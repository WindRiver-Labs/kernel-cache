
The issue at hand here is that the access_process_vm() calls
into get_user_pages which can sometimes call cond_resched().

If ptrace is servicing a breakpoint remove or planting a breakpoint,
a final call out to schedule() should not happen because the system
will be operating in the interrupt context already.

The example here is if ptrace is used to single step every line
of a forked child which exec'ed /bin/ls.  You can end
up with the many lines of errors printed by the kernel:

BUG: scheduling while atomic: ls/0x40000001/641

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 arch/arm/kernel/ptrace.c |   27 ++++++++++++++++++++++-----
 1 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 117e9f1..dba44c0 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -89,6 +89,23 @@ static u32 *thumbGetNpc(u16 instr,	/* the current instruction */
 #define BREAKINST_THUMB	0xde01
 #endif
 
+static inline int ptrace_access_process_vm(struct task_struct *tsk,
+			unsigned long addr,
+			void *buf,
+			int len,
+			int write)
+{
+	if (!(preempt_count() & PREEMPT_ACTIVE)) {
+		int ret;
+		add_preempt_count(PREEMPT_ACTIVE);
+		ret = access_process_vm(tsk, addr, buf, len, write);
+		sub_preempt_count(PREEMPT_ACTIVE);
+		return ret;
+	}
+
+	return access_process_vm(tsk, addr, buf, len, write);
+}
+
 /*
  * this routine will get a word off of the processes privileged stack.
  * the offset is how far from the base addr as stored in the THREAD.
@@ -128,7 +145,7 @@ read_u32(struct task_struct *task, unsigned long addr, u32 *res)
 {
 	int ret;
 
-	ret = access_process_vm(task, addr, res, sizeof(*res), 0);
+	ret = ptrace_access_process_vm(task, addr, res, sizeof(*res), 0);
 
 	return ret == sizeof(*res) ? 0 : -EIO;
 }
@@ -142,13 +159,13 @@ read_instr(struct task_struct *task, unsigned long addr, u32 *res,
 	if ((addr & 1) || is_thumb) {
 		u16 val;
 		pr_debug("%s: reading a THUMB instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	} else {
 		u32 val;
 		pr_debug("%s: reading an ARM instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	}
@@ -165,7 +182,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	pr_debug("%s new insn 0x%x for addr 0x%lx, size %d\n",
 	       __FUNCTION__, *((int *)new_insn), addr, size);
 
-	ret = access_process_vm(task, addr, old_insn, size, 0);
+	ret = ptrace_access_process_vm(task, addr, old_insn, size, 0);
 
 	if (size == 2) {
 		short old, new;
@@ -182,7 +199,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	}
 
 	if (ret == size)
-		ret = access_process_vm(task, addr, new_insn, size, 1);
+		ret = ptrace_access_process_vm(task, addr, new_insn, size, 1);
 	else
 		pr_debug("%s ERROR\n", __FUNCTION__);
 	return ret;
