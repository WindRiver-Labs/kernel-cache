From 0cb01eaa359c6207379aa50f729f9a430a7fa88b Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Tue, 13 Apr 2010 00:19:13 -0700
Subject: [PATCH 3/4] ptrace: scheduling while atomic fix for ARM.

The issue at hand here is that the access_process_vm() calls
into get_user_pages which can sometimes call cond_resched().

If ptrace is servicing a breakpoint remove or planting a breakpoint,
a final call out to schedule() should not happen because the system
will be operating in the interrupt context already.

The example here is if ptrace is used to single step every line
of a forked child which exec'ed /bin/ls.  You can end
up with the many lines of errors printed by the kernel:

BUG: scheduling while atomic: ls/0x40000001/641

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 arch/arm/kernel/ptrace.c |   27 ++++++++++++++++++++++-----
 1 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index a6d1078..acd6b94 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -89,6 +89,23 @@ static u32 *thumbGetNpc(u16 instr,	/* the current instruction */
 #define BREAKINST_THUMB	0xde01
 #endif
 
+static inline int ptrace_access_process_vm(struct task_struct *tsk,
+			unsigned long addr,
+			void *buf,
+			int len,
+			int write)
+{
+	if (!(preempt_count() & PREEMPT_ACTIVE)) {
+		int ret;
+		add_preempt_count(PREEMPT_ACTIVE);
+		ret = access_process_vm(tsk, addr, buf, len, write);
+		sub_preempt_count(PREEMPT_ACTIVE);
+		return ret;
+	}
+
+	return access_process_vm(tsk, addr, buf, len, write);
+}
+
 /*
  * this routine will get a word off of the processes privileged stack.
  * the offset is how far from the base addr as stored in the THREAD.
@@ -128,7 +145,7 @@ read_u32(struct task_struct *task, unsigned long addr, u32 *res)
 {
 	int ret;
 
-	ret = access_process_vm(task, addr, res, sizeof(*res), 0);
+	ret = ptrace_access_process_vm(task, addr, res, sizeof(*res), 0);
 
 	return ret == sizeof(*res) ? 0 : -EIO;
 }
@@ -142,13 +159,13 @@ read_instr(struct task_struct *task, unsigned long addr, u32 *res,
 	if ((addr & 1) || is_thumb) {
 		u16 val;
 		pr_debug("%s: reading a THUMB instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	} else {
 		u32 val;
 		pr_debug("%s: reading an ARM instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	}
@@ -165,7 +182,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	pr_debug("%s new insn 0x%x for addr 0x%lx, size %d\n",
 	       __FUNCTION__, *((int *)new_insn), addr, size);
 
-	ret = access_process_vm(task, addr, old_insn, size, 0);
+	ret = ptrace_access_process_vm(task, addr, old_insn, size, 0);
 
 	if (size == 2) {
 		short old, new;
@@ -182,7 +199,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	}
 
 	if (ret == size)
-		ret = access_process_vm(task, addr, new_insn, size, 1);
+		ret = ptrace_access_process_vm(task, addr, new_insn, size, 1);
 	else
 		pr_debug("%s ERROR\n", __FUNCTION__);
 	return ret;
-- 
1.6.5.2

