From ce27922cbf70da744f38a4ac88c524d456b8e333 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 11 Apr 2013 09:21:43 +0800
Subject: [PATCH] cpuidle: calibrate unstable TSC under idle

Some Intel CPUs have unstable TSCs.
When entering C-States, such as C3 or C5, the TSC will stop.
So, we need to calibrate the TSC when system is idle(C-State).

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/cpuidle/cpuidle.c |   17 +++++++++++++++++
 1 files changed, 17 insertions(+), 0 deletions(-)

diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 12fdd39..1c9f85e 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -52,6 +52,10 @@ static void cpuidle_idle_call(void)
 	struct cpuidle_device *dev = __get_cpu_var(cpuidle_devices);
 	struct cpuidle_state *target_state;
 	int next_state;
+#if defined(CONFIG_X86) && defined(CONFIG_HAVE_UNSYNCHRONIZED_TSC)
+	u64 tsc;
+	unsigned long flags;
+#endif
 
 	/* check if the device is ready */
 	if (!dev || !dev->enabled) {
@@ -85,7 +89,20 @@ static void cpuidle_idle_call(void)
 
 	/* enter the state and update stats */
 	dev->last_state = target_state;
+#if defined(CONFIG_X86) && defined(CONFIG_HAVE_UNSYNCHRONIZED_TSC)
+	tsc = get_cycles();
+#endif
 	dev->last_residency = target_state->enter(dev, target_state);
+	/* Some Intel CPUs have unstable TSCs.
+	 * When entering C-States, such as C3 or C5, the TSC will stop.
+	 * So, we need to calibrate the TSC when system is idle(C-State).
+	 */
+#if defined(CONFIG_X86) && defined(CONFIG_HAVE_UNSYNCHRONIZED_TSC)
+	tsc += (u64)(dev->last_residency)*(cpu_khz/1000);
+	local_irq_save(flags);
+	write_tsc((u32)tsc, (u32)((u64)tsc >> 32));
+	local_irq_restore(flags);
+#endif
 	if (dev->last_state)
 		target_state = dev->last_state;
 
-- 
1.7.0

