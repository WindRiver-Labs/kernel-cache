From c8460981d0e38f59854caa35fc39a699a794a131 Mon Sep 17 00:00:00 2001
From: "Junxian.Xiao" <Junxian.Xiao@windriver.com>
Date: Mon, 5 Sep 2016 04:36:51 +0800
Subject: [PATCH] rtmutex: Handle non enqueued waiters gracefully

Commit 2ae5b87eab12aa5773a4da028c2d386bfd4d9dc5 upstream

Yimin debugged that in case of a PI wakeup in progress when
rt_mutex_start_proxy_lock() calls task_blocks_on_rt_mutex() the latter
returns -EAGAIN and in consequence the remove_waiter() call runs into
a BUG_ON() because there is nothing to remove.

Guard it with rt_mutex_has_waiters(). This is a quick fix which is
easy to backport. The proper fix is to have a central check in
remove_waiter() so we can call it unconditionally.

Reported-and-debugged-by: Yimin Deng <yimin11.deng@gmail.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: stable-rt@vger.kernel.org
Signed-off-by: Junxian.Xiao <Junxian.Xiao@windriver.com>
---
 kernel/locking/rtmutex.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index 1ce0f6c..d3f8319 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -1285,7 +1285,7 @@ int rt_mutex_start_proxy_lock(struct rt_mutex *lock,
 		ret = 0;
 	}
 
-	if (unlikely(ret))
+	if (ret && rt_mutex_has_waiters(lock))
 		remove_waiter(lock, waiter);
 
 	raw_spin_unlock(&lock->wait_lock);
-- 
1.7.5.4

