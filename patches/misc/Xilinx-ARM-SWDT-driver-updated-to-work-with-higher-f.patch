From 432b516ce663a59ec2eadb22198b5a28cb2accc9 Mon Sep 17 00:00:00 2001
From: Andrei-Liviu Simion <andrei.simion@xilinx.com>
Date: Thu, 29 Mar 2012 18:40:17 -0700
Subject: [PATCH 079/628] Xilinx: ARM: SWDT driver updated to work with higher
 frequencies.

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 8c99f8ba8ec4614bca91beaebcf8dbfb95ed05ce

At higher frequencies:
- Depending on the timeout value, the timeout count calculation
was truncating some of the upper bits due to size overflow. The
order of the multiplication and divison has been changed to prevent
this.
- Sometimes, the WDZ bit would toggle to 1 but no reset would occur
despite the reset enable being set. To fix this, the reset length
was increased from 2 to 4 clock cycles.

Signed-off-by: Andrei-Liviu Simion <andrei.simion@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/watchdog/xilinx_wdtps.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/drivers/watchdog/xilinx_wdtps.c b/drivers/watchdog/xilinx_wdtps.c
index 4a6186d..dae161e 100644
--- a/drivers/watchdog/xilinx_wdtps.c
+++ b/drivers/watchdog/xilinx_wdtps.c
@@ -31,7 +31,7 @@
 #include <linux/of.h>
 
 #define XWDTPS_DEFAULT_TIMEOUT	10
-#define XWDTPS_MAX_TIMEOUT	400	/* Supports 1 - 400 sec */
+#define XWDTPS_MAX_TIMEOUT	516	/* Supports 1 - 516 sec */
 
 static int wdt_timeout = XWDTPS_DEFAULT_TIMEOUT;
 static int nowayout = WATCHDOG_NOWAYOUT;
@@ -97,7 +97,7 @@ static struct watchdog_info xwdtps_info = {
  */
 #define XWDTPS_ZMR_WDEN_MASK	0x00000001 /* Enable the WDT */
 #define XWDTPS_ZMR_RSTEN_MASK	0x00000002 /* Enable the reset output */
-#define XWDTPS_ZMR_RSTLEN_2	0x00000000 /* Reset pulse of 2 pclk cycles */
+#define XWDTPS_ZMR_RSTLEN_16	0x00000030 /* Reset pulse of 16 pclk cycles */
 #define XWDTPS_ZMR_ZKEY_VAL	0x00ABC000 /* Access key, 0xABC << 12 */
 /*
  * Counter Control register - This register controls how fast the timer runs
@@ -149,13 +149,13 @@ static void xwdtps_reload(void)
 static void xwdtps_start(void)
 {
 	unsigned int data = 0;
-	int count;
+	unsigned short count;
 
 	/*
 	 * 0x1000	- Counter Value Divide, to obtain the value of counter
 	 *		  reset to write to control register.
 	 */
-	count = (wdt_timeout * wdt_clock) / (wdt_prescalar * 0x1000) + 1;
+	count = ( wdt_timeout * (wdt_clock / wdt_prescalar) ) / 0x1000 + 1;
 
 	/* Check for boundary conditions of counter value */
 	if (count > 0xFFF)
@@ -174,7 +174,7 @@ static void xwdtps_start(void)
 	xwdtps_writereg(data, XWDTPS_CCR_OFFSET);
 
 	data = (XWDTPS_ZMR_WDEN_MASK | XWDTPS_ZMR_RSTEN_MASK | \
-		XWDTPS_ZMR_RSTLEN_2 | XWDTPS_ZMR_ZKEY_VAL);
+		XWDTPS_ZMR_RSTLEN_16 | XWDTPS_ZMR_ZKEY_VAL);
 	xwdtps_writereg(data, XWDTPS_ZMR_OFFSET);
 	spin_unlock(&wdt->io_lock);
 	xwdtps_writereg(0x00001999, XWDTPS_RESTART_OFFSET);
-- 
1.7.5.4

