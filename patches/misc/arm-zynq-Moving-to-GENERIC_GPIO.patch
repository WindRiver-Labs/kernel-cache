From f927305ff0ccc49e3e4f8bc51e199dec5d078304 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Thu, 29 Nov 2012 17:43:13 +0100
Subject: [PATCH 347/628] arm: zynq: Moving to GENERIC_GPIO

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 52c255e438108c829bb9a1a78dba83dc2bfc09e2

There is only one difference in irq_to_gpio function.
The rest is completely the same with GENERIC_GPIO
implementation.

Partial rework based on the patch from Stefan Roese <sr@denx.de>.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
[make some slight adjustments for Kconfig]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/Kconfig             |    4 +-
 drivers/gpio/gpio-xilinxps.c |   46 +++++++++++++++++++++++++++--------------
 2 files changed, 32 insertions(+), 18 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index e079fe2..6a5f794 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -3,7 +3,7 @@ config ARM
 	default y
 	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
-	select ARCH_HAVE_CUSTOM_GPIO_H
+	select ARCH_HAVE_CUSTOM_GPIO_H if (!ARCH_ZYNQ)
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
 	select ARCH_WANT_IPC_PARSE_VERSION
 	select BUILDTIME_EXTABLE_SORT if MMU
@@ -1628,7 +1628,7 @@ config LOCAL_TIMERS
 # selected platforms.
 config ARCH_NR_GPIO
 	int
-	default 1024 if ARCH_SHMOBILE || ARCH_TEGRA
+	default 1024 if ARCH_SHMOBILE || ARCH_TEGRA || ARCH_ZYNQ
 	default 512 if SOC_OMAP5 || SOC_DRA7XX
 	default 392 if ARCH_U8500
 	default 352 if ARCH_VT8500
diff --git a/drivers/gpio/gpio-xilinxps.c b/drivers/gpio/gpio-xilinxps.c
index f3802e6..908ffa8 100644
--- a/drivers/gpio/gpio-xilinxps.c
+++ b/drivers/gpio/gpio-xilinxps.c
@@ -27,10 +27,13 @@
 #include <linux/pm_wakeup.h>
 #include <linux/slab.h>
 #include <asm/mach/irq.h>
+#include <linux/irqdomain.h>
 
 #define DRIVER_NAME "xgpiops"
 #define XGPIOPS_NR_GPIOS	118
 
+static struct irq_domain *irq_domain;
+
 /* Register offsets for the GPIO device */
 
 #define XGPIOPS_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK)) /* LSW Mask &
@@ -85,6 +88,7 @@ struct xgpiops {
 	struct gpio_chip chip;
 	void __iomem *base_addr;
 	unsigned int irq;
+	unsigned int irq_base;
 	struct clk *clk;
 	spinlock_t gpio_lock;
 };
@@ -232,9 +236,7 @@ static int xgpiops_dir_out(struct gpio_chip *chip, unsigned int pin, int state)
 
 static int xgpiops_to_irq(struct gpio_chip *chip, unsigned offset)
 {
-	if (offset < XGPIOPS_NR_GPIOS)
-		return XGPIOPS_IRQBASE + offset;
-	return -ENODEV;
+	return irq_find_mapping(irq_domain, offset);
 }
 
 /**
@@ -249,7 +251,7 @@ static void xgpiops_irq_ack(struct irq_data *irq_data)
 	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
-	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	device_pin_num = irq_data->hwirq;
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
 	xgpiops_writereg(1 << bank_pin_num, gpio->base_addr +
 			(XGPIOPS_INTSTS_OFFSET(bank_num)));
@@ -268,7 +270,7 @@ static void xgpiops_irq_mask(struct irq_data *irq_data)
 	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
-	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	device_pin_num = irq_data->hwirq;
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
 	xgpiops_writereg(1 << bank_pin_num,
 			  gpio->base_addr + XGPIOPS_INTDIS_OFFSET(bank_num));
@@ -287,7 +289,7 @@ static void xgpiops_irq_unmask(struct irq_data *irq_data)
 	struct xgpiops *gpio = irq_data_get_irq_chip_data(irq_data);
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 
-	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	device_pin_num = irq_data->hwirq;
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
 	xgpiops_writereg(1 << bank_pin_num,
 			  gpio->base_addr + XGPIOPS_INTEN_OFFSET(bank_num));
@@ -313,7 +315,7 @@ static int xgpiops_set_irq_type(struct irq_data *irq_data, unsigned int type)
 	unsigned int device_pin_num, bank_num, bank_pin_num;
 	unsigned int int_type, int_pol, int_any;
 
-	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	device_pin_num = irq_data->hwirq;
 	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
 
 	int_type = xgpiops_readreg(gpio->base_addr +
@@ -396,8 +398,8 @@ static struct irq_chip xgpiops_irqchip = {
  */
 static void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
 {
-	int gpio_irq = (int)irq_get_handler_data(irq);
-	struct xgpiops *gpio = (struct xgpiops *)irq_get_chip_data(gpio_irq);
+	struct xgpiops *gpio = (struct xgpiops *)irq_get_handler_data(irq);
+	int gpio_irq = gpio->irq_base;
 	unsigned int int_sts, int_enb, bank_num;
 	struct irq_desc *gpio_irq_desc;
 	struct irq_chip *chip = irq_desc_get_chip(desc);
@@ -602,6 +604,18 @@ static int __devinit xgpiops_probe(struct platform_device *pdev)
 	chip->ngpio = XGPIOPS_NR_GPIOS;
 	chip->can_sleep = 0;
 
+	/* FIXME Setup 0 instead of 256 when PCIe is fixed */
+	gpio->irq_base = irq_alloc_descs(-1, 256, chip->ngpio, 0);
+	if (gpio->irq_base < 0) {
+		dev_err(&pdev->dev, "Couldn't allocate IRQ numbers\n");
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+
+	irq_domain = irq_domain_add_legacy(pdev->dev.of_node,
+					   chip->ngpio, gpio->irq_base, 0,
+					   &irq_domain_simple_ops, NULL);
+
 	/* report a bug if gpio chip registration fails */
 	ret = gpiochip_add(chip);
 	if (ret < 0) {
@@ -636,16 +650,16 @@ static int __devinit xgpiops_probe(struct platform_device *pdev)
 	 * set the irq chip, handler and irq chip data for callbacks for
 	 * each pin
 	 */
-	gpio_irq = XGPIOPS_IRQBASE;
-	for (pin_num = 0; pin_num < XGPIOPS_NR_GPIOS; pin_num++, gpio_irq++) {
-		irq_set_chip(gpio_irq, &xgpiops_irqchip);
+	for (pin_num = 0; pin_num < min_t(int, XGPIOPS_NR_GPIOS,
+						(int)chip->ngpio); pin_num++) {
+		gpio_irq = irq_find_mapping(irq_domain, pin_num);
+		irq_set_chip_and_handler(gpio_irq, &xgpiops_irqchip,
+							handle_simple_irq);
 		irq_set_chip_data(gpio_irq, (void *)gpio);
-		irq_set_handler(gpio_irq, handle_simple_irq);
-		irq_set_status_flags(gpio_irq, IRQF_VALID);
-		irq_clear_status_flags(gpio_irq, IRQ_NOREQUEST);
+		set_irq_flags(gpio_irq, IRQF_VALID);
 	}
 
-	irq_set_handler_data(irq_num, (void *)(XGPIOPS_IRQBASE));
+	irq_set_handler_data(irq_num, (void *)gpio);
 	irq_set_chained_handler(irq_num, xgpiops_irqhandler);
 
 	xgpiops_pm_runtime_init(pdev);
-- 
1.7.5.4

