From 49284d3c1e6ffcf61e1d5312fa89fb5c384bbcc4 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Wed, 14 Jan 2015 11:42:12 -0800
Subject: [PATCH] fs/jffs2: fix a locking order bug in garbage collect path

Under certain workload the following crash can be observed on jffs2,
the reason is that the commit "jffs2: Fix lock acquisition order bug
in jffs2_write_begin" introduces a incorrect locking order bug in
jffs2_read and jffs2_garbage_collect path, this patch fixes this bug
by reverting the above commit and changing lock_page to trylock_page
to avoid the dead lock in garbage collect pass.

The idea is from "http://patchwork.ozlabs.org/patch/269823".

INFO: task jffs2_gcd_mtd12:493 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c4abfc90] [c0007bf0] __switch_to+0x64/0xd0
[c4abfca0] [c058f518] schedule+0x258/0x638
[c4abfd20] [c058f954] io_schedule+0x5c/0x90
[c4abfd30] [c00bde60] sync_page+0x54/0x74
[c4abfd40] [c058fec8] __wait_on_bit_lock+0x9c/0x108
[c4abfd70] [c00bddd8] __lock_page+0x88/0x98
[c4abfda0] [c00be810] do_read_cache_page+0x188/0x1a4
[c4abfde0] [e16d8514] jffs2_gc_fetch_page+0x30/0xac [jffs2]
[c4abfdf0] [e16d5ab0] jffs2_garbage_collect_live+0x4c0/0xec4 [jffs2]
[c4abfea0] [e16d6aa8] jffs2_garbage_collect_pass+0x5f4/0x738 [jffs2]
[c4abff00] [e16d8374] jffs2_garbage_collect_thread+0x188/0x1a0 [jffs2]
[c4abffb0] [c00665c4] kthread+0x78/0x7c
[c4abfff0] [c000fae4] original_kernel_thread+0x4c/0x68
INFO: task mytest:1237 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c43e7ba0] [c0007bf0] __switch_to+0x64/0xd0
[c43e7bb0] [c058f518] schedule+0x258/0x638
[c43e7c30] [c059039c] __mutex_lock_slowpath+0x174/0x230
[c43e7c80] [c05904a8] mutex_lock+0x50/0x54
[c43e7c90] [e16cdeac] jffs2_write_begin+0xf0/0x2d4 [jffs2]
[c43e7d10] [c00bd260] generic_file_buffered_write+0x1b4/0x290
[c43e7da0] [c00bf70c] __generic_file_aio_write+0x33c/0x508
[c43e7e10] [c00bf948] generic_file_aio_write+0x70/0xf0
[c43e7e40] [c00fefec] do_sync_write+0xac/0x120
[c43e7ee0] [c00ffcbc] vfs_write+0xb4/0x158
[c43e7f00] [c00ffed4] sys_write+0x50/0x10c
[c43e7f40] [c000fdcc] ret_from_syscall+0x0/0x4

Signed-off-by: Shan Hai <shan.hai@windriver.com>
[Since stable commit 034c4b3e ("mm: remove read_cache_page_async()") removed
read_cache_page_async, so it doesn't make sense anymore to keep
read_cache_page_async_nowait]
Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 fs/jffs2/file.c | 40 +++++++++++++++++++---------------------
 fs/jffs2/gc.c   |  8 +++++++-
 2 files changed, 26 insertions(+), 22 deletions(-)

diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 256cd19..1744423 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -139,39 +139,34 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	struct page *pg;
 	struct inode *inode = mapping->host;
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	struct jffs2_raw_inode ri;
-	uint32_t alloc_len = 0;
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 	uint32_t pageofs = index << PAGE_CACHE_SHIFT;
 	int ret = 0;
 
-	jffs2_dbg(1, "%s()\n", __func__);
-
-	if (pageofs > inode->i_size) {
-		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
-					  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
-		if (ret)
-			return ret;
-	}
-
-	mutex_lock(&f->sem);
 	pg = grab_cache_page_write_begin(mapping, index, flags);
-	if (!pg) {
-		if (alloc_len)
-			jffs2_complete_reservation(c);
-		mutex_unlock(&f->sem);
+	if (!pg)
 		return -ENOMEM;
-	}
+
 	*pagep = pg;
 
-	if (alloc_len) {
+	jffs2_dbg(1, "%s()\n", __func__);
+
+	if (pageofs > inode->i_size) {
 		/* Make new hole frag from old EOF to new page */
+		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+		struct jffs2_raw_inode ri;
 		struct jffs2_full_dnode *fn;
+		uint32_t alloc_len;
 
 		jffs2_dbg(1, "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
 			  (unsigned int)inode->i_size, pageofs);
 
+		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
+					ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
+		if (ret)
+			goto out_page;
+
+		mutex_lock(&f->sem);
 		memset(&ri, 0, sizeof(ri));
 
 		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
@@ -198,6 +193,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 		if (IS_ERR(fn)) {
 			ret = PTR_ERR(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
@@ -212,10 +208,12 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 			jffs2_mark_node_obsolete(c, fn->raw);
 			jffs2_free_full_dnode(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		jffs2_complete_reservation(c);
 		inode->i_size = pageofs;
+		mutex_unlock(&f->sem);
 	}
 
 	/*
@@ -224,18 +222,18 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	 * case of a short-copy.
 	 */
 	if (!PageUptodate(pg)) {
+		mutex_lock(&f->sem);
 		ret = jffs2_do_readpage_nolock(inode, pg);
+		mutex_unlock(&f->sem);
 		if (ret)
 			goto out_page;
 	}
-	mutex_unlock(&f->sem);
 	jffs2_dbg(1, "end write_begin(). pg->flags %lx\n", pg->flags);
 	return ret;
 
 out_page:
 	unlock_page(pg);
 	page_cache_release(pg);
-	mutex_unlock(&f->sem);
 	return ret;
 }
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 5a2dec2..e7105d1 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -445,6 +445,9 @@ int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
 
 	jffs2_gc_release_inode(c, f);
 
+	if (!ret)
+		goto release_sem;
+
  test_gcnode:
 	if (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {
 		/* Eep. This really should never happen. GC is broken */
@@ -1308,7 +1311,10 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 	if (IS_ERR(pg_ptr)) {
 		pr_warn("read_cache_page() returned error: %ld\n",
 			PTR_ERR(pg_ptr));
-		return PTR_ERR(pg_ptr);
+		if (PTR_ERR(pg_ptr) == -EBUSY)
+			 return 0;
+		else
+			return PTR_ERR(pg_ptr);
 	}
 
 	offset = start;
-- 
2.0.2

