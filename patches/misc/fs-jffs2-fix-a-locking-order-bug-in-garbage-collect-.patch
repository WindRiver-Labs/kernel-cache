From 66130b01f0bbd23a3bb03178e3d29bb184654bf2 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Fri, 14 Nov 2014 15:40:25 +0800
Subject: [PATCH] fs/jffs2: fix a locking order bug in garbage collect path

Under certain workload the following crash can be observed on jffs2,
the reason is that the commit "jffs2: Fix lock acquisition order bug
in jffs2_write_begin" introduces a incorrect locking order bug in
jffs2_read and jffs2_garbage_collect path, this patch fixes this bug
by reverting the above commit and changing lock_page to trylock_page
to avoid the dead lock in garbage collect pass.

The idea is from "http://patchwork.ozlabs.org/patch/269823".

INFO: task jffs2_gcd_mtd12:493 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c4abfc90] [c0007bf0] __switch_to+0x64/0xd0
[c4abfca0] [c058f518] schedule+0x258/0x638
[c4abfd20] [c058f954] io_schedule+0x5c/0x90
[c4abfd30] [c00bde60] sync_page+0x54/0x74
[c4abfd40] [c058fec8] __wait_on_bit_lock+0x9c/0x108
[c4abfd70] [c00bddd8] __lock_page+0x88/0x98
[c4abfda0] [c00be810] do_read_cache_page+0x188/0x1a4
[c4abfde0] [e16d8514] jffs2_gc_fetch_page+0x30/0xac [jffs2]
[c4abfdf0] [e16d5ab0] jffs2_garbage_collect_live+0x4c0/0xec4 [jffs2]
[c4abfea0] [e16d6aa8] jffs2_garbage_collect_pass+0x5f4/0x738 [jffs2]
[c4abff00] [e16d8374] jffs2_garbage_collect_thread+0x188/0x1a0 [jffs2]
[c4abffb0] [c00665c4] kthread+0x78/0x7c
[c4abfff0] [c000fae4] original_kernel_thread+0x4c/0x68
INFO: task mytest:1237 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c43e7ba0] [c0007bf0] __switch_to+0x64/0xd0
[c43e7bb0] [c058f518] schedule+0x258/0x638
[c43e7c30] [c059039c] __mutex_lock_slowpath+0x174/0x230
[c43e7c80] [c05904a8] mutex_lock+0x50/0x54
[c43e7c90] [e16cdeac] jffs2_write_begin+0xf0/0x2d4 [jffs2]
[c43e7d10] [c00bd260] generic_file_buffered_write+0x1b4/0x290
[c43e7da0] [c00bf70c] __generic_file_aio_write+0x33c/0x508
[c43e7e10] [c00bf948] generic_file_aio_write+0x70/0xf0
[c43e7e40] [c00fefec] do_sync_write+0xac/0x120
[c43e7ee0] [c00ffcbc] vfs_write+0xb4/0x158
[c43e7f00] [c00ffed4] sys_write+0x50/0x10c
[c43e7f40] [c000fdcc] ret_from_syscall+0x0/0x4

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 fs/jffs2/file.c         |   40 +++++++++++++++++++---------------------
 fs/jffs2/fs.c           |    5 +++--
 fs/jffs2/gc.c           |    8 +++++++-
 include/linux/pagemap.h |    3 +++
 mm/filemap.c            |   41 +++++++++++++++++++++++++++++++++++++++++
 5 files changed, 73 insertions(+), 24 deletions(-)

diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 256cd19..1744423 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -139,39 +139,34 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	struct page *pg;
 	struct inode *inode = mapping->host;
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	struct jffs2_raw_inode ri;
-	uint32_t alloc_len = 0;
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 	uint32_t pageofs = index << PAGE_CACHE_SHIFT;
 	int ret = 0;
 
-	jffs2_dbg(1, "%s()\n", __func__);
-
-	if (pageofs > inode->i_size) {
-		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
-					  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
-		if (ret)
-			return ret;
-	}
-
-	mutex_lock(&f->sem);
 	pg = grab_cache_page_write_begin(mapping, index, flags);
-	if (!pg) {
-		if (alloc_len)
-			jffs2_complete_reservation(c);
-		mutex_unlock(&f->sem);
+	if (!pg)
 		return -ENOMEM;
-	}
+
 	*pagep = pg;
 
-	if (alloc_len) {
+	jffs2_dbg(1, "%s()\n", __func__);
+
+	if (pageofs > inode->i_size) {
 		/* Make new hole frag from old EOF to new page */
+		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+		struct jffs2_raw_inode ri;
 		struct jffs2_full_dnode *fn;
+		uint32_t alloc_len;
 
 		jffs2_dbg(1, "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
 			  (unsigned int)inode->i_size, pageofs);
 
+		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
+					ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
+		if (ret)
+			goto out_page;
+
+		mutex_lock(&f->sem);
 		memset(&ri, 0, sizeof(ri));
 
 		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
@@ -198,6 +193,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 		if (IS_ERR(fn)) {
 			ret = PTR_ERR(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
@@ -212,10 +208,12 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 			jffs2_mark_node_obsolete(c, fn->raw);
 			jffs2_free_full_dnode(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		jffs2_complete_reservation(c);
 		inode->i_size = pageofs;
+		mutex_unlock(&f->sem);
 	}
 
 	/*
@@ -224,18 +222,18 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	 * case of a short-copy.
 	 */
 	if (!PageUptodate(pg)) {
+		mutex_lock(&f->sem);
 		ret = jffs2_do_readpage_nolock(inode, pg);
+		mutex_unlock(&f->sem);
 		if (ret)
 			goto out_page;
 	}
-	mutex_unlock(&f->sem);
 	jffs2_dbg(1, "end write_begin(). pg->flags %lx\n", pg->flags);
 	return ret;
 
 out_page:
 	unlock_page(pg);
 	page_cache_release(pg);
-	mutex_unlock(&f->sem);
 	return ret;
 }
 
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index a69e426..c1dcdbd 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -687,8 +687,9 @@ unsigned char *jffs2_gc_fetch_page(struct jffs2_sb_info *c,
 	struct inode *inode = OFNI_EDONI_2SFFJ(f);
 	struct page *pg;
 
-	pg = read_cache_page_async(inode->i_mapping, offset >> PAGE_CACHE_SHIFT,
-			     (void *)jffs2_do_readpage_unlock, inode);
+	pg = read_cache_page_async_nowait(inode->i_mapping,
+				offset >> PAGE_CACHE_SHIFT,
+				(void *)jffs2_do_readpage_unlock, inode);
 	if (IS_ERR(pg))
 		return (void *)pg;
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 5a2dec2..e7105d1 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -445,6 +445,9 @@ int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
 
 	jffs2_gc_release_inode(c, f);
 
+	if (!ret)
+		goto release_sem;
+
  test_gcnode:
 	if (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {
 		/* Eep. This really should never happen. GC is broken */
@@ -1308,7 +1311,10 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 	if (IS_ERR(pg_ptr)) {
 		pr_warn("read_cache_page() returned error: %ld\n",
 			PTR_ERR(pg_ptr));
-		return PTR_ERR(pg_ptr);
+		if (PTR_ERR(pg_ptr) == -EBUSY)
+			 return 0;
+		else
+			return PTR_ERR(pg_ptr);
 	}
 
 	offset = start;
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 1710d1b..5bd2e4d 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -272,6 +272,9 @@ extern struct page * grab_cache_page_nowait(struct address_space *mapping,
 				pgoff_t index);
 extern struct page * read_cache_page_async(struct address_space *mapping,
 				pgoff_t index, filler_t *filler, void *data);
+extern struct page * read_cache_page_async_nowait(struct address_space *mapping,
+				pgoff_t index, filler_t *filler,
+				void *data);
 extern struct page * read_cache_page(struct address_space *mapping,
 				pgoff_t index, filler_t *filler, void *data);
 extern struct page * read_cache_page_gfp(struct address_space *mapping,
diff --git a/mm/filemap.c b/mm/filemap.c
index 720b3d3..6801c3e 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1889,6 +1889,47 @@ struct page *read_cache_page_async(struct address_space *mapping,
 }
 EXPORT_SYMBOL(read_cache_page_async);
 
+struct page *read_cache_page_async_nowait(struct address_space *mapping,
+                                pgoff_t index,
+                                int (*filler)(void *,struct page*),
+                                void *data)
+
+{
+        struct page *page;
+        int err;
+
+retry:
+        page = __read_cache_page(mapping, index, filler, data, mapping_gfp_mask(mapping));
+        if (IS_ERR(page))
+                return page;
+        if (PageUptodate(page))
+                goto out;
+
+        if (!trylock_page(page)) {
+                page_cache_release(page);
+		return ERR_PTR(-EBUSY);
+	}
+
+        if (!page->mapping) {
+                unlock_page(page);
+                page_cache_release(page);
+                goto retry;
+        }
+        if (PageUptodate(page)) {
+                unlock_page(page);
+                goto out;
+        }
+        err = filler(data, page);
+        if (err < 0) {
+                page_cache_release(page);
+                return ERR_PTR(err);
+        }
+out:
+        mark_page_accessed(page);
+        return page;
+}
+EXPORT_SYMBOL(read_cache_page_async_nowait);
+
 static struct page *wait_on_page_read(struct page *page)
 {
 	if (!IS_ERR(page)) {
-- 
1.7.5.4

