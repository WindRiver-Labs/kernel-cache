From 5d19dbf354074d18f17061aee7882c4aed8938aa Mon Sep 17 00:00:00 2001
From: Ming Liu <ming.liu@windriver.com>
Date: Thu, 24 Jan 2013 16:24:31 +0800
Subject: [PATCH 07/12] timekeeping: Maintain ktime_t based offsets for hrtimers

commit 5b9fe759a678e05be4937ddf03d50e950207c1c0 upstream.

We need to update the hrtimer clock offsets from the hrtimer interrupt
context. To avoid conversions from timespec to ktime_t maintain a
ktime_t based representation of those offsets in the timekeeper. This
puts the conversion overhead into the code which updates the
underlying offsets and provides fast accessible values in the hrtimer
interrupt.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: John Stultz <johnstul@us.ibm.com>
Reviewed-by: Ingo Molnar <mingo@kernel.org>
Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Acked-by: Prarit Bhargava <prarit@redhat.com>
Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Prarit Bhargava <prarit@redhat.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Linux Kernel <linux-kernel@vger.kernel.org>
Signed-off-by: John Stultz <johnstul@us.ibm.com>
Integrated-by: Ming Liu <ming.liu@windriver.com>
---
 kernel/time/timekeeping.c |   30 +++++++++++++++++++++++++++++-
 1 files changed, 29 insertions(+), 1 deletions(-)

diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 53c2538..c1afc16 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -46,6 +46,21 @@ struct timespec xtime __attribute__ ((aligned (16)));
 struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
 static unsigned long total_sleep_time;		/* seconds */
 
+/* Offset clock monotonic -> clock realtime */
+static ktime_t offs_real;
+
+/* Offset clock monotonic -> clock boottime */
+static ktime_t offs_boot;
+
+/* must hold write on xtime_lock */
+static void update_rt_offset(void)
+{
+	struct timespec tmp, *wtm = &wall_to_monotonic;
+
+	set_normalized_timespec(&tmp, -wtm->tv_sec, -wtm->tv_nsec);
+	offs_real = timespec_to_ktime(tmp);
+}
+
 /* must hold write on xtime_lock */
 static void timekeeping_update(bool clearntp)
 {
@@ -53,6 +68,7 @@ static void timekeeping_update(bool clearntp)
 		clock->error = 0;
 		ntp_clear();
 	}
+	update_rt_offset();
 	update_vsyscall(&xtime, clock);
 }
 
@@ -270,6 +286,7 @@ void __init timekeeping_init(void)
 	set_normalized_timespec(&wall_to_monotonic,
 		-xtime.tv_sec, -xtime.tv_nsec);
 	update_xtime_cache(0);
+	update_rt_offset();
 	total_sleep_time = 0;
 	write_sequnlock_irqrestore(&xtime_lock, flags);
 }
@@ -277,6 +294,17 @@ void __init timekeeping_init(void)
 /* time in seconds when suspend began */
 static unsigned long timekeeping_suspend_time;
 
+static void update_sleep_time(unsigned long t)
+{
+	struct timespec ts;
+
+	total_sleep_time = t;
+
+	ts.tv_sec = t;
+	ts.tv_nsec = 0;
+	offs_boot = timespec_to_ktime(ts);
+}
+
 /**
  * timekeeping_resume - Resumes the generic timekeeping subsystem.
  * @dev:	unused
@@ -299,7 +327,7 @@ static int timekeeping_resume(struct sys_device *dev)
 
 		xtime.tv_sec += sleep_length;
 		wall_to_monotonic.tv_sec -= sleep_length;
-		total_sleep_time += sleep_length;
+		update_sleep_time(total_sleep_time + sleep_length);
 	}
 	update_xtime_cache(0);
 	/* re-base the last cycle value */
-- 
1.7.0.2

