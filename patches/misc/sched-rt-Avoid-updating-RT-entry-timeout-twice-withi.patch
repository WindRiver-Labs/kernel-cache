From 2807a9f1b88d5e940d6052c672b5c73364996d9b Mon Sep 17 00:00:00 2001
From: Xue Ying <ying.xue@windriver.com>
Date: Tue, 24 Jul 2012 16:07:47 +0800
Subject: [PATCH] sched/rt: Avoid updating RT entry timeout twice within one
 tick period

After softirqs are threaded, it means there has at least one RT FIFO task
per cpu. The priority of these tasks is set to 50 by default. If user
launches an RT FIFO task with priority lower than 50 of softirq RT tasks,
it's possible there have two RT FIFO tasks enqueued one cpu runqueue at
one moment. By current strategy of balancing RT tasks, when it comes to
RT tasks, we really need to put them off to a CPU that they can run on
as soon as possible. Even if it means a bit of cache line flushing, but
we can let RT task be run within the least latencies.

For example, when the user RT FIFO task is running, tick sched timer of
current cpu happens. In this tick period, timeout value of the current
RT task will be updated once. Subsequently, we try to wake up the softirq
RT task on the current runqueue. As the priority of current RT task is
lower than the softirq RT task, the current task is preempted by the
higher priority softirq RT task. At the time, we check to see if current
can readily move to a different cpu, If so, we will reschedule to allow
RT push logic to try to move current somewhere else. Whenever the woken
softirq RT task runs, it first tries to migrate the user FIFO RT task
over to a cpu that is running a task of lesser priority. If done, it will
send an reschedule order to the found cpu by IPI interrupt. Once the
target cpu responds the IPI interrupt, it will pick the migrated user RT
task to preempt its current task. When the user RT task is running
on the new cpu, the tick sched timer of the cpu occurs. So it will tick
the user task again. This also means the RT timeout value will be
updated again. As the migration may be done in one tick period, it means
the user RT task timeout value will be updated two times within one tick.

If we set a limit on the amount of cpu time for the user RT task by
setrlimit(RLIMIT_RTTIME), the SIGXCPU signal should be posted upon
reaching the soft limit.

The timeout mechansim of sending SIGXCPU signal hopes the RT task
timeout is increased once every tick. However, currently the timeout
value may be added twice per tick. So it results in the SIGXCPU signal
being sent earlier than our expected.

To solve the issue, we prevent the timeout value from increasing twice
within one tick time by remembering the jiffies value of lastly updating
the timeout. As long as the RT task's jiffies is different with the
global jiffies value, we allow its timeout to be updated.

Signed-off-by: Xue Ying <ying.xue@windriver.com>
Signed-off-by: fan du <fan.du@windriver.com>
---
 include/linux/sched.h |    1 +
 kernel/sched_rt.c     |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 4afbe4a..28b0c8f 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1205,6 +1205,7 @@ struct sched_entity {
 struct sched_rt_entity {
 	struct list_head run_list;
 	unsigned long timeout;
+	unsigned long watchdog_stamp;
 	unsigned int time_slice;
 	int nr_cpus_allowed;
 
diff --git a/kernel/sched_rt.c b/kernel/sched_rt.c
index fd8c1a3..a435e2a 100644
--- a/kernel/sched_rt.c
+++ b/kernel/sched_rt.c
@@ -1673,7 +1673,11 @@ static void watchdog(struct rq *rq, struct task_struct *p)
 	if (soft != RLIM_INFINITY) {
 		unsigned long next;
 
-		p->rt.timeout++;
+		if (p->rt.watchdog_stamp != jiffies) {
+			p->rt.timeout++;
+			p->rt.watchdog_stamp = jiffies;
+		}
+
 		next = DIV_ROUND_UP(min(soft, hard), USEC_PER_SEC/HZ);
 		if (p->rt.timeout > next)
 			p->cputime_expires.sched_exp = p->se.sum_exec_runtime;
-- 
1.7.9.7

