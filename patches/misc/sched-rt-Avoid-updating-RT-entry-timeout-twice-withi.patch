From d6b9a61cad4c61482e3517504b2cffa9f765b620 Mon Sep 17 00:00:00 2001
From: Xue Ying <ying.xue@windriver.com>
Date: Tue, 24 Jul 2012 09:51:22 +0800
Subject: [PATCH] sched/rt: Avoid updating RT entry timeout twice within one
 tick period

After softirqs are threaded, it means there has at least one RT FIFO task
per cpu. The priority of these tasks is set to 50 by default. If user
launches an RT FIFO task with priority lower than 50 of softirq RT tasks,
it's possible there have two RT FIFO tasks enqueued one cpu runqueue at
one moment. By current strategy of balancing RT tasks, when it comes to
RT tasks, we really need to put them off to a CPU that they can run on
as soon as possible. Even if it means a bit of cache line flushing, but
we can let RT task be run within the least latencies.

For example, when the user RT FIFO task is running, tick sched timer of
current cpu happens. In this tick period, timeout value of the current
RT task will be updated once. Subsequently, we try to wake up the softirq
RT task on the current runqueue. As the priority of current RT task is
lower than the softirq RT task, the current task is preempted by the
higher priority softirq RT task. At the time, we check to see if current
can readily move to a different cpu, If so, we will reschedule to allow
RT push logic to try to move current somewhere else. Whenever the woken
softirq RT task runs, it first tries to migrate the user FIFO RT task
over to a cpu that is running a task of lesser priority. If done, it will
send an reschedule order to the found cpu by IPI interrupt. Once the
target cpu responds the IPI interrupt, it will pick the migrated user RT
task to preempt its current task. When the user RT task is running
on the new cpu, the tick sched timer of the cpu occurs. So it will tick
the user task again. This also means the RT timeout value will be
updated again. As the migration may be done in one tick period, it means
the user RT task timeout value will be updated two times within one tick.

If we set a limit on the amount of cpu time for the user RT task by
setrlimit(RLIMIT_RTTIME), the SIGXCPU signal should be posted upon
reaching the soft limit.

The timeout mechansim of sending SIGXCPU signal hopes the RT task
timeout is increased once every tick. However, currently the timeout
value may be added twice per tick. So it results in the SIGXCPU signal
being sent earlier than our expected.

To solve the issue, we prevent the timeout value from increasing twice
within one tick time by remembering the jiffies value of lastly updating
the timeout. As long as the RT task's jiffies is different with the
global jiffies value, we allow its timeout to be updated.

Signed-off-by: Xue Ying <ying.xue@windriver.com>
Signed-off-by: fan du <fan.du@windriver.com>
---
 include/linux/sched.h |    1 +
 kernel/sched_rt.c     |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5f55286..e8c46ec 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1024,6 +1024,7 @@ struct sched_rt_entity {
 	struct list_head run_list;
 	unsigned int time_slice;
 	unsigned long timeout;
+	unsigned long watchdog_stamp;
 	int nr_cpus_allowed;
 
 	struct sched_rt_entity *back;
diff --git a/kernel/sched_rt.c b/kernel/sched_rt.c
index 68c4745..5b6f620 100644
--- a/kernel/sched_rt.c
+++ b/kernel/sched_rt.c
@@ -1410,7 +1410,11 @@ static void watchdog(struct rq *rq, struct task_struct *p)
 	if (soft != RLIM_INFINITY) {
 		unsigned long next;
 
-		p->rt.timeout++;
+		if (p->rt.watchdog_stamp != jiffies) {
+			p->rt.timeout++;
+			p->rt.watchdog_stamp = jiffies;
+		}
+
 		next = DIV_ROUND_UP(min(soft, hard), USEC_PER_SEC/HZ);
 		if (p->rt.timeout > next)
 			p->it_sched_expires = p->se.sum_exec_runtime;
-- 
1.7.9.7

