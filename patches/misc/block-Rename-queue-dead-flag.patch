From 99028302e2c22ea4ffb92371b6931cb8fc1f6348 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Mon, 30 Jun 2014 13:16:31 +0800
Subject: [PATCH 1/3] block: Rename queue dead flag

based on commit 3f3299d5c0268d6cc3f47b446e8aca436e4a5651 upstream
(block: Rename queue dead flag)

Inspired by the above upstream commit to run script from it over the
current kernel source tree to generate this patch, because the original
commit depends on huge number of upstream commits and could not be applied
properly.

This patch has been generated by running the following command over the
kernel source tree:

git grep -lEw 'blk_queue_dead|QUEUE_FLAG_DEAD' |
    xargs sed -i.tmp -e 's/blk_queue_dead/blk_queue_dying/g'      \
        -e 's/QUEUE_FLAG_DEAD/QUEUE_FLAG_DYING/g';                \
sed -i.tmp -e "s/QUEUE_FLAG_DYING$(printf \\t)*5/QUEUE_FLAG_DYING$(printf \\t)5/g" \
    include/linux/blkdev.h;                                       \
sed -i.tmp -e 's/ DEAD/ DYING/g' -e 's/dead queue/a dying queue/' \
    -e 's/Dead queue/A dying queue/' block/blk-core.c

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 block/blk-core.c       |    8 ++++----
 block/blk-sysfs.c      |    4 ++--
 block/blk.h            |    2 +-
 block/elevator.c       |    2 +-
 drivers/block/ub.c     |    2 +-
 include/linux/blkdev.h |    2 +-
 6 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/block/blk-core.c b/block/blk-core.c
index 85d09ba..5b75e65 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -445,7 +445,7 @@ EXPORT_SYMBOL(blk_put_queue);
  * Note: If a driver supplied the queue lock, it is disconnected
  * by this function. The actual state of the lock doesn't matter
  * here as the request_queue isn't accessible after this point
- * (QUEUE_FLAG_DEAD is set) and no other requests will be queued.
+ * (QUEUE_FLAG_DYING is set) and no other requests will be queued.
  */
 void blk_cleanup_queue(struct request_queue *q)
 {
@@ -458,7 +458,7 @@ void blk_cleanup_queue(struct request_queue *q)
 	blk_sync_queue(q);
 
 	mutex_lock(&q->sysfs_lock);
-	queue_flag_set_unlocked(QUEUE_FLAG_DEAD, q);
+	queue_flag_set_unlocked(QUEUE_FLAG_DYING, q);
 	mutex_unlock(&q->sysfs_lock);
 
 	if (q->queue_lock != &q->__queue_lock)
@@ -612,7 +612,7 @@ EXPORT_SYMBOL(blk_init_queue_node);
 
 int blk_get_queue(struct request_queue *q)
 {
-	if (likely(!test_bit(QUEUE_FLAG_DEAD, &q->queue_flags))) {
+	if (likely(!test_bit(QUEUE_FLAG_DYING, &q->queue_flags))) {
 		kobject_get(&q->kobj);
 		return 0;
 	}
@@ -1457,7 +1457,7 @@ static inline void __generic_make_request(struct bio *bio)
 			goto end_io;
 		}
 
-		if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
+		if (unlikely(test_bit(QUEUE_FLAG_DYING, &q->queue_flags)))
 			goto end_io;
 
 		if (should_fail_request(bio))
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 52e17b0..d1cc206 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -410,7 +410,7 @@ queue_attr_show(struct kobject *kobj, struct attribute *attr, char *page)
 	if (!entry->show)
 		return -EIO;
 	mutex_lock(&q->sysfs_lock);
-	if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)) {
+	if (test_bit(QUEUE_FLAG_DYING, &q->queue_flags)) {
 		mutex_unlock(&q->sysfs_lock);
 		return -ENOENT;
 	}
@@ -432,7 +432,7 @@ queue_attr_store(struct kobject *kobj, struct attribute *attr,
 
 	q = container_of(kobj, struct request_queue, kobj);
 	mutex_lock(&q->sysfs_lock);
-	if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)) {
+	if (test_bit(QUEUE_FLAG_DYING, &q->queue_flags)) {
 		mutex_unlock(&q->sysfs_lock);
 		return -ENOENT;
 	}
diff --git a/block/blk.h b/block/blk.h
index 1414836..ee13ff8 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -62,7 +62,7 @@ static inline struct request *__elv_next_request(struct request_queue *q)
 				return rq;
 		}
 
-		if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags) ||
+		if (test_bit(QUEUE_FLAG_DYING, &q->queue_flags) ||
 		    !q->elevator->ops->elevator_dispatch_fn(q, 0))
 			return NULL;
 	}
diff --git a/block/elevator.c b/block/elevator.c
index 5be39e5..dc344ef 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -751,7 +751,7 @@ int elv_queue_empty(struct request_queue *q)
 	if (!list_empty(&q->queue_head))
 		return 0;
 
-	if (!test_bit(QUEUE_FLAG_DEAD, &q->queue_flags) &&
+	if (!test_bit(QUEUE_FLAG_DYING, &q->queue_flags) &&
 	    e->ops->elevator_queue_empty_fn)
 		return e->ops->elevator_queue_empty_fn(q);
 
diff --git a/drivers/block/ub.c b/drivers/block/ub.c
index 1c1533a..abd7b09 100644
--- a/drivers/block/ub.c
+++ b/drivers/block/ub.c
@@ -2408,7 +2408,7 @@ static void ub_disconnect(struct usb_interface *intf)
 		del_gendisk(lun->disk);
 		/*
 		 * I wish I could do:
-		 *    queue_flag_set(QUEUE_FLAG_DEAD, q);
+		 *    queue_flag_set(QUEUE_FLAG_DYING, q);
 		 * As it is, we rely on our internal poisoning and let
 		 * the upper levels to spin furiously failing all the I/O.
 		 */
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 22713e8..f818716 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -448,7 +448,7 @@ struct request_queue
 #define QUEUE_FLAG_STOPPED	2	/* queue is stopped */
 #define	QUEUE_FLAG_SYNCFULL	3	/* read queue has been filled */
 #define QUEUE_FLAG_ASYNCFULL	4	/* write queue has been filled */
-#define QUEUE_FLAG_DEAD		5	/* queue being torn down */
+#define QUEUE_FLAG_DYING	5	/* queue being torn down */
 #define QUEUE_FLAG_REENTER	6	/* Re-entrancy avoidance */
 #define QUEUE_FLAG_PLUGGED	7	/* queue is plugged */
 #define QUEUE_FLAG_ELVSWITCH	8	/* don't use elevator, just do FIFO */
-- 
1.7.0

