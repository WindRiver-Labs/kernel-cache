From 7c7af849670bc9d46d8f5db522f9ab4260a92cc6 Mon Sep 17 00:00:00 2001
From: David Howells <dhowells@redhat.com>
Date: Wed, 4 Oct 2017 16:43:25 +0100
Subject: [PATCH] KEYS: Fix race between updating and finding a negative key

commit  363b02dab09b3226f3bd1420dad9c72b79a42a76 upsteam

Consolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection
error into one field such that:

 (1) The instantiation state can be modified/read atomically.

 (2) The error can be accessed atomically with the state.

 (3) The error isn't stored unioned with the payload pointers.

This deals with the problem that the state is spread over three different
objects (two bits and a separate variable) and reading or updating them
atomically isn't practical, given that not only can uninstantiated keys
change into instantiated or rejected keys, but rejected keys can also turn
into instantiated keys - and someone accessing the key might not be using
any locking.

The main side effect of this problem is that what was held in the payload
may change, depending on the state.  For instance, you might observe the
key to be in the rejected state.  You then read the cached error, but if
the key semaphore wasn't locked, the key might've become instantiated
between the two reads - and you might now have something in hand that isn't
actually an error code.

The state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error
code if the key is negatively instantiated.  The key_is_instantiated()
function is replaced with key_is_positive() to avoid confusion as negative
keys are also 'instantiated'.

Additionally, barriering is included:

 (1) Order payload-set before state-set during instantiation.

 (2) Order state-read before payload-read when using the key.

Further separate barriering is necessary if RCU is being used to access the
payload content after reading the payload pointers.

Fixes: 146aa8b1453b ("KEYS: Merge the type-specific data with the payload data")
Cc: stable@vger.kernel.org # v4.4+
Reported-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Reviewed-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: Haitao Liu <haitao.liu@windriver.com>
---
 include/linux/key.h                      |   37 ++++++++++++++++++++---------
 net/dns_resolver/dns_key.c               |    2 +-
 security/keys/encrypted-keys/encrypted.c |    2 +-
 security/keys/gc.c                       |    9 ++++---
 security/keys/key.c                      |   32 +++++++++++++++++---------
 security/keys/keyctl.c                   |    9 +++----
 security/keys/keyring.c                  |   13 +++++-----
 security/keys/proc.c                     |    6 +++-
 security/keys/process_keys.c             |    2 +-
 security/keys/request_key.c              |    6 +++-
 security/keys/request_key_auth.c         |    2 +-
 security/keys/trusted.c                  |    2 +-
 security/keys/user_defined.c             |    4 +-
 13 files changed, 77 insertions(+), 49 deletions(-)

diff --git a/include/linux/key.h b/include/linux/key.h
index 16cbdb0..086f560 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -112,6 +112,10 @@ static inline unsigned long is_key_possessed(const key_ref_t key_ref)
 {
 	return (unsigned long) key_ref & 1UL;
 }
+enum key_state {
+	KEY_IS_UNINSTANTIATED,
+	KEY_IS_POSITIVE,		/* Positively instantiated */
+};
 
 /*****************************************************************************/
 /*
@@ -142,6 +146,7 @@ struct key {
 						 * - payload should contain own length
 						 */
 
+	int			state;		/* Key state (+) or rejection error (-) */
 #ifdef KEY_DEBUGGING
 	unsigned		magic;
 #define KEY_DEBUG_MAGIC		0x18273645u
@@ -149,13 +154,11 @@ struct key {
 #endif
 
 	unsigned long		flags;		/* status flags (change with bitops) */
-#define KEY_FLAG_INSTANTIATED	0	/* set if key has been instantiated */
-#define KEY_FLAG_DEAD		1	/* set if key type has been deleted */
-#define KEY_FLAG_REVOKED	2	/* set if key had been revoked */
-#define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
-#define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
-#define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
-#define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
+#define KEY_FLAG_DEAD		0	/* set if key type has been deleted */
+#define KEY_FLAG_REVOKED	1	/* set if key had been revoked */
+#define KEY_FLAG_IN_QUOTA	2	/* set if key consumes quota */
+#define KEY_FLAG_USER_CONSTRUCT	3	/* set if key is being constructed in userspace */
+#define KEY_FLAG_ROOT_CAN_CLEAR	4	/* set if key can be cleared by root without permission */
 
 	/* the description string
 	 * - this is used to match a key against search criteria
@@ -171,7 +174,6 @@ struct key {
 		struct list_head	link;
 		unsigned long		x[2];
 		void			*p[2];
-		int			reject_error;
 	} type_data;
 
 	/* key data
@@ -279,19 +281,30 @@ static inline key_serial_t key_serial(const struct key *key)
 
 extern void key_set_timeout(struct key *, unsigned);
 
+static inline int key_read_state(const struct key *key)
+{
+	/* Barrier versus mark_key_instantiated(). */
+    int state = ACCESS_ONCE(key->state);
+    smp_mb();
+	return state;
+}
+
 /**
- * key_is_instantiated - Determine if a key has been positively instantiated
+ * key_is_positive - Determine if a key has been positively instantiated
  * @key: The key to check.
  *
  * Return true if the specified key has been positively instantiated, false
  * otherwise.
  */
-static inline bool key_is_instantiated(const struct key *key)
+static inline bool key_is_positive(const struct key *key)
 {
-	return test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
-		!test_bit(KEY_FLAG_NEGATIVE, &key->flags);
+	return key_read_state(key) == KEY_IS_POSITIVE;
 }
 
+static inline bool key_is_negative(const struct key *key)
+{
+	return key_read_state(key) < 0;
+}
 #define rcu_dereference_key(KEY)					\
 	(rcu_dereference_protected((KEY)->payload.rcudata,		\
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
diff --git a/net/dns_resolver/dns_key.c b/net/dns_resolver/dns_key.c
index c73bba3..8bfbb0c 100644
--- a/net/dns_resolver/dns_key.c
+++ b/net/dns_resolver/dns_key.c
@@ -212,7 +212,7 @@ static void dns_resolver_describe(const struct key *key, struct seq_file *m)
 	int err = key->type_data.x[0];
 
 	seq_puts(m, key->description);
-	if (key_is_instantiated(key)) {
+	if (key_is_positive(key)) {
 		if (err)
 			seq_printf(m, ": %d", err);
 		else
diff --git a/security/keys/encrypted-keys/encrypted.c b/security/keys/encrypted-keys/encrypted.c
index 988a7e2..79a91ad 100644
--- a/security/keys/encrypted-keys/encrypted.c
+++ b/security/keys/encrypted-keys/encrypted.c
@@ -843,7 +843,7 @@ static int encrypted_update(struct key *key, const void *data, size_t datalen)
 	const char *format = NULL;
 	int ret = 0;
 
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+	if (key_is_negative(key))
 		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !data)
 		return -EINVAL;
diff --git a/security/keys/gc.c b/security/keys/gc.c
index e63cdf4..e5cdd47 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -172,10 +172,13 @@ do_gc:
  */
 static noinline void key_gc_unused_key(struct key *key)
 {
+	int state;
 	key_check(key);
 
 	security_key_free(key);
 
+	state = key->state;
+
 	/* deal with the user's key tracking and quota */
 	if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
 		spin_lock(&key->user->lock);
@@ -185,13 +188,11 @@ static noinline void key_gc_unused_key(struct key *key)
 	}
 
 	atomic_dec(&key->user->nkeys);
-	if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
+	if (state != KEY_IS_UNINSTANTIATED)
 		atomic_dec(&key->user->nikeys);
 
 	/* now throw away the key memory if the key is instantiated */
-	if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
-	    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
-	    key->type->destroy)
+	if (state == KEY_IS_POSITIVE && key->type->destroy)
 		key->type->destroy(key);
 
 	key_user_put(key->user);
diff --git a/security/keys/key.c b/security/keys/key.c
index 5f9902e..68fee94 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -406,6 +406,19 @@ int key_payload_reserve(struct key *key, size_t datalen)
 EXPORT_SYMBOL(key_payload_reserve);
 
 /*
+ * Change the key state to being instantiated.
+ */
+static void mark_key_instantiated(struct key *key, int reject_error)
+{
+	/* Commit the payload before setting the state; barrier versus
+	 * key_read_state().
+	 */
+    int value =  reject_error < 0 ? reject_error : KEY_IS_POSITIVE;
+    smp_mb();
+    ACCESS_ONCE_RW(key->state) = value;
+}
+
+/*
  * Instantiate a key and link it into the target keyring atomically.  Must be
  * called with the target keyring's semaphore writelocked.  The target key's
  * semaphore need not be locked as instantiation is serialised by
@@ -429,15 +442,14 @@ static int __key_instantiate_and_link(struct key *key,
 	mutex_lock(&key_construction_mutex);
 
 	/* can't instantiate twice */
-	if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+	if (key->state == KEY_IS_UNINSTANTIATED) {
 		/* instantiate the key */
 		ret = key->type->instantiate(key, data, datalen);
 
 		if (ret == 0) {
 			/* mark the key as being instantiated */
 			atomic_inc(&key->user->nikeys);
-			set_bit(KEY_FLAG_INSTANTIATED, &key->flags);
-
+			mark_key_instantiated(key, 0);
 			if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))
 				awaken = 1;
 
@@ -547,12 +559,10 @@ int key_reject_and_link(struct key *key,
 	mutex_lock(&key_construction_mutex);
 
 	/* can't instantiate twice */
-	if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+	if (key->state == KEY_IS_UNINSTANTIATED) {
 		/* mark the key as being negatively instantiated */
 		atomic_inc(&key->user->nikeys);
-		set_bit(KEY_FLAG_NEGATIVE, &key->flags);
-		set_bit(KEY_FLAG_INSTANTIATED, &key->flags);
-		key->type_data.reject_error = -error;
+		mark_key_instantiated(key, -error);
 		now = current_kernel_time();
 		key->expiry = now.tv_sec + timeout;
 		key_schedule_gc(key->expiry + key_gc_delay);
@@ -724,8 +734,8 @@ static inline key_ref_t __key_update(key_ref_t key_ref,
 
 	ret = key->type->update(key, payload, plen);
 	if (ret == 0)
-		/* updating a negative key instantiates it */
-		clear_bit(KEY_FLAG_NEGATIVE, &key->flags);
+        /* Updating a negative key positively instantiates it */
+        mark_key_instantiated(key, 0);
 
 	up_write(&key->sem);
 
@@ -905,8 +915,8 @@ int key_update(key_ref_t key_ref, const void *payload, size_t plen)
 
 		ret = key->type->update(key, payload, plen);
 		if (ret == 0)
-			/* updating a negative key instantiates it */
-			clear_bit(KEY_FLAG_NEGATIVE, &key->flags);
+            /* Updating a negative key positively instantiates it */
+            mark_key_instantiated(key, 0);
 
 		up_write(&key->sem);
 	}
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index 0f2ad5b..371e99d 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -684,10 +684,9 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	key = key_ref_to_ptr(key_ref);
 
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
-		ret = -ENOKEY;
-		goto error2;
-	}
+	ret = key_read_state(key);
+	if (ret < 0)
+		goto error2; /* Negatively instantiated */
 
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_READ);
@@ -809,7 +808,7 @@ long keyctl_chown_key(key_serial_t id, uid_t uid, gid_t gid)
 		atomic_dec(&key->user->nkeys);
 		atomic_inc(&newowner->nkeys);
 
-		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+		if (key->state != KEY_IS_UNINSTANTIATED) {
 			atomic_dec(&key->user->nikeys);
 			atomic_inc(&newowner->nikeys);
 		}
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index ab10335..ae29ed2 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -175,7 +175,7 @@ static void keyring_describe(const struct key *keyring, struct seq_file *m)
 	else
 		seq_puts(m, "[anon]");
 
-	if (key_is_instantiated(keyring)) {
+	if (key_is_positive(keyring)) {
 		rcu_read_lock();
 		klist = rcu_dereference(keyring->payload.subscriptions);
 		if (klist)
@@ -320,6 +320,7 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 	key_ref_t key_ref;
 	long err;
 	int sp, nkeys, kix;
+	int state = ACCESS_ONCE(key->state);
 
 	if (!match) {
 		key_ref = ERR_PTR(-EINVAL);
@@ -362,8 +363,8 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 			goto error_2;
 		if (key->expiry && now.tv_sec >= key->expiry)
 			goto error_2;
-		key_ref = ERR_PTR(key->type_data.reject_error);
-		if (kflags & (1 << KEY_FLAG_NEGATIVE))
+		key_ref = ERR_PTR(state);
+		if (state < 0)
 			goto error_2;
 		goto found;
 	}
@@ -371,7 +372,7 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 	/* otherwise, the top keyring must not be revoked, expired, or
 	 * negatively instantiated if we are to search it */
 	key_ref = ERR_PTR(-EAGAIN);
-	if (kflags & ((1 << KEY_FLAG_REVOKED) | (1 << KEY_FLAG_NEGATIVE)) ||
+	if (kflags & (1 << KEY_FLAG_REVOKED) || (state < 0) ||
 	    (keyring->expiry && now.tv_sec >= keyring->expiry))
 		goto error_2;
 
@@ -417,8 +418,8 @@ descend:
 			goto found;
 
 		/* we set a different error code if we pass a negative key */
-		if (kflags & (1 << KEY_FLAG_NEGATIVE)) {
-			err = key->type_data.reject_error;
+		if (state < 0) {
+			err = state;
 			continue;
 		}
 
diff --git a/security/keys/proc.c b/security/keys/proc.c
index 3f7b410..9fbe708 100644
--- a/security/keys/proc.c
+++ b/security/keys/proc.c
@@ -188,6 +188,7 @@ static int proc_keys_show(struct seq_file *m, void *v)
 	struct timespec now;
 	unsigned long timo;
 	key_ref_t key_ref, skey_ref;
+	int state;
 	char xbuf[16];
 	int rc;
 
@@ -239,17 +240,18 @@ static int proc_keys_show(struct seq_file *m, void *v)
 			sprintf(xbuf, "%luw", timo / (60*60*24*7));
 	}
 
+	state = key_read_state(key);
 #define showflag(KEY, LETTER, FLAG) \
 	(test_bit(FLAG,	&(KEY)->flags) ? LETTER : '-')
 
 	seq_printf(m, "%08x %c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s ",
 		   key->serial,
-		   showflag(key, 'I', KEY_FLAG_INSTANTIATED),
+		   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',
 		   showflag(key, 'R', KEY_FLAG_REVOKED),
 		   showflag(key, 'D', KEY_FLAG_DEAD),
 		   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),
 		   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),
-		   showflag(key, 'N', KEY_FLAG_NEGATIVE),
+		   state < 0 ? 'N' : '-',
 		   atomic_read(&key->usage),
 		   xbuf,
 		   key->perm,
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index 1aac832..1c767ea 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -734,7 +734,7 @@ try_again:
 
 	ret = -EIO;
 	if (!(lflags & KEY_LOOKUP_PARTIAL) &&
-	    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
+	    key_read_state(key) == KEY_IS_UNINSTANTIATED)
 		goto invalid_key;
 
 	/* check the permissions */
diff --git a/security/keys/request_key.c b/security/keys/request_key.c
index cc37903..0e94bff 100644
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@ -583,8 +583,10 @@ int wait_for_key_construction(struct key *key, bool intr)
 			  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);
 	if (ret < 0)
 		return ret;
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
-		return key->type_data.reject_error;
+	ret = key_read_state(key);
+	if (ret < 0) {
+		return ret;
+	}
 	return key_validate(key);
 }
 EXPORT_SYMBOL(wait_for_key_construction);
diff --git a/security/keys/request_key_auth.c b/security/keys/request_key_auth.c
index 60d4e3f..dea9efa 100644
--- a/security/keys/request_key_auth.c
+++ b/security/keys/request_key_auth.c
@@ -59,7 +59,7 @@ static void request_key_auth_describe(const struct key *key,
 
 	seq_puts(m, "key:");
 	seq_puts(m, key->description);
-	if (key_is_instantiated(key))
+	if (key_is_positive(key))
 		seq_printf(m, " pid:%d ci:%zu", rka->pid, rka->callout_len);
 }
 
diff --git a/security/keys/trusted.c b/security/keys/trusted.c
index 9614dbc..30f1ad5 100644
--- a/security/keys/trusted.c
+++ b/security/keys/trusted.c
@@ -1019,7 +1019,7 @@ static int trusted_update(struct key *key, const void *data, size_t datalen)
 	char *datablob;
 	int ret = 0;
 
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+	if (key_is_negative(key))
 		return -ENOKEY;
 	p = key->payload.data;
 	if (!p->migratable)
diff --git a/security/keys/user_defined.c b/security/keys/user_defined.c
index f89846f..3a7de1e 100644
--- a/security/keys/user_defined.c
+++ b/security/keys/user_defined.c
@@ -117,7 +117,7 @@ int user_update(struct key *key, const void *data, size_t datalen)
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
-		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		if (key_is_positive(key))
 			zap = key->payload.data;
 		else
 			zap = NULL;
@@ -181,7 +181,7 @@ EXPORT_SYMBOL_GPL(user_destroy);
 void user_describe(const struct key *key, struct seq_file *m)
 {
 	seq_puts(m, key->description);
-	if (key_is_instantiated(key))
+	if (key_is_positive(key))
 		seq_printf(m, ": %u", key->datalen);
 }
 
-- 
1.7.5.4

