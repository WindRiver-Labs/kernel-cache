From 007855ac5786fd9a9e6f9bf7aad95bbf1155c240 Mon Sep 17 00:00:00 2001
From: "J. R. Okajima" <hooanon05g@gmail.com>
Date: Tue, 16 Feb 2016 04:28:09 +0900
Subject: [PATCH 3/3] aufs: security bugfix, copy-up resets ACL

commit 0f14f47a29ea63ee3a2983fdf217656209bd4840 from
https://github.com/sfjro/aufs4-standalone.git aufs4.0

In ACL world, a dir can have its "default ACL" which will be applied to
all future children. It means that the copied-up entry will have its
original ACL (set on the lower RO branch) plus the parent dir's default
one (set on the upper RW branch). This mixture may cause a security
problem, and this commit resets all ACL in copy-up, which will prevent
inheriting the ACL from its parent dir.

Reported-by: halfdog <me@halfdog.net>
Signed-off-by: J. R. Okajima <hooanon05g@gmail.com>
(cherry picked from commit d783b9a5cff6fa2fedc80cfe781d40cd05fb09c4)
Signed-off-by: Qi Hou <qi.hou@windriver.com>
---
 fs/aufs/cpup.c |   42 +++++++++++++++++++++++++++++++++++++++---
 1 files changed, 39 insertions(+), 3 deletions(-)

diff --git a/fs/aufs/cpup.c b/fs/aufs/cpup.c
index aa69664..4ac4406 100644
--- a/fs/aufs/cpup.c
+++ b/fs/aufs/cpup.c
@@ -509,10 +509,43 @@ out:
 	return err;
 }
 
-static void au_do_cpup_dir(struct au_cp_generic *cpg, struct dentry *dst_parent)
+/*
+ * regardless 'acl' option, reset all ACL.
+ * All ACL will be copied up later from the original entry on the lower branch.
+ */
+static int au_reset_acl(struct inode *h_dir, struct path *h_path, umode_t mode)
 {
+	int err;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+
+	h_dentry = h_path->dentry;
+	h_inode = h_dentry->d_inode;
+	/* forget_all_cached_acls(h_inode)); */
+	err = vfsub_removexattr(h_dentry, XATTR_NAME_POSIX_ACL_ACCESS);
+	AuTraceErr(err);
+	if (!err)
+		err = vfsub_acl_chmod(h_inode, mode);
+	if (err == -EOPNOTSUPP)
+		err = 0;
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_do_cpup_dir(struct au_cp_generic *cpg, struct dentry *dst_parent,
+			  struct inode *h_dir, struct path *h_path)
+{
+	int err;
 	struct inode *dir;
 
+	err = vfsub_removexattr(h_path->dentry, XATTR_NAME_POSIX_ACL_DEFAULT);
+	AuTraceErr(err);
+	if (err == -EOPNOTSUPP)
+		err = 0;
+	if (unlikely(err))
+		goto out;
+
 	/*
 	 * strange behaviour from the users view,
 	 * particularry setattr case
@@ -521,6 +554,9 @@ static void au_do_cpup_dir(struct au_cp_generic *cpg, struct dentry *dst_parent)
 	if (au_ibstart(dir) == cpg->bdst)
 		au_cpup_attr_nlink(dir, /*force*/1);
 	au_cpup_attr_nlink(cpg->dentry->d_inode, /*force*/1);
+
+out:
+	return err;
 }
 
 static noinline_for_stack
@@ -576,7 +612,7 @@ int cpup_entry(struct au_cp_generic *cpg, struct dentry *dst_parent,
 		isdir = 1;
 		err = vfsub_mkdir(h_dir, &h_path, mode);
 		if (!err)
-			au_do_cpup_dir(cpg, dst_parent);
+			err = au_do_cpup_dir(cpg, dst_parent, h_dir, &h_path);
 		break;
 	case S_IFLNK:
 		err = au_do_cpup_symlink(&h_path, h_src, h_dir);
@@ -594,7 +630,7 @@ int cpup_entry(struct au_cp_generic *cpg, struct dentry *dst_parent,
 		err = -EIO;
 	}
 	if (!err)
-		err = vfsub_acl_chmod(h_path.dentry->d_inode, mode);
+		err = au_reset_acl(h_dir, &h_path, mode);
 
 	mnt_flags = au_mntflags(sb);
 	if (!au_opt_test(mnt_flags, UDBA_NONE)
-- 
1.7.5.4

