From 4ad071c951cf28ab1ad98513b0d608a36abeba56 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 23 Feb 2016 10:45:17 -0500
Subject: [PATCH] hpwdt: use raw lock in NMI handler code

The following was seen on a preempt-rt kernel:

BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:1163
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Preemption disabled at:[<ffffffff810abe7a>] cpu_startup_entry+0x14a/0x2a0

CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.14.52-rt50 #1
Hardware name: HP ProLiant DL360 Gen9, BIOS P89 05/06/2015
 0000006cc995f2ac ffff88046f805e20 ffffffff81aa0459 0000000000000000
 ffff88046f805e38 ffffffff81082e43 ffffffffa03801c0 ffff88046f805e50
 ffffffff81aa7190 0000000000000003 ffff88046f805e60 ffffffffa037f82d
Call Trace:
 <NMI>  [<ffffffff81aa0459>] dump_stack+0x4e/0x7a
 [<ffffffff81082e43>] __might_sleep+0xe3/0x160
 [<ffffffff81aa7190>] rt_spin_lock+0x20/0x50
 [<ffffffffa037f82d>] hpwdt_pretimeout+0x2d/0xd5 [hpwdt]
 [<ffffffff81007761>] nmi_handle+0x81/0x1a0
 [<ffffffff81007a10>] do_nmi+0x190/0x380
 [<ffffffff81aa9a54>] end_repeat_nmi+0x1a/0x1e
 [<ffffffff814a8994>] ? intel_idle+0xd4/0x160
 [<ffffffff814a8994>] ? intel_idle+0xd4/0x160
 [<ffffffff814a8994>] ? intel_idle+0xd4/0x160
 <<EOE>>  [<ffffffff817be92a>] cpuidle_enter_state+0x3a/0xb0
 [<ffffffff817bea64>] cpuidle_idle_call+0xc4/0x250
 [<ffffffff8100e14e>] arch_cpu_idle+0xe/0x20
 [<ffffffff810abeb5>] cpu_startup_entry+0x185/0x2a0
 [<ffffffff81a9a214>] rest_init+0x84/0x90
 [<ffffffff8233bd69>] start_kernel+0x3ef/0x3fc
 [<ffffffff8233b495>] x86_64_start_reservations+0x2a/0x2c
 [<ffffffff8233b58e>] x86_64_start_kernel+0xf7/0xfa

With IRQs disabled, we need a raw lock here.  Since the lock is
only used at one site (presumably) to set a recursion prevention
variable, there is no latency issue with using a raw lock here.

Add to that the fact that the next thing the code does is panic()
so it really doesn't matter what happens here, as the system is
as good as dead if you execute this path.  But at least getting
rid of the sleeping while atomic splat helps to not muddy the
waters any further, and lets people see the NMI output sooner.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/watchdog/hpwdt.c b/drivers/watchdog/hpwdt.c
index 2b75e8b47279..8318e09608d7 100644
--- a/drivers/watchdog/hpwdt.c
+++ b/drivers/watchdog/hpwdt.c
@@ -149,7 +149,7 @@ static unsigned int hpwdt_nmi_decoding;
 static unsigned int allow_kdump = 1;
 static unsigned int is_icru;
 static unsigned int is_uefi;
-static DEFINE_SPINLOCK(rom_lock);
+static DEFINE_RAW_SPINLOCK(rom_lock);
 static void *cru_rom_addr;
 static struct cmn_registers cmn_regs;
 
@@ -486,11 +486,11 @@ static int hpwdt_pretimeout(unsigned int ulReason, struct pt_regs *regs)
 	if (!hpwdt_nmi_decoding)
 		goto out;
 
-	spin_lock_irqsave(&rom_lock, rom_pl);
+	raw_spin_lock_irqsave(&rom_lock, rom_pl);
 	if (!die_nmi_called && !is_icru && !is_uefi)
 		asminline_call(&cmn_regs, cru_rom_addr);
 	die_nmi_called = 1;
-	spin_unlock_irqrestore(&rom_lock, rom_pl);
+	raw_spin_unlock_irqrestore(&rom_lock, rom_pl);
 
 	if (allow_kdump)
 		hpwdt_stop();
-- 
2.1.4

