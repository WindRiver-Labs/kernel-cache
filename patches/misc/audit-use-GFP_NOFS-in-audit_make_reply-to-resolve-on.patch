From d845b84e85dd7ad8aa2740f0665192a99fc9f112 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 26 May 2014 10:19:07 +0800
Subject: [PATCH] audit: use GFP_NOFS in audit_make_reply() to resolve one lockdep warning

When memory is in pressure, the following lockdep warning could happens:
[ 973.797945] [ INFO: possible irq lock inversion dependency detected ]
[ 973.797945] 2.6.34.13-WR4.3.fp_x86_32_standard-00044-g7626029 #1
[ 973.797945] ---------------------------------------------------------
[ 973.797945] kswapd0/22 just changed the state of lock:
[ 973.797945] (&inode->inotify_mutex){+.+.-.}, at: [<c1139a2a>] inotify_inode_is_dead+0x1a/0x80
[ 973.797945] but this lock took another, RECLAIM_FS-unsafe lock in the past:
[ 973.797945] (audit_filter_mutex){+.+.+.}
[ 973.797945]
[ 973.797945] and interrupts could create inverse lock ordering between them.
[ 973.797945]
[ 973.797945]
[ 973.797945] other info that might help us debug this:
[ 973.797945] 2 locks held by kswapd0/22:
[ 973.797945] #0: (shrinker_rwsem){++++..}, at: [<c10d5ed4>] shrink_slab+0x24/0x170
[ 973.797945] #1: (&type->s_umount_key#14){++++..}, at: [<c111b9b2>] shrink_dcache_memory+0x102/0x1b0
[ 973.797945]
[ 973.797945] the shortest dependencies between 2nd lock and 1st lock:
[ 973.797945] -> (audit_filter_mutex){+.+.+.} ops: 0 {
[ 973.797945] HARDIRQ-ON-W at:
[ 973.797945] [<c1079d0c>] mark_lock+0xec/0x390
[ 973.797945] [<c107afcc>] __lock_acquire+0x4ec/0x1280
[ 973.797945] [<c107bdd8>] lock_acquire+0x78/0xf0
[ 973.797945] [<c1465277>] __mutex_lock_common+0x47/0x350
[ 973.797945] [<c1465635>] mutex_lock_nested+0x35/0x40
[ 973.797945] [<c109d803>] audit_receive_filter+0x293/0xb00
[ 973.797945] [<c109b3ef>] audit_receive+0x22f/0xb50
[ 973.797945] [<c13bd0b9>] netlink_unicast+0x259/0x280
[ 973.797945] [<c13be130>] netlink_sendmsg+0x1b0/0x290
[ 973.797945] [<c138f8f7>] sock_sendmsg+0xe7/0x160
[ 973.797945] [<c138fac8>] sys_sendto+0x108/0x150
[ 973.797945] [<c139076a>] sys_socketcall+0x1ba/0x2e0
[ 973.797945] [<c1467374>] system_call_done+0x0/0x4

Fix this problem by use GFP_NOFS instead of GFP_KERNEL to allocate the memory when
audit_filter_mutex is hold.
Please note: mainline kernel has already replaced inotify with fsnotify in
audit implementation since 2.6.36, but we will not backport it because it would
introduces a lot of changes.

v2: Also replace GFP_KERNEL with GFP_NOFS in audit_krule_to_rule().

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 kernel/audit.c       |    2 +-
 kernel/auditfilter.c |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/audit.c b/kernel/audit.c
index c71bd26..9a848a7 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -515,7 +515,7 @@ struct sk_buff *audit_make_reply(int pid, int seq, int type, int done,
 	int		flags = multi ? NLM_F_MULTI : 0;
 	int		t     = done  ? NLMSG_DONE  : type;
 
-	skb = nlmsg_new(size, GFP_KERNEL);
+	skb = nlmsg_new(size, GFP_NOFS);
 	if (!skb)
 		return NULL;
 
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index ce08041..2ad3b9b 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -572,7 +572,7 @@ static struct audit_rule *audit_krule_to_rule(struct audit_krule *krule)
 	struct audit_rule *rule;
 	int i;
 
-	rule = kzalloc(sizeof(*rule), GFP_KERNEL);
+	rule = kzalloc(sizeof(*rule), GFP_NOFS);
 	if (unlikely(!rule))
 		return NULL;
 
-- 
1.7.0

