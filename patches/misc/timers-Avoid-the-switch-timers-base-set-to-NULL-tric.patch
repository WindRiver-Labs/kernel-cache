From 8b0dfda4f2862c0545a64669d7ce367daa52ef6f Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Tue, 28 Jan 2014 16:57:18 +0800
Subject: [PATCH] timers: Avoid the switch timers base set to NULL trick on RT

On RT that code is preemptible, so we cannot assign NULL to timers
base as a preempter would spin forever in lock_timer_base().

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: baogen shang <baogen.shang@windriver.com>
---
 kernel/timer.c |   40 ++++++++++++++++++++++++++++++++--------
 1 files changed, 32 insertions(+), 8 deletions(-)

diff --git a/kernel/timer.c b/kernel/timer.c
index 1cbabc4..dcd5a2a 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -638,6 +638,36 @@ static struct tvec_base *lock_timer_base(struct timer_list *timer,
 	}
 }
 
+#ifndef CONFIG_PREEMPT_RT_FULL
+static inline struct tvec_base *switch_timer_base(struct timer_list *timer,
+                                                 struct tvec_base *old,
+                                                 struct tvec_base *new)
+{
+       /* See the comment in lock_timer_base() */
+       timer_set_base(timer, NULL);
+       spin_unlock(&old->lock);
+       spin_lock(&new->lock);
+       timer_set_base(timer, new);
+       return new;
+}
+#else
+static inline struct tvec_base *switch_timer_base(struct timer_list *timer,
+                                                 struct tvec_base *old,
+                                                 struct tvec_base *new)
+{
+       /*
+        * We cannot do the above because we might be preempted and
+        * then the preempter would see NULL and loop forever.
+        */
+       if (spin_trylock(&new->lock)) {
+               timer_set_base(timer, new);
+               spin_unlock(&old->lock);
+               return new;
+       }
+       return old;
+}
+#endif
+
 static inline int
 __mod_timer(struct timer_list *timer, unsigned long expires,
 						bool pending_only, int pinned)
@@ -684,14 +714,8 @@ __mod_timer(struct timer_list *timer, unsigned long expires,
 		 * handler yet has not finished. This also guarantees that
 		 * the timer is serialized wrt itself.
 		 */
-		if (likely(base->running_timer != timer)) {
-			/* See the comment in lock_timer_base() */
-			timer_set_base(timer, NULL);
-			spin_unlock(&base->lock);
-			base = new_base;
-			spin_lock(&base->lock);
-			timer_set_base(timer, base);
-		}
+		if (likely(base->running_timer != timer))
+                        base = switch_timer_base(timer, base, new_base);
 	}
 
 	timer->expires = expires;
-- 
1.7.0

