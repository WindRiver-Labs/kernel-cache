From a8f11b6ca331b16931d4674ef496afc648b6f063 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Feb 2014 18:15:26 +0800
Subject: [PATCH 2/2] cpu: make clear_tasks_mm_cpumask() lockless when
 iterating each thread

Because the caller of the function is running offline and
in atomic context, it's not possible to acquire task lock.

It's confirmed that getting rid of the lock is safe due to
the same reason as above. The reader of mm_cpumask() will
not mess up.

There are three kinds of callers of mm_cpumask():
1) switch_mm(); this will not mess up with
   clear_tasks_mm_cpumask() because the two will not run at
   the same time.
2) tlb flush; this will not be affected by
   clear_tasks_mm_cpumask() because clear_tasks_mm_cpumask()
   is called when cpu is offline and the mechanism behind
   tlb flush (which is on_each_cpu) will exclude the
   offlined cpu.
3) Other that check if the current cpu is in mm_cpumask(),
   this doesn't matter because this only happens on the current
   cpu but clear_tasks_mm_cpumask() is called after everything is
   done.

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 kernel/cpu.c |   20 +++++++-------------
 1 files changed, 7 insertions(+), 13 deletions(-)

diff --git a/kernel/cpu.c b/kernel/cpu.c
index 198a388..f00f392 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -216,6 +216,7 @@ EXPORT_SYMBOL(unregister_cpu_notifier);
 void clear_tasks_mm_cpumask(int cpu)
 {
 	struct task_struct *p;
+	struct task_struct *t;
 
 	/*
 	 * This function is called after the cpu is taken down and marked
@@ -226,19 +227,12 @@ void clear_tasks_mm_cpumask(int cpu)
 	 */
 	WARN_ON(cpu_online(cpu));
 	rcu_read_lock();
-	for_each_process(p) {
-		struct task_struct *t;
-
-		/*
-		 * Main thread might exit, but other threads may still have
-		 * a valid mm. Find one.
-		 */
-		t = find_lock_task_mm(p);
-		if (!t)
-			continue;
-		cpumask_clear_cpu(cpu, mm_cpumask(t->mm));
-		task_unlock(t);
-	}
+	do_each_thread(p, t) {
+		if (likely(t->mm)) {
+			cpumask_clear_cpu(cpu, mm_cpumask(t->mm));
+			break;
+		}
+	} while_each_thread(p, t);
 	rcu_read_unlock();
 }
 
-- 
1.7.5.4

