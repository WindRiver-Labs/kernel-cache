From 559bd187605507459cfe783ba22697d7dfcdb39f Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@xilinx.com>
Date: Wed, 18 Sep 2013 17:27:24 +0530
Subject: [PATCH 115/628] axidma: xilinx: Proper freeing up of channel
 resources when driver exits/fails

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit c37eafe48f78101245df14e4bb431abfe4ab2180

This patch frees channel resources, whenever the driver probing fails or
exits normally, in a clean way.

Signed-off-by: Srikanth Thokala <sthokal@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/dma/xilinx/xilinx_axidma.c |   44 +++++++++++++++++++++++------------
 1 files changed, 29 insertions(+), 15 deletions(-)

diff --git a/drivers/dma/xilinx/xilinx_axidma.c b/drivers/dma/xilinx/xilinx_axidma.c
index 7e79d44..e97ec06 100644
--- a/drivers/dma/xilinx/xilinx_axidma.c
+++ b/drivers/dma/xilinx/xilinx_axidma.c
@@ -944,10 +944,15 @@ static int my_log(int value)
 	return i;
 }
 
-static void xilinx_dma_chan_remove(struct xilinx_dma_chan *chan)
+static void xilinx_dma_free_channels(struct xilinx_dma_device *xdev)
 {
-	irq_dispose_mapping(chan->irq);
-	list_del(&chan->common.device_node);
+	int i;
+
+	for (i = 0; i < XILINX_DMA_MAX_CHANS_PER_DEVICE; i++) {
+		list_del(&xdev->chan[i]->common.device_node);
+		tasklet_kill(&xdev->chan[i]->tasklet);
+		irq_dispose_mapping(xdev->chan[i]->irq);
+	}
 }
 
 /*
@@ -1032,8 +1037,6 @@ static int xilinx_dma_chan_probe(struct xilinx_dma_device *xdev,
 	chan->dev = xdev->dev;
 	xdev->chan[chan->id] = chan;
 
-	tasklet_init(&chan->tasklet, dma_do_tasklet, (unsigned long)chan);
-
 	/* Initialize the channel */
 	err = dma_init(chan);
 	if (err) {
@@ -1055,10 +1058,11 @@ static int xilinx_dma_chan_probe(struct xilinx_dma_device *xdev,
 				"xilinx-dma-controller", chan);
 	if (err) {
 		dev_err(xdev->dev, "unable to request IRQ\n");
-		irq_dispose_mapping(chan->irq);
 		return err;
 	}
 
+	tasklet_init(&chan->tasklet, dma_do_tasklet, (unsigned long)chan);
+
 	/* Add the channel to DMA device channel list */
 	list_add_tail(&chan->common.device_node, &xdev->common.channels);
 	xdev->common.chancnt++;
@@ -1072,8 +1076,7 @@ static int xilinx_dma_of_probe(struct platform_device *pdev)
 	struct device_node *child, *node;
 	const __be32 *value;
 	struct resource *res;
-
-	dev_info(&pdev->dev, "Probing xilinx axi dma engine\n");
+	int ret;
 
 	xdev = devm_kzalloc(&pdev->dev, sizeof(struct xilinx_dma_device),
 				GFP_KERNEL);
@@ -1129,26 +1132,37 @@ static int xilinx_dma_of_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, xdev);
 
 	for_each_child_of_node(node, child) {
-		xilinx_dma_chan_probe(xdev, child, xdev->feature);
+		ret = xilinx_dma_chan_probe(xdev, child, xdev->feature);
+		if (ret) {
+			dev_err(&pdev->dev, "Probing channels failed\n");
+			goto free_chan_resources;
+		}
+	}
+
+	ret = dma_async_device_register(&xdev->common);
+	if (ret) {
+		dev_err(&pdev->dev, "DMA device registration failed\n");
+		goto free_chan_resources;
 	}
 
-	dma_async_device_register(&xdev->common);
+	dev_info(&pdev->dev, "Probing xilinx axi dma engine...Successful\n");
 
 	return 0;
+
+free_chan_resources:
+	xilinx_dma_free_channels(xdev);
+
+	return ret;
 }
 
 static int xilinx_dma_of_remove(struct platform_device *pdev)
 {
 	struct xilinx_dma_device *xdev;
-	int i;
 
 	xdev = platform_get_drvdata(pdev);
 	dma_async_device_unregister(&xdev->common);
 
-	for (i = 0; i < XILINX_DMA_MAX_CHANS_PER_DEVICE; i++) {
-		if (xdev->chan[i])
-			xilinx_dma_chan_remove(xdev->chan[i]);
-	}
+	xilinx_dma_free_channels(xdev);
 
 	return 0;
 }
-- 
1.7.5.4

