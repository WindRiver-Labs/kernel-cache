From 639d09f1c4ae319ff79de4aadbb08ccac02d1feb Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Wed, 14 Jun 2017 08:16:54 +0200
Subject: [PATCH 1/4] mm: enlarge stack guard gap

Patch from mailing list distros@vs.openwall.org

Stack guard page is a useful feature to reduce a risk of stack smashing
into a different mapping.  We have been using a single page gap which is
sufficient to prevent having stack adjacent to a different mapping.  But
this seems to be insufficient in the light of the stack usage in the
userspace.  E.g.  glibc uses as large as 64kB alloca() in many commonly
used functions.  Others use constructs liks gid_t buffer[NGROUPS_MAX]
which is 256kB or stack strings with MAX_ARG_STRLEN.

This will become especially dangerous for suid binaries and the default
no limit for the stack size limit because those applications can be
tricked to consume a large portion of the stack and a single glibc call
could jump over the guard page.  These attacks are not theoretical,
unfortunatelly.

Make those attacks less probable by increasing the stack guard gap to
1MB (on systems with 4k pages but make it depend on the page size
because systems with larger base pages might cap stack allocations in
the PAGE_SIZE units) which should cover larger alloca() and VLA stack
allocations.  It is obviously not a full fix because the problem is
somehow inherent but it should reduce attack space a lot.  One could
argue that the gap size should be configurable from the userspace but
that can be done later on top when somebody finds that the new 1MB is
not suitable or even wrong for some special case applications.

Implementation wise, get rid of check_stack_guard_page and move all the
guard page specific code to expandable_stack_area which always tries to
guarantee the gap.  do_anonymous_page then just calls expand_stack.
Also get rid of stack_guard_page_{start,end} and replace them with
stack_guard_area to handle stack population and /proc/<pid>/[s]maps.

This should clean up the code which is quite scattered currently and
therefore justify the change.

Signed-off-by: Michal Hocko <mhocko@suse.com>
Tested-by: Tony Luck <tony.luck@intel.com> # ia64
Tested-by: Laura Abbott <labbott@redhat.com>
Tested-by: Helge Deller <deller@gmx.de> # parisc
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Ben Hutchings <ben@decadent.org.uk>
[wt: backport to 4.9 : s/vmf->address/fe->address/]
[wt: backport to 4.4 :
     s/fe->address/address/ ; s/FOLL_POPULATE/FOLL_MLOCK ]
[wt: backport to 3.10 : adjust context ;
     s/stack_guard_page()/stack_guard_area() ]
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 arch/ia64/mm/fault.c |    2 +-
 fs/exec.c            |    8 ++-
 fs/proc/task_mmu.c   |   11 ++-
 include/linux/mm.h   |   38 ++----------
 mm/memory.c          |   48 ++--------------
 mm/mmap.c            |  156 ++++++++++++++++++++++++++++++++++++++++++--------
 6 files changed, 158 insertions(+), 105 deletions(-)

diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c
index 02d29c2..037cd4f 100644
--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -197,7 +197,7 @@ ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *re
 		 */
 		if (address > vma->vm_end + PAGE_SIZE - sizeof(long))
 			goto bad_area;
-		if (expand_upwards(vma, address))
+		if (expand_upwards(vma, address, 0))
 			goto bad_area;
 	}
 	goto good_area;
diff --git a/fs/exec.c b/fs/exec.c
index 645734f..537f683 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -201,7 +201,7 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 
 #ifdef CONFIG_STACK_GROWSUP
 	if (write) {
-		ret = expand_downwards(bprm->vma, pos);
+		ret = expand_downwards(bprm->vma, pos, 0);
 		if (ret < 0)
 			return NULL;
 	}
@@ -215,6 +215,12 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;
 		struct rlimit *rlim;
 
+		/*
+		 * GROWSUP doesn't really have any gap at this stage because we grow
+		 * the stack down now. See the expand_downwards above.
+		 */
+		if (!IS_ENABLED(CONFIG_STACK_GROWSUP))
+			size -= stack_guard_gap;
 		acct_arg_size(bprm, size / PAGE_SIZE);
 
 		/*
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 8df7fd2..f2bae95 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -233,11 +233,14 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 
 	/* We don't show the stack guard page in /proc/maps */
 	start = vma->vm_start;
-	if (stack_guard_page_start(vma, start))
-		start += PAGE_SIZE;
 	end = vma->vm_end;
-	if (stack_guard_page_end(vma, end))
-		end -= PAGE_SIZE;
+	if (vma->vm_flags & VM_GROWSDOWN) {
+		if (stack_guard_area(vma, start))
+			start += stack_guard_gap;
+	} else if (vma->vm_flags & VM_GROWSUP) {
+		if (stack_guard_area(vma, end))
+			end -= stack_guard_gap;
+	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
 			start,
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 9d8e204..0c6cefe 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1014,34 +1014,6 @@ int set_page_dirty(struct page *page);
 int set_page_dirty_lock(struct page *page);
 int clear_page_dirty_for_io(struct page *page);
 
-/* Is the vma a continuation of the stack vma above it? */
-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);
-}
-
-static inline int stack_guard_page_start(struct vm_area_struct *vma,
-					     unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSDOWN) &&
-		(vma->vm_start == addr) &&
-		!vma_growsdown(vma->vm_prev, addr);
-}
-
-/* Is the vma a continuation of the stack vma below it? */
-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_start == addr) && (vma->vm_flags & VM_GROWSUP);
-}
-
-static inline int stack_guard_page_end(struct vm_area_struct *vma,
-					   unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSUP) &&
-		(vma->vm_end == addr) &&
-		!vma_growsup(vma->vm_next, addr);
-}
-
 extern pid_t
 vm_is_stack(struct task_struct *task, struct vm_area_struct *vma, int in_group);
 
@@ -1445,17 +1417,19 @@ unsigned long max_sane_readahead(unsigned long nr);
 unsigned long ra_submit(struct file_ra_state *ra,
 			struct address_space *mapping,
 			struct file *filp);
-
+extern unsigned long stack_guard_gap;
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+extern int stack_guard_area(struct vm_area_struct *vma, unsigned long address);
 
 /* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */
 extern int expand_downwards(struct vm_area_struct *vma,
-		unsigned long address);
+		unsigned long address, unsigned long gap);
 #if VM_GROWSUP
-extern int expand_upwards(struct vm_area_struct *vma, unsigned long address);
+extern int expand_upwards(struct vm_area_struct *vma,
+		unsigned long address, unsigned long gap);
 #else
-  #define expand_upwards(vma, address) do { } while (0)
+  #define expand_upwards(vma, address, gap) do { } while (0)
 #endif
 
 /* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
diff --git a/mm/memory.c b/mm/memory.c
index 13b2bce..7fd416b 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1624,12 +1624,6 @@ no_page_table:
 	return page;
 }
 
-static inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)
-{
-	return stack_guard_page_start(vma, addr) ||
-	       stack_guard_page_end(vma, addr+PAGE_SIZE);
-}
-
 /**
  * __get_user_pages() - pin user pages in memory
  * @tsk:	task_struct of target task
@@ -1782,7 +1776,7 @@ int __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 				/* For mlock, just skip the stack guard page. */
 				if (foll_flags & FOLL_MLOCK) {
-					if (stack_guard_page(vma, start))
+					if (stack_guard_area(vma, start))
 						goto next_page;
 				}
 				trace_page_fault_get_user_entry(mm,
@@ -3140,40 +3134,6 @@ out_release:
 }
 
 /*
- * This is like a special single-page "expand_{down|up}wards()",
- * except we must first make sure that 'address{-|+}PAGE_SIZE'
- * doesn't hit another vma.
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		struct vm_area_struct *prev = vma->vm_prev;
-
-		/*
-		 * Is there a mapping abutting this one below?
-		 *
-		 * That's only ok if it's the same stack mapping
-		 * that has gotten split..
-		 */
-		if (prev && prev->vm_end == address)
-			return prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;
-
-		expand_downwards(vma, address - PAGE_SIZE);
-	}
-	if ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {
-		struct vm_area_struct *next = vma->vm_next;
-
-		/* As VM_GROWSDOWN but s/below/above/ */
-		if (next && next->vm_start == address + PAGE_SIZE)
-			return next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;
-
-		expand_upwards(vma, address + PAGE_SIZE);
-	}
-	return 0;
-}
-
-/*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
@@ -3193,8 +3153,10 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		return VM_FAULT_SIGBUS;
 
 	/* Check if we need to add a guard page to the stack */
-	if (check_stack_guard_page(vma, address) < 0)
-		return VM_FAULT_SIGBUS;
+	if (stack_guard_area(vma, address)) {
+		if (expand_stack(vma, address) < 0)
+			return VM_FAULT_SIGBUS;
+	}
 
 	/* Use the zero-page for reads */
 	if (!(flags & FAULT_FLAG_WRITE)) {
diff --git a/mm/mmap.c b/mm/mmap.c
index 2e6d0ea..56cf13f 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1745,18 +1745,22 @@ find_vma_prev(struct mm_struct *mm, unsigned long addr,
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)
+static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow,
+		unsigned long gap)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct rlimit *rlim = current->signal->rlim;
-	unsigned long new_start;
+	unsigned long new_start, actual_size;;
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
-	if (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
+	actual_size = size;
+	if (size && (vma->vm_flags & (VM_GROWSUP | VM_GROWSDOWN)))
+		actual_size -= gap;
+	if (actual_size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
 		return -ENOMEM;
 
 	/* mlock limit tests */
@@ -1796,7 +1800,7 @@ static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns
  * PA-RISC uses this for its stack; IA64 for its Register Backing Store.
  * vma is the last one with address > vma->vm_end.  Have to extend vma.
  */
-int expand_upwards(struct vm_area_struct *vma, unsigned long address)
+int expand_upwards(struct vm_area_struct *vma, unsigned long address, unsigned long gap)
 {
 	int error;
 
@@ -1834,7 +1838,7 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 
 		error = -ENOMEM;
 		if (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				vma->vm_end = address;
 				perf_event_mmap(vma);
@@ -1851,7 +1855,7 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
  * vma is the first one with address < vma->vm_start.  Have to extend vma.
  */
 int expand_downwards(struct vm_area_struct *vma,
-				   unsigned long address)
+				   unsigned long address, unsigned long gap)
 {
 	int error;
 
@@ -1884,7 +1888,7 @@ int expand_downwards(struct vm_area_struct *vma,
 
 		error = -ENOMEM;
 		if (grow <= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				vma->vm_start = address;
 				vma->vm_pgoff -= grow;
@@ -1897,29 +1901,77 @@ int expand_downwards(struct vm_area_struct *vma,
 	return error;
 }
 
+/* enforced gap between the expanding stack and other mappings. */
+unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;
+
 /*
  * Note how expand_stack() refuses to expand the stack all the way to
  * abut the next virtual mapping, *unless* that mapping itself is also
- * a stack mapping. We want to leave room for a guard page, after all
+ * a stack mapping. We want to leave room for a guard area, after all
  * (the guard page itself is not added here, that is done by the
  * actual page faulting logic)
- *
- * This matches the behavior of the guard page logic (see mm/memory.c:
- * check_stack_guard_page()), which only allows the guard page to be
- * removed under these circumstances.
  */
 #ifdef CONFIG_STACK_GROWSUP
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *next = vma->vm_next;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+
+	/* don't exceed address space */
+	if (address >= TASK_SIZE)
+		return -ENOMEM;
+
+	address = PAGE_ALIGN(address);
+
+	if (!next)
+		goto out;
+
+	if (next->vm_flags & VM_GROWSUP) {
+		guard_gap = min(guard_gap, next->vm_start - address);
+		goto out;
+	}
+
+	if (next->vm_start - address < guard_gap)
+		return -ENOMEM;
+out:
+	if (TASK_SIZE - address < guard_gap)
+		guard_gap = TASK_SIZE - address;
+	guard_addr = address + guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
+	unsigned long gap;
+
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_upwards(vma, address, gap);
+}
+
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
 	struct vm_area_struct *next;
 
-	address &= PAGE_MASK;
+	if (!(vma->vm_flags & VM_GROWSUP))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
 	next = vma->vm_next;
-	if (next && next->vm_start == address + PAGE_SIZE) {
-		if (!(next->vm_flags & VM_GROWSUP))
-			return -ENOMEM;
-	}
-	return expand_upwards(vma, address);
+	if (next && next->vm_flags & VM_GROWSUP)
+		return 0;
+
+	return vma->vm_end - address <= stack_guard_gap;
 }
 
 struct vm_area_struct *
@@ -1939,17 +1991,73 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)
 	return prev;
 }
 #else
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *prev = vma->vm_prev;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+
+	address &= PAGE_MASK;
+	if (!prev)
+		goto out;
+
+	/*
+	 * Is there a mapping abutting this one below?
+	 *
+	 * That's only ok if it's the same stack mapping
+	 * that has gotten split or there is sufficient gap
+	 * between mappings
+	 */
+	if (prev->vm_flags & VM_GROWSDOWN) {
+		guard_gap = min(guard_gap, address - prev->vm_end);
+		goto out;
+	}
+
+	if (address - prev->vm_end < guard_gap)
+		return -ENOMEM;
+
+out:
+	/* make sure we won't underflow */
+	if (address < mmap_min_addr)
+		return -ENOMEM;
+	if (address - mmap_min_addr < guard_gap)
+		guard_gap = address - mmap_min_addr;
+
+	guard_addr = address - guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
+	unsigned long gap;
+
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_downwards(vma, address, gap);
+}
+
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
 	struct vm_area_struct *prev;
 
-	address &= PAGE_MASK;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
 	prev = vma->vm_prev;
-	if (prev && prev->vm_end == address) {
-		if (!(prev->vm_flags & VM_GROWSDOWN))
-			return -ENOMEM;
-	}
-	return expand_downwards(vma, address);
+	if (prev && prev->vm_flags & VM_GROWSDOWN)
+		return 0;
+
+	return address - vma->vm_start < stack_guard_gap;
 }
 
 struct vm_area_struct *
-- 
1.7.5.4

