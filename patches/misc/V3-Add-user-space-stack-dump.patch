From f7742485364350a59f7a4763b5de36e238331436 Mon Sep 17 00:00:00 2001
From: Paul Barrette <paul.barrette@windriver.com>
Date: Mon, 15 Oct 2012 12:31:25 -0400
Subject: [PATCH] V3 Add user space stack dump.

https://lkml.org/lkml/2012/4/17/249

Extend the current proc_pid_stack() output to include the user space stack as well.
The application must be compiled with stack frame pointers to produce
meaningful output.

Note: proc_pid_stack() is only called when reading from
/proc/<pid>/stack.  There is no other runtime performance impact.

Example dump of bash pid 589 stack containing both kernel and (new)
user stack info:
        root@qemu0:/# cat /proc/589/stack
        [<c1032d6c>] do_wait+0x1ac/0x230
        [<c1033f5d>] sys_wait4+0x7d/0xc0
        [<c1033fcc>] sys_waitpid+0x2c/0x30
        [<c16966d0>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
        userspace
        ffffe424
        08083bbc
        08074691
        080770e8
        08060f68
        0805f678
        4103d443

The userspace portion is in hex only because the kernel does not
know (or care to know) the userspace symbols so that it can print out
the corresponding function names.  However, the process running at the
time is known (e.g. 589==bash).  The developer can then run addr2line
-e <bash executable> and paste in the relevant hex address to get a
pointer to the function of interest.  addr2line can take an input
stream of many addresses, i.e. you can cut and paste all the US
hex values at once.

Note: this patch can be enabled/disabled via Kconfig CONFIG_EXT_USER_STACKTRACE_SUPPORT

Author's original patch notification:
https://lkml.org/lkml/2012/4/17/249

Extra information here:
https://lkml.org/lkml/2012/4/19/11

Signed-off-by: yanmin zhang <yanmin_zhang@linux.intel.com>
Signed-off-by: xiaobing tu <xiaobing.tu@intel.com>
Signed-off-by: Paul Barrette <paul.barrette@windriver.com>
[Pb: rewrote commit log, added doc, Kconfig, cleaned fuzz]
---
 Documentation/trace/user-stack-dump.txt |   52 +++++++++++++++++++++++++++++
 arch/x86/kernel/stacktrace.c            |   55 +++++++++++++++++++++++++++++++
 fs/proc/base.c                          |   22 ++++++++++++-
 include/linux/stacktrace.h              |    7 ++--
 kernel/trace/Kconfig                    |    8 +++++
 5 files changed, 141 insertions(+), 3 deletions(-)
 create mode 100644 Documentation/trace/user-stack-dump.txt

diff --git a/Documentation/trace/user-stack-dump.txt b/Documentation/trace/user-stack-dump.txt
new file mode 100644
index 0000000..5dbcae8
--- /dev/null
+++ b/Documentation/trace/user-stack-dump.txt
@@ -0,0 +1,52 @@
+		Extended User Stack Trace (EUST)
+		================================
+		Documentation by Paul Barrette
+
+Overview
+--------
+Extended User Stack Trace extends the user stack track functionality
+by adding an interface to dump the user space stack via cat
+/proc/<pid>/stack.  EUST support is a configurable option
+(CONFIG_EXT_USER_STACKTRACE_SUPPORT), and can be enabled if the
+current arch supports CONFIG_USER_STACKTRACE_SUPPORT.  Currently,
+only x86 has supports this feature.
+
+The user space application must be compiled with stack frame pointers.
+
+Synopsis of user stack dump
+-------------------------
+ cat /proc/<pid>/stack
+
+Usage examples
+--------------
+Dump of bash pid 589 stack containing both kernel and (new)
+user stack info:
+        root@qemu0:/# cat /proc/589/stack
+        [<c1032d6c>] do_wait+0x1ac/0x230
+        [<c1033f5d>] sys_wait4+0x7d/0xc0
+        [<c1033fcc>] sys_waitpid+0x2c/0x30
+        [<c16966d0>] sysenter_do_call+0x12/0x26
+        [<ffffffff>] 0xffffffff
+        userspace
+        ffffe424
+        08083bbc
+        08074691
+        080770e8
+        08060f68
+        0805f678
+        4103d443
+
+The user space portion is in hex only.  Tools can be used to
+process further information about the pid in question, e.g.  addr2line:
+
+	$ addr2line -e bash -f -s -p  080e531e
+
+	internal_free at malloc.c:924
+
+addr2line can take an input stream of many addresses at once.
+
+Author's original patch notification:
+https://lkml.org/lkml/2012/4/17/249
+
+Extra information here:
+https://lkml.org/lkml/2012/4/19/11
diff --git a/arch/x86/kernel/stacktrace.c b/arch/x86/kernel/stacktrace.c
index fdd0c64..8c03bfc 100644
--- a/arch/x86/kernel/stacktrace.c
+++ b/arch/x86/kernel/stacktrace.c
@@ -7,6 +7,7 @@
 #include <linux/stacktrace.h>
 #include <linux/module.h>
 #include <linux/uaccess.h>
+#include <linux/mm.h>
 #include <asm/stacktrace.h>
 
 static int save_stack_stack(void *data, char *name)
@@ -132,6 +133,7 @@ static inline void __save_stack_trace_user(struct stack_trace *trace)
 	}
 }
 
+#ifdef CONFIG_EXT_USER_STACKTRACE_SUPPORT
 void save_stack_trace_user(struct stack_trace *trace)
 {
 	/*
@@ -144,3 +146,56 @@ void save_stack_trace_user(struct stack_trace *trace)
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 
+static inline void __save_stack_trace_user_task(struct task_struct *task,
+		struct stack_trace *trace)
+{
+	const struct pt_regs *regs = task_pt_regs(task);
+	const void __user *fp;
+	unsigned long addr;
+
+	if (task != current && task->state == TASK_RUNNING && task->on_cpu) {
+		/* To trap into kernel at least once */
+		smp_send_reschedule(task_cpu(task));
+	}
+
+	fp = (const void __user *)regs->bp;
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = regs->ip;
+
+	while (trace->nr_entries < trace->max_entries) {
+		struct stack_frame_user frame;
+
+		frame.next_fp = NULL;
+		frame.ret_addr = 0;
+
+		addr = (unsigned long)fp;
+		if (!access_process_vm(task, addr, (void *)&frame,
+				sizeof(frame), 0))
+			break;
+		if ((unsigned long)fp < regs->sp)
+			break;
+		if (frame.ret_addr) {
+			trace->entries[trace->nr_entries++] =
+				frame.ret_addr;
+		}
+		if (fp == frame.next_fp)
+			break;
+		fp = frame.next_fp;
+	}
+}
+
+void save_stack_trace_user_task(struct task_struct *task,
+		struct stack_trace *trace)
+{
+	if (task == current || !task) {
+		save_stack_trace_user(trace);
+		return;
+	}
+
+	if (task->mm)
+		__save_stack_trace_user_task(task, trace);
+
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX; }
+EXPORT_SYMBOL_GPL(save_stack_trace_user_task);
+#endif
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 253ac5c..1ef4672 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -327,8 +327,28 @@ static int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,
 			seq_printf(m, "[<%pK>] %pS\n",
 				   (void *)entries[i], (void *)entries[i]);
 		}
-		unlock_trace(task);
 	}
+#ifdef CONFIG_EXT_USER_STACKTRACE_SUPPORT
+	 else
+		goto out;
+
+	trace.nr_entries	= 0;
+	trace.max_entries	= MAX_STACK_TRACE_DEPTH;
+	trace.entries		= entries;
+	trace.skip		= 0;
+
+	seq_printf(m, "userspace\n");
+
+	save_stack_trace_user_task(task, &trace);
+
+	for (i = 0; i < trace.nr_entries; i++) {
+		if (entries[i] != ULONG_MAX)
+			seq_printf(m, "%p\n", (void *)entries[i]);
+	}
+#endif
+	unlock_trace(task);
+
+out:
 	kfree(entries);
 
 	return err;
diff --git a/include/linux/stacktrace.h b/include/linux/stacktrace.h
index 115b570..4ae4ecc 100644
--- a/include/linux/stacktrace.h
+++ b/include/linux/stacktrace.h
@@ -21,10 +21,13 @@ extern void save_stack_trace_tsk(struct task_struct *tsk,
 
 extern void print_stack_trace(struct stack_trace *trace, int spaces);
 
-#ifdef CONFIG_USER_STACKTRACE_SUPPORT
+#ifdef CONFIG_EXT_USER_STACKTRACE_SUPPORT
 extern void save_stack_trace_user(struct stack_trace *trace);
+extern void save_stack_trace_user_task(struct task_struct *task,
+		struct stack_trace *trace);
 #else
-# define save_stack_trace_user(trace)              do { } while (0)
+# define save_stack_trace_user(trace)			do { } while (0)
+# define save_stack_trace_user_task(task, trace)	do { } while (0)
 #endif
 
 #else
diff --git a/kernel/trace/Kconfig b/kernel/trace/Kconfig
index 8511b79..b217efe 100644
--- a/kernel/trace/Kconfig
+++ b/kernel/trace/Kconfig
@@ -6,6 +6,14 @@
 config USER_STACKTRACE_SUPPORT
 	bool
 
+config EXT_USER_STACKTRACE_SUPPORT
+	bool "Extended user space stack dump support"
+	depends on USER_STACKTRACE_SUPPORT
+	default n
+	help
+		Adds the user space stack to /proc/<pid>/stack.
+		See Documentation/trace/user-stack-dump.txt.
+
 config NOP_TRACER
 	bool
 
-- 
1.7.9.7

