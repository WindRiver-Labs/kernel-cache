From 91e56d822bbe6d1e36ccefe759956046a2b83fab Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Tue, 16 Apr 2013 14:38:33 -0700
Subject: [PATCH 053/628] arm: xilinx: pm: Migrate to clock controller

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 28581ed9 arm: zynq: Migrate to clock controller

Switch Zynq, including its drivers, over to use the new clock
controller. And remove old clock implementation.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
[cherry picked the xilinx pm modification only]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/mach-zynq/pm.c |   43 +++++++++++++------------------------------
 1 files changed, 13 insertions(+), 30 deletions(-)

diff --git a/arch/arm/mach-zynq/pm.c b/arch/arm/mach-zynq/pm.c
index e8dc97e..16e6c6b 100644
--- a/arch/arm/mach-zynq/pm.c
+++ b/arch/arm/mach-zynq/pm.c
@@ -20,6 +20,7 @@
  */
 
 #include <linux/clk.h>
+#include <linux/clk/zynq.h>
 #include <linux/bitops.h>
 #include <linux/err.h>
 #include <linux/init.h>
@@ -45,10 +46,19 @@
 #define SCU_STBY_EN_MASK	BIT(5)
 #define TOPSW_CLK_CTRL_DIS_MASK	BIT(0)
 
-static struct clk *cpupll;
 static void __iomem *ddrc_base;
 static void __iomem *ocm_base;
 
+static int zynq_pm_prepare_late(void)
+{
+	return zynq_clk_suspend_early();
+}
+
+static void zynq_pm_wake(void)
+{
+	zynq_clk_resume_late();
+}
+
 static int zynq_pm_suspend(unsigned long arg)
 {
 	u32 reg;
@@ -114,23 +124,6 @@ static int zynq_pm_suspend(unsigned long arg)
 		do_ddrpll_bypass = 0;
 	}
 
-	/*
-	 * at this point PLLs are supposed to be bypassed:
-	 *
-	 * DDRPLL: Is bypassed without further sanity checking in the suspend
-	 * routine which is called below and executed from OCM.
-	 *
-	 * IOPLL/ARMPLL: By now all clock consumers should have released their
-	 * clock resulting in the PLLs to be bypassed. To account for timers and
-	 * similar which run in the CPU clock domain we call a disable on the
-	 * CPU clock's PLL to bypass it.
-	 *
-	 * A wake up device would prevent its source PLL from
-	 * being bypassed, unless its the DDRPLL.
-	 */
-	if (!IS_ERR(cpupll))
-		clk_disable(cpupll);
-
 	/* Transfer to suspend code in OCM */
 	if (do_ddrpll_bypass) {
 		/*
@@ -147,9 +140,6 @@ static int zynq_pm_suspend(unsigned long arg)
 		cpu_do_idle();
 	}
 
-	if (!IS_ERR(cpupll))
-		clk_enable(cpupll);
-
 	/* Restore original OCM contents */
 	if (do_ddrpll_bypass) {
 		memcpy((__force void *)ocm_base, ocm_swap_area,
@@ -208,7 +198,9 @@ static int zynq_pm_enter(suspend_state_t suspend_state)
 }
 
 static const struct platform_suspend_ops zynq_pm_ops = {
+	.prepare_late	= zynq_pm_prepare_late,
 	.enter		= zynq_pm_enter,
+	.wake		= zynq_pm_wake,
 	.valid		= suspend_valid_only_mem,
 };
 
@@ -267,15 +259,6 @@ static void __iomem *zynq_pm_remap_ocm(void)
 
 int __init zynq_pm_late_init(void)
 {
-	cpupll = clk_get_sys("CPU_6OR4X_CLK", NULL);
-	if (!IS_ERR(cpupll)) {
-		cpupll = clk_get_parent(cpupll);
-		if (!IS_ERR(cpupll))
-			cpupll = clk_get_parent(cpupll);
-	}
-	if (IS_ERR(cpupll))
-		pr_warn("%s: CPUPLL not found.\n", __func__);
-
 	ddrc_base = zynq_pm_ioremap("xlnx,ps7-ddrc");
 	if (!ddrc_base)
 		pr_warn("%s: Unable to map DDRC IO memory.\n", __func__);
-- 
1.7.5.4

