From e5435e73227bca00fda7b1c535272b518c16c5af Mon Sep 17 00:00:00 2001
From: "J. R. Okajima" <hooanon05g@gmail.com>
Date: Mon, 15 Feb 2016 15:42:10 +0900
Subject: [PATCH] aufs: security bugfix, test mnt_ns in open(2) for fuse
 branch

commit 01070dabac932a102816ab366fd4ea5a584c2baf from
https://github.com/sfjro/aufs4-standalone.git aufs4.0

Under a special condition, an executable on a malicious FUSE branch could
escalate its privilege via aufs. In order to prevent this, here adds a
test about mnt_ns into open(2) for FUSE branch only.

(How can I describe the security detail before the issue will be opened
on the coordinated release date (CRD)?)

Reported-by: halfdog <me@halfdog.net>
Signed-off-by: J. R. Okajima <hooanon05g@gmail.com>
(cherry picked from commit aae4cfb36c5a2a4643785438face14619fec482e)
Signed-off-by: Qi Hou <qi.hou@windriver.com>

Conflicts:
	fs/aufs/dir.c
---
 fs/aufs/dir.c    |    5 +++++
 fs/aufs/f_op.c   |   17 +++++++++++++----
 fs/aufs/module.c |    2 +-
 fs/aufs/module.h |    1 +
 fs/aufs/vfsub.c  |   18 ++++++++++++++++++
 fs/aufs/vfsub.h  |    6 ++++++
 6 files changed, 44 insertions(+), 5 deletions(-)

diff --git a/fs/aufs/dir.c b/fs/aufs/dir.c
index 7705c29..fd7cc41 100644
--- a/fs/aufs/dir.c
+++ b/fs/aufs/dir.c
@@ -250,10 +250,12 @@ static int do_open_dir(struct file *file, int flags, struct file *h_file)
 	int err;
 	aufs_bindex_t bindex, btail;
 	struct dentry *dentry, *h_dentry;
+	struct vfsmount *mnt;
 
 	FiMustWriteLock(file);
 	AuDebugOn(h_file);
 
+	mnt = file->f_path.mnt;
 	err = 0;
 	dentry = file->f_path.dentry;
 	file->f_version = d_inode(dentry)->i_version;
@@ -266,6 +268,9 @@ static int do_open_dir(struct file *file, int flags, struct file *h_file)
 		if (!h_dentry)
 			continue;
 
+		err = vfsub_test_mntns(mnt, h_dentry->d_sb);
+		if (unlikely(err))
+			break;
 		h_file = au_h_open(dentry, bindex, flags, file, /*force_wr*/0);
 		if (IS_ERR(h_file)) {
 			err = PTR_ERR(h_file);
diff --git a/fs/aufs/f_op.c b/fs/aufs/f_op.c
index 34037c7..cb8d5fd 100644
--- a/fs/aufs/f_op.c
+++ b/fs/aufs/f_op.c
@@ -29,7 +29,7 @@ int au_do_open_nondir(struct file *file, int flags, struct file *h_file)
 {
 	int err;
 	aufs_bindex_t bindex;
-	struct dentry *dentry;
+	struct dentry *dentry, *h_dentry;
 	struct au_finfo *finfo;
 	struct inode *h_inode;
 
@@ -42,10 +42,19 @@ int au_do_open_nondir(struct file *file, int flags, struct file *h_file)
 	memset(&finfo->fi_htop, 0, sizeof(finfo->fi_htop));
 	atomic_set(&finfo->fi_mmapped, 0);
 	bindex = au_dbstart(dentry);
-	if (!h_file)
+	if (!h_file) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		err = vfsub_test_mntns(file->f_path.mnt, h_dentry->d_sb);
+		if (unlikely(err))
+			goto out;
 		h_file = au_h_open(dentry, bindex, flags, file, /*force_wr*/0);
-	else
+	} else {
+		h_dentry = h_file->f_path.dentry;
+		err = vfsub_test_mntns(file->f_path.mnt, h_dentry->d_sb);
+		if (unlikely(err))
+			goto out;
 		get_file(h_file);
+	}
 	if (IS_ERR(h_file))
 		err = PTR_ERR(h_file);
 	else {
@@ -62,7 +71,7 @@ int au_do_open_nondir(struct file *file, int flags, struct file *h_file)
 		/* todo: necessary? */
 		/* file->f_ra = h_file->f_ra; */
 	}
-
+out:
 	return err;
 }
 
diff --git a/fs/aufs/module.c b/fs/aufs/module.c
index 2c70dff..583a4b6 100644
--- a/fs/aufs/module.c
+++ b/fs/aufs/module.c
@@ -110,7 +110,7 @@ MODULE_PARM_DESC(brs, "use <sysfs>/fs/aufs/si_*/brN");
 module_param_named(brs, sysaufs_brs, int, S_IRUGO);
 
 /* this module parameter has no meaning when USER_NS is disabled */
-static bool au_userns;
+bool au_userns;
 MODULE_PARM_DESC(allow_userns, "allow unprivileged to mount under userns");
 module_param_named(allow_userns, au_userns, bool, S_IRUGO);
 
diff --git a/fs/aufs/module.h b/fs/aufs/module.h
index c0a29d4..c39db2f 100644
--- a/fs/aufs/module.h
+++ b/fs/aufs/module.h
@@ -31,6 +31,7 @@ struct seq_file;
 
 /* module parameters */
 extern int sysaufs_brs;
+extern bool au_userns;
 
 /* ---------------------------------------------------------------------- */
 
diff --git a/fs/aufs/vfsub.c b/fs/aufs/vfsub.c
index d2af7ce..57758c7 100644
--- a/fs/aufs/vfsub.c
+++ b/fs/aufs/vfsub.c
@@ -20,10 +20,28 @@
  */
 
 #include <linux/namei.h>
+#include <linux/nsproxy.h>
 #include <linux/security.h>
 #include <linux/splice.h>
+#include "../fs/mount.h"
 #include "aufs.h"
 
+#ifdef CONFIG_AUFS_BR_FUSE
+int vfsub_test_mntns(struct vfsmount *mnt, struct super_block *h_sb)
+{
+	struct nsproxy *ns;
+
+	if (!au_test_fuse(h_sb) || !au_userns)
+		return 0;
+
+	ns = current->nsproxy;
+	/* no {get,put}_nsproxy(ns) */
+	return real_mount(mnt)->mnt_ns == ns->mnt_ns ? 0 : -EACCES;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
 int vfsub_update_h_iattr(struct path *h_path, int *did)
 {
 	int err;
diff --git a/fs/aufs/vfsub.h b/fs/aufs/vfsub.h
index 41ad33e..6d43fec 100644
--- a/fs/aufs/vfsub.h
+++ b/fs/aufs/vfsub.h
@@ -77,6 +77,12 @@ static inline int vfsub_native_ro(struct inode *inode)
 		|| IS_IMMUTABLE(inode);
 }
 
+#ifdef CONFIG_AUFS_BR_FUSE
+int vfsub_test_mntns(struct vfsmount *mnt, struct super_block *h_sb);
+#else
+AuStubInt0(vfsub_test_mntns, struct vfsmount *mnt, struct super_block *h_sb);
+#endif
+
 /* ---------------------------------------------------------------------- */
 
 int vfsub_update_h_iattr(struct path *h_path, int *did);
-- 
1.7.5.4

