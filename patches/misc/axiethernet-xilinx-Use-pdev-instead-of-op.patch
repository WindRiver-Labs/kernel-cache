From b668a6f7908cff4d83d25ba1f0e5de6980edfa1e Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@xilinx.com>
Date: Tue, 24 Sep 2013 20:00:52 +0530
Subject: [PATCH 457/628] axiethernet: xilinx: Use pdev instead of op

git://github.com/Xilinx/linux-xlnx.git xilinx-v2013.4
commit 44dff6d810ef81b04183c1b08ece7499dc0f6772

Synchronize names with other drivers

Signed-off-by: Srikanth Thokala <sthokal@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet_main.c |   53 +++++++++++----------
 1 files changed, 27 insertions(+), 26 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 5e260d5..9278d43 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -1506,7 +1506,7 @@ static void axienet_dma_err_handler(unsigned long data)
 
 /**
  * axienet_of_probe - Axi Ethernet probe function.
- * @op:		Pointer to platform device structure.
+ * @pdev:		Pointer to platform device structure.
  *
  * returns: 0, on success
  *	    Non-zero error value on failure.
@@ -1516,7 +1516,7 @@ static void axienet_dma_err_handler(unsigned long data)
  * device. Parses through device tree and populates fields of
  * axienet_local. It registers the Ethernet device.
  */
-static int axienet_of_probe(struct platform_device *op)
+static int axienet_of_probe(struct platform_device *pdev)
 {
 	__be32 *p;
 	int size, ret = 0;
@@ -1530,9 +1530,9 @@ static int axienet_of_probe(struct platform_device *op)
 		return -ENOMEM;
 
 	ether_setup(ndev);
-	platform_set_drvdata(op, ndev);
+	platform_set_drvdata(pdev, ndev);
 
-	SET_NETDEV_DEV(ndev, &op->dev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
 	ndev->flags &= ~IFF_MULTICAST;  /* clear multicast */
 	ndev->features = NETIF_F_FRAGLIST;
 	ndev->netdev_ops = &axienet_netdev_ops;
@@ -1540,19 +1540,19 @@ static int axienet_of_probe(struct platform_device *op)
 
 	lp = netdev_priv(ndev);
 	lp->ndev = ndev;
-	lp->dev = &op->dev;
+	lp->dev = &pdev->dev;
 	lp->options = XAE_OPTION_DEFAULTS;
 	/* Map device registers */
-	lp->regs = of_iomap(op->dev.of_node, 0);
+	lp->regs = of_iomap(pdev->dev.of_node, 0);
 	if (!lp->regs) {
-		dev_err(&op->dev, "could not map Axi Ethernet regs.\n");
+		dev_err(&pdev->dev, "could not map Axi Ethernet regs.\n");
 		goto nodev;
 	}
 	/* Setup checksum offload, but default to off if not specified */
 	lp->features = 0;
 
-	p = (__be32 *) of_get_property(op->dev.of_node, "xlnx,txcsum", NULL);
-	dev_info(&op->dev, "TX_CSUM %d\n", be32_to_cpup(p));
+	p = (__be32 *) of_get_property(pdev->dev.of_node, "xlnx,txcsum", NULL);
+	dev_info(&pdev->dev, "TX_CSUM %d\n", be32_to_cpup(p));
 	if (p) {
 		switch (be32_to_cpup(p)) {
 		case 1:
@@ -1573,8 +1573,8 @@ static int axienet_of_probe(struct platform_device *op)
 			lp->csum_offload_on_tx_path = XAE_NO_CSUM_OFFLOAD;
 		}
 	}
-	p = (__be32 *) of_get_property(op->dev.of_node, "xlnx,rxcsum", NULL);
-	dev_info(&op->dev, "RX_CSUM %d\n", be32_to_cpup(p));
+	p = (__be32 *) of_get_property(pdev->dev.of_node, "xlnx,rxcsum", NULL);
+	dev_info(&pdev->dev, "RX_CSUM %d\n", be32_to_cpup(p));
 	if (p) {
 		switch (be32_to_cpup(p)) {
 		case 1:
@@ -1597,43 +1597,44 @@ static int axienet_of_probe(struct platform_device *op)
 	 * Here we check for memory allocated for Rx/Tx in the hardware from
 	 * the device-tree and accordingly set flags.
 	 */
-	p = (__be32 *) of_get_property(op->dev.of_node, "xlnx,rxmem", NULL);
+	p = (__be32 *) of_get_property(pdev->dev.of_node, "xlnx,rxmem", NULL);
 	if (p)
 		lp->rxmem = be32_to_cpup(p);
-	p = (__be32 *) of_get_property(op->dev.of_node, "xlnx,temac-type",
+	p = (__be32 *) of_get_property(pdev->dev.of_node, "xlnx,temac-type",
 				       NULL);
 	if (p)
 		lp->temac_type = be32_to_cpup(p);
-	p = (__be32 *) of_get_property(op->dev.of_node, "xlnx,phy-type", NULL);
+	p = (__be32 *) of_get_property(pdev->dev.of_node,
+						"xlnx,phy-type", NULL);
 	if (p)
 		lp->phy_type = be32_to_cpup(p);
 
 	/* Find the DMA node, map the DMA registers, and decode the DMA IRQs */
-	np = of_parse_phandle(op->dev.of_node, "axistream-connected", 0);
+	np = of_parse_phandle(pdev->dev.of_node, "axistream-connected", 0);
 	if (!np) {
-		dev_err(&op->dev, "could not find DMA node\n");
+		dev_err(&pdev->dev, "could not find DMA node\n");
 		goto err_iounmap;
 	}
 	lp->dma_regs = of_iomap(np, 0);
 	if (lp->dma_regs) {
-		dev_dbg(&op->dev, "MEM base: %p\n", lp->dma_regs);
+		dev_dbg(&pdev->dev, "MEM base: %p\n", lp->dma_regs);
 	} else {
-		dev_err(&op->dev, "unable to map DMA registers\n");
+		dev_err(&pdev->dev, "unable to map DMA registers\n");
 		of_node_put(np);
 	}
 	lp->rx_irq = irq_of_parse_and_map(np, 1);
 	lp->tx_irq = irq_of_parse_and_map(np, 0);
 	of_node_put(np);
 	if ((lp->rx_irq <= 0) || (lp->tx_irq <= 0)) {
-		dev_err(&op->dev, "could not determine irqs\n");
+		dev_err(&pdev->dev, "could not determine irqs\n");
 		ret = -ENOMEM;
 		goto err_iounmap_2;
 	}
 
 	/* Retrieve the MAC address */
-	addr = of_get_property(op->dev.of_node, "local-mac-address", &size);
+	addr = of_get_property(pdev->dev.of_node, "local-mac-address", &size);
 	if ((!addr) || (size != 6)) {
-		dev_err(&op->dev, "could not find MAC address\n");
+		dev_err(&pdev->dev, "could not find MAC address\n");
 		ret = -ENODEV;
 		goto err_iounmap_2;
 	}
@@ -1642,11 +1643,11 @@ static int axienet_of_probe(struct platform_device *op)
 	lp->coalesce_count_rx = XAXIDMA_DFT_RX_THRESHOLD;
 	lp->coalesce_count_tx = XAXIDMA_DFT_TX_THRESHOLD;
 
-	lp->phy_node = of_parse_phandle(op->dev.of_node, "phy-handle", 0);
+	lp->phy_node = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
 	if (lp->phy_node)
-		ret = axienet_mdio_setup(lp, op->dev.of_node);
+		ret = axienet_mdio_setup(lp, pdev->dev.of_node);
 	if (ret)
-		dev_warn(&op->dev, "error registering MDIO bus\n");
+		dev_warn(&pdev->dev, "error registering MDIO bus\n");
 
 	ret = register_netdev(lp->ndev);
 	if (ret) {
@@ -1667,9 +1668,9 @@ nodev:
 	return ret;
 }
 
-static int axienet_of_remove(struct platform_device *op)
+static int axienet_of_remove(struct platform_device *pdev)
 {
-	struct net_device *ndev = platform_get_drvdata(op);
+	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct axienet_local *lp = netdev_priv(ndev);
 
 	axienet_mdio_teardown(lp);
-- 
1.7.5.4

