From d16b12631549cb3c249a166fefefd749a542bbe6 Mon Sep 17 00:00:00 2001
From: Brad Spengler <spender@grsecurity.net>
Date: Tue, 12 Apr 2016 15:08:21 +0800
Subject: [PATCH] cred: bug fix related to GRKERNSEC_SETXID

Patch from grsecurity patch:
https://raw.githubusercontent.com/slashbeast/grsecurity-scrape/master/test/grsecurity-3.0-3.14.5-201406021708.patch

Fix a bug with GRKERNSEC_SETXID exhibited by ntpd bailing out when
being unable to drop privileges.  It drops privileges itself in
two separate threads, though only one of the threads calls a
PR_SET_KEEPCAPS which forks off the cred struct.  While it's a little
silly for ntpd to be doing this (having two threads of different
privilege with the same shared memory space) we can make
GRKERNSEC_SETXID compatible by only scheduling a credential change
for tasks that share a cred struct with the thread that's doing
the root -> nonroot setuid

Thanks to strcat for the report

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 kernel/cred.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/kernel/cred.c b/kernel/cred.c
index 0d4998e..e8d7ce7 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -563,6 +563,7 @@ int commit_creds(struct cred *new)
 	int ret;
 	int schedule_it = 0;
 	struct task_struct *t;
+	unsigned oldsecurebits = current_cred()->securebits;
 
 	/* we won't get called with tasklist_lock held for writing
 	   and interrupts disabled as the cred struct in that case is
@@ -579,7 +580,11 @@ int commit_creds(struct cred *new)
 		read_lock(&tasklist_lock);
 		for (t = next_thread(current); t != current;
 		     t = next_thread(t)) {
-			if (t->delayed_cred == NULL) {
+			/* we'll check if the thread has uid 0 in
+			 * the delayed worker routine
+			 */
+			if (task_cred_xxx(t, securebits) == oldsecurebits &&
+			    t->delayed_cred == NULL) {
 				t->delayed_cred = get_cred(new);
 				set_tsk_thread_flag(t, TIF_GRSEC_SETXID);
 				set_tsk_need_resched(t);
-- 
1.7.5.4

