From faca6a9a235cff8d9bd8738eb567664cb0e8c99b Mon Sep 17 00:00:00 2001
From: John Stultz <john.stultz@linaro.org>
Date: Wed, 11 Dec 2013 20:07:49 -0800
Subject: [PATCH 3/4] timekeeping: Fix potential lost pv notification of time
 change

commit 5258d3f25c76f6ab86e9333abf97a55a877d3870 upstream

In 780427f0e11 (Indicate that clock was set in the pvclock
gtod notifier), logic was added to pass a CLOCK_WAS_SET
notification to the pvclock notifier chain.

While that patch added a action flag returned from
accumulate_nsecs_to_secs(), it only uses the returned value
in one location, and not in the logarithmic accumulation.

This means if a leap second triggered during the logarithmic
accumulation (which is most likely where it would happen),
the notification that the clock was set would not make it to
the pv notifiers.

This patch extends the logarithmic_accumulation pass down
that action flag so proper notification will occur.

This patch also changes the varialbe action -> clock_set
per Ingo's suggestion.

Cc: Sasha Levin <sasha.levin@oracle.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: David Vrabel <david.vrabel@citrix.com>
Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Cc: Prarit Bhargava <prarit@redhat.com>
Cc: Richard Cochran <richardcochran@gmail.com>
Cc: <xen-devel@lists.xen.org>
Cc: stable <stable@vger.kernel.org> #3.11+
Signed-off-by: John Stultz <john.stultz@linaro.org>
Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 kernel/time/timekeeping.c |   15 +++++++++------
 1 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index aab8568..2ef1f13 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -804,7 +804,7 @@ static void timekeeping_adjust(s64 offset)
 static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)
 {
 	u64 nsecps = (u64)NSEC_PER_SEC << tk->shift;
-	unsigned int action = 0;
+	unsigned int clock_set = 0;
 
 	while (tk->xtime_nsec >= nsecps) {
 		int leap;
@@ -815,10 +815,10 @@ static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)
 		wall_to_monotonic.tv_sec -= leap;
 		if (leap) {
 			clock_was_set_delayed();
-			action = TK_CLOCK_WAS_SET;
+			clock_set = TK_CLOCK_WAS_SET;
 		}
 	}
-	return action;
+	return clock_set;
 }
 
 
@@ -831,7 +831,8 @@ static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)
  *
  * Returns the unconsumed cycles.
  */
-static cycle_t logarithmic_accumulation(cycle_t offset, int shift)
+static cycle_t logarithmic_accumulation(cycle_t offset, int shift,
+						unsigned int *clock_set)
 {
 
 	/* If the offset is smaller then a shifted interval, do nothing */
@@ -844,7 +845,7 @@ static cycle_t logarithmic_accumulation(cycle_t offset, int shift)
 
 	timekeeper.xtime_nsec += timekeeper.xtime_interval << shift;
 
-	accumulate_nsecs_to_secs(&timekeeper);
+	*clock_set |= accumulate_nsecs_to_secs(&timekeeper);
 
 	/* Accumulate into raw time */
 	raw_time.tv_nsec += timekeeper.raw_interval << shift;;
@@ -874,6 +875,7 @@ void update_wall_time(void)
 	cycle_t offset;
 	u64 nsecs;
 	int shift = 0, maxshift;
+	unsigned int clock_set = 0;
 
 	/* Make sure we're fully resumed: */
 	if (unlikely(timekeeping_suspended))
@@ -905,7 +907,8 @@ void update_wall_time(void)
 	maxshift = (8*sizeof(tick_length) - (ilog2(tick_length)+1)) - 1;
 	shift = min(shift, maxshift);
 	while (offset >= timekeeper.cycle_interval) {
-		offset = logarithmic_accumulation(offset, shift);
+		offset = logarithmic_accumulation(offset, shift,
+							&clock_set);
 		if(offset < timekeeper.cycle_interval<<shift)
 			shift--;
 	}
-- 
1.7.5.4

