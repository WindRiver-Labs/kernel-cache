From 58beeb4463dbbaa87cb90913b6408c6c6bca5dcc Mon Sep 17 00:00:00 2001
From: John Linn <john.linn@xilinx.com>
Date: Fri, 29 Jun 2012 11:27:45 -0700
Subject: [PATCH 320/628] Xilinx: ARM: GPIO: updated driver names for cleanup

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit e9a98626baf3b31fa6a699576d8d089c5df10f35

Driver names were changed to match the kernel.

Signed-off-by: John Linn <john.linn@xilinx.com>
[make some slight adjustments for Makefile]
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/gpio/Makefile        |    1 +
 drivers/gpio/gpio-xilinx.c   |  172 ++++++++++++-
 drivers/gpio/gpio-xilinxps.c |  565 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 727 insertions(+), 11 deletions(-)
 create mode 100644 drivers/gpio/gpio-xilinxps.c

diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 0cb2d65..2636985 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_GPIO_WM831X)	+= gpio-wm831x.o
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
+obj-$(CONFIG_GPIO_XILINX_PS)	+= gpio-xilinxps.o
diff --git a/drivers/gpio/gpio-xilinx.c b/drivers/gpio/gpio-xilinx.c
index 9ae7aa8..2311e49 100644
--- a/drivers/gpio/gpio-xilinx.c
+++ b/drivers/gpio/gpio-xilinx.c
@@ -1,7 +1,7 @@
 /*
- * Xilinx gpio driver
+ * Xilinx gpio driver for xps/axi_gpio IP.
  *
- * Copyright 2008 Xilinx, Inc.
+ * Copyright 2008, 2011 Xilinx, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2
@@ -14,7 +14,6 @@
 
 #include <linux/init.h>
 #include <linux/errno.h>
-#include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
@@ -26,8 +25,17 @@
 #define XGPIO_DATA_OFFSET   (0x0)	/* Data register  */
 #define XGPIO_TRI_OFFSET    (0x4)	/* I/O direction register  */
 
+/* Read/Write access to the GPIO registers */
+#define xgpio_readreg(offset)		__raw_readl(offset)
+#define xgpio_writereg(offset, val)	__raw_writel(val, offset)
+
 struct xgpio_instance {
+#ifdef CONFIG_OF
 	struct of_mm_gpio_chip mmchip;
+#else
+	struct gpio_chip gc;
+	void __iomem *regs;
+#endif
 	u32 gpio_state;		/* GPIO state shadow register */
 	u32 gpio_dir;		/* GPIO direction shadow register */
 	spinlock_t gpio_lock;	/* Lock used for synchronization */
@@ -43,9 +51,15 @@ struct xgpio_instance {
  */
 static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)
 {
+#ifdef CONFIG_OF
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-
-	return (in_be32(mm_gc->regs + XGPIO_DATA_OFFSET) >> gpio) & 1;
+	void __iomem *regs = mm_gc->regs;
+#else
+	struct xgpio_instance *chip = container_of(gc, struct xgpio_instance,
+						   gc);
+	void __iomem *regs = chip->regs;
+#endif
+	return (xgpio_readreg(regs + XGPIO_DATA_OFFSET) >> gpio) & 1;
 }
 
 /**
@@ -60,9 +74,16 @@ static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)
 static void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
 {
 	unsigned long flags;
+#ifdef CONFIG_OF
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct xgpio_instance *chip =
 	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
+#else
+	struct xgpio_instance *chip = container_of(gc, struct xgpio_instance,
+						   gc);
+	void __iomem *regs = chip->regs;
+#endif
 
 	spin_lock_irqsave(&chip->gpio_lock, flags);
 
@@ -71,7 +92,8 @@ static void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
 		chip->gpio_state |= 1 << gpio;
 	else
 		chip->gpio_state &= ~(1 << gpio);
-	out_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);
+
+	xgpio_writereg(regs + XGPIO_DATA_OFFSET, chip->gpio_state);
 
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
@@ -88,15 +110,22 @@ static void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
 static int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
 {
 	unsigned long flags;
+#ifdef CONFIG_OF
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct xgpio_instance *chip =
 	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
+#else
+	struct xgpio_instance *chip = container_of(gc, struct xgpio_instance,
+						   gc);
+	void __iomem *regs = chip->regs;
+#endif
 
 	spin_lock_irqsave(&chip->gpio_lock, flags);
 
 	/* Set the GPIO bit in shadow register and set direction as input */
 	chip->gpio_dir |= (1 << gpio);
-	out_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
+	xgpio_writereg(regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
 
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
@@ -116,9 +145,16 @@ static int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
 static int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
 {
 	unsigned long flags;
+#ifdef CONFIG_OF
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct xgpio_instance *chip =
 	    container_of(mm_gc, struct xgpio_instance, mmchip);
+	void __iomem *regs = mm_gc->regs;
+#else
+	struct xgpio_instance *chip = container_of(gc, struct xgpio_instance,
+						   gc);
+	void __iomem *regs = chip->regs;
+#endif
 
 	spin_lock_irqsave(&chip->gpio_lock, flags);
 
@@ -127,17 +163,18 @@ static int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
 		chip->gpio_state |= 1 << gpio;
 	else
 		chip->gpio_state &= ~(1 << gpio);
-	out_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);
+	xgpio_writereg(regs + XGPIO_DATA_OFFSET, chip->gpio_state);
 
 	/* Clear the GPIO bit in shadow register and set direction as output */
 	chip->gpio_dir &= (~(1 << gpio));
-	out_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
+	xgpio_writereg(regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
 
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
 
+#ifdef CONFIG_OF
 /**
  * xgpio_save_regs - Set initial values of GPIO pins
  * @mm_gc: pointer to memory mapped GPIO chip structure
@@ -147,8 +184,8 @@ static void xgpio_save_regs(struct of_mm_gpio_chip *mm_gc)
 	struct xgpio_instance *chip =
 	    container_of(mm_gc, struct xgpio_instance, mmchip);
 
-	out_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);
-	out_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
+	xgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);
+	xgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
 }
 
 /**
@@ -206,6 +243,7 @@ static int xgpio_of_probe(struct device_node *np)
 		       np->full_name, status);
 		return status;
 	}
+	pr_info("XGpio: %s: registered\n", np->full_name);
 	return 0;
 }
 
@@ -214,14 +252,126 @@ static struct of_device_id xgpio_of_match[] = {
 	{ /* end of list */ },
 };
 
+#else
+
+/**
+ * xgpio_probe - Probe method for the GPIO device
+ * @pdev:	platform device instance
+ *
+ * This function allocates memory resources for the xgpio device and initializes
+ * the driver structures.
+ *
+ * Return:	0 on success, negative error otherwise.
+ */
+static int __init xgpio_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct xgpio_instance *chip;
+	struct gpio_chip *gc;
+	struct resource *mem_res = NULL;
+	struct xgpio_platform_data *pdata;
+
+	chip = kzalloc(sizeof(struct xgpio_instance), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&pdev->dev, "couldn't allocate memory for gpio private "
+			"data\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		ret = -ENODEV;
+		goto err_free_gpio;
+	}
+
+	if (!request_mem_region(mem_res->start, resource_size(mem_res),
+				pdev->name)) {
+		dev_err(&pdev->dev, "Cannot request IO\n");
+		ret = -ENXIO;
+		goto err_free_gpio;
+	}
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_err(&pdev->dev, "Cannot find platform data\n");
+		return -ENODEV;
+	}
+
+	chip->regs = ioremap(mem_res->start, resource_size(mem_res));
+	if (chip->regs == NULL) {
+		dev_err(&pdev->dev, "Couldn't ioremap memory at 0x%08lx\n",
+			(unsigned long)mem_res->start);
+		ret = -ENOMEM;
+		goto err_release_region;
+	}
+
+	chip->gpio_state = pdata->state;
+	chip->gpio_dir = pdata->dir;
+
+	xgpio_writereg(chip->regs + XGPIO_DATA_OFFSET, chip->gpio_state);
+	xgpio_writereg(chip->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);
+
+	/* configure the gpio chip */
+	gc = &chip->gc;
+	gc->label = "xgpio";
+	gc->owner = THIS_MODULE;
+	gc->dev = &pdev->dev;
+	gc->get = xgpio_get;
+	gc->set = xgpio_set;
+	gc->direction_input = xgpio_dir_in;
+	gc->direction_output = xgpio_dir_out;
+	gc->dbg_show = NULL;
+	gc->base = 0;		/* default pin base */
+	gc->ngpio = pdata->width;
+	gc->can_sleep = 0;
+
+	ret = gpiochip_add(gc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "gpio gc registration failed\n");
+		goto err_iounmap;
+	} else
+		dev_info(&pdev->dev, "gpio at 0x%08lx mapped to 0x%08lx\n",
+			 (unsigned long)mem_res->start,
+			 (unsigned long)chip->regs);
+
+	return 0;
+
+err_iounmap:
+	iounmap(chip->regs);
+err_release_region:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+err_free_gpio:
+	platform_set_drvdata(pdev, NULL);
+	kfree(chip);
+
+	return ret;
+}
+
+static struct platform_driver xgpio_driver = {
+	.driver	= {
+		.name	= "xilinx_gpio",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= xgpio_probe,
+};
+
+#endif /* CONFIG_OF */
+
 static int __init xgpio_init(void)
 {
+#ifdef CONFIG_OF
 	struct device_node *np;
 
 	for_each_matching_node(np, xgpio_of_match)
 		xgpio_of_probe(np);
 
 	return 0;
+#else
+	return platform_driver_register(&xgpio_driver);
+#endif
 }
 
 /* Make sure we get initialized before anyone else tries to use us */
diff --git a/drivers/gpio/gpio-xilinxps.c b/drivers/gpio/gpio-xilinxps.c
new file mode 100644
index 0000000..bfff00b
--- /dev/null
+++ b/drivers/gpio/gpio-xilinxps.c
@@ -0,0 +1,565 @@
+/*
+ * Xilinx PS GPIO device driver
+ *
+ * 2009-2011 (c) Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 675 Mass
+ * Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#define DRIVER_NAME "xgpiops"
+
+/* Register offsets for the GPIO device */
+
+#define XGPIOPS_DATA_LSW_OFFSET(BANK)	(0x000 + (8 * BANK)) /* LSW Mask &
+								Data -WO */
+#define XGPIOPS_DATA_MSW_OFFSET(BANK)	(0x004 + (8 * BANK)) /* MSW Mask &
+								Data -WO */
+#define XGPIOPS_DATA_OFFSET(BANK)	(0x040 + (4 * BANK)) /* Data Register
+								-RW */
+#define XGPIOPS_DIRM_OFFSET(BANK)	(0x204 + (0x40 * BANK)) /* Direction
+								mode reg-RW */
+#define XGPIOPS_OUTEN_OFFSET(BANK)	(0x208 + (0x40 * BANK)) /* Output
+								enable reg-RW
+								 */
+#define XGPIOPS_INTMASK_OFFSET(BANK)	(0x20C + (0x40 * BANK)) /* Interrupt
+								mask reg-RO */
+#define XGPIOPS_INTEN_OFFSET(BANK)	(0x210 + (0x40 * BANK)) /* Interrupt
+								enable reg-WO
+								 */
+#define XGPIOPS_INTDIS_OFFSET(BANK)	(0x214 + (0x40 * BANK)) /* Interrupt
+								disable reg-WO
+								 */
+#define XGPIOPS_INTSTS_OFFSET(BANK)	(0x218 + (0x40 * BANK)) /* Interrupt
+								status reg-RO
+								 */
+#define XGPIOPS_INTTYPE_OFFSET(BANK)	(0x21C + (0x40 * BANK)) /* Interrupt
+								type reg-RW
+								 */
+#define XGPIOPS_INTPOL_OFFSET(BANK)	(0x220 + (0x40 * BANK)) /* Interrupt
+								polarity reg
+								-RW */
+#define XGPIOPS_INTANY_OFFSET(BANK)	(0x224 + (0x40 * BANK)) /* Interrupt on
+								any, reg-RW */
+
+/* Read/Write access to the GPIO PS registers */
+#define xgpiops_readreg(offset)		__raw_readl(offset)
+#define xgpiops_writereg(val, offset)	__raw_writel(val, offset)
+
+static unsigned int xgpiops_pin_table[] = {
+	31, /* 0 - 31 */
+	53, /* 32 - 53 */
+	85, /* 54 - 85 */
+	117 /* 86 - 117 */
+};
+
+/**
+ * struct xgpiops - gpio device private data structure
+ * @chip:	instance of the gpio_chip
+ * @base_addr:	base address of the GPIO device
+ * @gpio_lock:	lock used for synchronization
+ */
+struct xgpiops {
+	struct gpio_chip chip;
+	void __iomem *base_addr;
+	spinlock_t gpio_lock;
+};
+
+/**
+ * xgpiops_get_bank_pin - Get the bank number and pin number within that bank
+ * for a given pin in the GPIO device
+ * @pin_num:	gpio pin number within the device
+ * @bank_num:	an output parameter used to return the bank number of the gpio
+ *		pin
+ * @bank_pin_num: an output parameter used to return pin number within a bank
+ *		  for the given gpio pin
+ *
+ * Returns the bank number.
+ */
+static inline void xgpiops_get_bank_pin(unsigned int pin_num,
+					 unsigned int *bank_num,
+					 unsigned int *bank_pin_num)
+{
+	for (*bank_num = 0; *bank_num < 4; (*bank_num)++)
+		if (pin_num <= xgpiops_pin_table[*bank_num])
+			break;
+
+	if (*bank_num == 0)
+		*bank_pin_num = pin_num;
+	else
+		*bank_pin_num = pin_num %
+					(xgpiops_pin_table[*bank_num - 1] + 1);
+}
+
+/**
+ * xgpiops_get_value - Get the state of the specified pin of GPIO device
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function reads the state of the specified pin of the GPIO device.
+ * It returns 0 if the pin is low, 1 if pin is high.
+ */
+static int xgpiops_get_value(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned int bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	return (xgpiops_readreg(gpio->base_addr +
+				 XGPIOPS_DATA_OFFSET(bank_num)) >>
+		bank_pin_num) & 1;
+}
+
+/**
+ * xgpiops_set_value - Modify the state of the pin with specified value
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ * @state:	value used to modify the state of the specified pin
+ *
+ * This function calculates the register offset (i.e to lower 16 bits or
+ * upper 16 bits) based on the given pin number and sets the state of a
+ * gpio pin to the specified value. The state is either 0 or non-zero.
+ */
+static void xgpiops_set_value(struct gpio_chip *chip, unsigned int pin,
+			       int state)
+{
+	unsigned long flags;
+	unsigned int reg_offset;
+	unsigned int bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	if (bank_pin_num >= 16) {
+		bank_pin_num -= 16; /* only 16 data bits in bit maskable reg */
+		reg_offset = XGPIOPS_DATA_MSW_OFFSET(bank_num);
+	} else
+		reg_offset = XGPIOPS_DATA_LSW_OFFSET(bank_num);
+
+	/*
+	 * get the 32 bit value to be written to the mask/data register where
+	 * the upper 16 bits is the mask and lower 16 bits is the data
+	 */
+	if (state)
+		state = 1;
+	state = ~(1 << (bank_pin_num + 16)) & ((state << bank_pin_num) |
+					       0xFFFF0000);
+
+	spin_lock_irqsave(&gpio->gpio_lock, flags);
+	xgpiops_writereg(state, gpio->base_addr + reg_offset);
+	spin_unlock_irqrestore(&gpio->gpio_lock, flags);
+}
+
+/**
+ * xgpiops_dir_in - Set the direction of the specified GPIO pin as input
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ *
+ * This function uses the read-modify-write sequence to set the direction of
+ * the gpio pin as input. Returns 0 always.
+ */
+static int xgpiops_dir_in(struct gpio_chip *chip, unsigned int pin)
+{
+	unsigned int reg, bank_num, bank_pin_num;
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+	/* clear the bit in direction mode reg to set the pin as input */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_DIRM_OFFSET(bank_num));
+	reg &= ~(1 << bank_pin_num);
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+
+	return 0;
+}
+
+/**
+ * xgpiops_dir_out - Set the direction of the specified GPIO pin as output
+ * @chip:	gpio_chip instance to be worked on
+ * @pin:	gpio pin number within the device
+ * @state:	value to be written to specified pin
+ *
+ * This function sets the direction of specified GPIO pin as output, configures
+ * the Output Enable register for the pin and uses xgpiops_set to set the state
+ * of the pin to the value specified. Returns 0 always.
+ */
+static int xgpiops_dir_out(struct gpio_chip *chip, unsigned int pin, int state)
+{
+	struct xgpiops *gpio = container_of(chip, struct xgpiops, chip);
+	unsigned int reg, bank_num, bank_pin_num;
+
+	xgpiops_get_bank_pin(pin, &bank_num, &bank_pin_num);
+
+	/* set the GPIO pin as output */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_DIRM_OFFSET(bank_num));
+	reg |= 1 << bank_pin_num;
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_DIRM_OFFSET(bank_num));
+
+	/* configure the output enable reg for the pin */
+	reg = xgpiops_readreg(gpio->base_addr +
+			       XGPIOPS_OUTEN_OFFSET(bank_num));
+	reg |= 1 << bank_pin_num;
+	xgpiops_writereg(reg,
+			  gpio->base_addr + XGPIOPS_OUTEN_OFFSET(bank_num));
+
+	/* set the state of the pin */
+	xgpiops_set_value(chip, pin, state);
+	return 0;
+}
+
+/**
+ * xgpiops_irq_ack - Acknowledge the interrupt of a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt to ack
+ *
+ * This function calculates gpio pin number from irq number and sets the bit
+ * in the Interrupt Status Register of the corresponding bank, to ACK the irq.
+ */
+static void xgpiops_irq_ack(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_sts;
+
+	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_sts = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTSTS_OFFSET(bank_num)) |
+				   (1 << bank_pin_num);
+	xgpiops_writereg(irq_sts,
+			  gpio->base_addr + (XGPIOPS_INTSTS_OFFSET(bank_num)));
+}
+
+/**
+ * xgpiops_irq_mask - Disable the interrupts for a gpio pin
+ * @irq:	irq number of gpio pin for which interrupt is to be disabled
+ *
+ * This function calculates gpio pin number from irq number and sets the
+ * bit in the Interrupt Disable register of the corresponding bank to disable
+ * interrupts for that pin.
+ */
+static void xgpiops_irq_mask(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_dis;
+
+	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_dis = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTDIS_OFFSET(bank_num)) |
+				   (1 << bank_pin_num);
+	xgpiops_writereg(irq_dis,
+			  gpio->base_addr + XGPIOPS_INTDIS_OFFSET(bank_num));
+}
+
+/**
+ * xgpiops_irq_unmask - Enable the interrupts for a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin for the interrupt to enable
+ *
+ * This function calculates the gpio pin number from irq number and sets the
+ * bit in the Interrupt Enable register of the corresponding bank to enable
+ * interrupts for that pin.
+ */
+static void xgpiops_irq_unmask(struct irq_data *irq_data)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int irq_en;
+
+	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+	irq_en = xgpiops_readreg(gpio->base_addr +
+				  XGPIOPS_INTEN_OFFSET(bank_num)) |
+				  (1 << bank_pin_num);
+	xgpiops_writereg(irq_en,
+			  gpio->base_addr + XGPIOPS_INTEN_OFFSET(bank_num));
+}
+
+/**
+ * xgpiops_set_irq_type - Set the irq type for a gpio pin
+ * @irq_data:	irq data containing irq number of gpio pin 
+ * @type:	interrupt type that is to be set for the gpio pin
+ *
+ * This function gets the gpio pin number and its bank from the gpio pin number
+ * and configures the INT_TYPE, INT_POLARITY and INT_ANY registers. Returns 0,
+ * negative error otherwise.
+ * TYPE-EDGE_RISING,  INT_TYPE - 1, INT_POLARITY - 1,  INT_ANY - 0;
+ * TYPE-EDGE_FALLING, INT_TYPE - 1, INT_POLARITY - 0,  INT_ANY - 0;
+ * TYPE-EDGE_BOTH,    INT_TYPE - 1, INT_POLARITY - NA, INT_ANY - 1;
+ * TYPE-LEVEL_HIGH,   INT_TYPE - 0, INT_POLARITY - 1,  INT_ANY - NA;
+ * TYPE-LEVEL_LOW,    INT_TYPE - 0, INT_POLARITY - 0,  INT_ANY - NA
+ */
+static int xgpiops_set_irq_type(struct irq_data *irq_data, unsigned int type)
+{
+	struct xgpiops *gpio = (struct xgpiops *)irq_data_get_irq_chip_data(irq_data);
+	unsigned int device_pin_num, bank_num, bank_pin_num;
+	unsigned int int_type, int_pol, int_any;
+
+	device_pin_num = irq_to_gpio(irq_data->irq); /* get pin num within the device */
+	xgpiops_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num);
+
+	int_type = xgpiops_readreg(gpio->base_addr +
+				    XGPIOPS_INTTYPE_OFFSET(bank_num));
+	int_pol = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTPOL_OFFSET(bank_num));
+	int_any = xgpiops_readreg(gpio->base_addr +
+				   XGPIOPS_INTANY_OFFSET(bank_num));
+
+	/*
+	 * based on the type requested, configure the INT_TYPE, INT_POLARITY
+	 * and INT_ANY registers
+	 */
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		int_type |= (1 << bank_pin_num);
+		int_pol |= (1 << bank_pin_num);
+		int_any &= ~(1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		int_type |= (1 << bank_pin_num);
+		int_pol &= ~(1 << bank_pin_num);
+		int_any &= ~(1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		int_type |= (1 << bank_pin_num);
+		int_any |= (1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		int_type &= ~(1 << bank_pin_num);
+		int_pol |= (1 << bank_pin_num);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		int_type &= ~(1 << bank_pin_num);
+		int_pol &= ~(1 << bank_pin_num);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	xgpiops_writereg(int_type,
+			  gpio->base_addr + XGPIOPS_INTTYPE_OFFSET(bank_num));
+	xgpiops_writereg(int_pol,
+			  gpio->base_addr + XGPIOPS_INTPOL_OFFSET(bank_num));
+	xgpiops_writereg(int_any,
+			  gpio->base_addr + XGPIOPS_INTANY_OFFSET(bank_num));
+	return 0;
+}
+
+/* irq chip descriptor */
+static struct irq_chip xgpiops_irqchip = {
+	.name		= DRIVER_NAME,
+	.irq_ack	= xgpiops_irq_ack,
+	.irq_mask	= xgpiops_irq_mask,
+	.irq_unmask	= xgpiops_irq_unmask,
+	.irq_set_type	= xgpiops_set_irq_type,
+};
+
+/**
+ * xgpiops_irqhandler - IRQ handler for the gpio banks of a gpio device
+ * @irq:	irq number of the gpio bank where interrupt has occurred
+ * @desc:	irq descriptor instance of the 'irq'
+ *
+ * This function reads the Interrupt Status Register of each bank to get the
+ * gpio pin number which has triggered an interrupt. It then acks the triggered
+ * interrupt and calls the pin specific handler set by the higher layer
+ * application for that pin.
+ * Note: A bug is reported if no handler is set for the gpio pin.
+ */
+void xgpiops_irqhandler(unsigned int irq, struct irq_desc *desc)
+{
+	int gpio_irq = (int)irq_get_handler_data(irq);
+	struct xgpiops *gpio = (struct xgpiops *)irq_get_chip_data(gpio_irq);
+	unsigned int int_sts, int_enb, bank_num;
+	struct irq_desc *gpio_irq_desc;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct irq_data *irq_data = irq_get_chip_data(irq);
+
+	chip->irq_ack(irq_data);
+	for (bank_num = 0; bank_num < 4; bank_num++) {
+		int_sts = xgpiops_readreg(gpio->base_addr +
+					   XGPIOPS_INTSTS_OFFSET(bank_num));
+		int_enb = xgpiops_readreg(gpio->base_addr +
+					   XGPIOPS_INTMASK_OFFSET(bank_num));
+		/*
+		 * handle only the interrupts which are enabled in interrupt
+		 * mask register
+		 */
+		int_sts &= ~int_enb;
+		for (; int_sts != 0; int_sts >>= 1, gpio_irq++) {
+			if ((int_sts & 1) == 0)
+				continue;
+			BUG_ON(!(irq_desc[gpio_irq].handle_irq));
+			gpio_irq_desc = irq_to_desc(gpio_irq);
+			chip->irq_ack(irq_data);
+
+			/* call the pin specific handler */
+			irq_desc[gpio_irq].handle_irq(gpio_irq,
+						      &irq_desc[gpio_irq]);
+		}
+		/* shift to first virtual irq of next bank */
+		gpio_irq = (int)irq_get_handler_data(irq) + 
+				(xgpiops_pin_table[bank_num] + 1);
+	}
+	chip->irq_unmask(irq_data);
+}
+
+/**
+ * xgpiops_probe - Initialization method for a xgpiops device
+ * @pdev:	platform device instance
+ *
+ * This function allocates memory resources for the gpio device and registers
+ * all the banks of the device. It will also set up interrupts for the gpio
+ * pins.
+ * Note: Interrupts are disabled for all the banks during initialization.
+ * Returns 0 on success, negative error otherwise.
+ */
+static int __init xgpiops_probe(struct platform_device *pdev)
+{
+	int ret;
+	unsigned int irq_num;
+	struct xgpiops *gpio;
+	struct gpio_chip *chip;
+	resource_size_t remap_size;
+	struct resource *mem_res = NULL;
+	int pin_num, bank_num, gpio_irq;
+
+	gpio = kzalloc(sizeof(struct xgpiops), GFP_KERNEL);
+	if (!gpio) {
+		dev_err(&pdev->dev, "couldn't allocate memory for gpio private "
+			"data\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, gpio);
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		ret = -ENODEV;
+		goto err_free_gpio;
+	}
+
+	remap_size = mem_res->end - mem_res->start + 1;
+	if (!request_mem_region(mem_res->start, remap_size, pdev->name)) {
+		dev_err(&pdev->dev, "Cannot request IO\n");
+		ret = -ENXIO;
+		goto err_free_gpio;
+	}
+
+	gpio->base_addr = ioremap(mem_res->start, remap_size);
+	if (gpio->base_addr == NULL) {
+		dev_err(&pdev->dev, "Couldn't ioremap memory at 0x%08lx\n",
+			(unsigned long)mem_res->start);
+		ret = -ENOMEM;
+		goto err_release_region;
+	}
+
+	irq_num = platform_get_irq(pdev, 0);
+
+	/* configure the gpio chip */
+	chip = &gpio->chip;
+	chip->label = "xgpiops";
+	chip->owner = THIS_MODULE;
+	chip->dev = &pdev->dev;
+	chip->get = xgpiops_get_value;
+	chip->set = xgpiops_set_value;
+	chip->direction_input = xgpiops_dir_in;
+	chip->direction_output = xgpiops_dir_out;
+	chip->dbg_show = NULL;
+	chip->base = 0;		/* default pin base */
+	chip->ngpio = 246;
+	chip->can_sleep = 0;
+
+	/* report a bug if gpio chip registration fails */
+	ret = gpiochip_add(chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "gpio chip registration failed\n");
+		goto err_iounmap;
+	} else
+		dev_info(&pdev->dev, "gpio at 0x%08lx mapped to 0x%08lx\n",
+			 (unsigned long)mem_res->start,
+			 (unsigned long)gpio->base_addr);
+
+	/* disable interrupts for all banks */
+	for (bank_num = 0; bank_num < 4; bank_num++) {
+		xgpiops_writereg(0xffffffff, gpio->base_addr +
+				  XGPIOPS_INTDIS_OFFSET(bank_num));
+	}
+
+	/*
+	 * set the irq chip, handler and irq chip data for callbacks for
+	 * each pin
+	 */
+	gpio_irq = XGPIOPS_IRQBASE;
+	for (pin_num = 0; pin_num < ARCH_NR_GPIOS; pin_num++, gpio_irq++) {
+		irq_set_chip(gpio_irq, &xgpiops_irqchip);
+		irq_set_chip_data(gpio_irq, (void *)gpio);
+		irq_set_handler(gpio_irq, handle_simple_irq);
+		irq_set_status_flags(gpio_irq, IRQF_VALID);
+	}
+
+	irq_set_handler_data(irq_num, (void *)(XGPIOPS_IRQBASE));
+	irq_set_chained_handler(irq_num, xgpiops_irqhandler);
+
+	return 0;
+
+err_iounmap:
+	iounmap(gpio->base_addr);
+err_release_region:
+	release_mem_region(mem_res->start, remap_size);
+err_free_gpio:
+	platform_set_drvdata(pdev, NULL);
+	kfree(gpio);
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id xgpiops_of_match[] __devinitdata = {
+	{ .compatible = "xlnx,ps7-gpio-1.00.a", },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, xgpiops_of_match);
+#endif
+
+static struct platform_driver xgpiops_driver = {
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = xgpiops_of_match,
+#endif
+	},
+	.probe		= xgpiops_probe,
+};
+
+/**
+ * xgpiops_init - Initial driver registration call
+ */
+static int __init xgpiops_init(void)
+{
+	return platform_driver_register(&xgpiops_driver);
+}
+
+subsys_initcall(xgpiops_init);
-- 
1.7.5.4

