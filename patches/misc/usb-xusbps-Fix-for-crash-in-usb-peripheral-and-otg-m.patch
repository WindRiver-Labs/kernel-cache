From a249eee5b7246854fdbd08d80c2e1e216ba14909 Mon Sep 17 00:00:00 2001
From: Punnaiah Choudary Kalluri <punnaiah.choudary.kalluri@xilinx.com>
Date: Tue, 20 Aug 2013 19:58:47 +0530
Subject: [PATCH 545/628] usb: xusbps: Fix for crash in usb peripheral and otg
 mode

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit ab1edc21dd6ec21193f3fda3b2874af918375ca8

The follwoing changes addresses the crash issue when the usb is configured for
peripheral and otg modes.the reason for the crash is due to registering the
gadget.dev twice.Also the xusbps_dr_of_probe funcion is called multiple times
due to pointing the of_node to the platform devicies that are created based
the dr_mode. So, this fix avoid this and pass the required information to the
platform device structure.

Signed-off-by: Punnaiah Choudary Kalluri <punnaia@xilinx.com>
Tested-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/usb/gadget/xilinx_usbps_udc.c |    9 ---------
 drivers/usb/host/ehci-xilinx-usbps.c  |    7 -------
 drivers/usb/host/xusbps-dr-of.c       |   26 +++++++++++++++++++++++++-
 drivers/usb/phy/phy-zynq-usb.c        |   14 +++++++-------
 4 files changed, 32 insertions(+), 24 deletions(-)

diff --git a/drivers/usb/gadget/xilinx_usbps_udc.c b/drivers/usb/gadget/xilinx_usbps_udc.c
index fa9a27b..0113c42 100644
--- a/drivers/usb/gadget/xilinx_usbps_udc.c
+++ b/drivers/usb/gadget/xilinx_usbps_udc.c
@@ -396,12 +396,6 @@ static int xusbps_udc_clk_init(struct platform_device *pdev)
 	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
 	int rc;
 
-	pdata->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(pdata->clk)) {
-		dev_err(&pdev->dev, "input clock not found.\n");
-		return PTR_ERR(pdata->clk);
-	}
-
 	rc = clk_prepare_enable(pdata->clk);
 	if (rc) {
 		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
@@ -2898,9 +2892,6 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 	dev_set_name(&udc_controller->gadget.dev, "gadget");
 	udc_controller->gadget.dev.release = xusbps_udc_release;
 	udc_controller->gadget.dev.parent = &pdev->dev;
-	ret = device_register(&udc_controller->gadget.dev);
-	if (ret < 0)
-		goto err_free_irq;
 
 	/* setup QH and epctrl for ep0 */
 	ep0_setup(udc_controller);
diff --git a/drivers/usb/host/ehci-xilinx-usbps.c b/drivers/usb/host/ehci-xilinx-usbps.c
index 4904374..40398dc 100644
--- a/drivers/usb/host/ehci-xilinx-usbps.c
+++ b/drivers/usb/host/ehci-xilinx-usbps.c
@@ -168,13 +168,6 @@ static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
 		goto err2;
 	}
 
-	pdata->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(pdata->clk)) {
-		dev_err(&pdev->dev, "input clock not found.\n");
-		retval = PTR_ERR(pdata->clk);
-		goto err2;
-	}
-
 	retval = clk_prepare_enable(pdata->clk);
 	if (retval) {
 		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
diff --git a/drivers/usb/host/xusbps-dr-of.c b/drivers/usb/host/xusbps-dr-of.c
index 0afd469..ff08696 100644
--- a/drivers/usb/host/xusbps-dr-of.c
+++ b/drivers/usb/host/xusbps-dr-of.c
@@ -117,7 +117,6 @@ static struct platform_device * xusbps_device_register(
 
 	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
 	pdev->dev.dma_mask = &dma_mask;
-	pdev->dev.of_node = ofdev->dev.of_node;
 
 	retval = platform_device_add_data(pdev, pdata, sizeof(*pdata));
 	if (retval)
@@ -215,6 +214,8 @@ static int xusbps_dr_of_probe(struct platform_device *ofdev)
 		goto err_out_clk_put;
 	}
 
+	pdata->clk = hdata->clk;
+
 	/* If ULPI phy type, set it up */
 	if (pdata->phy_mode == XUSBPS_USB2_PHY_ULPI) {
 		pdata->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops,
@@ -326,7 +327,30 @@ static struct platform_driver xusbps_dr_driver = {
 	.remove	= xusbps_dr_of_remove,
 };
 
+#ifdef CONFIG_USB_ZYNQ_PHY
+extern struct platform_driver xusbps_otg_driver;
+
+static int __init xusbps_dr_init(void)
+{
+	int retval;
+
+	/* Register otg driver first */
+	retval = platform_driver_register(&xusbps_otg_driver);
+	if (retval != 0)
+		return retval;
+
+	return platform_driver_register(&xusbps_dr_driver);
+}
+module_init(xusbps_dr_init);
+
+static void __exit xusbps_dr_exit(void)
+{
+	platform_driver_unregister(&xusbps_dr_driver);
+}
+module_exit(xusbps_dr_exit);
+#else
 module_platform_driver(xusbps_dr_driver);
+#endif
 
 MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
 MODULE_AUTHOR("Xilinx");
diff --git a/drivers/usb/phy/phy-zynq-usb.c b/drivers/usb/phy/phy-zynq-usb.c
index 7b21498..24812d5 100644
--- a/drivers/usb/phy/phy-zynq-usb.c
+++ b/drivers/usb/phy/phy-zynq-usb.c
@@ -1996,13 +1996,7 @@ static int xusbps_otg_probe(struct platform_device *pdev)
 	}
 	INIT_WORK(&xotg->work, xusbps_otg_work);
 
-	xotg->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(xotg->clk)) {
-		dev_err(&pdev->dev, "input clock not found.\n");
-		retval = PTR_ERR(xotg->clk);
-		goto err;
-	}
-
+	xotg->clk = pdata->clk;
 	retval = clk_prepare_enable(xotg->clk);
 	if (retval) {
 		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
@@ -2295,7 +2289,11 @@ static const struct dev_pm_ops xusbps_otg_dev_pm_ops = {
 #define XUSBPS_OTG_PM	NULL
 #endif /* ! CONFIG_PM_SLEEP */
 
+#ifndef CONFIG_USB_XUSBPS_DR_OF
 static struct platform_driver xusbps_otg_driver = {
+#else
+struct platform_driver xusbps_otg_driver = {
+#endif
 	.probe		= xusbps_otg_probe,
 	.remove		= xusbps_otg_remove,
 	.driver		= {
@@ -2305,7 +2303,9 @@ static struct platform_driver xusbps_otg_driver = {
 	},
 };
 
+#ifndef CONFIG_USB_XUSBPS_DR_OF
 module_platform_driver(xusbps_otg_driver);
+#endif
 
 MODULE_AUTHOR("Xilinx, Inc.");
 MODULE_DESCRIPTION("Xilinx PS USB OTG driver");
-- 
1.7.5.4

