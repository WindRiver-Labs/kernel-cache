From dab3ade2c64aaff45595f72248566807df35cd52 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Sat, 7 Dec 2013 17:14:59 +0800
Subject: [PATCH] sched: Work around sched_group::cpu_power = 0

the patch come from:
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=636797#46

to sched_group::cpu_power.  Try to work out why this is happening,
and fix it up to something sane it does.

Thanks to Bjoern Boschman <bjoern.boschman@nfon.net> for part of this.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 kernel/sched.c      |    2 +-
 kernel/sched_fair.c |   33 +++++++++++++++++++++++++++++----
 2 files changed, 30 insertions(+), 5 deletions(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 7a9168d..9616c09 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -6176,7 +6176,7 @@ static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,
 
 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));
 
-		printk(KERN_CONT " %s", str);
+		printk(KERN_CONT " group %p cpus %s", group, str);
 		if (group->cpu_power != SCHED_LOAD_SCALE) {
 			printk(KERN_CONT " (cpu_power = %d)",
 				group->cpu_power);
diff --git a/kernel/sched_fair.c b/kernel/sched_fair.c
index cbe71cf..5fc8f11 100644
--- a/kernel/sched_fair.c
+++ b/kernel/sched_fair.c
@@ -267,7 +267,6 @@ find_matching_se(struct sched_entity **se, struct sched_entity **pse)
 
 #endif	/* CONFIG_FAIR_GROUP_SCHED */
 
-
 /**************************************************************
  * Scheduling class tree data structure manipulation methods:
  */
@@ -1334,6 +1333,24 @@ static int wake_affine(struct sched_domain *sd, struct task_struct *p, int sync)
 	return 0;
 }
 
+/* Fix up and warn about group with cpu_power = 0 */
+static unsigned int sched_warn_zero_power(struct sched_group *group)
+{
+	static char str[256];
+
+	cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));
+	WARN_ONCE(1, "group %p cpus %s cpu_power = 0", group, str);
+
+	return 1;
+}
+
+static inline unsigned int sched_group_power(struct sched_group *group)
+{
+	unsigned int power = ACCESS_ONCE(group->cpu_power);
+
+	return likely(power > 0) ? power : sched_warn_zero_power(group);
+}
+
 /*
  * find_idlest_group finds and returns the least busy CPU group within the
  * domain.
@@ -1373,7 +1390,7 @@ find_idlest_group(struct sched_domain *sd, struct task_struct *p,
 		}
 
 		/* Adjust by relative CPU power of the group */
-		avg_load = (avg_load * SCHED_LOAD_SCALE) / group->cpu_power;
+		avg_load = (avg_load * SCHED_LOAD_SCALE) / sched_group_power(group);
 
 		if (local_group) {
 			this_load = avg_load;
@@ -2366,6 +2383,7 @@ static void update_cpu_power(struct sched_domain *sd, int cpu)
 	unsigned long weight = sd->span_weight;
 	unsigned long power = SCHED_LOAD_SCALE;
 	struct sched_group *sdg = sd->groups;
+	unsigned long scale_rt;
 
 	if (sched_feat(ARCH_POWER))
 		power *= arch_scale_freq_power(sd, cpu);
@@ -2383,12 +2401,16 @@ static void update_cpu_power(struct sched_domain *sd, int cpu)
 		power >>= SCHED_LOAD_SHIFT;
 	}
 
-	power *= scale_rt_power(cpu);
+	scale_rt = scale_rt_power(cpu);
+	power *= scale_rt;
 	power >>= SCHED_LOAD_SHIFT;
 
 	if (!power)
 		power = 1;
 
+	if (WARN_ON_ONCE((long)power <= 0))
+		printk(KERN_ERR "group %p cpu_power = %ld; scale_rt = %ld\n", sdg, power, scale_rt);
+
 	cpu_rq(cpu)->cpu_power = power;
 	sdg->cpu_power = power;
 }
@@ -2412,6 +2434,9 @@ static void update_group_power(struct sched_domain *sd, int cpu)
 		group = group->next;
 	} while (group != child->groups);
 
+	if (WARN_ON((long)power <= 0))
+		printk(KERN_ERR "cpu_power = %ld\n", power);
+
 	sdg->cpu_power = power;
 }
 
@@ -2489,7 +2514,7 @@ static inline void update_sg_lb_stats(struct sched_domain *sd,
 	update_group_power(sd, this_cpu);
 
 	/* Adjust by relative CPU power of the group */
-	sgs->avg_load = (sgs->group_load * SCHED_LOAD_SCALE) / group->cpu_power;
+	sgs->avg_load = (sgs->group_load * SCHED_LOAD_SCALE) / sched_group_power(group);
 
 	/*
 	 * Consider the group unbalanced when the imbalance is larger
-- 
1.7.0

