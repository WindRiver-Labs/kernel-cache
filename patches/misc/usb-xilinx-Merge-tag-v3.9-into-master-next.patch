From 9a9940530fdd300583708776aa87103ba8d520c9 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Wed, 8 May 2013 09:53:27 +0200
Subject: [PATCH 540/628] usb: xilinx: Merge tag 'v3.9' into master-next

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 79a6cbd5 Merge tag 'v3.9' into master-next

Merge Linux 3.9 to our branch.
- Remove EXPERIMENTAL option
- update defconfigs
- Several changes in USB subsystem which were fixed by
Naveen Mamindlapalli <naveenm@xilinx.com>
Subbaraya Sundeep Bhatta <sbhatta@xilinx.com>

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/usb/gadget/xilinx_udc.c       |   70 ++++++++++-----------------------
 drivers/usb/gadget/xilinx_usbps_udc.c |   53 ++++++-------------------
 2 files changed, 34 insertions(+), 89 deletions(-)

diff --git a/drivers/usb/gadget/xilinx_udc.c b/drivers/usb/gadget/xilinx_udc.c
index 27b9725..0931e86 100644
--- a/drivers/usb/gadget/xilinx_udc.c
+++ b/drivers/usb/gadget/xilinx_udc.c
@@ -1250,17 +1250,17 @@ static int xusb_ioctl(struct usb_gadget *gadget, unsigned code,
 	return 0;
 }
 
-static int xudc_start(struct usb_gadget_driver *driver,
-				int (*bind)(struct usb_gadget *,
-				struct usb_gadget_driver *driver));
-static int xudc_stop(struct usb_gadget_driver *driver);
+static int xudc_start(struct usb_gadget *gadget,
+			struct usb_gadget_driver *driver);
+static int xudc_stop(struct usb_gadget *gadget,
+			struct usb_gadget_driver *driver);
 static void xusb_release(struct device *dev);
 
 static const struct usb_gadget_ops xusb_udc_ops = {
 	.get_frame = xusb_get_frame,
 	.ioctl = xusb_ioctl,
-	.start = xudc_start,
-	.stop  = xudc_stop,
+	.udc_start = xudc_start,
+	.udc_stop  = xudc_stop,
 };
 
 
@@ -1493,6 +1493,7 @@ static void startup_intrhandler(void *callbackref, u32 intrstatus)
 			udc->gadget.speed = USB_SPEED_HIGH;
 		else
 			udc->gadget.speed = USB_SPEED_FULL;
+
 		if (udc->status == 1) {
 			udc->status = 0;
 			/* Set device address to 0.*/
@@ -2093,48 +2094,24 @@ static irqreturn_t xusb_udc_irq(int irq, void *_udc)
  * returns: 0 for success and error value on failure
  *
  **/
-int xudc_start(struct usb_gadget_driver *driver,
-				int (*bind)(struct usb_gadget *,
-				struct usb_gadget_driver *driver))
+static int xudc_start(struct usb_gadget *gadget,
+			struct usb_gadget_driver *driver)
 {
 	struct xusb_udc *udc = &controller;
-	int retval;
 	const struct usb_endpoint_descriptor *d = &config_bulk_out_desc;
 
-	/*
-	 * Check whether the driver related structure parameters
-	 * are created properly.
-	 */
-	if (!driver
-	    || driver->max_speed < USB_SPEED_FULL ||
-		!bind || !driver->unbind || !driver->setup) {
-		dev_dbg(&udc->gadget.dev, "bad parameter.\n");
-		return -EINVAL;
-	}
-
-	/* Is the device already declared as a gadget driver.*/
-	if (udc->driver) {
-		dev_dbg(&udc->gadget.dev,
-			"UDC already has a gadget driver\n");
-		return -EBUSY;
-	}
+	driver->driver.bus = NULL;
+	/* hook up the driver */
 	udc->driver = driver;
 	udc->gadget.dev.driver = &driver->driver;
 	udc->gadget.speed = driver->max_speed;
-	/* Add and bind the USB device to the device structure.*/
-	retval = device_add(&udc->gadget.dev);
-	retval = bind(&udc->gadget, driver);
-	if (retval) {
-		dev_dbg(&udc->gadget.dev,
-			"driver->bind() returned %d\n", retval);
-		udc->driver = NULL;
-		udc->gadget.dev.driver = NULL;
-		return retval;
-	}
-	xusb_ep_enable(&udc->ep[XUSB_EP_NUMBER_ZERO].ep, d);
+
 	/* Enable the USB device.*/
+	xusb_ep_enable(&udc->ep[XUSB_EP_NUMBER_ZERO].ep, d);
+	udc->write_fn(0, (udc->base_address + XUSB_ADDRESS_OFFSET));
 	udc->write_fn(XUSB_CONTROL_USB_READY_MASK,
 		(udc->base_address + XUSB_CONTROL_OFFSET));
+
 	return 0;
 }
 
@@ -2145,30 +2122,25 @@ int xudc_start(struct usb_gadget_driver *driver,
  * returns: 0 for success and error value on failure
  *
  */
-int xudc_stop(struct usb_gadget_driver *driver)
+static int xudc_stop(struct usb_gadget *gadget,
+		struct usb_gadget_driver *driver)
 {
 	struct xusb_udc *udc = &controller;
 	unsigned long flags;
 	u32 crtlreg;
 
-	if (!driver || driver != udc->driver || !driver->unbind)
-		return -EINVAL;
-
 	/* Disable USB device.*/
 	crtlreg = udc->read_fn(udc->base_address + XUSB_CONTROL_OFFSET);
 	crtlreg &= ~XUSB_CONTROL_USB_READY_MASK;
 	udc->write_fn(crtlreg, (udc->base_address + XUSB_CONTROL_OFFSET));
 	spin_lock_irqsave(&udc->lock, flags);
-	/* Stop any further activity in the device.*/
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
 	stop_activity(udc);
 	spin_unlock_irqrestore(&udc->lock, flags);
-	driver->unbind(&udc->gadget);
-	device_del(&udc->gadget.dev);
+
 	udc->gadget.dev.driver = NULL;
 	udc->driver = NULL;
 
-	dev_dbg(&udc->gadget.dev,
-		"unbound from %s\n", driver->driver.name);
 	return 0;
 }
 
@@ -2192,6 +2164,7 @@ static int xudc_init(struct device *dev, struct resource *regs_res,
 	int retval;
 
 	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = &pdev->dev;
 
 	remap_size = regs_res->end - regs_res->start + 1;
 	if (!request_mem_region(regs_res->start, remap_size,
@@ -2260,8 +2233,6 @@ static int xudc_init(struct device *dev, struct resource *regs_res,
 		  (udc->base_address + XUSB_IER_OFFSET));
 	platform_set_drvdata(pdev, udc);
 
-	udc->gadget.dev.parent = &pdev->dev;
-
 	dev_info(dev, "%s version %s\n", driver_name, DRIVER_VERSION);
 	dev_info(dev, "%s #%d at 0x%08X mapped to 0x%08X\n",
 	     driver_name, 0, (u32)regs_res->start, (u32 __force) v_addr);
@@ -2295,6 +2266,7 @@ static int xudc_remove(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
 
 	platform_set_drvdata(pdev, NULL);
+	device_unregister(&udc->gadget.dev);
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/xilinx_usbps_udc.c b/drivers/usb/gadget/xilinx_usbps_udc.c
index a06d551..083271c 100644
--- a/drivers/usb/gadget/xilinx_usbps_udc.c
+++ b/drivers/usb/gadget/xilinx_usbps_udc.c
@@ -1616,22 +1616,12 @@ static int xusbps_udc_stop_peripheral(struct usb_phy *otg)
  * Hook to gadget drivers
  * Called by initialization code of gadget drivers
 *----------------------------------------------------------------*/
-static int xusbps_start(struct usb_gadget_driver *driver,
-		int (*bind)(struct usb_gadget *, struct usb_gadget_driver *))
+static int xusbps_udc_start(struct usb_gadget *g,
+				struct usb_gadget_driver *driver)
 {
-	int retval = -ENODEV;
+	int retval = 0;
 	unsigned long flags = 0;
 
-	if (!udc_controller)
-		return -ENODEV;
-
-	if (!driver || (driver->max_speed < USB_SPEED_FULL)
-			|| !bind || !driver->disconnect || !driver->setup)
-		return -EINVAL;
-
-	if (udc_controller->driver)
-		return -EBUSY;
-
 	/* lock is needed but whether should use this lock or another */
 	spin_lock_irqsave(&udc_controller->lock, flags);
 
@@ -1639,17 +1629,8 @@ static int xusbps_start(struct usb_gadget_driver *driver,
 	/* hook up the driver */
 	udc_controller->driver = driver;
 	udc_controller->gadget.dev.driver = &driver->driver;
-	udc_controller->gadget.speed = driver->max_speed;
 	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
-	/* bind udc driver to gadget driver */
-	retval = bind(&udc_controller->gadget, driver);
-	if (retval) {
-		VDBG("bind to %s --> %d", driver->driver.name, retval);
-		udc_controller->gadget.dev.driver = NULL;
-		udc_controller->driver = NULL;
-		goto out;
-	}
 #ifdef CONFIG_USB_XUSBPS_OTG
 	if (gadget_is_otg(&udc_controller->gadget)) {
 		retval = otg_set_peripheral(udc_controller->transceiver->otg,
@@ -1659,7 +1640,7 @@ static int xusbps_start(struct usb_gadget_driver *driver,
 			driver->unbind(&udc_controller->gadget);
 			udc_controller->gadget.dev.driver = NULL;
 			udc_controller->driver = NULL;
-			goto out;
+			return retval;
 		}
 		/* Exporting start and stop routines */
 		udc_controller->xotg->start_peripheral =
@@ -1696,25 +1677,19 @@ static int xusbps_start(struct usb_gadget_driver *driver,
 
 	pr_info("%s: bind to driver %s\n",
 			udc_controller->gadget.name, driver->driver.name);
-
-out:
 	if (retval)
 		pr_warn("gadget driver register failed %d\n", retval);
+
 	return retval;
 }
 
 /* Disconnect from gadget driver */
-static int xusbps_stop(struct usb_gadget_driver *driver)
+static int xusbps_udc_stop(struct usb_gadget *g,
+		struct usb_gadget_driver *driver)
 {
 	struct xusbps_ep *loop_ep;
 	unsigned long flags;
 
-	if (!udc_controller)
-		return -ENODEV;
-
-	if (!driver || driver != udc_controller->driver || !driver->unbind)
-		return -EINVAL;
-
 	if (udc_controller->transceiver)
 		otg_set_peripheral(udc_controller->transceiver->otg, NULL);
 
@@ -1735,21 +1710,15 @@ static int xusbps_stop(struct usb_gadget_driver *driver)
 		nuke(loop_ep, -ESHUTDOWN);
 	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
-	/* report disconnect; the controller is already quiesced */
-	driver->disconnect(&udc_controller->gadget);
-
 #ifdef CONFIG_USB_XUSBPS_OTG
 	if (gadget_is_otg(&udc_controller->gadget)) {
 		udc_controller->xotg->start_peripheral = NULL;
 		udc_controller->xotg->stop_peripheral = NULL;
 	}
 #endif
-	/* unbind gadget and unhook driver. */
-	driver->unbind(&udc_controller->gadget);
 	udc_controller->gadget.dev.driver = NULL;
 	udc_controller->driver = NULL;
 
-	pr_warn("unregistered gadget driver '%s'\n", driver->driver.name);
 	return 0;
 }
 
@@ -1761,8 +1730,8 @@ static struct usb_gadget_ops xusbps_gadget_ops = {
 	.vbus_session = xusbps_vbus_session,
 	.vbus_draw = xusbps_vbus_draw,
 	.pullup = xusbps_pullup,
-	.start = xusbps_start,
-	.stop = xusbps_stop,
+	.udc_start = xusbps_udc_start,
+	.udc_stop = xusbps_udc_stop,
 };
 
 /* Set protocol stall on ep0, protocol stall will automatically be cleared
@@ -2958,6 +2927,10 @@ static int xusbps_udc_probe(struct platform_device *pdev)
 		goto err_unregister;
 	}
 
+	/* TODO: Check if VBUS can be dynamically detected by VBUS session
+	 * interrupts using OTGSC register */
+	udc_controller->vbus_active = 1;
+
 	ret = usb_add_gadget_udc(&pdev->dev, &udc_controller->gadget);
 	if (ret)
 		goto err_del_udc;
-- 
1.7.5.4

