From 245d2f56abc522a366f7cd2c74e456fc2a4c0c1c Mon Sep 17 00:00:00 2001
From: Michel Thebeau <michel.thebeau@windriver.com>
Date: Mon, 28 Jan 2013 13:36:58 -0500
Subject: [PATCH] call unlock_trace() when lock_trace() succeeds

The following warning raised the question of this code:
fs/proc/base.c:379:1: warning: label 'out' defined but not used [-Wunused-label]

The original patch lets unlock_trace() be called only when lock_trace()
succeeds.  The block #ifdef CONFIG_EXT_USER_STACKTRACE_SUPPORT enclosing
the else condition lets unlock_trace() be called when
CONFIG_EXT_USER_STACKTRACE_SUPPORT is disabled, so that unlock_trace()
is called no matter if lock_trace() succeeded.

We'll fix the warning, and the extraneous unlock in one go by putting
the entire CONFIG_EXT_USER_STACKTRACE_SUPPORT block within the success
condition of lock_trace().  Mostly this is whitespace change to
properly indent the block.

Signed-off-by: Paul Barrette <paul.barrette@windriver.com>
Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>
---
 fs/proc/base.c |   28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/fs/proc/base.c b/fs/proc/base.c
index 12b69b1..1b76893 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -328,28 +328,24 @@ static int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,
 			seq_printf(m, "[<%pK>] %pS\n",
 				   (void *)entries[i], (void *)entries[i]);
 		}
-	}
 #ifdef CONFIG_EXT_USER_STACKTRACE_SUPPORT
-	 else
-		goto out;
 
-	trace.nr_entries	= 0;
-	trace.max_entries	= MAX_STACK_TRACE_DEPTH;
-	trace.entries		= entries;
-	trace.skip		= 0;
+		trace.nr_entries	= 0;
+		trace.max_entries	= MAX_STACK_TRACE_DEPTH;
+		trace.entries		= entries;
+		trace.skip		= 0;
 
-	seq_printf(m, "userspace\n");
+		seq_printf(m, "userspace\n");
 
-	save_stack_trace_user_task(task, &trace);
+		save_stack_trace_user_task(task, &trace);
 
-	for (i = 0; i < trace.nr_entries; i++) {
-		if (entries[i] != ULONG_MAX)
-			seq_printf(m, "%p\n", (void *)entries[i]);
-	}
+		for (i = 0; i < trace.nr_entries; i++) {
+			if (entries[i] != ULONG_MAX)
+				seq_printf(m, "%p\n", (void *)entries[i]);
+		}
 #endif
-	unlock_trace(task);
-
-out:
+		unlock_trace(task);
+	}
 	kfree(entries);
 
 	return err;
-- 
1.7.9.7

