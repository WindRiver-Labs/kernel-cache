From cf05ca6c1c5f4dbbb5dd240e78ab7ba4fcde2d27 Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Wed, 14 Jun 2017 08:18:00 +0200
Subject: [PATCH 4/4] mm: do not collapse stack gap into THP

Patch from mailing list distros@vs.openwall.org

Oleg has noticed that khugepaged will happilly collapse stack vma (as
long as it is not an early stack - see is_vma_temporary_stack) and it
might effectively remove the stack gap area as well because a larger
part of the stack vma is usually populated.  The same applies to the
page fault handler.

Fix this by checking stack_guard_area when revalidating a VMA in
hugepage_vma_revalidate.  We do not want to hook/replace
is_vma_temporary_stack() check because THP might be still useful for
stack, all we need is excluding the gap from collapsing into a THP.

Also check the to-be-created THP in do_huge_pmd_anonymous_page to make
sure it is completely outside of the gap area because we we could create
THP covering the gap area.

Noticed-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Michal Hocko <mhocko@suse.com>
Tested-by: Tony Luck <tony.luck@intel.com> # ia64
Tested-by: Laura Abbott <labbott@redhat.com>
Tested-by: Helge Deller <deller@gmx.de> # parisc
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Ben Hutchings <ben@decadent.org.uk>
[wt: backport to 4.4 :
     changes to hugepage_vma_revalidate() go to collapse_huge_page() ]
[wt: backport to 3.10: no VM_FAULT_FALLBACK,
     use count_vm_event(THP_FAULT_FALLBACK) ]
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 mm/huge_memory.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index 3da5c0b..26985ea 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -709,6 +709,11 @@ int do_huge_pmd_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	pte_t *pte;
 
 	if (haddr >= vma->vm_start && haddr + HPAGE_PMD_SIZE <= vma->vm_end) {
+		if (stack_guard_area(vma, haddr) ||
+		    stack_guard_area(vma, haddr + HPAGE_PMD_SIZE)) {
+			count_vm_event(THP_FAULT_FALLBACK);
+			goto out;
+		}
 		if (unlikely(anon_vma_prepare(vma)))
 			return VM_FAULT_OOM;
 		if (unlikely(khugepaged_enter(vma)))
@@ -1909,6 +1914,10 @@ static void collapse_huge_page(struct mm_struct *mm,
 		goto out;
 	if (is_vma_temporary_stack(vma))
 		goto out;
+	/* never try to collapse stack gap */
+	if (stack_guard_area(vma, hstart) || stack_guard_area(vma, hend))
+		goto out;
+
 	/*
 	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be
 	 * true too, verify it here.
-- 
1.7.5.4

