From c983c53bdd5bc1b5aa7c581c7723183ee52b67ca Mon Sep 17 00:00:00 2001
From: Ming Liu <ming.liu@windriver.com>
Date: Sun, 22 Sep 2013 10:25:18 +0800
Subject: [PATCH 2/2] oom: avoid killing init if it assume the oom killed thread's mm

After selecting a task to kill, the oom killer iterates all processes and
kills all other user threads that share the same mm_struct in different
thread groups.

But in some extreme cases, the selected task happens to be a vfork child
of init process sharing the same mm_struct with it, which causes kernel
panic on init getting killed. This panic is observed in a busybox shell
that busybox itself is init, with a kthread keeps consuming memories.

Signed-off-by: Ming Liu <ming.liu@windriver.com>
---
 mm/oom_kill.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 93dd52b..0ccf1d2 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -369,13 +369,14 @@ static int oom_kill_task(struct task_struct *p)
 	__oom_kill_task(p, 1);
 
 	/*
-	 * kill all user processes that share the ->mm (i.e. all threads),
-	 * but are in a different thread group. Don't let them have access
-	 * to memory reserves though, otherwise we might deplete all memory.
+	 * kill all user processes except init that share the ->mm
+	 * (i.e. all threads), but are in a different thread group. Don't let
+	 * them have access to memory reserves though, otherwise we might
+	 * deplete all memory.
 	 */
 	do_each_thread(g, q) {
 		if (q->mm == mm && !same_thread_group(q, p) &&
-		    !(q->flags & PF_KTHREAD))
+		    !(q->flags & PF_KTHREAD) && !is_global_init(q))
 			force_sig(SIGKILL, q);
 	} while_each_thread(g, q);
 
-- 
1.7.0

