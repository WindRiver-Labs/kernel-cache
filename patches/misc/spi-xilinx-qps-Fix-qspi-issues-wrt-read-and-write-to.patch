From a8d9a6fb01427bad77e0b4775bc6b500a84a32a3 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <suneel.garapati@xilinx.com>
Date: Sat, 29 Jun 2013 09:16:07 +0530
Subject: [PATCH 249/628] spi: xilinx-qps: Fix qspi issues wrt read and write
 to flash

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 371bcf5ea5f8743e9ada54bff28f4b320ad780ee

Use correct offset while copying the data to TXD1/2/3 register.
In case of dual parallel, write/read must be of double byte
resolution, hence, use TXD0 register as hack on hw limitation,
and on RXD register always parse 4 bytes.

Signed-off-by: Suneel Garapati <suneel.garapati@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/spi/spi-xilinx-qps.c |   15 ++++++++++-----
 1 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/drivers/spi/spi-xilinx-qps.c b/drivers/spi/spi-xilinx-qps.c
index fa6d20f..f003329 100644
--- a/drivers/spi/spi-xilinx-qps.c
+++ b/drivers/spi/spi-xilinx-qps.c
@@ -540,7 +540,7 @@ static irqreturn_t xqspips_irq(int irq, void *dev_id)
 
 			data = xqspips_read(xqspi->regs + XQSPIPS_RXD_OFFSET);
 
-			if (xqspi->bytes_to_receive < 4)
+			if (xqspi->bytes_to_receive < 4 && !xqspi->is_dual)
 				xqspips_copy_read_data(xqspi, data,
 					xqspi->bytes_to_receive);
 			else
@@ -552,11 +552,16 @@ static irqreturn_t xqspips_irq(int irq, void *dev_id)
 				/* There is more data to send */
 				xqspips_fill_tx_fifo(xqspi);
 			} else {
+				int tmp;
+				tmp = xqspi->bytes_to_transfer;
 				xqspips_copy_write_data(xqspi, &data,
 					xqspi->bytes_to_transfer);
-				xqspips_write(xqspi->regs +
-					offset[xqspi->bytes_to_transfer],
-					data);
+				if (xqspi->is_dual)
+					xqspips_write(xqspi->regs +
+						XQSPIPS_TXD_00_00_OFFSET, data);
+				else
+					xqspips_write(xqspi->regs +
+						offset[tmp - 1], data);
 			}
 			xqspips_write(xqspi->regs + XQSPIPS_IEN_OFFSET,
 					XQSPIPS_IXR_ALL_MASK);
@@ -618,6 +623,7 @@ static int xqspips_start_transfer(struct spi_device *qspi,
 	if (xqspi->txbuf)
 		instruction = *(u8 *)xqspi->txbuf;
 
+	INIT_COMPLETION(xqspi->done);
 	if (instruction && xqspi->is_inst) {
 		for (index = 0 ; index < ARRAY_SIZE(flash_inst); index++)
 			if (instruction == flash_inst[index].opcode)
@@ -645,7 +651,6 @@ static int xqspips_start_transfer(struct spi_device *qspi,
 	}
 
 xfer_data:
-	INIT_COMPLETION(xqspi->done);
 	/* In case of Fast, Dual and Quad reads, transmit the instruction first.
 	 * Address and dummy byte will be transmitted in interrupt handler,
 	 * after instruction is transmitted */
-- 
1.7.5.4

