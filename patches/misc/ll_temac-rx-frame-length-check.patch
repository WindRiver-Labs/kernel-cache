From ca5e8a46044cf6edcff347bc0a27a618088448a2 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 26 Sep 2013 13:47:03 +0800
Subject: [PATCH] ll_temac: rx frame length check

As the length mask for received frame is 0x3FFF, so the packet
length could be 0-16k, but the allocated skb can only accommodate
9kB at most, so skb_over_panic could happen as follows:
  skb_over_panic: text:c0225fcc len:16383 put:16383 head:ce2ac000
  data:ce2ac000
  kernel BUG at net/core/skbuf!
  Oops: Exception in kernel mode, sig: 5 [#1] Xilinx Virtex last sysfs
  skb_over_panic+0x48/0x5c Call Trace:
  [cf83bab0] [c0247d4c] skb_over_panic+0x48/0x5c (unreliable)
  [cf83bac0] [c0249a6c] skb_put+0x5c/0x60
  [cf83bad0] [c0225fcc] ll_temac_rx_irq+0x10c/0x29c
  [cf83bb10] [c0071d60] handle_IRQ_event+0xb0/0x26c
  [cf83bb50] [c007472c] handle_level_irq+0x88/0x128
  [cf83bb60] [c0005164] do_IRQ+0x98/0xb4

Fix this problem by adding length check for received frames
before do skb_put().

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/ethernet/xilinx/ll_temac_main.c |   41 +++++++++++++++------------
 1 files changed, 23 insertions(+), 18 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/ll_temac_main.c b/drivers/net/ethernet/xilinx/ll_temac_main.c
index d21591a..f173ce5 100644
--- a/drivers/net/ethernet/xilinx/ll_temac_main.c
+++ b/drivers/net/ethernet/xilinx/ll_temac_main.c
@@ -767,25 +767,30 @@ static void ll_temac_recv(struct net_device *ndev)
 		dma_unmap_single(ndev->dev.parent, cur_p->phys, length,
 				 DMA_FROM_DEVICE);
 
-		skb_put(skb, length);
-		skb->dev = ndev;
-		skb->protocol = eth_type_trans(skb, ndev);
-		skb_checksum_none_assert(skb);
-
-		/* if we're doing rx csum offload, set it up */
-		if (((lp->temac_features & TEMAC_FEATURE_RX_CSUM) != 0) &&
-			(skb->protocol == __constant_htons(ETH_P_IP)) &&
-			(skb->len > 64)) {
-
-			skb->csum = cur_p->app3 & 0xFFFF;
-			skb->ip_summed = CHECKSUM_COMPLETE;
-		}
+		if (unlikely(length > XTE_MAX_JUMBO_FRAME_SIZE + XTE_ALIGN)) {
+			ndev->stats.rx_dropped++;
+			dev_kfree_skb(lp->rx_skb[lp->rx_bd_ci]);
+		} else {
+			skb_put(skb, length);
+			skb->dev = ndev;
+			skb->protocol = eth_type_trans(skb, ndev);
+			skb_checksum_none_assert(skb);
+
+			/* if we're doing rx csum offload, set it up */
+			if (((lp->temac_features & TEMAC_FEATURE_RX_CSUM) != 0) &&
+					(skb->protocol == __constant_htons(ETH_P_IP)) &&
+					(skb->len > 64)) {
 
-		if (!skb_defer_rx_timestamp(skb))
-			netif_rx(skb);
+				skb->csum = cur_p->app3 & 0xFFFF;
+				skb->ip_summed = CHECKSUM_COMPLETE;
+			}
 
-		ndev->stats.rx_packets++;
-		ndev->stats.rx_bytes += length;
+			if (!skb_defer_rx_timestamp(skb))
+				netif_rx(skb);
+
+			ndev->stats.rx_packets++;
+			ndev->stats.rx_bytes += length;
+		}
 
 		new_skb = netdev_alloc_skb_ip_align(ndev,
 						XTE_MAX_JUMBO_FRAME_SIZE);
-- 
1.7.5.4

