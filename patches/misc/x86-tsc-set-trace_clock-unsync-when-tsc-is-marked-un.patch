From 2389a76a87c07f86f55a113419c4c473c1f53412 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Mon, 24 Jun 2013 17:22:51 +0800
Subject: [PATCH] x86: tsc: set trace_clock unsync when tsc is marked unstable

Otherwise, lttng will get inconsistent trace_clock before/after
system suspend, the worst case is system live lock.
A typical scenario is like below:

Before suspend, CPU has constant_tsc set but tsc is marked
unstable in late boot stage, then when we launch lttng
async_tsc_refcount != 0
async_tsc_enabled = 0;

then when resume, we will get warning on
(!async_tsc_refcount || !async_tsc_enabled) in
trace_clock_async_tsc_read() because trace_clock_read32()
detect unstable tsc.

To cure it, we just mark trace_clock unsync when tsc is
marked unstable; thus make async_tsc work instead.

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/x86/kernel/tsc.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 90110ad..d1c2dbf 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -10,6 +10,7 @@
 #include <linux/clocksource.h>
 #include <linux/percpu.h>
 #include <linux/timex.h>
+#include <linux/trace-clock.h>
 
 #include <asm/hpet.h>
 #include <asm/timer.h>
@@ -806,6 +807,7 @@ void mark_tsc_unstable(char *reason)
 	if (!tsc_unstable) {
 		tsc_unstable = 1;
 		sched_clock_stable = 0;
+		set_trace_clock_is_sync(0);
 		printk(KERN_INFO "Marking TSC unstable due to %s\n", reason);
 		/* Change only the rating, when not registered */
 		if (clocksource_tsc.mult)
@@ -824,6 +826,7 @@ static int __init dmi_mark_tsc_unstable(const struct dmi_system_id *d)
 	printk(KERN_NOTICE "%s detected: marking TSC unstable.\n",
 			d->ident);
 	tsc_unstable = 1;
+	set_trace_clock_is_sync(0);
 	return 0;
 }
 
-- 
1.7.0

