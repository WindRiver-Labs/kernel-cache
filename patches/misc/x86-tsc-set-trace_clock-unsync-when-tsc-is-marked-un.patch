From c0be5927f68d63f1cc40a08e01860cc1fc401c63 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Mon, 24 Jun 2013 17:22:51 +0800
Subject: [PATCH] x86: tsc: set trace_clock unsync when tsc is marked unstable

Otherwise, lttng will get inconsistent trace_clock before/after
system suspend, the worst case is system live lock.
A typical scenario is like below:

Before suspend, CPU has constant_tsc set but tsc is marked
unstable in late boot stage, then when we launch lttng
async_tsc_refcount != 0
async_tsc_enabled = 0;

then when resume, we will get warning on
(!async_tsc_refcount || !async_tsc_enabled) in
trace_clock_async_tsc_read() because trace_clock_read32()
detect unstable tsc.

To cure it, we just mark trace_clock unsync when tsc is
marked unstable; thus make async_tsc work instead.

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/x86/kernel/tsc.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index fc0a147..ece35a1 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -9,6 +9,7 @@
 #include <linux/clocksource.h>
 #include <linux/percpu.h>
 #include <linux/timex.h>
+#include <linux/trace-clock.h>
 
 #include <asm/hpet.h>
 #include <asm/timer.h>
@@ -784,6 +785,7 @@ void mark_tsc_unstable(char *reason)
 	if (!tsc_unstable) {
 		tsc_unstable = 1;
 		sched_clock_stable = 0;
+		set_trace_clock_is_sync(0);
 		disable_sched_clock_irqtime();
 		printk(KERN_INFO "Marking TSC unstable due to %s\n", reason);
 		/* Change only the rating, when not registered */
-- 
1.7.5.4

