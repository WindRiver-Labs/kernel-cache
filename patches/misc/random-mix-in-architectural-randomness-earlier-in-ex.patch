From c5b69947b7c72d46544fb274be33efd36071aa1a Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Wed, 25 Nov 2015 18:41:42 +0800
Subject: [PATCH 2/3] random: mix in architectural randomness earlier in
 extract_buf()

commit 85a1f77716cf546d9b9c42e2848b5712f51ba1ee upstream

Previously if CPU chip had a built-in random number generator (i.e.,
RDRAND on newer x86 chips), we mixed it in at the very end of
extract_buf() using an XOR operation.

We now mix it in right after the calculate a hash across the entire
pool.  This has the advantage that any contribution of entropy from
the CPU's HWRNG will get mixed back into the pool.  In addition, it
means that if the HWRNG has any defects (either accidentally or
maliciously introduced), this will be mitigated via the non-linear
transform of the SHA-1 hash function before we hand out generated
output.

Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
Signed-off-by: yzhu1 <yzhu1@windriver.com>
---
 drivers/char/random.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/char/random.c b/drivers/char/random.c
index b196135..13b874c 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -992,7 +992,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	int i;
 	union {
 		__u32 w[5];
-		unsigned long l[LONGS(EXTRACT_SIZE)];
+		unsigned long l[LONGS(20)];
 	} hash;
 	__u32 workspace[SHA_WORKSPACE_WORDS];
 	__u8 extract[64];
@@ -1002,7 +1002,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	 * If we have a architectural hardware random number
 	 * generator, mix that in, too.
 	 */
-	for (i = 0; i < LONGS(EXTRACT_SIZE); i++) {
+	for (i = 0; i < LONGS(20); i++) {
 		unsigned long v;
 		if (!arch_get_random_long(&v))
 			break;
-- 
1.7.5.4

