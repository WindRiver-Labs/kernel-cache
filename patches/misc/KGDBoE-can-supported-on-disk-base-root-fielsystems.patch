From 8bf6e8b66ac564b8646da2077764a4f93ec4bf86 Mon Sep 17 00:00:00 2001
From: hongbo zhong <hongbo.zhong@windriver.com>
Date: Wed, 20 Oct 2010 14:26:17 +0800
Subject: [PATCH 6/6] KGDBoE can supported on disk base root fielsystems

kgdboe cann't support for the pch_gbe driver.
After add the pch_gbe_intr_poll function, the
kgdboe can run on disk base root filesystems.

Signed-off-by: Zhong hongbo <Hongbo.Zhong@windriver.com>
---
 drivers/net/pch_gbe/pch_gbe_main.c |   63 +++++++++++++++++++++++++++++++++++-
 1 files changed, 62 insertions(+), 1 deletions(-)

diff --git a/drivers/net/pch_gbe/pch_gbe_main.c b/drivers/net/pch_gbe/pch_gbe_main.c
index ba49c59..4369db1 100644
--- a/drivers/net/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/pch_gbe/pch_gbe_main.c
@@ -109,6 +109,9 @@ static void pch_gbe_set_mode(struct pch_gbe_adapter *adapter,
      u16 speed, u16 duplex);
 static void pch_gbe_watchdog(unsigned long data);
 static irqreturn_t pch_gbe_intr(int irq, void *data);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static irqreturn_t pch_gbe_intr_netpoll(int irq, void *data);
+#endif
 static unsigned char pch_gbe_clean_tx(struct pch_gbe_adapter *adapter,
     struct pch_gbe_tx_ring *tx_ring);
 static int pch_gbe_napi_poll(struct napi_struct *napi, int budget);
@@ -1138,7 +1141,7 @@ static void pch_gbe_netpoll(struct net_device *netdev)
  DPRINTK(PROBE, DEBUG, "\n");
 
  disable_irq(adapter->pdev->irq);
- pch_gbe_intr(adapter->pdev->irq, netdev);
+ pch_gbe_intr_netpoll(adapter->pdev->irq, netdev);
  enable_irq(adapter->pdev->irq);
 }
 #endif
@@ -2489,6 +2492,64 @@ void pch_gbe_update_stats(struct pch_gbe_adapter *adapter)
  spin_unlock_irqrestore(&adapter->stats_lock, flags);
 }
 
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static irqreturn_t pch_gbe_intr_netpoll(int irq, void *data)
+{
+ struct net_device *netdev = data;
+ struct pch_gbe_adapter *adapter = netdev_priv(netdev);
+ struct pch_gbe_hw *hw = &adapter->hw;
+ u32 int_st;
+ u32 int_en;
+
+ /* Check request status */
+ int_st = PCH_GBE_READ_REG(hw, INT_ST);
+ int_st = int_st & PCH_GBE_READ_REG(hw, INT_EN);
+ /* When request status is no interruption factor */
+ if (int_st & PCH_GBE_INT_RX_FRAME_ERR)
+  adapter->stats.intr_rx_frame_err_count++;
+ if (int_st & PCH_GBE_INT_RX_FIFO_ERR)
+  adapter->stats.intr_rx_fifo_err_count++;
+ if (int_st & PCH_GBE_INT_RX_DMA_ERR)
+  adapter->stats.intr_rx_dma_err_count++;
+ if (int_st & PCH_GBE_INT_TX_FIFO_ERR)
+  adapter->stats.intr_tx_fifo_err_count++;
+ if (int_st & PCH_GBE_INT_TX_DMA_ERR)
+  adapter->stats.intr_tx_dma_err_count++;
+ if (int_st & PCH_GBE_INT_TCPIP_ERR)
+  adapter->stats.intr_tcpip_err_count++;
+ /* When Rx descriptor is empty  */
+ if ((int_st & PCH_GBE_INT_RX_DSC_EMP)) {
+  adapter->stats.intr_rx_dsc_empty_count++;
+  int_en = PCH_GBE_READ_REG(hw, INT_EN);
+  PCH_GBE_WRITE_REG(hw, INT_EN,
+      (int_en & ~PCH_GBE_INT_RX_DSC_EMP));
+  if (hw->mac.tx_fc_enable == TRUE) {
+   /* Set Pause packet */
+   pch_gbe_hal_set_pause_packet(hw);
+  }
+  if ((int_en & (PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT))
+      == 0) {
+   return IRQ_HANDLED;
+  }
+ }
+
+ /* When request status is Receive interruption */
+  if (likely(napi_schedule_prep(&adapter->napi))) {
+   /* Enable only Rx Descriptor empty */
+   atomic_inc(&adapter->irq_sem);
+   int_en = PCH_GBE_READ_REG(hw, INT_EN);
+   int_en &=
+       ~(PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT);
+   PCH_GBE_WRITE_REG(hw, INT_EN, int_en);
+   /* Start polling for NAPI */
+   __napi_schedule(&adapter->napi);
+  }
+ PCH_DEBUG("return = 0x%08x  INT_EN reg = 0x%08x\n",
+   IRQ_HANDLED, PCH_GBE_READ_REG(hw, INT_EN));
+ return IRQ_HANDLED;
+}
+#endif
+
 /*!
  * @ingroup Linux driver internal function
  * @fn      static irqreturn_t pch_gbe_intr(int irq, void *data)
-- 
1.7.0

