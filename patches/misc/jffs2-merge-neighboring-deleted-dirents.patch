From 839bcfee016b8bd19a6ad2926fb90b13b6728b35 Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Mon, 2 Apr 2018 13:10:48 +0800
Subject: [PATCH] jffs2: merge neighboring deleted dirents

When a dirent been created and then removed, it wont be removed
from the list. In case of continues create random named file and
then removed it, the list will be continues enlarge that wastes
too much memory. Merge neighboring deleted dirents to avoid it.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 fs/jffs2/dir.c      |   12 +++++++++---
 fs/jffs2/nodelist.c |    3 ++-
 fs/jffs2/write.c    |   26 ++++++++++++++++++++++++--
 3 files changed, 35 insertions(+), 6 deletions(-)

diff --git a/fs/jffs2/dir.c b/fs/jffs2/dir.c
index acd46a4..89150da 100644
--- a/fs/jffs2/dir.c
+++ b/fs/jffs2/dir.c
@@ -149,14 +149,20 @@ static int jffs2_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		curofs++;
 		/* First loop: curofs = 2; offset = 2 */
 		if (curofs < offset) {
-			jffs2_dbg(2, "Skipping dirent: \"%s\", ino #%u, type %d, because curofs %ld < offset %ld\n",
-				  fd->name, fd->ino, fd->type, curofs, offset);
+			if (!fd->ino) {
+				jffs2_dbg(2, "Skipping deleted dirent \"%s\"\n", fd->name);
+				curofs += fd->version - 1;
+			} else
+				jffs2_dbg(2, "Skipping dirent: \"%s\", ino #%u, type %d, because curofs %ld < offset %ld\n",
+					  fd->name, fd->ino, fd->type, curofs, offset);
+
 			continue;
 		}
 		if (!fd->ino) {
 			jffs2_dbg(2, "Skipping deletion dirent \"%s\"\n",
 				  fd->name);
-			offset++;
+			offset += fd->version;
+			curofs += fd->version - 1;
 			continue;
 		}
 		jffs2_dbg(2, "Dirent %ld: \"%s\", ino #%u, type %d\n",
diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 975a1f5..2285da7 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -30,7 +30,8 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 	dbg_dentlist("add dirent \"%s\", ino #%u\n", new->name, new->ino);
 
 	while ((*prev) && (*prev)->nhash <= new->nhash) {
-		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
+		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name) &&
+		    (((*prev)->ino == 0 && (*prev)->version == 1) || (*prev)->ino)) {
 			/* Duplicate. Free one */
 			if (new->version < (*prev)->version) {
 				dbg_dentlist("Eep! Marking new dirent node obsolete, old is \"%s\", ino #%u\n",
diff --git a/fs/jffs2/write.c b/fs/jffs2/write.c
index b634de4..8eb158c 100644
--- a/fs/jffs2/write.c
+++ b/fs/jffs2/write.c
@@ -597,30 +597,52 @@ int jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,
 		jffs2_add_fd_to_list(c, fd, &dir_f->dents);
 		mutex_unlock(&dir_f->sem);
 	} else {
+		struct jffs2_full_dirent *prev = NULL;
 		uint32_t nhash = full_name_hash(name, namelen);
 
-		fd = dir_f->dents;
 		/* We don't actually want to reserve any space, but we do
 		   want to be holding the alloc_sem when we write to flash */
 		mutex_lock(&c->alloc_sem);
 		mutex_lock(&dir_f->sem);
 
 		for (fd = dir_f->dents; fd; fd = fd->next) {
-			if (fd->nhash == nhash &&
+
+			if (fd->ino != 0 && fd->nhash == nhash &&
 			    !memcmp(fd->name, name, namelen) &&
 			    !fd->name[namelen]) {
 
+				struct jffs2_full_dirent *del;
+
 				jffs2_dbg(1, "Marking old dirent node (ino #%u) @%08x obsolete\n",
 					  fd->ino, ref_offset(fd->raw));
 				jffs2_mark_node_obsolete(c, fd->raw);
+
 				/* We don't want to remove it from the list immediately,
 				   because that screws up getdents()/seek() semantics even
 				   more than they're screwed already. Turn it into a
 				   node-less deletion dirent instead -- a placeholder */
 				fd->raw = NULL;
 				fd->ino = 0;
+				/* Reuse version here as how many dirents merged together */
+				fd->version = 1;
+
+				/* If "next" is deleted, merge it into fd */
+				if ((fd->next) && (fd->next->ino == 0)) {
+					del = fd->next;
+					fd->next = del->next;
+					fd->version += del->version;
+					jffs2_free_full_dirent(del);
+				}
+				/* If "prev" is deleted, merge fd into it */
+				if((prev) && (prev->ino == 0)) {
+					del = fd;
+					prev->next = del->next;
+					prev->version += del->version;
+					jffs2_free_full_dirent(del);
+				}
 				break;
 			}
+			prev = fd;
 		}
 		mutex_unlock(&dir_f->sem);
 	}
-- 
1.7.5.4

