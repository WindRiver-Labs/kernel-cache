From 9e60751cbecbdf1c6179e60c4f4afbd74ce29eca Mon Sep 17 00:00:00 2001
From: Xin Song <xin.song@windriver.com>
Date: Wed, 20 Jul 2016 09:42:32 +0800
Subject: [PATCH 1/2] cgroup: make sure a parent css isn't offlined before its
 children

commit aa226ff4a1ce79f229c6b7a4c0a14e17fececd01 upstream.

There are three subsystem callbacks in css shutdown path -
css_offline(), css_released() and css_free().  Except for
css_released(), cgroup core didn't guarantee the order of invocation.
css_offline() or css_free() could be called on a parent css before its
children.  This behavior is unexpected and led to bugs in cpu and
memory controller.

This patch updates offline path so that a parent css is never offlined
before its children.  Each css keeps online_cnt which reaches zero iff
itself and all its children are offline and offline_css() is invoked
only after online_cnt reaches zero.

This fixes the memory controller bug and allows the fix for cpu
controller.

Signed-off-by: Tejun Heo <tj@kernel.org>
Reported-and-tested-by: Christian Borntraeger <borntraeger@de.ibm.com>
Reported-by: Brian Christiansen <brian.o.christiansen@gmail.com>
Integrated-by: Xin Song <xin.song@windriver.com>
Signed-off-by: Li Zhou <li.zhou@windriver.com>
---
 include/linux/cgroup.h |    6 ++++++
 kernel/cgroup.c        |   47 ++++++++++++++++++++++++-----------------------
 2 files changed, 30 insertions(+), 23 deletions(-)

diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index b53d804..a9349fb 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -79,6 +79,12 @@ struct cgroup_subsys_state {
 
 	unsigned long flags;
 
+	/*
+	 * Incremented by online self and children.  Used to guarantee that
+	 * parents are not offlined before their children.
+	 */
+	atomic_t online_cnt;	
+
 	/* percpu_ref killing and RCU release */
 	struct rcu_head rcu_head;
 	struct work_struct destroy_work;
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 550e205..6b3fb95 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -4042,6 +4042,7 @@ static void init_css(struct cgroup_subsys_state *css, struct cgroup_subsys *ss,
 	css->cgroup = cgrp;
 	css->ss = ss;
 	css->flags = 0;
+	atomic_set(&css->online_cnt, 0);
 
 	if (cgrp->parent)
 		css->parent = cgroup_css(cgrp->parent, ss);
@@ -4065,6 +4066,10 @@ static int online_css(struct cgroup_subsys_state *css)
 		css->flags |= CSS_ONLINE;
 		css->cgroup->nr_css++;
 		rcu_assign_pointer(css->cgroup->subsys[ss->subsys_id], css);
+
+		atomic_inc(&css->online_cnt);
+		if (css->parent)
+			atomic_inc(&css->parent->online_cnt);
 	}
 	return ret;
 }
@@ -4302,30 +4307,24 @@ static void css_killed_work_fn(struct work_struct *work)
 
 	mutex_lock(&cgroup_mutex);
 
-	/*
-	 * css_tryget() is guaranteed to fail now.  Tell subsystems to
-	 * initate destruction.
-	 */
-	offline_css(css);
+	do {
+		offline_css(css);
 
-	/*
-	 * If @cgrp is marked dead, it's waiting for refs of all css's to
-	 * be disabled before proceeding to the second phase of cgroup
-	 * destruction.  If we are the last one, kick it off.
-	 */
-	if (!cgrp->nr_css && cgroup_is_dead(cgrp))
-		cgroup_destroy_css_killed(cgrp);
+		/*
+	 	 * If @cgrp is marked dead, it's waiting for refs of all css's to
+	 	 * be disabled before proceeding to the second phase of cgroup
+	 	 * destruction.  If we are the last one, kick it off.
+	 	 */
+		cgrp = css->cgroup;
+		if (!cgrp->nr_css && cgroup_is_dead(cgrp))
+			cgroup_destroy_css_killed(cgrp);
 
-	mutex_unlock(&cgroup_mutex);
+		css_put(css);
+		/* @css can't go away while we're holding cgroup_mutex */
+		css = css->parent;
+	} while (css && atomic_dec_and_test(&css->online_cnt));
 
-	/*
-	 * Put the css refs from kill_css().  Each css holds an extra
-	 * reference to the cgroup's dentry and cgroup removal proceeds
-	 * regardless of css refs.  On the last put of each css, whenever
-	 * that may be, the extra dentry ref is put so that dentry
-	 * destruction happens only after all css's are released.
-	 */
-	css_put(css);
+	mutex_unlock(&cgroup_mutex);
 }
 
 /* css kill confirmation processing requires process context, bounce */
@@ -4334,8 +4333,10 @@ static void css_killed_ref_fn(struct percpu_ref *ref)
 	struct cgroup_subsys_state *css =
 		container_of(ref, struct cgroup_subsys_state, refcnt);
 
-	INIT_WORK(&css->destroy_work, css_killed_work_fn);
-	queue_work(cgroup_destroy_wq, &css->destroy_work);
+	if (atomic_dec_and_test(&css->online_cnt)) {
+		INIT_WORK(&css->destroy_work, css_killed_work_fn);
+		queue_work(cgroup_destroy_wq, &css->destroy_work);
+	}
 }
 
 /**
-- 
1.7.5.4

