From 6dbcf7b54f7860dd381ac45ef3c6d5a0405d9718 Mon Sep 17 00:00:00 2001
From: Xin Song <xin.song@windriver.com>
Date: Wed, 20 Jul 2016 10:04:32 +0800
Subject: [PATCH 2/2] cgroup: make sure a parent css isn't freed before its
 children

commit 8bb5ef79bc0f4016ecf79e8dce6096a3c63603e4 upstream.

There are three subsystem callbacks in css shutdown path -
css_offline(), css_released() and css_free().  Except for
css_released(), cgroup core didn't guarantee the order of invocation.
css_offline() or css_free() could be called on a parent css before its
children.  This behavior is unexpected and led to bugs in cpu and
memory controller.

The previous patch updated ordering for css_offline() which fixes the
cpu controller issue.  While there currently isn't a known bug caused
by misordering of css_free() invocations, let's fix it too for
consistency.

css_free() ordering can be trivially fixed by moving putting of the
parent css below css_free() invocation.

Signed-off-by: Tejun Heo <tj@kernel.org>
Integrated-by: Xin Song <xin.song@windriver.com>
Signed-off-by: Li Zhou <li.zhou@windriver.com>
---
 kernel/cgroup.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 6b3fb95..c7c13e6 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -4006,12 +4006,13 @@ static void css_free_work_fn(struct work_struct *work)
 	struct cgroup_subsys_state *css =
 		container_of(work, struct cgroup_subsys_state, destroy_work);
 	struct cgroup *cgrp = css->cgroup;
-
-	if (css->parent)
-		css_put(css->parent);
+	struct cgroup_subsys_state *parent = css->parent;
 
 	css->ss->css_free(css);
 	cgroup_dput(cgrp);
+
+	if (parent)
+		css_put(parent);
 }
 
 static void css_free_rcu_fn(struct rcu_head *rcu_head)
-- 
1.7.5.4

