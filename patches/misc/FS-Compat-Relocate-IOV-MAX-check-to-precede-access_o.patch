From 217f1a19a47fa36cbf7f9689c7d52589b805c9b8 Mon Sep 17 00:00:00 2001
From: Michel Thebeau <michel.thebeau@windriver.com>
Date: Mon, 4 Oct 2010 07:29:37 -0700
Subject: [PATCH 2/2] FS Compat: Relocate IOV MAX check to precede access_ok

Ensures that compat readv and writev system calls return EINVAL
when vector length (vlen) is greater than IOV MAX (UIO_MAXIOV).
This is consistent with the non-compat readv and writev system
calls.  System calls affected include compat_readv and
compat_writev.

Previously, these two system calls would return EFAULT when the vlen
passed to kernel was larger than the largest signed integer. (I.e.,
cram a negative int into an unsigned long); because access_ok would
fail to access such a large vector.  It was premature to check
access_ok before checking the vector length.

The check for UIO_MAXIOV is bubbled up out of
compat_rw_copy_check_uvector function into compat_do_readv_writev
so that it will precede the call to access_ok.
aio_setup_vectored_rw in fs/aio.c also calls
compat_rw_copy_check_uvector so move the IOV MAX check into there as
well.

In both cases listed above it is either redundant or unnecessary to
check for vector lengths less than zero, so that part is dropped
during the copy.

Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>
---
 fs/aio.c    |    8 ++++++--
 fs/compat.c |    6 +++---
 2 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/fs/aio.c b/fs/aio.c
index 48fdeeb..987e558 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1390,12 +1390,16 @@ static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
 	ssize_t ret;
 
 #ifdef CONFIG_COMPAT
-	if (compat)
+	if (compat) {
+		ret = -EINVAL;
+		if (kiocb->ki_nbytes > UIO_MAXIOV)
+			goto out;
+
 		ret = compat_rw_copy_check_uvector(type,
 				(struct compat_iovec __user *)kiocb->ki_buf,
 				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
 				&kiocb->ki_iovec);
-	else
+	} else
 #endif
 		ret = rw_copy_check_uvector(type,
 				(struct iovec __user *)kiocb->ki_buf,
diff --git a/fs/compat.c b/fs/compat.c
index 5055804..ab2a213 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -590,9 +590,6 @@ ssize_t compat_rw_copy_check_uvector(int type,
 	if (nr_segs == 0)
 		goto out;
 
-	ret = -EINVAL;
-	if (nr_segs > UIO_MAXIOV || nr_segs < 0)
-		goto out;
 	if (nr_segs > fast_segs) {
 		ret = -ENOMEM;
 		iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);
@@ -1160,6 +1157,9 @@ static ssize_t compat_do_readv_writev(int type, struct file *file,
 	if (!file->f_op)
 		goto out;
 
+	if (nr_segs > UIO_MAXIOV)
+		goto out;
+
 	ret = -EFAULT;
 	if (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))
 		goto out;
-- 
1.6.5.2

