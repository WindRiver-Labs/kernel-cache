From f3c47e70b5f372d28d93f87a2d95a9508fe739bc Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Fri, 16 Jun 2017 12:58:33 +0200
Subject: [PATCH 3/4] mm: allow to configure stack gap size

Patch from mailing list distros@vs.openwall.org

Add a kernel command line option (stack_guard_gap) to specify the stack
gap size (in page unites) and export the value in /proc/<pid>/smaps for
stack vmas.  This might be used for special applications like CRIU/RR.

Changes since v1
 - do not rely on is_stack when reporting the gap. show_map_vma has all
   the information we need

Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Michal Hocko <mhocko@suse.com>
Tested-by: Tony Luck <tony.luck@intel.com> # ia64
Tested-by: Laura Abbott <labbott@redhat.com>
Tested-by: Helge Deller <deller@gmx.de> # parisc
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
[wt: backport to 4.9 : kernel-parameters.txt is in Documentation/]
[wt: backport to 3.10 : adjust context]
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 Documentation/kernel-parameters.txt |    7 +++++++
 fs/proc/task_mmu.c                  |   20 +++++++++++++++-----
 mm/mmap.c                           |   13 +++++++++++++
 3 files changed, 35 insertions(+), 5 deletions(-)

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index a4db1f0..309601c 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2562,6 +2562,13 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 	spia_pedr=
 	spia_peddr=
 
+	stack_guard_gap=
+			[MM] override the default stack gap protection.The
+			value is in page units and it defines how many pages
+			prior to (for stacks growing down) resp. after (for
+			stacks growing up) the main stack are reserved for no
+			other mapping. Default value is 256 pages.
+
 	stacktrace	[FTRACE]
 			Enabled the stack tracer on boot up.
 
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 1188b9e..959c864 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -210,7 +210,7 @@ static int do_maps_open(struct inode *inode, struct file *file,
 }
 
 static void
-show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
+show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid, bool *has_gap)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct file *file = vma->vm_file;
@@ -235,11 +235,17 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 	start = vma->vm_start;
 	end = vma->vm_end;
 	if (vma->vm_flags & VM_GROWSDOWN) {
-		if (stack_guard_area(vma, start))
+		if (stack_guard_area(vma, start)) {
 			start = min(end, start + stack_guard_gap);
+			if (has_gap)
+				*has_gap = true;
+		}
 	} else if (vma->vm_flags & VM_GROWSUP) {
-		if (stack_guard_area(vma, end))
+		if (stack_guard_area(vma, end)) {
 			end = max(start, end - stack_guard_gap);
+			if (has_gap)
+				*has_gap = true;
+		}
 	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
@@ -309,7 +315,7 @@ static int show_map(struct seq_file *m, void *v, int is_pid)
 	struct proc_maps_private *priv = m->private;
 	struct task_struct *task = priv->task;
 
-	show_map_vma(m, vma, is_pid);
+	show_map_vma(m, vma, is_pid, NULL);
 
 	if (m->count < m->size)  /* vma is copied successfully */
 		m->version = (vma != get_gate_vma(task->mm))
@@ -484,6 +490,7 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 		.mm = vma->vm_mm,
 		.private = &mss,
 	};
+	bool has_gap = false;
 
 	memset(&mss, 0, sizeof mss);
 	mss.vma = vma;
@@ -491,7 +498,7 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 	if (vma->vm_mm && !is_vm_hugetlb_page(vma))
 		walk_page_range(vma->vm_start, vma->vm_end, &smaps_walk);
 
-	show_map_vma(m, vma, is_pid);
+	show_map_vma(m, vma, is_pid, &has_gap);
 
 	seq_printf(m,
 		   "Size:           %8lu kB\n"
@@ -524,6 +531,9 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)
 		   (vma->vm_flags & VM_LOCKED) ?
 			(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);
 
+	if (has_gap)
+		seq_printf(m, "Stack_Gap:      %8lu kB\n", stack_guard_gap >>10);
+
 	if (m->count < m->size)  /* vma is copied successfully */
 		m->version = (vma != get_gate_vma(task->mm))
 			? vma->vm_start : 0;
diff --git a/mm/mmap.c b/mm/mmap.c
index 56cf13f..ce64e05 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1904,6 +1904,19 @@ int expand_downwards(struct vm_area_struct *vma,
 /* enforced gap between the expanding stack and other mappings. */
 unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;
 
+static int __init cmdline_parse_stack_guard_gap(char *p)
+{
+	unsigned long val;
+	char *endptr;
+
+	val = simple_strtoul(p, &endptr, 10);
+	if (!*endptr)
+		stack_guard_gap = val << PAGE_SHIFT;
+
+	return 0;
+}
+__setup("stack_guard_gap=", cmdline_parse_stack_guard_gap);
+
 /*
  * Note how expand_stack() refuses to expand the stack all the way to
  * abut the next virtual mapping, *unless* that mapping itself is also
-- 
1.7.5.4

