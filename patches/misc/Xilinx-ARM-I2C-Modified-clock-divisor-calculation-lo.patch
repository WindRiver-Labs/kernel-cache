From e6a60e394013134d1cef8739e8a59c7854a467ac Mon Sep 17 00:00:00 2001
From: Suneel <suneelg@xilinx.com>
Date: Thu, 30 Aug 2012 20:34:16 +0530
Subject: [PATCH 298/628] Xilinx: ARM: I2C: Modified clock divisor calculation
 logic

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit b20737403d81fd65afe57455190547e6e267ac02

Modified the calculation of clock divisor logic to achieve
minimum deviation from the required i2c clock frequency.

Signed-off-by: Suneel <suneelg@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/i2c/busses/i2c-xilinx_ps.c |   67 +++++++++++++++++++++++++-----------
 1 files changed, 47 insertions(+), 20 deletions(-)

diff --git a/drivers/i2c/busses/i2c-xilinx_ps.c b/drivers/i2c/busses/i2c-xilinx_ps.c
index 2a98a1f..5df538d 100644
--- a/drivers/i2c/busses/i2c-xilinx_ps.c
+++ b/drivers/i2c/busses/i2c-xilinx_ps.c
@@ -571,10 +571,10 @@ static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
 		unsigned int *a, unsigned int *b, unsigned int *err)
 {
 	unsigned int fscl = *f;
-	unsigned int div_a, div_b, calc_div_a = 0;
+	unsigned int div_a, div_b, calc_div_a = 0, calc_div_b = 0;
 	unsigned int best_div_a = 0, best_div_b = 0;
 	unsigned int last_error = 0, current_error = 0;
-	unsigned int best_fscl, actual_fscl, temp;
+	unsigned int best_fscl = *f, actual_fscl, temp, templimit;
 
 	/* Assume div_a is 0 and calculate (divisor_a+1) x (divisor_b+1) */
 	temp = input_clk / (22 * fscl);
@@ -585,31 +585,58 @@ static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
 	 */
 	if (temp == 0)
 		return -EINVAL;
-	last_error = fscl;
-	for (div_b = 0; div_b < 64; div_b++) {
-		calc_div_a = (temp / (div_b + 1));
-		if (calc_div_a == 0)
-			div_a = calc_div_a;
-		else
-			div_a = calc_div_a - 1;
-		actual_fscl = input_clk / (22 * (div_a + 1) * (div_b + 1));
 
-		if (div_a > 3)
-			continue;
-		current_error = ((actual_fscl > fscl) ? (actual_fscl - fscl) :
+	/*
+	 * tempLimit helps in iterating over the consecutive value of temp to
+	 * find the closest clock rate achievable with divisors.
+	 */
+	templimit = (input_clk % (22 * fscl)) ? (temp + 1) : temp;
+	*err = fscl;
+
+	for ( ; temp < templimit+1; temp++)
+	{
+		last_error = fscl;
+		calc_div_a = 0;
+		calc_div_b = 0;
+		current_error = 0;
+
+		for (div_b = 0; div_b < 64; div_b++) {
+			div_a = temp / (div_b + 1);
+
+			if (div_a != 0)
+				div_a = div_a - 1;
+
+			if (div_a > 3)
+				continue;
+
+			actual_fscl =
+				input_clk / (22 * (div_a + 1) * (div_b + 1));
+
+			current_error =
+				((actual_fscl > fscl) ? (actual_fscl - fscl) :
 							(fscl - actual_fscl));
-		if ((last_error > current_error) && (actual_fscl <= fscl)) {
-			best_div_a = div_a;
-			best_div_b = div_b;
-			last_error = current_error;
-			best_fscl = actual_fscl;
+
+			if (last_error > current_error) {
+				calc_div_a = div_a;
+				calc_div_b = div_b;
+				best_fscl = actual_fscl;
+				last_error = current_error;
+			}
+		}
+
+		/*
+		 * Used to capture the best divisors.
+		 */
+		if (last_error < *err) {
+			*err = last_error;
+			best_div_a = calc_div_a;
+			best_div_b = calc_div_b;
+			*f = best_fscl;
 		}
 	}
 
 	*a = best_div_a;
 	*b = best_div_b;
-	*f = best_fscl;
-	*err = last_error;
 
 	return 0;
 }
-- 
1.7.5.4

