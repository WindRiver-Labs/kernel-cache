From 3696f27acbca26d0199d982cbdbcd4035ad76322 Mon Sep 17 00:00:00 2001
From: Suneel <suneelg@xilinx.com>
Date: Wed, 4 Jan 2012 15:26:45 +0530
Subject: [PATCH 291/628] Xilinx: ARM: I2C PS driver: fix for eeprom read and
 write

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit 4cc0c3d5557eeb1e92b2ef3c5fd65db0101ef805

Removed the setting of HOLD bus bit for more than one messages.
In ISR for complete, clearing the HOLD bus bit whenever we fill
the last data.

Signed-Off-by: suneelg@xilinx.com <Suneel G>

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/i2c/busses/i2c-xilinx_ps.c |   29 +++++++++++++++++------------
 1 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/drivers/i2c/busses/i2c-xilinx_ps.c b/drivers/i2c/busses/i2c-xilinx_ps.c
index f942ec9..47d7a6a 100644
--- a/drivers/i2c/busses/i2c-xilinx_ps.c
+++ b/drivers/i2c/busses/i2c-xilinx_ps.c
@@ -32,9 +32,8 @@
  *	To avoid this, we wrote the expected bytes to receive as FIFO depth + 1
  *	instead of FIFO depth. This generated the second DATA interrupt as there
  *	are still outstanding bytes to be received.
- *	In repeated start and read, write in one stop, we need to process
- *	consecutive messages without generating stop condition. So we used a
- *	flag to avoid clearing of HOLD bit after processing each message.
+ *
+ *	This driver has no support for Repeated start.
  *
  */
 
@@ -148,6 +147,7 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 {
 	unsigned int isr_status, avail_bytes;
 	unsigned int bytes_to_recv, bytes_to_send;
+	unsigned int ctrl_reg = 0;
 	struct xi2cps *id = ptr;
 
 	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
@@ -226,12 +226,19 @@ static irqreturn_t xi2cps_isr(int irq, void *ptr)
 		 * bit if there are no further messages to be processed.
 		 */
 				complete(&id->xfer_done);
-				if (id->bus_hold_flag == 0)
+			}
+			if (id->send_count == 0) {
+				if (id->bus_hold_flag == 0) {
 					/* Clear the hold bus bit */
-					xi2cps_writereg(
-					(xi2cps_readreg(XI2CPS_CR_OFFSET) &
-					(~XI2CPS_CR_HOLD_BUS_MASK)),
-					XI2CPS_CR_OFFSET);
+					ctrl_reg =
+					xi2cps_readreg(XI2CPS_CR_OFFSET);
+					if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
+						== XI2CPS_CR_HOLD_BUS_MASK)
+						xi2cps_writereg(
+						(ctrl_reg &
+						(~XI2CPS_CR_HOLD_BUS_MASK)),
+						XI2CPS_CR_OFFSET);
+				}
 			}
 		} else {
 		/*
@@ -392,11 +399,9 @@ static int xi2cps_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	 * Set the flag to zero when multiple messages are to be
 	 * processed with a repeated start.
 	 */
-	if (num > 1) {
+	if (num > 1)
 		id->bus_hold_flag = 0;
-		xi2cps_writereg((xi2cps_readreg(XI2CPS_CR_OFFSET) |
-				XI2CPS_CR_HOLD_BUS_MASK), XI2CPS_CR_OFFSET);
-	} else
+	else
 		id->bus_hold_flag = 1;
 
 	/* Process the msg one by one */
-- 
1.7.5.4

