From 4cc723e926bbaa95291e6cacf616d380dfbc40d2 Mon Sep 17 00:00:00 2001
From: Dave Lerner <dave.lerner@windriver.com>
Date: Tue, 20 Oct 2015 07:40:41 -0500
Subject: [PATCH] perf: fix backtrace for AAPCS with FP enabled

Issue: LIN8-835

This change replaces code designed for the obsolete ARM APCS ABI, which
causes failures of the perf backtrace logic unless the gcc option
-mapcs-frame is used to build all binaries on the platform.  This
obsolete gcc option forces the compiler to include the stack pointer
along with the frame pointer and link register in the stack frame
for each funciton call. The current AAPCS ABI document, doesn't
explicitly describe the frame structure when the gcc frame pointer
option, -fno-omit-frame-pointer, is enabled. However, with this option
enabled, examination of the emitted prologue instructions shows that
1) R11 is used as the frame pointer,
2) only the R11 and LR are saved onto the stack, not the stack pointer,
3) after this prologue setup, the frame pointer, R11 points to the
saved location of LR on the stack.

The use of unsigned long arithmetic in the commit is required since
the gcc emitted pointer arithmetic uses 8-byte pointer sizes, which are
incorrect addresses for the 4-byte stack address size.

As noted in removed comments, the original code was taken from oprofile,
and that original logic fails in oprofile unless the obsolete gcc option
-mapcs-frame is included in the build for all binaries on the platform.
A separate commit will address this correction in oprofile.
---
 arch/arm/kernel/perf_callchain.c | 24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/arch/arm/kernel/perf_callchain.c b/arch/arm/kernel/perf_callchain.c
index 4e02ae5..d58f90c 100644
--- a/arch/arm/kernel/perf_callchain.c
+++ b/arch/arm/kernel/perf_callchain.c
@@ -12,16 +12,22 @@
 #include <asm/stacktrace.h>
 
 /*
- * The registers we're interested in are at the end of the variable
- * length saved register structure. The fp points at the end of this
- * structure so the address of this struct is:
- * (struct frame_tail *)(xxx->fp)-1
+ * The AAPCS ABI, the most current replacing the obsolete APCS ABI,
+ * does not specifically describe the stack frame with respect to the
+ * frame pointer.  However, the examination of emitted prologue
+ * instructions for ARM implies that with -fno-omit-framepointer,
+ * register R11 is used as the frame pointer register and saved on the
+ * stack, with LR.
  *
- * This code has been adapted from the ARM OProfile support.
+ * After the prolog, the FP points to the location of the saved LR and
+ * FP+4 points to the previous frames FP as shown below:
+ *  Stack Hi Mem
+ *  (Value of FP)+4  Saved FP for caller
+ *  (Value of FP)    LR set by caller
+ *  Stack Lo Mem
  */
 struct frame_tail {
 	struct frame_tail __user *fp;
-	unsigned long sp;
 	unsigned long lr;
 } __attribute__((packed));
 
@@ -52,10 +58,10 @@ user_backtrace(struct frame_tail __user *tail,
 	 * Frame pointers should strictly progress back up the stack
 	 * (towards higher addresses).
 	 */
-	if (tail + 1 >= buftail.fp)
+	if ((unsigned long)tail + 4 >= (unsigned long)buftail.fp)
 		return NULL;
 
-	return buftail.fp - 1;
+	return (struct frame_tail *) ((unsigned long)buftail.fp - 4);
 }
 
 void
@@ -73,7 +79,7 @@ perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 	if (!current->mm)
 		return;
 
-	tail = (struct frame_tail __user *)regs->ARM_fp - 1;
+	tail = (struct frame_tail __user *)(regs->ARM_fp - 4);
 
 	while ((entry->nr < PERF_MAX_STACK_DEPTH) &&
 	       tail && !((unsigned long)tail & 0x3))
-- 
2.0.2

