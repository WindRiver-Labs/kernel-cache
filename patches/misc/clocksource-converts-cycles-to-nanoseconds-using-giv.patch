From 3cc1ec77933c8aa06f491ae05ffc4c0a618a8d87 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Wed, 10 Oct 2012 10:45:13 +0800
Subject: [PATCH 2/3] clocksource: converts cycles to nanoseconds, using given mult and shift

Back port cycles to nanoseconds conversion part of the upstream commit
155ec60226a ("timekeeping: Introduce struct timekeeper").
Modify the interface of cyc2ns() to convert cycles to nanoseconds by
using given mult and shift, the clocksource should use mult_orig and
the timekeeping should use mult for conversion for the sake of clocksource
should not be aware existence of ntp but the timekeeping should.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 include/linux/clocksource.h |   12 ++++--------
 kernel/time/clocksource.c   |    6 ++++--
 kernel/time/timekeeping.c   |   10 ++++++----
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f0a7fb9..225ad49 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -172,19 +172,15 @@ static inline cycle_t clocksource_read(struct clocksource *cs)
 }
 
 /**
- * cyc2ns - converts clocksource cycles to nanoseconds
- * @cs:		Pointer to clocksource
- * @cycles:	Cycles
+ * clocksource_cyc2ns - converts clocksource cycles to nanoseconds
  *
- * Uses the clocksource and ntp ajdustment to convert cycle_ts to nanoseconds.
+ * Converts cycles to nanoseconds, using the given mult and shift.
  *
  * XXX - This could use some mult_lxl_ll() asm optimization
  */
-static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
+static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 {
-	u64 ret = (u64)cycles;
-	ret = (ret * cs->mult) >> cs->shift;
-	return ret;
+	return ((u64) cycles * mult) >> shift;
 }
 
 /**
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index 9ed2eec..b34b06d 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -106,7 +106,8 @@ static void clocksource_watchdog(unsigned long data)
 	resumed = test_and_clear_bit(0, &watchdog_resumed);
 
 	wdnow = watchdog->read();
-	wd_nsec = cyc2ns(watchdog, (wdnow - watchdog_last) & watchdog->mask);
+	wd_nsec = clocksource_cyc2ns((wdnow - watchdog_last) & watchdog->mask,
+					watchdog->mult_orig, watchdog->shift);
 	watchdog_last = wdnow;
 
 	list_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {
@@ -133,7 +134,8 @@ static void clocksource_watchdog(unsigned long data)
 			cs->flags |= CLOCK_SOURCE_WATCHDOG;
 			cs->wd_last = csnow;
 		} else {
-			cs_nsec = cyc2ns(cs, (csnow - cs->wd_last) & cs->mask);
+			cs_nsec = clocksource_cyc2ns((csnow - cs->wd_last) &
+					cs->mask, cs->mult_orig, cs->shift);
 			cs->wd_last = csnow;
 			/* Check the delta. Might remove from the list ! */
 			clocksource_ratewd(cs, cs_nsec - wd_nsec);
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 6e22c16..a046ad8 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -76,7 +76,7 @@ static void clocksource_forward_now(void)
 	cycle_delta = (cycle_now - clock->cycle_last) & clock->mask;
 	clock->cycle_last = cycle_now;
 
-	nsec = cyc2ns(clock, cycle_delta);
+	nsec = clocksource_cyc2ns(cycle_delta, clock->mult, clock->shift);
 	timespec_add_ns(&xtime, nsec);
 }
 
@@ -106,8 +106,8 @@ void getnstimeofday(struct timespec *ts)
 		cycle_delta = (cycle_now - clock->cycle_last) & clock->mask;
 
 		/* convert to nanoseconds: */
-		nsecs = cyc2ns(clock, cycle_delta);
-
+		nsecs = clocksource_cyc2ns(cycle_delta, clock->mult,
+						clock->shift);
 	} while (read_seqretry(&xtime_lock, seq));
 
 	timespec_add_ns(ts, nsecs);
@@ -442,6 +442,7 @@ static void clocksource_adjust(s64 offset)
 void update_wall_time(void)
 {
 	cycle_t offset;
+	s64 nsecs;
 
 	/* Make sure we're fully resumed: */
 	if (unlikely(timekeeping_suspended))
@@ -503,7 +504,8 @@ void update_wall_time(void)
 	xtime.tv_nsec = (s64)clock->xtime_nsec >> clock->shift;
 	clock->xtime_nsec -= (s64)xtime.tv_nsec << clock->shift;
 
-	update_xtime_cache(cyc2ns(clock, offset));
+	nsecs = clocksource_cyc2ns(offset, clock->mult, clock->shift);
+	update_xtime_cache(nsecs);
 
 	/* check to see if there is a new clocksource to use */
 	change_clocksource();
-- 
1.7.3.5

