From 46461a02f161460b584390b760c9fac5dce4f30d Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Fri, 16 Nov 2012 09:31:01 +0800
Subject: [PATCH] strict limitation of dirty ratio starts from 1

When dirty ratio set 0, it will cause ilog2() to calculate error.
ilog2 is a optimized function for integer, and its parameter should be
larger or equal than 1. otherwise it will generate an error value.
So, strict limitation of dirty ratio starts from 1, and it will avoid
the problem.

and Noting the docs for dirty_bytes:
-----------------------
dirty_bytes

Contains the amount of dirty memory at which a process generating disk writes
will itself start writeback.
Note: dirty_bytes is the counterpart of dirty_ratio. Only one of them may be
specified at a time. When one sysctl is written it is immediately taken into
account to evaluate the dirty memory limits and the other appears as 0 when
read.
----------------------
So if a user wants to write zero to the % proc value, he is essentially
trying to clear it. But as the above states, you must have one of
the two set.  So zero is EINVAL, since if you want to clear dirty_percent,
you must set a value to dirty_bytes (which will then clear the % one
for you automatically).

test case:
 ## echo 0 > /proc/sys/vm/dirty_ratio
dirty_ratio_handler()
  update_completion_period()
    calc_period_shift()
      return 2 + ilog2(dirty_total - 1);
it causes an error calculate about ilog2(-1) = 63 (should be 2)
After that, a serial of kernel variables will be set error value.
At last, it cause divided error crash:
x86_64 ~ # divide error: 0000 [#1] PREEMPT SMP
LTT NESTING LEVEL : 0
last sysfs file: /sys/devices/pci0000:00/0000:00:1c.3/0000:18:00.0/net/eth0/ifindex
CPU 1
Modules linked in: 8021q sk98lin rsm ipv6
Pid: 575, comm: scp Not tainted 2.6.34.10-WR4.3.0.0_standard #1 /
RIP: 0010:[<ffffffff810d2a6c>]  [<ffffffff810d2a6c>] get_dirty_limits+0x1bc/0x2d0
RSP: 0018:ffff880870b8bac8  EFLAGS: 00010206
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000000 RSI: ffff880870a76430 RDI: ffffffff81a06268
RBP: ffff880870b8bb18 R08: 28f5c28f5c28f5c3 R09: ffff880001c40000
R10: 57ff6304d7bed280 R11: 0000000000000246 R12: 0000000000000000
R13: ffff880870b8bb70 R14: ffff880870b8bb60 R15: ffff880870b8bb68
FS:  00007f044e45e700(0000) GS:ffff880001c40000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
CR2: 00007f044cef6740 CR3: 0000000868be8000 CR4: 00000000000406e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process scp (pid: 575, threadinfo ffff880870b8a000, task ffff880870a75dc0)
Stack:
 0000000000000000 0000000000000001 0000000000000000 0000800000000000
<0> ffff880870b8baf8 0000000000000001 ffffffff81831260 0000000000000600
<0> 0000000000000000 0000000000000000 ffff880870b8bbe8 ffffffff810d2d5f
Call Trace:
 [<ffffffff810d2d5f>] balance_dirty_pages_ratelimited_nr+0x1df/0x3e0
 [<ffffffff810c9f22>] generic_file_buffered_write+0x1b2/0x260
 [<ffffffff810cb25a>] __generic_file_aio_write+0x22a/0x430
 [<ffffffff811308b9>] ? touch_atime+0x79/0x130
 [<ffffffff81123088>] ? pipe_read+0x348/0x4e0
 [<ffffffff810cb4c3>] generic_file_aio_write+0x63/0xd0
 [<ffffffff811197fb>] do_sync_write+0xcb/0x100
 [<ffffffff812a4031>] ? security_file_permission+0x11/0x20
 [<ffffffff81119d58>] ? rw_verify_area+0x58/0xc0
 [<ffffffff8111a02c>] vfs_write+0x9c/0x160
 [<ffffffff8111a3b0>] sys_write+0x50/0x110
 [<ffffffff81002481>] system_call_done+0x0/0x26

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 kernel/sysctl.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index d2ceded..35965f4 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -999,7 +999,7 @@ static struct ctl_table vm_table[] = {
 		.maxlen		= sizeof(vm_dirty_ratio),
 		.mode		= 0644,
 		.proc_handler	= dirty_ratio_handler,
-		.extra1		= &zero,
+		.extra1		= &one,
 		.extra2		= &one_hundred,
 	},
 	{
-- 
1.7.0.2

