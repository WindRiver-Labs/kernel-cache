From 2c6cb74ccf41519e9b33d62482150a45bb2e6c20 Mon Sep 17 00:00:00 2001
From: Jan Kara <jack@suse.cz>
Date: Tue, 4 Jun 2013 12:06:01 -0400
Subject: [PATCH 2/3] jbd2: remove journal_head from descriptor buffers

commit e5a120aeb57f40ae568a5ca1dd6ace53d0213582 upstream

Similarly as for metadata buffers, also log descriptor buffers don't
really need the journal head. So strip it and remove BJ_LogCtl list.

Reviewed-by: Zheng Liu <wenqing.lz@taobao.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 fs/jbd/checkpoint.c  |    1 -
 fs/jbd/commit.c      |   59 +++++++++++++++++++++----------------------------
 fs/jbd/journal.c     |    4 +-
 fs/jbd/revoke.c      |   40 +++++++++++++++++----------------
 fs/jbd/transaction.c |    6 -----
 include/linux/jbd.h  |   19 ++++++----------
 6 files changed, 55 insertions(+), 74 deletions(-)

diff --git a/fs/jbd/checkpoint.c b/fs/jbd/checkpoint.c
index eabc4bd..a670631 100644
--- a/fs/jbd/checkpoint.c
+++ b/fs/jbd/checkpoint.c
@@ -745,7 +745,6 @@ void __journal_drop_transaction(journal_t *journal, transaction_t *transaction)
 	J_ASSERT(transaction->t_sync_datalist == NULL);
 	J_ASSERT(transaction->t_forget == NULL);
 	J_ASSERT(transaction->t_shadow_list == NULL);
-	J_ASSERT(transaction->t_log_list == NULL);
 	J_ASSERT(transaction->t_checkpoint_list == NULL);
 	J_ASSERT(transaction->t_checkpoint_io_list == NULL);
 	J_ASSERT(transaction->t_updates == 0);
diff --git a/fs/jbd/commit.c b/fs/jbd/commit.c
index daccb82..936262a 100644
--- a/fs/jbd/commit.c
+++ b/fs/jbd/commit.c
@@ -120,7 +120,6 @@ static int inverted_lock(journal_t *journal, struct buffer_head *bh)
 static int journal_write_commit_record(journal_t *journal,
 					transaction_t *commit_transaction)
 {
-	struct journal_head *descriptor;
 	struct buffer_head *bh;
 	journal_header_t *header;
 	int ret;
@@ -129,12 +128,10 @@ static int journal_write_commit_record(journal_t *journal,
 	if (is_journal_aborted(journal))
 		return 0;
 
-	descriptor = journal_get_descriptor_buffer(journal);
-	if (!descriptor)
+	bh = journal_get_descriptor_buffer(journal);
+	if (!bh)
 		return 1;
 
-	bh = jh2bh(descriptor);
-
 	header = (journal_header_t *)(bh->b_data);
 	header->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);
 	header->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);
@@ -171,7 +168,6 @@ static int journal_write_commit_record(journal_t *journal,
 		ret = sync_dirty_buffer(bh);
 	}
 	put_bh(bh);		/* One for getblk() */
-	journal_put_journal_head(descriptor);
 
 	return (ret == -EIO);
 }
@@ -307,7 +303,8 @@ write_out_data:
 void journal_commit_transaction(journal_t *journal)
 {
 	transaction_t *commit_transaction;
-	struct journal_head *jh, *descriptor;
+	struct journal_head *jh;
+	struct buffer_head *descriptor;
 	struct buffer_head **wbuf = journal->j_wbuf;
 	int bufs;
 	int flags;
@@ -324,6 +321,7 @@ void journal_commit_transaction(journal_t *journal)
 	int i;
 	int write_op = WRITE;
 	LIST_HEAD(io_bufs);
+	LIST_HEAD(log_bufs);
 
 	/*
 	 * First job: lock down the current transaction and wait for
@@ -509,7 +507,8 @@ void journal_commit_transaction(journal_t *journal)
 		err = 0;
 	}
 
-	journal_write_revoke_records(journal, commit_transaction, write_op);
+	journal_write_revoke_records(journal, commit_transaction,
+						&log_bufs, write_op);
 
 	/*
 	 * If we found any dirty or locked buffers, then we should have
@@ -533,8 +532,8 @@ void journal_commit_transaction(journal_t *journal)
 	J_ASSERT(commit_transaction->t_nr_buffers <=
 		 commit_transaction->t_outstanding_credits);
 
-	descriptor = NULL;
 	bufs = 0;
+	descriptor = NULL;
 	while (commit_transaction->t_buffers) {
 
 		/* Find the next buffer to be journaled... */
@@ -561,7 +560,6 @@ void journal_commit_transaction(journal_t *journal)
 		   record the metadata buffer. */
 
 		if (!descriptor) {
-			struct buffer_head *bh;
 
 			J_ASSERT (bufs == 0);
 
@@ -573,26 +571,27 @@ void journal_commit_transaction(journal_t *journal)
 				continue;
 			}
 
-			bh = jh2bh(descriptor);
 			jbd_debug(4, "JBD: got buffer %llu (%p)\n",
-				(unsigned long long)bh->b_blocknr, bh->b_data);
-			header = (journal_header_t *)&bh->b_data[0];
+				(unsigned long long)descriptor->b_blocknr,
+				descriptor->b_data);
+			header = (journal_header_t *)descriptor->b_data;
 			header->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);
 			header->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);
 			header->h_sequence  = cpu_to_be32(commit_transaction->t_tid);
 
-			tagp = &bh->b_data[sizeof(journal_header_t)];
-			space_left = bh->b_size - sizeof(journal_header_t);
+			tagp = &descriptor->b_data[sizeof(journal_header_t)];
+			space_left = descriptor->b_size -
+						sizeof(journal_header_t);
+
 			first_tag = 1;
-			set_buffer_jwrite(bh);
-			set_buffer_dirty(bh);
-			wbuf[bufs++] = bh;
+			set_buffer_jwrite(descriptor);
+			set_buffer_dirty(descriptor);
+			wbuf[bufs++] = descriptor;
 
 			/* Record it so that we can wait for IO
                            completion later */
-			BUFFER_TRACE(bh, "ph3: file as descriptor");
-			journal_file_buffer(descriptor, commit_transaction,
-					BJ_LogCtl);
+			BUFFER_TRACE(descriptor, "ph3: file as descriptor");
+			jbd_file_log_bh(&log_bufs, descriptor);
 		}
 
 		/* Where is the buffer to be written? */
@@ -749,26 +748,19 @@ start_journal_io:
 	jbd_debug(3, "JBD: commit phase 5\n");
 
 	/* Here we wait for the revoke record and descriptor record buffers */
- wait_for_ctlbuf:
-	while (commit_transaction->t_log_list != NULL) {
+	while (!list_empty(&log_bufs)) {
 		struct buffer_head *bh;
 
-		jh = commit_transaction->t_log_list->b_tprev;
-		bh = jh2bh(jh);
-		if (buffer_locked(bh)) {
-			wait_on_buffer(bh);
-			goto wait_for_ctlbuf;
-		}
-		if (cond_resched())
-			goto wait_for_ctlbuf;
+		bh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);
+		wait_on_buffer(bh);
+		cond_resched();
 
 		if (unlikely(!buffer_uptodate(bh)))
 			err = -EIO;
 
 		BUFFER_TRACE(bh, "ph5: control buffer writeout done: unfile");
 		clear_buffer_jwrite(bh);
-		journal_unfile_buffer(journal, jh);
-		journal_put_journal_head(jh);
+		jbd_unfile_log_bh(bh);
 		__brelse(bh);		/* One for getblk */
 		/* AKPM: bforget here */
 	}
@@ -795,7 +787,6 @@ start_journal_io:
 	J_ASSERT(commit_transaction->t_buffers == NULL);
 	J_ASSERT(commit_transaction->t_checkpoint_list == NULL);
 	J_ASSERT(commit_transaction->t_shadow_list == NULL);
-	J_ASSERT(commit_transaction->t_log_list == NULL);
 
 restart_loop:
 	/*
diff --git a/fs/jbd/journal.c b/fs/jbd/journal.c
index 8dede9a..8230bed 100644
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -641,7 +641,7 @@ int journal_bmap(journal_t *journal, unsigned int blocknr,
  * But we don't bother doing that, so there will be coherency problems with
  * mmaps of blockdevs which hold live JBD-controlled filesystems.
  */
-struct journal_head *journal_get_descriptor_buffer(journal_t *journal)
+struct buffer_head *journal_get_descriptor_buffer(journal_t *journal)
 {
 	struct buffer_head *bh;
 	unsigned int blocknr;
@@ -660,7 +660,7 @@ struct journal_head *journal_get_descriptor_buffer(journal_t *journal)
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
 	BUFFER_TRACE(bh, "return this buffer");
-	return journal_add_journal_head(bh);
+	return bh;
 }
 
 /*
diff --git a/fs/jbd/revoke.c b/fs/jbd/revoke.c
index d290183..551fd02 100644
--- a/fs/jbd/revoke.c
+++ b/fs/jbd/revoke.c
@@ -118,9 +118,10 @@ struct jbd_revoke_table_s
 
 #ifdef __KERNEL__
 static void write_one_revoke_record(journal_t *, transaction_t *,
-				    struct journal_head **, int *,
+				    struct list_head *,
+				    struct buffer_head **, int *,
 				    struct jbd_revoke_record_s *, int);
-static void flush_descriptor(journal_t *, struct journal_head *, int, int);
+static void flush_descriptor(journal_t *, struct buffer_head *, int, int);
 #endif
 
 /* Utility functions to maintain the revoke table */
@@ -501,9 +502,10 @@ void journal_switch_revoke_table(journal_t *journal)
  * revoke hash, deleting the entries as we go.
  */
 void journal_write_revoke_records(journal_t *journal,
-				  transaction_t *transaction, int write_op)
+				  transaction_t *transaction,
+				struct list_head *log_bufs, int write_op)
 {
-	struct journal_head *descriptor;
+	struct buffer_head *descriptor;
 	struct jbd_revoke_record_s *record;
 	struct jbd_revoke_table_s *revoke;
 	struct list_head *hash_list;
@@ -523,7 +525,7 @@ void journal_write_revoke_records(journal_t *journal,
 		while (!list_empty(hash_list)) {
 			record = (struct jbd_revoke_record_s *)
 				hash_list->next;
-			write_one_revoke_record(journal, transaction,
+			write_one_revoke_record(journal, transaction, log_bufs,
 						&descriptor, &offset,
 						record, write_op);
 			count++;
@@ -543,12 +545,13 @@ void journal_write_revoke_records(journal_t *journal,
 
 static void write_one_revoke_record(journal_t *journal,
 				    transaction_t *transaction,
-				    struct journal_head **descriptorp,
+				    struct list_head *log_bufs,
+				    struct buffer_head **descriptorp,
 				    int *offsetp,
 				    struct jbd_revoke_record_s *record,
 				    int write_op)
 {
-	struct journal_head *descriptor;
+	struct buffer_head *descriptor;
 	int offset;
 	journal_header_t *header;
 
@@ -574,20 +577,20 @@ static void write_one_revoke_record(journal_t *journal,
 		descriptor = journal_get_descriptor_buffer(journal);
 		if (!descriptor)
 			return;
-		header = (journal_header_t *) &jh2bh(descriptor)->b_data[0];
+		header = (journal_header_t *) descriptor->b_data;
 		header->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);
 		header->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);
 		header->h_sequence  = cpu_to_be32(transaction->t_tid);
 
 		/* Record it so that we can wait for IO completion later */
-		JBUFFER_TRACE(descriptor, "file as BJ_LogCtl");
-		journal_file_buffer(descriptor, transaction, BJ_LogCtl);
+		BUFFER_TRACE(descriptor, "file in log_bufs");
+		jbd_file_log_bh(log_bufs, descriptor);
 
 		offset = sizeof(journal_revoke_header_t);
 		*descriptorp = descriptor;
 	}
 
-	* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =
+	* ((__be32 *)(&descriptor->b_data[offset])) =
 		cpu_to_be32(record->blocknr);
 	offset += 4;
 	*offsetp = offset;
@@ -601,23 +604,22 @@ static void write_one_revoke_record(journal_t *journal,
  */
 
 static void flush_descriptor(journal_t *journal,
-			     struct journal_head *descriptor,
+			     struct buffer_head *descriptor,
 			     int offset, int write_op)
 {
 	journal_revoke_header_t *header;
-	struct buffer_head *bh = jh2bh(descriptor);
 
 	if (is_journal_aborted(journal)) {
-		put_bh(bh);
+		put_bh(descriptor);
 		return;
 	}
 
-	header = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;
+	header = (journal_revoke_header_t *) descriptor->b_data;
 	header->r_count = cpu_to_be32(offset);
-	set_buffer_jwrite(bh);
-	BUFFER_TRACE(bh, "write");
-	set_buffer_dirty(bh);
-	write_dirty_buffer(bh, write_op);
+	set_buffer_jwrite(descriptor);
+	BUFFER_TRACE(descriptor, "write");
+	set_buffer_dirty(descriptor);
+	write_dirty_buffer(descriptor, write_op);
 }
 #endif
 
diff --git a/fs/jbd/transaction.c b/fs/jbd/transaction.c
index fb44d6e..cd98fd8 100644
--- a/fs/jbd/transaction.c
+++ b/fs/jbd/transaction.c
@@ -1603,9 +1603,6 @@ static void __journal_temp_unlink_buffer(struct journal_head *jh)
 	case BJ_Shadow:
 		list = &transaction->t_shadow_list;
 		break;
-	case BJ_LogCtl:
-		list = &transaction->t_log_list;
-		break;
 	case BJ_Reserved:
 		list = &transaction->t_reserved_list;
 		break;
@@ -2114,9 +2111,6 @@ void __journal_file_buffer(struct journal_head *jh,
 	case BJ_Shadow:
 		list = &transaction->t_shadow_list;
 		break;
-	case BJ_LogCtl:
-		list = &transaction->t_log_list;
-		break;
 	case BJ_Reserved:
 		list = &transaction->t_reserved_list;
 		break;
diff --git a/include/linux/jbd.h b/include/linux/jbd.h
index eaa97ea..bec44c1 100644
--- a/include/linux/jbd.h
+++ b/include/linux/jbd.h
@@ -492,12 +492,6 @@ struct transaction_s
 	struct journal_head	*t_shadow_list;
 
 	/*
-	 * Doubly-linked circular list of control buffers being written to the
-	 * log. [j_list_lock]
-	 */
-	struct journal_head	*t_log_list;
-
-	/*
 	 * Protects info related to handles
 	 */
 	spinlock_t		t_handle_lock;
@@ -850,7 +844,7 @@ static inline void jbd_unfile_log_bh(struct buffer_head *bh)
 }
 
 /* Log buffer allocation */
-extern struct journal_head * journal_get_descriptor_buffer(journal_t *);
+extern struct buffer_head * journal_get_descriptor_buffer(journal_t *);
 int journal_next_log_block(journal_t *, unsigned int *);
 
 /* Commit management */
@@ -971,7 +965,9 @@ extern int	   journal_revoke (handle_t *,
 				unsigned int, struct buffer_head *);
 extern int	   journal_cancel_revoke(handle_t *, struct journal_head *);
 extern void	   journal_write_revoke_records(journal_t *,
-						transaction_t *, int);
+						transaction_t *,
+						struct list_head *log_bufs,
+						int);
 
 /* Recovery revoke support */
 extern int	journal_set_revoke(journal_t *, unsigned int, tid_t);
@@ -1076,10 +1072,9 @@ static inline int jbd_space_needed(journal_t *journal)
 #define BJ_Metadata	2	/* Normal journaled metadata */
 #define BJ_Forget	3	/* Buffer superseded by this transaction */
 #define BJ_Shadow	4	/* Buffer contents being shadowed to the log */
-#define BJ_LogCtl	5	/* Buffer contains log descriptors */
-#define BJ_Reserved	6	/* Buffer is reserved for access by journal */
-#define BJ_Locked	7	/* Locked for I/O during commit */
-#define BJ_Types	8
+#define BJ_Reserved	5	/* Buffer is reserved for access by journal */
+#define BJ_Locked	6	/* Locked for I/O during commit */
+#define BJ_Types	7
 
 extern int jbd_blocks_per_page(struct inode *inode);
 
-- 
1.7.0

