From 031915ecbb8b77ef057de17b7d5e5bd279b2f961 Mon Sep 17 00:00:00 2001
From: Jibin Xu <jibin.xu@windriver.com>
Date: Thu, 24 Nov 2016 12:45:15 -0800
Subject: [PATCH 3/6] f2fs: fix to determine start_cp_addr by sbi->cur_cp_pack

Based on from https://git.kernel.org/pub/scm/linux/kernel/git/chao/linux.git
branch: f2fs-dev
commit: 8508e44ae98622f841f5ef29d0bf3d5db4e0c1cc

We don't guarantee cp_addr is fixed by cp_version.
This is to sync with f2fs-tools.

Cc: stable@vger.kernel.org
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

Refer to cf779cab14d5, backport the logic of
do_checkpoint(). The original log is:
[
    f2fs: handle EIO not to break fs consistency

    There are two rules when EIO is occurred.
    1. don't write any checkpoint data to preserve the previous checkpoint
    2. don't lose the cached dentry/node/meta pages

    So, at first, this patch adds set_page_dirty in f2fs_write_end_io's failure.
    Then, writing checkpoint/dentry/node blocks is not allowed.

    Note that, for the data pages, we can't just throw away by redirtying them.
    Otherwise, kworker can fall into infinite loop to flush them.
    (Ref. xfstests/019)
]

Signed-off-by: Jibin Xu <jibin.xu@windriver.com>
---
 fs/f2fs/checkpoint.c |    8 +++++++-
 fs/f2fs/f2fs.h       |   28 ++++++++++++++++++----------
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/fs/f2fs/checkpoint.c b/fs/f2fs/checkpoint.c
index 4b792b0..8d999e0 100644
--- a/fs/f2fs/checkpoint.c
+++ b/fs/f2fs/checkpoint.c
@@ -462,6 +462,11 @@ int get_valid_checkpoint(struct f2fs_sb_info *sbi)
 	if (sanity_check_ckpt(sbi))
 		goto fail_no_cp;
 
+	if (cur_page == cp1)
+		sbi->cur_cp_pack = 1;
+	else
+		sbi->cur_cp_pack = 2;
+
 	if (cp_blks <= 1)
 		goto done;
 
@@ -770,7 +775,7 @@ static void do_checkpoint(struct f2fs_sb_info *sbi, bool is_umount)
 				le32_to_cpu(ckpt->checksum_offset)))
 				= cpu_to_le32(crc32);
 
-	start_blk = __start_cp_addr(sbi);
+	start_blk = __start_cp_next_addr(sbi);
 
 	/* write out checkpoint buffer at block 0 */
 	cp_page = grab_meta_page(sbi, start_blk++);
@@ -824,6 +829,7 @@ static void do_checkpoint(struct f2fs_sb_info *sbi, bool is_umount)
 		clear_prefree_segments(sbi);
 		F2FS_RESET_SB_DIRT(sbi);
 	}
+	__set_cp_next_pack(sbi);
 }
 
 /*
diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h
index a7fa066..deb21d2 100644
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@ -401,6 +401,7 @@ struct f2fs_sb_info {
 
 	/* for checkpoint */
 	struct f2fs_checkpoint *ckpt;		/* raw checkpoint pointer */
+	int cur_cp_pack;			/* remain current cp pack */
 	struct inode *meta_inode;		/* cache meta blocks */
 	struct mutex cp_mutex;			/* checkpoint procedure lock */
 	struct rw_semaphore cp_rwsem;		/* blocking FS operations */
@@ -728,17 +729,10 @@ static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)
 
 static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)
 {
-	block_t start_addr;
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	unsigned long long ckpt_version = cur_cp_version(ckpt);
-
-	start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);
 
-	/*
-	 * odd numbered checkpoint should at cp segment 0
-	 * and even segent must be at cp segment 1
-	 */
-	if (!(ckpt_version & 1))
+	block_t start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);
+	
+	if (sbi->cur_cp_pack == 2)
 		start_addr += sbi->blocks_per_seg;
 
 	return start_addr;
@@ -749,6 +743,20 @@ static inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)
 	return le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);
 }
 
+static inline block_t __start_cp_next_addr(struct f2fs_sb_info *sbi)
+{
+	block_t start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);
+
+	if (sbi->cur_cp_pack == 1)
+		start_addr += sbi->blocks_per_seg;
+ 	return start_addr;
+}
+
+static inline void __set_cp_next_pack(struct f2fs_sb_info *sbi)
+{
+	sbi->cur_cp_pack = (sbi->cur_cp_pack == 1) ? 2 : 1;
+}
+
 static inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,
 						struct inode *inode)
 {
-- 
1.7.9.5

