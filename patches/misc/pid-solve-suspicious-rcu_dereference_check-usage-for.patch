From 6e79820f6a1b0e15dd9df8aec6e6d2f1b37e9d43 Mon Sep 17 00:00:00 2001
From: Li Zhou <li.zhou@windriver.com>
Date: Fri, 29 Apr 2016 17:41:56 +0800
Subject: [PATCH] pid: solve "suspicious rcu_dereference_check() usage" for
 attach_pid()

When CONFIG_LIVEDUMP and CONFIG_PROVE_RCU are set, there will be
[ INFO: suspicious RCU usage. ] when starting up the system.

kernel/pid.c:399 suspicious rcu_dereference_check() usage!
stack backtrace is:
[ 0.152878] [<c041a594>] (unwind_backtrace) from [<c0414080>] (show_stack+0x20/0x24)
[ 0.152888] [<c0414080>] (show_stack) from [<c0ad5bf4>] (dump_stack+0x78/0x98)
[ 0.152898] [<c0ad5bf4>] (dump_stack) from [<c0479978>] (lockdep_rcu_suspicious+0xd8/0x114)
[ 0.152908] [<c0479978>] (lockdep_rcu_suspicious) from [<c044fa84>] (attach_pid+0x68/0xe4)
[ 0.152918] [<c044fa84>] (attach_pid) from [<c042c01c>] (copy_process.part.5+0x135c/0x174c)
[ 0.152927] [<c042c01c>] (copy_process.part.5) from [<c042c4b4>] (copy_process+0x6c/0x84)
[ 0.152935] [<c042c4b4>] (copy_process) from [<c042c5d8>] (do_fork+0x84/0x7c0)
[ 0.152943] [<c042c5d8>] (do_fork) from [<c042cd4c>] (kernel_thread+0x38/0x40)
[ 0.152953] [<c042cd4c>] (kernel_thread) from [<c0ad1644>] (rest_init+0x30/0x174)
[ 0.152964] [<c0ad1644>] (rest_init) from [<c0d78cf4>] (start_kernel+0x3a4/0x414)
[ 0.152971] [<c0d78cf4>] (start_kernel) from [<0040808c>] (0x40808c)

This INFO is printed because that rcu_dereference is called without
calling rcu_read_lock before. In fact the rcu protected variant here
can be protected by either rcu or tasklist_lock. So
rcu_dereference_check is used here to make sure that the lock checking
can pass when either rcu_read_lock or tasklist_lock is held.

Signed-off-by: Li Zhou <li.zhou@windriver.com>
---
 kernel/pid.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/kernel/pid.c b/kernel/pid.c
index e3c3629..3a241df 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -396,7 +396,8 @@ void attach_pid(struct task_struct *task, enum pid_type type)
 	   arrives later, adding it after origin prevents pid_task()
 	   from returning pointer to clone instead of origin. */
 	if ((type == PIDTYPE_PID) &&
-	    (first = rcu_dereference(link->pid->tasks[type].first)))
+	    (first = rcu_dereference_check(link->pid->tasks[type].first,
+				lockdep_tasklist_lock_is_held())))
 		hlist_add_behind_rcu(&link->node, first);
 	else
 #endif
-- 
1.7.5.4

