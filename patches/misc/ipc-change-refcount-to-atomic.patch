From 1b524b5de9a4456c2aaee3b556494f7c88d07cbb Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Fri, 25 Jul 2014 15:41:57 +0800
Subject: [PATCH] ipc: change refcount to atomic

the patch comes from:
http://patches.kernelcare.com/bd35e2ecff1bc2241c3ba2007f5767e9473f66e3/1/kpatch.html
get kernel-2.6.18-redhat.patch from kernel-2.6.18-371.6.1.el5.src.rpm
at the same time, refer to kernel upstream of commit:
6062a8dc0517bce23e3c2f7d2fea5e22411269a3

The ipc_rcu_putref function in ipc/util.c in the Linux kernel
before 3.10 does not properly manage a reference count,
which allows local users to cause a denial of service
(memory consumption or system crash) via a crafted application.
http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-4483

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 ipc/msg.c  |    7 ++++++-
 ipc/sem.c  |   22 +++++++++++++---------
 ipc/util.c |   34 ++++++++++++++++++----------------
 ipc/util.h |    2 +-
 4 files changed, 38 insertions(+), 27 deletions(-)

diff --git a/ipc/msg.c b/ipc/msg.c
index 4c05653..211ba4b 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -688,7 +688,12 @@ long do_msgsnd(int msqid, long mtype, void __user *mtext,
 			goto out_unlock_free;
 		}
 		ss_add(msq, &s);
-		ipc_rcu_getref(msq);
+
+		if (!ipc_rcu_getref(msq)) {
+			err = -EIDRM;
+			goto out_unlock_free;
+		}
+
 		msg_unlock(msq);
 		schedule();
 
diff --git a/ipc/sem.c b/ipc/sem.c
index 3db6507..9dd4bd9 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -175,12 +175,6 @@ static inline void sem_lock_and_putref(struct sem_array *sma)
 	ipc_rcu_putref(sma);
 }
 
-static inline void sem_getref_and_unlock(struct sem_array *sma)
-{
-	ipc_rcu_getref(sma);
-	ipc_unlock(&(sma)->sem_perm);
-}
-
 static inline void sem_putref(struct sem_array *sma)
 {
 	ipc_lock_by_ptr(&sma->sem_perm);
@@ -746,7 +740,8 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,
 		int i;
 
 		if(nsems > SEMMSL_FAST) {
-			sem_getref_and_unlock(sma);
+			WARN_ON_ONCE(!ipc_rcu_getref(sma));
+			sem_unlock(sma);
 
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 			if(sem_io == NULL) {
@@ -775,7 +770,11 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,
 		int i;
 		struct sem_undo *un;
 
-		sem_getref_and_unlock(sma);
+		if (!ipc_rcu_getref(sma)) {
+			sem_unlock(sma);
+			return -EIDRM;
+		}
+		sem_unlock(sma);
 
 		if(nsems > SEMMSL_FAST) {
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
@@ -1080,7 +1079,12 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)
 		return ERR_PTR(PTR_ERR(sma));
 
 	nsems = sma->sem_nsems;
-	sem_getref_and_unlock(sma);
+	if (!ipc_rcu_getref(sma)) {
+		sem_unlock(sma);
+		un = ERR_PTR(-EIDRM);
+		goto out;
+	}
+	sem_unlock(sma);
 
 	/* step 2: allocate new undo structure */
 	new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);
diff --git a/ipc/util.c b/ipc/util.c
index 79ce84e..cbcc4a8 100644
--- a/ipc/util.c
+++ b/ipc/util.c
@@ -478,7 +478,7 @@ void ipc_free(void* ptr, int size)
  */
 struct ipc_rcu_hdr
 {
-	int refcount;
+	atomic_t refcount;
 	int is_vmalloc;
 	void *data[0];
 };
@@ -516,8 +516,7 @@ static inline int rcu_use_vmalloc(int size)
  *	@size: size desired
  *
  *	Allocate memory for the rcu header structure +  the object.
- *	Returns the pointer to the object.
- *	NULL is returned if the allocation fails. 
+ *	Returns the pointer to the object or NULL upon failure.
  */
  
 void* ipc_rcu_alloc(int size)
@@ -529,26 +528,29 @@ void* ipc_rcu_alloc(int size)
 	 */
 	if (rcu_use_vmalloc(size)) {
 		out = vmalloc(HDRLEN_VMALLOC + size);
-		if (out) {
-			out += HDRLEN_VMALLOC;
-			container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;
-			container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;
-		}
+		if (!out)
+			goto done;
+
+		out += HDRLEN_VMALLOC;
+		container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;
 	} else {
 		out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);
-		if (out) {
-			out += HDRLEN_KMALLOC;
-			container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;
-			container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;
-		}
+		if (!out)
+			goto done;
+
+		out += HDRLEN_KMALLOC;
+		container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;
 	}
 
+	/* set reference counter no matter what kind of allocation was done */
+	atomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);
+done:
 	return out;
 }
 
-void ipc_rcu_getref(void *ptr)
+int ipc_rcu_getref(void *ptr)
 {
-	container_of(ptr, struct ipc_rcu_hdr, data)->refcount++;
+	return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);
 }
 
 static void ipc_do_vfree(struct work_struct *work)
@@ -591,7 +593,7 @@ static void ipc_immediate_free(struct rcu_head *head)
 
 void ipc_rcu_putref(void *ptr)
 {
-	if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)
+	if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))
 		return;
 
 	if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {
diff --git a/ipc/util.h b/ipc/util.h
index 42eb09d..716d9cb 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -118,7 +118,7 @@ void ipc_free(void* ptr, int size);
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
  */
 void* ipc_rcu_alloc(int size);
-void ipc_rcu_getref(void *ptr);
+int ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
-- 
1.7.0

