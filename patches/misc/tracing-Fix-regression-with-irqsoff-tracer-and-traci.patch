From e86ecb6dea81b270236cf9de2251442362e15773 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Thu, 13 Mar 2014 15:46:40 +0800
Subject: [PATCH 2/4] tracing: Fix regression with irqsoff tracer and tracing_on file

commit 2df8f8a6a897ebf4c5613b5be6103d33b2a21520 upstream

Commit 02404baf1b47 "tracing: Remove deprecated tracing_enabled file"
removed the tracing_enabled file as it never worked properly and
the tracing_on file should be used instead. But the tracing_on file
didn't call into the tracers start/stop routines like the
tracing_enabled file did. This caused trace-cmd to break when it
enabled the irqsoff tracer.

If you just did "echo irqsoff > current_tracer" then it would work
properly. But the tool trace-cmd disables tracing first by writing
"0" into the tracing_on file. Then it writes "irqsoff" into
current_tracer and then writes "1" into tracing_on. Unfortunately,
the above commit changed the irqsoff tracer to check the tracing_on
status instead of the tracing_enabled status. If it's disabled then
it does not start the tracer internals.

The problem is that writing "1" into tracing_on does not call the
tracers "start" routine like writing "1" into tracing_enabled did.
This makes the irqsoff tracer not start when using the trace-cmd
tool, and is a regression for userspace.

Simple fix is to have the tracing_on file call the tracers start()
method when being enabled (and the stop() method when disabled).

Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
[modified code lines for applying the patch to the current version
of the kernel]
Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 kernel/trace/trace.c |   12 +++++++++---
 1 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 893577a..5027065 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -4348,11 +4348,17 @@ rb_simple_write(struct file *filp, const char __user *ubuf,
 	if (ret < 0)
 		return ret;
 
-
-	if (val)
+	mutex_lock(&trace_types_lock);
+	if (val) {
 		ring_buffer_record_on(tr->buffer);
-	else
+		if (current_trace->start)
+				current_trace->start(tr);
+	} else {
 		ring_buffer_record_off(tr->buffer);
+		if (current_trace->stop)
+			current_trace->stop(tr);
+	}
+	mutex_unlock(&trace_types_lock);
 
 	(*ppos)++;
 
-- 
1.7.0

