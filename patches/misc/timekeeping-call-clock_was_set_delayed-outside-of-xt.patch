From 0015e24283932b90cd6aec5abfb75966c9dbca58 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Thu, 16 Jul 2015 14:29:44 +0800
Subject: [PATCH 4/4] timekeeping: call clock_was_set_delayed outside of
 xtime_lock protected area

The xtime_lock will be obtained in the function call chain initiated
by clock_was_set_delayed() while the lock was already held, this is
a recursive locking we should avoid, this patch fixes this locking rule
violation by moving the clock_was_set_delayed() call out of the xtime_lock.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 include/linux/sched.h     |    2 +-
 include/linux/time.h      |    2 +-
 kernel/time/tick-sched.c  |    6 +++++-
 kernel/time/timekeeping.c |    9 +++++----
 kernel/timer.c            |    8 ++++++--
 5 files changed, 18 insertions(+), 9 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 204d4a8..fb4b1c6 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -2057,7 +2057,7 @@ extern void release_uids(struct user_namespace *ns);
 
 #include <asm/current.h>
 
-extern void do_timer(unsigned long ticks);
+extern unsigned int do_timer(unsigned long ticks);
 
 extern int wake_up_state(struct task_struct *tsk, unsigned int state);
 extern int wake_up_process(struct task_struct *tsk);
diff --git a/include/linux/time.h b/include/linux/time.h
index 478b88f..4896e23 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -174,7 +174,7 @@ extern void monotonic_to_bootbased(struct timespec *ts);
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
-extern void update_wall_time(void);
+extern unsigned int update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 extern void timekeeping_leap_insert(int leapsecond);
 
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index b7bd1db..7ebde56 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -48,6 +48,7 @@ static void tick_do_update_jiffies64(ktime_t now)
 {
 	unsigned long ticks = 0;
 	ktime_t delta;
+	unsigned int clock_set = 0;
 
 	/*
 	 * Do a quick check without holding xtime_lock:
@@ -75,12 +76,15 @@ static void tick_do_update_jiffies64(ktime_t now)
 			last_jiffies_update = ktime_add_ns(last_jiffies_update,
 							   incr * ticks);
 		}
-		do_timer(++ticks);
+		clock_set = do_timer(++ticks);
 
 		/* Keep the tick_next_period variable up to date */
 		tick_next_period = ktime_add(last_jiffies_update, tick_period);
 	}
 	write_sequnlock(&xtime_lock);
+
+	if (clock_set)
+		clock_was_set_delayed();
 }
 
 /*
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 2ef1f13..23d9df6 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -814,7 +814,6 @@ static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)
 		xtime.tv_sec += leap;
 		wall_to_monotonic.tv_sec -= leap;
 		if (leap) {
-			clock_was_set_delayed();
 			clock_set = TK_CLOCK_WAS_SET;
 		}
 	}
@@ -869,7 +868,7 @@ static cycle_t logarithmic_accumulation(cycle_t offset, int shift,
  *
  * Called from the timer interrupt, must hold a write on xtime_lock.
  */
-void update_wall_time(void)
+unsigned int update_wall_time(void)
 {
 	struct clocksource *clock;
 	cycle_t offset;
@@ -879,7 +878,7 @@ void update_wall_time(void)
 
 	/* Make sure we're fully resumed: */
 	if (unlikely(timekeeping_suspended))
-		return;
+		return 0;
 
 	clock = timekeeper.clock;
 #ifdef CONFIG_GENERIC_TIME
@@ -889,7 +888,7 @@ void update_wall_time(void)
 #endif
 	/* Check if there's really nothing to do */
 	if (offset < timekeeper.cycle_interval)
-		return;
+		return 0;
 
 	timekeeper.xtime_nsec = (s64)xtime.tv_nsec << timekeeper.shift;
 
@@ -950,6 +949,8 @@ void update_wall_time(void)
 	update_xtime_cache(nsecs);
 
 	timekeeping_update(false);
+
+	return clock_set;
 }
 
 /**
diff --git a/kernel/timer.c b/kernel/timer.c
index b00ea41..4b5d6f2 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -1274,12 +1274,16 @@ void run_local_timers(void)
  * jiffies is defined in the linker script...
  */
 
-void do_timer(unsigned long ticks)
+unsigned int do_timer(unsigned long ticks)
 {
+	unsigned int clock_set = 0;
+
 	jiffies_64 += ticks;
-	update_wall_time();
+	clock_set = update_wall_time();
 	trace_timer_update_time(&xtime, &wall_to_monotonic);
 	calc_global_load(ticks);
+
+	return clock_set;
 }
 
 #ifdef __ARCH_WANT_SYS_ALARM
-- 
1.7.5.4

