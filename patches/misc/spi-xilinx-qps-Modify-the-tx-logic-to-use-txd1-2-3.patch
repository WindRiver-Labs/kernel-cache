From 224e59a7346450831696c2942da02eab8c135837 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <suneel.garapati@xilinx.com>
Date: Thu, 30 May 2013 17:14:39 +0530
Subject: [PATCH 247/628] spi: xilinx-qps: Modify the tx logic to use txd1/2/3

git://github.com/Xilinx/linux-xlnx.git xilinx-v14.7
commit f7d385f0d96efb8a74ca2e1067ce5c1abcf7a6f1

Tx logic is modified to utilize TxD1/2/3 registers and few
other constraints.
Transmit length is split into multiples of 4 bytes and the
remainder is transmitted using TxD1/2/3. Also, a transmit on
TxD1/2/3 needs a check for Tx empty before using TXD0 and
vice versa. Towards this requirement, tx_fill_fifo is updated
to fill only if tx length is greater than 4 bytes. For any length
the remainder bytes is first pushed to TxD1/2/3 and enables
interrupts to wait for tx empty interrupt and transfer the remaining
in interrupt routine.

Signed-off-by: Suneel Garapati <suneel.garapati@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/spi/spi-xilinx-qps.c |   32 +++++++++++++++++++-------------
 1 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/drivers/spi/spi-xilinx-qps.c b/drivers/spi/spi-xilinx-qps.c
index ad0811d..270d951 100644
--- a/drivers/spi/spi-xilinx-qps.c
+++ b/drivers/spi/spi-xilinx-qps.c
@@ -491,13 +491,8 @@ static void xqspips_fill_tx_fifo(struct xqspips *xqspi)
 	u32 data = 0;
 
 	while ((!(xqspips_read(xqspi->regs + XQSPIPS_STATUS_OFFSET) &
-		XQSPIPS_IXR_TXFULL_MASK)) && (xqspi->bytes_to_transfer > 0)) {
-		if (xqspi->bytes_to_transfer < 4)
-			xqspips_copy_write_data(xqspi, &data,
-				xqspi->bytes_to_transfer);
-		else
-			xqspips_copy_write_data(xqspi, &data, 4);
-
+		XQSPIPS_IXR_TXFULL_MASK)) && (xqspi->bytes_to_transfer >= 4)) {
+		xqspips_copy_write_data(xqspi, &data, 4);
 		xqspips_write(xqspi->regs + XQSPIPS_TXD_00_00_OFFSET, data);
 	}
 }
@@ -517,6 +512,8 @@ static irqreturn_t xqspips_irq(int irq, void *dev_id)
 {
 	struct xqspips *xqspi = dev_id;
 	u32 intr_status;
+	u8 offset[3] =	{XQSPIPS_TXD_00_01_OFFSET, XQSPIPS_TXD_00_10_OFFSET,
+		XQSPIPS_TXD_00_11_OFFSET};
 
 	intr_status = xqspips_read(xqspi->regs + XQSPIPS_STATUS_OFFSET);
 	xqspips_write(xqspi->regs + XQSPIPS_STATUS_OFFSET , intr_status);
@@ -529,11 +526,11 @@ static irqreturn_t xqspips_irq(int irq, void *dev_id)
 		   the THRESHOLD value set to 1, so this bit indicates Tx FIFO
 		   is empty */
 		u32 config_reg;
+		u32 data;
 
 		/* Read out the data from the RX FIFO */
 		while (xqspips_read(xqspi->regs + XQSPIPS_STATUS_OFFSET) &
 			XQSPIPS_IXR_RXNEMTY_MASK) {
-			u32 data;
 
 			data = xqspips_read(xqspi->regs + XQSPIPS_RXD_OFFSET);
 
@@ -545,9 +542,16 @@ static irqreturn_t xqspips_irq(int irq, void *dev_id)
 		}
 
 		if (xqspi->bytes_to_transfer) {
-			/* There is more data to send */
-			xqspips_fill_tx_fifo(xqspi);
-
+			if (xqspi->bytes_to_transfer >= 4) {
+				/* There is more data to send */
+				xqspips_fill_tx_fifo(xqspi);
+			} else {
+				xqspips_copy_write_data(xqspi, &data,
+					xqspi->bytes_to_transfer);
+				xqspips_write(xqspi->regs +
+					offset[xqspi->bytes_to_transfer],
+					data);
+			}
 			xqspips_write(xqspi->regs + XQSPIPS_IEN_OFFSET,
 					XQSPIPS_IXR_ALL_MASK);
 
@@ -656,6 +660,7 @@ static int xqspips_start_transfer(struct spi_device *qspi,
 		 * delayed if the user tries to write when write FIFO is full
 		 */
 		xqspips_write(xqspi->regs + curr_inst->offset, data);
+		goto xfer_start;
 	}
 
 xfer_data:
@@ -663,13 +668,14 @@ xfer_data:
 	/* In case of Fast, Dual and Quad reads, transmit the instruction first.
 	 * Address and dummy byte will be transmitted in interrupt handler,
 	 * after instruction is transmitted */
-	if (((xqspi->is_inst == 0) && (xqspi->bytes_to_transfer)) ||
-	     ((xqspi->bytes_to_transfer) &&
+	if (((xqspi->is_inst == 0) && (xqspi->bytes_to_transfer >= 4)) ||
+	     ((xqspi->bytes_to_transfer >= 4) &&
 	      (instruction != XQSPIPS_FLASH_OPCODE_FAST_READ) &&
 	      (instruction != XQSPIPS_FLASH_OPCODE_DUAL_READ) &&
 	      (instruction != XQSPIPS_FLASH_OPCODE_QUAD_READ)))
 		xqspips_fill_tx_fifo(xqspi);
 
+xfer_start:
 	xqspips_write(xqspi->regs + XQSPIPS_IEN_OFFSET,
 			XQSPIPS_IXR_ALL_MASK);
 	/* Start the transfer by enabling manual start bit */
-- 
1.7.5.4

