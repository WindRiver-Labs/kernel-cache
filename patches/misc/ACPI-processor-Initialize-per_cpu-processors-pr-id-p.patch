From 56bbb9bd134640bcec437f15abbb41c6555c8413 Mon Sep 17 00:00:00 2001
From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Thu, 30 May 2013 21:55:46 +0200
Subject: [PATCH 04/25] ACPI / processor: Initialize per_cpu(processors,
 pr->id) properly

commit 2e4f1db49d97222110b6add9a2c6cf5251a41e35	upstream

Commit ac212b6 (ACPI / processor: Use common hotplug infrastructure)
forgot about initializing the per-CPU 'processors' variables which
lead to ACPI cpuidle failure to use C-states and caused boot slowdown
on multi-CPU machines.

Fix the problem by adding per_cpu(processors, pr->id) initialization
to acpi_processor_add() and add make acpi_processor_remove() clean it
up as appropriate.

Also modify acpi_processor_stop() so that it doesn't clear
per_cpu(processors, pr->id) on processor driver removal which would
then cause problems to happen when the driver is loaded again.

This version of the patch contains fixes from Yinghai Lu.

Reported-and-tested-by: Yinghai Lu <yinghai@kernel.org>
Reported-and-tested-by: Daniel Lezcano <daniel.lezcano@linaro.org>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/acpi/acpi_processor.c   |    6 ++++++
 drivers/acpi/processor_driver.c |    5 -----
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/drivers/acpi/acpi_processor.c b/drivers/acpi/acpi_processor.c
index 587d2af..cae2641 100644
--- a/drivers/acpi/acpi_processor.c
+++ b/drivers/acpi/acpi_processor.c
@@ -29,6 +29,9 @@
 
 ACPI_MODULE_NAME("processor");
 
+DEFINE_PER_CPU(struct acpi_processor *, processors);
+EXPORT_PER_CPU_SYMBOL(processors);
+
 /* --------------------------------------------------------------------------
                                 Errata Handling
    -------------------------------------------------------------------------- */
@@ -387,6 +390,7 @@ static int __cpuinit acpi_processor_add(struct acpi_device *device,
 	 * checks.
 	 */
 	per_cpu(processor_device_array, pr->id) = device;
+	per_cpu(processors, pr->id) = pr;
 
 	dev = get_cpu_device(pr->id);
 	ACPI_HANDLE_SET(dev, pr->handle);
@@ -407,6 +411,7 @@ static int __cpuinit acpi_processor_add(struct acpi_device *device,
  err:
 	free_cpumask_var(pr->throttling.shared_cpu_map);
 	device->driver_data = NULL;
+	per_cpu(processors, pr->id) = NULL;
  err_free_pr:
 	kfree(pr);
 	return result;
@@ -441,6 +446,7 @@ static void acpi_processor_remove(struct acpi_device *device)
 
 	/* Clean up. */
 	per_cpu(processor_device_array, pr->id) = NULL;
+	per_cpu(processors, pr->id) = NULL;
 	try_offline_node(cpu_to_node(pr->id));
 
 	/* Remove the CPU. */
diff --git a/drivers/acpi/processor_driver.c b/drivers/acpi/processor_driver.c
index ac28f18..d93963f 100644
--- a/drivers/acpi/processor_driver.c
+++ b/drivers/acpi/processor_driver.c
@@ -78,9 +78,6 @@ static struct device_driver acpi_processor_driver = {
 	.remove = acpi_processor_stop,
 };
 
-DEFINE_PER_CPU(struct acpi_processor *, processors);
-EXPORT_PER_CPU_SYMBOL(processors);
-
 static void acpi_processor_notify(acpi_handle handle, u32 event, void *data)
 {
 	struct acpi_device *device = data;
@@ -268,8 +265,6 @@ static int acpi_processor_stop(struct device *dev)
 		thermal_cooling_device_unregister(pr->cdev);
 		pr->cdev = NULL;
 	}
-
-	per_cpu(processors, pr->id) = NULL;
 	return 0;
 }
 
-- 
1.7.5.4

