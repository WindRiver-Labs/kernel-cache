From 738eea57fa0f12c54ff3e34be58b6ec5b5aaad68 Mon Sep 17 00:00:00 2001
From: Wolfgang Deuringer <Wolfgang.Deuringer@emerson.com>
Date: Fri, 6 Sep 2013 11:50:06 +0200
Subject: [PATCH 2/2] igb_5.0.5_SFP_ReInsertion

Adopted from Emerson.

Make link recover when replacing of copper SFP with Fibre.

Signed-off-by: Build User <build@nemo.force.de>
Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 drivers/net/igb/e1000_82575.c |    4 +-
 drivers/net/igb/e1000_82575.h |    4 ++
 drivers/net/igb/igb_main.c    |  102 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 108 insertions(+), 2 deletions(-)

diff --git a/drivers/net/igb/e1000_82575.c b/drivers/net/igb/e1000_82575.c
index b9bc26f..8cb0eef 100644
--- a/drivers/net/igb/e1000_82575.c
+++ b/drivers/net/igb/e1000_82575.c
@@ -67,7 +67,7 @@ static s32  e1000_set_d0_lplu_state_82575(struct e1000_hw *hw,
 					  bool active);
 static s32  e1000_setup_copper_link_82575(struct e1000_hw *hw);
 static s32  e1000_setup_serdes_link_82575(struct e1000_hw *hw);
-static s32  e1000_get_media_type_82575(struct e1000_hw *hw);
+//static s32  e1000_get_media_type_82575(struct e1000_hw *hw);
 static s32  e1000_set_sfp_media_type_82575(struct e1000_hw *hw);
 static s32  e1000_valid_led_default_82575(struct e1000_hw *hw, u16 *data);
 static s32  e1000_write_phy_reg_sgmii_82575(struct e1000_hw *hw,
@@ -1738,7 +1738,7 @@ static s32 e1000_setup_serdes_link_82575(struct e1000_hw *hw)
  *  - MDIO vs. I2C PHY control interface chosen
  *  - SFP module media type
  **/
-static s32 e1000_get_media_type_82575(struct e1000_hw *hw)
+s32 e1000_get_media_type_82575(struct e1000_hw *hw)
 {
 	struct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;
 	s32 ret_val = E1000_SUCCESS;
diff --git a/drivers/net/igb/e1000_82575.h b/drivers/net/igb/e1000_82575.h
index 1aec75a..4629a50 100644
--- a/drivers/net/igb/e1000_82575.h
+++ b/drivers/net/igb/e1000_82575.h
@@ -506,4 +506,8 @@ s32 e1000_read_i2c_byte_generic(struct e1000_hw *hw, u8 byte_offset,
 s32 e1000_write_i2c_byte_generic(struct e1000_hw *hw, u8 byte_offset,
 				 u8 dev_addr, u8 data);
 void e1000_i2c_bus_clear(struct e1000_hw *hw);
+
+/* rdw438: Fix replacement between copper and fiber sfp and vice versa */
+s32  e1000_get_media_type_82575(struct e1000_hw *hw);
+
 #endif /* _E1000_82575_H_ */
diff --git a/drivers/net/igb/igb_main.c b/drivers/net/igb/igb_main.c
index 4752556..d38c443 100644
--- a/drivers/net/igb/igb_main.c
+++ b/drivers/net/igb/igb_main.c
@@ -4516,6 +4516,41 @@ bool igb_has_link(struct igb_adapter *adapter)
 	return link_active;
 }
 
+
+s32 e1000_get_link_partner_ability(struct e1000_hw *hw)
+{
+        u16 mii_nway_lp_ability_reg = 0;
+        s32 ret_val = 0;
+        u16  phy_status;
+
+        if ((hw->phy.media_type == e1000_media_type_copper)) {
+
+                ret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);
+                if (ret_val) {
+                        goto out;
+                }
+
+                ret_val = hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status);
+
+                if (ret_val) {
+                        goto out;
+                }
+                /* we do not want to handle case where link is up */
+                if (phy_status & MII_SR_LINK_STATUS)
+                        goto out;
+
+                ret_val = hw->phy.ops.read_reg(hw, PHY_LP_ABILITY,
+                                &mii_nway_lp_ability_reg);
+                if (ret_val) {
+                        mii_nway_lp_ability_reg = 0;
+                        goto out;
+                }
+        }
+out :
+        return mii_nway_lp_ability_reg;
+}
+
+
 /**
  * igb_watchdog - Timer Call-back
  * @data: pointer to adapter cast into an unsigned long
@@ -4538,6 +4573,9 @@ static void igb_watchdog_task(struct work_struct *work)
 	int i;
 	u32 thstat, ctrl_ext;
 	u32 connsw;
+	u16 phy_status = 0;
+	int ret_val;
+	int media_type;
 
 	link = igb_has_link(adapter);
 	/* Force link down if we have fiber to swap to */
@@ -4679,6 +4717,70 @@ static void igb_watchdog_task(struct work_struct *work)
 		}
 	}
 
+	// read old value of the media type
+	media_type = hw->phy.media_type;
+
+	// re-read media type from hw
+	ret_val = e1000_get_media_type_82575(hw);
+
+	if (media_type != hw->phy.media_type)
+	{
+		// Media Type changed do whatever you need to do
+		printk(KERN_ERR "%s Media Type changed: %d --> %d\n", netdev->name, media_type, hw->phy.media_type );		
+		// if previous media type
+		if ((media_type == e1000_media_type_copper) && (hw->phy.media_type == e1000_media_type_internal_serdes)) {
+			e1000_power_down_phy(hw);
+
+			// set the function pointers	
+			e1000_setup_init_funcs(hw,TRUE);
+
+			printk(KERN_ERR "%s Reset adapter\n", netdev->name);
+			schedule_work(&adapter->reset_task);
+                        /* return immediately */
+			return;
+		}
+		else if ((media_type == e1000_media_type_internal_serdes) && (hw->phy.media_type == e1000_media_type_copper)) {
+			e1000_shutdown_fiber_serdes_link(hw);
+
+			// set the function pointers    
+                        e1000_setup_init_funcs(hw,TRUE);
+
+			printk(KERN_ERR "%s Reset adapter\n", netdev->name);  
+			schedule_work(&adapter->reset_task);
+			/* return immediately */
+                        return;
+		}
+		else 
+		{
+			// strange media type change... 
+		}
+	} 
+	
+
+	/* rdw438: fix for detection of re-insertion of copper sfp modules */
+	if ((hw->phy.media_type == e1000_media_type_copper) && (e1000_get_link_partner_ability(hw) != 0)) {
+		while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
+			msleep(1); 
+		if (!(hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status))) {
+			// re-read phy status register
+			if (!(hw->phy.ops.read_reg(hw, PHY_STATUS, &phy_status))) {
+				if (!(phy_status & MII_SR_LINK_STATUS) && !(phy_status & MII_SR_100X_FD_CAPS)) {
+					printk("%s : Resetting the copper phy \n", netdev->name);
+					if (netif_running(adapter->netdev)) {
+						igb_down(adapter);
+						igb_up(adapter);
+					} 
+					else 
+					{	
+						igb_reset(adapter);
+					}
+				}
+			}
+		}
+		clear_bit(__IGB_RESETTING, &adapter->state);
+	}
+	/* rdw438: fix end */
+
 	igb_update_stats(adapter);
 
 	for (i = 0; i < adapter->num_tx_queues; i++) {
-- 
1.7.0

