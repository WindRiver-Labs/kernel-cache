From 620cb2497ec23619afaea4c89156ed46db978ad1 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 23 Mar 2012 14:25:48 +0800
Subject: [PATCH 2/2] sctp: Make "Invalid Stream Identifier" ERROR follows SACK when bundling

When "Invalid Stream Identifier" ERROR happens after process the
received DATA chunks, this ERROR chunk is enqueued into outqueue
before SACK chunk, so when bundling ERROR chunk with SACK chunk,
the ERROR chunk is always placed first in the packet because of
the chunk's position in the outqueue.
This violates sctp specification:
    RFC 4960 6.5. Stream Identifier and Stream Sequence Number
    ...The endpoint may bundle the ERROR chunk in the same
    packet as the SACK as long as the ERROR follows the SACK.
So we must place SACK first when bundling "Invalid Stream Identifier"
ERROR and SACK in one packet.
Although we can do that by enqueue SACK chunk into outqueue before
ERROR chunk, it will violate the side-effect interpreter processing.
It's easy to do this job when dequeue chunks from the outqueue,
by this way, we introduce a flag 'has_inv_strm_error' which indicate
whether or not the "Invalid Stream Identifier" ERROR happens.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 include/net/sctp/structs.h |    3 +++
 net/sctp/output.c          |   27 +++++++++++++++++++++++++++
 2 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8eaa53d..70973fd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -811,6 +811,9 @@ struct sctp_packet {
 	/* This packet contains a COOKIE-ECHO chunk. */
 	__u8 has_cookie_echo;
 
+	/* This packet contains a "Invalid Stream Identifier" ERROR chunk. */
+	__u8 has_inv_strm_error;
+
 	/* This packet contains a SACK chunk. */
 	__u8 has_sack;
 
diff --git a/net/sctp/output.c b/net/sctp/output.c
index dd82755..a66451f 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -80,6 +80,7 @@ struct sctp_packet *sctp_packet_config(struct sctp_packet *packet,
 
 	packet->vtag = vtag;
 	packet->has_cookie_echo = 0;
+	packet->has_inv_strm_error = 0;
 	packet->has_sack = 0;
 	packet->has_auth = 0;
 	packet->has_data = 0;
@@ -125,6 +126,7 @@ struct sctp_packet *sctp_packet_init(struct sctp_packet *packet,
 	packet->size = overhead;
 	packet->vtag = 0;
 	packet->has_cookie_echo = 0;
+	packet->has_inv_strm_error = 0;
 	packet->has_sack = 0;
 	packet->has_auth = 0;
 	packet->has_data = 0;
@@ -263,6 +265,7 @@ sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *packet,
 				     struct sctp_chunk *chunk)
 {
 	sctp_xmit_t retval = SCTP_XMIT_OK;
+	struct sctp_chunk *lchunk;
 	__u16 chunk_len = WORD_ROUND(ntohs(chunk->chunk_hdr->length));
 	size_t psize;
 	size_t pmtu;
@@ -339,7 +342,31 @@ append:
 		packet->has_cookie_echo = 1;
 		break;
 
+	    case SCTP_CID_ERROR:
+		if (chunk->subh.err_hdr->cause & SCTP_ERROR_INV_STRM)
+			packet->has_inv_strm_error = 1;
+		break;
+
 	    case SCTP_CID_SACK:
+		/* RFC 4960
+		 * 6.5 Stream Identifier and Stream Sequence Number
+		 * The endpoint may bundle the ERROR chunk in the same
+		 * packet as the SACK as long as the ERROR follows the SACK.
+		 */
+		if (packet->has_inv_strm_error) {
+			if (list_is_singular(&packet->chunk_list))
+				list_add(&chunk->list, &packet->chunk_list);
+			else {
+				lchunk = list_first_entry(&packet->chunk_list,
+						struct sctp_chunk, list);
+				list_add(&chunk->list, &lchunk->list);
+			}
+			packet->size += chunk_len;
+			chunk->transport = packet->transport;
+			packet->has_sack = 1;
+			goto finish;
+		}
+
 		packet->has_sack = 1;
 		break;
 
-- 
1.7.0.4

