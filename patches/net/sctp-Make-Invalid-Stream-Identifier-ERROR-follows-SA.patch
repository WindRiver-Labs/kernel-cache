From 1d96e438f20bf0b899c349e8f75ad31cbfa610a9 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 23 Mar 2012 14:18:08 +0800
Subject: [PATCH] sctp: Make "Invalid Stream Identifier" ERROR follows SACK when bundling

When "Invalid Stream Identifier" ERROR happens after process the
received DATA chunks, this ERROR chunk is enqueued into outqueue
before SACK chunk, so when bundling ERROR chunk with SACK chunk,
the ERROR chunk is always placed first in the packet because of
the chunk's position in the outqueue.
This violates sctp specification:
    RFC 4960 6.5. Stream Identifier and Stream Sequence Number
    ...The endpoint may bundle the ERROR chunk in the same
    packet as the SACK as long as the ERROR follows the SACK.
So we must place SACK first when bundling "Invalid Stream Identifier"
ERROR and SACK in one packet.
Although we can do that by enqueue SACK chunk into outqueue before
ERROR chunk, it will violate the side-effect interpreter processing.
It's easy to do this job when dequeue chunks from the outqueue,
by this way, we introduce a flag 'has_inv_strm_error' which indicate
whether or not the "Invalid Stream Identifier" ERROR happens.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 include/net/sctp/structs.h |    1 +
 net/sctp/output.c          |   26 ++++++++++++++++++++++++++
 2 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a95b362..cf19d5d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -837,6 +837,7 @@ struct sctp_packet {
 	    has_sack:1,		/* This packet contains a SACK chunk. */
 	    has_auth:1,		/* This packet contains an AUTH chunk */
 	    has_data:1,		/* This packet contains at least 1 DATA chunk */
+	    has_inv_strm_error:1, /* This packet contains a "Invalid Stream Identifier" ERROR chunk */
 	    ipfragok:1,		/* So let ip fragment this packet */
 	    malloced:1;		/* Is it malloced? */
 };
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 07f6a05..962caca 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -77,6 +77,7 @@ static void sctp_packet_reset(struct sctp_packet *packet)
 	packet->has_sack = 0;
 	packet->has_data = 0;
 	packet->has_auth = 0;
+	packet->has_inv_strm_error = 0;
 	packet->ipfragok = 0;
 	packet->auth = NULL;
 }
@@ -266,6 +267,7 @@ sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *packet,
 				     struct sctp_chunk *chunk)
 {
 	sctp_xmit_t retval = SCTP_XMIT_OK;
+	struct sctp_chunk *lchunk;
 	__u16 chunk_len = WORD_ROUND(ntohs(chunk->chunk_hdr->length));
 
 	SCTP_DEBUG_PRINTK("%s: packet:%p chunk:%p\n", __func__, packet,
@@ -314,7 +316,31 @@ sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *packet,
 		packet->has_cookie_echo = 1;
 		break;
 
+	    case SCTP_CID_ERROR:
+		if (chunk->subh.err_hdr->cause & SCTP_ERROR_INV_STRM)
+			packet->has_inv_strm_error = 1;
+		break;
+
 	    case SCTP_CID_SACK:
+		/* RFC 4960
+		 * 6.5 Stream Identifier and Stream Sequence Number
+		 * The endpoint may bundle the ERROR chunk in the same
+		 * packet as the SACK as long as the ERROR follows the SACK.
+		 */
+		if (packet->has_inv_strm_error) {
+			if (list_is_singular(&packet->chunk_list))
+				list_add(&chunk->list, &packet->chunk_list);
+			else {
+				lchunk = list_first_entry(&packet->chunk_list,
+						struct sctp_chunk, list);
+				list_add(&chunk->list, &lchunk->list);
+			}
+			packet->size += chunk_len;
+			chunk->transport = packet->transport;
+			packet->has_sack = 1;
+			goto finish;
+		}
+
 		packet->has_sack = 1;
 		break;
 
-- 
1.7.0.4

