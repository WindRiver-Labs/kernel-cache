From d24815e1b6dea470814a4f4e440a3d78019fb6a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michal=20Kube=C4=8Dek?= <mkubecek@suse.cz>
Date: Fri, 2 Dec 2016 09:33:41 +0100
Subject: [PATCH] tipc: check minimum bearer MTU
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 3de81b758853f0b29c61e246679d20b513c4cfec upstream

Qian Zhang (张谦) reported a potential socket buffer overflow in
tipc_msg_build() which is also known as CVE-2016-8632: due to
insufficient checks, a buffer overflow can occur if MTU is too short for
even tipc headers. As anyone can set device MTU in a user/net namespace,
this issue can be abused by a regular user.

As agreed in the discussion on Ben Hutchings' original patch, we should
check the MTU at the moment a bearer is attached rather than for each
processed packet. We also need to repeat the check when bearer MTU is
adjusted to new device MTU.

Fixes: b97bf3fd8f6a ("[TIPC] Initial merge")
Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
Reported-by: Qian Zhang (张谦) <zhangqian-c@360.cn>
Acked-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[ cherry-pickd 3de81b758853f0b29c61e246679d20b513c4cfec upstream ]
Signed-off-by: Zhixiong Chi <zhixiong.chi@windriver.com>
---
 net/tipc/bearer.c |   13 ++++++++++++-
 net/tipc/bearer.h |   18 ++++++++++++++++++
 2 files changed, 30 insertions(+), 1 deletions(-)

diff --git a/net/tipc/bearer.c b/net/tipc/bearer.c
index 574b861..7ab4df3 100644
--- a/net/tipc/bearer.c
+++ b/net/tipc/bearer.c
@@ -444,6 +444,10 @@ int tipc_enable_l2_media(struct tipc_bearer *b)
 	dev = dev_get_by_name(&init_net, driver_name);
 	if (!dev)
 		return -ENODEV;
+	if (tipc_mtu_bad(dev, 0)) {
+		dev_put(dev);
+		return -EINVAL;
+	}
 
 	/* Associate TIPC bearer with Ethernet bearer */
 	b->media_ptr = dev;
@@ -583,8 +587,15 @@ static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,
 	case NETDEV_CHANGE:
 		if (netif_carrier_ok(dev))
 			break;
-	case NETDEV_DOWN:
 	case NETDEV_CHANGEMTU:
+		if (tipc_mtu_bad(dev, 0)) {
+			bearer_disable(b_ptr);
+			break;
+		}
+		b_ptr->mtu = dev->mtu;
+		tipc_reset_bearer(b_ptr);
+		break;
+	case NETDEV_DOWN:
 	case NETDEV_CHANGEADDR:
 		tipc_reset_bearer(b_ptr);
 		break;
diff --git a/net/tipc/bearer.h b/net/tipc/bearer.h
index 4f5db9a..eab0afd 100644
--- a/net/tipc/bearer.h
+++ b/net/tipc/bearer.h
@@ -58,6 +58,16 @@
 #define TIPC_MEDIA_TYPE_ETH	1
 #define TIPC_MEDIA_TYPE_IB	2
 
+/*
+ * Message header sizes
+ */
+#define INT_H_SIZE                40	/* Internal messages */
+#define MIN_H_SIZE                24	/* Smallest legal TIPC header size */
+#define MAX_H_SIZE                60	/* Largest possible TIPC header size */
+
+/* minimum bearer MTU */
+#define TIPC_MIN_BEARER_MTU    (MAX_H_SIZE + INT_H_SIZE)
+
 /**
  * struct tipc_media_addr - destination address used by TIPC bearers
  * @value: address info (format defined by media)
@@ -195,5 +205,13 @@ void tipc_bearer_cleanup(void);
 void tipc_bearer_stop(void);
 void tipc_bearer_send(struct tipc_bearer *b, struct sk_buff *buf,
 		      struct tipc_media_addr *dest);
+/* check if device MTU is too low for tipc headers */
+static inline bool tipc_mtu_bad(struct net_device *dev, unsigned int reserve)
+{
+	if (dev->mtu >= TIPC_MIN_BEARER_MTU + reserve)
+		return false;
+	netdev_warn(dev, "MTU too low for tipc bearer\n");
+	return true;
+}
 
 #endif	/* _TIPC_BEARER_H */
-- 
1.7.5.4

