From ac62bbbd1f7c0d1c55f8db0d86a558fceaab074b Mon Sep 17 00:00:00 2001
From: "David S. Miller" <davem@davemloft.net>
Date: Tue, 19 Apr 2016 19:49:29 -0400
Subject: [PATCH 204/376] net: Add helpers for 64-bit aligning netlink
 attributes.

commit 35c5845957c7982dac1f525ff3412f8acf0a0385 upstream

Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Suggested-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 include/net/netlink.h |   37 +++++++++++++++++++++++++++++++++++++
 net/core/rtnetlink.c  |   26 ++++++--------------------
 2 files changed, 43 insertions(+), 20 deletions(-)

diff --git a/include/net/netlink.h b/include/net/netlink.h
index 6ab65d1..e854068 100644
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -1226,6 +1226,43 @@ static inline int nla_validate_nested(const struct nlattr *start, int maxtype,
 }
 
 /**
+ * nla_align_64bit - 64-bit align the nla_data() of next attribute
+ * @skb: socket buffer the message is stored in
+ * @padattr: attribute type for the padding
+ *
+ * Conditionally emit a padding netlink attribute in order to make
+ * the next attribute we emit have a 64-bit aligned nla_data() area.
+ * This will only be done in architectures which do not have
+ * HAVE_EFFICIENT_UNALIGNED_ACCESS defined.
+ *
+ * Returns zero on success or a negative error code.
+ */
+static inline int nla_align_64bit(struct sk_buff *skb, int padattr)
+{
+#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
+	if (IS_ALIGNED((unsigned long)skb->data, 8)) {
+		struct nlattr *attr = nla_reserve(skb, padattr, 0);
+		if (!attr)
+			return -EMSGSIZE;
+	}
+#endif
+	return 0;
+}
+
+/**
+ * nla_total_size_64bit - total length of attribute including padding
+ * @payload: length of payload
+ */
+static inline int nla_total_size_64bit(int payload)
+{
+	return NLA_ALIGN(nla_attr_size(payload))
+#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
+		+ NLA_ALIGN(nla_attr_size(0))
+#endif
+		;
+}
+
+/**
  * nla_for_each_attr - iterate over a stream of attributes
  * @pos: loop counter, set to current attribute
  * @head: head of attribute stream
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 96227bc..a22c27c8 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -874,10 +874,7 @@ static noinline size_t if_nlmsg_size(const struct net_device *dev,
 	       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */
 	       + nla_total_size(sizeof(struct rtnl_link_ifmap))
 	       + nla_total_size(sizeof(struct rtnl_link_stats))
-#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
-	       + nla_total_size(0) /* IFLA_PAD */
-#endif
-	       + nla_total_size(sizeof(struct rtnl_link_stats64))
+	       + nla_total_size_64bit(sizeof(struct rtnl_link_stats64))
 	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
 	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */
 	       + nla_total_size(4) /* IFLA_TXQLEN */
@@ -1041,23 +1038,12 @@ static noinline_for_stack int rtnl_fill_stats(struct sk_buff *skb,
 	const struct rtnl_link_stats64 *stats;
 	struct rtnl_link_stats64 temp;
 	struct nlattr *attr;
+	int err;
 
-#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
-	/* IF necessary, add a zero length NOP attribute so that the
-	 * nla_data() of the IFLA_STATS64 will be 64-bit aligned.
-	 *
-	 * The nlattr header is 4 bytes in size, that's why we test
-	 * if the skb->data _is_ aligned.  This NOP attribute, plus
-	 * nlattr header for IFLA_STATS64, will make nla_data() 8-byte
-	 * aligned.
-	 */
-	if (IS_ALIGNED((unsigned long)skb->data, 8)) {
-		attr = nla_reserve(skb, IFLA_PAD, 0);
-		if (!attr)
-			return -EMSGSIZE;
-	}
-#endif
-
+	err = nla_align_64bit(skb, IFLA_PAD);
+	if (err)
+		return err;
+ 
 	stats = dev_get_stats(dev, &temp);
 
 	attr = nla_reserve(skb, IFLA_STATS,
-- 
1.7.5.4

