From 57cb42e18d97dec630a67a3919a0de85dd3b38e4 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Mon, 5 Oct 2009 09:13:56 -0400
Subject: [PATCH] sctp: add parameter to enable/disable ECN

SCTP always sends the TLV for ECN in all init chunks, so if
both sides support ECN, SCTP will then set the ECN bits in
the IP header.  If the packets are being routed through a
middlebox that drops packets that have the ECN bits set in
the IP header, SCTP packets with the ECN bits set will be
dropped, and the connection will fail.

To work around situations like this, a new sysctl option is
added: /proc/sys/net/sctp/ecn_enable.  By default it is '1'
meaning all new associations will attempt to negotiate the use
of ECN.  If it is set to '0', new associations will not include
the ECN TLV in init chunks, and it will ignore the ECN TLV if received
in an init chunk.  Changing the state of this option will only
effect new associations, existing associations are unaffected.

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 include/linux/sysctl.h     |    1 +
 include/net/sctp/structs.h |    6 +++++-
 net/sctp/output.c          |    3 ++-
 net/sctp/protocol.c        |    3 +++
 net/sctp/sm_make_chunk.c   |    9 ++++++---
 net/sctp/sysctl.c          |    9 +++++++++
 6 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index d0437f3..40f921e 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -778,6 +778,7 @@ enum {
 	NET_SCTP_SNDBUF_POLICY		 = 15,
 	NET_SCTP_SACK_TIMEOUT		 = 16,
 	NET_SCTP_RCVBUF_POLICY		 = 17,
+	NET_SCTP_ECN_ENABLE		 = 18,
 };
 
 /* /proc/sys/net/bridge */
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bf57e1b..86de4cc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -216,8 +216,11 @@ extern struct sctp_globals {
 	/* Flag to indicate if PR-SCTP is enabled. */
 	int prsctp_enable;
 
-	/* Flag to idicate if SCTP-AUTH is enabled */
+	/* Flag to indicate if SCTP-AUTH is enabled */
 	int auth_enable;
+
+	/* Flag to indicate if ECN is enabled for new connections */
+	int ecn_enable;
 } sctp_globals;
 
 #define sctp_rto_initial		(sctp_globals.rto_initial)
@@ -252,6 +255,7 @@ extern struct sctp_globals {
 #define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 #define sctp_auth_enable		(sctp_globals.auth_enable)
+#define sctp_ecn_enable			(sctp_globals.ecn_enable)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {
diff --git a/net/sctp/output.c b/net/sctp/output.c
index e4746fd..5fce06b 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -554,7 +554,8 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 	 * Note: The works for IPv6 layer checks this bit too later
 	 * in transmission.  See IP6_ECN_flow_xmit().
 	 */
-	(*tp->af_specific->ecn_capable)(nskb->sk);
+	if (!asoc ? sctp_ecn_enable : asoc->peer.ecn_capable)
+		(*tp->af_specific->ecn_capable)(nskb->sk);
 
 	/* Set up the IP options.  */
 	/* BUG: not implemented
diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c
index 0b65354..a2a42c4 100644
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@ -1279,6 +1279,9 @@ SCTP_STATIC __init int sctp_init(void)
 	/* Disable AUTH by default. */
 	sctp_auth_enable = 0;
 
+	/* Enable ECN by default. */
+	sctp_ecn_enable = 1;
+
 	sctp_sysctl_register();
 
 	INIT_LIST_HEAD(&sctp_address_families);
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index e5b02c6..e2c1801 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -208,7 +208,8 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 	num_types = sp->pf->supported_addrs(sp, types);
 
 	chunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);
-	chunksize += sizeof(ecap_param);
+	if (sctp_ecn_enable)
+		chunksize += sizeof(ecap_param);
 
 	if (sctp_prsctp_enable)
 		chunksize += sizeof(prsctp_param);
@@ -289,7 +290,8 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 	sctp_addto_chunk(retval, sizeof(sat), &sat);
 	sctp_addto_chunk(retval, num_types * sizeof(__u16), &types);
 
-	sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
+	if (sctp_ecn_enable)
+		sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
 
 	/* Add the supported extensions parameter.  Be nice and add this
 	 * fist before addiding the parameters for the extensions themselves
@@ -2472,7 +2474,8 @@ do_addr_param:
 		break;
 
 	case SCTP_PARAM_ECN_CAPABLE:
-		asoc->peer.ecn_capable = 1;
+		if (sctp_ecn_enable)
+			asoc->peer.ecn_capable = 1;
 		break;
 
 	case SCTP_PARAM_ADAPTATION_LAYER_IND:
diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c
index 5291069..df96191 100644
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@ -272,6 +272,15 @@ static ctl_table sctp_table[] = {
 		.proc_handler	= &proc_dointvec,
 		.strategy	= &sysctl_intvec
 	},
+	{
+		.ctl_name	= NET_SCTP_ECN_ENABLE,
+		.procname	= "ecn_enable",
+		.data		= &sctp_ecn_enable,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+		.strategy	= &sysctl_intvec
+	},
 	{ .ctl_name = 0 }
 };
 
-- 
1.6.3.3

