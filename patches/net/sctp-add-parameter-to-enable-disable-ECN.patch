From 4dd0d3970599aad3c2366dbe5237598eb82d3291 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Mon, 5 Oct 2009 09:13:56 -0400
Subject: [PATCH] sctp: add parameter to enable/disable ECN

SCTP always sends the TLV for ECN in all init chunks, so if
both sides support ECN, SCTP will then set the ECN bits in
the IP header.  If the packets are being routed through a
middlebox that drops packets that have the ECN bits set in
the IP header, SCTP packets with the ECN bits set will be
dropped, and the connection will fail.

To work around situations like this, a new sysctl option is
added: /proc/sys/net/sctp/ecn_enable.  By default it is '1'
meaning all new associations will attempt to negotiate the use
of ECN.  If it is set to '0', new associations will not include
the ECN TLV in init chunks, and it will ignore the ECN TLV if received
in an init chunk.  Changing the state of this option will only
effect new associations, existing associations are unaffected.

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 include/linux/sysctl.h     |    1 +
 include/net/sctp/structs.h |    6 +++++-
 net/sctp/output.c          |    8 +++++++-
 net/sctp/protocol.c        |    3 +++
 net/sctp/sm_make_chunk.c   |    9 ++++++---
 net/sctp/sysctl.c          |    7 +++++++
 6 files changed, 29 insertions(+), 5 deletions(-)

diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index f66014c..321a4d6 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -767,6 +767,7 @@ enum {
 	NET_SCTP_SNDBUF_POLICY		 = 15,
 	NET_SCTP_SACK_TIMEOUT		 = 16,
 	NET_SCTP_RCVBUF_POLICY		 = 17,
+	NET_SCTP_ECN_ENABLE		 = 18,
 };
 
 /* /proc/sys/net/bridge */
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ff30177..e430c5c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -216,9 +216,12 @@ extern struct sctp_globals {
 	/* Flag to indicate if PR-SCTP is enabled. */
 	int prsctp_enable;
 
-	/* Flag to idicate if SCTP-AUTH is enabled */
+	/* Flag to indicate if SCTP-AUTH is enabled */
 	int auth_enable;
 
+	/* Flag to indicate if ECN is enabled for new connections */
+	int ecn_enable;
+
 	/*
 	 * Policy to control SCTP IPv4 address scoping
 	 * 0   - Disable IPv4 address scoping
@@ -271,6 +274,7 @@ extern struct sctp_globals {
 #define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 #define sctp_auth_enable		(sctp_globals.auth_enable)
+#define sctp_ecn_enable 		(sctp_globals.ecn_enable)
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
 #define sctp_rwnd_upd_shift		(sctp_globals.rwnd_update_shift)
 
diff --git a/net/sctp/output.c b/net/sctp/output.c
index fad261d..6d5bea7 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -348,6 +348,7 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 	struct sock *sk;
 	int err = 0;
 	int padding;		/* How much padding do we need?  */
+	int use_ecn;
 	__u8 has_data = 0;
 	struct dst_entry *dst = tp->dst;
 	unsigned char *auth = NULL;	/* pointer to auth in skb data */
@@ -538,7 +539,12 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 	 * Note: The works for IPv6 layer checks this bit too later
 	 * in transmission.  See IP6_ECN_flow_xmit().
 	 */
-	(*tp->af_specific->ecn_capable)(nskb->sk);
+	if (asoc)
+		use_ecn = asoc->peer.ecn_capable;
+	else
+		use_ecn = sctp_ecn_enable;
+	if (use_ecn)
+		(*tp->af_specific->ecn_capable)(nskb->sk);
 
 	/* Set up the IP options.  */
 	/* BUG: not implemented
diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c
index a56f98e..a1e94d6 100644
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@ -1262,6 +1262,9 @@ SCTP_STATIC __init int sctp_init(void)
 	/* Set the default rwnd update threshold */
 	sctp_rwnd_upd_shift		= SCTP_DEFAULT_RWND_SHIFT;
 
+	/* Enable ECN by default. */
+	sctp_ecn_enable = 1;
+
 	sctp_sysctl_register();
 
 	INIT_LIST_HEAD(&sctp_address_families);
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 0fd5b4c..03001ec 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -210,7 +210,8 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 
 	chunksize = sizeof(init) + addrs_len;
 	chunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));
-	chunksize += sizeof(ecap_param);
+	if (sctp_ecn_enable)
+		chunksize += sizeof(ecap_param);
 
 	if (sctp_prsctp_enable)
 		chunksize += sizeof(prsctp_param);
@@ -292,7 +293,8 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 	sctp_addto_chunk(retval, sizeof(sat), &sat);
 	sctp_addto_chunk(retval, num_types * sizeof(__u16), &types);
 
-	sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
+	if (sctp_ecn_enable)
+		sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
 
 	/* Add the supported extensions parameter.  Be nice and add this
 	 * fist before addiding the parameters for the extensions themselves
@@ -2484,7 +2486,8 @@ do_addr_param:
 		break;
 
 	case SCTP_PARAM_ECN_CAPABLE:
-		asoc->peer.ecn_capable = 1;
+		if (sctp_ecn_enable)
+			asoc->peer.ecn_capable = 1;
 		break;
 
 	case SCTP_PARAM_ADAPTATION_LAYER_IND:
diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c
index 832590b..502bd62 100644
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@ -251,6 +251,13 @@ static ctl_table sctp_table[] = {
 		.extra1		= &one,
 		.extra2		= &rwnd_scale_max,
 	},
+	{
+		.procname	= "ecn_enable",
+		.data		= &sctp_ecn_enable,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 
 	{ /* sentinel */ }
 };
-- 
1.7.0

