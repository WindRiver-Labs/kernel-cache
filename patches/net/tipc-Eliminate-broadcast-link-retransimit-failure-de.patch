From 616440a704d0329b679968bf4b9d40978047e82e Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 30 May 2014 10:55:01 +0800
Subject: [PATCH 1/3] tipc: Eliminate broadcast link retransimit failure
 deadlock problem

Prevents deadlock from occurring during broadcast link retransmit
failure recovery. The problem arises if the thread handling the
broadcast link retransmit request takes the broadcast link lock
at the start of processing and then takes the node lock for the
requesting node once retransmission failure is declared; if another
thread simultaneously attempts to acknowledge receipt of broadcast
messages from that node -- meaning it first takes the node lock for
the node and then takes the broadcast link lock -- deadlock occurs.

Deadlock path:
CPU 1: tipc_recv_msg()->tipc_bclink_recv_pkt()->spin_lock_bh(&bc_lock)
       ->bclink_retransmit_pkt()->tipc_link_retransmit()->link_retransmit_failure()
       -> tipc_node_lock(n_ptr)
CPU 2: tipc_recv_msg()->tipc_node_lock(n_ptr)->tipc_bclink_acknowledge()
       -> spin_lock_bh(&bc_lock)

Deadlock is now prevented by relocating the code that prints out
state information about the retransmit failure to a different thread
of control that already takes the node lock safely; this eliminates
the need for the first thread to take the node lock.

Signed-off-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 net/tipc/link.c | 23 +++++++++--------------
 1 file changed, 9 insertions(+), 14 deletions(-)

diff --git a/net/tipc/link.c b/net/tipc/link.c
index da6018b..af58202 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -1255,6 +1255,15 @@ static void link_reset_all(unsigned long addr)
 
 	tipc_node_lock(n_ptr);
 
+	pr_info("Broadcast link info for %s\n", addr_string);
+	pr_info("Reception permitted: %d,  Acked: %u\n",
+		n_ptr->bclink.recv_permitted,
+		n_ptr->bclink.acked);
+	pr_info("Last in: %u,  Oos state: %u,  Last sent: %u\n",
+		n_ptr->bclink.last_in,
+		n_ptr->bclink.oos_state,
+		n_ptr->bclink.last_sent);
+
 	pr_warn("Resetting all links to %s\n",
 		tipc_addr_string_fill(addr_string, n_ptr->addr));
 
@@ -1284,29 +1293,15 @@ static void link_retransmit_failure(struct tipc_link *l_ptr,
 	} else {
 		/* Handle failure on broadcast link */
 		struct tipc_node *n_ptr;
-		char addr_string[16];
 
 		pr_info("Msg seq number: %u,  ", msg_seqno(msg));
 		pr_cont("Outstanding acks: %lu\n",
 			(unsigned long) TIPC_SKB_CB(buf)->handle);
 
 		n_ptr = tipc_bclink_retransmit_to();
-		tipc_node_lock(n_ptr);
-
-		tipc_addr_string_fill(addr_string, n_ptr->addr);
-		pr_info("Broadcast link info for %s\n", addr_string);
-		pr_info("Reception permitted: %d,  Acked: %u\n",
-			n_ptr->bclink.recv_permitted,
-			n_ptr->bclink.acked);
-		pr_info("Last in: %u,  Oos state: %u,  Last sent: %u\n",
-			n_ptr->bclink.last_in,
-			n_ptr->bclink.oos_state,
-			n_ptr->bclink.last_sent);
 
 		tipc_k_signal((Handler)link_reset_all, (unsigned long)n_ptr->addr);
 
-		tipc_node_unlock(n_ptr);
-
 		l_ptr->stale_count = 0;
 	}
 }
-- 
2.0.2

