From 77dbd6b06ac16103cb43868fee0e84fab4a81c27 Mon Sep 17 00:00:00 2001
From: Jon Paul Maloy <jon.maloy@ericsson.com>
Date: Thu, 22 Oct 2015 08:51:40 -0400
Subject: [PATCH 103/376] tipc: introduce capability bit for broadcast
 synchronization

commit fd556f209af53b9cdc45df8c467feb235376c4df upstream

Until now, we have tried to support both the newer, dedicated broadcast
synchronization mechanism along with the older, less safe, RESET_MSG/
ACTIVATE_MSG based one. The latter method has turned out to be a hazard
in a highly dynamic cluster, so we find it safer to disable it completely
when we find that the former mechanism is supported by the peer node.

For this purpose, we now introduce a new capabability bit,
TIPC_BCAST_SYNCH, to inform any peer nodes that dedicated broadcast
syncronization is supported by the present node. The new bit is conveyed
between peers in the 'capabilities' field of neighbor discovery messages.

Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
Reviewed-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 net/tipc/bcast.c    |    1 +
 net/tipc/discover.c |    2 +-
 net/tipc/link.c     |    7 +++++--
 net/tipc/link.h     |    6 ++++--
 net/tipc/node.c     |    6 ++++--
 net/tipc/node.h     |    8 ++++++++
 6 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/net/tipc/bcast.c b/net/tipc/bcast.c
index 08d64e7..7fdf895 100644
--- a/net/tipc/bcast.c
+++ b/net/tipc/bcast.c
@@ -1045,6 +1045,7 @@ int tipc_bcast_init(struct net *net)
 	if (!tipc_link_bc_create(&bb->node,
 				 MAX_PKT_DEFAULT_MCAST,
 				 BCLINK_WIN_DEFAULT,
+				 0,
 				 &bb->inputq,
 				 &bb->namedq,
 				 &l))
diff --git a/net/tipc/discover.c b/net/tipc/discover.c
index d14e0a4..6cd36f9 100644
--- a/net/tipc/discover.c
+++ b/net/tipc/discover.c
@@ -89,7 +89,7 @@ static void tipc_disc_init_msg(struct net *net, struct sk_buff *buf, u32 type,
 		      MAX_H_SIZE, dest_domain);
 	msg_set_non_seq(msg, 1);
 	msg_set_node_sig(msg, tn->random);
-	msg_set_node_capabilities(msg, 0);
+	msg_set_node_capabilities(msg, TIPC_NODE_CAPABILITIES);
 	msg_set_dest_domain(msg, dest_domain);
 	msg_set_bc_netid(msg, tn->net_id);
 	b_ptr->media->addr2msg(msg_media_addr(msg), &b_ptr->addr);
diff --git a/net/tipc/link.c b/net/tipc/link.c
index 363da5f..6a1a9d9 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -191,6 +191,7 @@ static u32 link_own_addr(struct tipc_link *l)
  * @session: session to be used by link
  * @ownnode: identity of own node
  * @peer: node id of peer node
+ * @peer_caps: bitmap describing peer node capabilities
  * @maddr: media address to be used
  * @inputq: queue to put messages ready for delivery
  * @namedq: queue to put binding table update messages ready for delivery
@@ -201,7 +202,7 @@ static u32 link_own_addr(struct tipc_link *l)
 bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
-		      struct tipc_media_addr *maddr,
+		      u16 peer_caps, struct tipc_media_addr *maddr,
 		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
 		      struct tipc_link **link)
 {
@@ -226,6 +227,7 @@ bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 	strcpy((char *)msg_data(hdr), if_name);
 
 	l->addr = peer;
+	l->peer_caps = peer_caps;
 	l->media_addr = maddr;
 	l->owner = n;
 	l->peer_session = WILDCARD_SESSION;
@@ -260,6 +262,7 @@ bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
  * Returns true if link was created, otherwise false
  */
 bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
+			 u16 peer_caps,
 			 struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link **link)
@@ -267,7 +270,7 @@ bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
 	struct tipc_link *l;
 
 	if (!tipc_link_create(n, "", MAX_BEARERS, 0, 'Z', mtu, 0, window,
-			      0, 0, 0, NULL, inputq, namedq, link))
+			      0, 0, 0, peer_caps, NULL, inputq, namedq, link))
 		return false;
 
 	l = *link;
diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9c4acc2..d23329d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -119,6 +119,7 @@ struct tipc_stats {
  * @keepalive_intv: link keepalive timer interval
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
+ * @peer_caps: bitmap describing capabilities of peer node
  * @silent_intv_cnt: # of timer intervals without any reception from peer
  * @proto_msg: template for control messages generated by link
  * @pmsg: convenience pointer to "proto_msg" field
@@ -162,6 +163,7 @@ struct tipc_link {
 	unsigned long keepalive_intv;
 	u32 abort_limit;
 	u32 state;
+	u16 peer_caps;
 	u32 silent_intv_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
@@ -215,11 +217,11 @@ struct tipc_link {
 bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
-		      struct tipc_media_addr *maddr,
+		      u16 peer_caps, struct tipc_media_addr *maddr,
 		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
 		      struct tipc_link **link);
 bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
-			 struct sk_buff_head *inputq,
+			 u16 peer_caps, struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
diff --git a/net/tipc/node.c b/net/tipc/node.c
index d3f7ca2..28bcd7b 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -584,8 +584,10 @@ void tipc_node_check_dest(struct net *net, u32 onode,
 		if (!tipc_link_create(n, if_name, b->identity, b->tolerance,
 				      b->net_plane, b->mtu, b->priority,
 				      b->window, mod(tipc_net(net)->random),
-				      tipc_own_addr(net), onode, &le->maddr,
-				      &le->inputq, &n->bclink.namedq, &l)) {
+				      tipc_own_addr(net), onode,
+				      n->capabilities,
+				      &le->maddr, &le->inputq,
+				      &n->bclink.namedq, &l)) {
 			*respond = false;
 			goto exit;
 		}
diff --git a/net/tipc/node.h b/net/tipc/node.h
index 344b3e7..1465774 100644
--- a/net/tipc/node.h
+++ b/net/tipc/node.h
@@ -62,6 +62,14 @@ enum {
 	TIPC_BCAST_RESET		= (1 << 10)
 };
 
+/* Optional capabilities supported by this code version
+ */
+enum {
+	TIPC_BCAST_SYNCH = (1 << 1)
+};
+
+#define TIPC_NODE_CAPABILITIES TIPC_BCAST_SYNCH
+
 /**
  * struct tipc_node_bclink - TIPC node bclink structure
  * @acked: sequence # of last outbound b'cast message acknowledged by node
-- 
1.7.5.4

