From 98d93e691e43e364b86a43d103f065e30d5ed4cc Mon Sep 17 00:00:00 2001
From: Zibo Zhao <Zibo.Zhao@windriver.com>
Date: Mon, 16 Jun 2014 14:35:11 -0400
Subject: [PATCH] Backport openvswitch 2.0 kernel module into wrl5 3.4 kernel

We have previously imported the datapath kernel module from OVS 2.0
in commit "Import initial datapath code from openvswitch 2.0.0"

This commit changes the import commit to build in the Wind River Linux
kernel environment.

The kernel module now supports both GRE tunnels and megaflow.

Signed-off-by: Zibo Zhao <Zibo.Zhao@windriver.com>

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 069c8eeff99a..9199aa8bf567 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -136,4 +136,5 @@ source "drivers/staging/ozwpan/Kconfig"
 
 source "drivers/staging/netmap/Kconfig"
 
+source "drivers/staging/openvswitch_nv/Kconfig"
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index e8943cabecd0..e0f3121d36fe 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_PHONE)		+= telephony/
 obj-$(CONFIG_RAMSTER)		+= ramster/
 obj-$(CONFIG_USB_WPAN_HCD)	+= ozwpan/
 obj-$(CONFIG_NETMAP)		+= netmap/
+obj-$(CONFIG_OPENVSWITCH_NV)	+= openvswitch_nv/
diff --git a/drivers/staging/openvswitch_nv/Kconfig b/drivers/staging/openvswitch_nv/Kconfig
new file mode 100644
index 000000000000..291cde33241f
--- /dev/null
+++ b/drivers/staging/openvswitch_nv/Kconfig
@@ -0,0 +1,32 @@
+#
+# Open vSwitch
+#
+
+config OPENVSWITCH_NV
+	tristate "Open vSwitch (2.0.0)"
+	depends on OPENVSWITCH=n && BRIDGE=m && EXPERIMENTAL && STAGING
+	---help---
+	  Open vSwitch is a multilayer Ethernet switch targeted at virtualized
+	  environments.  In addition to supporting a variety of features
+	  expected in a traditional hardware switch, it enables fine-grained
+	  programmatic extension and flow-based control of the network.  This
+	  control is useful in a wide variety of applications but is
+	  particularly important in multi-server virtualization deployments,
+	  which are often characterized by highly dynamic endpoints and the
+	  need to maintain logical abstractions for multiple tenants.
+
+	  The Open vSwitch datapath provides an in-kernel fast path for packet
+	  forwarding.  It is complemented by a userspace daemon, ovs-vswitchd,
+	  which is able to accept configuration from a variety of sources and
+	  translate it into packet processing rules.
+
+	  See http://openvswitch.org for more information and userspace
+	  utilities.
+
+	  This enables the latest Open vSwitch code taken from the out of tree
+	  kernel module.
+
+	  To compile this code as a module, choose M here: the module will be
+	  called openvswitch.
+
+	  If unsure, say N.
diff --git a/drivers/staging/openvswitch_nv/Makefile b/drivers/staging/openvswitch_nv/Makefile
new file mode 100644
index 000000000000..247e61d052cb
--- /dev/null
+++ b/drivers/staging/openvswitch_nv/Makefile
@@ -0,0 +1,26 @@
+#
+# Makefile for Open vSwitch (newer version)
+#
+
+obj-$(CONFIG_OPENVSWITCH_NV) += openvswitch.o
+
+EXTRA_CFLAGS += -I$(PWD)/drivers/staging/openvswitch_nv/linux/compat/ -I$(PWD)/drivers/staging/openvswitch_nv/linux/compat/include/linux/ -I$(PWD)/drivers/staging/openvswitch_nv/linux/compat/include/net/
+
+openvswitch-y := \
+	actions.o \
+	datapath.o \
+	dp_notify.o \
+	flow.o \
+	vport.o \
+	vport-gre.o \
+	vport-internal_dev.o \
+	vport-lisp.o \
+	vport-netdev.o \
+	vport-vxlan.o \
+	linux/compat/gso.o \
+	linux/compat/vxlan.o \
+	linux/compat/ip_tunnels_core.o \
+	linux/compat/gre.o \
+	linux/compat/workqueue.o
+
+
diff --git a/drivers/staging/openvswitch_nv/actions.c b/drivers/staging/openvswitch_nv/actions.c
index 30ea1d23e9c2..1f08c4aec3dd 100644
--- a/drivers/staging/openvswitch_nv/actions.c
+++ b/drivers/staging/openvswitch_nv/actions.c
@@ -21,7 +21,7 @@
 #include <linux/skbuff.h>
 #include <linux/in.h>
 #include <linux/ip.h>
-#include <linux/openvswitch.h>
+#include <linux/openvswitch-nv.h>
 #include <linux/sctp.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
@@ -38,6 +38,131 @@
 #include "vlan.h"
 #include "vport.h"
 
+
+/*
+ * find the offset to specified header or the protocol number of last header
+ * if target < 0. "last header" is transport protocol header, ESP, or
+ * "No next header".
+ *
+ * Note that *offset is used as input/output parameter. an if it is not zero,
+ * then it must be a valid offset to an inner IPv6 header. This can be used
+ * to explore inner IPv6 header, eg. ICMPv6 error messages.
+ *
+ * If target header is found, its offset is set in *offset and return protocol
+ * number. Otherwise, return -1.
+ *
+ * If the first fragment doesn't contain the final protocol header or
+ * NEXTHDR_NONE it is considered invalid.
+ *
+ * Note that non-1st fragment is special case that "the protocol number
+ * of last header" is "next header" field in Fragment header. In this case,
+ * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
+ * isn't NULL.
+ *
+ * if flags is not NULL and it's a fragment, then the frag flag
+ * OVS_IP6T_FH_F_FRAG will be set. If it's an AH header, the
+ * OVS_IP6T_FH_F_AUTH flag is set and target < 0, then this function will
+ * stop at the AH header. If OVS_IP6T_FH_F_SKIP_RH flag was passed, then this
+ * function will skip all those routing headers, where segements_left was 0.
+ */
+int ipv6_ovs_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+		  int target, unsigned short *fragoff, int *flags)
+{
+	unsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);
+	u8 nexthdr = ipv6_hdr(skb)->nexthdr;
+	unsigned int len;
+	bool found;
+
+	if (fragoff)
+		*fragoff = 0;
+
+	if (*offset) {
+		struct ipv6hdr _ip6, *ip6;
+
+		ip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);
+		if (!ip6 || (ip6->version != 6)) {
+			printk(KERN_ERR "IPv6 header not found\n");
+			return -EBADMSG;
+		}
+		start = *offset + sizeof(struct ipv6hdr);
+		nexthdr = ip6->nexthdr;
+	}
+	len = skb->len - start;
+
+	do {
+		struct ipv6_opt_hdr _hdr, *hp;
+		unsigned int hdrlen;
+		found = (nexthdr == target);
+
+		if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {
+			if (target < 0)
+				break;
+			return -ENOENT;
+		}
+
+		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
+		if (hp == NULL)
+			return -EBADMSG;
+
+		if (nexthdr == NEXTHDR_ROUTING) {
+			struct ipv6_rt_hdr _rh, *rh;
+
+			rh = skb_header_pointer(skb, start, sizeof(_rh),
+						&_rh);
+			if (rh == NULL)
+				return -EBADMSG;
+
+			if (flags && (*flags & OVS_IP6T_FH_F_SKIP_RH) &&
+			    rh->segments_left == 0)
+				found = false;
+		}
+
+		if (nexthdr == NEXTHDR_FRAGMENT) {
+			unsigned short _frag_off;
+			__be16 *fp;
+
+			if (flags)	/* Indicate that this is a fragment */
+				*flags |= OVS_IP6T_FH_F_FRAG;
+			fp = skb_header_pointer(skb,
+						start+offsetof(struct frag_hdr,
+							       frag_off),
+						sizeof(_frag_off),
+						&_frag_off);
+			if (fp == NULL)
+				return -EBADMSG;
+
+			_frag_off = ntohs(*fp) & ~0x7;
+			if (_frag_off) {
+				if (target < 0 &&
+				    ((!ipv6_ext_hdr(hp->nexthdr)) ||
+				     hp->nexthdr == NEXTHDR_NONE)) {
+					if (fragoff)
+						*fragoff = _frag_off;
+					return hp->nexthdr;
+				}
+				return -ENOENT;
+			}
+			hdrlen = 8;
+		} else if (nexthdr == NEXTHDR_AUTH) {
+			if (flags && (*flags & OVS_IP6T_FH_F_AUTH) &&
+			    (target < 0))
+				break;
+			hdrlen = (hp->hdrlen + 2) << 2;
+		} else
+			hdrlen = ipv6_optlen(hp);
+
+		if (!found) {
+			nexthdr = hp->nexthdr;
+			len -= hdrlen;
+			start += hdrlen;
+		}
+	} while (!found);
+
+	*offset = start;
+	return nexthdr;
+}
+
+
 static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,
 			      const struct nlattr *attr, int len, bool keep_skb);
 
@@ -166,7 +291,7 @@ static void set_ip_addr(struct sk_buff *skb, struct iphdr *nh,
 	}
 
 	csum_replace4(&nh->check, *addr, new_addr);
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 	*addr = new_addr;
 }
 
@@ -200,7 +325,7 @@ static void set_ipv6_addr(struct sk_buff *skb, u8 l4_proto,
 	if (recalculate_csum)
 		update_ipv6_checksum(skb, l4_proto, addr, new_addr);
 
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 	memcpy(addr, new_addr, sizeof(__be32[4]));
 }
 
@@ -276,7 +401,7 @@ static int set_ipv6(struct sk_buff *skb, const struct ovs_key_ipv6 *ipv6_key)
 		bool recalc_csum = true;
 
 		if (ipv6_ext_hdr(nh->nexthdr))
-			recalc_csum = ipv6_find_hdr(skb, &offset,
+			recalc_csum = ipv6_ovs_find_hdr(skb, &offset,
 						    NEXTHDR_ROUTING, NULL,
 						    &flags) != NEXTHDR_ROUTING;
 
@@ -297,7 +422,7 @@ static void set_tp_port(struct sk_buff *skb, __be16 *port,
 {
 	inet_proto_csum_replace2(check, skb, *port, new_port, 0);
 	*port = new_port;
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 }
 
 static void set_udp_port(struct sk_buff *skb, __be16 *port, __be16 new_port)
@@ -311,7 +436,7 @@ static void set_udp_port(struct sk_buff *skb, __be16 *port, __be16 new_port)
 			uh->check = CSUM_MANGLED_0;
 	} else {
 		*port = new_port;
-		skb_clear_rxhash(skb);
+		skb->rxhash = 0;
 	}
 }
 
@@ -382,7 +507,7 @@ static int set_sctp(struct sk_buff *skb,
 		/* Carry any checksum errors through. */
 		sh->checksum = old_csum ^ old_correct_csum ^ new_csum;
 
-		skb_clear_rxhash(skb);
+		skb->rxhash = 0;
 	}
 
 	return 0;
diff --git a/drivers/staging/openvswitch_nv/datapath.c b/drivers/staging/openvswitch_nv/datapath.c
index bb1e282d6439..927a3c2e93aa 100644
--- a/drivers/staging/openvswitch_nv/datapath.c
+++ b/drivers/staging/openvswitch_nv/datapath.c
@@ -36,7 +36,6 @@
 #include <linux/rcupdate.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
-#include <linux/version.h>
 #include <linux/ethtool.h>
 #include <linux/wait.h>
 #include <asm/div64.h>
@@ -45,7 +44,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/inetdevice.h>
 #include <linux/list.h>
-#include <linux/openvswitch.h>
+#include <linux/openvswitch-nv.h>
 #include <linux/rculist.h>
 #include <linux/dmi.h>
 #include <linux/genetlink.h>
@@ -59,6 +58,7 @@
 #include "vlan.h"
 #include "vport-internal_dev.h"
 #include "vport-netdev.h"
+#include "workqueue.h"
 
 #define REHASH_FLOW_INTERVAL (10 * 60 * HZ)
 static void rehash_flow_table(struct work_struct *work);
@@ -69,7 +69,7 @@ int ovs_net_id __read_mostly;
 static void ovs_notify(struct sk_buff *skb, struct genl_info *info,
 		       struct genl_multicast_group *grp)
 {
-	genl_notify(skb, genl_info_net(info), info->snd_portid,
+	genl_notify(skb, genl_info_net(info), info->snd_pid,
 		    grp->id, info->nlhdr, GFP_KERNEL);
 }
 
@@ -182,10 +182,11 @@ static struct hlist_head *vport_hash_bucket(const struct datapath *dp,
 struct vport *ovs_lookup_vport(const struct datapath *dp, u16 port_no)
 {
 	struct vport *vport;
+	struct hlist_node *n;
 	struct hlist_head *head;
 
 	head = vport_hash_bucket(dp, port_no);
-	hlist_for_each_entry_rcu(vport, head, dp_hash_node) {
+	hlist_for_each_entry_rcu(vport, n, head, dp_hash_node) {
 		if (vport->port_no == port_no)
 			return vport;
 	}
@@ -273,7 +274,6 @@ static struct genl_family dp_packet_genl_family = {
 	.version = OVS_PACKET_VERSION,
 	.maxattr = OVS_PACKET_ATTR_MAX,
 	.netnsok = true,
-	 SET_PARALLEL_OPS
 };
 
 int ovs_dp_upcall(struct datapath *dp, struct sk_buff *skb,
@@ -323,7 +323,7 @@ static int queue_gso_packets(struct net *net, int dp_ifindex,
 	struct sk_buff *segs, *nskb;
 	int err;
 
-	segs = __skb_gso_segment(skb, NETIF_F_SG | NETIF_F_HW_CSUM, false);
+	segs = skb_gso_segment(skb, NETIF_F_SG | NETIF_F_HW_CSUM);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
 
@@ -1000,7 +1000,6 @@ static struct genl_family dp_flow_genl_family = {
 	.version = OVS_FLOW_VERSION,
 	.maxattr = OVS_FLOW_ATTR_MAX,
 	.netnsok = true,
-	 SET_PARALLEL_OPS
 };
 
 static struct genl_multicast_group ovs_dp_flow_multicast_group = {
@@ -1339,7 +1338,7 @@ static int ovs_flow_cmd_new_or_set(struct sk_buff *skb, struct genl_info *info)
 		/* Put flow in bucket. */
 		ovs_flow_insert(table, flow);
 
-		reply = ovs_flow_cmd_build_info(flow, dp, info->snd_portid,
+		reply = ovs_flow_cmd_build_info(flow, dp, info->snd_pid,
 						info->snd_seq, OVS_FLOW_CMD_NEW);
 	} else {
 		/* We found a matching flow. */
@@ -1368,7 +1367,7 @@ static int ovs_flow_cmd_new_or_set(struct sk_buff *skb, struct genl_info *info)
 		rcu_assign_pointer(flow->sf_acts, acts);
 		ovs_flow_deferred_free_acts(old_acts);
 
-		reply = ovs_flow_cmd_build_info(flow, dp, info->snd_portid,
+		reply = ovs_flow_cmd_build_info(flow, dp, info->snd_pid,
 					       info->snd_seq, OVS_FLOW_CMD_NEW);
 
 		/* Clear stats. */
@@ -1433,7 +1432,7 @@ static int ovs_flow_cmd_get(struct sk_buff *skb, struct genl_info *info)
 		goto unlock;
 	}
 
-	reply = ovs_flow_cmd_build_info(flow, dp, info->snd_portid,
+	reply = ovs_flow_cmd_build_info(flow, dp, info->snd_pid,
 					info->snd_seq, OVS_FLOW_CMD_NEW);
 	if (IS_ERR(reply)) {
 		err = PTR_ERR(reply);
@@ -1491,7 +1490,7 @@ static int ovs_flow_cmd_del(struct sk_buff *skb, struct genl_info *info)
 
 	ovs_flow_remove(table, flow);
 
-	err = ovs_flow_cmd_fill_info(flow, dp, reply, info->snd_portid,
+	err = ovs_flow_cmd_fill_info(flow, dp, reply, info->snd_pid,
 				     info->snd_seq, 0, OVS_FLOW_CMD_DEL);
 	BUG_ON(err < 0);
 
@@ -1530,7 +1529,7 @@ static int ovs_flow_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)
 			break;
 
 		if (ovs_flow_cmd_fill_info(flow, dp, skb,
-					   NETLINK_CB(cb->skb).portid,
+					   NETLINK_CB(cb->skb).pid,
 					   cb->nlh->nlmsg_seq, NLM_F_MULTI,
 					   OVS_FLOW_CMD_NEW) < 0)
 			break;
@@ -1578,7 +1577,6 @@ static struct genl_family dp_datapath_genl_family = {
 	.version = OVS_DATAPATH_VERSION,
 	.maxattr = OVS_DP_ATTR_MAX,
 	.netnsok = true,
-	 SET_PARALLEL_OPS
 };
 
 static struct genl_multicast_group ovs_dp_datapath_multicast_group = {
@@ -1727,7 +1725,7 @@ static int ovs_dp_cmd_new(struct sk_buff *skb, struct genl_info *info)
 		goto err_destroy_ports_array;
 	}
 
-	reply = ovs_dp_cmd_build_info(dp, info->snd_portid,
+	reply = ovs_dp_cmd_build_info(dp, info->snd_pid,
 				      info->snd_seq, OVS_DP_CMD_NEW);
 	err = PTR_ERR(reply);
 	if (IS_ERR(reply))
@@ -1765,9 +1763,9 @@ static void __dp_destroy(struct datapath *dp)
 
 	for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {
 		struct vport *vport;
-		struct hlist_node *n;
+		struct hlist_node *node, *n;
 
-		hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node)
+		hlist_for_each_entry_safe(vport, node, n, &dp->ports[i], dp_hash_node)
 			if (vport->port_no != OVSP_LOCAL)
 				ovs_dp_detach_port(vport);
 	}
@@ -1794,7 +1792,7 @@ static int ovs_dp_cmd_del(struct sk_buff *skb, struct genl_info *info)
 	if (IS_ERR(dp))
 		goto unlock;
 
-	reply = ovs_dp_cmd_build_info(dp, info->snd_portid,
+	reply = ovs_dp_cmd_build_info(dp, info->snd_pid,
 				      info->snd_seq, OVS_DP_CMD_DEL);
 	err = PTR_ERR(reply);
 	if (IS_ERR(reply))
@@ -1823,7 +1821,7 @@ static int ovs_dp_cmd_set(struct sk_buff *skb, struct genl_info *info)
 	if (IS_ERR(dp))
 		goto unlock;
 
-	reply = ovs_dp_cmd_build_info(dp, info->snd_portid,
+	reply = ovs_dp_cmd_build_info(dp, info->snd_pid,
 				      info->snd_seq, OVS_DP_CMD_NEW);
 	if (IS_ERR(reply)) {
 		err = PTR_ERR(reply);
@@ -1855,7 +1853,7 @@ static int ovs_dp_cmd_get(struct sk_buff *skb, struct genl_info *info)
 		goto unlock;
 	}
 
-	reply = ovs_dp_cmd_build_info(dp, info->snd_portid,
+	reply = ovs_dp_cmd_build_info(dp, info->snd_pid,
 				      info->snd_seq, OVS_DP_CMD_NEW);
 	if (IS_ERR(reply)) {
 		err = PTR_ERR(reply);
@@ -1880,7 +1878,7 @@ static int ovs_dp_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)
 	rcu_read_lock();
 	list_for_each_entry_rcu(dp, &ovs_net->dps, list_node) {
 		if (i >= skip &&
-		    ovs_dp_cmd_fill_info(dp, skb, NETLINK_CB(cb->skb).portid,
+		    ovs_dp_cmd_fill_info(dp, skb, NETLINK_CB(cb->skb).pid,
 					 cb->nlh->nlmsg_seq, NLM_F_MULTI,
 					 OVS_DP_CMD_NEW) < 0)
 			break;
@@ -1933,7 +1931,6 @@ static struct genl_family dp_vport_genl_family = {
 	.version = OVS_VPORT_VERSION,
 	.maxattr = OVS_VPORT_ATTR_MAX,
 	.netnsok = true,
-	 SET_PARALLEL_OPS
 };
 
 struct genl_multicast_group ovs_dp_vport_multicast_group = {
@@ -2091,7 +2088,7 @@ static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info *info)
 	if (a[OVS_VPORT_ATTR_STATS])
 		ovs_vport_set_stats(vport, nla_data(a[OVS_VPORT_ATTR_STATS]));
 
-	reply = ovs_vport_cmd_build_info(vport, info->snd_portid, info->snd_seq,
+	reply = ovs_vport_cmd_build_info(vport, info->snd_pid, info->snd_seq,
 					 OVS_VPORT_CMD_NEW);
 	if (IS_ERR(reply)) {
 		err = PTR_ERR(reply);
@@ -2144,7 +2141,7 @@ static int ovs_vport_cmd_set(struct sk_buff *skb, struct genl_info *info)
 	if (a[OVS_VPORT_ATTR_UPCALL_PID])
 		vport->upcall_portid = nla_get_u32(a[OVS_VPORT_ATTR_UPCALL_PID]);
 
-	err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,
+	err = ovs_vport_cmd_fill_info(vport, reply, info->snd_pid,
 				      info->snd_seq, 0, OVS_VPORT_CMD_NEW);
 	BUG_ON(err < 0);
 
@@ -2177,7 +2174,7 @@ static int ovs_vport_cmd_del(struct sk_buff *skb, struct genl_info *info)
 		goto exit_unlock;
 	}
 
-	reply = ovs_vport_cmd_build_info(vport, info->snd_portid,
+	reply = ovs_vport_cmd_build_info(vport, info->snd_pid,
 					 info->snd_seq, OVS_VPORT_CMD_DEL);
 	err = PTR_ERR(reply);
 	if (IS_ERR(reply))
@@ -2207,7 +2204,7 @@ static int ovs_vport_cmd_get(struct sk_buff *skb, struct genl_info *info)
 	if (IS_ERR(vport))
 		goto exit_unlock;
 
-	reply = ovs_vport_cmd_build_info(vport, info->snd_portid,
+	reply = ovs_vport_cmd_build_info(vport, info->snd_pid,
 					 info->snd_seq, OVS_VPORT_CMD_NEW);
 	err = PTR_ERR(reply);
 	if (IS_ERR(reply))
@@ -2236,12 +2233,13 @@ static int ovs_vport_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)
 	rcu_read_lock();
 	for (i = bucket; i < DP_VPORT_HASH_BUCKETS; i++) {
 		struct vport *vport;
+		struct hlist_node *n;
 
 		j = 0;
-		hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node) {
+		hlist_for_each_entry_rcu(vport, n, &dp->ports[i], dp_hash_node) {
 			if (j >= skip &&
 			    ovs_vport_cmd_fill_info(vport, skb,
-						    NETLINK_CB(cb->skb).portid,
+						    NETLINK_CB(cb->skb).pid,
 						    cb->nlh->nlmsg_seq,
 						    NLM_F_MULTI,
 						    OVS_VPORT_CMD_NEW) < 0)
@@ -2375,7 +2373,7 @@ static int __net_init ovs_init_net(struct net *net)
 	struct ovs_net *ovs_net = net_generic(net, ovs_net_id);
 
 	INIT_LIST_HEAD(&ovs_net->dps);
-	INIT_WORK(&ovs_net->dp_notify_work, ovs_dp_notify_wq);
+	OVS_INIT_WORK(&ovs_net->dp_notify_work, ovs_dp_notify_wq);
 	return 0;
 }
 
@@ -2389,7 +2387,7 @@ static void __net_exit ovs_exit_net(struct net *net)
 		__dp_destroy(dp);
 	ovs_unlock();
 
-	cancel_work_sync(&ovs_net->dp_notify_work);
+	ovs_cancel_work_sync(&ovs_net->dp_notify_work);
 }
 
 static struct pernet_operations ovs_net_ops = {
@@ -2399,7 +2397,6 @@ static struct pernet_operations ovs_net_ops = {
 	.size = sizeof(struct ovs_net),
 };
 
-DEFINE_COMPAT_PNET_REG_FUNC(device);
 
 static int __init dp_init(void)
 {
@@ -2408,7 +2405,7 @@ static int __init dp_init(void)
 	BUILD_BUG_ON(sizeof(struct ovs_skb_cb) > FIELD_SIZEOF(struct sk_buff, cb));
 
 	pr_info("Open vSwitch switching datapath %s, built "__DATE__" "__TIME__"\n",
-		VERSION);
+		OVS_VERSION);
 
 	err = ovs_workqueues_init();
 	if (err)
@@ -2469,4 +2466,4 @@ module_exit(dp_cleanup);
 
 MODULE_DESCRIPTION("Open vSwitch switching datapath");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(VERSION);
+MODULE_VERSION(OVS_VERSION);
diff --git a/drivers/staging/openvswitch_nv/datapath.h b/drivers/staging/openvswitch_nv/datapath.h
index 5d50dd4383f3..9528d482f0a6 100644
--- a/drivers/staging/openvswitch_nv/datapath.h
+++ b/drivers/staging/openvswitch_nv/datapath.h
@@ -26,10 +26,10 @@
 #include <linux/skbuff.h>
 #include <linux/u64_stats_sync.h>
 
-#include "compat.h"
 #include "flow.h"
 #include "vlan.h"
 #include "vport.h"
+#include "workqueue.h"
 
 #define DP_MAX_PORTS		USHRT_MAX
 #define DP_VPORT_HASH_BUCKETS	1024
@@ -127,7 +127,7 @@ struct dp_upcall_info {
 struct ovs_net {
 	struct list_head dps;
 	struct vport_net vport_net;
-	struct work_struct dp_notify_work;
+	struct ovs_work_struct dp_notify_work;
 };
 
 extern int ovs_net_id;
@@ -187,7 +187,7 @@ struct sk_buff *ovs_vport_cmd_build_info(struct vport *, u32 portid, u32 seq,
 					 u8 cmd);
 
 int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb);
-void ovs_dp_notify_wq(struct work_struct *work);
+void ovs_dp_notify_wq(struct ovs_work_struct *work);
 
 #define OVS_NLERR(fmt, ...) \
 	pr_info_once("netlink: " fmt, ##__VA_ARGS__)
diff --git a/drivers/staging/openvswitch_nv/dp_notify.c b/drivers/staging/openvswitch_nv/dp_notify.c
index 847f6116f729..0c509f936ec5 100644
--- a/drivers/staging/openvswitch_nv/dp_notify.c
+++ b/drivers/staging/openvswitch_nv/dp_notify.c
@@ -25,6 +25,8 @@
 #include "vport-internal_dev.h"
 #include "vport-netdev.h"
 
+#include "workqueue.h"
+
 static void dp_detach_port_notify(struct vport *vport)
 {
 	struct sk_buff *notify;
@@ -46,7 +48,7 @@ static void dp_detach_port_notify(struct vport *vport)
 				GFP_KERNEL);
 }
 
-void ovs_dp_notify_wq(struct work_struct *work)
+void ovs_dp_notify_wq(struct ovs_work_struct *work)
 {
 	struct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);
 	struct datapath *dp;
@@ -57,9 +59,9 @@ void ovs_dp_notify_wq(struct work_struct *work)
 
 		for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {
 			struct vport *vport;
-			struct hlist_node *n;
+			struct hlist_node *node, *n;
 
-			hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) {
+			hlist_for_each_entry_safe(vport, node, n, &dp->ports[i], dp_hash_node) {
 				struct netdev_vport *netdev_vport;
 
 				if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)
@@ -90,7 +92,7 @@ static int dp_device_event(struct notifier_block *unused, unsigned long event,
 
 	if (event == NETDEV_UNREGISTER) {
 		ovs_net = net_generic(dev_net(dev), ovs_net_id);
-		queue_work(&ovs_net->dp_notify_work);
+		ovs_queue_work(&ovs_net->dp_notify_work);
 	}
 
 	return NOTIFY_DONE;
diff --git a/drivers/staging/openvswitch_nv/flow.c b/drivers/staging/openvswitch_nv/flow.c
index 29122af7a900..5c5092864b2d 100644
--- a/drivers/staging/openvswitch_nv/flow.c
+++ b/drivers/staging/openvswitch_nv/flow.c
@@ -510,10 +510,10 @@ static void __flow_tbl_destroy(struct flow_table *table)
 	for (i = 0; i < table->n_buckets; i++) {
 		struct sw_flow *flow;
 		struct hlist_head *head = flex_array_get(table->buckets, i);
-		struct hlist_node *n;
+		struct hlist_node *node, *n;
 		int ver = table->node_ver;
 
-		hlist_for_each_entry_safe(flow, n, head, hash_node[ver]) {
+		hlist_for_each_entry_safe(flow, node, n, head, hash_node[ver]) {
 			hlist_del(&flow->hash_node[ver]);
 			ovs_flow_free(flow, false);
 		}
@@ -566,6 +566,7 @@ void ovs_flow_tbl_destroy(struct flow_table *table, bool deferred)
 struct sw_flow *ovs_flow_dump_next(struct flow_table *table, u32 *bucket, u32 *last)
 {
 	struct sw_flow *flow;
+	struct hlist_node *n;
 	struct hlist_head *head;
 	int ver;
 	int i;
@@ -574,7 +575,7 @@ struct sw_flow *ovs_flow_dump_next(struct flow_table *table, u32 *bucket, u32 *l
 	while (*bucket < table->n_buckets) {
 		i = 0;
 		head = flex_array_get(table->buckets, *bucket);
-		hlist_for_each_entry_rcu(flow, head, hash_node[ver]) {
+		hlist_for_each_entry_rcu(flow, n, head, hash_node[ver]) {
 			if (i < *last) {
 				i++;
 				continue;
@@ -611,10 +612,11 @@ static void flow_table_copy_flows(struct flow_table *old, struct flow_table *new
 	for (i = 0; i < old->n_buckets; i++) {
 		struct sw_flow *flow;
 		struct hlist_head *head;
+		struct hlist_node *n;
 
 		head = flex_array_get(old->buckets, i);
 
-		hlist_for_each_entry(flow, head, hash_node[old_ver])
+		hlist_for_each_entry(flow, n, head, hash_node[old_ver])
 			__tbl_insert(new, flow);
 	}
 
@@ -1087,6 +1089,7 @@ static struct sw_flow *ovs_masked_flow_lookup(struct flow_table *table,
 				    struct sw_flow_mask *mask)
 {
 	struct sw_flow *flow;
+	struct hlist_node *n;
 	struct hlist_head *head;
 	int key_start = mask->range.start;
 	int key_end = mask->range.end;
@@ -1096,7 +1099,7 @@ static struct sw_flow *ovs_masked_flow_lookup(struct flow_table *table,
 	ovs_flow_key_mask(&masked_key, unmasked, mask);
 	hash = ovs_flow_hash(&masked_key, key_start, key_end);
 	head = find_bucket(table, hash);
-	hlist_for_each_entry_rcu(flow, head, hash_node[table->node_ver]) {
+	hlist_for_each_entry_rcu(flow, n, head, hash_node[table->node_ver]) {
 		if (flow->mask == mask &&
 		    __flow_cmp_masked_key(flow, &masked_key,
 					  key_start, key_end))
diff --git a/drivers/staging/openvswitch_nv/flow.h b/drivers/staging/openvswitch_nv/flow.h
index 03eae035237d..be6d3741bd66 100644
--- a/drivers/staging/openvswitch_nv/flow.h
+++ b/drivers/staging/openvswitch_nv/flow.h
@@ -21,7 +21,7 @@
 
 #include <linux/kernel.h>
 #include <linux/netlink.h>
-#include <linux/openvswitch.h>
+#include <linux/openvswitch-nv.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
@@ -32,7 +32,7 @@
 #include <linux/flex_array.h>
 
 #include <net/inet_ecn.h>
-#include <net/ip_tunnels.h>
+#include "ip_tunnels.h"
 
 struct sk_buff;
 struct sw_flow_mask;
diff --git a/drivers/staging/openvswitch_nv/linux/compat/gre.c b/drivers/staging/openvswitch_nv/linux/compat/gre.c
index 582bd94c2a56..b6ad150d8b89 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/gre.c
+++ b/drivers/staging/openvswitch_nv/linux/compat/gre.c
@@ -31,13 +31,13 @@
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 
-#include <net/gre.h>
 #include <net/icmp.h>
 #include <net/protocol.h>
 #include <net/route.h>
 #include <net/xfrm.h>
 
 #include "gso.h"
+#include "gre.h"
 
 static struct gre_cisco_protocol __rcu *gre_cisco_proto;
 
@@ -224,88 +224,14 @@ static const struct gre_protocol ipgre_protocol = {
 	.handler	=	gre_cisco_rcv,
 };
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
-static const struct gre_protocol __rcu *gre_proto[GREPROTO_MAX] __read_mostly;
-
-int gre_add_protocol(const struct gre_protocol *proto, u8 version)
-{
-	if (version >= GREPROTO_MAX)
-		return -EINVAL;
-
-	return (cmpxchg((const struct gre_protocol **)&gre_proto[version], NULL, proto) == NULL) ?
-		0 : -EBUSY;
-}
-
-int gre_del_protocol(const struct gre_protocol *proto, u8 version)
-{
-	int ret;
-
-	if (version >= GREPROTO_MAX)
-		return -EINVAL;
-
-	ret = (cmpxchg((const struct gre_protocol **)&gre_proto[version], proto, NULL) == proto) ?
-		0 : -EBUSY;
-
-	if (ret)
-		return ret;
-
-	synchronize_net();
-	return 0;
-}
-
-static int gre_rcv(struct sk_buff *skb)
-{
-	const struct gre_protocol *proto;
-	u8 ver;
-	int ret;
-
-	if (!pskb_may_pull(skb, 12))
-		goto drop;
-
-	ver = skb->data[1] & 0x7f;
-	if (ver >= GREPROTO_MAX)
-		goto drop;
-
-	rcu_read_lock();
-	proto = rcu_dereference(gre_proto[ver]);
-	if (!proto || !proto->handler)
-		goto drop_unlock;
-	ret = proto->handler(skb);
-	rcu_read_unlock();
-	return ret;
-
-drop_unlock:
-	rcu_read_unlock();
-drop:
-	kfree_skb(skb);
-	return NET_RX_DROP;
-}
-
-static const struct net_protocol net_gre_protocol = {
-	.handler     = gre_rcv,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
-	.netns_ok    = 1,
-#endif
-};
-#endif
 
 static int gre_compat_init(void)
 {
 	int err;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
-	if (inet_add_protocol(&net_gre_protocol, IPPROTO_GRE) < 0) {
-		pr_err("%s: cannot register gre protocol handler\n", __func__);
-		return -EAGAIN;
-	}
-#endif
 	err = gre_add_protocol(&ipgre_protocol, GREPROTO_CISCO);
 	if (err) {
 		pr_warn("%s: cannot register gre_cisco protocol handler\n", __func__);
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
-		inet_del_protocol(&net_gre_protocol, IPPROTO_GRE);
-#endif
 	}
 
 	return err;
@@ -318,12 +244,6 @@ static int gre_compat_exit(void)
 	ret = gre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);
 	if (ret)
 		return ret;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
-	ret = inet_del_protocol(&net_gre_protocol, IPPROTO_GRE);
-	if (ret)
-		return ret;
-#endif
 	return 0;
 }
 
diff --git a/drivers/staging/openvswitch_nv/linux/compat/gso.c b/drivers/staging/openvswitch_nv/linux/compat/gso.c
index 30332a2dc1fe..bfeb58d3ddac 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/gso.c
+++ b/drivers/staging/openvswitch_nv/linux/compat/gso.c
@@ -81,7 +81,7 @@ static struct sk_buff *tnl_skb_gso_segment(struct sk_buff *skb,
 	 * make copy of it to restore it back. */
 	memcpy(cb, skb->cb, sizeof(cb));
 
-	segs = __skb_gso_segment(skb, 0, tx_path);
+	segs = skb_gso_segment(skb, 0);
 	if (!segs || IS_ERR(segs))
 		goto free;
 
diff --git a/drivers/staging/openvswitch_nv/linux/compat/include/linux/workqueue.h b/drivers/staging/openvswitch_nv/linux/compat/include/linux/workqueue.h
index b2de545bb118..fec9f60bcf8b 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/include/linux/workqueue.h
+++ b/drivers/staging/openvswitch_nv/linux/compat/include/linux/workqueue.h
@@ -14,61 +14,59 @@ void ovs_workqueues_exit(void);
  * freeze in event of softlockup due to workq blocked on genl_lock.
  */
 
-struct work_struct;
+struct ovs_work_struct;
 
-typedef void (*work_func_t)(struct work_struct *work);
+typedef void (*ovs_work_func_t)(struct ovs_work_struct *work);
 
 #define work_data_bits(work) ((unsigned long *)(&(work)->data))
 
-struct work_struct {
+struct ovs_work_struct {
 #define WORK_STRUCT_PENDING 0           /* T if work item pending execution */
 	atomic_long_t data;
 	struct list_head entry;
-	work_func_t func;
+	ovs_work_func_t func;
 #ifdef CONFIG_LOCKDEP
 	struct lockdep_map lockdep_map;
 #endif
 };
 
-#define WORK_DATA_INIT()        ATOMIC_LONG_INIT(0)
+#define OVS_WORK_DATA_INIT()        ATOMIC_LONG_INIT(0)
 
-#define work_clear_pending(work)				\
+#define ovs_work_clear_pending(work)				\
 	clear_bit(WORK_STRUCT_PENDING, work_data_bits(work))
 
-struct delayed_work {
-	struct work_struct work;
+struct ovs_delayed_work {
+	struct ovs_work_struct work;
 	struct timer_list timer;
 };
 
-#define __WORK_INITIALIZER(n, f) {				\
-	.data = WORK_DATA_INIT(),				\
+#define __OVS_WORK_INITIALIZER(n, f) {				\
+	.data = OVS_WORK_DATA_INIT(),				\
 	.entry  = { &(n).entry, &(n).entry },			\
 	.func = (f),						\
 }
 
-#define __DELAYED_WORK_INITIALIZER(n, f) {			\
-	.work = __WORK_INITIALIZER((n).work, (f)),		\
+#define __OVS_DELAYED_WORK_INITIALIZER(n, f) {			\
+	.work = __OVS_WORK_INITIALIZER((n).work, (f)),		\
 	.timer = TIMER_INITIALIZER(NULL, 0, 0),			\
 }
 
-#define DECLARE_DELAYED_WORK(n, f)				\
-	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f)
+#define OVS_DECLARE_DELAYED_WORK(n, f)				\
+	struct delayed_work n = __OVS_DELAYED_WORK_INITIALIZER(n, f)
 
-#define schedule_delayed_work rpl_schedule_delayed_work
-int schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);
+int ovs_schedule_delayed_work(struct ovs_delayed_work *dwork, unsigned long delay);
 
-#define cancel_delayed_work_sync rpl_cancel_delayed_work_sync
-int cancel_delayed_work_sync(struct delayed_work *dwork);
+int ovs_cancel_delayed_work_sync(struct ovs_delayed_work *dwork);
 
-#define INIT_WORK(_work, _func)					\
+#define OVS_INIT_WORK(_work, _func)					\
 	do {							\
-		(_work)->data = (atomic_long_t) WORK_DATA_INIT();	\
+		(_work)->data = (atomic_long_t) OVS_WORK_DATA_INIT();	\
 		INIT_LIST_HEAD(&(_work)->entry);		\
 		(_work)->func = (_func);			\
 	} while (0)
 
-extern void flush_scheduled_work(void);
-extern void queue_work(struct work_struct *work);
-extern bool cancel_work_sync(struct work_struct *work);
+extern void ovs_flush_scheduled_work(void);
+extern void ovs_queue_work(struct ovs_work_struct *work);
+extern bool ovs_cancel_work_sync(struct ovs_work_struct *work);
 
 #endif
diff --git a/drivers/staging/openvswitch_nv/linux/compat/include/net/gre.h b/drivers/staging/openvswitch_nv/linux/compat/include/net/gre.h
index 5f46aed6840f..f0edbb846252 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/include/net/gre.h
+++ b/drivers/staging/openvswitch_nv/linux/compat/include/net/gre.h
@@ -2,26 +2,10 @@
 #define __LINUX_GRE_WRAPPER_H
 
 #include <linux/skbuff.h>
-#include <net/ip_tunnels.h>
+#include "ip_tunnels.h"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
-#include_next <net/gre.h>
+#include <net/gre.h>
 
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) */
-
-#define GREPROTO_CISCO		0
-#define GREPROTO_MAX		2
-
-struct gre_protocol {
-	int  (*handler)(struct sk_buff *skb);
-};
-
-int gre_add_protocol(const struct gre_protocol *proto, u8 version);
-int gre_del_protocol(const struct gre_protocol *proto, u8 version);
-
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 struct gre_base_hdr {
 	__be16 flags;
 	__be16 protocol;
@@ -71,7 +55,6 @@ static inline __be16 tnl_flags_to_gre_flags(__be16 tflags)
 
 	return flags;
 }
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
 
 #define MAX_GRE_PROTO_PRIORITY 255
 struct gre_cisco_protocol {
diff --git a/drivers/staging/openvswitch_nv/linux/compat/include/net/vxlan.h b/drivers/staging/openvswitch_nv/linux/compat/include/net/vxlan.h
index 46cbfb603f3b..490fd2c80ae6 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/include/net/vxlan.h
+++ b/drivers/staging/openvswitch_nv/linux/compat/include/net/vxlan.h
@@ -5,6 +5,8 @@
 #include <linux/netdevice.h>
 #include <linux/udp.h>
 
+#include "workqueue.h"
+
 struct vxlan_sock;
 typedef void (vxlan_rcv_t)(struct vxlan_sock *vs, struct sk_buff *skb, __be32 key);
 
@@ -13,7 +15,7 @@ struct vxlan_sock {
 	struct hlist_node hlist;
 	vxlan_rcv_t	 *rcv;
 	void		 *data;
-	struct work_struct del_work;
+	struct ovs_work_struct del_work;
 	struct socket	 *sock;
 	struct rcu_head	  rcu;
 };
diff --git a/drivers/staging/openvswitch_nv/linux/compat/ip_tunnels_core.c b/drivers/staging/openvswitch_nv/linux/compat/ip_tunnels_core.c
index a059be0a9820..e6227da77c83 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/ip_tunnels_core.c
+++ b/drivers/staging/openvswitch_nv/linux/compat/ip_tunnels_core.c
@@ -27,11 +27,10 @@
 #include <linux/version.h>
 #include <linux/workqueue.h>
 #include <linux/rculist.h>
-#include <net/ip_tunnels.h>
 #include <net/route.h>
 #include <net/xfrm.h>
 
-#include "compat.h"
+#include "ip_tunnels.h"
 #include "gso.h"
 
 int iptunnel_xmit(struct net *net, struct rtable *rt,
@@ -45,9 +44,9 @@ int iptunnel_xmit(struct net *net, struct rtable *rt,
 
 	nf_reset(skb);
 	secpath_reset(skb);
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 	skb_dst_drop(skb);
-	skb_dst_set(skb, &rt_dst(rt));
+	skb_dst_set(skb, &rt->dst);
 #if 0
 	/* Do not clear ovs_skb_cb.  It will be done in gso code. */
 	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
@@ -67,7 +66,7 @@ int iptunnel_xmit(struct net *net, struct rtable *rt,
 	iph->daddr	=	dst;
 	iph->saddr	=	src;
 	iph->ttl	=	ttl;
-	__ip_select_ident(iph, /* &rt_dst(rt), */ (skb_shinfo(skb)->gso_segs ?: 1) - 1);
+	__ip_select_ident(iph, /* &rt->dst, */ (skb_shinfo(skb)->gso_segs ?: 1) - 1);
 
 	err = ip_local_out(skb);
 	if (unlikely(net_xmit_eval(err)))
@@ -101,7 +100,7 @@ int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto)
 
 	nf_reset(skb);
 	secpath_reset(skb);
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 	skb_dst_drop(skb);
 	vlan_set_tci(skb, 0);
 	skb_set_queue_mapping(skb, 0);
diff --git a/drivers/staging/openvswitch_nv/linux/compat/vxlan.c b/drivers/staging/openvswitch_nv/linux/compat/vxlan.c
index 325b19d4f84d..678841556741 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/vxlan.c
+++ b/drivers/staging/openvswitch_nv/linux/compat/vxlan.c
@@ -40,7 +40,6 @@
 #include <net/arp.h>
 #include <net/ndisc.h>
 #include <net/ip.h>
-#include <net/ip_tunnels.h>
 #include <net/icmp.h>
 #include <net/udp.h>
 #include <net/rtnetlink.h>
@@ -49,11 +48,12 @@
 #include <net/inet_ecn.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
-#include <net/vxlan.h>
 
-#include "compat.h"
 #include "gso.h"
 #include "vlan.h"
+#include "ip_tunnels.h"
+#include "vxlan.h"
+#include "workqueue.h"
 
 #define PORT_HASH_BITS	8
 #define PORT_HASH_SIZE  (1<<PORT_HASH_BITS)
@@ -94,9 +94,10 @@ static inline struct hlist_head *vs_head(struct net *net, __be16 port)
 static struct vxlan_sock *vxlan_find_sock(struct net *net, __be16 port)
 {
 	struct vxlan_sock *vs;
+	struct hlist_node *node;
 
-	hlist_for_each_entry_rcu(vs, vs_head(net, port), hlist) {
-		if (inet_sport(vs->sock->sk) == port)
+	hlist_for_each_entry_rcu(vs, node, vs_head(net, port), hlist) {
+		if (inet_sk(vs->sock->sk)->inet_sport == port)
 			return vs;
 	}
 	return NULL;
@@ -124,7 +125,7 @@ static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
 	if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))
 		goto drop;
 
-	vs = vxlan_find_sock(sock_net(sk), inet_sport(sk));
+	vs = vxlan_find_sock(sock_net(sk), inet_sk(sk)->inet_sport);
 	if (!vs)
 		goto drop;
 
@@ -219,7 +220,7 @@ int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 	int min_headroom;
 	int err;
 
-	min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len
+	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
 			+ VXLAN_HLEN + sizeof(struct iphdr)
 			+ (vlan_tx_tag_present(skb) ? VLAN_HLEN : 0);
 
@@ -270,7 +271,7 @@ static void rcu_free_vs(struct rcu_head *rcu)
 	kfree(vs);
 }
 
-static void vxlan_del_work(struct work_struct *work)
+static void vxlan_del_work(struct ovs_work_struct *work)
 {
 	struct vxlan_sock *vs = container_of(work, struct vxlan_sock, del_work);
 
@@ -298,7 +299,7 @@ static struct vxlan_sock *vxlan_socket_create(struct net *net, __be16 port,
 		return ERR_PTR(-ENOMEM);
 	}
 
-	INIT_WORK(&vs->del_work, vxlan_del_work);
+	OVS_INIT_WORK(&vs->del_work, vxlan_del_work);
 
 	/* Create UDP socket for encapsulation receive. */
 	rc = sock_create_kern(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &vs->sock);
@@ -333,7 +334,6 @@ static struct vxlan_sock *vxlan_socket_create(struct net *net, __be16 port,
 	/* Mark socket as an encapsulation socket. */
 	udp_sk(sk)->encap_type = 1;
 	udp_sk(sk)->encap_rcv = vxlan_udp_encap_recv;
-	udp_encap_enable();
 	return vs;
 }
 
@@ -362,7 +362,7 @@ void vxlan_sock_release(struct vxlan_sock *vs)
 	hlist_del_rcu(&vs->hlist);
 	spin_unlock(&vn->sock_lock);
 
-	queue_work(&vs->del_work);
+	ovs_queue_work(&vs->del_work);
 }
 
 static int vxlan_init_net(struct net *net)
@@ -386,7 +386,6 @@ static struct pernet_operations vxlan_net_ops = {
 
 static int refcnt;
 static DEFINE_MUTEX(init_lock);
-DEFINE_COMPAT_PNET_REG_FUNC(device);
 
 static int vxlan_init_module(void)
 {
diff --git a/drivers/staging/openvswitch_nv/linux/compat/workqueue.c b/drivers/staging/openvswitch_nv/linux/compat/workqueue.c
index cdb36150c271..c0de0c4b8833 100644
--- a/drivers/staging/openvswitch_nv/linux/compat/workqueue.c
+++ b/drivers/staging/openvswitch_nv/linux/compat/workqueue.c
@@ -23,18 +23,20 @@
 #include <linux/lockdep.h>
 #include <linux/idr.h>
 
+#include "workqueue.h"
+
 static spinlock_t wq_lock;
 static struct list_head workq;
 static wait_queue_head_t more_work;
 static struct task_struct *workq_thread;
-static struct work_struct *current_work;
+static struct ovs_work_struct *current_work;
 
-static void add_work_to_ovs_wq(struct work_struct *work)
+static void add_work_to_ovs_wq(struct ovs_work_struct *work)
 {
 	list_add_tail(&work->entry, &workq);
 	wake_up(&more_work);
 }
-static void __queue_work(struct work_struct *work)
+static void __queue_work(struct ovs_work_struct *work)
 {
 	unsigned long flags;
 
@@ -43,7 +45,7 @@ static void __queue_work(struct work_struct *work)
 	spin_unlock_irqrestore(&wq_lock, flags);
 }
 
-void queue_work(struct work_struct *work)
+void ovs_queue_work(struct ovs_work_struct *work)
 {
 	if (test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work)))
 		return;
@@ -52,15 +54,15 @@ void queue_work(struct work_struct *work)
 
 static void _delayed_work_timer_fn(unsigned long __data)
 {
-	struct delayed_work *dwork = (struct delayed_work *)__data;
+	struct ovs_delayed_work *dwork = (struct ovs_delayed_work *)__data;
 	__queue_work(&dwork->work);
 }
 
-static void __queue_delayed_work(struct delayed_work *dwork,
+static void __queue_delayed_work(struct ovs_delayed_work *dwork,
 		unsigned long delay)
 {
 	struct timer_list *timer = &dwork->timer;
-	struct work_struct *work = &dwork->work;
+	struct ovs_work_struct *work = &dwork->work;
 
 	BUG_ON(timer_pending(timer));
 	BUG_ON(!list_empty(&work->entry));
@@ -72,7 +74,7 @@ static void __queue_delayed_work(struct delayed_work *dwork,
 	add_timer(timer);
 }
 
-int schedule_delayed_work(struct delayed_work *dwork, unsigned long delay)
+int ovs_schedule_delayed_work(struct ovs_delayed_work *dwork, unsigned long delay)
 {
 	if (test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(&dwork->work)))
 		return 0;
@@ -86,17 +88,17 @@ int schedule_delayed_work(struct delayed_work *dwork, unsigned long delay)
 }
 
 struct wq_barrier {
-	struct work_struct      work;
+	struct ovs_work_struct      work;
 	struct completion       done;
 };
 
-static void wq_barrier_func(struct work_struct *work)
+static void wq_barrier_func(struct ovs_work_struct *work)
 {
 	struct wq_barrier *barr = container_of(work, struct wq_barrier, work);
 	complete(&barr->done);
 }
 
-static void workqueue_barrier(struct work_struct *work)
+static void workqueue_barrier(struct ovs_work_struct *work)
 {
 	bool need_barrier;
 	struct wq_barrier barr;
@@ -105,7 +107,7 @@ static void workqueue_barrier(struct work_struct *work)
 	if (current_work != work)
 		need_barrier = false;
 	else {
-		INIT_WORK(&barr.work, wq_barrier_func);
+		OVS_INIT_WORK(&barr.work, wq_barrier_func);
 		init_completion(&barr.done);
 		add_work_to_ovs_wq(&barr.work);
 		need_barrier = true;
@@ -116,7 +118,7 @@ static void workqueue_barrier(struct work_struct *work)
 		wait_for_completion(&barr.done);
 }
 
-static int try_to_grab_pending(struct work_struct *work)
+static int try_to_grab_pending(struct ovs_work_struct *work)
 {
 	int ret;
 
@@ -137,7 +139,7 @@ static int try_to_grab_pending(struct work_struct *work)
 	return ret;
 }
 
-static int __cancel_work_timer(struct work_struct *work,
+static int __cancel_work_timer(struct ovs_work_struct *work,
 			       struct timer_list *timer)
 {
 	int ret;
@@ -157,12 +159,12 @@ static int __cancel_work_timer(struct work_struct *work,
 	return ret;
 }
 
-int cancel_delayed_work_sync(struct delayed_work *dwork)
+int ovs_cancel_delayed_work_sync(struct ovs_delayed_work *dwork)
 {
 	return __cancel_work_timer(&dwork->work, &dwork->timer);
 }
 
-bool cancel_work_sync(struct work_struct *work)
+bool ovs_cancel_work_sync(struct ovs_work_struct *work)
 {
 	return __cancel_work_timer(work, NULL);
 }
@@ -171,10 +173,10 @@ static void run_workqueue(void)
 {
 	spin_lock_irq(&wq_lock);
 	while (!list_empty(&workq)) {
-		struct work_struct *work = list_entry(workq.next,
-				struct work_struct, entry);
+		struct ovs_work_struct *work = list_entry(workq.next,
+				struct ovs_work_struct, entry);
 
-		work_func_t f = work->func;
+		ovs_work_func_t f = work->func;
 		list_del_init(workq.next);
 		current_work = work;
 		spin_unlock_irq(&wq_lock);
diff --git a/drivers/staging/openvswitch_nv/vlan.h b/drivers/staging/openvswitch_nv/vlan.h
index 13ae6a7e3715..6d6f50e6f565 100644
--- a/drivers/staging/openvswitch_nv/vlan.h
+++ b/drivers/staging/openvswitch_nv/vlan.h
@@ -21,7 +21,6 @@
 
 #include <linux/if_vlan.h>
 #include <linux/skbuff.h>
-#include <linux/version.h>
 
 /**
  * DOC: VLAN tag manipulation.
@@ -48,18 +47,64 @@
 
 static inline u16 vlan_get_tci(struct sk_buff *skb)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
-	if (skb->vlan_tci)
-		return skb->vlan_tci | VLAN_TAG_PRESENT;
-#endif
 	return skb->vlan_tci;
 }
 
 static inline void vlan_set_tci(struct sk_buff *skb, u16 vlan_tci)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
-	vlan_tci &= ~VLAN_TAG_PRESENT;
-#endif
 	skb->vlan_tci = vlan_tci;
 }
+
+/*
+ * The behavior of __vlan_put_tag() has changed over time:
+ *
+ *      - In 2.6.26 and earlier, it adjusted both MAC and network header
+ *        pointers.  (The latter didn't make any sense.)
+ *
+ *      - In 2.6.27 and 2.6.28, it did not adjust any header pointers at all.
+ *
+ *      - In 2.6.29 and later, it adjusts the MAC header pointer only.
+ *
+ * This is the version from 2.6.33.  We unconditionally substitute this version
+ * to avoid the need to guess whether the version in the kernel tree is
+ * acceptable.
+ */
+#define __vlan_put_tag(skb, proto, tag)  rpl__vlan_put_tag(skb, tag)
+
+static inline struct sk_buff *rpl__vlan_put_tag(struct sk_buff *skb, u16 vlan_tci)
+{
+	struct vlan_ethhdr *veth;
+
+	if (skb_cow_head(skb, VLAN_HLEN) < 0) {
+		kfree_skb(skb);
+		return NULL;
+	}
+	veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
+
+	/* Move the mac addresses to the beginning of the new header. */
+	memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);
+	skb->mac_header -= VLAN_HLEN;
+
+	/* first, the ethernet type */
+	veth->h_vlan_proto = htons(ETH_P_8021Q);
+
+	/* now, the TCI */
+	veth->h_vlan_TCI = htons(vlan_tci);
+
+	skb->protocol = htons(ETH_P_8021Q);
+
+	return skb;
+}
+
+static inline struct sk_buff *rpl___vlan_hwaccel_put_tag(struct sk_buff *skb,
+						     __be16 vlan_proto,
+						     u16 vlan_tci)
+{
+	return __vlan_hwaccel_put_tag(skb, vlan_tci);
+}
+
+#define __vlan_hwaccel_put_tag rpl___vlan_hwaccel_put_tag
+
+
+
 #endif /* vlan.h */
diff --git a/drivers/staging/openvswitch_nv/vport-gre.c b/drivers/staging/openvswitch_nv/vport-gre.c
index a49002f41582..35e75cf9a9b4 100644
--- a/drivers/staging/openvswitch_nv/vport-gre.c
+++ b/drivers/staging/openvswitch_nv/vport-gre.c
@@ -42,12 +42,12 @@
 
 #include <net/icmp.h>
 #include <net/ip.h>
-#include <net/ip_tunnels.h>
-#include <net/gre.h>
 #include <net/protocol.h>
 
+#include "ip_tunnels.h"
 #include "datapath.h"
 #include "vport.h"
+#include "gre.h"
 
 /* Returns the least-significant 32 bits of a __be64. */
 static __be32 be64_get_low32(__be64 x)
@@ -142,7 +142,7 @@ static int __send(struct vport *vport, struct sk_buff *skb,
 		goto error;
 	}
 
-	min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len
+	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
 			+ tunnel_hlen + sizeof(struct iphdr)
 			+ (vlan_tx_tag_present(skb) ? VLAN_HLEN : 0);
 
diff --git a/drivers/staging/openvswitch_nv/vport-internal_dev.c b/drivers/staging/openvswitch_nv/vport-internal_dev.c
index 738710ef66ab..1008937b9062 100644
--- a/drivers/staging/openvswitch_nv/vport-internal_dev.c
+++ b/drivers/staging/openvswitch_nv/vport-internal_dev.c
@@ -24,7 +24,6 @@
 #include <linux/ethtool.h>
 #include <linux/netdev_features.h>
 #include <linux/skbuff.h>
-#include <linux/version.h>
 
 #include <net/dst.h>
 #include <net/xfrm.h>
@@ -44,15 +43,9 @@ static struct internal_dev *internal_dev_priv(struct net_device *netdev)
 }
 
 /* This function is only called by the kernel network layer.*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 static struct rtnl_link_stats64 *internal_dev_get_stats(struct net_device *netdev,
 							struct rtnl_link_stats64 *stats)
 {
-#else
-static struct net_device_stats *internal_dev_sys_stats(struct net_device *netdev)
-{
-	struct net_device_stats *stats = &netdev->stats;
-#endif
 	struct vport *vport = ovs_internal_dev_get_vport(netdev);
 	struct ovs_vport_stats vport_stats;
 
@@ -102,14 +95,6 @@ static void internal_dev_getinfo(struct net_device *netdev,
 static const struct ethtool_ops internal_dev_ethtool_ops = {
 	.get_drvinfo	= internal_dev_getinfo,
 	.get_link	= ethtool_op_get_link,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
-	.get_sg		= ethtool_op_get_sg,
-	.set_sg		= ethtool_op_set_sg,
-	.get_tx_csum	= ethtool_op_get_tx_csum,
-	.set_tx_csum	= ethtool_op_set_tx_hw_csum,
-	.get_tso	= ethtool_op_get_tso,
-	.set_tso	= ethtool_op_set_tso,
-#endif
 };
 
 static int internal_dev_change_mtu(struct net_device *netdev, int new_mtu)
@@ -135,11 +120,7 @@ static const struct net_device_ops internal_dev_netdev_ops = {
 	.ndo_start_xmit = internal_dev_xmit,
 	.ndo_set_mac_address = eth_mac_addr,
 	.ndo_change_mtu = internal_dev_change_mtu,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 	.ndo_get_stats64 = internal_dev_get_stats,
-#else
-	.ndo_get_stats = internal_dev_sys_stats,
-#endif
 };
 
 static void do_setup(struct net_device *netdev)
@@ -158,11 +139,9 @@ static void do_setup(struct net_device *netdev)
 			   NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_TSO;
 
 	netdev->vlan_features = netdev->features;
-	netdev->features |= NETIF_F_HW_VLAN_CTAG_TX;
+	netdev->features |= NETIF_F_HW_VLAN_TX;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
 	netdev->hw_features = netdev->features & ~NETIF_F_LLTX;
-#endif
 	eth_hw_addr_random(netdev);
 }
 
@@ -236,22 +215,6 @@ static int internal_dev_recv(struct vport *vport, struct sk_buff *skb)
 	struct net_device *netdev = netdev_vport_priv(vport)->dev;
 	int len;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
-	if (vlan_tx_tag_present(skb)) {
-		if (unlikely(!__vlan_put_tag(skb,
-					     skb->vlan_proto,
-					     vlan_tx_tag_get(skb))))
-			return 0;
-
-		if (skb->ip_summed == CHECKSUM_COMPLETE)
-			skb->csum = csum_add(skb->csum,
-					     csum_partial(skb->data + (2 * ETH_ALEN),
-							  VLAN_HLEN, 0));
-
-		vlan_set_tci(skb, 0);
-	}
-#endif
-
 	len = skb->len;
 
 	skb_dst_drop(skb);
diff --git a/drivers/staging/openvswitch_nv/vport-lisp.c b/drivers/staging/openvswitch_nv/vport-lisp.c
index 44e9fd386e26..1241c4cff95f 100644
--- a/drivers/staging/openvswitch_nv/vport-lisp.c
+++ b/drivers/staging/openvswitch_nv/vport-lisp.c
@@ -19,7 +19,6 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include <linux/version.h>
 
 #include <linux/in.h>
 #include <linux/ip.h>
@@ -234,7 +233,7 @@ static void ovs_tnl_rcv(struct vport *vport, struct sk_buff *skb,
 
 	skb_dst_drop(skb);
 	nf_reset(skb);
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 	secpath_reset(skb);
 	vlan_set_tci(skb, 0);
 
@@ -330,8 +329,6 @@ static int lisp_socket_init(struct lisp_port *lisp_port, struct net *net)
 	udp_sk(lisp_port->lisp_rcv_socket->sk)->encap_type = UDP_ENCAP_LISP;
 	udp_sk(lisp_port->lisp_rcv_socket->sk)->encap_rcv = lisp_rcv;
 
-	udp_encap_enable();
-
 	return 0;
 
 error_sock:
@@ -442,7 +439,7 @@ static struct sk_buff *handle_offloads(struct sk_buff *skb)
 
 		memcpy(cb, skb->cb, sizeof(cb));
 
-		nskb = __skb_gso_segment(skb, 0, false);
+		nskb = skb_gso_segment(skb, 0);
 		if (IS_ERR(nskb)) {
 			err = PTR_ERR(nskb);
 			goto error;
@@ -506,7 +503,7 @@ static int ovs_tnl_send(struct vport *vport, struct sk_buff *skb,
 
 	tunnel_hlen += sizeof(struct iphdr);
 
-	min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len
+	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
 			+ tunnel_hlen
 			+ (vlan_tx_tag_present(skb) ? VLAN_HLEN : 0);
 
@@ -533,7 +530,7 @@ static int ovs_tnl_send(struct vport *vport, struct sk_buff *skb,
 	nf_reset(skb);
 	secpath_reset(skb);
 	skb_dst_drop(skb);
-	skb_clear_rxhash(skb);
+	skb->rxhash = 0;
 
 	while (skb) {
 		struct sk_buff *next_skb = skb->next;
@@ -557,9 +554,9 @@ static int ovs_tnl_send(struct vport *vport, struct sk_buff *skb,
 		skb_set_transport_header(skb, sizeof(struct iphdr));
 
 		if (next_skb)
-			skb_dst_set(skb, dst_clone(&rt_dst(rt)));
+			skb_dst_set(skb, dst_clone(&rt->dst));
 		else
-			skb_dst_set(skb, &rt_dst(rt));
+			skb_dst_set(skb, &rt->dst);
 
 		/* Push Tunnel header. */
 		build_header(vport, skb, tunnel_hlen);
diff --git a/drivers/staging/openvswitch_nv/vport-netdev.c b/drivers/staging/openvswitch_nv/vport-netdev.c
index 215a47e49ca7..f70664e9f088 100644
--- a/drivers/staging/openvswitch_nv/vport-netdev.c
+++ b/drivers/staging/openvswitch_nv/vport-netdev.c
@@ -25,7 +25,7 @@
 #include <linux/llc.h>
 #include <linux/rtnetlink.h>
 #include <linux/skbuff.h>
-#include <linux/openvswitch.h>
+#include <linux/openvswitch-nv.h>
 
 #include <net/llc.h>
 
@@ -34,20 +34,10 @@
 #include "vport-internal_dev.h"
 #include "vport-netdev.h"
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) && \
-	!defined(HAVE_VLAN_BUG_WORKAROUND)
-#include <linux/module.h>
-
-static int vlan_tso __read_mostly;
-module_param(vlan_tso, int, 0644);
-MODULE_PARM_DESC(vlan_tso, "Enable TSO for VLAN packets");
-#else
 #define vlan_tso true
-#endif
 
 static void netdev_port_receive(struct vport *vport, struct sk_buff *skb);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
 /* Called with rcu_read_lock and bottom-halves disabled. */
 static rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)
 {
@@ -63,67 +53,9 @@ static rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)
 
 	return RX_HANDLER_CONSUMED;
 }
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \
-      defined HAVE_RHEL_OVS_HOOK
-/* Called with rcu_read_lock and bottom-halves disabled. */
-static struct sk_buff *netdev_frame_hook(struct sk_buff *skb)
-{
-	struct vport *vport;
 
-	if (unlikely(skb->pkt_type == PACKET_LOOPBACK))
-		return skb;
-
-	vport = ovs_netdev_get_vport(skb->dev);
-
-	netdev_port_receive(vport, skb);
-
-	return NULL;
-}
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
-/*
- * Used as br_handle_frame_hook.  (Cannot run bridge at the same time, even on
- * different set of devices!)
- */
-/* Called with rcu_read_lock and bottom-halves disabled. */
-static struct sk_buff *netdev_frame_hook(struct net_bridge_port *p,
-					 struct sk_buff *skb)
-{
-	netdev_port_receive((struct vport *)p, skb);
-	return NULL;
-}
-#else
-#error
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \
-    defined HAVE_RHEL_OVS_HOOK
 static int netdev_init(void) { return 0; }
 static void netdev_exit(void) { }
-#else
-static int port_count;
-
-static void netdev_init(void)
-{
-	port_count++;
-	if (port_count > 1)
-		return;
-
-	/* Hook into callback used by the bridge to intercept packets.
-	 * Parasites we are. */
-	br_handle_frame_hook = netdev_frame_hook;
-
-	return;
-}
-
-static void netdev_exit(void)
-{
-	port_count--;
-	if (port_count > 0)
-		return;
-
-	br_handle_frame_hook = NULL;
-}
-#endif
 
 static struct net_device *get_dpdev(struct datapath *dp)
 {
@@ -163,15 +95,11 @@ static struct vport *netdev_create(const struct vport_parms *parms)
 	}
 
 	rtnl_lock();
-	err = netdev_master_upper_dev_link(netdev_vport->dev,
-					   get_dpdev(vport->dp));
-	if (err)
-		goto error_unlock;
 
 	err = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,
 					 vport);
 	if (err)
-		goto error_master_upper_dev_unlink;
+		goto error_unlock;
 
 	dev_set_promiscuity(netdev_vport->dev, 1);
 	netdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;
@@ -180,8 +108,6 @@ static struct vport *netdev_create(const struct vport_parms *parms)
 	netdev_init();
 	return vport;
 
-error_master_upper_dev_unlink:
-	netdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));
 error_unlock:
 	rtnl_unlock();
 error_put:
@@ -209,7 +135,6 @@ static void netdev_destroy(struct vport *vport)
 	rtnl_lock();
 	netdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;
 	netdev_rx_handler_unregister(netdev_vport->dev);
-	netdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));
 	dev_set_promiscuity(netdev_vport->dev, -1);
 	rtnl_unlock();
 
@@ -261,15 +186,8 @@ static unsigned int packet_length(const struct sk_buff *skb)
 
 static bool dev_supports_vlan_tx(struct net_device *dev)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
 	/* Software fallback means every device supports vlan_tci on TX. */
 	return true;
-#elif defined(HAVE_VLAN_BUG_WORKAROUND)
-	return dev->features & NETIF_F_HW_VLAN_TX;
-#else
-	/* Assume that the driver is buggy. */
-	return false;
-#endif
 }
 
 static int netdev_send(struct vport *vport, struct sk_buff *skb)
@@ -352,23 +270,14 @@ drop:
 /* Returns null if this device is not attached to a datapath. */
 struct vport *ovs_netdev_get_vport(struct net_device *dev)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \
-    defined HAVE_RHEL_OVS_HOOK
 #if IFF_OVS_DATAPATH != 0
 	if (likely(dev->priv_flags & IFF_OVS_DATAPATH))
 #else
 	if (likely(rcu_access_pointer(dev->rx_handler) == netdev_frame_hook))
 #endif
-#ifdef HAVE_RHEL_OVS_HOOK
-		return (struct vport *)rcu_dereference_rtnl(dev->ax25_ptr);
-#else
 		return (struct vport *)rcu_dereference_rtnl(dev->rx_handler_data);
-#endif
 	else
 		return NULL;
-#else
-	return (struct vport *)rcu_dereference_rtnl(dev->br_port);
-#endif
 }
 
 const struct vport_ops ovs_netdev_vport_ops = {
@@ -379,22 +288,3 @@ const struct vport_ops ovs_netdev_vport_ops = {
 	.send		= netdev_send,
 };
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) && \
-    !defined HAVE_RHEL_OVS_HOOK
-/*
- * Enforces, mutual exclusion with the Linux bridge module, by declaring and
- * exporting br_should_route_hook.  Because the bridge module also exports the
- * same symbol, the module loader will refuse to load both modules at the same
- * time (e.g. "bridge: exports duplicate symbol br_should_route_hook (owned by
- * openvswitch)").
- *
- * Before Linux 2.6.36, Open vSwitch cannot safely coexist with the Linux
- * bridge module, so openvswitch uses this macro in those versions.  In
- * Linux 2.6.36 and later, Open vSwitch can coexist with the bridge module.
- *
- * The use of "typeof" here avoids the need to track changes in the type of
- * br_should_route_hook over various kernel versions.
- */
-typeof(br_should_route_hook) br_should_route_hook;
-EXPORT_SYMBOL(br_should_route_hook);
-#endif
diff --git a/drivers/staging/openvswitch_nv/vport-vxlan.c b/drivers/staging/openvswitch_nv/vport-vxlan.c
index de49ab164642..7b7ad86dfddb 100644
--- a/drivers/staging/openvswitch_nv/vport-vxlan.c
+++ b/drivers/staging/openvswitch_nv/vport-vxlan.c
@@ -19,7 +19,6 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include <linux/version.h>
 
 #include <linux/in.h>
 #include <linux/ip.h>
@@ -30,7 +29,6 @@
 #include <net/icmp.h>
 #include <net/ip.h>
 #include <net/udp.h>
-#include <net/ip_tunnels.h>
 #include <net/udp.h>
 #include <net/rtnetlink.h>
 #include <net/route.h>
@@ -38,8 +36,9 @@
 #include <net/inet_ecn.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
-#include <net/vxlan.h>
 
+#include "ip_tunnels.h"
+#include "vxlan.h"
 #include "datapath.h"
 #include "vport.h"
 
@@ -77,7 +76,7 @@ static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb, __be32 vx_vni)
 static int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)
 {
 	struct vxlan_port *vxlan_port = vxlan_vport(vport);
-	__be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);
+	__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;
 
 	if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))
 		return -EMSGSIZE;
@@ -141,7 +140,7 @@ error:
 static int vxlan_tnl_send(struct vport *vport, struct sk_buff *skb)
 {
 	struct vxlan_port *vxlan_port = vxlan_vport(vport);
-	__be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);
+	__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;
 	struct net *net = ovs_dp_get_net(vport->dp);
 	struct rtable *rt;
 	__be16 src_port;
diff --git a/drivers/staging/openvswitch_nv/vport.c b/drivers/staging/openvswitch_nv/vport.c
index f62201d8236d..b24c0ae6d8f9 100644
--- a/drivers/staging/openvswitch_nv/vport.c
+++ b/drivers/staging/openvswitch_nv/vport.c
@@ -28,13 +28,23 @@
 #include <linux/rcupdate.h>
 #include <linux/rtnetlink.h>
 #include <linux/compat.h>
-#include <linux/version.h>
+#include <linux/u64_stats_sync.h>
 #include <net/net_namespace.h>
 
 #include "datapath.h"
 #include "vport.h"
 #include "vport-internal_dev.h"
 
+
+
+struct pcpu_tstats {
+	u64     rx_packets;
+	u64     rx_bytes;
+	u64     tx_packets;
+	u64     tx_bytes;
+	struct u64_stats_sync   syncp;
+};
+
 /* List of statically compiled vport implementations.  Don't forget to also
  * add yours to the list at the bottom of vport.h. */
 static const struct vport_ops *vport_ops_list[] = {
@@ -94,8 +104,9 @@ struct vport *ovs_vport_locate(struct net *net, const char *name)
 {
 	struct hlist_head *bucket = hash_bucket(net, name);
 	struct vport *vport;
+	struct hlist_node *node;
 
-	hlist_for_each_entry_rcu(vport, bucket, hash_node)
+	hlist_for_each_entry_rcu(vport, node, bucket, hash_node)
 		if (!strcmp(name, vport->ops->get_name(vport)) &&
 		    net_eq(ovs_dp_get_net(vport->dp), net))
 			return vport;
diff --git a/drivers/staging/openvswitch_nv/vport.h b/drivers/staging/openvswitch_nv/vport.h
index 995889c382b4..0d236b66fbfc 100644
--- a/drivers/staging/openvswitch_nv/vport.h
+++ b/drivers/staging/openvswitch_nv/vport.h
@@ -22,10 +22,16 @@
 #include <linux/if_tunnel.h>
 #include <linux/list.h>
 #include <linux/netlink.h>
-#include <linux/openvswitch.h>
+#include <linux/openvswitch-nv.h>
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 #include <linux/u64_stats_sync.h>
+#include <linux/in.h>
+#include <linux/in_route.h>
+#include <linux/netlink.h>
+#include <net/route.h>
+#include <net/xfrm.h>
+
 
 struct vport;
 struct vport_parms;
@@ -210,4 +216,23 @@ static inline void ovs_skb_postpush_rcsum(struct sk_buff *skb,
 	if (skb->ip_summed == CHECKSUM_COMPLETE)
 		skb->csum = csum_add(skb->csum, csum_partial(start, len, 0));
 }
+
+static inline struct rtable *find_route(struct net *net,
+					__be32 *saddr, __be32 daddr,
+					u8 ipproto, u8 tos, u32 skb_mark)
+{
+	struct rtable *rt;
+	/* Tunnel configuration keeps DSCP part of TOS bits, But Linux
+	 * router expect RT_TOS bits only. */
+
+	struct flowi4 fl = { .daddr = daddr,
+			     .saddr = *saddr,
+			     .flowi4_tos = RT_TOS(tos),
+			     .flowi4_mark = skb_mark,
+			     .flowi4_proto = ipproto };
+
+	rt = ip_route_output_key(net, &fl);
+	*saddr = fl.saddr;
+	return rt;
+}
 #endif /* vport.h */
diff --git a/include/linux/if_ether.h b/include/linux/if_ether.h
index 56d907a2c804..d46039d7dc21 100644
--- a/include/linux/if_ether.h
+++ b/include/linux/if_ether.h
@@ -91,6 +91,12 @@
 #define ETH_P_QINQ3	0x9300		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
 #define ETH_P_EDSA	0xDADA		/* Ethertype DSA [ NOT AN OFFICIALLY REGISTERED ID ] */
 #define ETH_P_AF_IUCV   0xFBFB		/* IBM af_iucv [ NOT AN OFFICIALLY REGISTERED ID ] */
+#ifdef __KERNEL__
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+#define ETH_P_802_3_MIN 0x0600      /* If the value in the ethernet type is less than this value
+                                     * then the frame is Ethernet II. Else it is 802.3 */
+#endif /* CONFIG_OPENVSWITCH_NV */
+#endif
 
 /*
  *	Non DIX types. Won't clash for 1500 types.
diff --git a/include/linux/openvswitch-nv.h b/include/linux/openvswitch-nv.h
index 09c26b56f9fc..c14d9c32a3b5 100644
--- a/include/linux/openvswitch-nv.h
+++ b/include/linux/openvswitch-nv.h
@@ -37,8 +37,8 @@
  * ----------------------------------------------------------------------
  */
 
-#ifndef _LINUX_OPENVSWITCH_H
-#define _LINUX_OPENVSWITCH_H 1
+#ifndef _LINUX_OPENVSWITCH_2_H
+#define _LINUX_OPENVSWITCH_2_H 1
 
 #include <linux/types.h>
 #include <linux/if_ether.h>
@@ -56,6 +56,8 @@ struct ovs_header {
 	int dp_ifindex;
 };
 
+#define OVS_VERSION "v2.0.0"
+
 /* Datapaths. */
 
 #define OVS_DATAPATH_FAMILY  "ovs_datapath"
@@ -551,3 +553,4 @@ enum ovs_action_attr {
 #define OVS_ACTION_ATTR_MAX (__OVS_ACTION_ATTR_MAX - 1)
 
 #endif /* _LINUX_OPENVSWITCH_H */
+
diff --git a/include/net/checksum.h b/include/net/checksum.h
index ba55d8b8c87c..7543cb19dc93 100644
--- a/include/net/checksum.h
+++ b/include/net/checksum.h
@@ -118,4 +118,12 @@ static inline void inet_proto_csum_replace2(__sum16 *sum, struct sk_buff *skb,
 				 (__force __be32)to, pseudohdr);
 }
 
+#ifdef __KERNEL__
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+extern void inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,
+                               const __be32 *from, const __be32 *to,
+                               int pseudohdr);
+#endif /* CONFIG_OPENVSWITCH_NV */
+#endif
+
 #endif
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 117eaa578d0d..63138a3581c4 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -230,6 +230,19 @@ struct ip6_flowlabel {
 	struct net		*fl_net;
 };
 
+#ifdef __KERNEL__
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+enum {
+  OVS_IP6T_FH_F_FRAG      = (1 << 0),
+  OVS_IP6T_FH_F_AUTH      = (1 << 1),
+  OVS_IP6T_FH_F_SKIP_RH   = (1 << 2),
+};
+
+#define NEXTHDR_SCTP    132 /* Stream Control Transport Protocol */
+
+#endif /* CONFIG_OPENVSWITCH_NV */
+#endif
+
 #define IPV6_FLOWINFO_MASK	cpu_to_be32(0x0FFFFFFF)
 #define IPV6_FLOWLABEL_MASK	cpu_to_be32(0x000FFFFF)
 
diff --git a/include/net/netlink.h b/include/net/netlink.h
index f394fe5d7641..8e3fabb1a4c1 100644
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -1069,4 +1069,23 @@ static inline int nla_validate_nested(const struct nlattr *start, int maxtype,
 #define nla_for_each_nested(pos, nla, rem) \
 	nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)
 
+#ifdef __KERNEL__
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+static inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)
+{
+  return nla_put(skb, attrtype, sizeof(__be16), &value);
+}
+
+static inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)
+{
+  return nla_put(skb, attrtype, sizeof(__be32), &value);
+}
+
+static inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value)
+{
+  return nla_put(skb, attrtype, sizeof(__be64), &value);
+}
+#endif /* CONFIG_OPENVSWITCH_NV */ 
+#endif
+
 #endif
diff --git a/include/net/sctp/checksum.h b/include/net/sctp/checksum.h
index befc8d2a1b9f..3f29012f821d 100644
--- a/include/net/sctp/checksum.h
+++ b/include/net/sctp/checksum.h
@@ -81,3 +81,26 @@ static inline __le32 sctp_end_cksum(__be32 crc32)
 {
 	return cpu_to_le32(~crc32);
 }
+
+#ifdef __KERNEL__
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+static inline __le32 sctp_compute_cksum(const struct sk_buff *skb,
+					unsigned int offset)
+{
+	const struct sk_buff *iter;
+
+	__u32 crc32 = sctp_start_cksum(skb->data + offset,
+				       skb_headlen(skb) - offset);
+	skb_walk_frags(skb, iter)
+		crc32 = sctp_update_cksum((__u8 *) iter->data,
+					  skb_headlen(iter), crc32);
+
+	/* Open-code sctp_end_cksum() to avoid a sparse warning due to a bug in
+	 * sparse annotations in Linux fixed in 3.10 in commit eee1d5a14 (sctp:
+	 * Correct type and usage of sctp_end_cksum()). */
+	return cpu_to_le32(~crc32);
+}
+#endif /* CONFIG_OPENVSWITCH_NV */
+#endif
+
+
diff --git a/net/core/utils.c b/net/core/utils.c
index dc3c3faff2f4..c103504fd4f2 100644
--- a/net/core/utils.c
+++ b/net/core/utils.c
@@ -297,6 +297,31 @@ void inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
 }
 EXPORT_SYMBOL(inet_proto_csum_replace4);
 
+#if IS_ENABLED(CONFIG_OPENVSWITCH_NV)
+
+void inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,
+                               const __be32 *from, const __be32 *to,
+                               int pseudohdr)
+{
+        __be32 diff[] = {
+                ~from[0], ~from[1], ~from[2], ~from[3],
+                to[0], to[1], to[2], to[3],
+        };
+        if (skb->ip_summed != CHECKSUM_PARTIAL) {
+                *sum = csum_fold(csum_partial(diff, sizeof(diff),
+                                        ~csum_unfold(*sum)));
+                if (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)
+                        skb->csum = ~csum_partial(diff, sizeof(diff),
+                                        ~skb->csum);
+        } else if (pseudohdr)
+                *sum = ~csum_fold(csum_partial(diff, sizeof(diff),
+                                        csum_unfold(*sum)));
+}
+EXPORT_SYMBOL(inet_proto_csum_replace16);
+
+#endif /* CONFIG_OPENVSWITCH_NV */
+
+
 int mac_pton(const char *s, u8 *mac)
 {
 	int i;
-- 
2.0.1

