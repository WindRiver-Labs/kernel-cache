From 9304199f9e9a0ebe1e41b36d0f3a6cc3512f6005 Mon Sep 17 00:00:00 2001
From: yzhu1 <Yanjun.Zhu@windriver.com>
Date: Tue, 16 Oct 2012 13:06:38 +0800
Subject: [PATCH 5/5] ensure-cache_check-caller-sees-updated-entry

commit fdef7aa5d4020fd94ffcbf0078d6bd9e5a111e19 upstream

Supposes cache_check runs simultaneously with an update on a different
CPU:

        cache_check                     task doing update
        ^^^^^^^^^^^                     ^^^^^^^^^^^^^^^^^

        1. test for CACHE_VALID         1'. set entry->data
           & !CACHE_NEGATIVE

        2. use entry->data              2'. set CACHE_VALID

If the two memory writes performed in step 1' and 2' appear misordered
with respect to the reads in step 1 and 2, then the caller could get
stale data at step 2 even though it saw CACHE_VALID set on the cache
entry.

Add memory barriers to prevent this.

Reviewed-by: NeilBrown <neilb@suse.de>
Signed-off-by: J. Bruce Fields <bfields@redhat.com>
Signed-off-by: yzhu1 <yanjun.zhu@windriver.com>
---
 net/sunrpc/cache.c | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 6202213..9cec9e5 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -115,6 +115,7 @@ static void cache_fresh_locked(struct cache_head *head, time_t expiry)
 {
 	head->expiry_time = expiry;
 	head->last_refresh = seconds_since_boot();
+	smp_wmb(); /* paired with smp_rmb() in cache_is_valid() */
 	set_bit(CACHE_VALID, &head->flags);
 }
 
@@ -196,8 +197,16 @@ static inline int cache_is_valid(struct cache_detail *detail, struct cache_head
 		/* entry is valid */
 		if (test_bit(CACHE_NEGATIVE, &h->flags))
 			return -ENOENT;
-		else
+		else{
+			/*
+			 * In combination with write barrier in
+			 * sunrpc_cache_update, ensures that anyone
+			 * using the cache entry after this sees the
+			 * updated contents:
+			 */
+			smp_rmb();
 			return 0;
+		}
 	}
 }
 
-- 
1.7.12

