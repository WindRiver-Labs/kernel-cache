From f548f7ca1b3f5eaef8830bbf5c836502442f7baf Mon Sep 17 00:00:00 2001
From: yzhu1 <Yanjun.Zhu@windriver.com>
Date: Sat, 29 Sep 2012 10:49:51 +0800
Subject: [PATCH 1/3] ensure-cache_check-caller-sees-updated-entry

commit fdef7aa5d4020fd94ffcbf0078d6bd9e5a111e19 upstream

Supposes cache_check runs simultaneously with an update on a different
CPU:

        cache_check                     task doing update
        ^^^^^^^^^^^                     ^^^^^^^^^^^^^^^^^

        1. test for CACHE_VALID         1'. set entry->data
           & !CACHE_NEGATIVE

        2. use entry->data              2'. set CACHE_VALID

If the two memory writes performed in step 1' and 2' appear misordered
with respect to the reads in step 1 and 2, then the caller could get
stale data at step 2 even though it saw CACHE_VALID set on the cache
entry.

Add memory barriers to prevent this.

Reviewed-by: NeilBrown <neilb@suse.de>
Signed-off-by: J. Bruce Fields <bfields@redhat.com>
Integrated-by: yzhu1 <yanjun.zhu@windriver.com>
---
 net/sunrpc/cache.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index b7af6b2..c390697 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -109,6 +109,7 @@ static void cache_fresh_locked(struct cache_head *head, time_t expiry)
 {
 	head->expiry_time = expiry;
 	head->last_refresh = get_seconds();
+	smp_wmb(); /* paired with smp_rmb() in cache_is_valid() */
 	set_bit(CACHE_VALID, &head->flags);
 }
 
@@ -192,8 +193,16 @@ static inline int cache_is_valid(struct cache_detail *detail, struct cache_head
 		/* entry is valid */
 		if (test_bit(CACHE_NEGATIVE, &h->flags))
 			return -ENOENT;
-		else
+		else{
+			/*
+			 * In combination with write barrier in
+			 * sunrpc_cache_update, ensures that anyone
+			 * using the cache entry after this sees the
+			 * updated contents:
+			 */
+			smp_rmb();
 			return 0;
+		}
 	}
 }
 
-- 
1.7.0

