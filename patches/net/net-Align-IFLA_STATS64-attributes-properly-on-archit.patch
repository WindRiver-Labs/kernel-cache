From 9f6932d116e007809c638c982c77a0c7d8bcd294 Mon Sep 17 00:00:00 2001
From: "David S. Miller" <davem@davemloft.net>
Date: Tue, 19 Apr 2016 14:30:10 -0400
Subject: [PATCH 203/376] net: Align IFLA_STATS64 attributes properly on
 architectures that need it.

commit 18402843bf88c2e9674e1a3a05c73b7d9b09ee05 upstream

Since the nlattr header is 4 bytes in size, it can cause the netlink
attribute payload to not be 8-byte aligned.

This is particularly troublesome for IFLA_STATS64 which contains 64-bit
statistic values.

Solve this by creating a dummy IFLA_PAD attribute which has a payload
which is zero bytes in size.  When HAVE_EFFICIENT_UNALIGNED_ACCESS is
false, we insert an IFLA_PAD attribute into the netlink response when
necessary such that the IFLA_STATS64 payload will be properly aligned.

With help and suggestions from Eric Dumazet.

Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 include/uapi/linux/if_link.h |    1 +
 net/core/rtnetlink.c         |   19 +++++++++++++++++++
 2 files changed, 20 insertions(+), 0 deletions(-)

diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index d058b1e..523d6ed 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -148,6 +148,7 @@ enum {
 	IFLA_PHYS_SWITCH_ID,
 	IFLA_LINK_NETNSID,
 	IFLA_PHYS_PORT_NAME,
+	IFLA_PAD,
 	__IFLA_MAX
 };
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index f7a9150..96227bc 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -874,6 +874,9 @@ static noinline size_t if_nlmsg_size(const struct net_device *dev,
 	       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */
 	       + nla_total_size(sizeof(struct rtnl_link_ifmap))
 	       + nla_total_size(sizeof(struct rtnl_link_stats))
+#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
+	       + nla_total_size(0) /* IFLA_PAD */
+#endif
 	       + nla_total_size(sizeof(struct rtnl_link_stats64))
 	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
 	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */
@@ -1039,6 +1042,22 @@ static noinline_for_stack int rtnl_fill_stats(struct sk_buff *skb,
 	struct rtnl_link_stats64 temp;
 	struct nlattr *attr;
 
+#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
+	/* IF necessary, add a zero length NOP attribute so that the
+	 * nla_data() of the IFLA_STATS64 will be 64-bit aligned.
+	 *
+	 * The nlattr header is 4 bytes in size, that's why we test
+	 * if the skb->data _is_ aligned.  This NOP attribute, plus
+	 * nlattr header for IFLA_STATS64, will make nla_data() 8-byte
+	 * aligned.
+	 */
+	if (IS_ALIGNED((unsigned long)skb->data, 8)) {
+		attr = nla_reserve(skb, IFLA_PAD, 0);
+		if (!attr)
+			return -EMSGSIZE;
+	}
+#endif
+
 	stats = dev_get_stats(dev, &temp);
 
 	attr = nla_reserve(skb, IFLA_STATS,
-- 
1.7.5.4

