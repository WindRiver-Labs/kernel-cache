From 6f2557ed88a40c2eefbb8126c5898a04a227f9fa Mon Sep 17 00:00:00 2001
From: Catalin Enache <catalin.enache@windriver.com>
Date: Fri, 18 Mar 2016 17:09:49 +0200
Subject: [PATCH] ipv6: Add missing route selection code

This is a follow-up patch to a4e902e ipv6: fix route selection
if kernel is not compiled with CONFIG_IPV6_ROUTER_PREF

We did a backport of an upstream commit but unfortunately this
wasn't complete, some upstream code is missing.

The initial test results were inaccurate and the initial
patch was integrated. It turns out that IPv6 route selection is not
working as expected after initial patch was ported.

With this patch we're completing the initial backporting.

Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 net/ipv6/route.c |   10 ++++++----
 1 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index c404be7..de3652a 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -473,7 +473,7 @@ static inline enum rt6_nud_state rt6_check_neigh(struct rt6_info *rt)
 	neigh = dst_get_neighbour_noref(&rt->dst);
 	if (rt->rt6i_flags & RTF_NONEXTHOP ||
 	    !(rt->rt6i_flags & RTF_GATEWAY))
-		return RT6_NUD_SUCCEED;
+		ret = RT6_NUD_SUCCEED;
 	else if (neigh) {
 		read_lock_bh(&neigh->lock);
 		if (neigh->nud_state & NUD_VALID)
@@ -495,11 +495,11 @@ static inline enum rt6_nud_state rt6_check_neigh(struct rt6_info *rt)
 static int rt6_score_route(struct rt6_info *rt, int oif,
 			   int strict)
 {
-	int m, n;
+	int m;
 
 	m = rt6_check_dev(rt, oif);
 	if (!m && (strict & RT6_LOOKUP_F_IFACE))
-		return -1;
+		return RT6_NUD_FAIL_HARD;
 #ifdef CONFIG_IPV6_ROUTER_PREF
 	m |= IPV6_DECODE_PREF(IPV6_EXTRACT_PREF(rt->rt6i_flags)) << 2;
 #endif
@@ -529,12 +529,14 @@ static struct rt6_info *find_match(struct rt6_info *rt, int oif, int strict,
 		goto out;
 	}
 
+	if (strict & RT6_LOOKUP_F_REACHABLE)
+		rt6_probe(rt);
+
 	if (m > *mpri) {
 		*do_rr = match_do_rr;
 		*mpri = m;
 		match = rt;
 	}
-
 out:
 	return match;
 }
-- 
1.7.5.4

