From e45b8d6a36203d89e5350ffb908e23f4b5751364 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 12 Dec 2013 13:39:00 +0800
Subject: [PATCH 2/2] net: fix the softirq handling in process_backlog()

The implementation of processing net-rx softirq in process_backlog()
is not correct, the work done variable is not compared against quota
variable properly, this may lead to two possible kernel panic for
both Non-NAPI and NAPI devices:
1). "WARN_ON_ONCE(work > weight)" in net_rx_action() could be
triggered after return from process_backlog().
To describe this scenario, we can set /proc/sys/net/core/dev_weight
to 0, so in net_rx_action() function, quota is assigned to 0 when
calling process_backlog(), thus, this poll function will return after
the first round loop and work variable would be returned as 1, so
"work > weight" is definitely true.
2). A use-after-delete problem for list entry could happen when
dev_weight is zero:
Check the below call chain:
  net_rx_action()
      process_backlog()
          __napi_complete()
      list_move_tail()
the napi poll_list is first deleted in __napi_complete(), then
net_rx_action() will try to delete it again in list_move_tail().

To resolve these problems, we could compare the work variable with
quota at the beginning of this loop, and increment it after deliver
a skb to upper layer.

Since 2.6.35, this issue is not present due to change 6e7676c1a("net:
batch skb dequeueing from softnet input_pkt_queue") which has already
changed the logic in a similar manner, but we won't adopt it because
it is made for RPS(Receive Packet Steering) feature and 2.6.34 kernel
share very few same context with this fix.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 net/core/dev.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/net/core/dev.c b/net/core/dev.c
index 67c5a05..97d34d6 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2934,7 +2934,7 @@ static int process_backlog(struct napi_struct *napi, int quota)
 	struct softnet_data *queue = &__get_cpu_var(softnet_data);
 
 	napi->weight = weight_p;
-	do {
+	while (work < quota) {
 		struct sk_buff *skb;
 
 		local_irq_disable();
@@ -2947,7 +2947,8 @@ static int process_backlog(struct napi_struct *napi, int quota)
 		local_irq_enable();
 
 		netif_receive_skb(skb);
-	} while (++work < quota);
+		++work;
+	}
 
 	return work;
 }
-- 
1.7.0

