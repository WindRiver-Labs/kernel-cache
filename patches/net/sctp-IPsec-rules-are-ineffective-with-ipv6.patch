From c23e9e2a4afe26b98dd565986d057fb9064ff814 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Fri, 13 Aug 2010 14:36:53 -0400
Subject: [PATCH 2/2] sctp: IPsec rules are ineffective with ipv6

For ipv6, sctp doesn't implement the IPsec mechanism thus it can't support
IPsec on IPv6. Enable the IPsec rules with sctp ipv6.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>

[ Integrated into the 2.6.34 kernel from the original
  commit cdc4104da8077bfe420d296b5d7cfa72d2418358.
  Had to modify the original patch due to the change in the
  signature of the __xfrm_lookup() function in the newer kernel
  which has an extra parameter of type struct net *
  To handle this a call was added to sock_net() to get the
  net and pass that into the new __xfrm_lookup() function.
  Original overall design of the patch is maintained. ]

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 net/sctp/ipv6.c |   26 ++++++++++++++++++++++++++
 1 files changed, 26 insertions(+), 0 deletions(-)

diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 9fb5d37..e7e6e2d 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -244,6 +244,7 @@ static struct dst_entry *sctp_v6_get_dst(struct sctp_association *asoc,
 {
 	struct dst_entry *dst;
 	struct flowi fl;
+	int err;
 
 	memset(&fl, 0, sizeof(fl));
 	ipv6_addr_copy(&fl.fl6_dst, &daddr->v6.sin6_addr);
@@ -261,11 +262,36 @@ static struct dst_entry *sctp_v6_get_dst(struct sctp_association *asoc,
 	dst = ip6_route_output(&init_net, NULL, &fl);
 	if (!dst->error) {
 		struct rt6_info *rt;
+		struct sock *sk;
+		struct net *net = NULL;
 		rt = (struct rt6_info *)dst;
 		SCTP_DEBUG_PRINTK("rt6_dst:%pI6 rt6_src:%pI6\n",
 			&rt->rt6i_dst.addr, &rt->rt6i_src.addr);
+		if (saddr)
+		{
+			sk = asoc ? asoc->base.sk : NULL;
+#ifdef CONFIG_NET_NS
+			/* in this config sock_net() doesn't check for
+			 * null pointers before dereferencing sk.  Need to
+			 * ensure sk is valid before calling sock_net()
+			 */
+			if (sk)
+#endif
+			net = sock_net(sk);
+			fl.proto = IPPROTO_SCTP;
+			if (sk) fl.oif = sk->sk_bound_dev_if;
+			fl.fl_ip_dport = daddr->v6.sin6_port;
+			fl.fl_ip_sport = saddr->v6.sin6_port;
+			if ((err = __xfrm_lookup(net, &dst, &fl, sk, 0)) < 0) {
+				if (err == -EREMOTE)
+					err = ip6_dst_blackhole(sk, &dst, &fl);
+				if (err < 0)
+					goto failure;
+			}
+		}
 		return dst;
 	}
+failure:
 	SCTP_DEBUG_PRINTK("NO ROUTE\n");
 	dst_release(dst);
 	return NULL;
-- 
1.6.5.2

