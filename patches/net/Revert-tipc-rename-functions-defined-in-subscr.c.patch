From 8c6cff100389f254ef26571c0cdd58430976a746 Mon Sep 17 00:00:00 2001
From: Zhenbo Gao <zhenbo.gao@windriver.com>
Date: Wed, 28 Mar 2018 16:39:51 +0800
Subject: [PATCH 015/376] Revert "tipc: rename functions defined in subscr.c"

This reverts commit ddd2210cb475868fd3a080d54d8c952581e8b120.

A big patch set for upgrading TIPC(to v4.16-rc6) will come soon

Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 net/tipc/core.c       |    4 +-
 net/tipc/name_table.c |   34 +++++++++-----
 net/tipc/subscr.c     |  116 +++++++++++++++++++++++++++----------------------
 net/tipc/subscr.h     |   20 ++++----
 4 files changed, 98 insertions(+), 76 deletions(-)

diff --git a/net/tipc/core.c b/net/tipc/core.c
index 005ba5e..be1c9fa 100644
--- a/net/tipc/core.c
+++ b/net/tipc/core.c
@@ -68,7 +68,7 @@ static int __net_init tipc_init_net(struct net *net)
 	if (err)
 		goto out_nametbl;
 
-	err = tipc_topsrv_start(net);
+	err = tipc_subscr_start(net);
 	if (err)
 		goto out_subscr;
 	return 0;
@@ -83,7 +83,7 @@ out_sk_rht:
 
 static void __net_exit tipc_exit_net(struct net *net)
 {
-	tipc_topsrv_stop(net);
+	tipc_subscr_stop(net);
 	tipc_net_stop(net);
 	tipc_nametbl_stop(net);
 	tipc_sk_rht_destroy(net);
diff --git a/net/tipc/name_table.c b/net/tipc/name_table.c
index 0f47f08..ab0ac62 100644
--- a/net/tipc/name_table.c
+++ b/net/tipc/name_table.c
@@ -330,9 +330,13 @@ static struct publication *tipc_nameseq_insert_publ(struct net *net,
 
 	/* Any subscriptions waiting for notification?  */
 	list_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {
-		tipc_subscrp_report_overlap(s, publ->lower, publ->upper,
-					    TIPC_PUBLISHED, publ->ref,
-					    publ->node, created_subseq);
+		tipc_subscr_report_overlap(s,
+					   publ->lower,
+					   publ->upper,
+					   TIPC_PUBLISHED,
+					   publ->ref,
+					   publ->node,
+					   created_subseq);
 	}
 	return publ;
 }
@@ -400,9 +404,13 @@ found:
 
 	/* Notify any waiting subscriptions */
 	list_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {
-		tipc_subscrp_report_overlap(s, publ->lower, publ->upper,
-					    TIPC_WITHDRAWN, publ->ref,
-					    publ->node, removed_subseq);
+		tipc_subscr_report_overlap(s,
+					   publ->lower,
+					   publ->upper,
+					   TIPC_WITHDRAWN,
+					   publ->ref,
+					   publ->node,
+					   removed_subseq);
 	}
 
 	return publ;
@@ -424,17 +432,19 @@ static void tipc_nameseq_subscribe(struct name_seq *nseq,
 		return;
 
 	while (sseq != &nseq->sseqs[nseq->first_free]) {
-		if (tipc_subscrp_check_overlap(s, sseq->lower, sseq->upper)) {
+		if (tipc_subscr_overlap(s, sseq->lower, sseq->upper)) {
 			struct publication *crs;
 			struct name_info *info = sseq->info;
 			int must_report = 1;
 
 			list_for_each_entry(crs, &info->zone_list, zone_list) {
-				tipc_subscrp_report_overlap(s, sseq->lower,
-							    sseq->upper,
-							    TIPC_PUBLISHED,
-							    crs->ref, crs->node,
-							    must_report);
+				tipc_subscr_report_overlap(s,
+							   sseq->lower,
+							   sseq->upper,
+							   TIPC_PUBLISHED,
+							   crs->ref,
+							   crs->node,
+							   must_report);
 				must_report = 0;
 			}
 		}
diff --git a/net/tipc/subscr.c b/net/tipc/subscr.c
index 7117913..948f316 100644
--- a/net/tipc/subscr.c
+++ b/net/tipc/subscr.c
@@ -42,12 +42,12 @@
  * struct tipc_subscriber - TIPC network topology subscriber
  * @conid: connection identifier to server connecting to subscriber
  * @lock: control access to subscriber
- * @subscrp_list: list of subscription objects for this subscriber
+ * @subscription_list: list of subscription objects for this subscriber
  */
 struct tipc_subscriber {
 	int conid;
 	spinlock_t lock;
-	struct list_head subscrp_list;
+	struct list_head subscription_list;
 };
 
 /**
@@ -62,9 +62,9 @@ static u32 htohl(u32 in, int swap)
 	return swap ? swab32(in) : in;
 }
 
-static void tipc_subscrp_send_event(struct tipc_subscription *sub,
-				    u32 found_lower, u32 found_upper,
-				    u32 event, u32 port_ref, u32 node)
+static void subscr_send_event(struct tipc_subscription *sub, u32 found_lower,
+			      u32 found_upper, u32 event, u32 port_ref,
+			      u32 node)
 {
 	struct tipc_net *tn = net_generic(sub->net, tipc_net_id);
 	struct tipc_subscriber *subscriber = sub->subscriber;
@@ -82,13 +82,12 @@ static void tipc_subscrp_send_event(struct tipc_subscription *sub,
 }
 
 /**
- * tipc_subscrp_check_overlap - test for subscription overlap with the
- * given values
+ * tipc_subscr_overlap - test for subscription overlap with the given values
  *
  * Returns 1 if there is overlap, otherwise 0.
  */
-int tipc_subscrp_check_overlap(struct tipc_subscription *sub, u32 found_lower,
-			       u32 found_upper)
+int tipc_subscr_overlap(struct tipc_subscription *sub, u32 found_lower,
+			u32 found_upper)
 {
 	if (found_lower < sub->seq.lower)
 		found_lower = sub->seq.lower;
@@ -99,20 +98,24 @@ int tipc_subscrp_check_overlap(struct tipc_subscription *sub, u32 found_lower,
 	return 1;
 }
 
-void tipc_subscrp_report_overlap(struct tipc_subscription *sub, u32 found_lower,
-				 u32 found_upper, u32 event, u32 port_ref,
-				 u32 node, int must)
+/**
+ * tipc_subscr_report_overlap - issue event if there is subscription overlap
+ *
+ * Protected by nameseq.lock in name_table.c
+ */
+void tipc_subscr_report_overlap(struct tipc_subscription *sub, u32 found_lower,
+				u32 found_upper, u32 event, u32 port_ref,
+				u32 node, int must)
 {
-	if (!tipc_subscrp_check_overlap(sub, found_lower, found_upper))
+	if (!tipc_subscr_overlap(sub, found_lower, found_upper))
 		return;
 	if (!must && !(sub->filter & TIPC_SUB_PORTS))
 		return;
 
-	tipc_subscrp_send_event(sub, found_lower, found_upper, event, port_ref,
-				node);
+	subscr_send_event(sub, found_lower, found_upper, event, port_ref, node);
 }
 
-static void tipc_subscrp_timeout(unsigned long data)
+static void subscr_timeout(unsigned long data)
 {
 	struct tipc_subscription *sub = (struct tipc_subscription *)data;
 	struct tipc_subscriber *subscriber = sub->subscriber;
@@ -131,30 +134,35 @@ static void tipc_subscrp_timeout(unsigned long data)
 	tipc_nametbl_unsubscribe(sub);
 
 	/* Unlink subscription from subscriber */
-	list_del(&sub->subscrp_list);
+	list_del(&sub->subscription_list);
 
 	spin_unlock_bh(&subscriber->lock);
 
 	/* Notify subscriber of timeout */
-	tipc_subscrp_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,
-				TIPC_SUBSCR_TIMEOUT, 0, 0);
+	subscr_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,
+			  TIPC_SUBSCR_TIMEOUT, 0, 0);
 
 	/* Now destroy subscription */
 	kfree(sub);
 	atomic_dec(&tn->subscription_count);
 }
 
-static void tipc_subscrp_delete(struct tipc_subscription *sub)
+/**
+ * subscr_del - delete a subscription within a subscription list
+ *
+ * Called with subscriber lock held.
+ */
+static void subscr_del(struct tipc_subscription *sub)
 {
 	struct tipc_net *tn = net_generic(sub->net, tipc_net_id);
 
 	tipc_nametbl_unsubscribe(sub);
-	list_del(&sub->subscrp_list);
+	list_del(&sub->subscription_list);
 	kfree(sub);
 	atomic_dec(&tn->subscription_count);
 }
 
-static void tipc_subscrb_delete(struct tipc_subscriber *subscriber)
+static void subscr_release(struct tipc_subscriber *subscriber)
 {
 	struct tipc_subscription *sub;
 	struct tipc_subscription *sub_temp;
@@ -162,14 +170,14 @@ static void tipc_subscrb_delete(struct tipc_subscriber *subscriber)
 	spin_lock_bh(&subscriber->lock);
 
 	/* Destroy any existing subscriptions for subscriber */
-	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscrp_list,
-				 subscrp_list) {
+	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,
+				 subscription_list) {
 		if (sub->timeout != TIPC_WAIT_FOREVER) {
 			spin_unlock_bh(&subscriber->lock);
 			del_timer_sync(&sub->timer);
 			spin_lock_bh(&subscriber->lock);
 		}
-		tipc_subscrp_delete(sub);
+		subscr_del(sub);
 	}
 	spin_unlock_bh(&subscriber->lock);
 
@@ -178,7 +186,7 @@ static void tipc_subscrb_delete(struct tipc_subscriber *subscriber)
 }
 
 /**
- * tipc_subscrp_cancel - handle subscription cancellation request
+ * subscr_cancel - handle subscription cancellation request
  *
  * Called with subscriber lock held. Routine must temporarily release lock
  * to enable the subscription timeout routine to finish without deadlocking;
@@ -186,16 +194,16 @@ static void tipc_subscrb_delete(struct tipc_subscriber *subscriber)
  *
  * Note that fields of 's' use subscriber's endianness!
  */
-static void tipc_subscrp_cancel(struct tipc_subscr *s,
-				struct tipc_subscriber *subscriber)
+static void subscr_cancel(struct tipc_subscr *s,
+			  struct tipc_subscriber *subscriber)
 {
 	struct tipc_subscription *sub;
 	struct tipc_subscription *sub_temp;
 	int found = 0;
 
 	/* Find first matching subscription, exit if not found */
-	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscrp_list,
-				 subscrp_list) {
+	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,
+				 subscription_list) {
 		if (!memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr))) {
 			found = 1;
 			break;
@@ -211,12 +219,17 @@ static void tipc_subscrp_cancel(struct tipc_subscr *s,
 		del_timer_sync(&sub->timer);
 		spin_lock_bh(&subscriber->lock);
 	}
-	tipc_subscrp_delete(sub);
+	subscr_del(sub);
 }
 
-static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
-			       struct tipc_subscriber *subscriber,
-			       struct tipc_subscription **sub_p)
+/**
+ * subscr_subscribe - create subscription for subscriber
+ *
+ * Called with subscriber lock held.
+ */
+static int subscr_subscribe(struct net *net, struct tipc_subscr *s,
+			    struct tipc_subscriber *subscriber,
+			    struct tipc_subscription **sub_p)
 {
 	struct tipc_net *tn = net_generic(net, tipc_net_id);
 	struct tipc_subscription *sub;
@@ -228,7 +241,7 @@ static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
 	/* Detect & process a subscription cancellation request */
 	if (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {
 		s->filter &= ~htohl(TIPC_SUB_CANCEL, swap);
-		tipc_subscrp_cancel(s, subscriber);
+		subscr_cancel(s, subscriber);
 		return 0;
 	}
 
@@ -260,14 +273,13 @@ static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
 		kfree(sub);
 		return -EINVAL;
 	}
-	list_add(&sub->subscrp_list, &subscriber->subscrp_list);
+	list_add(&sub->subscription_list, &subscriber->subscription_list);
 	sub->subscriber = subscriber;
 	sub->swap = swap;
-	memcpy(&sub->evt.s, s, sizeof(*s));
+	memcpy(&sub->evt.s, s, sizeof(struct tipc_subscr));
 	atomic_inc(&tn->subscription_count);
 	if (sub->timeout != TIPC_WAIT_FOREVER) {
-		setup_timer(&sub->timer, tipc_subscrp_timeout,
-			    (unsigned long)sub);
+		setup_timer(&sub->timer, subscr_timeout, (unsigned long)sub);
 		mod_timer(&sub->timer, jiffies + sub->timeout);
 	}
 	*sub_p = sub;
@@ -275,22 +287,22 @@ static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
 }
 
 /* Handle one termination request for the subscriber */
-static void tipc_subscrb_shutdown_cb(int conid, void *usr_data)
+static void subscr_conn_shutdown_event(int conid, void *usr_data)
 {
-	tipc_subscrb_delete((struct tipc_subscriber *)usr_data);
+	subscr_release((struct tipc_subscriber *)usr_data);
 }
 
 /* Handle one request to create a new subscription for the subscriber */
-static void tipc_subscrb_rcv_cb(struct net *net, int conid,
-				struct sockaddr_tipc *addr, void *usr_data,
-				void *buf, size_t len)
+static void subscr_conn_msg_event(struct net *net, int conid,
+				  struct sockaddr_tipc *addr, void *usr_data,
+				  void *buf, size_t len)
 {
 	struct tipc_subscriber *subscriber = usr_data;
 	struct tipc_subscription *sub = NULL;
 	struct tipc_net *tn = net_generic(net, tipc_net_id);
 
 	spin_lock_bh(&subscriber->lock);
-	if (tipc_subscrp_create(net, (struct tipc_subscr *)buf, subscriber, &sub))
+	if (subscr_subscribe(net, (struct tipc_subscr *)buf, subscriber, &sub))
 		tipc_conn_terminate(tn->topsrv, subscriber->conid);
 	else
 		tipc_nametbl_subscribe(sub);
@@ -298,7 +310,7 @@ static void tipc_subscrb_rcv_cb(struct net *net, int conid,
 }
 
 /* Handle one request to establish a new subscriber */
-static void *tipc_subscrb_connect_cb(int conid)
+static void *subscr_named_msg_event(int conid)
 {
 	struct tipc_subscriber *subscriber;
 
@@ -308,14 +320,14 @@ static void *tipc_subscrb_connect_cb(int conid)
 		pr_warn("Subscriber rejected, no memory\n");
 		return NULL;
 	}
-	INIT_LIST_HEAD(&subscriber->subscrp_list);
+	INIT_LIST_HEAD(&subscriber->subscription_list);
 	subscriber->conid = conid;
 	spin_lock_init(&subscriber->lock);
 
 	return (void *)subscriber;
 }
 
-int tipc_topsrv_start(struct net *net)
+int tipc_subscr_start(struct net *net)
 {
 	struct tipc_net *tn = net_generic(net, tipc_net_id);
 	const char name[] = "topology_server";
@@ -342,9 +354,9 @@ int tipc_topsrv_start(struct net *net)
 	topsrv->imp			= TIPC_CRITICAL_IMPORTANCE;
 	topsrv->type			= SOCK_SEQPACKET;
 	topsrv->max_rcvbuf_size		= sizeof(struct tipc_subscr);
-	topsrv->tipc_conn_recvmsg	= tipc_subscrb_rcv_cb;
-	topsrv->tipc_conn_new		= tipc_subscrb_connect_cb;
-	topsrv->tipc_conn_shutdown	= tipc_subscrb_shutdown_cb;
+	topsrv->tipc_conn_recvmsg	= subscr_conn_msg_event;
+	topsrv->tipc_conn_new		= subscr_named_msg_event;
+	topsrv->tipc_conn_shutdown	= subscr_conn_shutdown_event;
 
 	strncpy(topsrv->name, name, strlen(name) + 1);
 	tn->topsrv = topsrv;
@@ -353,7 +365,7 @@ int tipc_topsrv_start(struct net *net)
 	return tipc_server_start(topsrv);
 }
 
-void tipc_topsrv_stop(struct net *net)
+void tipc_subscr_stop(struct net *net)
 {
 	struct tipc_net *tn = net_generic(net, tipc_net_id);
 	struct tipc_server *topsrv = tn->topsrv;
diff --git a/net/tipc/subscr.h b/net/tipc/subscr.h
index 36b2f70..33488bd 100644
--- a/net/tipc/subscr.h
+++ b/net/tipc/subscr.h
@@ -54,7 +54,7 @@ struct tipc_subscriber;
  * @filter: event filtering to be done for subscription
  * @timer: timer governing subscription duration (optional)
  * @nameseq_list: adjacent subscriptions in name sequence's subscription list
- * @subscrp_list: adjacent subscriptions in subscriber's subscription list
+ * @subscription_list: adjacent subscriptions in subscriber's subscription list
  * @server_ref: object reference of server port associated with subscription
  * @swap: indicates if subscriber uses opposite endianness in its messages
  * @evt: template for events generated by subscription
@@ -67,17 +67,17 @@ struct tipc_subscription {
 	u32 filter;
 	struct timer_list timer;
 	struct list_head nameseq_list;
-	struct list_head subscrp_list;
+	struct list_head subscription_list;
 	int swap;
 	struct tipc_event evt;
 };
 
-int tipc_subscrp_check_overlap(struct tipc_subscription *sub, u32 found_lower,
-			       u32 found_upper);
-void tipc_subscrp_report_overlap(struct tipc_subscription *sub,
-				 u32 found_lower, u32 found_upper, u32 event,
-				 u32 port_ref, u32 node, int must);
-int tipc_topsrv_start(struct net *net);
-void tipc_topsrv_stop(struct net *net);
- 
+int tipc_subscr_overlap(struct tipc_subscription *sub, u32 found_lower,
+			u32 found_upper);
+void tipc_subscr_report_overlap(struct tipc_subscription *sub, u32 found_lower,
+				u32 found_upper, u32 event, u32 port_ref,
+				u32 node, int must);
+int tipc_subscr_start(struct net *net);
+void tipc_subscr_stop(struct net *net);
+
 #endif
-- 
1.7.5.4

