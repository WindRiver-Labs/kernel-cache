From 8bc994fef8c9933aa9e93d92a65d2b28d6d89142 Mon Sep 17 00:00:00 2001
From: yanjun.zhu <yanjun.zhu@windriver.com>
Date: Thu, 21 Aug 2014 18:02:20 +0800
Subject: [PATCH 1/2] inet: add RCU protection to inet->opt

commit f6d8bd051c391c1c0458a30b2a7abcd939329259 upstream.

We lack proper synchronization to manipulate inet->opt ip_options

Problem is ip_make_skb() calls ip_setup_cork() and
ip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),
without any protection against another thread manipulating inet->opt.

Another thread can change inet->opt pointer and free old one under us.

Use RCU to protect inet->opt (changed to inet->inet_opt).

Instead of handling atomic refcounts, just copy ip_options when
necessary, to avoid cache line dirtying.

We cant insert an rcu_head in struct ip_options since its included in
skb->cb[], so this patch is large because I had to introduce a new
ip_options_rcu structure.

Since commit 4687b258("inet: add RCU protection to inet->opt") is backported
from branch 2.6.32. The function rcu_dereference_protected does not exist in
branch 2.6.32.y while in branch 2.6.34.y has this function. To protect rcu
better and closer to the original commit 39329259 ("inet: add RCU protection
to inet->opt"), this function is inserted.

Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
Cc: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>
[dannf/bwh: backported to Debian's 2.6.32]
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: Willy Tarreau <w@1wt.eu>
[PG: use 2.6.32 patch, since it is closer to 2.6.34 than original
 baseline; drop net/l2tp/l2tp_ip.c chunk as we don't have that file]
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: yanjun.zhu <yanjun.zhu@windriver.com>
---
 net/dccp/ipv4.c        |    3 ++-
 net/ipv4/af_inet.c     |    5 +++--
 net/ipv4/cipso_ipv4.c  |    5 +++--
 net/ipv4/ip_sockglue.c |    6 ++++--
 net/ipv4/tcp_ipv4.c    |    3 ++-
 5 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/net/dccp/ipv4.c b/net/dccp/ipv4.c
index d73f17f..15c3195 100644
--- a/net/dccp/ipv4.c
+++ b/net/dccp/ipv4.c
@@ -60,7 +60,8 @@ int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 
 	nexthop = daddr = usin->sin_addr.s_addr;
 
-	inet_opt = inet->inet_opt;
+	inet_opt = rcu_dereference_protected(inet->inet_opt,
+					     sock_owned_by_user(sk));
 	if (inet_opt != NULL && inet_opt->opt.srr) {
 		if (daddr == 0)
 			return -EINVAL;
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 4dd4aad..16c0a0b 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -153,7 +153,7 @@ void inet_sock_destruct(struct sock *sk)
 	WARN_ON(sk->sk_wmem_queued);
 	WARN_ON(sk->sk_forward_alloc);
 
-	kfree(inet->inet_opt);
+	kfree(rcu_dereference_protected(inet->inet_opt, 1));
 	dst_release(sk->sk_dst_cache);
 	sk_refcnt_debug_dec(sk);
 }
@@ -1071,7 +1071,8 @@ static int inet_sk_reselect_saddr(struct sock *sk)
 	__be32 daddr = inet->inet_daddr;
 	struct ip_options_rcu *inet_opt;
 
-	inet_opt = inet->inet_opt;
+	inet_opt = rcu_dereference_protected(inet->inet_opt,
+					     sock_owned_by_user(sk));
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index f8f3388..eab76f3 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -1932,7 +1932,8 @@ int cipso_v4_sock_setattr(struct sock *sk,
 
 	sk_inet = inet_sk(sk);
 
-	old = sk_inet->inet_opt;
+	old = rcu_dereference_protected(sk_inet->inet_opt, 
+					sock_owned_by_user(sk));
 	if (sk_inet->is_icsk) {
 		sk_conn = inet_csk(sk);
 		if (old)
@@ -2100,7 +2101,7 @@ void cipso_v4_sock_delattr(struct sock *sk)
 	struct inet_sock *sk_inet;
 
 	sk_inet = inet_sk(sk);
-	opt = sk_inet->inet_opt;
+	opt = rcu_dereference_protected(sk_inet->inet_opt, 1);
 	if (opt == NULL || opt->opt.cipso == 0)
 		return;
 
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index d1fe717..6cf6324 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -495,7 +495,8 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 					       optval, optlen);
 		if (err)
 			break;
-		old = inet->inet_opt;
+		old = rcu_dereference_protected(inet->inet_opt, 
+						sock_owned_by_user(sk));
 		if (inet->is_icsk) {
 			struct inet_connection_sock *icsk = inet_csk(sk);
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
@@ -1054,7 +1055,8 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 		struct ip_options *opt = (struct ip_options *)optbuf;
 		struct ip_options_rcu *inet_opt;
 
-		inet_opt = inet->inet_opt;
+		inet_opt = rcu_dereference_protected(inet->inet_opt,
+						     sock_owned_by_user(sk));
 		opt->optlen = 0;
 		if (inet_opt)
 			memcpy(optbuf, &inet_opt->opt,
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 2abcef6..c802df8 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -166,7 +166,8 @@ int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 		return -EAFNOSUPPORT;
 
 	nexthop = daddr = usin->sin_addr.s_addr;
-	inet_opt = inet->inet_opt;
+	inet_opt = rcu_dereference_protected(inet->inet_opt, 
+					     sock_owned_by_user(sk));
 	if (inet_opt && inet_opt->opt.srr) {
 		if (!daddr)
 			return -EINVAL;
-- 
1.7.0

