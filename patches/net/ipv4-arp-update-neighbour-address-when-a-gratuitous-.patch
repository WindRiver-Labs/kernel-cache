From 7525d39e131c6c2d319385b056595672c8e0b912 Mon Sep 17 00:00:00 2001
From: Salam Noureddine <noureddine@aristanetworks.com>
Date: Tue, 24 Dec 2013 14:17:02 -0800
Subject: [PATCH 2/2] ipv4: arp: update neighbour address when a gratuitous
 arp is received and arp_accept is set

commit 56022a8fdd874c56bb61d8c82559e43044d1aa06 upstream

Gratuitous arp packets are useful in switchover scenarios to update
client arp tables as quickly as possible. Currently, the mac address
of a neighbour is only updated after a locktime period has elapsed
since the last update. In most use cases such delays are unacceptable
for network admins. Moreover, the "updated" field of the neighbour
stucture doesn't record the last time the address of a neighbour
changed but records any change that happens to the neighbour. This is
clearly a bug since locktime uses that field as meaning "addr_updated".
With this observation, I was able to perpetuate a stale address by
sending a stream of gratuitous arp packets spaced less than locktime
apart. With this change the address is updated when a gratuitous arp
is received and the arp_accept sysctl is set.

Signed-off-by: Salam Noureddine <noureddine@aristanetworks.com>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Jibin Xu <jibin.xu@windriver.com>
---
 net/ipv4/arp.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 34eaffe..4c9106f 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -734,6 +734,7 @@ static int arp_process(struct sk_buff *skb)
 	int addr_type;
 	struct neighbour *n;
 	struct net *net = dev_net(dev);
+	bool is_garp = false;
 
 	/* arp_rcv below verifies the ARP header and verifies the device
 	 * is ARP'able.
@@ -893,10 +894,12 @@ static int arp_process(struct sk_buff *skb)
 		   It is possible, that this option should be enabled for some
 		   devices (strip is candidate)
 		 */
+		is_garp = arp->ar_op == htons(ARPOP_REQUEST) && tip == sip &&
+			  inet_addr_type(net, sip) == RTN_UNICAST;
+
 		if (n == NULL &&
-		    (arp->ar_op == htons(ARPOP_REPLY) ||
-		     (arp->ar_op == htons(ARPOP_REQUEST) && tip == sip)) &&
-		    inet_addr_type(net, sip) == RTN_UNICAST)
+		    ((arp->ar_op == htons(ARPOP_REPLY)  &&
+		      inet_addr_type(net, sip) == RTN_UNICAST) || is_garp))
 			n = __neigh_lookup(&arp_tbl, &sip, dev, 1);
 	}
 
@@ -916,7 +919,7 @@ static int arp_process(struct sk_buff *skb)
 		if (time_after(n->updated, jiffies))
 			override = 1;
 		else
-			override = time_after(jiffies, n->updated + n->parms->locktime);
+			override = time_after(jiffies, n->updated + (n->parms->locktime) || is_garp);
 
 		/* Broadcast replies and request packets
 		   do not assert neighbour reachability.
-- 
1.7.5.4

