From 14e110c4e249c95fd389db1f39ea0d4eb3ed701b Mon Sep 17 00:00:00 2001
From: Zhenbo Gao <zhenbo.gao@windriver.com>
Date: Wed, 28 Mar 2018 16:39:34 +0800
Subject: [PATCH 013/376] Revert "tipc: involve reference counter for
 subscriber"

This reverts commit f6be6e4aac652e09b62952050a71e2b7b0c2ea58.

A big patch set for upgrading TIPC(to v4.16-rc6) will come soon

Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 net/tipc/subscr.c |  120 ++++++++++++++++++++++++++++++-----------------------
 1 files changed, 68 insertions(+), 52 deletions(-)

diff --git a/net/tipc/subscr.c b/net/tipc/subscr.c
index fd28248..9fb19b4 100644
--- a/net/tipc/subscr.c
+++ b/net/tipc/subscr.c
@@ -40,21 +40,16 @@
 
 /**
  * struct tipc_subscriber - TIPC network topology subscriber
- * @kref: reference counter to tipc_subscription object
  * @conid: connection identifier to server connecting to subscriber
  * @lock: control access to subscriber
  * @subscrp_list: list of subscription objects for this subscriber
  */
 struct tipc_subscriber {
-	struct kref kref;
 	int conid;
 	spinlock_t lock;
 	struct list_head subscrp_list;
 };
 
-static void tipc_subscrp_delete(struct tipc_subscription *sub);
-static void tipc_subscrb_put(struct tipc_subscriber *subscriber);
-
 /**
  * htohl - convert value to endianness used by destination
  * @in: value to convert
@@ -121,34 +116,42 @@ static void tipc_subscrp_timeout(unsigned long data)
 {
 	struct tipc_subscription *sub = (struct tipc_subscription *)data;
 	struct tipc_subscriber *subscriber = sub->subscriber;
+	struct tipc_net *tn = net_generic(sub->net, tipc_net_id);
 
-	/* Notify subscriber of timeout */
-	tipc_subscrp_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,
-				TIPC_SUBSCR_TIMEOUT, 0, 0);
-
+	/* The spin lock per subscriber is used to protect its members */
 	spin_lock_bh(&subscriber->lock);
-	tipc_subscrp_delete(sub);
-	spin_unlock_bh(&subscriber->lock);
 
-	tipc_subscrb_put(subscriber);
-}
+	/* Validate timeout (in case subscription is being cancelled) */
+	if (sub->timeout == TIPC_WAIT_FOREVER) {
+		spin_unlock_bh(&subscriber->lock);
+		return;
+	}
 
-static void tipc_subscrb_kref_release(struct kref *kref)
-{
-	struct tipc_subscriber *subcriber = container_of(kref,
-					    struct tipc_subscriber, kref);
+	/* Unlink subscription from name table */
+	tipc_nametbl_unsubscribe(sub);
 
-	kfree(subcriber);
-}
+	/* Unlink subscription from subscriber */
+	list_del(&sub->subscrp_list);
 
-static void tipc_subscrb_put(struct tipc_subscriber *subscriber)
-{
-	kref_put(&subscriber->kref, tipc_subscrb_kref_release);
+	spin_unlock_bh(&subscriber->lock);
+
+	/* Notify subscriber of timeout */
+	tipc_subscrp_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,
+				TIPC_SUBSCR_TIMEOUT, 0, 0);
+
+	/* Now destroy subscription */
+	kfree(sub);
+	atomic_dec(&tn->subscription_count);
 }
 
-static void tipc_subscrb_get(struct tipc_subscriber *subscriber)
+static void tipc_subscrp_delete(struct tipc_subscription *sub)
 {
-	kref_get(&subscriber->kref);
+	struct tipc_net *tn = net_generic(sub->net, tipc_net_id);
+
+	tipc_nametbl_unsubscribe(sub);
+	list_del(&sub->subscrp_list);
+	kfree(sub);
+	atomic_dec(&tn->subscription_count);
 }
 
 static struct tipc_subscriber *tipc_subscrb_create(int conid)
@@ -160,7 +163,6 @@ static struct tipc_subscriber *tipc_subscrb_create(int conid)
 		pr_warn("Subscriber rejected, no memory\n");
 		return NULL;
 	}
-	kref_init(&subscriber->kref);
 	INIT_LIST_HEAD(&subscriber->subscrp_list);
 	subscriber->conid = conid;
 	spin_lock_init(&subscriber->lock);
@@ -170,48 +172,62 @@ static struct tipc_subscriber *tipc_subscrb_create(int conid)
 
 static void tipc_subscrb_delete(struct tipc_subscriber *subscriber)
 {
-	struct tipc_subscription *sub, *temp;
+	struct tipc_subscription *sub;
+	struct tipc_subscription *sub_temp;
 
 	spin_lock_bh(&subscriber->lock);
+
 	/* Destroy any existing subscriptions for subscriber */
-	list_for_each_entry_safe(sub, temp, &subscriber->subscrp_list,
+	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscrp_list,
 				 subscrp_list) {
-		if (del_timer(&sub->timer)) {
-			tipc_subscrp_delete(sub);
-			tipc_subscrb_put(subscriber);
+		if (sub->timeout != TIPC_WAIT_FOREVER) {
+			spin_unlock_bh(&subscriber->lock);
+			del_timer_sync(&sub->timer);
+			spin_lock_bh(&subscriber->lock);
 		}
+		tipc_subscrp_delete(sub);
 	}
 	spin_unlock_bh(&subscriber->lock);
 
-	tipc_subscrb_put(subscriber);
-}
-
-static void tipc_subscrp_delete(struct tipc_subscription *sub)
-{
-	struct tipc_net *tn = net_generic(sub->net, tipc_net_id);
-
-	tipc_nametbl_unsubscribe(sub);
-	list_del(&sub->subscrp_list);
-	kfree(sub);
-	atomic_dec(&tn->subscription_count);
+	/* Now destroy subscriber */
+	kfree(subscriber);
 }
 
+/**
+ * tipc_subscrp_cancel - handle subscription cancellation request
+ *
+ * Called with subscriber lock held. Routine must temporarily release lock
+ * to enable the subscription timeout routine to finish without deadlocking;
+ * the lock is then reclaimed to allow caller to release it upon return.
+ *
+ * Note that fields of 's' use subscriber's endianness!
+ */
 static void tipc_subscrp_cancel(struct tipc_subscr *s,
 				struct tipc_subscriber *subscriber)
 {
-	struct tipc_subscription *sub, *temp;
+	struct tipc_subscription *sub;
+	struct tipc_subscription *sub_temp;
+	int found = 0;
 
 	/* Find first matching subscription, exit if not found */
-	list_for_each_entry_safe(sub, temp, &subscriber->subscrp_list,
+	list_for_each_entry_safe(sub, sub_temp, &subscriber->subscrp_list,
 				 subscrp_list) {
 		if (!memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr))) {
-			if (del_timer(&sub->timer)) {
-				tipc_subscrp_delete(sub);
-				tipc_subscrb_put(subscriber);
-			}
+			found = 1;
 			break;
 		}
 	}
+	if (!found)
+		return;
+
+	/* Cancel subscription timer (if used), then delete subscription */
+	if (sub->timeout != TIPC_WAIT_FOREVER) {
+		sub->timeout = TIPC_WAIT_FOREVER;
+		spin_unlock_bh(&subscriber->lock);
+		del_timer_sync(&sub->timer);
+		spin_lock_bh(&subscriber->lock);
+	}
+	tipc_subscrp_delete(sub);
 }
 
 static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
@@ -265,11 +281,11 @@ static int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,
 	sub->swap = swap;
 	memcpy(&sub->evt.s, s, sizeof(*s));
 	atomic_inc(&tn->subscription_count);
-	setup_timer(&sub->timer, tipc_subscrp_timeout, (unsigned long)sub);
-	if (sub->timeout != TIPC_WAIT_FOREVER)
-		sub->timeout += jiffies;
-	if (!mod_timer(&sub->timer, sub->timeout))
-		tipc_subscrb_get(subscriber);
+	if (sub->timeout != TIPC_WAIT_FOREVER) {
+		setup_timer(&sub->timer, tipc_subscrp_timeout,
+			    (unsigned long)sub);
+		mod_timer(&sub->timer, jiffies + sub->timeout);
+	}
 	*sub_p = sub;
 	return 0;
 }
-- 
1.7.5.4

