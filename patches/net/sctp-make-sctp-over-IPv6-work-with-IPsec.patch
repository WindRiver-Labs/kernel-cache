From 0bdfbbb18b2a4304c76c42ca409d1f0a75d8f198 Mon Sep 17 00:00:00 2001
From: Vlad Yasevich <vladislav.yasevich@hp.com>
Date: Thu, 17 Oct 2013 15:16:50 +0800
Subject: [PATCH 2/4] sctp: make sctp over IPv6 work with IPsec

commit 9c6a02f41d10dc9fbf5dd42058e8846f38dd2d9a upstream

SCTP never called xfrm_output after it's v6 route lookups so
that never really worked with ipsec.  Additioanlly, we never
passed port nubmers and protocol in the flowi, so any port
based policies were never applied as well.  Now that we can
fixed ipv6 routing lookup code, using ip6_dst_lookup_flow()
and pass port numbers.

Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[XZ: use struct flowi instead of struct flowi6.]
Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 net/sctp/ipv6.c |   42 +++++++++++++++++++++++-------------------
 1 files changed, 23 insertions(+), 19 deletions(-)

diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index c63ec3e..16bcc56 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -263,14 +263,20 @@ static struct dst_entry *sctp_v6_get_dst(struct sctp_association *asoc,
 
 	memset(fl, 0, sizeof(struct flowi));
 	ipv6_addr_copy(&fl->fl6_dst, &daddr->v6.sin6_addr);
+	fl->fl_ip_dport = daddr->v6.sin6_port;
+	fl->proto = IPPROTO_SCTP;
 	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
 		fl->oif = daddr->v6.sin6_scope_id;
 
 
 	SCTP_DEBUG_PRINTK("%s: DST=%pI6 ", __func__, &fl->fl6_dst);
 
+	if (asoc)
+		fl->fl_ip_sport = htons(asoc->base.bind_addr.port);
+
 	if (saddr) {
 		ipv6_addr_copy(&fl->fl6_src, &saddr->v6.sin6_addr);
+		fl->fl_ip_sport = saddr->v6.sin6_port;
 		SCTP_DEBUG_PRINTK("SRC=%pI6 - ", &fl->fl6_src);
 	}
 
@@ -327,6 +333,7 @@ static struct dst_entry *sctp_v6_get_dst(struct sctp_association *asoc,
 	rcu_read_unlock();
 	if (baddr) {
 		ipv6_addr_copy(&fl->fl6_src, &baddr->v6.sin6_addr);
+		fl->fl_ip_sport = baddr->v6.sin6_port;
 		err = ip6_dst_lookup(sk, &dst, fl);
 	}
 
@@ -338,29 +345,26 @@ out:
 		rt = (struct rt6_info *)dst;
 		SCTP_DEBUG_PRINTK("rt6_dst:%pI6 rt6_src:%pI6\n",
 			&rt->rt6i_dst.addr, &fl->fl6_src);
-		if (saddr)
-		{
-			sk = asoc ? asoc->base.sk : NULL;
+
+		sk = asoc ? asoc->base.sk : NULL;
 #ifdef CONFIG_NET_NS
-			/* in this config sock_net() doesn't check for
-			 * null pointers before dereferencing sk.  Need to
-			 * ensure sk is valid before calling sock_net()
-			 */
-			if (sk)
+		/* in this config sock_net() doesn't check for
+		 * null pointers before dereferencing sk.  Need to
+		 * ensure sk is valid before calling sock_net()
+		 */
+		if (sk)
 #endif
 			net = sock_net(sk);
-			if (!net)
+		if (!net)
+			goto failure;
+		if (sk)
+			fl->oif = sk->sk_bound_dev_if;
+		err = __xfrm_lookup(net, &dst, fl, sk, 0);
+		if (err < 0) {
+			if (err == -EREMOTE)
+				err = ip6_dst_blackhole(sk, &dst, fl);
+			if (err < 0)
 				goto failure;
-			fl->proto = IPPROTO_SCTP;
-			if (sk) fl->oif = sk->sk_bound_dev_if;
-			fl->fl_ip_dport = daddr->v6.sin6_port;
-			fl->fl_ip_sport = saddr->v6.sin6_port;
-			if ((err = __xfrm_lookup(net, &dst, fl, sk, 0)) < 0) {
-				if (err == -EREMOTE)
-					err = ip6_dst_blackhole(sk, &dst, fl);
-				if (err < 0)
-					goto failure;
-			}
 		}
 		return dst;
 	}
-- 
1.7.0

