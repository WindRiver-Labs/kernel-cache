From aaca7352de24fe55a42ca44ae7563a2afa229976 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 20 Dec 2011 10:11:38 +0800
Subject: [PATCH 1/4] net: add IFF_SKB_TX_SHARED flag to priv_flags

commit d8873315065f1f527c7c380402cf59b1e1d0ae36 upstream

Pktgen attempts to transmit shared skbs to net devices, which can't be used by
some drivers as they keep state information in skbs.  This patch adds a flag
marking drivers as being able to handle shared skbs in their tx path.  Drivers
are defaulted to being unable to do so, but calling ether_setup enables this
flag, as 90% of the drivers calling ether_setup touch real hardware and can
handle shared skbs.  A subsequent patch will audit drivers to ensure that the
flag is set properly

Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
Reported-by: Jiri Pirko <jpirko@redhat.com>
CC: Robert Olsson <robert.olsson@its.uu.se>
CC: Eric Dumazet <eric.dumazet@gmail.com>
CC: Alexey Dobriyan <adobriyan@gmail.com>
CC: David S. Miller <davem@davemloft.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

[Adjust the value of IFF_TX_SKB_SHARING to meet our kernel need.]

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 include/linux/if.h |    2 ++
 net/core/pktgen.c  |    7 +++++--
 net/ethernet/eth.c |    1 +
 3 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/include/linux/if.h b/include/linux/if.h
index 5c9d1fa..b051a0f 100644
--- a/include/linux/if.h
+++ b/include/linux/if.h
@@ -64,6 +64,8 @@
 #define IFF_BONDING	0x20		/* bonding master or slave	*/
 #define IFF_SLAVE_NEEDARP 0x40		/* need ARPs for validation	*/
 #define IFF_ISATAP	0x80		/* ISATAP interface (RFC4214)	*/
+#define IFF_TX_SKB_SHARING  0x100 	/* The interface supports sharing
+					 * skbs on transmit */
 
 #define IF_GET_IFACE	0x0001		/* for querying only */
 #define IF_GET_PROTO	0x0002
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index 86714d1..9ee876b 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -1015,6 +1015,9 @@ static ssize_t pktgen_if_write(struct file *file,
 		if (len < 0) {
 			return len;
 		}
+		if ((value > 0) &&
+		    (!(pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)))
+			return -ENOTSUPP;
 		i += len;
 		pkt_dev->clone_skb = value;
 
@@ -3637,7 +3640,6 @@ static int pktgen_add_device(struct pktgen_thread *t, const char *ifname)
 	pkt_dev->min_pkt_size = ETH_ZLEN;
 	pkt_dev->max_pkt_size = ETH_ZLEN;
 	pkt_dev->nfrags = 0;
-	pkt_dev->clone_skb = pg_clone_skb_d;
 	pkt_dev->delay_us = pg_delay_d / 1000;
 	pkt_dev->delay_ns = pg_delay_d % 1000;
 	pkt_dev->count = pg_count_d;
@@ -3646,7 +3648,6 @@ static int pktgen_add_device(struct pktgen_thread *t, const char *ifname)
 	pkt_dev->udp_src_max = 9;
 	pkt_dev->udp_dst_min = 9;
 	pkt_dev->udp_dst_max = 9;
-
 	pkt_dev->vlan_p = 0;
 	pkt_dev->vlan_cfi = 0;
 	pkt_dev->vlan_id = 0xffff;
@@ -3657,6 +3658,8 @@ static int pktgen_add_device(struct pktgen_thread *t, const char *ifname)
 	err = pktgen_setup_dev(pkt_dev, ifname);
 	if (err)
 		goto out1;
+	if (pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)
+		pkt_dev->clone_skb = pg_clone_skb_d;
 
 	pkt_dev->entry = proc_create_data(ifname, 0600, pg_proc_dir,
 					  &pktgen_if_fops, pkt_dev);
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index a80839b..022ca6d 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -333,6 +333,7 @@ void ether_setup(struct net_device *dev)
 	dev->addr_len		= ETH_ALEN;
 	dev->tx_queue_len	= 1000;	/* Ethernet wants good queues */
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
+	dev->priv_flags         = IFF_TX_SKB_SHARING;
 
 	memset(dev->broadcast, 0xFF, ETH_ALEN);
 
-- 
1.7.0.4

