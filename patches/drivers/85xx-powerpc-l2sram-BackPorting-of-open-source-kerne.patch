From abfa7c103a0cf03e37a385056757393c8e946155 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 27 Jun 2011 16:41:43 +0800
Subject: [PATCH 29/47] 85xx/powerpc: l2sram: BackPorting of open-source(kernel 2.6.36) changes to USDK (kernel 2.6.35)

* The offset where L2SRAM maps is taken from kernel command line
* cache-sram-offset=<value>
* Updated copyright information as well

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-85xx-powerpc-l2sram-BackPorting-of-open.patch.

Signed-off-by: Harninder Rai <harninder.rai@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 arch/powerpc/sysdev/fsl_85xx_cache_ctlr.h |   12 +++-
 arch/powerpc/sysdev/fsl_85xx_cache_sram.c |   69 +++++++++------------
 arch/powerpc/sysdev/fsl_85xx_l2ctlr.c     |   92 +++++++++++++++--------------
 3 files changed, 86 insertions(+), 87 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_85xx_cache_ctlr.h b/arch/powerpc/sysdev/fsl_85xx_cache_ctlr.h
index 11e8f9f..20b7059 100644
--- a/arch/powerpc/sysdev/fsl_85xx_cache_ctlr.h
+++ b/arch/powerpc/sysdev/fsl_85xx_cache_ctlr.h
@@ -1,9 +1,10 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc
+ * Copyright 2009-2011 Freescale Semiconductor, Inc
  *
  * QorIQ based Cache Controller Memory Mapped Registers
  *
  * Author: Vivek Mahajan <vivek.mahajan@freescale.com>
+ * Modifier: Harninder Rai <harninder.rai@freescale.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -89,8 +90,13 @@ struct mpc85xx_l2ctlr {
 	u8	res9[0x1A4];
 };
 
-extern int instantiate_cache_sram(struct of_device *dev, struct resource *res,
-		bool amp);
+struct sram_parameters {
+	unsigned int sram_size;
+	uint64_t sram_offset;
+};
+
+extern int instantiate_cache_sram(struct of_device *dev,
+		struct sram_parameters sram_params);
 extern void remove_cache_sram(struct of_device *dev);
 
 #endif /* __FSL_85XX_CACHE_CTLR_H__ */
diff --git a/arch/powerpc/sysdev/fsl_85xx_cache_sram.c b/arch/powerpc/sysdev/fsl_85xx_cache_sram.c
index 94eec82..6ebbc99 100644
--- a/arch/powerpc/sysdev/fsl_85xx_cache_sram.c
+++ b/arch/powerpc/sysdev/fsl_85xx_cache_sram.c
@@ -1,9 +1,10 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
  *
  * Simple memory allocator abstraction for QorIQ (P1/P2) based Cache-SRAM
  *
  * Author: Vivek Mahajan <vivek.mahajan@freescale.com>
+ * Modifier: Harninder Rai <harninder.rai@freescale.com>
  *
  * This file is derived from the original work done
  * by Sylvain Munaut for the Bestcomm SRAM allocator.
@@ -24,14 +25,18 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/err.h>
 #include <linux/of_platform.h>
 #include <asm/pgtable.h>
 #include <asm/fsl_85xx_cache_sram.h>
 
+#include "fsl_85xx_cache_ctlr.h"
+
 struct mpc85xx_cache_sram *cache_sram;
 
 void *mpc85xx_cache_sram_alloc(unsigned int size,
-			   phys_addr_t *phys, unsigned int align)
+				phys_addr_t *phys, unsigned int align)
 {
 	unsigned long offset;
 	unsigned long flags;
@@ -75,9 +80,11 @@ void mpc85xx_cache_sram_free(void *ptr)
 }
 EXPORT_SYMBOL(mpc85xx_cache_sram_free);
 
-int __init instantiate_cache_sram(struct of_device *dev, struct resource *res,
-		bool amp)
+int __init instantiate_cache_sram(struct of_device *dev,
+		struct sram_parameters sram_params)
 {
+	int ret = 0;
+
 	if (cache_sram) {
 		dev_err(&dev->dev, "Already initialized cache-sram\n");
 		return -EBUSY;
@@ -89,59 +96,32 @@ int __init instantiate_cache_sram(struct of_device *dev, struct resource *res,
 		return -ENOMEM;
 	}
 
-	cache_sram->base_phys = res->start;
-	cache_sram->size = res->end - res->start + 1;
-
-	if (amp) {
-		cache_sram->size /= 2;
-		if (mfspr(SPRN_PIR))
-			cache_sram->base_phys += cache_sram->size;
-	}
+	cache_sram->base_phys = sram_params.sram_offset;
+	cache_sram->size = sram_params.sram_size;
 
 	if (!request_mem_region(cache_sram->base_phys, cache_sram->size,
 						"fsl_85xx_cache_sram")) {
 		dev_err(&dev->dev, "%s: request memory failed\n",
 				dev->node->full_name);
-		kfree(cache_sram);
-		return -ENXIO;
-	}
-
-	/* P10x/P20x L2 when configured as sram, needs to be zeroized
-	* before using it as a cachable region, else there would be false
-	* ECC errors.
-	*/
-
-	cache_sram->base_virt = ioremap(cache_sram->base_phys,
-				cache_sram->size);
-	if (!cache_sram->base_virt) {
-		dev_err(&dev->dev, "%s: ioremap failed\n",
-				dev->node->full_name);
-		release_mem_region(cache_sram->base_phys, cache_sram->size);
-		kfree(cache_sram);
-		return -ENOMEM;
+		ret = -ENXIO;
+		goto out_free;
 	}
 
-	memset(cache_sram->base_virt, 0, cache_sram->size);
-	iounmap(cache_sram->base_virt);
-
 	cache_sram->base_virt = ioremap_flags(cache_sram->base_phys,
 				cache_sram->size, _PAGE_COHERENT | PAGE_KERNEL);
 	if (!cache_sram->base_virt) {
 		dev_err(&dev->dev, "%s: ioremap_flags failed\n",
 				dev->node->full_name);
-		release_mem_region(cache_sram->base_phys, cache_sram->size);
-		kfree(cache_sram);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out_release;
 	}
 
 	cache_sram->rh = rh_create(sizeof(unsigned int));
 	if (IS_ERR(cache_sram->rh)) {
 		dev_err(&dev->dev, "%s: Unable to create remote heap\n",
 				dev->node->full_name);
-		iounmap(cache_sram->base_virt);
-		release_mem_region(cache_sram->base_phys, cache_sram->size);
-		kfree(cache_sram);
-		return PTR_ERR(cache_sram->rh);
+		ret = PTR_ERR(cache_sram->rh);
+		goto out_unmap;
 	}
 
 	rh_attach_region(cache_sram->rh, 0, cache_sram->size);
@@ -149,7 +129,18 @@ int __init instantiate_cache_sram(struct of_device *dev, struct resource *res,
 
 	dev_info(&dev->dev, "[base:0x%llx, size:0x%x] configured and loaded\n",
 		(unsigned long long)cache_sram->base_phys, cache_sram->size);
+
 	return 0;
+
+out_unmap:
+	iounmap(cache_sram->base_virt);
+
+out_release:
+	release_mem_region(cache_sram->base_phys, cache_sram->size);
+
+out_free:
+	kfree(cache_sram);
+	return ret;
 }
 
 void remove_cache_sram(struct of_device *dev)
diff --git a/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c b/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
index 9fb78d2..15cc380 100644
--- a/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
+++ b/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
@@ -1,9 +1,10 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
  *
  * QorIQ (P1/P2) L2 controller init for Cache-SRAM instantiation
  *
  * Author: Vivek Mahajan <vivek.mahajan@freescale.com>
+ * Modifier: Harninder Rai <harninder.rai@freescale.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -26,29 +27,50 @@
 
 #include "fsl_85xx_cache_ctlr.h"
 
-static char *param;
+static char *sram_size;
+static char *sram_offset;
 struct mpc85xx_l2ctlr __iomem *l2ctlr;
 
 static long get_cache_sram_size(void)
 {
 	unsigned long val;
 
-	if (!param || (strict_strtoul(param, 0, &val) < 0))
+	if (!sram_size || (strict_strtoul(sram_size, 0, &val) < 0))
 		return -EINVAL;
 
 	return val;
 }
 
-static int __init get_cmdline_param(char *str)
+static long get_cache_sram_offset(void)
+{
+	unsigned long val;
+
+	if (!sram_offset || (strict_strtoul(sram_offset, 0, &val) < 0))
+		return -EINVAL;
+
+	return val;
+}
+
+static int __init get_size_from_cmdline(char *str)
+{
+	if (!str)
+		return 0;
+
+	sram_size = str;
+	return 1;
+}
+
+static int __init get_offset_from_cmdline(char *str)
 {
 	if (!str)
 		return 0;
 
-	param = str;
+	sram_offset = str;
 	return 1;
 }
 
-__setup("cache-sram-size=", get_cmdline_param);
+__setup("cache-sram-size=", get_size_from_cmdline);
+__setup("cache-sram-offset=", get_offset_from_cmdline);
 
 static int __devinit mpc85xx_l2ctlr_of_probe(struct of_device *dev,
 					  const struct of_device_id *match)
@@ -58,17 +80,7 @@ static int __devinit mpc85xx_l2ctlr_of_probe(struct of_device *dev,
 	unsigned char ways;
 	const unsigned int *prop;
 	unsigned int l2cache_size;
-	unsigned int sram_size;
-	struct device_node *np;
-	int rc = 1;
-	struct resource rsrc;
-	int i = 0;
-	bool amp = 0;
-	static char *compatible_list[] = {
-					"fsl,MPC85XXRDB-CAMP",
-					"fsl,P2020DS-CAMP",
-					NULL
-				};
+	struct sram_parameters sram_params;
 
 	if (!dev->node) {
 		dev_err(&dev->dev, "Device's OF-node is NULL\n");
@@ -82,53 +94,48 @@ static int __devinit mpc85xx_l2ctlr_of_probe(struct of_device *dev,
 	}
 	l2cache_size = *prop;
 
-	rval = get_cache_sram_size();
-	if (rval <= 0) {
+	sram_params.sram_size  = get_cache_sram_size();
+	if (sram_params.sram_size <= 0) {
 		dev_err(&dev->dev,
 			"Entire L2 as cache, Aborting Cache-SRAM stuff\n");
 		return -EINVAL;
 	}
 
-	rem = l2cache_size % (unsigned int)rval;
-	ways = LOCK_WAYS_FULL * (unsigned int)rval / l2cache_size;
+	sram_params.sram_offset  = get_cache_sram_offset();
+	if (sram_params.sram_offset <= 0) {
+		dev_err(&dev->dev,
+			"Entire L2 as cache, provide a valid sram offset\n");
+		return -EINVAL;
+	}
+
+
+	rem = l2cache_size % sram_params.sram_size;
+	ways = LOCK_WAYS_FULL * sram_params.sram_size / l2cache_size;
 	if (rem || (ways & (ways - 1))) {
 		dev_err(&dev->dev, "Illegal cache-sram-size in command line\n");
 		return -EINVAL;
 	}
 
-	sram_size = (unsigned int)rval;
-
 	l2ctlr = of_iomap(dev->node, 0);
 	if (!l2ctlr) {
 		dev_err(&dev->dev, "Can't map L2 controller\n");
 		return -EINVAL;
 	}
 
-	for_each_compatible_node(np, NULL, "fsl,l2sram")
-			rc = of_address_to_resource(np, 0, &rsrc);
-
-	if (rc) {
-		dev_err(&dev->dev, "l2sram node not found\n");
-		iounmap(l2ctlr);
-		return -EFAULT;
-	}
-
 	/*
 	 * Write bits[0-17] to srbar0
 	 */
 	out_be32(&l2ctlr->srbar0,
-		rsrc.start & L2SRAM_BAR_MSK_LO18);
+		sram_params.sram_offset & L2SRAM_BAR_MSK_LO18);
 
 	/*
 	 * Write bits[18-21] to srbare0
 	 */
 #ifdef CONFIG_PHYS_64BIT
 	out_be32(&l2ctlr->srbarea0,
-		(rsrc.start >> 32) & L2SRAM_BARE_MSK_HI4);
+		(sram_params.sram_offset >> 32) & L2SRAM_BARE_MSK_HI4);
 #endif
 
-	rsrc.end = rsrc.start + sram_size - 1;
-
 	clrsetbits_be32(&l2ctlr->ctl, L2CR_L2E, L2CR_L2FI);
 
 	switch (ways) {
@@ -155,15 +162,7 @@ static int __devinit mpc85xx_l2ctlr_of_probe(struct of_device *dev,
 	}
 	eieio();
 
-	for (i = 0; compatible_list[i] != NULL; i++) {
-		np = of_find_compatible_node(NULL, NULL, compatible_list[i]);
-		if (np) {
-			amp = 1;
-			break;
-		}
-	}
-
-	rval = instantiate_cache_sram(dev, &rsrc, amp);
+	rval = instantiate_cache_sram(dev, sram_params);
 	if (rval < 0) {
 		dev_err(&dev->dev, "Can't instantiate Cache-SRAM\n");
 		iounmap(l2ctlr);
@@ -195,6 +194,9 @@ static struct of_device_id mpc85xx_l2ctlr_of_match[] = {
 		.compatible = "fsl,p1020-l2-cache-controller",
 	},
 	{
+		.compatible = "fsl,p1010-l2-cache-controller",
+	},
+	{
 		.compatible = "fsl,p1011-l2-cache-controller",
 	},
 	{
-- 
1.7.0.4

