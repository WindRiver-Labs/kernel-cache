From ec0857a2e9db122bceeb3f787e2f6189dc352a5d Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:22:44 +0800
Subject: [PATCH 02/47] gianfar: add support for wake-on-packet

The wakeup-user-defined packet is ARP request packet or
unicast packet to board.

Gianfar driver receives the wakeup-user-defined packet to
rx queue#1, the normal packet to rx queue#0.

We set filter table to filer all of packets except the
wake up user defined packet to it.

The rule of the filter table as below
if (arp request to local ip address)
       accept it to queue#1
elif (unicast packet to local mac address)
       accept it to queue#1
else
       reject it
endif
* The local ip/mac address is the ethernet ip/mac address
of the baord

The receive part of eTSEC still continues work to
get the wake up user defined packet and generates interrupt to
wake up the system.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-gianfar-add-support-for-wake-on-packet.patch.

Signed-off-by: Dave Liu <daveliu@freescale.com>
Signed-off-by: Jin Qing <b24347@freescale.com>
Signed-off-by: Li Yang <leoli@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c         |  472 ++++++++++++++++++++++++++++++++++++++++-
 drivers/net/gianfar.h         |   61 +++++-
 drivers/net/gianfar_ethtool.c |   33 ++-
 3 files changed, 540 insertions(+), 26 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 23a9c5a..6eaf4f1 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -10,7 +10,7 @@
  * Maintainer: Kumar Gala
  * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
  *
- * Copyright 2002-2009 Freescale Semiconductor, Inc.
+ * Copyright 2002-2010 Freescale Semiconductor, Inc.
  * Copyright 2007 MontaVista Software, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -82,6 +82,8 @@
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <linux/in.h>
+#include <linux/inetdevice.h>
+#include <sysdev/fsl_soc.h>
 
 #include <asm/io.h>
 #include <asm/reg.h>
@@ -145,6 +147,16 @@ static void gfar_clear_exact_match(struct net_device *dev);
 static void gfar_set_mac_for_addr(struct net_device *dev, int num, u8 *addr);
 static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
+#ifdef CONFIG_PM
+static void gfar_halt_rx(struct net_device *dev);
+static void gfar_halt_tx_nodisable(struct net_device *dev);
+static void gfar_rx_start(struct net_device *dev);
+static void gfar_tx_start(struct net_device *dev);
+static void gfar_enable_filer(struct net_device *dev);
+static int gfar_get_ip(struct net_device *dev);
+static void gfar_config_filer_table(struct net_device *dev);
+#endif
+
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
@@ -172,7 +184,7 @@ static int gfar_init_bds(struct net_device *ndev)
 	struct gfar_priv_rx_q *rx_queue = NULL;
 	struct txbd8 *txbdp;
 	struct rxbd8 *rxbdp;
-	int i, j;
+	int i, j, num;
 
 	for (i = 0; i < priv->num_tx_queues; i++) {
 		tx_queue = priv->tx_queue[i];
@@ -196,7 +208,12 @@ static int gfar_init_bds(struct net_device *ndev)
 		txbdp->status |= TXBD_WRAP;
 	}
 
-	for (i = 0; i < priv->num_rx_queues; i++) {
+	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET))
+		num = priv->num_rx_queues - 1;
+	else
+		num = priv->num_rx_queues;
+
+	for (i = 0; i < num; i++) {
 		rx_queue = priv->rx_queue[i];
 		rx_queue->cur_rx = rx_queue->rx_bd_base;
 		rx_queue->skb_currx = 0;
@@ -241,6 +258,10 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	struct device *dev = &priv->ofdev->dev;
 	struct gfar_priv_tx_q *tx_queue = NULL;
 	struct gfar_priv_rx_q *rx_queue = NULL;
+	struct rxbd8 *wkbdp;
+	unsigned long wk_buf_paddr;
+	unsigned long wk_buf_vaddr;
+	int err = 0;
 
 	priv->total_tx_ring_size = 0;
 	for (i = 0; i < priv->num_tx_queues; i++)
@@ -317,8 +338,50 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	if (gfar_init_bds(ndev))
 		goto cleanup;
 
+	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET)) {
+	/* Alloc wake up rx buffer, wake up buffer need 64 bytes aligned */
+		rx_queue = priv->rx_queue[priv->num_rx_queues - 1];
+		rx_queue->cur_rx = rx_queue->rx_bd_base;
+		vaddr = (unsigned long) dma_alloc_coherent(&priv->ofdev->dev,
+			priv->wk_buffer_size * rx_queue->rx_ring_size  \
+			+ RXBUF_ALIGNMENT, &addr, GFP_KERNEL);
+		if (vaddr == 0) {
+			if (netif_msg_ifup(priv))
+				printk(KERN_ERR
+					"%s:Could not allocate wakeup buffer!\n", ndev->name);
+			err = -ENOMEM;
+			goto wk_buf_fail;
+		}
+
+		priv->wk_buf_vaddr = vaddr;
+		priv->wk_buf_paddr = addr;
+		wk_buf_vaddr = (unsigned long)(vaddr + RXBUF_ALIGNMENT) \
+						& ~(RXBUF_ALIGNMENT - 1);
+		wk_buf_paddr = (unsigned long)(addr + RXBUF_ALIGNMENT) \
+						& ~(RXBUF_ALIGNMENT - 1);
+		priv->wk_buf_align_vaddr = wk_buf_vaddr;
+		priv->wk_buf_align_paddr = wk_buf_paddr;
+
+		/* Setup wake up rx ring and buffer */
+		wkbdp = rx_queue->rx_bd_base;
+		for (i = 0; i < rx_queue->rx_ring_size; i++) {
+			wkbdp->status = RXBD_EMPTY | RXBD_INTERRUPT;
+			wkbdp->length = 0;
+			wkbdp->bufPtr = wk_buf_paddr + priv->wk_buffer_size * i;
+			wkbdp++;
+		}
+
+		/* Set the last descriptor in the ring to wrap */
+		wkbdp--;
+		wkbdp->status |= RXBD_WRAP;
+	}
 	return 0;
 
+wk_buf_fail:
+	dma_free_coherent(&priv->ofdev->dev,
+			priv->wk_buffer_size * rx_queue->rx_ring_size \
+			+ RXBUF_ALIGNMENT, (void *)priv->wk_buf_vaddr,
+			priv->wk_buf_paddr);
 cleanup:
 	free_skb_resources(priv);
 	return -ENOMEM;
@@ -738,7 +801,6 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev)
 			FSL_GIANFAR_DEV_HAS_PADDING |
 			FSL_GIANFAR_DEV_HAS_CSUM |
 			FSL_GIANFAR_DEV_HAS_VLAN |
-			FSL_GIANFAR_DEV_HAS_MAGIC_PACKET |
 			FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
 
 	ctype = of_get_property(np, "phy-connection-type", NULL);
@@ -752,6 +814,9 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev)
 	if (of_get_property(np, "fsl,magic-packet", NULL))
 		priv->device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
 
+	if (of_get_property(np, "fsl,wake-on-filer", NULL))
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_ARP_PACKET;
+
 	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
 
 	/* Find the TBI PHY.  If it's not there, we don't support SGMII */
@@ -1065,6 +1130,7 @@ static int gfar_probe(struct of_device *ofdev,
 	gfar_write(&regs->tqueue, tqueue);
 
 	priv->rx_buffer_size = DEFAULT_RX_BUFFER_SIZE;
+	priv->wk_buffer_size = DEFAULT_WK_BUFFER_SIZE;
 
 	/* Initializing some of the rx/tx queue level parameters */
 	for (i = 0; i < priv->num_tx_queues; i++) {
@@ -1074,15 +1140,18 @@ static int gfar_probe(struct of_device *ofdev,
 		priv->tx_queue[i]->txic = DEFAULT_TXIC;
 	}
 
+	priv->rx_queue[priv->num_rx_queues - 1]->rx_ring_size = DEFAULT_WK_RING_SIZE;
+
+	/* enable filer if using multiple RX queues*/
+	if (priv->num_rx_queues > 1)
+		priv->rx_filer_enable = 1;
+
 	for (i = 0; i < priv->num_rx_queues; i++) {
 		priv->rx_queue[i]->rx_ring_size = DEFAULT_RX_RING_SIZE;
 		priv->rx_queue[i]->rxcoalescing = DEFAULT_RX_COALESCE;
 		priv->rx_queue[i]->rxic = DEFAULT_RXIC;
 	}
 
-	/* enable filer if using multiple RX queues*/
-	if(priv->num_rx_queues > 1)
-		priv->rx_filer_enable = 1;
 	/* Enable most messages by default */
 	priv->msg_enable = (NETIF_MSG_IFUP << 1 ) - 1;
 
@@ -1097,8 +1166,11 @@ static int gfar_probe(struct of_device *ofdev,
 		goto register_fail;
 	}
 
-	device_init_wakeup(&dev->dev,
-		priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET) ||
+	    (priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET)) {
+		device_set_wakeup_capable(&ofdev->dev, true);
+		device_set_wakeup_enable(&ofdev->dev, false);
+	}	
 
 	/* fill out IRQ number and name fields */
 	len_devname = strlen(dev->name);
@@ -1189,6 +1261,134 @@ static int gfar_remove(struct of_device *ofdev)
 }
 
 #ifdef CONFIG_PM
+static void gfar_enable_filer(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 temp;
+
+	lock_rx_qs(priv);
+
+	temp = gfar_read(&regs->rctrl);
+	temp |= RCTRL_FILREN;
+	temp &= ~RCTRL_FSQEN;
+	temp &= ~RCTRL_PRSDEP_MASK;
+	temp |= RCTRL_PRSDEP_L2L3;
+	gfar_write(&regs->rctrl, temp);
+
+	unlock_rx_qs(priv);
+}
+
+static int gfar_get_ip(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct in_device *in_dev = (struct in_device *)dev->ip_ptr;
+	struct in_ifaddr *ifa;
+
+	if (in_dev != NULL) {
+		ifa = (struct in_ifaddr *)in_dev->ifa_list;
+		if (ifa != NULL) {
+			memcpy(priv->ip_addr, &ifa->ifa_address, 4);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+static void gfar_config_filer_table(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	u8 *ip_addr;
+	u32 wakeup_ip, dest_mac_addr_h, dest_mac_addr_l;
+	u32 rqfpr = 0x0;
+	u32 rqfcr = RQFCR_RJE | RQFCR_CMP_MATCH;
+	u8  rqfcr_queue = priv->num_rx_queues - 1;
+	int i;
+
+	if (gfar_get_ip(dev))
+		printk(KERN_ERR "WOL: get the ip address error\n");
+	ip_addr = priv->ip_addr;
+
+	wakeup_ip = (*ip_addr << 24) | (*(ip_addr + 1) << 16) | \
+		    (*(ip_addr + 2) << 8) | (*(ip_addr + 3));
+
+	dest_mac_addr_h = (dev->dev_addr[0] << 16) | \
+			  (dev->dev_addr[1] << 8) | dev->dev_addr[2];
+	dest_mac_addr_l = (dev->dev_addr[3] << 16) | \
+			  (dev->dev_addr[4] << 8) | dev->dev_addr[5];
+
+	lock_rx_qs(priv);
+
+	for(i = 0; i <= MAX_FILER_IDX; i++)
+		gfar_write_filer(priv, i, rqfcr, rqfpr);
+
+	/* ARP request filer, filling the packet to queue #1 */
+	rqfcr = (rqfcr_queue << 10) | RQFCR_AND | RQFCR_CMP_EXACT | RQFCR_PID_MASK;
+	rqfpr = RQFPR_ARQ;
+	gfar_write_filer(priv, 0, rqfcr, rqfpr);
+
+	rqfcr = (rqfcr_queue << 10) | RQFCR_AND | RQFCR_CMP_EXACT | RQFCR_PID_PARSE;
+	rqfpr = RQFPR_ARQ;
+	gfar_write_filer(priv, 1, rqfcr, rqfpr);
+
+	/* DEST_IP address in ARP packet, filling it to queue #1 */
+	rqfcr = (rqfcr_queue << 10) | RQFCR_AND | RQFCR_CMP_EXACT | RQFCR_PID_MASK;
+	rqfpr = FPR_FILER_MASK;
+	gfar_write_filer(priv, 2, rqfcr, rqfpr);
+
+	rqfcr = RQFCR_GPI | (rqfcr_queue << 10) | RQFCR_CMP_EXACT | RQFCR_PID_DIA;
+	rqfpr = wakeup_ip;
+	gfar_write_filer(priv, 3, rqfcr, rqfpr);
+
+	/* Unicast packet, filling it to queue #1 */
+	rqfcr = (rqfcr_queue << 10) | RQFCR_AND | RQFCR_CMP_EXACT | RQFCR_PID_DAH;
+	rqfpr = dest_mac_addr_h;
+	gfar_write_filer(priv, 4, rqfcr, rqfpr);
+
+	rqfcr = RQFCR_GPI | (rqfcr_queue << 10) | RQFCR_CMP_EXACT | RQFCR_PID_DAL;
+	mb();
+	rqfpr = dest_mac_addr_l;
+	gfar_write_filer(priv, 5, rqfcr, rqfpr);
+
+	unlock_rx_qs(priv);
+}
+
+static int gfar_arp_suspend(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	unsigned long flags;
+	u32 tempval;
+
+	netif_device_detach(dev);
+
+	if (netif_running(dev)) {
+		local_irq_save(flags);
+		lock_tx_qs(priv);
+		lock_rx_qs(priv);
+
+		gfar_halt_tx_nodisable(dev);
+
+		/* Disable Tx */
+		tempval = gfar_read(&regs->maccfg1);
+		tempval &= ~MACCFG1_TX_EN;
+		gfar_write(&regs->maccfg1, tempval);
+
+		unlock_rx_qs(priv);
+		unlock_tx_qs(priv);
+		local_irq_restore(flags);
+
+		disable_napi(priv);
+
+		gfar_halt_rx(dev);
+		gfar_config_filer_table(dev);
+		gfar_enable_filer(dev);
+		gfar_rx_start(dev);
+	}
+
+	return 0;
+}
+
 
 static int gfar_suspend(struct device *dev)
 {
@@ -1199,7 +1399,18 @@ static int gfar_suspend(struct device *dev)
 	u32 tempval;
 
 	int magic_packet = priv->wol_en &&
+		(priv->wol_opts & GIANFAR_WOL_MAGIC) &&
 		(priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	int arp_packet = priv->wol_en &&
+		(priv->wol_opts & GIANFAR_WOL_ARP) &&
+		(priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET);
+
+	if (arp_packet) {
+		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 1);
+		pmc_enable_lossless(1);
+		gfar_arp_suspend(ndev);
+		return 0;
+	}
 
 	netif_device_detach(ndev);
 
@@ -1228,6 +1439,7 @@ static int gfar_suspend(struct device *dev)
 		disable_napi(priv);
 
 		if (magic_packet) {
+			pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 1);
 			/* Enable interrupt on Magic Packet */
 			gfar_write(&regs->imask, IMASK_MAG);
 
@@ -1243,6 +1455,28 @@ static int gfar_suspend(struct device *dev)
 	return 0;
 }
 
+static int gfar_arp_resume(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+
+	if (!netif_running(dev)) {
+		netif_device_attach(dev);
+		return 0;
+	}
+
+	gfar_tx_start(dev);
+	stop_gfar(dev);
+	gfar_halt_rx(dev);
+	gfar_init_filer_table(priv);
+	startup_gfar(dev);
+	gfar_rx_start(dev);
+
+	netif_device_attach(dev);
+	enable_napi(priv);
+
+	return 0;
+}
+
 static int gfar_resume(struct device *dev)
 {
 	struct gfar_private *priv = dev_get_drvdata(dev);
@@ -1250,8 +1484,22 @@ static int gfar_resume(struct device *dev)
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	unsigned long flags;
 	u32 tempval;
+
 	int magic_packet = priv->wol_en &&
+		(priv->wol_opts & GIANFAR_WOL_MAGIC) &&
 		(priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	int arp_packet = priv->wol_en &&
+		(priv->wol_opts & GIANFAR_WOL_ARP) &&
+		(priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET);
+
+	if (arp_packet) {
+		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 0);
+		pmc_enable_lossless(0);
+		gfar_arp_resume(ndev);
+		return 0;
+	} else if (magic_packet) {
+		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 0);
+	}
 
 	if (!netif_running(ndev)) {
 		netif_device_attach(ndev);
@@ -1580,6 +1828,71 @@ static void gfar_halt_nodisable(struct net_device *dev)
 	}
 }
 
+#ifdef CONFIG_PM
+/* Halt the receive queues */
+static void gfar_halt_rx(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 tempval;
+	int i = 0;
+
+	/* Disable Rx in MACCFG1  */
+	tempval = gfar_read(&regs->maccfg1);
+	tempval &= ~MACCFG1_RX_EN;
+	gfar_write(&regs->maccfg1, tempval);
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfargrp[i].regs;
+		/* Mask all interrupts */
+		gfar_write(&regs->imask, IMASK_INIT_CLEAR | IMASK_FGPI);
+
+		/* Clear all interrupts */
+		gfar_write(&regs->ievent, IEVENT_INIT_CLEAR);
+	}
+
+	regs = priv->gfargrp[0].regs;
+	/* Stop the DMA, and wait for it to stop */
+	tempval = gfar_read(&regs->dmactrl);
+	if ((tempval & DMACTRL_GRS) != DMACTRL_GRS) {
+		tempval |= DMACTRL_GRS;
+		gfar_write(&regs->dmactrl, tempval);
+
+		while (!(gfar_read(&regs->ievent) & IEVENT_GRSC))
+			cpu_relax();
+	}
+}
+
+/* Halt the transmit queues */
+static void gfar_halt_tx_nodisable(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = NULL;
+	u32 tempval;
+	int i = 0;
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfargrp[i].regs;
+		/* Mask all interrupts */
+		gfar_write(&regs->imask, IMASK_INIT_CLEAR | IMASK_FGPI);
+
+		/* Clear all interrupts */
+		gfar_write(&regs->ievent, IEVENT_INIT_CLEAR);
+	}
+
+	regs = priv->gfargrp[0].regs;
+	/* Stop the DMA, and wait for it to stop */
+	tempval = gfar_read(&regs->dmactrl);
+	if ((tempval & DMACTRL_GTS) != DMACTRL_GTS) {
+		tempval |= DMACTRL_GTS;
+		gfar_write(&regs->dmactrl, tempval);
+
+		while (!(gfar_read(&regs->ievent) & IEVENT_GTSC))
+			cpu_relax();
+	}
+}
+#endif
+
 /* Halt the receive and transmit queues */
 void gfar_halt(struct net_device *dev)
 {
@@ -1749,6 +2062,56 @@ void gfar_start(struct net_device *dev)
 	dev->trans_start = jiffies;
 }
 
+#ifdef CONFIG_PM
+void gfar_rx_start(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 tempval;
+	int i = 0;
+
+	/* Enable Rx in MACCFG1 */
+	tempval = gfar_read(&regs->maccfg1);
+	tempval |= MACCFG1_RX_EN;
+	gfar_write(&regs->maccfg1, tempval);
+
+	/* Make sure we aren't stopped */
+	tempval = gfar_read(&regs->dmactrl);
+	tempval &= ~DMACTRL_GRS;
+	gfar_write(&regs->dmactrl, tempval);
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfargrp[i].regs;
+		/* Clear RHLT, so that the DMA starts polling now */
+		gfar_write(&regs->rstat, priv->gfargrp[i].rstat);
+	}
+}
+
+void gfar_tx_start(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 tempval;
+	int i = 0;
+
+	/* Enable Tx in MACCFG1 */
+	tempval = gfar_read(&regs->maccfg1);
+	tempval |= MACCFG1_TX_EN;
+	gfar_write(&regs->maccfg1, tempval);
+
+	/* Make sure we aren't stopped */
+	tempval = gfar_read(&regs->dmactrl);
+	tempval &= ~DMACTRL_GTS;
+	gfar_write(&regs->dmactrl, tempval);
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfargrp[i].regs;
+		/* Clear THLT, so that the DMA starts polling now */
+		gfar_write(&regs->rstat, priv->gfargrp[i].tstat);
+	}
+}
+#endif
+
 void gfar_configure_coalescing(struct gfar_private *priv,
 	unsigned long tx_mask, unsigned long rx_mask)
 {
@@ -1915,7 +2278,7 @@ static int gfar_enet_open(struct net_device *dev)
 
 	netif_tx_start_all_queues(dev);
 
-	device_set_wakeup_enable(&dev->dev, priv->wol_en);
+	device_set_wakeup_enable(&priv->ofdev->dev, priv->wol_en);
 
 	return err;
 }
@@ -2510,8 +2873,97 @@ static inline void count_errors(unsigned short status, struct net_device *dev)
 	}
 }
 
+static inline unsigned long __wk_phy_to_virt(struct net_device *dev,
+				unsigned long phy)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	unsigned long virt, offset;
+
+	offset = phy - priv->wk_buf_align_paddr;
+	virt = priv->wk_buf_align_vaddr + offset;
+	return virt;
+}
+
+static void gfar_receive_wakeup(struct net_device *dev)
+{
+	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar_priv_rx_q *rx_queue = priv->rx_queue[priv->num_rx_queues-1];
+	struct rxbd8 *bdp = rx_queue->cur_rx;
+	struct sk_buff *skb;
+	unsigned char *data;
+	u16 len;
+	int ret;
+
+	/* get the first full descriptor */
+	while (!(bdp->status & RXBD_EMPTY)) {
+		rmb();
+		if (bdp->status & RXBD_ERR) {
+			printk(KERN_ERR "Wake up packet error!\n");
+			goto out;
+		}
+
+		data = (u8 *)__wk_phy_to_virt(dev, bdp->bufPtr);
+		len = bdp->length;
+		/* allocate the skb */
+		skb = netdev_alloc_skb(dev, len);
+		if (!skb) {
+			dev->stats.rx_dropped++;
+			priv->extra_stats.rx_skbmissing++;
+			goto out;
+		}
+		/* The wake up packet has the FCB */
+		data += (GMAC_FCB_LEN + priv->padding);
+		len -= (GMAC_FCB_LEN + priv->padding);
+		/* remove the FCS from the packet length */
+		len -= 4;
+		/* copy received packet to skb buffer */
+		memcpy(skb->data, data, len);
+		/* Prep the skb for the packet */
+		skb_put(skb, len);
+		/* Tell the skb what kind of packet this is */
+		skb->protocol = eth_type_trans(skb, dev);
+
+		ret = netif_rx(skb);
+		if (NET_RX_DROP == ret) {
+			priv->extra_stats.kernel_dropped++;
+		} else {
+			/* Increment the number of packets */
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += len;
+		}
+
+out:
+		bdp->status &= RXBD_CLEAN;
+		bdp->status |= RXBD_EMPTY;
+		bdp->length = 0;
+
+		mb();
+		/* Update to the next pointer */
+		if (bdp->status & RXBD_WRAP)
+			bdp = priv->wk_bd_base;
+		else
+			bdp++;
+
+	}
+	rx_queue->cur_rx = bdp;
+}
+
 irqreturn_t gfar_receive(int irq, void *grp_id)
 {
+	struct gfar_priv_grp *gfargrp = grp_id;
+	struct gfar __iomem *regs = gfargrp->regs;
+	struct gfar_private *priv = gfargrp->priv;
+	struct net_device *dev = priv->ndev;
+	u32 ievent;
+
+	ievent = gfar_read(&regs->ievent);
+
+	if ((ievent & IEVENT_FGPI) == IEVENT_FGPI) {
+		gfar_write(&regs->ievent, ievent & IEVENT_RX_MASK);
+		gfar_receive_wakeup(dev);
+		return IRQ_HANDLED;
+	}
+
 	gfar_schedule_cleanup((struct gfar_priv_grp *)grp_id);
 	return IRQ_HANDLED;
 }
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index 9c23f12..2a18c48 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -9,7 +9,7 @@
  * Maintainer: Kumar Gala
  * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
  *
- * Copyright 2002-2009 Freescale Semiconductor, Inc.
+ * Copyright 2002-2010 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -85,6 +85,8 @@ extern const char gfar_driver_version[];
 /* These need to be powers of 2 for this driver */
 #define DEFAULT_TX_RING_SIZE	256
 #define DEFAULT_RX_RING_SIZE	256
+#define DEFAULT_WK_RING_SIZE	16
+
 
 #define GFAR_RX_MAX_RING_SIZE   256
 #define GFAR_TX_MAX_RING_SIZE   256
@@ -94,6 +96,7 @@ extern const char gfar_driver_version[];
 #define GFAR_MAX_FIFO_STARVE_OFF 511
 
 #define DEFAULT_RX_BUFFER_SIZE  1536
+#define DEFAULT_WK_BUFFER_SIZE	2048
 #define TX_RING_MOD_MASK(size) (size-1)
 #define RX_RING_MOD_MASK(size) (size-1)
 #define JUMBO_BUFFER_SIZE 9728
@@ -221,6 +224,14 @@ extern const char gfar_driver_version[];
 #define RQUEUE_EN7		0x00000001
 #define RQUEUE_EN_ALL		0x000000FF
 
+/* Wake-On-Lan options */
+#define GIANFAR_WOL_PHY		(1 << 0)
+#define GIANFAR_WOL_UCAST	(1 << 1)
+#define GIANFAR_WOL_MCAST	(1 << 2)
+#define GIANFAR_WOL_BCAST	(1 << 3)
+#define GIANFAR_WOL_ARP		(1 << 4)
+#define GIANFAR_WOL_MAGIC	(1 << 5)
+
 /* Init to do tx snooping for buffers and descriptors */
 #define DMACTRL_INIT_SETTINGS   0x000000c3
 #define DMACTRL_GRS             0x00000010
@@ -265,11 +276,15 @@ extern const char gfar_driver_version[];
 #define RCTRL_PAL_MASK		0x001f0000
 #define RCTRL_VLEX		0x00002000
 #define RCTRL_FILREN		0x00001000
+#define RCTRL_FSQEN		0x00000800
 #define RCTRL_GHTX		0x00000400
 #define RCTRL_IPCSEN		0x00000200
 #define RCTRL_TUCSEN		0x00000100
 #define RCTRL_PRSDEP_MASK	0x000000c0
 #define RCTRL_PRSDEP_INIT	0x000000c0
+#define RCTRL_PRSDEP_L2	0x00000040
+#define RCTRL_PRSDEP_L2L3	0x00000080
+#define RCTRL_PRSDEP_L2L3L4	0x000000c0
 #define RCTRL_PROM		0x00000008
 #define RCTRL_EMEN		0x00000002
 #define RCTRL_REQ_PARSER	(RCTRL_VLEX | RCTRL_IPCSEN | \
@@ -314,18 +329,20 @@ extern const char gfar_driver_version[];
 #define IEVENT_MAG		0x00000800
 #define IEVENT_GRSC		0x00000100
 #define IEVENT_RXF0		0x00000080
+#define IEVENT_FGPI		0x00000010
 #define IEVENT_FIR		0x00000008
 #define IEVENT_FIQ		0x00000004
 #define IEVENT_DPE		0x00000002
 #define IEVENT_PERR		0x00000001
-#define IEVENT_RX_MASK          (IEVENT_RXB0 | IEVENT_RXF0 | IEVENT_BSY)
+#define IEVENT_RX_MASK          (IEVENT_RXB0 | IEVENT_RXF0 | \
+					IEVENT_FGPI | IEVENT_BSY)
 #define IEVENT_TX_MASK          (IEVENT_TXB | IEVENT_TXF)
 #define IEVENT_RTX_MASK         (IEVENT_RX_MASK | IEVENT_TX_MASK)
 #define IEVENT_ERR_MASK         \
 (IEVENT_RXC | IEVENT_BSY | IEVENT_EBERR | IEVENT_MSRO | \
  IEVENT_BABT | IEVENT_TXC | IEVENT_TXE | IEVENT_LC \
- | IEVENT_CRL | IEVENT_XFUN | IEVENT_DPE | IEVENT_PERR \
- | IEVENT_MAG | IEVENT_BABR)
+ | IEVENT_CRL | IEVENT_XFUN | IEVENT_FIR | IEVENT_FIQ \
+ | IEVENT_DPE | IEVENT_PERR | IEVENT_MAG | IEVENT_BABR)
 
 #define IMASK_INIT_CLEAR	0x00000000
 #define IMASK_BABR              0x80000000
@@ -346,14 +363,15 @@ extern const char gfar_driver_version[];
 #define IMASK_MAG		0x00000800
 #define IMASK_GRSC              0x00000100
 #define IMASK_RXFEN0		0x00000080
+#define IMASK_FGPI		0x00000010
 #define IMASK_FIR		0x00000008
 #define IMASK_FIQ		0x00000004
 #define IMASK_DPE		0x00000002
 #define IMASK_PERR		0x00000001
 #define IMASK_DEFAULT  (IMASK_TXEEN | IMASK_TXFEN | IMASK_TXBEN | \
 		IMASK_RXFEN0 | IMASK_BSY | IMASK_EBERR | IMASK_BABR | \
-		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_DPE \
-		| IMASK_PERR)
+		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_FGPI | \
+		IMASK_FIR | IMASK_FIQ | IMASK_DPE | IMASK_PERR)
 #define IMASK_RTX_DISABLED ((~(IMASK_RXFEN0 | IMASK_TXFEN | IMASK_BSY)) \
 			   & IMASK_DEFAULT)
 
@@ -506,6 +524,7 @@ extern const char gfar_driver_version[];
 #define RXBD_OVERRUN		0x0002
 #define RXBD_TRUNCATED		0x0001
 #define RXBD_STATS		0x01ff
+#define RXBD_CLEAN              0x3000
 #define RXBD_ERR		(RXBD_LARGE | RXBD_SHORT | RXBD_NONOCTET 	\
 				| RXBD_CRCERR | RXBD_OVERRUN			\
 				| RXBD_TRUNCATED)
@@ -525,6 +544,8 @@ extern const char gfar_driver_version[];
 
 #define GFAR_INT_NAME_MAX	IFNAMSIZ + 4
 
+#define GIANFAR_WOL_MAGIC       (1 << 5)
+
 struct txbd8
 {
 	union {
@@ -885,6 +906,7 @@ struct gfar {
 #define FSL_GIANFAR_DEV_HAS_MAGIC_PACKET	0x00000100
 #define FSL_GIANFAR_DEV_HAS_BD_STASHING		0x00000200
 #define FSL_GIANFAR_DEV_HAS_BUF_STASHING	0x00000400
+#define FSL_GIANFAR_DEV_HAS_ARP_PACKET		0x00001000
 
 #if (MAXGROUPS == 2)
 #define DEFAULT_MAPPING 	0xAA
@@ -1066,6 +1088,20 @@ struct gfar_private {
 
 	u32 cur_filer_idx;
 
+	/* wake up ring */
+	struct rxbd8 *wk_bd_base;
+	struct rxbd8 *cur_wk;
+
+	/* wake up ring parameters */
+	unsigned int wk_ring_size;
+	unsigned int wk_buffer_size;
+
+	/* wake up buffer */
+	unsigned long wk_buf_vaddr;
+	unsigned long wk_buf_paddr;
+	unsigned long wk_buf_align_vaddr;
+	unsigned long wk_buf_align_paddr;
+
 	struct sk_buff_head rx_recycle;
 
 	struct vlan_group *vlgrp;
@@ -1105,6 +1141,9 @@ struct gfar_private {
 
 	struct work_struct reset_task;
 
+	u8 ip_addr[4];
+	int wol_opts;
+
 	/* Network Statistics */
 	struct gfar_extra_stats extra_stats;
 };
@@ -1130,6 +1169,16 @@ static inline void gfar_write(volatile unsigned __iomem *addr, u32 val)
 	out_be32(addr, val);
 }
 
+static inline void gfar_read_filer(struct gfar_private *priv,
+		unsigned int far, u32 *fcr, u32 *fpr)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+
+	gfar_write(&regs->rqfar, far);
+	*fcr = gfar_read(&regs->rqfcr);
+	*fpr = gfar_read(&regs->rqfpr);
+}
+
 static inline void gfar_write_filer(struct gfar_private *priv,
 		unsigned int far, unsigned int fcr, unsigned int fpr)
 {
diff --git a/drivers/net/gianfar_ethtool.c b/drivers/net/gianfar_ethtool.c
index ddab703..54f8d13 100644
--- a/drivers/net/gianfar_ethtool.c
+++ b/drivers/net/gianfar_ethtool.c
@@ -9,7 +9,7 @@
  *  Maintainer: Kumar Gala
  *  Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
  *
- *  Copyright 2003-2006, 2008-2009 Freescale Semiconductor, Inc.
+ *  Copyright 2003-2006, 2008-2010 Freescale Semiconductor, Inc.
  *
  *  This software may be used and distributed according to
  *  the terms of the GNU Public License, Version 2, incorporated herein
@@ -37,6 +37,7 @@
 #include <linux/ethtool.h>
 #include <linux/mii.h>
 #include <linux/phy.h>
+#include <asm/of_device.h>
 
 #include "gianfar.h"
 
@@ -615,11 +616,17 @@ static void gfar_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 {
 	struct gfar_private *priv = netdev_priv(dev);
 
+	wol->supported = 0;
+	wol->wolopts = 0;
+
 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET) {
-		wol->supported = WAKE_MAGIC;
-		wol->wolopts = priv->wol_en ? WAKE_MAGIC : 0;
-	} else {
 		wol->supported = wol->wolopts = 0;
+		wol->supported |= WAKE_MAGIC;
+		wol->wolopts |= priv->wol_en ? WAKE_MAGIC : 0;
+	}
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET) {
+		wol->supported |= WAKE_ARP;
+		wol->wolopts |= priv->wol_en ? WAKE_ARP : 0;
 	}
 }
 
@@ -629,15 +636,21 @@ static int gfar_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	unsigned long flags;
 
 	if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET) &&
-	    wol->wolopts != 0)
-		return -EINVAL;
-
-	if (wol->wolopts & ~WAKE_MAGIC)
+	    !(priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET))
 		return -EINVAL;
 
 	spin_lock_irqsave(&priv->bflock, flags);
-	priv->wol_en = wol->wolopts & WAKE_MAGIC ? 1 : 0;
-	device_set_wakeup_enable(&dev->dev, priv->wol_en);
+	if (wol->wolopts & WAKE_MAGIC) {
+		priv->wol_en = 1;
+		priv->wol_opts = GIANFAR_WOL_MAGIC;
+	} else if (wol->wolopts & WAKE_ARP) {
+		priv->wol_en = 1;
+		priv->wol_opts = GIANFAR_WOL_ARP;
+	} else {
+		priv->wol_en = 0;
+		priv->wol_opts = 0;
+	}
+	device_set_wakeup_enable(&priv->ofdev->dev, priv->wol_en);
 	spin_unlock_irqrestore(&priv->bflock, flags);
 
 	return 0;
-- 
1.7.0.2

