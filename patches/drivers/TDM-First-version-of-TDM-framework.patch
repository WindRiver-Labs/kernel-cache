From 3cb8f65e70d30d4d16c89d9067d295a9384343b9 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 11 Aug 2011 17:57:24 +0800
Subject: [PATCH 1/5] TDM:First version of TDM framework

- TDM CORE
	-Supports Channelized mode
	-Supports maintaining list of ports,devices(adapter),drivers
	-Supports Interleaving and De-interleaving
	-Supports Port open and close
	-Attaching and detaching of drivers with device(adapter)
- TDM DEV
	-Register with TDM Core
	-Supports user interface eg: open, close, read, write, and IOCTL's
- TDM FSL_STARLITE
	-Driver for FSL_STARLITE, configuring and intializing  the tdm
	-Register with the TDM Core

Signed-off-by: Rajesh Gumasta <Rajesh.Gumasta@freescale.com>

[Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
Fixed context to apply to Wind River kernel tree.]

Integrated-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/boot/dts/p1020rdb.dts    |    9 +
 drivers/Kconfig                       |    3 +
 drivers/Makefile                      |    1 +
 drivers/tdm/Kconfig                   |   38 ++
 drivers/tdm/Makefile                  |   11 +
 drivers/tdm/device/Kconfig            |   15 +
 drivers/tdm/device/Makefile           |    9 +
 drivers/tdm/device/tdm_fsl_starlite.c |  830 +++++++++++++++++++++++++
 drivers/tdm/device/tdm_fsl_starlite.h |  433 +++++++++++++
 drivers/tdm/tdm-core.c                | 1096 +++++++++++++++++++++++++++++++++
 drivers/tdm/tdm-dev.c                 |  386 ++++++++++++
 include/linux/mod_devicetable.h       |   11 +
 include/linux/tdm-dev.h               |   58 ++
 include/linux/tdm.h                   |  319 ++++++++++
 14 files changed, 3219 insertions(+), 0 deletions(-)
 create mode 100644 drivers/tdm/Kconfig
 create mode 100644 drivers/tdm/Makefile
 create mode 100644 drivers/tdm/device/Kconfig
 create mode 100644 drivers/tdm/device/Makefile
 create mode 100644 drivers/tdm/device/tdm_fsl_starlite.c
 create mode 100644 drivers/tdm/device/tdm_fsl_starlite.h
 create mode 100644 drivers/tdm/tdm-core.c
 create mode 100644 drivers/tdm/tdm-dev.c
 create mode 100644 include/linux/tdm-dev.h
 create mode 100644 include/linux/tdm.h

diff --git a/arch/powerpc/boot/dts/p1020rdb.dts b/arch/powerpc/boot/dts/p1020rdb.dts
index df52690..fff178a 100644
--- a/arch/powerpc/boot/dts/p1020rdb.dts
+++ b/arch/powerpc/boot/dts/p1020rdb.dts
@@ -300,6 +300,15 @@
 			gpio-controller;
 		};
 
+		tdm@16000 {
+			device_type = "tdm";
+			compatible = "fsl,starlite-tdm";
+			reg = <0x16000 0x200 0x2c000 0x2000>;
+			clock-frequency = <0>;
+			interrupts = <63 8 62 8>;
+			interrupt-parent = < &mpic >;
+		};
+
 		L2: l2-cache-controller@20000 {
 			compatible = "fsl,p1020-l2-cache-controller";
 			reg = <0x20000 0x1000>;
diff --git a/drivers/Kconfig b/drivers/Kconfig
index a2b902f..0a17225 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -111,4 +111,7 @@ source "drivers/xen/Kconfig"
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
+source "drivers/tdm/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index b64e7f1..12101ef 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -113,3 +113,4 @@ obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-y				+= tdm/
diff --git a/drivers/tdm/Kconfig b/drivers/tdm/Kconfig
new file mode 100644
index 0000000..bb56461
--- /dev/null
+++ b/drivers/tdm/Kconfig
@@ -0,0 +1,38 @@
+#
+# TDM subsystem configuration
+#
+
+menuconfig TDM
+	tristate "TDM support"
+	---help---
+	  More information is contained in the directory <file:Documentation/tdm/>,
+	  especially in the file called "summary" there.
+	  If you want TDM support, you should say Y here and also to the
+	  specific driver for your bus adapter(s) below.
+
+	  This TDM support can also be built as a module.  If so, the module
+	  will be called tdm-core.
+
+if TDM
+
+config TDM_CHARDEV
+	tristate "TDM device interface"
+	default n
+	help
+	  Say Y here to use tdm-dev device files, usually found in the /dev
+	  directory on your system.  They make it possible to have user-space
+	  programs use the TDM device. Information on how to do this is
+	  contained in the file <file:Documentation/tdm/dev-interface>.
+
+	  This support is also available as a module.  If so, the module
+	  will be called tdm-dev.
+
+config TDM_DEBUG_CORE
+	bool "TDM Core debugging messages"
+	help
+	  Say Y here if you want the TDM core to produce a bunch of debug
+	  messages to the system log.  Select this if you are having a
+	  problem with TDM support and want to see more of what is going on.
+
+source drivers/tdm/device/Kconfig
+endif # TDM
diff --git a/drivers/tdm/Makefile b/drivers/tdm/Makefile
new file mode 100644
index 0000000..468cded
--- /dev/null
+++ b/drivers/tdm/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the TDM core.
+#
+
+obj-$(CONFIG_TDM)		+= tdm-core.o
+obj-$(CONFIG_TDM_CHARDEV)	+= tdm-dev.o
+obj-y				+= device/
+
+ifeq ($(CONFIG_TDM_DEBUG_CORE),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/drivers/tdm/device/Kconfig b/drivers/tdm/device/Kconfig
new file mode 100644
index 0000000..1c4e3ba
--- /dev/null
+++ b/drivers/tdm/device/Kconfig
@@ -0,0 +1,15 @@
+#
+# Sensor device configuration
+#
+
+menu "TDM Device support"
+
+config TDM_FSL_STARLITE
+        tristate "Driver for Freescale Starlite TDM controller"
+        depends on FSL_SOC
+        ---help---
+          This is a driver for Freescale Starlite TDM controller. The controller
+          is found in various Freescale SOCs viz MPC8315, P1020. The TDM driver
+          basically multiplexes and demultiplexes data from different channels.
+          The TDM can interface SLIC kind of devices.
+endmenu
diff --git a/drivers/tdm/device/Makefile b/drivers/tdm/device/Makefile
new file mode 100644
index 0000000..ed07d86
--- /dev/null
+++ b/drivers/tdm/device/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the TDM bus drivers.
+#
+
+obj-$(CONFIG_TDM_FSL_STARLITE)	+= tdm_fsl_starlite.o
+
+#ifeq ($(CONFIG_TDM_DEBUG_BUS),y)
+#EXTRA_CFLAGS += -DDEBUG
+#endif
diff --git a/drivers/tdm/device/tdm_fsl_starlite.c b/drivers/tdm/device/tdm_fsl_starlite.c
new file mode 100644
index 0000000..f032e3f
--- /dev/null
+++ b/drivers/tdm/device/tdm_fsl_starlite.c
@@ -0,0 +1,830 @@
+/*
+ * drivers/misc/tdm_fsl_starlite.c
+ *
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * TDM driver for Freescale Starlite TDM controller.
+ * This driver can interface with SLIC device to run VOIP kind of
+ * applications.
+ *
+ * Author: P. V. Suresh <pala@freescale.com>
+ * Hemant Agrawal <hemant@freescale.com>
+ * Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+ /* Note that this is a complete rewrite of P.V. Suresh's starlite driver code.
+    But we have used so much of his original code and ideas that it seems
+    only fair to recognize him as co-author -- Rajesh & Hemant */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/tdm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <sysdev/fsl_soc.h>
+
+#include "tdm_fsl_starlite.h"
+
+#define DRV_DESC "Freescale Starlite TDM Driver Adapter"
+#define DRV_NAME "tdm_fsl_starlite"
+
+static int tdmen = 1;
+
+module_param(tdmen, int, S_IRUSR);
+MODULE_PARM_DESC(tdmen, "Enable TDM: Enable=1, Disable=0(default)");
+
+/* Initialize the Tx Transmit Control Discriptor parameters*/
+static void tx_tcd_init(struct tdm_priv *priv)
+{
+	int i;
+	u32 iter;
+	u32 offset;
+	dma_addr_t physaddr;
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(priv->cfg.num_ch * priv->cfg.ch_width, 8);
+
+	iter = bytes_in_fifo_per_frame / 8 * priv->cfg.num_frames;
+
+	for (i = 0; i < NUM_OF_TDM_BUF; i++) {
+		offset = i * priv->cfg.num_frames * bytes_in_fifo_per_frame;
+		/* saddr */
+		priv->dma_tx_tcd[i]->tcd[0] = priv->dma_output_paddr + offset;
+
+		/* ssize=dsize=64bit, soff=8, smod=dmod=0 */
+		priv->dma_tx_tcd[i]->tcd[1] =
+		    DMA_TCD1_SOFF(0x08) | DMA_TCD1_SSIZE(SSIZE_64BITS) |
+		    DMA_TCD1_DSIZE(SSIZE_64BITS);
+
+		/* number of bytes for minor loop, wide fifo 8bytes for dma */
+		priv->dma_tx_tcd[i]->tcd[2] = 0x08;
+
+		/* slast = 0 */
+		priv->dma_tx_tcd[i]->tcd[3] = 0x0;
+
+		/* dadr = TX FIFO */
+		priv->dma_tx_tcd[i]->tcd[4] = TDM_TDR_OFFSET + priv->ptdm_base;
+
+		/* channel to channel linking is disabled ,
+		 * destination offset is inc destination adr by 8,
+		 * current iteration(citer) = number of transfers for frame
+		 */
+		priv->dma_tx_tcd[i]->tcd[5] = DMA_TCD5_CITER_DISABLE_LINK(iter);
+
+		/* enable scater gather, interrupt on 1 Frame, */
+		priv->dma_tx_tcd[i]->tcd[7] =
+		    DMA_TCD7_BITER_DISABLE_LINK(iter) | DMA_TCD7_E_SG;
+		priv->dma_tx_tcd[i]->tcd[6] = 0;
+	}
+
+	/* Next TCD for SG operation */
+	physaddr = priv->dma_tx_tcd_paddr;
+	priv->dma_tx_tcd[2]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+	physaddr += TCD_BUFFER_SIZE;
+	priv->dma_tx_tcd[0]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+	physaddr += TCD_BUFFER_SIZE;
+	priv->dma_tx_tcd[1]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+}
+
+/* Initialize the Rx Transmit Control Discriptor parameters*/
+static void rx_tcd_init(struct tdm_priv *priv)
+{
+	int i;
+	u32 iter;
+	u32 offset;
+	dma_addr_t physaddr;
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(priv->cfg.num_ch * priv->cfg.ch_width, 8);
+
+	iter = bytes_in_fifo_per_frame / 8 * priv->cfg.num_frames;
+
+	for (i = 0; i < NUM_OF_TDM_BUF; i++) {
+		/* TDM RX fifo address */
+		priv->dma_rx_tcd[i]->tcd[0] = TDM_RDR_OFFSET + priv->ptdm_base;
+
+		/* ssize=dsize=64bit, soff=smod=dmod=0 */
+		priv->dma_rx_tcd[i]->tcd[1] =
+		    DMA_TCD1_SSIZE(SSIZE_64BITS) | DMA_TCD1_DSIZE(SSIZE_64BITS);
+
+		/* number of bytes for minor loop, wide fifo 8bytes for dma */
+		priv->dma_rx_tcd[i]->tcd[2] = 8;
+
+		/* slast = 0 */
+		priv->dma_rx_tcd[i]->tcd[3] = 0;
+
+		offset = i * priv->cfg.num_frames * bytes_in_fifo_per_frame;
+
+		/* dadr = rx buffer address */
+		priv->dma_rx_tcd[i]->tcd[4] = priv->dma_input_paddr + offset;
+
+		/* channel to channel linking is disabled ,
+		 * destination offset is inc destination adr by 8,
+		 * current iteration(citer) = number of transfers for frame
+		 */
+		priv->dma_rx_tcd[i]->tcd[5] =
+		    DMA_TCD5_DOFF(0x08) | DMA_TCD5_CITER_DISABLE_LINK(iter);
+
+		/* enable scater gather, interrupt on 1 Frame, */
+		priv->dma_rx_tcd[i]->tcd[7] =
+		    DMA_TCD7_BITER_DISABLE_LINK(iter) | DMA_TCD7_E_SG |
+		    DMA_TCD7_INT_MAJ;
+		priv->dma_rx_tcd[i]->tcd[6] = 0;
+	}
+
+	/* Next TCD for SG operation */
+	physaddr = priv->dma_rx_tcd_paddr;
+	priv->dma_rx_tcd[2]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+	physaddr += TCD_BUFFER_SIZE;
+	priv->dma_rx_tcd[0]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+	physaddr += TCD_BUFFER_SIZE;
+	priv->dma_rx_tcd[1]->tcd[6] =
+	    ALIGN_SIZE(physaddr, ALIGNED_32_BYTES);
+}
+
+static irqreturn_t tdm_err_isr(int irq, void *p)
+{
+	int ret = IRQ_NONE;
+	u32 status, mask, val;
+	u32 dmac_err;
+	struct tdm_priv *priv = p;
+	u8 ch;
+
+	/* transmit errors */
+	status = in_be32(&priv->tdm_regs->ter);
+	mask = in_be32(&priv->tdm_regs->tier);
+	val = status & mask;
+	out_be32(&priv->tdm_regs->ter, val);
+
+	/* Transmit under Run error */
+	if (val & TIER_TUEE)
+		dev_err(priv->device, "TDM::Transmit Under Run error\n");
+
+	/* Transmit Sync Error */
+	if (val & TIER_TSEEE)
+		dev_err(priv->device, "TDM::Transmit Sync error\n");
+
+	if (val)
+		ret = IRQ_HANDLED;
+
+	/* receive errors */
+	status = in_be32(&priv->tdm_regs->rer);
+	mask = in_be32(&priv->tdm_regs->rier);
+	val = status & mask;
+	out_be32(&priv->tdm_regs->rer, val);
+
+	/* Receiver Over run error */
+	if (val & RIER_ROEE)
+		dev_err(priv->device, "TDM::Receive  Over Run error\n");
+
+	/* Receive Sync Error  */
+	if (val & RIER_RSEEE)
+		dev_err(priv->device, "TDM::Receive Sync error\n");
+
+	if (val)
+		ret = IRQ_HANDLED;
+
+	/* Handling of DMA Errors */
+	dmac_err = in_be32(&priv->dmac_regs->dmaes);
+	if (!(dmac_err & DMAES_VLD))
+		return ret;
+
+	ch = DMAES_ERRCHN(dmac_err);
+
+	if (dmac_err & DMAES_CPE)
+		dev_err(priv->device, "TDM::Channel priority error\n");
+	if (dmac_err & DMAES_GPE)
+		dev_err(priv->device, "TDM::Group priority error\n");
+	if (dmac_err & DMAES_SAE)
+		dev_err(priv->device, "TDM::Source address error\n");
+	if (dmac_err & DMAES_SOE)
+		dev_err(priv->device, "TDM::Source offset error\n");
+	if (dmac_err & DMAES_DAE)
+		dev_err(priv->device, "TDM::Destination address error\n");
+	if (dmac_err & DMAES_DOE)
+		dev_err(priv->device, "TDM::Destination offset error\n");
+	if (dmac_err & DMAES_NCE)
+		dev_err(priv->device, "TDM::Nbytes citer error\n");
+	if (dmac_err & DMAES_SGE)
+		dev_err(priv->device, "TDM::Scatter gather error\n");
+	if (dmac_err & DMAES_DBE)
+		dev_err(priv->device, "TDM::Destination bus error\n");
+	if (dmac_err & DMAES_SBE)
+		dev_err(priv->device, "TDM::Source bus error\n");
+
+	/* Clear the error */
+	out_8(&priv->dmac_regs->dmacerr, ch);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dmac_done_isr(int irq, void *p)
+{
+	u32 ch;
+	int ret = IRQ_NONE;
+	struct tdm_priv *priv = p;
+
+	ch = in_be32(&priv->dmac_regs->dmaintl);
+
+	/* clear interrupt */
+	if (ch & DMAC_RX_INT) {
+		out_8(&priv->dmac_regs->dmacint, TDMRX_DMA_CH);
+		ret = IRQ_HANDLED;
+		/* track phases for Rx/Tx */
+		priv->phase_rx += 1;
+		if (priv->phase_rx == NUM_OF_TDM_BUF)
+			priv->phase_rx = 0;
+	}
+	if (ch & DMAC_TX_INT) {
+		out_8(&priv->dmac_regs->dmacint, TDMTX_DMA_CH);
+		ret = IRQ_HANDLED;
+	}
+
+	if (ret == IRQ_HANDLED) {
+		/* set the flag and wake up the thread */
+		priv->adap->tdm_rx_flag = 1;
+
+		/* schedule the tasklet */
+		if (priv->adap->tasklet_conf)
+			tasklet_schedule(&priv->adap->tdm_data_tasklet);
+	}
+	return ret;
+}
+
+static int init_tdm(struct tdm_priv *priv)
+{
+	u8 *buf;
+	int i;
+	int buf_size;
+	dma_addr_t physaddr = 0;
+	int ret = 0;
+
+	/*
+	   Allocate memory for Rx/Tx buffer according to active time slots
+	   BufferSize = NUM_OF_TDM_BUF*NUM_OF_FRAMES*Active_CH
+	 */
+	buf_size = TDM_BUF_SIZE(priv->cfg.num_ch, priv->cfg.ch_width,
+			 priv->cfg.num_frames);
+	buf = dma_alloc_coherent(priv->device, buf_size, &physaddr, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_alloc_ip;
+	}
+	priv->dma_input_paddr = physaddr;
+	priv->dma_input_vaddr = buf;
+	priv->tdm_input_data = ALIGN_ADDRESS(buf, ALIGNED_8_BYTES);
+
+	buf = dma_alloc_coherent(priv->device, buf_size, &physaddr, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_alloc_op;
+	}
+	priv->dma_output_paddr = physaddr;
+	priv->dma_output_vaddr = buf;
+	priv->tdm_output_data = ALIGN_ADDRESS(buf, ALIGNED_8_BYTES);
+
+	/* allocate memory for TCD buffer discriptors */
+	buf = dma_alloc_coherent(priv->device, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE,
+		&physaddr, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_alloc_rx;
+	}
+
+	memset(buf, 0, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE);
+	priv->dma_rx_tcd_paddr = physaddr;
+	priv->dma_rx_tcd_vaddr = buf;
+	for (i = 0; i < NUM_OF_TDM_BUF; i++) {
+		priv->dma_rx_tcd[i] = ALIGN_ADDRESS(buf, ALIGNED_32_BYTES);
+		buf += TCD_BUFFER_SIZE;
+	}
+
+	buf = dma_alloc_coherent(priv->device, 3 * TCD_BUFFER_SIZE, &physaddr,
+			       GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_alloc_tx;
+	}
+	memset(buf, 0, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE);
+	priv->dma_tx_tcd_paddr = physaddr;
+	priv->dma_tx_tcd_vaddr = buf;
+	for (i = 0; i < NUM_OF_TDM_BUF; i++) {
+		priv->dma_tx_tcd[i] = ALIGN_ADDRESS(buf, ALIGNED_32_BYTES);
+		buf += TCD_BUFFER_SIZE;
+	}
+
+	priv->phase_rx = 0;
+	priv->phase_tx = 0;
+	return 0;
+
+err_alloc_tx:
+	dma_free_coherent(priv->device, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE,
+		priv->dma_rx_tcd_vaddr, priv->dma_rx_tcd_paddr);
+err_alloc_rx:
+	dma_free_coherent(priv->device, buf_size, priv->dma_output_vaddr,
+			  priv->dma_output_paddr);
+err_alloc_op:
+	dma_free_coherent(priv->device, buf_size, priv->dma_input_vaddr,
+			  priv->dma_input_paddr);
+err_alloc_ip:
+	return ret;
+}
+
+/* TDM register programming */
+static int tdm_fsl_starlite_reg_init(struct tdm_priv *priv)
+{
+	int i;
+	phys_addr_t base = get_immrbase();
+
+#ifdef CONFIG_MPC831x_RDB
+	__be32 __iomem *psccr;
+	__be32 __iomem *psicr;
+
+	psccr = ioremap(base + SCCR_OFFSET, 4);
+	if (!psccr)
+		return -1;
+	/* CSB:TDM clk =1 */
+	clrsetbits_be32(psccr, SCCR_TDM_MASK, TDM_CM_01);
+	iounmap(psccr);
+
+	psicr = ioremap(base + SICRL_OFFSET, 4);
+	if (!psicr)
+		return -1;
+	/* enable TDM in SICR */
+	clrbits32(psicr, SICRL_TDM_MASK);
+	iounmap(psicr);
+
+#endif
+
+#ifdef CONFIG_MPC85xx_RDB
+	__be32 __iomem *pmuxcr;
+
+	pmuxcr = ioremap(base + PMUXCR_OFFSET, 4);
+	if (!pmuxcr)
+		return -1;
+
+	out_be32(pmuxcr, in_be32(pmuxcr) | PMUXCR_TDM_ENABLE);
+	iounmap(pmuxcr);
+#endif
+
+
+	/* channel/group round robin */
+	out_be32(&priv->dmac_regs->dmacr, DMACR_ERGA | DMACR_ERCA);
+	/* Enable error Interrupts for TDM Rx &Tx */
+	out_8(&priv->dmac_regs->dmaseei, TDMTX_DMA_CH);
+	out_8(&priv->dmac_regs->dmaseei, TDMRX_DMA_CH);
+	out_be32(&priv->dmac_regs->dmagpor, DMAGPOR_SNOOP);
+
+	tx_tcd_init(priv);
+	rx_tcd_init(priv);
+
+	/* TDM RD->TD loopback, Share T/R Fsync,Clock */
+	if (priv->cfg.loopback)
+		out_be32(&priv->tdm_regs->gir, GIR_LPBK | GIR_RTS);
+	else
+		out_be32(&priv->tdm_regs->gir, GIR_RTS);
+
+	/*
+	   Rx Water mark 0,  FIFO enable,  Wide fifo, DMA enable for RX,
+	   Receive Sync out, syncwidth = ch width, Rx clk out,zero sync,
+	   falling edge , data order
+	 */
+
+	out_be32(&priv->tdm_regs->rir,
+		 RIR_RFWM(0) | RIR_RFEN | RIR_RWEN | RIR_RDMA | RIR_RSL |
+		 RIR_RSO | RIR_RCOE | RIR_RRDO | RIR_RFSD(0x01));
+	out_be32(&priv->tdm_regs->tir,
+		 TIR_TFWM(0) | TIR_TFEN | TIR_TWEN | TIR_TDMA | TIR_TSL |
+		 TIR_TSO | TIR_TRDO | TIR_TFSD(0x01));
+
+	/* no of channels ,Channel size-coading */
+	out_be32(&priv->tdm_regs->rfp,
+		 RFP_RNCF(priv->cfg.num_ch) | RFP_RCS(priv->cfg.ch_type));
+	out_be32(&priv->tdm_regs->tfp,
+		 TFP_TNCF(priv->cfg.num_ch) | TFP_TCS(priv->cfg.ch_type));
+
+	out_be32(&priv->tdm_regs->rier, 0);
+	out_be32(&priv->tdm_regs->tier, 0);
+
+	/* clear all receive and transmit chs */
+	for (i = 0; i < 4; i++) {
+		out_be32(&priv->tdm_regs->tcma[i], 0);
+		out_be32(&priv->tdm_regs->tcen[i], 0);
+		out_be32(&priv->tdm_regs->rcen[i], 0);
+	}
+
+	return 0;
+
+}
+
+static void tdm_fsl_starlite_stop(struct tdm_priv *priv)
+{
+	/* stop the Tx & Rx */
+	out_be32(&priv->tdm_regs->tcr, 0);
+	out_be32(&priv->tdm_regs->rcr, 0);
+
+	/* Clear DMA error Enable Request DMAEEIH/L */
+	out_8(&priv->dmac_regs->dmaceei, TDMTX_DMA_CH);
+	out_8(&priv->dmac_regs->dmaceei, TDMRX_DMA_CH);
+	out_8(&priv->dmac_regs->dmacint, TDMRX_DMA_CH);
+	out_8(&priv->dmac_regs->dmacint, TDMTX_DMA_CH);
+
+	/* disable the dma request */
+	out_8(&priv->dmac_regs->dmacerq, TDMRX_DMA_CH);
+	out_8(&priv->dmac_regs->dmacerq, TDMTX_DMA_CH);
+}
+
+static int tdm_fsl_starlite_disable(struct tdm_adapter *adap)
+{
+	struct tdm_priv *priv = tdm_get_adapdata(adap);
+	if (priv->tdm_active == 0) {
+		dev_warn(priv->device, "already Disabled");
+		return 0;
+	}
+
+	priv->tdm_active = 0;
+
+	return 0;
+}
+
+static int tdm_fsl_starlite_enable(struct tdm_adapter *adap)
+{
+	int i;
+	u32 ch_enab[4];
+	unsigned long timeout;
+	struct tdm_priv *priv = tdm_get_adapdata(adap);
+	u8 ph = priv->phase_tx;
+
+	if (priv->tdm_active == 1) {
+		dev_warn(priv->device, "already Enabled");
+		return 0;
+	}
+
+	/* enable the Channels required 0 to number of ch -1 */
+	for (i = 0; i < 4; i++)
+		ch_enab[i] = 0;
+
+	for (i = 0; i < priv->cfg.num_ch; i++)
+		ch_enab[i / 32] |= (1 << (i & 0x1F));
+
+	for (i = 0; i < 4; i++) {
+		out_be32(&priv->tdm_regs->rcen[i], ch_enab[i]);
+		out_be32(&priv->tdm_regs->tcen[i], ch_enab[i]);
+	}
+
+	/* Clear the DONE bit */
+	out_8(&priv->dmac_regs->dmacdne, TDMRX_DMA_CH);
+	out_8(&priv->dmac_regs->dmacdne, TDMTX_DMA_CH);
+
+	/* Load the Tx  transfer control descriptors */
+	for (i = 0; i < DMA_MAX_TCD; i++)
+		out_be32(&priv->dmac_regs->tcd[TDMTX_DMA_CH].tcd[i],
+			 priv->dma_tx_tcd[ph]->tcd[i]);
+
+	/* Load the Rx  transfer control descriptors */
+	for (i = 0; i < DMA_MAX_TCD; i++)
+		out_be32(&priv->dmac_regs->tcd[TDMRX_DMA_CH].tcd[i],
+			 priv->dma_rx_tcd[ph]->tcd[i]);
+
+	/* enable the dma request */
+	out_8(&priv->dmac_regs->dmaserq, TDMRX_DMA_CH);
+	out_8(&priv->dmac_regs->dmaserq, TDMTX_DMA_CH);
+
+	/* Enable Receiver, transmitter */
+	timeout = jiffies + TDM_ENABLE_TIMEOUT;
+	out_be32(&priv->tdm_regs->tcr, TCR_TEN);
+	while (!(in_be32(&priv->tdm_regs->tsr) & TSR_TENS)) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(priv->device, "timeout to enable TDM Tx\n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+	}
+
+	timeout = jiffies + TDM_ENABLE_TIMEOUT;
+	out_be32(&priv->tdm_regs->rcr, RCR_REN);
+	while (!(in_be32(&priv->tdm_regs->rsr) & RSR_RENS)) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(priv->device, "timeout to enable TDM Rx\n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+
+	}
+
+	priv->tdm_active = 1;
+	return 1;
+}
+static u32 tdm_fsl_starlite_read(struct tdm_adapter *adap,
+		u16 **input_tdm_buffer)
+{
+	struct tdm_priv *priv = tdm_get_adapdata(adap);
+	u8 phase_rx;
+	u32 buf_addr, buf_size;
+	/* point to where to start for the current phase data processing */
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(priv->cfg.num_ch * priv->cfg.ch_width, 8);
+
+	if (priv->tdm_active == 0) {
+		dev_warn(priv->device, "TDM is not ready");
+		return 0;
+	}
+
+	if (priv->phase_rx == 0)
+		phase_rx = NUM_OF_TDM_BUF - 1;
+	else
+		phase_rx = priv->phase_rx - 1;
+
+	buf_size = bytes_in_fifo_per_frame * priv->cfg.num_frames;
+	buf_addr = buf_size * phase_rx;
+	*input_tdm_buffer = (u16 *)(priv->tdm_input_data + buf_addr);
+
+	return buf_size;
+}
+
+static u32 tdm_fsl_starlite_get_write_buf(struct tdm_adapter *adap,
+		u16 **output_tdm_buffer)
+{
+	struct tdm_priv *priv = tdm_get_adapdata(adap);
+	u32 tmp;
+	u8 phase_tx;
+	u32 buf_addr, buf_size;
+	/* point to where to start for the current phase data processing */
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(priv->cfg.num_ch * priv->cfg.ch_width, 8);
+
+	if (priv->tdm_active == 0) {
+		dev_warn(priv->device, "TDM is not ready");
+		return 0;
+	}
+
+	tmp = in_be32(&priv->dmac_regs->tcd[TDMTX_DMA_CH].tcd[0]);
+
+	tmp -= priv->dma_tx_tcd[0]->tcd[0];
+
+	priv->phase_tx = tmp / (bytes_in_fifo_per_frame * priv->cfg.num_frames);
+
+	if (priv->phase_tx == 0)
+		phase_tx = NUM_OF_TDM_BUF - 1;
+	else
+		phase_tx = priv->phase_tx - 1;
+
+	buf_size = bytes_in_fifo_per_frame * priv->cfg.num_frames;
+	buf_addr = buf_size * phase_tx;
+	*output_tdm_buffer = (u16 *)(priv->tdm_output_data + buf_addr);
+
+	return buf_size;
+}
+
+static const struct tdm_algorithm tdm_algo = {
+	.tdm_read = tdm_fsl_starlite_read,
+	.tdm_get_write_buf = tdm_fsl_starlite_get_write_buf,
+	.tdm_enable = tdm_fsl_starlite_enable,
+	.tdm_disable = tdm_fsl_starlite_disable,
+	.functionality = NULL,
+};
+
+static struct tdm_adapter tdm_fsl_starlite_ops = {
+	.owner = THIS_MODULE,
+	.name = "fsl_starlite",
+	.algo = &tdm_algo,
+};
+
+static int __devinit tdm_fsl_starlite_probe(struct of_device *ofdev,
+			      const struct of_device_id *match)
+{
+	int ret = 0;
+	struct tdm_priv *priv;
+	struct resource res;
+
+	priv = kmalloc(sizeof(struct tdm_priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+
+	dev_set_drvdata(&ofdev->dev, priv);
+	priv->device = &ofdev->dev;
+
+	ret = of_address_to_resource(ofdev->node, 0, &res);
+	if (ret) {
+		ret = -EINVAL;
+		goto err_resource;
+	}
+	priv->ptdm_base = res.start;
+
+	priv->tdm_regs = of_iomap(ofdev->node, 0);
+	if (!priv->tdm_regs) {
+		ret = -ENOMEM;
+		goto err_tdmregs;
+	}
+
+	priv->dmac_regs = of_iomap(ofdev->node, 1);
+	if (!priv->dmac_regs) {
+		ret = -ENOMEM;
+		goto err_dmacreg;
+	}
+
+	/* tdmrd tmdtd at immrbar+0x16100 */
+	priv->data_regs =
+	    (struct tdm_data *)(TDM_DATAREG_OFFSET + (u8 *)priv->tdm_regs);
+	/* TDMCLK_DIV_VAL_RX/TX at TDMBASE+0x180 */
+	priv->clk_regs =
+	    (struct tdm_clock *)(TDM_CLKREG_OFFSET + (u8 *)priv->tdm_regs);
+
+	/* irqs mapping for tdm err/dmac err, dmac done */
+	priv->tdm_err_intr = irq_of_parse_and_map(ofdev->node, 0);
+	if (priv->tdm_err_intr == NO_IRQ) {
+		ret = -EINVAL;
+		goto err_tdmerr_irqmap;
+	}
+
+	priv->dmac_done_intr = irq_of_parse_and_map(ofdev->node, 1);
+	if (priv->dmac_done_intr == NO_IRQ) {
+		ret = -EINVAL;
+		goto err_dmacdone_irqmap;
+	}
+	ret =
+	    request_irq(priv->tdm_err_intr, tdm_err_isr, 0, "tdm_err_isr",
+			priv);
+	if (ret)
+		goto err_tdmerrisr;
+
+	ret =
+	    request_irq(priv->dmac_done_intr, dmac_done_isr, 0, "dmac_done_isr",
+			priv);
+	if (ret)
+		goto err_dmacdoneisr;
+
+	priv->cfg.loopback = e_TDM_PROCESS_NORMAL;
+	priv->cfg.num_ch = TDM_ACTIVE_CHANNELS;
+	priv->cfg.ch_type = TDM_CHANNEL_TYPE;
+	priv->cfg.ch_width = TDM_SLOT_WIDTH;
+	priv->cfg.num_frames = NUM_OF_FRAMES;
+
+	priv->adap = &tdm_fsl_starlite_ops;
+
+	/* Wait q initilization */
+	priv->adap->tdm_rx_flag = 0;
+	/* todo - these should be configured by dts or init time */
+	priv->adap->adap_mode = e_TDM_ADAPTER_MODE_NONE;
+	priv->adap->tdm_mode = priv->cfg.loopback;
+
+	priv->adap->max_num_ports = priv->cfg.num_ch;
+
+	tdm_set_adapdata(priv->adap, priv);
+	priv->adap->parent = &ofdev->dev;
+
+	ret = 0;
+	ret = tdm_add_adapter(priv->adap);
+	if (ret < 0) {
+		dev_err(priv->device, "failed to add adapter\n");
+		goto fail_adapter;
+	}
+
+	ret = init_tdm(priv);
+	if (ret)
+		goto err_tdminit;
+
+	ret = tdm_fsl_starlite_reg_init(priv);
+	if (ret)
+		goto err_tdminit;
+
+	spin_lock_init(&priv->tdmlock);
+	spin_lock(&priv->tdmlock);
+	priv->tdm_active = 0;
+	spin_unlock(&priv->tdmlock);
+
+	if (tdmen) {
+		ret = tdm_fsl_starlite_enable(priv->adap);
+		if (!ret)
+			goto err_tdminit;
+	}
+
+	return 0;
+
+err_tdminit:
+fail_adapter:
+	free_irq(priv->dmac_done_intr, priv);
+err_dmacdoneisr:
+	free_irq(priv->tdm_err_intr, priv);
+err_tdmerrisr:
+	irq_dispose_mapping(priv->dmac_done_intr);
+err_dmacdone_irqmap:
+	irq_dispose_mapping(priv->tdm_err_intr);
+err_tdmerr_irqmap:
+	iounmap(priv->dmac_regs);
+err_dmacreg:
+	iounmap(priv->tdm_regs);
+err_tdmregs:
+err_resource:
+	dev_set_drvdata(&ofdev->dev, NULL);
+	kfree(priv);
+err_alloc:
+	return ret;
+}
+
+static int __devexit tdm_fsl_starlite_remove(struct of_device *ofdev)
+{
+	struct tdm_priv *priv = dev_get_drvdata(&ofdev->dev);
+	int buf_size;
+
+	tdm_fsl_starlite_disable(priv->adap);
+
+	tdm_fsl_starlite_stop(priv);
+
+	tdm_del_adapter(priv->adap);
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	/* free the irqs and dispose their mapping */
+	free_irq(priv->tdm_err_intr, priv);
+	free_irq(priv->dmac_done_intr, priv);
+	irq_dispose_mapping(priv->tdm_err_intr);
+	irq_dispose_mapping(priv->dmac_done_intr);
+	iounmap(priv->tdm_regs);
+	iounmap(priv->dmac_regs);
+
+	/* free the buffers */
+	buf_size =
+	    TDM_BUF_SIZE(priv->cfg.num_ch, priv->cfg.ch_width,
+			 priv->cfg.num_frames);
+	dma_free_coherent(priv->device, buf_size, priv->dma_input_vaddr,
+			  priv->dma_input_paddr);
+	dma_free_coherent(priv->device, buf_size, priv->dma_output_vaddr,
+			  priv->dma_output_paddr);
+
+	/* free the TCDs */
+	dma_free_coherent(priv->device, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE,
+		priv->dma_rx_tcd_vaddr,  priv->dma_rx_tcd_paddr);
+	dma_free_coherent(priv->device, NUM_OF_TDM_BUF * TCD_BUFFER_SIZE,
+		priv->dma_tx_tcd_vaddr,  priv->dma_tx_tcd_paddr);
+	dev_set_drvdata(&ofdev->dev, NULL);
+	kfree(priv);
+	return 0;
+}
+
+static const struct of_device_id fsl_tdm_of_match[] = {
+	{
+	 .compatible = "fsl,starlite-tdm",
+	 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, fsl_tdm_of_match);
+
+static struct of_platform_driver tdm_fsl_starlite_driver = {
+	.match_table	= fsl_tdm_of_match,
+	.probe		= tdm_fsl_starlite_probe,
+	.remove		= __devexit_p(tdm_fsl_starlite_remove),
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= DRV_NAME,
+	},
+};
+
+static int __init tdm_fsl_starlite_init(void)
+{
+	int ret;
+	pr_info(DRV_NAME ": " DRV_DESC ":Init\n");
+	ret = of_register_platform_driver(&tdm_fsl_starlite_driver);
+	if (ret)
+		pr_err(DRV_NAME
+			"of_register_platform_driver failed (%i)\n", ret);
+	return ret;
+}
+
+static void __exit tdm_fsl_starlite_exit(void)
+{
+	pr_info(DRV_NAME ": " DRV_DESC ":Exit\n");
+	of_unregister_platform_driver(&tdm_fsl_starlite_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("P.V.Suresh, Freescale Semiconductor");
+MODULE_DESCRIPTION("Driver For Freescale Starlite TDM controller");
+MODULE_VERSION("1.1");
+
+module_init(tdm_fsl_starlite_init);
+module_exit(tdm_fsl_starlite_exit);
diff --git a/drivers/tdm/device/tdm_fsl_starlite.h b/drivers/tdm/device/tdm_fsl_starlite.h
new file mode 100644
index 0000000..00aa33e
--- /dev/null
+++ b/drivers/tdm/device/tdm_fsl_starlite.h
@@ -0,0 +1,433 @@
+/*
+ * drivers/misc/fsl_starlite_tdm.h
+ *
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * Created by P. V. Suresh <pala@freescale.com>
+ *
+ * Modified by Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ * 1. Modified to support MPC85xx based devices
+ * 2. Modified the priv structure to support Adapter Registeration
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef FSL_STARLITE_TDM_H
+#define FSL_STARLITE_TDM_H
+
+/* enable clock to TDM */
+#ifdef CONFIG_MPC831x_RDB
+
+#define SCCR_OFFSET 0x0A08
+#define SCCR_TDM_MASK 0x000000C0
+#define TDM_CM_01 (0x01<<6)
+
+/* enable tdm in SICR */
+#define SICRL_OFFSET 0x0114
+#define SICRL_TDM_MASK 0xF00F0000
+
+#endif
+
+#ifdef CONFIG_MPC85xx_RDB
+
+#define PMUXCR_OFFSET 0xE0060
+#define PMUXCR_TDM_ENABLE 0x00800000
+
+#endif
+/* TDM data register offset */
+#define TDM_TDR_OFFSET 0x108
+#define TDM_RDR_OFFSET 0x100
+#define TDM_DATAREG_OFFSET 0x100
+#define TDM_CLKREG_OFFSET 0x180
+
+/* max number of TDM-DMA channels */
+#define DMA_MAX_CHANNELS 4
+
+/* each DMA-ch contains 8 Transfer Control Discriptors  */
+#define DMA_MAX_TCD 8
+
+#define DMAC_TX_INT 1
+#define DMAC_RX_INT 2
+
+/* DMAC TCD structure */
+struct tcd {
+	u32 tcd[DMA_MAX_TCD];
+};
+
+/* DMA Controllor */
+struct dmac_regs {
+	u32 dmacr;		/* DMA Control Register			*/
+	u32 dmaes;		/* DMA Error Status Register		*/
+	u32 dmaerqh;		/* DMA Enable Request			*/
+	u32 dmaerql;		/* DMA Enable Request			*/
+	u32 dmaeeih;		/* DMA Enable Error Interrupt		*/
+	u32 dmaeeil;		/* DMA Enable Error Interrupt		*/
+
+	u8 dmaserq;		/* DMA Set Enable Request		*/
+	u8 dmacerq;		/* DMA Clear Enable Request		*/
+	u8 dmaseei;		/* DMA Set Enable Error Interrupt	*/
+	u8 dmaceei;		/* DMA Clear Enable Error Interrupt	*/
+
+	u8 dmacint;		/* DMA Clear Interrupt Request		*/
+	u8 dmacerr;		/* DMA Clear Error			*/
+	u8 dmassrt;		/* DMA Set Start Bit			*/
+	u8 dmacdne;		/* DMA Clear Done Bit			*/
+
+	u32 dmainth;		/* DMA Interrupt Request High		*/
+	u32 dmaintl;		/* DMA Interrupt Request		*/
+	u32 dmaerrh;		/* DMA Error				*/
+	u32 dmaerrl;		/* DMA Error				*/
+	u32 dmahrsh;		/* DMA Hardware Request status		*/
+	u32 dmahrsl;		/* DMA HardWired Request status		*/
+	u32 dmagpor;		/* DMA General Purpose Register		*/
+	u8 reserved0[0xC4];
+	u8 dchpri[DMA_MAX_CHANNELS];	/* DMA Port Priority		*/
+	u8 reserved1[0xEFC];
+	struct tcd tcd[DMA_MAX_CHANNELS];	/*Transfer Control Descriptor */
+};
+
+/* DMA GPOR */
+#define DMAGPOR_SNOOP	0x00000040	/* Enable Snooping */
+
+/* DMA Control Register (DMACR) */
+#define DMACR_EMLM	0x00000080	/* Enable Minor loop Mapping */
+#define DMACR_CLM	0x00000040	/* Continuous link mode */
+#define DMACR_HALT	0x00000020	/* Halt DMA */
+#define DMACR_HOE	0x00000010	/* Halt on Error */
+#define DMACR_ERGA	0x00000008	/* Round robin among the groups */
+#define DMACR_ERCA	0x00000004	/* Round robin Port Arbitration */
+#define DMACR_EDBG	0x00000002	/* Debug */
+#define DMACR_EBW	0x00000001	/* Enable Buffer */
+
+/* DMA Error Status DMAES */
+#define DMAES_VLD	0x80000000	/* Logical OR of all DMA errors. */
+#define DMAES_ECX	0x00010000	/* Transfer cancelled */
+#define DMAES_GPE	0x00008000	/* Group priority error */
+#define DMAES_CPE	0x00004000	/* Channel priority error */
+/* errored/cancelled channel */
+#define DMAES_ERRCHN(ERRCH)	(((ERRCH) & 0x1F00) >> 8)
+#define DMAES_SAE	0x00000080	/* Source address error */
+#define DMAES_SOE	0x00000040	/* Source offset error */
+#define DMAES_DAE	0x00000020	/* Destination address error */
+#define DMAES_DOE	0x00000010	/* Destination offset error */
+#define DMAES_NCE	0x00000008	/* Nbytes citer error */
+#define DMAES_SGE	0x00000004	/* Scatter gather error */
+#define DMAES_SBE	0x00000002	/* Source bus error */
+#define DMAES_DBE	0x00000001	/* Destination bus error */
+
+/* DMA Enable Request (DMAERQH, DMAERQL) Enable/disable device
+	request for the channel */
+#define DMA_SET_ENABLE_REQUEST(REGS, CH)	out_8(((REGS)->dmasreq), CH)
+#define DMA_CLEAR_ENABLE_REQUEST(REGS, CH)	out_8(((REGS)->dmacerq), CH)
+
+/* DMA Enable Error Interrupt (DMAEEIH, DMAEEIL) Enable/disable
+	error interrupt for the channel */
+#define DMA_SET_ENABLE_ERROR_INT(REGS, CH)	out_8(((REGS)->dmaseei), CH)
+#define DMA_CLEAR_ENABLE_ERROR_INT(REGS, CH)	out_8(((REGS)->dmaceei), CH)
+
+/*   Clear interrupt/error for the channel */
+#define DMA_CLEAR_INTT_REQUEST(REGS, CH)	out_8(((REGS)->dmacint), CH)
+#define DMA_CLEAR_ERROR(REGS, CH)	out_8(((REGS)->dmacerr), CH)
+
+/* Clear done bit for the channel */
+#define DMA_CLEAR_DONE_BIT(REGS, CH)	out_8(((REGS)->dmacdne), CH)
+/* Set start bit for the channel */
+#define DMA_SET_START_BIT(REGS, CH)	out_8(((REGS)->dmassrt), CH)
+
+#define TDMTX_DMA_CH	0	/* TDM Tx uses DMA 0 HardWired */
+#define TDMRX_DMA_CH	1	/* TDM Rx uses DMA 1 Hardwired */
+#define TCD_SIZE 32		/* 32 byte TCD for channel */
+#define TCD_BUFFER_SIZE 64	/* 64 byte buffer for TCD */
+
+/* Source address modulo */
+#define DMA_TCD1_SMOD(SMOD)   (((SMOD) & 0x1F) << 27)
+/* Source data transfer size */
+#define DMA_TCD1_SSIZE(SSIZE) (((SSIZE) & 0x7) << 24)
+
+/* Destination address modulo */
+#define DMA_TCD1_DMOD(DMOD)   (((DMOD) & 0x1F) << 19)
+/* data transfer size  */
+#define DMA_TCD1_DSIZE(DSIZE) (((DSIZE) & 0x7) << 16)
+
+/* Source address signed offset */
+#define DMA_TCD1_SOFF(SOFF)   ((SOFF) & 0xFFFF)
+
+/* Enable link to another channel on minor iteration completion. */
+#define DMA_TCD5_E_MINOR_LINK 0x80000000
+/* Link to this channel. */
+#define DMA_TCD5_LINK_CH(CH) (((CH) & 0x3F) << 25)
+/* Current iteration count when linking disnabled */
+#define DMA_TCD5_CITER_DISABLE_LINK(CITER) (((CITER) & 0x7FFF) << 16)
+/* Current iteration count when linking enabled */
+#define DMA_TCD5_CITER_ENABLE_LINK(CITER) (((CITER) & 0x00FF) << 16)
+/*  Destination address signed offset */
+#define DMA_TCD5_DOFF(DOFF) ((DOFF) & 0xFFFF)
+
+/* Beginning iteration count when linking disnabled */
+#define DMA_TCD7_BITER_DISABLE_LINK(CITER) (((CITER) & 0x7FFF) << 16)
+/* Beginning iteration count when linking enabled */
+#define DMA_TCD7_BITER_ENABLE_LINK(CITER) (((CITER) & 0x00FF) << 16)
+#define DMA_TCD7_BWC(BW) (((BW)&0x3)<<14)	/* BandWidth Control. */
+/* Link channel number */
+#define DMA_TCD7_LINKCH(CH)   (((CH) & 0x1F) << 8)
+#define DMA_TCD7_DONE		0x00000080	/* Channel done  */
+#define DMA_TCD7_ACTIVE		0x00000040	/* Channel active */
+#define DMA_TCD7_E_MAJOR_LINK	0x00000020	/* channel to channel linking */
+#define DMA_TCD7_E_SG		0x00000010	/* Enable scatter gather */
+#define DMA_TCD7_D_REQ		0x00000008	/* Disable request */
+/* interrupt on half major counter */
+#define DMA_TCD7_INT_HALF	0x00000004
+#define DMA_TCD7_INT_MAJ	0x00000002	/* interrupt on major counter */
+#define DMA_TCD7_START		0x00000001	/* Channel start */
+
+#define SSIZE_08BITS		0x00	/* port 1 byte */
+#define SSIZE_16BITS		0x01
+#define SSIZE_32BITS		0x02
+#define SSIZE_64BITS		0x03
+
+/* TDM  Control Registers. */
+struct tdm_regs {
+	u32 gir;		/*  General Interface Register  */
+	u32 rir;		/*  Receive Interface Register  */
+	u32 tir;		/*  Transmit Interface Register */
+	u32 rfp;		/*  Receive Frame Parameters    */
+	u32 tfp;		/*  Transmit Frame Parameters   */
+	u8 reserved0[0xC];
+	u32 rcen[4];		/*  Recieve Channel Enabled     */
+	u8 reserved1[0x10];
+	u32 tcen[4];		/*  Transmit Channel Enabled    */
+	u8 reservedd2[0x10];
+	u32 tcma[4];		/*  Transmit Channel Mask       */
+	u8 reservederved3[0x10];
+	u32 rcr;		/*  Receiver Control Register           */
+	u32 tcr;		/*  Transmitter Control Register        */
+	u32 rier;		/*  Receive Interrupt Enable Register   */
+	u32 tier;		/*  Transmit Interrupt Enable Register  */
+	u8 reserved4[0x10];
+	u32 rer;		/*  Receive Event Register              */
+	u32 ter;		/*  Transmit Event Register             */
+	u32 rsr;		/*  Receive Status Register             */
+	u32 tsr;		/*  Transmit Status Register            */
+};
+
+struct tdm_data {
+	u64 rdr;		/* Receive Data Register */
+	u64 tdr;		/* Transmit Dataa Register */
+};
+
+struct tdm_clock {
+	u32 rx;			/* Transmit Dataa Register */
+	u32 tx;			/* Receive Data Register */
+};
+
+/* TDMGIR  General Interface Register */
+#define GIR_LPBK	0x00000004	/* loopback mode */
+#define GIR_CTS		0x00000002	/* Common TDM signals */
+#define GIR_RTS		0x00000001	/* Rx & Tx sharing */
+
+/* TDMRIR Recieve Interface Rgister */
+#define RIR_RFWM_MASK	0x00000003	/* Recieve FIFO Watermark */
+#define RIR_RFWM_SHIFT	16
+#define RIR_RFWM(x)     ((x & RIR_RFWM_MASK) << RIR_RFWM_SHIFT)
+#define RIR_RFEN	0x00008000	/* Recieve FIFO Enable */
+#define RIR_RWEN	0x00004000	/* Recieve Wide FIFO Enable */
+#define RIR_RDMA	0x00000040	/* Recieve DMA Enable */
+#define RIR_RFSD_SHIFT	0x00000004	/* Recieve Frame Sync Delay */
+#define RIR_RFSD_MASK	0x00000003
+#define RIR_RFSD(x)	((x & RIR_RFSD_MASK) << RIR_RFSD_SHIFT)
+#define RIR_RSO		0x00002000	/* Recieve sync Out */
+#define RIR_RSL		0x00000800	/* Recieve sync Out Length */
+#define RIR_RSOE	0x00000400	/* Recieve sync Out Edge */
+#define RIR_RCOE	0x00000200	/* Recieve Clock Output Enable */
+#define RIR_RSA		0x00000008	/* Recieve Sync Active */
+#define RIR_RDE		0x00000004	/* Recieve Data Edge */
+#define RIR_RFSE	0x00000002	/* Recieve Frame Sync Edge */
+#define RIR_RRDO	0x00000001	/* Revieve Reversed Data Order */
+
+/* TDMTIR  Transmit Interface Rgister */
+#define TIR_TFWM_MASK	0x00000003	/* Transmit FIFO Watermark */
+#define TIR_TFWM_SHIFT	16
+#define TIR_TFWM(x)	((x & TIR_TFWM_MASK) << TIR_TFWM_SHIFT)
+#define TIR_TFEN	0x00008000	/* Transmit FIFO Enable */
+#define TIR_TWEN	0x00004000	/* Transmit Wide FIFO Enable */
+#define TIR_TDMA	0x00000040	/* Transmit DMA Enable */
+#define TIR_TFSD_SHIFT	0x00000004	/* Transmit Frame Sync Delay */
+#define TIR_TFSD_MASK	0x00000003
+#define TIR_TFSD(x)	((x & TIR_TFSD_MASK) << TIR_TFSD_SHIFT)
+#define TIR_TSO		0x00002000	/* Transmit Sync Output */
+#define TIR_TSL		0x00000800	/* Transmit sync Out Length */
+#define TIR_TSOE	0x00000400	/* Transmit sync Out Edge */
+#define TIR_TCOE	0x00000200	/* Transmit Clock Output Enable */
+#define TIR_TSA		0x00000008	/* Transmit Sync Active */
+#define TIR_TDE		0x00000004	/* Transmit Data Edge */
+#define TIR_TFSE	0x00000002	/* Transmit Frame Sync Edge */
+#define TIR_TRDO	0x00000001	/* Transmit Reversed Data Order */
+
+/*TDMRFP  Revieve Frame Parameters */
+#define RFP_RNCF_SHIFT	0x00000010	/* Number of Channels in TDM Frame */
+#define RFP_RNCF_MASK	0x000000FF
+#define RFP_RNCF(x)	(((x - 1) & RFP_RNCF_MASK) << RFP_RNCF_SHIFT)
+#define RFP_RCS_SHIFT	0x00000004	/* Recieve Channel Size */
+#define RFP_RCS_MASK	0x00000003
+#define RFP_RCS(x)	((x & RFP_RCS_MASK) << RFP_RCS_SHIFT)
+#define RFP_RT1		0x00000002	/* Recieve T1 Frame */
+
+/*TDMTFP Transmit Frame Parameters */
+#define TFP_TNCF_SHIFT	0x00000010	/* Number of Channels in TDM Frame */
+#define TFP_TNCF_MASK	0x000000FF
+#define TFP_TNCF(x)	(((x - 1) & TFP_TNCF_MASK) << TFP_TNCF_SHIFT)
+#define TFP_TCS_SHIFT	0x00000004	/* Transmit Channel Size */
+#define TFP_TCS_MASK	0x00000003
+#define TFP_TCS(x)	((x & RFP_RCS_MASK) << RFP_RCS_SHIFT)
+#define TFP_TT1		0x00000002	/* Transmit T1 Frame */
+
+
+/* TDMRCR  Recieve Control Register */
+#define RCR_REN		0x00000001	/* Recieve Enable */
+/* TDMTCR  Transmit Control Register */
+#define TCR_TEN		0x00000001	/* Transmit Enable */
+
+/* TDMRIER receive interrupt enable register */
+#define RIER_RCEUE	0x00000100	/* Channel Enable Update Enable */
+#define RIER_RLCEE	0x00000080	/* Recieve Last Channel Event Enable */
+#define RIER_RFSEE	0x00000040	/* Recieve Frame Sync Event Enable */
+#define RIER_RFFEE	0x00000020	/* Recieve FIFO Full Event Enable */
+#define RIER_RDREE	0x00000010	/* Recieve Data Ready Event Enable */
+#define RIER_RSEEE	0x00000008	/* Recieve Sync Error Event Enable */
+#define RIER_ROEE	0x00000004	/* Recieve Overrun Event Enable */
+
+/* TDMTIER  transmit interrupt enable register */
+#define TIER_TCEUE	0x00000100	/* Channel Enable Update Enable */
+#define TIER_TLCEE	0x00000080	/* Transmit Last Channel Event */
+#define TIER_TFSEE	0x00000040	/* Transmit Frame Sync Event Enable */
+#define TIER_TFFEE	0x00000020	/* Transmit FIFO Full Event Enable */
+#define TIER_TDREE	0x00000010	/* Transmit Data Ready Event Enable */
+#define TIER_TSEEE	0x00000008	/* Transmit Sync Error Event Enable */
+#define TIER_TUEE	0x00000004	/* Transmit Overrun Event Enable */
+
+/* TDMRER  Recieve Event Register */
+#define RER_RCEU	0x00000100	/* Recieve Channel Enable Update */
+#define RER_RLCE	0x00000080	/* Recieve Last Channel Event */
+#define RER_RFSE	0x00000040	/* Recieve Frame Sync Event */
+#define RER_RFFE	0x00000020	/* Recieve FIFO Full Event */
+#define RER_RDRE	0x00000010	/* Recieve Data Ready Event */
+#define RER_RSEE	0x00000008	/* Recieve Sync Error Event */
+#define RER_ROE		0x00000004	/* Recieve Overrun Event */
+
+/* TDMTER  Transmit Event Register */
+#define TER_TCEU	0x00000100	/* Transmit Channel Enable Update */
+#define TER_TLCE	0x00000080	/* Transmit Last Channel Event */
+#define TER_TFSE	0x00000040	/* Transmit Frame Sync Event */
+#define TER_TFEE	0x00000020	/* Transmit FIFO Full Event */
+#define TER_TDRE	0x00000010	/* Transmit Data Ready Event */
+#define TER_TSEE	0x00000008	/* Transmit Sync Error Event */
+#define TER_TUE		0x00000004	/* Transmit Overrun Event */
+
+/* TDMRSR  Recieve Status Register */
+#define RSR_RFCNT	0x00000038	/* Recieve FIFO counter */
+#define RSSS_MASK	0x00000003	/* Recieve SYNC Status */
+#define RSR_RSSS_SHIFT  1
+#define RSR_RSSS(SSS)	(((SSS) >> (RSR_RSSS_SHIFT)) & (RSR_RSSS_MASK))
+#define RSR_RENS	0x00000001	/* Recieve Enable Status */
+
+/* TDMTSR  Transmit Status Register */
+#define TSR_TFCNT	0x00000038	/* Transmit FIFO counter */
+#define TSR_TSSS_MASK	0x00000003	/* Transmit SYNC Status */
+#define TSR_TSSS_SHIFT	1
+#define TSR_TSSS(SSS)	(((SSS) >> (TSR_TSSS_SHIFT)) & TSR_TSSS_MASK)
+#define TSR_TENS	0x00000001	/* Transmit Enable Status */
+
+/* channel width */
+#define CHANNEL_SIZE_1BYTE	1	/* 1 byte channel 8-bit linear */
+#define CHANNEL_SIZE_2BYTE	2	/* 2 bytes      */
+
+/* channel parameters   */
+#define TDM_ENABLE_TIMEOUT  1000	/* time out for TDM rx, tx enable */
+#define NUM_OF_TDM_BUF		3 /* Number of tdm buffers for startlite DMA */
+#define ALIGNED_2_BYTES		0x02	/* 2-bytes alignment */
+#define ALIGNED_4_BYTES		0x04	/* 4-bytes alignment */
+#define ALIGNED_8_BYTES		0x08	/* 8-bytes alignment */
+#define ALIGNED_16_BYTES	0x10	/* 16-bytes alignment */
+#define ALIGNED_32_BYTES	0x20	/* 32-bytes alignment */
+#define ALIGNED_64_BYTES	0x40	/* 64-bytes alignment */
+
+/* Extend a given size to make it alignable */
+static inline int ALIGNABLE_SIZE(u32 size, u32 alignment)
+{
+	return size + alignment - 1;
+}
+
+/* Align a given address */
+static inline void *ALIGN_ADDRESS(void *address, u32 alignment)
+{
+	return (void *)(((u32) address + alignment - 1) & (~(alignment - 1)));
+}
+
+/* Size of the buffer */
+static inline int TDM_1BUF_SIZE(u32 num_ch, u32 channel_size, u32 frame_size)
+{
+	return frame_size *
+		ALIGN_SIZE(channel_size * num_ch, ALIGNED_8_BYTES);
+}
+
+/* Alignable size of the 3 buffers */
+static inline int TDM_BUF_SIZE(u32 num_ch, u32 channel_size, u32 frame_size)
+{
+	return
+	    ALIGNABLE_SIZE((TDM_1BUF_SIZE(num_ch, channel_size, frame_size) *
+			    NUM_OF_TDM_BUF), ALIGNED_8_BYTES);
+}
+
+/* TDM configuration parameters */
+struct tdm_cfg {
+	u8 loopback;
+	u8 num_ch;
+	u8 ch_type;
+	u8 ch_width;
+	u8 num_frames;
+};
+
+struct tdm_priv {
+	struct tdm_regs __iomem *tdm_regs;
+	struct tdm_data __iomem *data_regs;
+	struct dmac_regs __iomem *dmac_regs;
+	struct tdm_clock __iomem *clk_regs;
+	u32 ptdm_base;
+	u8 *tdm_input_data;
+	u8 *tdm_output_data;
+	dma_addr_t dma_input_paddr;	/* dma mapped buffer for TDM Rx */
+	dma_addr_t dma_output_paddr;	/* dma mapped buffer for TDM Tx */
+	void *dma_input_vaddr;
+	void *dma_output_vaddr;
+	u8 phase_rx;
+	u8 phase_tx;
+	struct tcd *dma_rx_tcd[NUM_OF_TDM_BUF];
+	struct tcd *dma_tx_tcd[NUM_OF_TDM_BUF];
+	dma_addr_t dma_rx_tcd_paddr;
+	dma_addr_t dma_tx_tcd_paddr;
+	void *dma_rx_tcd_vaddr;
+	void *dma_tx_tcd_vaddr;
+	u32 tdm_buffer_size;
+	struct tdm_cfg cfg;
+	u32 tdm_err_intr;
+	u32 dmac_err_intr;
+	u32 dmac_done_intr;
+	int tdm_active;
+	struct device *device;
+	spinlock_t tdmlock;
+	struct tdm_adapter *adap;
+};
+
+#endif
diff --git a/drivers/tdm/tdm-core.c b/drivers/tdm/tdm-core.c
new file mode 100644
index 0000000..02de0f6
--- /dev/null
+++ b/drivers/tdm/tdm-core.c
@@ -0,0 +1,1096 @@
+/* driver/tdm/tdm-core.c
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * TDM core is the interface between TDM ports and devices.
+ *
+ * Author:Hemant Agrawal <hemant@freescale.com>
+ * Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/tdm.h>
+#include <linux/init.h>
+#include <linux/idr.h>
+#include <linux/mutex.h>
+#include <linux/completion.h>
+#include <linux/hardirq.h>
+#include <linux/irqflags.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+/*
+ * core_lock protects tdm_adapter_idr, and guarantees that device,
+ * deletion of devices, and attach_adapter and detach_adapter calls
+ * are serialized */
+static DEFINE_MUTEX(core_lock);
+static DEFINE_IDR(tdm_adapter_idr);
+LIST_HEAD(adapter_list);
+LIST_HEAD(driver_list);
+
+/* In case the previous data is not fetched by the client driver, the
+ * de-interleaving function will  discard the old data and rewrite the
+ * new data */
+static int use_latest_tdm_data = 1;
+
+static void tdm_data_tasklet_fn(unsigned long);
+
+static int tdm_device_match(struct tdm_driver *driver, struct tdm_adapter *adap)
+{
+	/* match on an id table if there is one */
+	if (driver->id_table && driver->id_table->name[0]) {
+		if (!(strcmp(driver->id_table->name, adap->name)))
+			return (int)driver->id_table;
+	}
+	return TDM_E_OK;
+}
+
+static int tdm_do_add_adapter(struct tdm_driver *driver,
+					struct tdm_adapter *adap)
+{
+	/* if driver is already attached to any other adapter, return*/
+	if (driver->adapter && driver->adapter != adap)
+		return TDM_E_OK;
+
+	driver->adapter = adap;
+
+	if (driver->attach_adapter) {
+		/* We ignore the return code; if it fails, too bad */
+		driver->attach_adapter(adap);
+	}
+	adap->drv_count++;
+
+	if (!adap->tasklet_conf) {
+		tasklet_init(&adap->tdm_data_tasklet, tdm_data_tasklet_fn,
+						(unsigned long)adap);
+		adap->tasklet_conf = 1;
+	}
+
+	return TDM_E_OK;
+}
+
+static int tdm_register_adapter(struct tdm_adapter *adap)
+{
+	int res = TDM_E_OK;
+	struct tdm_driver *driver, *next;
+
+	mutex_init(&adap->adap_lock);
+	INIT_LIST_HEAD(&adap->myports);
+	spin_lock_init(&adap->portlist_lock);
+
+	adap->drv_count = 0;
+	adap->tasklet_conf = 0;
+
+	list_add_tail(&adap->list, &adapter_list);
+
+	/* Notify drivers */
+	pr_info("adapter [%s] registered\n", adap->name);
+	mutex_lock(&core_lock);
+	list_for_each_entry_safe(driver, next, &driver_list, list) {
+		if (tdm_device_match(driver, adap)) {
+			res = tdm_do_add_adapter(driver, adap);
+			pr_info(
+			"Driver(ID=%d) is attached with Adapter %s(ID = %d)\n",
+				driver->id, adap->name, adap->id);
+		}
+	}
+	mutex_unlock(&core_lock);
+
+	return res;
+}
+
+/*
+ * tdm_add_adapter - declare tdm adapter, use dynamic device number
+ * @adapter: the adapter to add
+ * Context: can sleep
+ *
+ * This routine is used to declare an TDM adapter
+ * When this returns zero, a new device number will be allocated and stored
+ * in adap->id, and the specified adapter became available for ports.
+ * Otherwise, a negative errno value is returned.
+ */
+int tdm_add_adapter(struct tdm_adapter *adapter)
+{
+	int id, res = TDM_E_OK;
+
+retry:
+	if (idr_pre_get(&tdm_adapter_idr, GFP_KERNEL) == 0)
+		return -ENOMEM;
+
+	mutex_lock(&core_lock);
+	res = idr_get_new(&tdm_adapter_idr, adapter, &id);
+	mutex_unlock(&core_lock);
+
+	if (res < 0) {
+		if (res == -EAGAIN)
+			goto retry;
+		return res;
+	}
+
+	adapter->id = id;
+	return tdm_register_adapter(adapter);
+}
+EXPORT_SYMBOL(tdm_add_adapter);
+
+static int tdm_do_del_adapter(struct tdm_driver *driver,
+					struct tdm_adapter *adap)
+{
+	int res = TDM_E_OK;
+
+	if (!driver->adapter || driver->adapter != adap)
+		return TDM_E_OK;
+
+	if (!driver->detach_adapter)
+		return TDM_E_OK;
+
+	adap->drv_count--;
+
+	res = driver->detach_adapter(adap);
+	if (res)
+		pr_err("detach_adapter failed (%d) "
+			"for driver [%s]\n", res, driver->name);
+	driver->adapter = NULL;
+	return res;
+}
+
+/**
+ * tdm_del_adapter - unregister TDM adapter
+ * @adap: the adapter being unregistered
+ * Context: can sleep
+ *
+ * This unregisters an TDM adapter which was previously registered
+ * by @tdm_add_adapter.
+ */
+int tdm_del_adapter(struct tdm_adapter *adap)
+{
+	int res = TDM_E_OK;
+	struct tdm_adapter *found;
+	struct tdm_driver *driver, *next;
+
+	/* First make sure that this adapter was ever added */
+	mutex_lock(&core_lock);
+	found = idr_find(&tdm_adapter_idr, adap->id);
+	mutex_unlock(&core_lock);
+	if (found != adap) {
+		pr_err("tdm-core: attempting to delete unregistered "
+			 "adapter [%s]\n", adap->name);
+		return -EINVAL;
+	}
+
+	/*disable and kill the data processing tasklet */
+	if (adap->tasklet_conf) {
+		tasklet_disable(&adap->tdm_data_tasklet);
+		tasklet_kill(&adap->tdm_data_tasklet);
+		adap->tasklet_conf = 0;
+	}
+
+	/* Detach any active ports. This can't fail, thus we do not
+	   checking the returned value. */
+	mutex_lock(&core_lock);
+	list_for_each_entry_safe(driver, next, &driver_list, list) {
+		if (tdm_device_match(driver, adap)) {
+			tdm_do_del_adapter(driver, adap);
+			pr_info(
+			"Driver(ID=%d) is detached from Adapter %s(ID = %d)\n",
+				 driver->id, adap->name, adap->id);
+		}
+	}
+	mutex_unlock(&core_lock);
+
+	mutex_lock(&core_lock);
+	idr_remove(&tdm_adapter_idr, adap->id);
+	mutex_unlock(&core_lock);
+
+	pr_debug("adapter [%s] unregistered\n", adap->name);
+
+	list_del(&adap->list);
+	/* Clear the device structure in case this adapter is ever going to be
+	   added again */
+	adap->parent = NULL;
+
+	return res;
+}
+EXPORT_SYMBOL(tdm_del_adapter);
+
+static int __attach_adapter(struct tdm_adapter *adap, void *data)
+{
+	struct tdm_driver *driver = (struct tdm_driver *)data;
+
+	driver->adapter = adap;
+
+	if (driver->attach_adapter)
+		driver->attach_adapter(adap);
+
+	if (!adap->tasklet_conf) {
+		tasklet_init(&adap->tdm_data_tasklet, tdm_data_tasklet_fn,
+				(unsigned long)adap);
+		adap->tasklet_conf = 1;
+	}
+	adap->drv_count++;
+
+	return TDM_E_OK;
+}
+
+/*
+ * An tdm_driver is used with one or more tdm_port nodes to access
+ * tdm device, on a device instance associated with some tdm_adapter.
+ */
+
+int tdm_register_driver(struct module *owner, struct tdm_driver *driver)
+{
+	int res = TDM_E_OK;
+	struct tdm_adapter *adap, *next;
+
+	list_add_tail(&driver->list, &driver_list);
+
+	mutex_lock(&core_lock);
+	/* Walk the adapters that are already present */
+	list_for_each_entry_safe(adap, next, &adapter_list, list) {
+		if (tdm_device_match(driver, adap)) {
+			res = __attach_adapter(adap, driver);
+			pr_info("TDM Driver(ID=%d)is attached with Adapter"
+				"%s(ID = %d) drv_count=%d", driver->id,
+				adap->name, adap->id, adap->drv_count);
+		break;
+		}
+	}
+	mutex_unlock(&core_lock);
+
+	return res;
+}
+EXPORT_SYMBOL(tdm_register_driver);
+
+static int __detach_adapter(struct tdm_adapter *adap, void *data)
+{
+	struct tdm_driver *driver = (struct tdm_driver *)data;
+
+	if (adap == NULL)
+		return -ENODEV;
+
+	adap->drv_count--;
+
+	/* If no more driver is registed with the adapter*/
+	if (!adap->drv_count && adap->tasklet_conf) {
+		tasklet_disable(&adap->tdm_data_tasklet);
+		tasklet_kill(&adap->tdm_data_tasklet);
+		adap->tasklet_conf = 0;
+	}
+
+	if (driver->detach_adapter) {
+		if (driver->detach_adapter(adap))
+			pr_err("detach_adapter failed for driver [%s]\n",
+				driver->name);
+	}
+	driver->adapter = NULL;
+
+	return TDM_E_OK;
+}
+
+/*
+ * tdm_del_driver - unregister TDM driver
+ * @driver: the driver being unregistered
+ * Context: can sleep
+ */
+void tdm_del_driver(struct tdm_driver *driver)
+{
+       /* A driver can register to only one adapter,
+	* so no need to browse the list */
+	mutex_lock(&core_lock);
+	__detach_adapter(driver->adapter, driver);
+	mutex_unlock(&core_lock);
+
+	list_del(&driver->list);
+
+	pr_debug("tdm-core: driver [%s] unregistered\n", driver->name);
+}
+EXPORT_SYMBOL(tdm_del_driver);
+
+struct tdm_cmd_arg {
+	unsigned cmd;
+	void *arg;
+};
+
+static int tdm_cmd(struct tdm_driver *driver, void *_arg)
+{
+	struct tdm_cmd_arg *arg = _arg;
+
+	if (driver->command)
+		driver->command(arg->cmd, arg->arg);
+	return 0;
+}
+
+/* this will send the given command for all the drivers of the adapters */
+void tdm_driver_command(struct tdm_adapter *adap, unsigned int cmd, void *arg)
+{
+	struct tdm_cmd_arg cmd_arg;
+	struct tdm_driver *driver, *next;
+
+	cmd_arg.cmd = cmd;
+	cmd_arg.arg = arg;
+
+	/* Notify drivers */
+	mutex_lock(&core_lock);
+	list_for_each_entry_safe(driver, next, &driver_list, list) {
+		if (tdm_device_match(driver, adap))
+			tdm_cmd(driver, &cmd_arg);
+	}
+	mutex_unlock(&core_lock);
+}
+EXPORT_SYMBOL(tdm_driver_command);
+
+static int __init tdm_init(void)
+{
+	pr_info("%s\n", __func__);
+	return TDM_E_OK;
+}
+
+static void __exit tdm_exit(void)
+{
+	pr_info("%s\n", __func__);
+	return;
+}
+
+/* We must initialize early, because some subsystems register tdm drivers
+ * in subsys_initcall() code, but are linked (and initialized) before tdm.
+ */
+postcore_initcall(tdm_init);
+module_exit(tdm_exit);
+
+/* if read write debug required
+#define TDM_CORE_DEBUG
+*/
+
+/* the functional interface to the tdm device. */
+/*
+ * tdm_master_send - issue a TDM write
+ * @client: Handle to TDM device
+ * @buf: Data that will be written to the TDM device
+ * @count: How many bytes to write
+ *
+ * Returns negative errno, or else the number of bytes written.
+ */
+int tdm_master_send(struct tdm_adapter *adap, void **buf, int count)
+{
+	int res;
+
+	if (adap->algo->tdm_write)
+		res = adap->algo->tdm_write(adap, buf, count);
+	else {
+		pr_err("TDM level write not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	/* If everything went ok (i.e. frame transmitted), return #bytes
+	   transmitted, else error code. */
+	return (res == 1) ? count : res;
+}
+EXPORT_SYMBOL(tdm_master_send);
+
+/**
+ * tdm_master_recv - issue a TDM read
+ * @client: Handle to TDM device
+ * @buf: Where to store data read from TDM device
+ * @count: How many bytes to read
+ *
+ * Returns negative errno, or else the number of bytes read.
+ */
+int tdm_master_recv(struct tdm_adapter *adap, void **buf)
+{
+	int res;
+
+	if (adap->algo->tdm_read)
+		res = adap->algo->tdm_read(adap, (u16 **)buf);
+	else {
+		pr_err("TDM level read not supported\n");
+		return -EOPNOTSUPP;
+	}
+	/* If everything went ok (i.e. frame received), return #bytes
+	   transmitted, else error code. */
+	return res;
+}
+EXPORT_SYMBOL(tdm_master_recv);
+
+/**
+ * tdm_master_recv - issue a TDM read
+ * @client: Handle to TDM device
+ * @buf: Where to store data read from TDM device
+ * @count: How many bytes to read
+ *
+ * Returns negative errno, or else the number of bytes read.
+ */
+int tdm_master_get_write_buf(struct tdm_adapter *adap, void **buf)
+{
+	int res;
+
+	if (adap->algo->tdm_get_write_buf) {
+		res = adap->algo->tdm_get_write_buf(adap, (u16 **)buf);
+	} else {
+		pr_err("TDM level write buf get not supported\n");
+		return -EOPNOTSUPP;
+	}
+	/* If everything went ok (i.e. 1 msg received), return #bytes
+	   transmitted, else error code. */
+	return res;
+}
+EXPORT_SYMBOL(tdm_master_get_write_buf);
+
+int tdm_master_enable(struct tdm_driver *drv)
+{
+	int res;
+	struct tdm_adapter *adap = drv->adapter;
+
+	if (adap->algo->tdm_enable) {
+		res = adap->algo->tdm_enable(adap);
+	} else {
+		pr_err("TDM level enable not supported\n");
+		return -EOPNOTSUPP;
+	}
+	return res;
+}
+EXPORT_SYMBOL(tdm_master_enable);
+
+int tdm_master_disable(struct tdm_driver *drv)
+{
+	int res;
+	struct tdm_adapter *adap = drv->adapter;
+
+	if (adap->algo->tdm_disable) {
+		res = adap->algo->tdm_disable(adap);
+	} else {
+		pr_err("TDM level enable not supported\n");
+		return -EOPNOTSUPP;
+	}
+	return res;
+}
+EXPORT_SYMBOL(tdm_master_disable);
+
+
+struct tdm_adapter *tdm_get_adapter(int id)
+{
+	struct tdm_adapter *adapter;
+
+	mutex_lock(&core_lock);
+	adapter = idr_find(&tdm_adapter_idr, id);
+	if (adapter && !try_module_get(adapter->owner))
+		adapter = NULL;
+
+	mutex_unlock(&core_lock);
+
+	return adapter;
+}
+EXPORT_SYMBOL(tdm_get_adapter);
+
+void tdm_put_adapter(struct tdm_adapter *adap)
+{
+	module_put(adap->owner);
+}
+EXPORT_SYMBOL(tdm_put_adapter);
+
+
+unsigned int tdm_port_open(struct tdm_driver *driver, int chanid, void **h_port)
+{
+	struct tdm_port *port;
+	struct tdm_adapter *adap;
+	struct tdm_port_data	*p_port_data;
+	unsigned long		flags;
+	int res = TDM_E_OK;
+
+	/* todo - verify that chanid is not already open */
+	if (driver == NULL) {
+		pr_err("driver NULL\n");
+		return -ENODEV;
+	}
+	if (driver->adapter == NULL) {
+		pr_err("adapter NULL\n");
+		return -ENODEV;
+	}
+
+	adap = tdm_get_adapter(driver->adapter->id);
+	if (!adap)
+		return -ENODEV;
+
+	/* This creates an anonymous tdm_port, which may later be
+	 * pointed to some slot.
+	 *
+	 */
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port) {
+		res = -ENOMEM;
+		goto out;
+	}
+
+	init_waitqueue_head(&port->ch_wait_queue);
+
+	p_port_data = kzalloc(sizeof(struct tdm_port_data), GFP_KERNEL);
+	if (!p_port_data) {
+		res = -ENOMEM;
+		goto outdata;
+	}
+
+	p_port_data->rx_data_fifo[TDM_CH_RX_BD_RING_SIZE-1].wrap = 1;
+	p_port_data->tx_data_fifo[TDM_CH_TX_BD_RING_SIZE-1].wrap = 1;
+
+	p_port_data->rx_in_data = p_port_data->rx_data_fifo;
+	p_port_data->rx_out_data = p_port_data->rx_data_fifo;
+	p_port_data->tx_in_data = p_port_data->tx_data_fifo;
+	p_port_data->tx_out_data = p_port_data->tx_data_fifo;
+	spin_lock_init(&p_port_data->rx_channel_lock);
+	spin_lock_init(&p_port_data->tx_channel_lock);
+
+	port->p_port_data = p_port_data;
+
+	/* todo - these should be configured dynamically*/
+	port->rx_max_frames = NUM_OF_FRAMES;
+	port->ch_id = chanid;
+	port->first_slot = chanid;
+
+	port->slot_width = TDM_SLOT_WIDTH;
+
+	/* todo - enable/disable the port with ioctl */
+	port->in_use = 1;
+
+	snprintf(driver->name, TDM_NAME_SIZE, "tdm-dev %d", chanid);
+	port->driver = driver;
+
+	spin_lock_irqsave(&adap->portlist_lock, flags);
+	list_add_tail(&port->list, &adap->myports);
+	spin_unlock_irqrestore(&adap->portlist_lock, flags);;
+
+	*h_port = port;
+
+out:
+	return res;
+
+outdata:
+	unlock_kernel();
+	kfree(port);
+	return res;
+}
+EXPORT_SYMBOL(tdm_port_open);
+
+unsigned int tdm_port_close(void *h_port)
+{
+	struct tdm_adapter *adap;
+	struct tdm_driver *driver;
+	struct tdm_port *port = (struct tdm_port *)h_port;
+	unsigned long		flags;
+	int ch_id, res = TDM_E_OK;
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle");
+		return -ENXIO;
+	}
+
+	driver =  port->driver;
+	ch_id = port->ch_id;
+
+	if (driver == NULL) {
+		pr_err("driver NULL\n");
+		res = -ENODEV;
+		goto out;
+	}
+	if (driver->adapter == NULL) {
+		pr_err("adapter NULL\n");
+		res = -ENODEV;
+		goto out;
+	}
+
+	/* todo - verify that chanid is in open state */
+
+	adap = driver->adapter;
+
+	spin_lock_irqsave(&adap->portlist_lock, flags);
+	list_del(&port->list);
+	spin_unlock_irqrestore(&adap->portlist_lock, flags);
+
+	if (port->p_port_data != NULL) {
+		int i;
+		struct tdm_bd *ch_bd;
+
+		/* If the tdm is in channelised mode,
+		de-allocate the channelised buffer */
+		ch_bd = &(port->p_port_data->rx_data_fifo[0]);
+		for (i = 0; ch_bd && i < TDM_CH_RX_BD_RING_SIZE; i++) {
+			ch_bd->flag = 0;
+			ch_bd++;
+		}
+		ch_bd = &(port->p_port_data->tx_data_fifo[0]);
+		for (i = 0; ch_bd && i < TDM_CH_TX_BD_RING_SIZE; i++) {
+			ch_bd->flag = 0;
+			ch_bd++;
+		}
+		kfree(port->p_port_data);
+	}
+	kfree(port);
+	port = NULL;
+out:
+	return res;
+}
+EXPORT_SYMBOL(tdm_port_close);
+
+unsigned int tdm_port_ioctl(void *h_port, unsigned int cmd, unsigned long arg)
+{
+	struct tdm_port         *port = (struct tdm_port *)h_port;
+	int                     port_num;
+	int res = TDM_E_OK;
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle");
+		return -ENXIO;
+	}
+	port_num =  port->ch_id;
+
+	/* todo - verify that chanid is in open state */
+
+	pr_info("TDM %d IOCTL cmd=0x%x arg=0x%x", port_num, cmd,
+			(unsigned int)arg);
+
+	switch (cmd) {
+	case TDM_CHAN_ENABLE_TDM:
+		pr_info("Port %d Enable TDM", port_num);
+		port->in_use = 1;
+		break;
+
+	case TDM_CHAN_DISABLE_TDM:
+		pr_info("Port %d Disable TDM", port_num);
+		port->in_use = 0;
+		break;
+
+	case TDM_CHAN_SET_RX_LENGTH:
+		pr_info("Set Receive Buffer Length for Portised Mode");
+		if (port->in_use == 1) {
+			pr_err("chan %d TDM Port is Enable", port_num);
+			res = -EACCES;
+			goto out_err;
+		}
+		if (arg%NUM_OF_FRAMES) {
+			pr_info("Port %d Not a Multiple of %d", port_num,
+					NUM_OF_FRAMES);
+			res = -EINVAL;
+				goto out_err;
+		}
+		/* todo - Not Supported port->rx_max_frames = arg;*/
+		break;
+
+	case TDM_CHAN_SET_START_SLOT:
+		if (port->in_use == 1) {
+			pr_err("chan %d TDM Port is Enable", port_num);
+			res = -EACCES;
+			goto out_err;
+		}
+		pr_info("Port %d set slot %d TDM", port_num, (int)arg);
+		/* todo-currently not in use*/
+		port->first_slot = arg;
+		break;
+
+	case TDM_CHAN_SET_SLOT_WIDTH:
+		if (port->in_use == 1) {
+			pr_err("chan %d TDM Port is Enable", port_num);
+			res = -EACCES;
+			goto out_err;
+		}
+		pr_info("Port %d set width %d TDM", port_num, (int)arg);
+		/* todo- Not Supported port->slot_width = arg;*/
+		break;
+
+	default:
+		pr_info("IOCTL Command Not Implemented");
+		break;
+	}
+
+out_err:
+	return res;
+}
+EXPORT_SYMBOL(tdm_port_ioctl);
+
+unsigned int tdm_port_read(void *h_port, void *p_data, u16 *size)
+{
+	struct tdm_port *port = (struct tdm_port *)h_port;
+	struct tdm_bd *rx_bd;
+	unsigned long flags;
+	int i, res = TDM_E_OK;
+	unsigned short *buf, *buf1;
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle\n");
+		return -ENXIO;
+	}
+
+	/* todo - verify that chanid is in open state  */
+	if (!port->p_port_data || !port->in_use)
+		return -EIO;
+
+	spin_lock_irqsave(&port->p_port_data->rx_channel_lock, flags);
+	rx_bd = port->p_port_data->rx_out_data;
+
+	if (rx_bd->flag) {
+		*size = rx_bd->length;
+		buf = (u16 *) p_data;
+		buf1 = (u16 *)rx_bd->p_data;
+		for (i = 0; i < NUM_OF_FRAMES; i++)
+			buf[i] = buf1[i];
+		rx_bd->flag = 0;
+		rx_bd->offset = 0;
+		port->p_port_data->rx_out_data = (rx_bd->wrap) ?
+				port->p_port_data->rx_data_fifo : rx_bd + 1;
+
+	} else {
+		spin_unlock_irqrestore(&port->p_port_data->rx_channel_lock,
+						flags);
+		pr_info("No Data Available");
+		return -EAGAIN;
+	}
+	spin_unlock_irqrestore(&port->p_port_data->rx_channel_lock, flags);
+
+	return res;
+}
+EXPORT_SYMBOL(tdm_port_read);
+
+
+unsigned int tdm_port_write(void *h_port, void *p_data, u16 size)
+{
+	struct tdm_port *port = (struct tdm_port *)h_port;
+	struct tdm_bd *tx_bd;
+	unsigned long flags;
+	int err = TDM_E_OK;
+#ifdef TDM_CORE_DEBUG
+	bool data_flag = 0;
+#endif
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle");
+		return -ENXIO;
+	}
+
+	if (p_data == NULL) { /* invalid data*/
+		pr_err("Invalid Data");
+		return -EFAULT;
+	}
+
+	/* todo - verify that chanid is in open state  */
+	if (!port->p_port_data || !port->in_use)
+		return -EIO;
+
+	spin_lock_irqsave(&port->p_port_data->tx_channel_lock, flags);
+	tx_bd = port->p_port_data->tx_in_data;
+
+	if (!tx_bd->flag) {
+		tx_bd->length = size;
+		memcpy(tx_bd->p_data, p_data, size * port->slot_width);
+		tx_bd->flag = 1;
+		tx_bd->offset = 0;
+		port->p_port_data->tx_in_data = (tx_bd->wrap) ?
+				port->p_port_data->tx_data_fifo : tx_bd+1;
+		port->port_stat.tx_pkt_count++;
+#ifdef TDM_CORE_DEBUG
+		data_flag = 1;
+#endif
+	} else {
+		spin_unlock_irqrestore(&port->p_port_data->tx_channel_lock,
+						flags);
+		port->port_stat.tx_pkt_drop_count++;
+		pr_err("E_NO_MEMORY -Failed Transmit");
+		return -ENOMEM;
+	}
+	spin_unlock_irqrestore(&port->p_port_data->tx_channel_lock, flags);
+
+#ifdef	TDM_CORE_DEBUG
+	if (data_flag) {
+		int k;
+		pr_info("\nTX %d- Write - Port TX-%d\n", port->ch_id, size);
+		for (k = 0; k < size; k++)
+			pr_info("%x", p_data[k]);
+		pr_info("\n");
+	}
+#endif
+	return err;
+}
+EXPORT_SYMBOL(tdm_port_write);
+
+wait_queue_head_t *tdm_port_get_wait_queue(void  *h_port)
+{
+	struct tdm_port *port = (struct tdm_port *)h_port;
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle");
+		return NULL;
+	}
+
+	return &port->ch_wait_queue;
+
+}
+EXPORT_SYMBOL(tdm_port_get_wait_queue);
+
+/* Driver Function for select and poll. Based on Port no, it sleeps on
+ * waitque */
+unsigned int tdm_port_poll(void *h_port, unsigned int wait_time)
+{
+	struct tdm_port *port = (struct tdm_port *)h_port;
+
+	int rc;
+	unsigned long timeout = msecs_to_jiffies(wait_time);
+
+	if (port == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle\n");
+		return -ENXIO;
+	}
+	/* todo - verify that chanid is in open state  */
+	if (!port->p_port_data || !port->in_use)
+		return -EIO;
+
+	if (port->p_port_data->rx_out_data->flag) {
+		pr_debug("Data Available");
+		return TDM_E_OK;
+	}
+	if (timeout) {
+		rc = wait_event_interruptible_timeout(port->ch_wait_queue,
+					  port->p_port_data->rx_out_data->flag,
+					  timeout);
+
+		if (port->p_port_data->rx_out_data->flag) {
+			pr_debug("Data Available");
+			return TDM_E_OK;
+		}
+	}
+
+	return -EAGAIN;
+}
+EXPORT_SYMBOL(tdm_port_poll);
+
+unsigned int tdm_port_get_stats(void *h_port, struct tdm_port_stats *portStat)
+{
+	struct tdm_port *port = (struct tdm_port *)h_port;
+	int port_num;
+
+	if (port == NULL || portStat == NULL) { /* invalid handle*/
+		pr_err("Invalid Handle");
+		return -ENXIO;
+	}
+	port_num =  port->ch_id;
+
+	memcpy(portStat, &port->port_stat, sizeof(struct tdm_port_stats));
+
+	pr_info("TDM Port %d Get Stats", port_num);
+
+	return TDM_E_OK;
+}
+EXPORT_SYMBOL(tdm_port_get_stats);
+
+static int tdm_data_rx_deinterleave(struct tdm_adapter *adap)
+{
+	struct tdm_port *port, *next;
+	struct tdm_bd	*ch_bd;
+
+	int i, buf_size, ch_data_len = NUM_OF_FRAMES;
+	/* todo - need to be generic for u8 and u16 etc */
+	u16 *input_tdm_buffer;
+	u16 *pcm_buffer;
+	int framer_ch_data_size = NUM_OF_FRAMES;
+	bool ch_data = 0;
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(TDM_ACTIVE_CHANNELS * TDM_SLOT_WIDTH, 8);
+	int bytes_slot_offset = bytes_in_fifo_per_frame/TDM_SLOT_WIDTH;
+
+	buf_size = tdm_master_recv(adap, (void **)&input_tdm_buffer);
+	if (buf_size <= 0 || !input_tdm_buffer)
+		return -EINVAL;
+
+	/* de-interleaving for all ports*/
+	list_for_each_entry_safe(port, next, &adap->myports, list) {
+		/* if the port is not open */
+		if (!port->in_use || !port->p_port_data)
+			continue;
+
+		ch_bd = port->p_port_data->rx_in_data;
+
+		spin_lock(&port->p_port_data->rx_channel_lock);
+
+		/*if old data is to be discarded */
+		if (use_latest_tdm_data)
+			if (ch_bd->flag) {
+				ch_bd->flag = 0;
+				ch_bd->offset = 0;
+				if (ch_bd == port->p_port_data->rx_out_data)
+					port->p_port_data->rx_out_data =
+						ch_bd->wrap ?
+						port->p_port_data->rx_data_fifo
+						: ch_bd+1;
+				port->port_stat.rx_pkt_drop_count++;
+			}
+		/* if the bd is empty */
+		if (!ch_bd->flag) {
+			if (ch_bd->offset == 0)
+				ch_bd->length = port->rx_max_frames;
+
+			pcm_buffer = ch_bd->p_data + ch_bd->offset;
+			/* De-interleaving the data */
+			for (i = 0; i < ch_data_len; i++) {
+				pcm_buffer[i] =
+					input_tdm_buffer[i*bytes_slot_offset +
+								port->ch_id];
+			}
+			ch_bd->offset += ch_data_len * port->slot_width;
+
+			if (ch_bd->offset >=
+				(ch_bd->length - framer_ch_data_size)*
+							port->slot_width) {
+				ch_bd->flag = 1;
+				ch_bd->offset = 0;
+				port->p_port_data->rx_in_data = ch_bd->wrap ?
+						port->p_port_data->rx_data_fifo
+						: ch_bd+1;
+				ch_data = 1;
+			}
+		} else {
+			port->port_stat.rx_pkt_drop_count++;
+		}
+
+		spin_unlock(&port->p_port_data->rx_channel_lock);
+		if (ch_data) {
+			/*	Wake up the Port Data Poll event */
+			wake_up_interruptible(&port->ch_wait_queue);
+#ifdef	TDM_CORE_DEBUG
+			pr_info("Port RX-%d-%d\n", port->ch_id, ch_data_len);
+			for (i = 0; i < ch_data_len; i++)
+				pr_info("%x", pcm_buffer[i]);
+			pr_info("\n");
+#endif
+			port->port_stat.rx_pkt_count++;
+			ch_data = 0;
+		}
+	}
+	return TDM_E_OK;
+}
+
+static int tdm_data_tx_interleave(struct tdm_adapter *adap)
+{
+	struct tdm_port *port, *next;
+	struct tdm_bd	*ch_bd;
+	int i, buf_size, ch_data_len = NUM_OF_FRAMES;
+	bool last_data = 0;
+	/* todo - need to be generic for u8 and u16 etc */
+	u16 *output_tdm_buffer;
+	u16 *pcm_buffer;
+	int framer_ch_data_size = NUM_OF_FRAMES;
+	int bytes_in_fifo_per_frame =
+	    ALIGN_SIZE(TDM_ACTIVE_CHANNELS * TDM_SLOT_WIDTH, 8);
+	int bytes_slot_offset = bytes_in_fifo_per_frame/TDM_SLOT_WIDTH;
+
+#ifdef TDM_CORE_DEBUG
+	u8	data_flag = 0;
+#endif
+
+	buf_size = tdm_master_get_write_buf(adap, (void **)&output_tdm_buffer);
+	if (buf_size <= 0 || !output_tdm_buffer)
+		return -EINVAL;
+
+	memset(output_tdm_buffer, 0, sizeof(buf_size));
+
+	list_for_each_entry_safe(port, next, &adap->myports, list) {
+		/* if the channel is open */
+		if (!port->in_use || !port->p_port_data)
+			continue;
+		pr_debug("TX-Tdm %d (slots-)", port->ch_id);
+
+		spin_lock(&port->p_port_data->tx_channel_lock);
+		ch_bd = port->p_port_data->tx_out_data;
+		if (ch_bd->flag) {
+			pcm_buffer = (u16 *)((uint8_t *)ch_bd->p_data +
+								ch_bd->offset);
+			/*if the buffer has less frames than required */
+			if (framer_ch_data_size >=
+				((ch_bd->length) -
+					(ch_bd->offset/port->slot_width))) {
+				ch_data_len =
+					(ch_bd->length) -
+					(ch_bd->offset/port->slot_width);
+				last_data = 1;
+			} else {
+				ch_data_len = framer_ch_data_size;
+			}
+			/* Interleaving the data */
+			for (i = 0; i < ch_data_len; i++) {
+				/* todo - need to be genric for any size
+				   assignment*/
+				output_tdm_buffer[port->ch_id +
+					bytes_slot_offset * i] = pcm_buffer[i];
+			}
+			/* If all the data of this buffer is transmitted */
+			if (last_data) {
+				ch_bd->flag = 0;
+				ch_bd->offset = 0;
+				port->p_port_data->tx_out_data = ch_bd->wrap ?
+						port->p_port_data->tx_data_fifo
+						: ch_bd+1;
+				port->port_stat.tx_pkt_conf_count++;
+			} else {
+				ch_bd->offset += ch_data_len*port->slot_width;
+			}
+#ifdef	TDM_CORE_DEBUG
+		data_flag = 1;
+#endif
+		}
+		spin_unlock(&port->p_port_data->tx_channel_lock);
+	}
+
+#ifdef	TDM_CORE_DEBUG
+	if (data_flag) {
+		pr_info("TX-TDM Interleaved Data-\n");
+		for (i = 0; i < 64; i++)
+			pr_info("%x", output_tdm_buffer[i]);
+		pr_info("\n");
+	  }
+#endif
+	return TDM_E_OK;
+}
+
+static int tdm_data_tx_full(struct tdm_adapter *adap)
+{
+	pr_err("TX full mode data fetch is not supported yet");
+	return TDM_E_OK;
+}
+
+static int tdm_data_rx_full(struct tdm_adapter *adap)
+{
+	pr_err("RX full mode data fetch is not supported yet");
+	return TDM_E_OK;
+}
+
+static void tdm_data_tasklet_fn(unsigned long data)
+{
+	struct tdm_adapter *adapter = (struct tdm_adapter *)data;
+	if (adapter != NULL) {
+		if (adapter->adap_mode & 0xF0) {
+			tdm_data_tx_full(adapter);
+			tdm_data_rx_full(adapter);
+		} else {
+			tdm_data_tx_interleave(adapter);
+			tdm_data_rx_deinterleave(adapter);
+		}
+	}
+}
+
+
+MODULE_AUTHOR("Hemant Agrawal <hemant@freescale.com> and "
+	"Rajesh Gumasta <rajesh.gumasta@freescale.com>");
+MODULE_DESCRIPTION("TDM Driver Framework Core");
+MODULE_LICENSE("GPL");
diff --git a/drivers/tdm/tdm-dev.c b/drivers/tdm/tdm-dev.c
new file mode 100644
index 0000000..1a7f0aa
--- /dev/null
+++ b/drivers/tdm/tdm-dev.c
@@ -0,0 +1,386 @@
+/* driver/tdm/tdm-dev.c
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * tdm-dev.c - tdm-bus driver, char device interface
+ *
+ * Author:Hemant Agrawal <hemant@freescale.com>
+ * Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/tdm.h>
+#include <linux/tdm-dev.h>
+#include <linux/smp_lock.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h>
+
+#define TDM_FRAME_LENGTH NUM_OF_FRAMES
+static struct tdm_driver tdmdev_driver;
+static struct tasklet_struct tdmdev_stats_tasklet;
+
+static void print_port_stats(struct tdm_port *p_tdm_port,
+			struct tdm_port_stats *port_stats)
+{
+	pr_info("\tChannel-%d (minor=%d) statistics:\n \
+				rx_pkt_count	:%u\n \
+				rx_pkt_drop_count	:%u\n \
+				tx_pkt_count	:%u\n \
+				tx_pkt_drop_count	:%u\n \
+				txPktConf	:%u",
+		 p_tdm_port->ch_id, p_tdm_port->first_slot,
+		 port_stats->rx_pkt_count,
+		 port_stats->rx_pkt_drop_count,
+		 port_stats->tx_pkt_count,
+		 port_stats->tx_pkt_drop_count,
+		 port_stats->tx_pkt_conf_count);
+}
+
+static void dump_tdm_stats(unsigned long data)
+{
+/* todo implement it for the list of ports this driver maintains */
+/* struct tdm_port *h_port;
+ * struct tdm_port_stats	*port_stat;
+ * tdm_port_get_stats(h_port,port_stat);
+ * print_port_stats(h_port,port_stat);
+*/
+}
+
+static int tdm_proc_dump_stats(char *buffer, char **start, off_t offset,
+				 int length, int *eof, void *data)
+{
+	char *next = buffer;
+	unsigned size = length;
+	int t;
+
+	t = scnprintf(next, size, "Freescale tdm driver statistics.\n");
+	size -= t;
+	next += t;
+	tasklet_schedule(&tdmdev_stats_tasklet);
+
+	*eof = 1;
+	return length - size;
+}
+
+
+static int tdmdev_open(struct inode *inode, struct file *file)
+{
+	unsigned int minor = iminor(inode);
+	int err = TDM_E_OK;
+	void *handle;
+
+	pr_debug("OPEN Port- %d\n", minor);
+
+	if (file->private_data != NULL)
+		return -ENXIO;
+
+	if ((minor < 0) || (minor >= TDM_ACTIVE_CHANNELS)) {
+		pr_err("%s-minor number(%d)out of range\n", __func__, minor);
+		return -EINVAL;
+	}
+
+	err = tdm_port_open(&tdmdev_driver, minor, &handle);
+	if (err != TDM_E_OK) {
+		pr_err("Error in tdm_port_open(%d)- err %x\n", minor, err);
+		return -ENXIO;
+	}
+
+	file->private_data = handle;
+
+	return err;
+}
+
+static int tdmdev_close(struct inode *inode, struct file *file)
+{
+	unsigned int minor = iminor(inode);
+	int err = TDM_E_OK;
+
+	pr_debug("tdm_close(%p,%p)\n", inode, file);
+
+	if (!file->private_data) {
+		pr_err("%s-chan-%d-Null file pointer\n", __func__, minor);
+		return -ENXIO;
+	}
+
+	if ((minor < 0) || (minor >= TDM_ACTIVE_CHANNELS)) {
+		pr_err("%s-minor number(%d)out of range\n", __func__, minor);
+		return -EINVAL;
+	}
+
+	err = tdm_port_close((void *)file->private_data);
+	if (err != TDM_E_OK) {
+		pr_debug("Error in tdm_port_Close\n");
+		return -ENXIO;
+	}
+
+	file->private_data = NULL;
+
+	return err;
+}
+
+static long tdmdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+
+	if (!file->private_data) {
+		pr_err("%s--Null file pointer\n", __func__);
+		return -ENXIO;
+	}
+
+	err = tdm_port_ioctl((void *)file->private_data, cmd, arg);
+	if (err != TDM_E_OK) {
+		pr_err("Error in tdm_port_ioctl\n");
+		return -ENXIO;
+	}
+
+	return err;
+
+}
+
+
+static ssize_t tdmdev_read(struct file *file, char *data_buffer, size_t length,
+				loff_t *off)
+{
+	int err;
+	unsigned short p_data[TDM_FRAME_LENGTH];
+	uint16_t size = 0;
+
+	pr_debug("%s ", __func__);
+
+	if (!file->private_data) {
+		pr_err("%s--Null file pointer\n", __func__);
+		return -ENXIO;
+	}
+
+	err = tdm_port_read((void *)file->private_data, &p_data, &size);
+	if (err != TDM_E_OK) {
+		pr_debug("Error in tdm_port_read\n");
+		return -ENXIO;
+	}
+
+	err = copy_to_user((u16 *)data_buffer, p_data, length * 2);
+	if (err > 0) {
+		pr_err("Error in copy_to_user:%d bytes not copied", err);
+		return -EFAULT;
+	}
+
+	return size;
+}
+
+static ssize_t tdmdev_write(struct file *file, const char *data_buffer,
+				size_t length, loff_t *off)
+{
+	int err = TDM_E_OK;
+	unsigned short local_buffer[TDM_FRAME_LENGTH];
+	unsigned int size = 0;
+
+	pr_debug("%s ", __func__);
+
+	if (!file->private_data) {
+		pr_err("%s--Null file pointer\n", __func__);
+		return -EFAULT;
+	}
+
+	size = length;
+	if (length > TDM_FRAME_LENGTH) {
+		pr_err("Bufer Length is More than Maximum Allowed Length"
+			"(%d)<%d\n", TDM_FRAME_LENGTH, length);
+		return -ENXIO;
+	}
+
+	err = copy_from_user((void *)local_buffer, (u16 *)data_buffer,
+			length * 2);
+	if (err != TDM_E_OK) {
+		pr_err("Error in copy_from_user:%d bytes not copied", err);
+		return -EFAULT;
+
+	}
+
+	err = tdm_port_write((void *)file->private_data, local_buffer, size);
+	if (err != TDM_E_OK) {
+		pr_err("Error in tdm_port_write\n");
+		return -EFAULT;
+	}
+
+	return size;
+}
+
+static unsigned int tdmdev_poll(struct file *file, poll_table *wait)
+{
+	int err = TDM_E_OK;
+	int poll_time = 13;
+
+	pr_debug("%s ", __func__);
+
+	if (!file->private_data) {
+		pr_err("%s--Null file pointer\n", __func__);
+		return -ENXIO;
+	}
+
+	/* This function can be called by two process but on different
+	 minor device so locking is not required */
+	/* todo implement it using poll_wait */
+	err = tdm_port_poll((void *)file->private_data, poll_time);
+	if (err == TDM_E_OK) {
+		pr_debug("Data Available on Port\n");
+		return POLLIN | POLLRDNORM;
+	}
+
+	return -EINVAL;
+}
+
+static const struct file_operations tdmdev_fops = {
+	.owner		= THIS_MODULE,
+	.read		= tdmdev_read,
+	.write		= tdmdev_write,
+	.unlocked_ioctl	= tdmdev_ioctl,
+	.open		= tdmdev_open,
+	.release	= tdmdev_close,
+	.poll		= tdmdev_poll,
+};
+
+static struct class *tdm_dev_class;
+
+static int tdmdev_attach_adapter(struct tdm_adapter *adap)
+{
+	pr_debug("tdm-dev: attached to adapter [%s] id = %d\n",
+		 adap->name, adap->id);
+	return TDM_E_OK;
+}
+
+static int tdmdev_detach_adapter(struct tdm_adapter *adap)
+{
+	pr_debug("tdm-dev: adapter [%s] unregistered\n", adap->name);
+	return TDM_E_OK;
+}
+
+
+static int tdm_linux_register(void)
+{
+	struct proc_dir_entry  *proc_tdm, *proc_tdm_stats;
+	int res = 0;
+
+	res = register_chrdev(TDM_MAJOR_NUM, TDM_DEV_NAME, &tdmdev_fops);
+	if (res != 0) {
+		pr_err("TDM MAJOR no. %d Unable to register devfs",
+				TDM_MAJOR_NUM);
+		return -ENXIO;
+	}
+
+	/* Creating proc for tdm stats and register dumps*/
+	proc_tdm = proc_mkdir("tdm", NULL);
+	proc_tdm_stats = create_proc_read_entry("tdm-stats", 0, 0,
+					tdm_proc_dump_stats, NULL);
+	if ((proc_tdm == NULL) || (proc_tdm_stats == NULL)) {
+		unregister_chrdev(TDM_MAJOR_NUM, TDM_DEV_NAME);
+		pr_err("TDM_MAJOR_NUM %d Unable to create proc read entry -"
+				"proc/tdm/regs", TDM_MAJOR_NUM);
+		return -EINVAL;
+	}
+	tasklet_init(&tdmdev_stats_tasklet, dump_tdm_stats, 0);
+
+	return TDM_E_OK;
+}
+
+static int tdm_linux_unregister(void)
+{
+	tasklet_kill(&tdmdev_stats_tasklet);
+
+	/* Remove the proc entry */
+	remove_proc_entry("tdm-stats", NULL);
+	remove_proc_entry("tdm", NULL);
+
+	unregister_chrdev(TDM_MAJOR_NUM, TDM_DEV_NAME);
+
+	return TDM_E_OK;
+}
+
+
+static const struct tdm_device_id starlite_id[] = {
+	{ "fsl_starlite", 0 },
+	{ }
+};
+
+/*
+ * The legacy "tdmdev_driver" is used primarily to get notifications when
+ * TDM adapters are added or removed, so that each one gets an tdm_dev
+ * and is thus made available to userspace driver code.
+ */
+static struct tdm_driver tdmdev_driver = {
+	.attach_adapter = tdmdev_attach_adapter,
+	.detach_adapter = tdmdev_detach_adapter,
+	.id_table = starlite_id,
+};
+
+/* module load/unload record keeping */
+static int __init tdm_dev_init(void)
+{
+	int res;
+
+	pr_info(KERN_INFO "mknod tdm c %d 0\n", TDM_MAJOR_NUM);
+
+	tdm_dev_class = class_create(THIS_MODULE, "tdm-dev");
+	if (IS_ERR(tdm_dev_class)) {
+		res = PTR_ERR(tdm_dev_class);
+		goto out;
+	}
+
+	tdmdev_driver.id = 2;
+
+	res = tdm_add_driver(&tdmdev_driver);
+	if (res)
+		goto out_unreg_class;
+
+	if (tdm_linux_register() != TDM_E_OK) {
+		pr_err("Failed to Register the Linux Device!\n");
+		return -ENODEV;
+	}
+
+	pr_info("%s: registering the character device adap %x\n", __func__,
+			tdmdev_driver.adapter);
+	return 0;
+
+out_unreg_class:
+	class_destroy(tdm_dev_class);
+out:
+	pr_err("%s: registering the character device failed\n", __func__);
+	return res;
+}
+
+static void __exit tdm_dev_exit(void)
+{
+	tdm_linux_unregister();
+
+	pr_info("%s: unregistering the character device\n", __func__);
+	tdm_del_driver(&tdmdev_driver);
+	class_destroy(tdm_dev_class);
+}
+
+MODULE_AUTHOR("Hemant Agrawal <hemant@freescale.com> and "
+	"Rajesh Gumasta <rajesh.gumasta@freescale.com>");
+MODULE_DESCRIPTION("TDM /dev entries driver");
+MODULE_LICENSE("GPL");
+
+module_init(tdm_dev_init);
+module_exit(tdm_dev_exit);
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index f58e9d8..4c57733 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -399,6 +399,17 @@ struct i2c_device_id {
 			__attribute__((aligned(sizeof(kernel_ulong_t))));
 };
 
+/* tdm */
+
+#define TDM_NAME_SIZE   20
+#define TDM_MODULE_PREFIX "tdm:"
+
+struct tdm_device_id {
+	char name[TDM_NAME_SIZE];
+	kernel_ulong_t driver_data      /* Data private to the driver */
+			__attribute__((aligned(sizeof(kernel_ulong_t))));
+};
+
 /* spi */
 
 #define SPI_NAME_SIZE	32
diff --git a/include/linux/tdm-dev.h b/include/linux/tdm-dev.h
new file mode 100644
index 0000000..7d6e684
--- /dev/null
+++ b/include/linux/tdm-dev.h
@@ -0,0 +1,58 @@
+/* driver/tdm/tdm-dev.h
+ *
+ *  Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * tdm-dev.h - tdm-bus driver, char device interface
+ *
+ * Author:Hemant Agrawal <hemant@freescale.com>
+ * Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LINUX_TDM_DEV_H
+#define _LINUX_TDM_DEV_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/compiler.h>
+#endif /* __KERNEL__ */
+
+#define NCSW_TYPE_BASE		0xe0
+#define TDM_TYPE_BASE		(NCSW_TYPE_BASE+1)
+#define TDM_MAJOR_NUM		239	/* Device major number		*/
+#define TDM_DEV_NAME		"tdm"
+
+/* set slot value for this tdm */
+#define IOCTL_TDM_SET_START_SLOT	IOW(TDM_TYPE_BASE,	\
+						TDM_CHAN_SET_START_SLOT, int)
+
+/* set slot width, this should be in consistent with the adapters support */
+#define IOCTL_TDM_SET_SLOT_WIDTH	_IOW(TDM_TYPE_BASE,	\
+						TDM_CHAN_SET_SLOT_WIDTH, int)
+
+/* enable tdm for this channel */
+#define IOCTL_TDM_ENABLE_TDM		_IOW(TDM_TYPE_BASE,	\
+						TDM_CHAN_ENABLE_TDM, int)
+
+ /* disable tdm for this channel */
+#define IOCTL_TDM_DISABLE_TDM		_IOW(TDM_TYPE_BASE,	\
+						TDM_CHAN_DISABLE_TDM, int)
+
+/* set Rx Port Buffer Length */
+#define IOCTL_TDM_SET_RX_LENGTH		_IOW(TDM_TYPE_BASE,	\
+						TDM_CHAN_SET_RX_LENGTH, int)
+
+#endif /* _LINUX_TDM_DEV_H */
diff --git a/include/linux/tdm.h b/include/linux/tdm.h
new file mode 100644
index 0000000..45ea782
--- /dev/null
+++ b/include/linux/tdm.h
@@ -0,0 +1,319 @@
+/* include/linux/tdm.h
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ *
+ * tdm.h - definitions for the tdm-device framework interface
+ *
+ * Author:Hemant Agrawal <hemant@freescale.com>
+ * Rajesh Gumasta <rajesh.gumasta@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef _LINUX_TDM_H
+#define _LINUX_TDM_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/device.h>	/* for struct device */
+#include <linux/sched.h>	/* for completion */
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+
+/* channel coading RCS/TCS field of RFP/TFP */
+#define CHANNEL_8BIT_LIN	0x00000000	/* 8 bit linear */
+#define CHANNEL_8BIT_ULAW	0x00000001	/* 8 bit Mu-law */
+#define CHANNEL_8BIT_ALAW	0x00000002	/* 8 bit A-law */
+#define CHANNEL_16BIT_LIN	0x00000003	/* 16 bit Linear */
+
+/*todo - These parameters needs to be configured dynamically*/
+#define TDM_ACTIVE_CHANNELS	16	/* Number of channels active */
+#define TDM_CHANNEL_TYPE	CHANNEL_16BIT_LIN
+#if (TDM_CHANNEL_TYPE == CHANNEL_16BIT_LIN)
+	#define TDM_SLOT_WIDTH 2
+#else
+	#define TDM_SLOT_WIDTH 1
+#endif
+
+#define CH_1_MS_FRAMES		8
+#define NUM_MS			10
+#define NUM_OF_FRAMES		(NUM_MS * CH_1_MS_FRAMES) /* number of frames
+							   for 1 buffer */
+/* Port data size for one Processing Cycle */
+#define CH_DATA_SIZE		(NUM_OF_FRAMES * TDM_SLOT_WIDTH)
+
+/* General options */
+
+struct tdm_algorithm;
+struct tdm_adapter;
+struct tdm_port;
+struct tdm_driver;
+
+/* Align addr on a size boundary - adjust address up if needed */
+static inline int ALIGN_SIZE(u32 size, u32 alignment)
+{
+	return (size + alignment - 1) & (~(alignment - 1));
+}
+
+#if defined(CONFIG_TDM) || defined(CONFIG_TDM_MODULE)
+extern int tdm_master_enable(struct tdm_driver *);
+extern int tdm_master_disable(struct tdm_driver *);
+#endif /* TDM */
+
+/**
+ * struct tdm_driver - represent an TDM device driver
+ * @class: What kind of tdm device we instantiate (for detect)
+ * @id:Driver id
+ * @name: Name of the driver
+ * @attach_adapter: Callback for device addition (for legacy drivers)
+ * @detach_adapter: Callback for device removal (for legacy drivers)
+ * @probe: Callback for device binding
+ * @remove: Callback for device unbinding
+ * @shutdown: Callback for device shutdown
+ * @suspend: Callback for device suspend
+ * @resume: Callback for device resume
+ * @command: Callback for sending commands to device
+ * @id_table: List of TDM devices supported by this driver
+ * @list: List of drivers created (for tdm-core use only)
+ */
+struct tdm_driver {
+	unsigned int class;
+	unsigned int id;
+	char name[TDM_NAME_SIZE];
+
+	int (*attach_adapter)(struct tdm_adapter *);
+	int (*detach_adapter)(struct tdm_adapter *);
+
+	/* Standard driver model interfaces */
+	int (*probe)(const struct tdm_device_id *);
+	int (*remove)(void);
+
+	/* driver model interfaces that don't relate to enumeration */
+	void (*shutdown)(void);
+	int (*suspend)(pm_message_t mesg);
+	int (*resume)(void);
+
+	/* a ioctl like command that can be used to perform specific functions
+	 * with the device.
+	 */
+	int (*command)(unsigned int cmd, void *arg);
+
+	const struct tdm_device_id *id_table;
+
+	/* The associated adapter for this driver */
+	struct tdm_adapter *adapter;
+	struct list_head list;
+};
+
+/* tdm per port statistics structure, used for providing and storing tdm port
+ * statistics.
+ */
+struct tdm_port_stats{
+	unsigned int rx_pkt_count;	/* Rx frame count per channel */
+	unsigned int rx_pkt_drop_count;	/* Rx drop count per channel to
+					   clean space for new buffer */
+	unsigned int tx_pkt_count;	/* Tx frame count per channel */
+	unsigned int tx_pkt_conf_count;	/* Tx frame confirmation count per
+					   channel */
+	unsigned int tx_pkt_drop_count;	/* Tx drop count per channel due to
+					   queue full */
+};
+
+
+/* tdm Buffer Descriptor, used for Creating Interleaved and De-interleaved
+ * FIFOs
+ */
+struct tdm_bd {
+   unsigned char flag;		/* BD is full or empty */
+   unsigned char wrap;		/* BD is last in the queue */
+   unsigned short length;	/* Length of Data in BD */
+   /*todo use dyanmic memory
+   unsigned long *p_data; */	/* Data Pointer */
+   unsigned short p_data[NUM_OF_FRAMES];	/* Data Pointer */
+   unsigned long offset;	/* Offset of the Data Pointer to be used */
+};
+
+#define TDM_CH_RX_BD_RING_SIZE  3
+#define TDM_CH_TX_BD_RING_SIZE  3
+
+/* tdm RX-TX Channelised Data */
+struct tdm_port_data {
+	struct tdm_bd rx_data_fifo[TDM_CH_RX_BD_RING_SIZE]; /* Rx Port Data BD
+								Ring */
+	struct tdm_bd *rx_in_data;	/* Current Port Rx BD to be filled by
+						de-interleave function */
+	struct tdm_bd *rx_out_data;  /* Current Port Rx BD to be read by App */
+	struct tdm_bd tx_data_fifo[TDM_CH_TX_BD_RING_SIZE]; /* Tx Port Data BD
+								Ring */
+	struct tdm_bd *tx_in_data;	/* Current Port Tx BD to be filled by
+						App */
+	struct tdm_bd *tx_out_data;	/* Current Port Tx BD to be read by
+						interleave function */
+	spinlock_t rx_channel_lock;	/* Spin Lock for Rx Port */
+	spinlock_t tx_channel_lock;	/* Spin Lock for Tx Port */
+};
+
+/* struct tdm_port - represent an TDM ports for a device */
+struct tdm_port {
+	unsigned short flags;	/* div., see below */
+	unsigned short ch_id;	/* port ID - At present it is same as slot
+					Number */
+	unsigned short  first_slot;	/* Not Used */
+	unsigned short slot_width;	/* slot width for this port */
+	unsigned short in_use;		/* Port is enabled? */
+	uint16_t rx_max_frames;		/* Received Port frames
+					   before allowing Read Operation in
+					   Port Mode */
+
+	struct tdm_port_stats port_stat;/* A structure parameters defining
+					   TDM port statistics. */
+	struct tdm_port_data *p_port_data;	/* a structure parameters
+						defining tdm channelised data */
+	wait_queue_head_t ch_wait_queue;	/* waitQueue for RX Port Data */
+
+	struct tdm_driver *driver;	/* driver for this port */
+	struct list_head list;		/* list of ports */
+};
+
+/* tdm_algorithm is for accessing the routines of device */
+struct tdm_algorithm {
+	u32 (*tdm_read)(struct tdm_adapter *, u16 **);
+	u32 (*tdm_get_write_buf)(struct tdm_adapter *, u16 **);
+	u32 (*tdm_write)(struct tdm_adapter *, void * , unsigned int len);
+	int (*tdm_enable)(struct tdm_adapter *);
+	int (*tdm_disable)(struct tdm_adapter *);
+	/* To determine what the adapter supports */
+	u32 (*functionality) (struct tdm_adapter *);
+};
+
+/* tdm_adapter_mode is to define in mode of the device */
+enum tdm_adapter_mode {
+	e_TDM_ADAPTER_MODE_NONE = 0x00,
+	e_TDM_ADAPTER_MODE_T1 = 0x01,
+	e_TDM_ADAPTER_MODE_E1 = 0x02,
+	e_TDM_ADAPTER_MODE_T1_RAW = 0x10,
+	e_TDM_ADAPTER_MODE_E1_RAW = 0x20,
+};
+
+/* tdm_process_mode used for testing the tdm device in normal mode or internal
+ * loopback or external loopback
+ */
+enum tdm_process_mode{
+	e_TDM_PROCESS_NORMAL = 0	/* Normal mode */
+	, e_TDM_PROCESS_INT_LPB = 1	/* Internal loop mode */
+	, e_TDM_PROCESS_EXT_LPB = 2	/* External Loopback mode */
+};
+
+/*
+ * tdm_adapter is the structure used to identify a physical tdm device along
+ * with the access algorithms necessary to access it.
+ */
+struct tdm_adapter {
+	struct module *owner;	/* owner of the adapter module */
+	unsigned int id;	/* Adapter Id */
+	unsigned int class;	/* classes to allow probing for */
+	unsigned int drv_count;	/* Number of drivers associated with the
+				   adapter */
+
+	const struct tdm_algorithm *algo;	/* the algorithm to access the
+						   adapter*/
+
+	char name[TDM_NAME_SIZE];	/* Name of Adapter */
+	int tdm_mode;	/* Not Used : loopback or normal */
+	int adap_mode;	/* 0=None, 1= T1, 2= T1-FULL, 3=E1, 4 = E1-FULL */
+	int max_num_ports;	/* Not Used: Max Number of ports that can be
+				   created on this adapter */
+	struct mutex adap_lock;
+	struct device *parent;	/*Not Used*/
+
+	struct tasklet_struct tdm_data_tasklet;	/* tasklet handle to perform
+						   data processing*/
+	int tasklet_conf;	/* flag for tasklet configuration */
+	int tdm_rx_flag;
+
+	struct list_head myports;	/* list of ports, created on this
+					   adapter */
+	struct list_head list;
+	spinlock_t   portlist_lock;   /* Spin Lock for port_list */
+	void *data;
+};
+
+static inline void *tdm_get_adapdata(const struct tdm_adapter *dev)
+{
+	return dev->data;
+}
+
+static inline void tdm_set_adapdata(struct tdm_adapter *dev, void *data)
+{
+       dev->data = data;
+}
+
+/* functions exported by tdm.o */
+
+#if defined(CONFIG_TDM) || defined(CONFIG_TDM_MODULE)
+extern int tdm_add_adapter(struct tdm_adapter *);
+extern int tdm_del_adapter(struct tdm_adapter *);
+extern int tdm_register_driver(struct module *, struct tdm_driver *);
+extern void tdm_del_driver(struct tdm_driver *);
+
+extern unsigned int tdm_port_open(struct tdm_driver *, int , void **);
+extern unsigned int tdm_port_close(void *);
+extern unsigned int tdm_port_ioctl(void *, unsigned int, unsigned long);
+extern unsigned int tdm_port_read(void *, void *, u16 *);
+extern unsigned int tdm_port_write(void *, void *, u16);
+extern unsigned int tdm_port_poll(void *, unsigned int);
+
+static inline int tdm_add_driver(struct tdm_driver *driver)
+{
+	return tdm_register_driver(THIS_MODULE, driver);
+}
+
+/* call the tdm_driver->command() of all attached drivers with the given
+ * arguments */
+extern void tdm_driver_command(struct tdm_adapter *, unsigned int, void *);
+extern struct tdm_adapter *tdm_get_adapter(int id);
+extern void tdm_put_adapter(struct tdm_adapter *adap);
+
+/* Return the functionality mask */
+static inline u32 tdm_get_functionality(struct tdm_adapter *adap)
+{
+	return adap->algo->functionality(adap);
+}
+
+/* Return 1 if adapter supports everything we need, 0 if not. */
+static inline int tdm_check_functionality(struct tdm_adapter *adap, u32 func)
+{
+	return (func & tdm_get_functionality(adap)) == func;
+}
+
+#endif /* TDM */
+#endif /* __KERNEL__ */
+
+#define TDM_E_OK 0
+
+enum tdm_cmd_types {
+	TDM_CHAN_SET_MODE = 0,	/* Set the channel Mode (Full/Channelized) */
+	TDM_CHAN_SET_START_SLOT,/*Starting slot fo the port */
+	TDM_CHAN_SET_SLOT_WIDTH,/* Width of the slot */
+	TDM_CHAN_ENABLE_TDM,	/* Enable the TDM port of respective channel */
+	TDM_CHAN_DISABLE_TDM,	/* Disable the TDM port of respective channel */
+	TDM_CHAN_SET_RX_LENGTH	/* Minimum Received Port Buffer Length
+				   before allowing Read Operation in Port Mode*/
+};
+
+#endif /* _LINUX_TDM_H */
-- 
1.7.0.2

