From 62805c205fa361556e0a0963d03d8e7130616815 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 26 Jul 2013 13:06:48 +0800
Subject: [PATCH] fsl/pamu: only apply the fix of errata A-004510 for the affected SoCs

Extracted from the patch (powerpc/85xx: fsl-pamu: put the PAACT/OMT in
its own coherence subdomain (Erratum A-004510) in FSL SDK
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso.

This errata only affect some older CoreNet SoCs and all the future
CoreNet SoC will have this fixed. So check the SVR revision to avoid
applying the workaround on these fixed revisions.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/sysdev/fsl_pamu.c |  106 ++++++++++++++++++++++-----------------
 1 files changed, 60 insertions(+), 46 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index 538ac5f..a4e66cd 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -344,42 +344,7 @@ irqreturn_t pamu_av_isr(int irq, void *arg)
 #define LAWAR_CSDID_MASK	0x000FF000
 #define LAWAR_CSDID_SHIFT	12
 
-#ifdef CONFIG_P204x_RDB
-#define CSD_PORT_ID	0xFF000000
-#elif CONFIG_P3041_DS
-#define CSD_PORT_ID	0xFF000000
-#elif CONFIG_P4080_DS
-#define CSD_PORT_ID	0xFFF80000
-#elif CONFIG_P5020_DS || CONFIG_SBCP4080
-#define CSD_PORT_ID	0xFC000000
-#endif
-
-enum law_size {
-	LAW_SIZE_4K = 0xb,
-	LAW_SIZE_8K,
-	LAW_SIZE_16K,
-	LAW_SIZE_32K,
-	LAW_SIZE_64K,
-	LAW_SIZE_128K,
-	LAW_SIZE_256K,
-	LAW_SIZE_512K,
-	LAW_SIZE_1M,
-	LAW_SIZE_2M,
-	LAW_SIZE_4M,
-	LAW_SIZE_8M,
-	LAW_SIZE_16M,
-	LAW_SIZE_32M,
-	LAW_SIZE_64M,
-	LAW_SIZE_128M,
-	LAW_SIZE_256M,
-	LAW_SIZE_512M,
-	LAW_SIZE_1G,
-	LAW_SIZE_2G,
-	LAW_SIZE_4G,
-	LAW_SIZE_8G,
-	LAW_SIZE_16G,
-	LAW_SIZE_32G,
-};
+#define LAW_SIZE_4K		0xb
 
 struct ccsr_law {
 	u32	lawbarh;	/* LAWn base address high */
@@ -393,7 +358,7 @@ struct ccsr_law {
 /*
  * Create a coherence subdomain for a given memory block.
  */
-static int __init create_csd(phys_addr_t phys, size_t size)
+static int __init create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)
 {
 	struct device_node *np;
 	const __be32 *iprop;
@@ -470,7 +435,7 @@ static int __init create_csd(phys_addr_t phys, size_t size)
 	}
 
 	/* Store the Port ID in the (undocumented) proper CIDMRxx register */
-	csdids[csd_id] = CSD_PORT_ID;
+	csdids[csd_id] = csd_port_id;
 
 	/* Find the DDR LAW that maps to our buffer. */
 	for (i = 0; i < num_laws; i++) {
@@ -524,6 +489,35 @@ error:
 }
 #endif
 
+/*
+ * Table of SVRs and the corresponding PORT_ID values.
+ *
+ * All future CoreNet-enabled SOCs will have this erratum fixed, so this table
+ * should never need to be updated.  SVRs are guaranteed to be unique, so
+ * there is no worry that a future SOC will inadvertently have one of these
+ * values.
+ */
+static const struct {
+	u32 svr;
+	u32 port_id;
+} port_id_map[] = {
+	{0x82100010, 0xFF000000},	/* P2040 1.0 */
+	{0x82100011, 0xFF000000},	/* P2040 1.1 */
+	{0x82100110, 0xFF000000},	/* P2041 1.0 */
+	{0x82100111, 0xFF000000},	/* P2041 1.1 */
+	{0x82110310, 0xFF000000},	/* P3041 1.0 */
+	{0x82110311, 0xFF000000},	/* P3041 1.1 */
+	{0x82010020, 0xFFF80000},	/* P4040 2.0 */
+	{0x82000020, 0xFFF80000},	/* P4080 2.0 */
+	{0x82210010, 0xFC000000},       /* P5010 1.0 */
+	{0x82210020, 0xFC000000},       /* P5010 2.0 */
+	{0x82200010, 0xFC000000},	/* P5020 1.0 */
+	{0x82050010, 0xFF800000},	/* P5021 1.0 */
+	{0x82040010, 0xFF800000},	/* P5040 1.0 */
+};
+
+#define SVR_SECURITY	0x80000	/* The Security (E) bit */
+
 static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 				     const struct of_device_id *match)
 {
@@ -533,13 +527,15 @@ static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 	struct device_node *guts_node;
 	u64 size;
 	struct ppaace *ppaact = NULL;
+	int ret = 0;
 	struct ome *omt = NULL;
 	int irq;
 	struct page *p;
 #ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
 	size_t mem_size = 0;
 	unsigned int order = 0;
-	int ret;
+	u32 csd_port_id = 0;
+	unsigned i;
 #endif
 
 	printk(KERN_INFO "Setting Freescale static PAMU/IOMMU configuration\n");
@@ -614,13 +610,31 @@ static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 	dev_dbg(&dev->dev, "omt virt=%p phys=0x%llx\n", omt,
 		(unsigned long long) virt_to_phys(omt));
 
-	ret = create_csd(page_to_phys(p), mem_size);
-	if (ret) {
-		dev_err(&dev->dev, "could not create coherence subdomain\n");
-		free_pages((unsigned long)ppaact, order);
-		iounmap(guts_regs);
-		iounmap(pamu_regs);
-		return ret;
+	/* Check to see if we need to implement the work-around on this SOC */
+
+	/* Determine the Port ID for our coherence subdomain */
+	for (i = 0; i < ARRAY_SIZE(port_id_map); i++) {
+		if (port_id_map[i].svr == (mfspr(SPRN_SVR) & ~SVR_SECURITY)) {
+			csd_port_id = port_id_map[i].port_id;
+			dev_dbg(&dev->dev, "found matching SVR %08x\n",
+				port_id_map[i].svr);
+			break;
+		}
+	}
+
+	if (csd_port_id) {
+		dev_info(&dev->dev, "implementing work-around for erratum "
+			 "A-004510\n");
+		dev_dbg(&dev->dev, "creating coherency subdomain at address "
+			"0x%llx, size %zu, port id 0x%08x", page_to_phys(p),
+			mem_size, csd_port_id);
+
+		ret = create_csd(page_to_phys(p), mem_size, csd_port_id);
+		if (ret) {
+			dev_err(&dev->dev, "could not create coherence "
+				"subdomain\n");
+			return ret;
+		}
 	}
 #else
 	p = alloc_pages(GFP_KERNEL, get_order(PAACT_SIZE));
-- 
1.7.0

