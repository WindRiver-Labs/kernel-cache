From 367597117f4caae9862eed3e2815b74ead4621b5 Mon Sep 17 00:00:00 2001
From: Matt Peters <matt.peters@windriver.com>
Date: Mon, 26 Jan 2015 14:25:50 -0500
Subject: [PATCH 2/2] intel-iommu: allow ignoring Ethernet device RMRR with
 IOMMU passthrough

Some BIOS's are reporting DMAR RMRR entries for Ethernet devices
which is causing problems when PCI passthrough is enabled.  These
devices should be able to use the static identity map since the
host should not be enforcing specific address ranges when IOMMU
passthrough is enabled.

Originally-by: Matt Peters <matt.peters@windriver.com>
[PG: Added bootarg wrapper and documentation entries.]
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 Documentation/Intel-IOMMU.txt       | 18 ++++++++++++++++++
 Documentation/kernel-parameters.txt |  5 +++++
 drivers/iommu/intel-iommu.c         | 20 ++++++++++++++++++++
 3 files changed, 43 insertions(+)

diff --git a/Documentation/Intel-IOMMU.txt b/Documentation/Intel-IOMMU.txt
index cf9431db8731..1dcc3496002e 100644
--- a/Documentation/Intel-IOMMU.txt
+++ b/Documentation/Intel-IOMMU.txt
@@ -32,6 +32,24 @@ regions will fail. Hence BIOS uses RMRR to specify these regions along with
 devices that need to access these regions. OS is expected to setup
 unity mappings for these regions for these devices to access these regions.
 
+RMRR for other devices?
+-----------------------
+
+There are reports of BIOS out there that indicate RMRR regions for things
+like ethernet devices.  As per mainline commit c875d2c1b8083 ("iommu/vt-d:
+ Exclude devices using RMRRs from IOMMU API domains") such a device is
+"fundamentally incompatible" with the IOMMU API and "we must prevent such
+devices from being used by the IOMMU API."  However, in the event that
+the RMRR indicated by the BIOS is assumed to be just a reporting error,
+there is an additional iommu boot arg that can be used to ignore RMRR
+settings for ethernet, i.e. "intel_iommu=on,eth_no_rmrr iommu=pt".
+Note that iommu=pt is required in order to eth_no_rmrr to have effect.
+
+If you use this setting, you should consult with your hardware vendor to
+confirm that it is just a reporting error, and that it truly is not
+actively using any DMA to/from RMRR, as otherwise system instability
+may result.
+
 How is IOVA generated?
 ---------------------
 
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index e2ea982ad9ba..7c4898327973 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1178,6 +1178,11 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			than 32-bit addressing. The default is to look
 			for translation below 32-bit and if not available
 			then look in the higher range.
+		eth_no_rmrr [Default Off]
+			With this option provided, the kernel will ignore
+			any specified RMRR regions specified by the BIOS
+			for PCI ethernet devices.  Confirm with your hardware
+			vendor the RMRR regions are indeed invalid first.
 		strict [Default Off]
 			With this option on every unmap_single operation will
 			result in a hardware IOTLB flush operation as opposed
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index 14ea6fc24ff9..342469b3233c 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -441,6 +441,7 @@ static int dmar_map_gfx = 1;
 static int dmar_forcedac;
 static int intel_iommu_strict;
 static int intel_iommu_superpage = 1;
+static int intel_iommu_ethrmrr = 1;
 
 int intel_iommu_gfx_mapped;
 EXPORT_SYMBOL_GPL(intel_iommu_gfx_mapped);
@@ -470,6 +471,15 @@ static int __init intel_iommu_setup(char *str)
 			printk(KERN_INFO
 				"Intel-IOMMU: Forcing DAC for PCI devices\n");
 			dmar_forcedac = 1;
+		} else if (!strncmp(str, "eth_no_rmrr", 11)) {
+			if (!iommu_pass_through) {
+				printk(KERN_WARNING
+					"Intel-IOMMU: error - eth_no_rmrr requires iommu=pt\n");
+			} else {
+				printk(KERN_INFO
+					"Intel-IOMMU: ignoring ethernet RMRR values\n");
+				intel_iommu_ethrmrr = 0;
+			}
 		} else if (!strncmp(str, "strict", 6)) {
 			printk(KERN_INFO
 				"Intel-IOMMU: disable batched IOTLB flush\n");
@@ -2358,6 +2368,13 @@ static int iommu_should_identity_map(struct pci_dev *pdev, int startup)
 	 * and their respective RMRR info is lost. We exempt USB devices
 	 * from this process due to their usage of RMRRs that are known
 	 * to not be needed after BIOS hand-off to OS.
+	 *
+	 * As a temporary workaround for issues seen on ProLiant DL380p,
+	 * allow the operator to ignore the RMRR settings for ethernet
+	 * devices.  Ideally the end user should contact their vendor
+	 * regarding why there are RMRR, as per mainline c875d2c1b8083
+	 * ("iommu/vt-d: Exclude devices using RMRRs from IOMMU API domains")
+	 * it seems that these make no sense at all.
 	 */
 	if (device_has_rmrr(pdev)) {
 		int match = 0;
@@ -2365,6 +2382,9 @@ static int iommu_should_identity_map(struct pci_dev *pdev, int startup)
 		if ((pdev->class >> 8) == PCI_CLASS_SERIAL_USB)
 			match = 1;
 
+		if ((pdev->class >> 8) == PCI_CLASS_NETWORK_ETHERNET && !intel_iommu_ethrmrr)
+			match = 1;
+
 		if (!match)
 			return 0;
 	}
-- 
2.1.0

