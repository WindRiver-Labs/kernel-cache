From c16a6bc90052586a171fb9038c0a711bb0ccc74d Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 6 Nov 2014 10:35:53 +0800
Subject: [PATCH] nvme: Use get/put_locked_var replace get/put_cpu_var
 function

The get_nvmeq accesses per-cpu variables via get_cpu_var(), which disables
preemption and creates an atomic block of code. Between the get and put
of the variable, a spinlock is taken and hence violates the atomic
context by potentially sleeping and generating the following calltrace:

The local lock calls a rt safe spinlock and safely disables migration
while accessing the variable and using the local spin_locks to ensure local
serialization.

BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:905
in_atomic(): 1, irqs_disabled(): 0, pid: 1237, name: modprobe
Preemption disabled at:[<ffffffff813c1538>]
generic_make_request+0xd8/0x130

CPU: 20 PID: 1237 Comm: modprobe Not tainted
3.14.22-rt9-WR7.0.0.0_preempt-rt #1
Hardware name: Intel Corporation S2600WTT/S2600WTT, BIOS
GRNDSDP1.86B.0030.R03.1405061547 05/06/2014
 ffff8803cc7cbb40 ffff8803cc8ef580 ffffffff819df529 0000000000000000
 ffff8803cc8ef598 ffffffff8107ed43 ffff8803ccc20038 ffff8803cc8ef5b0
 ffffffff819e5e20 ffff8803ccc20000 ffff8803cc8ef5e0 ffffffffa16692da
Call Trace:
 [<ffffffff819df529>] dump_stack+0x4e/0x7a
 [<ffffffff8107ed43>] __might_sleep+0xe3/0x160
 [<ffffffff819e5e20>] rt_spin_lock+0x20/0x50
 [<ffffffffa16692da>] nvme_make_request+0x6a/0x1a0 [nvme]
 [<ffffffff813c1538>] generic_make_request+0xd8/0x130
 [<ffffffff813c15f8>] submit_bio+0x68/0x150
 [<ffffffff811b8d72>] _submit_bh+0x142/0x230
 [<ffffffff811ba67b>] block_read_full_page+0x29b/0x320
 [<ffffffff811bde60>] ? I_BDEV+0x10/0x10
 [<ffffffff81082230>] ? migrate_enable+0xb0/0x1b0
 [<ffffffff8112bb3f>] ? __lru_cache_add+0xbf/0x110
 [<ffffffff811be5e0>] ? blkdev_write_begin+0x30/0x30
 [<ffffffff811be5f8>] blkdev_readpage+0x18/0x20
 [<ffffffff8111cefa>] do_read_cache_page+0x7a/0x1a0
 [<ffffffff8111d05c>] read_cache_page+0x1c/0x30
 [<ffffffff813d1c90>] read_dev_sector+0x30/0xa0
 [<ffffffff813d3341>] read_lba+0xf1/0x1a0
 [<ffffffff813d3793>] ? find_valid_gpt+0xc3/0x6d0
 [<ffffffff813d37b1>] find_valid_gpt+0xe1/0x6d0
 [<ffffffff813e85bb>] ? string.isra.6+0x3b/0xf0
 [<ffffffff813d3da0>] ? find_valid_gpt+0x6d0/0x6d0
 [<ffffffff813d3e16>] efi_partition+0x76/0x410
 [<ffffffff813e9a1c>] ? vsnprintf+0x2cc/0x5e0
 [<ffffffff813e9dc9>] ? snprintf+0x39/0x40
 [<ffffffff813d3da0>] ? find_valid_gpt+0x6d0/0x6d0
 [<ffffffff813d27e7>] check_partition+0x107/0x220
 [<ffffffff813d23ed>] rescan_partitions+0xad/0x2d0
 [<ffffffff811bf995>] __blkdev_get+0x355/0x4b0
 [<ffffffff811bfb31>] blkdev_get+0x41/0x3c0
 [<ffffffff8119e17a>] ? unlock_new_inode+0x5a/0x80
 [<ffffffff811be49d>] ? bdget+0x13d/0x160
 [<ffffffff813cff6f>] add_disk+0x44f/0x4f0
 [<ffffffffa166a529>] nvme_probe+0x7f9/0x920 [nvme]
 [<ffffffff81416d32>] local_pci_probe+0x42/0xa0
 [<ffffffff8141643a>] ? pci_match_device+0xda/0xf0
 [<ffffffff81416e69>] pci_device_probe+0xd9/0x130
 [<ffffffff8156aa8e>] driver_probe_device+0x8e/0x270
 [<ffffffff8156ad3b>] __driver_attach+0x8b/0x90
 [<ffffffff8156acb0>] ? __device_attach+0x40/0x40
 [<ffffffff81568ac3>] bus_for_each_dev+0x73/0xb0
 [<ffffffff8156a58e>] driver_attach+0x1e/0x20
 [<ffffffff8156a1c8>] bus_add_driver+0x178/0x230
 [<ffffffff8156b3a4>] driver_register+0x64/0xf0
 [<ffffffff814165ee>] __pci_register_driver+0x7e/0x90
 [<ffffffffa1674000>] ? 0xffffffffa1673fff
 [<ffffffffa16740af>] nvme_init+0xaf/0xe8 [nvme]
 [<ffffffff81000332>] do_one_initcall+0xf2/0x150
 [<ffffffff8109aace>] ? rt_up_read+0xe/0x10
 [<ffffffff810779e2>] ? __blocking_notifier_call_chain+0x52/0x60
 [<ffffffff810ca356>] load_module+0x1926/0x2190
 [<ffffffff810c7360>] ? store_uevent+0x40/0x40
 [<ffffffff81183e3c>] ? vfs_read+0x11c/0x140
 [<ffffffff810c8369>] ? copy_module_from_fd.isra.50+0x119/0x170
 [<ffffffff810cad0e>] SyS_finit_module+0x7e/0x80
 [<ffffffff819e7056>] system_call_fastpath+0x1a/0x1f

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/block/nvme-core.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index 02351e2..2f042b4 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -40,6 +40,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <scsi/sg.h>
+#include <linux/locallock.h>
 #include <asm-generic/io-64-nonatomic-lo-hi.h>
 
 #include <trace/events/block.h>
@@ -68,6 +69,7 @@ module_param(nvme_major, int, 0);
 static int use_threaded_interrupts;
 module_param(use_threaded_interrupts, int, 0);
 
+static DEFINE_LOCAL_IRQ_LOCK(nvme_lock);
 static DEFINE_SPINLOCK(dev_list_lock);
 static LIST_HEAD(dev_list);
 static struct task_struct *nvme_thread;
@@ -287,7 +289,7 @@ static struct nvme_queue *raw_nvmeq(struct nvme_dev *dev, int qid)
 static struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)
 {
 	struct nvme_queue *nvmeq;
-	unsigned queue_id = get_cpu_var(*dev->io_queue);
+	unsigned short queue_id = get_locked_var(nvme_lock, *dev->io_queue);
 
 	rcu_read_lock();
 	nvmeq = rcu_dereference(dev->queues[queue_id]);
@@ -295,14 +297,14 @@ static struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)
 		return nvmeq;
 
 	rcu_read_unlock();
-	put_cpu_var(*dev->io_queue);
+	put_locked_var(nvme_lock, *dev->io_queue);
 	return NULL;
 }
 
 static void put_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)
 {
 	rcu_read_unlock();
-	put_cpu_var(nvmeq->dev->io_queue);
+	put_locked_var(nvme_lock, nvmeq->dev->io_queue);
 }
 
 static struct nvme_queue *lock_nvmeq(struct nvme_dev *dev, int q_idx)
-- 
1.7.5.4

