From da7bca7ff43290e6b9bcc42303b9d8a15a6371d0 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Thu, 7 Jan 2016 13:54:55 +0800
Subject: [PATCH] Revert "jffs2: bug fix of creating node when gc or find space"

This reverts commit 14098ca6e3c00cd15158e90f1e7b3727f19088b6.

The commit introduces the below "input/output error" on JFFS2 with
NAND flash:

The /data is a mount point of the JFFS2:
touch /data/1
touch: /data/1: Input/output error

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 fs/jffs2/dir.c      |    4 ----
 fs/jffs2/gc.c       |   10 ----------
 fs/jffs2/nodelist.c |    9 ---------
 fs/jffs2/nodelist.h |    5 -----
 fs/jffs2/write.c    |    1 -
 5 files changed, 0 insertions(+), 29 deletions(-)

diff --git a/fs/jffs2/dir.c b/fs/jffs2/dir.c
index fdf05c1..44c3b98 100644
--- a/fs/jffs2/dir.c
+++ b/fs/jffs2/dir.c
@@ -228,7 +228,6 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
 		  f->inocache->pino_nlink, inode->i_mapping->nrpages));
 
 	unlock_new_inode(inode);
-	jffs2_set_inocache_state_new(c, f->inocache, INO_STATE_N_NEW);
 	d_instantiate(dentry, inode);
 	return 0;
 
@@ -451,7 +450,6 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char
 	jffs2_complete_reservation(c);
 
 	unlock_new_inode(inode);
-	jffs2_set_inocache_state_new(c, f->inocache, INO_STATE_N_NEW);
 	d_instantiate(dentry, inode);
 	return 0;
 
@@ -599,7 +597,6 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
 	jffs2_complete_reservation(c);
 
 	unlock_new_inode(inode);
-	jffs2_set_inocache_state_new(c, f->inocache, INO_STATE_N_NEW);
 	d_instantiate(dentry, inode);
 	return 0;
 
@@ -777,7 +774,6 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de
 	jffs2_complete_reservation(c);
 
 	unlock_new_inode(inode);
-	jffs2_set_inocache_state_new(c, f->inocache, INO_STATE_N_NEW);
 	d_instantiate(dentry, inode);
 	return 0;
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 480fd2e..1875e57 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -317,16 +317,6 @@ int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
 
 	D1(printk(KERN_DEBUG "jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\n", jeb->offset, ref_offset(raw), ref_flags(raw), ic->ino));
 
-	/*create but not finished so find next block*/
-	if (ic->state_new == INO_STATE_I_NEW) {
-		D1(printk(KERN_DEBUG"%s(): ino #%u in state new so find next block\n",
-			  __func__, ic->ino));
-		c->gcblock = NULL;
-		mutex_unlock(&c->alloc_sem);
-		spin_unlock(&c->inocache_lock);
-		return 0;
-	}
-
 	/* Three possibilities:
 	   1. Inode is already in-core. We must iget it and do proper
 	      updating to its fragtree, etc.
diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index f6ec54c..af02bd1 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -411,15 +411,6 @@ void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache
 	spin_unlock(&c->inocache_lock);
 }
 
-void jffs2_set_inocache_state_new(struct jffs2_sb_info *c,
-				struct jffs2_inode_cache *ic, int state)
-{
-	spin_lock(&c->inocache_lock);
-	ic->state_new = state;
-	wake_up(&c->inocache_wq);
-	spin_unlock(&c->inocache_lock);
-}
-
 /* During mount, this needs no locking. During normal operation, its
    callers want to do other stuff while still holding the inocache_lock.
    Rather than introducing special case get_ino_cache functions or
diff --git a/fs/jffs2/nodelist.h b/fs/jffs2/nodelist.h
index 9b5f327..782e689 100644
--- a/fs/jffs2/nodelist.h
+++ b/fs/jffs2/nodelist.h
@@ -181,7 +181,6 @@ struct jffs2_inode_cache {
 				   here; other inodes store nlink.
 				   Zero always means that it's
 				   completely unlinked. */
-	uint32_t state_new;	/*create flag*/
 };
 
 /* Inode states for 'state' above. We need the 'GC' state to prevent
@@ -194,8 +193,6 @@ struct jffs2_inode_cache {
 #define INO_STATE_GC		4	/* GCing a 'pristine' node */
 #define INO_STATE_READING	5	/* In read_inode() */
 #define INO_STATE_CLEARING	6	/* In clear_inode() */
-#define INO_STATE_I_NEW		0	/* Just create but not finish*/
-#define INO_STATE_N_NEW		1	/* finished*/
 
 #define INO_FLAGS_XATTR_CHECKED	0x01	/* has no duplicate xattr_ref */
 
@@ -362,8 +359,6 @@ static inline struct jffs2_node_frag *frag_last(struct rb_root *root)
 /* nodelist.c */
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list);
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state);
-void jffs2_set_inocache_state_new(struct jffs2_sb_info *c,
-				struct jffs2_inode_cache *ic, int state);
 struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino);
 void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new);
 void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old);
diff --git a/fs/jffs2/write.c b/fs/jffs2/write.c
index 5a7b37f..c819eb0 100644
--- a/fs/jffs2/write.c
+++ b/fs/jffs2/write.c
@@ -34,7 +34,6 @@ int jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 	f->inocache->pino_nlink = 1; /* Will be overwritten shortly for directories */
 	f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
 	f->inocache->state = INO_STATE_PRESENT;
-	f->inocache->state_new = INO_STATE_I_NEW;
 
 	jffs2_add_ino_cache(c, f->inocache);
 	D1(printk(KERN_DEBUG "jffs2_do_new_inode(): Assigned ino# %d\n", f->inocache->ino));
-- 
1.7.0

