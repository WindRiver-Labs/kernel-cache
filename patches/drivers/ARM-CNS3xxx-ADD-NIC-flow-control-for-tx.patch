From 18d60ad073c8abb7479959e6b0a55be173d4f1c1 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 31 Aug 2011 16:44:33 +0800
Subject: [PATCH 1/4] ARM:CNS3xxx:ADD NIC flow control for tx

During CNS3xxx NIC's tx procedure, heavy egress traffic will consume
all DMA descriptors, which will lead to transmit failed.

When this happens, the driver reports a failure to the networking
subsystem. Too many failures will trigger self protection of networking
subsystem, which will block the NIC's transmit until re-activate the
device.

We should stop the tx queues of a device when its resource
exhausted, and restart the tx queues after the device finished its
work in queue.

To fix this problem, we add resource checking in NIC's transmit
routine. When the number of usable descriptors lower than a threshold,
or the remaining descriptors can not afford current packet, the driver
will stop tx queues. The stopped queues will restart in NIC's TSQE
(Transmit Queue Empty) ISR, the IRQ indicates the device has finished
all packets in DMA queue.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/cns3xxx/cns3xxx_main.c   |   29 +++++++++++++++++++++++++++++
 drivers/net/cns3xxx/cns3xxx_symbol.h |    1 +
 2 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/drivers/net/cns3xxx/cns3xxx_main.c b/drivers/net/cns3xxx/cns3xxx_main.c
index 409f748..ce01a6c 100644
--- a/drivers/net/cns3xxx/cns3xxx_main.c
+++ b/drivers/net/cns3xxx/cns3xxx_main.c
@@ -151,6 +151,8 @@ int TX_DESC_SIZE = 120;
 module_param(RX_DESC_SIZE, int, 0);
 module_param(TX_DESC_SIZE, int, 0);
 
+#define FREE_TX_DESCRIPTOR_THRESHOLD 5
+
 u8 ring_index; /* 0 or 1*/
 
 #ifdef CNS3XXX_DELAYED_INTERRUPT
@@ -991,6 +993,7 @@ int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev)
 		/* no enough tx descriptor */
 		spin_unlock_irqrestore(&tx_lock, flags);
 		/* re-queue the skb */
+		netif_tx_stop_all_queues(netdev);
 		return NETDEV_TX_BUSY;
 	}
 	tx_buffer = get_cur_tx_buffer(priv->tx_ring + ring_index);
@@ -1035,6 +1038,10 @@ int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev)
 			tx_desc[i]->cown = 0 ;
 	}
 
+	if (cns3xxx_check_enough_tx_descriptor(priv->tx_ring + ring_index,
+			FREE_TX_DESCRIPTOR_THRESHOLD) == 0)
+		netif_tx_stop_all_queues(netdev);
+
 	mb();
 
 	enable_tx_dma(ring_index, 1);
@@ -1158,6 +1165,16 @@ irqreturn_t cns3xxx_tstc_ring0_isr(int irq, void *dev_id)
 }
 #endif
 
+irqreturn_t cns3xxx_tsqe_ring0_isr(int irq, void *dev_id)
+{
+	int i;
+	for (i = PORT0_NETDEV_INDEX; i <= PORT2_NETDEV_INDEX; i++) {
+		if (net_dev_array[i] && (net_dev_array[i]->flags & IFF_UP))
+			netif_tx_start_all_queues(net_dev_array[i]);
+	}
+	return IRQ_HANDLED;
+}
+
 static int cns3xxx_install_isr(struct net_device *dev)
 {
 	int retval;
@@ -1205,6 +1222,18 @@ static int cns3xxx_install_isr(struct net_device *dev)
 		}
 #endif
 
+		printk(KERN_INFO "request TSQE_RING0_INTERRUPT_ID %d\n",
+			TSQE_RING0_INTERRUPT_ID);
+		retval = request_irq(TSQE_RING0_INTERRUPT_ID,
+			cns3xxx_tsqe_ring0_isr, IRQF_SHARED,
+			"TSQE_RING0", intr_netdev);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n",
+				"TSQE_RING0", TSQE_RING0_INTERRUPT_ID, retval);
+			return 3;
+		}
+
 	if (priv->num_rx_queues == 2) {
 #if defined(CNS3XXX_DOUBLE_RX_RING)
 		printk(KERN_INFO "request FSRC_RING1_INTERRUPT_ID %d\n",
diff --git a/drivers/net/cns3xxx/cns3xxx_symbol.h b/drivers/net/cns3xxx/cns3xxx_symbol.h
index 04bc989..af89db6 100644
--- a/drivers/net/cns3xxx/cns3xxx_symbol.h
+++ b/drivers/net/cns3xxx/cns3xxx_symbol.h
@@ -243,6 +243,7 @@
 #define FSRC_RING1_INTERRUPT_ID 55
 #define FSQF_RING1_INTERRUPT_ID 57
 
+#define TSQE_RING0_INTERRUPT_ID 52
 #define TSTC_RING0_INTERRUPT_ID 50
 
 #define TSTC_RING1_INTERRUPT_ID 54
-- 
1.7.0.4

