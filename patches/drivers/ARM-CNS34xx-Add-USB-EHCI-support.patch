From cae24ce6b3d87c141275d8732eb6dfe914f85ef5 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 15 Jun 2011 09:20:41 +0800
Subject: [PATCH 06/27] ARM:CNS34xx:Add USB EHCI support

The USB1 port on CNS34xx VB board is a USB2.0 port, the patch add
a USB EHCI driver for cns34xx board.

Extracted from vendor drop CNS3xxx-sdk-201102161603-v1.1_20110224.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm/mach-cns3xxx/cns3420vb.c            |   31 ++++++
 arch/arm/mach-cns3xxx/include/mach/cns3xxx.h |    2 +
 drivers/usb/Kconfig                          |    1 +
 drivers/usb/host/Kconfig                     |    6 +
 drivers/usb/host/ehci-cns3xxx.c              |  137 ++++++++++++++++++++++++++
 drivers/usb/host/ehci-hcd.c                  |    5 +
 6 files changed, 182 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/host/ehci-cns3xxx.c

diff --git a/arch/arm/mach-cns3xxx/cns3420vb.c b/arch/arm/mach-cns3xxx/cns3420vb.c
index 9832281..a58dae0 100644
--- a/arch/arm/mach-cns3xxx/cns3420vb.c
+++ b/arch/arm/mach-cns3xxx/cns3420vb.c
@@ -180,6 +180,31 @@ static struct platform_device cns3xxx_spi_controller_device = {
 	.name		= "cns3xxx_spi",
 };
 
+/* USB */
+static struct resource cns3xxx_usb_ehci_resource[] = {
+	[0] = {
+		.start = CNS3XXX_USB_BASE,
+		.end   = CNS3XXX_USB_BASE + SZ_16M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CNS3XXX_USB_EHCI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 cns3xxx_usb_dma_mask = 0xffffffffULL;
+
+static struct platform_device cns3xxx_usb_ehci_device = {
+	.name		= "cns3xxx-ehci",
+	.num_resources	= ARRAY_SIZE(cns3xxx_usb_ehci_resource),
+	.resource	= cns3xxx_usb_ehci_resource,
+	.dev		= {
+		.dma_mask		= &cns3xxx_usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffffULL,
+	},
+};
+
 /*
  * Initialization
  */
@@ -187,6 +212,7 @@ static struct platform_device *cns3420_pdevs[] __initdata = {
 	&cns3420_nor_pdev,
 	&cns3xxx_gpio_device,
 	&cns3xxx_spi_controller_device,
+	&cns3xxx_usb_ehci_device,
 };
 
 static void __init cns3420_init(void)
@@ -224,6 +250,11 @@ static struct map_desc cns3420_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(CNS3XXX_DMAC_BASE),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_USB_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_USB_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
 	},
 };
 
diff --git a/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h b/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h
index 94cca22..1f5929a 100644
--- a/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h
+++ b/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h
@@ -552,6 +552,8 @@ void cns3xxx_pwr_soft_rst(unsigned int block);
 void cns3xxx_pwr_clk_en(unsigned int block);
 int cns3xxx_cpu_clock(void);
 
+void cns3xxx_pwr_power_up(unsigned int block);
+
 /*
  * ARM11 MPCore interrupt sources (primary GIC)
  */
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 6a58cb1..cec8f91 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -64,6 +64,7 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_AT91SAM9G45
 	default y if ARCH_MXC
 	default y if ARCH_OMAP3
+	default y if ARCH_CNS3XXX
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 0679ce6..6af8bee 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -189,6 +189,12 @@ config USB_ISP1362_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called isp1362-hcd.
 
+config USB_CNS3XXX_EHCI
+	bool "Cavium CNS3XXX EHCI Module"
+	depends on USB && USB_EHCI_HCD
+	---help---
+	  Cavium CNS3XXX USB EHCI Chipset support
+
 config USB_OHCI_HCD
 	tristate "OHCI HCD support"
 	depends on USB && USB_ARCH_HAS_OHCI
diff --git a/drivers/usb/host/ehci-cns3xxx.c b/drivers/usb/host/ehci-cns3xxx.c
new file mode 100644
index 0000000..99401fc
--- /dev/null
+++ b/drivers/usb/host/ehci-cns3xxx.c
@@ -0,0 +1,137 @@
+
+#include <linux/platform_device.h>
+#include <mach/cns3xxx.h>
+
+static int cns3xxx_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval = 0;
+
+	printk(KERN_INFO "%s: !!WARNING!!"
+		" to verify the following ehci->caps ehci->regs\n",
+		__func__);
+	cns3xxx_pwr_power_up(1<<PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
+	cns3xxx_pwr_clk_en(1<<PM_CLK_GATE_REG_OFFSET_USB_HOST);
+	cns3xxx_pwr_soft_rst(1<<PM_SOFT_RST_REG_OFFST_USB_HOST);
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs
+		+ HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 0;
+	ehci_reset(ehci);
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci_writel(ehci, 0x00600060, hcd->regs + 0x94);
+	printk(KERN_INFO "%s,***Threshold OUT=0x60,IN=0x60 ***\n", __func__);
+	writel((readl((CNS3XXX_MISC_BASE_VIRT+0x04)) | (0X2<<24)),
+		(CNS3XXX_MISC_BASE_VIRT+0x04));
+
+	ehci_port_power(ehci, 0);
+
+	return retval;
+}
+
+static const struct hc_driver cns3xxx_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "CNS3XXX EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.reset			= cns3xxx_ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+	.get_frame_number	= ehci_get_frame,
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
+};
+
+static int cns3xxx_ehci_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	const struct hc_driver *driver = &cns3xxx_ehci_hc_driver;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto fail_create_hcd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		retval = -ENODEV;
+		goto fail_request_resource;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	hcd->regs = (void __iomem *) CNS3XXX_USB_BASE_VIRT;
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto fail_add_hcd;
+
+	return retval;
+
+fail_request_resource:
+fail_add_hcd:
+	usb_put_hcd(hcd);
+fail_create_hcd:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	return retval;
+}
+
+static int cns3xxx_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+MODULE_ALIAS("platform:cns3xxx-ehci");
+
+static struct platform_driver cns3xxx_ehci_driver = {
+	.probe = cns3xxx_ehci_probe,
+	.remove = cns3xxx_ehci_remove,
+	.driver = {
+		.name = "cns3xxx-ehci",
+	},
+};
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5a32023..97af916 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1172,6 +1172,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_USB_CNS3XXX_EHCI
+#include "ehci-cns3xxx.c"
+#define	PLATFORM_DRIVER		cns3xxx_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
-- 
1.7.0.4

