From eb1ae1f2f777484ef49589b00f28c90e6f78d501 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:22:49 +0800
Subject: [PATCH 07/47] gianfar: get cpu number based on packet header hash

Get the cpu number based on packet header hash.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-gianfar-get-cpu-number-based-on-packet-.patch.

Signed-off-by: Tarun Garg <b10794@freescale.com>
Signed-off-by: Tom Herbert <therbert@google.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c |   69 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 69 insertions(+), 0 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 1f70c7d..4aa32be 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -1045,6 +1045,75 @@ static void gfar_detect_errata(struct gfar_private *priv)
 			 priv->errata);
 }
 
+static int get_cpu_number(unsigned char *eth_pkt, int len)
+{
+	u32 addr1, addr2, ports;
+	struct ipv6hdr *ip6;
+	struct iphdr *ip;
+	u32 hash, ihl;
+	u8 ip_proto;
+	int cpu;
+	struct ethhdr *eth;
+	static u32 simple_hashrnd;
+	static int simple_hashrnd_initialized;
+
+	if (len < ETH_HLEN)
+		return -1;
+	else
+		eth = eth_pkt;
+
+	if (unlikely(!simple_hashrnd_initialized)) {
+		get_random_bytes(&simple_hashrnd, 4);
+		simple_hashrnd_initialized = 1;
+	}
+
+	switch (eth->h_proto) {
+	case __constant_htons(ETH_P_IP):
+		if (len < (ETH_HLEN + sizeof(*ip)))
+			return -1;
+
+		ip = (struct iphdr *) (eth_pkt + ETH_HLEN);
+		ip_proto = ip->protocol;
+		addr1 = ip->saddr;
+		addr2 = ip->daddr;
+		ihl = ip->ihl;
+		break;
+	case __constant_htons(ETH_P_IPV6):
+		if (len < (ETH_HLEN + sizeof(*ip6)))
+			return -1;
+
+		ip6 = (struct ipv6hdr *)(eth_pkt + ETH_HLEN);
+		ip_proto = ip6->nexthdr;
+		addr1 = ip6->saddr.s6_addr32[3];
+		addr2 = ip6->daddr.s6_addr32[3];
+		ihl = (40 >> 2);
+		break;
+	default:
+		return -EINVAL;
+	}
+	ports = 0;
+	switch (ip_proto) {
+	case IPPROTO_TCP:
+	case IPPROTO_UDP:
+	case IPPROTO_DCCP:
+	case IPPROTO_ESP:
+	case IPPROTO_AH:
+	case IPPROTO_SCTP:
+	case IPPROTO_UDPLITE:
+		if (len < (ETH_HLEN + (ihl * 4) + 4))
+			ports = *((u32 *) (eth_pkt + ETH_HLEN + (ihl * 4)));
+		break;
+
+	default:
+		break;
+	}
+
+	hash = jhash_3words(addr1, addr2, ports, simple_hashrnd);
+	cpu = hash & 0x1;
+
+	return cpu_online(cpu) ? cpu : -1;
+}
+
 /* Set up the ethernet device structure, private data,
  * and anything else we need before we start */
 static int gfar_probe(struct of_device *ofdev,
-- 
1.7.0.2

