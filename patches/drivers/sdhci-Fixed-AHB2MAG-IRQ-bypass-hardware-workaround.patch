From c59b1369309402a26cb761788349a559687ec24f Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 8 Aug 2011 10:28:17 +0800
Subject: [PATCH 43/47] sdhci: Fixed AHB2MAG IRQ bypass hardware workaround

Implement the workaround that the bit DCR[DMA__AHB2MAG_IRQ_BYPASS]
cannot be set automatically when SoC reset.

Signed-off-by: Gao Guanhua <B22826@freescale.com>
Signed-off-by: Jin Qing <b24347@freescale.com>

[Adjust the definition of macro SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS.]

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/mmc/host/sdhci-of-core.c |    3 +++
 drivers/mmc/host/sdhci.c         |    8 ++++++++
 drivers/mmc/host/sdhci.h         |    3 +++
 3 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/host/sdhci-of-core.c b/drivers/mmc/host/sdhci-of-core.c
index 0523afa..422b058 100644
--- a/drivers/mmc/host/sdhci-of-core.c
+++ b/drivers/mmc/host/sdhci-of-core.c
@@ -181,6 +181,9 @@ static int __devinit sdhci_of_probe(struct of_device *ofdev,
 	if (of_get_property(np, "fsl,sdhci-dma-broken", NULL))
 		host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
 
+	if (of_get_property(np, "fsl,sdhci-ahb2mag-irq-bypass", NULL))
+		host->quirks |= SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS;
+
 	clk = of_get_property(np, "clock-frequency", &size);
 	if (clk && size == sizeof(*clk) && *clk)
 		of_host->clock = *clk;
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 41ded9b..671ae84 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -180,6 +180,8 @@ static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios);
 
 static void sdhci_init(struct sdhci_host *host, int soft)
 {
+	u32 ctrl;
+
 	if (soft)
 		sdhci_reset(host, SDHCI_RESET_CMD|SDHCI_RESET_DATA);
 	else
@@ -189,6 +191,12 @@ static void sdhci_init(struct sdhci_host *host, int soft)
 	if (!(host->quirks & SDHCI_QUIRK_BROKEN_DMA))
 		sdhci_writel(host, SDHCI_CACHE_SNOOP, SDHCI_HOST_DMA_CONTROL);
 
+	if (host->quirks & SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS) {
+		ctrl = sdhci_readl(host, SDHCI_HOST_DMA_CONTROL);
+		ctrl |= SDHCI_AHB2MAG_IRQ_BYPASS;
+		sdhci_writel(host, ctrl, SDHCI_HOST_DMA_CONTROL);
+	}
+
 	sdhci_clear_set_irqs(host, SDHCI_INT_ALL_MASK,
 		SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index d787ee4..8d671ee 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -190,6 +190,7 @@
 
 /* 40C DMA control register */
 #define SDHCI_HOST_DMA_CONTROL	0x40C
+#define SDHCI_AHB2MAG_IRQ_BYPASS       0x20
 #define SDHCI_CACHE_SNOOP	0x40
 
 struct sdhci_ops;
@@ -252,6 +253,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
 /* Controller uses Auto CMD12 command to stop the transfer */
 #define SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12		(1<<25)
+/* Controller cannot set DCR[DMA__AHB2MAG_IRQ_BYPASS] automatically*/
+#define SDHCI_QUIRK_SET_AHB2MAG_IRQ_BYPASS             (1<<26)
 
 	int			irq;		/* Device IRQ */
 	void __iomem *		ioaddr;		/* Mapped address */
-- 
1.7.0.4

