From 3fcd6cacd20a10444febab2e050317d96ff73f10 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 1 Sep 2011 15:37:09 +0800
Subject: [PATCH] Create ptp_1588 proc entry only when IEEE 1588 is supported

In order to deal with PTPd error handling for unsupported BSPs,
the position of creating ptp_1588 proc entry is changed.
By doing this, we create '/proc/ptp_1588' only IEEE 1588 is
supported, eg. ptp_timer node is present.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c      |   15 +++++++++++++--
 drivers/net/gianfar.h      |    6 +++++-
 drivers/net/gianfar_1588.c |   10 +++++++---
 3 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 720c1e0..2dcb6ee 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -118,6 +118,9 @@ EXPORT_SYMBOL(devfp_tx_hook);
 const char gfar_driver_name[] = "Gianfar Ethernet";
 const char gfar_driver_version[] = "1.3";
 
+/* Used for determining hardware time stamps support */
+int ptp_1588_present = FALSE;
+
 static int gfar_enet_open(struct net_device *dev);
 static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static void gfar_reset_task(struct work_struct *work);
@@ -1233,6 +1236,12 @@ static int gfar_probe(struct of_device *ofdev,
 			priv->ptimer_present = 0;
 			printk(KERN_ERR "IEEE1588: ptp-timer init failed\n");
 		}
+
+		if (!ptp_1588_present) {
+			gfar_1588_proc_init();
+			ptp_1588_present = TRUE;
+		}
+
 		priv->rx_filer_enable = 1;
 		pmuxcr_guts_write();
 		printk(KERN_INFO "IEEE1588: ptp-timer initialized\n");
@@ -4518,13 +4527,15 @@ static struct of_platform_driver gfar_driver = {
 
 static int __init gfar_init(void)
 {
-	gfar_1588_proc_init(gfar_match, sizeof(gfar_match));
+	gfar_1588_node_init(gfar_match, sizeof(gfar_match));
 	return of_register_platform_driver(&gfar_driver);
 }
 
 static void __exit gfar_exit(void)
 {
-	gfar_1588_proc_exit();
+	if (ptp_1588_present)
+		gfar_1588_proc_exit();
+
 	of_unregister_platform_driver(&gfar_driver);
 }
 
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index c766eae..2c2bbcb 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -52,6 +52,9 @@
 #define ALIGNMENT 0x20
 #endif
 
+#define TRUE  1
+#define FALSE 0
+
 /* The maximum number of packets to be handled in one call of gfar_poll */
 #define GFAR_DEV_WEIGHT 64
 
@@ -1426,7 +1429,8 @@ extern void gfar_configure_rx_coalescing(struct gfar_private *priv,
 					long unsigned int rx_mask);
 void gfar_init_sysfs(struct net_device *dev);
 
-extern void gfar_1588_proc_init(struct of_device_id *dev_id, int cnt);
+extern void gfar_1588_node_init(struct of_device_id *dev_id, int cnt);
+extern void gfar_1588_proc_init(void);
 extern void gfar_1588_proc_exit(void);
 extern const struct ethtool_ops gfar_ethtool_ops;
 
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index 358f70e..d7550e0 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -806,7 +806,13 @@ static int gfar_1588_proc_write(struct file *file, const char *buffer,
 	return count;
 }
 
-void gfar_1588_proc_init(struct of_device_id *dev_id, int cnt)
+void gfar_1588_node_init(struct of_device_id *dev_id, int cnt)
+{
+	gfar_node.gfar_node_match = dev_id;
+	gfar_node.match_cnt = cnt;
+}
+
+void gfar_1588_proc_init()
 {
 	gfar_1588_proc_file = create_proc_entry(GFAR_1588_PROCFS_NAME,\
 							 0644, NULL);
@@ -825,8 +831,6 @@ void gfar_1588_proc_init(struct of_device_id *dev_id, int cnt)
 	gfar_1588_proc_file->uid	= 0;
 	gfar_1588_proc_file->gid	= 0;
 	gfar_1588_proc_file->data	= &gfar_1588_data;
-	gfar_node.gfar_node_match = dev_id;
-	gfar_node.match_cnt = cnt;
 	printk(KERN_INFO "/proc/%s created \r\n", GFAR_1588_PROCFS_NAME);
 }
 
-- 
1.7.0.4

