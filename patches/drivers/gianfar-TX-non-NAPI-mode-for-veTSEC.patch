From 6eb77d87e65875da0408444e478e8208f12e51f7 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:22:56 +0800
Subject: [PATCH 14/47] gianfar TX non-NAPI mode for veTSEC

TX non-NAPI mode for Ethernet load balance on multi-core.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-gianfar-TX-non-NAPI-mode-for-veTSEC.patch.

Signed-off-by: Jiajun Wu <b06378@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/Kconfig   |    7 +++++
 drivers/net/gianfar.c |   59 +++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/net/gianfar.h |    4 +-
 3 files changed, 68 insertions(+), 2 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index a6a6ea2..276ecf2 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2406,6 +2406,13 @@ config GIANFAR
 	  This driver supports the Gigabit TSEC on the MPC83xx, MPC85xx,
 	  and MPC86xx family of chips, and the FEC on the 8540.
 
+config GFAR_TX_NONAPI
+	default n
+	bool "TX non-NAPI mode"
+	depends on GIANFAR && EXPERIMENTAL && !GIANFAR_TXNAPI
+	help
+	  TX non-NAPI mode for Ethernet load balance on multi-core.
+
 config GIANFAR_TXNAPI
 	default n
 	bool "Introduce seperate tx_napi for cleaning the tx ring(V 0.0.1) (EXPERIMENTAL)"
diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index c01d502..7aeb505 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -3083,8 +3083,32 @@ static irqreturn_t gfar_transmit(int irq, void *grp_id)
 #ifdef CONFIG_GIANFAR_TXNAPI
 	gfar_schedule_cleanup_tx((struct gfar_priv_grp *)grp_id);
 #else
+#ifdef CONFIG_GFAR_TX_NONAPI
+	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+	struct gfar_private *priv = priv = grp->priv;
+	unsigned int mask = TSTAT_TXF0_MASK;
+	unsigned int tstat  = gfar_read(&grp->regs->tstat);
+	int i;
+	struct gfar_priv_tx_q *tx_queue = NULL;
+
+	tstat = gfar_read(&grp->regs->tstat);
+	tstat = tstat & TSTAT_TXF_MASK_ALL;
+	/* Clear IEVENT */
+	gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		if (tstat & mask) {
+			tx_queue = priv->tx_queue[i];
+			gfar_clean_tx_ring(tx_queue);
+		}
+		mask = mask >> 0x1;
+	}
+
+	gfar_configure_tx_coalescing(priv, grp->tx_bit_map);
+#else
 	gfar_schedule_cleanup((struct gfar_priv_grp *)grp_id);
 #endif
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -3259,8 +3283,32 @@ irqreturn_t gfar_receive(int irq, void *grp_id)
 #ifdef CONFIG_GIANFAR_TXNAPI
 	gfar_schedule_cleanup_rx((struct gfar_priv_grp *)grp_id);
 #else
+#ifdef CONFIG_GFAR_TX_NONAPI
+	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+	u32 tempval;
+
+	/*
+	 * Clear IEVENT, so interrupts aren't called again
+	 * because of the packets that have already arrived.
+	 */
+	gfar_write(&grp->regs->ievent, IEVENT_RX_MASK);
+
+	if (napi_schedule_prep(&grp->napi)) {
+		tempval = gfar_read(&grp->regs->imask);
+		tempval &= IMASK_RX_DISABLED;
+		gfar_write(&grp->regs->imask, tempval);
+		__napi_schedule(&grp->napi);
+	} else {
+		if (netif_msg_rx_err(grp->priv))
+			printk(KERN_DEBUG "%s: receive called twice (%x)[%x]\n",
+				dev->name, gfar_read(&grp->regs->ievent),
+				gfar_read(&grp->regs->imask));
+	}
+
+#else
 	gfar_schedule_cleanup((struct gfar_priv_grp *)grp_id);
 #endif
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -3544,7 +3592,11 @@ static int gfar_poll(struct napi_struct *napi, int budget)
 
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived */
+#ifdef CONFIG_GFAR_TX_NONAPI
+	gfar_write(&gfargrp->regs->ievent, IEVENT_RX_MASK);
+#else
 	gfar_write(&regs->ievent, IEVENT_RTX_MASK);
+#endif
 
 	while (num_queues && left_over_budget) {
 
@@ -3555,9 +3607,12 @@ static int gfar_poll(struct napi_struct *napi, int budget)
 			if (test_bit(i, &serviced_queues))
 				continue;
 			rx_queue = priv->rx_queue[i];
+
+#ifndef CONFIG_GFAR_TX_NONAPI
 			tx_queue = priv->tx_queue[rx_queue->qindex];
 
 			tx_cleaned += gfar_clean_tx_ring(tx_queue);
+#endif
 			rx_cleaned_per_queue = gfar_clean_rx_ring(rx_queue,
 							budget_per_queue);
 			rx_cleaned += rx_cleaned_per_queue;
@@ -3570,8 +3625,10 @@ static int gfar_poll(struct napi_struct *napi, int budget)
 		}
 	}
 
+#ifndef CONFIG_GFAR_TX_NONAPI
 	if (tx_cleaned)
 		return budget;
+#endif
 
 	if (rx_cleaned < budget) {
 		napi_complete(napi);
@@ -3584,7 +3641,9 @@ static int gfar_poll(struct napi_struct *napi, int budget)
 		/* If we are coalescing interrupts, update the timer */
 		/* Otherwise, clear it */
 		gfar_configure_rx_coalescing(priv, gfargrp->rx_bit_map);
+#ifndef CONFIG_GFAR_TX_NONAPI
 		gfar_configure_tx_coalescing(priv, gfargrp->tx_bit_map);
+#endif
 	}
 
 	return rx_cleaned;
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index abaaca3..58f256a 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -411,6 +411,7 @@ extern const char gfar_driver_version[];
 #define IMASK_FIQ		0x00000004
 #define IMASK_DPE		0x00000002
 #define IMASK_PERR		0x00000001
+#define IMASK_RX_DISABLED (~(IMASK_RXFEN0 | IMASK_BSY))
 #define IMASK_DEFAULT  (IMASK_TXEEN | IMASK_TXFEN | IMASK_TXBEN | \
 		IMASK_RXFEN0 | IMASK_BSY | IMASK_EBERR | IMASK_BABR | \
 		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_FGPI | \
@@ -421,8 +422,7 @@ extern const char gfar_driver_version[];
 #ifdef CONFIG_GIANFAR_TXNAPI
 #define IMASK_DEFAULT_TX	(IMASK_TXFEN | IMASK_TXBEN)
 #define IMASK_DEFAULT_RX	(IMASK_RXFEN0 | IMASK_RXB0 | IMASK_BSY)
-#define IMASK_RX_DISABLED	((~IMASK_DEFAULT_RX) \
-				& IMASK_DEFAULT)
+
 #define IMASK_TX_DISABLED	((~IMASK_DEFAULT_TX) \
 				& IMASK_DEFAULT)
 #endif
-- 
1.7.0.2

