From aaae87b41b0d6e18193d3f3fdf07e526814730c3 Mon Sep 17 00:00:00 2001
From: Dongdong Deng <Dongdong.Deng@windriver.com>
Date: Mon, 6 Jul 2009 16:02:57 +0800
Subject: [PATCH] drivers/net: keep interrupt status in net_send_packet()

spin_unlock_irq() will enable interrupt in net_send_packet(),
using spin_lock_irqsave() to replace spin_lock_irq() to keep the
interrupt status, so that kgdboe would work properly when using
cs89x0/isa-skeleton.

kgdb call trace over kgdboe:
kgdb()
{
 ...
 -> local_irq_save(flags);
    -> enter kgdboe moudle
      -> eth_flush_buf()
        -> netpoll_send_udp()
          -> netpoll_send_skb()
            -> net_send_packet()

 -> local_irq_restore(flags);
 ...
}

Signed-off-by: Dongdong Deng <Dongdong.Deng@windriver.com>
---
 drivers/net/cs89x0.c       |    7 ++++---
 drivers/net/isa-skeleton.c |    5 +++--
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/net/cs89x0.c b/drivers/net/cs89x0.c
index ea6144a..b943962 100644
--- a/drivers/net/cs89x0.c
+++ b/drivers/net/cs89x0.c
@@ -1518,6 +1518,7 @@ static void net_timeout(struct net_device *dev)
 
 static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
 {
+	unsigned long flags;
 	struct net_local *lp = netdev_priv(dev);
 
 	if (net_debug > 3) {
@@ -1530,7 +1531,7 @@ static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
                   ask the chip to start transmitting before the
                   whole packet has been completely uploaded. */
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, flags);
 	netif_stop_queue(dev);
 
 	/* initiate a transmit sequence */
@@ -1544,13 +1545,13 @@ static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
 		 * we're waiting for TxOk, so return 1 and requeue this packet.
 		 */
 
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, flags);
 		if (net_debug) printk("cs89x0: Tx buffer not free!\n");
 		return 1;
 	}
 	/* Write the contents of the packet */
 	writewords(dev->base_addr, TX_FRAME_PORT,skb->data,(skb->len+1) >>1);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, flags);
 	lp->stats.tx_bytes += skb->len;
 	dev->trans_start = jiffies;
 	dev_kfree_skb (skb);
diff --git a/drivers/net/isa-skeleton.c b/drivers/net/isa-skeleton.c
index d6ff26a..3049432 100644
--- a/drivers/net/isa-skeleton.c
+++ b/drivers/net/isa-skeleton.c
@@ -425,7 +425,8 @@ static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
 	 * hardware interrupt handler.  Queue flow control is
 	 * thus managed under this lock as well.
 	 */
-	spin_lock_irq(&np->lock);
+	unsigned long flags;
+	spin_lock_irqsave(&np->lock, flags);
 
 	add_to_tx_ring(np, skb, length);
 	dev->trans_start = jiffies;
@@ -441,7 +442,7 @@ static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
 	 * is when the transmit statistics are updated.
 	 */
 
-	spin_unlock_irq(&np->lock);
+	spin_unlock_irqrestore(&np->lock, flags);
 #else
 	/* This is the case for older hardware which takes
 	 * a single transmit buffer at a time, and it is
-- 
1.6.3.1

