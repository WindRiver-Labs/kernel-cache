From d6ffc3d4d464a1a0331b025d92165b356a40a2dc Mon Sep 17 00:00:00 2001
From: Lijun Guo <Lijun.Guo@windriver.com>
Date: Tue, 3 Feb 2015 13:35:58 +0800
Subject: [PATCH] move "wait-till-ready" checks into erase/write functions

Currently, m25p80.c which is a spi flash driver implements asynchronous
write and erase. In asynchronous mode, the following write/erase call wait
for the previous write/erase ops completion and then send write/erase
command, after this the function returns immediatelly. The problem is seen
when erasing a flash sector/block followed by an immediate system reset.
After reboot the flash sector/block is not erased. This is because the
last erase command has no time to execute in this situation. So we should
change write/erase function into synchronous mode. In synchronous mode,
write/erase function send command firstly, and then wait for ops
completion, the function only return after the write/erase ops completed.
This chage won't cause a significant impact on write performance,
especially continuous write/erase.

The driver's author of m25p80 writes spi-nor.c which based on m25p80.c,
and gives a patch to change spi-nor.c into synchronous mode. This patch
based on similar chages to m25p80.c.

Signed-off-by: Lijun Guo <Lijun.Guo@windriver.com>
---
 drivers/mtd/devices/m25p80.c |   50 ++++++++++-------------------------------
 1 files changed, 12 insertions(+), 38 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index d16e550..4e29a30 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -262,10 +262,6 @@ static int write_ear(struct m25p *flash, u32 addr)
 	u8 ear;
 	int ret;
 
-	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
-		return 1;
-
 	if (flash->mtd.size <= (0x1000000) << flash->shift)
 		return 0;
 
@@ -292,6 +288,9 @@ static int write_ear(struct m25p *flash, u32 addr)
 
 	flash->curbank = ear;
 
+	if (wait_till_ready(flash))
+		return 1;
+
 	return 0;
 }
 
@@ -305,10 +304,6 @@ static int erase_chip(struct m25p *flash)
 	pr_debug("%s: %s %lldKiB\n", dev_name(&flash->spi->dev), __func__,
 			(long long)(flash->mtd.size >> 10));
 
-	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
-		return 1;
-
 	if (flash->isstacked)
 		flash->spi->master->flags &= ~SPI_MASTER_U_PAGE;
 
@@ -321,9 +316,6 @@ static int erase_chip(struct m25p *flash)
 	spi_write(flash->spi, flash->command, 1);
 
 	if (flash->isstacked) {
-		/* Wait until finished previous write command. */
-		if (wait_till_ready(flash))
-			return 1;
 
 		flash->spi->master->flags |= SPI_MASTER_U_PAGE;
 
@@ -364,10 +356,6 @@ static int erase_sector(struct m25p *flash, u32 offset)
 	pr_debug("%s: %s %dKiB at 0x%08x\n", dev_name(&flash->spi->dev),
 			__func__, flash->mtd.erasesize / 1024, offset);
 
-	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
-		return 1;
-
 	/* update Extended Address Register */
 	if (write_ear(flash, offset))
 		return 1;
@@ -420,6 +408,8 @@ static int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)
 			mutex_unlock(&flash->lock);
 			return -EIO;
 		}
+		if (wait_till_ready(flash))
+			return 1;
 
 	/* REVISIT in some cases we could speed up erasing large regions
 	 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
@@ -449,6 +439,9 @@ static int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 			addr += mtd->erasesize;
 			len -= mtd->erasesize;
+
+			if (wait_till_ready(flash))
+				return 1;
 		}
 	}
 
@@ -489,11 +482,6 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	t[1].len = len;
 	spi_message_add_tail(&t[1], &m);
 
-	/* Wait till previous write/erase is done. */
-	if (wait_till_ready(flash))
-		/* REVISIT status return?? */
-		return 1;
-
 	/* FIXME switch to OPCODE_FAST_READ.  It's required for higher
 	 * clocks; and at this writing, every chip this driver handles
 	 * supports that opcode.
@@ -588,9 +576,6 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	t[1].tx_buf = buf;
 	spi_message_add_tail(&t[1], &m);
 
-	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
-		return 1;
 
 	write_enable(flash);
 
@@ -642,6 +627,9 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 		}
 	}
 
+	if (wait_till_ready(flash))
+		return 1;
+
 	return 0;
 }
 
@@ -718,11 +706,6 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 	mutex_lock(&flash->lock);
 
-	/* Wait until finished previous write command. */
-	ret = wait_till_ready(flash);
-	if (ret)
-		goto time_out;
-
 	write_enable(flash);
 
 	actual = to % 2;
@@ -782,6 +765,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		write_disable(flash);
 	}
 
+	ret = wait_till_ready(flash);
 time_out:
 	mutex_unlock(&flash->lock);
 	return ret;
@@ -795,11 +779,6 @@ static int m25p80_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 	int res = 0;
 
 	mutex_lock(&flash->lock);
-	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
-		res = 1;
-		goto err;
-	}
 
 	status_old = read_sr(flash);
 
@@ -840,11 +819,6 @@ static int m25p80_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 	int res = 0;
 
 	mutex_lock(&flash->lock);
-	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
-		res = 1;
-		goto err;
-	}
 
 	status_old = read_sr(flash);
 
-- 
1.7.5.4

