From beea5c3f42a24fffe7f565c3da1be135cf7c818c Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 11 Aug 2014 13:21:38 +0800
Subject: [PATCH 6/9] Revert "pwm: pwm-lpss: add pwm support for BayTrail bsp"

This reverts commit b2cec21ee9678c22c795db64f360f611aea4304c.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/Kconfig           |    3 +-
 drivers/acpi/acpi_lpss.c   |   12 ---
 drivers/pwm/Kconfig        |   17 ----
 drivers/pwm/Makefile       |    2 -
 drivers/pwm/pwm-lpss-pci.c |  116 -----------------------
 drivers/pwm/pwm-lpss.c     |  222 --------------------------------------------
 drivers/pwm/pwm-lpss.h     |   21 ----
 7 files changed, 2 insertions(+), 391 deletions(-)
 delete mode 100644 drivers/pwm/pwm-lpss-pci.c
 delete mode 100644 drivers/pwm/pwm-lpss.c
 delete mode 100644 drivers/pwm/pwm-lpss.h

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index c519087..55bba0b 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -433,7 +433,7 @@ config X86_INTEL_CE
 
 config X86_WANT_INTEL_MID
 	bool "Intel MID platform support"
-	depends on X86_32 || X86_64
+	depends on X86_32
 	depends on X86_EXTENDED_PLATFORM
 	---help---
 	  Select to build a kernel capable of supporting Intel MID platform
@@ -448,6 +448,7 @@ config X86_INTEL_MID
 config X86_MDFLD
        bool "Medfield MID platform"
 	depends on PCI
+	depends on PCI_GOANY
 	depends on X86_IO_APIC
 	select X86_INTEL_MID
 	select SFI
diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index c53e075..6273a18 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -142,17 +142,6 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.shared_clock = &i2c_clock,
 };
 
-static struct lpss_shared_clock pwm_clock = {
-        .name = "pwm_clk",
-        .rate = 25000000,
-};
-
-static struct lpss_device_desc byt_pwm_dev_desc = {
-        .clk_required = true,
-        .clk_gate = true,
-        .shared_clock = &pwm_clock,
-};
-
 static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	/* Generic LPSS devices */
 	{ "INTL9C60", (unsigned long)&lpss_dma_desc },
@@ -172,7 +161,6 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "80860F0E", (unsigned long)&byt_spi_dev_desc },
 	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
 	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
-	{ "80860F09", (unsigned long)&byt_pwm_dev_desc },
 	{ "INT33B2", },
 
 	{ "INT3430", (unsigned long)&lpt_dev_desc },
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 63c7280..ffe98d3 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -32,23 +32,6 @@ config PWM_SYSFS
 	bool
 	default y if SYSFS
 
-config PWM_LPSS
-	tristate "Intel LPSS PWM support"
-	depends on PCI || ACPI
-	help
-	  Generic PWM framework driver for Intel Low Power Subsystem PWM
-	  controller.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called pwm-lpio.
-
-config PWM_LPSS_PCI
-	tristate "Intel LPSS PWM PCI support"
-	depends on PWM_LPSS && PCI
-	help
-	   Generic PWM framework PCI driver for Intel Low Power Subsystem PWM
-	   controller.
-
 config PWM_AB8500
 	tristate "AB8500 PWM support"
 	depends on AB8500_CORE && ARCH_U8500
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index bc408c2..ee2a9c5 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -1,7 +1,5 @@
 obj-$(CONFIG_PWM)		+= core.o
 obj-$(CONFIG_PWM_SYSFS)		+= sysfs.o
-obj-$(CONFIG_PWM_LPSS)		+= pwm-lpss.o
-obj-$(CONFIG_PWM_LPSS_PCI)	+= pwm-lpss-pci.o
 obj-$(CONFIG_PWM_AB8500)	+= pwm-ab8500.o
 obj-$(CONFIG_PWM_ATMEL_TCB)	+= pwm-atmel-tcb.o
 obj-$(CONFIG_PWM_BFIN)		+= pwm-bfin.o
diff --git a/drivers/pwm/pwm-lpss-pci.c b/drivers/pwm/pwm-lpss-pci.c
deleted file mode 100644
index 9862640..0000000
--- a/drivers/pwm/pwm-lpss-pci.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Intel Low Power Subsystem PWM PCI controller driver
- *
- * Copyright (C) 2013, Intel Corporation
- * Author: Mika Westerberg <mika.westerberg@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/pci.h>
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pwm.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-
-#include "pwm-lpss.h"
-
-enum {
-        BYT_PWM_PORT0,
-        BYT_PWM_PORT1,
-};
-
-struct pwm_lpss_pci_config {
-	int bus_id;
-};
-
-static struct pwm_lpss_pci_config pwm_pci_configs[] = {
-	[BYT_PWM_PORT0] = {
-		.bus_id = 0,
-	},
-	[BYT_PWM_PORT1] = {
-		.bus_id = 1,
-	},
-};
-
-static int pwm_lpss_pci_probe(struct pci_dev *dev, const struct pci_device_id *ent)
-{
-	struct pwm_lpss_chip *lpwm;
-	struct platform_device_info pwm;
-	int ret;
-	struct platform_device *pdev;
-	struct pwm_lpss_pci_config *c = &pwm_pci_configs[ent->driver_data];
-
-	ret = pcim_enable_device(dev);
-	if (ret) {
-		dev_err(&dev->dev, "failed to enable PWM chip: %d\n", ret);
-		return ret;
-	}
-
-	ret = pcim_iomap_regions(dev, 1 << 0, "BYT PWM");
-	if (ret) {
-		dev_err(&dev->dev, "failed to map region for PWM chip: %d\n", ret);
-		return ret;
-	}
-
-	lpwm = devm_kzalloc(&dev->dev, sizeof(*lpwm), GFP_KERNEL);
-        if (!lpwm)
-                return -ENOMEM;
-
-	lpwm->regs = pcim_iomap_table(dev)[0];
-	if (!lpwm->regs)
-		return -EIO;
-
-	lpwm->clk = devm_clk_get(&dev->dev, NULL);
-
-	lpwm->chip.base = c->bus_id;
-
-	memset(&pwm, 0, sizeof(pwm));
-
-	pwm.parent = &dev->dev;
-	pwm.name = "pwm-lpss";
-	pwm.id = c->bus_id;
-	pwm.data = lpwm;
-	pwm.size_data = sizeof(*lpwm);
-
-	pdev = platform_device_register_full(&pwm);
-	if(!pdev)
-		return -ENOMEM;
-
-	pci_set_drvdata(dev, pdev);
-	return 0;
-}
-
-static void pwm_lpss_pci_remove(struct pci_dev *dev)
-{
-	struct platform_device *pdev = pci_get_drvdata(dev);
-	
-	platform_device_unregister(pdev);
-}
-
-static DEFINE_PCI_DEVICE_TABLE(pwm_lpss_pci_devices) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0f08),
-	  .driver_data = BYT_PWM_PORT0 },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0f09),
-	  .driver_data = BYT_PWM_PORT1 },
-	{ },
-};
-MODULE_DEVICE_TABLE(pci, pwm_lpss_pci_devices);
-
-static struct pci_driver pwm_lpss_pci_driver = {
-	.name = "pwm-lpss-pci",
-	.id_table = pwm_lpss_pci_devices,
-	.probe = pwm_lpss_pci_probe,
-	.remove = pwm_lpss_pci_remove,
-};
-module_pci_driver(pwm_lpss_pci_driver);
-
-MODULE_DESCRIPTION("PWM PCI driver for Intel LPSS");
-MODULE_AUTHOR("Mika Westerberg <mika.westerberg@linux.intel.com>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("pci:pwm-lpss");
diff --git a/drivers/pwm/pwm-lpss.c b/drivers/pwm/pwm-lpss.c
deleted file mode 100644
index 8c89041..0000000
--- a/drivers/pwm/pwm-lpss.c
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Intel Low Power Subsystem PWM controller driver
- *
- * Copyright (C) 2013, Intel Corporation
- * Author: Mika Westerberg <mika.westerberg@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/acpi.h>
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pwm.h>
-#include <linux/platform_device.h>
-
-#include "pwm-lpss.h"
-
-static void pwm_lpss_set_state(struct pwm_lpss_chip *lpwm, bool enable)
-{
-	u32 ctrl;
-
-	ctrl = readl(lpwm->regs + PWM);
-	if (enable)
-		ctrl |= PWM_ENABLE;
-	else
-		ctrl &= ~PWM_ENABLE;
-	writel(ctrl, lpwm->regs + PWM);
-}
-
-static u8 pwm_calculate_fraction(long remainder, long divisor)
-{
-	int i;
-	u8 flag = 0;
-	long temp, quotient = 0, adder = 0;
-	u8 fraction_flag = PWM_FRACTION_BIT1;
-	long fraction[PWM_FRACTION_SIZE] = {
-		50000000,	25000000,	12500000,	6250000,
-		3125000,	1562500,	781250,		390625,
-	};
-
-	/* Calculate the fraction values */
-	for (i = 0; i < PWM_FRACTION_SIZE; i++) {
-		quotient *= 10;
-		remainder *= 10;
-		quotient += (remainder / divisor);
-		remainder %= divisor;
-	}
-	/* Mapping fraction values to registers */
-	for (i = 0; i < PWM_FRACTION_SIZE; i++) {
-		temp = adder + fraction[i];
-		if ((quotient - temp) >= 0 ||
-				(temp - quotient) <= PWM_THRESHOLD) {
-			adder += fraction[i];
-			flag |= fraction_flag >> i;
-		}
-	}
-	return flag;
-}
-
-static int pwm_lpss_config(struct pwm_chip *chip, struct pwm_device *pwm,
-	int duty_ns, int period_ns)
-{
-	struct pwm_lpss_chip *lpwm = to_lpwm(chip);
-	u8 on_time_div, base_unit_hi = 0, base_unit_lo = 0;
-	long c = clk_get_rate(lpwm->clk);
-	long hz, remainder = 0;
-	u32 ctrl;
-	
-	hz = 1000000000UL / period_ns;
-
-	/*
-	 * There is no duty cycle resolution if base_unit value is higher
-	 * than 128.
-	 */
-	base_unit_hi = ((unsigned) hz * 256) / (unsigned) c;
-	if (base_unit_hi > 128)
-		return -EINVAL;
-
-	remainder = (hz * 256) % c;
-	if (remainder)
-		base_unit_lo = pwm_calculate_fraction(remainder, c);
-
-	if (duty_ns <= 0)
-		duty_ns = 1;
-	on_time_div = 255 - (255 * duty_ns / period_ns);
-
-	ctrl = readl(lpwm->regs + PWM);
-	ctrl &= ~(PWM_BASE_UNIT_MASK | PWM_ON_TIME_DIV_MASK);
-	ctrl |= ((base_unit_hi << PWM_HI_BASE_UNIT_SHIFT) |
-			(base_unit_lo << PWM_LO_BASE_UNIT_SHIFT));
-	ctrl |= on_time_div;
-	/* request PWM to update on next cycle */
-	ctrl |= PWM_SW_UPDATE;
-	writel(ctrl, lpwm->regs + PWM);
-
-	return 0;
-}
-
-static int pwm_lpss_enable(struct pwm_chip *chip, struct pwm_device *pwm)
-{
-	struct pwm_lpss_chip *lpwm = to_lpwm(chip);
-
-	clk_prepare_enable(lpwm->clk);
-	pwm_lpss_set_state(lpwm, true);
-	return 0;
-}
-
-static void pwm_lpss_disable(struct pwm_chip *chip, struct pwm_device *pwm)
-{
-	struct pwm_lpss_chip *lpwm = to_lpwm(chip);
-
-	pwm_lpss_set_state(lpwm, false);
-	clk_disable_unprepare(lpwm->clk);
-}
-
-static const struct pwm_ops pwm_lpss_ops = {
-	.config = pwm_lpss_config,
-	.enable = pwm_lpss_enable,
-	.disable = pwm_lpss_disable,
-	.owner = THIS_MODULE,
-};
-
-#ifdef CONFIG_ACPI
-struct pwm_lpss_chip *pwm_lpss_acpi_get_pdata(struct platform_device *pdev)
-{
-	struct pwm_lpss_chip *lpwm;
-	struct resource *r;
-	
-	lpwm = devm_kzalloc(&pdev->dev, sizeof(*lpwm), GFP_KERNEL);
-	if (!lpwm) {
-		dev_err(&pdev->dev, "failed to allocate memory for platform data\n");
-		return NULL;
-	}
-
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r) {
-		dev_err(&pdev->dev, "failed to get mmio base\n");
-		return NULL;
-	}
-
-	lpwm->clk = devm_clk_get(&pdev->dev, NULL);
-        if (IS_ERR(lpwm->clk)) {
-                dev_err(&pdev->dev, "failed to get pwm clk\n");
-                return NULL;
-        }
-
-	lpwm->chip.base = -1;
-
-	lpwm->regs = devm_request_and_ioremap(&pdev->dev, r);
-	if (!lpwm->regs)
-		return NULL;
-
-	return lpwm;
-}
-
-static const struct acpi_device_id pwm_lpss_acpi_match[] = {
-        { "80860F08", 0 },
-        { "80860F09", 0 },
-        { },
-};
-MODULE_DEVICE_TABLE(acpi, pwm_lpss_acpi_match);
-#else
-struct pwm_lpss_chip *pwm_lpss_acpi_get_pdata(struct platform_device *pdev)
-{
-	return NULL;
-}
-#endif
-
-static int pwm_lpss_probe(struct platform_device *pdev)
-{
-        struct device *dev = &pdev->dev;
-        struct pwm_lpss_chip *lpwm;
-	int ret;
- 
-        lpwm = dev_get_platdata(dev);
-        if (!lpwm){
-                lpwm = pwm_lpss_acpi_get_pdata(pdev);
-                if (!lpwm)
-                        return -ENODEV;
-        }
- 
-        lpwm->chip.dev = &pdev->dev;
-        lpwm->chip.ops = &pwm_lpss_ops;
-        lpwm->chip.npwm = 1;
-
-        ret = pwmchip_add(&lpwm->chip);
-        if (ret) {
-                dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
-                return ret;
-        }
- 
-        platform_set_drvdata(pdev, lpwm);
-        return 0;
- 
-}
-
-static int pwm_lpss_remove(struct platform_device *pdev)
-{
-	struct pwm_lpss_chip *lpwm = platform_get_drvdata(pdev);
-
-	pwm_lpss_set_state(lpwm, false);
-	return pwmchip_remove(&lpwm->chip);
-}
-
-static struct platform_driver pwm_lpss_driver = {
-	.driver = {
-		.name = "pwm-lpss",
-		.acpi_match_table = ACPI_PTR(pwm_lpss_acpi_match),
-	},
-	.probe = pwm_lpss_probe,
-	.remove = pwm_lpss_remove,
-};
-module_platform_driver(pwm_lpss_driver);
-
-MODULE_DESCRIPTION("PWM driver for Intel LPSS");
-MODULE_AUTHOR("Mika Westerberg <mika.westerberg@linux.intel.com>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:pwm-lpss");
diff --git a/drivers/pwm/pwm-lpss.h b/drivers/pwm/pwm-lpss.h
deleted file mode 100644
index ace2b51..0000000
--- a/drivers/pwm/pwm-lpss.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#define PWM			0x00000000
-#define PWM_ENABLE		BIT(31)
-#define PWM_SW_UPDATE		BIT(30)
-#define PWM_LO_BASE_UNIT_SHIFT	8
-#define PWM_HI_BASE_UNIT_SHIFT	16
-#define PWM_BASE_UNIT_MASK	0x00ffff00
-#define PWM_ON_TIME_DIV_MASK	0x000000ff
-#define PWM_THRESHOLD		900000
-#define PWM_FRACTION_SIZE	8
-#define PWM_FRACTION_BIT1	0x80
-
-struct pwm_lpss_chip {
-        struct pwm_chip chip;
-        void __iomem *regs;
-        struct clk *clk;
-};
- 
-static inline struct pwm_lpss_chip *to_lpwm(struct pwm_chip *chip)
-{
-        return container_of(chip, struct pwm_lpss_chip, chip);
-}
-- 
1.7.5.4

