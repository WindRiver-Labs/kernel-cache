From 950abe0966522aaaa677843f9d0916c83ed5af40 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:23:07 +0800
Subject: [PATCH 25/47] Read the Timer Osc Frequency value from the device tree

Read the Timer Osc Frequency value from the device tree
for PTP Node instead of using a hard coded value.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-Reading-the-Timer-Osc-Frequency-value-f.patch.

Signed-off-by: Bhaskar Upadhaya <Bhaskar.Upadhaya@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c      |   17 ++++-
 drivers/net/gianfar.h      |   16 ++--
 drivers/net/gianfar_1588.c |  174 ++++++++++++++++++++++++++++++++++++++------
 3 files changed, 173 insertions(+), 34 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index ede1a9f..73a01d0 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -937,12 +937,12 @@ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		return -ENODEV;
 
 	if ((cmd >= PTP_GET_RX_TIMESTAMP_SYNC) &&
-			(cmd <= PTP_CLEANUP_TIMESTAMP_BUFFERS))
+			(cmd <= PTP_CLEANUP_TIMESTAMP_BUFFERS)) {
 		if (priv->ptimer_present)
 			retVal = gfar_ioctl_1588(dev, rq, cmd);
 		else
 			retVal = -ENODEV;
-	else
+	} else
 		retVal = phy_mii_ioctl(priv->phydev, if_mii(rq), cmd);
 
 	return retVal;
@@ -2449,6 +2449,7 @@ int startup_gfar(struct net_device *ndev)
 	struct gfar_private *priv = netdev_priv(ndev);
 	struct gfar __iomem *regs = NULL;
 	int err, i, j;
+	u32 rctrl = 0;
 
 	for (i = 0; i < priv->num_grps; i++) {
 		regs= priv->gfargrp[i].regs;
@@ -2471,6 +2472,18 @@ int startup_gfar(struct net_device *ndev)
 		}
 	}
 
+	if (priv->ptimer_present) {
+		/* Enable Filer and Rx Packet Parsing capability of eTSEC */
+		/* Set Filer Table */
+		gfar_1588_start(ndev);
+		if (priv->device_flags & FSL_GIANFAR_DEV_HAS_PADDING)
+			rctrl &= RCTRL_PAL_MASK;
+		/* Enable Filer for Rx Queue */
+		rctrl |= RCTRL_PRSDEP_INIT |
+			RCTRL_TS_ENABLE | RCTRL_PADDING(8);
+		priv->padding = 0x8;
+	}
+
 	/* Start the controller */
 	gfar_start(ndev);
 
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index e86997e..333a7e3 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -139,7 +139,7 @@ extern const char gfar_driver_version[];
 #define GFAR_PTP_PKT_TYPE_OFFS		0x1f
 #define GFAR_PTP_PROTOCOL_OFFS		0x20
 #define GFAR_PTP_MULTI_ADDR_OFFS	0x26
-#define GFAR_PTP_PORT_OFFS		0x2A
+#define GFAR_PTP_PORT_OFFS		0x2C
 #define GFAR_PTP_MSG_TYPE_OFFS		0x32
 #define GFAR_PTP_SEQ_ID_OFFS		0x50
 #define GFAR_PTP_CTRL_OFFS		0x52
@@ -601,20 +601,13 @@ extern const char gfar_driver_version[];
 
 /* 1588 Module Registers bits */
 #define TMR_CTRL_ENABLE		0x00000004
-#define TMR_CTRL_RTC_CLK	0x00000003
-#define TMR_CTRL_EXT_CLK	0x00000000
-#define TMR_CTRL_SYS_CLK	0x00000001
-#define TMR_CTRL_TCLK_PRD	0x000A0000
-#define TMR_OSC_FREQ		300000000
 #define TMR_ADD_VAL		CONFIG_GFAR_PTP_TMR_ADD
 #define TMR_CTRL_TCLK_MASK	0x03ff0000
 #define TMR_PTPD_MAX_FREQ	0x80000
 #define TMR_CTRL_FIPER_START	0x10000000
-#define TMR_FIPER1		1000000000
 /*Alarm to traigger at 15sec boundary */
 #define TMR_ALARM1_L	0xD964B800
 #define TMR_ALARM1_H	0x00000045
-#define TMR_PRSC	0x2
 #define TMR_SEC		1000000000
 
 #define GFAR_INT_NAME_MAX	IFNAMSIZ + 4
@@ -1307,6 +1300,13 @@ struct gfar_private {
 	uint32_t ptimer_present;
 };
 
+struct gfar_ptp_attr_t {
+	u32 tclk_period;
+	u32 nominal_freq;
+	u32 sysclock_freq;
+	u32 freq_div_ratioo;
+};
+
 extern unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 extern unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
 
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index 52d0acb..45bdba6 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -1,7 +1,7 @@
 /*
  * drivers/net/gianfar_1588.c
  *
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
  * Copyright 2009 IXXAT Automation, GmbH
  *
  * Author: Anup Gangwar <anup.gangwar@freescale.com>
@@ -38,6 +38,8 @@ static int gfar_ptp_insert(struct gfar_ptp_circular_t *buf,
 			struct gfar_ptp_data_t *data);
 static int gfar_ptp_find_and_remove(struct gfar_ptp_circular_t *buf,
 			int key, struct gfar_ptp_data_t *data);
+static u32 nominal_frequency(u32 sysclock_freq);
+static void gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr);
 
 static DECLARE_WAIT_QUEUE_HEAD(ptp_rx_ts_wait);
 #define PTP_GET_RX_TIMEOUT	(HZ/10)
@@ -315,8 +317,17 @@ static void gfar_set_1588cnt(struct net_device *dev,
 			struct gfar_ptp_time *gfar_time)
 {
 	struct gfar_private *priv = netdev_priv(dev);
-	u32 tempval;
+	u32 tempval, *tmr_fiper1 = 0;
 	u64 alarm_value = 0, temp_alarm_val;
+	struct gfar_ptp_attr_t ptp_attr;
+	struct device_node *np;
+
+	memset(&ptp_attr, 0, sizeof(struct gfar_ptp_attr_t));
+	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
+	if (np == NULL)	{
+		printk(KERN_ERR "1588: Cannot find gianfar-ptp-timer node \r\n");
+		return;
+	}
 	temp_alarm_val = add64_oper((u64)gfar_time->low,
 		((u64)gfar_time->high)<<32);
 	div64_oper(temp_alarm_val, TMR_SEC, &tempval);
@@ -333,8 +344,15 @@ static void gfar_set_1588cnt(struct net_device *dev,
 	gfar_write(&(priv->ptimer->tmr_alarm1_l), tempval);
 	tempval = (u32)(alarm_value>>32);
 	gfar_write(&(priv->ptimer->tmr_alarm1_h), tempval);
+	gfar_ptp_cal_attr(&ptp_attr);
+	tmr_fiper1 = (u32 *)of_get_property(np, "tmr-fiper1", NULL);
+	if (tmr_fiper1 == NULL)	{
+		printk(KERN_ERR "1588: Cannot find tmr-fiper1 property \r\n");
+		return;
+	}
 	gfar_write(&(priv->ptimer->tmr_fiper1),
-		(TMR_FIPER1 - (TMR_CTRL_TCLK_PRD>>16)));
+		(*tmr_fiper1 - (ptp_attr.tclk_period>>16)));
+
 }
 
 /* Get both the time-stamps and use the larger one */
@@ -448,11 +466,26 @@ static void gfar_get_curr_cnt(struct gfar_regs_1588 __iomem *ptimer,
 void gfar_set_fiper_alarm(struct net_device *dev, struct gfar_ptp_time *alarm)
 {
 	struct gfar_private *priv = netdev_priv(dev);
-
+	struct gfar_ptp_attr_t ptp_attr;
+	u32 *tmr_fiper1 = 0;
+	struct device_node *np;
+
+	memset(&ptp_attr, 0, sizeof(struct gfar_ptp_attr_t));
+	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
+	if (np == NULL)	{
+		printk(KERN_ERR "1588: Cannot find gianfar-ptp-timer node \r\n");
+		return;
+	}
 	gfar_write(&(priv->ptimer->tmr_alarm1_l), alarm->low);
 	gfar_write(&(priv->ptimer->tmr_alarm1_h), alarm->high);
-	gfar_write(&(priv->ptimer->tmr_fiper1), TMR_FIPER1
-			- (TMR_CTRL_TCLK_PRD>>16));
+	gfar_ptp_cal_attr(&ptp_attr);
+	tmr_fiper1 = (u32 *)of_get_property(np, "tmr-fiper1", NULL);
+	if (tmr_fiper1 == NULL)	{
+		printk(KERN_ERR "1588: Cannot find tmr_fiper1 property \r\n");
+		return;
+	}
+	gfar_write(&(priv->ptimer->tmr_fiper1), *tmr_fiper1
+		- (ptp_attr.tclk_period>>16));
 }
 
 int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd)
@@ -527,39 +560,61 @@ int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd)
 /* 1588 Module intialization and filer table populating routine*/
 void gfar_1588_start(struct net_device *dev)
 {
-	u32 freq = 0;
 	struct gfar_private *priv = netdev_priv(dev);
+	struct gfar_ptp_attr_t ptp_attr;
+	u32 *tmr_fiper1 = 0, *tmr_prsc = 0, *cksel = 0;
+	struct device_node *np;
+
+	memset(&ptp_attr, 0, sizeof(struct gfar_ptp_attr_t));
+	gfar_ptp_cal_attr(&ptp_attr);
+	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
+	if (np == NULL)	{
+		printk(KERN_ERR "1588: Cannot find gianfar-ptp-timer node \r\n");
+		return;
+	}
+
+	tmr_prsc = (u32 *)of_get_property(np, "tmr-prsc", NULL);
+	if (tmr_prsc == NULL)	{
+		printk(KERN_ERR "1588: Cannot find tmr-prsc property \r\n");
+		return;
+	}
+
+	gfar_write(&(priv->ptimer->tmr_prsc), *tmr_prsc);
+
+	tmr_fiper1 = (u32 *)of_get_property(np, "tmr-fiper1", NULL);
+	if (tmr_fiper1 == NULL)	{
+		printk(KERN_ERR "1588: Cannot find tmr_fiper1 property \r\n");
+		return;
+	}
+
+	gfar_write(&(priv->ptimer->tmr_fiper1), *tmr_fiper1
+		 - (ptp_attr.tclk_period>>16));
 
-	gfar_write(&(priv->ptimer->tmr_prsc), TMR_PRSC);
-	gfar_write(&(priv->ptimer->tmr_fiper1), TMR_FIPER1
-		 - (TMR_CTRL_TCLK_PRD>>16));
 	gfar_write(&(priv->ptimer->tmr_alarm1_l), TMR_ALARM1_L);
 	gfar_write(&(priv->ptimer->tmr_alarm1_h), TMR_ALARM1_H);
 
 	/* Need to mask the TCLK bits as they are initialized with 1 */
 	gfar_write(&(priv->ptimer->tmr_ctrl),
 		(gfar_read(&(priv->ptimer->tmr_ctrl))
-		 & ~TMR_CTRL_TCLK_MASK) | TMR_CTRL_TCLK_PRD);
+			 & ~TMR_CTRL_TCLK_MASK) | (ptp_attr.tclk_period));
 
-	freq = TMR_SEC / (TMR_CTRL_TCLK_PRD>>16);
 	/* initialize TMR_ADD with the initial frequency compensation value:
 	 * freq_compensation = (2^32 / frequency ratio)
 	 */
-	div64_oper(((u64)freq << 32),
-		TMR_OSC_FREQ, &freq_compensation);
-
+	div64_oper((((u64)2 << 31)*100),
+		ptp_attr.freq_div_ratioo, &freq_compensation);
 	gfar_write(&(priv->ptimer->tmr_add), freq_compensation);
-#if defined(CONFIG_GFAR_PTP_EXTERNAL_CLK)
-	/* Select 1588 Timer source and enable module for starting Tmr Clock */
-	gfar_write(&(priv->ptimer->tmr_ctrl),
-		gfar_read(&(priv->ptimer->tmr_ctrl)) |
-		TMR_CTRL_ENABLE | TMR_CTRL_EXT_CLK | TMR_CTRL_FIPER_START);
-#else
-	/* Select 1588 Timer source and enable module for starting Tmr Clock */
+
+	cksel = (u32 *)of_get_property(np, "cksel", NULL);
+	if (cksel == NULL)	{
+		printk(KERN_ERR "1588: Cannot find cksel property \r\n");
+		return;
+	}
+
 	gfar_write(&(priv->ptimer->tmr_ctrl),
 		gfar_read(&(priv->ptimer->tmr_ctrl)) |
-		TMR_CTRL_ENABLE | TMR_CTRL_SYS_CLK | TMR_CTRL_FIPER_START);
-#endif
+		TMR_CTRL_ENABLE | *cksel | TMR_CTRL_FIPER_START);
+
 }
 
 /* Cleanup routine for 1588 module.
@@ -600,3 +655,74 @@ void pmuxcr_guts_write(void)
 	}
 #endif
 }
+
+/**
+ * nominal_frequency - This function calculates the nominal frequency.
+ * nominal frequency is the desired clock frequency.
+ * @sysclock_freq: Timer Oscillator Frequency
+ *
+ * Description:
+ *  Returns the nominal frequency which is calculated on the following
+ *  basis.
+ *  nominal frequency should be less than the Timer Oscillator frequency.
+ *  nominal frequency should be a factor of 1000.
+ *
+ *  Eg If Timer Oscillator frequency is 400.
+ *     then nominal frequency can be 250 or 200.
+ *
+ *     If Timer Oscillator frequency is 600.
+ *     then nominal frequency can be 500 or 250.
+ *
+ *     If Timer Oscillator frequency is 333.
+ *     then nominal frequency can be 250 or 200.
+ */
+u32 nominal_frequency(u32 sysclock_freq)
+{
+	u32 remainder = 0;
+
+	remainder = sysclock_freq % 50;
+	if (remainder != 0) {
+		sysclock_freq = sysclock_freq - remainder;
+		sysclock_freq += 50;
+	}
+
+	while ((10000 % (sysclock_freq -= 50)) != 0)
+		continue;
+	return sysclock_freq;
+}
+
+void gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr)
+{
+	u32 *sysclock_freq = 0, nominal_freq = 0, tclk_period = 0;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
+	if (np == NULL)	{
+		printk(KERN_ERR "1588: Cannot find gianfar-ptp-timer node \r\n");
+		return;
+	}
+	sysclock_freq = (u32 *)of_get_property(np, "timer-frequency", NULL);
+	if (sysclock_freq == NULL) {
+		printk(KERN_ERR "1588: Cannot find timer-frequency property \r\n");
+		return;
+	}
+	printk(KERN_INFO "1588 is running at system-clock"
+			" frequency (%u) \r\n", *sysclock_freq);
+
+	nominal_freq = nominal_frequency(*sysclock_freq / 1000000);
+
+	/* TCLK_PERIOD = 10^9/Nominal_Frequency in MHZ */
+	tclk_period = 1000/nominal_freq;
+	tclk_period <<= 16;
+	ptp_attr->tclk_period = tclk_period;
+	ptp_attr->nominal_freq = nominal_freq;
+	ptp_attr->sysclock_freq = *sysclock_freq / 1000000;
+
+	/*
+	 * FreqDivRatioo = Timer Oscillator Freq / Nominal Freq
+	 * and Timer Oscillator Freq = System Clock Freq
+	 */
+	ptp_attr->freq_div_ratioo = (ptp_attr->sysclock_freq *
+			100) / ptp_attr->nominal_freq;
+	return;
+}
-- 
1.7.0.2

