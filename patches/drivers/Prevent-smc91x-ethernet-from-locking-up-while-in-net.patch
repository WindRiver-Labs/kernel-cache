From 7d27aa923465247017eaa9e31d33c0424a78b4f4 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Sat, 7 Feb 2009 23:16:44 -0500
Subject: [PATCH] Prevent smc91x ethernet from locking up while in net_poll mode

Using KGDBoE with the smc91x ethernet device is unusable since it
locks up frequently no longer sending or receiving data. This patch
does several things to prevent this.

Several functions have had their locking updated to match what is
is seen with the smc911x driver and also to fix perceived errors
in the locking. The receive function has been modified to pull
all it can pull from the receive fifo allowing for better data
flow and memory usage. The watchdog timeout has been corrected
to match the comment and what is seen in the smc911x. A mdelay
has been added to the poll routine as it has been found that
without the delay reading the Interrupt Register at a high
frequency causes issues (basically the register reports the
same value even though it should in fact report a receive
interrupt event).

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 drivers/net/smc91x.c |  228 ++++++++++++++++++++++++++------------------------
 1 files changed, 120 insertions(+), 108 deletions(-)

diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index 02c7051..4dfb1aa 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -127,7 +127,7 @@ MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
 /*
  * Transmit timeout, default 5 seconds.
  */
-static int watchdog = 1000;
+static int watchdog = 5000;
 module_param(watchdog, int, 0400);
 MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
 
@@ -234,11 +234,12 @@ static void PRINT_PKT(u_char *buf, int length)
 /* this disables an interrupt from the interrupt mask register */
 #define SMC_DISABLE_INT(lp, x) do {					\
 	unsigned char mask;						\
-	spin_lock_irq(&lp->lock);					\
+	unsigned long int_flags;					\
+	spin_lock_irqsave(&lp->lock,int_flags);					\
 	mask = SMC_GET_INT_MASK(lp);					\
 	mask &= ~(x);							\
 	SMC_SET_INT_MASK(lp, mask);					\
-	spin_unlock_irq(&lp->lock);					\
+	spin_unlock_irqrestore(&lp->lock, int_flags);			\
 } while (0)
 
 /*
@@ -269,17 +270,18 @@ static void smc_reset(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	unsigned int ctl, cfg;
+	unsigned long int_flags;
 	struct sk_buff *pending_skb;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
 	/* Disable all interrupts, block TX tasklet */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 
 	/* free any pending tx skb */
 	if (pending_skb) {
@@ -397,16 +399,17 @@ static void smc_shutdown(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	struct sk_buff *pending_skb;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
 
 	/* no more interrupts for me */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	if (pending_skb)
 		dev_kfree_skb(pending_skb);
 
@@ -433,102 +436,99 @@ static inline void  smc_rcv(struct net_device *dev)
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
-	packet_number = SMC_GET_RXFIFO(lp);
-	if (unlikely(packet_number & RXFIFO_REMPTY)) {
-		PRINTK("%s: smc_rcv with nothing on FIFO.\n", dev->name);
-		return;
-	}
+	while(!((packet_number = SMC_GET_RXFIFO(lp)) & RXFIFO_REMPTY)) {
 
-	/* read from start of packet */
-	SMC_SET_PTR(lp, PTR_READ | PTR_RCV | PTR_AUTOINC);
+		/* read from start of packet */
+		SMC_SET_PTR(lp, PTR_READ | PTR_RCV | PTR_AUTOINC);
 
-	/* First two words are status and packet length */
-	SMC_GET_PKT_HDR(lp, status, packet_len);
-	packet_len &= 0x07ff;  /* mask off top bits */
-	DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
-		dev->name, packet_number, status,
-		packet_len, packet_len);
+		/* First two words are status and packet length */
+		SMC_GET_PKT_HDR(lp, status, packet_len);
+		packet_len &= 0x07ff;  /* mask off top bits */
+		DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
+			dev->name, packet_number, status,
+			packet_len, packet_len);
 
-	if (unlikely(packet_len == 0 && !(status & RS_ERRORS))) {
-		printk(KERN_ERR "%s: bad memory timings: rxlen %u status %x\n",
-			dev->name, packet_len, status);
-		status |= RS_TOOSHORT;
-	}
-	back:
-	if (unlikely(packet_len < 6 || status & RS_ERRORS)) {
-		if (status & RS_TOOLONG && packet_len <= (1514 + 4 + 6)) {
-			/* accept VLAN packets */
-			status &= ~RS_TOOLONG;
-			goto back;
-		}
-		if (packet_len < 6) {
-			/* bloody hardware */
-			printk(KERN_ERR "%s: fubar (rxlen %u status %x\n",
-					dev->name, packet_len, status);
+		if (unlikely(packet_len == 0 && !(status & RS_ERRORS))) {
+			printk(KERN_ERR "%s: bad memory timings: rxlen %u status %x\n",
+				dev->name, packet_len, status);
 			status |= RS_TOOSHORT;
 		}
-		SMC_WAIT_MMU_BUSY(lp);
-		SMC_SET_MMU_CMD(lp, MC_RELEASE);
-		dev->stats.rx_errors++;
-		if (status & RS_ALGNERR)
-			dev->stats.rx_frame_errors++;
-		if (status & (RS_TOOSHORT | RS_TOOLONG))
-			dev->stats.rx_length_errors++;
-		if (status & RS_BADCRC)
-			dev->stats.rx_crc_errors++;
-	} else {
-		struct sk_buff *skb;
-		unsigned char *data;
-		unsigned int data_len;
-
-		/* set multicast stats */
-		if (status & RS_MULTICAST)
-			dev->stats.multicast++;
-
-		/*
-		 * Actual payload is packet_len - 6 (or 5 if odd byte).
-		 * We want skb_reserve(2) and the final ctrl word
-		 * (2 bytes, possibly containing the payload odd byte).
-		 * Furthermore, we add 2 bytes to allow rounding up to
-		 * multiple of 4 bytes on 32 bit buses.
-		 * Hence packet_len - 6 + 2 + 2 + 2.
-		 */
-		skb = dev_alloc_skb(packet_len);
-		if (unlikely(skb == NULL)) {
-			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
-				dev->name);
+		back:
+		if (unlikely(packet_len < 6 || status & RS_ERRORS)) {
+			if (status & RS_TOOLONG && packet_len <= (1514 + 4 + 6)) {
+				/* accept VLAN packets */
+				status &= ~RS_TOOLONG;
+				goto back;
+			}
+			if (packet_len < 6) {
+				/* bloody hardware */
+				printk(KERN_ERR "%s: fubar (rxlen %u status %x\n",
+						dev->name, packet_len, status);
+				status |= RS_TOOSHORT;
+			}
 			SMC_WAIT_MMU_BUSY(lp);
 			SMC_SET_MMU_CMD(lp, MC_RELEASE);
-			dev->stats.rx_dropped++;
-			return;
-		}
-
-		/* Align IP header to 32 bits */
-		skb_reserve(skb, 2);
-
-		/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
-		if (lp->version == 0x90)
-			status |= RS_ODDFRAME;
-
-		/*
-		 * If odd length: packet_len - 5,
-		 * otherwise packet_len - 6.
-		 * With the trailing ctrl byte it's packet_len - 4.
-		 */
-		data_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);
-		data = skb_put(skb, data_len);
-		SMC_PULL_DATA(lp, data, packet_len - 4);
+			dev->stats.rx_errors++;
+			if (status & RS_ALGNERR)
+				dev->stats.rx_frame_errors++;
+			if (status & (RS_TOOSHORT | RS_TOOLONG))
+				dev->stats.rx_length_errors++;
+			if (status & RS_BADCRC)
+				dev->stats.rx_crc_errors++;
+		} else {
+			struct sk_buff *skb;
+			unsigned char *data;
+			unsigned int data_len;
+
+			/* set multicast stats */
+			if (status & RS_MULTICAST)
+				dev->stats.multicast++;
+
+			/*
+			 * Actual payload is packet_len - 6 (or 5 if odd byte).
+			 * We want skb_reserve(2) and the final ctrl word
+			 * (2 bytes, possibly containing the payload odd byte).
+			 * Furthermore, we add 2 bytes to allow rounding up to
+			 * multiple of 4 bytes on 32 bit buses.
+			 * Hence packet_len - 6 + 2 + 2 + 2.
+			 */
+			skb = dev_alloc_skb(packet_len);
+			if (unlikely(skb == NULL)) {
+				printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+					dev->name);
+				SMC_WAIT_MMU_BUSY(lp);
+				SMC_SET_MMU_CMD(lp, MC_RELEASE);
+				dev->stats.rx_dropped++;
+				return;
+			}
+
+			/* Align IP header to 32 bits */
+			skb_reserve(skb, 2);
+
+			/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
+			if (lp->version == 0x90)
+				status |= RS_ODDFRAME;
+
+			/*
+			 * If odd length: packet_len - 5,
+			 * otherwise packet_len - 6.
+			 * With the trailing ctrl byte it's packet_len - 4.
+			 */
+			data_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);
+			data = skb_put(skb, data_len);
+			SMC_PULL_DATA(lp, data, packet_len - 4);
 
-		SMC_WAIT_MMU_BUSY(lp);
-		SMC_SET_MMU_CMD(lp, MC_RELEASE);
+			SMC_WAIT_MMU_BUSY(lp);
+			SMC_SET_MMU_CMD(lp, MC_RELEASE);
 
-		PRINT_PKT(data, packet_len - 4);
+			PRINT_PKT(data, packet_len - 4);
 
-		dev->last_rx = jiffies;
-		skb->protocol = eth_type_trans(skb, dev);
-		netif_rx(skb);
-		dev->stats.rx_packets++;
-		dev->stats.rx_bytes += data_len;
+			dev->last_rx = jiffies;
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_rx(skb);
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += data_len;
+		}
 	}
 }
 
@@ -582,9 +582,12 @@ static void smc_hardware_send_pkt(unsigned long data)
 	struct sk_buff *skb;
 	unsigned int packet_no, len;
 	unsigned char *buf;
+	unsigned int flags;
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
+	spin_lock_irqsave(&lp->lock, flags);
+
 	if (!smc_special_trylock(&lp->lock)) {
 		netif_stop_queue(dev);
 		tasklet_schedule(&lp->tx_task);
@@ -650,7 +653,8 @@ static void smc_hardware_send_pkt(unsigned long data)
 
 	SMC_ENABLE_INT(lp, IM_TX_INT | IM_TX_EMPTY_INT);
 
-done:	if (!THROTTLE_TX_PKTS)
+ done:	spin_unlock_irqrestore(&lp->lock, flags);
+	if (!THROTTLE_TX_PKTS)
 		netif_wake_queue(dev);
 
 	dev_kfree_skb(skb);
@@ -1074,10 +1078,11 @@ static void smc_phy_configure(struct work_struct *work)
 	int my_phy_caps; /* My PHY capabilities */
 	int my_ad_caps; /* My Advertised capabilities */
 	int status;
+	unsigned long int_flags;
 
 	DBG(3, "%s:smc_program_phy()\n", dev->name);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 
 	/*
 	 * We should not be called if phy_type is zero.
@@ -1159,7 +1164,7 @@ static void smc_phy_configure(struct work_struct *work)
 
 smc_phy_configure_exit:
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 /*
@@ -1353,6 +1358,7 @@ static void smc_poll_controller(struct net_device *dev)
 {
 	disable_irq(dev->irq);
 	smc_interrupt(dev->irq, dev);
+	mdelay(5);
 	enable_irq(dev->irq);
 }
 #endif
@@ -1363,10 +1369,11 @@ static void smc_timeout(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	int status, mask, eph_st, meminfo, fifo;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	status = SMC_GET_INT(lp);
 	mask = SMC_GET_INT_MASK(lp);
 	fifo = SMC_GET_FIFO(lp);
@@ -1374,7 +1381,7 @@ static void smc_timeout(struct net_device *dev)
 	eph_st = SMC_GET_EPH_STATUS(lp);
 	meminfo = SMC_GET_MIR(lp);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	PRINTK( "%s: TX timeout (INT 0x%02x INTMASK 0x%02x "
 		"MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",
 		dev->name, status, mask, meminfo, fifo, eph_st );
@@ -1407,6 +1414,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 	void __iomem *ioaddr = lp->base;
 	unsigned char multicast_table[8];
 	int update_multicast = 0;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1489,7 +1497,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		update_multicast = 1;
 	}
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 0);
 	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 	if (update_multicast) {
@@ -1497,7 +1505,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		SMC_SET_MCAST(lp, multicast_table);
 	}
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 
@@ -1510,6 +1518,7 @@ static int
 smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1543,9 +1552,9 @@ smc_open(struct net_device *dev)
 	if (lp->phy_type != 0)
 		smc_phy_configure(&lp->phy_configure);
 	else {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		smc_10bt_check_media(dev, 1);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	netif_start_queue(dev);
@@ -1583,14 +1592,15 @@ smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	cmd->maxtxpkt = 1;
 	cmd->maxrxpkt = 1;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_gset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		cmd->supported = SUPPORTED_10baseT_Half |
 				 SUPPORTED_10baseT_Full |
@@ -1617,11 +1627,12 @@ smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_sset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		if (cmd->autoneg != AUTONEG_DISABLE ||
 		    cmd->speed != SPEED_10 ||
@@ -1653,11 +1664,12 @@ static int smc_ethtool_nwayreset(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret = -EINVAL;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_nway_restart(&lp->mii);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	return ret;
-- 
1.6.0.3

