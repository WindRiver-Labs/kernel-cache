From 96bb711fc1f9e7b65ef4dcb73f4484d62b2ad69f Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Sat, 7 Feb 2009 23:16:44 -0500
Subject: [PATCH] Prevent smc91x ethernet from locking up while in net_poll mode

Using KGDBoE with the smc91x ethernet device is unusable since it
locks up frequently no longer sending or receiving data. This patch
does several things to prevent this.

Several functions have had their locking updated to match what is
is seen with the smc911x driver and also to fix perceived errors
in the locking. The receive function has been modified to pull
all it can pull from the receive fifo allowing for better data
flow and memory usage. The watchdog timeout has been corrected
to match the comment and what is seen in the smc911x. A mdelay
has been added to the poll routine as it has been found that
without the delay reading the Interrupt Register at a high
frequency causes issues (basically the register reports the
same value even though it should in fact report a receive
interrupt event).

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 drivers/net/smc91x.c |   59 +++++++++++++++++++++++++++++++------------------
 1 files changed, 37 insertions(+), 22 deletions(-)

diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index 02c7051..9a821f2 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -127,7 +127,7 @@ MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
 /*
  * Transmit timeout, default 5 seconds.
  */
-static int watchdog = 1000;
+static int watchdog = 5000;
 module_param(watchdog, int, 0400);
 MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
 
@@ -234,11 +234,12 @@ static void PRINT_PKT(u_char *buf, int length)
 /* this disables an interrupt from the interrupt mask register */
 #define SMC_DISABLE_INT(lp, x) do {					\
 	unsigned char mask;						\
-	spin_lock_irq(&lp->lock);					\
+	unsigned long int_flags;					\
+	spin_lock_irqsave(&lp->lock,int_flags);					\
 	mask = SMC_GET_INT_MASK(lp);					\
 	mask &= ~(x);							\
 	SMC_SET_INT_MASK(lp, mask);					\
-	spin_unlock_irq(&lp->lock);					\
+	spin_unlock_irqrestore(&lp->lock, int_flags);			\
 } while (0)
 
 /*
@@ -269,17 +270,18 @@ static void smc_reset(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	unsigned int ctl, cfg;
+	unsigned long int_flags;
 	struct sk_buff *pending_skb;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
 	/* Disable all interrupts, block TX tasklet */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 
 	/* free any pending tx skb */
 	if (pending_skb) {
@@ -397,16 +399,17 @@ static void smc_shutdown(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	struct sk_buff *pending_skb;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
 
 	/* no more interrupts for me */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	if (pending_skb)
 		dev_kfree_skb(pending_skb);
 
@@ -582,9 +585,12 @@ static void smc_hardware_send_pkt(unsigned long data)
 	struct sk_buff *skb;
 	unsigned int packet_no, len;
 	unsigned char *buf;
+	unsigned int flags;
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
+	spin_lock_irqsave(&lp->lock, flags);
+
 	if (!smc_special_trylock(&lp->lock)) {
 		netif_stop_queue(dev);
 		tasklet_schedule(&lp->tx_task);
@@ -650,7 +656,8 @@ static void smc_hardware_send_pkt(unsigned long data)
 
 	SMC_ENABLE_INT(lp, IM_TX_INT | IM_TX_EMPTY_INT);
 
-done:	if (!THROTTLE_TX_PKTS)
+ done:	spin_unlock_irqrestore(&lp->lock, flags);
+	if (!THROTTLE_TX_PKTS)
 		netif_wake_queue(dev);
 
 	dev_kfree_skb(skb);
@@ -1074,10 +1081,11 @@ static void smc_phy_configure(struct work_struct *work)
 	int my_phy_caps; /* My PHY capabilities */
 	int my_ad_caps; /* My Advertised capabilities */
 	int status;
+	unsigned long int_flags;
 
 	DBG(3, "%s:smc_program_phy()\n", dev->name);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 
 	/*
 	 * We should not be called if phy_type is zero.
@@ -1159,7 +1167,7 @@ static void smc_phy_configure(struct work_struct *work)
 
 smc_phy_configure_exit:
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 /*
@@ -1353,6 +1361,7 @@ static void smc_poll_controller(struct net_device *dev)
 {
 	disable_irq(dev->irq);
 	smc_interrupt(dev->irq, dev);
+	mdelay(5);
 	enable_irq(dev->irq);
 }
 #endif
@@ -1363,10 +1372,11 @@ static void smc_timeout(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	int status, mask, eph_st, meminfo, fifo;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	status = SMC_GET_INT(lp);
 	mask = SMC_GET_INT_MASK(lp);
 	fifo = SMC_GET_FIFO(lp);
@@ -1374,7 +1384,7 @@ static void smc_timeout(struct net_device *dev)
 	eph_st = SMC_GET_EPH_STATUS(lp);
 	meminfo = SMC_GET_MIR(lp);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	PRINTK( "%s: TX timeout (INT 0x%02x INTMASK 0x%02x "
 		"MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",
 		dev->name, status, mask, meminfo, fifo, eph_st );
@@ -1407,6 +1417,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 	void __iomem *ioaddr = lp->base;
 	unsigned char multicast_table[8];
 	int update_multicast = 0;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1489,7 +1500,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		update_multicast = 1;
 	}
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 0);
 	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 	if (update_multicast) {
@@ -1497,7 +1508,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		SMC_SET_MCAST(lp, multicast_table);
 	}
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 
@@ -1510,6 +1521,7 @@ static int
 smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1543,9 +1555,9 @@ smc_open(struct net_device *dev)
 	if (lp->phy_type != 0)
 		smc_phy_configure(&lp->phy_configure);
 	else {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		smc_10bt_check_media(dev, 1);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	netif_start_queue(dev);
@@ -1583,14 +1595,15 @@ smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	cmd->maxtxpkt = 1;
 	cmd->maxrxpkt = 1;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_gset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		cmd->supported = SUPPORTED_10baseT_Half |
 				 SUPPORTED_10baseT_Full |
@@ -1617,11 +1630,12 @@ smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_sset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		if (cmd->autoneg != AUTONEG_DISABLE ||
 		    cmd->speed != SPEED_10 ||
@@ -1653,11 +1667,12 @@ static int smc_ethtool_nwayreset(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret = -EINVAL;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_nway_restart(&lp->mii);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	return ret;
-- 
1.6.0.3

