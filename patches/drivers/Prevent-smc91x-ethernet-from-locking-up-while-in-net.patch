From 50ea4b662c2bddd030621d3e34d9fc8be1a4fb02 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Sat, 7 Feb 2009 23:16:44 -0500
Subject: [PATCH 06/11] Prevent smc91x ethernet from locking up while in net_poll mode

Using KGDBoE with the smc91x ethernet device is unusable since it
locks up frequently no longer sending or receiving data. This patch
does several things to prevent this.

Several functions have had their locking updated to match what is
is seen with the smc911x driver and also to fix perceived errors
in the locking. The receive function has been modified to pull
all it can pull from the receive fifo allowing for better data
flow and memory usage. The watchdog timeout has been corrected
to match the comment and what is seen in the smc911x. A mdelay
has been added to the poll routine as it has been found that
without the delay reading the Interrupt Register at a high
frequency causes issues (basically the register reports the
same value even though it should in fact report a receive
interrupt event).

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 drivers/net/smc91x.c |   63 +++++++++++++++++++++++++++++++-------------------
 1 files changed, 39 insertions(+), 24 deletions(-)

diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index 860339d..ca199d7 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -99,7 +99,7 @@ MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
 /*
  * Transmit timeout, default 5 seconds.
  */
-static int watchdog = 1000;
+static int watchdog = 5000;
 module_param(watchdog, int, 0400);
 MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
 
@@ -242,17 +242,18 @@ static void smc_reset(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	unsigned int ctl, cfg;
+	unsigned long int_flags;
 	struct sk_buff *pending_skb;
 
 	DBG(2, "%s: %s\n", dev->name, __func__);
 
 	/* Disable all interrupts, block TX tasklet */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 
 	/* free any pending tx skb */
 	if (pending_skb) {
@@ -370,16 +371,17 @@ static void smc_shutdown(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	struct sk_buff *pending_skb;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", CARDNAME, __func__);
 
 	/* no more interrupts for me */
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	if (pending_skb)
 		dev_kfree_skb(pending_skb);
 
@@ -553,6 +555,8 @@ static void smc_hardware_send_pkt(unsigned long data)
 
 	DBG(3, "%s: %s\n", dev->name, __func__);
 
+	spin_lock_irqsave(&lp->lock, flags);
+
 	if (!smc_special_trylock(&lp->lock, flags)) {
 		netif_stop_queue(dev);
 		tasklet_schedule(&lp->tx_task);
@@ -618,7 +622,8 @@ static void smc_hardware_send_pkt(unsigned long data)
 
 	SMC_ENABLE_INT(lp, IM_TX_INT | IM_TX_EMPTY_INT);
 
-done:	if (!THROTTLE_TX_PKTS)
+ done:	spin_unlock_irqrestore(&lp->lock, flags);
+	if (!THROTTLE_TX_PKTS)
 		netif_wake_queue(dev);
 
 	dev_kfree_skb(skb);
@@ -1043,10 +1048,11 @@ static void smc_phy_configure(struct work_struct *work)
 	int my_phy_caps; /* My PHY capabilities */
 	int my_ad_caps; /* My Advertised capabilities */
 	int status;
+	unsigned long int_flags;
 
 	DBG(3, "%s:smc_program_phy()\n", dev->name);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 
 	/*
 	 * We should not be called if phy_type is zero.
@@ -1128,7 +1134,7 @@ static void smc_phy_configure(struct work_struct *work)
 
 smc_phy_configure_exit:
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 /*
@@ -1322,6 +1328,7 @@ static void smc_poll_controller(struct net_device *dev)
 {
 	disable_irq(dev->irq);
 	smc_interrupt(dev->irq, dev);
+	mdelay(5);
 	enable_irq(dev->irq);
 }
 #endif
@@ -1332,10 +1339,11 @@ static void smc_timeout(struct net_device *dev)
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	int status, mask, eph_st, meminfo, fifo;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __func__);
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	status = SMC_GET_INT(lp);
 	mask = SMC_GET_INT_MASK(lp);
 	fifo = SMC_GET_FIFO(lp);
@@ -1343,7 +1351,7 @@ static void smc_timeout(struct net_device *dev)
 	eph_st = SMC_GET_EPH_STATUS(lp);
 	meminfo = SMC_GET_MIR(lp);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	PRINTK( "%s: TX timeout (INT 0x%02x INTMASK 0x%02x "
 		"MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",
 		dev->name, status, mask, meminfo, fifo, eph_st );
@@ -1376,6 +1384,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 	void __iomem *ioaddr = lp->base;
 	unsigned char multicast_table[8];
 	int update_multicast = 0;
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __func__);
 
@@ -1453,7 +1462,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		update_multicast = 1;
 	}
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	SMC_SELECT_BANK(lp, 0);
 	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 	if (update_multicast) {
@@ -1461,7 +1470,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		SMC_SET_MCAST(lp, multicast_table);
 	}
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 }
 
 
@@ -1474,6 +1483,7 @@ static int
 smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
+	unsigned long int_flags;
 
 	DBG(2, "%s: %s\n", dev->name, __func__);
 
@@ -1509,9 +1519,9 @@ smc_open(struct net_device *dev)
 	if (lp->phy_type != 0)
 		smc_phy_configure(&lp->phy_configure);
 	else {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		smc_10bt_check_media(dev, 1);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	netif_start_queue(dev);
@@ -1549,14 +1559,15 @@ smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	cmd->maxtxpkt = 1;
 	cmd->maxrxpkt = 1;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_gset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		cmd->supported = SUPPORTED_10baseT_Half |
 				 SUPPORTED_10baseT_Full |
@@ -1583,11 +1594,12 @@ smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_ethtool_sset(&lp->mii, cmd);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	} else {
 		if (cmd->autoneg != AUTONEG_DISABLE ||
 		    cmd->speed != SPEED_10 ||
@@ -1619,11 +1631,12 @@ static int smc_ethtool_nwayreset(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret = -EINVAL;
+	unsigned long int_flags;
 
 	if (lp->phy_type != 0) {
-		spin_lock_irq(&lp->lock);
+		spin_lock_irqsave(&lp->lock, int_flags);
 		ret = mii_nway_restart(&lp->mii);
-		spin_unlock_irq(&lp->lock);
+		spin_unlock_irqrestore(&lp->lock, int_flags);
 	}
 
 	return ret;
@@ -1646,8 +1659,9 @@ static int smc_write_eeprom_word(struct net_device *dev, u16 addr, u16 word)
 	u16 ctl;
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
+	unsigned long int_flags;
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	/* load word into GP register */
 	SMC_SELECT_BANK(lp, 1);
 	SMC_SET_GP(lp, word);
@@ -1665,7 +1679,7 @@ static int smc_write_eeprom_word(struct net_device *dev, u16 addr, u16 word)
 	/* clean up */
 	SMC_SET_CTL(lp, ctl);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	return 0;
 }
 
@@ -1674,8 +1688,9 @@ static int smc_read_eeprom_word(struct net_device *dev, u16 addr, u16 *word)
 	u16 ctl;
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
+	unsigned long int_flags;
 
-	spin_lock_irq(&lp->lock);
+	spin_lock_irqsave(&lp->lock, int_flags);
 	/* set the EEPROM address to get the data from */
 	SMC_SELECT_BANK(lp, 2);
 	SMC_SET_PTR(lp, addr | PTR_READ);
@@ -1693,7 +1708,7 @@ static int smc_read_eeprom_word(struct net_device *dev, u16 addr, u16 *word)
 	/* clean up */
 	SMC_SET_CTL(lp, ctl);
 	SMC_SELECT_BANK(lp, 2);
-	spin_unlock_irq(&lp->lock);
+	spin_unlock_irqrestore(&lp->lock, int_flags);
 	return 0;
 }
 
-- 
1.6.5.2

