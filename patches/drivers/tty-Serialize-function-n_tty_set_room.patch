From e3d5e23cc5df04e1b09fefe692854c3122d488e9 Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Wed, 14 Oct 2015 10:38:52 +0800
Subject: [PATCH] tty: Serialize function n_tty_set_room

There is a read buffer in pty device and it has two variables to
check and judge the status of this read buffer. "read_cnt" shows
how many bytes can be read from this read buffer; "receive_room"
shows how many bytes are still free and can be write into the read
buffer. "read_cnt" is 0 means the buffer is empty while the 0
"receve_room" means the buffer is  full. The "receive_room" was
set based on "read_cnt" with function "n_tty_set_room" by both the
"consumer" and "producer" of this read buffer. While the very
function was not serialized that may cause race condition in
preempt kernel. That race condition may cause both the raed_cnt and
receive_room is 0 thus block both consumer and producer for ever.

Without serialization, preemption on this function may
cause the read_cnt and receive_room are both set to
zero. This will block both producer and consumer of the
read_buf. Serialize it with a new created spinlock.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 drivers/tty/n_tty.c  |   11 +++++++----
 drivers/tty/tty_io.c |    1 +
 include/linux/tty.h  |    1 +
 3 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index fa0376b..36cfb06 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -86,16 +86,18 @@ static inline int tty_put_user(struct tty_struct *tty, unsigned char x,
  *
  *	Called by the driver to find out how much data it is
  *	permitted to feed to the line discipline without any being lost
- *	and thus to manage flow control. Not serialized. Answers for the
- *	"instant".
+ *	and thus to manage flow control.
  */
 
 static void n_tty_set_room(struct tty_struct *tty)
 {
-	/* tty->read_cnt is not read locked ? */
-	int	left = N_TTY_BUF_SIZE - tty->read_cnt - 1;
+	unsigned long flags;
+	int	left;
 	int old_left;
 
+	spin_lock_irqsave(&tty->receive_room_lock, flags);
+	left = N_TTY_BUF_SIZE - tty->read_cnt - 1;
+
 	/*
 	 * If we are doing input canonicalization, and there are no
 	 * pending newlines, let characters through without limit, so
@@ -106,6 +108,7 @@ static void n_tty_set_room(struct tty_struct *tty)
 		left = tty->icanon && !tty->canon_data;
 	old_left = tty->receive_room;
 	tty->receive_room = left;
+	spin_unlock_irqrestore(&tty->receive_room_lock, flags);
 
 	/* Did this open up the receive buffer? We may need to flip */
 	if (left && !old_left)
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index d69802d..acf6461 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -3070,6 +3070,7 @@ void initialize_tty_struct(struct tty_struct *tty,
 	mutex_init(&tty->echo_lock);
 	spin_lock_init(&tty->read_lock);
 	spin_lock_init(&tty->ctrl_lock);
+	spin_lock_init(&tty->receive_room_lock);
 	INIT_LIST_HEAD(&tty->tty_files);
 	INIT_WORK(&tty->SAK_work, do_SAK_work);
 
diff --git a/include/linux/tty.h b/include/linux/tty.h
index cf2feee..0f7e16c 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -331,6 +331,7 @@ struct tty_struct {
 	/* If the tty has a pending do_SAK, queue it here - akpm */
 	struct work_struct SAK_work;
 	struct tty_port *port;
+	spinlock_t receive_room_lock;
 };
 
 /* Each of a tty's open files has private_data pointing to tty_file_private */
-- 
1.7.5.4

