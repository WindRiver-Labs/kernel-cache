From fafcf79fddfce0c02b2414da66eb0a02be9274c1 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Fri, 1 Apr 2011 18:03:44 +0800
Subject: [PATCH 01/20] TI 8168EVM: add devices support for 8168EVM

Add devices support for 8168EVM board.

This patch refers to below commits in arago git tree.
git://arago-project.org/git/projects/linux-omap3.git

b8bf45 ti816x: Add platform hookup for EMAC driver.
acbc90 TI816x: Add AHCI platform support
d2fcbc TI816X: Add platform Support for EDMA3 Driver
69be15 TI816X: Audio support
ff2ce5 ti816x: mcspi PIO mode support validated on ti8168 evm
ebe7d3 mcspi platform resource added to devices.c
3257b0 omap: init the gpio pinmux for mmc
1cef51 hsmmc: This patch adds support for HSMMC module to TI816x platform.
b8bf45 ti816x: Add platform hookup for EMAC driver.

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-omap2/devices.c |  552 ++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 550 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 353023d..4955161 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -15,8 +15,10 @@
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/clk.h>
+#include <linux/davinci_emac.h>
 
 #include <mach/hardware.h>
+#include <mach/irqs.h>
 #include <asm/mach-types.h>
 #include <asm/mach/map.h>
 
@@ -24,8 +26,11 @@
 #include <plat/tc.h>
 #include <plat/board.h>
 #include <plat/mux.h>
+#include <plat/ahci_platform.h>
 #include <mach/gpio.h>
+#include <mach/edma.h>
 #include <plat/mmc.h>
+#include <plat/asp.h>
 
 #include "mux.h"
 
@@ -300,6 +305,8 @@ static inline void omap_init_sti(void) {}
 #define OMAP4_MCSPI3_BASE		0x480b8100
 #define OMAP4_MCSPI4_BASE		0x480ba100
 
+#define TI816X_MCSPI1_BASE		0x48030100
+
 static struct omap2_mcspi_platform_config omap2_mcspi1_config = {
 	.num_cs		= 4,
 };
@@ -393,6 +400,18 @@ static struct platform_device omap2_mcspi4 = {
 };
 #endif
 
+#ifdef CONFIG_ARCH_TI816X
+static inline void ti816x_mcspi_fixup(void)
+{
+	omap2_mcspi1_resources[0].start	= TI816X_MCSPI1_BASE;
+	omap2_mcspi1_resources[0].end	= TI816X_MCSPI1_BASE + 0xff;
+}
+#else
+static inline void ti816x_mcspi_fixup(void)
+{
+}
+#endif
+
 #ifdef CONFIG_ARCH_OMAP4
 static inline void omap4_mcspi_fixup(void)
 {
@@ -439,8 +458,13 @@ static void omap_init_mcspi(void)
 	if (cpu_is_omap44xx())
 		omap4_mcspi_fixup();
 
+	if (cpu_is_ti816x())
+		ti816x_mcspi_fixup();
+
 	platform_device_register(&omap2_mcspi1);
+#ifndef CONFIG_ARCH_TI816X
 	platform_device_register(&omap2_mcspi2);
+#endif
 
 	if (cpu_is_omap2430() || cpu_is_omap343x() || cpu_is_omap44xx())
 		omap2_mcspi3_init();
@@ -591,6 +615,17 @@ static inline void omap_hsmmc_reset(void) {}
 static inline void omap2_mmc_mux(struct omap_mmc_platform_data *mmc_controller,
 			int controller_nr)
 {
+#ifdef CONFIG_MACH_TI8168EVM
+	if ((mmc_controller->slots[0].switch_pin > 0) && \
+		(mmc_controller->slots[0].switch_pin < OMAP_MAX_GPIO_LINES))
+		omap_mux_init_gpio(mmc_controller->slots[0].switch_pin,
+					OMAP_PIN_INPUT_PULLUP);
+	if ((mmc_controller->slots[0].gpio_wp > 0) && \
+		(mmc_controller->slots[0].gpio_wp < OMAP_MAX_GPIO_LINES))
+		omap_mux_init_gpio(mmc_controller->slots[0].gpio_wp,
+					OMAP_PIN_INPUT_PULLUP);
+#endif
+
 	if (cpu_is_omap2420() && controller_nr == 0) {
 		omap_cfg_reg(H18_24XX_MMC_CMD);
 		omap_cfg_reg(H15_24XX_MMC_CLKI);
@@ -684,6 +719,18 @@ static inline void omap2_mmc_mux(struct omap_mmc_platform_data *mmc_controller,
 		 * For MMC3 the pins need to be muxed in the board-*.c files
 		 */
 	}
+
+	if (cpu_is_ti816x()) {
+		omap_mux_init_signal("mmc_pow", OMAP_PULL_ENA);
+		omap_mux_init_signal("mmc_clk", OMAP_PIN_OUTPUT);
+		omap_mux_init_signal("mmc_cmd", OMAP_PULL_UP);
+		omap_mux_init_signal("mmc_dat0", OMAP_PULL_UP);
+		omap_mux_init_signal("mmc_dat1_sdirq", OMAP_PULL_UP);
+		omap_mux_init_signal("mmc_dat2_sdrw", OMAP_PULL_UP);
+		omap_mux_init_signal("mmc_dat3", OMAP_PULL_UP);
+		omap_mux_init_signal("mmc_sdcd", OMAP_PULL_ENA);
+		omap_mux_init_signal("mmc_sdwp", OMAP_PULL_ENA);
+	}
 }
 
 void __init omap2_init_mmc(struct omap_mmc_platform_data **mmc_data,
@@ -703,8 +750,13 @@ void __init omap2_init_mmc(struct omap_mmc_platform_data **mmc_data,
 
 		switch (i) {
 		case 0:
-			base = OMAP2_MMC1_BASE;
-			irq = INT_24XX_MMC_IRQ;
+			if (!cpu_is_ti816x()) {
+				base = OMAP2_MMC1_BASE;
+				irq = INT_24XX_MMC_IRQ;
+			} else {
+				base = TI816X_MMC1_BASE;
+				irq = TI816X_IRQ_SD;
+			}
 			break;
 		case 1:
 			base = OMAP2_MMC2_BASE;
@@ -742,6 +794,9 @@ void __init omap2_init_mmc(struct omap_mmc_platform_data **mmc_data,
 			}
 			size = OMAP4_HSMMC_SIZE;
 			name = "mmci-omap-hs";
+		} else if (cpu_is_ti816x()) {
+			size = TI816X_HSMMC_SIZE;
+			name = "mmci-omap-hs";
 		} else {
 			size = OMAP3_HSMMC_SIZE;
 			name = "mmci-omap-hs";
@@ -813,6 +868,499 @@ static void omap_init_vout(void)
 static inline void omap_init_vout(void) {}
 #endif
 
+#define P0PHYCR	0x178  /* SATA PHY0 Control Register offset from AHCI base) */
+#define P1PHYCR	0x1F8  /* SATA PHY0 Control Register offset from AHCI base) */
+#define PHY_ENPLL	1 /* bit0        1 */
+#define PHY_MPY		8 /* bits4:1     4 Clock Sources at 100MHz */
+#define PHY_LB		0 /* bits6:5     2 */
+#define PHY_CLKBYP	0 /* bits8:7     2 */
+#define PHY_RXINVPAIR	0 /* bit9        1 */
+#define PHY_LBK		0 /* bits11:10   2 */
+#define PHY_RXLOS	1 /* bit12	 1 */
+#define PHY_RXCDR	4 /* bits15:13   3 */
+#define PHY_RXEQ	1 /* bits19:16   4 */
+#define PHY_RxENOC	1 /* bit20       1 */
+#define PHY_TXINVPAIR	0 /* bit21	 1 */
+#define PHY_TXCM	0 /* bit22       1 */
+#define PHY_TXSWING	0x7 /* bits26:23   4 */
+#define PHY_TXDE	0x0 /* bits31:27   5 */
+
+u8	ti_num_ahci_inst = 1;
+struct clk *sata_clk;
+
+static int ahci_plat_init(struct device *dev)
+{
+	u32 phy_val = 0;
+	void __iomem *base;
+
+	sata_clk = clk_get(NULL, "sata_ick");
+	if (IS_ERR(sata_clk)) {
+		pr_err("ahci : Failed to get AHCI clock\n");
+		return -1;
+	}
+
+	if (clk_enable(sata_clk)) {
+		pr_err("ahci : Clock Enable Failed\n");
+		return -1;
+	}
+
+	phy_val = PHY_ENPLL << 0 | PHY_MPY << 1 | PHY_LB << 5 |
+			PHY_CLKBYP << 7 | PHY_RXINVPAIR << 9 |
+			PHY_LBK  << 10 | PHY_RXLOS << 12 |
+			PHY_RXCDR << 13 | PHY_RXEQ << 16 |
+			PHY_RxENOC << 20 | PHY_TXINVPAIR << 21 |
+			PHY_TXCM << 22 | PHY_TXSWING  << 23 | PHY_TXDE << 27;
+	base = ioremap(TI816X_SATA_BASE, 0x10ffff);
+	if (!base) {
+		printk(KERN_WARNING
+				"%s: Unable to map SATA, "
+				"cannot turn on PHY.\n",  __func__);
+		return -1;
+	}
+
+	/* Initialize the SATA PHY */
+	writel(phy_val,	base + P0PHYCR);
+
+	/* ti816x platform has 2 SATA PHY's Initialize the second instance */
+	if (cpu_is_ti816x() && (ti_num_ahci_inst > 1))
+		writel(phy_val, base + P1PHYCR);
+
+	iounmap(base);
+
+	return 0;
+}
+
+static void ahci_plat_exit(struct device *dev)
+{
+}
+
+static struct resource ahci_resources[] = {
+	{
+		.start	=	TI816X_SATA_BASE,
+		.end	=	TI816X_SATA_BASE + 0x10fff,
+		.flags	=	IORESOURCE_MEM,
+	},
+	{
+		.start	=	TI816X_IRQ_SATA,
+		.flags	=	IORESOURCE_IRQ,
+	}
+};
+
+struct ahci_platform_data ahci_pdata = {
+	.init =	ahci_plat_init,
+	.exit =	ahci_plat_exit,
+};
+
+static struct platform_device ti_ahci_device = {
+	.name	=	"ahci",
+	.id	=	-1,
+	.dev	=	{
+				.platform_data = &ahci_pdata,
+				.coherent_dma_mask = 0xffffffff,
+			},
+	.num_resources = ARRAY_SIZE(ahci_resources),
+	.resource	= ahci_resources,
+};
+
+int __init ti_ahci_register(u8 num_inst)
+{
+	num_inst = num_inst ? num_inst : 1;
+	ti_num_ahci_inst = num_inst;
+	ahci_pdata.force_port_map = (1 << num_inst) - 1;
+	ahci_pdata.mask_port_map = 0;
+	return platform_device_register(&ti_ahci_device);
+}
+
+#ifdef CONFIG_ARCH_TI816X
+static struct resource ti816x_mcasp_resource[] = {
+	{
+		.name = "mcasp",
+		.start = TI816X_ASP2_BASE,
+		.end = TI816X_ASP2_BASE + (SZ_1K * 12) - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	/* TX event */
+	{
+		.start = TI816X_DMA_MCASP2_AXEVT,
+		.end = TI816X_DMA_MCASP2_AXEVT,
+		.flags = IORESOURCE_DMA,
+	},
+	/* RX event */
+	{
+		.start = TI816X_DMA_MCASP2_AREVT,
+		.end = TI816X_DMA_MCASP2_AREVT,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device ti816x_mcasp_device = {
+	.name = "davinci-mcasp",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(ti816x_mcasp_resource),
+	.resource = ti816x_mcasp_resource,
+};
+
+void __init ti816x_register_mcasp(int id, struct snd_platform_data *pdata)
+{
+	ti816x_mcasp_device.dev.platform_data = pdata;
+	platform_device_register(&ti816x_mcasp_device);
+}
+#endif
+
+#if defined(CONFIG_ARCH_TI816X) && defined(CONFIG_PCI)
+static struct ti816x_pcie_data ti816x_pcie_data = {
+		.msi_irq_base = TI816X_MSI_IRQ_BASE,
+		.msi_irq_num = TI816X_MSI_NR_IRQS,
+};
+
+static struct resource ti816x_pcie_resources[] = {
+	{
+		/* Register space */
+		.name		= "pcie-regs",
+		.start		= TI816X_PCIE_REG_BASE,
+		.end		= TI816X_PCIE_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		/* Non-prefetch memory */
+		.name		= "pcie-nonprefetch",
+		.start		= TI816X_PCIE_MEM_BASE,
+		.end		= TI816X_PCIE_MEM_BASE + SZ_256M - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		/* IO window */
+		.name		= "pcie-io",
+		.start		= TI816X_PCIE_IO_BASE,
+		.end		= TI816X_PCIE_IO_BASE + SZ_2M + SZ_1M - 1,
+		.flags		= IORESOURCE_IO,
+	},
+	{
+		/* Inbound memory window */
+		.name		= "pcie-inbound0",
+		.start		= PHYS_OFFSET,
+		.end		= PHYS_OFFSET + SZ_2G - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		/* Legacy Interrupt */
+		.name		= "legacy_int",
+		.start		= TI816X_IRQ_PCIINT0,
+		.end		= TI816X_IRQ_PCIINT0,
+		.flags		= IORESOURCE_IRQ,
+	},
+#ifdef CONFIG_PCI_MSI
+	{
+		/* MSI Interrupt Line */
+		.name		= "msi_int",
+		.start		= TI816X_IRQ_PCIINT1,
+		.end		= TI816X_IRQ_PCIINT1,
+		.flags		= IORESOURCE_IRQ,
+	},
+#endif
+};
+
+static struct platform_device ti816x_pcie_device = {
+	.name		= "ti816x_pcie",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &ti816x_pcie_data,
+	},
+	.num_resources	= ARRAY_SIZE(ti816x_pcie_resources),
+	.resource	= ti816x_pcie_resources,
+};
+
+void __init ti816x_init_pcie(void)
+{
+	if (cpu_is_ti816x()) {
+		omap_ctrl_writel(TI816X_PCIE_PLLMUX_25X |
+				TI816X_PCIE_DEVTYPE_RC,
+				TI816X_CONTROL_PCIE_CFG);
+		platform_device_register(&ti816x_pcie_device);
+	}
+}
+#else
+void __init ti816x_init_pcie(void) {}
+#endif
+
+#ifdef CONFIG_ARCH_TI816X
+#define TI816X_TPCC_BASE		0x49000000
+#define TI816X_TPTC0_BASE		0x49800000
+#define TI816X_TPTC1_BASE		0x49900000
+#define TI816X_TPTC2_BASE		0x49a00000
+#define TI816X_TPTC3_BASE		0x49b00000
+
+static const s16 ti816x_dma_rsv_chans[][2] = {
+	/* (offset, number) */
+	{ 0,  4},	/* !@@@ TODO replace as appropriate - Sundaram*/
+	/* {24,  4},*/
+	{30,  2},
+	{54,  3},
+	{-1, -1}
+};
+
+static const s16 ti816x_dma_rsv_slots[][2] = {
+	/* (offset, number) */
+	{ 0,  4},	/* !@@@ TODO replace as appropriate - Sundaram*/
+	/* {24,  4}, */
+	{30,  2},
+	{54,  3},
+	{128, 384},
+	{-1, -1}
+};
+
+/* Four Transfer Controllers on TI816X */
+static const s8 ti816x_queue_tc_mapping[][2] = {
+	/* {event queue no, TC no} */
+	{0, 0},
+	{1, 1},
+	{2, 2},
+	{3, 3},
+	{-1, -1}
+};
+
+static const s8 ti816x_queue_priority_mapping[][2] = {
+	/* {event queue no, Priority} */
+	{0, 4},	/* !@@@ TODO replace as appropriate - Sundaram*/
+	{1, 0},
+	{2, 5},
+	{3, 1},
+	{-1, -1}
+};
+
+static struct edma_soc_info ti816x_edma_info[] = {
+	{
+		.n_channel		= 64,
+		.n_region		= 5,	/* 0-2, 4-5 */
+		.n_slot			= 512,
+		.n_tc			= 4,
+		.n_cc			= 1,
+		.rsv_chans		= ti816x_dma_rsv_chans,
+		.rsv_slots		= ti816x_dma_rsv_slots,
+		.queue_tc_mapping	= ti816x_queue_tc_mapping,
+		.queue_priority_mapping	= ti816x_queue_priority_mapping,
+	},
+};
+
+static struct resource ti816x_edma_resources[] = {
+	{
+		.name	= "edma_cc0",
+		.start	= TI816X_TPCC_BASE,
+		.end	= TI816X_TPCC_BASE + SZ_32K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc0",
+		.start	= TI816X_TPTC0_BASE,
+		.end	= TI816X_TPTC0_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc1",
+		.start	= TI816X_TPTC1_BASE,
+		.end	= TI816X_TPTC1_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc2",
+		.start	= TI816X_TPTC2_BASE,
+		.end	= TI816X_TPTC2_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc3",
+		.start	= TI816X_TPTC3_BASE,
+		.end	= TI816X_TPTC3_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma0",
+		.start	= TI816X_IRQ_EDMA_COMP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "edma0_err",
+		.start	= TI816X_IRQ_EDMA_ERR,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ti816x_edma_device = {
+	.name		= "edma",
+	.id		= -1,	/* !@@@ TODO replace as appropriate - Sundaram*/
+	.dev = {
+		.platform_data = ti816x_edma_info,
+	},
+	.num_resources	= ARRAY_SIZE(ti816x_edma_resources),
+	.resource	= ti816x_edma_resources,
+};
+
+int __init ti816x_register_edma(void)
+{
+	struct platform_device *pdev;
+	static struct clk *edma_clk;
+
+	if (cpu_is_ti816x())
+		pdev = &ti816x_edma_device;
+	else {
+		pr_err("%s: platform not supported\n", __func__);
+		return -ENODEV;
+	}
+
+	edma_clk = clk_get(NULL, "tpcc_ick");
+	if (IS_ERR(edma_clk)) {
+		printk(KERN_ERR "EDMA: Failed to get clock\n");
+		return -EBUSY;
+	}
+	clk_enable(edma_clk);
+	edma_clk = clk_get(NULL, "tptc0_ick");
+	if (IS_ERR(edma_clk)) {
+		printk(KERN_ERR "EDMA: Failed to get clock\n");
+		return -EBUSY;
+	}
+	clk_enable(edma_clk);
+	edma_clk = clk_get(NULL, "tptc1_ick");
+	if (IS_ERR(edma_clk)) {
+		printk(KERN_ERR "EDMA: Failed to get clock\n");
+		return -EBUSY;
+	}
+	clk_enable(edma_clk);
+	edma_clk = clk_get(NULL, "tptc2_ick");
+	if (IS_ERR(edma_clk)) {
+		printk(KERN_ERR "EDMA: Failed to get clock\n");
+		return -EBUSY;
+	}
+	clk_enable(edma_clk);
+	edma_clk = clk_get(NULL, "tptc3_ick");
+	if (IS_ERR(edma_clk)) {
+		printk(KERN_ERR "EDMA: Failed to get clock\n");
+		return -EBUSY;
+	}
+	clk_enable(edma_clk);
+
+	return platform_device_register(pdev);
+}
+#endif
+
+#ifdef CONFIG_ARCH_TI816X
+#define TI816X_EMAC1_BASE		(0x4A100000)
+#define TI816X_EMAC_CNTRL_OFFSET	(0x0)
+#define TI816X_EMAC_CNTRL_MOD_OFFSET	(0x900)
+#define TI816X_EMAC_CNTRL_RAM_OFFSET	(0x2000)
+#define TI816X_EMAC_MDIO_BASE		(TI816X_EMAC1_BASE + 0x800)
+#define TI816X_EMAC_MDIO_SIZE		(0xFF)
+#define TI816X_EMAC_CNTRL_RAM_SIZE	(0x2000)
+#define TI816X_EMAC1_HW_RAM_ADDR	(0x4A102000)
+#define TI816X_EMAC1_PHY_MASK		(0x2)
+#define TI816X_EMAC_PHY_ID		0x0282F013
+#define TI816X_EMAC_MDIO_FREQ		(1000000)
+
+static struct emac_platform_data ti816x_emac1_pdata = {
+	.phy_mask	=	TI816X_EMAC1_PHY_MASK,
+	.rmii_en	=	0,
+};
+
+struct emac_mdio_data mdio_data = {
+	.regs		=	TI816X_EMAC_MDIO_BASE,
+	.size		=	TI816X_EMAC_MDIO_SIZE,
+	.max_freq	=	TI816X_EMAC_MDIO_FREQ
+};
+
+static struct resource ti816x_emac1_resources[] = {
+	{
+		.start	=	TI816X_EMAC1_BASE,
+		.end	=	TI816X_EMAC1_BASE + 0x3FFF,
+		.flags	=	IORESOURCE_MEM,
+	},
+	{
+		.start	=	TI816X_IRQ_MACRXTHR0,
+		.end	=	TI816X_IRQ_MACRXTHR0,
+		.flags	=	IORESOURCE_IRQ,
+	},
+	{
+		.start	=	TI816X_IRQ_MACRXINT0,
+		.end	=	TI816X_IRQ_MACRXINT0,
+		.flags	=	IORESOURCE_IRQ,
+	},
+	{
+		.start	=	TI816X_IRQ_MACTXINT0,
+		.end	=	TI816X_IRQ_MACTXINT0,
+		.flags	=	IORESOURCE_IRQ,
+	},
+	{
+		.start	=	TI816X_IRQ_MACMISC0,
+		.end	=	TI816X_IRQ_MACMISC0,
+		.flags	=	IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ti816x_emac1_device = {
+	.name	=	"davinci_emac",
+	.id	=	0,
+	.num_resources	=	ARRAY_SIZE(ti816x_emac1_resources),
+	.resource	=	ti816x_emac1_resources,
+};
+
+void ti816x_emac_mux(void)
+{
+	omap_mux_init_signal("gmii1_rxclk", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd0", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd1", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd2", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd3", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd4", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd5", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd6", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxd7", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxdv", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_gtxclk", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd0", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd1", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd2", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd3", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd4", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd5", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd6", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txd7", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txen", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_txclk", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_col", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_crs", OMAP_MUX_MODE1);
+	omap_mux_init_signal("gmii1_rxer", OMAP_MUX_MODE1);
+}
+
+void ti816x_ethernet_init(void)
+{
+	u32 mac_lo, mac_hi;
+
+	mac_lo = omap_ctrl_readl(TI816X_CONTROL_MAC_ID0_LO);
+	mac_hi = omap_ctrl_readl(TI816X_CONTROL_MAC_ID0_HI);
+	ti816x_emac1_pdata.mac_addr[0] = mac_hi & 0xFF;
+	ti816x_emac1_pdata.mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	ti816x_emac1_pdata.mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	ti816x_emac1_pdata.mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	ti816x_emac1_pdata.mac_addr[4] = mac_lo & 0xFF;
+	ti816x_emac1_pdata.mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	ti816x_emac1_pdata.ctrl_reg_offset = TI816X_EMAC_CNTRL_OFFSET;
+	ti816x_emac1_pdata.ctrl_mod_reg_offset = TI816X_EMAC_CNTRL_MOD_OFFSET;
+	ti816x_emac1_pdata.ctrl_ram_offset = TI816X_EMAC_CNTRL_RAM_OFFSET;
+
+	/* mdio_reg_offset not exist in ti816x, and also platformdata
+	 * doesn't have interrupt_enable/disable memeber */
+	ti816x_emac1_pdata.mdio_data = &mdio_data;
+
+	ti816x_emac1_pdata.ctrl_ram_size = TI816X_EMAC_CNTRL_RAM_SIZE;
+	ti816x_emac1_pdata.version = EMAC_VERSION_2;
+	ti816x_emac1_pdata.hw_ram_addr = TI816X_EMAC1_HW_RAM_ADDR;
+	ti816x_emac1_pdata.interrupt_enable = NULL;
+	ti816x_emac1_pdata.interrupt_disable = NULL;
+	ti816x_emac1_device.dev.platform_data = &ti816x_emac1_pdata;
+	platform_device_register(&ti816x_emac1_device);
+
+	ti816x_emac_mux();
+}
+#endif
 /*-------------------------------------------------------------------------*/
 
 static int __init omap2_init_devices(void)
-- 
1.7.0.2

