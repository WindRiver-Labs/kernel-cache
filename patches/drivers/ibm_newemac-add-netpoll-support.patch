From eb95a0b38766c324afebbf221dd69b74cd718d7e Mon Sep 17 00:00:00 2001
From: Luo Chunbo <chunbo.luo@windriver.com>
Date: Wed, 31 Mar 2010 15:38:04 +0800
Subject: [PATCH] ibm_newemac: add netpoll support

Added netpoll tx and rx function in ibm_newemac for
IBM 440 onchip ethernet driver, because kgdboe requires ethernet
driver to support netpolling.  Original patch is from
http://patchwork.ozlabs.org/linuxppc/patch?filter=archived&id=3648

Signed-off-by: Thomas Tai <Thomas.Tai@windriver.com>
Integrated-by: Tiejun Chen <tiejun.chen@windriver.com>
Integrated-by: Dongdong Deng <dongdong.deng@windriver.com>
Integrated-by: Luo Chunbo <chunbo.luo@windriver.com>
---
 drivers/net/ibm_newemac/core.c |   91 +++++++++++++++++++++++++++++++++++++++-
 drivers/net/ibm_newemac/mal.c  |   18 --------
 drivers/net/ibm_newemac/mal.h  |   14 ++++++
 include/linux/netpoll.h        |    2 +
 4 files changed, 106 insertions(+), 19 deletions(-)

diff --git a/drivers/net/ibm_newemac/core.c b/drivers/net/ibm_newemac/core.c
index fb0ac6d..d1249db 100644
--- a/drivers/net/ibm_newemac/core.c
+++ b/drivers/net/ibm_newemac/core.c
@@ -1357,10 +1357,16 @@ static int emac_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	struct emac_instance *dev = netdev_priv(ndev);
 	unsigned int len = skb->len;
 	int slot;
-
 	u16 ctrl = EMAC_TX_CTRL_GFCS | EMAC_TX_CTRL_GP | MAL_TX_CTRL_READY |
 	    MAL_TX_CTRL_LAST | emac_tx_csum(dev, skb);
 
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	if (unlikely(dev->tx_cnt == NUM_TX_BUFF)) {
+		netif_stop_queue(ndev);
+		return -EBUSY;
+	}
+#endif
+
 	slot = dev->tx_slot++;
 	if (dev->tx_slot == NUM_TX_BUFF) {
 		dev->tx_slot = 0;
@@ -1521,6 +1527,61 @@ static void emac_parse_tx_error(struct emac_instance *dev, u16 ctrl)
 		++st->tx_bd_sqe;
 }
 
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * emac_poll_tx_nobh() is called during netpolling, it is
+ * samiliar to emac_poll_tx except that it does not
+ * lock/unlock bottom half. Otherwise, kernel will panic.
+ *
+ */
+static void emac_poll_tx_nobh(void *param)
+{
+	struct emac_instance *dev = param;
+	u32 bad_mask;
+
+	DBG2(dev, "poll_tx, %d %d" NL, dev->tx_cnt, dev->ack_slot);
+
+	if (emac_has_feature(dev, EMAC_FTR_HAS_TAH))
+		bad_mask = EMAC_IS_BAD_TX_TAH;
+	else
+		bad_mask = EMAC_IS_BAD_TX;
+
+	/*	netif_tx_lock_bh(dev->ndev); */
+	if (dev->tx_cnt) {
+		u16 ctrl;
+		int slot = dev->ack_slot, n = 0;
+again:
+		ctrl = dev->tx_desc[slot].ctrl;
+		if (!(ctrl & MAL_TX_CTRL_READY)) {
+			struct sk_buff *skb = dev->tx_skb[slot];
+			++n;
+
+			if (skb) {
+				dev_kfree_skb(skb);
+				dev->tx_skb[slot] = NULL;
+			}
+			slot = (slot + 1) % NUM_TX_BUFF;
+
+			if (unlikely(ctrl & bad_mask))
+				emac_parse_tx_error(dev, ctrl);
+
+			if (--dev->tx_cnt)
+				goto again;
+		}
+		if (n) {
+			dev->ack_slot = slot;
+			if (netif_queue_stopped(dev->ndev) &&
+			    dev->tx_cnt < EMAC_TX_WAKEUP_THRESH)
+				netif_wake_queue(dev->ndev);
+
+			DBG2(dev, "tx %d pkts" NL, n);
+		}
+	}
+	/* netif_tx_unlock_bh(dev->ndev); */
+}
+#endif
+
+
 static void emac_poll_tx(void *param)
 {
 	struct emac_instance *dev = param;
@@ -2691,6 +2752,28 @@ static int __devinit emac_init_config(struct emac_instance *dev)
 	return 0;
 }
 
+#ifdef CONFIG_NET_POLL_CONTROLLER
+void poll_ctrl(struct net_device *dev)
+{
+	int budget = 16;
+
+	struct emac_instance *emac_dev = netdev_priv(dev);
+	struct mal_instance *mal = dev_get_drvdata(&emac_dev->mal_dev->dev);
+
+	/* disable  MAL interrupts */
+	mal_disable_eob_irq(mal);
+	napi_disable(&mal->napi);
+
+	emac_poll_rx(netdev_priv(dev), budget);
+	emac_poll_tx_nobh(netdev_priv(dev));
+
+	napi_enable(&mal->napi);
+	/* Enable mal interrupts */
+	mal_enable_eob_irq(mal);
+
+}
+#endif
+
 static const struct net_device_ops emac_netdev_ops = {
 	.ndo_open		= emac_open,
 	.ndo_stop		= emac_close,
@@ -2702,6 +2785,9 @@ static const struct net_device_ops emac_netdev_ops = {
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_start_xmit		= emac_start_xmit,
 	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= poll_ctrl,
+#endif
 };
 
 static const struct net_device_ops emac_gige_netdev_ops = {
@@ -2715,6 +2801,9 @@ static const struct net_device_ops emac_gige_netdev_ops = {
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_start_xmit		= emac_start_xmit_sg,
 	.ndo_change_mtu		= emac_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= poll_ctrl,
+#endif
 };
 
 static int __devinit emac_probe(struct of_device *ofdev,
diff --git a/drivers/net/ibm_newemac/mal.c b/drivers/net/ibm_newemac/mal.c
index 2a2fc17..3c78e03 100644
--- a/drivers/net/ibm_newemac/mal.c
+++ b/drivers/net/ibm_newemac/mal.c
@@ -199,24 +199,6 @@ void mal_poll_del(struct mal_instance *mal, struct mal_commac *commac)
 	spin_unlock_irqrestore(&mal->lock, flags);
 }
 
-/* synchronized by mal_poll() */
-static inline void mal_enable_eob_irq(struct mal_instance *mal)
-{
-	MAL_DBG2(mal, "enable_irq" NL);
-
-	// XXX might want to cache MAL_CFG as the DCR read can be slooooow
-	set_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) | MAL_CFG_EOPIE);
-}
-
-/* synchronized by NAPI state */
-static inline void mal_disable_eob_irq(struct mal_instance *mal)
-{
-	// XXX might want to cache MAL_CFG as the DCR read can be slooooow
-	set_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) & ~MAL_CFG_EOPIE);
-
-	MAL_DBG2(mal, "disable_irq" NL);
-}
-
 static irqreturn_t mal_serr(int irq, void *dev_instance)
 {
 	struct mal_instance *mal = dev_instance;
diff --git a/drivers/net/ibm_newemac/mal.h b/drivers/net/ibm_newemac/mal.h
index 9ededfb..3510ece 100644
--- a/drivers/net/ibm_newemac/mal.h
+++ b/drivers/net/ibm_newemac/mal.h
@@ -261,6 +261,20 @@ static inline int mal_has_feature(struct mal_instance *dev,
 		(MAL_FTRS_POSSIBLE & dev->features & feature);
 }
 
+/* synchronized by mal_poll() */
+static inline void mal_enable_eob_irq(struct mal_instance *mal)
+{
+	/* XXX might want to cache MAL_CFG as the DCR read can be slooooow */
+	set_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) | MAL_CFG_EOPIE);
+}
+
+/* synchronized by NAPI state */
+static inline void mal_disable_eob_irq(struct mal_instance *mal)
+{
+	/* XXX might want to cache MAL_CFG as the DCR read can be slooooow */
+	set_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) & ~MAL_CFG_EOPIE);
+}
+
 /* Register MAL devices */
 int mal_init(void);
 void mal_exit(void);
diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index fcbb0d2..808728d 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -77,7 +77,9 @@ static inline int netpoll_rx_on(struct sk_buff *skb)
 
 static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
+#ifndef CONFIG_IBM_NEW_EMAC
 	if (!list_empty(&skb->dev->napi_list))
+#endif
 		return netpoll_rx(skb);
 	return 0;
 }
-- 
1.6.5.2

