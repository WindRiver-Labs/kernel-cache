From e0b36bbbaa050ad91e46e63c2553366e7d687d26 Mon Sep 17 00:00:00 2001
From: huanhuan Wang <huanhuan.Wang@windriver.com>
Date: Thu, 27 Feb 2014 10:30:14 +0800
Subject: [PATCH] gianfar: fix a memory leak in gianfar.c

A memory leak is introduced by commit
"gianfar: add support for wake-on-packet".

If FSL_GIANFAR_DEV_HAS_ARP_PACKET is enabled,
a block of memory will be allocated for the interface
when it's opened as below:
  gfar_enet_open
    |
     --startup_gfar
      |
       --gfar_alloc_skb_resources
but the block of memory allocated is not released when the
interface is closed, see following:
  stop_gfar
    |
     --free_skb_resources

Execute the below commands hundreds of times on a board
with gianfar NIC will causes "SIOCSIFFLAGS: Cannot
allocate memory" warning.
  ifconfig eth0 up
  sleep 1
  ifconfig eth0 down

Besides, this patch also fix two other issues:
1. double "free_skb_resources" if "gfar_init_bds" fails in
"gfar_alloc_skb_resources"
2. unnecessary call of "dma_free_coherent" when
"dma_alloc_coherent" fails in "gfar_alloc_skb_resources"

Signed-off-by: huanhuan Wang <huanhuan.Wang@windriver.com>
---
 drivers/net/gianfar.c |   27 +++++++++++++++------------
 1 files changed, 15 insertions(+), 12 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index a7aa083..10a28bd 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -263,7 +263,7 @@ static int gfar_init_bds(struct net_device *ndev)
 				if (!skb) {
 					pr_err("%s: Can't allocate RX buffers\n",
 							ndev->name);
-					goto err_rxalloc_fail;
+					return -ENOMEM;
 				}
 				rx_queue->rx_skbuff[j] = skb;
 
@@ -276,10 +276,6 @@ static int gfar_init_bds(struct net_device *ndev)
 	}
 
 	return 0;
-
-err_rxalloc_fail:
-	free_skb_resources(priv);
-	return -ENOMEM;
 }
 
 unsigned long alloc_bds(struct gfar_private *priv, dma_addr_t *addr)
@@ -418,7 +414,7 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 				printk(KERN_ERR
 					"%s:Could not allocate wakeup buffer!\n", ndev->name);
 			err = -ENOMEM;
-			goto wk_buf_fail;
+			goto cleanup;
 		}
 
 		priv->wk_buf_vaddr = (unsigned long) vaddr;
@@ -446,11 +442,6 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	}
 	return 0;
 
-wk_buf_fail:
-	dma_free_coherent(&priv->ofdev->dev,
-			priv->wk_buffer_size * rx_queue->rx_ring_size \
-			+ RXBUF_ALIGNMENT, (void *)priv->wk_buf_vaddr,
-			priv->wk_buf_paddr);
 cleanup:
 	free_skb_resources(priv);
 	return -ENOMEM;
@@ -1812,7 +1803,10 @@ static int gfar_restore(struct device *dev)
 	if (!netif_running(ndev))
 		return 0;
 
-	gfar_init_bds(ndev);
+	if (gfar_init_bds(ndev)) {
+		free_skb_resources(priv);
+		return -ENOMEM;
+	}
 	init_registers(ndev);
 	gfar_set_mac_address(ndev);
 	gfar_init_mac(ndev);
@@ -2205,6 +2199,15 @@ void free_bds(struct gfar_private *priv)
 			priv->tx_queue[0]->tx_bd_base,
 			priv->tx_queue[0]->tx_bd_dma_base);
 #endif
+	if (priv->wk_buf_vaddr != 0) {
+		dma_free_coherent(&priv->ofdev->dev,
+			priv->wk_buffer_size *
+			priv->rx_queue[priv->num_rx_queues - 1]->rx_ring_size
+			+ RXBUF_ALIGNMENT,
+			(void*)(priv->wk_buf_vaddr),
+			priv->wk_buf_paddr);
+		priv->wk_buf_vaddr = 0;
+	}
 }
 
 void stop_gfar(struct net_device *dev)
-- 
1.7.0

