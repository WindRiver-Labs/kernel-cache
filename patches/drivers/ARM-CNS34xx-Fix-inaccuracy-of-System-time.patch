From 4de4098eea40e15ae0bcd121eff78dc5171534e7 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Tue, 13 Sep 2011 17:56:12 +0800
Subject: [PATCH 4/4] ARM:CNS34xx:Fix inaccuracy of System time

The system time of CNS34xx board has been found lost 17 seconds every
30 minutes. The issue is caused by improper algorithm for timer's
frequency involved by timer initial routine.

On CNS34xx board, Linux use external timer1 to update system time.
Timer1 is driven by pclk, which is a clock with working frequency as
much as 1/8 of cpu frequency. The overflow value of Timer1 should be
(pclk frequency / HZ).

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm/mach-cns3xxx/core.c |   12 ++++++++----
 1 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 9ca4d58..2a8265a 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -101,12 +101,13 @@ static void cns3xxx_timer_set_mode(enum clock_event_mode mode,
 				   struct clock_event_device *clk)
 {
 	unsigned long ctrl = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
-	int pclk = cns3xxx_cpu_clock() / 8;
+	int pclk = cns3xxx_cpu_clock() * 1000 * 1000 / 8;
 	int reload;
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		reload = pclk * 20 / (3 * HZ) * 0x25000;
+		reload = pclk / HZ;
+		writel(reload, cns3xxx_tmr1 + TIMER1_COUNTER_OFFSET);
 		writel(reload, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
 		ctrl |= (1 << 0) | (1 << 2) | (1 << 9);
 		break;
@@ -189,6 +190,7 @@ static void __init __cns3xxx_timer_init(unsigned int timer_irq)
 {
 	u32 val;
 	u32 irq_mask;
+	int pclk = cns3xxx_cpu_clock() * 1000 * 1000 / 8;
 
 	/*
 	 * Initialise to a known state (all timers off)
@@ -199,9 +201,11 @@ static void __init __cns3xxx_timer_init(unsigned int timer_irq)
 	/* stop free running timer3 */
 	writel(0, cns3xxx_tmr1 + TIMER_FREERUN_CONTROL_OFFSET);
 
+	val = pclk / HZ;
+
 	/* timer1 */
-	writel(0x5C800, cns3xxx_tmr1 + TIMER1_COUNTER_OFFSET);
-	writel(0x5C800, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
+	writel(val, cns3xxx_tmr1 + TIMER1_COUNTER_OFFSET);
+	writel(val, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
 
 	writel(0, cns3xxx_tmr1 + TIMER1_MATCH_V1_OFFSET);
 	writel(0, cns3xxx_tmr1 + TIMER1_MATCH_V2_OFFSET);
-- 
1.7.0.4

