From 15e6e97e52eb23f6d30899f86b66fc52b483e018 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Wed, 3 Aug 2011 10:29:01 +0800
Subject: [PATCH 33/47] SD/MMC: add VFS(ext2/ext4) performance optimization support

Improve ext2/ext4 performance. Distinguish the usage of write operation.
used_for_format in struct inode will be indicated whether data is used
to format device. If both data is not used to format disk and backing
device is pointed to a real block device, it means write-back mechanism
write redundant data, and these write operations will take bad effect to
I/O performance. So, page cache write operation (do_writepages) will skip
these operations.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-SD-MMC-add-VFS-ext2-ext4-performance-op.patch and
0046-SD-MMC-fix-the-race-condition-flaw-when-format-SSD-d.patch.

Signed-off-by: Qiang Liu <b32616@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 fs/Kconfig          |    9 +++++++++
 include/linux/fs.h  |    3 +++
 mm/filemap.c        |    6 +++++-
 mm/page-writeback.c |   12 ++++++++++++
 4 files changed, 29 insertions(+), 1 deletions(-)

diff --git a/fs/Kconfig b/fs/Kconfig
index 5f85b59..99a3202 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -55,6 +55,15 @@ config FILE_LOCKING
           for filesystems like NFS and for the flock() system
           call. Disabling this option saves about 11k.
 
+config OPTIMIZE_SD_PERFORMANCE
+	bool "Improve SD/MMC storage performance"
+	depends on EXT2_FS || EXT4_FS
+	default n
+	help
+	  This option allows you to improve I/O storage performance, optimized
+	  writeback via avoiding to write the metadata of device node, required
+	  filesystems like ext2 and ext4 call. Other filesystems are not validated.
+
 source "fs/notify/Kconfig"
 
 source "fs/quota/Kconfig"
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8aa6bd9..d468eda 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -790,6 +790,9 @@ struct inode {
 	struct posix_acl	*i_default_acl;
 #endif
 	void			*i_private; /* fs or device private pointer */
+#ifdef CONFIG_OPTIMIZE_SD_PERFORMANCE
+	unsigned int            used_for_format;/* usage of the inode */
+#endif
 };
 
 /*
diff --git a/mm/filemap.c b/mm/filemap.c
index 32b36ca..95f0c6d 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2348,7 +2348,11 @@ ssize_t __generic_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	err = generic_segment_checks(iov, &nr_segs, &ocount, VERIFY_READ);
 	if (err)
 		return err;
-
+#ifdef CONFIG_OPTIMIZE_SD_PERFORMANCE
+	/* tag normal write and format device */
+	if (imajor(inode))
+		inode->used_for_format = 1;
+#endif
 	count = ocount;
 	pos = *ppos;
 
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 0b19943..91f9c88 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -1013,12 +1013,24 @@ int do_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
 	int ret;
 
+#ifdef CONFIG_OPTIMIZE_SD_PERFORMANCE
+	/* no need to write device if the operation is not used to format device */
+	if (imajor(mapping->host) &&
+			(wbc->sync_mode == WB_SYNC_NONE) &&
+			!mapping->host->used_for_format)
+		return 0;
+#endif
 	if (wbc->nr_to_write <= 0)
 		return 0;
 	if (mapping->a_ops->writepages)
 		ret = mapping->a_ops->writepages(mapping, wbc);
 	else
 		ret = generic_writepages(mapping, wbc);
+#ifdef CONFIG_OPTIMIZE_SD_PERFORMANCE
+	/* recover initial state of this inode */
+	if (mapping->host->used_for_format && (wbc->sync_mode == WB_SYNC_ALL))
+		mapping->host->used_for_format = 0;
+#endif
 	return ret;
 }
 
-- 
1.7.0.4

