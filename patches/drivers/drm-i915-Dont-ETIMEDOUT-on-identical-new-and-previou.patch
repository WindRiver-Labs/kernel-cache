From 188384941c332966b979ea7d112d70c0c97ef38a Mon Sep 17 00:00:00 2001
From: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date: Thu, 23 Jul 2015 16:35:50 -0700
Subject: [PATCH 019/435] drm/i915: Dont -ETIMEDOUT on identical new and
 previous (count, crc).

commit 'aabc95dcf200908993573b2019ff5210121bcba9' upstream

By Vesa DP 1.2 spec TEST_CRC_COUNT is a "4 bit wrap counter which
increments each time the TEST_CRC_x_x are updated."

However if we are trying to verify the screen hasn't changed we get
same (count, crc) pair twice. Without this patch we would return
-ETIMEOUT in this case.

So, if in 6 vblanks the pair (count, crc) hasn't changed we
return it anyway instead of returning error and let test case decide
if it was right or not.

Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Reviewed-by: Rafael Antognolli <rafael.antognolli@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Hu <yadi.hu@windriver.com>
---
 drivers/gpu/drm/i915/intel_dp.c |   21 +++++++++++++++------
 1 files changed, 15 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 79ecbfa..d940093 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -4077,6 +4077,7 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 	u8 buf;
 	int count, ret;
 	int attempts = 6;
+	bool old_equal_new;
 
 	ret = intel_dp_sink_crc_start(intel_dp);
 	if (ret)
@@ -4091,6 +4092,7 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 			goto stop;
 		}
 		count = buf & DP_TEST_COUNT_MASK;
+
 		/*
 		 * Count might be reset during the loop. In this case
 		 * last known count needs to be reset as well.
@@ -4102,17 +4104,24 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 			ret = -EIO;
 			goto stop;
 		}
-	} while (--attempts && (count == 0 || (count == intel_dp->sink_crc.last_count &&
-					       !memcmp(intel_dp->sink_crc.last_crc, crc,
-						       6 * sizeof(u8)))));
+
+		old_equal_new = (count == intel_dp->sink_crc.last_count &&
+				 !memcmp(intel_dp->sink_crc.last_crc, crc,
+					 6 * sizeof(u8)));
+
+	} while (--attempts && (count == 0 || old_equal_new));
 
 	intel_dp->sink_crc.last_count = buf & DP_TEST_COUNT_MASK;
 	memcpy(intel_dp->sink_crc.last_crc, crc, 6 * sizeof(u8));
 
 	if (attempts == 0) {
-		DRM_DEBUG_KMS("Panel is unable to calculate CRC after 6 vblanks\n");
-		ret = -ETIMEDOUT;
-		goto stop;
+		if (old_equal_new) {
+			DRM_DEBUG_KMS("Unreliable Sink CRC counter: Current returned CRC is identical to the previous one\n");
+		} else {
+			DRM_ERROR("Panel is unable to calculate any CRC after 6 vblanks\n");
+			ret = -ETIMEDOUT;
+			goto stop;
+		}
 	}
 
 stop:
-- 
1.7.5.4

