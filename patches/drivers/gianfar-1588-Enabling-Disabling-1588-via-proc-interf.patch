From f821434b6194863fc85042359a29d6269f884ce9 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:23:11 +0800
Subject: [PATCH 29/47] gianfar/1588: Enabling/Disabling 1588 via proc interface

Enable/Disable 1588 via /proc/ptp_1588.
To Enable 1588
        - echo 1 > /proc/ptp_1588
To Disable 1588
        - echo 0 > /proc/ptp_1588
This functionality is provided to disable 1588 during performance analysis,
for which earlier we have to remove the ptp_timer node from dts.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
0022-gianfar-1588-Enabling-Disabling-1588-via-proc-interf.patch.

Signed-off-by: Bhaskar Upadhaya <Bhaskar.Upadhaya@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c      |    2 +
 drivers/net/gianfar.h      |   15 ++++++
 drivers/net/gianfar_1588.c |  107 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 124 insertions(+), 0 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 4534144..0d14306 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -4375,11 +4375,13 @@ static struct of_platform_driver gfar_driver = {
 
 static int __init gfar_init(void)
 {
+	gfar_1588_proc_init(gfar_match, sizeof(gfar_match));
 	return of_register_platform_driver(&gfar_driver);
 }
 
 static void __exit gfar_exit(void)
 {
+	gfar_1588_proc_exit();
 	of_unregister_platform_driver(&gfar_driver);
 }
 
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index d59eb52..225bba0 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -608,6 +608,9 @@ extern const char gfar_driver_version[];
 #define TMR_CTRL_FIPER_START	0x10000000
 #define PPS_1588	1
 #define ONE_GIGA	1000000000
+#define GFAR_1588_PROCFS_MAX_SIZE         12
+#define GFAR_1588_PROCFS_NAME           "ptp_1588"
+
 /*Alarm to traigger at 15sec boundary */
 #define TMR_ALARM1_L	0xD964B800
 #define TMR_ALARM1_H	0x00000045
@@ -1313,6 +1316,16 @@ struct gfar_ptp_attr_t {
 	u32 max_adj;
 };
 
+struct gfar_1588_data_t {
+	char name[GFAR_1588_PROCFS_MAX_SIZE + 1];
+	char value[GFAR_1588_PROCFS_MAX_SIZE + 1];
+};
+
+struct gfar_node_info_t {
+	struct of_device_id *gfar_node_match;
+	int match_cnt;
+};
+
 extern unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 extern unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
 
@@ -1378,6 +1391,8 @@ extern void gfar_configure_rx_coalescing(struct gfar_private *priv,
 					long unsigned int rx_mask);
 void gfar_init_sysfs(struct net_device *dev);
 
+extern void gfar_1588_proc_init(struct of_device_id *dev_id, int cnt);
+extern void gfar_1588_proc_exit(void);
 extern const struct ethtool_ops gfar_ethtool_ops;
 
 #endif /* __GIANFAR_H */
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index d2e6f8e..a9c15d1 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -19,6 +19,7 @@
 #include <linux/vmalloc.h>
 #include <linux/of.h>
 #include "gianfar.h"
+#include <linux/of_platform.h>
 
 #if defined(CONFIG_1588_MUX_eTSEC1) || defined(CONFIG_1588_MUX_eTSEC2)
 #define MPC85XX_PMUXCR_OFFS 0x60
@@ -46,6 +47,10 @@ static DECLARE_WAIT_QUEUE_HEAD(ptp_rx_ts_wait);
 
 static u32 freq_compensation;
 
+static struct proc_dir_entry *gfar_1588_proc_file;
+static struct gfar_node_info_t gfar_node;
+static struct gfar_1588_data_t gfar_1588_data;
+
 /*64 bites add and return the result*/
 static u64 add64_oper(u64 addend, u64 augend)
 {
@@ -699,3 +704,105 @@ int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr)
 					100) / ptp_attr->nominal_freq;
 	return 0;
 }
+
+static int gfar_1588_proc_read(char *buffer,
+		char **buffer_location,
+		off_t offset, int buffer_length, int *eof, void *data)
+{
+	int len;
+	struct gfar_1588_data_t *gfar_1588_info = \
+				(struct gfar_1588_data_t *)data;
+
+	len = sprintf(buffer, "%s = '%s'\n",
+			gfar_1588_info->name, gfar_1588_info->value);
+	return len;
+}
+
+static int gfar_1588_proc_write(struct file *file, const char *buffer,
+			unsigned long count, void *data)
+{
+	int i, cnt;
+	struct gfar_private *priv;
+	struct device_node *np = NULL;
+	struct of_device *ofdev;
+	struct gfar_1588_data_t *gfar_1588_info = \
+				(struct gfar_1588_data_t *)data;
+
+	if (count > GFAR_1588_PROCFS_MAX_SIZE)
+		count = GFAR_1588_PROCFS_MAX_SIZE;
+
+	if (copy_from_user(gfar_1588_info->value, buffer, count))
+		return -EFAULT;
+	gfar_1588_info->value[count - 1] = '\0';
+	printk(KERN_DEBUG "\r\n  buffer (%s) \r\n", gfar_1588_info->value);
+	cnt = gfar_node.match_cnt / sizeof(struct of_device_id);
+
+	/*
+	 * Here we are getting the valid index ie "i" for which we have
+	 * valid compatible string in the dts file.
+	 */
+	for (i = 0; i < (cnt - 1); i++) {
+		printk(KERN_DEBUG "\r\n gfar-node is (%s)\r\n", \
+				gfar_node.gfar_node_match[i].compatible);
+		if (!of_find_compatible_node(NULL, NULL, \
+				gfar_node.gfar_node_match[i].compatible))
+			continue;
+		else
+			break;
+	}
+
+	/*
+	 * After getting the valid index "i" from above for loop
+	 * we are Enabling/Disabling the 1588 functionality on the
+	 * eTSEC controllers.
+	 */
+	while (1) {
+		np = of_find_compatible_node(np, NULL, \
+				gfar_node.gfar_node_match[i].compatible);
+		if (np == NULL) {
+			printk(KERN_DEBUG "\r\nUnale to find gfar-node\n");
+			break;
+		} else {
+			ofdev = of_find_device_by_node(np);
+			priv = dev_get_drvdata(&ofdev->dev);
+			if (!strcmp(gfar_1588_info->value, "0")) {
+				printk(KERN_DEBUG "\r\n PTPD OFF \r\n");
+				priv->ptimer_present = 0;
+			} else if (!strcmp(gfar_1588_info->value, "1")) {
+				printk(KERN_DEBUG "\r\n PTPD ON \r\n");
+				priv->ptimer_present = 1;
+			}
+		}
+	}
+	return count;
+}
+
+void gfar_1588_proc_init(struct of_device_id *dev_id, int cnt)
+{
+	gfar_1588_proc_file = create_proc_entry(GFAR_1588_PROCFS_NAME,\
+							 0644, NULL);
+
+	if (gfar_1588_proc_file == NULL) {
+		remove_proc_entry(GFAR_1588_PROCFS_NAME, NULL);
+		printk(KERN_ALERT "Error: Could not initialize /proc/%s\n",
+			GFAR_1588_PROCFS_NAME);
+		return;
+	}
+	strcpy(gfar_1588_data.name, GFAR_1588_PROCFS_NAME);
+	strcpy(gfar_1588_data.value, "1");
+	gfar_1588_proc_file->read_proc  = gfar_1588_proc_read;
+	gfar_1588_proc_file->write_proc = gfar_1588_proc_write;
+	gfar_1588_proc_file->mode	= S_IFREG | S_IRUGO;
+	gfar_1588_proc_file->uid	= 0;
+	gfar_1588_proc_file->gid	= 0;
+	gfar_1588_proc_file->data	= &gfar_1588_data;
+	gfar_node.gfar_node_match = dev_id;
+	gfar_node.match_cnt = cnt;
+	printk(KERN_INFO "/proc/%s created \r\n", GFAR_1588_PROCFS_NAME);
+}
+
+void gfar_1588_proc_exit()
+{
+	remove_proc_entry(GFAR_1588_PROCFS_NAME, NULL);
+	printk(KERN_INFO "/proc/%s removed \r\n", GFAR_1588_PROCFS_NAME);
+}
-- 
1.7.0.2

