From bc95646c9cb9d9705a49462a7e60aee23c07d1af Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Tue, 26 Jul 2011 16:07:49 +0800
Subject: [PATCH 26/27] ARM:CNS34xx:Fix memory corruption caused by improper operation of DMA

During shutdown netif operation, there is alignment exception
introduced by CNS34xx NIC driver:

Alignment trap: not handling instruction e1931f9f at [<c03f5198>]

Unhandled fault: alignment exception (0x011) at 0x00090881

Internal error: : 11 [#1] PREEMPT

last sysfs file:

Modules linked in:

CPU: 0    Not tainted  (2.6.34.8-WR4.1.0.0_standard #1)

PC is at dst_release+0x10/0x3c

LR is at skb_release_head_state+0x18/0xc8

pc : [<c03f519c>]    lr : [<c03e3a58>]    psr: 20000013

sp : cff31e08  ip : d0000000  fp : cff31ea8

r10: cfe3b20c  r9 : 00000000  r8 : cfe18880

r7 : cff5a000  r6 : cff5a180  r5 : 00000030  r4 : cff26300

r3 : 00090881  r2 : 00000002  r1 : cff61e40  r0 : 00090801

Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user

Control: 00c5787d  Table: 0ffb8008  DAC: 00000015

Process ifconfig (pid: 118, stack limit = 0xcff30268)

Stack: (0xcff31e08 to 0xcff32000)

1e00:                   cff26300 c03e5e64 cff26300 c03e5574 00000180 c035178c

1e20: cfe18880 cfe50000 00000000 00000001 cfe3b200 c03517bc cfe502e0 c03519a0

1e40: c03517e4 cfe50000 c04b1128 00001003 00000001 c03f01bc c03f0150 cfe50000

1e60: 00001042 c03ec72c 00000000 cfe50000 00001003 cfe50000 00000000 c03f0028

1e80: 00000000 cfefa440 cfe50000 c043bec4 bedb4c28 00000000 30687465 00000000

1ea0: 00000000 00000000 00001042 00000000 00000000 00000000 00001042 00000000

1ec0: 00000000 00000000 00000000 00008914 bedb4c28 c06a9660 00008914 00000003

1ee0: cff30000 00000000 00000000 c03dcd80 cfdfeb00 c03dcb88 bedb4c28 00008914

1f00: 00000003 c00ea8b0 0000c000 bedb4c28 cfdfeb00 cf86e028 00000000 c00eaf68

1f20: cf86e000 00000000 cff31f40 c03de774 00000000 00000000 00000000 c056cf34

1f40: cfc3d880 cf872600 00000000 c00dad14 00000003 00000000 00000000 00000000

1f60: c002cfe8 cfdfeb00 bedb4c28 00008914 00000000 00000003 cff30000 00000000

1f80: 00000000 c00eb08c 00000003 00000000 0005c82a 00000001 00057944 00000036

1fa0: c002cfe8 c002ce40 0005c82a 00000001 00000003 00008914 bedb4c28 0005c82a

1fc0: 0005c82a 00000001 00057944 00000036 00000000 00000000 bedb4f14 00000000

1fe0: 00000003 bedb4c18 0000e554 441965ec 60000010 00000003 00000000 00000000

[<c03f519c>] (dst_release+0x10/0x3c) from [<c03e3a58>] (skb_release_head_state+0x18/0xc8)

[<c03e3a58>] (skb_release_head_state+0x18/0xc8) from [<c03e5e64>] (skb_release_all+0xc/0x18)

[<c03e5e64>] (skb_release_all+0xc/0x18) from [<c03e5574>] (__kfree_skb+0xc/0xac)

[<c03e5574>] (__kfree_skb+0xc/0xac) from [<c035178c>] (free_rx_skb+0x68/0x8c)

[<c035178c>] (free_rx_skb+0x68/0x8c) from [<c03517bc>] (cns3xxx_free_all_rx_resources+0xc/0x34)

[<c03517bc>] (cns3xxx_free_all_rx_resources+0xc/0x34) from [<c03519a0>] (cns3xxx_close+0x1bc/0x258)

[<c03519a0>] (cns3xxx_close+0x1bc/0x258) from [<c03f01bc>] (__dev_close+0x6c/0x8c)

[<c03f01bc>] (__dev_close+0x6c/0x8c) from [<c03ec72c>] (__dev_change_flags+0x8c/0x118)

[<c03ec72c>] (__dev_change_flags+0x8c/0x118) from [<c03f0028>] (dev_change_flags+0x10/0x44)

[<c03f0028>] (dev_change_flags+0x10/0x44) from [<c043bec4>] (devinet_ioctl+0x2e4/0x650)

[<c043bec4>] (devinet_ioctl+0x2e4/0x650) from [<c03dcd80>] (sock_ioctl+0x1f8/0x24c)

[<c03dcd80>] (sock_ioctl+0x1f8/0x24c) from [<c00ea8b0>] (vfs_ioctl+0x2c/0xac)

[<c00ea8b0>] (vfs_ioctl+0x2c/0xac) from [<c00eaf68>] (do_vfs_ioctl+0x548/0x5a0)

[<c00eaf68>] (do_vfs_ioctl+0x548/0x5a0) from [<c00eb08c>] (sys_ioctl+0xcc/0xf0)

[<c00eb08c>] (sys_ioctl+0xcc/0xf0) from [<c002ce40>] (ret_fast_syscall+0x0/0x30)

Code: e3500000 012fff1e e2803080 e1931f9f (e2411001)

---[ end trace bf334d2253420020 ]---

Segmentation fault

The fault is caused by improper DMA operation during shutdown routine,
The shutdown operation needs stop DMA first, then release buffers(
including DMA descriptors and packet buffers).
While the enable_dma(0,0) function could not stop DMA. After buffers
released, the DMA transaction in progress will lead memory corruption.

To stop DMA, it needs to set CLR_FS_DMA (bit 31) in DMA_RING_CTRL
register.

clear_fs_dma_state() function is used to stop DMA before releasing NIC
buffer, inspired by same handling in netif open routine.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/cns3xxx/cns3xxx_main.c   |    1 +
 drivers/net/cns3xxx/cns3xxx_symbol.h |    2 ++
 drivers/net/cns3xxx/cns3xxx_tool.h   |    4 ++++
 3 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/net/cns3xxx/cns3xxx_main.c b/drivers/net/cns3xxx/cns3xxx_main.c
index 892149c..409f748 100644
--- a/drivers/net/cns3xxx/cns3xxx_main.c
+++ b/drivers/net/cns3xxx/cns3xxx_main.c
@@ -443,6 +443,7 @@ static int cns3xxx_free_rx_tx_res(struct CNS3XXXPrivate *priv)
 
 	--rc_setup_rx_tx;
 	if (rc_setup_rx_tx == 0) {
+		clear_fs_dma_state(1);
 		printk(KERN_INFO "free tx/rx resource\n");
 		enable_port(3, 0); /* disable cpu port */
 
diff --git a/drivers/net/cns3xxx/cns3xxx_symbol.h b/drivers/net/cns3xxx/cns3xxx_symbol.h
index 8766db4..04bc989 100644
--- a/drivers/net/cns3xxx/cns3xxx_symbol.h
+++ b/drivers/net/cns3xxx/cns3xxx_symbol.h
@@ -135,6 +135,8 @@
 
 #define SLK_SKEW_CTRL_REG SWITCH_REG_VALUE(0xf0)
 
+#define DMA_RING_CTRL_CLR_FS_DMA (31)
+
 #define DMA_RING_CTRL_REG SWITCH_REG_VALUE(0x100)
 
 #define DMA_AUTO_POLL_CFG_REG SWITCH_REG_VALUE(0x104)
diff --git a/drivers/net/cns3xxx/cns3xxx_tool.h b/drivers/net/cns3xxx/cns3xxx_tool.h
index 5fa131a..4ccd688 100644
--- a/drivers/net/cns3xxx/cns3xxx_tool.h
+++ b/drivers/net/cns3xxx/cns3xxx_tool.h
@@ -519,6 +519,10 @@ static inline int enable_tx_dma(u8 which, u8 enable)
  */
 static inline void clear_fs_dma_state(u8 clear)
 {
+	if (clear == 0)
+		DMA_RING_CTRL_REG &= ~(1 << DMA_RING_CTRL_CLR_FS_DMA);
+	else
+		DMA_RING_CTRL_REG |= (1 << DMA_RING_CTRL_CLR_FS_DMA);
 }
 
 /* enable: 1 -> IVL
-- 
1.7.0.4

