From f50e2c9406ccef84eae80e453e159c232981b847 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Fri, 24 Jun 2011 16:59:17 +0800
Subject: [PATCH 07/20] TI816x hsmmc: add hsmmc support

Add hsmmc support for 816x.

This patch refers to below commits in arago git tree.
git://arago-project.org/git/projects/linux-omap3.git

e52aae omap: hsmmc: fix the hsmmc driver for am3517
6036cf TI816x: Adding MMC platform data
03feb1 TI816X: Adding version information to the platform data
bd8a68 ti816x: HSMMC: Minor changes after rebasing to kernel v2.6.3
5a7b78 WP + DISPING patches
b80ac4 ti816x : omap_hsmmc : Correct card insert and write protect detect logic
e4532e TI816X: Adding support for MMC/SD card insertion interrupt
1cef51 hsmmc: This patch adds support for HSMMC module to TI816x platform.
5ed9ee TI816X: Moving the DMA lines population to platform
d9c895 TI816X : Addressing review comments on platform data

[With modifications to compatible with wrlinux kernel]
Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-omap2/hsmmc.c           |   23 ++++++-
 arch/arm/plat-omap/devices.c          |   17 +++++
 arch/arm/plat-omap/include/plat/mmc.h |   12 +++
 drivers/mmc/host/Kconfig              |    2 +-
 drivers/mmc/host/omap_hsmmc.c         |  126 +++++++++++++++++++++++++++++----
 5 files changed, 165 insertions(+), 15 deletions(-)

diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index 9ad2295..4553827 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -139,7 +139,17 @@ static void hsmmc23_before_set_reg(struct device *dev, int slot,
 	}
 }
 
+static int nop_mmc_set_power(struct device *dev, int slot,
+			     int power_on, int vdd)
+{
+		return 0;
+}
+
+#ifndef CONFIG_ARCH_TI816X
 static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC] __initdata;
+#else
+static struct omap_mmc_platform_data *hsmmc_data[TI816X_NR_MMC] __initdata;
+#endif
 
 void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 {
@@ -175,6 +185,9 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 			goto done;
 		}
 
+		if (cpu_is_ti816x())
+			mmc->version = MMC_CTRL_VERSION_2;
+
 		if (c->name)
 			strncpy(hc->name, c->name, HSMMC_NAME_LEN);
 		else
@@ -216,6 +229,9 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 		 */
 		mmc->slots[0].ocr_mask = c->ocr_mask;
 
+		if (cpu_is_ti816x())
+			mmc->slots[0].set_power = nop_mmc_set_power;
+
 		switch (c->mmc) {
 		case 1:
 			/* on-chip level shifting via PBIAS0/PBIAS1 */
@@ -235,9 +251,11 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 				c->wires = 4;
 			/* FALLTHROUGH */
 		case 3:
+#ifndef CONFIG_ARCH_TI816X
 			/* off-chip level shifting, or none */
 			mmc->slots[0].before_set_reg = hsmmc23_before_set_reg;
 			mmc->slots[0].after_set_reg = NULL;
+#endif
 			break;
 		default:
 			pr_err("MMC%d configuration not supported!\n", c->mmc);
@@ -247,7 +265,10 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 		hsmmc_data[c->mmc - 1] = mmc;
 	}
 
-	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+	if (!cpu_is_ti816x())
+		omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+	else
+		omap2_init_mmc(hsmmc_data, TI816X_NR_MMC);
 
 	/* pass the device nodes back to board setup code */
 	for (c = controllers; c->mmc; c++) {
diff --git a/arch/arm/plat-omap/devices.c b/arch/arm/plat-omap/devices.c
index 95677d1..e481707 100644
--- a/arch/arm/plat-omap/devices.c
+++ b/arch/arm/plat-omap/devices.c
@@ -232,7 +232,13 @@ static inline void omap_init_mcpdm(void) {}
 #if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
 	defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
 
+#ifndef CONFIG_ARCH_TI816X
 #define OMAP_MMC_NR_RES		2
+#else
+#define OMAP_MMC_NR_RES		4
+#define TI816X_DMA_MMC1_RX      25
+#define TI816X_DMA_MMC1_TX      24
+#endif
 
 /*
  * Register MMC devices. Called from mach-omap1 and mach-omap2 device init.
@@ -256,6 +262,17 @@ int __init omap_mmc_add(const char *name, int id, unsigned long base,
 	res[1].start = res[1].end = irq;
 	res[1].flags = IORESOURCE_IRQ;
 
+#ifdef CONFIG_ARCH_TI816X
+	if (id == 0) {
+		res[2].start = TI816X_DMA_MMC1_RX;
+		res[2].end = TI816X_DMA_MMC1_RX;
+		res[2].flags = IORESOURCE_DMA;
+		res[3].start = TI816X_DMA_MMC1_TX;
+		res[3].end = TI816X_DMA_MMC1_TX;
+		res[3].flags = IORESOURCE_DMA;
+	}
+#endif
+
 	ret = platform_device_add_resources(pdev, res, ARRAY_SIZE(res));
 	if (ret == 0)
 		ret = platform_device_add_data(pdev, data, sizeof(*data));
diff --git a/arch/arm/plat-omap/include/plat/mmc.h b/arch/arm/plat-omap/include/plat/mmc.h
index a1bac07..6c8b4d3 100644
--- a/arch/arm/plat-omap/include/plat/mmc.h
+++ b/arch/arm/plat-omap/include/plat/mmc.h
@@ -41,8 +41,18 @@
 #define HSMMC2			(1 << 1)
 #define HSMMC1			(1 << 0)
 
+#define TI816X_NR_MMC           1
+#define TI816X_HSMMC_SIZE       0x10000
+#define TI816X_MMC1_BASE        0x48060100 /* TI816X MMC/SD config base */
+#define TI816X_MMC1_HL_BASE     0x48060000 /* TI816X HL configuration*/
+
 #define OMAP_MMC_MAX_SLOTS	2
 
+enum {
+	MMC_CTRL_VERSION_1 = 0, /* OMAP class devicess */
+	MMC_CTRL_VERSION_2      /* TI816X class devicess */
+};
+
 struct omap_mmc_platform_data {
 	/* back-link to device */
 	struct device *dev;
@@ -137,6 +147,8 @@ struct omap_mmc_platform_data {
 		unsigned int ban_openended:1;
 
 	} slots[OMAP_MMC_MAX_SLOTS];
+
+	u8 version;
 };
 
 /* called from board-specific card detection service routine */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 2e13b94..4fa1f9a 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -159,7 +159,7 @@ config MMC_OMAP
 
 config MMC_OMAP_HS
 	tristate "TI OMAP High Speed Multimedia Card Interface support"
-	depends on ARCH_OMAP2430 || ARCH_OMAP3 || ARCH_OMAP4
+	depends on ARCH_OMAP2430 || ARCH_OMAP3 || ARCH_OMAP4 || ARCH_TI816X
 	help
 	  This selects the TI OMAP High Speed Multimedia card Interface.
 	  If you have an OMAP2430 or OMAP3 board or OMAP4 board with a
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index e9caf69..0f9512f 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -56,6 +56,7 @@
 #define OMAP_HSMMC_IE		0x0134
 #define OMAP_HSMMC_ISE		0x0138
 #define OMAP_HSMMC_CAPA		0x0140
+#define OMAP_HSMMC_PSTATE       0x0124
 
 #define VS18			(1 << 26)
 #define VS30			(1 << 25)
@@ -75,7 +76,11 @@
 #define CLKD_SHIFT		6
 #define DTO_MASK		0x000F0000
 #define DTO_SHIFT		16
+#ifdef CONFIG_ARCH_TI816X
 #define INT_EN_MASK		0x307F0033
+#else
+#define INT_EN_MASK		0x307F00f3
+#endif
 #define BWR_ENABLE		(1 << 4)
 #define BRR_ENABLE		(1 << 5)
 #define INIT_STREAM		(1 << 1)
@@ -102,6 +107,13 @@
 #define SRD			(1 << 26)
 #define SOFTRESET		(1 << 1)
 #define RESETDONE		(1 << 0)
+#define CINS			(1 << 6)
+#define PSTATE_CINS_MASK	BIT(16)
+#define PSTATE_CINS_SHIFT	16
+#define PSTATE_WP_MASK		BIT(19)
+#define PSTATE_WP_SHIFT		19
+#define IE_CINS			0x00000040
+#define IE_CINS_SHIFT		6
 
 /*
  * FIXME: Most likely all the data using these _DEVID defines should come
@@ -187,28 +199,64 @@ struct omap_hsmmc_host {
 	struct	omap_mmc_platform_data	*pdata;
 };
 
+static irqreturn_t omap_hsmmc_cd_handler(int irq, void *dev_id);
+
 static int omap_hsmmc_card_detect(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	struct omap_hsmmc_host *host =
+			platform_get_drvdata(to_platform_device(dev));
+
+	if (mmc->version != MMC_CTRL_VERSION_2)
+		/* NOTE: assumes card detect signal is active-low */
+		return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+	else {
+		u32 pstate = 0;
+		u32 enabled = 0;
 
-	/* NOTE: assumes card detect signal is active-low */
-	return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+		enabled = host->mmc->enabled;
+		if (!enabled)
+			mmc_host_enable(host->mmc);
+
+		pstate = OMAP_HSMMC_READ(host->base, PSTATE);
+
+		if (!enabled)
+			mmc_host_disable(host->mmc);
+		printk(KERN_INFO "PSTATE %x\n", pstate);
+		pstate = pstate & PSTATE_CINS_MASK;
+		pstate = pstate >> PSTATE_CINS_SHIFT;
+		return pstate;
+	}
 }
 
 static int omap_hsmmc_get_wp(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	struct omap_hsmmc_host *host =
+			platform_get_drvdata(to_platform_device(dev));
 
-	/* NOTE: assumes write protect signal is active-high */
-	return gpio_get_value_cansleep(mmc->slots[0].gpio_wp);
+	if (mmc->version != MMC_CTRL_VERSION_2)
+		/* NOTE: assumes write protect signal is active-high */
+		return gpio_get_value_cansleep(mmc->slots[0].gpio_wp);
+	else {
+		u32 pstate = 0;
+		pstate = OMAP_HSMMC_READ(host->base, PSTATE);
+		pstate &= PSTATE_WP_MASK;
+		return !(pstate >> PSTATE_WP_SHIFT);
+	}
 }
 
 static int omap_hsmmc_get_cover_state(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	struct omap_hsmmc_host *host =
+			platform_get_drvdata(to_platform_device(dev));
 
-	/* NOTE: assumes card detect signal is active-low */
-	return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+	if (mmc->version != MMC_CTRL_VERSION_2)
+		/* NOTE: assumes card detect signal is active-low */
+		return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+	else
+		return OMAP_HSMMC_READ(host->base, PSTATE) >> PSTATE_CINS_SHIFT;
 }
 
 #ifdef CONFIG_PM
@@ -216,16 +264,28 @@ static int omap_hsmmc_get_cover_state(struct device *dev, int slot)
 static int omap_hsmmc_suspend_cdirq(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	struct omap_hsmmc_host *host =
+			platform_get_drvdata(to_platform_device(dev));
 
-	disable_irq(mmc->slots[0].card_detect_irq);
+	if (mmc->version != MMC_CTRL_VERSION_2)
+		disable_irq(mmc->slots[0].card_detect_irq);
+	else
+		OMAP_HSMMC_WRITE(host->base, IE,
+			OMAP_HSMMC_READ(host->base, IE) & ~IE_CINS);
 	return 0;
 }
 
 static int omap_hsmmc_resume_cdirq(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	struct omap_hsmmc_host *host =
+			platform_get_drvdata(to_platform_device(dev));
 
-	enable_irq(mmc->slots[0].card_detect_irq);
+	if (mmc->version != MMC_CTRL_VERSION_2)
+		enable_irq(mmc->slots[0].card_detect_irq);
+	else
+		OMAP_HSMMC_WRITE(host->base, IE,
+			OMAP_HSMMC_READ(host->base, IE) | IE_CINS);
 	return 0;
 }
 
@@ -494,6 +554,14 @@ static int omap_hsmmc_gpio_init(struct omap_mmc_platform_data *pdata)
 	} else
 		pdata->slots[0].gpio_wp = -EINVAL;
 
+	if (pdata->version == MMC_CTRL_VERSION_2) {
+		pdata->suspend = omap_hsmmc_suspend_cdirq;
+		pdata->resume = omap_hsmmc_resume_cdirq;
+		pdata->slots[0].get_cover_state = omap_hsmmc_get_cover_state;
+		pdata->slots[0].get_ro = omap_hsmmc_get_wp;
+		pdata->slots[0].card_detect = omap_hsmmc_card_detect;
+	}
+
 	return 0;
 
 err_free_wp:
@@ -1040,6 +1108,13 @@ static irqreturn_t omap_hsmmc_irq(int irq, void *dev_id)
 		}
 	}
 
+	/* Schedule card detect here ONLY if irq for CD isn't registerted*/
+	if ((host->pdata->version == MMC_CTRL_VERSION_2) &&
+					((status & CINS) || (status & 0x80))) {
+		printk(KERN_INFO "Received CINS Interrupt\n\n");
+		omap_hsmmc_cd_handler(irq, dev_id);
+	}
+
 	OMAP_HSMMC_WRITE(host->base, STAT, status);
 	/* Flush posted write */
 	OMAP_HSMMC_READ(host->base, STAT);
@@ -1216,23 +1291,28 @@ static void omap_hsmmc_config_dma_params(struct omap_hsmmc_host *host,
 				       struct scatterlist *sgl)
 {
 	int blksz, nblk, dma_ch;
+	int bindex = 0, cindex = 0;
 
 	dma_ch = host->dma_ch;
+	blksz = host->data->blksz;
+	nblk = sg_dma_len(sgl) / blksz;
+	if (cpu_is_ti816x()) {
+		bindex = 4;
+		cindex = blksz;
+	}
+
 	if (data->flags & MMC_DATA_WRITE) {
 		omap_set_dma_dest_params(dma_ch, 0, OMAP_DMA_AMODE_CONSTANT,
 			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
 		omap_set_dma_src_params(dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-			sg_dma_address(sgl), 0, 0);
+			sg_dma_address(sgl), bindex, cindex);
 	} else {
 		omap_set_dma_src_params(dma_ch, 0, OMAP_DMA_AMODE_CONSTANT,
 			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
 		omap_set_dma_dest_params(dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-			sg_dma_address(sgl), 0, 0);
+			sg_dma_address(sgl), bindex, cindex);
 	}
 
-	blksz = host->data->blksz;
-	nblk = sg_dma_len(sgl) / blksz;
-
 	omap_set_dma_transfer_params(dma_ch, OMAP_DMA_DATA_TYPE_S32,
 			blksz / 4, nblk, OMAP_DMA_SYNC_FRAME,
 			omap_hsmmc_get_dma_sync_dev(host, data),
@@ -1491,7 +1571,11 @@ static void omap_hsmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	/* FIXME: set registers based only on changes to ios */
 
+#ifndef CONFIG_ARCH_TI816X
 	con = OMAP_HSMMC_READ(host->base, CON);
+#else
+	con = OMAP_HSMMC_READ(host->base, CON) | (3 << 9) | (3 << 8);
+#endif
 	switch (mmc->ios.bus_width) {
 	case MMC_BUS_WIDTH_8:
 		OMAP_HSMMC_WRITE(host->base, CON, con | DW8);
@@ -2077,6 +2161,10 @@ static int __init omap_hsmmc_probe(struct platform_device *pdev)
 	 * as we want. */
 	mmc->max_phys_segs = 1024;
 	mmc->max_hw_segs = 1024;
+	if (cpu_is_ti816x()) {
+		mmc->max_phys_segs = 1;
+		mmc->max_hw_segs = 1;
+	}
 
 	mmc->max_blk_size = 512;       /* Block Length at max can be 1024 */
 	mmc->max_blk_count = 0xFFFF;    /* No. of Blocks is 16 bits */
@@ -2123,6 +2211,18 @@ static int __init omap_hsmmc_probe(struct platform_device *pdev)
 		goto err_irq;
 	}
 
+#ifdef CONFIG_ARCH_TI816X
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!res)
+		goto err_irq;
+	host->dma_line_rx = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+	if (!res)
+		goto err1;
+	host->dma_line_tx = res->start;
+#endif
+
 	/* Request IRQ for MMC operations */
 	ret = request_irq(host->irq, omap_hsmmc_irq, IRQF_DISABLED,
 			mmc_hostname(mmc), host);
-- 
1.7.0.2

