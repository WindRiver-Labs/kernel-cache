From dae169cf4eeb992c0b6c54a1b59f912f5c71b5ae Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 9 Aug 2011 19:22:50 +0800
Subject: [PATCH 08/47] gianfar: Separate out the rx and tx coalescing functions

o. Divide the gfar_configure_coalescing function into two functions
   gfar_configure_rx_coalescing and gfar_configure_tx_coalescing
   so that rx and tx coalescing can be programmed separately.

o. Add tcp segment offload support flag operation function.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-gianfar-Seperate-out-the-rx-and-tx-coal.patch.

Signed-off-by: Sandeep Gopalpet <sandeep.kumar@freescale.com>
Signed-off-by: Jiajun Wu <b06378@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c         |   36 ++++++++++++++++++++++++++----------
 drivers/net/gianfar.h         |    6 ++++--
 drivers/net/gianfar_ethtool.c |    4 +++-
 3 files changed, 33 insertions(+), 13 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 4aa32be..a48848f 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -454,7 +454,8 @@ static void gfar_init_mac(struct net_device *ndev)
 	gfar_init_tx_rx_base(priv);
 
 	/* Configure the coalescing support */
-	gfar_configure_coalescing(priv, 0xFF, 0xFF);
+	gfar_configure_tx_coalescing(priv, 0xFF);
+	gfar_configure_rx_coalescing(priv, 0xFF);
 
 	if (priv->rx_filer_enable) {
 		rctrl |= RCTRL_FILREN;
@@ -2310,8 +2311,8 @@ void gfar_tx_start(struct net_device *dev)
 }
 #endif
 
-void gfar_configure_coalescing(struct gfar_private *priv,
-	unsigned long tx_mask, unsigned long rx_mask)
+void gfar_configure_tx_coalescing(struct gfar_private *priv,
+				long unsigned int tx_mask)
 {
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	u32 __iomem *baddr;
@@ -2324,10 +2325,6 @@ void gfar_configure_coalescing(struct gfar_private *priv,
 	if(likely(priv->tx_queue[0]->txcoalescing))
 		gfar_write(&regs->txic, priv->tx_queue[0]->txic);
 
-	gfar_write(&regs->rxic, 0);
-	if(unlikely(priv->rx_queue[0]->rxcoalescing))
-		gfar_write(&regs->rxic, priv->rx_queue[0]->rxic);
-
 	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->txic0;
 		for_each_set_bit(i, &tx_mask, priv->num_tx_queues) {
@@ -2337,6 +2334,24 @@ void gfar_configure_coalescing(struct gfar_private *priv,
 			}
 		}
 
+	}
+}
+
+void gfar_configure_rx_coalescing(struct gfar_private *priv,
+				long unsigned int rx_mask)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 *baddr;
+	int i = 0;
+
+	/* Backward compatible case ---- even if we enable
+	 * multiple queues, there's only single reg to program
+	 */
+	gfar_write(&regs->rxic, 0);
+	if (unlikely(priv->rx_queue[0]->rxcoalescing))
+		gfar_write(&regs->rxic, priv->rx_queue[0]->rxic);
+
+	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->rxic0;
 		for_each_set_bit(i, &rx_mask, priv->num_rx_queues) {
 			if (likely(priv->rx_queue[i]->rxcoalescing)) {
@@ -2436,7 +2451,8 @@ int startup_gfar(struct net_device *ndev)
 
 	phy_start(priv->phydev);
 
-	gfar_configure_coalescing(priv, 0xFF, 0xFF);
+	gfar_configure_tx_coalescing(priv, 0xFF);
+	gfar_configure_rx_coalescing(priv, 0xFF);
 
 	return 0;
 
@@ -3543,8 +3559,8 @@ static int gfar_poll(struct napi_struct *napi, int budget)
 
 		/* If we are coalescing interrupts, update the timer */
 		/* Otherwise, clear it */
-		gfar_configure_coalescing(priv,
-				gfargrp->rx_bit_map, gfargrp->tx_bit_map);
+		gfar_configure_rx_coalescing(priv, gfargrp->rx_bit_map);
+		gfar_configure_tx_coalescing(priv, gfargrp->tx_bit_map);
 	}
 
 	return rx_cleaned;
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index 09ce69e..e2d7176 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -1353,8 +1353,10 @@ extern void gfar_ptp_store_rxstamp(struct net_device *dev, struct sk_buff *skb);
 extern int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd);
 extern void gfar_phy_test(struct mii_bus *bus, struct phy_device *phydev,
 		int enable, u32 regnum, u32 read);
-extern void gfar_configure_coalescing(struct gfar_private *priv,
-		unsigned long tx_mask, unsigned long rx_mask);
+extern void gfar_configure_tx_coalescing(struct gfar_private *priv,
+					long unsigned int tx_mask);
+extern void gfar_configure_rx_coalescing(struct gfar_private *priv,
+					long unsigned int rx_mask);
 void gfar_init_sysfs(struct net_device *dev);
 
 extern const struct ethtool_ops gfar_ethtool_ops;
diff --git a/drivers/net/gianfar_ethtool.c b/drivers/net/gianfar_ethtool.c
index 54f8d13..e50b304 100644
--- a/drivers/net/gianfar_ethtool.c
+++ b/drivers/net/gianfar_ethtool.c
@@ -421,7 +421,8 @@ static int gfar_scoalesce(struct net_device *dev, struct ethtool_coalesce *cvals
 			gfar_usecs2ticks(priv, cvals->tx_coalesce_usecs));
 	}
 
-	gfar_configure_coalescing(priv, 0xFF, 0xFF);
+	gfar_configure_tx_coalescing(priv, 0xFF);
+	gfar_configure_rx_coalescing(priv, 0xFF);
 
 	return 0;
 }
@@ -913,6 +914,7 @@ const struct ethtool_ops gfar_ethtool_ops = {
 	.set_sg = ethtool_op_set_sg,
 	.get_msglevel = gfar_get_msglevel,
 	.set_msglevel = gfar_set_msglevel,
+	.set_tso = ethtool_op_set_tso,
 #ifdef CONFIG_PM
 	.get_wol = gfar_get_wol,
 	.set_wol = gfar_set_wol,
-- 
1.7.0.2

