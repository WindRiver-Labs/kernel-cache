From 090e7c3e26d21c4ecc3fbdfde86f918bfcb98859 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 28 Jun 2011 15:13:16 +0800
Subject: [PATCH 06/47] Talitos extensible driver for 3.1 on 8569

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-Talitos-extensible-driver-for-3.1-on-8.patch.

Signed-off-by: Steve Cornelius <steve.cornelius@freescale.com>
Signed-off-by: Jiang Yutang <b14898@freescale.com>
Signed-off-by: Jin Qing <b24347@freescale.com>

[Xufeng Zhang:
1. Add linux/crypto.h header to t23xsec2core.c so as to fix compile error.
2. Replace init_MUTEX_LOCKED API by sema_init because WRL preempt_rt kernel
no longer supports this API.
]

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/crypto/Kconfig                      |   25 +
 drivers/crypto/Makefile                     |    4 +
 drivers/crypto/t23x/common/t23.h            | 1165 ++++++++
 drivers/crypto/t23x/common/xwcRMinterface.h |  306 ++
 drivers/crypto/t23x/t23xrm/Makefile         |   16 +
 drivers/crypto/t23x/t23xrm/t23xrmBase.c     |  191 ++
 drivers/crypto/t23x/t23xrm/t23xrmID.c       |  635 ++++
 drivers/crypto/t23x/t23xrm/t23xrmIFreg.c    |  117 +
 drivers/crypto/t23x/t23xrm/t23xrmISR.c      |  211 ++
 drivers/crypto/t23x/t23xrm/t23xrmInternal.h |  267 ++
 drivers/crypto/t23x/t23xrm/t23xrmMemUtil.c  |  421 +++
 drivers/crypto/t23x/t23xrm/t23xrmModule.c   |  244 ++
 drivers/crypto/t23x/t23xrm/t23xrmRequest.c  |  367 +++
 drivers/crypto/t23x/t23xrm/t23xrmResponse.c |  348 +++
 drivers/crypto/t23x/t23xsec2/Makefile       |   10 +
 drivers/crypto/t23x/t23xsec2/Sec2.h         | 1934 +++++++++++++
 drivers/crypto/t23x/t23xsec2/Sec2local.h    |  113 +
 drivers/crypto/t23x/t23xsec2/sec2_sctrMap.c |  613 ++++
 drivers/crypto/t23x/t23xsec2/t23xsec2core.c |  695 +++++
 drivers/crypto/t23x/t23xsec2/t23xsec2mod.c  |  127 +
 drivers/crypto/t23x/t23xsec2/t2dpd.c        | 4184 +++++++++++++++++++++++++++
 drivers/crypto/t23x/t23xtest/Makefile       |    8 +
 drivers/crypto/t23x/t23xtest/multidesc.c    |  297 ++
 drivers/crypto/t23x/t23xtest/rmtest.c       |  252 ++
 drivers/crypto/t23x/t23xtest/rmtest.h       |   87 +
 drivers/crypto/t23x/t23xtest/rmtest_mod.c   |   70 +
 drivers/crypto/t23x/t23xtest/singledesc.c   |  262 ++
 27 files changed, 12969 insertions(+), 0 deletions(-)
 create mode 100644 drivers/crypto/t23x/common/t23.h
 create mode 100644 drivers/crypto/t23x/common/xwcRMinterface.h
 create mode 100644 drivers/crypto/t23x/t23xrm/Makefile
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmBase.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmID.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmIFreg.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmISR.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmInternal.h
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmMemUtil.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmModule.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmRequest.c
 create mode 100644 drivers/crypto/t23x/t23xrm/t23xrmResponse.c
 create mode 100644 drivers/crypto/t23x/t23xsec2/Makefile
 create mode 100644 drivers/crypto/t23x/t23xsec2/Sec2.h
 create mode 100644 drivers/crypto/t23x/t23xsec2/Sec2local.h
 create mode 100644 drivers/crypto/t23x/t23xsec2/sec2_sctrMap.c
 create mode 100644 drivers/crypto/t23x/t23xsec2/t23xsec2core.c
 create mode 100644 drivers/crypto/t23x/t23xsec2/t23xsec2mod.c
 create mode 100644 drivers/crypto/t23x/t23xsec2/t2dpd.c
 create mode 100644 drivers/crypto/t23x/t23xtest/Makefile
 create mode 100644 drivers/crypto/t23x/t23xtest/multidesc.c
 create mode 100644 drivers/crypto/t23x/t23xtest/rmtest.c
 create mode 100644 drivers/crypto/t23x/t23xtest/rmtest.h
 create mode 100644 drivers/crypto/t23x/t23xtest/rmtest_mod.c
 create mode 100644 drivers/crypto/t23x/t23xtest/singledesc.c

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index b08403d..62330df 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -222,4 +222,29 @@ config CRYPTO_DEV_PPC4XX
 	help
 	  This option allows you to have support for AMCC crypto acceleration.
 
+config CRYPTO_DEV_EXTENS_T23X
+	tristate "Extensible Driver (t23x) for Talitos 2.x/3.x (EXPERIMENTAL)"
+	depends on PPC_83xx || PPC_85xx || PPC_86xx
+	default m
+	help
+	  Extensible Crypto Driver for PowerQUICC devices containing the
+	  SEC 2.x/3.x accelerator core.
+
+	  Builds the Resource Manager component (t23xrm), which manages
+	  the hardware and enables sharing between APIs
+
+config CRYPTO_DEV_EXTENS_T23X_RMTEST
+	tristate "t23x Resource Manager testing module (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_EXTENS_T23X
+	help
+	  Test module (t23xtest) to verify installation of t23x Resource
+	  Manager and accelerator hardware under it's control
+
+config CRYPTO_DEV_EXTENS_T23X_SEC2
+	tristate "t23x SEC2 Legacy Device Interface (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_EXTENS_T23X
+	help
+	  SEC2 Legacy Driver Interface (t23xsec2) component intended to
+	  allow migration of applications dependent on the legacy driver
+
 endif # CRYPTO_HW
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 6ffcb3f..3ca47f4 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -6,3 +6,7 @@ obj-$(CONFIG_CRYPTO_DEV_MV_CESA) += mv_cesa.o
 obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_PPC4XX) += amcc/
+
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X) += t23x/t23xrm/
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X_RMTEST) += t23x/t23xtest/
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X_SEC2) += t23x/t23xsec2/
diff --git a/drivers/crypto/t23x/common/t23.h b/drivers/crypto/t23x/common/t23.h
new file mode 100644
index 0000000..b5c0f2f
--- /dev/null
+++ b/drivers/crypto/t23x/common/t23.h
@@ -0,0 +1,1165 @@
+
+/*
+ * t23.h
+ *
+ * Basic hardware definitions that apply to both the
+ * Talitos (SEC) 2.x and 3.x family of embeddable cryptographic
+ * acceleration cores native to PowerQUICC processors
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - add SNOW-3G CHA support
+ */
+
+
+#ifndef T23_H
+#define T23_H
+
+
+/** @file
+ * Basic hardware definitions for the Talitos (SEC) 2.x and 3.x
+ * family of embeddable cryptographic acceleration cores.
+ */
+
+
+#include <linux/types.h>
+
+
+
+#ifdef _cplusplus
+extern "C" {
+#endif
+
+
+
+/*
+ * Basic header construction definitions
+ */
+
+#define EU_SEL_MASK           (0x00000f00)
+#define EU_MODE_MASK          (0x000000ff)
+#define EU_SEL_SHIFT          (8)
+
+/*
+ * Header bits for EU selection:  0 -  3 (primary)
+ *                               12 - 15 (secondary)
+ */
+#define EU_NONE               (0x00 << EU_SEL_SHIFT) /**< No EU selected          */
+#define EU_ARC4               (0x01 << EU_SEL_SHIFT) /**< RC-4                    */
+#define EU_DES                (0x02 << EU_SEL_SHIFT) /**< DES                     */
+#define EU_MD                 (0x03 << EU_SEL_SHIFT) /**< SHA160/225/256/MD5      */
+#define EU_RND                (0x04 << EU_SEL_SHIFT) /**< Randomizer              */
+#define EU_PK                 (0x05 << EU_SEL_SHIFT) /**< Public Key              */
+#define EU_AES                (0x06 << EU_SEL_SHIFT) /**< AES                     */
+#define EU_KEA                (0x07 << EU_SEL_SHIFT) /**< Kasumi                  */
+#define EU_CRC                (0x08 << EU_SEL_SHIFT) /**< CRC unit                */
+#define EU_SNOW               (0x09 << EU_SEL_SHIFT) /**< SNOW-3G unit            */
+#define EU_MDPRIME            (0x0b << EU_SEL_SHIFT) /**< SHA256/384/512 -t3 only */
+
+
+/* MDHA Mode Bits                                            */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  | */
+/* | CONT | CICV | SMAC | INIT | HMAC |  PD  |     ALG     | */
+#define MD_CONT               (0x80)
+#define MD_CICV               (0x40)
+#define MD_SMAC               (0x20)
+#define MD_INIT               (0x10)
+#define MD_HMAC               (0x08)
+#define MD_PD                 (0x04)
+#define MD_SHA1               (0x00)
+#define MD_SHA256             (0x01)
+#define MD_MD5                (0x02)
+#define MD_SHA224             (0x03)
+#define MD_SHA384             (0x00)  /* in MDEU-B mode */
+#define MD_SHA512             (0x02)  /* in MDEU-B mode */
+
+
+/* DES Mode Bits                                             */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  | */
+/*                             |     CM      |  TS  |  ED  | */
+#define DES_ENCRYPT           (0x01)
+#define DES_DECRYPT           (0x00)
+#define DES_TRIPLE            (0x02)
+#define DES_SINGLE            (0x00)
+#define DES_CBC               (0x04)
+#define DES_ECB               (0x00)
+#define DES_CFB_64            (0x08)
+#define DES_OFB_64            (0x0c)
+
+
+/* AES Mode Bits                                                     */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |         */
+/* |     ECM     | AUX2 | AUX1 | AUX0 |     CM      |  ED  | T3 view */
+/* |     ECM     |  FM  |  IM  | RDK  |     CM      |  ED  | T2 view */
+#define AES_ENCRYPT           (0x01)
+#define AES_DECRYPT           (0x00)
+#define AES_RDK               (0x08)
+#define AES_INITMAC           (0x10)
+#define AES_FINALMAC          (0x20)
+#define AES_AUX0              (0x08)
+#define AES_AUX1              (0x10)
+#define AES_AUX2              (0x20)
+
+#define AES_ECB               ((0x00 << 6) | (0x00 << 1))
+#define AES_CBC               ((0x00 << 6) | (0x01 << 1))
+#define AES_CBC_RBP           ((0x00 << 6) | (0x01 << 1) | AES_FINALMAC)
+#define AES_CBC_OFB           ((0x00 << 6) | (0x02 << 1))
+#define AES_CTR               ((0x00 << 6) | (0x03 << 1))
+#define AES_LRW_NO_TWEAK      ((0x01 << 6) | (0x00 << 1) | AES_FINALMAC)
+#define AES_LRW               ((0x01 << 6) | (0x00 << 1))
+#define AES_CMAC              ((0x01 << 6) | (0x02 << 1))
+#define AES_CMAC_ICV          ((0x01 << 6) | (0x02 << 1) | AES_FINALMAC)
+#define AES_SRTP              ((0x01 << 6) | (0x03 << 1))
+#define AES_CCM               ((0x02 << 6) | (0x00 << 1))
+#define AES_CCM_FMAC          ((0x02 << 6) | (0x00 << 1) | AES_FINALMAC)
+#define AES_GCM               ((0x02 << 6) | (0x01 << 1))
+#define AES_GCM_FMAC          ((0x02 << 6) | (0x01 << 1) | AES_FINALMAC)
+#define AES_XCBC_MAC          ((0x02 << 6) | (0x02 << 1))
+#define AES_XCBC_MAC_ICV      ((0x02 << 6) | (0x02 << 1) | AES_FINALMAC)
+#define AES_CFB128            ((0x02 << 6) | (0x03 << 1))
+#define AES_CCM               ((0x02 << 6) | (0x00 << 1))
+#define AES_CCM_ICV           ((0x03 << 6) | (0x00 << 1))
+#define AES_GCM_ICV           ((0x03 << 6) | (0x01 << 1))
+#define AES_XOR               ((0x03 << 6) | (0x03 << 1))
+
+
+/* PKHA Mode Bits                                             */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |  */
+/* |                     ROUTINE                              */
+#define PK_CLEARMEM           (0x01) /**< Clear PKHA memory           */
+#define PK_MOD_EXP            (0x02) /**< Expo mod N,
+                                            convert from Monty        */
+#define PK_MOD_R2MODN         (0x03) /**< Compute Monty converter     */
+#define PK_MOD_RRMODP         (0x04) /**< Compute Monty converter
+                                            for CRT                   */
+#define PK_EC_FP_AFF_PTMULT   (0x05) /**< FP scalar * point in
+                                            affine system             */
+#define PK_EC_F2M_AFF_PTMULT  (0x06) /**< F2M scalar * point in
+                                            affine system             */
+#define PK_EC_FP_PROJ_PTMULT  (0x07) /**< FP scalar
+                                            * point projective        */
+#define PK_EC_F2M_PROJ_PTMULT (0x08) /**< F2M scalar
+                                            * point projective        */
+#define PK_EC_FP_ADD          (0x09) /**< FP Add two points           */
+#define PK_EC_FP_DOUBLE       (0x0a) /**< FP double a point           */
+#define PK_EC_F2M_ADD         (0x0b) /**< F2M Add two points          */
+#define PK_EC_F2M_DOUBLE      (0x0c) /**< F2M double a point          */
+#define PK_F2M_R2             (0x0d) /**< F2M R2 mod N montgomery
+                                            converter                 */
+#define PK_F2M_INV            (0x0e) /**< F2M modular inversion       */
+#define PK_FP_MODINV          (0x0f) /**< FP modular inversion        */
+#define PK_FP_MODADD          (0x10) /**< FP modular addition         */
+#define PK_FP_MODSUB          (0x20) /**< FP modular subtraction      */
+#define PK_FP_MULT_MONT       (0x30) /**< FP multiply in montgomery   */
+#define PK_FP_MULT_DECONV     (0x40) /**< FP multiply and deconvert
+                                            from monty                */
+#define PK_F2M_ADD            (0x50) /**< F2M modular addition        */
+#define PK_F2M_MULT_MONT      (0x60) /**< F2M multiply in montgomery  */
+#define PK_F2M_MULT_DECONV    (0x70) /**< F2M multiply and deconvert
+                                            from monty                */
+#define PK_RSA_SS             (0x80) /**< Single-Step RSA expo        */
+#define PK_MOD_EXP_TEQ        (0x1d) /**< Expo ModN with timing EQ    */
+#define PK_RSA_SS_TEQ         (0x1e) /**< SingleStep RSA w/timing EQ  */
+#define PK_PKBUILD            (0xff) /**< Build the ECC intermediate
+                                            structure                 */
+
+/* ARC4 mode bits                                            */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  | */
+/*                                    |  CS  |  DC  |  PP  | */
+#define ARC4_PERMUTE_INHIBIT  (0x01) /**< don't init Sbox if true     */
+#define ARC4_DUMP_CONTEXT     (0x02) /**< write context when done     */
+#define ARC4_FETCH_CTX        (0x04) /**< read context
+                                            before starting           */
+
+/* Kasumi mode bits                                          */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  | */
+/* | GSM  | CICV | EDGE |  PE  | INT  |      |     ALG     | */
+#define KEA_F8                (0x00) /**< f8 function                 */
+#define KEA_F9                (0x02) /**< f9 function                 */
+#define KEA_INIT              (0x08) /**< setup for new message       */
+#define KEA_EOM               (0x10) /**< end of message              */
+#define KEA_EDGE              (0x20) /**< EDGE-compatible reads       */
+#define KEA_ICV               (0x40) /**< inline integrity check      */
+#define KEA_GSM               (0x80) /**< GSM-compatible reads        */
+
+
+/* CRC mode bits                                              */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |  */
+/* | RAW  | CICV |                           |     ALG     |  */
+#define CRC_RAW               (0x80) /**< do not perform result
+                                            manupulation              */
+#define CRC_ICV               (0x40) /**< perform inline integrity
+                                            check                     */
+#define CRC_802               (0x00) /**< Use 802.x
+                                            polynomial/residue        */
+#define CRC_ISCSI             (0x01) /**< Use iSCSI
+                                            polynomial/residue        */
+#define CRC_STATIC_CUSTOM     (0x02) /**< Use Control Register
+                                            for remainder             */
+#define CRC_DYNAMIC_CUSTOM    (0x03) /**< Use Key register
+                                            for remainder             */
+
+/* SNOW-3G mode bits                                          */
+/* |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |  */
+/* |      | CICV |      |  PE  | INT  |         ALG        |  */
+#define SNOW_F8               (0x01) /**< F8 cipher                  */
+#define SNOW_F9               (0x02) /**< F9 integrity check         */
+#define SNOW_INIT             (0x08) /**< Initialization (new msg)   */
+#define SNOW_EOM              (0x10) /**< End of message (finalize)  */
+#define SNOW_ICV              (0x40) /**< inline integrity check     */
+
+
+/* Remaining header stuff, shift/mask for EU selection and descriptor type */
+
+#define EU_SHIFT_PRIMARY    (20)
+#define EU_SHIFT_SECONDARY  (8)
+
+#define DESCTYPE_SHIFT      (3)
+#define DESCTYPE_MASK       (0x0000001f << DESCTYPE_SHIFT)
+
+
+/*
+ * AES counter-mode nonsnooping       0  b0000_0
+ * aesu_ctr_nosnoop
+ * p0 - (reserved)
+ * p1 - Cipher Context In
+ * p2 - Cipher Key
+ * p3 - Main Data In
+ * p4 - Data Out
+ * p5 - Cipher Context Out
+ * p6 - (reserved)
+ */
+#define DESCTYPE_AES_CTR        (0 << DESCTYPE_SHIFT)
+
+
+/*
+ * IPSec ESP singlepass               1  b0000_1
+ * ipsec_esp
+ * p0 - HMAC Key
+ * p1 - Hash-only Header
+ * p2 - Cipher IV In
+ * p3 - Cipher Key
+ * p4 - Main Data In          ext: ICV In
+ * p5 - Data Out              ext: ICV Out
+ * p6 - Cipher IV Out
+ */
+#define DESCTYPE_IPSEC_ESP      (1 << DESCTYPE_SHIFT)
+
+
+/*
+ * Common nonsnooping no RC4          2  b0001_0
+ * common_nosnoop DES, Kasumi f8, RNG, AES-CCM
+ * p0 - (reserved)
+ * p1 - Context In
+ * p2 - Key
+ * p3 - Main Data In
+ * p4 - Data Out
+ * p5 - Context Out
+ * p6 - (reserved)
+ *
+ * common_nosnoop MDEU
+ * p0 - (reserved)
+ * p1 - Context In
+ * p2 - Key
+ * p3 - Main Data In
+ * p4 - ICV In
+ * p5 - Context Out
+ * p6 - (reserved)
+ *
+ * common_nosnoop Kasumi f9, AES-XCBC, AES_CMAC, CRCA
+ * p0 - (reserved)
+ * p1 - Context In
+ * p2 - Key
+ * p3 - Main Data In
+ * p4 - (reserved)            ext: ICV in
+ * p5 - Context Out
+ * p6 - ICV Out
+ */
+#define DESCTYPE_COMMON         (2 << DESCTYPE_SHIFT)
+
+
+/*
+ * AES CCMP singlepass 802.11i        3  b0001_1
+ * 802.11i_AES_ccmp
+ * p0 - CRC-only Header       ext: CRC In/Out (FCS)
+ * p1 - AES Context In
+ * p2 - AES Key
+ * p3 - Hash-Only Header
+ * p4 - Main Data In          ext: MIC In
+ * p5 - Data Out              ext: MIC Out
+ * p6 - AES Context Out
+ */
+#define DESCTYPE_AES_CCMP       (3 << DESCTYPE_SHIFT)
+
+
+/*
+ * HMAC snooping no RC4               4  b0010_0
+ * hmac_snoop_no_afeu
+ * p0 - Hash Key
+ * p1 - Hash-Only Header
+ * p2 - Cipher Key
+ * p3 - Cipher Context In
+ * p4 - Main Data In
+ * p5 - Data Out
+ * p6 - ICV Out
+ */
+#define DESCTYPE_HMAC           (4 << DESCTYPE_SHIFT)
+
+
+/*
+ * SRTP single-pass                   5  b010_1
+ * srtp_with_ICV_check
+ * p0 - HMAC Key
+ * p1 - AES Context in
+ * p2 - AES Key
+ * p3 - Main Data In          ext: Hash-Only Header
+ * p4 - Data Out              ext: Hash-Only Trailer
+ * p5 - HMAC Out
+ * p6 - AES Context Out
+ *
+ * srtp_without_ICV_check
+ * p0 - HMAC Key
+ * p1 - AES Context in
+ * p2 - AES Key
+ * p3 - Main Data In          ext: Hash-Only Header
+ * p4 - HMAC In               ext: Hash-Only Trailer
+ * p5 - Data Out              ext: HMAC Out
+ * p6 - AES Context Out
+ */
+#define DESCTYPE_SRTP           (5 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                         6  b0011_0
+ */
+
+
+/*
+ * ECC data assemble                  7  b0011_1
+ * pkeu_build
+ * p0 - A0 In
+ * p1 - A1 In
+ * p2 - A2 In
+ * p3 - A3 In
+ * p4 - B0 In
+ * p5 - B1 In
+ * p6 - Build Out
+ */
+#define DESCTYPE_PK_ECC_ASM     (7 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                         8  b0100_0
+ */
+
+
+/*
+ * ECC point multiply                 9  b0100_1
+ * pkeu_ptmul
+ * p0 - N In
+ * p1 - E In
+ * p2 - Build In
+ * p3 - B1 Out
+ * p4 - B2 Out
+ * p5 - B3 out
+ * p6 - (reserved)
+ */
+#define DESCTYPE_PK_ECC_PTMULT  (9 << DESCTYPE_SHIFT)
+
+
+/*
+ * Common nonsnooping RC4            10  b0101_0
+ * common_nosnoop_afeu
+ * p0 - (reserved)
+ * p1 - Context In (via in FIFO)
+ * p2 - Cipher Key
+ * p3 - Main Data In
+ * p4 - Data Out
+ * p5 - Context Out (via out FIFO)
+ * p6 - (reserved)
+ */
+#define DESCTYPE_ARC4           (10 << DESCTYPE_SHIFT)
+
+
+/*
+ * ECC point add-double              11  b0101_1
+ * pkeu_ptadd_dbl
+ * p0 - N In
+ * p1 - Build In
+ * p2 - B2 In
+ * p3 - B3 In
+ * p4 - B1 Out
+ * p5 - B2 Out
+ * p6 - B3 Out
+ */
+#define DESCTYPE_PK_ECC_PTADD_D (11 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                        12-15
+ */
+
+
+/*
+ * Montgomery multiply               16  b1000_0
+ * pkeu_mm
+ * p0 - N In
+ * p1 - B In
+ * p2 - A In
+ * p3 - E In
+ * p4 - B Out
+ * p5 - (reserved)
+ * p6 - (reserved)
+ */
+#define DESCTYPE_PK_MONTY       (16 << DESCTYPE_SHIFT)
+
+
+/*
+ * TLS singlepass blockcipher        17  b1000_1
+ * tls_ssl_block (outbound)
+ * p0 - MAC Key
+ * p1 - Cipher IV In
+ * p2 - Cipher Key
+ * p3 - Main Data In          ext: Hash-Only Header
+ * p4 - Cipher-Only Trailer   ext: ICV Out
+ * p5 - Data Out
+ * p6 - Cipher IV Out
+ *
+ * tls_ssl_block (inbound)
+ * p0 - MAC Key
+ * p1 - Cipher IV In
+ * p2 - Cipher Key
+ * p3 - (reserved)            ext: Hash-Only Header
+ * p4 - Main Data In          ext: ICV In
+ * p5 - Main Data Out         ext: ICV Out
+ * p6 - Cipher IV Out
+ */
+#define DESCTYPE_TLS_BLOCK      (17 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                        18  b1001_0
+ */
+
+
+/*
+ * TLS singlepass streamcipher       19  b1001_1
+ * tls_ssl_stream (outbound)
+ * p0 - MAC Key
+ * p1 - Cipher IV In
+ * p2 - Cipher Key
+ * p3 - Main Data In          ext: Hash-Only Header
+ * p4 - (reserved)            ext: ICV Out
+ * p5 - Data Out
+ * p6 - Cipher IV Out
+ *
+ * tls_ssl_stream (inbound)
+ * p0 - MAC Key
+ * p1 - Cipher IV In
+ * p2 - Cipher Key
+ * p3 - (reserved)            ext: Hash-Only Header
+ * p4 - Main Data In          ext: ICV In
+ * p5 - Data Out              ext: ICV Out
+ * p6 - Cipher IV Out
+ */
+#define DESCTYPE_TLS_STREAM     (19 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                        20  b1010_0
+ */
+
+
+/*
+ * RAID-XOR multiple sources         21  b1010_1
+ * raid_xor
+ * p0 - Source F Data In
+ * p1 - Source E Data In
+ * p2 - Source D Data In
+ * p3 - Source C Data In
+ * p4 - Source B Data In
+ * p5 - Source A Data In
+ * p6 - Data Out
+ */
+#define DESCTYPE_RAIDXOR        (21 << DESCTYPE_SHIFT)
+
+
+/*
+ * (reserved)                        22  b1011_0
+ */
+
+
+/*
+ * IPSec ESP with AES-ECM            23  b1011_1
+ * ipsec_aes_gcm
+ * p0 - AES Context In
+ * p1 - AAD In
+ * p2 - Nonce Part 2 In
+ * p3 - AES Key In            ext: Nonce Part 1 In
+ * p4 - Main Data In          ext: AES ICV In
+ * p5 - Data Out              ext: AES ICV Out
+ * p6 - Cipher Context Out    ext: CRC ICV In/Out
+ */
+#define DESCTYPE_IPSEC_AES_GCM  (23 << DESCTYPE_SHIFT)
+
+
+/*
+ * AES CTR snoop (-HMAC)             24  b1100_0
+ * hmac_snoop_aesu_ctr
+ * p0 - Hash Key
+ * p1 - Hash-Only Header
+ * p2 - AES Key
+ * p3 - AES Context In
+ * p4 - Main Data In
+ * p5 - Data Out
+ * p6 - ICV Out
+ */
+#define DESCTYPE_AES_HMAC       (24 << DESCTYPE_SHIFT)
+
+
+/*
+ * Double CRC operation              25  b1100_1
+ * dbl_digest
+ * p0 - Header In             ext: Header ICV
+ * p1 - Payload In            ext: Payload ICV
+ * p2 - (reserved)            ext: Header ICV Out
+ * p3 - (reserved)            ext: Payload ICV Out
+ * p4 - (reserved)
+ * p5 - (reserved)
+ * p6 - (reserved)
+ */
+#define DESCTYPE_DBLCRC         (25 << DESCTYPE_SHIFT)
+
+/*
+ * (reserved)                        26-31
+ */
+
+
+/* Remaining Header Bits */
+#define HDR_OUTBOUND        (0x00000000)
+#define HDR_INBOUND         (0x00000002)
+#define HDR_DONE            (0x00000001)
+
+
+
+
+
+/*
+ * General register structure of a SEC2 or 3 core
+ */
+
+/** Register location offset relative to IMMR base or equivalent */
+#define T2_BASEADDR_OFFSET            (0x00030000)
+
+/** Size of register bank space requested from memory manager */
+#define T2_REGISTER_BANK_SIZE         (0x00010000)
+
+
+/** fixed depth of a T2 fetch FIFO */
+#define T2_CHANNEL_FIFO_DEPTH         (24)
+
+
+#ifdef OBSOLETE
+#define T2_TOTAL_CHANNELS             (4)
+#define T2_TOTAL_EUS                  (7)
+#endif
+
+#define T3_MAX_CHANNELS               (10) /* theoretical max, based on */
+                                           /* register map              */
+#define T3_MAX_EUS                    (9)  /* includes MDEU-B */
+
+    typedef u8 _resvd;
+
+
+
+
+    /*
+     * Content of the device controller block
+     * This controls all aspects of the core's interaction with
+     * the remainder of the system (interrupts, bus priorities, etc.
+     *
+     */
+
+    /* EU assignment status register - 0x31028 ro */
+#define T2_EUASR_AFEU_MASK                 0x0f00000000000000ull
+#define T2_EUASR_AFEU_SHIFT                56
+#define T2_EUASR_MDEU_MASK                 0x000f000000000000ull
+#define T2_EUASR_MDEU_SHIFT                48
+#define T2_EUASR_AESU_MASK                 0x00000f0000000000ull
+#define T2_EUASR_AESU_SHIFT                40
+#define T2_EUASR_DEU_MASK                  0x0000000f00000000ull
+#define T2_EUASR_DEU_SHIFT                 32
+#define T2_EUASR_KEU_MASK                  0x00000000000f0000ull
+#define T2_EUASR_KEU_SHIFT                 16
+#define T2_EUASR_PKEU_MASK                 0x0000000000000f00ull
+#define T2_EUASR_PKEU_SHIFT                8
+#define T2_EUASR_RNG_MASK                  0x000000000000000full
+#define T2_EUASR_RNG_SHIFT                 0
+#define T2_EUASR_STEU_MASK                 0x000000000000f000ull
+#define T2_EUASR_STEU_SHIFT                12
+
+
+    /* Interrupt Mask/Status/Clear (IMR/ISR/ICR) defs */
+    /* IMR - 0x31008 rw */
+    /* ISR - 0x31010 ro */
+    /* ICR - 0x31018 wo */
+#define T2_IMR_INTERNAL_TIMEOUT            0x0001000000000000ull
+
+#define T2_IMR_DONE_OVERFLOW_CH0           0x0000010000000000ull
+#define T2_IMR_DONE_OVERFLOW_CH1           0x0000020000000000ull
+#define T2_IMR_DONE_OVERFLOW_CH2           0x0000040000000000ull
+#define T2_IMR_DONE_OVERFLOW_CH3           0x0000080000000000ull
+
+#define T2_IMR_ERROR_CH0                   0x0000000200000000ull
+#define T2_IMR_ERROR_CH1                   0x0000000800000000ull
+#define T2_IMR_ERROR_CH2                   0x0000002000000000ull
+#define T2_IMR_ERROR_CH3                   0x0000008000000000ull
+#define T2_IMR_ERROR_ALL_CHANNELS          (T2_IMR_ERROR_CH0 | \
+        T2_IMR_ERROR_CH0 | \
+        T2_IMR_ERROR_CH0 | \
+        T2_IMR_ERROR_CH0)
+#define T2_IMR_ERROR_STEP                  2
+
+#define T2_IMR_DONE_CH0                    0x0000000100000000ull
+#define T2_IMR_DONE_CH1                    0x0000000400000000ull
+#define T2_IMR_DONE_CH2                    0x0000001000000000ull
+#define T2_IMR_DONE_CH3                    0x0000004000000000ull
+#define T2_IMR_DONE_ALL_CHANNELS           (T2_IMR_DONE_CH0 | \
+        T2_IMR_DONE_CH1 | \
+        T2_IMR_DONE_CH2 | \
+        T2_IMR_DONE_CH3)
+#define T2_IMR_DONE_STEP                   2
+
+#define T2_IMR_DONE_DEU                    0x0000000000000001ull
+#define T2_IMR_ERROR_DEU                   0x0000000000000002ull
+#define T2_IMR_DONE_AESU                   0x0000000000000010ull
+#define T2_IMR_ERROR_AESU                  0x0000000000000020ull
+#define T2_IMR_DONE_MDEU                   0x0000000000000100ull
+#define T2_IMR_ERROR_MDEU                  0x0000000000000200ull
+#define T2_IMR_DONE_AFEU                   0x0000000000001000ull
+#define T2_IMR_ERROR_AFEU                  0x0000000000002000ull
+#define T2_IMR_DONE_RNG                    0x0000000000010000ull
+#define T2_IMR_ERROR_RNG                   0x0000000000020000ull
+#define T2_IMR_DONE_PKEU                   0x0000000000100000ull
+#define T2_IMR_ERROR_PKEU                  0x0000000000200000ull
+#define T2_IMR_DONE_KEU                    0x0000000001000000ull
+#define T2_IMR_ERROR_KEU                   0x0000000002000000ull
+#define T2_IMR_DONE_STEU                   0x0000000000400000ull
+#define T2_IMR_ERROR_STEU                  0x0000000000800000ull
+
+
+/* Master Control Register (MCR) defs - 0x31030 rw */
+
+#define T2_MCR_BUSPRIORITY_LOW             0x0000000000000000ull
+#define T2_MCR_BUSPRIORITY_MED_LOW         0x0000010000000000ull
+#define T2_MCR_BUSPRIORITY_MED_HIGH        0x0000020000000000ull
+#define T2_MCR_BUSPRIORITY_HIGH            0x0000030000000000ull
+
+/* GI exists only in the PQ2pro variants */
+#define T2_MCR_GLOBAL_INHIBIT              0x0000000200000000ull
+
+#define T2_MCR_SOFTWARE_RESET              0x0000000100000000ull
+
+
+
+/** Register-level view of a controller block, 256 bytes */
+typedef struct _T2controller {
+    _resvd       _reserved1[8];                  /**< 0x00 - 0x07 */
+    volatile u64 intMask;                        /**< 0x08 - 0x0f */
+    volatile u64 intStatus;                      /**< 0x10 - 0x17 */
+    volatile u64 intClear;                       /**< 0x18 - 0x1f */
+    volatile u64 ID;                             /**< 0x20 - 0x27 */
+    volatile u64 euStatus;                       /**< 0x28 - 0x2f */
+    volatile u64 masterControl;                  /**< 0x30 - 0x37 */
+    _resvd       _reserved2[200];                /**< 0x38 - 0xff */
+} T2CONTROLLER;
+
+
+
+    /*
+     * Content of a channel control block
+     * Provides for a DMA-like interface between cryptographic services
+     * and host memory
+     */
+
+    /* Channel Control Register (CCR) defs - 0x31x08 rw*/
+#define T2_CCR_CONTINUE                    0x0000000200000000ull
+#define T2_CCR_RESET                       0x0000000100000000ull
+
+#define T2_CCR_BURSTSIZE_128               0x0000000000000100ull
+#define T2_CCR_BURSTSIZE_64                0x0000000000000000ull
+#define T2_CCR_ICV_STATUS_WRITEBACK        0x0000000000000080ull
+#define T2_CCR_ADDRESS_32                  0x0000000000000000ull
+#define T2_CCR_ADDRESS_36                  0x0000000000000020ull
+#define T2_CCR_CHANNEL_DONE_WRITEBACK      0x0000000000000010ull
+#define T2_CCR_STATUS_WRITEBACK            0x0000000000000008ull
+#define T2_CCR_SELECTIVE_NOTIFY            0x0000000000000004ull
+#define T2_CCR_CHANNEL_DONE_INTERRUPT      0x0000000000000002ull
+
+/* Channel Pointer Status Register (CPSR) defs - 0x31x10 ro */
+/* Note these are mildly different between T2/3, but the    */
+/* error bits are basically the same                        */
+#define T2_CPSR_FF_COUNTER_MASK            0x1f00000000000000ull
+#define T2_CPSR_FF_COUNTER_SHIFT           56
+#define T2_CPSR_G_STATE_MASK               0x000f000000000000ull
+#define T2_CPSR_G_STATE_SHIFT              48
+#define T2_CPSR_S_STATE_MASK               0x00000f0000000000ull
+#define T2_CPSR_S_STATE_SHIFT              40
+#define T2_CPSR_CHN_STATE_MASK             0x000000ff00000000ull
+#define T2_CPSR_CHN_STATE_SHIFT            32
+
+#define T3_CPSR_GET_STATE_MASK             0x7f00000000000000ull
+#define T3_CPSR_GET_STATE_SHIFT            56
+#define T3_CPSR_PUT_STATE_MASK             0x007f000000000000ull
+#define T3_CPSR_PUT_STATE_SHIFT            48
+#define T3_CPSR_MAIN_STATE_MASK            0x000001ff00000000ull
+#define T3_CPSR_MAIN_STATE_SHIFT           32
+
+#define T2_CPSR_MI                         0x0000000002000000ull
+#define T2_CPSR_MO                         000000000001000000ull
+#define T2_CPSR_PR                         0x0000000000800000ull
+#define T2_CPSR_SR                         0x0000000000400000ull
+#define T2_CPSR_PG                         0x0000000000200000ull
+#define T2_CPSR_SG                         0x0000000000100000ull
+#define T2_CPSR_PRD                        0x0000000000080000ull
+#define T2_CPSR_SRD                        0x0000000000040000ull
+#define T2_CPSR_PD                         0x0000000000020000ull
+#define T2_CPSR_SD                         0x0000000000010000ull
+#define T2_CPSR_ERROR_MASK                 0x000000000000fff0ull
+#define T2_CPSR_ERROR_SHIFT                4
+#define T2_CPSR_PAIR_PTR_MASK              0x000000000000000full
+
+#define T3_CPSR_FF_LEVEL_MASK              0x000000001f000000ull
+#define T3_CPSR_FF_LEVEL_SHIFT             24
+#define T3_CPSR_PRD                        0x0000000000080000ull
+#define T3_CPSR_SRD                        0x0000000000040000ull
+#define T3_CPSR_PD                         0x0000000000020000ull
+#define T3_CPSR_SD                         0x0000000000010000ull
+
+#define T2_CHN_ERROR_DOF                   0x0000000000008000ull
+#define T2_CHN_ERROR_SOF                   0x0000000000004000ull
+#define T2_CHN_ERROR_MDTE                  0x0000000000002000ull
+#define T2_CHN_ERROR_SG_ZERO_LEN           0x0000000000001000ull
+#define T2_CHN_ERROR_FP_ZERO               0x0000000000000800ull
+#define T2_CHN_ERROR_ILLEGAL_HEADER        0x0000000000000400ull
+#define T2_CHN_ERROR_INVALID_EU            0x0000000000000200ull
+#define T2_CHN_ERROR_EU_ERROR              0x0000000000000100ull
+#define T2_CHN_ERROR_G_BOUNDARY            0x0000000000000080ull
+#define T2_CHN_ERROR_G_LENGTH              0x0000000000000040ull
+#define T2_CHN_ERROR_S_BOUNDARY            0x0000000000000020ull
+#define T2_CHN_ERROR_S_LENGTH              0x0000000000000010ull
+
+
+
+/** Register view of a channel block - 256 bytes */
+typedef struct _T2channel {
+    _resvd       _reserved1[8];                  /**< 0x00 - 0x07 */
+    volatile u64 config;                         /**< 0x08 - 0x0f */
+    volatile u64 pointerStatus;                  /**< 0x10 - 0x17 */
+    _resvd       _reserved2[40];                 /**< 0x18 - 0x3f */
+    volatile u64 currentDesc;                    /**< 0x40 - 0x47 */
+    volatile u64 fetchFIFO;                      /**< 0x48 - 0x4f */
+    _resvd       _reserved3[48];                 /**< 0x50 - 0x7f */
+    volatile u64 descBuffer[8];                  /**< 0x80 - 0xbf */
+    volatile u64 gatherLinkTbl[4];               /**< 0xc0 - 0xdf */
+    volatile u64 scatterLinkTbl[4];              /**< 0xe0 - 0xff */
+} T2CHANNEL;
+
+
+/** Register view of the T3 polychannel status - padded to 256 bytes */
+typedef struct _T2polychn {
+    volatile u64 fetchFIFOenQ;                   /**< 0x00 - 0x07 */
+    volatile u64 descFinished;                   /**< 0x08 - 0x0f */
+    volatile u64 dataBytesIn;                    /**< 0x10 - 0x17 */
+    volatile u64 dataBytesOut;                   /**< 0x18 - 0x1f */
+    _resvd       _reserved[224];                 /**< 0x20 - 0xff */
+} T3POLYCHN;
+
+/** Register view of the IP block ID region - 256 bytes */
+typedef struct _T2IPID {
+    _resvd         _reserved0[248];              /**< 0x00 - 0xf7 */
+    volatile u64 id;                             /**< 0xf8 = 0xff */
+} T2IPID;
+
+
+/** DES (DEU) block register view 0x---32000 */
+typedef struct _T2EU_DES {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[16];               /**< 0x040 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u8    IV[8];                        /**< 0x100 - 0x107 RW */
+    _resvd         _reserved3[760];              /**< 0x108 - 0x3ff -- */
+    volatile u8    key1[8];                      /**< 0x400 - 0x407 WO */
+    volatile u8    key2[8];                      /**< 0x408 - 0x40f WO */
+    volatile u8    key3[8];                      /**< 0x410 - 0x417 WO */
+    _resvd         _reserved4[1000];             /**< 0x418 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T2EU_DES;
+
+
+/** AES (AESU) block register view 0x---34000 */
+typedef struct _T2EU_AES {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[16];               /**< 0x040 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u8    context[8];                   /**< 0x100 - 0x107 RW */
+    _resvd         _reserved3[760];              /**< 0x108 - 0x3ff -- */
+    volatile u8    key[8];                       /**< 0x400 - 0x407 RW */
+    _resvd         _reserved4[1016];             /**< 0x408 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T2EU_AES;
+
+
+/** MD (MDEU) block register view 0x---36000 */
+typedef struct _T2EU_MD {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    volatile u64   ICVsize;                      /**< 0x040 - 0x047 RW */
+    _resvd         _reserved1[8];                /**< 0x048 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u8    context[33];                  /**< 0x100 - 0x120 RW */
+    _resvd         _reserved3[735];              /**< 0x121 - 0x3ff -- */
+    volatile u8    key[128];                     /**< 0x400 - 0x47f WO */
+    _resvd         _reserved4[896];              /**< 0x480 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff WO */
+} T2EU_MD;
+
+
+/** ARC (AFEU) block register view 0x---38000 */
+typedef struct _T2EU_ARC4 {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[16];               /**< 0x040 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u8    contextMem[256];              /**< 0x100 - 0x1ff RW */
+    volatile u8    contextPtr[512];              /**< 0x200 - 0x3ff RW */
+    volatile u8    key0[128];                    /**< 0x400 - 0x47f WO */
+    volatile u8    key1[128];                    /**< 0x480 - 0x4ff WO */
+    _resvd         _reserved3[768];              /**< 0x500 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T2EU_ARC4;
+
+
+/** Random Generator (RNG) block register view 0x---3a000 */
+typedef struct _T2EU_RND {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[16];               /**< 0x040 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[1960];             /**< 0x058 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T2EU_RND;
+
+
+/** PKHA block register view 0x---3c000 */
+typedef struct _T2EU_PKHA {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    volatile u64   ABsize;                       /**< 0x040 - 0x047 RW */
+    _resvd         _reserved1[8];                /**< 0x048 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[424];              /**< 0x058 - 0x1ff -- */
+    volatile u8    paramA0[64];                  /**< 0x200 - 0x23f RW */
+    volatile u8    paramA1[64];                  /**< 0x240 - 0x27f RW */
+    volatile u8    paramA2[64];                  /**< 0x280 - 0x2bf RW */
+    volatile u8    paramA3[64];                  /**< 0x2c0 - 0x2ff RW */
+    volatile u8    paramB0[64];                  /**< 0x300 - 0x33f RW */
+    volatile u8    paramB1[64];                  /**< 0x340 - 0x37f RW */
+    volatile u8    paramB2[64];                  /**< 0x380 - 0x3bf RW */
+    volatile u8    paramB3[64];                  /**< 0x3c0 - 0x3ff RW */
+    volatile u8    paramE[256];                  /**< 0x400 - 0x4ff WO */
+    _resvd         _reserved3[768];              /**< 0x500 - 0x7ff -- */
+    volatile u8    paramN[256];                  /**< 0x800 - 0x8ff RW */
+    _resvd         _reserved4[1792];             /**< 0x900 - 0xfff -- */
+} T2EU_PKHA;
+
+
+/** Kasumi (KEU) block register view 0x---3e000 */
+typedef struct _T2EU_KEA {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[8];                /**< 0x040 - 0x047 -- */
+    volatile u64   F9MAC;                        /**< 0x048 - 0x04f R0 */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u64   IV1;                          /**< 0x100 - 0x107 RW */
+    volatile u64   ICVin;                        /**< 0x108 - 0x10f RW */
+    volatile u64   IV2;                          /**< 0x110 - 0x117 RW */
+    volatile u64   context1;                     /**< 0x118 - 0x11f RW */
+    volatile u64   context2;                     /**< 0x120 - 0x127 RW */
+    volatile u64   context3;                     /**< 0x128 - 0x12f RW */
+    volatile u64   context4;                     /**< 0x130 - 0x137 RW */
+    volatile u64   context5;                     /**< 0x138 - 0x13f RW */
+    volatile u64   context6;                     /**< 0x140 - 0x147 RW */
+    _resvd         _reserved3[696];              /**< 0x148 - 0x3ff -- */
+    volatile u64   key1;                         /**< 0x400 - 0x407 RW */
+    volatile u64   key2;                         /**< 0x408 - 0x40f RW */
+    volatile u64   key3;                         /**< 0x410 - 0x417 RW */
+    volatile u64   key4;                         /**< 0x418 - 0x41f RW */
+    _resvd         _reserved4[992];              /**< 0x420 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T2EU_KEA;
+
+/** SNOW-3G (STEU) block register view 0x---3d000 - T3.1+ only */
+typedef struct _T3EU_SNOW3G {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f -- */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    _resvd         _reserved[8];                 /**< 0x020 - 0x027 -- */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RO */
+    volatile u64   interruptControl;             /**< 0x038 - 0x03f RW */
+    _resvd         _reserved1[8];                /**< 0x040 - 0x047 -- */
+    volatile u64   F9MAC;                        /**< 0x048 - 0x04f R0 */
+    volatile u64   eom;                          /**< 0x050 - 0x057 WO */
+    _resvd         _reserved2[168];              /**< 0x058 - 0x0ff -- */
+    volatile u64   IV1;                          /**< 0x100 - 0x107 RW */
+    volatile u64   ICVin;                        /**< 0x108 - 0x10f RW */
+    volatile u64   IV2;                          /**< 0x110 - 0x117 RW */
+    volatile u64   context1;                     /**< 0x118 - 0x11f RW */
+    volatile u64   context2;                     /**< 0x120 - 0x127 RW */
+    volatile u64   context3;                     /**< 0x128 - 0x12f RW */
+    volatile u64   context4;                     /**< 0x130 - 0x137 RW */
+    volatile u64   LFSRstate;                    /**< 0x138 - 0x13f RW */
+    _resvd         _reserved3[56];               /**< 0x140 - 0x177 -- */
+    volatile u64   FSMstate[2];                  /**< 0x178 - 0x187 RW */
+    _resvd         _reserved4[632];              /**< 0x188 - 0x3ff -- */
+    volatile u64   keyData[2];                   /**< 0x400 - 0x40f RW */
+    _resvd         _reserved5[1008];             /**< 0x410 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff RW */
+} T3EU_SNOW3G;
+
+
+/** CRC (CRCU) block register view 0x---3f000 - T3 only */
+typedef struct _T3EU_CRC {
+    volatile u64   mode;                         /**< 0x000 - 0x007 RW */
+    volatile u64   keySize;                      /**< 0x008 - 0x00f RW */
+    volatile u64   dataSize;                     /**< 0x010 - 0x017 RW */
+    volatile u64   resetControl;                 /**< 0x018 - 0x01f RW */
+    volatile u64   control;                      /**< 0x020 - 0x027 RW */
+    volatile u64   status;                       /**< 0x028 - 0x02f RO */
+    volatile u64   interruptStatus;              /**< 0x030 - 0x037 RW */
+    volatile u64   interruptMask;                /**< 0x038 - 0x03f RW */
+    volatile u64   ICVsize[2];                   /**< 0x040 - 0x04f -- */
+    volatile u64   EUgo;                         /**< 0x050 - 0x057 WO */
+    _resvd         _reserved[176];               /**< 0x058 - 0x107 -- */
+    volatile u32   context;                      /**< 0x108 - 0x10b RW */
+    _resvd         _reserved1[756];              /**< 0x10c - 0x3ff -- */
+    volatile u64   key;                          /**< 0x400 - 0x407 RW */
+    _resvd         _reserved2[1016];             /**< 0x408 - 0x7ff -- */
+    volatile u8    FIFO[2048];                   /**< 0x800 - 0xfff WO */
+} T3EU_CRC;
+
+
+
+/*
+ * Top-level view of Talitos, all blocks aggregated into the full core
+ * This is typically:
+ *
+ * 0x0000 - 0x00ff - (reserved)
+ * 0x0100 - 0x01ff - Alternate channel 0 - T3 only
+ * 0x0200 - 0x02ff - Alternate channel 1 - T3 only
+ * 0x0300 - 0x03ff - Alternate channel 2 - T3 only
+ * 0x0400 - 0x04ff - Alternate channel 3 - T3 only
+ * 0x0500 - 0x05ff - Theoretical alternate channel 4 - T3 only
+ * 0x0600 - 0x06ff - Theoretical alternate channel 5 - T3 only
+ * 0x0700 - 0x07ff - Theoretical alternate channel 6 - T3 only
+ * 0x0800 - 0x08ff - Theoretical alternate channel 7 - T3 only
+ * 0x0900 - 0x09ff - Theoretical alternate channel 8 - T3 only
+ * 0x0a00 - 0x0aff - Theoretical alternate channel 9 - T3 only
+ * 0x1000 - 0x10ff - Controller
+ * 0x1100 - 0x11ff - Channel 0
+ * 0x1200 - 0x12ff - Channel 1
+ * 0x1300 - 0x13ff - Channel 2
+ * 0x1400 - 0x14ff - Channel 3
+ * 0x1500 - 0x15ff - T3 Polychannel
+ * 0x1600 - 0x16ff - (reserved - theoretical channel 5)
+ * 0x1700 - 0x17ff - (reserved - theoretical channel 6)
+ * 0x1800 - 0x18ff - (reserved - theoretical channel 7)
+ * 0x1900 - 0x19ff - (reserved - theoretical channel 8)
+ * 0x1a00 - 0x1aff - (reserved - theoretical channel 9)
+ * 0x1b00 - 0x1bf7 - (reserved)
+ * 0x1bf8 - 0x1bff - IP block revision register
+ * 0x1c00 - 0x1fff - (reserved)
+ * 0x2000 - 0x2fff - DEU
+ * 0x3000 - 0x3fff - (reserved)
+ * 0x4000 - 0x4fff - AESU
+ * 0x5000 - 0x5fff - (reserved)
+ * 0x6000 - 0x6fff - MDEU
+ * 0x7000 - 0x7fff - (reserved)
+ * 0x8000 - 0x8fff - AFEU
+ * 0x9000 - 0x9fff - (reserved)
+ * 0xa000 - 0xafff - RNG
+ * 0xb000 - 0xbfff - (reserved)
+ * 0xc000 - 0xcfff - PKEU
+ * 0xd000 - 0xdfff - SNOW3G
+ * 0xe000 - 0xefff - KEU
+ * 0xf000 - 0xffff - CRCU - T3 only
+ */
+
+typedef struct _T2CORE {
+    _resvd       _reserved0[256];
+    T2CHANNEL    altchn[T3_MAX_CHANNELS]; /**< T3 only, 10 channels only
+                                                    theoretical */
+    _resvd       _reserved1[1280];
+    T2CONTROLLER ctrl;
+    T2CHANNEL    chn[4];
+    T3POLYCHN    polyCh;
+    _resvd       _reserved2[1280];
+    T2IPID       ipID;
+    _resvd       _reserved3[1024];
+    T2EU_DES     euDES;
+    _resvd       _reserved4[4096];
+    T2EU_AES     euAES;
+    _resvd       _reserved5[4096];
+    T2EU_MD      euMD;
+    _resvd       _reserved6[4096];
+    T2EU_ARC4    euARC4;
+    _resvd       _reserved7[4096];
+    T2EU_RND     euRND;
+    _resvd       _reserved8[4096];
+    T2EU_PKHA    euPK;
+    T3EU_SNOW3G  euSNOW;
+    T2EU_KEA     euKEA;
+    T3EU_CRC     euCRC;
+} T2CORE;
+
+
+
+/*
+ * Packet descriptor format for any T2 variant
+ */
+
+#define TOTAL_PAIRS (7)
+
+#define LAST_ENTRY  (0x02)  /**< linkEntry.chainCtrl
+                                    - end of linktable */
+#define NEXT_ENTRY  (0x01)  /**< linkEntry.chainCtrl
+                                    - point to next table */
+
+
+/** Describes a single fragment entry in a linktable
+    These are referenced by a pointer pair if a virtual buffer is
+    "dispersed" (scattered) in memory                             */
+
+typedef struct _linkEntry {
+    u16     segLen;     /**< segment length, <= 64k */
+    u8      chainCtrl;  /**< chain                  */
+    u8      extAddr;    /**< extended address bits  */
+    void   *segAddr;    /**< segment address        */
+} linkEntry;
+
+
+/* Describes a pointer/size pair in a packet descriptor */
+/* There are 7 of these in a single packet descriptor   */
+
+#define JUMPTABLE   (0x80)  /**< ptrPair[].extent if linktable in use */
+#define EXTENT_MASK (0x7f)  /**< ptrPair[].extent without J bit       */
+#define EPTR_MASK   (0x0f)  /**< ptrPair[].eptr useful bits           */
+
+typedef struct _ptrPair {
+    u16   size;     /**< 64K buffer size                          */
+    u8    extent;   /**< J bit (jumptable) plus 128-byte extentq  */
+    u8    eptr;     /**< 4-bit pointer extension
+                        (36-bit addressing                        */
+    void *ptr;
+} ptrPair;
+
+
+
+/** Basic form of a single packet descriptor */
+typedef struct _T2DPD {
+    u32       hdr;
+    u32       fdbk;
+    ptrPair   pair[TOTAL_PAIRS];
+} T2DPD;
+
+
+
+
+
+#ifdef _cplusplus
+}
+#endif
+
+#endif /* T23_H */
diff --git a/drivers/crypto/t23x/common/xwcRMinterface.h b/drivers/crypto/t23x/common/xwcRMinterface.h
new file mode 100644
index 0000000..f5396fb
--- /dev/null
+++ b/drivers/crypto/t23x/common/xwcRMinterface.h
@@ -0,0 +1,306 @@
+
+/*
+ * xwcRMinterface.h
+ *
+ * Defines module interaction between layers for drivers that
+ * conform to the Extensible Crypto Driver Framework (XCDF).
+ * This header is meant to describe the Registered Interface/
+ * Resource Manager component boundary. It contains no hardware
+ * dependencies.
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 1.0.0   2008_01_29 sec - add FW version support
+ * 2.1.0   2009_05_04 sec - remove redundant registration info
+ */
+
+
+#ifndef XWCRMINTFC_H
+#define XWCRMINTFC_H
+
+
+/** @file
+ * xwcRMinterface.h defines the inteface to the extensible driver
+ * resource manager independent of the accelerator architecture.
+ */
+
+
+#ifdef __KERNEL__
+#include <linux/wait.h>
+#include <linux/string.h>
+#endif
+
+#include "../common/t23.h"
+
+
+/* Use this as our "tag" for determining request compatibility, */
+/* should it become a consideration                             */
+#define XWC_FRAMEWORK_CURRENT_VERSION_STRING "2"
+#define XWC_FRAMEWORK_CURRENT_VERSION         2
+
+/**
+ * Error status reported to interfaces for all RM requests
+ */
+
+typedef uint32_t RMstatus;
+
+/**< No error, nothing to see here */
+#define RM_OK                    (0)
+
+/**< The context block referenced by an inbound request was
+     misspecified  */
+#define RM_BAD_INTFC_CTX         (-1)
+
+/**< No more interfaces can be registered at this time */
+#define RM_MAX_INTFC_REGISTERED  (-2)
+
+/**< Registration request misspecified something */
+#define RM_BAD_REGISTRATION_RQ   (-3)
+
+/**< Deregistration request misspecified something */
+#define RM_BAD_DEREGISTRATION_RQ (-4)
+
+/**< A requested feature is not yet implemented in this version */
+#define RM_UNIMPLEMENTED         (-5)
+
+/**< Something in an exec message was corrupted on a queue request
+     or a request cancellation */
+#define RM_BAD_EXEC_MESSAGE      (-6)
+
+/**< Some element in a passed descriptor chain is corrupt, or
+     references some inaccessible element */
+#define RM_CORRUPT_DESCRIPTOR    (-7)
+
+/**< No more entries left in the exec queue, try again later */
+#define RM_EXEC_QUEUE_FULL       (-8)
+
+/**< An algorithm or processing mode requested is not present
+     in the hardware being used */
+#define RM_NO_CAPABILITY         (-9)
+
+/**< The RM needs system heap for something, and can't get it
+     at the present time. */
+#define RM_NO_MEMORY             (-10)
+
+/**< IF tried to cancel request that was already "in process"
+     with a descriptor launched, so, can't cancel */
+#define RM_CANNOT_CANCEL         (-11)
+
+/**< Framework version not supported by this RM */
+#define RM_UNSUPPORTED_FW        (-12)
+
+
+
+
+/*
+ * The basic context for a registered interface
+ * The RM owns these, they are filled out and referenced to
+ * the interface being registered.
+ */
+
+
+typedef struct __RMinterfaceCtx {
+
+     /* interface state registration removed in v2+ due to disuse */
+
+#ifdef __KERNEL__
+    struct device *dev;     /* Assigned dev */
+    void          *devctx;  /* Device-private data */
+#endif
+
+} RMinterfaceCtx;
+
+
+
+
+
+
+
+
+/**
+ * Basic RM request execution message
+ *  @section request_reading Basic RM Request
+ *
+ *  Resource Manager - Execution Request Message
+ *
+ *  This is the basis of the request mechanism between any Interface
+ *  and the Resource Manager. It describes everything that the IF
+ *  needs the RM to do with a string of composed descriptors.
+ * *
+ *  When the RM receives this message, it will place this message
+ *  on a queue for execution as soon as resources are available to
+ *  execute it. The IF *must* leave this message, and it's associated
+ *  descriptors, alone until the completion handler is called.
+ *
+ *  The request will return an entry ID that the IF can maintain
+ *  if it needs to cancel a request.
+ */
+
+
+typedef struct _RMexecMessage {
+    /* If framework evolves, this is a version compatibility tag */
+    uint32_t           frameworkID;
+    uint32_t           reserved;
+
+    /*
+     * Part #1: Everything about the set of descriptors that defines
+     * this request. This includes a pointer to the head of the list,
+     * any mapping information that must "live" with the request
+     * throughout it's lifecycle, and a count of the total descriptors
+     * in the list
+     */
+    void              *descHead;      /**< Points to DMA-able descriptor
+                                           list, readable by hardware */
+    void              *descBufferMap; /**< Auxiliary mapping info
+                                           for desccriptor list, the actual
+                                           content is hardware-dependent */
+    uint32_t           descCount;     /**< Total descriptors in this set */
+
+    /*
+     * Part #2: Status/error information. Although an Interface can't touch
+     * registers directly, it can interpret them. Therefore, this will hold
+     * error information for interpretation by the interface, into whatever
+     * form is useful.
+     */
+    u64                errState[4]; /**< untranslated error content from RM */
+
+    void              *errDesc;     /**< physical address of the descriptor
+                                         triggering the error, if implemented
+                                         by the hardware in use             */
+
+
+    /*
+     * Part #3: Exec message release handler specification.
+     * Since the Interface might not have a way of knowing when a request
+     * has completed processing, it can specify a handler that knows how to
+     * release all resources associated with the request. This specification
+     * takes the form of a handler function, and a pointer to an Interface-
+     * defined argument that identifies the individual request. For the
+     * cirrent release, this function is required.
+     */
+    void             (*messageReleaseHandler)(void *);
+    void              *releaseArgument;
+
+    /*
+     * Part #4: Reserved queue handlers. Used for allocating a queue
+     * to a dedicated application, and invoking specialty handlers either
+     * at interrupt time, or deferred service time.
+     *
+     * Unimplemented in the current release.
+     */
+    uint8_t            reservedQueue;
+    void             (*queueISRHandler)(uint32_t); /* ISR level handler */
+    void             (*queueAuxHandler)(uint32_t); /* deferred handler */
+
+    /*
+     * Part #5: Request completion identity.
+     * At the completion of a request, the Resource Manager can take
+     * optional actions to notify the Interface, or a user of the interface,
+     * that the request is complete. There are two classes of such actions,
+     * one for synchronous style requests, and another for asynchronous
+     * requests.
+     */
+    /* Synchronous set */
+    wait_queue_head_t *waitingTask; /**< saved waitqueue for waiting task */
+
+    /* Asynchronous set */
+    void             (*descriptorDoneHandler)(uint32_t);
+    void             (*descriptorErrorHandler)(uint32_t);
+    void              *initialRQ; /**< IF-defined pointer for deferred service */
+    pid_t              rqID;      /**< PID of the requesting process */
+    int                sigval[4]; /**< saved signals for user process */
+    uint8_t            buftype; /**< memory type for buffer releases */
+
+
+
+    /*
+     * Part #6: Miscellaneous tracking information
+     */
+    RMinterfaceCtx    *owningIF; /**< Request belongs to this Interface */
+} RMexecMessage;
+
+
+
+
+/**
+ * General prototypes for the RM's functionality exposed to an IF
+ */
+
+/** Queue a new request message */
+RMstatus xwcRMqueueRequest(RMinterfaceCtx *intfc,
+                           RMexecMessage  *execMsg,
+                           uint32_t       *entryID);
+
+
+
+/** Cancel a queued request */
+RMstatus xwcRMcancelRequest(RMinterfaceCtx *intfc,
+                            uint32_t        entryID);
+
+
+/** Registration prototypes for any resource manager */
+RMstatus xwcRMregisterInterface(uint8_t         *intname,
+                                RMinterfaceCtx **regdesc);
+
+RMstatus xwcRMderegisterInterface(RMinterfaceCtx *regdesc);
+
+
+/** Memory buffer mapping/management functions for use by all IFs */
+
+RMstatus xwcMemTranslateLogical(uint32_t    ent,
+                                void       *pd,
+                                void       *pdmap);
+
+RMstatus xwcMemTranslateUserVirtual(uint32_t    ent,
+                                    void       *pd,
+                                    void       *pdmap);
+
+RMstatus xwcMemTranslateKernelVirtual(uint32_t    ent,
+                                      void       *pd,
+                                      void       *pdmap);
+
+RMstatus xwcMemReleaseLogical(uint32_t    ent,
+                              void       *pd,
+                              void       *pdmap);
+
+RMstatus xwcMemReleaseUserVirtual(uint32_t    ent,
+                                  void       *pd,
+                                  void       *pdmap);
+
+RMstatus xwcMemReleaseKernelVirtual(uint32_t    ent,
+                                    void       *pd,
+                                    void       *pdmap);
+
+
+#endif /* XWCRMINTFC_H */
diff --git a/drivers/crypto/t23x/t23xrm/Makefile b/drivers/crypto/t23x/t23xrm/Makefile
new file mode 100644
index 0000000..72d2e07
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/Makefile
@@ -0,0 +1,16 @@
+#
+# 2.6 makefile for T2/3 extensible crypto driver resource manager
+#
+# Valid EXTRA_CFLAGS are (-Dnnn):
+#     RM_DBG_APITRACE - view requests through all RM interface entry points
+#     RM_DBG_DPDVIEW  - dump all descriptors right before initiation
+#     RM_DBG_DEVID    - show the ID of the device at startup
+#     RM_DBG_EXTENDED_ERROR - show in-depth information on error
+
+#EXTRA_CFLAGS += -DRM_DBG_DEVID -DRM_DBG_APITRACE -DRM_DBG_DPDVIEW -DRM_DBG_EXTENDED_ERROR
+EXTRA_CFLAGS += -DRM_DBG_DEVID
+
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X) += t23xrm.o
+
+t23xrm-objs := t23xrmBase.o t23xrmModule.o t23xrmISR.o t23xrmIFreg.o\
+    t23xrmRequest.o t23xrmResponse.o t23xrmID.o t23xrmMemUtil.o
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmBase.c b/drivers/crypto/t23x/t23xrm/t23xrmBase.c
new file mode 100644
index 0000000..d41c0b5
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmBase.c
@@ -0,0 +1,191 @@
+
+/*
+ * t23xrmBase.c
+ *
+ * Core of the Talitos 2/3 extensible resource manager,
+ * including module registration, core detection and
+ * initialization, and the global storage area for
+ * each core instance.
+ *
+ * Current versions are 100% dependent on a flat device
+ * tree entry for each core, they do not auto-detect
+ * hardware capability
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - simplified registration rework
+ *
+ */
+
+
+/** @file t23xrmBase.c
+ * Device initialization and shutdown
+ */
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+#include "t23xrmInternal.h"
+
+
+void t23xrmCoreID(T2CoreInstance *inst, uint8_t fdt);
+
+
+RMinterfaceCtx ifCtx;
+
+
+/**
+ * t23RMdevInit() - portable part of device initialization
+ *
+ * @param *t2blk        device state context block
+ *
+ * @param  channels     Number of channels implemented in this device
+ *
+ * @param  fifo_depth   Depth of Fetch FIFOs implemented in this device
+ *
+ * @param  eu_present   Bitmask of EUs present in this device
+ *
+ * @param  desc_types   Descriptor types supported by this device
+ *
+ * @return
+ */
+int32_t t23RMdevInit(T2CoreInstance *t2blk,
+                     uint32_t channels,
+                     uint32_t fifo_depth,
+                     uint32_t eu_present,
+                     uint32_t desc_types)
+{
+    int32_t           i, stat;
+
+    stat = 0;
+
+    /* Init ISR and Exec queues */
+    t2blk->isrQhead  = 0;
+    t2blk->isrQtail  = 0;
+    t2blk->isrQlevel = 0;
+    t2blk->isrQpeak  = 0;
+
+    for (i = 0; i < EXEC_QUEUE_DEPTH; i++)
+        t2blk->execQ[i] = NULL;
+
+    t2blk->execQhead  = 0;
+    t2blk->execQtail  = 0;
+    t2blk->execQlevel = 0;
+    t2blk->execQpeak  = 0;
+    spin_lock_init(&t2blk->execQlock);
+
+    /* init channel states */
+    for (i = 0; i < T3_MAX_CHANNELS; i++)
+    {
+        t2blk->channelState[i] = CHstateFree;
+        t2blk->chnDescCt[i]    = 0;
+    }
+
+
+    /* Initialize the device geometry with the stuff passed in from */
+    /* the OS-dependent part of initialization. Ports of the driver */
+    /* that don't work with the device tree need to ignore this,    */
+    /* and derive the configuration from registers                  */
+    t2blk->totalChannels = channels;
+    t2blk->fifoDepth     = fifo_depth;
+    t2blk->euPresent     = eu_present | 0x00000001; /* or-in EU_NONE */
+    t2blk->validTypes    = desc_types;
+
+    /* Now go ID the core so we know what we're working with */
+    t23xrmCoreID(t2blk, HAS_FDT);
+
+
+#ifdef RM_DBG_DEVID
+    printk("Extensible Crypto Driver - SEC 2/3 Resource Manager - pkg rev %s\n", T23X_PACKAGE_VERSION);
+    printk("core ID = %s (0x%016llx/0x%016llx)\n",
+           t2blk->devName,
+           t2blk->regs->ctrl.ID,
+           t2blk->regs->ipID.id);
+#endif
+
+
+    /* All configured, reset the device */
+    t2blk->regs->ctrl.masterControl = T2_MCR_SOFTWARE_RESET;
+
+
+    /* Enable all channel interrupts. May throw this out in favor */
+    /* of individual channel enable/disable functions */
+    t2blk->regs->ctrl.intMask = (T2_IMR_ERROR_CH0 |
+                                 T2_IMR_ERROR_CH1 |
+                                 T2_IMR_ERROR_CH2 |
+                                 T2_IMR_ERROR_CH3 |
+                                 T2_IMR_DONE_CH0 |
+                                 T2_IMR_DONE_CH1 |
+                                 T2_IMR_DONE_CH2 |
+                                 T2_IMR_DONE_CH3);
+
+
+
+    /* ...and configure channels to taste. This is just a generic      */
+    /* setting, protocol plugins may choose a different configuration. */
+    /* Configuration is saved off in core instance block for resets,   */
+    /* and possible mutation, if need be                               */
+
+    for (i = 0; i < t2blk->totalChannels; i++)
+    {
+        t2blk->channelConfig[i] = T2_CCR_BURSTSIZE_128 |
+                                  T2_CCR_ADDRESS_32 |
+                                  T2_CCR_ICV_STATUS_WRITEBACK |
+                                  T2_CCR_STATUS_WRITEBACK |
+                                  T2_CCR_SELECTIVE_NOTIFY |
+                                  T2_CCR_CHANNEL_DONE_INTERRUPT;
+
+        t2blk->regs->chn[i].config = t2blk->channelConfig[i];
+    }
+
+    /* Any remaining miscellaneous stuff */
+    t2blk->processedRQs = 0;
+
+    /* All done, return to OS-level initialization */
+    return stat;
+}
+
+
+
+/**
+ * Remove device
+ *
+ * @return      status
+ */
+RMstatus t23RMdevRemove(T2CoreInstance *t2blk)
+{
+    /* Turn off all interrupts */
+    t2blk->regs->ctrl.intMask = 0;
+
+    return RM_OK;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmID.c b/drivers/crypto/t23x/t23xrm/t23xrmID.c
new file mode 100644
index 0000000..36317eb
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmID.c
@@ -0,0 +1,635 @@
+
+/*
+ * t23xrmID.c
+ *
+ * Contains core version detection code for the t23x resource manager
+ * module
+ *
+ * As of the present rev, core characteristice are provided by the
+ * device tree, this module effectively determines the core
+ * major/minor/rev from the ID registers. It can be used to detect
+ * core capability for operating systems that don't support an fdt
+ * construct in the future.
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - add SNOW-3G CHA support
+ */
+
+
+/** @file
+ * Handles device version detection for Talitos 2/3 devices, and
+ * sets up "capability information" for an initialized device
+ */
+
+#include <linux/types.h>
+
+#include "t23xrmInternal.h"
+
+extern T2CoreInstance t2blk[];
+
+
+
+
+static const uint8_t devname_unknown[] = { "unknown" };
+static const uint8_t devname_2_0_0[]   = { "2.0.0" }; /* 8541/8555 */
+static const uint8_t devname_2_0_1[]   = { "2.0.1" }; /* 8349/8347/8343/8360/8538 */
+static const uint8_t devname_2_1_0[]   = { "2.1.0" }; /* 8548/8547/8545/8543 */
+static const uint8_t devname_2_1_1[]   = { "2.1.1" };
+static const uint8_t devname_2_1_2[]   = { "2.1.2" }; /* 8548/8547/8545/8543 */
+static const uint8_t devname_2_1_3[]   = { "2.1.3" };
+static const uint8_t devname_2_1_4[]   = { "2.1.4" }; /* 8548/8547/8545/8543 */
+static const uint8_t devname_2_1_5[]   = { "2.1.5" }; /* 8548/8547/8545/8543 */
+static const uint8_t devname_2_2_0[]   = { "2.2.0" }; /* 8323/8321/8311/8313 */
+static const uint8_t devname_2_2_1[]   = { "2.2.1" }; /* 8323/8321/8311/8313 */
+static const uint8_t devname_2_2_2[]   = { "2.2.2" }; /* 8323/8321/8311/8313 */
+static const uint8_t devname_2_4_0[]   = { "2.4.0" }; /* 8349/8347/8343/8360/8538 */
+static const uint8_t devname_2_4_1[]   = { "2.4.1" }; /* 8349/8347/8343/8360/8538 */
+static const uint8_t devname_2_4_2[]   = { "2.4.2" }; /* 8349/8347/8343/8360/8538 */
+
+static const uint8_t devname_3_0_0[]   = { "3.0.0" }; /* 8572/8571/8379/8378/8377 */
+static const uint8_t devname_3_0_1[]   = { "3.0.1" }; /* 8536 */
+static const uint8_t devname_3_1_0[]   = { "3.1.0" }; /* 8569/8526 */
+static const uint8_t devname_3_3_0[]   = { "3.3.0" }; /* 8315 */
+static const uint8_t devname_3_3_1[]   = { "3.3.1" }; /* 8315 */
+
+/*
+ * Device capability mode bits for both Talitos 2 and 3
+ * This is the same convention used for the device tree, and is used to build
+ * a "capability mask" for the hardware detected in the system.
+ *
+ * On late linux-powerpc versions, this comes directly from the OS. For all
+ * others, NO_FDT should be specified to t23xrmCoreID(), and the proper
+ * values detected from ID registers and passed in.
+ *
+ *
+ *       EU selection bits
+ *
+ *       0 (reserved - none selected)
+ *       1 AFEU
+ *       2 DEU
+ *       3 MDEU-A  (T2 and 3)
+ *       4 RNG
+ *       5 PKEU
+ *       6 AESU
+ *       7 KEU
+ *       8 CRCU
+ *       9 STEU
+ *      10 (reserved)
+ *      11 MDEU-B  (T3 only)
+ *      12 (reserved)
+ *      13 (reserved)
+ *      14 (reserved)
+ *      15 (reserved, header writeback)
+ *
+ *      Descriptor processing mode selection bits
+ *
+ *       0 aesu_ctr_nonsnoop      AESU CTR mode. nonsnoop
+ *       1 ipsec_esp              IPSEC ESP conventional (non-GCM)
+ *       2 common_nonsnoop        Common non-PK or ARC4
+ *       3 802.11i_AES_ccmp       CCMP cipher/hash compliant with 802.11i
+ *       4 hmac_snoop_no_afeu     HMAC snoop, non-AFEU
+ *       5 srtp descriptor        Cipher/hash compliant with SRTP
+ *       6 non_hmac_snoop_no_afeu
+ *       7 pkeu_assemble          PK request build for ECC
+ *       8 aesu_key_expand_output
+ *       9 pkeu_ptmul             PK point multiply
+ *      10 common_nonsnoop_afeu   Common ARC4
+ *      11 pkeu_ptadd_dbl         PK point add double
+ *      12 (reserved)
+ *      13 (reserved)
+ *      14 (reserved)
+ *      15 (reserved)
+ *      16 pkeu_mm                PKEU Montgomery Multiplication
+ *      17 tls_ssl_block          TLS/SSL generic blockcipher
+ *      18 (reserved)
+ *      19 tls_ssl_stream         TLS/SSL generic streamcipher
+ *      20 (reserved)
+ *      21 raid_xor               XOR 2-6 sources
+ *      22 (reserved)
+ *      23 ipsec_aes_gcm          IPSEC ESP with GCM cipher/hash
+ *      24 hmac_snoop_aesu_ctr    AESU CTR hmac snooping
+ *      25 dbl_crc                Double CRC operations
+ *      26 (reserved)
+ *      27 (reserved)
+ *      28 (reserved)
+ *      29 (reserved)
+ *      30 (reserved)
+ *      31 (reserved)
+ */
+
+#define HAS_NULL   0x00000001
+#define HAS_AFEU   0x00000002
+#define HAS_DEU    0x00000004
+#define HAS_MDEU   0x00000008
+#define HAS_RNG    0x00000010
+#define HAS_PKEU   0x00000020
+#define HAS_AESU   0x00000040
+#define HAS_KEU    0x00000080
+#define HAS_CRCU   0x00000100
+#define HAS_STEU   0x00000200
+#define HAS_MDEU_B 0x00000800
+
+#define HAS_AESU_CTR_NONSNOOP      0x00000001
+#define HAS_IPSEC_ESP              0x00000002
+#define HAS_COMMON_NONSNOOP        0x00000004
+#define HAS_COMMON_80211_AES_CCMP  0x00000008
+#define HAS_HMAC_SNOOP_NO_AFEU     0x00000010
+#define HAS_SRTP                   0x00000020
+#define HAS_NON_HMAC_SNOOP_NO_AFEU 0x00000040
+#define HAS_PKEU_ASSEMBLE          0x00000080
+#define HAS_AESU_KEY_EXPAND_OUT    0x00000100
+#define HAS_PKEU_PTMUL             0x00000200
+#define HAS_COMMON_NONSNOOP_AFEU   0x00000400
+#define HAS_PKEU_PTADD_DBL         0x00000800
+#define HAS_PKEU_MM                0x00010000
+#define HAS_TLS_SSL_BLOCK          0x00020000
+#define HAS_TLS_SSL_STREAM         0x00080000
+#define HAS_RAID_XOR               0x00200000
+#define HAS_IPSEC_AES_GCM          0x00800000
+#define HAS_HMAC_SNOOP_AESU_CTR    0x01000000
+#define HAS_DBL_CRC                0x02000000
+
+
+/**
+ * Core ID and capabilty map builder.
+ * This needs to be made table-driven
+ *
+ * Passes instance and NO_FDT if the device tree is not present,
+ * or HAS_FDT if it exists
+ */
+
+void t23xrmCoreID(T2CoreInstance *inst, uint8_t fdt)
+{
+    T2CoreInstance  *thisInst;
+
+    thisInst = inst;
+
+    /* If a device has no known ID, don't let it do much */
+    thisInst->devMajor      = 0;
+    thisInst->devMinor      = 0;
+    thisInst->devRev        = 0;
+    thisInst->devName       = devname_unknown;
+    if (fdt == NO_FDT)
+    {
+        thisInst->totalChannels = 0;
+        thisInst->fifoDepth     = 24;
+        thisInst->euPresent     = HAS_NULL;
+        thisInst->validTypes    = 0;
+    }
+
+
+    /* 2.0.0 - 8541/8555 */
+    if (thisInst->regs->ctrl.ID == 0x0000000000000040ull)
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 0;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_2_0_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.0.1 - 8349/8347/8343/8360/8538 */
+    if (thisInst->regs->ctrl.ID == 0x0000000000000041ull)
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 0;
+        thisInst->devRev   = 1;
+        thisInst->devName  = devname_2_0_1;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.1.0 - 8548/8547/8545/8543 */
+    if ((thisInst->regs->ctrl.ID == 0x0000000000000040ull) &&
+        (thisInst->regs->ipID.id == 0x0030000000000000ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 1;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_2_1_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.1.2 - 8548/8547/8545/8543 */
+    if ((thisInst->regs->ctrl.ID == 0x0030010200000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030010200000000ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 1;
+        thisInst->devRev   = 2;
+        thisInst->devName  = devname_2_1_2;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.1.4 - 8548/8547/8545/8543 */
+    if ((thisInst->regs->ctrl.ID == 0x0030010400000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030010400000000ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 1;
+        thisInst->devRev   = 4;
+        thisInst->devName  = devname_2_1_4;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.1.5 - 8548/8547/8545/8543 */
+    if ((thisInst->regs->ctrl.ID == 0x0030010500000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030010500000000ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 1;
+        thisInst->devRev   = 5;
+        thisInst->devName  = devname_2_1_5;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.2.0 - 8323/8321/8311/8313 */
+    if ((thisInst->regs->ctrl.ID == 0x00000000000000a0ull) &&
+        (thisInst->regs->ipID.id == 0x00000000000000a0ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 2;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_2_2_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 1;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_DEU | HAS_MDEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_AESU_KEY_EXPAND_OUT |
+                                      HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_IPSEC_AES_GCM | HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.2.1 - 8323/8321/8311/8313 */
+    if ((thisInst->regs->ctrl.ID == 0x00000000000100a0ull) &&
+        (thisInst->regs->ipID.id == 0x00000000000100a0ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 2;
+        thisInst->devRev   = 1;
+        thisInst->devName  = devname_2_2_1;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 1;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_DEU | HAS_MDEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_AESU_KEY_EXPAND_OUT |
+                                      HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_IPSEC_AES_GCM | HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.2.2 - 8323/8321/8311/8313 */
+    if ((thisInst->regs->ctrl.ID == 0x00000000000200a0ull) &&
+        (thisInst->regs->ipID.id == 0x00000000000200a0ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 2;
+        thisInst->devRev   = 2;
+        thisInst->devName  = devname_2_2_2;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 1;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_DEU | HAS_MDEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_AESU_KEY_EXPAND_OUT |
+                                      HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_IPSEC_AES_GCM | HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.4.0 - 8349/8347/8343/8360/8538 */
+    if ((thisInst->regs->ctrl.ID == 0x0030000000000003ull) &&
+        (thisInst->regs->ipID.id == 0x0030000000000003ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 4;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_2_4_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.4.1 - 8349/8347/8343/8360/8538 */
+    if ((thisInst->regs->ctrl.ID == 0x0030000100000003ull) &&
+        (thisInst->regs->ipID.id == 0x0030000100000003ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 4;
+        thisInst->devRev   = 1;
+        thisInst->devName  = devname_2_4_1;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 2.4.2 - 8349/8347/8343/8360/8538 */
+    if ((thisInst->regs->ctrl.ID == 0x0030000200000003ull) &&
+        (thisInst->regs->ipID.id == 0x0030000200000003ull))
+    {
+        thisInst->devMajor = 2;
+        thisInst->devMinor = 4;
+        thisInst->devRev   = 2;
+        thisInst->devName  = devname_2_4_2;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_HMAC_SNOOP_AESU_CTR;
+        }
+    }
+
+    /* 3.0.0 - 8572/8571/8379/8378/8377 */
+    if ((thisInst->regs->ctrl.ID == 0x0030030000000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030030000000000ull))
+    {
+        thisInst->devMajor = 3;
+        thisInst->devMinor = 0;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_3_0_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU | HAS_CRCU | HAS_MDEU_B;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_RAID_XOR | HAS_IPSEC_AES_GCM |
+                                      HAS_HMAC_SNOOP_AESU_CTR | HAS_DBL_CRC;
+        }
+    }
+
+    /* 3.0.1 - 8536 */
+    if ((thisInst->regs->ctrl.ID == 0x0030030000010000ull) &&
+        (thisInst->regs->ipID.id == 0x0030030000010000ull))
+    {
+        thisInst->devMajor = 3;
+        thisInst->devMinor = 0;
+        thisInst->devRev   = 1;
+        thisInst->devName  = devname_3_0_1;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU | HAS_CRCU | HAS_MDEU_B;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_RAID_XOR | HAS_IPSEC_AES_GCM |
+                                      HAS_HMAC_SNOOP_AESU_CTR | HAS_DBL_CRC;
+        }
+    }
+
+    /* 3.1.0 - 8569/8526 */
+    if ((thisInst->regs->ctrl.ID == 0x0030030100000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030030100000000ull))
+    {
+        thisInst->devMajor = 3;
+        thisInst->devMinor = 1;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_3_1_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_AFEU | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_KEU | HAS_CRCU | HAS_STEU | HAS_MDEU_B;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_COMMON_NONSNOOP_AFEU | HAS_PKEU_PTADD_DBL |
+                                      HAS_PKEU_MM | HAS_TLS_SSL_BLOCK | HAS_TLS_SSL_STREAM |
+                                      HAS_RAID_XOR | HAS_IPSEC_AES_GCM |
+                                      HAS_HMAC_SNOOP_AESU_CTR | HAS_DBL_CRC;
+        }
+    }
+
+    /* 3.3.0 - 8315 */
+    if ((thisInst->regs->ctrl.ID == 0x0030030300000000ull) &&
+        (thisInst->regs->ipID.id == 0x0030030300000000ull))
+    {
+        thisInst->devMajor = 3;
+        thisInst->devMinor = 3;
+        thisInst->devRev   = 0;
+        thisInst->devName  = devname_3_3_0;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_CRCU | HAS_MDEU_B;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_PKEU_PTADD_DBL | HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR | HAS_IPSEC_AES_GCM |
+                                      HAS_HMAC_SNOOP_AESU_CTR | HAS_DBL_CRC;
+        }
+    }
+
+    /* 3.3.1 - 8315 */
+    if ((thisInst->regs->ctrl.ID == 0x0030030300010000ull) &&
+        (thisInst->regs->ipID.id == 0x0030030300010000ull))
+    {
+        thisInst->devMajor = 3;
+        thisInst->devMinor = 3;
+        thisInst->devRev   = 1;
+        thisInst->devName  = devname_3_3_1;
+        if (fdt == NO_FDT)
+        {
+            thisInst->totalChannels = 4;
+            thisInst->fifoDepth     = 24;
+            thisInst->euPresent     = HAS_NULL | HAS_DEU | HAS_MDEU | HAS_RNG |
+                                      HAS_PKEU | HAS_AESU | HAS_CRCU | HAS_MDEU_B;
+            thisInst->validTypes    = HAS_AESU_CTR_NONSNOOP | HAS_IPSEC_ESP |
+                                      HAS_COMMON_NONSNOOP | HAS_COMMON_80211_AES_CCMP |
+                                      HAS_HMAC_SNOOP_NO_AFEU | HAS_SRTP |
+                                      HAS_NON_HMAC_SNOOP_NO_AFEU | HAS_PKEU_ASSEMBLE |
+                                      HAS_AESU_KEY_EXPAND_OUT | HAS_PKEU_PTMUL |
+                                      HAS_PKEU_PTADD_DBL | HAS_PKEU_MM | HAS_TLS_SSL_BLOCK |
+                                      HAS_TLS_SSL_STREAM | HAS_RAID_XOR | HAS_IPSEC_AES_GCM |
+                                      HAS_HMAC_SNOOP_AESU_CTR | HAS_DBL_CRC;
+        }
+    }
+
+
+    /* Last, init the number of free channels from the total */
+    thisInst->freeChannels = thisInst->totalChannels;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmIFreg.c b/drivers/crypto/t23x/t23xrm/t23xrmIFreg.c
new file mode 100644
index 0000000..d0e82e3
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmIFreg.c
@@ -0,0 +1,117 @@
+
+/*
+ * t23xrmIFreg.c
+ *
+ * Extensible resource manager interface registration/deregistration
+ * functionality for t23x
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - simplify registration
+ *
+ */
+
+
+
+/** @file
+ * Handles registration of extensible "interfaces" with the resource
+ * manager, so that the RM can organize requests from differing sources
+ */
+
+#include "../common/xwcRMinterface.h"
+#include "t23xrmInternal.h"
+
+
+extern RMinterfaceCtx ifCtx;
+
+/**
+ * Register an interface with the resource manager.
+ *
+ * @param intname - name of this interface, the RM will use
+ *           this as an identifier tag
+ *
+ * @param regdesc - points to a reference used to identify
+ *           the context for this interface
+ *
+ * @return RMstatus
+ */
+
+RMstatus xwcRMregisterInterface(uint8_t         *intname,
+                                RMinterfaceCtx **regdesc)
+{
+
+#ifdef RM_DBG_APITRACE
+    printk("xwcRMregisterInterface(intname=%s,regdesc=0x%08x)\n",
+           intname,
+           (uint32_t)regdesc);
+#endif
+
+    if (intname == NULL)
+        return RM_BAD_REGISTRATION_RQ;
+
+    *regdesc = &ifCtx;
+
+    return RM_OK;
+}
+
+
+
+/**
+ * Deregister an interface from the resource manager
+ * @param *regdesc
+ * @return
+ */
+
+RMstatus xwcRMderegisterInterface(RMinterfaceCtx *regdesc)
+{
+
+#ifdef RM_DBG_APITRACE
+    printk("xwcRMderegisterInterface(regdesc=0x%08x)\n",
+           (uint32_t)regdesc);
+#endif
+
+    /* May have to check the status of pending requests first */
+
+    /* Is pointer mis-specified? */
+    if (regdesc == NULL)
+        return RM_BAD_DEREGISTRATION_RQ;
+
+
+    /*
+     * As of this release, this does nothing. If cancellation
+     * is supported in a future release, it will become meaningful
+     */
+
+    return RM_OK;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmISR.c b/drivers/crypto/t23x/t23xrm/t23xrmISR.c
new file mode 100644
index 0000000..114269d
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmISR.c
@@ -0,0 +1,211 @@
+
+/*
+ * t23xrmISR
+ *
+ * t23x interrupt service module
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - remove overflow handler
+ */
+
+
+
+/** @file
+ * Handles interrupt processing for the Talitos 2/3 resource manager,
+ * including definition of the deferred-service tasklet, and it's
+ * initiation.
+ */
+
+#include <linux/interrupt.h>
+
+#include "../common/t23.h"
+#include "t23xrmInternal.h"
+
+
+
+/**
+ * deferred Interrupt routine
+ * @param unused
+ */
+void t23RMdeferredInterruptResponder(unsigned long unused);
+
+
+
+DECLARE_TASKLET(t23xrmPostInt0,
+                t23RMdeferredInterruptResponder,
+		0);
+
+
+/* Extract EU status registeres from a selector derived from a */
+/* descriptor header                                           */
+
+static u64 euGetState(u32              selector,
+                      T2CORE          *dev)
+{
+    switch (selector)
+    {
+        case EU_ARC4:
+            return dev->euARC4.interruptStatus;
+
+        case EU_DES:
+            return dev->euDES.interruptStatus;
+
+        case EU_MD:
+        case EU_MDPRIME:
+            return dev->euMD.interruptStatus;
+
+        case EU_RND:
+            return dev->euRND.interruptStatus;
+
+        case EU_PK:
+            return dev->euPK.interruptStatus;
+
+        case EU_AES:
+            return dev->euAES.interruptStatus;
+
+        case EU_KEA:
+            return dev->euKEA.interruptStatus;
+
+        case EU_CRC:
+            return dev->euCRC.interruptStatus;
+
+        default:
+        case EU_NONE:
+            return 0;
+    }
+}
+
+
+/**
+ * Interrupt Handler
+ * @param irq
+ * @param devInstBlock
+ * @param *regs
+ * @return
+ */
+irqreturn_t t23RMintDoneHandler(int32_t         irq,
+                                void           *devInstBlock)
+{
+    T2CoreInstance *t2blk;
+    u64             intBits, tmp;
+    T2ISRCtx       *thisEntry;
+    int32_t         i;
+    u32             priSel, secSel;
+
+    t2blk = devInstBlock;
+
+    /* Get a copy of the current pending interrupt bits */
+    intBits = t2blk->regs->ctrl.intStatus;
+
+    /* None set, then we didn't cause it, say so in the return */
+    if (!intBits)
+    {
+        panic("t23xrm: no interrupt status detected\n");
+        return IRQ_NONE;
+    }
+
+    /* We've caused something, don't know what yet. Grab an ISR queue */
+    /* entry to store the context in.                                 */
+
+    if ((t2blk->isrQlevel + 1) >= ISRMSG_QUEUE_DEPTH)
+        panic("t23xrm: ISR message queue overflow\n");
+
+    thisEntry = &t2blk->t2isrQ[t2blk->isrQtail];
+    t2blk->isrQtail = (t2blk->isrQtail + 1) % ISRMSG_QUEUE_DEPTH;
+    t2blk->isrQlevel++;
+    if (t2blk->isrQlevel > t2blk->isrQpeak)
+        t2blk->isrQpeak = t2blk->isrQlevel;
+
+    /* clear done/error data before OR of done/error pending bits */
+    thisEntry->channelsDone    = 0;
+    thisEntry->channelsInError = 0;
+
+    /* Capture CPSR/CPDR, and done/error state in queue entry */
+    for (i = 0; i < t2blk->totalChannels; i++)
+    {
+        thisEntry->channelState[i] = t2blk->regs->chn[i].pointerStatus;
+        thisEntry->currentDesc[i]  = t2blk->regs->chn[i].currentDesc;
+
+        if (intBits & (T2_IMR_DONE_CH0 << (i * T2_IMR_DONE_STEP)))
+            thisEntry->channelsDone |= (INT_ACTIVE_CH0 << i);
+
+        if (intBits & (T2_IMR_ERROR_CH0 << (i * T2_IMR_ERROR_STEP)))
+        {
+            /* Build a mask of the channels with an error pending */
+            thisEntry->channelsInError |= (INT_ACTIVE_CH0 << i);
+
+            /* Snapshot EU status for later analysis */
+            /* First, extract EU selection from the failed descriptor */
+            priSel = (((T2DPD *)&t2blk->regs->chn[i].descBuffer)->hdr
+                     >> EU_SHIFT_PRIMARY) & EU_SEL_MASK;
+            secSel = (((T2DPD *)&t2blk->regs->chn[i].descBuffer)->hdr
+                     >> EU_SHIFT_SECONDARY) & EU_SEL_MASK;
+
+            /* Second, translate/extract relevant EU status registers */
+            thisEntry->priEUstate[i] = euGetState(priSel, t2blk->regs);
+
+            if (secSel)
+                thisEntry->secEUstate[i] = euGetState(secSel, t2blk->regs);
+            else
+                thisEntry->secEUstate[i] = 0;
+
+#ifdef RM_DBG_EXTENDED_ERROR
+
+            /* just a blind copy of the descriptor buffer, and the */
+            /* SG link tables, all in one big copy                 */
+            memcpy(&thisEntry->fetchedDesc[i],
+                   &t2blk->regs->chn[i].descBuffer,
+                   sizeof(struct internal_descinfo));
+#endif
+
+            /* Now that we've identified an error-ing channel,       */
+            /* and have captured it's state, reset it, let the reset */
+            /* latch, and restore it's saved configuration           */
+            t2blk->regs->chn[i].config = T2_CCR_RESET;
+            tmp = t2blk->regs->chn[i].config; /* allow reset to cycle */
+            t2blk->regs->chn[i].config = t2blk->channelConfig[i];
+        }
+
+    }
+
+
+    tasklet_schedule(&t23xrmPostInt0); /* kick off deferred service  */
+
+    /* Must make sure interrupt clear register is   */
+    /* written once identified                      */
+    t2blk->regs->ctrl.intClear = intBits;
+
+    return IRQ_HANDLED;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmInternal.h b/drivers/crypto/t23x/t23xrm/t23xrmInternal.h
new file mode 100644
index 0000000..883d5fe
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmInternal.h
@@ -0,0 +1,267 @@
+
+/*
+ * t23xrmInternal.h
+ *
+ * t23x extensible driver subsystem Inter-component definitions, specific
+ * to the hardware architecture and the specific implementation
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - simplify registration
+ *
+ */
+
+
+
+/** @file
+ * Defines internal data structures to be shared between modules of
+ * the T2/3 resource manager. Does not expose any "public" interfaces
+ */
+
+
+#include <linux/version.h>
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+
+#ifndef T23XRMINTERNAL_H
+#define T23XRMINTERNAL_H
+
+
+#define T23X_PACKAGE_VERSION "2.1.0"
+
+
+/* Limit of registrable interfaces */
+#define MAX_INTERFACES (32)
+
+/* Maximum entries in an execution queue */
+#define EXEC_QUEUE_DEPTH (8192)
+
+/* Maximum entries in the interrupt message queue */
+#define ISRMSG_QUEUE_DEPTH (32)
+
+
+
+/* Switch for drivers that don't have a device tree, or those that do */
+#define NO_FDT  0
+#define HAS_FDT 1
+
+
+
+/**
+ * Current state of a channel
+ */
+typedef enum
+{
+    CHstateFree,
+    CHstateBusy,
+    CHstateReserved,
+} T2chState;
+
+/**
+ * Current processing state of a queue entry
+ */
+typedef enum
+{
+    RQstateEmpty,        /**< Empty request                     */
+    RQstatePending,      /**< Waiting for resources             */
+    RQstateProcessing,   /**< Running, descriptors queued       */
+    RQstateDone,         /**< Processing done,
+                                executing followup actions      */
+    RQstateCanceling,    /**< Cancellation request received     */
+} T2rqState;
+
+
+/**
+ * Queue entry for all requests. This is what the RM uses to track
+ * queued requests
+ */
+typedef struct _T2RMqueueEntry
+{
+    RMexecMessage  *rqMsg;
+    RMinterfaceCtx *ownerIF;
+    T2rqState       rqState;
+    /* prev/next */
+} T2RMqueueEntry;
+
+
+
+/**
+ * Descriptor page mapping info used to track resources used in
+ * scatter-gather mapping for any T2/3 descriptor. This gets used
+ * with descBufferMap in the exec message
+ */
+
+typedef struct _PAIR_MAP
+{
+    struct page        **pages;
+    int                  pageCt; /**< Count of mapped pages
+                                        for this pair */
+} T2PTR_PAIR_MAP;
+
+typedef struct _DPD_AUXMAP
+{
+    T2PTR_PAIR_MAP pair[TOTAL_PAIRS];
+    /* anything for whole of DPD? */
+} T2DESC_AUXMAP;
+
+
+
+/*
+ * Interrupt event context - comprises the ISR queue
+ */
+
+#define INT_ACTIVE_CH0 (0x001)
+#define INT_ACTIVE_CH1 (0x002)
+#define INT_ACTIVE_CH2 (0x004)
+#define INT_ACTIVE_CH3 (0x008)
+#define INT_ACTIVE_CH4 (0x010)
+#define INT_ACTIVE_CH5 (0x020)
+#define INT_ACTIVE_CH6 (0x040)
+#define INT_ACTIVE_CH7 (0x080)
+#define INT_ACTIVE_CH8 (0x100)
+#define INT_ACTIVE_CH9 (0x200)
+
+struct internal_descinfo
+{
+    T2DPD     dpd;
+    linkEntry glt[4];
+    linkEntry slt[4];
+};
+
+
+typedef struct _T2ISRCtx
+{
+    u16 channelsDone;                    /**< bitmask of done channels */
+    u16 channelsInError;                 /**< bitmask of errored channels */
+    u64 channelState[T3_MAX_CHANNELS];   /**< CPSR of channel */
+    u64 currentDesc[T3_MAX_CHANNELS];    /**< CDPR of channel */
+
+    /* These save the EU state associated with a channel so that */
+    /* more in-depth information can be analyzed                */
+    u64 priEUstate[T3_MAX_CHANNELS]; /* Primary EU error status */
+    u64 secEUstate[T3_MAX_CHANNELS]; /* Secondary EU error status */
+
+#ifdef RM_DBG_EXTENDED_ERROR
+    /* Captures current descriptor and SG tables upon error interrupt */
+    /* This takes a lot of space, but it's the only practical way to  */
+    /* "save" the information for out-of-ISR analysis. This is copied */
+    /* as one chunk, so it has to mirror the actual registers         */
+    struct internal_descinfo fetchedDesc[T3_MAX_CHANNELS];
+
+#endif
+
+} T2ISRCtx;
+
+
+
+/**
+ * Instance state block for each Talitos device in a system
+ * Normally is only one, but if we keep this together, we can
+ * handle multiples
+ */
+
+#define MAX_T2_INSTANCES (1)
+
+typedef struct _T2CoreInstance
+{
+    /* Hardware information */
+    T2CORE        *regs;            /**< base of Talitos register space */
+    u32            doneIRQid;       /**< main interrupt ID */
+    u32            ovflIRQid;       /**< overflow interrupt, nonzero if exists */
+
+    /* Geometry of this core, derived from ID register or device tree */
+    u8             totalChannels;  /**< Total usable channels        */
+    u8             fifoDepth;      /**< Depth of fetchFIFOs          */
+    u32            euPresent;      /**< header bits of installed EUs */
+    u32            validTypes;     /**< valid descriptor types       */
+
+    /* Translated stuff from device ID register */
+    const u8      *devName;        /**< printable version name */
+    u8             devMajor;       /**< 2 or 3     */
+    u8             devMinor;       /**< ex: 2.n    */
+    u8             devRev;         /**< ex: 2.1.n  */
+
+    /* Current state information */
+    /* will want channel reservation and states for each... */
+    u8             freeChannels;
+    T2chState      channelState[T3_MAX_CHANNELS];
+    u64            channelConfig[T3_MAX_CHANNELS];
+    RMexecMessage *channelActvMsg[T3_MAX_CHANNELS];
+
+    /* ISR message queue for this instance */
+    T2ISRCtx       t2isrQ[ISRMSG_QUEUE_DEPTH];
+    u32            isrQhead;
+    u32            isrQtail;
+    u32            isrQlevel;
+
+    /* Request feeder queue  */
+    RMexecMessage  *execQ[EXEC_QUEUE_DEPTH];
+    u32             execQhead;
+    u32             execQtail;
+    u32             execQlevel;
+    spinlock_t      execQlock;
+
+    /* Statistics collection - may not be permanent */
+    u32             execQpeak;    /* Peak depth of global request queue */
+    u32             isrQpeak;     /* Peak depth of ISR event queue */
+    u64             processedRQs; /* Total exec messages processed */
+    u64             chnDescCt[T3_MAX_CHANNELS]; /* total descriptors/channel */
+} T2CoreInstance;
+
+
+
+
+
+/**
+ * Portable driver initialization - not exposed
+ *
+ */
+int32_t t23RMdevInit(T2CoreInstance *t2blk,
+                     uint32_t channels,
+                     uint32_t fifo_depth,
+                     uint32_t eu_present,
+                     uint32_t desc_types);
+
+
+/**
+ * Portable driver shutdown/removal function - not exposed
+ *
+ */
+RMstatus t23RMdevRemove(T2CoreInstance *t2blk);
+
+
+
+
+#endif /* T23XRMINTERNAL_H */
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmMemUtil.c b/drivers/crypto/t23x/t23xrm/t23xrmMemUtil.c
new file mode 100644
index 0000000..c62f1e3
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmMemUtil.c
@@ -0,0 +1,421 @@
+
+/*
+ * t23xrmMemUtil.c
+ *
+ * Buffer mapping/conversion utility routines for use by t23x registered
+ * interfaces
+ *
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ */
+
+
+
+
+/** @file
+ * Manages buffer mapping for constructed descriptors to be executed
+ * by the xwc driver subsystem for Talitos 2/3, including virtual buffer
+ * page mapping for both kernel and user application handling
+ */
+
+
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+
+#include "../common/xwcRMinterface.h"
+#include "t23xrmInternal.h"
+#include "../common/t23.h"
+
+
+/**
+ * All functions here in t23xrmMemUtil.c are designed to handle the
+ * mapping, lockdown, and construction of fragment lists as required for
+ * (a) a single memory buffer specified in a descriptor, and (b)
+ * the host operating system in question.
+ *
+ * There are six calls present, handling the mapping translation and
+ * unmapping/freeing of buffers consisting of three different classes
+ * of memory as:
+ *
+ *   (1) Logical addresses
+ *   (2) Virtual addresses in a user-process address space
+ *   (3) Virtual addresses in the kernel's address space
+ *       (unimplemented in this release)
+ *
+ * Of course, hardware crypto accelerators generally cannot do address
+ * translations on their own; this translation to physical addresses
+ * must be done for them. Advanced crypto accelerators do generally
+ * have the capability to act on a buffers fragmented into varying
+ * locations (as buffers in virtual address space may be), so one of
+ * the actions that must take place here is the construction of a
+ * scatter-gather list for that buffer.
+ *
+ * Therefore, these functions are all passed:
+ * (1) an entity ID for the pointer value in the descriptor, normally
+ * the ordinal value of where the pointer element occurs in the
+ * descriptor's construction,
+ * (2) the descriptor in question (this is core dependent), and
+ * (3) a pointer to auxiliary mapping information that the IF will
+ * preserve with the descriptor; this holds enough information to "free"
+ * any descriptive resources later. These functions will work upon the
+ * three classes of memory in this way:
+ *
+ *   - "Translate" functions will:
+ *     + translate a buffer address to physical
+ *     + if virtual,
+ *       > make sure pages comprising the buffer are swapped in
+ *       > lock down those pages
+ *       > allocate a scatter-gather list adequate for this buffer
+ *       > fill out the scatter-gather list
+ *     + put the physical address (the indirect reference to the
+ *       scatterlist) in the descriptor pointer entity
+ *
+ *   - "Free" functions will:
+ *     + if a scatter-gather list was constructed (DPD_AUXMAP pointer
+ *       is non-NULL):
+ *       > unlock memory pages
+ *       > free the scatter-gather list
+ *
+ * So, all these functions have a symmetrical argument set:
+ * - uint32_t    entity - descriptor pointer entity ID
+ * - void       *desc   - descriptor
+ * - void       *auxmap - auxiliary data to maintain with the descriptor
+ *                       that tracks the resources used for this pointer.
+ *
+ */
+
+/**
+ * RMstatus xwcMemTranslateLogical(uint32_t    entity,
+ *                                 void       *desc,
+ *                                 void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the logical
+ *            buffer reference
+ * - auxmap - an auxmap entry for tracking resources used to
+ *            map this buffer (unlikely to be used with a logical
+ *            address)
+ *
+ * xwcMemTranslateLogical will take a logical buffer pointer
+ * in a descriptor, and translate it to a physical pointer to
+ * the same buffer. The buffer in question must be resident
+ * and contiguous in physical memory
+ *
+ */
+
+RMstatus xwcMemTranslateLogical(uint32_t    entity,
+                                void       *desc,
+                                void       *auxmap)
+{
+    T2DPD   *pd = desc;
+
+#ifdef OBSOLETE
+    uint8_t *ud;
+    ud = pd->pair[entity].ptr;
+#endif
+
+    pd->pair[entity].ptr =
+      (void *)virt_to_phys(lowmem_page_address(pd->pair[entity].ptr));
+
+    return RM_OK;
+}
+
+
+
+
+/**
+ * RMstatus xwcMemTranslateUserVirtual(uint32_t    entity,
+ *                                     void       *desc,
+ *                                     void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the virtual
+ *            buffer reference in the user process' address
+ *            space
+ * - auxmap - an auxmap entry for tracking resources used to
+ *            map this buffer
+ *
+ * xwcMemTranslateUserVirtual(), with a user buffer pointer in
+ * a descriptor (as was passed in from the user process), will
+ * identify the pages used for this buffer, lock them in memory,
+ * allocate a contiguous block for a scatterlist, populate the
+ * scatterlist, and set the descriptor pointer to that scatterlist.
+ *
+ */
+
+RMstatus xwcMemTranslateUserVirtual(uint32_t    entity,
+                                    void       *desc,
+                                    void       *auxmap)
+{
+    unsigned       i;
+    linkEntry     *hwsgl;
+    size_t         count;
+    int            pageEst;
+    T2DPD         *pd = desc;
+    T2DESC_AUXMAP *pdmap = auxmap;
+
+    /* Estimate the number of needed page pointers */
+    pageEst = (((unsigned long)pd->pair[entity].ptr & ~PAGE_MASK) +
+               pd->pair[entity].size + ~PAGE_MASK) >> PAGE_SHIFT;
+
+    /* Allocate list of pointers to pages for this user buffer reference */
+    pdmap->pair[entity].pages = vmalloc(pageEst * sizeof(pdmap->pair[entity].pages));
+    if (pdmap->pair[entity].pages == NULL)
+        return RM_NO_MEMORY;
+
+    /* Lock this process' pages and map them. The descriptor pair pointer */
+    /* still references the user's buffer at this point                   */
+    down_read(&current->mm->mmap_sem);
+    pdmap->pair[entity].pageCt =
+        get_user_pages(current,
+                       current->mm,
+                       (unsigned long)pd->pair[entity].ptr,
+                       pageEst,
+                       WRITE, 1,
+                       pdmap->pair[entity].pages,
+                       NULL);
+    up_read(&current->mm->mmap_sem);
+
+    /* here for development, remove once stabilized */
+    if (pageEst != pdmap->pair[entity].pageCt)
+        printk("t23xwc: user page estimate = %d, actual = %d\n", pageEst, pdmap->pair[entity].pageCt);
+
+    if (pdmap->pair[entity].pageCt > pageEst)
+        panic("t23xwc - user pages mapped exceeds estimate\n");
+
+    /* Needed user pages are now mapped. If data element fits in 1 page, then */
+    /* we can just do a physical pointer, no scatterlist is needed. If it     */
+    /* exceeds one page, we must have a scatterlist                           */
+
+    if (pdmap->pair[entity].pageCt > 1) /* Does entry span pages? */
+    {
+        /* Allocate "hardware" scatterlist */
+        hwsgl = kmalloc(pageEst * sizeof(linkEntry), GFP_KERNEL | GFP_DMA);
+        if (hwsgl == NULL)
+        {
+            /* Out of kmalloc() space, gotta bail. Release mapped pages */
+            for (i = 0; i < pdmap->pair[entity].pageCt; i++)
+                page_cache_release(pdmap->pair[entity].pages[i]);
+
+            /* Free allocated page list */
+            vfree(pdmap->pair[entity].pages);
+
+            return RM_NO_MEMORY;
+        }
+
+        count = pd->pair[entity].size;
+
+        hwsgl[0].segAddr =
+            (unsigned char *)virt_to_phys(lowmem_page_address(pdmap->pair[entity].pages[0]) +
+                             ((unsigned long)pd->pair[entity].ptr & ~PAGE_MASK));
+
+        hwsgl[0].chainCtrl = 0;
+        hwsgl[0].extAddr   = 0;
+
+        if (pdmap->pair[entity].pageCt > 1)
+        {
+            hwsgl[0].segLen = PAGE_SIZE - ((unsigned long)pd->pair[entity].ptr & ~PAGE_MASK);
+            count -= hwsgl[0].segLen;
+            for (i = 1; i < pdmap->pair[entity].pageCt; i++)
+            {
+                hwsgl[i].segLen    = count < PAGE_SIZE ? count : PAGE_SIZE;
+                hwsgl[i].segAddr   = (unsigned char *)
+                    virt_to_phys(lowmem_page_address(pdmap->pair[entity].pages[i]));
+                hwsgl[i].extAddr   = 0;
+                hwsgl[i].chainCtrl = 0;
+                count -= PAGE_SIZE;
+            }
+        }
+        else
+            hwsgl[0].segLen = pd->pair[entity].size;
+
+        /* mark the last entry in the Talitos scatterlist */
+        hwsgl[pdmap->pair[entity].pageCt - 1].chainCtrl = LAST_ENTRY;
+
+        /* Point to descriptor pair to the Talitos scatterlist */
+        pd->pair[entity].ptr     = (unsigned char *)virt_to_phys(hwsgl);
+        pd->pair[entity].extent |= JUMPTABLE;
+    }
+    else
+        pd->pair[entity].ptr =
+            (unsigned char *)virt_to_phys(lowmem_page_address(pdmap->pair[entity].pages[0]) +
+                                          ((unsigned long)pd->pair[entity].ptr & ~PAGE_MASK));
+
+    return RM_OK;
+}
+
+
+
+
+/**
+ * RMstatus xwcMemTranslateKernelVirtual(uint32_t    entity,
+ *                                       void       *desc,
+ *                                       void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the virtual
+ *            buffer reference in the kernel process' address
+ *            space
+ * - auxmap - an auxmap entry for tracking resources used to
+ *            map this buffer
+ *
+ * xwcMemTranslateKernelVirtual() is intended to translate
+ * a kernel-virtual buffer pointer into a scatter/gather
+ * fragment list referencing possibly non-contiguous data
+ * in kernel-owned address space. It is not implemented
+ * at this time, largely because it is assumed that there
+ * is little value to referencing virtual buffers in kernel
+ * mode.
+ */
+
+RMstatus xwcMemTranslateKernelVirtual(uint32_t    entity,
+                                      void       *desc,
+                                      void       *auxmap)
+{
+
+    return RM_UNIMPLEMENTED;
+}
+
+
+
+
+
+
+/**
+ * RMstatus xwcMemReleaseLogical(uint32_t    entity,
+ *                               void       *desc,
+ *                               void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the physical
+ *            buffer reference in the kernel's address space
+ * - auxmap - an auxmap entry for tracking resources used to
+ *            map this buffer
+ *
+ * xwcMemReleaseLogical() as the counterpart of xwcMemTranslateLogical()
+ * is effectively a NULL function, as there are no resources to free
+ * from a logical pointer. It is here only for symmetry.
+ */
+
+RMstatus xwcMemReleaseLogical(uint32_t    entity,
+                              void       *desc,
+                              void       *auxmap)
+{
+    return RM_OK;
+}
+
+
+
+/**
+ * RMstatus xwcMemReleaseUserVirtual(uint32_t    entity,
+ *                                   void       *desc,
+ *                                   void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the physical
+ *            address of a scatter-gather map of the user's
+ *            buffer
+ * - auxmap  - an auxmap entry for tracking resources used to
+ *            map this buffer
+ *
+ * xwcMemReleaseUserVirtual() as the counterpart of
+ * xwcMemTranslateUserVirtual(), exists to free resources used
+ * to describe the physical structure of the user's buffer.
+ * Effectively, it frees the scatterlist, and unlocks/unmaps
+ * the pages comprising the buffer.
+ */
+
+RMstatus xwcMemReleaseUserVirtual(uint32_t    entity,
+                                  void       *desc,
+                                  void       *auxmap)
+{
+    int            i;
+    T2DPD         *pd = desc;
+    T2DESC_AUXMAP *pdmap = auxmap;
+
+    /* If element is in real, live scatterlist, free it */
+    if (pd->pair[entity].extent & JUMPTABLE)
+        kfree(phys_to_virt((unsigned long)pd->pair[entity].ptr));
+
+    /* walk through segment buffer and unlock pages */
+    for (i = 0; i < pdmap->pair[entity].pageCt; i++)
+        page_cache_release(pdmap->pair[entity].pages[i]);
+
+    /* Now free page list */
+    vfree(pdmap->pair[entity].pages);
+
+    return RM_OK;
+}
+
+
+
+/**
+ * RMstatus xwcMemReleaseKernelVirtual(uint32_t    entity,
+ *                                     void       *desc,
+ *                                     void       *auxmap)
+ *
+ * where:
+ * - entity - pointer element identity in the descriptor
+ * - desc   - pointer of the descriptor containing the physical
+ *            address of a scatter-gather map of the kernel
+ *            buffer
+ * - auxmap - an auxmap entry for tracking resources used to
+ *            map this buffer
+ *
+ * xwcMemReleaseKernelVirtual() is present as a placeholder
+ * at this time, it is not implemented.
+ */
+
+RMstatus xwcMemReleaseKernelVirtual(uint32_t    entity,
+                                    void       *desc,
+                                    void       *auxmap)
+{
+
+    return RM_UNIMPLEMENTED;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmModule.c b/drivers/crypto/t23x/t23xrm/t23xrmModule.c
new file mode 100644
index 0000000..ed31609
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmModule.c
@@ -0,0 +1,244 @@
+
+/*
+ * t23xrmModule.c
+ *
+ * Linux specific driver module initialization,
+ *
+ * Current version is 100% dependent on a flat device
+ * tree entry for each core, it does not auto-detect
+ * hardware capability
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * 2.1.0   2009_05_04 sec - remove /proc entries, simplify registration
+ */
+
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+#include "t23xrmInternal.h"
+
+
+
+/* FIXME: This should be picked up from a header... */
+irqreturn_t t23RMintDoneHandler(int32_t, void *);
+
+extern RMinterfaceCtx ifCtx;
+
+
+
+/**
+ * Basic initializer, called from RM module installation
+ *
+ * Note that this only maps in 1 instance of a Talitos core,
+ * all that is possible at the present time. The OS dependent
+ * parts of initialization happen here; the portable core
+ * initialization code happens in t23RMdevInit()
+ *
+ * @return
+ */
+static int t23x_probe(struct of_device *ofdev,
+                      const struct of_device_id *match)
+{
+    int         stat;
+    uint32_t    devirq = 0;
+
+    uint32_t   *channels = NULL;
+    uint32_t   *fifod    = NULL;
+    uint32_t   *eu_mask  = NULL;
+    uint32_t   *typ_mask = NULL;
+    T2CoreInstance *devinst;
+    struct device_node *dn;
+    struct device *dev;
+
+
+    devinst = kzalloc(sizeof(T2CoreInstance), GFP_KERNEL);
+    if (!devinst)
+	return -ENOMEM;
+
+    dev = &ofdev->dev;
+    dev_set_drvdata(dev, devinst);
+    dn = ofdev->node;
+
+    devinst->regs = of_iomap(dn, 0);
+    if (devinst->regs == NULL) {
+        dev_err(dev, "t23x: can't map device register space\n");
+	return -ENOMEM;
+    }
+
+    devinst->doneIRQid = of_irq_to_resource(dn, 0, NULL);
+
+    /* Need to fetch capability bits from the dev node here */
+    channels = (uint32_t *)of_get_property(dn, "fsl,num-channels", NULL);
+    fifod    = (uint32_t *)of_get_property(dn, "fsl,channel-fifo-len", NULL);
+    eu_mask  = (uint32_t *)of_get_property(dn, "fsl,exec-units-mask", NULL);
+    typ_mask = (uint32_t *)of_get_property(dn, "fsl,descriptor-types-mask", NULL);
+
+    if ((channels == NULL) ||
+        (fifod    == NULL) ||
+        (eu_mask  == NULL) ||
+        (typ_mask == NULL))
+    {
+        printk("t23xrm: can't get a required property from device tree\n");
+        return -1;
+    }
+
+    /*
+     * Now go call the standard driver initialization
+     * It's primary argument is the base address of the security block
+     * in the address space of the chip
+     */
+
+    stat = t23RMdevInit(devinst, *channels, *fifod, *eu_mask, *typ_mask);
+
+    if (stat == -1)
+    {
+/*         iounmap(devBase); */
+        return stat;
+    }
+
+
+    /* connect the primary "done" handler. All Talitos devs use this */
+    stat = request_irq(devinst->doneIRQid,
+                       t23RMintDoneHandler,
+                       0,
+                       "t23x-done",
+                       devinst);
+
+    if (stat)
+    {
+        printk("t23xrm: can't connect 'done' interrupt %d\n", devirq);
+        return -1;
+    }
+
+
+
+    ifCtx.dev    = dev;
+    ifCtx.devctx = devinst;
+
+    return stat;
+}
+
+
+/**
+ * Device shutdown and removed, from RM module removal
+ */
+static int t23x_remove(struct of_device *ofdev)
+{
+    T2CoreInstance *devinst;
+
+
+    devinst = dev_get_drvdata(&ofdev->dev);
+
+    /*
+     * Go call the "portable" remove function before releasing
+     * OS resources. It will shut off the core-level interrupt,
+     * we need to shut off the handlers
+     */
+    t23RMdevRemove(devinst);
+
+    /* Now disconnect interrupts */
+    free_irq(devinst->doneIRQid, devinst);
+
+    /* Unmap the register region, and unregister the driver */
+/*    iounmap(devinst->regs); */
+
+    kfree(devinst);
+
+    return 0;
+}
+
+
+static struct of_device_id t23x_match[] = {
+	{
+		.compatible = "fsl,sec3.1",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, t23x_match);
+
+static struct of_platform_driver t23x_driver = {
+	.name        = "t32x",
+	.match_table = t23x_match,
+	.probe       = t23x_probe,
+	.remove      = __devexit_p(t23x_remove),
+};
+
+static int __init t23x_init(void)
+{
+	return of_register_platform_driver(&t23x_driver);
+}
+
+static void __exit t23x_exit(void)
+{
+	return of_unregister_platform_driver(&t23x_driver);
+}
+
+EXPORT_SYMBOL (xwcRMregisterInterface);
+EXPORT_SYMBOL (xwcRMderegisterInterface);
+EXPORT_SYMBOL (xwcRMqueueRequest);
+EXPORT_SYMBOL (xwcRMcancelRequest);
+
+EXPORT_SYMBOL (xwcMemTranslateLogical);
+EXPORT_SYMBOL (xwcMemTranslateUserVirtual);
+EXPORT_SYMBOL (xwcMemTranslateKernelVirtual);
+EXPORT_SYMBOL (xwcMemReleaseLogical);
+EXPORT_SYMBOL (xwcMemReleaseUserVirtual);
+EXPORT_SYMBOL (xwcMemReleaseKernelVirtual);
+
+
+module_init(t23x_init);
+module_exit(t23x_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Extensible Crypto Driver " \
+                    "- Resource Manager (SEC 2/3)");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmRequest.c b/drivers/crypto/t23x/t23xrm/t23xrmRequest.c
new file mode 100644
index 0000000..903a771
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmRequest.c
@@ -0,0 +1,367 @@
+
+/*
+ * t23xrmRequest.c
+ *
+ * t23x resource manager inbound request processing module
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - add SNOW-3G support
+ *
+ */
+
+
+
+
+/** @file
+ * Processes inbound requests for the resource manager, and also
+ * handles the cancellation of a queued request
+ */
+
+#include <linux/mm.h>
+#include "t23xrmInternal.h"
+
+
+
+/**
+ * Starts processing an array of descriptors from an exec message.
+ * The array must be less than the fetch FIFO depth in this
+ * implementation (unless event timers are implemented to ensure
+ * feeding of more)
+ *
+ * @param ins - crypto core instance
+ * @param *rq - exec message to initiate
+ * @param ch  - channel to use
+ */
+void rmStartDesc(T2CoreInstance *t2blk, RMexecMessage *rq, int32_t ch)
+{
+    int32_t    dpdidx;
+    T2DPD     *physdesc;
+
+    t2blk->channelActvMsg[ch] = rq;
+
+    /* get physical pointer to head of list */
+    physdesc = (T2DPD *)virt_to_phys(rq->descHead);
+
+    /* Feed each one to the fetch FIFO. List MUST be smaller than FIFO*/
+    for (dpdidx = 0; dpdidx < rq->descCount; dpdidx++)
+    {
+        t2blk->regs->chn[ch].fetchFIFO = (uint32_t)physdesc;
+        physdesc++;
+        t2blk->chnDescCt[ch]++;
+    }
+}
+
+
+
+/**
+ * Queue a new request message
+ *
+ * @param *t2blk
+ * @param *intfc
+ * @param *execMsg
+ * @param *entryID
+ */
+RMstatus xwcRMqueueRequest(RMinterfaceCtx *intfc,
+                           RMexecMessage  *execMsg,
+                           uint32_t       *entryID)
+{
+    int32_t         i, channel;
+    T2DPD          *listHead, *thisDPD;
+    uint32_t        priEU, secEU, descType;
+    unsigned long   irqflags;
+    T2CoreInstance *t2blk;
+
+#ifdef RM_DBG_DPDVIEW
+    int32_t j, k;
+    linkEntry *thisEnt;
+#endif
+
+    t2blk = (T2CoreInstance *)intfc->devctx;
+
+#ifdef RM_DBG_APITRACE
+    printk("xwcRMqueueRequest(intfc=0x%08x, execMsg=0x%08x, entryID=0x%08x)\n",
+          (uint32_t)intfc, (uint32_t)execMsg, (uint32_t)entryID);
+#endif
+
+    /* If bad IFctx, flag an error */
+    if (intfc == NULL)
+        return RM_BAD_INTFC_CTX;
+
+    /* If null request, just return and act dumb */
+    if (execMsg == NULL)
+        return RM_OK;
+
+    /* If FW version incompatible, quit */
+    if (execMsg->frameworkID > 2)
+        return RM_UNSUPPORTED_FW;
+
+    /* Now check the vital stuff in the execution message */
+    if ((execMsg->descHead == NULL) ||
+            (execMsg->descCount == 0) ||
+            (execMsg->messageReleaseHandler == NULL))
+        return RM_BAD_EXEC_MESSAGE;
+
+#ifdef RM_DBG_DPDVIEW
+
+    printk("t23xrm:xwcRMqueueRequest() - new request received, "
+           "%d deep\n", execMsg->descCount);
+
+    listHead = (T2DPD *)execMsg->descHead;
+
+    for (i = 0; i < execMsg->descCount; i++)
+    {
+        thisDPD = &listHead[i];
+
+        printk("first desc at:   0x%08x (0x%08lx physical)\n", (u32)thisDPD, virt_to_phys(thisDPD));
+
+        printk("desc %2d header:  0x%08x\n",
+                i,
+                thisDPD->hdr);
+
+        printk("(pri:");
+
+        switch((thisDPD->hdr >> EU_SHIFT_PRIMARY) & EU_SEL_MASK)
+        {
+            case EU_ARC4: printk("RC4"); break;
+            case EU_DES:  printk("DES"); break;
+            case EU_RND:  printk("RND"); break;
+            case EU_PK:   printk("PK "); break;
+            case EU_AES:  printk("AES"); break;
+            case EU_KEA:  printk("KEA"); break;
+            case EU_CRC:  printk("CRC"); break;
+            case EU_SNOW: printk("SNO"); break;
+
+            case EU_MD:
+            case EU_MDPRIME:
+                printk("MD "); break;
+
+            case EU_NONE:
+            default:
+                printk("nul"); break;
+
+        printk("/0x%02x sec:", (thisDPD->hdr >> EU_SHIFT_PRIMARY) & EU_MODE_MASK);
+
+        switch((thisDPD->hdr >> EU_SHIFT_SECONDARY) & EU_SEL_MASK)
+        {
+            case EU_ARC4: printk("RC4"); break;
+            case EU_DES:  printk("DES"); break;
+            case EU_RND:  printk("RND"); break;
+            case EU_PK:   printk("PK "); break;
+            case EU_AES:  printk("AES"); break;
+            case EU_KEA:  printk("KEA"); break;
+            case EU_CRC:  printk("CRC"); break;
+            case EU_SNOW: printk("SNO"); break;
+
+            case EU_MD:
+            case EU_MDPRIME:
+                printk("MD "); break;
+
+            case EU_NONE:
+            default:
+                printk("nul"); break;
+        }
+        printk("/0x%02x - ", (thisDPD->hdr >> EU_SHIFT_SECONDARY) & EU_MODE_MASK);
+
+        switch(thisDPD->hdr & DESCTYPE_MASK)
+        {
+            case DESCTYPE_AES_CTR:         printk("aes-ctrmode  :"); break;
+            case DESCTYPE_IPSEC_ESP:       printk("ipsec-ESP    :"); break;
+            case DESCTYPE_COMMON:          printk("cipher-common:"); break;
+            case DESCTYPE_AES_CCMP:        printk("aes-CCMP     :"); break;
+            case DESCTYPE_HMAC:            printk("hmac         :"); break;
+            case DESCTYPE_SRTP:            printk("srtp         :"); break;
+            case DESCTYPE_PK_ECC_ASM:      printk("ecc-assemble :"); break;
+            case DESCTYPE_PK_ECC_PTMULT:   printk("ecc-pt-mult  :"); break;
+            case DESCTYPE_ARC4:            printk("arc4-stream  :"); break;
+            case DESCTYPE_PK_ECC_PTADD_D:  printk("ecc-pt-add   :"); break;
+            case DESCTYPE_PK_MONTY:        printk("pk-montgomery:"); break;
+            case DESCTYPE_TLS_BLOCK:       printk("tls blkcphr  :"); break;
+            case DESCTYPE_TLS_STREAM:      printk("TLS stmcphr  :"); break;
+            case DESCTYPE_RAIDXOR:         printk("raid XOR     :"); break;
+            case DESCTYPE_IPSEC_AES_GCM:   printk("ipsec aes/gcm:"); break;
+            case DESCTYPE_AES_HMAC:        printk("aes-HMAC     :"); break;
+            case DESCTYPE_DBLCRC:          printk("double-crc   :"); break;
+            default:                       printk("unknown      :"); break;
+        }
+
+        if (thisDPD->hdr & HDR_INBOUND)
+            printk("inbound:");
+        else
+            printk("outbound:");
+
+        if (thisDPD->hdr & HDR_DONE)
+            printk("done");
+        else
+            printk("none");
+
+        printk(")\n");
+
+        for (j = 0; j < TOTAL_PAIRS; j++)
+        {
+            if ((thisDPD->pair[j].size) ||
+                (thisDPD->pair[j].ptr))
+            {
+                printk("desc %2d pair %1d: 0x%1x%08x: %5d (ext:%3d)",
+                        i, j,
+                        thisDPD->pair[j].eptr & EPTR_MASK,
+                        (uint32_t)thisDPD->pair[j].ptr,
+                        thisDPD->pair[j].size,
+                        thisDPD->pair[j].extent & EXTENT_MASK);
+                if (thisDPD->pair[j].extent & JUMPTABLE)
+                {
+                    printk(", scattered\n");
+                    k = 0;
+                    thisEnt = (linkEntry *)phys_to_virt((unsigned long)thisDPD->pair[j].ptr);
+                    do
+                    {
+                        printk("          frag: 0x%1x%08x: %5d ",
+                               thisEnt[k].extAddr & EPTR_MASK,
+                               (uint32_t)thisEnt[k].segAddr,
+                               thisEnt[k].segLen);
+                        if (thisEnt[k].chainCtrl & NEXT_ENTRY)
+                        {
+                            printk("->");
+                            thisEnt = (linkEntry *)phys_to_virt((unsigned long)thisEnt[k].segAddr);
+                            k = 0;
+                        }
+                        printk("\n");
+                    } while (!(thisEnt[k++].chainCtrl & LAST_ENTRY));
+                }
+                else
+                    printk(", direct\n");
+            }
+        }
+    }
+
+#endif
+
+    /* Now verify descriptors for supported EUs and modes */
+    listHead = (T2DPD *)execMsg->descHead;
+    for (i = 0; i < execMsg->descCount; i++)
+    {
+        thisDPD = &listHead[i];
+
+        priEU    = ((thisDPD->hdr >> EU_SHIFT_PRIMARY) & EU_SEL_MASK) >> EU_SEL_SHIFT;
+        secEU    = ((thisDPD->hdr >> EU_SHIFT_SECONDARY) & EU_SEL_MASK) >> EU_SEL_SHIFT;
+        descType = (thisDPD->hdr & DESCTYPE_MASK) & DESCTYPE_SHIFT;
+
+
+        /* Check primary and secondary EUs against those in the capability mask */
+        if (!((1 << priEU) & t2blk->euPresent))
+            return RM_NO_CAPABILITY;
+
+        if (!((1 << secEU) & t2blk->euPresent))
+            return RM_NO_CAPABILITY;
+
+        /* Check against supported modes */
+        if (!((1 << descType) & t2blk->validTypes))
+            return RM_NO_CAPABILITY;
+    }
+
+    /* OK, if we got this far, we must have a good RQ message */
+    /* Log the owning interface in this message */
+    execMsg->owningIF = intfc;
+
+    /* Count in in the statistics */
+    t2blk->processedRQs++;
+
+    /*
+     * Lock the global request queue while we either choose a
+     * channel if one is available, or queue the request if
+     * all are busy.
+     *
+     * With this implementation, the exec queue lock is protecting
+     * both the channel pool and the global request queue
+     */
+
+    spin_lock_irqsave(&t2blk->execQlock, irqflags);
+
+    /* Now see if a channel is available */
+    if (t2blk->freeChannels)
+    {
+        for (channel = 0; channel < t2blk->totalChannels; channel++)
+            if (t2blk->channelState[channel] == CHstateFree)
+            {
+                t2blk->freeChannels--;
+                t2blk->channelState[channel] = CHstateBusy;
+                rmStartDesc(t2blk, execMsg, channel);
+                break;
+            }
+    }
+    else
+    {
+        /* Did we overrun the global request queue? */
+        if ((t2blk->execQlevel + 1) >= EXEC_QUEUE_DEPTH)
+        {
+            spin_unlock_irqrestore(&t2blk->execQlock, irqflags);
+            return RM_EXEC_QUEUE_FULL;
+        }
+
+        /* no, so push it on */
+        t2blk->execQ[t2blk->execQtail] = execMsg;
+        t2blk->execQtail = (t2blk->execQtail + 1) % EXEC_QUEUE_DEPTH;
+        t2blk->execQlevel++;
+        if (t2blk->execQlevel > t2blk->execQpeak)
+            t2blk->execQpeak = t2blk->execQlevel;
+
+    }
+
+    spin_unlock_irqrestore(&t2blk->execQlock, irqflags);
+
+    return RM_OK;
+}
+
+
+
+
+/**
+ * Cancel a queued request
+ * @param ins
+ * @param *intfc
+ * @param entryID
+ * @return
+ */
+RMstatus xwcRMcancelRequest(RMinterfaceCtx *intfc,
+                            uint32_t        entryID)
+{
+#ifdef RM_DBG_APITRACE
+    T2CoreInstance *t2blk = (T2CoreInstance *)intfc->devctx;
+
+    printk("xwcRMcancelRequest(inst=0x%08x,intfc=0x%08x,entryID=0x%08x)\n",
+            (uint32_t)t2blk, (uint32_t)intfc, entryID);
+#endif
+
+    return RM_UNIMPLEMENTED;
+}
diff --git a/drivers/crypto/t23x/t23xrm/t23xrmResponse.c b/drivers/crypto/t23x/t23xrm/t23xrmResponse.c
new file mode 100644
index 0000000..537649e
--- /dev/null
+++ b/drivers/crypto/t23x/t23xrm/t23xrmResponse.c
@@ -0,0 +1,348 @@
+
+/*
+ * t23xrmResponse.c
+ *
+ * t23x resource manager response processing module. This module
+ * handles post-request processing on behalf of an interface
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 1.0.0   2008_01_29  sec - simpler queue locking implemented
+ * 2.1.0   2009_05_04  sec - add SNOW-3G support
+ */
+
+
+
+
+/** @file
+ * Handles post-request processing for the resource manager, including
+ * the core of deferred-service processing to follow an interrupt (the
+ * actual tasklet declaration is in t23xrmISR.c)
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+
+#include "t23xrmInternal.h"
+
+#define free_channel(i) \
+    spin_lock_irqsave(&thisDev->execQlock, irqflags);\
+if (thisDev->channelState[i] == CHstateBusy) { \
+    thisDev->channelActvMsg[i] = NULL; \
+    thisDev->channelState[i] = CHstateFree; \
+    thisDev->freeChannels++; } \
+    spin_unlock_irqrestore(&thisDev->execQlock, irqflags);
+
+
+extern void rmStartDesc(T2CoreInstance *t2blk, RMexecMessage *rq, int32_t ch);
+extern RMinterfaceCtx ifCtx[];
+
+
+/**
+ * Deferred service responder to process messages off the ISR
+ * queue
+ * If expanded to multiple instances, "ins" will be the index
+ * of the device instance state block
+ * @param ins
+ */
+void t23RMdeferredInterruptResponder(int inst)
+{
+    int32_t         i;
+    T2ISRCtx       *thisEvent;
+    T2CoreInstance *thisDev;
+    RMexecMessage  *thisMsg, *nextMsg;
+    u32             errorDesc;
+    int32_t         channel, burstsize, burst;
+    unsigned long   irqflags;
+#ifdef RM_DBG_EXTENDED_ERROR
+    int32_t         j;
+    int16_t         errbits;
+#endif
+
+    thisDev = ifCtx[inst].devctx;
+
+
+    /* Spin through "do" for as many events on the ISR event queue */
+    /* This means that the tasklet might get invoked with nothing to */
+    /* do on rare occasions, so be it... */
+
+    do
+    {
+        /* Mask interrupts, and pull ISR contexts off the ISR queue */
+        /* If level == 0, nothing to do */
+        disable_irq(thisDev->doneIRQid);
+        if (!thisDev->isrQlevel)
+        {
+            enable_irq(thisDev->doneIRQid);
+            return;
+        }
+
+        /* Grab an IRQ event context, decrement queue level, and unmask */
+        thisEvent = &thisDev->t2isrQ[thisDev->isrQhead];
+        thisDev->isrQhead = (thisDev->isrQhead + 1) % ISRMSG_QUEUE_DEPTH;
+        thisDev->isrQlevel--;
+        enable_irq(thisDev->doneIRQid);
+
+#ifdef RM_DBG_EXTENDED_ERROR
+        printk("t23xrm:t23RMdeferredInterruptResponder() - new ISR event - done 0x%04x - error 0x%04x\n",
+                thisEvent->channelsDone, thisEvent->channelsInError);
+
+        if (thisEvent->channelsDone)
+            printk("channels done: ");
+        for (j = 0; j < thisDev->totalChannels; j++)
+            if (thisEvent->channelsDone & (INT_ACTIVE_CH0 << j))
+                printk("%d ", j + 1);
+        if (thisEvent->channelsDone)
+            printk("\n");
+
+        if (thisEvent->channelsInError)
+            printk("channels in error: ");
+        for (j = 0; j < thisDev->totalChannels; j++)
+            if (thisEvent->channelsInError & (INT_ACTIVE_CH0 << j))
+                printk("%d ", j + 1);
+        if (thisEvent->channelsInError)
+            printk("\n");
+#endif
+
+        /* For any "done" interrupt, go through all interrupting channels */
+        /* and invoke handlers as spec'ed in each message, then free the  */
+        /* channel if there is no static reservation                      */
+        if (thisEvent->channelsDone)
+            for (i = 0; i < thisDev->totalChannels; i++)
+                if (thisEvent->channelsDone & (INT_ACTIVE_CH0 << i))
+                {
+                    thisMsg = thisDev->channelActvMsg[i];
+                    /* error information is zeroed */
+                    thisMsg->errState[0] = 0;
+                    thisMsg->errState[1] = 0;
+                    thisMsg->errState[2] = 0;
+                    thisMsg->errState[3] = 0;
+                    thisMsg->errDesc     = NULL;
+
+                    if (thisMsg->descriptorDoneHandler != NULL)
+                        thisMsg->descriptorDoneHandler(0);
+
+                    thisMsg->messageReleaseHandler(thisMsg->releaseArgument);
+                    if (thisMsg->waitingTask != NULL)
+                        wake_up(thisMsg->waitingTask);
+
+                    free_channel(i);
+                }
+
+        /* For any "error" interrupt, go through all interrupting channels     */
+        /* capture the error status and a pointer to the error-ing descriptor, */
+        /* then go invoke handlers if they exist, and free the channel         */
+        if (thisEvent->channelsInError)
+            for (i = 0; i < thisDev->totalChannels; i++)
+                if (thisEvent->channelsInError & (INT_ACTIVE_CH0 << i))
+                {
+                    thisMsg = thisDev->channelActvMsg[i];
+                    /* write the CPSR/errdesc to exec message status */
+                    thisMsg->errState[0] = thisEvent->channelState[i];
+                    thisMsg->errState[1] = 0;
+                    thisMsg->errState[2] = thisEvent->priEUstate[i];
+                    thisMsg->errState[3] = thisEvent->secEUstate[i];
+
+                    errorDesc = (thisEvent->currentDesc[i] & 0x00000000ffffffffull);
+                    thisMsg->errDesc = (T2DPD *)errorDesc;
+
+                    if (thisMsg->descriptorErrorHandler != NULL)
+                        thisMsg->descriptorErrorHandler(0);
+
+                    thisMsg->messageReleaseHandler(thisMsg->releaseArgument);
+                    if (thisMsg->waitingTask != NULL)
+                        wake_up(thisMsg->waitingTask);
+
+                    free_channel(i);
+
+#ifdef RM_DBG_EXTENDED_ERROR
+                    printk("Extended error report for channel %d:\n", i + 1);
+
+                    printk("CPSR ");
+                    printk("get:0x%02llx ", (thisMsg->errState[0] & T3_CPSR_GET_STATE_MASK) >> T3_CPSR_GET_STATE_SHIFT);
+                    printk("put:0x%02llx ", (thisMsg->errState[0] & T3_CPSR_PUT_STATE_MASK) >> T3_CPSR_PUT_STATE_SHIFT);
+                    printk("main:0x%03llx ", (thisMsg->errState[0] & T3_CPSR_MAIN_STATE_MASK) >> T3_CPSR_MAIN_STATE_SHIFT);
+                    printk("ff_lvl:0x%02llx ", (thisMsg->errState[0] & T3_CPSR_FF_LEVEL_MASK) >> T3_CPSR_FF_LEVEL_SHIFT);
+                    if (thisMsg->errState[0] & T3_CPSR_PRD) printk("prd ");
+                    if (thisMsg->errState[0] & T3_CPSR_SRD) printk("srd ");
+                    if (thisMsg->errState[0] & T3_CPSR_PD)  printk("pd ");
+                    if (thisMsg->errState[0] & T3_CPSR_SD)  printk("sd ");
+                    printk("\n");
+
+                    printk("CPSR error bits: ");
+                    errbits = thisMsg->errState[0] & T2_CPSR_ERROR_MASK;
+                    if (errbits & T2_CHN_ERROR_DOF)            printk("DOF ");
+                    if (errbits & T2_CHN_ERROR_SOF)            printk("SOF ");
+                    if (errbits & T2_CHN_ERROR_MDTE)           printk("MDTE ");
+                    if (errbits & T2_CHN_ERROR_SG_ZERO_LEN)    printk("SGZERO ");
+                    if (errbits & T2_CHN_ERROR_FP_ZERO)        printk("FPZERO ");
+                    if (errbits & T2_CHN_ERROR_ILLEGAL_HEADER) printk("ILLHDR ");
+                    if (errbits & T2_CHN_ERROR_INVALID_EU)     printk("INVEU ");
+                    if (errbits & T2_CHN_ERROR_EU_ERROR)       printk("EUERR ");
+                    if (errbits & T2_CHN_ERROR_G_BOUNDARY)     printk("GBDRY ");
+                    if (errbits & T2_CHN_ERROR_G_LENGTH)       printk("GLEN ");
+                    if (errbits & T2_CHN_ERROR_S_BOUNDARY)     printk("SBDRY ");
+                    if (errbits & T2_CHN_ERROR_S_LENGTH)       printk("SLEN ");
+                    printk("\n");
+
+                    printk("fetched descriptor as read into channel:\n");
+                    printk("header: 0x%08x\n", thisEvent->fetchedDesc[i].dpd.hdr);
+                    for (j = 0; j < TOTAL_PAIRS; j++)
+                    {
+                        if (thisEvent->fetchedDesc[i].dpd.pair[j].eptr ||
+                            thisEvent->fetchedDesc[i].dpd.pair[j].ptr  ||
+                            thisEvent->fetchedDesc[i].dpd.pair[j].size ||
+                            thisEvent->fetchedDesc[i].dpd.pair[j].extent)
+                        {
+                            printk("pair %d: 0x%02x%08x: %5d (ext:%3d)",
+                                   j,
+                                   thisEvent->fetchedDesc[i].dpd.pair[j].eptr,
+                                   (u32)thisEvent->fetchedDesc[i].dpd.pair[j].ptr,
+                                   thisEvent->fetchedDesc[i].dpd.pair[j].size,
+                                   (thisEvent->fetchedDesc[i].dpd.pair[j].extent & EXTENT_MASK));
+                            if (thisEvent->fetchedDesc[i].dpd.pair[j].extent & JUMPTABLE)
+                                printk(", scattered\n");
+                            else
+                                printk("\n");
+                        }
+                    }
+
+                    for (j = 0; j < 4; j++)
+                    {
+                        if (thisEvent->fetchedDesc[i].glt[j].segLen    ||
+                            thisEvent->fetchedDesc[i].glt[j].chainCtrl ||
+                            thisEvent->fetchedDesc[i].glt[j].extAddr   ||
+                            thisEvent->fetchedDesc[i].glt[j].segAddr)
+                        {
+                            printk("gthr %d: 0x%02x%08x: %5d ",
+                            j,
+                            thisEvent->fetchedDesc[i].glt[j].extAddr,
+                            (u32)thisEvent->fetchedDesc[i].glt[j].segAddr,
+                            thisEvent->fetchedDesc[i].glt[j].segLen);
+
+                            if (thisEvent->fetchedDesc[i].glt[j].chainCtrl & LAST_ENTRY)
+                                printk("end ");
+                            if (thisEvent->fetchedDesc[i].glt[j].chainCtrl & NEXT_ENTRY)
+                                printk("next ");
+
+                            printk("\n");
+                        }
+                    }
+
+                    for (j = 0; j < 4; j++)
+                    {
+                        if (thisEvent->fetchedDesc[i].slt[j].segLen    ||
+                            thisEvent->fetchedDesc[i].slt[j].chainCtrl ||
+                            thisEvent->fetchedDesc[i].slt[j].extAddr   ||
+                            thisEvent->fetchedDesc[i].slt[j].segAddr)
+                        {
+                            printk("sctr %d: 0x%02x%08x: %5d ",
+                            j,
+                            thisEvent->fetchedDesc[i].slt[j].extAddr,
+                            (u32)thisEvent->fetchedDesc[i].slt[j].segAddr,
+                            thisEvent->fetchedDesc[i].slt[j].segLen);
+
+                            if (thisEvent->fetchedDesc[i].slt[j].chainCtrl & LAST_ENTRY)
+                                printk("end ");
+                            if (thisEvent->fetchedDesc[i].slt[j].chainCtrl & NEXT_ENTRY)
+                                printk("next ");
+
+                            printk("\n");
+                        }
+                    }
+
+                    printk("channel %d pri EU intstatus = 0x%016llx\n",
+                           i,
+                           thisEvent->priEUstate[i]);
+
+                    printk("channel %d sec EU intstatus = 0x%016llx\n",
+                           i,
+                           thisEvent->secEUstate[i]);
+#endif
+                }
+
+
+        /* Once we get down here, we should have some free channels */
+        /* If there's stuff on the exec queue, start as many        */
+        /* entries off the queue as possible                        */
+        spin_lock_irqsave(&thisDev->execQlock, irqflags);
+        if ((thisDev->execQlevel) &&
+            (thisDev->freeChannels))
+        {
+
+            /* OK, we have at least one in the request queue, and */
+            /* at least one free channel. Channel allocation and  */
+            /* the request queue are both locked. Based on this,  */
+            /* how many can we launch?                            */
+            if (thisDev->execQlevel < thisDev->freeChannels)
+                burstsize = thisDev->execQlevel;
+            else
+                burstsize = thisDev->freeChannels;
+
+            burst = burstsize;
+
+            /* loop through each possible message in this launch burst */
+            while (burstsize)
+            {
+                /* Don't know which channels are free, so find one */
+                for (channel = 0; channel < thisDev->totalChannels; channel++)
+                    if (thisDev->channelState[channel] == CHstateFree)
+                    {
+                        /* This one is free, reserve it */
+                        thisDev->freeChannels--;
+                        thisDev->channelState[channel] = CHstateBusy;
+                        break;
+                    }
+
+                /* Got an allocated channel. Pop one entry */
+                nextMsg = thisDev->execQ[thisDev->execQhead];
+                thisDev->execQhead =
+                    (thisDev->execQhead + 1) % EXEC_QUEUE_DEPTH;
+                thisDev->execQlevel--;
+
+                /* launch it */
+                if ((uint32_t)nextMsg <= 0x00001000)
+                    panic("t23xrm:t23RMdeferredInterruptResponder() new msg 0x%08x channel %d execQlevel %d head %d tail %d, isrQ %d, burst %d, pending 0x%04x\n",
+                          (uint32_t)nextMsg, channel, thisDev->execQlevel, thisDev->execQhead, thisDev->execQtail, thisDev->isrQlevel, burst, thisEvent->channelsDone);
+                rmStartDesc(thisDev, nextMsg, channel);
+
+                burstsize--;
+            }
+        }
+        spin_unlock_irqrestore(thisDev->execQlock, irqflags);
+
+    } while (thisDev->isrQlevel);
+}
diff --git a/drivers/crypto/t23x/t23xsec2/Makefile b/drivers/crypto/t23x/t23xsec2/Makefile
new file mode 100644
index 0000000..89f8d8a
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/Makefile
@@ -0,0 +1,10 @@
+#
+# 2.6 makefile for T2/3 SEC2.x legacy interface module
+#
+
+#EXTRA_CFLAGS += -DSEC2_DBG_INFO -DSEC2_DBG_EXTENDED_ERROR
+EXTRA_CFLAGS += -DSEC2_DBG_INFO
+
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X_SEC2) += t23xsec2.o
+
+t23xsec2-objs := t23xsec2core.o t2dpd.o sec2_sctrMap.o t23xsec2mod.o
diff --git a/drivers/crypto/t23x/t23xsec2/Sec2.h b/drivers/crypto/t23x/t23xsec2/Sec2.h
new file mode 100644
index 0000000..4d958d4
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/Sec2.h
@@ -0,0 +1,1934 @@
+
+/*
+ * Sec2.h
+ *
+ * Public-level interfaces for the SEC2.x legacy crypto interface
+ * Contains changes to interwork with the t23x extensible subsystem
+ * for Talitos 2/3
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - Add SNOW-3G support
+ *
+ */
+
+
+
+
+#ifndef SEC2_H
+#define SEC2_H
+
+
+
+/** @file
+ * Top-level driver include file for SEC2 security processor
+ *
+ *        - XWC prototype version
+ */
+
+
+#ifdef _cplusplus
+extern "C" {
+#endif
+
+
+
+
+    /* General types for the driver, if they don't exist elsewhere */
+
+#ifndef BOOLEAN
+#define BOOLEAN int
+#endif
+
+#ifndef TRUE
+#define TRUE (1)
+#endif
+#ifndef FALSE
+#define FALSE (0)
+#endif
+
+#ifndef offsetof
+#define offsetof(s,m)   (size_t)&(((s *)0)->m)
+#endif
+
+
+
+    /* IOCTL function code offsets */
+    /* Each defines an IOCTL request to be added to a system-defined offset */
+#define SEC2_PROC_REQ                (1)  /**< Process request        */
+#define SEC2_GET_STATUS              (2)  /**< Read delayed status    */
+#define SEC2_RESERVE_CHANNEL_STATIC  (4)  /**< Reserve any channel
+                                                for use               */
+#define SEC2_RELEASE_CHANNEL         (8)  /**< Release channel
+                                                from reserved use     */
+#define SEC2_MALLOC                  (13) /**< Allocate driver
+                                                storage block         */
+#define SEC2_FREE                    (14) /**< Free a driver
+                                                storage block         */
+#define SEC2_COPYFROM                (15) /**< Driver buffer
+                                                copy function         */
+#define SEC2_COPYTO                  (16) /**< Opposing buffer
+                                                copy function         */
+#define SEC2_INSTALL_AUX_HANDLER     (20) /**< Install aux handler
+                                                for channel           */
+#define SEC2_KBUF_MULTI_PUSH         (21) /**< Push multiple buffers
+                                                to kernel             */
+#define SEC2_KBUF_MULTI_PULL         (22) /**< Pull multiple buffers
+                                                from kernel           */
+#define SEC2_KBUF_MULTI_ALLOC        (23) /**< Allocate multiple
+                                                kernel buffers        */
+#define SEC2_KBUF_MULTI_FREE         (24) /**< Free multiple
+                                                kernel buffers        */
+#define SEC2_PROC_REQ_BLOCK          (25) /**< PROC_REQ with block          */
+
+/* 26-29 reserved for SEC2 request expansion */
+
+#define SEC2_PROC_REQ_VIRTUAL        (30) /**< PROC_REQ using virtual
+                                               buffers */
+
+#define SEC2_PROC_REQ_BLOCK_VIRTUAL  (31) /**< PROC_REQ_BLOCK using
+                                               virtual buffers */
+
+
+    /* Base IOCTL function index,                 */
+    /* assume 0 to 0x7ff reserved for the host OS */
+#define SEC2_IOCTL_INDEX             (0x800)
+
+    /* Computed IOCTL constants for use */
+#define IOCTL_PROC_REQ               (SEC2_IOCTL_INDEX + SEC2_PROC_REQ)
+#define IOCTL_GET_STATUS             (SEC2_IOCTL_INDEX + SEC2_GET_STATUS)
+#define IOCTL_RESERVE_CHANNEL_STATIC (SEC2_IOCTL_INDEX + SEC2_RESERVE_CHANNEL_STATIC)
+#define IOCTL_RELEASE_CHANNEL        (SEC2_IOCTL_INDEX + SEC2_RELEASE_CHANNEL)
+#define IOCTL_MALLOC                 (SEC2_IOCTL_INDEX + SEC2_MALLOC)
+#define IOCTL_FREE                   (SEC2_IOCTL_INDEX + SEC2_FREE)
+#define IOCTL_COPYFROM               (SEC2_IOCTL_INDEX + SEC2_COPYFROM)
+#define IOCTL_COPYTO                 (SEC2_IOCTL_INDEX + SEC2_COPYTO)
+#define IOCTL_INSTALL_AUX_HANDLER    (SEC2_IOCTL_INDEX + SEC2_INSTALL_AUX_HANDLER)
+#define IOCTL_KBUF_MULTI_PUSH        (SEC2_IOCTL_INDEX + SEC2_KBUF_MULTI_PUSH)
+#define IOCTL_KBUF_MULTI_PULL        (SEC2_IOCTL_INDEX + SEC2_KBUF_MULTI_PULL)
+#define IOCTL_KBUF_MULTI_ALLOC       (SEC2_IOCTL_INDEX + SEC2_KBUF_MULTI_ALLOC)
+#define IOCTL_KBUF_MULTI_FREE        (SEC2_IOCTL_INDEX + SEC2_KBUF_MULTI_FREE)
+#define IOCTL_PROC_REQ_BLOCK         (SEC2_IOCTL_INDEX + SEC2_PROC_REQ_BLOCK)
+
+#define IOCTL_PROC_REQ_VIRTUAL       (SEC2_IOCTL_INDEX + SEC2_PROC_REQ_VIRTUAL)
+#define IOCTL_PROC_REQ_BLOCK_VIRTUAL (SEC2_IOCTL_INDEX + SEC2_PROC_REQ_BLOCK_VIRTUAL)
+
+
+
+
+    /* General error/status codes for ioctl() function returns,       */
+    /* and for the status field of the general-purpose part of        */
+    /* the request struct                                             */
+
+    /* all OK                                               */
+#define SEC2_SUCCESS                          (0x00000000)
+
+    /* Driver memory allocation problem                     */
+#define SEC2_MEMORY_ALLOCATION                (0xE004FFFF)
+
+    /* Channel spec out-of-range.                           */
+#define SEC2_INVALID_CHANNEL                  (0xE004FFFE)
+
+    /* Requested cipher type not supported on               */
+    /* this hardware.                                       */
+#define SEC2_INVALID_CHA_TYPE                 (0xE004FFFD)
+
+    /* Operation type specified in the request              */
+    /* block does not exist                                 */
+#define SEC2_INVALID_OPERATION_ID             (0xE004FFFC)
+
+    /* Requested channel not available for use              */
+#define SEC2_CHANNEL_NOT_AVAILABLE            (0xE004FFFB)
+
+    /* Requested cipher type already in use by              */
+    /* some other request                                   */
+#define SEC2_CHA_NOT_AVAILABLE                (0xE004FFFA)
+
+    /* At least one data length in the request is invalid   */
+    /* This is likely an alignment issue                    */
+#define SEC2_INVALID_LENGTH                   (0xE004FFF9)
+
+    /* An address in the request struct is misaligned       */
+#define SEC2_OUTPUT_BUFFER_ALIGNMENT          (0xE004FFF8)
+
+    /* Driver has internal address translation err          */
+#define SEC2_ADDRESS_PROBLEM                  (0xE004FFF6)
+
+    /* Driver has run out of request entries                */
+#define SEC2_INSUFFICIENT_REQS                (0xE004FFF5)
+
+    /* An accelerator is in error state after a request     */
+#define SEC2_CHA_ERROR                        (0xE004FFF2)
+
+    /* Specified request was NULL                           */
+#define SEC2_NULL_REQUEST                     (0xE004FFF1)
+
+    /* Timeout during request execution                     */
+#define SEC2_REQUEST_TIMED_OUT                (0xE004FFF0)
+
+    /* Driver ran out of memory in the course of processing */
+#define SEC2_MALLOC_FAILED                    (0xE004FFEF)
+
+    /* Driver failed to free a block while processing       */
+#define SEC2_FREE_FAILED                      (0xE004FFEE)
+
+    /* Driver encountered a parity error in the input data  */
+#define SEC2_PARITY_SYSTEM_ERROR              (0xE004FFED)
+
+#define SEC2_INCOMPLETE_POINTER               (0xE004FFEC)
+#define SEC2_TEA_ERROR                        (0xE004FFEB)
+
+    /* While trying to build a scatter-gather fragment list */
+    /* for a specified request, the driver ran out of       */
+    /* entries to store into                                */
+#define SEC2_FRAGMENT_POOL_EXHAUSTED          (0xE004FFEA)
+
+    /* Driver attempted to stuff too many DPDs into the     */
+    /* fetch FIFO. This indicates an internal driver error  */
+#define SEC2_FETCH_FIFO_OVERFLOW              (0xE004FFE9)
+
+    /* Hardware failed while trying to acquire mastership   */
+    /* of the bus                                           */
+#define SEC2_BUS_MASTER_ERROR                 (0xE004FFE8)
+
+    /* While composing a scatter descriptor, the driver     */
+    /* encountered an error, most likely a bad pointer in   */
+    /* the specification list                               */
+#define SEC2_SCATTER_LIST_ERROR               (0xE004FFE7)
+
+    /* Driver encountered an unidentfiable condition        */
+#define SEC2_UNKNOWN_ERROR                    (0xE004FFE6)
+
+    /* Request invalid for usage mode                       */
+    /* Returned for blocking request from out of usermode   */
+#define SEC2_INVALID_REQUEST_MODE             (0xE004FFE5)
+
+    /* Unrecognized IOCTL code passed on request */
+#define SEC2_UNKNOWN_IOCTL_CODE               (0xE004FFE4)
+
+    /* Unimplemented request */
+#define SEC2_UNIMPLEMENTED                    (0xE004FFE3)
+
+
+
+    /* Security device not found at the specified location  */
+    /* This is a legacy error left over from earlier revs   */
+#define SEC2_IO_CARD_NOT_FOUND                     (-1000)
+
+    /* Driver can't allocate a buffer                       */
+#define SEC2_IO_MEMORY_ALLOCATE_ERROR              (-1001)
+
+    /* Driver has a problem with register I/O               */
+#define SEC2_IO_IO_ERROR                           (-1002)
+
+    /* System can't attach driver to the OS dispatch table  */
+#define SEC2_IO_VXWORKS_DRIVER_TABLE_ADD_ERROR     (-1003)
+
+    /* Driver can't use a needed interrupt ID               */
+#define SEC2_IO_INTERRUPT_ALLOCATE_ERROR           (-1004)
+
+    /* Driver can't use peripheral base region              */
+#define SEC2_CANNOT_SETUP_BAR0_ERROR               (-1008)
+
+    /* Driver can't initialize message queue                */
+#define SEC2_VXWORKS_CANNOT_CREATE_QUEUE           (-1009)
+
+    /* Request was cancelled by external means              */
+#define SEC2_CANCELLED_REQUEST                     (-1010)
+
+    /* User passed a null request pointer to IOCTL_PROC_REQ */
+#define SEC2_INVALID_ADDRESS                       (-1011)
+
+
+
+
+
+
+    /* Limit of geometry, for allocators */
+#define MAX_CHANNELS     (4)
+#define MAX_CHAS         (7)
+#define NUM_DPD_FLDS     (7)
+
+
+    /*
+     * STATUS_REQ
+     * structure used to indicate the state of the SEC2 as well as the
+     * river.  Returned as a pointer by GetStatus() and embedded in all
+     * requests.
+     */
+    typedef struct
+    {
+        unsigned long ChaAssignmentStatusRegister[2];
+        unsigned long InterruptControlRegister[2];
+        unsigned long InterruptStatusRegister[2];
+        unsigned long IdRegister;
+        unsigned long ChannelStatusRegister[MAX_CHANNELS][2];
+        unsigned long ChannelConfigurationRegister[MAX_CHANNELS][2];
+        unsigned long CHAInterruptStatusRegister[MAX_CHAS][2];
+        unsigned long QueueEntryDepth;
+        unsigned long FreeChannels;
+        unsigned long FreeRngas;
+        unsigned long FreeAfhas;
+        unsigned long FreeDesas;
+        unsigned long FreeMdhas;
+        unsigned long FreePkhas;
+        unsigned long FreeAesas;
+        unsigned long FreeKeas;
+        unsigned long BlockSize;
+    } STATUS_REQ;
+
+    typedef STATUS_REQ SEC2_STATUS;
+
+    typedef void* PSEC2_NOTIFY_CTX;
+
+    /*
+     * SEC2_NOTIFY_ON_ERROR_CTX
+     * structure used in all requests to indicate the nature of errors.
+     */
+    typedef struct
+    {
+        unsigned long errorcode; /**< Error the request generated     */
+        void *request;           /**< Pointer to original request block */
+        STATUS_REQ driverstatus; /**< Detailed device state block     */
+    } SEC2_NOTIFY_ON_ERROR_CTX, *PSEC2_NOTIFY_ON_ERROR_CTX;
+
+
+    typedef void (*PSEC2_NOTIFY_ROUTINE) (PSEC2_NOTIFY_CTX pCtx);
+    typedef void (*PSEC2_NOTIFY_ON_ERROR_ROUTINE) (PSEC2_NOTIFY_ON_ERROR_CTX pErrCtx);
+
+
+
+
+    /**
+     * AUX_HANDLER_SPEC
+     *
+     * Passed as the argument to SEC2_INSTALL_AUX_HANDLER, and is used
+     * to specify an auxiliary handler to be called via deferred service
+     * for a channel completion interrupt. Such a handler is called
+     * before the standard channel service
+     *
+     * It has two parts, a pointer to the handler requested (or NULL if
+     * an existing handler is to be disabled), and the channel that the
+     * handler is to be associated with (this channel must be reserved
+     * static to be used for this).
+     *
+     * Note that for Linux targets, this feature can not be used from
+     * a user-mode application.
+
+     */
+    typedef struct _aux_handler_spec
+    {
+        int  (*auxHandler)(int, void *);    /**< points to handler
+                                                routine specified   */
+        char   channel;                     /**< channel previously
+                                                reserved for use    */
+    } AUX_HANDLER_SPEC;
+
+
+    /**
+     * MALLOC_REQ
+     * structure used on allocation requests to the driver
+     *
+     *  Used by KernelMalloc()
+     *
+     *  Used also by the Dispatch function that calls
+     *  KernelMalloc() and KernelFree()
+     */
+    typedef struct
+    {
+        unsigned long   sz;     /**< Number of bytes to allocate
+                                 * Zero means to use the default.
+                                 * A value of zero can be used to
+                                 * avoid fragmentation.               */
+        void            *ptr;   /**< Pointer to the adress that is to
+                                 * be returned by a call to
+                                 * KernelMalloc() or a pointer to
+                                 * an address that is to
+                                 * be freed when calling KernelFree() */
+        char            *to;    /**< copy to                          */
+        char            *from;  /**< copy from                        */
+        int             pid;    /**< pid                              */
+    } MALLOC_REQ;
+
+
+
+    /**
+     * KBUF_MULTI
+     *
+     * Used to push/pull a set of data items from local (virtual) memory to
+     * contiguous kernel buffers. It contains 7 source/destination
+     * buffer pairs, one for each possible pair represented in a
+     * packet descriptor
+     *
+     * Each pair consists of:
+     *   local - address of local data buffer
+     *   kbuf  - address of kernel (contiguous) data buffer
+     *   size  - size of data for allocation or movement
+     *
+     * This block works with all multibuffer driver service calls:
+     *
+     * - IOCTL_KBUF_MULTI_PUSH
+     *   Move buffers from local memory to kernel buffers.
+     *   "local" is source, "kbuf" is destination, "size" in bytes
+     *   Any zero size, or pair with one null pointer is skipped
+     *
+     * - IOCTL_KBUF_MULTI_PULL
+     *   Move from kernel buffers to local memory
+     *   "local" is destination, "kbuf" is source, "size" in bytes
+     *   Any zero size, or pair with one null pointer is skipped
+     *
+     * - IOCTL_KBUF_MULTI_ALLOC
+     *   Alloc kernel buffers, "kbuf" gets filled with address of "size"
+     *   so long as size is nonzero. If any buffer is unavailable, will
+     *   return error (and no buffers are allocated)
+     *
+     * - IOCTL_KBUF_MULTI_FREE,  "kbuf" gets freed if non-NULL
+     *
+     */
+
+    typedef struct
+    {
+        unsigned char *local;  /**< Local ptr
+                                    (src for push, dest for pull)     */
+        unsigned char *kbuf;   /**< Kernel ptr
+                                    (dest for push, src for pull)     */
+        unsigned int   size;   /**< Size of buffer in bytes           */
+    } KBUF_ITEM;
+
+#define MAX_PAIRS (NUM_DPD_FLDS)
+
+    typedef struct
+    {
+        KBUF_ITEM pair[MAX_PAIRS];
+    } KBUF_MULTI;
+
+
+
+    /**
+     * Basic scatter/gather linked list form for general-purpose use
+     * This is used by the requestor to identify scatter buffer
+     * fragments to the driver for any pointer in a request. It's
+     * constructed in common NULL-terminated linked list form
+     */
+
+    typedef struct _sec2scatterFragment
+    {
+        void          *next;                  /**< next fragment in list
+                                                    NULL if none      */
+        void          *fragment;              /**< physical location
+                                                    of fragment       */
+        unsigned short size;                  /**< size of this
+                                                    fragment          */
+    } EXT_SCATTER_ELEMENT;
+
+
+
+
+/* Direct call into the driver's scatter/gather buffer marking function */
+int MarkScatterBuffer(void *request, void *buffer);
+
+
+
+#define RNG_GROUP       (0x1000)          /**< RNG Group              */
+#define DES_GROUP       (0x2000)          /**< Des Groups             */
+#define ARC4_GROUP      (0x3000)          /**< RC4 Groups             */
+#define MD_GROUP        (0x4000)          /**< MD Groups              */
+#define PK_GROUP        (0x5000)          /**< PK Groups              */
+#define AES_GROUP       (0x6000)          /**< AES Groups             */
+#define IPSEC_DES_GROUP (0x7000)          /**< ipsec Des + MD Groups  */
+#define IPSEC_AES_GROUP (0x8000)          /**< ipsec aes + md groups  */
+#define TLS_GROUP       (0x9000)          /**< SSL/TLS                */
+#define KEA_GROUP       (0xa000)          /**< Kasumi                 */
+#define CRC_GROUP       (0xb000)          /**< CRC Group              */
+#define SNOW_GROUP      (0xc000)          /**< SNOW-3G Group          */
+
+/* Extracts the request type from an OpId */
+#define DESC_TYPE_MASK (0xFF00)
+/* Extracts the request group from an OpId */
+#define DESC_NUM_MASK (0x00FF)
+
+
+
+
+/**
+ * Common request block for all request headers
+ * This macro contains the common portion of all request blocks
+ * It's composed as follows:
+ *   opId -            Type of operation requested
+ *   scatterBufs -     Map of scattered buffers, returned from MarkScatterBuffer()
+ *   notifyFlags -     if bits set, notify pointers are signal values to be
+ *                     sent upon request completion
+ *   channel -         Zero if auto-allocated, >= 1 if using static channel
+ *   notify -          Handler for normal completion. Signal value to use
+ *                     for completion if in usermode
+ *   pNotifyCtx -      Context for handler. Nothing for usermode.
+ *   notify_on_error - Handler for error completion. Signal value to use
+ *                     for error indication if in usermode
+ *   ctxNotifyOnErr -  returned device context if error. Nothing for usermode.
+ *   status -          Driver completion status
+ *   nextReq -         Next request in list, if any
+ */
+
+#define COMMON_REQ_PREAMBLE \
+    unsigned long                 opId; \
+    unsigned char                 scatterBufs; \
+    unsigned char                 notifyFlags; \
+    unsigned char                 reserved; \
+    unsigned char                 channel; \
+    PSEC2_NOTIFY_ROUTINE          notify; \
+    PSEC2_NOTIFY_CTX              pNotifyCtx; \
+    PSEC2_NOTIFY_ON_ERROR_ROUTINE notify_on_error; \
+    SEC2_NOTIFY_ON_ERROR_CTX      ctxNotifyOnErr; \
+    int                           status; \
+    void                         *nextReq;
+
+
+
+/**
+ * This gets used by driver functions that need access to
+ * just the request header without knowing the remaining
+ * request-type-specific content
+ */
+typedef struct { COMMON_REQ_PREAMBLE } GENERIC_REQ;
+
+
+/* Bits for use with notifyFlags in the request header                        */
+/* NOTIFY_IS_PID and NOTIFY_ERROR_IS_PID are no longer used in 2.0 and after, */
+/* NOTIFY_SIGNAL is used to tell an RTOS to use a signal if needed            */
+#define NOTIFY_SIGNAL       (0x04) /* notify/notify_on_error contain user-defined */
+                                   /* signal values for completion notification   */
+
+
+
+    /**
+     * RNG_REQ - Random-Number generator request block
+     * rngBytes - number of bytes to return
+     * rngData  - pointer to user's random data buffer
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  rngBytes;
+        unsigned char *rngData;
+    } RNG_REQ;
+
+#define NUM_RNGA_DESC (1)
+#define DPD_RNG_GROUP (RNG_GROUP | 0x0000)
+
+    /* Get random data from the RNG */
+#define DPD_RNG_GETRN (DPD_RNG_GROUP + 0)
+
+
+
+
+
+
+    /**
+     * DES_CBC_CRYPT_REQ - DES request with context load
+     * These are basically CBC (cipher-block-chain) operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  inIvBytes;   /**< 0 or 8 bytes                 */
+        unsigned char *inIvData;
+        unsigned long  keyBytes;    /**< 8, 16, or 24 bytes           */
+        unsigned char *keyData;
+        unsigned long  inBytes;     /**< multiple of 8 bytes          */
+        unsigned char *inData;
+        unsigned char *outData;     /**< output length = input length */
+        unsigned long  outIvBytes;  /**< 0 or 8 bytes                 */
+        unsigned char *outIvData;
+    } DES_CBC_CRYPT_REQ;
+
+    /* typedef the old name for legacy compatibility */
+    typedef DES_CBC_CRYPT_REQ DES_LOADCTX_CRYPT_REQ;
+
+#define NUM_DES_CBC_DESC         (12)
+#define DPD_DES_CBC_GROUP        (DES_GROUP | 0x0500)
+
+#define DPD_SDES_CBC_CTX_ENCRYPT    (DPD_DES_CBC_GROUP + 0)
+#define DPD_SDES_CBC_CTX_DECRYPT    (DPD_DES_CBC_GROUP + 1)
+#define DPD_TDES_CBC_CTX_ENCRYPT    (DPD_DES_CBC_GROUP + 2)
+#define DPD_TDES_CBC_CTX_DECRYPT    (DPD_DES_CBC_GROUP + 3)
+#define DPD_SDES_CFB_64_CTX_ENCRYPT (DPD_DES_CBC_GROUP + 4)
+#define DPD_SDES_CFB_64_CTX_DECRYPT (DPD_DES_CBC_GROUP + 5)
+#define DPD_TDES_CFB_64_CTX_ENCRYPT (DPD_DES_CBC_GROUP + 6)
+#define DPD_TDES_CFB_64_CTX_DECRYPT (DPD_DES_CBC_GROUP + 7)
+#define DPD_SDES_OFB_64_CTX_ENCRYPT (DPD_DES_CBC_GROUP + 8)
+#define DPD_SDES_OFB_64_CTX_DECRYPT (DPD_DES_CBC_GROUP + 9)
+#define DPD_TDES_OFB_64_CTX_ENCRYPT (DPD_DES_CBC_GROUP + 10)
+#define DPD_TDES_OFB_64_CTX_DECRYPT (DPD_DES_CBC_GROUP + 11)
+
+
+
+
+    /**
+     * DES_CRYPT_REQ - non-context DES cipher operation
+     * These are ECB-only operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;  /* 8, 16, or 24 bytes */
+        unsigned char *keyData;
+        unsigned long  inBytes;  /* multiple of 8 bytes */
+        unsigned char *inData;
+        unsigned char *outData;  /* output length = input length */
+    } DES_CRYPT_REQ;
+
+#define NUM_DES_DESC         (4)
+#define DPD_DES_ECB_GROUP    (DES_GROUP | 0x0600)
+
+#define DPD_SDES_ECB_ENCRYPT (DPD_DES_ECB_GROUP + 0)
+#define DPD_SDES_ECB_DECRYPT (DPD_DES_ECB_GROUP + 1)
+#define DPD_TDES_ECB_ENCRYPT (DPD_DES_ECB_GROUP + 2)
+#define DPD_TDES_ECB_DECRYPT (DPD_DES_ECB_GROUP + 3)
+
+
+
+
+    /*
+     * AESA_CRYPT_REQ - AES ciphering operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;     /**< 8, 16, or 24 bytes          */
+        unsigned char *keyData;
+        unsigned long  inIvBytes;    /**< 0 or 16 bytes               */
+        unsigned char *inIvData;
+        unsigned long  inBytes;      /**< multiple of 8 bytes         */
+        unsigned char *inData;
+        unsigned char *outData;      /**< output length = input length*/
+        unsigned long  outCtxBytes;  /**< 0 or 16 bytes               */
+        unsigned char *outCtxData;
+    } AESA_CRYPT_REQ;
+
+#define NUM_AESA_CRYPT_DESC            (23)
+#define DPD_AESA_CRYPT_GROUP           (AES_GROUP | 0x0000)
+
+#define DPD_AESA_CBC_ENCRYPT_CRYPT     (DPD_AESA_CRYPT_GROUP + 0)
+#define DPD_AESA_CBC_DECRYPT_CRYPT     (DPD_AESA_CRYPT_GROUP + 1)
+#define DPD_AESA_CBC_DECRYPT_CRYPT_RDK (DPD_AESA_CRYPT_GROUP + 2)
+#define DPD_AESA_ECB_ENCRYPT_CRYPT     (DPD_AESA_CRYPT_GROUP + 3)
+#define DPD_AESA_ECB_DECRYPT_CRYPT     (DPD_AESA_CRYPT_GROUP + 4)
+#define DPD_AESA_ECB_DECRYPT_CRYPT_RDK (DPD_AESA_CRYPT_GROUP + 5)
+#define DPD_AESA_CTR_CRYPT             (DPD_AESA_CRYPT_GROUP + 6)
+#define DPD_AESA_CTR_HMAC              (DPD_AESA_CRYPT_GROUP + 7)
+#define DPD_AESA_CBC_RBP_ENCRYPT       (DPD_AESA_CRYPT_GROUP + 8)
+#define DPD_AESA_CBC_RBP_DECRYPT       (DPD_AESA_CRYPT_GROUP + 9)
+#define DPD_AESA_OFB_ENCRYPT           (DPD_AESA_CRYPT_GROUP + 10)
+#define DPD_AESA_OFB_DECRYPT           (DPD_AESA_CRYPT_GROUP + 11)
+#define DPD_AESA_CFB128_ENCRYPT        (DPD_AESA_CRYPT_GROUP + 12)
+#define DPD_AESA_CFB128_DECRYPT        (DPD_AESA_CRYPT_GROUP + 13)
+#define DPD_AESA_CCM_ENCRYPT           (DPD_AESA_CRYPT_GROUP + 14)
+#define DPD_AESA_CCM_DECRYPT           (DPD_AESA_CRYPT_GROUP + 15)
+#define DPD_AESA_CCM_FINAL_ENCRYPT     (DPD_AESA_CRYPT_GROUP + 16)
+#define DPD_AESA_CCM_FINAL_DECRYPT     (DPD_AESA_CRYPT_GROUP + 17)
+#define DPD_AESA_CCM_FINAL_DECRYPT_CMP (DPD_AESA_CRYPT_GROUP + 18)
+#define DPD_AESA_LRW_ENCRYPT           (DPD_AESA_CRYPT_GROUP + 19)
+#define DPD_AESA_LRW_NO_TWEAK_ENCRYPT  (DPD_AESA_CRYPT_GROUP + 20)
+#define DPD_AESA_LRW_DECRYPT           (DPD_AESA_CRYPT_GROUP + 21)
+#define DPD_AESA_LRW_NO_TWEAK_DECRYPT  (DPD_AESA_CRYPT_GROUP + 22)
+
+
+
+
+    /**
+     * RAID_XOR_REQ - specialty AESA XOR operations
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned char *inDataA;  /**< input block A */
+        unsigned char *inDataB;  /**< input block B */
+        unsigned char *inDataC;  /**< input block C */
+        unsigned char *inDataD;  /**< input block D */
+        unsigned char *inDataE;  /**< input block E */
+        unsigned char *inDataF;  /**< input block F */
+        unsigned char *outData;  /**< output buffer */
+        unsigned long  opSize;   /**< size to process */
+    } RAID_XOR_REQ;
+
+#define NUM_RAID_XOR_DESC              (1)
+#define DPD_RAID_XOR_GROUP             (AES_GROUP | 0x0200)
+
+#define DPD_RAID_XOR                   (DPD_RAID_XOR_GROUP + 0)
+
+
+
+
+/*
+ * AESA_MAC_REQ - AES authenticity operations
+ */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  inCtxBytes;
+        unsigned char *inCtxData;
+        unsigned long  outCtxBytes;
+        unsigned char *outCtxData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  cmpBytes;
+        unsigned char *cmpIn;        /* ICV compare */
+        unsigned char *cmpOut;       /* Digest out */
+    } AESA_MAC_REQ;
+
+#define NUM_AESA_MAC_DESC              (4)
+#define DPD_AESA_MAC_GROUP             (AES_GROUP | 0x0100)
+
+#define DPD_AESA_CMAC                  (DPD_AESA_MAC_GROUP + 0)
+#define DPD_AESA_CMAC_CMP              (DPD_AESA_MAC_GROUP + 1)
+#define DPD_AESA_XCBCMAC               (DPD_AESA_MAC_GROUP + 2)
+#define DPD_AESA_XCBCMAC_CMP           (DPD_AESA_MAC_GROUP + 3)
+
+
+
+
+/*
+ * AESA_GCM_REQ
+ */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  gcmCtxBytes;
+        unsigned char *gcmCtxData;
+        unsigned long  AADBytes;
+        unsigned char *AAD;
+        unsigned char  ivBytes;
+        unsigned char *ivIn;
+        unsigned char *ivOut;
+        unsigned long  keyBytes;
+        unsigned long  saltBytes;
+        unsigned char *keyData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  cmpBytes;
+        unsigned long  outBytes;
+        unsigned char *outData;
+        unsigned long  crcBytes;
+    } AESA_GCM_REQ;
+
+#define NUM_AESA_GCM_DESC              (5)
+#define DPD_AESA_GCM_GROUP             (AES_GROUP | 0x0300)
+
+#define DPD_AESA_GCM_ENCRYPT           (DPD_AESA_GCM_GROUP + 0)
+#define DPD_AESA_GCM_DECRYPT           (DPD_AESA_GCM_GROUP + 1)
+#define DPD_AESA_GCM_FINAL_ENCRYPT     (DPD_AESA_GCM_GROUP + 2)
+#define DPD_AESA_GCM_FINAL_DECRYPT     (DPD_AESA_GCM_GROUP + 3)
+#define DPD_AESA_GCM_FINAL_DECRYPT_CMP (DPD_AESA_GCM_GROUP + 4)
+
+
+
+
+
+    /**
+     * KEA_CRYPT_REQ - Kasumi cipher operations
+     * Not present in 2.0
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  ivBytes;
+        unsigned char *ivData;
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  inBytes;    /**< multiple of 8 bytes          */
+        unsigned char *inData;
+        unsigned long  outBytes;   /**< must be zero if f9 only      */
+        unsigned char *outData;    /**< output length = input length */
+        /** if f9_CMP, this becomes compare value */
+        unsigned long  outIvBytes;
+        unsigned char *outIvData;
+        unsigned long  ctxBytes;
+        unsigned char *ctxData;    /**< f9 integrity digest/context  */
+    } KEA_CRYPT_REQ;
+
+#define NUM_KEA_CRYPT_DESC                     (10)
+#define DPD_KEA_CRYPT_GROUP                    (KEA_GROUP | 0x0000)
+
+    /* Kasumi request types */
+#define DPD_KEA_f8_CIPHER_INIT                 (DPD_KEA_CRYPT_GROUP + 0)
+#define DPD_KEA_f8_CIPHER                      (DPD_KEA_CRYPT_GROUP + 1)
+#define DPD_KEA_f9_CIPHER_INIT                 (DPD_KEA_CRYPT_GROUP + 2)
+#define DPD_KEA_f9_CIPHER                      (DPD_KEA_CRYPT_GROUP + 3)
+#define DPD_KEA_f9_CIPHER_FINAL                (DPD_KEA_CRYPT_GROUP + 4)
+#define DPD_KEA_f9_CIPHER_INIT_FINAL           (DPD_KEA_CRYPT_GROUP + 5)
+#define DPD_KEA_GSM_A53_CIPHER                 (DPD_KEA_CRYPT_GROUP + 6)
+#define DPD_KEA_EDGE_A53_CIPHER                (DPD_KEA_CRYPT_GROUP + 7)
+#define DPD_KEA_f9_CIPHER_FINAL_CMP            (DPD_KEA_CRYPT_GROUP + 8)
+#define DPD_KEA_f9_CIPHER_INIT_FINAL_CMP       (DPD_KEA_CRYPT_GROUP + 9)
+
+
+
+    /**
+     * SNOW3G_CRYPT_REQ - SNOW for 3G cipher operations
+     * Present >= 3.1
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  ivBytes;    /**< Combination bearer/count/dir */
+        unsigned char *ivData;
+        unsigned long  keyBytes;   /**< always 16 for UEA2/UIA2 */
+        unsigned char *keyData;
+        unsigned long  inBytes;    /**< multiple of 8 bytes          */
+        unsigned char *inData;
+        unsigned long  outBytes;   /**< zero for UIA2 only      */
+        unsigned char *outData;    /**< output length = input length */
+        unsigned long  outIvBytes;
+        unsigned char *outIvData;
+        unsigned long  ctxBytes;   /**< = 8 for UIA2, lower 4 bytes */
+        unsigned char *ctxData;    /**< UIA2 integrity digest/context  */
+    } SNOW3G_CRYPT_REQ;
+
+#define NUM_SNOW3G_CRYPT_DESC                  (8)
+#define DPD_SNOW3G_CRYPT_GROUP                 (SNOW_GROUP | 0x0000)
+
+#define DPD_SNOW3G_UEA2_INIT                   (DPD_SNOW3G_CRYPT_GROUP + 0)
+#define DPD_SNOW3G_UEA2                        (DPD_SNOW3G_CRYPT_GROUP + 1)
+#define DPD_SNOW3G_UIA2_INIT                   (DPD_SNOW3G_CRYPT_GROUP + 2)
+#define DPD_SNOW3G_UIA2                        (DPD_SNOW3G_CRYPT_GROUP + 3)
+#define DPD_SNOW3G_UIA2_FINAL                  (DPD_SNOW3G_CRYPT_GROUP + 4)
+#define DPD_SNOW3G_UIA2_INIT_FINAL             (DPD_SNOW3G_CRYPT_GROUP + 5)
+#define DPD_SNOW3G_UIA2_FINAL_CMP              (DPD_SNOW3G_CRYPT_GROUP + 8)
+#define DPD_SNOW3G_UIA2_INIT_FINAL_CMP         (DPD_SNOW3G_CRYPT_GROUP + 9)
+
+
+
+    /**
+     * ARC4_LOADCTX_CRYPT_REQ - ARC4 cipher operation with context load
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  inCtxBytes;  /**< 257 bytes */
+        unsigned char *inCtxData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned char *outData;         /**< output length = input length */
+        unsigned long  outCtxBytes;     /**< 257 bytes */
+        unsigned char *outCtxData;
+    } ARC4_LOADCTX_CRYPT_REQ;
+
+#define NUM_RC4_LOADCTX_UNLOADCTX_DESC  (1)
+#define DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP (ARC4_GROUP | 0x0400)
+
+#define DPD_RC4_LDCTX_CRYPT_ULCTX       (DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP + 0)
+
+
+
+
+    /**
+     * ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ - ARC4 operation with key load
+     *                                    and context save
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned char *outData;  /* output length = input length */
+        unsigned long  outCtxBytes;  /* 257 bytes */
+        unsigned char *outCtxData;
+    } ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ;
+
+#define NUM_RC4_LOADKEY_UNLOADCTX_DESC  (1)
+#define DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP (ARC4_GROUP | 0x0500)
+
+#define DPD_RC4_LDKEY_CRYPT_ULCTX       (DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP + 0)
+
+
+
+
+    /**
+     * HASH_REQ - combined SHA/MD5 hash operations with context loads
+     *            and saves
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  ctxBytes;
+        unsigned char *ctxData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  outBytes;  /**< length is fixed by algorithm   */
+        unsigned char *outData;
+        unsigned char *cmpData;   /**< digest compare value,
+                                        same len as outData           */
+    } HASH_REQ;
+
+
+#define NUM_MDHA_DESC                        (30)
+#define DPD_HASH_LDCTX_HASH_ULCTX_GROUP      (MD_GROUP | 0x0400)
+
+#define DPD_SHA256_LDCTX_HASH_ULCTX          (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 0)
+#define DPD_MD5_LDCTX_HASH_ULCTX             (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 1)
+#define DPD_SHA_LDCTX_HASH_ULCTX             (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 2)
+#define DPD_SHA256_LDCTX_IDGS_HASH_ULCTX     (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 3)
+#define DPD_MD5_LDCTX_IDGS_HASH_ULCTX        (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 4)
+#define DPD_SHA_LDCTX_IDGS_HASH_ULCTX        (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 5)
+#define DPD_SHA256_CONT_HASH_ULCTX           (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 6)
+#define DPD_MD5_CONT_HASH_ULCTX              (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 7)
+#define DPD_SHA_CONT_HASH_ULCTX              (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 8)
+#define DPD_SHA224_LDCTX_HASH_ULCTX          (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 9)
+#define DPD_SHA224_LDCTX_IDGS_HASH_ULCTX     (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 10)
+#define DPD_SHA224_CONT_HASH_ULCTX           (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 12)
+#define DPD_SHA256_LDCTX_HASH_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 13)
+#define DPD_MD5_LDCTX_HASH_ULCTX_CMP         (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 14)
+#define DPD_SHA_LDCTX_HASH_ULCTX_CMP         (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 15)
+#define DPD_SHA256_LDCTX_IDGS_HASH_ULCTX_CMP (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 16)
+#define DPD_MD5_LDCTX_IDGS_HASH_ULCTX_CMP    (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 17)
+#define DPD_SHA_LDCTX_IDGS_HASH_ULCTX_CMP    (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 18)
+#define DPD_SHA224_LDCTX_HASH_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 19)
+#define DPD_SHA224_LDCTX_IDGS_HASH_ULCTX_CMP (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 20)
+#define DPD_SHA384_LDCTX_HASH_ULCTX          (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 21)
+#define DPD_SHA384_LDCTX_IDGS_HASH_ULCTX     (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 22)
+#define DPD_SHA384_CONT_HASH_ULCTX           (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 23)
+#define DPD_SHA384_LDCTX_HASH_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 24)
+#define DPD_SHA384_LDCTX_IDGS_HASH_ULCTX_CMP (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 25)
+#define DPD_SHA512_LDCTX_HASH_ULCTX          (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 26)
+#define DPD_SHA512_LDCTX_IDGS_HASH_ULCTX     (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 27)
+#define DPD_SHA512_CONT_HASH_ULCTX           (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 28)
+#define DPD_SHA512_LDCTX_HASH_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 29)
+#define DPD_SHA512_LDCTX_IDGS_HASH_ULCTX_CMP (DPD_HASH_LDCTX_HASH_ULCTX_GROUP + 30)
+
+
+
+
+#define NUM_MDHA_PAD_DESC                        (24)
+#define DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP      (MD_GROUP | 0x0500)
+
+#define DPD_SHA256_LDCTX_HASH_PAD_ULCTX          (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 0)
+#define DPD_MD5_LDCTX_HASH_PAD_ULCTX             (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 1)
+#define DPD_SHA_LDCTX_HASH_PAD_ULCTX             (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 2)
+#define DPD_SHA256_LDCTX_IDGS_HASH_PAD_ULCTX     (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 3)
+#define DPD_MD5_LDCTX_IDGS_HASH_PAD_ULCTX        (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 4)
+#define DPD_SHA_LDCTX_IDGS_HASH_PAD_ULCTX        (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 5)
+#define DPD_SHA224_LDCTX_HASH_PAD_ULCTX          (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 6)
+#define DPD_SHA224_LDCTX_IDGS_HASH_PAD_ULCTX     (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 7)
+#define DPD_SHA256_LDCTX_HASH_PAD_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 8)
+#define DPD_MD5_LDCTX_HASH_PAD_ULCTX_CMP         (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 9)
+#define DPD_SHA_LDCTX_HASH_PAD_ULCTX_CMP         (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 10)
+#define DPD_SHA256_LDCTX_IDGS_HASH_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 11)
+#define DPD_MD5_LDCTX_IDGS_HASH_PAD_ULCTX_CMP    (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 12)
+#define DPD_SHA_LDCTX_IDGS_HASH_PAD_ULCTX_CMP    (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 13)
+#define DPD_SHA224_LDCTX_HASH_PAD_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 14)
+#define DPD_SHA224_LDCTX_IDGS_HASH_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 15)
+#define DPD_SHA384_LDCTX_HASH_PAD_ULCTX          (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 16)
+#define DPD_SHA384_LDCTX_IDGS_HASH_PAD_ULCTX     (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 17)
+#define DPD_SHA384_LDCTX_HASH_PAD_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 18)
+#define DPD_SHA384_LDCTX_IDGS_HASH_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 19)
+#define DPD_SHA512_LDCTX_HASH_PAD_ULCTX          (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 20)
+#define DPD_SHA512_LDCTX_IDGS_HASH_PAD_ULCTX     (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 21)
+#define DPD_SHA512_LDCTX_HASH_PAD_ULCTX_CMP      (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 22)
+#define DPD_SHA512_LDCTX_IDGS_HASH_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP + 23)
+
+
+
+    /**
+     * HMAC_PAD_REQ - Hash-message authentication code
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  outBytes;  /**< length is fixed by algorithm   */
+        unsigned char *outData;
+        unsigned char *cmpData;   /**< digest compare value,
+                                        same len as outData           */
+    } HMAC_PAD_REQ;
+
+#define NUM_HMAC_PAD_DESC                   (24)
+#define DPD_HASH_LDCTX_HMAC_ULCTX_GROUP     (MD_GROUP | 0x0A00)
+
+#define DPD_SHA256_LDCTX_HMAC_ULCTX         (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 0)
+#define DPD_MD5_LDCTX_HMAC_ULCTX            (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 1)
+#define DPD_SHA_LDCTX_HMAC_ULCTX            (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 2)
+#define DPD_SHA256_LDCTX_HMAC_PAD_ULCTX     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 3)
+#define DPD_MD5_LDCTX_HMAC_PAD_ULCTX        (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 4)
+#define DPD_SHA_LDCTX_HMAC_PAD_ULCTX        (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 5)
+#define DPD_SHA224_LDCTX_HMAC_ULCTX         (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 6)
+#define DPD_SHA224_LDCTX_HMAC_PAD_ULCTX     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 7)
+#define DPD_SHA256_LDCTX_HMAC_ULCTX_CMP     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 8)
+#define DPD_MD5_LDCTX_HMAC_ULCTX_CMP        (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 9)
+#define DPD_SHA_LDCTX_HMAC_ULCTX_CMP        (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 10)
+#define DPD_SHA256_LDCTX_HMAC_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 11)
+#define DPD_MD5_LDCTX_HMAC_PAD_ULCTX_CMP    (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 12)
+#define DPD_SHA_LDCTX_HMAC_PAD_ULCTX_CMP    (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 13)
+#define DPD_SHA224_LDCTX_HMAC_ULCTX_CMP     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 14)
+#define DPD_SHA224_LDCTX_HMAC_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 15)
+#define DPD_SHA384_LDCTX_HMAC_ULCTX         (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 16)
+#define DPD_SHA384_LDCTX_HMAC_PAD_ULCTX     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 17)
+#define DPD_SHA384_LDCTX_HMAC_ULCTX_CMP     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 18)
+#define DPD_SHA384_LDCTX_HMAC_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 19)
+#define DPD_SHA512_LDCTX_HMAC_ULCTX         (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 20)
+#define DPD_SHA512_LDCTX_HMAC_PAD_ULCTX     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 21)
+#define DPD_SHA512_LDCTX_HMAC_ULCTX_CMP     (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 22)
+#define DPD_SHA512_LDCTX_HMAC_PAD_ULCTX_CMP (DPD_HASH_LDCTX_HMAC_ULCTX_GROUP + 23)
+
+
+
+    /**
+     * MOD_EXP_REQ - integer public key (modular expo) operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  aDataBytes;
+        unsigned char *aData;
+        unsigned long  expBytes;
+        unsigned char *expData;
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } MOD_EXP_REQ;
+
+#define NUM_MM_EXP_DESC                  (2)
+#define DPD_MM_LDCTX_EXP_ULCTX_GROUP     (PK_GROUP | 0x0100)
+
+#define DPD_MM_LDCTX_EXP_ULCTX           (DPD_MM_LDCTX_EXP_ULCTX_GROUP + 0)
+#define DPD_MM_LDCTX_EXP_TEQ_ULCTX       (DPD_MM_LDCTX_EXP_ULCTX_GROUP + 1)
+
+
+
+    /**
+     * MOD_SS_EXP_REQ - single-stage RSA operations
+     *
+     */
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  expBytes;
+        unsigned char *expData;
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  aDataBytes;
+        unsigned char *aData;
+        unsigned long  bDataBytes;
+        unsigned char *bData;
+    } MOD_SS_EXP_REQ;
+
+#define NUM_MM_SS_EXP_DESC      (2)
+#define DPD_MM_SS_EXP_GROUP     (PK_GROUP | 0x0b00)
+
+#define DPD_MM_SS_RSA_EXP       (DPD_MM_SS_EXP_GROUP + 0)
+#define DPD_MM_SS_RSA_TEQ_EXP   (DPD_MM_SS_EXP_GROUP + 1)
+
+
+
+    /**
+     * MOD_R2MODN_REQ - Modular R2 operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } MOD_R2MODN_REQ;
+
+#define NUM_MOD_R2MODN_DESC             (2)
+#define DPD_MM_LDCTX_R2MODN_ULCTX_GROUP (PK_GROUP | 0x0200)
+
+#define DPD_MM_LDCTX_R2MODN_ULCTX       (DPD_MM_LDCTX_R2MODN_ULCTX_GROUP + 0)
+#define DPD_F2M_R2                      (DPD_MM_LDCTX_R2MODN_ULCTX_GROUP + 1)
+
+
+
+
+    /**
+     * MOD_RRMODP_REQ - montgomery precomputation operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  nBytes;
+        unsigned long  pBytes;
+        unsigned char *pData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } MOD_RRMODP_REQ;
+
+#define NUM_MM_RRMODP_DESC              (1)
+#define DPD_MM_LDCTX_RRMODP_ULCTX_GROUP (PK_GROUP | 0x0300)
+
+#define DPD_MM_LDCTX_RRMODP_ULCTX       (DPD_MM_LDCTX_RRMODP_ULCTX_GROUP + 0)
+
+
+
+
+    /**
+     * MOD_INV_REQ - Modular Inversion
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  nBytes;
+        unsigned char *nData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } MOD_INV_REQ;
+
+#define NUM_MM_MOD_INV_DESC        (1)
+#define DPD_MM_MOD_INV_ULCTX_GROUP (PK_GROUP | 0x0500)
+
+#define DPD_MM_MOD_INV_ULCTX       (DPD_MM_MOD_INV_ULCTX_GROUP + 0)
+
+
+
+    /**
+     * MOD_2OP_REQ
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  bDataBytes;
+        unsigned char *bData;
+        unsigned long  aDataBytes;
+        unsigned char *aData;
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } MOD_2OP_REQ;
+
+#define NUM_MOD_2OP_DESC              (52)
+#define DPD_MOD_LDCTX_2OP_ULCTX_GROUP (PK_GROUP | 0x0400)
+
+#define DPD_MOD_LDCTX_MUL1_ULCTX      (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 0)
+#define DPD_MOD_LDCTX_MUL2_ULCTX      (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 1)
+#define DPD_MOD_LDCTX_ADD_ULCTX       (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 2)
+#define DPD_MOD_LDCTX_SUB_ULCTX       (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 3)
+
+    /* equivalents for obsolete names */
+#define DPD_MM_LDCTX_MUL1_ULCTX DPD_MOD_LDCTX_MUL1_ULCTX
+#define DPD_MM_LDCTX_MUL2_ULCTX DPD_MOD_LDCTX_MUL2_ULCTX
+#define DPD_MM_LDCTX_ADD_ULCTX  DPD_MOD_LDCTX_ADD_ULCTX
+#define DPD_MM_LDCTX_SUB_ULCTX  DPD_MOD_LDCTX_SUB_ULCTX
+
+    /* These constants will likely be removed in a future release in favor */
+    /* of a different internal register allocation scheme                  */
+#define DPD_POLY_LDCTX_A0_B0_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 4)
+#define DPD_POLY_LDCTX_A0_B0_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 5)
+#define DPD_POLY_LDCTX_A0_B0_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 6)
+#define DPD_POLY_LDCTX_A1_B0_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 7)
+#define DPD_POLY_LDCTX_A1_B0_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 8)
+#define DPD_POLY_LDCTX_A1_B0_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 9)
+#define DPD_POLY_LDCTX_A2_B0_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 10)
+#define DPD_POLY_LDCTX_A2_B0_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 11)
+#define DPD_POLY_LDCTX_A2_B0_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 12)
+#define DPD_POLY_LDCTX_A3_B0_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 13)
+#define DPD_POLY_LDCTX_A3_B0_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 14)
+#define DPD_POLY_LDCTX_A3_B0_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 15)
+#define DPD_POLY_LDCTX_A0_B1_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 16)
+#define DPD_POLY_LDCTX_A0_B1_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 17)
+#define DPD_POLY_LDCTX_A0_B1_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 18)
+#define DPD_POLY_LDCTX_A1_B1_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 19)
+#define DPD_POLY_LDCTX_A1_B1_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 20)
+#define DPD_POLY_LDCTX_A1_B1_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 21)
+#define DPD_POLY_LDCTX_A2_B1_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 22)
+#define DPD_POLY_LDCTX_A2_B1_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 23)
+#define DPD_POLY_LDCTX_A2_B1_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 24)
+#define DPD_POLY_LDCTX_A3_B1_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 25)
+#define DPD_POLY_LDCTX_A3_B1_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 26)
+#define DPD_POLY_LDCTX_A3_B1_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 27)
+#define DPD_POLY_LDCTX_A0_B2_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 28)
+#define DPD_POLY_LDCTX_A0_B2_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 29)
+#define DPD_POLY_LDCTX_A0_B2_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 30)
+#define DPD_POLY_LDCTX_A1_B2_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 31)
+#define DPD_POLY_LDCTX_A1_B2_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 32)
+#define DPD_POLY_LDCTX_A1_B2_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 33)
+#define DPD_POLY_LDCTX_A2_B2_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 34)
+#define DPD_POLY_LDCTX_A2_B2_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 35)
+#define DPD_POLY_LDCTX_A2_B2_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 36)
+#define DPD_POLY_LDCTX_A3_B2_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 37)
+#define DPD_POLY_LDCTX_A3_B2_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 38)
+#define DPD_POLY_LDCTX_A3_B2_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 39)
+#define DPD_POLY_LDCTX_A0_B3_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 40)
+#define DPD_POLY_LDCTX_A0_B3_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 41)
+#define DPD_POLY_LDCTX_A0_B3_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 42)
+#define DPD_POLY_LDCTX_A1_B3_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 43)
+#define DPD_POLY_LDCTX_A1_B3_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 44)
+#define DPD_POLY_LDCTX_A1_B3_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 45)
+#define DPD_POLY_LDCTX_A2_B3_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 46)
+#define DPD_POLY_LDCTX_A2_B3_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 47)
+#define DPD_POLY_LDCTX_A2_B3_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 48)
+#define DPD_POLY_LDCTX_A3_B3_MUL1_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 49)
+#define DPD_POLY_LDCTX_A3_B3_MUL2_ULCTX (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 50)
+#define DPD_POLY_LDCTX_A3_B3_ADD_ULCTX  (DPD_MOD_LDCTX_2OP_ULCTX_GROUP + 51)
+
+
+
+
+
+    /**
+     * ECC_POINT_REQ - elliptic curve point processing
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  nDataBytes;
+        unsigned char *nData;
+        unsigned long  eDataBytes;
+        unsigned char *eData;
+        unsigned long  buildDataBytes;
+        unsigned char *buildData;
+        unsigned long  b1DataBytes;
+        unsigned char *b1Data;
+        unsigned long  b2DataBytes;
+        unsigned char *b2Data;
+        unsigned long  b3DataBytes;
+        unsigned char *b3Data;
+    } ECC_POINT_REQ;
+
+#define NUM_EC_POINT_DESC              (8)
+#define DPD_EC_LDCTX_kP_ULCTX_GROUP    (PK_GROUP | 0x0800)
+
+#define DPD_EC_FP_AFF_PT_MULT          (DPD_EC_LDCTX_kP_ULCTX_GROUP + 0)
+#define DPD_EC_FP_PROJ_PT_MULT         (DPD_EC_LDCTX_kP_ULCTX_GROUP + 1)
+#define DPD_EC_F2M_AFF_PT_MULT         (DPD_EC_LDCTX_kP_ULCTX_GROUP + 2)
+#define DPD_EC_F2M_PROJ_PT_MULT        (DPD_EC_LDCTX_kP_ULCTX_GROUP + 3)
+#define DPD_EC_FP_LDCTX_ADD_ULCTX      (DPD_EC_LDCTX_kP_ULCTX_GROUP + 4)
+#define DPD_EC_FP_LDCTX_DOUBLE_ULCTX   (DPD_EC_LDCTX_kP_ULCTX_GROUP + 5)
+#define DPD_EC_F2M_LDCTX_ADD_ULCTX     (DPD_EC_LDCTX_kP_ULCTX_GROUP + 6)
+#define DPD_EC_F2M_LDCTX_DOUBLE_ULCTX  (DPD_EC_LDCTX_kP_ULCTX_GROUP + 7)
+
+    /* legacy name definitions */
+#define DPD_EC_FP_AFF_LDCTX_kP_ULCTX   DPD_EC_FP_AFF_PT_MULT
+#define DPD_EC_FP_PROJ_LDCTX_kP_ULCTX  DPD_EC_FP_PROJ_PT_MULT
+#define DPD_EC_F2M_AFF_LDCTX_kP_ULCTX  DPD_EC_F2M_AFF_PT_MULT
+#define DPD_EC_F2M_PROJ_LDCTX_kP_ULCTX DPD_EC_F2M_PROJ_PT_MULT
+
+
+
+    /**
+     * F2M_INV_REQ - Binary Inversion
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  nBytes;
+        unsigned char *nData;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } F2M_INV_REQ;
+
+#define NUM_F2M_INV_DESC        (1)
+#define DPD_F2M_INV_ULCTX_GROUP (PK_GROUP | 0x0600)
+
+#define DPD_F2M_INV_ULCTX       (DPD_F2M_INV_ULCTX_GROUP + 0)
+
+
+
+
+    /**
+     * ECC_2OP_REQ - F2M elliptic curve operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  bDataBytes;
+        unsigned char *bData;
+        unsigned long  aDataBytes;
+        unsigned char *aData;
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  outBytes;
+        unsigned char *outData;
+    } ECC_2OP_REQ;
+
+#define NUM_EC_2OP_DESC             (3)
+#define DPD_EC_2OP_GROUP            (PK_GROUP | 0x0900)
+
+#define DPD_F2M_LDCTX_MUL1_ULCTX    (DPD_EC_2OP_GROUP + 0)
+#define DPD_F2M_LDCTX_MUL2_ULCTX    (DPD_EC_2OP_GROUP + 1)
+#define DPD_F2M_LDCTX_ADD_ULCTX     (DPD_EC_2OP_GROUP + 2)
+
+
+
+    /**
+     * ECC_SPKBUILD_REQ - elliptic curve request builder
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  a0DataBytes;
+        unsigned char *a0Data;
+        unsigned long  a1DataBytes;
+        unsigned char *a1Data;
+        unsigned long  a2DataBytes;
+        unsigned char *a2Data;
+        unsigned long  a3DataBytes;
+        unsigned char *a3Data;
+        unsigned long  b0DataBytes;
+        unsigned char *b0Data;
+        unsigned long  b1DataBytes;
+        unsigned char *b1Data;
+        unsigned long  buildDataBytes;
+        unsigned char *buildData;
+    } ECC_SPKBUILD_REQ;
+
+#define NUM_EC_SPKBUILD_DESC  (1)
+#define DPD_EC_SPKBUILD_GROUP (PK_GROUP | 0x0c00)
+
+#define DPD_EC_SPKBUILD       (DPD_EC_SPKBUILD_GROUP + 0)
+
+
+
+
+    /**
+     * ECC_PTADD_DBL_REQ - elliptic curve point add
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  modBytes;
+        unsigned char *modData;
+        unsigned long  buildDataBytes;
+        unsigned char *buildData;
+        unsigned long  b2InDataBytes;
+        unsigned char *b2InData;
+        unsigned long  b3InDataBytes;
+        unsigned char *b3InData;
+        unsigned long  b1DataBytes;
+        unsigned char *b1Data;
+        unsigned long  b2DataBytes;
+        unsigned char *b2Data;
+        unsigned long  b3DataBytes;
+        unsigned char *b3Data;
+    } ECC_PTADD_DBL_REQ;
+
+#define NUM_EC_PTADD_DBL_DESC  (4)
+#define DPD_EC_PTADD_DBL_GROUP (PK_GROUP | 0x0d00)
+
+#define DPD_EC_FPADD           (DPD_EC_PTADD_DBL_GROUP + 0)
+#define DPD_EC_FPDBL           (DPD_EC_PTADD_DBL_GROUP + 1)
+#define DPD_EC_F2MADD          (DPD_EC_PTADD_DBL_GROUP + 2)
+#define DPD_EC_F2MDBL          (DPD_EC_PTADD_DBL_GROUP + 3)
+
+
+
+
+
+
+    /**
+     * IPSEC_CBC_REQ - common IPSec/DES-CBC compound request operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  cryptKeyBytes;
+        unsigned char *cryptKeyData;
+        unsigned long  cryptCtxInBytes;
+        unsigned char *cryptCtxInData;
+        unsigned long  hashInDataBytes;
+        unsigned char *hashInData;
+        unsigned long  inDataBytes;
+        unsigned char *inData;
+        unsigned char *cryptDataOut;
+        unsigned long  hashDataOutBytes;
+        unsigned char *hashDataOut;
+    } IPSEC_CBC_REQ;
+
+#define NUM_IPSEC_CBC_DESC                    (24)
+#define DPD_IPSEC_CBC_GROUP                   (IPSEC_DES_GROUP | 0x0000)
+
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_MD5_PAD    (DPD_IPSEC_CBC_GROUP + 0)
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_SHA_PAD    (DPD_IPSEC_CBC_GROUP + 1)
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_SHA256_PAD (DPD_IPSEC_CBC_GROUP + 2)
+#define DPD_IPSEC_CBC_SDES_DECRYPT_MD5_PAD    (DPD_IPSEC_CBC_GROUP + 3)
+#define DPD_IPSEC_CBC_SDES_DECRYPT_SHA_PAD    (DPD_IPSEC_CBC_GROUP + 4)
+#define DPD_IPSEC_CBC_SDES_DECRYPT_SHA256_PAD (DPD_IPSEC_CBC_GROUP + 5)
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_MD5_PAD    (DPD_IPSEC_CBC_GROUP + 6)
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_SHA_PAD    (DPD_IPSEC_CBC_GROUP + 7)
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_SHA256_PAD (DPD_IPSEC_CBC_GROUP + 8)
+#define DPD_IPSEC_CBC_TDES_DECRYPT_MD5_PAD    (DPD_IPSEC_CBC_GROUP + 9)
+#define DPD_IPSEC_CBC_TDES_DECRYPT_SHA_PAD    (DPD_IPSEC_CBC_GROUP + 10)
+#define DPD_IPSEC_CBC_TDES_DECRYPT_SHA256_PAD (DPD_IPSEC_CBC_GROUP + 11)
+
+    /* All "standard" legacy request types will autopad, no reason */
+    /* to do otherwise                                             */
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_MD5    DPD_IPSEC_CBC_SDES_ENCRYPT_MD5_PAD
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_SHA    DPD_IPSEC_CBC_SDES_ENCRYPT_SHA_PAD
+#define DPD_IPSEC_CBC_SDES_ENCRYPT_SHA256 DPD_IPSEC_CBC_SDES_ENCRYPT_SHA256_PAD
+#define DPD_IPSEC_CBC_SDES_DECRYPT_MD5    DPD_IPSEC_CBC_SDES_DECRYPT_MD5_PAD
+#define DPD_IPSEC_CBC_SDES_DECRYPT_SHA    DPD_IPSEC_CBC_SDES_DECRYPT_SHA_PAD
+#define DPD_IPSEC_CBC_SDES_DECRYPT_SHA256 DPD_IPSEC_CBC_SDES_DECRYPT_SHA256_PAD
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_MD5    DPD_IPSEC_CBC_TDES_ENCRYPT_MD5_PAD
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_SHA    DPD_IPSEC_CBC_TDES_ENCRYPT_SHA_PAD
+#define DPD_IPSEC_CBC_TDES_ENCRYPT_SHA256 DPD_IPSEC_CBC_TDES_ENCRYPT_SHA256_PAD
+#define DPD_IPSEC_CBC_TDES_DECRYPT_MD5    DPD_IPSEC_CBC_TDES_DECRYPT_MD5_PAD
+#define DPD_IPSEC_CBC_TDES_DECRYPT_SHA    DPD_IPSEC_CBC_TDES_DECRYPT_SHA_PAD
+#define DPD_IPSEC_CBC_TDES_DECRYPT_SHA256 DPD_IPSEC_CBC_TDES_DECRYPT_SHA256_PAD
+
+
+
+    /**
+     * IPSEC_ECB_REQ - common IPSec/DES-ECB compound request operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  cryptKeyBytes;
+        unsigned char *cryptKeyData;
+        unsigned long  hashInDataBytes;
+        unsigned char *hashInData;
+        unsigned long  inDataBytes;
+        unsigned char *inData;
+        unsigned long  hashDataOutBytes;
+        unsigned char *hashDataOut;
+        unsigned char *cryptDataOut;
+    } IPSEC_ECB_REQ;
+
+#define NUM_IPSEC_ECB_DESC                    (24)
+#define DPD_IPSEC_ECB_GROUP                   (IPSEC_DES_GROUP | 0x0100)
+
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_MD5_PAD    (DPD_IPSEC_ECB_GROUP + 0)
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_SHA_PAD    (DPD_IPSEC_ECB_GROUP + 1)
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_SHA256_PAD (DPD_IPSEC_ECB_GROUP + 2)
+#define DPD_IPSEC_ECB_SDES_DECRYPT_MD5_PAD    (DPD_IPSEC_ECB_GROUP + 3)
+#define DPD_IPSEC_ECB_SDES_DECRYPT_SHA_PAD    (DPD_IPSEC_ECB_GROUP + 4)
+#define DPD_IPSEC_ECB_SDES_DECRYPT_SHA256_PAD (DPD_IPSEC_ECB_GROUP + 5)
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_MD5_PAD    (DPD_IPSEC_ECB_GROUP + 6)
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_SHA_PAD    (DPD_IPSEC_ECB_GROUP + 7)
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_SHA256_PAD (DPD_IPSEC_ECB_GROUP + 8)
+#define DPD_IPSEC_ECB_TDES_DECRYPT_MD5_PAD    (DPD_IPSEC_ECB_GROUP + 9)
+#define DPD_IPSEC_ECB_TDES_DECRYPT_SHA_PAD    (DPD_IPSEC_ECB_GROUP + 10)
+#define DPD_IPSEC_ECB_TDES_DECRYPT_SHA256_PAD (DPD_IPSEC_ECB_GROUP + 11)
+
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_MD5    DPD_IPSEC_ECB_SDES_ENCRYPT_MD5_PAD
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_SHA    DPD_IPSEC_ECB_SDES_ENCRYPT_SHA_PAD
+#define DPD_IPSEC_ECB_SDES_ENCRYPT_SHA256 DPD_IPSEC_ECB_SDES_ENCRYPT_SHA256_PAD
+#define DPD_IPSEC_ECB_SDES_DECRYPT_MD5    DPD_IPSEC_ECB_SDES_DECRYPT_MD5_PAD
+#define DPD_IPSEC_ECB_SDES_DECRYPT_SHA    DPD_IPSEC_ECB_SDES_DECRYPT_SHA_PAD
+#define DPD_IPSEC_ECB_SDES_DECRYPT_SHA256 DPD_IPSEC_ECB_SDES_DECRYPT_SHA256_PAD
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_MD5    DPD_IPSEC_ECB_TDES_ENCRYPT_MD5_PAD
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_SHA    DPD_IPSEC_ECB_TDES_ENCRYPT_SHA_PAD
+#define DPD_IPSEC_ECB_TDES_ENCRYPT_SHA256 DPD_IPSEC_ECB_TDES_ENCRYPT_SHA256_PAD
+#define DPD_IPSEC_ECB_TDES_DECRYPT_MD5    DPD_IPSEC_ECB_TDES_DECRYPT_MD5_PAD
+#define DPD_IPSEC_ECB_TDES_DECRYPT_SHA    DPD_IPSEC_ECB_TDES_DECRYPT_SHA_PAD
+#define DPD_IPSEC_ECB_TDES_DECRYPT_SHA256 DPD_IPSEC_ECB_TDES_DECRYPT_SHA256_PAD
+
+
+
+    /**
+     * IPSEC_AES_CBC_REQ - common IPSec/AES-CBC compound request operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  cryptKeyBytes;
+        unsigned char *cryptKeyData;
+        unsigned long  cryptCtxInBytes;
+        unsigned char *cryptCtxInData;
+        unsigned long  hashInDataBytes;
+        unsigned char *hashInData;
+        unsigned long  inDataBytes;
+        unsigned char *inData;
+        unsigned char *cryptDataOut;
+        unsigned long  hashDataOutBytes;
+        unsigned char *hashDataOut;
+    } IPSEC_AES_CBC_REQ;
+
+#define NUM_IPSEC_AES_CBC_DESC                      (12)
+#define DPD_IPSEC_AES_CBC_GROUP                     (IPSEC_AES_GROUP | 0x0000)
+
+#define DPD_IPSEC_AES_CBC_ENCRYPT_MD5_APAD          (DPD_IPSEC_AES_CBC_GROUP + 0)
+#define DPD_IPSEC_AES_CBC_ENCRYPT_SHA_APAD          (DPD_IPSEC_AES_CBC_GROUP + 1)
+#define DPD_IPSEC_AES_CBC_ENCRYPT_SHA256_APAD       (DPD_IPSEC_AES_CBC_GROUP + 2)
+#define DPD_IPSEC_AES_CBC_ENCRYPT_MD5               (DPD_IPSEC_AES_CBC_GROUP + 3)
+#define DPD_IPSEC_AES_CBC_ENCRYPT_SHA               (DPD_IPSEC_AES_CBC_GROUP + 4)
+#define DPD_IPSEC_AES_CBC_ENCRYPT_SHA256            (DPD_IPSEC_AES_CBC_GROUP + 5)
+#define DPD_IPSEC_AES_CBC_DECRYPT_MD5_APAD          (DPD_IPSEC_AES_CBC_GROUP + 6)
+#define DPD_IPSEC_AES_CBC_DECRYPT_SHA_APAD          (DPD_IPSEC_AES_CBC_GROUP + 7)
+#define DPD_IPSEC_AES_CBC_DECRYPT_SHA256_APAD       (DPD_IPSEC_AES_CBC_GROUP + 8)
+#define DPD_IPSEC_AES_CBC_DECRYPT_MD5               (DPD_IPSEC_AES_CBC_GROUP + 9)
+#define DPD_IPSEC_AES_CBC_DECRYPT_SHA               (DPD_IPSEC_AES_CBC_GROUP + 10)
+#define DPD_IPSEC_AES_CBC_DECRYPT_SHA256            (DPD_IPSEC_AES_CBC_GROUP + 11)
+
+
+
+    /**
+     * IPSEC_AES_ECB_REQ - common IPSec/AES-ECB compound request operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  cryptKeyBytes;
+        unsigned char *cryptKeyData;
+        unsigned long  hashInDataBytes;
+        unsigned char *hashInData;
+        unsigned long  inDataBytes;
+        unsigned char *inData;
+        unsigned char *cryptDataOut;
+        unsigned long  hashDataOutBytes;
+        unsigned char *hashDataOut;
+    } IPSEC_AES_ECB_REQ;
+
+#define NUM_IPSEC_AES_ECB_DESC                      (12)
+#define DPD_IPSEC_AES_ECB_GROUP                     (IPSEC_AES_GROUP | 0x0100)
+
+#define DPD_IPSEC_AES_ECB_ENCRYPT_MD5_APAD          (DPD_IPSEC_AES_ECB_GROUP + 0)
+#define DPD_IPSEC_AES_ECB_ENCRYPT_SHA_APAD          (DPD_IPSEC_AES_ECB_GROUP + 1)
+#define DPD_IPSEC_AES_ECB_ENCRYPT_SHA256_APAD       (DPD_IPSEC_AES_ECB_GROUP + 2)
+#define DPD_IPSEC_AES_ECB_ENCRYPT_MD5               (DPD_IPSEC_AES_ECB_GROUP + 3)
+#define DPD_IPSEC_AES_ECB_ENCRYPT_SHA               (DPD_IPSEC_AES_ECB_GROUP + 4)
+#define DPD_IPSEC_AES_ECB_ENCRYPT_SHA256            (DPD_IPSEC_AES_ECB_GROUP + 5)
+#define DPD_IPSEC_AES_ECB_DECRYPT_MD5_APAD          (DPD_IPSEC_AES_ECB_GROUP + 6)
+#define DPD_IPSEC_AES_ECB_DECRYPT_SHA_APAD          (DPD_IPSEC_AES_ECB_GROUP + 7)
+#define DPD_IPSEC_AES_ECB_DECRYPT_SHA256_APAD       (DPD_IPSEC_AES_ECB_GROUP + 8)
+#define DPD_IPSEC_AES_ECB_DECRYPT_MD5               (DPD_IPSEC_AES_ECB_GROUP + 9)
+#define DPD_IPSEC_AES_ECB_DECRYPT_SHA               (DPD_IPSEC_AES_ECB_GROUP + 10)
+#define DPD_IPSEC_AES_ECB_DECRYPT_SHA256            (DPD_IPSEC_AES_ECB_GROUP + 11)
+
+
+
+
+    /**
+     * IPSEC_ESP_REQ - IPSec Encapsulated system payload compound operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  cryptKeyBytes;
+        unsigned char *cryptKeyData;
+        unsigned long  cryptCtxInBytes;
+        unsigned char *cryptCtxInData;
+        unsigned long  hashInDataBytes;
+        unsigned char *hashInData;
+        unsigned long  inDataBytes;
+        unsigned char *inData;
+        unsigned char *cryptDataOut;
+        unsigned long  hashDataOutBytes; /* out ICV is always at the end of cryptDataOut */
+        unsigned long  cryptCtxOutBytes;
+        unsigned char *cryptCtxOutData;
+    } IPSEC_ESP_REQ;
+
+#define NUM_IPSEC_ESP_DESC                                (36)
+#define DPD_IPSEC_ESP_GROUP                               (IPSEC_DES_GROUP | 0x0500)
+
+#define DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 0)
+#define DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 1)
+#define DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 2)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 3)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 4)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 5)
+#define DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 6)
+#define DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 7)
+#define DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 8)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 9)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 10)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 11)
+#define DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 12)
+#define DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 13)
+#define DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 14)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 15)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 16)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 17)
+#define DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 18)
+#define DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 19)
+#define DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 20)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_MD5_PAD           (DPD_IPSEC_ESP_GROUP + 21)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA_PAD           (DPD_IPSEC_ESP_GROUP + 22)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA256_PAD        (DPD_IPSEC_ESP_GROUP + 23)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_MD5_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 24)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 25)
+#define DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA256_PAD_CMP    (DPD_IPSEC_ESP_GROUP + 26)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_MD5_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 27)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 28)
+#define DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA256_PAD_CMP    (DPD_IPSEC_ESP_GROUP + 29)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_MD5_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 30)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 31)
+#define DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA256_PAD_CMP    (DPD_IPSEC_ESP_GROUP + 32)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_MD5_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 33)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA_PAD_CMP       (DPD_IPSEC_ESP_GROUP + 34)
+#define DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA256_PAD_CMP    (DPD_IPSEC_ESP_GROUP + 35)
+
+
+
+
+
+    /**
+     * CCMP_REQ 802.11 counter mode with CBC MAC protocol operation
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  ctxBytes;
+        unsigned char *context;
+        unsigned long  FrameDataBytes;
+        unsigned char *FrameData;
+        unsigned long  AADBytes;
+        unsigned char *AADData;
+        unsigned long  cryptDataBytes;
+        unsigned char *cryptDataOut;
+        unsigned long  MICBytes;
+        unsigned char *MICData;
+    } CCMP_REQ;
+
+#define NUM_CCMP_DESC                         (3)
+#define DPD_CCMP_GROUP                        (AES_GROUP | 0x0500)
+
+#define DPD_802_11_CCMP_OUTBOUND              (DPD_CCMP_GROUP + 0)
+#define DPD_802_11_CCMP_INBOUND               (DPD_CCMP_GROUP + 1)
+#define DPD_802_11_CCMP_INBOUND_CMP           (DPD_CCMP_GROUP + 2)
+
+
+
+    /**
+     * SRTP_REQ - secure RTP compound operations
+     *
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char *hashKeyData;
+        unsigned long  keyBytes;
+        unsigned char *keyData;
+        unsigned long  ivBytes;
+        unsigned char *ivData;
+        unsigned long  HeaderBytes;
+        unsigned long  inBytes;
+        unsigned char *inData;
+        unsigned long  ROCBytes;
+        unsigned long  cryptDataBytes;
+        unsigned char *cryptDataOut;
+        unsigned long  digestBytes;
+        unsigned char *digestData;
+        unsigned long  outIvBytes;
+        unsigned char *outIvData;
+    } SRTP_REQ;
+
+#define NUM_SRTP_DESC                                     (3)
+#define DPD_SRTP_GROUP                                    (IPSEC_AES_GROUP | 0x0500)
+
+#define DPD_SRTP_OUTBOUND                                 (DPD_SRTP_GROUP + 0)
+#define DPD_SRTP_INBOUND                                  (DPD_SRTP_GROUP + 1)
+#define DPD_SRTP_INBOUND_CMP                              (DPD_SRTP_GROUP + 2)
+
+
+
+
+
+    /*
+     * TLS request types
+     *
+     * Note that this differs from many similar types of requests
+     * on account that there are significant differences is the needed
+     * format for a DPD for each of the different types of TLS packets
+     *
+     * Since DPD's are built according to a translation table that's
+     * determined on a group basis (not on individual requests), and
+     * since the DPDs have to be constructed differently for each type
+     * of TLS packet/payload, there are individual request structs for
+     * each
+     */
+
+    /**
+     * TLS_BLOCK_INBOUND_REQ - SSL/TLS block cipher inbound operation
+     * This is a 2.1 request type only
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char* hashKeyData;
+        unsigned long  hashOnlyBytes;
+        unsigned char* hashOnlyData;
+        unsigned long  ivBytes;
+        unsigned char* ivData;
+        unsigned long  cipherKeyBytes;
+        unsigned char* cipherKeyData;
+        unsigned long  inBytes;
+        unsigned char* inData;
+        unsigned long  MACcmpBytes;
+        unsigned long  outBytes;
+        unsigned char* outData;
+        unsigned long  MACoutBytes;
+        unsigned long  ivOutBytes;
+        unsigned char* ivOutData;
+    } TLS_BLOCK_INBOUND_REQ;
+
+#define NUM_TLS_BLOCK_INBOUND_DESC                (30)
+#define DPD_TLS_BLOCK_INBOUND_GROUP               (TLS_GROUP | 0x0000)
+
+#define DPD_TLS_BLOCK_INBOUND_SDES_MD5            (DPD_TLS_BLOCK_INBOUND_GROUP)
+#define DPD_TLS_BLOCK_INBOUND_SDES_MD5_CMP        (DPD_TLS_BLOCK_INBOUND_GROUP + 1)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA1           (DPD_TLS_BLOCK_INBOUND_GROUP + 2)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA1_CMP       (DPD_TLS_BLOCK_INBOUND_GROUP + 3)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA256         (DPD_TLS_BLOCK_INBOUND_GROUP + 4)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA256_CMP     (DPD_TLS_BLOCK_INBOUND_GROUP + 5)
+#define DPD_TLS_BLOCK_INBOUND_TDES_MD5            (DPD_TLS_BLOCK_INBOUND_GROUP + 6)
+#define DPD_TLS_BLOCK_INBOUND_TDES_MD5_CMP        (DPD_TLS_BLOCK_INBOUND_GROUP + 7)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA1           (DPD_TLS_BLOCK_INBOUND_GROUP + 8)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA1_CMP       (DPD_TLS_BLOCK_INBOUND_GROUP + 9)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA256         (DPD_TLS_BLOCK_INBOUND_GROUP + 10)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA256_CMP     (DPD_TLS_BLOCK_INBOUND_GROUP + 11)
+#define DPD_TLS_BLOCK_INBOUND_SDES_MD5_SMAC       (DPD_TLS_BLOCK_INBOUND_GROUP + 12)
+#define DPD_TLS_BLOCK_INBOUND_SDES_MD5_SMAC_CMP   (DPD_TLS_BLOCK_INBOUND_GROUP + 13)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA1_SMAC      (DPD_TLS_BLOCK_INBOUND_GROUP + 14)
+#define DPD_TLS_BLOCK_INBOUND_SDES_SHA1_SMAC_CMP  (DPD_TLS_BLOCK_INBOUND_GROUP + 15)
+#define DPD_TLS_BLOCK_INBOUND_TDES_MD5_SMAC       (DPD_TLS_BLOCK_INBOUND_GROUP + 16)
+#define DPD_TLS_BLOCK_INBOUND_TDES_MD5_SMAC_CMP   (DPD_TLS_BLOCK_INBOUND_GROUP + 17)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA1_SMAC      (DPD_TLS_BLOCK_INBOUND_GROUP + 18)
+#define DPD_TLS_BLOCK_INBOUND_TDES_SHA1_SMAC_CMP  (DPD_TLS_BLOCK_INBOUND_GROUP + 19)
+#define DPD_TLS_BLOCK_INBOUND_AES_MD5             (DPD_TLS_BLOCK_INBOUND_GROUP + 20)
+#define DPD_TLS_BLOCK_INBOUND_AES_MD5_CMP         (DPD_TLS_BLOCK_INBOUND_GROUP + 21)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA1            (DPD_TLS_BLOCK_INBOUND_GROUP + 22)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA1_CMP        (DPD_TLS_BLOCK_INBOUND_GROUP + 23)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA256          (DPD_TLS_BLOCK_INBOUND_GROUP + 24)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA256_CMP      (DPD_TLS_BLOCK_INBOUND_GROUP + 25)
+#define DPD_TLS_BLOCK_INBOUND_AES_MD5_SMAC        (DPD_TLS_BLOCK_INBOUND_GROUP + 26)
+#define DPD_TLS_BLOCK_INBOUND_AES_MD5_SMAC_CMP    (DPD_TLS_BLOCK_INBOUND_GROUP + 27)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA1_SMAC       (DPD_TLS_BLOCK_INBOUND_GROUP + 28)
+#define DPD_TLS_BLOCK_INBOUND_AES_SHA1_SMAC_CMP   (DPD_TLS_BLOCK_INBOUND_GROUP + 29)
+
+
+
+    /**
+     * TLS_BLOCK_OUTBOUND_REQ - SSL/TLS block cipher outbound operation
+     * This is a 2.1 request type only
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char* hashKeyData;
+        unsigned long  ivBytes;
+        unsigned char* ivData;
+        unsigned long  cipherKeyBytes;
+        unsigned char* cipherKeyData;
+        unsigned long  hashOnlyBytes;
+        unsigned char* hashOnlyData;
+        unsigned long  mainDataBytes;
+        unsigned long  outBytes;
+        unsigned char* outData;
+        unsigned long  MACbytes;
+        unsigned long  cipherOnlyBytes;
+        unsigned char* cipherOnlyData;
+        unsigned long  ivOutBytes;
+        unsigned char* ivOutData;
+    } TLS_BLOCK_OUTBOUND_REQ;
+
+#define NUM_TLS_BLOCK_OUTBOUND_DESC             (9)
+#define DPD_TLS_BLOCK_OUTBOUND_GROUP            (TLS_GROUP | 0x0100)
+
+#define DPD_TLS_BLOCK_OUTBOUND_SDES_MD5         (DPD_TLS_BLOCK_OUTBOUND_GROUP + 0)
+#define DPD_TLS_BLOCK_OUTBOUND_SDES_SHA1        (DPD_TLS_BLOCK_OUTBOUND_GROUP + 1)
+#define DPD_TLS_BLOCK_OUTBOUND_SDES_SHA256      (DPD_TLS_BLOCK_OUTBOUND_GROUP + 2)
+#define DPD_TLS_BLOCK_OUTBOUND_TDES_MD5         (DPD_TLS_BLOCK_OUTBOUND_GROUP + 3)
+#define DPD_TLS_BLOCK_OUTBOUND_TDES_SHA1        (DPD_TLS_BLOCK_OUTBOUND_GROUP + 4)
+#define DPD_TLS_BLOCK_OUTBOUND_TDES_SHA256      (DPD_TLS_BLOCK_OUTBOUND_GROUP + 5)
+#define DPD_TLS_BLOCK_OUTBOUND_AES_MD5          (DPD_TLS_BLOCK_OUTBOUND_GROUP + 6)
+#define DPD_TLS_BLOCK_OUTBOUND_AES_SHA1         (DPD_TLS_BLOCK_OUTBOUND_GROUP + 7)
+#define DPD_TLS_BLOCK_OUTBOUND_AES_SHA256       (DPD_TLS_BLOCK_OUTBOUND_GROUP + 8)
+
+
+    /**
+     * TLS_STREAM_INBOUND_REQ - SSL/TLS stream cipher inbound operation
+     * This is a 2.1 request type only
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char* hashKeyData;
+        unsigned long  hashOnlyBytes;
+        unsigned char* hashOnlyData;
+        unsigned long  ivBytes;
+        unsigned char* ivData;
+        unsigned long  cipherKeyBytes;
+        unsigned char* cipherKeyData;
+        unsigned long  inBytes;
+        unsigned char* inData;
+        unsigned long  MACcmpBytes;
+        unsigned long  outBytes;
+        unsigned char* outData;
+        unsigned long  MACoutBytes;
+        unsigned long  ivOutBytes;
+        unsigned char* ivOutData;
+        unsigned char* cmpData;
+    } TLS_STREAM_INBOUND_REQ;
+
+#define NUM_TLS_STREAM_INBOUND_DESC               (12)
+#define DPD_TLS_STREAM_INBOUND_GROUP              (TLS_GROUP | 0x0200)
+
+#define DPD_TLS_STREAM_INBOUND
+#define DPD_TLS_STREAM_INBOUND_MD5                (DPD_TLS_STREAM_INBOUND_GROUP)
+#define DPD_TLS_STREAM_INBOUND_CTX_MD5            (DPD_TLS_STREAM_INBOUND_GROUP + 1)
+#define DPD_TLS_STREAM_INBOUND_SHA1               (DPD_TLS_STREAM_INBOUND_GROUP + 2)
+#define DPD_TLS_STREAM_INBOUND_CTX_SHA1           (DPD_TLS_STREAM_INBOUND_GROUP + 3)
+#define DPD_TLS_STREAM_INBOUND_SHA256             (DPD_TLS_STREAM_INBOUND_GROUP + 4)
+#define DPD_TLS_STREAM_INBOUND_CTX_SHA256         (DPD_TLS_STREAM_INBOUND_GROUP + 5)
+#define DPD_TLS_STREAM_INBOUND_MD5_CMP            (DPD_TLS_STREAM_INBOUND_GROUP + 6)
+#define DPD_TLS_STREAM_INBOUND_CTX_MD5_CMP        (DPD_TLS_STREAM_INBOUND_GROUP + 7)
+#define DPD_TLS_STREAM_INBOUND_SHA1_CMP           (DPD_TLS_STREAM_INBOUND_GROUP + 8)
+#define DPD_TLS_STREAM_INBOUND_CTX_SHA1_CMP       (DPD_TLS_STREAM_INBOUND_GROUP + 9)
+#define DPD_TLS_STREAM_INBOUND_SHA256_CMP         (DPD_TLS_STREAM_INBOUND_GROUP + 10)
+#define DPD_TLS_STREAM_INBOUND_CTX_SHA256_CMP     (DPD_TLS_STREAM_INBOUND_GROUP + 11)
+
+
+
+
+    /**
+     * TLS_STREAM_OUTBOUND_REQ - SSL/TLS stream cipher outbound
+     * operation This is a 2.1 request type only
+     */
+
+    typedef struct
+    {
+        COMMON_REQ_PREAMBLE
+        unsigned long  hashKeyBytes;
+        unsigned char* hashKeyData;
+        unsigned long  ivBytes;
+        unsigned char* ivData;
+        unsigned long  cipherKeyBytes;
+        unsigned char* cipherKeyData;
+        unsigned long  hashOnlyBytes;
+        unsigned char* hashOnlyData;
+        unsigned long  mainDataBytes;
+        unsigned long  outBytes;
+        unsigned char* outData;
+        unsigned long  MACbytes;
+        unsigned long  ivOutBytes;
+        unsigned char* ivOutData;
+        unsigned char* cmpData;
+    } TLS_STREAM_OUTBOUND_REQ;
+
+#define NUM_TLS_STREAM_OUTBOUND_DESC             (6)
+#define DPD_TLS_STREAM_OUTBOUND_GROUP            (TLS_GROUP | 0x0300)
+
+#define DPD_TLS_STREAM_OUTBOUND_MD5              (DPD_TLS_STREAM_OUTBOUND_GROUP + 0)
+#define DPD_TLS_STREAM_OUTBOUND_SHA1             (DPD_TLS_STREAM_OUTBOUND_GROUP + 1)
+#define DPD_TLS_STREAM_OUTBOUND_SHA256           (DPD_TLS_STREAM_OUTBOUND_GROUP + 2)
+#define DPD_TLS_STREAM_OUTBOUND_CTX_MD5          (DPD_TLS_STREAM_OUTBOUND_GROUP + 3)
+#define DPD_TLS_STREAM_OUTBOUND_CTX_SHA1         (DPD_TLS_STREAM_OUTBOUND_GROUP + 4)
+#define DPD_TLS_STREAM_OUTBOUND_CTX_SHA256       (DPD_TLS_STREAM_OUTBOUND_GROUP + 5)
+
+
+
+
+
+
+#ifdef _cplusplus
+}
+#endif
+
+#endif  /* SEC2_H */
diff --git a/drivers/crypto/t23x/t23xsec2/Sec2local.h b/drivers/crypto/t23x/t23xsec2/Sec2local.h
new file mode 100644
index 0000000..f42530f
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/Sec2local.h
@@ -0,0 +1,113 @@
+/*
+ * Sec2local.h
+ *
+ * Interenal definitions for the SEC2.x legacy interface for the
+ * t23x extensible crypto driver subsystem
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+#ifndef SEC2LOCAL_H
+#define SEC2LOCAL_H
+
+
+/** @file
+ * Descriptor construction definitions for the SEC2.x
+ *   - security processing core family
+ */
+
+
+#ifdef _cplusplus
+extern "C" {
+#endif
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+#include "Sec2.h"
+
+
+#define SEC2X_DEVMAJOR   (0)
+#define SEC2X_DEVNAME    "sec2x"
+
+
+
+    /**
+     * Types of requests. These are saved off in the dynamic request
+     * queue, or in the channel state block so that the deferred
+     * service knows how to handle the request completion notification
+     */
+    typedef enum rq_type
+    {
+        RQ_KERNEL_ASYNC, /**< asynchronous,
+                                can directly invoke handlers */
+        RQ_USER_ASYNC,   /**< User-mode asynchronous,
+                                will save and send signals */
+        RQ_USER_BLOCK    /**< User-mode synchronous,
+                                will waitqueue the request */
+    } RQ_TYPE;
+
+
+    /**
+     * Specifies the memory translation needed when putting addresses
+     * in a descriptor under construction
+     */
+    typedef enum ptrtype
+    {
+        PTR_PHYSICAL,       /**< physical address,
+                                no translation needed                 */
+        PTR_LOGICAL,        /**< logical address,
+                                simple translation only               */
+        PTR_USER_VIRTUAL,   /**< points to a user memory buffer       */
+        PTR_KERNEL_VIRTUAL, /**< points to a kernel memory buffer     */
+    } PTRTYPE;
+
+
+
+
+    /*
+     * Internal prototypes
+     */
+
+    /* t2dpd.c */
+    int constructDPDlist(GENERIC_REQ *rqList, RMexecMessage *exMsg, PTRTYPE memtyp);
+    int releaseDPDlist(RMexecMessage *exMsg, PTRTYPE memtyp);
+
+
+#ifdef _cplusplus
+}
+#endif
+
+#endif /* SEC2LOCAL_H */
diff --git a/drivers/crypto/t23x/t23xsec2/sec2_sctrMap.c b/drivers/crypto/t23x/t23xsec2/sec2_sctrMap.c
new file mode 100644
index 0000000..a7a715a
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/sec2_sctrMap.c
@@ -0,0 +1,613 @@
+
+/*
+ * sec2_sctrMap.c - scatter buffer pointer marker
+ *
+ * Instantiated into the t23x SEC2.x legacy interface module,.
+ * This code is OBSOLETE, and is provided for legacy application
+ * transition. New applications should use the _VIRTUAL functions
+ * wherever possible
+ *
+ * Copyright (c) 2004-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "Sec2.h"
+#include "Sec2local.h"
+
+typedef struct _scatter_assoc
+{
+    unsigned long offset;
+    unsigned long pos;
+} SCATTER_ASSOC;
+
+
+
+
+
+static const SCATTER_ASSOC SCTMAP_RNG[] =
+{
+    {offsetof(RNG_REQ, rngData), 0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_DES_CBC_CTX[] =
+{
+    {offsetof(DES_CBC_CRYPT_REQ, inIvData),  0x02},
+    {offsetof(DES_CBC_CRYPT_REQ, keyData),   0x04},
+    {offsetof(DES_CBC_CRYPT_REQ, inData),    0x08},
+    {offsetof(DES_CBC_CRYPT_REQ, outData),   0x10},
+    {offsetof(DES_CBC_CRYPT_REQ, outIvData), 0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_DES_ECB[] =
+{
+    {offsetof(DES_CRYPT_REQ, keyData), 0x04},
+    {offsetof(DES_CRYPT_REQ, inData),  0x08},
+    {offsetof(DES_CRYPT_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_RC4_LDCTX_CRYPT_ULCTX[] =
+{
+    {offsetof(ARC4_LOADCTX_CRYPT_REQ, inCtxData),   0x02},
+    {offsetof(ARC4_LOADCTX_CRYPT_REQ, inData),      0x08},
+    {offsetof(ARC4_LOADCTX_CRYPT_REQ, outData),     0x10},
+    {offsetof(ARC4_LOADCTX_CRYPT_REQ, outCtxData),  0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_RC4_LDKEY_CRYPT_ULCTX[] =
+{
+    {offsetof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, keyData),     0x04},
+    {offsetof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, inData),      0x08},
+    {offsetof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, outData),     0x10},
+    {offsetof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, outCtxData),  0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_HASH_LDCTX_HASH_ULCTX[] =
+{
+    {offsetof(HASH_REQ, ctxData),  0x02},
+    {offsetof(HASH_REQ, inData),   0x08},
+    {offsetof(HASH_REQ, cmpData),  0x10},
+    {offsetof(HASH_REQ, outData),  0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_HASH_LDCTX_HASH_PAD_ULCTX[] =
+{
+    {offsetof(HASH_REQ, ctxData),  0x02},
+    {offsetof(HASH_REQ, inData),   0x08},
+    {offsetof(HASH_REQ, cmpData),  0x10},
+    {offsetof(HASH_REQ, outData),  0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_HASH_LDCTX_HMAC_ULCTX[] =
+{
+    {offsetof(HMAC_PAD_REQ, keyData), 0x04},
+    {offsetof(HMAC_PAD_REQ, inData),  0x08},
+    {offsetof(HMAC_PAD_REQ, cmpData), 0x10},
+    {offsetof(HMAC_PAD_REQ, outData), 0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_MM_LDCTX_EXP_ULCTX[] =
+{
+    {offsetof(MOD_EXP_REQ, aData),   0x02},
+    {offsetof(MOD_EXP_REQ, expData), 0x04},
+    {offsetof(MOD_EXP_REQ, modData), 0x08},
+    {offsetof(MOD_EXP_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_MM_SS_RSA_EXP[] =
+{
+    {offsetof(MOD_SS_EXP_REQ, modData), 0x01},
+    {offsetof(MOD_SS_EXP_REQ, aData),   0x04},
+    {offsetof(MOD_SS_EXP_REQ, expData), 0x08},
+    {offsetof(MOD_SS_EXP_REQ, bData),   0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_MM_LDCTX_R2MODN_ULCTX[] =
+{
+    {offsetof(MOD_R2MODN_REQ, modData), 0x08},
+    {offsetof(MOD_R2MODN_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_MM_LDCTX_RRMODP_ULCTX[] =
+{
+    {offsetof(MOD_RRMODP_REQ, pData),   0x01},
+    {offsetof(MOD_RRMODP_REQ, nBytes),  0x08},
+    {offsetof(MOD_RRMODP_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+static const SCATTER_ASSOC SCTMAP_MM_MOD_INV_ULCTX[] =
+{
+    {offsetof(MOD_INV_REQ, nData),   0x01},
+    {offsetof(MOD_INV_REQ, inData),  0x04},
+    {offsetof(MOD_INV_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+static const SCATTER_ASSOC SCTMAP_MOD_LDCTX_2OP_ULCTX[] =
+{
+    {offsetof(MOD_2OP_REQ, modData), 0x01},
+    {offsetof(MOD_2OP_REQ, bData),   0x02},
+    {offsetof(MOD_2OP_REQ, aData),   0x04},
+    {offsetof(MOD_2OP_REQ, outData), 0x10},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_EC_LDCTX_kP_ULCTX[] =
+{
+    {offsetof(ECC_POINT_REQ, nData),     0x01},
+    {offsetof(ECC_POINT_REQ, eData),     0x02},
+    {offsetof(ECC_POINT_REQ, buildData), 0x04},
+    {offsetof(ECC_POINT_REQ, b1Data),    0x08},
+    {offsetof(ECC_POINT_REQ, b2Data),    0x10},
+    {offsetof(ECC_POINT_REQ, b3Data),    0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_EC_2OP[] =
+{
+    {offsetof(ECC_2OP_REQ, bData),   0x01},
+    {offsetof(ECC_2OP_REQ, aData),   0x02},
+    {offsetof(ECC_2OP_REQ, modData), 0x04},
+    {offsetof(ECC_2OP_REQ, outData), 0x08},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_EC_SPKBUILD_ULCTX[] =
+{
+    {offsetof(ECC_SPKBUILD_REQ, a0Data),    0x01},
+    {offsetof(ECC_SPKBUILD_REQ, a1Data),    0x02},
+    {offsetof(ECC_SPKBUILD_REQ, a2Data),    0x04},
+    {offsetof(ECC_SPKBUILD_REQ, a3Data),    0x08},
+    {offsetof(ECC_SPKBUILD_REQ, b0Data),    0x10},
+    {offsetof(ECC_SPKBUILD_REQ, b1Data),    0x20},
+    {offsetof(ECC_SPKBUILD_REQ, buildData), 0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_ECC_PTADD_DBL[] =
+{
+    {offsetof(ECC_PTADD_DBL_REQ, modData),    0x01},
+    {offsetof(ECC_PTADD_DBL_REQ, buildData),  0x02},
+    {offsetof(ECC_PTADD_DBL_REQ, b2InData),   0x04},
+    {offsetof(ECC_PTADD_DBL_REQ, b3InData),   0x08},
+    {offsetof(ECC_PTADD_DBL_REQ, b1Data),     0x10},
+    {offsetof(ECC_PTADD_DBL_REQ, b2Data),     0x20},
+    {offsetof(ECC_PTADD_DBL_REQ, b3Data),     0x40},
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_CBC[] =
+{
+    {offsetof(IPSEC_CBC_REQ, hashKeyData),    0x01},
+    {offsetof(IPSEC_CBC_REQ, hashInData),     0x02},
+    {offsetof(IPSEC_CBC_REQ, cryptKeyData),   0x04},
+    {offsetof(IPSEC_CBC_REQ, cryptCtxInData), 0x08},
+    {offsetof(IPSEC_CBC_REQ, inData),         0x10},
+    {offsetof(IPSEC_CBC_REQ, cryptDataOut),   0x20},
+    {offsetof(IPSEC_CBC_REQ, hashDataOut),    0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_ESP[] =
+{
+    {offsetof(IPSEC_ESP_REQ, hashKeyData),     0x01},
+    {offsetof(IPSEC_ESP_REQ, hashInData),      0x02},
+    {offsetof(IPSEC_ESP_REQ, cryptCtxInData),  0x04},
+    {offsetof(IPSEC_ESP_REQ, cryptKeyData),    0x08},
+    {offsetof(IPSEC_ESP_REQ, inData),          0x10},
+    {offsetof(IPSEC_ESP_REQ, cryptDataOut),    0x20},
+    {offsetof(IPSEC_ESP_REQ, cryptCtxOutData), 0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_STATIC_CBC[] =
+{
+    {offsetof(IPSEC_CBC_REQ, hashKeyData),    0x01},
+    {offsetof(IPSEC_CBC_REQ, hashInData),     0x02},
+    {offsetof(IPSEC_CBC_REQ, cryptKeyData),   0x04},
+    {offsetof(IPSEC_CBC_REQ, cryptCtxInData), 0x08},
+    {offsetof(IPSEC_CBC_REQ, inData),         0x10},
+    {offsetof(IPSEC_CBC_REQ, cryptDataOut),   0x20},
+    {offsetof(IPSEC_CBC_REQ, hashDataOut),    0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_ECB[] =
+{
+    {offsetof(IPSEC_ECB_REQ, hashKeyData),  0x01},
+    {offsetof(IPSEC_ECB_REQ, hashInData),   0x02},
+    {offsetof(IPSEC_ECB_REQ, cryptKeyData), 0x04},
+    {offsetof(IPSEC_ECB_REQ, inData),       0x10},
+    {offsetof(IPSEC_ECB_REQ, cryptDataOut), 0x20},
+    {offsetof(IPSEC_ECB_REQ, hashDataOut),  0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_AES_CBC[] =
+{
+    {offsetof(IPSEC_AES_CBC_REQ, hashKeyData),    0x01},
+    {offsetof(IPSEC_AES_CBC_REQ, hashInData),     0x02},
+    {offsetof(IPSEC_AES_CBC_REQ, cryptKeyData),   0x04},
+    {offsetof(IPSEC_AES_CBC_REQ, cryptCtxInData), 0x08},
+    {offsetof(IPSEC_AES_CBC_REQ, inData),         0x10},
+    {offsetof(IPSEC_AES_CBC_REQ, cryptDataOut),   0x20},
+    {offsetof(IPSEC_AES_CBC_REQ, hashDataOut),    0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_IPSEC_AES_ECB[] =
+{
+    {offsetof(IPSEC_AES_ECB_REQ, hashKeyData),  0x01},
+    {offsetof(IPSEC_AES_ECB_REQ, hashInData),   0x02},
+    {offsetof(IPSEC_AES_ECB_REQ, cryptKeyData), 0x04},
+    {offsetof(IPSEC_AES_ECB_REQ, inData),       0x10},
+    {offsetof(IPSEC_AES_ECB_REQ, cryptDataOut), 0x20},
+    {offsetof(IPSEC_AES_ECB_REQ, hashDataOut),  0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_AESA_CRYPT[] =
+{
+    {offsetof(AESA_CRYPT_REQ, inIvData),   0x02},
+    {offsetof(AESA_CRYPT_REQ, keyData),    0x04},
+    {offsetof(AESA_CRYPT_REQ, inData),     0x08},
+    {offsetof(AESA_CRYPT_REQ, outData),    0x10},
+    {offsetof(AESA_CRYPT_REQ, outCtxData), 0x20},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_CCMP[] =
+{
+    {offsetof(CCMP_REQ, context),      0x02},
+    {offsetof(CCMP_REQ, keyData),      0x04},
+    {offsetof(CCMP_REQ, AADData),      0x08},
+    {offsetof(CCMP_REQ, FrameData),    0x10},
+    {offsetof(CCMP_REQ, cryptDataOut), 0x20},
+    {offsetof(CCMP_REQ, MICData),      0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_SRTP[] =
+{
+    {offsetof(SRTP_REQ, hashKeyData),  0x01},
+    {offsetof(SRTP_REQ, ivData),       0x02},
+    {offsetof(SRTP_REQ, keyData),      0x04},
+    {offsetof(SRTP_REQ, inData),       0x08},
+    {offsetof(SRTP_REQ, cryptDataOut), 0x10},
+    {offsetof(SRTP_REQ, digestData),   0x20},
+    {offsetof(SRTP_REQ, outIvData),    0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_KEA_CRYPT[] =
+{
+    {offsetof(KEA_CRYPT_REQ, ivData),   0x02},
+    {offsetof(KEA_CRYPT_REQ, keyData),  0x04},
+    {offsetof(KEA_CRYPT_REQ, inData),   0x08},
+    {offsetof(KEA_CRYPT_REQ, outData),  0x10},
+    {offsetof(KEA_CRYPT_REQ, ctxData),  0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_RAID_XOR[] =
+{
+    {offsetof(RAID_XOR_REQ, inDataA),  0x08},
+    {offsetof(RAID_XOR_REQ, inDataB),  0x10},
+    {offsetof(RAID_XOR_REQ, inDataC),  0x20},
+    {offsetof(RAID_XOR_REQ, outData),  0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_TLS_BLOCK_INBOUND[] =
+{
+    {offsetof(TLS_BLOCK_INBOUND_REQ, hashKeyData),   0x01},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, hashOnlyData),  0x02},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, ivData),        0x04},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, cipherKeyData), 0x08},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, inData),        0x10},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, outData),       0x20},
+    {offsetof(TLS_BLOCK_INBOUND_REQ, ivOutData),     0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_TLS_BLOCK_OUTBOUND[] =
+{
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, hashKeyData),    0x01},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, ivData),         0x02},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, cipherKeyData),  0x04},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, hashOnlyData),   0x08},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, cipherOnlyData), 0x10},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, outData),        0x20},
+    {offsetof(TLS_BLOCK_OUTBOUND_REQ, ivOutData),      0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_TLS_STREAM_INBOUND[] =
+{
+    {offsetof(TLS_STREAM_INBOUND_REQ, hashKeyData),   0x01},
+    {offsetof(TLS_STREAM_INBOUND_REQ, hashOnlyData),  0x02},
+    {offsetof(TLS_STREAM_INBOUND_REQ, ivData),        0x04},
+    {offsetof(TLS_STREAM_INBOUND_REQ, cipherKeyData), 0x08},
+    {offsetof(TLS_STREAM_INBOUND_REQ, inData),        0x10},
+    {offsetof(TLS_STREAM_INBOUND_REQ, outData),       0x20},
+    {offsetof(TLS_STREAM_INBOUND_REQ, ivOutData),     0x40},
+    {0, 0}
+};
+
+
+
+static const SCATTER_ASSOC SCTMAP_TLS_STREAM_OUTBOUND[] =
+{
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, hashKeyData),   0x01},
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, ivData),        0x02},
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, cipherKeyData), 0x04},
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, hashOnlyData),  0x08},
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, outData),       0x10},
+    {offsetof(TLS_STREAM_OUTBOUND_REQ, ivOutData),     0x40},
+    {0, 0}
+};
+
+
+
+
+static unsigned char locate(SCATTER_ASSOC *assoc,
+                            unsigned long offset)
+{
+  int i = 0;
+
+  while(assoc[i].offset)
+    if (assoc[i].offset == offset)
+      return(assoc[i].pos);
+    else
+      i++;
+
+  return(0);
+}
+
+/* Locate a pointer field within a request struct, look it up, and mark the */
+/* scatter buffer mask if it is such */
+
+int MarkScatterBuffer(void *request, void *buffer)
+{
+  GENERIC_REQ *rq;
+  unsigned long offs;
+
+  rq = (GENERIC_REQ *)request;
+  offs = (unsigned long)buffer - (unsigned long)request;
+
+  switch (rq->opId & DESC_TYPE_MASK)
+  {
+    case DPD_RNG_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_RNG, offs);
+      break;
+
+    case DPD_DES_CBC_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_DES_CBC_CTX, offs);
+      break;
+
+    case DPD_DES_ECB_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_DES_ECB, offs);
+      break;
+
+    case DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_RC4_LDCTX_CRYPT_ULCTX, offs);
+      break;
+
+    case DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_RC4_LDKEY_CRYPT_ULCTX, offs);
+      break;
+
+    case DPD_HASH_LDCTX_HASH_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_HASH_LDCTX_HASH_ULCTX, offs);
+      break;
+
+    case DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_HASH_LDCTX_HASH_PAD_ULCTX, offs);
+      break;
+
+    case DPD_HASH_LDCTX_HMAC_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_HASH_LDCTX_HMAC_ULCTX, offs);
+      break;
+
+    case DPD_MM_LDCTX_EXP_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MM_LDCTX_EXP_ULCTX, offs);
+      break;
+
+    case DPD_MM_SS_EXP_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MM_SS_RSA_EXP, offs);
+      break;
+
+    case DPD_MM_LDCTX_R2MODN_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MM_LDCTX_R2MODN_ULCTX, offs);
+      break;
+
+    case DPD_MM_LDCTX_RRMODP_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MM_LDCTX_RRMODP_ULCTX, offs);
+      break;
+
+    case DPD_MM_MOD_INV_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MM_MOD_INV_ULCTX, offs);
+      break;
+
+    case DPD_MOD_LDCTX_2OP_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_MOD_LDCTX_2OP_ULCTX, offs);
+      break;
+
+    case DPD_EC_LDCTX_kP_ULCTX_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_EC_LDCTX_kP_ULCTX, offs);
+      break;
+
+    case DPD_EC_2OP_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_EC_2OP, offs);
+      break;
+
+    case DPD_IPSEC_CBC_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_IPSEC_CBC, offs);
+      break;
+
+    case DPD_IPSEC_ECB_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_IPSEC_ECB, offs);
+      break;
+
+    case DPD_IPSEC_AES_CBC_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_IPSEC_AES_CBC, offs);
+      break;
+
+    case DPD_IPSEC_AES_ECB_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_IPSEC_AES_ECB, offs);
+      break;
+
+    case DPD_AESA_CRYPT_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_AESA_CRYPT, offs);
+      break;
+
+    case DPD_IPSEC_ESP_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_IPSEC_ESP, offs);
+      break;
+
+    case DPD_CCMP_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_CCMP, offs);
+      break;
+
+    case DPD_SRTP_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_SRTP, offs);
+      break;
+
+    case DPD_RAID_XOR_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_RAID_XOR, offs);
+      break;
+
+    case DPD_KEA_CRYPT_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_KEA_CRYPT, offs);
+      break;
+
+    case DPD_EC_SPKBUILD_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_EC_SPKBUILD_ULCTX, offs);
+      break;
+
+    case DPD_EC_PTADD_DBL_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_ECC_PTADD_DBL, offs);
+      break;
+
+    case DPD_TLS_BLOCK_INBOUND_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_TLS_BLOCK_INBOUND, offs);
+      break;
+
+    case DPD_TLS_BLOCK_OUTBOUND_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_TLS_BLOCK_OUTBOUND, offs);
+      break;
+
+    case DPD_TLS_STREAM_INBOUND_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_TLS_STREAM_INBOUND, offs);
+      break;
+
+    case DPD_TLS_STREAM_OUTBOUND_GROUP:
+      rq->scatterBufs |= locate((SCATTER_ASSOC *)SCTMAP_TLS_STREAM_OUTBOUND, offs);
+      break;
+
+    default:
+      return -1;
+  }
+
+  return 0;
+}
diff --git a/drivers/crypto/t23x/t23xsec2/t23xsec2core.c b/drivers/crypto/t23x/t23xsec2/t23xsec2core.c
new file mode 100644
index 0000000..bee05b3
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/t23xsec2core.c
@@ -0,0 +1,695 @@
+/*
+ * t23xsec2core.c
+ *
+ * t23x extensible driver subsystem - SEC2.x legacy interface
+ * Module registration and request dispatch code
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - simplified registration, compatibility
+ *
+ */
+
+
+
+/** @file
+ * Handles SEC2 legacy interface module registration and ioctl()
+ * system call dispatch for the Talitos 2/3 xwc driver subsystem.
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/crypto.h>
+
+
+/* Includes for SEC2 legacy interfaces */
+#include "Sec2.h"
+#include "Sec2local.h"
+
+/* For the framework */
+#include "../common/xwcRMinterface.h"
+
+/* For the local rm */
+#include "../t23xrm/t23xrmInternal.h"
+
+#define BLOCK_RQ_PENDING (0x7fffffff)
+#define BLOCK_RQ_DONE    (0x00000001)
+
+#define EXECMSG_POOL_DEPTH 32
+
+
+
+/* Globals for this module alone */
+
+RMinterfaceCtx *ifctx;
+
+RMexecMessage   excMsgPool[EXECMSG_POOL_DEPTH];
+spinlock_t      excPoolLock;
+
+BOOLEAN         msgInUse[EXECMSG_POOL_DEPTH];
+T2DESC_AUXMAP   descPageMap[EXECMSG_POOL_DEPTH];
+
+uint32_t        msgID;
+
+
+/* Translate a CPSR into a SEC2 driver error                        */
+/* Notice that this does nothing with the error descriptor pointer, */
+/* this interface lacks a graceful means of handling it             */
+static int sec2xTranslateError(RMexecMessage *xmsg)
+{
+    int status = SEC2_UNKNOWN_ERROR;
+    u64 err;
+
+    /* Only the first word of errState is meaningful for Talitos */
+    /* All it contains is a saved copy of a CPSR, and we'll look */
+    /* at the error field alone for error information.           */
+
+    err = xmsg->errState[0] & T2_CPSR_ERROR_MASK;
+
+#ifdef SEC2_DBG_EXTENDED_ERROR
+    if (err)
+    {
+        printk("t23xsec2: error translation CPSR:0x%016llx\n", xmsg->errState[0]);
+        printk("                          pri EU:0x%016llx\n", xmsg->errState[2]);
+        printk("                          sec EU:0x%016llx\n", xmsg->errState[3]);
+    }
+#endif
+
+    /* if no value, OK, so return and skip translation */
+    if (!err)
+        return SEC2_SUCCESS;
+
+    if ((err & T2_CHN_ERROR_EU_ERROR) ||
+        (err & T2_CHN_ERROR_INVALID_EU) ||
+        (err & T2_CHN_ERROR_ILLEGAL_HEADER))
+        status = SEC2_CHA_ERROR;
+
+    if (err & T2_CHN_ERROR_FP_ZERO)
+        status = SEC2_INVALID_OPERATION_ID;
+
+    if (err & T2_CHN_ERROR_FP_ZERO)
+        status = SEC2_INCOMPLETE_POINTER;
+
+    if ((err & T2_CHN_ERROR_G_BOUNDARY) ||
+        (err & T2_CHN_ERROR_G_LENGTH) ||
+        (err & T2_CHN_ERROR_S_BOUNDARY) ||
+        (err & T2_CHN_ERROR_S_LENGTH) ||
+        (err & T2_CHN_ERROR_SG_ZERO_LEN))
+        status = SEC2_SCATTER_LIST_ERROR;
+
+    if (err & T2_CHN_ERROR_MDTE)
+        status = SEC2_BUS_MASTER_ERROR;
+
+    if ((err & T2_CHN_ERROR_DOF) ||
+        (err & T2_CHN_ERROR_SOF))
+        status = SEC2_FETCH_FIFO_OVERFLOW;
+
+    return status;
+}
+
+
+
+
+static RMexecMessage *getExecMsg(void)
+{
+    int i;
+
+    spin_lock(&excPoolLock);
+    for (i = 0; i < EXECMSG_POOL_DEPTH; i++)
+        if (msgInUse[i] == FALSE)
+        {
+            msgInUse[i] = TRUE;
+            spin_unlock(&excPoolLock);
+            return &excMsgPool[i];
+        }
+
+    spin_unlock(&excPoolLock);
+    return NULL;
+}
+
+static void freeExecMsg(RMexecMessage *execMsg)
+{
+    int i;
+
+    spin_lock(&excPoolLock);
+    for (i = 0; i < EXECMSG_POOL_DEPTH; i++)
+        if (execMsg == &excMsgPool[i])
+        {
+            msgInUse[i] = FALSE;
+            spin_unlock(&excPoolLock);
+            return;
+        }
+    spin_unlock(&excPoolLock);
+
+    return;
+}
+
+
+/* Release handler (callback) for a blocking request       */
+/* Invoked by the RM by reference out of a request message */
+static void sec2xBlockReleaseHandler(void *rqarg)
+{
+    volatile int *wasHere = rqarg;
+
+    *wasHere = BLOCK_RQ_DONE;
+}
+
+extern struct task_struct *find_task_by_vpid(pid_t nr);
+/* Release handler for completion of a non-blocking request */
+/* All notifiers and deallocations have to happen from here */
+static void sec2xAsyncReleaseHandler(void *msg)
+{
+    RMexecMessage      *thisMsg = msg;
+    GENERIC_REQ        *originalRQ;
+    int                 status;
+    struct task_struct *usertask;
+
+    releaseDPDlist(thisMsg, thisMsg->buftype);
+
+    originalRQ = (GENERIC_REQ *)thisMsg->initialRQ;
+
+    /* Translate error registers into something local */
+    status = sec2xTranslateError(thisMsg);
+
+    /* Do notifiers. If rqID has a PID, send signals */
+    if (status == SEC2_SUCCESS)
+    {
+        if (thisMsg->rqID)
+        {
+            usertask = find_task_by_vpid(thisMsg->rqID);
+            send_sig(thisMsg->sigval[0], usertask, 1);
+        }
+        else
+            if (originalRQ->notify != NULL)
+                originalRQ->notify(originalRQ->pNotifyCtx);
+    }
+    else
+    {
+        if (thisMsg->rqID)
+        {
+            usertask = find_task_by_vpid(thisMsg->rqID);
+            send_sig(thisMsg->sigval[1], usertask, 1);
+        }
+        else
+            if (originalRQ->notify_on_error != NULL)
+                originalRQ->notify_on_error(NULL);
+    }
+
+    /* free up resources */
+    freeExecMsg(thisMsg);
+}
+
+
+
+
+
+/**
+ * Initialize the legacy interface and connect it to the
+ * current resource manager
+ */
+int SEC2xDrvInit(void)
+{
+    RMstatus rmstatus;
+    int i, j;
+
+    /* Set up the exec message pool for this module */
+    for (i = 0; i < EXECMSG_POOL_DEPTH; i++)
+    {
+        excMsgPool[i].frameworkID            = XWC_FRAMEWORK_CURRENT_VERSION;
+        excMsgPool[i].descCount              = 0;
+        excMsgPool[i].errState[0]            = 0;
+        excMsgPool[i].errState[1]            = 0;
+        excMsgPool[i].errState[2]            = 0;
+        excMsgPool[i].errState[3]            = 0;
+        excMsgPool[i].errDesc                = NULL;
+        excMsgPool[i].messageReleaseHandler  = NULL;
+        excMsgPool[i].releaseArgument        = NULL;
+        excMsgPool[i].waitingTask            = NULL;
+        excMsgPool[i].queueISRHandler        = NULL;
+        excMsgPool[i].queueAuxHandler        = NULL;
+        excMsgPool[i].reservedQueue          = 0;
+        excMsgPool[i].descriptorDoneHandler  = NULL;
+        excMsgPool[i].descriptorErrorHandler = NULL;
+        excMsgPool[i].buftype                = 0;
+        excMsgPool[i].initialRQ              = NULL;
+        excMsgPool[i].rqID                   = 0;
+        excMsgPool[i].sigval[0]              = 0;
+        excMsgPool[i].sigval[1]              = 0;
+        excMsgPool[i].sigval[2]              = 0;
+        excMsgPool[i].sigval[3]              = 0;
+        excMsgPool[i].owningIF               = NULL;
+
+
+        excMsgPool[i].descHead      = kmalloc(sizeof(T2DPD) * T2_CHANNEL_FIFO_DEPTH, GFP_KERNEL | GFP_DMA);
+        excMsgPool[i].descBufferMap = &descPageMap[i];
+
+        if (excMsgPool[i].descHead == NULL)
+        {
+            printk("t23xsec2: can't get descriptor buffers\n");
+            for (j = i - 1; j > -1; j--)
+                kfree(excMsgPool[i].descHead);
+
+            return -1;
+        }
+    }
+    spin_lock_init(&excPoolLock);
+
+    /* register with the RM */
+    rmstatus = xwcRMregisterInterface("t23xsec2", &ifctx);
+    if (rmstatus != RM_OK)
+    {
+        printk("t23xsec2: can't register interface, error %d\n", rmstatus);
+        return -1;
+    }
+
+#ifdef SEC2_DBG_INFO
+    printk("Extensible Crypto Driver - SEC2.x Legacy Interface - pkg rev %s\n", T23X_PACKAGE_VERSION);
+#endif
+
+    return 0;
+}
+
+
+
+
+/**
+ * Disconnect this interface
+ */
+
+int SEC2xShutdown(void)
+{
+    RMstatus rmstatus;
+    int      i;
+    /* Cancel any pending requests!!!! */
+
+    /* Release local resources */
+    for (i = 0; i < EXECMSG_POOL_DEPTH; i++)
+        kfree(excMsgPool[i].descHead);
+
+    /* Deregister from the RM */
+    rmstatus = xwcRMderegisterInterface(ifctx);
+    if (rmstatus != RM_OK)
+    {
+        printk("t2xsec2: can't deregister this interface, error %d\n", rmstatus);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+/**
+ * Open a new path and make it known to this IF
+ */
+int SEC2xOpen(struct inode *nd, struct file *fil)
+{
+
+
+    return SEC2_SUCCESS;
+}
+
+
+/**
+ * Close an open path
+ */
+int SEC2xClose(struct inode *nd, struct file *fil)
+{
+
+    /* nothing needed here... */
+    return SEC2_SUCCESS;
+}
+
+
+
+
+/**
+ * ioctl() entry point from the I/O manager
+ *
+ */
+int SEC2xIoctl(struct inode  *nd,
+               struct file   *fil,
+               unsigned int   code,
+               unsigned long  param)
+{
+    int               status;
+    RQ_TYPE           rqType;
+    RMstatus          rmstat;
+    RMexecMessage    *localMsg;
+    wait_queue_head_t wq;
+    wait_queue_t      wqent;
+    volatile int      blockst;
+    int               i;
+    MALLOC_REQ       *mem;
+    KBUF_MULTI       *kbm;
+    PTRTYPE           memtype;
+
+
+    status = SEC2_SUCCESS;
+
+    switch (code)
+    {
+
+        /* standard request type */
+        case IOCTL_PROC_REQ:
+        case IOCTL_PROC_REQ_VIRTUAL:
+
+            /* Check the param block */
+            if (param == (int)NULL)
+            {
+                status = SEC2_INVALID_ADDRESS;
+                break;
+            }
+
+            /* Figure out the memory type we have to deal with */
+            /* If virtual specified, we have to figure out which type */
+            if (code == IOCTL_PROC_REQ_VIRTUAL)
+                if (fil == NULL)
+                    memtype = PTR_KERNEL_VIRTUAL;
+                else
+                    memtype = PTR_USER_VIRTUAL;
+            else
+                memtype = PTR_LOGICAL;
+
+            /* Allocate a request message from the "pool" */
+            localMsg = getExecMsg();
+            if (localMsg == NULL)
+                return SEC2_INSUFFICIENT_REQS;
+
+            /* Construct a list of descriptors from the input */
+            status = constructDPDlist((GENERIC_REQ *)param, localMsg, memtype);
+            if (status != SEC2_SUCCESS)
+                return status;
+
+            /* Set up completion handlers here. For a non-blocking */
+            /* request like this, we have to do all releasing from */
+            /* inside the handler itself, because this function    */
+            /* may exit before the request completes               */
+            localMsg->messageReleaseHandler = sec2xAsyncReleaseHandler;
+            localMsg->releaseArgument       = localMsg;
+            localMsg->buftype               = (uint8_t)memtype;
+
+            /* Save off parameter block, process ID, signal values */
+            localMsg->initialRQ             = (void *)param;
+            if (fil != NULL)
+            {
+                localMsg->rqID                  = current->pid;
+                localMsg->sigval[0]             = (int)(((GENERIC_REQ *)param)->notify);
+                localMsg->sigval[1]             = (int)(((GENERIC_REQ *)param)->notify_on_error);
+            }
+            else
+                localMsg->rqID = 0;
+
+            /* Set the RM to processing our request */
+            rmstat = xwcRMqueueRequest(ifctx, localMsg, &msgID);
+
+            /* report error if the RM no can do... */
+            if (rmstat)
+            {
+                printk("t23xsec2:ioctl() - error 0x%08x from RM, request not initiated\n", rmstat);
+                status = SEC2_UNKNOWN_ERROR;
+                releaseDPDlist(localMsg, memtype);
+                freeExecMsg(localMsg);
+            }
+
+            /* Return status to the user and go home. If queueRequest()   */
+            /* worked OK, now it's processing, and it's up to the release */
+            /* handler to free resources and translate/report errors      */
+            return status;
+            break;
+
+
+        /* blocking request types, should ONLY come from usermode */
+        case IOCTL_PROC_REQ_BLOCK:
+        case IOCTL_PROC_REQ_BLOCK_VIRTUAL:
+            /* check the presence of a param block */
+            if (param == (int)NULL)
+            {
+                status = SEC2_INVALID_ADDRESS;
+                break;
+            }
+
+            if (fil == NULL) /* only valid from usermode */
+            {
+                status = SEC2_INVALID_REQUEST_MODE;
+                break;
+            }
+            else
+                rqType = RQ_USER_BLOCK;
+
+            if (code == IOCTL_PROC_REQ_BLOCK_VIRTUAL)
+                memtype = PTR_USER_VIRTUAL;
+            else
+                memtype = PTR_LOGICAL;
+
+            /* Allocate a request message from the "pool" */
+            localMsg = getExecMsg();
+            if (localMsg == NULL)
+                return SEC2_INSUFFICIENT_REQS;
+
+            /* Construct a list of descriptors from the input */
+            status = constructDPDlist((GENERIC_REQ *)param, localMsg, memtype);
+            if (status != SEC2_SUCCESS)
+                return status;
+
+            /* Set up completion action & waitqueue entry for this request */
+            blockst                         = BLOCK_RQ_PENDING;
+            localMsg->messageReleaseHandler = sec2xBlockReleaseHandler;
+            localMsg->releaseArgument       = (void *)&blockst;
+
+            init_waitqueue_head(&wq);
+            init_waitqueue_entry(&wqent, current);
+            add_wait_queue(&wq, &wqent);
+            localMsg->waitingTask = &wq;
+            set_current_state(TASK_INTERRUPTIBLE);
+
+            /* Pass constructed request off to the RM for processing */
+            rmstat = xwcRMqueueRequest(ifctx, localMsg, &msgID);
+
+            /* report error, else spin on the waitqueue */
+            if (rmstat)
+            {
+                status = SEC2_UNKNOWN_ERROR; /* worst case error */
+                if (rmstat == RM_NO_CAPABILITY)     /* maybe no such CHA? */
+                    status = SEC2_INVALID_CHA_TYPE;
+                set_current_state(TASK_RUNNING);
+            }
+            else
+            {
+                while(1)
+                {
+                    set_current_state(TASK_INTERRUPTIBLE);
+                    if (blockst == BLOCK_RQ_PENDING)
+                        schedule();
+                    else
+                        break;
+                }
+                set_current_state(TASK_RUNNING);
+            }
+
+            /* Release the DPD list. */
+            releaseDPDlist(localMsg, memtype);
+
+            /* If error from the waitqueue hold, return it */
+            if (status)
+                return status;
+
+            /* If no error from the waitqueue hold, then check our exec */
+            /* message for error registers, and translate */
+            if (!status)
+                status = sec2xTranslateError(localMsg);
+
+            /* all done with this exec msg */
+            freeExecMsg(localMsg);
+            return status;
+
+            break;
+
+        case IOCTL_GET_STATUS:
+            status = SEC2_UNIMPLEMENTED;
+            break;
+
+        case IOCTL_RESERVE_CHANNEL_STATIC:
+#ifdef UNIMPLEMENTED
+            status = ReserveChannelStatic((unsigned char *)param,
+                    (int)taskIdSelf());
+#endif
+            status = SEC2_UNIMPLEMENTED;
+            break;
+
+        case IOCTL_RELEASE_CHANNEL:
+#ifdef UNIMPLEMENTED
+            status = ReleaseChannel(*(unsigned char *)param, (int)taskIdSelf(), FALSE);
+#endif
+            status = SEC2_UNIMPLEMENTED;
+            break;
+
+
+        case IOCTL_MALLOC:
+            if ((((MALLOC_REQ *)param)->ptr =
+                        kmalloc(((MALLOC_REQ *)param)->sz, GFP_KERNEL | GFP_DMA)) == 0)
+            {
+                status = SEC2_MALLOC_FAILED;
+                break;
+            }
+            memset(((MALLOC_REQ *)param)->ptr, 0, ((MALLOC_REQ *)param)->sz);
+            status = SEC2_SUCCESS;
+            break;
+
+        case IOCTL_COPYFROM:
+            mem = (MALLOC_REQ *)param;
+            mem->pid = current->pid;
+            copy_from_user(mem->to, mem->from, mem->sz);
+            status = SEC2_SUCCESS;
+            break;
+
+        case IOCTL_COPYTO:
+            mem = (MALLOC_REQ *)param;
+            mem->pid = current->pid;
+            copy_to_user(mem->to, mem->from, mem->sz);
+            status = SEC2_SUCCESS;
+            break;
+
+        case IOCTL_FREE:
+            kfree((void *)param);
+            break;
+
+        case IOCTL_KBUF_MULTI_PUSH:
+            kbm = (KBUF_MULTI *)param;
+            for (i = 0; i < MAX_PAIRS; i++)
+            {
+                if ((kbm->pair[i].local != NULL) &&
+                        (kbm->pair[i].kbuf != NULL) &&
+                        (kbm->pair[i].size > 0))
+                    copy_from_user(kbm->pair[i].kbuf,   /* destination */
+                            kbm->pair[i].local,  /* source      */
+                            kbm->pair[i].size);
+            }
+            break;
+
+        case IOCTL_KBUF_MULTI_PULL:
+            kbm = (KBUF_MULTI *)param;
+            for (i = 0; i < MAX_PAIRS; i++)
+            {
+                if ((kbm->pair[i].local != NULL) &&
+                        (kbm->pair[i].kbuf != NULL) &&
+                        (kbm->pair[i].size > 0))
+                    copy_to_user(kbm->pair[i].local,   /* destination */
+                            kbm->pair[i].kbuf,    /* source      */
+                            kbm->pair[i].size);
+            }
+            break;
+
+        case IOCTL_KBUF_MULTI_ALLOC:
+            kbm = (KBUF_MULTI *)param;
+            for (i = 0; i < MAX_PAIRS; i++)
+            {
+                /* If size spec'ed nonzero, allocate buffer */
+                if (kbm->pair[i].size)
+                {
+                    kbm->pair[i].kbuf = kmalloc(kbm->pair[i].size, GFP_KERNEL | GFP_DMA);
+                    /* If allocate error, unwind any other allocs and exit */
+                    if (kbm->pair[i].kbuf == NULL)
+                    {
+                        while (i >= 0)
+                        {
+                            if (kbm->pair[i].kbuf != NULL)
+                                kfree(kbm->pair[i].kbuf);
+                            i--;
+                        }
+                        status = SEC2_MALLOC_FAILED;
+                        break;
+                    } /* end allocation error */
+                } /* end if (nonzero size) */
+            }
+            status = SEC2_SUCCESS;
+            break;
+
+
+        case IOCTL_KBUF_MULTI_FREE:
+            kbm = (KBUF_MULTI *)param;
+            for (i = 0; i < MAX_PAIRS; i++)
+                if (kbm->pair[i].kbuf != NULL)
+                    kfree(kbm->pair[i].kbuf);
+            break;
+
+
+
+        case IOCTL_INSTALL_AUX_HANDLER:
+#ifdef UNIMPLEMENTED
+            chan = ((AUX_HANDLER_SPEC *)param)->channel;
+            /* see if requested channel is valid */
+            if ((chan <= 0) || (chan > TotalChannels))
+            {
+                status = SEC2_INVALID_CHANNEL;
+                break;
+            }
+
+            /* channel is valid, is it reserved (and not busy)? */
+            if (ChannelAssignments[chan - 1].assignment != CHANNEL_STATIC_ASSIGNED)
+            {
+                status = SEC2_CHANNEL_NOT_AVAILABLE;
+                break;
+            }
+
+
+            /* Channel spec is in range, and is reserved for use. Notice that */
+            /* we really don't have any good means to identify the requestor  */
+            /* for validity (could be the kernel itself), so will assume that */
+            /* channel ownership is not an issue. Now register/remove the     */
+            /* handler                                                        */
+
+            ChannelAssignments[chan - 1].auxHandler = ((AUX_HANDLER_SPEC *)param)->auxHandler;
+#endif
+            status = SEC2_UNIMPLEMENTED;
+            break;
+
+    } /* switch (code) */
+
+
+    return status;
+}
+
+
+
+
+/* Equivalence symbol to mimic the entry point of the old driver */
+int SEC2_ioctl(struct inode  *nd,
+               struct file   *fil,
+               unsigned int   code,
+               unsigned long  param)
+{
+    return(SEC2xIoctl(nd, fil, code, param));
+}
diff --git a/drivers/crypto/t23x/t23xsec2/t23xsec2mod.c b/drivers/crypto/t23x/t23xsec2/t23xsec2mod.c
new file mode 100644
index 0000000..293d997
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/t23xsec2mod.c
@@ -0,0 +1,127 @@
+
+/*
+ * t23xsec2mod.c
+ *
+ * Linux specific driver module initialization for SEC2.x legacy
+ * compatibility module
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+
+/* Includes for SEC2 legacy interfaces */
+#include "Sec2.h"
+#include "Sec2local.h"
+
+extern int SEC2xOpen(struct inode *nd, struct file *fil);
+extern int SEC2xClose(struct inode *nd, struct file *fil);
+extern int SEC2xIoctl(struct inode  *nd,
+                      struct file   *fil,
+                      unsigned int   code,
+                      unsigned long  param);
+extern int SEC2_ioctl(struct inode  *nd,
+                      struct file   *fil,
+                      unsigned int   code,
+                      unsigned long  param);
+extern int SEC2xDrvInit(void);
+extern int SEC2xShutdown(void);
+
+
+dev_t           sec2x_devmajor;
+
+
+
+/** fopts struct from device registration */
+struct file_operations SEC2x_fopts = {
+    .open    = SEC2xOpen,
+    .release = SEC2xClose,
+    .ioctl   = SEC2xIoctl,
+};
+
+static int __init SEC2xInit(void)
+{
+    int rtstat;
+
+
+    /* Notice that this registers a device major number dynamically, but it */
+    /* leaves the node to the user to create...                             */
+
+    rtstat = register_chrdev(SEC2X_DEVMAJOR, SEC2X_DEVNAME, &SEC2x_fopts);
+
+    if (rtstat < 0)
+    {
+        printk(KERN_WARNING "t23xsec2: can't register driver, fatal\n");
+        return rtstat;
+    }
+
+    if (SEC2X_DEVMAJOR == 0) /* if no specific major requested, and there was no error above */
+        sec2x_devmajor = rtstat; /* set the dynamic number */
+
+    /* Now go init */
+    rtstat = SEC2xDrvInit();
+    if (rtstat < 0)
+        unregister_chrdev(sec2x_devmajor, SEC2X_DEVNAME);
+
+    return rtstat;
+}
+
+
+static void __exit SEC2xExit(void)
+{
+
+    SEC2xShutdown();
+
+    unregister_chrdev(sec2x_devmajor, SEC2X_DEVNAME);
+}
+
+
+EXPORT_SYMBOL (SEC2xIoctl);
+EXPORT_SYMBOL (SEC2_ioctl);
+EXPORT_SYMBOL (MarkScatterBuffer);
+
+module_init(SEC2xInit);
+module_exit(SEC2xExit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Extensible Crypto Driver - SEC 2.x Legacy Interface");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/t23x/t23xsec2/t2dpd.c b/drivers/crypto/t23x/t23xsec2/t2dpd.c
new file mode 100644
index 0000000..37d6bd9
--- /dev/null
+++ b/drivers/crypto/t23x/t23xsec2/t2dpd.c
@@ -0,0 +1,4184 @@
+/*
+ * t2dpd.c
+ *
+ * t23x SEC2.x legacy interface
+ * REQ-to-descriptor translation interface
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - add SNOW-3G support
+ *
+ */
+
+
+
+/** @file
+ * Constructs packet descriptors for the legacy driver interface
+ * for Talitos 2/3
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/page.h>
+
+#include "../common/xwcRMinterface.h"
+#include "../t23xrm/t23xrmInternal.h"
+#include "Sec2.h"
+#include "Sec2local.h"
+
+
+/**
+ * Header constants for AESA_CRYPT_REQ / DPD_AESA_CRYPT_GROUP
+ * Note that CCM and SRT modes are not handled by this request type,
+ * they are deployed in the SRTP and CCMP request types.
+ */
+
+const unsigned long AesaDesc[1*NUM_AESA_CRYPT_DESC] = {
+    /* DPD_AESA_CBC_ENCRYPT_CRYPT     OpId 0x6000 */
+    /* CM = 1 (cbc), encrypt on                   */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60300010,                                */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CBC_DECRYPT_CRYPT     OpId 0x6001 */
+    /* CM = 1 (cbc), encrypt off                  */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60200010,                                */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CBC_DECRYPT_CRYPT_RDK OpId 0x6002 */
+    /* RDK = noexpand, CM = 1 (cbc), encrypt off  */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60a00010,                                */
+    ((EU_AES | AES_DECRYPT | AES_CBC | AES_RDK) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_ECB_ENCRYPT_CRYPT     OpId 0x6003 */
+    /* CM = 0 (ecb), encrypt on                   */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60100010,                                */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_ECB_DECRYPT_CRYPT     OpId 0x6004 */
+    /* CM = 0 (ecb), encrypt off                  */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60000010,                                */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_ECB_DECRYPT_CRYPT_RDK OpId 0x6005 */
+    /* RDK = noexpand, CM = 1 (ecb), encrypt off  */
+    /* desc type = 2 (common, nosnoop)            */
+    /* 0x60800010,                                */
+    ((EU_AES | AES_DECRYPT | AES_ECB | AES_RDK) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CTR_CRYPT             OpId 0x6006 */
+    /* CM = 2 (ctr), encrypt off                  */
+    /* desc type = 0 (aesa_ctr, nosnoop)          */
+    /* 0x60600000,                                */
+    ((EU_AES | AES_CTR) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_CTR | HDR_OUTBOUND,
+
+    /* DPD_AESA_CTR_HMAC              OpId 0x6007 */
+    /* CM = 2 (ctr), encrypt off                  */
+    /* desc type = 24 (aesa_ctr_HMAC-snoop)       */
+    /* 0x606000c0,                                */
+    ((EU_AES | AES_CTR) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_CBC_RBP_ENCRYPT       OpId 0x6008 */
+    ((EU_AES | AES_CBC_RBP | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CBC_RBP_DECRYPT       OpId 0x6009 */
+    ((EU_AES | AES_CBC_RBP | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_OFB_ENCRYPT           OpId 0x600a */
+    ((EU_AES | AES_CBC_OFB | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_OFB_DECRYPT           OpId 0x600b */
+    ((EU_AES | AES_CBC_OFB | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CFB128_ENCRYPT        OpId 0x600c */
+    ((EU_AES | AES_CFB128 | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CFB128_DECRYPT        OpId 0x600d */
+    ((EU_AES | AES_CFB128 | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CCM_ENCRYPT           OpId 0x600e */
+    ((EU_AES | AES_CCM | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_CCM_DECRYPT           OpId 0x600f */
+    ((EU_AES | AES_CCM | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_CCM_FINAL_ENCRYPT     OpId 0x6010 */
+    ((EU_AES | AES_CCM_FMAC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_CCM_FINAL_DECRYPT     OpId 0x6011 */
+    ((EU_AES | AES_CCM_FMAC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_CCM_FINAL_DECRYPT_CMP OpId 0x6012 */
+    ((EU_AES | AES_CCM_FMAC | AES_RDK | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_LRW_ENCRYPT           OpId 0x6013 */
+    ((EU_AES | AES_LRW | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_LRW_NO_TWEAK_ENCRYPT  OpId 0x6014 */
+    ((EU_AES | AES_LRW_NO_TWEAK | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_LRW_DECRYPT           OpId 0x6015 */
+    ((EU_AES | AES_LRW | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+    /* DPD_AESA_LRW_NO_TWEAK_DECRYPT  OpId 0x6016 */
+    ((EU_AES | AES_LRW_NO_TWEAK | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_AES_HMAC | HDR_OUTBOUND,
+
+};
+
+
+
+const unsigned long AesaMACDesc[1*NUM_AESA_MAC_DESC] = {
+    /* DPD_AESA_CMAC                  OpId 0x6100 */
+    ((EU_AES | AES_CMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_CMAC_CMP              OpId 0x6101 */
+    ((EU_AES | AES_CMAC_ICV | AES_RDK) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_XCBCMAC               OpId 0x6102 */
+    ((EU_AES | AES_XCBC_MAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_AESA_XCBCMAC_CMP           OpId 0x6103 */
+    ((EU_AES | AES_XCBC_MAC_ICV | AES_RDK) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_OUTBOUND
+};
+
+
+const unsigned long AesaGCMDesc[1*NUM_AESA_GCM_DESC] = {
+    /* DPD_AESA_GCM_ENCRYPT           OpId 0x6300 */
+    ((EU_AES | AES_GCM | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_IPSEC_AES_GCM | HDR_OUTBOUND,
+
+    /* DPD_AESA_GCM_DECRYPT           OpId 0x6301 */
+    ((EU_AES | AES_GCM | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_IPSEC_AES_GCM | HDR_OUTBOUND,
+
+    /* DPD_AESA_GCM_FINAL_ENCRYPT     OpId 0x6302 */
+    ((EU_AES | AES_GCM_FMAC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_IPSEC_AES_GCM | HDR_OUTBOUND,
+
+    /* DPD_AESA_GCM_FINAL_DECRYPT     OpId 0x6303 */
+    ((EU_AES | AES_GCM_FMAC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_IPSEC_AES_GCM | HDR_OUTBOUND,
+
+    /* DPD_AESA_GCM_FINAL_DECRYPT_CMP OpId 0x6304 */
+    ((EU_AES | AES_GCM_FMAC | AES_RDK | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_IPSEC_AES_GCM | HDR_OUTBOUND,
+};
+
+
+
+/**
+ * Header constants for RNG_REQ / DPD_RNG_GROUP
+ */
+
+const unsigned long RngDesc[1*NUM_RNGA_DESC] = {
+    /* DPD_RNG_GETRN Req OpId 0x1000 */
+    /* 0x40000010                    */
+    (EU_RND << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON
+};
+
+
+
+/**
+ * Header constants for DES_CBC_CRYPT_REQ / DPD_DES_CBC_GROUP
+ */
+
+const unsigned long DesCbcReq[1 * NUM_DES_CBC_DESC] = {
+    /* DPD_SDES_CBC_CTX_ENCRYPT              OpId 0x2500 */
+    ((EU_DES | DES_SINGLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_CBC_CTX_DECRYPT              OpId 0x2501 */
+    ((EU_DES | DES_SINGLE | DES_CBC | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_CBC_CTX_ENCRYPT              OpId 0x2502 */
+    ((EU_DES | DES_TRIPLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_CBC_CTX_DECRYPT              OpId 0x2503 */
+    ((EU_DES | DES_TRIPLE | DES_CBC | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_CFB_64_CTX_ENCRYPT           OpId 0x2508 */
+    ((EU_DES | DES_SINGLE | DES_CFB_64 | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_CFB_64_CTX_DECRYPT           OpId 0x2509 */
+    ((EU_DES | DES_SINGLE | DES_CFB_64 | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_CFB_64_CTX_ENCRYPT           OpId 0x250a */
+    ((EU_DES | DES_TRIPLE | DES_CFB_64 | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_CFB_64_CTX_DECRYPT           OpId 0x250b */
+    ((EU_DES | DES_TRIPLE | DES_CFB_64 | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_OFB_64_CTX_ENCRYPT           OpId 0x250c */
+    ((EU_DES | DES_SINGLE | DES_OFB_64 | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_OFB_64_CTX_DECRYPT           OpId 0x250d */
+    ((EU_DES | DES_SINGLE | DES_OFB_64 | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_OFB_64_CTX_ENCRYPT           OpId 0x250e */
+    ((EU_DES | DES_TRIPLE | DES_OFB_64 | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_OFB_64_CTX_DECRYPT           OpId 0x250f */
+    ((EU_DES | DES_TRIPLE | DES_OFB_64 | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+};
+
+
+
+
+/**
+ * Header constants for DES_CRYPT_REQ / DPD_DES_ECB_GROUP
+ */
+
+const unsigned long DesReq[1*NUM_DES_DESC] = {
+    /* DPD_SDES_ECB_ENCRYPT Req OpId 0x2600 */
+    /* 0x20100010,                          */
+    ((EU_DES | DES_SINGLE | DES_ECB | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SDES_ECB_DECRYPT Req OpId 0x2601 */
+    /* 0x20000010,                          */
+    ((EU_DES | DES_SINGLE | DES_ECB | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_ECB_ENCRYPT Req OpId 0x2602 */
+    /* 0x20300010,                          */
+    ((EU_DES | DES_TRIPLE | DES_ECB | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_TDES_ECB_DECRYPT Req OpId 0x2603 */
+    /* 0x20200010                           */
+    ((EU_DES | DES_TRIPLE | DES_ECB | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+};
+
+
+
+
+/**
+ * Header constants for
+ * ARC4_LOADCTX_CRYPT_REQ / DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP
+ */
+
+const unsigned long Rc4LoadCtxUnloadCtxReq[1*NUM_RC4_LOADCTX_UNLOADCTX_DESC] = {
+    /* DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP OpId 0x3400 */
+    /* 0x10700050                                  */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_ARC4
+};
+
+
+
+/**
+ * Header constants for
+ * ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ / DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP
+ */
+const unsigned long Rc4LoadKeyUnloadCtxReq[1*NUM_RC4_LOADKEY_UNLOADCTX_DESC] = {
+    /* DPD_RC4_LDKEY_CRYPT_ULCTX Req OpId 0x3500 */
+    /* 0x10200050                                */
+    ((EU_ARC4 | ARC4_DUMP_CONTEXT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_ARC4
+};
+
+
+
+/**
+ * Header constants for HASH_REQ / DPD_HASH_LDCTX_HASH_ULCTX_GROUP
+ */
+const unsigned long MdhaReq[1 * NUM_MDHA_DESC] = {
+    /* DPD_SHA256_LDCTX_HASH_ULCTX          OpId 0x4400 */
+    /* SHA-256                                          */
+    /* 0x30100010,                                      */
+    ((EU_MD | MD_SHA256) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_HASH_ULCTX             OpId 0x4401 */
+    /* MD-5                                             */
+    /* 0x30200010,                                      */
+    ((EU_MD | MD_MD5) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_HASH_ULCTX             OpId 0x4402 */
+    /* SHA-1                                            */
+    /* 0x30000010,                                      */
+    ((EU_MD | MD_SHA1) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_IDGS_HASH_ULCTX     OpId 0x4403 */
+    /* SHA-256, CONT, INIT                              */
+    /* 0x39100010,                                      */
+    ((EU_MD | MD_SHA256 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_IDGS_HASH_ULCTX        OpId 0x4404 */
+    /* MD-5, CONT, INIT                                 */
+    /* 0x39200010,                                      */
+    ((EU_MD | MD_MD5 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_IDGS_HASH_ULCTX        OpId 0x4405 */
+    /* SHA-1, CONT, INIT                                */
+    /* 0x39000010,                                      */
+    ((EU_MD | MD_SHA1 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_CONT_HASH_ULCTX           OpId 0x4406 */
+    /* SHA256, CONT                                     */
+    /* 0x38100010,                                      */
+    ((EU_MD | MD_SHA256 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_CONT_HASH_ULCTX              OpId 0x4407 */
+    /* MD-5, CONT                                       */
+    /* 0x38200010,                                      */
+    ((EU_MD | MD_MD5 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_CONT_HASH_ULCTX              OpId 0x4408 */
+    /* SHA-1, CONT                                      */
+    /* 0x38000010,                                      */
+    ((EU_MD | MD_SHA1 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_HASH_ULCTX          OpId 0x4409 */
+    /* SHA-224                                          */
+    /* 0x30300010,                                      */
+    ((EU_MD | MD_SHA224) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_IDGS_HASH_ULCTX     OpId 0x440a */
+    /* SHA224, CONT, INIT                               */
+    /* 0x39300010,                                      */
+    ((EU_MD | MD_SHA224 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_CONT_HASH_ULCTX           OpId 0x440b */
+    /* SHA-224, CONT                                    */
+    /* 0x38300010,                                      */
+    ((EU_MD | MD_SHA224 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_HASH_ULCTX_CMP      OpId 0x440c */
+    /* SHA-256, CICV                                    */
+    /* 0x34100012,                                      */
+    ((EU_MD | MD_SHA256 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_HASH_ULCTX_CMP         OpId 0x440d */
+    /* MD-5, CICV                                       */
+    /* 0x34200012,                                      */
+    ((EU_MD | MD_MD5 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_HASH_ULCTX_CMP         OpId 0x440e */
+    /* SHA-1, CICV                                      */
+    /* 0x34000012,                                      */
+    ((EU_MD | MD_SHA1 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA256_LDCTX_IDGS_HASH_ULCTX_CMP OpId 0x440f */
+    /* SHA-256, CONT, INIT, CICV                        */
+    /* 0x3d100012,                                      */
+    ((EU_MD | MD_SHA256 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_IDGS_HASH_ULCTX_CMP    OpId 0x4410 */
+    /* MD-5, CONT, INIT, CICV                           */
+    /* 0x3d200012,                                      */
+    ((EU_MD | MD_MD5 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_IDGS_HASH_ULCTX_CMP    OpId 0x4411 */
+    /* SHA-1, CONT, INIT, CICV                          */
+    /* 0x3d000012,                                      */
+    ((EU_MD | MD_SHA1 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_HASH_ULCTX_CMP      OpId 0x4412 */
+    /* SHA-224, CICV                                    */
+    /* 0x34300012,                                      */
+    ((EU_MD | MD_SHA224 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_IDGS_HASH_ULCTX_CMP OpId 0x4413 */
+    /* SHA224, CONT, INIT, CICV                         */
+    /* 0x3d300012,                                      */
+    ((EU_MD | MD_SHA224 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_HASH_ULCTX          OpId 0x4414 */
+    ((EU_MDPRIME | MD_SHA384) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_IDGS_HASH_ULCTX     OpId 0x4415 */
+    ((EU_MDPRIME | MD_SHA384 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_CONT_HASH_ULCTX           OpId 0x4416 */
+    ((EU_MDPRIME | MD_SHA384 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_HASH_ULCTX_CMP      OpId 0x4417 */
+    ((EU_MDPRIME | MD_SHA384 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_IDGS_HASH_ULCTX_CMP OpId 0x4418 */
+    ((EU_MDPRIME | MD_SHA384 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_HASH_ULCTX          OpId 0x4419 */
+    ((EU_MDPRIME | MD_SHA512) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_IDGS_HASH_ULCTX     OpId 0x441a */
+    ((EU_MDPRIME | MD_SHA512 | MD_CONT | MD_INIT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_CONT_HASH_ULCTX           OpId 0x441b */
+    ((EU_MDPRIME | MD_SHA512 | MD_CONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_HASH_ULCTX_CMP      OpId 0x441c */
+    ((EU_MDPRIME | MD_SHA512 | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_IDGS_HASH_ULCTX_CMP OpId 0x441d */
+    ((EU_MDPRIME | MD_SHA512 | MD_CONT | MD_INIT | MD_CICV) << EU_SHIFT_PRIMARY)
+        | DESCTYPE_COMMON | HDR_INBOUND,
+
+};
+
+
+/**
+ * Header constants for HASH_REQ / DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP
+ */
+const unsigned long MdhaPadReq[1 * NUM_MDHA_PAD_DESC] = {
+    /* DPD_SHA256_LDCTX_HASH_PAD_ULCTX          OpId 0x4500 */
+    /* SHA-256, PD                                          */
+    /* 0x30500010,                                          */
+    ((EU_MD | MD_SHA256 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_HASH_PAD_ULCTX             OpId 0x4501 */
+    /* MD-5, PD                                             */
+    /* 0x30600010,                                          */
+    ((EU_MD | MD_MD5 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_HASH_PAD_ULCTX             OpId 0x4502 */
+    /* SHA-1, PD                                            */
+    /* 0x30400010,                                          */
+    ((EU_MD | MD_SHA1 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_IDGS_HASH_PAD_ULCTX     OpId 0x4503 */
+    /* SHA-256, PD, INIT                                    */
+    /* 0x31500010,                                          */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_IDGS_HASH_PAD_ULCTX        OpId 0x4504 */
+    /* MD-5, PD, INIT                                       */
+    /* 0x31600010,                                          */
+    ((EU_MD | MD_MD5 | MD_INIT  | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_IDGS_HASH_PAD_ULCTX        OpId 0x4505 */
+    /* SHA-1, PD, INIT                                      */
+    /* 0x31400010,                                          */
+    ((EU_MD | MD_SHA1 | MD_INIT  | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_HASH_PAD_ULCTX          OpId 0x4506 */
+    /* SHA-224, PD                                          */
+    /* 0x30700010,                                          */
+    ((EU_MD | MD_SHA224 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_IDGS_HASH_PAD_ULCTX     OpId 0x4507 */
+    /* SHA-224, PD, INIT                                    */
+    /* 0x31700010,                                          */
+    ((EU_MD | MD_SHA224 | MD_INIT  | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_HASH_PAD_ULCTX_CMP      OpId 0x4508 */
+    /* SHA-256, PD, CICV                                    */
+    /* 0x34500012,                                          */
+    ((EU_MD | MD_SHA256 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_HASH_PAD_ULCTX_CMP         OpId 0x4509 */
+    /* MD-5, PD, CICV                                       */
+    /* 0x34600012,                                          */
+    ((EU_MD | MD_MD5 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_HASH_PAD_ULCTX_CMP         OpId 0x450a */
+    /* SHA-1, PD, CICV                                      */
+    /* 0x34400012,                                          */
+    ((EU_MD | MD_SHA1 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA256_LDCTX_IDGS_HASH_PAD_ULCTX_CMP OpId 0x450b */
+    /* SHA-256, PD, INIT, CICV                              */
+    /* 0x35500012,                                          */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_IDGS_HASH_PAD_ULCTX_CMP    OpId 0x450c */
+    /* MD-5, PD, INIT, CICV                                 */
+    /* 0x35600012,                                          */
+    ((EU_MD | MD_MD5 | MD_INIT | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_IDGS_HASH_PAD_ULCTX_CMP    OpId 0x450d */
+    /* SHA-1, PD, INIT, CICV                                */
+    /* 0x35400012,                                          */
+    ((EU_MD | MD_SHA1 | MD_INIT | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_HASH_PAD_ULCTX_CMP      OpId 0x450e */
+    /* SHA-224, PD, CICV                                    */
+    /* 0x34700012,                                          */
+    ((EU_MD | MD_SHA224 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_IDGS_HASH_PAD_ULCTX_CMP OpId 0x450f */
+    /* SHA-224, PD, INIT                                    */
+    /* 0x35700012,                                          */
+    ((EU_MD | MD_SHA224 | MD_INIT | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_HASH_PAD_ULCTX          OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA384 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_IDGS_HASH_PAD_ULCTX     OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_HASH_PAD_ULCTX_CMP      OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA384 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_IDGS_HASH_PAD_ULCTX_CMP OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_HASH_PAD_ULCTX          OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA512 | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_IDGS_HASH_PAD_ULCTX     OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_HASH_PAD_ULCTX_CMP      OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA512 | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_IDGS_HASH_PAD_ULCTX_CMP OpId 0x4510 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_CICV | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+};
+
+
+
+/**
+ * Header constants for HMAC_PAD_REQ / DPD_HASH_LDCTX_HMAC_ULCTX_GROUP
+ */
+
+const unsigned long HmacPadReq[1 * NUM_HMAC_PAD_DESC] = {
+    /* DPD_SHA256_LDCTX_HMAC_ULCTX             OpId 0x4a00 */
+    /* SHA-256, INIT, HMAC                                 */
+    /* 0x31900010,                                         */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_HMAC_ULCTX                OpId 0x4a01 */
+    /* MD-5, INIT, HMAC                                    */
+    /* 0x31A00010,                                         */
+    ((EU_MD | MD_MD5 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_HMAC_ULCTX                OpId 0x4a02 */
+    /* SHA-1, INIT, HMAC                                   */
+    /* 0x31800010,                                         */
+    ((EU_MD | MD_SHA1 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_HMAC_PAD_ULCTX         OpId 0x4a03 */
+    /* SHA-256, INIT, HMAC, PD                             */
+    /* 0x31D00010,                                         */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_MD5_LDCTX_HMAC_PAD_ULCTX            OpId 0x4a04 */
+    /* MD-5, INIT, HMAC, PD                                */
+    /* 0x31E00010,                                         */
+    ((EU_MD | MD_MD5 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA_LDCTX_HMAC_PAD_ULCTX            OpId 0x4a05 */
+    /* SHA-1, INIT, HMAC, PD                               */
+    /* 0x31C00010,                                         */
+    ((EU_MD | MD_SHA1 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_HMAC_ULCTX             OpId 0x4a06 */
+    /* SHA-224, INIT, HMAC                                 */
+    /* 0x31b00010,                                         */
+    ((EU_MD | MD_SHA224 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA224_LDCTX_HMAC_PAD_ULCTX         OpId 0x4a07 */
+    /* SHA-224, INIT, HMAC, PD                             */
+    /* 0x31f00010,                                         */
+    ((EU_MD | MD_SHA224 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA256_LDCTX_HMAC_ULCTX_CMP         OpId 0x4a08 */
+    /* SHA-256, INIT, HMAC, CICV                           */
+    /* 0x35900012,                                         */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_HMAC_ULCTX_CMP            OpId 0x4a09 */
+    /* MD-5, INIT, HMAC, CICV                              */
+    /* 0x35A00012,                                         */
+    ((EU_MD | MD_MD5 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_HMAC_ULCTX_CMP            OpId 0x4a0a */
+    /* SHA-1, INIT, HMAC, CICV                             */
+    /* 0x35800012,                                         */
+    ((EU_MD | MD_SHA1 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA256_LDCTX_HMAC_PAD_ULCTX_CMP     OpId 0x4a0b */
+    /* SHA-256, INIT, HMAC, PD, CICV                       */
+    /* 0x35D00012,                                         */
+    ((EU_MD | MD_SHA256 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_MD5_LDCTX_HMAC_PAD_ULCTX_CMP        OpId 0x4a0c */
+    /* MD-5, INIT, HMAC, PD, CICV                          */
+    /* 0x35E00012,                                         */
+    ((EU_MD | MD_MD5 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA_LDCTX_HMAC_PAD_ULCTX_CMP        OpId 0x4a0d */
+    /* SHA-1, INIT, HMAC, PD, CICV                         */
+    /* 0x35C00012,                                         */
+    ((EU_MD | MD_SHA1 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_HMAC_ULCTX_CMP         OpId 0x4a0e */
+    /* SHA-224, INIT, HMAC, CICV                           */
+    /* 0x35b00012,                                         */
+    ((EU_MD | MD_SHA224 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA224_LDCTX_HMAC_PAD_ULCTX_CMP     OpId 0x4a0f */
+    /* SHA-224, INIT, HMAC, PD, CICV                       */
+    /* 0x35f00012,                                         */
+    ((EU_MD | MD_SHA224 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_HMAC_ULCTX             OpId 0x4a10 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_HMAC_PAD_ULCTX         OpId 0x4a11 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA384_LDCTX_HMAC_ULCTX_CMP         OpId 0x4a12 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA384_LDCTX_HMAC_PAD_ULCTX_CMP     OpId 0x4a13 */
+    ((EU_MDPRIME | MD_SHA384 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_HMAC_ULCTX             OpId 0x4a14 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_HMAC) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_HMAC_PAD_ULCTX         OpId 0x4a15 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_HMAC | MD_PD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON,
+
+    /* DPD_SHA512_LDCTX_HMAC_ULCTX_CMP         OpId 0x4a16 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_HMAC | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_SHA512_LDCTX_HMAC_PAD_ULCTX_CMP     OpId 0x4a17 */
+    ((EU_MDPRIME | MD_SHA512 | MD_INIT | MD_HMAC | MD_PD | MD_CICV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_COMMON | HDR_INBOUND,
+
+};
+
+
+
+/**
+ * Header constants for MOD_EXP_REQ  DPD_MM_LDCTX_EXP_ULCTX_GROUP
+ */
+const unsigned long PkhaMmExpReq[1*NUM_MM_EXP_DESC] = {
+    /* DPD_MM_LDCTX_EXP_ULCTX                  OpId 0x5100 */
+    ((EU_PK | PK_MOD_EXP) << EU_SHIFT_PRIMARY)     | DESCTYPE_PK_MONTY,
+
+    /* DPD_MM_LDCTX_EXP_TEQ_ULCTX              OpId 0x5101 */
+    ((EU_PK | PK_MOD_EXP_TEQ) << EU_SHIFT_PRIMARY) | DESCTYPE_PK_MONTY
+};
+
+
+/**
+ * Header constants for MOD_SS_EXP_REQ / DPD_MM_SS_RSA_EXP
+ */
+const unsigned long PkhaMmSsExpReq[1*NUM_MM_SS_EXP_DESC] = {
+    /* DPD_MM_SS_RSA_EXP                       OpId 0x5b00 */
+    ((EU_PK | PK_RSA_SS) << EU_SHIFT_PRIMARY)     | DESCTYPE_PK_MONTY,
+
+    /* DPD_MM_SS_RSA_EXP_TEQ                   OpId 0x5b01 */
+    ((EU_PK | PK_RSA_SS_TEQ) << EU_SHIFT_PRIMARY) | DESCTYPE_PK_MONTY,
+};
+
+
+/**
+ * Header constants for MOD_R2MODN_REQ / DPD_MM_LDCTX_R2MODN_ULCTX_GROUP
+ */
+const unsigned long PkhaModR2modnReq[1 * NUM_MOD_R2MODN_DESC] = {
+    /*  DPD_MM_LDCTX_R2MODN_ULCTX Req OpId 0x5200 */
+    /* 0x50300080,                                */
+    ((EU_PK | PK_MOD_R2MODN) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY,
+
+    /*  DPD_F2M_R2 Req OpId 0x5201 */
+    /* 0x50D00080                                 */
+    ((EU_PK | PK_F2M_R2) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY
+};
+
+/**
+ * Header constants for MOD_RRMODP_REQ / DPD_MM_LDCTX_RRMODP_ULCTX_GROUP
+ */
+const unsigned long PkhaMmRrmodpReq[1*NUM_MM_RRMODP_DESC] = {
+    /* DPD_MM_LDCTX_RRMODP_ULCTX Req OpId 0x5300 */
+    /* 0x50400080                                */
+    ((EU_PK | PK_MOD_RRMODP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY
+};
+
+/**
+ * Header constants for MOD_INV_REQ / DPD_MM_MOD_INV_ULCTX_GROUP
+ */
+const unsigned long PkhaMmModInvReq[1*NUM_MM_MOD_INV_DESC] = {
+    /* DPD_MM_MOD_INV_ULCTX Req OpId 0x5500 */
+    /* 0x50f00080                           */
+    ((EU_PK | PK_FP_MODINV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY
+};
+
+/**
+ * Header constant for F2M_INV_REQ / DPD_F2M_INV_ULCTX_GROUP
+ */
+const unsigned long PkhaF2MInvReq[1*NUM_F2M_INV_DESC] = {
+    /* DPD_F2M_INV_ULCTX Req OpId 0x5600 */
+    /* 0x50e00080                        */
+    ((EU_PK | PK_F2M_INV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY
+};
+
+/**
+ * Header constants for MOD_2OP_REQ / DPD_MM_LDCTX_2OP_ULCTX_GROUP
+ * These are carryovers from SEC1, and need to be reviewed...
+ */
+const unsigned long PkhaMod2OpReq[1 * NUM_MOD_2OP_DESC] = {
+    /* DPD_MOD_LDCTX_MUL1_ULCTX        Req OpId 0x5400 */
+    /* 0x53000080,                                     */
+    ((EU_PK | PK_FP_MULT_MONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_MOD_LDCTX_MUL2_ULCTX        Req OpId 0x5401 */
+    /* 0x54000080,                                     */
+    ((EU_PK | PK_FP_MULT_DECONV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_MOD_LDCTX_ADD_ULCTX         Req OpId 0x5402 */
+    /* 0x51000080,                                     */
+    ((EU_PK | PK_FP_MODADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_MOD_LDCTX_SUB_ULCTX         Req OpId 0x5403 */
+    /* 0x52000080,                                     */
+    ((EU_PK | PK_FP_MODSUB) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B0_MUL1_ULCTX Req OpId 0x5404 */
+    /* 0x56000080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B0_MUL2_ULCTX Req OpId 0x5405 */
+    /* 0x57000080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B0_ADD_ULCTX  Req OpId 0x5406 */
+    /* 0x55000080,                                     */
+    ((EU_PK | PK_F2M_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B0_MUL1_ULCTX Req OpId 0x5407 */
+    /* 0x56400080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_MOD_RRMODP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B0_MUL2_ULCTX Req OpId 0x5408 */
+    /* 0x57400080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_MOD_RRMODP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B0_ADD_ULCTX  Req OpId 0x5409 */
+    /* 0x55400080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_MOD_RRMODP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B0_MUL1_ULCTX Req OpId 0x540a */
+    /* 0x56800080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_F2M_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B0_MUL2_ULCTX Req OpId 0x540b */
+    /* 0x57800080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_F2M_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B0_ADD_ULCTX  Req OpId 0x540c */
+    /* 0x55800080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_F2M_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B0_MUL1_ULCTX Req OpId 0x540d */
+    /* 0x56c00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_F2M_MULT_DECONV | PK_RSA_SS) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B0_MUL2_ULCTX Req OpId 0x540e */
+    /* 0x57c00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_F2M_MULT_DECONV | PK_RSA_SS) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B0_ADD_ULCTX  Req OpId 0x540f */
+    /* 0x55c00080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_F2M_MULT_DECONV | PK_RSA_SS) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B1_MUL1_ULCTX Req OpId 0x5410 */
+    /* 0x56100080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_CLEARMEM) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B1_MUL2_ULCTX Req OpId 0x5411 */
+    /* 0x57100080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_CLEARMEM) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B1_ADD_ULCTX  Req OpId 0x5412 */
+    /* 0x55100080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_CLEARMEM) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B1_MUL1_ULCTX Req OpId 0x5413 */
+    /* 0x56500080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_FP_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B1_MUL2_ULCTX Req OpId 0x5414 */
+    /* 0x57500080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_FP_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B1_ADD_ULCTX  Req OpId 0x5415 */
+    /* 0x55500080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_FP_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B1_MUL1_ULCTX Req OpId 0x5416 */
+    /* 0x56900080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_FP_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B1_MUL2_ULCTX Req OpId 0x5417 */
+    /* 0x57900080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_FP_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B1_ADD_ULCTX  Req OpId 0x5418 */
+    /* 0x55900080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_FP_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B1_MUL1_ULCTX Req OpId 0x5419 */
+    /* 0x56d00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_F2M_R2) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B1_MUL2_ULCTX Req OpId 0x541a */
+    /* 0x57d00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_F2M_R2) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B1_ADD_ULCTX  Req OpId 0x541b */
+    /* 0x55d00080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_F2M_R2) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B2_MUL1_ULCTX Req OpId 0x541c */
+    /* 0x56200080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_MOD_EXP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B2_MUL2_ULCTX Req OpId 0x541d */
+    /* 0x57200080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_MOD_EXP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B2_ADD_ULCTX  Req OpId 0x541e */
+    /* 0x55200080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_MOD_EXP) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B2_MUL1_ULCTX Req OpId 0x541f */
+    /* 0x56600080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B2_MUL2_ULCTX Req OpId 0x5420 */
+    /* 0x57600080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B2_ADD_ULCTX  Req OpId 0x5421 */
+    /* 0x55600080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B2_MUL1_ULCTX Req OpId 0x5422 */
+    /* 0x56a00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_FP_DOUBLE) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B2_MUL2_ULCTX Req OpId 0x5423 */
+    /* 0x57a00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_FP_DOUBLE) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B2_ADD_ULCTX  Req OpId 0x5424 */
+    /* 0x55a00080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_FP_DOUBLE) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B2_MUL1_ULCTX Req OpId 0x5425 */
+    /* 0x56e00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_F2M_INV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B2_MUL2_ULCTX Req OpId 0x5426 */
+    /* 0x57e00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_F2M_INV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B2_ADD_ULCTX  Req OpId 0x5427 */
+    /* 0x55e00080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_F2M_INV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B3_MUL1_ULCTX Req OpId 0x5428 */
+    /* 0x56300080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_MOD_R2MODN) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B3_MUL2_ULCTX Req OpId 0x5429 */
+    /* 0x57300080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_MOD_R2MODN) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A0_B3_ADD_ULCTX  Req OpId 0x542a */
+    /* 0x55300080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_MOD_R2MODN) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B3_MUL1_ULCTX Req OpId 0x542b */
+    /* 0x56700080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_FP_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B3_MUL2_ULCTX Req OpId 0x542c */
+    /* 0x57700080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_FP_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A1_B3_ADD_ULCTX  Req OpId 0x542d */
+    /* 0x55700080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_FP_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B3_MUL1_ULCTX Req OpId 0x542e */
+    /* 0x56b00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_EC_F2M_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B3_MUL2_ULCTX Req OpId 0x542f */
+    /* 0x57b00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_EC_F2M_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A2_B3_ADD_ULCTX  Req OpId 0x5430 */
+    /* 0x55b00080,                                     */
+    ((EU_PK | PK_F2M_ADD | PK_EC_F2M_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B3_MUL1_ULCTX Req OpId 0x5431 */
+    /* 0x56f00080,                                     */
+    ((EU_PK | PK_F2M_MULT_MONT | PK_FP_MODINV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B3_MUL2_ULCTX Req OpId 0x5432 */
+    /* 0x57f00080,                                     */
+    ((EU_PK | PK_F2M_MULT_DECONV | PK_FP_MODINV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+    /* DPD_POLY_LDCTX_A3_B3_ADD_ULCTX  Req OpId 0x5433 */
+    /* 0x55f00080                                     */
+    ((EU_PK | PK_F2M_ADD | PK_FP_MODINV) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND
+};
+
+
+
+/**
+ * Header constants for ECC_POINT_REQ / DPD_EC_LDCTX_kP_ULCTX_GROUP
+ * These descriptors use the "packed" format
+ */
+const unsigned long PkhaEccPointReq[1*NUM_EC_POINT_DESC] = {
+    /* DPD_EC_FP_AFF_PT_MULT          OpId 0x5800 */
+    /* 0x50500048,                                */
+    ((EU_PK | PK_EC_FP_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_FP_PROJ_PT_MULT         OpId 0x5801 */
+    /* 0x50700048,                                */
+    ((EU_PK | PK_EC_FP_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_AFF_PT_MULT         OpId 0x5802 */
+    /* 0x50600048,                                */
+    ((EU_PK | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_PROJ_PT_MULT        OpId 0x5803 */
+    /* 0x50800048,                                */
+    ((EU_PK | PK_EC_F2M_PROJ_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_FP_LDCTX_ADD_ULCTX      OpId 0x5804 */
+    /* 0x50900048,                                */
+    ((EU_PK | PK_EC_FP_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_FP_LDCTX_DOUBLE_ULCTX   OpId 0x5805 */
+    /* 0x50a00048,                                */
+    ((EU_PK | PK_EC_FP_DOUBLE) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_LDCTX_ADD_ULCTX     OpId 0x5806 */
+    /* 0x50b00048,                                */
+    ((EU_PK | PK_EC_F2M_ADD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_LDCTX_DOUBLE_ULCTX  OpId 0x5807 */
+    /* 0x50c00048                                 */
+    ((EU_PK | PK_EC_F2M_DOUBLE) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_PTMULT | HDR_OUTBOUND
+};
+
+
+
+/**
+ * Header constants for ECC_2OP_REQ / DPD_EC_2OP_GROUP
+ */
+const unsigned long PkhaEcc2OpReq[1*NUM_EC_2OP_DESC] = {
+    /* DPD_EC_F2M_LDCTX_MUL1_ULCTX Req OpId 0x5900 */
+    /* 0x56000080,                                 */
+    ((EU_PK | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_LDCTX_MUL2_ULCTX Req OpId 0x5901 */
+    /* 0x57000080,                                 */
+    ((EU_PK | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND,
+
+    /* DPD_EC_F2M_LDCTX_ADD_ULCTX  Req OpId 0x5902 */
+    /* 0x55000080                                  */
+    ((EU_PK | PK_EC_F2M_AFF_PTMULT) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_MONTY | HDR_OUTBOUND
+};
+
+
+/**
+ * Header constants for ECC_SPKBUILD_REQ / DPD_EC_SPKBUILD_GROUP
+ */
+const unsigned long PkhaEccSpkbuildReq[1*NUM_EC_SPKBUILD_DESC] =
+{
+    /* DPD_EC_SPKBUILD Req OpId 0x5c00 */
+    /* 0x5ff00038                      */
+    ((EU_PK | PK_PKBUILD) << EU_SHIFT_PRIMARY) |
+        DESCTYPE_PK_ECC_ASM
+};
+
+
+/**
+ * Header constants for ECC_PTADD_DBL
+ */
+const unsigned long PkhaEccPtaddDblReq[1 * NUM_EC_PTADD_DBL_DESC] =
+{
+    /* DPD_EC_FPADD      Req OpId 0x5d00 */
+    /* 0x50900058                        */
+    ((EU_PK | PK_EC_FP_ADD) << EU_SHIFT_PRIMARY) |
+     DESCTYPE_PK_ECC_PTADD_D,
+
+    /* DPD_EC_FPDBL      Req OpId 0x5d01 */
+    /* 0x50a00058                        */
+    ((EU_PK | PK_EC_FP_DOUBLE) << EU_SHIFT_PRIMARY) |
+     DESCTYPE_PK_ECC_PTADD_D,
+
+    /* DPD_EC_F2MADD     Req OpId 0x5d02 */
+    /* 0x50b00058                        */
+    ((EU_PK | PK_EC_F2M_ADD) << EU_SHIFT_PRIMARY) |
+     DESCTYPE_PK_ECC_PTADD_D,
+
+    /* DPD_EC_F2MDBL     Req OpId 0x5d03 */
+    /* 0x50c00058                        */
+    ((EU_PK | PK_EC_F2M_DOUBLE) << EU_SHIFT_PRIMARY) |
+     DESCTYPE_PK_ECC_PTADD_D
+};
+
+
+/**
+ * Header constants for IPSEC_CBC_REQ / DPD_IPSEC_CBC_GROUP
+ */
+const unsigned long IpsecCbcReq[1*NUM_IPSEC_CBC_DESC] = {
+    /* DPD_IPSEC_CBC_SDES_ENCRYPT_MD5_PAD    OpId 0x7000 */
+    /* 0x20531e20,                                       */
+    ((EU_DES | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_SDES_ENCRYPT_SHA_PAD    OpId 0x7001 */
+    /* 0x20531c20,                                       */
+    ((EU_DES | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_SDES_ENCRYPT_SHA256_PAD OpId 0x7002 */
+    /* 0x20531d20,                                       */
+    ((EU_DES | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_SDES_DECRYPT_MD5_PAD    OpId 0x7003 */
+    /* 0x20431e22,                                       */
+    ((EU_DES | DES_CBC | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_CBC_SDES_DECRYPT_SHA_PAD    OpId 0x7004 */
+    /* 0x20431c22,                                       */
+    ((EU_DES | DES_CBC | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_CBC_SDES_DECRYPT_SHA256_PAD OpId 0x7005 */
+    /* 0x20431d22,                                       */
+    ((EU_DES | DES_CBC | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_CBC_TDES_ENCRYPT_MD5_PAD    OpId 0x7006 */
+    /* 0x20731e20,                                       */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_TDES_ENCRYPT_SHA_PAD    OpId 0x7007 */
+    /* 0x20731c20,                                       */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_TDES_ENCRYPT_SHA256_PAD OpId 0x7008 */
+    /* 0x20731d20,                                       */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC,
+
+    /* DPD_IPSEC_CBC_TDES_DECRYPT_MD5_PAD    OpId 0x7009 */
+    /* 0x20631e22,                                       */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_CBC_TDES_DECRYPT_SHA_PAD    OpId 0x700a */
+    /* 0x20631c22,                                       */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_CBC_TDES_DECRYPT_SHA256_PAD OpId 0x700b */
+    /* 0x20631d22                                        */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND
+};
+
+
+
+
+/**
+ * Header constants for IPSEC_ECB_REQ / DPD_IPSEC_ECB_GROUP
+ */
+const unsigned long IpsecEcbReq[1*NUM_IPSEC_ECB_DESC] = {
+    /* DPD_IPSEC_ECB_SDES_ENCRYPT_MD5_PAD    OpId 0x7100 */
+    /* 0x20131e20,                                       */
+    ((EU_DES | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_SDES_ENCRYPT_SHA_PAD    OpId 0x7101 */
+    /* 0x20131c20,                                       */
+    ((EU_DES | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_SDES_ENCRYPT_SHA256_PAD OpId 0x7102 */
+    /* 0x20131d20,                                       */
+    ((EU_DES | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_SDES_DECRYPT_MD5_PAD    OpId 0x7103 */
+    /* 0x20031e22,                                       */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_ECB_SDES_DECRYPT_SHA_PAD    OpId 0x7104 */
+    /* 0x20031c22,                                       */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_ECB_SDES_DECRYPT_SHA256_PAD OpId 0x7105 */
+    /* 0x20031d22,                                       */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_ENCRYPT_MD5_PAD    OpId 0x7106 */
+    /* 0x20331e20,                                       */
+    ((EU_DES | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_ENCRYPT_SHA_PAD    OpId 0x7107 */
+    /* 0x20331c20,                                       */
+    ((EU_DES | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_ENCRYPT_SHA256_PAD OpId 0x7108 */
+    /* 0x20331d20,                                       */
+    ((EU_DES | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_DECRYPT_MD5_PAD    OpId 0x7109 */
+    /* 0x20231e22,                                       */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_DECRYPT_SHA_PAD    OpId 0x710a */
+    /* 0x20231c22,                                       */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /* DPD_IPSEC_ECB_TDES_DECRYPT_SHA256_PAD OpId 0x710b */
+    /* 0x20231d22                                        */
+    ((EU_DES | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+};
+
+
+
+/**
+ * Header constants for IPSEC_AES_CBC_REQ / DPD_IPSEC_AES_CBC_GROUP
+ */
+
+const unsigned long IpsecAesCbcReq[1*NUM_IPSEC_AES_CBC_DESC] = {
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_MD5_APAD           OpId 0x8000 */
+    /* 0x60331E20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_SHA_APAD           OpId 0x8001 */
+    /* 0x60331C20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_SHA256_APAD        OpId 0x8002 */
+    /* 0x60331D20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_MD5                OpId 0x8003 */
+    /* 0x60331a20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_SHA                OpId 0x8004 */
+    /* 0x60331820,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_ENCRYPT_SHA256             OpId 0x8005 */
+    /* 0x60331920,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_MD5_APAD           OpId 0x8006 */
+    /* 0x60231e22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_SHA_APAD           OpId 0x8007 */
+    /* 0x60231c22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_SHA256_APAD        OpId 0x8008 */
+    /* 0x60231d22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_MD5                OpId 0x8009 */
+    /* 0x60231a22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_SHA                OpId 0x800a */
+    /* 0x60231822,                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_CBC_DECRYPT_SHA256             OpId 0x800b */
+    /* 0x60231922                                               */
+    ((EU_AES | AES_DECRYPT | AES_CBC) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND
+};
+
+
+
+
+/**
+ * Header constants for IPSEC_AES_ECB_REQ / DPD_IPSEC_AES_ECB_GROUP
+ */
+
+const unsigned long IpsecAesEcbReq[1*NUM_IPSEC_AES_ECB_DESC] = {
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_MD5_APAD           OpId 0x8100 */
+    /* 0x60131E20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_SHA_APAD           OpId 0x8101 */
+    /* 0x60131C20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_SHA256_APAD        OpId 0x8102 */
+    /* 0x60131D20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_MD5                OpId 0x8103 */
+    /* 0x60131a20,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_SHA                OpId 0x8104 */
+    /* 0x60131820,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_ENCRYPT_SHA256             OpId 0x8105 */
+    /* 0x60131920,                                               */
+    ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_MD5_APAD           OpId 0x8106 */
+    /* 0x60031e22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_SHA_APAD           OpId 0x8107 */
+    /* 0x60031c22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_SHA256_APAD        OpId 0x8108 */
+    /* 0x60031d22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_MD5                OpId 0x8109 */
+    /* 0x60031a22,                                               */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_SHA                OpId 0x810a */
+    /* 0x60031822,                                               */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+
+    /*  DPD_IPSEC_AES_ECB_DECRYPT_SHA256             OpId 0x810b */
+    /* 0x60031922                                                */
+    ((EU_AES | AES_DECRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC  | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_HMAC | HDR_INBOUND,
+};
+
+
+
+/**
+ * Header constants for IPSEC_ESP_REQ / DPD_IPSEC_ESP_GROUP
+ */
+
+const unsigned long IpsecEspReq[1 * NUM_IPSEC_ESP_DESC] = {
+    /*  DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_MD5_PAD          OpId 0x7500 */
+    /* 0x20131e08,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_SHA_PAD          OpId 0x7501 */
+    /* 0x20131c08,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_SDES_ECB_CRPT_SHA256_PAD       OpId 0x7502 */
+    /* 0x20131d08,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_MD5_PAD          OpId 0x7503 */
+    /* 0x20031e0a,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA_PAD          OpId 0x7504 */
+    /* 0x20031c0a,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA256_PAD       OpId 0x7505 */
+    /* 0x20031d0a,                                                   */
+    ((EU_DES | DES_ECB |DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_MD5_PAD          OpId 0x7506 */
+    /* 0x20531e08,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_SHA_PAD          OpId 0x7507 */
+    /* 0x20531c08,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_SDES_CBC_CRPT_SHA256_PAD       OpId 0x7508 */
+    /* 0x20531d08,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_MD5_PAD          OpId 0x7509 */
+    /* 0x20431e0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA_PAD          OpId 0x750a */
+    /* 0x20431c0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA256_PAD       OpId 0x750b */
+    /* 0x20431d0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_MD5_PAD          OpId 0x750c */
+    /* 0x20731e08,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_SHA_PAD          OpId 0x750d */
+    /* 0x20731c08,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_CBC_CRPT_SHA256_PAD       OpId 0x750e */
+    /* 0x20731d08,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_MD5_PAD          OpId 0x750f */
+    /* 0x20631e0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA_PAD          OpId 0x7510 */
+    /* 0x20631c0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA256_PAD       OpId 0x7511 */
+    /* 0x20631d0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_MD5_PAD          OpId 0x7512 */
+    /* 0x20331e08,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_SHA_PAD          OpId 0x7513 */
+    /* 0x20331c08,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_OUT_TDES_ECB_CRPT_SHA256_PAD       OpId 0x7514 */
+    /* 0x20331d08,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_OUTBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_MD5_PAD          OpId 0x7515 */
+    /* 0x20231e0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA_PAD          OpId 0x7516 */
+    /* 0x20231c0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA256_PAD       OpId 0x7517 */
+    /* 0x20231d0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_MD5_PAD_CMP      OpId 0x7518 */
+    /* 0x20035e0a,                                                   */
+    ((EU_DES | DES_ECB | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA_PAD_CMP      OpId 0x7519 */
+    /* 0x20035c0a,                                                   */
+    ((EU_DES | DES_ECB | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_ECB_DCRPT_SHA256_PAD_CMP   OpId 0x751a */
+    /* 0x20035d0a,                                                   */
+    ((EU_DES | DES_ECB | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_MD5_PAD_CMP      OpId 0x751b */
+    /* 0x20435e0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA_PAD_CMP      OpId 0x751c */
+    /* 0x20435c0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_SDES_CBC_DCRPT_SHA256_PAD_CMP   OpId 0x751d */
+    /* 0x20435d0a,                                                   */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_MD5_PAD_CMP      OpId 0x751e */
+    /* 0x20635e0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA_PAD_CMP      OpId 0x751f */
+    /* 0x20635c0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_CBC_DCRPT_SHA256_PAD_CMP   OpId 0x7520 */
+    /* 0x20635d0a,                                                   */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_MD5_PAD_CMP      OpId 0x7521 */
+    /* 0x20235e0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA_PAD_CMP      OpId 0x7522 */
+    /* 0x20235c0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND,
+
+    /*  DPD_IPSEC_ESP_IN_TDES_ECB_DCRPT_SHA256_PAD_CMP   OpId 0x7523 */
+    /* 0x20235d0a,                                                   */
+    ((EU_DES | DES_ECB | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_CICV | MD_INIT | MD_HMAC | MD_PD | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_IPSEC_ESP | HDR_INBOUND
+};
+
+
+
+
+/**
+ * Header constants for CCMP_REQ / DPD_CCMP_GROUP
+ */
+
+const unsigned long CcmpReq[1 * NUM_CCMP_DESC] = {
+    /*  DPD_802_11_CCMP_OUTBOUND                 OpId 0x6500 */
+    /* 0x6b100018,                                           */
+    /* AES mode ECM = 2, FM, CM = 0, ED                      */
+    ((EU_AES | AES_CCM | AES_FINALMAC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_AES_CCMP | HDR_OUTBOUND,
+
+    /*  DPD_802_11_CCMP_INBOUND                  OpId 0x6501 */
+    /* 0x6b00001a,                                           */
+    /* AES mode ECM = 2, CM = 0, FM                          */
+    ((EU_AES | AES_CCM | AES_FINALMAC) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_AES_CCMP | HDR_INBOUND,
+
+    /*  DPD_802_11_CCMP_INBOUND_CMP              0pId 0x6502 */
+    /* 0x6f00001a,                                           */
+    /* AES mode ECM = 2, CM = 0, FM, IM                      */
+    ((EU_AES | AES_CCM | AES_FINALMAC | AES_INITMAC) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_AES_CCMP | HDR_INBOUND
+};
+
+
+
+
+/**
+ * Header constants for SRTP_REQ / DPD_SRTP_GROUP
+ */
+
+const unsigned long SrtpReq[1 * NUM_SRTP_DESC] = {
+    /* DPD_SRTP_OUTBOUND                         OpId 0x8500  */
+    /* Primary EU:   AES     Mode: SRT, CBC-encrypt           */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, PD, SHA1       */
+    /* Type:         SRTP, Outbound                           */
+    /* 0x64731c28,                                            */
+    ((EU_AES | AES_SRTP | AES_CBC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) ||
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) ||
+    DESCTYPE_SRTP | HDR_OUTBOUND,
+
+    /* DPD_SRTP_INBOUND                          OpId 0x8501  */
+    /* Primary EU:   AES     Mode: SRT, CBC-decrypt           */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, PD, SHA1       */
+    /* Type:         SRTP, Inbound                            */
+    /* 0x64631c2a,                                            */
+    ((EU_AES | AES_SRTP | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) ||
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) ||
+    DESCTYPE_SRTP | HDR_OUTBOUND,
+
+    /* DPD_SRTP_INBOUND_CMP                     OpId 0x8502   */
+    /* Primary EU:   AES     Mode: SRT, CBC-decrypt           */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, PD, CICV, SHA1 */
+    /* Type:         SRTP, Inbound                            */
+    /* 0x64635c2a                                             */
+    ((EU_AES | AES_SRTP | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) ||
+    ((EU_MD | MD_INIT | MD_HMAC | MD_PD | MD_SHA1) << EU_SHIFT_SECONDARY) ||
+    DESCTYPE_SRTP | HDR_OUTBOUND,
+};
+
+
+
+/**
+ * Header constants for KEA_CRYPT_REQ / DPD_KEA_CRYPT_GROUP
+ */
+
+const unsigned long KeaReq[1 * NUM_KEA_CRYPT_DESC] = {
+    /* DPD_KEA_f8_CIPHER_INIT           (DPD_KEA_CRYPT_GROUP + 0) (OpId 0xa000) */
+    /* INT, f8                                                                  */
+    /* 0x70800010,                                                              */
+    ((EU_KEA | KEA_F8 | KEA_INIT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f8_CIPHER                (DPD_KEA_CRYPT_GROUP + 1) (OpId 0xa001) */
+    /* f8                                                                       */
+    /* 0x70000010,                                                              */
+    ((EU_KEA | KEA_F8) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_CIPHER_INIT           (DPD_KEA_CRYPT_GROUP + 2) (OpId 0xa002) */
+    /* INT, f9                                                                  */
+    /* 0x70a00010,                                                              */
+    ((EU_KEA | KEA_F9 | KEA_INIT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_CIPHER                (DPD_KEA_CRYPT_GROUP + 3) (OpId 0xa003) */
+    /* f9                                                                       */
+    /* 0x70200010,                                                              */
+    ((EU_KEA | KEA_F9) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_CIPHER_FINAL          (DPD_KEA_CRYPT_GROUP + 4) (OpId 0xa004) */
+    /* PE, f9                                                                   */
+    /* 0x71200010,                                                              */
+    ((EU_KEA | KEA_F9 | KEA_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_CIPHER_INIT_FINAL     (DPD_KEA_CRYPT_GROUP + 5) (OpId 0xa005) */
+    /* INT, PE, f9                                                              */
+    /* 0x71a00010,                                                              */
+    ((EU_KEA | KEA_F9 | KEA_INIT | KEA_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_GSM_A53_CIPHER           (DPD_KEA_CRYPT_GROUP + 6) (OpId 0xa006) */
+    /* GSM, PE, INT, f8                                                         */
+    /* 0x79800010,                                                              */
+    ((EU_KEA | KEA_F8 | KEA_GSM | KEA_EOM | KEA_INIT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_EDGE_A53_CIPHER          (DPD_KEA_CRYPT_GROUP + 7) (OpId 0xa007) */
+    /* EDGE, PE, INT, f8                                                        */
+    /* 0x73800010,                                                              */
+    ((EU_KEA | KEA_F8 | KEA_EDGE | KEA_INIT | KEA_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_CIPHER_FINAL_CMP      (DPD_KEA_CRYPT_GROUP + 8) (OpId 0xa008) */
+    /* PE, f9, CICV                                                             */
+    /* 0x75200012,                                                              */
+    ((EU_KEA | KEA_F9 | KEA_ICV | KEA_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_KEA_f9_CIPHER_INIT_FINAL_CMP (DPD_KEA_CRYPT_GROUP + 9) (OpId 0xa009) */
+    /* INT, PE, f9, CICV                                                        */
+    /* 0x75a00012,                                                              */
+    ((EU_KEA | KEA_F9 | KEA_INIT | KEA_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_INBOUND
+};
+
+
+
+/**
+ * Header constants for SNOW3G_CRYPT_REQ / DPD_SNOW3G_CRYPT_GROUP
+ */
+
+const unsigned long SnoReq[1 * NUM_SNOW3G_CRYPT_DESC] = {
+    /* DPD_SNOW3G_f8_INIT        (DPD_SNOW3G_CRYPT_GROUP + 0) (OpId 0xc000) */
+    /* INT, f8                                                              */
+    ((EU_SNOW | SNOW_F8 | SNOW_INIT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f8                (DPD_SNOW3G_CRYPT_GROUP + 1) (OpId 0xa001) */
+    /* f8                                                                   */
+    ((EU_SNOW | SNOW_F8) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_INIT           (DPD_SNOW3G_CRYPT_GROUP + 2) (OpId 0xc002) */
+    /* INT, f9                                                              */
+    ((EU_SNOW | SNOW_F9 | SNOW_INIT) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9                (DPD_SNOW3G_CRYPT_GROUP + 3) (OpId 0xc003) */
+    /* f9                                                                   */
+    ((EU_SNOW | SNOW_F9) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_FINAL          (DPD_SNOW3G_CRYPT_GROUP + 4) (OpId 0xc004) */
+    /* PE, f9                                                               */
+    ((EU_SNOW | SNOW_F9 | SNOW_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_INIT_FINAL     (DPD_SNOW3G_CRYPT_GROUP + 5) (OpId 0xc005) */
+    /* INT, PE, f9                                                          */
+    ((EU_SNOW | SNOW_F9 | SNOW_INIT | SNOW_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_OUTBOUND,
+
+    /* DPD_KEA_f9_FINAL_CMP      (DPD_SNOW3G_CRYPT_GROUP + 8) (OpId 0xc008) */
+    /* PE, f9, CICV                                                         */
+    ((EU_SNOW | SNOW_F9 | SNOW_ICV | SNOW_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_INBOUND,
+
+    /* DPD_KEA_f9_INIT_FINAL_CMP (DPD_SNOW3G_CRYPT_GROUP + 9) (OpId 0xc009) */
+    /* INT, PE, f9, CICV                                                    */
+    ((EU_SNOW | SNOW_F9 | SNOW_INIT | SNOW_EOM) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_COMMON | HDR_INBOUND
+};
+
+
+/**
+ * Header constants for RAID_XOR_REQ / DPD_RAID_XOR_REQ_GROUP
+ */
+
+const unsigned long RaidXorReq[1 * NUM_RAID_XOR_DESC] = {
+    /* DPD_RAID_XOR                              OpId 0x6200 */
+    ((EU_AES | AES_XOR) << EU_SHIFT_PRIMARY) |
+    DESCTYPE_RAIDXOR,
+};
+
+
+
+/**
+ * Header constants for TLS_BLOCK_INBOUND_REQ / DPD_TLS_BLOCK_INBOUND_GROUP
+ */
+const unsigned long TlsBlockInboundReq[1 * NUM_TLS_BLOCK_INBOUND_DESC] = {
+    /* DPD_TLS_BLOCK_INBOUND_SDES_MD5            OpId 0x9000 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x20431a8a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_MD5_CMP        OpId 0x9001 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x20435a8a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA1           OpId 0x9002 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043188a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA1_CMP       OpId 0x9003 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043588a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA256         OpId 0x9004 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043198a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA256_CMP     OpId 0x9005 */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA256  */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043598a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_MD5            OpId 0x9006 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x20631a8a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_MD5_CMP        OpId 0x9007 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x20635a8a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY ) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA1           OpId 0x9008 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063188a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA1_CMP       OpId 0x9009 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063588a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA256         OpId 0x900a */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063198a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA256_CMP     OpId 0x900b */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA256  */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063598a,                                           */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_MD5_SMAC       OpId 0x900c */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043328a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_MD5_SMAC_CMP   OpId 0x900d */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043728a,                                           */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA1_SMAC      OpId 0x900e */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043308a, */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_SDES_SHA1_SMAC_CMP  OpId 0x900f */
+    /* Primary EU:   DES     Mode: Single, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2043708a, */
+    ((EU_DES | DES_CBC | DES_SINGLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_MD5_SMAC       OpId 0x9010 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063328a, */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_MD5_SMAC_CMP   OpId 0x9011 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063728a, */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA1_SMAC      OpId 0x9012 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063308a, */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_TDES_SHA1_SMAC_CMP  OpId 0x9013 */
+    /* Primary EU:   DES     Mode: Triple, CBC-decrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x2063708a, */
+    ((EU_DES | DES_CBC | DES_TRIPLE | DES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_MD5             OpId 0x9014 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x60231a8a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_MD5_CMP         OpId 0x9015 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x60235a8a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA1            OpId 0x9016 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023188a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA1_CMP        OpId 0x9017 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023588a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA256          OpId 0x9018 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023198a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA256_CMP      OpId 0x9019 */
+    /* Primary EU:   AES     Mode: CBC-decrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA256  */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023598a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_MD5_SMAC        OpId 0x901a */
+    /* Primary EU:   AES     CBC-decrypt                     */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, MD5           */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023328a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_MD5_SMAC_CMP    OpId 0x901b */
+    /* Primary EU:   AES     CBC-decrypt                     */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023728a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA1_SMAC       OpId 0x901c */
+    /* Primary EU:   AES     CBC-decrypt                     */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023308a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+
+    /* DPD_TLS_BLOCK_INBOUND_AES_SHA1_SMAC_CMP   OpId 0x901d */
+    /* Primary EU:   AES     CBC-decrypt                     */
+    /* Secondary EU: MDEU    Mode: INIT, SMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Block, Inbound                  */
+    /* 0x6023708a, */
+    ((EU_AES | AES_CBC | AES_DECRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_SMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_INBOUND,
+};
+
+
+
+
+
+/**
+ * Header constants for TLS_BLOCK_OUTBOUND_REQ / DPD_TLS_BLOCK_OUTBOUND_GROUP
+ */
+const unsigned long TlsBlockOutboundReq[1 * NUM_TLS_BLOCK_OUTBOUND_DESC] = {
+    /* DPD_TLS_BLOCK_OUTBOUND_SDES_MD5           OpId 0x9100 */
+    /* Primary EU:   DES     Mode: Single, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20531a88, */
+    ((EU_DES | DES_SINGLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_SDES_SHA1          OpId 0x9101 */
+    /* Primary EU:   DES     Mode: Single, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20531888, */
+    ((EU_DES | DES_SINGLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_SDES_SHA256        OpId 0x9102 */
+    /* Primary EU:   DES     Mode: Single, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20531988, */
+    ((EU_DES | DES_SINGLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_TDES_MD5           OpId 0x9103 */
+    /* Primary EU:   DES     Mode: Triple, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20731a88, */
+    ((EU_DES | DES_TRIPLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_TDES_SHA1          OpId 0x9104 */
+    /* Primary EU:   DES     Mode: Triple, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20731888, */
+    ((EU_DES | DES_TRIPLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_TDES_SHA256        OpId 0x9105 */
+    /* Primary EU:   DES     Mode: Triple, CBC-encrypt       */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x20731988, */
+    ((EU_DES | DES_TRIPLE | DES_CBC | DES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_AES_MD5            OpId 0x9106 */
+    /* Primary EU:   AES     Mode: CBC-encrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x60331a88, */
+    ((EU_AES | AES_CBC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_AES_SHA1           OpId 0x9107 */
+    /* Primary EU:   AES     Mode: CBC-encrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x60331888, */
+    ((EU_AES | AES_CBC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+    /* DPD_TLS_BLOCK_OUTBOUND_AES_SHA256         OpId 0x9108 */
+    /* Primary EU:   AES     Mode: CBC-encrypt               */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Block, Outbound                 */
+    /* 0x60331988, */
+    ((EU_AES | AES_CBC | AES_ENCRYPT) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_BLOCK | HDR_OUTBOUND,
+
+};
+
+
+
+
+
+/**
+ * Header constants for TLS_STREAM_INBOUND_REQ / DPD_TLS_STREAM_INBOUND_GROUP
+ */
+const unsigned long TlsStreamInboundReq[1 * NUM_TLS_STREAM_INBOUND_DESC] = {
+    /* DPD_TLS_STREAM_INBOUND_MD5                OpId 0x9200 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x10031a9a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_MD5            OpId 0x9201 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x10731a9a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_SHA1               OpId 0x9202 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1003189a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_SHA1           OpId 0x9203 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1073189a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_SHA256             OpId 0x9204 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1003199a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_SHA256         OpId 0x9205 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1073199a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_MD5_CMP            OpId 0x9206 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x10035a9a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_MD5_CMP        OpId 0x9207 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, MD5     */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x10735a9a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_SHA1_CMP           OpId 0x9208 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1003589a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_SHA1_CMP       OpId 0x9209 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA1    */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1073589a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_SHA256_CMP         OpId 0x920a */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA256  */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1003599a, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+
+    /* DPD_TLS_STREAM_INBOUND_CTX_SHA256_CMP     OpId 0x920b */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, CICV, SHA256  */
+    /* Type:         TLS/SSL Stream, Inbound                 */
+    /* 0x1073599a, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_CICV | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_INBOUND,
+};
+
+
+
+
+/**
+ * Header constants for TLS_STREAM_OUTBOUND_REQ / DPD_TLS_STREAM_OUTBOUND_GROUP
+ */
+const unsigned long TlsStreamOutboundReq[1 * NUM_TLS_STREAM_OUTBOUND_DESC] = {
+    /* DPD_TLS_STREAM_OUTBOUND_MD5               OpId 0x9300 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10031a98, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+
+    /* DPD_TLS_STREAM_OUTBOUND_SHA1              OpId 0x9301 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10031898, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+
+    /* DPD_TLS_STREAM_OUTBOUND_SHA256            OpId 0x9302 */
+    /* Primary EU:   AFEU    Mode: (none)                    */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA256        */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10031998, */
+    ((EU_ARC4) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+
+    /* DPD_TLS_STREAM_OUTBOUND_CTX_MD5           OpId 0x9303 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, MD5           */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10731a98, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_MD5) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+
+    /* DPD_TLS_STREAM_OUTBOUND_CTX_SHA1          OpId 0x9304 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA1          */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10731898, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA1) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+
+    /* DPD_TLS_STREAM_OUTBOUND_CTX_SHA256        OpId 0x9305 */
+    /* Primary EU:   AFEU    Mode: CS, DC, PP                */
+    /* Secondary EU: MDEU    Mode: INIT, HMAC, SHA156        */
+    /* Type:         TLS/SSL Stream, Outbound                */
+    /* 0x10731998, */
+    ((EU_ARC4 | ARC4_PERMUTE_INHIBIT | ARC4_DUMP_CONTEXT | ARC4_FETCH_CTX) << EU_SHIFT_PRIMARY) |
+    ((EU_MD | MD_INIT | MD_HMAC | MD_SHA256) << EU_SHIFT_SECONDARY) |
+    DESCTYPE_TLS_STREAM | HDR_OUTBOUND,
+};
+
+
+#define DES_STD_BLOCKSIZE      (8)
+#define ARC4_STD_MIN_KEYBYTES  (1)
+#define ARC4_STD_MAX_KEYBYTES  (16)
+#define ARC4_STD_CONTEXTBYTES  (259)
+
+
+
+#define STD_OFFSETS(s,l1,l2,p1,p2)  offsetof(s,l1), offsetof(s,l2),\
+    offsetof(s,p1), 0
+#define EXT_OFFSETS(s,l1,l2,p1,p2)  offsetof(s,l1), offsetof(s,l2),\
+    offsetof(s,p1), offsetof(s,p2)
+#define NULL_PTR_OFFSETS(s,l1,l2)   offsetof(s,l1), offsetof(s,l2), 0, 0
+#define ZERO_LEN_OFFSETS(s,p1,p2)   0, 0, offsetof(s,p1), offsetof(s,p2)
+#define ALL_ZERO_OFFSETS            0, 0, 0, 0
+
+static char NIL[] = {"NIL"};
+
+
+
+/*! \enum FLD_TYPE
+  \brief A field can either be for reading from or writing to
+ */
+typedef enum {
+    Read,
+    Write,
+    Extent
+} FLD_TYPE;
+
+
+/**
+ * DPD_FLD_DETAILS_ENTRY
+ *    Describes where and how a field in a request goes to a field in a DPD
+ */
+typedef struct
+{
+    char                    *txt;               /**< Description of the
+                                                 * field within the
+                                                 * request a NULL
+                                                 * indicates the end
+                                                 * of field entries   */
+    unsigned int            lenOffset1st;       /**< Offset into request
+                                                 * pointer for the
+                                                 * initial length field
+                                                 */
+    unsigned int            lenOffsetNxt;       /**< Offset into request
+                                                 * pointer for the next
+                                                 * length field. Used
+                                                 * when input points to
+                                                 * output of the
+                                                 * previous request   */
+    unsigned int            ptrOffset1st;       /**< Offset into request
+                                                 * pointer for the
+                                                 * initial data area  */
+    unsigned int            extOffset;
+    FLD_TYPE                dataType;           /**< Data type either:
+                                                 * a "Read" or "Write"
+                                                 * area               */
+    BOOLEAN                 (*pFncSize)(unsigned long len);
+    /**< Pointer to function that checks
+     * whether the length is
+     * consistent with the request */
+} DPD_FLD_DETAILS_ENTRY;
+
+/**
+ * DPD_DETAILS_ENTRY
+ * Describes how a request is broken into a single DPD or a set of chained
+ * DPDs
+ */
+typedef struct DPD_DETAILS_ENTRY
+{
+    unsigned long            opId;               /**< Operation ID for
+                                                  * entry             */
+    char                    *txt;                /**< Description of
+                                                  * request a NULL
+                                                  * indicates the end
+                                                  * of the table      */
+    unsigned long            sz;                 /**< Size of request */
+    const unsigned long     *hdrDesc;            /**< Descriptor Header
+                                                  */
+    unsigned int             lenOffsetBlockLen;  /**< Offset into
+                                                  * request pointer
+                                                  * for total length of
+                                                  * data              */
+    DPD_FLD_DETAILS_ENTRY    fld[NUM_DPD_FLDS];
+} DPD_DETAILS_ENTRY;        /* Each request is enumerated here */
+
+
+BOOLEAN ChkDesIvLen(unsigned long len);
+BOOLEAN ChkDesKeyLen(unsigned long len);
+BOOLEAN ChkDesStaticDataLen(unsigned long len);
+BOOLEAN ChkDesDataLen(unsigned long len);
+BOOLEAN ChkDesCryptLen(unsigned long len);
+BOOLEAN ChkDesCtxLen(unsigned long len);
+BOOLEAN ChkArcKeyLen(unsigned long len);
+BOOLEAN ChkArcCtxLen(unsigned long len);
+BOOLEAN ChkOptionalArcCtxLen(unsigned long len);
+BOOLEAN ChkEccLen(unsigned long len);
+BOOLEAN ChkAesIvLen(unsigned long len);
+BOOLEAN ChkAesKeyLen(unsigned long len);
+BOOLEAN ChkCcmpKeyLen(unsigned long len);
+
+
+DPD_DETAILS_ENTRY DpdDetails[] =
+{
+
+
+    /*
+     * DPD_RNG_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  (none)                (none)             (none)
+     * p2  (none)                (none)             (none)
+     * p3  (none)                (none)             (none)
+     * p4  rngData               rngBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_RNG_GROUP,
+        "DPD_RNG_GROUP",
+        sizeof(RNG_REQ),
+        RngDesc,
+        offsetof(RNG_REQ, rngBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL},
+            {"rngData",     STD_OFFSETS(RNG_REQ, rngBytes, rngBytes, rngData, rngData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                           Read,  NULL}
+        },
+    },
+
+
+    /*
+     * DPD_DES_CBC_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  inIvData              inIvBytes          (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               outBytes           (none)
+     * p5  outIvData             outIvBytes         (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_DES_CBC_GROUP,
+        "DPD_DES_CBC_GROUP",
+        sizeof(DES_CBC_CRYPT_REQ),
+        DesCbcReq,
+        offsetof(DES_CBC_CRYPT_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                             Read,  NULL},
+            {"inIvData",    STD_OFFSETS(DES_CBC_CRYPT_REQ, inIvBytes,  inIvBytes,  inIvData,  outIvData), Read,  ChkDesIvLen},
+            {"keyData",     STD_OFFSETS(DES_CBC_CRYPT_REQ, keyBytes,   keyBytes,   keyData,   keyData),   Read,  ChkDesKeyLen},
+            {"inData",      STD_OFFSETS(DES_CBC_CRYPT_REQ, inBytes,    inBytes,    inData,    inData),    Read,  ChkDesDataLen},
+            {"outData",     STD_OFFSETS(DES_CBC_CRYPT_REQ, inBytes,    inBytes,    outData,   outData),   Write, NULL},
+            {"outIvData",   STD_OFFSETS(DES_CBC_CRYPT_REQ, outIvBytes, outIvBytes, outIvData, outIvData), Write, ChkDesIvLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                             Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_DES_ECB_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  (none)                (none)             (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               inBytes            (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_DES_ECB_GROUP,
+        "DPD_DES_ECB_GROUP",
+        sizeof(DES_CRYPT_REQ),
+        DesReq,
+        offsetof(DES_CRYPT_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                 Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                 Read,  NULL},
+            {"keyData",     STD_OFFSETS(DES_CRYPT_REQ, keyBytes, keyBytes, keyData, keyData), Read,  ChkDesKeyLen},
+            {"inData",      STD_OFFSETS(DES_CRYPT_REQ, inBytes,  inBytes,  inData,  inData),  Read,  ChkDesDataLen},
+            {"outData",     STD_OFFSETS(DES_CRYPT_REQ, inBytes,  inBytes,  outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                 Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                 Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  inCtxData             inCtxBytes         (none)
+     * p2  (none)                (none)             (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               inBytes            (none)
+     * p5  outCtxData            outCtxBytes        (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP,
+        "DPD_RC4_LDCTX_CRYPT_ULCTX_GROUP",
+        sizeof(ARC4_LOADCTX_CRYPT_REQ),
+        Rc4LoadCtxUnloadCtxReq,
+        offsetof(ARC4_LOADCTX_CRYPT_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                                      Read,  NULL},
+            {"inCtxData",   STD_OFFSETS(ARC4_LOADCTX_CRYPT_REQ, inCtxBytes,  inCtxBytes,  inCtxData,  outCtxData), Read,  ChkArcCtxLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                                      Read,  NULL},
+            {"inData",      STD_OFFSETS(ARC4_LOADCTX_CRYPT_REQ, inBytes,     inBytes,     inData,     inData),     Read,  NULL},
+            {"outData",     STD_OFFSETS(ARC4_LOADCTX_CRYPT_REQ, inBytes,     inBytes,     outData,    outData),    Write, NULL},
+            {"outCtxData",  STD_OFFSETS(ARC4_LOADCTX_CRYPT_REQ, outCtxBytes, outCtxBytes, outCtxData, outCtxData), Write, ChkArcCtxLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                                      Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  (none)                (none)             (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               inBytes            (none)
+     * p5  outCtxData            outCtxBytes        (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP,
+        "DPD_RC4_LDKEY_CRYPT_ULCTX_GROUP",
+        sizeof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ),
+        Rc4LoadKeyUnloadCtxReq,
+        offsetof(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                                                Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                                                Read,  NULL},
+            {"keyData",     STD_OFFSETS(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, keyBytes,    keyBytes,    keyData,    keyData),    Read,  ChkArcKeyLen},
+            {"inData",      STD_OFFSETS(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, inBytes,     inBytes,     inData,     inData),     Read,  NULL},
+            {"outData",     STD_OFFSETS(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, inBytes,     inBytes,     outData,    outData),    Write, NULL},
+            {"outCtxData",  STD_OFFSETS(ARC4_LOADKEY_CRYPT_UNLOADCTX_REQ, outCtxBytes, outCtxBytes, outCtxData, outCtxData), Write, ChkArcCtxLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                                                Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_HASH_LDCTX_HASH_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  ctxData               ctxBytes           (none)
+     * p2  (none)                (none)             (none)
+     * p3  inData                inBytes            (none)
+     * p4  cmpData               outBytes           (none)
+     * p5  outData               outBytes           (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_HASH_LDCTX_HASH_ULCTX_GROUP,
+        "DPD_HASH_LDCTX_HASH_ULCTX_GROUP",
+        sizeof(HASH_REQ),
+        MdhaReq,
+        offsetof(HASH_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {"ctxData",     STD_OFFSETS(HASH_REQ, ctxBytes, outBytes, ctxData, outData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {"inData",      STD_OFFSETS(HASH_REQ, inBytes,  inBytes,  inData,  inData),  Read,  NULL},
+            {"cmpData",     STD_OFFSETS(HASH_REQ, outBytes, outBytes, cmpData, cmpData), Read,  NULL},
+            {"outData",     STD_OFFSETS(HASH_REQ, outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  ctxData               ctxBytes           (none)
+     * p2  (none)                (none)             (none)
+     * p3  inData                inBytes            (none)
+     * p4  cmpData               outBytes           (none)
+     * p5  outData               outBytes           (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP,
+        "DPD_HASH_LDCTX_HASH_PAD_ULCTX_GROUP",
+        sizeof(HASH_REQ),
+        MdhaPadReq,
+        offsetof(HASH_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {"ctxData",     STD_OFFSETS(HASH_REQ, ctxBytes, ctxBytes, ctxData, ctxData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {"inData",      STD_OFFSETS(HASH_REQ, inBytes,  inBytes,  inData,  inData),  Read,  NULL},
+            {"cmpData",     STD_OFFSETS(HASH_REQ, outBytes, outBytes, cmpData, cmpData), Read,  NULL},
+            {"outData",     STD_OFFSETS(HASH_REQ, outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_HASH_LDCTX_HMAC_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  (none)                (none)             (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  cmpData               outBytes           (none)
+     * p5  outData               outBytes           (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_HASH_LDCTX_HMAC_ULCTX_GROUP,
+        "DPD_HASH_LDCTX_HMAC_ULCTX_GROUP",
+        sizeof(HMAC_PAD_REQ),
+        HmacPadReq,
+        offsetof(HMAC_PAD_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                Read,  NULL},
+            {"keyData",     STD_OFFSETS(HMAC_PAD_REQ, keyBytes, keyBytes, keyData, keyData), Read,  NULL},
+            {"inData",      STD_OFFSETS(HMAC_PAD_REQ, inBytes,  inBytes,  inData,  inData),  Read,  NULL},
+            {"cmpData",     STD_OFFSETS(HMAC_PAD_REQ, outBytes, outBytes, cmpData, cmpData), Read,  NULL},
+            {"outData",     STD_OFFSETS(HMAC_PAD_REQ, outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_MM_LDCTX_EXP_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  modData               modBytes           (none)
+     * p1  (none)                (none)             (none)
+     * p2  aData                 aDataBytes         (none)
+     * p3  expData               expBytes           (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MM_LDCTX_EXP_ULCTX_GROUP,
+        "DPD_MM_LDCTX_EXP_ULCTX_GROUP",
+        sizeof(MOD_EXP_REQ),
+        PkhaMmExpReq,
+        offsetof(MOD_EXP_REQ, outBytes),
+        {
+            {"modData",     STD_OFFSETS(MOD_EXP_REQ, modBytes,   modBytes,   modData, modData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {"aData",       STD_OFFSETS(MOD_EXP_REQ, aDataBytes, aDataBytes, aData,   aData),   Read,  NULL},
+            {"expData",     STD_OFFSETS(MOD_EXP_REQ, expBytes,   expBytes,   expData, expData), Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_EXP_REQ, outBytes,   outBytes,   outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_MM_SS_RSA_EXP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  modData               modBytes           (none)
+     * p1  (none)                (none)             (none)
+     * p2  aData                 aDataBytes         (none)
+     * p3  expData               expBytes           (none)
+     * p4  bData                 bDataBytes         (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MM_SS_RSA_EXP,
+        "DPD_MM_SS_RSA_EXP",
+        sizeof(MOD_SS_EXP_REQ),
+        PkhaMmSsExpReq,
+        0,
+        {
+            {"modData",     STD_OFFSETS(MOD_SS_EXP_REQ, modBytes,   modBytes,   modData, modData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                      Read,  NULL},
+            {"aData",       STD_OFFSETS(MOD_SS_EXP_REQ, aDataBytes, aDataBytes, aData,   aData),   Read,  NULL},
+            {"expData",     STD_OFFSETS(MOD_SS_EXP_REQ, expBytes,   expBytes,   expData, expData), Read,  NULL},
+            {"bData",       STD_OFFSETS(MOD_SS_EXP_REQ, bDataBytes, bDataBytes, bData,   bData),   Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                      Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                      Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_MM_LDCTX_R2MODN_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  modData               modBytes           (none)
+     * p1  (none)                (none)             (none)
+     * p2  (none)                (none)             (none)
+     * p3  (none)                (none)             (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MM_LDCTX_R2MODN_ULCTX_GROUP,
+        "DPD_MM_LDCTX_R2MODN_ULCTX_GROUP",
+        sizeof(MOD_R2MODN_REQ),
+        PkhaModR2modnReq,
+        offsetof(MOD_R2MODN_REQ, outBytes),
+        {
+            {"modData",     STD_OFFSETS(MOD_R2MODN_REQ, modBytes, modBytes, modData, modData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_R2MODN_REQ, outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_MM_LDCTX_RRMODP_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  pData                 pBytes             (none)
+     * p1  (none)                (none)             (none)
+     * p2  (none)                (none)             (none)
+     * p3  NULL                  nBytes             (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MM_LDCTX_RRMODP_ULCTX_GROUP,
+        "DPD_MM_LDCTX_RRMODP_ULCTX_GROUP",
+        sizeof(MOD_RRMODP_REQ),
+        PkhaMmRrmodpReq,
+        offsetof(MOD_RRMODP_REQ, outBytes),
+        {
+            {"pData",       STD_OFFSETS(MOD_RRMODP_REQ,      pBytes,   pBytes,   pData,   pData),   Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                       Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                       Read,  NULL},
+            {"nBytes",      NULL_PTR_OFFSETS(MOD_RRMODP_REQ, nBytes,   nBytes),                     Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_RRMODP_REQ,      outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                       Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                       Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_MM_MOD_INV_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  nData                 nBytes             (none)
+     * p1  (none)                (none)             (none)
+     * p2  inData                inBytes            (none)
+     * p3  (none)                (none)             (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MM_MOD_INV_ULCTX_GROUP,
+        "DPD_MM_MOD_INV_ULCTX_GROUP",
+        sizeof(MOD_INV_REQ),
+        PkhaMmModInvReq,
+        offsetof(MOD_INV_REQ, outBytes),
+        {
+            {"nData",       STD_OFFSETS(MOD_INV_REQ,      nBytes,   nBytes,   nData,   nData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {"inData",      STD_OFFSETS(MOD_INV_REQ,      inBytes, inBytes, inData, inData),   Read, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_INV_REQ,      outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL}
+        },
+    },
+
+
+    /*
+     * DPD_F2M_INV_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  nData                 nBytes             (none)
+     * p1  (none)                (none)             (none)
+     * p2  inData                inBytes            (none)
+     * p3  (none)                (none)             (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+
+    {
+        DPD_F2M_INV_ULCTX_GROUP,
+        "DPD_F2M_INV_ULCTX_GROUP",
+        sizeof(F2M_INV_REQ),
+        PkhaF2MInvReq,
+        offsetof(F2M_INV_REQ, outBytes),
+        {
+            {"nData",       STD_OFFSETS(MOD_INV_REQ,      nBytes,   nBytes,   nData,   nData), Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {"inData",      STD_OFFSETS(MOD_INV_REQ,      inBytes, inBytes, inData, inData),   Read, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_INV_REQ,      outBytes, outBytes, outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                  Read,  NULL}
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_MM_LDCTX_2OP_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  modData               modBytes           (none)
+     * p1  bData                 bDataBytes         (none)
+     * p2  aData                 aDataBytes         (none)
+     * p3  (none)                (none)             (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_MOD_LDCTX_2OP_ULCTX_GROUP,
+        "DPD_MOD_LDCTX_2OP_ULCTX_GROUP",
+        sizeof(MOD_2OP_REQ),
+        PkhaMod2OpReq,
+        offsetof(MOD_2OP_REQ, outBytes),
+        {
+            {"modData",     STD_OFFSETS(MOD_2OP_REQ, modBytes,   modBytes,   modData, modData), Read,  NULL},
+            {"bData",       STD_OFFSETS(MOD_2OP_REQ, bDataBytes, bDataBytes, bData,   bData),   Read,  NULL},
+            {"aData",       STD_OFFSETS(MOD_2OP_REQ, aDataBytes, aDataBytes, aData,   aData),   Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {"outData",     STD_OFFSETS(MOD_2OP_REQ, outBytes,   outBytes,   outData, outData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_EC_LDCTX_kP_ULCTX_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  nData                 nDataBytes         (none)
+     * p1  eData                 eDataBytes         (none)
+     * p2  buildData             buildDataBytes     (none)
+     * p3  b1Data                b1DataBytes        (none)
+     * p4  b2Data                b2DataBytes        (none)
+     * p5  b3Data                b3DataBytes        (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_EC_LDCTX_kP_ULCTX_GROUP,
+        "DPD_EC_LDCTX_kP_ULCTX_GROUP",
+        sizeof(ECC_POINT_REQ),
+        PkhaEccPointReq,
+        offsetof(ECC_POINT_REQ, b3DataBytes),
+        {
+            {"nData",     STD_OFFSETS(ECC_POINT_REQ, nDataBytes,     nDataBytes,     nData,     nData),     Read,  NULL},
+            {"eData",     STD_OFFSETS(ECC_POINT_REQ, eDataBytes,     eDataBytes,     eData,     eData),     Read,  NULL},
+            {"buildData", STD_OFFSETS(ECC_POINT_REQ, buildDataBytes, buildDataBytes, buildData, buildData), Read,  NULL},
+            {"b1Data",    STD_OFFSETS(ECC_POINT_REQ, b1DataBytes,    b1DataBytes,    b1Data,    b1Data),    Write, NULL},
+            {"b2Data",    STD_OFFSETS(ECC_POINT_REQ, b2DataBytes,    b2DataBytes,    b2Data,    b2Data),    Write, NULL},
+            {"b3Data",    STD_OFFSETS(ECC_POINT_REQ, b3DataBytes,    b3DataBytes,    b3Data,    b3Data),    Write, NULL},
+            {NIL,         ALL_ZERO_OFFSETS,                                                                 Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_EC_2OP_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  bData                 bDataBytes         (none)
+     * p1  aData                 aDataBytes         (none)
+     * p2  modData               modBytes           (none)
+     * p3  outData               outBytes           (none)
+     * p4  (none)                (none)             (none)
+     * p5  (none)                (none)             (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_EC_2OP_GROUP,
+        "DPD_EC_2OP_GROUP",
+        sizeof(ECC_2OP_REQ),
+        PkhaEcc2OpReq,
+        offsetof(ECC_2OP_REQ, outBytes),
+        {
+            {"modData",     STD_OFFSETS(ECC_2OP_REQ, modBytes,   modBytes,   modData, modData), Read,  ChkEccLen},
+            {"bData",       STD_OFFSETS(ECC_2OP_REQ, bDataBytes, bDataBytes, bData,   bData),   Read,  ChkEccLen},
+            {"aData",       STD_OFFSETS(ECC_2OP_REQ, aDataBytes, aDataBytes, aData,   aData),   Read,  ChkEccLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {"outData",     STD_OFFSETS(ECC_2OP_REQ, outBytes,   outBytes,   outData, outData), Write, ChkEccLen},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                   Read,  NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_EC_SPKBUILD_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  a0Data                a0DataBytes        (none)
+     * p1  a1Data                a1DataBytes        (none)
+     * p2  a2Data                a2DataBytes        (none)
+     * p3  a3Data                a3DataBytes        (none)
+     * p4  b0Data                b0DataBytes        (none)
+     * p5  b1Data                b1DataBytes        (none)
+     * p6  buildData             buildDataBytes     (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_EC_SPKBUILD_GROUP,
+        "DPD_EC_SPKBUILD_GROUP",
+        sizeof(ECC_SPKBUILD_REQ),
+        PkhaEccSpkbuildReq,
+        offsetof(ECC_SPKBUILD_REQ, buildDataBytes),
+        {
+            {"a0Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, a0DataBytes,    a0DataBytes,    a0Data,    a0Data),    Read,  NULL},
+            {"a1Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, a1DataBytes,    a1DataBytes,    a1Data,    a1Data),    Read,  NULL},
+            {"a2Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, a2DataBytes,    a2DataBytes,    a2Data,    a2Data),    Read,  NULL},
+            {"a3Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, a3DataBytes,    a3DataBytes,    a3Data,    a3Data),    Read,  NULL},
+            {"b0Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, b0DataBytes,    b0DataBytes,    b0Data,    b0Data),    Read,  NULL},
+            {"b1Data",    STD_OFFSETS(ECC_SPKBUILD_REQ, b1DataBytes,    b1DataBytes,    b1Data,    b1Data),    Read,  NULL},
+            {"buildData", STD_OFFSETS(ECC_SPKBUILD_REQ, buildDataBytes, buildDataBytes, buildData, buildData), Write, NULL},
+        },
+    },
+
+
+
+
+    /*
+     * DPD_EC_PTADD_DBL_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  modData               modBytes           (none)
+     * p1  buildData             buildDataBytes     (none)
+     * p2  b2InData              b2InDataBytes      (none)
+     * p3  b3InData              b3InDataBytes      (none)
+     * p4  b1Data                b1DataBytes        (none)
+     * p5  b2Data                b2DataBytes        (none)
+     * p6  b3Data                b3DataBytes        (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_EC_PTADD_DBL_GROUP,
+        "DPD_EC_PTADD_DBL_GROUP",
+        sizeof(ECC_PTADD_DBL_REQ),
+        PkhaEccPtaddDblReq,
+        offsetof(ECC_PTADD_DBL_REQ, b3DataBytes),
+        {
+            {"modData",   STD_OFFSETS(ECC_PTADD_DBL_REQ, modBytes,       modBytes,       modData,   modData),   Read,  NULL},
+            {"buildData", STD_OFFSETS(ECC_PTADD_DBL_REQ, buildDataBytes, buildDataBytes, buildData, buildData), Read,  NULL},
+            {"b2InData",  STD_OFFSETS(ECC_PTADD_DBL_REQ, b2InDataBytes,  b2InDataBytes,  b2InData,  b2InData),  Read,  NULL},
+            {"b3InData",  STD_OFFSETS(ECC_PTADD_DBL_REQ, b3InDataBytes,  b3InDataBytes,  b3InData,  b3InData),  Read,  NULL},
+            {"b1Data",    STD_OFFSETS(ECC_PTADD_DBL_REQ, b1DataBytes,    b1DataBytes,    b1Data,    b1Data),    Write, NULL},
+            {"b2Data",    STD_OFFSETS(ECC_PTADD_DBL_REQ, b2DataBytes,    b2DataBytes,    b2Data,    b2Data),    Write, NULL},
+            {"b3Data",    STD_OFFSETS(ECC_PTADD_DBL_REQ, b3DataBytes,    b3DataBytes,    b3Data,    b3Data),    Write, NULL},
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_IPSEC_CBC_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  hashInData            hashInDataBytes    (none)
+     * p2  cryptKeyData          cryptKeyBytes      (none)
+     * p3  cryptCtxInData        cryptCtxInBytes    (none)
+     * p4  inData                inDataBytes        (none)
+     * p5  cryptDataOut          inDataBytes        (none)
+     * p6  hashDataOut           hashDataOutBytes   (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_IPSEC_CBC_GROUP,
+        "DPD_IPSEC_CBC_GROUP",
+        sizeof(IPSEC_CBC_REQ),
+        IpsecCbcReq,
+        offsetof(IPSEC_CBC_REQ, inDataBytes),
+        {
+            {"hashKeyData",    STD_OFFSETS(IPSEC_CBC_REQ, hashKeyBytes,     hashKeyBytes,     hashKeyData,    hashKeyData),    Read,  NULL},
+            {"hashInData",     STD_OFFSETS(IPSEC_CBC_REQ, hashInDataBytes,  hashInDataBytes,  hashInData,     hashInData),     Read,  NULL},
+            {"cryptKeyData",   STD_OFFSETS(IPSEC_CBC_REQ, cryptKeyBytes,    cryptKeyBytes,    cryptKeyData,   cryptKeyData),   Read,  ChkDesKeyLen},
+            {"cryptCtxInData", STD_OFFSETS(IPSEC_CBC_REQ, cryptCtxInBytes,  cryptCtxInBytes,  cryptCtxInData, cryptCtxInData), Read,  ChkDesCtxLen},
+            {"inData",         STD_OFFSETS(IPSEC_CBC_REQ, inDataBytes,      inDataBytes,      inData,         inData),         Read,  ChkDesStaticDataLen},
+            {"cryptDataOut",   STD_OFFSETS(IPSEC_CBC_REQ, inDataBytes,      inDataBytes,      cryptDataOut,   cryptDataOut),   Write, NULL},
+            {"hashDataOut",    STD_OFFSETS(IPSEC_CBC_REQ, hashDataOutBytes, hashDataOutBytes, hashDataOut,    hashDataOut),    Write, NULL}
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_IPSEC_ECB_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  hashInData            hashInDataBytes    (none)
+     * p2  cryptKeyData          cryptKeyBytes      (none)
+     * p3  (none)                (none)             (none)
+     * p4  inData                inDataBytes        (none)
+     * p5  cryptDataOut          inDataBytes        (none)
+     * p6  hashDataOut           hashDataOutBytes   (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_IPSEC_ECB_GROUP,
+        "DPD_IPSEC_ECB_GROUP",
+        sizeof(IPSEC_ECB_REQ),
+        IpsecEcbReq,
+        offsetof(IPSEC_ECB_REQ, inDataBytes),
+        {
+            {"hashKeyData",  STD_OFFSETS(IPSEC_ECB_REQ, hashKeyBytes,     hashKeyBytes,     hashKeyData,  hashKeyData),  Read,  NULL},
+            {"hashInData",   STD_OFFSETS(IPSEC_ECB_REQ, hashInDataBytes,  hashInDataBytes,  hashInData,   hashInData),   Read,  NULL},
+            {"cryptKeyData", STD_OFFSETS(IPSEC_ECB_REQ, cryptKeyBytes,    cryptKeyBytes,    cryptKeyData, cryptKeyData), Read,  ChkDesKeyLen},
+            {NIL,            ALL_ZERO_OFFSETS,                                                                           Read,  NULL},
+            {"inData",       STD_OFFSETS(IPSEC_ECB_REQ, inDataBytes,      inDataBytes,      inData,       inData),       Read,  ChkDesStaticDataLen},
+            {"cryptDataOut", STD_OFFSETS(IPSEC_ECB_REQ, inDataBytes,      inDataBytes,      cryptDataOut, cryptDataOut), Write, NULL},
+            {"hashDataOut",  STD_OFFSETS(IPSEC_ECB_REQ, hashDataOutBytes, hashDataOutBytes, hashDataOut,  hashDataOut),  Write, NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_IPSEC_ESP_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  hashInData            hashInDataBytes    (none)
+     * p2  cryptCtxInData        cryptCtxInBytes    (none)
+     * p3  cryptKeyData          cryptKeyBytes      (none)
+     * p4  inData                inDataBytes        (none)
+     * p5  cryptDataOut          inDataBytes        hashOutDataBytes
+     * p6  cryptCtxOutData       cryptCtxOutBytes   (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_IPSEC_ESP_GROUP,
+        "DPD_IPSEC_ESP_GROUP",
+        sizeof(IPSEC_ESP_REQ),
+        IpsecEspReq,
+        offsetof(IPSEC_ESP_REQ, inDataBytes),
+        {
+            {"hashKeyData",     STD_OFFSETS(IPSEC_ESP_REQ, hashKeyBytes,     hashKeyBytes,     hashKeyData,     hashKeyData),      Read,  NULL},
+            {"hashInData",      STD_OFFSETS(IPSEC_ESP_REQ, hashInDataBytes,  hashInDataBytes,  hashKeyData,     hashKeyData),      Read,  NULL},
+            {"cryptCtxInData",  STD_OFFSETS(IPSEC_ESP_REQ, cryptCtxInBytes,  cryptCtxInBytes,  cryptCtxInData,  cryptCtxInData),   Read,  ChkDesCtxLen},
+            {"cryptKeyData",    STD_OFFSETS(IPSEC_ESP_REQ, cryptKeyBytes,    cryptKeyBytes,    cryptKeyData,    cryptKeyData),     Read,  ChkDesKeyLen},
+            {"inData",          STD_OFFSETS(IPSEC_ESP_REQ, inDataBytes,      inDataBytes,      inData,          inData),           Read,  ChkDesStaticDataLen},
+            {"cryptDataOut",    EXT_OFFSETS(IPSEC_ESP_REQ, inDataBytes,      inDataBytes,      cryptDataOut,    hashDataOutBytes), Write, NULL},
+            {"cryptCtxOutData", STD_OFFSETS(IPSEC_ESP_REQ, cryptCtxOutBytes, cryptCtxOutBytes, cryptCtxOutData, cryptCtxOutData),  Write, ChkDesCtxLen}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_IPSEC_AES_CBC_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  hashInData            hashInDataBytes    (none)
+     * p2  cryptKeyData          cryptKeyBytes      (none)
+     * p3  cryptCtxInData        cryptCtxInBytes    (none)
+     * p4  inData                inDataBytes        (none)
+     * p5  cryptDataOut          inDataBytes        (none)
+     * p6  hashDataOut           hashDataOutBytes   (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_IPSEC_AES_CBC_GROUP,
+        "DPD_IPSEC_AES_CBC_GROUP",
+        sizeof(IPSEC_AES_CBC_REQ),
+        IpsecAesCbcReq,
+        offsetof(IPSEC_AES_CBC_REQ, inDataBytes),
+        {
+            {"hashKeyData",    STD_OFFSETS(IPSEC_CBC_REQ, hashKeyBytes,     hashKeyBytes,     hashKeyData,    hashKeyData),    Read,  NULL},
+            {"hashInData",     STD_OFFSETS(IPSEC_CBC_REQ, hashInDataBytes,  hashInDataBytes,  hashInData,     hashInData),     Read,  NULL},
+            {"cryptKeyData",   STD_OFFSETS(IPSEC_CBC_REQ, cryptKeyBytes,    cryptKeyBytes,    cryptKeyData,   cryptKeyData),   Read,  ChkAesKeyLen},
+            {"cryptCtxInData", STD_OFFSETS(IPSEC_CBC_REQ, cryptCtxInBytes,  cryptCtxInBytes,  cryptCtxInData, cryptCtxInData), Read,  ChkAesIvLen},
+            {"inData",         STD_OFFSETS(IPSEC_CBC_REQ, inDataBytes,      inDataBytes,      inData,         inData),         Read,  ChkDesStaticDataLen},
+            {"cryptDataOut",   STD_OFFSETS(IPSEC_CBC_REQ, inDataBytes,      inDataBytes,      cryptDataOut,   cryptDataOut),   Write, NULL},
+            {"hashDataOut",    STD_OFFSETS(IPSEC_CBC_REQ, hashDataOutBytes, hashDataOutBytes, hashDataOut,    hashDataOut),    Write, NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_IPSEC_AES_ECB_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  hashInData            hashInDataBytes    (none)
+     * p2  cryptKeyData          cryptKeyBytes      (none)
+     * p3  (none)                (none)             (none)
+     * p4  inData                inDataBytes        (none)
+     * p5  cryptDataOut          inDataBytes        (none)
+     * p6  hashDataOut           hashDataOutBytes   (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_IPSEC_AES_ECB_GROUP,
+        "DPD_IPSEC_AES_ECB_GROUP",
+        sizeof(IPSEC_AES_ECB_REQ),
+        IpsecAesEcbReq,
+        offsetof(IPSEC_AES_ECB_REQ, inDataBytes),
+        {
+            {"hashKeyData",  STD_OFFSETS(IPSEC_AES_ECB_REQ, hashKeyBytes,     hashKeyBytes,     hashKeyData,  hashKeyData),  Read,  NULL},
+            {"hashInData",   STD_OFFSETS(IPSEC_AES_ECB_REQ, hashInDataBytes,  hashInDataBytes,  hashInData,   hashInData),   Read,  NULL},
+            {"cryptKeyData", STD_OFFSETS(IPSEC_AES_ECB_REQ, cryptKeyBytes,    cryptKeyBytes,    cryptKeyData, cryptKeyData), Read,  ChkAesKeyLen},
+            {NIL,            ALL_ZERO_OFFSETS,                                                                               Read,  NULL},
+            {"inData",       STD_OFFSETS(IPSEC_AES_ECB_REQ, inDataBytes,      inDataBytes,      inData,       inData),       Read,  ChkDesStaticDataLen},
+            {"cryptDataOut", STD_OFFSETS(IPSEC_AES_ECB_REQ, inDataBytes,      inDataBytes,      cryptDataOut, cryptDataOut), Write, NULL},
+            {"hashDataOut",  STD_OFFSETS(IPSEC_AES_ECB_REQ, hashDataOutBytes, hashDataOutBytes, hashDataOut,  hashDataOut),  Write, NULL}
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_AESA_CRYPT_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  inIvData              inIvBytes          (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               inBytes            (none)
+     * p5  outCtxData            outCtxBytes        (none)
+     * p6  (none)                (none)             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_AESA_CRYPT_GROUP,
+        "DPD_AESA_CRYPT_GROUP",
+        sizeof(AESA_CRYPT_REQ),
+        AesaDesc,
+        offsetof(AESA_CRYPT_REQ, inBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                              Read,  NULL},
+            {"inIvData",    STD_OFFSETS(AESA_CRYPT_REQ, inIvBytes,   inIvBytes,   inIvData,   inIvData),   Read,  ChkAesIvLen},
+            {"keyData",     STD_OFFSETS(AESA_CRYPT_REQ, keyBytes,    keyBytes,    keyData,    keyData),    Read,  ChkAesKeyLen},
+            {"inData",      STD_OFFSETS(AESA_CRYPT_REQ, inBytes,     inBytes,     inData,     inData),     Read,  0},
+            {"outData",     STD_OFFSETS(AESA_CRYPT_REQ, inBytes,     inBytes,     outData,    outData),    Write, NULL},
+            {"outCtxData",  STD_OFFSETS(AESA_CRYPT_REQ, outCtxBytes, outCtxBytes, outCtxData, outCtxData), Write, NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                                              Read,  NULL}
+        },
+    },
+
+
+    /*
+     * DPD_AESA_MAC_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  inCtxData             inCtxBytes         (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  cmpIn                 cmpBytes           (none)
+     * p5  outCtxData            outCtxBytes        (none)
+     * p6  cmpOut                cmpBytes           (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_AESA_MAC_GROUP,
+        "DPD_AESA_MAC_GROUP",
+        sizeof(AESA_MAC_REQ),
+        AesaMACDesc,
+        offsetof(AESA_MAC_REQ, keyBytes),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                              Read,  NULL},
+            {"inCtxData",   STD_OFFSETS(AESA_MAC_REQ, inCtxBytes,  inCtxBytes,   inCtxData,  inCtxData),   Read,  ChkAesIvLen},
+            {"keyData",     STD_OFFSETS(AESA_MAC_REQ, keyBytes,    keyBytes,     keyData,    keyData),     Read,  ChkAesKeyLen},
+            {"inData",      STD_OFFSETS(AESA_MAC_REQ, inBytes,     inBytes,      inData,     inData),      Read,  0},
+            {"cmpIn",       STD_OFFSETS(AESA_MAC_REQ, cmpBytes,    cmpBytes,     cmpIn,      cmpIn),       Read,  NULL},
+            {"outCtxData",  STD_OFFSETS(AESA_MAC_REQ, outCtxBytes, outCtxBytes,  outCtxData, outCtxData),  Write, NULL},
+            {"cmpOut",      STD_OFFSETS(AESA_MAC_REQ, cmpBytes,    cmpBytes,     cmpOut,     cmpOut),      Write, NULL}
+        },
+    },
+
+
+
+    /*
+     * DPD_AESA_GCM_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  gcmCtxData            gcmCtxBytes        (none)
+     * p1  AAD                   AADBytes           (none)
+     * p2  ivIn                  ivBytes            (none)
+     * p3  keyData               keyBytes           saltBytes
+     * p4  inData                inBytes            (none)
+     * p5  outData               outBytes           cmpBytes
+     * p6  ivOut                 ivBytes            crcBytes
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_AESA_GCM_GROUP,
+        "DPD_AESA_GCM_GROUP",
+        sizeof(AESA_GCM_REQ),
+        AesaGCMDesc,
+        offsetof(AESA_GCM_REQ, gcmCtxBytes),
+        {
+            {"gcmCtxData",  STD_OFFSETS(AESA_GCM_REQ,   gcmCtxBytes, gcmCtxBytes, gcmCtxData, gcmCtxData), Read,  NULL},
+            {"AAD",         STD_OFFSETS(AESA_GCM_REQ,   AADBytes,    AADBytes,    AAD,        AAD),        Read,  0},
+            {"IVin",        STD_OFFSETS(AESA_GCM_REQ,   ivBytes,     ivBytes,     ivIn,       ivIn),     Read,  0},
+            {"key",         EXT_OFFSETS(AESA_GCM_REQ,   keyBytes,    keyBytes,    keyData,    saltBytes),  Read,  0},
+            {"inData",      STD_OFFSETS(AESA_GCM_REQ,   inBytes,     inBytes,     inData,     inData),     Read,  0},
+            {"outData",     EXT_OFFSETS(AESA_GCM_REQ,   outBytes,    outBytes,    outData,    cmpBytes),   Write, NULL},
+            {"IVout",       EXT_OFFSETS(AESA_GCM_REQ,   ivBytes,     ivBytes,     ivOut,      crcBytes),   Write, NULL},
+        },
+    },
+
+
+
+
+    /*
+     * DPD_CCMP_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  context               ctxBytes           (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  AADData               AADBytes           (none)
+     * p4  FrameData             FrameDataBytes     (none)
+     * p5  cryptDataOut          cryptDataBytes     (none)
+     * p6  MICData               MICBytes           (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_CCMP_GROUP,
+        "DPD_CCMP_GROUP",
+        sizeof(CCMP_REQ),
+        CcmpReq,
+        offsetof(CCMP_REQ, MICData),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                                  Read,  NULL},
+            {"context",     STD_OFFSETS(CCMP_REQ, ctxBytes,       ctxBytes,       context,      context),      Read,  NULL},
+            {"keyData",     STD_OFFSETS(CCMP_REQ, keyBytes,       keyBytes,       keyData,      keyData),      Read,  ChkCcmpKeyLen},
+            {"AADData",     STD_OFFSETS(CCMP_REQ, AADBytes,       AADBytes,       AADData,      AADData),      Read,  0},
+            {"FrameData",   STD_OFFSETS(CCMP_REQ, FrameDataBytes, FrameDataBytes, FrameData,    FrameData),    Read,  0},
+            {"cryptDataOut",STD_OFFSETS(CCMP_REQ, cryptDataBytes, cryptDataBytes, cryptDataOut, cryptDataOut), Write, NULL},
+            {"MICData",     STD_OFFSETS(CCMP_REQ, MICBytes,       MICBytes,       MICData,      MICData),      Write, NULL}
+        },
+    },
+
+
+
+
+    /*
+     * DPD_SRTP_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes       (none)
+     * p1  ivData                ivBytes            (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            HeaderBytes
+     * p4  cryptDataOut          cryptDataBytes     ROCBytes
+     * p5  digestData            digestBytes        (none)
+     * p6  outIvData             outIvBytes         (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_SRTP_GROUP,
+        "DPD_SRTP_GROUP",
+        sizeof(SRTP_REQ),
+        SrtpReq,
+        offsetof(SRTP_REQ, outIvData),
+        {
+            {"hashKeyData", STD_OFFSETS(SRTP_REQ, hashKeyBytes,   hashKeyBytes,   hashKeyData,  hashKeyData), Read,  NULL},
+            {"ivData",      STD_OFFSETS(SRTP_REQ, ivBytes,        ivBytes,        ivData,       ivData),      Read,  NULL},
+            {"keyData",     STD_OFFSETS(SRTP_REQ, keyBytes,       keyBytes,       keyData,      keyData),     Read,  ChkAesKeyLen},
+            {"inData",      EXT_OFFSETS(SRTP_REQ, inBytes,        inBytes,        inData,       HeaderBytes), Read,  0},
+            {"cryptDataOut",EXT_OFFSETS(SRTP_REQ, cryptDataBytes, cryptDataBytes, cryptDataOut, ROCBytes),    Write, NULL},
+            {"digestData",  STD_OFFSETS(SRTP_REQ, digestBytes,    digestBytes,    digestData,   digestData),  Read,  0},
+            {"outIvData",   STD_OFFSETS(SRTP_REQ, outIvBytes,     outIvBytes,     outIvData,    outIvData),   Write, NULL}
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_KEA_CRYPT_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  ivData                ivBytes            (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  ctxData               ctxBytes           (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_KEA_CRYPT_GROUP,
+        "DPD_KEA_CRYPT_GROUP",
+        sizeof(KEA_CRYPT_REQ),
+        KeaReq,
+        offsetof(KEA_CRYPT_REQ, ctxData),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                         Read,  NULL},
+            {"ivData",      STD_OFFSETS(KEA_CRYPT_REQ, ivBytes,    ivBytes,    ivData,    ivData),    Read,  NULL},
+            {"keyData",     STD_OFFSETS(KEA_CRYPT_REQ, keyBytes,   keyBytes,   keyData,   keyData),   Read,  NULL},
+            {"inData",      STD_OFFSETS(KEA_CRYPT_REQ, inBytes,    inBytes,    inData,    inData),    Read,  NULL},
+            {"outData",     STD_OFFSETS(KEA_CRYPT_REQ, outBytes,   outBytes,   outData,   outData),   Write, NULL},
+            {"outIvData",   STD_OFFSETS(KEA_CRYPT_REQ, outIvBytes, outIvBytes, outIvData, outIvData), Write, NULL},
+            {"ctxData",     STD_OFFSETS(KEA_CRYPT_REQ, ctxBytes,   ctxBytes,   ctxData,   ctxData),   Write, NULL}
+        },
+    },
+
+    /*
+     * DPD_SNOW3G_CRYPT_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  ivData                ivBytes            (none)
+     * p2  keyData               keyBytes           (none)
+     * p3  inData                inBytes            (none)
+     * p4  outData               outBytes           (none)
+     * p5  (none)                (none)             (none)
+     * p6  ctxData               ctxBytes           (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_SNOW3G_CRYPT_GROUP,
+        "DPD_SNOW3G_CRYPT_GROUP",
+        sizeof(SNOW3G_CRYPT_REQ),
+        SnoReq,
+        offsetof(SNOW3G_CRYPT_REQ, ctxData),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                                            Read,  NULL},
+            {"ivData",      STD_OFFSETS(SNOW3G_CRYPT_REQ, ivBytes,    ivBytes,    ivData,    ivData),    Read,  NULL},
+            {"keyData",     STD_OFFSETS(SNOW3G_CRYPT_REQ, keyBytes,   keyBytes,   keyData,   keyData),   Read,  NULL},
+            {"inData",      STD_OFFSETS(SNOW3G_CRYPT_REQ, inBytes,    inBytes,    inData,    inData),    Read,  NULL},
+            {"outData",     STD_OFFSETS(SNOW3G_CRYPT_REQ, outBytes,   outBytes,   outData,   outData),   Write, NULL},
+            {"outIvData",   STD_OFFSETS(SNOW3G_CRYPT_REQ, outIvBytes, outIvBytes, outIvData, outIvData), Write, NULL},
+            {"ctxData",     STD_OFFSETS(SNOW3G_CRYPT_REQ, ctxBytes,   ctxBytes,   ctxData,   ctxData),   Write, NULL}
+        },
+    },
+
+
+    /*
+     * DPD_RAID_XOR_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  (none)                (none)             (none)
+     * p1  (none)                (none)             (none)
+     * p2  (none)                (none)             (none)
+     * p3  inDataA               opSize             (none)
+     * p4  inDataB               opSize             (none)
+     * p5  inDataC               opSize             (none)
+     * p6  outData               opSize             (none)
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_RAID_XOR_GROUP,
+        "DPD_RAID_XOR_GROUP",
+        sizeof(RAID_XOR_REQ),
+        RaidXorReq,
+        offsetof(RAID_XOR_REQ, outData),
+        {
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {NIL,           ALL_ZERO_OFFSETS,                                            Read,  NULL},
+            {"inDataA",     STD_OFFSETS(RAID_XOR_REQ, opSize, opSize, inDataA, inDataA), Read,  NULL},
+            {"inDataB",     STD_OFFSETS(RAID_XOR_REQ, opSize, opSize, inDataB, inDataB), Read,  NULL},
+            {"inDataC",     STD_OFFSETS(RAID_XOR_REQ, opSize, opSize, inDataC, inDataC), Read,  NULL},
+            {"outData",     STD_OFFSETS(RAID_XOR_REQ, opSize, opSize, outData, outData), Write, NULL},
+        },
+    },
+
+
+    /*
+     * DPD_TLS_BLOCK_INBOUND_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes
+     * p1  hashOnlyData                             hashOnlyBytes
+     * p2  ivData                ivBytes
+     * p3  cipherKeyData         cipherKeyBytes
+     * p4  inData                inBytes            MACcmpBytes
+     * p5  outData               outBytes           MACoutBytes
+     * p6  ivOutData             ivOutBytes
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_TLS_BLOCK_INBOUND_GROUP,
+        "DPD_TLS_BLOCK_INBOUND_GROUP",
+        sizeof(TLS_BLOCK_INBOUND_REQ),
+        TlsBlockInboundReq,
+        offsetof(TLS_BLOCK_INBOUND_REQ, ivOutData),
+        {
+            {"hashKeyData",   STD_OFFSETS(TLS_BLOCK_INBOUND_REQ, hashKeyBytes,   hashKeyBytes,   hashKeyData,   hashKeyData),   Read,  NULL},
+            {"hashOnlyData",  EXT_OFFSETS(TLS_BLOCK_INBOUND_REQ, hashOnlyBytes,  hashOnlyBytes,  hashOnlyData,  hashOnlyBytes), Read,  NULL},
+            {"ivData",        STD_OFFSETS(TLS_BLOCK_INBOUND_REQ, ivBytes,        ivBytes,        ivData,        ivData),        Read,  NULL},
+            {"cipherKeyData", STD_OFFSETS(TLS_BLOCK_INBOUND_REQ, cipherKeyBytes, cipherKeyBytes, cipherKeyData, cipherKeyData), Read,  NULL},
+            {"inData",        EXT_OFFSETS(TLS_BLOCK_INBOUND_REQ, inBytes,        inBytes,        inData,        MACcmpBytes),   Read,  NULL},
+            {"outData",       EXT_OFFSETS(TLS_BLOCK_INBOUND_REQ, outBytes,       outBytes,       outData,       MACoutBytes),   Write, NULL},
+            {"ivOutData",     STD_OFFSETS(TLS_BLOCK_INBOUND_REQ, ivOutBytes,     ivOutBytes,     ivOutData,     ivOutData),     Write, NULL}
+        },
+    },
+
+
+
+    /*
+     * DPD_TLS_BLOCK_OUTBOUND_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes
+     * p1  ivData                ivBytes
+     * p2  cipherKeyData         cipherKeyBytes
+     * p3  hashOnlyData          mainDataBytes      hashOnlyBytes
+     * p4  cipherOnlyData        cipherOnlyBytes    MACbytes
+     * p5  outData               outBytes
+     * p6  ivOutData             ivOutBytes
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_TLS_BLOCK_OUTBOUND_GROUP,
+        "DPD_TLS_BLOCK_OUTBOUND_GROUP",
+        sizeof(TLS_BLOCK_OUTBOUND_REQ),
+        TlsBlockOutboundReq,
+        offsetof(TLS_BLOCK_OUTBOUND_REQ, ivOutData),
+        {
+            {"hashKeyData",    STD_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, hashKeyBytes,    hashKeyBytes,    hashKeyData,    hashKeyData),    Read,  NULL},
+            {"ivData",         STD_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, ivBytes,         ivBytes,         ivData,         ivData),         Read,  NULL},
+            {"cipherKeyData",  STD_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, cipherKeyBytes,  cipherKeyBytes,  cipherKeyData,  cipherKeyData),  Read,  NULL},
+            {"hashOnlyData",   EXT_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, mainDataBytes,   mainDataBytes,   hashOnlyData,   hashOnlyBytes),  Read,  NULL},
+            {"cipherOnlyData", EXT_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, cipherOnlyBytes, cipherOnlyBytes, cipherOnlyData, MACbytes),       Write, NULL},
+            {"outData",        STD_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, outBytes,        outBytes,        outData,        outData),        Read,  NULL},
+            {"ivOutData",      STD_OFFSETS(TLS_BLOCK_OUTBOUND_REQ, ivOutBytes,      ivOutBytes,      ivOutData,      ivOutData),      Write, NULL}
+        },
+    },
+
+
+
+
+
+    /*
+     * DPD_TLS_STREAM_INBOUND_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes
+     * p1  hashOnlyData                             hashOnlyBytes
+     * p2  ivData                ivBytes
+     * p3  cipherKeyData         cipherKeyBytes
+     * p4  inData                inBytes            MACcmpBytes
+     * p5  outData               outBytes           MACoutBytes
+     * p6  ivOutData             ivOutBytes
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_TLS_STREAM_INBOUND_GROUP,
+        "DPD_TLS_STREAM_INBOUND_GROUP",
+        sizeof(TLS_STREAM_INBOUND_REQ),
+        TlsStreamInboundReq,
+        offsetof(TLS_STREAM_INBOUND_REQ, ivOutBytes),
+        {
+            {"hashKeyData",   STD_OFFSETS(TLS_STREAM_INBOUND_REQ, hashKeyBytes,   hashKeyBytes,   hashKeyData,   hashKeyData),   Read,  NULL},
+            {"hashOnlyData",  EXT_OFFSETS(TLS_STREAM_INBOUND_REQ, hashOnlyBytes,  hashOnlyBytes,  hashOnlyData,  hashOnlyBytes), Read,  NULL},
+            {"ivData",        STD_OFFSETS(TLS_STREAM_INBOUND_REQ, ivBytes,        ivBytes,        ivData,        ivData),        Read,  NULL},
+            {"cipherKeyData", STD_OFFSETS(TLS_STREAM_INBOUND_REQ, cipherKeyBytes, cipherKeyBytes, cipherKeyData, cipherKeyData), Read,  NULL},
+            {"inData",        EXT_OFFSETS(TLS_STREAM_INBOUND_REQ, inBytes,        inBytes,        inData,        MACcmpBytes),   Read,  NULL},
+            {"outData",       EXT_OFFSETS(TLS_STREAM_INBOUND_REQ, outBytes,       outBytes,       outData,       MACoutBytes),   Write, NULL},
+            {"ivOutData",     STD_OFFSETS(TLS_STREAM_INBOUND_REQ, ivOutBytes,     ivOutBytes,     ivOutData,     ivOutData),     Write, NULL}
+        },
+    },
+
+
+
+
+
+
+    /*
+     * DPD_TLS_STREAM_OUTBOUND_GROUP
+     *     pointer               length             extent
+     * ----------------------------------------------------------------
+     * p0  hashKeyData           hashKeyBytes
+     * p1  ivData                ivBytes
+     * p2  cipherKeyData         cipherKeyBytes
+     * p3  hashOnlyData          mainDataBytes      hashOnlyBytes
+     * p4  outData               outBytes           MACbytes
+     * p5
+     * p6  ivOutData             ivOutBytes
+     * ----------------------------------------------------------------
+     */
+    {
+        DPD_TLS_STREAM_OUTBOUND_GROUP, "DPD_TLS_STREAM_OUTBOUND_GROUP",
+        sizeof(TLS_STREAM_OUTBOUND_REQ), TlsStreamOutboundReq,
+        offsetof(TLS_STREAM_OUTBOUND_REQ, ivOutBytes),
+        {
+            {"hashKeyData",    STD_OFFSETS(TLS_STREAM_OUTBOUND_REQ, hashKeyBytes,   hashKeyBytes,   hashKeyData,   hashKeyData),   Read,  NULL},
+            {"ivData",         STD_OFFSETS(TLS_STREAM_OUTBOUND_REQ, ivBytes,        ivBytes,        ivData,        ivData),        Read,  NULL},
+            {"cipherKeyData",  STD_OFFSETS(TLS_STREAM_OUTBOUND_REQ, cipherKeyBytes, cipherKeyBytes, cipherKeyData, cipherKeyData), Read,  NULL},
+            {"hashOnlyData",   EXT_OFFSETS(TLS_STREAM_OUTBOUND_REQ, mainDataBytes,  mainDataBytes,  hashOnlyData,  hashOnlyBytes), Read,  NULL},
+            {"outData",        EXT_OFFSETS(TLS_STREAM_OUTBOUND_REQ, outBytes,       outBytes,       outData,       MACbytes),      Write, NULL},
+            {NIL,              ALL_ZERO_OFFSETS,                                                                                  Read,  NULL},
+            {"ivOutData",      STD_OFFSETS(TLS_STREAM_OUTBOUND_REQ, ivOutBytes,     ivOutBytes,     ivOutData,     ivOutData),     Write, NULL}
+        },
+    },
+
+    /* Always terminates list, keep this line at the end when adding functions */
+    {
+        0, NULL,
+        0, NULL,
+        0,
+        {
+            {NULL, ALL_ZERO_OFFSETS, Read, NULL},
+        },
+    },
+
+};
+
+
+int VerifyRequest(register void *rq, register DPD_DETAILS_ENTRY *dpdmap)
+{
+    register int           i;
+    register unsigned long len;
+
+    for (i = 0; i < NUM_DPD_FLDS && dpdmap->fld[i].txt != NULL; i++)
+    {
+
+        if (dpdmap->fld[i].pFncSize != NULL)
+        {
+            len = *(unsigned int *)((unsigned int)rq + dpdmap->fld[i].lenOffset1st);
+
+            if (!dpdmap->fld[i].pFncSize(len))
+                return SEC2_INVALID_LENGTH;
+        }
+
+        if (dpdmap->fld[i].extOffset != 0)
+        {
+            len = *(unsigned int *)((unsigned int)rq + dpdmap->fld[i].extOffset);
+            if (len >= 128)
+                return SEC2_INVALID_LENGTH;
+        }
+    }
+
+    return SEC2_SUCCESS;
+}
+
+
+
+
+
+/**
+ * Scan the DPDDetails table for a particular opId value.
+ * Return a pointer to the entry if it is found, NULL otherwise
+ */
+DPD_DETAILS_ENTRY *GetRequestDescEntry(unsigned long opId)
+{
+    int i = 0;
+
+    opId &= DESC_TYPE_MASK;
+    while (DpdDetails[i].txt != NULL && DpdDetails[i].opId != opId) i++;
+
+    return(DpdDetails[i].opId == 0 ? NULL : &DpdDetails[i]);
+}
+
+
+
+/**
+ * This needs to get the core info from the RM */
+int CheckCapability(unsigned long opID)
+{
+    /*
+       switch (opID & 0xf000)
+       {
+       case RNG_GROUP:
+       if (DevCapability & CHA_RNGA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case DES_GROUP:
+       if (DevCapability & CHA_DESA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case ARC4_GROUP:
+       if (DevCapability & CHA_AFHA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case MD_GROUP:
+       if (DevCapability & CHA_MDHA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case PK_GROUP:
+       if (DevCapability & CHA_PKHA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case AES_GROUP:
+       if (DevCapability & CHA_AESA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       case IPSEC_DES_GROUP:
+       case TLS_GROUP:
+       if ((DevCapability & CHA_MDHA_BITMASK) &&
+       (DevCapability & CHA_DESA_BITMASK))
+       return(SEC2_SUCCESS);
+
+       case IPSEC_AES_GROUP:
+       if ((DevCapability & CHA_MDHA_BITMASK) &&
+       (DevCapability & CHA_AESA_BITMASK))
+       return(SEC2_SUCCESS);
+
+       case KEA_GROUP:
+       if (DevCapability & CHA_KEA_BITMASK)
+       return(SEC2_SUCCESS);
+
+       default:
+       return (SEC2_INVALID_CHA_TYPE);
+       }
+
+       return (SEC2_INVALID_CHA_TYPE);
+     */
+    return SEC2_SUCCESS;
+}
+
+
+BOOLEAN ChkDesIvLen(unsigned long len)
+{
+    return len != 0 && len != DES_STD_BLOCKSIZE ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkDesKeyLen(unsigned long len)
+{
+    return len != DES_STD_BLOCKSIZE && len != (2 * DES_STD_BLOCKSIZE) && len != (3 * DES_STD_BLOCKSIZE) ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkDesStaticDataLen(unsigned long len)
+{
+    return (len & 0x7) != 0 ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkDesDataLen(unsigned long len)
+{
+    return (len & 0x7) != 0 ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkDesCtxLen(unsigned long len)
+{
+    return len != 0 && len != DES_STD_BLOCKSIZE ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkAesKeyLen(unsigned long len)
+{
+    return len != 16 && len != 24 && len != 32 ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkAesIvLen(unsigned long len)
+{
+    return len != 0 && len != 16 ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkArcKeyLen(unsigned long len)
+{
+    return len < ARC4_STD_MIN_KEYBYTES || len > ARC4_STD_MAX_KEYBYTES ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkArcCtxLen(unsigned long len)
+{
+    return len != ARC4_STD_CONTEXTBYTES ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkOptionalArcCtxLen(unsigned long len)
+{
+    return len != ARC4_STD_CONTEXTBYTES && len != 0 ? FALSE : TRUE;
+}
+
+
+
+BOOLEAN ChkEccLen(unsigned long len)
+{
+    return len > 64 ? FALSE : TRUE;
+}
+
+#if 0
+
+BOOLEAN FitInBlock(unsigned long len)
+{
+    return len > BlockSize ? FALSE : TRUE;
+}
+#endif
+
+
+
+BOOLEAN ChkCcmpKeyLen(unsigned long len)
+{
+    return len != 0 && len != 16 ? FALSE : TRUE;
+}
+
+
+
+
+
+int constructDPDlist(GENERIC_REQ   *rqList,
+                     RMexecMessage *execMsg,
+                     PTRTYPE        memtype)
+{
+    DPD_DETAILS_ENTRY *dpdmap;
+    T2DPD             *thisDPD;
+    T2DESC_AUXMAP     *thisDPDmap;
+    int                i, status, dpdcount;
+    GENERIC_REQ       *thisRQ;
+
+    if (rqList == NULL)
+        return SEC2_NULL_REQUEST;
+
+    dpdcount   = 0;
+    thisRQ     = rqList;
+    thisDPD    = execMsg->descHead;
+    thisDPDmap = execMsg->descBufferMap;
+
+    do
+    {
+        dpdmap = GetRequestDescEntry(thisRQ->opId);
+        if (dpdmap == NULL)
+            return SEC2_INVALID_OPERATION_ID;
+
+        status = CheckCapability(thisRQ->opId);
+        if (status != SEC2_SUCCESS)
+            return status;
+
+        status = VerifyRequest(thisRQ, dpdmap);
+        if (status != SEC2_SUCCESS)
+            return status;
+
+
+        /* Get the descriptor header */
+        thisDPD->hdr = dpdmap->hdrDesc[1 * (thisRQ->opId & DESC_NUM_MASK)];
+
+        /* Now process each pair */
+        for (i = 0;
+             (i < TOTAL_PAIRS) && (dpdmap->fld[i].txt != NULL);
+             i++)
+        {
+            if (*dpdmap->fld[i].txt == *"NIL")
+            {
+                thisDPD->pair[i].ptr    = NULL;
+                thisDPD->pair[i].eptr   = 0;
+                thisDPD->pair[i].size   = 0;
+                thisDPD->pair[i].extent = 0;
+            }
+            else /* is non NIL pair, and has value */
+            {
+                if ((dpdmap->fld[i].ptrOffset1st != 0) &&
+                        *(unsigned int *)
+                        ((unsigned int)thisRQ + dpdmap->fld[i].ptrOffset1st))
+                {
+                    /* Extract the pointer using the dpdmap offset */
+                    thisDPD->pair[i].ptr =
+                        (void *)(*(unsigned int *)
+                                 ((unsigned int)thisRQ + dpdmap->fld[i].ptrOffset1st));
+
+                    /* 36-bit addressing not in use for legacy, zero it */
+                    thisDPD->pair[i].eptr = 0;
+
+                    /* Extract the length using the dpdmap offset */
+                    thisDPD->pair[i].size =
+                        *(unsigned int *)
+                        ((unsigned int)thisRQ + dpdmap->fld[i].lenOffset1st);
+
+                    /* Extract the (optional) extent using the dpdmap offset */
+                    if (dpdmap->fld[i].extOffset)
+                        thisDPD->pair[i].extent =
+                            (*(unsigned int *)
+                             ((unsigned int)thisRQ + dpdmap->fld[i].extOffset) &
+                             EXTENT_MASK);
+                    else
+                        thisDPD->pair[i].extent = 0;
+
+                    switch(memtype)
+                    {
+                        /* If we know it's a phyiscal pointer, don't have to */
+                        /* do anything                                       */
+                        case PTR_PHYSICAL:
+                            break;
+
+
+                            /* If logical, then we assume that the buffer is     */
+                            /* contiguous, and we only have to substitute a      */
+                            /* physical address for the pointer specified        */
+                        case PTR_LOGICAL:
+                            status = xwcMemTranslateLogical(i, thisDPD, thisDPDmap);
+                            if (status)
+                            {
+                                printk("t23xsec2: can't translate logical address\n");
+                                return SEC2_ADDRESS_PROBLEM;
+                            }
+                            break;
+
+
+                            /* If user virtual, we have look at the page map for */
+                            /* this buffer, create a scatterlist, and lock in    */
+                            /* pages in question                                 */
+                        case PTR_USER_VIRTUAL:
+                            status = xwcMemTranslateUserVirtual(i, thisDPD, thisDPDmap);
+                            if (status)
+                            {
+                                printk("t23xsec2: can't translate user virtual address\n");
+                                return SEC2_ADDRESS_PROBLEM;
+                            }
+                            break;
+
+
+                            /* If kernel virtual, we have to build a scatterlist */
+                            /* Not supported at this time - if ever...           */
+                        case PTR_KERNEL_VIRTUAL:
+                            status = xwcMemTranslateKernelVirtual(i, thisDPD, thisDPDmap);
+                            if (status)
+                            {
+                                printk("t23xsec2: can't translate kernel virtual address\n");
+                                return SEC2_ADDRESS_PROBLEM;
+                            }
+                            break;
+
+
+                            /* NO default, if no specifed type, this is a bug... */
+                        default:
+                            return SEC2_ADDRESS_PROBLEM;
+
+                    } /* switch (memtype) */
+                } /* if (a real pointer) */
+                else /* valid field, but no data needed, so clear it */
+                {
+                    thisDPD->pair[i].ptr    = NULL;
+                    thisDPD->pair[i].eptr   = 0;
+                    thisDPD->pair[i].size   = 0;
+                    thisDPD->pair[i].extent = 0;
+                }
+            } /* non-NULL pair */
+        } /* for (each pair) */
+
+        /* If this is the last RQ in the list, then mark this DPD */
+        /* to generate an interrupt. Not sure it's appropriate to */
+        /* stay this way...                                      */
+
+        if (thisRQ->nextReq == NULL)
+            thisDPD->hdr |= HDR_DONE;
+
+        /* Done with this DPD, go to next */
+        thisRQ = thisRQ->nextReq;
+        thisDPD++;
+        thisDPDmap++;
+
+        /* This should be dynamic...*/
+        if (++dpdcount > T2_CHANNEL_FIFO_DEPTH)
+            return SEC2_INSUFFICIENT_REQS;
+
+    } while (thisRQ != NULL);
+
+    execMsg->descCount = dpdcount;
+
+    return SEC2_SUCCESS;
+}
+
+
+/**
+ * After done with a DPD list, free any resources it may have used */
+int releaseDPDlist(RMexecMessage *execMsg,
+                   PTRTYPE        memtype)
+{
+    int            i, status, totalDPDs;
+    T2DPD         *thisDPD;
+    T2DESC_AUXMAP *thisDPDmap;
+
+
+    thisDPD    = execMsg->descHead;
+    thisDPDmap = execMsg->descBufferMap;
+    totalDPDs  = execMsg->descCount;
+
+    do
+    {
+        for (i = 0; (i < TOTAL_PAIRS); i++)
+        {
+            if (thisDPD->pair[i].ptr != NULL)
+                switch (memtype)
+                {
+                    case PTR_PHYSICAL:
+                    case PTR_LOGICAL:
+                        break;
+
+                    case PTR_USER_VIRTUAL:
+                        status = xwcMemReleaseUserVirtual(i, thisDPD, thisDPDmap);
+                        if (status)
+                        {
+                            printk("t2xsec2: can't release user virtual buffer\n");
+                            return SEC2_UNKNOWN_ERROR;
+                        }
+                        break;
+
+                    case PTR_KERNEL_VIRTUAL:
+                        status = xwcMemReleaseKernelVirtual(i, thisDPD, thisDPDmap);
+                        if (status)
+                        {
+                            printk("t2xsec2: can't release kernel virtual address\n");
+                            return SEC2_UNKNOWN_ERROR;
+                        }
+                        break;
+
+                    default:
+                        return SEC2_ADDRESS_PROBLEM;
+
+                } /* switch (memtype) */
+            /* if (valid pair) */
+        } /* for (each pair) */
+
+        thisDPD++;
+        thisDPDmap++;
+
+    } while (--totalDPDs);
+
+    return SEC2_SUCCESS;
+}
diff --git a/drivers/crypto/t23x/t23xtest/Makefile b/drivers/crypto/t23x/t23xtest/Makefile
new file mode 100644
index 0000000..5695ac6
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/Makefile
@@ -0,0 +1,8 @@
+#
+# 2.6 makefile for T2 driver base checkout module
+#
+
+
+obj-$(CONFIG_CRYPTO_DEV_EXTENS_T23X_RMTEST) += t23xtest.o
+
+t23xtest-objs := rmtest.o singledesc.o multidesc.o rmtest_mod.o
diff --git a/drivers/crypto/t23x/t23xtest/multidesc.c b/drivers/crypto/t23x/t23xtest/multidesc.c
new file mode 100644
index 0000000..e9c047f
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/multidesc.c
@@ -0,0 +1,297 @@
+/*
+ * multidesc.c
+ *
+ * t23x RM testing module - multi-descriptor requests
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - updated from simplified registration
+ */
+
+
+
+
+/** @file
+ *  Test using multiple descriptors
+ */
+
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+#include "rmtest.h"
+
+/* SHA1 data */
+static const uint8_t sha1plaintext[] =
+"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
+
+static const uint8_t sha1digest[] =
+{
+    0x84, 0x98, 0x3e, 0x44, 0x1c,
+    0x3b, 0xd2, 0x6e, 0xba, 0xae,
+    0x4a, 0xa1, 0xf9, 0x51, 0x29,
+    0xe5, 0xe5, 0x46, 0x70, 0xf1
+};
+
+/** AES ECB Data */
+static const uint8_t AESkey[] = {
+    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+    0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87
+};
+
+static const uint8_t AESdata[] =
+{"Now is the time for all good men"}; /* 32 bytes */
+
+static const uint8_t AEScipher[] = {
+    0xf0, 0xd1, 0xad, 0x6f, 0x90, 0x1f, 0xff, 0xae,
+    0x55, 0x72, 0xa6, 0x92, 0x8d, 0xab, 0x52, 0xb0,
+    0x64, 0xb2, 0x5c, 0x79, 0xf8, 0x76, 0x73, 0x03,
+    0x21, 0xe3, 0x6d, 0xc0, 0x10, 0x11, 0xac, 0xce
+};
+
+/* TDES Data */
+static const uint8_t DESdata[] = {
+    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+    0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+    0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+    0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12
+};
+
+static const uint8_t DESkey[] = {
+    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
+};
+
+static const uint8_t DEScipher[] = {
+    0xf6, 0x53, 0xf7, 0x0a, 0x75, 0xfe, 0x67, 0x8a,
+    0xbf, 0xbf, 0x24, 0x6b, 0x4a, 0xdc, 0xf2, 0xf8,
+    0x16, 0x92, 0x9c, 0x44, 0xf0, 0x26, 0xe1, 0x12,
+    0x81, 0xf0, 0x5f, 0x4a, 0x56, 0x8e, 0xcc, 0x48
+};
+
+
+static void testMultiIntRelease(struct semaphore *lock)
+{
+    up(lock);
+}
+
+
+
+int32_t testMultiDPD_withInterrupt(RMinterfaceCtx *ifCtx)
+{
+    int32_t           testfail;
+    T2DPD            *dpdlist;
+    RMexecMessage     execMsg;
+    uint8_t          *hashplain, *digest;
+    uint8_t          *desplain, *descipher, *deskey;
+    uint8_t          *aesplain, *aescipher, *aeskey;
+    RMstatus          rmstatus;
+    uint32_t          entryID;
+    struct semaphore  irqlock;
+
+    memset(&execMsg, 0, sizeof(execMsg));
+    sema_init(&irqlock, 0);
+
+    dpdlist = getDPD(3);
+    if (dpdlist == NULL)
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): no memory\n");
+        return -1;
+    }
+
+    execMsg.frameworkID           = XWC_FRAMEWORK_CURRENT_VERSION;
+    execMsg.descHead              = dpdlist;
+    execMsg.descCount             = 3;
+    execMsg.messageReleaseHandler = (void (*)(void *))testMultiIntRelease;
+    execMsg.releaseArgument       = (void *)&irqlock;
+
+    /* Set up the hash request */
+    hashplain = getInBuffer((uint8_t *)sha1plaintext, 56);
+    digest    = getOutBuffer(20);
+
+    if ((hashplain == NULL) ||
+        (digest == NULL))
+    {
+        freeBuf(dpdlist);
+        freeBuf(hashplain);
+        freeBuf(digest);
+        dbgmsg("testMultiDPD_withInterrupt(): no memory\n");
+        return -1;
+    }
+
+    (&dpdlist[0])->hdr = ((EU_MD | MD_SHA1 | MD_INIT | MD_PD)
+                          << EU_SHIFT_PRIMARY) |
+                          DESCTYPE_COMMON | HDR_OUTBOUND; /* no DONE */
+    setDPDfield(&dpdlist[0], 3, hashplain, 56, 0, 0);
+    setDPDfield(&dpdlist[0], 5, digest,    20, 0, 0);
+
+
+    /* Set up DES request */
+    desplain  = getInBuffer((uint8_t *)DESdata, 32);
+    deskey    = getInBuffer((uint8_t *)DESkey,  24);
+    descipher = getOutBuffer(32);
+
+    if ((desplain  == NULL) ||
+        (deskey    == NULL) ||
+        (descipher == NULL))
+    {
+        freeBuf(dpdlist);
+        freeBuf(hashplain);
+        freeBuf(digest);
+        freeBuf(desplain);
+        freeBuf(deskey);
+        freeBuf(descipher);
+        dbgmsg("testMultiDPD_withInterrupt(): no memory\n");
+        return -1;
+    }
+
+    /* TDES ECB Encrypt = 0x20700010 */
+    /* Key in [2], input in [3], output in [4] */
+    (&dpdlist[1])->hdr = ((EU_DES | DES_ENCRYPT | DES_ECB | DES_TRIPLE)
+                          << EU_SHIFT_PRIMARY) |
+                          DESCTYPE_COMMON | HDR_OUTBOUND; /* no DONE */
+    setDPDfield(&dpdlist[1], 2, deskey,    24, 0, 0);
+    setDPDfield(&dpdlist[1], 3, desplain,  32, 0, 0);
+    setDPDfield(&dpdlist[1], 4, descipher, 32, 0, 0);
+
+    /* AES ECB Encrypt = 0x60100010 */
+    /* inIV [1], key [2], input [3], output [4], outIV [5] */
+    aesplain  = getInBuffer((uint8_t *)AESdata, 32);
+    aeskey    = getInBuffer((uint8_t *)AESkey,   16);
+    aescipher = getOutBuffer(32);
+
+    if ((aesplain  == NULL) ||
+        (aeskey    == NULL) ||
+        (aescipher == NULL))
+    {
+        freeBuf(dpdlist);
+        freeBuf(hashplain);
+        freeBuf(digest);
+        freeBuf(desplain);
+        freeBuf(deskey);
+        freeBuf(descipher);
+        freeBuf(aesplain);
+        freeBuf(aeskey);
+        freeBuf(aescipher);
+        dbgmsg("testMultiDPD_withInterrupt(): no memory\n");
+        return -1;
+    }
+
+    (&dpdlist[2])->hdr = ((EU_AES | AES_ENCRYPT | AES_ECB) << EU_SHIFT_PRIMARY) |
+                          DESCTYPE_COMMON | HDR_OUTBOUND | HDR_DONE;
+    setDPDfield(&dpdlist[2], 2, aeskey,    16, 0, 0);
+    setDPDfield(&dpdlist[2], 3, aesplain,  32, 0, 0);
+    setDPDfield(&dpdlist[2], 4, aescipher, 32, 0, 0);
+
+
+    /*
+     * Step #2 - Pass the DPD to the RM for handling
+     */
+
+    rmstatus = xwcRMqueueRequest(ifCtx, &execMsg, &entryID);
+    if (rmstatus != RM_OK)
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): error queueing request, error %d\n", rmstatus);
+        freeBuf(dpdlist);
+        freeBuf(hashplain);
+        freeBuf(digest);
+        freeBuf(desplain);
+        freeBuf(deskey);
+        freeBuf(descipher);
+        freeBuf(aesplain);
+        freeBuf(aeskey);
+        freeBuf(aescipher);
+        return -1;
+    }
+
+    if (down_interruptible(&irqlock))
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): interrupted\n");
+        freeBuf(dpdlist);
+        freeBuf(hashplain);
+        freeBuf(digest);
+        freeBuf(desplain);
+        freeBuf(deskey);
+        freeBuf(descipher);
+        freeBuf(aesplain);
+        freeBuf(aeskey);
+        freeBuf(aescipher);
+        return -1;
+    }
+
+
+
+    /*
+     * Step #3 - Verify the result
+     */
+    testfail = 0;
+
+    if (memcmp(digest, sha1digest, 20))
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): hash digest is INCORRECT\n");
+        bufferDump(digest, 20);
+        testfail++;
+    }
+
+    if (memcmp(descipher, DEScipher, 32))
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): DES ciphertext is INCORRECT\n");
+        bufferDump(descipher, 32);
+        testfail++;
+    }
+
+    if (memcmp(aescipher, AEScipher, 32))
+    {
+        dbgmsg("testMultiDPD_withInterrupt(): AES ciphertext is INCORRECT\n");
+        bufferDump(aescipher, 32);
+        testfail++;
+    }
+
+    if (testfail == 0)
+        dbgmsg("testMultiDPD_withInterrupt(): OK\n");
+
+    freeBuf(dpdlist);
+    freeBuf(hashplain);
+    freeBuf(digest);
+    freeBuf(desplain);
+    freeBuf(deskey);
+    freeBuf(descipher);
+    freeBuf(aesplain);
+    freeBuf(aeskey);
+    freeBuf(aescipher);
+
+    return 0;
+}
diff --git a/drivers/crypto/t23x/t23xtest/rmtest.c b/drivers/crypto/t23x/t23xtest/rmtest.c
new file mode 100644
index 0000000..058ecf9
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/rmtest.c
@@ -0,0 +1,252 @@
+/*
+ * rmtest.c
+ *
+ * t23x RM test - base functionality
+ *
+ * This module runs a short series of crypto operations against
+ * most "any" hardware in the SEC 2.x/3.x family. It serves
+ * as a quick checkout of the RM, and acts as a very primitive
+ * registered interface, useful as a limited example.
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+
+
+/** @file
+ * Test module meant to exercise a resource manager's functionality
+ */
+
+
+
+#include <linux/slab.h>
+
+#include "../common/xwcRMinterface.h"
+#include "../common/t23.h"
+#include "../t23xrm/t23xrmInternal.h"
+#include "rmtest.h"
+
+
+
+
+int (*dbgmsg)(const char *fmt, ...);
+RMinterfaceCtx *ifctx;
+
+
+int32_t execTestSeries(void)
+{
+    RMstatus        rmstatus;
+    int32_t         teststatus;
+
+
+    dbgmsg = printk;
+
+    dbgmsg("Extensible Crypto Driver - t23x RM testing module - pkg rev %s\n", T23X_PACKAGE_VERSION);
+
+
+    /*
+     * Step #1 - Register thyself as an interface
+     */
+
+    rmstatus = xwcRMregisterInterface("t23xtest", &ifctx);
+    if (rmstatus != RM_OK)
+    {
+        dbgmsg("t23xtest: can't register interface, error %d\n", rmstatus);
+        return -1;
+    }
+
+    /*
+     * Step #2 - walk through individual tests
+     */
+    teststatus = 0;
+
+    if (testOneDPD_withInterruptSHA(ifctx))
+        teststatus++;
+
+    if (testOneDPD_withInterruptRND(ifctx))
+        teststatus++;
+
+    if (testMultiDPD_withInterrupt(ifctx))
+        teststatus++;
+
+
+    /*
+     * Step #3 - Deregister and exit
+     */
+    rmstatus = xwcRMderegisterInterface(ifctx);
+    if (rmstatus != RM_OK)
+    {
+        dbgmsg("t23xtest: can't deregister interface, error %d\n", rmstatus);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/* Helper functions for all tests to use */
+
+/* Allocate 1-n DPDs */
+T2DPD *getDPD(int32_t count)
+{
+    T2DPD *desc;
+
+    desc = (T2DPD *)kmalloc((sizeof(T2DPD) * count), GFP_DMA | GFP_KERNEL);
+    if (desc == NULL)
+        return (T2DPD *)NULL;
+
+    memset(desc, 0, sizeof(T2DPD) * count);
+
+    return desc;
+}
+
+/* Free a buffer */
+void freeBuf(void *stuff)
+{
+    kfree(stuff);
+}
+
+/* Get an input buffer, copy data to it */
+uint8_t *getInBuffer(uint8_t *content, int32_t size)
+{
+    uint8_t *buf;
+
+    buf = (uint8_t *)kmalloc(size, GFP_DMA | GFP_KERNEL);
+    if (buf == NULL)
+        return (uint8_t *)NULL;
+
+    memcpy(buf, content, size);
+
+    return (uint8_t *)buf;
+}
+
+/* Get an output buffer */
+uint8_t *getOutBuffer(int32_t size)
+{
+    uint8_t *buf;
+
+    buf = (uint8_t *)kmalloc(size, GFP_DMA | GFP_KERNEL);
+    memset(buf, 0, size);
+
+    return (uint8_t *)buf;
+}
+
+
+linkEntry *getSGlist(int32_t entries)
+{
+    linkEntry *list;
+
+    list = (linkEntry *)kmalloc(sizeof(linkEntry) * entries,
+            GFP_DMA | GFP_KERNEL);
+    memset(list, 0, sizeof(linkEntry) * entries);
+    return list;
+}
+
+
+
+/* Write a DPD "pointer field" with content */
+void setDPDfield(   T2DPD           *desc,
+                    int32_t          field,
+                    uint8_t         *ptr,
+                    uint16_t         size,
+                    uint8_t          extent,
+                    uint8_t          jump)
+{
+    desc->pair[field].size   = size;
+    desc->pair[field].extent = extent & EXTENT_MASK;
+    desc->pair[field].ptr    = (void *)__pa(ptr);
+    desc->pair[field].eptr   = 0; /* not used here */
+    if (jump)
+        desc->pair[field].extent |= JUMPTABLE;
+}
+
+
+/* Get a physical address from a buffer */
+void *physAddr(void *vaddr)
+{
+    return (void *)__pa(vaddr);
+}
+
+
+#define DUMP_LINE_SIZE (8)
+
+void bufferDump(uint8_t *buf, int32_t size)
+{
+    uint8_t *next;
+    int32_t  remain, linesz, i;
+    uint8_t  ascout[DUMP_LINE_SIZE + 1];
+
+    next = buf;
+
+    remain = size;
+
+    while(remain)
+    {
+        memset(ascout, 0, DUMP_LINE_SIZE + 1); /* +1 for eol terminator */
+
+        dbgmsg("0x%08x: ", (uint32_t)next);
+
+        if (remain <= DUMP_LINE_SIZE)
+            linesz = remain;
+        else
+            linesz = DUMP_LINE_SIZE;
+
+        for (i = 0; i < linesz; i++)
+        {
+            dbgmsg("%02x ", *next);
+
+            if ((*next >= 32) && (*next <= 126))
+                ascout[i] = *next;
+            else
+                ascout[i] = '.';
+
+            next++;
+        }
+
+        if (linesz < DUMP_LINE_SIZE)
+            for (i = DUMP_LINE_SIZE - linesz; i; i--)
+                dbgmsg("   ");
+
+        dbgmsg("%s\n", ascout);
+
+        remain -= linesz;
+
+    }
+
+
+
+
+}
diff --git a/drivers/crypto/t23x/t23xtest/rmtest.h b/drivers/crypto/t23x/t23xtest/rmtest.h
new file mode 100644
index 0000000..6dff15d
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/rmtest.h
@@ -0,0 +1,87 @@
+/*
+ * rmtest.h
+ *
+ * t23x RM testing module - common definitions
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+
+
+#ifndef RMTEST_H
+#define RMTEST_H
+
+
+/** @file
+ * Helper functions for all tests to use
+ */
+
+
+#ifdef _cplusplus
+extern "C" {
+#endif
+
+
+    extern int (*dbgmsg)(const char *fmt, ...);
+    extern RMinterfaceCtx *ifctx;
+
+
+    /* Helper functions for all tests to use */
+    T2DPD *getDPD(int32_t);
+    void freeBuf(void *);
+    uint8_t *getInBuffer(uint8_t *content, int32_t size);
+    uint8_t *getOutBuffer(int32_t size);
+    linkEntry *getSGlist(int32_t entries);
+    void setDPDfield(   T2DPD   *desc,
+                        int32_t  field,
+                        uint8_t *ptr,
+                        uint16_t size,
+                        uint8_t  extent,
+                        uint8_t  jump);
+    void bufferDump(uint8_t *buf, int32_t size);
+    void *physAddr(void *vaddr);
+
+    /* Individual test prototypes */
+
+    int32_t testOneDPD_withInterruptSHA(RMinterfaceCtx *);
+    int32_t testOneDPD_withInterruptRND(RMinterfaceCtx *);
+    int32_t testMultiDPD_withInterrupt(RMinterfaceCtx *);
+
+#ifdef _cplusplus
+}
+#endif
+
+#endif /* RMTEST_H */
diff --git a/drivers/crypto/t23x/t23xtest/rmtest_mod.c b/drivers/crypto/t23x/t23xtest/rmtest_mod.c
new file mode 100644
index 0000000..d6d21ef
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/rmtest_mod.c
@@ -0,0 +1,70 @@
+
+
+/*
+ * rmtest_mod.c
+ *
+ * Linux specific driver module initialization for t23xrm test module
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+
+#include <linux/module.h>
+
+
+extern int32_t execTestSeries(void);
+
+
+static int32_t __init rmtest_init(void)
+{
+    return execTestSeries();
+}
+
+static void rmtest_exit(void)
+{
+}
+
+
+module_init(rmtest_init);
+module_exit(rmtest_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Extensible Crypto Driver - t23x RM quick-test module");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/t23x/t23xtest/singledesc.c b/drivers/crypto/t23x/t23xtest/singledesc.c
new file mode 100644
index 0000000..6e87acb
--- /dev/null
+++ b/drivers/crypto/t23x/t23xtest/singledesc.c
@@ -0,0 +1,262 @@
+/*
+ * singledesc.c
+ *
+ * t23x RM testing module - single descriptor cases
+ *
+ * Copyright (c) 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or
+ * without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * - Neither the name of Freescale Semiconductor nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * 2.1.0   2009_05_04 sec - updated from simplified registration
+ */
+
+
+
+
+/** @file
+ *  Test using single descriptor
+ */
+
+
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+
+#include "../common/t23.h"
+#include "../common/xwcRMinterface.h"
+#include "rmtest.h"
+
+/* This is the data set we can use for a simple SHA1 request */
+static const uint8_t sha1padplaintext1[] = "abc";
+static const uint8_t sha1paddigest1[] =
+{
+    0xa9, 0x99, 0x3e, 0x36, 0x47,
+    0x06, 0x81, 0x6a, 0xba, 0x3e,
+    0x25, 0x71, 0x78, 0x50, 0xc2,
+    0x6c, 0x9c, 0xd0, 0xd8, 0x9d
+};
+
+
+
+static void intRelease(struct semaphore *lock)
+{
+    up(lock);
+}
+
+
+
+int32_t testOneDPD_withInterruptSHA(RMinterfaceCtx *ifCtx)
+{
+    T2DPD           *thisdpd;
+    RMexecMessage    execMsg;
+    uint8_t         *plaintext, *digest;
+    RMstatus         rmstatus;
+    uint32_t         entryID;
+    struct semaphore intlock;
+
+    memset(&execMsg, 0, sizeof(execMsg));
+    sema_init(&intlock, 0);
+
+    thisdpd   = getDPD(1);
+    plaintext = getInBuffer((uint8_t *)sha1padplaintext1, 3);
+    digest    = getOutBuffer(20);
+
+    execMsg.frameworkID           = XWC_FRAMEWORK_CURRENT_VERSION;
+    execMsg.descHead              = thisdpd;
+    execMsg.descCount             = 1;
+    execMsg.messageReleaseHandler = (void (*)(void *))intRelease;
+    execMsg.releaseArgument       = (void *)&intlock;
+
+    if ((thisdpd == NULL) ||
+        (plaintext == NULL) ||
+        (digest == NULL))
+    {
+        freeBuf(thisdpd);
+        freeBuf(plaintext);
+        freeBuf(digest);
+        dbgmsg("testOneDPD_withInterruptSHA(): no memory\n");
+        return -1;
+    }
+
+    thisdpd->hdr = ((EU_MD | MD_SHA1 | MD_INIT | MD_PD) << EU_SHIFT_PRIMARY) |
+                    DESCTYPE_COMMON | HDR_OUTBOUND | HDR_DONE;
+    setDPDfield(thisdpd, 3, plaintext, 3, 0, 0);
+    setDPDfield(thisdpd, 5, digest,   20, 0, 0);
+
+
+    /*
+     * Step #2 - Pass the DPD to the RM for handling
+     */
+
+    rmstatus = xwcRMqueueRequest(ifCtx, &execMsg, &entryID);
+
+    if (rmstatus != RM_OK)
+    {
+        dbgmsg("testOneDPD_withInterruptSHA(): error queueing request, error %d\n", rmstatus);
+        freeBuf(thisdpd);
+        freeBuf(plaintext);
+        freeBuf(digest);
+        return -1;
+    }
+
+    if (down_interruptible(&intlock))
+    {
+        dbgmsg("testOneDPD_withInterruptSHA(): interrupted\n");
+        freeBuf(thisdpd);
+        freeBuf(plaintext);
+        freeBuf(digest);
+        return -1;
+    }
+
+
+    /*
+     * Step #3 - Verify the result
+     */
+
+    if (!memcmp(digest, sha1paddigest1, 20))
+        dbgmsg("testOneDPD_withInterruptSHA(): OK\n");
+    else
+    {
+        dbgmsg("testOneDPD_withInterruptSHA(): processed digest is INCORRECT\n");
+        bufferDump(digest, 20);
+    }
+
+
+    freeBuf(thisdpd);
+    freeBuf(plaintext);
+    freeBuf(digest);
+    return 0;
+}
+
+
+#define BITSINABYTE (8)
+
+int32_t rndbitwt(uint8_t *buf, int32_t size)
+{
+    uint32_t  totalbits, actualbits;
+    uint32_t  i, j;
+
+    totalbits = size * BITSINABYTE;
+    actualbits = 0;
+
+    for (i = 0; i < size; i++)
+        for (j = 0; j < BITSINABYTE; j++)
+            if ((buf[i] >> j) & 0x01)
+                actualbits++;
+    return((actualbits * 100) / totalbits);
+}
+
+#define RNDSIZE 2048
+
+int32_t testOneDPD_withInterruptRND(RMinterfaceCtx *ifCtx)
+{
+    T2DPD           *thisdpd;
+    RMexecMessage    execMsg;
+    uint8_t         *databuf;
+    RMstatus         rmstatus;
+    uint32_t         entryID;
+    int32_t          bitwt;
+    linkEntry       *sglist;
+    struct semaphore intlock;
+
+    memset(&execMsg, 0, sizeof(execMsg));
+    sema_init(&intlock, 0);
+
+    thisdpd   = getDPD(1);
+    sglist    = getSGlist(1);
+    databuf = (uint8_t *)kmalloc(RNDSIZE, GFP_DMA | GFP_KERNEL);
+
+    execMsg.frameworkID           = XWC_FRAMEWORK_CURRENT_VERSION;
+    execMsg.descHead              = thisdpd;
+    execMsg.descCount             = 1;
+    execMsg.messageReleaseHandler = (void (*)(void *))intRelease;
+    execMsg.releaseArgument       = (void *)&intlock;
+
+    if ((thisdpd == NULL) ||
+        (databuf == NULL) ||
+        (sglist == NULL))
+    {
+        freeBuf(thisdpd);
+        freeBuf(sglist);
+        kfree(databuf);
+        dbgmsg("testOneDPD_withInterruptRND(): no memory\n");
+        return -1;
+    }
+
+    thisdpd->hdr      = (EU_RND << EU_SHIFT_PRIMARY) | DESCTYPE_COMMON | HDR_DONE;
+    sglist->segLen    = RNDSIZE;
+    sglist->chainCtrl = LAST_ENTRY;
+    sglist->segAddr   = (uint8_t *)__pa(databuf);
+
+    setDPDfield(thisdpd, 4, (uint8_t *)sglist, RNDSIZE, 0, 1);
+
+
+    rmstatus = xwcRMqueueRequest(ifCtx, &execMsg, &entryID);
+
+    if (rmstatus != RM_OK)
+    {
+        if (rmstatus == RM_NO_CAPABILITY)
+            dbgmsg("testOneDPD_withInterruptRND(): random generator not present\n");
+        else
+            dbgmsg("testOneDPD_withInterruptRND(): error queueing request, error %d\n", rmstatus);
+
+        freeBuf(thisdpd);
+        freeBuf(sglist);
+        kfree(databuf);
+        return -1;
+    }
+
+    if (down_interruptible(&intlock))
+    {
+        dbgmsg("testOneDPD_withInterruptRND(): interrupted\n");
+        freeBuf(thisdpd);
+        kfree(databuf);
+        freeBuf(sglist);
+        return -1;
+    }
+
+    bitwt = rndbitwt(databuf, RNDSIZE);
+
+    if ((bitwt < 46) || (bitwt > 54))
+    {
+        dbgmsg("testOneDPD_withInterruptRND(): failed - bit weight = %d%\n", bitwt);
+        bufferDump(databuf, 64);
+    }
+    else
+        dbgmsg("testOneDPD_withInterruptRND(): OK\n");
+
+
+    freeBuf(thisdpd);
+    kfree(databuf);
+    freeBuf(sglist);
+    return 0;
+}
-- 
1.7.0.4

