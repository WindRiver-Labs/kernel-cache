From 40d075e95311f1cd78cae3c74fc18d38401fbb10 Mon Sep 17 00:00:00 2001
From: chunguang yang <chunguang.yang@windriver.com>
Date: Thu, 9 Apr 2015 14:11:30 +0800
Subject: [PATCH] r8168: Add dma_mapping_error check

commit d827d86b6fe [r8169: print errors when dma mapping fail] fixes a
similar issue when dma mappings fail. r8168_n.c is ported from
http://www.realtek.com.tw/. It's not in the upstream kernel. so We
cannot use commit d827d86b6fe directly and use r8169.c as a reference.

here is the calltrace:
[ 6.434358] r8168 0000:03:00.0: DMA-API: device driver failed to check
map error[device address=0x0000000076728048] [size=1523 bytes] [mapped
as single]
[ 6.434799] Modules linked in:

[ 6.434910] CPU: 1 PID: 1 Comm: swapper/0 Not tainted
3.14.29ltsi-WR7.0.0.0_standard #1
[ 6.435159] Hardware name: To be filled by O.E.M. To be filled by
O.E.M./Aptio CRB, BIOS 5.6.5 02/25/2014
[ 6.435460] 0000000000000009 ffff88006753ba18 ffffffff81a9b2a6
ffff88006753ba60
[ 6.435754] ffff88006753ba50 ffffffff8104bd2d ffff8800795b9300
ffff88006779ed30
[ 6.436044] ffffffff8245d2d0 0000000000000086 ffffffff81ec9944
ffff88006753bab0
[ 6.436334] Call Trace:
[ 6.436405] [<ffffffff81a9b2a6>] dump_stack+0x4e/0x7a
[ 6.448396] [<ffffffff8104bd2d>] warn_slowpath_common+0x7d/0xa0
[ 6.460278] [<ffffffff8104bd9c>] warn_slowpath_fmt+0x4c/0x50
[ 6.471983] [<ffffffff814292be>] check_unmap+0x50e/0xa00
[ 6.483543] [<ffffffff8107eeb0>] ? wake_up_process+0x50/0x50
[ 6.495077] [<ffffffff81429811>] debug_dma_unmap_page+0x61/0x70
[ 6.506714] [<ffffffff817fcc44>] rtl8168_rx_clear+0x74/0x100
[ 6.518337] [<ffffffff8184de94>] rtl8168_down+0xb4/0x110
[ 6.529934] [<ffffffff8184df31>] rtl8168_close+0x41/0x320
[ 6.541526] [<ffffffff818bf775>] __dev_close_many+0x85/0xd0
[ 6.553153] [<ffffffff818bf92d>] __dev_close+0x4d/0x90
[ 6.564724] [<ffffffff818c72bd>] __dev_change_flags+0x9d/0x180
[ 6.576297] [<ffffffff818c73c9>] dev_change_flags+0x29/0x70
Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/staging/r8168/r8168_n.c |   69 ++++++++++++++++++++++++++++++++-------
 1 files changed, 57 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/r8168/r8168_n.c b/drivers/staging/r8168/r8168_n.c
index ba62d72..ec22a9c 100755
--- a/drivers/staging/r8168/r8168_n.c
+++ b/drivers/staging/r8168/r8168_n.c
@@ -21344,13 +21344,15 @@ rtl8168_map_to_asic(struct RxDesc *desc,
 }
 
 static int
-rtl8168_alloc_rx_skb(struct pci_dev *pdev,
+rtl8168_alloc_rx_skb(struct rtl8168_private *tp,
                      struct sk_buff **sk_buff,
                      struct RxDesc *desc,
                      int rx_buf_sz)
 {
         struct sk_buff *skb;
         dma_addr_t mapping;
+	struct pci_dev *pdev = tp->pci_dev;
+	struct device *d = &pdev->dev;
         int ret = 0;
 
         skb = dev_alloc_skb(rx_buf_sz + RTK_RX_ALIGN);
@@ -21362,12 +21364,21 @@ rtl8168_alloc_rx_skb(struct pci_dev *pdev,
 
         mapping = pci_map_single(pdev, skb->data, rx_buf_sz,
                                  PCI_DMA_FROMDEVICE);
+	if (unlikely(dma_mapping_error(d, mapping))) {
+		if (net_ratelimit())
+			netif_err(tp, drv, tp->dev, "Failed to map RX DMA!\n");
+		goto err_out_dma_mapping;
+	}
+
 
         rtl8168_map_to_asic(desc, mapping, rx_buf_sz);
 
 out:
         return ret;
 
+err_out_dma_mapping:
+	dev_kfree_skb(skb);
+	*sk_buff = NULL;
 err_out:
         ret = -ENOMEM;
         rtl8168_make_unusable_by_asic(desc);
@@ -21400,7 +21411,7 @@ rtl8168_rx_fill(struct rtl8168_private *tp,
                 if (tp->Rx_skbuff[i])
                         continue;
 
-                ret = rtl8168_alloc_rx_skb(tp->pci_dev, tp->Rx_skbuff + i,
+                ret = rtl8168_alloc_rx_skb(tp, tp->Rx_skbuff + i,
                                            tp->RxDescArray + i, tp->rx_buf_sz);
                 if (ret < 0)
                         break;
@@ -21503,16 +21514,15 @@ rtl8168_unmap_tx_skb(struct pci_dev *pdev,
         tx_skb->len = 0;
 }
 
-static void
-rtl8168_tx_clear(struct rtl8168_private *tp)
+
+static void rtl8168_tx_clear_range(struct rtl8168_private *tp, u32 start,
+                                   unsigned int n)
 {
         unsigned int i;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-        struct net_device *dev = tp->dev;
-#endif
 
-        for (i = tp->dirty_tx; i < tp->dirty_tx + NUM_TX_DESC; i++) {
-                unsigned int entry = i % NUM_TX_DESC;
+	for (i = 0; i < n; i++) {
+		unsigned int entry = (start + i) % NUM_TX_DESC;
+
                 struct ring_info *tx_skb = tp->tx_skb + entry;
                 unsigned int len = tx_skb->len;
 
@@ -21522,12 +21532,18 @@ rtl8168_tx_clear(struct rtl8168_private *tp)
                         rtl8168_unmap_tx_skb(tp->pci_dev, tx_skb,
                                              tp->TxDescArray + entry);
                         if (skb) {
-                                dev_kfree_skb(skb);
+				tp->dev->stats.tx_dropped++;
+				dev_kfree_skb_any(skb);
                                 tx_skb->skb = NULL;
                         }
-                        RTLDEV->stats.tx_dropped++;
                 }
         }
+}
+
+static void
+rtl8168_tx_clear(struct rtl8168_private *tp)
+{
+	rtl8168_tx_clear_range(tp, tp->dirty_tx, NUM_TX_DESC);
         tp->cur_tx = tp->dirty_tx = 0;
 }
 
@@ -21681,6 +21697,8 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
         struct skb_shared_info *info = skb_shinfo(skb);
         unsigned int cur_frag, entry;
         struct TxDesc *txd = NULL;
+	struct device *d = &tp->pci_dev->dev;
+
 
         entry = tp->cur_tx;
         for (cur_frag = 0; cur_frag < info->nr_frags; cur_frag++) {
@@ -21700,6 +21718,12 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
                 addr = skb_frag_address(frag);
 #endif
                 mapping = pci_map_single(tp->pci_dev, addr, len, PCI_DMA_TODEVICE);
+		if (unlikely(dma_mapping_error(d, mapping))) {
+			if (net_ratelimit())
+				netif_err(tp, drv, tp->dev,
+					  "Failed to map TX fragments DMA!\n");
+			goto err_out;
+		}
 
                 /* anti gcc 2.95.3 bugware (sic) */
                 status = opts1 | len | (RingEnd * !((entry + 1) % NUM_TX_DESC));
@@ -21719,6 +21743,10 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
         }
 
         return cur_frag;
+
+err_out:
+	rtl8168_tx_clear_range(tp, tp->cur_tx + 1, cur_frag);
+	return -EIO;
 }
 
 static inline u32
@@ -21806,6 +21834,7 @@ rtl8168_start_xmit(struct sk_buff *skb,
         unsigned int frags, entry;
         struct TxDesc *txd;
         void __iomem *ioaddr = tp->mmio_addr;
+	struct device *d = &tp->pci_dev->dev;
         dma_addr_t mapping;
         u32 len;
         u32 opts1;
@@ -21871,7 +21900,9 @@ rtl8168_start_xmit(struct sk_buff *skb,
         }
 
         frags = rtl8168_xmit_frags(tp, skb, opts1, opts2);
-        if (frags) {
+	if (frags < 0)
+		goto err_dma_1;
+        else if (frags) {
                 len = skb_headlen(skb);
                 opts1 |= FirstFrag;
         } else {
@@ -21890,6 +21921,12 @@ rtl8168_start_xmit(struct sk_buff *skb,
 
         opts1 |= len | (RingEnd * !((entry + 1) % NUM_TX_DESC));
         mapping = pci_map_single(tp->pci_dev, skb->data, len, PCI_DMA_TODEVICE);
+	if (unlikely(dma_mapping_error(d, mapping))) {
+		if (net_ratelimit())
+			netif_err(tp, drv, dev, "Failed to map TX DMA!\n");
+		goto err_dma_0;
+	}
+
         tp->tx_skb[entry].len = len;
         txd->addr = cpu_to_le64(mapping);
         txd->opts2 = cpu_to_le32(opts2);
@@ -21916,6 +21953,14 @@ rtl8168_start_xmit(struct sk_buff *skb,
 
 out:
         return ret;
+
+err_dma_1:
+	rtl8168_unmap_tx_skb(tp->pci_dev, tp->tx_skb + entry, txd);
+err_dma_0:
+	dev_kfree_skb_any(skb);
+	dev->stats.tx_dropped++;
+	return NETDEV_TX_OK;
+
 err_stop:
         netif_stop_queue(dev);
         ret = NETDEV_TX_BUSY;
-- 
1.7.5.4

