From 5e3e8da2a8abda18c3736608204a2b319c1c2446 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 14:37:21 +0800
Subject: [PATCH] nlm_xlp_64_be: add usb support

[ Based on netlogic SDK 20110329 ]

Add support for the following USB of XLP:

4 type-A USB host connectors; High-speed(480Mbps), Full speed(12Mbps)
and Low speed(1.5Mbps); USB 2.0, OHCI 1.0a, EHCI 1.0 complicant.

Because there are frequently dirty message "nobady cared irq", and can
not find full/low speed USB stick to do validation, remove OHCI from
README's feature supported list, here only keep it's codes for
reference.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Nebu Philips <nphilips@netlogicmicro.com>
[ Register interrupt handler before enabling the interrupts to fix
potential kernel Oops ]
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 drivers/usb/host/Kconfig      |    8 ++-
 drivers/usb/host/Makefile     |    3 +
 drivers/usb/host/ehci-pci.c   |  108 ++++++++++++++++++++++++++++++++++++++++-
 drivers/usb/host/ohci-hcd.c   |   17 ++++++
 drivers/usb/host/ohci-pci.c   |   96 +++++++++++++++++++++++++++++++++++-
 drivers/usb/host/pci-quirks.c |    2 +
 include/linux/pci_ids.h       |    2 +
 7 files changed, 230 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 8d3df03..0679ce6 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -90,12 +90,12 @@ config USB_EHCI_TT_NEWSCHED
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || NLM_XLP)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX)
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || NLM_XLP)
 	default y
 
 config XPS_USB_HCD_XILINX
@@ -264,17 +264,19 @@ config USB_OHCI_HCD_SSB
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
 	depends on USB_OHCI_HCD
+	default y if NLM_XLP
 	default n
 
 config USB_OHCI_BIG_ENDIAN_MMIO
 	bool
 	depends on USB_OHCI_HCD
+	default y if NLM_XLP
 	default n
 
 config USB_OHCI_LITTLE_ENDIAN
 	bool
 	depends on USB_OHCI_HCD
-	default n if STB03xxx || PPC_MPC52xx
+	default n if STB03xxx || PPC_MPC52xx || NLM_XLP
 	default y
 
 config USB_UHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b6315aa..db64276 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -1,6 +1,9 @@
 #
 # Makefile for USB Host Controller Drivers
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+	EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 ifeq ($(CONFIG_USB_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index de0dbd5..2e37d24 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -2,6 +2,7 @@
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *
  * Copyright (c) 2000-2004 by David Brownell
+ * Copyright (c) 2003-2010 Netlogic Microsystems Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -22,6 +23,82 @@
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
 
+#ifdef CONFIG_NLM_XLP
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+volatile uint64_t *ehci_regs;
+
+static void xlp_usb_hw_start(int ctrl_no)
+{
+	int val;
+
+	/* enable USB EHCI interrupts(Don't enable ohci interrupt this
+	 * time, otherwise, ohci will fail for no interrupt handler installed
+	 * before enabling the interrupts.
+	 */
+	/* val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT1_EN; */
+	val = USB_CTRL_INTERRUPT_EN;
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+static void xlp_usb_hw_stop(int ctrl_no)
+{
+	int val;
+
+	/* enable USB EHCI interrupts(Don't enable ohci interrupt this
+	 * time, otherwise, ohci will fail for no interrupt handler installed
+	 * before enabling the interrupts.
+	 */
+	/* val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT1_EN; */
+	val = ~USB_CTRL_INTERRUPT_EN;
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+int xlp_ehci_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int irq, irt, ctrl_no, ret;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
+	irq = nlm_hal_request_shared_irq(irt);
+
+	if (!irq) {
+		pr_err("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n",
+				pci_name(dev));
+		return -ENODEV;
+	}
+
+	dev->irq = irq;
+	ret = usb_hcd_pci_probe(dev, id);
+	if (ret)
+		pr_err("%s: Fail to probe xlp ehci\n", __func__);
+	else
+		xlp_usb_hw_start(ctrl_no);
+
+	return ret;
+}
+
+void xlp_ehci_hcd_pci_remove(struct pci_dev *dev)
+{
+	int ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	xlp_usb_hw_stop(ctrl_no);
+	usb_hcd_pci_remove(dev);
+}
+
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -99,6 +176,16 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 		}
 		break;
+
+	case PCI_VENDOR_ID_NETLOGIC:
+		if (pdev->device == 0x1007) {
+#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+			ehci->big_endian_mmio = 1;
+#else
+			ehci->big_endian_mmio = 0;
+#endif
+		}
+		break;
 	}
 
 	ehci->caps = hcd->regs;
@@ -449,6 +536,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 
 /*-------------------------------------------------------------------------*/
 
+#ifndef CONFIG_NLM_XLP
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
@@ -457,15 +545,33 @@ static const struct pci_device_id pci_ids [] = { {
 	},
 	{ /* end: all zeroes */ }
 };
+#else
+/* PCI driver selection metadata; PCI hotplugging uses this */
+static const struct pci_device_id pci_ids[] = { {
+		.vendor		= PCI_VENDOR_ID_NETLOGIC,
+		.device		= XLP_DEVID_EHCI,
+		.subvendor	= 0,
+		.subdevice	= 0,
+		.class		= PCI_CLASS_SERIAL_USB_EHCI,
+		.class_mask	= ~0,
+		.driver_data	= (unsigned long) &ehci_pci_hc_driver,
+	},
+	{ /* end: all zeroes */ }
+};
+#endif
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
+#ifndef CONFIG_NLM_XLP
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+#else
+	.probe =	xlp_ehci_hcd_pci_probe,
+	.remove =	xlp_ehci_hcd_pci_remove,
+#endif
 	.shutdown = 	usb_hcd_pci_shutdown,
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index d6b6a1f..c8b5064 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -3,6 +3,7 @@
  *
  * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
  * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2003-2010 Netlogic Microsystems Inc.
  *
  * [ Initialisation is based on Linus'  ]
  * [ uhci code and gregs ohci fragments ]
@@ -891,6 +892,22 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		(void) ohci_readl (ohci, &ohci->regs->control);
 	}
 
+	if (ints & OHCI_INTR_FNO) {
+		ohci_err (ohci, "OHCI frame number overflow\n");
+		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrstatus);
+		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrdisable);
+		/* flush those writes */
+		(void) ohci_readl (ohci, &ohci->regs->control);
+	}
+
+	if (ints & OHCI_INTR_SO) {
+		ohci_err (ohci, "OHCI scheduling overrun`\n");
+		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrstatus);
+		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrdisable);
+		/* flush those writes */
+		(void) ohci_readl (ohci, &ohci->regs->control);
+	}
+
 	return IRQ_HANDLED;
 }
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 67f83e5..784ffac 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -3,6 +3,7 @@
  *
  * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
  * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2003-2010 Netlogic Microsystems Inc.
  *
  * [ Initialisation is based on Linus'  ]
  * [ uhci code and gregs ohci fragments ]
@@ -40,6 +41,80 @@ static struct pci_dev *amd_smbus_dev;
 static struct pci_dev *amd_hb_dev;
 static int amd_ohci_iso_count;
 
+#ifdef CONFIG_NLM_XLP
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+static void xlp_usb_start_ohc(int ctrl_no)
+{
+	/* enable interrupts
+	 */
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN,
+			USB_CTRL_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT12_EN
+			| USB_OHCI_INTERRUPT1_EN);
+	return;
+}
+
+static void xlp_usb_stop_ohc(int ctrl_no)
+{
+	int val;
+
+	val = usb_reg_read(0, ctrl_no, XLP_USB_INT_EN);
+	val &= ~(USB_CTRL_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT12_EN
+			| USB_OHCI_INTERRUPT1_EN);
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+int xlp_ohci_hcd_pci_probe(struct pci_dev *dev,
+		const struct pci_device_id *id)
+{
+	int irq, irt, ctrl_no, ret;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
+	irq = nlm_hal_request_shared_irq(irt);
+
+	if (!irq) {
+		pr_err("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n",
+				pci_name(dev));
+		return -ENODEV;
+	}
+
+	dev->irq = irq;
+	pr_info("%s: ohci irq = %d\n", __func__, dev->irq);
+	/* Stop it before probing */
+	xlp_usb_stop_ohc(ctrl_no);
+	ret = usb_hcd_pci_probe(dev, id);
+	if (ret)
+		pr_err("%s: Fail to probe xlp ohci\n", __func__);
+	else
+		xlp_usb_start_ohc(ctrl_no);
+
+	return ret;
+}
+
+void xlp_ohci_hcd_pci_remove(struct pci_dev *dev)
+{
+	int ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	xlp_usb_stop_ohc(ctrl_no);
+	usb_hcd_pci_remove(dev);
+}
+
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -515,22 +590,39 @@ static const struct hc_driver ohci_pci_hc_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-
+#ifndef CONFIG_NLM_XLP
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, { /* end: all zeroes */ }
 };
+#else
+static const struct pci_device_id pci_ids[] = { {
+		.vendor		= PCI_VENDOR_ID_NETLOGIC,
+		.device		= XLP_DEVID_OHCI,
+		.subvendor	= 0,
+		.subdevice	= 0,
+		.class		= PCI_CLASS_SERIAL_USB_OHCI,
+		.class_mask	= ~0,
+		.driver_data	= (unsigned long) &ohci_pci_hc_driver,
+	},
+	{ /* end: all zeroes */ }
+};
+#endif
 MODULE_DEVICE_TABLE (pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
+#ifndef CONFIG_NLM_XLP
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+#else
+	.probe =	xlp_ohci_hcd_pci_probe,
+	.remove =	xlp_ohci_hcd_pci_remove,
+#endif
 	.shutdown =	usb_hcd_pci_shutdown,
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 5840ab8..f2cd97d 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -489,4 +489,6 @@ static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 	else if (pdev->class == PCI_CLASS_SERIAL_USB_XHCI)
 		quirk_usb_handoff_xhci(pdev);
 }
+#ifndef CONFIG_CPU_XLP		/* Commented out. Hangs in netl code */
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
+#endif
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 9b865c2..3ad4f0b 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -580,6 +580,8 @@
 #define PCI_DEVICE_ID_TRIDENT_8420	0x8420
 #define PCI_DEVICE_ID_TRIDENT_8500	0x8500
 
+#define PCI_VENDOR_ID_NETLOGIC		0x184E
+
 #define PCI_VENDOR_ID_AI		0x1025
 #define PCI_DEVICE_ID_AI_M1435		0x1435
 
-- 
1.7.0.2

