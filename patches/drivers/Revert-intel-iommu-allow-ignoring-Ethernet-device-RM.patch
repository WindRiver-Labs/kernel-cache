From ac7b6eeb703dbb2b228de60da793a8a8ee456167 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Fri, 11 Dec 2015 10:33:54 +0800
Subject: [PATCH] Revert "intel-iommu: allow ignoring Ethernet device RMRR
 with IOMMU passthrough"

This reverts commit 9456aa0fba4e84d865c9dcfdb440ab908d4aee8e.

It seems that there are some concerns about people mis-using this boot
arg, and now there is a hardware specific solution to avoid needing a
software/kernel specific solution.  So lets drop this temp workaround.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 Documentation/Intel-IOMMU.txt       |   18 ------------------
 Documentation/kernel-parameters.txt |    5 -----
 drivers/iommu/intel-iommu.c         |   20 --------------------
 3 files changed, 0 insertions(+), 43 deletions(-)

diff --git a/Documentation/Intel-IOMMU.txt b/Documentation/Intel-IOMMU.txt
index 1dcc349..cf9431d 100644
--- a/Documentation/Intel-IOMMU.txt
+++ b/Documentation/Intel-IOMMU.txt
@@ -32,24 +32,6 @@ regions will fail. Hence BIOS uses RMRR to specify these regions along with
 devices that need to access these regions. OS is expected to setup
 unity mappings for these regions for these devices to access these regions.
 
-RMRR for other devices?
------------------------
-
-There are reports of BIOS out there that indicate RMRR regions for things
-like ethernet devices.  As per mainline commit c875d2c1b8083 ("iommu/vt-d:
- Exclude devices using RMRRs from IOMMU API domains") such a device is
-"fundamentally incompatible" with the IOMMU API and "we must prevent such
-devices from being used by the IOMMU API."  However, in the event that
-the RMRR indicated by the BIOS is assumed to be just a reporting error,
-there is an additional iommu boot arg that can be used to ignore RMRR
-settings for ethernet, i.e. "intel_iommu=on,eth_no_rmrr iommu=pt".
-Note that iommu=pt is required in order to eth_no_rmrr to have effect.
-
-If you use this setting, you should consult with your hardware vendor to
-confirm that it is just a reporting error, and that it truly is not
-actively using any DMA to/from RMRR, as otherwise system instability
-may result.
-
 How is IOVA generated?
 ---------------------
 
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index c2104d9..8ecf802 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1189,11 +1189,6 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			than 32-bit addressing. The default is to look
 			for translation below 32-bit and if not available
 			then look in the higher range.
-		eth_no_rmrr [Default Off]
-			With this option provided, the kernel will ignore
-			any specified RMRR regions specified by the BIOS
-			for PCI ethernet devices.  Confirm with your hardware
-			vendor the RMRR regions are indeed invalid first.
 		strict [Default Off]
 			With this option on every unmap_single operation will
 			result in a hardware IOTLB flush operation as opposed
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index b484873..85bb7c7 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -442,7 +442,6 @@ static int dmar_map_gfx = 1;
 static int dmar_forcedac;
 static int intel_iommu_strict;
 static int intel_iommu_superpage = 1;
-static int intel_iommu_ethrmrr = 1;
 
 int intel_iommu_gfx_mapped;
 EXPORT_SYMBOL_GPL(intel_iommu_gfx_mapped);
@@ -472,15 +471,6 @@ static int __init intel_iommu_setup(char *str)
 			printk(KERN_INFO
 				"Intel-IOMMU: Forcing DAC for PCI devices\n");
 			dmar_forcedac = 1;
-		} else if (!strncmp(str, "eth_no_rmrr", 11)) {
-			if (!iommu_pass_through) {
-				printk(KERN_WARNING
-					"Intel-IOMMU: error - eth_no_rmrr requires iommu=pt\n");
-			} else {
-				printk(KERN_INFO
-					"Intel-IOMMU: ignoring ethernet RMRR values\n");
-				intel_iommu_ethrmrr = 0;
-			}
 		} else if (!strncmp(str, "strict", 6)) {
 			printk(KERN_INFO
 				"Intel-IOMMU: disable batched IOTLB flush\n");
@@ -2530,13 +2520,6 @@ static int iommu_should_identity_map(struct pci_dev *pdev, int startup)
 	 * and their respective RMRR info is lost. We exempt USB devices
 	 * from this process due to their usage of RMRRs that are known
 	 * to not be needed after BIOS hand-off to OS.
-	 *
-	 * As a temporary workaround for issues seen on ProLiant DL380p,
-	 * allow the operator to ignore the RMRR settings for ethernet
-	 * devices.  Ideally the end user should contact their vendor
-	 * regarding why there are RMRR, as per mainline c875d2c1b8083
-	 * ("iommu/vt-d: Exclude devices using RMRRs from IOMMU API domains")
-	 * it seems that these make no sense at all.
 	 */
 	if (device_has_rmrr(&pdev->dev)) {
 		int match = 0;
@@ -2544,9 +2527,6 @@ static int iommu_should_identity_map(struct pci_dev *pdev, int startup)
 		if ((pdev->class >> 8) == PCI_CLASS_SERIAL_USB)
 			match = 1;
 
-		if ((pdev->class >> 8) == PCI_CLASS_NETWORK_ETHERNET && !intel_iommu_ethrmrr)
-			match = 1;
-
 		if (!match)
 			return 0;
 	}
-- 
1.7.5.4

