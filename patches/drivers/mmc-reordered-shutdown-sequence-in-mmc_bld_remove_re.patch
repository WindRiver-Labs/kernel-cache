From 4de9839686c8cf63d5760b9cb22b92104f14c302 Mon Sep 17 00:00:00 2001
From: Paul Taysom <taysom@chromium.org>
Date: Tue, 27 Sep 2016 10:01:23 +0800
Subject: [PATCH 3/3] mmc: reordered shutdown sequence in mmc_bld_remove_req

commit fdfa20c1631210d0ca218689204682ea80e170e3 upstream

We had a multi-partition SD-Card with two ext2 file systems. The
partition
table was getting overwritten by a race between the card removal and
the unmount of the 2nd ext2 partition.

What was observed:
1. Suspend/resume would call to remove the device. The clearing
   of the device information is done asynchronously.
2. A request is made to unmount the file system (this is called
   after the removal has started).
3. The remapping table was cleared by the asynchronous part of
   the device removal.
4. A write request to the super block (block 0 of the partition)
   was sent down and instead of being remapped to the partition
   offset, it was remapped to block 0 of the device which is where
   the partition table is located.
5. Write was queued and written resulting in the overwriting
   of the partition table with the ext2 super block.
6. The mmc_queue is cleaned up.

The mmc card device driver used to access SD cards, was calling
del_gendisk
before calling mmc_cleanup-queue. The comment in the mmc_blk_remove_req
code indicated that it expected del_gendisk to block all further
requests
from being queued but it doesn't. The mmc driver uses the presences of
the
mmc_queue to determine if the request should be queued.

The fix was to clean up the mmc_queue before the rest of the
the delete partition code is called.

This prevents the overwriting of the partition table.

However, the umount gets an error trying to write the super block.
The umount should be issued before the device is removed but that
is not always possible. The umount is still needed to cleanup other
data structures.

Addresses the problem described in http://crbug.com/240815

Signed-off-by: Paul Taysom <taysom@chromium.org>
Signed-off-by: Chris Ball <cjb@laptop.org>
Signed-off-by: Hu <yadi.hu@windriver.com>
---
 drivers/mmc/card/block.c |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 98dc07a..e586b63 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1701,6 +1701,12 @@ static void mmc_blk_remove_req(struct mmc_blk_data *md)
 	struct mmc_card *card;
 
 	if (md) {
+		/*
+		 * Flush remaining requests and free queues. It
+		 * is freeing the queue that stops new requests
+		 * from being accepted.
+		 */
+		mmc_cleanup_queue(&md->queue);
 		card = md->queue.card;
 		if (md->disk->flags & GENHD_FL_UP) {
 			device_remove_file(disk_to_dev(md->disk), &md->force_ro);
@@ -1713,8 +1719,6 @@ static void mmc_blk_remove_req(struct mmc_blk_data *md)
 			del_gendisk(md->disk);
 		}
 
-		/* Then flush out any already in there */
-		mmc_cleanup_queue(&md->queue);
 		mmc_blk_put(md);
 	}
 }
-- 
1.7.5.4

