From e6e9cfcc92827929405f982b6b90a20b604aa717 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Mon, 2 Feb 2009 08:23:42 -0500
Subject: [PATCH] 8250: fixup port interrupt handling to avoid INT flood on break

There seems to be an issue with recent 83xx/85xx SOC UARTs, in which a break
triggers a short lived IRQ storm (hence killing any hope of using SysRQ).
The only fix that could be  found to work was to just ignore the bogus
events that had the associated signature bit set.

This additional code is used if CONFIG_SERIAL_8250_PPC_BUG is set
allowing the fix to be enabled easily if the flood condition is met
on target hardware.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 drivers/serial/8250.c      |    6 ++++++
 drivers/serial/8250.h      |   15 +++++++++++++++
 drivers/serial/Kconfig     |   13 +++++++++++++
 include/linux/serial_reg.h |    1 +
 4 files changed, 35 insertions(+), 0 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 731c8e8..97b8142 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -1438,6 +1438,11 @@ serial8250_handle_port(struct uart_8250_port *up)
 
 	status = serial_inp(up, UART_LSR);
 
+	if ((up->bugs & UART_BUG_PPC) && (status == RFE_ERR_BITS)) {
+		spin_unlock_irqrestore(&up->port.lock, flags);
+		return;
+	}
+
 	DEBUG_INTR("status = %x...", status);
 
 	if (status & (UART_LSR_DR | UART_LSR_BI))
@@ -1819,6 +1824,7 @@ static int serial8250_startup(struct uart_port *port)
 
 	up->capabilities = uart_config[up->port.type].flags;
 	up->mcr = 0;
+	up->bugs |= UART_KNOWN_BUGS;
 
 	if (up->port.type == PORT_16C950) {
 		/* Wake up and initialize UART */
diff --git a/drivers/serial/8250.h b/drivers/serial/8250.h
index 5202603..cba3f46 100644
--- a/drivers/serial/8250.h
+++ b/drivers/serial/8250.h
@@ -14,6 +14,11 @@
  */
 
 #include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+
+
+#define RFE_ERR_BITS ( UART_LSR_RFE | UART_LSR_TEMT | \
+			UART_LSR_THRE | UART_LSR_BI | UART_LSR_DR )
 
 struct old_serial_port {
 	unsigned int uart;
@@ -48,6 +53,7 @@ struct serial8250_config {
 #define UART_BUG_TXEN	(1 << 1)	/* UART has buggy TX IIR status */
 #define UART_BUG_NOMSR	(1 << 2)	/* UART has buggy MSR status bits (Au1x00) */
 #define UART_BUG_THRE	(1 << 3)	/* UART has buggy THRE reassertion */
+#define UART_BUG_PPC	(1 << 4)	/* UART has buggy PPC break IRQ storm */
 
 #define PROBE_RSA	(1 << 0)
 #define PROBE_ANY	(~0)
@@ -77,3 +83,12 @@ struct serial8250_config {
 #else
 #define ALPHA_KLUDGE_MCR 0
 #endif
+
+#ifdef CONFIG_SERIAL_8250_PPC_BUG
+#define UART_KNOWN_BUGS UART_BUG_PPC
+#endif
+
+#ifndef UART_KNOWN_BUGS
+#define UART_KNOWN_BUGS 0
+#endif
+
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 77cb342..ba63abe 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -71,6 +71,19 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config SERIAL_8250_PPC_BUG
+	bool "Fix 8250/16550 to handle interrupt storm on receipt of a break"
+	depends on SERIAL_8250
+	---help---
+	  If you say Y here, addional checks will be added in the handling of
+	  interrupts on the serial ports which will prevent ill effects of
+	  an interrupt storm caused by buggy hardware. This can be the solution
+	  to unusable Magic Sysrq on the serial console.
+
+	  This is commonly observed on 83xx/85xx/86xx boards.
+
+	  If unsure, say N.
+
 config FIX_EARLYCON_MEM
 	bool
 	depends on X86
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 96c0d93..1ea6436 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -111,6 +111,7 @@
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
 #define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_RFE		0x80 /* Rx FIFO Error (BE, FE, or PE) */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
-- 
1.6.0.3

