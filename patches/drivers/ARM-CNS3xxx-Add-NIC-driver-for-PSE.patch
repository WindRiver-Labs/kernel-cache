From 7f59e142091a6684cde406f3d587f13a1b82520b Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Sat, 18 Jun 2011 16:33:06 +0800
Subject: [PATCH 04/27] ARM:CNS3xxx:Add NIC driver for PSE

The PSE module(L2 Packet Swithing Engine) on CNS3420 processor is a
5 ports non-blocking swithing fabric, it exposes 3 MAC port for
external connection.

The CNS3420 board connects Port 0 & 1 on processor to a broadcom's
switch (bcm53115M), which exposes four RJ45 ethernet ports on board.
While the MAC Port 2 from processor exports a ethernet port via
a ICP ip1001 phy.

This patch adds a NIC driver for CNS3420 VB board's PSE module.

Extracted from vendor drop CNS3xxx-sdk-201102161603-v1.1_20110224.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm/mach-cns3xxx/cns3420vb.c         |    5 +
 drivers/net/Kconfig                       |    1 +
 drivers/net/Makefile                      |    3 +
 drivers/net/cns3xxx/Kconfig               |   59 +
 drivers/net/cns3xxx/Makefile              |   36 +
 drivers/net/cns3xxx/cns3xxx.h             |  322 +++
 drivers/net/cns3xxx/cns3xxx_config.h      |   75 +
 drivers/net/cns3xxx/cns3xxx_ethtool.c     |  341 +++
 drivers/net/cns3xxx/cns3xxx_init_config.h |   37 +
 drivers/net/cns3xxx/cns3xxx_main.c        | 3340 +++++++++++++++++++++++++++++
 drivers/net/cns3xxx/cns3xxx_phy.c         |  983 +++++++++
 drivers/net/cns3xxx/cns3xxx_phy.h         |   78 +
 drivers/net/cns3xxx/cns3xxx_symbol.h      |  250 +++
 drivers/net/cns3xxx/cns3xxx_tool.h        |  581 +++++
 drivers/net/cns3xxx/pse_init.c            |  370 ++++
 drivers/net/cns3xxx/pse_init_common.h     |   56 +
 drivers/net/cns3xxx/switch_api.h          |  314 +++
 drivers/net/cns3xxx/vb.h                  |  436 ++++
 18 files changed, 7287 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/cns3xxx/Kconfig
 create mode 100644 drivers/net/cns3xxx/Makefile
 create mode 100644 drivers/net/cns3xxx/cns3xxx.h
 create mode 100644 drivers/net/cns3xxx/cns3xxx_config.h
 create mode 100644 drivers/net/cns3xxx/cns3xxx_ethtool.c
 create mode 100644 drivers/net/cns3xxx/cns3xxx_init_config.h
 create mode 100644 drivers/net/cns3xxx/cns3xxx_main.c
 create mode 100644 drivers/net/cns3xxx/cns3xxx_phy.c
 create mode 100644 drivers/net/cns3xxx/cns3xxx_phy.h
 create mode 100644 drivers/net/cns3xxx/cns3xxx_symbol.h
 create mode 100644 drivers/net/cns3xxx/cns3xxx_tool.h
 create mode 100644 drivers/net/cns3xxx/pse_init.c
 create mode 100644 drivers/net/cns3xxx/pse_init_common.h
 create mode 100644 drivers/net/cns3xxx/switch_api.h
 create mode 100644 drivers/net/cns3xxx/vb.h

diff --git a/arch/arm/mach-cns3xxx/cns3420vb.c b/arch/arm/mach-cns3xxx/cns3420vb.c
index 4d2fbbe..9832281 100644
--- a/arch/arm/mach-cns3xxx/cns3420vb.c
+++ b/arch/arm/mach-cns3xxx/cns3420vb.c
@@ -205,6 +205,11 @@ static void __init cns3420_init(void)
 
 static struct map_desc cns3420_io_desc[] __initdata = {
 	{
+		.virtual	= CNS3XXX_SWITCH_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_SWITCH_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
 		.virtual	= CNS3XXX_SSP_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_SSP_BASE),
 		.length		= SZ_4K,
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 70c8e79..cf62cb7 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2010,6 +2010,7 @@ menuconfig NETDEV_1000
 	  If you say N, all options in this submenu will be skipped and disabled.
 
 if NETDEV_1000
+source "drivers/net/cns3xxx/Kconfig"
 
 config ACENIC
 	tristate "Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support"
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 8dd55bc..44fa8c6 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -10,6 +10,9 @@ obj-$(CONFIG_TI_DAVINCI_EMAC) += davinci_emac.o
 
 obj-$(CONFIG_E1000) += e1000/
 obj-$(CONFIG_E1000E) += e1000e/
+
+obj-$(CONFIG_CNS3XXX_GSW) += cns3xxx/
+
 obj-$(CONFIG_IBM_NEW_EMAC) += ibm_newemac/
 obj-$(CONFIG_IGB) += igb/
 obj-$(CONFIG_IGBVF) += igbvf/
diff --git a/drivers/net/cns3xxx/Kconfig b/drivers/net/cns3xxx/Kconfig
new file mode 100644
index 0000000..66cee45
--- /dev/null
+++ b/drivers/net/cns3xxx/Kconfig
@@ -0,0 +1,59 @@
+menu "CNS3XXX Gigabit Switch Support"
+	depends on ARCH_CNS3XXX
+
+config CNS3XXX_GSW
+	tristate "CNS3XXX Gigabit Switch Driver Support"
+	depends on ARCH_CNS3XXX
+	select CNS3XXX_PSE_INIT
+	help
+	  CNS3XXX layer-2 Packet Switching Enging(PSE) is a 5-port Layer-2
+	  non-blocking shared-memory switch fabric: 3 MAC ports are exposed
+	  for external connections, and the other two are used internally for
+	  CPU port, and L2/L3/L4 Packet Processing Engine(PPE) respectively.
+
+config CNS3XXX_ETHADDR_IN_FLASH
+	bool "CNS3XXX MAC address in flash"
+	depends on CNS3XXX_GSW && MTD
+	help
+	  Say Y if you want to load MAC address from flash.
+
+choice
+	prompt "Load MAC address from ..."
+	depends on CNS3XXX_ETHADDR_IN_FLASH
+	default MAC_IN_PARALLEL_FLASH
+
+config CNS3XXX_MAC_IN_PARALLEL_FLASH
+	bool "Parallel Flash"
+
+config CNS3XXX_MAC_IN_SPI_FLASH
+	bool "SPI Flash"
+
+endchoice
+
+config CNS3XXX_PSE_INIT
+	tristate "CNS3XXX PSE Initialize part"
+	depends on ARCH_CNS3XXX && CNS3XXX_GSW
+	default m if CNS3XXX_GSW=m
+	default y if CNS3XXX_GSW=y
+	help
+	  CNS3XXX layer-2 Packet Switching Enging(PSE) is a 5-port Layer-2
+	  non-blocking shared-memory switch fabric: 3 MAC ports are exposed
+	  for external connections, and the other two are used internally for
+	  CPU port, and L2/L3/L4 Packet Processing Engine(PPE) respectively.
+
+choice
+	prompt "Board Configuration"
+	depends on CNS3XXX_PSE_INIT
+	default CNS3XXX_GSW_VB if CONFIG_MACH_CNS3420VB=y
+
+config CNS3XXX_GSW_VB
+	bool "Validation Board 1.x"
+	select GPIO_CNS3XXX
+	help
+	  This configuration is used for CNS3420 Validation Board version:
+	  1.1, 1,2 and 1.3. MAC0 and MAC1 connect to Broadcom BCM53115M
+	  5-port 10/100/1000 switch. MAC2 connect to IC Plus IP1001 gigabit
+	  ethernet transceiver.
+endchoice
+
+endmenu
diff --git a/drivers/net/cns3xxx/Makefile b/drivers/net/cns3xxx/Makefile
new file mode 100644
index 0000000..73fa606
--- /dev/null
+++ b/drivers/net/cns3xxx/Makefile
@@ -0,0 +1,36 @@
+################################################################################
+#
+#
+#   Copyright (c) 2008 Cavium Networks
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+#
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+#
+# Makefile for the Star GSW ethernet driver
+#
+
+obj-$(CONFIG_CNS3XXX_GSW) += cns3xxx.o
+cns3xxx-objs := cns3xxx_main.o cns3xxx_ethtool.o
+
+obj-$(CONFIG_CNS3XXX_PSE_INIT) += cns3xxx_pse_init.o
+cns3xxx_pse_init-objs := cns3xxx_phy.o pse_init.o
diff --git a/drivers/net/cns3xxx/cns3xxx.h b/drivers/net/cns3xxx/cns3xxx.h
new file mode 100644
index 0000000..d3fe79c
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx.h
@@ -0,0 +1,322 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#ifndef CNS3XXX_H
+#define CNS3XXX_H
+
+#include "cns3xxx_symbol.h"
+#include "cns3xxx_config.h"
+#include "switch_api.h"
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/reboot.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/if_ether.h>
+#include <linux/icmp.h>
+#include <linux/udp.h>
+#include <linux/tcp.h>
+#include <linux/if_arp.h>
+#include <net/arp.h>
+#include <asm/irq.h>
+#include <mach/cns3xxx.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+struct TXDesc {
+	int32_t sdp; /* segment data pointer*/
+
+	u32 sdl:16; /* segment data length */
+	u32 tco:1;
+	u32 uco:1;
+	u32 ico:1;
+	u32 rsv_1:3; /* reserve */
+	u32 pri:3;
+	u32 fp:1; /* force priority*/
+	u32 fr:1;
+	u32 interrupt:1;
+	u32 lsd:1;
+	u32 fsd:1;
+	u32 eor:1;
+	u32 cown:1;
+
+
+	u32 ctv:1;
+	u32 stv:1;
+	u32 sid:4;
+	u32 inss:1;
+	u32 dels:1;
+	u32 rsv_2:9;
+	u32 pmap:5;
+	u32 mark:3;
+	u32 ewan:1;
+	u32 fewan:1;
+	u32 rsv_3:5;
+
+	u32 c_vid:12;
+	u32 c_cfs:1;
+	u32 c_pri:3;
+	u32 s_vid:12;
+	u32 s_dei:1;
+	u32 s_pri:3;
+
+	u8 alignment[16]; /* for alignment 32 byte*/
+} __attribute__((packed));
+
+struct RXDesc {
+	u32 sdp;
+
+	u32 sdl:16;
+	u32 l4f:1;
+	u32 ipf:1;
+	u32 prot:4;
+	u32 hr:6;
+	u32 lsd:1;
+	u32 fsd:1;
+	u32 eor:1;
+	u32 cown:1;
+
+	u32 ctv:1;
+	u32 stv:1;
+	u32 unv:1;
+	u32 iwan:1;
+	u32 exdv:1;
+	u32 e_wan:1;
+	u32 rsv_1:2;
+	u32 sp:3;
+	u32 crc_err:1;
+	u32 un_eth:1;
+	u32 tc:2;
+	u32 rsv_2:1;
+	u32 ip_offset:5;
+	u32 rsv_3:11;
+
+	u32 c_vid:12;
+	u32 c_cfs:1;
+	u32 c_pri:3;
+	u32 s_vid:12;
+	u32 s_dei:1;
+	u32 s_pri:3;
+
+	u8 alignment[16]; /* for alignment 32 byte*/
+
+} __attribute__((packed));
+
+struct TXBuffer {
+	struct TXDesc *tx_desc;
+	struct sk_buff *skb; /* for free skb*/
+	u32 pri;
+	unsigned long tx_index;
+};
+
+struct RXBuffer {
+	struct RXDesc *rx_desc;
+	struct sk_buff *skb;
+	/* rx path need to fill some skb field, ex: length ...*/
+};
+
+
+struct TXRing {
+	struct TXBuffer *head;
+	struct TXDesc *tx_desc_head_vir_addr;
+	dma_addr_t tx_desc_head_phy_addr;
+	u32 cur_index; /* for put send packet*/
+	spinlock_t tx_lock;
+	u32 non_free_tx_skb;
+	u32 free_tx_skb_index;
+	u32 ring_size;
+	u32 max_ring_size;
+	u32 num_free_desc;
+};
+
+
+struct RXRing {
+	struct RXBuffer *head;
+	struct RXDesc *rx_desc_head_vir_addr;
+	dma_addr_t rx_desc_head_phy_addr;
+	u32 cur_index;
+	u32 ring_size;
+	u32 max_ring_size;
+};
+
+
+#define RX_RING0(priv) (priv->rx_ring[0])
+#define TX_RING0(priv) (priv->tx_ring[0])
+
+#define get_rx_ring_size(ring) \
+	(((struct RXRing *)ring)->ring_size)
+
+#define get_tx_ring_size(ring) \
+	(((struct TXRing *)ring)->ring_size)
+
+#define get_rx_ring_head(rx_ring) \
+	(((struct RXRing *)rx_ring)->head)
+
+#define get_tx_ring_head(tx_ring) \
+	(((struct TXRing *)tx_ring)->head)
+
+#define get_cur_rx_buffer(rx_ring) \
+(((struct RXRing *)rx_ring)->head + ((struct RXRing *)rx_ring)->cur_index)
+
+#define get_cur_tx_buffer(tx_ring) \
+(((struct TXRing *)tx_ring)->head + ((struct TXRing *)tx_ring)->cur_index)
+
+#define get_rx_head_phy_addr(rx_ring) \
+	(((struct RXRing *)rx_ring)->rx_desc_head_phy_addr)
+
+#define get_tx_ring_head_phy_addr(tx_ring) \
+	(((struct TXRing *)tx_ring)->tx_desc_head_phy_addr)
+
+#define get_rx_cur_index(rx_ring) (((struct RXRing *)rx_ring)->cur_index)
+
+#define get_tx_cur_index(tx_ring) (((struct TXRing *)tx_ring)->cur_index)
+
+static inline u32 get_tx_cur_phy_addr(u8 ring_num)
+{
+	if (ring_num == 0)
+		return TS_DESC_PTR0_REG;
+	if (ring_num == 1)
+		return TS_DESC_PTR1_REG;
+	return 0; /* fail */
+}
+
+#define rx_index_next(ring) \
+	(((struct RXRing *)ring)->cur_index =\
+	((((struct RXRing *)ring)->cur_index + 1) %\
+	((struct RXRing *)ring)->ring_size))
+
+#define tx_index_next(ring) \
+	(((struct TXRing *)ring)->cur_index =\
+	((((struct TXRing *)ring)->cur_index + 1) %\
+	((struct TXRing *)ring)->ring_size))
+
+struct CNS3XXXPrivate;
+
+/* for ethtool set operate */
+struct NICSetting {
+
+};
+
+struct NetDevicePriv {
+	int pmap; /* for port base, force route*/
+	int is_wan; /* mean the net device is WAN side.*/
+	u16 s_tag;
+	u16 vlan_tag;
+
+/* do port base mode and vlan base mode work */
+	int (*rx_func)(struct sk_buff *skb,
+		struct RXDesc *tx_desc_ptr, const struct CNS3XXXPrivate *);
+	int (*tx_func)(struct TXDesc *tx_desc_ptr,
+		const struct CNS3XXXPrivate *, struct sk_buff *);
+	void (*open)(void);
+	void (*close)(void);
+	u8 which_port;
+
+	u8 mac[6];
+	struct VLANTableEntry *vlan_table_entry;
+	struct ARLTableEntry *arl_table_entry;
+	struct NICSetting *nic_setting;
+	const char *name;
+	/* 16 bytes, reference include/linux/netdevice.h IFNAMSIZ*/
+};
+
+struct RingInfo {
+	u8 num_rx_queues;
+	u8 num_tx_queues;
+	struct TXRing *tx_ring;
+	struct RXRing *rx_ring;
+};
+
+
+/* store this information for the driver.. */
+struct CNS3XXXPrivate {
+	u8 num_rx_queues;
+	u8 num_tx_queues;
+	struct TXRing *tx_ring;
+	struct RXRing *rx_ring;
+	struct net_device_stats stats;
+	spinlock_t lock;
+	int pmap;
+	int is_wan; /* mean the net device is WAN side.*/
+	u16 gid;
+	u8 mac_type; /* VLAN base, or port base;*/
+	u16 vlan_tag;
+	struct napi_struct napi;
+	struct work_struct reset_task;
+
+	u8 which_port;
+
+	char name[IFNAMSIZ];
+	/* 16 bytes, reference include/linux/netdevice.h IFNAMSIZ*/
+
+	struct NetDevicePriv *net_device_priv;
+	u8 ring_index;
+
+	u32 rx_s_vid[4096]; /* record receive s vid (0x9100 ...)*/
+	u32 rx_c_vid[4096]; /* record receive c vid (0x8100 ...)*/
+	volatile unsigned long is_qf; /* determine rx ring queue full state*/
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	struct vlan_group               *vlgrp;
+#endif
+};
+
+int rx_port_base(struct sk_buff *skb,
+	struct RXDesc *rx_desc_ptr, const struct CNS3XXXPrivate *priv);
+
+int rx_vlan_base(struct sk_buff *skb,
+	struct RXDesc *rx_desc_ptr, const struct CNS3XXXPrivate *priv);
+
+int tx_port_base(struct TXDesc *tx_desc_ptr,
+	const struct CNS3XXXPrivate *priv, struct sk_buff *skb);
+
+int tx_vlan_base(struct TXDesc *tx_desc_ptr,
+	const struct CNS3XXXPrivate *priv, struct sk_buff *skb);
+
+int cns3xxx_close(struct net_device *dev);
+int cns3xxx_open(struct net_device *dev);
+
+#endif
diff --git a/drivers/net/cns3xxx/cns3xxx_config.h b/drivers/net/cns3xxx/cns3xxx_config.h
new file mode 100644
index 0000000..ae67d32
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_config.h
@@ -0,0 +1,75 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+#ifndef CNS3XXX_CONFIG_H
+#define CNS3XXX_CONFIG_H
+
+#define CNS3XXX_CPU_MIB_COUNTER
+#define CNS3XXX_MAC0_MIB_COUNTER
+#define CNS3XXX_MAC1_MIB_COUNTER
+#define CNS3XXX_MAC2_MIB_COUNTER
+
+#define CONFIG_CNS3XXX_NAPI
+#ifdef CONFIG_CNS3XXX_NAPI
+#define CNS3XXX_NAPI_WEIGHT 16
+#endif
+
+#define CNS3XXX_TX_HW_CHECKSUM
+#define CNS3XXX_RX_HW_CHECKSUM
+
+#undef CNS3XXX_SHOW_LINK_STATUS
+
+#ifdef CNS3XXX_SHOW_LINK_STATUS
+#define CNS3XXX_STATUS_ISR
+#endif
+#undef CNS3XXX_STATUS_ISR
+#undef CNS3XXX_TEST_ONE_LEG_VLAN
+#undef CNS3XXX_TX_DSCP_PROC
+
+
+#define CNS3XXX_FSQF_RING0_ISR
+#undef CNS3XXX_TSTC_RING0_ISR
+#undef CNS3XXX_TSTC_RING1_ISR
+
+#undef CNS3XXX_COMPARE_PACKET
+#undef CONFIG_FPGA_10
+
+
+#define CNS3XXX_FREE_TX_IN_RX_PATH
+
+#define CNS3XXX_PVID_PROC
+#define CNS3XXX_SARL_PROC
+
+
+#undef CNS3XXX_DOUBLE_RX_RING
+#undef CNS3XXX_DOUBLE_TX_RING
+
+#define CNS3XXX_CONFIG_CHANGE_TX_RING
+
+#ifdef CNS3XXX_DOUBLE_RX_RING
+#define CNS3XXX_FSQF_RING1_ISR
+#endif
+
+
+#define PRINT_INFO printk
+
+#endif
diff --git a/drivers/net/cns3xxx/cns3xxx_ethtool.c b/drivers/net/cns3xxx/cns3xxx_ethtool.c
new file mode 100644
index 0000000..f48f4ad
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_ethtool.c
@@ -0,0 +1,341 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ethtool.h>
+#include <linux/netdevice.h>
+#include "cns3xxx_symbol.h"
+#include "cns3xxx.h"
+#include "cns3xxx_tool.h"
+
+static void cns3xxx_get_drvinfo(
+	struct net_device *netdev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "cns3xxx");
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->fw_version, "N/A");
+	strcpy(info->bus_info, "N/A");
+}
+
+static void cns3xxx_get_ringparam(struct net_device *netdev,
+	struct ethtool_ringparam *ring)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	ring->rx_max_pending = priv->rx_ring->max_ring_size;
+	ring->tx_max_pending = priv->tx_ring->max_ring_size;
+	ring->rx_pending = priv->rx_ring->ring_size;
+	ring->tx_pending = priv->tx_ring->ring_size;
+}
+
+extern struct net_device *net_dev_array[];
+
+static int cns3xxx_set_ringparam(
+	struct net_device *netdev, struct ethtool_ringparam *ring)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	int i = 0;
+
+	for (i = 0; i < NETDEV_SIZE; ++i) {
+		if (net_dev_array[i] && netif_running(net_dev_array[i]))
+			cns3xxx_close(net_dev_array[i]);
+	}
+
+	priv->rx_ring->ring_size =
+		min(ring->rx_pending, priv->rx_ring->max_ring_size);
+	priv->tx_ring->ring_size =
+		min(ring->rx_pending, priv->tx_ring->max_ring_size);
+
+	for (i = 0; i < NETDEV_SIZE; ++i) {
+		if (net_dev_array[i] && netif_running(net_dev_array[i]))
+			cns3xxx_open(net_dev_array[i]);
+	}
+	return 0;
+}
+
+static uint32_t cns3xxx_get_tx_csum(struct net_device *netdev)
+{
+	return (netdev->features & NETIF_F_IP_CSUM) != 0;
+}
+
+static int cns3xxx_set_tx_csum(struct net_device *netdev, uint32_t data)
+{
+	if (data)
+		netdev->features |= NETIF_F_IP_CSUM;
+	else
+		netdev->features &= ~NETIF_F_IP_CSUM;
+	return 0;
+}
+
+static uint32_t cns3xxx_get_rx_csum(struct net_device *netdev)
+{
+	return 1;
+}
+
+static int cns3xxx_set_rx_csum(struct net_device *netdev, uint32_t data)
+{
+	return 0;
+}
+
+u32 cns3xxx_get_sg(struct net_device *dev)
+{
+#ifdef NETIF_F_SG
+	return (dev->features & NETIF_F_SG) != 0;
+#else
+	return 0;
+#endif
+}
+
+int cns3xxx_set_sg(struct net_device *dev, u32 data)
+{
+#ifdef NETIF_F_SG
+	if (data)
+		dev->features |= NETIF_F_SG;
+	else
+		dev->features &= ~NETIF_F_SG;
+#endif
+	return 0;
+}
+
+static void cns3xxx_get_pauseparam(
+	struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	u32 mac_port_config = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	switch (priv->net_device_priv->which_port) {
+	case MAC_PORT0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case MAC_PORT1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case MAC_PORT2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+	pause->autoneg = (((mac_port_config >> 7) & 1) ?
+		AUTONEG_ENABLE : AUTONEG_DISABLE);
+	pause->tx_pause = (mac_port_config >> 6) & 1;
+	pause->rx_pause = (mac_port_config >> 5) & 1;
+}
+
+static int cns3xxx_set_pauseparam(
+	struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	u32 mac_port_config = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	switch (priv->net_device_priv->which_port) {
+	case MAC_PORT0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case MAC_PORT1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case MAC_PORT2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+
+	mac_port_config &= ~(0x1 << 7); /* clean AN */
+	mac_port_config &= ~(0x1 << 11); /* clean rx flow control*/
+	mac_port_config &= ~(0x1 << 12); /* clean tx flow control*/
+
+	mac_port_config |=
+		((pause->autoneg << 7) |
+		(pause->rx_pause << 11) |
+		(pause->tx_pause << 12));
+
+	switch (priv->net_device_priv->which_port) {
+	case MAC_PORT0:
+		MAC0_CFG_REG  = mac_port_config;
+		break;
+	case MAC_PORT1:
+		MAC1_CFG_REG  = mac_port_config;
+		break;
+	case MAC_PORT2:
+		MAC2_CFG_REG  = mac_port_config;
+		break;
+	}
+	return 0;
+}
+
+u32 cns3xxx_get_link(struct net_device *netdev)
+{
+	u32 mac_port_config = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	switch (priv->net_device_priv->which_port) {
+	case MAC_PORT0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case MAC_PORT1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case MAC_PORT2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+
+	return (mac_port_config & 1) ? 1 : 0;
+}
+
+static int cns3xxx_get_settings(
+	struct net_device *netdev, struct ethtool_cmd *ecmd)
+{
+	u8 value;
+	u32 mac_port_config = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	if (priv->net_device_priv->nic_setting == 0) {
+		/* connect to switch chip*/
+		GET_MAC_PORT_CFG(
+			priv->net_device_priv->which_port,
+			mac_port_config)
+		ecmd->supported =
+			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+			SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full |
+			SUPPORTED_Autoneg | SUPPORTED_TP |
+			SUPPORTED_MII | SUPPORTED_Pause);
+		ecmd->duplex =
+			((mac_port_config >> 4) & 0x1) ?
+			DUPLEX_FULL : DUPLEX_HALF;
+
+		value = ((mac_port_config >> 2) & 0x3);
+		switch (value) {
+		case 0:
+			ecmd->speed = SPEED_10;
+			break;
+		case 1:
+			ecmd->speed = SPEED_100;
+			break;
+		case 2:
+			ecmd->speed = SPEED_1000;
+			break;
+		}
+		ecmd->autoneg =
+			((mac_port_config >> 7) & 1) ?
+			AUTONEG_ENABLE : AUTONEG_DISABLE;
+	}
+
+	return 0;
+}
+
+/* set speed and duplex */
+int cns3xxx_set_spd_dplx(struct net_device *netdev, u16 spddplx)
+{
+	u32 mac_port_config = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	GET_MAC_PORT_CFG(priv->net_device_priv->which_port, mac_port_config)
+
+	mac_port_config &= ~(0x3 << 8); /* clear speed*/
+	mac_port_config &= ~(0x1 << 10); /* clear duplex*/
+	mac_port_config &= ~(0x1 << 7); /* disable AN */
+	switch (spddplx) {
+	case AUTONEG_ENABLE:
+		mac_port_config |= (0x1 << 7); /* enable AN*/
+		break;
+	case SPEED_10 + DUPLEX_HALF:
+		mac_port_config |= (0 << 8); /* set speed*/
+		mac_port_config |= (0 << 10); /* set duplex*/
+		break;
+	case SPEED_10 + DUPLEX_FULL:
+		mac_port_config |= (0 << 8); /* set speed*/
+		mac_port_config |= (1 << 10); /* set duplex*/
+		break;
+	case SPEED_100 + DUPLEX_HALF:
+		mac_port_config |= (1 << 8); /* set speed*/
+		mac_port_config |= (0 << 10); /* set duplex*/
+		break;
+	case SPEED_100 + DUPLEX_FULL:
+		mac_port_config |= (1 << 8); /* set speed*/
+		mac_port_config |= (1 << 10); /* set duplex*/
+		break;
+	case SPEED_1000 + DUPLEX_HALF:
+		mac_port_config |= (2 << 8); /* set speed*/
+		mac_port_config |= (0 << 10); /* set duplex*/
+		break;
+	case SPEED_1000 + DUPLEX_FULL:
+		mac_port_config |= (2 << 8); /* set speed*/
+		mac_port_config |= (1 << 10); /* set duplex*/
+		break;
+	default:
+		return -EINVAL;
+	}
+	SET_MAC_PORT_CFG(priv->net_device_priv->which_port, mac_port_config)
+	return 0;
+}
+
+static int cns3xxx_set_settings(
+	struct net_device *netdev, struct ethtool_cmd *ecmd)
+{
+	u8 value = 0;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	if (priv->net_device_priv->nic_setting == 0) {
+		/*connect to switch chip*/
+		if (ecmd->autoneg == AUTONEG_ENABLE) {
+			printk(KERN_INFO "autoneg\n");
+			value = cns3xxx_set_spd_dplx(netdev, AUTONEG_ENABLE);
+			if (value != 0)
+				return -EINVAL;
+		} else {
+			printk(KERN_INFO "no autoneg\n");
+			value = cns3xxx_set_spd_dplx(
+				netdev, ecmd->speed + ecmd->duplex);
+			if (value != 0)
+				return -EINVAL;
+		}
+	}
+
+	/* down then up */
+	return 0;
+}
+
+static const struct ethtool_ops cns3xxx_ethtool_ops = {
+	.get_drvinfo            = cns3xxx_get_drvinfo,
+	.get_ringparam          = cns3xxx_get_ringparam,
+	.set_ringparam          = cns3xxx_set_ringparam,
+	.get_rx_csum            = cns3xxx_get_rx_csum,
+	.set_rx_csum            = cns3xxx_set_rx_csum,
+	.get_tx_csum            = cns3xxx_get_tx_csum,
+	.set_tx_csum            = cns3xxx_set_tx_csum,
+	.get_sg		        = cns3xxx_get_sg,
+	.set_sg                 = cns3xxx_set_sg,
+	.get_pauseparam         = cns3xxx_get_pauseparam,
+	.set_pauseparam         = cns3xxx_set_pauseparam,
+	.get_link               = cns3xxx_get_link,
+	.get_settings           = cns3xxx_get_settings,
+	.set_settings           = cns3xxx_set_settings,
+};
+
+void cns3xxx_set_ethtool_ops(struct net_device *netdev)
+{
+	SET_ETHTOOL_OPS(netdev, &cns3xxx_ethtool_ops);
+}
diff --git a/drivers/net/cns3xxx/cns3xxx_init_config.h b/drivers/net/cns3xxx/cns3xxx_init_config.h
new file mode 100644
index 0000000..d0709dd
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_init_config.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+#include "pse_init_common.h"
+
+#ifndef CNS3XXX_INIT_CONFIG_H
+#define CNS3XXX_INIT_CONFIG_H
+
+#define CNS3XXX_SET_ARL_TABLE
+#define CNS3XXX_AGE_ENABLE
+#define CNS3XXX_LEARN_ENABLE
+#define CNS3XXX_CPU_PORT_FC
+
+#undef ACCEPT_CRC_BAD_PKT
+
+#define IVL /* if no define, use SVL */
+
+#endif
diff --git a/drivers/net/cns3xxx/cns3xxx_main.c b/drivers/net/cns3xxx/cns3xxx_main.c
new file mode 100644
index 0000000..05be4b3
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_main.c
@@ -0,0 +1,3340 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <mach/cns3xxx.h>
+
+#include "cns3xxx.h"
+#include "cns3xxx_tool.h"
+#include "cns3xxx_config.h"
+#include "pse_init_common.h"
+
+#if defined(CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
+#include <linux/mtd/mtd.h>
+#endif
+
+#define RX_SDP_ALIGN 64
+
+ushort MAX_PACKET_LEN = 1536;
+#define CPU_CACHE_BYTES         64
+#define CPU_CACHE_ALIGN(X) \
+	(((X) + (CPU_CACHE_BYTES-1)) & ~(CPU_CACHE_BYTES-1))
+
+
+#define QUEUE_WEIGHT_SET(port, ctl) \
+{ \
+	MAC##port##_PRI_CTRL_REG &= ~(0x3ffff); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.sch_mode << 16); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q0_w); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q1_w << 4); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q2_w << 8); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q3_w << 12); \
+}
+
+#define QUEUE_WEIGHT_GET(port, ctl) \
+{ \
+	ctl.sch_mode = ((MAC##port##_PRI_CTRL_REG >> 16) & 0x3); \
+	ctl.q0_w = ((MAC##port##_PRI_CTRL_REG >> 0) & 0x7); \
+	ctl.q1_w = ((MAC##port##_PRI_CTRL_REG >> 4) & 0x7); \
+	ctl.q2_w = ((MAC##port##_PRI_CTRL_REG >> 8) & 0x7); \
+	ctl.q3_w = ((MAC##port##_PRI_CTRL_REG >> 12) & 0x7); \
+}
+
+#if defined(CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
+
+#define MTD_READ(mtd, args...) (*(mtd->read))(mtd, args)
+
+#ifdef CONFIG_CNS3XXX_MAC_IN_SPI_FLASH
+#define ENV_OFFSET 0x30000
+#define PARTITION_NAME "SPI-UBoot"
+#else
+#define ENV_OFFSET 0x0
+#define PARTITION_NAME "UBootEnv"
+#endif
+
+#define MTD_READ_LEN 1024
+
+static char mtd_str[MTD_READ_LEN], ethaddr[12];
+
+static int init_mtd_env(void)
+{
+	struct mtd_info *mtd;
+	size_t retlen = 0;
+
+	mtd = get_mtd_device_nm(PARTITION_NAME);
+
+	if (IS_ERR(mtd))
+		return -ENODEV;
+
+	MTD_READ(mtd, ENV_OFFSET, MTD_READ_LEN, &retlen, mtd_str);
+	return 0;
+}
+
+int fmg_get(const char *name, int *ret_len)
+{
+	int i, j, x, z;
+	int nlen = strlen(name);
+	char tmp_str[20];
+
+	memset(ethaddr, 0x0, 12);
+
+	for (i = 0; i < MTD_READ_LEN - nlen; i++) {
+		z = 0;
+		for (x = 0; x < nlen; x++) {
+			if (mtd_str[i+x] == name[x])
+				z++;
+		}
+		if (z == nlen) {
+			memcpy(tmp_str, mtd_str + i + nlen, 17);
+			tmp_str[17] = '\0';
+			for (j = 0; j < 17; j++) {
+				if (tmp_str[j] != ':')
+					sprintf(ethaddr,
+						"%s%c", ethaddr, tmp_str[j]);
+			}
+			*ret_len = strlen(ethaddr);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int mac_str_to_int(
+	const char *mac_str, int mac_str_len, u8 *mac_int, int mac_len)
+{
+	int i = 0, j = 0;
+	char mac_s[3] = {0, 0, 0};
+
+	for (i = 0; i < mac_str_len; i += 2) {
+		mac_s[0] = mac_str[i];
+		mac_s[1] = mac_str[i + 1];
+		mac_int[j++] = simple_strtol(mac_s, NULL, 16);
+	}
+	return 0;
+}
+#endif
+
+static int install_isr_rc;
+static int rc_setup_rx_tx; /* rc means reference counting.*/
+static struct net_device *intr_netdev;
+struct net_device *net_dev_array[NETDEV_SIZE];
+spinlock_t tx_lock;
+spinlock_t rx_lock;
+
+u8 show_rx_proc;
+u8 show_tx_proc;
+
+const int MAX_RX_DESC_SIZE = 512;
+const int MAX_TX_DESC_SIZE = 512;
+int RX_DESC_SIZE = 128;
+int TX_DESC_SIZE = 120;
+module_param(RX_DESC_SIZE, int, 0);
+module_param(TX_DESC_SIZE, int, 0);
+
+u8 ring_index; /* 0 or 1*/
+
+#ifdef CNS3XXX_DELAYED_INTERRUPT
+static u32 max_pend_int_cnt = MAX_PEND_INT_CNT;
+static u32 max_pend_time = MAX_PEND_TIME;
+#endif
+
+#ifdef CONFIG_CNS3XXX_NAPI
+struct net_device *napi_dev;
+	#ifdef CNS3XXX_DOUBLE_RX_RING
+	struct net_device *r1_napi_dev;
+	#endif
+#endif
+
+struct RingInfo g_ring_info;
+
+int MSG_LEVEL = NORMAL_MSG;
+
+#ifdef CNS3XXX_STATUS_ISR
+const char *cns3xxx_gsw_status_tbl[] = {
+	"\nMAC0_Q_FULL\n",
+	"\nMAC1_Q_FULL\n",
+	"\nCPU_Q_FULL\n",
+	"\nHNAT_Q_FULL\n",
+	"\nMAC2_Q_FULL\n",
+	"\nMAC0_Q_EXT_FULL\n",
+	"\nGLOBAL_Q_FULL\n",
+	"\nBUFFER_FULL\n",
+	"\nMIB_COUNTER_TH\n",
+	"\n",
+	"\nMAC0_INTRUDER\n",
+	"\nMAC1_INTRUDER\n",
+	"\nCPU_INTRUDER\n",
+	"\nMAC2_INTRUDER\n",
+	"\nMAC0_STATUS_CHG\n",
+	"\nMAC1_STATUS_CHG\n",
+	"\nMAC2_STATUS_CHG\n",
+	"\nMAC0_NO_LINK_DROP\n",
+	"\nMAC1_NO_LINK_DROP\n",
+	"\nMAC2_NO_LINK_DROP\n",
+	"\nMAC0_RX_ERROR_DROP\n",
+	"\nMAC1_RX_ERROR_DROP\n",
+	"\nMAC2_RX_ERROR_DROP\n",
+	"\nMAC0_NO_DESTINATION_DROP\n",
+	"\nMAC1_NO_DESTINATION_DROP\n",
+	"\nMAC2_NO_DESTINATION_DROP\n",
+	"\nMAC0_RMC_PAUSE_DROP\n",
+	"\nMAC1_RMC_PAUSE_DROP\n",
+	"\nMAC2_RMC_PAUSE_DROP\n",
+	"\nMAC0_LOCAL_DROP\n",
+	"\nMAC1_LOCAL_DROP\n",
+	"\nMAC2_LOCAL_DROP\n",
+};
+#endif
+
+#define MIN_PACKET_LEN 14
+
+static int cns3xxx_notify_reboot(
+	struct notifier_block *nb, unsigned long event, void *ptr);
+
+static struct notifier_block cns3xxx_notifier_reboot = {
+	.notifier_call	= cns3xxx_notify_reboot,
+	.next		= NULL,
+	.priority	= 0
+};
+
+void __take_off_vlan_header(struct sk_buff *skb)
+{
+	/* take off VLAN header,minus 4 byte vlan tag*/
+	memmove(skb->data + 4, skb->data, 12);
+	skb->data += 4;
+	skb->len -= 4;
+}
+
+static struct sk_buff *cns3xxx_alloc_skb(void)
+{
+	struct sk_buff *skb;
+	u32 align_64;
+	skb = dev_alloc_skb(MAX_PACKET_LEN + 2 + RX_SDP_ALIGN);
+
+	if (unlikely(!skb)) {
+		printk(KERN_ERR
+			"dev_alloc_skb fail!! while allocate RFD ring !!\n");
+		return NULL;
+	}
+
+	align_64 = CPU_CACHE_ALIGN((u32)skb->data);
+	skb_reserve(skb, align_64-(u32)skb->data);	/* 16 bytes alignment */
+
+	skb_reserve(skb, NET_IP_ALIGN);	/* 16 bytes alignment */
+
+	return skb;
+}
+
+static int free_rx_skb(struct RXRing *rx_ring)
+{
+	int i = 0;
+	struct RXBuffer *rx_buffer = rx_ring->head;
+
+	for (i = 0; i < get_rx_ring_size(rx_ring); ++i) {
+		if (rx_buffer->skb) {
+			dma_unmap_single(NULL,
+					 rx_buffer->rx_desc->sdp,
+					 rx_buffer->rx_desc->sdl,
+					 DMA_FROM_DEVICE);
+			dev_kfree_skb(rx_buffer->skb);
+			rx_buffer->skb = 0;
+		}
+		++rx_buffer;
+	}
+	return 0;
+}
+
+int cns3xxx_setup_all_rx_resources(struct RXRing *rx_ring, u8 ring_num)
+{
+	int i = 0;
+	struct RXBuffer *rx_buffer = 0;
+	struct RXDesc *rx_desc = 0;
+	dma_addr_t dmap;
+
+	/* alloc RXDesc array */
+	rx_ring->rx_desc_head_vir_addr =
+		dma_alloc_coherent(NULL,
+			sizeof(struct RXDesc) * (get_rx_ring_size(rx_ring)),
+			&rx_ring->rx_desc_head_phy_addr, GFP_KERNEL);
+	if (!rx_ring->rx_desc_head_vir_addr) {
+		printk(KERN_ERR
+			"rx_ring->rx_desc_head_vir_addr alloc memory fail!\n");
+		return -ENOMEM;
+	}
+
+	memset(rx_ring->rx_desc_head_vir_addr, 0,
+		sizeof(struct RXDesc) * get_rx_ring_size(rx_ring));
+
+	/* alloc RXBuffer array */
+	rx_ring->head =
+		kmalloc(
+			sizeof(struct RXBuffer) * get_rx_ring_size(rx_ring),
+			GFP_KERNEL);
+
+	if (!rx_ring->head) {
+		printk("rx_ring.head alloc memory fail!\n");
+		return -ENOMEM;
+	}
+
+	rx_buffer = rx_ring->head;
+	for (i = 0; i < get_rx_ring_size(rx_ring); ++i) {
+		rx_buffer->skb = 0;
+		++rx_buffer;
+	}
+
+	rx_buffer = rx_ring->head;
+	rx_desc = rx_ring->rx_desc_head_vir_addr;
+	for (i = 0; i < get_rx_ring_size(rx_ring);
+			++i, ++rx_buffer, ++rx_desc) {
+		rx_buffer->rx_desc = rx_desc;
+		rx_buffer->skb = cns3xxx_alloc_skb();
+
+		if (!rx_buffer->skb) {
+			free_rx_skb(rx_ring);
+			kfree(rx_ring->head);
+			dma_free_coherent(NULL,
+				sizeof(struct RXDesc) *
+					get_rx_ring_size(rx_ring),
+				rx_ring->rx_desc_head_vir_addr,
+				rx_ring->rx_desc_head_phy_addr);
+			printk(KERN_ERR "cannot alloc rx skb!!");
+			return -ENOMEM;
+		}
+
+		rx_buffer->rx_desc->sdl = MAX_PACKET_LEN;
+		if (i == (get_rx_ring_size(rx_ring)-1))
+			rx_buffer->rx_desc->eor = 1;
+
+		rx_buffer->rx_desc->fsd = 1;
+		rx_buffer->rx_desc->lsd = 1;
+
+		dmap = dma_map_single(NULL,
+			rx_buffer->skb->data, MAX_PACKET_LEN, DMA_FROM_DEVICE);
+		rx_buffer->rx_desc->sdp = dmap;
+	}
+
+	rx_ring->cur_index = 0 ;
+
+	if (ring_num == 0) {
+		FS_DESC_PTR0_REG = rx_ring->rx_desc_head_phy_addr;
+		FS_DESC_BASE_ADDR0_REG = rx_ring->rx_desc_head_phy_addr;
+	} else if (ring_num == 1) {
+		FS_DESC_PTR1_REG = rx_ring->rx_desc_head_phy_addr;
+		FS_DESC_BASE_ADDR1_REG = rx_ring->rx_desc_head_phy_addr;
+	}
+
+	return CAVM_OK;
+}
+
+static int cns3xxx_setup_all_tx_resources(struct TXRing *tx_ring, u8 ring_num)
+{
+	int i = 0;
+	struct TXBuffer *tx_buffer = 0;
+	struct TXDesc *tx_desc = 0;
+
+	spin_lock_init(&(tx_ring->tx_lock));
+
+	tx_ring->tx_desc_head_vir_addr =
+		dma_alloc_coherent(NULL,
+			sizeof(struct TXDesc) * get_tx_ring_size(tx_ring),
+			&tx_ring->tx_desc_head_phy_addr, GFP_KERNEL);
+
+	if (!tx_ring->tx_desc_head_vir_addr) {
+		printk(KERN_ERR
+			"tx_ring->tx_desc_head_vir_addr alloc memory fail!\n");
+		return -ENOMEM;
+	}
+
+	memset(tx_ring->tx_desc_head_vir_addr, 0,
+		sizeof(struct TXDesc) * get_tx_ring_size(tx_ring));
+	tx_ring->head = kmalloc(
+		sizeof(struct TXBuffer) * get_tx_ring_size(tx_ring),
+		GFP_KERNEL);
+
+	tx_buffer = tx_ring->head;
+	tx_desc = tx_ring->tx_desc_head_vir_addr;
+
+	for (i = 0; i < get_tx_ring_size(tx_ring);
+			++i, ++tx_buffer, ++tx_desc) {
+		tx_buffer->tx_desc = tx_desc;
+
+		tx_buffer->tx_desc->cown = 1;
+		tx_buffer->skb = 0;
+		if (i == (get_tx_ring_size(tx_ring)-1))
+			tx_buffer->tx_desc->eor = 1;
+	}
+	tx_ring->num_free_desc = get_tx_ring_size(tx_ring);
+	tx_ring->cur_index = 0 ;
+
+	if (ring_num == 0) {
+		TS_DESC_PTR0_REG = tx_ring->tx_desc_head_phy_addr;
+		TS_DESC_BASE_ADDR0_REG = tx_ring->tx_desc_head_phy_addr;
+	} else if (ring_num == 1) {
+		TS_DESC_PTR1_REG = tx_ring->tx_desc_head_phy_addr;
+		TS_DESC_BASE_ADDR1_REG = tx_ring->tx_desc_head_phy_addr;
+	}
+	return CAVM_OK;
+}
+
+int cns3xxx_free_all_rx_resources(struct RXRing *rx_ring)
+{
+	free_rx_skb(rx_ring);
+	kfree(rx_ring->head);
+	dma_free_coherent(NULL,
+		sizeof(struct RXDesc) * get_rx_ring_size(rx_ring),
+		rx_ring->rx_desc_head_vir_addr,
+		rx_ring->rx_desc_head_phy_addr);
+	return 0;
+}
+
+static int free_tx_skb(struct TXRing *tx_ring)
+{
+	int i = 0;
+	struct TXBuffer *tx_buffer = tx_ring->head;
+
+	for (i = 0; i < get_tx_ring_size(tx_ring); ++i) {
+		if (tx_buffer->skb) {
+			dma_unmap_single(NULL,
+					 tx_buffer->tx_desc->sdp,
+					 tx_buffer->tx_desc->sdl,
+					 DMA_TO_DEVICE);
+
+			dev_kfree_skb(tx_buffer->skb);
+			tx_buffer->skb = 0;
+		}
+		++tx_buffer;
+	}
+	return 0;
+}
+
+int cns3xxx_free_all_tx_resources(struct TXRing *tx_ring)
+{
+	free_tx_skb(tx_ring);
+	kfree(tx_ring->head);
+	dma_free_coherent(NULL,
+		sizeof(struct TXDesc) * get_tx_ring_size(tx_ring),
+		tx_ring->tx_desc_head_vir_addr, tx_ring->tx_desc_head_phy_addr);
+	return 0;
+}
+
+static int cns3xxx_free_rx_tx_res(struct CNS3XXXPrivate *priv)
+{
+	int i = 0;
+
+	--rc_setup_rx_tx;
+	if (rc_setup_rx_tx == 0) {
+		printk(KERN_INFO "free tx/rx resource\n");
+		enable_port(3, 0); /* disable cpu port */
+
+		for (i = 0 ; i < priv->num_rx_queues ; ++i) {
+			/* stop RX dma */
+			enable_rx_dma(i, 0);
+			cns3xxx_free_all_rx_resources(priv->rx_ring+i);
+			memset(priv->rx_ring + i, 0, sizeof(struct RXRing));
+		}
+
+		for (i = 0; i < priv->num_tx_queues; ++i) {
+			/* stop TX dma*/
+			enable_tx_dma(i, 0);
+			cns3xxx_free_all_tx_resources(priv->tx_ring+i);
+			memset(priv->tx_ring + i, 0, sizeof(struct TXRing));
+		}
+	}
+	return 0;
+}
+
+
+static int cns3xxx_setup_rx_tx_res(struct CNS3XXXPrivate *priv)
+{
+	int i = 0;
+
+	if (rc_setup_rx_tx == 0) {
+		printk(KERN_INFO "alloc tx/rx resource\n");
+		clear_fs_dma_state(1);
+		FS_DESC_PTR0_REG = 0;
+		FS_DESC_BASE_ADDR0_REG = 0;
+		FS_DESC_PTR1_REG = 0;
+		FS_DESC_BASE_ADDR1_REG = 0;
+		TS_DESC_PTR0_REG = 0;
+		TS_DESC_BASE_ADDR0_REG = 0;
+		TS_DESC_PTR1_REG = 0;
+		TS_DESC_BASE_ADDR1_REG = 0;
+
+		for (i = 0; i < priv->num_tx_queues; ++i) {
+			spin_lock_init(&((priv->tx_ring+i)->tx_lock));
+			(priv->tx_ring+i)->max_ring_size = MAX_TX_DESC_SIZE;
+			(priv->tx_ring+i)->ring_size = TX_DESC_SIZE;
+			if (cns3xxx_setup_all_tx_resources(priv->tx_ring+i, i)
+				!= CAVM_OK)
+				return CAVM_ERR;
+		}
+
+		for (i = 0; i < priv->num_rx_queues; ++i) {
+			(priv->rx_ring+i)->max_ring_size = MAX_RX_DESC_SIZE;
+			(priv->rx_ring+i)->ring_size = RX_DESC_SIZE;
+			if (cns3xxx_setup_all_rx_resources(priv->rx_ring+i, i)
+				!= CAVM_OK)
+				return CAVM_ERR;
+		}
+		clear_fs_dma_state(0);
+	}
+	++rc_setup_rx_tx;
+	return CAVM_OK;
+}
+
+static int free_tx_desc_skb(struct TXRing *tx_ring, u8 ring_num)
+{
+	int i;
+	struct TXBuffer *tx_buffer;
+	u32 tx_ring_size = get_tx_ring_size(tx_ring);
+	/* check curent hw index previous tx descriptor */
+	u32 cur_index = cns3xxx_get_tx_hw_index(ring_num) - 1;
+	struct TXDesc *tx_desc_ptr;
+
+	tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+
+	for (i = 0; i < tx_ring_size; ++i) {
+		if (tx_buffer->tx_desc->cown == 1 && tx_buffer->skb) {
+			tx_desc_ptr = tx_buffer->tx_desc;
+			dma_unmap_single(NULL,
+					 tx_desc_ptr->sdp,
+					 tx_desc_ptr->sdl,
+					 DMA_TO_DEVICE);
+			dev_kfree_skb_any(tx_buffer->skb);
+			tx_buffer->skb = 0;
+			tx_ring->num_free_desc++;
+		} else {
+			break;
+		}
+		--cur_index;
+		tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+	}
+	return 0;
+}
+
+void assign_netdev(volatile struct RXBuffer *rx_buffer)
+{
+	struct RXDesc *rx_desc = 0;
+	rx_desc = rx_buffer->rx_desc;
+
+	if (is_config_cns3xxx_port_base()) {
+		switch (rx_desc->sp) {
+		case 0:
+			rx_buffer->skb->dev = PORT0_NETDEV;
+			break;
+		case 1:
+			rx_buffer->skb->dev = PORT1_NETDEV;
+			break;
+		case 4:
+			rx_buffer->skb->dev = PORT2_NETDEV;
+			break;
+		}
+	}
+
+	if (is_config_cns3xxx_vlan_base()) {
+		u16 vlan_tag;
+
+		vlan_tag = rx_desc->c_vid;
+		rx_buffer->skb->dev = net_dev_array[vlan_tag];
+	}
+}
+
+/* old_priv has ring index information,
+ * current version only uses the information.
+ */
+static int cns3xxx_get_rfd_buff(
+	struct RXDesc *rx_desc, volatile struct RXBuffer *rx_buffer,
+	struct CNS3XXXPrivate *old_priv)
+{
+	struct CNS3XXXPrivate *priv = 0;
+	struct sk_buff *skb;
+	u32 len;
+
+	skb = rx_buffer->skb;
+	len = rx_desc->sdl;
+
+	dma_unmap_single(NULL,
+		 rx_desc->sdp,
+		 rx_desc->sdl,
+		 DMA_FROM_DEVICE);
+
+	if (is_cns3xxx_non_nic_mode_8021q()) {
+		if (cns3xxx_is_untag_packet(rx_desc) == 1)
+			__take_off_vlan_header(skb);
+	}
+
+	if (is_config_cns3xxx_port_base()) {
+		assign_netdev(rx_buffer);
+
+		if (rx_buffer->skb->dev)
+			/* if skb->dev is 0, means VLAN base*/
+			goto determine_dev_ok;
+	}
+
+	if (is_config_cns3xxx_vlan_base()) {
+		if (is_config_have_vlan_tag()) {
+			assign_netdev(rx_buffer);
+
+			__take_off_vlan_header(skb);
+			if (MSG_LEVEL == 5)
+				print_packet(skb->data, 32);
+
+			if (rx_buffer->skb->dev == 0)
+				goto freepacket;
+		}
+	}
+
+determine_dev_ok:
+	skb_put(skb, len);
+	if (skb->dev)
+		priv = netdev_priv(skb->dev);
+	else {
+		DEBUG_MSG(WARNING_MSG, "skb_ptr->dev==NULL\n");
+		goto freepacket;
+	}
+
+#ifdef CNS3XXX_RX_HW_CHECKSUM
+	switch (rx_desc->prot) {
+	case 1:
+	case 2:
+	case 5:
+	case 6:
+		if (rx_desc->l4f == 0)
+			/* tcp/udp checksum is correct */
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			skb->ip_summed = CHECKSUM_NONE;
+		break;
+	default:
+		skb->ip_summed = CHECKSUM_NONE;
+		break;
+	}
+#else
+	skb->ip_summed = CHECKSUM_NONE;
+#endif
+
+	/* this line must, if no,
+	 * packet will not send to network layer
+	 */
+	skb->protocol = eth_type_trans(skb, skb->dev);
+
+	skb->dev->last_rx = jiffies;
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+#ifdef CONFIG_CNS3XXX_NAPI
+	netif_receive_skb(skb);
+#else
+	netif_rx(skb);
+#endif
+	return 0;
+
+freepacket:
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+/* index from 1 */
+u32 get_rx_hw_index(struct CNS3XXXPrivate *priv)
+{
+	return (FS_DESC_PTR0_REG - get_rx_head_phy_addr(&RX_RING0(priv))) /
+		sizeof(struct RXDesc);
+}
+
+int get_rx_hw_index_by_reg(u8 ring_num)
+{
+	if (ring_num == 0)
+		return (FS_DESC_PTR0_REG - FS_DESC_BASE_ADDR0_REG) /
+			sizeof(struct RXDesc);
+	else if (ring_num == 1)
+		return (FS_DESC_PTR1_REG - FS_DESC_BASE_ADDR1_REG) /
+			sizeof(struct RXDesc);
+	return CAVM_FAIL;
+}
+
+#ifdef CONFIG_CNS3XXX_NAPI
+void cns3xxx_receive_packet(
+	struct CNS3XXXPrivate *priv, int mode, int *work_done, int work_to_do)
+#else
+void cns3xxx_receive_packet(struct CNS3XXXPrivate *priv, int mode)
+#endif
+{
+	register int fssd_index;
+	register struct RXBuffer volatile *rx_buffer = 0;
+	register struct RXDesc volatile *rx_desc = 0;
+	register struct sk_buff *skb;
+#ifndef CONFIG_CNS3XXX_NAPI
+	register int fsqf = 0; /* Queue Full Mode =0 */
+#endif
+	register int i, rxcount = 0;
+	register u8 queue_index = priv->ring_index;
+	register dma_addr_t dmap;
+
+	register volatile struct RXDesc *rx_desc_ori_ptr = 0;
+	volatile struct RXDesc rx_desc_tmp;
+
+	rx_buffer = get_cur_rx_buffer(&(priv->rx_ring[queue_index]));
+	rx_desc = rx_buffer->rx_desc;
+
+	fssd_index = get_rx_hw_index_by_reg(queue_index);
+
+	if (fssd_index > get_rx_cur_index(&priv->rx_ring[queue_index]))
+		rxcount = fssd_index -
+			get_rx_cur_index(&priv->rx_ring[queue_index]);
+	else if (fssd_index < get_rx_cur_index(&priv->rx_ring[queue_index]))
+		rxcount = (get_rx_ring_size(&priv->rx_ring[queue_index]) -
+			get_rx_cur_index(&priv->rx_ring[queue_index])) +
+			fssd_index;
+	else {
+		if (rx_desc->cown == 0) {
+			/* if rx_desc->cown is 1,
+			 * we can receive the RX descriptor.
+			 */
+			enable_rx_dma(0, 1);
+			goto receive_packet_exit;
+		} else {
+			/* Queue Full*/
+#ifndef CONFIG_CNS3XXX_NAPI
+			fsqf = 1;
+#endif
+			rxcount = get_rx_ring_size(&priv->rx_ring[queue_index]);
+		}
+	}
+
+#ifndef CONFIG_CNS3XXX_NAPI
+	if (mode == 1) {
+		fsqf = 1;
+		rxcount = get_rx_ring_size(&priv->rx_ring[queue_index]);
+	}
+#endif
+
+#ifdef CNS3XXX_FREE_TX_IN_RX_PATH
+	free_tx_desc_skb(priv->tx_ring + 0, 0);
+#ifdef CNS3XXX_DOUBLE_TX_RING
+	free_tx_desc_skb(priv->tx_ring + 1, 1);
+#endif
+#endif
+
+	for (i = 0; i < rxcount; i++) {
+		if (rx_desc->cown != 0) {
+			/* start to get packet
+			 * Alloc New skb_buff*/
+			skb = cns3xxx_alloc_skb();
+			/* Check skb_buff*/
+			if (skb) {
+				rx_desc_ori_ptr = rx_desc;
+				rx_desc = &rx_desc_tmp;
+				rx_desc_tmp = *rx_desc_ori_ptr;
+
+				cns3xxx_get_rfd_buff(
+					(struct RXDesc *)rx_desc,
+					rx_buffer, priv);
+
+				rx_buffer->skb = skb;
+
+				dmap = dma_map_single(NULL, skb->data,
+					MAX_PACKET_LEN, DMA_FROM_DEVICE);
+
+				rx_desc->sdp = dmap;
+				rx_desc->sdl = MAX_PACKET_LEN;
+				rx_desc->fsd = 1;
+				rx_desc->lsd = 1;
+
+				*rx_desc_ori_ptr = rx_desc_tmp;
+				rx_desc = rx_desc_ori_ptr;
+
+				rx_desc->cown = 0; /* set cbit to 0*/
+
+#ifdef CONFIG_CNS3XXX_NAPI
+				++(*work_done);
+				if (*work_done >= work_to_do) {
+					rx_index_next(
+						&priv->rx_ring[queue_index]);
+					/*rx_ring.cur_index points to next*/
+					rx_buffer = get_cur_rx_buffer(
+						&priv->rx_ring[queue_index]);
+					rx_desc = rx_buffer->rx_desc;
+					break;
+				}
+#endif
+			} else {
+				printk(KERN_ERR
+					"%s: Alloc sk_buf fail, reuse buffer\n",
+					__func__);
+				rx_desc->cown = 0; /* set cbit to 0*/
+				return;
+			}
+		} else  /* cown is 0, no packets */
+			return;
+
+		rx_index_next(&priv->rx_ring[queue_index]);
+		/* rx_ring.cur_index points to next*/
+		rx_buffer = get_cur_rx_buffer(&priv->rx_ring[queue_index]);
+		rx_desc = rx_buffer->rx_desc;
+	} /* end for (i = 0; i < rxcount; i++) */
+
+#ifndef CONFIG_CNS3XXX_NAPI
+	if (fsqf) {
+		priv->rx_ring[queue_index].cur_index = fssd_index;
+		mb();
+		enable_rx_dma(0, 1);
+	}
+#endif
+
+receive_packet_exit:
+	return;
+}
+
+irqreturn_t cns3xxx_fsrc_ring0_isr(int irq, void *dev_id)
+{
+#ifdef CONFIG_CNS3XXX_NAPI
+	struct CNS3XXXPrivate *priv = netdev_priv(napi_dev);
+	priv->ring_index = 0;
+
+	cns3xxx_disable_irq(FSRC_RING0_INTERRUPT_ID);
+
+	if (likely(napi_schedule_prep(&priv->napi)))
+		__napi_schedule(&priv->napi);
+	else
+		cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
+
+#else
+	struct net_device *netdev = dev_id;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	priv->ring_index = 0;
+
+	cns3xxx_disable_irq(FSRC_RING0_INTERRUPT_ID);
+	cns3xxx_disable_irq(FSQF_RING0_INTERRUPT_ID);
+
+	cns3xxx_receive_packet(priv, 0); /* Receive Once*/
+
+	cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
+	cns3xxx_enable_irq(FSQF_RING0_INTERRUPT_ID);
+
+	enable_rx_dma(0, 1);
+#endif
+	return IRQ_HANDLED;
+}
+
+#if defined(CNS3XXX_DOUBLE_RX_RING)
+irqreturn_t cns3xxx_fsrc_ring1_isr(int irq, void *dev_id)
+{
+#if defined(CONFIG_CNS3XXX_NAPI) && defined(CNS3XXX_DOUBLE_RX_RING)
+	struct CNS3XXXPrivate *priv = netdev_priv(r1_napi_dev);
+	priv->ring_index = 1;
+
+	cns3xxx_disable_irq(FSRC_RING1_INTERRUPT_ID);
+
+	if (likely(napi_schedule_prep(&priv->napi)))
+		__napi_schedule(&priv->napi);
+	else
+		cns3xxx_enable_irq(FSRC_RING1_INTERRUPT_ID);
+#else
+	struct net_device *netdev = dev_id;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+	priv->ring_index = 1;
+
+	cns3xxx_disable_irq(CNS3XXX_FSRC_RING1_INTERRUPT_ID);
+	cns3xxx_disable_irq(CNS3XXX_FSQF_RING1_INTERRUPT_ID);
+	cns3xxx_receive_packet(priv, 0); /* Receive Once */
+	enable_rx_dma(1, 1);
+
+	cns3xxx_enable_irq(CNS3XXX_FSRC_RING1_INTERRUPT_ID);
+	cns3xxx_enable_irq(CNS3XXX_FSQF_RING1_INTERRUPT_ID);
+#endif
+	return IRQ_HANDLED;
+}
+#endif
+
+static int cns3xxx_check_enough_tx_descriptor(
+	struct TXRing *tx_ring, int need_free_tx_desc)
+{
+	int i = 0;
+	struct TXDesc *tx_desc = 0;
+	u32 cur_index = get_tx_cur_index(tx_ring);
+	struct TXBuffer *tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+
+	tx_desc = tx_buffer->tx_desc;
+
+	for (i = 0; i < need_free_tx_desc; ++i) {
+		if (tx_desc->cown == 0)
+			return 0; /* no free TX descriptor*/
+
+		tx_buffer = get_tx_buffer_by_index(tx_ring, ++cur_index);
+		tx_desc = tx_buffer->tx_desc;
+	}
+
+	return 1;
+}
+
+/* if return CAVM_ERR, means pad is fail, the packet cannot send by switch.*/
+static int fill_a_skb_to_tx_desc(
+	struct TXBuffer *tx_buffer, u8 *data, int len, struct sk_buff *skb,
+	const struct CNS3XXXPrivate *priv, int sg, int fsd, int lsd)
+{
+	register dma_addr_t dmap;
+	register struct TXRing *tx_ring;
+
+	register struct TXDesc *tx_desc_ptr = 0;
+	register struct TXDesc *tx_desc_ori_ptr = 0;
+	struct TXDesc tx_desc_tmp;
+
+	tx_desc_ptr = tx_buffer->tx_desc;
+
+	tx_desc_ori_ptr = tx_desc_ptr;
+	tx_desc_ptr = &tx_desc_tmp;
+	tx_desc_tmp = *tx_desc_ori_ptr;
+
+
+	if (tx_buffer->skb) {
+		dma_unmap_single(NULL,
+				tx_desc_ptr->sdp,
+				tx_desc_ptr->sdl,
+				DMA_TO_DEVICE);
+		dev_kfree_skb_any(tx_buffer->skb);
+		tx_buffer->skb = 0 ;
+	}
+
+	tx_buffer->skb = skb;  /* for free skb */
+	tx_buffer->tx_index = cns3xxx_get_tx_hw_index(0);
+
+#ifdef CNS3XXX_TX_HW_CHECKSUM
+	tx_desc_ptr->ico = 1;
+	tx_desc_ptr->uco = 1;
+	tx_desc_ptr->tco = 1;
+#else
+	tx_desc_ptr->ico = 0;
+	tx_desc_ptr->uco = 0;
+	tx_desc_ptr->tco = 0;
+#endif
+	/* Wake interrupt */
+#ifdef CNS3XXX_TSTC_RING0_ISR
+	tx_desc_ptr->interrupt = 1;
+#else
+	tx_desc_ptr->interrupt = 0;
+#endif
+
+	/* fill 0 to MIN_PACKET_LEN size
+	 * can change MIN_PACKET_LEN to 14
+	 */
+	if (sg == 0 && len < MIN_PACKET_LEN) {
+		if (skb_padto(skb, MIN_PACKET_LEN)) {
+			printk(KERN_ERR "padding skb error.\n");
+			return CAVM_ERR;
+		}
+		tx_desc_ptr->sdl = MIN_PACKET_LEN;
+	} else {
+		tx_desc_ptr->sdl = len;
+	}
+
+	dmap = dma_map_single(NULL, data, len, DMA_TO_DEVICE);
+	tx_desc_ptr->sdp = dmap;
+
+	/* VLAN base or port base function to set TX descriptor */
+	/* reference: tx_//port_base(), tx_vlan_base() */
+	priv->net_device_priv->tx_func(tx_desc_ptr, priv, skb);
+	tx_desc_ptr->fsd = fsd;
+	tx_desc_ptr->lsd = lsd;
+
+	*tx_desc_ori_ptr = tx_desc_tmp;
+	tx_desc_ptr = tx_desc_ori_ptr;
+
+	/* NOT SG packet */
+	if (!sg)
+		tx_desc_ptr->cown = 0;
+
+	tx_ring = priv->tx_ring + ring_index;
+
+	if (tx_ring->num_free_desc)
+		tx_ring->num_free_desc--;
+
+	return CAVM_OK;
+}
+
+int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev)
+{
+	register struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+	register struct TXBuffer *tx_buffer = 0;
+	register unsigned long flags;
+
+	register int nr_frags = skb_shinfo(skb)->nr_frags;
+	struct TXDesc *tx_desc[10];
+	register int tx_desc_count = 0;
+	register int i = 0;
+
+	spin_lock_irqsave(&tx_lock, flags);
+
+	if (cns3xxx_check_enough_tx_descriptor(priv->tx_ring + ring_index,
+			(nr_frags == 0) ? 1 : nr_frags) == 0) {
+		/* no enough tx descriptor */
+		spin_unlock_irqrestore(&tx_lock, flags);
+		/* re-queue the skb */
+		return NETDEV_TX_BUSY;
+	}
+	tx_buffer = get_cur_tx_buffer(priv->tx_ring + ring_index);
+
+	if (nr_frags == 0) { /* non scatter/gather I/O */
+		fill_a_skb_to_tx_desc(tx_buffer, skb->data,
+			skb->len, skb, priv, 0, 1, 1);
+		tx_index_next(priv->tx_ring + ring_index);
+	} else { /* scatter/gather I/O */
+		struct skb_frag_struct *frag = 0;
+
+		fill_a_skb_to_tx_desc(tx_buffer, skb->data,
+			skb->len - skb->data_len, 0, priv, 1, 1, 0);
+		tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
+		tx_index_next(priv->tx_ring + ring_index);
+		tx_buffer = get_cur_tx_buffer(priv->tx_ring + ring_index);
+
+		for (i = 0; i < nr_frags - 1 ; ++i) {
+			frag = &skb_shinfo(skb)->frags[i];
+
+			fill_a_skb_to_tx_desc(tx_buffer,
+				page_address(frag->page) + frag->page_offset,
+				frag->size, 0, priv, 1, 0, 0);
+			tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
+
+			tx_index_next(priv->tx_ring + ring_index);
+			tx_buffer =
+				get_cur_tx_buffer(priv->tx_ring + ring_index);
+		}
+		frag = &skb_shinfo(skb)->frags[nr_frags-1];
+
+		/* last fragment */
+		fill_a_skb_to_tx_desc(tx_buffer,
+			page_address(frag->page) + frag->page_offset,
+			frag->size, skb, priv, 1, 0, 1);
+		tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
+
+		tx_index_next(priv->tx_ring + ring_index);
+		tx_buffer = get_cur_tx_buffer(priv->tx_ring + ring_index);
+
+		for (i = 0; i < tx_desc_count ; i++)
+			tx_desc[i]->cown = 0 ;
+	}
+
+	mb();
+
+	enable_tx_dma(ring_index, 1);
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	netdev->trans_start = jiffies;
+
+	spin_unlock_irqrestore(&tx_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+#ifdef CNS3XXX_FSQF_RING0_ISR
+irqreturn_t cns3xxx_fsqf_ring0_isr(int irq, void *dev_id)
+{
+#ifndef CONFIG_CNS3XXX_NAPI
+	struct net_device *netdev = dev_id;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+#endif
+
+#ifdef CONFIG_CNS3XXX_NAPI
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(napi_dev);
+	/* because in normal state,
+	 * fsqf only invoke once and set_bit is atomic function.
+	 * so don't mask it.
+	 */
+	set_bit(0, &priv->is_qf);
+}
+#else
+	cns3xxx_disable_irq(FSRC_RING0_INTERRUPT_ID);
+	cns3xxx_disable_irq(FSQF_RING0_INTERRUPT_ID);
+
+	cns3xxx_receive_packet(priv, 1); /* Receive at Queue Full Mode*/
+
+	cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
+	cns3xxx_enable_irq(FSQF_RING0_INTERRUPT_ID);
+
+	enable_rx_dma(0, 1);
+#endif
+	return IRQ_HANDLED;
+}
+#endif
+
+#if defined(CNS3XXX_DOUBLE_RX_RING)
+#ifdef CNS3XXX_FSQF_RING1_ISR
+irqreturn_t cns3xxx_fsqf_ring1_isr(int irq, void *dev_id)
+{
+	struct net_device *netdev = dev_id;
+	struct CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+#ifdef CONFIG_CNS3XXX_NAPI
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(r1_napi_dev);
+	/* because in normal state,
+	 * fsqf only invoke once and set_bit is atomic function.
+	 * so don't mask it.
+	 */
+	set_bit(0, &priv->is_qf);
+}
+#else
+	cns3xxx_disable_irq(FSRC_RING1_INTERRUPT_ID);
+	cns3xxx_disable_irq(FSQF_RING1_INTERRUPT_ID);
+
+	cns3xxx_receive_packet(priv, 1); /* Receive at Queue Full Mode*/
+	enable_rx_dma(1, 1);
+
+	cns3xxx_enable_irq(FSRC_RING1_INTERRUPT_ID);
+	cns3xxx_enable_irq(FSQF_RING1_INTERRUPT_ID);
+#endif
+	return IRQ_HANDLED;
+}
+#endif
+#endif
+
+
+#ifdef CNS3XXX_STATUS_ISR
+irqreturn_t cns3xxx_status_isr(int irq, void *dev_id)
+{
+	u32 int_status = INTR_STAT_REG;
+	u32 i = 0;
+
+	cns3xxx_disable_irq(STATUS_INTERRUPT_ID);
+#ifdef CNS3XXX_SHOW_LINK_STATUS
+	for (i = 14; i <= 16 ; ++i) {
+		u32 cfg = 0;
+		u8 mac_cfg[] = {0xc, 0x10, 0x18};
+		u32 reg;
+
+		if (((int_status >> i) & 1)) {
+			if ((SWITCH_REG_VALUE(mac_cfg[i-14]) & 1)) {
+				/* GMII2 high speed drive strength*/
+				reg = __raw_readl(MISC_IO_PAD_DRIVE_STRENGTH_CTRL_A);
+				reg &= (~(3 << 10));
+
+				if (((SWITCH_REG_VALUE(mac_cfg[i-14]) >> 2)
+						&0x3) == 2)
+					reg |= (2 << 10);/* 1000 Mbps*/
+				__raw_writel(MISC_IO_PAD_DRIVE_STRENGTH_CTRL_A);
+			}
+		}
+	}
+#else
+	for (i = 0; i < 32; i++) {
+		if (int_status & (1 << i))
+			PRINT_INFO(cns3xxx_gsw_status_tbl[i]);
+	}
+#endif
+	INTR_STAT_REG = 0xffffffff;
+	cns3xxx_enable_irq(STATUS_INTERRUPT_ID);
+	return IRQ_HANDLED;
+}
+#endif
+
+
+#ifdef CNS3XXX_TSTC_RING0_ISR
+irqreturn_t cns3xxx_tstc_ring0_isr(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+static int cns3xxx_install_isr(struct net_device *dev)
+{
+	int retval;
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+
+	if (install_isr_rc == 0) {
+		printk(KERN_INFO
+			"request FSRC_RING0_INTERRUPT_ID %d\n",
+			FSRC_RING0_INTERRUPT_ID);
+		retval = request_irq(FSRC_RING0_INTERRUPT_ID,
+			cns3xxx_fsrc_ring0_isr, IRQF_SHARED,
+			"FSRC_RING0", intr_netdev);
+
+		if (retval) {
+			printk(KERN_ERR "%s: unable to get IRQ %d (irqval=%d).\n",
+				"FSRC_RING0", FSRC_RING0_INTERRUPT_ID, retval);
+			return 1;
+		}
+
+#ifdef CNS3XXX_FSQF_RING0_ISR
+		printk(KERN_INFO "request FSQF_RING0_INTERRUPT_ID %d\n",
+			FSQF_RING0_INTERRUPT_ID);
+		retval = request_irq(FSQF_RING0_INTERRUPT_ID,
+			cns3xxx_fsqf_ring0_isr, IRQF_SHARED,
+			"FSQF_RING0", intr_netdev);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n",
+				"FSQF_RING0", FSQF_RING0_INTERRUPT_ID, retval);
+			return 2;
+		}
+#endif
+
+#ifdef CNS3XXX_TSTC_RING0_ISR
+		printk(KERN_INFO "request TSTC_RING0_INTERRUPT_ID %d\n",
+			TSTC_RING0_INTERRUPT_ID);
+		retval = request_irq(TSTC_RING0_INTERRUPT_ID,
+			cns3xxx_tstc_ring0_isr, IRQF_SHARED,
+			"TSTC_RING0", intr_netdev);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n",
+				"TSTC_RING0", FSQF_RING0_INTERRUPT_ID, retval);
+			return 3;
+		}
+#endif
+
+	if (priv->num_rx_queues == 2) {
+#if defined(CNS3XXX_DOUBLE_RX_RING)
+		printk(KERN_INFO "request FSRC_RING1_INTERRUPT_ID %d\n",
+		FSRC_RING1_INTERRUPT_ID);
+		retval = request_irq(FSRC_RING1_INTERRUPT_ID,
+			cns3xxx_fsrc_ring1_isr, IRQF_SHARED,
+			"FSRC_RING1", intr_netdev);
+
+		if (retval) {
+			printk(KERN_INFO
+				"%s: unable to get IRQ %d (irqval=%d).\n",
+				"FSRC_RING1", FSRC_RING1_INTERRUPT_ID, retval);
+			return 1;
+		}
+
+#ifdef CNS3XXX_FSQF_RING1_ISR
+		printk(KERN_INFO "request FSQF_RING1_INTERRUPT_ID %d\n",
+			FSQF_RING1_INTERRUPT_ID);
+		retval = request_irq(FSQF_RING1_INTERRUPT_ID,
+			cns3xxx_fsqf_ring1_isr, IRQF_SHARED,
+			"FSQF_RING1", intr_netdev);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n",
+				"FSQF_RING1", FSQF_RING1_INTERRUPT_ID, retval);
+			return 2;
+		}
+#endif
+
+#endif
+	}
+
+#ifdef CNS3XXX_STATUS_ISR
+#ifdef CNS3XXX_SHOW_LINK_STATUS
+
+	INTR_MASK_REG = 0xffffffff;
+	/* only enable mac link status */
+	INTR_MASK_REG &= (~(1 << 14));
+	INTR_MASK_REG &= (~(1 << 15));
+	INTR_MASK_REG &= (~(1 << 16));
+
+#endif
+	printk(KERN_ERR "request STATUS_INTERRUPT_ID %d\n",
+		STATUS_INTERRUPT_ID);
+	retval = request_irq(STATUS_INTERRUPT_ID,
+		cns3xxx_status_isr, IRQF_SHARED, "GSW_STATUS", intr_netdev);
+
+	if (retval) {
+		PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n",
+			"GSW STATUS INT", STATUS_INTERRUPT_ID, retval);
+		return 3;
+	}
+	INTR_MASK_REG = 0;
+#endif
+
+#ifdef CONFIG_CNS3XXX_NAPI
+{
+	struct CNS3XXXPrivate *sp = netdev_priv(napi_dev);
+	napi_enable(&sp->napi);
+	netif_start_queue(napi_dev);
+
+#ifdef CNS3XXX_DOUBLE_RX_RING
+	sp = netdev_priv(r1_napi_dev);
+	napi_enable(&sp->napi);
+	netif_start_queue(r1_napi_dev);
+#endif
+}
+#endif
+	/* enable cpu port */
+	enable_port(3, 1);
+
+	} /* end if (install_isr_rc == 0)*/
+
+	++install_isr_rc;
+
+	return 0;
+}
+
+int cns3xxx_open(struct net_device *dev)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+	if (cns3xxx_setup_rx_tx_res(priv) != CAVM_OK) {
+		printk(KERN_ERR "alloc rx/tx ring fail!!\n");
+		return -1;
+	}
+
+	netif_start_queue(dev);
+
+	cns3xxx_install_isr(dev);
+
+	enable_rx_dma(0, 1);
+
+	if (priv->num_rx_queues == 2)
+		enable_rx_dma(1, 1);
+
+	netif_carrier_on(dev);
+	priv->net_device_priv->open();
+
+	return 0;
+}
+
+static int cns3xxx_uninstall_isr(struct net_device *dev)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+	--install_isr_rc;
+	if (install_isr_rc == 0) {
+		enable_port(3, 0);
+		free_irq(FSRC_RING0_INTERRUPT_ID, intr_netdev);
+#ifdef CNS3XXX_STATUS_ISR
+		free_irq(STATUS_INTERRUPT_ID, intr_netdev);
+#endif
+
+#ifdef CNS3XXX_FSQF_RING0_ISR
+		free_irq(FSQF_RING0_INTERRUPT_ID, intr_netdev);
+#endif
+
+#ifdef CNS3XXX_TSTC_RING0_ISR
+		free_irq(TSTC_RING0_INTERRUPT_ID, intr_netdev);
+#endif
+
+	if (priv->num_rx_queues == 2) {
+		free_irq(FSRC_RING1_INTERRUPT_ID, intr_netdev);
+
+#ifdef CNS3XXX_FSQF_RING1_ISR
+		free_irq(FSQF_RING1_INTERRUPT_ID, intr_netdev);
+#endif
+	}
+
+#ifdef CONFIG_CNS3XXX_NAPI
+{
+	struct CNS3XXXPrivate *sp = netdev_priv(napi_dev);
+
+	napi_disable(&sp->napi);
+	netif_stop_queue(napi_dev);
+#ifdef CNS3XXX_DOUBLE_RX_RING
+	sp = netdev_priv(r1_napi_dev);
+
+	napi_disable(&sp->napi);
+	netif_stop_queue(r1_napi_dev);
+#endif
+}
+#endif
+	}
+
+	return 0;
+}
+
+int cns3xxx_close(struct net_device *dev)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+
+	enable_rx_dma(0, 0);
+	enable_tx_dma(0, 0);
+
+	if (priv->num_rx_queues == 2)
+		enable_tx_dma(1, 0);
+
+	if (priv->num_tx_queues == 2)
+		enable_rx_dma(1, 0);
+
+	netif_stop_queue(dev);
+
+	priv->net_device_priv->close();
+	cns3xxx_uninstall_isr(dev);
+	cns3xxx_free_rx_tx_res(priv);
+	netif_carrier_off(dev);
+	return 0;
+}
+
+void broadcast_storm_cfg(u8 port, u8 boradcast, u8 multicast, u8 unknown)
+{
+	switch (port) {
+	case 0:
+		(boradcast == 1) ?
+			(MAC0_CFG_REG |= (1 << 30)) :
+			(MAC0_CFG_REG &= (~(1 << 30))) ;
+		(multicast == 1) ?
+			(MAC0_CFG_REG |= (1 << 29)) :
+			(MAC0_CFG_REG &= (~(1 << 29))) ;
+		(unknown == 1) ?
+			(MAC0_CFG_REG |= (1 << 28)) :
+			(MAC0_CFG_REG &= (~(1 << 28))) ;
+		break;
+	case 1:
+		(boradcast == 1) ?
+			(MAC1_CFG_REG |= (1 << 30)) :
+			(MAC1_CFG_REG &= (~(1 << 30))) ;
+		(multicast == 1) ?
+			(MAC1_CFG_REG |= (1 << 29)) :
+			(MAC1_CFG_REG &= (~(1 << 29))) ;
+		(unknown == 1) ?
+			(MAC1_CFG_REG |= (1 << 28)) :
+			(MAC1_CFG_REG &= (~(1 << 28))) ;
+		break;
+	case 2:
+		(boradcast == 1) ?
+			(MAC2_CFG_REG |= (1 << 30)) :
+			(MAC2_CFG_REG &= (~(1 << 30))) ;
+		(multicast == 1) ?
+			(MAC2_CFG_REG |= (1 << 29)) :
+			(MAC2_CFG_REG &= (~(1 << 29))) ;
+		(unknown == 1) ?
+			(MAC2_CFG_REG |= (1 << 28)) :
+			(MAC2_CFG_REG &= (~(1 << 28))) ;
+		break;
+	}
+}
+
+void broadcast_storm_rate(u8 rate)
+{
+	TC_CTRL_REG &= (~(0xf << 24));
+	TC_CTRL_REG |= (rate << 24);
+}
+
+static int cns3xxx_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+
+	struct sockaddr *addr = p;
+
+	spin_lock_irq(&priv->lock);
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	/* 1. delete old arl mac entry
+	 * 2. add new arl mac entry
+	 * 3. copy new mac to netdev field
+	 */
+	if (priv->net_device_priv->arl_table_entry) {
+		cns3xxx_arl_table_invalid(
+			priv->net_device_priv->arl_table_entry);
+		memcpy(priv->net_device_priv->arl_table_entry->mac,
+			addr->sa_data, dev->addr_len);
+		cns3xxx_arl_table_add(priv->net_device_priv->arl_table_entry);
+	}
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	spin_unlock_irq(&priv->lock);
+	return 0;
+}
+
+
+int set_fc_rls(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	FC_GLOB_THRS_REG &= (~(0x1ff << 16));
+	FC_GLOB_THRS_REG |= (ctl.val << 16);
+	return CAVM_OK;
+}
+
+int get_fc_rls(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	ctl.val = ((FC_GLOB_THRS_REG >> 16) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_fc_set(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	FC_GLOB_THRS_REG &= (~0x1ff);
+	FC_GLOB_THRS_REG |= ctl.val;
+	return CAVM_OK;
+}
+
+int get_fc_set(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	ctl.val = ((FC_GLOB_THRS_REG) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+
+int set_sarl_rls(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	SARL_CTRL_REG &= (~(0x1ff << 12));
+	SARL_CTRL_REG |= (ctl.val << 12);
+	return CAVM_OK;
+}
+
+int get_sarl_rls(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	ctl.val = ((SARL_CTRL_REG >> 12) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_sarl_enable(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	SARL_CTRL_REG &= (~(0x1 << 31));
+	SARL_CTRL_REG |= (ctl.val << 31);
+	return CAVM_OK;
+}
+
+int get_sarl_enable(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	ctl.val = ((SARL_CTRL_REG >> 31) & 0x1);
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+int set_sarl_set(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	SARL_CTRL_REG &= (~0x1ff);
+	SARL_CTRL_REG |= ctl.val;
+	return CAVM_OK;
+}
+
+int get_sarl_set(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	ctl.val = ((SARL_CTRL_REG) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_sarl_oq(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	switch (ctl.gyr) {
+	case 0: /* green*/
+		SARL_OQ_GTH_REG &= (~(0xff << ctl.tc*8));
+		SARL_OQ_GTH_REG |= (ctl.val << ctl.tc*8);
+		break;
+	case 1: /* yellow */
+		SARL_OQ_YTH_REG &= (~(0xff << ctl.tc*8));
+		SARL_OQ_YTH_REG |= (ctl.val << ctl.tc*8);
+		break;
+	case 2: /* red */
+		SARL_OQ_RTH_REG &= (~(0xff << ctl.tc*8));
+		SARL_OQ_RTH_REG |= (ctl.val << ctl.tc*8);
+		break;
+	}
+	return CAVM_OK;
+}
+
+int get_sarl_oq(struct ifreq *ifr)
+{
+	struct CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+
+	switch (ctl.gyr) {
+	case 0: /* green*/
+		ctl.val = ((SARL_OQ_GTH_REG >> ctl.tc*8) & 0xff);
+		break;
+	case 1: /* yellow */
+		ctl.val = ((SARL_OQ_YTH_REG >> ctl.tc*8) & 0xff);
+		break;
+	case 2: /* red */
+		ctl.val = ((SARL_OQ_RTH_REG >> ctl.tc*8) & 0xff);
+		break;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXSARLEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_queue_weight(struct ifreq *ifr)
+{
+	struct CNS3XXXQueueWeightEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXQueueWeightEntry)))
+		return -EFAULT;
+	switch (ctl.which_port) {
+	case 0:
+		QUEUE_WEIGHT_SET(0, ctl)
+		break;
+	case 1:
+		QUEUE_WEIGHT_SET(1, ctl)
+		break;
+	case 2:
+		QUEUE_WEIGHT_SET(2, ctl)
+		break;
+	case 3: /* cpu port */
+		CPU_PRI_CTRL_REG &= ~(0x3ffff);
+		CPU_PRI_CTRL_REG |= (ctl.sch_mode << 16);
+		CPU_PRI_CTRL_REG |= (ctl.q0_w);
+		CPU_PRI_CTRL_REG |= (ctl.q1_w << 4);
+		CPU_PRI_CTRL_REG |= (ctl.q2_w << 8);
+		CPU_PRI_CTRL_REG |= (ctl.q3_w << 12);
+		break;
+	case 4: /* PPE port */
+		HNAT_PRI_CTRL_REG &= ~(0x3ffff);
+		HNAT_PRI_CTRL_REG |= (ctl.sch_mode << 16);
+		HNAT_PRI_CTRL_REG |= (ctl.q0_w);
+		HNAT_PRI_CTRL_REG |= (ctl.q1_w << 4);
+		HNAT_PRI_CTRL_REG |= (ctl.q2_w << 8);
+		HNAT_PRI_CTRL_REG |= (ctl.q3_w << 12);
+		break;
+	default:
+		return -EFAULT;
+	}
+	return CAVM_OK;
+}
+
+int get_queue_weight(struct ifreq *ifr)
+{
+	struct CNS3XXXQueueWeightEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXQueueWeightEntry)))
+		return -EFAULT;
+
+	switch (ctl.which_port)	{
+	case 0:
+		QUEUE_WEIGHT_GET(0, ctl)
+		break;
+	case 1:
+		QUEUE_WEIGHT_GET(1, ctl)
+		break;
+	case 2:
+		QUEUE_WEIGHT_GET(2, ctl)
+		break;
+	case 3:
+		ctl.sch_mode = ((CPU_PRI_CTRL_REG >> 16) & 0x3);
+		ctl.q0_w = ((CPU_PRI_CTRL_REG >> 0) & 0x7);
+		ctl.q1_w = ((CPU_PRI_CTRL_REG >> 4) & 0x7);
+		ctl.q2_w = ((CPU_PRI_CTRL_REG >> 8) & 0x7);
+		ctl.q3_w = ((CPU_PRI_CTRL_REG >> 12) & 0x7);
+		break;
+	case 4:
+		ctl.sch_mode = ((HNAT_PRI_CTRL_REG >> 16) & 0x3);
+		ctl.q0_w = ((HNAT_PRI_CTRL_REG >> 0) & 0x7);
+		ctl.q1_w = ((HNAT_PRI_CTRL_REG >> 4) & 0x7);
+		ctl.q2_w = ((HNAT_PRI_CTRL_REG >> 8) & 0x7);
+		ctl.q3_w = ((HNAT_PRI_CTRL_REG >> 12) & 0x7);
+		break;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXQueueWeightEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_rate_limit(struct ifreq *ifr)
+{
+	struct CNS3XXXRateLimitEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXRateLimitEntry)))
+		return -EFAULT;
+	switch (ctl.which_port)	{
+	case 0:
+		RATE_CTRL_REG &= (~(0x7f << 8));
+		RATE_CTRL_REG |= (ctl.band_width << 8);
+		RATE_CTRL_REG &= (~(0x3));
+		RATE_CTRL_REG |= ctl.base_rate;
+		break;
+	case 1:
+		RATE_CTRL_REG &= (~(0x7f << 16));
+		RATE_CTRL_REG |= (ctl.band_width << 16);
+		RATE_CTRL_REG &= (~(0x3 << 2));
+		RATE_CTRL_REG |= (ctl.base_rate << 2);
+		break;
+	case 2:
+		RATE_CTRL_REG &= (~(0x7f << 24));
+		RATE_CTRL_REG |= (ctl.band_width << 24);
+		RATE_CTRL_REG &= (~(0x3 << 4));
+		RATE_CTRL_REG |= (ctl.base_rate << 4);
+		break;
+	case 3: /* port 0 extra dma*/
+		TC_CTRL_REG &= (~0x7f);
+		TC_CTRL_REG |= ctl.band_width;
+		RATE_CTRL_REG &= (~(0x3 << 6));
+		RATE_CTRL_REG |= (ctl.base_rate << 6);
+		break;
+	default:
+		return -EFAULT;
+	}
+	return CAVM_OK;
+}
+
+int get_rate_limit(struct ifreq *ifr)
+{
+	struct CNS3XXXRateLimitEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXRateLimitEntry)))
+		return -EFAULT;
+	switch (ctl.which_port) {
+	case 0:
+		ctl.band_width = (RATE_CTRL_REG >> 8) & 0x7f;
+		ctl.base_rate = RATE_CTRL_REG & 0x3;
+		break;
+	case 1:
+		ctl.band_width = (RATE_CTRL_REG >> 16) & 0x7f;
+		ctl.base_rate = (RATE_CTRL_REG >> 2) & 0x3;
+		break;
+	case 2:
+		ctl.band_width = (RATE_CTRL_REG >> 24) & 0x7f;
+		ctl.base_rate = (RATE_CTRL_REG >> 4) & 0x3;
+		break;
+	case 3: /* port 0 extra dma*/
+		ctl.band_width = (TC_CTRL_REG) & 0x7f;
+		ctl.base_rate = (RATE_CTRL_REG >> 6) & 0x3;
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXRateLimitEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_fc(struct ifreq *ifr)
+{
+	struct CNS3XXXFCEntry ctl;
+	u32 port_offset[] = {0x0c, 0x10, 0x18, 0x14};
+		/* 0x14 is cpu port offset */
+	u32 val = 0;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXFCEntry)))
+		return -EFAULT;
+
+	val = SWITCH_REG_VALUE(port_offset[ctl.port]);
+	if (ctl.port == 3) { /* cpu port, only can set rx fc */
+		val &= (~(1 << 31));
+		if (ctl.fc_en)
+			val |= (1 << 31);
+	} else {
+		val &= (~(1 << 11)); /* disable rx fc */
+		val &= (~(1 << 12)); /* disable tx fc */
+		val |= (ctl.fc_en << 11);
+	}
+
+	SWITCH_REG_VALUE(port_offset[ctl.port]) = val;
+	return CAVM_OK;
+}
+
+int get_fc(struct ifreq *ifr)
+{
+	struct CNS3XXXFCEntry ctl;
+	u32 port_offset[] = {0x0c, 0x10, 0x18, 0x14};
+		/* 0x14 is cpu port offset */
+	u32 val = 0;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXFCEntry)))
+		return -EFAULT;
+
+	val = SWITCH_REG_VALUE(port_offset[ctl.port]);
+	printk(KERN_INFO "port_offset[%d]: %x\n",
+			ctl.port, port_offset[ctl.port]);
+	printk(KERN_INFO "val: %x\n", val);
+	if (ctl.port == 3) /* cpu port, only can set rx fc */
+		ctl.fc_en = ((val >> 31) & 1);
+	else
+		ctl.fc_en = ((val >> 11) & 3);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXFCEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_ivl(struct ifreq *ifr)
+{
+	struct CNS3XXXIVLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXIVLEntry)))
+		return -EFAULT;
+
+	cns3xxx_ivl(ctl.enable);
+
+	return CAVM_OK;
+}
+
+int get_ivl(struct ifreq *ifr)
+{
+	struct CNS3XXXIVLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXIVLEntry)))
+		return -EFAULT;
+
+	ctl.enable = ((MAC_GLOB_CFG_REG >> 7) & 0x1);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXIVLEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_wan_port(struct ifreq *ifr)
+{
+	struct CNS3XXXWANPortEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXWANPortEntry)))
+		return -EFAULT;
+	VLAN_CFG &= (~(0x1f << 8));
+	VLAN_CFG |= (ctl.wan_port << 8);
+
+	return CAVM_OK;
+}
+int get_wan_port(struct ifreq *ifr)
+{
+	struct CNS3XXXWANPortEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXWANPortEntry)))
+		return -EFAULT;
+
+	ctl.wan_port = ((VLAN_CFG >> 8) & 0x1f);
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXWANPortEntry)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_pvid(struct ifreq *ifr)
+{
+	struct CNS3XXXPVIDEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXPVIDEntry)))
+		return -EFAULT;
+	cns3xxx_set_pvid(ctl.which_port, ctl.pvid);
+
+	return CAVM_OK;
+}
+
+int get_pvid(struct ifreq *ifr)
+{
+	struct CNS3XXXPVIDEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXPVIDEntry)))
+		return -EFAULT;
+
+	ctl.pvid = cns3xxx_get_pvid(ctl.which_port);
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXPVIDEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_qa(struct ifreq *ifr)
+{
+	struct CNS3XXXQAEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXQAEntry)))
+		return -EFAULT;
+
+	MAC_GLOB_CFG_EXT_REG &= ~(0x7 << 27);
+	MAC_GLOB_CFG_EXT_REG |= (ctl.qa << 27);
+
+	return CAVM_OK;
+}
+
+int get_qa(struct ifreq *ifr)
+{
+	struct CNS3XXXQAEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXQAEntry)))
+		return -EFAULT;
+
+	ctl.qa = (MAC_GLOB_CFG_EXT_REG >> 27) & 0x7;
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXQAEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int get_packet_max_len(struct ifreq *ifr)
+{
+	struct CNS3XXXMaxLenEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXMaxLenEntry)))
+		return -EFAULT;
+
+	ctl.max_len = (PHY_AUTO_ADDR_REG >> 30) & 0x3;
+
+	if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXMaxLenEntry)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_packet_max_len(struct ifreq *ifr)
+{
+	struct CNS3XXXMaxLenEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data,
+			sizeof(struct CNS3XXXMaxLenEntry)))
+		return -EFAULT;
+
+	PHY_AUTO_ADDR_REG &= (~(3 << 30));
+	PHY_AUTO_ADDR_REG |= (ctl.max_len << 30);
+
+	return CAVM_OK;
+}
+
+int set_udp_range(struct ifreq *ifr)
+{
+	struct CNS3XXXUdpRangeEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXUdpRangeEtypeControl)))
+		return -EFAULT;
+
+	switch (conf.udp_range_num) {
+	case 0:
+		UDP_RANGE0_REG = 0;
+		UDP_RANGE0_REG |= conf.port_start;
+		UDP_RANGE0_REG |= (conf.port_end << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 16));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 16);
+		break;
+	case 1:
+		UDP_RANGE1_REG = 0;
+		UDP_RANGE1_REG |= conf.port_start;
+		UDP_RANGE1_REG |= (conf.port_end << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 20));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 20);
+		break;
+	case 2:
+		UDP_RANGE2_REG = 0;
+		UDP_RANGE2_REG |= conf.port_start;
+		UDP_RANGE2_REG |= (conf.port_end << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 24));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 24);
+		break;
+	case 3:
+		UDP_RANGE3_REG = 0;
+		UDP_RANGE3_REG |= conf.port_start;
+		UDP_RANGE3_REG |= (conf.port_end << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 28));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 28);
+		break;
+	}
+
+	return CAVM_OK;
+}
+
+int get_udp_range(struct ifreq *ifr)
+{
+	struct CNS3XXXUdpRangeEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXUdpRangeEtypeControl)))
+		return -EFAULT;
+
+	switch (conf.udp_range_num)	{
+	case 0:
+		conf.port_start = (UDP_RANGE0_REG & 0xffff);
+		conf.port_end = ((UDP_RANGE0_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 16) & 0x7);
+		break;
+	case 1:
+		conf.port_start = (UDP_RANGE1_REG & 0xffff);
+		conf.port_end = ((UDP_RANGE1_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 20) & 0x7);
+		break;
+	case 2:
+		conf.port_start = (UDP_RANGE2_REG & 0xffff);
+		conf.port_end = ((UDP_RANGE2_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 24) & 0x7);
+		break;
+	case 3:
+		conf.port_start = (UDP_RANGE3_REG & 0xffff);
+		conf.port_end = ((UDP_RANGE3_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 28) & 0x7);
+		break;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &conf,
+			sizeof(struct CNS3XXXUdpRangeEtypeControl)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int get_etype(struct ifreq *ifr)
+{
+	struct CNS3XXXEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXEtypeControl)))
+		return -EFAULT;
+	switch (conf.etype_num)	{
+	case 0:
+		conf.val = (ETYPE1_ETYPE0_REG & 0xffff);
+		conf.pri = (PRIO_ETYPE_UDP_REG & 0x7);
+		break;
+	case 1:
+		conf.val = ((ETYPE1_ETYPE0_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 4) & 0x7);
+		break;
+	case 2:
+		conf.val = (ETYPE3_ETYPE2_REG & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 8) & 0x7);
+		break;
+	case 3:
+		conf.val = ((ETYPE3_ETYPE2_REG >> 16) & 0xffff);
+		conf.pri = ((PRIO_ETYPE_UDP_REG >> 12) & 0x7);
+		break;
+	}
+	if (copy_to_user(ifr->ifr_data, &conf,
+			sizeof(struct CNS3XXXEtypeControl)))
+		return -EFAULT;
+
+	return CAVM_OK;
+}
+
+int set_etype(struct ifreq *ifr)
+{
+	struct CNS3XXXEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXEtypeControl)))
+		return -EFAULT;
+
+	switch (conf.etype_num) {
+	case 0:
+		ETYPE1_ETYPE0_REG &= (~0xffff);
+		ETYPE1_ETYPE0_REG |= conf.val;
+
+		PRIO_ETYPE_UDP_REG &= (~7);
+		PRIO_ETYPE_UDP_REG |= (conf.pri);
+		break;
+	case 1:
+		ETYPE1_ETYPE0_REG &= (~(0xffff << 16));
+		ETYPE1_ETYPE0_REG |= (conf.val << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 4));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 4);
+		break;
+	case 2:
+		ETYPE3_ETYPE2_REG &= (~0xffff);
+		ETYPE3_ETYPE2_REG |= conf.val;
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 8));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 8);
+		break;
+	case 3:
+		ETYPE3_ETYPE2_REG &= (~(0xffff << 16));
+		ETYPE3_ETYPE2_REG |= (conf.val << 16);
+
+		PRIO_ETYPE_UDP_REG &= (~(7 << 12));
+		PRIO_ETYPE_UDP_REG |= (conf.pri << 12);
+		break;
+	}
+	return CAVM_OK;
+}
+
+int get_pri_ip_dscp(struct ifreq *ifr)
+{
+	struct CNS3XXXPriIpDscpControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXPriIpDscpControl)))
+		return -EFAULT;
+
+	if (0 <= conf.ip_dscp_num && conf.ip_dscp_num <= 7)
+		conf.pri =
+			(PRIO_IPDSCP_7_0_REG >> (conf.ip_dscp_num * 4))
+			& 0x7;
+	else if (8 <= conf.ip_dscp_num && conf.ip_dscp_num <= 15)
+		conf.pri =
+			(PRIO_IPDSCP_15_8_REG >> ((conf.ip_dscp_num-8) * 4))
+			& 0x7;
+	else if (16 <= conf.ip_dscp_num && conf.ip_dscp_num <= 23)
+		conf.pri =
+			(PRIO_IPDSCP_23_16_REG >> ((conf.ip_dscp_num-16) * 4))
+			& 0x7;
+	else if (24 <= conf.ip_dscp_num && conf.ip_dscp_num <= 31)
+		conf.pri =
+			(PRIO_IPDSCP_31_24_REG >> ((conf.ip_dscp_num-24) * 4))
+			& 0x7;
+	else if (32 <= conf.ip_dscp_num && conf.ip_dscp_num <= 39)
+		conf.pri =
+			(PRIO_IPDSCP_39_32_REG >> ((conf.ip_dscp_num-32) * 4))
+			& 0x7;
+	else if (40 <= conf.ip_dscp_num && conf.ip_dscp_num <= 47)
+		conf.pri =
+			(PRIO_IPDSCP_47_40_REG >> ((conf.ip_dscp_num-40) * 4))
+			& 0x7;
+	else if (48 <= conf.ip_dscp_num && conf.ip_dscp_num <= 55)
+		conf.pri =
+			(PRIO_IPDSCP_55_48_REG >> ((conf.ip_dscp_num-48) * 4))
+			& 0x7;
+	else if (56 <= conf.ip_dscp_num && conf.ip_dscp_num <= 63)
+		conf.pri =
+			(PRIO_IPDSCP_63_56_REG >> ((conf.ip_dscp_num-56) * 4))
+			& 0x7;
+	else
+		return CAVM_ERR;
+
+	if (copy_to_user(ifr->ifr_data, &conf,
+			sizeof(struct CNS3XXXPriIpDscpControl)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int set_pri_ip_dscp(struct ifreq *ifr)
+{
+	struct CNS3XXXPriIpDscpControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXPriIpDscpControl)))
+		return -EFAULT;
+
+	if (0 <= conf.ip_dscp_num && conf.ip_dscp_num <= 7) {
+		PRIO_IPDSCP_7_0_REG &=
+			(~(0x7 << (conf.ip_dscp_num * 4)));
+		PRIO_IPDSCP_7_0_REG |=
+			(conf.pri << (conf.ip_dscp_num * 4));
+	} else if (8 <= conf.ip_dscp_num && conf.ip_dscp_num <= 15) {
+		PRIO_IPDSCP_15_8_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-8) * 4)));
+		PRIO_IPDSCP_15_8_REG |=
+			(conf.pri << ((conf.ip_dscp_num-8) * 4));
+	} else if (16 <= conf.ip_dscp_num && conf.ip_dscp_num <= 23) {
+		PRIO_IPDSCP_23_16_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-16) * 4)));
+		PRIO_IPDSCP_23_16_REG |=
+			(conf.pri << ((conf.ip_dscp_num-16) * 4));
+	} else if (24 <= conf.ip_dscp_num && conf.ip_dscp_num <= 31) {
+		PRIO_IPDSCP_31_24_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-24) * 4)));
+		PRIO_IPDSCP_31_24_REG |=
+			(conf.pri << ((conf.ip_dscp_num-24) * 4));
+	} else if (32 <= conf.ip_dscp_num && conf.ip_dscp_num <= 39) {
+		PRIO_IPDSCP_39_32_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-32) * 4)));
+		PRIO_IPDSCP_39_32_REG |=
+			(conf.pri << ((conf.ip_dscp_num-32) * 4));
+	} else if (40 <= conf.ip_dscp_num && conf.ip_dscp_num <= 47) {
+		PRIO_IPDSCP_47_40_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-40) * 4)));
+		PRIO_IPDSCP_47_40_REG |=
+			(conf.pri << ((conf.ip_dscp_num-40) * 4));
+	} else if (48 <= conf.ip_dscp_num && conf.ip_dscp_num <= 55) {
+		PRIO_IPDSCP_55_48_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-48) * 4)));
+		PRIO_IPDSCP_55_48_REG |=
+			(conf.pri << ((conf.ip_dscp_num-48) * 4));
+	} else if (56 <= conf.ip_dscp_num && conf.ip_dscp_num <= 63) {
+		PRIO_IPDSCP_63_56_REG &=
+			(~(0x7 << ((conf.ip_dscp_num-56) * 4)));
+		PRIO_IPDSCP_63_56_REG |=
+			(conf.pri << ((conf.ip_dscp_num-56) * 4));
+	} else
+		return CAVM_ERR;
+
+	return CAVM_OK;
+}
+
+#if defined(CONFIG_CNS3XXX_GSW_VB)
+extern int bcm53115M_reg_read(int page, int offset, u8 *buf, int len);
+extern int bcm53115M_reg_write(int page, int offset, u8 *buf, int len);
+
+int bcm53115M_reg_read_ioctl(struct ifreq *ifr)
+{
+	struct CNS3XXXBCM53115M conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXBCM53115M)))
+		return -EFAULT;
+
+	printk(KERN_INFO "conf.page: %x\n", conf.page);
+	printk(KERN_INFO "conf.offset: %x\n", conf.offset);
+	printk(KERN_INFO "conf.data_len: %x\n", conf.data_len);
+	switch (conf.data_len) {
+	case 1:
+		bcm53115M_reg_read(conf.page, conf.offset,
+			(u8 *)&conf.u8_val, 1);
+		printk(KERN_INFO "conf.u8_val: %x\n", conf.u8_val);
+		break;
+	case 2:
+		bcm53115M_reg_read(conf.page, conf.offset,
+			(u8 *)&conf.u16_val, 2);
+		printk(KERN_INFO "conf.u16_val: %x\n", conf.u16_val);
+		break;
+	case 4:
+		bcm53115M_reg_read(conf.page, conf.offset,
+			(u8 *)&conf.u32_val, 4);
+		printk(KERN_INFO "conf.u32_val: %x\n", conf.u32_val);
+		break;
+	default:
+		printk(KERN_ERR
+			"[kernel mode]: don't support date length: %d\n",
+			conf.data_len);
+		break;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &conf,
+			sizeof(struct CNS3XXXBCM53115M)))
+		return -EFAULT;
+	return CAVM_OK;
+}
+
+int bcm53115M_reg_write_ioctl(struct ifreq *ifr)
+{
+	struct CNS3XXXBCM53115M conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXBCM53115M)))
+		return -EFAULT;
+
+	switch (conf.data_len) {
+	case 1:
+		bcm53115M_reg_write(conf.page, conf.offset,
+			(u8 *)&conf.u8_val, 1);
+		break;
+	case 2:
+		bcm53115M_reg_write(conf.page, conf.offset,
+			(u8 *)&conf.u16_val, 2);
+		break;
+	case 4:
+		bcm53115M_reg_write(conf.page, conf.offset,
+			(u8 *)&conf.u32_val, 4);
+		break;
+	default:
+		printk(KERN_ERR
+			"[kernel mode]: don't support date length: %d\n",
+			conf.data_len);
+		break;
+	}
+	return CAVM_OK;
+}
+#endif
+
+int dump_mib_counter(struct ifreq *ifr)
+{
+	struct CNS3XXXMIBCounter conf;
+	int addr = 0, i = 0;
+
+	if (copy_from_user(&conf, ifr->ifr_data,
+			sizeof(struct CNS3XXXMIBCounter)))
+		return -EFAULT;
+
+	for (addr = 0x300; addr <= 0x334 ; addr += 4)
+		conf.mib[i++] = SWITCH_REG_VALUE(addr);
+	for (addr = 0x400; addr <= 0x434 ; addr += 4)
+		conf.mib[i++] = SWITCH_REG_VALUE(addr);
+	for (addr = 0x600; addr <= 0x634 ; addr += 4)
+		conf.mib[i++] = SWITCH_REG_VALUE(addr);
+	/* cpu mib counter */
+	for (addr = 0x500; addr <= 0x528 ; addr += 4)
+		conf.mib[i++] = SWITCH_REG_VALUE(addr);
+	conf.mib_len = i;
+	if (copy_to_user(ifr->ifr_data, &conf,
+			sizeof(struct CNS3XXXMIBCounter)))
+		return -EFAULT;
+	return 0;
+}
+
+int cns3xxx_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	enum CNS3XXXIoctlCmd ioctl_cmd;
+
+	if (cmd != SIOCDEVPRIVATE)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&ioctl_cmd, ifr->ifr_data,
+			sizeof(enum CNS3XXXIoctlCmd)))
+		return -EFAULT;
+
+	switch (ioctl_cmd) {
+	case CNS3XXX_ARP_REQUEST_SET:
+	{
+		struct CNS3XXXArpRequestControl ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXArpRequestControl)))
+			return -EFAULT;
+		(ctl.val == 0) ?
+			(MAC_GLOB_CFG_REG &= (~(1 << 23))) :
+			(MAC_GLOB_CFG_REG |= (1 << 23));
+		return CAVM_OK;
+	}
+	case CNS3XXX_ARP_REQUEST_GET:
+	{
+		struct CNS3XXXArpRequestControl ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXArpRequestControl)))
+			return -EFAULT;
+		ctl.val = ((MAC_GLOB_CFG_REG >> 23) & 1);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+			sizeof(struct CNS3XXXArpRequestControl)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+	case CNS3XXX_HOL_PREVENT_SET:
+	{
+		struct CNS3XXXHOLPreventControl ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXHOLPreventControl)))
+			return -EFAULT;
+		(ctl.enable == 1) ?
+			(TC_CTRL_REG |= (1 << 29)) :
+			(TC_CTRL_REG &= (~(1 << 29))) ;
+		return CAVM_OK;
+	}
+	case CNS3XXX_HOL_PREVENT_GET:
+	{
+		struct CNS3XXXHOLPreventControl ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXHOLPreventControl)))
+			return -EFAULT;
+
+		ctl.enable = ((TC_CTRL_REG >> 29) & 0x1);
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXHOLPreventControl)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+	case CNS3XXX_BRIDGE_SET:
+	{
+		struct CNS3XXXBridgeControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXBridgeControl)))
+			return -EFAULT;
+		(ctl.type == 1) ?
+			(VLAN_CFG |= (1 << 1)) :
+			(VLAN_CFG &= (~(1 << 1)));
+		return CAVM_OK;
+	}
+	case CNS3XXX_BRIDGE_GET:
+	{
+		struct CNS3XXXBridgeControl ctl;
+		ctl.type = ((VLAN_CFG >> 1) & 0x1);
+		printk(KERN_INFO "[kernel mode] ctl.type: %d\n", ctl.type);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXBridgeControl)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+	case CNS3XXX_PORT_NEIGHBOR_SET:
+	{
+		struct CNS3XXXPortNeighborControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXPortNeighborControl)))
+			return -EFAULT;
+
+		switch (ctl.which_port)	{
+		case 0:
+			(ctl.type == 1) ?
+				(VLAN_CFG |= (1 << 4)) :
+				(VLAN_CFG &= (~(1 << 4)));
+			return CAVM_OK;
+		case 1:
+			(ctl.type == 1) ?
+				(VLAN_CFG |= (1 << 5)) :
+				(VLAN_CFG &= (~(1 << 5)));
+			return CAVM_OK;
+		case 2:
+			(ctl.type == 1) ?
+				(VLAN_CFG |= (1 << 7)) :
+				(VLAN_CFG &= (~(1 << 7)));
+			return CAVM_OK;
+		case 3: /* cpu port */
+			(ctl.type == 1) ?
+				(VLAN_CFG |= (1 << 6)) :
+				(VLAN_CFG &= (~(1 << 6)));
+			return CAVM_OK;
+		default:
+			return -EFAULT;
+		}
+	}
+	case CNS3XXX_PORT_NEIGHBOR_GET:
+	{
+		struct CNS3XXXPortNeighborControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXPortNeighborControl)))
+			return -EFAULT;
+		switch (ctl.which_port) {
+		case 0:
+			ctl.type = ((VLAN_CFG >> 4) & 0x1);
+			break;
+		case 1:
+			ctl.type = ((VLAN_CFG >> 5) & 0x1);
+			break;
+		case 2:
+			ctl.type = ((VLAN_CFG >> 7) & 0x1);
+			break;
+		case 3: /* cpu port */
+			ctl.type = ((VLAN_CFG >> 6) & 0x1);
+			break;
+		}
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXPortNeighborControl)))
+			return -EFAULT;
+
+		return CAVM_OK;
+	}
+	case CNS3XXX_VLAN_TABLE_LOOKUP:
+	{
+		struct CNS3XXXVLANTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+		if (cns3xxx_vlan_table_lookup(&ctl.entry) ==  CAVM_NOT_FOUND)
+			return CAVM_NOT_FOUND;
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+
+		return CAVM_FOUND;
+	}
+	case CNS3XXX_VLAN_TABLE_READ:
+	{
+		struct CNS3XXXVLANTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_vlan_table_read(&ctl.entry);
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+	case CNS3XXX_VLAN_TABLE_ADD:
+	{
+		struct CNS3XXXVLANTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_vlan_table_add(&ctl.entry);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXVLANTableEntry)))
+			return -EFAULT;
+
+		return CAVM_OK;
+	}
+	case CNS3XXX_ARL_TABLE_ADD:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		printk(KERN_INFO "[kernel mode] CNS3XXX_ARL_TABLE_ADD\n");
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_arl_table_add(&ctl.entry);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+	case CNS3XXX_ARL_TABLE_DEL:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_arl_table_invalid(&ctl.entry);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		return CAVM_OK;
+	}
+	case CNS3XXX_VLAN_TABLE_DEL:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_arl_table_invalid(&ctl.entry);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		return CAVM_FOUND;
+	}
+	case CNS3XXX_ARL_TABLE_SEARCH:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		if (cns3xxx_arl_table_search(&ctl.entry) == CAVM_NOT_FOUND) {
+			printk(KERN_INFO "[kernel mode] not found\n");
+			return CAVM_NOT_FOUND;
+		}
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		return CAVM_FOUND;
+	}
+	case CNS3XXX_ARL_IS_TABLE_END:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		if (cns3xxx_is_arl_table_end() == CAVM_ERR)
+			return CAVM_ERR;
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		return CAVM_OK;
+	}
+
+	case CNS3XXX_ARL_TABLE_SEARCH_AGAIN:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		if (cns3xxx_arl_table_search_again(&ctl.entry) ==
+				CAVM_NOT_FOUND)
+			return CAVM_NOT_FOUND;
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		return CAVM_FOUND;
+	}
+
+	case CNS3XXX_ARL_TABLE_FLUSH:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		cns3xxx_arl_table_flush();
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+
+		return CAVM_FOUND;
+	}
+	case CNS3XXX_ARL_TABLE_LOOKUP:
+	{
+		struct CNS3XXXARLTableEntry ctl;
+
+		printk(KERN_INFO "[kernel mode] in CNS3XXX_ARL_TABLE_LOOKUP\n");
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		if (cns3xxx_arl_table_lookup(&ctl.entry) == CAVM_NOT_FOUND)
+			return CAVM_NOT_FOUND;
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXARLTableEntry)))
+			return -EFAULT;
+		return CAVM_FOUND;
+	}
+	case CNS3XXX_TC_SET:
+	{
+		struct CNS3XXXTrafficClassControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXTrafficClassControl)))
+			return -EFAULT;
+
+		TC_CTRL_REG &= (~(0x3 << 30));
+		TC_CTRL_REG |= (ctl.tc << 30);
+		return CAVM_OK;
+	}
+	case CNS3XXX_TC_GET:
+	{
+		struct CNS3XXXTrafficClassControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXTrafficClassControl)))
+			return -EFAULT;
+
+		ctl.tc = ((TC_CTRL_REG >> 30) & 0x3);
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXTrafficClassControl)))
+			return -EFAULT;
+		return CAVM_OK;
+	}
+
+	case CNS3XXX_PRI_CTRL_SET:
+	{
+		struct CNS3XXXPriCtrlControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXPriCtrlControl)))
+			return -EFAULT;
+
+		switch (ctl.which_port) {
+		case 0:
+			MAC0_PRI_CTRL_REG &= (~(0x7 << 24));
+			MAC0_PRI_CTRL_REG &= (~(0xf << 18));
+
+			MAC0_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+			MAC0_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+			MAC0_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+			MAC0_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+			MAC0_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+			break;
+		case 1:
+			MAC1_PRI_CTRL_REG &= (~(0x7 << 24));
+			MAC1_PRI_CTRL_REG &= (~(0xf << 18));
+
+			MAC1_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+			MAC1_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+			MAC1_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+			MAC1_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+			MAC1_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+			break;
+		case 2:
+			MAC2_PRI_CTRL_REG &= (~(0x7 << 24));
+			MAC2_PRI_CTRL_REG &= (~(0xf << 18));
+
+			MAC2_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+			MAC2_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+			MAC2_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+			MAC2_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+			MAC2_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+			break;
+		case 3: /* cpu */
+			printk(KERN_INFO
+				"[kernel mode] CPU_PRI_CTRL_REG: %#x\n",
+				CPU_PRI_CTRL_REG);
+			CPU_PRI_CTRL_REG &= (~(0x7 << 24));
+			CPU_PRI_CTRL_REG &= (~(0xf << 18));
+
+			CPU_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+			CPU_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+			CPU_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+			CPU_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+			CPU_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+			break;
+		}
+		return CAVM_OK;
+	}
+	case CNS3XXX_PRI_CTRL_GET:
+	{
+		struct CNS3XXXPriCtrlControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXPriCtrlControl)))
+			return -EFAULT;
+		switch (ctl.which_port) {
+		case 0:
+			ctl.port_pri = (unsigned char)
+				((MAC0_PRI_CTRL_REG >> 24) & 0x7);
+			ctl.ether_pri_en = (unsigned char)
+				((MAC0_PRI_CTRL_REG >> 18) & 0x1);
+			ctl.vlan_pri_en = (unsigned char)
+				((MAC0_PRI_CTRL_REG >> 19) & 0x1);
+			ctl.dscp_pri_en = (unsigned char)
+				((MAC0_PRI_CTRL_REG >> 20) & 0x1);
+			ctl.udp_pri_en = (unsigned char)
+				((MAC0_PRI_CTRL_REG >> 21) & 0x1);
+			break;
+		case 1:
+			ctl.port_pri = (unsigned char)
+				((MAC1_PRI_CTRL_REG >> 24) & 0x7);
+			ctl.ether_pri_en = (unsigned char)
+				((MAC1_PRI_CTRL_REG >> 18) & 0x1);
+			ctl.vlan_pri_en = (unsigned char)
+				((MAC1_PRI_CTRL_REG >> 19) & 0x1);
+			ctl.dscp_pri_en = (unsigned char)
+				((MAC1_PRI_CTRL_REG >> 20) & 0x1);
+			ctl.udp_pri_en = (unsigned char)
+				((MAC1_PRI_CTRL_REG >> 21) & 0x1);
+			break;
+		case 2:
+			ctl.port_pri = (unsigned char)
+				((MAC2_PRI_CTRL_REG >> 24) & 0x7);
+			ctl.ether_pri_en = (unsigned char)
+				((MAC2_PRI_CTRL_REG >> 18) & 0x1);
+			ctl.vlan_pri_en = (unsigned char)
+				((MAC2_PRI_CTRL_REG >> 19) & 0x1);
+			ctl.dscp_pri_en = (unsigned char)
+				((MAC2_PRI_CTRL_REG >> 20) & 0x1);
+			ctl.udp_pri_en = (unsigned char)
+				((MAC2_PRI_CTRL_REG >> 21) & 0x1);
+			break;
+		case 3:
+			ctl.port_pri =
+				(unsigned char)((CPU_PRI_CTRL_REG >> 24) & 0x7);
+			ctl.ether_pri_en =
+				(unsigned char)((CPU_PRI_CTRL_REG >> 18) & 0x1);
+			ctl.vlan_pri_en =
+				(unsigned char)((CPU_PRI_CTRL_REG >> 19) & 0x1);
+			ctl.dscp_pri_en =
+				(unsigned char)((CPU_PRI_CTRL_REG >> 20) & 0x1);
+			ctl.udp_pri_en =
+				(unsigned char)((CPU_PRI_CTRL_REG >> 21) & 0x1);
+			break;
+		}
+
+		if (copy_to_user(ifr->ifr_data, &ctl,
+				sizeof(struct CNS3XXXPriCtrlControl)))
+			return -EFAULT;
+
+		return CAVM_OK;
+	}
+	case CNS3XXX_DMA_RING_CTRL_SET:
+	{
+		struct CNS3XXXDmaRingCtrlControl ctl;
+
+		if (copy_from_user(&ctl, ifr->ifr_data,
+				sizeof(struct CNS3XXXDmaRingCtrlControl)))
+			return -EFAULT;
+
+		(ctl.ts_double_ring_en == 0) ?
+			DMA_RING_CTRL_REG &= (~(0x1 << 16)) :
+			(DMA_RING_CTRL_REG |= (ctl.ts_double_ring_en << 16));
+		(ctl.fs_double_ring_en == 0) ?
+			DMA_RING_CTRL_REG &= (~(0x1 << 0)) :
+			(DMA_RING_CTRL_REG |= (ctl.fs_double_ring_en << 0));
+		(ctl.fs_pkt_allocate == 0) ?
+			DMA_RING_CTRL_REG &= (~(0x1 << 1)) :
+			(DMA_RING_CTRL_REG |= (ctl.fs_pkt_allocate << 1));
+		return CAVM_OK;
+	}
+	case CNS3XXX_PRI_IP_DSCP_SET:
+		return set_pri_ip_dscp(ifr);
+	case CNS3XXX_PRI_IP_DSCP_GET:
+		return get_pri_ip_dscp(ifr);
+	case CNS3XXX_ETYPE_SET:
+		return set_etype(ifr);
+	case CNS3XXX_ETYPE_GET:
+		return get_etype(ifr);
+	case CNS3XXX_UDP_RANGE_SET:
+		return set_udp_range(ifr);
+	case CNS3XXX_UDP_RANGE_GET:
+		return get_udp_range(ifr);
+	case CNS3XXX_RATE_LIMIT_SET:
+		return set_rate_limit(ifr);
+	case CNS3XXX_RATE_LIMIT_GET:
+		return get_rate_limit(ifr);
+	case CNS3XXX_QUEUE_WEIGHT_SET:
+		return set_queue_weight(ifr);
+	case CNS3XXX_QUEUE_WEIGHT_GET:
+		return get_queue_weight(ifr);
+	case CNS3XXX_FC_RLS_SET:
+		return set_fc_rls(ifr);
+	case CNS3XXX_FC_RLS_GET:
+		return get_fc_rls(ifr);
+	case CNS3XXX_FC_SET_SET:
+		return set_fc_set(ifr);
+	case CNS3XXX_FC_SET_GET:
+		return get_fc_set(ifr);
+	case CNS3XXX_SARL_RLS_SET:
+		return set_sarl_rls(ifr);
+	case CNS3XXX_SARL_RLS_GET:
+		return get_sarl_rls(ifr);
+	case CNS3XXX_SARL_SET_SET:
+		return set_sarl_set(ifr);
+	case CNS3XXX_SARL_SET_GET:
+		return get_sarl_set(ifr);
+	case CNS3XXX_SARL_OQ_SET:
+		return set_sarl_oq(ifr);
+	case CNS3XXX_SARL_OQ_GET:
+		return get_sarl_oq(ifr);
+	case CNS3XXX_SARL_ENABLE_SET:
+		return set_sarl_enable(ifr);
+	case CNS3XXX_SARL_ENABLE_GET:
+		return get_sarl_enable(ifr);
+	case CNS3XXX_FC_SET:
+		return set_fc(ifr);
+	case CNS3XXX_FC_GET:
+		return get_fc(ifr);
+	case CNS3XXX_IVL_SET:
+		return set_ivl(ifr);
+	case CNS3XXX_IVL_GET:
+		return get_ivl(ifr);
+	case CNS3XXX_WAN_PORT_SET:
+		return set_wan_port(ifr);
+	case CNS3XXX_WAN_PORT_GET:
+		return get_wan_port(ifr);
+	case CNS3XXX_PVID_SET:
+		return set_pvid(ifr);
+	case CNS3XXX_PVID_GET:
+		return get_pvid(ifr);
+	case CNS3XXX_QA_GET:
+		return get_qa(ifr);
+	case CNS3XXX_QA_SET:
+		return set_qa(ifr);
+	case CNS3XXX_PACKET_MAX_LEN_GET:
+		return get_packet_max_len(ifr);
+	case CNS3XXX_PACKET_MAX_LEN_SET:
+		return set_packet_max_len(ifr);
+#if defined(CONFIG_CNS3XXX_GSW_VB)
+	case CNS3XXX_BCM53115M_REG_READ:
+		return bcm53115M_reg_read_ioctl(ifr);
+	case CNS3XXX_BCM53115M_REG_WRITE:
+		return bcm53115M_reg_write_ioctl(ifr);
+#endif
+	case CNS3XXX_DUMP_MIB_COUNTER:
+		return dump_mib_counter(ifr);
+	default:
+		printk(KERN_ERR "[kernel mode] don't match any command\n");
+		break;
+	} /* end switch (ioctl_cmd)  */
+	return 0;
+}
+
+#ifdef CONFIG_CNS3XXX_NAPI
+static int cns3xxx_poll(struct napi_struct *napi, int budget)
+{
+	struct CNS3XXXPrivate *sp =
+		container_of(napi, struct CNS3XXXPrivate, napi);
+	int work_done = 0;
+	int work_to_do = budget; /* define minima value */
+
+	cns3xxx_receive_packet(sp, 0, &work_done, work_to_do);
+
+	budget -= work_done;
+
+    if (work_done) {
+		if (test_bit(0, (unsigned long *)&sp->is_qf) == 1) {
+			clear_bit(0, (unsigned long *)&sp->is_qf);
+			enable_rx_dma(sp->ring_index, 1);
+			return work_done;
+	}
+	} else {
+		napi_complete(napi);
+
+		if (sp->ring_index == 0)
+			cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
+		else
+			cns3xxx_enable_irq(FSRC_RING1_INTERRUPT_ID);
+		return 0;
+	}
+
+	return work_done;
+}
+#endif
+
+static struct net_device_stats *cns3xxx_get_stats(struct net_device *dev)
+{
+	struct CNS3XXXPrivate *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static int cns3xxx_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu < cns3xxx_min_mtu() || new_mtu > cns3xxx_max_mtu())
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static void cns3xxx_timeout(struct net_device *dev)
+{
+	printk(KERN_INFO "%s:cns3xxx gsw timeout\n", dev->name);
+	netif_wake_queue(dev);
+	dev->trans_start = jiffies;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void cns3xxx_netpoll(struct net_device *dev)
+{
+	disable_irq(FSRC_RING0_INTERRUPT_ID);
+	cns3xxx_fsrc_ring0_isr(FSRC_RING0_INTERRUPT_ID, dev);
+	enable_irq(FSRC_RING0_INTERRUPT_ID);
+
+	disable_irq(FSQF_RING0_INTERRUPT_ID);
+	cns3xxx_fsqf_ring0_isr(FSQF_RING0_INTERRUPT_ID, dev);
+	enable_irq(FSQF_RING0_INTERRUPT_ID);
+}
+#endif
+
+static const struct net_device_ops cns3xxx_netdev_ops = {
+	.ndo_open               = cns3xxx_open,
+	.ndo_stop               = cns3xxx_close,
+	.ndo_start_xmit         = cns3xxx_send_packet,
+	/*.ndo_validate_addr      = eth_validate_addr,
+	.ndo_set_multicast_list = cns3xxx_set_multicast_list,*/
+	.ndo_set_mac_address    = cns3xxx_set_mac_addr,
+	.ndo_change_mtu         = cns3xxx_change_mtu,
+	.ndo_do_ioctl           = cns3xxx_do_ioctl,
+	.ndo_tx_timeout         = cns3xxx_timeout,
+	.ndo_get_stats		= cns3xxx_get_stats,
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller    = cns3xxx_netpoll,
+#endif
+};
+
+extern void cns3xxx_set_ethtool_ops(struct net_device *netdev);
+
+static int __init cns3xxx_probe(struct RingInfo ring_info)
+{
+
+	int netdev_size = num_net_dev_priv;
+	int i = 0, err = 0;
+	struct net_device *netdev;
+	struct CNS3XXXPrivate *priv = NULL;
+	struct sockaddr sock_addr;
+#ifdef CONFIG_CNS3XXX_ETHADDR_IN_FLASH
+    u8 mac_int[6];
+    int val_len;
+    int do_new_mac = 0;
+    if (0 == init_mtd_env())
+		do_new_mac = 1;
+#endif
+
+	for (i = 0; i < netdev_size; ++i) {
+		netdev = alloc_etherdev(sizeof(struct CNS3XXXPrivate));
+		if (!netdev) {
+			err = -ENOMEM;
+			goto err_alloc_etherdev;
+		}
+		if (net_device_prive[i].name)
+			strcpy(netdev->name, net_device_prive[i].name);
+
+		net_dev_array[net_device_prive[i].vlan_tag] = netdev;
+		if (intr_netdev == 0)
+			intr_netdev = netdev;
+
+		SET_NETDEV_DEV(netdev, NULL);
+		priv = netdev_priv(netdev);
+		spin_lock_init(&priv->lock);
+		memset(priv, 0, sizeof(struct CNS3XXXPrivate));
+
+		priv->num_rx_queues = ring_info.num_rx_queues;
+		priv->num_tx_queues = ring_info.num_tx_queues;
+		priv->rx_ring = ring_info.rx_ring;
+		priv->tx_ring = ring_info.tx_ring;
+
+		priv->net_device_priv = &net_device_prive[i];
+		/* set netdev MAC address */
+#if defined(CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
+		if (do_new_mac) {
+			char name[20];
+			sprintf(name, "ethaddr%d=", i);
+			if (0 == fmg_get(name, &val_len)) {
+				mac_str_to_int(ethaddr, val_len, mac_int, 6);
+				memcpy(sock_addr.sa_data, mac_int, 6);
+			} else {
+				memcpy(sock_addr.sa_data,
+					net_device_prive[i].mac, 6);
+			}
+		} else
+			memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
+#else
+		memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
+#endif
+		cns3xxx_set_mac_addr(netdev, &sock_addr);
+
+		netdev->netdev_ops = &cns3xxx_netdev_ops;
+
+		cns3xxx_set_ethtool_ops(netdev);
+
+#if defined(CNS3XXX_TX_HW_CHECKSUM)
+		netdev->features |= NETIF_F_IP_CSUM;
+		netdev->features |= NETIF_F_SG;
+#endif
+
+		err = register_netdev(netdev);
+		if (err) {
+			printk(KERN_ERR "Register network dev :%s failed\n",
+				netdev->name);
+			goto err_register_netdev;
+		}
+		printk(KERN_INFO "Register network dev :%s\n", netdev->name);
+		netif_carrier_off(netdev);
+		netdev = 0;
+	}
+
+	return 0;
+
+err_register_netdev:
+	free_netdev(netdev);
+
+err_alloc_etherdev:
+	return err;
+}
+
+static int cns3xxx_notify_reboot(
+	struct notifier_block *nb, unsigned long event, void *ptr)
+{
+/* stop the DMA*/
+	enable_rx_dma(0, 0);
+	enable_tx_dma(0, 0);
+	enable_rx_dma(1, 0);
+	enable_tx_dma(1, 0);
+
+/* disable Port 0*/
+	enable_port(0, 0);
+	enable_port(1, 0);
+	enable_port(2, 0);
+	enable_port(3, 0);
+
+/* disable phy auto-poll*/
+	PHY_AUTO_ADDR_REG &= ~((1<<5) | (1<<13) | (1<<21));
+/* wait state machine idle*/
+	mdelay(1000);
+
+	return NOTIFY_DONE;
+}
+
+#ifdef CONFIG_CNS3XXX_NAPI
+static struct net_device *init_napi_dev(
+	struct net_device *ndev, const struct RingInfo *ring_info)
+{
+	struct CNS3XXXPrivate *priv;
+
+	ndev = alloc_etherdev(sizeof(struct CNS3XXXPrivate));
+	if (!ndev) {
+		printk(KERN_ERR "Cannot allocate NAPI virtual device\n");
+		BUG();
+	}
+	priv = netdev_priv(ndev);
+	memset(priv, 0, sizeof(struct CNS3XXXPrivate));
+
+	priv->num_rx_queues = ring_info->num_rx_queues;
+	priv->num_tx_queues = ring_info->num_tx_queues;
+	priv->rx_ring = ring_info->rx_ring;
+	priv->tx_ring = ring_info->tx_ring;
+
+	netif_napi_add(ndev, &priv->napi , cns3xxx_poll, CNS3XXX_NAPI_WEIGHT);
+	dev_hold(ndev);
+	set_bit(__LINK_STATE_START, &ndev->state);
+
+	return ndev;
+}
+#endif
+
+#include <asm/hardware/gic.h>
+
+/* type: level or edge
+ * 0 - level high active, 1 - rising edge sensitive
+ */
+void set_interrupt_type_by_base(void __iomem *base, int id, u32 type)
+{
+	unsigned char int_type_bit = 0;
+	u32 gic_v = 0;
+
+	/* judge gic offset */
+	int_type_bit = (id % 16 * 2 + 1);
+
+	gic_v = readl(base + GIC_DIST_CONFIG + id / 16 * 4);
+
+	gic_v &= (~(1 << int_type_bit));
+	gic_v |= (type << int_type_bit);
+
+	writel(gic_v, base + GIC_DIST_CONFIG + id / 16 * 4);
+}
+
+/* type: level or edge
+ * 0 - level high active, 1 - rising edge sensitive
+ */
+void set_interrupt_type(int id, u32 type)
+{
+	set_interrupt_type_by_base(
+		(void __iomem *) CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT, id, type);
+}
+
+void get_interrupt_type_by_base(void __iomem *base, u32 id, u32 *type)
+{
+	unsigned char int_type_bit = 0;
+	u32 gic_v = 0;
+
+	/* judge gic offset */
+	int_type_bit = (id % 16 * 2 + 1);
+
+	gic_v = readl(base + GIC_DIST_CONFIG + id / 16 * 4);
+
+	*type = ((gic_v >> int_type_bit) & 0x1);
+}
+
+void get_interrupt_type(u32 id, u32 *type)
+{
+	get_interrupt_type_by_base(
+		(void __iomem *) CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT, id, type);
+}
+
+
+void cns3xxx_config_intr(void)
+{
+	u32 v = 0xffffffff;
+
+	get_interrupt_type(FSRC_RING0_INTERRUPT_ID, &v);
+
+	set_interrupt_type(FSRC_RING0_INTERRUPT_ID, RISING_EDGE);
+	get_interrupt_type(FSRC_RING0_INTERRUPT_ID, &v);
+
+	get_interrupt_type(FSRC_RING1_INTERRUPT_ID, &v);
+	set_interrupt_type(FSRC_RING1_INTERRUPT_ID, RISING_EDGE);
+	get_interrupt_type(FSRC_RING1_INTERRUPT_ID, &v);
+
+	get_interrupt_type(FSQF_RING0_INTERRUPT_ID, &v);
+	set_interrupt_type(FSQF_RING0_INTERRUPT_ID, RISING_EDGE);
+	get_interrupt_type(FSQF_RING0_INTERRUPT_ID, &v);
+
+	get_interrupt_type(FSQF_RING1_INTERRUPT_ID, &v);
+	set_interrupt_type(FSQF_RING1_INTERRUPT_ID, RISING_EDGE);
+	get_interrupt_type(FSQF_RING1_INTERRUPT_ID, &v);
+}
+
+static int __init cns3xxx_init_module(void)
+{
+/* when tx_ring/rx_ring alloc memory,
+ * don't free them until cns3xxx_exit_module
+ */
+	struct RingInfo ring_info;
+	int i = 0;
+	u32 reg_config = 0;
+
+#ifdef CNS3XXX_DOUBLE_RX_RING
+	ring_info.num_rx_queues = 2;
+#else
+	ring_info.num_rx_queues = 1;
+#endif
+
+#ifdef CNS3XXX_DOUBLE_TX_RING
+	ring_info.num_tx_queues = 2;
+#else
+	ring_info.num_tx_queues = 1;
+#endif
+	ring_info.rx_ring = kcalloc(
+		ring_info.num_rx_queues, sizeof(struct RXRing), GFP_KERNEL);
+	if (!ring_info.rx_ring)
+		return -ENOMEM;
+	for (i = 0 ; i < ring_info.num_rx_queues ; ++i)
+		memset(ring_info.rx_ring + i, 0, sizeof(struct RXRing));
+
+	ring_info.tx_ring = kcalloc(
+		ring_info.num_tx_queues, sizeof(struct TXRing), GFP_KERNEL);
+	if (!ring_info.tx_ring)
+		return -ENOMEM;
+	for (i = 0 ; i < ring_info.num_tx_queues ; ++i)
+		memset(ring_info.tx_ring + i, 0, sizeof(struct TXRing));
+
+	g_ring_info = ring_info;
+
+	cns3xxx_gsw_up_init();
+
+	reg_config = PHY_AUTO_ADDR_REG;
+	reg_config &= ~(3 << 30);
+	if (jumbo_frame)
+		reg_config |= (3 << 30); /* maximum frame length: 9600 bytes */
+	else
+		reg_config |= (2 << 30); /* maximum frame length: 1536 bytes */
+	PHY_AUTO_ADDR_REG = reg_config;
+
+	if (jumbo_frame) {
+		MAX_PACKET_LEN = 9600;
+		printk(KERN_INFO "jumbo_frame on\n");
+		printk(KERN_INFO "MAX_PACKET_LEN:%d\n", MAX_PACKET_LEN);
+	} else {
+		MAX_PACKET_LEN = 1536;
+		printk(KERN_INFO "jumbo_frame off\n");
+		printk(KERN_INFO "MAX_PACKET_LEN:%d\n", MAX_PACKET_LEN);
+	}
+
+	cns3xxx_probe(ring_info);
+	cns3xxx_config_intr();
+
+	spin_lock_init(&tx_lock);
+	spin_lock_init(&rx_lock);
+
+#ifdef CONFIG_CNS3XXX_NAPI
+	napi_dev = init_napi_dev(napi_dev, &ring_info);
+#ifdef CNS3XXX_DOUBLE_RX_RING
+	r1_napi_dev = init_napi_dev(r1_napi_dev, &ring_info);
+#endif
+#endif
+	register_reboot_notifier(&cns3xxx_notifier_reboot);
+	clear_fs_dma_state(0);
+	if (ring_info.num_rx_queues == 2)
+		DMA_RING_CTRL_REG |= 1; /* enable RX dobule ring*/
+
+	if (ring_info.num_tx_queues == 2)
+		DMA_RING_CTRL_REG |= (1 << 16); /* enable TX dobule ring*/
+
+	return 0;
+}
+
+static void __exit cns3xxx_exit_module(void)
+{
+	int i = 0;
+
+	kfree(g_ring_info.rx_ring);
+	kfree(g_ring_info.tx_ring);
+
+	for (i = 0; i < NETDEV_SIZE; ++i) {
+		struct CNS3XXXPrivate *priv = 0;
+
+		if (net_dev_array[i]) {
+			priv = netdev_priv(net_dev_array[i]);
+
+			unregister_netdev(net_dev_array[i]);
+			free_netdev(net_dev_array[i]);
+		}
+	}
+
+#ifdef CONFIG_CNS3XXX_NAPI
+	free_netdev(napi_dev);
+#ifdef CNS3XXX_DOUBLE_RX_RING
+	free_netdev(r1_napi_dev);
+#endif
+#endif
+
+	unregister_reboot_notifier(&cns3xxx_notifier_reboot);
+	printk(KERN_INFO "remove cns3xxx pse module\n");
+}
+
+MODULE_AUTHOR("Cavium Networks, <tech@XXXX.com>");
+MODULE_DESCRIPTION("CNS3XXX Switch Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(cns3xxx_init_module);
+module_exit(cns3xxx_exit_module);
diff --git a/drivers/net/cns3xxx/cns3xxx_phy.c b/drivers/net/cns3xxx/cns3xxx_phy.c
new file mode 100644
index 0000000..17002b5
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_phy.c
@@ -0,0 +1,983 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#include "cns3xxx_phy.h"
+#include "cns3xxx_symbol.h"
+
+#include <linux/gpio.h>
+
+#include "cns3xxx_tool.h"
+#include "switch_api.h" /* for CAVM_OK ... macro */
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+ushort jumbo_frame;
+module_param(jumbo_frame, ushort, S_IRUGO|S_IWUSR);
+EXPORT_SYMBOL_GPL(jumbo_frame);
+
+int cns3xxx_phy_reset(u8 phy_addr)
+{
+	u16 phy_data = 0;
+
+	if (cns3xxx_read_phy(phy_addr, 0, &phy_data) != CAVM_OK)
+		return CAVM_ERR;
+	phy_data |= (0x1 << 15);
+	if (cns3xxx_write_phy(phy_addr, 0, phy_data) != CAVM_OK)
+		return CAVM_ERR;
+
+	return CAVM_OK;
+}
+
+/* mac_port: 0, 1, 2 */
+int cns3xxx_enable_mac_clock(u8 mac_port, u8 en)
+{
+	switch (mac_port) {
+	case 0:
+		(en == 1) ?
+			(PHY_AUTO_ADDR_REG |= 1 << 7) :
+			(PHY_AUTO_ADDR_REG &= (~(1 << 7)));
+		break;
+	case 1:
+		(en == 1) ?
+			(PHY_AUTO_ADDR_REG |= (1 << 15)) :
+			(PHY_AUTO_ADDR_REG &= (~(1 << 15)));
+		break;
+	case 2:
+		(en == 1) ?
+			(PHY_AUTO_ADDR_REG |= (1 << 23)) :
+			(PHY_AUTO_ADDR_REG &= (~(1 << 23)));
+		break;
+	}
+	return CAVM_OK;
+}
+
+/* dis: 1 disable; dis: 0 enable*/
+int cns3xxx_phy_auto_polling_enable(u8 port, u8 en)
+{
+	u8 phy_addr[] = {5, 13, 21};
+
+	PHY_AUTO_ADDR_REG &= (~(1 << phy_addr[port]));
+	if (en)
+		PHY_AUTO_ADDR_REG |= (1 << phy_addr[port]);
+	return CAVM_OK;
+}
+
+/* dis: 1 disable, 0 enable */
+int cns3xxx_mdc_mdio_disable(u8 dis)
+{
+	PHY_CTRL_REG &= (~(1 << 7));
+	if (dis)
+		PHY_CTRL_REG |= (1 << 7);
+
+	return CAVM_OK;
+}
+
+int cns3xxx_phy_auto_polling_conf(int mac_port, u8 phy_addr)
+{
+	if ((mac_port < 0) || (mac_port > 2)) {
+		printk(KERN_ERR "err\n");
+		return CAVM_ERR;
+	}
+	switch (mac_port) {
+	case 0:
+		PHY_AUTO_ADDR_REG &= (~0x1f);
+		PHY_AUTO_ADDR_REG |= phy_addr;
+		break;
+	case 1:
+		PHY_AUTO_ADDR_REG &= (~(0x1f << 8));
+		PHY_AUTO_ADDR_REG |= (phy_addr << 8);
+		break;
+	case 2:
+		PHY_AUTO_ADDR_REG &= (~(0x1f << 16));
+		PHY_AUTO_ADDR_REG |= (phy_addr << 16);
+		break;
+	}
+	cns3xxx_phy_auto_polling_enable(mac_port, 1);
+	return CAVM_OK;
+}
+
+int cns3xxx_read_phy(u8 phy_addr, u8 phy_reg, u16 *read_data)
+{
+	int delay = 0;
+	u32 volatile tmp = PHY_CTRL_REG;
+
+	PHY_CTRL_REG |= (1 << 15); /* clear "command completed" bit */
+
+	for (delay = 0; delay < 10; delay++)
+		;
+
+	tmp &= (~0x1f);
+	tmp |= phy_addr;
+
+	tmp &= (~(0x1f << 8));
+	tmp |= (phy_reg << 8);
+
+	tmp |= (1 << 14); /* read command */
+
+	PHY_CTRL_REG = tmp;
+
+	/* wait command complete */
+	while (((PHY_CTRL_REG >> 15) & 1) == 0)
+		;
+
+	*read_data = (PHY_CTRL_REG >> 16);
+	PHY_CTRL_REG |= (1 << 15); /* clear "command completed" bit */
+
+	return CAVM_OK;
+}
+
+int cns3xxx_write_phy(u8 phy_addr, u8 phy_reg, u16 write_data)
+{
+	int delay = 0;
+	u32 tmp = PHY_CTRL_REG;
+
+	PHY_CTRL_REG |= (1 << 15); /* clear "command completed" bit */
+
+	for (delay = 0; delay < 10; delay++)
+		;
+
+	tmp &= (~(0xffff << 16));
+	tmp |= (write_data << 16);
+
+	tmp &= (~0x1f);
+	tmp |= phy_addr;
+
+	tmp &= (~(0x1f << 8));
+	tmp |= (phy_reg << 8);
+
+	tmp |= (1 << 13); /* write command */
+
+	PHY_CTRL_REG = tmp;
+
+	/* wait command complete */
+	while (((PHY_CTRL_REG >> 15) & 1) == 0)
+		;
+
+	return CAVM_OK;
+}
+
+/* port 0,1,2 */
+void cns3xxx_rxc_dly(u8 port, u8 val)
+{
+	switch (port) {
+	case 0:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 4));
+		SLK_SKEW_CTRL_REG |= (val << 4);
+		break;
+	case 1:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 12));
+		SLK_SKEW_CTRL_REG |= (val << 12);
+		break;
+	case 2:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 20));
+		SLK_SKEW_CTRL_REG |= (val << 20);
+		break;
+	}
+}
+
+/* port 0,1,2 */
+void cns3xxx_txc_dly(u8 port, u8 val)
+{
+	switch (port) {
+	case 0:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 6));
+		SLK_SKEW_CTRL_REG |= (val << 6);
+		break;
+	case 1:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 14));
+		SLK_SKEW_CTRL_REG |= (val << 14);
+		break;
+	case 2:
+		SLK_SKEW_CTRL_REG &= (~(0x3 << 22));
+		SLK_SKEW_CTRL_REG |= (val << 22);
+		break;
+	}
+}
+
+void cns3xxx_mac2_gtxd_dly(u8 val)
+{
+	SLK_SKEW_CTRL_REG &= (~(0x3 << 24));
+	SLK_SKEW_CTRL_REG |= (val << 24);
+}
+
+/* port : 0 => port0 ; port : 1 => port1
+ * y = 1 ; disable AN
+ */
+void disable_AN(int port, int y)
+{
+	u32 mac_port_config = 0;
+
+	switch (port) {
+	case 0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case 1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case 2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+
+	/* disable PHY's AN */
+	if (y == 1)
+		mac_port_config &= ~(0x1 << 7);
+
+	/* enable PHY's AN */
+	if (y == 0)
+		mac_port_config |= (0x1 << 7);
+
+	switch (port) {
+	case 0:
+		MAC0_CFG_REG = mac_port_config;
+		break;
+	case 1:
+		MAC1_CFG_REG = mac_port_config;
+		break;
+	case 2:
+		MAC2_CFG_REG = mac_port_config;
+		break;
+	}
+}
+
+int cns3xxx_std_phy_power_down(int phy_addr, int y)
+{
+	u16 phy_data = 0;
+	/* power-down or up the PHY */
+	cns3xxx_read_phy(phy_addr, 0, &phy_data);
+	if (y == 1) /* down */
+		phy_data |= (0x1 << 11);
+	if (y == 0) /* up */
+		phy_data &= (~(0x1 << 11));
+	cns3xxx_write_phy(phy_addr, 0, phy_data);
+
+	phy_data = 0;
+	cns3xxx_read_phy(phy_addr, 0, &phy_data);
+
+	return 0;
+}
+
+#if defined(CONFIG_CNS3XXX_GSW_VB)
+extern u8 cns3xxx_spi_tx_rx(
+	u8 tx_channel, u8 tx_eof, u32 tx_data, u32 *rx_data);
+
+int cns3xxx_spi_tx_rx_n(
+	u32 tx_data, u32 *rx_data, u32 tx_channel, u32 tx_eof_flag)
+{
+	return cns3xxx_spi_tx_rx(tx_channel, tx_eof_flag, tx_data, rx_data);
+}
+
+int bcm53115M_reg_read(int page, int offset, u8 *buf, int len)
+{
+	u32 ch = BCM53115_SPI_CHANNEL;
+	u8 cmd_byte;
+	u32	dumy_word;
+	u32 spi_status;
+	int i;
+
+	/* Normal SPI Mode (Command Byte)
+	 * Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
+	 * 0	1	1	Mode=0 CHIP_ID2	ID1	ID0(lsb) Rd/Wr(0/1)
+	 */
+
+	/* Normal Read Operation */
+	/* 1. Issue a normal read command(0x60) to poll the SPIF bit in the
+	 * SPI status register(0XFE) to determine the
+	 * operation can start */
+	do {
+		cmd_byte = 0x60;
+		cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0xFE, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0x00, &spi_status, ch, 1);
+	} while ((spi_status >> ROBO_SPIF_BIT) & 1);
+
+	/* 2. Issue a normal write command(0x61) to write
+	 * the register page value into the SPI page register(0xFF)	*/
+	cmd_byte = 0x61;
+	cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(0xFF, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(page, &dumy_word, ch, 1);
+
+	/* 3. Issue a normal read command(0x60) to setup the
+	 * required RobiSwitch register address	 */
+	cmd_byte = 0x60;
+	cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(offset, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(0x00, &dumy_word, ch, 1);
+
+	/* 4. Issue a normal read command(0x60) to poll the
+	 * RACK bit in the SPI status register(0XFE) to determine
+	 * the completion of read*/
+	do {
+		cmd_byte = 0x60;
+		cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0xFE, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0x00, &spi_status, ch, 1);
+	} while (((spi_status >> ROBO_RACK_BIT) & 1) == 0);
+
+	/* 5. Issue a normal read command(0x60) to read the
+	 * specific register's conternt placed in the SPI
+	 * data I/O register(0xF0)	 */
+	cmd_byte = 0x60;
+	cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(0xF0, &dumy_word, ch, 0);
+	/* read content */
+	for (i = 0; i < len; i++) {
+		cns3xxx_spi_tx_rx_n(
+			0x00, &dumy_word, ch, ((i == (len - 1)) ? 1 : 0));
+		buf[i] = (u8)dumy_word;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm53115M_reg_read);
+
+int bcm53115M_reg_write(int page, int offset, u8 *buf, int len)
+{
+	u32 ch = BCM53115_SPI_CHANNEL;
+	u8 cmd_byte;
+	u32 dumy_word;
+	u32 spi_status;
+	int i;
+
+	/* Normal SPI Mode (Command Byte)
+	 * Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
+	 * 0	1	1	Mode=0 CHIP_ID2	ID1	ID0(lsb) Rd/Wr(0/1)
+	 */
+
+	/* Normal Write Operation */
+	/* 1. Issue a normal read command(0x60) to poll the SPIF bit in the
+	 * SPI status register(0XFE) to determine the operation can start */
+	do {
+		cmd_byte = 0x60;
+		cns3xxx_spi_tx_rx_n(cmd_byte, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0xFE, &dumy_word, ch, 0);
+		cns3xxx_spi_tx_rx_n(0x00, &spi_status, ch, 1);
+	} while ((spi_status >> ROBO_SPIF_BIT) & 1) ;
+
+	/* 2. Issue a normal write command(0x61) to write
+	 * the register page valueinto the SPI page register(0xFF)	*/
+	cmd_byte = 0x61;
+	cns3xxx_spi_tx_rx_n((u32)cmd_byte, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(0xFF, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(page, &dumy_word, ch, 1);
+
+	/* 3. Issue a normal write command(0x61)
+	 * and write the address of the accessed
+	 * register followed by the write content
+	 * starting from a lower byte */
+	cmd_byte = 0x61;
+	cns3xxx_spi_tx_rx_n((u32)cmd_byte, &dumy_word, ch, 0);
+	cns3xxx_spi_tx_rx_n(offset, &dumy_word, ch, 0);
+	/* write content */
+	for (i = 0; i < len; i++)
+		cns3xxx_spi_tx_rx_n((u32)buf[i],
+			&dumy_word, ch, ((i == (len-1)) ? 1 : 0));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm53115M_reg_write);
+
+void bcm53115M_init_mac(u8 mac_port, u16 phy_addr)
+{
+	u32 mac_port_config = 0;
+	u8 mac_addr[] = {0x0c, 0x10, 0x18};
+
+	cns3xxx_enable_mac_clock(mac_port, 1);
+	cns3xxx_phy_auto_polling_enable(mac_port, 0);
+
+	mac_port_config = SWITCH_REG_VALUE(mac_addr[mac_port]);
+
+	/* enable GMII, MII, reverse MII*/
+	mac_port_config &= (~(1 << 15));
+
+	/* enable RGMII*/
+	mac_port_config |= (1 << 15);
+
+	/* disable GIGA mode */
+	mac_port_config &= (~(1<<16));
+
+	/* enable GIGA mode*/
+	mac_port_config |= (1<<16);
+
+	/* disable PHY's AN */
+	mac_port_config &= (~(0x1 << 7));
+
+	/* force 1000Mbps*/
+	mac_port_config &= (~(0x3 << 8));
+	mac_port_config |= (0x2 << 8);
+
+	/* force duplex*/
+	mac_port_config |= (0x1 << 10);
+
+	/* TX flow control on*/
+	mac_port_config |= (0x1 << 12);
+
+	/* RX flow control on*/
+	mac_port_config |= (0x1 << 11);
+
+	/* Turn off GSW_PORT_TX_CHECK_EN_BIT*/
+	mac_port_config &= (~(0x1 << 13));
+
+	/* Turn on GSW_PORT_TX_CHECK_EN_BIT*/
+	mac_port_config |= (0x1 << 13);
+
+	SWITCH_REG_VALUE(mac_addr[mac_port]) = mac_port_config;
+}
+
+struct bcm53115M_vlan_entry {
+	u16 vid;
+	u16 forward_map;
+	u16 untag_map;
+};
+
+int bcm53115M_write_vlan(struct bcm53115M_vlan_entry *v)
+{
+	u8 bval;
+	u16 wval;
+	u32 dwval;
+
+	/* fill vid*/
+	wval = (u16)v->vid;
+	bcm53115M_reg_write(0x05, 0x81, (u8 *)&wval, 2);
+
+	/* fill table content*/
+	dwval = 0;
+	dwval |= (v->forward_map & 0x1FF);
+	dwval |= ((v->untag_map & 0x1FF) << 9);
+	bcm53115M_reg_write(0x05, 0x83, (u8 *)&wval, 4);
+
+	/* write cmd */
+	bval = VLAN_WRITE_CMD;
+	bval |= (1 << VLAN_START_BIT);
+	bcm53115M_reg_write(0x05, 0x80, (u8 *)&bval, 1);
+
+	/* wait cmd complete */
+	while (1) {
+		bcm53115M_reg_read(0x05, 0x80, (u8 *)&bval, 1);
+		if (((bval >> VLAN_START_BIT) & 1) == 0)
+			break;
+	}
+	return CAVM_OK;
+}
+
+struct bcm_port_cfg {
+	u8 link;
+	u8 fdx;
+	enum BCM_PORT_SPEED speed;
+	u8 rx_flw_ctrl;
+	u8 tx_flw_ctrl;
+	u8 ow;
+};
+
+int bcm53115M_mac_port_config(int port, struct bcm_port_cfg *cfg)
+{
+	u8 bval = 0;
+	int page, addr;
+
+	if (cfg->link)
+		bval |= (1<<0);
+	if (cfg->fdx)
+		bval |= (1<<1);
+	bval |= ((cfg->speed & 0x3) << 2);
+	if (cfg->rx_flw_ctrl)
+		bval |= (1<<4);
+	if (cfg->tx_flw_ctrl)
+		bval |= (1<<5);
+
+	if (port == BCM_PORT_IMP) {
+		bval |= (1 << 7); /* Use content of this register*/
+		page = 0x00;
+		addr = 0x0E;
+	} else {
+		page = 0x00;
+		addr = 0x58+port;
+	}
+
+	bcm53115M_reg_write(page, addr, &bval, 1);
+
+	return 0;
+}
+
+int bcm53115M_init_internal_phy(void)
+{
+	int p, page;
+	u16 wval;
+
+	for (p = BCM_PORT_0; p <= BCM_PORT_4; p++) {
+		page = 0x10 + p;
+
+		/* reset phy*/
+		bcm53115M_reg_read(page, 0x00, (u8 *)&wval, 2);
+		wval |= 0x8000;
+		bcm53115M_reg_write(page, 0x00, (u8 *)&wval, 2);
+
+		/* config auto-nego & all advertisement*/
+		bcm53115M_reg_read(page, 0x00, (u8 *)&wval, 2);
+		wval |= (1<<12); /* auto-nego */
+		bcm53115M_reg_write(page, 0x00, (u8 *)&wval, 2);
+
+		bcm53115M_reg_read(page, 0x08, (u8 *)&wval, 2);
+		wval |= 0x1E0; /* advertisement all*/
+		bcm53115M_reg_write(page, 0x08, (u8 *)&wval, 2);
+
+		/* 1000BASE-T*/
+		bcm53115M_reg_read(page, 0x12, (u8 *)&wval, 2);
+		wval &= ~(1<<12); /*automatic master/slave configuration*/
+		wval |= 0x300; /*1000-base full/half advertisements*/
+		bcm53115M_reg_write(page, 0x12, (u8 *)&wval, 2);
+	}
+
+	return 0;
+}
+
+int bcm53115M_led_init(void)
+{
+	u16 led_func, bval, wval;
+
+	/* LED function 1G/ACT, 100M/ACT, 10M/ACT, not used */
+	led_func = 0x2C00;
+	bcm53115M_reg_write(0x00, 0x10, (u8 *)&led_func, 2);
+	bcm53115M_reg_write(0x00, 0x12, (u8 *)&led_func, 2);
+
+	/* LED map enable */
+	wval = 0x1F; /* port0~4*/
+	bcm53115M_reg_write(0x00, 0x16, (u8 *)&wval, 2);
+
+	/* LED mode map */
+	wval = 0x1F; /* led auto mode*/
+	bcm53115M_reg_write(0x00, 0x18, (u8 *)&wval, 2);
+	bcm53115M_reg_write(0x00, 0x1A, (u8 *)&wval, 2);
+
+	/* LED enable */
+	bcm53115M_reg_read(0x00, 0x0F, (u8 *)&bval, 1);
+	bval |= 0x80;
+	bcm53115M_reg_write(0x00, 0x0F, (u8 *)&bval, 1);
+
+	return 0;
+}
+
+int bcm53115M_init(u8 mac_port, u16 phy_addr)
+{
+	u32 u32_val = 0;
+	u16 u16_val = 0;
+	u8 bval = 0;
+	int i = 0;
+	struct bcm53115M_vlan_entry v_ent;
+	struct bcm_port_cfg pc;
+	u8 page = 0, offset = 0;
+	u8 gpio_pin = 50; /* for control bcm53115, gpio B pin 18*/
+
+	printk(KERN_INFO "Initialize BCM53115M\n");
+
+	memset(&v_ent, 0, sizeof(struct bcm53115M_vlan_entry));
+	/* gpio B pin 18*/
+	if (gpio_request(gpio_pin, "cns3xxx_gpio") == 0) {
+		gpio_direction_output(gpio_pin, 0);
+		gpio_free(gpio_pin);
+	}
+
+	bcm53115M_init_mac(0, 0);
+	bcm53115M_init_mac(1, 1);
+	/*read device id*/
+	bcm53115M_reg_read(0x02, 0x30, (u8 *)&u32_val, 4);
+	printk(KERN_INFO "bcm53115M device id:(0x%x)\r\n", u32_val);
+
+	if (u32_val != 0x53115) {
+		printk(KERN_INFO "bad device id(0x%x)\r\n", u32_val);
+		return -1;
+	}
+
+	u16_val = 0;
+	/* read phy id*/
+	bcm53115M_reg_read(0x10, 0x04, (u8 *)&u16_val, 2);
+	printk(KERN_INFO "bcm53115M phy id_1:(0x%x)\r\n", u16_val);
+
+	if (u16_val != 0x143) {
+		printk(KERN_INFO "bad phy id1(0x%x)\r\n", u16_val);
+		return CAVM_ERR;
+	}
+
+	u16_val = 0;
+	/* read phy id2*/
+	bcm53115M_reg_read(0x10, 0x06, (u8 *)&u16_val, 2);
+	printk(KERN_INFO "bcm53115M phy id_2:(0x%x)\r\n", u16_val);
+
+	/* Loop detection disable */
+	bcm53115M_reg_read(0x72, 0x00, (u8 *)&u16_val, 2);
+	u16_val &= ~(0x3<<11);
+	bcm53115M_reg_write(0x72, 0x00, (u8 *)&u16_val, 2);
+
+
+	/* VLAN forwarding mask
+	 * Bit8 IMP port, Bits[5:0] correspond to ports[5:0]
+	 * port 0 <-> port IMP
+	 */
+	u16_val = 0x103;
+	bcm53115M_reg_write(0x31, 0x0, (u8 *)&u16_val, 2); /* port 0*/
+	u16_val = 0x103;
+	bcm53115M_reg_write(0x31, 0x10, (u8 *)&u16_val, 2); /* IMP*/
+
+	/* port 4 <-> port 5*/
+	u16_val = 0x3c;
+	bcm53115M_reg_write(0x31, 0x08, (u8 *)&u16_val, 2); /* port 4*/
+	u16_val = 0x3c;
+	bcm53115M_reg_write(0x31, 0x0A, (u8 *)&u16_val, 2); /* port 5*/
+
+	/* others <-> none*/
+	u16_val = 0x00;
+	bcm53115M_reg_write(0x31, 0x02, (u8 *)&u16_val, 2); /* port 1*/
+	bcm53115M_reg_write(0x31, 0x04, (u8 *)&u16_val, 2); /* port 2*/
+	bcm53115M_reg_write(0x31, 0x06, (u8 *)&u16_val, 2); /* port 3*/
+
+	/* port 1 <-> port IMP*/
+	u16_val = 0x103;
+	bcm53115M_reg_write(0x31, 0x2, (u8 *)&u16_val, 2); /* port 1*/
+
+	/* port 2 <-> port 5*/
+	u16_val = 0x3c;
+	bcm53115M_reg_write(0x31, 0x4, (u8 *)&u16_val, 2); /* port 2*/
+
+	/* port 3 <-> port 5*/
+	u16_val = 0x3c;
+	bcm53115M_reg_write(0x31, 0x6, (u8 *)&u16_val, 2); /* port 3*/
+
+	/* Create VLAN1 for default port pvid */
+
+	/* Unmanagement mode
+	 * Switch Mode. Page 00h,Address 0Bh
+	 */
+	bval = 0x02; /* forward enable, unmanaged mode*/
+	bcm53115M_reg_write(0x0, 0xb, &bval, 1);
+
+	/* Init port5 & IMP  (test giga mode first)
+	 * IMP port control. Page 00h,Address 08h
+	 */
+	bval = 0x1C; /* RX UCST/MCST/BCST enable*/
+	bcm53115M_reg_write(0x0, 0x8, &bval, 1);
+
+	offset = 0x5d; /* port 5*/
+	bval = 0x7b;
+	bcm53115M_reg_write(page, offset, (u8 *)&bval, 1);
+	bcm53115M_reg_read(page, offset, (u8 *)&bval, 1);
+
+	/* Speed, dulplex......etc
+	 * setting in Gsw_Configure_Gsw_Hardware()
+	 */
+
+	/* Mgmt configuration, Page 02h, Address 00h*/
+	bval = 0;
+	bcm53115M_reg_write(0x02, 0x00, &bval, 1);
+	/* BRCM header, Page 02h, Address 03h*/
+	bval = 0; /* without additional header information*/
+	bcm53115M_reg_write(0x02, 0x03, &bval, 1);
+
+	/* Init front ports, port0-4 */
+	/* MAC*/
+	pc.speed = BCM_PORT_1G;
+	pc.link = 0; /* link detect by robo_port_update()*/
+	pc.ow = 0;
+	for (i = BCM_PORT_0; i <= BCM_PORT_4; i++)
+		bcm53115M_mac_port_config(i, &pc);
+	/* Internal Phy*/
+	bcm53115M_init_internal_phy();
+
+	/* Enable all port, STP_STATE=No spanning tree, TX/RX enable */
+	/* Page 00h, Address 00h-05h*/
+	bval = 0x0;
+	for (i = 0; i <= 5; i++)
+		bcm53115M_reg_write(0x0, i, &bval, 1);
+
+	/* Disable broadcast storm control due to h/w strap pin BC_SUPP_EN
+	 * Page 41h, Address 10h-13h, bit28&22
+	 */
+
+	/* for port 0 ~ 5*/
+	for (i = 0; i <= 0x14; i += 4) {
+		bcm53115M_reg_read(0x41, 0x10+i, (u8 *)&u32_val, 4);
+		u32_val &= ~((1<<28) | (1<<22));
+		bcm53115M_reg_write(0x41, 0x10+i, (u8 *)&u32_val, 4);
+	}
+
+	/* for IMP port*/
+	bcm53115M_reg_read(0x41, 0x30, (u8 *)&u32_val, 4);
+	u32_val &= ~((1<<28) | (1<<22));
+	bcm53115M_reg_write(0x41, 0x30, (u8 *)&u32_val, 4);
+
+	/* Misc */
+	/* led*/
+	bcm53115M_led_init();
+	/* multicast fwd rule, Page 00h, Address 2Fh*/
+	bval = 0;
+	bcm53115M_reg_write(0x00, 0x2F, &bval, 1);
+
+	/* enable IMF port flow control function.*/
+	page = 0x00;
+	offset = 0x0e;
+	bval = 0;
+	bcm53115M_reg_read(page, offset, (u8 *)&bval, 1);
+	bval |= (1<<4);
+	bval |= (1<<5);
+	bcm53115M_reg_write(page, offset, (u8 *)&bval, 1);
+	bcm53115M_reg_read(page, offset, (u8 *)&bval, 1);
+
+	return CAVM_OK;
+}
+#endif
+
+#define CNS3XXX_MAC2_IP1001_GIGA_MODE
+
+void icp_ip1001_init_mac(u8 mac_port, u16 phy_addr)
+{
+	u32 mac_port_config = 0;
+	u8 mac_addr[] = {0x0c, 0x10, 0x18};
+
+	cns3xxx_enable_mac_clock(mac_port, 1);
+
+	mac_port_config = SWITCH_REG_VALUE(mac_addr[mac_port]);
+
+	/* enable GMII, MII, reverse MII*/
+	mac_port_config &= (~(1 << 15));
+
+#ifdef MAC2_RGMII
+	mac_port_config |= (1 << 15);
+#endif
+
+	/* disable GIGA mode*/
+	mac_port_config &= (~(1<<16));
+
+#ifdef CNS3XXX_MAC2_IP1001_GIGA_MODE
+	/* enable GIGA mode*/
+	mac_port_config |= (1<<16);
+#endif
+	/* disable PHY's AN*/
+	mac_port_config &= (~(0x1 << 7));
+
+	/* enable PHY's AN*/
+	mac_port_config |= (0x1 << 7);
+	SWITCH_REG_VALUE(mac_addr[mac_port]) = mac_port_config;
+}
+
+#define PROBE_PHY_ID 0x0243
+
+int icp_ip1001_init(u8 mac_port, u8 phy_addr)
+{
+	u16 phy_data = 0;
+
+	printk(KERN_INFO "Initialize ICPLUS IP1001\n");
+
+	cns3xxx_mdc_mdio_disable(0);
+
+	phy_data = get_phy_id(phy_addr); /* should be 0x243*/
+
+	if (phy_data != PROBE_PHY_ID) {
+		printk(KERN_ERR "wrong phy id: %x!! Should be %x\n",
+			phy_data, PROBE_PHY_ID);
+		return CAVM_ERR;
+	}
+
+	cns3xxx_phy_reset(phy_addr);
+
+	icp_ip1001_init_mac(mac_port, phy_addr);
+
+	/* read advertisement register*/
+	cns3xxx_read_phy(phy_addr, 0x4, &phy_data);
+
+	/* enable PAUSE frame capability*/
+	phy_data |= (0x1 << 10);
+
+	phy_data &= (~(0x1 << 5));
+	phy_data &= (~(0x1 << 6));
+	phy_data &= (~(0x1 << 7));
+	phy_data &= (~(0x1 << 8));
+
+	phy_data |= (0x1 << 5);
+	phy_data |= (0x1 << 6);
+	phy_data |= (0x1 << 7);
+	phy_data |= (0x1 << 8);
+
+	cns3xxx_write_phy(phy_addr, 0x4, phy_data);
+
+	cns3xxx_read_phy(phy_addr, 9, &phy_data);
+
+	phy_data &= (~(1<<8)); /* remove advertise 1000 half duples*/
+	phy_data &= (~(1<<9)); /* remove advertise 1000 full duples*/
+
+#ifdef CNS3XXX_MAC2_IP1001_GIGA_MODE
+	phy_data |= (1<<9); /* add advertise 1000 full duples*/
+#endif
+	cns3xxx_write_phy(phy_addr, 9, phy_data);
+	cns3xxx_read_phy(phy_addr, 9, &phy_data);
+	cns3xxx_read_phy(phy_addr, 0, &phy_data);
+
+	/* AN enable*/
+	phy_data |= (0x1 << 12);
+	cns3xxx_write_phy(phy_addr, 0, phy_data);
+	cns3xxx_read_phy(phy_addr, 0, &phy_data);
+	/* restart AN*/
+	phy_data |= (0x1 << 9);
+	cns3xxx_write_phy(phy_addr, 0, phy_data);
+
+	/* If mac port AN turns on, auto polling needs to turn on.*/
+	cns3xxx_phy_auto_polling_conf(mac_port, phy_addr);
+	return 0;
+}
+
+#define PHY_CONTROL_REG_ADDR 0x00
+#define PHY_AN_ADVERTISEMENT_REG_ADDR 0x04
+
+int icp_101a_init_mac(u8 port, u8 phy_addr)
+{
+	u32 mac_port_config = 0;
+	cns3xxx_enable_mac_clock(port, 1);
+	switch (port) {
+	case 0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case 1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case 2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+
+	/* enable GMII, MII, reverse MII*/
+	mac_port_config &= (~(1 << 15));
+
+	/* disable PHY's AN, use force mode*/
+	mac_port_config &= (~(0x1 << 7));
+
+	/* enable PHY's AN*/
+	mac_port_config |= (0x1 << 7);
+	/* If mac port AN turns on, auto polling needs to turn on.*/
+	cns3xxx_phy_auto_polling_conf(port, phy_addr);
+
+	/* normal MII*/
+	mac_port_config &= (~(1 << 14));
+
+	switch (port) {
+	case 0:
+		MAC0_CFG_REG = mac_port_config;
+		break;
+	case 1:
+		MAC1_CFG_REG = mac_port_config;
+		break;
+	case 2:
+		MAC2_CFG_REG = mac_port_config;
+		break;
+	}
+	return CAVM_OK;
+}
+
+int icp_101a_init(u8 mac_port, u8 phy_addr)
+{
+	u32 mac_port_config = 0;
+	u16 phy_data = 0;
+
+	cns3xxx_mdc_mdio_disable(0);
+	cns3xxx_phy_reset(phy_addr);
+
+	phy_data = get_phy_id(mac_port);
+	if (phy_data != 0x0243) {
+		printk(KERN_ERR "ICPLUS 101A phy id should be 0x243,"
+			"but the phy id is : %x\n", phy_data);
+		return CAVM_ERR;
+	}
+	printk(KERN_INFO "phy id : %x\n", phy_data);
+	printk(KERN_INFO "init IC+101A\n");
+
+	icp_101a_init_mac(mac_port, phy_addr);
+
+	/* read advertisement register*/
+	cns3xxx_read_phy(phy_addr, 0x4, &phy_data);
+
+	/* enable PAUSE frame capability*/
+	phy_data |= (0x1 << 10);
+
+	cns3xxx_write_phy(phy_addr, 0x4, phy_data);
+
+	switch (mac_port) {
+	case 0:
+		mac_port_config = MAC0_CFG_REG;
+		break;
+	case 1:
+		mac_port_config = MAC1_CFG_REG;
+		break;
+	case 2:
+		mac_port_config = MAC2_CFG_REG;
+		break;
+	}
+
+	cns3xxx_read_phy(phy_addr, 0, &phy_data);
+	/* an enable*/
+	phy_data |= (0x1 << 12);
+
+	/* restart AN*/
+	phy_data |= (0x1 << 9);
+	cns3xxx_write_phy(phy_addr, 0, phy_data);
+
+	while (1) {
+		cns3xxx_read_phy(phy_data, 0, &phy_data);
+
+		if (phy_data & (0x1 << 9))
+			continue;
+		else
+			break;
+	}
+
+	return CAVM_OK;
+}
+
+u16 get_phy_id(u8 phy_addr)
+{
+	u16 read_data;
+
+	cns3xxx_read_phy(phy_addr, 2, &read_data);
+
+	return read_data;
+}
+
+u32 get_vsc8601_recv_err_counter(u8 phy_addr)
+{
+	u16 read_data = 0;
+	cns3xxx_read_phy(phy_addr, 19, &read_data);
+	return read_data;
+}
+
+u32 get_crc_good_counter(u8 phy_addr)
+{
+	u16 read_data = 0;
+	/* enter extended register mode*/
+	cns3xxx_write_phy(phy_addr, 31, 0x0001);
+	cns3xxx_read_phy(phy_addr, 18, &read_data);
+
+	/* back to normal register mode*/
+	cns3xxx_write_phy(phy_addr, 31, 0x0000);
+	return read_data;
+}
diff --git a/drivers/net/cns3xxx/cns3xxx_phy.h b/drivers/net/cns3xxx/cns3xxx_phy.h
new file mode 100644
index 0000000..2288057
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_phy.h
@@ -0,0 +1,78 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#ifndef CNS3XXX_PHY_H
+#define CNS3XXX_PHY_H
+
+#include <linux/version.h>
+#include <linux/types.h>
+
+void disable_AN(int port, int y);
+
+u16 get_phy_id(u8 phy_addr);
+int cns3xxx_std_phy_power_down(int phy_addr, int y);
+u32 get_vsc8601_recv_err_counter(u8 phy_addr);
+u32 get_crc_good_counter(u8 phy_addr);
+int cns3xxx_config_VSC8601(u8 mac_port, u8 phy_addr);
+int vsc8601_power_down(int phy_addr, int y);
+int icp_101a_init(u8 mac_port, u8 phy_addr);
+int bcm53115M_init(u8 mac_port, u16 phy_addr);
+int icp_ip1001_init(u8 mac_port, u8 phy_addr);
+int rtk_rtl8211_init(u8 mac_port, u8 phy_addr);
+int rtl8366rb_init(u8 mac_port, u16 phy_addr);
+
+int cns3xxx_phy_auto_polling_enable(u8 port, u8 en);
+int cns3xxx_phy_auto_polling_conf(int mac_port, u8 phy_addr);
+
+int cns3xxx_read_phy(u8 phy_addr, u8 phy_reg, u16 *read_data);
+int cns3xxx_write_phy(u8 phy_addr, u8 phy_reg, u16 write_data);
+
+/* wrap cns3xxx_spi_tx_rx() for argument order*/
+int cns3xxx_spi_tx_rx_n(
+	u32 tx_data, u32 *rx_data, u32 tx_channel, u32 tx_eof_flag);
+int vitesse7395_init(u8 mac_port, u16 phy_addr);
+
+/* for bcm53115M */
+#define ROBO_SPIF_BIT 7
+#define BCM53115_SPI_CHANNEL 1
+#define ROBO_RACK_BIT 5
+
+#define VLAN_START_BIT 7
+#define VLAN_WRITE_CMD 0
+
+enum BCM_PORT_SPEED {
+   BCM_PORT_10M = 0,
+   BCM_PORT_100M,
+   BCM_PORT_1G,
+};
+
+#define BCM_PORT_0 0
+#define BCM_PORT_1 1
+#define BCM_PORT_2 2
+#define BCM_PORT_3 3
+#define BCM_PORT_4 4
+#define BCM_PORT_5 5
+#define BCM_PORT_IMP 6
+
+#endif
diff --git a/drivers/net/cns3xxx/cns3xxx_symbol.h b/drivers/net/cns3xxx/cns3xxx_symbol.h
new file mode 100644
index 0000000..8766db4
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_symbol.h
@@ -0,0 +1,250 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+/* the symbol define memory map register. */
+
+#ifndef CNS3XXX_SYMBOL_H
+#define CNS3XXX_SYMBOL_H
+
+#define DRV_VERSION "Cavium CNS3XXX Switch Driver-0.0.1"
+
+#include <mach/cns3xxx.h>
+
+#define SWITCH_REG_VALUE(offset) \
+	(*((volatile unsigned int *)(CNS3XXX_SWITCH_BASE_VIRT+offset)))
+
+#define NETDEV_SIZE (4097+3)
+
+#define PORT0_NETDEV_INDEX (NETDEV_SIZE-3)
+#define PORT1_NETDEV_INDEX (NETDEV_SIZE-2)
+#define PORT2_NETDEV_INDEX (NETDEV_SIZE-1)
+
+#define PORT0_NETDEV net_dev_array[PORT0_NETDEV_INDEX]
+#define PORT1_NETDEV net_dev_array[PORT1_NETDEV_INDEX]
+#define PORT2_NETDEV net_dev_array[PORT2_NETDEV_INDEX]
+
+/* for VLAN and ARL table MB_PMAP */
+#define MAC_PORT0_PMAP 1
+#define MAC_PORT1_PMAP (1 << 1)
+#define MAC_PORT2_PMAP (1 << 4)
+#define CPU_PORT_PMAP (1 << 2)
+
+/* memory map register definition */
+
+#define PHY_CTRL_REG SWITCH_REG_VALUE(0x0)
+#define PHY_AUTO_ADDR_REG SWITCH_REG_VALUE(0x04)
+
+#define MAC_GLOB_CFG_REG SWITCH_REG_VALUE(0x08)
+#define MAC_GLOB_CFG_EXT_REG SWITCH_REG_VALUE(0xf4)
+#define MAC0_CFG_REG SWITCH_REG_VALUE(0x0c)
+#define MAC1_CFG_REG SWITCH_REG_VALUE(0x10)
+#define MAC2_CFG_REG SWITCH_REG_VALUE(0x18)
+#define CPU_CFG_REG SWITCH_REG_VALUE(0x14)
+
+#define MAC0_PRI_CTRL_REG SWITCH_REG_VALUE(0x1c)
+#define MAC1_PRI_CTRL_REG SWITCH_REG_VALUE(0x20)
+#define CPU_PRI_CTRL_REG SWITCH_REG_VALUE(0x24)
+#define HNAT_PRI_CTRL_REG SWITCH_REG_VALUE(0x28)
+#define MAC2_PRI_CTRL_REG SWITCH_REG_VALUE(0x2c)
+
+#define MAC0_PRI_CTRL_EXT_REG SWITCH_REG_VALUE(0x30)
+
+#define ETYPE1_ETYPE0_REG SWITCH_REG_VALUE(0x34)
+#define ETYPE3_ETYPE2_REG SWITCH_REG_VALUE(0x38)
+
+#define UDP_RANGE0_REG SWITCH_REG_VALUE(0x3c)
+#define UDP_RANGE1_REG SWITCH_REG_VALUE(0x40)
+#define UDP_RANGE2_REG SWITCH_REG_VALUE(0x44)
+#define UDP_RANGE3_REG SWITCH_REG_VALUE(0x48)
+
+
+#define PRIO_ETYPE_UDP_REG SWITCH_REG_VALUE(0x4c)
+
+#define PRIO_IPDSCP_7_0_REG SWITCH_REG_VALUE(0x50)
+#define PRIO_IPDSCP_15_8_REG SWITCH_REG_VALUE(0x54)
+#define PRIO_IPDSCP_23_16_REG SWITCH_REG_VALUE(0x58)
+#define PRIO_IPDSCP_31_24_REG SWITCH_REG_VALUE(0x5c)
+#define PRIO_IPDSCP_39_32_REG SWITCH_REG_VALUE(0x60)
+#define PRIO_IPDSCP_47_40_REG SWITCH_REG_VALUE(0x64)
+#define PRIO_IPDSCP_55_48_REG SWITCH_REG_VALUE(0x68)
+#define PRIO_IPDSCP_63_56_REG SWITCH_REG_VALUE(0x6c)
+
+#define TC_CTRL_REG SWITCH_REG_VALUE(0x70)
+#define RATE_CTRL_REG SWITCH_REG_VALUE(0x74)
+
+#define FC_GLOB_THRS_REG SWITCH_REG_VALUE(0x78)
+#define FC_PORT_THRS_REG SWITCH_REG_VALUE(0x7c)
+#define MC_GLOB_THRS_REG SWITCH_REG_VALUE(0x80)
+#define DC_GLOB_THRS_REG SWITCH_REG_VALUE(0x84)
+
+#define ARL_VLAN_CMD_REG SWITCH_REG_VALUE(0x88)
+
+#define ARL_CTRL0_REG SWITCH_REG_VALUE(0x8c)
+#define ARL_CTRL1_REG SWITCH_REG_VALUE(0x90)
+#define ARL_CTRL2_REG SWITCH_REG_VALUE(0x94)
+
+#define VLAN_CFG SWITCH_REG_VALUE(0x098)
+
+#define MAC1_MAC0_PVID_REG SWITCH_REG_VALUE(0x9c)
+#define MAC2_CPU_PVID_REG SWITCH_REG_VALUE(0xa0)
+
+#define VLAN_CTRL0_REG SWITCH_REG_VALUE(0xa4)
+#define VLAN_CTRL1_REG SWITCH_REG_VALUE(0xa8)
+#define VLAN_CTRL2_REG SWITCH_REG_VALUE(0xac)
+
+#define SESSION_ID_1_0_REG SWITCH_REG_VALUE(0xb0)
+#define SESSION_ID_3_2_REG SWITCH_REG_VALUE(0xb4)
+#define SESSION_ID_5_4_REG SWITCH_REG_VALUE(0xb8)
+#define SESSION_ID_7_6_REG SWITCH_REG_VALUE(0xbc)
+#define SESSION_ID_9_8_REG SWITCH_REG_VALUE(0xc0)
+#define SESSION_ID_11_10_REG SWITCH_REG_VALUE(0xc4)
+#define SESSION_ID_13_12_REG SWITCH_REG_VALUE(0xc8)
+#define SESSION_ID_15_14_REG SWITCH_REG_VALUE(0xcc)
+
+#define INTR_STAT_REG SWITCH_REG_VALUE(0xd0)
+#define INTR_MASK_REG SWITCH_REG_VALUE(0xd4)
+
+#define SRAM_TEST_REG SWITCH_REG_VALUE(0xd8)
+
+#define MEM_QUEUE_REG SWITCH_REG_VALUE(0xdc)
+
+#define SARL_CTRL_REG SWITCH_REG_VALUE(0xe0)
+#define SARL_OQ_GTH_REG SWITCH_REG_VALUE(0xe4)
+#define SARL_OQ_YTH_REG SWITCH_REG_VALUE(0xe8)
+#define SARL_OQ_RTH_REG SWITCH_REG_VALUE(0xec)
+
+#define SLK_SKEW_CTRL_REG SWITCH_REG_VALUE(0xf0)
+
+#define DMA_RING_CTRL_REG SWITCH_REG_VALUE(0x100)
+
+#define DMA_AUTO_POLL_CFG_REG SWITCH_REG_VALUE(0x104)
+
+#define DELAY_INTR_CFG_REG SWITCH_REG_VALUE(0x108)
+
+#define TS_DMA_CTRL0_REG SWITCH_REG_VALUE(0x110)
+#define TS_DESC_PTR0_REG  SWITCH_REG_VALUE(0x114)
+#define TS_DESC_BASE_ADDR0_REG SWITCH_REG_VALUE(0x118)
+
+#define FS_DMA_CTRL0_REG  SWITCH_REG_VALUE(0x120)
+#define FS_DESC_PTR0_REG  SWITCH_REG_VALUE(0x124)
+#define FS_DESC_BASE_ADDR0_REG SWITCH_REG_VALUE(0x128)
+
+#define TS_DMA_CTRL1_REG  SWITCH_REG_VALUE(0x130)
+#define TS_DESC_PTR1_REG  SWITCH_REG_VALUE(0x134)
+#define TS_DESC_BASE_ADDR1_REG SWITCH_REG_VALUE(0x138)
+
+#define FS_DMA_CTRL1_REG  SWITCH_REG_VALUE(0x140)
+#define FS_DESC_PTR1_REG  SWITCH_REG_VALUE(0x144)
+#define FS_DESC_BASE_ADDR1_REG SWITCH_REG_VALUE(0x148)
+
+#define TS_DMA_STA_REG  SWITCH_REG_VALUE(0x150)
+#define FS_DMA_STA_REG  SWITCH_REG_VALUE(0x154)
+
+#define TS_MRD_CMD_CNT_REG  SWITCH_REG_VALUE(0x158)
+#define TS_MWT_CMD_CNT_REG  SWITCH_REG_VALUE(0x15c)
+
+#define FS_MRD_CMD_CNT_REG  SWITCH_REG_VALUE(0x160)
+#define FS_MWT_CMD_CNT_REG  SWITCH_REG_VALUE(0x164)
+
+#define C_RXOKPKT_MAC0_REG  SWITCH_REG_VALUE(0x300)
+#define C_RXOKBYTE_MAC0_REG  SWITCH_REG_VALUE(0x304)
+#define C_RXRUNT_MAC0_REG  SWITCH_REG_VALUE(0x308)
+#define C_RXLONG_MAC0_REG  SWITCH_REG_VALUE(0x30c)
+#define C_RXDROP_MAC0_REG  SWITCH_REG_VALUE(0x310)
+#define C_RXCRC_MAC0_REG  SWITCH_REG_VALUE(0x314)
+#define C_RXARLDROP_MAC0_REG  SWITCH_REG_VALUE(0x318)
+#define C_VIDROP_MAC0_REG  SWITCH_REG_VALUE(0x31c)
+#define C_VEDROP_MAC0_REG  SWITCH_REG_VALUE(0x320)
+#define C_RXRL_MAC0_REG  SWITCH_REG_VALUE(0x324)
+#define C_RXPAUSE_MAC0_REG  SWITCH_REG_VALUE(0x328)
+
+#define C_TXOKPKT_MAC0_REG  SWITCH_REG_VALUE(0x32c)
+#define C_TXOKBYTE_MAC0_REG  SWITCH_REG_VALUE(0x330)
+#define C_TXPAUSECOL_MAC0_REG  SWITCH_REG_VALUE(0x334)
+
+#define C_RXOKPKT_MAC1_REG  SWITCH_REG_VALUE(0x400)
+#define C_RXOKBYTE_MAC1_REG  SWITCH_REG_VALUE(0x404)
+#define C_RXRUNT_MAC1_REG  SWITCH_REG_VALUE(0x408)
+#define C_RXLONG_MAC1_REG  SWITCH_REG_VALUE(0x40c)
+#define C_RXDROP_MAC1_REG  SWITCH_REG_VALUE(0x410)
+#define C_RXCRC_MAC1_REG  SWITCH_REG_VALUE(0x414)
+#define C_RXARLDROP_MAC1_REG  SWITCH_REG_VALUE(0x418)
+#define C_VIDROP_MAC1_REG  SWITCH_REG_VALUE(0x41c)
+#define C_VEDROP_MAC1_REG  SWITCH_REG_VALUE(0x420)
+#define C_RXRL_MAC1_REG  SWITCH_REG_VALUE(0x424)
+#define C_RXPAUSE_MAC1_REG  SWITCH_REG_VALUE(0x428)
+
+#define C_TXOKPKT_MAC1_REG  SWITCH_REG_VALUE(0x42c)
+#define C_TXOKBYTE_MAC1_REG  SWITCH_REG_VALUE(0x430)
+#define C_TXPAUSECOL_MAC1_REG  SWITCH_REG_VALUE(0x434)
+
+#define C_TSOKPKT_CPU_REG  SWITCH_REG_VALUE(0x500)
+#define C_TSOKBYTE_CPU_REG  SWITCH_REG_VALUE(0x504)
+#define C_TSRUNT_CPU_REG  SWITCH_REG_VALUE(0x508)
+#define C_TSLONG_CPU_REG  SWITCH_REG_VALUE(0x50c)
+#define C_TSNODSTDROP_CPU_REG  SWITCH_REG_VALUE(0x510)
+#define C_TSARLDROP_CPU_REG  SWITCH_REG_VALUE(0x514)
+#define C_TSVIDROP_CPU_REG  SWITCH_REG_VALUE(0x518)
+#define C_TSVEDROP_CPU_REG  SWITCH_REG_VALUE(0x51c)
+#define C_TSRL_CPU_REG  SWITCH_REG_VALUE(0x520)
+
+#define C_FSOKPKT_CPU_REG  SWITCH_REG_VALUE(0x524)
+#define C_FSOKBYTE_CPU_REG  SWITCH_REG_VALUE(0x528)
+
+#define C_RXOKPKT_MAC2_REG  SWITCH_REG_VALUE(0x600)
+#define C_RXOKBYTE_MAC2_REG  SWITCH_REG_VALUE(0x604)
+#define C_RXRUNT_MAC2_REG  SWITCH_REG_VALUE(0x608)
+#define C_RXLONG_MAC2_REG  SWITCH_REG_VALUE(0x60c)
+#define C_RXDROP_MAC2_REG  SWITCH_REG_VALUE(0x610)
+#define C_RXCRC_MAC2_REG  SWITCH_REG_VALUE(0x614)
+#define C_RXARLDROP_MAC2_REG  SWITCH_REG_VALUE(0x618)
+#define C_VIDROP_MAC2_REG  SWITCH_REG_VALUE(0x61c)
+#define C_VEDROP_MAC2_REG  SWITCH_REG_VALUE(0x620)
+#define C_RXRL_MAC2_REG  SWITCH_REG_VALUE(0x624)
+#define C_RXPAUSE_MAC2_REG  SWITCH_REG_VALUE(0x628)
+
+#define C_TXOKPKT_MAC2_REG  SWITCH_REG_VALUE(0x62c)
+#define C_TXOKBYTE_MAC2_REG  SWITCH_REG_VALUE(0x630)
+#define C_TXPAUSECOL_MAC2_REG  SWITCH_REG_VALUE(0x634)
+
+#define C_TXOKPKT_MAC0_EXT_REG  SWITCH_REG_VALUE(0x72c)
+#define C_TXOKBYTE_MAC0_EXT_REG  SWITCH_REG_VALUE(0x730)
+
+#define LEVEL_HIGH 0
+#define RISING_EDGE 1
+
+#define STATUS_INTERRUPT_ID 49
+
+#define FSRC_RING0_INTERRUPT_ID 51
+#define FSQF_RING0_INTERRUPT_ID 53
+
+#define FSRC_RING1_INTERRUPT_ID 55
+#define FSQF_RING1_INTERRUPT_ID 57
+
+#define TSTC_RING0_INTERRUPT_ID 50
+
+#define TSTC_RING1_INTERRUPT_ID 54
+
+#define HNAT_INTERRUPT_ID 58
+
+#endif
diff --git a/drivers/net/cns3xxx/cns3xxx_tool.h b/drivers/net/cns3xxx/cns3xxx_tool.h
new file mode 100644
index 0000000..f1aad18
--- /dev/null
+++ b/drivers/net/cns3xxx/cns3xxx_tool.h
@@ -0,0 +1,581 @@
+/*******************************************************************************
+ *
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#ifndef CNS3XXX_TOOL_H
+#define CNS3XXX_TOOL_H
+
+#define PRINT_INFO printk
+
+#include "cns3xxx.h"
+#include <linux/kernel.h>
+
+#define SHOW_DEBUG_MESSAGE
+#ifdef SHOW_DEBUG_MESSAGE
+
+extern int MSG_LEVEL;
+
+#define NO_MSG 0
+#define NORMAL_MSG 1
+#define WARNING_MSG (1 << 1)
+#define CRITICAL_MSG (1 << 2)
+#define DUMP_RX_PKT_INFO (1 << 3)
+#define DUMP_TX_PKT_INFO (1 << 4)
+
+#define DEBUG_MSG(msg_level, fmt, args...)\
+{\
+	int i = 0;\
+	for (i = 0 ; i < 3 ; ++i) { \
+		if ((MSG_LEVEL & msg_level) >> i) \
+			printk(KERN_INFO "*cns3xxx gsw debug* " fmt, ## args); \
+	} \
+}
+
+#endif
+
+#define GET_MAC_PORT_CFG(port, cfg) \
+{ \
+	switch (port) { \
+	case MAC_PORT0: \
+		cfg = MAC0_CFG_REG; \
+		break; \
+	case MAC_PORT1: \
+		cfg = MAC1_CFG_REG; \
+		break; \
+	case MAC_PORT2: \
+		cfg = MAC2_CFG_REG; \
+		break; \
+	} \
+}
+
+#define SET_MAC_PORT_CFG(port, cfg) \
+{ \
+	switch (port) { \
+	case MAC_PORT0: \
+		MAC0_CFG_REG = cfg; \
+		break; \
+	case MAC_PORT1: \
+		MAC1_CFG_REG = cfg; \
+		break; \
+	case MAC_PORT2: \
+		MAC2_CFG_REG = cfg; \
+		break; \
+	} \
+}
+
+#define between(x, start, end) ((x) >= (start) && (x) <= (end))
+static inline void print_packet(unsigned char *data, int len)
+{
+	int i, j;
+
+	printk(KERN_INFO "packet length: %d%s:\n",
+		len, len > 128 ? "(only show the first 128 bytes)" : "");
+
+	for (i = 0; len; ) {
+		printk(KERN_INFO "\t");
+		if (len >= 16) {
+			for (j = 0; j < 16; j++)
+				printk("%02x ", data[i++]);
+			printk("| ");
+
+			i -= 16;
+			for (j = 0; j < 16; j++) {
+				if (between(data[i], 0x21, 0x7e))
+					printk("%c", data[i++]);
+				else {
+					printk(".");
+					i++;
+				}
+			}
+			len -= 16;
+		} else {
+			/* last line */
+			for (j = 0; j < len; j++)
+				printk("%02x ", data[i++]);
+
+			for (; j < 16; j++)
+				printk("   ");
+
+			printk("| ");
+
+			i -= len;
+			for (j = 0; j < len; j++) {
+				if (between(data[i], 0x21, 0x7e))
+					printk("%c", data[i++]);
+				else {
+					printk(".");
+					i++;
+				}
+			}
+			len = 0;
+		}
+		printk("\n");
+    }
+    return;
+}
+
+static inline void cns3xxx_gsw_power_enable(void)
+{
+	u32 reg = __raw_readl(PM_PLL_HM_PD_CTRL_REG);
+
+	reg &= (~(1 << 2)); /* power up PLL_RGMII (for MAC)*/
+	__raw_writel(reg, PM_PLL_HM_PD_CTRL_REG);
+
+	reg = __raw_readl(PM_CLK_GATE_REG);
+	reg |= (1 << 11); /* enable switch clock*/
+	__raw_writel(reg, PM_CLK_GATE_REG);
+}
+
+static inline void cns3xxx_gsw_software_reset(void)
+{
+	u32 reg = __raw_readl(PM_SOFT_RST_REG);
+	reg &= (~(1 << 11));
+	__raw_writel(reg, PM_SOFT_RST_REG);
+
+	reg = __raw_readl(PM_SOFT_RST_REG);
+	reg |= (1 << 11);
+	__raw_writel(reg, PM_SOFT_RST_REG);
+}
+
+/* port:
+ * 0 : mac port0
+ * 1 : mac port1
+ * 2 : mac port2
+ * 3 : cpu port
+ */
+static inline void enable_port(u8 port, u8 enable)
+{
+	switch (port) {
+	case 0:
+		(enable == 1) ?
+			(MAC0_CFG_REG &= (~(1 << 18))) :
+			(MAC0_CFG_REG |= (1 << 18)) ;
+		break;
+	case 1:
+		(enable == 1) ?
+			(MAC1_CFG_REG &= (~(1 << 18))) :
+			(MAC1_CFG_REG |= (1 << 18)) ;
+		break;
+	case 2:
+		(enable == 1) ?
+			(MAC2_CFG_REG &= (~(1 << 18))) :
+			(MAC2_CFG_REG |= (1 << 18)) ;
+		break;
+	case 3:
+		(enable == 1) ?
+			(CPU_CFG_REG &= (~(1 << 18))) :
+			(CPU_CFG_REG |= (1 << 18)) ;
+		break;
+	}
+}
+
+static inline int cns3xxx_vlan_table_lookup(struct VLANTableEntry *entry)
+{
+	VLAN_CTRL2_REG |= entry->vid;
+	ARL_VLAN_CMD_REG |= (1 << 8); /* look up vlan table command*/
+
+	/* wait for vlan command complete*/
+	while (((ARL_VLAN_CMD_REG >> 9) & 1) == 0)
+		;
+
+	if (!((ARL_VLAN_CMD_REG >> 10) & 1))
+		return CAVM_NOT_FOUND;
+
+	entry->valid = ((VLAN_CTRL0_REG >> 31) & 0x1);
+	entry->vid = ((VLAN_CTRL2_REG >> 31) & 0xfff);
+	entry->wan_side = ((VLAN_CTRL0_REG >> 30) & 0x1);
+	entry->etag_pmap = ((VLAN_CTRL0_REG >> 25) & 0x1f);
+	entry->mb_pmap = ((VLAN_CTRL0_REG >> 9) & 0x1f);
+
+	entry->my_mac[0] = ((VLAN_CTRL1_REG >> 24) & 0xff);
+	entry->my_mac[1] = ((VLAN_CTRL1_REG >> 16) & 0xff);
+	entry->my_mac[2] = ((VLAN_CTRL1_REG >> 8) & 0xff);
+	entry->my_mac[3] = (VLAN_CTRL1_REG & 0xff);
+
+	entry->my_mac[4] = ((VLAN_CTRL2_REG >> 24) & 0xff);
+	entry->my_mac[5] = ((VLAN_CTRL2_REG >> 16) & 0xff);
+
+	return CAVM_FOUND;
+}
+
+static inline int cns3xxx_vlan_table_read(struct VLANTableEntry *entry)
+{
+	ARL_VLAN_CMD_REG &= (~0x3f);
+	ARL_VLAN_CMD_REG |= (entry->vlan_index);
+	ARL_VLAN_CMD_REG |= (1 << 7); /* read vlan table command*/
+
+	/* wait for vlan command complete*/
+	while (((ARL_VLAN_CMD_REG >> 9) & 1) == 0)
+		;
+
+	entry->valid = ((VLAN_CTRL0_REG >> 31) & 0x1);
+	entry->vid = ((VLAN_CTRL2_REG) & 0xfff);
+	entry->wan_side = ((VLAN_CTRL0_REG >> 30) & 0x1);
+	entry->etag_pmap = ((VLAN_CTRL0_REG >> 25) & 0x1f);
+	entry->mb_pmap = ((VLAN_CTRL0_REG >> 9) & 0x1f);
+
+	entry->my_mac[0] = ((VLAN_CTRL1_REG >> 24) & 0xff);
+	entry->my_mac[1] = ((VLAN_CTRL1_REG >> 16) & 0xff);
+	entry->my_mac[2] = ((VLAN_CTRL1_REG >> 8) & 0xff);
+	entry->my_mac[3] = (VLAN_CTRL1_REG & 0xff);
+
+	entry->my_mac[4] = ((VLAN_CTRL2_REG >> 24) & 0xff);
+	entry->my_mac[5] = ((VLAN_CTRL2_REG >> 16) & 0xff);
+
+	return CAVM_OK;
+}
+
+/* add a entry in the vlan table */
+static inline int cns3xxx_vlan_table_add(struct VLANTableEntry *entry)
+{
+	VLAN_CTRL0_REG = 0;
+	VLAN_CTRL1_REG = 0;
+	VLAN_CTRL2_REG = 0;
+
+	VLAN_CTRL0_REG |= (entry->valid << 31);
+	VLAN_CTRL0_REG |= (entry->wan_side << 30);
+	VLAN_CTRL0_REG |= (entry->etag_pmap << 25);
+	VLAN_CTRL0_REG |= (entry->mb_pmap << 9);
+
+	VLAN_CTRL1_REG |= (entry->my_mac[0] << 24);
+	VLAN_CTRL1_REG |= (entry->my_mac[1] << 16);
+	VLAN_CTRL1_REG |= (entry->my_mac[2] << 8);
+	VLAN_CTRL1_REG |= (entry->my_mac[3]);
+
+	VLAN_CTRL2_REG |= (entry->my_mac[4] << 24);
+	VLAN_CTRL2_REG |= (entry->my_mac[5] << 16);
+	VLAN_CTRL2_REG |= entry->vid;
+
+	ARL_VLAN_CMD_REG &= (~0x3f);
+	ARL_VLAN_CMD_REG |= (entry->vlan_index);
+	ARL_VLAN_CMD_REG |= (1 << 6); /* write vlan table command */
+
+	/* wait for vlan command complete*/
+	while (((ARL_VLAN_CMD_REG >> 9) & 1) == 0)
+		;
+
+	return CAVM_OK;
+}
+
+static inline int cns3xxx_arl_table_lookup(struct ARLTableEntry *entry)
+{
+	ARL_CTRL0_REG = 0;
+	ARL_CTRL1_REG = 0;
+	ARL_CTRL2_REG = 0;
+
+	ARL_CTRL0_REG |= (entry->vid << 16);
+
+	ARL_CTRL1_REG |= (entry->mac[0] << 24);
+	ARL_CTRL1_REG |= (entry->mac[1] << 16);
+	ARL_CTRL1_REG |= (entry->mac[2] << 8);
+	ARL_CTRL1_REG |= entry->mac[3];
+
+	ARL_CTRL2_REG |= (entry->mac[4] << 24);
+	ARL_CTRL2_REG |= (entry->mac[5] << 16);
+
+	ARL_VLAN_CMD_REG |= (1 << 18); /* arl table lookup command*/
+
+	/* wait arl command complete */
+	while (((ARL_VLAN_CMD_REG >> 21) & 1) == 0)
+		;
+
+	if (((ARL_VLAN_CMD_REG >> 23) & 1)) {
+		entry->vid = ((ARL_CTRL0_REG >> 16) & 0xfff);
+		entry->pmap = ((ARL_CTRL0_REG >> 9) & 0x1f);
+
+		entry->age_field = ((ARL_CTRL2_REG >> 4) & 0x7);
+		entry->vlan_mac = ((ARL_CTRL2_REG >> 1) & 0x1);
+		entry->filter = (ARL_CTRL2_REG & 0x1);
+		return CAVM_FOUND;
+	} else
+		return CAVM_NOT_FOUND;
+
+
+}
+
+static inline int
+	cns3xxx_arl_table_search_again(struct ARLTableEntry *entry)
+{
+	ARL_CTRL0_REG = 0;
+	ARL_CTRL1_REG = 0;
+	ARL_CTRL2_REG = 0;
+
+	ARL_VLAN_CMD_REG |= (1 << 17); /* arl table search again command*/
+
+	/* wait arl command complete */
+	while (((ARL_VLAN_CMD_REG >> 21) & 1) == 0)
+		;
+
+	if ((ARL_VLAN_CMD_REG >> 23) & 1) {
+		entry->vid = ((ARL_CTRL0_REG >> 16) & 0xfff);
+		entry->pmap = ((ARL_CTRL0_REG >> 9) & 0x1f);
+
+		entry->age_field = ((ARL_CTRL2_REG >> 4) & 0x7);
+		entry->vlan_mac = ((ARL_CTRL2_REG >> 1) & 0x1);
+		entry->filter = (ARL_CTRL2_REG & 0x1);
+
+		entry->mac[0] = (ARL_CTRL1_REG >> 24);
+		entry->mac[1] = (ARL_CTRL1_REG >> 16);
+		entry->mac[2] = (ARL_CTRL1_REG >> 8);
+		entry->mac[3] = ARL_CTRL1_REG;
+
+		entry->mac[4] = (ARL_CTRL2_REG >> 24);
+		entry->mac[5] = (ARL_CTRL2_REG >> 16);
+
+		return CAVM_FOUND;
+	} else
+		return CAVM_NOT_FOUND;
+}
+
+static inline int cns3xxx_is_arl_table_end(void)
+{
+	ARL_CTRL0_REG = 0;
+	ARL_CTRL1_REG = 0;
+	ARL_CTRL2_REG = 0;
+
+	if (((ARL_VLAN_CMD_REG >> 22) & 1)) /* search to table end*/
+		return CAVM_OK;
+	else
+		return CAVM_ERR;
+}
+
+static inline int cns3xxx_arl_table_search(struct ARLTableEntry *entry)
+{
+	ARL_CTRL0_REG = 0;
+	ARL_CTRL1_REG = 0;
+	ARL_CTRL2_REG = 0;
+
+	printk(KERN_INFO "ARL_VLAN_CMD_REG: %x\n", ARL_VLAN_CMD_REG);
+	ARL_VLAN_CMD_REG |= (1 << 16); /* arl table search start command */
+	printk(KERN_INFO "11 ARL_VLAN_CMD_REG: %x\n", ARL_VLAN_CMD_REG);
+
+	/* wait arl command complete */
+	while (((ARL_VLAN_CMD_REG >> 21) & 1) == 0)
+		;
+
+	if (((ARL_VLAN_CMD_REG >> 23) & 1)) {
+		entry->vid = ((ARL_CTRL0_REG >> 16) & 0xfff);
+		entry->pmap = ((ARL_CTRL0_REG >> 9) & 0x1f);
+
+		entry->age_field = ((ARL_CTRL2_REG >> 4) & 0x7);
+		entry->vlan_mac = ((ARL_CTRL2_REG >> 1) & 0x1);
+		entry->filter = (ARL_CTRL2_REG & 0x1);
+
+		entry->mac[0] = (ARL_CTRL1_REG >> 24);
+		entry->mac[1] = (ARL_CTRL1_REG >> 16);
+		entry->mac[2] = (ARL_CTRL1_REG >> 8);
+		entry->mac[3] = ARL_CTRL1_REG;
+
+		entry->mac[4] = (ARL_CTRL2_REG >> 24);
+		entry->mac[5] = (ARL_CTRL2_REG >> 16);
+
+		return CAVM_FOUND;
+	} else
+		return CAVM_NOT_FOUND;
+}
+
+
+/* flush all age out entries except static entries*/
+static inline int cns3xxx_arl_table_flush(void)
+{
+	ARL_VLAN_CMD_REG |= (1 << 20); /*flush arl table command*/
+
+	/* wait arl command complete */
+	while (((ARL_VLAN_CMD_REG >> 21) & 1) == 0)
+		;
+
+	return CAVM_OK;
+}
+
+
+/* add a entry in the arl table */
+static inline int cns3xxx_arl_table_add(struct ARLTableEntry *entry)
+{
+	ARL_CTRL0_REG = 0;
+	ARL_CTRL1_REG = 0;
+	ARL_CTRL2_REG = 0;
+
+	entry->age_field = 7; /* static entry */
+	ARL_CTRL0_REG |= (entry->vid << 16);
+	ARL_CTRL0_REG |= (entry->pmap << 9);
+
+	ARL_CTRL1_REG |= (entry->mac[0] << 24);
+	ARL_CTRL1_REG |= (entry->mac[1] << 16);
+	ARL_CTRL1_REG |= (entry->mac[2] << 8);
+	ARL_CTRL1_REG |= entry->mac[3];
+
+	ARL_CTRL2_REG |= (entry->mac[4] << 24);
+	ARL_CTRL2_REG |= (entry->mac[5] << 16);
+
+	ARL_CTRL2_REG |= (entry->age_field << 4);
+	ARL_CTRL2_REG |= (entry->vlan_mac << 1);
+	ARL_CTRL2_REG |= (entry->filter);
+
+	ARL_VLAN_CMD_REG |= (1 << 19); /* arl table write command*/
+
+	/* wait arl command complete */
+	while (((ARL_VLAN_CMD_REG >> 21) & 1) == 0)
+		;
+
+	return CAVM_OK;
+}
+
+/* invalid a entry in the arl table*/
+static inline int cns3xxx_arl_table_invalid(struct ARLTableEntry *entry)
+{
+	entry->age_field = 0;
+	return cns3xxx_arl_table_add(entry);
+}
+
+/* port:
+ * 0 : mac port0
+ * 1 : mac port1
+ * 2 : mac port2
+ * 3 : cpu port
+ */
+static inline void cns3xxx_set_pvid(u8 port, u16 pvid)
+{
+	switch (port) {
+	case 0:
+		MAC1_MAC0_PVID_REG &= (~0x0fff);
+		MAC1_MAC0_PVID_REG |= pvid;
+		break;
+	case 1:
+		MAC1_MAC0_PVID_REG &= (~(0x0fff << 16));
+		MAC1_MAC0_PVID_REG |= (pvid << 16);
+		break;
+	case 2:
+		MAC2_CPU_PVID_REG &= (~(0x0fff << 16));
+		MAC2_CPU_PVID_REG |= (pvid << 16);
+		break;
+	case 3:
+		MAC2_CPU_PVID_REG &= (~0x0fff);
+		MAC2_CPU_PVID_REG |= pvid;
+		break;
+	}
+}
+
+static inline u16 cns3xxx_get_pvid(u8 port)
+{
+	/* 0,     1,   2,    cpu port */
+	u16 port_offset[] = {0x9c, 0x9c, 0xa0, 0xa0};
+	u16 port_shift[] = {0, 16, 16, 0};
+
+	return (SWITCH_REG_VALUE(port_offset[port]) >> port_shift[port])
+		& 0xfff;
+}
+
+/* which : 0 or 1
+ * enable: 0 or 1
+ */
+static inline int enable_rx_dma(u8 which, u8 enable)
+{
+	if (which == 0)
+		FS_DMA_CTRL0_REG = enable;
+	else if (which == 1)
+		FS_DMA_CTRL1_REG = enable;
+	else
+		return CAVM_ERR;
+	return CAVM_OK;
+}
+
+/* which : 0 or 1
+ * enable: 0 or 1
+ */
+static inline int enable_tx_dma(u8 which, u8 enable)
+{
+	if (which == 0)
+		TS_DMA_CTRL0_REG = enable;
+	else if (which == 1)
+		TS_DMA_CTRL1_REG = enable;
+	else
+		return CAVM_ERR;
+	return CAVM_OK;
+}
+
+/* clear: 0 normal
+ * clear: 1 clear
+ */
+static inline void clear_fs_dma_state(u8 clear)
+{
+}
+
+/* enable: 1 -> IVL
+ * enable: 0 -> SVL
+ */
+static inline void cns3xxx_ivl(u8 enable)
+{
+	MAC_GLOB_CFG_REG &= (~(0x1 << 7));
+	if (enable == 1)
+		MAC_GLOB_CFG_REG |= (0x1 << 7);
+}
+
+static inline void cns3xxx_disable_irq(u32 irq)
+{
+	disable_irq_nosync(irq);
+}
+
+static inline void cns3xxx_enable_irq(u32 irq)
+{
+	enable_irq(irq);
+}
+
+static inline int cns3xxx_get_tx_hw_index(u8 ring_index)
+{
+	if (ring_index == 0)
+		return (TS_DESC_PTR0_REG - TS_DESC_BASE_ADDR0_REG) /
+			sizeof(struct TXDesc);
+	else if (ring_index == 1)
+		return (TS_DESC_PTR1_REG - TS_DESC_BASE_ADDR1_REG) /
+			sizeof(struct TXDesc);
+	else
+		return CAVM_ERR;
+}
+
+static inline struct TXBuffer *get_tx_buffer_by_index(
+	struct TXRing *tx_ring, int i)
+{
+	int index = i;
+	index = ((index + get_tx_ring_size(tx_ring)) %
+		get_tx_ring_size(tx_ring));
+
+	return tx_ring->head + index;
+}
+
+static inline int cns3xxx_is_untag_packet(const struct RXDesc *rx_desc)
+{
+	return rx_desc->crc_err;
+}
+
+static inline int cns3xxx_min_mtu(void)
+{
+	return 64;
+}
+
+static inline int cns3xxx_max_mtu(void)
+{
+	int max_len[] = {1518, 1522, 1536, 9600};
+	return max_len[((PHY_AUTO_ADDR_REG >> 30) & 0x3)];
+}
+
+#endif
diff --git a/drivers/net/cns3xxx/pse_init.c b/drivers/net/cns3xxx/pse_init.c
new file mode 100644
index 0000000..a8e3fde
--- /dev/null
+++ b/drivers/net/cns3xxx/pse_init.c
@@ -0,0 +1,370 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <mach/cns3xxx.h>
+
+#include "cns3xxx.h"
+#include "cns3xxx_tool.h"
+#include "cns3xxx_init_config.h"
+#include "pse_init_common.h"
+
+#ifdef CONFIG_CNS3XXX_GSW_VB
+#include "vb.h"
+#endif
+
+int init_port = 7; /* bit map 7 means port 0, 1 and 2, default is 7. */
+module_param(init_port, int, 0);
+
+void take_off_vlan_header(struct sk_buff *skb)
+{
+	memmove(skb->data + 4, skb->data, 12);
+	skb->data += 4;
+	skb->len -= 4; /* minus 4 byte vlan tag */
+}
+
+int rx_port_base(
+	struct sk_buff *skb, struct RXDesc *rx_desc_ptr,
+	const struct CNS3XXXPrivate *priv)
+{
+	if (skb->data[12] == 0x81 && skb->data[13] == 0x00) {
+		/*VLAN Header */
+		printk(KERN_INFO "take_off_vlan_header\n");
+		take_off_vlan_header(skb);
+	}
+	return 0;
+}
+
+int rx_vlan_base(
+	struct sk_buff *skb, struct RXDesc *rx_desc_ptr,
+	const struct CNS3XXXPrivate *priv)
+{
+	return 0;
+}
+
+int tx_port_base(
+	struct TXDesc *tx_desc_ptr,
+	const struct CNS3XXXPrivate *priv,
+	struct sk_buff *skb)
+{
+#if defined(CNS3XXX_VLAN_8021Q) && defined(CNS3XXX_8021Q_HW_TX)
+	if (skb && priv->vlgrp != NULL && vlan_tx_tag_present(skb)) {
+		tx_desc_ptr->c_vid = cpu_to_le16(vlan_tx_tag_get(skb));
+		tx_desc_ptr->ctv = 1;
+		tx_desc_ptr->fr	= 0;
+	} else
+#endif
+	{
+		tx_desc_ptr->ctv = 0;
+		tx_desc_ptr->pmap = priv->net_device_priv->pmap;
+		tx_desc_ptr->fr	= 1;
+	}
+	return 0;
+}
+
+int tx_vlan_base(
+	struct TXDesc *tx_desc_ptr,
+	const struct CNS3XXXPrivate *priv,
+	struct sk_buff *skb)
+{
+#if defined(CNS3XXX_VLAN_8021Q)
+	if (skb && priv->vlgrp != NULL && vlan_tx_tag_present(skb))
+		tx_desc_ptr->c_vid = cpu_to_le16(vlan_tx_tag_get(skb));
+#else
+	tx_desc_ptr->c_vid = priv->net_device_priv->vlan_tag;
+#endif
+	tx_desc_ptr->ctv = 1;
+	tx_desc_ptr->fr	= 0;
+
+	return 0;
+}
+
+/* port: 0, 1, 2 ; port0, port1 and port2
+ * config general mac port configuration
+ */
+void cns3xxx_general_mac_cfg(u8 port)
+{
+	u32 cfg = 0;
+
+	switch (port) {
+	case 0:
+		cfg = MAC0_CFG_REG;
+		break;
+	case 1:
+		cfg = MAC1_CFG_REG;
+		break;
+	case 2:
+		cfg = MAC2_CFG_REG;
+		break;
+	}
+
+	cfg |= (1 << 13);	/* txc_check_en: 1  */
+	cfg |= (1 << 17);	/* bp_en: 1 */
+
+#ifdef CNS3XXX_LEARN_ENABLE
+	cfg &= (~(1 << 19)); /* learn_dis: 0 */
+#else
+	cfg |= (1 << 19);	/* learn disable, learn_dis: 1*/
+#endif
+	cfg &= (~(1 << 20));	/* blocking_state: 0 */
+
+	cfg &= (~(1 << 21));	/* block_mode: 0 */
+
+#ifdef CNS3XXX_AGE_ENABLE
+	cfg |= (1 << 22);	/* age_en: 1 */
+#else
+	cfg &= (~(1 << 22));	/* age disable,age_en: 1 */
+#endif
+	cfg &= (~(1 << 23)); /* SA_secured: 0 */
+	switch (port) {
+	case 0:
+		MAC0_CFG_REG = cfg;
+		break;
+	case 1:
+		MAC1_CFG_REG = cfg;
+		break;
+	case 2:
+		MAC2_CFG_REG = cfg;
+		break;
+	}
+}
+
+void cns3xxx_configu_cpu_port(void)
+{
+/* Set CPU port to general configuration */
+
+#ifdef CNS3XXX_LEARN_ENABLE
+	CPU_CFG_REG &= (~(1 << 19)); /* learn_dis: 0 */
+#else
+	CPU_CFG_REG |= (1 << 19); /* learn_dis: 1 */
+#endif
+
+#ifdef CNS3XXX_AGE_ENABLE
+	CPU_CFG_REG |= (1 << 22); /* age_en: 1 */
+#else
+	CPU_CFG_REG &= (~(1 << 22)); /* age disable age_en: 0 */
+#endif
+	CPU_CFG_REG &= (~(1 << 23)); /* SA_secured: 0 */
+	CPU_CFG_REG |= (1 << 29); /* go to hnat:1 */
+	CPU_CFG_REG &= (~(1 << 30)); /* offset 4N +2 */
+#ifdef CNS3XXX_4N
+	CPU_CFG_REG |= (1 << 30);
+#endif
+	CPU_CFG_REG &= (~(1 << 31)); /* cpu flow control disable */
+#ifdef CNS3XXX_CPU_PORT_FC
+	CPU_CFG_REG |= (1 << 31); /* cpu flow control enable */
+#endif
+}
+
+void cns3xxx_gsw_hw_init(void)
+{
+	int i;
+	u32 reg;
+
+	reg = __raw_readl(MISC_GPIOB_PIN_ENABLE_REG);
+	reg |= (1 << 14); /*enable GMII2_CRS*/
+	reg |= (1 << 15); /*enable GMII2_COL*/
+	reg |= (1 << 20); /*enable MDC*/
+	reg |= (1 << 21); /*enable MDIO*/
+	__raw_writel(reg, MISC_GPIOB_PIN_ENABLE_REG);
+
+	cns3xxx_pwr_clk_en(0x1 << PM_CLK_GATE_REG_OFFSET_SWITCH);
+	cns3xxx_pwr_soft_rst(0x1 << PM_CLK_GATE_REG_OFFSET_SWITCH);
+
+	/* RGMII0 high speed drive strength */
+	reg = __raw_readl(MISC_IO_PAD_DRIVE_STRENGTH_CTRL_A);
+	reg &= (~(3 << 2));
+	reg |= (2 << 2);
+
+	/* RGMII1 high speed drive strength */
+	reg &= (~(3 << 6));
+	reg |= (2 << 6);
+
+	/* GMII2 high speed drive strength*/
+	reg &= (~(3 << 10));
+	reg |= (2 << 10);
+	__raw_writel(reg, MISC_IO_PAD_DRIVE_STRENGTH_CTRL_A);
+
+	/* RGMII0 no pull*/
+	reg = __raw_readl(MISC_IO_PULL_CTRL_REG);
+	reg &= (~(3 << 0));
+
+	/* RGMII1 no pull*/
+	reg &= (~(3 << 2));
+
+	/* GMII2 no pull*/
+	reg &= (~(3 << 4));
+	__raw_writel(reg, MISC_IO_PULL_CTRL_REG);
+
+	/* disable all ports auto polling */
+	cns3xxx_phy_auto_polling_enable(0, 0);
+	cns3xxx_phy_auto_polling_enable(1, 0);
+	cns3xxx_phy_auto_polling_enable(2, 0);
+
+	while (((SRAM_TEST_REG >> 20) & 1) == 0)
+		;
+	INTR_STAT_REG = 0xffffffff; /* write 1 for clear. */
+
+	/* Set general value for MAC_GLOB_CFG_REG
+	 * age_time: 2 ^(1-1) * 300 sec
+	 */
+	MAC_GLOB_CFG_REG &= (~0xf);
+	MAC_GLOB_CFG_REG |= 1;
+
+	/* bkoff_mode: 111 follow standard */
+	MAC_GLOB_CFG_REG &= (~(0x7 << 9));
+	MAC_GLOB_CFG_REG |= (0x7 << 9);
+
+	/* jam_no: 1010: */
+	MAC_GLOB_CFG_REG &= (~(0xf << 12));
+	MAC_GLOB_CFG_REG |= (0xa << 12);
+
+	/* bp_mode: 10: */
+	MAC_GLOB_CFG_REG &= (~(0x3 << 16));
+	MAC_GLOB_CFG_REG |= (0x2 << 16);
+
+	/* res_mc_flt: 0 */
+	MAC_GLOB_CFG_REG &= (~(0x1 << 28));
+
+	/* col_mode: 11 */
+	MAC_GLOB_CFG_REG &= (~(0x3 << 18));
+	MAC_GLOB_CFG_REG |= (0x3 << 18);
+
+	/*crc_stripping: 1*/
+	MAC_GLOB_CFG_REG |= (0x1 << 20);
+
+
+	/* ACCEPT_CRC_BAD_PKT : 0*/
+	MAC_GLOB_CFG_REG &= (~(0x1 << 21));
+
+#ifdef ACCEPT_CRC_BAD_PKT
+	MAC_GLOB_CFG_REG |= (0x1 << 21);
+#endif
+
+	/* SVL */
+	MAC_GLOB_CFG_REG &= (~(0x1 << 7));
+
+#ifdef IVL
+	/* IVL: 1 (IVL), 0 (SVL) */
+	MAC_GLOB_CFG_REG |= (0x1 << 7);
+#endif
+
+	/* HNAT_en: 0 */
+	MAC_GLOB_CFG_REG &= (~(0x1 << 26));
+
+	/* Firewall_mode: 0 */
+	MAC_GLOB_CFG_REG &= (~(0x1 << 27));
+
+	cns3xxx_general_mac_cfg(0);
+	cns3xxx_general_mac_cfg(1);
+	cns3xxx_general_mac_cfg(2);
+	cns3xxx_configu_cpu_port();
+
+	/* write vlan table
+	 * set cpu port vlan table
+	 */
+	cns3xxx_vlan_table_add(&cpu_vlan_table_entry);
+	for (i = 0;
+		i < sizeof(vlan_table_entry) / sizeof(struct VLANTableEntry);
+		++i)
+		cns3xxx_vlan_table_add(&vlan_table_entry[i]);
+
+	cns3xxx_set_pvid(0, PORT0_PVID);
+	cns3xxx_set_pvid(1, PORT1_PVID);
+	cns3xxx_set_pvid(2, PORT2_PVID);
+	cns3xxx_set_pvid(3, CPU_PVID);
+
+#ifdef CNS3XXX_SET_ARL_TABLE
+	/* set arl table */
+	cns3xxx_arl_table_flush();
+#endif
+}
+
+int cns3xxx_gsw_config_mac_port0(void)
+{
+	INIT_PORT0_PHY
+	INIT_PORT0_MAC
+	PORT0_LINK_DOWN
+	return 0;
+}
+
+int cns3xxx_gsw_config_mac_port1(void)
+{
+	INIT_PORT1_PHY
+	INIT_PORT1_MAC
+	PORT1_LINK_DOWN
+	return 0;
+}
+
+int cns3xxx_gsw_config_mac_port2(void)
+{
+	INIT_PORT2_PHY
+	INIT_PORT2_MAC
+	PORT2_LINK_DOWN
+	return 0;
+}
+
+void cns3xxx_gsw_up_init(void)
+{
+	cns3xxx_gsw_hw_init();
+
+	printk(KERN_INFO "CNS3XXX PSE: Initialize\n");
+
+	if ((init_port & 1) == 1) {
+		printk(KERN_INFO "MAC 0\n");
+		cns3xxx_gsw_config_mac_port0();
+	}
+
+	if (((init_port >> 1) & 1) == 1) {
+		printk(KERN_INFO "MAC 1\n");
+		cns3xxx_gsw_config_mac_port1();
+	}
+
+	if (((init_port >> 2) & 1) == 1) {
+		printk(KERN_INFO "MAC 2\n");
+		cns3xxx_gsw_config_mac_port2();
+	}
+}
+EXPORT_SYMBOL_GPL(cns3xxx_gsw_up_init);
+
+static int __init cns3xxx_pse_init_init_module(void)
+{
+	return 0;
+}
+
+static void __exit cns3xxx_pse_init_exit_module(void)
+{
+	/* disable phy auto-poll */
+	PHY_AUTO_ADDR_REG &= ~((1<<5) | (1<<13) | (1<<21));
+	/* wait state machine idle	*/
+	mdelay(1000);
+}
+
+MODULE_AUTHOR("Cavium Networks, <tech@XXXX.com>");
+MODULE_DESCRIPTION("CNS3XXX PSE Init");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(cns3xxx_pse_init_init_module);
+module_exit(cns3xxx_pse_init_exit_module);
diff --git a/drivers/net/cns3xxx/pse_init_common.h b/drivers/net/cns3xxx/pse_init_common.h
new file mode 100644
index 0000000..ace7aca
--- /dev/null
+++ b/drivers/net/cns3xxx/pse_init_common.h
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2008 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * Technology Support <tech@starsemi.com>
+ * Star Semiconductor 4F, No.1, Chin-Shan 8th St, Hsin-Chu,300 Taiwan, R.O.C
+ *
+ ******************************************************************************/
+
+#include "switch_api.h"
+#include "cns3xxx.h"
+
+#ifndef __PSE_INIT_COMMON_H
+#define __PSE_INIT_COMMON_H
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define CNS3XXX_VLAN_8021Q
+#endif
+
+#define CNS3XXX_8021Q_HW_TX
+
+extern int is_cns3xxx_nic_mode_8021q(void);
+extern int is_cns3xxx_non_nic_mode_8021q(void);
+extern int is_cns3xxx_vlan_base_mode(void);
+extern int is_cns3xxx_port_base_mode(void);
+extern int is_config_cns3xxx_port_base(void);
+extern int is_config_cns3xxx_vlan_base(void);
+extern int is_config_have_vlan_tag(void);
+extern void cns3xxx_gsw_up_init(void);
+extern void cns3xxx_gsw_sop_init(void);
+extern ushort jumbo_frame;
+extern struct VLANTableEntry cpu_vlan_table_entry;
+extern struct VLANTableEntry vlan_table_entry[];
+extern struct ARLTableEntry arl_table_entry[];
+extern struct NetDevicePriv net_device_prive[];
+extern int num_net_dev_priv;
+
+#endif
diff --git a/drivers/net/cns3xxx/switch_api.h b/drivers/net/cns3xxx/switch_api.h
new file mode 100644
index 0000000..b06c8ad
--- /dev/null
+++ b/drivers/net/cns3xxx/switch_api.h
@@ -0,0 +1,314 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2008 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * Technology Support <tech@starsemi.com>
+ * Star Semiconductor 4F, No.1, Chin-Shan 8th St, Hsin-Chu,300 Taiwan, R.O.C
+ *
+ ******************************************************************************/
+
+#ifndef SWITCH_API_H_K
+#define SWITCH_API_H_K
+
+#include <linux/types.h>
+
+#define CAVM_OK 0
+#define CAVM_ERR 1
+#define CAVM_NOT_FOUND 2
+#define CAVM_FOUND 3
+#define CAVM_FAIL -1
+
+#define MAC_PORT0 0
+#define MAC_PORT1 1
+#define MAC_PORT2 2
+#define CPU_PORT 3
+
+enum CNS3XXXIoctlCmd {
+	CNS3XXX_ARL_TABLE_LOOKUP,
+	CNS3XXX_ARL_TABLE_ADD,
+	CNS3XXX_ARL_TABLE_DEL,
+	CNS3XXX_ARL_TABLE_SEARCH,
+	CNS3XXX_ARL_TABLE_SEARCH_AGAIN,
+	CNS3XXX_ARL_IS_TABLE_END,
+	CNS3XXX_ARL_TABLE_FLUSH,
+
+	CNS3XXX_VLAN_TABLE_LOOKUP,
+	CNS3XXX_VLAN_TABLE_ADD,
+	CNS3XXX_VLAN_TABLE_DEL,
+	CNS3XXX_VLAN_TABLE_READ,
+
+	CNS3XXX_SKEW_SET,
+	CNS3XXX_SKEW_GET,
+
+	CNS3XXX_BRIDGE_SET,
+	CNS3XXX_BRIDGE_GET,
+
+	CNS3XXX_PORT_NEIGHBOR_SET,
+	CNS3XXX_PORT_NEIGHBOR_GET,
+
+	CNS3XXX_HOL_PREVENT_SET,
+	CNS3XXX_HOL_PREVENT_GET,
+
+	CNS3XXX_TC_SET, /* traffic class, for 1, 2, 4, traffic class*/
+	CNS3XXX_TC_GET,
+
+	CNS3XXX_PRI_CTRL_SET,
+	CNS3XXX_PRI_CTRL_GET,
+
+	CNS3XXX_DMA_RING_CTRL_SET,
+	CNS3XXX_DMA_RING_CTRL_GET,
+
+	CNS3XXX_PRI_IP_DSCP_SET,
+	CNS3XXX_PRI_IP_DSCP_GET,
+
+	CNS3XXX_ETYPE_SET,
+	CNS3XXX_ETYPE_GET,
+
+	CNS3XXX_UDP_RANGE_SET,
+	CNS3XXX_UDP_RANGE_GET,
+
+	CNS3XXX_ARP_REQUEST_SET,
+	CNS3XXX_ARP_REQUEST_GET,
+
+	CNS3XXX_RATE_LIMIT_SET,
+	CNS3XXX_RATE_LIMIT_GET,
+
+	CNS3XXX_QUEUE_WEIGHT_SET,
+	CNS3XXX_QUEUE_WEIGHT_GET,
+
+	CNS3XXX_FC_RLS_SET,
+	CNS3XXX_FC_RLS_GET,
+
+	CNS3XXX_FC_SET_SET,
+	CNS3XXX_FC_SET_GET,
+
+	CNS3XXX_SARL_RLS_SET,
+	CNS3XXX_SARL_RLS_GET,
+
+	CNS3XXX_SARL_SET_SET,
+	CNS3XXX_SARL_SET_GET,
+
+	CNS3XXX_SARL_OQ_SET,
+	CNS3XXX_SARL_OQ_GET,
+
+	CNS3XXX_SARL_ENABLE_SET,
+	CNS3XXX_SARL_ENABLE_GET,
+
+	CNS3XXX_FC_SET,
+	CNS3XXX_FC_GET,
+
+	CNS3XXX_IVL_SET,
+	CNS3XXX_IVL_GET,
+
+	CNS3XXX_WAN_PORT_SET,
+	CNS3XXX_WAN_PORT_GET,
+
+	CNS3XXX_PVID_GET,
+	CNS3XXX_PVID_SET,
+
+	CNS3XXX_QA_GET, /* queue allocate */
+	CNS3XXX_QA_SET,
+
+	CNS3XXX_PACKET_MAX_LEN_GET, /* set maximun frame length.*/
+	CNS3XXX_PACKET_MAX_LEN_SET,
+
+	CNS3XXX_BCM53115M_REG_READ,
+	CNS3XXX_BCM53115M_REG_WRITE,
+
+	CNS3XXX_RXRING_STATUS,
+	CNS3XXX_TXRING_STATUS,
+
+	CNS3XXX_DUMP_MIB_COUNTER,
+
+	CNS3XXX_REG_READ,
+	CNS3XXX_REG_WRITE,
+};
+
+struct VLANTableEntry {
+	u8 vlan_index;
+	u8 valid;
+	u16 vid;
+	u8 wan_side;
+	u8 etag_pmap;
+	u8 mb_pmap;
+	u8 my_mac[6];
+}; /* for vlan table function*/
+
+struct ARLTableEntry {
+	u16 vid;
+	u8 pmap;
+	u8 mac[6];
+	u8 age_field;
+	u8 vlan_mac;
+	u8 filter;
+}; /* for arl table function*/
+
+
+struct CNS3XXXARLTableEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	struct ARLTableEntry entry;
+}; /* for ioctl arl ...*/
+
+struct CNS3XXXVLANTableEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	struct VLANTableEntry entry;
+}; /* for ioctl VLAN table ...*/
+
+struct CNS3XXXHOLPreventControl {
+	enum CNS3XXXIoctlCmd cmd;
+	u8 enable;
+};
+
+
+struct CNS3XXXPortNeighborControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char which_port; /* 0, 1, 2, 3 (cpu port)*/
+	unsigned char type; /*0: C-Neighbor, 1: S-Neighbor*/
+};
+
+struct CNS3XXXBridgeControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char type; /* 0: C-Component, 1: S-Component*/
+};
+
+struct CNS3XXXTrafficClassControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char tc; /* traffic class, for 1, 2, 4, traffic class*/
+};
+
+struct CNS3XXXPriCtrlControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char which_port; /* 0, 1, 2, 3 (cpu port) */
+	unsigned int val;
+	unsigned char port_pri;
+	unsigned char udp_pri_en;
+	unsigned char dscp_pri_en;
+	unsigned char vlan_pri_en;
+	unsigned char ether_pri_en;
+};
+
+struct CNS3XXXDmaRingCtrlControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char ts_double_ring_en;
+	unsigned char fs_double_ring_en;
+	unsigned char fs_pkt_allocate;
+};
+
+struct CNS3XXXPriIpDscpControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned int ip_dscp_num; /* 0 ~ 63 */
+	unsigned char pri; /* 3 bits */
+};
+
+struct CNS3XXXEtypeControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned int etype_num;
+	unsigned int val;
+	unsigned int pri;
+};
+
+struct CNS3XXXUdpRangeEtypeControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned int udp_range_num;
+	unsigned int port_start;
+	unsigned int port_end;
+	unsigned int pri;
+};
+
+struct CNS3XXXArpRequestControl {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char val; /* 0: boradcast forward, 1: redirect to the CPU*/
+};
+
+struct CNS3XXXRateLimitEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char which_port; /* 0, 1, 2, 3 (port 0 extra dma)*/
+	unsigned char band_width;
+	unsigned char base_rate;
+};  /* for ioctl arl ...*/
+
+struct CNS3XXXQueueWeightEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char which_port; /* 0, 1, 2, 3 (port 0 extra dma)*/
+	unsigned char sch_mode;
+	unsigned char q0_w;
+	unsigned char q1_w;
+	unsigned char q2_w;
+	unsigned char q3_w;
+}; /* for ioctl arl ...*/
+
+struct CNS3XXXSARLEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned int val;
+	unsigned char tc; /* 0-3*/
+	unsigned char gyr; /* 0 (green), 1(yellow), 2(red)*/
+};  /* for ioctl arl ...*/
+
+struct CNS3XXXFCEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char port; /* 0, 1, 2, 3 (cpu port) */
+	unsigned char fc_en;
+	/* 0(rx/tx disable), 1(rx enable), 2(tx enable), 3(rx/tx enable) */
+};  /* for ioctl arl ...*/
+
+struct CNS3XXXIVLEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char enable; /* enable: 1 -> IVL, enable: 0 -> SVL */
+};  /* for ioctl arl ...*/
+
+struct CNS3XXXWANPortEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char wan_port;
+}; /* for ioctl arl ...*/
+
+struct CNS3XXXPVIDEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char which_port;
+	unsigned int pvid;
+};  /* for ioctl arl ...*/
+
+struct CNS3XXXQAEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char qa; /* queue allocate */
+}; /* for ioctl arl ...*/
+
+struct CNS3XXXMaxLenEntry {
+	enum CNS3XXXIoctlCmd cmd;
+	unsigned char max_len; /* maximum frame length */
+}; /*for ioctl arl ...*/
+
+struct CNS3XXXBCM53115M {
+	enum CNS3XXXIoctlCmd cmd;
+	u8 page;
+	u8 offset;
+	u32 u32_val;
+	u16 u16_val;
+	u8 u8_val;
+	u8 data_len;
+};
+
+struct CNS3XXXMIBCounter {
+	enum CNS3XXXIoctlCmd cmd;
+	u32 mib[52];
+	u16 mib_len;
+};
+
+#endif
diff --git a/drivers/net/cns3xxx/vb.h b/drivers/net/cns3xxx/vb.h
new file mode 100644
index 0000000..2b5150f
--- /dev/null
+++ b/drivers/net/cns3xxx/vb.h
@@ -0,0 +1,436 @@
+/*******************************************************************************
+ *
+ * Copyright (c) 2009 Cavium Networks
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ ******************************************************************************/
+
+/* This macro or function divide two part,
+ * one is initial state, another is in netdev open (ifconfig up) function.
+ */
+#ifndef VB_H
+#define VB_H
+
+#include <linux/types.h>
+
+#include "cns3xxx.h"
+#include "cns3xxx_phy.h"
+
+#ifdef CONFIG_CNS3XXX_GSW_VB
+/* init phy or switch chip */
+#define INIT_PORT0_PHY bcm53115M_init(0, 0);
+#define INIT_PORT1_PHY
+#define INIT_PORT2_PHY icp_ip1001_init(2, 2);
+
+/* configure mac0/mac1 register */
+#define INIT_PORT0_MAC
+#define INIT_PORT1_MAC
+#define INIT_PORT2_MAC
+
+#define PORT0_LINK_DOWN disable_AN(0, 0);
+#define PORT0_LINK_UP disable_AN(0, 1);
+
+#define PORT1_LINK_DOWN disable_AN(1, 0);
+#define PORT1_LINK_UP disable_AN(1, 1);
+
+#define PORT2_LINK_DOWN cns3xxx_std_phy_power_down(2, 1);
+#define PORT2_LINK_UP cns3xxx_std_phy_power_down(2, 0);
+
+#define MODEL "CNS3XXX validation board"
+
+static int rc_port0;
+/* rc means reference counting, determine port open/close.*/
+
+static inline void open_port0(void)
+{
+	if (rc_port0 == 0) {
+		enable_port(0, 1);
+		/* link up */
+		PORT0_LINK_UP
+	}
+	++rc_port0;
+}
+
+static inline void close_port0(void)
+{
+	--rc_port0;
+	if (rc_port0 == 0) {
+		/* link down */
+		PORT0_LINK_DOWN
+		enable_port(0, 0);
+	}
+}
+
+static inline void open_port1(void)
+{
+
+	enable_port(1, 1);
+	/* link up */
+	PORT1_LINK_UP
+}
+
+static inline void close_port1(void)
+{
+	enable_port(1, 0);
+	/* link down */
+	PORT1_LINK_DOWN
+}
+
+static inline void open_port2(void)
+{
+	enable_port(2, 1);
+	/* link up */
+	PORT2_LINK_UP
+}
+
+static inline void close_port2(void)
+{
+	enable_port(2, 0);
+	/* link down */
+	PORT2_LINK_DOWN
+}
+
+#define my_vlan0_mac {0x00, 0x11, 0x22, 0x33, 0x55, 0x00}
+#define my_vlan1_mac {0x00, 0x11, 0x22, 0x33, 0x55, 0x11}
+#define my_vlan2_mac {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x70}
+#define my_vlan3_mac {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x80}
+
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	#ifndef CNS3XXX_NIC_MODE_8021Q
+		#define CNS3XXX_NON_NIC_MODE_8021Q
+	#endif
+#else
+	#define CNS3XXX_PORT_BASE_MODE
+#endif
+
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+#define PORT0_PVID 50
+#define PORT1_PVID 60
+#define PORT2_PVID 70
+#define CPU_PVID 80
+
+#define CONFIG_CNS3XXX_PORT_BASE
+
+struct VLANTableEntry cpu_vlan_table_entry = {
+	0, 1, CPU_PVID, 0, 0,
+	MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP,
+	my_vlan3_mac
+};
+
+struct VLANTableEntry vlan_table_entry[] = {
+	/* vlan_index; valid; vid; wan_side;
+	 * etag_pmap; mb_pmap; *my_mac;
+	 */
+	{
+		1, 1, PORT0_PVID, 0, CPU_PORT_PMAP,
+		MAC_PORT0_PMAP | CPU_PORT_PMAP,	my_vlan0_mac
+	}, {
+		2, 1, PORT1_PVID, 0, CPU_PORT_PMAP,
+		MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac
+	}, {
+		3, 1, PORT2_PVID, 0, CPU_PORT_PMAP,
+		MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac
+	},
+};
+
+struct ARLTableEntry arl_table_entry[] = {
+	/* vid; pmap; *mac; age_field; vlan_mac ; filter */
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+struct NetDevicePriv net_device_prive[] = {
+	/* pmap, is_wan, s-tag, vlan_tag or pvid, rx_func_ptr, tx_func_ptr,
+	 * open_ptr, close_ptr, which port, mac, VLANTableEntry,
+	 * ARLTableEntry, NICSetting, netdev s-tag, name
+	 */
+	{/*eth0 */
+		MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac,
+		&vlan_table_entry[0], &arl_table_entry[0], 0, 0
+	}, {/*eth1 */
+		MAC_PORT1_PMAP, 0, 2, PORT1_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac,
+		&vlan_table_entry[1], &arl_table_entry[1], 0, 0
+	}, {/*eth2 */
+		MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,
+		&vlan_table_entry[2], &arl_table_entry[2], 0, 0
+	}
+};
+#endif /* CNS3XXX_PORT_BASE_MODE*/
+
+#ifdef CNS3XXX_PORT_BASE_MODE
+
+#define PORT0_PVID 0x1
+#define PORT1_PVID 0x2
+#define PORT2_PVID 3
+#define CPU_PVID 5
+
+#define CONFIG_CNS3XXX_PORT_BASE
+
+struct VLANTableEntry cpu_vlan_table_entry = {
+	0, 1, CPU_PVID, 0, 0,
+	MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP,
+	my_vlan3_mac
+};
+
+struct VLANTableEntry vlan_table_entry[] = {
+	/* vlan_index; valid; vid; wan_side;
+	 * etag_pmap; mb_pmap; *my_mac;
+	 */
+	{
+		1, 1, PORT0_PVID, 0, 0,
+		MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac
+	}, {
+		2, 1, PORT1_PVID, 0, 0,
+		MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac
+	}, {
+		3, 1, PORT2_PVID, 1, 0,
+		MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac
+	},
+};
+
+struct ARLTableEntry arl_table_entry[] = {
+	/* vid; pmap; *mac; age_field; vlan_mac ; filter */
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+struct NetDevicePriv net_device_prive[] = {
+	/* pmap, is_wan, s-tag, vlan_tag or pvid, rx_func_ptr, tx_func_ptr,
+	 * open_ptr, close_ptr, which port, mac, VLANTableEntry,
+	 * ARLTableEntry, NICSetting, netdev s-tag, name
+	 */
+	{/*eth0 */
+		MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac,
+		&vlan_table_entry[0], &arl_table_entry[0], 0, 0
+	}, {/*eth1 */
+		MAC_PORT1_PMAP, 0, 2, PORT1_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac,
+		&vlan_table_entry[1], &arl_table_entry[1], 0, 0
+	}, {/*eth2 */
+		MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,
+		&vlan_table_entry[2], &arl_table_entry[2], 0, 0
+	}
+};
+#endif /* CNS3XXX_PORT_BASE_MODE*/
+
+#ifdef CNS3XXX_NIC_MODE_8021Q
+#define PORT0_PVID 1
+#define PORT1_PVID 2
+#define PORT2_PVID 9
+#define CPU_PVID 5
+
+#define CONFIG_CNS3XXX_PORT_BASE
+
+struct VLANTableEntry cpu_vlan_table_entry = {
+	0, 1, CPU_PVID, 0, 0,
+	MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP,
+	my_vlan3_mac
+};
+
+struct VLANTableEntry vlan_table_entry[] = {
+	/* vlan_index; valid; vid; wan_side;
+	 * etag_pmap; mb_pmap; *my_mac;C_PORT2_PMAP
+	 */
+	{
+		1, 1, PORT0_PVID, 1,
+		MAC_PORT0_PMAP|CPU_PORT_PMAP, MAC_PORT0_PMAP | CPU_PORT_PMAP,
+		my_vlan0_mac
+	}, {
+		2, 1, PORT1_PVID, 0,
+		MAC_PORT1_PMAP|CPU_PORT_PMAP, MAC_PORT1_PMAP | CPU_PORT_PMAP,
+		my_vlan1_mac
+	}, {
+		3, 1, PORT2_PVID, 1,
+		MAC_PORT2_PMAP|CPU_PORT_PMAP, MAC_PORT2_PMAP | CPU_PORT_PMAP,
+		my_vlan2_mac
+	}
+};
+
+struct ARLTableEntry arl_table_entry[] = {
+	/* vid; pmap; *mac; age_field; vlan_mac ; filter*/
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+/* if used 8021Q, use PORT0_NETDEV_INDEX, don't use VID */
+struct NetDevicePriv net_device_prive[] = {
+	{/*eth0 */
+		MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port0, close_port0, MAC_PORT0,
+		my_vlan0_mac, &vlan_table_entry[0], &arl_table_entry[0], 0, 0
+	}, {/*eth1 */
+		MAC_PORT1_PMAP, 0, 0, PORT1_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port1, close_port1, MAC_PORT1,
+		my_vlan1_mac, &vlan_table_entry[1], &arl_table_entry[1], 0, 0
+	}, {/*eth1 */
+		MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base,
+		tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,
+		&vlan_table_entry[2], &arl_table_entry[2], 0, 0
+	}
+};
+
+#endif /* CNS3XXX_NIC_MODE_8021Q */
+
+#ifdef CNS3XXX_VLAN_BASE_MODE
+/* vlan configuration*/
+
+#define PORT0_PVID 1
+#define PORT1_PVID 2
+#define PORT2_PVID 3
+#define CPU_PVID 5
+#define CONFIG_CNS3XXX_VLAN_BASE
+#define CONFIG_HAVE_VLAN_TAG
+
+struct VLANTableEntry cpu_vlan_table_entry = {
+	0, 1, CPU_PVID, 0,
+	MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP,
+	MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP,
+	my_vlan3_mac
+};
+
+struct VLANTableEntry vlan_table_entry[] = {
+	/* vlan_index; valid; vid; wan_side; etag_pmap; mb_pmap; *my_mac;*/
+	{
+		1, 1, PORT0_PVID, 0,
+		MAC_PORT0_PMAP | CPU_PORT_PMAP, MAC_PORT0_PMAP | CPU_PORT_PMAP,
+		my_vlan0_mac
+	}, {
+		2, 1, PORT1_PVID, 0,
+		MAC_PORT1_PMAP | CPU_PORT_PMAP, MAC_PORT1_PMAP | CPU_PORT_PMAP,
+		my_vlan1_mac
+	}, {
+		3, 1, PORT2_PVID, 1,
+		MAC_PORT2_PMAP | CPU_PORT_PMAP, MAC_PORT2_PMAP | CPU_PORT_PMAP,
+		my_vlan2_mac
+	},
+};
+
+struct ARLTableEntry arl_table_entry[] = {
+	/* vid; pmap; *mac; age_field; vlan_mac ; filter */
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+struct NetDevicePriv net_device_prive[] = {
+	/* pmap, is_wan, gid, vlan_tag or pvid,rx_func_ptr, tx_func_ptr,
+	 * open_ptr, close_ptr, which port, mac,
+	 * VLANTableEntry, ARLTableEntry, NICSetting, netdev name
+	 */
+	{/*eth0 */
+		MAC_PORT0_PMAP, 0, 1, PORT0_PVID, rx_port_base,
+		tx_vlan_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac,
+		&vlan_table_entry[0], &arl_table_entry[0], 0, 0
+	}, {/*eth1 */
+		MAC_PORT1_PMAP, 0, 0, PORT1_PVID, rx_port_base,
+		tx_vlan_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac,
+		&vlan_table_entry[1], &arl_table_entry[1], 0, 0
+	}, {/*eth2 */
+		MAC_PORT2_PMAP, 1, 3, PORT2_PVID, rx_port_base,
+		tx_vlan_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,
+		&vlan_table_entry[2], &arl_table_entry[2], 0, 0
+	}
+};
+#endif /* CNS3XXX_VLAN_BASE_MODE */
+
+int is_config_cns3xxx_port_base(void)
+{
+#ifdef CONFIG_CNS3XXX_PORT_BASE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_cns3xxx_port_base);
+
+int is_config_cns3xxx_vlan_base(void)
+{
+#ifdef CONFIG_CNS3XXX_VLAN_BASE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_cns3xxx_vlan_base);
+
+int is_config_have_vlan_tag(void)
+{
+#ifdef CONFIG_HAVE_VLAN_TAG
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_have_vlan_tag);
+
+
+int is_cns3xxx_nic_mode_8021q(void)
+{
+#ifdef CNS3XXX_NIC_MODE_8021Q
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_nic_mode_8021q);
+
+int is_cns3xxx_non_nic_mode_8021q(void)
+{
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_non_nic_mode_8021q);
+
+int is_cns3xxx_vlan_base_mode(void)
+{
+#ifdef CNS3XXX_VLAN_BASE_MODE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_vlan_base_mode);
+
+int is_cns3xxx_port_base_mode(void)
+{
+#ifdef CNS3XXX_PORT_BASE_MODE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_port_base_mode);
+
+int num_net_dev_priv =
+	sizeof(net_device_prive) / sizeof(struct NetDevicePriv);
+
+#endif /* CONFIG_CNS3XXX_GSW_VB*/
+#endif
-- 
1.7.0.4

