From d89e62c8f3e8fd6cd1e1343ac26209bc6aaa2020 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Mon, 12 Oct 2015 09:05:51 -0400
Subject: [PATCH 5/5] scsi/hpsa: fix calltrace when using fdisk to partition
 disk

when using fdisk to partiton the disk, the following calltrace
will appear:
[  863.373381] BUG: using smp_processor_id() in preemptible [00000000 00000000] code: fdisk/1348
[  863.373384] caller is debug_smp_processor_id+0x17/0x20
[  863.373386] CPU: 3 PID: 1348 Comm: fdisk Not tainted 4.1.10-rt8-WR8.0.0.0_preempt-rt #8
[  863.373387] Hardware name: HP ProLiant BL460c Gen8, BIOS I31 02/10/2014
[  863.373390]  ffffffff81ef6a45 ffff881007efb938 ffffffff81aca3d7 0000000080000002
[  863.373392]  0000000000000003 ffff881007efb978 ffffffff81426e75 0000000100000544
[  863.373395]  ffff880817b688c0 ffff881007efb9a8 ffff880816008000 ffff88080e804500
[  863.373395] Call Trace:
[  863.373398]  [<ffffffff81aca3d7>] dump_stack+0x4a/0x61
[  863.373401]  [<ffffffff81426e75>] check_preemption_disabled+0x135/0x140
[  863.373403]  [<ffffffff81426e97>] debug_smp_processor_id+0x17/0x20
[  863.373409]  [<ffffffffa0284fce>] __enqueue_cmd_and_start_io+0x8e/0x270 [hpsa]
[  863.373414]  [<ffffffffa0288d12>] enqueue_cmd_and_start_io+0x62/0x90 [hpsa]
[  863.373419]  [<ffffffffa0289031>] hpsa_ciss_submit+0x2f1/0x430 [hpsa]
[  863.373424]  [<ffffffffa028a5b7>] hpsa_scsi_queue_command+0x97/0x160 [hpsa]
[  863.373427]  [<ffffffff81632f54>] scsi_dispatch_cmd+0xa4/0x200
[  863.373431]  [<ffffffff8163601b>] scsi_request_fn+0x2fb/0x600
[  863.373435]  [<ffffffff81405f53>] ? cfq_insert_request+0x93/0x700
[  863.373438]  [<ffffffff813e4a47>] __blk_run_queue+0x37/0x50
[  863.373441]  [<ffffffff813e9270>] blk_queue_bio+0x350/0x360
[  863.373444]  [<ffffffff813e6ed0>] generic_make_request+0xc0/0x110
[  863.373447]  [<ffffffff813e6f85>] submit_bio+0x65/0x140
[  863.373451]  [<ffffffff811cf87c>] _submit_bh+0x11c/0x190
[  863.373454]  [<ffffffff811cfcbb>] block_read_full_page+0x2cb/0x360
[  863.373458]  [<ffffffff8105358a>] ? unpin_current_cpu+0x1a/0x80
[  863.373460]  [<ffffffff811d1ed0>] ? I_BDEV+0x10/0x10
[  863.373464]  [<ffffffff811393b8>] ? __lru_cache_add+0xb8/0xf0
[  863.373466]  [<ffffffff811d2a60>] ? blkdev_readpages+0x20/0x20
[  863.373469]  [<ffffffff811d2a78>] blkdev_readpage+0x18/0x20
[  863.373471]  [<ffffffff81129c1e>] do_read_cache_page+0x7e/0x1e0
[  863.373473]  [<ffffffff81129d9c>] read_cache_page+0x1c/0x20
[  863.373475]  [<ffffffff813fa390>] read_dev_sector+0x30/0xa0
[  863.373478]  [<ffffffff8162f691>] scsi_bios_ptable+0x41/0xd0
[  863.373481]  [<ffffffff8162f73b>] scsicam_bios_param+0x1b/0x180
[  863.373483]  [<ffffffff81662884>] sd_getgeo+0x94/0xa0
[  863.373487]  [<ffffffff813f617b>] blkdev_ioctl+0x35b/0x850
[  863.373489]  [<ffffffff811d378d>] block_ioctl+0x3d/0x50
[  863.373493]  [<ffffffff811ab7de>] do_vfs_ioctl+0x30e/0x590
[  863.373496]  [<ffffffff8109c099>] ? rt_up_read+0x19/0x20
[  863.373499]  [<ffffffff811abae1>] SyS_ioctl+0x81/0xa0
[  863.373503]  [<ffffffff81ad259b>] system_call_fastpath+0x16/0x6e

To fix this issue, use raw_smp_processor_id instead in preempt-rt context.
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>

Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/scsi/hpsa.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 8b02173..a3b596f 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -1091,7 +1091,7 @@ static void set_performant_mode(struct ctlr_info *h, struct CommandList *c,
 			return;
 		if (likely(reply_queue == DEFAULT_REPLY_QUEUE))
 			c->Header.ReplyQueue =
-				smp_processor_id() % h->nreply_queues;
+				raw_smp_processor_id() % h->nreply_queues;
 		else
 			c->Header.ReplyQueue = reply_queue % h->nreply_queues;
 	}
@@ -1107,7 +1107,7 @@ static void set_ioaccel1_performant_mode(struct ctlr_info *h,
 	 * processor.  This seems to give the best I/O throughput.
 	 */
 	if (likely(reply_queue == DEFAULT_REPLY_QUEUE))
-		cp->ReplyQueue = smp_processor_id() % h->nreply_queues;
+		cp->ReplyQueue = raw_smp_processor_id() % h->nreply_queues;
 	else
 		cp->ReplyQueue = reply_queue % h->nreply_queues;
 	/* Set the bits in the address sent down to include:
@@ -1130,7 +1130,7 @@ static void set_ioaccel2_tmf_performant_mode(struct ctlr_info *h,
 	 * processor.  This seems to give the best I/O throughput.
 	 */
 	if (likely(reply_queue == DEFAULT_REPLY_QUEUE))
-		cp->reply_queue = smp_processor_id() % h->nreply_queues;
+		cp->reply_queue = raw_smp_processor_id() % h->nreply_queues;
 	else
 		cp->reply_queue = reply_queue % h->nreply_queues;
 	/* Set the bits in the address sent down to include:
@@ -1151,7 +1151,7 @@ static void set_ioaccel2_performant_mode(struct ctlr_info *h,
 	 * processor.  This seems to give the best I/O throughput.
 	 */
 	if (likely(reply_queue == DEFAULT_REPLY_QUEUE))
-		cp->reply_queue = smp_processor_id() % h->nreply_queues;
+		cp->reply_queue = raw_smp_processor_id() % h->nreply_queues;
 	else
 		cp->reply_queue = reply_queue % h->nreply_queues;
 	/* Set the bits in the address sent down to include:
-- 
2.0.2

