From 58f09f534460cfa34b1646093f5d6c7a03295cfa Mon Sep 17 00:00:00 2001
From: dongdong deng <ddeng@pek-lpgbuild3.wrs.com>
Date: Fri, 5 Nov 2010 04:47:36 +0800
Subject: [PATCH] e1000e: Work around HW erratta about the rx interrupt cleared

Work around HW erratta where ICR could have the rx interrupt cleared

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Signed-off-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 drivers/net/e1000e/netdev.c |   24 +++++++++++++++++++++---
 1 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index 15f61cc..c8306c3 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -4813,22 +4813,40 @@ static irqreturn_t e1000_intr_msix(int irq, void *data)
 static void e1000_netpoll(struct net_device *netdev)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
+	int ret;
 
 	switch (adapter->int_mode) {
 	case E1000E_INT_MODE_MSIX:
-		e1000_intr_msix(adapter->pdev->irq, netdev);
+		ret = e1000_intr_msix(adapter->pdev->irq, netdev);
 		break;
 	case E1000E_INT_MODE_MSI:
 		disable_irq(adapter->pdev->irq);
-		e1000_intr_msi(adapter->pdev->irq, netdev);
+		ret = e1000_intr_msi(adapter->pdev->irq, netdev);
 		enable_irq(adapter->pdev->irq);
 		break;
 	default: /* E1000E_INT_MODE_LEGACY */
 		disable_irq(adapter->pdev->irq);
-		e1000_intr(adapter->pdev->irq, netdev);
+		ret = e1000_intr(adapter->pdev->irq, netdev);
 		enable_irq(adapter->pdev->irq);
 		break;
 	}
+
+	if (adapter->int_mode != E1000E_INT_MODE_LEGACY ||
+			ret != IRQ_HANDLED) {
+		/*
+		 * Work around HW erratta where ICR could have the rx
+		 * interrupt cleared, if it came in, in the same cycle
+		 * as the poll
+		 */
+
+		if (napi_schedule_prep(&adapter->napi)) {
+			adapter->total_tx_bytes = 0;
+			adapter->total_tx_packets = 0;
+			adapter->total_rx_bytes = 0;
+			adapter->total_rx_packets = 0;
+			__napi_schedule(&adapter->napi);
+		}
+	}
 }
 #endif
 
-- 
1.6.5.2

