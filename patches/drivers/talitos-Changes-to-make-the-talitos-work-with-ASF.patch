From 643c3b2167794fcbbd76281230d1201b47082417 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 11 Jul 2011 17:50:29 +0800
Subject: [PATCH 18/47] talitos: Changes to make the talitos work with ASF

Add the changes which are required to make the IPsec part of
ASF (Application Specific Fastpath) work.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
0028-talitos-Changes-to-make-the-talitos-work-with-ASF.patch.

Signed-off-by: Hemant Agarwal <hemant@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/crypto/talitos.c |  145 ++++++++++++++++++++++++++++++++++++++-------
 drivers/crypto/talitos.h |   29 +++++++++-
 2 files changed, 150 insertions(+), 24 deletions(-)

diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c
index d6545da..67a43e0 100644
--- a/drivers/crypto/talitos.c
+++ b/drivers/crypto/talitos.c
@@ -53,6 +53,18 @@
 #include <linux/ip.h>
 
 #include "talitos.h"
+#ifdef CONFIG_AS_FASTPATH
+struct secfp_ivInfo_s {
+	dma_addr_t paddr;
+	unsigned long *vaddr;
+	unsigned long ulIVIndex;
+	bool bUpdatePending;
+	unsigned int ulNumAvail;
+	unsigned int ulUpdateIndex;
+} secfp_ivInfo_s;
+#define SECFP_NUM_IV_DATA_GET_AT_ONE_TRY 1
+#define SECFP_NUM_IV_ENTRIES 8
+#endif
 
 #define TALITOS_TIMEOUT 100000
 #define TALITOS_MAX_DATA_LEN 65535
@@ -65,24 +77,12 @@
 
 #define MAP_ARRAY(chan_no)     (3 << (chan_no * 2))
 #define MAP_ARRAY_DONE(chan_no)        (1 << (chan_no * 2))
-
-#define MAX_IPSEC_RECYCLE_DESC 64
 #define MAX_DESC_LEN   160
 
-/* descriptor pointer entry */
-struct talitos_ptr {
-	__be16 len;	/* length */
-	u8 j_extent;	/* jump to sg link table and/or extent */
-	u8 eptr;	/* extended address */
-	__be32 ptr;	/* address */
-};
-
-/* descriptor */
-struct talitos_desc {
-	__be32 hdr;			/* header high bits */
-	__be32 hdr_lo;			/* header low bits */
-	struct talitos_ptr ptr[7];	/* ptr/len pair array */
-};
+#ifdef CONFIG_AS_FASTPATH
+static struct device *pg_talitos_dev;
+static struct talitos_private *pg_talitos_privdata;
+#endif
 
 /**
  * talitos_request - descriptor submission request
@@ -165,7 +165,10 @@ struct talitos_private {
 
 	/* hwrng device */
 	struct hwrng rng;
-	
+	bool bRngInit;
+#ifdef CONFIG_AS_FASTPATH
+	atomic_t ulRngInUse;
+#endif
 	/* XOR Device */
 	struct dma_device dma_dev_common;
 };
@@ -393,9 +396,17 @@ static int init_device(struct device *dev)
 	setbits32(priv->reg + TALITOS_IMR_LO, TALITOS_IMR_LO_INIT);
 
 	/* disable integrity check error interrupts (use writeback instead) */
-	if (priv->features & TALITOS_FTR_HW_AUTH_CHECK)
+	if (priv->features & TALITOS_FTR_HW_AUTH_CHECK) {
 		setbits32(priv->reg + TALITOS_MDEUICR_LO,
-		          TALITOS_MDEUICR_LO_ICE);
+			  TALITOS_MDEUICR_LO_ICE);
+#ifdef CONFIG_AS_FASTPATH
+		printk(KERN_INFO "Masking ICV Error interrupt\r\n");
+		setbits32(priv->reg + TALITOS_AESUICR_LO,
+			  TALITOS_AESUICR_LO_ICE);
+#endif
+	} else {
+		printk(KERN_INFO "Not setting ICE\r\n");
+	}
 
 	return 0;
 }
@@ -470,6 +481,16 @@ static int talitos_submit(struct device *dev, struct talitos_desc *desc,
 	}
 }
 
+#ifdef CONFIG_AS_FASTPATH
+int secfp_talitos_submit(struct device *dev, struct talitos_desc *desc,
+	void (*callback) (struct device *dev, struct talitos_desc *desc,
+	void *context, int err), void *context)
+{
+	return talitos_submit(dev, desc, callback, context);
+}
+EXPORT_SYMBOL(secfp_talitos_submit);
+#endif /* CONFIG_AS_FASTPATH */
+
 /*
  * process what was done, notify callback of error if not
  */
@@ -794,6 +815,44 @@ static irqreturn_t talitos_interrupt(int irq, void *data)
 /*
  * hwrng
  */
+#ifdef CONFIG_AS_FASTPATH
+/* nr_entries = number of 32 bit entries */
+#define SECFP_IV_DATA_LO_THRESH 2
+int secfp_rng_read_data(struct secfp_ivInfo_s *ptr)
+{
+	struct device *dev = pg_talitos_dev;
+	struct talitos_private *priv = dev_get_drvdata(dev);
+	u32 ii, ofl;
+
+	if (ptr && ptr->ulNumAvail < SECFP_IV_DATA_LO_THRESH) {
+		while (!atomic_add_unless(&priv->ulRngInUse, 1, 1))
+			;
+
+		ofl = in_be32(priv->reg + TALITOS_RNGUSR_LO) &
+		TALITOS_RNGUSR_LO_OFL;
+		ofl = ((ofl - 1) * 2) < SECFP_NUM_IV_DATA_GET_AT_ONE_TRY ?
+			(ofl-1*2) : SECFP_NUM_IV_DATA_GET_AT_ONE_TRY;
+
+		if (ofl) {
+			for (ii = 0; ii < ofl; ii += 2) {
+				ptr->vaddr[ptr->ulUpdateIndex] =
+					in_be32(priv->reg + TALITOS_RNGU_FIFO);
+				ptr->ulUpdateIndex = (ptr->ulUpdateIndex + 1)
+					& (SECFP_NUM_IV_ENTRIES - 1);
+				ptr->vaddr[ptr->ulUpdateIndex] = in_be32(
+					priv->reg + TALITOS_RNGU_FIFO_LO);
+				ptr->ulUpdateIndex = (ptr->ulUpdateIndex + 1) &
+					(SECFP_NUM_IV_ENTRIES - 1);
+			}
+			ptr->ulNumAvail += (ofl*2);
+		}
+	}
+	atomic_set(&priv->ulRngInUse, 0);
+	return 0;
+}
+EXPORT_SYMBOL(secfp_rng_read_data);
+#endif
+
 static int talitos_rng_data_present(struct hwrng *rng, int wait)
 {
 	struct device *dev = (struct device *)rng->priv;
@@ -816,11 +875,18 @@ static int talitos_rng_data_read(struct hwrng *rng, u32 *data)
 {
 	struct device *dev = (struct device *)rng->priv;
 	struct talitos_private *priv = dev_get_drvdata(dev);
-
+#ifdef CONFIG_AS_FASTPATH
+	do {
+		if (!atomic_add_unless(&priv->ulRngInUse, 1, 1))
+			break;
+	} while (1);
+#endif
 	/* rng fifo requires 64-bit accesses */
 	*data = in_be32(priv->reg + TALITOS_RNGU_FIFO);
 	*data = in_be32(priv->reg + TALITOS_RNGU_FIFO_LO);
-
+#ifdef CONFIG_AS_FASTPATH
+	atomic_set(&priv->ulRngInUse, 0);
+#endif
 	return sizeof(u32);
 }
 
@@ -829,6 +895,8 @@ static int talitos_rng_init(struct hwrng *rng)
 	struct device *dev = (struct device *)rng->priv;
 	struct talitos_private *priv = dev_get_drvdata(dev);
 	unsigned int timeout = TALITOS_TIMEOUT;
+	if (priv->bRngInit)
+		return 0;
 
 	setbits32(priv->reg + TALITOS_RNGURCR_LO, TALITOS_RNGURCR_LO_SR);
 	while (!(in_be32(priv->reg + TALITOS_RNGUSR_LO) & TALITOS_RNGUSR_LO_RD)
@@ -842,6 +910,8 @@ static int talitos_rng_init(struct hwrng *rng)
 	/* start generating */
 	setbits32(priv->reg + TALITOS_RNGUDSR_LO, 0);
 
+	priv->bRngInit = 1;
+
 	return 0;
 }
 
@@ -2355,7 +2425,10 @@ static int talitos_remove(struct of_device *ofdev)
 	if (priv->netcrypto_cache != NULL)
 		kmem_cache_destroy(priv->netcrypto_cache);
 	kfree(priv);
-
+#ifdef CONFIG_AS_FASTPATH
+	pg_talitos_dev = NULL;
+	pg_talitos_privdata = NULL;
+#endif
 	return 0;
 }
 
@@ -2670,7 +2743,10 @@ static int talitos_probe(struct of_device *ofdev,
 			}
 		}
 	}
-
+#ifdef CONFIG_AS_FASTPATH
+	pg_talitos_dev = dev;
+	pg_talitos_privdata =  priv;
+#endif
 	return 0;
 
 err_out:
@@ -2679,6 +2755,26 @@ err_out:
 	return err;
 }
 
+#ifdef CONFIG_AS_FASTPATH
+struct device *talitos_getdevice(void)
+{
+	return pg_talitos_dev;
+}
+EXPORT_SYMBOL(talitos_getdevice);
+
+dma_addr_t talitos_dma_map_single(void *data, unsigned int len, int dir)
+{
+	return dma_map_single(pg_talitos_dev, data, len, dir);
+}
+EXPORT_SYMBOL(talitos_dma_map_single);
+
+void talitos_dma_unmap_single(void *data, unsigned int len, int dir)
+{
+	dma_unmap_single(pg_talitos_dev, data, len, dir);
+}
+EXPORT_SYMBOL(talitos_dma_unmap_single);
+#endif
+
 static const struct of_device_id talitos_match[] = {
 	{
 		.compatible = "fsl,sec2.0",
@@ -2699,6 +2795,9 @@ static struct of_platform_driver talitos_driver = {
 
 static int __init talitos_init(void)
 {
+#ifdef CONFIG_AS_FASTPATH
+	printk(KERN_INFO "SEC FASTPATH Enabled\r\n");
+#endif
 	return of_register_platform_driver(&talitos_driver);
 }
 module_init(talitos_init);
diff --git a/drivers/crypto/talitos.h b/drivers/crypto/talitos.h
index 88116cd..cd98167 100644
--- a/drivers/crypto/talitos.h
+++ b/drivers/crypto/talitos.h
@@ -1,7 +1,7 @@
 /*
  * Freescale SEC (talitos) device register and descriptor header defines
  *
- * Copyright (c) 2006-2008 Freescale Semiconductor, Inc.
+ * Copyright (c) 2006-2011 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -32,6 +32,21 @@
  * TALITOS_xxx_LO addresses point to the low data bits (32-63) of the register
  */
 #define TALITOS_NAPI_WEIGHT     12
+#define MAX_IPSEC_RECYCLE_DESC 64
+/* descriptor pointer entry */
+struct talitos_ptr {
+	__be16 len;	/* length */
+	u8 j_extent;	/* jump to sg link table and/or extent */
+	u8 eptr;	/* extended address */
+	__be32 ptr;	/* address */
+};
+
+/* descriptor */
+struct talitos_desc {
+	__be32 hdr;			/* header high bits */
+	__be32 hdr_lo;			/* header low bits */
+	struct talitos_ptr ptr[7];	/* ptr/len pair array */
+};
 
 /* global register offset addresses */
 #define   TALITOS_MCR			0x1030  /* master control register */
@@ -107,6 +122,9 @@
 #define TALITOS_DEUISR_LO		0x2034
 #define TALITOS_AESUISR			0x4030 /* AES unit */
 #define TALITOS_AESUISR_LO		0x4034
+#define TALITOS_AESUICR			0x4038 /* AES unit */
+#define TALITOS_AESUICR_LO		0x403c
+#define TALITOS_AESUICR_LO_ICE	0x4000
 #define TALITOS_MDEUISR			0x6030 /* message digest unit */
 #define TALITOS_MDEUISR_LO		0x6034
 #define TALITOS_MDEUICR			0x6038 /* interrupt control */
@@ -143,6 +161,9 @@
 #define DESC_HDR_LO_ICCR1_MASK		cpu_to_be32(0x00180000)
 #define DESC_HDR_LO_ICCR1_PASS		cpu_to_be32(0x00080000)
 #define DESC_HDR_LO_ICCR1_FAIL		cpu_to_be32(0x00100000)
+#define DESC_HDR_LO_ICCR0_MASK		cpu_to_be32(0x18000000)
+#define DESC_HDR_LO_ICCR0_PASS		cpu_to_be32(0x08000000)
+#define DESC_HDR_LO_ICCR0_FAIL		cpu_to_be32(0x10000000)
 
 /* primary execution unit select */
 #define	DESC_HDR_SEL0_MASK		cpu_to_be32(0xf0000000)
@@ -175,6 +196,10 @@
 #define	DESC_HDR_MODE0_MDEU_SHA1_HMAC	(DESC_HDR_MODE0_MDEU_SHA1 | \
 					 DESC_HDR_MODE0_MDEU_HMAC)
 
+#define DESC_HDR_MODE0_AES_XCBS_MAC		cpu_to_be32(0x08400000)
+#define DESC_HDR_MODE0_AES_XCBS_CICV	cpu_to_be32(0x02000000)
+#define	DESC_HDR_MODE0_AES_CTR			cpu_to_be32(0x00600000)
+
 /* secondary execution unit select (SEL1) */
 #define	DESC_HDR_SEL1_MASK		cpu_to_be32(0x000f0000)
 #define	DESC_HDR_SEL1_MDEUA		cpu_to_be32(0x00030000)
@@ -182,6 +207,7 @@
 #define	DESC_HDR_SEL1_CRCU		cpu_to_be32(0x00080000)
 
 /* secondary execution unit mode (MODE1) and derivatives */
+#define	DESC_HDR_MODE0_MDEU_CICV	cpu_to_be32(0x04000000)
 #define	DESC_HDR_MODE1_MDEU_CICV	cpu_to_be32(0x00004000)
 #define	DESC_HDR_MODE1_MDEU_INIT	cpu_to_be32(0x00001000)
 #define	DESC_HDR_MODE1_MDEU_HMAC	cpu_to_be32(0x00000800)
@@ -207,6 +233,7 @@
 #define DESC_HDR_TYPE_IPSEC_ESP			cpu_to_be32(1 << 3)
 #define DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU	cpu_to_be32(2 << 3)
 #define DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU	cpu_to_be32(4 << 3)
+#define DESC_HDR_TYPE_AESU_CTR_HMAC		cpu_to_be32(3 << 6)
 #define DESC_HDR_TYPE_RAID_XOR			cpu_to_be32(21 << 3)
 
 /* link table extent field bits */
-- 
1.7.0.4

