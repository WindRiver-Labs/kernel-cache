From f3ec8127be7c4c657979a5d7df3ea21201370a78 Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Thu, 24 Jun 2010 17:30:11 +0800
Subject: [PATCH 2/3] gianfar: fix headroom expansion code

The code that was added to increase headroom was wrong.
It doesn't handle the case where gfar_add_fcb() changes the skb.
Better to do check at start of transmit (outside of lock), where
error handling is better anyway.

This patch was backported from mainline.
commit upstream: commit 54dc79fe0d895758bdaa1dcf8512d3d21263d105

Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Integrated-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 drivers/net/gianfar.c |   45 +++++++++++++++++++++++----------------------
 1 files changed, 23 insertions(+), 22 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index eb04550..111bcbe 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -1103,19 +1103,9 @@ static int gfar_enet_open(struct net_device *dev)
 	return err;
 }
 
-static inline struct txfcb *gfar_add_fcb(struct sk_buff **skbp, struct txbd8 *bdp)
+static inline struct txfcb *gfar_add_fcb(struct sk_buff *skb, struct txbd8 *bdp)
 {
-	struct txfcb *fcb;
-	struct sk_buff *skb = *skbp;
-
-	if (unlikely(skb_headroom(skb) < GMAC_FCB_LEN)) {
-		struct sk_buff *old_skb = skb;
-		skb = skb_realloc_headroom(old_skb, GMAC_FCB_LEN);
-		if (!skb)
-			return NULL;
-		dev_kfree_skb_any(old_skb);
-	}
-	fcb = (struct txfcb *)skb_push(skb, GMAC_FCB_LEN);
+	struct txfcb *fcb = (struct txfcb *)skb_push (skb, GMAC_FCB_LEN);
 
 	memset(fcb, 0, GMAC_FCB_LEN);
 
@@ -1166,6 +1156,19 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	u16 status;
 	unsigned long flags;
 
+	/* make space for additional header */
+	if (skb_headroom(skb) < GMAC_FCB_LEN) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, GMAC_FCB_LEN);
+		if (!skb_new) {
+			kfree(skb);
+			return NETDEV_TX_OK;
+		}
+		kfree_skb(skb);
+		skb = skb_new;
+	}
+
 	/* Update transmit stats */
 	dev->stats.tx_bytes += skb->len;
 
@@ -1181,21 +1184,19 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Set up checksumming */
 	if (likely((dev->features & NETIF_F_IP_CSUM)
 			&& (CHECKSUM_PARTIAL == skb->ip_summed))) {
-		fcb = gfar_add_fcb(&skb, txbdp);
-		if (likely(fcb != NULL)) {
-			status |= TXBD_TOE;
-			gfar_tx_checksum(skb, fcb);
-		}
+		fcb = gfar_add_fcb(skb, txbdp);
+		status |= TXBD_TOE;
+		gfar_tx_checksum(skb, fcb);
 	}
 
 	if (priv->vlan_enable &&
 			unlikely(priv->vlgrp && vlan_tx_tag_present(skb))) {
-		if (unlikely(NULL == fcb))
-			fcb = gfar_add_fcb(&skb, txbdp);
-		if (likely(fcb != NULL)) {
+		if (unlikely(NULL == fcb)) {
+			fcb = gfar_add_fcb(skb, txbdp);
 			status |= TXBD_TOE;
-			gfar_tx_vlan(skb, fcb);
 		}
+
+		gfar_tx_vlan(skb, fcb);
 	}
 
 	/* Set buffer length and pointer */
@@ -1254,7 +1255,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Unlock priv */
 	spin_unlock_irqrestore(&priv->txlock, flags);
 
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 /* Stops the kernel queue, and halts the controller */
-- 
1.7.0.4

