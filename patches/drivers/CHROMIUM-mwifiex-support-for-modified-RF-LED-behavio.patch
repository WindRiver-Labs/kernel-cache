From 0bdfd97e49edb1753ad9d8b25ab9d69d8fa726f6 Mon Sep 17 00:00:00 2001
From: Simon Hu <huxm@marvell.com>
Date: Mon, 22 Sep 2014 16:36:18 +0800
Subject: [PATCH 01/12] CHROMIUM: mwifiex: support for modified RF LED
 behavior

From google chromium:
https://chromium-review.googlesource.com/#/c/220159/

This patch adds support for modified LED behavior on some
platforms.This feature can be enabled via device tree configuration.

For FW where this LED behavior is supported, new behavior would be:

1. LED solid ON when interface is up.
2. LED off when interface is down.
3. LED off when suspeneded.
4. After resume, LED follows behavior from step1/step2.

BUG=chrome-os-partner:30547
TEST=manual: 1. ifconfig mlan0 up, turns LED on.
2. ifconfing mlan0 down, turns LED off.
3. Suspend turns led off.

Change-Id: Ic39622177bcdd6aef682576def0a50a40e73b3a6
Signed-off-by: Xinming Hu <huxm@marvell.com>
Signed-off-by: Avinash Patil <patila@marvell.com>
Signed-off-by: Amitkumar Karwar <akarwar@marvell.com>
Signed-off-by: Kevin Gan <ganhy@marvell.com>
Signed-off-by: Cathy Luo <cluo@marvell.com>
Signed-off-by: Marc Yang <yangyang@marvell.com>
Tested-by: Chin-Ran Lo <crlo@marvell.com>
Signed-off-by: Feng Mu <Feng.Mu@windriver.com>
---
 drivers/net/wireless/mwifiex/fw.h          |   18 +++++++++++++++
 drivers/net/wireless/mwifiex/init.c        |   32 +++++++++++++++++++++++++++
 drivers/net/wireless/mwifiex/main.c        |    6 +++++
 drivers/net/wireless/mwifiex/main.h        |    6 +++++
 drivers/net/wireless/mwifiex/sta_cmd.c     |   33 ++++++++++++++++++++++++++++
 drivers/net/wireless/mwifiex/sta_cmdresp.c |    2 +
 drivers/net/wireless/mwifiex/sta_ioctl.c   |   15 ++++++++++++
 7 files changed, 112 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/mwifiex/fw.h b/drivers/net/wireless/mwifiex/fw.h
index 59d8964..587239d 100644
--- a/drivers/net/wireless/mwifiex/fw.h
+++ b/drivers/net/wireless/mwifiex/fw.h
@@ -174,6 +174,7 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define TLV_TYPE_SCAN_CHANNEL_GAP   (PROPRIETARY_TLV_BASE_ID + 197)
 #define TLV_TYPE_API_REV            (PROPRIETARY_TLV_BASE_ID + 199)
 #define TLV_TYPE_CHANNEL_STATS      (PROPRIETARY_TLV_BASE_ID + 198)
+#define TLV_TYPE_LED_CONTROL        (PROPRIETARY_TLV_BASE_ID + 205)
 
 #define MWIFIEX_TX_DATA_BUF_SIZE_2K        2048
 
@@ -316,6 +317,7 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define HostCmd_CMD_802_11_AD_HOC_JOIN                0x002c
 #define HostCmd_CMD_802_11_AD_HOC_STOP                0x0040
 #define HostCmd_CMD_802_11_MAC_ADDRESS                0x004D
+#define HostCmd_CMD_802_11_LED_CONTROL                0X004E
 #define HostCmd_CMD_802_11D_DOMAIN_INFO               0x005b
 #define HostCmd_CMD_802_11_KEY_MATERIAL               0x005e
 #define HostCmd_CMD_802_11_BG_SCAN_QUERY              0x006c
@@ -1029,6 +1031,16 @@ struct ieee_types_oper_mode_ntf {
 	u8 oper_mode;
 } __packed;
 
+struct mwifiex_led_param {
+	__le16 mode;
+	__le16 on;
+} __packed;
+
+struct mwifiex_ie_types_led_param {
+	struct mwifiex_ie_types_header header;
+	struct mwifiex_led_param led_cfg;
+} __packed;
+
 struct host_cmd_ds_802_11_ad_hoc_start {
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	u8 bss_mode;
@@ -1139,6 +1151,11 @@ struct host_cmd_ds_802_11_hs_cfg_enh {
 	} params;
 } __packed;
 
+struct host_cmd_ds_802_11_led_control {
+	__le16 action;
+	__le16 num_led;
+} __packed;
+
 enum SNMP_MIB_INDEX {
 	OP_RATE_SET_I = 1,
 	DTIM_PERIOD_I = 3,
@@ -1973,6 +1990,7 @@ struct host_cmd_ds_command {
 		struct host_cmd_ds_tdls_oper tdls_oper;
 		struct host_cmd_ds_chan_rpt_req chan_rpt_req;
 		struct host_cmd_sdio_sp_rx_aggr_cfg sdio_rx_aggr_cfg;
+		struct host_cmd_ds_802_11_led_control led_cfg;
 	} params;
 } __packed;
 
diff --git a/drivers/net/wireless/mwifiex/init.c b/drivers/net/wireless/mwifiex/init.c
index e12192f..5c4b767 100644
--- a/drivers/net/wireless/mwifiex/init.c
+++ b/drivers/net/wireless/mwifiex/init.c
@@ -258,6 +258,8 @@ static void mwifiex_init_adapter(struct mwifiex_adapter *adapter)
 	adapter->hs_cfg.gap = HS_CFG_GAP_DEF;
 	adapter->hs_activated = false;
 
+	adapter->rf_led_enabled = true;
+
 	memset(adapter->event_body, 0, sizeof(adapter->event_body));
 	adapter->hw_dot_11n_dev_cap = 0;
 	adapter->hw_dev_mcs_support = 0;
@@ -507,6 +509,34 @@ int mwifiex_init_lock_list(struct mwifiex_adapter *adapter)
 	return 0;
 }
 
+static void mwifiex_init_from_dev_tree(struct mwifiex_adapter *adapter)
+{
+#ifdef CONFIG_OF
+	struct property *prop;
+	u32 data;
+	if (!adapter) {
+		pr_err("%s: adapter is NULL\n", __func__);
+		return;
+	}
+
+	adapter->dt_node = of_find_node_by_name(NULL, "marvell_cfgdata");
+	if (!adapter->dt_node)
+		return;
+	for_each_property_of_node(adapter->dt_node, prop) {
+		if (!strncmp(prop->name, "rf_led", strlen("rf_led"))) {
+			if (!of_property_read_u32(adapter->dt_node,
+						  prop->name, &data)) {
+				dev_dbg(adapter->dev, "rf_led = 0x%x\n", data);
+				if (data)
+					adapter->rf_led_enabled = true;
+				else
+					adapter->rf_led_enabled = false;
+			}
+		}
+	}
+#endif
+}
+
 /*
  * This function initializes the firmware.
  *
@@ -552,6 +582,8 @@ int mwifiex_init_fw(struct mwifiex_adapter *adapter)
 			return -1;
 	}
 
+	mwifiex_init_from_dev_tree(adapter);
+
 	for (i = 0; i < adapter->priv_num; i++) {
 		if (adapter->priv[i]) {
 			ret = mwifiex_sta_init_cmd(adapter->priv[i], first_sta,
diff --git a/drivers/net/wireless/mwifiex/main.c b/drivers/net/wireless/mwifiex/main.c
index 03a95c7..43c44a7 100644
--- a/drivers/net/wireless/mwifiex/main.c
+++ b/drivers/net/wireless/mwifiex/main.c
@@ -615,8 +615,12 @@ static int mwifiex_init_hw_fw(struct mwifiex_adapter *adapter)
 static int
 mwifiex_open(struct net_device *dev)
 {
+	struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
 	netif_carrier_off(dev);
 
+	if (priv->adapter->rf_led_enabled)
+		mwifiex_set_led(priv->adapter, MWIFIEX_LED_ON);
+
 	return 0;
 }
 
@@ -635,6 +639,8 @@ mwifiex_close(struct net_device *dev)
 		priv->scan_aborting = true;
 	}
 
+	if (priv->adapter->rf_led_enabled)
+		mwifiex_set_led(priv->adapter, MWIFIEX_LED_OFF);
 	return 0;
 }
 
diff --git a/drivers/net/wireless/mwifiex/main.h b/drivers/net/wireless/mwifiex/main.h
index fe12560..36a7604 100644
--- a/drivers/net/wireless/mwifiex/main.h
+++ b/drivers/net/wireless/mwifiex/main.h
@@ -111,6 +111,10 @@ enum {
 
 #define PKT_TYPE_MGMT	0xE5
 
+#define MWIFIEX_LED_ON		1
+#define MWIFIEX_LED_OFF		0
+#define MWIFIEX_LED_MAX		3
+
 /*
  * Do not check for data_received for USB, as data_received
  * is handled in mwifiex_usb_recv for USB
@@ -865,6 +869,7 @@ struct mwifiex_adapter {
 	struct mwifiex_hs_config_param hs_cfg;
 	u8 hs_activated;
 	u16 hs_activate_wait_q_woken;
+	bool rf_led_enabled;
 	wait_queue_head_t hs_activate_wait_q;
 	bool is_suspended;
 	bool hs_enabling;
@@ -1267,6 +1272,7 @@ int mwifiex_wait_queue_complete(struct mwifiex_adapter *adapter,
 				struct cmd_ctrl_node *cmd_queued);
 int mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,
 		      struct cfg80211_ssid *req_ssid);
+int mwifiex_set_led(struct mwifiex_adapter *adapter, int on);
 int mwifiex_cancel_hs(struct mwifiex_private *priv, int cmd_type);
 int mwifiex_enable_hs(struct mwifiex_adapter *adapter);
 int mwifiex_disable_auto_ds(struct mwifiex_private *priv);
diff --git a/drivers/net/wireless/mwifiex/sta_cmd.c b/drivers/net/wireless/mwifiex/sta_cmd.c
index 49422f2..8502aaf 100644
--- a/drivers/net/wireless/mwifiex/sta_cmd.c
+++ b/drivers/net/wireless/mwifiex/sta_cmd.c
@@ -388,6 +388,35 @@ mwifiex_cmd_802_11_hs_cfg(struct mwifiex_private *priv,
 	return 0;
 }
 
+static int
+mwifiex_cmd_802_11_led_cfg(struct mwifiex_private *priv,
+			   struct host_cmd_ds_command *cmd,
+			   u16 cmd_action,
+			   struct mwifiex_led_param *ledcfg_param)
+{
+	struct host_cmd_ds_802_11_led_control *led_cfg = &cmd->params.led_cfg;
+	struct mwifiex_ie_types_led_param *led_tlv;
+	u8 *pos;
+
+	cmd->command = cpu_to_le16(HostCmd_CMD_802_11_LED_CONTROL);
+	cmd->size = cpu_to_le16(S_DS_GEN);
+	le16_add_cpu(&cmd->size, sizeof(struct host_cmd_ds_802_11_led_control));
+
+	led_cfg->action = cpu_to_le16(cmd_action);
+	led_cfg->num_led = cpu_to_le16(MWIFIEX_LED_MAX);
+
+	pos = (u8 *)led_cfg + sizeof(struct host_cmd_ds_802_11_led_control);
+	led_tlv = (void *)pos;
+	led_tlv->header.type = cpu_to_le16(TLV_TYPE_LED_CONTROL);
+	led_tlv->header.len = cpu_to_le16(sizeof(struct mwifiex_led_param));
+	memcpy(&led_tlv->led_cfg, ledcfg_param,
+	       sizeof(struct mwifiex_led_param));
+
+	le16_add_cpu(&cmd->size, sizeof(struct mwifiex_ie_types_led_param));
+
+	return 0;
+}
+
 /*
  * This function prepares command to set/get MAC address.
  *
@@ -1747,6 +1776,10 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
 		ret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,
 				(struct mwifiex_hs_config_param *) data_buf);
 		break;
+	case HostCmd_CMD_802_11_LED_CONTROL:
+		ret = mwifiex_cmd_802_11_led_cfg(priv, cmd_ptr, cmd_action,
+						 data_buf);
+		break;
 	case HostCmd_CMD_802_11_SCAN:
 		ret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);
 		break;
diff --git a/drivers/net/wireless/mwifiex/sta_cmdresp.c b/drivers/net/wireless/mwifiex/sta_cmdresp.c
index 88dc6b6..9609c9e 100644
--- a/drivers/net/wireless/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/mwifiex/sta_cmdresp.c
@@ -1145,6 +1145,8 @@ int mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,
 	case HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:
 		ret = mwifiex_ret_sdio_rx_aggr_cfg(priv, resp);
 		break;
+	case HostCmd_CMD_802_11_LED_CONTROL:
+		break;
 	default:
 		dev_err(adapter->dev, "CMD_RESP: unknown cmd response %#x\n",
 			resp->command);
diff --git a/drivers/net/wireless/mwifiex/sta_ioctl.c b/drivers/net/wireless/mwifiex/sta_ioctl.c
index 0599e41..fd1c1b6 100644
--- a/drivers/net/wireless/mwifiex/sta_ioctl.c
+++ b/drivers/net/wireless/mwifiex/sta_ioctl.c
@@ -525,6 +525,21 @@ int mwifiex_enable_hs(struct mwifiex_adapter *adapter)
 }
 EXPORT_SYMBOL_GPL(mwifiex_enable_hs);
 
+int mwifiex_set_led(struct mwifiex_adapter *adapter, int on)
+{
+	struct mwifiex_private *priv;
+	struct mwifiex_led_param ledcfg;
+
+	priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);
+	memset(&ledcfg, 0, sizeof(struct mwifiex_led_param));
+	ledcfg.on = cpu_to_le16(on);
+
+	return mwifiex_send_cmd(priv,
+				HostCmd_CMD_802_11_LED_CONTROL,
+				HostCmd_ACT_GEN_SET, 0,
+				&ledcfg, true);
+}
+
 /*
  * IOCTL request handler to get BSS information.
  *
-- 
1.7.5.4

