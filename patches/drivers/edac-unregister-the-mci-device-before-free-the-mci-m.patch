From f7c591067daa5e16200066bec98bf4834a3eb2ca Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Fri, 21 Aug 2015 15:45:07 +0800
Subject: [PATCH 2/2] edac: unregister the mci device before free the mci
 memory

this patch can fix the following kmemleak:

unreferenced object 0xffff881022b60ee0 (size 32):
  comm "udevd", pid 262, jiffies 4294709066 (age 1410.265s)
  hex dump (first 32 bytes):
    00 7c e8 18 10 88 ff ff 00 74 e8 18 10 88 ff ff .|.......t......
    00 70 e8 18 10 88 ff ff 00 00 00 00 00 00 00 00 .p..............
  backtrace:
    [<ffffffff819814b6>] kmemleak_alloc+0x26/0x50
    [<ffffffff8115b194>] __kmalloc+0x154/0x2f0
    [<ffffffff817ca848>] edac_mc_alloc+0x278/0x6d0
    [<ffffffffa0106f9d>] 0xffffffffa0106f9d
    [<ffffffff8140c9ae>] local_pci_probe+0x3e/0x70
    [<ffffffff8140cbb1>] pci_device_probe+0x121/0x130
    [<ffffffff8155be85>] driver_probe_device+0x105/0x260
    [<ffffffff8155c0b3>] __driver_attach+0x93/0xa0
    [<ffffffff81559ed3>] bus_for_each_dev+0x63/0xa0
    [<ffffffff8155b90e>] driver_attach+0x1e/0x20
    [<ffffffff8155b500>] bus_add_driver+0x1f0/0x290
    [<ffffffff8155c6e4>] driver_register+0x64/0xf0
    [<ffffffff8140c81c>] __pci_register_driver+0x4c/0x50
    [<ffffffffa010d050>] 0xffffffffa010d050
    [<ffffffff810002d2>] do_one_initcall+0x102/0x160
    [<ffffffff810a25e5>] load_module+0x1a65/0x2230

the kmemleak happened when rmmod sb_edac.ko
In edac_mc_free, only after mci device is ungistered, it will do the mci
free task, or it will do the mci unregister action, adjust the sequence
of the free task to ungister the device first and then free the mci
struct.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 drivers/edac/edac_mc.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index f4be374..7e52b51 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -470,6 +470,11 @@ void edac_mc_free(struct mem_ctl_info *mci)
 {
 	edac_dbg(1, "\n");
 
+	/* the mci instance is freed here, when the sysfs object is dropped */
+	if (device_is_registered(&mci->dev)) {
+		edac_unregister_sysfs(mci);
+	}
+
 	/* If we're not yet registered with sysfs free only what was allocated
 	 * in edac_mc_alloc().
 	 */
@@ -477,9 +482,6 @@ void edac_mc_free(struct mem_ctl_info *mci)
 		_edac_mc_free(mci);
 		return;
 	}
-
-	/* the mci instance is freed here, when the sysfs object is dropped */
-	edac_unregister_sysfs(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_free);
 
-- 
1.7.5.4

