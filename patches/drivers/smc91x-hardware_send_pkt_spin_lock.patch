From fc9e813952c891c3cc373acdb74141bc1f6e4f92 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 4 Dec 2008 17:26:13 +0800
Subject: [PATCH] smc91x-hardware_send_pkt_spin_lock

It can be seen from kernel dump, after restoring sp,

       spin_unlock_irq(&lp->lock);
    22e8:       e10f3000        mrs     r3, CPSR
    22ec:       e3c33080        bic     r3, r3, #128    ; 0x80
    22f0:       e121f003        msr     CPSR_c, r3
    22f4:       e3a00001        mov     r0, #1  ; 0x1
    22f8:       ebfffffe        bl      0 <sub_preempt_count>
                        22f8: R_ARM_CALL        sub_preempt_count
->  22fc:       e1a0200d        mov     r2, sp
    2300:       e3c23d7f        bic     r3, r2, #8128   ; 0x1fc0

the "Flags" are changed, the direct reason is very
slow net speed. So spin_lock_irqsave is used here.

After applied this patch, the panic does not happen
even though gdboe can't be established due to ugly
slwo net speed.

BUG: soft lockup - CPU#0 stuck for 81s! [swapper:0]g5fff857/kernel/drive
Modules linked in: binfmt_misc ipv6 kgdboe
Pid: 0, comm:              swapper
CPU: 0    Not tainted  (2.6.27.6-WR3.0zz_standard-00389-g5fff857 #2)
PC is at smc_hardware_send_pkt+0x1ec/0x284
LR is at smc_hardware_send_pkt+0x1e0/0x284
pc : [<c01e6c50>]    lr : [<c01e6c44>]    psr: 60000013
sp : c03bdc50  ip : c03bdc50  fp : c03bdc84
r10: c7d1dc02  r9 : c694ab80  r8 : 0000002b
r7 : c694a800  r6 : c926c000  r5 : 00000028  r4 : c7d1dc04
r3 : 60000013  r2 : 00000000  r1 : c03bc000  r0 : 00000001
Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 0005317f  Table: 07c88000  DAC: 00000017

Signed-off-by Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/smc91x.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index cebabd4..02c7051 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -223,11 +223,12 @@ static void PRINT_PKT(u_char *buf, int length)
 /* this enables an interrupt in the interrupt mask register */
 #define SMC_ENABLE_INT(lp, x) do {					\
 	unsigned char mask;						\
-	spin_lock_irq(&lp->lock);					\
+	unsigned long int_flags;					\
+	spin_lock_irqsave(&lp->lock,int_flags);				\
 	mask = SMC_GET_INT_MASK(lp);					\
 	mask |= (x);							\
 	SMC_SET_INT_MASK(lp, mask);					\
-	spin_unlock_irq(&lp->lock);					\
+	spin_unlock_irqrestore(&lp->lock,int_flags);			\
 } while (0)
 
 /* this disables an interrupt from the interrupt mask register */
-- 
1.6.0.2.GIT

