From 8f63ff1f4a5f34b075bbe5ad001018b3a927a21a Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Fri, 30 Nov 2012 17:30:37 +0800
Subject: [PATCH] mmc: core: Add default timeout value for CMD6

Back port of upstream commit b23cf0bd55b0c6b703982446f679e00d6d929524
(mmc: core: Add default timeout value for CMD6)

Modifications to the patch on back porting:
- Discard two of mmc_switch() calls from original patch because the current
	kernel only need one.
- Back ported parts from below upstream commits for providing functions and
	interfaces necessary for the above commit back porting.
	dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
	(mmc: add erase, secure erase, trim and secure trim  operations)
	d3a8d95dcbb726b9cf0bbc166b2473bdd236c88c
	(mmc: core: Allow setting CMD timeout for CMD6 (SWITCH).)
	a3c7778f8153b9e4eceea6738973280b9e63c618
	(mmc: sdhci: R1B command handling + MMC_CAP_ERASE.)

The commit fixes below warning on resuming from previous suspend.
Jan  9 03:11:22 localhost kernel: mmc1: Got data interrupt 0x00100000 even though no data operation was in progress.
Jan  9 03:11:22 localhost kernel: sdhci: ============== REGISTER DUMP ==============
Jan  9 03:11:22 localhost kernel: sdhci: Sys addr: 0x00000000 | Version:  0x00000100
Jan  9 03:11:22 localhost kernel: sdhci: Blk size: 0x00000000 | Blk cnt:  0x00000000
Jan  9 03:11:22 localhost kernel: sdhci: Argument: 0x03b70101 | Trn mode: 0x00000000
Jan  9 03:11:22 localhost kernel: sdhci: Present:  0x01ef0000 | Host ctl: 0x00000001
Jan  9 03:11:22 localhost kernel: sdhci: Power:    0x0000000f | Blk gap:  0x00000000
Jan  9 03:11:22 localhost kernel: sdhci: Wake-up:  0x00000000 | Clock:    0x00000107
Jan  9 03:11:22 localhost kernel: sdhci: Timeout:  0x00000000 | Int stat: 0x00000000
Jan  9 03:11:22 localhost kernel: sdhci: Int enab: 0x00ff0003 | Sig enab: 0x00ff0003
Jan  9 03:11:22 localhost kernel: sdhci: AC12 err: 0x00000000 | Slot int: 0x000000ff
Jan  9 03:11:22 localhost kernel: sdhci: Caps:     0x01f632b2 | Max curr: 0x00000080
Jan  9 03:11:22 localhost kernel: sdhci: ===========================================

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 drivers/mmc/core/mmc.c     |   11 +++++++++--
 drivers/mmc/core/mmc_ops.c |    5 ++++-
 drivers/mmc/core/mmc_ops.h |    2 +-
 drivers/mmc/host/sdhci.c   |   40 +++++++++++++++++++++++++---------------
 include/linux/mmc/card.h   |    1 +
 include/linux/mmc/core.h   |    2 +-
 include/linux/mmc/mmc.h    |    1 +
 7 files changed, 42 insertions(+), 20 deletions(-)

diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index af2eae8..a02fdc9 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -249,6 +249,12 @@ static int mmc_read_ext_csd(struct mmc_card *card)
 					1 << ext_csd[EXT_CSD_S_A_TIMEOUT];
 	}
 
+	if (card->ext_csd.rev >= 6)
+		card->ext_csd.generic_cmd6_time = 10 *
+			ext_csd[EXT_CSD_GENERIC_CMD6_TIME];
+	else
+		card->ext_csd.generic_cmd6_time = 0;
+
 out:
 	kfree(ext_csd);
 
@@ -415,7 +421,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	if ((card->ext_csd.hs_max_dtr != 0) &&
 		(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_HS_TIMING, 1);
+			EXT_CSD_HS_TIMING, 1, card->ext_csd.generic_cmd6_time);
 		if (err && err != -EBADMSG)
 			goto free_card;
 
@@ -459,7 +465,8 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		}
 
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_BUS_WIDTH, ext_csd_bit);
+				EXT_CSD_BUS_WIDTH, ext_csd_bit,
+				card->ext_csd.generic_cmd6_time);
 
 		if (err && err != -EBADMSG)
 			goto free_card;
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 53761c6..84ed729 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -387,7 +387,9 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
 	return err;
 }
 
-int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value)
+int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
+		unsigned int timeout_ms)
+
 {
 	int err;
 	struct mmc_command cmd;
@@ -404,6 +406,7 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value)
 		  (value << 8) |
 		  set;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+	cmd.cmd_timeout_ms = timeout_ms;
 
 	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
 	if (err)
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
index 653eb8e..b911717 100644
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@ -20,7 +20,7 @@ int mmc_all_send_cid(struct mmc_host *host, u32 *cid);
 int mmc_set_relative_addr(struct mmc_card *card);
 int mmc_send_csd(struct mmc_card *card, u32 *csd);
 int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
-int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value);
+extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 int mmc_send_status(struct mmc_card *card, u32 *status);
 int mmc_send_cid(struct mmc_host *host, u32 *cid);
 int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 3c50fd9..9927aca 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -38,7 +38,7 @@
 
 static unsigned int debug_quirks = 0;
 
-static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
+static void sdhci_prepare_data(struct sdhci_host *, struct mmc_command *);
 static void sdhci_finish_data(struct sdhci_host *);
 
 static void sdhci_send_command(struct sdhci_host *, struct mmc_command *);
@@ -599,9 +599,10 @@ static void sdhci_adma_table_post(struct sdhci_host *host,
 		data->sg_len, direction);
 }
 
-static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_data *data)
+static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)
 {
 	u8 count;
+	struct mmc_data *data = cmd->data;
 	unsigned target_timeout, current_timeout;
 
 	/*
@@ -613,12 +614,16 @@ static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_data *data)
 	if (host->quirks & SDHCI_QUIRK_BROKEN_TIMEOUT_VAL)
 		return 0xE;
 
-	/* timeout in us */
-	target_timeout = data->timeout_ns / 1000 +
-		data->timeout_clks / host->clock;
+	/* Unspecified timeout, assume max */
+	if (!data && !cmd->cmd_timeout_ms)
+		return 0xE;
 
-	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
-		host->timeout_clk = host->clock / 1000;
+	/* timeout in us */
+	if (!data)
+		target_timeout = cmd->cmd_timeout_ms * 1000;
+	else
+		target_timeout = data->timeout_ns / 1000 +
+			data->timeout_clks / host->clock;
 
 	/*
 	 * Figure out needed cycles.
@@ -640,8 +645,7 @@ static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_data *data)
 	}
 
 	if (count >= 0xF) {
-		printk(KERN_WARNING "%s: Too large timeout requested!\n",
-			mmc_hostname(host->mmc));
+		printk(KERN_WARNING "%s: Too large timeout requested for CMD%d!\n", mmc_hostname(host->mmc), cmd->opcode);
 		count = 0xE;
 	}
 
@@ -672,15 +676,21 @@ static void sdhci_set_transfer_irqs(struct sdhci_host *host)
 		sdhci_clear_set_irqs(host, dma_irqs, pio_irqs);
 }
 
-static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
+static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 {
 	u8 count;
 	u32 ctrl;
+	struct mmc_data *data = cmd->data;
 	int ret;
 
 	WARN_ON(host->data);
 
-	if (data == NULL)
+	if (data || (cmd->flags & MMC_RSP_BUSY)) {
+		count = sdhci_calc_timeout(host, cmd);
+		sdhci_writeb(host, count, SDHCI_TIMEOUT_CONTROL);
+	}
+
+	if (!data)
 		return;
 
 	/* Sanity checks */
@@ -691,9 +701,6 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
 	host->data = data;
 	host->data_early = 0;
 
-	count = sdhci_calc_timeout(host, data);
-	sdhci_writeb(host, count, SDHCI_TIMEOUT_CONTROL);
-
 	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA))
 		host->flags |= SDHCI_REQ_USE_DMA;
 
@@ -955,7 +962,7 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 
 	host->cmd = cmd;
 
-	sdhci_prepare_data(host, cmd->data);
+	sdhci_prepare_data(host, cmd);
 
 	sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
 
@@ -1887,6 +1894,9 @@ int sdhci_add_host(struct sdhci_host *host)
 	if (caps & SDHCI_TIMEOUT_CLK_UNIT)
 		host->timeout_clk *= 1000;
 
+	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
+		host->timeout_clk = host->clock / 1000;
+
 	/*
 	 * Set host parameters.
 	 */
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d02d2c6..467d5eb 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -42,6 +42,7 @@ struct mmc_csd {
 struct mmc_ext_csd {
 	u8			rev;
 	unsigned int		sa_timeout;		/* Units: 100ns */
+	unsigned int            generic_cmd6_time;      /* Units: 10ms */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 };
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index e4898e9..57e2d4f 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -91,7 +91,7 @@ struct mmc_command {
  * ENOMEDIUM    Host can determine that the slot is empty and is
  *              actively failing requests
  */
-
+	unsigned int            cmd_timeout_ms; /* in milliseconds */
 	struct mmc_data		*data;		/* data segment associated with cmd */
 	struct mmc_request	*mrq;		/* associated request */
 };
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 8a49cbf..085a190 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -257,6 +257,7 @@ struct _mmc_csd {
 #define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT	217
+#define EXT_CSD_GENERIC_CMD6_TIME      248     /* RO */
 
 /*
  * EXT_CSD field definitions
-- 
1.7.0

