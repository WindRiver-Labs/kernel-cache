From 8b80c79b2e359e732a63d0cb50bb466da74ae4bc Mon Sep 17 00:00:00 2001
From: Qi Hou <qi.hou@windriver.com>
Date: Wed, 28 Dec 2016 08:34:17 +0800
Subject: [PATCH] tty: Serialize function receive_room

There is a read buffer in pty device and it has two variables to
check and judge the status of this read buffer. "read_cnt" shows
how many bytes can be read from this read buffer; "receive_room"
shows how many bytes are still free and can be write into the read
buffer. "read_cnt" is 0 means the buffer is empty while the 0
"receve_room" means the buffer is  full. The "receive_room" was
set based on "read_cnt" with function "receive_room" by both the
"consumer" and "producer" of this read buffer. While the very
function was not serialized that may cause race condition in
preempt kernel. That race condition may cause both the raed_cnt and
receive_room is 0 thus block both consumer and producer for ever.

Without serialization, preemption on this function may
cause the read_cnt and receive_room are both set to
zero. This will block both producer and consumer of the
read_buf. Serialize it with a new created spinlock.

Signed-off-by: Qi Hou <qi.hou@windriver.com>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 drivers/tty/n_tty.c  |    3 +++
 drivers/tty/tty_io.c |    1 +
 include/linux/tty.h  |    1 +
 3 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 8ab46ad..5cb5b89 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -165,7 +165,9 @@ static int receive_room(struct tty_struct *tty)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 	int left;
+	unsigned long flags;
 
+	spin_lock_irqsave(&tty->receive_room_lock, flags);
 	if (I_PARMRK(tty)) {
 		/* Multiply read_cnt by 3, since each byte might take up to
 		 * three times as many spaces when PARMRK is set (depending on
@@ -173,6 +175,7 @@ static int receive_room(struct tty_struct *tty)
 		left = N_TTY_BUF_SIZE - read_cnt(ldata) * 3 - 1;
 	} else
 		left = N_TTY_BUF_SIZE - read_cnt(ldata) - 1;
+	spin_unlock_irqrestore(&tty->receive_room_lock, flags);
 
 	/*
 	 * If we are doing input canonicalization, and there are no
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 1ceb255..cf55aaa 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -3140,6 +3140,7 @@ void initialize_tty_struct(struct tty_struct *tty,
 	INIT_WORK(&tty->hangup_work, do_tty_hangup);
 	mutex_init(&tty->atomic_write_lock);
 	spin_lock_init(&tty->ctrl_lock);
+	spin_lock_init(&tty->receive_room_lock);
 	INIT_LIST_HEAD(&tty->tty_files);
 	INIT_WORK(&tty->SAK_work, do_SAK_work);
 
diff --git a/include/linux/tty.h b/include/linux/tty.h
index b90b5c2..ecd35f1 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -284,6 +284,7 @@ struct tty_struct {
 	/* If the tty has a pending do_SAK, queue it here - akpm */
 	struct work_struct SAK_work;
 	struct tty_port *port;
+	spinlock_t receive_room_lock;
 };
 
 /* Each of a tty's open files has private_data pointing to tty_file_private */
-- 
1.7.5.4

