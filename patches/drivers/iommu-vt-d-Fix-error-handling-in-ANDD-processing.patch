From 19bb31de50a23d3920ae2083286be60ab00e4def Mon Sep 17 00:00:00 2001
From: David Woodhouse <David.Woodhouse@intel.com>
Date: Tue, 1 Apr 2014 14:58:36 +0100
Subject: [PATCH 057/108] iommu/vt-d: Fix error handling in ANDD processing

commit 7713ec066ae8adc49dd8daa02a73e6b60af6ee5f upstream.

If we failed to find an ACPI device to correspond to an ANDD record, we
would fail to increment our pointer and would just process the same record
over and over again, with predictable results.

Turn it from a while() loop into a for() loop to let the 'continue' in
the error paths work correctly.

Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 drivers/iommu/dmar.c |    8 +++-----
 1 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c
index 142650e..f445c10 100644
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@ -662,10 +662,9 @@ static int __init dmar_acpi_dev_scope_init(void)
 	if (dmar_tbl == NULL)
 		return -ENODEV;
 
-	andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
-
-	while (((unsigned long)andd) <
-	       ((unsigned long)dmar_tbl) + dmar_tbl->length) {
+	for (andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
+	     ((unsigned long)andd) < ((unsigned long)dmar_tbl) + dmar_tbl->length;
+	     andd = ((void *)andd) + andd->header.length) {
 		if (andd->header.type == ACPI_DMAR_TYPE_ANDD) {
 			acpi_handle h;
 			struct acpi_device *adev;
@@ -685,7 +684,6 @@ static int __init dmar_acpi_dev_scope_init(void)
 			}
 			dmar_acpi_insert_dev_scope(andd->device_number, adev);
 		}
-		andd = ((void *)andd) + andd->header.length;
 	}
 	return 0;
 }
-- 
1.7.5.4

