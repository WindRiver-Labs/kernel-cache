From 4b6205bafeb2d422c0b88c073580a481274ee9b1 Mon Sep 17 00:00:00 2001
From: chunguang yang <chunguang.yang@windriver.com>
Date: Fri, 3 Jul 2015 18:46:06 +0800
Subject: [PATCH 1/2] usb: dwc3: introduce dual role switch function with
 debugfs

The Bakersport board has a usb otg port and due to its hardware design
it only works as usb device port and can't change its role dynamically.
The default dwc3 driver's dual role work is OTG and loads the xhci-hcd module,
which takes irq 22. when loading the usb gadget module like g_printer,
the irq num conflict will occur and the loading failes. Add this patch
to enable dwc3's driver switch to device mode and unload the xhci-hcd module.
Although the patch used for this change was not accepted upstream, it
is technically sound and with Wind River's specific BSP enablement it
is safe for integration into the kernel

This patch is from http://permalink.gmane.org/gmane.linux.usb.general/115277

This patch implemented a feature to dynamic switch to host or device role under
debugfs for some physical limitation that unable to leverage connector A/B
cables (ID pin) to change roles.

The default role should be set as OTG mode. Then use below commands:

[1] switch to host:
echo host > /sys/kernel/debug/dwc3.0.auto/mode

[2] switch to device:
echo device > /sys/kernel/debug/dwc3.0.auto/mode

[3] switch to otg (default mode):
echo otg > /sys/kernel/debug/dwc3.0.auto/mode

Signed-off-by: Huang Rui <ray.huang@amd.com>
Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/usb/dwc3/Makefile  |    1 +
 drivers/usb/dwc3/core.c    |    5 +-
 drivers/usb/dwc3/core.h    |    6 ++
 drivers/usb/dwc3/debugfs.c |   21 ++++--
 drivers/usb/dwc3/drd.c     |  163 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/dwc3/drd.h     |   30 ++++++++
 drivers/usb/dwc3/gadget.c  |   99 +++++++++++++++++----------
 drivers/usb/dwc3/gadget.h  |    4 +
 drivers/usb/dwc3/host.c    |    2 +
 9 files changed, 286 insertions(+), 45 deletions(-)
 create mode 100644 drivers/usb/dwc3/drd.c
 create mode 100644 drivers/usb/dwc3/drd.h

diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 0c7ac92..982661a 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -11,6 +11,7 @@ endif
 
 ifneq ($(filter y,$(CONFIG_USB_DWC3_GADGET) $(CONFIG_USB_DWC3_DUAL_ROLE)),)
 	dwc3-y				+= gadget.o ep0.o
+	dwc3-y				+= gadget.o ep0.o drd.o
 endif
 
 ifneq ($(CONFIG_DEBUG_FS),)
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 1d38603..eb78a3e 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -80,7 +80,7 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
  * dwc3_core_soft_reset - Issues core soft reset and PHY reset
  * @dwc: pointer to our context structure
  */
-static void dwc3_core_soft_reset(struct dwc3 *dwc)
+int dwc3_core_soft_reset(struct dwc3 *dwc)
 {
 	u32		reg;
 
@@ -119,6 +119,7 @@ static void dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 	reg &= ~DWC3_GCTL_CORESOFTRESET;
 	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
+	return 0;
 }
 
 /**
@@ -218,7 +219,7 @@ static int dwc3_alloc_event_buffers(struct dwc3 *dwc, unsigned length)
  *
  * Returns 0 on success otherwise negative errno.
  */
-static int dwc3_event_buffers_setup(struct dwc3 *dwc)
+int dwc3_event_buffers_setup(struct dwc3 *dwc)
 {
 	struct dwc3_event_buffer	*evt;
 	int				n;
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 7ab3c99..e145006 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -632,6 +632,8 @@ struct dwc3_scratchpad_array {
  * @u1u2: only used on revisions <1.83a for workaround
  * @maximum_speed: maximum speed requested (mainly for testing purposes)
  * @revision: revision register contents
+ *  <at> has_gadget: true when gadget is initialized
+ *  <at> has_xhci: true when xhci is initialized
  * @mode: mode of operation
  * @usb2_phy: pointer to USB2 PHY
  * @usb3_phy: pointer to USB3 PHY
@@ -728,6 +730,8 @@ struct dwc3 {
 	unsigned		resize_fifos:1;
 	unsigned		pullups_connected:1;
 
+	bool			has_gadget;
+	bool			has_xhci;
 	enum dwc3_ep0_next	ep0_next_event;
 	enum dwc3_ep0_state	ep0state;
 	enum dwc3_link_state	link_state;
@@ -888,6 +892,8 @@ union dwc3_event {
 /* prototypes */
 void dwc3_set_mode(struct dwc3 *dwc, u32 mode);
 int dwc3_gadget_resize_tx_fifos(struct dwc3 *dwc);
+int dwc3_core_soft_reset(struct dwc3 *dwc);
+int dwc3_event_buffers_setup(struct dwc3 *dwc);
 
 #if IS_ENABLED(CONFIG_USB_DWC3_HOST) || IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE)
 int dwc3_host_init(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/debugfs.c b/drivers/usb/dwc3/debugfs.c
index 9e9f122..fb428c8 100644
--- a/drivers/usb/dwc3/debugfs.c
+++ b/drivers/usb/dwc3/debugfs.c
@@ -52,6 +52,7 @@
 #include "gadget.h"
 #include "io.h"
 #include "debug.h"
+#include "drd.h"
 
 #define dump_register(nm)				\
 {							\
@@ -414,7 +415,6 @@ static ssize_t dwc3_mode_write(struct file *file,
 {
 	struct seq_file		*s = file->private_data;
 	struct dwc3		*dwc = s->private;
-	unsigned long		flags;
 	u32			mode = 0;
 	char			buf[32];
 
@@ -430,11 +430,20 @@ static ssize_t dwc3_mode_write(struct file *file,
 	if (!strncmp(buf, "otg", 3))
 		mode |= DWC3_GCTL_PRTCAP_OTG;
 
-	if (mode) {
-		spin_lock_irqsave(&dwc->lock, flags);
-		dwc3_set_mode(dwc, mode);
-		spin_unlock_irqrestore(&dwc->lock, flags);
-	}
+	switch (mode) {
+	case DWC3_GCTL_PRTCAP_DEVICE:
+		dwc3_drd_to_device(dwc);
+		break;
+	case DWC3_GCTL_PRTCAP_HOST:
+		dwc3_drd_to_host(dwc);
+		break;
+	case DWC3_GCTL_PRTCAP_OTG:
+		dwc3_drd_to_otg(dwc);
+		break;
+	default:
+		/* Should never happen */
+		break;
+        }
 	return count;
 }
 
diff --git a/drivers/usb/dwc3/drd.c b/drivers/usb/dwc3/drd.c
new file mode 100644
index 0000000..f80090f
--- /dev/null
+++ b/drivers/usb/dwc3/drd.c
@@ -0,0 +1,163 @@
+/****
+ * drd.c - DesignWare USB3 DRD Controller Dual Role Switch Funciton File
+ *
+ * Copyright (C) 2014 Advanced Micro Devices, Inc.
+ *
+ * Author: Huang Rui <ray.huang@... <http://gmane.org/get-address.php?address=ray.huang%2d5C7GfCeVMHo%40public.gmane.org>>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/composite.h>
+
+#include "core.h"
+#include "gadget.h"
+#include "io.h"
+#include "drd.h"
+
+
+int dwc3_drd_to_host(struct dwc3 *dwc)
+{
+	int ret;
+	unsigned long flags = 0;
+
+	if (dwc->has_xhci)
+		dwc3_host_exit(dwc);
+	if (dwc->has_gadget)
+		dwc3_gadget_stop_on_switch(dwc);
+
+	ret = dwc3_core_soft_reset(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "soft reset failed\n");
+		goto err0;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	ret = dwc3_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto err0;
+	}
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_HOST);
+
+	ret = dwc3_host_init(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to init host\n");
+		goto err0;
+	}
+err0:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	return ret;
+}
+
+int dwc3_drd_to_device(struct dwc3 *dwc)
+{
+	int ret;
+	unsigned long timeout, flags = 0;
+	u32 reg;
+
+	if (dwc->has_xhci)
+		dwc3_host_exit(dwc);
+	if (dwc->has_gadget)
+		dwc3_gadget_stop_on_switch(dwc);
+
+	ret = dwc3_core_soft_reset(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "soft reset failed\n");
+		goto err0;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
+
+	/* issue device SoftReset too */
+	timeout = jiffies + msecs_to_jiffies(500);
+	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		if (!(reg & DWC3_DCTL_CSFTRST))
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			dev_err(dwc->dev, "Reset Timed Out\n");
+			ret = -ETIMEDOUT;
+			goto err0;
+		}
+
+		cpu_relax();
+	} while (true);
+
+	ret = dwc3_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto err0;
+	}
+
+	ret = dwc3_gadget_restart(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to restart gadget\n");
+		goto err0;
+	}
+err0:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	return ret;
+}
+
+int dwc3_drd_to_otg(struct dwc3 *dwc)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+
+	if (dwc->has_xhci)
+		dwc3_host_exit(dwc);
+	if (dwc->has_gadget)
+		dwc3_gadget_stop_on_switch(dwc);
+
+	ret = dwc3_core_soft_reset(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "soft reset failed\n");
+		goto err0;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	ret = dwc3_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto err0;
+	}
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_OTG);
+
+	ret = dwc3_host_init(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to init host\n");
+		goto err0;
+	}
+
+err0:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	return ret;
+}
diff --git a/drivers/usb/dwc3/drd.h b/drivers/usb/dwc3/drd.h
new file mode 100644
index 0000000..1bacead
--- /dev/null
+++ b/drivers/usb/dwc3/drd.h
@@ -0,0 +1,30 @@
+/****
+ * drd.c - DesignWare USB3 DRD Controller Dual Role Switch Funciton Header
+ *
+ * Copyright (C) 2014 Advanced Micro Devices, Inc.
+ *
+ * Author: Huang Rui <ray.huang@... <http://gmane.org/get-address.php?address=ray.huang%2d5C7GfCeVMHo%40public.gmane.org>>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DRIVERS_USB_DWC3_DRD_H
+#define __DRIVERS_USB_DWC3_DRD_H
+
+#include "core.h"
+#include "gadget.h"
+#include "io.h"
+
+extern int dwc3_drd_to_host(struct dwc3 *dwc);
+extern int dwc3_drd_to_device(struct dwc3 *dwc);
+extern int dwc3_drd_to_otg(struct dwc3 *dwc);
+
+#endif /* __DRIVERS_USB_DWC3_CORE_H */
+
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 8f8e75e..051b613 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -1506,37 +1506,13 @@ static void dwc3_gadget_disable_irq(struct dwc3 *dwc)
 static irqreturn_t dwc3_interrupt(int irq, void *_dwc);
 static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc);
 
-static int dwc3_gadget_start(struct usb_gadget *g,
-		struct usb_gadget_driver *driver)
+int dwc3_gadget_restart(struct dwc3 *dwc)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
-	struct dwc3_ep		*dep;
-	unsigned long		flags;
 	int			ret = 0;
-	int			irq;
-	u32			reg;
-
-	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
-	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
-			IRQF_SHARED | IRQF_ONESHOT, "dwc3", dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
-				irq, ret);
-		goto err0;
-	}
-
-	spin_lock_irqsave(&dwc->lock, flags);
-
-	if (dwc->gadget_driver) {
-		dev_err(dwc->dev, "%s is already bound to %s\n",
-				dwc->gadget.name,
-				dwc->gadget_driver->driver.name);
-		ret = -EBUSY;
-		goto err1;
-	}
-
-	dwc->gadget_driver	= driver;
+ 	u32			reg;
+	struct dwc3_ep		*dep;
 
+	dwc->has_gadget = true;
 	reg = dwc3_readl(dwc->regs, DWC3_DCFG);
 	reg &= ~(DWC3_DCFG_SPEED_MASK);
 
@@ -1568,14 +1544,14 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err2;
+		goto err0;
 	}
 
 	dep = dwc->eps[1];
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err3;
+		goto err1;
 	}
 
 	/* begin to receive SETUP packets */
@@ -1584,25 +1560,72 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 
 	dwc3_gadget_enable_irq(dwc);
 
-	spin_unlock_irqrestore(&dwc->lock, flags);
-
 	return 0;
 
-err3:
+err1:
 	__dwc3_gadget_ep_disable(dwc->eps[0]);
 
-err2:
+err0:
 	dwc->gadget_driver = NULL;
 
-err1:
+	return ret;
+}
+
+
+static int dwc3_gadget_start(struct usb_gadget *g,
+		struct usb_gadget_driver *driver)
+{
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	int			ret = 0;
+	int			irq;
+
+	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
+			IRQF_SHARED, "dwc3", dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
+				irq, ret);
+		goto err0;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->gadget_driver) {
+		dev_err(dwc->dev, "%s is already bound to %s\n",
+				dwc->gadget.name,
+				dwc->gadget_driver->driver.name);
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	dwc->gadget_driver	= driver;
+
+	ret = dwc3_gadget_restart(dwc);
+	if (ret)
+		goto err1;
+
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
+	return 0;
+err1:
+ 	spin_unlock_irqrestore(&dwc->lock, flags);
 	free_irq(irq, dwc);
-
 err0:
-	return ret;
+ 	return ret; 
+}
+
+
+int dwc3_gadget_stop_on_switch(struct dwc3 *dwc)
+{
+	dwc->has_gadget = false;
+	__dwc3_gadget_ep_disable(dwc->eps[0]);
+	__dwc3_gadget_ep_disable(dwc->eps[1]);
+
+	return 0;
 }
 
+
 static int dwc3_gadget_stop(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
 {
@@ -2641,6 +2664,7 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 		goto err3;
 	}
 
+	dwc->has_gadget			= true;
 	dwc->gadget.ops			= &dwc3_gadget_ops;
 	dwc->gadget.max_speed		= USB_SPEED_SUPER;
 	dwc->gadget.speed		= USB_SPEED_UNKNOWN;
@@ -2700,6 +2724,7 @@ err0:
 
 void dwc3_gadget_exit(struct dwc3 *dwc)
 {
+	dwc->has_gadget = false;
 	usb_del_gadget_udc(&dwc->gadget);
 
 	dwc3_gadget_free_endpoints(dwc);
diff --git a/drivers/usb/dwc3/gadget.h b/drivers/usb/dwc3/gadget.h
index b3f25c3..d770ad4 100644
--- a/drivers/usb/dwc3/gadget.h
+++ b/drivers/usb/dwc3/gadget.h
@@ -135,6 +135,10 @@ static inline u32 dwc3_gadget_ep_get_transfer_index(struct dwc3 *dwc, u8 number)
 	return DWC3_DEPCMD_GET_RSC_IDX(res_id);
 }
 
+int dwc3_gadget_restart(struct dwc3 *dwc);
+int dwc3_gadget_stop_on_switch(struct dwc3 *dwc);
+
+
 /**
  * dwc3_gadget_event_string - returns event name
  * @event: the event code
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index 0fa1846..3b0c9f8 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -58,6 +58,7 @@ int dwc3_host_init(struct dwc3 *dwc)
 	xhci->dev.dma_parms	= dwc->dev->dma_parms;
 
 	dwc->xhci = xhci;
+	dwc->has_xhci = true;
 
 	ret = platform_device_add_resources(xhci, dwc->xhci_resources,
 						DWC3_XHCI_RESOURCES_NUM);
@@ -83,5 +84,6 @@ err0:
 
 void dwc3_host_exit(struct dwc3 *dwc)
 {
+	dwc->has_xhci = false;
 	platform_device_unregister(dwc->xhci);
 }
-- 
1.7.5.4

