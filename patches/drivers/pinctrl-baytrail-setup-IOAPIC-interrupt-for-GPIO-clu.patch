From 943138e29eb8726d1c1aca2cf1df616c7c1c8b40 Mon Sep 17 00:00:00 2001
From: "Chew, Kean Ho" <kean.ho.chew@intel.com>
Date: Tue, 11 Feb 2014 11:25:45 -0500
Subject: [PATCH 21/24] pinctrl-baytrail: setup IOAPIC interrupt for GPIO
 clusters on non-ACPI system

commit 0992d01f5f382f6da60004ef87f67ebd3ca13732 valleyisland-io-3.0
git://git.yoctoproject.org/linux-yocto-3.10.git

BayTrail GPIO NORTH, SOUTH and SUS clusters use IRQ48,
49 and 50 respectively. On non-ACPI system, we need
to setup IOAPIC RTE for device that use interrupt
beyond IRQ23.

Signed-off-by: Chew, Kean Ho <kean.ho.chew@intel.com>
Signed-off-by: Chew, Chiau Ee <chiau.ee.chew@intel.com>
Signed-off-by: Sreeju Selvaraj <sreeju.armughanx.selvaraj@intel.com>
Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/pinctrl/pinctrl-baytrail.c |   35 +++++++++++++++++++++++++++++++++++
 1 files changed, 35 insertions(+), 0 deletions(-)

diff --git a/drivers/pinctrl/pinctrl-baytrail.c b/drivers/pinctrl/pinctrl-baytrail.c
index 53b7416..7cd4b61 100644
--- a/drivers/pinctrl/pinctrl-baytrail.c
+++ b/drivers/pinctrl/pinctrl-baytrail.c
@@ -475,6 +475,36 @@ static const struct irq_domain_ops byt_gpio_irq_ops = {
 	.map = byt_gpio_irq_map,
 };
 
+#ifdef CONFIG_PINCTRL_BAYTRAIL_DEVICE
+static int byt_gpio_irq_enable(unsigned hwirq, struct platform_device *pdev)
+{
+	struct io_apic_irq_attr irq_attr;
+	struct device *dev = &pdev->dev;
+	/*
+	 *  Since PCI BIOS is not able to provide IRQ mapping to
+	 *  IRQ24 and onward, we need register to ioapic directly
+	 *  and hardcode pci->irq= hwirq
+	 */
+	irq_attr.ioapic = mp_find_ioapic(hwirq);
+	if (irq_attr.ioapic < 0) {
+		dev_err(&pdev->dev,
+			"Unable to locate IOAPIC for IRQ=%d\n", hwirq);
+		return irq_attr.ioapic;
+	}
+	irq_attr.ioapic_pin = hwirq;
+	irq_attr.trigger = 1;	/* level */
+	irq_attr.polarity = 1;	/* active low */
+	io_apic_set_pci_routing(dev, hwirq, &irq_attr);
+	return 0;
+
+}
+#else
+static int byt_gpio_irq_enable(unsigned hwirq, struct platform_device *pdev)
+{
+	return 0;
+}
+#endif
+
 static int byt_gpio_probe(struct platform_device *pdev)
 {
 	struct byt_gpio *vg;
@@ -550,6 +580,11 @@ static int byt_gpio_probe(struct platform_device *pdev)
 	if (irq_rc && irq_rc->start) {
 		hwirq = irq_rc->start;
 		gc->to_irq = byt_gpio_to_irq;
+		ret = byt_gpio_irq_enable(hwirq, pdev);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to add GPIO to APIC\n");
+			return ret;
+		}
 
 		vg->domain = irq_domain_add_linear(NULL, gc->ngpio,
 						   &byt_gpio_irq_ops, vg);
-- 
1.7.5.4

