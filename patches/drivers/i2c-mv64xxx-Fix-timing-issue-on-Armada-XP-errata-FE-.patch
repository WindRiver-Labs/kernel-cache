From bb467cd9083f4e3a02864b47b5ddceea26a78544 Mon Sep 17 00:00:00 2001
From: lguo1 <Lijun.Guo@windriver.com>
Date: Fri, 6 Mar 2015 08:52:19 +0800
Subject: [PATCH 5/5] i2c: mv64xxx: Fix timing issue on Armada XP (errata
 FE-8471889)

upstream commit	c1d15b68aab86f1f3b602fa65e7618c0065d46e6

i2c: mv64xxx: Fix timing issue on Armada XP (errata FE-8471889)

All the Armada XP (mv78230, mv78260 and mv78460) have a silicon issue
in the I2C controller which violate the i2c repeated start
timing. The I2C standard requires a minimum of 4.7us for the repeated
start condition whereas the I2C controller of the Armada XP this time
is 2.9us.

So this patch adds a 5us delay for the start case only if the the
compatible i2c-mv78230 is set.

Based on the initals patches from Zbigniew Bodek

Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
Signed-off-by: Zbigniew Bodek <zbb@semihalf.com>
Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
Signed-off-by: lguo1 <Lijun.Guo@windriver.com>
---
 drivers/i2c/busses/i2c-mv64xxx.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index 00fbee4..5b8900e 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -23,6 +23,7 @@
 #include <linux/of_i2c.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/delay.h>
 
 /* Register defines */
 #define	MV64XXX_I2C_REG_SLAVE_ADDR			0x00
@@ -112,6 +113,8 @@ struct mv64xxx_i2c_data {
 	spinlock_t		lock;
 	struct i2c_msg		*msg;
 	struct i2c_adapter	adapter;
+	/* 5us delay in order to avoid repeated start timing violation */
+	bool errata_delay;
 };
 
 /*
@@ -261,6 +264,8 @@ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 
 		/* Setup for the next message */
 		mv64xxx_i2c_prepare_for_io(drv_data, drv_data->msgs);
+		if (drv_data->errata_delay)
+			udelay(5);
 
 		/*
 		 * We're never at the start of the message here, and by this
@@ -330,6 +335,9 @@ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
 			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
 		drv_data->block = 0;
+		if (drv_data->errata_delay)
+			udelay(5);
+
 		wake_up_interruptible(&drv_data->waitq);
 		break;
 	}
-- 
1.7.5.4

