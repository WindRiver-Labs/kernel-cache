From 0efddd716c2daf7a393f74ed7945f0348eb122f0 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Fri, 27 Aug 2010 11:46:09 +0800
Subject: [PATCH 1/4] SDHCI: get proper input clock for no frequency fixing by u-boot

The handling of general "auto-cmd12"/"broken-timeout" quirks and
MMC_BUS_WIDTH_8 is merged form mainline.

The input clock frequency of SDHCI controller needs to be caculated
based on platform bus frequency, since "clock-frequency" property of SDCHI
in DTB blob is not fixed by u-boot on mpc83xx platform. This is from
vendor drop ltib-mpc8308erdb-20100413.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mmc/host/sdhci-of-core.c |   53 ++++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci.c         |   18 ++++++++++++-
 drivers/mmc/host/sdhci.h         |   13 ++++++++-
 3 files changed, 82 insertions(+), 2 deletions(-)

diff --git a/drivers/mmc/host/sdhci-of-core.c b/drivers/mmc/host/sdhci-of-core.c
index 55e3313..a873b29 100644
--- a/drivers/mmc/host/sdhci-of-core.c
+++ b/drivers/mmc/host/sdhci-of-core.c
@@ -25,6 +25,8 @@
 #include "sdhci-of.h"
 #include "sdhci.h"
 
+#include <sysdev/fsl_soc.h>
+
 #ifdef CONFIG_MMC_SDHCI_BIG_ENDIAN_32BIT_BYTE_SWAPPER
 
 /*
@@ -154,6 +156,12 @@ static int __devinit sdhci_of_probe(struct of_device *ofdev,
 		host->ops = &sdhci_of_data->ops;
 	}
 
+	if (of_get_property(np, "sdhci,auto-cmd12", NULL))
+		host->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
+
+	if (of_get_property(np, "sdhci,broken-timeout", NULL))
+		host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
+
 	if (of_get_property(np, "sdhci,1-bit-only", NULL))
 		host->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;
 
@@ -163,6 +171,50 @@ static int __devinit sdhci_of_probe(struct of_device *ofdev,
 	clk = of_get_property(np, "clock-frequency", &size);
 	if (clk && size == sizeof(*clk) && *clk)
 		of_host->clock = *clk;
+	else {
+		/* clock frequency of peripherals maybe not fixed by u-boot
+		 * on some platforms, then need to find proper clock of
+		 * SDHCI controller by CPU's bus frequency.*/
+		struct device_node *cpu;
+
+		cpu = of_find_node_by_type(NULL, "cpu");
+		if (cpu) {
+			unsigned int size;
+			const u32 *prop = of_get_property(cpu, "bus-frequency", &size);
+			of_host->clock = *prop;
+			of_node_put(cpu);
+		} else {
+			ret = -EINVAL;
+			goto err_bad_freq;
+		}
+
+		/*
+		 * SDHCI input clock can be scaled against platform bus frequency.
+		 */
+		if (of_get_property(np, "sdhci,clk-scale", NULL)) {
+
+			void __iomem *immap = NULL;
+			unsigned int sdhccm;
+
+			immap = ioremap(get_immrbase(), 0x1000);
+			if (!immap) {
+				ret = -ENOMEM;
+				goto err_bad_freq;
+			}
+
+			sdhccm = (in_be32(immap + SDHCI_SCCR_OFFS) & SDHCI_SDHCCM_MASK)
+				>> SDHCI_SDHCCM_SHIFT;
+
+			iounmap(immap);
+
+			if (sdhccm == 0) {
+				printk(KERN_ERR "The eSDHC clock was disable!\n");
+				ret = -EBADSLT;
+				goto err_bad_freq;
+			} else
+				of_host->clock /= sdhccm;
+		}
+	}
 
 	ret = sdhci_add_host(host);
 	if (ret)
@@ -171,6 +223,7 @@ static int __devinit sdhci_of_probe(struct of_device *ofdev,
 	return 0;
 
 err_add_host:
+err_bad_freq:
 	irq_dispose_mapping(host->irq);
 err_no_irq:
 	iounmap(host->ioaddr);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 9d4fdfa..b7a1ce4 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -807,8 +807,12 @@ static void sdhci_set_transfer_mode(struct sdhci_host *host,
 	WARN_ON(!host->data);
 
 	mode = SDHCI_TRNS_BLK_CNT_EN;
-	if (data->blocks > 1)
+	if (data->blocks > 1) {
+		if (host->quirks & SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12)
+			mode |= SDHCI_TRNS_MULTI | SDHCI_TRNS_ACMD12;
+		else
 		mode |= SDHCI_TRNS_MULTI;
+	}
 	if (data->flags & MMC_DATA_READ)
 		mode |= SDHCI_TRNS_READ;
 	if (host->flags & SDHCI_REQ_USE_DMA)
@@ -1099,6 +1103,13 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	sdhci_activate_led(host);
 #endif
 
+	if (host->quirks & SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12) {
+		if (mrq->stop) {
+			mrq->data->stop = NULL;
+			mrq->stop = NULL;
+		}
+	}
+
 	host->mrq = mrq;
 
 	/* If polling, assume that the card is always present. */
@@ -1149,6 +1160,11 @@ static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
 
+	if (ios->bus_width == MMC_BUS_WIDTH_8)
+		ctrl |= SDHCI_CTRL_8BITBUS;
+	else
+		ctrl &= ~SDHCI_CTRL_8BITBUS;
+
 	if (ios->bus_width == MMC_BUS_WIDTH_4)
 		ctrl |= SDHCI_CTRL_4BITBUS;
 	else
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 842f46f..face3c4 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -17,6 +17,14 @@
 #include <linux/io.h>
 
 /*
+ * SoC register
+ */
+/*System Clock Control Register (SCCR)*/
+#define SDHCI_SCCR_OFFS	0xA08
+#define SDHCI_SDHCCM_MASK	0x0c000000
+#define SDHCI_SDHCCM_SHIFT	26
+
+/*
  * Controller registers
  */
 
@@ -72,6 +80,7 @@
 #define   SDHCI_CTRL_ADMA1	0x08
 #define   SDHCI_CTRL_ADMA32	0x10
 #define   SDHCI_CTRL_ADMA64	0x18
+#define  SDHCI_CTRL_8BITBUS	0x20
 
 #define SDHCI_POWER_CONTROL	0x29
 #define  SDHCI_POWER_ON		0x01
@@ -127,7 +136,7 @@
 #define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
 		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
 		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
-		SDHCI_INT_DATA_END_BIT | SDHCI_ADMA_ERROR)
+		SDHCI_INT_DATA_END_BIT | SDHCI_INT_ADMA_ERROR)
 #define SDHCI_INT_ALL_MASK	((unsigned int)-1)
 
 #define SDHCI_ACMD12_ERR	0x3C
@@ -236,6 +245,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK_DELAY_AFTER_POWER			(1<<23)
 /* Controller uses SDCLK instead of TMCLK for data timeouts */
 #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
+/* Controller uses Auto CMD12 command to stop the transfer */
+#define SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12		(1<<25)
 
 	int			irq;		/* Device IRQ */
 	void __iomem *		ioaddr;		/* Mapped address */
-- 
1.6.5.2

