From aa8337c23e2210407599d51fefcaa8ddfec09cb6 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 16 Jan 2013 16:56:04 +0800
Subject: [PATCH] ACPI, APEI: Fixup incorrect 64-bit access width firmware bug

The bit width check was introduced by 15afae60 (ACPI, APEI: Fix
incorrect APEI register bit width check and usage), and a fixup
for incorrect 32-bit width memory address was given by f712c71
(ACPI, APEI: Fixup common access width firmware bug). Now there
is a similar symptom:

[Firmware Bug]: APEI: Invalid bit width + offset in GAR [0x12345000/64/0/3/0]

Another bogus BIOS reports an incorrect 64-bit width in trigger table.
Thus, apply to a similar workaround for 64-bit width memory address when:

1) the access bit field within the physical memory address should be from
bit-0 (indicated by bit_offset), and

2) the access bit width within the physical memory address should be 64 bit
(indicated by bit_width), and

3) the physical memory address should be aligned to 8 bytes (indicated by
*paddr & 0x07 == 0), and

4) the actual bit length of physical memory address is shorter than access
 bit width.

If all 4 conditions above are met, we enlarge the actual bit length of physical
memory address to be accessed.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/acpi/apei/apei-base.c |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/acpi/apei/apei-base.c b/drivers/acpi/apei/apei-base.c
index 00a7836..46f80e2 100644
--- a/drivers/acpi/apei/apei-base.c
+++ b/drivers/acpi/apei/apei-base.c
@@ -590,6 +590,9 @@ static int apei_check_gar(struct acpi_generic_address *reg, u64 *paddr,
 	if (bit_width == 32 && bit_offset == 0 && (*paddr & 0x03) == 0 &&
 	    *access_bit_width < 32)
 		*access_bit_width = 32;
+	else if (bit_width == 64 && bit_offset == 0 && (*paddr & 0x07) == 0 &&
+	    *access_bit_width < 64)
+		*access_bit_width = 64;
 
 	if ((bit_width + bit_offset) > *access_bit_width) {
 		pr_warning(FW_BUG APEI_PFX
-- 
1.7.9.7

