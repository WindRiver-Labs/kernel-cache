From e27e8b94e5d723ed3b92d663fc92b4864272a76f Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Sat, 18 Jun 2011 17:46:42 +0800
Subject: [PATCH 22/27] ARM:CNS34xx:Add SDHCI driver

CNS34xx processor implements one SDHCI, this patch adds
SoC-specific ops and quirks for SDHCI platform driver.

Extracted from vendor drop CNS3xxx-sdk-201102161603-v1.1_20110224.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm/mach-cns3xxx/cns3420vb.c |   24 ++++++
 drivers/mmc/host/Kconfig          |    9 ++
 drivers/mmc/host/Makefile         |    1 +
 drivers/mmc/host/sdhci-cns3xxx.c  |  147 +++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci-pltfm.c    |    5 +-
 drivers/mmc/host/sdhci-pltfm.h    |    4 +
 drivers/mmc/host/sdhci.c          |    4 +
 7 files changed, 193 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mmc/host/sdhci-cns3xxx.c

diff --git a/arch/arm/mach-cns3xxx/cns3420vb.c b/arch/arm/mach-cns3xxx/cns3420vb.c
index 462dc6a..01b09c2 100644
--- a/arch/arm/mach-cns3xxx/cns3420vb.c
+++ b/arch/arm/mach-cns3xxx/cns3420vb.c
@@ -256,6 +256,29 @@ static struct platform_device cns3xxx_usb_otg_device = {
 };
 
 /*
+ * SDHCI
+ */
+static struct resource cns3xxx_sdhci_resources[] = {
+	[0] = {
+		.start = CNS3XXX_SDIO_BASE,
+		.end   = CNS3XXX_SDIO_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CNS3XXX_SDIO,
+		.end   = IRQ_CNS3XXX_SDIO,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cns3xxx_sdhci_device = {
+	.name		= "sdhci-cns3xxx",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(cns3xxx_sdhci_resources),
+	.resource	= cns3xxx_sdhci_resources,
+};
+
+/*
  * Initialization
  */
 static struct platform_device *cns3420_pdevs[] __initdata = {
@@ -265,6 +288,7 @@ static struct platform_device *cns3420_pdevs[] __initdata = {
 	&cns3xxx_i2c_controller_device,
 	&cns3xxx_usb_ehci_device,
 	&cns3xxx_usb_otg_device,
+	&cns3xxx_sdhci_device,
 };
 
 static void __init cns3420_init(void)
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 4fa1f9a..3f1dd7b 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -121,6 +121,15 @@ config MMC_SDHCI_PLTFM
 
 	  If unsure, say N.
 
+config MMC_SDHCI_CNS3XXX
+	bool "SDHCI support on the Cavium Networks CNS3xxx SoC"
+	depends on ARCH_CNS3XXX
+	depends on MMC_SDHCI_PLTFM
+	help
+	  This selects the SDHCI support for CNS3xxx System-on-Chip devices.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_S3C
 	tristate "SDHCI support on Samsung S3C SoC"
 	depends on MMC_SDHCI && (PLAT_S3C24XX || PLAT_S3C64XX)
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index a7ae648..bbd998c 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_SDH_BFIN)		+= bfin_sdh.o
 
 obj-$(CONFIG_MMC_SDHCI_PLTFM)			+= sdhci-platform.o
 sdhci-platform-y				:= sdhci-pltfm.o
+sdhci-platform-$(CONFIG_MMC_SDHCI_CNS3XXX)	+= sdhci-cns3xxx.o
 
 obj-$(CONFIG_MMC_SDHCI_OF)	+= sdhci-of.o
 sdhci-of-y				:= sdhci-of-core.o
diff --git a/drivers/mmc/host/sdhci-cns3xxx.c b/drivers/mmc/host/sdhci-cns3xxx.c
new file mode 100644
index 0000000..37568f9
--- /dev/null
+++ b/drivers/mmc/host/sdhci-cns3xxx.c
@@ -0,0 +1,147 @@
+/*
+ * SDHCI support for CNS3xxx SoC
+ *
+ * Copyright 2008 Cavium Networks
+ * Copyright 2010 MontaVista Software, LLC.
+ *
+ * Authors: Scott Shu
+ *	    Anton Vorontsov <avorontsov@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/mmc/host.h>
+#include <linux/sdhci-pltfm.h>
+#include <mach/cns3xxx.h>
+#include "sdhci.h"
+#include "sdhci-pltfm.h"
+
+static unsigned int sdhci_cns3xxx_get_max_clk(struct sdhci_host *host)
+{
+	int clk = 50000000;
+
+	return clk;
+}
+
+static unsigned int sdhci_cns3xxx_get_timeout_clk(struct sdhci_host *host)
+{
+	return sdhci_cns3xxx_get_max_clk(host) / 100000;
+}
+
+/*
+ * sdhci_cns3xxx_set_clock - callback on clock change
+ *
+ * When the card's clock is going to be changed, look at the new frequency
+ * and find the best clock source to go with it.
+ */
+static void sdhci_cns3xxx_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	u16 clk;
+	unsigned long timeout;
+	int max_speed, div = 1;
+	int hclk = cns3xxx_cpu_clock()/4;
+
+	if (clock == host->clock)
+		return;
+
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+	if (clock == 0)
+		goto out;
+
+   /*
+	* SD frequency divider should be determined by HCLK
+	* the maximum SD clock is 25MHz (normal speed mode)
+	* or 50MHz (high speed mode)
+	* formula => SD clock = (HCLK / divisor)
+	*/
+	div = 1;
+	hclk = cns3xxx_cpu_clock()/4;
+
+	if (0x4 & sdhci_readw(host, 0x28))
+		max_speed = 50;
+	else
+		max_speed = 25;
+
+	while (max_speed < (hclk/div))
+		div++;
+
+	switch (div) {
+	case 1:
+		clk = 0x00 << SDHCI_DIVIDER_SHIFT;
+		break;
+	case 2:
+		/* base clock divided by 2 */
+		clk = 0x01 << SDHCI_DIVIDER_SHIFT;
+		break;
+	case 3:
+		/* base clock divided by 3 */
+		clk = 0x03 << SDHCI_DIVIDER_SHIFT;
+		break;
+	case 4:
+		/* base clock divided by 4 */
+		clk = 0x02 << SDHCI_DIVIDER_SHIFT;
+		break;
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+		/* base clock divided by 8 */
+		clk = 0x04 << SDHCI_DIVIDER_SHIFT;
+		break;
+	default:
+		/* base clock divided by 16 */
+		clk = 0x08 << SDHCI_DIVIDER_SHIFT;
+		break;
+	}
+
+	clk |= SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	timeout = 10;
+	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0)
+			return;
+
+		timeout--;
+		mdelay(1);
+	}
+
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	host->timeout_clk = sdhci_cns3xxx_get_timeout_clk(host);
+out:
+	host->clock = clock;
+}
+
+static struct sdhci_ops sdhci_cns3xxx_ops = {
+	.get_max_clock	= sdhci_cns3xxx_get_max_clk,
+	.set_clock	= sdhci_cns3xxx_set_clock,
+};
+
+int sdhci_cns3xxx_init(struct sdhci_host *host)
+{
+	u32 gpioa_pins = __raw_readl(MISC_GPIOA_PIN_ENABLE_REG);
+	/* MMC/SD pins share with GPIOA */
+	gpioa_pins |= 0x1f0f0004;
+	__raw_writel(gpioa_pins, MISC_GPIOA_PIN_ENABLE_REG);
+
+	cns3xxx_pwr_clk_en(CNS3XXX_PWR_CLK_EN(SDIO));
+	cns3xxx_pwr_soft_rst(CNS3XXX_PWR_SOFTWARE_RST(SDIO));
+	return 0;
+}
+
+struct sdhci_pltfm_data sdhci_cns3xxx_pdata = {
+	.ops = &sdhci_cns3xxx_ops,
+	.quirks = SDHCI_QUIRK_BROKEN_DMA |
+		  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |
+		  SDHCI_QUIRK_INVERTED_WRITE_PROTECT |
+		  SDHCI_QUIRK_NONSTANDARD_CLOCK,
+	.init = sdhci_cns3xxx_init,
+};
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index f8dfbf0..e045e3c 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -67,7 +67,7 @@ static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	if (resource_size(iomem) != 0x100)
+	if (resource_size(iomem) < 0x100)
 		dev_err(&pdev->dev, "Invalid iomem size. You may "
 			"experience problems.\n");
 
@@ -158,6 +158,9 @@ static int __devexit sdhci_pltfm_remove(struct platform_device *pdev)
 
 static const struct platform_device_id sdhci_pltfm_ids[] = {
 	{ "sdhci", },
+#ifdef CONFIG_MMC_SDHCI_CNS3XXX
+	{ "sdhci-cns3xxx", (kernel_ulong_t)&sdhci_cns3xxx_pdata },
+#endif
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, sdhci_pltfm_ids);
diff --git a/drivers/mmc/host/sdhci-pltfm.h b/drivers/mmc/host/sdhci-pltfm.h
index 4aa07a9..900f329 100644
--- a/drivers/mmc/host/sdhci-pltfm.h
+++ b/drivers/mmc/host/sdhci-pltfm.h
@@ -11,4 +11,8 @@
 #ifndef _DRIVERS_MMC_SDHCI_PLTFM_H
 #define _DRIVERS_MMC_SDHCI_PLTFM_H
 
+#include <linux/sdhci-pltfm.h>
+
+extern struct sdhci_pltfm_data sdhci_cns3xxx_pdata;
+
 #endif /* _DRIVERS_MMC_SDHCI_PLTFM_H */
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index d03d4a9..c729d0b 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -297,6 +297,10 @@ static void sdhci_read_block_pio(struct sdhci_host *host)
 		}
 	}
 
+#ifdef CONFIG_MMC_SDHCI_CNS3XXX
+	flush_dcache_page(host->sg_miter.page);
+#endif
+
 	sg_miter_stop(&host->sg_miter);
 
 	local_irq_restore(flags);
-- 
1.7.0.4

