From 6dc862b244169e8d8679c0324fa2c618957cdd31 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 24 Mar 2010 13:46:39 +0800
Subject: [PATCH 2/2] touchscreen: move regulator operations out of spinlock protected area

The commit 9114337 introduces regulator operations in the ads7846
touchscreen driver. Among these operations, some are called in the
spinlock protected context.
On most platforms, the regulator operation is achieved through
i2c/spi bus transfer operations, some of bus transfer operations will
call wait_for_completion function. It isn't allowable  to call
sleepable function in the atomic context. So move them out from the
atomic context.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/input/touchscreen/ads7846.c |   16 +++++++++++++---
 1 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/drivers/input/touchscreen/ads7846.c b/drivers/input/touchscreen/ads7846.c
index 532279c..f6b9e7c 100644
--- a/drivers/input/touchscreen/ads7846.c
+++ b/drivers/input/touchscreen/ads7846.c
@@ -484,6 +484,9 @@ static ssize_t ads7846_disable_store(struct device *dev,
 	if (strict_strtoul(buf, 10, &i))
 		return -EINVAL;
 
+	if (!i)
+		regulator_enable(ts->reg);
+
 	spin_lock_irq(&ts->lock);
 
 	if (i)
@@ -493,6 +496,9 @@ static ssize_t ads7846_disable_store(struct device *dev,
 
 	spin_unlock_irq(&ts->lock);
 
+	if (i)
+		regulator_disable(ts->reg);
+
 	return count;
 }
 
@@ -789,9 +795,11 @@ static void ads7846_disable(struct ads7846 *ts)
 			msleep(1);
 			spin_lock_irq(&ts->lock);
 		}
+
+		ts->irq_disabled = 1;
+		disable_irq(ts->spi->irq);
 	}
 
-	regulator_disable(ts->reg);
 
 	/* we know the chip's in lowpower mode since we always
 	 * leave it that way after every request
@@ -804,8 +812,6 @@ static void ads7846_enable(struct ads7846 *ts)
 	if (!ts->disabled)
 		return;
 
-	regulator_enable(ts->reg);
-
 	ts->disabled = 0;
 	ts->irq_disabled = 0;
 	enable_irq(ts->spi->irq);
@@ -822,6 +828,8 @@ static int ads7846_suspend(struct spi_device *spi, pm_message_t message)
 
 	spin_unlock_irq(&ts->lock);
 
+	regulator_disable(ts->reg);
+
 	if (device_may_wakeup(&ts->spi->dev))
 		enable_irq_wake(ts->spi->irq);
 
@@ -836,6 +844,8 @@ static int ads7846_resume(struct spi_device *spi)
 	if (device_may_wakeup(&ts->spi->dev))
 		disable_irq_wake(ts->spi->irq);
 
+	regulator_enable(ts->reg);
+
 	spin_lock_irq(&ts->lock);
 
 	ts->is_suspended = 0;
-- 
1.6.5.2

