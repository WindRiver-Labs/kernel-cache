From 6503a94d4cebf5de7e3ea303d390169d7ef47cbe Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Fri, 12 Oct 2012 12:49:24 -0700
Subject: [PATCH 68/70] adr: Adding ADR memory type support

This patch is provided by dave.jiang@intel.com, and it is not
committed to mainline yet.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
[ywei: Fix context conflict]
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 Documentation/kernel-parameters.txt |    6 ++++
 arch/x86/Kconfig                    |   26 ++++++++++++++++++
 arch/x86/include/asm/e820.h         |   50 ++++++++++++++++++++++++++++++----
 arch/x86/kernel/Makefile            |    2 +
 arch/x86/kernel/adr.c               |   51 +++++++++++++++++++++++++++++++++++
 arch/x86/kernel/e820.c              |   26 +++++++++++++----
 arch/x86/kernel/setup.c             |   21 ++++++++++++++
 arch/x86/mm/pageattr.c              |    1 +
 8 files changed, 171 insertions(+), 12 deletions(-)
 create mode 100644 arch/x86/kernel/adr.c

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index a5fa68a..bb8b83f 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1497,6 +1497,12 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			         or
 			         memmap=0x10000$0x18690000
 
+	memmap=nn[KMG]!ss[KMG]
+			[KNL,X86] Mark specific memory as protected.
+			Region of memory to be used, from ss to ss+nn.
+			The memory region may be marked as type 12 and
+			is NVDIMM or ADR memory.
+
 	memory_corruption_check=0/1 [X86]
 			Some BIOSes seem to corrupt the first 64k of
 			memory when doing things like suspend/resume.
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 9374fe5..3f049b1 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1305,6 +1305,32 @@ config ILLEGAL_POINTER_VALUE
 
 source "mm/Kconfig"
 
+config ADR
+	bool "Support ADR protected memory"
+	depends on X86_64
+	help
+	  Asynchronous DRAM Refresh is a mechanism to protect a region
+	  of system memory from platform power loss.  RAM is protected
+	  in a fashion similar to the S3 state except that entrance into
+	  this state is:
+	  1/ asynchronous, i.e. no opportunity to save state
+	  2/ does not protect all of memory
+	  3/ it only protects data in the DIMM and data that has safely
+	     reached ADR protected buffers in the platform
+
+	  If you say N the kernel will treat the ADR region like an e820
+	  reserved region.
+
+	  Say Y if unsure
+
+config ADR_MEM_TYPE
+	int "ACPI memory type for ADR reserved memory"
+	default "12"
+	---help---
+	The memory type specified by the BIOS for ADR reserved memory. On the
+	Intel JasperForest CPU the BIOS used 6. With the Intel Jaketown CPU the
+	type has been changed to 12 due to 6 being reserved by ACPI spec now.
+
 config HIGHPTE
 	bool "Allocate 3rd-level pagetables from highmem"
 	depends on HIGHMEM
diff --git a/arch/x86/include/asm/e820.h b/arch/x86/include/asm/e820.h
index 3778256..b3fef15 100644
--- a/arch/x86/include/asm/e820.h
+++ b/arch/x86/include/asm/e820.h
@@ -33,6 +33,8 @@
 #else	/* ! CONFIG_EFI */
 #define E820_X_MAX E820MAX
 #endif
+#include <linux/ioport.h>
+#define HIGH_MEMORY	(1024*1024)
 #else	/* ! __KERNEL__ */
 #define E820_X_MAX E820MAX
 #endif
@@ -53,6 +55,9 @@
  */
 #define E820_RESERVED_KERN        128
 
+/* protected RAM interpreted type */
+#define E820_PROTECTED_KERN   CONFIG_ADR_MEM_TYPE
+
 #ifndef __ASSEMBLY__
 #include <linux/types.h>
 struct e820entry {
@@ -76,6 +81,45 @@ struct e820map {
 #define BIOS_ROM_END		0xffffffff
 
 #ifdef __KERNEL__
+
+#ifdef CONFIG_ADR
+#define ADR_MAX_REGIONS 4
+extern struct resource *adr_resource[ADR_MAX_REGIONS];
+
+/* memory protected by the system ADR (asynchronous dram refresh)
+ * mechanism is accounted as ram for purposes of establishing max_pfn
+ * and mem_map
+ */
+static inline bool is_e820_ram(__u32 type)
+{
+    if (type == E820_RAM || type == E820_PROTECTED_KERN)
+        return true;
+    return false;
+}
+
+static inline void e820_set_adr_resource(struct resource *res)
+{
+    int i;
+
+    for (i = 0; i < ADR_MAX_REGIONS; i++)
+        if (adr_resource[i] == NULL) {
+            adr_resource[i] = res;
+            break;
+        }
+}
+#else
+static inline bool is_e820_ram(__u32 type)
+{
+    if (type == E820_RAM)
+        return true;
+    return false;
+}
+
+static inline void e820_set_adr_resource(struct resource *res)
+{
+}
+#endif
+
 /* see comment in arch/x86/kernel/e820.c */
 extern struct e820map e820;
 extern struct e820map e820_saved;
@@ -140,10 +184,4 @@ static inline bool is_ISA_range(u64 s, u64 e)
 #endif /* __KERNEL__ */
 #endif /* __ASSEMBLY__ */
 
-#ifdef __KERNEL__
-#include <linux/ioport.h>
-
-#define HIGH_MEMORY	(1024*1024)
-#endif /* __KERNEL__ */
-
 #endif /* _ASM_X86_E820_H */
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index b1efe68..9a6ff14 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -92,6 +92,8 @@ obj-$(CONFIG_PARAVIRT_CLOCK)	+= pvclock.o
 
 obj-$(CONFIG_PCSPKR_PLATFORM)	+= pcspeaker.o
 
+obj-$(CONFIG_ADR)		+= adr.o
+
 microcode-y				:= microcode_core.o
 microcode-$(CONFIG_MICROCODE_INTEL)	+= microcode_intel.o
 microcode-$(CONFIG_MICROCODE_AMD)	+= microcode_amd.o
diff --git a/arch/x86/kernel/adr.c b/arch/x86/kernel/adr.c
new file mode 100644
index 0000000..379b39f
--- /dev/null
+++ b/arch/x86/kernel/adr.c
@@ -0,0 +1,51 @@
+/*
+ * platform device for ADR protected memory
+ * Copyright (c) 2009, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <asm/e820.h>
+
+static struct resource adr_res[ADR_MAX_REGIONS];
+
+static struct platform_device adr_device = {
+	.name = "adr",
+	.id = 0,
+	.resource = adr_res,
+};
+
+static __init int register_adr_device(void)
+{
+	int rc, i;
+
+	for (i = 0; i < ADR_MAX_REGIONS; i++)
+		if (adr_resource[i]) {
+			adr_res[i] = *adr_resource[i];
+			adr_device.num_resources++;
+		}
+
+	if (!adr_device.num_resources)
+		return 0;
+
+	rc = platform_device_register(&adr_device);
+	if (rc == 0)
+		dev_info(&adr_device.dev, "registered platform adr device\n");
+
+	return rc;
+}
+
+device_initcall(register_adr_device);
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 298dc00..10c4338 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -48,6 +48,11 @@ unsigned long pci_mem_start = 0xaeedbabe;
 EXPORT_SYMBOL(pci_mem_start);
 #endif
 
+#ifdef CONFIG_ADR
+/* collects protected memory ranges for the bbu driver */
+struct resource *adr_resource[ADR_MAX_REGIONS];
+#endif
+
 /*
  * This function checks if any part of the range <start,end> is mapped
  * with type.
@@ -147,6 +152,8 @@ static void __init e820_print_type(u32 type)
 	case E820_UNUSABLE:
 		printk(KERN_CONT "(unusable)");
 		break;
+	case E820_PROTECTED_KERN:
+		printk(KERN_CONT "(protected)\n");
 	default:
 		printk(KERN_CONT "type %u", type);
 		break;
@@ -694,7 +701,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 			register_nosave_region(pfn, PFN_UP(ei->addr));
 
 		pfn = PFN_DOWN(ei->addr + ei->size);
-		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
+		if (!is_e820_ram(ei->type) && ei->type != E820_RESERVED_KERN)
 			register_nosave_region(PFN_UP(ei->addr), pfn);
 
 		if (pfn >= limit_pfn)
@@ -754,7 +761,7 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
 {
 	int i;
 	unsigned long last_pfn = 0;
@@ -765,7 +772,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
-		if (ei->type != type)
+		if (!is_e820_ram(ei->type))
 			continue;
 
 		start_pfn = ei->addr >> PAGE_SHIFT;
@@ -790,12 +797,12 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
-	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
+	return e820_end_pfn(MAX_ARCH_PFN);
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
-	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
+	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT));
 }
 
 static void early_panic(char *msg)
@@ -872,6 +879,9 @@ static int __init parse_memmap_opt(char *p)
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
 		e820_add_region(start_at, mem_size, E820_RESERVED);
+	} else if (*p == '!') {
+		start_at = memparse(p+1, &p);
+		e820_add_region(start_at, mem_size, E820_PROTECTED_KERN);
 	} else
 		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
@@ -901,6 +911,7 @@ static inline const char *e820_type_to_string(int e820_type)
 	case E820_ACPI:	return "ACPI Tables";
 	case E820_NVS:	return "ACPI Non-volatile Storage";
 	case E820_UNUSABLE:	return "Unusable memory";
+	case E820_PROTECTED_KERN: return "Protected RAM";
 	default:	return "reserved";
 	}
 }
@@ -935,7 +946,10 @@ void __init e820_reserve_resources(void)
 		 * pcibios_resource_survey()
 		 */
 		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20)) {
-			res->flags |= IORESOURCE_BUSY;
+			if (e820.map[i].type == E820_PROTECTED_KERN)
+				e820_set_adr_resource(res);
+			else
+				res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
 		res++;
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index dc29333..cb8c2b2 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -425,6 +425,25 @@ static void __init reserve_initrd(void)
 }
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+static void __init reserve_adr(void)
+{
+#ifdef CONFIG_ADR
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		if (ei->type != E820_PROTECTED_KERN)
+			continue;
+
+		memblock_reserve(ei->addr, ei->addr + ei->size);
+		max_pfn_mapped = init_memory_mapping(
+				ei->addr < 1UL << 32 ? 1UL << 32 : ei->addr,
+				ei->addr + ei->size);
+	}
+#endif
+}
+
 static void __init parse_setup_data(void)
 {
 	struct setup_data *data;
@@ -1057,6 +1076,8 @@ void __init setup_arch(char **cmdline_p)
 
 	early_acpi_boot_init();
 
+	reserve_adr();
+
 	initmem_init();
 	memblock_find_dma_reserve();
 
diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c
index e1ebde3..80918f6 100644
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@ -1092,6 +1092,7 @@ int _set_memory_wb(unsigned long addr, int numpages)
 	return change_page_attr_clear(&addr, numpages,
 				      __pgprot(_PAGE_CACHE_MASK), 0);
 }
+EXPORT_SYMBOL(_set_memory_wb);
 
 int set_memory_wb(unsigned long addr, int numpages)
 {
-- 
1.7.5.4

