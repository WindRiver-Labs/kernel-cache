From 5b8eeabc310cbded7889c1dfc566f278b741ff05 Mon Sep 17 00:00:00 2001
From: Jon Mason <jon.mason@intel.com>
Date: Thu, 7 Feb 2013 10:42:27 -0700
Subject: [PATCH 33/70] NTB: Xeon AER support

This patch is provided by dave.jiang@intel.com via e-mail, and not
committed to mainline yet.

In Xeon NTB, AER appears as a vendor specific extended capability of PCI
Config space, and not the standard PCI AER capability.  Unfortunately,
this means it cannot use the Linux AER infrastructure and must do its
own detection and recovery.

When an AER event occurs, a link interrupt is encountered.  The driver
must now check on all link interrupts for AER events and Link changes.
For all correctable and non-fatal events, log the error and continue
running as normal.  If a fatal event is encountered, retrain the link
and attempt to recover.

Signed-off-by: Jon Mason <jon.mason@intel.com>
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/ntb/ntb_hw.c   |  120 +++++++++++++++++++++++++++++++++++++++++++++++-
 drivers/ntb/ntb_regs.h |   17 +++++++
 2 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/drivers/ntb/ntb_hw.c b/drivers/ntb/ntb_hw.c
index 2ce8a83..cdcc3b3 100644
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@ -513,9 +513,41 @@ static int ntb_xeon_setup(struct ntb_device *ndev)
 {
 	int rc;
 	u8 val;
+	u32 val32;
 
 	ndev->hw_type = SNB_HW;
 
+	/* Enable non-standard AER */
+	rc = pci_write_config_dword(ndev->pdev, SNB_RPERRCMD_OFFSET,
+				    SNB_AER_FATAL_ENABLE |
+				    SNB_AER_NONFATAL_ENABLE |
+				    SNB_AER_CORRERR_ENABLE);
+	if (rc)
+		dev_err(&ndev->pdev->dev, "AER enablement failed, continuing on anyway.\n");
+
+	/* Disable SLD AER event, as this will show up as a Link down interrupt
+	 * in B2B mode.  Also, make the error not fatal.  Otherwise, any
+	 * non-fatal error will be escilated to fatal when it is detected due to
+	 * a fatal SLD error being detected but masked.
+	 */
+	rc = pci_read_config_dword(ndev->pdev, SNB_UNCERRMSK_OFFSET, &val32);
+	if (rc)
+		return rc;
+
+	val32 |= SNB_AER_SLDMASK;
+	rc = pci_write_config_dword(ndev->pdev, SNB_UNCERRMSK_OFFSET, val32);
+	if (rc)
+		return rc;
+
+	rc = pci_read_config_dword(ndev->pdev, SNB_UNCERRSEV_OFFSET, &val32);
+	if (rc)
+		return rc;
+
+	val32 &= ~SNB_AER_SLDSEV;
+	rc = pci_write_config_dword(ndev->pdev, SNB_UNCERRSEV_OFFSET, val32);
+	if (rc)
+		return rc;
+
 	rc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &val);
 	if (rc)
 		return rc;
@@ -747,14 +779,100 @@ static int ntb_hw_link_up(struct ntb_device *ndev)
 	return 0;
 }
 
+static void ntb_aer_fatal_recover(struct ntb_device *ndev)
+{
+	u16 val;
+	int rc;
+
+	/* Bad things are happening.  Bring down the link to the remote system,
+	 * stop all data, and retrain the link.  Hopefully retraining the link
+	 * is sufficient to recover from the fatal error.
+	 */
+
+	ntb_link_event(ndev, NTB_LINK_DOWN);
+
+	/* Bring NTB link down */
+	ntb_hw_link_down(ndev);
+
+	rc = pci_read_config_word(ndev->pdev, SNB_LNKCON_OFFSET, &val);
+	if (rc)
+		return;
+
+	val |= SNB_LNKCON_RETRAIN;
+	rc = pci_write_config_word(ndev->pdev, SNB_LNKCON_OFFSET, val);
+	if (rc)
+		return;
+
+	/* Let's bring the NTB link up */
+	ntb_hw_link_up(ndev);
+}
+
+static void xeon_aer_check(struct ntb_device *ndev)
+{
+	u32 val;
+	int rc;
+
+	rc = pci_read_config_dword(ndev->pdev, SNB_RPERRSTS_OFFSET, &val);
+	if (rc)
+		return;
+
+	/* Nothing to see here, move along */
+	if (!val)
+		return;
+
+	if (val & SNB_AER_CORR_ERR) {
+		u32 err;
+
+		rc = pci_read_config_dword(ndev->pdev, SNB_CORERRSTS_OFFSET,
+					   &err);
+		if (rc)
+			dev_info(&ndev->pdev->dev, "AER Unknown Correctable Error Found\n");
+		else
+			dev_info(&ndev->pdev->dev, "AER Correctable Error Found - %x\n",
+				 err);
+	}
+
+	if (val & SNB_AER_NONFATAL_ERR) {
+		u32 err;
+
+		rc = pci_read_config_dword(ndev->pdev, SNB_UNCERRSTS_OFFSET,
+					   &err);
+		if (rc)
+			dev_warn(&ndev->pdev->dev, "AER Unknown Nonfatal Error Found\n");
+		else
+			dev_warn(&ndev->pdev->dev, "AER Nonfatal Error Found - %x\n",
+				 err);
+	}
+
+	if (val & SNB_AER_FATAL_ERR) {
+		u32 err;
+
+		rc = pci_read_config_dword(ndev->pdev, SNB_UNCERRSTS_OFFSET,
+					   &err);
+		if (rc)
+			dev_err(&ndev->pdev->dev, "AER Unknown Fatal Error Found\n");
+		else
+			dev_err(&ndev->pdev->dev, "AER Fatal Error Found - %x\n",
+				err);
+
+		ntb_aer_fatal_recover(ndev);
+	}
+
+	pci_write_config_dword(ndev->pdev, SNB_RPERRSTS_OFFSET, val);
+}
+
 /* Since we do not have a HW doorbell in BWD, this is only used in JF/JT */
 static irqreturn_t xeon_event_msix_irq(int irq, void *dev)
 {
 	struct ntb_device *ndev = dev;
 	int rc;
 
+	/* This interrupt is shared for AER events and Link Status */
+
 	dev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for Events\n", irq);
 
+	xeon_aer_check(ndev);
+
 	rc = ntb_link_status(ndev);
 	if (rc)
 		dev_err(&ndev->pdev->dev, "Error determining link status\n");
@@ -1157,7 +1275,6 @@ static void ntb_pci_remove(struct pci_dev *pdev)
 {
 	struct ntb_device *ndev = pci_get_drvdata(pdev);
 	int i;
-	u32 ntb_cntl;
 
 	/* Bring NTB link down */
 	ntb_hw_link_down(ndev);
@@ -1216,7 +1333,6 @@ static pci_ers_result_t ntb_pci_link_reset(struct pci_dev *pdev)
 static pci_ers_result_t ntb_pci_mmio_enabled(struct pci_dev *pdev)
 {
 	struct ntb_device *ndev = pci_get_drvdata(pdev);
-	u32 ntb_cntl;
 
 	dev_err(&pdev->dev, "PCI AER: MMIO re-enabled");
 
diff --git a/drivers/ntb/ntb_regs.h b/drivers/ntb/ntb_regs.h
index 5bfa8c0..9364743 100644
--- a/drivers/ntb/ntb_regs.h
+++ b/drivers/ntb/ntb_regs.h
@@ -90,6 +90,23 @@
 #define SNB_B2B_DOORBELL_OFFSET	0x0140
 #define SNB_B2B_XLAT_OFFSET	0x0144
 
+#define SNB_RPERRCMD_OFFSET	0x0174
+#define SNB_AER_FATAL_ENABLE	(1 << 2)
+#define SNB_AER_NONFATAL_ENABLE	(1 << 1)
+#define SNB_AER_CORRERR_ENABLE	(1 << 0)
+#define SNB_RPERRSTS_OFFSET	0x0178
+#define SNB_AER_FATAL_ERR	(1 << 6)
+#define SNB_AER_NONFATAL_ERR	(1 << 5)
+#define SNB_AER_CORR_ERR	(1 << 0)
+#define SNB_UNCERRSTS_OFFSET	0x014C
+#define SNB_UNCERRMSK_OFFSET	0x0150
+#define SNB_AER_SLDMASK		(1 << 5)
+#define SNB_UNCERRSEV_OFFSET	0x0154
+#define SNB_AER_SLDSEV		(1 << 5)
+#define SNB_CORERRSTS_OFFSET	0x0158
+#define SNB_LNKCON_OFFSET	0x01A0
+#define SNB_LNKCON_RETRAIN	(1 << 5)
+
 #define BWD_MSIX_CNT		34
 #define BWD_MAX_SPADS		16
 #define BWD_MAX_COMPAT_SPADS	16
-- 
1.7.5.4

