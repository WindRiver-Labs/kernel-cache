From a200a94ca29522e7eb446240d393692ee6f50e66 Mon Sep 17 00:00:00 2001
From: Jon Mason <jon.mason@intel.com>
Date: Tue, 4 Dec 2012 14:46:05 -0700
Subject: [PATCH 32/70] NTB: AER support

This patch is provided by dave.jiang@intel.com via e-mail, and not
committed to mainline yet.

Add AER support for the NTB driver

Signed-off-by: Jon Mason <jon.mason@intel.com>
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 Documentation/PCI/pci-error-recovery.txt |    4 +-
 drivers/ntb/ntb_hw.c                     |  160 +++++++++++++++++++++++++++--
 2 files changed, 151 insertions(+), 13 deletions(-)

diff --git a/Documentation/PCI/pci-error-recovery.txt b/Documentation/PCI/pci-error-recovery.txt
index 898ded2..721987d 100644
--- a/Documentation/PCI/pci-error-recovery.txt
+++ b/Documentation/PCI/pci-error-recovery.txt
@@ -417,8 +417,8 @@ anyway :)
 >>> drivers/scsi/sym53c8xx_2
 >>> drivers/scsi/qla2xxx
 >>> drivers/scsi/lpfc
->>> drivers/next/bnx2.c
->>> drivers/next/e100.c
+>>> drivers/net/bnx2.c
+>>> drivers/net/e100.c
 >>> drivers/net/e1000
 >>> drivers/net/e1000e
 >>> drivers/net/ixgb
diff --git a/drivers/ntb/ntb_hw.c b/drivers/ntb/ntb_hw.c
index 2dacd19..2ce8a83 100644
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@ -51,6 +51,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/aer.h>
 #include "ntb_hw.h"
 #include "ntb_regs.h"
 
@@ -568,6 +569,10 @@ static int ntb_bwd_setup(struct ntb_device *ndev)
 
 	ndev->hw_type = BWD_HW;
 
+	rc = pci_enable_pcie_error_reporting(ndev->pdev);
+	if (rc)
+		dev_err(&ndev->pdev->dev, "AER enablement failed, continuing on anyway.\n");
+
 	rc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &val);
 	if (rc)
 		return rc;
@@ -587,12 +592,6 @@ static int ntb_bwd_setup(struct ntb_device *ndev)
 	else
 		ndev->dev_type = NTB_DEV_USD;
 
-	/* Initiate PCI-E link training */
-	rc = pci_write_config_dword(ndev->pdev, NTB_PPD_OFFSET,
-				    val | BWD_PPD_INIT_LINK);
-	if (rc)
-		return rc;
-
 	ndev->reg_ofs.pdb = ndev->reg_base + BWD_PDOORBELL_OFFSET;
 	ndev->reg_ofs.pdb_mask = ndev->reg_base + BWD_PDBMSK_OFFSET;
 	ndev->reg_ofs.sbar2_xlat = ndev->reg_base + BWD_SBAR2XLAT_OFFSET;
@@ -699,6 +698,55 @@ static irqreturn_t xeon_callback_msix_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static int ntb_hw_link_down(struct ntb_device *ndev)
+{
+	if (ndev->hw_type == BWD_HW) {
+		u32 val;
+		int rc;
+
+		rc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &val);
+		if (rc)
+			return rc;
+
+		/* Initiate PCI-E link training */
+		rc = pci_write_config_dword(ndev->pdev, NTB_PPD_OFFSET,
+					    val & ~BWD_PPD_INIT_LINK);
+		if (rc)
+			return rc;
+
+	} else {
+		u32 ntb_cntl;
+
+		ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
+		ntb_cntl |= NTB_LINK_DISABLE;
+		writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+	}
+
+	return 0;
+}
+
+static int ntb_hw_link_up(struct ntb_device *ndev)
+{
+	if (ndev->hw_type == BWD_HW) {
+		u32 val;
+		int rc;
+
+		rc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &val);
+		if (rc)
+			return rc;
+
+		/* Initiate PCI-E link training */
+		rc = pci_write_config_dword(ndev->pdev, NTB_PPD_OFFSET,
+					    val | BWD_PPD_INIT_LINK);
+		if (rc)
+			return rc;
+	} else
+		writel(NTB_CNTL_BAR23_SNOOP | NTB_CNTL_BAR45_SNOOP,
+		       ndev->reg_ofs.lnk_cntl);
+
+	return 0;
+}
+
 /* Since we do not have a HW doorbell in BWD, this is only used in JF/JT */
 static irqreturn_t xeon_event_msix_irq(int irq, void *dev)
 {
@@ -1080,8 +1128,7 @@ static int ntb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto err6;
 
 	/* Let's bring the NTB link up */
-	writel(NTB_CNTL_BAR23_SNOOP | NTB_CNTL_BAR45_SNOOP,
-	       ndev->reg_ofs.lnk_cntl);
+	ntb_hw_link_up(ndev);
 
 	return 0;
 
@@ -1113,9 +1160,7 @@ static void ntb_pci_remove(struct pci_dev *pdev)
 	u32 ntb_cntl;
 
 	/* Bring NTB link down */
-	ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
-	ntb_cntl |= NTB_LINK_DISABLE;
-	writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+	ntb_hw_link_down(ndev);
 
 	ntb_transport_free(ndev->ntb_transport);
 
@@ -1128,14 +1173,107 @@ static void ntb_pci_remove(struct pci_dev *pdev)
 
 	iounmap(ndev->reg_base);
 	pci_release_selected_regions(pdev, NTB_BAR_MASK);
+	pci_disable_pcie_error_reporting(pdev);
 	pci_disable_device(pdev);
 	kfree(ndev);
 }
 
+/* PCI bus error detected on this device */
+static pci_ers_result_t
+ntb_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state error)
+{
+	struct ntb_device *ndev = pci_get_drvdata(pdev);
+
+	ntb_link_event(ndev, NTB_LINK_DOWN);
+
+	switch (error) {
+	case pci_channel_io_normal:
+		dev_warn(&pdev->dev, "PCI AER non-fatal error detected");
+		return PCI_ERS_RESULT_CAN_RECOVER;
+	case pci_channel_io_frozen:
+		dev_err(&pdev->dev, "PCI AER fatal error detected");
+		ntb_device_free(ndev);
+		pci_disable_device(pdev);
+		return PCI_ERS_RESULT_NEED_RESET;
+	case pci_channel_io_perm_failure:
+		dev_err(&pdev->dev, "PCI error detected and unable to recover");
+		return PCI_ERS_RESULT_DISCONNECT;
+	default:
+		dev_err(&pdev->dev, "Unknown PCI Error");
+		return PCI_ERS_RESULT_NONE;
+	}
+}
+
+/* PCI Express link has been reset */
+static pci_ers_result_t ntb_pci_link_reset(struct pci_dev *pdev)
+{
+	dev_err(&pdev->dev, "PCI AER: Link Reset");
+	BUG();
+	return PCI_ERS_RESULT_NONE;
+}
+
+/* MMIO has been re-enabled, but not DMA */
+static pci_ers_result_t ntb_pci_mmio_enabled(struct pci_dev *pdev)
+{
+	struct ntb_device *ndev = pci_get_drvdata(pdev);
+	u32 ntb_cntl;
+
+	dev_err(&pdev->dev, "PCI AER: MMIO re-enabled");
+
+	/* Bring NTB link down */
+	ntb_hw_link_down(ndev);
+
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
+/* PCI slot has been reset */
+static pci_ers_result_t ntb_pci_slot_reset(struct pci_dev *pdev)
+{
+	struct ntb_device *ndev = pci_get_drvdata(pdev);
+	int rc;
+
+	dev_err(&pdev->dev, "PCI AER: Slot Reset");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return PCI_ERS_RESULT_DISCONNECT;
+
+	pci_set_master(pdev);
+	pci_restore_state(pdev);
+	pci_save_state(pdev);
+	pci_cleanup_aer_uncorrect_error_status(pdev);
+
+	rc = ntb_device_setup(ndev);
+	if (rc)
+		return PCI_ERS_RESULT_DISCONNECT;
+
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
+/* Device driver may resume normal operations */
+static void ntb_pci_resume(struct pci_dev *pdev)
+{
+	struct ntb_device *ndev = pci_get_drvdata(pdev);
+
+	dev_err(&pdev->dev, "PCI AER error recovered");
+
+	/* Let's bring the NTB link up */
+	ntb_hw_link_up(ndev);
+}
+
+static struct pci_error_handlers ntb_pci_err_handler = {
+	.error_detected = ntb_pci_error_detected,
+	.mmio_enabled = ntb_pci_mmio_enabled,
+	.link_reset = ntb_pci_link_reset,
+	.slot_reset = ntb_pci_slot_reset,
+	.resume = ntb_pci_resume,
+};
+
 static struct pci_driver ntb_pci_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = ntb_pci_tbl,
 	.probe = ntb_pci_probe,
 	.remove = ntb_pci_remove,
+	.err_handler = &ntb_pci_err_handler,
 };
 module_pci_driver(ntb_pci_driver);
-- 
1.7.5.4

