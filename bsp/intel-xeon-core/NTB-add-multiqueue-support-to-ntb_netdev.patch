From 045619d04c60bd07b387cbab72ae771e460610d5 Mon Sep 17 00:00:00 2001
From: Jon Mason <jon.mason@intel.com>
Date: Fri, 11 Jan 2013 12:46:48 -0700
Subject: [PATCH 36/70] NTB: add multiqueue support to ntb_netdev

This patch is provided by dave.jiang@intel.com via e-mail, and not
committed to mainline yet.

Signed-off-by: Jon Mason <jon.mason@intel.com>
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/net/ntb_netdev.c |  176 ++++++++++++++++++++++++++++++----------------
 1 files changed, 115 insertions(+), 61 deletions(-)

diff --git a/drivers/net/ntb_netdev.c b/drivers/net/ntb_netdev.c
index f3cdf64..9ba9e9a 100644
--- a/drivers/net/ntb_netdev.c
+++ b/drivers/net/ntb_netdev.c
@@ -58,11 +58,15 @@ MODULE_VERSION(NTB_NETDEV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Intel Corporation");
 
+static int num_qps = 1;
+module_param(num_qps, uint, 0644);
+MODULE_PARM_DESC(num_qps, "Number of NTB transport connections");
+
 struct ntb_netdev {
 	struct list_head list;
 	struct pci_dev *pdev;
 	struct net_device *ndev;
-	struct ntb_transport_qp *qp;
+	struct ntb_transport_qp **qp;
 };
 
 #define	NTB_TX_TIMEOUT_MS	1000
@@ -74,15 +78,16 @@ static void ntb_netdev_event_handler(void *data, int status)
 {
 	struct net_device *ndev = data;
 	struct ntb_netdev *dev = netdev_priv(ndev);
+	int i;
 
-	netdev_dbg(ndev, "Event %x, Link %x\n", status,
-		   ntb_transport_link_query(dev->qp));
+	for (i = 0; i < num_qps; i++) {
+		if (!ntb_transport_link_query(dev->qp[i])) {
+			netif_carrier_off(ndev);
+			return;
+		}
+	}
 
-	/* Currently, only link status event is supported */
-	if (status)
-		netif_carrier_on(ndev);
-	else
-		netif_carrier_off(ndev);
+	netif_carrier_on(ndev);
 }
 
 static void ntb_netdev_rx_handler(struct ntb_transport_qp *qp, void *qp_data,
@@ -91,16 +96,21 @@ static void ntb_netdev_rx_handler(struct ntb_transport_qp *qp, void *qp_data,
 	struct net_device *ndev = qp_data;
 	struct sk_buff *skb;
 	int rc;
+	u16 rx_queue;
 
 	skb = data;
 	if (!skb)
 		return;
 
-	netdev_dbg(ndev, "%s: %d byte payload received\n", __func__, len);
+	rx_queue = ntb_transport_qp_num(qp);
+
+	netdev_dbg(ndev, "%s: %d byte payload received on qp %d\n",
+		   __func__, len, rx_queue);
 
 	skb_put(skb, len);
 	skb->protocol = eth_type_trans(skb, ndev);
 	skb->ip_summed = CHECKSUM_NONE;
+	skb_record_rx_queue(skb, rx_queue);
 
 	if (netif_rx(skb) == NET_RX_DROP) {
 		ndev->stats.rx_errors++;
@@ -150,11 +160,17 @@ static netdev_tx_t ntb_netdev_start_xmit(struct sk_buff *skb,
 					 struct net_device *ndev)
 {
 	struct ntb_netdev *dev = netdev_priv(ndev);
-	int rc;
+	struct netdev_queue *txq;
+	int rc, qp_num;
 
-	netdev_dbg(ndev, "%s: skb len %d\n", __func__, skb->len);
+	qp_num = skb->queue_mapping;
+	txq = netdev_get_tx_queue(ndev, qp_num);
 
-	rc = ntb_transport_tx_enqueue(dev->qp, skb, skb->data, skb->len);
+	netdev_dbg(ndev, "%s: transmitting %d byte payload on qp %d\n",
+		   __func__, skb->len, qp_num);
+
+	rc = ntb_transport_tx_enqueue(dev->qp[qp_num], skb, skb->data,
+				      skb->len);
 	if (rc)
 		goto err;
 
@@ -170,30 +186,35 @@ static int ntb_netdev_open(struct net_device *ndev)
 {
 	struct ntb_netdev *dev = netdev_priv(ndev);
 	struct sk_buff *skb;
-	int rc, i, len;
+	int rc, i, len, qp_num;
+
+	netif_carrier_off(ndev);
 
 	/* Add some empty rx bufs */
-	for (i = 0; i < NTB_RXQ_SIZE; i++) {
-		skb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);
-		if (!skb) {
-			rc = -ENOMEM;
-			goto err;
-		}
+	for (qp_num = 0; qp_num < num_qps; qp_num++)
+		for (i = 0; i < NTB_RXQ_SIZE; i++) {
+			skb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);
+			if (!skb) {
+				rc = -ENOMEM;
+				goto err;
+			}
 
-		rc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,
-					      ndev->mtu + ETH_HLEN);
-		if (rc == -EINVAL)
-			goto err;
-	}
+			rc = ntb_transport_rx_enqueue(dev->qp[qp_num], skb,
+						      skb->data,
+						      ndev->mtu + ETH_HLEN);
+			if (rc == -EINVAL)
+				goto err;
+		}
 
-	netif_carrier_off(ndev);
-	ntb_transport_link_up(dev->qp);
+	for (qp_num = 0; qp_num < num_qps; qp_num++)
+		ntb_transport_link_up(dev->qp[qp_num]);
 
 	return 0;
 
 err:
-	while ((skb = ntb_transport_rx_remove(dev->qp, &len)))
-		dev_kfree_skb(skb);
+	for (qp_num = 0; qp_num < num_qps; qp_num++)
+		while ((skb = ntb_transport_rx_remove(dev->qp[qp_num], &len)))
+			dev_kfree_skb(skb);
 	return rc;
 }
 
@@ -201,12 +222,14 @@ static int ntb_netdev_close(struct net_device *ndev)
 {
 	struct ntb_netdev *dev = netdev_priv(ndev);
 	struct sk_buff *skb;
-	int len;
+	int len, qp_num;
 
-	ntb_transport_link_down(dev->qp);
+	for (qp_num = 0; qp_num < num_qps; qp_num++)
+		ntb_transport_link_down(dev->qp[qp_num]);
 
-	while ((skb = ntb_transport_rx_remove(dev->qp, &len)))
-		dev_kfree_skb(skb);
+	for (qp_num = 0; qp_num < num_qps; qp_num++)
+		while ((skb = ntb_transport_rx_remove(dev->qp[qp_num], &len)))
+			dev_kfree_skb(skb);
 
 	return 0;
 }
@@ -215,10 +238,11 @@ static int ntb_netdev_change_mtu(struct net_device *ndev, int new_mtu)
 {
 	struct ntb_netdev *dev = netdev_priv(ndev);
 	struct sk_buff *skb;
-	int len, rc;
+	int len, qpn, rc;
 
-	if (new_mtu > ntb_transport_max_size(dev->qp) - ETH_HLEN)
-		return -EINVAL;
+	for (qpn = 0; qpn < num_qps; qpn++)
+		if (new_mtu > ntb_transport_max_size(dev->qp[qpn]) - ETH_HLEN)
+			return -EINVAL;
 
 	if (!netif_running(ndev)) {
 		ndev->mtu = new_mtu;
@@ -226,41 +250,53 @@ static int ntb_netdev_change_mtu(struct net_device *ndev, int new_mtu)
 	}
 
 	/* Bring down the link and dispose of posted rx entries */
-	ntb_transport_link_down(dev->qp);
+	for (qpn = 0; qpn < num_qps; qpn++)
+		ntb_transport_link_down(dev->qp[qpn]);
 
 	if (ndev->mtu < new_mtu) {
 		int i;
 
-		for (i = 0; (skb = ntb_transport_rx_remove(dev->qp, &len)); i++)
-			dev_kfree_skb(skb);
-
-		for (; i; i--) {
-			skb = netdev_alloc_skb(ndev, new_mtu + ETH_HLEN);
-			if (!skb) {
-				rc = -ENOMEM;
-				goto err;
-			}
-
-			rc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,
-						      new_mtu + ETH_HLEN);
-			if (rc) {
+		for (qpn = 0; qpn < num_qps; qpn++) {
+			for (i = 0;
+			     (skb = ntb_transport_rx_remove(dev->qp[qpn],
+							    &len));
+			     i++)
 				dev_kfree_skb(skb);
-				goto err;
+
+			for (; i; i--) {
+				skb = netdev_alloc_skb(ndev,
+						       new_mtu + ETH_HLEN);
+				if (!skb) {
+					rc = -ENOMEM;
+					goto err;
+				}
+
+				rc = ntb_transport_rx_enqueue(dev->qp[qpn],
+							      skb, skb->data,
+							      new_mtu +
+							      ETH_HLEN);
+				if (rc) {
+					dev_kfree_skb(skb);
+					goto err;
+				}
 			}
 		}
 	}
 
 	ndev->mtu = new_mtu;
 
-	ntb_transport_link_up(dev->qp);
+	for (qpn = 0; qpn < num_qps; qpn++)
+		ntb_transport_link_up(dev->qp[qpn]);
 
 	return 0;
 
 err:
-	ntb_transport_link_down(dev->qp);
+	for (qpn = 0; qpn < num_qps; qpn++)
+		ntb_transport_link_down(dev->qp[qpn]);
 
-	while ((skb = ntb_transport_rx_remove(dev->qp, &len)))
-		dev_kfree_skb(skb);
+	for (qpn = 0; qpn < num_qps; qpn++)
+		while ((skb = ntb_transport_rx_remove(dev->qp[qpn], &len)))
+			dev_kfree_skb(skb);
 
 	netdev_err(ndev, "Error changing MTU, device inoperable\n");
 	return rc;
@@ -317,9 +353,9 @@ static int ntb_netdev_probe(struct pci_dev *pdev)
 {
 	struct net_device *ndev;
 	struct ntb_netdev *dev;
-	int rc;
+	int rc, i;
 
-	ndev = alloc_etherdev(sizeof(struct ntb_netdev));
+	ndev = alloc_etherdev_mq(sizeof(struct ntb_netdev), num_qps);
 	if (!ndev)
 		return -ENOMEM;
 
@@ -340,13 +376,26 @@ static int ntb_netdev_probe(struct pci_dev *pdev)
 	ndev->netdev_ops = &ntb_netdev_ops;
 	SET_ETHTOOL_OPS(ndev, &ntb_ethtool_ops);
 
-	dev->qp = ntb_transport_create_queue(ndev, pdev, &ntb_netdev_handlers);
+	dev->qp = kcalloc(sizeof(struct ntb_transport_qp *), num_qps,
+			  GFP_KERNEL);
 	if (!dev->qp) {
-		rc = -EIO;
+		rc = -ENOMEM;
 		goto err;
 	}
 
-	ndev->mtu = ntb_transport_max_size(dev->qp) - ETH_HLEN;
+	ndev->mtu = ~0;
+
+	for (i = 0; i < num_qps; i++) {
+		dev->qp[i] = ntb_transport_create_queue(ndev, pdev,
+							&ntb_netdev_handlers);
+		if (!dev->qp[i]) {
+			rc = -EIO;
+			goto err1;
+		}
+
+		ndev->mtu = min(ntb_transport_max_size(dev->qp[i]) - ETH_HLEN,
+				ndev->mtu);
+	}
 
 	rc = register_netdev(ndev);
 	if (rc)
@@ -357,7 +406,9 @@ static int ntb_netdev_probe(struct pci_dev *pdev)
 	return 0;
 
 err1:
-	ntb_transport_free_queue(dev->qp);
+	for (i--; i >= 0 && dev->qp[i]; i--)
+		ntb_transport_free_queue(dev->qp[i]);
+	kfree(dev->qp);
 err:
 	free_netdev(ndev);
 	return rc;
@@ -367,6 +418,7 @@ static void ntb_netdev_remove(struct pci_dev *pdev)
 {
 	struct net_device *ndev;
 	struct ntb_netdev *dev;
+	int i;
 
 	list_for_each_entry(dev, &dev_list, list) {
 		if (dev->pdev == pdev)
@@ -380,7 +432,9 @@ static void ntb_netdev_remove(struct pci_dev *pdev)
 	ndev = dev->ndev;
 
 	unregister_netdev(ndev);
-	ntb_transport_free_queue(dev->qp);
+	for (i = 0; i < num_qps; i++)
+		ntb_transport_free_queue(dev->qp[i]);
+	kfree(dev->qp);
 	free_netdev(ndev);
 }
 
-- 
1.7.5.4

