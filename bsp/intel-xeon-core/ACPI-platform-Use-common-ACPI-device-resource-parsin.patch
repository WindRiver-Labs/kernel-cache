From dce9b8df2af835b8ec268bb7509dcde6bfc0b6d1 Mon Sep 17 00:00:00 2001
From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Thu, 15 Nov 2012 00:30:12 +0100
Subject: [PATCH 030/129] ACPI / platform: Use common ACPI device resource
 parsing routines

upstream: 97d69dc061e968b5e9e56f48bb223b9ab7764b48

Use common routines in drivers/acpi/resource.c to parse ACPI device
resources while creating platform device objects.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/acpi/acpi_platform.c |   89 +++++++++--------------------------------
 1 files changed, 20 insertions(+), 69 deletions(-)

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index dbb31d6..bcbb00c 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,21 +29,20 @@ static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
 						 void *data)
 {
 	struct acpi_resource_extended_irq *acpi_xirq;
+	struct acpi_resource_irq *acpi_irq;
 	struct resource_info *ri = data;
 
 	switch (res->type) {
-	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
 	case ACPI_RESOURCE_TYPE_IRQ:
-		ri->n++;
+		acpi_irq = &res->data.irq;
+		ri->n += acpi_irq->interrupt_count;
 		break;
 	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
 		acpi_xirq = &res->data.extended_irq;
 		ri->n += acpi_xirq->interrupt_count;
 		break;
-	case ACPI_RESOURCE_TYPE_ADDRESS32:
-		if (res->data.address32.resource_type == ACPI_IO_RANGE)
-			ri->n++;
-		break;
+	default:
+		ri->n++;
 	}
 
 	return AE_OK;
@@ -52,71 +51,26 @@ static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
 static acpi_status acpi_platform_add_resources(struct acpi_resource *res,
 					       void *data)
 {
-	struct acpi_resource_fixed_memory32 *acpi_mem;
-	struct acpi_resource_address32 *acpi_add32;
-	struct acpi_resource_extended_irq *acpi_xirq;
-	struct acpi_resource_irq *acpi_irq;
 	struct resource_info *ri = data;
 	struct resource *r;
-	int irq, i;
-
-	switch (res->type) {
-	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
-		acpi_mem = &res->data.fixed_memory32;
-		r = &ri->res[ri->cur++];
 
-		r->start = acpi_mem->address;
-		r->end = r->start + acpi_mem->address_length - 1;
-		r->flags = IORESOURCE_MEM;
-
-		dev_dbg(ri->dev, "Memory32Fixed %pR\n", r);
-		break;
-
-	case ACPI_RESOURCE_TYPE_ADDRESS32:
-		acpi_add32 = &res->data.address32;
-
-		if (acpi_add32->resource_type == ACPI_IO_RANGE) {
-			r = &ri->res[ri->cur++];
-			r->start = acpi_add32->minimum;
-			r->end = r->start + acpi_add32->address_length - 1;
-			r->flags = IORESOURCE_IO;
-			dev_dbg(ri->dev, "Address32 %pR\n", r);
-		}
-		break;
-
-	case ACPI_RESOURCE_TYPE_IRQ:
-		acpi_irq = &res->data.irq;
-		r = &ri->res[ri->cur++];
-
-		irq = acpi_register_gsi(ri->dev,
-					acpi_irq->interrupts[0],
-					acpi_irq->triggering,
-					acpi_irq->polarity);
-
-		r->start = r->end = irq;
-		r->flags = IORESOURCE_IRQ;
-
-		dev_dbg(ri->dev, "IRQ %pR\n", r);
-		break;
-
-	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
-		acpi_xirq = &res->data.extended_irq;
-
-		for (i = 0; i < acpi_xirq->interrupt_count; i++, ri->cur++) {
-			r = &ri->res[ri->cur];
-			irq = acpi_register_gsi(ri->dev,
-						acpi_xirq->interrupts[i],
-						acpi_xirq->triggering,
-						acpi_xirq->polarity);
+	r = ri->res + ri->cur;
+	if (acpi_dev_resource_memory(res, r)
+	    || acpi_dev_resource_io(res, r)
+	    || acpi_dev_resource_address_space(res, r)
+	    || acpi_dev_resource_ext_address_space(res, r)) {
+		ri->cur++;
+		return AE_OK;
+	}
+	if (acpi_dev_resource_interrupt(res, 0, r)) {
+		int i;
 
-			r->start = r->end = irq;
-			r->flags = IORESOURCE_IRQ;
+		r++;
+		for (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)
+			r++;
 
-			dev_dbg(ri->dev, "Interrupt %pR\n", r);
-		}
-		break;
+		ri->cur += i;
 	}
-
 	return AE_OK;
 }
 
@@ -165,9 +119,6 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		goto out;
 	}
 
-	if (WARN_ON(ri.n != ri.cur))
-		goto out;
-
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device
 	 * attached to it, that physical device should be the parent of the
@@ -189,7 +140,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		mutex_unlock(&acpi_parent->physical_node_lock);
 	}
 	pdev = platform_device_register_resndata(parent, dev_name(&adev->dev),
-						 -1, ri.res, ri.n, NULL, 0);
+						 -1, ri.res, ri.cur, NULL, 0);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
-- 
1.7.5.4

