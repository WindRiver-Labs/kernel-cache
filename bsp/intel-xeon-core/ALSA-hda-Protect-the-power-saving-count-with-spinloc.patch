From 1fe50e08aa7063d2f02d0324dd2a8e8199a7c035 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 8 May 2012 17:08:10 +0200
Subject: [PATCH 077/129] ALSA: hda - Protect the power-saving count with
 spinlock

upstream: 5536c6d69376273d5210ce05b7d5d462f0dff9d6

To avoid some races.  Still not perfect, but now a bit safer.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 sound/pci/hda/hda_codec.c |   23 +++++++++++++++++++++--
 sound/pci/hda/hda_codec.h |    1 +
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 5fd8430..1a52695 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -1271,6 +1271,7 @@ int /*__devinit*/ snd_hda_codec_new(struct hda_bus *bus,
 	snd_array_init(&codec->spdif_out, sizeof(struct hda_spdif_out), 16);
 
 #ifdef CONFIG_SND_HDA_POWER_SAVE
+	spin_lock_init(&codec->power_lock);
 	INIT_DELAYED_WORK(&codec->power_work, hda_power_work);
 	/* snd_hda_codec_new() marks the codec as power-up, and leave it as is.
 	 * the caller has to power down appropriatley after initialization
@@ -4319,12 +4320,16 @@ static void hda_power_work(struct work_struct *work)
 		container_of(work, struct hda_codec, power_work.work);
 	struct hda_bus *bus = codec->bus;
 
+	spin_lock(&codec->power_lock);
 	if (!codec->power_on || codec->power_count) {
 		codec->power_transition = 0;
+		spin_unlock(&codec->power_lock);
 		return;
 	}
 
 	trace_hda_power_down(codec);
+	spin_unlock(&codec->power_lock);
+
 	hda_call_codec_suspend(codec);
 	if (bus->ops.pm_notify)
 		bus->ops.pm_notify(bus);
@@ -4332,9 +4337,11 @@ static void hda_power_work(struct work_struct *work)
 
 static void hda_keep_power_on(struct hda_codec *codec)
 {
+	spin_lock(&codec->power_lock);
 	codec->power_count++;
 	codec->power_on = 1;
 	codec->power_jiffies = jiffies;
+	spin_unlock(&codec->power_lock);
 }
 
 /* update the power on/off account with the current jiffies */
@@ -4359,20 +4366,28 @@ void snd_hda_power_up(struct hda_codec *codec)
 {
 	struct hda_bus *bus = codec->bus;
 
+	spin_lock(&codec->power_lock);
 	codec->power_count++;
-	if (codec->power_on || codec->power_transition)
+	if (codec->power_on || codec->power_transition) {
+		spin_unlock(&codec->power_lock);
 		return;
+	}
 
 	trace_hda_power_up(codec);
 	snd_hda_update_power_acct(codec);
 	codec->power_on = 1;
 	codec->power_jiffies = jiffies;
 	codec->power_transition = 1; /* avoid reentrance */
+	spin_unlock(&codec->power_lock);
+
 	if (bus->ops.pm_notify)
 		bus->ops.pm_notify(bus);
 	hda_call_codec_resume(codec);
+
+	spin_lock(&codec->power_lock);
 	cancel_delayed_work(&codec->power_work);
 	codec->power_transition = 0;
+	spin_unlock(&codec->power_lock);
 }
 EXPORT_SYMBOL_HDA(snd_hda_power_up);
 
@@ -4388,14 +4403,18 @@ EXPORT_SYMBOL_HDA(snd_hda_power_up);
  */
 void snd_hda_power_down(struct hda_codec *codec)
 {
+	spin_lock(&codec->power_lock);
 	--codec->power_count;
-	if (!codec->power_on || codec->power_count || codec->power_transition)
+	if (!codec->power_on || codec->power_count || codec->power_transition) {
+		spin_unlock(&codec->power_lock);
 		return;
+	}
 	if (power_save(codec)) {
 		codec->power_transition = 1; /* avoid reentrance */
 		queue_delayed_work(codec->bus->workq, &codec->power_work,
 				msecs_to_jiffies(power_save(codec) * 1000));
 	}
+	spin_unlock(&codec->power_lock);
 }
 EXPORT_SYMBOL_HDA(snd_hda_power_down);
 
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 94be275..0f39aff 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -868,6 +868,7 @@ struct hda_codec {
 	unsigned long power_on_acct;
 	unsigned long power_off_acct;
 	unsigned long power_jiffies;
+	spinlock_t power_lock;
 #endif
 
 	/* codec-specific additional proc output */
-- 
1.7.5.4

