From 7839dd5be858bb98f13958c6d9d09c19e1d592f9 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 31 Aug 2012 07:46:56 -0700
Subject: [PATCH 104/129] ALSA: hda - Yet another fix for D3 stop-clock
 refcounting

upstream: 08fa20ae20eb378225e5519db4e07f663ce405fa

The call of pm_notify callback in snd_hda_codec_free() should be with
the check of the current state whether pm_notify(false) is called or
not, instead of codec->power_on check.

For improving the code readability and fixing this inconsistency,
codec->d3_stop_clk_ok is renamed to codec->pm_down_notified, and this
flag is set only when runtime PM down is called.  The new name reflects
to a more direct purpose of the flag.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 sound/pci/hda/hda_codec.c |   41 ++++++++++++++++++++++-------------------
 sound/pci/hda/hda_codec.h |    2 +-
 2 files changed, 23 insertions(+), 20 deletions(-)

diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 991cec6..0364411 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -1214,7 +1214,7 @@ static void snd_hda_codec_free(struct hda_codec *codec)
 	if (codec->patch_ops.free)
 		codec->patch_ops.free(codec);
 #ifdef CONFIG_PM
-	if (codec->power_on)
+	if (!codec->pm_down_notified) /* cancel leftover refcounts */
 		hda_call_pm_notify(codec->bus, false);
 #endif
 	module_put(codec->owner);
@@ -1230,7 +1230,7 @@ static void snd_hda_codec_free(struct hda_codec *codec)
 static bool snd_hda_codec_get_supported_ps(struct hda_codec *codec,
 				hda_nid_t fg, unsigned int power_state);
 
-static void hda_set_power_state(struct hda_codec *codec, hda_nid_t fg,
+static unsigned int hda_set_power_state(struct hda_codec *codec, hda_nid_t fg,
 				unsigned int power_state);
 
 /**
@@ -3517,18 +3517,14 @@ static unsigned int hda_sync_power_state(struct hda_codec *codec,
 }
 
 /*
- * set power state of the codec
+ * set power state of the codec, and return the power state
  */
-static void hda_set_power_state(struct hda_codec *codec, hda_nid_t fg,
-				unsigned int power_state)
+static unsigned int hda_set_power_state(struct hda_codec *codec, hda_nid_t fg,
+					unsigned int power_state)
 {
 	int count;
 	unsigned int state;
 
-#ifdef CONFIG_PM
-	codec->d3_stop_clk_ok = 0;
-#endif
-
 	/* this delay seems necessary to avoid click noise at power-down */
 	if (power_state == AC_PWRST_D3) {
 		/* transition time less than 10ms for power down */
@@ -3552,11 +3548,7 @@ static void hda_set_power_state(struct hda_codec *codec, hda_nid_t fg,
 			break;
 	}
 
-#ifdef CONFIG_PM
-	if (!codec->bus->power_keep_link_on && power_state == AC_PWRST_D3
-		&& codec->d3_stop_clk && (state & AC_PWRST_CLK_STOP_OK))
-		codec->d3_stop_clk_ok = 1;
-#endif
+	return state;
 }
 
 #ifdef CONFIG_SND_HDA_HWDEP
@@ -3573,13 +3565,16 @@ static inline void hda_exec_init_verbs(struct hda_codec *codec) {}
 #ifdef CONFIG_PM
 /*
  * call suspend and power-down; used both from PM and power-save
+ * this function returns the power state in the end
  */
-static void hda_call_codec_suspend(struct hda_codec *codec)
+static unsigned int hda_call_codec_suspend(struct hda_codec *codec)
 {
+	unsigned int state;
+
 	if (codec->patch_ops.suspend)
 		codec->patch_ops.suspend(codec);
 	hda_cleanup_all_streams(codec);
-	hda_set_power_state(codec,
+	state = hda_set_power_state(codec,
 			    codec->afg ? codec->afg : codec->mfg,
 			    AC_PWRST_D3);
 	cancel_delayed_work(&codec->power_work);
@@ -3590,6 +3585,7 @@ static void hda_call_codec_suspend(struct hda_codec *codec)
 	codec->power_transition = 0;
 	codec->power_jiffies = jiffies;
 	spin_unlock(&codec->power_lock);
+	return state;
 }
 
 /*
@@ -4385,6 +4381,7 @@ static void hda_power_work(struct work_struct *work)
 	struct hda_codec *codec =
 		container_of(work, struct hda_codec, power_work.work);
 	struct hda_bus *bus = codec->bus;
+	unsigned int state;
 
 	spin_lock(&codec->power_lock);
 	if (codec->power_transition > 0) { /* during power-up sequence? */
@@ -4398,9 +4395,12 @@ static void hda_power_work(struct work_struct *work)
 	}
 	spin_unlock(&codec->power_lock);
 
-	hda_call_codec_suspend(codec);
-	if (codec->d3_stop_clk_ok)
+	state = hda_call_codec_suspend(codec);
+	codec->pm_down_notified = 0;
+	if (!bus->power_keep_link_on && (state & AC_PWRST_CLK_STOP_OK)) {
+		codec->pm_down_notified = 1;
 		hda_call_pm_notify(bus, false);
+	}
 }
 
 static void hda_keep_power_on(struct hda_codec *codec)
@@ -4454,8 +4454,11 @@ static void __snd_hda_power_up(struct hda_codec *codec, bool wait_power_down)
 	codec->power_transition = 1; /* avoid reentrance */
 	spin_unlock(&codec->power_lock);
 
-	if (codec->d3_stop_clk_ok) /* flag set at suspend */
+	if (codec->pm_down_notified) {
+		codec->pm_down_notified = 0;
 		hda_call_pm_notify(bus, true);
+	}
+
 	hda_call_codec_resume(codec);
 
 	spin_lock(&codec->power_lock);
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 3305a5d..411e0c3 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -872,7 +872,7 @@ struct hda_codec {
 	spinlock_t power_lock;
 
 	unsigned int d3_stop_clk:1;	/* support D3 operation without BCLK */
-	unsigned int d3_stop_clk_ok:1; /* BCLK can stop */
+	unsigned int pm_down_notified:1; /* PM notified to controller */
 #endif
 
 	/* codec-specific additional proc output */
-- 
1.7.5.4

