From b6541fff44e1ff187265f3404324bd6bd6d36bb9 Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Fri, 30 Nov 2012 16:43:05 -0700
Subject: [PATCH 69/70] blk: battery backed RAM disk

This patch is provided by dave.jiang@intel.com via e-mail, and not
committed to mainline yet.

adrbd: Allow multi-region to be mapped to multiple ADR devices

Signed-of-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
---
 drivers/block/Kconfig  |   11 ++
 drivers/block/Makefile |    2 +
 drivers/block/adrbd.c  |  397 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 410 insertions(+), 0 deletions(-)
 create mode 100644 drivers/block/adrbd.c

diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index a796407..7cd845e 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -555,4 +555,15 @@ config BLK_DEV_RBD
 
 	  If unsure, say N.
 
+config BLK_DEV_ADRBD
+	tristate "Battery Backed RAM disk (ADRBD)"
+	depends on X86 && EXPERIMENTAL && BLOCK
+	select ADR
+	default n
+	help
+	  Say Y here if you want to enable battery backed RAM disk based on
+	  the ADR feature.
+
+	  If unsure, say N.
+
 endif # BLK_DEV
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 5b79505..6228c4c 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -42,4 +42,6 @@ obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
 obj-$(CONFIG_BLK_DEV_RBD)     += rbd.o
 obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
 
+obj-$(CONFIG_BLK_DEV_ADRBD)	+= adrbd.o
+
 swim_mod-y	:= swim.o swim_asm.o
diff --git a/drivers/block/adrbd.c b/drivers/block/adrbd.c
new file mode 100644
index 0000000..8e99164
--- /dev/null
+++ b/drivers/block/adrbd.c
@@ -0,0 +1,397 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2012 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2012 Intel Corporation. All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copy
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Intel ADR backed RAM disk
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/buffer_head.h>
+#include <linux/bio.h>
+#include <linux/platform_device.h>
+#include <linux/hdreg.h>
+
+static sector_t hardsect_size = 4096/*512*/;
+
+#define to_adrbd(dev, i) container_of(adev, struct adrbd, dev[i])
+
+struct adr_dev {
+	int dev_id;
+	size_t size;
+	sector_t sectors;
+	void *adr_start;
+	struct request_queue *queue;
+	struct gendisk *gd;
+};
+
+#define MAX_ADR_REGIONS 4
+struct adrbd {
+	struct adr_dev adev[MAX_ADR_REGIONS];
+	struct platform_device *pdev;
+	int adr_major;
+	int idx;
+};
+
+#define ADEV_MINORS		16
+#define MINOR_SHIFT		4
+#define DEVNUM(kdevnum)	(MINOR(kdev_t_to_nr(kdevnum)) >> MINOR_SHIFT
+#define KERNEL_SECTOR_SIZE	512
+#define SECTOR_SHIFT		9
+
+#ifdef CONFIG_X86_64
+/*
+ * Use the non-temperal mov calls to avoid the move with allocating in cache
+ * in order to make the flushing less expensive.
+ */
+static void * _memcpy_nt64(void *dst, void *src, size_t len)
+{
+	int i;
+	long long t1, t2, t3, t4;
+	unsigned char *from, *to;
+	size_t remain = len & 63;
+
+	from = src;
+	to = dst;
+	i = len >> 6; /* len/64 */
+
+	for ( ; i > 0; i--) {
+		__asm__ __volatile__ (
+		"  mov (%4), %0\n"
+		"  mov 8(%4), %1\n"
+		"  mov 16(%4), %2\n"
+		"  mov 24(%4), %3\n"
+		"  movnti %0, (%5)\n"
+		"  movnti %1, 8(%5)\n"
+		"  movnti %2, 16(%5)\n"
+		"  movnti %3, 24(%5)\n"
+		"  mov 32(%4), %0\n"
+		"  mov 40(%4), %1\n"
+		"  mov 48(%4), %2\n"
+		"  mov 56(%4), %3\n"
+		"  movnti %0, 32(%5)\n"
+		"  movnti %1, 40(%5)\n"
+		"  movnti %2, 48(%5)\n"
+		"  movnti %3, 56(%5)\n"
+		: "=r" (t1), "=r" (t2), "=r" (t3), "=r" (t4)
+		: "r" (from), "r" (to)
+		: "memory");
+
+		from += 64;
+		to += 64;
+	}
+
+	/*
+	 * Now do the tail of the block:
+	 */
+	if (remain) {
+		memcpy(to, from, remain);
+		clflush_cache_range(to, remain);
+	}
+
+	__asm__ __volatile__("mfence \n"::);
+
+	return dst;
+}
+
+#define memcpy_nt _memcpy_nt64
+#else
+#define memcpy_nt memcpy
+inline void * memcpy_nt(void *dest, const void *src, size_t n)
+{
+	memcpy(dest, src, n);
+	clflush_cache_range(dest, n);
+}
+#endif
+
+static void
+adr_xfer(struct adr_dev *adev, unsigned long sector,
+	 unsigned long nbytes, char *buffer, int write)
+{
+	unsigned long offset = sector * KERNEL_SECTOR_SIZE;
+	struct adrbd *adrbd = to_adrbd(adev, adev->dev_id);
+
+	if ((offset + nbytes) > adev->size) {
+		dev_dbg(&adrbd->pdev->dev,
+			"Beyond-end access (%ld %ld)\n", offset, nbytes);
+		return;
+	}
+
+	if (write)
+		memcpy_nt(adev->adr_start + offset, buffer, nbytes);
+	else
+		memcpy(buffer, adev->adr_start + offset, nbytes);
+}
+
+static void adr_make_request(struct request_queue *q, struct bio *bio)
+{
+	struct adr_dev *adev = q->queuedata;
+	struct block_device *bdev = bio->bi_bdev;
+	struct bio_vec *bvec;
+	sector_t sector = bio->bi_sector;
+	int i;
+	int err = 0;
+
+	if (sector + (bio->bi_size >> SECTOR_SHIFT) >
+			get_capacity(bdev->bd_disk)) {
+		err = -EIO;
+		goto out;
+	}
+
+	bio_for_each_segment(bvec, bio, i) {
+		unsigned int len = bvec->bv_len;
+		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
+		adr_xfer(adev, sector, bvec->bv_len,
+			 buffer, bio_data_dir(bio) == WRITE);
+		sector += len >> SECTOR_SHIFT;
+		__bio_kunmap_atomic(bio, KM_USER0);
+	}
+
+out:
+	bio_endio(bio, err);
+}
+
+static int
+adr_ioctl(struct block_device *bdev, fmode_t mode,
+	  unsigned int cmd, unsigned long arg)
+{
+	if (cmd != BLKFLSBUF)
+		return -ENOTTY;
+
+	/*
+	 * we'll just say we did because we don't need to flush since we
+	 * are flushing to DRAM every time we write anyhow
+	 */
+	return 0;
+}
+
+static struct block_device_operations adev_ops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= adr_ioctl
+};
+
+static int adev_init(struct adrbd *adrbd, int idx)
+{
+	struct adr_dev *adev = &adrbd->adev[idx];
+
+	adev->queue = blk_alloc_queue(GFP_KERNEL);
+	if (!adev->queue)
+		return -ENODEV;
+	blk_queue_make_request(adev->queue, adr_make_request);
+	blk_queue_max_hw_sectors(adev->queue, 1024);
+	blk_queue_bounce_limit(adev->queue, BLK_BOUNCE_ANY);
+
+	blk_queue_physical_block_size(adev->queue, hardsect_size);
+	blk_queue_logical_block_size(adev->queue, hardsect_size);
+
+	adev->queue->queuedata = adev;
+
+	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, adev->queue);
+
+	adev->gd = alloc_disk(ADEV_MINORS);
+	if (!adev->gd) {
+		dev_err(&adrbd->pdev->dev, "%s: alloc_disk failed\n", __func__);
+		return -ENODEV;
+	}
+
+	adev->gd->major = adrbd->adr_major;
+	adev->gd->first_minor = ADEV_MINORS * adev->dev_id;
+	adev->gd->fops = &adev_ops;
+	adev->gd->queue = adev->queue;
+	adev->gd->private_data = adev;
+	adev->gd->flags |= GENHD_FL_SUPPRESS_PARTITION_INFO;
+	snprintf(adev->gd->disk_name, 32, "adrbd%u", adev->dev_id);
+	set_capacity(adev->gd, adev->size >> 9);
+	add_disk(adev->gd);
+
+	return 0;
+}
+
+static int adrbd_probe(struct platform_device *pdev)
+{
+	struct adrbd *adrbd;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	resource_size_t size;
+	int err, i, j;
+	unsigned long start_pfn, end_pfn, num_pages;
+
+	adrbd = devm_kzalloc(&pdev->dev, sizeof(*adrbd), GFP_KERNEL);
+	if (!adrbd) {
+		dev_err(&pdev->dev, "Unable to allocate adrbd\n");
+		return -ENOMEM;
+	}
+
+	adrbd->adr_major = register_blkdev(0, "adrbd");
+	if (adrbd->adr_major <= 0) {
+		dev_warn(&pdev->dev, "Unable to acquire major number.\n");
+		kfree(adrbd);
+		return -EBUSY;
+	}
+
+	adrbd->pdev = pdev;
+
+	for (i = 0,j = 0; i < MAX_ADR_REGIONS && j < pdev->num_resources; j++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, j);
+		if (!res)
+			continue;
+
+		size = resource_size(res);
+		if (!devm_request_mem_region(dev,
+					     res->start, size, pdev->name)) {
+			dev_err(&pdev->dev,
+				"Failed to request mem region (%s) %#llx size %llu\n",
+				pdev->name, res->start, size);
+			continue;
+		}
+
+		start_pfn = res->start >> PAGE_SHIFT;
+		end_pfn = (res->start + size - 1) >> PAGE_SHIFT;
+		num_pages = end_pfn - start_pfn + 1;
+		err = _set_memory_wb((unsigned long)page_address(pfn_to_page(start_pfn)), num_pages);
+		if (err) {
+			dev_err(&pdev->dev, "Unable to set memory attribute\n");
+			continue;
+		}
+
+		adrbd->adev[i].dev_id = adrbd->idx++;
+		adrbd->adev[i].size = size;
+		adrbd->adev[i].sectors = size / hardsect_size;
+		adrbd->adev[i].adr_start = page_address(pfn_to_page(start_pfn));
+
+		dev_dbg(&pdev->dev, "physical start: %#llx\n", res->start);
+		dev_dbg(&pdev->dev, "physical end: %#llx\n", res->end);
+		dev_dbg(&pdev->dev, "size: %llu bytes\n", size);
+		dev_dbg(&pdev->dev, "virt start: %p\n",
+			adrbd->adev[i].adr_start);
+
+		err = adev_init(adrbd, i);
+		if (err < 0) {
+			dev_err(&pdev->dev, "ADRBD.%d initialization failed\n",
+				i);
+			adrbd->idx--;
+			unregister_blkdev(adrbd->adr_major, "adrbd");
+			continue;
+		}
+
+		dev_info(&pdev->dev, "ADRBD.%d (%d.%d) registered: %lu bytes.\n",
+			 adrbd->adev[i].dev_id, adrbd->adr_major,
+			 adrbd->adev[i].gd->first_minor,
+			 adrbd->adev[i].size);
+		i++;
+	}
+
+	if (!adrbd->idx) {
+		kfree(adrbd);
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(pdev, adrbd);
+
+	return 0;
+}
+
+static int adrbd_remove(struct platform_device *pdev)
+{
+	struct adrbd *adrbd = platform_get_drvdata(pdev);
+	int i;
+	int devs = adrbd->idx;
+
+	for (i = 0; i < devs; i++) {
+		struct gendisk *disk = adrbd->adev[i].gd;
+
+		if (!disk)
+			continue;
+
+		del_gendisk(disk);
+		blk_cleanup_queue(disk->queue);
+		put_disk(disk);
+		adrbd->idx--;
+	}
+
+	unregister_blkdev(adrbd->adr_major, "adrbd");
+	kfree(adrbd);
+
+	return 0;
+}
+
+static struct platform_driver adrbd_driver = {
+	.probe		= adrbd_probe,
+	.remove		= adrbd_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "adr",
+	},
+};
+
+static int __init adr_init(void)
+{
+	return platform_driver_register(&adrbd_driver);
+}
+subsys_initcall(adr_init);
+
+static void adr_exit(void)
+{
+	platform_driver_unregister(&adrbd_driver);
+}
+module_exit(adr_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("ADR backed RAM disk");
+MODULE_AUTHOR("Intel Corporation");
-- 
1.7.5.4

