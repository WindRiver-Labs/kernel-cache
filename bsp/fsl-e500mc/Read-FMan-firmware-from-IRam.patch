From 5fcba42eb40542916bd9e73f27847d7ba49fd80d Mon Sep 17 00:00:00 2001
From: Wangrui Shen <wangrui.shen@windriver.com>
Date: Wed, 31 Jul 2013 09:11:52 +0800
Subject: [PATCH] Read FMan firmware from IRam

Normally, U-Boot embedded the FMan firmware into DTB, and pass it
to kernel. However, certain version of U-Boot doesn't do it,
which is not right. As a workaround, kernel read the old firmware
from IRam, and use it to update IRam.

This piece of logic exist in FSL QorIQ SDK 1.1, not in FSL QorIQ
SDK 1.3. So port it from 1.1 to 1.3.

Signed-off-by: Wangrui Shen <wangrui.shen@windriver.com>
---
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |   40 ++++++++++++++++++++
 1 files changed, 40 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 2fdc4c8..73cd4e2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -492,6 +492,27 @@ static t_Error ClearIRam(t_Fm *p_Fm)
     return E_OK;
 }
 
+static t_Error ReadFmanCtrlCode(t_Handle h_Fm, uint32_t *p_buff, uint32_t size)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_FMIramRegs    *p_Iram;
+    int             i;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_buff);
+    ASSERT_COND(size);
+
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+
+    /* Enable the auto-increment */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < ((size + 3) / 4); i++)
+        p_buff[i] = GET_UINT32(p_Iram->idata);
+
+    return E_OK;
+}
 static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram;
@@ -4153,6 +4174,25 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         }
         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
+    else
+    {
+        /* Read the Microcode from the IRAM and reuse it later */
+        p_Fm->p_FmDriverParam->firmware.size = FM_IRAM_SIZE;
+        p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+
+        if (!p_Fm->p_FmDriverParam->firmware.p_Code ||
+                ReadFmanCtrlCode(p_Fm, p_Fm->p_FmDriverParam->firmware.p_Code, FM_IRAM_SIZE) != E_OK)
+        {
+            if (p_Fm->p_FmDriverParam->firmware.p_Code)
+                XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+            XX_FreeSpinlock(p_Fm->h_Spinlock);
+            XX_Free(p_Fm->p_FmDriverParam);
+            XX_Free(p_Fm->p_FmStateStruct);
+            XX_Free(p_Fm);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
+            return NULL;
+        }
+    }
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return p_Fm;
-- 
1.7.5.4

