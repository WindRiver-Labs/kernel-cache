From 7aebe72502c3c30c114ca15b8b34ccc70c1f1130 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Mon, 24 Jan 2011 18:46:10 +0800
Subject: [PATCH 10/11] include/drm: modify drm header file to support sandybridge

For stability and isolation, and reuse current drm header
files, add some modifications(all add with CONFIG_DRM_I915_SB)
in seven drm header files to support sandybridge, and also
introduce two new header files, These modifications included
lots of structural differences which refer to upstream commits,
such as the following.

1. Among seven header files(drmP.h, drm_crtc.h and i915_drm.h
etc), these modifications are mostly change the structs and
macros refer to upstream commits such as the following.

The upstream commits:
  dcdb167402cbdca1d021bdfa5f63995ee0a79317 [drm: Add support for platform devices to register as DRM devices]
  eb1f8e4f3be898df808e2dfc131099f5831d491d [drm/fbdev: rework output polling to be back in the core. (v4)]
  1b2f1489633888d4a06028315dc19d65768a1c05 [drm: block userspace under allocating buffer and having drivers overwrite it (v2)]
Add new macros(DRIVER_USE_PLATFORM_DEVICE, DRM_CONNECTOR_POLL_HPD and DRM_IOCTL_DEF_DRV).

The upstream commits:
  386516744ba45d50f42c6999151cc210cb4f96e4 [drm/fb: fix fbdev object model + cleanup properly.]
  7203425a943eb3e189ba6b512827e0deb5f23872 [drm: expand gamma_set]
  73aa808f10effc280e6eb70267314542a7c29426 [drm: Move the GTT accounting to i915]
  dcdb167402cbdca1d021bdfa5f63995ee0a79317 [drm: Add support for platform devices to register as DRM devices]
Contain struct changes(drm_framebuffer, drm_crtc_funcs, drm_device and drm_driver).

The upstream commits:
  39b4d07aa3583ceefe73622841303a0a3e942ca1 [drm: Hold the mutex when dropping the last GEM reference (v2)]
  29d08b3efddca628b0360411ab2b85f7b1723f48 [drm/gem: handlecount isn't really a kref so don't make it one]
  0b4c0f3f0eceacb691e2b5570d9b16d751ce1b48 [drm/kms/fb: separate fbdev connector list from core drm connectors]
Contain function changes(drm_dev_to_irq, drm_gem_object_handle_unreference_unlocked and drm_connector_helper_add).

2. Introduce other two drm header files which are also needed by
sandybridge, which are introduced from the below commits.
  68adac5e49436992e9c999fbae879d9ac5b72d4e [drm: move radeon_fixed.h to shared drm_fixed.h header]
  ba4420c224c2808f2661cf8428f43ceef7a73a4a [drm: move ttm global code to core drm]

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 include/drm/drmP.h            |  149 +++++++++++++++++++++++++++++++++++++++++
 include/drm/drm_crtc.h        |   65 ++++++++++++++++++
 include/drm/drm_crtc_helper.h |   31 +++++++++
 include/drm/drm_edid.h        |    8 ++
 include/drm/drm_fb_helper.h   |   56 +++++++++++++++
 include/drm/drm_fixed.h       |   67 ++++++++++++++++++
 include/drm/drm_global.h      |   53 +++++++++++++++
 include/drm/drm_mm.h          |   29 ++++++++
 include/drm/i915_drm.h        |   16 +++++
 9 files changed, 474 insertions(+), 0 deletions(-)
 create mode 100644 include/drm/drm_fixed.h
 create mode 100644 include/drm/drm_global.h

diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index 2f3b3a0..df05846 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -48,6 +48,9 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/file.h>
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#include <linux/platform_device.h>
+#endif
 #include <linux/pci.h>
 #include <linux/jiffies.h>
 #include <linux/smp_lock.h>	/* For (un)lock_kernel */
@@ -144,6 +147,9 @@ extern void drm_ut_debug_printk(unsigned int request_level,
 #define DRIVER_IRQ_VBL2    0x800
 #define DRIVER_GEM         0x1000
 #define DRIVER_MODESET     0x2000
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DRIVER_USE_PLATFORM_DEVICE  0x4000
+#endif
 
 /***********************************************************************/
 /** \name Begin the DRM... */
@@ -303,12 +309,22 @@ struct drm_ioctl_desc {
 	unsigned int cmd;
 	int flags;
 	drm_ioctl_t *func;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	unsigned int cmd_drv;
+#endif
 };
 
 /**
  * Creates a driver or general drm_ioctl_desc array entry for the given
  * ioctl, for use by drm_ioctl().
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DRM_IOCTL_DEF_DRV(ioctl, _func, _flags)			\
+	[DRM_IOCTL_NR(DRM_##ioctl)] = {.cmd = DRM_##ioctl, .func = _func, \
+					.flags = _flags, \
+					.cmd_drv = DRM_IOCTL_##ioctl}
+#endif
+
 #define DRM_IOCTL_DEF(ioctl, _func, _flags) \
 	[DRM_IOCTL_NR(ioctl)] = {.cmd = ioctl, .func = _func, .flags = _flags}
 
@@ -403,6 +419,10 @@ struct drm_pending_event {
 	struct drm_event *event;
 	struct list_head link;
 	struct drm_file *file_priv;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	pid_t pid; /* pid of requester, no guarantee it's valid by the time
+		      we deliver the event, for tracing only */
+#endif
 	void (*destroy)(struct drm_pending_event *event);
 };
 
@@ -608,6 +628,10 @@ struct drm_gem_object {
 	/** Handle count of this object. Each handle also holds a reference */
 	struct kref handlecount;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	atomic_t handle_count; /* number of handles on this object */
+#endif
+
 	/** Related drm device */
 	struct drm_device *dev;
 
@@ -823,6 +847,9 @@ struct drm_driver {
 	int num_ioctls;
 	struct file_operations fops;
 	struct pci_driver pci_driver;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct platform_device *platform_device;
+#endif
 	/* List of devices hanging off this driver */
 	struct list_head device_list;
 };
@@ -1015,12 +1042,18 @@ struct drm_device {
 
 	struct drm_agp_head *agp;	/**< AGP data */
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct device *dev;             /**< Device structure */
+#endif
 	struct pci_dev *pdev;		/**< PCI device structure */
 	int pci_vendor;			/**< PCI vendor id */
 	int pci_device;			/**< PCI device id */
 #ifdef __alpha__
 	struct pci_controller *hose;
 #endif
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct platform_device *platformdev; /**< Platform device struture */
+#endif
 	struct drm_sg_mem *sg;	/**< Scatter gather memory */
 	int num_crtcs;                  /**< Number of CRTCs on this device */
 	void *dev_private;		/**< device private data */
@@ -1060,10 +1093,12 @@ struct drm_device {
 
 };
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 static inline int drm_dev_to_irq(struct drm_device *dev)
 {
 	return dev->pdev->irq;
 }
+#endif
 
 static __inline__ int drm_core_check_feature(struct drm_device *dev,
 					     int feature)
@@ -1071,11 +1106,40 @@ static __inline__ int drm_core_check_feature(struct drm_device *dev,
 	return ((dev->driver->driver_features & feature) ? 1 : 0);
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static inline int drm_dev_to_irq(struct drm_device *dev)
+{
+	if (drm_core_check_feature(dev, DRIVER_USE_PLATFORM_DEVICE))
+		return platform_get_irq(dev->platformdev, 0);
+	else
+		return dev->pdev->irq;
+}
+#endif
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static inline int drm_get_pci_domain(struct drm_device *dev)
+{
+	if (drm_core_check_feature(dev, DRIVER_USE_PLATFORM_DEVICE))
+		return 0;
+
+#ifndef __alpha__
+	/* For historical reasons, drm_get_pci_domain() is busticated
+	 * on most archs and has to remain so for userspace interface
+	 * < 1.4, except on alpha which was right from the beginning
+	 */
+	if (dev->if_version < 0x10004)
+		return 0;
+#endif /* __alpha__ */
+
+	return pci_domain_nr(dev->pdev->bus);
+}
+#else
 #ifdef __alpha__
 #define drm_get_pci_domain(dev) dev->hose->index
 #else
 #define drm_get_pci_domain(dev) 0
 #endif
+#endif
 
 #if __OS_HAS_AGP
 static inline int drm_core_has_AGP(struct drm_device *dev)
@@ -1138,6 +1202,9 @@ extern long drm_compat_ioctl(struct file *filp,
 extern int drm_lastclose(struct drm_device *dev);
 
 				/* Device support (drm_fops.h) */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern struct mutex drm_global_mutex;
+#endif
 extern int drm_open(struct inode *inode, struct file *filp);
 extern int drm_stub_open(struct inode *inode, struct file *filp);
 extern int drm_fasync(int fd, struct file *filp, int on);
@@ -1151,6 +1218,9 @@ extern int drm_mmap_locked(struct file *filp, struct vm_area_struct *vma);
 extern void drm_vm_open_locked(struct vm_area_struct *vma);
 extern resource_size_t drm_core_get_map_ofs(struct drm_local_map * map);
 extern resource_size_t drm_core_get_reg_ofs(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern void drm_vm_close_locked(struct vm_area_struct *vma);
+#endif
 extern unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
 
 				/* Memory management support (drm_memory.h) */
@@ -1353,6 +1423,13 @@ extern struct drm_master *drm_master_get(struct drm_master *master);
 extern void drm_master_put(struct drm_master **master);
 extern int drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
 		       struct drm_driver *driver);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern int drm_get_pci_dev(struct pci_dev *pdev,
+			   const struct pci_device_id *ent,
+			   struct drm_driver *driver);
+extern int drm_get_platform_dev(struct platform_device *pdev,
+				struct drm_driver *driver);
+#endif
 extern void drm_put_dev(struct drm_device *dev);
 extern int drm_put_minor(struct drm_minor **minor);
 extern unsigned int drm_debug;
@@ -1432,11 +1509,22 @@ void drm_gem_object_free(struct kref *kref);
 void drm_gem_object_free_unlocked(struct kref *kref);
 struct drm_gem_object *drm_gem_object_alloc(struct drm_device *dev,
 					    size_t size);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+void drm_gem_object_release(struct drm_gem_object *obj);
+int drm_gem_object_init(struct drm_device *dev,
+			struct drm_gem_object *obj, size_t size);
+void drm_gem_object_handle_free(struct drm_gem_object *obj);
+#else
 void drm_gem_object_handle_free(struct kref *kref);
+#endif
 void drm_gem_vm_open(struct vm_area_struct *vma);
 void drm_gem_vm_close(struct vm_area_struct *vma);
 int drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#include "drm_global.h"
+#endif
+
 static inline void
 drm_gem_object_reference(struct drm_gem_object *obj)
 {
@@ -1453,8 +1541,17 @@ drm_gem_object_unreference(struct drm_gem_object *obj)
 static inline void
 drm_gem_object_unreference_unlocked(struct drm_gem_object *obj)
 {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (obj != NULL) {
+		struct drm_device *dev = obj->dev;
+		mutex_lock(&dev->struct_mutex);
+		kref_put(&obj->refcount, drm_gem_object_free);
+		mutex_unlock(&dev->struct_mutex);
+	}
+#else
 	if (obj != NULL)
 		kref_put(&obj->refcount, drm_gem_object_free_unlocked);
+#endif
 }
 
 int drm_gem_handle_create(struct drm_file *file_priv,
@@ -1465,7 +1562,11 @@ static inline void
 drm_gem_object_handle_reference(struct drm_gem_object *obj)
 {
 	drm_gem_object_reference(obj);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	atomic_inc(&obj->handle_count);
+#else
 	kref_get(&obj->handlecount);
+#endif
 }
 
 static inline void
@@ -1474,12 +1575,22 @@ drm_gem_object_handle_unreference(struct drm_gem_object *obj)
 	if (obj == NULL)
 		return;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (atomic_read(&obj->handle_count) == 0)
+		return;
+#endif
+
 	/*
 	 * Must bump handle count first as this may be the last
 	 * ref, in which case the object would disappear before we
 	 * checked for a name
 	 */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (atomic_dec_and_test(&obj->handle_count))
+		drm_gem_object_handle_free(obj);
+#else
 	kref_put(&obj->handlecount, drm_gem_object_handle_free);
+#endif
 	drm_gem_object_unreference(obj);
 }
 
@@ -1489,12 +1600,22 @@ drm_gem_object_handle_unreference_unlocked(struct drm_gem_object *obj)
 	if (obj == NULL)
 		return;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (atomic_read(&obj->handle_count) == 0)
+		return;
+#endif
+
 	/*
 	* Must bump handle count first as this may be the last
 	* ref, in which case the object would disappear before we
 	* checked for a name
 	*/
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (atomic_dec_and_test(&obj->handle_count))
+		drm_gem_object_handle_free(obj);
+#else
 	kref_put(&obj->handlecount, drm_gem_object_handle_free);
+#endif
 	drm_gem_object_unreference_unlocked(obj);
 }
 
@@ -1526,6 +1647,11 @@ static __inline__ struct drm_local_map *drm_core_findmap(struct drm_device *dev,
 
 static __inline__ int drm_device_is_agp(struct drm_device *dev)
 {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (drm_core_check_feature(dev, DRIVER_USE_PLATFORM_DEVICE))
+		return 0;
+#endif
+
 	if (dev->driver->device_is_agp != NULL) {
 		int err = (*dev->driver->device_is_agp) (dev);
 
@@ -1539,7 +1665,14 @@ static __inline__ int drm_device_is_agp(struct drm_device *dev)
 
 static __inline__ int drm_device_is_pcie(struct drm_device *dev)
 {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (drm_core_check_feature(dev, DRIVER_USE_PLATFORM_DEVICE))
+		return 0;
+	else
+		return pci_find_capability(dev->pdev, PCI_CAP_ID_EXP);
+#else
 	return pci_find_capability(dev->pdev, PCI_CAP_ID_EXP);
+#endif
 }
 
 static __inline__ void drm_core_dropmap(struct drm_local_map *map)
@@ -1547,6 +1680,22 @@ static __inline__ void drm_core_dropmap(struct drm_local_map *map)
 }
 
 #include "drm_mem_util.h"
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static inline void *drm_get_device(struct drm_device *dev)
+{
+	if (drm_core_check_feature(dev, DRIVER_USE_PLATFORM_DEVICE))
+		return dev->platformdev;
+	else
+		return dev->pdev;
+}
+
+extern int drm_platform_init(struct drm_driver *driver);
+extern int drm_pci_init(struct drm_driver *driver);
+extern int drm_fill_in_dev(struct drm_device *dev,
+			   const struct pci_device_id *ent,
+			   struct drm_driver *driver);
+int drm_get_minor(struct drm_device *dev, struct drm_minor **minor, int type);
+#endif
 /*@}*/
 
 #endif				/* __KERNEL__ */
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1347524..233d851 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -189,6 +189,7 @@ enum subpixel_order {
  */
 struct drm_display_info {
 	char name[DRM_DISPLAY_INFO_LEN];
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	/* Input info */
 	bool serration_vsync;
 	bool sync_on_green;
@@ -197,6 +198,7 @@ struct drm_display_info {
 	bool blank_to_black;
 	unsigned char video_level;
 	bool digital;
+#endif
 	/* Physical size */
         unsigned int width_mm;
 	unsigned int height_mm;
@@ -226,11 +228,13 @@ struct drm_display_info {
 	unsigned int min_hfreq, max_hfreq;
 	unsigned int pixel_clock;
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	/* White point indices FIXME: storage format */
 	unsigned int wpx1, wpy1;
 	unsigned int wpgamma1;
 	unsigned int wpx2, wpy2;
 	unsigned int wpgamma2;
+#endif
 
 	enum subpixel_order subpixel_order;
 
@@ -254,9 +258,16 @@ struct drm_framebuffer_funcs {
 	 * the semantics and arguments have a one to one mapping
 	 * on this function.
 	 */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	int (*dirty)(struct drm_framebuffer *framebuffer,
+		     struct drm_file *file_priv, unsigned flags,
+		     unsigned color, struct drm_clip_rect *clips,
+		     unsigned num_clips);
+#else
 	int (*dirty)(struct drm_framebuffer *framebuffer, unsigned flags,
 		     unsigned color, struct drm_clip_rect *clips,
 		     unsigned num_clips);
+#endif
 };
 
 struct drm_framebuffer {
@@ -271,8 +282,10 @@ struct drm_framebuffer {
 	unsigned int depth;
 	int bits_per_pixel;
 	int flags;
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	struct fb_info *fbdev;
 	u32 pseudo_palette[17];
+#endif
 	struct list_head filp_head;
 	/* if you are using the helper */
 	void *helper_private;
@@ -343,8 +356,13 @@ struct drm_crtc_funcs {
 	int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
 
 	/* Set gamma on the CRTC */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
+			  uint32_t start, uint32_t size);
+#else
 	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
 			  uint32_t size);
+#endif
 	/* Object destroy routine */
 	void (*destroy)(struct drm_crtc *crtc);
 
@@ -426,7 +444,18 @@ struct drm_connector_funcs {
 	void (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	/* Check to see if anything is attached to the connector.
+	 * @force is set to false whilst polling, true when checking the
+	 * connector due to user request. @force can be used by the driver
+	 * to avoid expensive, destructive operations during automated
+	 * probing.
+	 */
+	enum drm_connector_status (*detect)(struct drm_connector *connector,
+					    bool force);
+#else
 	enum drm_connector_status (*detect)(struct drm_connector *connector);
+#endif
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
@@ -467,6 +496,17 @@ enum drm_connector_force {
 	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* should we poll this connector for connects and disconnects */
+/* hot plug detectable */
+#define DRM_CONNECTOR_POLL_HPD (1 << 0)
+/* poll for connections */
+#define DRM_CONNECTOR_POLL_CONNECT (1 << 1)
+/* can cleanly poll for disconnections without flickering the screen */
+/* DACs should rarely do this without a lot of testing */
+#define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)
+#endif
+
 /**
  * drm_connector - central DRM connector control structure
  * @crtc: CRTC this connector is currently connected to, NULL if none
@@ -511,6 +551,10 @@ struct drm_connector {
 	u32 property_ids[DRM_CONNECTOR_MAX_PROPERTY];
 	uint64_t property_values[DRM_CONNECTOR_MAX_PROPERTY];
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
+#endif
+
 	/* requested DPMS state */
 	int dpms;
 
@@ -558,6 +602,9 @@ struct drm_mode_set {
 struct drm_mode_config_funcs {
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
 	int (*fb_changed)(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	void (*output_poll_changed)(struct drm_device *dev);
+#endif
 };
 
 struct drm_mode_group {
@@ -598,6 +645,12 @@ struct drm_mode_config {
 	struct drm_mode_config_funcs *funcs;
 	resource_size_t fb_base;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	/* output poll support */
+	bool poll_enabled;
+	struct delayed_work output_poll_work;
+#endif
+
 	/* pointers to standard properties */
 	struct list_head property_blob_list;
 	struct drm_property *edid_property;
@@ -666,8 +719,10 @@ extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 extern int drm_do_probe_ddc_edid(struct i2c_adapter *adapter,
 				 unsigned char *buf, int len);
+#endif
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
@@ -803,4 +858,14 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
 extern bool drm_edid_is_valid(struct edid *edid);
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern bool drm_detect_monitor_audio(struct edid *edid);
+extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
+				int hdisplay, int vdisplay, int vrefresh,
+				bool interlaced, int margins, int GTF_M,
+				int GTF_2C, int GTF_K, int GTF_2J);
+struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
+					   int hsize, int vsize, int fresh);
+#endif
 #endif /* __DRM_CRTC_H__ */
diff --git a/include/drm/drm_crtc_helper.h b/include/drm/drm_crtc_helper.h
index 4c12319..c22b24d 100644
--- a/include/drm/drm_crtc_helper.h
+++ b/include/drm/drm_crtc_helper.h
@@ -40,6 +40,12 @@
 #include <linux/fb.h>
 
 #include "drm_fb_helper.h"
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+enum mode_set_atomic {
+	LEAVE_ATOMIC_MODE_SET,
+	ENTER_ATOMIC_MODE_SET,
+};
+#endif
 struct drm_crtc_helper_funcs {
 	/*
 	 * Control power levels on the CRTC.  If the mode passed in is
@@ -61,8 +67,17 @@ struct drm_crtc_helper_funcs {
 	/* Move the crtc on the current fb to the given position *optional* */
 	int (*mode_set_base)(struct drm_crtc *crtc, int x, int y,
 			     struct drm_framebuffer *old_fb);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	int (*mode_set_base_atomic)(struct drm_crtc *crtc,
+				    struct drm_framebuffer *fb, int x, int y,
+				    enum mode_set_atomic);
+
+	/* disable crtc when not in use - more explicit than dpms off */
+	void (*disable)(struct drm_crtc *crtc);
+#else
 	int (*mode_set_base_atomic)(struct drm_crtc *crtc,
 				    struct drm_framebuffer *fb, int x, int y);
+#endif
 
 	/* reload the current crtc LUT */
 	void (*load_lut)(struct drm_crtc *crtc);
@@ -125,12 +140,28 @@ static inline void drm_encoder_helper_add(struct drm_encoder *encoder,
 	encoder->helper_private = (void *)funcs;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static inline void drm_connector_helper_add(struct drm_connector *connector,
+				const struct drm_connector_helper_funcs *funcs)
+{
+	connector->helper_private = (void *)funcs;
+}
+#else
 static inline int drm_connector_helper_add(struct drm_connector *connector,
 					    const struct drm_connector_helper_funcs *funcs)
 {
 	connector->helper_private = (void *)funcs;
 	return drm_fb_helper_add_connector(connector);
 }
+#endif
 
 extern int drm_helper_resume_force_mode(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern void drm_kms_helper_poll_init(struct drm_device *dev);
+extern void drm_kms_helper_poll_fini(struct drm_device *dev);
+extern void drm_helper_hpd_irq_event(struct drm_device *dev);
+
+extern void drm_kms_helper_poll_disable(struct drm_device *dev);
+extern void drm_kms_helper_poll_enable(struct drm_device *dev);
+#endif
 #endif
diff --git a/include/drm/drm_edid.h b/include/drm/drm_edid.h
index b420989..1d81bd9 100644
--- a/include/drm/drm_edid.h
+++ b/include/drm/drm_edid.h
@@ -28,6 +28,14 @@
 #define EDID_LENGTH 128
 #define DDC_ADDR 0x50
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define CEA_EXT	    0x02
+#define VTB_EXT	    0x10
+#define DI_EXT	    0x40
+#define LS_EXT	    0x50
+#define MI_EXT	    0x60
+#endif
+
 struct est_timings {
 	u8 t1;
 	u8 t2;
diff --git a/include/drm/drm_fb_helper.h b/include/drm/drm_fb_helper.h
index 1f2ab94..1b8a3ae 100644
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
@@ -35,14 +35,33 @@
 struct drm_fb_helper_crtc {
 	uint32_t crtc_id;
 	struct drm_mode_set mode_set;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_display_mode *desired_mode;
+#endif
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+struct drm_fb_helper;
+
+struct drm_fb_helper_surface_size {
+	u32 fb_width;
+	u32 fb_height;
+	u32 surface_width;
+	u32 surface_height;
+	u32 surface_bpp;
+	u32 surface_depth;
+};
+#endif
 
 struct drm_fb_helper_funcs {
 	void (*gamma_set)(struct drm_crtc *crtc, u16 red, u16 green,
 			  u16 blue, int regno);
 	void (*gamma_get)(struct drm_crtc *crtc, u16 *red, u16 *green,
 			  u16 *blue, int regno);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	int (*fb_probe)(struct drm_fb_helper *helper,
+			struct drm_fb_helper_surface_size *sizes);
+#endif
 };
 
 /* mode specified on the command line */
@@ -61,6 +80,9 @@ struct drm_fb_helper_cmdline_mode {
 
 struct drm_fb_helper_connector {
 	struct drm_fb_helper_cmdline_mode cmdline_mode;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_connector *connector;
+#endif
 };
 
 struct drm_fb_helper {
@@ -68,14 +90,34 @@ struct drm_fb_helper {
 	struct drm_framebuffer *saved_fb;
 	struct drm_device *dev;
 	struct drm_display_mode *mode;
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	struct dbg_kms_ops kdb_ops;
+#endif
 	int crtc_count;
 	struct drm_fb_helper_crtc *crtc_info;
 	struct drm_fb_helper_funcs *funcs;
 	int conn_limit;
 	struct list_head kernel_fb_list;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	int connector_count;
+	struct drm_fb_helper_connector **connector_info;
+	struct fb_info *fbdev;
+	u32 pseudo_palette[17];
+	/* we got a hotplug but fbdev wasn't running the console
+	   delay until next set_par */
+	bool delayed_hotplug;
+#endif
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int drm_fb_helper_single_fb_probe(struct drm_fb_helper *helper,
+				  int preferred_bpp);
+
+int drm_fb_helper_init(struct drm_device *dev,
+		       struct drm_fb_helper *helper, int crtc_count,
+		       int max_conn);
+void drm_fb_helper_fini(struct drm_fb_helper *helper);
+#else
 int drm_fb_helper_single_fb_probe(struct drm_device *dev,
 				  int preferred_bpp,
 				  int (*fb_create)(struct drm_device *dev,
@@ -86,6 +128,7 @@ int drm_fb_helper_single_fb_probe(struct drm_device *dev,
 						   uint32_t surface_depth,
 						   uint32_t surface_bpp,
 						   struct drm_framebuffer **fb_ptr));
+#endif
 int drm_fb_helper_init_crtc_count(struct drm_fb_helper *helper, int crtc_count,
 				  int max_conn);
 void drm_fb_helper_free(struct drm_fb_helper *helper);
@@ -103,13 +146,26 @@ int drm_fb_helper_setcolreg(unsigned regno,
 			    struct fb_info *info);
 
 void drm_fb_helper_restore(void);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+void drm_fb_helper_fill_var(struct fb_info *info,
+			    struct drm_fb_helper *fb_helper,
+			    uint32_t fb_width, uint32_t fb_height);
+bool drm_fb_helper_hotplug_event(struct drm_fb_helper *fb_helper);
+bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper, int bpp_sel);
+int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *fb_helper);
+int drm_fb_helper_debug_enter(struct fb_info *info);
+int drm_fb_helper_debug_leave(struct fb_info *info);
+#else
 void drm_fb_helper_fill_var(struct fb_info *info, struct drm_framebuffer *fb,
 			    uint32_t fb_width, uint32_t fb_height);
+#endif
 void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,
 			    uint32_t depth);
 
 int drm_fb_helper_add_connector(struct drm_connector *connector);
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 int drm_fb_helper_parse_command_line(struct drm_device *dev);
+#endif
 int drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info);
 
 #endif
diff --git a/include/drm/drm_fixed.h b/include/drm/drm_fixed.h
new file mode 100644
index 0000000..4a08a66
--- /dev/null
+++ b/include/drm/drm_fixed.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2009 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Dave Airlie
+ */
+#ifndef DRM_FIXED_H
+#define DRM_FIXED_H
+
+typedef union dfixed {
+	u32 full;
+} fixed20_12;
+
+
+#define dfixed_const(A) (u32)(((A) << 12))/*  + ((B + 0.000122)*4096)) */
+#define dfixed_const_half(A) (u32)(((A) << 12) + 2048)
+#define dfixed_const_666(A) (u32)(((A) << 12) + 2731)
+#define dfixed_const_8(A) (u32)(((A) << 12) + 3277)
+#define dfixed_mul(A, B) ((u64)((u64)(A).full * (B).full + 2048) >> 12)
+#define dfixed_init(A) { .full = dfixed_const((A)) }
+#define dfixed_init_half(A) { .full = dfixed_const_half((A)) }
+#define dfixed_trunc(A) ((A).full >> 12)
+
+static inline u32 dfixed_floor(fixed20_12 A)
+{
+	u32 non_frac = dfixed_trunc(A);
+
+	return dfixed_const(non_frac);
+}
+
+static inline u32 dfixed_ceil(fixed20_12 A)
+{
+	u32 non_frac = dfixed_trunc(A);
+
+	if (A.full > dfixed_const(non_frac))
+		return dfixed_const(non_frac + 1);
+	else
+		return dfixed_const(non_frac);
+}
+
+static inline u32 dfixed_div(fixed20_12 A, fixed20_12 B)
+{
+	u64 tmp = ((u64)A.full << 13);
+
+	do_div(tmp, B.full);
+	tmp += 1;
+	tmp /= 2;
+	return lower_32_bits(tmp);
+}
+#endif
diff --git a/include/drm/drm_global.h b/include/drm/drm_global.h
new file mode 100644
index 0000000..a06805e
--- /dev/null
+++ b/include/drm/drm_global.h
@@ -0,0 +1,53 @@
+/**************************************************************************
+ *
+ * Copyright 2008-2009 VMware, Inc., Palo Alto, CA., USA
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+/*
+ * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
+ */
+
+#ifndef _DRM_GLOBAL_H_
+#define _DRM_GLOBAL_H_
+enum drm_global_types {
+	DRM_GLOBAL_TTM_MEM = 0,
+	DRM_GLOBAL_TTM_BO,
+	DRM_GLOBAL_TTM_OBJECT,
+	DRM_GLOBAL_NUM
+};
+
+struct drm_global_reference {
+	enum drm_global_types global_type;
+	size_t size;
+	void *object;
+	int (*init) (struct drm_global_reference *);
+	void (*release) (struct drm_global_reference *);
+};
+
+extern void drm_global_init(void);
+extern void drm_global_release(void);
+extern int drm_global_item_ref(struct drm_global_reference *ref);
+extern void drm_global_item_unref(struct drm_global_reference *ref);
+
+#endif
diff --git a/include/drm/drm_mm.h b/include/drm/drm_mm.h
index 4c10be3..8a1b1ef 100644
--- a/include/drm/drm_mm.h
+++ b/include/drm/drm_mm.h
@@ -44,16 +44,39 @@
 struct drm_mm_node {
 	struct list_head fl_entry;
 	struct list_head ml_entry;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct list_head free_stack;
+	struct list_head node_list;
+	unsigned free:1;
+	unsigned scanned_block:1;
+	unsigned scanned_prev_free:1;
+	unsigned scanned_next_free:1;
+#else
 	int free;
+#endif
 	unsigned long start;
 	unsigned long size;
 	struct drm_mm *mm;
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	void *private;
+#endif
 };
 
 struct drm_mm {
 	struct list_head fl_entry;
 	struct list_head ml_entry;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	/* List of free memory blocks, most recently freed ordered. */
+	struct list_head free_stack;
+	/* List of all memory nodes, ordered according to the (increasing) start
+	 * address of the memory node. */
+	struct list_head node_list;
+	unsigned scan_alignment;
+	unsigned long scan_size;
+	unsigned long scan_hit_start;
+	unsigned scan_hit_size;
+	unsigned scanned_blocks;
+#endif
 	struct list_head unused_nodes;
 	int num_unused;
 	spinlock_t unused_lock;
@@ -133,6 +156,12 @@ static inline struct drm_mm *drm_get_mm(struct drm_mm_node *block)
 	return block->mm;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+void drm_mm_init_scan(struct drm_mm *mm, unsigned long size,
+		      unsigned alignment);
+int drm_mm_scan_add_block(struct drm_mm_node *node);
+int drm_mm_scan_remove_block(struct drm_mm_node *node);
+#endif
 extern void drm_mm_debug_table(struct drm_mm *mm, const char *prefix);
 #ifdef CONFIG_DEBUG_FS
 int drm_mm_dump_table(struct seq_file *m, struct drm_mm *mm);
diff --git a/include/drm/i915_drm.h b/include/drm/i915_drm.h
index b64a8d7..f83f4dd 100644
--- a/include/drm/i915_drm.h
+++ b/include/drm/i915_drm.h
@@ -206,6 +206,11 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
 #define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
 #define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + \
+						DRM_I915_HWS_ADDR, \
+						struct drm_i915_gem_init)
+#endif
 #define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)
 #define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)
 #define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)
@@ -275,6 +280,10 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_OVERLAY           7
 #define I915_PARAM_HAS_PAGEFLIPPING	 8
 #define I915_PARAM_HAS_EXECBUF2          9
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define I915_PARAM_HAS_BSD		 10
+#define I915_PARAM_HAS_BLT		 11
+#endif
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -616,6 +625,13 @@ struct drm_i915_gem_execbuffer2 {
 	__u32 num_cliprects;
 	/** This is a struct drm_clip_rect *cliprects */
 	__u64 cliprects_ptr;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define I915_EXEC_RING_MASK              (7<<0)
+#define I915_EXEC_DEFAULT                (0<<0)
+#define I915_EXEC_RENDER                 (1<<0)
+#define I915_EXEC_BSD                    (2<<0)
+#define I915_EXEC_BLT                    (3<<0)
+#endif
 	__u64 flags; /* currently unused */
 	__u64 rsvd1;
 	__u64 rsvd2;
-- 
1.6.5.2

