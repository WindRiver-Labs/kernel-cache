From 0ed20824fdcbbe303c7b2df8fd2a7cc34218265a Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Mon, 24 Jan 2011 18:40:57 +0800
Subject: [PATCH 08/11] graphic/drm/i915: add sandybridge graphic support in i915 folder

In order to not impact existing i915 platforms, and also for
stability and isolation, add some modifications(all add with
CONFIG_DRM_I915_SB) in i915 folder. These modifications included
lots of structural differences which refer to upstream commits,
such as the following.

The upstream commits:
  6ec3d0c0e9c0c605696e91048eebaca7b0c36695 [drm/i915/crt: Use a DDC probe on 0xA0 before load-detect]
  386516744ba45d50f42c6999151cc210cb4f96e4 [drm/fb: fix fbdev object model + cleanup properly]
  eb1f8e4f3be898df808e2dfc131099f5831d491d [drm/fbdev: rework output polling to be back in the core. (v4)]
Add new functions(intel_crt_ddc_probe, intelfb_create and intel_fb_output_poll_changed).

The upstream commits:
  44834a67c0082e2cf74b16be91e49108b1432d65 [drm/i915: Use the VBT from OpRegion when available (v3)]
  53640e1d07fb7dd5d14300dd94f4718eca33348e [drm/i915: Track gpu fence usage]
  e957d7720a2797b31231616014b68f4f6203145e [drm/i915/sdvo: Fix GMBUSification]
  a6c45cf013a57e32ddae43dd4ac911eb4a3919fd [drm/i915: INTEL_INFO->gen supercedes i8xx, i9xx, i965g]
Contain struct changes(intel_opregion, drm_i915_fence_reg, sdvo_device_mapping and intel_device_info).

The upstream commits:
  b690e96cf9e6a6cde6f0393de47bdd6317ddb5de [drm/i915: add pipe A force quirks to i915 driver]
  3bad0781832e4e8c9a532f1169bfcd7257bcfd9e [drm/i915: Probe for PCH chipset type]
  12682a971160959072c4970da9b7778709f60bc9 [drm/i915: enable sdvo lvds scaling function]
  c55217064eb728fc9348de781979b533e7cc116c [drm/i915/sdvo: Add missing TV filters]
Add new macros(UIRK_PIPEA_FORCE, INTEL_PCH_TYPE, SDVO_NEED_TO_STALL and SDVO_CMD_GET_HPOS).

The upstream commits:
  8187a2b70e34c727a06617441f74f202b6fefaf9 [drm/i915: introduce intel_ring_buffer structure (V2)]
Contain macro changes(BEGIN_LP_RING and OUT_RING).

The upstream commits:
  890f3359f7b84d7015104360d647ccac5f515542 [drm/i915/i2c: Track the parent encoder rather than just the dev]
  a6c45cf013a57e32ddae43dd4ac911eb4a3919fd [drm/i915: INTEL_INFO->gen supercedes i8xx, i9xx, i965g]
  f899fc64cda8569d0529452aafc0da31c042df2e [drm/i915: use GMBUS to manage i2c links]
Contain function changes(intel_crt_get_modes, intel_crt_load_detect and intel_crt_get_modes).

The upstream commits:
  e2f0ba97d60e59fe5c6237851933a9c38a8f9a24 [drm/i915: sync SDVO code with stable userland modesetting driver]
  3bad0781832e4e8c9a532f1169bfcd7257bcfd9e [drm/i915: Probe for PCH chipset type]
Add new structs(intel_sdvo_tv_format, intel_sdvo_in_out_map and intel_pch).

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c    |    4 +
 drivers/gpu/drm/i915/i915_drv.h        |  343 +++++++++++++++++++
 drivers/gpu/drm/i915/i915_gem_tiling.c |    8 +
 drivers/gpu/drm/i915/i915_reg.h        |  566 +++++++++++++++++++++++++++++++-
 drivers/gpu/drm/i915/i915_trace.h      |   39 +++-
 drivers/gpu/drm/i915/intel_bios.c      |  122 +++++++
 drivers/gpu/drm/i915/intel_bios.h      |    4 +
 drivers/gpu/drm/i915/intel_crt.c       |  132 ++++++++
 drivers/gpu/drm/i915/intel_drv.h       |  198 +++++++++++-
 drivers/gpu/drm/i915/intel_fb.c        |  220 +++++++++++++
 drivers/gpu/drm/i915/intel_modes.c     |   28 ++
 drivers/gpu/drm/i915/intel_sdvo_regs.h |   33 ++
 12 files changed, 1694 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 6e7e47d..029e065 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -579,7 +579,11 @@ static int i915_fbc_status(struct seq_file *m, void *unused)
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		if (!crtc->enabled)
 			continue;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+		if (dev_priv->display.fbc_enabled(crtc->dev))
+#else
 		if (dev_priv->display.fbc_enabled(crtc))
+#endif
 			fbc_enabled = true;
 	}
 
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index aa7a5a8..d82df02 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -33,6 +33,13 @@
 #include "i915_reg.h"
 #include "intel_bios.h"
 #include <linux/io-mapping.h>
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#include "intel_ringbuffer.h"
+#include <linux/i2c.h>
+#include <drm/intel-gtt.h>
+
+#define I915_GEM_GPU_DOMAINS	(~(I915_GEM_DOMAIN_CPU | I915_GEM_DOMAIN_GTT))
+#endif
 
 /* General customization:
  */
@@ -118,8 +125,18 @@ struct intel_opregion {
 	struct opregion_swsci *swsci;
 	struct opregion_asle *asle;
 	int enabled;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	void *vbt;
+#endif
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define OPREGION_SIZE            (8*1024)
+
+struct intel_overlay;
+struct intel_overlay_error_state;
+#endif
+
 struct drm_i915_master_private {
 	drm_local_map_t *sarea;
 	struct _drm_i915_sarea *sarea_priv;
@@ -128,6 +145,10 @@ struct drm_i915_master_private {
 
 struct drm_i915_fence_reg {
 	struct drm_gem_object *obj;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct list_head lru_list;
+	bool gpu;
+#endif
 };
 
 struct sdvo_device_mapping {
@@ -135,6 +156,11 @@ struct sdvo_device_mapping {
 	u8 slave_addr;
 	u8 dvo_wiring;
 	u8 initialized;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	u8 i2c_pin;
+	u8 i2c_speed;
+	u8 ddc_pin;
+#endif
 };
 
 struct drm_i915_error_state {
@@ -171,17 +197,30 @@ struct drm_i915_error_state {
 		u32 purgeable:1;
 	} *active_bo;
 	u32 active_bo_count;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct intel_overlay_error_state *overlay;
+#endif
 };
 
 struct drm_i915_display_funcs {
 	void (*dpms)(struct drm_crtc *crtc, int mode);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	bool (*fbc_enabled)(struct drm_device *dev);
+#else
 	bool (*fbc_enabled)(struct drm_crtc *crtc);
+#endif
 	void (*enable_fbc)(struct drm_crtc *crtc, unsigned long interval);
 	void (*disable_fbc)(struct drm_device *dev);
 	int (*get_display_clock_speed)(struct drm_device *dev);
 	int (*get_fifo_size)(struct drm_device *dev, int plane);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	void (*update_wm)(struct drm_device *dev, int planea_clock,
+			  int planeb_clock, int sr_hdisplay, int sr_htotal,
+			  int pixel_size);
+#else
 	void (*update_wm)(struct drm_device *dev, int planea_clock,
 			  int planeb_clock, int sr_hdisplay, int pixel_size);
+#endif
 	/* clock updates for mode set */
 	/* cursor updates */
 	/* render clock increase/decrease */
@@ -193,6 +232,9 @@ struct drm_i915_display_funcs {
 struct intel_overlay;
 
 struct intel_device_info {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	u8 gen;
+#endif
 	u8 is_mobile : 1;
 	u8 is_i8xx : 1;
 	u8 is_i85x : 1;
@@ -212,16 +254,42 @@ struct intel_device_info {
 	u8 has_pipe_cxsr : 1;
 	u8 has_hotplug : 1;
 	u8 cursor_needs_physical : 1;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	u8 is_broadwater:1;
+	u8 is_crestline:1;
+	u8 has_overlay:1;
+	u8 overlay_needs_physical:1;
+	u8 supports_tv:1;
+	u8 has_bsd_ring:1;
+	u8 has_blt_ring:1;
+#endif
 };
 
 enum no_fbc_reason {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	FBC_NO_OUTPUT, /* no outputs enabled to compress */
+#endif
 	FBC_STOLEN_TOO_SMALL, /* not enough space to hold compressed buffers */
 	FBC_UNSUPPORTED_MODE, /* interlace or doublescanned mode */
 	FBC_MODE_TOO_LARGE, /* mode too large for compression */
 	FBC_BAD_PLANE, /* fbc not supported on plane */
 	FBC_NOT_TILED, /* buffer not tiled */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	FBC_MULTIPLE_PIPES, /* more than one pipe active */
+#endif
+};
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+enum intel_pch {
+	PCH_IBX,	/* Ibexpeak PCH */
+	PCH_CPT,	/* Cougarpoint PCH */
 };
 
+#define QUIRK_PIPEA_FORCE (1<<0)
+
+struct intel_fbdev;
+#endif
+
 typedef struct drm_i915_private {
 	struct drm_device *dev;
 
@@ -230,6 +298,44 @@ typedef struct drm_i915_private {
 	int has_gem;
 
 	void __iomem *regs;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct intel_gmbus {
+		struct i2c_adapter adapter;
+		struct i2c_adapter *force_bit;
+		u32 reg0;
+	} *gmbus;
+	struct intel_ring_buffer render_ring;
+	struct intel_ring_buffer bsd_ring;
+	struct intel_ring_buffer blt_ring;
+	uint32_t next_seqno;
+	struct drm_gem_object *renderctx;
+#define I915_DEBUG_READ (1<<0)
+#define I915_DEBUG_WRITE (1<<1)
+	unsigned long debug_flags;
+	int num_pipe;
+	uint32_t last_instdone;
+	uint32_t last_instdone1;
+	unsigned long cfb_offset;
+	int cfb_y;
+	struct {
+		int rate;
+		int lanes;
+		int preemphasis;
+		int vswing;
+
+		bool initialized;
+		bool support;
+		int bpp;
+		struct edp_power_seq pps;
+	} edp;
+	bool no_aux_handshake;
+	unsigned int is_ddr3;
+	struct completion error_completion;
+	/* PCH chipset type */
+	enum intel_pch pch_type;
+
+	unsigned long quirks;
+#endif
 
 	struct pci_dev *bridge_dev;
 	drm_i915_ring_buffer_t ring;
@@ -488,6 +594,23 @@ typedef struct drm_i915_private {
 	u32 saveMCHBAR_RENDER_STANDBY;
 
 	struct {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+		/** Bridge to intel-gtt-ko */
+		struct intel_gtt *gtt;
+		/** Memory allocator for GTT stolen memory */
+		struct drm_mm vram;
+		struct list_head pinned_list;
+		uint32_t flush_rings;
+
+		/* accounting, useful for userland debugging */
+		size_t object_memory;
+		size_t pin_memory;
+		size_t gtt_memory;
+		size_t gtt_total;
+		u32 object_count;
+		u32 pin_count;
+		u32 gtt_count;
+#endif
 		struct drm_mm gtt_space;
 
 		struct io_mapping *gtt_mapping;
@@ -607,6 +730,26 @@ typedef struct drm_i915_private {
 	struct sdvo_device_mapping sdvo_mappings[2];
 	/* indicate whether the LVDS_BORDER should be enabled or not */
 	unsigned int lvds_border_bits;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	/* Panel fitter placement and size for Ironlake+ */
+	u32 pch_pf_pos, pch_pf_size;
+	u8 fmax;
+	u8 fstart;
+
+	u64 last_count1;
+	unsigned long last_time1;
+	u64 last_count2;
+	struct timespec last_time2;
+	unsigned long gfx_power;
+	int c_m;
+	int r_t;
+	u8 corr;
+	spinlock_t *mchdev_lock;
+	unsigned long last_gpu_reset;
+
+	/* list of fbdev register on this device */
+	struct intel_fbdev *fbdev;
+#endif
 
 	struct drm_crtc *plane_to_crtc_mapping[2];
 	struct drm_crtc *pipe_to_crtc_mapping[2];
@@ -739,9 +882,23 @@ struct drm_i915_gem_object {
 	 * reaches 0, dev_priv->pending_flip_queue will be woken up.
 	 */
 	atomic_t pending_flip;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_gem_object base;
+	struct list_head ring_list;
+	/** This object's place on eviction list */
+	struct list_head evict_list;
+#define DRM_I915_GEM_OBJECT_MAX_PAGES_REFCOUNT 0x3
+#define DRM_I915_GEM_OBJECT_MAX_PIN_COUNT 0xf
+	/* Which ring is refering to is this object */
+	struct intel_ring_buffer *ring;
+#endif
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define to_intel_bo(x) container_of(x, struct drm_i915_gem_object, base)
+#else
 #define to_intel_bo(x) ((struct drm_i915_gem_object *) (x)->driver_private)
+#endif
 
 /**
  * Request queue structure.
@@ -754,6 +911,12 @@ struct drm_i915_gem_object {
  * an emission time with seqnos for tracking how far ahead of the GPU we are.
  */
 struct drm_i915_gem_request {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	/** On Which ring this request was generated */
+	struct intel_ring_buffer *ring;
+
+	struct drm_i915_file_private *file_priv;
+#endif
 	/** GEM sequence number associated with this request. */
 	uint32_t seqno;
 
@@ -769,6 +932,9 @@ struct drm_i915_gem_request {
 
 struct drm_i915_file_private {
 	struct {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+		struct spinlock lock;
+#endif
 		struct list_head request_list;
 	} mm;
 };
@@ -810,6 +976,27 @@ extern int i915_emit_box(struct drm_device *dev,
 			 struct drm_clip_rect *boxes,
 			 int i, int DR1, int DR4);
 extern int i965_reset(struct drm_device *dev, u8 flags);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern unsigned long i915_chipset_val(struct drm_i915_private *dev_priv);
+extern unsigned long i915_mch_val(struct drm_i915_private *dev_priv);
+extern unsigned long i915_gfx_val(struct drm_i915_private *dev_priv);
+extern void i915_update_gfx_val(struct drm_i915_private *dev_priv);
+extern void i915_disable_irq(drm_i915_private_t *dev_priv, u32 mask);
+extern void ironlake_enable_graphics_irq(drm_i915_private_t *dev_priv,
+		u32 mask);
+extern void ironlake_disable_graphics_irq(drm_i915_private_t *dev_priv,
+		u32 mask);
+
+#ifdef CONFIG_DEBUG_FS
+extern void i915_destroy_error_state(struct drm_device *dev);
+#else
+#define i915_destroy_error_state(x)
+#endif
+
+int i915_gem_check_is_wedged(struct drm_device *dev);
+struct drm_gem_object *i915_gem_alloc_object(struct drm_device *dev,
+					      size_t size);
+#endif
 
 /* i915_irq.c */
 void i915_hangcheck_elapsed(unsigned long data);
@@ -911,8 +1098,17 @@ void i915_gem_release_mmap(struct drm_gem_object *obj);
 void i915_gem_lastclose(struct drm_device *dev);
 uint32_t i915_get_gem_seqno(struct drm_device *dev);
 bool i915_seqno_passed(uint32_t seq1, uint32_t seq2);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int i915_gem_object_get_fence_reg(struct drm_gem_object *obj,
+				  bool interruptible);
+int i915_gem_object_put_fence_reg(struct drm_gem_object *obj,
+				  bool interruptible);
+int i915_gpu_idle(struct drm_device *dev);
+void i915_gem_reset(struct drm_device *dev);
+#else
 int i915_gem_object_get_fence_reg(struct drm_gem_object *obj);
 int i915_gem_object_put_fence_reg(struct drm_gem_object *obj);
+#endif
 void i915_gem_retire_requests(struct drm_device *dev);
 void i915_gem_retire_work_handler(struct work_struct *work);
 void i915_gem_clflush_object(struct drm_gem_object *obj);
@@ -924,15 +1120,35 @@ void i915_gem_cleanup_ringbuffer(struct drm_device *dev);
 int i915_gem_do_init(struct drm_device *dev, unsigned long start,
 		     unsigned long end);
 int i915_gem_idle(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+uint32_t i915_add_request(struct drm_device *dev,
+			  struct drm_file *file_priv,
+			  struct drm_i915_gem_request *request,
+			  struct intel_ring_buffer *ring);
+int i915_do_wait_request(struct drm_device *dev,
+			 uint32_t seqno,
+			 bool interruptible,
+			 struct intel_ring_buffer *ring);
+#else
 uint32_t i915_add_request(struct drm_device *dev, struct drm_file *file_priv,
 			  uint32_t flush_domains);
 int i915_do_wait_request(struct drm_device *dev, uint32_t seqno, int interruptible);
+#endif
 int i915_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
 int i915_gem_object_set_to_gtt_domain(struct drm_gem_object *obj,
 				      int write);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int i915_gem_object_set_to_display_plane(struct drm_gem_object *obj,
+					 bool pipelined);
+int i915_gem_attach_phys_object(struct drm_device *dev,
+				struct drm_gem_object *obj,
+				int id,
+				int align);
+#else
 int i915_gem_object_set_to_display_plane(struct drm_gem_object *obj);
 int i915_gem_attach_phys_object(struct drm_device *dev,
 				struct drm_gem_object *obj, int id);
+#endif
 void i915_gem_detach_phys_object(struct drm_device *dev,
 				 struct drm_gem_object *obj);
 void i915_gem_free_all_phys_object(struct drm_device *dev);
@@ -944,6 +1160,12 @@ void i915_gem_object_flush_write_domain(struct drm_gem_object *obj);
 void i915_gem_shrinker_init(void);
 void i915_gem_shrinker_exit(void);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* i915_gem_evict.c */
+int i915_gem_evict_everything(struct drm_device *dev);
+int i915_gem_evict_inactive(struct drm_device *dev);
+#endif
+
 /* i915_gem_tiling.c */
 void i915_gem_detect_bit_6_swizzle(struct drm_device *dev);
 void i915_gem_object_do_bit_17_swizzle(struct drm_gem_object *obj);
@@ -978,6 +1200,47 @@ extern int i915_restore_state(struct drm_device *dev);
 extern int i915_save_state(struct drm_device *dev);
 extern int i915_restore_state(struct drm_device *dev);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* intel_i2c.c */
+extern int intel_setup_gmbus(struct drm_device *dev);
+extern void intel_teardown_gmbus(struct drm_device *dev);
+extern void intel_gmbus_set_speed(struct i2c_adapter *adapter, int speed);
+extern void intel_gmbus_force_bit(struct i2c_adapter *adapter, bool force_bit);
+extern inline bool intel_gmbus_is_forced_bit(struct i2c_adapter *adapter)
+{
+	return container_of(adapter, struct intel_gmbus, adapter)->force_bit;
+}
+extern void intel_i2c_reset_gmbus(struct drm_device *dev);
+
+/* intel_opregion.c */
+extern int intel_opregion_setup(struct drm_device *dev);
+
+/* intel_acpi.c */
+#ifdef CONFIG_ACPI
+extern void intel_register_dsm_handler(void);
+extern void intel_unregister_dsm_handler(void);
+#else
+static inline void intel_register_dsm_handler(void) { return; }
+static inline void intel_unregister_dsm_handler(void) { return; }
+#endif /* CONFIG_ACPI */
+#endif
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#ifdef CONFIG_ACPI
+extern void intel_opregion_init(struct drm_device *dev);
+extern void intel_opregion_fini(struct drm_device *dev);
+extern void intel_opregion_asle_intr(struct drm_device *dev);
+extern void intel_opregion_gse_intr(struct drm_device *dev);
+extern void intel_opregion_enable_asle(struct drm_device *dev);
+#else
+static inline void intel_opregion_init(struct drm_device *dev) { return; }
+static inline void intel_opregion_fini(struct drm_device *dev) { return; }
+static inline void intel_opregion_asle_intr(struct drm_device *dev) { return; }
+static inline void intel_opregion_gse_intr(struct drm_device *dev) { return; }
+static inline void intel_opregion_enable_asle(struct drm_device *dev) \
+								{ return; }
+#endif
+#else
 #ifdef CONFIG_ACPI
 /* i915_opregion.c */
 extern int intel_opregion_init(struct drm_device *dev, int resume);
@@ -992,6 +1255,7 @@ static inline void opregion_asle_intr(struct drm_device *dev) { return; }
 static inline void ironlake_opregion_gse_intr(struct drm_device *dev) { return; }
 static inline void opregion_enable_asle(struct drm_device *dev) { return; }
 #endif
+#endif
 
 /* modesetting */
 extern void intel_modeset_init(struct drm_device *dev);
@@ -999,6 +1263,23 @@ extern void intel_modeset_cleanup(struct drm_device *dev);
 extern int intel_modeset_vga_set_state(struct drm_device *dev, bool state);
 extern void i8xx_disable_fbc(struct drm_device *dev);
 extern void g4x_disable_fbc(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern void ironlake_disable_fbc(struct drm_device *dev);
+extern void intel_disable_fbc(struct drm_device *dev);
+extern void intel_enable_fbc(struct drm_crtc *crtc, unsigned long interval);
+extern bool intel_fbc_enabled(struct drm_device *dev);
+extern bool ironlake_set_drps(struct drm_device *dev, u8 val);
+extern void intel_detect_pch(struct drm_device *dev);
+extern int intel_trans_dp_port_sel(struct drm_crtc *crtc);
+
+/* overlay */
+#ifdef CONFIG_DEBUG_FS
+extern struct intel_overlay_error_state
+		*intel_overlay_capture_error_state(struct drm_device *dev);
+extern void intel_overlay_print_error_state(struct seq_file *m,
+				struct intel_overlay_error_state *error);
+#endif
+#endif
 
 /**
  * Lock test for when it's just for synchronization of ring access.
@@ -1006,10 +1287,18 @@ extern void g4x_disable_fbc(struct drm_device *dev);
  * In that case, we don't need to do it when GEM is initialized as nobody else
  * has access to the ring.
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define RING_LOCK_TEST_WITH_RETURN(dev, file_priv) do {			\
+	if (((drm_i915_private_t *)dev->dev_private)->render_ring.gem_object \
+			== NULL)					\
+		LOCK_TEST_WITH_RETURN(dev, file_priv);			\
+} while (0)
+#else
 #define RING_LOCK_TEST_WITH_RETURN(dev, file_priv) do {			\
 	if (((drm_i915_private_t *)dev->dev_private)->ring.ring_obj == NULL) \
 		LOCK_TEST_WITH_RETURN(dev, file_priv);			\
 } while (0)
+#endif
 
 #define I915_READ(reg)          readl(dev_priv->regs + (reg))
 #define I915_WRITE(reg, val)     writel(val, dev_priv->regs + (reg))
@@ -1020,11 +1309,42 @@ extern void g4x_disable_fbc(struct drm_device *dev);
 #define I915_WRITE64(reg, val)	writeq(val, dev_priv->regs + (reg))
 #define I915_READ64(reg)	readq(dev_priv->regs + (reg))
 #define POSTING_READ(reg)	(void)I915_READ(reg)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define POSTING_READ16(reg)	(void)I915_READ16(reg)
+
+#define I915_DEBUG_ENABLE_IO() (dev_priv->debug_flags |= I915_DEBUG_READ | \
+				I915_DEBUG_WRITE)
+#define I915_DEBUG_DISABLE_IO() (dev_priv->debug_flags &= ~(I915_DEBUG_READ | \
+							    I915_DEBUG_WRITE))
+#endif
 
 #define I915_VERBOSE 0
 
 #define RING_LOCALS	volatile unsigned int *ring_virt__;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define BEGIN_LP_RING(n)  do { \
+	drm_i915_private_t *dev_priv__ = dev->dev_private;                \
+	if (I915_VERBOSE)						\
+		DRM_DEBUG("   BEGIN_LP_RING %x\n", (int)(n));		\
+	intel_ring_begin(dev, &dev_priv__->render_ring, (n));		\
+} while (0)
+
+#define OUT_RING(x) do {						\
+	drm_i915_private_t *dev_priv__ = dev->dev_private;		\
+	if (I915_VERBOSE)						\
+		DRM_DEBUG("   OUT_RING %x\n", (int)(x));		\
+	intel_ring_emit(dev, &dev_priv__->render_ring, x);		\
+} while (0)
+
+#define ADVANCE_LP_RING() do {						\
+	drm_i915_private_t *dev_priv__ = dev->dev_private;                \
+	if (I915_VERBOSE)						\
+		DRM_DEBUG("ADVANCE_LP_RING %x\n",			\
+				dev_priv__->render_ring.tail);		\
+	intel_ring_advance(dev, &dev_priv__->render_ring);		\
+} while (0)
+#else
 #define BEGIN_LP_RING(n) do {						\
 	int bytes__ = 4*(n);						\
 	if (I915_VERBOSE) DRM_DEBUG("BEGIN_LP_RING(%d)\n", (n));	\
@@ -1050,6 +1370,7 @@ extern void g4x_disable_fbc(struct drm_device *dev);
 		DRM_DEBUG("ADVANCE_LP_RING %x\n", dev_priv->ring.tail);	\
 	I915_WRITE(PRB0_TAIL, dev_priv->ring.tail);			\
 } while(0)
+#endif
 
 /**
  * Reads a dword out of the status page, which is written to from the command
@@ -1066,7 +1387,12 @@ extern void g4x_disable_fbc(struct drm_device *dev);
  *
  * The area from dword 0x20 to 0x3ff is available for driver usage.
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define READ_HWSP(dev_priv, reg)  (((volatile u32 *)\
+			(dev_priv->render_ring.status_page.page_addr))[reg])
+#else
 #define READ_HWSP(dev_priv, reg)  (((volatile u32*)(dev_priv->hw_status_page))[reg])
+#endif
 #define READ_BREADCRUMB(dev_priv) READ_HWSP(dev_priv, I915_BREADCRUMB_INDEX)
 #define I915_GEM_HWS_INDEX		0x20
 #define I915_BREADCRUMB_INDEX		0x21
@@ -1097,7 +1423,24 @@ extern int i915_wait_ring(struct drm_device * dev, int n, const char *caller);
 #define IS_IRONLAKE_M(dev)	((dev)->pci_device == 0x0046)
 #define IS_IRONLAKE(dev)	(INTEL_INFO(dev)->is_ironlake)
 #define IS_I9XX(dev)		(INTEL_INFO(dev)->is_i9xx)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define IS_BROADWATER(dev)	(INTEL_INFO(dev)->is_broadwater)
+#define IS_CRESTLINE(dev)	(INTEL_INFO(dev)->is_crestline)
+#define IS_GEN5(dev)		(INTEL_INFO(dev)->gen == 5)
+#define IS_GEN6(dev)		(INTEL_INFO(dev)->gen == 6)
+
+#define HAS_BSD(dev)            (INTEL_INFO(dev)->has_bsd_ring)
+#define HAS_BLT(dev)            (INTEL_INFO(dev)->has_blt_ring)
+#define HAS_OVERLAY(dev)	(INTEL_INFO(dev)->has_overlay)
+#define OVERLAY_NEEDS_PHYSICAL(dev)	\
+				(INTEL_INFO(dev)->overlay_needs_physical)
+#define INTEL_PCH_TYPE(dev) (((struct drm_i915_private *) \
+					(dev)->dev_private)->pch_type)
+#define HAS_PCH_CPT(dev) (INTEL_PCH_TYPE(dev) == PCH_CPT)
+#define HAS_PCH_IBX(dev) (INTEL_PCH_TYPE(dev) == PCH_IBX)
+#else
 #define IS_GEN6(dev)		(INTEL_INFO(dev)->is_gen6)
+#endif
 #define IS_MOBILE(dev)		(INTEL_INFO(dev)->is_mobile)
 
 #define IS_GEN3(dev)	(IS_I915G(dev) ||			\
diff --git a/drivers/gpu/drm/i915/i915_gem_tiling.c b/drivers/gpu/drm/i915/i915_gem_tiling.c
index 4bdccef..ddc61b0 100644
--- a/drivers/gpu/drm/i915/i915_gem_tiling.c
+++ b/drivers/gpu/drm/i915/i915_gem_tiling.c
@@ -216,7 +216,11 @@ i915_tiling_ok(struct drm_device *dev, int stride, int size, int tiling_mode)
 	}
 
 	/* 965+ just needs multiples of tile width */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	if (INTEL_INFO(dev)->gen >= 4) {
+#else
 	if (IS_I965G(dev)) {
+#endif
 		if (stride & (tile_width - 1))
 			return false;
 		return true;
@@ -323,7 +327,11 @@ i915_gem_set_tiling(struct drm_device *dev, void *data,
 		if (!i915_gem_object_fence_offset_ok(obj, args->tiling_mode))
 			ret = i915_gem_object_unbind(obj);
 		else if (obj_priv->fence_reg != I915_FENCE_REG_NONE)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+			ret = i915_gem_object_put_fence_reg(obj, true);
+#else
 			ret = i915_gem_object_put_fence_reg(obj);
+#endif
 		else
 			i915_gem_release_mmap(obj);
 
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index eb01ca6..d696a00 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -25,6 +25,10 @@
 #ifndef _I915_REG_H_
 #define _I915_REG_H_
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define _PIPE(pipe, a, b) ((a) + (pipe)*((b)-(a)))
+#endif
+
 /*
  * The Bridge device's PCI config space has information about the
  * fb aperture size and the amount of pre-reserved memory.
@@ -111,6 +115,15 @@
 #define  GDRST_RENDER	(1<<2)
 #define  GDRST_MEDIA	(3<<2)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* Graphics reset regs */
+#define I965_GDRST 0xc0 /* PCI config register */
+#define ILK_GDSR 0x2ca4 /* MCHBAR offset */
+#define  GRDOM_FULL	(0<<2)
+#define  GRDOM_RENDER	(1<<2)
+#define  GRDOM_MEDIA	(3<<2)
+#endif
+
 /* VGA stuff */
 
 #define VGA_ST01_MDA 0x3ba
@@ -170,6 +183,12 @@
 #define   MI_NO_WRITE_FLUSH	(1 << 2)
 #define   MI_SCENE_COUNT	(1 << 3) /* just increment scene count */
 #define   MI_END_SCENE		(1 << 4) /* flush binner and incr scene count */
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* invalidate indirect state pointers */
+#define MI_INVALIDATE_ISP       (1 << 5)
+#endif
+
 #define MI_BATCH_BUFFER_END	MI_INSTR(0x0a, 0)
 #define MI_REPORT_HEAD		MI_INSTR(0x07, 0)
 #define MI_OVERLAY_FLIP		MI_INSTR(0x11,0)
@@ -180,6 +199,17 @@
 #define MI_DISPLAY_FLIP		MI_INSTR(0x14, 2)
 #define MI_DISPLAY_FLIP_I915	MI_INSTR(0x14, 1)
 #define   MI_DISPLAY_FLIP_PLANE(n) ((n) << 20)
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define MI_SET_CONTEXT		MI_INSTR(0x18, 0)
+#define MI_MM_SPACE_GTT		(1<<8)
+#define MI_MM_SPACE_PHYSICAL	(0<<8)
+#define MI_SAVE_EXT_STATE_EN	(1<<3)
+#define MI_RESTORE_EXT_STATE_EN	(1<<2)
+#define MI_RESTORE_INHIBIT	(1<<0)
+#define MI_FLUSH_DW		MI_INSTR(0x26, 2) /* for GEN6 */
+#endif
+
 #define MI_STORE_DWORD_IMM	MI_INSTR(0x20, 1)
 #define   MI_MEM_VIRTUAL	(1 << 22) /* 965+ only */
 #define MI_STORE_DWORD_INDEX	MI_INSTR(0x21, 1)
@@ -242,6 +272,16 @@
 #define   PIPE_CONTROL_GLOBAL_GTT (1<<2) /* in addr dword */
 #define   PIPE_CONTROL_STALL_EN	(1<<1) /* in addr word, Ironlake+ only */
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/*
+ * Reset registers
+ */
+#define DEBUG_RESET_I830		0x6070
+#define  DEBUG_RESET_FULL		(1<<7)
+#define  DEBUG_RESET_RENDER		(1<<8)
+#define  DEBUG_RESET_DISPLAY		(1<<9)
+#endif
+
 /*
  * Fence registers
  */
@@ -276,6 +316,21 @@
 #define PRB0_HEAD	0x02034
 #define PRB0_START	0x02038
 #define PRB0_CTL	0x0203c
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define RENDER_RING_BASE	0x02000
+#define BSD_RING_BASE		0x04000
+#define GEN6_BSD_RING_BASE	0x12000
+#define BLT_RING_BASE		0x22000
+#define RING_TAIL(base)		((base)+0x30)
+#define RING_HEAD(base)		((base)+0x34)
+#define RING_START(base)	((base)+0x38)
+#define RING_CTL(base)		((base)+0x3c)
+#define RING_HWS_PGA(base)	((base)+0x80)
+#define RING_HWS_PGA_GEN6(base)	((base)+0x2080)
+#define RING_ACTHD(base)	((base)+0x74)
+#endif
+
 #define   TAIL_ADDR		0x001FFFF8
 #define   HEAD_WRAP_COUNT	0xFFE00000
 #define   HEAD_WRAP_ONE		0x00200000
@@ -288,6 +343,12 @@
 #define   RING_VALID_MASK	0x00000001
 #define   RING_VALID		0x00000001
 #define   RING_INVALID		0x00000000
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   RING_WAIT_I8XX	(1<<0) /* gen2, PRBx_HEAD */
+#define   RING_WAIT		(1<<11) /* gen3+, PRBx_CTL */
+#endif
+
 #define PRB1_TAIL	0x02040 /* 915+ only */
 #define PRB1_HEAD	0x02044 /* 915+ only */
 #define PRB1_START	0x02048 /* 915+ only */
@@ -313,6 +374,10 @@
 #define MI_MODE		0x0209c
 # define VS_TIMER_DISPATCH				(1 << 6)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define MI_FLUSH_ENABLE	(1 << 11)
+#endif
+
 #define SCPD0		0x0209c /* 915+ only */
 #define IER		0x020a0
 #define IIR		0x020a4
@@ -335,6 +400,11 @@
 #define   I915_DEBUG_INTERRUPT				(1<<2)
 #define   I915_USER_INTERRUPT				(1<<1)
 #define   I915_ASLE_INTERRUPT				(1<<0)
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   I915_BSD_USER_INTERRUPT			(1<<25)
+#endif
+
 #define EIR		0x020b0
 #define EMR		0x020b4
 #define ESR		0x020b8
@@ -436,6 +506,38 @@
 #define   ECO_GATING_CX_ONLY	(1<<3)
 #define   ECO_FLIP_DONE		(1<<0)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* GEN6 interrupt control */
+#define GEN6_RENDER_HWSTAM	0x2098
+#define GEN6_RENDER_IMR		0x20a8
+#define GEN6_RENDER_CONTEXT_SWITCH_INTERRUPT		(1 << 8)
+#define GEN6_RENDER_PPGTT_PAGE_FAULT			(1 << 7)
+#define GEN6_RENDER_TIMEOUT_COUNTER_EXPIRED		(1 << 6)
+#define GEN6_RENDER_L3_PARITY_ERROR			(1 << 5)
+#define GEN6_RENDER_PIPE_CONTROL_NOTIFY_INTERRUPT	(1 << 4)
+#define GEN6_RENDER_COMMAND_PARSER_MASTER_ERROR		(1 << 3)
+#define GEN6_RENDER_SYNC_STATUS				(1 << 2)
+#define GEN6_RENDER_DEBUG_INTERRUPT			(1 << 1)
+#define GEN6_RENDER_USER_INTERRUPT			(1 << 0)
+
+#define GEN6_BLITTER_HWSTAM	0x22098
+#define GEN6_BLITTER_IMR	0x220a8
+#define GEN6_BLITTER_MI_FLUSH_DW_NOTIFY_INTERRUPT	(1 << 26)
+#define GEN6_BLITTER_COMMAND_PARSER_MASTER_ERROR	(1 << 25)
+#define GEN6_BLITTER_SYNC_STATUS			(1 << 24)
+#define GEN6_BLITTER_USER_INTERRUPT			(1 << 22)
+
+#define GEN6_BSD_SLEEP_PSMI_CONTROL	0x12050
+#define GEN6_BSD_SLEEP_PSMI_CONTROL_RC_ILDL_MESSAGE_MODIFY_MASK	(1 << 16)
+#define GEN6_BSD_SLEEP_PSMI_CONTROL_RC_ILDL_MESSAGE_DISABLE	(1 << 0)
+#define GEN6_BSD_SLEEP_PSMI_CONTROL_RC_ILDL_MESSAGE_ENABLE	0
+#define GEN6_BSD_SLEEP_PSMI_CONTROL_IDLE_INDICATOR		(1 << 3)
+
+#define GEN6_BSD_IMR			0x120a8
+#define GEN6_BSD_IMR_USER_INTERRUPT	(1 << 12)
+
+#define GEN6_BSD_RNCID			0x12198
+#endif
 
 /*
  * Framebuffer compression (915+ only)
@@ -499,6 +601,23 @@
 #define DPFC_CHICKEN		0x3224
 #define   DPFC_HT_MODIFY	(1<<31)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* Framebuffer compression for Ironlake */
+#define ILK_DPFC_CB_BASE	0x43200
+#define ILK_DPFC_CONTROL	0x43208
+/* The bit 28-8 is reserved */
+#define   DPFC_RESERVED		(0x1FFFFF00)
+#define ILK_DPFC_RECOMP_CTL	0x4320c
+#define ILK_DPFC_STATUS		0x43210
+#define ILK_DPFC_FENCE_YOFF	0x43218
+#define ILK_DPFC_CHICKEN	0x43224
+#define ILK_FBC_RT_BASE		0x2128
+#define   ILK_FBC_RT_VALID	(1<<0)
+
+#define ILK_DISPLAY_CHICKEN1	0x42000
+#define   ILK_FBCQ_DIS		(1<<22)
+#endif
+
 /*
  * GPIO regs
  */
@@ -532,6 +651,48 @@
 #define GMBUS4			0x5110
 #define GMBUS5			0x5120
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   GMBUS_RATE_100KHZ	(0<<8)
+#define   GMBUS_RATE_50KHZ	(1<<8)
+#define   GMBUS_RATE_400KHZ	(2<<8) /* reserved on Pineview */
+#define   GMBUS_RATE_1MHZ	(3<<8) /* reserved on Pineview */
+#define   GMBUS_HOLD_EXT	(1<<7) /* 300ns hold time, rsvd on Pineview */
+#define   GMBUS_PORT_DISABLED	0
+#define   GMBUS_PORT_SSC	1
+#define   GMBUS_PORT_VGADDC	2
+#define   GMBUS_PORT_PANEL	3
+#define   GMBUS_PORT_DPC	4 /* HDMIC */
+#define   GMBUS_PORT_DPB	5 /* SDVO, HDMIB */
+				  /* 6 reserved */
+#define   GMBUS_PORT_DPD	7 /* HDMID */
+#define   GMBUS_NUM_PORTS       8
+#define   GMBUS_SW_CLR_INT	(1<<31)
+#define   GMBUS_SW_RDY		(1<<30)
+#define   GMBUS_ENT		(1<<29) /* enable timeout */
+#define   GMBUS_CYCLE_NONE	(0<<25)
+#define   GMBUS_CYCLE_WAIT	(1<<25)
+#define   GMBUS_CYCLE_INDEX	(2<<25)
+#define   GMBUS_CYCLE_STOP	(4<<25)
+#define   GMBUS_BYTE_COUNT_SHIFT 16
+#define   GMBUS_SLAVE_INDEX_SHIFT 8
+#define   GMBUS_SLAVE_ADDR_SHIFT 1
+#define   GMBUS_SLAVE_READ	(1<<0)
+#define   GMBUS_SLAVE_WRITE	(0<<0)
+#define   GMBUS_INUSE		(1<<15)
+#define   GMBUS_HW_WAIT_PHASE	(1<<14)
+#define   GMBUS_STALL_TIMEOUT	(1<<13)
+#define   GMBUS_INT		(1<<12)
+#define   GMBUS_HW_RDY		(1<<11)
+#define   GMBUS_SATOER		(1<<10)
+#define   GMBUS_ACTIVE		(1<<9)
+#define   GMBUS_SLAVE_TIMEOUT_EN (1<<4)
+#define   GMBUS_NAK_EN		(1<<3)
+#define   GMBUS_IDLE_EN		(1<<2)
+#define   GMBUS_HW_WAIT_EN	(1<<1)
+#define   GMBUS_HW_RDY_EN	(1<<0)
+#define   GMBUS_2BYTE_INDEX_EN	(1<<31)
+#endif
+
 /*
  * Clock control & power management
  */
@@ -549,6 +710,11 @@
 #define   VGA1_PD_P1_MASK	(0x1f << 8)
 #define DPLL_A	0x06014
 #define DPLL_B	0x06018
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DPLL(pipe) _PIPE(pipe, DPLL_A, DPLL_B)
+#endif
+
 #define   DPLL_VCO_ENABLE		(1 << 31)
 #define   DPLL_DVO_HIGH_SPEED		(1 << 30)
 #define   DPLL_SYNCLOCK_ENABLE		(1 << 29)
@@ -612,13 +778,15 @@
 #define ADPA_DPMS_STANDBY	(2<<10)
 #define ADPA_DPMS_OFF		(3<<10)
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 #define RING_TAIL		0x00
 #define TAIL_ADDR		0x001FFFF8
 #define RING_HEAD		0x04
+#define RING_START		0x08
+#endif
 #define HEAD_WRAP_COUNT		0xFFE00000
 #define HEAD_WRAP_ONE		0x00200000
 #define HEAD_ADDR		0x001FFFFC
-#define RING_START		0x08
 #define START_ADDR		0xFFFFF000
 #define RING_LEN		0x0C
 #define RING_NR_PAGES		0x001FF000
@@ -705,6 +873,13 @@
  * This best be set to the default value (3) or the CRT won't work. No,
  * I don't entirely understand what this does...
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DPLL_MD(pipe) _PIPE(pipe, DPLL_A_MD, DPLL_B_MD)
+#define FP0(pipe) _PIPE(pipe, FPA0, FPB0)
+#define FP1(pipe) _PIPE(pipe, FPA1, FPB1)
+#define DSTATE_GFX_RESET_I830 (1<<6)
+#endif
+
 #define   DPLL_MD_VGA_UDI_MULTIPLIER_MASK	0x0000003f
 #define   DPLL_MD_VGA_UDI_MULTIPLIER_SHIFT	0
 #define DPLL_B_MD 0x06020 /* 965+ only */
@@ -873,6 +1048,19 @@
 #define DCC_CHANNEL_XOR_DISABLE				(1 << 10)
 #define DCC_CHANNEL_XOR_BIT_17				(1 << 9)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/** Pineview MCH register contains DDR3 setting */
+#define CSHRDDR3CTL            0x101a8
+#define CSHRDDR3CTL_DDR3       (1 << 2)
+#define TSC1			0x11001
+#define TSE			(1<<0)
+#define TR1			0x11006
+#define TSFS			0x11020
+#define TSFS_SLOPE_MASK		0x0000ff00
+#define TSFS_SLOPE_SHIFT	8
+#define TSFS_INTR_MASK		0x000000ff
+#endif
+
 /** 965 MCH register controlling DRAM channel configuration */
 #define C0DRB3			0x10206
 #define C1DRB3			0x10606
@@ -1034,6 +1222,52 @@
 #define RCPREVBSYTDNAVG		0x113bc
 #define PEG_BAND_GAP_DATA	0x14d68
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define PMMISC			0x11214
+#define MCPPCE_EN		(1<<0) /* enable PM_MSG from PCH->MPC */
+#define SDEW			0x1124c
+#define CSIEW0			0x11250
+#define CSIEW1			0x11254
+#define CSIEW2			0x11258
+#define PEW			0x1125c
+#define DEW			0x11270
+#define MCHAFE			0x112c0
+#define CSIEC			0x112e0
+#define DMIEC			0x112e4
+#define DDREC			0x112e8
+#define PEG0EC			0x112ec
+#define PEG1EC			0x112f0
+#define GFXEC			0x112f4
+#define RPPREVBSYTUPAVG		0x113b8
+#define RPPREVBSYTDNAVG		0x113bc
+#define ECR			0x11600
+#define ECR_GPFE		(1<<31)
+#define ECR_IMONE		(1<<30)
+#define ECR_CAP_MASK		0x0000001f /* Event range, 0-31 */
+#define OGW0			0x11608
+#define OGW1			0x1160c
+#define EG0			0x11610
+#define EG1			0x11614
+#define EG2			0x11618
+#define EG3			0x1161c
+#define EG4			0x11620
+#define EG5			0x11624
+#define EG6			0x11628
+#define EG7			0x1162c
+#define PXW			0x11664
+#define PXWL			0x11680
+#define LCFUSE02		0x116c0
+#define LCFUSE_HIV_MASK		0x000000ff
+#define CSIPLL0			0x12c10
+#define DDRMPLL1		0X12c20
+
+/*
+ * Logical Context regs
+ */
+#define CCID			0x2180
+#define   CCID_EN		(1<<0)
+#endif
+
 /*
  * Overlay regs
  */
@@ -1072,6 +1306,17 @@
 #define PIPEBSRC	0x6101c
 #define BCLRPAT_B	0x61020
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define HTOTAL(pipe) _PIPE(pipe, HTOTAL_A, HTOTAL_B)
+#define HBLANK(pipe) _PIPE(pipe, HBLANK_A, HBLANK_B)
+#define HSYNC(pipe) _PIPE(pipe, HSYNC_A, HSYNC_B)
+#define VTOTAL(pipe) _PIPE(pipe, VTOTAL_A, VTOTAL_B)
+#define VBLANK(pipe) _PIPE(pipe, VBLANK_A, VBLANK_B)
+#define VSYNC(pipe) _PIPE(pipe, VSYNC_A, VSYNC_B)
+#define PIPESRC(pipe) _PIPE(pipe, PIPEASRC, PIPEBSRC)
+#define BCLRPAT(pipe) _PIPE(pipe, BCLRPAT_A, BCLRPAT_B)
+#endif
+
 /* VGA port control */
 #define ADPA			0x61100
 #define   ADPA_DAC_ENABLE	(1<<31)
@@ -1255,6 +1500,24 @@
 #define   LVDS_B0B3_POWER_DOWN		(0 << 2)
 #define   LVDS_B0B3_POWER_UP		(3 << 2)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* Video Data Island Packet control */
+#define   VIDEO_DIP_DATA		0x61178
+#define   VIDEO_DIP_CTL			0x61170
+#define   VIDEO_DIP_ENABLE		(1 << 31)
+#define   VIDEO_DIP_PORT_B		(1 << 29)
+#define   VIDEO_DIP_PORT_C		(2 << 29)
+#define   VIDEO_DIP_ENABLE_AVI		(1 << 21)
+#define   VIDEO_DIP_ENABLE_VENDOR	(2 << 21)
+#define   VIDEO_DIP_ENABLE_SPD		(8 << 21)
+#define   VIDEO_DIP_SELECT_AVI		(0 << 19)
+#define   VIDEO_DIP_SELECT_VENDOR	(1 << 19)
+#define   VIDEO_DIP_SELECT_SPD		(3 << 19)
+#define   VIDEO_DIP_FREQ_ONCE		(0 << 16)
+#define   VIDEO_DIP_FREQ_VSYNC		(1 << 16)
+#define   VIDEO_DIP_FREQ_2VSYNC		(2 << 16)
+#endif
+
 /* Panel power sequencing */
 #define PP_STATUS	0x61200
 #define   PP_ON		(1 << 31)
@@ -1276,6 +1539,12 @@
 #define PP_OFF_DELAYS	0x6120c
 #define PP_DIVISOR	0x61210
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   PP_CYCLE_DELAY_ACTIVE	(1 << 27)
+#define   PP_SEQUENCE_STATE_ON_IDLE (1 << 3)
+#define   PP_SEQUENCE_STATE_MASK 0x0000000f
+#endif
+
 /* Panel fitting */
 #define PFIT_CONTROL	0x61230
 #define   PFIT_ENABLE		(1 << 31)
@@ -1405,6 +1674,11 @@
 # define TV_TEST_MODE_MASK		(7 << 0)
 
 #define TV_DAC			0x68004
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define TV_DAC_SAVE		0x00ffff00
+#endif
+
 /**
  * Reports that DAC state change logic has reported change (RO).
  *
@@ -1832,6 +2106,16 @@
 #define   DP_LINK_TRAIN_MASK		(3 << 28)
 #define   DP_LINK_TRAIN_SHIFT		28
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* CPT Link training mode */
+#define   DP_LINK_TRAIN_PAT_1_CPT	(0 << 8)
+#define   DP_LINK_TRAIN_PAT_2_CPT	(1 << 8)
+#define   DP_LINK_TRAIN_PAT_IDLE_CPT	(2 << 8)
+#define   DP_LINK_TRAIN_OFF_CPT		(3 << 8)
+#define   DP_LINK_TRAIN_MASK_CPT	(7 << 8)
+#define   DP_LINK_TRAIN_SHIFT_CPT	8
+#endif
+
 /* Signal voltages. These are mostly controlled by the other end */
 #define   DP_VOLTAGE_0_4		(0 << 25)
 #define   DP_VOLTAGE_0_6		(1 << 25)
@@ -1993,6 +2277,28 @@
 
 /* dithering flag on Ironlake */
 #define PIPE_ENABLE_DITHER	(1 << 4)
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   DSL_LINEMASK		0x00000fff
+#define   PIPECONF_ENABLE	(1<<31)
+#define   PIPECONF_DISABLE	0
+#define   PIPECONF_DOUBLE_WIDE	(1<<30)
+#define   PIPECONF_SINGLE_WIDE	0
+#define   PIPECONF_PIPE_UNLOCKED 0
+#define   PIPECONF_PIPE_LOCKED	(1<<25)
+#define   PIPECONF_BPP_MASK	(0x000000e0)
+#define   PIPECONF_BPP_8	(0<<5)
+#define   PIPECONF_BPP_10	(1<<5)
+#define   PIPECONF_BPP_6	(2<<5)
+#define   PIPECONF_BPP_12	(3<<5)
+#define   PIPECONF_DITHER_EN	(1<<4)
+#define   PIPECONF_DITHER_TYPE_MASK (0x0000000c)
+#define   PIPECONF_DITHER_TYPE_SP (0<<2)
+#define   PIPECONF_DITHER_TYPE_ST1 (1<<2)
+#define   PIPECONF_DITHER_TYPE_ST2 (2<<2)
+#define   PIPECONF_DITHER_TYPE_TEMP (3<<2)
+#endif
+
 /* Pipe A */
 #define PIPEADSL		0x70000
 #define PIPEACONF		0x70008
@@ -2046,6 +2352,11 @@
 #define   PIPE_6BPC				(2 << 5)
 #define   PIPE_12BPC				(3 << 5)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define PIPECONF(pipe) _PIPE(pipe, PIPEACONF, PIPEBCONF)
+#define PIPEDSL(pipe)  _PIPE(pipe, PIPEADSL, PIPEBDSL)
+#endif
+
 #define DSPARB			0x70030
 #define   DSPARB_CSTART_MASK	(0x7f << 7)
 #define   DSPARB_CSTART_SHIFT	7
@@ -2066,6 +2377,18 @@
 #define   DSPFW_CURSOR_SR_SHIFT	24
 #define   PINEVIEW_SELF_REFRESH_EN	(1<<30)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define   DSPFW_SR_MASK		(0x1ff<<23)
+#define   DSPFW_CURSORB_MASK	(0x3f<<16)
+#define   DSPFW_PLANEB_MASK	(0x7f<<8)
+#define   DSPFW_PLANEA_MASK	(0x7f)
+#define   DSPFW_PLANEC_MASK	(0x7f)
+#define   DSPFW_CURSOR_SR_MASK		(0x3f<<24)
+#define   DSPFW_HPLL_CURSOR_SHIFT	16
+#define   DSPFW_HPLL_CURSOR_MASK	(0x3f<<16)
+#define   DSPFW_HPLL_SR_MASK		(0x1ff)
+#endif
+
 /* FIFO watermark sizes etc */
 #define G4X_FIFO_LINE_SIZE	64
 #define I915_FIFO_LINE_SIZE	64
@@ -2073,6 +2396,7 @@
 
 #define G4X_FIFO_SIZE		127
 #define I945_FIFO_SIZE		127 /* 945 & 965 */
+#define I965_FIFO_SIZE          512
 #define I915_FIFO_SIZE		95
 #define I855GM_FIFO_SIZE	127 /* In cachelines */
 #define I830_FIFO_SIZE		95
@@ -2091,6 +2415,59 @@
 #define PINEVIEW_CURSOR_DFT_WM	0
 #define PINEVIEW_CURSOR_GUARD_WM	5
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define I965_CURSOR_FIFO	64
+#define I965_CURSOR_MAX_WM	32
+#define I965_CURSOR_DFT_WM	8
+
+/* define the Watermark register on Ironlake */
+#define WM0_PIPEA_ILK		0x45100
+#define  WM0_PIPE_PLANE_MASK	(0x7f<<16)
+#define  WM0_PIPE_PLANE_SHIFT	16
+#define  WM0_PIPE_SPRITE_MASK	(0x3f<<8)
+#define  WM0_PIPE_SPRITE_SHIFT	8
+#define  WM0_PIPE_CURSOR_MASK	(0x1f)
+
+#define WM0_PIPEB_ILK		0x45104
+#define WM1_LP_ILK		0x45108
+#define  WM1_LP_SR_EN		(1<<31)
+#define  WM1_LP_LATENCY_SHIFT	24
+#define  WM1_LP_LATENCY_MASK	(0x7f<<24)
+#define  WM1_LP_FBC_MASK	(0xf<<20)
+#define  WM1_LP_FBC_SHIFT	20
+#define  WM1_LP_SR_MASK		(0x1ff<<8)
+#define  WM1_LP_SR_SHIFT	8
+#define  WM1_LP_CURSOR_MASK	(0x3f)
+#define WM2_LP_ILK		0x4510c
+#define  WM2_LP_EN		(1<<31)
+#define WM3_LP_ILK		0x45110
+#define  WM3_LP_EN		(1<<31)
+#define WM1S_LP_ILK		0x45120
+#define  WM1S_LP_EN		(1<<31)
+
+/* Memory latency timer register */
+#define MLTR_ILK		0x11222
+/* the unit of memory self-refresh latency time is 0.5us */
+#define  ILK_SRLT_MASK		0x3f
+
+/* define the fifo size on Ironlake */
+#define ILK_DISPLAY_FIFO	128
+#define ILK_DISPLAY_MAXWM	64
+#define ILK_DISPLAY_DFTWM	8
+#define ILK_CURSOR_FIFO		32
+#define ILK_CURSOR_MAXWM	16
+#define ILK_CURSOR_DFTWM	8
+
+#define ILK_DISPLAY_SR_FIFO	512
+#define ILK_DISPLAY_MAX_SRWM	0x1ff
+#define ILK_DISPLAY_DFT_SRWM	0x3f
+#define ILK_CURSOR_SR_FIFO	64
+#define ILK_CURSOR_MAX_SRWM	0x3f
+#define ILK_CURSOR_DFT_SRWM	8
+
+#define ILK_FIFO_LINE_SIZE	64
+#endif
+
 /*
  * The two pipe frame counter registers are not synchronized, so
  * reading a stable value is somewhat tricky. The following code
@@ -2184,6 +2561,16 @@
 #define DSPASURF		0x7019C /* 965+ only */
 #define DSPATILEOFF		0x701A4 /* 965+ only */
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DSPCNTR(plane) _PIPE(plane, DSPACNTR, DSPBCNTR)
+#define DSPADDR(plane) _PIPE(plane, DSPAADDR, DSPBADDR)
+#define DSPSTRIDE(plane) _PIPE(plane, DSPASTRIDE, DSPBSTRIDE)
+#define DSPPOS(plane) _PIPE(plane, DSPAPOS, DSPBPOS)
+#define DSPSIZE(plane) _PIPE(plane, DSPASIZE, DSPBSIZE)
+#define DSPSURF(plane) _PIPE(plane, DSPASURF, DSPBSURF)
+#define DSPTILEOFF(plane) _PIPE(plane, DSPATILEOFF, DSPBTILEOFF)
+#endif
+
 /* VBIOS flags */
 #define SWF00			0x71410
 #define SWF01			0x71414
@@ -2254,6 +2641,10 @@
 #define DISPLAY_PORT_PLL_BIOS_1         0x46010
 #define DISPLAY_PORT_PLL_BIOS_2         0x46014
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define  FDI_PLL_FB_CLOCK_MASK  0xff
+#endif
+
 #define PCH_DSPCLK_GATE_D	0x42020
 # define DPFDUNIT_CLOCK_GATE_DISABLE		(1 << 7)
 # define DPARBUNIT_CLOCK_GATE_DISABLE		(1 << 5)
@@ -2290,6 +2681,17 @@
 #define PIPEA_LINK_N2           0x6004c
 #define  PIPEA_LINK_N2_OFFSET   0
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define  PIPE_DATA_M1_OFFSET    0
+#define  PIPE_DATA_N1_OFFSET    0
+#define  PIPE_DATA_M2_OFFSET    0
+#define  PIPE_DATA_N2_OFFSET    0
+#define  PIPE_LINK_M1_OFFSET    0
+#define  PIPE_LINK_N1_OFFSET    0
+#define  PIPE_LINK_M2_OFFSET    0
+#define  PIPE_LINK_N2_OFFSET    0
+#endif
+
 /* PIPEB timing regs are same start from 0x61000 */
 
 #define PIPEB_DATA_M1           0x61030
@@ -2312,6 +2714,17 @@
 #define PIPEB_LINK_N2           0x6104c
 #define  PIPEB_LINK_N2_OFFSET   0
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define PIPE_DATA_M1(pipe) _PIPE(pipe, PIPEA_DATA_M1, PIPEB_DATA_M1)
+#define PIPE_DATA_N1(pipe) _PIPE(pipe, PIPEA_DATA_N1, PIPEB_DATA_N1)
+#define PIPE_DATA_M2(pipe) _PIPE(pipe, PIPEA_DATA_M2, PIPEB_DATA_M2)
+#define PIPE_DATA_N2(pipe) _PIPE(pipe, PIPEA_DATA_N2, PIPEB_DATA_N2)
+#define PIPE_LINK_M1(pipe) _PIPE(pipe, PIPEA_LINK_M1, PIPEB_LINK_M1)
+#define PIPE_LINK_N1(pipe) _PIPE(pipe, PIPEA_LINK_N1, PIPEB_LINK_N1)
+#define PIPE_LINK_M2(pipe) _PIPE(pipe, PIPEA_LINK_M2, PIPEB_LINK_M2)
+#define PIPE_LINK_N2(pipe) _PIPE(pipe, PIPEA_LINK_N2, PIPEB_LINK_N2)
+#endif
+
 /* CPU panel fitter */
 #define PFA_CTL_1               0x68080
 #define PFB_CTL_1               0x68880
@@ -2372,6 +2785,22 @@
 #define GTIIR   0x44018
 #define GTIER   0x4401c
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define GT_BSD_USER_INTERRUPT   (1 << 5)
+#define GT_GEN6_BSD_USER_INTERRUPT	(1 << 12)
+#define GT_BLT_USER_INTERRUPT	(1 << 22)
+#define ILK_DISPLAY_CHICKEN2	0x42004
+#define  ILK_DPARB_GATE	(1<<22)
+#define  ILK_VSDPFD_FULL	(1<<21)
+#define ILK_DSPCLK_GATE		0x42020
+#define  ILK_DPARB_CLK_GATE	(1<<5)
+/* According to spec this bit 7/8/9 of 0x42020 should be set to enable FBC */
+#define   ILK_CLK_FBC		(1<<7)
+#define   ILK_DPFC_DIS1		(1<<8)
+#define   ILK_DPFC_DIS2		(1<<9)
+#define  DISP_FBC_WM_DIS		(1<<15)
+#endif
+
 #define DISP_ARB_CTL	0x45000
 #define  DISP_TILE_SURFACE_SWIZZLING	(1<<13)
 
@@ -2385,6 +2814,18 @@
 #define SDE_SDVOB_HOTPLUG       (1 << 6)
 #define SDE_HOTPLUG_MASK	(0xf << 8)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* CPT */
+#define SDE_CRT_HOTPLUG_CPT	(1 << 19)
+#define SDE_PORTD_HOTPLUG_CPT	(1 << 23)
+#define SDE_PORTC_HOTPLUG_CPT	(1 << 22)
+#define SDE_PORTB_HOTPLUG_CPT	(1 << 21)
+#define SDE_HOTPLUG_MASK_CPT	(SDE_CRT_HOTPLUG_CPT |		\
+				 SDE_PORTD_HOTPLUG_CPT |	\
+				 SDE_PORTC_HOTPLUG_CPT |	\
+				 SDE_PORTB_HOTPLUG_CPT)
+#endif
+
 #define SDEISR  0xc4000
 #define SDEIMR  0xc4004
 #define SDEIIR  0xc4008
@@ -2441,6 +2882,12 @@
 
 #define PCH_DPLL_TEST           0xc606c
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define PCH_DPLL(pipe) _PIPE(pipe, PCH_DPLL_A, PCH_DPLL_B)
+#define PCH_FP0(pipe) _PIPE(pipe, PCH_FPA0, PCH_FPB0)
+#define PCH_FP1(pipe) _PIPE(pipe, PCH_FPA1, PCH_FPB1)
+#endif
+
 #define PCH_DREF_CONTROL        0xC6200
 #define  DREF_CONTROL_MASK      0x7fc3
 #define  DREF_CPU_SOURCE_OUTPUT_DISABLE         (0<<13)
@@ -2475,6 +2922,19 @@
 #define PCH_SSC4_PARMS          0xc6210
 #define PCH_SSC4_AUX_PARMS      0xc6214
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define PCH_DPLL_SEL		0xc7000
+#define  TRANSA_DPLL_ENABLE	(1<<3)
+#define	 TRANSA_DPLLB_SEL	(1<<0)
+#define	 TRANSA_DPLLA_SEL	0
+#define  TRANSB_DPLL_ENABLE	(1<<7)
+#define	 TRANSB_DPLLB_SEL	(1<<4)
+#define	 TRANSB_DPLLA_SEL	(0)
+#define  TRANSC_DPLL_ENABLE	(1<<11)
+#define	 TRANSC_DPLLB_SEL	(1<<8)
+#define	 TRANSC_DPLLA_SEL	(0)
+#endif
+
 /* transcoder */
 
 #define TRANS_HTOTAL_A          0xe0000
@@ -2540,6 +3000,16 @@
 #define  TRANS_6BPC             (2<<5)
 #define  TRANS_12BPC            (3<<5)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define TRANS_HTOTAL(pipe) _PIPE(pipe, TRANS_HTOTAL_A, TRANS_HTOTAL_B)
+#define TRANS_HBLANK(pipe) _PIPE(pipe, TRANS_HBLANK_A, TRANS_HBLANK_B)
+#define TRANS_HSYNC(pipe) _PIPE(pipe, TRANS_HSYNC_A, TRANS_HSYNC_B)
+#define TRANS_VTOTAL(pipe) _PIPE(pipe, TRANS_VTOTAL_A, TRANS_VTOTAL_B)
+#define TRANS_VBLANK(pipe) _PIPE(pipe, TRANS_VBLANK_A, TRANS_VBLANK_B)
+#define TRANS_VSYNC(pipe) _PIPE(pipe, TRANS_VSYNC_A, TRANS_VSYNC_B)
+#define TRANSCONF(plane) _PIPE(plane, TRANSACONF, TRANSBCONF)
+#endif
+
 #define FDI_RXA_CHICKEN         0xc200c
 #define FDI_RXB_CHICKEN         0xc2010
 #define  FDI_RX_PHASE_SYNC_POINTER_ENABLE       (1)
@@ -2548,6 +3018,12 @@
 #define FDI_TXA_CTL             0x60100
 #define FDI_TXB_CTL             0x61100
 #define  FDI_TX_DISABLE         (0<<31)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define FDI_RX_CHICKEN(pipe) _PIPE(pipe, FDI_RXA_CHICKEN, FDI_RXB_CHICKEN)
+#define SOUTH_DSPCLK_GATE_D	0xc2020
+#define  PCH_DPLSUNIT_CLOCK_GATE_DISABLE (1<<29)
+#define FDI_TX_CTL(pipe) _PIPE(pipe, FDI_TXA_CTL, FDI_TXB_CTL)
+#endif
 #define  FDI_TX_ENABLE          (1<<31)
 #define  FDI_LINK_TRAIN_PATTERN_1       (0<<28)
 #define  FDI_LINK_TRAIN_PATTERN_2       (1<<28)
@@ -2561,6 +3037,21 @@
 #define  FDI_LINK_TRAIN_PRE_EMPHASIS_1_5X (1<<22)
 #define  FDI_LINK_TRAIN_PRE_EMPHASIS_2X   (2<<22)
 #define  FDI_LINK_TRAIN_PRE_EMPHASIS_3X   (3<<22)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* ILK always use 400mV 0dB for voltage swing and pre-emphasis level.
+   SNB has different settings. */
+/* SNB A-stepping */
+#define  FDI_LINK_TRAIN_400MV_0DB_SNB_A		(0x38<<22)
+#define  FDI_LINK_TRAIN_400MV_6DB_SNB_A		(0x02<<22)
+#define  FDI_LINK_TRAIN_600MV_3_5DB_SNB_A	(0x01<<22)
+#define  FDI_LINK_TRAIN_800MV_0DB_SNB_A		(0x0<<22)
+/* SNB B-stepping */
+#define  FDI_LINK_TRAIN_400MV_0DB_SNB_B		(0x0<<22)
+#define  FDI_LINK_TRAIN_400MV_6DB_SNB_B		(0x3a<<22)
+#define  FDI_LINK_TRAIN_600MV_3_5DB_SNB_B	(0x39<<22)
+#define  FDI_LINK_TRAIN_800MV_0DB_SNB_B		(0x38<<22)
+#define  FDI_LINK_TRAIN_VOL_EMP_MASK		(0x3f<<22)
+#endif
 #define  FDI_DP_PORT_WIDTH_X1           (0<<19)
 #define  FDI_DP_PORT_WIDTH_X2           (1<<19)
 #define  FDI_DP_PORT_WIDTH_X3           (2<<19)
@@ -2594,6 +3085,18 @@
 #define  FDI_SEL_RAWCLK                 (0<<4)
 #define  FDI_SEL_PCDCLK                 (1<<4)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define FDI_RX_CTL(pipe) _PIPE(pipe, FDI_RXA_CTL, FDI_RXB_CTL)
+#define  FDI_PCDCLK	                (1<<4)
+/* CPT */
+#define  FDI_AUTO_TRAINING			(1<<10)
+#define  FDI_LINK_TRAIN_PATTERN_1_CPT		(0<<8)
+#define  FDI_LINK_TRAIN_PATTERN_2_CPT		(1<<8)
+#define  FDI_LINK_TRAIN_PATTERN_IDLE_CPT	(2<<8)
+#define  FDI_LINK_TRAIN_NORMAL_CPT		(3<<8)
+#define  FDI_LINK_TRAIN_PATTERN_MASK_CPT	(3<<8)
+#endif
+
 #define FDI_RXA_MISC            0xf0010
 #define FDI_RXB_MISC            0xf1010
 #define FDI_RXA_TUSIZE1         0xf0030
@@ -2601,6 +3104,12 @@
 #define FDI_RXB_TUSIZE1         0xf1030
 #define FDI_RXB_TUSIZE2         0xf1038
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define FDI_RX_MISC(pipe) _PIPE(pipe, FDI_RXA_MISC, FDI_RXB_MISC)
+#define FDI_RX_TUSIZE1(pipe) _PIPE(pipe, FDI_RXA_TUSIZE1, FDI_RXB_TUSIZE1)
+#define FDI_RX_TUSIZE2(pipe) _PIPE(pipe, FDI_RXA_TUSIZE2, FDI_RXB_TUSIZE2)
+#endif
+
 /* FDI_RX interrupt register format */
 #define FDI_RX_INTER_LANE_ALIGN         (1<<10)
 #define FDI_RX_SYMBOL_LOCK              (1<<9) /* train 2 */
@@ -2619,6 +3128,11 @@
 #define FDI_RXB_IIR             0xf1014
 #define FDI_RXB_IMR             0xf1018
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define FDI_RX_IIR(pipe) _PIPE(pipe, FDI_RXA_IIR, FDI_RXB_IIR)
+#define FDI_RX_IMR(pipe) _PIPE(pipe, FDI_RXA_IMR, FDI_RXB_IMR)
+#endif
+
 #define FDI_PLL_CTL_1           0xfe000
 #define FDI_PLL_CTL_2           0xfe004
 
@@ -2664,6 +3178,14 @@
 #define  HSYNC_ACTIVE_HIGH      (1 << 3)
 #define  PORT_DETECTED          (1 << 2)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* CPT */
+#define  HDMI_MODE_SELECT	(1 << 9)
+#define  DVI_MODE_SELECT	(0)
+/* PCH SDVOB multiplex with HDMIB */
+#define PCH_SDVOB	HDMIB
+#endif
+
 #define HDMIC   0xe1150
 #define HDMID   0xe1160
 
@@ -2722,4 +3244,46 @@
 #define PCH_DPD_AUX_CH_DATA4	0xe4320
 #define PCH_DPD_AUX_CH_DATA5	0xe4324
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* CPT */
+#define  PORT_TRANS_A_SEL_CPT	0
+#define  PORT_TRANS_B_SEL_CPT	(1<<29)
+#define  PORT_TRANS_C_SEL_CPT	(2<<29)
+#define  PORT_TRANS_SEL_MASK	(3<<29)
+
+#define TRANS_DP_CTL_A		0xe0300
+#define TRANS_DP_CTL_B		0xe1300
+#define TRANS_DP_CTL_C		0xe2300
+#define TRANS_DP_CTL(pipe)	(TRANS_DP_CTL_A + (pipe) * 0x01000)
+#define  TRANS_DP_OUTPUT_ENABLE	(1<<31)
+#define  TRANS_DP_PORT_SEL_B	(0<<29)
+#define  TRANS_DP_PORT_SEL_C	(1<<29)
+#define  TRANS_DP_PORT_SEL_D	(2<<29)
+#define  TRANS_DP_PORT_SEL_MASK	(3<<29)
+#define  TRANS_DP_AUDIO_ONLY	(1<<26)
+#define  TRANS_DP_ENH_FRAMING	(1<<18)
+#define  TRANS_DP_8BPC		(0<<9)
+#define  TRANS_DP_10BPC		(1<<9)
+#define  TRANS_DP_6BPC		(2<<9)
+#define  TRANS_DP_12BPC		(3<<9)
+#define  TRANS_DP_VSYNC_ACTIVE_HIGH	(1<<4)
+#define  TRANS_DP_VSYNC_ACTIVE_LOW	0
+#define  TRANS_DP_HSYNC_ACTIVE_HIGH	(1<<3)
+#define  TRANS_DP_HSYNC_ACTIVE_LOW	0
+#define  TRANS_DP_SYNC_MASK	(3<<3)
+
+/* SNB eDP training params */
+/* SNB A-stepping */
+#define  EDP_LINK_TRAIN_400MV_0DB_SNB_A		(0x38<<22)
+#define  EDP_LINK_TRAIN_400MV_6DB_SNB_A		(0x02<<22)
+#define  EDP_LINK_TRAIN_600MV_3_5DB_SNB_A	(0x01<<22)
+#define  EDP_LINK_TRAIN_800MV_0DB_SNB_A		(0x0<<22)
+/* SNB B-stepping */
+#define  EDP_LINK_TRAIN_400MV_0DB_SNB_B		(0x0<<22)
+#define  EDP_LINK_TRAIN_400MV_6DB_SNB_B		(0x3a<<22)
+#define  EDP_LINK_TRAIN_600MV_3_5DB_SNB_B	(0x39<<22)
+#define  EDP_LINK_TRAIN_800MV_0DB_SNB_B		(0x38<<22)
+#define  EDP_LINK_TRAIN_VOL_EMP_MASK_SNB	(0x3f<<22)
+#endif
+
 #endif /* _I915_REG_H_ */
diff --git a/drivers/gpu/drm/i915/i915_trace.h b/drivers/gpu/drm/i915/i915_trace.h
index 01840d9..e48bcf5 100644
--- a/drivers/gpu/drm/i915/i915_trace.h
+++ b/drivers/gpu/drm/i915/i915_trace.h
@@ -197,7 +197,6 @@ TRACE_EVENT(i915_gem_request_flush,
 		      __entry->flush_domains, __entry->invalidate_domains)
 );
 
-
 TRACE_EVENT(i915_gem_request_complete,
 
 	    TP_PROTO(struct drm_device *dev, u32 seqno),
@@ -310,6 +309,44 @@ TRACE_EVENT(i915_ring_wait_end,
 
 #endif /* _I915_TRACE_H_ */
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+TRACE_EVENT(i915_flip_request,
+	    TP_PROTO(int plane, struct drm_gem_object *obj),
+
+	    TP_ARGS(plane, obj),
+
+	    TP_STRUCT__entry(
+		    __field(int, plane)
+		    __field(struct drm_gem_object *, obj)
+		    ),
+
+	    TP_fast_assign(
+		    __entry->plane = plane;
+		    __entry->obj = obj;
+		    ),
+
+	    TP_printk("plane=%d, obj=%p", __entry->plane, __entry->obj)
+);
+
+TRACE_EVENT(i915_flip_complete,
+	    TP_PROTO(int plane, struct drm_gem_object *obj),
+
+	    TP_ARGS(plane, obj),
+
+	    TP_STRUCT__entry(
+		    __field(int, plane)
+		    __field(struct drm_gem_object *, obj)
+		    ),
+
+	    TP_fast_assign(
+		    __entry->plane = plane;
+		    __entry->obj = obj;
+		    ),
+
+	    TP_printk("plane=%d, obj=%p", __entry->plane, __entry->obj)
+);
+#endif
+
 /* This part must be outside protection */
 #undef TRACE_INCLUDE_PATH
 #define TRACE_INCLUDE_PATH ../../drivers/gpu/drm/i915
diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c
index f9ba452..42bf18c 100644
--- a/drivers/gpu/drm/i915/intel_bios.c
+++ b/drivers/gpu/drm/i915/intel_bios.c
@@ -29,6 +29,9 @@
 #include "i915_drm.h"
 #include "i915_drv.h"
 #include "intel_bios.h"
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#include <drm/drm_dp_helper.h>
+#endif
 
 #define	SLAVE_ADDR1	0x70
 #define	SLAVE_ADDR2	0x72
@@ -279,6 +282,7 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 			  struct bdb_header *bdb)
 {
 	struct bdb_general_definitions *general;
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	const int crt_bus_map_table[] = {
 		GPIOB,
 		GPIOA,
@@ -287,6 +291,7 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 		GPIOE,
 		GPIOF,
 	};
+#endif
 
 	general = find_section(bdb, BDB_GENERAL_DEFINITIONS);
 	if (general) {
@@ -295,8 +300,12 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 			int bus_pin = general->crt_ddc_gmbus_pin;
 			DRM_DEBUG_KMS("crt_ddc_bus_pin: %d\n", bus_pin);
 			if ((bus_pin >= 1) && (bus_pin <= 6)) {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+				dev_priv->crt_ddc_bus = bus_pin;
+#else
 				dev_priv->crt_ddc_bus =
 					crt_bus_map_table[bus_pin-1];
+#endif
 			}
 		} else {
 			DRM_DEBUG_KMS("BDB_GD too small (%d). Invalid.\n",
@@ -561,3 +570,116 @@ intel_init_bios(struct drm_device *dev)
 
 	return 0;
 }
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static void
+init_vbt_defaults(struct drm_i915_private *dev_priv)
+{
+	dev_priv->crt_ddc_bus = GMBUS_PORT_VGADDC;
+
+	/* LFP panel data */
+	dev_priv->lvds_dither = 1;
+	dev_priv->lvds_vbt = 0;
+
+	/* SDVO panel data */
+	dev_priv->sdvo_lvds_vbt_mode = NULL;
+
+	/* general features */
+	dev_priv->int_tv_support = 1;
+	dev_priv->int_crt_support = 1;
+	dev_priv->lvds_use_ssc = 0;
+
+	/* eDP data */
+	dev_priv->edp.bpp = 18;
+}
+
+/**
+ * intel_parse_bios - find VBT and initialize settings from the BIOS
+ * @dev: DRM device
+ *
+ * Loads the Video BIOS and checks that the VBT exists.  Sets scratch registers
+ * to appropriate values.
+ *
+ * Returns 0 on success, nonzero on failure.
+ */
+bool
+intel_parse_bios(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct pci_dev *pdev = dev->pdev;
+	struct bdb_header *bdb = NULL;
+	u8 __iomem *bios = NULL;
+
+	init_vbt_defaults(dev_priv);
+
+	/* XXX Should this validation be moved to intel_opregion.c? */
+	if (dev_priv->opregion.vbt) {
+		struct vbt_header *vbt = dev_priv->opregion.vbt;
+		if (memcmp(vbt->signature, "$VBT", 4) == 0) {
+			DRM_DEBUG_DRIVER("Using VBT from OpRegion: %20s\n",
+					 vbt->signature);
+			bdb = (struct bdb_header *)((char *)vbt +
+							vbt->bdb_offset);
+		} else
+			dev_priv->opregion.vbt = NULL;
+	}
+
+	if (bdb == NULL) {
+		struct vbt_header *vbt = NULL;
+		size_t size;
+		int i;
+
+		bios = pci_map_rom(pdev, &size);
+		if (!bios)
+			return -1;
+
+		/* Scour memory looking for the VBT signature */
+		for (i = 0; i + 4 < size; i++) {
+			if (!memcmp(bios + i, "$VBT", 4)) {
+				vbt = (struct vbt_header *)(bios + i);
+				break;
+			}
+		}
+
+		if (!vbt) {
+			DRM_ERROR("VBT signature missing\n");
+			pci_unmap_rom(pdev, bios);
+			return -1;
+		}
+
+		bdb = (struct bdb_header *)(bios + i + vbt->bdb_offset);
+	}
+
+	/* Grab useful general definitions */
+	parse_general_features(dev_priv, bdb);
+	parse_general_definitions(dev_priv, bdb);
+	parse_lfp_panel_data(dev_priv, bdb);
+	parse_sdvo_panel_data(dev_priv, bdb);
+	parse_sdvo_device_mapping(dev_priv, bdb);
+	parse_device_mapping(dev_priv, bdb);
+	parse_driver_features(dev_priv, bdb);
+	parse_edp(dev_priv, bdb);
+
+	if (bios)
+		pci_unmap_rom(pdev, bios);
+
+	return 0;
+}
+
+/* Ensure that vital registers have been initialised, even if the BIOS
+ * is absent or just failing to do its job.
+ */
+void intel_setup_bios(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	 /* Set the Panel Power On/Off timings if uninitialized. */
+	if ((I915_READ(PP_ON_DELAYS) == 0) && (I915_READ(PP_OFF_DELAYS) == 0)) {
+		/* Set T2 to 40ms and T5 to 200ms */
+		I915_WRITE(PP_ON_DELAYS, 0x019007d0);
+
+		/* Set T3 to 35ms and Tx to 200ms */
+		I915_WRITE(PP_OFF_DELAYS, 0x015e07d0);
+	}
+}
+#endif
diff --git a/drivers/gpu/drm/i915/intel_bios.h b/drivers/gpu/drm/i915/intel_bios.h
index 4c18514..567921d 100644
--- a/drivers/gpu/drm/i915/intel_bios.h
+++ b/drivers/gpu/drm/i915/intel_bios.h
@@ -198,6 +198,8 @@ struct child_device_config {
 	u16 handle;
 	u16 device_type;
 	u8  device_id[10]; /* See DEVICE_TYPE_* above */
+	u8  i2c_speed;
+	u8  rsvd[9];
 	u16 addin_offset;
 	u8  dvo_port; /* See Device_PORT_* above */
 	u8  i2c_pin;
@@ -467,6 +469,8 @@ struct bdb_edp {
 } __attribute__ ((packed));
 
 bool intel_init_bios(struct drm_device *dev);
+void intel_setup_bios(struct drm_device *dev);
+bool intel_parse_bios(struct drm_device *dev);
 
 /*
  * Driver<->VBIOS interaction occurs through scratch bits in
diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c
index 759c2ef..d7b319c 100644
--- a/drivers/gpu/drm/i915/intel_crt.c
+++ b/drivers/gpu/drm/i915/intel_crt.c
@@ -245,6 +245,44 @@ static bool intel_crt_detect_hotplug(struct drm_connector *connector)
 	return false;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static bool intel_crt_ddc_probe(struct drm_i915_private *dev_priv, int ddc_bus)
+{
+	u8 buf;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = 0xA0,
+			.flags = 0,
+			.len = 1,
+			.buf = &buf,
+		},
+	};
+	/* DDC monitor detect: Does it ACK a write to 0xA0? */
+	return i2c_transfer(&dev_priv->gmbus[ddc_bus].adapter, msgs, 1) == 1;
+}
+
+static bool intel_crt_detect_ddc(struct drm_encoder *encoder)
+{
+	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
+	struct drm_i915_private *dev_priv = encoder->dev->dev_private;
+
+	/* CRT should always be at 0, but check anyway */
+	if (intel_encoder->type != INTEL_OUTPUT_ANALOG)
+		return false;
+
+	if (intel_crt_ddc_probe(dev_priv, dev_priv->crt_ddc_bus)) {
+		DRM_DEBUG_KMS("CRT detected via DDC:0xa0\n");
+		return true;
+	}
+
+	if (intel_ddc_probe(intel_encoder, dev_priv->crt_ddc_bus)) {
+		DRM_DEBUG_KMS("CRT detected via DDC:0x50 [EDID]\n");
+		return true;
+	}
+
+	return false;
+}
+#else
 static bool intel_crt_detect_ddc(struct drm_connector *connector)
 {
 	struct intel_encoder *intel_encoder = to_intel_encoder(connector);
@@ -255,11 +293,16 @@ static bool intel_crt_detect_ddc(struct drm_connector *connector)
 
 	return intel_ddc_probe(intel_encoder);
 }
+#endif
 
 static enum drm_connector_status
 intel_crt_load_detect(struct drm_crtc *crtc, struct intel_encoder *intel_encoder)
 {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_encoder *encoder = &intel_encoder->base;
+#else
 	struct drm_encoder *encoder = &intel_encoder->enc;
+#endif
 	struct drm_device *dev = encoder->dev;
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
@@ -313,7 +356,11 @@ intel_crt_load_detect(struct drm_crtc *crtc, struct intel_encoder *intel_encoder
 		I915_WRITE(pipeconf_reg, pipeconf | PIPECONF_FORCE_BORDER);
 		/* Wait for next Vblank to substitue
 		 * border color for Color info */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+		intel_wait_for_vblank(dev, pipe);
+#else
 		intel_wait_for_vblank(dev);
+#endif
 		st00 = I915_READ8(VGA_MSR_WRITE);
 		status = ((st00 & (1 << 4)) != 0) ?
 			connector_status_connected :
@@ -384,6 +431,50 @@ intel_crt_load_detect(struct drm_crtc *crtc, struct intel_encoder *intel_encoder
 	return status;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static enum drm_connector_status
+intel_crt_detect(struct drm_connector *connector, bool force)
+{
+	struct drm_device *dev = connector->dev;
+	struct intel_encoder *encoder = intel_attached_encoder(connector);
+	struct drm_crtc *crtc;
+	int dpms_mode;
+	enum drm_connector_status status;
+
+	if (I915_HAS_HOTPLUG(dev)) {
+		if (intel_crt_detect_hotplug(connector)) {
+			DRM_DEBUG_KMS("CRT detected via hotplug\n");
+			return connector_status_connected;
+		} else
+			return connector_status_disconnected;
+	}
+
+	if (intel_crt_detect_ddc(&encoder->base))
+		return connector_status_connected;
+
+	if (!force)
+		return connector->status;
+
+	/* for pre-945g platforms use load detect */
+	if (encoder->base.crtc && encoder->base.crtc->enabled) {
+		status = intel_crt_load_detect(encoder->base.crtc, encoder);
+	} else {
+		crtc = intel_get_load_detect_pipe(encoder, connector,
+						  NULL, &dpms_mode);
+		if (crtc) {
+			if (intel_crt_detect_ddc(&encoder->base))
+				status = connector_status_connected;
+			else
+				status = intel_crt_load_detect(crtc, encoder);
+			intel_release_load_detect_pipe(encoder,
+						       connector, dpms_mode);
+		} else
+			status = connector_status_unknown;
+	}
+
+	return status;
+}
+#else
 static enum drm_connector_status intel_crt_detect(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
@@ -418,6 +509,7 @@ static enum drm_connector_status intel_crt_detect(struct drm_connector *connecto
 
 	return status;
 }
+#endif
 
 static void intel_crt_destroy(struct drm_connector *connector)
 {
@@ -431,6 +523,20 @@ static void intel_crt_destroy(struct drm_connector *connector)
 
 static int intel_crt_get_modes(struct drm_connector *connector)
 {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_device *dev = connector->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
+
+	ret = intel_ddc_get_modes(connector,
+			&dev_priv->gmbus[dev_priv->crt_ddc_bus].adapter);
+	if (ret || !IS_G4X(dev))
+		return ret;
+
+	/* Try to probe digital port for output in DVI-I -> VGA mode. */
+	return intel_ddc_get_modes(connector,
+				   &dev_priv->gmbus[GMBUS_PORT_DPB].adapter);
+#else
 	int ret;
 	struct intel_encoder *intel_encoder = to_intel_encoder(connector);
 	struct i2c_adapter *ddcbus;
@@ -458,6 +564,7 @@ static int intel_crt_get_modes(struct drm_connector *connector)
 
 end:
 	return ret;
+#endif
 
 }
 
@@ -508,12 +615,32 @@ void intel_crt_init(struct drm_device *dev)
 	struct drm_connector *connector;
 	struct intel_encoder *intel_encoder;
 	struct drm_i915_private *dev_priv = dev->dev_private;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct intel_connector *intel_connector;
+#else
 	u32 i2c_reg;
+#endif
 
 	intel_encoder = kzalloc(sizeof(struct intel_encoder), GFP_KERNEL);
 	if (!intel_encoder)
 		return;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	intel_connector = kzalloc(sizeof(struct intel_connector), GFP_KERNEL);
+	if (!intel_connector) {
+		kfree(intel_encoder);
+		return;
+	}
+
+	connector = &intel_connector->base;
+	drm_connector_init(dev, &intel_connector->base,
+			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);
+
+	drm_encoder_init(dev, &intel_encoder->base, &intel_crt_enc_funcs,
+			 DRM_MODE_ENCODER_DAC);
+
+	intel_connector_attach_encoder(intel_connector, intel_encoder);
+#else
 	connector = &intel_encoder->base;
 	drm_connector_init(dev, &intel_encoder->base,
 			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);
@@ -539,6 +666,7 @@ void intel_crt_init(struct drm_device *dev)
 			   "failed.\n");
 		return;
 	}
+#endif
 
 	intel_encoder->type = INTEL_OUTPUT_ANALOG;
 	intel_encoder->clone_mask = (1 << INTEL_SDVO_NON_TV_CLONE_BIT) |
@@ -548,7 +676,11 @@ void intel_crt_init(struct drm_device *dev)
 	connector->interlace_allowed = 0;
 	connector->doublescan_allowed = 0;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	drm_encoder_helper_add(&intel_encoder->base, &intel_crt_helper_funcs);
+#else
 	drm_encoder_helper_add(&intel_encoder->enc, &intel_crt_helper_funcs);
+#endif
 	drm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);
 
 	drm_sysfs_connector_add(connector);
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 4e9f24a..1a2260b 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -32,6 +32,38 @@
 #include "drm_crtc.h"
 
 #include "drm_crtc_helper.h"
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#include "drm_fb_helper.h"
+
+#define _wait_for(COND, MS, W) ({ \
+	unsigned long timeout__ = jiffies + msecs_to_jiffies(MS);	\
+	int ret__ = 0;							\
+	while (!(COND)) {						\
+		if (time_after(jiffies, timeout__)) {			\
+			ret__ = -ETIMEDOUT;				\
+			break;						\
+		}							\
+		if (W && !in_dbg_master())				\
+			msleep(W);					\
+	}								\
+	ret__;								\
+})
+
+#define wait_for(COND, MS) _wait_for(COND, MS, 1)
+#define wait_for_atomic(COND, MS) _wait_for(COND, MS, 0)
+
+#define MSLEEP(x) do { \
+	if (in_dbg_master()) \
+		mdelay(x); \
+	else \
+		msleep(x); \
+} while (0)
+
+#define KHz(x) (1000*x)
+#define MHz(x) KHz(1000*x)
+#endif
+
 /*
  * Display related stuff
  */
@@ -82,6 +114,28 @@
 #define INTEL_DVO_CHIP_TMDS 2
 #define INTEL_DVO_CHIP_TVOUT 4
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/* drm_display_mode->private_flags */
+#define INTEL_MODE_PIXEL_MULTIPLIER_SHIFT (0x0)
+#define INTEL_MODE_PIXEL_MULTIPLIER_MASK \
+	(0xf << INTEL_MODE_PIXEL_MULTIPLIER_SHIFT)
+
+static inline void
+intel_mode_set_pixel_multiplier(struct drm_display_mode *mode,
+				int multiplier)
+{
+	mode->clock *= multiplier;
+	mode->private_flags |= multiplier;
+}
+
+static inline int
+intel_mode_get_pixel_multiplier(const struct drm_display_mode *mode)
+{
+	return (mode->private_flags & INTEL_MODE_PIXEL_MULTIPLIER_MASK) >>
+		INTEL_MODE_PIXEL_MULTIPLIER_SHIFT;
+}
+#endif
+
 struct intel_i2c_chan {
 	struct drm_device *drm_dev; /* for getting at dev. private (mmio etc.) */
 	u32 reg; /* GPIO reg */
@@ -94,9 +148,21 @@ struct intel_framebuffer {
 	struct drm_gem_object *obj;
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+struct intel_fbdev {
+	struct drm_fb_helper helper;
+	struct intel_framebuffer ifb;
+	struct list_head fbdev_list;
+	struct drm_display_mode *our_mode;
+};
+#endif
 
 struct intel_encoder {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_encoder base;
+#else
 	struct drm_connector base;
+#endif
 
 	struct drm_encoder enc;
 	int type;
@@ -110,7 +176,15 @@ struct intel_encoder {
 	int clone_mask;
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+struct intel_connector {
+	struct drm_connector base;
+	struct intel_encoder *encoder;
+};
+#endif
+
 struct intel_crtc;
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 struct intel_overlay {
 	struct drm_device *dev;
 	struct intel_crtc *crtc;
@@ -135,6 +209,7 @@ struct intel_overlay {
 #define SWITCH_OFF_STAGE_1	4
 #define SWITCH_OFF_STAGE_2	5
 };
+#endif
 
 struct intel_crtc {
 	struct drm_crtc base;
@@ -153,19 +228,106 @@ struct intel_crtc {
 	int16_t cursor_x, cursor_y;
 	int16_t cursor_width, cursor_height;
 	bool cursor_visble;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	int fdi_lanes;
+	bool active; /* is the crtc on? independent of the dpms mode */
+	bool cursor_visible;
+#endif
 };
 
 #define to_intel_crtc(x) container_of(x, struct intel_crtc, base)
 #define to_intel_encoder(x) container_of(x, struct intel_encoder, base)
 #define enc_to_intel_encoder(x) container_of(x, struct intel_encoder, enc)
 #define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define to_intel_connector(x) container_of(x, struct intel_connector, base)
+#define DIP_TYPE_AVI    0x82
+#define DIP_VERSION_AVI 0x2
+#define DIP_LEN_AVI     13
+
+struct dip_infoframe {
+	uint8_t type;		/* HB0 */
+	uint8_t ver;		/* HB1 */
+	uint8_t len;		/* HB2 - body len, not including checksum */
+	uint8_t ecc;		/* Header ECC */
+	uint8_t checksum;	/* PB0 */
+	union {
+		struct {
+			/* PB1 - Y 6:5, A 4:4, B 3:2, S 1:0 */
+			uint8_t Y_A_B_S;
+			/* PB2 - C 7:6, M 5:4, R 3:0 */
+			uint8_t C_M_R;
+			/* PB3 - ITC 7:7, EC 6:4, Q 3:2, SC 1:0 */
+			uint8_t ITC_EC_Q_SC;
+			/* PB4 - VIC 6:0 */
+			uint8_t VIC;
+			/* PB5 - PR 3:0 */
+			uint8_t PR;
+			/* PB6 to PB13 */
+			uint16_t top_bar_end;
+			uint16_t bottom_bar_start;
+			uint16_t left_bar_end;
+			uint16_t right_bar_start;
+		} avi;
+		uint8_t payload[27];
+	} __attribute__ ((packed)) body;
+} __attribute__((packed));
+
+static inline struct drm_crtc *
+intel_get_crtc_for_pipe(struct drm_device *dev, int pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	return dev_priv->pipe_to_crtc_mapping[pipe];
+}
+
+struct intel_unpin_work {
+	struct work_struct work;
+	struct drm_device *dev;
+	struct drm_gem_object *old_fb_obj;
+	struct drm_gem_object *pending_flip_obj;
+	struct drm_pending_vblank_event *event;
+	int pending;
+	bool enable_stall_check;
+};
+#endif
 
 struct i2c_adapter *intel_i2c_create(struct drm_device *dev, const u32 reg,
 				     const char *name);
 void intel_i2c_destroy(struct i2c_adapter *adapter);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int intel_ddc_get_modes(struct drm_connector *c, struct i2c_adapter *adapter);
+extern bool intel_ddc_probe(struct intel_encoder *intel_encoder, int ddc_bus);
+void intel_dip_infoframe_csum(struct dip_infoframe *avi_if);
+extern bool intel_dpd_is_edp(struct drm_device *dev);
+extern bool intel_encoder_is_pch_edp(struct drm_encoder *encoder);
+extern void intel_fixed_panel_mode(struct drm_display_mode *fixed_mode,
+				   struct drm_display_mode *adjusted_mode);
+extern void intel_pch_panel_fitting(struct drm_device *dev,
+				    int fitting_mode,
+				    struct drm_display_mode *mode,
+				    struct drm_display_mode *adjusted_mode);
+extern u32 intel_panel_get_max_backlight(struct drm_device *dev);
+extern u32 intel_panel_get_backlight(struct drm_device *dev);
+extern void intel_panel_set_backlight(struct drm_device *dev, u32 level);
+extern void intel_encoder_destroy(struct drm_encoder *encoder);
+
+static inline struct intel_encoder
+*intel_attached_encoder(struct drm_connector *connector)
+{
+	return to_intel_connector(connector)->encoder;
+}
+
+extern void intel_connector_attach_encoder(struct intel_connector *connector,
+					   struct intel_encoder *encoder);
+extern void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
+#else
 int intel_ddc_get_modes(struct intel_encoder *intel_encoder);
 extern bool intel_ddc_probe(struct intel_encoder *intel_encoder);
+#endif
+
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 void intel_i2c_quirk_set(struct drm_device *dev, bool enable);
+#endif
 void intel_i2c_reset_gmbus(struct drm_device *dev);
 
 extern void intel_crt_init(struct drm_device *dev);
@@ -181,8 +343,9 @@ intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,
 		 struct drm_display_mode *adjusted_mode);
 extern void intel_edp_link_config (struct intel_encoder *, int *, int *);
 
-
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 extern int intel_panel_fitter_pipe (struct drm_device *dev);
+#endif
 extern void intel_crtc_load_lut(struct drm_crtc *crtc);
 extern void intel_encoder_prepare (struct drm_encoder *encoder);
 extern void intel_encoder_commit (struct drm_encoder *encoder);
@@ -193,6 +356,18 @@ extern struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
 						    struct drm_crtc *crtc);
 int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern void intel_wait_for_vblank(struct drm_device *dev, int pipe);
+extern void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
+extern struct drm_crtc
+*intel_get_load_detect_pipe(struct intel_encoder *intel_encoder,
+			    struct drm_connector *connector,
+			    struct drm_display_mode *mode,
+			    int *dpms_mode);
+extern void intel_release_load_detect_pipe(struct intel_encoder *intel_encoder,
+					   struct drm_connector *connector,
+					   int dpms_mode);
+#else
 extern void intel_wait_for_vblank(struct drm_device *dev);
 extern struct drm_crtc *intel_get_crtc_from_pipe(struct drm_device *dev, int pipe);
 extern struct drm_crtc *intel_get_load_detect_pipe(struct intel_encoder *intel_encoder,
@@ -200,6 +375,7 @@ extern struct drm_crtc *intel_get_load_detect_pipe(struct intel_encoder *intel_e
 						   int *dpms_mode);
 extern void intel_release_load_detect_pipe(struct intel_encoder *intel_encoder,
 					   int dpms_mode);
+#endif
 
 extern struct drm_connector* intel_sdvo_find(struct drm_device *dev, int sdvoB);
 extern int intel_sdvo_supports_hotplug(struct drm_connector *connector);
@@ -216,6 +392,20 @@ extern void intel_init_clock_gating(struct drm_device *dev);
 extern void ironlake_enable_drps(struct drm_device *dev);
 extern void ironlake_disable_drps(struct drm_device *dev);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern void intel_init_emon(struct drm_device *dev);
+
+extern int intel_pin_and_fence_fb_obj(struct drm_device *dev,
+				      struct drm_gem_object *obj,
+				      bool pipelined);
+
+extern int intel_framebuffer_init(struct drm_device *dev,
+				  struct intel_framebuffer *ifb,
+				  struct drm_mode_fb_cmd *mode_cmd,
+				  struct drm_gem_object *obj);
+extern int intel_fbdev_init(struct drm_device *dev);
+extern void intel_fbdev_fini(struct drm_device *dev);
+#endif
 extern int intel_framebuffer_create(struct drm_device *dev,
 				    struct drm_mode_fb_cmd *mode_cmd,
 				    struct drm_framebuffer **fb,
@@ -227,9 +417,15 @@ extern void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 
 extern void intel_setup_overlay(struct drm_device *dev);
 extern void intel_cleanup_overlay(struct drm_device *dev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+extern int intel_overlay_switch_off(struct intel_overlay *overlay,
+				    bool interruptible);
+extern void intel_fb_output_poll_changed(struct drm_device *dev);
+#else
 extern int intel_overlay_switch_off(struct intel_overlay *overlay);
 extern int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay,
 						int interruptible);
+#endif
 extern int intel_overlay_put_image(struct drm_device *dev, void *data,
 				   struct drm_file *file_priv);
 extern int intel_overlay_attrs(struct drm_device *dev, void *data,
diff --git a/drivers/gpu/drm/i915/intel_fb.c b/drivers/gpu/drm/i915/intel_fb.c
index 8a0b3bc..778eba8 100644
--- a/drivers/gpu/drm/i915/intel_fb.c
+++ b/drivers/gpu/drm/i915/intel_fb.c
@@ -54,7 +54,9 @@ static struct fb_ops intelfb_ops = {
 	.owner = THIS_MODULE,
 	.fb_check_var = drm_fb_helper_check_var,
 	.fb_set_par = drm_fb_helper_set_par,
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	.fb_setcolreg = drm_fb_helper_setcolreg,
+#endif
 	.fb_fillrect = cfb_fillrect,
 	.fb_copyarea = cfb_copyarea,
 	.fb_imageblit = cfb_imageblit,
@@ -63,9 +65,17 @@ static struct fb_ops intelfb_ops = {
 	.fb_setcmap = drm_fb_helper_setcmap,
 };
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static int intel_fb_find_or_create_single(struct drm_fb_helper *helper,
+				struct drm_fb_helper_surface_size *sizes);
+#endif
+
 static struct drm_fb_helper_funcs intel_fb_helper_funcs = {
 	.gamma_set = intel_crtc_fb_gamma_set,
 	.gamma_get = intel_crtc_fb_gamma_get,
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	.fb_probe = intel_fb_find_or_create_single,
+#endif
 };
 
 
@@ -76,6 +86,7 @@ static struct drm_fb_helper_funcs intel_fb_helper_funcs = {
  * caller should hold the mode config lock.
  *
  */
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 int intelfb_resize(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct fb_info *info;
@@ -108,7 +119,213 @@ int intelfb_resize(struct drm_device *dev, struct drm_crtc *crtc)
 	return 0;
 }
 EXPORT_SYMBOL(intelfb_resize);
+#endif
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static int intelfb_create(struct intel_fbdev *ifbdev,
+			  struct drm_fb_helper_surface_size *sizes)
+{
+	struct drm_device *dev = ifbdev->helper.dev;
+	struct fb_info *info;
+	struct drm_framebuffer *fb;
+	struct drm_mode_fb_cmd mode_cmd;
+	struct drm_gem_object *fbo = NULL;
+	struct drm_i915_gem_object *obj_priv;
+	struct device *device = &dev->pdev->dev;
+	int size, ret, mmio_bar = IS_GEN2(dev) ? 1 : 0;
 
+	/* we don't do packed 24bpp */
+	if (sizes->surface_bpp == 24)
+		sizes->surface_bpp = 32;
+
+	mode_cmd.width = sizes->surface_width;
+	mode_cmd.height = sizes->surface_height;
+
+	mode_cmd.bpp = sizes->surface_bpp;
+	mode_cmd.pitch = ALIGN(mode_cmd.width * ((mode_cmd.bpp + 1) / 8), 64);
+	mode_cmd.depth = sizes->surface_depth;
+
+	size = mode_cmd.pitch * mode_cmd.height;
+	size = ALIGN(size, PAGE_SIZE);
+	fbo = i915_gem_alloc_object(dev, size);
+	if (!fbo) {
+		DRM_ERROR("failed to allocate framebuffer\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	obj_priv = to_intel_bo(fbo);
+
+	mutex_lock(&dev->struct_mutex);
+
+	/* Flush everything out, we'll be doing GTT only from now on */
+	ret = intel_pin_and_fence_fb_obj(dev, fbo, false);
+	if (ret) {
+		DRM_ERROR("failed to pin fb: %d\n", ret);
+		goto out_unref;
+	}
+
+	info = framebuffer_alloc(0, device);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out_unpin;
+	}
+
+	info->par = ifbdev;
+
+	ret = intel_framebuffer_init(dev, &ifbdev->ifb, &mode_cmd, fbo);
+	if (ret)
+		goto out_unpin;
+
+	fb = &ifbdev->ifb.base;
+
+	ifbdev->helper.fb = fb;
+	ifbdev->helper.fbdev = info;
+
+	strcpy(info->fix.id, "inteldrmfb");
+
+	info->flags = FBINFO_DEFAULT;
+	info->fbops = &intelfb_ops;
+
+	/* setup aperture base/size for vesafb takeover */
+	info->aperture_base = dev->mode_config.fb_base;
+	if (!IS_GEN2(dev))
+		info->aperture_size = drm_get_resource_len(dev, 2);
+	else
+		info->aperture_size = drm_get_resource_len(dev, 0);
+
+	info->fix.smem_start = dev->mode_config.fb_base + obj_priv->gtt_offset;
+	info->fix.smem_len = size;
+
+	info->screen_base = ioremap_wc(dev->agp->base + obj_priv->gtt_offset,
+				       size);
+	if (!info->screen_base) {
+		ret = -ENOSPC;
+		goto out_unpin;
+	}
+
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto out_unpin;
+	}
+	info->screen_size = size;
+
+	drm_fb_helper_fill_fix(info, fb->pitch, fb->depth);
+	drm_fb_helper_fill_var(info, &ifbdev->helper,
+			       sizes->fb_width, sizes->fb_height);
+
+	/* FIXME: we really shouldn't expose mmio space at all */
+	info->fix.mmio_start = drm_get_resource_start(dev, mmio_bar);
+	info->fix.mmio_len = drm_get_resource_len(dev, mmio_bar);
+
+	info->pixmap.size = 64*1024;
+	info->pixmap.buf_align = 8;
+	info->pixmap.access_align = 32;
+	info->pixmap.flags = FB_PIXMAP_SYSTEM;
+	info->pixmap.scan_align = 1;
+
+	DRM_DEBUG_KMS("allocated %dx%d fb: 0x%08x, bo %p\n",
+		      fb->width, fb->height,
+		      obj_priv->gtt_offset, fbo);
+
+
+	mutex_unlock(&dev->struct_mutex);
+	vga_switcheroo_client_fb_set(dev->pdev, info);
+	return 0;
+
+out_unpin:
+	i915_gem_object_unpin(fbo);
+out_unref:
+	drm_gem_object_unreference(fbo);
+	mutex_unlock(&dev->struct_mutex);
+out:
+	return ret;
+}
+
+static int intel_fb_find_or_create_single(struct drm_fb_helper *helper,
+				struct drm_fb_helper_surface_size *sizes)
+{
+	struct intel_fbdev *ifbdev = (struct intel_fbdev *)helper;
+	int new_fb = 0;
+	int ret;
+
+	if (!helper->fb) {
+		ret = intelfb_create(ifbdev, sizes);
+		if (ret)
+			return ret;
+		new_fb = 1;
+	}
+	return new_fb;
+}
+
+static void intel_fbdev_destroy(struct drm_device *dev,
+				struct intel_fbdev *ifbdev)
+{
+	struct fb_info *info;
+	struct intel_framebuffer *ifb = &ifbdev->ifb;
+
+	if (ifbdev->helper.fbdev) {
+		info = ifbdev->helper.fbdev;
+		unregister_framebuffer(info);
+		iounmap(info->screen_base);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+		framebuffer_release(info);
+	}
+
+	drm_fb_helper_fini(&ifbdev->helper);
+
+	drm_framebuffer_cleanup(&ifb->base);
+	if (ifb->obj) {
+		drm_gem_object_unreference_unlocked(ifb->obj);
+		ifb->obj = NULL;
+	}
+}
+
+int intel_fbdev_init(struct drm_device *dev)
+{
+	struct intel_fbdev *ifbdev;
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	int ret;
+
+	ifbdev = kzalloc(sizeof(struct intel_fbdev), GFP_KERNEL);
+	if (!ifbdev)
+		return -ENOMEM;
+
+	dev_priv->fbdev = ifbdev;
+	ifbdev->helper.funcs = &intel_fb_helper_funcs;
+
+	ret = drm_fb_helper_init(dev, &ifbdev->helper,
+				 dev_priv->num_pipe,
+				 INTELFB_CONN_LIMIT);
+	if (ret) {
+		kfree(ifbdev);
+		return ret;
+	}
+
+	drm_fb_helper_single_add_all_connectors(&ifbdev->helper);
+	drm_fb_helper_initial_config(&ifbdev->helper, 32);
+	return 0;
+}
+
+void intel_fbdev_fini(struct drm_device *dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	if (!dev_priv->fbdev)
+		return;
+
+	intel_fbdev_destroy(dev, dev_priv->fbdev);
+	kfree(dev_priv->fbdev);
+	dev_priv->fbdev = NULL;
+}
+MODULE_LICENSE("GPL and additional rights");
+
+void intel_fb_output_poll_changed(struct drm_device *dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_fb_helper_hotplug_event(&dev_priv->fbdev->helper);
+}
+#else
 static int intelfb_create(struct drm_device *dev, uint32_t fb_width,
 			  uint32_t fb_height, uint32_t surface_width,
 			  uint32_t surface_height,
@@ -246,7 +463,9 @@ out_unref:
 out:
 	return ret;
 }
+#endif
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 int intelfb_probe(struct drm_device *dev)
 {
 	int ret;
@@ -279,3 +498,4 @@ int intelfb_remove(struct drm_device *dev, struct drm_framebuffer *fb)
 }
 EXPORT_SYMBOL(intelfb_remove);
 MODULE_LICENSE("GPL and additional rights");
+#endif
diff --git a/drivers/gpu/drm/i915/intel_modes.c b/drivers/gpu/drm/i915/intel_modes.c
index 8e5c83b..df5904b 100644
--- a/drivers/gpu/drm/i915/intel_modes.c
+++ b/drivers/gpu/drm/i915/intel_modes.c
@@ -34,11 +34,20 @@
  * intel_ddc_probe
  *
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+bool intel_ddc_probe(struct intel_encoder *intel_encoder, int ddc_bus)
+#else
 bool intel_ddc_probe(struct intel_encoder *intel_encoder)
+#endif
 {
 	u8 out_buf[] = { 0x0, 0x0};
 	u8 buf[2];
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	struct drm_i915_private *dev_priv =
+			intel_encoder->base.dev->dev_private;
+#else
 	int ret;
+#endif
 	struct i2c_msg msgs[] = {
 		{
 			.addr = 0x50,
@@ -54,6 +63,9 @@ bool intel_ddc_probe(struct intel_encoder *intel_encoder)
 		}
 	};
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	return i2c_transfer(&dev_priv->gmbus[ddc_bus].adapter, msgs, 2) == 2;
+#else
 	intel_i2c_quirk_set(intel_encoder->base.dev, true);
 	ret = i2c_transfer(intel_encoder->ddc_bus, msgs, 2);
 	intel_i2c_quirk_set(intel_encoder->base.dev, false);
@@ -61,6 +73,7 @@ bool intel_ddc_probe(struct intel_encoder *intel_encoder)
 		return true;
 
 	return false;
+#endif
 }
 
 /**
@@ -69,11 +82,25 @@ bool intel_ddc_probe(struct intel_encoder *intel_encoder)
  *
  * Fetch the EDID information from @connector using the DDC bus.
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int intel_ddc_get_modes(struct drm_connector *connector,
+			struct i2c_adapter *adapter)
+#else
 int intel_ddc_get_modes(struct intel_encoder *intel_encoder)
+#endif
 {
 	struct edid *edid;
 	int ret = 0;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	edid = drm_get_edid(connector, adapter);
+	if (edid) {
+		drm_mode_connector_update_edid_property(connector, edid);
+		ret = drm_add_edid_modes(connector, edid);
+		connector->display_info.raw_edid = NULL;
+		kfree(edid);
+	}
+#else
 	intel_i2c_quirk_set(intel_encoder->base.dev, true);
 	edid = drm_get_edid(&intel_encoder->base, intel_encoder->ddc_bus);
 	intel_i2c_quirk_set(intel_encoder->base.dev, false);
@@ -84,6 +111,7 @@ int intel_ddc_get_modes(struct intel_encoder *intel_encoder)
 		intel_encoder->base.display_info.raw_edid = NULL;
 		kfree(edid);
 	}
+#endif
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/i915/intel_sdvo_regs.h b/drivers/gpu/drm/i915/intel_sdvo_regs.h
index ba5cdf8..63dbded 100644
--- a/drivers/gpu/drm/i915/intel_sdvo_regs.h
+++ b/drivers/gpu/drm/i915/intel_sdvo_regs.h
@@ -596,13 +596,23 @@ struct intel_sdvo_enhancements_reply {
     unsigned int overscan_h:1;
 
     unsigned int overscan_v:1;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+    unsigned int hpos:1;
+    unsigned int vpos:1;
+#else
     unsigned int position_h:1;
     unsigned int position_v:1;
+#endif
     unsigned int sharpness:1;
     unsigned int dot_crawl:1;
     unsigned int dither:1;
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+    unsigned int tv_chroma_filter:1;
+    unsigned int tv_luma_filter:1;
+#else
     unsigned int max_tv_chroma_filter:1;
     unsigned int max_tv_luma_filter:1;
+#endif
 } __attribute__((packed));
 
 /* Picture enhancement limits below are dependent on the current TV format,
@@ -717,6 +727,29 @@ struct intel_sdvo_enhancements_arg {
 #define SDVO_CMD_GET_AUDIO_TX_INFO	0x9c
 #define SDVO_NEED_TO_STALL  (1 << 7)
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define SDVO_CMD_GET_MAX_FLICKER_FILTER			0x4d
+#define SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE	0x7b
+#define SDVO_CMD_GET_MAX_FLICKER_FILTER_2D		0x52
+#define SDVO_CMD_GET_MAX_HPOS				0x67
+#define SDVO_CMD_GET_MAX_VPOS				0x6a
+#define SDVO_CMD_GET_MAX_SHARPNESS			0x6d
+#define SDVO_CMD_GET_MAX_TV_CHROMA_FILTER		0x74
+#define SDVO_CMD_GET_MAX_TV_LUMA_FILTER			0x77
+#define SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE		0x50
+#define SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE		0x51
+#define SDVO_CMD_GET_FLICKER_FILTER_2D			0x53
+#define SDVO_CMD_SET_FLICKER_FILTER_2D			0x54
+#define SDVO_CMD_GET_HPOS				0x68
+#define SDVO_CMD_SET_HPOS				0x69
+#define SDVO_CMD_GET_VPOS				0x6b
+#define SDVO_CMD_SET_VPOS				0x6c
+#define SDVO_CMD_GET_TV_CHROMA_FILTER			0x75
+#define SDVO_CMD_SET_TV_CHROMA_FILTER			0x76
+#define SDVO_CMD_GET_TV_LUMA_FILTER			0x78
+#define SDVO_CMD_SET_TV_LUMA_FILTER			0x79
+#endif
+
 struct intel_sdvo_encode{
     u8 dvi_rev;
     u8 hdmi_rev;
-- 
1.6.5.2

