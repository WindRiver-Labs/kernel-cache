From 6d1011512aa85957ac04fa1f51f0bf182a149c50 Mon Sep 17 00:00:00 2001
From: Hui Wang <Hui.Wang@windriver.com>
Date: Fri, 28 Jan 2011 16:34:45 +0800
Subject: [PATCH 18/25] drm/i915: Add the support of eDP on DP-D for Ibex/CPT

Refer to upstream: 36e83a18

This one adds support for eDP that connected on PCH DP-D port
instead of CPU DP-A port, and only DP-D port could be used for eDP.

https://bugs.freedesktop.org/show_bug.cgi?id=27220

Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
Tested-by: Jan-Hendrik Zab <jan@jhz.name>
Tested-by: Templar <templar@rshc.de>
Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
Signed-off-by: Eric Anholt <eric@anholt.net>

[The PCH prot D can be acted as DP(displayport) or eDP(embedded
displayport), we should provide a routine to be able to detect it.
Pick detect routine relating codes from this commit.]

Signed-off-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/gpu/drm/i915/intel_dp.c  |   50 +++++++++++++++++++++++++++++++-------
 drivers/gpu/drm/i915/intel_drv.h |    2 +-
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 9747f71..189339f 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -254,6 +254,12 @@ intel_dp_aux_ch(struct intel_encoder *intel_encoder,
 	else
 		precharge = 5;
 
+	if (I915_READ(ch_ctl) & DP_AUX_CH_CTL_SEND_BUSY) {
+		DRM_ERROR("dp_aux_ch not started status 0x%08x\n",
+			  I915_READ(ch_ctl));
+		return -EBUSY;
+	}
+
 	/* Must try at least 3 times according to DP spec */
 	for (try = 0; try < 5; try++) {
 		/* Load the send data into the aux channel data registers */
@@ -659,6 +665,7 @@ intel_dp_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,
 	struct intel_dp_priv *dp_priv = intel_encoder->dev_priv;
 	struct drm_crtc *crtc = intel_encoder->enc.crtc;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+	struct drm_device *dev = intel_encoder->base.dev;
 
 	dp_priv->DP = (DP_VOLTAGE_0_4 |
 		       DP_PRE_EMPHASIS_0);
@@ -1091,6 +1098,11 @@ intel_dp_link_train(struct intel_encoder *intel_encoder, uint32_t DP,
 	int tries;
 	u32 reg;
 
+	/* Enable output, wait for it to become active */
+	I915_WRITE(dp_priv->output_reg, dp_priv->DP);
+	POSTING_READ(dp_priv->output_reg);
+	intel_wait_for_vblank(dev);
+
 	/* Write the link configuration data */
 	intel_dp_aux_native_write(intel_encoder, 0x100,
 				  link_configuration, DP_LINK_CONFIGURATION_SIZE);
@@ -1422,15 +1434,6 @@ static const struct drm_encoder_funcs intel_dp_enc_funcs = {
 	.destroy = intel_dp_enc_destroy,
 };
 
-void
-intel_dp_hot_plug(struct intel_encoder *intel_encoder)
-{
-	struct intel_dp_priv *dp_priv = intel_encoder->dev_priv;
-
-	if (dp_priv->dpms_mode == DRM_MODE_DPMS_ON)
-		intel_dp_check_link_status(intel_encoder);
-}
-
 /* Return which DP Port should be selected for Transcoder DP control */
 int
 intel_trans_dp_port_sel (struct drm_crtc *crtc)
@@ -1455,6 +1458,35 @@ intel_trans_dp_port_sel (struct drm_crtc *crtc)
 	return -1;
 }
 
+/* check the VBT to see whether the eDP is on DP-D port */
+bool intel_dpd_is_edp(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct child_device_config *p_child;
+	int i;
+
+	if (!dev_priv->child_dev_num)
+		return false;
+
+	for (i = 0; i < dev_priv->child_dev_num; i++) {
+		p_child = dev_priv->child_dev + i;
+
+		if (p_child->dvo_port == PORT_IDPD &&
+		    p_child->device_type == DEVICE_TYPE_eDP)
+			return true;
+	}
+	return false;
+}
+
+void
+intel_dp_hot_plug(struct intel_encoder *intel_encoder)
+{
+	struct intel_dp_priv *dp_priv = intel_encoder->dev_priv;
+
+	if (dp_priv->dpms_mode == DRM_MODE_DPMS_ON)
+		intel_dp_check_link_status(intel_encoder);
+}
+
 void
 intel_dp_init(struct drm_device *dev, int output_reg)
 {
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 4e9f24a..38ddd06 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -180,7 +180,7 @@ void
 intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,
 		 struct drm_display_mode *adjusted_mode);
 extern void intel_edp_link_config (struct intel_encoder *, int *, int *);
-
+extern bool intel_dpd_is_edp(struct drm_device *dev);
 
 extern int intel_panel_fitter_pipe (struct drm_device *dev);
 extern void intel_crtc_load_lut(struct drm_crtc *crtc);
-- 
1.6.5.2

