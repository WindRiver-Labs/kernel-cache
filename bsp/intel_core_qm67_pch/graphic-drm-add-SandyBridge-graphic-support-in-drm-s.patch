From 7d833fd7a42fae18a9568e45eb6a4350d250657d Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Sun, 23 Jan 2011 14:01:47 +0800
Subject: [PATCH 05/11] graphic/drm: add SandyBridge graphic support in drm subsystem

In order to not impact existing drm subsystem, and also for
stability and isolation, add some modifications(all add with
CONFIG_DRM_I915_SB) in drm. These modifications included lots
of structural differences which refer to upstream commits,
such as the following.

The upstream commits:
  02b001624f0384540299d9288fdaf37b7d37c814 [drm: vmwgfx: Add a struct drm_file parameter to the dirty framebuffer callback]
  7203425a943eb3e189ba6b512827e0deb5f23872 [drm: expand gamma_set]
  7b334fcb45b757ffb093696ca3de1b0c8b4a33f1 [drm: Use a nondestructive mode for output detect when polling]
Contain function pointer changes(dirty, gamma_set and detect).

The upstream commits:
  1d397043bcc2c8cdccb584a8ef73131f28f18e4c [drm: extract drm_gem_object_init]
  dcdb167402cbdca1d021bdfa5f63995ee0a79317 [drm: Add support for platform devices to register as DRM devices]
  86a1b9d1f175e9e9d022c7674d6ba1ede48ee15f [drm: disable encoder rather than dpms off in drm_crtc_prepare_encoders()]
Add new functions(drm_gem_object_init, drm_get_pci_dev and drm_encoder_disable).

The upstream commits:
  dcdb167402cbdca1d021bdfa5f63995ee0a79317 [drm: Add support for platform devices to register as DRM devices]
  29d08b3efddca628b0360411ab2b85f7b1723f48 [drm/gem: handlecount isn't really a kref so don't make it one]
Contain function changes(drm_fill_in_dev and drm_gem_object_handle_free).

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/gpu/drm/drm_crtc.c        |   10 +++
 drivers/gpu/drm/drm_crtc_helper.c |  158 +++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/drm_gem.c         |   40 +++++++++
 drivers/gpu/drm/drm_modes.c       |   28 +++++++
 drivers/gpu/drm/drm_pci.c         |  147 ++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/drm_stub.c        |   17 ++++
 drivers/gpu/drm/drm_sysfs.c       |    4 +
 7 files changed, 404 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 1a224f8..00d22e1 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -1846,7 +1846,12 @@ int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
 	}
 
 	if (fb->funcs->dirty) {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
+				       clips, num_clips);
+#else
 		ret = fb->funcs->dirty(fb, flags, r->color, clips, num_clips);
+#endif
 	} else {
 		ret = -ENOSYS;
 		goto out_err2;
@@ -2531,7 +2536,12 @@ int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 		goto out;
 	}
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base,
+			       0, crtc->gamma_size);
+#else
 	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base, crtc->gamma_size);
+#endif
 
 out:
 	mutex_unlock(&dev->mode_config.mutex);
diff --git a/drivers/gpu/drm/drm_crtc_helper.c b/drivers/gpu/drm/drm_crtc_helper.c
index 220177a..d395a36 100644
--- a/drivers/gpu/drm/drm_crtc_helper.c
+++ b/drivers/gpu/drm/drm_crtc_helper.c
@@ -34,6 +34,11 @@
 #include "drm_crtc_helper.h"
 #include "drm_fb_helper.h"
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static bool drm_kms_helper_poll = true;
+module_param_named(poll, drm_kms_helper_poll, bool, 0600);
+#endif
+
 static void drm_mode_validate_flag(struct drm_connector *connector,
 				   int flags)
 {
@@ -98,8 +103,15 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 			connector->status = connector_status_disconnected;
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	} else {
+		connector->status = connector->funcs->detect(connector, true);
+		drm_kms_helper_poll_enable(dev);
+	}
+#else
 	} else
 		connector->status = connector->funcs->detect(connector);
+#endif
 
 	if (connector->status == connector_status_disconnected) {
 		DRM_DEBUG_KMS("%s is disconnected\n",
@@ -216,6 +228,20 @@ bool drm_helper_crtc_in_use(struct drm_crtc *crtc)
 }
 EXPORT_SYMBOL(drm_helper_crtc_in_use);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+static void
+drm_encoder_disable(struct drm_encoder *encoder)
+{
+	struct drm_encoder_helper_funcs *encoder_funcs =
+						encoder->helper_private;
+
+	if (encoder_funcs->disable)
+		(*encoder_funcs->disable)(encoder);
+	else
+		(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
+}
+#endif
+
 /**
  * drm_helper_disable_unused_functions - disable unused objects
  * @dev: DRM device
@@ -243,10 +269,14 @@ void drm_helper_disable_unused_functions(struct drm_device *dev)
 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 		encoder_funcs = encoder->helper_private;
 		if (!drm_helper_encoder_in_use(encoder)) {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+			drm_encoder_disable(encoder);
+#else
 			if (encoder_funcs->disable)
 				(*encoder_funcs->disable)(encoder);
 			else
 				(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
+#endif
 			/* disconnector encoder from any connector */
 			encoder->crtc = NULL;
 		}
@@ -256,7 +286,14 @@ void drm_helper_disable_unused_functions(struct drm_device *dev)
 		struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
 		crtc->enabled = drm_helper_crtc_in_use(crtc);
 		if (!crtc->enabled) {
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+			if (crtc_funcs->disable)
+				(*crtc_funcs->disable)(crtc);
+			else
+				(*crtc_funcs->dpms)(crtc, DRM_MODE_DPMS_OFF);
+#else
 			crtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);
+#endif
 			crtc->fb = NULL;
 		}
 	}
@@ -603,11 +640,19 @@ drm_crtc_prepare_encoders(struct drm_device *dev)
 		encoder_funcs = encoder->helper_private;
 		/* Disable unused encoders */
 		if (encoder->crtc == NULL)
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+			drm_encoder_disable(encoder);
+#else
 			(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
+#endif
 		/* Disable encoders whose CRTC is about to change */
 		if (encoder_funcs->get_crtc &&
 		    encoder->crtc != (*encoder_funcs->get_crtc)(encoder))
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+			drm_encoder_disable(encoder);
+#else
 			(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
+#endif
 	}
 }
 
@@ -1020,7 +1065,9 @@ bool drm_helper_initial_config(struct drm_device *dev)
 	/* disable all the possible outputs/crtcs before entering KMS mode */
 	drm_helper_disable_unused_functions(dev);
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	drm_fb_helper_parse_command_line(dev);
+#endif
 
 	count = drm_helper_probe_connector_modes(dev,
 						 dev->mode_config.max_width,
@@ -1200,3 +1247,114 @@ int drm_helper_resume_force_mode(struct drm_device *dev)
 	return 0;
 }
 EXPORT_SYMBOL(drm_helper_resume_force_mode);
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define DRM_OUTPUT_POLL_PERIOD (10*HZ)
+static void output_poll_execute(struct work_struct *work)
+{
+	struct delayed_work *delayed_work = to_delayed_work(work);
+	struct drm_device *dev = container_of(delayed_work, struct drm_device,
+					      mode_config.output_poll_work);
+	struct drm_connector *connector;
+	enum drm_connector_status old_status, status;
+	bool repoll = false, changed = false;
+
+	if (!drm_kms_helper_poll)
+		return;
+
+	mutex_lock(&dev->mode_config.mutex);
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+
+		/* if this is HPD or polled don't check it -
+		   TV out for instance */
+		if (!connector->polled)
+			continue;
+
+		else if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
+					      DRM_CONNECTOR_POLL_DISCONNECT))
+			repoll = true;
+
+		old_status = connector->status;
+		/* if we are connected and don't want to poll for disconnect
+		   skip it */
+		if (old_status == connector_status_connected &&
+		    !(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT) &&
+		    !(connector->polled & DRM_CONNECTOR_POLL_HPD))
+			continue;
+
+		status = connector->funcs->detect(connector, false);
+		if (old_status != status)
+			changed = true;
+	}
+
+	mutex_unlock(&dev->mode_config.mutex);
+
+	if (changed) {
+		/* send a uevent + call fbdev */
+		drm_sysfs_hotplug_event(dev);
+		if (dev->mode_config.funcs->output_poll_changed)
+			dev->mode_config.funcs->output_poll_changed(dev);
+	}
+
+	if (repoll)
+		queue_delayed_work(system_nrt_wq, delayed_work,
+				   DRM_OUTPUT_POLL_PERIOD);
+}
+
+void drm_kms_helper_poll_disable(struct drm_device *dev)
+{
+	if (!dev->mode_config.poll_enabled)
+		return;
+	cancel_delayed_work_sync(&dev->mode_config.output_poll_work);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_disable);
+
+void drm_kms_helper_poll_enable(struct drm_device *dev)
+{
+	bool poll = false;
+	struct drm_connector *connector;
+
+	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
+		return;
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->polled)
+			poll = true;
+	}
+
+	if (poll)
+		queue_delayed_work(system_nrt_wq,
+				   &dev->mode_config.output_poll_work,
+				   DRM_OUTPUT_POLL_PERIOD);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_enable);
+
+void drm_kms_helper_poll_init(struct drm_device *dev)
+{
+	INIT_DELAYED_WORK(&dev->mode_config.output_poll_work,
+			  output_poll_execute);
+	dev->mode_config.poll_enabled = true;
+
+	drm_kms_helper_poll_enable(dev);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_init);
+
+void drm_kms_helper_poll_fini(struct drm_device *dev)
+{
+	drm_kms_helper_poll_disable(dev);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_fini);
+
+void drm_helper_hpd_irq_event(struct drm_device *dev)
+{
+	if (!dev->mode_config.poll_enabled)
+		return;
+
+	/* kill timer and schedule immediate execution, this doesn't block */
+	cancel_delayed_work(&dev->mode_config.output_poll_work);
+	if (drm_kms_helper_poll)
+		queue_delayed_work(system_nrt_wq,
+			&dev->mode_config.output_poll_work, 0);
+}
+EXPORT_SYMBOL(drm_helper_hpd_irq_event);
+#endif
diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c
index aa89d4b..ccd2b12 100644
--- a/drivers/gpu/drm/drm_gem.c
+++ b/drivers/gpu/drm/drm_gem.c
@@ -123,6 +123,30 @@ drm_gem_destroy(struct drm_device *dev)
 	dev->mm_private = NULL;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+/**
+ * Initialize an already allocate GEM object of the specified size with
+ * shmfs backing store.
+ */
+int drm_gem_object_init(struct drm_device *dev,
+			struct drm_gem_object *obj, size_t size)
+{
+	BUG_ON((size & (PAGE_SIZE - 1)) != 0);
+
+	obj->dev = dev;
+	obj->filp = shmem_file_setup("drm mm object", size, VM_NORESERVE);
+	if (IS_ERR(obj->filp))
+		return -ENOMEM;
+
+	kref_init(&obj->refcount);
+	atomic_set(&obj->handle_count, 0);
+	obj->size = size;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_gem_object_init);
+#endif
+
 /**
  * Allocate a GEM object of the specified size with shmfs backing store
  */
@@ -413,6 +437,15 @@ drm_gem_object_free_common(struct drm_gem_object *obj)
 	kfree(obj);
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+void
+drm_gem_object_release(struct drm_gem_object *obj)
+{
+	fput(obj->filp);
+}
+EXPORT_SYMBOL(drm_gem_object_release);
+#endif
+
 /**
  * Called after the last reference to the object has been lost.
  * Must be called holding struct_ mutex
@@ -430,7 +463,9 @@ drm_gem_object_free(struct kref *kref)
 	if (dev->driver->gem_free_object != NULL)
 		dev->driver->gem_free_object(obj);
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	drm_gem_object_free_common(obj);
+#endif
 }
 EXPORT_SYMBOL(drm_gem_object_free);
 
@@ -470,12 +505,17 @@ static void drm_gem_object_ref_bug(struct kref *list_kref)
  * called before drm_gem_object_free or we'll be touching
  * freed memory
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+void drm_gem_object_handle_free(struct drm_gem_object *obj)
+{
+#else
 void
 drm_gem_object_handle_free(struct kref *kref)
 {
 	struct drm_gem_object *obj = container_of(kref,
 						  struct drm_gem_object,
 						  handlecount);
+#endif
 	struct drm_device *dev = obj->dev;
 
 	/* Remove any name for this object */
diff --git a/drivers/gpu/drm/drm_modes.c b/drivers/gpu/drm/drm_modes.c
index 76d6339..51f88a4 100644
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -300,9 +300,16 @@ EXPORT_SYMBOL(drm_cvt_mode);
  * I also refer to the function of fb_get_mode in the file of
  * drivers/video/fbmon.c
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+struct drm_display_mode *
+drm_gtf_mode_complex(struct drm_device *dev, int hdisplay, int vdisplay,
+		     int vrefresh, bool interlaced, int margins,
+		     int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)
+#else
 struct drm_display_mode *drm_gtf_mode(struct drm_device *dev, int hdisplay,
 				      int vdisplay, int vrefresh,
 				      bool interlaced, int margins)
+#endif
 {
 	/* 1) top/bottom margin size (% of height) - default: 1.8, */
 #define	GTF_MARGIN_PERCENTAGE		18
@@ -317,6 +324,7 @@ struct drm_display_mode *drm_gtf_mode(struct drm_device *dev, int hdisplay,
 	/* min time of vsync + back porch (microsec) */
 #define MIN_VSYNC_PLUS_BP		550
 	/* blanking formula gradient */
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 #define GTF_M				600
 	/* blanking formula offset */
 #define GTF_C				40
@@ -324,8 +332,13 @@ struct drm_display_mode *drm_gtf_mode(struct drm_device *dev, int hdisplay,
 #define GTF_K				128
 	/* blanking formula scaling factor */
 #define GTF_J				20
+#endif
 	/* C' and M' are part of the Blanking Duty Cycle computation */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#define GTF_C_PRIME		(((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J)
+#else
 #define GTF_C_PRIME		(((GTF_C - GTF_J) * GTF_K / 256) + GTF_J)
+#endif
 #define GTF_M_PRIME		(GTF_K * GTF_M / 256)
 	struct drm_display_mode *drm_mode;
 	unsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;
@@ -470,7 +483,22 @@ struct drm_display_mode *drm_gtf_mode(struct drm_device *dev, int hdisplay,
 
 	return drm_mode;
 }
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 EXPORT_SYMBOL(drm_gtf_mode);
+#else
+EXPORT_SYMBOL(drm_gtf_mode_complex);
+#endif
+
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+struct drm_display_mode *
+drm_gtf_mode(struct drm_device *dev, int hdisplay, int vdisplay, int vrefresh,
+	     bool lace, int margins)
+{
+	return drm_gtf_mode_complex(dev, hdisplay, vdisplay, vrefresh, lace,
+				    margins, 600, 40 * 2, 128, 20 * 2);
+}
+EXPORT_SYMBOL(drm_gtf_mode);
+#endif
 /**
  * drm_mode_set_name - set the name on a mode
  * @mode: name will be set in this mode
diff --git a/drivers/gpu/drm/drm_pci.c b/drivers/gpu/drm/drm_pci.c
index 2ea9ad4..fb6ff70 100644
--- a/drivers/gpu/drm/drm_pci.c
+++ b/drivers/gpu/drm/drm_pci.c
@@ -124,4 +124,151 @@ void drm_pci_free(struct drm_device * dev, drm_dma_handle_t * dmah)
 
 EXPORT_SYMBOL(drm_pci_free);
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+#ifdef CONFIG_PCI
+/**
+ * Register.
+ *
+ * \param pdev - PCI device structure
+ * \param ent entry from the PCI ID table with device type flags
+ * \return zero on success or a negative number on failure.
+ *
+ * Attempt to gets inter module "drm" information. If we are first
+ * then register the character device and inter module information.
+ * Try and register, if we fail to register, backout previous work.
+ */
+int drm_get_pci_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
+		    struct drm_driver *driver)
+{
+	struct drm_device *dev;
+	int ret;
+
+	DRM_DEBUG("\n");
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	ret = pci_enable_device(pdev);
+	if (ret)
+		goto err_g1;
+
+	pci_set_master(pdev);
+
+	dev->pdev = pdev;
+	dev->dev = &pdev->dev;
+
+	dev->pci_device = pdev->device;
+	dev->pci_vendor = pdev->vendor;
+
+#ifdef __alpha__
+	dev->hose = pdev->sysdata;
+#endif
+
+	ret = drm_fill_in_dev(dev, ent, driver);
+	if (ret) {
+		printk(KERN_ERR "DRM: Fill_in_dev failed.\n");
+		goto err_g2;
+	}
+
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		pci_set_drvdata(pdev, dev);
+		ret = drm_get_minor(dev, &dev->control, DRM_MINOR_CONTROL);
+		if (ret)
+			goto err_g2;
+	}
+
+	ret = drm_get_minor(dev, &dev->primary, DRM_MINOR_LEGACY);
+	if (ret)
+		goto err_g3;
+
+	if (dev->driver->load) {
+		ret = dev->driver->load(dev, ent->driver_data);
+		if (ret)
+			goto err_g4;
+	}
+
+	/* setup the grouping for the legacy output */
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		ret = drm_mode_group_init_legacy_group(dev,
+						&dev->primary->mode_group);
+		if (ret)
+			goto err_g4;
+	}
+
+	list_add_tail(&dev->driver_item, &driver->device_list);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",
+		 driver->name, driver->major, driver->minor, driver->patchlevel,
+		 driver->date, pci_name(pdev), dev->primary->index);
+
+	return 0;
+
+err_g4:
+	drm_put_minor(&dev->primary);
+err_g3:
+	if (drm_core_check_feature(dev, DRIVER_MODESET))
+		drm_put_minor(&dev->control);
+err_g2:
+	pci_disable_device(pdev);
+err_g1:
+	kfree(dev);
+	return ret;
+}
+EXPORT_SYMBOL(drm_get_pci_dev);
+
+/**
+ * PCI device initialization. Called via drm_init at module load time,
+ *
+ * \return zero on success or a negative number on failure.
+ *
+ * Initializes a drm_device structures,registering the
+ * stubs and initializing the AGP device.
+ *
+ * Expands the \c DRIVER_PREINIT and \c DRIVER_POST_INIT macros before and
+ * after the initialization for driver customization.
+ */
+int drm_pci_init(struct drm_driver *driver)
+{
+	struct pci_dev *pdev = NULL;
+	const struct pci_device_id *pid;
+	int i;
+
+	if (driver->driver_features & DRIVER_MODESET)
+		return pci_register_driver(&driver->pci_driver);
+
+	/* If not using KMS, fall back to stealth mode manual scanning. */
+	for (i = 0; driver->pci_driver.id_table[i].vendor != 0; i++) {
+		pid = &driver->pci_driver.id_table[i];
+
+		/* Loop around setting up a DRM device for each PCI device
+		 * matching our ID and device class.  If we had the internal
+		 * function that pci_get_subsys and pci_get_class used, we'd
+		 * be able to just pass pid in instead of doing a two-stage
+		 * thing.
+		 */
+		pdev = NULL;
+		while ((pdev =
+			pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
+				       pid->subdevice, pdev)) != NULL) {
+			if ((pdev->class & pid->class_mask) != pid->class)
+				continue;
+
+			/* stealth mode requires a manual probe */
+			pci_dev_get(pdev);
+			drm_get_pci_dev(pdev, pid, driver);
+		}
+	}
+	return 0;
+}
+
+#else
+
+int drm_pci_init(struct drm_driver *driver)
+{
+	return -1;
+}
+
+#endif
+#endif
 /*@}*/
diff --git a/drivers/gpu/drm/drm_stub.c b/drivers/gpu/drm/drm_stub.c
index a0c365f..c806bc3 100644
--- a/drivers/gpu/drm/drm_stub.c
+++ b/drivers/gpu/drm/drm_stub.c
@@ -224,9 +224,15 @@ int drm_dropmaster_ioctl(struct drm_device *dev, void *data,
 	return 0;
 }
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int drm_fill_in_dev(struct drm_device *dev,
+		    const struct pci_device_id *ent,
+		    struct drm_driver *driver)
+#else
 static int drm_fill_in_dev(struct drm_device * dev, struct pci_dev *pdev,
 			   const struct pci_device_id *ent,
 			   struct drm_driver *driver)
+#endif
 {
 	int retcode;
 
@@ -245,9 +251,11 @@ static int drm_fill_in_dev(struct drm_device * dev, struct pci_dev *pdev,
 
 	idr_init(&dev->drw_idr);
 
+#if !defined(CONFIG_DRM_I915_SB) && !defined(CONFIG_DRM_I915_SB_MODULE)
 	dev->pdev = pdev;
 	dev->pci_device = pdev->device;
 	dev->pci_vendor = pdev->vendor;
+#endif
 
 #ifdef __alpha__
 	dev->hose = pdev->sysdata;
@@ -321,7 +329,11 @@ static int drm_fill_in_dev(struct drm_device * dev, struct pci_dev *pdev,
  * create the proc init entry via proc_init(). This routines assigns
  * minor numbers to secondary heads of multi-headed cards
  */
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+int drm_get_minor(struct drm_device *dev, struct drm_minor **minor, int type)
+#else
 static int drm_get_minor(struct drm_device *dev, struct drm_minor **minor, int type)
+#endif
 {
 	struct drm_minor *new_minor;
 	int ret;
@@ -415,7 +427,12 @@ int drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
 		goto err_g1;
 
 	pci_set_master(pdev);
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	ret = drm_fill_in_dev(dev, ent, driver);
+	if (ret) {
+#else
 	if ((ret = drm_fill_in_dev(dev, pdev, ent, driver))) {
+#endif
 		printk(KERN_ERR "DRM: Fill_in_dev failed.\n");
 		goto err_g2;
 	}
diff --git a/drivers/gpu/drm/drm_sysfs.c b/drivers/gpu/drm/drm_sysfs.c
index 25bbd30..344381a 100644
--- a/drivers/gpu/drm/drm_sysfs.c
+++ b/drivers/gpu/drm/drm_sysfs.c
@@ -159,7 +159,11 @@ static ssize_t status_show(struct device *device,
 	struct drm_connector *connector = to_drm_connector(device);
 	enum drm_connector_status status;
 
+#if defined(CONFIG_DRM_I915_SB) || defined(CONFIG_DRM_I915_SB_MODULE)
+	status = connector->funcs->detect(connector, true);
+#else
 	status = connector->funcs->detect(connector);
+#endif
 	return snprintf(buf, PAGE_SIZE, "%s\n",
 			drm_get_connector_status_name(status));
 }
-- 
1.6.5.2

