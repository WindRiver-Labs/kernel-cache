From 2f9e5e005f5f4b1d428bf844ca13fa98973989d9 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Fri, 19 Jun 2009 20:38:31 +0800
Subject: [PATCH 07/13] fsl_imx31pdk: add pm support

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Update irq codes to add PM wakeup irq support. And add arch specific
PM process stuff.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Makefile   |    3 +
 arch/arm/mach-mx3/crm_regs.h |    1 +
 arch/arm/mach-mx3/mxc_pm.c   |  417 ++++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx3/pm.c       |  107 +++++++++++
 arch/arm/plat-mxc/irq.c      |  132 +++++++++++++
 5 files changed, 660 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx3/mxc_pm.c
 create mode 100644 arch/arm/mach-mx3/pm.c

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 06066b5..486cce5 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -11,3 +11,6 @@ obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
 obj-$(CONFIG_USB_EHCI_ARC)  += usb.o
 
 obj-$(CONFIG_MXC_DVFS)      += dvfs.o
+
+# power management
+obj-$(CONFIG_PM)        += pm.o mxc_pm.o
diff --git a/arch/arm/mach-mx3/crm_regs.h b/arch/arm/mach-mx3/crm_regs.h
index 4a0e0ed..66c3554 100644
--- a/arch/arm/mach-mx3/crm_regs.h
+++ b/arch/arm/mach-mx3/crm_regs.h
@@ -55,6 +55,7 @@
 #define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
 
 /* Register bit definitions */
+#define MXC_CCM_CCMR_VSTBY						(1 << 28)
 #define MXC_CCM_CCMR_WBEN                       (1 << 27)
 #define MXC_CCM_CCMR_CSCS                       (1 << 25)
 #define MXC_CCM_CCMR_PERCS                      (1 << 24)
diff --git a/arch/arm/mach-mx3/mxc_pm.c b/arch/arm/mach-mx3/mxc_pm.c
new file mode 100644
index 0000000..e96999d
--- /dev/null
+++ b/arch/arm/mach-mx3/mxc_pm.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DPM_MX31 Power Management
+ * @ingroup MSL_MX31
+ */
+/*!
+ * @file mach-mx3/mxc_pm.c
+ *
+ * @brief This file provides all the kernel level and user level API
+ * definitions for the CRM_MCU and DPLL in mx3.
+ *
+ * @ingroup DPM_MX31
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/cpu.h>
+
+#include <asm/plat-mxc/mxc_pm.h>
+#include <asm/irq.h>
+#include <asm/proc-fns.h>
+
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <mach/clock.h>
+#include <mach/dvfs.h>
+
+#include "crm_regs.h"
+
+/* Local defines */
+/* tolerance percentage times 100 */
+#define FREQ_COMP_TOLERANCE 200
+/* Maximum frequency MCU PLL clock */
+#define MCU_PLL_MAX_FREQ    600000000
+/* Minimum frequency MCU PLL clock */
+#define MCU_PLL_MIN_FREQ    160000000
+/* Maximum frequency NFC clock */
+#define NFC_MAX_FREQ	    20000000
+/* Minimum Frequency after Predivider */
+#define PRE_DIV_MIN_FREQ    10000000
+
+static struct clk *mcu_pll_clk;
+static struct clk *cpu_clk;
+static struct clk *ahb_clk;
+static struct clk *ipg_clk;
+
+/*!
+ * Compare two frequences using allowable tolerance
+ *
+ * The MX3 PLL can generate many frequencies. This function
+ * compares the generated frequency to the requested frequency
+ * and determines it they are within and acceptable tolerance.
+ *
+ * @param   freq1  desired frequency
+ * @param   freq2  generated frequency
+ *
+ * @return       Returns 0 is frequencies are within talerance
+ *               and non-zero is they are not.
+ */
+static int freq_equal(unsigned long freq1, unsigned long freq2)
+{
+	if (freq1 > freq2)
+		return (freq1 - freq2) <= (freq1 / FREQ_COMP_TOLERANCE);
+
+	return (freq2 - freq1) <= (freq1 / FREQ_COMP_TOLERANCE);
+}
+
+/*!
+ * Calculate new MCU clock dividers for the PDR0 regiser.
+ *
+ * @param   mcu_main_clk PLL output frequency (Hz)
+ * @param   arm_freq     desired ARM frequency (Hz)
+ * @param   max_freq     desired MAX frequency (Hz)
+ * @param   ip_freq      desired IP frequency (Hz)
+ * @param   mask         were to return PDR0 mask
+ * @param   value        were to return PDR0 value
+ *
+ * @return         Returns 0 on success or
+ *                 Returns non zero if error
+ *                 PLL_LESS_ARM_ERR if pll frequency is less than
+ *                 desired core frequency
+ *                 FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                 possible with the current mcu pll frequency.
+ */
+static int
+cal_pdr0_value(unsigned long mcu_main_clk,
+		long arm_freq, long max_freq,
+		long ip_freq, unsigned long *mask,
+		unsigned long *value)
+{
+	unsigned long arm_div;	/* ARM core clock divider */
+	unsigned long max_div;	/* MAX clock divider */
+	unsigned long ipg_div;	/* IPG clock divider */
+	unsigned long nfc_div;	/* NFC (Nand Flash Controller)
+							   clock divider */
+	unsigned long hsp_div;	/* HSP clock divider */
+
+	if (arm_freq > mcu_main_clk)
+		return -PLL_LESS_ARM_ERR;
+
+	arm_div = mcu_main_clk / arm_freq;
+	if ((arm_div == 0) ||
+			!freq_equal(arm_freq, mcu_main_clk / arm_div))
+		return FREQ_OUT_OF_RANGE;
+
+	max_div = mcu_main_clk / max_freq;
+	if ((max_div == 0) ||
+			!freq_equal(max_freq, mcu_main_clk / max_div))
+		return FREQ_OUT_OF_RANGE;
+
+	hsp_div = max_div;
+
+	ipg_div = max_freq / ip_freq;
+	if ((ipg_div == 0) ||
+			!freq_equal(ip_freq, max_freq / ipg_div))
+		return FREQ_OUT_OF_RANGE;
+
+	nfc_div = ((max_freq - 1000000) / NFC_MAX_FREQ) + 1;
+
+	/* All of the divider values have been calculated.
+	 * Now change the hardware register. */
+
+	*mask = MXC_CCM_PDR0_HSP_PODF_MASK |
+		MXC_CCM_PDR0_NFC_PODF_MASK |
+		MXC_CCM_PDR0_IPG_PODF_MASK |
+		MXC_CCM_PDR0_MAX_PODF_MASK |
+		MXC_CCM_PDR0_MCU_PODF_MASK;
+
+	*value = ((hsp_div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET) |
+		((nfc_div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET) |
+		((ipg_div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET) |
+		((max_div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET) |
+		((arm_div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
+
+	return 0;
+}
+
+/*!
+ * Integer clock scaling
+ *
+ * Change main arm clock frequencies without changing the PLL.
+ * The integer dividers are changed to produce the desired
+ * frequencies. The number of valid frequency are limited and
+ * are determined by the current MCU PLL frequency
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return     Returns 0 on success or
+ *             Returns non zero if error
+ *             PLL_LESS_ARM_ERR if pll frequency is less than
+ *             desired core frequency
+ *             FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *             possible with the current mcu pll frequency.
+ */
+int mxc_pm_intscale(long arm_freq, long max_freq, long ip_freq)
+{
+	unsigned long mcu_main_clk;	/* mcu clock domain main clock */
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+			arm_freq, max_freq, ip_freq);
+
+	mcu_main_clk = clk_get_rate(mcu_pll_clk);
+	ret_value = cal_pdr0_value(mcu_main_clk, arm_freq,
+			max_freq, ip_freq,
+			&mask, &value);
+
+	if ((arm_freq != clk_round_rate(cpu_clk, arm_freq)) ||
+			(max_freq != clk_round_rate(ahb_clk, max_freq)) ||
+			(ip_freq != clk_round_rate(ipg_clk, ip_freq)))
+		return -EINVAL;
+
+	if ((max_freq != clk_get_rate(ahb_clk)) ||
+			(ip_freq != clk_get_rate(ipg_clk)))
+		return -EINVAL;
+
+	if (arm_freq != clk_get_rate(cpu_clk))
+		ret_value = clk_set_rate(cpu_clk, arm_freq);
+
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_intscale);
+
+/*!
+ * PLL clock scaling
+ *
+ * Change MCU PLL frequency and adjust derived clocks.
+ * Integer dividers are used generate the derived clocks
+ * so changed to produce the desired the valid frequencies
+ * are limited by the desired ARM frequency.
+ *
+ * The clock source for the MCU is set to the MCU PLL.
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return     Returns 0 on success or
+ *             Returns non zero if error
+ *             PLL_LESS_ARM_ERR if pll frequency is less than
+ *             desired core frequency
+ *             FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *             possible with the current mcu pll frequency.
+ */
+int mxc_pm_pllscale(long arm_freq, long max_freq, long ip_freq)
+{
+	signed long pll_freq = 0;	/* target pll frequency */
+	unsigned long old_pll;
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+			arm_freq, max_freq, ip_freq);
+
+	do {
+		pll_freq += arm_freq;
+		if ((pll_freq > MCU_PLL_MAX_FREQ) ||
+				(pll_freq / 8 > arm_freq))
+			return FREQ_OUT_OF_RANGE;
+
+		if (pll_freq < MCU_PLL_MIN_FREQ)
+			ret_value = 111;
+		else
+			ret_value = cal_pdr0_value(pll_freq,
+					arm_freq, max_freq,
+					ip_freq, &mask, &value);
+	} while (ret_value != 0);
+
+	old_pll = clk_get_rate(mcu_pll_clk);
+	if (pll_freq > old_pll) {
+		/* if pll freq is increasing then
+		 * change dividers first */
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
+	} else {
+		/* if pll freq is decreasing then
+		 * change pll first */
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+	}
+
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_pllscale);
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, DOZE_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode)
+{
+	unsigned int lpm;
+	int enable_flag;
+
+	local_irq_disable();
+	enable_flag = 0;
+
+	switch (mode) {
+	case DOZE_MODE:
+		lpm = 1;
+		break;
+
+	case STOP_MODE:
+		/* State Retention mode */
+		lpm = 2;
+		/* Disable timer interrupt */
+		disable_irq(MXC_INT_GPT);
+		enable_flag = 1;
+
+		/* Enable Well Bias and set VSTBY
+		 * VSTBY pin will be asserted during
+		 * SR mode. This asks the PM IC to set
+		 * the core voltage to the standby voltage
+		 * Must clear the MXC_CCM_CCMR_SBYCS bit as well
+		 */
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY |
+				MXC_CCM_CCMR_SBYCS,
+				MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY);
+
+		/*mxc_ccm_modify_reg(MXC_CCM_CCMR,
+		  MXC_CCM_CCMR_LPM_MASK,
+		  lpm << MXC_CCM_CCMR_LPM_OFFSET);*/
+		break;
+
+	case DSM_MODE:
+		/* Deep Sleep Mode */
+		lpm = 3;
+		/* Disable timer interrupt */
+		disable_irq(MXC_INT_GPT);
+		enable_flag = 1;
+		/* Enabled Well Bias
+		 * SBYCS = 0, MCU clock source is disabled*/
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_SBYCS,
+				MXC_CCM_CCMR_WBEN);
+		break;
+
+	default:
+	case WAIT_MODE:
+		/* Wait is the default mode used when idle. */
+		lpm = 0;
+		break;
+	}
+
+	mxc_ccm_modify_reg(MXC_CCM_CCMR,
+			MXC_CCM_CCMR_LPM_MASK,
+			lpm << MXC_CCM_CCMR_LPM_OFFSET);
+
+	/* Executing CP15 (Wait-for-Interrupt) Instruction */
+	/* wait for interrupt */
+	__asm__ __volatile__("mov r1, #0x0\n"
+			"mcr p15, 0, r1, c7, c0, 4\n"
+			"nop\n" "nop\n" "nop\n" "nop\n" "nop\n" : : );
+
+	if (enable_flag) {
+		/* Enable timer interrupt */
+		enable_irq(MXC_INT_GPT);
+	}
+
+	local_irq_enable();
+}
+EXPORT_SYMBOL(mxc_pm_lowpower);
+
+#ifdef CONFIG_MXC_DVFS
+/*!
+ * Changes MCU frequencies using dvfs.
+ *
+ * @param       armfreq       desired ARM frequency in Hz
+ * @param       ahbfreq       desired AHB frequency in Hz
+ * @param       ipfreq        desired IP frequency in Hz
+ *
+ * @return             Returns 0 on success, non-zero on error
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq)
+{
+	int ret_value;
+	int i;
+
+	if (ahbfreq != 133000000)
+		return FREQ_OUT_OF_RANGE;
+
+	if (ipfreq != 66500000)
+		return FREQ_OUT_OF_RANGE;
+
+	ret_value = FREQ_OUT_OF_RANGE;
+	for (i = 0; i < dvfs_states_tbl->num_of_states; i++) {
+		if (dvfs_states_tbl->freqs[i] == armfreq) {
+			ret_value = dvfs_set_state(i);
+			break;
+		}
+	}
+
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_dvfs);
+#endif
+
+/*!
+ * This function is used to load the module.
+ *
+ * @return   Returns an Integer on success
+ */
+static int __init mxc_pm_init_module(void)
+{
+	printk(KERN_INFO "Low-Level PM Driver module loaded\n");
+
+	mcu_pll_clk = clk_get(NULL, "mcu_pll");
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	ipg_clk = clk_get(NULL, "ipg_clk");
+	return 0;
+}
+
+/*!
+ * This function is used to unload the module
+ */
+static void __exit mxc_pm_cleanup_module(void)
+{
+	clk_put(mcu_pll_clk);
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+	clk_put(ipg_clk);
+	printk(KERN_INFO "Low-Level PM Driver module Unloaded\n");
+}
+
+module_init(mxc_pm_init_module);
+module_exit(mxc_pm_cleanup_module);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX3 Low-level Power Management Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx3/pm.c b/arch/arm/mach-mx3/pm.c
new file mode 100644
index 0000000..5f7555a
--- /dev/null
+++ b/arch/arm/mach-mx3/pm.c
@@ -0,0 +1,107 @@
+/*
+ * linux/arch/arm/mach-mx3/pm.c
+ *
+ * MX3 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX31
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+
+#include <asm/plat-mxc/mxc_pm.h>
+
+#include <mach/iomux-mx3.h>
+
+
+/*
+ * TODO: whatta save?
+ */
+
+static int mx31_suspend_enter(suspend_state_t state)
+{
+	printk(KERN_INFO "Hi, from mx31_pm_enter\n");
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+			mxc_pm_lowpower(DSM_MODE);
+			break;
+	case PM_SUSPEND_STANDBY:
+			mxc_pm_lowpower(STOP_MODE);
+			break;
+	default:
+			return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx31_suspend_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx31_suspend_finish(void)
+{
+	return;
+}
+
+static int mx31_pm_valid(suspend_state_t state)
+{
+	return state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX;
+}
+
+struct platform_suspend_ops mx31_suspend_ops = {
+	.valid = mx31_pm_valid,
+	.prepare = mx31_suspend_prepare,
+	.enter = mx31_suspend_enter,
+	.finish = mx31_suspend_finish,
+};
+
+static int __init mx31_pm_init(void)
+{
+	printk(KERN_INFO "Power Management for Freescale MX31\n");
+	suspend_set_ops(&mx31_suspend_ops);
+
+	return 0;
+}
+
+late_initcall(mx31_pm_init);
diff --git a/arch/arm/plat-mxc/irq.c b/arch/arm/plat-mxc/irq.c
index a872c69..64aaf2a 100644
--- a/arch/arm/plat-mxc/irq.c
+++ b/arch/arm/plat-mxc/irq.c
@@ -17,7 +17,11 @@
  * MA  02110-1301, USA.
  */
 
+#include <linux/module.h>
 #include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+
 #include <asm/io.h>
 #include <mach/common.h>
 
@@ -54,6 +58,11 @@
 #define IIM_PROD_REV_SH		3
 #define IIM_PROD_REV_LEN	5
 
+#define IRQ_BIT(irq)  (1 << (irq))
+
+static uint32_t saved_wakeup_low, saved_wakeup_high;
+static uint32_t suspend_wakeup_low, suspend_wakeup_high;
+
 /* Disable interrupt number "irq" in the AVIC */
 static void mxc_mask_irq(unsigned int irq)
 {
@@ -66,10 +75,42 @@ static void mxc_unmask_irq(unsigned int irq)
 	__raw_writel(irq, AVIC_INTENNUM);
 }
 
+/*!
+ * Set interrupt number "irq" in the AVIC as a wake-up source.
+ *
+ * @param  irq			interrupt source number
+ * @param  enable		enable as wake-up if equal to non-zero
+ *		disble as wake-up if equal to zero
+ *
+ * @return				This function returns 0 on success.
+ */
+static int mxc_set_wake_irq(unsigned int irq, unsigned int enable)
+{
+	uint32_t *wakeup_intr;
+	uint32_t irq_bit;
+
+	if (irq < 32) {
+		wakeup_intr = &suspend_wakeup_low;
+		irq_bit = IRQ_BIT(irq);
+	} else {
+		wakeup_intr = &suspend_wakeup_high;
+		irq_bit = IRQ_BIT(irq - 32);
+	}
+
+	if (enable)
+		*wakeup_intr |= irq_bit;
+	else
+		*wakeup_intr &= ~irq_bit;
+
+	return 0;
+}
+
 static struct irq_chip mxc_avic_chip = {
+	.name = "MXC_AVIC",
 	.ack = mxc_mask_irq,
 	.mask = mxc_mask_irq,
 	.unmask = mxc_unmask_irq,
+	.set_wake = mxc_set_wake_irq,
 };
 
 /*
@@ -112,3 +153,94 @@ void __init mxc_init_irq(void)
 
 	printk(KERN_INFO "MXC IRQ initialized\n");
 }
+
+#ifdef CONFIG_PM
+/*!
+ * This function puts the AVIC in low-power mode/state.
+ * All the interrupts that are enabled are first saved.
+ * Only those interrupts which registers as a wake source
+ * by calling enable_irq_wake are enabled. All other
+ * interrupts are disabled.
+ *
+ * @param	dev	the system device structure used to give
+ * 			information on AVIC to suspend
+ * @param	mesg the power state the device is entering
+ *
+ * @return  The function always returns 0.
+*/
+static int mxc_avic_suspend(struct sys_device *dev, pm_message_t mesg)
+{
+	saved_wakeup_high = __raw_readl(AVIC_INTENABLEH);
+	saved_wakeup_low = __raw_readl(AVIC_INTENABLEL);
+
+	__raw_writel(suspend_wakeup_high, AVIC_INTENABLEH);
+	__raw_writel(suspend_wakeup_low, AVIC_INTENABLEL);
+
+	return 0;
+}
+
+/*!
+ * This function brings the AVIC back from low-power state.
+ * All the interrupts enabled before suspension are re-enabled
+ * from the saved information.
+ *
+ * @param	dev	the system device structure used to give
+ *				information on AVIC to resume
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_avic_resume(struct sys_device *dev)
+{
+	__raw_writel(saved_wakeup_high, AVIC_INTENABLEH);
+	__raw_writel(saved_wakeup_low, AVIC_INTENABLEL);
+
+	return 0;
+}
+#else
+#define mxc_avic_suspend  NULL
+#define mxc_avic_resume   NULL
+#endif
+
+/*!
+ * This structure contains pointers to the power
+ * management callback functions.
+ */
+static struct sysdev_class mxc_avic_sysclass = {
+	.name = "mxc_irq",
+	.suspend = mxc_avic_suspend,
+	.resume = mxc_avic_resume,
+};
+
+/*!
+ * This structure represents AVIC as a system device.
+ * System devices follow a slightly different driver model.
+ * They don't need to do dynammic driver binding, can't be
+ * probed, and don't reside on any type of peripheral bus.
+ * So, it is represented and treated a little differently.
+ */
+static struct sys_device mxc_avic_device = {
+	.id = 0,
+	.cls = &mxc_avic_sysclass,
+};
+
+/*!
+ * This function registers AVIC hardware as a system device.
+ * System devices will only be suspended with interrupts
+ * disabled, and after all other devices have been suspended.
+ * On resume, they will be resumed before any other devices,
+ * and also with interrupts disabled.
+ *
+ * @return	This function returns 0 on success.
+ */
+static int __init mxc_avic_sysinit(void)
+{
+	int ret = 0;
+
+	ret = sysdev_class_register(&mxc_avic_sysclass);
+	if (ret == 0)
+		ret = sysdev_register(&mxc_avic_device);
+
+	return ret;
+}
+
+arch_initcall(mxc_avic_sysinit);
-- 
1.6.3.1

