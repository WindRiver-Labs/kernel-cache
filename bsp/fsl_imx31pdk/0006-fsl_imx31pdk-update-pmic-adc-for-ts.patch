From e6f037da7a6c14616f02c44b29dd417c53d11176 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Fri, 19 Jun 2009 20:38:33 +0800
Subject: [PATCH] fsl_imx31pdk: update pmic adc for ts

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Mainly differentiate TS and none TS adc comparator and add
sanity test for pmic_adc_get_touch_sample() to make sure that
TS sample is properly collected.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/pmic/mc13783/pmic_adc.c      |   53 +++++++++++++++++++++++------
 drivers/mxc/pmic/mc13783/pmic_adc_defs.h |    2 +-
 2 files changed, 43 insertions(+), 12 deletions(-)

diff --git a/drivers/mxc/pmic/mc13783/pmic_adc.c b/drivers/mxc/pmic/mc13783/pmic_adc.c
index 16effe8..98cf541 100644
--- a/drivers/mxc/pmic/mc13783/pmic_adc.c
+++ b/drivers/mxc/pmic/mc13783/pmic_adc.c
@@ -84,6 +84,7 @@ static bool monitor_en;
 static bool monitor_adc;
 static t_check_mode wcomp_mode;
 void (*monitoring_cb) (void);	/*call back to be */
+static DECLARE_MUTEX(convert_mutex);
 /* called when event is detected. */
 
 static DECLARE_WAIT_QUEUE_HEAD(queue_adc_busy);
@@ -129,7 +130,15 @@ static int pmic_adc_suspend(struct platform_device *pdev, pm_message_t state)
 static int pmic_adc_resume(struct platform_device *pdev)
 {
 	/* nothing for mc13783 adc */
+	unsigned int adc_0_reg, adc_1_reg;
 	suspend_flag = 0;
+
+	/* let interrupt of TSI again */
+	adc_0_reg = ADC_WAIT_TSI_0;
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+	adc_1_reg = ADC_WAIT_TSI_1 | (ADC_BIS * adc_ts);
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+
 	while (swait > 0) {
 		swait--;
 		wake_up_interruptible(&suspendq);
@@ -414,6 +423,9 @@ int pmic_adc_init(void)
 	CHECK_ERROR(pmic_write_reg(REG_ADC_2, reg_value, PMIC_ALL_BITS));
 	CHECK_ERROR(pmic_write_reg(REG_ADC_3, DEF_ADC_3, PMIC_ALL_BITS));
 	CHECK_ERROR(pmic_write_reg(REG_ADC_4, reg_value, PMIC_ALL_BITS));
+	reg_value = 0x001000;
+	CHECK_ERROR(pmic_write_reg(REG_ARBITRATION_PERIPHERAL_AUDIO, reg_value,
+				0xFFFFFF));
 
 	data_ready_adc_1 = false;
 	data_ready_adc_2 = false;
@@ -533,7 +545,11 @@ PMIC_STATUS mc13783_adc_convert(t_adc_param *adc_param)
 		wait_for_completion_interruptible(&adc_tsi);
 		wait_ts = false;
 	}
-	use_bis = mc13783_adc_request();
+
+	if (adc_param->read_ts == false)
+		down(&convert_mutex);
+
+	use_bis = mc13783_adc_request(adc_param->read_ts);
 	if (use_bis < 0) {
 		pr_debug("process has received a signal and got interrupted\n");
 		return -EINTR;
@@ -652,6 +668,10 @@ PMIC_STATUS mc13783_adc_convert(t_adc_param *adc_param)
 	}
 
 	mc13783_adc_release(use_bis);
+
+	if (adc_param->read_ts == false)
+		up(&convert_mutex);
+
 	return PMIC_SUCCESS;
 }
 
@@ -901,9 +921,13 @@ EXPORT_SYMBOL(pmic_adc_get_touch_mode);
  */
 PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *touch_sample, int wait)
 {
-	mc13783_adc_read_ts(touch_sample, wait);
-	pmic_adc_filter(touch_sample);
+	if (mc13783_adc_read_ts(touch_sample, wait) != 0)
+		return PMIC_ERROR;
+
+	if (0 == pmic_adc_filter(touch_sample))
 	return PMIC_SUCCESS;
+	else
+		return PMIC_ERROR;
 }
 EXPORT_SYMBOL(pmic_adc_get_touch_sample);
 
@@ -931,7 +955,8 @@ PMIC_STATUS mc13783_adc_read_ts(t_touch_screen *ts_value, int wait_tsi)
 	mc13783_adc_init_param(&param);
 	param.wait_tsi = wait_tsi;
 	param.read_ts = true;
-	mc13783_adc_convert(&param);
+	if (mc13783_adc_convert(&param) != 0)
+		return PMIC_ERROR;
 	/* check if x-y is ok */
 	if ((param.ts_value.x_position1 < TS_X_MAX) &&
 	    (param.ts_value.x_position1 >= TS_X_MIN) &&
@@ -1009,16 +1034,22 @@ EXPORT_SYMBOL(pmic_adc_get_battery_current);
  * @return      This function returns index of ADC to be
  * used (0 or 1) if successful. return -1 if error.
  * */
-int mc13783_adc_request(void)
+int mc13783_adc_request(bool read_ts)
 {
 	int adc_index = -1;
-	if (((adc_dev[0] == ADC_USED) && (adc_dev[1] == ADC_USED)))
-		/* all ADC is used wait... */
-		wait_event(queue_adc_busy, 0);
-	else if (adc_dev[0] == ADC_FREE) {
+
+	if (read_ts != 0) {
+		/*for ts we use bis=0 */
+		if (adc_dev[0] == ADC_USED)
+			return -EBUSY;
+		/*no wait here */
 		adc_dev[0] = ADC_USED;
 		adc_index = 0;
-	} else if (adc_dev[1] == ADC_FREE) {
+	} else {
+		/*for other adc use bis = 1 */
+		if (adc_dev[1] == ADC_USED)
+			return -EBUSY;
+		/*no wait here */
 		adc_dev[1] = ADC_USED;
 		adc_index = 1;
 	}
@@ -1114,7 +1145,7 @@ PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
 	monitoring.channel = channel;
 	monitoring.callback = (void *)callback;
 
-	use_bis = mc13783_adc_request();
+	use_bis = mc13783_adc_request(false);
 	if (use_bis < 0) {
 		pr_debug("mc13783_adc : request error\n");
 		return PMIC_ERROR;
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc_defs.h b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
index 06395fa..397fc0f 100644
--- a/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
+++ b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
@@ -286,7 +286,7 @@ static int pmic_adc_filter(t_touch_screen *ts_curr);
  * be used (0 or 1) if successful.
  * return -1 if error.
  */
-int mc13783_adc_request(void);
+int mc13783_adc_request(bool read_ts);
 
 /*!
  * This function is used to update buffer of touch screen value in read mode.
-- 
1.5.5.1

