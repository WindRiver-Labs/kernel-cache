From bc1df428484c607bb9c7aabef762b9cd3422676f Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Tue, 23 Jun 2009 11:32:58 +0800
Subject: [PATCH 12/13] fsl_imx31pdk: add gpio routines

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Add on-board peripherals multiplex gpio control.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/mx31pdk_gpio.c | 1256 ++++++++++++++++++++++++++++++++++++++
 1 files changed, 1256 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx3/mx31pdk_gpio.c

diff --git a/arch/arm/mach-mx3/mx31pdk_gpio.c b/arch/arm/mach-mx3/mx31pdk_gpio.c
new file mode 100644
index 0000000..a59d6d2
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31pdk_gpio.c
@@ -0,0 +1,1256 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-types.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <mach/iomux-mx3.h>
+#include <asm/plat-mxc/pmic_adc.h>
+
+void gpio_keypad_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for keypad signals.
+	 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL2,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL3,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW2,
+				IOMUX_CONFIG_FUNC));
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+void gpio_keypad_inactive(void)
+{
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL0,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL1,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL2,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL3,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW0,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW1,
+				IOMUX_CONFIG_GPIO));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW2,
+				IOMUX_CONFIG_GPIO));
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+void gpio_power_key_active(void)
+{
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_2,
+				IOMUX_CONFIG_GPIO));
+
+	if (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO1_2),
+				"mxc_pmic_pm_key"))
+		gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO1_2));
+	else {
+		pr_err("mxc_pmic_pm_key: Failed to request gpio\n");
+		return;
+	}
+
+	mxc_iomux_set_pad(MX31_PIN_GPIO1_2, PAD_CTL_PKE_NONE);
+}
+EXPORT_SYMBOL(gpio_power_key_active);
+
+void gpio_lcd_active(void)
+{
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD2,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD3,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD4,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD5,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD6,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD7,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD8,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD9,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD10,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD11,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD12,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD13,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD14,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD15,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD16,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LD17,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_VSYNC3,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_HSYNC,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_FPSHIFT,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CONTRAST,
+				IOMUX_CONFIG_FUNC));
+
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LCS1,
+				IOMUX_CONFIG_NORMAL));
+	if (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_LCS1),
+				"mxc_sdc_fb")) {
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+		/* do reset */
+		mdelay(10); /* tRES >= 100us */
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 1);
+	} else {
+		pr_err("mxc_sdc_fb: Failed to request gpio\n");
+		return;
+	}
+
+	/* enable data */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SER_RS,
+				IOMUX_CONFIG_NORMAL));
+	if (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_SER_RS),
+				"mxc_sdc_fb"))
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_SER_RS), 1);
+	else {
+		pr_err("mxc_sdc_fb: Failed to request gpio\n");
+		gpio_free(IOMUX_TO_GPIO(MX31_PIN_LCS1));
+		return;
+	}
+}
+EXPORT_SYMBOL(gpio_lcd_active);
+
+void gpio_lcd_inactive(void)
+{
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_SER_RS), 0);
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_SER_RS));
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_LCS1));
+}
+EXPORT_SYMBOL(gpio_lcd_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+			/* SPI1 */
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MOSI,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MISO,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SCLK,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SPI_RDY,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS0,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS1,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS2,
+						IOMUX_CONFIG_FUNC));
+			break;
+	case 1:
+			/* SPI2 */
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MOSI,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MISO,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SCLK,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SPI_RDY,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS0,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS1,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS2,
+						IOMUX_CONFIG_FUNC));
+			break;
+	case 2:
+			/* SPI3 */
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_MOSI,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_MISO,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_SCLK,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_SPI_RDY,
+						IOMUX_CONFIG_FUNC));
+			/* FIXME: According to Datasheet,
+			 * SPI3 has no own SS pins, it uses
+			 * multiplexed SS pins of SPI1 and SPI2.
+			 * Still have to confirm this */
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS0,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS1,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS0,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS2,
+						IOMUX_CONFIG_FUNC));
+			break;
+	default:
+			pr_err("not valid spi id\n");
+	}
+}
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MOSI,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MISO,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SCLK,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SPI_RDY,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS0,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS1,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS2,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	case 1:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MOSI,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MISO,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SCLK,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SPI_RDY,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS0,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS1,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS2,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	case 2:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_MOSI,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_MISO,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_SCLK,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI3_SPI_RDY,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * This function configures the IOMux block
+ * for PMIC standard operations.
+ */
+
+void gpio_pmic_active(void)
+{
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_3,
+				IOMUX_CONFIG_GPIO));
+	gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO1_3));
+}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_I2C_CLK,
+						IOMUX_CONFIG_FUNC));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_I2C_DAT,
+						IOMUX_CONFIG_FUNC));
+			break;
+	case 1:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MOSI,
+						IOMUX_CONFIG_ALT1));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MISO,
+						IOMUX_CONFIG_ALT1));
+			break;
+	case 2:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS2,
+						IOMUX_CONFIG_ALT1));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SCLK,
+						IOMUX_CONFIG_ALT1));
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_I2C_CLK,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_I2C_DAT,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	case 1:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MOSI,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MISO,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	case 2:
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SS2,
+						IOMUX_CONFIG_NORMAL));
+			mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_SCLK,
+						IOMUX_CONFIG_NORMAL));
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ *  * Setup GPIO for SDHC to be active
+ *   *
+ *    * @param module SDHC module number
+ *     */
+void gpio_sdhc_active(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA3,
+					IOMUX_CONFIG_FUNC));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA2,
+					IOMUX_CONFIG_FUNC));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA1,
+					IOMUX_CONFIG_FUNC));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA0,
+					IOMUX_CONFIG_FUNC));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_FUNC));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CMD,
+					IOMUX_CONFIG_FUNC));
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+		/*
+		 * Active the Buffer Enable Pin only if there is
+		 * a card in slot.
+		 * To fix the card voltage issue caused by
+		 * bi-directional chip TXB0108 on 3Stack
+		 */
+		if (gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1)))
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		else
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 1);
+		break;
+	case 1:
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_CD2_B,
+					IOMUX_CONFIG_ALT1));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_CD1_B,
+					IOMUX_CONFIG_ALT1));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_WAIT_B,
+					IOMUX_CONFIG_ALT1));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_READY,
+					IOMUX_CONFIG_ALT1));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_VS1,
+					IOMUX_CONFIG_ALT1));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_PWRON,
+					IOMUX_CONFIG_ALT1));
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CMD,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA0,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA1,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA2,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_DATA3,
+					IOMUX_CONFIG_NORMAL));
+
+		/* Buffer Enable Pin of SD, Active HI */
+		gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		break;
+	case 1:
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_CD2_B,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_CD1_B,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_NORMAL));
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD1_CLK,
+					IOMUX_CONFIG_NORMAL));
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(
+				IOMUX_TO_GPIO(MX31_PIN_GPIO3_1));
+		/*
+		 * Active the Buffer Enable Pin only if there is
+		 * a card in slot.
+		 * To fix the card voltage issue caused by
+		 * bi-directional chip TXB0108 on 3Stack
+		 */
+		if (ret)
+			gpio_set_value(
+					IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		else
+			gpio_set_value(
+					IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 1);
+		return ret;
+	} else
+		return gpio_get_value(
+				IOMUX_TO_GPIO(MX31_PIN_GPIO1_2));
+}
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	int ret = 0;
+	if (id == 0) {
+		/* Buffer Enable Pin, Active HI */
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO3_0,
+					IOMUX_CONFIG_NORMAL));
+
+		ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0),
+				"mxc_sdhc");
+		if (!ret)
+			gpio_direction_output(
+					IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		else {
+			pr_err("mxc_sdhc: Failed to request gpio\n");
+			return ret;
+		}
+
+		/* CD Pin */
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO3_1,
+					IOMUX_CONFIG_GPIO));
+		mxc_iomux_set_pad(MX31_PIN_GPIO3_1,
+				PAD_CTL_PKE_NONE);
+
+		ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1),
+				"mxc_sdhc");
+		if (!ret)
+			gpio_direction_input(
+					IOMUX_TO_GPIO(MX31_PIN_GPIO3_1));
+		else {
+			pr_err("mxc_sdhc: Failed to request gpio\n");
+			gpio_free(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0));
+			return ret;
+		}
+
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO3_1);
+	} else {
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_2,
+					IOMUX_CONFIG_GPIO));
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_2);
+	}
+}
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Get SD1_WP ADIN7 of ATLAS pin value to detect write protection
+ */
+int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	pmic_adc_convert(GEN_PURPOSE_AD7, &rc);
+	if (rc > 0)
+		return 1;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(sdhc_write_protect);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+	/*
+	 * Configure the GPR for ATA group B signals
+	 */
+	mxc_iomux_set_gpr(MUX_PGP_ATA_8 | MUX_PGP_ATA_5 |
+			MUX_PGP_ATA_4 | MUX_PGP_ATA_3 |
+			MUX_PGP_ATA_2, false);
+
+	mxc_iomux_set_gpr(MUX_PGP_ATA_9 | MUX_PGP_ATA_7 |
+			MUX_PGP_ATA_6 | MUX_PGP_ATA_1, true);
+
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MOSI,
+				IOMUX_CONFIG_FUNC)); /* ATA_D0 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MISO,
+				IOMUX_CONFIG_FUNC)); /* ATA_D1 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS0,
+				IOMUX_CONFIG_FUNC)); /* ATA_D2 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS1,
+				IOMUX_CONFIG_FUNC)); /* ATA_D3 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS2,
+				IOMUX_CONFIG_FUNC)); /* ATA_D4 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SCLK,
+				IOMUX_CONFIG_FUNC)); /* ATA_D5 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SPI_RDY,
+				IOMUX_CONFIG_FUNC)); /* ATA_D6 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD3,
+				IOMUX_CONFIG_FUNC)); /* ATA_D7 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD3,
+				IOMUX_CONFIG_FUNC)); /* ATA_D8 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK3,
+				IOMUX_CONFIG_FUNC)); /* ATA_D9 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SFS3,
+				IOMUX_CONFIG_FUNC)); /* ATA_D10 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD6,
+				IOMUX_CONFIG_FUNC)); /* ATA_D11 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD6,
+				IOMUX_CONFIG_FUNC)); /* ATA_D12 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK6,
+				IOMUX_CONFIG_FUNC)); /* ATA_D13 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CAPTURE,
+				IOMUX_CONFIG_FUNC)); /* ATA_D14 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_COMPARE,
+				IOMUX_CONFIG_FUNC)); /* ATA_D15 */
+
+	/* Config the multiplex pin of ATA interface
+	   DIR, DA0-2, INTRQ, DMARQ */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL4,
+				IOMUX_CONFIG_FUNC)); /* ATA_DMARQ_B */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW6,
+				IOMUX_CONFIG_FUNC)); /* ATA_INTRQ_B */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL5,
+				IOMUX_CONFIG_FUNC)); /* ATA_DA0 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL6,
+				IOMUX_CONFIG_FUNC)); /* ATA_DA1 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL7,
+				IOMUX_CONFIG_FUNC)); /* ATA_DA2 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW7,
+				IOMUX_CONFIG_FUNC)); /* ATA_BUFFER_DIR */
+
+	/* HDD_ENABLE_B(H:Disable,L:Enable) */
+	if (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_CSI_D4),
+				"mxc_pata"))
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_CSI_D4), 0);
+	else {
+		pr_err("mxc_pata: Failed to request gpio\n");
+		return;
+	}
+	mdelay(10);
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_CS0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_CS1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DIOR,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DIOW,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DMACK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_RESET_B,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PWMO,
+				IOMUX_CONFIG_FUNC));
+
+	/* Need fast slew rate for UDMA mode */
+
+#define ATA_DAT_PAD_CFG (PAD_CTL_SRE_FAST | \
+		PAD_CTL_PKE_NONE | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, ATA_DAT_PAD_CFG); /* data 0 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, ATA_DAT_PAD_CFG); /* data 1 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, ATA_DAT_PAD_CFG); /* data 2 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, ATA_DAT_PAD_CFG); /* data 3 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, ATA_DAT_PAD_CFG); /* data 4 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, ATA_DAT_PAD_CFG); /* data 5 */
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, ATA_DAT_PAD_CFG); /* data 6 */
+	mxc_iomux_set_pad(MX31_PIN_STXD3, ATA_DAT_PAD_CFG); /* data 7 */
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, ATA_DAT_PAD_CFG); /* data 8 */
+	mxc_iomux_set_pad(MX31_PIN_SCK3, ATA_DAT_PAD_CFG);  /* data 9 */
+	mxc_iomux_set_pad(MX31_PIN_SFS3, ATA_DAT_PAD_CFG);  /* data 10 */
+	mxc_iomux_set_pad(MX31_PIN_STXD6, ATA_DAT_PAD_CFG); /* data 11 */
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, ATA_DAT_PAD_CFG); /* data 12 */
+	mxc_iomux_set_pad(MX31_PIN_SCK6, ATA_DAT_PAD_CFG);  /* data 13 */
+	mxc_iomux_set_pad(MX31_PIN_CAPTURE, ATA_DAT_PAD_CFG); /* data 14 */
+	mxc_iomux_set_pad(MX31_PIN_COMPARE, ATA_DAT_PAD_CFG); /* data 15 */
+#undef ATA_DAT_PAD_CFG
+
+#define ATA_CTL_PAD_CFG (PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE)
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL4, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL5, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL6, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL7, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, ATA_CTL_PAD_CFG);
+
+	mxc_iomux_set_pad(MX31_PIN_ATA_CS0, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_CS1, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DIOR, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DIOW, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DMACK, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_RESET_B, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PWMO, ATA_CTL_PAD_CFG);
+#undef ATA_CTL_PAD_CFG
+}
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_CSI_D4));
+	/*
+	 * Turn off ATA group B signals
+	 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MOSI,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D0 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_MISO,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D1 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS0,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D2 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS1,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D3 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SS2,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D4 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SCLK,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D5 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI1_SPI_RDY,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D6 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD3,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D7 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD3,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D8 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK3,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D9 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SFS3,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D10 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD6,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D11 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD6,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D12 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK6,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D13 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CAPTURE,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D14 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_COMPARE,
+				IOMUX_CONFIG_NORMAL)); /* ATA_D15 */
+
+	/* Config the multiplex pin of ATA interface
+	   DIR, DA0-2, INTRQ, DMARQ */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL4,
+				IOMUX_CONFIG_NORMAL));  /* ATA_DMARQ_B */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW6,
+				IOMUX_CONFIG_NORMAL));  /* ATA_INTRQ_B */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL5,
+				IOMUX_CONFIG_NORMAL));  /* ATA_DA0 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL6,
+				IOMUX_CONFIG_NORMAL));  /* ATA_DA1 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_COL7,
+				IOMUX_CONFIG_NORMAL));  /* ATA_DA2 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_KEY_ROW7,
+				IOMUX_CONFIG_NORMAL));  /* ATA_BUFFER_DIR */
+
+	/* HDD_BUFF_EN (H:A->B, L:B->A) and
+	   HDD_ENABLE_B(H:Disable,L:Enable) */
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_CSI_D4));
+
+	/* These ATA pins are common to Group A and Group B */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_CS0,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_CS1,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DIOR,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DIOW,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_DMACK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_ATA_RESET_B,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PWMO,
+				IOMUX_CONFIG_NORMAL));
+
+	/* Needed fast slew rate for UDMA mode */
+
+#define ATA_DAT_PAD_CFG (PAD_CTL_SRE_SLOW | \
+		PAD_CTL_DRV_NORMAL | PAD_CTL_PKE_NONE)
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL4, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL5, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_COL7, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, ATA_DAT_PAD_CFG);
+
+	mxc_iomux_set_pad(MX31_PIN_ATA_CS0, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_CS1, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DIOR, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DIOW, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_DMACK, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_ATA_RESET_B, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PWMO, ATA_DAT_PAD_CFG);
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_STXD3, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SCK3, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SFS3, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_STXD6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SCK6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_CAPTURE, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_COMPARE, ATA_DAT_PAD_CFG);
+#undef ATA_DAT_PAD_CFG
+}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	int ret = 0;
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_CLK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DIR,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_NXT,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_STP,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DATA0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DATA1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_VS2,
+				IOMUX_CONFIG_ALT1));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_BVD1,
+				IOMUX_CONFIG_ALT1));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_BVD2,
+				IOMUX_CONFIG_ALT1));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_RST,
+				IOMUX_CONFIG_ALT1));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_IOIS16,
+				IOMUX_CONFIG_ALT1));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_RW_B,
+				IOMUX_CONFIG_ALT1));
+
+#define H2_PAD_CFG (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | \
+		PAD_CTL_HYS_CMOS | PAD_CTL_ODE_CMOS | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0, H2_PAD_CFG); /* USBH2_DATA0 */
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1, H2_PAD_CFG); /* USBH2_DATA1 */
+	mxc_iomux_set_pad(MX31_PIN_PC_VS2, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD1, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD2, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PC_RST, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_IOIS16, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_PC_RW_B, H2_PAD_CFG);
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USB_BYP, (IOMUX_OCONFIG_GPIO | \
+					IOMUX_ICONFIG_NONE)));
+
+	ret =
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), "usbh2 bypass");
+	if (ret) {
+		pr_info("usbh2 bypass pin conflict\n");
+		return ret;
+	}
+
+	ret = gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), 0);
+	mdelay(10);
+	ret = gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), 1);
+	return ret;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_USB_BYP));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_VS2,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD1,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD2,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RST,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_IOIS16,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RW_B,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_CLK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DIR,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_NXT,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_STP,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DATA0,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBH2_DATA1,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_VS2,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_BVD1,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_BVD2,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_RST,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_IOIS16,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_PC_RW_B,
+				IOMUX_CONFIG_NORMAL));
+}
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	int ret = 0;
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA2,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA3,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA4,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA5,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA6,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA7,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_CLK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DIR,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_NXT,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_STP,
+				IOMUX_CONFIG_FUNC));
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	/* reset transceiver */
+	ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_USB_PWR),
+			"usbotg hs pwr");
+	if (ret) {
+		pr_err("usbotg hs pwr pin conflict\n");
+		return ret;
+	}
+
+	ret = gpio_direction_output(
+			IOMUX_TO_GPIO(MX31_PIN_USB_PWR), 0);
+	mdelay(1);
+	ret = gpio_direction_output(
+			IOMUX_TO_GPIO(MX31_PIN_USB_PWR), 1);
+
+	return ret;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA0,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA1,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA2,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA3,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA4,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA5,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA6,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA7,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_CLK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DIR,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_NXT,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_STP,
+				IOMUX_CONFIG_NORMAL));
+
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_USB_PWR));
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*!
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA0,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA1,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA2,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA3,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA4,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA5,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA6,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA7,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_CLK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DIR,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_NXT,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_STP,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USB_PWR,
+				IOMUX_CONFIG_FUNC));
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA0,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA1,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA2,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA3,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA4,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA5,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA6,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DATA7,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_CLK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_DIR,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_NXT,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USBOTG_STP,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_USB_PWR,
+				IOMUX_CONFIG_NORMAL));
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	int ret = 0;
+
+	ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_CSI_D5), "ov2640");
+	if (!ret) {
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D5,
+					IOMUX_OCONFIG_GPIO |
+					IOMUX_ICONFIG_NONE));
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_CSI_D5), 0);
+	} else
+		pr_err("ov2640: Failed to request gpio\n");
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D6,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D7,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D8,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D9,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D10,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D11,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D12,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D13,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D14,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D15,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_HSYNC,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_MCLK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_PIXCLK,
+				IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_VSYNC,
+				IOMUX_CONFIG_FUNC));
+
+	ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO), "ov2640");
+	if (!ret) {
+		mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SD_D_IO,
+					IOMUX_OCONFIG_GPIO |
+					IOMUX_ICONFIG_NONE));
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO), 1);
+	} else {
+		pr_info("ov2640: Failed to request gpio\n");
+		gpio_free(IOMUX_TO_GPIO(MX31_PIN_CSI_D5));
+	}
+}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(void)
+{
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_CSI_D5));
+	gpio_free(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO));
+
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D6,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D7,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D8,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D9,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D10,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D11,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D12,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D13,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D14,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_D15,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_HSYNC,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_MCLK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_PIXCLK,
+				IOMUX_CONFIG_NORMAL));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSI_VSYNC,
+				IOMUX_CONFIG_NORMAL));
+}
+EXPORT_SYMBOL(gpio_sensor_inactive);
-- 
1.6.3.1

