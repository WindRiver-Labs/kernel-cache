From e435aa213afe02eac46627043aa29aafe8020108 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Tue, 23 Jun 2009 11:32:59 +0800
Subject: [PATCH 13/13] fsl_imx31pdk: update usb to support host2 and OTG

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Two main update, Add power regulator control for
GPO1/3 which  control usb vbus powersupply and adapt usb device
platform data to latest imx series usb common parts.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Makefile |    2 +-
 arch/arm/mach-mx3/usb.c    |   65 ++++++++++++++++++++++++++++++++++++-------
 2 files changed, 55 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 9d9c450..9e2d343 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -9,7 +9,7 @@ obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o mx31_gpio.o
 obj-$(CONFIG_MACH_MX31_3DS) += mx31pdk.o mx31pdk_gpio.o
 obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
-obj-$(CONFIG_USB_EHCI_ARC)  += usb.o
+obj-$(CONFIG_USB)  += usb.o
 
 obj-$(CONFIG_MXC_DVFS)      += dvfs.o
 
diff --git a/arch/arm/mach-mx3/usb.c b/arch/arm/mach-mx3/usb.c
index 4450d56..eabcbe6 100644
--- a/arch/arm/mach-mx3/usb.c
+++ b/arch/arm/mach-mx3/usb.c
@@ -35,6 +35,7 @@
 #include <linux/platform_device.h>
 #include <linux/usb/otg.h>
 #include <linux/delay.h>
+#include <linux/fsl_devices.h>
 
 #include <linux/io.h>
 #include <asm/irq.h>
@@ -48,11 +49,14 @@
 #include <mach/clock.h>
 #include <mach/isp1504.h>
 #include <asm/plat-mxc/mxc_timer.h>
+#include <asm/plat-mxc/pmic_power.h>
 
 #include "crm_regs.h"
 
+#ifndef CONFIG_MACH_MX31_3DS
 #define PBC3_CLEAR	(PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR)
 #define PBC3_SET	(PBC_BASE_ADDRESS + PBC_BCTRL3_SET)
+#endif
 
 #undef VERBOSE
 
@@ -231,6 +235,13 @@ static void otg_hs_set_xcvr(void)
 {
 	u32 tmp;
 
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+	USBCTRL &= ~UCTRL_BPE;
+
+	USBCTRL |= UCTRL_OUIE | /* ULPI intr enable */
+		UCTRL_OWIE |    /* OTG wakeup intr enable */
+		UCTRL_OPM;      /* power mask */
+
 	/* set ULPI xcvr */
 	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
 	tmp |= PORTSC_PTS_ULPI;
@@ -257,6 +268,7 @@ static int otg_hs_init(void)
 		if (gpio_usbotg_hs_active())	/* grab our pins */
 			return -EINVAL;
 
+#ifndef CONFIG_MACH_MX31_3DS
 		if (machine_is_mx31ads()) {
 			/* enable OTG/HS */
 			__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
@@ -264,6 +276,7 @@ static int otg_hs_init(void)
 			/* disable OTG/FS */
 			__raw_writew(PBC_BCTRL3_OTG_FS_EN, PBC3_SET);
 		}
+#endif
 
 		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
 		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
@@ -284,8 +297,10 @@ static void otg_hs_uninit(void)
 
 	otg_used--;
 	if (!otg_used) {
+#ifndef CONFIG_MACH_MX31_3DS
 		/* disable  OTG/HS */
 		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_SET);
+#endif
 
 		dbg("free OTG-HS pins");
 		gpio_usbotg_hs_inactive();	/* release our pins */
@@ -318,6 +333,8 @@ static struct arc_usb_config otg_hs_host_config = {
 	.usbmode         = (u32) &UOG_USBMODE,
 	.does_otg        = 1,
 	.power_budget    = 150,		/* 150 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
 };
 /* *INDENT-ON* */
 
@@ -325,7 +342,8 @@ static struct platform_device *otg_hs_host_device;
 #endif	/* CONFIG_USB_EHCI_ARC_OTGHS */
 #endif	/* CONFIG_USB_EHCI_ARC_OTGHS || CONFIG_USB_GADGET_ARC_OTGHS */
 
-#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || defined(CONFIG_USB_EHCI_ARC_OTGFS)
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || \
+	defined(CONFIG_USB_EHCI_ARC_OTGFS) || defined(CONFIG_USB_GADGET_ARC_OTG)
 /* *INDENT-OFF* */
 static struct resource otg_resources[] = {
 	{
@@ -442,6 +460,7 @@ static int usbh1_init(void)
 	if (gpio_usbh1_active())
 		return -EINVAL;
 
+#ifndef CONFIG_MACH_MX31_3DS
 	if (machine_is_mx31ads()) {
 		__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_CLEAR);	/* enable FSH */
 		__raw_writew(PBC_BCTRL3_FSH_SEL, PBC3_SET);	/* Group B */
@@ -450,6 +469,8 @@ static int usbh1_init(void)
 		/* enable FSH VBUS */
 		__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);
 	}
+#endif
+
 	/* disable bypass mode */
 	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);
 	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
@@ -467,12 +488,14 @@ static void usbh1_uninit(void)
 {
 	dbg();
 
+#ifndef CONFIG_MACH_MX31_3DS
 	if (machine_is_mx31ads()) {
 		/* disable FSH */
 		__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_SET);
 		/* disable FSH VBUS */
 		__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_SET);
 	}
+#endif
 
 	if (!(--usb_clk_cnt)) {
 		clk_disable(usb_clk);
@@ -523,6 +546,11 @@ static int usbh2_init(void)
 	if (check_usbclk() != 0)
 		return -EINVAL;
 
+#ifdef CONFIG_MACH_MX31_3DS
+	/* power on the GPO1/3 */
+	pmic_power_regulator_on(REGU_GPO1);
+	pmic_power_regulator_on(REGU_GPO3);
+#else
 	if (machine_is_mx31ads()) {
 		/* abort the init if NAND card is present */
 		if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT1) &
@@ -544,23 +572,28 @@ static int usbh2_init(void)
 			return -EINVAL;
 		}
 	}
+#endif
 
 	if (gpio_usbh2_active())	/* grab our pins */
 		return -EINVAL;
 
+#ifndef CONFIG_MACH_MX31_3DS
 	if (machine_is_mx31ads()) {
 		/* enable HSH select */
 		__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_SET);
 		/* enable HSH */
 		__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);
 	}
+#endif
 
 	usbh2_set_xcvr();	/* set transceiver type */
 
+#ifndef CONFIG_MACH_MX31_3DS
 	if (machine_is_mx31lite()) {
 		usbh2_set_vbus_power(true);
 		barrier();
 	}
+#endif
 
 	/* disable bypass mode */
 	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
@@ -579,12 +612,18 @@ static void usbh2_uninit(void)
 {
 	dbg();
 
+#ifdef CONFIG_MACH_MX31_3DS
+	/* power off the GPO1/3 */
+	pmic_power_regulator_off(REGU_GPO1);
+	pmic_power_regulator_off(REGU_GPO3);
+#else
 	if (!machine_is_mx31lite()) {
 		/* disable HSH select */
 		__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_CLEAR);
 		/* disable HSH */
 		__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_SET);
 	}
+#endif
 
 	if (!(--usb_clk_cnt)) {
 		clk_disable(usb_clk);
@@ -610,6 +649,8 @@ static struct arc_usb_config usbh2_config = {
 	.xcvr_type       = PORTSC_PTS_ULPI,
 	.usbmode         = (u32) &UH2_USBMODE,
 	.power_budget    = 150,		/* 150 mA max power */
+	.suspended       = 0,
+	.already_suspended = 0,
 };
 
 static struct resource usbh2_resources[] = {
@@ -630,13 +671,10 @@ static struct platform_device *usbh2_device;
 #ifdef CONFIG_USB_GADGET_ARC
 #ifdef CONFIG_USB_GADGET_ARC_OTGHS
 /* *INDENT-OFF* */
-static struct arc_usb_config udc_hs_config = {
-	.name            = "OTG HS Gadget",
+static struct fsl_usb2_platform_data udc_hs_config = {
 	.platform_init   = otg_hs_init,
 	.platform_uninit = otg_hs_uninit,
-	.set_vbus_power  = otg_hs_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_ULPI,
-	.usbmode         = (u32) &UOG_USBMODE,
+	.phy_mode = FSL_USB2_PHY_ULPI,
 };
 /* *INDENT-ON* */
 #endif
@@ -713,7 +751,7 @@ static void usb_release(struct device *dev)
 static u64 udc_dmamask = ~(u32)0;
 /* *INDENT-OFF* */
 static struct platform_device udc_device = {
-	.name = "arc_udc",
+	.name = "fsl-usb2-udc",
 	.id   = -1,
 	.dev  = {
 		.release           = usb_release,
@@ -768,16 +806,21 @@ static void isp1504_release(struct device *dev)
 }
 
 /* *INDENT-OFF* */
-static struct arc_xcvr_config isp1504_config = {
+static struct fsl_usb2_platform_data isp1504_config = {
 	.name            = "isp1504",
 	.platform_init   = otg_hs_init,
 	.platform_uninit = otg_hs_uninit,
-	.regs            = (void *)&UOG_ID,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 500,       /* 500 mA max power */
 };
 
 static struct resource isp1504_resources[] = {
 	{
-		.start = INT_USB3,
+		.start = (u32) (USB_OTGREGS_BASE),
+		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -870,7 +913,7 @@ static inline void fixup_usb_pll(void)
 
 static int __init mx3_usb_init(void)
 {
-#if defined(CONFIG_USB_OTG)
+#if defined(CONFIG_USB_OTG) || defined(CONFIG_USB_GADGET_ARC)
 	int rc;
 #endif
 
-- 
1.6.3.1

