From 3e553b2e1619cc1d40bf24a598612b41ce8d242b Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Tue, 23 Jun 2009 11:32:57 +0800
Subject: [PATCH 11/13] fsl_imx31pdk: add board specific stuff

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Add fsl_imx31pdk board specific items in Kconfig ,Makefile.And
add board init routine, on-board peripherals registry.
In SPI driver,  catenate "cspi_clk" and pdev->id to get device clock,
the clock name index starts from 0, so update spi device id to match this.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Kconfig                      |   14 +
 arch/arm/mach-mx3/Makefile                     |    1 +
 arch/arm/mach-mx3/devices.c                    |   10 +-
 arch/arm/mach-mx3/mx31pdk.c                    |  692 ++++++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/board-mx31pdk.h |   69 +++
 5 files changed, 781 insertions(+), 5 deletions(-)
 create mode 100644 arch/arm/mach-mx3/mx31pdk.c
 create mode 100644 arch/arm/plat-mxc/include/mach/board-mx31pdk.h

diff --git a/arch/arm/mach-mx3/Kconfig b/arch/arm/mach-mx3/Kconfig
index db9431d..8114cdc 100644
--- a/arch/arm/mach-mx3/Kconfig
+++ b/arch/arm/mach-mx3/Kconfig
@@ -21,5 +21,19 @@ config MACH_MX31LITE
 	  Include support for MX31 LITEKIT platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX31_3DS
+	bool "Support MX31PDK (3DS)"
+	default n
+	help
+	  Include support for MX31PDK (3DS) platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MXC_SDMA_API
+	bool "Use SDMA API"
+	default y
+	help
+	  Select this to enable the Freescale MXC SDMA API.
+	  If unsure, say N.
+
 endmenu
 
diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 486cce5..9d9c450 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -7,6 +7,7 @@
 obj-y			:= mm.o clock.o devices.o iomux.o cpu.o dma.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o mx31_gpio.o
+obj-$(CONFIG_MACH_MX31_3DS) += mx31pdk.o mx31pdk_gpio.o
 obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
 obj-$(CONFIG_USB_EHCI_ARC)  += usb.o
 
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index a523702..b68cf46 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -377,13 +377,13 @@ int __init mxc_init_mmc(void)
 #if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
 static int mxc_spi_active(struct platform_device *pdev)
 {
-	gpio_spi_active(pdev->id - 1);
+	gpio_spi_active(pdev->id);
 	return 0;
 }
 
 static int mxc_spi_inactive(struct platform_device *pdev)
 {
-	gpio_spi_inactive(pdev->id - 1);
+	gpio_spi_inactive(pdev->id);
 	return 0;
 }
 #ifdef CONFIG_SPI_MXC_SELECT1
@@ -415,7 +415,7 @@ static struct mxc_spi_master mxc_spi1_data = {
 /*! Device Definition for MXC CSPI1 */
 static struct platform_device mxc_spi1_device = {
 	.name = "mxc_spi",
-	.id = 1,
+	.id = 0,
 	.dev = {
 		.platform_data = &mxc_spi1_data,
 	},
@@ -453,7 +453,7 @@ static struct mxc_spi_master mxc_spi2_data = {
 /*! Device Definition for MXC CSPI2 */
 static struct platform_device mxc_spi2_device = {
 	.name = "mxc_spi",
-	.id = 2,
+	.id = 1,
 	.dev = {
 		.platform_data = &mxc_spi2_data,
 	},
@@ -492,7 +492,7 @@ static struct mxc_spi_master mxc_spi3_data = {
 /*! Device Definition for MXC CSPI3 */
 static struct platform_device mxc_spi3_device = {
 	.name = "mxc_spi",
-	.id = 3,
+	.id = 2,
 	.dev = {
 		.platform_data = &mxc_spi3_data,
 	},
diff --git a/arch/arm/mach-mx3/mx31pdk.c b/arch/arm/mach-mx3/mx31pdk.c
new file mode 100644
index 0000000..135a1dd
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31pdk.c
@@ -0,0 +1,692 @@
+/*
+ *  Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2009 WindRiver System, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/gpio.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/memory.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/smc911x.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/regulator/regulator-platform.h>
+#include <linux/regulator/regulator.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/iomux-mx3.h>
+#include <mach/imx-uart.h>
+#include <mach/mxc_nand.h>
+
+#include <asm/plat-mxc/pmic_power.h>
+#include <asm/plat-mxc/pmic_adc.h>
+#include <asm/plat-mxc/mxc_mci.h>
+
+#include "crm_regs.h"
+
+/*!
+ * @file mx31pdk.c
+ *
+ * @brief This file contains the board-specific
+ * initialization routines.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * This structure defines static mappings for the i.MX31PDK board.
+ */
+static struct map_desc mx31pdk_io_desc[] __initdata = {
+	{
+		.virtual    = AIPS1_BASE_ADDR_VIRT,
+		.pfn        = __phys_to_pfn(AIPS1_BASE_ADDR),
+		.length     = AIPS1_SIZE,
+		.type       = MT_DEVICE_NONSHARED
+	}, {
+		.virtual = SPBA0_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+		.length = SPBA0_SIZE,
+		.type = MT_DEVICE_NONSHARED
+	}, {
+		.virtual    = AIPS2_BASE_ADDR_VIRT,
+		.pfn        = __phys_to_pfn(AIPS2_BASE_ADDR),
+		.length     = AIPS2_SIZE,
+		.type       = MT_DEVICE_NONSHARED
+	}, {
+		.virtual = CS4_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(CS4_BASE_ADDR),
+		.length = CS4_SIZE,
+		.type = MT_DEVICE
+	}
+};
+
+/*!
+ * Set up static virtual mappings.
+ */
+static void __init mx31pdk_map_io(void)
+{
+	mxc_map_io();
+	iotable_init(mx31pdk_io_desc, ARRAY_SIZE(mx31pdk_io_desc));
+}
+
+static int __init mxc_init_regulator(void)
+{
+	int err;
+	struct regulator *gpo1;
+	struct regulator *gpo2;
+	struct regulator *gpo3;
+	struct regulator *gpo4;
+
+	gpo1 = regulator_get(NULL, "GPO1");
+	gpo2 = regulator_get(NULL, "GPO2");
+	gpo3 = regulator_get(NULL, "GPO3");
+	gpo4 = regulator_get(NULL, "GPO4");
+
+	err = regulator_set_platform_source(gpo2, gpo1);
+	if (err)
+		printk(KERN_ERR "Unable to set GPO1 be the"
+				"parent of GPO2\n");
+
+	err = regulator_set_platform_source(gpo3, gpo1);
+	if (err)
+		printk(KERN_ERR "Unable to set GPO1 be the"
+				"parent of GPO3\n");
+
+	err = regulator_set_platform_source(gpo4, gpo1);
+	if (err)
+		printk(KERN_ERR "Unable to set GPO1 be the"
+				"parent of GPO4\n");
+
+	return 0;
+}
+
+module_init(mxc_init_regulator);
+
+#if defined(CONFIG_KEYBOARD_MXC) || \
+	defined(CONFIG_KEYBOARD_MXC_MODULE)
+static u16 keymapping[12] = {
+	KEY_UP, KEY_DOWN, 0, 0,
+	KEY_RIGHT, KEY_LEFT, KEY_ENTER, 0,
+	KEY_F6, KEY_F8, KEY_F9, KEY_F10,
+};
+
+static struct resource keypad_resources[] = {
+	{
+		.start = MXC_INT_KPP,
+		.end = MXC_INT_KPP,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct mxc_keypad_platform_data keypad_plat_data = {
+	.rowmax = 3,
+	.colmax = 4,
+	.irq = MXC_INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+static struct platform_device mx31pdk_keypad = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(keypad_resources),
+	.resource = keypad_resources,
+	.dev = {
+		.platform_data = &keypad_plat_data,
+	},
+};
+#endif
+
+/* MTD NAND flash */
+#if defined(CONFIG_MTD_NAND_MXC) || \
+	defined(CONFIG_MTD_NAND_MXC_MODULE)
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+		.name = "nand.bootloader",
+		.offset = 0,
+		.size = 1024 * 1024},
+	{
+		.name = "nand.kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 5 * 1024 * 1024},
+	{
+		.name = "nand.configure",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 8 * 1024 * 1024},
+	{
+		.name = "nand.rootfs",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct mxc_nand_platform_data mxc_nand_plat_data = {
+	.width = 1,
+	.hw_ecc = 1,
+	.flash_data = &mxc_nand_data,
+};
+
+static struct resource mxc_nand_resources[] = {
+	{
+		.start  = NFC_BASE_ADDR,
+		.end    = NFC_BASE_ADDR + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = MXC_INT_NANDFC,
+		.end    = MXC_INT_NANDFC,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_nand_plat_data,
+	},
+	.num_resources = 2,
+	.resource = mxc_nand_resources,
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	(void)platform_device_register(&mxc_nand_mtd_device);
+}
+#endif
+
+static u32 brd_io;
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr_val;
+	u32 int_valid;
+	u32 expio_irq;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr_val = __raw_readw(brd_io + INTR_MASK_REG);
+	int_valid = __raw_readw(brd_io + INTR_STATUS_REG) & ~imr_val;
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irq_desc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		d->handle_irq(expio_irq, d);
+	}
+
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* mask the interrupt */
+	__raw_writew(1 << expio, brd_io + INTR_MASK_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the
+ * bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u16 reg;
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* unmask the interrupt */
+	reg = __raw_readw(brd_io + INTR_MASK_REG);
+	reg &= ~(1 << expio);
+	__raw_writew(reg, brd_io + INTR_MASK_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	brd_io = (u32) ioremap(BOARD_IO_ADDR, SZ_4K);
+
+	if (brd_io == 0)
+		return -ENOMEM;
+
+	if ((__raw_readw(brd_io + MAGIC_NUMBER1_REG) != 0xAAAA) ||
+			(__raw_readw(brd_io + MAGIC_NUMBER2_REG) != 0x5555) ||
+			(__raw_readw(brd_io + MAGIC_NUMBER3_REG) != 0xCAFE)) {
+		iounmap((void *)brd_io);
+		brd_io = 0;
+		return -ENODEV;
+	}
+
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n",
+			readw(brd_io + CPLD_CODE_VER_REG));
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_1,
+				IOMUX_CONFIG_GPIO));
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0, brd_io + INTR_MASK_REG);
+	__raw_writew(0xFFFF, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	__raw_writew(0x1F, brd_io + INTR_MASK_REG);
+
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE +
+				MXC_MAX_EXP_IO_LINES); i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	set_irq_type(EXPIO_PARENT_INT, IRQ_TYPE_LEVEL_LOW);
+	set_irq_chained_handler(EXPIO_PARENT_INT,
+			mxc_expio_irq_handler);
+
+	return 0;
+}
+
+#if (defined(CONFIG_MXC_PMIC_MC13783) || \
+		defined(CONFIG_MXC_PMIC_MC13783_MODULE)) \
+&& (defined(CONFIG_SND_MXC_PMIC) || \
+		defined(CONFIG_SND_MXC_PMIC_MODULE))
+static void __init mxc_init_pmic_audio(void)
+{
+	struct clk *ckih_clk;
+	struct clk *cko_clk;
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	ckih_clk = clk_get(NULL, "ckih");
+	cko_clk = clk_get(NULL, "cko1_clk");
+
+	if (IS_ERR(ckih_clk) || IS_ERR(cko_clk))
+		printk(KERN_ERR "Unable to set CKO1 output to CKIH\n");
+	else {
+		clk_set_parent(cko_clk, ckih_clk);
+		clk_set_rate(cko_clk, clk_get_rate(ckih_clk));
+		clk_enable(cko_clk);
+	}
+
+	clk_put(ckih_clk);
+	clk_put(cko_clk);
+
+	/* config Audio ports (4 & 5) */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK4, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD4, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD4, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SFS4, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SCK5, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SRXD5, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_STXD5, IOMUX_CONFIG_FUNC));
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_SFS5, IOMUX_CONFIG_FUNC));
+}
+#endif
+
+static struct resource smc911x_resources[] = {
+	{
+		.start = CS5_BASE_ADDR,
+		.end = CS5_BASE_ADDR + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = LAN9217_IRQ,
+		.end = LAN9217_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mx31pdk_eth = {
+	.name = "smsc911x",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(smc911x_resources),
+	.resource = smc911x_resources,
+};
+
+#if defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_MODULE)
+static void lcd_reset(void)
+{
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_LCS1,
+				IOMUX_OCONFIG_GPIO | IOMUX_ICONFIG_NONE));
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+
+	/* do reset */
+	msleep(10);	/* tRES >= 100us */
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 1);
+	msleep(60);
+}
+
+static struct mxc_lcd_platform_data lcd_data = {
+	.io_reg = "VGEN",
+	.core_reg = "VMMC1",
+	.reset = lcd_reset,
+};
+#endif /*CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL*/
+
+#if defined(CONFIG_SPI_MXC) || \
+	defined(CONFIG_SPI_MXC_MODULE)
+/* An example spi device on spi1 using spidev driver */
+static struct spi_board_info mx31pdk_spi_board_info[] __initdata = {
+	{
+		.modalias = "pmic_spi",
+		.irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_3),
+		.max_speed_hz = 4000000,
+		.bus_num = 1,
+		.chip_select = 2,
+	},
+#if defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_MODULE)
+	{
+		.modalias = "lcd_spi",
+		.max_speed_hz = 5000000,
+		.bus_num = 0,
+		.chip_select = 2,
+		.platform_data = (void *)&lcd_data,
+	}
+#endif
+};
+#endif /* CONFIG_SPI_MXC */
+
+#if defined(CONFIG_VIDEO_MXC_CAMERA) || \
+	defined(CONFIG_VIDEO_MXC_CAMERA_MODULE)
+static struct mxc_camera_platform_data ov2640_data = {
+	.core_regulator = "VVIB",
+	.io_regulator = "VMMC1",
+	.analog_regulator = "SW2B_NORMAL",
+	.gpo_regulator = "GPO3",
+	.mclk = 27000000,
+};
+#endif /* CONFIG_VIDEO_MXC_CAMERA */
+
+#if defined(CONFIG_FB_MXC_TVOUT_CH7024) || \
+	defined(CONFIG_FB_MXC_TVOUT_CH7024_MODULE)
+struct mxc_tvout_platform_data ch7024_data = {
+	.io_reg = "VGEN",
+	.core_reg = "GPO3",
+	.analog_reg = "GPO1",
+	.detect_line = IOMUX_TO_GPIO(MX31_PIN_BATT_LINE),
+};
+#endif /* CONFIG_FB_MXC_TVOUT_CH7024 */
+
+#if defined(CONFIG_I2C_MXC) || \
+	defined(CONFIG_I2C_MXC_MODULE)
+static struct i2c_board_info mx31pdk_i2c_devices[] = {
+#if defined(CONFIG_VIDEO_MXC_CAMERA) || \
+	defined(CONFIG_VIDEO_MXC_CAMERA_MODULE)
+	{
+		I2C_BOARD_INFO("ov2640", 0x30),
+		.type = "ov2640",
+		.platform_data = (void *)&ov2640_data,
+	},
+#endif
+#if defined(CONFIG_FB_MXC_TVOUT_CH7024) || \
+	defined(CONFIG_FB_MXC_TVOUT_CH7024_MODULE)
+	{
+		I2C_BOARD_INFO("ch7024", 0x76),
+		.type = "ch7024",
+		.platform_data = (void *)&ch7024_data,
+		.irq = IOMUX_TO_IRQ(MX31_PIN_BATT_LINE),
+	},
+#endif
+};
+#endif /*CONFIG_I2C_MXC*/
+
+#if defined(CONFIG_FB_MXC) || \
+	defined(CONFIG_FB_MXC_MODULE)
+static const char fb_default_mode[] = "Epson-VGA";
+
+static struct platform_device mx31pdk_fb = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+};
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXC) || \
+	defined(CONFIG_BACKLIGHT_MXC_MODULE)
+static struct platform_device mx31pdk_bl = {
+	.name = "mxc_ipu_bl",
+	.id = 0,
+	.dev = {
+		/* DISP #3 for this backlight */
+		.platform_data = (void *)3,
+	},
+};
+#endif
+
+static struct platform_device *devices[] __initdata = {
+	&mx31pdk_eth,
+#if defined(CONFIG_FB_MXC) || \
+	defined(CONFIG_FB_MXC_MODULE)
+	&mx31pdk_fb,
+#endif
+#if defined(CONFIG_BACKLIGHT_MXC) || \
+	defined(CONFIG_BACKLIGHT_MXC_MODULE)
+	&mx31pdk_bl,
+#endif
+#if defined(CONFIG_KEYBOARD_MXC) || \
+	defined(CONFIG_KEYBOARD_MXC_MODULE)
+	&mx31pdk_keypad,
+#endif
+};
+
+static struct imxuart_platform_data mxc_uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mx31pdk_board_init(void)
+{
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CS5, IOMUX_CONFIG_FUNC));
+
+	imx_init_uart(0, &mxc_uart_pdata);
+
+	mxc_expio_init();
+#if defined(CONFIG_MTD_NAND_MXC) || \
+	defined(CONFIG_MTD_NAND_MXC_MODULE)
+	mxc_init_nand_mtd();
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXC) || \
+	defined(CONFIG_RTC_DRV_MXC_MODULE)
+	mxc_init_rtc();
+#endif
+#if defined(CONFIG_MXC_WATCHDOG) || \
+	defined(CONFIG_MXC_WATCHDOG_MODULE)
+	mxc_init_wdt();
+#endif
+
+#if defined(CONFIG_SPI_MXC) || \
+	defined(CONFIG_SPI_MXC_MODULE)
+	mxc_init_spi();
+	spi_register_board_info(mx31pdk_spi_board_info,
+			ARRAY_SIZE(mx31pdk_spi_board_info));
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_MXC) || \
+	defined(CONFIG_BLK_DEV_IDE_MXC_MODULE)
+	mxc_init_ide();
+#endif
+
+#if defined(CONFIG_SND_MXC_PMIC) || \
+	defined(CONFIG_SND_MXC_PMIC_MODULE)
+	mxc_init_audio();
+	mxc_init_pmic_audio();
+#endif
+
+#if defined(CONFIG_MXC_SSI) || \
+	defined(CONFIG_MXC_SSI_MODULE)
+	mxc_init_ssi();
+#endif
+
+#ifdef CONFIG_I2C_MXC
+	/* only the i2c master 0 is used on this CPU card */
+	i2c_register_board_info(0, mx31pdk_i2c_devices,
+			ARRAY_SIZE(mx31pdk_i2c_devices));
+#endif
+
+#if defined(CONFIG_MMC_MXC) || \
+	defined(CONFIG_MMC_MXC_MODULE)
+	mxc_init_mmc();
+#endif
+
+#if defined(CONFIG_MXC_IPU) || \
+	defined(CONFIG_MXC_IPU_MODULE)
+	mxc_init_ipu();
+#endif
+
+#if defined(CONFIG_MXC_HMP4E) || \
+	defined(CONFIG_MXC_HMP4E_MODULE)
+	mxc_init_hmp4e();
+#endif
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static void __init mx31pdk_timer_init(void)
+{
+	mxc_clocks_init(26000000);
+	mxc_timer_init("ipg_clk.0");
+}
+
+static struct sys_timer mx31pdk_timer = {
+	.init	= mx31pdk_timer_init,
+};
+
+#define PLL_PCTL_REG(pd, mfd, mfi, mfn)		\
+	((((pd) - 1) << 26) + (((mfd) - 1) << 16) + ((mfi)  << 10) + mfn)
+
+/* For 26MHz input clock */
+#define PLL_532MHZ		PLL_PCTL_REG(1, 13, 10, 3)
+#define PLL_399MHZ		PLL_PCTL_REG(1, 52, 7, 35)
+#define PLL_133MHZ		PLL_PCTL_REG(2, 26, 5, 3)
+
+#define PDR0_REG(mcu, max, hsp, ipg, nfc)	\
+	(MXC_CCM_PDR0_MCU_DIV_##mcu | MXC_CCM_PDR0_MAX_DIV_##max | \
+	 MXC_CCM_PDR0_HSP_DIV_##hsp | MXC_CCM_PDR0_IPG_DIV_##ipg | \
+	 MXC_CCM_PDR0_NFC_DIV_##nfc)
+
+/* working point(wp): 0 - 133MHz; 1 - 266MHz; 2 - 399MHz; 3 - 532MHz */
+/* 26MHz input clock table */
+static struct cpu_wp cpu_wp_26[] = {
+	{
+		.pll_reg = PLL_532MHZ,
+		.pll_rate = 532000000,
+		.cpu_rate = 133000000,
+		.pdr0_reg = PDR0_REG(4, 4, 4, 2, 6),
+	},
+	{
+		.pll_reg = PLL_532MHZ,
+		.pll_rate = 532000000,
+		.cpu_rate = 266000000,
+		.pdr0_reg = PDR0_REG(2, 4, 4, 2, 6),
+	},
+	{
+		.pll_reg = PLL_399MHZ,
+		.pll_rate = 399000000,
+		.cpu_rate = 399000000,
+		.pdr0_reg = PDR0_REG(1, 3, 3, 2, 6),
+	},
+	{
+		.pll_reg = PLL_532MHZ,
+		.pll_rate = 532000000,
+		.cpu_rate = 532000000,
+		.pdr0_reg = PDR0_REG(1, 4, 4, 2, 6),
+	},
+};
+
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	*wp = 4;
+	return cpu_wp_26;
+}
+
+/*
+ * The following uses standard kernel macros defined in
+ * arch.h in order to initialize __mach_desc_MX31PDK data structure.
+ */
+MACHINE_START(MX31_3DS, "Freescale MX31PDK (3DS)")
+/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io	= AIPS1_BASE_ADDR,
+	.io_pg_offst	= ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = mx31pdk_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = mx31pdk_board_init,
+	.timer          = &mx31pdk_timer,
+MACHINE_END
diff --git a/arch/arm/plat-mxc/include/mach/board-mx31pdk.h b/arch/arm/plat-mxc/include/mach/board-mx31pdk.h
new file mode 100644
index 0000000..0e058b7
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/board-mx31pdk.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX31PDK_H__
+#define __ASM_ARCH_MXC_BOARD_MX31PDK_H__
+
+/* mandatory for CONFIG_LL_DEBUG */
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define MXC_MAX_EXP_IO_LINES	16
+
+#define BOARD_IO_ADDR		(CS5_BASE_ADDR + 0x20000)
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG		0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+/* interrupts like external uart , external ethernet etc*/
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX31_PIN_GPIO1_1)
+
+#define EXPIO_INT_ENET		(MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_XUART_A 	(MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_XUART_B 	(MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_BUTTON_A 	(MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_BUTTON_B 	(MXC_EXP_IO_BASE + 4)
+
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ	EXPIO_INT_ENET
+
+/* Size of contiguous memory for DMA and other h/w blocks */
+#define CONSISTENT_DMA_SIZE	SZ_16M
+
+/* I2C configuration */
+/*!
+ * This defines the number of I2C modules in the MXC platform
+ * Defined as 1, as MC13783 on ADS uses the other pins
+ */
+#define I2C_NR                  1
+/*!
+ * This define specifies the frequency divider value to be
+ * written into the I2C IFDR register.
+ */
+#define I2C1_FRQ_DIV            0x17
+
+#endif /* __ASM_ARCH_MXC_BOARD_MX31PDK_H__ */
-- 
1.6.3.1

