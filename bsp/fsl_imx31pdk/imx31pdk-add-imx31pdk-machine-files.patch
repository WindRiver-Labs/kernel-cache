From b000aa06eafb574f9dffe1c128e9526e2980d99c Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 27 May 2010 18:47:47 +0800
Subject: [PATCH 5/5] imx31pdk: add imx31pdk machine files

Add imx31pdk machine files, these specific files include support
for board, gpio, and pmic.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-mx3/Makefile                  |    2 +-
 arch/arm/mach-mx3/board-mx3_3stack.h        |  154 ++++
 arch/arm/mach-mx3/mach-mx31_3ds.c           |  455 ++++++++++--
 arch/arm/mach-mx3/mx31pdk_gpio.c            | 1025 +++++++++++++++++++++++++++
 arch/arm/mach-mx3/mx3_3stack_pmic_mc13783.c |  355 +++++++++
 5 files changed, 1913 insertions(+), 78 deletions(-)
 create mode 100644 arch/arm/mach-mx3/board-mx3_3stack.h
 create mode 100644 arch/arm/mach-mx3/mx31pdk_gpio.c
 create mode 100644 arch/arm/mach-mx3/mx3_3stack_pmic_mc13783.c

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index dc09187..48708dd 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -15,7 +15,7 @@ obj-$(CONFIG_MACH_MX31LILLY)	+= mach-mx31lilly.o mx31lilly-db.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mach-mx31lite.o mx31lite-db.o
 obj-$(CONFIG_MACH_PCM037)	+= mach-pcm037.o
 obj-$(CONFIG_MACH_PCM037_EET)	+= mach-pcm037_eet.o
-obj-$(CONFIG_MACH_MX31_3DS)	+= mach-mx31_3ds.o
+obj-$(CONFIG_MACH_MX31_3DS)	+= mach-mx31_3ds.o mx31pdk_gpio.o mx3_3stack_pmic_mc13783.o
 CFLAGS_mach-mx31_3ds.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
 obj-$(CONFIG_MACH_MX31MOBOARD)	+= mach-mx31moboard.o mx31moboard-devboard.o \
 				   mx31moboard-marxbot.o mx31moboard-smartbot.o
diff --git a/arch/arm/mach-mx3/board-mx3_3stack.h b/arch/arm/mach-mx3/board-mx3_3stack.h
new file mode 100644
index 0000000..cabdc73
--- /dev/null
+++ b/arch/arm/mach-mx3/board-mx3_3stack.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX31PDK_H__
+#define __ASM_ARCH_MXC_BOARD_MX31PDK_H__
+
+#ifdef CONFIG_MACH_MX31_3DS
+/*!
+ * @defgroup BRDCFG_MX31 Board Configuration Options
+ * @ingroup MSL_MX31
+ */
+
+/*!
+ * @file mach-mx3/board-mx3_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX31 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX31
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+/* Disable UART 4 as its pins are shared with ATA */
+#define UART4_ENABLED           0
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define DEBUG_BASE_ADDRESS	CS5_BASE_ADDR
+/* LAN9217 ethernet base address */
+#define LAN9217_BASE_ADDR	DEBUG_BASE_ADDRESS
+/* External UART */
+#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x8000)
+#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		(DEBUG_BASE_ADDRESS + 0x20000)
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG		0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+/* interrupts like external uart , external ethernet etc*/
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX31_PIN_GPIO1_1)
+
+#define MXC_EXP_IO_BASE		(MXC_BOARD_IRQ_START)
+#define EXPIO_INT_ENET		(MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUART_A	(MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUART_B	(MXC_BOARD_IRQ_START + 2)
+#define EXPIO_INT_BUTTON_A	(MXC_BOARD_IRQ_START + 3)
+#define EXPIO_INT_BUTTON_B	(MXC_BOARD_IRQ_START + 4)
+
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ	EXPIO_INT_ENET
+
+/*! LED definition*/
+#define MXC_BD_LED1	(1)
+#define MXC_BD_LED2	(1 << 1)
+#define MXC_BD_LED3	(1 << 2)
+#define MXC_BD_LED4	(1 << 3)
+#define MXC_BD_LED5	(1 << 4)
+#define MXC_BD_LED6	(1 << 5)
+#define MXC_BD_LED7	(1 << 6)
+#define MXC_BD_LED8	(1 << 7)
+
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+extern int sdhc_write_protect(struct device *dev);
+
+extern int __init mx3_3stack_init_mc13783(void);
+
+#endif				/* CONFIG_MACH_MX31_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX31PDK_H__ */
diff --git a/arch/arm/mach-mx3/mach-mx31_3ds.c b/arch/arm/mach-mx3/mach-mx31_3ds.c
index f54af1e..3653345 100644
--- a/arch/arm/mach-mx3/mach-mx31_3ds.c
+++ b/arch/arm/mach-mx3/mach-mx31_3ds.c
@@ -25,7 +25,15 @@
 #include <linux/platform_device.h>
 #include <linux/mfd/mc13783.h>
 #include <linux/spi/spi.h>
+#include <linux/i2c.h>
 #include <linux/regulator/machine.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/input/matrix_keypad.h>
+#include <asm/mach/flash.h>
+#include <mach/mxc_nand.h>
 
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
@@ -36,10 +44,11 @@
 #include <mach/common.h>
 #include <mach/board-mx31_3ds.h>
 #include <mach/imx-uart.h>
-#include <mach/iomux-mx3.h>
 #include <mach/mxc_nand.h>
 #include <mach/spi.h>
 #include "devices.h"
+#include "iomux.h"
+#include "crm_regs.h"
 
 /*!
  * @file mx31_3ds.c
@@ -49,96 +58,336 @@
  * @ingroup System
  */
 
-static int mx31_3ds_pins[] = {
-	/* UART1 */
-	MX31_PIN_CTS1__CTS1,
-	MX31_PIN_RTS1__RTS1,
-	MX31_PIN_TXD1__TXD1,
-	MX31_PIN_RXD1__RXD1,
-	IOMUX_MODE(MX31_PIN_GPIO1_1, IOMUX_CONFIG_GPIO),
-	/* SPI 1 */
-	MX31_PIN_CSPI2_SCLK__SCLK,
-	MX31_PIN_CSPI2_MOSI__MOSI,
-	MX31_PIN_CSPI2_MISO__MISO,
-	MX31_PIN_CSPI2_SPI_RDY__SPI_RDY,
-	MX31_PIN_CSPI2_SS0__SS0,
-	MX31_PIN_CSPI2_SS2__SS2, /*CS for MC13783 */
-	/* MC13783 IRQ */
-	IOMUX_MODE(MX31_PIN_GPIO1_3, IOMUX_CONFIG_GPIO),
+#if defined(CONFIG_KEYBOARD_MXC) || \
+	defined(CONFIG_KEYBOARD_MXC_MODULE)
+static u16 keymapping[12] = {
+	KEY_UP, KEY_DOWN, 0, 0,
+	KEY_RIGHT, KEY_LEFT, KEY_ENTER, 0,
+	KEY_F6, KEY_F8, KEY_F9, KEY_F10,
+};
+
+static struct resource keypad_resources[] = {
+	{
+		.start = MXC_INT_KPP,
+		.end = MXC_INT_KPP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mxc_keypad_platform_data keypad_plat_data = {
+	.rowmax = 3,
+	.colmax = 4,
+	.irq = MXC_INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
 };
 
-/* Regulators */
-static struct regulator_init_data pwgtx_init = {
-	.constraints = {
-		.boot_on	= 1,
-		.always_on	= 1,
+static struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(keypad_resources),
+	.resource = keypad_resources,
+	.dev = {
+		.platform_data = &keypad_plat_data,
 	},
 };
 
-static struct mc13783_regulator_init_data mx31_3ds_regulators[] = {
+static void mxc_init_keypad(void)
+{
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* NAND Flash */
+#if defined(CONFIG_MTD_NAND_MXC) || \
+	defined(CONFIG_MTD_NAND_MXC_MODULE)
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+		.name = "nand.bootloader",
+		.offset = 0,
+		.size = 1024 * 1024},
+	{
+		.name = "nand.kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 5 * 1024 * 1024},
 	{
-		.id = MC13783_REGU_PWGT1SPI, /* Power Gate for ARM core. */
-		.init_data = &pwgtx_init,
+		.name = "nand.configure",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 8 * 1024 * 1024},
+	{
+		.name = "nand.rootfs",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct mxc_nand_platform_data mxc_nand_plat_data = {
+	.width		= 1,
+	.hw_ecc		= 1,
+	.flash_data = &mxc_nand_data,
+};
+
+static struct resource mxc_nand_resources[] = {
+	{
+		.start  = MX31_NFC_BASE_ADDR,
+		.end    = MX31_NFC_BASE_ADDR + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
 	}, {
-		.id = MC13783_REGU_PWGT2SPI, /* Power Gate for L2 Cache. */
-		.init_data = &pwgtx_init,
+		.start  = MXC_INT_NANDFC,
+		.end    = MXC_INT_NANDFC,
+		.flags  = IORESOURCE_IRQ,
 	},
 };
 
-/* MC13783 */
-static struct mc13783_platform_data mc13783_pdata __initdata = {
-	.regulators = mx31_3ds_regulators,
-	.num_regulators = ARRAY_SIZE(mx31_3ds_regulators),
-	.flags  = MC13783_USE_REGULATOR,
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_nand_plat_data,
+	},
+	.num_resources = 2,
+	.resource = mxc_nand_resources,
 };
 
-/* SPI */
-static int spi1_internal_chipselect[] = {
-	MXC_SPI_CS(0),
-	MXC_SPI_CS(2),
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	(void)platform_device_register(&mxc_nand_mtd_device);
 };
+#else
+static void mxc_init_nand_mtd(void)
+{
+}
+#endif /* CONFIG_MTD_NAND_MXC */
+
+static void lcd_reset(void)
+{
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	mxc_request_iomux(MX31_PIN_LCS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_LCS1), "lcs1");
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+	/* do reset */
+	msleep(10);             /* tRES >= 100us */
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_LCS1), 1);
+	msleep(60);
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+#endif
+}
 
-static struct spi_imx_master spi1_pdata = {
-	.chipselect	= spi1_internal_chipselect,
-	.num_chipselect	= ARRAY_SIZE(spi1_internal_chipselect),
+static struct mxc_lcd_platform_data lcd_data = {
+	.io_reg = "VGEN",
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	.core_reg = "VMMC1",
+#else
+	.core_reg = "GPO1",
+#endif
+	.reset = lcd_reset,
 };
 
-static struct spi_board_info mx31_3ds_spi_devs[] __initdata = {
+static struct spi_board_info mx31pdk_spi_board_info[] __initdata = {
 	{
-		.modalias	= "mc13783",
-		.max_speed_hz	= 1000000,
-		.bus_num	= 1,
-		.chip_select	= 1, /* SS2 */
-		.platform_data	= &mc13783_pdata,
+		.modalias	= "pmic_spi",
 		.irq		= IOMUX_TO_IRQ(MX31_PIN_GPIO1_3),
-		.mode = SPI_CS_HIGH,
+		.max_speed_hz	= 4000000,
+		.bus_num	= 2/* 1 */,
+		.chip_select	= 2, /* SS2 */
 	},
+#if defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_MODULE)
+	{
+		.modalias = "lcd_spi",
+		.max_speed_hz = 5000000,
+		.bus_num = 1,
+		.chip_select = 2,
+		.platform_data = (void *)&lcd_data,
+	}
+#endif
 };
 
-/*
- * NAND Flash
- */
-static struct mxc_nand_platform_data imx31_3ds_nand_flash_pdata = {
-	.width		= 1,
-	.hw_ecc		= 1,
-#ifdef MACH_MX31_3DS_MXC_NAND_USE_BBT
-	.flash_bbt	= 1,
+#if defined(CONFIG_VIDEO_MXC_CAMERA) || \
+	defined(CONFIG_VIDEO_MXC_CAMERA_MODULE)
+static struct mxc_camera_platform_data ov2640_data = {
+	.core_regulator = "VVIB",
+	.io_regulator = "VMMC1",
+	.analog_regulator = "SW2B_NORMAL",
+	.gpo_regulator = "GPO3",
+	.mclk = 27000000,
+};
 #endif
+
+#if defined(CONFIG_FB_MXC_TVOUT_CH7024) || \
+	defined(CONFIG_FB_MXC_TVOUT_CH7024_MODULE)
+struct mxc_tvout_platform_data ch7024_data = {
+	.io_reg = "VGEN",
+	.core_reg = "GPO3",
+	.analog_reg = "GPO1",
+	.detect_line = IOMUX_TO_GPIO(MX31_PIN_BATT_LINE),
 };
 
-static struct imxuart_platform_data uart_pdata = {
-	.flags = IMXUART_HAVE_RTSCTS,
+static int mxc_init_ch7024(void)
+{
+	/* request gpio for phone jack detect */
+	mxc_request_iomux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_iomux_set_pad(MX31_PIN_BATT_LINE, PAD_CTL_PKE_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_BATT_LINE), "batt_line");
+	gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_BATT_LINE));
+
+	return 0;
+}
+#else
+static inline int mxc_init_ch7024(void)
+{
+}
+#endif
+
+static struct i2c_board_info mx31pdk_i2c_devices[] = {
+#if defined(CONFIG_VIDEO_MXC_CAMERA) || \
+	defined(CONFIG_VIDEO_MXC_CAMERA_MODULE)
+	{
+		I2C_BOARD_INFO("ov2640", 0x30),
+		.type = "ov2640",
+		.platform_data = (void *)&ov2640_data,
+	},
+#endif
+#if defined(CONFIG_FB_MXC_TVOUT_CH7024) || \
+	defined(CONFIG_FB_MXC_TVOUT_CH7024_MODULE)
+	{
+		I2C_BOARD_INFO("ch7024", 0x76),
+		.type = "ch7024",
+		.platform_data = (void *)&ch7024_data,
+		.irq = IOMUX_TO_IRQ(MX31_PIN_BATT_LINE),
+	},
+#endif
+};
+
+#if defined(CONFIG_FB_MXC) || \
+	defined(CONFIG_FB_MXC_MODULE)
+static const char fb_default_mode[] = "Epson-VGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+};
+
+#if defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_MODULE)
+static struct platform_device mxc_fb_wvga_device = {
+	.name = "lcd_claa",
+	.id = 0,
+	.dev = {
+		.platform_data = &lcd_data,
+	},
 };
+#endif
+
+static void mxc_init_fb(void)
+{
+	platform_device_register(&mxc_fb_device);
+#if defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_MODULE)
+	platform_device_register(&mxc_fb_wvga_device);
+#endif
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif /* CONFIG_FB_MXC */
+
+#if defined(CONFIG_BACKLIGHT_MXC) || \
+	defined(CONFIG_BACKLIGHT_MXC_MODULE)
+static struct platform_device mxcbl_devices[] = {
+	{
+		.name = "mxc_ipu_bl",
+		.id = 0,
+		.dev = {
+			/* DISP # for this backlight */
+			.platform_data = (void *)3,
+			},
+	},
+};
+
+static inline void mxc_init_bl(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxcbl_devices); i++)
+		platform_device_register(&mxcbl_devices[i]);
+}
+#else
+static inline void mxc_init_bl(void)
+{
+}
+#endif /* CONFIG_BACKLIGHT_MXC */
+
+#if (defined(CONFIG_MXC_PMIC_MC13783) || \
+		defined(CONFIG_MXC_PMIC_MC13783_MODULE)) \
+&& (defined(CONFIG_SND_MXC_PMIC) || \
+		defined(CONFIG_SND_MXC_PMIC_MODULE))
+static void __init mxc_init_pmic_audio(void)
+{
+	struct clk *ckih_clk;
+	struct clk *cko_clk;
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	ckih_clk = clk_get(NULL, "ckih");
+	cko_clk = clk_get(NULL, "cko1_clk");
+
+	if (IS_ERR(ckih_clk) || IS_ERR(cko_clk))
+		printk(KERN_ERR "Unable to set CKO1 output to CKIH\n");
+	else {
+		clk_set_parent(cko_clk, ckih_clk);
+		clk_set_rate(cko_clk, clk_get_rate(ckih_clk));
+		clk_enable(cko_clk);
+	}
+
+	clk_put(ckih_clk);
+	clk_put(cko_clk);
+
+	/* config Audio ports (4 & 5) */
+	mxc_request_iomux(MX31_PIN_SCK4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SCK5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+#else
+static inline void mxc_init_pmic_audio(void)
+{
+}
+#endif
 
 /*
  * Support for the SMSC9217 on the Debug board.
  */
-
+#if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
 static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-	.flags		= SMSC911X_USE_16BIT | SMSC911X_FORCE_INTERNAL_PHY,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.flags = SMSC911X_USE_32BIT | SMSC911X_FORCE_INTERNAL_PHY,
 };
 
 static struct resource smsc911x_resources[] = {
@@ -147,8 +396,8 @@ static struct resource smsc911x_resources[] = {
 		.end		= LAN9217_BASE_ADDR + 0xff,
 		.flags		= IORESOURCE_MEM,
 	}, {
-		.start		= EXPIO_INT_ENET,
-		.end		= EXPIO_INT_ENET,
+		.start		= LAN9217_IRQ,
+		.end		= LAN9217_IRQ,
 		.flags		= IORESOURCE_IRQ,
 	},
 };
@@ -163,10 +412,16 @@ static struct platform_device smsc911x_device = {
 	},
 };
 
-/*
- * Routines for the CPLD on the debug board. It contains a CPLD handling
- * LEDs, switches, interrupts for Ethernet.
- */
+static void mxc_init_enet(void)
+{
+	(void)platform_device_register(&smsc911x_device);
+}
+#else
+static inline void mxc_init_enet(void)
+{
+}
+#endif
+
 
 static void mx31_3ds_expio_irq_handler(uint32_t irq, struct irq_desc *desc)
 {
@@ -291,6 +546,35 @@ static struct map_desc mx31_3ds_io_desc[] __initdata = {
 	},
 };
 
+extern void mxc_cpu_init(void) __init;
+
+/*!
+* Board specific fixup function. It is called by \b setup_arch() in
+* setup.c file very early on during kernel starts. It allows the user to
+* statically fill in the proper values for the passed-in parameters. None of
+* the parameters is used currently.
+*
+* @param  desc         pointer to \b struct \b machine_desc
+* @param  tags         pointer to \b struct \b tag
+* @param  cmdline      pointer to the command line
+* @param  mi           pointer to \b struct \b meminfo
+*/
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+
 /*
  * Set up static virtual mappings.
  */
@@ -300,23 +584,39 @@ static void __init mx31_3ds_map_io(void)
 	iotable_init(mx31_3ds_io_desc, ARRAY_SIZE(mx31_3ds_io_desc));
 }
 
+static struct imxuart_platform_data uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+extern int mx3_devices_init(void);
+extern int __init mx3_3stack_init_mc13783(void);
+extern void mxc_cpu_common_init(void);
+
 /*!
  * Board specific initialization.
  */
 static void __init mxc_board_init(void)
 {
-	mxc_iomux_setup_multiple_pins(mx31_3ds_pins, ARRAY_SIZE(mx31_3ds_pins),
-				      "mx31_3ds");
+	/* config CS5 for debugboard */
+	mxc_request_iomux(MX31_PIN_CS5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
 
 	mxc_register_device(&mxc_uart_device0, &uart_pdata);
-	mxc_register_device(&mxc_nand_device, &imx31_3ds_nand_flash_pdata);
-
-	mxc_register_device(&mxc_spi_device1, &spi1_pdata);
-	spi_register_board_info(mx31_3ds_spi_devs,
-						ARRAY_SIZE(mx31_3ds_spi_devs));
-
-	if (!mx31_3ds_init_expio())
-		platform_device_register(&smsc911x_device);
+	mx31_3ds_init_expio();
+	mxc_init_enet();
+	mx3_devices_init();
+
+	mxc_init_pmic_audio();
+	mxc_init_keypad();
+	mxc_init_nand_mtd();
+	mxc_init_ch7024();
+	mxc_init_fb();
+	mxc_init_bl();
+	mx3_3stack_init_mc13783();
+
+	i2c_register_board_info(0, mx31pdk_i2c_devices,
+				ARRAY_SIZE(mx31pdk_i2c_devices));
+	spi_register_board_info(mx31pdk_spi_board_info,
+				ARRAY_SIZE(mx31pdk_spi_board_info));
 }
 
 static void __init mx31_3ds_timer_init(void)
@@ -337,6 +637,7 @@ MACHINE_START(MX31_3DS, "Freescale MX31PDK (3DS)")
 	.phys_io	= MX31_AIPS1_BASE_ADDR,
 	.io_pg_offst	= (MX31_AIPS1_BASE_ADDR_VIRT >> 18) & 0xfffc,
 	.boot_params    = MX3x_PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
 	.map_io         = mx31_3ds_map_io,
 	.init_irq       = mx31_init_irq,
 	.init_machine   = mxc_board_init,
diff --git a/arch/arm/mach-mx3/mx31pdk_gpio.c b/arch/arm/mach-mx3/mx31pdk_gpio.c
new file mode 100644
index 0000000..0e7c35e
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31pdk_gpio.c
@@ -0,0 +1,1025 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/pmic_adc.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include "board-mx3_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx3/mx3_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX31
+ */
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		mxc_request_iomux(MX31_PIN_RTS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CTS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI3_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SPI_RDY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * TODO: Configure the Pad registers for the UART pins
+	 */
+}
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_RXD1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_TXD1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_RTS1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_CTS1), NULL);
+
+		mxc_free_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		break;
+	case 1:
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_TXD2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_RXD2), NULL);
+
+		mxc_free_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RTS2, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CTS2, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	switch (port) {
+	case 1:
+		/* Configure to receive UART 2 SDMA events */
+		mxc_iomux_set_gpr(MUX_PGP_FIRI, false);
+		break;
+	case 2:
+		/* Configure to receive UART 3 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI1_UART3, true);
+		break;
+	case 4:
+		/* Configure to receive UART 5 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI3_UART5_SEL, true);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Setup GPIO for Keypad  to be active
+ *
+ */
+void gpio_keypad_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for keypad signals.
+	 */
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Setup GPIO for Keypad to be inactive
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_COL0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_COL1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_COL2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_COL3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_ROW0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_ROW1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_KEY_ROW2), NULL);
+
+	mxc_free_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+	mxc_free_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+void gpio_power_key_active(void)
+{
+	mxc_request_iomux(MX31_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO1_2), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO1_2));
+	mxc_iomux_set_pad(MX31_PIN_GPIO1_2, PAD_CTL_PKE_NONE);
+}
+EXPORT_SYMBOL(gpio_power_key_active);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		/* setup GPR for CSPI BB */
+		mxc_iomux_set_gpr(MUX_PGP_CSPI_BB, true);
+		/* CSPI1 clock and RDY use full UART ALT1 mode */
+		mxc_request_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 2:
+		/* SPI3 */
+		/*
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		*/
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		/* setup GPR for CSPI BB */
+		mxc_iomux_set_gpr(MUX_PGP_CSPI_BB, false);
+		/* CSPI1 clock and RDY use full UART ALT1 mode */
+		mxc_free_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_free_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		break;
+	case 2:
+		/* SPI3 */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+
+}
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_free_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_free_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_ALT1);
+		mxc_free_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	mxc_request_iomux(MX31_PIN_GPIO1_3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO1_3), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO1_3));
+}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST
+				   | PAD_CTL_100K_PU));
+
+		/*
+		 * Active the Buffer Enable Pin only if there is
+		 * a card in slot.
+		 * To fix the card voltage issue caused by
+		 * bi-directional chip TXB0108 on 3Stack
+		 */
+		if (gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1)))
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		else
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 1);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_free_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+		mxc_free_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+
+		/* Buffer Enable Pin of SD, Active HI */
+		gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		break;
+	case 1:
+		/* TODO:what are the pins for SDHC2? */
+		mxc_free_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_FUNC,
+			       INPUTCONFIG_NONE);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1));
+		/*
+		 * Active the Buffer Enable Pin only if there is
+		 * a card in slot.
+		 * To fix the card voltage issue caused by
+		 * bi-directional chip TXB0108 on 3Stack
+		 */
+		if (ret)
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		else
+			gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 1);
+		return ret;
+	} else
+		return gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_GPIO1_2));
+}
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	if (id == 0) {
+		/* Buffer Enable Pin, Active HI */
+		mxc_request_iomux(MX31_PIN_GPIO3_0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), "gpio3_0");
+		gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+		gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_GPIO3_0), 0);
+
+		/* CD Pin */
+		mxc_request_iomux(MX31_PIN_GPIO3_1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_iomux_set_pad(MX31_PIN_GPIO3_1, PAD_CTL_PKE_NONE);
+		gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1), "gpio3_1");
+		gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1));
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO3_1);
+	} else {
+		iomux_config_mux(MX31_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
+				 INPUTCONFIG_GPIO);
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_2);
+
+	}
+}
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Get SD1_WP ADIN7 of ATLAS pin value to detect write protection
+ */
+int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	pmic_adc_convert(GEN_PURPOSE_AD7, &rc);
+	if (rc > 0)
+		return 1;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(sdhc_write_protect);
+
+/*!
+ * Setup GPIO for LCD to be active
+ *
+ */
+void gpio_lcd_active(void)
+{
+
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*LD16*/
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	/* LD17 */
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	/* VSYNC */
+	mxc_request_iomux(MX31_PIN_VSYNC3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	/* HSYNC */
+	mxc_request_iomux(MX31_PIN_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	/* CLK */
+	mxc_request_iomux(MX31_PIN_FPSHIFT, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	/* CONTR */
+	mxc_request_iomux(MX31_PIN_CONTRAST, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	mxc_request_iomux(MX31_PIN_DRDY0,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* DRDY */
+	mxc_request_iomux(MX31_PIN_D3_REV,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* REV */
+	mxc_request_iomux(MX31_PIN_D3_SPL,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* SPL */
+	mxc_request_iomux(MX31_PIN_D3_CLS,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* CLS */
+#else
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	mxc_request_iomux(MX31_PIN_LCS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_LCS1), "lcs1");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_LCS1), 0);
+	/* do reset */
+	mdelay(10);		/* tRES >= 100us */
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_LCS1), 1);
+
+	/* enable data */
+	mxc_request_iomux(MX31_PIN_SER_RS, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_SER_RS), "ser_rs");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_SER_RS), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_SER_RS), 1);
+#endif
+}
+EXPORT_SYMBOL(gpio_lcd_active);
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ *
+ */
+void gpio_lcd_inactive(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_SER_RS), 0);
+}
+EXPORT_SYMBOL(gpio_lcd_inactive);
+
+/*!
+ * Switch to the specified sensor - MX31 ADS has two
+ *
+ */
+void gpio_sensor_select(int sensor)
+{
+}
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(unsigned int csi_index)
+{
+	gpio_sensor_select(0);
+
+	/*
+	 * Configure the iomuxen for the CSI.
+	 */
+
+	mxc_request_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_CSI_D5), "csi_d5");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_CSI_D5), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_CSI_D5), 0);
+
+	mxc_request_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+
+	if (mxc_request_iomux(MX31_PIN_A23, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE)
+	    == 0) {
+		printk(KERN_ERR "%s:REGEN set request gpio ok\n", __func__);
+	} else {
+		printk(KERN_ERR "%s:REGEN set error, request gpio error\n",
+		       __func__);
+		return;
+	}
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO), "sd_d_io");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_SD_D_IO), 1);
+}
+
+void gpio_sensor_reset(bool flag)
+{
+}
+EXPORT_SYMBOL(gpio_sensor_reset);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(unsigned int csi)
+{
+	mxc_free_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+		       INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+
+/* *INDENT-OFF* */
+/*
+ * USB Host 1
+ * pins conflict with SPI1, ATA, UART3
+ */
+int gpio_usbh1_active(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh1_active);
+
+void gpio_usbh1_inactive(void)
+{
+	/* Do nothing as pins don't have/support GPIO mode */
+
+}
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBH2_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_PC_VS2,		/* USBH2_DATA2 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_PC_RST,		/* USBH2_DATA5 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_IOIS16,		/* USBH2_DATA6 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1)) {
+		return -EINVAL;
+	}
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST |
+			   PAD_CTL_PKE_NONE));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_VS2,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD1,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD2,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RST,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_IOIS16,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RW_B,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_request_iomux(MX31_PIN_USB_BYP, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), "usb_byp");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), 0);
+	mdelay(1);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_USB_BYP), 1);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_VS2,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD1,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_BVD2,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RST,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_IOIS16,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_PC_RW_B,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+	mxc_free_iomux(MX31_PIN_USBH2_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_PC_VS2,			/* USBH2_DATA2 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST,			/* USBH2_DATA5 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_IOIS16,			/* USBH2_DATA6 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_USB_BYP,		/* USBH2 PHY reset */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+		return -EINVAL;
+	}
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	/* reset transceiver */
+	mxc_request_iomux(MX31_PIN_USB_PWR, OUTPUTCONFIG_GPIO,
+		INPUTCONFIG_GPIO);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_USB_PWR), "usb_pwr");
+	gpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_USB_PWR), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_USB_PWR), 0);
+	mdelay(1);
+	gpio_set_value(IOMUX_TO_GPIO(MX31_PIN_USB_PWR), 1);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USB_PWR, OUTPUTCONFIG_GPIO,
+		INPUTCONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*!
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USB_PWR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC))
+		return -EINVAL;
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+	/* Do nothing as  pins doesn't have/support GPIO mode */
+
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
diff --git a/arch/arm/mach-mx3/mx3_3stack_pmic_mc13783.c b/arch/arm/mach-mx3/mx3_3stack_pmic_mc13783.c
new file mode 100644
index 0000000..4c6d517
--- /dev/null
+++ b/arch/arm/mach-mx3/mx3_3stack_pmic_mc13783.c
@@ -0,0 +1,355 @@
+/*
+ * mx3-3stack-pmic-mc13783.c  --  i.MX3 3STACK Driver for Atlas MC13783 PMIC
+ */
+ /*
+  * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13783/core.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+
+struct mc13783;
+
+static struct regulator_init_data violo_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1800), /* mc13783 allows max of 1800. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1800), /* mc13783 allows max of 1800. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_consumer_supply vgen_init_supply = {
+	.supply = "VGEN",
+};
+
+static struct regulator_init_data vgen_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1100), /* mc13783 allows min of 1100. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &vgen_init_supply,
+};
+
+static struct regulator_init_data vrfdig_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1875), /* mc13783 allows max of 1875. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vrfref_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(2475), /* mc13783 allows min of 2475. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vrfcp_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(2700), /* mc13783 allows min of 2700. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vsim_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1800), /* mc13783 allows min of 1800. */
+		.max_uV = mV_to_uV(2900), /* mc13783 allows max of 2900. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vesim_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1800), /* mc13783 allows min of 1800. */
+		.max_uV = mV_to_uV(2900), /* mc13783 allows max of 2900. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1500), /* mc13783 allows min of 1500. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_consumer_supply vvib_init_supply = {
+	.supply = "VVIB",
+};
+
+static struct regulator_init_data vvib_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1300), /* mc13783 allows min of 1300. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &vvib_init_supply,
+};
+
+static struct regulator_init_data vrf_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1500), /* mc13783 allows min of 1500. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_consumer_supply vmmc1_init_supply = {
+	.supply = "VMMC1",
+};
+
+static struct regulator_init_data vmmc1_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1600), /* mc13783 allows min of 1600. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &vmmc1_init_supply,
+};
+
+static struct regulator_consumer_supply vmmc2_init_supply = {
+	.supply = "VMMC2",
+};
+
+static struct regulator_init_data vmmc2_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1600), /* mc13783 allows min of 1600. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &vmmc2_init_supply,
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(5000), /* mc13783 allows min of 5000. */
+		.max_uV = mV_to_uV(5500), /* mc13783 allows max of 5500. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_consumer_supply sw1_init_supply = {
+	.supply = "SW1A",
+};
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 900. */
+		.max_uV = mV_to_uV(1600), /* mc13783 allows max of 2200. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE
+				  | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST
+				    | REGULATOR_MODE_NORMAL
+				    | REGULATOR_MODE_IDLE
+				    | REGULATOR_MODE_STANDBY,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = mV_to_uV(1250),
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &sw1_init_supply,
+};
+
+static struct regulator_consumer_supply sw2b_init_supply = {
+	.supply = "SW2B_NORMAL",
+};
+
+static struct regulator_init_data sw2b_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 900. */
+		.max_uV = mV_to_uV(2200), /* mc13783 allows max of 2200. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &sw2b_init_supply,
+};
+
+static struct regulator_init_data sw_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 900. */
+		.max_uV = mV_to_uV(2200), /* mc13783 allows max of 2200. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_consumer_supply gpo1_init_supply = {
+	.supply = "GPO1",
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &gpo1_init_supply,
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+	},
+};
+
+static struct regulator_consumer_supply gpo2_init_supply = {
+	.supply = "GPO2",
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &gpo2_init_supply,
+};
+
+static struct regulator_consumer_supply gpo3_init_supply = {
+	.supply = "GPO3",
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &gpo3_init_supply,
+};
+
+static struct regulator_init_data gpo_init = {
+	.constraints = {
+	},
+};
+
+static int mc13783_regulator_init(void *data)
+{
+	struct mc13783 *mc13783 = data;
+	unsigned int value;
+
+	/*most regulators are controled by standby signal*/
+	/*except violo*/
+	pmic_read_reg(REG_REGULATOR_MODE_0, &value, 0xffffff);
+	value |= 0x492412;
+	pmic_write_reg(REG_REGULATOR_MODE_0, value, 0xffffff);
+	pmic_read_reg(REG_REGULATOR_MODE_1, &value, 0xffffff);
+	value |= 0x492492;
+	pmic_write_reg(REG_REGULATOR_MODE_1, value, 0xffffff);
+	/*also sw3 is controled by standby signal*/
+	pmic_read_reg(REG_SWITCHERS_5, &value, 0xffffff);
+	value |= 0x200000;
+	pmic_write_reg(REG_SWITCHERS_5, value, 0xffffff);
+
+	mc13783_register_regulator(mc13783, MC13783_SW1A, &sw1_init);
+	mc13783_register_regulator(mc13783, MC13783_SW1B, &sw2b_init);
+	mc13783_register_regulator(mc13783, MC13783_SW2A, &sw_init);
+	mc13783_register_regulator(mc13783, MC13783_SW2B, &sw_init);
+	mc13783_register_regulator(mc13783, MC13783_SW3, &sw3_init);
+	mc13783_register_regulator(mc13783, MC13783_VMMC1, &vmmc1_init);
+	mc13783_register_regulator(mc13783, MC13783_VMMC2, &vmmc2_init);
+	mc13783_register_regulator(mc13783, MC13783_VVIB, &vvib_init);
+	mc13783_register_regulator(mc13783, MC13783_VIOHI, &viohi_init);
+	mc13783_register_regulator(mc13783, MC13783_VIOLO, &violo_init);
+	mc13783_register_regulator(mc13783, MC13783_VDIG, &vdig_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFDIG, &vrfdig_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFREF, &vrfref_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFCP, &vrfcp_init);
+	mc13783_register_regulator(mc13783, MC13783_VRF1, &vrf_init);
+	mc13783_register_regulator(mc13783, MC13783_VRF2, &vrf_init);
+	mc13783_register_regulator(mc13783, MC13783_VAUDIO, &vaudio_init);
+	mc13783_register_regulator(mc13783, MC13783_VCAM, &vcam_init);
+	mc13783_register_regulator(mc13783, MC13783_VGEN, &vgen_init);
+	mc13783_register_regulator(mc13783, MC13783_VSIM, &vsim_init);
+	mc13783_register_regulator(mc13783, MC13783_VESIM, &vesim_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO1, &gpo1_init);
+
+	gpo_init.supply_regulator_dev =
+				&(mc13783->pmic.pdev[MC13783_GPO1]->dev);
+	mc13783_register_regulator(mc13783, MC13783_GPO2, &gpo2_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO3, &gpo3_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO4, &gpo4_init);
+
+	return 0;
+}
+static struct pmic_platform_data mc13783_plat = {
+	.init = mc13783_regulator_init,
+	.power_key_irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_2),
+};
+
+static struct spi_board_info __initdata mc13783_spi_device = {
+	.modalias = "pmic_spi",
+	.irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_3),
+	.max_speed_hz = 4000000,
+	.bus_num = 2,
+	.platform_data = &mc13783_plat,
+	.chip_select = 2,
+};
+
+int __init mx3_3stack_init_mc13783(void)
+{
+	return spi_register_board_info(&mc13783_spi_device, 1);
+}
-- 
1.6.5.2

