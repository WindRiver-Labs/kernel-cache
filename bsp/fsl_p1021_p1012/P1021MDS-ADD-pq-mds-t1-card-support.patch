From ed5ec879b6df5d6d2952e4ec12d60346ab6517ed Mon Sep 17 00:00:00 2001
From: Kai.Jiang <Kai.Jiang@freescale.com>
Date: Wed, 12 Jan 2011 16:14:57 +0800
Subject: [PATCH 2/5] P1021MDS: ADD pq-mds-t1 card support.

This patch enable Freescale PQ-MDS-T1 card to work in T1 or E1 mode.

Signed-off-by: Kai.Jiang <Kai.Jiang@freescale.com>

[Extracted from the P1021MDS_20110118_TDM_Patch.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]

Integrated-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/tdm/line_ctrl/Kconfig     |    7 +
 drivers/tdm/line_ctrl/Makefile    |    1 +
 drivers/tdm/line_ctrl/pq_mds_t1.c |  506 +++++++++++++++++++++++++++++++++++++
 drivers/tdm/line_ctrl/pq_mds_t1.h |  297 ++++++++++++++++++++++
 4 files changed, 811 insertions(+), 0 deletions(-)
 create mode 100644 drivers/tdm/line_ctrl/pq_mds_t1.c
 create mode 100644 drivers/tdm/line_ctrl/pq_mds_t1.h

diff --git a/drivers/tdm/line_ctrl/Kconfig b/drivers/tdm/line_ctrl/Kconfig
index 00ef073..55fcc52 100644
--- a/drivers/tdm/line_ctrl/Kconfig
+++ b/drivers/tdm/line_ctrl/Kconfig
@@ -8,3 +8,10 @@ config SLIC_ZARLINK
 		default n
 		---help---
 		  This module initialize and configure the zarlink slic
+
+config PQ_MDS_T1
+	tristate "PQ MDS T1 CARD SUPPORT"
+		default n
+		---help---
+		 This module initialize and configure the pq-mds-t1 card
+		 in T1 or E1 mode.
diff --git a/drivers/tdm/line_ctrl/Makefile b/drivers/tdm/line_ctrl/Makefile
index 93f5ba6..4a85635 100644
--- a/drivers/tdm/line_ctrl/Makefile
+++ b/drivers/tdm/line_ctrl/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_SLIC_ZARLINK)	+= slic_zarlink.o
+obj-$(CONFIG_PQ_MDS_T1)		+= pq_mds_t1.o
diff --git a/drivers/tdm/line_ctrl/pq_mds_t1.c b/drivers/tdm/line_ctrl/pq_mds_t1.c
new file mode 100644
index 0000000..a053b4e
--- /dev/null
+++ b/drivers/tdm/line_ctrl/pq_mds_t1.c
@@ -0,0 +1,506 @@
+/*
+ * drivers/tdm/line/pq_mds_t1.c
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * T1/E1 PHY(DS26528) Control Module for Freescale PQ-MDS-T1 card.
+ *
+ * Author: Kai Jiang <Kai.Jiang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/param.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/io.h>
+
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+
+#include "pq_mds_t1.h"
+#define DRV_DESC "Freescale Developed PQ_MDS_T1CARD Driver"
+#define DRV_NAME "PQ_MDS_T1"
+#define DRV_VERSION "1.0"
+
+static int pq_mds_t1_connect(struct pq_mds_t1 *t1_info)
+{
+	struct pld_mem *pld_base = t1_info->pld_base;
+
+	if ((in_8(&pld_base->brdrev) == PQ_MDS_8E1T1_BRD_REV) &&
+		(in_8(&pld_base->pldrev) == PQ_MDS_8E1T1_PLD_REV))
+		return 0;
+	else {
+		printk(KERN_WARNING"No PQ-MDS-T1 Card Connected\n");
+		return -ENODEV;
+	}
+}
+
+static int pq_mds_t1_clock_set(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+	struct pld_mem *pld = pq_mds_t1_info->pld_base;
+
+	if (pq_mds_t1_info->line_rate == LINE_RATE_T1) {
+		/* General clock configuration
+		   Altera register setting: Framer DIGIOEN and TXEN active */
+		out_8(&pld->pinset, 0x03);
+		/* Drive MCLK & REFCLKIO with 1.544MHz */
+		out_8(&pld->csr, 0x00);
+		/* Drive TSYSCLK & RSYSCLK with 1.544MHz */
+		out_8(&pld->sysclk_tr, 0x00);
+
+		/* Framer setting
+		   Select MCLK - 1.544MHz, REFCLKIO - 1.544MHz (GTCCR) */
+		out_8(&ds26528->link[0].gbl.gtccr, 0xac);
+		/* Wait 10msec */
+		msleep(10);
+
+		/* Set TSSYNCIO -> OUTPUT (GTCR2) */
+		out_8(&ds26528->link[0].gbl.gtcr2, 0x02);
+		/* Select BPCLK=2.048MHz (GFCR) */
+		out_8(&ds26528->link[0].gbl.gfcr, 0x00);
+	} else {
+		/* General clock configuration
+		    Altera register setting: Framer DIGIOEN and TXEN active */
+		out_8(&pld->pinset, 0x03);
+		/* Drive MCLK & REFCLKIO with 2.048MHz */
+		out_8(&pld->csr, 0x41);
+		/* Drive TSYSCLK & RSYSCLK with 2.048MHz */
+		out_8(&pld->sysclk_tr, 0x41);
+
+		/* Framer setting
+		    Select MCLK - 2.048MHz, REFCLKIO - 2.048MHz (GTCCR) */
+		out_8(&ds26528->link[0].gbl.gtccr, 0xa0);
+		/* Wait 10msec */
+		msleep(10);
+
+		/* Set TSSYNCIO -> OUTPUT (GTCR2) */
+		out_8(&ds26528->link[0].gbl.gtcr2, 0x02);
+		/* Select BPCLK=2.048MHz (GFCR) */
+		out_8(&ds26528->link[0].gbl.gfcr, 0x00);
+	}
+
+	return 0;
+}
+
+static int ds26528_bulk_write_set(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	/* Select Bulk write for Framer Register Init (GTCR1) */
+	out_8(&(pq_mds_t1_info->ds26528_base->link[0].gbl.gtcr1), 0x04);
+	return 0;
+}
+
+static int ds26528_bulk_write_unset(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	/* Unselect Bulk write for Framer Register Init (GTCR1) */
+	out_8(&(pq_mds_t1_info->ds26528_base->link[0].gbl.gtcr1), 0x00);
+	return 0;
+}
+
+static int ds26528_gbl_sreset(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+
+	/* Global LIU Software Reset Register (GLSRR) */
+	out_8(&ds26528->link[0].gbl.glsrr, 0xff);
+	/* Global Framer and BERT Software Reset Register (GFSRR) */
+	out_8(&ds26528->link[0].gbl.gfsrr, 0xff);
+	/* Wait 10msec*/
+	msleep(10);
+
+	out_8(&ds26528->link[0].gbl.glsrr, 0x00);
+	out_8(&ds26528->link[0].gbl.gfsrr, 0x00);
+
+	return 0;
+}
+
+static int card_pld_t1_clk_set(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	struct pld_mem *pld = pq_mds_t1_info->pld_base;
+	/* Drive TCLK1..4 with 1.544MHz*/
+	out_8(&pld->tcsr1, 0x00);
+	/* Drive TCLK5..8 with 1.544MHz*/
+	out_8(&pld->tcsr2, 0x00);
+	msleep(10);
+
+	return 0;
+}
+
+static int card_pld_e1_clk_set(struct pq_mds_t1 *pq_mds_t1_info)
+{
+	struct pld_mem *pld = pq_mds_t1_info->pld_base;
+	/* Drive TCLK1..4 with 2.048MHz*/
+	out_8(&pld->tcsr1, 0x55);
+	/* Drive TCLK5..8 with 2.048MHz*/
+	out_8(&pld->tcsr2, 0x55);
+	msleep(10);
+
+	return 0;
+}
+
+static int ds26528_rx_tx_sreset(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+
+	if (phy_id > MAX_NUM_OF_CHANNELS)
+		return -ENODEV;
+
+	/* Perform RX/TX SRESET,Reset receiver (RMMR) */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0x02);
+	/* Reset tranceiver (TMMR) */
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0x02);
+	/* Wait 10msec */
+	msleep(10);
+
+	return 0;
+}
+
+static int ds26528_frame_regs_clear(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+	/* Zero all Framer Registers */
+	memset(&ds26528->link[phy_id].rx, 0, sizeof(struct rx_frame));
+	memset(&ds26528->link[phy_id].tx, 0, sizeof(struct tx_frame));
+	memset(&ds26528->liu[phy_id], 0, sizeof(struct liu_reg));
+	memset(&ds26528->bert[phy_id], 0, sizeof(struct bert_reg));
+
+	return 0;
+}
+
+static int ds26528_trans_mode_set(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+
+	switch (pq_mds_t1_info->trans_mode) {
+	case FRAMER_LB:
+		out_8(&ds26528->link[phy_id].rx.rcr3, 0x01);
+		break;
+	case NORMAL:
+		break;
+	default:
+		printk(KERN_WARNING
+			"function: %s No such transfer mode\n", __func__);
+		break;
+	}
+
+	return 0;
+
+}
+
+static int ds26528_t1_spec_config(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+	/* Receive T1 Mode (Receive Master Mode Register - RMMR)
+	   Framer Disabled */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0x00);
+	/* Transmit T1 Mode (Transmit Master Mode Register - TMMR)
+	   Framer Disabled */
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0x00);
+	/* Receive T1 Mode Framer Enable (RMMR - Framer Enabled/T1) */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0x80);
+	/* Transmit T1 Mode Framer Enable (TMMR - Framer Enabled/T1) */
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0x80);
+	/* RCR1, receive T1 B8zs & ESF (Receive Control Register 1 - T1 MODE) */
+	out_8(&ds26528->link[phy_id].rx.rcr1, 0xc8);
+	/* RIOCR  (RSYSCLK=1.544MHz, RSYNC-Output) */
+	out_8(&ds26528->link[phy_id].rx.riocr, 0x00);
+	/* TCR1 Transmit T1 b8zs*/
+	out_8(&ds26528->link[phy_id].tx.tcr[0], 0x04);
+	/* TIOCR (TSYSCLK=1.544MHz, TSYNC-Output) */
+	out_8(&ds26528->link[phy_id].tx.tiocr, 0x04);
+	/* Receive T1 Mode Framer Enable & init Done */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0xc0);
+	/* Transmit T1 Mode Framer Enable & init Done */
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0xc0);
+	/* Configure LIU (LIU Transmit Receive Control Register
+	   - LTRCR. T1 mode) */
+	out_8(&ds26528->liu[phy_id].ltrcr, 0x02);
+	/* T1 Mode default 100 ohm 0db CSU (LIU Transmit Impedance and
+	   Pulse Shape Selection Register - LTITSR)*/
+	out_8(&ds26528->liu[phy_id].ltitsr, 0x10);
+	/* T1 Mode default 100 ohm Long haul (LIU Receive Impedance and
+	   Sensitivity Monitor Register - LRISMR)*/
+	out_8(&ds26528->liu[phy_id].lrismr, 0x13);
+	/* Enable Transmit output (LIU Maintenance Control Register - LMCR) */
+	out_8(&ds26528->liu[phy_id].lmcr, 0x01);
+	return 0;
+}
+static int ds26528_e1_spec_config(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct ds26528_mem *ds26528 = pq_mds_t1_info->ds26528_base;
+
+	/* Receive E1 Mode (Receive Master Mode Register - RMMR)
+	   Framer Disabled */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0x01);
+	/* Transmit E1 Mode (Transmit Master Mode Register - TMMR)
+	   Framer Disabled*/
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0x01);
+	/* Receive E1 Mode Framer Enable (RMMR - Framer Enabled/E1)*/
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0x81);
+	/* Transmit E1 Mode Framer Enable (TMMR - Framer Enabled/E1)*/
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0x81);
+	/* RCR1, receive E1 B8zs & ESF (Receive Control Register 1 - E1 MODE)*/
+	out_8(&ds26528->link[phy_id].rx.rcr1, 0x60);
+	/* RIOCR (RSYSCLK=2.048MHz, RSYNC-Output) */
+	out_8(&ds26528->link[phy_id].rx.riocr, 0x10);
+	/* TCR1 Transmit E1 b8zs */
+	out_8(&ds26528->link[phy_id].tx.tcr[0], 0x04);
+	/* TIOCR (TSYSCLK=2.048MHz, TSYNC-Output) */
+	out_8(&ds26528->link[phy_id].tx.tiocr, 0x14);
+	/* Set E1TAF (Transmit Align Frame Register regsiter) */
+	out_8(&ds26528->link[phy_id].tx.e1taf, 0x1b);
+	/* Set E1TNAF register (Transmit Non-Align Frame Register) */
+	out_8(&ds26528->link[phy_id].tx.e1tnaf, 0x40);
+	/* Receive E1 Mode Framer Enable & init Done (RMMR) */
+	out_8(&ds26528->link[phy_id].rx.rmmr, 0xc1);
+	/* Transmit E1 Mode Framer Enable & init Done (TMMR) */
+	out_8(&ds26528->link[phy_id].tx.tmmr, 0xc1);
+	/* Configure LIU (LIU Transmit Receive Control Register
+	   - LTRCR. E1 mode) */
+	out_8(&ds26528->liu[phy_id].ltrcr, 0x00);
+	/* E1 Mode default 75 ohm w/Transmit Impedance Matlinking
+	 (LIU Transmit Impedance and Pulse Shape Selection Register - LTITSR)*/
+	out_8(&ds26528->liu[phy_id].ltitsr, 0x00);
+	/* E1 Mode default 75 ohm Long Haul w/Receive Impedance Matlinking
+	  (LIU Receive Impedance and Sensitivity Monitor Register - LRISMR)*/
+	out_8(&ds26528->liu[phy_id].lrismr, 0x03);
+	/* Enable Transmit output (LIU Maintenance Control Register - LMCR) */
+	out_8(&ds26528->liu[phy_id].lmcr, 0x01);
+
+	return 0;
+}
+
+int ds26528_t1_e1_config(struct pq_mds_t1 *pq_mds_t1_info, u8 phy_id)
+{
+	struct pq_mds_t1 *card_info = pq_mds_t1_info;
+
+	ds26528_bulk_write_set(card_info);
+	ds26528_gbl_sreset(card_info);
+	switch (card_info->line_rate) {
+	case LINE_RATE_T1:
+		card_pld_t1_clk_set(card_info);
+		break;
+	case LINE_RATE_E1:
+		card_pld_e1_clk_set(card_info);
+		break;
+	default:
+		printk(KERN_WARNING"Support E1/T1. Frame mode not support.\n");
+		return -ENODEV;
+		break;
+	}
+	ds26528_rx_tx_sreset(card_info, phy_id);
+	ds26528_frame_regs_clear(card_info, phy_id);
+	ds26528_trans_mode_set(card_info, phy_id);
+
+	switch (card_info->line_rate) {
+	case LINE_RATE_T1:
+		ds26528_t1_spec_config(card_info, phy_id);
+		break;
+	case LINE_RATE_E1:
+		ds26528_e1_spec_config(card_info, phy_id);
+		break;
+	default:
+		printk(KERN_WARNING"Support E1/T1. Frame mode not support\n");
+		return -ENODEV;
+		break;
+	}
+	ds26528_bulk_write_unset(card_info);
+	msleep(10);
+
+	return 0;
+}
+
+static enum line_rate_t set_phy_line_rate(const char *line_rate)
+{
+	if (strcasecmp(line_rate, "t1") == 0)
+		return LINE_RATE_T1;
+	else if (strcasecmp(line_rate, "e1") == 0)
+		return LINE_RATE_E1;
+	else
+		return LINE_RATE_T1;
+}
+
+static enum tdm_trans_mode_t set_phy_trans_mode(const char *trans_mode)
+{
+	if (strcasecmp(trans_mode, "normal") == 0)
+		return NORMAL;
+	else if (strcasecmp(trans_mode, "framer-loopback") == 0)
+		return FRAMER_LB;
+	else
+		return NORMAL;
+}
+
+
+static int __devinit pq_mds_t1_probe(struct of_device *ofdev,
+				const struct of_device_id *match)
+{
+	int err = 0;
+	struct device_node *np;
+	struct resource res;
+	struct pq_mds_t1 *t1_info = NULL;
+	unsigned char *prop = NULL;
+
+	t1_info = kzalloc(sizeof(struct pq_mds_t1), GFP_KERNEL);
+	if (!t1_info) {
+		printk(KERN_ERR"%s: No memory to alloc\n", __func__);
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&ofdev->dev, t1_info);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,pq-mds-t1-pld");
+	if (!np)  {
+		printk(KERN_ERR
+			"%s: Invalid fsl,pq-mds-t1-pld property\n", __func__);
+		err =  -ENODEV;
+		goto err_miss_pld_property;
+	}
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err) {
+		err = -ENODEV;
+		goto err_miss_pld_property;
+	}
+	t1_info->pld_base = ioremap(res.start, res.end - res.start + 1);
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "dallas,ds26528");
+	if (!np) {
+		printk(KERN_ERR
+			"%s: Invalid dallas,ds26528 property\n", __func__);
+		err = -ENODEV;
+		goto err_miss_phy_property;
+
+	}
+	err = of_address_to_resource(np, 0, &res);
+	if (err) {
+		err = -ENODEV;
+		goto err_miss_phy_property;
+	}
+	t1_info->ds26528_base = ioremap(res.start, res.end - res.start + 1);
+
+	err = pq_mds_t1_connect(t1_info);
+	if (err) {
+		err = -ENODEV;
+		printk(KERN_ERR"%s: No PQ_MDS_T1 CARD\n", __func__);
+		goto err_card_unplugin;
+	}
+
+	prop = (unsigned char *)of_get_property(np, "line-rate", NULL);
+	if (!prop) {
+		err = -ENODEV;
+		printk(KERN_ERR"%s: Invalid line-rate property\n", __func__);
+		goto err_card_unplugin;
+	}
+
+	t1_info->line_rate = set_phy_line_rate(prop);
+
+	prop = (unsigned char *)of_get_property(np, "trans-mode", NULL);
+	if (!prop) {
+		err = -ENODEV;
+		printk(KERN_ERR"%s: Invalid trans-mode property\n", __func__);
+		goto err_card_unplugin;
+	}
+	t1_info->trans_mode = set_phy_trans_mode(prop);
+	of_node_put(np);
+
+	pq_mds_t1_clock_set(t1_info);
+	ds26528_t1_e1_config(t1_info, 0);
+
+	return 0;
+
+err_card_unplugin:
+	iounmap(t1_info->ds26528_base);
+err_miss_phy_property:
+	iounmap(t1_info->pld_base);
+err_miss_pld_property:
+	kfree(t1_info);
+
+	return err;
+}
+
+static int pq_mds_t1_remove(struct of_device *ofdev)
+{
+	struct pq_mds_t1 *t1_info = dev_get_drvdata(&ofdev->dev);
+
+	iounmap(t1_info->pld_base);
+	iounmap(t1_info->ds26528_base);
+	kfree(t1_info);
+
+	return 0;
+}
+
+static struct of_device_id pq_mds_t1_of_match[] = {
+	{
+	.compatible = "fsl,pq-mds-t1",
+	},
+	{},
+};
+
+static struct of_platform_driver pq_mds_t1_driver = {
+	.owner = THIS_MODULE,
+	.name = "pq_mds_t1",
+	.match_table = pq_mds_t1_of_match,
+	.probe = pq_mds_t1_probe,
+	.remove = __devexit_p(pq_mds_t1_remove),
+	.driver = {
+		.name = "pq_mds_t1",
+		.owner = THIS_MODULE,
+	},
+};
+
+
+
+static int __init pq_mds_t1_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "PQ-MDS-T1: " DRV_DESC "\n");
+
+	ret = of_register_platform_driver(&pq_mds_t1_driver);
+	if (ret)
+		printk(KERN_WARNING "PQ_MDS_T1 Card failed to register\n");
+
+	return ret;
+}
+
+
+static void __exit pq_mds_t1_exit(void)
+{
+	of_unregister_platform_driver(&pq_mds_t1_driver);
+}
+
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc");
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_LICENSE("GPL");
+
+
+module_init(pq_mds_t1_init);
+module_exit(pq_mds_t1_exit);
diff --git a/drivers/tdm/line_ctrl/pq_mds_t1.h b/drivers/tdm/line_ctrl/pq_mds_t1.h
new file mode 100644
index 0000000..ba62e4e
--- /dev/null
+++ b/drivers/tdm/line_ctrl/pq_mds_t1.h
@@ -0,0 +1,297 @@
+/*
+ * drivers/tdm/line/pq_mds_t1.h
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Kai Jiang <Kai.Jiang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#define MAX_NUM_OF_CHANNELS	8
+#define PQ_MDS_8E1T1_BRD_REV		0x00
+#define PQ_MDS_8E1T1_PLD_REV		0x00
+
+/*Global register used to configure the Slic Slac in E1 and T1 mode*/
+struct global_reg {
+    /*Occupied addresses from 0F0 to 0FF*/
+    u8  gtcr1;	/* 0x0f0 - Global Transceiver Control Reg 1 */
+    u8  gfcr;	/* 0x0f1 - Global Framer Control Reg */
+    u8  gtcr2;	/* 0x0f2 - Global Transceiver Control Reg 2 */
+    u8  gtccr;	/* 0x0f3 - Global Transciever Clock Control Reg */
+    u8  res1;	/* 0x0f4 - Reserved */
+    u8  glsrr;	/* 0x0f5 - Global LIU Software Reset Reg */
+    u8  gfsrr;	/* 0x0f6 - Global Framer and BERT Software Reset Reg */
+    u8  res2;	/* 0x0f7 - Reserved */
+    u8  idr;		/* 0x0f8 - Device Identification Reg */
+    u8  gfisr;	/* 0x0f9 - Global Framers Interrupt Status Reg */
+    u8  gbisr;	/* 0x0fa - Global BERT Interrupt Status Reg */
+    u8  glisr;	/* 0x0fb - Global LIU Interrupt Status Reg */
+    u8  gfimr;	/* 0x0fc - Global Framers Interrupt Mask Reg */
+    u8	gbimr;  /* 0x0fd - Global BERT Interrupt Mask Reg */
+    u8  glimr;	/* 0x0fe - Global LIU Interrupt Mask Reg */
+    u8  res3;	/* 0x0ff - Reseved */
+} __attribute__((packed));
+
+/*Registers that control the Receive Framer in E1 Mode and T1 Mode*/
+struct rx_frame {
+    /*Occupied addresses from 000 to 0EF*/
+    u8  res1[16];	/* 0x000 - 0x00f Reserved */
+    u8  rhc;		/* 0x010 - Receive HDLC Control Reg */
+    u8  rhbse;		/* 0x011 - Receive HDLC Bit Suppress Reg */
+    u8  rds0sel;	/* 0x012 - Receive Channel Monitor Select Reg */
+    u8  rsigc;		/* 0x013 - Receive-Signaling Control Reg */
+    u8  rsaimr;		/* 0x014 - Receive Control Register 2 (T1 Mode)
+				   Receive Sa-Bit Interrupt Mask Register
+				   (E1 Mode) */
+    u8  t1rbocc;	/* 0x015 - Receive BOC Ccontrol Reg(T1 Mode Only) */
+    u8  res2[10];	/* 0x016 - 0x01f Reserved */
+    u8  ridr[32];	/* 0x020 - 0x03f Receive Idle Definition 32 Reg
+				   For E1 framming */
+    u8  rs[16];		/* 0x040 - 0x04f RxSignaling[16] For E1 framming*/
+    u8  lcvcr1;		/* 0x050 - Line Code Violation Count Reg 1 */
+    u8  lcvcr2;		/* 0x051 - Line Code Violation Count Reg 2 */
+    u8  pcvcr1;		/* 0x052 - Path Code Violation Count Reg 1 */
+    u8  pcvcr2;		/* 0x053 - Path Code Violation Count Reg 2 */
+    u8  foscr1;		/* 0x054 - Frame Out of Sync Count Reg 1 */
+    u8  foscr2;		/* 0x055 - Frame Out of Sync Count Reg 2 */
+    u8  e1ebcr1;	/* 0x056 - E1-Bit Counter 1(E1 Mode Only) */
+    u8  e1ebcr2;	/* 0x057 - E1-Bit Counter 2(E1 Mode Only) */
+    u8  res3[8];	/* 0x058 - 0x05f Reserved */
+    u8  rds0m;		/* 0x060 - Receive DS0 Monitor Reg */
+    u8  e1rfrid;	/* 0x061 - Receive Firmware Revision ID Register
+				   (E1 Mode Only)*/
+    u8  e1rrts7;	/* 0x062 - Receive FDL Register (T1 Mode)
+				   Receive Real-Time Status Register 7
+				   (E1 Mode) */
+    u8  t1rboc;		/* 0x063 - Receive BOC Register(T1 Mode) */
+    u8  e1raf;		/* 0x064 - Receive SLC-96 Data Link Register 1(T1 Mode)
+				   E1 Receive Align Frame Register (E1 Mode) */
+    u8  e1rnaf;		/* 0x065 - Receive SLC-96 Data Link Register 2(T1 Mode)
+				   E1 Receive Non-Align Frame Register
+				   (E1 Mode) */
+    u8  e1rsiaf;	/* 0x066 - Receive SLC-96 Data Link Register 3(T1 Mode)
+				   E1 Received Si Bits of the Align
+				   Frame Register (E1 Mode)*/
+    u8  e1rsinaf;	/* 0x067 - Receive Si Bit of Non-Align Frame Reg
+				   (E1 Mode) */
+    u8  e1rra;		/* 0x068 - Receive Remote Alarm Reg (E1 Mode) */
+    u8  e1rsa[6];  /* 0x069 - 0x06e E1 Receive Sa Bits Reg
+				   (E1 Mode Only) */
+    u8  sa6code;	/* 0x06f - Received Sa6 Codeword Reg */
+    u8  res5[16];	/* 0x070 - 0x07f Reserved */
+    u8  rmmr;		/* 0x080 - Receive Master Mode Reg */
+    u8  rcr1;		/* 0x081 - Receive Control Reg 1 */
+    u8  rcr2;		/* 0x082 - Receive Control Reg 2 */
+    u8  rcr3;		/* 0x083 - Receive Control Reg 3 */
+    u8  riocr;		/* 0x084 - Receive I/O Config Reg */
+    u8  rescr;		/* 0x085 - Receive Elastic Store Control Reg */
+    u8  ercnt;		/* 0x086 - Error-Counter Config Reg */
+    u8  rhfc;		/* 0x087 - Receive HDLC FIFO Control Reg */
+    u8  riboc;		/* 0x088 - Receive Interleave Bus Operation
+				   Control Reg */
+    u8  t1rscc;		/* 0x089 - In-Band Receive Spare Control Register
+				   (T1 Mode Only)*/
+    u8  rxpc;		/* 0x08a - Receive Expansion Port Control Reg */
+    u8  rbpbs;		/* 0x08b - Receive BERT Port Bit Suppress Reg */
+    u8  res6[4];	/* 0x08c - 0x08f Reserved */
+    u8  rls[7];		/* 0x090 - 0x096 Receive Latched Status Reg */
+    u8  res8;		/* 0x097 - Reserved */
+    u8  rss[4];		/* 0x098 - 0x09b Receive-Signaling Status Reg */
+    u8  t1rscd[2];	/* 0x09c - 0x09d Receive Spare Code Definition Reg
+				   (T1 Mode Only) */
+    u8  res9;		/* 0x09e - Reserved */
+    u8  riir;		/* 0x09f - Receive Interrupt Information Reg */
+    u8  rim[7];		/* 0x0a0 - 0x0a6 Receive Interrupt Mask[7] */
+    u8  res10;		/* 0x0a7 - Reserved */
+    u8  rscse[4];	/* 0x0a8 - 0x0ab Receive-Signaling Change of
+				   State Enable[4] */
+    u8  t1rupcd[2];	/* 0x0ac - 0x0ad Receive Up Code Definition[2]
+				   (T1 mode only) */
+    u8  t1rdncd[2];	/* 0x0ae - 0x0af Receive Down Code Definition[2]
+				   (T1 mode only) */
+    u8  rrts1;		/* 0x0b0 - Receive Real-Time Status Reg 1 */
+    u8  res11;		/* 0x0b1 - Reserved */
+    u8  rrts3;		/* 0x0b2 - Receive Real-Time Status Reg 3 */
+    u8  res12;		/* 0x0b3 - Reserved */
+    u8  rrts5;		/* 0x0b4 - Receive Real-Time Status Reg 5 */
+    u8  rhpba;		/* 0x0b5 - Receive HDLC Packet Bytes Available Reg */
+    u8  rhf;		/* 0x0b6 - Receive HDLC FIFO Reg */
+    u8  res13[9];	/* 0x0b7 - 0x0bf Reserved */
+    u8  rbcs[4];	/* 0x0c0 - 0x0c3 Receive Blank Channel Select[4] */
+    u8  rcbr[4];	/* 0x0c4 - 0x0c7 Receive Channel Blocking[4] */
+    u8  rsi[4];		/* 0x0c8 - 0x0cb Receive-Signalling Reinsertion[4]
+				   Enable Reg */
+    u8  rgccs[4];	/* 0x0cc - 0x0cf Receive Gapped Clock Channel
+				   Select[4] Reg */
+    u8  rcice[4];	/* 0x0d0 - 0x0d3 Receive Channel Idle Code
+				   Enable[4] Reg */
+    u8  rbpcs[4];	/* 0x0d4 - 0x0d7 Receive BERT Port Channel
+				   Select[4] Reg */
+    u8  res14[24];	/* 0x0d8 - 0x0ef Reserved */
+} __attribute__((packed));
+
+struct tx_frame {
+    /*Occupied addresses from 100 to 1FF */
+    u8  res1[16];	/* 0x100 - 0x10f */
+    u8  thc1;		/* 0x110 - Transmit HDLC Control Reg 1 */
+    u8  thbse;		/* 0x111 - Transmit HDLC Bit Suppress Reg */
+    u8  res2;		/* 0x112 - Reserved */
+    u8  thc2;		/* 0x113 - Transmit HDLC Control Reg 2 */
+    u8  e1tsacr;	/* 0x114 - E1 Transmit Sa-Bit Control Reg (E1 Mode) */
+    u8  res3[3];	/* 0x115 - 0x117 Reserved */
+    u8  ssie[4];	/* 0x118 - 0x11b E1 Transmit Sa-Bit Control Reg
+				   (E1 Mode) */
+    u8  res4[4];	/* 0x11c - 0x11f Reserved */
+    u8  tidr[32];	/* 0x120 - 0x13f Transmit Idle Code Definition */
+    u8  ts[16];		/* 0x140 - 0x14f Transmit-Signaling Reg */
+    u8  tcice[4];	/* 0x150 - 0x153 Transmit Channel Idle Code
+				   Enable Reg */
+    u8  res5[13];	/* 0x154 - 0x160 Reserved */
+    u8	tfrid;		/* 0x161 - Transmit Firmware Revision ID Register*/
+    u8  tfdl;		/* 0x162 - Transmit FDL Register (T1 Mode Only) */
+    u8  tboc;		/* 0x163 - Transmit BOC Register (T1 Mode Only) */
+    u8  e1taf;		/* 0x164 - Transmit SLC-96 Data Link Register 1
+				   (T1 Mode)
+				   Transmit Align Frame Register (E1 Mode) */
+    u8  e1tnaf;		/* 0x165 - Transmit SLC-96 Data Link Register 2
+				   (T1 Mode)
+				   Transmit Non-Align Frame Register(E1 Mode)*/
+    u8  e1tsiaf;	/* 0x166 - Transmit SLC-96 Data Link Register 3(T1 Mode)
+				   Transmit Si Bits of the Align Frame Register
+				   (E1 Mode) */
+    u8  e1tsinaf;	/* 0x167 - Transmit Si Bits of the Non-Align
+				   Frame Register (E1 Mode Only) */
+    u8  e1tra;		/* 0x168 - Transmit Remote Alarm Register (E1 Mode) */
+    u8  e1tsa[5];	/* 0x169 - 0x16d Transmit Sa Bits Register
+				   (E1 Mode Only)*/
+    u8  res6[18];	/* 0x16e - 0x17f Reserved */
+    u8  tmmr;		/* 0x180 - Transmit Master Mode Register */
+    u8  tcr[3];		/* 0x181 - 0x183 Transmit Control Register */
+    u8  tiocr;		/* 0x184 - Transmit I/O Configuration Register */
+    u8  tescr;		/* 0x185 - Transmit Elastic Store Control Register */
+    u8  tcr4;		/* 0x186 - Transmit Control Register 4 (T1 Mode Only)*/
+    u8  thfc;		/* 0x187 - Transmit HDLC FIFO Control Register */
+    u8  tiboc;		/* 0x188 - Transmit Interleave Bus Operation
+				   Control Register */
+    u8  tds0sel;	/* 0x189 - Transmit DS0 Channel Monitor Select
+				   Register */
+    u8  txpc;		/* 0x18a - Transmit Expansion Port Control Register */
+    u8  tbpbs;		/* 0x18b - Transmit BERT Port Bit Suppress Register */
+    u8  res7[2];	/* 0x18c - 0x18d Reserved */
+    u8  tsyncc;		/* 0x18e - Transmit Synchronizer Control Register */
+    u8  res8;		/* 0x18f Reserved */
+    u8  tls[3];		/* 0x190 - 0x192 Transmit Latched Status Register*/
+    u8  res9[12];	/* 0x193 - 0x19e Reserved*/
+    u8  tiir;		/* 0x19f - Transmit Interrupt Information Register*/
+    u8  tim[3];		/* 0x1a0 - 0x1a2 Transmit Interrupt Mask Register */
+    u8  res10[9];	/* 0x1a3 - 0x1ab Reserved */
+    u8  titcd[2];	/* 0x1ac - 0x1ad Transmit Code Definition Register */
+    u8  res11[3];	/* 0x1ae - 0x1b0 Reserved */
+    u8  trts2;		/* 0x1b1 - Transmit Real-Time Status Register 2(HDLC)*/
+    u8  res12;		/* 0x1b2 - Reserved */
+    u8  tfba;		/* 0x1b3 - Transmit HDLC FIFO Buffer Available */
+    u8  thf;		/* 0x1b4 - Transmit HDLC FIFO Register */
+    u8  res13[6];	/* 0x1b5 - 0x1ba Reserved */
+    u8  tds0m;		/* 0x1bb - Transmit DS0 Monitor Register */
+    u8  res14[4];	/* 0x1bc - 0x1bf Reserved */
+    u8  tbcs[4];	/* 0x1c0 - 0x1c3 Transmit Blank Channel
+				   Select Register */
+    u8  tcbr[4];	/* 0x1c4 - 0x1c7 Transmit Channel Blocking Register */
+    u8  thscs[4];	/* 0x1c8 - 0x1cb Transmit Hardware-Signaling Channel
+				   Select Register */
+    u8  tgccs[4];	/* 0x1cc - 0x1cf Transmit Gapped-Clock Channel
+				   Select Register */
+    u8  pcl[4];		/* 0x1d0 - 0x1d3 Per-Channel Loopback Enable Register */
+    u8  tbpcs[4];	/* 0x1d4 - 0x1d7 Transmit BERT Port Channel
+				   Select Register */
+    u8  res15[40]; /* 0x1d8 - 0x1ff Reserved */
+} __attribute__((packed));
+
+struct liu_reg {
+    /*Occupied addresses from 1000 to 101F*/
+    u8  ltrcr;		/* 0x1000 - LIU Transmit Receive Control Register */
+    u8  ltitsr;		/* 0x1001 - LIU Transmit Impedance and Pulse Shape
+				    Selection Register */
+    u8  lmcr;		/* 0x1002 - LIU Maintenance Control Register */
+    u8  lrsr;		/* 0x1003 - LIU Real Status Register */
+    u8  lsimr;		/* 0x1004 - LIU Status Interrupt Mask Register */
+    u8  llsr;		/* 0x1005 - LIU Latched Status Register */
+    u8  lrsl;		/* 0x1006 - LIU Receive Signal Level Register */
+    u8  lrismr;		/* 0x1007 - LIU Receive Impedance and Sensitivity
+				    Monitor Register */
+    u8  res1[24];	/* 0x1008 - 0x101f Reserved */
+} __attribute__((packed));
+
+struct bert_reg {
+    /*Occupied addresses from 1100 to 110F*/
+    u8  bawc;		/* 0x1100 - BERT Alternating Word Count Rate Register*/
+    u8  brp[4];		/* 0x1101 - 0x1104 BERT Repetitive Pattern
+				    Set Register */
+    u8  bc[2];		/* 0x1105 - 0x1106 BERT Control Register */
+    u8	bbc[4];		/* 0x1107 - 0x110a BERT Bit Count Register */
+    u8  bec[3];		/* 0x110b - 0x110d BERT Error Count Register */
+    u8  blsr;		/* 0x110e - BERT Latched Status Register */
+    u8  bsim;		/* 0x110f - BERT Status Interrupt Mask Register */
+} __attribute__((packed));
+
+struct link_frame {
+    struct rx_frame	rx;	/*Receive Framer Settings*/
+    struct global_reg	gbl;
+    struct tx_frame	tx;     /*Transmit Framer Registers*/
+} __attribute__((packed));
+
+/* Definition of strucute of the framers */
+struct ds26528_mem {
+    struct link_frame	link[MAX_NUM_OF_CHANNELS];
+    struct liu_reg	liu[MAX_NUM_OF_CHANNELS];
+    struct bert_reg	bert[MAX_NUM_OF_CHANNELS];
+} __attribute__((packed));
+
+struct pld_mem {
+	u8 brdid;
+	u8 brdrev;
+	u8 pldrev;
+	u8 pinset;
+	u8 csr;
+	u8 sysclk_tr;
+	u8 synctss;
+	u8 tcsr1;
+	u8 tcsr2;
+	u8 tsyncs1;
+	u8 ds3set;
+	u8 gcr;
+	u8 rsv[4];
+} __attribute((packed));
+
+enum line_rate_t {
+	LINE_RATE_T1,                   /* T1 line rate (1.544 Mbps)      */
+	LINE_RATE_E1                     /* E1 line rate (2.048 Mbps)     */
+};
+
+enum tdm_trans_mode_t {
+    NORMAL = 0,
+    FRAMER_LB
+};
+
+struct pq_mds_t1 {
+	u32 irq;
+	struct ds26528_mem *ds26528_base;
+	struct pld_mem *pld_base;
+	enum tdm_trans_mode_t trans_mode;
+	enum line_rate_t line_rate;
+};
-- 
1.7.0.4

