From d46eafdb9258dd88d9d10b21d543f626e77d2927 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 26 Jan 2011 15:35:31 +0800
Subject: [PATCH 5/5] powerpc:P1021MDS: set/release muxed QE12 pin for UEC MII and LBCTL

P1021 has QE_MDIO pin muxed with LBCTL pin, which is controlled by
PMUXCR[QE12]. For accessing mdio by probing mdio bus and read/write phy
registers, QE12 needs to be set together with QE9 to enable both
QE_MDIO and QE_MDC. However, after accessing mdio, QE12 needs to be
released so that eLBC can be accessed properly.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>

[Extracted from the P1021MDS-20101124-ltib.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/mpc85xx_mds.c |   41 ++++++++++-------------------
 arch/powerpc/sysdev/Kconfig               |   10 +++++++
 arch/powerpc/sysdev/fsl_soc.c             |   37 ++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_soc.h             |   20 ++++++++++++++
 drivers/net/fsl_pq_mdio.c                 |   37 ++++++++++++++++++++++++++
 5 files changed, 118 insertions(+), 27 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/mpc85xx_mds.c b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
index 04958f9..515874a 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_mds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
@@ -295,37 +295,24 @@ static void __init mpc85xx_mds_setup_arch(void)
 	}
 
 	if (machine_is(p1021_mds)) {
-#define MPC85xx_PMUXCR_OFFSET           0x60
-#define MPC85xx_PMUXCR_QE0              0x00008000
-#define MPC85xx_PMUXCR_QE3              0x00001000
-#define MPC85xx_PMUXCR_QE9              0x00000040
-#define MPC85xx_PMUXCR_QE12             0x00000008
 		static __be32 __iomem *pmuxcr;
 
-		np = of_find_node_by_name(NULL, "global-utilities");
-
-		if (np) {
-			pmuxcr = of_iomap(np, 0) + MPC85xx_PMUXCR_OFFSET;
-
-			if (!pmuxcr)
-				printk(KERN_EMERG "Error: Alternate function"
-					" signal multiplex control register not"
-					" mapped!\n");
-			else
-			/* P1021 has pins muxed for QE and other functions. To
-			 * enable QE UEC mode, we need to set bit QE0 for UCC1
-			 * in Eth mode, QE0 and QE3 for UCC5 in Eth mode, QE9
-			 * and QE12 for QE MII management singals in PMUXCR
-			 * register.
-			 */
+		pmuxcr = p1021_get_pmuxcr();
+		if (!pmuxcr) {
+			printk(KERN_EMERG "Error: Alternate function"
+				" signal multiplex control register not"
+				" mapped!\n");
+		} else {
+#ifdef CONFIG_UCC_GETH
+		/*
+		 * P1021 has pins muxed for QE and other functions. To
+		 * enable QE UEC mode, we need to set bit QE0 for UCC1
+		 * in eth mode, QE0 and QE3 for UCC5 in eth mode.
+		 */
 				setbits32(pmuxcr, MPC85xx_PMUXCR_QE0 |
-						  MPC85xx_PMUXCR_QE3 |
-						  MPC85xx_PMUXCR_QE9 |
-						  MPC85xx_PMUXCR_QE12);
-
-			of_node_put(np);
+					MPC85xx_PMUXCR_QE3);
+#endif /* CONFIG_UCC_GETH */
 		}
-
 	}
 #endif	/* CONFIG_QUICC_ENGINE */
 
diff --git a/arch/powerpc/sysdev/Kconfig b/arch/powerpc/sysdev/Kconfig
index 3965828..e2296e2 100644
--- a/arch/powerpc/sysdev/Kconfig
+++ b/arch/powerpc/sysdev/Kconfig
@@ -12,3 +12,13 @@ config PPC_MSI_BITMAP
 	depends on PCI_MSI
 	default y if MPIC
 	default y if FSL_PCI
+
+config P1021_MDIO_MUX
+	bool "Set and clear MII pins for P1021"
+	depends on QUICC_ENGINE
+	depends on UCC_GETH
+	depends on PPC_85xx
+	help
+	   P1021 has pins muxed for QE_MDIO and LBCTL, thus QE12 in PMUXCR needs
+	   to be set and released for accessing MIIM and eLBC.
+	default n
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 985a511..693dd72 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -434,3 +434,40 @@ void fsl_rstcr_restart(char *cmd)
 struct platform_diu_data_ops diu_ops;
 EXPORT_SYMBOL(diu_ops);
 #endif
+
+static __be32 __iomem *p1021_pmuxcr;
+
+__be32 __iomem *p1021_get_pmuxcr(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_name(NULL, "global-utilities");
+
+	if (np)
+		p1021_pmuxcr = of_iomap(np, 0) + MPC85xx_PMUXCR_OFFSET;
+
+	return p1021_pmuxcr;
+}
+
+#ifdef CONFIG_P1021_MDIO_MUX
+/*
+ * P1021 has pins muxed for QE and other functions.
+ * Set QE9 and QE12 bit in PMUXCR register to enable QE_MDC and QE_MDIO, clear
+ * QE12 to release the QE_MDIO for LBCTL to allow the eLBC data buffer control.
+ * Please note the potential risk may occur if both QE_MDIO and LBCTL needs to
+ * be active simutaneously.
+ */
+void p1021_pmuxcr_mdio_mux(int set)
+{
+	if (p1021_pmuxcr) {
+		if (set == P1021_MUX_MDIO) {
+			setbits32(p1021_pmuxcr, MPC85xx_PMUXCR_QE9);
+			setbits32(p1021_pmuxcr, MPC85xx_PMUXCR_QE12);
+		} else {
+			clrbits32(p1021_pmuxcr, MPC85xx_PMUXCR_QE12);
+		}
+	}
+}
+EXPORT_SYMBOL(p1021_pmuxcr_mdio_mux);
+
+#endif /* CONFIG_P1021_MDIO_MUX */
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index 42381bb..ace61aa 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -35,5 +35,25 @@ struct platform_diu_data_ops {
 extern struct platform_diu_data_ops diu_ops;
 #endif
 
+#define MPC85xx_PMUXCR_OFFSET           0x60
+#define MPC85xx_PMUXCR_QE0              0x00008000
+#define MPC85xx_PMUXCR_QE2              0x00002000
+#define MPC85xx_PMUXCR_QE3              0x00001000
+#define MPC85xx_PMUXCR_QE4              0x00000800
+#define MPC85xx_PMUXCR_QE5              0x00000400
+#define MPC85xx_PMUXCR_QE8              0x00000080
+#define MPC85xx_PMUXCR_QE9              0x00000040
+#define MPC85xx_PMUXCR_QE11             0x00000010
+#define MPC85xx_PMUXCR_QE12             0x00000008
+
+extern __be32 __iomem *p1021_get_pmuxcr(void);
+#ifdef CONFIG_P1021_MDIO_MUX
+#define P1021_MUX_MDIO 1
+#define P1021_MUX_LBCTL 0
+extern void p1021_pmuxcr_mdio_mux(int set);
+#else
+static inline void p1021_pmuxcr_mdio_mux(int set) {}
+#endif /* CONFIG_P1021_MDIO_MUX */
+
 #endif
 #endif
diff --git a/drivers/net/fsl_pq_mdio.c b/drivers/net/fsl_pq_mdio.c
index 8cdc716..650d637 100644
--- a/drivers/net/fsl_pq_mdio.c
+++ b/drivers/net/fsl_pq_mdio.c
@@ -46,6 +46,10 @@
 #include "gianfar.h"
 #include "fsl_pq_mdio.h"
 
+#ifdef CONFIG_P1021_MDIO_MUX
+#include <sysdev/fsl_soc.h>
+#endif
+
 struct fsl_pq_mdio_priv {
 	void __iomem *map;
 	struct fsl_pq_mdio __iomem *regs;
@@ -63,6 +67,10 @@ struct fsl_pq_mdio_priv {
 int fsl_pq_local_mdio_write(struct fsl_pq_mdio __iomem *regs, int mii_id,
 			int regnum, u16 value)
 {
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_MDIO);
+#endif
+
 	/* Set the PHY address and the register address we want to write */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -73,6 +81,10 @@ int fsl_pq_local_mdio_write(struct fsl_pq_mdio __iomem *regs, int mii_id,
 	while (in_be32(&regs->miimind) & MIIMIND_BUSY)
 		cpu_relax();
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_LBCTL);
+#endif
+
 	return 0;
 }
 
@@ -91,6 +103,10 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs, int mii_id,
 {
 	u16 value;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_MDIO);
+#endif
+
 	/* Set the PHY address and the register address we want to read */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -105,6 +121,10 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs, int mii_id,
 	/* Grab the value of the register from miimstat */
 	value = in_be32(&regs->miimstat);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_LBCTL);
+#endif
+
 	return value;
 }
 
@@ -146,6 +166,10 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 	struct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);
 	int timeout = PHY_INIT_TIMEOUT;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_MDIO);
+#endif
+
 	mutex_lock(&bus->mdio_lock);
 
 	/* Reset the management interface */
@@ -160,6 +184,10 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 
 	mutex_unlock(&bus->mdio_lock);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_LBCTL);
+#endif
+
 	if (timeout < 0) {
 		printk(KERN_ERR "%s: The MII Bus is stuck!\n",
 				bus->name);
@@ -421,7 +449,16 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	out_be32(tbipa, tbiaddr);
 #endif
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_MDIO);
+#endif
+
 	err = of_mdiobus_register(new_bus, np);
+
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux(P1021_MUX_LBCTL);
+#endif
+
 	if (err) {
 		printk (KERN_ERR "%s: Cannot register as MDIO bus\n",
 				new_bus->name);
-- 
1.7.0.4

