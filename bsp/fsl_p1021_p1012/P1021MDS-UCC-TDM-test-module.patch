From ff9535f2623f9e6d11effd951db1c1ca372b4a17 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 11 Aug 2011 18:05:59 +0800
Subject: [PATCH 4/5] P1021MDS: UCC TDM test module.

This is a small test module to transfer and receive data via tdm.

Signed-off-by: Kai.Jiang <Kai.Jiang@freescale.com>

[Extracted from the P1021MDS_20110118_TDM_Patch.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]

Integrated-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/tdm/test/Kconfig        |    8 ++
 drivers/tdm/test/Makefile       |    1 +
 drivers/tdm/test/ucc_tdm_test.c |  160 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 169 insertions(+), 0 deletions(-)
 create mode 100644 drivers/tdm/test/ucc_tdm_test.c

diff --git a/drivers/tdm/test/Kconfig b/drivers/tdm/test/Kconfig
index 30f9963..a5aa0d6 100644
--- a/drivers/tdm/test/Kconfig
+++ b/drivers/tdm/test/Kconfig
@@ -10,3 +10,11 @@ config TDM_TEST
 	  This TDM test module is a small test module which
 	  registers with the TDM core(framework) and sets up
 	  a TDM Voice path between Port 0 and Port 1 for each slic.
+ 
+config UCC_TDM_TEST
+	tristate "UCC TDM test Module"
+	default n
+	---help---
+	  This UCC TDM test module is a small test module to test
+	  ucc tdm transfer and receive data via ucc1.
+
diff --git a/drivers/tdm/test/Makefile b/drivers/tdm/test/Makefile
index 40f6725..24a635d 100644
--- a/drivers/tdm/test/Makefile
+++ b/drivers/tdm/test/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_TDM_TEST)	+= tdm_test.o
+obj-$(CONFIG_UCC_TDM_TEST)	+= ucc_tdm_test.o
diff --git a/drivers/tdm/test/ucc_tdm_test.c b/drivers/tdm/test/ucc_tdm_test.c
new file mode 100644
index 0000000..cc8e2d0
--- /dev/null
+++ b/drivers/tdm/test/ucc_tdm_test.c
@@ -0,0 +1,160 @@
+/*
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * TDM Test Module.
+ * This TDM test module is a small test module which registers with the
+ * TDM framework and transfer and receive data via UCC1.
+ *
+ * Author: Kai Jiang <Kai.Jiang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/param.h>
+#include <linux/tdm.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/tdm.h>
+
+#define DRV_DESC "Test Module for Freescale Platforms with TDM support"
+#define DRV_NAME "ucc_tdm_test"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR(" Kai Jiang <Kai.Jiang@freescale.com>");
+MODULE_DESCRIPTION(DRV_DESC);
+
+static struct task_struct *tdm_thread_task;
+static struct tdm_driver test_tdmdev_driver;
+static int tdm_thread_state;
+static int ucc_num = -1;
+
+module_param(ucc_num, int, S_IRUGO);
+
+#define READ_LEN (72*32)	/* BD buffer max len */
+#define WRITE_LEN 0x80
+#define READ_COUNT 4		/* BD ring len */
+
+static int tdm_check_data(void)
+{
+	int i, j;
+	u8 buf[READ_LEN];
+
+	for (j = 0; j < READ_COUNT; j++) {
+
+		memset(buf, 0, READ_LEN);
+		tdm_read_direct(test_tdmdev_driver.adapter, buf, READ_LEN);
+		for (i = 0; (i < READ_LEN); i++) {
+			if (buf[i] != 0xff) {
+				for (j = 0; j < WRITE_LEN; j += 4)
+					printk(KERN_INFO "%x\t%x\t%x\t%x\n",
+						buf[i+j], buf[i+j+1],
+						buf[i+j+2], buf[i+j+3]);
+
+				i = i + WRITE_LEN - 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static int tdm_thread(void *ptr)
+{
+	u8 send_buf[WRITE_LEN];
+	int i;
+
+	for (i = 0; i < 0x80; i++)
+		send_buf[i] = i;
+	/* start TDM */
+	tdm_master_enable(&test_tdmdev_driver);
+	/* write data */
+	tdm_write_direct(test_tdmdev_driver.adapter, send_buf, WRITE_LEN);
+	/* read and print data */
+	tdm_check_data();
+	/* stop TDM */
+	tdm_master_disable(&test_tdmdev_driver);
+
+	return 0;
+}
+static int test_attach_adapter(struct tdm_adapter *adap)
+{
+	pr_debug("tdm-dev: adapter [%s] registered as minor %d\n",
+		 adap->name, adap->id);
+	tdm_thread_state = 0;
+	tdm_thread_task = kthread_run(tdm_thread, NULL, "tdm_thread");
+
+	return 0;
+}
+
+static int test_detach_adapter(struct tdm_adapter *adap)
+{
+	if (tdm_thread_state)
+		kthread_stop(tdm_thread_task);
+
+	pr_debug("tdm-dev: adapter [%s] unregistered\n", adap->name);
+
+	return 0;
+}
+
+static const struct tdm_device_id test_ucc_tdm_id[] = {
+	{ "tdm_ucc_1", 0 },
+	{ }
+};
+
+static struct tdm_driver test_tdmdev_driver = {
+	.attach_adapter	= test_attach_adapter,
+	.detach_adapter	= test_detach_adapter,
+	.id_table = test_ucc_tdm_id,
+};
+
+static int __init tdm_test_init(void)
+{
+	int ret;
+	pr_info("TDM_TEST: " DRV_DESC "\n");
+
+	if ((ucc_num >= 0) && (ucc_num < 8))
+		sprintf((char *)test_ucc_tdm_id[0].name, "%s%d",
+			"tdm_ucc_", ucc_num);
+
+	test_tdmdev_driver.id = 1;
+
+	/* create a binding with TDM driver */
+	ret = tdm_add_driver(&test_tdmdev_driver);
+	if (ret == 0)
+		pr_info("TDM_TEST module installed\n");
+	else
+		pr_err("%s tdm_port_init failed\n", __func__);
+
+	return ret;
+
+}
+
+static void __exit tdm_test_exit(void)
+{
+	tdm_del_driver(&test_tdmdev_driver);
+	pr_info("TDM_TEST module un-installed\n");
+}
+
+module_init(tdm_test_init);
+module_exit(tdm_test_exit);
-- 
1.7.0.4

