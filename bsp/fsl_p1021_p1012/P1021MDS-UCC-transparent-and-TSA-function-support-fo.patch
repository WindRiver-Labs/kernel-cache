From ee7b67445c8afb5f9f153351f75eb76d5e2e27ee Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 28 Jul 2011 10:37:07 +0800
Subject: [PATCH 1/5] P1021MDS: UCC transparent and TSA function support for TDM.

This patch enabled UCC as transparent controller, working in continue
mode, and enabled TSA A/B/C/D ports to send and receive data from UCC.
This TDM function can transfer and receive data at different time slot
based on tdm dts setting. Different UCC and TSA port can be binded to
one TDM based on dts.
It also added tdm clock configuration in both qe clock system and
ucc fast controller.

This tdm driver connected to tdm core, and tdm core exported function
interfaces for user in kernel space.

Signed-off-by: Kai.Jiang <Kai.Jiang@freescale.com>

[Extracted from the P1021MDS_20110118_TDM_Patch.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]

Integrated-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/qe.h             |   11 +
 arch/powerpc/include/asm/ucc.h            |    6 +-
 arch/powerpc/include/asm/ucc_fast.h       |    7 +-
 arch/powerpc/platforms/85xx/mpc85xx_mds.c |   36 +-
 arch/powerpc/sysdev/fsl_soc.h             |    1 +
 arch/powerpc/sysdev/qe_lib/Kconfig        |    2 +-
 arch/powerpc/sysdev/qe_lib/qe.c           |    6 +
 arch/powerpc/sysdev/qe_lib/ucc.c          |  774 +++++++++++++++++++++-
 arch/powerpc/sysdev/qe_lib/ucc_fast.c     |  101 ++-
 drivers/tdm/device/Kconfig                |    7 +
 drivers/tdm/device/Makefile               |    2 +-
 drivers/tdm/device/fsl_ucc_tdm.c          | 1068 +++++++++++++++++++++++++++++
 drivers/tdm/device/fsl_ucc_tdm.h          |  165 +++++
 drivers/tdm/tdm-core.c                    |   39 +-
 include/linux/tdm.h                       |    9 +-
 15 files changed, 2199 insertions(+), 35 deletions(-)
 create mode 100644 drivers/tdm/device/fsl_ucc_tdm.c
 create mode 100644 drivers/tdm/device/fsl_ucc_tdm.h

diff --git a/arch/powerpc/include/asm/qe.h b/arch/powerpc/include/asm/qe.h
index 0947b36..12af762 100644
--- a/arch/powerpc/include/asm/qe.h
+++ b/arch/powerpc/include/asm/qe.h
@@ -75,6 +75,8 @@ enum qe_clock {
 	QE_CLK22,		/* Clock 22 */
 	QE_CLK23,		/* Clock 23 */
 	QE_CLK24,		/* Clock 24 */
+	QE_RSYNC_PIN,	/* RSYNC from pin */
+	QE_TSYNC_PIN,	/* TSYNC from pin */
 	QE_CLK_DUMMY
 };
 
@@ -635,6 +637,15 @@ struct ucc_slow_pram {
 #define UCC_BISYNC_UCCE_TXB	0x0002
 #define UCC_BISYNC_UCCE_RXB	0x0001
 
+/* Transparent UCC Event Register (UCCE) */
+#define UCC_TRANS_UCCE_GRA	0x0080
+#define UCC_TRANS_UCCE_TXE	0x0010
+#define UCC_TRANS_UCCE_RXF	0x0008
+#define UCC_TRANS_UCCE_BSY	0x0004
+#define UCC_TRANS_UCCE_TXB	0x0002
+#define UCC_TRANS_UCCE_RXB	0x0001
+
+
 /* Gigabit Ethernet Fast UCC Event Register (UCCE) */
 #define UCC_GETH_UCCE_MPD       0x80000000
 #define UCC_GETH_UCCE_SCAR      0x40000000
diff --git a/arch/powerpc/include/asm/ucc.h b/arch/powerpc/include/asm/ucc.h
index 46b09ba..57a4caf 100644
--- a/arch/powerpc/include/asm/ucc.h
+++ b/arch/powerpc/include/asm/ucc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006 Freescale Semicondutor, Inc. All rights reserved.
+ * Copyright (C) 2006, 2011 Freescale Semicondutor, Inc. All rights reserved.
  *
  * Authors: 	Shlomi Gridish <gridish@freescale.com>
  * 		Li Yang <leoli@freescale.com>
@@ -41,6 +41,10 @@ int ucc_set_qe_mux_mii_mng(unsigned int ucc_num);
 
 int ucc_set_qe_mux_rxtx(unsigned int ucc_num, enum qe_clock clock,
 	enum comm_dir mode);
+int ucc_set_tdm_rxtx_clk(u32 tdm_num, enum qe_clock clock,
+	enum comm_dir mode);
+int ucc_set_tdm_rxtx_sync(u32 tdm_num, enum qe_clock clock,
+	enum comm_dir mode);
 
 int ucc_mux_set_grant_tsa_bkpt(unsigned int ucc_num, int set, u32 mask);
 
diff --git a/arch/powerpc/include/asm/ucc_fast.h b/arch/powerpc/include/asm/ucc_fast.h
index 839aab8..30f0491 100644
--- a/arch/powerpc/include/asm/ucc_fast.h
+++ b/arch/powerpc/include/asm/ucc_fast.h
@@ -1,7 +1,7 @@
 /*
  * Internal header file for UCC FAST unit routines.
  *
- * Copyright (C) 2006 Freescale Semicondutor, Inc. All rights reserved.
+ * Copyright (C) 2006, 2011 Freescale Semicondutor, Inc. All rights reserved.
  *
  * Authors: 	Shlomi Gridish <gridish@freescale.com>
  * 		Li Yang <leoli@freescale.com>
@@ -27,12 +27,14 @@
 #define R_I	0x10000000	/* interrupt on reception */
 #define R_L	0x08000000	/* last */
 #define R_F	0x04000000	/* first */
+#define R_CM	0x02000000	/* CM */
 
 /* transmit BD's status */
 #define T_R	0x80000000	/* ready bit */
 #define T_W	0x20000000	/* wrap bit */
 #define T_I	0x10000000	/* interrupt on completion */
 #define T_L	0x08000000	/* last */
+#define T_CM	0x02000000	/* CM */
 
 /* Rx Data buffer must be 4 bytes aligned in most cases */
 #define UCC_FAST_RX_ALIGN			4
@@ -118,8 +120,11 @@ enum ucc_fast_transparent_tcrc {
 /* Fast UCC initialization structure */
 struct ucc_fast_info {
 	int ucc_num;
+	int tdm_num;
 	enum qe_clock rx_clock;
 	enum qe_clock tx_clock;
+	enum qe_clock rx_sync;
+	enum qe_clock tx_sync;
 	u32 regs;
 	int irq;
 	u32 uccm_mask;
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_mds.c b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
index 515874a..c7f572f 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_mds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) Freescale Semicondutor, Inc. 2006-2010. All rights reserved.
+ * Copyright (C) 2006-2011 Freescale Semiconductor, Inc.  All rights reserved.
  *
  * Author: Andy Fleming <afleming@freescale.com>
  *
@@ -286,9 +286,25 @@ static void __init mpc85xx_mds_setup_arch(void)
 
 		} else if (machine_is(p1021_mds)) {
 #define BCSR11_ENET_MICRST     (0x1 << 5)
+#define BCSR6_1588_TDMA         (0x1 << 7)
+#define BCSR6_UPC_EN            (0x1 << 4)
+#define BCSR6_TDMB_ENET1        (0x1)
+#define BCSR6_TDMC_NIBBLE       (0x1 << 1)
+#define BCSR6_TDMC_ENET5        (0x1 << 3)
+#define BCSR6_TDMD_UART1        (0x1 << 2)
+
 			/* Reset Micrel PHY */
 			clrbits8(&bcsr_regs[11], BCSR11_ENET_MICRST);
 			setbits8(&bcsr_regs[11], BCSR11_ENET_MICRST);
+
+#ifdef CONFIG_TDM
+			clrbits8(&bcsr_regs[6], BCSR6_1588_TDMA);
+			setbits8(&bcsr_regs[6], BCSR6_TDMB_ENET1 |
+						BCSR6_UPC_EN);
+			setbits8(&bcsr_regs[6], BCSR6_TDMC_ENET5);
+			clrbits8(&bcsr_regs[6], BCSR6_TDMC_NIBBLE);
+			setbits8(&bcsr_regs[6], BCSR6_TDMD_UART1);
+#endif /* CONFIG_TDM */
 		}
 
 		iounmap(bcsr_regs);
@@ -312,6 +328,24 @@ static void __init mpc85xx_mds_setup_arch(void)
 				setbits32(pmuxcr, MPC85xx_PMUXCR_QE0 |
 					MPC85xx_PMUXCR_QE3);
 #endif /* CONFIG_UCC_GETH */
+
+#ifdef CONFIG_TDM
+
+			/* Clear QE12 for releasing the LBCTL */
+			clrbits32(pmuxcr, MPC85xx_PMUXCR_QE12);
+			/* TDMA */
+			setbits32(pmuxcr, MPC85xx_PMUXCR_QE5 |
+					  MPC85xx_PMUXCR_QE11);
+			/* TDMB */
+			setbits32(pmuxcr, MPC85xx_PMUXCR_QE0 |
+					  MPC85xx_PMUXCR_QE9);
+			/* TDMC */
+			 setbits32(pmuxcr, MPC85xx_PMUXCR_QE0);
+			/* TDMD */
+			setbits32(pmuxcr, MPC85xx_PMUXCR_QE8 |
+					  MPC85xx_PMUXCR_QE7);
+
+#endif /* CONFIG_TDM */
 		}
 	}
 #endif	/* CONFIG_QUICC_ENGINE */
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index ace61aa..473c7af 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -41,6 +41,7 @@ extern struct platform_diu_data_ops diu_ops;
 #define MPC85xx_PMUXCR_QE3              0x00001000
 #define MPC85xx_PMUXCR_QE4              0x00000800
 #define MPC85xx_PMUXCR_QE5              0x00000400
+#define MPC85xx_PMUXCR_QE7				0x00000100
 #define MPC85xx_PMUXCR_QE8              0x00000080
 #define MPC85xx_PMUXCR_QE9              0x00000040
 #define MPC85xx_PMUXCR_QE11             0x00000010
diff --git a/arch/powerpc/sysdev/qe_lib/Kconfig b/arch/powerpc/sysdev/qe_lib/Kconfig
index 41ac3df..54ee9d1 100644
--- a/arch/powerpc/sysdev/qe_lib/Kconfig
+++ b/arch/powerpc/sysdev/qe_lib/Kconfig
@@ -11,7 +11,7 @@ config UCC_SLOW
 
 config UCC_FAST
 	bool
-	default y if UCC_GETH
+	default y if UCC_GETH || FSL_UCC_TDM
 	help
 	  This option provides qe_lib support to UCC fast
 	  protocols: HDLC, Ethernet, ATM, transparent
diff --git a/arch/powerpc/sysdev/qe_lib/qe.c b/arch/powerpc/sysdev/qe_lib/qe.c
index 149393c..fd7966f 100644
--- a/arch/powerpc/sysdev/qe_lib/qe.c
+++ b/arch/powerpc/sysdev/qe_lib/qe.c
@@ -240,6 +240,12 @@ enum qe_clock qe_clock_source(const char *source)
 	if (strcasecmp(source, "none") == 0)
 		return QE_CLK_NONE;
 
+	if (strcasecmp(source, "tsync_pin") == 0)
+		return QE_TSYNC_PIN;
+
+	if (strcasecmp(source, "rsync_pin") == 0)
+		return QE_RSYNC_PIN;
+
 	if (strncasecmp(source, "brg", 3) == 0) {
 		i = simple_strtoul(source + 3, NULL, 10);
 		if ((i >= 1) && (i <= 16))
diff --git a/arch/powerpc/sysdev/qe_lib/ucc.c b/arch/powerpc/sysdev/qe_lib/ucc.c
index fa589b2..998caab 100644
--- a/arch/powerpc/sysdev/qe_lib/ucc.c
+++ b/arch/powerpc/sysdev/qe_lib/ucc.c
@@ -3,7 +3,7 @@
  *
  * QE UCC API Set - UCC specific routines implementations.
  *
- * Copyright (C) 2006 Freescale Semicondutor, Inc. All rights reserved.
+ * Copyright (C) 2006, 2011 Freescale Semicondutor, Inc. All rights reserved.
  *
  * Authors: 	Shlomi Gridish <gridish@freescale.com>
  * 		Li Yang <leoli@freescale.com>
@@ -211,3 +211,775 @@ int ucc_set_qe_mux_rxtx(unsigned int ucc_num, enum qe_clock clock,
 
 	return 0;
 }
+
+/* tdm_num: TDM A-H port num is 0-7 */
+int ucc_set_tdm_rxtx_clk(u32 tdm_num, enum qe_clock clock,
+		enum comm_dir mode)
+{
+	u32 clock_bits, shift;
+	struct qe_mux *qe_mux_reg = NULL;
+	 __be32 __iomem *cmxs1cr;
+
+	clock_bits = 0;
+	qe_mux_reg = &qe_immr->qmx;
+
+	if ((tdm_num > 7 || tdm_num < 0))
+		return -EINVAL;
+
+	/* The communications direction must be RX or TX */
+	if (!((mode == COMM_DIR_RX) || (mode == COMM_DIR_TX)))
+		return -EINVAL;
+
+	switch (mode) {
+	case COMM_DIR_RX:
+		switch (tdm_num) {
+		case 0:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK3:
+					clock_bits = 6;
+					break;
+			case QE_CLK8:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 28;
+			break;
+		case 1:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK5:
+					clock_bits = 6;
+					break;
+			case QE_CLK10:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 24;
+			break;
+		case 2:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK7:
+					clock_bits = 6;
+					break;
+			case QE_CLK12:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 20;
+			break;
+		case 3:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK9:
+					clock_bits = 6;
+					break;
+			case QE_CLK14:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 16;
+			break;
+		case 4:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK11:
+					clock_bits = 6;
+					break;
+			case QE_CLK16:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 28;
+			break;
+		case 5:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK13:
+					clock_bits = 6;
+					break;
+			case QE_CLK18:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 24;
+			break;
+		case 6:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK15:
+					clock_bits = 6;
+					break;
+			case QE_CLK20:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 20;
+			break;
+		case 7:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK17:
+					clock_bits = 6;
+					break;
+			case QE_CLK22:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 16;
+			break;
+		default:
+				break;
+		}
+		break;
+	case COMM_DIR_TX:
+		switch (tdm_num) {
+		case 0:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK4:
+					clock_bits = 6;
+					break;
+			case QE_CLK9:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 12;
+			break;
+		case 1:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK6:
+					clock_bits = 6;
+					break;
+			case QE_CLK11:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 8;
+			break;
+		case 2:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK8:
+					clock_bits = 6;
+					break;
+			case QE_CLK13:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 4;
+			break;
+		case 3:
+			switch (clock) {
+			case QE_BRG3:
+					clock_bits = 1;
+					break;
+			case QE_BRG4:
+					clock_bits = 2;
+					break;
+			case QE_CLK1:
+					clock_bits = 4;
+					break;
+			case QE_CLK2:
+					clock_bits = 5;
+					break;
+			case QE_CLK10:
+					clock_bits = 6;
+					break;
+			case QE_CLK15:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 0;
+			break;
+		case 4:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK12:
+					clock_bits = 6;
+					break;
+			case QE_CLK17:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 12;
+			break;
+		case 5:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK14:
+					clock_bits = 6;
+					break;
+			case QE_CLK19:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 8;
+			break;
+		case 6:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK16:
+					clock_bits = 6;
+					break;
+			case QE_CLK21:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 4;
+			break;
+		case 7:
+			switch (clock) {
+			case QE_BRG12:
+					clock_bits = 1;
+					break;
+			case QE_BRG13:
+					clock_bits = 2;
+					break;
+			case QE_CLK23:
+					clock_bits = 4;
+					break;
+			case QE_CLK24:
+					clock_bits = 5;
+					break;
+			case QE_CLK18:
+					clock_bits = 6;
+					break;
+			case QE_CLK3:
+					clock_bits = 7;
+					break;
+			default:
+					break;
+			}
+			shift = 0;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (!clock_bits)
+		return -ENOENT;
+
+	cmxs1cr = (tdm_num < 4) ? (&qe_mux_reg->cmxsi1cr_l) :
+				  (&qe_mux_reg->cmxsi1cr_h);
+
+	clrsetbits_be32(cmxs1cr, QE_CMXUCR_TX_CLK_SRC_MASK << shift,
+		   clock_bits << shift);
+
+       return 0;
+}
+
+
+int ucc_set_tdm_rxtx_sync(u32 tdm_num, enum qe_clock clock,
+		enum comm_dir mode)
+{
+	u32 shift, clock_bits;
+	struct qe_mux *qe_mux_reg = NULL;
+	int source;
+
+	source = 0;
+	shift = 0;
+	qe_mux_reg = &qe_immr->qmx;
+
+	if ((tdm_num > 7 || tdm_num < 0))
+		return -EINVAL;
+
+	/* The communications direction must be RX or TX */
+	if (!((mode == COMM_DIR_RX) || (mode == COMM_DIR_TX)))
+		return -EINVAL;
+
+	switch (mode) {
+	case COMM_DIR_RX:
+		switch (tdm_num) {
+		case 0:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG10:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 30;
+			break;
+		case 1:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG10:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 28;
+			break;
+		case 2:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG11:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 26;
+			break;
+		case 3:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG11:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 24;
+			break;
+		case 4:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG14:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 22;
+			break;
+		case 5:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG14:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 20;
+			break;
+		case 6:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG15:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 18;
+			break;
+		case 7:
+			switch (clock) {
+			case QE_RSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG15:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 16;
+			break;
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	case COMM_DIR_TX:
+		switch (tdm_num) {
+		case 0:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG10:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 14;
+			break;
+		case 1:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG10:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 12;
+			break;
+		case 2:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG11:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 10;
+			break;
+		case 3:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG9:
+					source = 1;
+					break;
+			case QE_BRG11:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 8;
+			break;
+		case 4:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG14:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 6;
+			break;
+		case 5:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG14:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 4;
+			break;
+		case 6:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG15:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 2;
+			break;
+		case 7:
+			switch (clock) {
+			case QE_TSYNC_PIN:
+					source = 0;
+					break;
+			case QE_BRG13:
+					source = 1;
+					break;
+			case QE_BRG15:
+					source = 2;
+					break;
+			default:
+					source = -1;
+					break;
+			}
+			shift = 0;
+			break;
+
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	default:
+		source = -1;
+		break;
+       }
+
+	if (source == -1)
+		return -ENOENT;
+
+	clock_bits = (u32) source;
+
+	clrsetbits_be32(&qe_mux_reg->cmxsi1syr,
+			QE_CMXUCR_TX_CLK_SRC_MASK << shift,
+			clock_bits << shift);
+
+       return 0;
+}
+
diff --git a/arch/powerpc/sysdev/qe_lib/ucc_fast.c b/arch/powerpc/sysdev/qe_lib/ucc_fast.c
index 25fbbfa..6f68ca1 100644
--- a/arch/powerpc/sysdev/qe_lib/ucc_fast.c
+++ b/arch/powerpc/sysdev/qe_lib/ucc_fast.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006 Freescale Semicondutor, Inc. All rights reserved.
+ * Copyright (C) 2006, 2009, 2011 Freescale Semiconductor, Inc. All rights reserved.
  *
  * Authors: 	Shlomi Gridish <gridish@freescale.com>
  * 		Li Yang <leoli@freescale.com>
@@ -301,32 +301,79 @@ int ucc_fast_init(struct ucc_fast_info * uf_info, struct ucc_fast_private ** ucc
 	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
 	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
 
-	/* Mux clocking */
-	/* Grant Support */
-	ucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);
-	/* Breakpoint Support */
-	ucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);
-	/* Set Tsa or NMSI mode. */
-	ucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);
-	/* If NMSI (not Tsa), set Tx and Rx clock. */
-	if (!uf_info->tsa) {
-		/* Rx clock routing */
-		if ((uf_info->rx_clock != QE_CLK_NONE) &&
-		    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->rx_clock,
-					COMM_DIR_RX)) {
-			printk(KERN_ERR "%s: illegal value for RX clock\n",
-			       __func__);
-			ucc_fast_free(uccf);
-			return -EINVAL;
-		}
-		/* Tx clock routing */
-		if ((uf_info->tx_clock != QE_CLK_NONE) &&
-		    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->tx_clock,
-					COMM_DIR_TX)) {
-			printk(KERN_ERR "%s: illegal value for TX clock\n",
-			       __func__);
-			ucc_fast_free(uccf);
-			return -EINVAL;
+	/*
+	 * If UCC works as ATM, its clocks come from UPC
+	 * and do not needs io pins
+	 */
+	if (uf_info->mode != UCC_FAST_PROTOCOL_MODE_ATM) {
+		/* Mux clocking */
+		/* Grant Support */
+		ucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);
+		/* Breakpoint Support */
+		ucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);
+		/* Set Tsa or NMSI mode. */
+		ucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);
+		/* If NMSI (not Tsa), set Tx and Rx clock. */
+		if (!uf_info->tsa) {
+			/* Rx clock routing */
+			if ((uf_info->rx_clock != QE_CLK_NONE) &&
+				ucc_set_qe_mux_rxtx(uf_info->ucc_num,
+					uf_info->rx_clock, COMM_DIR_RX)) {
+				printk(KERN_ERR "%s: illegal value for RX clock\n",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+			/* Tx clock routing */
+			if ((uf_info->tx_clock != QE_CLK_NONE) &&
+				ucc_set_qe_mux_rxtx(uf_info->ucc_num,
+					uf_info->tx_clock, COMM_DIR_TX)) {
+				printk(KERN_ERR "%s: illegal value for TX clock\n",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+		} else {
+			/* tdm Rx clock routing */
+			if ((uf_info->rx_clock != QE_CLK_NONE) &&
+				ucc_set_tdm_rxtx_clk(uf_info->tdm_num,
+					uf_info->rx_clock, COMM_DIR_RX)) {
+				printk(KERN_ERR"%s: illegal value for RX clock",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+
+			/* tdm Tx clock routing */
+			if ((uf_info->tx_clock != QE_CLK_NONE) &&
+				ucc_set_tdm_rxtx_clk(uf_info->tdm_num,
+					uf_info->tx_clock, COMM_DIR_TX)) {
+				printk(KERN_ERR "%s:illegal value for TX clock",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+
+			/* tdm Rx sync clock routing */
+			if ((uf_info->rx_sync != QE_CLK_NONE) &&
+				ucc_set_tdm_rxtx_sync(uf_info->tdm_num,
+					uf_info->rx_sync, COMM_DIR_RX)) {
+				printk(KERN_ERR "%s:illegal value for TX clock",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+
+			/* tdm Tx sync clock routing */
+			if ((uf_info->tx_sync != QE_CLK_NONE) &&
+				ucc_set_tdm_rxtx_sync(uf_info->tdm_num,
+					uf_info->tx_sync, COMM_DIR_TX)) {
+				printk(KERN_ERR "%s:illegal value for TX clock",
+					__func__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+
 		}
 	}
 
diff --git a/drivers/tdm/device/Kconfig b/drivers/tdm/device/Kconfig
index 1c4e3ba..8998e05 100644
--- a/drivers/tdm/device/Kconfig
+++ b/drivers/tdm/device/Kconfig
@@ -12,4 +12,11 @@ config TDM_FSL_STARLITE
           is found in various Freescale SOCs viz MPC8315, P1020. The TDM driver
           basically multiplexes and demultiplexes data from different channels.
           The TDM can interface SLIC kind of devices.
+
+config FSL_UCC_TDM
+       tristate "UCC TDM driver for Freescale QE engine"
+       depends on FSL_SOC || CONFIG_QE
+       ---help---
+         This is a driver for Freescale QE UCC working with TDM interface.
+
 endmenu
diff --git a/drivers/tdm/device/Makefile b/drivers/tdm/device/Makefile
index ed07d86..21b6c02 100644
--- a/drivers/tdm/device/Makefile
+++ b/drivers/tdm/device/Makefile
@@ -3,7 +3,7 @@
 #
 
 obj-$(CONFIG_TDM_FSL_STARLITE)	+= tdm_fsl_starlite.o
-
+obj-$(CONFIG_FSL_UCC_TDM)	+= fsl_ucc_tdm.o
 #ifeq ($(CONFIG_TDM_DEBUG_BUS),y)
 #EXTRA_CFLAGS += -DDEBUG
 #endif
diff --git a/drivers/tdm/device/fsl_ucc_tdm.c b/drivers/tdm/device/fsl_ucc_tdm.c
new file mode 100644
index 0000000..25f90af
--- /dev/null
+++ b/drivers/tdm/device/fsl_ucc_tdm.c
@@ -0,0 +1,1068 @@
+/*
+ * Freescale QUICC Engine TDM Device Driver
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author:	Haiying Wang	<Haiying.Wang@freescale.com>
+ *		Kai Jiang	<Kai.Jiang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * This driver adds support for TDM devices via Freescale's QUICC Engine.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/tdm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <sysdev/fsl_soc.h>
+#include <sysdev/fsl_soc.h>
+#include "fsl_ucc_tdm.h"
+
+#define DRV_DESC "Freescale QE UCC TDM Driver"
+#define DRV_NAME "ucc_tdm"
+
+#undef DEBUG
+
+static struct ucc_tdm_info utdm_primary_info = {
+	.uf_info = {
+		.tsa = 1,
+		.cdp = 1,
+		.cds = 1,
+		.ctsp = 1,
+		.ctss = 1,
+		.revd = 0,
+		.urfs = 256,
+		.utfs = 256,
+		.urfet = 128,
+		.urfset = 192,
+		.utfet = 128,
+		.utftt = 0x40,
+		.ufpt = 256,
+		.ttx_trx = UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_TRANSPARENT,
+		.tenc = UCC_FAST_TX_ENCODING_NRZ,
+		.renc = UCC_FAST_RX_ENCODING_NRZ,
+		.tcrc = UCC_FAST_16_BIT_CRC,
+		.synl = UCC_FAST_SYNC_LEN_NOT_USED,
+	},
+
+	.si_info = {
+		.simr_rfsd = 1,		/* pq_mds_t1 card need 1 bit delay */
+		.simr_tfsd = 0,
+		.simr_crt = 0,
+		.simr_sl = 0,
+		.simr_ce = 1,
+		.simr_fe = 1,
+		.simr_gm = 0,
+	},
+};
+
+static struct ucc_tdm_info utdm_info[MAX_TDM_NUM];
+
+#ifdef DEBUG
+static void dump_siram(struct ucc_tdm_private *priv)
+{
+	int i;
+	u16 *siram = priv->siram;
+
+	pr_info(" Dump the SI RX RAM\n");
+	for (i = 0; i < priv->num_of_ts; i++) {
+		pr_info("%04x ", siram[priv->siram_entry_id * 32 + i]);
+		if ((i + 1) % 4)
+			pr_info("\n");
+	}
+
+	pr_info(" Dump the SI TX RAM\n");
+	for (i = 0; i < priv->num_of_ts; i++) {
+		pr_info("%04x ", siram[priv->siram_entry_id * 32 + 0x200 + i]);
+		if ((i + 1) % 4)
+			pr_info("\n");
+	}
+}
+
+static void mem_disp(u8 *addr, int size)
+{
+	u8 *i;
+	int size16Aling = (size >> 4) << 4;
+	int size4Aling = (size >> 2) << 2;
+	int notAlign = 0;
+	if (size % 16)
+		notAlign = 1;
+
+	for (i = addr; (u32) i < (u32) addr + size16Aling; i += 16)
+		pr_info("0x%08x: %08x %08x %08x %08x\r\n",
+			(u32) i,
+			*((u32 *) (i)),
+			*((u32 *) (i + 4)),
+			*((u32 *) (i + 8)), *((u32 *) (i + 12)));
+	if (notAlign == 1)
+		pr_info("0x%08x: ", (u32) i);
+	for (; (u32) i < (u32) addr + size4Aling; i += 4)
+		pr_info("%08x ", *((u32 *) (i)));
+	for (; (u32) i < (u32) addr + size; i++)
+		pr_info("%02x", *((u8 *) (i)));
+	if (notAlign == 1)
+		pr_info("\r\n");
+}
+
+static void dump_ucc(struct ucc_tdm_private *priv)
+{
+	struct ucc_transparent_param *ucc_pram;
+	ucc_pram = priv->ucc_pram;
+
+	pr_info("Dumping UCC %d Registers\n", priv->ut_info->uf_info.ucc_num);
+	ucc_fast_dump_regs(priv->uccf);
+	pr_info("Dumping UCC %d Parameter RAM\n",
+			priv->ut_info->uf_info.ucc_num);
+	pr_info("rbase = 0x%x\n", in_be32(&ucc_pram->rbase));
+	pr_info("rbptr = 0x%x\n", in_be32(&ucc_pram->rbptr));
+	pr_info("mrblr = 0x%x\n", in_be16(&ucc_pram->mrblr));
+	pr_info("rbdlen = 0x%x\n", in_be16(&ucc_pram->rbdlen));
+	pr_info("rbdstat = 0x%x\n", in_be16(&ucc_pram->rbdstat));
+	pr_info("rstate = 0x%x\n", in_be32(&ucc_pram->rstate));
+	pr_info("rdptr = 0x%x\n", in_be32(&ucc_pram->rdptr));
+	pr_info("riptr = 0x%x\n", in_be16(&ucc_pram->riptr));
+	pr_info("tbase = 0x%x\n", in_be32(&ucc_pram->tbase));
+	pr_info("tbptr = 0x%x\n", in_be32(&ucc_pram->tbptr));
+	pr_info("tbdlen = 0x%x\n", in_be16(&ucc_pram->tbdlen));
+	pr_info("tbdstat = 0x%x\n", in_be16(&ucc_pram->tbdstat));
+	pr_info("tstate = 0x%x\n", in_be32(&ucc_pram->tstate));
+	pr_info("tdptr = 0x%x\n", in_be32(&ucc_pram->tdptr));
+	pr_info("tiptr = 0x%x\n", in_be16(&ucc_pram->tiptr));
+	pr_info("rcrc = 0x%x\n", in_be32(&ucc_pram->rcrc));
+	pr_info("tcrc = 0x%x\n", in_be32(&ucc_pram->tcrc));
+	pr_info("c_mask = 0x%x\n", in_be32(&ucc_pram->c_mask));
+	pr_info("c_pers = 0x%x\n", in_be32(&ucc_pram->c_pres));
+	pr_info("disfc = 0x%x\n", in_be16(&ucc_pram->disfc));
+	pr_info("crcec = 0x%x\n", in_be16(&ucc_pram->crcec));
+}
+
+static void dump_bds(struct ucc_tdm_private *priv)
+{
+	int length;
+
+	if (priv->tx_bd) {
+		length = sizeof(struct qe_bd) * NUM_OF_BUF;
+		pr_info(" Dump tx BDs\n");
+		mem_disp((u8 *)priv->tx_bd, length);
+	}
+
+	if (priv->rx_bd) {
+		length = sizeof(struct qe_bd) * NUM_OF_BUF;
+		pr_info(" Dump rx BDs\n");
+		mem_disp((u8 *)priv->rx_bd, length);
+	}
+
+}
+
+static void dump_priv(struct ucc_tdm_private *priv)
+{
+	pr_info("ut_info = 0x%x\n", (u32)priv->ut_info);
+	pr_info("uccf = 0x%x\n", (u32)priv->uccf);
+	pr_info("uf_regs = 0x%x\n", (u32)priv->uf_regs);
+	pr_info("si_regs = 0x%x\n", (u32)priv->si_regs);
+	pr_info("ucc_pram = 0x%x\n", (u32)priv->ucc_pram);
+	pr_info("tdm_port = 0x%x\n", (u32)priv->tdm_port);
+	pr_info("siram_entry_id = 0x%x\n", priv->siram_entry_id);
+	pr_info("siram = 0x%x\n", (u32)priv->siram);
+	pr_info("tdm_mode = 0x%x\n", (u32)priv->tdm_mode);
+	pr_info("tdm_framer_type; = 0x%x\n", (u32)priv->tdm_framer_type);
+	pr_info("rx_buffer; = 0x%x\n", (u32)priv->rx_buffer);
+	pr_info("tx_buffer; = 0x%x\n", (u32)priv->tx_buffer);
+	pr_info("dma_rx_addr; = 0x%x\n", (u32)priv->dma_rx_addr);
+	pr_info("dma_tx_addr; = 0x%x\n", (u32)priv->dma_tx_addr);
+	pr_info("tx_bd; = 0x%x\n", (u32)priv->tx_bd);
+	pr_info("rx_bd; = 0x%x\n", (u32)priv->rx_bd);
+	pr_info("phase_rx = 0x%x\n", (u32)priv->phase_rx);
+	pr_info("phase_tx = 0x%x\n", (u32)priv->phase_tx);
+	pr_info("ucc_pram_offset = 0x%x\n", priv->ucc_pram_offset);
+	pr_info("tx_bd_offset = 0x%x\n", priv->tx_bd_offset);
+	pr_info("rx_bd_offset = 0x%x\n", priv->rx_bd_offset);
+
+}
+
+#endif /* DEBUG */
+
+static void init_si(struct ucc_tdm_private *priv)
+{
+	struct si1 __iomem *si_regs = NULL;
+	u16 __iomem *siram = NULL;
+	u16 siram_entry_valid = 0;
+	u16 siram_entry_closed = 0;
+	u16 ucc_num;
+	u8 csel;
+	u16 sixmr;
+	u16 tdm_port;
+	u32 siram_entry_id;
+	u32 mask;
+	int i;
+
+	si_regs = priv->si_regs;
+	siram = priv->siram;
+	ucc_num = priv->ut_info->uf_info.ucc_num;
+	tdm_port = priv->tdm_port;
+	siram_entry_id = priv->siram_entry_id;
+
+	/* set siram table */
+	if (ucc_num < 4)
+		csel = ucc_num + 9;
+	else
+		csel = ucc_num - 3;
+
+	siram_entry_valid = SIR_CSEL(csel) | SIR_BYTE | SIR_CNT(0);
+	siram_entry_closed = SIR_IDLE | SIR_BYTE | SIR_CNT(0);
+
+	for (i = 0; i < priv->num_of_ts; i++) {
+		mask = 0x01 << i;
+
+		if (priv->tx_ts_mask & mask)
+			out_be16(&siram[siram_entry_id * 32 + i],
+					siram_entry_valid);
+		else
+			out_be16(&siram[siram_entry_id * 32 + i],
+					siram_entry_closed);
+
+		if (priv->rx_ts_mask & mask)
+			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
+					siram_entry_valid);
+		else
+			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
+					siram_entry_closed);
+	}
+
+	setbits16(&siram[(siram_entry_id * 32) + (priv->num_of_ts - 1)],
+			SIR_LAST);
+	setbits16(&siram[(siram_entry_id * 32) + 0x200 + (priv->num_of_ts - 1)],
+			SIR_LAST);
+
+	/* Set SIxMR register */
+	sixmr = SIMR_SAD(siram_entry_id);
+
+	sixmr &= ~SIMR_SDM_MASK;
+
+	if (priv->tdm_mode == TDM_INTERNAL_LOOPBACK)
+		sixmr |= SIMR_SDM_INTERNAL_LOOPBACK;
+	else
+		sixmr |= SIMR_SDM_NORMAL;
+
+	sixmr |= SIMR_RFSD(priv->ut_info->si_info.simr_rfsd) |
+			SIMR_TFSD(priv->ut_info->si_info.simr_tfsd);
+
+	if (priv->ut_info->si_info.simr_crt)
+		sixmr |= SIMR_CRT;
+	if (priv->ut_info->si_info.simr_sl)
+		sixmr |= SIMR_SL;
+	if (priv->ut_info->si_info.simr_ce)
+		sixmr |= SIMR_CE;
+	if (priv->ut_info->si_info.simr_fe)
+		sixmr |= SIMR_FE;
+	if (priv->ut_info->si_info.simr_gm)
+		sixmr |= SIMR_GM;
+
+	switch (tdm_port) {
+	case 0:
+		out_be16(&si_regs->siamr1, sixmr);
+		break;
+	case 1:
+		out_be16(&si_regs->sibmr1, sixmr);
+		break;
+	case 2:
+		out_be16(&si_regs->sicmr1, sixmr);
+		break;
+	case 3:
+		out_be16(&si_regs->sidmr1, sixmr);
+		break;
+	default:
+		printk(KERN_ERR"can not find tdm sixmr reg\n");
+		break;
+	}
+
+#ifdef DEBUG
+	dump_siram(priv);
+#endif
+
+}
+static int utdm_init(struct ucc_tdm_private *priv)
+{
+	struct ucc_tdm_info *ut_info;
+	struct ucc_fast_info *uf_info;
+	u32 cecr_subblock;
+	u32 bd_status;
+	int ret, i;
+	void *bd_buffer;
+	dma_addr_t bd_dma_addr;
+	u32 riptr;
+	u32 tiptr;
+
+	ut_info = priv->ut_info;
+	uf_info = &ut_info->uf_info;
+
+	if (priv->tdm_framer_type == TDM_FRAMER_T1)
+		priv->num_of_ts = 24;
+	if (priv->tdm_framer_type == TDM_FRAMER_E1)
+		priv->num_of_ts = 32;
+
+	uf_info->uccm_mask = (u32) (UCC_TRANS_UCCE_RXB << 16);
+
+	if (ucc_fast_init(uf_info, &priv->uccf)) {
+		printk(KERN_ERR "%s: Failed to init uccf.", __func__);
+		return -ENOMEM;
+}
+
+	priv->uf_regs = priv->uccf->uf_regs;
+	ucc_fast_disable(priv->uccf, COMM_DIR_RX | COMM_DIR_TX);
+
+	/* Initialize SI */
+	init_si(priv);
+
+	/* Write to QE CECR, UCCx channel to Stop Transmission */
+	cecr_subblock = ucc_fast_get_qe_cr_subblock(uf_info->ucc_num);
+	ret = qe_issue_cmd(QE_STOP_TX, cecr_subblock,
+		(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+
+	/* Set UPSMR */
+	out_be32(&priv->uf_regs->upsmr, 0);
+
+	/* Alloc Rx BD */
+	priv->rx_bd_offset = qe_muram_alloc(NUM_OF_BUF * sizeof(struct qe_bd),
+			QE_ALIGNMENT_OF_BD);
+	if (IS_ERR_VALUE(priv->rx_bd_offset)) {
+		printk(KERN_ERR "%s: Cannot allocate MURAM memory for RxBDs\n",
+				__func__);
+		ret = -ENOMEM;
+		goto rxbd_alloc_error;
+	}
+
+	/* Alloc Tx BD */
+	priv->tx_bd_offset = qe_muram_alloc(NUM_OF_BUF * sizeof(struct qe_bd),
+				QE_ALIGNMENT_OF_BD);
+	if (IS_ERR_VALUE(priv->tx_bd_offset)) {
+		printk(KERN_ERR "%s: Cannot allocate MURAM memory for TxBDs\n",
+				__func__);
+		ret = -ENOMEM;
+		goto txbd_alloc_error;
+	}
+
+	priv->tx_bd = qe_muram_addr(priv->tx_bd_offset);
+	priv->rx_bd = qe_muram_addr(priv->rx_bd_offset);
+
+	/* Alloc parameter ram for ucc transparent */
+	priv->ucc_pram_offset = qe_muram_alloc(sizeof(priv->ucc_pram),
+				ALIGNMENT_OF_UCC_TRANS_PRAM);
+
+	if (IS_ERR_VALUE(priv->ucc_pram_offset)) {
+		printk(KERN_ERR "%s: Can not allocate MURAM for hdlc prameter.\n",
+				__func__);
+		return -ENOMEM;
+		goto pram_alloc_error;
+	}
+
+	/* init parameter base */
+	cecr_subblock = ucc_fast_get_qe_cr_subblock(uf_info->ucc_num);
+	ret = qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, cecr_subblock,
+			QE_CR_PROTOCOL_UNSPECIFIED, priv->ucc_pram_offset);
+
+	priv->ucc_pram = (struct ucc_transparent_param __iomem *)
+					qe_muram_addr(priv->ucc_pram_offset);
+
+	/* Zero out parameter ram */
+	memset_io(priv->ucc_pram, 0, sizeof(struct ucc_transparent_param));
+
+	/* Alloc riptr, tiptr */
+	riptr = qe_muram_alloc(32, 32);
+	if (IS_ERR_VALUE(riptr)) {
+		printk(KERN_ERR "%s: Cannot allocate MURAM mem for Receive"
+			" internal temp data pointer\n", __func__);
+		ret = -ENOMEM;
+		goto riptr_alloc_error;
+	}
+
+	tiptr = qe_muram_alloc(32, 32);
+	if (IS_ERR_VALUE(tiptr)) {
+		printk(KERN_ERR "%s: Cannot allocate MURAM mem for transmit"
+			" internal temp data pointer\n", __func__);
+		ret = -ENOMEM;
+		goto tiptr_alloc_error;
+	}
+
+	/* Set RIPTR, TIPTR */
+	out_be16(&priv->ucc_pram->riptr, (u16)riptr);
+	out_be16(&priv->ucc_pram->tiptr, (u16)tiptr);
+
+	/* Set MRBLR */
+	out_be16(&priv->ucc_pram->mrblr, (u16)MAX_RX_BUF_LENGTH);
+
+	/* Set RBASE, TBASE */
+	out_be32(&priv->ucc_pram->rbase, (u32)cpm_muram_dma(priv->rx_bd));
+	out_be32(&priv->ucc_pram->tbase, (u32)cpm_muram_dma(priv->tx_bd));
+
+	/* Set RSTATE, TSTATE */
+	out_be32(&priv->ucc_pram->rstate, 0x30000000);
+	out_be32(&priv->ucc_pram->tstate, 0x30000000);
+
+	/* Set C_MASK, C_PRES for 16bit CRC */
+	out_be32(&priv->ucc_pram->c_mask, 0x0000F0B8);
+	out_be32(&priv->ucc_pram->c_pres, 0x0000FFFF);
+
+	out_be16(&priv->ucc_pram->res0, 0);
+	for (i = 0; i < 4; i++)
+		out_be32(&priv->ucc_pram->res4[i], 0x0);
+
+	/* Get BD buffer */
+	bd_buffer = dma_alloc_coherent(priv->dev,
+		2 * NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+		&bd_dma_addr, GFP_KERNEL);
+
+	if (!bd_buffer) {
+		printk("Could not allocate buffer descriptors\n");
+		return -ENOMEM;
+	}
+
+	memset(bd_buffer, 0, 2 * NUM_OF_BUF * MAX_RX_BUF_LENGTH);
+
+	priv->rx_buffer = bd_buffer;
+	priv->tx_buffer = bd_buffer + NUM_OF_BUF * MAX_RX_BUF_LENGTH;
+
+	priv->dma_rx_addr = bd_dma_addr;
+	priv->dma_tx_addr = bd_dma_addr + NUM_OF_BUF * MAX_RX_BUF_LENGTH;
+
+	for (i = 0; i < NUM_OF_BUF; i++) {
+		if (i < (NUM_OF_BUF - 1))
+			bd_status = R_E | R_I | R_CM;
+		else
+			bd_status = R_E | R_I | R_W | R_CM;
+
+		out_be32((u32 *)(priv->rx_bd + i), bd_status);
+		out_be32(&priv->rx_bd[i].buf, priv->dma_rx_addr
+				+ i * MAX_RX_BUF_LENGTH);
+
+		if (i < (NUM_OF_BUF - 1))
+			bd_status =  T_I;
+		else
+			bd_status =  T_I | T_W;
+
+		out_be32((u32 *)(priv->tx_bd + i), bd_status);
+		out_be32(&priv->tx_bd[i].buf, priv->dma_tx_addr
+				+ i * MAX_RX_BUF_LENGTH);
+	}
+
+	priv->phase_rx = 0;
+	priv->phase_tx = 0;
+
+	return 0;
+
+tiptr_alloc_error:
+	qe_muram_free(riptr);
+riptr_alloc_error:
+	qe_muram_free(priv->ucc_pram_offset);
+pram_alloc_error:
+	qe_muram_free(priv->tx_bd_offset);
+txbd_alloc_error:
+	qe_muram_free(priv->rx_bd_offset);
+rxbd_alloc_error:
+	ucc_fast_free(priv->uccf);
+
+	return ret;
+}
+
+static int ucc_tdm_read(struct tdm_adapter *adap, u8 *tdm_buffer, u32 len)
+{
+
+	struct ucc_tdm_private *priv = tdm_get_adapdata(adap);
+	u8 phase_rx;
+	u32 i;
+	u32 byte_copy;
+	u8 *recv_buf;
+
+	wait_event_interruptible(priv->tdm_queue, priv->tdm_queue_flag != 0);
+	priv->tdm_queue_flag = 0;
+
+	if (priv->phase_rx == 0)
+		phase_rx = NUM_OF_BUF - 1;
+	else
+		phase_rx = priv->phase_rx - 1;
+
+	recv_buf = priv->rx_buffer + phase_rx * MAX_RX_BUF_LENGTH;
+
+	if (len > MAX_RX_BUF_LENGTH)
+		byte_copy = MAX_RX_BUF_LENGTH;
+	else
+		byte_copy = len;
+
+	for (i = 0; i < byte_copy; i++)
+		*(tdm_buffer +  i) = recv_buf[i];
+
+	return byte_copy;
+
+}
+
+
+static int ucc_tdm_write(struct tdm_adapter *adap, u8 *write_buf,
+		 unsigned int len)
+{
+	struct ucc_tdm_private *priv = tdm_get_adapdata(adap);
+	struct qe_bd __iomem *bd;
+	u32 bd_status;
+	u8 *tdm_send_buf;
+	u32 copy_len;
+	int i, j;
+	u32 buf_num;
+
+	buf_num = len / MAX_RX_BUF_LENGTH;
+	if (len % MAX_RX_BUF_LENGTH)
+		buf_num += 1;
+
+	if (buf_num > NUM_OF_BUF)
+		return -EINVAL;
+
+	for (i = 0; i < buf_num; i++) {
+
+		if (priv->phase_tx == NUM_OF_BUF)
+			priv->phase_tx = 0;
+
+		bd = (priv->tx_bd + priv->phase_tx);
+		bd_status = in_be32((u32 __iomem *)bd);
+		tdm_send_buf = priv->tx_buffer +
+				priv->phase_tx * MAX_RX_BUF_LENGTH;
+
+		/* the last buf to copy */
+		if (i == (buf_num - 1))
+			copy_len = len - i * MAX_RX_BUF_LENGTH;
+		else
+			copy_len = MAX_RX_BUF_LENGTH;
+
+		while ((bd_status = in_be32((u32 __iomem *)bd)) & T_R)
+			msleep(30);
+
+		memset(tdm_send_buf, 0xff, MAX_RX_BUF_LENGTH);
+
+		for (j = 0; j < copy_len; j++)
+			tdm_send_buf[j] = *((u8 *)write_buf + j);
+
+		bd_status &= ~(T_L | BD_LEN_MASK);
+		if (i == (buf_num - 1))
+			out_be32((u32 *)(bd),
+				bd_status | T_R | T_L | T_I | copy_len);
+		else
+			out_be32((u32 *)(bd), bd_status | T_R | T_I | copy_len);
+
+		priv->phase_tx++;
+	}
+
+	return 0;
+}
+
+static irqreturn_t ucc_tdm_irq_handler(int irq, void *dev_id)
+{
+	struct ucc_tdm_private *priv = (struct ucc_tdm_private *)dev_id;
+	struct ucc_fast_private *uccf;
+	struct ucc_tdm_info *ut_info;
+	register u32 ucce;
+	register u32 uccm;
+
+	ut_info = priv->ut_info;
+	uccf = priv->uccf;
+
+	ucce = (u32) in_be32(uccf->p_ucce);
+	uccm = (u32) in_be32(uccf->p_uccm);
+
+	if ((ucce >> 16) & UCC_TRANS_UCCE_RXB) {
+		if (priv->phase_rx  == NUM_OF_BUF - 1)
+			priv->phase_rx = 0;
+		else
+			priv->phase_rx++;
+
+		priv->tdm_queue_flag = 1;
+		wake_up_interruptible(&priv->tdm_queue);
+
+	}
+
+	out_be32(uccf->p_ucce, ucce);
+
+	return IRQ_HANDLED;
+
+}
+
+static int utdm_start(struct tdm_adapter *adap)
+{
+	u32 cecr_subblock;
+	struct ucc_tdm_private *priv = tdm_get_adapdata(adap);
+
+	if (priv->tdm_busy != 1) {
+		if (request_irq(priv->ut_info->uf_info.irq, ucc_tdm_irq_handler,
+					0, "tdm", (void *)priv)) {
+			printk(KERN_ERR "%s: request_irq for ucc tdm failed\n",
+							__func__);
+			return -ENODEV;
+		}
+		cecr_subblock =
+		ucc_fast_get_qe_cr_subblock(priv->ut_info->uf_info.ucc_num);
+
+		qe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,
+			(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+
+		ucc_fast_enable(priv->uccf, COMM_DIR_RX | COMM_DIR_TX);
+
+		/* Enable the TDM port */
+		priv->si_regs->siglmr1_h |= (0x1 << priv->tdm_port);
+		priv->phase_rx = 0;
+		priv->phase_tx = 0;
+		priv->tdm_busy = 1;
+		msleep(100);
+	} else
+		printk(KERN_ERR"TDM IS RUNNING!\n");
+
+#ifdef DEBUG
+	dump_priv(priv);
+	dump_ucc(priv);
+	dump_bds(priv);
+#endif
+
+	return 0;
+}
+
+static void utdm_memclean(struct ucc_tdm_private *priv)
+{
+	qe_muram_free(priv->ucc_pram->riptr);
+	qe_muram_free(priv->ucc_pram->tiptr);
+
+	if (priv->rx_bd) {
+		qe_muram_free(priv->rx_bd_offset);
+		priv->rx_bd = NULL;
+		priv->rx_bd_offset = 0;
+	}
+
+	if (priv->tx_bd) {
+		qe_muram_free(priv->tx_bd_offset);
+		priv->tx_bd = NULL;
+		priv->tx_bd_offset = 0;
+	}
+
+	if (priv->ucc_pram) {
+		qe_muram_free(priv->ucc_pram_offset);
+		priv->ucc_pram = NULL;
+		priv->ucc_pram_offset = 0;
+	 }
+
+	if (priv->uf_regs) {
+		iounmap(priv->uf_regs);
+		priv->uf_regs = NULL;
+	}
+
+	if (priv->uccf) {
+		ucc_fast_free(priv->uccf);
+		priv->uccf = NULL;
+	}
+
+	if (priv->rx_buffer) {
+		dma_free_coherent(NULL, 2 * NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+			priv->rx_buffer, priv->dma_rx_addr);
+		priv->rx_buffer = NULL;
+		priv->dma_rx_addr = 0;
+	}
+}
+
+static int utdm_stop(struct tdm_adapter *adap)
+{
+	struct ucc_tdm_private *priv = tdm_get_adapdata(adap);
+	u32 cecr_subblock;
+
+	cecr_subblock = ucc_fast_get_qe_cr_subblock(
+			priv->ut_info->uf_info.ucc_num);
+
+	qe_issue_cmd(QE_GRACEFUL_STOP_TX, cecr_subblock,
+			(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+	qe_issue_cmd(QE_CLOSE_RX_BD, cecr_subblock,
+			(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+
+	priv->si_regs->siglmr1_h &= ~(0x1 << priv->tdm_port);
+	ucc_fast_disable(priv->uccf, COMM_DIR_RX | COMM_DIR_TX);
+
+	free_irq(priv->ut_info->uf_info.irq, priv);
+	priv->tdm_busy = 0;
+
+	return 0;
+}
+
+static const struct tdm_algorithm tdm_algo = {
+	.tdm_read_simple = ucc_tdm_read,
+	.tdm_write_simple = ucc_tdm_write,
+	.tdm_enable = utdm_start,
+	.tdm_disable = utdm_stop,
+	.functionality = NULL,
+};
+
+static struct tdm_adapter ucc_tdm_ops = {
+	.owner = THIS_MODULE,
+	.algo = &tdm_algo,
+};
+
+static enum tdm_mode_t set_tdm_mode(const char *tdm_mode_type)
+{
+	if (strcasecmp(tdm_mode_type, "internal-loopback") == 0)
+		return TDM_INTERNAL_LOOPBACK;
+	else if (strcasecmp(tdm_mode_type, "normal") == 0)
+		return TDM_NORMAL;
+	else
+		return TDM_NORMAL;
+}
+
+
+static enum tdm_framer_t set_tdm_framer(const char *tdm_framer_type)
+{
+	if (strcasecmp(tdm_framer_type, "t1") == 0)
+		return TDM_FRAMER_T1;
+	else if (strcasecmp(tdm_framer_type, "e1") == 0)
+		return TDM_FRAMER_E1;
+	else
+		return TDM_FRAMER_T1;
+}
+
+static int set_si_param(struct ucc_tdm_private *priv)
+{
+	struct si_mode_info *si_info = &priv->ut_info->si_info;
+
+	if (priv->tdm_mode == TDM_INTERNAL_LOOPBACK) {
+		si_info->simr_crt = 1;
+		si_info->simr_rfsd = 0;
+	}
+
+	return 0;
+}
+
+static int __devinit ucc_tdm_probe(struct of_device *ofdev,
+				const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node;
+	struct ucc_tdm_private *utdm_priv = NULL;
+	struct ucc_tdm_info *ut_info;
+	struct resource res;
+	int ucc_num;
+	const unsigned int *prop;
+	const char *sprop;
+	struct device_node *dnp;
+	int ret;
+	static int si_flag;
+
+	prop = of_get_property(np, "cell-index", NULL);
+	if (!prop) {
+		printk(KERN_ERR "%s: Invalid ucc property\n", __func__);
+		return -ENODEV;
+	}
+
+	ucc_num = *prop - 1;
+	if ((ucc_num > 7) && (ucc_num < 0)) {
+		printk(KERN_ERR "%s: Invalid UCC num\n", __func__);
+		return -EINVAL;
+	}
+
+	ut_info = &utdm_info[ucc_num];
+	ut_info->uf_info.ucc_num = ucc_num;
+
+	sprop = of_get_property(np, "rx-clock-name", NULL);
+	if (sprop) {
+		ut_info->uf_info.rx_clock = qe_clock_source(sprop);
+		if ((ut_info->uf_info.rx_clock < QE_CLK_NONE) ||
+			(ut_info->uf_info.rx_clock > QE_CLK24)) {
+			printk(KERN_ERR	"%s: Invalid rx-clock-name property\n",
+					__func__);
+			return -EINVAL;
+		}
+	} else {
+		printk(KERN_ERR
+			"%s: Invalid rx-clock-name property\n", __func__);
+		return -EINVAL;
+	}
+
+	sprop = of_get_property(np, "tx-clock-name", NULL);
+	if (sprop) {
+		ut_info->uf_info.tx_clock = qe_clock_source(sprop);
+		if ((ut_info->uf_info.tx_clock < QE_CLK_NONE) ||
+			(ut_info->uf_info.tx_clock > QE_CLK24)) {
+			printk(KERN_ERR
+			"%s: Invalid tx-clock-name property\n", __func__);
+		return -EINVAL;
+		}
+	} else {
+		printk(KERN_ERR
+			"%s: Invalid tx-clock-name property\n", __func__);
+		return -EINVAL;
+	}
+
+	sprop = of_get_property(np, "rx-sync-clock", NULL);
+	if (sprop) {
+		ut_info->uf_info.tx_sync = qe_clock_source(sprop);
+		if ((ut_info->uf_info.tx_sync < QE_CLK_NONE) ||
+			(ut_info->uf_info.tx_sync > QE_TSYNC_PIN)) {
+			printk(KERN_ERR
+			"%s: Invalid rx-sync-clock property\n", __func__);
+		return -EINVAL;
+		}
+	} else {
+		printk(KERN_ERR
+			"%s: Invalid rx-sync-clock property\n", __func__);
+		return -EINVAL;
+	}
+
+	sprop = of_get_property(np, "tx-sync-clock", NULL);
+	if (sprop) {
+		ut_info->uf_info.tx_sync = qe_clock_source(sprop);
+		if ((ut_info->uf_info.tx_sync < QE_CLK_NONE) ||
+			(ut_info->uf_info.tx_sync > QE_TSYNC_PIN)) {
+			printk(KERN_ERR
+			"%s: Invalid tx-sync-clock property\n", __func__);
+		return -EINVAL;
+		}
+	} else {
+		printk(KERN_ERR
+			"%s: Invalid tx-sync-clock property\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		return -EINVAL;
+
+	ut_info->uf_info.regs = res.start;
+	ut_info->uf_info.irq = irq_of_parse_and_map(np, 0);
+
+	utdm_priv = kzalloc(sizeof(struct ucc_tdm_private), GFP_KERNEL);
+	if (!utdm_priv) {
+		ret = -ENOMEM;
+		printk(KERN_ERR
+			"%s: No mem to alloc tdm private data\n", __func__);
+		goto err_alloc_priv;
+	}
+
+	dev_set_drvdata(&ofdev->dev, utdm_priv);
+	utdm_priv->dev = &ofdev->dev;
+
+	prop = of_get_property(np, "tx-timeslot", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR
+			"%s: Invalid tx-timeslot property\n", __func__);
+		goto err_miss_property;
+	}
+	utdm_priv->tx_ts_mask = *prop;
+
+	prop = of_get_property(np, "rx-timeslot", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR
+			"%s: Invalid rx-timeslot property\n", __func__);
+		goto err_miss_property;
+	}
+	utdm_priv->rx_ts_mask = *prop;
+
+	prop = of_get_property(np, "fsl,tdm-id", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR
+			"%s: No fsl,tdm-id property for this UCC\n", __func__);
+		goto err_miss_property;
+	}
+	utdm_priv->tdm_port = *prop;
+	ut_info->uf_info.tdm_num = utdm_priv->tdm_port ;
+
+	prop = of_get_property(np, "tdm-mode", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR
+			"%s: No tdm-mode property for UCC\n", __func__);
+		goto err_miss_property;
+	}
+	utdm_priv->tdm_mode = set_tdm_mode((const char *)prop);
+
+	prop = of_get_property(np, "tdm-framer-type", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR
+			"%s: No tdm-framer-type property for UCC\n", __func__);
+		goto err_miss_property;
+	}
+	utdm_priv->tdm_framer_type = set_tdm_framer((const char *)prop);
+
+	prop = of_get_property(np, "fsl,siram-entry-id", NULL);
+	if (!prop) {
+		ret = -EINVAL;
+		printk(KERN_ERR"No siram entry id for UCC\n");
+		goto err_miss_property;
+	}
+	utdm_priv->siram_entry_id = *(const u32 *)prop;
+
+	dnp = of_find_node_by_name(NULL, "si");
+	if (!dnp) {
+		ret = -EINVAL;
+		printk(KERN_ERR "%s: No si property\n", __func__);
+		goto err_miss_property;
+	}
+	of_address_to_resource(dnp, 0, &res);
+	utdm_priv->si_regs = ioremap(res.start, res.end - res.start + 1);
+	of_node_put(dnp);
+
+
+	dnp = of_find_node_by_name(NULL, "siram");
+	if (!dnp) {
+		ret = -EINVAL;
+		printk(KERN_ERR "%s: No siramproperty\n", __func__);
+		goto err_miss_si_property;
+	}
+	of_address_to_resource(dnp, 0 , &res);
+	utdm_priv->siram = ioremap(res.start, res.end - res.start + 1);
+	of_node_put(dnp);
+
+	if (si_flag == 0) {
+		memset(utdm_priv->siram, 0,  res.end - res.start + 1);
+		si_flag = 1;
+	}
+
+	utdm_priv->ut_info = ut_info;
+	set_si_param(utdm_priv);
+
+	utdm_priv->adap = kzalloc(sizeof(struct tdm_adapter), GFP_KERNEL);
+	if (!utdm_priv->adap) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "%s: No mem to alloc for adapter\n", __func__);
+		goto err_adap_alloc;
+	}
+	sprintf(ucc_tdm_ops.name, "%s%d", "tdm_ucc_", ucc_num + 1);
+	memcpy(utdm_priv->adap, &ucc_tdm_ops, sizeof(struct tdm_adapter));
+
+	tdm_set_adapdata(utdm_priv->adap, utdm_priv);
+	utdm_priv->adap->parent = &ofdev->dev;
+
+	init_waitqueue_head(&utdm_priv->tdm_queue);
+	utdm_priv->tdm_queue_flag = 0;
+
+	ret = utdm_init(utdm_priv);
+	if (ret) {
+		printk(KERN_ERR "%s: Failed to init utdm\n", __func__);
+		goto err_utdm_init;
+	}
+
+	ret = tdm_add_adapter(utdm_priv->adap);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: Failed to add adapter\n", __func__);
+		goto err_utdm_init;
+	}
+
+	spin_lock_init(&utdm_priv->tdmlock);
+
+	#ifdef DEBUG
+		dump_priv(utdm_priv);
+		dump_ucc(utdm_priv);
+		dump_bds(utdm_priv);
+		mem_disp((u8 *)utdm_priv->si_regs, 0x20);
+	#endif
+
+	return 0;
+
+err_utdm_init:
+	kfree(utdm_priv->adap);
+err_adap_alloc:
+	iounmap(utdm_priv->siram);
+err_miss_si_property:
+	iounmap(utdm_priv->si_regs);
+err_miss_property:
+	kfree(utdm_priv);
+err_alloc_priv:
+	return ret;
+
+}
+
+static int __devexit ucc_tdm_remove(struct of_device *ofdev)
+{
+	struct ucc_tdm_private *priv = dev_get_drvdata(&ofdev->dev);
+
+	utdm_stop(priv->adap);
+	utdm_memclean(priv);
+
+	if (priv->si_regs) {
+		iounmap(priv->si_regs);
+		priv->si_regs = NULL;
+	}
+
+	if (priv->siram) {
+		iounmap(priv->siram);
+		priv->siram = NULL;
+	}
+	kfree(priv->adap);
+	kfree(priv);
+
+	pr_info("%s UCC based tdm module removed\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id fsl_ucc_tdm_of_match[] = {
+	{
+	.compatible = "fsl,ucc-tdm",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, fsl_ucc_tdm_of_match);
+
+static struct of_platform_driver ucc_tdm_driver = {
+	.match_table    = fsl_ucc_tdm_of_match,
+	.probe          = ucc_tdm_probe,
+	.remove         = __devexit_p(ucc_tdm_remove),
+	.driver         = {
+		.owner  = THIS_MODULE,
+		.name   = DRV_NAME,
+	},
+};
+
+static int __init ucc_tdm_init(void)
+{
+	int i, ret;
+
+	pr_info(DRV_NAME ": " DRV_DESC ":Init\n");
+
+	for (i = 0; i < MAX_TDM_NUM; i++)
+		memcpy(&(utdm_info[i]), &utdm_primary_info,
+			sizeof(utdm_primary_info));
+
+	ret = of_register_platform_driver(&ucc_tdm_driver);
+	if (ret)
+		pr_err(DRV_NAME
+			"ucc_tdm_driver failed (%i)\n", ret);
+	return ret;
+}
+
+static void __exit ucc_tdm_exit(void)
+{
+	pr_info(DRV_NAME ": " DRV_DESC ":Exit\n");
+	of_unregister_platform_driver(&ucc_tdm_driver);
+}
+
+module_init(ucc_tdm_init);
+module_exit(ucc_tdm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
+MODULE_DESCRIPTION("Driver For Freescale QE UCC TDM controller");
+MODULE_VERSION("1.0");
diff --git a/drivers/tdm/device/fsl_ucc_tdm.h b/drivers/tdm/device/fsl_ucc_tdm.h
new file mode 100644
index 0000000..a6aab77
--- /dev/null
+++ b/drivers/tdm/device/fsl_ucc_tdm.h
@@ -0,0 +1,165 @@
+/*
+ * Freescale QUICC Engine TDM Device Driver
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Haiying Wang <Haiying.Wang@freescale.com>
+ *		    Kai Jiang	   <Kai.Jiang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * This driver adds support for TDM devices via Freescale's QUICC Engine.
+ */
+
+
+#ifndef CONFIG_UCC_TDM_H
+#define CONFIG_UCC_TDM_H
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include <asm/ucc.h>
+#include <asm/ucc_fast.h>
+
+/* SI RAM entries */
+#define SIR_LAST 0x0001
+#define SIR_BYTE 0x0002
+#define SIR_CNT(x) ((x) << 2)
+#define SIR_CSEL(x) ((x) << 5)
+#define SIR_SGS	0x0200
+#define SIR_SWTR 0x4000
+#define SIR_MCC 0x8000
+#define SIR_IDLE  0
+
+/* SIxMR fields */
+#define SIMR_SAD(x) ((x) << 12)
+#define SIMR_SDM_NORMAL 0x0000
+#define SIMR_SDM_INTERNAL_LOOPBACK	0x0800
+#define SIMR_SDM_MASK	0x0c00
+#define SIMR_CRT 0x0040
+#define SIMR_SL	0x0020
+#define SIMR_CE	0x0010
+#define SIMR_FE 0x0008
+#define SIMR_GM 0x0004
+#define SIMR_TFSD(n) (n)
+#define SIMR_RFSD(n) ((n) << 8)
+
+enum tdm_ts_t{
+	TDM_TX_TS,
+	TDM_RX_TS
+} ;
+
+
+enum tdm_framer_t{
+	TDM_FRAMER_T1,
+	TDM_FRAMER_E1
+} ;
+
+enum tdm_mode_t{
+	TDM_INTERNAL_LOOPBACK,
+	TDM_NORMAL
+} ;
+
+struct ucc_transparent_param {
+	__be16 riptr;
+	__be16 tiptr;
+	__be16 res0;
+	__be16 mrblr;
+	__be32 rstate;
+	__be32 rbase;
+	__be16 rbdstat;
+	__be16 rbdlen;
+	__be32 rdptr;
+	__be32 tstate;
+	__be32 tbase;
+	__be16 tbdstat;
+	__be16 tbdlen;
+	__be32 tdptr;
+	__be32 rbptr;
+	__be32 tbptr;
+	__be32 rcrc;
+	__be32 res1;
+	__be32 tcrc;
+	__be32 res2;
+	__be32 res3;
+	__be32 c_mask;
+	__be32 c_pres;
+	__be16 disfc;
+	__be16 crcec;
+	__be32 res4[4];
+	__be16 ts_tmp;
+	__be16 tmp_mb;
+} __attribute__ ((packed));
+
+struct si_mode_info {
+	u8	simr_rfsd;
+	u8	simr_tfsd;
+	u8	simr_crt;
+	u8	simr_sl;
+	u8	simr_ce;
+	u8	simr_fe;
+	u8	simr_gm;
+};
+
+struct ucc_tdm_info {
+	struct ucc_fast_info uf_info;
+	struct si_mode_info si_info;
+};
+
+struct ucc_tdm_private {
+	struct ucc_tdm_info *ut_info;
+	struct ucc_fast_private *uccf;
+	struct device *dev;
+	struct ucc_fast __iomem *uf_regs;       /* UCC Fast registers */
+	struct si1 __iomem *si_regs;
+	struct ucc_transparent_param __iomem *ucc_pram;
+	u16 tdm_port;           /* port for this tdm:TDMA,TDMB,TDMC,TDMD */
+	u32 siram_entry_id;
+	u16 __iomem *siram;
+	enum tdm_mode_t	tdm_mode;
+	enum tdm_framer_t	tdm_framer_type;
+	u8 tdm_busy;
+	u8 num_of_ts;		/* the number of timeslots in this tdm frame */
+	u32 tx_ts_mask;	/* tx time slot mask */
+	u32 rx_ts_mask;	/*rx time slot mask */
+	u8 *rx_buffer;     /* buffer used for Rx by the tdm */
+	u8 *tx_buffer;     /* buffer used for Tx by the tdm */
+	dma_addr_t dma_rx_addr; /* dma mapped buffer for TDM Rx */
+	dma_addr_t dma_tx_addr; /* dma mapped buffer for TDM Tx */
+	struct qe_bd *tx_bd;
+	struct qe_bd *rx_bd;
+	u8 phase_rx;
+	u8 phase_tx;
+	u32 ucc_pram_offset;
+	u32 tx_bd_offset;
+	u32 rx_bd_offset;
+	spinlock_t tdmlock;
+	wait_queue_head_t tdm_queue;
+	int tdm_queue_flag;
+	struct tdm_adapter *adap;
+};
+
+#define NUM_OF_BUF	4
+#define MAX_RX_BUF_LENGTH	(72*0x20)
+#define ALIGNMENT_OF_UCC_TRANS_PRAM  64
+#define SI_BANK_SIZE	128
+#define MAX_TDM_NUM	8
+#define BD_LEN_MASK	0xffff
+
+#endif
diff --git a/drivers/tdm/tdm-core.c b/drivers/tdm/tdm-core.c
index 02de0f6..adfd6b6 100644
--- a/drivers/tdm/tdm-core.c
+++ b/drivers/tdm/tdm-core.c
@@ -1,6 +1,6 @@
 /* driver/tdm/tdm-core.c
  *
- * Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc, All rights reserved.
  *
  * TDM core is the interface between TDM ports and devices.
  *
@@ -379,6 +379,43 @@ module_exit(tdm_exit);
 #define TDM_CORE_DEBUG
 */
 
+int tdm_read_direct(struct tdm_adapter *adap, u8 *buf, u32 len)
+{
+	int res;
+
+	if (adap->algo->tdm_read_simple)
+		res = adap->algo->tdm_read_simple(adap, buf, len);
+	else {
+		pr_err("TDM level read not supported\n");
+		return -EOPNOTSUPP;
+	}
+	/* If everything went ok (i.e. frame received), return #bytes
+	transmitted, else error code. */
+
+	return res;
+
+
+}
+EXPORT_SYMBOL(tdm_read_direct);
+
+int tdm_write_direct(struct tdm_adapter *adap, u8 *buf, u32 len)
+{
+	int res;
+
+	if (adap->algo->tdm_write_simple)
+		res = adap->algo->tdm_write_simple(adap, buf, len);
+	else {
+		pr_err("TDM level write not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	return res;
+}
+EXPORT_SYMBOL(tdm_write_direct);
+
+
+
+
 /* the functional interface to the tdm device. */
 /*
  * tdm_master_send - issue a TDM write
diff --git a/include/linux/tdm.h b/include/linux/tdm.h
index 45ea782..2099815 100644
--- a/include/linux/tdm.h
+++ b/include/linux/tdm.h
@@ -1,6 +1,6 @@
 /* include/linux/tdm.h
  *
- * Copyright (C) 2010 Freescale Semiconductor, Inc, All rights reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc, All rights reserved.
  *
  * tdm.h - definitions for the tdm-device framework interface
  *
@@ -73,6 +73,11 @@ static inline int ALIGN_SIZE(u32 size, u32 alignment)
 #if defined(CONFIG_TDM) || defined(CONFIG_TDM_MODULE)
 extern int tdm_master_enable(struct tdm_driver *);
 extern int tdm_master_disable(struct tdm_driver *);
+int tdm_master_send(struct tdm_adapter *adap, void **buf, int count);
+int tdm_master_recv(struct tdm_adapter *adap, void **buf);
+int tdm_read_direct(struct tdm_adapter *adap, u8 *buf, u32 len);
+int tdm_write_direct(struct tdm_adapter *adap, u8 *buf, u32 len);
+
 #endif /* TDM */
 
 /**
@@ -197,6 +202,8 @@ struct tdm_algorithm {
 	u32 (*tdm_write)(struct tdm_adapter *, void * , unsigned int len);
 	int (*tdm_enable)(struct tdm_adapter *);
 	int (*tdm_disable)(struct tdm_adapter *);
+	int (*tdm_read_simple)(struct tdm_adapter *, u8 *, u32 len);
+	int (*tdm_write_simple)(struct tdm_adapter *, u8 *, u32 len);
 	/* To determine what the adapter supports */
 	u32 (*functionality) (struct tdm_adapter *);
 };
-- 
1.7.0.4

