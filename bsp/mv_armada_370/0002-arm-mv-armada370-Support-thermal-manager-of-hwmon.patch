From 3fb46cbc166b4a45e9e90b09f17f3a530559d5f4 Mon Sep 17 00:00:00 2001
From: Aaron Ma <pengyu.ma@windriver.com>
Date: Thu, 2 Aug 2012 15:25:07 +0800
Subject: [PATCH 2/2] arm/mv-armada370: Support thermal manager of hwmon

Ported from Marvell vendor drop: Armada370_LSP_1.0.2_NQ_p12
This driver implements the alarm of temperature and supports the irq
of thermal sensor.
The low and high threshold values can be set in sysfs, the alarm will
be showed in sysfs too.

Signed-off-by: Aaron Ma <pengyu.ma@windriver.com>
---
 arch/arm/mach-armada370/hwmon.c             |  116 ++++++++++++++++++++-------
 arch/arm/mach-armada370/include/mach/irqs.h |    2 +
 2 files changed, 88 insertions(+), 30 deletions(-)

diff --git a/arch/arm/mach-armada370/hwmon.c b/arch/arm/mach-armada370/hwmon.c
index 3bacc10..88cb6a0 100644
--- a/arch/arm/mach-armada370/hwmon.c
+++ b/arch/arm/mach-armada370/hwmon.c
@@ -29,37 +29,48 @@
 #include <linux/platform_device.h>
 #include <linux/cpu.h>
 #include <asm/io.h>
-//#include <linux/delay.h>
 #include <linux/slab.h>
-//#include "pmu/mvPmuRegs.h"
+#include <linux/interrupt.h>
 
 /* Termal Sensor Registers */
 #define TSEN_STATUS_REG				0x18300
-#define	TSEN_STATUS_TEMP_OUT_OFFSET		19
-#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+#define TSEN_STATUS_TEMP_OUT_OFFSET		19
+#define TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
 
 #define TSEN_CONF_REG				0x18304
-#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
-#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
-#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+#define TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
 
-#define ARMADAXP_OVERHEAT_TEMP	105000		/* milidegree Celsius */
+#define ARMADAXP_OVERHEAT_TEMP	105		/* milidegree Celsius */
 #define ARMADAXP_OVERHEAT_DELAY	0x700
-#define ARMADAXP_OVERCOOL_TEMP	10000		/* milidegree Celsius */
-#define	ARMADAXP_OVERCOOL_DELAY	0x700
+#define ARMADAXP_OVERCOOL_TEMP	10		/* milidegree Celsius */
+#define ARMADAXP_OVERCOOL_DELAY	0x700
 #define ARMADAXP_OVERHEAT_MIN	0
 #define ARMADAXP_OVERHEAT_MAX	110000
 #define ARMADAXP_OVERCOOL_MIN	0
 #define ARMADAXP_OVERCOOL_MAX	110000
+#define PMU_THERMAL_MNGR_REG	0x1830C
+#define PMU_INT_CAUSE_REG	0x1C120
+#define PMU_INT_MASK_REG	0x1C124
+#define PMU_INT_OVRHEAT_MASK	0x1
+#define PMU_INT_COOLING_MASK	0x2
+
+#define PMU_TM_COOL_THRSH_OFFS          10
+#define PMU_TM_COOL_THRSH_MASK          (0x1FF << PMU_TM_COOL_THRSH_OFFS)
+#define PMU_TM_OVRHEAT_THRSH_OFFS       19
+#define PMU_TM_OVRHEAT_THRSH_MASK       (0x1FF << PMU_TM_OVRHEAT_THRSH_OFFS)
+
+#define PMU_TM_DISABLE_OFFS             0
+#define PMU_TM_DISABLE_MASK             (0x1 << PMU_TM_DISABLE_OFFS)
+
+#define PMU_TM_COOLING_DLY_REG	0x18310
+#define PMU_TM_OVRHEAT_DLY_REG  0x18314
 
 /* Junction Temperature */
 #define ARMADAXP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
 #define ARMADAXP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
-#if 0
-/* Dove */
-((2281638 - (10 * x)) / 7298)    /* in millCelsius */
- ((2281638 - (7298 * x)) / 10)
-#endif
 
 #define LABEL "T-junction"
 static struct device *hwmon_dev;
@@ -76,9 +87,12 @@ typedef enum {
 
 static void axptemp_set_thresholds(unsigned int max, unsigned int min)
 {
-#if 0
 	u32 temp, reg;
 
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_DISABLE_MASK;
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
 	/* Set the overheat threashold & delay */
 	temp = ARMADAXP_TSEN_TEMP2RAW(max);
 	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
@@ -86,13 +100,12 @@ static void axptemp_set_thresholds(unsigned int max, unsigned int min)
 	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
 	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
 
-	/* Set the overcool threshole & delay */
+	/* Set the cooling threshole & delay */
 	temp = ARMADAXP_TSEN_TEMP2RAW(min);
 	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_COOL_THRSH_MASK;
 	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
 	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
-#endif
 }
 
 static int axptemp_init_sensor(void)
@@ -100,35 +113,46 @@ static int axptemp_init_sensor(void)
 	u32 reg;
 
 	/* init the TSEN sensor once */
+	/* Enable On-The-Fly Calibration mode */
 	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
 	reg |= TSEN_CONF_OTF_CALIB_MASK;
 	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
 
+	/* Set the Reference Count value */
 	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
 	reg &= ~(TSEN_CONF_REF_CAL_MASK);
 	reg |= (0xf1 << 11);
 	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
 
+	/* Do not start calibration sequence */
 	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
-	reg |= TSEN_CONF_SOFT_RESET_MASK;
+	reg &= ~(TSEN_CONF_START_CALIB_MASK);
 	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
 
-	//udelay(1000);
+	/* Initiate Soft Reset
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_SOFT_RESET_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	udelay(1000);
+	*/
 
+	/* Exit from Soft Reset
 	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
 	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
 	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	udelay(10000);
+	*/
 
-	//udelay(10000);
-
-#if 0
 	/* Set thresholds */
 	axptemp_set_thresholds(temp_max, temp_min);
 
 	/* Set delays */
 	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_BASE | PMU_TM_OVRHEAT_DLY_REG));
 	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_BASE | PMU_TM_COOLING_DLY_REG));
-#endif
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel(0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
 
 	return 0;
 }
@@ -139,8 +163,6 @@ static int axptemp_read_temp(void)
 
 	reg = readl(INTER_REGS_BASE | TSEN_STATUS_REG);
 	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
-//	value = ((3153000 - (10000 * reg)) / 13825);
-
 	return ARMADAXP_TSEN_RAW2TEMP(reg);
 }
 
@@ -157,7 +179,6 @@ static ssize_t show_name(struct device *dev, struct device_attribute
 static ssize_t show_alarm(struct device *dev, struct device_attribute
 			  *devattr, char *buf)
 {
-#if 0
 	int alarm = 0;
 	u32 reg;
 
@@ -172,8 +193,8 @@ static ssize_t show_alarm(struct device *dev, struct device_attribute
 		alarm = 2;
 		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
 	}
-#endif
-	return sprintf(buf, "%d\n", 0);
+
+	return sprintf(buf, "%d\n", alarm);
 }
 
 static ssize_t show_info(struct device *dev,
@@ -237,11 +258,39 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 	else
 		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
 
+	/* Clear & unmask cooling/overheat interrupts */
+	writel (0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
 	printk(KERN_INFO "set_temp got string: %d\n", temp);
 
 	return count;
 }
 
+static irqreturn_t axptemp_irq_handler(int irq, void *data)
+{
+	u32 val, mask;
+
+	mask = readl(INTER_REGS_BASE | PMU_INT_MASK_REG);
+	val = (readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG) & mask);
+
+	/* Mask cooling/overheat interrupt */
+	writel((mask & ~val), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
+			((val & PMU_INT_OVRHEAT_MASK) ? "overheat" : "cooling"));
+
+	if (val & PMU_INT_OVRHEAT_MASK)
+		val &= ~PMU_INT_OVRHEAT_MASK;
+	else if (val & PMU_INT_COOLING_MASK)
+		val &= ~PMU_INT_COOLING_MASK;
+
+	/* Clear cooling/overheat interrupt */
+	writel(val, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+
+	return IRQ_HANDLED;
+}
+
 /* TODO - Add read/write support in order to support setting max/min */
 static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
 			  SHOW_TYPE);
@@ -273,7 +322,7 @@ static const struct attribute_group axptemp_group = {
 
 static int __devinit axptemp_probe(struct platform_device *pdev)
 {
-	int err;
+	int err, irq;
 
 	err = axptemp_init_sensor();
 	if (err)
@@ -290,6 +339,13 @@ static int __devinit axptemp_probe(struct platform_device *pdev)
 		goto exit;
 	}
 
+	/* Register cooling/overheat interrupt */
+	irq = IRQ_AURORA_PMU;
+	err = request_irq(irq, axptemp_irq_handler, IRQF_DISABLED | IRQF_NOBALANCING,
+				  "axp-temp", NULL);
+	if (err)
+		printk(KERN_INFO "unable to request IRQ%d for axp-temp\n", irq);
+
 	printk(KERN_INFO "Armada XP hwmon thermal sensor initialized.\n");
 
 	return 0;
diff --git a/arch/arm/mach-armada370/include/mach/irqs.h b/arch/arm/mach-armada370/include/mach/irqs.h
index 40a116a..38416fa 100644
--- a/arch/arm/mach-armada370/include/mach/irqs.h
+++ b/arch/arm/mach-armada370/include/mach/irqs.h
@@ -90,6 +90,8 @@
 #define IRQ_AURORA_OUTB_DB1	97
 #define IRQ_AURORA_OUTB_DB2	98
 
+#define IRQ_AURORA_PMU		107
+
 #define IRQ_AURORA_DRAM		108
 #define IRQ_AURORA_NET_WKUP0	109
 #define IRQ_AURORA_NET_WKUP1	110
-- 
1.7.3.4

