From 4a5909d1099cb6b8f77a975c5a7dcc246e2b3b4e Mon Sep 17 00:00:00 2001
From: Karandeep Chahal <karandeepchahal@gmail.com>
Date: Tue, 7 Feb 2012 11:49:26 +0800
Subject: [PATCH 200/479] sb_edac: fix incorrect notifier registration and unregistration

Refered to: https://lkml.org/lkml/2011/12/23/248

While testing Sandy Bridge EDAC module I discovered a problem in the
way sb_edac was registering itself for machine check notifications.
The symptoms of the problem include:
1. Injecting a machine check exception can cause the system to hang
for 10-15 seconds.
2. Removing and re-inserting the kernel module can cause panic.

The system hangs for 10-15 seconds because the sb_edac notifier gets
called by the kernel (notifier_call_chain) 0xffffffff times
((u32)(-1)). The problem occurs because sb_edac calls
atomic_notifier_chain_register twice with the same static
notifier_block structure. The function atomic_notifier_chain_register
gets called once for each memory controller (MC) with the same
structure. The patch, then, fixes this problem by making sure that
sb_edac registers for machine check notifications only once.

Also copying Mauro Carvalho Chehab (maintainer of sb_edac) for the
review of the patch.

Signed-off-by: Karandeep Chahal <karandeepchahal@gmail.com>

[Move unregistration from sbridge_exit() to sbridge_remove(), since we
should unregister notifier callback first, then remove this device,
otherwise callback function has possibility to use already released
resource.]

Signed-off-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/edac/sb_edac.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c
index 965bc0c..8baeadf 100644
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@ -1661,7 +1661,6 @@ static void sbridge_unregister_mci(struct sbridge_dev *sbridge_dev)
 	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
 		__func__, mci, &sbridge_dev->pdev[0]->dev);
 
-	mce_unregister_decode_chain(&sbridge_mce_dec);
 
 	/* Remove MC sysfs nodes */
 	edac_mc_del_mc(mci->dev);
@@ -1730,7 +1729,6 @@ static int sbridge_register_mci(struct sbridge_dev *sbridge_dev)
 		goto fail0;
 	}
 
-	mce_register_decode_chain(&sbridge_mce_dec);
 	return 0;
 
 fail0:
@@ -1820,6 +1818,8 @@ static void __devexit sbridge_remove(struct pci_dev *pdev)
 		return;
 	}
 
+	mce_unregister_decode_chain(&sbridge_mce_dec);
+
 	list_for_each_entry(sbridge_dev, &sbridge_edac_list, list)
 		sbridge_unregister_mci(sbridge_dev);
 
@@ -1859,9 +1859,10 @@ static int __init sbridge_init(void)
 
 	pci_rc = pci_register_driver(&sbridge_driver);
 
-	if (pci_rc >= 0)
+	if (pci_rc >= 0) {
+		mce_register_decode_chain(&sbridge_mce_dec);
 		return 0;
-
+	}
 	sbridge_printk(KERN_ERR, "Failed to register device with error %d.\n",
 		      pci_rc);
 
-- 
1.7.0

