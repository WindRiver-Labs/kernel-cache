From b5bf569da19bb70616a6af1e5ed04a3671bbfe36 Mon Sep 17 00:00:00 2001
From: Edmund Nadolski <edmund.nadolski@intel.com>
Date: Tue, 8 Feb 2011 09:28:42 -0700
Subject: [PATCH 003/479] isci: remove SCI_INVALID_HANDLE

upstream: a7e536c7d6f1796e8727f5c90d33765ae7cfd8d8

Replace SCI_INVALID_HANDLE with NULL

Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 .../isci/core/sci_base_memory_descriptor_list.c    |    6 ++--
 .../isci/core/sci_base_memory_descriptor_list.h    |    3 +-
 drivers/scsi/isci/core/sci_types.h                 |    2 -
 drivers/scsi/isci/core/scic_phy.h                  |    2 +-
 drivers/scsi/isci/core/scic_sds_controller.c       |   24 ++++++++++----------
 drivers/scsi/isci/core/scic_sds_phy.c              |    8 +++---
 drivers/scsi/isci/core/scic_sds_port.c             |   20 ++++++++--------
 .../isci/core/scic_sds_port_configuration_agent.c  |   24 ++++++++++----------
 drivers/scsi/isci/core/scic_sds_remote_device.c    |    2 +-
 drivers/scsi/isci/core/scic_user_callback.h        |    6 ++--
 drivers/scsi/isci/events.c                         |    7 ++---
 11 files changed, 50 insertions(+), 54 deletions(-)

diff --git a/drivers/scsi/isci/core/sci_base_memory_descriptor_list.c b/drivers/scsi/isci/core/sci_base_memory_descriptor_list.c
index 86ae6a8..2d785b5 100644
--- a/drivers/scsi/isci/core/sci_base_memory_descriptor_list.c
+++ b/drivers/scsi/isci/core/sci_base_memory_descriptor_list.c
@@ -76,7 +76,7 @@ void sci_mdl_first_entry(
 	/*
 	 * If this MDL is managing another MDL, then recursively rewind that MDL
 	 * object as well. */
-	if (base_mdl->next_mdl != SCI_INVALID_HANDLE)
+	if (base_mdl->next_mdl != NULL)
 		sci_mdl_first_entry(base_mdl->next_mdl);
 }
 
@@ -93,7 +93,7 @@ void sci_mdl_next_entry(
 		/*
 		 * This MDL has exhausted it's set of entries.  If this MDL is managing
 		 * another MDL, then start iterating through that MDL. */
-		if (base_mdl->next_mdl != SCI_INVALID_HANDLE)
+		if (base_mdl->next_mdl != NULL)
 			sci_mdl_next_entry(base_mdl->next_mdl);
 	}
 }
@@ -108,7 +108,7 @@ struct sci_physical_memory_descriptor *sci_mdl_get_current_entry(
 		/*
 		 * This MDL has exhausted it's set of entries.  If this MDL is managing
 		 * another MDL, then return it's current entry. */
-		if (base_mdl->next_mdl != SCI_INVALID_HANDLE)
+		if (base_mdl->next_mdl != NULL)
 			return sci_mdl_get_current_entry(base_mdl->next_mdl);
 	}
 
diff --git a/drivers/scsi/isci/core/sci_base_memory_descriptor_list.h b/drivers/scsi/isci/core/sci_base_memory_descriptor_list.h
index 257d6e3..614e0a9 100644
--- a/drivers/scsi/isci/core/sci_base_memory_descriptor_list.h
+++ b/drivers/scsi/isci/core/sci_base_memory_descriptor_list.h
@@ -94,8 +94,7 @@ struct sci_base_memory_descriptor_list {
 
 	/**
 	 * This field simply allows a user to chain memory descriptor lists
-	 * together if desired.  This field will be initialized to
-	 * SCI_INVALID_HANDLE.
+	 * together if desired.  This field will be initialized to NULL.
 	 */
 	struct sci_base_memory_descriptor_list *next_mdl;
 
diff --git a/drivers/scsi/isci/core/sci_types.h b/drivers/scsi/isci/core/sci_types.h
index 72a56bf..e15dc0c 100644
--- a/drivers/scsi/isci/core/sci_types.h
+++ b/drivers/scsi/isci/core/sci_types.h
@@ -61,8 +61,6 @@
 #define sci_cb_make_physical_address(physical_addr, addr_upper, addr_lower) \
 	((physical_addr) = (addr_lower) | ((u64)addr_upper) << 32)
 
-#define SCI_INVALID_HANDLE 0x0
-
 typedef enum {
 	SCI_IO_REQUEST_DATA_IN = 0,	/* Read operation */
 	SCI_IO_REQUEST_DATA_OUT,	/* Write operation */
diff --git a/drivers/scsi/isci/core/scic_phy.h b/drivers/scsi/isci/core/scic_phy.h
index 25a6140..fec273b 100644
--- a/drivers/scsi/isci/core/scic_phy.h
+++ b/drivers/scsi/isci/core/scic_phy.h
@@ -82,7 +82,7 @@ struct scic_sds_port;
 struct scic_phy_properties {
 	/**
 	 * This field specifies the port that currently contains the
-	 * supplied phy.  This field may be set to SCI_INVALID_HANDLE
+	 * supplied phy.  This field may be set to NULL
 	 * if the phy is not currently contained in a port.
 	 */
 	struct scic_sds_port *owning_port;
diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index 35f7796..6a32d91 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -890,7 +890,7 @@ enum sci_status scic_sds_controller_start_next_phy(
 			for (index = 0; index < SCI_MAX_PHYS; index++) {
 				the_phy = &this_controller->phy_table[index];
 
-				if (scic_sds_phy_get_port(the_phy) != SCI_INVALID_HANDLE) {
+				if (scic_sds_phy_get_port(the_phy) != NULL) {
 					/**
 					 * The controller start operation is complete if and only
 					 * if:
@@ -940,7 +940,7 @@ enum sci_status scic_sds_controller_start_next_phy(
 				scic_sds_controller_get_port_configuration_mode(this_controller)
 				== SCIC_PORT_MANUAL_CONFIGURATION_MODE
 				) {
-				if (scic_sds_phy_get_port(the_phy) == SCI_INVALID_HANDLE) {
+				if (scic_sds_phy_get_port(the_phy) == NULL) {
 					this_controller->next_phy_to_start++;
 
 					/*
@@ -1025,7 +1025,7 @@ enum sci_status scic_sds_controller_stop_devices(
 	status = SCI_SUCCESS;
 
 	for (index = 0; index < this_controller->remote_node_entries; index++) {
-		if (this_controller->device_table[index] != SCI_INVALID_HANDLE) {
+		if (this_controller->device_table[index] != NULL) {
 			/* / @todo What timeout value do we want to provide to this request? */
 			device_status = scic_remote_device_stop(this_controller->device_table[index], 0);
 
@@ -1197,7 +1197,7 @@ static void scic_sds_controller_task_completion(
 
 	/* Make sure that we really want to process this IO request */
 	if (
-		(io_request != SCI_INVALID_HANDLE)
+		(io_request != NULL)
 		&& (io_request->io_tag != SCI_CONTROLLER_INVALID_IO_TAG)
 		&& (
 			scic_sds_io_tag_get_sequence(io_request->io_tag)
@@ -1395,7 +1395,7 @@ static void scic_sds_controller_event_completion(
 		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
 		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
 			io_request = this_controller->io_request_table[index];
-			if (io_request != SCI_INVALID_HANDLE)
+			if (io_request != NULL)
 				scic_sds_io_request_event_handler(io_request, completion_entry);
 			else
 				dev_warn(scic_to_dev(this_controller),
@@ -1410,7 +1410,7 @@ static void scic_sds_controller_event_completion(
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
 			device = this_controller->device_table[index];
-			if (device != SCI_INVALID_HANDLE)
+			if (device != NULL)
 				scic_sds_remote_device_event_handler(device, completion_entry);
 			else
 				dev_warn(scic_to_dev(this_controller),
@@ -2174,7 +2174,7 @@ struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
 	task_index = scic_sds_io_tag_get_index(io_tag);
 
 	if (task_index  < this_controller->task_context_entries) {
-		if (this_controller->io_request_table[task_index] != SCI_INVALID_HANDLE) {
+		if (this_controller->io_request_table[task_index] != NULL) {
 			task_sequence = scic_sds_io_tag_get_sequence(io_tag);
 
 			if (task_sequence == this_controller->io_request_sequence[task_index]) {
@@ -2183,7 +2183,7 @@ struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
 		}
 	}
 
-	return SCI_INVALID_HANDLE;
+	return NULL;
 }
 
 /**
@@ -2240,7 +2240,7 @@ void scic_sds_controller_free_remote_node_context(
 	u32 remote_node_count = scic_sds_remote_device_node_count(the_device);
 
 	if (this_controller->device_table[node_id] == the_device) {
-		this_controller->device_table[node_id] = SCI_INVALID_HANDLE;
+		this_controller->device_table[node_id] = NULL;
 
 		scic_sds_remote_node_table_release_remote_node_index(
 			&this_controller->available_remote_nodes, remote_node_count, node_id
@@ -2262,7 +2262,7 @@ union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffe
 	) {
 	if (
 		(node_id < this_controller->remote_node_entries)
-		&& (this_controller->device_table[node_id] != SCI_INVALID_HANDLE)
+		&& (this_controller->device_table[node_id] != NULL)
 		) {
 		return &this_controller->remote_node_context_table[node_id];
 	}
@@ -2449,7 +2449,7 @@ u32 scic_controller_get_suggested_start_timeout(
 	struct scic_sds_controller *sc)
 {
 	/* Validate the user supplied parameters. */
-	if (sc == SCI_INVALID_HANDLE)
+	if (sc == NULL)
 		return 0;
 
 	/*
@@ -3659,7 +3659,7 @@ static enum sci_status scic_sds_controller_ready_state_complete_io_handler(
 
 	if (status == SCI_SUCCESS) {
 		index = scic_sds_io_tag_get_index(the_request->io_tag);
-		this_controller->io_request_table[index] = SCI_INVALID_HANDLE;
+		this_controller->io_request_table[index] = NULL;
 	}
 
 	return status;
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 7d012b5..01da46a 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -414,15 +414,15 @@ void scic_sds_phy_construct(
  *    containing port.
  *
  * This method returns a handle to a port that contains the supplied phy.
- * SCI_INVALID_HANDLE This value is returned if the phy is not part of a real
- * port (i.e. it's contained in the dummy port). !SCI_INVALID_HANDLE All other
+ * NULL This value is returned if the phy is not part of a real
+ * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
 struct scic_sds_port *scic_sds_phy_get_port(
 	struct scic_sds_phy *this_phy)
 {
 	if (scic_sds_port_get_index(this_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
-		return SCI_INVALID_HANDLE;
+		return NULL;
 
 	return this_phy->owning_port;
 }
@@ -2373,7 +2373,7 @@ static enum sci_status scic_sds_phy_ready_state_event_handler(
 
 	case SCU_EVENT_BROADCAST_CHANGE:
 		/* Broadcast change received. Notify the port. */
-		if (scic_sds_phy_get_port(this_phy) != SCI_INVALID_HANDLE)
+		if (scic_sds_phy_get_port(this_phy) != NULL)
 			scic_sds_port_broadcast_change_received(this_phy->owning_port, this_phy);
 		else
 			this_phy->bcn_received_while_port_unassigned = true;
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index 1af3850..9749e3a 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -277,8 +277,8 @@ enum sci_status scic_sds_port_set_phy(
 	 * that means that the phy is not part of a port and that the port does
 	 * not already have a phy assinged to the phy index. */
 	if (
-		(port->phy_table[phy->phy_index] == SCI_INVALID_HANDLE)
-		&& (scic_sds_phy_get_port(phy) == SCI_INVALID_HANDLE)
+		(port->phy_table[phy->phy_index] == NULL)
+		&& (scic_sds_phy_get_port(phy) == NULL)
 		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
 		) {
 		/*
@@ -318,7 +318,7 @@ enum sci_status scic_sds_port_clear_phy(
 			&scic_sds_port_get_controller(port)->port_table[SCI_MAX_PORTS]
 			);
 
-		port->phy_table[phy->phy_index] = SCI_INVALID_HANDLE;
+		port->phy_table[phy->phy_index] = NULL;
 
 		return SCI_SUCCESS;
 	}
@@ -529,7 +529,7 @@ void scic_sds_port_construct(
 	this_port->started_request_count = 0;
 	this_port->assigned_device_count = 0;
 
-	this_port->timer_handle = SCI_INVALID_HANDLE;
+	this_port->timer_handle = NULL;
 
 	this_port->transport_layer_registers = NULL;
 	this_port->port_task_scheduler_registers = NULL;
@@ -669,7 +669,7 @@ enum sci_status scic_port_get_properties(
 	struct scic_sds_port *port,
 	struct scic_port_properties *prop)
 {
-	if ((port == SCI_INVALID_HANDLE) ||
+	if ((port == NULL) ||
 	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
 		return SCI_FAILURE_INVALID_PORT;
 
@@ -1267,29 +1267,29 @@ static enum sci_status scic_sds_port_ready_operational_substate_reset_handler(
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
 	u32 phy_index;
 	struct scic_sds_port *this_port = (struct scic_sds_port *)port;
-	struct scic_sds_phy *selected_phy = SCI_INVALID_HANDLE;
+	struct scic_sds_phy *selected_phy = NULL;
 
 
 	/* Select a phy on which we can send the hard reset request. */
 	for (
 		phy_index = 0;
 		(phy_index < SCI_MAX_PHYS)
-		&& (selected_phy == SCI_INVALID_HANDLE);
+		&& (selected_phy == NULL);
 		phy_index++
 		) {
 		selected_phy = this_port->phy_table[phy_index];
 
 		if (
-			(selected_phy != SCI_INVALID_HANDLE)
+			(selected_phy != NULL)
 			&& !scic_sds_port_active_phy(this_port, selected_phy)
 			) {
 			/* We found a phy but it is not ready select different phy */
-			selected_phy = SCI_INVALID_HANDLE;
+			selected_phy = NULL;
 		}
 	}
 
 	/* If we have a phy then go ahead and start the reset procedure */
-	if (selected_phy != SCI_INVALID_HANDLE) {
+	if (selected_phy != NULL) {
 		status = scic_sds_phy_reset(selected_phy);
 
 		if (status == SCI_SUCCESS) {
diff --git a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
index 37d4469..dd2cdd4 100644
--- a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
+++ b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
@@ -118,9 +118,9 @@ static s32 sci_sas_address_compare(
  *
  * This routine will find a matching port for the phy.  This means that the
  * port and phy both have the same broadcast sas address and same received sas
- * address. The port address or the SCI_INVALID_HANDLE if there is no matching
+ * address. The port address or the NULL if there is no matching
  * port. port address if the port can be found to match the phy.
- * SCI_INVALID_HANDLE if there is no matching port for the phy.
+ * NULL if there is no matching port for the phy.
  */
 static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 	struct scic_sds_controller *controller,
@@ -156,7 +156,7 @@ static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 		}
 	}
 
-	return SCI_INVALID_HANDLE;
+	return NULL;
 }
 
 /**
@@ -390,7 +390,7 @@ static void scic_sds_mpc_agent_timeout_handler(
  * @controller: This is the controller object that receives the link up
  *    notification.
  * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an SCI_INVALID_HANDLE.
+ *    associated port this is an NULL.
  * @phy: This is the phy object which has gone ready.
  *
  * This method handles the manual port configuration link up notifications.
@@ -409,7 +409,7 @@ static void scic_sds_mpc_agent_link_up(
 	 * If the port has an invalid handle then the phy was not assigned to
 	 * a port.  This is because the phy was not given the same SAS Address
 	 * as the other PHYs in the port. */
-	if (port != SCI_INVALID_HANDLE) {
+	if (port != NULL) {
 		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
 
 		scic_sds_port_link_up(port, phy);
@@ -425,7 +425,7 @@ static void scic_sds_mpc_agent_link_up(
  * @controller: This is the controller object that receives the link down
  *    notification.
  * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an SCI_INVALID_HANDLE.  The port is an invalid
+ *    associated port this is an NULL.  The port is an invalid
  *    handle only if the phy was never port of this port.  This happens when
  *    the phy is not broadcasting the same SAS address as the other phys in the
  *    assigned port.
@@ -443,7 +443,7 @@ static void scic_sds_mpc_agent_link_down(
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
 {
-	if (port != SCI_INVALID_HANDLE) {
+	if (port != NULL) {
 		/*
 		 * If we can form a new port from the remainder of the phys then we want
 		 * to start the timer to allow the SCI User to cleanup old devices and
@@ -573,7 +573,7 @@ static void scic_sds_apc_agent_configure_ports(
 
 	port = scic_sds_port_configuration_agent_find_port(controller, phy);
 
-	if (port != SCI_INVALID_HANDLE) {
+	if (port != NULL) {
 		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
@@ -680,7 +680,7 @@ static void scic_sds_apc_agent_configure_ports(
  * @controller: This is the controller object that receives the link up
  *    notification.
  * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an SCI_INVALID_HANDLE.
+ *    associated port this is an NULL.
  * @phy: This is the phy object which has gone link up.
  *
  * This method handles the automatic port configuration for link up
@@ -693,7 +693,7 @@ static void scic_sds_apc_agent_link_up(
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
 {
-	BUG_ON(port != SCI_INVALID_HANDLE);
+	BUG_ON(port != NULL);
 
 	port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
 
@@ -705,7 +705,7 @@ static void scic_sds_apc_agent_link_up(
  * @controller: This is the controller object that receives the link down
  *    notification.
  * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an SCI_INVALID_HANDLE.
+ *    associated port this is an NULL.
  * @phy: This is the phy object which has gone link down.
  *
  * This method handles the automatic port configuration link down
@@ -721,7 +721,7 @@ static void scic_sds_apc_agent_link_down(
 {
 	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
 
-	if (port != SCI_INVALID_HANDLE) {
+	if (port != NULL) {
 		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
 			enum sci_status status;
 
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.c b/drivers/scsi/isci/core/scic_sds_remote_device.c
index 21f03bc..cb26d0c 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_remote_device.c
@@ -1170,7 +1170,7 @@ enum sci_status scic_sds_remote_device_general_frame_handler(
 		io_request = scic_sds_controller_get_io_request_from_tag(
 			scic_sds_remote_device_get_controller(this_device), frame_header->tag);
 
-		if ((io_request == SCI_INVALID_HANDLE)
+		if ((io_request == NULL)
 		    || (io_request->target_device != this_device)) {
 			/*
 			 * We could not map this tag to a valid IO request
diff --git a/drivers/scsi/isci/core/scic_user_callback.h b/drivers/scsi/isci/core/scic_user_callback.h
index 6eca5a9..4aa020e 100644
--- a/drivers/scsi/isci/core/scic_user_callback.h
+++ b/drivers/scsi/isci/core/scic_user_callback.h
@@ -600,7 +600,7 @@ void scic_cb_port_invalid_link_up(
  * @port: This parameter specifies the SCI port object for which the callback
  *    is being invoked.  For instances where the phy on which the primitive was
  *    received is not part of a port, this parameter will be
- *    SCI_INVALID_HANDLE_T.
+ *    NULL.
  * @phy: This parameter specifies the phy on which the primitive was received.
  *
  */
@@ -620,7 +620,7 @@ void scic_cb_port_bc_change_primitive_received(
  *    phy.
  * @port: This parameter specifies the port object for which the user callback
  *    is being invoked.  There may be conditions where this parameter can be
- *    SCI_INVALID_HANDLE
+ *    NULL
  * @phy: This parameter specifies the phy object for which the user callback is
  *    being invoked.
  *
@@ -638,7 +638,7 @@ void scic_cb_port_link_up(
  *    phy.
  * @port: This parameter specifies the port object for which the user callback
  *    is being invoked.  There may be conditions where this parameter can be
- *    SCI_INVALID_HANDLE
+ *    NULL
  * @phy: This parameter specifies the phy object for which the user callback is
  *    being invoked.
  *
diff --git a/drivers/scsi/isci/events.c b/drivers/scsi/isci/events.c
index 75f9cd5..6911ea5 100644
--- a/drivers/scsi/isci/events.c
+++ b/drivers/scsi/isci/events.c
@@ -399,8 +399,7 @@ void scic_cb_port_invalid_link_up(
  *    port.
  * @port: This parameter specifies the SCI port object for which the callback
  *    is being invoked.  For instances where the phy on which the primitive was
- *    received is not part of a port, this parameter will be
- *    SCI_INVALID_HANDLE_T.
+ *    received is not part of a port, this parameter will be NULL.
  * @phy: This parameter specifies the phy on which the primitive was received.
  *
  */
@@ -430,7 +429,7 @@ void scic_cb_port_bc_change_primitive_received(
  *    phy.
  * @port: This parameter specifies the port object for which the user callback
  *    is being invoked.  There may be conditions where this parameter can be
- *    SCI_INVALID_HANDLE
+ *    NULL
  * @phy: This parameter specifies the phy object for which the user callback is
  *    being invoked.
  *
@@ -460,7 +459,7 @@ void scic_cb_port_link_up(
  *    phy.
  * @port: This parameter specifies the port object for which the user callback
  *    is being invoked.  There may be conditions where this parameter can be
- *    SCI_INVALID_HANDLE
+ *    NULL
  * @phy: This parameter specifies the phy object for which the user callback is
  *    being invoked.
  *
-- 
1.7.0

