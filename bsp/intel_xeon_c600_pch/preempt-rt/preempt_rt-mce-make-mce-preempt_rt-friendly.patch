From bd75f8d81787bb8751f426b2babf4d2a4bcf533d Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 27 Mar 2012 13:34:40 +0800
Subject: [PATCH 460/478] preempt_rt mce: make mce preempt_rt friendly

Add mce preempt_rt support to avoiding tons of call trace when
run mce test.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/include/asm/mce.h              |    1 +
 arch/x86/kernel/cpu/mcheck/mce-apei.c   |    2 +-
 arch/x86/kernel/cpu/mcheck/mce-inject.c |    4 ++-
 arch/x86/kernel/cpu/mcheck/mce.c        |   37 +++++++++++++++----------------
 arch/x86/kernel/cpu/mcheck/mce_intel.c  |    2 +-
 5 files changed, 24 insertions(+), 22 deletions(-)

diff --git a/arch/x86/include/asm/mce.h b/arch/x86/include/asm/mce.h
index ec22389..f660c63 100644
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@ -201,6 +201,7 @@ void machine_check_poll(enum mcp_flags flags, mce_banks_t *b);
 
 int mce_notify_irq(void);
 void mce_notify_process(void);
+void mce_schedule_tasklet(void);
 
 DECLARE_PER_CPU(struct mce, injectm);
 
diff --git a/arch/x86/kernel/cpu/mcheck/mce-apei.c b/arch/x86/kernel/cpu/mcheck/mce-apei.c
index 83930de..57c901d 100644
--- a/arch/x86/kernel/cpu/mcheck/mce-apei.c
+++ b/arch/x86/kernel/cpu/mcheck/mce-apei.c
@@ -50,7 +50,7 @@ void apei_mce_report_mem_error(int corrected, struct cper_sec_mem_err *mem_err)
 	m.status = MCI_STATUS_VAL | MCI_STATUS_EN | MCI_STATUS_ADDRV | 0x9f;
 	m.addr = mem_err->physical_addr;
 	mce_log(&m);
-	mce_notify_irq();
+	mce_schedule_tasklet();
 }
 EXPORT_SYMBOL_GPL(apei_mce_report_mem_error);
 
diff --git a/arch/x86/kernel/cpu/mcheck/mce-inject.c b/arch/x86/kernel/cpu/mcheck/mce-inject.c
index 0c89a2a..b48c67e 100644
--- a/arch/x86/kernel/cpu/mcheck/mce-inject.c
+++ b/arch/x86/kernel/cpu/mcheck/mce-inject.c
@@ -71,7 +71,9 @@ static void raise_exception(struct mce *m, struct pt_regs *pregs)
 	}
 	/* in mcheck exeception handler, irq will be disabled */
 	local_irq_save(flags);
+	preempt_disable_notrace();
 	do_machine_check(pregs, 0);
+	preempt_enable_no_resched_notrace();
 	local_irq_restore(flags);
 	m->finished = 0;
 }
@@ -140,7 +142,7 @@ static int raise_local(void)
 	} else if (m->status) {
 		printk(KERN_INFO "Starting machine check poll CPU %d\n", cpu);
 		raise_poll(m);
-		mce_notify_irq();
+		mce_schedule_tasklet();
 		printk(KERN_INFO "Machine check poll done on CPU %d\n", cpu);
 	} else
 		m->finished = 0;
diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c
index f64c0a7..10ab119 100644
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@ -104,7 +104,7 @@ DEFINE_PER_CPU(mce_banks_t, mce_poll_banks) = {
 	[0 ... BITS_TO_LONGS(MAX_NR_BANKS)-1] = ~0UL
 };
 
-static DEFINE_PER_CPU(struct work_struct, mce_work);
+static DEFINE_PER_CPU(struct tasklet_struct, mce_tasklet);
 
 /*
  * CPU/chipset specific EDAC code can register a notifier call here to print
@@ -462,7 +462,7 @@ static DEFINE_PER_CPU(struct mce_ring, mce_ring);
 /* Runs with CPU affinity in workqueue */
 static int mce_ring_empty(void)
 {
-	struct mce_ring *r = &__get_cpu_var(mce_ring);
+	struct mce_ring *r = &__raw_get_cpu_var(mce_ring);
 
 	return r->start == r->end;
 }
@@ -474,7 +474,7 @@ static int mce_ring_get(unsigned long *pfn)
 
 	*pfn = 0;
 	get_cpu();
-	r = &__get_cpu_var(mce_ring);
+	r = &__raw_get_cpu_var(mce_ring);
 	if (r->start == r->end)
 		goto out;
 	*pfn = r->ring[r->start];
@@ -488,7 +488,7 @@ out:
 /* Always runs in MCE context with preempt off */
 static int mce_ring_add(unsigned long pfn)
 {
-	struct mce_ring *r = &__get_cpu_var(mce_ring);
+	struct mce_ring *r = &__raw_get_cpu_var(mce_ring);
 	unsigned next;
 
 	next = (r->end + 1) % MCE_RING_SIZE;
@@ -507,14 +507,12 @@ int mce_available(struct cpuinfo_x86 *c)
 	return cpu_has(c, X86_FEATURE_MCE) && cpu_has(c, X86_FEATURE_MCA);
 }
 
-static void mce_schedule_work(void)
+void mce_schedule_tasklet(void)
 {
-	if (!mce_ring_empty()) {
-		struct work_struct *work = &__get_cpu_var(mce_work);
-		if (!work_pending(work))
-			schedule_work(work);
-	}
+	struct tasklet_struct *tasklet = &__get_cpu_var(mce_tasklet);
+	tasklet_schedule(tasklet);
 }
+EXPORT_SYMBOL_GPL(mce_schedule_tasklet);
 
 #ifdef CONFIG_X86_LOCAL_APIC
 /*
@@ -527,8 +525,7 @@ asmlinkage void smp_mce_self_interrupt(struct pt_regs *regs)
 	ack_APIC_irq();
 	exit_idle();
 	irq_enter();
-	mce_notify_irq();
-	mce_schedule_work();
+	mce_schedule_tasklet();
 	irq_exit();
 }
 #endif
@@ -536,14 +533,13 @@ asmlinkage void smp_mce_self_interrupt(struct pt_regs *regs)
 static void mce_report_event(struct pt_regs *regs)
 {
 	if (regs->flags & (X86_VM_MASK|X86_EFLAGS_IF)) {
-		mce_notify_irq();
 		/*
 		 * Triggering the work queue here is just an insurance
 		 * policy in case the syscall exit notify handler
 		 * doesn't run soon enough or ends up running on the
 		 * wrong CPU (can happen when audit sleeps)
 		 */
-		mce_schedule_work();
+		mce_schedule_tasklet();
 		return;
 	}
 
@@ -1223,12 +1219,15 @@ void mce_notify_process(void)
  * from the list of faulting pages that do_machine_check()
  * placed into the "ring").
  */
-static void mce_process_work(struct work_struct *dummy)
+static void mce_process_tasklet(unsigned long dummy)
 {
-	unsigned long pfn;
+ 	unsigned long pfn;
+ 	mce_notify_irq();
 
-	while (mce_ring_get(&pfn))
-		memory_failure(pfn, MCE_VECTOR, 0);
+	if (!mce_ring_empty()) {
+		while (mce_ring_get(&pfn))
+			memory_failure(pfn, MCE_VECTOR, 0);
+	}
 }
 
 #ifdef CONFIG_X86_MCE_INTEL
@@ -1579,7 +1578,7 @@ void __cpuinit mcheck_cpu_init(struct cpuinfo_x86 *c)
 	__mcheck_cpu_init_generic();
 	__mcheck_cpu_init_vendor(c);
 	__mcheck_cpu_init_timer();
-	INIT_WORK(&__get_cpu_var(mce_work), mce_process_work);
+	tasklet_init(&__get_cpu_var(mce_tasklet), mce_process_tasklet, 0);
 
 }
 
diff --git a/arch/x86/kernel/cpu/mcheck/mce_intel.c b/arch/x86/kernel/cpu/mcheck/mce_intel.c
index d0d79a7..89b2901 100644
--- a/arch/x86/kernel/cpu/mcheck/mce_intel.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_intel.c
@@ -62,7 +62,7 @@ static int cmci_supported(int *banks)
 static void intel_threshold_interrupt(void)
 {
 	machine_check_poll(MCP_TIMESTAMP, &__get_cpu_var(mce_banks_owned));
-	mce_notify_irq();
+	mce_schedule_tasklet();
 }
 
 static void print_update(char *type, int *hdr, int num)
-- 
1.7.0

