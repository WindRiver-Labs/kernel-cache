From 1e26fa17244e40736678fa170d70fa560ad8c629 Mon Sep 17 00:00:00 2001
From: Huang Ying <ying.huang@intel.com>
Date: Thu, 8 Dec 2011 11:25:40 +0800
Subject: [PATCH 339/478] ACPI, Add 64bit read/write support to atomicio on i386

commit 04c25997c97e57d95d1f5a7a6e5fff2411dbd48b upstream

There is no 64bit read/write support in ACPI atomicio because
readq/writeq is used to implement 64bit read/write, but readq/writeq
is not available on i386.  This patch implement 64bit read/write
support in atomicio via two readl/writel.

Signed-off-by: Huang Ying <ying.huang@intel.com>
[context adjustment]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/acpi/atomicio.c |   32 ++++++++++++++++++++++++++++++--
 1 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/drivers/acpi/atomicio.c b/drivers/acpi/atomicio.c
index 542e539..1f58ed0 100644
--- a/drivers/acpi/atomicio.c
+++ b/drivers/acpi/atomicio.c
@@ -260,6 +260,21 @@ int acpi_post_unmap_gar(struct acpi_generic_address *reg)
 }
 EXPORT_SYMBOL_GPL(acpi_post_unmap_gar);
 
+#ifdef readq
+static inline u64 read64(const volatile void __iomem *addr)
+{
+	return readq(addr);
+}
+#else
+static inline u64 read64(const volatile void __iomem *addr)
+{
+	u64 l, h;
+	l = readl(addr);
+	h = readl(addr+4);
+	return l | (h << 32);
+}
+#endif
+
 /*
  * Can be used in atomic (including NMI) or process context. RCU read
  * lock can only be released after the IO memory area accessing.
@@ -281,7 +296,7 @@ static int acpi_atomic_read_mem(u64 paddr, u64 *val, u32 width)
 		*val = readl(addr);
 		break;
 	case 64:
-		*val = readq(addr);
+		*val = read64(addr);
 		break;
 	default:
 		return -EINVAL;
@@ -291,6 +306,19 @@ static int acpi_atomic_read_mem(u64 paddr, u64 *val, u32 width)
 	return 0;
 }
 
+#ifdef writeq
+static inline void write64(u64 val, volatile void __iomem *addr)
+{
+	writeq(val, addr);
+}
+#else
+static inline void write64(u64 val, volatile void __iomem *addr)
+{
+	writel(val, addr);
+	writel(val>>32, addr+4);
+}
+#endif
+
 static int acpi_atomic_write_mem(u64 paddr, u64 val, u32 width)
 {
 	void __iomem *addr;
@@ -308,7 +336,7 @@ static int acpi_atomic_write_mem(u64 paddr, u64 val, u32 width)
 		writel(val, addr);
 		break;
 	case 64:
-		writeq(val, addr);
+		write64(val, addr);
 		break;
 	default:
 		return -EINVAL;
-- 
1.7.0

