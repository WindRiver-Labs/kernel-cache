From 7aa15bc5788bfd6a285e9f32b0376c73e343156f Mon Sep 17 00:00:00 2001
From: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date: Thu, 15 Apr 2010 13:19:48 +0900
Subject: [PATCH 212/478] PCI: aerdrv: remove is_downstream

commit 4f7ccf6a6085eefd2517b8c7090608c64b01ab67 upstream

The pcie->port of port service device points the port associated
the service with.  The find_aer_service iterates over children of
given port udev.

So it is clear that the pcie->port of port service of given port
udev must always point the udev.

Therefore we can know the type of udev without checking its children.

Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
---
 drivers/pci/pcie/aer/aerdrv_core.c |   33 ++++++++++++---------------------
 1 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c
index 4b01290..81754eb 100644
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -375,30 +375,20 @@ static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,
 
 struct find_aer_service_data {
 	struct pcie_port_service_driver *aer_driver;
-	int is_downstream;
 };
 
 static int find_aer_service_iter(struct device *device, void *data)
 {
-	struct device_driver *driver;
 	struct pcie_port_service_driver *service_driver;
 	struct find_aer_service_data *result;
 
 	result = (struct find_aer_service_data *) data;
 
-	if (device->bus == &pcie_port_bus_type) {
-		struct pcie_device *pcie = to_pcie_device(device);
-
-		if (pcie->port->pcie_type == PCI_EXP_TYPE_DOWNSTREAM)
-			result->is_downstream = 1;
-
-		driver = device->driver;
-		if (driver) {
-			service_driver = to_service_driver(driver);
-			if (service_driver->service == PCIE_PORT_SERVICE_AER) {
-				result->aer_driver = service_driver;
-				return 1;
-			}
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		service_driver = to_service_driver(device->driver);
+		if (service_driver->service == PCIE_PORT_SERVICE_AER) {
+			result->aer_driver = service_driver;
+			return 1;
 		}
 	}
 
@@ -424,7 +414,6 @@ static pci_ers_result_t reset_link(struct pcie_device *aerdev,
 	else
 		udev = dev->bus->self;
 
-	data.is_downstream = 0;
 	data.aer_driver = NULL;
 	find_aer_service(udev, &data);
 
@@ -433,22 +422,24 @@ static pci_ers_result_t reset_link(struct pcie_device *aerdev,
 	 * If it hasn't the aer driver, use the root port's
 	 */
 	if (!data.aer_driver || !data.aer_driver->reset_link) {
-		if (data.is_downstream &&
+		if (udev->pcie_type == PCI_EXP_TYPE_DOWNSTREAM &&
 			aerdev->device.driver &&
 			to_service_driver(aerdev->device.driver)->reset_link) {
 			data.aer_driver =
 				to_service_driver(aerdev->device.driver);
 		} else {
-			dev_printk(KERN_DEBUG, &dev->dev, "no link-reset "
-				   "support\n");
+			dev_printk(KERN_DEBUG, &dev->dev,
+				"no link-reset support at upstream device %s\n",
+				pci_name(udev));
 			return PCI_ERS_RESULT_DISCONNECT;
 		}
 	}
 
 	status = data.aer_driver->reset_link(udev);
 	if (status != PCI_ERS_RESULT_RECOVERED) {
-		dev_printk(KERN_DEBUG, &dev->dev, "link reset at upstream "
-			   "device %s failed\n", pci_name(udev));
+		dev_printk(KERN_DEBUG, &dev->dev,
+			"link reset at upstream device %s failed\n",
+			pci_name(udev));
 		return PCI_ERS_RESULT_DISCONNECT;
 	}
 
-- 
1.7.0

