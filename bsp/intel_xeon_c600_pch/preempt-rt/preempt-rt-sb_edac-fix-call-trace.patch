From 28f5e61bc130ccc5708d0ae84ee3679174dbc27f Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Sun, 25 Mar 2012 18:17:12 +0800
Subject: [PATCH 461/478] preempt-rt sb_edac: fix call trace

call trace of sb_edac has chance to appear in preempt-rt kernel:
BUG: sleeping function called from invalid context at kernel/rtmutex.c:707
pcnt: 2 0 in_atomic(): 1, irqs_disabled(): 1, pid: 6465, name: mce-inject
Pid: 6465, comm: mce-inject Tainted: G   M       2.6.34.10-rt-WR4.3.0.0_preempt_
rt #1
Call Trace:
 [<ffffffff81037f45>] __might_sleep+0xe5/0x110
 [<ffffffff815d1874>] rt_spin_lock+0x34/0x80
 [<ffffffff8111245e>] _slab_irq_disable+0x4e/0x70
 [<ffffffff81115e5e>] __kmalloc+0x7e/0x350
 [<ffffffff81307404>] ? vsnprintf+0x74/0x590
 [<ffffffff813098a7>] ? kvasprintf+0x57/0x90
 [<ffffffff813098a7>] kvasprintf+0x57/0x90
 [<ffffffff81309918>] kasprintf+0x38/0x40
 [<ffffffffa000ac87>] sbridge_check_error+0x2c7/0x3b0 [sb_edac]
 [<ffffffffa000af2d>] sbridge_mce_check_error+0x1bd/0x1e0 [sb_edac]
 [<ffffffff81073097>] notifier_call_chain+0x47/0x90
 [<ffffffff81073865>] __atomic_notifier_call_chain+0x45/0x70
 [<ffffffff810738a1>] atomic_notifier_call_chain+0x11/0x20
 [<ffffffff810175c5>] mce_log+0x25/0x170
 [<ffffffff81018044>] do_machine_check+0x394/0x9b0
 [<ffffffff81019955>] raise_exception+0x45/0x90
 [<ffffffff81019bdb>] raise_local+0xdb/0xe0
 [<ffffffff81019e73>] mce_write+0x293/0x2d0
 [<ffffffff812ab2c1>] ? security_file_permission+0x11/0x20
 [<ffffffff81015c9a>] mce_chrdev_write+0x1a/0x20
 [<ffffffff811265a8>] vfs_write+0xb8/0x180
 [<ffffffff811267f7>] sys_write+0x57/0x110
 [<ffffffff810025ab>] system_call_done+0x0/0x5

The root cause the kmalloc is finally called in atomic context, to fix it,
use stack variable insead.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/edac/sb_edac.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c
index 8baeadf..db50574 100644
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@ -1399,7 +1399,8 @@ static void sbridge_mce_output_error(struct mem_ctl_info *mci,
 {
 	struct mem_ctl_info *new_mci;
 	struct sbridge_pvt *pvt = mci->pvt_info;
-	char *type, *optype, *msg, *recoverable_msg;
+	char *type, *optype, *recoverable_msg;
+	char msg[512];
 	bool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);
 	bool overflow = GET_BITFIELD(m->status, 62, 62);
 	bool uncorrected_error = GET_BITFIELD(m->status, 61, 61);
@@ -1488,7 +1489,7 @@ static void sbridge_mce_output_error(struct mem_ctl_info *mci,
 	 * Probably, we can just discard it, as the channel information
 	 * comes from the get_memory_error_data() address decoding
 	 */
-	msg = kasprintf(GFP_ATOMIC,
+	scnprintf(msg, 512,
 			"%d %s error(s): %s on %s area %s%s: cpu=%d Err=%04x:%04x (ch=%d), "
 			"addr = 0x%08llx => socket=%d, Channel=%ld(mask=%ld), rank=%d\n",
 			core_err_cnt,
@@ -1514,7 +1515,6 @@ static void sbridge_mce_output_error(struct mem_ctl_info *mci,
 	else
 		edac_mc_handle_fbd_ce(mci, csrow, 0, msg);
 
-	kfree(msg);
 }
 
 /*
-- 
1.7.0

