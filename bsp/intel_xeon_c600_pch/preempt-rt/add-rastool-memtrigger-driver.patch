From a13f0a4fc8b83277c99deb99fa7236b0a745245c Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 13 Feb 2012 15:09:31 +0800
Subject: [PATCH 414/478] add rastool memtrigger driver

Intel application rastool use memtrigger device to trigger memory
error event, so add in this gpl driver in kernel

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/char/Kconfig      |    7 ++
 drivers/char/Makefile     |    1 +
 drivers/char/memtrigger.c |  205 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/char/memtrigger.h |   42 +++++++++
 4 files changed, 255 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/memtrigger.c
 create mode 100644 drivers/char/memtrigger.h

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 7dfc24c..8cb2242 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -427,6 +427,13 @@ config SGI_MBCS
 
 source "drivers/serial/Kconfig"
 
+config RASTOOL_MEMTRIGGER
+	tristate "rastool memtrigger support"
+	default n
+	---help---
+	  Intel application rastool use memtrigger device to trigger memory
+	  error event. Say N if you know nothing about rastool
+
 config UNIX98_PTYS
 	bool "Unix98 PTY support" if EMBEDDED
 	default y
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 571b891..61a5613 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -9,6 +9,7 @@ FONTMAPFILE = cp437.uni
 
 obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o tty_buffer.o tty_port.o
 
+obj-$(CONFIG_RASTOOL_MEMTRIGGER) += memtrigger.o
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
 obj-y				+= misc.o
diff --git a/drivers/char/memtrigger.c b/drivers/char/memtrigger.c
new file mode 100644
index 0000000..d320bb1
--- /dev/null
+++ b/drivers/char/memtrigger.c
@@ -0,0 +1,205 @@
+/*******************************************************************************
+
+  Memtrigger Kernel Module
+  Copyright(c) Intel(R) Corporation 2011
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+	Description  
+	Memtrigger kernel module. Provides mechanism to force a read/write/flush
+    of a physical memory address.  This can be used to trigger the detection of change and/or
+	the consumption of data the at the physical memory location. 
+*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/page_types.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "memtrigger.h"
+
+
+int init_module(void);
+void cleanup_module(void);
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+int device_ioctl(struct inode *, struct file *, unsigned int, u64);
+
+#define SUCCESS 0
+#define DEVICE_NAME "memtrigger"
+
+MODULE_LICENSE("GPL");
+
+
+static int Major;
+
+/*
+* Valid operations,  Open, Release, and IOCTLS,  Read/Write to the 
+* Character device is unnecessary and disabled.
+*/
+static struct file_operations fops = {
+	.open = device_open,
+	.release = device_release,
+    .ioctl = device_ioctl
+};
+
+
+/*
+* Initialize the Kernel Module
+*/
+int init_module(void) {
+
+   Major = register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops);
+
+   if (Major < 0) {
+	printk(KERN_ALERT "Registering char device failed with %d\n", Major);
+	return Major;
+   }
+   printk(KERN_INFO "memtrigger initialized %d \n", Major);
+   return SUCCESS;
+}
+/*
+* Cleanup the module.
+*/
+void cleanup_module(void) {
+   unregister_chrdev(MAJOR_NUM, DEVICE_NAME);
+}
+
+/*
+*  Open the module
+*/
+static int device_open (struct inode *inode, struct file *file) {
+   printk(KERN_INFO "memtrigger device opened\n");
+   return SUCCESS;
+}
+
+/* 
+*  Close the module
+*/
+static int device_release(struct inode *inode, struct file *file) {
+   printk(KERN_INFO "memtrigger device closed\n");
+   return SUCCESS;
+}
+
+/*
+* FLUSH IOCTL,  Performs a flush at the specificed address.
+*/
+void flush(u64 addr) {
+  void* vaddr;
+  
+  vaddr = __va(addr);
+  if (vaddr != NULL) {
+     clflush(vaddr);
+  } else {
+    printk(KERN_INFO "memtrigger read failed, unable to get virtual address\n");
+  }
+}
+
+/*
+* READ IOCTL,  Performs a read at the specified address.
+*/
+void read(u64 addr) {
+    void *vaddr;
+    
+    vaddr = __va(addr);
+    if (vaddr != NULL) {
+       readq(vaddr);  
+    } else {
+       printk(KERN_INFO "memtrigger flush failed, unable to get virtual address\n");
+    }
+}
+
+/*
+* READ_FLUSH IOCTL,  Reads at the specificed address, and flushes the cacheline.
+*/
+void readflush(u64 addr) {
+   void* vaddr;
+   
+   vaddr = __va(addr);
+  
+   if (vaddr != NULL) {
+      readq(vaddr);
+      clflush(vaddr);
+   } else {
+      printk(KERN_INFO "memtrigger read_flush failed, unable to get virtual address\n");
+   }	
+}
+
+/*
+*  READ_WRITE IOCTL,  Reads and writes back to the spcecificed address, without flushing
+*  the cache.
+*/
+void readwrite(u64 addr) {
+   void* vaddr;
+   
+   vaddr = __va(addr);
+   if (vaddr != NULL) {
+     // Perform the read/write in a single atomic operation.
+     asm volatile(LOCK_PREFIX "addb $0,%0" : : "m" (*(char *)vaddr) : "memory");
+   } else {
+      printk(KERN_INFO "memtrigger read_write failed, unable to get virtual address\n");
+   }
+}
+
+/*
+* READ_WRITE_FLUSH IOCTL,  Reads, writes, and flushes the specified address.
+*/
+void readwriteflush(u64 addr) {
+   void* vaddr;
+	
+   printk(KERN_INFO "memtrigger, rwf, phys_addr = %p\n", (void*)addr);
+   vaddr = __va(addr);
+   printk(KERN_INFO "memtrigger, rwf, vaddr = %p\n", vaddr);
+
+  if (vaddr != NULL) {
+   asm volatile(LOCK_PREFIX "addb $0,%0" : : "m" (*(char *)vaddr) : "memory");
+   clflush(vaddr);
+  }
+  else {
+    printk("memtrigger read_write_flush failed,  unable to get virtual address\n");
+  }
+}
+
+int device_ioctl(struct inode *inode, struct file *file, unsigned int ioctl_num, u64 ioctl_param) {
+   switch (ioctl_num) {
+       case IOCTL_FLUSH:
+ 	  flush(ioctl_param);
+       break;
+       case IOCTL_READ:
+          read(ioctl_param);
+       break;
+       case IOCTL_READ_FLUSH:
+          readflush(ioctl_param);
+       break;
+       case IOCTL_READ_WRITE:
+          readwrite(ioctl_param);
+       break;
+       case IOCTL_READ_WRITE_FLUSH:
+          readwriteflush(ioctl_param);
+       break;
+   }
+
+   return SUCCESS;
+
+
+}
+
+
+
+
diff --git a/drivers/char/memtrigger.h b/drivers/char/memtrigger.h
new file mode 100644
index 0000000..0ca8290
--- /dev/null
+++ b/drivers/char/memtrigger.h
@@ -0,0 +1,42 @@
+/*******************************************************************************
+
+  Memtrigger Kernel Module
+  Copyright(c) Intel(R) Corporation 2011
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+	Description  
+	Memtrigger kernel module. Provides mechanism to force a read/write/flush
+    of a physical memory address.  This can be used to trigger the detection of change and/or
+	the consumption of data the at the physical memory location. 
+*/
+
+#ifndef MEMTRIGGER_H
+#define MEMTRIGGER_H
+
+#include <linux/ioctl.h>
+
+#define MAJOR_NUM 0xE1
+
+#define IOCTL_FLUSH _IOR(MAJOR_NUM, 0, u64)
+#define IOCTL_READ _IOR(MAJOR_NUM, 1, u64)
+#define IOCTL_READ_FLUSH _IOR(MAJOR_NUM, 2, u64)
+#define IOCTL_READ_WRITE _IOR(MAJOR_NUM, 3, u64)
+#define IOCTL_READ_WRITE_FLUSH _IOR(MAJOR_NUM, 4, u64)
+
+
+#endif //MEMTRIGGER_H
-- 
1.7.0

