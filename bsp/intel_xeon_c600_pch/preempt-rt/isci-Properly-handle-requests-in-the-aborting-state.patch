From 65715b0876a5ae13f13147a2848b198215b34413 Mon Sep 17 00:00:00 2001
From: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date: Thu, 31 Mar 2011 13:10:34 -0700
Subject: [PATCH 086/478] isci: Properly handle requests in the "aborting" state.

upstream: f219f010a355487638bf2fff4724a420e7158fd2

When a TMF times-out, the request is set back to "aborting".
Requests in the "aborting" state must be terminated when
LUN and device resets occur.

Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/scsi/isci/request.h |    2 +-
 drivers/scsi/isci/task.c    |   14 +++++++++++---
 2 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/drivers/scsi/isci/request.h b/drivers/scsi/isci/request.h
index 4a63bb6..0c08da6 100644
--- a/drivers/scsi/isci/request.h
+++ b/drivers/scsi/isci/request.h
@@ -199,7 +199,7 @@ static inline enum isci_request_status isci_request_change_started_to_newstate(
 
 	old_state = isci_request->status;
 
-	if (old_state == started) {
+	if (old_state == started || old_state == aborting) {
 		BUG_ON(isci_request->io_request_completion != NULL);
 
 		isci_request->io_request_completion = completion_ptr;
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index 7e96684..338f08e 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -903,7 +903,9 @@ static void isci_terminate_request(
 		new_request_state
 		);
 
-	if ((old_state == started) || (old_state == completed)) {
+	if ((old_state == started) ||
+	    (old_state == completed) ||
+	    (old_state == aborting)) {
 
 		/* If the old_state is started:
 		 * This request was not already being aborted. If it had been,
@@ -920,6 +922,10 @@ static void isci_terminate_request(
 		 * This request completed from the SCU hardware perspective
 		 * and now just needs cleaning up in terms of freeing the
 		 * request and potentially calling up to libsas.
+		 *
+		 * If old_state == aborting:
+		 * This request has already gone through a TMF timeout, but may
+		 * not have been terminated; needs cleaning up at least.
 		 */
 		isci_terminate_request_core(isci_host, isci_device,
 					    isci_request);
@@ -1297,14 +1303,16 @@ int isci_task_abort_task(struct sas_task *task)
 
 	spin_lock_irqsave(&isci_host->scic_lock, flags);
 
-	/* Check the request status and change to "aborting" if currently
+	/* Check the request status and change to "aborted" if currently
 	 * "starting"; if true then set the I/O kernel completion
 	 * struct that will be triggered when the request completes.
 	 */
 	old_state = isci_task_validate_request_to_abort(
 				old_request, isci_host, isci_device,
 				&aborted_io_completion);
-	if ((old_state != started) && (old_state != completed)) {
+	if ((old_state != started) &&
+	    (old_state != completed) &&
+	    (old_state != aborting)) {
 
 		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
 
-- 
1.7.0

