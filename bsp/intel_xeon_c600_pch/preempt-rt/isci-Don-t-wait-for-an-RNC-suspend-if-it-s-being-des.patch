From ffee9758fcdcb4d0e9a4b6d6f662e3420760be12 Mon Sep 17 00:00:00 2001
From: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date: Thu, 8 Mar 2012 22:42:08 -0800
Subject: [PATCH 177/478] isci: Don't wait for an RNC suspend if it's being destroyed.

commit 1fabdf161e28b10143c11a67628f450163f5e609 from
git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git

Make sure that the wait for suspend can handle the RNC destruction case.

Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
---
 drivers/scsi/isci/remote_device.c       |   20 ++++++++++++++++----
 drivers/scsi/isci/remote_node_context.c |    5 +++++
 drivers/scsi/isci/remote_node_context.h |    7 +++++++
 3 files changed, 28 insertions(+), 4 deletions(-)

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index be9f0e0..68ab4fb 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -142,7 +142,12 @@ static bool isci_compare_suspendcount(
 	u32 localcount)
 {
 	smp_rmb();
-	return localcount != idev->rnc.suspend_count;
+
+	/* Check for a change in the suspend count, or the RNC
+	 * being destroyed.
+	 */
+	return (localcount != idev->rnc.suspend_count)
+	    || sci_remote_node_context_is_being_destroyed(&idev->rnc);
 }
 
 static bool isci_check_reqterm(
@@ -1380,7 +1385,8 @@ enum sci_status isci_remote_device_resume_from_abort(
 	struct isci_remote_device *idev)
 {
 	unsigned long flags;
-	enum sci_status status;
+	enum sci_status status = SCI_SUCCESS;
+	int destroyed;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 	/* Preserve any current resume callbacks, for instance from other
@@ -1390,11 +1396,17 @@ enum sci_status isci_remote_device_resume_from_abort(
 	idev->abort_resume_cbparam = idev->rnc.user_cookie;
 	set_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
 	clear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
-	status = sci_remote_device_resume(
+	destroyed = sci_remote_node_context_is_being_destroyed(&idev->rnc);
+	if (!destroyed)
+		status = sci_remote_device_resume(
 			idev, isci_remote_device_resume_from_abort_complete,
 			idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-	isci_remote_device_wait_for_resume_from_abort(ihost, idev);
+	if (!destroyed)
+		isci_remote_device_wait_for_resume_from_abort(ihost, idev);
+	else
+		clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
+
 	return status;
 }
 
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index a0a62e3..920c2bb 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -270,6 +270,8 @@ static void sci_remote_node_context_invalidate_context_buffer(struct sci_remote_
 static void sci_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct isci_remote_device *idev = rnc_to_dev(rnc);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	/* Check to see if we have gotten back to the initial state because
 	 * someone requested to destroy the remote node context object.
@@ -277,6 +279,9 @@ static void sci_remote_node_context_initial_state_enter(struct sci_base_state_ma
 	if (sm->previous_state_id == SCI_RNC_INVALIDATING) {
 		rnc->destination_state = RNC_DEST_UNSPECIFIED;
 		sci_remote_node_context_notify_user(rnc);
+
+		smp_wmb();
+		wake_up(&ihost->eventq);
 	}
 }
 
diff --git a/drivers/scsi/isci/remote_node_context.h b/drivers/scsi/isci/remote_node_context.h
index c61c02e..0d4a24d 100644
--- a/drivers/scsi/isci/remote_node_context.h
+++ b/drivers/scsi/isci/remote_node_context.h
@@ -226,4 +226,11 @@ enum sci_status sci_remote_node_context_start_io(struct sci_remote_node_context
 int sci_remote_node_context_is_safe_to_abort(
 	struct sci_remote_node_context *sci_rnc);
 
+static inline bool sci_remote_node_context_is_being_destroyed(
+	struct sci_remote_node_context *sci_rnc)
+{
+	return ((sci_rnc->sm.current_state_id == SCI_RNC_INVALIDATING)
+		&& (sci_rnc->destination_state == RNC_DEST_FINAL))
+		|| (sci_rnc->sm.current_state_id == SCI_RNC_INITIAL);
+}
 #endif  /* _SCIC_SDS_REMOTE_NODE_CONTEXT_H_ */
-- 
1.7.0

