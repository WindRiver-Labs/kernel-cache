From cd8fef71bbf2d736bd140d5980b8d73ab42c9125 Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Wed, 23 Feb 2011 15:57:30 -0800
Subject: [PATCH 033/474] isci: Change event notify calls from scic_cb_* to isci_event_*

upstream: a1914059f1434b0cdf113ebf16df627fd85689d0

Renaming the callbacks to apparopriate event notify calls for the LLDD.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/scsi/isci/core/scic_sds_controller.c       |   24 +-
 drivers/scsi/isci/core/scic_sds_phy.c              |   14 +-
 drivers/scsi/isci/core/scic_sds_port.c             |   37 ++-
 .../isci/core/scic_sds_port_configuration_agent.c  |   10 +-
 drivers/scsi/isci/core/scic_sds_remote_device.c    |   10 +-
 drivers/scsi/isci/core/scic_sds_request.c          |    4 +-
 .../scsi/isci/core/scic_sds_smp_remote_device.c    |    4 +-
 .../scsi/isci/core/scic_sds_stp_remote_device.c    |    6 +-
 drivers/scsi/isci/core/scic_user_callback.h        |  315 -----------------
 drivers/scsi/isci/events.c                         |   90 +++---
 drivers/scsi/isci/events.h                         |  370 ++++++++++++++++++++
 drivers/scsi/isci/isci.h                           |    1 +
 12 files changed, 476 insertions(+), 409 deletions(-)
 create mode 100644 drivers/scsi/isci/events.h

diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index e8d09fd..b0f9221 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -256,7 +256,7 @@ static void scic_sds_controller_phy_startup_timeout_handler(
 void scic_sds_controller_initialize_phy_startup(
 	struct scic_sds_controller *this_controller)
 {
-	this_controller->phy_startup_timer = scic_cb_timer_create(
+	this_controller->phy_startup_timer = isci_event_timer_create(
 		this_controller,
 		scic_sds_controller_phy_startup_timeout_handler,
 		this_controller
@@ -275,7 +275,7 @@ void scic_sds_controller_initialize_phy_startup(
 void scic_sds_controller_initialize_power_control(
 	struct scic_sds_controller *this_controller)
 {
-	this_controller->power_control.timer = scic_cb_timer_create(
+	this_controller->power_control.timer = isci_event_timer_create(
 		this_controller,
 		scic_sds_controller_power_control_timer_handler,
 		this_controller
@@ -734,7 +734,7 @@ static void scic_sds_controller_transition_to_ready(
 			SCI_BASE_CONTROLLER_STATE_READY
 			);
 
-		scic_cb_controller_start_complete(this_controller, status);
+		isci_event_controller_start_complete(this_controller, status);
 	}
 }
 
@@ -757,7 +757,7 @@ void scic_sds_controller_timeout_handler(
 		sci_base_state_machine_change_state(
 			scic_sds_controller_get_base_state_machine(scic),
 			SCI_BASE_CONTROLLER_STATE_FAILED);
-		scic_cb_controller_stop_complete(scic, SCI_FAILURE_TIMEOUT);
+		isci_event_controller_stop_complete(scic, SCI_FAILURE_TIMEOUT);
 	} else	/* / @todo Now what do we want to do in this case? */
 		dev_err(scic_to_dev(scic),
 			"%s: Controller timer fired when controller was not "
@@ -823,7 +823,7 @@ enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller *scic)
 static void scic_sds_controller_phy_timer_start(
 	struct scic_sds_controller *this_controller)
 {
-	scic_cb_timer_start(
+	isci_event_timer_start(
 		this_controller,
 		this_controller->phy_startup_timer,
 		SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
@@ -840,7 +840,7 @@ static void scic_sds_controller_phy_timer_start(
 void scic_sds_controller_phy_timer_stop(
 	struct scic_sds_controller *this_controller)
 {
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		this_controller,
 		this_controller->phy_startup_timer
 		);
@@ -1041,7 +1041,7 @@ enum sci_status scic_sds_controller_stop_devices(
 static void scic_sds_controller_power_control_timer_start(
 	struct scic_sds_controller *this_controller)
 {
-	scic_cb_timer_start(
+	isci_event_timer_start(
 		this_controller, this_controller->power_control.timer,
 		SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL
 		);
@@ -2809,7 +2809,7 @@ static enum sci_status scic_sds_controller_reset_state_initialize_handler(
 		SCI_BASE_CONTROLLER_STATE_INITIALIZING
 		);
 
-	this_controller->timeout_timer = scic_cb_timer_create(
+	this_controller->timeout_timer = isci_event_timer_create(
 		this_controller,
 		(void (*)(void *))scic_sds_controller_timeout_handler,
 		(void (*)(void *))controller);
@@ -3040,7 +3040,7 @@ static enum sci_status scic_sds_controller_initialized_state_start_handler(
 	if (SCI_SUCCESS == result) {
 		scic_sds_controller_start_next_phy(this_controller);
 
-		scic_cb_timer_start(this_controller,
+		isci_event_timer_start(this_controller,
 				    this_controller->timeout_timer,
 				    timeout);
 
@@ -3130,7 +3130,7 @@ static enum sci_status scic_sds_controller_ready_state_stop_handler(
 
 	this_controller = (struct scic_sds_controller *)controller;
 
-	scic_cb_timer_start(this_controller,
+	isci_event_timer_start(this_controller,
 			    this_controller->timeout_timer,
 			    timeout);
 
@@ -3578,7 +3578,7 @@ static void scic_sds_controller_starting_state_exit(
 {
 	struct scic_sds_controller *scic = (struct scic_sds_controller *)object;
 
-	scic_cb_timer_stop(scic, scic->timeout_timer);
+	isci_event_timer_stop(scic, scic->timeout_timer);
 }
 
 /**
@@ -3660,7 +3660,7 @@ static void scic_sds_controller_stopping_state_exit(
 
 	this_controller = (struct scic_sds_controller *)object;
 
-	scic_cb_timer_stop(this_controller, this_controller->timeout_timer);
+	isci_event_timer_stop(this_controller, this_controller->timeout_timer);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index e8d5be7..92a5d29 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -370,7 +370,7 @@ enum sci_status scic_sds_phy_initialize(
 	struct scu_link_layer_registers __iomem *link_layer_registers)
 {
 	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer = scic_cb_timer_create(
+	sci_phy->sata_timeout_timer = isci_event_timer_create(
 		scic_sds_phy_get_controller(sci_phy),
 		scic_sds_phy_sata_timeout,
 		sci_phy
@@ -1746,7 +1746,7 @@ static void scic_sds_phy_starting_await_sata_phy_substate_enter(
 		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN
 		);
 
-	scic_cb_timer_start(
+	isci_event_timer_start(
 		scic_sds_phy_get_controller(this_phy),
 		this_phy->sata_timeout_timer,
 		SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT
@@ -1768,7 +1768,7 @@ static void scic_sds_phy_starting_await_sata_phy_substate_exit(
 
 	this_phy = (struct scic_sds_phy *)object;
 
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		scic_sds_phy_get_controller(this_phy),
 		this_phy->sata_timeout_timer
 		);
@@ -1793,7 +1793,7 @@ static void scic_sds_phy_starting_await_sata_speed_substate_enter(
 		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN
 		);
 
-	scic_cb_timer_start(
+	isci_event_timer_start(
 		scic_sds_phy_get_controller(this_phy),
 		this_phy->sata_timeout_timer,
 		SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT
@@ -1815,7 +1815,7 @@ static void scic_sds_phy_starting_await_sata_speed_substate_exit(
 
 	this_phy = (struct scic_sds_phy *)object;
 
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		scic_sds_phy_get_controller(this_phy),
 		this_phy->sata_timeout_timer
 		);
@@ -1854,7 +1854,7 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(
 		 * condition is cleared. */
 		scic_sds_phy_resume(this_phy);
 
-		scic_cb_timer_start(
+		isci_event_timer_start(
 			scic_sds_phy_get_controller(this_phy),
 			this_phy->sata_timeout_timer,
 			SCIC_SDS_SIGNATURE_FIS_TIMEOUT
@@ -1879,7 +1879,7 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(
 
 	this_phy = (struct scic_sds_phy *)object;
 
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		scic_sds_phy_get_controller(this_phy),
 		this_phy->sata_timeout_timer
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index b8acc23..f31e6dc 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -565,7 +565,7 @@ enum sci_status scic_sds_port_initialize(
 	 * the timer and start the state machine */
 	if (this_port->physical_port_index != SCI_MAX_PORTS) {
 		/* / @todo should we create the timer at create time? */
-		this_port->timer_handle = scic_cb_timer_create(
+		this_port->timer_handle = isci_event_timer_create(
 			scic_sds_port_get_controller(this_port),
 			scic_sds_port_timeout_handler,
 			this_port
@@ -727,7 +727,9 @@ void scic_sds_port_activate_phy(
 	scic_sds_controller_clear_invalid_phy(controller, the_phy);
 
 	if (do_notify_user == true)
-		scic_cb_port_link_up(this_port->owning_controller, this_port, the_phy);
+		isci_event_port_link_up(this_port->owning_controller,
+					this_port,
+					the_phy);
 }
 
 /**
@@ -735,7 +737,8 @@ void scic_sds_port_activate_phy(
  * @this_port: This is the port on which the phy should be deactivated.
  * @the_phy: This is the specific phy that is no longer active in the port.
  * @do_notify_user: This parameter specifies whether to inform the user (via
- *    scic_cb_port_link_down()) as to the fact that a new phy as become ready.
+ *    isci_event_port_link_down()) as to the fact that a new phy as become
+ *    ready.
  *
  * This method will deactivate the supplied phy in the port. none
  */
@@ -752,7 +755,9 @@ void scic_sds_port_deactivate_phy(
 	SCU_PCSPExCR_WRITE(this_port, the_phy->phy_index, the_phy->phy_index);
 
 	if (do_notify_user == true)
-		scic_cb_port_link_down(this_port->owning_controller, this_port, the_phy);
+		isci_event_port_link_down(this_port->owning_controller,
+					  this_port,
+					  the_phy);
 }
 
 /**
@@ -775,7 +780,7 @@ static void scic_sds_port_invalid_link_up(
 	if ((controller->invalid_phy_mask & (1 << the_phy->phy_index)) == 0) {
 		scic_sds_controller_set_invalid_phy(controller, the_phy);
 
-		scic_cb_port_invalid_link_up(controller, this_port, the_phy);
+		isci_event_port_invalid_link_up(controller, this_port, the_phy);
 	}
 }
 
@@ -933,7 +938,7 @@ static void scic_sds_port_timeout_handler(void *port)
 			this_port);
 	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
 		/* if the port is still stopping then the stop has not completed */
-		scic_cb_port_stop_complete(
+		isci_event_port_stop_complete(
 			scic_sds_port_get_controller(this_port),
 			port,
 			SCI_FAILURE_TIMEOUT
@@ -1030,7 +1035,7 @@ void scic_sds_port_broadcast_change_received(
 	struct scic_sds_phy *this_phy)
 {
 	/* notify the user. */
-	scic_cb_port_bc_change_primitive_received(
+	isci_event_port_bc_change_primitive_received(
 		this_port->owning_controller, this_port, this_phy
 		);
 }
@@ -1259,7 +1264,7 @@ static enum sci_status scic_sds_port_ready_operational_substate_reset_handler(
 		status = scic_sds_phy_reset(selected_phy);
 
 		if (status == SCI_SUCCESS) {
-			scic_cb_timer_start(
+			isci_event_timer_start(
 				scic_sds_port_get_controller(this_port),
 				this_port->timer_handle,
 				timeout
@@ -1610,7 +1615,7 @@ static void scic_sds_port_ready_substate_operational_enter(
 		this_port, SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
 		);
 
-	scic_cb_port_ready(
+	isci_event_port_ready(
 		scic_sds_port_get_controller(this_port), this_port
 		);
 
@@ -1640,7 +1645,7 @@ static void scic_sds_port_ready_substate_operational_exit(
 {
 	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
 
-	scic_cb_port_not_ready(
+	isci_event_port_not_ready(
 		scic_sds_port_get_controller(this_port),
 		this_port,
 		this_port->not_ready_reason
@@ -1670,7 +1675,7 @@ static void scic_sds_port_ready_substate_configuring_enter(
 		);
 
 	if (this_port->active_phy_mask == 0) {
-		scic_cb_port_not_ready(
+		isci_event_port_not_ready(
 			scic_sds_port_get_controller(this_port),
 			this_port,
 			SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS
@@ -2544,14 +2549,14 @@ static void scic_sds_port_ready_state_enter(
 		SCI_BASE_PORT_STATE_RESETTING
 		== this_port->parent.state_machine.previous_state_id
 		) {
-		scic_cb_port_hard_reset_complete(
+		isci_event_port_hard_reset_complete(
 			scic_sds_port_get_controller(this_port),
 			this_port,
 			SCI_SUCCESS
 			);
 	} else {
 		/* Notify the caller that the port is not yet ready */
-		scic_cb_port_not_ready(
+		isci_event_port_not_ready(
 			scic_sds_port_get_controller(this_port),
 			this_port,
 			SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS
@@ -2615,7 +2620,7 @@ static void scic_sds_port_resetting_state_exit(
 
 	this_port = (struct scic_sds_port *)object;
 
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		scic_sds_port_get_controller(this_port),
 		this_port->timer_handle
 		);
@@ -2655,7 +2660,7 @@ static void scic_sds_port_stopping_state_exit(
 
 	this_port = (struct scic_sds_port *)object;
 
-	scic_cb_timer_stop(
+	isci_event_timer_stop(
 		scic_sds_port_get_controller(this_port),
 		this_port->timer_handle
 		);
@@ -2681,7 +2686,7 @@ static void scic_sds_port_failed_state_enter(
 		SCI_BASE_PORT_STATE_FAILED
 		);
 
-	scic_cb_port_hard_reset_complete(
+	isci_event_port_hard_reset_complete(
 		scic_sds_port_get_controller(this_port),
 		this_port,
 		SCI_FAILURE_TIMEOUT
diff --git a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
index 001472e..e26a4e6 100644
--- a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
+++ b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
@@ -463,7 +463,7 @@ static void scic_sds_mpc_agent_link_down(
 			) {
 			port_agent->timer_pending = true;
 
-			scic_cb_timer_start(
+			isci_event_timer_start(
 				controller,
 				port_agent->timer,
 				SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT
@@ -542,12 +542,12 @@ static void scic_sds_apc_agent_start_timer(
 	u32 timeout)
 {
 	if (port_agent->timer_pending) {
-		scic_cb_timer_stop(controller, port_agent->timer);
+		isci_event_timer_stop(controller, port_agent->timer);
 	}
 
 	port_agent->timer_pending = true;
 
-	scic_cb_timer_start(controller, port_agent->timer, timeout);
+	isci_event_timer_start(controller, port_agent->timer, timeout);
 }
 
 /**
@@ -830,7 +830,7 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
 
-		port_agent->timer = scic_cb_timer_create(
+		port_agent->timer = isci_event_timer_create(
 			controller,
 			scic_sds_mpc_agent_timeout_handler,
 			controller
@@ -841,7 +841,7 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
 
-		port_agent->timer = scic_cb_timer_create(
+		port_agent->timer = isci_event_timer_create(
 			controller,
 			scic_sds_apc_agent_timeout_handler,
 			controller
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.c b/drivers/scsi/isci/core/scic_sds_remote_device.c
index cb1cf39..3a8d563 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_remote_device.c
@@ -1817,7 +1817,7 @@ static void scic_sds_remote_device_stopped_state_enter(
 	 * the stop operation has completed. */
 	if (this_device->parent.state_machine.previous_state_id
 	    == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING) {
-		scic_cb_remote_device_stop_complete(
+		isci_event_remote_device_stop_complete(
 			scic_sds_remote_device_get_controller(this_device),
 			this_device,
 			SCI_SUCCESS
@@ -1848,7 +1848,7 @@ static void scic_sds_remote_device_starting_state_enter(
 		SCI_BASE_REMOTE_DEVICE_STATE_STARTING
 		);
 
-	scic_cb_remote_device_not_ready(
+	isci_event_remote_device_not_ready(
 		the_controller,
 		this_device,
 		SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED
@@ -1871,7 +1871,7 @@ static void scic_sds_remote_device_starting_state_exit(
 	/*
 	 * / @todo Check the device object for the proper return code for this
 	 * /       callback */
-	scic_cb_remote_device_start_complete(
+	isci_event_remote_device_start_complete(
 		scic_sds_remote_device_get_controller(this_device),
 		this_device,
 		SCI_SUCCESS
@@ -1905,7 +1905,7 @@ static void scic_sds_remote_device_ready_state_enter(
 	if (this_device->has_ready_substate_machine) {
 		sci_base_state_machine_start(&this_device->ready_substate_machine);
 	} else {
-		scic_cb_remote_device_ready(the_controller, this_device);
+		isci_event_remote_device_ready(the_controller, this_device);
 	}
 }
 
@@ -1928,7 +1928,7 @@ static void scic_sds_remote_device_ready_state_exit(
 	if (this_device->has_ready_substate_machine) {
 		sci_base_state_machine_stop(&this_device->ready_substate_machine);
 	} else {
-		scic_cb_remote_device_not_ready(
+		isci_event_remote_device_not_ready(
 			the_controller,
 			this_device,
 			SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index 3bad0bc..909361f 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -2078,14 +2078,14 @@ static void scic_sds_request_completed_state_enter(
 
 	/* Tell the SCI_USER that the IO request is complete */
 	if (this_request->is_task_management_request == false) {
-		scic_cb_io_request_complete(
+		isci_event_io_request_complete(
 			scic_sds_request_get_controller(this_request),
 			scic_sds_request_get_device(this_request),
 			this_request,
 			this_request->sci_status
 			);
 	} else {
-		scic_cb_task_request_complete(
+		isci_event_task_request_complete(
 			scic_sds_request_get_controller(this_request),
 			scic_sds_request_get_device(this_request),
 			this_request,
diff --git a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
index ea608c1..e90d46e 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
@@ -265,7 +265,7 @@ static void scic_sds_smp_remote_device_ready_idle_substate_enter(
 		SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
 		);
 
-	scic_cb_remote_device_ready(
+	isci_event_remote_device_ready(
 		scic_sds_remote_device_get_controller(this_device), this_device);
 }
 
@@ -291,7 +291,7 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(
 		SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD
 		);
 
-	scic_cb_remote_device_not_ready(
+	isci_event_remote_device_not_ready(
 		scic_sds_remote_device_get_controller(this_device),
 		this_device,
 		SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED
diff --git a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
index 880e0e5..ce2cb7b 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
@@ -667,7 +667,7 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 	 * the ready notification. */
 	if (this_device->ready_substate_machine.previous_state_id
 	    != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ) {
-		scic_cb_remote_device_ready(
+		isci_event_remote_device_ready(
 			scic_sds_remote_device_get_controller(this_device), this_device
 			);
 	}
@@ -741,7 +741,7 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(
 		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD
 		);
 
-	scic_cb_remote_device_not_ready(
+	isci_event_remote_device_not_ready(
 		scic_sds_remote_device_get_controller(this_device),
 		this_device,
 		SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED
@@ -799,7 +799,7 @@ static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(
 
 	if (this_device->not_ready_reason ==
 	    SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED) {
-		scic_cb_remote_device_not_ready(
+		isci_event_remote_device_not_ready(
 			scic_sds_remote_device_get_controller(this_device),
 			this_device,
 			this_device->not_ready_reason
diff --git a/drivers/scsi/isci/core/scic_user_callback.h b/drivers/scsi/isci/core/scic_user_callback.h
index d1a3cb8..c097711 100644
--- a/drivers/scsi/isci/core/scic_user_callback.h
+++ b/drivers/scsi/isci/core/scic_user_callback.h
@@ -74,62 +74,6 @@ struct scic_sds_remote_device;
 struct scic_sds_controller;
 
 /**
- * scic_cb_timer_create() - This callback method asks the user to create a
- *    timer and provide a handle for this timer for use in further timer
- *    interactions.
- * @controller: This parameter specifies the controller with which this timer
- *    is to be associated.
- * @timer_callback: This parameter specifies the callback method to be invoked
- *    whenever the timer expires.
- * @cookie: This parameter specifies a piece of information that the user must
- *    retain.  This cookie is to be supplied by the user anytime a timeout
- *    occurs for the created timer.
- *
- * The "timer_callback" method should be executed in a mutually exlusive manner
- * from the controller completion handler handler. This method returns a handle
- * to a timer object created by the user.  The handle will be utilized for all
- * further interactions relating to this timer.
- */
-void *scic_cb_timer_create(
-	struct scic_sds_controller *controller,
-	void (*timer_callback)(void *),
-	void *cookie);
-
-
-/**
- * scic_cb_timer_start() - This callback method asks the user to start the
- *    supplied timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be started.
- * @milliseconds: This parameter specifies the number of milliseconds for which
- *    to stall.  The operating system driver is allowed to round this value up
- *    where necessary.
- *
- * All timers in the system started by the SCI Core are one shot timers.
- * Therefore, the SCI user should make sure that it removes the timer from it's
- * list when a timer actually fires. Additionally, SCI Core user's should be
- * able to handle calls from the SCI Core to stop a timer that may already be
- * stopped. none
- */
-void scic_cb_timer_start(
-	struct scic_sds_controller *controller,
-	void *timer,
-	u32 milliseconds);
-
-/**
- * scic_cb_timer_stop() - This callback method asks the user to stop the
- *    supplied timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be stopped.
- *
- */
-void scic_cb_timer_stop(
-	struct scic_sds_controller *controller,
-	void *timer);
-
-/**
  * scic_cb_stall_execution() - This method is called when the core requires the
  *    OS driver to stall execution.  This method is utilized during
  *    initialization or non-performance paths only.
@@ -142,67 +86,6 @@ void scic_cb_timer_stop(
 void scic_cb_stall_execution(
 	u32 microseconds);
 
-/**
- * scic_cb_controller_start_complete() - This user callback will inform the
- *    user that the controller has finished the start process.
- * @controller: This parameter specifies the controller that was started.
- * @completion_status: This parameter specifies the results of the start
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void scic_cb_controller_start_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_controller_stop_complete() - This user callback will inform the user
- *    that the controller has finished the stop process.
- * @controller: This parameter specifies the controller that was stopped.
- * @completion_status: This parameter specifies the results of the stop
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void scic_cb_controller_stop_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_io_request_complete() - This user callback will inform the user that
- *    an IO request has completed.
- * @controller: This parameter specifies the controller on which the IO is
- *    completing.
- * @remote_device: This parameter specifies the remote device on which this IO
- *    request is completing.
- * @io_request: This parameter specifies the IO request that has completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void scic_cb_io_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *io_request,
-	enum sci_io_status completion_status);
-
-/**
- * scic_cb_task_request_complete() - This user callback will inform the user
- *    that a task management request completed.
- * @controller: This parameter specifies the controller on which the task
- *    management request is completing.
- * @remote_device: This parameter specifies the remote device on which this
- *    task management request is completing.
- * @task_request: This parameter specifies the task management request that has
- *    completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void scic_cb_task_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *task_request,
-	enum sci_task_status completion_status);
-
 #ifndef SCI_GET_PHYSICAL_ADDRESS_OPTIMIZATION_ENABLED
 /**
  * scic_cb_io_request_get_physical_address() - This callback method asks the
@@ -508,204 +391,6 @@ void *scic_cb_get_virtual_address(
 	struct scic_sds_controller *controller,
 	dma_addr_t physical_address);
 
-/**
- * scic_cb_port_stop_complete() - This method informs the user when a stop
- *    operation on the port has completed.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void scic_cb_port_stop_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_port_hard_reset_complete() - This method informs the user when a
- *    hard reset on the port has completed.  This hard reset could have been
- *    initiated by the user or by the remote port.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void scic_cb_port_hard_reset_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_port_ready() - This method informs the user that the port is now in
- *    a ready state and can be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- *
- */
-void scic_cb_port_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port);
-
-/**
- * scic_cb_port_not_ready() - This method informs the user that the port is now
- *    not in a ready (i.e. busy) state and can't be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @reason_code: This parameter specifies the reason for the port not ready
- *    callback.
- *
- */
-void scic_cb_port_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	u32 reason_code);
-
-/**
- * scic_cb_port_invalid_link_up() - This method informs the SCI Core user that
- *    a phy/link became ready, but the phy is not allowed in the port.  In some
- *    situations the underlying hardware only allows for certain phy to port
- *    mappings.  If these mappings are violated, then this API is invoked.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @phy: This parameter specifies the phy that came ready, but the phy can't be
- *    a valid member of the port.
- *
- */
-void scic_cb_port_invalid_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * scic_cb_port_bc_change_primitive_received() - This callback method informs
- *    the user that a broadcast change primitive was received.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.  For instances where the phy on which the primitive was
- *    received is not part of a port, this parameter will be
- *    NULL.
- * @phy: This parameter specifies the phy on which the primitive was received.
- *
- */
-void scic_cb_port_bc_change_primitive_received(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-
-
-
-/**
- * scic_cb_port_link_up() - This callback method informs the user that a phy
- *    has become operational and is capable of communicating with the remote
- *    end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- */
-void scic_cb_port_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * scic_cb_port_link_down() - This callback method informs the user that a phy
- *    is no longer operational and is not capable of communicating with the
- *    remote end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- */
-void scic_cb_port_link_down(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * scic_cb_remote_device_start_complete() - This user callback method will
- *    inform the user that a start operation has completed.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void scic_cb_remote_device_start_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_remote_device_stop_complete() - This user callback method will
- *    inform the user that a stop operation has completed.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void scic_cb_remote_device_stop_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	enum sci_status completion_status);
-
-/**
- * scic_cb_remote_device_ready() - This user callback method will inform the
- *    user that a remote device is now capable of handling IO requests.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- *
- */
-void scic_cb_remote_device_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device);
-
-/**
- * scic_cb_remote_device_not_ready() - This user callback method will inform
- *    the user that a remote device is no longer capable of handling IO
- *    requests (until a ready callback is invoked).
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- * @reason_code: This paramete specifies the reason the remote device is not
- *    ready.
- *
- */
-void scic_cb_remote_device_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	u32 reason_code);
-
 #if !defined(DISABLE_ATAPI)
 /**
  * scic_cb_stp_packet_io_request_get_cdb_address() - This user callback gets
diff --git a/drivers/scsi/isci/events.c b/drivers/scsi/isci/events.c
index 6911ea5..8872f4c 100644
--- a/drivers/scsi/isci/events.c
+++ b/drivers/scsi/isci/events.c
@@ -64,9 +64,10 @@
 #include "request.h"
 #include "sata.h"
 #include "task.h"
+#include "events.h"
 
 /**
- * scic_cb_timer_create() - This callback method asks the user to create a
+ * isci_event_timer_create() - This callback method asks the user to create a
  *    timer and provide a handle for this timer for use in further timer
  *    interactions. The appropriate isci timer object function is called to
  *    create a timer object.
@@ -81,7 +82,7 @@
  * This method returns a handle to a timer object created by the user.  The
  * handle will be utilized for all further interactions relating to this timer.
  */
-void *scic_cb_timer_create(
+void *isci_event_timer_create(
 	struct scic_sds_controller *controller,
 	void (*timer_callback)(void *),
 	void *cookie)
@@ -107,7 +108,7 @@ void *scic_cb_timer_create(
 
 
 /**
- * scic_cb_timer_start() - This callback method asks the user to start the
+ * isci_event_timer_start() - This callback method asks the user to start the
  *    supplied timer. The appropriate isci timer object function is called to
  *    start the timer.
  * @controller: This parameter specifies the controller with which this timer
@@ -118,7 +119,7 @@ void *scic_cb_timer_create(
  *    where necessary.
  *
  */
-void scic_cb_timer_start(
+void isci_event_timer_start(
 	struct scic_sds_controller *controller,
 	void *timer,
 	u32 milliseconds)
@@ -137,7 +138,7 @@ void scic_cb_timer_start(
 }
 
 /**
- * scic_cb_timer_stop() - This callback method asks the user to stop the
+ * isci_event_timer_stop() - This callback method asks the user to stop the
  *    supplied timer. The appropriate isci timer object function is called to
  *    stop the timer.
  * @controller: This parameter specifies the controller with which this timer
@@ -145,7 +146,7 @@ void scic_cb_timer_start(
  * @timer: This parameter specifies the timer to be stopped.
  *
  */
-void scic_cb_timer_stop(
+void isci_event_timer_stop(
 	struct scic_sds_controller *controller,
 	void *timer)
 {
@@ -162,7 +163,7 @@ void scic_cb_timer_stop(
 }
 
 /**
- * scic_cb_controller_start_complete() - This user callback will inform the
+ * isci_event_controller_start_complete() - This user callback will inform the
  *    user that the controller has finished the start process. The associated
  *    isci host adapter's start_complete function is called.
  * @controller: This parameter specifies the controller that was started.
@@ -170,7 +171,7 @@ void scic_cb_timer_stop(
  *    operation.  SCI_SUCCESS indicates successful completion.
  *
  */
-void scic_cb_controller_start_complete(
+void isci_event_controller_start_complete(
 	struct scic_sds_controller *controller,
 	enum sci_status completion_status)
 {
@@ -184,7 +185,7 @@ void scic_cb_controller_start_complete(
 }
 
 /**
- * scic_cb_controller_stop_complete() - This user callback will inform the user
+ * isci_event_controller_stop_complete() - This user callback will inform the user
  *    that the controller has finished the stop process. The associated isci
  *    host adapter's start_complete function is called.
  * @controller: This parameter specifies the controller that was stopped.
@@ -192,7 +193,7 @@ void scic_cb_controller_start_complete(
  *    operation.  SCI_SUCCESS indicates successful completion.
  *
  */
-void scic_cb_controller_stop_complete(
+void isci_event_controller_stop_complete(
 	struct scic_sds_controller *controller,
 	enum sci_status completion_status)
 {
@@ -205,7 +206,7 @@ void scic_cb_controller_stop_complete(
 }
 
 /**
- * scic_cb_io_request_complete() - This user callback will inform the user that
+ * isci_event_io_request_complete() - This user callback will inform the user that
  *    an IO request has completed.
  * @controller: This parameter specifies the controller on which the IO is
  *    completing.
@@ -216,7 +217,7 @@ void scic_cb_controller_stop_complete(
  *    operation.  SCI_SUCCESS indicates successful completion.
  *
  */
-void scic_cb_io_request_complete(
+void isci_event_io_request_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device,
 	struct scic_sds_request *scic_io_request,
@@ -239,7 +240,7 @@ void scic_cb_io_request_complete(
 }
 
 /**
- * scic_cb_task_request_complete() - This user callback will inform the user
+ * isci_event_task_request_complete() - This user callback will inform the user
  *    that a task management request completed.
  * @controller: This parameter specifies the controller on which the task
  *    management request is completing.
@@ -251,7 +252,7 @@ void scic_cb_io_request_complete(
  *    operation.  SCI_SUCCESS indicates successful completion.
  *
  */
-void scic_cb_task_request_complete(
+void isci_event_task_request_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device,
 	struct scic_sds_request *scic_task_request,
@@ -271,7 +272,7 @@ void scic_cb_task_request_complete(
 }
 
 /**
- * scic_cb_port_stop_complete() - This method informs the user when a stop
+ * isci_event_port_stop_complete() - This method informs the user when a stop
  *    operation on the port has completed.
  * @controller: This parameter represents the controller which contains the
  *    port.
@@ -281,17 +282,20 @@ void scic_cb_task_request_complete(
  *    being completed.
  *
  */
-void scic_cb_port_stop_complete(
+void isci_event_port_stop_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	enum sci_status completion_status)
 {
-	pr_warn("%s:************************************************\n",
-		__func__);
+	struct isci_host *isci_host;
+
+	isci_host = (struct isci_host *)sci_object_get_association(controller);
+
+	dev_notice(&isci_host->pdev->dev, "Port stop complete\n");
 }
 
 /**
- * scic_cb_port_hard_reset_complete() - This method informs the user when a
+ * isci_event_port_hard_reset_complete() - This method informs the user when a
  *    hard reset on the port has completed.  This hard reset could have been
  *    initiated by the user or by the remote port.
  * @controller: This parameter represents the controller which contains the
@@ -302,7 +306,7 @@ void scic_cb_port_stop_complete(
  *    being completed.
  *
  */
-void scic_cb_port_hard_reset_complete(
+void isci_event_port_hard_reset_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	enum sci_status completion_status)
@@ -314,7 +318,7 @@ void scic_cb_port_hard_reset_complete(
 }
 
 /**
- * scic_cb_port_ready() - This method informs the user that the port is now in
+ * isci_event_port_ready() - This method informs the user that the port is now in
  *    a ready state and can be utilized to issue IOs.
  * @controller: This parameter represents the controller which contains the
  *    port.
@@ -322,7 +326,7 @@ void scic_cb_port_hard_reset_complete(
  *    is being invoked.
  *
  */
-void scic_cb_port_ready(
+void isci_event_port_ready(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port)
 {
@@ -342,7 +346,7 @@ void scic_cb_port_ready(
 }
 
 /**
- * scic_cb_port_not_ready() - This method informs the user that the port is now
+ * isci_event_port_not_ready() - This method informs the user that the port is now
  *    not in a ready (i.e. busy) state and can't be utilized to issue IOs.
  * @controller: This parameter represents the controller which contains the
  *    port.
@@ -350,7 +354,7 @@ void scic_cb_port_ready(
  *    is being invoked.
  *
  */
-void scic_cb_port_not_ready(
+void isci_event_port_not_ready(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	u32 reason_code)
@@ -371,7 +375,7 @@ void scic_cb_port_not_ready(
 }
 
 /**
- * scic_cb_port_invalid_link_up() - This method informs the SCI Core user that
+ * isci_event_port_invalid_link_up() - This method informs the SCI Core user that
  *    a phy/link became ready, but the phy is not allowed in the port.  In some
  *    situations the underlying hardware only allows for certain phy to port
  *    mappings.  If these mappings are violated, then this API is invoked.
@@ -383,17 +387,19 @@ void scic_cb_port_not_ready(
  *    a valid member of the port.
  *
  */
-void scic_cb_port_invalid_link_up(
+void isci_event_port_invalid_link_up(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
 {
-	pr_warn("%s:************************************************\n",
-		__func__);
+	struct isci_host *isci_host;
+
+	isci_host = (struct isci_host *)sci_object_get_association(controller);
+	dev_warn(&isci_host->pdev->dev, "Invalid link up!\n");
 }
 
 /**
- * scic_cb_port_bc_change_primitive_received() - This callback method informs
+ * isci_event_port_bc_change_primitive_received() - This callback method informs
  *    the user that a broadcast change primitive was received.
  * @controller: This parameter represents the controller which contains the
  *    port.
@@ -403,7 +409,7 @@ void scic_cb_port_invalid_link_up(
  * @phy: This parameter specifies the phy on which the primitive was received.
  *
  */
-void scic_cb_port_bc_change_primitive_received(
+void isci_event_port_bc_change_primitive_received(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
@@ -422,7 +428,7 @@ void scic_cb_port_bc_change_primitive_received(
 
 
 /**
- * scic_cb_port_link_up() - This callback method informs the user that a phy
+ * isci_event_port_link_up() - This callback method informs the user that a phy
  *    has become operational and is capable of communicating with the remote
  *    end point.
  * @controller: This parameter represents the controller associated with the
@@ -435,7 +441,7 @@ void scic_cb_port_bc_change_primitive_received(
  *
  * none.
  */
-void scic_cb_port_link_up(
+void isci_event_port_link_up(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
@@ -452,7 +458,7 @@ void scic_cb_port_link_up(
 }
 
 /**
- * scic_cb_port_link_down() - This callback method informs the user that a phy
+ * isci_event_port_link_down() - This callback method informs the user that a phy
  *    is no longer operational and is not capable of communicating with the
  *    remote end point.
  * @controller: This parameter represents the controller associated with the
@@ -465,7 +471,7 @@ void scic_cb_port_link_up(
  *
  * none.
  */
-void scic_cb_port_link_down(
+void isci_event_port_link_down(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
@@ -490,7 +496,7 @@ void scic_cb_port_link_down(
 }
 
 /**
- * scic_cb_remote_device_start_complete() - This user callback method will
+ * isci_event_remote_device_start_complete() - This user callback method will
  *    inform the user that a start operation has completed.
  * @controller: This parameter specifies the core controller associated with
  *    the completion callback.
@@ -500,7 +506,7 @@ void scic_cb_port_link_down(
  *    operation.
  *
  */
-void scic_cb_remote_device_start_complete(
+void isci_event_remote_device_start_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device,
 	enum sci_status completion_status)
@@ -525,7 +531,7 @@ void scic_cb_remote_device_start_complete(
 }
 
 /**
- * scic_cb_remote_device_stop_complete() - This user callback method will
+ * isci_event_remote_device_stop_complete() - This user callback method will
  *    inform the user that a stop operation has completed.
  * @controller: This parameter specifies the core controller associated with
  *    the completion callback.
@@ -535,7 +541,7 @@ void scic_cb_remote_device_start_complete(
  *    operation.
  *
  */
-void scic_cb_remote_device_stop_complete(
+void isci_event_remote_device_stop_complete(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device,
 	enum sci_status completion_status)
@@ -560,7 +566,7 @@ void scic_cb_remote_device_stop_complete(
 }
 
 /**
- * scic_cb_remote_device_ready() - This user callback method will inform the
+ * isci_event_remote_device_ready() - This user callback method will inform the
  *    user that a remote device is now capable of handling IO requests.
  * @controller: This parameter specifies the core controller associated with
  *    the completion callback.
@@ -568,7 +574,7 @@ void scic_cb_remote_device_stop_complete(
  *    the callback.
  *
  */
-void scic_cb_remote_device_ready(
+void isci_event_remote_device_ready(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device)
 {
@@ -583,7 +589,7 @@ void scic_cb_remote_device_ready(
 }
 
 /**
- * scic_cb_remote_device_not_ready() - This user callback method will inform
+ * isci_event_remote_device_not_ready() - This user callback method will inform
  *    the user that a remote device is no longer capable of handling IO
  *    requests (until a ready callback is invoked).
  * @controller: This parameter specifies the core controller associated with
@@ -594,7 +600,7 @@ void scic_cb_remote_device_ready(
  *    going to a not ready state.
  *
  */
-void scic_cb_remote_device_not_ready(
+void isci_event_remote_device_not_ready(
 	struct scic_sds_controller *controller,
 	struct scic_sds_remote_device *remote_device,
 	u32 reason_code)
diff --git a/drivers/scsi/isci/events.h b/drivers/scsi/isci/events.h
new file mode 100644
index 0000000..98526e9
--- /dev/null
+++ b/drivers/scsi/isci/events.h
@@ -0,0 +1,370 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ISCI_EVENT_H_
+#define _ISCI_EVENT_H_
+
+/**
+ * isci_event_timer_create() - This callback method asks the user to create a
+ *    timer and provide a handle for this timer for use in further timer
+ *    interactions.
+ * @controller: This parameter specifies the controller with which this timer
+ *    is to be associated.
+ * @timer_callback: This parameter specifies the callback method to be invoked
+ *    whenever the timer expires.
+ * @cookie: This parameter specifies a piece of information that the user must
+ *    retain.  This cookie is to be supplied by the user anytime a timeout
+ *    occurs for the created timer.
+ *
+ * The "timer_callback" method should be executed in a mutually exlusive manner
+ * from the controller completion handler handler. This method returns a handle
+ * to a timer object created by the user.  The handle will be utilized for all
+ * further interactions relating to this timer.
+ */
+void *isci_event_timer_create(
+	struct scic_sds_controller *controller,
+	void (*timer_callback)(void *),
+	void *cookie);
+
+/**
+ * isci_event_timer_start() - This callback method asks the user to start the
+ *    supplied timer.
+ * @controller: This parameter specifies the controller with which this timer
+ *    is to associated.
+ * @timer: This parameter specifies the timer to be started.
+ * @milliseconds: This parameter specifies the number of milliseconds for which
+ *    to stall.  The operating system driver is allowed to round this value up
+ *    where necessary.
+ *
+ * All timers in the system started by the SCI Core are one shot timers.
+ * Therefore, the SCI user should make sure that it removes the timer from it's
+ * list when a timer actually fires. Additionally, SCI Core user's should be
+ * able to handle calls from the SCI Core to stop a timer that may already be
+ * stopped. none
+ */
+void isci_event_timer_start(
+	struct scic_sds_controller *controller,
+	void *timer,
+	u32 milliseconds);
+
+/**
+ * isci_event_timer_stop() - This callback method asks the user to stop the
+ *    supplied timer.
+ * @controller: This parameter specifies the controller with which this timer
+ *    is to associated.
+ * @timer: This parameter specifies the timer to be stopped.
+ *
+ */
+void isci_event_timer_stop(
+	struct scic_sds_controller *controller,
+	void *timer);
+
+/**
+ * isci_event_controller_start_complete() - This user callback will inform the
+ *    user that the controller has finished the start process.
+ * @controller: This parameter specifies the controller that was started.
+ * @completion_status: This parameter specifies the results of the start
+ *    operation.  SCI_SUCCESS indicates successful completion.
+ *
+ */
+void isci_event_controller_start_complete(
+	struct scic_sds_controller *controller,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_controller_stop_complete() - This user callback will inform the
+ * user that the controller has finished the stop process.
+ * @controller: This parameter specifies the controller that was stopped.
+ * @completion_status: This parameter specifies the results of the stop
+ *    operation.  SCI_SUCCESS indicates successful completion.
+ *
+ */
+void isci_event_controller_stop_complete(
+	struct scic_sds_controller *controller,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_io_request_complete() - This user callback will inform the user
+ * that an IO request has completed.
+ * @controller: This parameter specifies the controller on which the IO is
+ *    completing.
+ * @remote_device: This parameter specifies the remote device on which this IO
+ *    request is completing.
+ * @io_request: This parameter specifies the IO request that has completed.
+ * @completion_status: This parameter specifies the results of the IO request
+ *    operation.  SCI_SUCCESS indicates successful completion.
+ *
+ */
+void isci_event_io_request_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *scic_io_request,
+	enum sci_io_status completion_status);
+
+/**
+ * isci_event_task_request_complete() - This user callback will inform the user
+ *    that a task management request completed.
+ * @controller: This parameter specifies the controller on which the task
+ *    management request is completing.
+ * @remote_device: This parameter specifies the remote device on which this
+ *    task management request is completing.
+ * @task_request: This parameter specifies the task management request that has
+ *    completed.
+ * @completion_status: This parameter specifies the results of the IO request
+ *    operation.  SCI_SUCCESS indicates successful completion.
+ *
+ */
+void isci_event_task_request_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *scic_task_request,
+	enum sci_task_status completion_status);
+
+/**
+ * isci_event_port_stop_complete() - This method informs the user when a stop
+ *    operation on the port has completed.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @completion_status: This parameter specifies the status for the operation
+ *    being completed.
+ *
+ */
+void isci_event_port_stop_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_port_hard_reset_complete() - This method informs the user when a
+ *    hard reset on the port has completed.  This hard reset could have been
+ *    initiated by the user or by the remote port.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @completion_status: This parameter specifies the status for the operation
+ *    being completed.
+ *
+ */
+void isci_event_port_hard_reset_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_port_ready() - This method informs the user that the port is now
+ * in a ready state and can be utilized to issue IOs.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ *
+ */
+void isci_event_port_ready(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port);
+
+/**
+ * isci_event_port_not_ready() - This method informs the user that the port is
+ * now not in a ready (i.e. busy) state and can't be utilized to issue IOs.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @reason_code: This parameter specifies the reason for the port not ready
+ *    callback.
+ *
+ */
+void isci_event_port_not_ready(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	u32 reason_code);
+
+/**
+ * isci_event_port_invalid_link_up() - This method informs the SCI Core user
+ * that a phy/link became ready, but the phy is not allowed in the port.  In
+ * some situations the underlying hardware only allows for certain phy to port
+ *    mappings.  If these mappings are violated, then this API is invoked.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @phy: This parameter specifies the phy that came ready, but the phy can't be
+ *    a valid member of the port.
+ *
+ */
+void isci_event_port_invalid_link_up(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy);
+
+/**
+ * isci_event_port_bc_change_primitive_received() - This callback method informs
+ *    the user that a broadcast change primitive was received.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.  For instances where the phy on which the primitive was
+ *    received is not part of a port, this parameter will be
+ *    NULL.
+ * @phy: This parameter specifies the phy on which the primitive was received.
+ *
+ */
+void isci_event_port_bc_change_primitive_received(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy);
+
+/**
+ * isci_event_port_link_up() - This callback method informs the user that a phy
+ *    has become operational and is capable of communicating with the remote
+ *    end point.
+ * @controller: This parameter represents the controller associated with the
+ *    phy.
+ * @port: This parameter specifies the port object for which the user callback
+ *    is being invoked.  There may be conditions where this parameter can be
+ *    NULL
+ * @phy: This parameter specifies the phy object for which the user callback is
+ *    being invoked.
+ *
+ */
+void isci_event_port_link_up(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy);
+
+/**
+ * isci_event_port_link_down() - This callback method informs the user that a
+ * phy is no longer operational and is not capable of communicating with the
+ *    remote end point.
+ * @controller: This parameter represents the controller associated with the
+ *    phy.
+ * @port: This parameter specifies the port object for which the user callback
+ *    is being invoked.  There may be conditions where this parameter can be
+ *    NULL
+ * @phy: This parameter specifies the phy object for which the user callback is
+ *    being invoked.
+ *
+ */
+void isci_event_port_link_down(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy);
+
+/**
+ * isci_event_remote_device_start_complete() - This user callback method will
+ *    inform the user that a start operation has completed.
+ * @controller: This parameter specifies the core controller associated with
+ *    the completion callback.
+ * @remote_device: This parameter specifies the remote device associated with
+ *    the completion callback.
+ * @completion_status: This parameter specifies the completion status for the
+ *    operation.
+ *
+ */
+void isci_event_remote_device_start_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_remote_device_stop_complete() - This user callback method will
+ *    inform the user that a stop operation has completed.
+ * @controller: This parameter specifies the core controller associated with
+ *    the completion callback.
+ * @remote_device: This parameter specifies the remote device associated with
+ *    the completion callback.
+ * @completion_status: This parameter specifies the completion status for the
+ *    operation.
+ *
+ */
+void isci_event_remote_device_stop_complete(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device,
+	enum sci_status completion_status);
+
+/**
+ * isci_event_remote_device_ready() - This user callback method will inform the
+ *    user that a remote device is now capable of handling IO requests.
+ * @controller: This parameter specifies the core controller associated with
+ *    the completion callback.
+ * @remote_device: This parameter specifies the remote device associated with
+ *    the callback.
+ *
+ */
+void isci_event_remote_device_ready(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device);
+
+/**
+ * isci_event_remote_device_not_ready() - This user callback method will inform
+ *    the user that a remote device is no longer capable of handling IO
+ *    requests (until a ready callback is invoked).
+ * @controller: This parameter specifies the core controller associated with
+ *    the completion callback.
+ * @remote_device: This parameter specifies the remote device associated with
+ *    the callback.
+ * @reason_code: This paramete specifies the reason the remote device is not
+ *    ready.
+ *
+ */
+void isci_event_remote_device_not_ready(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *remote_device,
+	u32 reason_code);
+
+#endif
diff --git a/drivers/scsi/isci/isci.h b/drivers/scsi/isci/isci.h
index 225764f..9ec91f8 100644
--- a/drivers/scsi/isci/isci.h
+++ b/drivers/scsi/isci/isci.h
@@ -85,6 +85,7 @@
 #include "timers.h"
 #include "sci_status.h"
 #include "request.h"
+#include "events.h"
 
 extern struct kmem_cache *isci_kmem_cache;
 extern struct isci_firmware *isci_firmware;
-- 
1.7.0

