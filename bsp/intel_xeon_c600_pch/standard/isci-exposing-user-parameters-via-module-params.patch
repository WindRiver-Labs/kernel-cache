From 26fcc03330571c0fdb040e1c71865dee22a314e6 Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Wed, 16 Mar 2011 14:57:23 -0700
Subject: [PATCH 077/474] isci: exposing user parameters via module params

upstream: b5f18a201ed82ed3776c9950646689b93713ae57

Exposing the user config parameters through the kernel module parameters.
The kernel module params will have the default values set and we will no
longer pulling the default values for user params from the core.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/scsi/isci/core/scic_sds_controller.c |   73 +++++++++++++------------
 drivers/scsi/isci/host.c                     |   28 ++++++++++-
 drivers/scsi/isci/init.c                     |   30 ++++++++++-
 drivers/scsi/isci/isci.h                     |    8 +++
 4 files changed, 102 insertions(+), 37 deletions(-)

diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index b0edd84..cd31cba 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -2548,41 +2548,46 @@ enum sci_status scic_user_parameters_set(
 	struct scic_sds_controller *scic,
 	union scic_user_parameters *scic_parms)
 {
-	if (
-		(scic->parent.state_machine.current_state_id
-		 == SCI_BASE_CONTROLLER_STATE_RESET)
-		|| (scic->parent.state_machine.current_state_id
-		    == SCI_BASE_CONTROLLER_STATE_INITIALIZING)
-		|| (scic->parent.state_machine.current_state_id
-		    == SCI_BASE_CONTROLLER_STATE_INITIALIZED)
-		) {
+	u32 state = scic->parent.state_machine.current_state_id;
+
+	if (state == SCI_BASE_CONTROLLER_STATE_RESET ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZING ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
 		u16 index;
 
 		/*
 		 * Validate the user parameters.  If they are not legal, then
-		 * return a failure. */
+		 * return a failure.
+		 */
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			if (!(scic_parms->sds1.phys[index].max_speed_generation
-			     <= SCIC_SDS_PARM_MAX_SPEED
-			     && scic_parms->sds1.phys[index].max_speed_generation
-			     > SCIC_SDS_PARM_NO_SPEED))
+			struct sci_phy_user_params *user_phy;
+
+			user_phy = &scic_parms->sds1.phys[index];
+
+			if (!((user_phy->max_speed_generation <=
+						SCIC_SDS_PARM_MAX_SPEED) &&
+			      (user_phy->max_speed_generation >
+						SCIC_SDS_PARM_NO_SPEED)))
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
-			if (scic_parms->sds1.phys[index].in_connection_align_insertion_frequency < 3)
+			if (user_phy->in_connection_align_insertion_frequency <
+					3)
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-			if (
-			    (scic_parms->sds1.phys[index].in_connection_align_insertion_frequency < 3) ||
-			    (scic_parms->sds1.phys[index].align_insertion_frequency == 0) ||
-			    (scic_parms->sds1.phys[index].notify_enable_spin_up_insertion_frequency == 0)
-			    )
+
+			if ((user_phy->in_connection_align_insertion_frequency <
+						3) ||
+			    (user_phy->align_insertion_frequency == 0) ||
+			    (user_phy->
+				notify_enable_spin_up_insertion_frequency ==
+						0))
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 		}
 
 		if ((scic_parms->sds1.stp_inactivity_timeout == 0) ||
-		   (scic_parms->sds1.ssp_inactivity_timeout == 0) ||
-		   (scic_parms->sds1.stp_max_occupancy_timeout == 0) ||
-		   (scic_parms->sds1.ssp_max_occupancy_timeout == 0) ||
-		   (scic_parms->sds1.no_outbound_task_timeout == 0))
+		    (scic_parms->sds1.ssp_inactivity_timeout == 0) ||
+		    (scic_parms->sds1.stp_max_occupancy_timeout == 0) ||
+		    (scic_parms->sds1.ssp_max_occupancy_timeout == 0) ||
+		    (scic_parms->sds1.no_outbound_task_timeout == 0))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
 		memcpy(&scic->user_parameters, scic_parms, sizeof(*scic_parms));
@@ -2620,36 +2625,34 @@ enum sci_status scic_oem_parameters_set(
 		 * Validate the oem parameters.  If they are not legal, then
 		 * return a failure. */
 		for (index = 0; index < SCI_MAX_PORTS; index++) {
-			if (scic_parms->sds1.ports[index].phy_mask > SCIC_SDS_PARM_PHY_MASK_MAX) {
+			if (scic_parms->sds1.ports[index].phy_mask > SCIC_SDS_PARM_PHY_MASK_MAX)
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-			}
 		}
 
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			if (
-				scic_parms->sds1.phys[index].sas_address.high == 0
-				&& scic_parms->sds1.phys[index].sas_address.low  == 0
-				) {
+			if ((scic_parms->sds1.phys[index].sas_address.high == 0) &&
+			    (scic_parms->sds1.phys[index].sas_address.low == 0))
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-			}
 		}
 
-		if (scic_parms->sds1.controller.mode_type == SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE) {
+		if (scic_parms->sds1.controller.mode_type ==
+				SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE) {
 			for (index = 0; index < SCI_MAX_PHYS; index++) {
 				if (scic_parms->sds1.ports[index].phy_mask != 0)
 					return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 			}
-		} else if (scic_parms->sds1.controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
+		} else if (scic_parms->sds1.controller.mode_type ==
+				SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
 			for (index = 0; index < SCI_MAX_PHYS; index++)
 				combined_phy_mask |= scic_parms->sds1.ports[index].phy_mask;
 
 			if (combined_phy_mask == 0)
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-		} else {
+		} else
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-		}
 
-		if (scic_parms->sds1.controller.max_concurrent_dev_spin_up > MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT)
+		if (scic_parms->sds1.controller.max_concurrent_dev_spin_up >
+				MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT)
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
 		scic->oem_parameters.sds1 = scic_parms->sds1;
diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d6e2a73..79515be 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -413,6 +413,32 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
 }
 
+static void isci_user_parameters_get(
+		struct isci_host *isci_host,
+		union scic_user_parameters *scic_user_params)
+{
+	struct scic_sds_user_parameters *u = &scic_user_params->sds1;
+	int i;
+
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		struct sci_phy_user_params *u_phy = &u->phys[i];
+
+		u_phy->max_speed_generation = phy_gen;
+
+		/* we are not exporting these for now */
+		u_phy->align_insertion_frequency = 0x7f;
+		u_phy->in_connection_align_insertion_frequency = 0xff;
+		u_phy->notify_enable_spin_up_insertion_frequency = 0x33;
+	}
+
+	u->stp_inactivity_timeout = stp_inactive_to;
+	u->ssp_inactivity_timeout = ssp_inactive_to;
+	u->stp_max_occupancy_timeout = stp_max_occ_to;
+	u->ssp_max_occupancy_timeout = ssp_max_occ_to;
+	u->no_outbound_task_timeout = no_outbound_task_to;
+	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
+}
+
 int isci_host_init(struct isci_host *isci_host)
 {
 	int err = 0, i;
@@ -462,7 +488,7 @@ int isci_host_init(struct isci_host *isci_host)
 	 * grab initial values stored in the controller object for OEM and USER
 	 * parameters
 	 */
-	scic_user_parameters_get(controller, &scic_user_params);
+	isci_user_parameters_get(isci_host, &scic_user_params);
 	status = scic_user_parameters_set(isci_host->core_controller,
 					  &scic_user_params);
 	if (status != SCI_SUCCESS) {
diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
index 51a7bce..1b04b9c 100644
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@ -110,9 +110,37 @@ int isci_si_rev = ISCI_SI_REVA2;
 #else
 int isci_si_rev = ISCI_SI_REVB0;
 #endif
-module_param(isci_si_rev, int, S_IRUGO | S_IWUSR);
+module_param(isci_si_rev, int, 0);
 MODULE_PARM_DESC(isci_si_rev, "override default si rev (0: A0 1: A2 2: B0)");
 
+unsigned char no_outbound_task_to = 20;
+module_param(no_outbound_task_to, byte, 0);
+MODULE_PARM_DESC(no_outbound_task_to, "No Outbound Task Timeout (1us incr)");
+
+u16 ssp_max_occ_to = 20;
+module_param(ssp_max_occ_to, ushort, 0);
+MODULE_PARM_DESC(ssp_max_occ_to, "SSP Max occupancy timeout (100us incr)");
+
+u16 stp_max_occ_to = 5;
+module_param(stp_max_occ_to, ushort, 0);
+MODULE_PARM_DESC(stp_max_occ_to, "STP Max occupancy timeout (100us incr)");
+
+u16 ssp_inactive_to = 5;
+module_param(ssp_inactive_to, ushort, 0);
+MODULE_PARM_DESC(ssp_inactive_to, "SSP inactivity timeout (100us incr)");
+
+u16 stp_inactive_to = 5;
+module_param(stp_inactive_to, ushort, 0);
+MODULE_PARM_DESC(stp_inactive_to, "STP inactivity timeout (100us incr)");
+
+unsigned char phy_gen = 3;
+module_param(phy_gen, byte, 0);
+MODULE_PARM_DESC(phy_gen, "PHY generation (1: 1.5Gbps 2: 3.0Gbps 3: 6.0Gbps)");
+
+unsigned char max_concurr_spinup = 1;
+module_param(max_concurr_spinup, byte, 0);
+MODULE_PARM_DESC(max_concurr_spinup, "Max concurrent device spinup");
+
 static struct scsi_host_template isci_sht = {
 
 	.module				= THIS_MODULE,
diff --git a/drivers/scsi/isci/isci.h b/drivers/scsi/isci/isci.h
index 83422d4..a2df59c 100644
--- a/drivers/scsi/isci/isci.h
+++ b/drivers/scsi/isci/isci.h
@@ -75,6 +75,14 @@
 #include "task.h"
 #include "sata.h"
 
+extern unsigned char no_outbound_task_to;
+extern u16 ssp_max_occ_to;
+extern u16 stp_max_occ_to;
+extern u16 ssp_inactive_to;
+extern u16 stp_inactive_to;
+extern unsigned char phy_gen;
+extern unsigned char max_concurr_spinup;
+
 irqreturn_t isci_msix_isr(int vec, void *data);
 irqreturn_t isci_intx_isr(int vec, void *data);
 irqreturn_t isci_error_isr(int vec, void *data);
-- 
1.7.0

