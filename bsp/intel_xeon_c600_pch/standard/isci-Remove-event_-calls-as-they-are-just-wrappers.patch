From 96fed881a17f4b59ab0a9bb6b85f4a46c7efc71e Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Sat, 26 Mar 2011 16:11:51 -0700
Subject: [PATCH 080/474] isci: Remove event_* calls as they are just wrappers

upstream: 09d7da135b34bc74a7996b5db373521557ddf3d4

Removed isci_event_* calls and call those functions directly.

Reported-by: Christoph Hellwig <hch@infradead.org>
Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/scsi/isci/Makefile                         |    2 +-
 drivers/scsi/isci/core/scic_sds_controller.c       |  400 ++++++-------
 drivers/scsi/isci/core/scic_sds_controller.h       |    3 +-
 drivers/scsi/isci/core/scic_sds_phy.c              |  203 ++++----
 drivers/scsi/isci/core/scic_sds_port.c             |  444 +++++++--------
 .../isci/core/scic_sds_port_configuration_agent.c  |   97 ++--
 drivers/scsi/isci/core/scic_sds_remote_device.c    |  142 +++---
 drivers/scsi/isci/core/scic_sds_request.c          |   36 +-
 .../scsi/isci/core/scic_sds_smp_remote_device.c    |   42 +-
 .../scsi/isci/core/scic_sds_stp_remote_device.c    |   74 +--
 drivers/scsi/isci/events.c                         |  609 --------------------
 drivers/scsi/isci/events.h                         |  373 ------------
 drivers/scsi/isci/isci.h                           |    1 -
 drivers/scsi/isci/port.c                           |   51 ++-
 drivers/scsi/isci/port.h                           |   10 +
 15 files changed, 735 insertions(+), 1752 deletions(-)
 delete mode 100644 drivers/scsi/isci/events.c
 delete mode 100644 drivers/scsi/isci/events.h

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index 1252d76..a65c0ae 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -9,7 +9,7 @@ EXTRA_CFLAGS += -Idrivers/scsi/isci/core/ -Idrivers/scsi/isci/
 obj-$(CONFIG_SCSI_ISCI) += isci.o
 isci-objs := init.o phy.o request.o sata.o \
 	     remote_device.o port.o timers.o \
-	     host.o task.o events.o probe_roms.o \
+	     host.o task.o probe_roms.o \
 	     core/scic_sds_controller.o  \
 	     core/scic_sds_remote_device.o    \
 	     core/scic_sds_request.o \
diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index cd31cba..eaaa4cc 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -253,19 +253,19 @@ static void scic_sds_controller_phy_startup_timeout_handler(
  * This method initializes the phy startup operations for controller start.
  */
 enum sci_status scic_sds_controller_initialize_phy_startup(
-	struct scic_sds_controller *this_controller)
+		struct scic_sds_controller *scic)
 {
-	this_controller->phy_startup_timer = isci_event_timer_create(
-		this_controller,
-		scic_sds_controller_phy_startup_timeout_handler,
-		this_controller
-		);
+	struct isci_host *ihost = sci_object_get_association(scic);
 
-	if (this_controller->phy_startup_timer == NULL) {
+	scic->phy_startup_timer = isci_timer_create(ihost,
+						    scic,
+						    scic_sds_controller_phy_startup_timeout_handler);
+
+	if (scic->phy_startup_timer == NULL)
 		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
-	} else {
-		this_controller->next_phy_to_start = 0;
-		this_controller->phy_startup_timer_pending = false;
+	else {
+		scic->next_phy_to_start = 0;
+		scic->phy_startup_timer_pending = false;
 	}
 
 	return SCI_SUCCESS;
@@ -278,22 +278,20 @@ enum sci_status scic_sds_controller_initialize_phy_startup(
  * object.
  */
 void scic_sds_controller_initialize_power_control(
-	struct scic_sds_controller *this_controller)
+		struct scic_sds_controller *scic)
 {
-	this_controller->power_control.timer = isci_event_timer_create(
-		this_controller,
-		scic_sds_controller_power_control_timer_handler,
-		this_controller
-		);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	scic->power_control.timer = isci_timer_create(
+			ihost,
+			scic,
+			scic_sds_controller_power_control_timer_handler);
 
-	memset(
-		this_controller->power_control.requesters,
-		0,
-		sizeof(this_controller->power_control.requesters)
-		);
+	memset(scic->power_control.requesters,
+	       0,
+	       sizeof(scic->power_control.requesters));
 
-	this_controller->power_control.phys_waiting = 0;
-	this_controller->power_control.phys_granted_power = 0;
+	scic->power_control.phys_waiting = 0;
+	scic->power_control.phys_granted_power = 0;
 }
 
 /* --------------------------------------------------------------------------- */
@@ -730,30 +728,29 @@ void scic_sds_controller_afe_initialization(struct scic_sds_controller *scic)
  * none.
  */
 static void scic_sds_controller_transition_to_ready(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	enum sci_status status)
 {
-	if (this_controller->parent.state_machine.current_state_id
-	    == SCI_BASE_CONTROLLER_STATE_STARTING) {
+	struct isci_host *ihost = sci_object_get_association(scic);
+
+	if (scic->parent.state_machine.current_state_id ==
+			SCI_BASE_CONTROLLER_STATE_STARTING) {
 		/*
 		 * We move into the ready state, because some of the phys/ports
-		 * may be up and operational. */
+		 * may be up and operational.
+		 */
 		sci_base_state_machine_change_state(
-			scic_sds_controller_get_base_state_machine(this_controller),
-			SCI_BASE_CONTROLLER_STATE_READY
-			);
+			scic_sds_controller_get_base_state_machine(scic),
+			SCI_BASE_CONTROLLER_STATE_READY);
 
-		isci_event_controller_start_complete(this_controller, status);
+		isci_host_start_complete(ihost, status);
 	}
 }
 
-/**
- * This method is the general timeout handler for the controller. It will take
- *    the correct timetout action based on the current controller state
- */
-void scic_sds_controller_timeout_handler(
-	struct scic_sds_controller *scic)
+void scic_sds_controller_timeout_handler(void *_scic)
 {
+	struct scic_sds_controller *scic = _scic;
+	struct isci_host *ihost = sci_object_get_association(scic);
 	enum sci_base_controller_states current_state;
 
 	current_state = sci_base_state_machine_get_state(
@@ -766,7 +763,7 @@ void scic_sds_controller_timeout_handler(
 		sci_base_state_machine_change_state(
 			scic_sds_controller_get_base_state_machine(scic),
 			SCI_BASE_CONTROLLER_STATE_FAILED);
-		isci_event_controller_stop_complete(scic, SCI_FAILURE_TIMEOUT);
+		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
 	} else	/* / @todo Now what do we want to do in this case? */
 		dev_err(scic_to_dev(scic),
 			"%s: Controller timer fired when controller was not "
@@ -803,37 +800,21 @@ enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller *scic)
 	return status;
 }
 
-/**
- *
- *
- *
- */
-static void scic_sds_controller_phy_timer_start(
-	struct scic_sds_controller *this_controller)
+static inline void scic_sds_controller_phy_timer_start(
+		struct scic_sds_controller *scic)
 {
-	isci_event_timer_start(
-		this_controller,
-		this_controller->phy_startup_timer,
-		SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
-		);
+	isci_timer_start(scic->phy_startup_timer,
+			 SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT);
 
-	this_controller->phy_startup_timer_pending = true;
+	scic->phy_startup_timer_pending = true;
 }
 
-/**
- *
- *
- *
- */
-void scic_sds_controller_phy_timer_stop(
-	struct scic_sds_controller *this_controller)
+inline void scic_sds_controller_phy_timer_stop(
+		struct scic_sds_controller *scic)
 {
-	isci_event_timer_stop(
-		this_controller,
-		this_controller->phy_startup_timer
-		);
+	isci_timer_stop(scic->phy_startup_timer);
 
-	this_controller->phy_startup_timer_pending = false;
+	scic->phy_startup_timer_pending = false;
 }
 
 /**
@@ -1009,19 +990,17 @@ enum sci_status scic_sds_controller_stop_devices(
  * ****************************************************************************- */
 
 /**
+ * This function starts the power control timer for this controller object.
  *
- *
- * This method starts the power control timer for this controller object.
+ * @param scic
  */
-static void scic_sds_controller_power_control_timer_start(
-	struct scic_sds_controller *this_controller)
+static inline void scic_sds_controller_power_control_timer_start(
+	struct scic_sds_controller *scic)
 {
-	isci_event_timer_start(
-		this_controller, this_controller->power_control.timer,
-		SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL
-		);
+	isci_timer_start(scic->power_control.timer,
+			 SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
 
-	this_controller->power_control.timer_started = true;
+	scic->power_control.timer_started = true;
 }
 
 /**
@@ -1029,20 +1008,22 @@ static void scic_sds_controller_power_control_timer_start(
  *
  * @param scic
  */
-void scic_sds_controller_power_control_timer_stop(struct scic_sds_controller *scic)
+static inline void scic_sds_controller_power_control_timer_stop(
+		struct scic_sds_controller *scic)
 {
 	if (scic->power_control.timer_started) {
-		isci_event_timer_stop(scic, scic->power_control.timer);
+		isci_timer_stop(scic->power_control.timer);
 		scic->power_control.timer_started = false;
 	}
 }
 
 /**
- * This method stops and starts the power control timer for this controller object.
+ * This method stops and starts the power control timer for this controller
+ * object.
  *
  * @param scic
  */
-void scic_sds_controller_power_control_timer_restart(
+static inline void scic_sds_controller_power_control_timer_restart(
 	struct scic_sds_controller *scic)
 {
 	scic_sds_controller_power_control_timer_stop(scic);
@@ -2893,51 +2874,41 @@ static enum sci_status scic_sds_controller_general_reset_handler(
  * * RESET STATE HANDLERS
  * ***************************************************************************** */
 
-/**
- *
- * @controller: This is the struct sci_base_controller object which is cast into a
- *    struct scic_sds_controller object.
- *
- * This method is the struct scic_sds_controller initialize handler for the reset
- * state. - Currently this function does nothing enum sci_status SCI_FAILURE This
- * function is not yet implemented and is a valid request from the reset state.
- */
-static enum sci_status scic_sds_controller_reset_state_initialize_handler(
-	struct sci_base_controller *controller)
+static enum sci_status scic_sds_controller_reset_state_initialize_handler(struct sci_base_controller *base_scic)
 {
-	u32 index;
 	enum sci_status result = SCI_SUCCESS;
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
+	struct isci_host *ihost;
+	u32 index;
 
-	this_controller = (struct scic_sds_controller *)controller;
+	scic = container_of(base_scic, typeof(*scic), parent);
+	ihost = sci_object_get_association(scic);
 
 	sci_base_state_machine_change_state(
-		scic_sds_controller_get_base_state_machine(this_controller),
-		SCI_BASE_CONTROLLER_STATE_INITIALIZING
-		);
+		scic_sds_controller_get_base_state_machine(scic),
+		SCI_BASE_CONTROLLER_STATE_INITIALIZING);
 
-	this_controller->timeout_timer = isci_event_timer_create(
-		this_controller,
-		(void (*)(void *))scic_sds_controller_timeout_handler,
-		(void (*)(void *))controller);
+	scic->timeout_timer = isci_timer_create(ihost,
+						scic,
+						scic_sds_controller_timeout_handler);
 
-	scic_sds_controller_initialize_phy_startup(this_controller);
+	scic_sds_controller_initialize_phy_startup(scic);
 
-	scic_sds_controller_initialize_power_control(this_controller);
+	scic_sds_controller_initialize_power_control(scic);
 
 	/*
 	 * There is nothing to do here for B0 since we do not have to
 	 * program the AFE registers.
 	 * / @todo The AFE settings are supposed to be correct for the B0 but
 	 * /       presently they seem to be wrong. */
-	scic_sds_controller_afe_initialization(this_controller);
+	scic_sds_controller_afe_initialization(scic);
 
-	if (SCI_SUCCESS == result) {
+	if (result == SCI_SUCCESS) {
 		u32 status;
 		u32 terminate_loop;
 
 		/* Take the hardware out of reset */
-		SMU_SMUSRCR_WRITE(this_controller, 0x00000000);
+		SMU_SMUSRCR_WRITE(scic, 0x00000000);
 
 		/*
 		 * / @todo Provide meaningfull error code for hardware failure
@@ -2948,11 +2919,11 @@ static enum sci_status scic_sds_controller_reset_state_initialize_handler(
 		while (terminate_loop-- && (result != SCI_SUCCESS)) {
 			/* Loop until the hardware reports success */
 			udelay(SCU_CONTEXT_RAM_INIT_STALL_TIME);
-			status = SMU_SMUCSR_READ(this_controller);
+			status = SMU_SMUCSR_READ(scic);
 
-			if ((status & SCU_RAM_INIT_COMPLETED) == SCU_RAM_INIT_COMPLETED) {
+			if ((status & SCU_RAM_INIT_COMPLETED) ==
+					SCU_RAM_INIT_COMPLETED)
 				result = SCI_SUCCESS;
-			}
 		}
 	}
 
@@ -2965,39 +2936,42 @@ static enum sci_status scic_sds_controller_reset_state_initialize_handler(
 		/*
 		 * Determine what are the actaul device capacities that the
 		 * hardware will support */
-		device_context_capacity = SMU_DCC_READ(this_controller);
+		device_context_capacity = SMU_DCC_READ(scic);
 
-		max_supported_ports =
-			smu_dcc_get_max_ports(device_context_capacity);
-		max_supported_devices =
-			smu_dcc_get_max_remote_node_context(device_context_capacity);
-		max_supported_io_requests =
-			smu_dcc_get_max_task_context(device_context_capacity);
+		max_supported_ports = smu_dcc_get_max_ports(device_context_capacity);
+		max_supported_devices = smu_dcc_get_max_remote_node_context(device_context_capacity);
+		max_supported_io_requests = smu_dcc_get_max_task_context(device_context_capacity);
 
-		/* Make all PEs that are unassigned match up with the logical ports */
+		/*
+		 * Make all PEs that are unassigned match up with the
+		 * logical ports
+		 */
 		for (index = 0; index < max_supported_ports; index++) {
-			scu_register_write(
-				this_controller,
-				this_controller->scu_registers->peg0.ptsg.protocol_engine[index],
-				index
-				);
+			struct scu_port_task_scheduler_group_registers *ptsg =
+				&scic->scu_registers->peg0.ptsg;
+
+			scu_register_write(scic,
+					   ptsg->protocol_engine[index],
+					   index);
 		}
 
 		/* Record the smaller of the two capacity values */
-		this_controller->logical_port_entries =
-			min(max_supported_ports, this_controller->logical_port_entries);
+		scic->logical_port_entries =
+			min(max_supported_ports, scic->logical_port_entries);
 
-		this_controller->task_context_entries =
-			min(max_supported_io_requests, this_controller->task_context_entries);
+		scic->task_context_entries =
+			min(max_supported_io_requests,
+			    scic->task_context_entries);
 
-		this_controller->remote_node_entries =
-			min(max_supported_devices, this_controller->remote_node_entries);
+		scic->remote_node_entries =
+			min(max_supported_devices, scic->remote_node_entries);
 
 		/*
 		 * Now that we have the correct hardware reported minimum values
 		 * build the MDL for the controller.  Default to a performance
-		 * configuration. */
-		scic_controller_set_mode(this_controller, SCI_MODE_SPEED);
+		 * configuration.
+		 */
+		scic_controller_set_mode(scic, SCI_MODE_SPEED);
 	}
 
 	/* Initialize hardware PCI Relaxed ordering in DMA engines */
@@ -3005,66 +2979,62 @@ static enum sci_status scic_sds_controller_reset_state_initialize_handler(
 		u32 dma_configuration;
 
 		/* Configure the payload DMA */
-		dma_configuration = SCU_PDMACR_READ(this_controller);
-		dma_configuration |= SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-		SCU_PDMACR_WRITE(this_controller, dma_configuration);
+		dma_configuration = SCU_PDMACR_READ(scic);
+		dma_configuration |=
+			SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+		SCU_PDMACR_WRITE(scic, dma_configuration);
 
 		/* Configure the control DMA */
-		dma_configuration = SCU_CDMACR_READ(this_controller);
-		dma_configuration |= SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-		SCU_CDMACR_WRITE(this_controller, dma_configuration);
+		dma_configuration = SCU_CDMACR_READ(scic);
+		dma_configuration |=
+			SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+		SCU_CDMACR_WRITE(scic, dma_configuration);
 	}
 
 	/*
 	 * Initialize the PHYs before the PORTs because the PHY registers
-	 * are accessed during the port initialization. */
+	 * are accessed during the port initialization.
+	 */
 	if (result == SCI_SUCCESS) {
 		/* Initialize the phys */
 		for (index = 0;
 		     (result == SCI_SUCCESS) && (index < SCI_MAX_PHYS);
 		     index++) {
 			result = scic_sds_phy_initialize(
-				&this_controller->phy_table[index],
-				&this_controller->scu_registers->peg0.pe[index].tl,
-				&this_controller->scu_registers->peg0.pe[index].ll
-				);
+				&scic->phy_table[index],
+				&scic->scu_registers->peg0.pe[index].tl,
+				&scic->scu_registers->peg0.pe[index].ll);
 		}
 	}
 
 	if (result == SCI_SUCCESS) {
 		/* Initialize the logical ports */
 		for (index = 0;
-		     (index < this_controller->logical_port_entries)
-		     && (result == SCI_SUCCESS);
+		     (index < scic->logical_port_entries) &&
+		     (result == SCI_SUCCESS);
 		     index++) {
 			result = scic_sds_port_initialize(
-				&this_controller->port_table[index],
-				&this_controller->scu_registers->peg0.ptsg.port[index],
-				&this_controller->scu_registers->peg0.ptsg.protocol_engine,
-				&this_controller->scu_registers->peg0.viit[index]
-				);
+				&scic->port_table[index],
+				&scic->scu_registers->peg0.ptsg.port[index],
+				&scic->scu_registers->peg0.ptsg.protocol_engine,
+				&scic->scu_registers->peg0.viit[index]);
 		}
 	}
 
-	if (SCI_SUCCESS == result) {
+	if (result == SCI_SUCCESS)
 		result = scic_sds_port_configuration_agent_initialize(
-			this_controller,
-			&this_controller->port_agent
-			);
-	}
+				scic,
+				&scic->port_agent);
 
 	/* Advance the controller state machine */
-	if (result == SCI_SUCCESS) {
+	if (result == SCI_SUCCESS)
 		sci_base_state_machine_change_state(
-			scic_sds_controller_get_base_state_machine(this_controller),
-			SCI_BASE_CONTROLLER_STATE_INITIALIZED
-			);
-	} else {
+			scic_sds_controller_get_base_state_machine(scic),
+			SCI_BASE_CONTROLLER_STATE_INITIALIZED);
+	else
 		sci_base_state_machine_change_state(
-			scic_sds_controller_get_base_state_machine(this_controller),
-			SCI_BASE_CONTROLLER_STATE_FAILED
-			);
-	}
+			scic_sds_controller_get_base_state_machine(scic),
+			SCI_BASE_CONTROLLER_STATE_FAILED);
 
 	return result;
 }
@@ -3076,13 +3046,14 @@ static enum sci_status scic_sds_controller_reset_state_initialize_handler(
 
 /**
  *
- * @controller: This is the struct sci_base_controller object which is cast into a
- *    struct scic_sds_controller object.
+ * @controller: This is the struct sci_base_controller object which is cast
+ * into a struct scic_sds_controller object.
  * @timeout: This is the allowed time for the controller object to reach the
  *    started state.
  *
- * This method is the struct scic_sds_controller start handler for the initialized
- * state. - Validate we have a good memory descriptor table - Initialze the
+ * This function is the struct scic_sds_controller start handler for the
+ * initialized state.
+ * - Validate we have a good memory descriptor table - Initialze the
  * physical memory before programming the hardware - Program the SCU hardware
  * with the physical memory addresses passed in the memory descriptor table. -
  * Initialzie the TCi pool - Initialize the RNi pool - Initialize the
@@ -3099,70 +3070,74 @@ static enum sci_status scic_sds_controller_initialized_state_start_handler(
 {
 	u16 index;
 	enum sci_status result;
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)controller;
+	scic = (struct scic_sds_controller *)controller;
 
-	/* Make sure that the SCI User filled in the memory descriptor table correctly */
-	result = scic_sds_controller_validate_memory_descriptor_table(this_controller);
+	/*
+	 * Make sure that the SCI User filled in the memory descriptor
+	 * table correctly
+	 */
+	result = scic_sds_controller_validate_memory_descriptor_table(scic);
 
 	if (result == SCI_SUCCESS) {
-		/* The memory descriptor list looks good so program the hardware */
-		scic_sds_controller_ram_initialization(this_controller);
+		/*
+		 * The memory descriptor list looks good so program the
+		 * hardware
+		 */
+		scic_sds_controller_ram_initialization(scic);
 	}
 
 	if (result == SCI_SUCCESS) {
 		/* Build the TCi free pool */
-		sci_pool_initialize(this_controller->tci_pool);
-		for (index = 0; index < this_controller->task_context_entries; index++) {
-			sci_pool_put(this_controller->tci_pool, index);
-		}
+		sci_pool_initialize(scic->tci_pool);
+		for (index = 0; index < scic->task_context_entries; index++)
+			sci_pool_put(scic->tci_pool, index);
 
 		/* Build the RNi free pool */
 		scic_sds_remote_node_table_initialize(
-			&this_controller->available_remote_nodes,
-			this_controller->remote_node_entries
-			);
+				&scic->available_remote_nodes,
+				scic->remote_node_entries);
 	}
 
 	if (result == SCI_SUCCESS) {
 		/*
-		 * Before anything else lets make sure we will not be interrupted
-		 * by the hardware. */
-		scic_controller_disable_interrupts(this_controller);
+		 * Before anything else lets make sure we will not be
+		 * interrupted by the hardware.
+		 */
+		scic_controller_disable_interrupts(scic);
 
 		/* Enable the port task scheduler */
-		scic_sds_controller_enable_port_task_scheduler(this_controller);
+		scic_sds_controller_enable_port_task_scheduler(scic);
 
-		/* Assign all the task entries to this controller physical function */
-		scic_sds_controller_assign_task_entries(this_controller);
+		/* Assign all the task entries to scic physical function */
+		scic_sds_controller_assign_task_entries(scic);
 
 		/* Now initialze the completion queue */
-		scic_sds_controller_initialize_completion_queue(this_controller);
+		scic_sds_controller_initialize_completion_queue(scic);
 
 		/* Initialize the unsolicited frame queue for use */
-		scic_sds_controller_initialize_unsolicited_frame_queue(this_controller);
+		scic_sds_controller_initialize_unsolicited_frame_queue(scic);
 	}
 
 	/* Start all of the ports on this controller */
-	for (index = 0; index < this_controller->logical_port_entries &&
-			result == SCI_SUCCESS; index++) {
-		struct scic_sds_port *sci_port = &this_controller->port_table[index];
+	for (index = 0;
+	     (index < scic->logical_port_entries) && (result == SCI_SUCCESS);
+	     index++) {
+		struct scic_sds_port *sci_port = &scic->port_table[index];
 
-		result = sci_port->state_handlers->parent.start_handler(&sci_port->parent);
+		result = sci_port->state_handlers->parent.start_handler(
+				&sci_port->parent);
 	}
 
 	if (result == SCI_SUCCESS) {
-		scic_sds_controller_start_next_phy(this_controller);
+		scic_sds_controller_start_next_phy(scic);
 
-		isci_event_timer_start(this_controller,
-				    this_controller->timeout_timer,
-				    timeout);
+		isci_timer_start(scic->timeout_timer, timeout);
 
 		sci_base_state_machine_change_state(
-			scic_sds_controller_get_base_state_machine(this_controller),
-			SCI_BASE_CONTROLLER_STATE_STARTING
-			);
+			scic_sds_controller_get_base_state_machine(scic),
+			SCI_BASE_CONTROLLER_STATE_STARTING);
 	}
 
 	return result;
@@ -3241,18 +3216,14 @@ static enum sci_status scic_sds_controller_ready_state_stop_handler(
 	struct sci_base_controller *controller,
 	u32 timeout)
 {
-	struct scic_sds_controller *this_controller;
-
-	this_controller = (struct scic_sds_controller *)controller;
+	struct scic_sds_controller *scic =
+		(struct scic_sds_controller *)controller;
 
-	isci_event_timer_start(this_controller,
-			    this_controller->timeout_timer,
-			    timeout);
+	isci_timer_start(scic->timeout_timer, timeout);
 
 	sci_base_state_machine_change_state(
-		scic_sds_controller_get_base_state_machine(this_controller),
-		SCI_BASE_CONTROLLER_STATE_STOPPING
-		);
+		scic_sds_controller_get_base_state_machine(scic),
+		SCI_BASE_CONTROLLER_STATE_STOPPING);
 
 	return SCI_SUCCESS;
 }
@@ -3689,12 +3660,12 @@ static void scic_sds_controller_initial_state_enter(
  * from the SCI_BASE_CONTROLLER_STATE_STARTING. - This function stops the
  * controller starting timeout timer. none
  */
-static void scic_sds_controller_starting_state_exit(
+static inline void scic_sds_controller_starting_state_exit(
 	struct sci_base_object *object)
 {
 	struct scic_sds_controller *scic = (struct scic_sds_controller *)object;
 
-	isci_event_timer_stop(scic, scic->timeout_timer);
+	isci_timer_stop(scic->timeout_timer);
 }
 
 /**
@@ -3762,21 +3733,20 @@ static void scic_sds_controller_stopping_state_enter(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_controller
- *    object.
+ * @object: This is the struct sci_base_object which is cast to a struct
+ * scic_sds_controller object.
  *
- * This method implements the actions taken by the struct scic_sds_controller on exit
- * from the SCI_BASE_CONTROLLER_STATE_STOPPING. - This function stops the
- * controller stopping timeout timer. none
+ * This funciton implements the actions taken by the struct scic_sds_controller
+ * on exit from the SCI_BASE_CONTROLLER_STATE_STOPPING. -
+ * This function stops the controller stopping timeout timer.
  */
-static void scic_sds_controller_stopping_state_exit(
+static inline void scic_sds_controller_stopping_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *this_controller;
-
-	this_controller = (struct scic_sds_controller *)object;
+	struct scic_sds_controller *scic =
+		(struct scic_sds_controller *)object;
 
-	isci_event_timer_stop(this_controller, this_controller->timeout_timer);
+	isci_timer_stop(scic->timeout_timer);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_controller.h b/drivers/scsi/isci/core/scic_sds_controller.h
index 6386a64..f426324 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.h
+++ b/drivers/scsi/isci/core/scic_sds_controller.h
@@ -681,8 +681,7 @@ void scic_sds_controller_copy_task_context(
 	struct scic_sds_controller *this_controller,
 	struct scic_sds_request *this_request);
 
-void scic_sds_controller_timeout_handler(
-	struct scic_sds_controller *controller);
+void scic_sds_controller_timeout_handler(void *controller);
 
 void scic_sds_controller_initialize_power_control(
 	struct scic_sds_controller *this_controller);
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 2717458..225e67a 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -366,18 +366,23 @@ void scic_sds_phy_set_port(
  */
 enum sci_status scic_sds_phy_initialize(
 	struct scic_sds_phy *sci_phy,
-		struct scu_transport_layer_registers __iomem *transport_layer_registers,
-		struct scu_link_layer_registers __iomem *link_layer_registers)
+	struct scu_transport_layer_registers __iomem *transport_layer_registers,
+	struct scu_link_layer_registers __iomem *link_layer_registers)
 {
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct isci_host *ihost = sci_object_get_association(scic);
+
 	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer = isci_event_timer_create(
-		scic_sds_phy_get_controller(sci_phy),
-		scic_sds_phy_sata_timeout,
-		sci_phy
-		);
+	sci_phy->sata_timeout_timer =
+		isci_timer_create(
+			ihost,
+			sci_phy,
+			scic_sds_phy_sata_timeout);
 
 	/* Perfrom the initialization of the TL hardware */
-	scic_sds_phy_transport_layer_initialization(sci_phy, transport_layer_registers);
+	scic_sds_phy_transport_layer_initialization(
+			sci_phy,
+			transport_layer_registers);
 
 	/* Perofrm the initialization of the PE hardware */
 	scic_sds_phy_link_layer_initialization(sci_phy, link_layer_registers);
@@ -387,8 +392,7 @@ enum sci_status scic_sds_phy_initialize(
 	 * transition to the stopped state. */
 	sci_base_state_machine_change_state(
 		scic_sds_phy_get_base_state_machine(sci_phy),
-		SCI_BASE_PHY_STATE_STOPPED
-		);
+		SCI_BASE_PHY_STATE_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -1742,49 +1746,42 @@ static void scic_sds_phy_starting_await_sata_power_substate_exit(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_phy object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on
+ * This function will perform the actions required by the struct scic_sds_phy on
  * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. - Set the
  * struct scic_sds_phy object state handlers for this state. none
  */
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
-
-	this_phy = (struct scic_sds_phy *)object;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN
-		);
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
 
-	isci_event_timer_start(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy->sata_timeout_timer,
-		SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT
-		);
+	isci_timer_start(sci_phy->sata_timeout_timer,
+			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_phy object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * This method will perform the actions required by the struct scic_sds_phy
+ * on exiting
  * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
  * that was started on entry to await sata phy event notification none
  */
-static void scic_sds_phy_starting_await_sata_phy_substate_exit(
+static inline void scic_sds_phy_starting_await_sata_phy_substate_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
 
-	this_phy = (struct scic_sds_phy *)object;
-
-	isci_event_timer_stop(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy->sata_timeout_timer
-		);
+	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
 /**
@@ -1798,104 +1795,92 @@ static void scic_sds_phy_starting_await_sata_phy_substate_exit(
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
-
-	this_phy = (struct scic_sds_phy *)object;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN
-		);
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
 
-	isci_event_timer_start(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy->sata_timeout_timer,
-		SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT
-		);
+	isci_timer_start(sci_phy->sata_timeout_timer,
+			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_phy object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * This function will perform the actions required by the
+ * struct scic_sds_phy on exiting
  * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
  * that was started on entry to await sata phy event notification none
  */
-static void scic_sds_phy_starting_await_sata_speed_substate_exit(
+static inline void scic_sds_phy_starting_await_sata_speed_substate_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
 
-	this_phy = (struct scic_sds_phy *)object;
-
-	isci_event_timer_stop(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy->sata_timeout_timer
-		);
+	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_phy object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on
+ * This function will perform the actions required by the struct scic_sds_phy on
  * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Set the
- * struct scic_sds_phy object state handlers for this state. - Start the SIGNATURE FIS
+ * struct scic_sds_phy object state handlers for this state.
+ * - Start the SIGNATURE FIS
  * timeout timer none
  */
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(
 	struct sci_base_object *object)
 {
 	bool continue_to_ready_state;
-	struct scic_sds_phy *this_phy;
-
-	this_phy = (struct scic_sds_phy *)object;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF
-		);
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
 
 	continue_to_ready_state = scic_sds_port_link_detected(
-		this_phy->owning_port,
-		this_phy
-		);
+		sci_phy->owning_port,
+		sci_phy);
 
 	if (continue_to_ready_state) {
 		/*
-		 * Clear the PE suspend condition so we can actually receive SIG FIS
-		 * The hardware will not respond to the XRDY until the PE suspend
-		 * condition is cleared. */
-		scic_sds_phy_resume(this_phy);
+		 * Clear the PE suspend condition so we can actually
+		 * receive SIG FIS
+		 * The hardware will not respond to the XRDY until the PE
+		 * suspend condition is cleared.
+		 */
+		scic_sds_phy_resume(sci_phy);
 
-		isci_event_timer_start(
-			scic_sds_phy_get_controller(this_phy),
-			this_phy->sata_timeout_timer,
-			SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-			);
-	} else {
-		this_phy->is_in_link_training = false;
-	}
+		isci_timer_start(sci_phy->sata_timeout_timer,
+				 SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
+	} else
+		sci_phy->is_in_link_training = false;
 }
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_phy object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * This function will perform the actions required by the
+ * struct scic_sds_phy on exiting
  * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Stop the SIGNATURE
  * FIS timeout timer. none
  */
-static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(
+static inline void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	isci_event_timer_stop(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy->sata_timeout_timer
-		);
+	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
 /**
@@ -2158,27 +2143,30 @@ enum sci_status scic_sds_phy_default_consume_power_handler(
 
 /**
  *
- * @phy: This is the struct sci_base_phy object which is cast into a struct scic_sds_phy
- *    object.
+ * @phy: This is the struct sci_base_phy object which is cast into a
+ * struct scic_sds_phy object.
  *
- * This method takes the struct scic_sds_phy from a stopped state and attempts to
- * start it. - The phy state machine is transitioned to the
+ * This method takes the struct scic_sds_phy from a stopped state and
+ * attempts to start it. - The phy state machine is transitioned to the
  * SCI_BASE_PHY_STATE_STARTING. enum sci_status SCI_SUCCESS
  */
-static enum sci_status scic_sds_phy_stopped_state_start_handler(struct sci_base_phy *phy)
+static enum sci_status scic_sds_phy_stopped_state_start_handler(
+		struct sci_base_phy *phy)
 {
-	struct scic_sds_phy *this_phy;
-
-	this_phy = (struct scic_sds_phy *)phy;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)phy;
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct isci_host *ihost = sci_object_get_association(scic);
 
 	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	this_phy->sata_timeout_timer = isci_event_timer_create(
-		scic_sds_phy_get_controller(this_phy),
-		scic_sds_phy_sata_timeout, this_phy);
+	sci_phy->sata_timeout_timer =
+		isci_timer_create(
+				ihost,
+				sci_phy,
+				scic_sds_phy_sata_timeout);
 
-	if (this_phy->sata_timeout_timer != NULL) {
+	if (sci_phy->sata_timeout_timer != NULL) {
 		sci_base_state_machine_change_state(
-			scic_sds_phy_get_base_state_machine(this_phy),
+			scic_sds_phy_get_base_state_machine(sci_phy),
 			SCI_BASE_PHY_STATE_STARTING);
 	}
 
@@ -2525,14 +2513,16 @@ static void scic_sds_phy_initial_state_enter(
  * @object: This is the struct sci_base_object which is cast to a
  * struct scic_sds_phy object.
  *
- * This method will perform the actions required by the struct scic_sds_phy on
+ * This function will perform the actions required by the struct scic_sds_phy on
  * entering the SCI_BASE_PHY_STATE_INITIAL. - This function sets the state
  * handlers for the phy object base state machine initial state. - The SCU
  * hardware is requested to stop the protocol engine. none
  */
 static void scic_sds_phy_stopped_state_enter(struct sci_base_object *object)
 {
-	struct scic_sds_phy *sci_phy;
+	struct scic_sds_phy *sci_phy = (struct scic_sds_phy *)object;
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct isci_host *ihost = sci_object_get_association(scic);
 
 	sci_phy = (struct scic_sds_phy *)object;
 
@@ -2541,11 +2531,11 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_object *object)
 	 * reset state
 	 */
 
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_STOPPED);
+	scic_sds_phy_set_base_state_handlers(sci_phy,
+					     SCI_BASE_PHY_STATE_STOPPED);
 
 	if (sci_phy->sata_timeout_timer != NULL) {
-		isci_event_timer_destroy(scic_sds_phy_get_controller(sci_phy),
-					 sci_phy->sata_timeout_timer);
+		isci_del_timer(ihost, sci_phy->sata_timeout_timer);
 
 		sci_phy->sata_timeout_timer = NULL;
 	}
@@ -2554,9 +2544,10 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_object *object)
 
 	if (sci_phy->parent.state_machine.previous_state_id !=
 			SCI_BASE_PHY_STATE_INITIAL)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      scic_sds_phy_get_port(sci_phy),
-					      sci_phy);
+		scic_sds_controller_link_down(
+				scic_sds_phy_get_controller(sci_phy),
+				scic_sds_phy_get_port(sci_phy),
+				sci_phy);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index a41fe42..3ae0f0d 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -738,34 +738,32 @@ void scic_sds_port_setup_transports(
  * @do_notify_user: This parameter specifies whether to inform the user (via
  *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
  *
- * This method will activate the phy in the port. Activation includes: - adding
+ * This function will activate the phy in the port.
+ * Activation includes: - adding
  * the phy to the port - enabling the Protocol Engine in the silicon. -
  * notifying the user that the link is up. none
  */
-void scic_sds_port_activate_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy,
-	bool do_notify_user)
+void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
+				struct scic_sds_phy *sci_phy,
+				bool do_notify_user)
 {
-	struct scic_sds_controller *controller;
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
 	struct sci_sas_identify_address_frame_protocols protocols;
+	struct isci_host *ihost = sci_object_get_association(scic);
 
-	controller = scic_sds_port_get_controller(this_port);
-	scic_sds_phy_get_attached_phy_protocols(the_phy, &protocols);
+	scic_sds_phy_get_attached_phy_protocols(sci_phy, &protocols);
 
 	/* If this is sata port then the phy has already been resumed */
-	if (!protocols.u.bits.stp_target) {
-		scic_sds_phy_resume(the_phy);
-	}
+	if (!protocols.u.bits.stp_target)
+		scic_sds_phy_resume(sci_phy);
 
-	this_port->active_phy_mask |= 1 << the_phy->phy_index;
+	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
 
-	scic_sds_controller_clear_invalid_phy(controller, the_phy);
+	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
 
 	if (do_notify_user == true)
-		isci_event_port_link_up(this_port->owning_controller,
-					this_port,
-					the_phy);
+		isci_port_link_up(ihost, sci_port, sci_phy);
 }
 
 /**
@@ -773,27 +771,30 @@ void scic_sds_port_activate_phy(
  * @this_port: This is the port on which the phy should be deactivated.
  * @the_phy: This is the specific phy that is no longer active in the port.
  * @do_notify_user: This parameter specifies whether to inform the user (via
- *    isci_event_port_link_down()) as to the fact that a new phy as become
+ *    isci_port_link_down()) as to the fact that a new phy as become
  *    ready.
  *
- * This method will deactivate the supplied phy in the port. none
+ * This function will deactivate the supplied phy in the port. none
  */
-void scic_sds_port_deactivate_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy,
-	bool do_notify_user)
+void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
+				  struct scic_sds_phy *sci_phy,
+				  bool do_notify_user)
 {
-	this_port->active_phy_mask &= ~(1 << the_phy->phy_index);
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
+	struct isci_port *iport = sci_object_get_association(sci_port);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_phy *iphy = sci_object_get_association(sci_phy);
+
+	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
 
-	the_phy->max_negotiated_speed = SCI_SAS_NO_LINK_RATE;
+	sci_phy->max_negotiated_speed = SCI_SAS_NO_LINK_RATE;
 
 	/* Re-assign the phy back to the LP as if it were a narrow port */
-	SCU_PCSPExCR_WRITE(this_port, the_phy->phy_index, the_phy->phy_index);
+	SCU_PCSPExCR_WRITE(sci_port, sci_phy->phy_index, sci_phy->phy_index);
 
 	if (do_notify_user == true)
-		isci_event_port_link_down(this_port->owning_controller,
-					  this_port,
-					  the_phy);
+		isci_port_link_down(ihost, iphy, iport);
 }
 
 /**
@@ -801,22 +802,24 @@ void scic_sds_port_deactivate_phy(
  * @this_port: This is the port on which the phy should be disabled.
  * @the_phy: This is the specific phy which to disabled.
  *
- * This method will disable the phy and report that the phy is not valid for
+ * This function will disable the phy and report that the phy is not valid for
  * this port object. None
  */
 static void scic_sds_port_invalid_link_up(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	struct scic_sds_controller *controller = scic_sds_port_get_controller(this_port);
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
 
 	/*
-	 * Check to see if we have alreay reported this link as bad and if not go
-	 * ahead and tell the SCI_USER that we have discovered an invalid link. */
-	if ((controller->invalid_phy_mask & (1 << the_phy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(controller, the_phy);
-
-		isci_event_port_invalid_link_up(controller, this_port, the_phy);
+	 * Check to see if we have alreay reported this link as bad and if
+	 * not go ahead and tell the SCI_USER that we have discovered an
+	 * invalid link.
+	 */
+	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(scic, sci_phy);
+		isci_port_invalid_link_up(scic, sci_port, sci_phy);
 	}
 }
 
@@ -950,44 +953,48 @@ enum sci_status scic_sds_port_complete_io(
  */
 static void scic_sds_port_timeout_handler(void *port)
 {
-	struct scic_sds_port *this_port = port;
+	struct scic_sds_port *sci_port = port;
 	u32 current_state;
 
 	current_state = sci_base_state_machine_get_state(
-		&this_port->parent.state_machine);
+		&sci_port->parent.state_machine);
 
 	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
 		/*
-		 * if the port is still in the resetting state then the timeout fired
-		 * before the reset completed. */
+		 * if the port is still in the resetting state then the
+		 * timeout fired before the reset completed.
+		 */
 		sci_base_state_machine_change_state(
-			&this_port->parent.state_machine,
-			SCI_BASE_PORT_STATE_FAILED
-			);
+			&sci_port->parent.state_machine,
+			SCI_BASE_PORT_STATE_FAILED);
 	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
 		/*
 		 * if the port is stopped then the start request failed
-		 * In this case stay in the stopped state. */
-		dev_err(sciport_to_dev(this_port),
+		 * In this case stay in the stopped state.
+		 */
+		dev_err(sciport_to_dev(sci_port),
 			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
 			__func__,
-			this_port);
+			sci_port);
 	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
-		/* if the port is still stopping then the stop has not completed */
-		isci_event_port_stop_complete(
-			scic_sds_port_get_controller(this_port),
-			port,
-			SCI_FAILURE_TIMEOUT
-			);
+		/*
+		 * if the port is still stopping then the stop has not
+		 * completed
+		 */
+		isci_port_stop_complete(
+				scic_sds_port_get_controller(sci_port),
+				sci_port,
+				SCI_FAILURE_TIMEOUT);
 	} else {
 		/*
-		 * The port is in the ready state and we have a timer reporting a timeout
-		 * this should not happen. */
-		dev_err(sciport_to_dev(this_port),
+		 * The port is in the ready state and we have a timer
+		 * reporting a timeout this should not happen.
+		 */
+		dev_err(sciport_to_dev(sci_port),
 			"%s: SCIC Port 0x%p is processing a timeout operation "
 			"in state %d.\n",
 			__func__,
-			this_port,
+			sci_port,
 			current_state);
 	}
 }
@@ -1067,13 +1074,14 @@ enum sci_sas_link_rate scic_sds_port_get_max_allowed_speed(
  *
  */
 void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = sci_object_get_association(scic);
+
 	/* notify the user. */
-	isci_event_port_bc_change_primitive_received(
-		this_port->owning_controller, this_port, this_phy
-		);
+	isci_port_bc_change_received(ihost, sci_port, sci_phy);
 }
 
 
@@ -1267,30 +1275,29 @@ static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
  *
  * This method will casue the port to reset. enum sci_status SCI_SUCCESS
  */
-static enum sci_status scic_sds_port_ready_operational_substate_reset_handler(
-	struct sci_base_port *port,
-	u32 timeout)
+static enum
+sci_status scic_sds_port_ready_operational_substate_reset_handler(
+		struct sci_base_port *port,
+		u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
 	u32 phy_index;
-	struct scic_sds_port *this_port = (struct scic_sds_port *)port;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)port;
 	struct scic_sds_phy *selected_phy = NULL;
 
 
 	/* Select a phy on which we can send the hard reset request. */
-	for (
-		phy_index = 0;
-		(phy_index < SCI_MAX_PHYS)
-		&& (selected_phy == NULL);
-		phy_index++
-		) {
-		selected_phy = this_port->phy_table[phy_index];
-
-		if (
-			(selected_phy != NULL)
-			&& !scic_sds_port_active_phy(this_port, selected_phy)
-			) {
-			/* We found a phy but it is not ready select different phy */
+	for (phy_index = 0;
+	     (phy_index < SCI_MAX_PHYS) && (selected_phy == NULL);
+	     phy_index++) {
+		selected_phy = sci_port->phy_table[phy_index];
+
+		if ((selected_phy != NULL) &&
+		    !scic_sds_port_active_phy(sci_port, selected_phy)) {
+			/*
+			 * We found a phy but it is not ready select
+			 * different phy
+			 */
 			selected_phy = NULL;
 		}
 	}
@@ -1300,18 +1307,13 @@ static enum sci_status scic_sds_port_ready_operational_substate_reset_handler(
 		status = scic_sds_phy_reset(selected_phy);
 
 		if (status == SCI_SUCCESS) {
-			isci_event_timer_start(
-				scic_sds_port_get_controller(this_port),
-				this_port->timer_handle,
-				timeout
-				);
-
-			this_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+			isci_timer_start(sci_port->timer_handle, timeout);
+			sci_port->not_ready_reason =
+				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
 			sci_base_state_machine_change_state(
-				&this_port->parent.state_machine,
-				SCI_BASE_PORT_STATE_RESETTING
-				);
+					&sci_port->parent.state_machine,
+					SCI_BASE_PORT_STATE_RESETTING);
 		}
 	}
 
@@ -1686,10 +1688,11 @@ static void scic_sds_port_ready_substate_waiting_enter(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
+ * This function will perform the actions required by the struct scic_sds_port
+ * on entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
  * the state handlers for the port object, notifies the SCI User that the port
  * is ready, and resumes port operations. none
  */
@@ -1697,32 +1700,34 @@ static void scic_sds_port_ready_substate_operational_enter(
 	struct sci_base_object *object)
 {
 	u32 index;
-	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_port *iport = sci_object_get_association(sci_port);
 
 	scic_sds_port_set_ready_state_handlers(
-		this_port, SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-		);
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 
-	isci_event_port_ready(
-		scic_sds_port_get_controller(this_port), this_port
-		);
+	isci_port_ready(ihost, iport);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->phy_table[index] != NULL) {
+		if (sci_port->phy_table[index] != NULL)
 			scic_sds_port_write_phy_assignment(
-				this_port, this_port->phy_table[index]
-				);
-		}
+					sci_port,
+					sci_port->phy_table[index]);
 	}
 
-	scic_sds_port_update_viit_entry(this_port);
+	scic_sds_port_update_viit_entry(sci_port);
 
-	scic_sds_port_resume_port_task_scheduler(this_port);
+	scic_sds_port_resume_port_task_scheduler(sci_port);
 
-	/* Post the dummy task for the port so the hardware can schedule
+	/*
+	 * Post the dummy task for the port so the hardware can schedule
 	 * io correctly
 	 */
-	scic_sds_port_post_dummy_request(this_port);
+	scic_sds_port_post_dummy_request(sci_port);
 }
 
 /**
@@ -1736,20 +1741,20 @@ static void scic_sds_port_ready_substate_operational_enter(
 static void scic_sds_port_ready_substate_operational_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_port *iport = sci_object_get_association(sci_port);
 
-/*
- * Kill the dummy task for this port if it has not yet posted
- * the hardware will treat this as a NOP and just return abort
- * complete.
- */
-	scic_sds_port_abort_dummy_request(this_port);
+	/*
+	 * Kill the dummy task for this port if it has not yet posted
+	 * the hardware will treat this as a NOP and just return abort
+	 * complete.
+	 */
+	scic_sds_port_abort_dummy_request(sci_port);
 
-	isci_event_port_not_ready(
-		scic_sds_port_get_controller(this_port),
-		this_port,
-		this_port->not_ready_reason
-		);
+	isci_port_not_ready(ihost, iport);
 }
 
 /*
@@ -1759,7 +1764,8 @@ static void scic_sds_port_ready_substate_operational_exit(
 
 /**
  * scic_sds_port_ready_substate_configuring_enter() -
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
  * This method will perform the actions required by the struct scic_sds_port on
  * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
@@ -1768,29 +1774,26 @@ static void scic_sds_port_ready_substate_operational_exit(
 static void scic_sds_port_ready_substate_configuring_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_port *iport = sci_object_get_association(sci_port);
 
 	scic_sds_port_set_ready_state_handlers(
-		this_port, SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-		);
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 
-	if (this_port->active_phy_mask == 0) {
-		isci_event_port_not_ready(
-			scic_sds_port_get_controller(this_port),
-			this_port,
-			SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS
-			);
+	if (sci_port->active_phy_mask == 0) {
+		isci_port_not_ready(ihost, iport);
 
 		sci_base_state_machine_change_state(
-			&this_port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_WAITING
-			);
-	} else if (this_port->started_request_count == 0) {
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+	} else if (sci_port->started_request_count == 0)
 		sci_base_state_machine_change_state(
-			&this_port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-			);
-	}
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 }
 
 static void scic_sds_port_ready_substate_configuring_exit(
@@ -2165,42 +2168,52 @@ static enum sci_status scic_sds_port_general_complete_io_handler(
 /**
  * scic_sds_port_stopped_state_start_handler() - stop a port from "started"
  *
- * @port: This is the struct sci_base_port object which is cast into a struct scic_sds_port
- *    object.
+ * @port: This is the struct sci_base_port object which is cast into a
+ * struct scic_sds_port object.
  *
- * This method takes the struct scic_sds_port from a stopped state and attempts to
- * start it.  To start a port it must have no assiged devices and it must have
- * at least one phy assigned to it.  If those conditions are met then the port
- * can transition to the ready state. enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION This struct scic_sds_port object could
- * not be started because the port configuration is not valid. SCI_SUCCESS the
- * start request is successful and the struct scic_sds_port object has transitioned to
- * the SCI_BASE_PORT_STATE_READY.
+ * This function takes the struct scic_sds_port from a stopped state and
+ * attempts to start it.  To start a port it must have no assiged devices and
+ * it must have at least one phy assigned to it.  If those conditions are
+ * met then the port can transition to the ready state.
+ * enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
+ * This struct scic_sds_port object could not be started because the port
+ * configuration is not valid.
+ * SCI_SUCCESS
+ * the start request is successful and the struct scic_sds_port object
+ * has transitioned to the SCI_BASE_PORT_STATE_READY.
  */
-static enum sci_status scic_sds_port_stopped_state_start_handler(struct sci_base_port *base_port)
+static enum sci_status
+scic_sds_port_stopped_state_start_handler(struct sci_base_port *base_port)
 {
-	struct scic_sds_port *sci_port = container_of(base_port, typeof(*sci_port), parent);
+	struct scic_sds_port *sci_port =
+		container_of(base_port, typeof(*sci_port), parent);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = sci_object_get_association(scic);
 	enum sci_status status = SCI_SUCCESS;
 	u32 phy_mask;
 
 	if (sci_port->assigned_device_count > 0) {
 		/*
-		 * / @todo This is a start failure operation because there are still
-		 * /       devices assigned to this port.  There must be no devices
-		 * /       assigned to a port on a start operation. */
+		 * @todo This is a start failure operation because
+		 * there are still devices assigned to this port.
+		 * There must be no devices assigned to a port on a
+		 * start operation.
+		 */
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 	}
 
-	sci_port->timer_handle = isci_event_timer_create(scic,
-							 scic_sds_port_timeout_handler,
-							 sci_port);
+	sci_port->timer_handle =
+		isci_timer_create(ihost,
+				  sci_port,
+				  scic_sds_port_timeout_handler);
 
 	if (!sci_port->timer_handle)
 		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
 
 	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
-		u16 rni = scic_sds_remote_node_table_allocate_remote_node(&scic->available_remote_nodes, 1);
+		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
+				&scic->available_remote_nodes, 1);
 
 		if (rni != SCU_DUMMY_INDEX)
 			scic_sds_port_construct_dummy_rnc(sci_port, rni);
@@ -2715,50 +2728,41 @@ static void scic_sds_port_stopped_state_exit(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
  * This method will perform the actions required by the struct scic_sds_port on
  * entering the SCI_BASE_PORT_STATE_READY. This function sets the ready state
- * handlers for the struct scic_sds_port object, reports the port object as not ready
- * and starts the ready substate machine. none
+ * handlers for the struct scic_sds_port object, reports the port object as
+ * not ready and starts the ready substate machine. none
  */
-static void scic_sds_port_ready_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_port_ready_state_enter(struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
+	struct isci_port *iport = sci_object_get_association(sci_port);
+	struct scic_sds_controller *scic =
+		scic_sds_port_get_controller(sci_port);
+	struct isci_host *ihost = sci_object_get_association(scic);
 
-	this_port = (struct scic_sds_port *)object;
+	/*
+	 * Put the ready state handlers in place though they will not be
+	 * there long
+	 */
+	scic_sds_port_set_base_state_handlers(sci_port,
+					      SCI_BASE_PORT_STATE_READY);
 
-	/* Put the ready state handlers in place though they will not be there long */
-	scic_sds_port_set_base_state_handlers(
-		this_port, SCI_BASE_PORT_STATE_READY
-		);
-
-	if (
-		SCI_BASE_PORT_STATE_RESETTING
-		== this_port->parent.state_machine.previous_state_id
-		) {
-		isci_event_port_hard_reset_complete(
-			scic_sds_port_get_controller(this_port),
-			this_port,
-			SCI_SUCCESS
-			);
-	} else {
-		/* Notify the caller that the port is not yet ready */
-		isci_event_port_not_ready(
-			scic_sds_port_get_controller(this_port),
-			this_port,
-			SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS
-			);
-	}
+	if (sci_port->parent.state_machine.previous_state_id ==
+			SCI_BASE_PORT_STATE_RESETTING)
+		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
+	else /* Notify the caller that the port is not yet ready */
+		isci_port_not_ready(ihost, iport);
 
 	/* Post and suspend the dummy remote node context for this port. */
-	scic_sds_port_post_dummy_remote_node(this_port);
+	scic_sds_port_post_dummy_remote_node(sci_port);
 
 	/* Start the ready substate machine */
 	sci_base_state_machine_start(
-		scic_sds_port_get_ready_substate_machine(this_port)
-		);
+			scic_sds_port_get_ready_substate_machine(sci_port));
 }
 
 /**
@@ -2802,22 +2806,19 @@ static void scic_sds_port_resetting_state_enter(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
  * exiting the SCI_BASE_STATE_RESETTING. This function does nothing. none
  */
-static void scic_sds_port_resetting_state_exit(
+static inline void scic_sds_port_resetting_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
 
-	this_port = (struct scic_sds_port *)object;
-
-	isci_event_timer_stop(
-		scic_sds_port_get_controller(this_port),
-		this_port->timer_handle
-		);
+	isci_timer_stop(sci_port->timer_handle);
 }
 
 /**
@@ -2842,51 +2843,42 @@ static void scic_sds_port_stopping_state_enter(
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
  * exiting the SCI_BASE_STATE_STOPPING. This function does nothing. none
  */
-static void scic_sds_port_stopping_state_exit(
-	struct sci_base_object *object)
+static inline void
+scic_sds_port_stopping_state_exit(struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
-
-	this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
 
-	isci_event_timer_stop(
-		scic_sds_port_get_controller(this_port),
-		this_port->timer_handle
-		);
+	isci_timer_stop(sci_port->timer_handle);
 
-	scic_sds_port_destroy_dummy_resources(this_port);
+	scic_sds_port_destroy_dummy_resources(sci_port);
 }
 
 /**
  *
- * @object: This is the struct sci_base_object which is cast to a struct scic_sds_port object.
+ * @object: This is the struct sci_base_object which is cast to a
+ * struct scic_sds_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
  * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
  * state handlers for the struct scic_sds_port object. none
  */
-static void scic_sds_port_failed_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_port_failed_state_enter(struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
-
-	this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
+	struct isci_port *iport = sci_object_get_association(sci_port);
 
-	scic_sds_port_set_base_state_handlers(
-		this_port,
-		SCI_BASE_PORT_STATE_FAILED
-		);
+	scic_sds_port_set_base_state_handlers(sci_port,
+					      SCI_BASE_PORT_STATE_FAILED);
 
-	isci_event_port_hard_reset_complete(
-		scic_sds_port_get_controller(this_port),
-		this_port,
-		SCI_FAILURE_TIMEOUT
-		);
+	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
 }
 
 /* --------------------------------------------------------------------------- */
diff --git a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
index 7c95210..d2d3f52 100644
--- a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
+++ b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
@@ -431,46 +431,47 @@ static void scic_sds_mpc_agent_link_up(
  *    assigned port.
  * @phy: This is the phy object which has gone link down.
  *
- * This method handles the manual port configuration link down notifications.
+ * This function handles the manual port configuration link down notifications.
  * Since all ports and phys are associated at initialization time we just turn
  * around and notifiy the port object of the link down event.  If this PHY is
  * not associated with a port there is no action taken. Is it possible to get a
  * link down notification from a phy that has no assocoated port?
  */
 static void scic_sds_mpc_agent_link_down(
-	struct scic_sds_controller *controller,
+	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	if (port != NULL) {
+	if (sci_port != NULL) {
 		/*
-		 * If we can form a new port from the remainder of the phys then we want
-		 * to start the timer to allow the SCI User to cleanup old devices and
-		 * rediscover the port before rebuilding the port with the phys that
-		 * remain in the ready state. */
-		port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
-		port_agent->phy_configured_mask &= ~(1 << scic_sds_phy_get_index(phy));
+		 * If we can form a new port from the remainder of the phys
+		 * then we want to start the timer to allow the SCI User to
+		 * cleanup old devices and rediscover the port before
+		 * rebuilding the port with the phys that remain in the ready
+		 * state.
+		 */
+		port_agent->phy_ready_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
+		port_agent->phy_configured_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
 
 		/*
-		 * Check to see if there are more phys waiting to be configured into a port.
-		 * If there are allow the SCI User to tear down this port, if necessary, and
-		 * then reconstruc the port after the timeout. */
-		if (
-			(port_agent->phy_configured_mask == 0x0000)
-			&& (port_agent->phy_ready_mask != 0x0000)
-			&& !port_agent->timer_pending
-			) {
+		 * Check to see if there are more phys waiting to be
+		 * configured into a port. If there are allow the SCI User
+		 * to tear down this port, if necessary, and then reconstruct
+		 * the port after the timeout.
+		 */
+		if ((port_agent->phy_configured_mask == 0x0000) &&
+		    (port_agent->phy_ready_mask != 0x0000) &&
+		    !port_agent->timer_pending) {
 			port_agent->timer_pending = true;
 
-			isci_event_timer_start(
-				controller,
-				port_agent->timer,
-				SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT
-				);
+			isci_timer_start(port_agent->timer,
+					 SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(port, phy);
+		scic_sds_port_link_down(sci_port, sci_phy);
 	}
 }
 
@@ -535,19 +536,18 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
  * the next time period.  This could be caused by either a link down event or a
  * link up event where we can not yet tell to which port a phy belongs.
  */
-static void scic_sds_apc_agent_start_timer(
-	struct scic_sds_controller *controller,
+static inline void scic_sds_apc_agent_start_timer(
+	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *phy,
+	struct scic_sds_phy *sci_phy,
 	u32 timeout)
 {
-	if (port_agent->timer_pending) {
-		isci_event_timer_stop(controller, port_agent->timer);
-	}
+	if (port_agent->timer_pending)
+		isci_timer_stop(port_agent->timer);
 
 	port_agent->timer_pending = true;
 
-	isci_event_timer_start(controller, port_agent->timer, timeout);
+	isci_timer_start(port_agent->timer, timeout);
 }
 
 /**
@@ -816,45 +816,46 @@ void scic_sds_port_configuration_agent_construct(
  * This method will construct the port configuration agent for this controller.
  */
 enum sci_status scic_sds_port_configuration_agent_initialize(
-	struct scic_sds_controller *controller,
+	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent)
 {
 	enum sci_status status = SCI_SUCCESS;
 	enum SCIC_PORT_CONFIGURATION_MODE mode;
+	struct isci_host *ihost = sci_object_get_association(scic);
 
-	mode = controller->oem_parameters.sds1.controller.mode_type;
+	mode = scic->oem_parameters.sds1.controller.mode_type;
 
 	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-		status = scic_sds_mpc_agent_validate_phy_configuration(controller, port_agent);
+		status = scic_sds_mpc_agent_validate_phy_configuration(
+				scic, port_agent);
 
 		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
 
-		port_agent->timer = isci_event_timer_create(
-			controller,
-			scic_sds_mpc_agent_timeout_handler,
-			controller
-			);
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_mpc_agent_timeout_handler);
 	} else {
-		status = scic_sds_apc_agent_validate_phy_configuration(controller, port_agent);
+		status = scic_sds_apc_agent_validate_phy_configuration(
+				scic, port_agent);
 
 		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
 
-		port_agent->timer = isci_event_timer_create(
-			controller,
-			scic_sds_apc_agent_timeout_handler,
-			controller
-			);
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_apc_agent_timeout_handler);
 	}
 
 	/* Make sure we have actually gotten a timer */
 	if ((status == SCI_SUCCESS) && (port_agent->timer == NULL)) {
-		dev_err(scic_to_dev(controller),
+		dev_err(scic_to_dev(scic),
 			"%s: Controller 0x%p automatic port configuration "
 			"agent could not get timer.\n",
 			__func__,
-			controller);
+			scic);
 
 		status = SCI_FAILURE;
 	}
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.c b/drivers/scsi/isci/core/scic_sds_remote_device.c
index 0ac6ca0..f722678 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_remote_device.c
@@ -1795,7 +1795,7 @@ static void scic_sds_remote_device_initial_state_enter(
  * @object: This is the struct sci_base_object that is cast into a
  *    struct scic_sds_remote_device.
  *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_INITIAL it
+ * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_INITIAL it
  * sets the stopped state handlers and if this state is entered from the
  * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING then the SCI User is informed that the
  * device stop is complete. none
@@ -1803,30 +1803,29 @@ static void scic_sds_remote_device_initial_state_enter(
 static void scic_sds_remote_device_stopped_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev =
+		sci_object_get_association(sci_dev);
 
-	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPED
-		);
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
 
 	/*
 	 * If we are entering from the stopping state let the SCI User know that
-	 * the stop operation has completed. */
-	if (this_device->parent.state_machine.previous_state_id
-	    == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING) {
-		isci_event_remote_device_stop_complete(
-			scic_sds_remote_device_get_controller(this_device),
-			this_device,
-			SCI_SUCCESS
-			);
-	}
+	 * the stop operation has completed.
+	 */
+	if (sci_dev->parent.state_machine.previous_state_id ==
+			SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
+		isci_remote_device_stop_complete(ihost, idev, SCI_SUCCESS);
 
 	scic_sds_controller_remote_device_stopped(
-		scic_sds_remote_device_get_controller(this_device),
-		this_device
-	);
+		scic_sds_remote_device_get_controller(sci_dev),
+		sci_dev);
 }
 
 /**
@@ -1834,29 +1833,28 @@ static void scic_sds_remote_device_stopped_state_enter(
  * @object: This is the struct sci_base_object that is cast into a
  *    struct scic_sds_remote_device.
  *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_STARTING it
+ * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_STARTING it
  * sets the starting state handlers, sets the device not ready, and posts the
  * remote node context to the hardware. none
  */
 static void scic_sds_remote_device_starting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *the_controller;
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_controller *scic;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
-	the_controller = scic_sds_remote_device_get_controller(this_device);
+	scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_STARTING
-		);
+			sci_dev,
+			scic_sds_remote_device_state_handler_table,
+			SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
 
-	isci_event_remote_device_not_ready(
-		the_controller,
-		this_device,
-		SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED
-		);
+	isci_remote_device_not_ready(
+			idev,
+			SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
 
 /**
@@ -1864,27 +1862,29 @@ static void scic_sds_remote_device_starting_state_enter(
  * @object: This is the struct sci_base_object that is cast into a
  *    struct scic_sds_remote_device.
  *
- * This is the exit method for the SCI_BASE_REMOTE_DEVICE_STATE_STARTING it
+ * This is the exit function for the SCI_BASE_REMOTE_DEVICE_STATE_STARTING it
  * reports that the device start is complete. none
  */
 static void scic_sds_remote_device_starting_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
 
 	/*
-	 * / @todo Check the device object for the proper return code for this
-	 * /       callback */
-	isci_event_remote_device_start_complete(
-		scic_sds_remote_device_get_controller(this_device),
-		this_device,
-		SCI_SUCCESS
-		);
+	 * @todo Check the device object for the proper return code for this
+	 * callback
+	 */
+	isci_remote_device_start_complete(ihost, idev, SCI_SUCCESS);
 
 	scic_sds_controller_remote_device_started(
-		scic_sds_remote_device_get_controller(this_device),
-		this_device
-	);
+		scic_sds_remote_device_get_controller(sci_dev),
+		sci_dev);
 }
 
 /**
@@ -1892,30 +1892,28 @@ static void scic_sds_remote_device_starting_state_exit(
  * @object: This is the struct sci_base_object that is cast into a
  *    struct scic_sds_remote_device.
  *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_READY it sets
+ * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_READY it sets
  * the ready state handlers, and starts the ready substate machine. none
  */
 static void scic_sds_remote_device_ready_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *the_controller;
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
-
-	the_controller = scic_sds_remote_device_get_controller(this_device);
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+	struct scic_sds_controller *scic
+		= scic_sds_remote_device_get_controller(sci_dev);
 
-	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_READY
-		);
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
 
-	the_controller->remote_device_sequence[this_device->rnc->remote_node_index]++;
+	scic->remote_device_sequence[sci_dev->rnc->remote_node_index]++;
 
-	if (this_device->has_ready_substate_machine) {
-		sci_base_state_machine_start(&this_device->ready_substate_machine);
-	} else {
-		isci_event_remote_device_ready(the_controller, this_device);
-	}
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_start(&sci_dev->ready_substate_machine);
+	else
+		isci_remote_device_ready(idev);
 }
 
 /**
@@ -1923,26 +1921,22 @@ static void scic_sds_remote_device_ready_state_enter(
  * @object: This is the struct sci_base_object that is cast into a
  *    struct scic_sds_remote_device.
  *
- * This is the exit method for the SCI_BASE_REMOTE_DEVICE_STATE_READY it does
+ * This is the exit function for the SCI_BASE_REMOTE_DEVICE_STATE_READY it does
  * nothing. none
  */
 static void scic_sds_remote_device_ready_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *the_controller;
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
-	the_controller = scic_sds_remote_device_get_controller(this_device);
-
-	if (this_device->has_ready_substate_machine) {
-		sci_base_state_machine_stop(&this_device->ready_substate_machine);
-	} else {
-		isci_event_remote_device_not_ready(
-			the_controller,
-			this_device,
-			SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED
-			);
-	}
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
+	else
+		isci_remote_device_not_ready(
+				idev,
+				SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index 00bebb9..4542f4e 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -2077,30 +2077,24 @@ static void scic_sds_request_started_state_exit(
 static void scic_sds_request_completed_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
+	struct scic_sds_controller *scic =
+		scic_sds_request_get_controller(sci_req);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_request *ireq = sci_object_get_association(sci_req);
 
-	SET_STATE_HANDLER(
-		this_request,
-		scic_sds_request_state_handler_table,
-		SCI_BASE_REQUEST_STATE_COMPLETED
-		);
+
+	SET_STATE_HANDLER(sci_req,
+			  scic_sds_request_state_handler_table,
+			  SCI_BASE_REQUEST_STATE_COMPLETED);
 
 	/* Tell the SCI_USER that the IO request is complete */
-	if (this_request->is_task_management_request == false) {
-		isci_event_io_request_complete(
-			scic_sds_request_get_controller(this_request),
-			scic_sds_request_get_device(this_request),
-			this_request,
-			this_request->sci_status
-			);
-	} else {
-		isci_event_task_request_complete(
-			scic_sds_request_get_controller(this_request),
-			scic_sds_request_get_device(this_request),
-			this_request,
-			this_request->sci_status
-			);
-	}
+	if (sci_req->is_task_management_request == false)
+		isci_request_io_request_complete(ihost,
+						 ireq,
+						 sci_req->sci_status);
+	else
+		isci_task_request_complete(ihost, ireq, sci_req->sci_status);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
index 93e6ab8..fb832ef 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
@@ -250,22 +250,23 @@ const struct scic_sds_remote_device_state_handler scic_sds_smp_remote_device_rea
  *    struct scic_sds_remote_device.
  *
  * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE enter method.
- * This method sets the ready cmd substate handlers and reports the device as
+ * This function sets the ready cmd substate handlers and reports the device as
  * ready. none
  */
-static void scic_sds_smp_remote_device_ready_idle_substate_enter(
+static inline void scic_sds_smp_remote_device_ready_idle_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
 
 	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_smp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
-		);
+			sci_dev,
+			scic_sds_smp_remote_device_ready_substate_handler_table,
+			SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 
-	isci_event_remote_device_ready(
-		scic_sds_remote_device_get_controller(this_device), this_device);
+	isci_remote_device_ready(idev);
 }
 
 /**
@@ -274,27 +275,26 @@ static void scic_sds_smp_remote_device_ready_idle_substate_enter(
  *    struct scic_sds_remote_device.
  *
  * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD enter method. This
- * method sets the remote device objects ready cmd substate handlers, and
+ * function sets the remote device objects ready cmd substate handlers, and
  * notify core user that the device is not ready. none
  */
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)object;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
-	BUG_ON(this_device->working_request == NULL);
+	BUG_ON(sci_dev->working_request == NULL);
 
 	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_smp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD
-		);
+			sci_dev,
+			scic_sds_smp_remote_device_ready_substate_handler_table,
+			SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
 
-	isci_event_remote_device_not_ready(
-		scic_sds_remote_device_get_controller(this_device),
-		this_device,
-		SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED
-		);
+	isci_remote_device_not_ready(
+			idev,
+			SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
index 9a615f0..cb396d1 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
@@ -677,23 +677,22 @@ const struct scic_sds_remote_device_state_handler scic_sds_stp_remote_device_rea
  * *  STP REMOTE DEVICE READY SUBSTATE PRIVATE METHODS
  * ***************************************************************************** */
 
-static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(
-	void *user_cookie)
+static inline void
+scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(
+		void *user_cookie)
 {
-	struct scic_sds_remote_device *this_device;
-
-	this_device = (struct scic_sds_remote_device *)user_cookie;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)user_cookie;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
 	/*
 	 * For NCQ operation we do not issue a
 	 * scic_cb_remote_device_not_ready().  As a result, avoid sending
-	 * the ready notification. */
-	if (this_device->ready_substate_machine.previous_state_id
-	    != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ) {
-		isci_event_remote_device_ready(
-			scic_sds_remote_device_get_controller(this_device), this_device
-			);
-	}
+	 * the ready notification.
+	 */
+	if (sci_dev->ready_substate_machine.previous_state_id !=
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
+		isci_remote_device_ready(idev);
 }
 
 /*
@@ -749,26 +748,23 @@ static void scic_sds_stp_remote_device_ready_idle_substate_enter(
  *    struct scic_sds_remote_device object.
  *
  */
-static void scic_sds_stp_remote_device_ready_cmd_substate_enter(
+static inline void scic_sds_stp_remote_device_ready_cmd_substate_enter(
 	struct sci_base_object *device)
 {
-	struct scic_sds_remote_device *this_device;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)device;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
-	this_device = (struct scic_sds_remote_device *)device;
-
-	BUG_ON(this_device->working_request == NULL);
+	BUG_ON(sci_dev->working_request == NULL);
 
 	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD
-		);
+			sci_dev,
+			scic_sds_stp_remote_device_ready_substate_handler_table,
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
 
-	isci_event_remote_device_not_ready(
-		scic_sds_remote_device_get_controller(this_device),
-		this_device,
-		SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED
-		);
+	isci_remote_device_not_ready(
+			idev,
+			SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
 /*
@@ -807,27 +803,21 @@ static void scic_sds_stp_remote_device_ready_ncq_substate_enter(
  *    struct scic_sds_remote_device object.
  *
  */
-static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(
+static inline void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(
 	struct sci_base_object *device)
 {
-	struct scic_sds_remote_device *this_device;
-
-	this_device = (struct scic_sds_remote_device *)device;
+	struct scic_sds_remote_device *sci_dev =
+		(struct scic_sds_remote_device *)device;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
 	SET_STATE_HANDLER(
-		this_device,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
-		);
+			sci_dev,
+			scic_sds_stp_remote_device_ready_substate_handler_table,
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
 
-	if (this_device->not_ready_reason ==
-	    SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED) {
-		isci_event_remote_device_not_ready(
-			scic_sds_remote_device_get_controller(this_device),
-			this_device,
-			this_device->not_ready_reason
-			);
-	}
+	if (sci_dev->not_ready_reason ==
+		SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
+		isci_remote_device_not_ready(idev, sci_dev->not_ready_reason);
 }
 
 /*
diff --git a/drivers/scsi/isci/events.c b/drivers/scsi/isci/events.c
deleted file mode 100644
index 9d58e45..0000000
--- a/drivers/scsi/isci/events.c
+++ /dev/null
@@ -1,609 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/**
- * This file contains isci module object implementation.
- *
- *
- */
-
-#include "isci.h"
-#include "request.h"
-#include "sata.h"
-#include "task.h"
-#include "events.h"
-
-/**
- * isci_event_timer_create() - This callback method asks the user to create a
- *    timer and provide a handle for this timer for use in further timer
- *    interactions. The appropriate isci timer object function is called to
- *    create a timer object.
- * @timer_callback: This parameter specifies the callback method to be invoked
- *    whenever the timer expires.
- * @controller: This parameter specifies the controller with which this timer
- *    is to be associated.
- * @cb_param: opaque callback parameter
- *
- * This method returns a handle to a timer object created by the user.  The
- * handle will be utilized for all further interactions relating to this timer.
- */
-void *isci_event_timer_create(struct scic_sds_controller *scic,
-			      void (*timer_callback)(void *),
-			      void *cb_param)
-{
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_timer *itimer;
-
-	itimer = isci_timer_create(ihost, cb_param, timer_callback);
-
-	dev_dbg(&ihost->pdev->dev, "%s: timer = %p\n", __func__, itimer);
-
-	return itimer;
-}
-
-
-/**
- * isci_event_timer_start() - This callback method asks the user to start the
- *    supplied timer. The appropriate isci timer object function is called to
- *    start the timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be started.
- * @milliseconds: This parameter specifies the number of milliseconds for which
- *    to stall.  The operating system driver is allowed to round this value up
- *    where necessary.
- *
- */
-void isci_event_timer_start(
-	struct scic_sds_controller *controller,
-	void *timer,
-	u32 milliseconds)
-{
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_host = %p, timer = %p, milliseconds = %d\n",
-		__func__, isci_host, timer, milliseconds);
-
-	isci_timer_start((struct isci_timer *)timer, milliseconds);
-
-}
-
-/**
- * isci_event_timer_stop() - This callback method asks the user to stop the
- *    supplied timer. The appropriate isci timer object function is called to
- *    stop the timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be stopped.
- *
- */
-void isci_event_timer_stop(struct scic_sds_controller *controller, void *timer)
-{
-	struct isci_host *isci_host = sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_host = %p, timer = %p\n",
-		__func__, isci_host, timer);
-
-	isci_timer_stop((struct isci_timer *)timer);
-}
-
-void isci_event_timer_destroy(struct scic_sds_controller *scic, void *timer)
-{
-        struct isci_host *ihost = sci_object_get_association(scic);
-
-	dev_dbg(&ihost->pdev->dev, "%s: ihost = %p, timer = %p\n",
-			__func__, ihost, timer);
-
-	isci_del_timer(ihost, timer);
-}
-
-/**
- * isci_event_controller_start_complete() - This user callback will inform the
- *    user that the controller has finished the start process. The associated
- *    isci host adapter's start_complete function is called.
- * @controller: This parameter specifies the controller that was started.
- * @completion_status: This parameter specifies the results of the start
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_controller_start_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status)
-{
-	struct isci_host *isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_host = %p\n", __func__, isci_host);
-
-	isci_host_start_complete(isci_host, completion_status);
-}
-
-/**
- * isci_event_controller_stop_complete() - This user callback will inform the user
- *    that the controller has finished the stop process. The associated isci
- *    host adapter's start_complete function is called.
- * @controller: This parameter specifies the controller that was stopped.
- * @completion_status: This parameter specifies the results of the stop
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_controller_stop_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status)
-{
-	struct isci_host *isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: status = 0x%x\n", __func__, completion_status);
-	isci_host_stop_complete(isci_host, completion_status);
-}
-
-/**
- * isci_event_io_request_complete() - This user callback will inform the user that
- *    an IO request has completed.
- * @controller: This parameter specifies the controller on which the IO is
- *    completing.
- * @remote_device: This parameter specifies the remote device on which this IO
- *    request is completing.
- * @io_request: This parameter specifies the IO request that has completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_io_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *scic_io_request,
-	enum sci_io_status completion_status)
-{
-	struct isci_request *request;
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	request =
-		(struct isci_request *)sci_object_get_association(
-			scic_io_request
-			);
-
-	isci_request_io_request_complete(isci_host,
-					 request,
-					 completion_status);
-}
-
-/**
- * isci_event_task_request_complete() - This user callback will inform the user
- *    that a task management request completed.
- * @controller: This parameter specifies the controller on which the task
- *    management request is completing.
- * @remote_device: This parameter specifies the remote device on which this
- *    task management request is completing.
- * @task_request: This parameter specifies the task management request that has
- *    completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_task_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *scic_task_request,
-	enum sci_task_status completion_status)
-{
-	struct isci_request *request;
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	request =
-		(struct isci_request *)sci_object_get_association(
-			scic_task_request);
-
-	isci_task_request_complete(isci_host, request, completion_status);
-}
-
-/**
- * isci_event_port_stop_complete() - This method informs the user when a stop
- *    operation on the port has completed.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void isci_event_port_stop_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status)
-{
-	struct isci_host *isci_host;
-
-	isci_host = (struct isci_host *)sci_object_get_association(controller);
-
-	dev_notice(&isci_host->pdev->dev, "Port stop complete\n");
-}
-
-/**
- * isci_event_port_hard_reset_complete() - This method informs the user when a
- *    hard reset on the port has completed.  This hard reset could have been
- *    initiated by the user or by the remote port.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void isci_event_port_hard_reset_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status)
-{
-	struct isci_port *isci_port
-		= (struct isci_port *)sci_object_get_association(port);
-
-	isci_port_hard_reset_complete(isci_port, completion_status);
-}
-
-/**
- * isci_event_port_ready() - This method informs the user that the port is now in
- *    a ready state and can be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- *
- */
-void isci_event_port_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port)
-{
-	struct isci_port *isci_port;
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	isci_port =
-		(struct isci_port *)sci_object_get_association(port);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_port = %p\n", __func__, isci_port);
-
-	isci_port_ready(isci_host, isci_port);
-}
-
-/**
- * isci_event_port_not_ready() - This method informs the user that the port is now
- *    not in a ready (i.e. busy) state and can't be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- *
- */
-void isci_event_port_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	u32 reason_code)
-{
-	struct isci_port *isci_port;
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	isci_port =
-		(struct isci_port *)sci_object_get_association(port);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_port = %p\n", __func__, isci_port);
-
-	isci_port_not_ready(isci_host, isci_port);
-}
-
-/**
- * isci_event_port_invalid_link_up() - This method informs the SCI Core user that
- *    a phy/link became ready, but the phy is not allowed in the port.  In some
- *    situations the underlying hardware only allows for certain phy to port
- *    mappings.  If these mappings are violated, then this API is invoked.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @phy: This parameter specifies the phy that came ready, but the phy can't be
- *    a valid member of the port.
- *
- */
-void isci_event_port_invalid_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct isci_host *isci_host;
-
-	isci_host = (struct isci_host *)sci_object_get_association(controller);
-	dev_warn(&isci_host->pdev->dev, "Invalid link up!\n");
-}
-
-/**
- * isci_event_port_bc_change_primitive_received() - This callback method informs
- *    the user that a broadcast change primitive was received.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.  For instances where the phy on which the primitive was
- *    received is not part of a port, this parameter will be NULL.
- * @phy: This parameter specifies the phy on which the primitive was received.
- *
- */
-void isci_event_port_bc_change_primitive_received(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: port = %p, phy = %p\n", __func__, port, phy);
-	isci_port_bc_change_received(isci_host, port, phy);
-}
-
-
-
-
-/**
- * isci_event_port_link_up() - This callback method informs the user that a phy
- *    has become operational and is capable of communicating with the remote
- *    end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- * none.
- */
-void isci_event_port_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: phy = %p\n", __func__, phy);
-
-	isci_port_link_up(isci_host, port, phy);
-}
-
-/**
- * isci_event_port_link_down() - This callback method informs the user that a phy
- *    is no longer operational and is not capable of communicating with the
- *    remote end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- * none.
- */
-void isci_event_port_link_down(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct isci_host *isci_host;
-	struct isci_phy *isci_phy;
-	struct isci_port *isci_port;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	isci_phy =
-		(struct isci_phy *)sci_object_get_association(phy);
-
-	isci_port =
-		(struct isci_port *)sci_object_get_association(port);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_port = %p\n", __func__, isci_port);
-
-	isci_port_link_down(isci_host, isci_phy, isci_port);
-}
-
-/**
- * isci_event_remote_device_start_complete() - This user callback method will
- *    inform the user that a start operation has completed.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void isci_event_remote_device_start_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	enum sci_status completion_status)
-{
-	struct isci_host *isci_host;
-	struct isci_remote_device *isci_device;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	isci_device =
-		(struct isci_remote_device *)sci_object_get_association(
-			remote_device
-			);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
-
-	isci_remote_device_start_complete(
-		isci_host, isci_device, completion_status);
-
-}
-
-/**
- * isci_event_remote_device_stop_complete() - This user callback method will
- *    inform the user that a stop operation has completed.
- * @scic: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void isci_event_remote_device_stop_complete(struct scic_sds_controller *scic,
-					    struct scic_sds_remote_device *sci_dev,
-					    enum sci_status completion_status)
-{
-	struct isci_host *ihost;
-	struct isci_remote_device *idev;
-
-	ihost = sci_object_get_association(scic);
-	idev = sci_object_get_association(sci_dev);
-
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev = %p\n", __func__, idev);
-
-	isci_remote_device_stop_complete(ihost, idev, completion_status);
-}
-
-/**
- * isci_event_remote_device_ready() - This user callback method will inform the
- *    user that a remote device is now capable of handling IO requests.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- *
- */
-void isci_event_remote_device_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device)
-{
-	struct isci_remote_device *isci_device =
-		(struct isci_remote_device *)
-		sci_object_get_association(remote_device);
-
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
-
-	isci_remote_device_ready(isci_device);
-}
-
-/**
- * isci_event_remote_device_not_ready() - This user callback method will inform
- *    the user that a remote device is no longer capable of handling IO
- *    requests (until a ready callback is invoked).
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- * @reason_code: This parameter specifies the reason for the remote device
- *    going to a not ready state.
- *
- */
-void isci_event_remote_device_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	u32 reason_code)
-{
-	struct isci_remote_device *isci_device =
-		(struct isci_remote_device *)
-		sci_object_get_association(remote_device);
-
-	struct isci_host *isci_host;
-
-	isci_host =
-		(struct isci_host *)sci_object_get_association(controller);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p, reason_code = %x\n",
-		__func__, isci_device, reason_code);
-
-	isci_remote_device_not_ready(isci_device, reason_code);
-}
-
-
diff --git a/drivers/scsi/isci/events.h b/drivers/scsi/isci/events.h
deleted file mode 100644
index fa2f6aa..0000000
--- a/drivers/scsi/isci/events.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _ISCI_EVENT_H_
-#define _ISCI_EVENT_H_
-
-/**
- * isci_event_timer_create() - This callback method asks the user to create a
- *    timer and provide a handle for this timer for use in further timer
- *    interactions.
- * @controller: This parameter specifies the controller with which this timer
- *    is to be associated.
- * @timer_callback: This parameter specifies the callback method to be invoked
- *    whenever the timer expires.
- * @cookie: This parameter specifies a piece of information that the user must
- *    retain.  This cookie is to be supplied by the user anytime a timeout
- *    occurs for the created timer.
- *
- * The "timer_callback" method should be executed in a mutually exlusive manner
- * from the controller completion handler handler. This method returns a handle
- * to a timer object created by the user.  The handle will be utilized for all
- * further interactions relating to this timer.
- */
-void *isci_event_timer_create(
-	struct scic_sds_controller *controller,
-	void (*timer_callback)(void *),
-	void *cookie);
-
-/**
- * isci_event_timer_start() - This callback method asks the user to start the
- *    supplied timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be started.
- * @milliseconds: This parameter specifies the number of milliseconds for which
- *    to stall.  The operating system driver is allowed to round this value up
- *    where necessary.
- *
- * All timers in the system started by the SCI Core are one shot timers.
- * Therefore, the SCI user should make sure that it removes the timer from it's
- * list when a timer actually fires. Additionally, SCI Core user's should be
- * able to handle calls from the SCI Core to stop a timer that may already be
- * stopped. none
- */
-void isci_event_timer_start(
-	struct scic_sds_controller *controller,
-	void *timer,
-	u32 milliseconds);
-
-/**
- * isci_event_timer_stop() - This callback method asks the user to stop the
- *    supplied timer.
- * @controller: This parameter specifies the controller with which this timer
- *    is to associated.
- * @timer: This parameter specifies the timer to be stopped.
- *
- */
-void isci_event_timer_stop(
-	struct scic_sds_controller *controller,
-	void *timer);
-
-
-void isci_event_timer_destroy(struct scic_sds_controller *scic, void *timer);
-
-/**
- * isci_event_controller_start_complete() - This user callback will inform the
- *    user that the controller has finished the start process.
- * @controller: This parameter specifies the controller that was started.
- * @completion_status: This parameter specifies the results of the start
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_controller_start_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status);
-
-/**
- * isci_event_controller_stop_complete() - This user callback will inform the
- * user that the controller has finished the stop process.
- * @controller: This parameter specifies the controller that was stopped.
- * @completion_status: This parameter specifies the results of the stop
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_controller_stop_complete(
-	struct scic_sds_controller *controller,
-	enum sci_status completion_status);
-
-/**
- * isci_event_io_request_complete() - This user callback will inform the user
- * that an IO request has completed.
- * @controller: This parameter specifies the controller on which the IO is
- *    completing.
- * @remote_device: This parameter specifies the remote device on which this IO
- *    request is completing.
- * @io_request: This parameter specifies the IO request that has completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_io_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *scic_io_request,
-	enum sci_io_status completion_status);
-
-/**
- * isci_event_task_request_complete() - This user callback will inform the user
- *    that a task management request completed.
- * @controller: This parameter specifies the controller on which the task
- *    management request is completing.
- * @remote_device: This parameter specifies the remote device on which this
- *    task management request is completing.
- * @task_request: This parameter specifies the task management request that has
- *    completed.
- * @completion_status: This parameter specifies the results of the IO request
- *    operation.  SCI_SUCCESS indicates successful completion.
- *
- */
-void isci_event_task_request_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *scic_task_request,
-	enum sci_task_status completion_status);
-
-/**
- * isci_event_port_stop_complete() - This method informs the user when a stop
- *    operation on the port has completed.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void isci_event_port_stop_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status);
-
-/**
- * isci_event_port_hard_reset_complete() - This method informs the user when a
- *    hard reset on the port has completed.  This hard reset could have been
- *    initiated by the user or by the remote port.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @completion_status: This parameter specifies the status for the operation
- *    being completed.
- *
- */
-void isci_event_port_hard_reset_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	enum sci_status completion_status);
-
-/**
- * isci_event_port_ready() - This method informs the user that the port is now
- * in a ready state and can be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- *
- */
-void isci_event_port_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port);
-
-/**
- * isci_event_port_not_ready() - This method informs the user that the port is
- * now not in a ready (i.e. busy) state and can't be utilized to issue IOs.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @reason_code: This parameter specifies the reason for the port not ready
- *    callback.
- *
- */
-void isci_event_port_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	u32 reason_code);
-
-/**
- * isci_event_port_invalid_link_up() - This method informs the SCI Core user
- * that a phy/link became ready, but the phy is not allowed in the port.  In
- * some situations the underlying hardware only allows for certain phy to port
- *    mappings.  If these mappings are violated, then this API is invoked.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @phy: This parameter specifies the phy that came ready, but the phy can't be
- *    a valid member of the port.
- *
- */
-void isci_event_port_invalid_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * isci_event_port_bc_change_primitive_received() - This callback method informs
- *    the user that a broadcast change primitive was received.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.  For instances where the phy on which the primitive was
- *    received is not part of a port, this parameter will be
- *    NULL.
- * @phy: This parameter specifies the phy on which the primitive was received.
- *
- */
-void isci_event_port_bc_change_primitive_received(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * isci_event_port_link_up() - This callback method informs the user that a phy
- *    has become operational and is capable of communicating with the remote
- *    end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- */
-void isci_event_port_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * isci_event_port_link_down() - This callback method informs the user that a
- * phy is no longer operational and is not capable of communicating with the
- *    remote end point.
- * @controller: This parameter represents the controller associated with the
- *    phy.
- * @port: This parameter specifies the port object for which the user callback
- *    is being invoked.  There may be conditions where this parameter can be
- *    NULL
- * @phy: This parameter specifies the phy object for which the user callback is
- *    being invoked.
- *
- */
-void isci_event_port_link_down(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
-
-/**
- * isci_event_remote_device_start_complete() - This user callback method will
- *    inform the user that a start operation has completed.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void isci_event_remote_device_start_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	enum sci_status completion_status);
-
-/**
- * isci_event_remote_device_stop_complete() - This user callback method will
- *    inform the user that a stop operation has completed.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the completion callback.
- * @completion_status: This parameter specifies the completion status for the
- *    operation.
- *
- */
-void isci_event_remote_device_stop_complete(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	enum sci_status completion_status);
-
-/**
- * isci_event_remote_device_ready() - This user callback method will inform the
- *    user that a remote device is now capable of handling IO requests.
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- *
- */
-void isci_event_remote_device_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device);
-
-/**
- * isci_event_remote_device_not_ready() - This user callback method will inform
- *    the user that a remote device is no longer capable of handling IO
- *    requests (until a ready callback is invoked).
- * @controller: This parameter specifies the core controller associated with
- *    the completion callback.
- * @remote_device: This parameter specifies the remote device associated with
- *    the callback.
- * @reason_code: This paramete specifies the reason the remote device is not
- *    ready.
- *
- */
-void isci_event_remote_device_not_ready(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *remote_device,
-	u32 reason_code);
-
-#endif
diff --git a/drivers/scsi/isci/isci.h b/drivers/scsi/isci/isci.h
index a2df59c..8764385 100644
--- a/drivers/scsi/isci/isci.h
+++ b/drivers/scsi/isci/isci.h
@@ -71,7 +71,6 @@
 #include "timers.h"
 #include "sci_status.h"
 #include "request.h"
-#include "events.h"
 #include "task.h"
 #include "sata.h"
 
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index a5b2565..666076a 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -279,10 +279,8 @@ void isci_port_link_up(
  * @port: This parameter specifies the isci port with the active link.
  *
  */
-void isci_port_link_down(
-	struct isci_host *isci_host,
-	struct isci_phy *isci_phy,
-	struct isci_port *isci_port)
+void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
+			 struct isci_port *isci_port)
 {
 	struct isci_remote_device *isci_device;
 
@@ -358,9 +356,7 @@ void isci_port_formed(
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_ready(
-	struct isci_host *isci_host,
-	struct isci_port *isci_port)
+void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -378,9 +374,7 @@ void isci_port_ready(
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_not_ready(
-	struct isci_host *isci_host,
-	struct isci_port *isci_port)
+void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -394,9 +388,8 @@ void isci_port_not_ready(
  *    process.
  *
  */
-void isci_port_hard_reset_complete(
-	struct isci_port *isci_port,
-	enum sci_status completion_status)
+void isci_port_hard_reset_complete(struct isci_port *isci_port,
+				   enum sci_status completion_status)
 {
 	dev_dbg(&isci_port->isci_host->pdev->dev,
 		"%s: isci_port = %p, completion_status=%x\n",
@@ -480,3 +473,35 @@ int isci_port_perform_hard_reset(
 
 	return ret;
 }
+
+/**
+ * isci_port_invalid_link_up() - This function informs the SCI Core user that
+ *    a phy/link became ready, but the phy is not allowed in the port.  In some
+ *    situations the underlying hardware only allows for certain phy to port
+ *    mappings.  If these mappings are violated, then this API is invoked.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @phy: This parameter specifies the phy that came ready, but the phy can't be
+ *    a valid member of the port.
+ *
+ */
+void isci_port_invalid_link_up(struct scic_sds_controller *scic,
+				      struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *phy)
+{
+	struct isci_host *ihost =
+		(struct isci_host *)sci_object_get_association(scic);
+
+	dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
+}
+
+void isci_port_stop_complete(struct scic_sds_controller *scic,
+					  struct scic_sds_port *sci_port,
+					  enum sci_status completion_status)
+{
+	struct isci_host *ihost = sci_object_get_association(scic);
+
+	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
+}
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index b7a7dd7..dfdd12a 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -147,5 +147,15 @@ int isci_port_perform_hard_reset(
 	struct isci_port *isci_port_ptr,
 	struct isci_phy *isci_phy_ptr);
 
+void isci_port_invalid_link_up(
+		struct scic_sds_controller *scic,
+		struct scic_sds_port *sci_port,
+		struct scic_sds_phy *phy);
+
+void isci_port_stop_complete(
+		struct scic_sds_controller *scic,
+		struct scic_sds_port *sci_port,
+		enum sci_status completion_status);
+
 #endif /* !defined(_ISCI_PORT_H_) */
 
-- 
1.7.0

