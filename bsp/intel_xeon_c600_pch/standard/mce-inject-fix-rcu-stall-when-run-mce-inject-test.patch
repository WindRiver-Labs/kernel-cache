From 2dd3b01b7f546a6c276d8367022178dbf956b44f Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 29 Mar 2012 13:07:15 +0800
Subject: [PATCH 458/474] mce-inject: fix rcu stall when run mce-inject test

rcu stall can appear sometimes, that is because mce_write process
has chance to be interrupted and scheduled out after nmi is issued
before raise_local is called, we need disable irq when nmi runs on
other cores to prevent potential lock up.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/cpu/mcheck/mce-inject.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/arch/x86/kernel/cpu/mcheck/mce-inject.c b/arch/x86/kernel/cpu/mcheck/mce-inject.c
index a8a3fca..0c89a2a 100644
--- a/arch/x86/kernel/cpu/mcheck/mce-inject.c
+++ b/arch/x86/kernel/cpu/mcheck/mce-inject.c
@@ -150,6 +150,7 @@ static int raise_local(void)
 
 static void raise_mce(struct mce *m)
 {
+	unsigned long flags;
 	int context = MCJ_CTX(m->inject_flags);
 
 	inject_mce(m);
@@ -180,11 +181,18 @@ static void raise_mce(struct mce *m)
 				preempt_disable();
 				smp_call_function_many(mce_inject_cpumask,
 					mce_irq_ipi, NULL, 0);
+				raise_local();
 				preempt_enable();
-			} else if (m->inject_flags & MCJ_NMI_BROADCAST)
+			} else if (m->inject_flags & MCJ_NMI_BROADCAST) {
+				local_irq_save(flags);
 				apic->send_IPI_mask(mce_inject_cpumask,
 						NMI_VECTOR);
-		}
+				raise_local();
+				local_irq_restore(flags);
+			}
+		} else
+			raise_local();
+
 		start = jiffies;
 		while (!cpumask_empty(mce_inject_cpumask)) {
 			if (!time_before(jiffies, start + 2*HZ)) {
@@ -195,7 +203,6 @@ static void raise_mce(struct mce *m)
 			}
 			cpu_relax();
 		}
-		raise_local();
 		put_cpu();
 		put_online_cpus();
 	} else
-- 
1.7.0

