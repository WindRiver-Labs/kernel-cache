From 3bf7708434afcdc0aaae9f0b7fe1202852d987db Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 2 Feb 2012 15:02:14 +0800
Subject: [PATCH 418/474] apei: replace irq work interface with perf event pending

irq work interface doesn't exists in 2.6.34, so we need to
use perf event pending interface to do the same work.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/acpi/apei/Kconfig  |    1 +
 drivers/acpi/apei/ghes.c   |   12 ++++--------
 include/linux/perf_event.h |    2 ++
 kernel/perf_event.c        |    2 +-
 4 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/drivers/acpi/apei/Kconfig b/drivers/acpi/apei/Kconfig
index d23e7ac..17cf973 100644
--- a/drivers/acpi/apei/Kconfig
+++ b/drivers/acpi/apei/Kconfig
@@ -13,6 +13,7 @@ config ACPI_APEI_GHES
 	bool "APEI Generic Hardware Error Source"
 	depends on ACPI_APEI && X86
 	select ACPI_HED
+	select PERF_EVENTS
 	select GENERIC_ALLOCATOR
 	help
 	  Generic Hardware Error Source provides a way to report
diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c
index eb6d8d3..d27b0db 100644
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@ -43,7 +43,7 @@
 #include <linux/mutex.h>
 #include <linux/ratelimit.h>
 #include <linux/vmalloc.h>
-#include <linux/irq_work.h>
+#include <linux/perf_event.h>
 #include <linux/llist.h>
 #include <linux/genalloc.h>
 #include <linux/pci.h>
@@ -177,7 +177,7 @@ static DEFINE_SPINLOCK(ghes_ioremap_lock_irq);
 static struct gen_pool *ghes_estatus_pool;
 static unsigned long ghes_estatus_pool_size_request;
 static struct llist_head ghes_estatus_llist;
-static struct irq_work ghes_proc_irq_work;
+static struct perf_pending_entry ghes_proc_irq_work;
 
 struct ghes_estatus_cache *ghes_estatus_caches[GHES_ESTATUS_CACHES_SIZE];
 static atomic_t ghes_estatus_cache_alloced;
@@ -753,7 +753,7 @@ static struct llist_node *llist_nodes_reverse(struct llist_node *llnode)
 	return tail;
 }
 
-static void ghes_proc_in_irq(struct irq_work *irq_work)
+static void ghes_proc_in_irq(struct perf_pending_entry *entry)
 {
 	struct llist_node *llnode, *next;
 	struct ghes_estatus_node *estatus_node;
@@ -876,9 +876,7 @@ next:
 #endif
 		ghes_clear_estatus(ghes);
 	}
-#ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
-	irq_work_queue(&ghes_proc_irq_work);
-#endif
+	perf_pending_queue(&ghes_proc_irq_work, ghes_proc_in_irq);
 
 out:
 	raw_spin_unlock(&ghes_nmi_lock);
@@ -1077,8 +1075,6 @@ static int __init ghes_init(void)
 		return -EINVAL;
 	}
 
-	init_irq_work(&ghes_proc_irq_work, ghes_proc_in_irq);
-
 	rc = ghes_ioremap_init();
 	if (rc)
 		goto err;
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 2a06e2f..14a24bd 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -951,6 +951,8 @@ extern int perf_swevent_get_recursion_context(void);
 extern void perf_swevent_put_recursion_context(int rctx);
 extern void perf_event_enable(struct perf_event *event);
 extern void perf_event_disable(struct perf_event *event);
+extern void perf_pending_queue(struct perf_pending_entry *entry,
+			       void (*func)(struct perf_pending_entry *));
 #else
 static inline void
 perf_event_task_sched_in(struct task_struct *task)			{ }
diff --git a/kernel/perf_event.c b/kernel/perf_event.c
index 2479011..8530a16 100644
--- a/kernel/perf_event.c
+++ b/kernel/perf_event.c
@@ -2767,7 +2767,7 @@ static DEFINE_PER_CPU(struct perf_pending_entry *, perf_pending_head) = {
 	PENDING_TAIL,
 };
 
-static void perf_pending_queue(struct perf_pending_entry *entry,
+void perf_pending_queue(struct perf_pending_entry *entry,
 			       void (*func)(struct perf_pending_entry *))
 {
 	struct perf_pending_entry **head;
-- 
1.7.0

