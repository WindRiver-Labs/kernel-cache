From 91c510443128fc5f9fa6413787bd8c24fc228696 Mon Sep 17 00:00:00 2001
From: Dan Williams <dan.j.williams@intel.com>
Date: Fri, 25 Feb 2011 10:25:21 -0800
Subject: [PATCH 035/474] isci: fix sas address reporting

upstream: 150fc6fc725055b400a8865e6785dc8dd0a2225d

Undo the open coded and incorrect translation of the oem parameter sas
address to its libsas expected format.

Signed-off-by: Dan Williams <dan.j.williams@intel.com>

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/scsi/isci/host.c |    5 -----
 drivers/scsi/isci/host.h |    1 -
 drivers/scsi/isci/init.c |    2 +-
 drivers/scsi/isci/phy.c  |   30 ++++++++++--------------------
 drivers/scsi/isci/port.c |   17 +++++++----------
 5 files changed, 18 insertions(+), 37 deletions(-)

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index aa86615..d8d6f67 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -517,11 +517,6 @@ int isci_host_init(struct isci_host *isci_host)
 	for (index = 0; index < SCI_MAX_PHYS; index++)
 		isci_phy_init(&isci_host->phys[index], isci_host, index);
 
-	/* Why are we doing this? Is this even necessary? */
-	memcpy(&isci_host->sas_addr[0],
-	       &isci_host->phys[0].sas_addr[0],
-	       SAS_ADDR_SIZE);
-
 	/* Start the ports */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
 		scic_controller_get_port_handle(controller, index, &scic_port);
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 06154a6..b794dfd 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -105,7 +105,6 @@ struct isci_host {
 	spinlock_t state_lock;
 
 	struct pci_dev *pdev;
-	u8 sas_addr[SAS_ADDR_SIZE];
 
 	enum isci_status status;
 	#define IHOST_START_PENDING 0
diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
index 6ca623a..d01c44f 100644
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@ -209,7 +209,7 @@ static int isci_register_sas_ha(struct isci_host *isci_host)
 
 	sas_ha->sas_ha_name = DRV_NAME;
 	sas_ha->lldd_module = THIS_MODULE;
-	sas_ha->sas_addr    = &(isci_host->sas_addr[0]);
+	sas_ha->sas_addr    = &isci_host->phys[0].sas_addr[0];
 
 	/* set the array of phy and port structs.  */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fbda570..1eefaae 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -75,14 +75,15 @@ void isci_phy_init(
 	struct isci_host *isci_host,
 	int index)
 {
-	struct scic_sds_controller *controller = isci_host->core_controller;
+	struct scic_sds_controller *scic = isci_host->core_controller;
 	struct scic_sds_phy *scic_phy;
-	union scic_oem_parameters oem_parameters;
+	union scic_oem_parameters oem;
 	enum sci_status status = SCI_SUCCESS;
+	u64 sas_addr;
 
 	/*--------------- SCU_Phy Initialization Stuff -----------------------*/
 
-	status = scic_controller_get_phy_handle(controller, index, &scic_phy);
+	status = scic_controller_get_phy_handle(scic, index, &scic_phy);
 	if (status == SCI_SUCCESS) {
 		sci_object_set_association(scic_phy, (void *)phy);
 		phy->sci_phy_handle = scic_phy;
@@ -90,24 +91,13 @@ void isci_phy_init(
 		dev_err(&isci_host->pdev->dev,
 			"failed scic_controller_get_phy_handle\n");
 
-	scic_oem_parameters_get(controller, &oem_parameters);
-
-	phy->sas_addr[0] =  oem_parameters.sds1.phys[index].sas_address.low
-			   & 0xFF;
-	phy->sas_addr[1] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 8)   & 0xFF;
-	phy->sas_addr[2] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 16)  & 0xFF;
-	phy->sas_addr[3] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 24)  & 0xFF;
-	phy->sas_addr[4] =  oem_parameters.sds1.phys[index].sas_address.high
-			   & 0xFF;
-	phy->sas_addr[5] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 8)  & 0xFF;
-	phy->sas_addr[6] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 16) & 0xFF;
-	phy->sas_addr[7] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 24) & 0xFF;
+	scic_oem_parameters_get(scic, &oem);
+	sas_addr = oem.sds1.phys[index].sas_address.high;
+	sas_addr <<= 32;
+	sas_addr |= oem.sds1.phys[index].sas_address.low;
+	swab64s(&sas_addr);
+
+	memcpy(phy->sas_addr, &sas_addr, sizeof(sas_addr));
 
 	phy->isci_port = NULL;
 	phy->sas_phy.enabled = 0;
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 446da20..30da3ec 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -192,6 +192,7 @@ void isci_port_link_up(
 	scic_port_get_properties(port, &properties);
 
 	if (properties.remote.protocols.u.bits.stp_target) {
+		u64 attached_sas_address;
 
 		struct scic_sata_phy_properties sata_phy_properties;
 
@@ -220,17 +221,13 @@ void isci_port_link_up(
 		 * will not be the same as assigned to the PHY and needs
 		 * to be obtained from struct scic_port_properties properties.
 		 */
+		attached_sas_address = properties.remote.sas_address.high;
+		attached_sas_address <<= 32;
+		attached_sas_address |= properties.remote.sas_address.low;
+		swab64s(&attached_sas_address);
 
-		BUG_ON(((size_t)SAS_ADDR_SIZE / 2)
-		       != sizeof(properties.remote.sas_address.low));
-
-		memcpy(&isci_phy->sas_phy.attached_sas_addr[0],
-		       &properties.remote.sas_address.low,
-		       SAS_ADDR_SIZE / 2);
-
-		memcpy(&isci_phy->sas_phy.attached_sas_addr[4],
-		       &properties.remote.sas_address.high,
-		       SAS_ADDR_SIZE / 2);
+		memcpy(&isci_phy->sas_phy.attached_sas_addr,
+		       &attached_sas_address, sizeof(attached_sas_address));
 
 	} else if (properties.remote.protocols.u.bits.ssp_target ||
 		   properties.remote.protocols.u.bits.smp_target) {
-- 
1.7.0

