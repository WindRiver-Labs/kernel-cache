From a0391dd909ccebc8baeab2569aceb5fcc6209329 Mon Sep 17 00:00:00 2001
From: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date: Thu, 15 Apr 2010 13:16:16 +0900
Subject: [PATCH 207/474] PCI: aerdrv: rework get_e_source()

commit 88da13bfabbffb8f89574eb168b9da9a0abc693f upstream

Current get_e_source() returns pointer to an element of array.
However since it also progress consume counter, it is possible
that the element is overwritten by newly produced data before
the element is really consumed.

This patch changes get_e_source() to copy contents of the element
to address pointed by its caller.  Once copied the element in
array can be consumed.

And relocate this function to more innocuous place.

Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
---
 drivers/pci/pcie/aer/aerdrv_core.c |   63 +++++++++++++++++------------------
 1 files changed, 31 insertions(+), 32 deletions(-)

diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c
index ee2769e..70514c1 100644
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -555,32 +555,6 @@ static void handle_error_source(struct pcie_device *aerdev,
 }
 
 /**
- * get_e_source - retrieve an error source
- * @rpc: pointer to the root port which holds an error
- *
- * Invoked by DPC handler to consume an error.
- */
-static struct aer_err_source *get_e_source(struct aer_rpc *rpc)
-{
-	struct aer_err_source *e_source;
-	unsigned long flags;
-
-	/* Lock access to Root error producer/consumer index */
-	spin_lock_irqsave(&rpc->e_lock, flags);
-	if (rpc->prod_idx == rpc->cons_idx) {
-		spin_unlock_irqrestore(&rpc->e_lock, flags);
-		return NULL;
-	}
-	e_source = &rpc->e_sources[rpc->cons_idx];
-	rpc->cons_idx++;
-	if (rpc->cons_idx == AER_ERROR_SOURCES_MAX)
-		rpc->cons_idx = 0;
-	spin_unlock_irqrestore(&rpc->e_lock, flags);
-
-	return e_source;
-}
-
-/**
  * get_device_error_info - read error status from dev and store it to info
  * @dev: pointer to the device expected to have a error record
  * @info: pointer to structure to store the error record
@@ -717,6 +691,34 @@ static void aer_isr_one_error(struct pcie_device *p_device,
 }
 
 /**
+ * get_e_source - retrieve an error source
+ * @rpc: pointer to the root port which holds an error
+ * @e_src: pointer to store retrieved error source
+ *
+ * Return 1 if an error source is retrieved, otherwise 0.
+ *
+ * Invoked by DPC handler to consume an error.
+ */
+static int get_e_source(struct aer_rpc *rpc, struct aer_err_source *e_src)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	/* Lock access to Root error producer/consumer index */
+	spin_lock_irqsave(&rpc->e_lock, flags);
+	if (rpc->prod_idx != rpc->cons_idx) {
+		*e_src = rpc->e_sources[rpc->cons_idx];
+		rpc->cons_idx++;
+		if (rpc->cons_idx == AER_ERROR_SOURCES_MAX)
+			rpc->cons_idx = 0;
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&rpc->e_lock, flags);
+
+	return ret;
+}
+
+/**
  * aer_isr - consume errors detected by root port
  * @work: definition of this work item
  *
@@ -726,14 +728,11 @@ void aer_isr(struct work_struct *work)
 {
 	struct aer_rpc *rpc = container_of(work, struct aer_rpc, dpc_handler);
 	struct pcie_device *p_device = rpc->rpd;
-	struct aer_err_source *e_src;
+	struct aer_err_source e_src;
 
 	mutex_lock(&rpc->rpc_mutex);
-	e_src = get_e_source(rpc);
-	while (e_src) {
-		aer_isr_one_error(p_device, e_src);
-		e_src = get_e_source(rpc);
-	}
+	while (get_e_source(rpc, &e_src))
+		aer_isr_one_error(p_device, &e_src);
 	mutex_unlock(&rpc->rpc_mutex);
 
 	wake_up(&rpc->wait_release);
-- 
1.7.0

