From b6fb621a42b8d0712c31c51f3270af0d61128f2a Mon Sep 17 00:00:00 2001
From: Murthy, Raghuveer <raghuveer.murthy@ti.com>
Date: Thu, 3 Mar 2011 09:28:00 -0600
Subject: [PATCH 079/108] OMAP4: DSS2: Using dss_features to set independent core clock divider

commit 0cf35df353e8c36d4be0da2d7483896de599f397 upstream

Using dss_features to select independent core clock divider and setting
it. Added the register used, to DISPC context save and restore group

-----------------------------------------------------------------------
In OMAP4, the minimum DISPC_CORE_CLK required can be expressed as:

	DISPC_CORE_CLK >= max(PCLK1*HSCALE1, PCLK2*HSCALE2, ...)

Where PCLKi is the pixel clock generated by MANAGERi and HSCALEi is the
maximum horizontal downscaling done through MANAGERi

Based on the usecase, core clk can be increased or decreased at runtime
to save power. Such mechanism are not yet implemented. Hence, we set the
core clock divisor to 1, to support maximum range of resolutions
------------------------------------------------------------------------

Signed-off-by: Raghuveer Murthy <raghuveer.murthy@ti.com>
Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Integrated-by: Jingdong Lu <jingdong.lu@windriver.com>
---
 drivers/video/omap2/dss/dispc.c |   24 ++++++++++++++++++++++++
 1 files changed, 24 insertions(+), 0 deletions(-)

diff --git a/drivers/video/omap2/dss/dispc.c b/drivers/video/omap2/dss/dispc.c
index a3dff5f..dae9686 100644
--- a/drivers/video/omap2/dss/dispc.c
+++ b/drivers/video/omap2/dss/dispc.c
@@ -375,6 +375,9 @@ void dispc_save_context(void)
 	SR(VID_FIR_COEF_V(1, 7));
 
 	SR(VID_PRELOAD(1));
+
+	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+		SR(DIVISOR);
 }
 
 void dispc_restore_context(void)
@@ -534,6 +537,9 @@ void dispc_restore_context(void)
 
 	RR(VID_PRELOAD(1));
 
+	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+		RR(DIVISOR);
+
 	/* enable last, because LCD & DIGIT enable are here */
 	RR(CONTROL);
 	if (dss_has_feature(FEAT_MGR_LCD2))
@@ -2380,6 +2386,7 @@ unsigned long dispc_pclk_rate(enum omap_channel channel)
 void dispc_dump_clocks(struct seq_file *s)
 {
 	int lcd, pcd;
+	u32 l;
 	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
 
 	enable_clocks(1);
@@ -2392,6 +2399,14 @@ void dispc_dump_clocks(struct seq_file *s)
 
 	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
 
+	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+		seq_printf(s, "- DISPC-CORE-CLK -\n");
+		l = dispc_read_reg(DISPC_DIVISOR);
+		lcd = FLD_GET(l, 23, 16);
+
+		seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
+				(dispc_fclk_rate()/lcd), lcd);
+	}
 	seq_printf(s, "- LCD1 -\n");
 
 	dispc_get_lcd_divisor(OMAP_DSS_CHANNEL_LCD, &lcd, &pcd);
@@ -3287,6 +3302,15 @@ static void _omap_dispc_initial_config(void)
 	l = FLD_MOD(l, 1, 0, 0);	/* AUTOIDLE */
 	dispc_write_reg(DISPC_SYSCONFIG, l);
 
+	/* Exclusively enable DISPC_CORE_CLK and set divider to 1 */
+	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+		l = dispc_read_reg(DISPC_DIVISOR);
+		/* Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */
+		l = FLD_MOD(l, 1, 0, 0);
+		l = FLD_MOD(l, 1, 23, 16);
+		dispc_write_reg(DISPC_DIVISOR, l);
+	}
+
 	/* FUNCGATED */
 	if (dss_has_feature(FEAT_FUNCGATED))
 		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
-- 
1.7.4.1

