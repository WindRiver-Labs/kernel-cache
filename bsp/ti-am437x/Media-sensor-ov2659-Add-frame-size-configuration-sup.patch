From 16aa528cec7f367004e0a8c3cd46aee0ffce8f0e Mon Sep 17 00:00:00 2001
From: Benoit Parrot <bparrot@ti.com>
Date: Tue, 4 Feb 2014 02:18:39 +0000
Subject: [PATCH 209/285] Media: sensor: ov2659: Add frame size configuration
 support

Added the capability from the following frame sizes:
	320x240
	640x480
	800x600 (default)
	1024X768
	1280X720
	1280X1024
	1600X1200

Signed-off-by: Benoit Parrot <bparrot@ti.com>
Signed-off-by: Darren Etheridge <detheridge@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/media/i2c/ov2659.c |  473 ++++++++++++++++++++++----------------------
 1 files changed, 232 insertions(+), 241 deletions(-)

diff --git a/drivers/media/i2c/ov2659.c b/drivers/media/i2c/ov2659.c
index 85d788c..3024210 100644
--- a/drivers/media/i2c/ov2659.c
+++ b/drivers/media/i2c/ov2659.c
@@ -342,11 +342,9 @@ static const struct sensor_register ov2659_init_regs[] = {
 	{0x4702, 0x02}, /* DVP Debug mode ?? */
 	{0x370c, 0x34}, /* ?? */
 
-	 /* With 15Mhz input clock (0x39) should yield 72Mhz pixel clock
-	  * With 25Mhz input clock (0x22) should yield 70.83MHz (epos-evm)
-	  * With 12Mhz input clock (0x22) should yield 34MHz (gp-evm) */
 	{0x3004, 0x10}, /* System Divider */
 	{0x3005, 0x22}, /* Pixel clock Multiplier */
+
 	{0x3800, 0x00}, /* TIMING */
 	{0x3801, 0x00}, /* TIMING */
 	{0x3802, 0x00}, /* TIMING */
@@ -357,23 +355,10 @@ static const struct sensor_register ov2659_init_regs[] = {
 	{0x3807, 0xb7}, /* TIMING */
 
 	/* 800 x 600 */
-/*	{0x3808, 0x03}, */  /* Horizontal High Byte */
-/*	{0x3809, 0x20}, */  /* Horizontal Low Byte */
-/*	{0x380a, 0x02}, */  /* Vertical High Byte */
-/*	{0x380b, 0x58}, */  /* Vertical Low Byte */
-	/* 640 x 480 */
-/*	{0x3808, 0x02}, */  /* Horizontal High Byte */
-/*	{0x3809, 0x80}, */  /* Horizontal Low Byte */
-/*	{0x380a, 0x01}, */  /* Vertical High Byte */
-/*	{0x380b, 0xe0}, */  /* Vertical Low Byte */
-
-	/* horizontal output */
-	{REG_TIMING_DVPHO_H, (800>>8)&0xff},
-	{REG_TIMING_DVPHO_L, (800>>0)&0xff},
-	/* vertical output */
-	{REG_TIMING_DVPVO_H, (600>>8)&0xff},
-	{REG_TIMING_DVPVO_L, (600>>0)&0xff},
-
+	{0x3808, 0x03}, /* Horizontal High Byte */
+	{0x3809, 0x20}, /* Horizontal Low Byte */
+	{0x380a, 0x02}, /* Vertical High Byte */
+	{0x380b, 0x58}, /* Vertical Low Byte */
 	{0x380c, 0x05}, /* TIMING */
 	{0x380d, 0x14}, /* TIMING */
 	{0x380e, 0x02}, /* TIMING */
@@ -405,14 +390,6 @@ static const struct sensor_register ov2659_init_regs[] = {
 	{0x370a, 0x52}, /* ?? */
 	{0x4608, 0x00}, /* VFIFO */
 	{0x4609, 0x80}, /* VFIFO */
-	/* Output Format Configuration
-	 * 0x00 -- RAW Bayer BGGR <== Verified
-	 * 0x30 -- YUV422 YUYV    <== Verified
-	 * 0x32 -- YUV422 UYVY    <== Verified
-	 * 0x40 -- YUV420         <== Does not appear to be supported
-	 * 0x50 -- YUV420 Legacy  <== Does not appear to be supported
-	 * 0x60 -- RGB565         <== Not Verified yet
-	 */
 	{0x4300, 0x30}, /* Format */
 	{0x5086, 0x02}, /* ?? */
 	{0x5000, 0xfb}, /* DPC/ISP */
@@ -518,29 +495,13 @@ static const struct sensor_register ov2659_init_regs[] = {
 	{0x5061, 0x7d}, /* Y AVG */
 	{0x5062, 0x7d}, /* Y AVG */
 	{0x5063, 0x69}, /* Y AVG */
-/*	{0x3004, 0x20}, */
 /*	{REG_ISP_PRE_CTRL00, 0x80}, */ /* Enable Test Pattern: ColorBar */
 
-		{0x0100, 0x01}, /* SOFTWARE STANDBY - Start Streaming */
 	{0xffff, 0x00}
 };
 
 /* 1280x720 720p */
 static struct sensor_register ov2659_720p[] = {
-	{0x0103, 0x01},
-	{0x3000, 0x0f},
-	{0x3001, 0xff},
-	{0x3002, 0xff},
-
-	{0x3633, 0x3d},
-	{0x3620, 0x02},
-	{0x3631, 0x11},
-	{0x3612, 0x04},
-	{0x3630, 0x20},
-	{0x4702, 0x02},
-	{0x370c, 0x34},
-	{0x3004, 0x10},
-	{0x3005, 0x24},
 	{0x3800, 0x00},
 	{0x3801, 0xa0},
 	{0x3802, 0x00},
@@ -561,134 +522,12 @@ static struct sensor_register ov2659_720p[] = {
 	{0x3813, 0x06},
 	{0x3814, 0x11},
 	{0x3815, 0x11},
-	{0x3a02, 0x02},
+	{0x3820, 0x80},
+	{0x3821, 0x00},
 	{0x3a03, 0xe8},
-	{0x3a08, 0x00},
 	{0x3a09, 0x6f},
-	{0x3a0a, 0x00},
 	{0x3a0b, 0x5d},
-	{0x3a0d, 0x08},
-	{0x3a0e, 0x06},
-	{0x3a14, 0x02},
 	{0x3a15, 0x9a},
-	    {0x4708, 0x01},
-	{0x3623, 0x02},
-	{0x3634, 0x44},
-	{0x3701, 0x41},
-	{0x3702, 0x30},
-	{0x3703, 0x48},
-	{0x3704, 0x48},
-	{0x3705, 0x18},
-	{0x3820, 0x80},
-	{0x3821, 0x00},
-	{0x370a, 0x12},
-	{0x4608, 0x00},
-	{0x4609, 0x80},
-	{0x4300, 0x32},
-	{0x5086, 0x02},
-	{0x5000, 0xfb},
-	{0x5001, 0x1f},
-	{0x5002, 0x00},
-	{0x5025, 0x0e},
-	{0x5026, 0x18},
-	{0x5027, 0x34},
-	{0x5028, 0x4c},
-	{0x5029, 0x62},
-	{0x502a, 0x74},
-	{0x502b, 0x85},
-	{0x502c, 0x92},
-	{0x502d, 0x9e},
-	{0x502e, 0xb2},
-	{0x502f, 0xc0},
-	{0x5030, 0xcc},
-	{0x5031, 0xe0},
-	{0x5032, 0xee},
-	{0x5033, 0xf6},
-	{0x5034, 0x11},
-	{0x5070, 0x1c},
-	{0x5071, 0x5b},
-	{0x5072, 0x05},
-	{0x5073, 0x20},
-	{0x5074, 0x94},
-	{0x5075, 0xb4},
-	{0x5076, 0xb4},
-	{0x5077, 0xaf},
-	{0x5078, 0x05},
-	{0x5079, 0x98},
-	{0x507a, 0x21},
-	{0x5035, 0x6a},
-	{0x5036, 0x11},
-	{0x5037, 0x92},
-	{0x5038, 0x21},
-	{0x5039, 0xe1},
-	{0x503a, 0x01},
-	{0x503c, 0x05},
-	{0x503d, 0x08},
-	{0x503e, 0x08},
-	{0x503f, 0x64},
-	{0x5040, 0x58},
-	{0x5041, 0x2a},
-	{0x5042, 0xc5},
-	{0x5043, 0x2e},
-	{0x5044, 0x3a},
-	{0x5045, 0x3c},
-	{0x5046, 0x44},
-	{0x5047, 0xf8},
-	{0x5048, 0x08},
-	{0x5049, 0x70},
-	{0x504a, 0xf0},
-	{0x504b, 0xf0},
-	{0x500c, 0x03},
-	{0x500d, 0x20},
-	{0x500e, 0x02},
-	{0x500f, 0x5c},
-	{0x5010, 0x48},
-	{0x5011, 0x00},
-	{0x5012, 0x66},
-	{0x5013, 0x03},
-	{0x5014, 0x30},
-	{0x5015, 0x02},
-	{0x5016, 0x7c},
-	{0x5017, 0x40},
-	{0x5018, 0x00},
-	{0x5019, 0x66},
-	{0x501a, 0x03},
-	{0x501b, 0x10},
-	{0x501c, 0x02},
-	{0x501d, 0x7c},
-	{0x501e, 0x3a},
-	{0x501f, 0x00},
-	{0x5020, 0x66},
-	{0x506e, 0x44},
-	{0x5064, 0x08},
-	{0x5065, 0x10},
-	{0x5066, 0x12},
-	{0x5067, 0x02},
-	{0x506c, 0x08},
-	{0x506d, 0x10},
-	{0x506f, 0xa6},
-	{0x5068, 0x08},
-	{0x5069, 0x10},
-	{0x506a, 0x04},
-	{0x506b, 0x12},
-	{0x507e, 0x40},
-	{0x507f, 0x20},
-	{0x507b, 0x02},
-	{0x507a, 0x01},
-	{0x5084, 0x0c},
-	{0x5085, 0x3e},
-	{0x5005, 0x80},
-	{0x3a0f, 0x30},
-	{0x3a10, 0x28},
-	{0x3a1b, 0x32},
-	{0x3a1e, 0x26},
-	{0x3a11, 0x60},
-	{0x3a1f, 0x14},
-	{0x5060, 0x69},
-	{0x5061, 0x7d},
-	{0x5062, 0x7d},
-	{0x5063, 0x69},
-	{0x0100, 0x01},
 	{0xffff, 0x00}
 };
 
@@ -737,22 +576,105 @@ static struct sensor_register ov2659_uxga[] = {
 	{0x4608, 0x00},
 	{0x4609, 0x80},
 	{0x5002, 0x00},
-	{0x3005, 0x24},
-	{0x3004, 0x20},
 	{0xffff, 0x00}
 };
 
 /* 1280X1024 SXGA */
 static struct sensor_register ov2659_sxga[] = {
-	{0xffff, 0x0}
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x04},
+	{0x380b, 0x00},
+	{0x380c, 0x07},
+	{0x380d, 0x9c},
+	{0x380e, 0x04},
+	{0x380f, 0xd0},
+	{0x3811, 0x10},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x80},
+	{0x3821, 0x00},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x5002, 0x00},
+	{0xffff, 0x00}
 };
 /* 1024X768 SXGA */
 static struct sensor_register ov2659_xga[] = {
-	{0xffff, 0x0}
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x04},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x00},
+	{0x380c, 0x07},
+	{0x380d, 0x9c},
+	{0x380e, 0x04},
+	{0x380f, 0xd0},
+	{0x3811, 0x10},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x80},
+	{0x3821, 0x00},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x5002, 0x00},
+	{0xffff, 0x00}
 };
 /* 800X600 SVGA*/
 static struct sensor_register ov2659_svga[] = {
-		{0x0100, 0x00},
 	{0x3800, 0x00},
 	{0x3801, 0x00},
 	{0x3802, 0x00},
@@ -795,21 +717,104 @@ static struct sensor_register ov2659_svga[] = {
 	{0x370a, 0x52},
 	{0x4608, 0x00},
 	{0x4609, 0x80},
-	{0x5002, 0x10},
-	{0x3005, 0x18},
-	{0x3004, 0x20},
-		{0x0100, 0x01},
+	{0x5002, 0x00},
 	{0xffff, 0x00}
 };
 
 /* 640X480 VGA */
 static struct sensor_register ov2659_vga[] = {
-	{0xffff, 0x0}
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x02},
+	{0x3809, 0x80},
+	{0x380a, 0x01},
+	{0x380b, 0xe0},
+	{0x380c, 0x05},
+	{0x380d, 0x14},
+	{0x380e, 0x02},
+	{0x380f, 0x68},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x81},
+	{0x3821, 0x01},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x5002, 0x10},
+	{0xffff, 0x00}
 };
 
 /* 320*240 QVGA */
 static  struct sensor_register ov2659_qvga[] = {
-	{0xffff, 0x0}
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x01},
+	{0x3809, 0x40},
+	{0x380a, 0x00},
+	{0x380b, 0xf0},
+	{0x380c, 0x05},
+	{0x380d, 0x14},
+	{0x380e, 0x02},
+	{0x380f, 0x68},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x81},
+	{0x3821, 0x01},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x5002, 0x10},
+	{0xffff, 0x00}
 };
 
 static const struct ov2659_framesize ov2659_framesizes[] = {
@@ -1220,40 +1225,25 @@ static void __ov2659_set_power(struct ov2659 *ov2659, int on)
 	struct i2c_client *client = ov2659->client;
 
 	dev_dbg(&client->dev, "%s: on: %d\n", __func__, on);
+	on = (on) ? 1 : 0;
+
+	if (ov2659->power == on)
+		return;
+
+	ov2659->power = on;
 }
 
 static int ov2659_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct ov2659 *ov2659 = to_ov2659(sd);
 	struct i2c_client *client = ov2659->client;
-	int ret = 0;
 
 	dev_dbg(&client->dev, "%s: on: %d\n", __func__, on);
 
 	mutex_lock(&ov2659->lock);
-	if (ov2659->power == !on) {
-		__ov2659_set_power(ov2659, on);
-		if (on) {
-			ov2659_set_streaming(ov2659, 0);
-			ret = ov2659_write_array(client,
-						 ov2659_init_regs);
-
-			ov2659_set_pixel_clock(ov2659);
-
-			ov2659_set_streaming(ov2659, 1);
-
-			ov2659_reg_dump(client);
-
-			ov2659->apply_frame_fmt = 1;
-			ov2659->ctrls.update = 1;
-		}
-	}
-	if (!ret)
-		ov2659->power += on ? 1 : -1;
-
-	WARN_ON(ov2659->power < 0);
+	__ov2659_set_power(ov2659, on);
 	mutex_unlock(&ov2659->lock);
-	return ret;
+	return 0;
 }
 
 /*
@@ -1514,7 +1504,7 @@ static int ov2659_enum_frame_sizes(struct v4l2_subdev *sd,
 
 	dev_dbg(&client->dev, "%s:\n", __func__);
 
-	if (fse->index > ARRAY_SIZE(ov2659_framesizes))
+	if (fse->index >= ARRAY_SIZE(ov2659_framesizes))
 		return -EINVAL;
 
 	while (--i)
@@ -1684,7 +1674,6 @@ static int ov2659_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 			ov2659->format = fmt->format;
 			ov2659->format_ctrl_regs =
 				ov2659_formats[index].format_ctrl_regs;
-			ov2659->apply_frame_fmt = 1;
 		}
 	}
 
@@ -1705,6 +1694,8 @@ static int ov2659_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 
 static int ov2659_set_frame_size(struct ov2659 *ov2659)
 {
+	struct i2c_client *client = ov2659->client;
+	dev_dbg(&client->dev, "%s\n", __func__);
 	return ov2659_write_array(ov2659->client,
 					ov2659->frame_size->regs);
 }
@@ -1717,23 +1708,6 @@ static int ov2659_set_format(struct ov2659 *ov2659)
 					ov2659->format_ctrl_regs);
 }
 
-static int __ov2659_set_params(struct ov2659 *ov2659)
-{
-	int ret = 0;
-
-	if (ov2659->apply_frame_fmt) {
-		ret = ov2659_set_frame_size(ov2659);
-		if (ret < 0)
-			return ret;
-
-		ret = ov2659_set_format(ov2659);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
 static int ov2659_s_stream(struct v4l2_subdev *sd, int on)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -1743,33 +1717,50 @@ static int ov2659_s_stream(struct v4l2_subdev *sd, int on)
 
 	dev_dbg(&client->dev, "%s: on: %d\n", __func__, on);
 
+	if (ov2659->streaming == on)
+		return 0;
+
 	mutex_lock(&ov2659->lock);
-	if (ov2659->streaming == !on) {
-		if (on)
-			ret = __ov2659_set_params(ov2659);
+	switch (on) {
+	case 0:
+		/* Stop Streaming Sequence */
+		ov2659_set_streaming(ov2659, 0);
+		ov2659->streaming = on;
+		__ov2659_set_power(ov2659, 0);
+		break;
+
+	case 1:
+		/* Start Streaming Sequence */
+		__ov2659_set_power(ov2659, 1);
+
+		/* 1st make sure we are not streaming */
+		ov2659_set_streaming(ov2659, 0);
+		/* Something may changed in the config so re-load it */
+		ret = ov2659_write_array(client, ov2659_init_regs);
+
+		ov2659_set_pixel_clock(ov2659);
+		ov2659_set_frame_size(ov2659);
+		ov2659_set_format(ov2659);
 
+		/*
+		 * ov2659_s_ctrl callback takes the mutex
+		 * so it needs to be released here.
+		 */
 		mutex_unlock(&ov2659->lock);
-		ov2659_s_power(sd, on);
+		ret = v4l2_ctrl_handler_setup(&ctrls->handler);
 		mutex_lock(&ov2659->lock);
-		if (!ret && ctrls->update) {
-			/*
-			 * ov2659_s_ctrl callback takes the mutex
-			 * so it needs to be released here.
-			 */
-			mutex_unlock(&ov2659->lock);
-			ret = v4l2_ctrl_handler_setup(&ctrls->handler);
-
-			mutex_lock(&ov2659->lock);
-			if (!ret)
-				ctrls->update = 0;
-		}
+
+		ov2659_set_streaming(ov2659, 1);
+
+		ov2659_reg_dump(client);
+		ov2659->streaming = on;
+		break;
+
+	default:
+		ret = -EINVAL;
 	}
-	if (!ret)
-		ov2659->streaming += on ? 1 : -1;
 
-	WARN_ON(ov2659->streaming < 0);
 	mutex_unlock(&ov2659->lock);
-
 	return ret;
 }
 
-- 
1.7.5.4

