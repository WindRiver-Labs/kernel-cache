From 2309ba8a81cb85a96f21eb85db612bc4be083746 Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Tue, 17 Dec 2013 17:57:11 +0530
Subject: [PATCH 269/285] bus: omap_l3_noc: fix unclearable error handling

Errors that cannot be cleared (determined by reading status register)
are currently handled by masking it. Status register is understood to be
raw status rather than result of masking, based on recent issue reported
by Vaibhav Hiremath (I could not make out from the documentation that it
is raw status).

As that is the case, if after the occurance of an unclearable error,
another clearable L3 error happens that has lower binary weightage in
flagmux register (compared to the unclearable error that has occured),
and as status register is raw, isr will think that interrupt is raised
due to unclearable error(even though it was masked). This causes the new
error that could have been cleared, uncleared, resulting in isr getting
called repeatedly.

Fix it by masking raw status with masked ones before handling the error.

Reported-by: Vaibhav Hiremath <hvaibhav@ti.com>
Signed-off-by: Afzal Mohammed <afzal@ti.com>
Tested-by: Vaibhav Hiremath <hvaibhav@gmail.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/bus/omap_l3_noc.c |    6 ++++++
 drivers/bus/omap_l3_noc.h |    1 +
 2 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 9ecdc40..3771e97 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -64,6 +64,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	u32 std_err_main, err_reg, clear, masterid;
 	void __iomem *base, *l3_targ_base;
 	char *target_name, *master_name = "UN IDENTIFIED";
+	static u32 mask0[MAX_L3_MODULES], mask1[MAX_L3_MODULES];
 
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
@@ -76,6 +77,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		base = l3->l3_base[i];
 		err_reg = __raw_readl(base + l3->l3_flag_mux[i] +
 					+ L3_FLAGMUX_REGERR0 + (inttype << 3));
+		err_reg &= inttype ? ~mask1[i] : ~mask0[i];
 
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
@@ -94,6 +96,10 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					err_src, i, "(unclearable)");
 				val = readl(reg);
 				val &= ~(1 << err_src);
+				if (inttype)
+					mask1[i] |= (1 << err_src);
+				else
+					mask0[i] |= (1 << err_src);
 				writel(val, reg);
 				break;
 			}
diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 0f24e4f..e9739e3 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -25,6 +25,7 @@
 
 #define AM4372_L3_MODULES		2
 #define OMAP_L3_MODULES			3
+#define MAX_L3_MODULES			OMAP_L3_MODULES
 #define CLEAR_STDERR_LOG		(1 << 31)
 #define CUSTOM_ERROR			0x2
 #define STANDARD_ERROR			0x0
-- 
1.7.5.4

