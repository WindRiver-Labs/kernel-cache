From 1ba2819016943f5f753b8070c95377731bea9143 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Mon, 23 Sep 2013 17:36:29 +0300
Subject: [PATCH 040/285] phy: omap-usb3: Use generic clock names

As clocks might be named differently on multiple platforms, use a generic
name in the driver and allow device tree node to specify the platform
specific clock name.

Also update device tree binding information.

Signed-off-by: Roger Quadros <rogerq@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 Documentation/devicetree/bindings/usb/usb-phy.txt |    3 ++
 drivers/usb/phy/phy-omap-usb3.c                   |   25 +++++++++++++++++---
 include/linux/usb/omap_usb.h                      |    1 +
 3 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/Documentation/devicetree/bindings/usb/usb-phy.txt b/Documentation/devicetree/bindings/usb/usb-phy.txt
index de6d0ce..036623e 100644
--- a/Documentation/devicetree/bindings/usb/usb-phy.txt
+++ b/Documentation/devicetree/bindings/usb/usb-phy.txt
@@ -9,6 +9,9 @@ Required properties:
    filled in "reg".
  - #phy-cells: determine the number of cells that should be given in the
    phandle while referencing this phy.
+ - clocks: phandle to PHY clocks i.e. 32KHz wakup clock, 960MHz clock and lfps clock.
+   Use as per Documentation/devicetree/bindings/clock/clock-bindings.txt
+ - clock-names: should contain "wkupclk", "refclk1" and "refclk2"
 
 Optional properties:
  - ctrl-module : phandle of the control module used by PHY driver to power on
diff --git a/drivers/usb/phy/phy-omap-usb3.c b/drivers/usb/phy/phy-omap-usb3.c
index 84e2c30..b94b76c 100644
--- a/drivers/usb/phy/phy-omap-usb3.c
+++ b/drivers/usb/phy/phy-omap-usb3.c
@@ -226,20 +226,27 @@ static int omap_usb3_probe(struct platform_device *pdev)
 	phy->phy.type		= USB_PHY_TYPE_USB3;
 
 	phy->is_suspended	= 1;
-	phy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");
+	phy->wkupclk = devm_clk_get(phy->dev, "wkupclk");
 	if (IS_ERR(phy->wkupclk)) {
-		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
+		dev_err(&pdev->dev, "unable to get wkupclk\n");
 		return PTR_ERR(phy->wkupclk);
 	}
 	clk_prepare(phy->wkupclk);
 
-	phy->optclk = devm_clk_get(phy->dev, "usb_otg_ss_refclk960m");
+	phy->optclk = devm_clk_get(phy->dev, "refclk");
 	if (IS_ERR(phy->optclk)) {
-		dev_err(&pdev->dev, "unable to get usb_otg_ss_refclk960m\n");
+		dev_err(&pdev->dev, "unable to get refclk\n");
 		return PTR_ERR(phy->optclk);
 	}
 	clk_prepare(phy->optclk);
 
+	phy->optclk2 = devm_clk_get(phy->dev, "refclk2");
+	if (IS_ERR(phy->optclk2)) {
+		dev_err(&pdev->dev, "unable to get refclk2\n");
+		return PTR_ERR(phy->optclk2);
+	}
+	clk_prepare(phy->optclk2);
+
 	phy->sys_clk = devm_clk_get(phy->dev, "sys_clkin");
 	if (IS_ERR(phy->sys_clk)) {
 		pr_err("%s: unable to get sys_clkin\n", __func__);
@@ -276,6 +283,7 @@ static int omap_usb3_remove(struct platform_device *pdev)
 
 	clk_unprepare(phy->wkupclk);
 	clk_unprepare(phy->optclk);
+	clk_unprepare(phy->optclk2);
 	usb_remove_phy(&phy->phy);
 	if (!pm_runtime_suspended(&pdev->dev))
 		pm_runtime_put(&pdev->dev);
@@ -293,6 +301,7 @@ static int omap_usb3_runtime_suspend(struct device *dev)
 
 	clk_disable(phy->wkupclk);
 	clk_disable(phy->optclk);
+	clk_disable(phy->optclk2);
 
 	return 0;
 }
@@ -315,8 +324,16 @@ static int omap_usb3_runtime_resume(struct device *dev)
 		goto err2;
 	}
 
+	ret = clk_enable(phy->optclk2);
+	if (ret) {
+		dev_err(phy->dev, "Failed to enable optclk2 %d\n", ret);
+		goto err3;
+	}
+
 	return 0;
 
+err3:
+	clk_disable(phy->wkupclk);
 err2:
 	clk_disable(phy->optclk);
 
diff --git a/include/linux/usb/omap_usb.h b/include/linux/usb/omap_usb.h
index 6ae2936..3e67eb1 100644
--- a/include/linux/usb/omap_usb.h
+++ b/include/linux/usb/omap_usb.h
@@ -39,6 +39,7 @@ struct omap_usb {
 	struct clk		*wkupclk;
 	struct clk		*sys_clk;
 	struct clk		*optclk;
+	struct clk		*optclk2;
 	u8			is_suspended:1;
 };
 
-- 
1.7.5.4

