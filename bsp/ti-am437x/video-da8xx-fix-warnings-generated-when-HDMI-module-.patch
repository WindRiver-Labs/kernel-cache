From 54263b471ca829db6d474b60c7ea4a9e3dec9992 Mon Sep 17 00:00:00 2001
From: Darren Etheridge <detheridge@ti.com>
Date: Wed, 2 Oct 2013 10:40:17 -0500
Subject: [PATCH 080/285] video: da8xx: fix warnings generated when HDMI
 module is enabled

Remove the #ifdef's and clean up how modules are handled vs builtin
this eliminates the warnings and makes the code much cleaner and
easier to follow.
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/video/da8xx-fb.c           |  117 +++++++++++++++++------------------
 drivers/video/da8xx-tda998x-hdmi.c |   22 -------
 2 files changed, 57 insertions(+), 82 deletions(-)

diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 150b342..8266eae 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -796,8 +796,8 @@ static int da8xx_fb_config_clk_divider(struct da8xx_fb_par *par,
 }
 
 static unsigned int da8xx_fb_calc_clk_divider(struct da8xx_fb_par *par,
-					      unsigned pixclock,
-					      unsigned *lcdc_clk_rate)
+			      unsigned pixclock,
+			      unsigned *lcdc_clk_rate)
 {
 	unsigned lcdc_clk_div;
 
@@ -831,7 +831,7 @@ static int da8xx_fb_calc_config_clk_divider(struct da8xx_fb_par *par,
 }
 
 static unsigned da8xx_fb_round_clk(struct da8xx_fb_par *par,
-					  unsigned pixclock)
+				  unsigned pixclock)
 {
 	unsigned lcdc_clk_div, lcdc_clk_rate;
 
@@ -844,54 +844,54 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 {
 	u32 bpp;
 	int ret = 0;
-
-#if !defined(CONFIG_FB_DA8XX_TDA998X) && \
-	!defined(CONFIG_FB_DA8XX_TDA998X_MODULE)
-	/*
-	 * Not using external encoder, using old and more inaccurate method of
-	 * setting the clocks
-	 */
-	ret = da8xx_fb_calc_config_clk_divider(par, panel);
-	if (IS_ERR_VALUE(ret)) {
-		dev_err(par->dev, "unable to configure clock\n");
-		return ret;
-	}
-#else /* if CONFIG_FB_DA8XX_TDA998X */
-	unsigned int div = 0;
-	unsigned long pixclock = 0;
 	struct da8xx_encoder *enc = 0;
 
-	pr_debug("pixclock from panel %d\n", panel->pixclock);
-	pixclock = PICOS2KHZ(panel->pixclock) * 1000;
-	pr_debug("pixclock converted to hz %ld\n", pixclock);
-	/* remove any rounding errors as this seems to mess up clk */
-	pixclock = (pixclock/10000)*10000;
-	pr_debug("rounded clock rate %ld\n",
-		clk_round_rate(par->lcdc_clk, pixclock*2));
-	/* in raster mode, minimum divisor is 2: */
-	ret = clk_set_rate(par->disp_clk, pixclock * 2);
-	if (IS_ERR_VALUE(ret)) {
-		dev_err(par->dev, "failed to set display clock rate to: %ld\n",
-			pixclock);
-		return ret;
-	}
+	if (IS_ENABLED(CONFIG_FB_DA8XX_TDA998X) && par->hdmi_node) {
+		unsigned int div = 0;
+		unsigned long pixclock = 0;
+
+		pr_debug("pixclock from panel %d\n", panel->pixclock);
+		pixclock = PICOS2KHZ(panel->pixclock) * 1000;
+		pr_debug("pixclock converted to hz %ld\n", pixclock);
+		/* remove any rounding errors as this seems to mess up clk */
+		pixclock = (pixclock/10000)*10000;
+		pr_debug("rounded clock rate %ld\n",
+			clk_round_rate(par->lcdc_clk, pixclock*2));
+		/* in raster mode, minimum divisor is 2: */
+		ret = clk_set_rate(par->disp_clk, pixclock * 2);
+		if (IS_ERR_VALUE(ret)) {
+			dev_err(par->dev, "failed to set display clock rate to: %ld\n",
+				pixclock);
+			return ret;
+		}
 
-	par->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);
-	div = par->lcdc_clk_rate / pixclock;
+		par->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);
+		div = par->lcdc_clk_rate / pixclock;
 
-	pr_debug("lcd_clk=%u, mode clock=%ld, div=%u\n",
-		par->lcdc_clk_rate, pixclock, div);
-	pr_debug("fck=%lu, dpll_disp_ck=%lu\n",
-		clk_get_rate(par->lcdc_clk), clk_get_rate(par->disp_clk));
+		pr_debug("lcd_clk=%u, mode clock=%ld, div=%u\n",
+			par->lcdc_clk_rate, pixclock, div);
+		pr_debug("fck=%lu, dpll_disp_ck=%lu\n",
+			clk_get_rate(par->lcdc_clk),
+			clk_get_rate(par->disp_clk));
 
-	/* Configure the LCD clock divisor. */
-	lcdc_write(LCD_CLK_DIVISOR(div) |
-		(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);
+		/* Configure the LCD clock divisor. */
+		lcdc_write(LCD_CLK_DIVISOR(div) |
+			(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);
 
-	if (lcd_revision == LCD_VERSION_2)
-		lcdc_write(LCD_V2_DMA_CLK_EN | LCD_V2_LIDD_CLK_EN |
-			LCD_V2_CORE_CLK_EN, LCD_CLK_ENABLE_REG);
-#endif
+		if (lcd_revision == LCD_VERSION_2)
+			lcdc_write(LCD_V2_DMA_CLK_EN | LCD_V2_LIDD_CLK_EN |
+				LCD_V2_CORE_CLK_EN, LCD_CLK_ENABLE_REG);
+	} else {
+		/*
+		 * Not using external encoder, using old and more inaccurate
+		 * method of setting the clocks.
+		 */
+		ret = da8xx_fb_calc_config_clk_divider(par, panel);
+		if (IS_ERR_VALUE(ret)) {
+			dev_err(par->dev, "unable to configure clock\n");
+			return ret;
+		}
+	}
 
 	if (panel->sync & FB_SYNC_CLK_INVERT)
 		lcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) |
@@ -932,17 +932,16 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 	lcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |
 		       (cfg->fdd << 12), LCD_RASTER_CTRL_REG);
 
-#if defined(CONFIG_FB_DA8XX_TDA998X_MODULE) || defined(CONFIG_FB_DA8XX_TDA998X)
-	/*
-	 * keep doing this lookup, because there is a posibility that
-	 * somebody went and unloaded the encoder driver from out beneath
-	 * us
-	 */
-	enc = da8xx_get_encoder_from_phandle(par->hdmi_node);
-	if (enc)
-		enc->set_mode(enc, panel);
-#endif
-
+	if (IS_ENABLED(CONFIG_FB_DA8XX_TDA998X) && par->hdmi_node) {
+		/*
+		 * keep doing this lookup, because there is a posibility that
+		 * somebody went and unloaded the encoder driver from out
+		 * beneath us
+		 */
+		enc = da8xx_get_encoder_from_phandle(par->hdmi_node);
+		if (enc)
+			enc->set_mode(enc, panel);
+	}
 	return 0;
 }
 
@@ -1183,15 +1182,13 @@ static int fb_check_var(struct fb_var_screeninfo *var,
 	if (var->yres + var->yoffset > var->yres_virtual)
 		var->yoffset = var->yres_virtual - var->yres;
 
-#if !defined(CONFIG_FB_DA8XX_TDA998X) && \
-	!defined(CONFIG_FB_DA8XX_TDA998X_MODULE)
 	/*
 	 * if we don't have an encoder attached, use the legacy
 	 * clock setting code that works on da8xx but is a bit
 	 * inaccurate for the encoders on AM335x
 	 */
-	var->pixclock = da8xx_fb_round_clk(par, var->pixclock);
-#endif
+	if (!IS_ENABLED(CONFIG_FB_DA8XX_TDA998X) || (par->hdmi_node == 0))
+		var->pixclock = da8xx_fb_round_clk(par, var->pixclock);
 
 	return err;
 }
diff --git a/drivers/video/da8xx-tda998x-hdmi.c b/drivers/video/da8xx-tda998x-hdmi.c
index d5faf36..c10a787 100644
--- a/drivers/video/da8xx-tda998x-hdmi.c
+++ b/drivers/video/da8xx-tda998x-hdmi.c
@@ -345,28 +345,6 @@ cec_write(struct tda998x_encoder *encoder, uint16_t addr, uint8_t val)
 			ret, addr);
 }
 
-static uint8_t
-cec_read(struct tda998x_encoder *encoder, uint8_t addr)
-{
-	struct i2c_client *client = to_tda998x_priv(encoder)->cec;
-	uint8_t val;
-	int ret;
-
-	ret = i2c_master_send(client, &addr, sizeof(addr));
-	if (ret < 0)
-		goto fail;
-
-	ret = i2c_master_recv(client, &val, sizeof(val));
-	if (ret < 0)
-		goto fail;
-
-	return val;
-
-fail:
-	dev_err(&client->dev, "Error %d reading from cec:0x%x\n", ret, addr);
-	return 0;
-}
-
 static void
 set_page(struct tda998x_encoder *encoder, uint16_t reg)
 {
-- 
1.7.5.4

