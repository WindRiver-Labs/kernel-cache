From d979af27588997f81f794dc27b625317fa07ac5b Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Tue, 24 Sep 2013 20:48:36 -0500
Subject: [PATCH 150/188] mailbox/omap: add registration support for multiple
 instances

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

The omap mailbox core currently keeps a global list of registered
mailboxes, and as such stores only the mailboxes from the last
registered mailbox IP instance. DRA7 is the first SoC where multiple
mailbox IP instances are present, and the mailbox clients are unable
to request mailbox devices present in any of earlier registered
IP instances.

The core registration logic is enhanced to support storing mailboxes
from multiple IP instances now. This is achieved by maintaining a list
of the mailbox IP instances, and storing the mailboxes per mailbox
instance. This allows the mailbox clients to successfully use a
mailbox from any IP instance.

Signed-off-by: Suman Anna <s-anna@ti.com>
(cherry picked from commit 4424376232378dba85fcb87777365c8a011ee3b3)
---
 drivers/mailbox/mailbox-omap1.c |    4 +-
 drivers/mailbox/mailbox-omap2.c |    4 +-
 drivers/mailbox/omap-mailbox.c  |   55 ++++++++++++++++++++++++++++++--------
 drivers/mailbox/omap-mbox.h     |    5 ++-
 4 files changed, 50 insertions(+), 18 deletions(-)

diff --git a/drivers/mailbox/mailbox-omap1.c b/drivers/mailbox/mailbox-omap1.c
index 0f874e0..97ecb83 100644
--- a/drivers/mailbox/mailbox-omap1.c
+++ b/drivers/mailbox/mailbox-omap1.c
@@ -188,7 +188,7 @@ static int omap1_mbox_probe(struct platform_device *pdev)
 	mdev->num_users = 2;
 	mdev->num_fifos = 4;
 
-	ret = omap_mbox_register(&pdev->dev, list);
+	ret = omap_mbox_register(mdev);
 	if (ret) {
 		iounmap(mdev->mbox_base);
 		return ret;
@@ -201,7 +201,7 @@ static int omap1_mbox_remove(struct platform_device *pdev)
 {
 	struct omap_mbox_device *mdev = &omap1_mbox_device;
 
-	omap_mbox_unregister();
+	omap_mbox_unregister(mdev);
 	iounmap(mdev->mbox_base);
 	mdev->mbox_base = NULL;
 	mdev->mboxes = NULL;
diff --git a/drivers/mailbox/mailbox-omap2.c b/drivers/mailbox/mailbox-omap2.c
index 7ef338e..8c808fb 100644
--- a/drivers/mailbox/mailbox-omap2.c
+++ b/drivers/mailbox/mailbox-omap2.c
@@ -317,7 +317,7 @@ static int omap2_mbox_probe(struct platform_device *pdev)
 	mdev->num_users = pdata->num_users;
 	mdev->num_fifos = pdata->num_fifos;
 	mdev->mboxes = list;
-	ret = omap_mbox_register(&pdev->dev, list);
+	ret = omap_mbox_register(mdev);
 	if (ret)
 		goto unmap_mbox;
 	platform_set_drvdata(pdev, mdev);
@@ -349,7 +349,7 @@ static int omap2_mbox_remove(struct platform_device *pdev)
 	pm_runtime_disable(mdev->dev);
 
 	privblk = mboxblk->priv;
-	omap_mbox_unregister();
+	omap_mbox_unregister(mdev);
 	iounmap(mdev->mbox_base);
 	kfree(privblk);
 	kfree(mboxblk);
diff --git a/drivers/mailbox/omap-mailbox.c b/drivers/mailbox/omap-mailbox.c
index 8329c8a..87e06d8 100644
--- a/drivers/mailbox/omap-mailbox.c
+++ b/drivers/mailbox/omap-mailbox.c
@@ -32,7 +32,9 @@
 
 #include "omap-mbox.h"
 
-static struct omap_mbox **mboxes;
+/* global variables for the mailbox devices */
+static DEFINE_MUTEX(omap_mbox_devices_lock);
+static LIST_HEAD(omap_mbox_devices);
 
 static unsigned int mbox_kfifo_size = CONFIG_OMAP_MBOX_KFIFO_SIZE;
 module_param(mbox_kfifo_size, uint, S_IRUGO);
@@ -333,20 +335,38 @@ static void omap_mbox_fini(struct omap_mbox *mbox)
 	mutex_unlock(&mdev->cfg_lock);
 }
 
-struct omap_mbox *omap_mbox_get(const char *name, struct notifier_block *nb)
+static struct omap_mbox *omap_mbox_device_find(struct omap_mbox_device *mdev,
+						const char *mbox_name)
 {
 	struct omap_mbox *_mbox, *mbox = NULL;
-	int i, ret;
+	struct omap_mbox **mboxes = mdev->mboxes;
+	int i;
 
 	if (!mboxes)
-		return ERR_PTR(-EINVAL);
+		return NULL;
 
 	for (i = 0; (_mbox = mboxes[i]); i++) {
-		if (!strcmp(_mbox->name, name)) {
+		if (!strcmp(_mbox->name, mbox_name)) {
 			mbox = _mbox;
 			break;
 		}
 	}
+	return mbox;
+}
+
+struct omap_mbox *omap_mbox_get(const char *name, struct notifier_block *nb)
+{
+	struct omap_mbox *mbox = NULL;
+	struct omap_mbox_device *mdev;
+	int ret;
+
+	mutex_lock(&omap_mbox_devices_lock);
+	list_for_each_entry(mdev, &omap_mbox_devices, elem) {
+		mbox = omap_mbox_device_find(mdev, name);
+		if (mbox)
+			break;
+	}
+	mutex_unlock(&omap_mbox_devices_lock);
 
 	if (!mbox)
 		return ERR_PTR(-ENOENT);
@@ -373,19 +393,20 @@ EXPORT_SYMBOL(omap_mbox_put);
 
 static struct class omap_mbox_class = { .name = "mbox", };
 
-int omap_mbox_register(struct device *parent, struct omap_mbox **list)
+int omap_mbox_register(struct omap_mbox_device *mdev)
 {
 	int ret;
 	int i;
+	struct omap_mbox **mboxes;
 
-	mboxes = list;
-	if (!mboxes)
+	if (!mdev || !mdev->mboxes)
 		return -EINVAL;
 
+	mboxes = mdev->mboxes;
 	for (i = 0; mboxes[i]; i++) {
 		struct omap_mbox *mbox = mboxes[i];
 		mbox->dev = device_create(&omap_mbox_class,
-				parent, 0, mbox, "%s", mbox->name);
+				mdev->dev, 0, mbox, "%s", mbox->name);
 		if (IS_ERR(mbox->dev)) {
 			ret = PTR_ERR(mbox->dev);
 			goto err_out;
@@ -393,6 +414,11 @@ int omap_mbox_register(struct device *parent, struct omap_mbox **list)
 
 		BLOCKING_INIT_NOTIFIER_HEAD(&mbox->notifier);
 	}
+
+	mutex_lock(&omap_mbox_devices_lock);
+	list_add(&mdev->elem, &omap_mbox_devices);
+	mutex_unlock(&omap_mbox_devices_lock);
+
 	return 0;
 
 err_out:
@@ -402,16 +428,21 @@ err_out:
 }
 EXPORT_SYMBOL(omap_mbox_register);
 
-int omap_mbox_unregister(void)
+int omap_mbox_unregister(struct omap_mbox_device *mdev)
 {
 	int i;
+	struct omap_mbox **mboxes;
 
-	if (!mboxes)
+	if (!mdev || !mdev->mboxes)
 		return -EINVAL;
 
+	mutex_lock(&omap_mbox_devices_lock);
+	list_del(&mdev->elem);
+	mutex_unlock(&omap_mbox_devices_lock);
+
+	mboxes = mdev->mboxes;
 	for (i = 0; mboxes[i]; i++)
 		device_unregister(mboxes[i]->dev);
-	mboxes = NULL;
 	return 0;
 }
 EXPORT_SYMBOL(omap_mbox_unregister);
diff --git a/drivers/mailbox/omap-mbox.h b/drivers/mailbox/omap-mbox.h
index 2d3cdb4..3836da9 100644
--- a/drivers/mailbox/omap-mbox.h
+++ b/drivers/mailbox/omap-mbox.h
@@ -52,6 +52,7 @@ struct omap_mbox_device {
 	u32 num_users;
 	u32 num_fifos;
 	struct omap_mbox **mboxes;
+	struct list_head elem;
 };
 
 struct omap_mbox {
@@ -66,7 +67,7 @@ struct omap_mbox {
 	struct blocking_notifier_head	notifier;
 };
 
-int omap_mbox_register(struct device *parent, struct omap_mbox **);
-int omap_mbox_unregister(void);
+int omap_mbox_register(struct omap_mbox_device *device);
+int omap_mbox_unregister(struct omap_mbox_device *device);
 
 #endif /* OMAP_MBOX_H */
-- 
1.7.5.4

