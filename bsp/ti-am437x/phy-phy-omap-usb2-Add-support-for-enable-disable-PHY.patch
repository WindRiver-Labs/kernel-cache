From 8cd406bbcfdd2169abf5a2101d31c84f130c9608 Mon Sep 17 00:00:00 2001
From: George Cherian <george.cherian@ti.com>
Date: Tue, 17 Dec 2013 18:47:53 +0530
Subject: [PATCH 241/285] phy: phy-omap-usb2: Add support for enable/disable
 PHY wkup for AM43x

Add support to enable/disable PHY wakeup feature in AM43x Soc during
system suspend/resume. Also add a driver flag to make sure PHY wakeup
is enabled only for AM43x SoC.

Also add SYSTEM_SLEEP_PM_OPS to enable AM43x to successfully enter
deep sleep state.

Signed-off-by: George Cherian <george.cherian@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/phy/phy-omap-usb2.c  |   85 ++++++++++++++++++++++++++++++++++-------
 include/linux/phy/omap_usb.h |    1 +
 2 files changed, 71 insertions(+), 15 deletions(-)

diff --git a/drivers/phy/phy-omap-usb2.c b/drivers/phy/phy-omap-usb2.c
index 36b33b1..47f7d80 100644
--- a/drivers/phy/phy-omap-usb2.c
+++ b/drivers/phy/phy-omap-usb2.c
@@ -161,7 +161,7 @@ static const struct usb_phy_data dra7x_usb2_data = {
 
 static const struct usb_phy_data am437x_usb2_data = {
 	.label = "am437x_usb2",
-	.flags =  0,
+	.flags =  OMAP_USB2_ENABLE_PHYWKUP,
 };
 
 static const struct of_device_id omap_usb2_id_table[] = {
@@ -233,6 +233,9 @@ static int omap_usb2_probe(struct platform_device *pdev)
 		phy->flags |= OMAP_USB2_CALIBRATE_FALSE_DISCONNECT;
 	}
 
+	if (phy_data->flags & OMAP_USB2_ENABLE_PHYWKUP)
+		phy->flags |= OMAP_USB2_ENABLE_PHYWKUP;
+
 	control_node = of_parse_phandle(node, "ctrl-module", 0);
 	if (!control_node) {
 		dev_err(&pdev->dev, "Failed to get control device phandle\n");
@@ -300,25 +303,31 @@ static int omap_usb2_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
+static int omap_usb2_enable_phywkup(struct omap_usb *phy)
+{
+	omap_control_phy_wkup(phy->control_dev, 1);
 
-static int omap_usb2_runtime_suspend(struct device *dev)
+	return 0;
+}
+
+static int omap_usb2_disable_phywkup(struct omap_usb *phy)
+{
+	omap_control_phy_wkup(phy->control_dev, 0);
+
+	return 0;
+}
+
+static void omap_usb2_disable_clocks(struct omap_usb *phy)
 {
-	struct platform_device	*pdev = to_platform_device(dev);
-	struct omap_usb	*phy = platform_get_drvdata(pdev);
 
 	clk_disable(phy->wkupclk);
 	if (!IS_ERR(phy->optclk))
 		clk_disable(phy->optclk);
-
-	return 0;
 }
 
-static int omap_usb2_runtime_resume(struct device *dev)
+static int omap_usb2_enable_clocks(struct omap_usb *phy)
 {
 	u32 ret = 0;
-	struct platform_device	*pdev = to_platform_device(dev);
-	struct omap_usb	*phy = platform_get_drvdata(pdev);
 
 	ret = clk_enable(phy->wkupclk);
 	if (ret < 0) {
@@ -343,15 +352,61 @@ err0:
 	return ret;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+static int omap_usb2_runtime_suspend(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct omap_usb	*phy = platform_get_drvdata(pdev);
+
+	omap_usb2_disable_clocks(phy);
+
+	return 0;
+}
+
+static int omap_usb2_runtime_resume(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct omap_usb	*phy = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = omap_usb2_enable_clocks(phy);
+
+	return ret;
+}
+#endif
+
+static int omap_usb2_suspend(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct omap_usb	*phy = platform_get_drvdata(pdev);
+
+	if (phy->flags & OMAP_USB2_ENABLE_PHYWKUP)
+		omap_usb2_enable_phywkup(phy);
+
+	omap_usb2_disable_clocks(phy);
+
+	return 0;
+}
+
+static int omap_usb2_resume(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct omap_usb	*phy = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = omap_usb2_enable_clocks(phy);
+	if (phy->flags & OMAP_USB2_ENABLE_PHYWKUP)
+		omap_usb2_disable_phywkup(phy);
+
+	return ret;
+}
+
 static const struct dev_pm_ops omap_usb2_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(omap_usb2_suspend, omap_usb2_resume)
 	SET_RUNTIME_PM_OPS(omap_usb2_runtime_suspend, omap_usb2_runtime_resume,
 		NULL)
 };
 
-#define DEV_PM_OPS     (&omap_usb2_pm_ops)
-#else
-#define DEV_PM_OPS     NULL
-#endif
 
 static struct platform_driver omap_usb2_driver = {
 	.probe		= omap_usb2_probe,
@@ -359,7 +414,7 @@ static struct platform_driver omap_usb2_driver = {
 	.driver		= {
 		.name	= "omap-usb2",
 		.owner	= THIS_MODULE,
-		.pm	= DEV_PM_OPS,
+		.pm	= &omap_usb2_pm_ops,
 		.of_match_table = of_match_ptr(omap_usb2_id_table),
 	},
 };
diff --git a/include/linux/phy/omap_usb.h b/include/linux/phy/omap_usb.h
index 946f2d8..1170285 100644
--- a/include/linux/phy/omap_usb.h
+++ b/include/linux/phy/omap_usb.h
@@ -51,6 +51,7 @@ struct usb_phy_data {
 #define OMAP_USB2_HAS_START_SRP (1 << 0)
 #define OMAP_USB2_HAS_SET_VBUS (1 << 1)
 #define OMAP_USB2_CALIBRATE_FALSE_DISCONNECT (1 << 2)
+#define OMAP_USB2_ENABLE_PHYWKUP (1 << 3)
 
 #define	phy_to_omapusb(x)	container_of((x), struct omap_usb, phy)
 
-- 
1.7.5.4

