From 516f2f78599f8dd9f0cf991101c76b002845bd51 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Mon, 14 Oct 2013 15:58:09 +0300
Subject: [PATCH 249/285] phy: omap-pipe3: streamline PHY operations

Limit .power_on() and .power_off() to just control the
PHY power and not the DPLL. The DPLL will be enabled
in .init() and idled in .exit().

Don't reprogram the DPLL if it has been already locked
by the bootloader. This fixes a problem with SATA, where
it fails if SATA was used by the bootloader.

Signed-off-by: Roger Quadros <rogerq@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/phy/phy-omap-pipe3.c |  140 ++++++++++++++++++++++++------------------
 1 files changed, 80 insertions(+), 60 deletions(-)

diff --git a/drivers/phy/phy-omap-pipe3.c b/drivers/phy/phy-omap-pipe3.c
index b0f8ea2..c724208 100644
--- a/drivers/phy/phy-omap-pipe3.c
+++ b/drivers/phy/phy-omap-pipe3.c
@@ -47,7 +47,8 @@
 #define	PLL_SD_MASK		0x0003FC00
 #define	PLL_SD_SHIFT		10
 #define	SET_PLL_GO		0x1
-#define	PLL_TICOPWDN		0x10000
+#define	PLL_TICOPWDN		BIT(16)
+#define PLL_LDOPWDN		BIT(15)
 #define	PLL_LOCK		0x2
 #define	PLL_IDLE		0x1
 
@@ -56,7 +57,8 @@
  * value required for the PIPE3PHY_PLL_CONFIGURATION2.PLL_IDLE status
  * to be correctly reflected in the PIPE3PHY_PLL_STATUS register.
  */
-# define PLL_IDLE_TIME  100;
+#define PLL_IDLE_TIME	100	/* in milliseconds */
+#define PLL_LOCK_TIME	100	/* in milliseconds */
 
 static struct pipe3_dpll_map dpll_map_usb[] = {
 	{12000000, {1250, 5, 4, 20, 0} },	/* 12 MHz */
@@ -96,66 +98,28 @@ static struct pipe3_dpll_params *omap_pipe3_get_dpll_params(struct omap_pipe3
 	return 0;
 }
 
-static int omap_pipe3_power_off(struct phy *x)
-{
-	struct omap_pipe3 *phy = phy_get_drvdata(x);
-	int val;
-	int timeout = PLL_IDLE_TIME;
-
-	val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);
-	val |= PLL_IDLE;
-	omap_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);
-
-	do {
-		val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);
-		if (val & PLL_TICOPWDN)
-			break;
-		udelay(1);
-	} while (--timeout);
-
-	omap_control_phy_power(phy->control_dev, 0);
-
-	return 0;
-}
-
-static int omap_pipe3_power_on(struct phy *x)
-{
-	struct omap_pipe3 *phy = phy_get_drvdata(x);
-	int val;
-	int timeout = PLL_IDLE_TIME;
-
-	val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);
-	val &= ~PLL_IDLE;
-	omap_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);
-
-	do {
-		val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);
-		if (!(val & PLL_TICOPWDN))
-			break;
-		udelay(1);
-	} while (--timeout);
-
-	msleep(100);
-
-	return 0;
-}
-
-static void omap_pipe3_dpll_relock(struct omap_pipe3 *phy)
+static int omap_pipe3_wait_lock(struct omap_pipe3 *phy)
 {
 	u32		val;
 	unsigned long	timeout;
 
-	omap_pipe3_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);
-
-	timeout = jiffies + msecs_to_jiffies(20);
+	timeout = jiffies + msecs_to_jiffies(PLL_LOCK_TIME);
 	do {
+		cpu_relax();
 		val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);
 		if (val & PLL_LOCK)
 			break;
-	} while (!WARN_ON(time_after(jiffies, timeout)));
+	} while (!time_after(jiffies, timeout));
+
+	if (!(val & PLL_LOCK)) {
+		dev_err(phy->dev, "DPLL failed to lock\n");
+		return -EBUSY;
+	}
+
+	return 0;
 }
 
-static int omap_pipe3_dpll_lock(struct omap_pipe3 *phy)
+static int omap_pipe3_dpll_program(struct omap_pipe3 *phy)
 {
 	u32			val;
 	unsigned long		rate;
@@ -164,6 +128,7 @@ static int omap_pipe3_dpll_lock(struct omap_pipe3 *phy)
 	rate = clk_get_rate(phy->sys_clk);
 	dpll_params = omap_pipe3_get_dpll_params(phy);
 	if (!dpll_params) {
+		dev_err(phy->dev, "Invalid DPLL parameters\n");
 		return -EINVAL;
 	}
 
@@ -192,21 +157,75 @@ static int omap_pipe3_dpll_lock(struct omap_pipe3 *phy)
 	val |= dpll_params->sd << PLL_SD_SHIFT;
 	omap_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION3, val);
 
-	omap_pipe3_dpll_relock(phy);
+	omap_pipe3_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);
+
+	return omap_pipe3_wait_lock(phy);
+}
+
+static int omap_pipe3_power_off(struct phy *x)
+{
+	struct omap_pipe3 *phy = phy_get_drvdata(x);
+
+	omap_control_phy_power(phy->control_dev, 0);
+	return 0;
+}
 
+static int omap_pipe3_power_on(struct phy *x)
+{
+	struct omap_pipe3 *phy = phy_get_drvdata(x);
+
+	omap_control_phy_power(phy->control_dev, 1);
 	return 0;
 }
 
 static int omap_pipe3_init(struct phy *x)
 {
 	struct omap_pipe3 *phy = phy_get_drvdata(x);
-	int ret;
+	u32 val;
+	int ret = 0;
 
-	ret = omap_pipe3_dpll_lock(phy);
-	if (ret)
-		return ret;
+	/* Program the DPLL only if not locked */
+	val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);
+	if (!(val & PLL_LOCK))
+		if (omap_pipe3_dpll_program(phy))
+			return -EINVAL;
 
-	omap_control_phy_power(phy->control_dev, 1);
+	/* Bring it out of IDLE if it is IDLE */
+	val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);
+	if (val & PLL_IDLE) {
+		val &= ~PLL_IDLE;
+		omap_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);
+		ret = omap_pipe3_wait_lock(phy);
+	}
+
+	return ret;
+}
+
+static int omap_pipe3_exit(struct phy *x)
+{
+	struct omap_pipe3 *phy = phy_get_drvdata(x);
+	u32 val;
+	unsigned long timeout;
+
+	/* Put DPLL in IDLE mode */
+	val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);
+	val |= PLL_IDLE;
+	omap_pipe3_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);
+
+	/* wait for LDO and Oscillator to power down */
+	timeout = jiffies + msecs_to_jiffies(PLL_IDLE_TIME);
+	do {
+		cpu_relax();
+		val = omap_pipe3_readl(phy->pll_ctrl_base, PLL_STATUS);
+		if ((val & PLL_TICOPWDN) && (val & PLL_LDOPWDN))
+			break;
+	} while (!time_after(jiffies, timeout));
+
+	if (!(val & PLL_TICOPWDN) || !(val & PLL_LDOPWDN)) {
+		dev_err(phy->dev, "Failed to power down: PLL_STATUS 0x%x\n",
+									val);
+		return -EBUSY;
+	}
 
 	return 0;
 }
@@ -215,6 +234,7 @@ static struct phy_ops ops = {
 	.init		= omap_pipe3_init,
 	.power_on	= omap_pipe3_power_on,
 	.power_off	= omap_pipe3_power_off,
+	.exit		= omap_pipe3_exit,
 	.owner		= THIS_MODULE,
 };
 
@@ -321,7 +341,7 @@ static int omap_pipe3_probe(struct platform_device *pdev)
 
 	phy_set_drvdata(generic_phy, phy);
 
-	pm_runtime_get(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
 
 	return 0;
 }
@@ -337,7 +357,7 @@ static int omap_pipe3_remove(struct platform_device *pdev)
 	if (!IS_ERR(phy->optclk2))
 		clk_unprepare(phy->optclk2);
 	if (!pm_runtime_suspended(&pdev->dev))
-		pm_runtime_put(&pdev->dev);
+		pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
 	return 0;
-- 
1.7.5.4

