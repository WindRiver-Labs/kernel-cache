From bad06d63fae3a8942add0e3cf37292017c9d46d3 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Thu, 13 Sep 2012 23:48:16 -0500
Subject: [PATCH 110/285] remoteproc: add debugfs entry to print the firmware
 version info

A debugfs entry called "version" is created under the corresponding
remoteproc directory when the firmware image is processed. The
design relies on the firmware file having a special section
containing the version info. The version info has to be stored into
this section in the remote processor image build step.

This is currently implemented for ELF images by storing the version
information in a specific ELF section named ".version".

A read on the entry will print the contents of the version section.
The following shows an example usage:
    cat /d/remoteproc/remoteproc0/version

This is based on a patch developed by Juan Gutierrez on 3.4 kernel,
and has been reworked and ported to 3.8 kernel.

Signed-off-by: Juan Gutierrez <jgutierrez@ti.com>
Signed-off-by: Suman Anna <s-anna@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/remoteproc/remoteproc_core.c       |   31 ++++++++++++++-
 drivers/remoteproc/remoteproc_debugfs.c    |   20 ++++++++++
 drivers/remoteproc/remoteproc_elf_loader.c |   57 +++++++++++++++++++++++++++-
 drivers/remoteproc/remoteproc_internal.h   |   13 ++++++
 include/linux/remoteproc.h                 |    2 +
 5 files changed, 121 insertions(+), 2 deletions(-)

diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index fff17380..1db95cc 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -779,6 +779,20 @@ static int rproc_handle_resources(struct rproc *rproc, int len,
 	return ret;
 }
 
+/* handle firmware version entry before loading the firmware sections */
+static int
+rproc_handle_fw_version(struct rproc *rproc, const char *version, int versz)
+{
+	struct device *dev = &rproc->dev;
+
+	rproc->fw_version = kmemdup(version, versz, GFP_KERNEL);
+	if (!rproc->fw_version) {
+		dev_err(dev, "%s: version kzalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
 /**
  * rproc_resource_cleanup() - clean up and free all acquired resources
  * @rproc: rproc handle
@@ -821,6 +835,9 @@ static void rproc_resource_cleanup(struct rproc *rproc)
 		list_del(&entry->node);
 		kfree(entry);
 	}
+
+	/* free fw version */
+	kfree(rproc->fw_version);
 }
 
 /*
@@ -831,7 +848,8 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 	struct device *dev = &rproc->dev;
 	const char *name = rproc->firmware;
 	struct resource_table *table, *loaded_table;
-	int ret, tablesz;
+	int ret, tablesz, versz;
+	const char *version;
 
 	if (!rproc->table_ptr)
 		return -ENOMEM;
@@ -875,6 +893,17 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 		goto clean_up;
 	}
 
+	/* look for the firmware version, and store if present */
+	version = rproc_find_version_info(rproc, fw, &versz);
+	if (version) {
+		ret = rproc_handle_fw_version(rproc, version, versz);
+		if (ret) {
+			dev_err(dev, "Failed to process version info: %d\n",
+				ret);
+			goto clean_up;
+		}
+	}
+
 	/* load the ELF segments to memory */
 	ret = rproc_load_segments(rproc, fw);
 	if (ret) {
diff --git a/drivers/remoteproc/remoteproc_debugfs.c b/drivers/remoteproc/remoteproc_debugfs.c
index 8d6a89b..029ed47 100644
--- a/drivers/remoteproc/remoteproc_debugfs.c
+++ b/drivers/remoteproc/remoteproc_debugfs.c
@@ -190,6 +190,24 @@ static const struct file_operations rproc_recovery_ops = {
 	.llseek = generic_file_llseek,
 };
 
+static ssize_t rproc_fw_version_read(struct file *filp, char __user *userbuf,
+						size_t count, loff_t *ppos)
+{
+	struct rproc *rproc = filp->private_data;
+
+	if (!rproc->fw_version)
+		return 0;
+
+	return simple_read_from_buffer(userbuf, count, ppos, rproc->fw_version,
+						strlen(rproc->fw_version));
+}
+
+static const struct file_operations rproc_version_ops = {
+	.read = rproc_fw_version_read,
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+};
+
 void rproc_remove_trace_file(struct dentry *tfile)
 {
 	debugfs_remove(tfile);
@@ -235,6 +253,8 @@ void rproc_create_debug_dir(struct rproc *rproc)
 			    rproc, &rproc_state_ops);
 	debugfs_create_file("recovery", 0400, rproc->dbg_dir,
 			    rproc, &rproc_recovery_ops);
+	debugfs_create_file("version", 0400, rproc->dbg_dir,
+			    rproc, &rproc_version_ops);
 }
 
 void __init rproc_init_debugfs(void)
diff --git a/drivers/remoteproc/remoteproc_elf_loader.c b/drivers/remoteproc/remoteproc_elf_loader.c
index c523983..e038ea7 100644
--- a/drivers/remoteproc/remoteproc_elf_loader.c
+++ b/drivers/remoteproc/remoteproc_elf_loader.c
@@ -328,10 +328,65 @@ rproc_elf_find_loaded_rsc_table(struct rproc *rproc, const struct firmware *fw)
 	return rproc_da_to_va(rproc, shdr->sh_addr, shdr->sh_size);
 }
 
+/**
+ * rproc_elf_find_version_section() - find the .version section
+ * @rproc: the rproc handle
+ * @fw: the ELF firmware image
+ * @len: firmware size (in bytes)
+ * @versz: place holder for providing back the version size
+ *
+ * This function finds the .version section inside the remote processor's
+ * firmware. It is used to provide any version information for the
+ * firmware.
+ *
+ * Returns the pointer to the .version section if it is found, and write its
+ * size into @versz. If a valid version isn't found, NULL is returned
+ * (and @versz isn't set).
+ */
+static const char *
+rproc_elf_find_version_section(struct rproc *rproc, const struct firmware *fw,
+			       int *versz)
+{
+	struct elf32_hdr *ehdr;
+	struct elf32_shdr *shdr;
+	const char *name_table;
+	struct device *dev = &rproc->dev;
+	const char *vdata = NULL;
+	int i;
+	const u8 *elf_data = fw->data;
+
+	ehdr = (struct elf32_hdr *)elf_data;
+	shdr = (struct elf32_shdr *)(elf_data + ehdr->e_shoff);
+	name_table = elf_data + shdr[ehdr->e_shstrndx].sh_offset;
+
+	/* look for the version section */
+	for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
+		int size = shdr->sh_size;
+		int offset = shdr->sh_offset;
+
+		if (strcmp(name_table + shdr->sh_name, ".version"))
+			continue;
+
+		vdata = (char *)(elf_data + offset);
+
+		/* make sure we have the entire section */
+		if (offset + size > fw->size) {
+			dev_err(dev, "version info truncated\n");
+			return NULL;
+		}
+
+		*versz = shdr->sh_size;
+		break;
+	}
+
+	return vdata;
+}
+
 const struct rproc_fw_ops rproc_elf_fw_ops = {
 	.load = rproc_elf_load_segments,
 	.find_rsc_table = rproc_elf_find_rsc_table,
 	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
 	.sanity_check = rproc_elf_sanity_check,
-	.get_boot_addr = rproc_elf_get_boot_addr
+	.get_boot_addr = rproc_elf_get_boot_addr,
+	.find_version = rproc_elf_find_version_section
 };
diff --git a/drivers/remoteproc/remoteproc_internal.h b/drivers/remoteproc/remoteproc_internal.h
index 8938faf..6f192ab 100644
--- a/drivers/remoteproc/remoteproc_internal.h
+++ b/drivers/remoteproc/remoteproc_internal.h
@@ -33,6 +33,7 @@ struct rproc;
  *			expects to find it
  * @sanity_check:	sanity check the fw image
  * @get_boot_addr:	get boot address to entry point specified in firmware
+ * @find_version:	get the version information string from the firmware
  */
 struct rproc_fw_ops {
 	struct resource_table *(*find_rsc_table) (struct rproc *rproc,
@@ -43,6 +44,8 @@ struct rproc_fw_ops {
 	int (*load)(struct rproc *rproc, const struct firmware *fw);
 	int (*sanity_check)(struct rproc *rproc, const struct firmware *fw);
 	u32 (*get_boot_addr)(struct rproc *rproc, const struct firmware *fw);
+	const char * (*find_version)(struct rproc *rproc,
+					const struct firmware *fw, int *versz);
 };
 
 /* from remoteproc_core.c */
@@ -115,6 +118,16 @@ struct resource_table *rproc_find_loaded_rsc_table(struct rproc *rproc,
         return NULL;
 }
 
+static inline
+const char *rproc_find_version_info(struct rproc *rproc,
+				const struct firmware *fw, int *versz)
+{
+	if (rproc->fw_ops->find_version)
+		return rproc->fw_ops->find_version(rproc, fw, versz);
+
+	return NULL;
+}
+
 extern const struct rproc_fw_ops rproc_elf_fw_ops;
 
 extern struct device_type rproc_type;
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index 35da97b..f2c1e6a 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -404,6 +404,7 @@ enum rproc_crash_type {
  * @table_ptr: pointer to the resource table in effect
  * @cached_table: copy of the resource table
  * @table_csum: checksum of the resource table
+ * @fw_version: human readable version information extracted from f/w
  */
 struct rproc {
 	struct klist_node node;
@@ -435,6 +436,7 @@ struct rproc {
 	struct resource_table *table_ptr;
 	struct resource_table *cached_table;
 	u32 table_csum;
+	char *fw_version;
 };
 
 /* we currently support only two vrings per rvdev */
-- 
1.7.5.4

