From 6bebb59a0de7eecdc2e341d1ba2552120f51cdd0 Mon Sep 17 00:00:00 2001
From: Sourav Poddar <sourav.poddar@ti.com>
Date: Sat, 26 Jan 2013 14:30:51 +0530
Subject: [PATCH 257/285] sp/qspi: Make conditional compilation of control
 module register.

Some SOC does not depend on control module register, while memory
map address space varies from SOC to SOC. Add conditional compilation
for these register.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/spi-ti-qspi.c |   51 ++++++++++++++++++++++++++++++---------------
 1 files changed, 34 insertions(+), 17 deletions(-)

diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c
index de97e05..dc89425 100644
--- a/drivers/spi/spi-ti-qspi.c
+++ b/drivers/spi/spi-ti-qspi.c
@@ -63,6 +63,7 @@ struct ti_qspi {
 	u32 dc;
 
 	bool memory_mapped;
+	bool ctrl_mod;
 };
 
 #define QSPI_PID			(0x0)
@@ -147,9 +148,11 @@ void enable_qspi_memory_mapped(struct ti_qspi *qspi)
 	u32 val;
 
 	ti_qspi_write(qspi, MM_SWITCH, QSPI_SPI_SWITCH_REG);
-	val = readl(qspi->ctrl_base);
-	val |= MEM_CS;
-	writel(val, qspi->ctrl_base);
+	if (qspi->ctrl_mod) {
+		val = readl(qspi->ctrl_base);
+		val |= MEM_CS;
+		writel(val, qspi->ctrl_base);
+	}
 }
 
 void disable_qspi_memory_mapped(struct ti_qspi *qspi)
@@ -157,9 +160,11 @@ void disable_qspi_memory_mapped(struct ti_qspi *qspi)
 	u32 val;
 
 	ti_qspi_write(qspi, ~MM_SWITCH, QSPI_SPI_SWITCH_REG);
-	val = readl(qspi->ctrl_base);
-	val |= MEM_CS_DIS;
-	writel(val, qspi->ctrl_base);
+	if (qspi->ctrl_mod) {
+		val = readl(qspi->ctrl_base);
+		val |= MEM_CS_DIS;
+		writel(val, qspi->ctrl_base);
+	}
 }
 
 static int ti_qspi_setup(struct spi_device *spi)
@@ -558,9 +563,16 @@ static int ti_qspi_probe(struct platform_device *pdev)
 	qspi->master = master;
 	qspi->dev = &pdev->dev;
 
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	res_ctrl = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	res_mmap = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_base");
+	if (r == NULL) {
+		dev_err(&pdev->dev, "missing platform resources data\n");
+		return -ENODEV;
+	}
+
+	res_mmap = platform_get_resource_byname(pdev,
+			IORESOURCE_MEM, "qspi_mmap");
+	res_ctrl = platform_get_resource_byname(pdev,
+			IORESOURCE_MEM, "qspi_ctrlmod");
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -576,16 +588,21 @@ static int ti_qspi_probe(struct platform_device *pdev)
 		goto free_master;
 	}
 
-	qspi->ctrl_base = devm_ioremap_resource(&pdev->dev, res_ctrl);
-	if (IS_ERR(qspi->ctrl_base)) {
-		ret = PTR_ERR(qspi->ctrl_base);
-		goto free_master;
+	if (res_ctrl) {
+		qspi->ctrl_mod = true;
+		qspi->ctrl_base = devm_ioremap_resource(&pdev->dev, res_ctrl);
+		if (IS_ERR(qspi->ctrl_base)) {
+			ret = PTR_ERR(qspi->ctrl_base);
+			goto free_master;
+		}
 	}
 
-	qspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);
-	if (IS_ERR(qspi->mmap_base)) {
-		ret = PTR_ERR(qspi->mmap_base);
-		goto free_master;
+	if (res_mmap) {
+		qspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);
+		if (IS_ERR(qspi->mmap_base)) {
+			ret = PTR_ERR(qspi->mmap_base);
+			goto free_master;
+		}
 	}
 
 	ret = devm_request_irq(&pdev->dev, irq, ti_qspi_isr, 0,
-- 
1.7.5.4

