From 8b5631efea3a8b115c2ff6ddaaa1eaba6a6624df Mon Sep 17 00:00:00 2001
From: Benoit Parrot <bparrot@ti.com>
Date: Tue, 4 Feb 2014 02:18:42 +0000
Subject: [PATCH 212/285] Media: platform: ti-vpfe: Add frame size/format
 config

Added frame size/format configuration support
Added frame size enumeration support

Signed-off-by: Benoit Parrot <bparrot@ti.com>
Signed-off-by: Darren Etheridge <detheridge@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin, just
change the media_entity_remote_pad() to
media_entity_remote_source()]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/media/platform/ti-vpfe/am437x_isif.c  |    6 +
 drivers/media/platform/ti-vpfe/vpfe_capture.c |  212 ++++++++++++++++++++++---
 2 files changed, 192 insertions(+), 26 deletions(-)

diff --git a/drivers/media/platform/ti-vpfe/am437x_isif.c b/drivers/media/platform/ti-vpfe/am437x_isif.c
index abe92f2..74692d2 100644
--- a/drivers/media/platform/ti-vpfe/am437x_isif.c
+++ b/drivers/media/platform/ti-vpfe/am437x_isif.c
@@ -600,6 +600,9 @@ static int isif_set_pixel_format(struct vpfe_isif_device *isif, u32 pixfmt)
 
 	if (isif->isif_cfg.if_type == VPFE_RAW_BAYER) {
 		isif->isif_cfg.bayer.pix_fmt = ISIF_PIXFMT_RAW;
+		/* Need to clear it in case it was left on
+		   after the last capture. */
+		isif->isif_cfg.bayer.config_params.alaw.enable = 0;
 		if (pixfmt == V4L2_PIX_FMT_SBGGR8)
 			isif->isif_cfg.bayer.config_params.alaw.enable = 1;
 		else if (pixfmt == V4L2_PIX_FMT_YUYV)
@@ -610,6 +613,8 @@ static int isif_set_pixel_format(struct vpfe_isif_device *isif, u32 pixfmt)
 			; /*nothing for now */
 		else if (pixfmt == V4L2_PIX_FMT_NV12)
 			; /*nothing for now */
+		else if (pixfmt == V4L2_PIX_FMT_RGB565X)
+			; /*nothing for now */
 		else if (pixfmt != V4L2_PIX_FMT_SBGGR16)
 			return -EINVAL;
 	} else {
@@ -958,6 +963,7 @@ static void isif_config_defaults(struct vpfe_isif_device *isif)
 	isif->isif_cfg.bayer.win.width = 800;
 	isif->isif_cfg.bayer.win.height = 600;
 	isif->isif_cfg.bayer.config_params.data_sz = ISIF_DATA_8BITS;
+	isif->isif_cfg.bayer.config_params.alaw.gamma_wd = ISIF_GAMMA_BITS_09_0;
 }
 
 int vpfe_isif_init(struct vpfe_isif_device *isif, struct platform_device *pdev)
diff --git a/drivers/media/platform/ti-vpfe/vpfe_capture.c b/drivers/media/platform/ti-vpfe/vpfe_capture.c
index 7549871..d256b77 100644
--- a/drivers/media/platform/ti-vpfe/vpfe_capture.c
+++ b/drivers/media/platform/ti-vpfe/vpfe_capture.c
@@ -216,6 +216,72 @@ void mbus_to_pix(struct vpfe_device *vpfe_dev,
 		pix->sizeimage = pix->bytesperline * pix->height;
 }
 
+/* map mbus_fmt to pixelformat */
+void pix_to_mbus(struct vpfe_device *vpfe_dev,
+		struct v4l2_pix_format *pix,
+		struct v4l2_mbus_framefmt *mbus)
+{
+	memset(mbus, 0, sizeof(*mbus));
+	mbus->width = pix->width;
+	mbus->height = pix->height;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_UYVY:
+		mbus->code = V4L2_MBUS_FMT_UYVY8_2X8;
+		break;
+
+	case V4L2_PIX_FMT_YUYV:
+		mbus->code = V4L2_MBUS_FMT_YUYV8_2X8;
+		break;
+
+	case V4L2_PIX_FMT_YVYU:
+		mbus->code = V4L2_MBUS_FMT_YVYU8_2X8;
+		break;
+
+	case V4L2_PIX_FMT_VYUY:
+		mbus->code = V4L2_MBUS_FMT_VYUY8_2X8;
+		break;
+
+	case V4L2_PIX_FMT_NV12:
+		mbus->code = V4L2_MBUS_FMT_YDYUYDYV8_1X16;
+		break;
+
+	case V4L2_PIX_FMT_YUV420:
+		mbus->code = V4L2_MBUS_FMT_Y12_1X12;
+		break;
+
+	case V4L2_PIX_FMT_SBGGR8:
+		mbus->code = V4L2_MBUS_FMT_SBGGR8_1X8;
+		break;
+
+	case V4L2_PIX_FMT_SGBRG8:
+		mbus->code = V4L2_MBUS_FMT_SGBRG8_1X8;
+		break;
+
+	case V4L2_PIX_FMT_SGRBG8:
+		mbus->code = V4L2_MBUS_FMT_SGRBG8_1X8;
+		break;
+
+	case V4L2_PIX_FMT_SRGGB8:
+		mbus->code = V4L2_MBUS_FMT_SRGGB8_1X8;
+		break;
+
+	case V4L2_PIX_FMT_RGB565:
+		mbus->code = V4L2_MBUS_FMT_BGR565_2X8_BE;
+		break;
+
+	case V4L2_PIX_FMT_RGB565X:
+		mbus->code = V4L2_MBUS_FMT_RGB565_2X8_BE;
+		break;
+
+	default:
+		pr_err("Invalid pixel code\n");
+	}
+
+	mbus->colorspace = pix->colorspace;
+	mbus->field = pix->field;
+}
+
 /*  Print Four-character-code (FOURCC) */
 static char *print_fourcc(u32 fmt)
 {
@@ -229,6 +295,17 @@ static char *print_fourcc(u32 fmt)
 	return code;
 }
 
+static int cmp_v4l2_format(const struct v4l2_format *lhs,
+	const struct v4l2_format *rhs)
+{
+	return lhs->type == rhs->type &&
+		lhs->fmt.pix.width == rhs->fmt.pix.width &&
+		lhs->fmt.pix.height == rhs->fmt.pix.height &&
+		lhs->fmt.pix.pixelformat == rhs->fmt.pix.pixelformat &&
+		lhs->fmt.pix.field == rhs->fmt.pix.field &&
+		lhs->fmt.pix.colorspace == rhs->fmt.pix.colorspace;
+}
+
 /*
  * vpfe_get_isif_image_format - Get image parameters based on ISIF settings
  */
@@ -425,38 +502,23 @@ static int vpfe_config_image_format(struct vpfe_device *vpfe_dev,
 				"v4l2_subdev_call g_mbus_fmt: %d\n", ret);
 		}
 	}
+
 	/* convert mbus_format to v4l2_format */
-	v4l2_fill_pix_format(pix, &mbus_fmt);
-	v4l2_fill_pix_format(&pix_test, &sd_fmt.format);
-	mbus_to_pix(vpfe_dev, &sd_fmt.format, &pix_test, &vpfe_dev->bpp);
-	pix->bytesperline = pix->width * 2;
-	pix->sizeimage = pix->bytesperline * pix->height;
+	v4l2_fill_pix_format(pix, &sd_fmt.format);
+	mbus_to_pix(vpfe_dev, &sd_fmt.format, pix, &vpfe_dev->bpp);
 
 	dev_dbg(vpfe_dev->pdev, "vpfe_config_image_format pix 1: size %dx%d pixelformat: %s bytesperline = %d, sizeimage = %d\n",
 		 pix->width, pix->height,
 		 print_fourcc(pix->pixelformat),
 		 pix->bytesperline, pix->sizeimage);
 
-	dev_dbg(vpfe_dev->pdev, "vpfe_config_image_format pix_test: size %dx%d pixelformat: %s bytesperline = %d, sizeimage = %d, bpp = %d\n",
-		 pix_test.width, pix_test.height,
-		 print_fourcc(pix_test.pixelformat),
-		 pix_test.bytesperline, pix_test.sizeimage, vpfe_dev->bpp);
+	/* Update the crop window based on found values */
+	vpfe_dev->crop.width = pix->width;
+	vpfe_dev->crop.height = pix->height;
 
 	/* Sets the values in ISIF */
 	ret = vpfe_config_isif_image_format(vpfe_dev);
-	if (ret)
-		return ret;
 
-	/* Update the values of sizeimage and bytesperline */
-	if (!ret) {
-		pix->bytesperline = vpfe_dev->vpfe_isif.hw_ops.get_line_length(
-					&vpfe_dev->vpfe_isif);
-		pix->sizeimage = pix->bytesperline * pix->height;
-		dev_dbg(vpfe_dev->pdev, "vpfe_config_image_format pix 2: size %dx%d pixelformat: %s bytesperline = %d, sizeimage = %d\n",
-			 pix->width, pix->height,
-			 print_fourcc(pix->pixelformat),
-			 pix->bytesperline, pix->sizeimage);
-	}
 	return ret;
 }
 
@@ -868,6 +930,7 @@ vpfe_remote_subdev(struct vpfe_device *vpfe_dev, u32 *pad)
 
 	if (pad)
 		*pad = remote->index;
+
 	return media_entity_to_v4l2_subdev(remote->entity);
 }
 
@@ -897,14 +960,51 @@ static int __vpfe_get_format(struct vpfe_device *vpfe_dev,
 
 	format->type = vpfe_dev->fmt.type;
 
-	dev_dbg(vpfe_dev->pdev, "__vpfe_get_format: mbus->code: %x\n",
-		fmt.format.code);
+	/* convert mbus_format to v4l2_format */
+	v4l2_fill_pix_format(&format->fmt.pix, &fmt.format);
+	mbus_to_pix(vpfe_dev, &fmt.format, &format->fmt.pix, bpp);
+	dev_dbg(vpfe_dev->pdev, "__vpfe_get_format size %dx%d (%s) bytesperline = %d, sizeimage = %d, bpp = %d\n",
+		 format->fmt.pix.width, format->fmt.pix.height,
+		 print_fourcc(format->fmt.pix.pixelformat),
+		 format->fmt.pix.bytesperline, format->fmt.pix.sizeimage, *bpp);
+
+	return 0;
+}
+
+/* set the format at output pad of the adjacent subdev */
+static int __vpfe_set_format(struct vpfe_device *vpfe_dev,
+			struct v4l2_format *format, unsigned int *bpp)
+{
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *subdev;
+	struct media_pad *remote;
+	u32 pad;
+	int ret;
+
+	dev_dbg(vpfe_dev->pdev, "__vpfe_set_format\n");
+
+	subdev = vpfe_remote_subdev(vpfe_dev, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	remote = media_entity_remote_source(&vpfe_dev->pad);
+	fmt.pad = remote->index;
+
+	pix_to_mbus(vpfe_dev, &format->fmt.pix, &fmt.format);
+
+	ret = v4l2_subdev_call(subdev, pad, set_fmt, NULL, &fmt);
+	if (ret == -ENOIOCTLCMD)
+		return -EINVAL;
+
+	format->type = vpfe_dev->fmt.type;
 
 	/* convert mbus_format to v4l2_format */
 	v4l2_fill_pix_format(&format->fmt.pix, &fmt.format);
 	mbus_to_pix(vpfe_dev, &fmt.format, &format->fmt.pix, bpp);
-	dev_dbg(vpfe_dev->pdev, "__vpfe_get_format size %dx%d bytesperline = %d, sizeimage = %d, bpp = %d\n",
+	dev_dbg(vpfe_dev->pdev, "__vpfe_set_format size %dx%d (%s) bytesperline = %d, sizeimage = %d, bpp = %d\n",
 		 format->fmt.pix.width, format->fmt.pix.height,
+		 print_fourcc(format->fmt.pix.pixelformat),
 		 format->fmt.pix.bytesperline, format->fmt.pix.sizeimage, *bpp);
 
 	return 0;
@@ -991,8 +1091,15 @@ static int vpfe_s_fmt(struct file *file, void *priv,
 	ret = __vpfe_get_format(vpfe_dev, &format, &bpp);
 	if (ret)
 		return ret;
-
-	*fmt = format;
+	if (!cmp_v4l2_format(fmt, &format)) {
+		/* Sensor format is different from the requested format
+		 * so we need to change it
+		 */
+		ret = __vpfe_set_format(vpfe_dev, fmt, &bpp);
+		if (ret)
+			return ret;
+	} else /* Just make sure all of the fields are consistent */
+		*fmt = format;
 
 	/* store the pixel format in the device  object */
 	ret = mutex_lock_interruptible(&vpfe_dev->lock);
@@ -1004,6 +1111,10 @@ static int vpfe_s_fmt(struct file *file, void *priv,
 	vpfe_dev->fmt = *fmt;
 	vpfe_dev->bpp = bpp;
 
+	/* Update the crop window based on found values */
+	vpfe_dev->crop.width = fmt->fmt.pix.width;
+	vpfe_dev->crop.height = fmt->fmt.pix.height;
+
 	/* set image capture parameters in the isif */
 	ret = vpfe_config_isif_image_format(vpfe_dev);
 	mutex_unlock(&vpfe_dev->lock);
@@ -1028,6 +1139,54 @@ static int vpfe_try_fmt(struct file *file, void *priv,
 	return 0;
 }
 
+static int vpfe_enum_size(struct file *file, void  *priv,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	struct vpfe_device *vpfe_dev = video_drvdata(file);
+	struct v4l2_mbus_framefmt mbus;
+	struct v4l2_subdev_frame_size_enum fse;
+	struct v4l2_subdev *subdev;
+	struct media_pad *remote;
+	struct v4l2_pix_format pix;
+	u32 pad;
+	int ret;
+
+	dev_dbg(vpfe_dev->pdev, "vpfe_enum_size\n");
+
+	subdev = vpfe_remote_subdev(vpfe_dev, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	/* Construct pix from parameter and use defualt for the rest */
+	pix.pixelformat = fsize->pixel_format;
+	pix.width = 640;
+	pix.height = 480;
+	pix.colorspace = V4L2_COLORSPACE_JPEG;
+	pix.field = V4L2_FIELD_NONE;
+	pix_to_mbus(vpfe_dev, &pix, &mbus);
+	remote = media_entity_remote_source(&vpfe_dev->pad);
+	fse.index = fsize->index;
+	fse.pad = remote->index;
+	fse.code = mbus.code;
+	ret = v4l2_subdev_call(subdev, pad, enum_frame_size, NULL, &fse);
+	if (ret)
+		return -EINVAL;
+
+	dev_dbg(vpfe_dev->pdev, "vpfe_enum_size: index: %d code: %x W:[%d,%d] H:[%d,%d]\n",
+		fse.index, fse.code, fse.min_width, fse.max_width,
+		fse.min_height, fse.max_height);
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = fse.max_width;
+	fsize->discrete.height = fse.max_height;
+
+	dev_dbg(vpfe_dev->pdev, "vpfe_enum_size: index: %d pixformat: %s size: %dx%d\n",
+		fsize->index, print_fourcc(fsize->pixel_format),
+		fsize->discrete.width, fsize->discrete.height);
+
+	return 0;
+}
+
 /*
  * vpfe_get_subdev_input_index - Get subdev index and subdev input index for a
  * given app input index
@@ -1936,6 +2095,7 @@ static const struct v4l2_ioctl_ops vpfe_ioctl_ops = {
 	.vidioc_enum_fmt_vid_cap = vpfe_enum_fmt,
 	.vidioc_s_fmt_vid_cap    = vpfe_s_fmt,
 	.vidioc_try_fmt_vid_cap  = vpfe_try_fmt,
+	.vidioc_enum_framesizes  = vpfe_enum_size,
 	.vidioc_enum_input	 = vpfe_enum_input,
 	.vidioc_g_input		 = vpfe_g_input,
 	.vidioc_s_input		 = vpfe_s_input,
-- 
1.7.5.4

