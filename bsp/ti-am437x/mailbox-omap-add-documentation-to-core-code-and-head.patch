From 4e802cb85539e731cdb9a615ca6918452ecf0b32 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Wed, 25 Sep 2013 16:09:59 -0500
Subject: [PATCH 151/188] mailbox/omap: add documentation to core code and
 headers

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

The current omap mailbox code lacks any meaningful documentation,
making life hard for any new users to understand the API/usage.
Hopefully, this patch adds enough basic info for the developers.

This patch does not touch any code pieces, it is strictly limited
to documentation and code comments.

Signed-off-by: Suman Anna <s-anna@ti.com>
(cherry picked from commit cf5c40ee1a8c163c55ea83a07073b25f3ceb9327)
---
 drivers/mailbox/omap-mailbox.c |  178 ++++++++++++++++++++++++++++++++++++++--
 drivers/mailbox/omap-mbox.h    |  101 ++++++++++++++++++++++-
 include/linux/omap-mailbox.h   |    7 ++
 3 files changed, 278 insertions(+), 8 deletions(-)

diff --git a/drivers/mailbox/omap-mailbox.c b/drivers/mailbox/omap-mailbox.c
index 87e06d8..bcac0f3 100644
--- a/drivers/mailbox/omap-mailbox.c
+++ b/drivers/mailbox/omap-mailbox.c
@@ -36,11 +36,12 @@
 static DEFINE_MUTEX(omap_mbox_devices_lock);
 static LIST_HEAD(omap_mbox_devices);
 
+/* default size for the fifos, configured through kernel menuconfig */
 static unsigned int mbox_kfifo_size = CONFIG_OMAP_MBOX_KFIFO_SIZE;
 module_param(mbox_kfifo_size, uint, S_IRUGO);
 MODULE_PARM_DESC(mbox_kfifo_size, "Size of omap's mailbox kfifo (bytes)");
 
-/* Mailbox FIFO handle functions */
+/* mailbox h/w transport communication handler helper functions */
 static inline mbox_msg_t mbox_fifo_read(struct omap_mbox *mbox)
 {
 	return mbox->ops->fifo_read(mbox);
@@ -53,12 +54,16 @@ static inline int mbox_fifo_empty(struct omap_mbox *mbox)
 {
 	return mbox->ops->fifo_empty(mbox);
 }
+/*
+ * local helper to check if the h/w transport is busy or free.
+ * Returns 0 if free, and non-zero otherwise
+ */
 static inline int mbox_poll_for_space(struct omap_mbox *mbox)
 {
 	return mbox->ops->poll_for_space(mbox);
 }
 
-/* Mailbox IRQ handle functions */
+/* mailbox h/w irq handler helper functions */
 static inline void ack_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
 {
 	if (mbox->ops->ack_irq)
@@ -69,8 +74,20 @@ static inline int is_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
 	return mbox->ops->is_irq(mbox, irq);
 }
 
-/*
- * message sender
+/**
+ * omap_mbox_msg_send() - send a mailbox message
+ * @mbox: handle to the acquired mailbox on which to send the message
+ * @msg: the mailbox message to be sent
+ *
+ * This API is called by a client user to send a mailbox message on an
+ * acquired mailbox. The API transmits the message immediately on the h/w
+ * communication transport if it is available, otherwise buffers the
+ * message for transmission as soon as the h/w transport is ready.
+ *
+ * The only failure from this function is when neither the h/w transport
+ * is available nor the s/w buffer fifo is empty.
+ *
+ * Returns 0 on success, or an error otherwise
  */
 int omap_mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg)
 {
@@ -100,6 +117,17 @@ out:
 }
 EXPORT_SYMBOL(omap_mbox_msg_send);
 
+/**
+ * omap_mbox_save_ctx: save the context of a mailbox
+ * @mbox: handle to the acquired mailbox
+ *
+ * This allows a client (controlling a remote) to request a mailbox to
+ * save its context when it is powering down the remote.
+ *
+ * NOTE: This will be eventually deprecated, new clients should not use this.
+ *	 The same feature can be enabled through runtime_pm enablement of
+ *	 mailbox.
+ */
 void omap_mbox_save_ctx(struct omap_mbox *mbox)
 {
 	if (!mbox->ops->save_ctx) {
@@ -111,6 +139,18 @@ void omap_mbox_save_ctx(struct omap_mbox *mbox)
 }
 EXPORT_SYMBOL(omap_mbox_save_ctx);
 
+/**
+ * omap_mbox_restore_ctx: restore the context of a mailbox
+ * @mbox: handle to the acquired mailbox
+ *
+ * This allows a client (controlling a remote) to request a mailbox to
+ * restore its context after restoring the remote, so that it can
+ * communicate with the remote as it would normally.
+ *
+ * NOTE: This will be deprecated, new clients should not use this.
+ *	 The same feature can be enabled through runtime_pm enablement
+ *	 of mailbox.
+ */
 void omap_mbox_restore_ctx(struct omap_mbox *mbox)
 {
 	if (!mbox->ops->restore_ctx) {
@@ -122,18 +162,48 @@ void omap_mbox_restore_ctx(struct omap_mbox *mbox)
 }
 EXPORT_SYMBOL(omap_mbox_restore_ctx);
 
+/**
+ * omap_mbox_enable_irq: enable a specific mailbox Rx or Tx interrupt source
+ * @mbox: handle to the acquired mailbox
+ * @irq: interrupt type associated with either the Rx or Tx
+ *
+ * This allows a client (having its own shared memory communication protocol
+ * with the remote) to request a mailbox to enable a particular interrupt
+ * signal source of the mailbox, as part of its communication state machine.
+ *
+ * NOTE: This will be deprecated, new clients should not use this. It is
+ *	 being exported for TI DSP/Bridge driver.
+ */
 void omap_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
 {
 	mbox->ops->enable_irq(mbox, irq);
 }
 EXPORT_SYMBOL(omap_mbox_enable_irq);
 
+/**
+ * omap_mbox_disable_irq: disable a specific mailbox Rx or Tx interrupt source
+ * @mbox: handle to the acquired mailbox
+ * @irq: interrupt type associated with either the Rx or Tx
+ *
+ * This allows a client (having its own shared memory communication protocal
+ * with the remote) to request a mailbox to disable a particular interrupt
+ * signal source of the mailbox, as part of its communication state machine.
+ *
+ * NOTE: This will be deprecated, new clients should not use this. It is
+ *	 being exported for TI DSP/Bridge driver.
+ */
 void omap_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
 {
 	mbox->ops->disable_irq(mbox, irq);
 }
 EXPORT_SYMBOL(omap_mbox_disable_irq);
 
+/*
+ * This is the tasklet function in which all the buffered messages are
+ * sent until the h/w transport is busy again. The tasklet is scheduled
+ * upon receiving an interrupt indicating the availability of the h/w
+ * transport.
+ */
 static void mbox_tx_tasklet(unsigned long tx_data)
 {
 	struct omap_mbox *mbox = (struct omap_mbox *)tx_data;
@@ -156,7 +226,12 @@ static void mbox_tx_tasklet(unsigned long tx_data)
 }
 
 /*
- * Message receiver(workqueue)
+ * This is the message receiver workqueue function, which is responsible
+ * for delivering all the received messages stored in the receive kfifo
+ * to the clients. Each message is delivered to all the registered mailbox
+ * clients. It also re-enables the receive interrupt on the mailbox (disabled
+ * when the s/w kfifo is full) after emptying atleast a message from the
+ * fifo.
  */
 static void mbox_rx_work(struct work_struct *work)
 {
@@ -181,7 +256,9 @@ static void mbox_rx_work(struct work_struct *work)
 }
 
 /*
- * Mailbox interrupt handler
+ * Interrupt handler for Tx interrupt source for each of the mailboxes.
+ * This schedules the tasklet to transmit the messages buffered in the
+ * Tx fifo.
  */
 static void __mbox_tx_interrupt(struct omap_mbox *mbox)
 {
@@ -190,6 +267,12 @@ static void __mbox_tx_interrupt(struct omap_mbox *mbox)
 	tasklet_schedule(&mbox->txq->tasklet);
 }
 
+/*
+ * Interrupt handler for Rx interrupt source for each of the mailboxes.
+ * This performs the read from the h/w mailbox until the transport is
+ * free of any incoming messages, and buffers the read message. The
+ * buffers are delivered to clients by scheduling a work-queue.
+ */
 static void __mbox_rx_interrupt(struct omap_mbox *mbox)
 {
 	struct omap_mbox_queue *mq = mbox->rxq;
@@ -215,6 +298,10 @@ nomem:
 	schedule_work(&mbox->rxq->work);
 }
 
+/*
+ * The core mailbox interrupt handler function. The interrupt core would
+ * call this for each of the mailboxes the interrupt is configured.
+ */
 static irqreturn_t mbox_interrupt(int irq, void *p)
 {
 	struct omap_mbox *mbox = p;
@@ -228,6 +315,12 @@ static irqreturn_t mbox_interrupt(int irq, void *p)
 	return IRQ_HANDLED;
 }
 
+/*
+ * Helper function to allocate a mailbox queue object. This function
+ * also creates either or both of the work-queue or tasklet to
+ * deal with processing of messages on the kfifo associated with
+ * the mailbox queue object.
+ */
 static struct omap_mbox_queue *mbox_queue_alloc(struct omap_mbox *mbox,
 					void (*work) (struct work_struct *),
 					void (*tasklet)(unsigned long))
@@ -254,12 +347,21 @@ error:
 	return NULL;
 }
 
+/*
+ * Helper function to free a mailbox queue object.
+ */
 static void mbox_queue_free(struct omap_mbox_queue *q)
 {
 	kfifo_free(&q->fifo);
 	kfree(q);
 }
 
+/*
+ * Helper function to initialize a mailbox. This function creates
+ * the mailbox queue objects associated with the mailbox h/w channel
+ * and plugs-in the interrupt associated with the mailbox, when the
+ * mailbox h/w channel is requested for the first time.
+ */
 static int omap_mbox_startup(struct omap_mbox *mbox)
 {
 	int ret = 0;
@@ -314,6 +416,9 @@ fail_startup:
 	return ret;
 }
 
+/*
+ * Helper function to de-initialize a mailbox
+ */
 static void omap_mbox_fini(struct omap_mbox *mbox)
 {
 	struct omap_mbox_device *mdev = mbox->parent;
@@ -335,6 +440,11 @@ static void omap_mbox_fini(struct omap_mbox *mbox)
 	mutex_unlock(&mdev->cfg_lock);
 }
 
+/*
+ * Helper function to find a mailbox. It is currently assumed that all the
+ * mailbox names are unique among all the mailbox devices. This can be
+ * easily extended if only a particular mailbox device is to searched.
+ */
 static struct omap_mbox *omap_mbox_device_find(struct omap_mbox_device *mdev,
 						const char *mbox_name)
 {
@@ -354,6 +464,23 @@ static struct omap_mbox *omap_mbox_device_find(struct omap_mbox_device *mdev,
 	return mbox;
 }
 
+/**
+ * omap_mbox_get() - acquire a mailbox
+ * @name: name of the mailbox to acquire
+ * @nb: notifier block to be invoked on received messages
+ *
+ * This API is called by a client user to use a mailbox. The returned handle
+ * needs to be used by the client for invoking any other mailbox API. Any
+ * message received on the mailbox is delivered to the client through the
+ * 'nb' notifier. There are currently no restrictions on multiple clients
+ * acquiring the same mailbox - the same message is delivered to each of the
+ * clients through their respective notifiers.
+ *
+ * The function ensures that the mailbox is put into an operational state
+ * before the function returns.
+ *
+ * Returns a usable mailbox handle on success, or NULL otherwise
+ */
 struct omap_mbox *omap_mbox_get(const char *name, struct notifier_block *nb)
 {
 	struct omap_mbox *mbox = NULL;
@@ -384,6 +511,18 @@ struct omap_mbox *omap_mbox_get(const char *name, struct notifier_block *nb)
 }
 EXPORT_SYMBOL(omap_mbox_get);
 
+/**
+ * omap_mbox_put() - release a mailbox
+ * @mbox: handle to the acquired mailbox
+ * @nb: notifier block used while acquiring the mailbox
+ *
+ * This API is to be called by a client user once it is done using the
+ * mailbox. The particular user's notifier function is removed from the
+ * notifier list of received messages on this mailbox. It also undoes
+ * any h/w configuration done during the acquisition of the mailbox.
+ *
+ * No return value
+ */
 void omap_mbox_put(struct omap_mbox *mbox, struct notifier_block *nb)
 {
 	blocking_notifier_chain_unregister(&mbox->notifier, nb);
@@ -393,6 +532,21 @@ EXPORT_SYMBOL(omap_mbox_put);
 
 static struct class omap_mbox_class = { .name = "mbox", };
 
+/**
+ * omap_mbox_register() - register the list of mailboxes
+ * @mdev: mailbox device handle containing the mailboxes that need to be
+ *	  with the mailbox core
+ *
+ * This API is to be called by individual mailbox driver implementations
+ * for registering the set of mailboxes contained in a h/w communication
+ * block with the mailbox core. Each of the mailbox represents a h/w
+ * communication channel, contained within the h/w communication block or ip.
+ *
+ * An associated device is also created for each of the mailboxes, and the
+ * mailbox device is added to a global list of registered mailbox devices.
+ *
+ * Return 0 on success, or a failure code otherwise
+ */
 int omap_mbox_register(struct omap_mbox_device *mdev)
 {
 	int ret;
@@ -428,6 +582,18 @@ err_out:
 }
 EXPORT_SYMBOL(omap_mbox_register);
 
+/**
+ * omap_mbox_unregister() - unregister the list of mailboxes
+ * @mdev: parent mailbox device handle containing the mailboxes that need
+ *	  to be unregistered
+ *
+ * This API is to be called by individual mailbox driver implementations
+ * for unregistering the set of mailboxes contained in a h/w communication
+ * block. Once unregistered, these mailboxes are not available for any
+ * client users/drivers.
+ *
+ * Return 0 on success, or a failure code otherwise
+ */
 int omap_mbox_unregister(struct omap_mbox_device *mdev)
 {
 	int i;
diff --git a/drivers/mailbox/omap-mbox.h b/drivers/mailbox/omap-mbox.h
index 3836da9..38efd0f 100644
--- a/drivers/mailbox/omap-mbox.h
+++ b/drivers/mailbox/omap-mbox.h
@@ -16,10 +16,54 @@
 #include <linux/workqueue.h>
 #include <linux/omap-mailbox.h>
 
+/**
+ * struct omap_mbox_ops - function ops specific to a mailbox implementation
+ * @startup: the startup function, essential for making the mailbox active.
+ *	     This will be called when a client acquires the mailbox. The driver
+ *	     implementation needs to take care of any refcounting if the same
+ *	     mailbox is requested by multiple clients.
+ * @shutdown: the shutdown function, essential for making the mailbox inactive
+ *	      after usage. This will be called when a client releases the
+ *	      mailbox. The driver implementation needs to take care of any
+ *	      refcounting if the same mailbox is requested by multiple clients.
+ * @fifo_read: read and return the h/w transport payload message. This hook
+ *	       provides the omap mailbox core to read all the available messages
+ *	       upon a Rx interrupt and buffer them. The messages are delivered
+ *	       to the clients in a workqueue.
+ * @fifo_write: send a mailbox message packet on the h/w transport channel. The
+ *		individual drivers are responsible for configuring the h/w
+ *		accordingly.
+ * @fifo_empty: check if the h/w Rx transport has more messages. The function
+ *		should return 0 if there are no more messages to be read from
+ *		the transport, and non-zero if there are available messages.
+ * @poll_for_space: check if the h/w Tx transport is busy. This hook should
+ *		    return non-zero if the h/w Tx transport is busy, and 0 when
+ *		    the h/w communication channel is free.
+ * @enable_irq: This hook allows the mailbox core to allow a specific Rx or Tx
+ *		interrupt signal to interrupt the processor, based on its state
+ *		machine.
+ * @disable_irq: This hooks allows the mailbox core to disable a specific Rx or
+ *		 Tx interrupt signal from interrupting the processor, based on
+ *		 its state machine.
+ * @ack_irq: acknowledge the Tx or Rx interrupt signal internal to the mailbox.
+ *	     This allows the h/w communication block to clear any internal
+ *	     interrupt source status registers.
+ * @is_irq: check if a particular Tx or Rx interrupt signal on the corresponding
+ *	    mailbox is set. This hook is used by the mailbox core to process the
+ *	    interrupt accordingly.
+ * @save_ctx: Called by a client or the mailbox core to allow the individual
+ *	      driver implementation to save the context of the mailbox registers
+ *	      before the domain containing the h/w communication block can be
+ *	      put into a low-power state.
+ * @restore_ctx: Called by a client or the mailbox core to allow the individual
+ *	      driver implementation to restore the context of the mailbox
+ *	      registers after the domain containing the h/w communication block
+ *	      is powered back to active state.
+ */
 struct omap_mbox_ops {
 	int		(*startup)(struct omap_mbox *mbox);
 	void		(*shutdown)(struct omap_mbox *mbox);
-	/* fifo */
+	/* mailbox access */
 	mbox_msg_t	(*fifo_read)(struct omap_mbox *mbox);
 	void		(*fifo_write)(struct omap_mbox *mbox, mbox_msg_t msg);
 	int		(*fifo_empty)(struct omap_mbox *mbox);
@@ -31,11 +75,28 @@ struct omap_mbox_ops {
 						omap_mbox_irq_t irq);
 	void		(*ack_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
 	int		(*is_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
-	/* ctx */
+	/* context */
 	void		(*save_ctx)(struct omap_mbox *mbox);
 	void		(*restore_ctx)(struct omap_mbox *mbox);
 };
 
+/**
+ * struct omap_mbox_queue - A queue object used for buffering messages
+ * @lock: a spinlock providing synchronization in atomic context
+ * @fifo: a kfifo object for buffering the messages. The size of the kfifo is
+ *	  is currently configured either at build time using kernel menu
+ *	  configuration or at runtime through a module parameter. The usage of
+ *	  the kfifo depends on whether the queue object is for Rx or Tx. For Tx,
+ *	  a message is buffered into the kfifo if the h/w transport is busy, and
+ *	  is taken out when the h/w signals Tx readiness. For Rx, the messages
+ *	  are buffered into the kfifo in the bottom-half processing of a Rx
+ *	  interrupt, and taken out during the top-half processing.
+ * @work: a workqueue object for scheduling top-half processing of rx messages
+ * @tasklet: a tasklet object for processing tx messages in an atomic context
+ * @mbox: reference to the containing parent mailbox
+ * full: indicates the status of the fifo, and is set to true when there is no
+ *	 room in the fifo.
+ */
 struct omap_mbox_queue {
 	spinlock_t		lock;
 	struct kfifo		fifo;
@@ -45,6 +106,19 @@ struct omap_mbox_queue {
 	bool full;
 };
 
+/**
+ * struct omap_mbox_device - device structure for storing h/w mailbox block
+ * @dev:	reference device pointer of the h/w mailbox block
+ * @cfg_lock:	a configuration mutex lock used for protecting the mailbox
+ *		device configuration operations
+ * @mbox_base:	ioremapped base address of the h/w mailbox block
+ * @num_users:	number of output interrupts from the h/w mailbox block, multiple
+ *		interrupts can be routed to a particular processor sub-system
+ * @num_fifos:	number of individual h/w fifo queues supported within a h/w
+ *		mailbox block
+ * @mboxes:	array of containing mailboxes within the h/w mailbox block
+ * @elem:	list node
+ */
 struct omap_mbox_device {
 	struct device *dev;
 	struct mutex cfg_lock;
@@ -55,6 +129,25 @@ struct omap_mbox_device {
 	struct list_head elem;
 };
 
+/**
+ * struct omap_mbox - the base object describing a h/w communication channel.
+ *	  there can be more than one object in a h/w communication block
+ * @name: a unique name for the mailbox object. Client users acquire a
+ *	  mailbox object using this name
+ * @irq: IRQ number that the mailbox uses to interrupt the host processor.
+ *	 the same IRQ number may be shared between different mailboxes
+ * @txq: the mailbox queue object pertaining to Tx
+ * @rxq: the mailbox queue object pertaining to Rx
+ * @ops: function ops specific to the mailbox
+ * @dev: the device pointer representing the mailbox object
+ * @parent: back reference to the containing parent mailbox device object
+ * @priv: a private structure specific to the driver implementation, this will
+ *	  not be touched by the mailbox core
+ * @use_count: number of current references to the mailbox, useful in
+ *	       controlling the mailbox state
+ * @notifier: notifier chain of clients, to which a received message is
+ *	      communicated
+ */
 struct omap_mbox {
 	const char		*name;
 	unsigned int		irq;
@@ -67,6 +160,10 @@ struct omap_mbox {
 	struct blocking_notifier_head	notifier;
 };
 
+/*
+ * mailbox objects registration and de-registration functions with the
+ * mailbox core.
+ */
 int omap_mbox_register(struct omap_mbox_device *device);
 int omap_mbox_unregister(struct omap_mbox_device *device);
 
diff --git a/include/linux/omap-mailbox.h b/include/linux/omap-mailbox.h
index f8322d9..86c8943 100644
--- a/include/linux/omap-mailbox.h
+++ b/include/linux/omap-mailbox.h
@@ -9,20 +9,27 @@
 #ifndef OMAP_MAILBOX_H
 #define OMAP_MAILBOX_H
 
+/* forward declaration for clients */
 typedef u32 mbox_msg_t;
 struct omap_mbox;
 
+/* interrupt direction identifiers */
 typedef int __bitwise omap_mbox_irq_t;
 #define IRQ_TX ((__force omap_mbox_irq_t) 1)
 #define IRQ_RX ((__force omap_mbox_irq_t) 2)
 
+/* client api for message transmission */
 int omap_mbox_msg_send(struct omap_mbox *, mbox_msg_t msg);
 
+/* client api for acquiring and releasing a mailbox */
 struct omap_mbox *omap_mbox_get(const char *, struct notifier_block *nb);
 void omap_mbox_put(struct omap_mbox *mbox, struct notifier_block *nb);
 
+/* client api for saving and restoring context */
 void omap_mbox_save_ctx(struct omap_mbox *mbox);
 void omap_mbox_restore_ctx(struct omap_mbox *mbox);
+
+/* client api for manipulating mailbox interrupts */
 void omap_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq);
 void omap_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq);
 
-- 
1.7.5.4

