From 52216329a6c733e2ff9c2f034aee0b8682bfd42a Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Wed, 9 Oct 2013 12:32:44 +0300
Subject: [PATCH 261/285] phy: omap-pipe3: prepare/unprepare clocks while
 enable/disable

As there is no need for the clocks to be enabled/disabled
atomically, we can combine prepare/unprepare operations
with enable/disable.

Signed-off-by: Roger Quadros <rogerq@ti.com>
Acked-by: Felipe Balbi <balbi@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/phy/phy-omap-pipe3.c |   30 ++++++++----------------------
 1 files changed, 8 insertions(+), 22 deletions(-)

diff --git a/drivers/phy/phy-omap-pipe3.c b/drivers/phy/phy-omap-pipe3.c
index 7ad4363..012400c 100644
--- a/drivers/phy/phy-omap-pipe3.c
+++ b/drivers/phy/phy-omap-pipe3.c
@@ -332,20 +332,14 @@ static int omap_pipe3_probe(struct platform_device *pdev)
 	phy->wkupclk = devm_clk_get(phy->dev, "wkupclk");
 	if (IS_ERR(phy->wkupclk))
 		dev_dbg(&pdev->dev, "unable to get wkupclk\n");
-	else
-		clk_prepare(phy->wkupclk);
 
 	phy->optclk = devm_clk_get(phy->dev, "refclk");
 	if (IS_ERR(phy->optclk))
 		dev_dbg(&pdev->dev, "unable to get refclk\n");
-	else
-		clk_prepare(phy->optclk);
 
 	phy->optclk2 = devm_clk_get(phy->dev, "refclk2");
 	if (IS_ERR(phy->optclk2))
 		dev_dbg(&pdev->dev, "unable to get refclk2\n");
-	else
-		clk_prepare(phy->optclk2);
 
 	control_node = of_parse_phandle(node, "ctrl-module", 0);
 	if (!control_node) {
@@ -384,14 +378,6 @@ static int omap_pipe3_probe(struct platform_device *pdev)
 
 static int omap_pipe3_remove(struct platform_device *pdev)
 {
-	struct omap_pipe3 *phy = platform_get_drvdata(pdev);
-
-	if (!IS_ERR(phy->wkupclk))
-		clk_unprepare(phy->wkupclk);
-	if (!IS_ERR(phy->optclk))
-		clk_unprepare(phy->optclk);
-	if (!IS_ERR(phy->optclk2))
-		clk_unprepare(phy->optclk2);
 	if (!pm_runtime_suspended(&pdev->dev))
 		pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -406,11 +392,11 @@ static int omap_pipe3_runtime_suspend(struct device *dev)
 	struct omap_pipe3	*phy = dev_get_drvdata(dev);
 
 	if (!IS_ERR(phy->wkupclk))
-		clk_disable(phy->wkupclk);
+		clk_disable_unprepare(phy->wkupclk);
 	if (!IS_ERR(phy->optclk))
-		clk_disable(phy->optclk);
+		clk_disable_unprepare(phy->optclk);
 	if (!IS_ERR(phy->optclk2))
-		clk_disable(phy->optclk2);
+		clk_disable_unprepare(phy->optclk2);
 
 	return 0;
 }
@@ -421,7 +407,7 @@ static int omap_pipe3_runtime_resume(struct device *dev)
 	struct omap_pipe3	*phy = dev_get_drvdata(dev);
 
 	if (!IS_ERR(phy->optclk)) {
-		ret = clk_enable(phy->optclk);
+		ret = clk_prepare_enable(phy->optclk);
 		if (ret) {
 			dev_err(phy->dev, "Failed to enable optclk %d\n", ret);
 			goto err1;
@@ -429,7 +415,7 @@ static int omap_pipe3_runtime_resume(struct device *dev)
 	}
 
 	if (!IS_ERR(phy->wkupclk)) {
-		ret = clk_enable(phy->wkupclk);
+		ret = clk_prepare_enable(phy->wkupclk);
 		if (ret) {
 			dev_err(phy->dev, "Failed to enable wkupclk %d\n", ret);
 			goto err2;
@@ -437,7 +423,7 @@ static int omap_pipe3_runtime_resume(struct device *dev)
 	}
 
 	if (!IS_ERR(phy->optclk2)) {
-		ret = clk_enable(phy->optclk2);
+		ret = clk_prepare_enable(phy->optclk2);
 		if (ret) {
 			dev_err(phy->dev, "Failed to enable optclk2 %d\n", ret);
 			goto err3;
@@ -448,10 +434,10 @@ static int omap_pipe3_runtime_resume(struct device *dev)
 
 err3:
 	if (!IS_ERR(phy->wkupclk))
-		clk_disable(phy->wkupclk);
+		clk_disable_unprepare(phy->wkupclk);
 err2:
 	if (!IS_ERR(phy->optclk))
-		clk_disable(phy->optclk);
+		clk_disable_unprepare(phy->optclk);
 
 err1:
 	return ret;
-- 
1.7.5.4

