From 79ed164f614c1a5157e3db70e7316d09fc34a6ac Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Fri, 31 Jan 2014 12:57:54 +0200
Subject: [PATCH 040/188] usb: musb: core: restore context only if suspended

This commit comes from branch ti-linux-3.12.y:

git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Static variable in a function fails big time with multiple instances.
This will cause musb_runtime_resume to restore invalid context for the
2nd musb instance during probe.

Add a suspended flag to struct musb {} to track whether the controller
is really suspended or not. Restore context only if it was suspended.

Signed-off-by: Roger Quadros <rogerq@ti.com>
(cherry picked from commit 45caf1b9bb9c0ff7d664af374afd8206edd3e531)
---
 drivers/usb/musb/musb_core.c |   37 ++++++++++++++++++++++++-------------
 drivers/usb/musb/musb_core.h |    2 ++
 2 files changed, 26 insertions(+), 13 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index ecd1339..9aaa9a6 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -2286,8 +2286,13 @@ static int musb_suspend(struct device *dev)
 		 */
 	}
 
+	if (musb->suspended)
+		goto exit;
+
 	musb_save_context(musb);
+	musb->suspended = true;
 
+exit:
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return 0;
 }
@@ -2306,7 +2311,15 @@ static int musb_resume_noirq(struct device *dev)
 	 * unconditionally.
 	 */
 
+	if (!musb->suspended)
+		return 0;
+
 	musb_restore_context(musb);
+	musb->suspended = false;
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
 
 	return 0;
 }
@@ -2315,7 +2328,12 @@ static int musb_runtime_suspend(struct device *dev)
 {
 	struct musb	*musb = dev_to_musb(dev);
 
+	dev_dbg(dev, "%s\n", __func__);
+	if (musb->suspended)
+		return 0;
+
 	musb_save_context(musb);
+	musb->suspended = true;
 
 	return 0;
 }
@@ -2323,20 +2341,13 @@ static int musb_runtime_suspend(struct device *dev)
 static int musb_runtime_resume(struct device *dev)
 {
 	struct musb	*musb = dev_to_musb(dev);
-	static int	first = 1;
 
-	/*
-	 * When pm_runtime_get_sync called for the first time in driver
-	 * init,  some of the structure is still not initialized which is
-	 * used in restore function. But clock needs to be
-	 * enabled before any register access, so
-	 * pm_runtime_get_sync has to be called.
-	 * Also context restore without save does not make
-	 * any sense
-	 */
-	if (!first)
-		musb_restore_context(musb);
-	first = 0;
+	dev_dbg(dev, "%s\n", __func__);
+	if (!musb->suspended)
+		return 0;
+
+	musb_restore_context(musb);
+	musb->suspended = false;
 
 	return 0;
 }
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3a58999..6536425 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -428,6 +428,8 @@ struct musb {
 	struct musb_hdrc_config	*config;
 
 	int			xceiv_old_state;
+
+	bool			suspended;	/* controller suspended */
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debugfs_root;
 #endif
-- 
1.7.5.4

