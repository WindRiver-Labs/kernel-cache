From 136159a6fd2b8941964026db214c2c4209f34e8d Mon Sep 17 00:00:00 2001
From: Pekon Gupta <pekon@ti.com>
Date: Thu, 16 Jan 2014 13:54:57 +0530
Subject: [PATCH 140/285] mtd: nand: omap: resolve dependencies to build OMAP
 NAND driver as module

This patch resolves following OMAP NAND driver dependencies if build as module:

(Case-1) ecc-scheme == OMAP_ECC_HAM1_CODE_HW
  - no dependency

(Case-2) ecc-scheme == OMAP_ECC_BCH4_CODE_HW ||
	ecc-scheme == OMAP_ECC_BCH8_CODE_HW
  - ELM driver is also built as module (CONFIG_MTD_NAND_OMAP_BCH=m)
    Either modprobe can be used to automatically resolve dependencies,
    Or following sequence needs to be followed to load ELM and OMAP modules.
      insmod elm.o
      insmod omap2.o
      rmmod omap2
      rmmod elm

(Case-3) ecc-scheme == OMAP_ECC_BCH4_CODE_HW_DETECTION_SW ||
	ecc-scheme == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW
  - no dependency as lib/bch.c cannot be built as loadable module.

Signed-off-by: Pekon Gupta <pekon@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mtd/nand/omap2.c |   27 ++++++++++++++-------------
 1 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
index a932990..59f0881 100644
--- a/drivers/mtd/nand/omap2.c
+++ b/drivers/mtd/nand/omap2.c
@@ -25,11 +25,11 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 
-#ifdef CONFIG_MTD_NAND_ECC_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)
 #include <linux/bch.h>
 #include <linux/mtd/nand_bch.h>
 #endif
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 #include <linux/platform_data/elm.h>
 #endif
 
@@ -129,7 +129,7 @@
 
 #define BADBLOCK_MARKER_LENGTH		0x2
 
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 static u_char bch4_vector[]  = {0x00, 0x6b, 0x31, 0xdd, 0x41, 0xbc, 0x10};
 static u_char bch8_vector[]  = {0xf3, 0xdb, 0x14, 0x16, 0x8b, 0xd2, 0xbe, 0xcc,
 				0xac, 0x6b, 0xff, 0x99, 0x7b};
@@ -1103,7 +1103,7 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 	writel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);
 }
 
-#if defined(CONFIG_MTD_NAND_ECC_BCH) || defined(CONFIG_MTD_NAND_OMAP_BCH)
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH) || IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 /**
  * omap_calculate_ecc_bch - Generate bytes of ECC bytes
  * @mtd:	MTD device structure
@@ -1239,9 +1239,10 @@ static int omap_calculate_ecc_bch(struct mtd_info *mtd, const u_char *dat,
 	}
 	return 0;
 }
-#endif /*defined(CONFIG_MTD_NAND_ECC_BCH) || defined(CONFIG_MTD_NAND_OMAP_BCH)*/
+#endif /* IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH) ||
+	IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH) */
 
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 /**
  * omap_elm_correct_data - corrects page data area in case error reported
  * @mtd:	MTD device structure
@@ -1705,7 +1706,7 @@ static int omap_nand_probe(struct platform_device *pdev)
 		goto custom_ecc_layout;
 		break;
 	case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:
-#ifdef CONFIG_MTD_NAND_ECC_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)
 		pr_info("nand: using OMAP_ECC_BCH4_CODE_HW_DETECTION_SW\n");
 		info->nand.ecc.mode		= NAND_ECC_HW;
 		info->nand.ecc.size		= 512;
@@ -1739,7 +1740,7 @@ static int omap_nand_probe(struct platform_device *pdev)
 #endif
 		break;
 	case OMAP_ECC_BCH4_CODE_HW:
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 		pr_info("nand: using OMAP_ECC_BCH4_CODE_HW ECC scheme\n");
 		info->nand.ecc.mode		= NAND_ECC_HW;
 		info->nand.ecc.size		= 512;
@@ -1772,7 +1773,7 @@ static int omap_nand_probe(struct platform_device *pdev)
 #endif
 		break;
 	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
-#ifdef CONFIG_MTD_NAND_ECC_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)
 		pr_info("nand: using OMAP_ECC_BCH8_CODE_HW_DETECTION_SW\n");
 		info->nand.ecc.mode		= NAND_ECC_HW;
 		info->nand.ecc.size		= 512;
@@ -1806,7 +1807,7 @@ static int omap_nand_probe(struct platform_device *pdev)
 #endif
 		break;
 	case OMAP_ECC_BCH8_CODE_HW:
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 		pr_info("nand: using OMAP_ECC_BCH8_CODE_HW ECC scheme\n");
 		info->nand.ecc.mode		= NAND_ECC_HW;
 		info->nand.ecc.size		= 512;
@@ -1839,7 +1840,7 @@ static int omap_nand_probe(struct platform_device *pdev)
 #endif
 		break;
 	case OMAP_ECC_BCH16_CODE_HW:
-#ifdef CONFIG_MTD_NAND_OMAP_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
 		pr_info("using OMAP_ECC_BCH16_CODE_HW ECC scheme\n");
 		chip->ecc.mode		= NAND_ECC_HW;
 		chip->ecc.size		= 512;
@@ -1916,7 +1917,7 @@ out_release_mem_region:
 	release_mem_region(info->phys_base, info->mem_size);
 
 out_free_info:
-#ifdef CONFIG_MTD_NAND_ECC_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)
 	if (info->nand.ecc.priv) {
 		nand_bch_free(info->nand.ecc.priv);
 		info->nand.ecc.priv = NULL;
@@ -1932,7 +1933,7 @@ static int omap_nand_remove(struct platform_device *pdev)
 	struct mtd_info *mtd = platform_get_drvdata(pdev);
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 							mtd);
-#ifdef CONFIG_MTD_NAND_ECC_BCH
+#if IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)
 	if (info->nand.ecc.priv) {
 		nand_bch_free(info->nand.ecc.priv);
 		info->nand.ecc.priv = NULL;
-- 
1.7.5.4

