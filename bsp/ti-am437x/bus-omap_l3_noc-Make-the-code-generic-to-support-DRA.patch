From 310457b0a37b93924a9e9bf6ce462ad21102540c Mon Sep 17 00:00:00 2001
From: Sricharan R <r.sricharan@ti.com>
Date: Sun, 28 Apr 2013 14:59:03 +0530
Subject: [PATCH 244/285] bus: omap_l3_noc: Make the code generic to support
 DRA interconnect

The dra7xx soc has the same l3-noc interconnect ip (as OMAP4 and OMAP5).
So make the driver code generic to make it easier to add the dra7xx
changes.

Signed-off-by: Sricharan R <r.sricharan@ti.com>
Signed-off-by: Rajendra Nayak <rnayak@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/bus/omap_l3_noc.c |   71 +++++++++++++++++++++++----------------------
 drivers/bus/omap_l3_noc.h |   52 ++++++++++++++++++++++-----------
 2 files changed, 71 insertions(+), 52 deletions(-)

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 264867b..3577e16 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -1,5 +1,5 @@
 /*
- * OMAP4XXX L3 Interconnect error handling driver
+ * OMAP L3 Interconnect error handling driver
  *
  * Copyright (C) 2011 Texas Corporation
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
@@ -27,6 +27,8 @@
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include "omap_l3_noc.h"
 
@@ -56,7 +58,7 @@
 static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 {
 
-	struct omap4_l3 *l3 = _l3;
+	struct omap_l3 *l3 = _l3;
 	int inttype, i, k;
 	int err_src = 0;
 	u32 std_err_main, err_reg, clear, masterid;
@@ -66,13 +68,13 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
 
-	for (i = 0; i < L3_MODULES; i++) {
+	for (i = 0; i < l3->num_modules; i++) {
 		/*
 		 * Read the regerr register of the clock domain
 		 * to determine the source
 		 */
 		base = l3->l3_base[i];
-		err_reg = __raw_readl(base + l3_flagmux[i] +
+		err_reg = __raw_readl(base + l3->l3_flag_mux[i] +
 					+ L3_FLAGMUX_REGERR0 + (inttype << 3));
 
 		/* Get the corresponding error and analyse */
@@ -96,7 +98,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			}
 
 			/* Read the stderrlog_main_source from clk domain */
-			l3_targ_base = base + *(l3_targ[i] + err_src);
+			l3_targ_base = base + *(l3->l3_targets[i] + err_src);
 			std_err_main =  __raw_readl(l3_targ_base +
 					L3_TARG_STDERRLOG_MAIN);
 			masterid = __raw_readl(l3_targ_base +
@@ -105,7 +107,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			switch (std_err_main & CUSTOM_ERROR) {
 			case STANDARD_ERROR:
 				target_name =
-					l3_targ_inst_name[i][err_src];
+					l3->target_names[i][err_src];
 				WARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",
 					target_name,
 					__raw_readl(l3_targ_base +
@@ -118,11 +120,11 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 			case CUSTOM_ERROR:
 				target_name =
-					l3_targ_inst_name[i][err_src];
-				for (k = 0; k < NUM_OF_L3_MASTERS; k++) {
-					if (masterid == l3_masters[k].id)
+					l3->target_names[i][err_src];
+				for (k = 0; k < l3->num_masters; k++) {
+					if (masterid == ((l3->masters_names)[k]).id)
 						master_name =
-							l3_masters[k].name;
+							((l3->masters_names)[k]).name;
 				}
 				WARN(true, "L3 custom error: MASTER:%s TARGET:%s\n",
 					master_name, target_name);
@@ -143,13 +145,22 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	return IRQ_HANDLED;
 }
 
-static int omap4_l3_probe(struct platform_device *pdev)
+static const struct of_device_id l3_noc_match[] = {
+	{.compatible = "ti,omap4-l3-noc", .data = &omap_l3_data},
+	{},
+};
+MODULE_DEVICE_TABLE(of, l3_noc_match);
+
+static int omap_l3_probe(struct platform_device *pdev)
 {
-	static struct omap4_l3 *l3;
+	static struct omap_l3 *l3;
 	struct resource	*res;
 	int ret;
+	const struct of_device_id *of_id =
+				of_match_device(l3_noc_match, &pdev->dev);
+
+	l3 = (struct omap_l3 *)of_id->data;
 
-	l3 = kzalloc(sizeof(*l3), GFP_KERNEL);
 	if (!l3)
 		return -ENOMEM;
 
@@ -234,9 +245,9 @@ err0:
 	return ret;
 }
 
-static int omap4_l3_remove(struct platform_device *pdev)
+static int omap_l3_remove(struct platform_device *pdev)
 {
-	struct omap4_l3 *l3 = platform_get_drvdata(pdev);
+	struct omap_l3 *l3 = platform_get_drvdata(pdev);
 
 	free_irq(l3->app_irq, l3);
 	free_irq(l3->debug_irq, l3);
@@ -248,34 +259,24 @@ static int omap4_l3_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#if defined(CONFIG_OF)
-static const struct of_device_id l3_noc_match[] = {
-	{.compatible = "ti,omap4-l3-noc", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, l3_noc_match);
-#else
-#define l3_noc_match NULL
-#endif
-
-static struct platform_driver omap4_l3_driver = {
-	.probe		= omap4_l3_probe,
-	.remove		= omap4_l3_remove,
+static struct platform_driver omap_l3_driver = {
+	.probe		= omap_l3_probe,
+	.remove		= omap_l3_remove,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,
-		.of_match_table = l3_noc_match,
+		.of_match_table = of_match_ptr(l3_noc_match),
 	},
 };
 
-static int __init omap4_l3_init(void)
+static int __init omap_l3_init(void)
 {
-	return platform_driver_register(&omap4_l3_driver);
+	return platform_driver_register(&omap_l3_driver);
 }
-postcore_initcall_sync(omap4_l3_init);
+postcore_initcall_sync(omap_l3_init);
 
-static void __exit omap4_l3_exit(void)
+static void __exit omap_l3_exit(void)
 {
-	platform_driver_unregister(&omap4_l3_driver);
+	platform_driver_unregister(&omap_l3_driver);
 }
-module_exit(omap4_l3_exit);
+module_exit(omap_l3_exit);
diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 0255b4c..59cd395 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -1,5 +1,5 @@
 /*
- * OMAP4XXX L3 Interconnect  error handling driver header
+ * OMAP L3 Interconnect  error handling driver header
  *
  * Copyright (C) 2011 Texas Corporation
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
@@ -20,10 +20,10 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  * USA
  */
-#ifndef __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
-#define __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
+#ifndef OMAP_L3_NOC_H
+#define OMAP_L3_NOC_H
 
-#define L3_MODULES			3
+#define OMAP_L3_MODULES			3
 #define CLEAR_STDERR_LOG		(1 << 31)
 #define CUSTOM_ERROR			0x2
 #define STANDARD_ERROR			0x0
@@ -41,16 +41,16 @@
 #define L3_FLAGMUX_TARGET_OFS_INVALID	0xdeadbeef
 #define L3_FLAGMUX_TARGET_OFS_TIMEOUT	L3_FLAGMUX_TARGET_OFS_INVALID
 
-#define NUM_OF_L3_MASTERS	(sizeof(l3_masters)/sizeof(l3_masters[0]))
+#define OMAP_NUM_OF_L3_MASTERS	(sizeof(omap_l3_masters)/sizeof(l3_masters[0]))
 
-static u32 l3_flagmux[L3_MODULES] = {
+static u32 omap_l3_flagmux[] = {
 	0x500,
 	0x1000,
 	0X0200
 };
 
 /* L3 Target standard Error register offsets */
-static u32 l3_targ_inst_clk1[] = {
+static u32 omap_l3_targ_inst_clk1[] = {
 	0x100, /* DMM1 */
 	0x200, /* DMM2 */
 	0x300, /* ABE */
@@ -60,7 +60,7 @@ static u32 l3_targ_inst_clk1[] = {
 	0x900	/* L4 Wakeup */
 };
 
-static u32 l3_targ_inst_clk2[] = {
+static u32 omap_l3_targ_inst_clk2[] = {
 	0x500, /* CORTEX M3 */
 	0x300, /* DSS */
 	0x100, /* GPMC */
@@ -84,7 +84,7 @@ static u32 l3_targ_inst_clk2[] = {
 	0x1700 /* LLI */
 };
 
-static u32 l3_targ_inst_clk3[] = {
+static u32 omap_l3_targ_inst_clk3[] = {
 	0x0100	/* EMUSS */,
 	0x0300, /* DEBUGSS_CT_TBR */
 	0x0 /* HOST CLK3 */
@@ -93,7 +93,7 @@ static u32 l3_targ_inst_clk3[] = {
 static struct l3_masters_data {
 	u32 id;
 	char name[10];
-} l3_masters[] = {
+} omap_l3_masters[] = {
 	{ 0x0 , "MPU"},
 	{ 0x10, "CS_ADP"},
 	{ 0x14, "xxx"},
@@ -121,7 +121,7 @@ static struct l3_masters_data {
 	{ 0xC8, "USBHOSTFS"}
 };
 
-static char *l3_targ_inst_name[L3_MODULES][21] = {
+static char *omap_l3_targ_inst_name[][21] = {
 	{
 		"DMM1",
 		"DMM2",
@@ -161,20 +161,38 @@ static char *l3_targ_inst_name[L3_MODULES][21] = {
 	},
 };
 
-static u32 *l3_targ[L3_MODULES] = {
-	l3_targ_inst_clk1,
-	l3_targ_inst_clk2,
-	l3_targ_inst_clk3,
+static u32 *omap_l3_targ[] = {
+	omap_l3_targ_inst_clk1,
+	omap_l3_targ_inst_clk2,
+	omap_l3_targ_inst_clk3,
 };
 
-struct omap4_l3 {
+struct omap_l3 {
 	struct device *dev;
 	struct clk *ick;
 
 	/* memory base */
-	void __iomem *l3_base[L3_MODULES];
+	void __iomem *l3_base[3];
 
+	u32 **l3_targets;
+	struct l3_masters_data *masters_names;
+	char *(*target_names)[21];
+	u32 **l3_timeout_targets;
+	u32 *l3_flag_mux;
 	int debug_irq;
 	int app_irq;
+	int num_modules;
+	int num_masters;
 };
+
+struct omap_l3 omap_l3_data = {
+	.l3_targets = omap_l3_targ,
+	.masters_names = omap_l3_masters,
+	.target_names = omap_l3_targ_inst_name,
+	.l3_timeout_targets = NULL,
+	.num_modules = OMAP_L3_MODULES,
+	.num_masters = sizeof(omap_l3_masters)/sizeof(struct l3_masters_data),
+	.l3_flag_mux = omap_l3_flagmux,
+};
+
 #endif
-- 
1.7.5.4

