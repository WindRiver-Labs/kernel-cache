From d1984bb5710e696fcce80c43572a53cfa8cd7a02 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 13 Feb 2014 16:27:22 +0800
Subject: [PATCH 031/188] usb: musb: musb_dsps: Enable Babble workaround for
 AM335x

This commit f2a67622 comes from branch ti-linux-3.12.y:

git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Added sw controlled babble logic during babble condition,
so that controller does not end the session during the babble
condition.

Based on line-monitor flag, determine whether it is a transient
babble or real babble.

If the transient babble condition occurs the controller is
expected to work normal without restart, if real babble occurs
then restart of controller is needed.

Signed-off-by: George Cherian <george.cherian@ti.com>
Signed-off-by: Ravi Babu <ravibabu@ti.com>
---
 drivers/usb/musb/musb_core.c |    6 +++
 drivers/usb/musb/musb_core.h |    1 +
 drivers/usb/musb/musb_dsps.c |   89 +++++++++++++++++++++++++++++++++++++++++-
 drivers/usb/musb/musb_regs.h |    7 +++
 4 files changed, 101 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index aa82376..f97aeae 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1602,6 +1602,12 @@ irqreturn_t musb_interrupt(struct musb *musb)
 }
 EXPORT_SYMBOL_GPL(musb_interrupt);
 
+void musb_babble_reinit(struct musb *musb)
+{
+	musb_start(musb);
+}
+EXPORT_SYMBOL_GPL(musb_babble_reinit);
+
 #ifndef CONFIG_MUSB_PIO_ONLY
 static bool use_dma = 1;
 
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index dd2cbbf..55e25f6 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -511,6 +511,7 @@ extern void musb_stop(struct musb *musb);
 extern int musb_get_id(struct device *dev, gfp_t gfp_mask);
 extern void musb_put_id(struct device *dev, int id);
 extern void musb_start(struct musb *musb);
+void musb_babble_reinit(struct musb *musb);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
 extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index 75f4a47..66a3eb9 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -268,6 +268,75 @@ static void otg_timer(unsigned long _musb)
 	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
+static void sw_babble_control(struct musb *musb)
+{
+	struct device *dev = musb->controller;
+	struct dsps_glue *glue = dev_get_drvdata(dev->parent);
+	const struct dsps_musb_wrapper *wrp = glue->wrp;
+	void __iomem *base = musb->mregs;
+	int timeout = 10;
+	u8 babble_ctl, session_restart = 0;
+
+	/* wait for 320 clock cycles and check whether still babble
+	 * present on the bus */
+	udelay(6);
+
+	babble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);
+	dev_dbg(musb->controller, "babble: MUSB_BABBLE_CTL value %x\n",
+		babble_ctl);
+
+	/* check line monitor flag to check whether babble is
+	 * due to noise
+	 */
+	dev_dbg(musb->controller, "STUCK_J is %s\n",
+		babble_ctl & MUSB_BABBLE_STUCK_J ? "set" : "reset");
+
+	if (babble_ctl & MUSB_BABBLE_STUCK_J) {
+		/* babble is due to noise, then set transmit idle (d7 bit)
+		 * to resume normal operation
+		 */
+		babble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);
+		babble_ctl |= MUSB_BABBLE_FORCE_TXIDLE;
+		musb_writeb(musb->mregs, MUSB_BABBLE_CTL, babble_ctl);
+
+		/* wait till line monitor flag cleared */
+		dev_dbg(musb->controller, "Set TXIDLE, wait J to clear\n");
+		do {
+			babble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);
+			udelay(1);
+		} while ((babble_ctl & MUSB_BABBLE_STUCK_J) && timeout--);
+
+		/* check whether stuck_at_j bit cleared */
+		babble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);
+		if (babble_ctl & MUSB_BABBLE_STUCK_J) {
+			/* real babble condition is occured
+			 * restart the controller to start the
+			 * session again
+			 */
+			dev_dbg(musb->controller, "J not cleared, misc (%x)\n",
+				babble_ctl);
+
+			session_restart = 1;
+		}
+	} else {
+		session_restart = 1;
+	}
+
+	if (session_restart) {
+		u32 devctl;
+
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		devctl &= ~MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+
+		/* Reset the controller */
+		dsps_writel(base, wrp->control, (1 << wrp->reset));
+
+		musb_platform_set_mode(musb, MUSB_HOST);
+		musb_babble_reinit(musb);
+	}
+}
+
 static irqreturn_t dsps_interrupt(int irq, void *hci)
 {
 	struct musb  *musb = hci;
@@ -278,6 +347,7 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 	unsigned long flags;
 	irqreturn_t ret = IRQ_NONE;
 	u32 epintr, usbintr;
+	bool babble_detected = false;
 
 	spin_lock_irqsave(&musb->lock, flags);
 
@@ -308,8 +378,12 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 	 * value but DEVCTL.BDEVICE is invalid without DEVCTL.SESSION set.
 	 * Also, DRVVBUS pulses for SRP (but not at 5V) ...
 	 */
-	if (is_host_active(musb) && usbintr & MUSB_INTR_BABBLE)
-		pr_info("CAUTION: musb: Babble Interrupt Occurred\n");
+	if (is_host_active(musb) && (usbintr & MUSB_INTR_BABBLE) &&
+	    (musb->xceiv->state == OTG_STATE_A_HOST)) {
+		musb->int_usb |= MUSB_INTR_DISCONNECT;
+		babble_detected = true;
+		ERR("CAUTION: musb: Babble Interrupt Occurred\n");
+	}
 
 	if (usbintr & ((1 << wrp->drvvbus) << wrp->usb_shift)) {
 		int drvvbus = dsps_readl(reg_base, wrp->status);
@@ -363,6 +437,9 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 	if (musb->xceiv->state == OTG_STATE_B_IDLE &&
 			musb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)
 		mod_timer(&glue->timer, jiffies + wrp->poll_seconds * HZ);
+
+	if (babble_detected)
+		sw_babble_control(musb);
 out:
 	spin_unlock_irqrestore(&musb->lock, flags);
 
@@ -411,6 +488,14 @@ static int dsps_musb_init(struct musb *musb)
 	val &= ~(1 << wrp->otg_disable);
 	dsps_writel(musb->ctrl_base, wrp->phy_utmi, val);
 
+	/* enable s/w controlled session bit during
+	 * babble condition
+	 */
+	val = musb_readb(musb->mregs, MUSB_BABBLE_CTL);
+	val |= MUSB_BABBLE_SW_SESSION_CTRL;
+	musb_writeb(musb->mregs, MUSB_BABBLE_CTL, val);
+	dev_info(musb->controller, "Enabled SW babble control\n");
+
 	return 0;
 }
 
diff --git a/drivers/usb/musb/musb_regs.h b/drivers/usb/musb/musb_regs.h
index 03f2655..08ed61c 100644
--- a/drivers/usb/musb/musb_regs.h
+++ b/drivers/usb/musb/musb_regs.h
@@ -202,6 +202,12 @@
 #define MUSB_RXCSR_H_REQPKT		0x0020
 #define MUSB_RXCSR_H_ERROR		0x0004
 
+/*BABBLE  control register offs 0x61 */
+#define MUSB_BABBLE_FORCE_TXIDLE         0x80
+#define MUSB_BABBLE_SW_SESSION_CTRL      0x40
+#define MUSB_BABBLE_STUCK_J              0x20
+#define MUSB_BABBLE_RCV_DISABLE          0x04
+
 /* RXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
 #define MUSB_RXCSR_P_WZC_BITS	\
 	(MUSB_RXCSR_P_SENTSTALL | MUSB_RXCSR_P_OVERRUN \
@@ -246,6 +252,7 @@
  */
 
 #define MUSB_DEVCTL		0x60	/* 8 bit */
+#define MUSB_BABBLE_CTL		0x61	/* 8 bit */
 
 /* These are always controlled through the INDEX register */
 #define MUSB_TXFIFOSZ		0x62	/* 8-bit (see masks) */
-- 
1.7.5.4

