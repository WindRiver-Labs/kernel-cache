From c24c1b805b8e795a8e1cd9e280a7f6cd7fac868d Mon Sep 17 00:00:00 2001
From: Sourav Poddar <sourav.poddar@ti.com>
Date: Wed, 7 Aug 2013 11:15:41 +0530
Subject: [PATCH 094/285] spi/qspi: use gpio to select qspi on AM43x epos evm

On AM43x epos evm, use of qspi and Nand is mutually exclusive. There is
a gpio present which is used to select between qspi and Nand.

As far as kernel is concerned, idea is to enable both qspi and nand
in dts, and able to use one of them based on user requirement.

The patch below makes use of the module parameter(enable_qspi) and expects
nand to use something similar(enable_nand) to get around this.

With this approach,
QSPI on J6: Works fine.
QSPI on AM43x-epos-evm "with" enable_qspi=1 in bootargs works fine
and qspi flash gets selected.
QSPI on AM43x-epos-evm "without" enable_qspi in bootargs prints a
message in the bootlog that "flash not recognised" as the flash does
not get selected.

This may not be the good solution, posting this to get some more feedbacks
on handling this out in a better way.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/spi-ti-qspi.c |   20 +++++++++++++++++++-
 1 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c
index b258a41..ffc9700 100644
--- a/drivers/spi/spi-ti-qspi.c
+++ b/drivers/spi/spi-ti-qspi.c
@@ -31,9 +31,14 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
-
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/spi/spi.h>
 
+static int enable_qspi;
+module_param(enable_qspi, int, 0);
+MODULE_PARM_DESC(enable_qspi, "enable qspi on AM437x board");
+
 struct ti_qspi_regs {
 	u32 clkctrl;
 };
@@ -515,6 +520,19 @@ static int ti_qspi_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	u32 max_freq;
 	int ret = 0, num_cs, irq;
+	int gpio;
+	enum of_gpio_flags flags;
+
+	if (enable_qspi) {
+		gpio = of_get_named_gpio_flags(np, "qspi-gpio", 0, &flags);
+		if (gpio_is_valid(gpio)) {
+			gpio_request(gpio, "qspi");
+			gpio_direction_output(gpio, flags);
+		} else {
+			dev_err(&pdev->dev, "GPIO not available to select qspi");
+			return 0;
+		}
+	}
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*qspi));
 	if (!master)
-- 
1.7.5.4

