From 03c0c9c4077009837e33da033aee7304d452151b Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 3 Nov 2011 17:46:24 +0800
Subject: [PATCH] CNS34xx:Fix ethtool_ops's get/set_settings routine to support VB board

There are 3 ethernet ports on CNS3420 VB board, port 0 & port 1
connects to a 5-ports switch via fixed link, port 2 connect to a
ICP IP1001 1000BaseT phy chip. Port 0 & Port 1 only support 1000 BaseT
with full-duplex mode, while Port 2 could support 10/100/1000 mode and
auto-negotiation feature.

The patch updates get_settings() routine of CNS34xx's NIC driver with
fixing support feature list, which is extracted from a routine
dedicated for CNS3420 VB board.

Besides, in set_setting() function, the patch adds checking and phy
chip setting routine for VB board.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/cns3xxx/cns3xxx_ethtool.c |   24 ++++--
 drivers/net/cns3xxx/pse_init_common.h |    5 +
 drivers/net/cns3xxx/vb.h              |  142 +++++++++++++++++++++++++++++++++
 3 files changed, 165 insertions(+), 6 deletions(-)

diff --git a/drivers/net/cns3xxx/cns3xxx_ethtool.c b/drivers/net/cns3xxx/cns3xxx_ethtool.c
index f48f4ad..9e8f613 100644
--- a/drivers/net/cns3xxx/cns3xxx_ethtool.c
+++ b/drivers/net/cns3xxx/cns3xxx_ethtool.c
@@ -29,6 +29,7 @@
 #include "cns3xxx_symbol.h"
 #include "cns3xxx.h"
 #include "cns3xxx_tool.h"
+#include "pse_init_common.h"
 
 static void cns3xxx_get_drvinfo(
 	struct net_device *netdev, struct ethtool_drvinfo *info)
@@ -216,12 +217,8 @@ static int cns3xxx_get_settings(
 		GET_MAC_PORT_CFG(
 			priv->net_device_priv->which_port,
 			mac_port_config)
-		ecmd->supported =
-			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
-			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
-			SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full |
-			SUPPORTED_Autoneg | SUPPORTED_TP |
-			SUPPORTED_MII | SUPPORTED_Pause);
+		cns3xxx_get_port_support(priv->net_device_priv->which_port,
+			ecmd);
 		ecmd->duplex =
 			((mac_port_config >> 4) & 0x1) ?
 			DUPLEX_FULL : DUPLEX_HALF;
@@ -300,17 +297,32 @@ static int cns3xxx_set_settings(
 
 	if (priv->net_device_priv->nic_setting == 0) {
 		/*connect to switch chip*/
+		if (cns3xxx_check_port_support(
+			priv->net_device_priv->which_port, ecmd) < 0)
+			return -EINVAL;
+
 		if (ecmd->autoneg == AUTONEG_ENABLE) {
 			printk(KERN_INFO "autoneg\n");
 			value = cns3xxx_set_spd_dplx(netdev, AUTONEG_ENABLE);
 			if (value != 0)
 				return -EINVAL;
+			value =
+				cns3xxx_set_phy_autoneg(
+					priv->net_device_priv->which_port);
+			if (value != 0)
+				return -EINVAL;
 		} else {
 			printk(KERN_INFO "no autoneg\n");
 			value = cns3xxx_set_spd_dplx(
 				netdev, ecmd->speed + ecmd->duplex);
 			if (value != 0)
 				return -EINVAL;
+			value =
+				cns3xxx_set_phy_forced(
+					priv->net_device_priv->which_port,
+					ecmd->speed, ecmd->duplex);
+			if (value != 0)
+				return -EINVAL;
 		}
 	}
 
diff --git a/drivers/net/cns3xxx/pse_init_common.h b/drivers/net/cns3xxx/pse_init_common.h
index ace7aca..64b315f 100644
--- a/drivers/net/cns3xxx/pse_init_common.h
+++ b/drivers/net/cns3xxx/pse_init_common.h
@@ -53,4 +53,9 @@ extern struct ARLTableEntry arl_table_entry[];
 extern struct NetDevicePriv net_device_prive[];
 extern int num_net_dev_priv;
 
+extern int cns3xxx_get_port_support(int port, struct ethtool_cmd *ecmd);
+extern int cns3xxx_check_port_support(int port, struct ethtool_cmd *ecmd);
+extern int cns3xxx_set_phy_autoneg(int port);
+extern int cns3xxx_set_phy_forced(int port, u16 speed, u16 duplex);
+
 #endif
diff --git a/drivers/net/cns3xxx/vb.h b/drivers/net/cns3xxx/vb.h
index 7cbe777..67deecf 100644
--- a/drivers/net/cns3xxx/vb.h
+++ b/drivers/net/cns3xxx/vb.h
@@ -28,6 +28,8 @@
 #define VB_H
 
 #include <linux/types.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
 
 #include "cns3xxx.h"
 #include "cns3xxx_phy.h"
@@ -433,5 +435,145 @@ EXPORT_SYMBOL_GPL(is_cns3xxx_port_base_mode);
 int num_net_dev_priv =
 	sizeof(net_device_prive) / sizeof(struct NetDevicePriv);
 
+int cns3xxx_get_port_support(int port, struct ethtool_cmd *ecmd)
+{
+	switch (port) {
+	case MAC_PORT0:
+	case MAC_PORT1:
+		/*Port 0 & 1 support 1000baseT
+		 * with Full duplex mode only
+		 */
+		ecmd->supported =
+			(SUPPORTED_1000baseT_Full |
+			SUPPORTED_TP | SUPPORTED_Pause);
+		break;
+	case MAC_PORT2:
+		/*Port 2 supports 10/100/1000 mode*/
+		ecmd->supported =
+		(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+		SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+		SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full |
+		SUPPORTED_Autoneg | SUPPORTED_TP |
+		SUPPORTED_MII | SUPPORTED_Pause);
+		break;
+	default:
+		return -ENODEV;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cns3xxx_get_port_support);
+
+int cns3xxx_check_port_support(int port, struct ethtool_cmd *ecmd)
+{
+	switch (port) {
+	case MAC_PORT0:
+	case MAC_PORT1:
+		/* Port 0 & 1 not support auto-negotiation*/
+		if (ecmd->autoneg == AUTONEG_ENABLE)
+			return -EINVAL;
+		/* Port 0 & 1 support 1000baseT
+		 * with Full duplex mode only
+		 */
+		if ((ecmd->speed == SPEED_1000) &&
+			(ecmd->duplex == DUPLEX_FULL))
+			return 0;
+		break;
+	case MAC_PORT2:
+		if (ecmd->autoneg == AUTONEG_ENABLE)
+			return 0;
+	/*Port 2 supports 10/100/1000 mode*/
+		switch (ecmd->speed) {
+		case SPEED_10:
+		case SPEED_100:
+		case SPEED_1000:
+			return 0;
+		}
+		break;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(cns3xxx_check_port_support);
+
+int cns3xxx_set_phy_forced(int port, u16 speed, u16 duplex)
+{
+	u16 ctl;
+	switch (port) {
+	case MAC_PORT0:
+	case MAC_PORT1:
+		return 0;
+	case MAC_PORT2:
+		if (cns3xxx_read_phy(2, MII_BMCR, &ctl) != CAVM_OK)
+			return -1;
+		ctl &= ~(BMCR_FULLDPLX | BMCR_SPEED100 |
+			BMCR_SPEED1000 | BMCR_ANENABLE);
+
+		/* First clear the PHY */
+		cns3xxx_write_phy(2, MII_BMCR, ctl | BMCR_RESET);
+
+		/* Select speed & duplex */
+		switch (speed) {
+		case SPEED_10:
+			break;
+		case SPEED_100:
+			ctl |= BMCR_SPEED100;
+			break;
+		case SPEED_1000:
+			ctl |= BMCR_SPEED1000;
+			break;
+		default:
+			return -EINVAL;
+		}
+		if (duplex == DUPLEX_FULL)
+			ctl |= BMCR_FULLDPLX;
+
+		cns3xxx_write_phy(2, MII_BMCR, ctl | BMCR_RESET);
+		return 0;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(cns3xxx_set_phy_forced);
+
+int cns3xxx_set_phy_autoneg(int port)
+{
+	u16 ctl, adv;
+	switch (port) {
+	case MAC_PORT0:
+	case MAC_PORT1:
+		return 0;
+	case MAC_PORT2:
+		if (cns3xxx_read_phy(2, MII_BMCR, &ctl) != CAVM_OK)
+			return -1;
+		ctl &= ~(BMCR_FULLDPLX | BMCR_SPEED100 |
+			BMCR_SPEED1000 | BMCR_ANENABLE);
+
+		/* First clear the PHY */
+		cns3xxx_write_phy(2, MII_BMCR, ctl | BMCR_RESET);
+
+		/* Setup standard advertise */
+		if (cns3xxx_read_phy(2, MII_ADVERTISE, &adv) != CAVM_OK)
+			return -1;
+		adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 |
+			ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+		adv |= (ADVERTISE_10HALF | ADVERTISE_10FULL |
+			ADVERTISE_100HALF | ADVERTISE_100FULL |
+			ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+		cns3xxx_write_phy(2, MII_ADVERTISE, adv);
+
+		if (cns3xxx_read_phy(2, MII_CTRL1000, &adv) != CAVM_OK)
+			return -1;
+		adv |= ADVERTISE_1000FULL | ADVERTISED_1000baseT_Half;
+		cns3xxx_write_phy(2, MII_CTRL1000, adv);
+
+		/* Start/Restart aneg */
+		if (cns3xxx_read_phy(2, MII_BMCR, &ctl) != CAVM_OK)
+			return -1;
+		ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
+		cns3xxx_write_phy(2, MII_BMCR, ctl);
+		return 0;
+	}
+}
+EXPORT_SYMBOL_GPL(cns3xxx_set_phy_autoneg);
+
+
 #endif /* CONFIG_CNS3XXX_GSW_VB*/
 #endif
-- 
1.7.0.4

