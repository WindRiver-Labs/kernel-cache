From 5dac2ea243f11ff0174fcad75e7a6948cd50a25b Mon Sep 17 00:00:00 2001
From: lwang1 <li.wang@windriver.com>
Date: Thu, 11 Sep 2008 16:21:54 +0800
Subject: [PATCH] fsl_hpcnet Support ASMP Mode

Add ASMP support for MPC8641HPCN

Signed-off-by: Wang Haiying <haiying.wang@freescale.com>
Signed-off-by: Zhang Wei <wei.zhang@freescale.com>
Signed-off-by: LiWang <li.wang@windriver.com>
diff --git a/arch/powerpc/include/asm/io.h b/arch/powerpc/include/asm/io.h
index 77c7fa0..a222472 100644
--- a/arch/powerpc/include/asm/io.h
+++ b/arch/powerpc/include/asm/io.h
@@ -27,6 +27,8 @@ extern int check_legacy_ioport(unsigned long base_port);
 #include <asm/synch.h>
 #include <asm/delay.h>
 #include <asm/mmu.h>
+#include <asm/reg.h>
+#include <asm/smp.h>
 
 #include <asm-generic/iomap.h>
 
@@ -46,11 +48,19 @@ extern int check_legacy_ioport(unsigned long base_port);
 #ifndef CONFIG_PCI
 #define _IO_BASE	0
 #define _ISA_MEM_BASE	0
+#ifdef CONFIG_ASMP
+#define PCI_DRAM_OFFSET (CONFIG_ASMP_MEMOFFSET * raw_asmp_processor_id())
+#else
 #define PCI_DRAM_OFFSET 0
+#endif
 #elif defined(CONFIG_PPC32)
 #define _IO_BASE	isa_io_base
 #define _ISA_MEM_BASE	isa_mem_base
+#ifdef CONFIG_ASMP
+#define PCI_DRAM_OFFSET (pci_dram_offset + CONFIG_ASMP_MEMOFFSET * raw_asmp_processor_id())
+#else
 #define PCI_DRAM_OFFSET	pci_dram_offset
+#endif
 #else
 #define _IO_BASE	pci_io_base
 #define _ISA_MEM_BASE	isa_mem_base
diff --git a/arch/powerpc/include/asm/smp.h b/arch/powerpc/include/asm/smp.h
index 4d28e1e..2250241 100644
--- a/arch/powerpc/include/asm/smp.h
+++ b/arch/powerpc/include/asm/smp.h
@@ -91,6 +91,10 @@ extern void __cpu_die(unsigned int cpu);
 
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_ASMP
+#define raw_asmp_processor_id()		(mfspr(SPRN_PIR))
+#endif
+
 #ifdef CONFIG_PPC64
 #define get_hard_smp_processor_id(CPU) (paca[(CPU)].hw_cpu_id)
 #define set_hard_smp_processor_id(CPU, VAL) \
diff --git a/arch/powerpc/platforms/86xx/pic.c b/arch/powerpc/platforms/86xx/pic.c
index 668275d..e7f33b2 100644
--- a/arch/powerpc/platforms/86xx/pic.c
+++ b/arch/powerpc/platforms/86xx/pic.c
@@ -42,11 +42,18 @@ void __init mpc86xx_init_irq(void)
 		return;
 	of_address_to_resource(np, 0, &res);
 
+#ifdef CONFIG_ASMP
+	mpic = mpic_alloc(np, res.start,
+			MPIC_PRIMARY |
+			MPIC_BIG_ENDIAN | MPIC_BROKEN_FRR_NIRQS,
+			0, 256, " MPIC     ");
+#else
 	mpic = mpic_alloc(np, res.start,
 			MPIC_PRIMARY | MPIC_WANTS_RESET |
 			MPIC_BIG_ENDIAN | MPIC_BROKEN_FRR_NIRQS |
 			MPIC_SINGLE_DEST_CPU,
 			0, 256, " MPIC     ");
+#endif
 	of_node_put(np);
 	BUG_ON(mpic == NULL);
 
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index 7f65127..cad460e 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -254,4 +254,20 @@ config NOT_COHERENT_CACHE
 config CHECK_CACHE_COHERENCY
 	bool
 
+config ASMP
+	bool "Asynchronous SMP support"
+	depends on MPC8641 && !SMP
+	default n
+	---help---
+	This enables support for system with more than one CPU and per CPU runs
+	an individual Linux kernel. This selection is mutually exclusive than
+	SMP. Note the ASMP kernel is only supporting MPC8641 processor now.
+
+	If you don't know what to do here, say N.
+
+config ASMP_MEMOFFSET
+	hex
+	depends on ASMP
+	default "0x10000000" if MPC8641
+
 endmenu
diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index 78d6d42..ebc76cf 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -974,8 +974,13 @@ void mpic_set_affinity(unsigned int irq, cpumask_t cpumask)
 
 		cpus_and(tmp, cpumask, cpu_online_map);
 
+#ifdef CONFIG_ASMP
+		mpic_irq_write(src, MPIC_INFO(IRQ_DESTINATION),
+			       1 << raw_asmp_processor_id());
+#else
 		mpic_irq_write(src, MPIC_INFO(IRQ_DESTINATION),
 			       mpic_physmask(cpus_addr(tmp)[0]));
+#endif
 	}
 }
 
@@ -1412,11 +1417,16 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 	}
 
 	/* Map the per-CPU registers */
+#ifdef CONFIG_ASMP
+	mpic_map(mpic, paddr, &mpic->cpuregs[0], MPIC_INFO(CPU_BASE) +
+		raw_asmp_processor_id() * MPIC_INFO(CPU_STRIDE), 0x1000);
+#else
 	for (i = 0; i < mpic->num_cpus; i++) {
 		mpic_map(mpic, paddr, &mpic->cpuregs[i],
 			 MPIC_INFO(CPU_BASE) + i * MPIC_INFO(CPU_STRIDE),
 			 0x1000);
 	}
+#endif
 
 	/* Initialize main ISU if none provided */
 	if (mpic->isu_size == 0) {
@@ -1482,16 +1492,31 @@ void __init mpic_init(struct mpic *mpic)
 {
 	int i;
 	int cpu;
+	u32 pir = 0;
+	u32 count = 1;
+#ifdef CONFIG_ASMP
+	u32 rirq, intsize, intlen, vecpri;
+	struct device_node *np;
+	const u32 *intspec, *tmp;
+#endif
 
 	BUG_ON(mpic->num_sources == 0);
 
 	printk(KERN_INFO "mpic: Initializing for %d sources\n", mpic->num_sources);
 
+#ifdef CONFIG_ASMP
+	/* On AMP, we use timer0,timer2 for core0;timer1,timer3 for core1 */
+	pir = raw_asmp_processor_id();
+	count = 2;
+#endif
 	/* Set current processor priority to max */
 	mpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0xf);
 
 	/* Initialize timers: just disable them all */
 	for (i = 0; i < 4; i++) {
+		/* skip other core */
+		if ((i % count )!= pir )
+			continue;
 		mpic_write(mpic->tmregs,
 			   i * MPIC_INFO(TIMER_STRIDE) +
 			   MPIC_INFO(TIMER_DESTINATION), 0);
@@ -1529,6 +1554,25 @@ void __init mpic_init(struct mpic *mpic)
 	else
 		cpu = 0;
 
+#ifdef CONFIG_ASMP
+	/* get current core id */
+	pir = raw_asmp_processor_id();
+
+	/* get interrupts which are  assigned to this core */
+	np = of_find_node_by_type(NULL, "open-pic");
+	intspec = of_get_property(np, "assigned_irqs", &intlen);
+	intlen /= sizeof(u32);
+	tmp = of_get_property(np, "#interrupt-cells", NULL);
+	intsize = *tmp;
+	for (i = 0; i < (intlen / 2); i++) {
+		rirq = intspec[i * intsize];
+		vecpri = MPIC_VECPRI_MASK | rirq |
+			(8 << MPIC_VECPRI_PRIORITY_SHIFT);
+		mpic_irq_write(rirq, MPIC_INFO(IRQ_VECTOR_PRI), vecpri);
+		mpic_irq_write(rirq, MPIC_INFO(IRQ_DESTINATION),
+			1 << pir);
+	}
+#else
 	for (i = 0; i < mpic->num_sources; i++) {
 		/* start with vector = source number, and masked */
 		u32 vecpri = MPIC_VECPRI_MASK | i |
@@ -1541,6 +1585,7 @@ void __init mpic_init(struct mpic *mpic)
 		mpic_irq_write(i, MPIC_INFO(IRQ_VECTOR_PRI), vecpri);
 		mpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION), 1 << cpu);
 	}
+#endif
 	
 	/* Init spurious vector */
 	mpic_write(mpic->gregs, MPIC_INFO(GREG_SPURIOUS), mpic->spurious_vec);
