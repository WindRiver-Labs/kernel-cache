From ceb50e2c3ccac155ccaa67c52f08b5cffe1a2699 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 6 Jul 2012 02:09:11 +0000
Subject: [PATCH 2/7] qman: set stash request queue to match the cpu affinity

Up until recently, the mapping of portals to stash request queues (and
the configuration of each stashing LIODN to target the desired cpu) was
being configured in u-boot using hard-coded constants. The device-tree
contained the same constants, and that's what linux was using to
determine which portals were used on which cpus.

Dynamic allocation of portals and dynamic assignment (and later,
reassignment) of cpu affinity has changed that, and the stash request
flow control feature was broken. The kernel needs to try to set the
portal's stash request queue at the moment it is configuring the portal
for cpu-affine use (ie. as it is allocated), and this is what this change
does. However this will fail with a warning if the kernel does not have
access to the QMan control registers.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2.1-20120824-yocto.tar.gz tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c  |   14 +++++++++++++
 drivers/staging/fsl_qbman/qman_driver.c  |   32 +++++++++++++++++++----------
 drivers/staging/fsl_qbman/qman_private.h |    1 +
 3 files changed, 36 insertions(+), 11 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index c8b2be1..5aaaee7 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -800,6 +800,20 @@ void qman_liodn_fixup(enum qm_channel channel)
 	qm_out(QCSP_PID_CFG(idx), after);
 }
 
+#define IO_CFG_SDEST_MASK 0x00ff0000
+int qman_set_sdest(enum qm_channel channel, unsigned int cpu_idx)
+{
+	int idx = channel - qm_channel_swportal0;
+	u32 before, after;
+
+	if (!qman_have_ccsr())
+		return -ENODEV;
+	before = qm_in(QCSP_IO_CFG(idx));
+	after = (before & (~IO_CFG_SDEST_MASK)) | (cpu_idx << 16);
+	qm_out(QCSP_IO_CFG(idx), after);
+	return 0;
+}
+
 #ifdef CONFIG_SYSFS
 
 #define DRV_NAME	"fsl-qman"
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index d88a0e4..d96e61e 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -256,7 +256,7 @@ static struct qm_portal_config *get_pcfg(struct list_head *list)
 }
 
 #ifdef CONFIG_FSL_PAMU
-static void set_liodns(const struct qm_portal_config *pcfg, int cpu)
+static void portal_set_liodns(const struct qm_portal_config *pcfg, int cpu)
 {
 	unsigned int index = 0;
 	unsigned int liodn_cnt = pamu_get_liodn_count(pcfg->node);
@@ -267,9 +267,18 @@ static void set_liodns(const struct qm_portal_config *pcfg, int cpu)
 	}
 }
 #else
-#define set_liodns(pcfg, cpu) do { } while (0)
+#define portal_set_liodns(pcfg, cpu) do { } while (0)
 #endif
 
+static void portal_set_cpu(const struct qm_portal_config *pcfg, int cpu)
+{
+	portal_set_liodns(pcfg, cpu);
+#ifdef CONFIG_FSL_QMAN_CONFIG
+	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
+#endif
+		pr_warning("Failed to set QMan portal's stash request queue\n");
+}
+
 /* UIO handling callbacks */
 #define QMAN_UIO_PREAMBLE() \
 	const struct qm_portal_config *pcfg = \
@@ -309,14 +318,15 @@ static void qman_uio_cb_destroy(const struct list_head *__p,
 static int qman_uio_cb_open(const struct list_head *__p)
 {
 	QMAN_UIO_PREAMBLE();
-	/* Bind stashing LIODNs to the CPU we are currently executing on. The
-	 * user-space driver assumption is that the pthread has to already be
-	 * affine to one cpu only before opening a portal. If that check is
-	 * circumvented, the only risk is a performance degradation - stashing
-	 * will go to whatever cpu they happened to be running on when opening
-	 * the device file, and if that isn't the cpu they subsequently bind to
-	 * and do their polling on, tough. */
-	set_liodns(pcfg, hard_smp_processor_id());
+	/* Bind stashing LIODNs to the CPU we are currently executing on, and
+	 * set the portal to use the stashing request queue corresonding to the
+	 * cpu as well. The user-space driver assumption is that the pthread has
+	 * to already be affine to one cpu only before opening a portal. If that
+	 * check is circumvented, the only risk is a performance degradation -
+	 * stashing will go to whatever cpu they happened to be running on when
+	 * opening the device file, and if that isn't the cpu they subsequently
+	 * bind to and do their polling on, tough. */
+	portal_set_cpu(pcfg, hard_smp_processor_id());
 	return 0;
 }
 static void qman_uio_cb_interrupt(const struct list_head *__p)
@@ -342,7 +352,7 @@ static struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)
 	struct qman_portal *p;
 	struct cpumask oldmask = *tsk_cpus_allowed(current);
 
-	set_liodns(pcfg, pcfg->public_cfg.cpu);
+	portal_set_cpu(pcfg, pcfg->public_cfg.cpu);
 	set_cpus_allowed_ptr(current, get_cpu_mask(pcfg->public_cfg.cpu));
 	p = qman_create_affine_portal(pcfg, NULL);
 	if (p) {
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 5ca90e8..915b2c0 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -133,6 +133,7 @@ extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
 /* Hooks from qman_driver.c to qman_config.c */
 int qman_init_ccsr(struct device_node *node);
 void qman_liodn_fixup(enum qm_channel channel);
+int qman_set_sdest(enum qm_channel channel, unsigned int cpu_idx);
 #endif
 
 /* Hooks from qman_driver.c in to qman_high.c */
-- 
1.7.0.5

