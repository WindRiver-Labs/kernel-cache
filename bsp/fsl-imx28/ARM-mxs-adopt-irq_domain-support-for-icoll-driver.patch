From ce01d679a9483b3e8112297bc6b4beeb35d63029 Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@linaro.org>
Date: Thu, 17 Jan 2013 16:24:53 +0800
Subject: [PATCH 116/169] ARM: mxs: adopt irq_domain support for icoll driver

Upstream ID: 83a84efcefe8d7935883ab9d8e45c689d5760ddf

Remove irq_domain_add_legacy call from mach-mxs.c and have icoll adopt
irq_domain support in the driver.

Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mxs/icoll.c    |   45 ++++++++++++++++++++++++++++++++++-------
 arch/arm/mach-mxs/mach-mxs.c |   25 +---------------------
 2 files changed, 39 insertions(+), 31 deletions(-)

diff --git a/arch/arm/mach-mxs/icoll.c b/arch/arm/mach-mxs/icoll.c
index a11b618..8fb23af 100644
--- a/arch/arm/mach-mxs/icoll.c
+++ b/arch/arm/mach-mxs/icoll.c
@@ -19,7 +19,10 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
 #include <asm/exception.h>
 #include <mach/mxs.h>
 #include <mach/common.h>
@@ -33,7 +36,10 @@
 #define BM_ICOLL_INTERRUPTn_ENABLE		0x00000004
 #define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0	0x1
 
+#define ICOLL_NUM_IRQS		128
+
 static void __iomem *icoll_base = MXS_IO_ADDRESS(MXS_ICOLL_BASE_ADDR);
+static struct irq_domain *icoll_domain;
 
 static void icoll_ack_irq(struct irq_data *d)
 {
@@ -49,13 +55,13 @@ static void icoll_ack_irq(struct irq_data *d)
 static void icoll_mask_irq(struct irq_data *d)
 {
 	__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,
-			icoll_base + HW_ICOLL_INTERRUPTn_CLR(d->irq));
+			icoll_base + HW_ICOLL_INTERRUPTn_CLR(d->hwirq));
 }
 
 static void icoll_unmask_irq(struct irq_data *d)
 {
 	__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,
-			icoll_base + HW_ICOLL_INTERRUPTn_SET(d->irq));
+			icoll_base + HW_ICOLL_INTERRUPTn_SET(d->hwirq));
 }
 
 static struct irq_chip mxs_icoll_chip = {
@@ -72,6 +78,7 @@ asmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)
 		irqnr = __raw_readl(icoll_base + HW_ICOLL_STAT_OFFSET);
 		if (irqnr != 0x7f) {
 			__raw_writel(irqnr, icoll_base + HW_ICOLL_VECTOR);
+			irqnr = irq_find_mapping(icoll_domain, irqnr);
 			handle_IRQ(irqnr, regs);
 			continue;
 		}
@@ -79,18 +86,40 @@ asmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)
 	} while (1);
 }
 
-void __init icoll_init_irq(void)
+static int icoll_irq_domain_map(struct irq_domain *d, unsigned int virq,
+				irq_hw_number_t hw)
 {
-	int i;
+	irq_set_chip_and_handler(virq, &mxs_icoll_chip, handle_level_irq);
+	set_irq_flags(virq, IRQF_VALID);
+
+	return 0;
+}
 
+static struct irq_domain_ops icoll_irq_domain_ops = {
+	.map = icoll_irq_domain_map,
+	.xlate = irq_domain_xlate_onecell,
+};
+
+void __init icoll_of_init(struct device_node *np,
+			  struct device_node *interrupt_parent)
+{
 	/*
 	 * Interrupt Collector reset, which initializes the priority
 	 * for each irq to level 0.
 	 */
 	mxs_reset_block(icoll_base + HW_ICOLL_CTRL);
 
-	for (i = 0; i < MXS_INTERNAL_IRQS; i++) {
-		irq_set_chip_and_handler(i, &mxs_icoll_chip, handle_level_irq);
-		set_irq_flags(i, IRQF_VALID);
-	}
+	icoll_domain = irq_domain_add_linear(np, ICOLL_NUM_IRQS,
+					     &icoll_irq_domain_ops, NULL);
+	WARN_ON(!icoll_domain);
+}
+
+static const struct of_device_id icoll_of_match[] __initconst = {
+	{.compatible = "fsl,icoll", .data = icoll_of_init},
+	{ /* sentinel */ }
+};
+
+void __init icoll_init_irq(void)
+{
+	of_irq_init(icoll_of_match);
 }
diff --git a/arch/arm/mach-mxs/mach-mxs.c b/arch/arm/mach-mxs/mach-mxs.c
index 75a4688..a074a87 100644
--- a/arch/arm/mach-mxs/mach-mxs.c
+++ b/arch/arm/mach-mxs/mach-mxs.c
@@ -17,9 +17,7 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
-#include <linux/irqdomain.h>
 #include <linux/mxsfb.h>
-#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/phy.h>
 #include <linux/pinctrl/consumer.h>
@@ -121,25 +119,6 @@ static struct of_dev_auxdata mxs_auxdata_lookup[] __initdata = {
 	{ /* sentinel */ }
 };
 
-static int __init mxs_icoll_add_irq_domain(struct device_node *np,
-				struct device_node *interrupt_parent)
-{
-	irq_domain_add_legacy(np, 128, 0, 0, &irq_domain_simple_ops, NULL);
-
-	return 0;
-}
-
-static const struct of_device_id mxs_irq_match[] __initconst = {
-	{ .compatible = "fsl,mxs-icoll", .data = mxs_icoll_add_irq_domain, },
-	{ /* sentinel */ }
-};
-
-static void __init mxs_dt_init_irq(void)
-{
-	icoll_init_irq();
-	of_irq_init(mxs_irq_match);
-}
-
 static void __init imx23_timer_init(void)
 {
 	mx23_clocks_init();
@@ -373,7 +352,7 @@ static const char *imx28_dt_compat[] __initdata = {
 
 DT_MACHINE_START(IMX23, "Freescale i.MX23 (Device Tree)")
 	.map_io		= mx23_map_io,
-	.init_irq	= mxs_dt_init_irq,
+	.init_irq	= icoll_init_irq,
 	.handle_irq	= icoll_handle_irq,
 	.timer		= &imx23_timer,
 	.init_machine	= mxs_machine_init,
@@ -383,7 +362,7 @@ MACHINE_END
 
 DT_MACHINE_START(IMX28, "Freescale i.MX28 (Device Tree)")
 	.map_io		= mx28_map_io,
-	.init_irq	= mxs_dt_init_irq,
+	.init_irq	= icoll_init_irq,
 	.handle_irq	= icoll_handle_irq,
 	.timer		= &imx28_timer,
 	.init_machine	= mxs_machine_init,
-- 
1.7.0

