From 7d1d441f4b992a50e156425d10db82e3b8d98281 Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@linaro.org>
Date: Sun, 29 Apr 2012 00:02:40 +0800
Subject: [PATCH 009/169] ARM: mxs: remove old clock support

The mxs clock has been switched to common clock framework, so the old
clock support can be removed now.

Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
(cherry picked from commit 5da301a2056529cc5366f21d4325b96052d9cad1)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mxs/clock-mx23.c          |  536 ---------------------
 arch/arm/mach-mxs/clock-mx28.c          |  803 -------------------------------
 arch/arm/mach-mxs/clock.c               |  211 --------
 arch/arm/mach-mxs/include/mach/clock.h  |   62 ---
 arch/arm/mach-mxs/include/mach/common.h |    2 -
 arch/arm/mach-mxs/regs-clkctrl-mx23.h   |  331 -------------
 arch/arm/mach-mxs/regs-clkctrl-mx28.h   |  486 -------------------
 arch/arm/mach-mxs/system.c              |   16 -
 8 files changed, 0 insertions(+), 2447 deletions(-)
 delete mode 100644 arch/arm/mach-mxs/clock-mx23.c
 delete mode 100644 arch/arm/mach-mxs/clock-mx28.c
 delete mode 100644 arch/arm/mach-mxs/clock.c
 delete mode 100644 arch/arm/mach-mxs/include/mach/clock.h
 delete mode 100644 arch/arm/mach-mxs/regs-clkctrl-mx23.h
 delete mode 100644 arch/arm/mach-mxs/regs-clkctrl-mx28.h

diff --git a/arch/arm/mach-mxs/clock-mx23.c b/arch/arm/mach-mxs/clock-mx23.c
deleted file mode 100644
index e3ac52c..0000000
--- a/arch/arm/mach-mxs/clock-mx23.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/jiffies.h>
-#include <linux/clkdev.h>
-
-#include <asm/clkdev.h>
-#include <asm/div64.h>
-
-#include <mach/mx23.h>
-#include <mach/common.h>
-#include <mach/clock.h>
-
-#include "regs-clkctrl-mx23.h"
-
-#define CLKCTRL_BASE_ADDR	MX23_IO_ADDRESS(MX23_CLKCTRL_BASE_ADDR)
-#define DIGCTRL_BASE_ADDR	MX23_IO_ADDRESS(MX23_DIGCTL_BASE_ADDR)
-
-#define PARENT_RATE_SHIFT	8
-
-static int _raw_clk_enable(struct clk *clk)
-{
-	u32 reg;
-
-	if (clk->enable_reg) {
-		reg = __raw_readl(clk->enable_reg);
-		reg &= ~(1 << clk->enable_shift);
-		__raw_writel(reg, clk->enable_reg);
-	}
-
-	return 0;
-}
-
-static void _raw_clk_disable(struct clk *clk)
-{
-	u32 reg;
-
-	if (clk->enable_reg) {
-		reg = __raw_readl(clk->enable_reg);
-		reg |= 1 << clk->enable_shift;
-		__raw_writel(reg, clk->enable_reg);
-	}
-}
-
-/*
- * ref_xtal_clk
- */
-static unsigned long ref_xtal_clk_get_rate(struct clk *clk)
-{
-	return 24000000;
-}
-
-static struct clk ref_xtal_clk = {
-	.get_rate = ref_xtal_clk_get_rate,
-};
-
-/*
- * pll_clk
- */
-static unsigned long pll_clk_get_rate(struct clk *clk)
-{
-	return 480000000;
-}
-
-static int pll_clk_enable(struct clk *clk)
-{
-	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |
-			BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_SET);
-
-	/* Only a 10us delay is need. PLLCTRL1 LOCK bitfied is only a timer
-	 * and is incorrect (excessive). Per definition of the PLLCTRL0
-	 * POWER field, waiting at least 10us.
-	 */
-	udelay(10);
-
-	return 0;
-}
-
-static void pll_clk_disable(struct clk *clk)
-{
-	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |
-			BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_CLR);
-}
-
-static struct clk pll_clk = {
-	 .get_rate = pll_clk_get_rate,
-	 .enable = pll_clk_enable,
-	 .disable = pll_clk_disable,
-	 .parent = &ref_xtal_clk,
-};
-
-/*
- * ref_clk
- */
-#define _CLK_GET_RATE_REF(name, sr, ss)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	unsigned long parent_rate;					\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##sr);		\
-	div = (reg >> BP_CLKCTRL_##sr##_##ss##FRAC) & 0x3f;		\
-	parent_rate = clk_get_rate(clk->parent);			\
-									\
-	return SH_DIV((parent_rate >> PARENT_RATE_SHIFT) * 18,		\
-			div, PARENT_RATE_SHIFT);			\
-}
-
-_CLK_GET_RATE_REF(ref_cpu_clk, FRAC, CPU)
-_CLK_GET_RATE_REF(ref_emi_clk, FRAC, EMI)
-_CLK_GET_RATE_REF(ref_pix_clk, FRAC, PIX)
-_CLK_GET_RATE_REF(ref_io_clk, FRAC, IO)
-
-#define _DEFINE_CLOCK_REF(name, er, es)					\
-	static struct clk name = {					\
-		.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_##er,	\
-		.enable_shift	= BP_CLKCTRL_##er##_CLKGATE##es,	\
-		.get_rate	= name##_get_rate,			\
-		.enable		= _raw_clk_enable,			\
-		.disable	= _raw_clk_disable,			\
-		.parent		= &pll_clk,				\
-	}
-
-_DEFINE_CLOCK_REF(ref_cpu_clk, FRAC, CPU);
-_DEFINE_CLOCK_REF(ref_emi_clk, FRAC, EMI);
-_DEFINE_CLOCK_REF(ref_pix_clk, FRAC, PIX);
-_DEFINE_CLOCK_REF(ref_io_clk, FRAC, IO);
-
-/*
- * General clocks
- *
- * clk_get_rate
- */
-static unsigned long rtc_clk_get_rate(struct clk *clk)
-{
-	/* ref_xtal_clk is implemented as the only parent */
-	return clk_get_rate(clk->parent) / 768;
-}
-
-static unsigned long clk32k_clk_get_rate(struct clk *clk)
-{
-	return clk->parent->get_rate(clk->parent) / 750;
-}
-
-#define _CLK_GET_RATE(name, rs)						\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-									\
-	if (clk->parent == &ref_xtal_clk)				\
-		div = (reg & BM_CLKCTRL_##rs##_DIV_XTAL) >>		\
-			BP_CLKCTRL_##rs##_DIV_XTAL;			\
-	else								\
-		div = (reg & BM_CLKCTRL_##rs##_DIV_##rs) >>		\
-			BP_CLKCTRL_##rs##_DIV_##rs;			\
-									\
-	if (!div)							\
-		return -EINVAL;						\
-									\
-	return clk_get_rate(clk->parent) / div;				\
-}
-
-_CLK_GET_RATE(cpu_clk, CPU)
-_CLK_GET_RATE(emi_clk, EMI)
-
-#define _CLK_GET_RATE1(name, rs)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-	div = (reg & BM_CLKCTRL_##rs##_DIV) >> BP_CLKCTRL_##rs##_DIV;	\
-									\
-	if (!div)							\
-		return -EINVAL;						\
-									\
-	return clk_get_rate(clk->parent) / div;				\
-}
-
-_CLK_GET_RATE1(hbus_clk, HBUS)
-_CLK_GET_RATE1(xbus_clk, XBUS)
-_CLK_GET_RATE1(ssp_clk, SSP)
-_CLK_GET_RATE1(gpmi_clk, GPMI)
-_CLK_GET_RATE1(lcdif_clk, PIX)
-
-#define _CLK_GET_RATE_STUB(name)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	return clk_get_rate(clk->parent);				\
-}
-
-_CLK_GET_RATE_STUB(uart_clk)
-_CLK_GET_RATE_STUB(audio_clk)
-_CLK_GET_RATE_STUB(pwm_clk)
-
-/*
- * clk_set_rate
- */
-static int cpu_clk_set_rate(struct clk *clk, unsigned long rate)
-{
-	u32 reg, bm_busy, div_max, d, f, div, frac;
-	unsigned long diff, parent_rate, calc_rate;
-
-	parent_rate = clk_get_rate(clk->parent);
-
-	if (clk->parent == &ref_xtal_clk) {
-		div_max = BM_CLKCTRL_CPU_DIV_XTAL >> BP_CLKCTRL_CPU_DIV_XTAL;
-		bm_busy = BM_CLKCTRL_CPU_BUSY_REF_XTAL;
-		div = DIV_ROUND_UP(parent_rate, rate);
-		if (div == 0 || div > div_max)
-			return -EINVAL;
-	} else {
-		div_max = BM_CLKCTRL_CPU_DIV_CPU >> BP_CLKCTRL_CPU_DIV_CPU;
-		bm_busy = BM_CLKCTRL_CPU_BUSY_REF_CPU;
-		rate >>= PARENT_RATE_SHIFT;
-		parent_rate >>= PARENT_RATE_SHIFT;
-		diff = parent_rate;
-		div = frac = 1;
-		for (d = 1; d <= div_max; d++) {
-			f = parent_rate * 18 / d / rate;
-			if ((parent_rate * 18 / d) % rate)
-				f++;
-			if (f < 18 || f > 35)
-				continue;
-
-			calc_rate = parent_rate * 18 / f / d;
-			if (calc_rate > rate)
-				continue;
-
-			if (rate - calc_rate < diff) {
-				frac = f;
-				div = d;
-				diff = rate - calc_rate;
-			}
-
-			if (diff == 0)
-				break;
-		}
-
-		if (diff == parent_rate)
-			return -EINVAL;
-
-		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
-		reg &= ~BM_CLKCTRL_FRAC_CPUFRAC;
-		reg |= frac;
-		__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
-	}
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
-	reg &= ~BM_CLKCTRL_CPU_DIV_CPU;
-	reg |= div << BP_CLKCTRL_CPU_DIV_CPU;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
-
-	mxs_clkctrl_timeout(HW_CLKCTRL_CPU, bm_busy);
-
-	return 0;
-}
-
-#define _CLK_SET_RATE(name, dr)						\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	u32 reg, div_max, div;						\
-	unsigned long parent_rate;					\
-									\
-	parent_rate = clk_get_rate(clk->parent);			\
-	div_max = BM_CLKCTRL_##dr##_DIV >> BP_CLKCTRL_##dr##_DIV;	\
-									\
-	div = DIV_ROUND_UP(parent_rate, rate);				\
-	if (div == 0 || div > div_max)					\
-		return -EINVAL;						\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-	reg &= ~BM_CLKCTRL_##dr##_DIV;					\
-	reg |= div << BP_CLKCTRL_##dr##_DIV;				\
-	if (reg & (1 << clk->enable_shift)) {				\
-		pr_err("%s: clock is gated\n", __func__);		\
-		return -EINVAL;						\
-	}								\
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-									\
-	mxs_clkctrl_timeout(HW_CLKCTRL_##dr, BM_CLKCTRL_##dr##_BUSY);	\
-	return 0;							\
-}
-
-_CLK_SET_RATE(xbus_clk, XBUS)
-_CLK_SET_RATE(ssp_clk, SSP)
-_CLK_SET_RATE(gpmi_clk, GPMI)
-_CLK_SET_RATE(lcdif_clk, PIX)
-
-#define _CLK_SET_RATE_STUB(name)					\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	return -EINVAL;							\
-}
-
-_CLK_SET_RATE_STUB(emi_clk)
-_CLK_SET_RATE_STUB(uart_clk)
-_CLK_SET_RATE_STUB(audio_clk)
-_CLK_SET_RATE_STUB(pwm_clk)
-_CLK_SET_RATE_STUB(clk32k_clk)
-
-/*
- * clk_set_parent
- */
-#define _CLK_SET_PARENT(name, bit)					\
-static int name##_set_parent(struct clk *clk, struct clk *parent)	\
-{									\
-	if (parent != clk->parent) {					\
-		__raw_writel(BM_CLKCTRL_CLKSEQ_BYPASS_##bit,		\
-			 CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ_TOG);	\
-		clk->parent = parent;					\
-	}								\
-									\
-	return 0;							\
-}
-
-_CLK_SET_PARENT(cpu_clk, CPU)
-_CLK_SET_PARENT(emi_clk, EMI)
-_CLK_SET_PARENT(ssp_clk, SSP)
-_CLK_SET_PARENT(gpmi_clk, GPMI)
-_CLK_SET_PARENT(lcdif_clk, PIX)
-
-#define _CLK_SET_PARENT_STUB(name)					\
-static int name##_set_parent(struct clk *clk, struct clk *parent)	\
-{									\
-	if (parent != clk->parent)					\
-		return -EINVAL;						\
-	else								\
-		return 0;						\
-}
-
-_CLK_SET_PARENT_STUB(uart_clk)
-_CLK_SET_PARENT_STUB(audio_clk)
-_CLK_SET_PARENT_STUB(pwm_clk)
-_CLK_SET_PARENT_STUB(clk32k_clk)
-
-/*
- * clk definition
- */
-static struct clk cpu_clk = {
-	.get_rate = cpu_clk_get_rate,
-	.set_rate = cpu_clk_set_rate,
-	.set_parent = cpu_clk_set_parent,
-	.parent = &ref_cpu_clk,
-};
-
-static struct clk hbus_clk = {
-	.get_rate = hbus_clk_get_rate,
-	.parent = &cpu_clk,
-};
-
-static struct clk xbus_clk = {
-	.get_rate = xbus_clk_get_rate,
-	.set_rate = xbus_clk_set_rate,
-	.parent = &ref_xtal_clk,
-};
-
-static struct clk rtc_clk = {
-	.get_rate = rtc_clk_get_rate,
-	.parent = &ref_xtal_clk,
-};
-
-/* usb_clk gate is controlled in DIGCTRL other than CLKCTRL */
-static struct clk usb_clk = {
-	.enable_reg = DIGCTRL_BASE_ADDR,
-	.enable_shift = 2,
-	.enable = _raw_clk_enable,
-	.disable = _raw_clk_disable,
-	.parent = &pll_clk,
-};
-
-#define _DEFINE_CLOCK(name, er, es, p)					\
-	static struct clk name = {					\
-		.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_##er,	\
-		.enable_shift	= BP_CLKCTRL_##er##_##es,		\
-		.get_rate	= name##_get_rate,			\
-		.set_rate	= name##_set_rate,			\
-		.set_parent	= name##_set_parent,			\
-		.enable		= _raw_clk_enable,			\
-		.disable	= _raw_clk_disable,			\
-		.parent		= p,					\
-	}
-
-_DEFINE_CLOCK(emi_clk, EMI, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(ssp_clk, SSP, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(gpmi_clk, GPMI, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(lcdif_clk, PIX, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(uart_clk, XTAL, UART_CLK_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(audio_clk, XTAL, FILT_CLK24M_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(pwm_clk, XTAL, PWM_CLK24M_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(clk32k_clk, XTAL, TIMROT_CLK32K_GATE, &ref_xtal_clk);
-
-#define _REGISTER_CLOCK(d, n, c) \
-	{ \
-		.dev_id = d, \
-		.con_id = n, \
-		.clk = &c, \
-	},
-
-static struct clk_lookup lookups[] = {
-	/* for amba bus driver */
-	_REGISTER_CLOCK("duart", "apb_pclk", xbus_clk)
-	/* for amba-pl011 driver */
-	_REGISTER_CLOCK("duart", NULL, uart_clk)
-	_REGISTER_CLOCK("mxs-auart.0", NULL, uart_clk)
-	_REGISTER_CLOCK("rtc", NULL, rtc_clk)
-	_REGISTER_CLOCK("mxs-dma-apbh", NULL, hbus_clk)
-	_REGISTER_CLOCK("mxs-dma-apbx", NULL, xbus_clk)
-	_REGISTER_CLOCK("mxs-mmc.0", NULL, ssp_clk)
-	_REGISTER_CLOCK("mxs-mmc.1", NULL, ssp_clk)
-	_REGISTER_CLOCK(NULL, "usb", usb_clk)
-	_REGISTER_CLOCK(NULL, "audio", audio_clk)
-	_REGISTER_CLOCK("mxs-pwm.0", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.1", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.2", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.3", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.4", NULL, pwm_clk)
-	_REGISTER_CLOCK("imx23-fb", NULL, lcdif_clk)
-	_REGISTER_CLOCK("imx23-gpmi-nand", NULL, gpmi_clk)
-};
-
-static int clk_misc_init(void)
-{
-	u32 reg;
-	int ret;
-
-	/* Fix up parent per register setting */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
-	cpu_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU) ?
-			&ref_xtal_clk : &ref_cpu_clk;
-	emi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI) ?
-			&ref_xtal_clk : &ref_emi_clk;
-	ssp_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP) ?
-			&ref_xtal_clk : &ref_io_clk;
-	gpmi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI) ?
-			&ref_xtal_clk : &ref_io_clk;
-	lcdif_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_PIX) ?
-			&ref_xtal_clk : &ref_pix_clk;
-
-	/* Use int div over frac when both are available */
-	__raw_writel(BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);
-	__raw_writel(BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);
-	__raw_writel(BM_CLKCTRL_HBUS_DIV_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
-	reg &= ~BM_CLKCTRL_XBUS_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP);
-	reg &= ~BM_CLKCTRL_SSP_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
-	reg &= ~BM_CLKCTRL_GPMI_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX);
-	reg &= ~BM_CLKCTRL_PIX_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX);
-
-	/*
-	 * Set safe hbus clock divider. A divider of 3 ensure that
-	 * the Vddd voltage required for the cpu clock is sufficiently
-	 * high for the hbus clock.
-	 */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
-	reg &= BM_CLKCTRL_HBUS_DIV;
-	reg |= 3 << BP_CLKCTRL_HBUS_DIV;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
-
-	ret = mxs_clkctrl_timeout(HW_CLKCTRL_HBUS, BM_CLKCTRL_HBUS_BUSY);
-
-	/* Gate off cpu clock in WFI for power saving */
-	__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_SET);
-
-	/*
-	 * 480 MHz seems too high to be ssp clock source directly,
-	 * so set frac to get a 288 MHz ref_io.
-	 */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
-	reg &= ~BM_CLKCTRL_FRAC_IOFRAC;
-	reg |= 30 << BP_CLKCTRL_FRAC_IOFRAC;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
-
-	return ret;
-}
-
-int __init mx23_clocks_init(void)
-{
-	clk_misc_init();
-
-	/*
-	 * source ssp clock from ref_io than ref_xtal,
-	 * as ref_xtal only provides 24 MHz as maximum.
-	 */
-	clk_set_parent(&ssp_clk, &ref_io_clk);
-
-	clk_prepare_enable(&cpu_clk);
-	clk_prepare_enable(&hbus_clk);
-	clk_prepare_enable(&xbus_clk);
-	clk_prepare_enable(&emi_clk);
-	clk_prepare_enable(&uart_clk);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	mxs_timer_init(&clk32k_clk, MX23_INT_TIMER0);
-
-	return 0;
-}
diff --git a/arch/arm/mach-mxs/clock-mx28.c b/arch/arm/mach-mxs/clock-mx28.c
deleted file mode 100644
index 5a832ad..0000000
--- a/arch/arm/mach-mxs/clock-mx28.c
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/jiffies.h>
-#include <linux/clkdev.h>
-#include <linux/spinlock.h>
-
-#include <asm/clkdev.h>
-#include <asm/div64.h>
-
-#include <mach/mx28.h>
-#include <mach/common.h>
-#include <mach/clock.h>
-#include <mach/digctl.h>
-
-#include "regs-clkctrl-mx28.h"
-
-#define CLKCTRL_BASE_ADDR	MX28_IO_ADDRESS(MX28_CLKCTRL_BASE_ADDR)
-#define DIGCTRL_BASE_ADDR	MX28_IO_ADDRESS(MX28_DIGCTL_BASE_ADDR)
-
-#define PARENT_RATE_SHIFT	8
-
-static struct clk pll2_clk;
-static struct clk cpu_clk;
-static struct clk emi_clk;
-static struct clk saif0_clk;
-static struct clk saif1_clk;
-static struct clk clk32k_clk;
-static DEFINE_SPINLOCK(clkmux_lock);
-
-/*
- * HW_SAIF_CLKMUX_SEL:
- *  DIRECT(0x0): SAIF0 clock pins selected for SAIF0 input clocks, and SAIF1
- *		clock pins selected for SAIF1 input clocks.
- *  CROSSINPUT(0x1): SAIF1 clock inputs selected for SAIF0 input clocks, and
- *		SAIF0 clock inputs selected for SAIF1 input clocks.
- *  EXTMSTR0(0x2): SAIF0 clock pin selected for both SAIF0 and SAIF1 input
- *		clocks.
- *  EXTMSTR1(0x3): SAIF1 clock pin selected for both SAIF0 and SAIF1 input
- *		clocks.
- */
-int mxs_saif_clkmux_select(unsigned int clkmux)
-{
-	if (clkmux > 0x3)
-		return -EINVAL;
-
-	spin_lock(&clkmux_lock);
-	__raw_writel(BM_DIGCTL_CTRL_SAIF_CLKMUX,
-			DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL + MXS_CLR_ADDR);
-	__raw_writel(clkmux << BP_DIGCTL_CTRL_SAIF_CLKMUX,
-			DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL + MXS_SET_ADDR);
-	spin_unlock(&clkmux_lock);
-
-	return 0;
-}
-
-static int _raw_clk_enable(struct clk *clk)
-{
-	u32 reg;
-
-	if (clk->enable_reg) {
-		reg = __raw_readl(clk->enable_reg);
-		reg &= ~(1 << clk->enable_shift);
-		__raw_writel(reg, clk->enable_reg);
-	}
-
-	return 0;
-}
-
-static void _raw_clk_disable(struct clk *clk)
-{
-	u32 reg;
-
-	if (clk->enable_reg) {
-		reg = __raw_readl(clk->enable_reg);
-		reg |= 1 << clk->enable_shift;
-		__raw_writel(reg, clk->enable_reg);
-	}
-}
-
-/*
- * ref_xtal_clk
- */
-static unsigned long ref_xtal_clk_get_rate(struct clk *clk)
-{
-	return 24000000;
-}
-
-static struct clk ref_xtal_clk = {
-	.get_rate = ref_xtal_clk_get_rate,
-};
-
-/*
- * pll_clk
- */
-static unsigned long pll0_clk_get_rate(struct clk *clk)
-{
-	return 480000000;
-}
-
-static unsigned long pll1_clk_get_rate(struct clk *clk)
-{
-	return 480000000;
-}
-
-static unsigned long pll2_clk_get_rate(struct clk *clk)
-{
-	return 50000000;
-}
-
-#define _CLK_ENABLE_PLL(name, r, g)					\
-static int name##_enable(struct clk *clk)				\
-{									\
-	__raw_writel(BM_CLKCTRL_##r##CTRL0_POWER,			\
-		     CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_SET);	\
-	udelay(10);							\
-									\
-	if (clk == &pll2_clk)						\
-		__raw_writel(BM_CLKCTRL_##r##CTRL0_##g,			\
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_CLR);	\
-	else								\
-		__raw_writel(BM_CLKCTRL_##r##CTRL0_##g,			\
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_SET);	\
-									\
-	return 0;							\
-}
-
-_CLK_ENABLE_PLL(pll0_clk, PLL0, EN_USB_CLKS)
-_CLK_ENABLE_PLL(pll1_clk, PLL1, EN_USB_CLKS)
-_CLK_ENABLE_PLL(pll2_clk, PLL2, CLKGATE)
-
-#define _CLK_DISABLE_PLL(name, r, g)					\
-static void name##_disable(struct clk *clk)				\
-{									\
-	__raw_writel(BM_CLKCTRL_##r##CTRL0_POWER,			\
-		     CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_CLR);	\
-									\
-	if (clk == &pll2_clk)						\
-		__raw_writel(BM_CLKCTRL_##r##CTRL0_##g,			\
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_SET);	\
-	else								\
-		__raw_writel(BM_CLKCTRL_##r##CTRL0_##g,			\
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_##r##CTRL0_CLR);	\
-									\
-}
-
-_CLK_DISABLE_PLL(pll0_clk, PLL0, EN_USB_CLKS)
-_CLK_DISABLE_PLL(pll1_clk, PLL1, EN_USB_CLKS)
-_CLK_DISABLE_PLL(pll2_clk, PLL2, CLKGATE)
-
-#define _DEFINE_CLOCK_PLL(name)						\
-	static struct clk name = {					\
-		.get_rate	= name##_get_rate,			\
-		.enable		= name##_enable,			\
-		.disable	= name##_disable,			\
-		.parent		= &ref_xtal_clk,			\
-	}
-
-_DEFINE_CLOCK_PLL(pll0_clk);
-_DEFINE_CLOCK_PLL(pll1_clk);
-_DEFINE_CLOCK_PLL(pll2_clk);
-
-/*
- * ref_clk
- */
-#define _CLK_GET_RATE_REF(name, sr, ss)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	unsigned long parent_rate;					\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##sr);		\
-	div = (reg >> BP_CLKCTRL_##sr##_##ss##FRAC) & 0x3f;		\
-	parent_rate = clk_get_rate(clk->parent);			\
-									\
-	return SH_DIV((parent_rate >> PARENT_RATE_SHIFT) * 18,		\
-			div, PARENT_RATE_SHIFT);			\
-}
-
-_CLK_GET_RATE_REF(ref_cpu_clk, FRAC0, CPU)
-_CLK_GET_RATE_REF(ref_emi_clk, FRAC0, EMI)
-_CLK_GET_RATE_REF(ref_io0_clk, FRAC0, IO0)
-_CLK_GET_RATE_REF(ref_io1_clk, FRAC0, IO1)
-_CLK_GET_RATE_REF(ref_pix_clk, FRAC1, PIX)
-_CLK_GET_RATE_REF(ref_gpmi_clk, FRAC1, GPMI)
-
-#define _DEFINE_CLOCK_REF(name, er, es)					\
-	static struct clk name = {					\
-		.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_##er,	\
-		.enable_shift	= BP_CLKCTRL_##er##_CLKGATE##es,	\
-		.get_rate	= name##_get_rate,			\
-		.enable		= _raw_clk_enable,			\
-		.disable	= _raw_clk_disable,			\
-		.parent		= &pll0_clk,				\
-	}
-
-_DEFINE_CLOCK_REF(ref_cpu_clk, FRAC0, CPU);
-_DEFINE_CLOCK_REF(ref_emi_clk, FRAC0, EMI);
-_DEFINE_CLOCK_REF(ref_io0_clk, FRAC0, IO0);
-_DEFINE_CLOCK_REF(ref_io1_clk, FRAC0, IO1);
-_DEFINE_CLOCK_REF(ref_pix_clk, FRAC1, PIX);
-_DEFINE_CLOCK_REF(ref_gpmi_clk, FRAC1, GPMI);
-
-/*
- * General clocks
- *
- * clk_get_rate
- */
-static unsigned long lradc_clk_get_rate(struct clk *clk)
-{
-	return clk_get_rate(clk->parent) / 16;
-}
-
-static unsigned long rtc_clk_get_rate(struct clk *clk)
-{
-	/* ref_xtal_clk is implemented as the only parent */
-	return clk_get_rate(clk->parent) / 768;
-}
-
-static unsigned long clk32k_clk_get_rate(struct clk *clk)
-{
-	return clk->parent->get_rate(clk->parent) / 750;
-}
-
-static unsigned long spdif_clk_get_rate(struct clk *clk)
-{
-	return clk_get_rate(clk->parent) / 4;
-}
-
-#define _CLK_GET_RATE(name, rs)						\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-									\
-	if (clk->parent == &ref_xtal_clk)				\
-		div = (reg & BM_CLKCTRL_##rs##_DIV_XTAL) >>		\
-			BP_CLKCTRL_##rs##_DIV_XTAL;			\
-	else								\
-		div = (reg & BM_CLKCTRL_##rs##_DIV_##rs) >>		\
-			BP_CLKCTRL_##rs##_DIV_##rs;			\
-									\
-	if (!div)							\
-		return -EINVAL;						\
-									\
-	return clk_get_rate(clk->parent) / div;				\
-}
-
-_CLK_GET_RATE(cpu_clk, CPU)
-_CLK_GET_RATE(emi_clk, EMI)
-
-#define _CLK_GET_RATE1(name, rs)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	u32 reg, div;							\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-	div = (reg & BM_CLKCTRL_##rs##_DIV) >> BP_CLKCTRL_##rs##_DIV;	\
-									\
-	if (!div)							\
-		return -EINVAL;						\
-									\
-	if (clk == &saif0_clk || clk == &saif1_clk)			\
-		return clk_get_rate(clk->parent) >> 16 * div;		\
-	else								\
-		return clk_get_rate(clk->parent) / div;			\
-}
-
-_CLK_GET_RATE1(hbus_clk, HBUS)
-_CLK_GET_RATE1(xbus_clk, XBUS)
-_CLK_GET_RATE1(ssp0_clk, SSP0)
-_CLK_GET_RATE1(ssp1_clk, SSP1)
-_CLK_GET_RATE1(ssp2_clk, SSP2)
-_CLK_GET_RATE1(ssp3_clk, SSP3)
-_CLK_GET_RATE1(gpmi_clk, GPMI)
-_CLK_GET_RATE1(lcdif_clk, DIS_LCDIF)
-_CLK_GET_RATE1(saif0_clk, SAIF0)
-_CLK_GET_RATE1(saif1_clk, SAIF1)
-
-#define _CLK_GET_RATE_STUB(name)					\
-static unsigned long name##_get_rate(struct clk *clk)			\
-{									\
-	return clk_get_rate(clk->parent);				\
-}
-
-_CLK_GET_RATE_STUB(uart_clk)
-_CLK_GET_RATE_STUB(pwm_clk)
-_CLK_GET_RATE_STUB(can0_clk)
-_CLK_GET_RATE_STUB(can1_clk)
-_CLK_GET_RATE_STUB(fec_clk)
-
-/*
- * clk_set_rate
- */
-/* fool compiler */
-#define BM_CLKCTRL_CPU_DIV	0
-#define BP_CLKCTRL_CPU_DIV	0
-#define BM_CLKCTRL_CPU_BUSY	0
-
-#define _CLK_SET_RATE(name, dr, fr, fs)					\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	u32 reg, bm_busy, div_max, d, f, div, frac;			\
-	unsigned long diff, parent_rate, calc_rate;			\
-									\
-	div_max = BM_CLKCTRL_##dr##_DIV >> BP_CLKCTRL_##dr##_DIV;	\
-	bm_busy = BM_CLKCTRL_##dr##_BUSY;				\
-									\
-	if (clk->parent == &ref_xtal_clk) {				\
-		parent_rate = clk_get_rate(clk->parent);		\
-		div = DIV_ROUND_UP(parent_rate, rate);			\
-		if (clk == &cpu_clk) {					\
-			div_max = BM_CLKCTRL_CPU_DIV_XTAL >>		\
-				BP_CLKCTRL_CPU_DIV_XTAL;		\
-			bm_busy = BM_CLKCTRL_CPU_BUSY_REF_XTAL;		\
-		}							\
-		if (div == 0 || div > div_max)				\
-			return -EINVAL;					\
-	} else {							\
-		/*							\
-		 * hack alert: this block modifies clk->parent, too,	\
-		 * so the base to use it the grand parent.		\
-		 */							\
-		parent_rate = clk_get_rate(clk->parent->parent);	\
-		rate >>= PARENT_RATE_SHIFT;				\
-		parent_rate >>= PARENT_RATE_SHIFT;			\
-		diff = parent_rate;					\
-		div = frac = 1;						\
-		if (clk == &cpu_clk) {					\
-			div_max = BM_CLKCTRL_CPU_DIV_CPU >>		\
-				BP_CLKCTRL_CPU_DIV_CPU;			\
-			bm_busy = BM_CLKCTRL_CPU_BUSY_REF_CPU;		\
-		}							\
-		for (d = 1; d <= div_max; d++) {			\
-			f = parent_rate * 18 / d / rate;		\
-			if ((parent_rate * 18 / d) % rate)		\
-				f++;					\
-			if (f < 18 || f > 35)				\
-				continue;				\
-									\
-			calc_rate = parent_rate * 18 / f / d;		\
-			if (calc_rate > rate)				\
-				continue;				\
-									\
-			if (rate - calc_rate < diff) {			\
-				frac = f;				\
-				div = d;				\
-				diff = rate - calc_rate;		\
-			}						\
-									\
-			if (diff == 0)					\
-				break;					\
-		}							\
-									\
-		if (diff == parent_rate)				\
-			return -EINVAL;					\
-									\
-		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##fr);	\
-		reg &= ~BM_CLKCTRL_##fr##_##fs##FRAC;			\
-		reg |= frac << BP_CLKCTRL_##fr##_##fs##FRAC;		\
-		__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_##fr);	\
-	}								\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-	if (clk == &cpu_clk) {						\
-		reg &= ~BM_CLKCTRL_CPU_DIV_CPU;				\
-		reg |= div << BP_CLKCTRL_CPU_DIV_CPU;			\
-	} else {							\
-		reg &= ~BM_CLKCTRL_##dr##_DIV;				\
-		reg |= div << BP_CLKCTRL_##dr##_DIV;			\
-		if (reg & (1 << clk->enable_shift)) {			\
-			pr_err("%s: clock is gated\n", __func__);	\
-			return -EINVAL;					\
-		}							\
-	}								\
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-									\
-	return mxs_clkctrl_timeout(HW_CLKCTRL_##dr, bm_busy);		\
-}
-
-_CLK_SET_RATE(cpu_clk, CPU, FRAC0, CPU)
-_CLK_SET_RATE(ssp0_clk, SSP0, FRAC0, IO0)
-_CLK_SET_RATE(ssp1_clk, SSP1, FRAC0, IO0)
-_CLK_SET_RATE(ssp2_clk, SSP2, FRAC0, IO1)
-_CLK_SET_RATE(ssp3_clk, SSP3, FRAC0, IO1)
-_CLK_SET_RATE(lcdif_clk, DIS_LCDIF, FRAC1, PIX)
-_CLK_SET_RATE(gpmi_clk, GPMI, FRAC1, GPMI)
-
-#define _CLK_SET_RATE1(name, dr)					\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	u32 reg, div_max, div;						\
-	unsigned long parent_rate;					\
-									\
-	parent_rate = clk_get_rate(clk->parent);			\
-	div_max = BM_CLKCTRL_##dr##_DIV >> BP_CLKCTRL_##dr##_DIV;	\
-									\
-	div = DIV_ROUND_UP(parent_rate, rate);				\
-	if (div == 0 || div > div_max)					\
-		return -EINVAL;						\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-	reg &= ~BM_CLKCTRL_##dr##_DIV;					\
-	reg |= div << BP_CLKCTRL_##dr##_DIV;				\
-	if (reg & (1 << clk->enable_shift)) {				\
-		pr_err("%s: clock is gated\n", __func__);		\
-		return -EINVAL;						\
-	}								\
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_##dr);		\
-									\
-	return mxs_clkctrl_timeout(HW_CLKCTRL_##dr, BM_CLKCTRL_##dr##_BUSY);\
-}
-
-_CLK_SET_RATE1(xbus_clk, XBUS)
-
-/* saif clock uses 16 bits frac div */
-#define _CLK_SET_RATE_SAIF(name, rs)					\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	u16 div;							\
-	u32 reg;							\
-	u64 lrate;							\
-	unsigned long parent_rate;					\
-									\
-	parent_rate = clk_get_rate(clk->parent);			\
-	if (rate > parent_rate)						\
-		return -EINVAL;						\
-									\
-	lrate = (u64)rate << 16;					\
-	do_div(lrate, parent_rate);					\
-	div = (u16)lrate;						\
-									\
-	if (!div)							\
-		return -EINVAL;						\
-									\
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-	reg &= ~BM_CLKCTRL_##rs##_DIV;					\
-	reg |= div << BP_CLKCTRL_##rs##_DIV;				\
-	if (reg & (1 << clk->enable_shift)) {				\
-		pr_err("%s: clock is gated\n", __func__);		\
-		return -EINVAL;						\
-	}								\
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_##rs);		\
-									\
-	return mxs_clkctrl_timeout(HW_CLKCTRL_##rs, BM_CLKCTRL_##rs##_BUSY);\
-}
-
-_CLK_SET_RATE_SAIF(saif0_clk, SAIF0)
-_CLK_SET_RATE_SAIF(saif1_clk, SAIF1)
-
-#define _CLK_SET_RATE_STUB(name)					\
-static int name##_set_rate(struct clk *clk, unsigned long rate)		\
-{									\
-	return -EINVAL;							\
-}
-
-_CLK_SET_RATE_STUB(emi_clk)
-_CLK_SET_RATE_STUB(uart_clk)
-_CLK_SET_RATE_STUB(pwm_clk)
-_CLK_SET_RATE_STUB(spdif_clk)
-_CLK_SET_RATE_STUB(clk32k_clk)
-_CLK_SET_RATE_STUB(can0_clk)
-_CLK_SET_RATE_STUB(can1_clk)
-_CLK_SET_RATE_STUB(fec_clk)
-
-/*
- * clk_set_parent
- */
-#define _CLK_SET_PARENT(name, bit)					\
-static int name##_set_parent(struct clk *clk, struct clk *parent)	\
-{									\
-	if (parent != clk->parent) {					\
-		__raw_writel(BM_CLKCTRL_CLKSEQ_BYPASS_##bit,		\
-			 CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ_TOG);	\
-		clk->parent = parent;					\
-	}								\
-									\
-	return 0;							\
-}
-
-_CLK_SET_PARENT(cpu_clk, CPU)
-_CLK_SET_PARENT(emi_clk, EMI)
-_CLK_SET_PARENT(ssp0_clk, SSP0)
-_CLK_SET_PARENT(ssp1_clk, SSP1)
-_CLK_SET_PARENT(ssp2_clk, SSP2)
-_CLK_SET_PARENT(ssp3_clk, SSP3)
-_CLK_SET_PARENT(lcdif_clk, DIS_LCDIF)
-_CLK_SET_PARENT(gpmi_clk, GPMI)
-_CLK_SET_PARENT(saif0_clk, SAIF0)
-_CLK_SET_PARENT(saif1_clk, SAIF1)
-
-#define _CLK_SET_PARENT_STUB(name)					\
-static int name##_set_parent(struct clk *clk, struct clk *parent)	\
-{									\
-	if (parent != clk->parent)					\
-		return -EINVAL;						\
-	else								\
-		return 0;						\
-}
-
-_CLK_SET_PARENT_STUB(pwm_clk)
-_CLK_SET_PARENT_STUB(uart_clk)
-_CLK_SET_PARENT_STUB(clk32k_clk)
-_CLK_SET_PARENT_STUB(spdif_clk)
-_CLK_SET_PARENT_STUB(fec_clk)
-_CLK_SET_PARENT_STUB(can0_clk)
-_CLK_SET_PARENT_STUB(can1_clk)
-
-/*
- * clk definition
- */
-static struct clk cpu_clk = {
-	.get_rate = cpu_clk_get_rate,
-	.set_rate = cpu_clk_set_rate,
-	.set_parent = cpu_clk_set_parent,
-	.parent = &ref_cpu_clk,
-};
-
-static struct clk hbus_clk = {
-	.get_rate = hbus_clk_get_rate,
-	.parent = &cpu_clk,
-};
-
-static struct clk xbus_clk = {
-	.get_rate = xbus_clk_get_rate,
-	.set_rate = xbus_clk_set_rate,
-	.parent = &ref_xtal_clk,
-};
-
-static struct clk lradc_clk = {
-	.get_rate = lradc_clk_get_rate,
-	.parent = &clk32k_clk,
-};
-
-static struct clk rtc_clk = {
-	.get_rate = rtc_clk_get_rate,
-	.parent = &ref_xtal_clk,
-};
-
-/* usb_clk gate is controlled in DIGCTRL other than CLKCTRL */
-static struct clk usb0_clk = {
-	.enable_reg = DIGCTRL_BASE_ADDR,
-	.enable_shift = 2,
-	.enable = _raw_clk_enable,
-	.disable = _raw_clk_disable,
-	.parent = &pll0_clk,
-};
-
-static struct clk usb1_clk = {
-	.enable_reg = DIGCTRL_BASE_ADDR,
-	.enable_shift = 16,
-	.enable = _raw_clk_enable,
-	.disable = _raw_clk_disable,
-	.parent = &pll1_clk,
-};
-
-#define _DEFINE_CLOCK(name, er, es, p)					\
-	static struct clk name = {					\
-		.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_##er,	\
-		.enable_shift	= BP_CLKCTRL_##er##_##es,		\
-		.get_rate	= name##_get_rate,			\
-		.set_rate	= name##_set_rate,			\
-		.set_parent	= name##_set_parent,			\
-		.enable		= _raw_clk_enable,			\
-		.disable	= _raw_clk_disable,			\
-		.parent		= p,					\
-	}
-
-_DEFINE_CLOCK(emi_clk, EMI, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(ssp0_clk, SSP0, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(ssp1_clk, SSP1, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(ssp2_clk, SSP2, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(ssp3_clk, SSP3, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(lcdif_clk, DIS_LCDIF, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(gpmi_clk, GPMI, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(saif0_clk, SAIF0, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(saif1_clk, SAIF1, CLKGATE, &ref_xtal_clk);
-_DEFINE_CLOCK(can0_clk, FLEXCAN, STOP_CAN0, &ref_xtal_clk);
-_DEFINE_CLOCK(can1_clk, FLEXCAN, STOP_CAN1, &ref_xtal_clk);
-_DEFINE_CLOCK(pwm_clk, XTAL, PWM_CLK24M_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(uart_clk, XTAL, UART_CLK_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(clk32k_clk, XTAL, TIMROT_CLK32K_GATE, &ref_xtal_clk);
-_DEFINE_CLOCK(spdif_clk, SPDIF, CLKGATE, &pll0_clk);
-_DEFINE_CLOCK(fec_clk, ENET, DISABLE, &hbus_clk);
-
-#define _REGISTER_CLOCK(d, n, c) \
-	{ \
-		.dev_id = d, \
-		.con_id = n, \
-		.clk = &c, \
-	},
-
-static struct clk_lookup lookups[] = {
-	/* for amba bus driver */
-	_REGISTER_CLOCK("duart", "apb_pclk", xbus_clk)
-	/* for amba-pl011 driver */
-	_REGISTER_CLOCK("duart", NULL, uart_clk)
-	_REGISTER_CLOCK("imx28-fec.0", NULL, fec_clk)
-	_REGISTER_CLOCK("imx28-fec.1", NULL, fec_clk)
-	_REGISTER_CLOCK("imx28-gpmi-nand", NULL, gpmi_clk)
-	_REGISTER_CLOCK("mxs-auart.0", NULL, uart_clk)
-	_REGISTER_CLOCK("mxs-auart.1", NULL, uart_clk)
-	_REGISTER_CLOCK("mxs-auart.2", NULL, uart_clk)
-	_REGISTER_CLOCK("mxs-auart.3", NULL, uart_clk)
-	_REGISTER_CLOCK("mxs-auart.4", NULL, uart_clk)
-	_REGISTER_CLOCK("rtc", NULL, rtc_clk)
-	_REGISTER_CLOCK("enet_out", NULL, pll2_clk)
-	_REGISTER_CLOCK("mxs-dma-apbh", NULL, hbus_clk)
-	_REGISTER_CLOCK("mxs-dma-apbx", NULL, xbus_clk)
-	_REGISTER_CLOCK("mxs-mmc.0", NULL, ssp0_clk)
-	_REGISTER_CLOCK("mxs-mmc.1", NULL, ssp1_clk)
-	_REGISTER_CLOCK("mxs-mmc.2", NULL, ssp2_clk)
-	_REGISTER_CLOCK("mxs-mmc.3", NULL, ssp3_clk)
-	_REGISTER_CLOCK("flexcan.0", NULL, can0_clk)
-	_REGISTER_CLOCK("flexcan.1", NULL, can1_clk)
-	_REGISTER_CLOCK(NULL, "usb0", usb0_clk)
-	_REGISTER_CLOCK(NULL, "usb1", usb1_clk)
-	_REGISTER_CLOCK("mxs-pwm.0", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.1", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.2", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.3", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.4", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.5", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.6", NULL, pwm_clk)
-	_REGISTER_CLOCK("mxs-pwm.7", NULL, pwm_clk)
-	_REGISTER_CLOCK(NULL, "lradc", lradc_clk)
-	_REGISTER_CLOCK(NULL, "spdif", spdif_clk)
-	_REGISTER_CLOCK("imx28-fb", NULL, lcdif_clk)
-	_REGISTER_CLOCK("mxs-saif.0", NULL, saif0_clk)
-	_REGISTER_CLOCK("mxs-saif.1", NULL, saif1_clk)
-};
-
-static int clk_misc_init(void)
-{
-	u32 reg;
-	int ret;
-
-	/* Fix up parent per register setting */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
-	cpu_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU) ?
-			&ref_xtal_clk : &ref_cpu_clk;
-	emi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI) ?
-			&ref_xtal_clk : &ref_emi_clk;
-	ssp0_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP0) ?
-			&ref_xtal_clk : &ref_io0_clk;
-	ssp1_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP1) ?
-			&ref_xtal_clk : &ref_io0_clk;
-	ssp2_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP2) ?
-			&ref_xtal_clk : &ref_io1_clk;
-	ssp3_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP3) ?
-			&ref_xtal_clk : &ref_io1_clk;
-	lcdif_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF) ?
-			&ref_xtal_clk : &ref_pix_clk;
-	gpmi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI) ?
-			&ref_xtal_clk : &ref_gpmi_clk;
-	saif0_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF0) ?
-			&ref_xtal_clk : &pll0_clk;
-	saif1_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF1) ?
-			&ref_xtal_clk : &pll0_clk;
-
-	/* Use int div over frac when both are available */
-	__raw_writel(BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);
-	__raw_writel(BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);
-	__raw_writel(BM_CLKCTRL_HBUS_DIV_FRAC_EN,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
-	reg &= ~BM_CLKCTRL_XBUS_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);
-	reg &= ~BM_CLKCTRL_SSP0_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);
-	reg &= ~BM_CLKCTRL_SSP1_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);
-	reg &= ~BM_CLKCTRL_SSP2_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);
-	reg &= ~BM_CLKCTRL_SSP3_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
-	reg &= ~BM_CLKCTRL_GPMI_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);
-	reg &= ~BM_CLKCTRL_DIS_LCDIF_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);
-
-	/* SAIF has to use frac div for functional operation */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);
-	reg |= BM_CLKCTRL_SAIF0_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);
-
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);
-	reg |= BM_CLKCTRL_SAIF1_DIV_FRAC_EN;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);
-
-	/*
-	 * Set safe hbus clock divider. A divider of 3 ensure that
-	 * the Vddd voltage required for the cpu clock is sufficiently
-	 * high for the hbus clock.
-	 */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
-	reg &= BM_CLKCTRL_HBUS_DIV;
-	reg |= 3 << BP_CLKCTRL_HBUS_DIV;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
-
-	ret = mxs_clkctrl_timeout(HW_CLKCTRL_HBUS, BM_CLKCTRL_HBUS_ASM_BUSY);
-
-	/* Gate off cpu clock in WFI for power saving */
-	__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,
-			CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_SET);
-
-	/*
-	 * Extra fec clock setting
-	 * The DENX M28 uses an external clock source
-	 * and the clock output must not be enabled
-	 */
-	if (!machine_is_m28evk()) {
-		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
-		reg &= ~BM_CLKCTRL_ENET_SLEEP;
-		reg |= BM_CLKCTRL_ENET_CLK_OUT_EN;
-		__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
-	}
-
-	/*
-	 * 480 MHz seems too high to be ssp clock source directly,
-	 * so set frac0 to get a 288 MHz ref_io0.
-	 */
-	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);
-	reg &= ~BM_CLKCTRL_FRAC0_IO0FRAC;
-	reg |= 30 << BP_CLKCTRL_FRAC0_IO0FRAC;
-	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);
-
-	return ret;
-}
-
-int __init mx28_clocks_init(void)
-{
-	clk_misc_init();
-
-	/*
-	 * source ssp clock from ref_io0 than ref_xtal,
-	 * as ref_xtal only provides 24 MHz as maximum.
-	 */
-	clk_set_parent(&ssp0_clk, &ref_io0_clk);
-	clk_set_parent(&ssp1_clk, &ref_io0_clk);
-	clk_set_parent(&ssp2_clk, &ref_io1_clk);
-	clk_set_parent(&ssp3_clk, &ref_io1_clk);
-
-	clk_prepare_enable(&cpu_clk);
-	clk_prepare_enable(&hbus_clk);
-	clk_prepare_enable(&xbus_clk);
-	clk_prepare_enable(&emi_clk);
-	clk_prepare_enable(&uart_clk);
-
-	clk_set_parent(&lcdif_clk, &ref_pix_clk);
-	clk_set_parent(&saif0_clk, &pll0_clk);
-	clk_set_parent(&saif1_clk, &pll0_clk);
-
-	/*
-	 * Set an initial clock rate for the saif internal logic to work
-	 * properly. This is important when working in EXTMASTER mode that
-	 * uses the other saif's BITCLK&LRCLK but it still needs a basic
-	 * clock which should be fast enough for the internal logic.
-	 */
-	clk_set_rate(&saif0_clk, 24000000);
-	clk_set_rate(&saif1_clk, 24000000);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	mxs_timer_init(&clk32k_clk, MX28_INT_TIMER0);
-
-	return 0;
-}
diff --git a/arch/arm/mach-mxs/clock.c b/arch/arm/mach-mxs/clock.c
deleted file mode 100644
index 97a6f4a..0000000
--- a/arch/arm/mach-mxs/clock.c
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Based on arch/arm/plat-omap/clock.c
- *
- * Copyright (C) 2004 - 2005 Nokia corporation
- * Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
- * Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-/* #define DEBUG */
-
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/proc_fs.h>
-#include <linux/semaphore.h>
-#include <linux/string.h>
-
-#include <mach/clock.h>
-
-static LIST_HEAD(clocks);
-static DEFINE_MUTEX(clocks_mutex);
-
-/*-------------------------------------------------------------------------
- * Standard clock functions defined in include/linux/clk.h
- *-------------------------------------------------------------------------*/
-
-static void __clk_disable(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return;
-	WARN_ON(!clk->usecount);
-
-	if (!(--clk->usecount)) {
-		if (clk->disable)
-			clk->disable(clk);
-		__clk_disable(clk->parent);
-	}
-}
-
-static int __clk_enable(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return -EINVAL;
-
-	if (clk->usecount++ == 0) {
-		__clk_enable(clk->parent);
-
-		if (clk->enable)
-			clk->enable(clk);
-	}
-	return 0;
-}
-
-/*
- * The clk_enable/clk_disable could be called by drivers in atomic context,
- * so they should not really hold mutex.  Instead, clk_prepare/clk_unprepare
- * can hold a mutex, as the pair will only be called in non-atomic context.
- * Before migrating to common clk framework, we can have __clk_enable and
- * __clk_disable called in clk_prepare/clk_unprepare with mutex held and
- * leave clk_enable/clk_disable as the dummy functions.
- */
-int clk_prepare(struct clk *clk)
-{
-	int ret = 0;
-
-	if (clk == NULL || IS_ERR(clk))
-		return -EINVAL;
-
-	mutex_lock(&clocks_mutex);
-	ret = __clk_enable(clk);
-	mutex_unlock(&clocks_mutex);
-
-	return ret;
-}
-EXPORT_SYMBOL(clk_prepare);
-
-void clk_unprepare(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return;
-
-	mutex_lock(&clocks_mutex);
-	__clk_disable(clk);
-	mutex_unlock(&clocks_mutex);
-}
-EXPORT_SYMBOL(clk_unprepare);
-
-int clk_enable(struct clk *clk)
-{
-	return 0;
-}
-EXPORT_SYMBOL(clk_enable);
-
-void clk_disable(struct clk *clk)
-{
-	/* nothing to do */
-}
-EXPORT_SYMBOL(clk_disable);
-
-/* Retrieve the *current* clock rate. If the clock itself
- * does not provide a special calculation routine, ask
- * its parent and so on, until one is able to return
- * a valid clock rate
- */
-unsigned long clk_get_rate(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return 0UL;
-
-	if (clk->get_rate)
-		return clk->get_rate(clk);
-
-	return clk_get_rate(clk->parent);
-}
-EXPORT_SYMBOL(clk_get_rate);
-
-/* Round the requested clock rate to the nearest supported
- * rate that is less than or equal to the requested rate.
- * This is dependent on the clock's current parent.
- */
-long clk_round_rate(struct clk *clk, unsigned long rate)
-{
-	if (clk == NULL || IS_ERR(clk) || !clk->round_rate)
-		return 0;
-
-	return clk->round_rate(clk, rate);
-}
-EXPORT_SYMBOL(clk_round_rate);
-
-/* Set the clock to the requested clock rate. The rate must
- * match a supported rate exactly based on what clk_round_rate returns
- */
-int clk_set_rate(struct clk *clk, unsigned long rate)
-{
-	int ret = -EINVAL;
-
-	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
-		return ret;
-
-	mutex_lock(&clocks_mutex);
-	ret = clk->set_rate(clk, rate);
-	mutex_unlock(&clocks_mutex);
-
-	return ret;
-}
-EXPORT_SYMBOL(clk_set_rate);
-
-/* Set the clock's parent to another clock source */
-int clk_set_parent(struct clk *clk, struct clk *parent)
-{
-	int ret = -EINVAL;
-	struct clk *old;
-
-	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
-	    IS_ERR(parent) || clk->set_parent == NULL)
-		return ret;
-
-	if (clk->usecount)
-		clk_prepare_enable(parent);
-
-	mutex_lock(&clocks_mutex);
-	ret = clk->set_parent(clk, parent);
-	if (ret == 0) {
-		old = clk->parent;
-		clk->parent = parent;
-	} else {
-		old = parent;
-	}
-	mutex_unlock(&clocks_mutex);
-
-	if (clk->usecount)
-		clk_disable(old);
-
-	return ret;
-}
-EXPORT_SYMBOL(clk_set_parent);
-
-/* Retrieve the clock's parent clock source */
-struct clk *clk_get_parent(struct clk *clk)
-{
-	struct clk *ret = NULL;
-
-	if (clk == NULL || IS_ERR(clk))
-		return ret;
-
-	return clk->parent;
-}
-EXPORT_SYMBOL(clk_get_parent);
diff --git a/arch/arm/mach-mxs/include/mach/clock.h b/arch/arm/mach-mxs/include/mach/clock.h
deleted file mode 100644
index 592c9ab..0000000
--- a/arch/arm/mach-mxs/include/mach/clock.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-#ifndef __MACH_MXS_CLOCK_H__
-#define __MACH_MXS_CLOCK_H__
-
-#ifndef __ASSEMBLY__
-#include <linux/list.h>
-
-struct module;
-
-struct clk {
-	int id;
-	/* Source clock this clk depends on */
-	struct clk *parent;
-	/* Reference count of clock enable/disable */
-	__s8 usecount;
-	/* Register bit position for clock's enable/disable control. */
-	u8 enable_shift;
-	/* Register address for clock's enable/disable control. */
-	void __iomem *enable_reg;
-	u32 flags;
-	/* get the current clock rate (always a fresh value) */
-	unsigned long (*get_rate) (struct clk *);
-	/* Function ptr to set the clock to a new rate. The rate must match a
-	   supported rate returned from round_rate. Leave blank if clock is not
-	   programmable */
-	int (*set_rate) (struct clk *, unsigned long);
-	/* Function ptr to round the requested clock rate to the nearest
-	   supported rate that is less than or equal to the requested rate. */
-	unsigned long (*round_rate) (struct clk *, unsigned long);
-	/* Function ptr to enable the clock. Leave blank if clock can not
-	   be gated. */
-	int (*enable) (struct clk *);
-	/* Function ptr to disable the clock. Leave blank if clock can not
-	   be gated. */
-	void (*disable) (struct clk *);
-	/* Function ptr to set the parent clock of the clock. */
-	int (*set_parent) (struct clk *, struct clk *);
-};
-
-int clk_register(struct clk *clk);
-void clk_unregister(struct clk *clk);
-
-#endif /* __ASSEMBLY__ */
-#endif /* __MACH_MXS_CLOCK_H__ */
diff --git a/arch/arm/mach-mxs/include/mach/common.h b/arch/arm/mach-mxs/include/mach/common.h
index c50c3ea..e1237ab 100644
--- a/arch/arm/mach-mxs/include/mach/common.h
+++ b/arch/arm/mach-mxs/include/mach/common.h
@@ -31,6 +31,4 @@ extern void mx28_init_irq(void);
 
 extern void icoll_init_irq(void);
 
-extern int mxs_clkctrl_timeout(unsigned int reg_offset, unsigned int mask);
-
 #endif /* __MACH_MXS_COMMON_H__ */
diff --git a/arch/arm/mach-mxs/regs-clkctrl-mx23.h b/arch/arm/mach-mxs/regs-clkctrl-mx23.h
deleted file mode 100644
index 0ea5c9d..0000000
--- a/arch/arm/mach-mxs/regs-clkctrl-mx23.h
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Freescale CLKCTRL Register Definitions
- *
- * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
- * Copyright 2008-2010 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- * This file is created by xml file. Don't Edit it.
- *
- * Xml Revision: 1.48
- * Template revision: 26195
- */
-
-#ifndef __REGS_CLKCTRL_MX23_H__
-#define __REGS_CLKCTRL_MX23_H__
-
-
-#define HW_CLKCTRL_PLLCTRL0	(0x00000000)
-#define HW_CLKCTRL_PLLCTRL0_SET	(0x00000004)
-#define HW_CLKCTRL_PLLCTRL0_CLR	(0x00000008)
-#define HW_CLKCTRL_PLLCTRL0_TOG	(0x0000000c)
-
-#define BP_CLKCTRL_PLLCTRL0_LFR_SEL	28
-#define BM_CLKCTRL_PLLCTRL0_LFR_SEL	0x30000000
-#define BF_CLKCTRL_PLLCTRL0_LFR_SEL(v)  \
-		(((v) << 28) & BM_CLKCTRL_PLLCTRL0_LFR_SEL)
-#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLLCTRL0_CP_SEL	24
-#define BM_CLKCTRL_PLLCTRL0_CP_SEL	0x03000000
-#define BF_CLKCTRL_PLLCTRL0_CP_SEL(v)  \
-		(((v) << 24) & BM_CLKCTRL_PLLCTRL0_CP_SEL)
-#define BV_CLKCTRL_PLLCTRL0_CP_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLLCTRL0_CP_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLLCTRL0_CP_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLLCTRL0_CP_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLLCTRL0_DIV_SEL	20
-#define BM_CLKCTRL_PLLCTRL0_DIV_SEL	0x00300000
-#define BF_CLKCTRL_PLLCTRL0_DIV_SEL(v)  \
-		(((v) << 20) & BM_CLKCTRL_PLLCTRL0_DIV_SEL)
-#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__LOWER     0x1
-#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__LOWEST    0x2
-#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__UNDEFINED 0x3
-#define BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS	0x00040000
-#define BM_CLKCTRL_PLLCTRL0_POWER	0x00010000
-
-#define HW_CLKCTRL_PLLCTRL1	(0x00000010)
-
-#define BM_CLKCTRL_PLLCTRL1_LOCK	0x80000000
-#define BM_CLKCTRL_PLLCTRL1_FORCE_LOCK	0x40000000
-#define BP_CLKCTRL_PLLCTRL1_LOCK_COUNT	0
-#define BM_CLKCTRL_PLLCTRL1_LOCK_COUNT	0x0000FFFF
-#define BF_CLKCTRL_PLLCTRL1_LOCK_COUNT(v)  \
-		(((v) << 0) & BM_CLKCTRL_PLLCTRL1_LOCK_COUNT)
-
-#define HW_CLKCTRL_CPU	(0x00000020)
-#define HW_CLKCTRL_CPU_SET	(0x00000024)
-#define HW_CLKCTRL_CPU_CLR	(0x00000028)
-#define HW_CLKCTRL_CPU_TOG	(0x0000002c)
-
-#define BM_CLKCTRL_CPU_BUSY_REF_XTAL	0x20000000
-#define BM_CLKCTRL_CPU_BUSY_REF_CPU	0x10000000
-#define BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN	0x04000000
-#define BP_CLKCTRL_CPU_DIV_XTAL	16
-#define BM_CLKCTRL_CPU_DIV_XTAL	0x03FF0000
-#define BF_CLKCTRL_CPU_DIV_XTAL(v)  \
-		(((v) << 16) & BM_CLKCTRL_CPU_DIV_XTAL)
-#define BM_CLKCTRL_CPU_INTERRUPT_WAIT	0x00001000
-#define BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN	0x00000400
-#define BP_CLKCTRL_CPU_DIV_CPU	0
-#define BM_CLKCTRL_CPU_DIV_CPU	0x0000003F
-#define BF_CLKCTRL_CPU_DIV_CPU(v)  \
-		(((v) << 0) & BM_CLKCTRL_CPU_DIV_CPU)
-
-#define HW_CLKCTRL_HBUS	(0x00000030)
-#define HW_CLKCTRL_HBUS_SET	(0x00000034)
-#define HW_CLKCTRL_HBUS_CLR	(0x00000038)
-#define HW_CLKCTRL_HBUS_TOG	(0x0000003c)
-
-#define BM_CLKCTRL_HBUS_BUSY	0x20000000
-#define BM_CLKCTRL_HBUS_DCP_AS_ENABLE	0x10000000
-#define BM_CLKCTRL_HBUS_PXP_AS_ENABLE	0x08000000
-#define BM_CLKCTRL_HBUS_APBHDMA_AS_ENABLE	0x04000000
-#define BM_CLKCTRL_HBUS_APBXDMA_AS_ENABLE	0x02000000
-#define BM_CLKCTRL_HBUS_TRAFFIC_JAM_AS_ENABLE	0x01000000
-#define BM_CLKCTRL_HBUS_TRAFFIC_AS_ENABLE	0x00800000
-#define BM_CLKCTRL_HBUS_CPU_DATA_AS_ENABLE	0x00400000
-#define BM_CLKCTRL_HBUS_CPU_INSTR_AS_ENABLE	0x00200000
-#define BM_CLKCTRL_HBUS_AUTO_SLOW_MODE	0x00100000
-#define BP_CLKCTRL_HBUS_SLOW_DIV	16
-#define BM_CLKCTRL_HBUS_SLOW_DIV	0x00070000
-#define BF_CLKCTRL_HBUS_SLOW_DIV(v)  \
-		(((v) << 16) & BM_CLKCTRL_HBUS_SLOW_DIV)
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY1  0x0
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY2  0x1
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY4  0x2
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY8  0x3
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY16 0x4
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY32 0x5
-#define BM_CLKCTRL_HBUS_DIV_FRAC_EN	0x00000020
-#define BP_CLKCTRL_HBUS_DIV	0
-#define BM_CLKCTRL_HBUS_DIV	0x0000001F
-#define BF_CLKCTRL_HBUS_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_HBUS_DIV)
-
-#define HW_CLKCTRL_XBUS	(0x00000040)
-
-#define BM_CLKCTRL_XBUS_BUSY	0x80000000
-#define BM_CLKCTRL_XBUS_DIV_FRAC_EN	0x00000400
-#define BP_CLKCTRL_XBUS_DIV	0
-#define BM_CLKCTRL_XBUS_DIV	0x000003FF
-#define BF_CLKCTRL_XBUS_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_XBUS_DIV)
-
-#define HW_CLKCTRL_XTAL	(0x00000050)
-#define HW_CLKCTRL_XTAL_SET	(0x00000054)
-#define HW_CLKCTRL_XTAL_CLR	(0x00000058)
-#define HW_CLKCTRL_XTAL_TOG	(0x0000005c)
-
-#define BP_CLKCTRL_XTAL_UART_CLK_GATE	31
-#define BM_CLKCTRL_XTAL_UART_CLK_GATE	0x80000000
-#define BP_CLKCTRL_XTAL_FILT_CLK24M_GATE	30
-#define BM_CLKCTRL_XTAL_FILT_CLK24M_GATE	0x40000000
-#define BP_CLKCTRL_XTAL_PWM_CLK24M_GATE	29
-#define BM_CLKCTRL_XTAL_PWM_CLK24M_GATE	0x20000000
-#define BM_CLKCTRL_XTAL_DRI_CLK24M_GATE	0x10000000
-#define BM_CLKCTRL_XTAL_DIGCTRL_CLK1M_GATE	0x08000000
-#define BP_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	26
-#define BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	0x04000000
-#define BP_CLKCTRL_XTAL_DIV_UART	0
-#define BM_CLKCTRL_XTAL_DIV_UART	0x00000003
-#define BF_CLKCTRL_XTAL_DIV_UART(v)  \
-		(((v) << 0) & BM_CLKCTRL_XTAL_DIV_UART)
-
-#define HW_CLKCTRL_PIX	(0x00000060)
-
-#define BP_CLKCTRL_PIX_CLKGATE	31
-#define BM_CLKCTRL_PIX_CLKGATE	0x80000000
-#define BM_CLKCTRL_PIX_BUSY	0x20000000
-#define BM_CLKCTRL_PIX_DIV_FRAC_EN	0x00001000
-#define BP_CLKCTRL_PIX_DIV	0
-#define BM_CLKCTRL_PIX_DIV	0x00000FFF
-#define BF_CLKCTRL_PIX_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_PIX_DIV)
-
-#define HW_CLKCTRL_SSP	(0x00000070)
-
-#define BP_CLKCTRL_SSP_CLKGATE	31
-#define BM_CLKCTRL_SSP_CLKGATE	0x80000000
-#define BM_CLKCTRL_SSP_BUSY	0x20000000
-#define BM_CLKCTRL_SSP_DIV_FRAC_EN	0x00000200
-#define BP_CLKCTRL_SSP_DIV	0
-#define BM_CLKCTRL_SSP_DIV	0x000001FF
-#define BF_CLKCTRL_SSP_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SSP_DIV)
-
-#define HW_CLKCTRL_GPMI	(0x00000080)
-
-#define BP_CLKCTRL_GPMI_CLKGATE	31
-#define BM_CLKCTRL_GPMI_CLKGATE	0x80000000
-#define BM_CLKCTRL_GPMI_BUSY	0x20000000
-#define BM_CLKCTRL_GPMI_DIV_FRAC_EN	0x00000400
-#define BP_CLKCTRL_GPMI_DIV	0
-#define BM_CLKCTRL_GPMI_DIV	0x000003FF
-#define BF_CLKCTRL_GPMI_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_GPMI_DIV)
-
-#define HW_CLKCTRL_SPDIF	(0x00000090)
-
-#define BM_CLKCTRL_SPDIF_CLKGATE	0x80000000
-
-#define HW_CLKCTRL_EMI	(0x000000a0)
-
-#define BP_CLKCTRL_EMI_CLKGATE	31
-#define BM_CLKCTRL_EMI_CLKGATE	0x80000000
-#define BM_CLKCTRL_EMI_SYNC_MODE_EN	0x40000000
-#define BM_CLKCTRL_EMI_BUSY_REF_XTAL	0x20000000
-#define BM_CLKCTRL_EMI_BUSY_REF_EMI	0x10000000
-#define BM_CLKCTRL_EMI_BUSY_REF_CPU	0x08000000
-#define BM_CLKCTRL_EMI_BUSY_SYNC_MODE	0x04000000
-#define BM_CLKCTRL_EMI_BUSY_DCC_RESYNC	0x00020000
-#define BM_CLKCTRL_EMI_DCC_RESYNC_ENABLE	0x00010000
-#define BP_CLKCTRL_EMI_DIV_XTAL	8
-#define BM_CLKCTRL_EMI_DIV_XTAL	0x00000F00
-#define BF_CLKCTRL_EMI_DIV_XTAL(v)  \
-		(((v) << 8) & BM_CLKCTRL_EMI_DIV_XTAL)
-#define BP_CLKCTRL_EMI_DIV_EMI	0
-#define BM_CLKCTRL_EMI_DIV_EMI	0x0000003F
-#define BF_CLKCTRL_EMI_DIV_EMI(v)  \
-		(((v) << 0) & BM_CLKCTRL_EMI_DIV_EMI)
-
-#define HW_CLKCTRL_IR	(0x000000b0)
-
-#define BM_CLKCTRL_IR_CLKGATE	0x80000000
-#define BM_CLKCTRL_IR_AUTO_DIV	0x20000000
-#define BM_CLKCTRL_IR_IR_BUSY	0x10000000
-#define BM_CLKCTRL_IR_IROV_BUSY	0x08000000
-#define BP_CLKCTRL_IR_IROV_DIV	16
-#define BM_CLKCTRL_IR_IROV_DIV	0x01FF0000
-#define BF_CLKCTRL_IR_IROV_DIV(v)  \
-		(((v) << 16) & BM_CLKCTRL_IR_IROV_DIV)
-#define BP_CLKCTRL_IR_IR_DIV	0
-#define BM_CLKCTRL_IR_IR_DIV	0x000003FF
-#define BF_CLKCTRL_IR_IR_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_IR_IR_DIV)
-
-#define HW_CLKCTRL_SAIF	(0x000000c0)
-
-#define BM_CLKCTRL_SAIF_CLKGATE	0x80000000
-#define BM_CLKCTRL_SAIF_BUSY	0x20000000
-#define BM_CLKCTRL_SAIF_DIV_FRAC_EN	0x00010000
-#define BP_CLKCTRL_SAIF_DIV	0
-#define BM_CLKCTRL_SAIF_DIV	0x0000FFFF
-#define BF_CLKCTRL_SAIF_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SAIF_DIV)
-
-#define HW_CLKCTRL_TV	(0x000000d0)
-
-#define BM_CLKCTRL_TV_CLK_TV108M_GATE	0x80000000
-#define BM_CLKCTRL_TV_CLK_TV_GATE	0x40000000
-
-#define HW_CLKCTRL_ETM	(0x000000e0)
-
-#define BM_CLKCTRL_ETM_CLKGATE	0x80000000
-#define BM_CLKCTRL_ETM_BUSY	0x20000000
-#define BM_CLKCTRL_ETM_DIV_FRAC_EN	0x00000040
-#define BP_CLKCTRL_ETM_DIV	0
-#define BM_CLKCTRL_ETM_DIV	0x0000003F
-#define BF_CLKCTRL_ETM_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_ETM_DIV)
-
-#define HW_CLKCTRL_FRAC	(0x000000f0)
-#define HW_CLKCTRL_FRAC_SET	(0x000000f4)
-#define HW_CLKCTRL_FRAC_CLR	(0x000000f8)
-#define HW_CLKCTRL_FRAC_TOG	(0x000000fc)
-
-#define BP_CLKCTRL_FRAC_CLKGATEIO	31
-#define BM_CLKCTRL_FRAC_CLKGATEIO	0x80000000
-#define BM_CLKCTRL_FRAC_IO_STABLE	0x40000000
-#define BP_CLKCTRL_FRAC_IOFRAC	24
-#define BM_CLKCTRL_FRAC_IOFRAC	0x3F000000
-#define BF_CLKCTRL_FRAC_IOFRAC(v)  \
-		(((v) << 24) & BM_CLKCTRL_FRAC_IOFRAC)
-#define BP_CLKCTRL_FRAC_CLKGATEPIX	23
-#define BM_CLKCTRL_FRAC_CLKGATEPIX	0x00800000
-#define BM_CLKCTRL_FRAC_PIX_STABLE	0x00400000
-#define BP_CLKCTRL_FRAC_PIXFRAC	16
-#define BM_CLKCTRL_FRAC_PIXFRAC	0x003F0000
-#define BF_CLKCTRL_FRAC_PIXFRAC(v)  \
-		(((v) << 16) & BM_CLKCTRL_FRAC_PIXFRAC)
-#define BP_CLKCTRL_FRAC_CLKGATEEMI	15
-#define BM_CLKCTRL_FRAC_CLKGATEEMI	0x00008000
-#define BM_CLKCTRL_FRAC_EMI_STABLE	0x00004000
-#define BP_CLKCTRL_FRAC_EMIFRAC	8
-#define BM_CLKCTRL_FRAC_EMIFRAC	0x00003F00
-#define BF_CLKCTRL_FRAC_EMIFRAC(v)  \
-		(((v) << 8) & BM_CLKCTRL_FRAC_EMIFRAC)
-#define BP_CLKCTRL_FRAC_CLKGATECPU	7
-#define BM_CLKCTRL_FRAC_CLKGATECPU	0x00000080
-#define BM_CLKCTRL_FRAC_CPU_STABLE	0x00000040
-#define BP_CLKCTRL_FRAC_CPUFRAC	0
-#define BM_CLKCTRL_FRAC_CPUFRAC	0x0000003F
-#define BF_CLKCTRL_FRAC_CPUFRAC(v)  \
-		(((v) << 0) & BM_CLKCTRL_FRAC_CPUFRAC)
-
-#define HW_CLKCTRL_FRAC1	(0x00000100)
-#define HW_CLKCTRL_FRAC1_SET	(0x00000104)
-#define HW_CLKCTRL_FRAC1_CLR	(0x00000108)
-#define HW_CLKCTRL_FRAC1_TOG	(0x0000010c)
-
-#define BM_CLKCTRL_FRAC1_CLKGATEVID	0x80000000
-#define BM_CLKCTRL_FRAC1_VID_STABLE	0x40000000
-
-#define HW_CLKCTRL_CLKSEQ	(0x00000110)
-#define HW_CLKCTRL_CLKSEQ_SET	(0x00000114)
-#define HW_CLKCTRL_CLKSEQ_CLR	(0x00000118)
-#define HW_CLKCTRL_CLKSEQ_TOG	(0x0000011c)
-
-#define BM_CLKCTRL_CLKSEQ_BYPASS_ETM	0x00000100
-#define BM_CLKCTRL_CLKSEQ_BYPASS_CPU	0x00000080
-#define BM_CLKCTRL_CLKSEQ_BYPASS_EMI	0x00000040
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP	0x00000020
-#define BM_CLKCTRL_CLKSEQ_BYPASS_GPMI	0x00000010
-#define BM_CLKCTRL_CLKSEQ_BYPASS_IR	0x00000008
-#define BM_CLKCTRL_CLKSEQ_BYPASS_PIX	0x00000002
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF	0x00000001
-
-#define HW_CLKCTRL_RESET	(0x00000120)
-
-#define BM_CLKCTRL_RESET_CHIP	0x00000002
-#define BM_CLKCTRL_RESET_DIG	0x00000001
-
-#define HW_CLKCTRL_STATUS	(0x00000130)
-
-#define BP_CLKCTRL_STATUS_CPU_LIMIT	30
-#define BM_CLKCTRL_STATUS_CPU_LIMIT	0xC0000000
-#define BF_CLKCTRL_STATUS_CPU_LIMIT(v) \
-		(((v) << 30) & BM_CLKCTRL_STATUS_CPU_LIMIT)
-
-#define HW_CLKCTRL_VERSION	(0x00000140)
-
-#define BP_CLKCTRL_VERSION_MAJOR	24
-#define BM_CLKCTRL_VERSION_MAJOR	0xFF000000
-#define BF_CLKCTRL_VERSION_MAJOR(v) \
-		(((v) << 24) & BM_CLKCTRL_VERSION_MAJOR)
-#define BP_CLKCTRL_VERSION_MINOR	16
-#define BM_CLKCTRL_VERSION_MINOR	0x00FF0000
-#define BF_CLKCTRL_VERSION_MINOR(v)  \
-		(((v) << 16) & BM_CLKCTRL_VERSION_MINOR)
-#define BP_CLKCTRL_VERSION_STEP	0
-#define BM_CLKCTRL_VERSION_STEP	0x0000FFFF
-#define BF_CLKCTRL_VERSION_STEP(v)  \
-		(((v) << 0) & BM_CLKCTRL_VERSION_STEP)
-
-#endif /* __REGS_CLKCTRL_MX23_H__ */
diff --git a/arch/arm/mach-mxs/regs-clkctrl-mx28.h b/arch/arm/mach-mxs/regs-clkctrl-mx28.h
deleted file mode 100644
index 7d1b061..0000000
--- a/arch/arm/mach-mxs/regs-clkctrl-mx28.h
+++ /dev/null
@@ -1,486 +0,0 @@
-/*
- * Freescale CLKCTRL Register Definitions
- *
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- * This file is created by xml file. Don't Edit it.
- *
- * Xml Revision: 1.48
- * Template revision: 26195
- */
-
-#ifndef __REGS_CLKCTRL_MX28_H__
-#define __REGS_CLKCTRL_MX28_H__
-
-#define HW_CLKCTRL_PLL0CTRL0	(0x00000000)
-#define HW_CLKCTRL_PLL0CTRL0_SET	(0x00000004)
-#define HW_CLKCTRL_PLL0CTRL0_CLR	(0x00000008)
-#define HW_CLKCTRL_PLL0CTRL0_TOG	(0x0000000c)
-
-#define BP_CLKCTRL_PLL0CTRL0_LFR_SEL	28
-#define BM_CLKCTRL_PLL0CTRL0_LFR_SEL	0x30000000
-#define BF_CLKCTRL_PLL0CTRL0_LFR_SEL(v)  \
-		(((v) << 28) & BM_CLKCTRL_PLL0CTRL0_LFR_SEL)
-#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLL0CTRL0_CP_SEL	24
-#define BM_CLKCTRL_PLL0CTRL0_CP_SEL	0x03000000
-#define BF_CLKCTRL_PLL0CTRL0_CP_SEL(v)  \
-		(((v) << 24) & BM_CLKCTRL_PLL0CTRL0_CP_SEL)
-#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLL0CTRL0_DIV_SEL	20
-#define BM_CLKCTRL_PLL0CTRL0_DIV_SEL	0x00300000
-#define BF_CLKCTRL_PLL0CTRL0_DIV_SEL(v)  \
-		(((v) << 20) & BM_CLKCTRL_PLL0CTRL0_DIV_SEL)
-#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWER     0x1
-#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWEST    0x2
-#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__UNDEFINED 0x3
-#define BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS	0x00040000
-#define BM_CLKCTRL_PLL0CTRL0_POWER	0x00020000
-
-#define HW_CLKCTRL_PLL0CTRL1	(0x00000010)
-
-#define BM_CLKCTRL_PLL0CTRL1_LOCK	0x80000000
-#define BM_CLKCTRL_PLL0CTRL1_FORCE_LOCK	0x40000000
-#define BP_CLKCTRL_PLL0CTRL1_LOCK_COUNT	0
-#define BM_CLKCTRL_PLL0CTRL1_LOCK_COUNT	0x0000FFFF
-#define BF_CLKCTRL_PLL0CTRL1_LOCK_COUNT(v)  \
-		(((v) << 0) & BM_CLKCTRL_PLL0CTRL1_LOCK_COUNT)
-
-#define HW_CLKCTRL_PLL1CTRL0	(0x00000020)
-#define HW_CLKCTRL_PLL1CTRL0_SET	(0x00000024)
-#define HW_CLKCTRL_PLL1CTRL0_CLR	(0x00000028)
-#define HW_CLKCTRL_PLL1CTRL0_TOG	(0x0000002c)
-
-#define BM_CLKCTRL_PLL1CTRL0_CLKGATEEMI	0x80000000
-#define BP_CLKCTRL_PLL1CTRL0_LFR_SEL	28
-#define BM_CLKCTRL_PLL1CTRL0_LFR_SEL	0x30000000
-#define BF_CLKCTRL_PLL1CTRL0_LFR_SEL(v)  \
-		(((v) << 28) & BM_CLKCTRL_PLL1CTRL0_LFR_SEL)
-#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLL1CTRL0_CP_SEL	24
-#define BM_CLKCTRL_PLL1CTRL0_CP_SEL	0x03000000
-#define BF_CLKCTRL_PLL1CTRL0_CP_SEL(v)  \
-		(((v) << 24) & BM_CLKCTRL_PLL1CTRL0_CP_SEL)
-#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__TIMES_2   0x1
-#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__TIMES_05  0x2
-#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__UNDEFINED 0x3
-#define BP_CLKCTRL_PLL1CTRL0_DIV_SEL	20
-#define BM_CLKCTRL_PLL1CTRL0_DIV_SEL	0x00300000
-#define BF_CLKCTRL_PLL1CTRL0_DIV_SEL(v)  \
-		(((v) << 20) & BM_CLKCTRL_PLL1CTRL0_DIV_SEL)
-#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__DEFAULT   0x0
-#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWER     0x1
-#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWEST    0x2
-#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__UNDEFINED 0x3
-#define BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS	0x00040000
-#define BM_CLKCTRL_PLL1CTRL0_POWER	0x00020000
-
-#define HW_CLKCTRL_PLL1CTRL1	(0x00000030)
-
-#define BM_CLKCTRL_PLL1CTRL1_LOCK	0x80000000
-#define BM_CLKCTRL_PLL1CTRL1_FORCE_LOCK	0x40000000
-#define BP_CLKCTRL_PLL1CTRL1_LOCK_COUNT	0
-#define BM_CLKCTRL_PLL1CTRL1_LOCK_COUNT	0x0000FFFF
-#define BF_CLKCTRL_PLL1CTRL1_LOCK_COUNT(v)  \
-		(((v) << 0) & BM_CLKCTRL_PLL1CTRL1_LOCK_COUNT)
-
-#define HW_CLKCTRL_PLL2CTRL0	(0x00000040)
-#define HW_CLKCTRL_PLL2CTRL0_SET	(0x00000044)
-#define HW_CLKCTRL_PLL2CTRL0_CLR	(0x00000048)
-#define HW_CLKCTRL_PLL2CTRL0_TOG	(0x0000004c)
-
-#define BM_CLKCTRL_PLL2CTRL0_CLKGATE	0x80000000
-#define BP_CLKCTRL_PLL2CTRL0_LFR_SEL	28
-#define BM_CLKCTRL_PLL2CTRL0_LFR_SEL	0x30000000
-#define BF_CLKCTRL_PLL2CTRL0_LFR_SEL(v)  \
-		(((v) << 28) & BM_CLKCTRL_PLL2CTRL0_LFR_SEL)
-#define BM_CLKCTRL_PLL2CTRL0_HOLD_RING_OFF_B	0x04000000
-#define BP_CLKCTRL_PLL2CTRL0_CP_SEL	24
-#define BM_CLKCTRL_PLL2CTRL0_CP_SEL	0x03000000
-#define BF_CLKCTRL_PLL2CTRL0_CP_SEL(v)  \
-		(((v) << 24) & BM_CLKCTRL_PLL2CTRL0_CP_SEL)
-#define BM_CLKCTRL_PLL2CTRL0_POWER	0x00800000
-
-#define HW_CLKCTRL_CPU	(0x00000050)
-#define HW_CLKCTRL_CPU_SET	(0x00000054)
-#define HW_CLKCTRL_CPU_CLR	(0x00000058)
-#define HW_CLKCTRL_CPU_TOG	(0x0000005c)
-
-#define BM_CLKCTRL_CPU_BUSY_REF_XTAL	0x20000000
-#define BM_CLKCTRL_CPU_BUSY_REF_CPU	0x10000000
-#define BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN	0x04000000
-#define BP_CLKCTRL_CPU_DIV_XTAL	16
-#define BM_CLKCTRL_CPU_DIV_XTAL	0x03FF0000
-#define BF_CLKCTRL_CPU_DIV_XTAL(v)  \
-		(((v) << 16) & BM_CLKCTRL_CPU_DIV_XTAL)
-#define BM_CLKCTRL_CPU_INTERRUPT_WAIT	0x00001000
-#define BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN	0x00000400
-#define BP_CLKCTRL_CPU_DIV_CPU	0
-#define BM_CLKCTRL_CPU_DIV_CPU	0x0000003F
-#define BF_CLKCTRL_CPU_DIV_CPU(v)  \
-		(((v) << 0) & BM_CLKCTRL_CPU_DIV_CPU)
-
-#define HW_CLKCTRL_HBUS	(0x00000060)
-#define HW_CLKCTRL_HBUS_SET	(0x00000064)
-#define HW_CLKCTRL_HBUS_CLR	(0x00000068)
-#define HW_CLKCTRL_HBUS_TOG	(0x0000006c)
-
-#define BM_CLKCTRL_HBUS_ASM_BUSY	0x80000000
-#define BM_CLKCTRL_HBUS_DCP_AS_ENABLE	0x40000000
-#define BM_CLKCTRL_HBUS_PXP_AS_ENABLE	0x20000000
-#define BM_CLKCTRL_HBUS_ASM_EMIPORT_AS_ENABLE	0x08000000
-#define BM_CLKCTRL_HBUS_APBHDMA_AS_ENABLE	0x04000000
-#define BM_CLKCTRL_HBUS_APBXDMA_AS_ENABLE	0x02000000
-#define BM_CLKCTRL_HBUS_TRAFFIC_JAM_AS_ENABLE	0x01000000
-#define BM_CLKCTRL_HBUS_TRAFFIC_AS_ENABLE	0x00800000
-#define BM_CLKCTRL_HBUS_CPU_DATA_AS_ENABLE	0x00400000
-#define BM_CLKCTRL_HBUS_CPU_INSTR_AS_ENABLE	0x00200000
-#define BM_CLKCTRL_HBUS_ASM_ENABLE	0x00100000
-#define BM_CLKCTRL_HBUS_AUTO_CLEAR_DIV_ENABLE	0x00080000
-#define BP_CLKCTRL_HBUS_SLOW_DIV	16
-#define BM_CLKCTRL_HBUS_SLOW_DIV	0x00070000
-#define BF_CLKCTRL_HBUS_SLOW_DIV(v)  \
-		(((v) << 16) & BM_CLKCTRL_HBUS_SLOW_DIV)
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY1  0x0
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY2  0x1
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY4  0x2
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY8  0x3
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY16 0x4
-#define BV_CLKCTRL_HBUS_SLOW_DIV__BY32 0x5
-#define BM_CLKCTRL_HBUS_DIV_FRAC_EN	0x00000020
-#define BP_CLKCTRL_HBUS_DIV	0
-#define BM_CLKCTRL_HBUS_DIV	0x0000001F
-#define BF_CLKCTRL_HBUS_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_HBUS_DIV)
-
-#define HW_CLKCTRL_XBUS	(0x00000070)
-
-#define BM_CLKCTRL_XBUS_BUSY	0x80000000
-#define BM_CLKCTRL_XBUS_AUTO_CLEAR_DIV_ENABLE	0x00000800
-#define BM_CLKCTRL_XBUS_DIV_FRAC_EN	0x00000400
-#define BP_CLKCTRL_XBUS_DIV	0
-#define BM_CLKCTRL_XBUS_DIV	0x000003FF
-#define BF_CLKCTRL_XBUS_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_XBUS_DIV)
-
-#define HW_CLKCTRL_XTAL	(0x00000080)
-#define HW_CLKCTRL_XTAL_SET	(0x00000084)
-#define HW_CLKCTRL_XTAL_CLR	(0x00000088)
-#define HW_CLKCTRL_XTAL_TOG	(0x0000008c)
-
-#define BP_CLKCTRL_XTAL_UART_CLK_GATE	31
-#define BM_CLKCTRL_XTAL_UART_CLK_GATE	0x80000000
-#define BP_CLKCTRL_XTAL_PWM_CLK24M_GATE	29
-#define BM_CLKCTRL_XTAL_PWM_CLK24M_GATE	0x20000000
-#define BP_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	26
-#define BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	0x04000000
-#define BP_CLKCTRL_XTAL_DIV_UART	0
-#define BM_CLKCTRL_XTAL_DIV_UART	0x00000003
-#define BF_CLKCTRL_XTAL_DIV_UART(v)  \
-		(((v) << 0) & BM_CLKCTRL_XTAL_DIV_UART)
-
-#define HW_CLKCTRL_SSP0	(0x00000090)
-
-#define BP_CLKCTRL_SSP0_CLKGATE	31
-#define BM_CLKCTRL_SSP0_CLKGATE	0x80000000
-#define BM_CLKCTRL_SSP0_BUSY	0x20000000
-#define BM_CLKCTRL_SSP0_DIV_FRAC_EN	0x00000200
-#define BP_CLKCTRL_SSP0_DIV	0
-#define BM_CLKCTRL_SSP0_DIV	0x000001FF
-#define BF_CLKCTRL_SSP0_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SSP0_DIV)
-
-#define HW_CLKCTRL_SSP1	(0x000000a0)
-
-#define BP_CLKCTRL_SSP1_CLKGATE	31
-#define BM_CLKCTRL_SSP1_CLKGATE	0x80000000
-#define BM_CLKCTRL_SSP1_BUSY	0x20000000
-#define BM_CLKCTRL_SSP1_DIV_FRAC_EN	0x00000200
-#define BP_CLKCTRL_SSP1_DIV	0
-#define BM_CLKCTRL_SSP1_DIV	0x000001FF
-#define BF_CLKCTRL_SSP1_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SSP1_DIV)
-
-#define HW_CLKCTRL_SSP2	(0x000000b0)
-
-#define BP_CLKCTRL_SSP2_CLKGATE	31
-#define BM_CLKCTRL_SSP2_CLKGATE	0x80000000
-#define BM_CLKCTRL_SSP2_BUSY	0x20000000
-#define BM_CLKCTRL_SSP2_DIV_FRAC_EN	0x00000200
-#define BP_CLKCTRL_SSP2_DIV	0
-#define BM_CLKCTRL_SSP2_DIV	0x000001FF
-#define BF_CLKCTRL_SSP2_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SSP2_DIV)
-
-#define HW_CLKCTRL_SSP3	(0x000000c0)
-
-#define BP_CLKCTRL_SSP3_CLKGATE	31
-#define BM_CLKCTRL_SSP3_CLKGATE	0x80000000
-#define BM_CLKCTRL_SSP3_BUSY	0x20000000
-#define BM_CLKCTRL_SSP3_DIV_FRAC_EN	0x00000200
-#define BP_CLKCTRL_SSP3_DIV	0
-#define BM_CLKCTRL_SSP3_DIV	0x000001FF
-#define BF_CLKCTRL_SSP3_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SSP3_DIV)
-
-#define HW_CLKCTRL_GPMI	(0x000000d0)
-
-#define BP_CLKCTRL_GPMI_CLKGATE	31
-#define BM_CLKCTRL_GPMI_CLKGATE	0x80000000
-#define BM_CLKCTRL_GPMI_BUSY	0x20000000
-#define BM_CLKCTRL_GPMI_DIV_FRAC_EN	0x00000400
-#define BP_CLKCTRL_GPMI_DIV	0
-#define BM_CLKCTRL_GPMI_DIV	0x000003FF
-#define BF_CLKCTRL_GPMI_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_GPMI_DIV)
-
-#define HW_CLKCTRL_SPDIF	(0x000000e0)
-
-#define BP_CLKCTRL_SPDIF_CLKGATE	31
-#define BM_CLKCTRL_SPDIF_CLKGATE	0x80000000
-
-#define HW_CLKCTRL_EMI	(0x000000f0)
-
-#define BP_CLKCTRL_EMI_CLKGATE	31
-#define BM_CLKCTRL_EMI_CLKGATE	0x80000000
-#define BM_CLKCTRL_EMI_SYNC_MODE_EN	0x40000000
-#define BM_CLKCTRL_EMI_BUSY_REF_XTAL	0x20000000
-#define BM_CLKCTRL_EMI_BUSY_REF_EMI	0x10000000
-#define BM_CLKCTRL_EMI_BUSY_REF_CPU	0x08000000
-#define BM_CLKCTRL_EMI_BUSY_SYNC_MODE	0x04000000
-#define BM_CLKCTRL_EMI_BUSY_DCC_RESYNC	0x00020000
-#define BM_CLKCTRL_EMI_DCC_RESYNC_ENABLE	0x00010000
-#define BP_CLKCTRL_EMI_DIV_XTAL	8
-#define BM_CLKCTRL_EMI_DIV_XTAL	0x00000F00
-#define BF_CLKCTRL_EMI_DIV_XTAL(v)  \
-		(((v) << 8) & BM_CLKCTRL_EMI_DIV_XTAL)
-#define BP_CLKCTRL_EMI_DIV_EMI	0
-#define BM_CLKCTRL_EMI_DIV_EMI	0x0000003F
-#define BF_CLKCTRL_EMI_DIV_EMI(v)  \
-		(((v) << 0) & BM_CLKCTRL_EMI_DIV_EMI)
-
-#define HW_CLKCTRL_SAIF0	(0x00000100)
-
-#define BP_CLKCTRL_SAIF0_CLKGATE	31
-#define BM_CLKCTRL_SAIF0_CLKGATE	0x80000000
-#define BM_CLKCTRL_SAIF0_BUSY	0x20000000
-#define BM_CLKCTRL_SAIF0_DIV_FRAC_EN	0x00010000
-#define BP_CLKCTRL_SAIF0_DIV	0
-#define BM_CLKCTRL_SAIF0_DIV	0x0000FFFF
-#define BF_CLKCTRL_SAIF0_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SAIF0_DIV)
-
-#define HW_CLKCTRL_SAIF1	(0x00000110)
-
-#define BP_CLKCTRL_SAIF1_CLKGATE	31
-#define BM_CLKCTRL_SAIF1_CLKGATE	0x80000000
-#define BM_CLKCTRL_SAIF1_BUSY	0x20000000
-#define BM_CLKCTRL_SAIF1_DIV_FRAC_EN	0x00010000
-#define BP_CLKCTRL_SAIF1_DIV	0
-#define BM_CLKCTRL_SAIF1_DIV	0x0000FFFF
-#define BF_CLKCTRL_SAIF1_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_SAIF1_DIV)
-
-#define HW_CLKCTRL_DIS_LCDIF	(0x00000120)
-
-#define BP_CLKCTRL_DIS_LCDIF_CLKGATE	31
-#define BM_CLKCTRL_DIS_LCDIF_CLKGATE	0x80000000
-#define BM_CLKCTRL_DIS_LCDIF_BUSY	0x20000000
-#define BM_CLKCTRL_DIS_LCDIF_DIV_FRAC_EN	0x00002000
-#define BP_CLKCTRL_DIS_LCDIF_DIV	0
-#define BM_CLKCTRL_DIS_LCDIF_DIV	0x00001FFF
-#define BF_CLKCTRL_DIS_LCDIF_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_DIS_LCDIF_DIV)
-
-#define HW_CLKCTRL_ETM	(0x00000130)
-
-#define BM_CLKCTRL_ETM_CLKGATE	0x80000000
-#define BM_CLKCTRL_ETM_BUSY	0x20000000
-#define BM_CLKCTRL_ETM_DIV_FRAC_EN	0x00000080
-#define BP_CLKCTRL_ETM_DIV	0
-#define BM_CLKCTRL_ETM_DIV	0x0000007F
-#define BF_CLKCTRL_ETM_DIV(v)  \
-		(((v) << 0) & BM_CLKCTRL_ETM_DIV)
-
-#define HW_CLKCTRL_ENET	(0x00000140)
-
-#define BM_CLKCTRL_ENET_SLEEP	0x80000000
-#define BP_CLKCTRL_ENET_DISABLE	30
-#define BM_CLKCTRL_ENET_DISABLE	0x40000000
-#define BM_CLKCTRL_ENET_STATUS	0x20000000
-#define BM_CLKCTRL_ENET_BUSY_TIME	0x08000000
-#define BP_CLKCTRL_ENET_DIV_TIME	21
-#define BM_CLKCTRL_ENET_DIV_TIME	0x07E00000
-#define BF_CLKCTRL_ENET_DIV_TIME(v)  \
-		(((v) << 21) & BM_CLKCTRL_ENET_DIV_TIME)
-#define BM_CLKCTRL_ENET_BUSY	0x08000000
-#define BP_CLKCTRL_ENET_DIV	21
-#define BM_CLKCTRL_ENET_DIV	0x07E00000
-#define BF_CLKCTRL_ENET_DIV(v)  \
-		(((v) << 21) & BM_CLKCTRL_ENET_DIV)
-#define BP_CLKCTRL_ENET_TIME_SEL	19
-#define BM_CLKCTRL_ENET_TIME_SEL	0x00180000
-#define BF_CLKCTRL_ENET_TIME_SEL(v)  \
-		(((v) << 19) & BM_CLKCTRL_ENET_TIME_SEL)
-#define BV_CLKCTRL_ENET_TIME_SEL__XTAL      0x0
-#define BV_CLKCTRL_ENET_TIME_SEL__PLL       0x1
-#define BV_CLKCTRL_ENET_TIME_SEL__RMII_CLK  0x2
-#define BV_CLKCTRL_ENET_TIME_SEL__UNDEFINED 0x3
-#define BM_CLKCTRL_ENET_CLK_OUT_EN	0x00040000
-#define BM_CLKCTRL_ENET_RESET_BY_SW_CHIP	0x00020000
-#define BM_CLKCTRL_ENET_RESET_BY_SW	0x00010000
-
-#define HW_CLKCTRL_HSADC	(0x00000150)
-
-#define BM_CLKCTRL_HSADC_RESETB	0x40000000
-#define BP_CLKCTRL_HSADC_FREQDIV	28
-#define BM_CLKCTRL_HSADC_FREQDIV	0x30000000
-#define BF_CLKCTRL_HSADC_FREQDIV(v)  \
-		(((v) << 28) & BM_CLKCTRL_HSADC_FREQDIV)
-
-#define HW_CLKCTRL_FLEXCAN	(0x00000160)
-
-#define BP_CLKCTRL_FLEXCAN_STOP_CAN0	30
-#define BM_CLKCTRL_FLEXCAN_STOP_CAN0	0x40000000
-#define BM_CLKCTRL_FLEXCAN_CAN0_STATUS	0x20000000
-#define BP_CLKCTRL_FLEXCAN_STOP_CAN1	28
-#define BM_CLKCTRL_FLEXCAN_STOP_CAN1	0x10000000
-#define BM_CLKCTRL_FLEXCAN_CAN1_STATUS	0x08000000
-
-#define HW_CLKCTRL_FRAC0	(0x000001b0)
-#define HW_CLKCTRL_FRAC0_SET	(0x000001b4)
-#define HW_CLKCTRL_FRAC0_CLR	(0x000001b8)
-#define HW_CLKCTRL_FRAC0_TOG	(0x000001bc)
-
-#define BP_CLKCTRL_FRAC0_CLKGATEIO0	31
-#define BM_CLKCTRL_FRAC0_CLKGATEIO0	0x80000000
-#define BM_CLKCTRL_FRAC0_IO0_STABLE	0x40000000
-#define BP_CLKCTRL_FRAC0_IO0FRAC	24
-#define BM_CLKCTRL_FRAC0_IO0FRAC	0x3F000000
-#define BF_CLKCTRL_FRAC0_IO0FRAC(v)  \
-		(((v) << 24) & BM_CLKCTRL_FRAC0_IO0FRAC)
-#define BP_CLKCTRL_FRAC0_CLKGATEIO1	23
-#define BM_CLKCTRL_FRAC0_CLKGATEIO1	0x00800000
-#define BM_CLKCTRL_FRAC0_IO1_STABLE	0x00400000
-#define BP_CLKCTRL_FRAC0_IO1FRAC	16
-#define BM_CLKCTRL_FRAC0_IO1FRAC	0x003F0000
-#define BF_CLKCTRL_FRAC0_IO1FRAC(v)  \
-		(((v) << 16) & BM_CLKCTRL_FRAC0_IO1FRAC)
-#define BP_CLKCTRL_FRAC0_CLKGATEEMI	15
-#define BM_CLKCTRL_FRAC0_CLKGATEEMI	0x00008000
-#define BM_CLKCTRL_FRAC0_EMI_STABLE	0x00004000
-#define BP_CLKCTRL_FRAC0_EMIFRAC	8
-#define BM_CLKCTRL_FRAC0_EMIFRAC	0x00003F00
-#define BF_CLKCTRL_FRAC0_EMIFRAC(v)  \
-		(((v) << 8) & BM_CLKCTRL_FRAC0_EMIFRAC)
-#define BP_CLKCTRL_FRAC0_CLKGATECPU	7
-#define BM_CLKCTRL_FRAC0_CLKGATECPU	0x00000080
-#define BM_CLKCTRL_FRAC0_CPU_STABLE	0x00000040
-#define BP_CLKCTRL_FRAC0_CPUFRAC	0
-#define BM_CLKCTRL_FRAC0_CPUFRAC	0x0000003F
-#define BF_CLKCTRL_FRAC0_CPUFRAC(v)  \
-		(((v) << 0) & BM_CLKCTRL_FRAC0_CPUFRAC)
-
-#define HW_CLKCTRL_FRAC1	(0x000001c0)
-#define HW_CLKCTRL_FRAC1_SET	(0x000001c4)
-#define HW_CLKCTRL_FRAC1_CLR	(0x000001c8)
-#define HW_CLKCTRL_FRAC1_TOG	(0x000001cc)
-
-#define BP_CLKCTRL_FRAC1_CLKGATEGPMI	23
-#define BM_CLKCTRL_FRAC1_CLKGATEGPMI	0x00800000
-#define BM_CLKCTRL_FRAC1_GPMI_STABLE	0x00400000
-#define BP_CLKCTRL_FRAC1_GPMIFRAC	16
-#define BM_CLKCTRL_FRAC1_GPMIFRAC	0x003F0000
-#define BF_CLKCTRL_FRAC1_GPMIFRAC(v)  \
-		(((v) << 16) & BM_CLKCTRL_FRAC1_GPMIFRAC)
-#define BP_CLKCTRL_FRAC1_CLKGATEHSADC	15
-#define BM_CLKCTRL_FRAC1_CLKGATEHSADC	0x00008000
-#define BM_CLKCTRL_FRAC1_HSADC_STABLE	0x00004000
-#define BP_CLKCTRL_FRAC1_HSADCFRAC	8
-#define BM_CLKCTRL_FRAC1_HSADCFRAC	0x00003F00
-#define BF_CLKCTRL_FRAC1_HSADCFRAC(v)  \
-		(((v) << 8) & BM_CLKCTRL_FRAC1_HSADCFRAC)
-#define BP_CLKCTRL_FRAC1_CLKGATEPIX	7
-#define BM_CLKCTRL_FRAC1_CLKGATEPIX	0x00000080
-#define BM_CLKCTRL_FRAC1_PIX_STABLE	0x00000040
-#define BP_CLKCTRL_FRAC1_PIXFRAC	0
-#define BM_CLKCTRL_FRAC1_PIXFRAC	0x0000003F
-#define BF_CLKCTRL_FRAC1_PIXFRAC(v)  \
-		(((v) << 0) & BM_CLKCTRL_FRAC1_PIXFRAC)
-
-#define HW_CLKCTRL_CLKSEQ	(0x000001d0)
-#define HW_CLKCTRL_CLKSEQ_SET	(0x000001d4)
-#define HW_CLKCTRL_CLKSEQ_CLR	(0x000001d8)
-#define HW_CLKCTRL_CLKSEQ_TOG	(0x000001dc)
-
-#define BM_CLKCTRL_CLKSEQ_BYPASS_CPU	0x00040000
-#define BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF	0x00004000
-#define BV_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF__BYPASS 0x1
-#define BV_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF__PFD    0x0
-#define BM_CLKCTRL_CLKSEQ_BYPASS_ETM	0x00000100
-#define BM_CLKCTRL_CLKSEQ_BYPASS_EMI	0x00000080
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP3	0x00000040
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP2	0x00000020
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP1	0x00000010
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP0	0x00000008
-#define BM_CLKCTRL_CLKSEQ_BYPASS_GPMI	0x00000004
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF1	0x00000002
-#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF0	0x00000001
-
-#define HW_CLKCTRL_RESET	(0x000001e0)
-
-#define BM_CLKCTRL_RESET_WDOG_POR_DISABLE	0x00000020
-#define BM_CLKCTRL_RESET_EXTERNAL_RESET_ENABLE	0x00000010
-#define BM_CLKCTRL_RESET_THERMAL_RESET_ENABLE	0x00000008
-#define BM_CLKCTRL_RESET_THERMAL_RESET_DEFAULT	0x00000004
-#define BM_CLKCTRL_RESET_CHIP	0x00000002
-#define BM_CLKCTRL_RESET_DIG	0x00000001
-
-#define HW_CLKCTRL_STATUS	(0x000001f0)
-
-#define BP_CLKCTRL_STATUS_CPU_LIMIT	30
-#define BM_CLKCTRL_STATUS_CPU_LIMIT	0xC0000000
-#define BF_CLKCTRL_STATUS_CPU_LIMIT(v) \
-		(((v) << 30) & BM_CLKCTRL_STATUS_CPU_LIMIT)
-
-#define HW_CLKCTRL_VERSION	(0x00000200)
-
-#define BP_CLKCTRL_VERSION_MAJOR	24
-#define BM_CLKCTRL_VERSION_MAJOR	0xFF000000
-#define BF_CLKCTRL_VERSION_MAJOR(v) \
-		(((v) << 24) & BM_CLKCTRL_VERSION_MAJOR)
-#define BP_CLKCTRL_VERSION_MINOR	16
-#define BM_CLKCTRL_VERSION_MINOR	0x00FF0000
-#define BF_CLKCTRL_VERSION_MINOR(v)  \
-		(((v) << 16) & BM_CLKCTRL_VERSION_MINOR)
-#define BP_CLKCTRL_VERSION_STEP	0
-#define BM_CLKCTRL_VERSION_STEP	0x0000FFFF
-#define BF_CLKCTRL_VERSION_STEP(v)  \
-		(((v) << 0) & BM_CLKCTRL_VERSION_STEP)
-
-#endif /* __REGS_CLKCTRL_MX28_H__ */
diff --git a/arch/arm/mach-mxs/system.c b/arch/arm/mach-mxs/system.c
index 80ac1fc..30042e2 100644
--- a/arch/arm/mach-mxs/system.c
+++ b/arch/arm/mach-mxs/system.c
@@ -37,8 +37,6 @@
 #define MXS_MODULE_CLKGATE		(1 << 30)
 #define MXS_MODULE_SFTRST		(1 << 31)
 
-#define CLKCTRL_TIMEOUT		10	/* 10 ms */
-
 static void __iomem *mxs_clkctrl_reset_addr;
 
 /*
@@ -139,17 +137,3 @@ error:
 	return -ETIMEDOUT;
 }
 EXPORT_SYMBOL(mxs_reset_block);
-
-int mxs_clkctrl_timeout(unsigned int reg_offset, unsigned int mask)
-{
-	unsigned long timeout = jiffies + msecs_to_jiffies(CLKCTRL_TIMEOUT);
-	while (readl_relaxed(MXS_IO_ADDRESS(MXS_CLKCTRL_BASE_ADDR)
-						+ reg_offset) & mask) {
-		if (time_after(jiffies, timeout)) {
-			pr_err("Timeout at CLKCTRL + 0x%x\n", reg_offset);
-			return -ETIMEDOUT;
-		}
-	}
-
-	return 0;
-}
-- 
1.7.0

