From 5cba8e6c65b7e6666cb075c7f40ff544808d0d50 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Mon, 6 Dec 2010 17:13:29 +0800
Subject: [PATCH 6/6] intel_xeon_core_dh89xx_pch: fixed the cgl boot issue (V2)

There is a lock issue in the cgl kernel during the smp init and it make the
kernel can't boot up.

When we enable the lock debug options we get following message:

......
......
[ INFO: inconsistent lock state ]
2.6.34.6-grsec-WR4.0.0.0_cgl #2
---------------------------------
inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-W} usage.
swapper/0 [HC1[1]:SC0[0]:HE0:SE1] takes:
 (&(&p->alloc_lock)->rlock){?.+...}, at: [<ffffffff810a54c2>] cpuset_cpus_allowed_locked+0x22/0xa0
{HARDIRQ-ON-W} state was registered at:
  [<ffffffff81081ebb>] mark_lock+0x16b/0x630
  [<ffffffff81084e28>] __lock_acquire+0x638/0xc80
  [<ffffffff8108550e>] lock_acquire+0x9e/0x150
  [<ffffffff8157744b>] _raw_spin_lock+0x3b/0x70
  [<ffffffff811350a9>] set_task_comm+0x29/0x80
  [<ffffffff8106e4aa>] kthreadd+0x2a/0x120
  [<ffffffff81003e84>] kernel_thread_helper+0x4/0x10
irq event stamp: 10
hardirqs last  enabled at (9): [<ffffffff8100c98c>] mwait_idle+0x6c/0x100
hardirqs last disabled at (10): [<ffffffff81002c09>] save_args+0x69/0x70
softirqs last  enabled at (0): [<ffffffff81046778>] copy_process+0x398/0x14a0
softirqs last disabled at (0): [<(null)>] (null)

other info that might help us debug this:
1 lock held by swapper/0:
 #0:  (rcu_read_lock){.+.+..}, at: [<ffffffff8103e07b>] select_fallback_rq+0x9b/0x180

stack backtrace:
Pid: 0, comm: swapper Not tainted 2.6.34.6-grsec-WR4.0.0.0_cgl #2
Call Trace:
 <IRQ>  [<ffffffff81081cff>] print_usage_bug+0x17f/0x1d0
 [<ffffffff81082169>] mark_lock+0x419/0x630
 [<ffffffff81084e9a>] __lock_acquire+0x6aa/0xc80
 [<ffffffff8108550e>] lock_acquire+0x9e/0x150
 [<ffffffff810a54c2>] ? cpuset_cpus_allowed_locked+0x22/0xa0
 [<ffffffff8157744b>] _raw_spin_lock+0x3b/0x70
 [<ffffffff810a54c2>] ? cpuset_cpus_allowed_locked+0x22/0xa0
 [<ffffffff8107f20e>] ? put_lock_stats+0xe/0x30
 [<ffffffff810a54c2>] cpuset_cpus_allowed_locked+0x22/0xa0
 [<ffffffff8103e0b6>] select_fallback_rq+0xd6/0x180
 [<ffffffff8103e07b>] ? select_fallback_rq+0x9b/0x180
 [<ffffffff8103a61a>] try_to_wake_up+0x34a/0x380
 [<ffffffff8103a680>] wake_up_process+0x10/0x20
 [<ffffffff8104fec2>] wakeup_softirqd+0x82/0x90
 [<ffffffff810505b0>] raise_softirq+0x40/0xd0
 [<ffffffff8105ae13>] run_local_timers+0x13/0x20
 [<ffffffff8105ae58>] update_process_times+0x38/0x70
 [<ffffffff8107d407>] tick_periodic+0x27/0x70
 [<ffffffff8107d46f>] tick_handle_periodic+0x1f/0x90
 [<ffffffff8101cf50>] smp_apic_timer_interrupt+0x80/0x180
 [<ffffffff81003888>] apic_timer_interrupt+0x28/0x30
 <EOI>  [<ffffffff8100c995>] ? mwait_idle+0x75/0x100
 [<ffffffff8100c98c>] ? mwait_idle+0x6c/0x100
 [<ffffffff81001674>] cpu_idle+0x44/0x80
 [<ffffffff81570c46>] start_secondary+0x1c3/0x1c8
lockdep: fixing up alternatives.
......
......

Checking the select_fallback_rq() we found that the cpu_active_mask is
incorrect. There is a interrupt coming here before the kernel set the
correct cpu_active_mask. And the apic_timer_interrupt -> ... ->
wakeup_softirq --> select_fallback_rq -> incorrect cpu_active_mask -->
not a normal state --> lock inconsistent --> kernel hang

So we set the cpu_active_mask in start_secondary for this special
platform.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/x86/kernel/smpboot.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 6a2dcef..0044162 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -349,6 +349,7 @@ notrace static void __cpuinit start_secondary(void *unused)
 	ipi_call_lock();
 	lock_vector_lock();
 	set_cpu_online(smp_processor_id(), true);
+	set_cpu_active(smp_processor_id(), true);
 	unlock_vector_lock();
 	ipi_call_unlock();
 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
-- 
1.6.3.1

