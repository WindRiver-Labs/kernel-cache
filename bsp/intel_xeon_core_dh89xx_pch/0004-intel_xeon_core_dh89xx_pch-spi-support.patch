From d43604cc1163e4b98163e88e5c90dee9a9c81dec Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 21 Jul 2011 11:07:11 +0800
Subject: [PATCH 4/6] intel_xeon_core_dh89xx_pch: spi support

add the spi support of dh89xx chipset

Get it from Intel QAT SDK 0.6.0-95

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/spi/Kconfig  |    7 +
 drivers/spi/Makefile |    1 +
 drivers/spi/pchspi.c | 1435 ++++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/spi/pchspi.h |  244 +++++++++
 4 files changed, 1687 insertions(+), 0 deletions(-)
 create mode 100755 drivers/spi/pchspi.c
 create mode 100755 drivers/spi/pchspi.h

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 04a34e4..a98c69e 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -419,6 +419,13 @@ config SPI_TLE62X0
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_DH89XX
+	tristate "Intel DH89xx SPI driver support"
+	depends on X86 && SPI
+	default y	
+	help
+	  This supports Intel DH89xx SPI drivers.
+
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 33322d3..ce6cca6 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+obj-$(CONFIG_SPI_DH89XX)		+= pchspi.o
 
 # special build for s3c24xx spi driver with fiq support
 spi_s3c24xx_hw-y			:= spi_s3c24xx.o
diff --git a/drivers/spi/pchspi.c b/drivers/spi/pchspi.c
new file mode 100755
index 0000000..4899bea
--- /dev/null
+++ b/drivers/spi/pchspi.c
@@ -0,0 +1,1435 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ *   redistributing this file, you may do so under either license.
+ * 
+ *   GPL LICENSE SUMMARY
+ * 
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ * 
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ * 
+ *   This program is distributed in the hope that it will be useful, but 
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *   General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU General Public License 
+ *   along with this program; if not, write to the Free Software 
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution 
+ *   in the file called LICENSE.GPL.
+ * 
+ *   Contact Information:
+ *   Intel Corporation
+ * 
+ *   BSD LICENSE 
+ * 
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ * 
+ *   Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions 
+ *   are met:
+ * 
+ *     * Redistributions of source code must retain the above copyright 
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright 
+ *       notice, this list of conditions and the following disclaimer in 
+ *       the documentation and/or other materials provided with the 
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its 
+ *       contributors may be used to endorse or promote products derived 
+ *       from this software without specific prior written permission.
+ * 
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * 
+ *  version: DH89xxCC_EMBEDDED.L.0.6.0-95
+ */
+
+/*****************************************************************************
+  @ingroup SPI 
+ 
+  @file pchspi.c
+ 
+  @description
+    This module contains the Serial Peripheral Interface driver code.
+ 
+  <DEFAULT_LICENSE_BEGIN>
+
+  Driver for PCH SPI Controller
+  Copyright(c) 2008 Intel Corporation.
+  
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+*****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>    /* for proc fs */
+#include <asm/uaccess.h>    /* for copy_from_user */
+#include <linux/delay.h>    
+#include <linux/fs.h>         /* for struct file */
+
+
+#include "pchspi.h"
+
+MODULE_AUTHOR("Intel(R) Corporation");
+MODULE_DESCRIPTION("PCH SPI Controller");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION("1.0.0");
+
+/* module global variables */
+static char g_drvname[]="pchspi";
+
+static char g_pf_name[]="pchspi";
+static char g_dbg_print=0;
+
+/* default block size used for read/write ops*/
+#define DEFAULT_BS            (1024*2)
+
+/* Prototypes - Misc. */
+typedef enum {
+    cmd_invalid,
+    cmd_read,
+    cmd_write,
+    cmd_erase
+} pch_spi_pf_cmds_t;
+
+/* proc files system structure */
+typedef struct pch_spi_procfs_struct {
+    struct proc_dir_entry *proc_fs; /* struct holds info about proc fs */
+    pch_spi_pf_cmds_t cur_cmd; /* current command */
+    struct file* file; /* current operation on file */
+    unsigned int cur_addr; /* current flash addr to start rd/wr from */
+    unsigned int end_addr; /* valid max flash addr for rd/wr op */
+    unsigned int bs; /* read bytes at a time, should be equal or less than 3K */
+} pch_spi_procfs_struct_t;
+
+static pch_spi_procfs_struct_t g_pf;
+
+static const char g_pf_help[] = "\
+Usage:\n\
+e.g. help:\n\
+    echo help > /proc/pchspi\n\
+    cat /proc/pchspi\n\
+    dmesg | tail -n 80\n\
+\n\
+e.g. to identify or init spi flash device:\n\
+    echo read id > /proc/pchspi\n\
+    dmesg | tail -n 80\n\
+\n\
+e.g. to erase flash chip <use with CAUTION>:\n\
+    echo erase FLASH > /proc/pchspi\n\
+e.g. to write file contains to flash starting from address 0x0:\n\
+    echo write FLASH > /proc/pchspi\n\
+    cat flash-data.bin > /proc/pchspi\n\
+\n\
+e.g. to write file contains to BIOS or iME or GbE or DATA region on flash:\n\
+    echo write BIOS > /proc/pchspi\n\
+    cat bios.rom > /proc/pchspi\n\
+\n\
+    echo write iME > /proc/pchspi\n\
+    cat me.bin > /proc/pchspi\n\
+\n\
+    echo write GBE > /proc/pchspi\n\
+    cat gbe.rom > /proc/pchspi\n\
+\n\
+    echo write DATA > /proc/pchspi\n\
+    cat platform-data.bin > /proc/pchspi\n\
+\n\
+e.g. read complete flash of size 8 MB:\n\
+    echo seek 0x0 > /proc/pchspi\n\
+    for i in {1..4096}; do echo $i; cat /proc/pchspi >> flash.bin; done\n\
+\n\
+e.g. write contents of file to flash addr 0x3000:\n\
+    echo seek 0x3000 > /proc/pchspi\n\
+    echo w > /proc/pchspi \n\
+    cat flash.bin > /proc/pchspi\n\
+\n\
+e.g. write complete flash of size 8 MB:\n\
+    echo seek 0x0 > /proc/pchspi\n\
+    cat flash.bin > /proc/pchspi\n\
+\n\
+e.g. to print SPI registers:\n\
+    echo p > /proc/pchspi\n\
+    dmesg | tail -n 80\n\
+\n\
+e.g. to read 2048 bytes from flash addr 0x0:\n\
+    echo seek 0x0 > /proc/pchspi\n\
+    echo r > /proc/pchspi\n\
+    cat /proc/pchspi > flash.bin\n\
+\n\
+";
+
+/* Debug Print Statements */
+#define dbg_print(_m) {if (g_dbg_print) { printk _m; } }
+
+/* supported flash opcodes for SST25VF080B flash device */
+static const struct flash_cmd_struct sst25_cmds[OPCODE_LAST_IDX] = {
+/* index                 {opcode, prefix, spi_operation_type}*/
+/*OPCODE_JEDEC_ID_IDX*/  {0x9F, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/*OPCODE_READ_ID_IDX*/   {0xAB, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_WR_STATUS_IDX*/ {0x01, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_WR},
+/*OPCODE_WRITE_IDX*/     {0x02, NO_PREFIX, B_SPI_OPTYPE_WR},
+/*OPCODE_READ_IDX*/      {0x03, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_ERASE_IDX*/     {0x20, NO_PREFIX, B_SPI_OPTYPE_WR},
+/*OPCODE_RD_STATUS_IDX*/ {0x05, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/*OPCODE_CHIP_ERASE_ID*/ {0xC7, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_WR}
+    };
+
+/* supported flash opcodes for M25P64VMF flash device */
+static const struct flash_cmd_struct m25p64_cmds[OPCODE_LAST_IDX] = {
+/* index                 {opcode, prefix, spi_operation_type}*/
+/*OPCODE_JEDEC_ID_IDX*/  {0x9F, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/*OPCODE_READ_ID_IDX*/   {0x9F, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_WR_STATUS_IDX*/ {0x01, 0x06,      B_SPI_OPTYPE_NO_ADDR_WR},
+/*OPCODE_WRITE_IDX*/     {0x02, 0x06,      B_SPI_OPTYPE_WR},
+/*OPCODE_READ_IDX*/      {0x03, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_ERASE_IDX*/     {0xD8, 0x06,      B_SPI_OPTYPE_WR},
+/*OPCODE_RD_STATUS_IDX*/ {0x05, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/* erase time 60-160 Sec */
+/*OPCODE_CHIP_ERASE_IDX*/{0xC7, 0x06,      B_SPI_OPTYPE_NO_ADDR_WR} 
+    };
+
+/* supported flash opcodes for AT25DF321 flash device */
+static const struct flash_cmd_struct at25df321_cmds[OPCODE_LAST_IDX] = {
+/* index                 {opcode, prefix, spi_operation_type}*/
+/*OPCODE_JEDEC_ID_IDX*/  {0x9F, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/*OPCODE_READ_ID_IDX*/   {0x9F, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_WR_STATUS_IDX*/ {0x01, 0x06,      B_SPI_OPTYPE_NO_ADDR_WR},
+/*OPCODE_WRITE_IDX*/     {0x02, 0x06,      B_SPI_OPTYPE_WR},
+/*OPCODE_READ_IDX*/      {0x03, NO_PREFIX, B_SPI_OPTYPE_RD},
+/*OPCODE_ERASE_IDX*/     {0x20, 0x06,      B_SPI_OPTYPE_WR},
+/*OPCODE_RD_STATUS_IDX*/ {0x05, NO_PREFIX, B_SPI_OPTYPE_NO_ADDR_RD},
+/* erase time 60-160 Sec */
+/*OPCODE_CHIP_ERASE_IDX*/{0xC7, 0x06,      B_SPI_OPTYPE_NO_ADDR_WR} 
+    };
+
+/* flash info */
+static struct flash_info_struct g_flash_info[] = {
+/*  {"name"       , mfr , id  , jedec_id,   sz,  erase_sz */
+    {"SST25VF080B", 0xBF, 0x8E, 0x258E, 0x400*0x400, 0x400*4,
+        sst25_cmds},
+    {"M25P64VMF", 0x20, 0x20, 0x2017, (0x400*0x400*0x40)>>0x3, 0x400*0x40,
+        m25p64_cmds},
+    {"M25PX64VP", 0x20, 0x20, 0x7117, (0x400*0x400*0x40)>>0x3, 0x400*0x40,
+        m25p64_cmds},
+    {"AT25DF321", 0x1F, 0x47, 0x4700, (0x400*0x400*0x20)>>0x3, 0x400*0x4,
+        at25df321_cmds}
+};
+
+static struct pch_spi_struct g_spi;
+
+/* macro definition */
+#define spi_readb(_offset) readb(g_spi.spi+(_offset))
+#define spi_readw(_offset) readw(g_spi.spi+(_offset))
+#define spi_readl(_offset) readl(g_spi.spi+(_offset))
+#define spi_writeb(_offset,_val) writeb((_val),g_spi.spi+(_offset))
+#define spi_writew(_offset,_val) writew((_val),g_spi.spi+(_offset))
+#define spi_writel(_offset,_val) writel((_val),g_spi.spi+(_offset))
+
+/* prototypes */
+void Pch_Spi_Procfs_Exit(void);
+int Pch_Spi_Procfs_Init(void);
+
+/*****************************************************************************
+ * Abstract
+ * process flash read command. Input paramter 'flash_addr' is start
+ * of address to read from, 'buf' is input buffer, 'count' read size in bytes.
+ * Side Effects:
+ * Assumptions:
+ * Return Values: number of bytes read
+ *                    zero if nothing to read/return
+ *****************************************************************************/
+STATIC int Pch_Spi_Procfs_Process_Rd_Cmd(const unsigned int flash_addr, u8* buf,
+                                         unsigned int count)
+{
+    unsigned int sz;
+
+    sz = Pch_Spi_Flash_Sz();
+
+    if (g_pf.cur_cmd != cmd_read) {
+        printk(KERN_INFO "%s: error: not a read cmd\n", g_pf_name);
+        return 0;
+    }
+
+    if ((count == 0) || (buf == NULL)) {
+        printk(KERN_INFO "%s: error: invalid param\n", g_pf_name);
+        return 0;
+    }
+
+    dbg_print((KERN_INFO "%s: r: buf: %p addr %x: count %x\n", g_pf_name, 
+        buf, flash_addr, count));
+
+    if (flash_addr >= sz) {
+        dbg_print((KERN_INFO "%s: end of flash\n", g_pf_name));
+        return 0; /* end of flash read */
+    }
+
+    if (count > g_pf.bs) {
+        count = g_pf.bs; /* read this many bytes and no more */
+    }
+
+    if (count >= (sz-flash_addr)) {
+        count = (sz-flash_addr);
+    }
+
+    if (Pch_Spi_Flash_Read( buf, count /*len*/, flash_addr/*addr*/)) {
+        printk(KERN_INFO "%s: flash reading err\n", g_pf_name);
+        return 0; /* error reading flash */
+    }
+
+    dbg_print((KERN_INFO "%s: ret: %x\n", g_pf_name, count));
+    return count;
+}
+
+/*****************************************************************************
+ * Abstract
+ * process flash write command. 'buf' is input buffer, 'buf_len' buffer size 
+ * in bytes.
+ * Side Effects:
+ * writing to flash begins from 'g_pf.cur_addr'
+ * Assumptions:
+ * Return Values: number of bytes written
+ *****************************************************************************/
+STATIC int Pch_Spi_Procfs_Process_Wr_Cmd(u8* buf, int buf_len)
+{
+    int ret=buf_len;
+
+    if (g_pf.cur_cmd != cmd_write) {
+        printk(KERN_INFO "%s: error: not a write cmd\n", g_pf_name);
+        return ret;
+    }
+
+    if (!buf || !buf_len) {
+        return ret;
+    }
+
+    dbg_print((KERN_INFO "%s: w: buf: %p addr %x: count %x\n", 
+        g_pf_name, buf, g_pf.cur_addr, (u32)buf_len));
+
+    if ((u32)buf_len > (g_pf.end_addr - g_pf.cur_addr)) {
+        buf_len = (int)(g_pf.end_addr - g_pf.cur_addr);
+    }
+
+    if (buf_len > 0) {
+        if (Pch_Spi_Flash_Write( buf, buf_len, g_pf.cur_addr/*addr*/)) {
+            printk(KERN_INFO "%s: flash writing err\n", g_pf_name);
+            return -1; /* error writing flash */
+        }
+        g_pf.cur_addr += buf_len;
+    }
+
+    return ret;
+}
+
+/*****************************************************************************
+ * Abstract
+ * proc filesystem read callback function. Input parameter 'page' is data 
+ * buffer (usually 4KB or less) in kernel space, 'off' is start writing at 
+ * offset i.e., (page+offset), 'count' is max size in bytes which can be 
+ * written to 'page', 'eof' is set to 1 when last flash read is complete.
+ * Side Effects:
+ * Assumptions:
+ * Return Values: actual bytes read
+ *****************************************************************************/
+STATIC int Pch_Spi_Procfs_Read(char *page, char **start,
+    off_t off, int count, int *eof, void *data)
+{
+    int ret = 0; /* zero means nothing to return, eof */
+
+    /* always read less than page size */
+    if (off) {
+        *eof = 1;
+        return ret;
+    }
+
+    if (g_pf.cur_cmd == cmd_read) {
+        if (g_pf.cur_addr < g_pf.end_addr) {
+            page += off;
+            ret = Pch_Spi_Procfs_Process_Rd_Cmd(g_pf.cur_addr,
+                page, count);
+        }
+        else {
+            ret = 0;
+        }
+        
+        /* update flash addr */
+        g_pf.cur_addr += (ret);
+        
+        //*start = (char*)ret;
+        /* mark end of file */
+        *eof = 1;
+        if (!ret) {
+            *eof = 1;
+            g_pf.cur_cmd = cmd_invalid;
+        }
+    }
+    else {
+        /* print help */
+        if (count >= sizeof(g_pf_help)) {
+            memcpy(page, g_pf_help, sizeof(g_pf_help));
+            ret = sizeof(g_pf_help);
+            *eof = 1;
+            g_pf.cur_cmd = cmd_invalid;
+        }
+        else {
+            printk(KERN_INFO "%s: %s", g_pf_name, g_pf_help);
+            /* indicate error */
+            ret = -1; 
+        }
+    }
+
+    return ret;
+}
+
+/*****************************************************************************
+ * Abstract
+ * proc filesystem write callback function. Input parameter 'file' is file 
+ * pointer associated with write operation, 'buf' is user mode buffer, 'count'
+ * is size to write.
+ * Side Effects:
+ * Assumptions:
+ * Return Values: actual bytes written
+ *****************************************************************************/
+STATIC int Pch_Spi_Procfs_Write(struct file *file, const char __user *buf,
+    unsigned long count, void *data)
+{
+    ssize_t ret = (ssize_t)count;
+    char *page;
+    unsigned long val;
+    char ctmp;
+
+    if (!count) {
+        printk(KERN_INFO "%s: too small write "\
+            "count %d\n", g_pf_name, (int)count);
+        return ret;
+    }
+
+    dbg_print((KERN_INFO "file %p buf %p count %d\n", 
+        file, buf, (int)count));
+
+    /* copy data from user space */
+    page = (char *)__get_free_page(GFP_KERNEL);
+    if (!page) {
+        goto out;
+    }
+    
+    count = (count > PAGE_SIZE)? PAGE_SIZE : count;
+    if (copy_from_user(page, buf, count)) {
+        goto out;
+    }
+
+    if ((g_pf.file == NULL) && (g_pf.cur_cmd == cmd_write)) {
+        file->private_data = (void*)1;
+        /* first block flash write */
+        g_pf.file = file;
+        ret = Pch_Spi_Procfs_Process_Wr_Cmd(page, count);
+        goto out;
+    }
+    else if ((g_pf.file == file) && (g_pf.cur_cmd == cmd_write)) {
+        if (file->private_data) {
+            /* subsequent block flash write */
+            ret = Pch_Spi_Procfs_Process_Wr_Cmd(page, count);
+            goto out;
+        }
+    }
+    
+    /* new operation */
+    g_pf.cur_cmd = cmd_invalid;
+    g_pf.file = NULL;
+
+    ret = (ssize_t) count;
+
+    if (sscanf(page, "help%c", &ctmp) == 1) { /* help: print help */
+        printk(KERN_INFO "%s: %s", g_pf_name, g_pf_help);
+    }
+    /* read id: read flash id */
+    else if (sscanf(page, "read id%c", &ctmp) == 1) { 
+        printk(KERN_INFO "%s: cmd: read flash jedec id\n", g_pf_name);
+        Pch_Spi_Flash_Init();
+    }
+    else if (sscanf(page, "read FLASH%c", &ctmp) == 1) {
+        /* read complete flash starting from 0x0 */
+        g_pf.cur_cmd = cmd_read;
+        g_pf.cur_addr = 0x0;
+        g_pf.end_addr = Pch_Spi_Flash_Sz();
+        printk(KERN_INFO "%s: Flash size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: read flash from addr 0x%X to 0x%X\n", 
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "write FLASH%c", &ctmp) == 1) { 
+        /* write complete flash starting from 0x0 */
+        g_pf.cur_cmd = cmd_write;
+        g_pf.cur_addr = 0x0;
+        g_pf.end_addr = Pch_Spi_Flash_Sz();
+        printk(KERN_INFO "%s: Flash size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: write flash from addr 0x%X to 0x%X\n",
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "erase FLASH%c", &ctmp) == 1) { 
+        /* erase flash chip */
+        printk(KERN_INFO "%s: cmd: erase flash chip\n", g_pf_name);
+        if (!Pch_Spi_Flash_Erase_Chip()) {
+            printk(KERN_INFO "%s: chip erase complete\n", g_pf_name);
+        }
+        else {
+            printk(KERN_INFO "%s: erase flash chip failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (sscanf(page, "read BIOS%c", &ctmp) == 1) {
+        /* read BIOS region */
+        g_pf.cur_cmd = cmd_read;
+        g_pf.cur_addr = \
+                      Pch_Spi_Region_Get_Address(REGION_BIOS, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_BIOS, END_OF_REGION);
+
+        printk(KERN_INFO "%s: BIOS region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: read BIOS region from addr 0x%X to 0x%X\n", 
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "write BIOS%c", &ctmp) == 1) { 
+        /* write to BIOS region */
+        g_pf.cur_cmd = cmd_write;
+        g_pf.cur_addr = \
+                      Pch_Spi_Region_Get_Address(REGION_BIOS, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_BIOS, END_OF_REGION);
+
+        printk(KERN_INFO "%s: BIOS region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: write BIOS region from addr 0x%X to 0x%X\n",
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "erase BIOS%c", &ctmp) == 1) { /* erase flash chip */
+        /* erase BIOS region */
+        printk(KERN_INFO "%s: cmd: erase BIOS region\n", g_pf_name);
+        
+        if (!Pch_Spi_Region_Erase(REGION_BIOS)) {
+            printk(KERN_INFO "%s: erase BIOS region complete\n", g_pf_name);
+        }
+        else {
+            printk(KERN_INFO "%s: erase BIOS region failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (sscanf(page, "read iME%c", &ctmp) == 1) {
+        /* read iME region */
+        g_pf.cur_cmd = cmd_read;
+        g_pf.cur_addr = Pch_Spi_Region_Get_Address(REGION_IME, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_IME, END_OF_REGION);
+
+        printk(KERN_INFO "%s: iME region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: read iME region from addr 0x%X to 0x%X\n", 
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "write iME%c", &ctmp) == 1) { 
+        /* write to iME region */
+        g_pf.cur_cmd = cmd_write;
+        g_pf.cur_addr = Pch_Spi_Region_Get_Address(REGION_IME, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_IME, END_OF_REGION);
+
+        printk(KERN_INFO "%s: iME region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: write iME region from addr 0x%X to 0x%X\n",
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "erase iME%c", &ctmp) == 1) { /* erase flash chip */
+        /* erase BIOS region */
+        printk(KERN_INFO "%s: cmd: erase iME region\n", g_pf_name);
+        
+        if (!Pch_Spi_Region_Erase(REGION_IME)) {
+            printk(KERN_INFO "%s: erase iME region complete\n", g_pf_name);
+        }
+        else {
+            printk(KERN_INFO "%s: erase iME region failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (sscanf(page, "read GBE%c", &ctmp) == 1) {
+        /* read GbE region */
+        g_pf.cur_cmd = cmd_read;
+        g_pf.cur_addr = Pch_Spi_Region_Get_Address(REGION_GBE, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_GBE, END_OF_REGION);
+
+        printk(KERN_INFO "%s: GBE region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: read GBE region from addr 0x%X to 0x%X\n", 
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "write GBE%c", &ctmp) == 1) { 
+        /* write to GbE region */
+        g_pf.cur_cmd = cmd_write;
+        g_pf.cur_addr = Pch_Spi_Region_Get_Address(REGION_GBE, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_GBE, END_OF_REGION);
+
+        printk(KERN_INFO "%s: BE region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: write GBE region from addr 0x%X to 0x%X\n",
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "erase GBE%c", &ctmp) == 1) { /* erase flash chip */
+        /* erase GbE region */
+        printk(KERN_INFO "%s: cmd: erase GBE region\n", g_pf_name);
+        
+        if (!Pch_Spi_Region_Erase(REGION_GBE)) {
+            printk(KERN_INFO "%s: erase GBE region complete\n", g_pf_name);
+        }
+        else {
+            printk(KERN_INFO "%s: erase GBE region failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (sscanf(page, "read DATA%c", &ctmp) == 1) {
+        /* read DATA region */
+        g_pf.cur_cmd = cmd_read;
+        g_pf.cur_addr = \
+                      Pch_Spi_Region_Get_Address(REGION_DATA, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_DATA, END_OF_REGION);
+
+        printk(KERN_INFO "%s: DATA region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: read DATA region from addr 0x%X to 0x%X\n", 
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "write DATA%c", &ctmp) == 1) { 
+        /* write to DATA region */
+        g_pf.cur_cmd = cmd_write;
+        g_pf.cur_addr = \
+                      Pch_Spi_Region_Get_Address(REGION_DATA, START_OF_REGION);
+        g_pf.end_addr = Pch_Spi_Region_Get_Address(REGION_DATA, END_OF_REGION);
+
+        printk(KERN_INFO "%s: DATA region size 0x%X\n", g_pf_name, 
+            (g_pf.end_addr-g_pf.cur_addr));
+        printk(KERN_INFO "%s: cmd: write DATA region from addr 0x%X to 0x%X\n",
+            g_pf_name, g_pf.cur_addr, g_pf.end_addr);
+    }
+    else if (sscanf(page, "erase DATA%c", &ctmp) == 1) { /* erase flash chip */
+        /* erase DATA region */
+        printk(KERN_INFO "%s: cmd: erase DATA region\n", g_pf_name);
+        
+        if (!Pch_Spi_Region_Erase(REGION_DATA)) {
+            printk(KERN_INFO "%s: erase DATA region complete\n", g_pf_name);
+        } 
+        else {
+            printk(KERN_INFO "%s: erase DATA region failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (sscanf(page, "seek 0x%lx", &val) == 1) {  /* seek: seek address*/
+        g_pf.cur_addr = (unsigned int) val; /* start reading */
+        printk(KERN_INFO "%s: cmd: seek 0x%lX\n", g_pf_name,
+            val);
+    }
+    else if (page[0] == 'r') { /* r: read flash starting from `seek` */
+        g_pf.cur_cmd = cmd_read;
+        printk(KERN_INFO "%s: cmd: read flash from addr 0x%X\n", 
+            g_pf_name, g_pf.cur_addr);
+    }
+    else if (page[0] == 'w') { /* w: write flash starting from `seek` */
+        g_pf.cur_cmd = cmd_write;
+        printk(KERN_INFO "%s: cmd: write flash from addr 0x%X\n",
+            g_pf_name, g_pf.cur_addr);
+    }
+    else if (sscanf(page, "e 0x%lx", &val) == 1) { /* e: erase sector */
+        val &= ~((Pch_Spi_Flash_Erase_Sz()-1));
+        printk(KERN_INFO "%s: cmd: erase sector, addr 0x%lX\n", g_pf_name, val);
+        if (!Pch_Spi_Flash_Erase_Sector((u32)val)) {
+            printk(KERN_INFO "%s: erase sector complete\n", g_pf_name);
+        }
+        else {
+            printk(KERN_INFO "%s: erase flash sector failed!\n", g_pf_name);
+            ret = -1;
+        }
+    }
+    else if (page[0] == 'p') { /* p: print SPI regs */
+        printk(KERN_INFO "%s: cmd: print SPI registers\n", g_pf_name);
+        Pch_Spi_Bar_Print();
+    }
+    else if (sscanf(page, "debug %lx", &val) == 1) { /* debug 0 */
+        printk(KERN_INFO "%s: cmd: debug print %d\n", g_pf_name, (int)val);
+        g_dbg_print = (u8) val;
+    }
+    else {
+        g_pf.cur_cmd = cmd_invalid;
+        /* can't understand */
+        ret = -1;
+        goto err;
+    }
+    goto out;
+
+err:
+    page[count]='\0';
+    dbg_print((KERN_INFO "%s: error cmd: %s\n", g_pf_name, page));
+
+out:
+    free_page((unsigned long)page);
+    return ret;
+}
+
+
+/*****************************************************************************
+ * Abstract
+ * Clean up proc file
+ * Side Effects:
+ * Assumptions:
+ * Return Values: 
+ *****************************************************************************/
+void Pch_Spi_Procfs_Exit(void)
+{
+    /* remove proc fs */
+    if( g_pf.proc_fs ) {
+        remove_proc_entry(g_pf_name, NULL /* &proc_root */); /* in 2.6.29.4 
+                                                     this is dummy macro */
+    }
+}
+
+/*****************************************************************************
+ * Abstract
+ * proc file creation and initalization.
+ * Side Effects:
+ * Assumptions:
+ * Return Values: zero on success, non-zero on error
+ *****************************************************************************/
+int Pch_Spi_Procfs_Init(void)
+{
+    g_pf.proc_fs = \
+                 create_proc_entry(g_pf_name, (S_IRUGO|S_IWUGO)/*0666*/, NULL);
+    
+    if (g_pf.proc_fs == NULL) {
+        remove_proc_entry(g_pf_name, NULL /* &proc_root */); /* in 2.6.29.4 
+                                                        this is dummy macro */
+        printk(KERN_ALERT "Error: Could not initialize /proc/%s\n",
+            g_pf_name);
+        return -ENOMEM;
+    }
+
+    g_pf.proc_fs->read_proc  = Pch_Spi_Procfs_Read;
+    g_pf.proc_fs->write_proc = Pch_Spi_Procfs_Write;
+    /*g_pf.proc_fs->owner = THIS_MODULE;*/
+    g_pf.proc_fs->mode    = S_IFREG | S_IRUGO;
+    g_pf.proc_fs->uid     = 0;
+    g_pf.proc_fs->gid     = 0;
+
+    /* init settings */
+    g_pf.cur_cmd = cmd_invalid;
+    g_pf.file = NULL;
+    g_pf.cur_addr = 0x0;
+    g_pf.bs = DEFAULT_BS;
+
+    printk(KERN_ALERT "%s: /proc/%s created\n", g_pf_name, g_pf_name);
+
+    return 0;    /* everything is ok */
+}
+
+/*****************************************************************************
+ * Abstract
+ * return flash size in bytes
+ * Assumptions:
+ * g_flash_info initalized.
+ * Return Values: flash size in bytes
+ *****************************************************************************/
+unsigned int Pch_Spi_Flash_Sz(void)
+{
+    if (!g_spi.flash) {
+        return 0;
+     }
+    return (g_spi.flash->size_in_bytes * g_spi.flash_cnt);
+}
+
+/*****************************************************************************
+ * Abstract
+ * return flash erase block size in bytes
+ * Assumptions:
+ * g_flash_info initalized.
+ * Return Values: flash erase block size in bytes
+ *****************************************************************************/
+unsigned int Pch_Spi_Flash_Erase_Sz(void)
+{
+    if (!g_spi.flash) {
+        return 0;
+    }
+    return g_spi.flash->erasesize;
+}
+
+/*****************************************************************************
+ * Abstract
+ * returns SPI flash region address (start and end)
+ * Assumptions: None
+ * Return Values: flash address; on error -1
+ *****************************************************************************/
+unsigned int Pch_Spi_Region_Get_Address(int region, int start_or_end)
+{
+    unsigned int r;
+    unsigned int start;
+    unsigned int end;
+
+    if (region == REGION_DESC) {
+        r = spi_readl(SPI_REG_FREG0);
+    }
+    if (region == REGION_BIOS) {
+        r = spi_readl(SPI_REG_FREG1);
+    }
+    else if (region == REGION_IME) {
+        r = spi_readl(SPI_REG_FREG2);
+    }
+    else if (region == REGION_GBE) {
+        r = spi_readl(SPI_REG_FREG3);
+    }
+    else if (region == REGION_DATA) { 
+        r = spi_readl(SPI_REG_FREG4);
+    }
+    else { 
+        return -1;
+    }
+
+    start = ((r & 0x1FFF) << 0xC);
+    end = ((r & 0x1FFF0000) >> (0x10-0xC)); /* end address is always 
+                                            start of erasable block */
+    end += 0xFFF;  /* adjust end address */
+    if (START_OF_REGION == start_or_end) {
+        return start;
+    }
+    else if (END_OF_REGION == start_or_end) {
+        return end;
+    }
+
+    return -1;
+}
+
+
+/*****************************************************************************
+ * Abstract
+ * erase entier SPI flash region 
+ * Assumptions: None
+ * Return Values: 0 on success ; -1 on error
+ *****************************************************************************/
+unsigned int Pch_Spi_Region_Erase(int region)
+{
+    unsigned int start;
+    unsigned int end;
+    unsigned int esz;
+    int ret=-1;
+
+    start = Pch_Spi_Region_Get_Address(region, START_OF_REGION);
+    end = Pch_Spi_Region_Get_Address(region, END_OF_REGION);
+
+    if (start == -1 || end == -1) {
+       return -1;
+    }
+
+    esz = Pch_Spi_Flash_Erase_Sz();
+
+    do {
+        if (start > end ) {
+           return ret;
+        }
+        printk(KERN_INFO "%s: erase sector 0x%x\n", g_drvname, start);
+        ret = Pch_Spi_Flash_Erase_Sector(start);
+        start += esz;
+    } while (!ret);
+
+    return ret;
+}
+
+
+
+/*****************************************************************************
+ * Abstract
+ * wait for  flash cycle to complete 
+ * Assumptions:
+ * Return Values: 
+ *****************************************************************************/
+STATIC void Pch_Spi_Wait_For_Free(void)
+{
+    /* wait until "SPI Cycle in Progress" bit is 1 */
+    while (spi_readw(SPI_REG_SSFSTS) & B_SPI_SSFS_SCIP) { };
+}
+
+/*****************************************************************************
+ * Abstract
+ * wait for previous flash command to complete 
+ * Assumptions:
+ * Return Values: 
+ *****************************************************************************/
+STATIC int Pch_Spi_Wait_For_Complete(void)
+{
+    u16 spi_status;
+    u32 retry_cnt=SPI_FLASH_OP_MAX_TIMEOUT_IN_SEC*0x3E8; /* in msec */
+
+    spi_status = spi_readb(SPI_REG_SSFSTS);
+
+    /* wait until "Cycle Done Status" bit is 1 */
+    while (!(spi_status & B_SPI_SSFS_CDS)) {
+        /* check errors */
+        if (spi_status & (B_SPI_SSFS_AEL | B_SPI_SSFS_FCERR)) {
+            printk(KERN_INFO "%s: SPI status error 0x%x\n", 
+                g_drvname, spi_status);
+            return -1;
+        }
+        mdelay(1);
+        cond_resched();
+        retry_cnt--;
+        if (!retry_cnt) {
+            printk(KERN_INFO "%s: error: Pch_Spi_Wait_For_Complete timeout!\n",
+                g_drvname);
+            return -1;
+        }
+        else if (!(retry_cnt%(0x3E9))) {
+            printk(KERN_INFO "%s: flash operation in progress!\n", g_drvname);
+        }
+        spi_status = spi_readb(SPI_REG_SSFSTS);
+    }
+
+    /* clear status */
+    spi_status |= B_SPI_SSFS_CDS;
+    spi_writeb(SPI_REG_SSFSTS, (u8)spi_status);
+
+    return 0;
+}
+
+/*****************************************************************************
+ * Abstract
+ * Execute a flash command. Input parameter 'cmd_idx' is index to flash 
+ * command to be executed, 'addr' flash address associated w/ flash command,
+ * 'byte_cnt' is byte count associated w/ flash command, 'data' is buffer 
+ * pointer.
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+STATIC int Pch_Spi_Flash_Cmd(const u8 cmd_idx, u32 addr, u16 byte_cnt, u8* data)
+{
+    int ret = 0;
+    u16 ctl = 0;
+    u16 i;
+
+    Pch_Spi_Wait_For_Free();
+
+    /* flash address */
+    if (addr != NO_ADDR) {
+        spi_writel(SPI_REG_FADDR, addr);
+    }
+    /* opcode type */
+    spi_writew(SPI_REG_OPTYPE, g_spi.flash->fcmds[cmd_idx].spi_optype);
+    /* opcode */
+    spi_writeb(SPI_REG_OPMENU, g_spi.flash->fcmds[cmd_idx].opcode);
+    /* prefix */
+    if (g_spi.flash->fcmds[cmd_idx].prefix != NO_PREFIX) {
+        spi_writew(SPI_REG_PREOP, g_spi.flash->fcmds[cmd_idx].prefix);
+        /* atomic cycle */
+        ctl |= B_SPI_SSFC_ACS;
+    }
+
+    if (byte_cnt) {
+        /* data cycle */
+        ctl |= B_SPI_SSFC_DS;
+        /* byte count <zero based> */
+        byte_cnt = (byte_cnt - 1) & (B_SPI_SSFC_DBC >> 0x8); 
+        ctl |= (byte_cnt << 0x8);
+        byte_cnt++; /* restore */
+        if (g_spi.flash->fcmds[cmd_idx].spi_optype & 
+         B_SPI_OPTYPE_NO_ADDR_WR) {
+            /* write data */
+            for (i = 0; i < byte_cnt; ) {
+                if ((i+0x4) <= byte_cnt) {
+                    /* big write */
+                    spi_writel((SPI_REG_FDATA0+i), *((u32*)&data[i]));
+                    i += 0x4;
+                }
+                else {
+                    /* small write */
+                    spi_writeb((SPI_REG_FDATA0 + i), data[i]);
+                    i++;
+                }
+            } /* for */
+        } /* write */
+    } /* if data cycle */
+
+    /* go */
+    ctl |= B_SPI_SSFC_SCGO;
+    spi_writew(SPI_REG_SSFCTL, ctl);
+
+    ret = Pch_Spi_Wait_For_Complete();
+    if (!ret) {
+        if (!(g_spi.flash->fcmds[cmd_idx].spi_optype & \
+                                                   B_SPI_OPTYPE_NO_ADDR_WR)) {
+            /* read data */
+            for (i = 0; i < byte_cnt; ) {
+                if ((i+0x4) <= byte_cnt) {
+                    /* big read */
+                    *((u32*)&data[i]) = 
+                        spi_readl((SPI_REG_FDATA0+i));
+                    i += 0x4;
+                }
+                else {
+                    /* small read */
+                    data[i] = spi_readb((SPI_REG_FDATA0 + i));
+                    i++;
+                }
+            } /* for */
+        } /* read */
+    }
+
+    return ret;
+}
+
+/*
+ * Print current SPI registers to message log. This is for diagnostic purpose.
+ */
+void Pch_Spi_Bar_Print(void)
+{
+#define SPI_PRINT_REGION(_r) printk(KERN_INFO " <0x%x-0x%x>",\
+    (((_r)&0x1FFF)<<12), ((_r)&0x1FFF0000>>(16-12)));
+
+#define SPI_PRINT_PROTECTION(_r)    \
+        if ((_r)&0x80008000) {    \
+            if ((_r)&0x80000000) {   \
+                printk(KERN_INFO " <WR_EN>");\
+            }\
+            if ((_r)&0x00008000) {   \
+                printk(KERN_INFO " <RD_EN>");\
+            }\
+        }
+
+    printk(KERN_INFO "%s:\n", g_drvname);
+    printk(KERN_INFO "SPI BAR\n");
+    printk(KERN_INFO "-------\n");
+    printk(KERN_INFO "0x00-0x03: %08X BIOS flash primary region\n", 
+        spi_readl(SPI_REG_BFPREG));
+        SPI_PRINT_REGION(spi_readl(SPI_REG_BFPREG));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO "0x04-0x05: %04X HW seq. flash status\n", 
+        spi_readw(SPI_REG_HSFSTS));
+    printk(KERN_INFO "0x06-0x07: %04X HW seq. flash ctrl\n", 
+        spi_readw(SPI_REG_HSFCTL));
+    printk(KERN_INFO "0x50-0x53: %08X Flash region access perm\n", 
+        spi_readl(SPI_REG_FRACC));
+    printk(KERN_INFO "0x54-0x57: %08X region 0 ", spi_readl(SPI_REG_FREG0));
+
+    printk(KERN_INFO "Descriptor Region <0x%x-0x%x>\n",
+        Pch_Spi_Region_Get_Address(REGION_DESC, START_OF_REGION), 
+        Pch_Spi_Region_Get_Address(REGION_DESC, END_OF_REGION));
+
+    printk(KERN_INFO "0x58-0x5B: %08X region 1 ", spi_readl(SPI_REG_FREG1));
+    printk(KERN_INFO "BIOS Region <0x%x-0x%x>\n",
+        Pch_Spi_Region_Get_Address(REGION_BIOS, START_OF_REGION), 
+        Pch_Spi_Region_Get_Address(REGION_BIOS, END_OF_REGION));
+
+    printk(KERN_INFO "0x5C-0x5F: %08X region 2 ", spi_readl(SPI_REG_FREG2));
+    printk(KERN_INFO "iME Region <0x%x-0x%x>\n",
+        Pch_Spi_Region_Get_Address(REGION_IME, START_OF_REGION), 
+        Pch_Spi_Region_Get_Address(REGION_IME, END_OF_REGION));
+
+    printk(KERN_INFO "0x60-0x63: %08X region 3", spi_readl(SPI_REG_FREG3));
+    printk(KERN_INFO "GBE Region <0x%x-0x%x>\n",
+        Pch_Spi_Region_Get_Address(REGION_GBE, START_OF_REGION), 
+        Pch_Spi_Region_Get_Address(REGION_GBE, END_OF_REGION));
+
+    printk(KERN_INFO "0x64-0x67: %08X region 4", spi_readl(SPI_REG_FREG4));
+    printk(KERN_INFO "DATA Region <0x%x-0x%x>\n",
+        Pch_Spi_Region_Get_Address(REGION_DATA, START_OF_REGION), 
+        Pch_Spi_Region_Get_Address(REGION_DATA, END_OF_REGION));
+
+    printk(KERN_INFO "0x74-0x77: %08X protected range 0", \
+                                                   spi_readl(SPI_REG_PR0));
+    printk(KERN_INFO " <desc>");
+        SPI_PRINT_REGION(spi_readl(SPI_REG_PR0));
+        SPI_PRINT_PROTECTION(spi_readl(SPI_REG_PR0));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO "0x78-0x7B: %08X protected range 1", \
+                                                    spi_readl(SPI_REG_PR1));
+    printk(KERN_INFO " <BIOS>");
+        SPI_PRINT_REGION(spi_readl(SPI_REG_PR1));
+        SPI_PRINT_PROTECTION(spi_readl(SPI_REG_PR1));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO "0x7C-0x7F: %08X protected range 2", \
+                                                    spi_readl(SPI_REG_PR2));
+        printk(KERN_INFO " <ME>");
+        SPI_PRINT_PROTECTION(spi_readl(SPI_REG_PR2));
+        SPI_PRINT_REGION(spi_readl(SPI_REG_PR2));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO "0x80-0x83: %08X protected range 3", \
+                                                    spi_readl(SPI_REG_PR3));
+        printk(KERN_INFO " <GbE>");
+        SPI_PRINT_REGION(spi_readl(SPI_REG_PR3));
+        SPI_PRINT_PROTECTION(spi_readl(SPI_REG_PR3));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO "0x84-0x87: %08X protected range 4", \
+                                                    spi_readl(SPI_REG_PR4));
+        printk(KERN_INFO " <plat data>");
+        SPI_PRINT_REGION(spi_readl(SPI_REG_PR4));
+        SPI_PRINT_PROTECTION(spi_readl(SPI_REG_PR4));
+        printk(KERN_INFO "\n");
+    printk(KERN_INFO \
+        "0xA0     : %02X BIOS base address config.\n", spi_readb(0xA0));
+    printk(KERN_INFO \
+        "0xB0-0xB3: %04X flash desc observability ctrl\n", \
+                                                 spi_readl(SPI_REG_FDOC));
+    printk(KERN_INFO \
+        "0xB4-0xB7: %04X flash desc observability data\n", \
+                                                 spi_readl(SPI_REG_FDOD));
+    printk(KERN_INFO \
+        "0xC0-0xC3: %04X additional flash ctrl\n", spi_readl(SPI_REG_AFC));
+    printk(KERN_INFO \
+        "0xC4-0xC7: %04X host lower vendor specific component cap.\n", 
+        spi_readl(0xC4));
+    printk(KERN_INFO \
+        "0xC8-0xCB: %04X host upper vendor specific component cap.\n", 
+        spi_readl(0xC8));
+    printk(KERN_INFO \
+        "0xD0-0xD3: %04X flash partition boundary\n", spi_readl(0xD0));
+}
+
+
+/*****************************************************************************
+ * Abstract
+ * identify SPI flash device. JEDEC id is used for identifying particular flash
+ * device from g_flash_info array
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+STATIC int Pch_Spi_Flash_Probe(void)
+{
+    u8 data[0x3];
+    u8 mfr;
+    u16 jedec_id=(~0);
+    u16 i;
+
+    g_spi.flash = &g_flash_info[0];
+    if (Pch_Spi_Flash_Cmd(OPCODE_JEDEC_ID_IDX, NO_ADDR, 0x3, data)) { 
+        return -1;
+    }
+
+    mfr = data[0];
+    jedec_id = (data[1] << 0x8) | data[0x2];
+    printk(KERN_INFO "%s: flash device JEDEC ID: %X\n", g_drvname, jedec_id);
+    g_spi.flash = NULL;
+
+    /* find matching jedec id */
+    for (i=0; i < (sizeof(g_flash_info)/sizeof(struct flash_info_struct)); \
+                                                                        i++) {
+        g_spi.flash = &g_flash_info[i];
+
+        if (jedec_id == g_spi.flash->jedec_id) { 
+            break; /* found */
+        }
+    }
+    if (i == (sizeof(g_flash_info)/sizeof(struct flash_info_struct))) {
+        printk(KERN_INFO "%s: unknown SPI device\n", g_drvname);
+        return -1;
+    }
+
+    printk(KERN_INFO "%s: found flash device %s <JEDEC ID: %X>\n", 
+        g_drvname, g_spi.flash->name, g_spi.flash->jedec_id);
+    printk(KERN_INFO "%s: flash size %d bytes\n", 
+        g_drvname, g_spi.flash->size_in_bytes);
+    printk(KERN_INFO "%s: erase block size %d bytes\n", 
+        g_drvname, g_spi.flash->erasesize);
+
+    /* determine number of flash chips, could have 1 or 2 */
+       g_spi.flash_cnt = 1; /* default */
+    for(i = REGION_DESC; i <= REGION_DATA; i++) {
+        if (Pch_Spi_Region_Get_Address(i, END_OF_REGION) > 
+                g_spi.flash->size_in_bytes) {
+           g_spi.flash_cnt = 0x2;
+           break;
+        }
+    }
+    printk(KERN_INFO "%s: Number of flash devices: %d\n", 
+        g_drvname, (int)g_spi.flash_cnt);
+
+    return 0;
+}
+
+/*****************************************************************************
+ * Abstract
+ * read flash device status
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+int Pch_Spi_Flash_Rd_Status(u8* status)
+{
+    Pch_Spi_Wait_For_Free();
+    return Pch_Spi_Flash_Cmd(OPCODE_RD_STATUS_IDX, NO_ADDR, 1, status);
+}
+
+/*****************************************************************************
+ * Abstract
+ * write flash device status
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+int Pch_Spi_Flash_Wr_Status(u8 status)
+{
+    Pch_Spi_Wait_For_Free();
+    return Pch_Spi_Flash_Cmd(OPCODE_WR_STATUS_IDX, NO_ADDR, 1, &status);
+}
+
+/*****************************************************************************
+ * Abstract
+ * initalize SPI interface and identify flash device
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+int Pch_Spi_Flash_Init(void)
+{
+    /* clear any errors */
+    spi_writeb(SPI_REG_SSFSTS, spi_readb(SPI_REG_SSFSTS));
+
+    /* identify flash device */
+    if (Pch_Spi_Flash_Probe()) {
+        return -1; /* error */
+    }
+
+    /* unlock all blocks */
+    //Pch_Spi_Flash_Wr_Status(0);
+    return 0;
+}
+
+/*****************************************************************************
+ * Abstract
+ * flash device read / write function
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+STATIC int Pch_Spi_Flash_Rd_Wr(u8* data, u32 byte_len, u32 addr, u8 read_op)
+{
+    int ret=0;
+    u32 len;
+
+    do {
+        len = (byte_len > 0x40)? 0x40 : byte_len;
+        if (addr%0x4) { /* addr not aligned at u32 boundry */
+            len = 1;
+         }
+
+        if (read_op) {
+            ret = Pch_Spi_Flash_Cmd(OPCODE_READ_IDX, addr, (u16)len, data);
+        }
+        else { 
+            ret = Pch_Spi_Flash_Cmd(OPCODE_WRITE_IDX, addr, (u16)len, data);
+        }
+
+        if (ret) {
+            break;
+        }
+        addr += len;
+        data += len;
+        byte_len -= len;
+    } while (byte_len);
+
+    return ret;
+}
+
+/* Flash device read. */
+int Pch_Spi_Flash_Read(u8* data, u32 byte_len, u32 addr)
+{
+    return Pch_Spi_Flash_Rd_Wr(data, byte_len, addr, 1 /*read*/);
+}
+
+/* Flash device write */
+int Pch_Spi_Flash_Write(u8* data, u32 byte_len, u32 addr)
+{
+    return Pch_Spi_Flash_Rd_Wr(data, byte_len, addr, 0 /*write*/);
+}
+
+/*****************************************************************************
+ * Abstract
+ * Perform flash chip erase. Entire flash chip is erased
+ * Side Effects:
+ * Erase chip takes long time to complete. E.g., Erase time 60-160 Sec for
+ * M25P64VMF flash device.
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+int Pch_Spi_Flash_Erase_Chip(void)
+{
+    return Pch_Spi_Flash_Cmd(OPCODE_CHIP_ERASE_IDX, NO_ADDR, 0, NULL);
+}
+
+/*****************************************************************************
+ * Abstract
+ * Perform flash chip erase sector. Single sector is erased.
+ * Side Effects:
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+int Pch_Spi_Flash_Erase_Sector(u32 addr)
+{
+    return Pch_Spi_Flash_Cmd(OPCODE_ERASE_IDX, addr, 0, NULL);
+}
+
+/*****************************************************************************
+ * Abstract
+ * driver exit function; performs clean up.
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+STATIC void Pch_Spi_Exit(void)
+{
+    printk(KERN_INFO "%s: Unloading driver\n", g_drvname);
+
+    /* remove proc fs */
+    Pch_Spi_Procfs_Exit();
+
+    /* unmap IO mem */
+    if (g_spi.spi) {
+        iounmap(g_spi.spi);
+    }
+
+    /* free IO mem */
+    if (g_spi.res.start) {
+        release_resource(&g_spi.res);
+    }
+}
+
+/*****************************************************************************
+ * Abstract
+ * enable flash BIOS region write if it's disabled from BIOS.
+ * Assumptions:
+ * Return Values: 
+ *****************************************************************************/
+STATIC void Pch_Spi_Enable_Bios_Wr(void)
+{
+    struct pci_device_id *id;
+    struct pci_dev *dev=NULL;
+    u32 bios_cntl;
+
+    /* ICH9/PCH SKUs*/
+    static struct pci_device_id ich9_pci_tbl[] __devinitdata = {
+    {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH)},
+    {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH9_2)},
+    {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH9_4)},
+    {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH9_7)},
+    {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH9_8)},
+    {.vendor = 0,},
+    };
+    
+    for (id = ich9_pci_tbl; id->vendor; id++) {
+        dev = pci_get_device(id->vendor, id->device, NULL);
+        if (dev) {
+            printk(KERN_INFO "%s: found PCH device ID %x \n",
+                g_drvname, id->device);
+            break;
+        }
+    }
+    if (!dev) { 
+        return;
+    }
+
+    /* Enable writes to the BIOS.
+     * Since the SPI flash can serve as BIOS storage, the 'BIOS write
+     * enable' bit of the LPC BIOS_CNTL PCI configuration register must be
+     * set in order to allow writing to the flash.  This is true regardless
+     * of whether the SPI flash is actually used for BIOS.
+     */
+    pci_read_config_byte(dev, LPC_BIOS_CNTL_REG, (u8 *) &bios_cntl);
+    if (!(bios_cntl & BIOS_CNTL_BIOSWE) &&
+        (bios_cntl & BIOS_CNTL_BLE)) {
+        printk(KERN_WARNING "%s: error: writes to SPI flash are prohibited by"
+               " BIOS.\n", g_drvname);
+    } else {
+        pci_write_config_byte(dev, LPC_BIOS_CNTL_REG,
+                      (u8)(bios_cntl | BIOS_CNTL_BIOSWE));
+    }
+
+    pci_dev_put(dev);
+}
+
+/*****************************************************************************
+ * Abstract
+ * Driver init function
+ * Assumptions:
+ * Return Values: 
+ * non-zero value on error, else zero
+ *****************************************************************************/
+STATIC int Pch_Spi_Init(void)
+{
+    struct pch_spi_struct *s = &g_spi;
+    int err = -ENODEV;
+
+    printk(KERN_INFO "%s: init\n", g_drvname);
+
+    /* claim and map the SPI registers */
+    s->res.name = "pch_spibar";
+    s->res.start = SPI_BASE;
+    s->res.end = s->res.start + SPI_SIZE - 1;
+    s->res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+    if (request_resource(&iomem_resource, &s->res)) {
+        printk(KERN_ERR "%s: warning: can't claim the PCH SPI registers.\n",
+            g_drvname);
+        memset(&s->res, 0x0, sizeof(s->res));
+    }
+
+    /* memory map */
+    s->spi = ioremap_nocache(SPI_BASE, SPI_SIZE);
+    if (!s->spi) {
+        printk(KERN_ERR "%s: ioremap_nocache(SPI_BASE=0x%08x, SPI_SIZE) \
+               failed!\n", g_drvname, SPI_BASE);
+        goto free_resource;
+    }
+
+    /**
+     * GCS shouldn't be touched on CRB BIOS
+     */
+
+    Pch_Spi_Enable_Bios_Wr();
+
+    /* init / probe spi flash */
+    if (Pch_Spi_Flash_Init()) {
+        printk(KERN_ERR "%s: Pch_Spi_Flash_Init() failed!\n", g_drvname);
+        goto free_resource;
+    }
+
+    /* create proc fs */
+    Pch_Spi_Procfs_Init();
+
+    return 0;
+
+free_resource:
+    return err;
+}
+
+module_init(Pch_Spi_Init);
+module_exit(Pch_Spi_Exit);
diff --git a/drivers/spi/pchspi.h b/drivers/spi/pchspi.h
new file mode 100755
index 0000000..4f477cb
--- /dev/null
+++ b/drivers/spi/pchspi.h
@@ -0,0 +1,244 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ *   redistributing this file, you may do so under either license.
+ * 
+ *   GPL LICENSE SUMMARY
+ * 
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ * 
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ * 
+ *   This program is distributed in the hope that it will be useful, but 
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *   General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU General Public License 
+ *   along with this program; if not, write to the Free Software 
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution 
+ *   in the file called LICENSE.GPL.
+ * 
+ *   Contact Information:
+ *   Intel Corporation
+ * 
+ *   BSD LICENSE 
+ * 
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ * 
+ *   Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions 
+ *   are met:
+ * 
+ *     * Redistributions of source code must retain the above copyright 
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright 
+ *       notice, this list of conditions and the following disclaimer in 
+ *       the documentation and/or other materials provided with the 
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its 
+ *       contributors may be used to endorse or promote products derived 
+ *       from this software without specific prior written permission.
+ * 
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * 
+ *  version: DH89xxCC_EMBEDDED.L.0.6.0-95
+ *****************************************************************************/
+
+/**
+ ******************************************************************************
+ * @ingroup CC_SPI
+ * 
+ * File:  pchspi.h
+ *
+ * @description
+ * SPI driver data structures and types.
+ *****************************************************************************/
+
+#ifndef __PCHSPI_H__
+#define __PCHSPI_H__
+
+/* LPC Configuration registers, offsets and bit fields */
+#define LPC_RCBA_REG		0xF0    /* root complex base address */
+#define LPC_BIOS_CNTL_REG	0xDC    /* BIOS control register */
+
+#define BIOS_CNTL_BIOSWE	0x0001	/* write enable */
+#define BIOS_CNTL_BLE		0x0002	/* lock enable */
+
+#define PCI_DEVICE_ID_INTEL_ICH9_2    0x2912
+#define PCI_DEVICE_ID_INTEL_ICH9_4    0x2914
+#define PCI_DEVICE_ID_INTEL_ICH9_7    0x2916
+#define PCI_DEVICE_ID_INTEL_ICH9_8    0x2918
+#define PCI_DEVICE_ID_INTEL_PCH       0x3B00
+
+#define SPI_REG_BFPREG                    0x00
+#define SPI_REG_HSFSTS                    0x04
+#define SPI_REG_HSFCTL                    0x06
+#define SPI_REG_FADDR                     0x08
+#define SPI_REG_FDATA0                    0x10
+#define SPI_REG_FDATA1                    0x14
+#define SPI_REG_FDATA2                    0x18
+#define SPI_REG_FDATA3                    0x1c
+#define SPI_REG_FDATA4                    0x20
+#define SPI_REG_FDATA5                    0x24
+#define SPI_REG_FDATA6                    0x28
+#define SPI_REG_FDATA7                    0x2c
+#define SPI_REG_FDATA8                    0x30
+#define SPI_REG_FDATA9                    0x34
+#define SPI_REG_FDATA10                   0x38
+#define SPI_REG_FDATA11                   0x3c
+#define SPI_REG_FDATA12                   0x40
+#define SPI_REG_FDATA13                   0x44
+#define SPI_REG_FDATA14                   0x48
+#define SPI_REG_FDATA15                   0x4c
+#define SPI_REG_FRACC                     0x50
+#define SPI_REG_FREG0                     0x54
+#define SPI_REG_FREG1                     0x58
+#define SPI_REG_FREG2                     0x5c
+#define SPI_REG_FREG3                     0x60
+#define SPI_REG_FREG4                     0x64
+#define SPI_REG_PR0                       0x74
+#define SPI_REG_PR1                       0x78
+#define SPI_REG_PR2                       0x7c
+#define SPI_REG_PR3                       0x80
+#define SPI_REG_PR4                       0x84
+#define SPI_REG_SSFSTS                    0x90
+#define SPI_REG_SSFCTL                    0x91
+#define SPI_REG_PREOP                     0x94
+#define SPI_REG_OPTYPE                    0x96
+#define SPI_REG_OPMENU                    0x98
+#define SPI_REG_FDOC                      0xB0
+#define SPI_REG_FDOD                      0xB4
+#define SPI_REG_AFC                       0xC0
+#define SPI_REG_VSCC                      0xC1
+
+#define B_SPI_HSFS_FLOCKDN  0x8000 /* Flash Config Lockdown */
+#define B_SPI_HSFS_FDV      0x4000 /* Flash Descriptor Valid */
+#define B_SPI_HSFS_FDOPSS   0x2000 /* Flash Descriptor Override 
+										Pin-Strap Status */
+#define B_SPI_HSFS_SCIP     0x0020 /* SPI Cycle In Progress */
+#define B_SPI_HSFS_BERASE   0x0018 /* Block/Sector Erase Size */
+#define B_SPI_HSFS_AEL      0x0004 /* Access Error */
+#define B_SPI_HSFS_FCERR    0x0002 /* Flash Cycle Error */
+#define B_SPI_HSFS_FDONE    0x0001 /* Flash Cycle Done */
+                                          
+#define B_SPI_SSFC_SFRC     0x00080000 /* SPI Fast Read Cycle */
+#define B_SPI_SSFC_SFC      0x00070000 /* SPI Cycle Frequency */
+#define B_SPI_SSFC_SMIEN    0x00008000 /* SPI SMI# Enable 
+										(assert SMI on Cycle Done) */
+#define B_SPI_SSFC_DS       0x00004000 /* Data Cycle */
+#define B_SPI_SSFC_DBC      0x00003F00 /* Data Byte Count */
+#define B_SPI_SSFC_COP		0x00000070 /* Cycle Opcode Pointer */
+#define B_SPI_SSFC_SPOP     0x00000008 /* Sequence Prefix Opcode Pointer */
+#define B_SPI_SSFC_ACS      0x00000004 /* Atomic Cycle Sequence */
+#define B_SPI_SSFC_SCGO     0x00000002 /* SPI Cycle Go */
+
+#define B_SPI_SSFS_AEL                  0x10       /* Access Error Log */
+#define B_SPI_SSFS_FCERR                0x08       /* Flash Cycle Error */
+#define B_SPI_SSFS_CDS                  0x04       /* Cycle Done Status */
+#define B_SPI_SSFS_SCIP                 0x01       /* SPI Cycle in Progress */
+
+#define B_SPI_OPTYPE_NO_ADDR_RD   0x00
+#define B_SPI_OPTYPE_NO_ADDR_WR   0x01
+#define B_SPI_OPTYPE_RD           0x02
+#define B_SPI_OPTYPE_WR           0x03
+
+/*
+ * SPI default opcode slots
+ */
+#define OPCODE_JEDEC_ID_IDX         0
+#define OPCODE_READ_ID_IDX          1
+#define OPCODE_WR_STATUS_IDX        2
+#define OPCODE_WRITE_IDX            3
+#define OPCODE_READ_IDX             4
+#define OPCODE_ERASE_IDX            5
+#define OPCODE_RD_STATUS_IDX        6
+#define OPCODE_CHIP_ERASE_IDX       7
+#define OPCODE_LAST_IDX             8
+
+#define NO_ADDR                     (~0)
+#define NO_PREFIX                   0
+
+#define RCBA_BASE	0xFED1C000
+#define SPI_BASE	(RCBA_BASE + 0x3800)
+#define SPI_SIZE	0xD4	/* SPI register memory region */
+
+#define GCS_OFFSET	(RCBA_BASE + 0x3410) 
+/* mask of the boot BIOS straps field in the GCS register */
+#define GCS_BBS_MASK	0x00000C00
+#define GCS_BBS_SPI	0x00000400	/* enable SPI */
+
+
+#define SPI_FLASH_OP_MAX_TIMEOUT_IN_SEC		300 /* worst case 5 min */
+
+/* flash opcode supported a particular flash device */
+struct flash_cmd_struct {
+	u8 opcode;
+	u8 prefix;
+	u8 spi_optype;
+};
+
+/* flash information */
+struct flash_info_struct {
+	char *name;
+	unsigned mfr;
+	unsigned id;
+	unsigned jedec_id;
+	unsigned size_in_bytes;
+	unsigned erasesize;
+	const struct flash_cmd_struct* fcmds;
+} ;
+
+/* SPI structure */
+struct pch_spi_struct {
+	u32 gcs;
+	void __iomem *spi;
+	struct resource res;
+	
+	/* enumerated flash based on jedec id, see function */
+	struct flash_info_struct* flash;
+	/* number of flash chips could have 1 or 2 */
+	u8 flash_cnt; 
+} ;
+
+/* required for Parasoft */
+#define STATIC static
+
+/* function declaration */
+void Pch_Spi_Bar_Print(void);
+int Pch_Spi_Flash_Init(void);
+int Pch_Spi_Flash_Read(u8* data, u32 byte_len, u32 addr);
+int Pch_Spi_Flash_Write(u8* data, u32 byte_len, u32 addr);
+int Pch_Spi_Flash_Erase_Chip(void);
+int Pch_Spi_Flash_Erase_Sector(u32 addr);
+
+unsigned int Pch_Spi_Flash_Sz(void);
+unsigned int Pch_Spi_Flash_Erase_Sz(void);
+
+#define REGION_DESC		0	/* descriptor region */
+#define REGION_BIOS		1
+#define REGION_IME		2
+#define REGION_GBE		3
+#define REGION_DATA		4
+
+#define START_OF_REGION		0
+#define END_OF_REGION		1
+
+unsigned int Pch_Spi_Region_Get_Address(int region, int start_or_end);
+unsigned int Pch_Spi_Region_Erase(int region);
+
+#endif /* __PCHSPI_H__ */
-- 
1.6.3.1

