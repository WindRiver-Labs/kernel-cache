From fb1a617c222574a4adcaebd3dd8f9604b88ed723 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 7 Jul 2014 15:16:35 +0800
Subject: [PATCH 202/263] usb: dwc3: dwc3-omap: Adding extcon support for
 dynamic usb cable detection

The 3190c6f7 comes from the following git repo:

  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Adding extcon support for dynamic detection of usb cable detection
and initialize the usb-modes accordingly.

Change-Id: Ie9c671eba0414bdfc9ba4a69cd6d8e53eb5394b5
Signed-off-by: Ravi Babu <ravibabu@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/dwc3/dwc3-omap.c |   70 ++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 68 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/dwc3/dwc3-omap.c b/drivers/usb/dwc3/dwc3-omap.c
index 8097f6b..36b4b91 100644
--- a/drivers/usb/dwc3/dwc3-omap.c
+++ b/drivers/usb/dwc3/dwc3-omap.c
@@ -29,9 +29,13 @@
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
-
+#include <linux/extcon.h>
+#include <linux/extcon/of_extcon.h>
+#include <linux/regulator/consumer.h>
+ 
 #include <linux/usb/otg.h>
 #include <linux/usb/dwc3-omap.h>
+#include <linux/usb/of.h>
 
 /*
  * All these registers belong to OMAP's Wrapper around the
@@ -132,6 +136,10 @@ struct dwc3_omap {
 	u32			revision;
 
 	u32			dma_status:1;
+	struct extcon_specific_cable_nb extcon_vbus_dev;
+	struct extcon_specific_cable_nb extcon_id_dev;
+	struct notifier_block	vbus_nb;
+	struct notifier_block	id_nb;
 };
 
 static struct dwc3_omap		*_omap;
@@ -268,6 +276,32 @@ int dwc3_omap_mailbox(enum omap_dwc3_vbus_id_status status)
 }
 EXPORT_SYMBOL_GPL(dwc3_omap_mailbox);
 
+static int dwc3_omap_id_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
+{
+	struct dwc3_omap *omap = container_of(nb, struct dwc3_omap, id_nb);
+
+	if (event)
+		dwc3_omap_usbvbus_id_handler(omap->dev, OMAP_DWC3_ID_GROUND);
+	else
+		dwc3_omap_usbvbus_id_handler(omap->dev, OMAP_DWC3_VBUS_VALID);
+
+	return NOTIFY_DONE;
+}
+
+static int dwc3_omap_vbus_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
+{
+	struct dwc3_omap *omap = container_of(nb, struct dwc3_omap, vbus_nb);
+
+	if (event)
+		dwc3_omap_usbvbus_id_handler(omap->dev, OMAP_DWC3_VBUS_VALID);
+	else
+		dwc3_omap_usbvbus_id_handler(omap->dev, OMAP_DWC3_VBUS_OFF);
+
+	return NOTIFY_DONE;
+}
+
 static irqreturn_t dwc3_omap_interrupt(int irq, void *_omap)
 {
 	struct dwc3_omap	*omap = _omap;
@@ -362,6 +396,8 @@ static int dwc3_omap_probe(struct platform_device *pdev)
 	struct dwc3_omap	*omap;
 	struct resource		*res;
 	struct device		*dev = &pdev->dev;
+	struct extcon_dev	*edev;
+	u8			mode;
 
 	int			ret = -ENOMEM;
 	int			irq;
@@ -490,14 +526,44 @@ static int dwc3_omap_probe(struct platform_device *pdev)
 
 	dwc3_omap_enable_irqs(omap);
 
+	mode = of_usb_get_dr_mode(node);
+	if (mode == USB_DR_MODE_OTG && of_property_read_bool(node, "extcon")) {
+		edev = of_extcon_get_extcon_dev(dev, 0);
+		if (IS_ERR(edev)) {
+			dev_vdbg(dev, "couldn't get extcon device\n");
+			ret = -EPROBE_DEFER;
+			goto err2;
+		}
+
+		omap->vbus_nb.notifier_call = dwc3_omap_vbus_notifier;
+		ret = extcon_register_interest(&omap->extcon_vbus_dev,
+			edev->name, "USB", &omap->vbus_nb);
+		if (ret < 0)
+			dev_vdbg(dev, "failed to register notifier for USB\n");
+		omap->id_nb.notifier_call = dwc3_omap_id_notifier;
+		ret = extcon_register_interest(&omap->extcon_id_dev, edev->name,
+					 "USB-HOST", &omap->id_nb);
+		if (ret < 0)
+			dev_vdbg(dev,
+				"failed to register notifier for USB-HOST\n");
+
+		dwc3_omap_usbvbus_id_handler(omap->dev, OMAP_DWC3_ID_GROUND);
+	}
+
 	ret = of_platform_populate(node, NULL, NULL, dev);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to create dwc3 core\n");
-		goto err2;
+		goto err3;
 	}
 
 	return 0;
 
+err3:
+	if (omap->extcon_vbus_dev.edev)
+		extcon_unregister_interest(&omap->extcon_vbus_dev);
+	if (omap->extcon_id_dev.edev)
+		extcon_unregister_interest(&omap->extcon_id_dev);
+
 err2:
 	dwc3_omap_disable_irqs(omap);
 
-- 
1.7.5.4

