From 42a09782b7e8f8c4d3c6d007b18a2b6895a61366 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 9 Jul 2014 13:11:09 +0800
Subject: [PATCH 215/263] usb: phy: enable phy drivers to use the device node
 for optional clock names.

The 79e752ae comes from the following git repo:

  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Allow the device drivers to use the required optional clock names
from the DT node data.This allows scalability when multiple usb_otg_ss
instances are in use.

Change-Id: Id4a941855d6011a195d5cc796d6b1861624f8f56
Signed-off-by: Ruchika Kharwar <ruchika@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/dwc3/core.c         |   11 +++------
 drivers/usb/dwc3/dwc3-omap.c    |   10 ---------
 drivers/usb/phy/phy-omap-usb2.c |   42 ++++++++++++++++++++++++++++----------
 drivers/usb/phy/phy-omap-usb3.c |   36 ++++++++++++++++++++++++---------
 drivers/usb/usb-common.c        |   36 +++++++++++++++++++++++++++++++++
 include/linux/usb/of.h          |    6 +++++
 6 files changed, 103 insertions(+), 38 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index cc567fa..aa2f3d0 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -518,15 +518,12 @@ static int dwc3_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	if (IS_ENABLED(CONFIG_USB_DWC3_HOST))
-		dwc->dr_mode = USB_DR_MODE_HOST;
-	else if (IS_ENABLED(CONFIG_USB_DWC3_GADGET))
-		dwc->dr_mode = USB_DR_MODE_PERIPHERAL;
-
-	if (dwc->dr_mode == USB_DR_MODE_UNKNOWN)
+	if (dwc->dr_mode == USB_DR_MODE_UNKNOWN) {
 		dwc->dr_mode = USB_DR_MODE_OTG;
+		dev_warn(dev, "dwc3 mode set to otg default\n");
+	}
 
-	if (mode != USB_DR_MODE_PERIPHERAL) {
+	if (dwc->dr_mode != USB_DR_MODE_PERIPHERAL) {
 		dwc->gpio_count = of_gpio_count(node);
 		if (dwc->gpio_count < 1) {
 			dev_err(dev, "No gpio to configure\n");
diff --git a/drivers/usb/dwc3/dwc3-omap.c b/drivers/usb/dwc3/dwc3-omap.c
index 36b4b91..ca060d9 100644
--- a/drivers/usb/dwc3/dwc3-omap.c
+++ b/drivers/usb/dwc3/dwc3-omap.c
@@ -404,9 +404,7 @@ static int dwc3_omap_probe(struct platform_device *pdev)
 
 	int			utmi_mode = 0;
 	int			x_major;
-
 	u32			reg;
-
 	void __iomem		*base;
 
 	if (!node) {
@@ -433,14 +431,6 @@ static int dwc3_omap_probe(struct platform_device *pdev)
 	if (IS_ERR(base))
 		return PTR_ERR(base);
 
-	if (of_property_read_bool(node, "vbus-supply")) {
-		vbus_reg = devm_regulator_get(dev, "vbus");
-		if (IS_ERR(vbus_reg)) {
-			dev_err(dev, "vbus init failed\n");
-			return PTR_ERR(vbus_reg);
-		}
-	}
-
 	omap->dev	= dev;
 	omap->irq	= irq;
 	omap->base	= base;
diff --git a/drivers/usb/phy/phy-omap-usb2.c b/drivers/usb/phy/phy-omap-usb2.c
index 9c3b6ef..2439d33 100644
--- a/drivers/usb/phy/phy-omap-usb2.c
+++ b/drivers/usb/phy/phy-omap-usb2.c
@@ -28,6 +28,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/delay.h>
 #include <linux/usb/omap_control_usb.h>
+#include <linux/of_device.h>
 
 #define USB2PHY_DISCON_BYP_LATCH (1 << 31)
 #define	USB2PHY_ANA_CONFIG1	0x4c
@@ -176,6 +177,10 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	struct usb_otg			*otg;
 	const struct of_device_id *of_id;
 	struct usb_phy_data *phy_data;
+	struct device_node *node = pdev->dev.of_node;
+	const char *clk_name;
+	struct device_node		*node = pdev->dev.of_node;
+	const char   			*clk_name;
 
 	of_id = of_match_device(of_match_ptr(omap_usb2_id_table), &pdev->dev);
 
@@ -194,7 +199,7 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	if (!otg) {
 		dev_err(&pdev->dev, "unable to allocate memory for USB OTG\n");
 		return -ENOMEM;
-	}
+	}	
 
 	phy->dev		= &pdev->dev;
 
@@ -203,6 +208,7 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	phy->phy.set_suspend	= omap_usb2_suspend;
 	phy->phy.otg		= otg;
 	phy->phy.type		= USB_PHY_TYPE_USB2;
+	phy->control_dev 	= omap_get_control_dev();
 	phy->phy.init		= omap_usb_init;
 
 	if (phy_data->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT)
@@ -223,19 +229,33 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	otg->start_srp		= omap_usb_start_srp;
 	otg->phy		= &phy->phy;
 
-	phy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");
-	if (IS_ERR(phy->wkupclk)) {
-		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
-		return PTR_ERR(phy->wkupclk);
+	of_property_read_string(node, "wkupclk", &clk_name);
+	if (!clk_name) {
+		dev_err(&pdev->dev, "unable to read wkupclk property from dt \n");
+		return -ENODEV;
+	} else {
+		phy->wkupclk = devm_clk_get(phy->dev, clk_name);
+		if (IS_ERR(phy->wkupclk)) {
+			dev_err(&pdev->dev, "unable to get usb_phy wk clk\n");
+			return PTR_ERR(phy->wkupclk);
+		}
 	}
-	clk_prepare(phy->wkupclk);
 
-	phy->optclk = devm_clk_get(phy->dev, "usb_otg_ss_refclk960m");
-	if (IS_ERR(phy->optclk))
-		dev_vdbg(&pdev->dev, "unable to get refclk960m\n");
-	else
-		clk_prepare(phy->optclk);
+	clk_prepare(phy->wkupclk);
 
+	of_property_read_string(node, "optclk", &clk_name);
+	if (!clk_name)
+		dev_err(&pdev->dev, "unable to read optclk property from dt\n");
+	else {
+		phy->optclk = devm_clk_get(phy->dev, clk_name);
+		if (IS_ERR(phy->optclk)) {
+			dev_err(&pdev->dev, "unable to get usb_phy opt clk\n");
+			return PTR_ERR(phy->optclk);
+		}
+		else
+			clk_prepare(phy->optclk);
+	}
+ 
 	usb_add_phy_dev(&phy->phy);
 
 	platform_set_drvdata(pdev, phy);
diff --git a/drivers/usb/phy/phy-omap-usb3.c b/drivers/usb/phy/phy-omap-usb3.c
index fc15694..be3bd47 100644
--- a/drivers/usb/phy/phy-omap-usb3.c
+++ b/drivers/usb/phy/phy-omap-usb3.c
@@ -198,7 +198,9 @@ static int omap_usb3_probe(struct platform_device *pdev)
 {
 	struct omap_usb			*phy;
 	struct resource			*res;
-
+	struct device_node		*node = pdev->dev.of_node;
+	const char   			*clk_name;
+ 
 	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
 	if (!phy) {
 		dev_err(&pdev->dev, "unable to alloc mem for OMAP USB3 PHY\n");
@@ -219,19 +221,33 @@ static int omap_usb3_probe(struct platform_device *pdev)
 	phy->phy.type		= USB_PHY_TYPE_USB3;
 
 	phy->is_suspended	= 1;
-	phy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");
-	if (IS_ERR(phy->wkupclk)) {
-		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
-		return PTR_ERR(phy->wkupclk);
+
+	of_property_read_string(node, "wkupclk", &clk_name);
+	if (!clk_name) {
+		dev_err(&pdev->dev, "unable to read wkupclk property from dt \n");
+		return -EINVAL;
+	} else {
+		phy->wkupclk = devm_clk_get(phy->dev, clk_name);
+		if (IS_ERR(phy->wkupclk)) {
+			dev_err(&pdev->dev, "unable to get usb_phy wk clk\n");
+			return PTR_ERR(phy->wkupclk);
+		}
+
 	}
 	clk_prepare(phy->wkupclk);
 
-	phy->optclk = devm_clk_get(phy->dev, "usb_otg_ss_refclk960m");
-	if (IS_ERR(phy->optclk)) {
-		dev_err(&pdev->dev, "unable to get usb_otg_ss_refclk960m\n");
-		return PTR_ERR(phy->optclk);
+	of_property_read_string(node, "optclk", &clk_name);
+	if (!clk_name)
+		dev_err(&pdev->dev, "unable to read optclk property from dt\n");
+	else {
+		phy->optclk = devm_clk_get(phy->dev, clk_name);
+		if (IS_ERR(phy->optclk)) {
+			dev_err(&pdev->dev, "unable to get usb_phy opt clk\n");
+			return PTR_ERR(phy->optclk);
+		}
+		else
+			clk_prepare(phy->optclk);
 	}
-	clk_prepare(phy->optclk);
 
 	phy->sys_clk = devm_clk_get(phy->dev, "sys_clkin");
 	if (IS_ERR(phy->sys_clk)) {
diff --git a/drivers/usb/usb-common.c b/drivers/usb/usb-common.c
index 675384d..e702d22 100644
--- a/drivers/usb/usb-common.c
+++ b/drivers/usb/usb-common.c
@@ -112,6 +112,42 @@ enum usb_dr_mode of_usb_get_dr_mode(struct device_node *np)
 	return USB_DR_MODE_UNKNOWN;
 }
 EXPORT_SYMBOL_GPL(of_usb_get_dr_mode);
+
+static const char *const usb_maximum_speed[] = {
+	[USB_SPEED_UNKNOWN]	= "",
+	[USB_SPEED_LOW]		= "lowspeed",
+	[USB_SPEED_FULL]	= "fullspeed",
+	[USB_SPEED_HIGH]	= "highspeed",
+	[USB_SPEED_WIRELESS]	= "wireless",
+	[USB_SPEED_SUPER]	= "superspeed",
+};
+
+/**
+ * of_usb_get_maximum_speed - Get maximum requested speed for a given USB
+ * controller.
+ * @np: Pointer to the given device_node
+ *
+ * The function gets the maximum speed string from property "maximum-speed",
+ * and returns the corresponding enum usb_device_speed.
+ */
+enum usb_device_speed of_usb_get_maximum_speed(struct device_node *np)
+{
+	const char *maximum_speed;
+	int err;
+	int i;
+
+	err = of_property_read_string(np, "maximum-speed", &maximum_speed);
+	if (err < 0)
+		return USB_SPEED_UNKNOWN;
+
+	for (i = 0; i < ARRAY_SIZE(usb_maximum_speed); i++)
+		if (strcmp(maximum_speed, usb_maximum_speed[i]) == 0)
+			return i;
+
+	return USB_SPEED_UNKNOWN;
+}
+EXPORT_SYMBOL_GPL(of_usb_get_maximum_speed);
+
 #endif
 
 MODULE_LICENSE("GPL");
diff --git a/include/linux/usb/of.h b/include/linux/usb/of.h
index e460a24..45d33d9 100644
--- a/include/linux/usb/of.h
+++ b/include/linux/usb/of.h
@@ -13,6 +13,7 @@
 #ifdef CONFIG_OF
 enum usb_phy_interface of_usb_get_phy_mode(struct device_node *np);
 enum usb_dr_mode of_usb_get_dr_mode(struct device_node *np);
+enum usb_device_speed of_usb_get_maximum_speed(struct device_node *np);
 #else
 static inline enum usb_phy_interface of_usb_get_phy_mode(struct device_node *np)
 {
@@ -23,6 +24,11 @@ static inline enum usb_dr_mode of_usb_get_dr_mode(struct device_node *np)
 {
 	return USB_DR_MODE_UNKNOWN;
 }
+static inline enum usb_device_speed
+of_usb_get_maximum_speed(struct device_node *np)
+{
+	return USB_SPEED_UNKNOWN;
+}
 #endif
 
 #endif /* __LINUX_USB_OF_H */
-- 
1.7.5.4

