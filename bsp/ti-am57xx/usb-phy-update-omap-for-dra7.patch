From bdfdd504ec80c61d93185959d53ea83734731ca4 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 9 Jul 2014 13:18:40 +0800
Subject: [PATCH 216/263] usb: phy: update omap for dra7

These commits comes from the following git repo:

      git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

8b181260 usb: phy: omap_control_usb: addition of a dummy control register
7682ea81 usb: omap_control_usb: addition of a phy variation.
f8da37e2 usb: phy: omap_control_usb: removal of globals

We can't cherry-pick all of them since there is a big change
on phy topology structure, so this is a manual pick-up.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 Documentation/devicetree/bindings/usb/omap-usb.txt |    3 +-
 drivers/usb/phy/phy-omap-control.c                 |   99 +++++++++++++-------
 drivers/usb/phy/phy-omap-usb2.c                    |   27 +++++-
 drivers/usb/phy/phy-omap-usb3.c                    |   23 +++++-
 drivers/usb/usb-common.c                           |   10 +-
 include/linux/usb/omap_control_usb.h               |   10 ++-
 include/linux/usb/omap_usb.h                       |    1 +
 7 files changed, 125 insertions(+), 48 deletions(-)

diff --git a/Documentation/devicetree/bindings/usb/omap-usb.txt b/Documentation/devicetree/bindings/usb/omap-usb.txt
index 1bf6d60..8b5db30 100644
--- a/Documentation/devicetree/bindings/usb/omap-usb.txt
+++ b/Documentation/devicetree/bindings/usb/omap-usb.txt
@@ -84,7 +84,8 @@ Required properties:
    usb mailbox or usb3 phy power. omap4 has usb mailbox in control module to
    notify events to the musb core and omap5 has usb3 phy power register to
    power on usb3 phy. Should be "1" if it has mailbox and "2" if it has usb3
-   phy power.
+   phy power (usb3 phy power indicates the presense of a usb2 and usb3 phy),
+   should be "3" is it has only usb2 phy power.
 
 omap_control_usb: omap-control-usb@4a002300 {
 	compatible = "ti,omap-control-usb";
diff --git a/drivers/usb/phy/phy-omap-control.c b/drivers/usb/phy/phy-omap-control.c
index 1419ced..527be7e 100644
--- a/drivers/usb/phy/phy-omap-control.c
+++ b/drivers/usb/phy/phy-omap-control.c
@@ -25,25 +25,6 @@
 #include <linux/clk.h>
 #include <linux/usb/omap_control_usb.h>
 
-static struct omap_control_usb *control_usb;
-
-/**
- * omap_get_control_dev - returns the device pointer for this control device
- *
- * This API should be called to get the device pointer for this control
- * module device. This device pointer should be used for called other
- * exported API's in this driver.
- *
- * To be used by PHY driver and glue driver.
- */
-struct device *omap_get_control_dev(void)
-{
-	if (!control_usb)
-		return ERR_PTR(-ENODEV);
-
-	return control_usb->dev;
-}
-EXPORT_SYMBOL_GPL(omap_get_control_dev);
 
 /**
  * omap_control_usb3_phy_power - power on/off the serializer using control
@@ -93,14 +74,33 @@ void omap_control_usb_phy_power(struct device *dev, int on)
 	u32 val;
 	struct omap_control_usb	*control_usb = dev_get_drvdata(dev);
 
-	val = readl(control_usb->dev_conf);
-
-	if (on)
-		val &= ~OMAP_CTRL_DEV_PHY_PD;
-	else
-		val |= OMAP_CTRL_DEV_PHY_PD;
+	if (control_usb->type == OMAP_CTRL_DEV_TYPE2) {
+		val = readl(control_usb->dev_conf);
+		if (on)
+			val &= ~OMAP_CTRL_DEV_PHY_PD;
+		else
+			val |= OMAP_CTRL_DEV_PHY_PD;
 
-	writel(val, control_usb->dev_conf);
+		writel(val, control_usb->dev_conf);
+	} else {
+		if (on) {
+			val = readl(control_usb->dummy_reg);
+			val |= 0x100;
+			writel(val , control_usb->dummy_reg);
+
+			val = readl(control_usb->ctrl_core_srcomp_north_side);
+			val &= ~OMAP_CTRL_USB_SRCOMP_NORTH_SIDE_PD;
+			writel(val, control_usb->ctrl_core_srcomp_north_side);
+		} else {
+			val = readl(control_usb->ctrl_core_srcomp_north_side);
+			val |= OMAP_CTRL_USB_SRCOMP_NORTH_SIDE_PD;
+			writel(val, control_usb->ctrl_core_srcomp_north_side);
+
+			val = readl(control_usb->dummy_reg);
+			val &= ~0x100;
+			writel(val , control_usb->dummy_reg);
+		}
+	}
 }
 EXPORT_SYMBOL_GPL(omap_control_usb_phy_power);
 
@@ -172,10 +172,12 @@ void omap_control_usb_set_mode(struct device *dev,
 {
 	struct omap_control_usb	*ctrl_usb;
 
-	if (IS_ERR(dev) || control_usb->type != OMAP_CTRL_DEV_TYPE1)
+	if (IS_ERR(dev))
 		return;
 
 	ctrl_usb = dev_get_drvdata(dev);
+	if (ctrl_usb->type != OMAP_CTRL_DEV_TYPE1)
+		return;
 
 	switch (mode) {
 	case USB_MODE_HOST:
@@ -198,6 +200,7 @@ static int omap_control_usb_probe(struct platform_device *pdev)
 	struct resource	*res;
 	struct device_node *np = pdev->dev.of_node;
 	struct omap_control_usb_platform_data *pdata = pdev->dev.platform_data;
+	struct omap_control_usb               *control_usb;
 
 	control_usb = devm_kzalloc(&pdev->dev, sizeof(*control_usb),
 		GFP_KERNEL);
@@ -217,12 +220,6 @@ static int omap_control_usb_probe(struct platform_device *pdev)
 
 	control_usb->dev	= &pdev->dev;
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-		"control_dev_conf");
-	control_usb->dev_conf = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(control_usb->dev_conf))
-		return PTR_ERR(control_usb->dev_conf);
-
 	if (control_usb->type == OMAP_CTRL_DEV_TYPE1) {
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 			"otghs_control");
@@ -234,11 +231,43 @@ static int omap_control_usb_probe(struct platform_device *pdev)
 
 	if (control_usb->type == OMAP_CTRL_DEV_TYPE2) {
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+			"control_dev_conf");
+		control_usb->dev_conf = devm_request_and_ioremap(&pdev->dev, res);
+		if (!control_usb->dev_conf) {
+			dev_err(&pdev->dev, "Failed to obtain io memory\n");
+			return -EADDRNOTAVAIL;
+		}
+
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 			"phy_power_usb");
 		control_usb->phy_power = devm_ioremap_resource(
 			&pdev->dev, res);
 		if (IS_ERR(control_usb->phy_power))
 			return PTR_ERR(control_usb->phy_power);
+	}
+
+	if (control_usb->type == OMAP_CTRL_DEV_TYPE3) {
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+			"ctrl_core_srcomp_north_side");
+		control_usb->ctrl_core_srcomp_north_side =
+				devm_request_and_ioremap(&pdev->dev, res);
+		if (!control_usb->ctrl_core_srcomp_north_side) {
+			dev_err(&pdev->dev, "Failed to obtain io memory\n");
+			return -EADDRNOTAVAIL;
+		}
+
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+			"dummy_reg");
+		control_usb->dummy_reg = devm_request_and_ioremap(&pdev->dev, res);
+		if (!control_usb->dummy_reg) {
+			dev_err(&pdev->dev, "Failed to obtain io memory\n");
+			dev_err(&pdev->dev, "#RK: DUMMY not found  \n");
+			return -EADDRNOTAVAIL;
+		}
+	}
+
+	if ((control_usb->type == OMAP_CTRL_DEV_TYPE2) ||
+		(control_usb->type == OMAP_CTRL_DEV_TYPE3)) {
 
 		control_usb->sys_clk = devm_clk_get(control_usb->dev,
 			"sys_clkin");
@@ -248,7 +277,6 @@ static int omap_control_usb_probe(struct platform_device *pdev)
 		}
 	}
 
-
 	dev_set_drvdata(control_usb->dev, control_usb);
 
 	return 0;
@@ -257,6 +285,9 @@ static int omap_control_usb_probe(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static const struct of_device_id omap_control_usb_id_table[] = {
 	{ .compatible = "ti,omap-control-usb" },
+	{ .compatible = "ti,control-phy-usb2" },
+	{ .compatible = "ti,control-phy-pipe3" },
+	{ .compatible = "ti,control-phy-dra7usb2" },
 	{}
 };
 MODULE_DEVICE_TABLE(of, omap_control_usb_id_table);
diff --git a/drivers/usb/phy/phy-omap-usb2.c b/drivers/usb/phy/phy-omap-usb2.c
index 2439d33..4c06e67 100644
--- a/drivers/usb/phy/phy-omap-usb2.c
+++ b/drivers/usb/phy/phy-omap-usb2.c
@@ -29,6 +29,7 @@
 #include <linux/delay.h>
 #include <linux/usb/omap_control_usb.h>
 #include <linux/of_device.h>
+#include <linux/of_platform.h>
 
 #define USB2PHY_DISCON_BYP_LATCH (1 << 31)
 #define	USB2PHY_ANA_CONFIG1	0x4c
@@ -179,8 +180,8 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	struct usb_phy_data *phy_data;
 	struct device_node *node = pdev->dev.of_node;
 	const char *clk_name;
-	struct device_node		*node = pdev->dev.of_node;
-	const char   			*clk_name;
+	struct device_node		*omap_control_usb_node;
+	struct platform_device		*pdev_control_usb;
 
 	of_id = of_match_device(of_match_ptr(omap_usb2_id_table), &pdev->dev);
 
@@ -208,18 +209,33 @@ static int omap_usb2_probe(struct platform_device *pdev)
 	phy->phy.set_suspend	= omap_usb2_suspend;
 	phy->phy.otg		= otg;
 	phy->phy.type		= USB_PHY_TYPE_USB2;
-	phy->control_dev 	= omap_get_control_dev();
+	omap_control_usb_node   = of_parse_phandle(node, "ctrl-module", 0);
 	phy->phy.init		= omap_usb_init;
 
-	if (phy_data->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT)
+	if (phy_data && phy_data->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT)
 		phy->flags |= OMAP_USB2_CALIBRATE_FALSE_DISCONNECT;
 
-	phy->control_dev = omap_get_control_dev();
+	if (IS_ERR(omap_control_usb_node)) {
+		dev_err(&pdev->dev, "Failed to find ctrl-module\n");
+		return -EPROBE_DEFER;
+	}
+
+	pdev_control_usb = of_find_device_by_node(omap_control_usb_node);
+
+	if (IS_ERR(pdev_control_usb)) {
+		dev_dbg(&pdev->dev, "Attempt to get the platform control usb failed\n");
+		return -EPROBE_DEFER;
+	}
+	phy->control_dev = &pdev_control_usb->dev;
+
 	if (IS_ERR(phy->control_dev)) {
 		dev_dbg(&pdev->dev, "Failed to get control device\n");
 		return -ENODEV;
 	}
 
+	dev_dbg(&pdev->dev, "got control usb name %s\n",
+					dev_name(phy->control_dev));
+	phy->control_node	= omap_control_usb_node;
 	phy->is_suspended	= 1;
 	omap_control_usb_phy_power(phy->control_dev, 0);
 
@@ -270,6 +286,7 @@ static int omap_usb2_remove(struct platform_device *pdev)
 	struct omap_usb	*phy = platform_get_drvdata(pdev);
 
 	clk_unprepare(phy->wkupclk);
+	of_node_put(phy->control_node);
 	if (!IS_ERR(phy->optclk))
 		clk_unprepare(phy->optclk);
 	usb_remove_phy(&phy->phy);
diff --git a/drivers/usb/phy/phy-omap-usb3.c b/drivers/usb/phy/phy-omap-usb3.c
index be3bd47..d64ab96 100644
--- a/drivers/usb/phy/phy-omap-usb3.c
+++ b/drivers/usb/phy/phy-omap-usb3.c
@@ -26,6 +26,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/delay.h>
 #include <linux/usb/omap_control_usb.h>
+#include <linux/of_platform.h>
 
 #define	PLL_STATUS		0x00000004
 #define	PLL_GO			0x00000008
@@ -199,6 +200,8 @@ static int omap_usb3_probe(struct platform_device *pdev)
 	struct omap_usb			*phy;
 	struct resource			*res;
 	struct device_node		*node = pdev->dev.of_node;
+	struct device_node		*omap_control_usb_node;
+	struct platform_device		*pdev_control_usb;
 	const char   			*clk_name;
  
 	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
@@ -255,12 +258,29 @@ static int omap_usb3_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	phy->control_dev = omap_get_control_dev();
+	omap_control_usb_node   = of_parse_phandle(node, "ctrl-module", 0);
+	if (IS_ERR(omap_control_usb_node)) {
+		dev_err(&pdev->dev, "Failed to find ctrl-module\n");
+		return -EPROBE_DEFER;
+	}
+
+	pdev_control_usb = of_find_device_by_node(omap_control_usb_node);
+	if (IS_ERR(pdev_control_usb)) {
+		dev_dbg(&pdev->dev, "Attempt to get the platform control usb failed\n");
+		return -EPROBE_DEFER;
+	}
+
+	phy->control_dev = &pdev_control_usb->dev;
+
 	if (IS_ERR(phy->control_dev)) {
 		dev_dbg(&pdev->dev, "Failed to get control device\n");
 		return -ENODEV;
 	}
 
+	dev_dbg(&pdev->dev, "got control usb name %s\n",
+					dev_name(phy->control_dev));
+	phy->control_node = omap_control_usb_node;
+
 	omap_control_usb3_phy_power(phy->control_dev, 0);
 	usb_add_phy_dev(&phy->phy);
 
@@ -278,6 +298,7 @@ static int omap_usb3_remove(struct platform_device *pdev)
 
 	clk_unprepare(phy->wkupclk);
 	clk_unprepare(phy->optclk);
+	of_node_put(phy->control_node);
 	usb_remove_phy(&phy->phy);
 	if (!pm_runtime_suspended(&pdev->dev))
 		pm_runtime_put(&pdev->dev);
diff --git a/drivers/usb/usb-common.c b/drivers/usb/usb-common.c
index e702d22..4fefe67 100644
--- a/drivers/usb/usb-common.c
+++ b/drivers/usb/usb-common.c
@@ -114,12 +114,12 @@ enum usb_dr_mode of_usb_get_dr_mode(struct device_node *np)
 EXPORT_SYMBOL_GPL(of_usb_get_dr_mode);
 
 static const char *const usb_maximum_speed[] = {
-	[USB_SPEED_UNKNOWN]	= "",
-	[USB_SPEED_LOW]		= "lowspeed",
-	[USB_SPEED_FULL]	= "fullspeed",
-	[USB_SPEED_HIGH]	= "highspeed",
+	[USB_SPEED_UNKNOWN]	= "UNKNOWN",
+	[USB_SPEED_LOW]		= "low-speed",
+	[USB_SPEED_FULL]	= "full-speed",
+	[USB_SPEED_HIGH]	= "high-speed",
 	[USB_SPEED_WIRELESS]	= "wireless",
-	[USB_SPEED_SUPER]	= "superspeed",
+	[USB_SPEED_SUPER]	= "super-speed",
 };
 
 /**
diff --git a/include/linux/usb/omap_control_usb.h b/include/linux/usb/omap_control_usb.h
index 27b5b8c..a630a61 100644
--- a/include/linux/usb/omap_control_usb.h
+++ b/include/linux/usb/omap_control_usb.h
@@ -25,6 +25,8 @@ struct omap_control_usb {
 	u32 __iomem *dev_conf;
 	u32 __iomem *otghs_control;
 	u32 __iomem *phy_power;
+	u32 __iomem *ctrl_core_srcomp_north_side;
+	u32 __iomem *dummy_reg;
 
 	struct clk *sys_clk;
 
@@ -43,8 +45,10 @@ enum omap_control_usb_mode {
 };
 
 /* To differentiate ctrl module IP having either mailbox or USB3 PHY power */
-#define	OMAP_CTRL_DEV_TYPE1		0x1
-#define	OMAP_CTRL_DEV_TYPE2		0x2
+#define	OMAP_CTRL_DEV_TYPE1		0x1	/* mailbox */
+#define	OMAP_CTRL_DEV_TYPE2		0x2	/* has a usb2 and usb3 phy */
+#define	OMAP_CTRL_DEV_TYPE3		0x3	/* has only a usb2 phy */
+
 
 #define	OMAP_CTRL_DEV_PHY_PD		BIT(0)
 
@@ -63,6 +67,8 @@ enum omap_control_usb_mode {
 #define	OMAP_CTRL_USB3_PHY_TX_RX_POWERON	0x3
 #define	OMAP_CTRL_USB3_PHY_TX_RX_POWEROFF	0x0
 
+#define OMAP_CTRL_USB_SRCOMP_NORTH_SIDE_PD	BIT(28)
+
 #if IS_ENABLED(CONFIG_OMAP_CONTROL_USB)
 extern struct device *omap_get_control_dev(void);
 extern void omap_control_usb_phy_power(struct device *dev, int on);
diff --git a/include/linux/usb/omap_usb.h b/include/linux/usb/omap_usb.h
index 656bfd0..650a4aa 100644
--- a/include/linux/usb/omap_usb.h
+++ b/include/linux/usb/omap_usb.h
@@ -45,6 +45,7 @@ struct omap_usb {
 	struct clk		*sys_clk;
 	struct clk		*optclk;
 	u8			is_suspended:1;
+	struct device_node	*control_node;
 	void __iomem		*phy_base;
 	u32			flags;
 };
-- 
1.7.5.4

