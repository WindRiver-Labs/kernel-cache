From 7b5a2a3bfbe67fba39cb69dce1115af273ae1e86 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 10 Jul 2014 16:57:20 +0800
Subject: [PATCH 223/263] This adds OTG support to the xhci driver

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Specifically for the Synopsys PCI controller, but the code should be reusable for other controllers.

The Synopsys controller requires disabling the host mode driver when
switching to peripheral mode, then re-enabling it when switching
back to host mode. We do that by calling usb_remove_hcd() /
usb_add_hcd().

This requires a small change to usb_hcd_pci_remove(), to test
whether usb_remove_hcd() has already been called and so should not
be called again when the driver is unloaded. We use the
hcd->rh_pollable flag for this

Change-Id: I6ec6b600506d2d5e4781d800c06739133b71b702
Signed-off-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Signed-off-by: Ravi Babu <ravibabu@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/core/hub.c       |    1 +
 drivers/usb/host/xhci-hub.c  |   20 +++++++++++++++++
 drivers/usb/host/xhci-plat.c |   49 +++++++++++++++++++++++++++++++++++++++--
 drivers/usb/host/xhci.c      |   29 ++++++++++++++++++------
 drivers/usb/host/xhci.h      |    9 +++++++
 5 files changed, 97 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index dec4239..126633f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -598,6 +598,7 @@ void usb_kick_khubd(struct usb_device *hdev)
 	if (hub)
 		kick_khubd(hub);
 }
+EXPORT_SYMBOL_GPL(usb_kick_khubd);
 
 /*
  * Let the USB core know that a USB 3.0 device has sent a Function Wake Device
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index f6395dd..a4a14d8 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -47,6 +47,26 @@ static u8 usb_bos_descriptor [] = {
 	0x00, 0x00			/* __le16 bU2DevExitLat, set later. */
 };
 
+#ifdef CONFIG_USB_OTG
+int xhci_start_port_reset(struct usb_hcd *hcd, unsigned port)
+{
+	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
+	u32 status;
+
+	if (!port)
+		return -EINVAL;
+	port--;
+
+	/* start port reset before HNP protocol times out */
+	status = xhci_readl(xhci, &xhci->op_regs->port_status_base + port * 16);
+	status |= PORT_RESET;
+
+	/* khubd will finish the reset later */
+	xhci_writel(xhci, status, &xhci->op_regs->port_status_base + port * 16);
+
+	return 0;
+}
+#endif
 
 static void xhci_common_hub_descriptor(struct xhci_hcd *xhci,
 		struct usb_hub_descriptor *desc, int ports)
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 6e70ce9..9811b66 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -14,17 +14,20 @@
 #include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/usb/otg.h>
 
 #include "xhci.h"
 
 static void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)
 {
+ 	xhci->quirks |= XHCI_BROKEN_MSI;
 	/*
 	 * As of now platform drivers don't provide MSI support so we ensure
 	 * here that the generic code does not try to make a pci_dev from our
 	 * dev struct in order to setup MSI
 	 */
 	xhci->quirks |= XHCI_PLAT;
+	xhci->quirks |= XHCI_DWC3_OTG;
 }
 
 /* called during probe() after chip reset completes */
@@ -80,6 +83,7 @@ static const struct hc_driver xhci_plat_xhci_driver = {
 	.hub_status_data =	xhci_hub_status_data,
 	.bus_suspend =		xhci_bus_suspend,
 	.bus_resume =		xhci_bus_resume,
+	.start_port_reset =	xhci_start_port_reset,
 };
 
 static int xhci_plat_probe(struct platform_device *pdev)
@@ -91,6 +95,7 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	int			ret;
 	int			irq;
 
+	printk("### %s %d \n", __func__,__LINE__);
 	if (usb_disabled())
 		return -ENODEV;
 
@@ -149,6 +154,26 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	if (ret)
 		goto put_usb3_hcd;
 
+	xhci->loaded = 1;
+
+#ifdef CONFIG_USB_OTG
+	hcd->phy = usb_get_phy(USB_PHY_TYPE_USB3);
+	if (!IS_ERR(hcd->phy)) {
+		if (hcd->phy && hcd->phy->otg) {
+			dev_dbg(&pdev->dev, "%s otg support available\n",
+					__func__);
+			ret = otg_set_host(hcd->phy->otg, &hcd->self);
+			if (!ret) {
+				xhci->shared_hcd->phy = hcd->phy;
+				goto otg_done;
+			}
+		}
+		usb_put_phy(hcd->phy);
+	}
+	hcd->phy = NULL;
+otg_done:
+#endif
+	printk("### %s %d \n", __func__,__LINE__);
 	return 0;
 
 put_usb3_hcd:
@@ -174,10 +199,28 @@ static int xhci_plat_remove(struct platform_device *dev)
 	struct usb_hcd	*hcd = platform_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 
-	usb_remove_hcd(xhci->shared_hcd);
-	usb_put_hcd(xhci->shared_hcd);
+#ifdef CONFIG_USB_OTG
+	if (hcd->phy) {
+		if (!IS_ERR(hcd->phy)) {
+			if (hcd->phy->otg)
+				otg_set_host(hcd->phy->otg, NULL);
+			usb_put_phy(hcd->phy);
+		}
+		hcd->phy = NULL;
+		if (xhci->shared_hcd)
+			xhci->shared_hcd->phy = NULL;
+	}
+#endif
 
-	usb_remove_hcd(hcd);
+	if (xhci->shared_hcd) {
+		if (xhci->loaded)
+			usb_remove_hcd(xhci->shared_hcd);
+		usb_put_hcd(xhci->shared_hcd);
+	}
+
+	if (xhci->loaded)
+		usb_remove_hcd(hcd);
+ 
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_put_hcd(hcd);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index c693aee..47e0450 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -164,11 +164,12 @@ int xhci_reset(struct xhci_hcd *xhci)
 
 	xhci_dbg(xhci, "// Reset the HC\n");
 	command = xhci_readl(xhci, &xhci->op_regs->command);
-	command |= CMD_RESET;
+	command |= (xhci->quirks & XHCI_DWC3_OTG) ? CMD_LRESET : CMD_RESET;
 	xhci_writel(xhci, command, &xhci->op_regs->command);
 
 	ret = xhci_handshake(xhci, &xhci->op_regs->command,
-			CMD_RESET, 0, 10 * 1000 * 1000);
+			(xhci->quirks & XHCI_DWC3_OTG) ? CMD_LRESET : CMD_RESET,
+			0, 10 * 1000 * 1000);
 	if (ret)
 		return ret;
 
@@ -719,7 +720,8 @@ void xhci_stop(struct usb_hcd *hcd)
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
 	if (!usb_hcd_is_primary_hcd(hcd)) {
-		xhci_only_stop_hcd(xhci->shared_hcd);
+		if (!(xhci->quirks & XHCI_DWC3_OTG))
+			xhci_only_stop_hcd(xhci->shared_hcd);
 		return;
 	}
 
@@ -4641,17 +4643,24 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 	struct device		*dev = hcd->self.controller;
 	int			retval;
 	u32			temp;
+	bool			allocated = false;
 
+	printk("### %s %d \n", __func__,__LINE__);
 	/* Accept arbitrarily long scatter-gather lists */
 	hcd->self.sg_tablesize = ~0;
 	/* XHCI controllers don't stop the ep queue on short packets :| */
 	hcd->self.no_stop_on_short = 1;
 
 	if (usb_hcd_is_primary_hcd(hcd)) {
-		xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
-		if (!xhci)
-			return -ENOMEM;
-		*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
+		if (*((struct xhci_hcd **) hcd->hcd_priv) == NULL) {
+			xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
+			if (!xhci)
+				return -ENOMEM;
+			*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
+			allocated = true;
+		} else {
+			xhci = *((struct xhci_hcd **) hcd->hcd_priv);
+		}
 		xhci->main_hcd = hcd;
 		/* Mark the first roothub as being USB 2.0.
 		 * The xHCI driver will register the USB 3.0 roothub.
@@ -4730,7 +4739,11 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 	xhci_dbg(xhci, "Called HCD init\n");
 	return 0;
 error:
-	kfree(xhci);
+	if (allocated) {
+		*((struct xhci_hcd **) hcd->hcd_priv) = NULL;
+		kfree(xhci);
+	}
+
 	return retval;
 }
 
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a1e6dd9..0425455 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1554,6 +1554,7 @@ struct xhci_hcd {
 #define XHCI_COMP_MODE_QUIRK	(1 << 14)
 #define XHCI_AVOID_BEI		(1 << 15)
 #define XHCI_PLAT		(1 << 16)
+#define XHCI_DWC3_OTG		(1 << 17)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
@@ -1570,6 +1571,8 @@ struct xhci_hcd {
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
+	/* true if HCDs have been loaded by usb_add_hcd() */
+	unsigned		loaded:1;
 	/* cached usb2 extened protocol capabilites */
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
@@ -1878,6 +1881,12 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
 int xhci_find_raw_port_number(struct usb_hcd *hcd, int port1);
 
+#ifdef CONFIG_USB_OTG
+int xhci_start_port_reset(struct usb_hcd *hcd, unsigned port);
+#else
+#define xhci_start_port_reset	NULL
+#endif
+
 #ifdef CONFIG_PM
 int xhci_bus_suspend(struct usb_hcd *hcd);
 int xhci_bus_resume(struct usb_hcd *hcd);
-- 
1.7.5.4

