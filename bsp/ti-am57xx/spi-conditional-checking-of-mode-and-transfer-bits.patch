From d713bfa3745a00403720e4b726ef9f4d96e9ad61 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 17 Jul 2014 13:26:24 +0800
Subject: [PATCH 115/263] spi: conditional checking of mode and transfer bits.

This commit db90a441 from:

 git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

fix the previous patch some mistake below:
1. DT in slave node, use "spi-tx-nbits = <1/2/4>" in place of using
   "spi-tx-dual, spi-tx-quad" directly, same to rx. So correct the
   previous way to get the property in @of_register_spi_devices().
2. Change the value of transfer bit macro(SPI_NBITS_SINGLE, SPI_NBITS_DUAL
   SPI_NBITS_QUAD) to 0x01, 0x02 and 0x04 to match the actual wires.
3. Add the following check
   (1)keep the tx_nbits and rx_nbits in spi_transfer is not beyond the
      single, dual and quad.
   (2)keep tx_nbits and rx_nbits are contained by @spi_device->mode
      example: if @spi_device->mode = DUAL, then tx/rx_nbits can not be set
               to QUAD(SPI_NBITS_QUAD)
   (3)if "@spi_device->mode & SPI_3WIRE", then tx/rx_nbits should be in
      single(SPI_NBITS_SINGLE)

Checking of the tx/rx transfer bits and mode bits should be done conditionally
based on type of buffer filled else EINVAL condition will
always get hit either for rx or tx.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
Signed-off-by: Mark Brown <broonie@linaro.org>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/spi/spi.c |   56 ++++++++++++++++++++++++++++------------------------
 1 files changed, 30 insertions(+), 26 deletions(-)

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a85699a..25bc145 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1491,33 +1491,37 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 		 * 2. keep tx/rx_nbits is contained by mode in spi_device
 		 * 3. if SPI_3WIRE, tx/rx_nbits should be in single
 		 */
-		if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
-			xfer->tx_nbits != SPI_NBITS_DUAL &&
-			xfer->tx_nbits != SPI_NBITS_QUAD)
-			return -EINVAL;
-		if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
-			!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
-			return -EINVAL;
-		if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
-			!(spi->mode & SPI_TX_QUAD))
-			return -EINVAL;
-		if ((spi->mode & SPI_3WIRE) &&
-			(xfer->tx_nbits != SPI_NBITS_SINGLE))
-			return -EINVAL;
+		if (xfer->tx_buf) {
+			if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
+				xfer->tx_nbits != SPI_NBITS_DUAL &&
+				xfer->tx_nbits != SPI_NBITS_QUAD)
+				return -EINVAL;
+			if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
+				!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
+				return -EINVAL;
+			if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
+				!(spi->mode & SPI_TX_QUAD))
+				return -EINVAL;
+			if ((spi->mode & SPI_3WIRE) &&
+				(xfer->tx_nbits != SPI_NBITS_SINGLE))
+				return -EINVAL;
+		}
 		/* check transfer rx_nbits */
-		if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
-			xfer->rx_nbits != SPI_NBITS_DUAL &&
-			xfer->rx_nbits != SPI_NBITS_QUAD)
-			return -EINVAL;
-		if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
-			!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
-			return -EINVAL;
-		if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
-			!(spi->mode & SPI_RX_QUAD))
-			return -EINVAL;
-		if ((spi->mode & SPI_3WIRE) &&
-			(xfer->rx_nbits != SPI_NBITS_SINGLE))
-			return -EINVAL;
+		if (xfer->rx_buf) {
+			if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
+				xfer->rx_nbits != SPI_NBITS_DUAL &&
+				xfer->rx_nbits != SPI_NBITS_QUAD)
+				return -EINVAL;
+			if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
+				!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
+				return -EINVAL;
+			if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
+				!(spi->mode & SPI_RX_QUAD))
+				return -EINVAL;
+			if ((spi->mode & SPI_3WIRE) &&
+				(xfer->rx_nbits != SPI_NBITS_SINGLE))
+				return -EINVAL;
+		}
 	}
 
 	message->spi = spi;
-- 
1.7.5.4

