From d7fa8f045bc7b24e28acc71d5f9f74fcef1ed064 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 21 Jul 2014 14:58:13 +0800
Subject: [PATCH 146/263] arm: omap2+: dra7-evm: add GCC initialization
 support

This patch is to add device initialization from

  git://git.omapzoom.org/kernel/omap.git

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/devices.c |   62 +++++++++++++++++++++++++++++++++++++++++
 1 files changed, 62 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index bc89028..b0615d2 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -20,6 +20,7 @@
 #include <linux/pinctrl/machine.h>
 #include <linux/platform_data/omap4-keypad.h>
 #include <linux/platform_data/mailbox-omap.h>
+#include <linux/platform_data/omap_gcx.h>
 #include <linux/wl12xx.h>
 
 #include <asm/mach-types.h>
@@ -27,6 +28,7 @@
 
 #include <linux/omap-dma.h>
 
+#include "omap-pm.h"
 #include "iomap.h"
 #include "omap_hwmod.h"
 #include "omap_device.h"
@@ -449,6 +451,63 @@ static void __init omap_init_aes(void)
 	WARN(IS_ERR(pdev), "Can't build omap_device for omap-aes\n");
 }
 
+#ifdef CONFIG_GCCORE
+static int gcxxx_scale_dev(struct device *dev, unsigned long val);
+static int gcxxx_set_l3_bw(struct device *dev, unsigned long val);
+
+static struct omap_gcx_platform_data omap_gcxxx = {
+	.get_context_loss_count = omap_pm_get_dev_context_loss_count,
+	.scale_dev = gcxxx_scale_dev,
+	.set_bw = gcxxx_set_l3_bw,
+};
+
+static int gcxxx_scale_dev(struct device *dev, unsigned long val)
+{
+	/*omap_device_scale(dev, val) is not supported, returning with no-op
+	 * for now. */
+	return 0;
+}
+
+static int gcxxx_set_l3_bw(struct device *dev, unsigned long val)
+{
+	return omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, val);
+}
+
+int __init gcxxx_init(void)
+{
+	int retval = 0;
+	struct omap_hwmod *oh;
+	struct platform_device *pdev;
+	/*struct omap_device *od;
+	struct device *dev;*/
+	const char *oh_name = "bb2d";
+	const char *dev_name = "gccore";
+
+	/*
+	 * Hwmod lookup will fail in case our platform doesn't support the
+	 * hardware spinlock module, so it is safe to run this initcall
+	 * on all omaps
+	 */
+	oh = omap_hwmod_lookup(oh_name);
+	if (oh == NULL)
+		return -EINVAL;
+
+	omap_gcxxx.regbase = omap_hwmod_get_mpu_rt_va(oh);
+	omap_gcxxx.is_hw_present = (soc_is_omap543x()
+				|| soc_is_dra7xx()) ? true : false;
+	pdev = omap_device_build(dev_name, 0, oh, &omap_gcxxx,
+				sizeof(omap_gcxxx));
+	printk("%s %d regbase =0x%p present %d \n", __func__,__LINE__, omap_gcxxx.regbase,omap_gcxxx.is_hw_present);
+	if (IS_ERR(pdev)) {
+		pr_err("Can't build omap_device for %s:%s\n", dev_name,
+								oh_name);
+		retval = PTR_ERR(pdev);
+	} else
+		printk("GCCore initialization OK %s %d \n", __func__,__LINE__);
+	return retval;
+}
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_VIDEO_OMAP2_VOUT) || \
@@ -524,6 +583,9 @@ static int __init omap2_init_devices(void)
 	 */
 	omap_init_audio();
 	omap_init_camera();
+#ifdef CONFIG_GCCORE
+	gcxxx_init();
+#endif
 	omap_init_hdmi_audio();
 	/* If dtb is there, the devices will be created dynamically */
 	if (!of_have_populated_dt()) {
-- 
1.7.5.4

