From 34533ae86a0a071d77d90591653cf6a847d94c06 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 7 Jul 2014 14:42:06 +0800
Subject: [PATCH 198/263] usb: dwc3: drd: adding usb-id handler to support drd

The ad57a440 comes from the following git repo:

  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

adding usbid handler to update the utmi status based
on the usb-mode is device or host to support dual role

Change-Id: I352898814faed8aed66e4165270bbd067850dc98
Signed-off-by: Ravi Babu <ravibabu@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/dwc3/core.c       |    6 +++-
 drivers/usb/dwc3/dwc3-omap.c  |   48 ++++++++++++++++++-----------------------
 include/linux/usb/dwc3-omap.h |    6 +++-
 3 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 7eabcae..ebc4338 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -530,8 +530,10 @@ static int dwc3_probe(struct platform_device *pdev)
 		 * vbus change event, hence set vbus and session
 		 * to cause connect to host-machine
 		 */
-		if (of_device_is_compatible(node, "synopsys,dra7xx-dwc3"))
-			dwc3_omap_vbus_connect(dwc->dev->parent);
+		if (of_device_is_compatible(node, "synopsys,dra7xx-dwc3")) {
+			dwc3_omap_usbvbus_id_handler(dwc->dev->parent,
+				OMAP_DWC3_VBUS_VALID);
+		}
 
 		dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
 		ret = dwc3_gadget_init(dwc);
diff --git a/drivers/usb/dwc3/dwc3-omap.c b/drivers/usb/dwc3/dwc3-omap.c
index 1d7a841..8097f6b 100644
--- a/drivers/usb/dwc3/dwc3-omap.c
+++ b/drivers/usb/dwc3/dwc3-omap.c
@@ -31,6 +31,7 @@
 #include <linux/of_platform.h>
 
 #include <linux/usb/otg.h>
+#include <linux/usb/dwc3-omap.h>
 
 /*
  * All these registers belong to OMAP's Wrapper around the
@@ -197,7 +198,8 @@ static void dwc3_omap_write_irq0_set(struct dwc3_omap *omap, u32 value)
 						omap->irq0_offset, value);
 }
 
-int dwc3_omap_vbus_connect(struct device *dev)
+int dwc3_omap_usbvbus_id_handler(struct device *dev,
+	enum omap_dwc3_vbus_id_status status)
 {
 	u32			val;
 	struct dwc3_omap	*omap;
@@ -214,64 +216,56 @@ int dwc3_omap_vbus_connect(struct device *dev)
 		return -ENODEV;
 
 	val = dwc3_omap_readl(omap->base, USBOTGSS_UTMI_OTG_STATUS);
-	val &= ~USBOTGSS_UTMI_OTG_STATUS_SESSEND;
-	val |= USBOTGSS_UTMI_OTG_STATUS_IDDIG
-			| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID
-			| USBOTGSS_UTMI_OTG_STATUS_SESSVALID
-			| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT;
-	dwc3_omap_writel(omap->base, USBOTGSS_UTMI_OTG_STATUS, val);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(dwc3_omap_vbus_connect);
 
-int dwc3_omap_mailbox(enum omap_dwc3_vbus_id_status status)
-{
-	u32			val;
-	struct dwc3_omap	*omap = _omap;
-
-	if (!omap) {
-		dev_dbg(omap->dev, "not ready , deferring\n");
-		return -EPROBE_DEFER;
-	}
 	switch (status) {
 	case OMAP_DWC3_ID_GROUND:
 		dev_dbg(omap->dev, "ID GND\n");
-
-		val = dwc3_omap_read_utmi_status(omap);
 		val &= ~(USBOTGSS_UTMI_OTG_STATUS_IDDIG
 				| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID
 				| USBOTGSS_UTMI_OTG_STATUS_SESSEND);
 		val |= USBOTGSS_UTMI_OTG_STATUS_SESSVALID
 				| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT;
-		dwc3_omap_write_utmi_status(omap, val);
 		break;
 
 	case OMAP_DWC3_VBUS_VALID:
 		dev_dbg(omap->dev, "VBUS Connect\n");
-
-		dwc3_omap_vbus_connect(omap->dev);
+		val &= ~USBOTGSS_UTMI_OTG_STATUS_SESSEND;
+		val |= USBOTGSS_UTMI_OTG_STATUS_IDDIG
+				| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID
+				| USBOTGSS_UTMI_OTG_STATUS_SESSVALID
+				| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT;
 		break;
 
 	case OMAP_DWC3_ID_FLOAT:
 	case OMAP_DWC3_VBUS_OFF:
 		dev_dbg(omap->dev, "VBUS Disconnect\n");
 
-		val = dwc3_omap_read_utmi_status(omap);
 		val &= ~(USBOTGSS_UTMI_OTG_STATUS_SESSVALID
 				| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID
 				| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT);
 		val |= USBOTGSS_UTMI_OTG_STATUS_SESSEND
 				| USBOTGSS_UTMI_OTG_STATUS_IDDIG;
-		dwc3_omap_write_utmi_status(omap, val);
 		break;
 
 	default:
 		dev_dbg(omap->dev, "ID float\n");
 	}
 
+	dwc3_omap_writel(omap->base, USBOTGSS_UTMI_OTG_STATUS, val);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(dwc3_omap_usbvbus_id_handler);
+
+int dwc3_omap_mailbox(enum omap_dwc3_vbus_id_status status)
+{
+	struct dwc3_omap	*omap = _omap;
+
+	if (!omap) {
+		dev_dbg(omap->dev, "not ready , deferring\n");
+		return -EPROBE_DEFER;
+	}
+	return dwc3_omap_usbvbus_id_handler(omap->dev, status);
+}
 EXPORT_SYMBOL_GPL(dwc3_omap_mailbox);
 
 static irqreturn_t dwc3_omap_interrupt(int irq, void *_omap)
diff --git a/include/linux/usb/dwc3-omap.h b/include/linux/usb/dwc3-omap.h
index ee7accd..748dc42 100644
--- a/include/linux/usb/dwc3-omap.h
+++ b/include/linux/usb/dwc3-omap.h
@@ -20,13 +20,15 @@ enum omap_dwc3_vbus_id_status {
 
 #if (defined(CONFIG_USB_DWC3) || defined(CONFIG_USB_DWC3_MODULE))
 extern int dwc3_omap_mailbox(enum omap_dwc3_vbus_id_status status);
-extern int dwc3_omap_vbus_connect(struct device *dev);
+extern int dwc3_omap_usbvbus_id_handler(struct device *dev,
+		enum omap_dwc3_vbus_id_status status);
 #else
 static inline int dwc3_omap_mailbox(enum omap_dwc3_vbus_id_status status)
 {
 	return -ENODEV;
 }
-static int dwc3_omap_vbus_connect(struct device *dev)
+static int dwc3_omap_usbvbus_id_handler(struct device *dev,
+		enum omap_dwc3_vbus_id_status status)
 {
 	return -ENODEV;
 }
-- 
1.7.5.4

