From 53187013b947b8d504a88caa0d89eefbd433a3ff Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 11 Aug 2014 12:45:28 +0800
Subject: [PATCH] usb: dwc3: combine the gadget primary and thread handler for
 rt kernel

The dwc3 gadget irq handler is split into two parts. The primary
handler run in irq context, and the thread handler run in thread
context. This works pretty good in standard kernel. But for a rt
kernel this will cause issue due to the spinlock used by these two
parts become sleepable. One option is change this spinlock to raw
spinlock, but this will make the most of the code in thread handler
run with irq disabled. This will cause various issues if the normal
spinlock or work queue is used in the gadget driver callbacks. So
we choose to combine the gadget interrupt into one function and make
it entirely threaded for a rt kernel.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/usb/dwc3/gadget.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 6392b94..8be4f44 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -1562,8 +1562,13 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	int			irq;
 
 	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+#ifdef CONFIG_PREEMPT_RT_BASE
+	ret = request_threaded_irq(irq, NULL, dwc3_interrupt,
+			IRQF_SHARED | IRQF_ONESHOT, "dwc3", dwc);
+#else
 	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
 			IRQF_SHARED, "dwc3", dwc);
+#endif
 	if (ret) {
 		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
 				irq, ret);
@@ -2592,6 +2597,10 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 
 	spin_unlock(&dwc->lock);
 
+#ifdef CONFIG_PREEMPT_RT_BASE
+	if (ret != IRQ_NONE)
+		dwc3_thread_interrupt(irq, dwc);
+#endif
 	return ret;
 }
 
-- 
1.7.5.4

