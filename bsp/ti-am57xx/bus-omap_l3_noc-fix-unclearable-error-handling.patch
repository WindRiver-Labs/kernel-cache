From 4aef0d23c4534a4966b75899d1eb10168a4c24d0 Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Tue, 17 Dec 2013 17:57:11 +0530
Subject: [PATCH 047/263] bus: omap_l3_noc: fix unclearable error handling

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Errors that cannot be cleared (determined by reading status register)
are currently handled by masking it. Status register is understood to be
raw status rather than result of masking, based on recent issue reported
by Vaibhav Hiremath (I could not make out from the documentation that it
is raw status).

As that is the case, if after the occurance of an unclearable error,
another clearable L3 error happens that has lower binary weightage in
flagmux register (compared to the unclearable error that has occured),
and as status register is raw, isr will think that interrupt is raised
due to unclearable error(even though it was masked). This causes the new
error that could have been cleared, uncleared, resulting in isr getting
called repeatedly.

Fix it by masking raw status with masked ones before handling the error.

Reported-by: Vaibhav Hiremath <hvaibhav@ti.com>
Signed-off-by: Afzal Mohammed <afzal@ti.com>
Tested-by: Vaibhav Hiremath <hvaibhav@gmail.com>
(cherry picked from commit 96876702484a46d48571742435adb88356e53c45)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/bus/omap_l3_noc.c |    6 ++++++
 drivers/bus/omap_l3_noc.h |    1 +
 2 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 0a16e01..3c60922 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -64,6 +64,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	u32 std_err_main, err_reg, clear, masterid;
 	void __iomem *base, *l3_targ_base;
 	char *target_name, *master_name = "UN IDENTIFIED";
+	static u32 mask0[MAX_L3_MODULES], mask1[MAX_L3_MODULES];
 
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
@@ -76,6 +77,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		base = l3->l3_base[i];
 		err_reg = __raw_readl(base + l3->l3_flag_mux[i] +
 					+ L3_FLAGMUX_REGERR0 + (inttype << 3));
+		err_reg &= inttype ? ~mask1[i] : ~mask0[i];
 
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
@@ -93,6 +95,10 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					err_src, i, "(unclearable)");
 				val = readl(reg);
 				val &= ~(1 << err_src);
+				if (inttype)
+					mask1[i] |= (1 << err_src);
+				else
+					mask0[i] |= (1 << err_src);
 				writel(val, reg);
 				break;
 			}
diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 9696251..42e0786 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -25,6 +25,7 @@
 
 #define AM4372_L3_MODULES		2
 #define OMAP_L3_MODULES			3
+#define MAX_L3_MODULES			OMAP_L3_MODULES
 #define CLEAR_STDERR_LOG		(1 << 31)
 #define CUSTOM_ERROR			0x2
 #define STANDARD_ERROR			0x0
-- 
1.7.5.4

