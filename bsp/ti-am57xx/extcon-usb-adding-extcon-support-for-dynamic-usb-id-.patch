From cb7f03aeb67755369966c2482da081122a18c98f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 9 Jul 2014 14:45:55 +0800
Subject: [PATCH 219/263] extcon: usb: adding extcon support for dynamic
 usb-id detection by polling

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Adding extcon suppport for dynamic usb-id detection by polling mechanism
in the interval of 2 seconds.

Change-Id: I0069a3a630456cf88f378eae21816d5d2593bbc9
Signed-off-by: Ravi Babu <ravibabu@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../bindings/extcon/extcon-gpio-usbvid.txt         |    5 ++
 drivers/extcon/Kconfig                             |    1 +
 drivers/extcon/extcon-gpio-usbvid.c                |   71 +++++++++++++++++++-
 3 files changed, 74 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/extcon/extcon-gpio-usbvid.txt b/Documentation/devicetree/bindings/extcon/extcon-gpio-usbvid.txt
index eea0741..f497b5b 100644
--- a/Documentation/devicetree/bindings/extcon/extcon-gpio-usbvid.txt
+++ b/Documentation/devicetree/bindings/extcon/extcon-gpio-usbvid.txt
@@ -8,6 +8,9 @@ Required Properties:
 	   and the second used for VBUS detection.
 	   ID pin gpio is mandatory and VBUS is optional
 	   depending on implementation.
+- interrupt_mode : set to 1 for usb ID pin detection can by interrupt mode
+		   set to 0 for usb ID pin detection by polling mode.
+- dr_mode : set to "host", "peripheral" or "otg" for respective usb modes.
 
 Please refer to ../gpio/gpio.txt for details of the common GPIO bindings
 
@@ -17,4 +20,6 @@ Example:
 		compatible = "ti,gpio-usb-vid";
 		gpios = <&gpio1 1 0>,
 			<&gpio2 2 0>;
+		interrupt_mode = <0>;
+		dr_mode = "otg";
 	};
diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index c36594d..2341a52 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -59,6 +59,7 @@ config EXTCON_ARIZONA
 
 config EXTCON_GPIO_USBVID
 	tristate "Generic USB VBUS/ID detection using GPIO EXTCON support"
+	depends on USB_DWC3
 	help
 	  Say Y here to enable support for USB VBUS/ID deetction by GPIO.
 
diff --git a/drivers/extcon/extcon-gpio-usbvid.c b/drivers/extcon/extcon-gpio-usbvid.c
index dd4e462..c325a41 100644
--- a/drivers/extcon/extcon-gpio-usbvid.c
+++ b/drivers/extcon/extcon-gpio-usbvid.c
@@ -28,6 +28,11 @@
 #include <linux/of_gpio.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/usb/of.h>
+
+#define USBVID_POLL_MILLISEC  2000
 
 struct gpio_usbvid {
 	struct device *dev;
@@ -41,6 +46,8 @@ struct gpio_usbvid {
 	int id_irq;
 	int vbus_irq;
 	int type;
+	int id_current;
+	struct task_struct *usbid_thread;
 };
 
 static const char *dra7xx_extcon_cable[] = {
@@ -148,6 +155,43 @@ static void gpio_usbvid_set_initial_state(struct gpio_usbvid *gpio_usbvid)
 	}
 }
 
+static int poll_usbvbus_id_task(void *data)
+{
+	struct gpio_usbvid *gpio_usbvid = (struct gpio_usbvid *)data;
+	int id_current;
+
+	while (1) {
+
+		id_current = gpio_get_value_cansleep(gpio_usbvid->id_gpio);
+
+		if (id_current == gpio_usbvid->id_current) {
+			msleep(USBVID_POLL_MILLISEC);
+			continue;
+		}
+
+		dev_info(gpio_usbvid->dev, "id change event from %d to %d\n",
+			gpio_usbvid->id_current, id_current);
+
+		if (id_current == ID_GND) {
+			if (gpio_usbvid->type == ID_DETECT)
+				extcon_set_cable_state(&gpio_usbvid->edev,
+							"USB", false);
+			extcon_set_cable_state(&gpio_usbvid->edev,
+				"USB-HOST", true);
+		} else {
+			extcon_set_cable_state(&gpio_usbvid->edev, "USB-HOST",
+				false);
+			if (gpio_usbvid->type == ID_DETECT)
+				extcon_set_cable_state(&gpio_usbvid->edev,
+						"USB", true);
+		}
+		gpio_usbvid->id_current = id_current;
+		msleep(USBVID_POLL_MILLISEC);
+	}
+
+	return 0;
+}
+
 static int gpio_usbvid_request_irq(struct gpio_usbvid *gpio_usbvid)
 {
 	int ret;
@@ -182,6 +226,19 @@ static int gpio_usbvid_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct gpio_usbvid *gpio_usbvid;
 	int ret, gpio;
+	int intr_mode;
+	u8 mode;
+
+	if (!node)
+		return -EINVAL;
+
+	mode = of_usb_get_dr_mode(node);
+	if (mode != USB_DR_MODE_OTG)
+		return -EINVAL;
+
+	of_property_read_u32(node, "interrupt-mode", &intr_mode);
+	if (intr_mode > 1)
+		return -EINVAL;
 
 	gpio_usbvid = devm_kzalloc(&pdev->dev, sizeof(*gpio_usbvid),
 				GFP_KERNEL);
@@ -231,9 +288,17 @@ static int gpio_usbvid_probe(struct platform_device *pdev)
 		}
 	}
 
-	ret = gpio_usbvid_request_irq(gpio_usbvid);
-	if (ret)
-		return ret;
+	if (intr_mode) {
+		ret = gpio_usbvid_request_irq(gpio_usbvid);
+		if (ret)
+			return ret;
+	} else {
+		gpio_usbvid->id_current = -1;
+		gpio_usbvid->usbid_thread = kthread_run(poll_usbvbus_id_task,
+						 gpio_usbvid, "extcon-usbid");
+		if (IS_ERR(gpio_usbvid->usbid_thread))
+			return -1;
+	}
 
 	ret = extcon_dev_register(&gpio_usbvid->edev, gpio_usbvid->dev);
 	if (ret) {
-- 
1.7.5.4

