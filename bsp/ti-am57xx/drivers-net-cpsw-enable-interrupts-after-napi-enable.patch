From 647d201a9a5129f385697a280764dbc83bc4a67b Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Tue, 17 Dec 2013 16:03:30 +0530
Subject: [PATCH 259/263] drivers: net: cpsw: enable interrupts after napi
 enable and clearing previous interrupts

When the Ethernet interface is put down and up with heavy Ethernet
traffic, then there is prossibility of an interrupt waiting in irq
controller to be processed, so when the interface is brought up again
just after enable interrupt, it goes to ISR due to the previous
unhandled interrutp and in ISR napi is not scheduled as the napi
is not enabled in ndo_open which results in disabled interrupt for
CPSW and no packets are received in cpsw. So this patch moves enabling
of interupts after napi_enable and clearing CPDMA interrupts.

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
[Kevin: The original patch taken from TI
ti-sdk-am437x-evm-07.01.00.00-Linux-x86-Install.bin]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
(cherry picked from commit fb460ac99bd8dd6176c0633eccf54ed7e26d49df)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/ti/cpsw.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 46d0525..9a5f1d2 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -1245,6 +1245,12 @@ static int cpsw_ndo_open(struct net_device *ndev)
 		cpsw_set_coalesce(ndev, &coal);
 	}
 
+	napi_enable(&priv->napi);
+	cpdma_ctlr_start(priv->dma);
+	cpsw_intr_enable(priv);
+	cpdma_ctlr_eoi(priv->dma, CPDMA_EOI_RX);
+	cpdma_ctlr_eoi(priv->dma, CPDMA_EOI_TX);
+
 	prim_cpsw = cpsw_get_slave_priv(priv, 0);
 	if (prim_cpsw->irq_enabled == false) {
 		if ((priv == prim_cpsw) || !netif_running(prim_cpsw->ndev)) {
@@ -1253,12 +1259,6 @@ static int cpsw_ndo_open(struct net_device *ndev)
 		}
 	}
 
-	napi_enable(&priv->napi);
-	cpdma_ctlr_start(priv->dma);
-	cpsw_intr_enable(priv);
-	cpdma_ctlr_eoi(priv->dma, CPDMA_EOI_RX);
-	cpdma_ctlr_eoi(priv->dma, CPDMA_EOI_TX);
-
 	if (priv->data.dual_emac)
 		priv->slaves[priv->emac_port].open_stat = true;
 	return 0;
-- 
1.7.5.4

