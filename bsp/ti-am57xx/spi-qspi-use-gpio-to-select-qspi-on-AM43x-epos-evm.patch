From ab18af3104253eb6b6b9113cc048534cb05fa42f Mon Sep 17 00:00:00 2001
From: Sourav Poddar <sourav.poddar@ti.com>
Date: Wed, 7 Aug 2013 11:15:41 +0530
Subject: [PATCH 106/263] spi/qspi: use gpio to select qspi on AM43x epos evm

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

On AM43x epos evm, use of qspi and Nand is mutually exclusive. There is
a gpio present which is used to select between qspi and Nand.

As far as kernel is concerned, idea is to enable both qspi and nand
in dts, and able to use one of them based on user requirement.

The patch below makes use of the module parameter(enable_qspi) and expects
nand to use something similar(enable_nand) to get around this.

With this approach,
QSPI on J6: Works fine.
QSPI on AM43x-epos-evm "with" enable_qspi=1 in bootargs works fine
and qspi flash gets selected.
QSPI on AM43x-epos-evm "without" enable_qspi in bootargs prints a
message in the bootlog that "flash not recognised" as the flash does
not get selected.

This may not be the good solution, posting this to get some more feedbacks
on handling this out in a better way.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
(cherry picked from commit cfa9737e8192725f03bee5d43f336eac07cc38ec)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/spi/spi-ti-qspi.c |   20 +++++++++++++++++++-
 1 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c
index 278c185..cdb480d 100644
--- a/drivers/spi/spi-ti-qspi.c
+++ b/drivers/spi/spi-ti-qspi.c
@@ -31,9 +31,14 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
-
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/spi/spi.h>
 
+static int enable_qspi;
+module_param(enable_qspi, int, 0);
+MODULE_PARM_DESC(enable_qspi, "enable qspi on AM437x board");
+
 struct ti_qspi_regs {
 	u32 clkctrl;
 };
@@ -520,6 +525,19 @@ static int ti_qspi_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	u32 max_freq;
 	int ret = 0, num_cs, irq;
+	int gpio;
+	enum of_gpio_flags flags;
+
+	if (enable_qspi) {
+		gpio = of_get_named_gpio_flags(np, "qspi-gpio", 0, &flags);
+		if (gpio_is_valid(gpio)) {
+			gpio_request(gpio, "qspi");
+			gpio_direction_output(gpio, flags);
+		} else {
+			dev_err(&pdev->dev, "GPIO not available to select qspi");
+			return 0;
+		}
+	}
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*qspi));
 	if (!master)
-- 
1.7.5.4

