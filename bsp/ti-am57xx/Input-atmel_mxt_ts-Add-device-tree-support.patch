From 118b3ecd3f237fba5b0a26db5f065b0ef83a9925 Mon Sep 17 00:00:00 2001
From: Sundar Raman <sunds@ti.com>
Date: Thu, 24 Oct 2013 11:57:59 -0500
Subject: [PATCH 014/263] Input: atmel_mxt_ts: Add device tree support

This commit comes from branch ti-linux-3.12.y:
  git://git.omapzoom.org/kernel/omap.git
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

Add device tree support for Atmel touch driver. All platform
specific data is now read from dts files and parsed inside the
driver.

NOTE: Provision for supplying config data for controller is
given from board specific dts file since the driver no longer
configures these values for different firmware revisions,
after this commit: 71749f5c66e797a39600dae9de58aab3858dc488

Signed-off-by: Sundar Raman <sunds@ti.com>
Acked-by: Nishanth Menon <nm@ti.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit 6ef8bb7de4d590b174057736d097f49405b054e1)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../bindings/input/touchscreen/atmel_mxt_ts.txt    |  108 ++++++++++++++++
 drivers/input/touchscreen/atmel_mxt_ts.c           |  135 +++++++++++++++++++-
 2 files changed, 238 insertions(+), 5 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/input/touchscreen/atmel_mxt_ts.txt

diff --git a/Documentation/devicetree/bindings/input/touchscreen/atmel_mxt_ts.txt b/Documentation/devicetree/bindings/input/touchscreen/atmel_mxt_ts.txt
new file mode 100644
index 0000000..effc1ab
--- /dev/null
+++ b/Documentation/devicetree/bindings/input/touchscreen/atmel_mxt_ts.txt
@@ -0,0 +1,108 @@
+Atmel MaxTouch Touchscreen
+--------------------------
+Required properties:
+ - compatible: "atmel,mXT244" or "atmel,qt602240_ts"
+                or "atmel,atmel_mxt_ts"
+ - reg: I2C address of the chip
+ - interrupts: interrupt signal to which the chip is connected
+ - atmel,x-line: Number of x lines the touch object occupies in pixels
+ - atmel,y-line: Number of y lines the touch object occupies in pixels
+ - atmel,x-size: Horizontal resolution of touchscreen in pixels
+ - atmel,y-size: Vertical resolution of touchscreen in pixels
+ - atmel,blen: Sets the gain of the analog circuit in front of ADC
+               Gain setting depends on package type. Range: 0-3
+ - atmel,threshold: Channel detection threshold value. Range: 0-255
+                    Typical: 30-80. Lower the threshold, higher the
+                    sensitivity
+ - atmel,voltage: Nominal AVdd in uV for analog circuitry, greater than
+                  or less than base voltage of 2.7V, used for optimizing
+                  capacitive sensing. For example, if you want to
+                  program an optimum voltage of 2.8V in your design,
+                  specify 2800000 for this parameter
+ - atmel,orientation: touchscreen orientation, must be one of following,
+     as defined inside include/linux/i2c/atmel_mxt_ts.h
+     - 0: MXT_NORMAL - normal
+     - 1: MXT_DIAGONAL - diagonal
+     - 2: MXT_HORIZONTAL_FLIP - horizonally flipped
+     - 3: MXT_ROTATED_90_COUNTER - rotated by 90 degrees
+                                  counter-clockwise
+     - 4: MXT_VERTICAL_FLIP - vertically flipped
+     - 5: MXT_ROTATED_90 - rotated by 90 degress clockwise
+     - 6: MXT_ROTATED_180 - rotated by 180 degrees
+     - 7: MXT_DIAGONAL_COUNTER - diagonal counter
+
+Optional properties:
+ - atmel,config: list of 8-bit register values for controller objects
+   in the following order. Number of objects and values depends on the
+   particular model of Atmel touch screen you are using. Please check
+   with your Atmel representative for helping you tune these values
+   GEN_COMMAND, GEN_POWER, GEN_ACQUIRE, TOUCH_MULTI
+   TOUCH_KEYARRAY, MXT244_COMMSCONFIG_T18, SPT_GPIOPWM, PROCI_GRIPFACE,
+   PROCG_NOISE, TOUCH_PROXIMITY, PROCI_ONETOUCH, SPT_SELFTEST,
+   PROCI_TWOTOUCH, SPT_CTECONFIG
+   Note: These register values can be specified here according to
+   the specific controller and platform configuration desired. The
+   driver does not configure these registers by default and leaves it
+   to the platform dts file to supply them
+
+Example:
+
+	&i2c1 {
+		mXT244:mXT244@4a {
+			reg = <0x4a>;
+		};
+	};
+
+	&mXT244 {
+		compatible = "atmel,mXT244";
+		interrupts = <0 119 0x4>;
+
+		atmel,config = <
+		/* MXT244_GEN_COMMAND(6) */
+		0x00 0x00 0x00 0x00 0x00 0x00
+		/* MXT244_GEN_POWER(7) */
+		0x20 0xff 0x32
+		/* MXT244_GEN_ACQUIRE(8) */
+		0x0a 0x00 0x05 0x00 0x00 0x00 0x09 0x23
+		/* MXT244_TOUCH_MULTI(9) */
+		0x00 0x00 0x00 0x13 0x0b 0x00 0x00 0x00 0x02 0x00
+		0x00 0x01 0x01 0x0e 0x0a 0x0a 0x0a 0x0a 0x00 0x00
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00
+		/* MXT244_TOUCH_KEYARRAY(15) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00
+		/* MXT244_COMMSCONFIG_T18(2) */
+		0x00 0x00
+		/* MXT244_SPT_GPIOPWM(19) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00 0x00 0x00 0x00 0x00 0x00
+		/* MXT244_PROCI_GRIPFACE(20) */
+		0x07 0x00 0x00 0x00 0x00 0x00 0x00 0x50 0x28 0x04
+		0x0f 0x0a
+		/* MXT244_PROCG_NOISE(22) */
+		0x05 0x00 0x00 0x00 0x00 0x00 0x00 0x03 0x23 0x00
+		0x00 0x05 0x0f 0x19 0x23 0x2d 0x03
+		/* MXT244_TOUCH_PROXIMITY(23) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00 0x00 0x00 0x00 0x00
+		/* MXT244_PROCI_ONETOUCH(24) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		/* MXT244_SPT_SELFTEST(25) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		0x00 0x00 0x00 0x00
+		/* MXT244_PROCI_TWOTOUCH(27) */
+		0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		/* MXT244_SPT_CTECONFIG(28) */
+		0x00 0x00 0x02 0x08 0x10 0x00 >;
+
+		atmel,x_line = <18>;
+		atmel,y_line = <12>;
+		atmel,x_size = <800>;
+		atmel,y_size = <480>;
+		atmel,blen = <0x01>;
+		atmel,threshold = <30>;
+		atmel,voltage = <2800000>;
+		atmel,orient = <0x4>;
+	};
diff --git a/drivers/input/touchscreen/atmel_mxt_ts.c b/drivers/input/touchscreen/atmel_mxt_ts.c
index f4a727e..afdefbb 100644
--- a/drivers/input/touchscreen/atmel_mxt_ts.c
+++ b/drivers/input/touchscreen/atmel_mxt_ts.c
@@ -20,6 +20,8 @@
 #include <linux/input/mt.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 /* Version */
 #define MXT_VER_20		20
@@ -335,6 +337,105 @@ static void mxt_dump_message(struct device *dev,
 		message->reportid, 7, message->message);
 }
 
+static int mxt_of_get_platform_info(struct i2c_client *client,
+			     struct mxt_platform_data *pdata)
+
+{
+	int size, index = 0;
+	u32 val;
+	const __be32 *config_be;
+	u8 *config;
+	const char *pname;
+	struct device_node *node = client->dev.of_node;
+
+	config_be = of_get_property(node, "atmel,config", &size);
+	if (config_be && size) {
+		size /= sizeof(*config_be);
+		config = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+		if (!config) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		pdata->config = config;
+		pdata->config_length = size;
+
+		while (index < size) {
+			config[index] = be32_to_cpup(config_be + index) & 0xFF;
+			index++;
+		}
+	} else {
+		dev_dbg(&client->dev, "%s:no config data specified\n",
+			__func__);
+	}
+
+	pname = "atmel,x_line";
+	if (of_property_read_u32(node, pname, &pdata->x_line)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,y_line";
+	if (of_property_read_u32(node, pname, &pdata->y_line)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,x_size";
+	if (of_property_read_u32(node, pname, &pdata->x_size)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,y_size";
+	if (of_property_read_u32(node, pname, &pdata->y_size)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,blen";
+	if (of_property_read_u32(node, pname, &pdata->blen)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,threshold";
+	if (of_property_read_u32(node, pname, &pdata->threshold)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,voltage";
+	if (of_property_read_u32(node, pname, &pdata->voltage)) {
+		dev_err(&client->dev,
+			"%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,orient";
+	if (of_property_read_u32(node, pname, &val)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	if (val > 0xFF) {
+		dev_err(&client->dev, "%s: Bad %s property value %d\n",
+			__func__, pname, val);
+		return -EINVAL;
+	}
+	pdata->orient = val & 0xFF;
+
+	return 0;
+}
+
 static int mxt_check_bootloader(struct i2c_client *client,
 				     unsigned int state)
 {
@@ -1127,17 +1228,40 @@ static void mxt_input_close(struct input_dev *dev)
 	mxt_stop(data);
 }
 
+static const struct of_device_id mxt_dt_ids[] = {
+	{ .compatible = "atmel,qt602240_ts", },
+	{ .compatible = "atmel,atmel_mxt_ts", },
+	{ .compatible = "atmel,mXT244", },
+	{ /* sentinel */ }
+};
+
 static int mxt_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
-	const struct mxt_platform_data *pdata = client->dev.platform_data;
+	struct mxt_platform_data *pdata;
 	struct mxt_data *data;
 	struct input_dev *input_dev;
 	int error;
 	unsigned int num_mt_slots;
-
-	if (!pdata)
-		return -EINVAL;
+	const struct of_device_id *match;
+
+	match = of_match_device(of_match_ptr(mxt_dt_ids), &client->dev);
+	if (match) {
+		pdata = devm_kzalloc(&client->dev,
+					sizeof(struct mxt_platform_data),
+					GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+		error = mxt_of_get_platform_info(client, pdata);
+		if (error)
+			return error;
+	} else {
+		pdata = client->dev.platform_data;
+		if (!pdata) {
+			dev_err(&client->dev, "Platform data not populated\n");
+			return -EINVAL;
+		}
+	}
 
 	data = devm_kzalloc(&client->dev, sizeof(struct mxt_data), GFP_KERNEL);
 	input_dev = input_allocate_device();
@@ -1226,7 +1350,7 @@ static int mxt_probe(struct i2c_client *client,
 
 	error = devm_request_threaded_irq(&client->dev, client->irq,
 					  NULL, mxt_interrupt,
-					  pdata->irqflags | IRQF_ONESHOT,
+					  IRQF_ONESHOT,
 					  dev_name(&client->dev), data);
 	if (error) {
 		dev_err(&client->dev, "Failed to register interrupt\n");
@@ -1324,6 +1448,7 @@ static struct i2c_driver mxt_driver = {
 		.name	= "atmel_mxt_ts",
 		.owner	= THIS_MODULE,
 		.pm	= &mxt_pm_ops,
+		.of_match_table = mxt_dt_ids,
 	},
 	.probe		= mxt_probe,
 	.remove		= mxt_remove,
-- 
1.7.5.4

