From 5ea3a9212853a08828a2712acfbbf5dfcaa76c35 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 7 Jul 2014 14:49:40 +0800
Subject: [PATCH 199/263] usb: dwc3: debugfs: dual role switch through debugfs
 entries

The f296f6bc comes from the following git repo:

  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

dual role switch through debugfs entries usage:

1) mount debugfs
        # mount -t debugfs debugfs /mnt

2) To switch usb1 to device/host mode
        # echo "device" > /mnt/4889000.dwc3/mode
        # echo "host" > /mnt/4889000.dwc3/mode

3) To switch usb2 to device/host mode
        # echo "device" > /mnt/488d000.dwc3/mode
        # echo "host" > /mnt/488d000.dwc3/mode

To switch to device mode: make sure previous mode is host.
To switch to host mode: make sure previous mode is device.

Change-Id: I3fcecd59cd4910efe38d54d7196b8686a00f1e87
Signed-off-by: Ravi Babu <ravibabu@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/dwc3/debugfs.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/dwc3/debugfs.c b/drivers/usb/dwc3/debugfs.c
index 9ac37fe..9057e79 100644
--- a/drivers/usb/dwc3/debugfs.c
+++ b/drivers/usb/dwc3/debugfs.c
@@ -27,6 +27,7 @@
 #include <linux/uaccess.h>
 
 #include <linux/usb/ch9.h>
+#include <linux/usb/dwc3-omap.h>
 
 #include "core.h"
 #include "gadget.h"
@@ -375,7 +376,8 @@ static int dwc3_mode_show(struct seq_file *s, void *unused)
 		seq_printf(s, "device\n");
 		break;
 	case DWC3_GCTL_PRTCAP_OTG:
-		seq_printf(s, "OTG\n");
+		seq_printf(s, "OTG DRD %s\n",
+			dwc->drd_state ? "device" : "host");
 		break;
 	default:
 		seq_printf(s, "UNKNOWN %08x\n", DWC3_GCTL_PRTCAP(reg));
@@ -412,7 +414,15 @@ static ssize_t dwc3_mode_write(struct file *file,
 
 	if (mode) {
 		spin_lock_irqsave(&dwc->lock, flags);
-		dwc3_set_mode(dwc, mode);
+		if (mode & DWC3_GCTL_PRTCAP_HOST) {
+			dwc3_omap_usbvbus_id_handler(dwc->dev->parent,
+				OMAP_DWC3_ID_GROUND);
+			mode = 0;
+		} else if (mode & DWC3_GCTL_PRTCAP_DEVICE) {
+			dwc3_omap_usbvbus_id_handler(dwc->dev->parent,
+				OMAP_DWC3_VBUS_VALID);
+			mode = 1;
+		}
 		spin_unlock_irqrestore(&dwc->lock, flags);
 	}
 	return count;
-- 
1.7.5.4

