From bc1de252d2d46a73fc946191d4bec786edd60239 Mon Sep 17 00:00:00 2001
From: Ravi Babu <ravibabu@ti.com>
Date: Wed, 6 Nov 2013 13:13:20 +0530
Subject: [PATCH 222/263] usb: xhci: fix up deallocation code

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

This fixes up the deallocation code in the xhci driver, so that
usb_add_hcd()/usb_remove_hcd() can be called repeatedly without
crashing
From: Paul Zimmerman <Paul.Zimmerman@synopsys.com>

Change-Id: Ia1c2a9887b3f709eb970b5a50af52c14044d787c
Signed-off-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Signed-off-by: Ravi Babu <ravibabu@ti.com>
(cherry picked from commit 7db2e7e4f2c993130ea3e6cca40a5196337bc25d)

Conflicts:
	drivers/usb/host/xhci-mem.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/usb/host/xhci-mem.c |   18 ++++++++++++++++--
 drivers/usb/host/xhci.c     |   10 ++++++----
 2 files changed, 22 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 27062e6..4cea912 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -815,6 +815,9 @@ static void xhci_free_tt_info(struct xhci_hcd *xhci,
 		return;
 	}
 
+	if (!xhci->rh_bw)
+		return;
+
 	tt_list_head = &(xhci->rh_bw[virt_dev->real_port - 1].tts);
 	list_for_each_entry_safe(tt_info, next, tt_list_head, tt_list) {
 		/* Multi-TT hubs will have more than one entry */
@@ -882,7 +885,8 @@ void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id)
 		return;
 
 	dev = xhci->devs[slot_id];
-	xhci->dcbaa->dev_context_ptrs[slot_id] = 0;
+	if (xhci->dcbaa)
+		xhci->dcbaa->dev_context_ptrs[slot_id] = 0;
 	if (!dev)
 		return;
 
@@ -892,9 +896,11 @@ void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id)
 	for (i = 0; i < 31; ++i) {
 		if (dev->eps[i].ring)
 			xhci_ring_free(xhci, dev->eps[i].ring);
+		dev->eps[i].ring = NULL;
 		if (dev->eps[i].stream_info)
 			xhci_free_stream_info(xhci,
 					dev->eps[i].stream_info);
+		dev->eps[i].stream_info = NULL;
 		/* Endpoints on the TT/root port lists should have been removed
 		 * when usb_disable_device() was called for the device.
 		 * We can't drop them anyway, because the udev might have gone
@@ -914,12 +920,15 @@ void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id)
 		for (i = 0; i < dev->num_rings_cached; i++)
 			xhci_ring_free(xhci, dev->ring_cache[i]);
 		kfree(dev->ring_cache);
+		dev->ring_cache = NULL;
 	}
 
 	if (dev->in_ctx)
 		xhci_free_container_ctx(xhci, dev->in_ctx);
+	dev->in_ctx = NULL;
 	if (dev->out_ctx)
 		xhci_free_container_ctx(xhci, dev->out_ctx);
+	dev->out_ctx = NULL;
 
 	kfree(xhci->devs[slot_id]);
 	xhci->devs[slot_id] = NULL;
@@ -1781,6 +1790,7 @@ void xhci_mem_cleanup(struct xhci_hcd *xhci)
 
 	if (xhci->lpm_command)
 		xhci_free_command(xhci, xhci->lpm_command);
+	xhci->lpm_command = NULL;
 	xhci->cmd_ring_reserved_trbs = 0;
 	if (xhci->cmd_ring)
 		xhci_ring_free(xhci, xhci->cmd_ring);
@@ -1848,10 +1858,14 @@ no_bw:
 	xhci->num_usb3_ports = 0;
 	xhci->num_active_eps = 0;
 	kfree(xhci->usb2_ports);
+	xhci->usb2_ports = NULL;
 	kfree(xhci->usb3_ports);
+	xhci->usb3_ports = NULL;
 	kfree(xhci->port_array);
-	kfree(xhci->rh_bw);
+	xhci->port_array = NULL;
 	kfree(xhci->ext_caps);
+	kfree(xhci->rh_bw);
+	xhci->rh_bw = NULL;
 
 	xhci->page_size = 0;
 	xhci->page_shift = 0;
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index e159467..c693aee 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -3532,10 +3532,12 @@ void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev)
 
 	virt_dev = xhci->devs[udev->slot_id];
 
-	/* Stop any wayward timer functions (which may grab the lock) */
-	for (i = 0; i < 31; ++i) {
-		virt_dev->eps[i].ep_state &= ~EP_HALT_PENDING;
-		del_timer_sync(&virt_dev->eps[i].stop_cmd_timer);
+	if (virt_dev) {
+		/* Stop any wayward timer functions (which may grab the lock) */
+		for (i = 0; i < 31; ++i) {
+			virt_dev->eps[i].ep_state &= ~EP_HALT_PENDING;
+			del_timer_sync(&virt_dev->eps[i].stop_cmd_timer);
+		}
 	}
 
 	spin_lock_irqsave(&xhci->lock, flags);
-- 
1.7.5.4

