From 44f51488d98cf2525891cd1644e98e38ec94576f Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 13 Jun 2013 09:30:15 +0800
Subject: [PATCH 19/38] fsl_imx6q: Update usb driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/core/hub.c               |   59 ++++
 drivers/usb/gadget/Kconfig           |    6 +
 drivers/usb/gadget/arcotg_udc.c      |  122 +++++--
 drivers/usb/gadget/arcotg_udc.h      |    5 +
 drivers/usb/gadget/f_uac1.c          |   40 ++-
 drivers/usb/gadget/file_storage.c    |   61 ++++-
 drivers/usb/gadget/fsl_updater.c     |  613 ++++++++++++++++++++++++++++++++++
 drivers/usb/gadget/fsl_updater.h     |  149 ++++++++
 drivers/usb/gadget/imx_usb_charger.c |  343 +++++++++++++++++++
 drivers/usb/gadget/imx_usb_charger.h |  193 +++++++++++
 drivers/usb/gadget/u_uac1.c          |   17 +-
 drivers/usb/host/Kconfig             |    7 +
 drivers/usb/host/Makefile            |    1 +
 drivers/usb/host/arc_hset.c          |  468 ++++++++++++++++++++++++++
 drivers/usb/host/ehci-arc.c          |   55 ++--
 drivers/usb/host/ehci-fsl.h          |    1 +
 drivers/usb/host/ehci-hcd.c          |   31 ++-
 drivers/usb/host/ehci-q.c            |  181 ++++++++++
 drivers/usb/otg/arc_otg.c            |   78 +++--
 19 files changed, 2323 insertions(+), 107 deletions(-)
 create mode 100644 drivers/usb/gadget/fsl_updater.c
 create mode 100644 drivers/usb/gadget/fsl_updater.h
 create mode 100644 drivers/usb/gadget/imx_usb_charger.c
 create mode 100644 drivers/usb/gadget/imx_usb_charger.h
 create mode 100644 drivers/usb/host/arc_hset.c

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 3c2943f..9ea4a3b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -160,7 +160,50 @@ EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u8 usb_device_white_list[] = {
+	USB_CLASS_HID,
+	USB_CLASS_HUB,
+	USB_CLASS_MASS_STORAGE
+};
+
+static inline int in_white_list(u8 interfaceclass)
+{
+	int i;
+	for (i = 0; i < sizeof(usb_device_white_list); i++)	{
+		if (interfaceclass == usb_device_white_list[i])
+			return 1;
+	}
+	return 0;
+}
+
+static inline int device_in_white_list(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	struct usb_host_config *c;
+
+	/* for test fixture, we always return 1 */
+	if (udev->descriptor.idVendor == 0x1A0A)
+		return 1;
+
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
 
+		if (desc && !in_white_list((u8)desc->bInterfaceClass))
+			continue;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
@@ -2016,6 +2059,14 @@ int usb_new_device(struct usb_device *udev)
 	udev->dev.devt = MKDEV(USB_DEVICE_MAJOR,
 			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+	if (!device_in_white_list(udev)) {
+		printk(KERN_ERR "unsupported device: not in white list\n");
+		goto fail;
+	} else {
+		printk(KERN_DEBUG "supported device\n");
+	}
+#endif
 	/* Tell the world! */
 	announce_device(udev);
 
@@ -3592,6 +3643,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_set_device_state(udev, USB_STATE_POWERED);
  		udev->bus_mA = hub->mA_per_port;
 		udev->level = hdev->level + 1;
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		printk(KERN_INFO "+++ %s:udev->level :%d", __func__,
+						udev->level);
+#endif
 		udev->wusb = hub_is_wusb(hub);
 
 		/* Only USB 3.0 devices are connected to SuperSpeed hubs. */
@@ -3851,6 +3906,10 @@ static void hub_events(void)
 			if (ret < 0)
 				continue;
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+			if (portstatus & USB_PORT_STAT_TEST)
+				continue;
+#endif
 			if (portchange & USB_PORT_STAT_C_CONNECTION) {
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_CONNECTION);
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 8b4f29f..a9218e8 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -798,6 +798,12 @@ config USB_FILE_STORAGE
 	  NOTE: This driver is deprecated.  Its replacement is the
 	  Mass Storage Gadget.
 
+config FSL_UTP
+	bool "UTP over Storage Gadget"
+	depends on USB_FILE_STORAGE
+	help
+	  Freescale's extension to MSC protocol
+
 config USB_FILE_STORAGE_TEST
 	bool "File-backed Storage Gadget testing version"
 	depends on USB_FILE_STORAGE
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 284f1aa..076c9e6 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -38,10 +38,10 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/dmapool.h>
+#include <linux/io.h>
 
 #include <asm/processor.h>
 #include <asm/byteorder.h>
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/mach-types.h>
@@ -77,6 +77,8 @@ static const char driver_desc[] = DRIVER_DESC;
 volatile static struct usb_dr_device *dr_regs;
 volatile static struct usb_sys_interface *usb_sys_regs;
 
+#include "imx_usb_charger.c" /* support for usb charger detect */
+
 /* it is initialized in probe()  */
 static struct fsl_udc *udc_controller;
 
@@ -490,6 +492,7 @@ static void dr_controller_run(struct fsl_udc *udc)
 	/* If vbus not on and used low power mode */
 	if (!(temp & OTGSC_B_SESSION_VALID)) {
 		/* Set stopped before low power mode */
+		udc->vbus_active = false;
 		udc->stopped = 1;
 		/* enable wake up */
 		dr_wake_up_enable(udc, true);
@@ -510,10 +513,9 @@ static void dr_controller_run(struct fsl_udc *udc)
 
 		/* disable pulldown dp and dm */
 		dr_discharge_line(udc->pdata, false);
-		/* The usb line has already been connected to pc */
-		temp = fsl_readl(&dr_regs->usbcmd);
-		temp |= USB_CMD_RUN_STOP;
-		fsl_writel(temp, &dr_regs->usbcmd);
+		udc->vbus_active = true;
+		/* notify vbus is connected */
+		imx_usb_vbus_connect(&udc->charger);
 		printk(KERN_DEBUG "%s: udc out low power mode\n", __func__);
 	}
 
@@ -560,6 +562,8 @@ static void dr_controller_stop(struct fsl_udc *udc)
 	tmp &= ~USB_CMD_RUN_STOP;
 	fsl_writel(tmp, &dr_regs->usbcmd);
 
+	/* disable pulldown dp and dm */
+	dr_discharge_line(udc->pdata, true);
 	return;
 }
 
@@ -956,7 +960,11 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 			(unsigned)EP_MAX_LENGTH_TRANSFER);
 	if (NEED_IRAM(req->ep))
 		*length = min(*length, g_iram_size);
+#ifdef CONFIG_FSL_UTP
+	dtd = dma_pool_alloc_nonbufferable(udc_controller->td_pool, GFP_ATOMIC, dma);
+#else
 	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_ATOMIC, dma);
+#endif
 	if (dtd == NULL)
 		return dtd;
 
@@ -1470,19 +1478,27 @@ static int fsl_pullup(struct usb_gadget *gadget, int is_on)
 }
 
 static int fsl_arc_start(struct usb_gadget_driver *driver,
-				int (*bind)(struct usb_gadget *));
+			int (*bind)(struct usb_gadget *));
 static int fsl_arc_stop(struct usb_gadget_driver *driver);
+/*
+ * The USB PHY/Charger driver can't visit usb_gadget directly, so
+ * supply a wrapped function for usb charger visiting.
+ */
+static void usb_charger_pullup_dp(bool enable)
+{
+	fsl_pullup(&udc_controller->gadget, (int)enable);
+}
 
 /* defined in gadget.h */
 static struct usb_gadget_ops fsl_gadget_ops = {
-	.get_frame	= fsl_get_frame,
-	.wakeup		= fsl_wakeup,
+	.get_frame = fsl_get_frame,
+	.wakeup = fsl_wakeup,
 /*	.set_selfpowered = fsl_set_selfpowered,	*/ /* Always selfpowered */
-	.vbus_session	= fsl_vbus_session,
-	.vbus_draw	= fsl_vbus_draw,
-	.pullup		= fsl_pullup,
-	.start		= fsl_arc_start,
-	.stop		= fsl_arc_stop,
+	.vbus_session = fsl_vbus_session,
+	.vbus_draw = fsl_vbus_draw,
+	.pullup = fsl_pullup,
+	.start = fsl_arc_start,
+	.stop = fsl_arc_stop,
 };
 
 /* Set protocol stall on ep0, protocol stall will automatically be cleared
@@ -1541,6 +1557,19 @@ static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
 	udc->device_address = (u8) value;
 	/* Update usb state */
 	udc->usb_state = USB_STATE_ADDRESS;
+
+	/* for USB CV 3.0 test, the gap between the ACK of the set_address
+	 * and the subsequently setup packet may be very little, say 500us,
+	 * and if the latency we handle the ep completion is greater than
+	 * this gap, there is no response to the subsequent setup packet.
+	 * It will cause the CV test fail */
+	/* There is another way to set address, we can set the bit 24 to
+	 * 1 to make IC set this address instead of SW, it is more fast
+	 * and safe than SW way */
+	fsl_writel(udc->device_address << USB_DEVICE_ADDRESS_BIT_POS |
+			1 << USB_DEVICE_ADDRESS_ADV_BIT_POS,
+			&dr_regs->deviceaddr);
+
 	/* Status phase */
 	if (ep0_prime_status(udc, EP_DIR_IN))
 		ep0stall(udc);
@@ -1686,6 +1715,10 @@ static void setup_received_irq(struct fsl_udc *udc,
 				else if (setup->bRequest ==
 					 USB_DEVICE_A_ALT_HNP_SUPPORT)
 					udc->gadget.a_alt_hnp_support = 1;
+				else
+					break;
+			} else {
+				break;
 			}
 			rc = 0;
 		} else
@@ -1749,13 +1782,6 @@ static void setup_received_irq(struct fsl_udc *udc,
 static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
 		struct fsl_req *req)
 {
-	if (udc->usb_state == USB_STATE_ADDRESS) {
-		/* Set the new address */
-		u32 new_address = (u32) udc->device_address;
-		fsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
-				&dr_regs->deviceaddr);
-	}
-
 	done(ep0, req, 0);
 }
 
@@ -2179,9 +2205,10 @@ static void fsl_gadget_disconnect_event(struct work_struct *work)
 
 	pdata = udc->pdata;
 
+	 /* notify vbus is disconnected */
+	imx_usb_vbus_disconnect(&udc->charger);
 	/* wait line to se0 */
 	dr_discharge_line(pdata, true);
-
 	/*
 	 * Wait class drivers finish, an well-behaviour class driver should
 	 * call ep_disable when it is notified to be disconnected.
@@ -2235,13 +2262,16 @@ bool try_wake_up_udc(struct fsl_udc *udc)
 		if (irq_src & OTGSC_B_SESSION_VALID) {
 			if (udc->suspended) /*let the system pm resume the udc */
 				return true;
+			udc->vbus_active = true;
 			udc->stopped = 0;
 			/* disable pulldown dp and dm */
 			dr_discharge_line(pdata, false);
-			fsl_writel(tmp | USB_CMD_RUN_STOP, &dr_regs->usbcmd);
+			/* notify vbus is connected */
+			imx_usb_vbus_connect(&udc->charger);
 			printk(KERN_DEBUG "%s: udc out low power mode\n", __func__);
 		} else {
-			fsl_writel(tmp & ~USB_CMD_RUN_STOP, &dr_regs->usbcmd);
+			udc->vbus_active = false;
+			fsl_pullup(&udc_controller->gadget, false); /* usbcmd.rs=0 */
 			/* here we need disable B_SESSION_IRQ, after
 			 * schedule_work finished, it need to be enabled again.
 			 * Doing like this can avoid conflicting between rapid
@@ -2252,7 +2282,6 @@ bool try_wake_up_udc(struct fsl_udc *udc)
 				fsl_writel(tmp &
 					   (~OTGSC_B_SESSION_VALID_IRQ_EN),
 					   &dr_regs->otgsc);
-
 			/* update port status */
 			fsl_udc_speed_update(udc);
 			spin_unlock(&udc->lock);
@@ -2435,7 +2464,6 @@ static int fsl_arc_start(struct usb_gadget_driver *driver,
 		if (udc_controller->stopped)
 			dr_clk_gate(false);
 	}
-
 	printk(KERN_INFO "%s: bind to driver %s \n",
 			udc_controller->gadget.name, driver->driver.name);
 
@@ -2496,6 +2524,7 @@ static int fsl_arc_stop(struct usb_gadget_driver *driver)
 
 	dr_phy_low_power_mode(udc_controller, true);
 
+	dr_clk_gate(false);
 	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
 	       driver->driver.name);
 	return 0;
@@ -2887,6 +2916,7 @@ static void fsl_udc_release(struct device *dev)
 	dma_free_coherent(dev, udc_controller->ep_qh_size,
 			udc_controller->ep_qh, udc_controller->ep_qh_dma);
 	kfree(udc_controller);
+	udc_controller = NULL;
 }
 
 /******************************************************************
@@ -3047,6 +3077,7 @@ static int __devinit fsl_udc_probe(struct platform_device *pdev)
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
 	if (pdata->init && pdata->init(pdev)) {
+		pdata->lowpower = false;
 		ret = -ENODEV;
 		goto err2a;
 	}
@@ -3102,7 +3133,6 @@ static int __devinit fsl_udc_probe(struct platform_device *pdev)
 	udc_controller->gadget.ops = &fsl_gadget_ops;
 	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
 	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
-	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
 	udc_controller->gadget.max_speed= USB_SPEED_HIGH;
 	udc_controller->gadget.name = driver_name;
 
@@ -3184,10 +3214,22 @@ static int __devinit fsl_udc_probe(struct platform_device *pdev)
 
 	create_proc_file();
 
+	/* create usb charger */
+#ifdef CONFIG_IMX_USB_CHARGER
+	udc_controller->charger.dev = &pdev->dev;
+	udc_controller->charger.dp_pullup = usb_charger_pullup_dp;
+	udc_controller->charger.enable = true;
+	if (pdata->charger_base_addr)
+		udc_controller->charger.charger_base_addr = pdata->charger_base_addr;
+	if (imx_usb_create_charger(&udc_controller->charger, "imx_usb_charger"))
+		dev_err(&pdev->dev, "Can't create usb charger\n");
+#else
+	udc_controller->charger.dp_pullup = usb_charger_pullup_dp;
+	udc_controller->charger.enable = false;
+#endif
 	ret = usb_add_gadget_udc(&pdev->dev, &udc_controller->gadget);
 	if (!ret)
 		return ret;
-
 	return 0;
 
 err4:
@@ -3211,19 +3253,25 @@ err1a:
 /* Driver removal function
  * Free resources and finish pending transactions
  */
-static int __exit fsl_udc_remove(struct platform_device *pdev)
+static int  fsl_udc_remove(struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-
+	u32 temp;
 	DECLARE_COMPLETION(done);
 
 	if (!udc_controller)
 		return -ENODEV;
 	udc_controller->done = &done;
 	/* open USB PHY clock */
-	if (udc_controller->stopped)
-		dr_clk_gate(true);
+	dr_clk_gate(true);
+
+	/* disable wake up and otgsc interrupt for safely remove udc driver*/
+	temp = fsl_readl(&dr_regs->otgsc);
+	temp &= ~(0x7f << 24);
+	fsl_writel(temp, &dr_regs->otgsc);
+	dr_wake_up_enable(udc_controller, false);
 
+	dr_discharge_line(pdata, true);
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
 
@@ -3244,6 +3292,10 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	free_irq(udc_controller->irq, udc_controller);
 	iounmap((u8 __iomem *)dr_regs);
 
+#ifdef CONFIG_IMX_USB_CHARGER
+	imx_usb_remove_charger(&udc_controller->charger);
+#endif
+
 #ifndef CONFIG_USB_OTG
 {
 	struct resource *res;
@@ -3251,7 +3303,6 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
 }
 #endif
-
 	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
@@ -3262,9 +3313,6 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	if (pdata->exit)
 		pdata->exit(pdata->pdev);
 
-	if (udc_controller->stopped)
-		dr_clk_gate(false);
-
 	return 0;
 }
 
@@ -3491,7 +3539,7 @@ end:
 --------------------------------------------------------------------------*/
 
 static struct platform_driver udc_driver = {
-	.remove  = __exit_p(fsl_udc_remove),
+	.remove  = fsl_udc_remove,
 	/* these suspend and resume are not usb suspend and resume */
 	.suspend = fsl_udc_suspend,
 	.resume  = fsl_udc_resume,
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index 8ff5baa..013166f 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -25,6 +25,9 @@
 #ifndef __ARCOTG_UDC_H
 #define __ARCOTG_UDC_H
 
+/* delete below include when charger code moves to phy driver */
+#include "imx_usb_charger.h"
+
 #define TRUE 1
 #define FALSE 0
 
@@ -199,6 +202,7 @@ struct usb_sys_interface {
 /* Device Address bit masks */
 #define  USB_DEVICE_ADDRESS_MASK              (0xFE000000)
 #define  USB_DEVICE_ADDRESS_BIT_POS           (25)
+#define  USB_DEVICE_ADDRESS_ADV_BIT_POS       (24)
 
 /* endpoint list address bit masks */
 #define USB_EP_LIST_ADDRESS_MASK              (0xfffff800)
@@ -621,6 +625,7 @@ struct fsl_udc {
 	u32 iram_buffer[IRAM_PPH_NTD];
 	void *iram_buffer_v[IRAM_PPH_NTD];
 	struct work_struct gadget_disconnect_schedule;
+	struct usb_charger charger; /* usb charger for this udc */
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/gadget/f_uac1.c b/drivers/usb/gadget/f_uac1.c
index 1a5dcd5..fb2bc50 100644
--- a/drivers/usb/gadget/f_uac1.c
+++ b/drivers/usb/gadget/f_uac1.c
@@ -29,9 +29,16 @@ static int audio_buf_size = 48000;
 module_param(audio_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(audio_buf_size, "Audio buffer size");
 
+/* The first usb audio buf to alsa playback */
+static int first_audio_buf_size = 65500;
+module_param(first_audio_buf_size, int, S_IRUGO);
+MODULE_PARM_DESC(first_audio_buf_size, "First Audio buffer size");
+
 static int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value);
 static int generic_get_cmd(struct usb_audio_control *con, u8 cmd);
 
+/* Flag to use buffer with first_audio_buf_size to asla */
+static int first_copy_audio_buffer = 1;
 /*
  * DESCRIPTORS ... most are static, but strings and full
  * configuration descriptors are built on demand.
@@ -305,13 +312,27 @@ static int f_audio_out_ep_complete(struct usb_ep *ep, struct usb_request *req)
 	if (!copy_buf)
 		return -EINVAL;
 
+	if (!first_copy_audio_buffer) {
 	/* Copy buffer is full, add it to the play_queue */
-	if (audio_buf_size - copy_buf->actual < req->actual) {
-		list_add_tail(&copy_buf->list, &audio->play_queue);
-		schedule_work(&audio->playback_work);
-		copy_buf = f_audio_buffer_alloc(audio_buf_size);
-		if (IS_ERR(copy_buf))
-			return -ENOMEM;
+		if (audio_buf_size - copy_buf->actual < req->actual) {
+			list_add_tail(&copy_buf->list, &audio->play_queue);
+			schedule_work(&audio->playback_work);
+			copy_buf = f_audio_buffer_alloc(audio_buf_size);
+
+			if (IS_ERR(copy_buf))
+				return -ENOMEM;
+		}
+	} else {
+		if (first_audio_buf_size - copy_buf->actual < req->actual) {
+			list_add_tail(&copy_buf->list, &audio->play_queue);
+			schedule_work(&audio->playback_work);
+			copy_buf = f_audio_buffer_alloc(audio_buf_size);
+
+			if (IS_ERR(copy_buf))
+				return -ENOMEM;
+
+			first_copy_audio_buffer = 0;
+		}
 	}
 
 	memcpy(copy_buf->buf + copy_buf->actual, req->buf, req->actual);
@@ -553,7 +574,7 @@ static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		if (alt == 1) {
 			usb_ep_enable(out_ep);
 			out_ep->driver_data = audio;
-			audio->copy_buf = f_audio_buffer_alloc(audio_buf_size);
+			audio->copy_buf = f_audio_buffer_alloc(first_audio_buf_size);
 			if (IS_ERR(audio->copy_buf))
 				return -ENOMEM;
 
@@ -590,6 +611,7 @@ static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 						&audio->play_queue);
 				schedule_work(&audio->playback_work);
 			}
+			first_copy_audio_buffer = 1;
 		}
 	}
 
@@ -598,6 +620,10 @@ static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 static void f_audio_disable(struct usb_function *f)
 {
+	struct f_audio          *audio = func_to_audio(f);
+
+	usb_ep_disable(audio->out_ep);
+
 	return;
 }
 
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index a896d73..21e870b 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -489,8 +489,15 @@ struct fsg_dev {
 	struct fsg_lun		*curlun;
 	/* Must be the last entry */
 	struct fsg_buffhd	buffhds[];
+#ifdef CONFIG_FSL_UTP
+	void			*utp;
+#endif
 };
 
+#ifdef CONFIG_FSL_UTP
+#include "fsl_updater.h"
+#endif
+
 typedef void (*fsg_routine_t)(struct fsg_dev *);
 
 static int exception_in_progress(struct fsg_dev *fsg)
@@ -558,7 +565,11 @@ device_desc = {
 
 	.iManufacturer =	FSG_STRING_MANUFACTURER,
 	.iProduct =		FSG_STRING_PRODUCT,
+#ifdef CONFIG_FSL_UTP
+	.iSerialNumber = 0,
+#else
 	.iSerialNumber =	FSG_STRING_SERIAL,
+#endif
 	.bNumConfigurations =	1,
 };
 
@@ -1638,6 +1649,13 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	}
 #endif
 
+#ifdef CONFIG_FSL_UTP
+	if (utp_get_sense(fsg) == 0) {	/* got the sense from the UTP */
+		sd = UTP_CTX(fsg)->sd;
+		sdinfo = UTP_CTX(fsg)->sdinfo;
+		valid = 0;
+	} else
+#endif
 	if (!curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
 		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
@@ -1659,6 +1677,9 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	buf[7] = 18 - 8;			// Additional sense length
 	buf[12] = ASC(sd);
 	buf[13] = ASCQ(sd);
+#ifdef CONFIG_FSL_UTP
+	put_unaligned_be32(UTP_CTX(fsg)->sdinfo_h, &buf[8]);
+#endif
 	return 18;
 }
 
@@ -2150,7 +2171,11 @@ static int send_status(struct fsg_dev *fsg)
 		sd = SS_INVALID_COMMAND;
 	} else if (sd != SS_NO_SENSE) {
 		DBG(fsg, "sending command-failure status\n");
+#ifdef CONFIG_FSL_UTP
+               status = USB_STATUS_PASS;
+#else
 		status = US_BULK_STAT_FAIL;
+#endif
 		VDBG(fsg, "  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"
 				"  info x%x\n",
 				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
@@ -2380,6 +2405,13 @@ static int do_scsi_command(struct fsg_dev *fsg)
 	fsg->phase_error = 0;
 	fsg->short_packet_received = 0;
 
+#ifdef CONFIG_FSL_UTP
+	reply = utp_handle_message(fsg, fsg->cmnd, reply);
+
+	if (reply != -EINVAL)
+		return reply;
+#endif
+
 	down_read(&fsg->filesem);	// We're using the backing file
 	switch (fsg->cmnd[0]) {
 
@@ -3048,8 +3080,9 @@ static void handle_exception(struct fsg_dev *fsg)
 		break;
 
 	case FSG_STATE_DISCONNECT:
-		for (i = 0; i < fsg->nluns; ++i)
-			fsg_lun_fsync_sub(fsg->luns + i);
+		if (fsg->config != 0)
+			for (i = 0; i < fsg->nluns; ++i)
+				fsg_lun_fsync_sub(fsg->luns + i);
 		do_set_config(fsg, 0);		// Unconfigured state
 		break;
 
@@ -3080,10 +3113,12 @@ static int fsg_main_thread(void *fsg_)
 	/* Allow the thread to be frozen */
 	set_freezable();
 
+#ifndef CONFIG_FSL_UTP
 	/* Arrange for userspace references to be interpreted as kernel
 	 * pointers.  That way we can pass a kernel pointer to a routine
 	 * that expects a __user pointer and it will work okay. */
 	set_fs(get_ds());
+#endif
 
 	/* The main loop */
 	while (fsg->state != FSG_STATE_TERMINATED) {
@@ -3207,6 +3242,9 @@ static void /* __init_or_exit */ fsg_unbind(struct usb_gadget *gadget)
 	}
 
 	set_gadget_data(gadget, NULL);
+#ifdef CONFIG_FSL_UTP
+	utp_exit(fsg);
+#endif
 }
 
 
@@ -3241,6 +3279,17 @@ static int __init check_parameters(struct fsg_dev *fsg)
 
 	prot = simple_strtol(mod_data.protocol_parm, NULL, 0);
 
+#ifdef CONFIG_FSL_UTP
+	mod_data.can_stall = 0;
+	mod_data.removable = 1;
+	mod_data.nluns = 1;
+	mod_data.file[0] = NULL;
+	mod_data.vendor = 0x066F;
+	mod_data.product = 0x37FF;
+	pr_info("%s:UTP settings are in place now, overriding defaults\n",
+		__func__);
+#endif
+
 #ifdef CONFIG_USB_FILE_STORAGE_TEST
 	if (strnicmp(mod_data.transport_parm, "BBB", 10) == 0) {
 		;		// Use default setting
@@ -3329,8 +3378,9 @@ static int __init check_parameters(struct fsg_dev *fsg)
 
 	return 0;
 }
-
-
+#ifdef CONFIG_FSL_UTP
+#include "fsl_updater.c"
+#endif
 static int __init fsg_bind(struct usb_gadget *gadget)
 {
 	struct fsg_dev		*fsg = the_fsg;
@@ -3361,6 +3411,9 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	/* Only for removable media? */
 	dev_attr_nofua.attr.mode = 0644;
 	dev_attr_nofua.store = fsg_store_nofua;
+#ifdef CONFIG_FSL_UTP
+	utp_init(fsg);
+#endif
 
 	/* Find out how many LUNs there should be */
 	i = mod_data.nluns;
diff --git a/drivers/usb/gadget/fsl_updater.c b/drivers/usb/gadget/fsl_updater.c
new file mode 100644
index 0000000..39175d6
--- /dev/null
+++ b/drivers/usb/gadget/fsl_updater.c
@@ -0,0 +1,613 @@
+/*
+ * Freescale UUT driver
+ *
+ * Copyright 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+static u64 get_be64(u8 *buf)
+{
+	return ((u64)get_unaligned_be32(buf) << 32) |
+		get_unaligned_be32(buf + 4);
+}
+
+static int utp_init(struct fsg_dev *fsg)
+{
+	init_waitqueue_head(&utp_context.wq);
+	init_waitqueue_head(&utp_context.list_full_wq);
+
+	INIT_LIST_HEAD(&utp_context.read);
+	INIT_LIST_HEAD(&utp_context.write);
+	mutex_init(&utp_context.lock);
+
+	/* the max message is 64KB */
+	utp_context.buffer = vmalloc(0x10000);
+	if (!utp_context.buffer)
+		return -EIO;
+	utp_context.utp_version = 0x1ull;
+	fsg->utp = &utp_context;
+	return misc_register(&utp_dev);
+}
+
+static void utp_exit(struct fsg_dev *fsg)
+{
+	vfree(utp_context.buffer);
+	misc_deregister(&utp_dev);
+}
+
+static struct utp_user_data *utp_user_data_alloc(size_t size)
+{
+	struct utp_user_data *uud;
+
+	uud = vmalloc(size + sizeof(*uud));
+	if (!uud)
+		return uud;
+	memset(uud, 0, size + sizeof(*uud));
+	uud->data.size = size + sizeof(uud->data);
+	INIT_LIST_HEAD(&uud->link);
+	return uud;
+}
+
+static void utp_user_data_free(struct utp_user_data *uud)
+{
+	mutex_lock(&utp_context.lock);
+	list_del(&uud->link);
+	mutex_unlock(&utp_context.lock);
+	vfree(uud);
+}
+
+/* Get the number of element for list */
+static u32 count_list(struct list_head *l)
+{
+	u32 count = 0;
+	struct list_head *tmp;
+
+	mutex_lock(&utp_context.lock);
+	list_for_each(tmp, l) {
+		count++;
+	}
+	mutex_unlock(&utp_context.lock);
+
+	return count;
+}
+/* The routine will not go on if utp_context.queue is empty */
+#define WAIT_ACTIVITY(queue) \
+ wait_event_interruptible(utp_context.wq, !list_empty(&utp_context.queue))
+
+/* Called by userspace program (uuc) */
+static ssize_t utp_file_read(struct file *file,
+			     char __user *buf,
+			     size_t size,
+			     loff_t *off)
+{
+	struct utp_user_data *uud;
+	size_t size_to_put;
+	int free = 0;
+
+	WAIT_ACTIVITY(read);
+
+	mutex_lock(&utp_context.lock);
+	uud = list_first_entry(&utp_context.read, struct utp_user_data, link);
+	mutex_unlock(&utp_context.lock);
+	size_to_put = uud->data.size;
+
+	if (size >= size_to_put)
+		free = !0;
+	if (copy_to_user(buf, &uud->data, size_to_put)) {
+		printk(KERN_INFO "[ %s ] copy error\n", __func__);
+		return -EACCES;
+	}
+	if (free)
+		utp_user_data_free(uud);
+	else {
+		pr_info("sizeof = %d, size = %d\n",
+			sizeof(uud->data),
+			uud->data.size);
+
+		pr_err("Will not free utp_user_data, because buffer size = %d,"
+			"need to put %d\n", size, size_to_put);
+	}
+
+	/*
+	 * The user program has already finished data process,
+	 * go on getting data from the host
+	 */
+	wake_up(&utp_context.list_full_wq);
+
+	return size_to_put;
+}
+
+static ssize_t utp_file_write(struct file *file, const char __user *buf,
+				size_t size, loff_t *off)
+{
+	struct utp_user_data *uud;
+
+	if (size < sizeof(uud->data))
+		return -EINVAL;
+	uud = utp_user_data_alloc(size);
+	if (uud == NULL)
+		return -ENOMEM;
+	if (copy_from_user(&uud->data, buf, size)) {
+		printk(KERN_INFO "[ %s ] copy error!\n", __func__);
+		vfree(uud);
+		return -EACCES;
+	}
+	mutex_lock(&utp_context.lock);
+	list_add_tail(&uud->link, &utp_context.write);
+	/* Go on EXEC routine process */
+	wake_up(&utp_context.wq);
+	mutex_unlock(&utp_context.lock);
+	return size;
+}
+
+static long
+utp_ioctl(struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	int cpu_id = 0;
+	switch (cmd) {
+	case UTP_GET_CPU_ID:
+/* Currently, it only supports below SoC for manufacture tool
+ * The naming rule
+ * 1. The numberic for SoC string
+ * 2. If there is next SoC version, and the corresponding utp
+ * operation will be differ, then, need to add '1' next to SoC
+ * name. Such as the next 50 SoC version is: cpu_is = 501
+ */
+#ifdef CONFIG_ARCH_MXS
+		if (cpu_is_mx23())
+			cpu_id = 23;
+		else if (cpu_is_mx28())
+			cpu_id = 28;
+#endif
+#ifdef CONFIG_ARCH_MXC
+		if (cpu_is_mx25())
+			cpu_id = 25;
+		else if (cpu_is_mx35())
+			cpu_id = 35;
+		else if (cpu_is_mx51())
+			cpu_id = 51;
+		else if (cpu_is_mx53())
+			cpu_id = 53;
+		else if (cpu_is_mx50())
+			cpu_id = 50;
+#endif
+		return put_user(cpu_id, (int __user *)arg);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+/* Will be called when the host wants to get the sense data */
+static int utp_get_sense(struct fsg_dev *fsg)
+{
+	if (UTP_CTX(fsg)->processed == 0)
+		return -1;
+
+	UTP_CTX(fsg)->processed = 0;
+	return 0;
+}
+
+static int utp_do_read(struct fsg_dev *fsg, void *data, size_t size)
+{
+	struct fsg_buffhd	*bh;
+	int			rc;
+	u32			amount_left;
+	unsigned int		amount;
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+
+	amount_left = size;
+	if (unlikely(amount_left == 0))
+		return -EIO;		/* No default reply*/
+
+	pr_debug("%s: sending %d\n", __func__, size);
+	for (;;) {
+		/* Figure out how much we need to read:
+		 * Try to read the remaining amount.
+		 * But don't read more than the buffer size.
+		 * And don't try to read past the end of the file.
+		 * Finally, if we're not at a page boundary, don't read past
+		 *	the next page.
+		 * If this means reading 0 then we were asked to read past
+		 *	the end of file. */
+		amount = min((unsigned int) amount_left, mod_data.buflen);
+
+		/* Wait for the next buffer to become available */
+		bh = fsg->next_buffhd_to_fill;
+		while (bh->state != BUF_STATE_EMPTY) {
+			rc = sleep_thread(fsg);
+			if (rc)
+				return rc;
+		}
+
+		/* If we were asked to read past the end of file,
+		 * end with an empty buffer. */
+		if (amount == 0) {
+			bh->inreq->length = 0;
+			bh->state = BUF_STATE_FULL;
+			break;
+		}
+
+		/* Perform the read */
+		pr_info("Copied to %p, %d bytes started from %d\n",
+				bh->buf, amount, size - amount_left);
+		/* from upt buffer to file_storeage buffer */
+		memcpy(bh->buf, data + size - amount_left, amount);
+		amount_left  -= amount;
+		fsg->residue -= amount;
+
+		bh->inreq->length = amount;
+		bh->state = BUF_STATE_FULL;
+
+		/* Send this buffer and go read some more */
+		bh->inreq->zero = 0;
+
+		/* USB Physical transfer: Data from device to host */
+		start_transfer(fsg, fsg->bulk_in, bh->inreq,
+				&bh->inreq_busy, &bh->state);
+
+		fsg->next_buffhd_to_fill = bh->next;
+
+		if (amount_left <= 0)
+			break;
+	}
+
+	return size - amount_left;
+}
+
+static int utp_do_write(struct fsg_dev *fsg, void *data, size_t size)
+{
+	struct fsg_buffhd	*bh;
+	int			get_some_more;
+	u32			amount_left_to_req, amount_left_to_write;
+	unsigned int		amount;
+	int			rc;
+	loff_t			offset;
+
+	/* Carry out the file writes */
+	get_some_more = 1;
+	amount_left_to_req = amount_left_to_write = size;
+
+	if (unlikely(amount_left_to_write == 0))
+		return -EIO;
+
+	offset = 0;
+	while (amount_left_to_write > 0) {
+
+		/* Queue a request for more data from the host */
+		bh = fsg->next_buffhd_to_fill;
+		if (bh->state == BUF_STATE_EMPTY && get_some_more) {
+
+			/* Figure out how much we want to get:
+			 * Try to get the remaining amount.
+			 * But don't get more than the buffer size.
+			 * And don't try to go past the end of the file.
+			 * If we're not at a page boundary,
+			 *	don't go past the next page.
+			 * If this means getting 0, then we were asked
+			 *	to write past the end of file.
+			 * Finally, round down to a block boundary. */
+			amount = min(amount_left_to_req, mod_data.buflen);
+
+			if (amount == 0) {
+				get_some_more = 0;
+				/* cry now */
+				continue;
+			}
+
+			/* Get the next buffer */
+			amount_left_to_req -= amount;
+			if (amount_left_to_req == 0)
+				get_some_more = 0;
+
+			/* amount is always divisible by 512, hence by
+			 * the bulk-out maxpacket size */
+			bh->outreq->length = bh->bulk_out_intended_length =
+					amount;
+			bh->outreq->short_not_ok = 1;
+			start_transfer(fsg, fsg->bulk_out, bh->outreq,
+					&bh->outreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+			continue;
+		}
+
+		/* Write the received data to the backing file */
+		bh = fsg->next_buffhd_to_drain;
+		if (bh->state == BUF_STATE_EMPTY && !get_some_more)
+			break;			/* We stopped early */
+		if (bh->state == BUF_STATE_FULL) {
+			smp_rmb();
+			fsg->next_buffhd_to_drain = bh->next;
+			bh->state = BUF_STATE_EMPTY;
+
+			/* Did something go wrong with the transfer? */
+			if (bh->outreq->status != 0)
+				/* cry again, COMMUNICATION_FAILURE */
+				break;
+
+			amount = bh->outreq->actual;
+
+			/* Perform the write */
+			memcpy(data + offset, bh->buf, amount);
+
+			offset += amount;
+			if (signal_pending(current))
+				return -EINTR;		/* Interrupted!*/
+			amount_left_to_write -= amount;
+			fsg->residue -= amount;
+
+			/* Did the host decide to stop early? */
+			if (bh->outreq->actual != bh->outreq->length) {
+				fsg->short_packet_received = 1;
+				break;
+			}
+			continue;
+		}
+
+		/* Wait for something to happen */
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	return -EIO;
+}
+
+static inline void utp_set_sense(struct fsg_dev *fsg, u16 code, u64 reply)
+{
+	UTP_CTX(fsg)->processed = true;
+	UTP_CTX(fsg)->sdinfo = reply & 0xFFFFFFFF;
+	UTP_CTX(fsg)->sdinfo_h = (reply >> 32) & 0xFFFFFFFF;
+	UTP_CTX(fsg)->sd = (UTP_SENSE_KEY << 16) | code;
+}
+
+static void utp_poll(struct fsg_dev *fsg)
+{
+	struct utp_context *ctx = UTP_CTX(fsg);
+	struct utp_user_data *uud = NULL;
+
+	mutex_lock(&ctx->lock);
+	if (!list_empty(&ctx->write))
+		uud = list_first_entry(&ctx->write, struct utp_user_data, link);
+	mutex_unlock(&ctx->lock);
+
+	if (uud) {
+		if (uud->data.flags & UTP_FLAG_STATUS) {
+			printk(KERN_WARNING "%s: exit with status %d\n",
+					__func__, uud->data.status);
+			UTP_SS_EXIT(fsg, uud->data.status);
+		} else if (uud->data.flags & UTP_FLAG_REPORT_BUSY) {
+			UTP_SS_BUSY(fsg, --ctx->counter);
+		} else {
+			printk("%s: pass returned.\n", __func__);
+			UTP_SS_PASS(fsg);
+		}
+		utp_user_data_free(uud);
+	} else {
+		if (utp_context.cur_state & UTP_FLAG_DATA) {
+			if (count_list(&ctx->read) < 7) {
+				pr_debug("%s: pass returned in POLL stage. \n", __func__);
+				UTP_SS_PASS(fsg);
+				utp_context.cur_state = 0;
+				return;
+			}
+		}
+		UTP_SS_BUSY(fsg, --ctx->counter);
+	}
+}
+
+static int utp_exec(struct fsg_dev *fsg,
+		    char *command,
+		    int cmdsize,
+		    unsigned long long payload)
+{
+	struct utp_user_data *uud = NULL, *uud2r;
+	struct utp_context *ctx = UTP_CTX(fsg);
+
+	ctx->counter = 0xFFFF;
+	uud2r = utp_user_data_alloc(cmdsize + 1);
+	if (!uud2r)
+		return -ENOMEM;
+	uud2r->data.flags = UTP_FLAG_COMMAND;
+	uud2r->data.payload = payload;
+	strncpy(uud2r->data.command, command, cmdsize);
+
+	mutex_lock(&ctx->lock);
+	list_add_tail(&uud2r->link, &ctx->read);
+	mutex_unlock(&ctx->lock);
+	/* wake up the read routine */
+	wake_up(&ctx->wq);
+
+	if (command[0] == '!')	/* there will be no response */
+		return 0;
+
+	/*
+	 * the user program (uuc) will return utp_message
+	 * and add list to write list
+	 */
+	WAIT_ACTIVITY(write);
+
+	mutex_lock(&ctx->lock);
+	if (!list_empty(&ctx->write)) {
+		uud = list_first_entry(&ctx->write, struct utp_user_data, link);
+#ifdef DEBUG
+		pr_info("UUD:\n\tFlags = %02X\n", uud->data.flags);
+		if (uud->data.flags & UTP_FLAG_DATA) {
+			pr_info("\tbufsize = %d\n", uud->data.bufsize);
+			print_hex_dump(KERN_DEBUG, "\t", DUMP_PREFIX_NONE,
+				16, 2, uud->data.data, uud->data.bufsize, true);
+		}
+		if (uud->data.flags & UTP_FLAG_REPORT_BUSY)
+			pr_info("\tBUSY\n");
+#endif
+	}
+	mutex_unlock(&ctx->lock);
+
+	if (uud->data.flags & UTP_FLAG_DATA) {
+		memcpy(ctx->buffer, uud->data.data, uud->data.bufsize);
+		UTP_SS_SIZE(fsg, uud->data.bufsize);
+	} else if (uud->data.flags & UTP_FLAG_REPORT_BUSY) {
+		UTP_SS_BUSY(fsg, ctx->counter);
+	} else if (uud->data.flags & UTP_FLAG_STATUS) {
+		printk(KERN_WARNING "%s: exit with status %d\n", __func__,
+				uud->data.status);
+		UTP_SS_EXIT(fsg, uud->data.status);
+	} else {
+		pr_debug("%s: pass returned in EXEC stage. \n", __func__);
+		UTP_SS_PASS(fsg);
+	}
+	utp_user_data_free(uud);
+	return 0;
+}
+
+static int utp_send_status(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	u8			status = USB_STATUS_PASS;
+	struct bulk_cs_wrap	*csw;
+	int 			rc;
+
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	if (fsg->phase_error) {
+		DBG(fsg, "sending phase-error status\n");
+		status = USB_STATUS_PHASE_ERROR;
+
+	} else if ((UTP_CTX(fsg)->sd & 0xFFFF) != UTP_REPLY_PASS) {
+		status = USB_STATUS_FAIL;
+	}
+
+	csw = bh->buf;
+
+	/* Store and send the Bulk-only CSW */
+	csw->Signature = __constant_cpu_to_le32(USB_BULK_CS_SIG);
+	csw->Tag = fsg->tag;
+	csw->Residue = cpu_to_le32(fsg->residue);
+	csw->Status = status;
+
+	bh->inreq->length = USB_BULK_CS_WRAP_LEN;
+	bh->inreq->zero = 0;
+	start_transfer(fsg, fsg->bulk_in, bh->inreq,
+			&bh->inreq_busy, &bh->state);
+	fsg->next_buffhd_to_fill = bh->next;
+	return 0;
+}
+
+static int utp_handle_message(struct fsg_dev *fsg,
+			      char *cdb_data,
+			      int default_reply)
+{
+	struct utp_msg *m = (struct utp_msg *)cdb_data;
+	void *data = NULL;
+	int r;
+	struct utp_user_data *uud2r;
+	unsigned long long param;
+	unsigned long tag;
+
+	if (m->f0 != 0xF0)
+		return default_reply;
+
+	tag = get_unaligned_be32((void *)&m->utp_msg_tag);
+	param = get_be64((void *)&m->param);
+	pr_debug("Type 0x%x, tag 0x%08lx, param %llx\n",
+			m->utp_msg_type, tag, param);
+
+	switch ((enum utp_msg_type)m->utp_msg_type) {
+
+	case UTP_POLL:
+		if (get_be64((void *)&m->param) == 1) {
+			pr_debug("%s: version request\n", __func__);
+			UTP_SS_EXIT(fsg, UTP_CTX(fsg)->utp_version);
+			break;
+		}
+		utp_poll(fsg);
+		break;
+	case UTP_EXEC:
+		pr_debug("%s: EXEC\n", __func__);
+		data = vmalloc(fsg->data_size);
+		memset(data, 0, fsg->data_size);
+		/* copy data from usb buffer to utp buffer */
+		utp_do_write(fsg, data, fsg->data_size);
+		utp_exec(fsg, data, fsg->data_size, param);
+		vfree(data);
+		break;
+	case UTP_GET: /* data from device to host */
+		pr_debug("%s: GET, %d bytes\n", __func__, fsg->data_size);
+		r = utp_do_read(fsg, UTP_CTX(fsg)->buffer, fsg->data_size);
+		UTP_SS_PASS(fsg);
+		break;
+	case UTP_PUT:
+		utp_context.cur_state =  UTP_FLAG_DATA;
+		pr_debug("%s: PUT, Received %d bytes\n", __func__, fsg->data_size);/* data from host to device */
+		uud2r = utp_user_data_alloc(fsg->data_size);
+		if (!uud2r)
+			return -ENOMEM;
+		uud2r->data.bufsize = fsg->data_size;
+		uud2r->data.flags = UTP_FLAG_DATA;
+		utp_do_write(fsg, uud2r->data.data, fsg->data_size);
+		/* don't know what will be written */
+		mutex_lock(&UTP_CTX(fsg)->lock);
+		list_add_tail(&uud2r->link, &UTP_CTX(fsg)->read);
+		mutex_unlock(&UTP_CTX(fsg)->lock);
+		wake_up(&UTP_CTX(fsg)->wq);
+		/*
+		 * Return PASS or FAIL according to uuc's status
+		 * Please open it if need to check uuc's status
+		 * and use another version uuc
+		 */
+#if 0
+		struct utp_user_data *uud = NULL;
+		struct utp_context *ctx;
+		WAIT_ACTIVITY(write);
+		ctx = UTP_CTX(fsg);
+		mutex_lock(&ctx->lock);
+
+		if (!list_empty(&ctx->write))
+			uud = list_first_entry(&ctx->write,
+					struct utp_user_data, link);
+
+		mutex_unlock(&ctx->lock);
+		if (uud) {
+			if (uud->data.flags & UTP_FLAG_STATUS) {
+				printk(KERN_WARNING "%s: exit with status %d\n",
+					 __func__, uud->data.status);
+				UTP_SS_EXIT(fsg, uud->data.status);
+			} else {
+				pr_debug("%s: pass\n", __func__);
+				UTP_SS_PASS(fsg);
+			}
+			utp_user_data_free(uud);
+		} else{
+			UTP_SS_PASS(fsg);
+		}
+#endif
+		if (count_list(&UTP_CTX(fsg)->read) < 7) {
+			utp_context.cur_state = 0;
+			UTP_SS_PASS(fsg);
+		} else
+			UTP_SS_BUSY(fsg, UTP_CTX(fsg)->counter);
+
+		break;
+	}
+
+	utp_send_status(fsg);
+	return -1;
+}
+
diff --git a/drivers/usb/gadget/fsl_updater.h b/drivers/usb/gadget/fsl_updater.h
new file mode 100644
index 0000000..e2cac2d
--- /dev/null
+++ b/drivers/usb/gadget/fsl_updater.h
@@ -0,0 +1,149 @@
+/*
+ * Freescale UUT driver
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc.
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __FSL_UPDATER_H
+#define __FSL_UPDATER_H
+
+#include <linux/miscdevice.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+#include <linux/ioctl.h>
+#include <mach/hardware.h>
+
+static int utp_init(struct fsg_dev *fsg);
+static void utp_exit(struct fsg_dev *fsg);
+static ssize_t utp_file_read(struct file *file,
+			     char __user *buf,
+			     size_t size,
+			     loff_t *off);
+
+static ssize_t utp_file_write(struct file *file,
+			      const char __user *buf,
+			      size_t size,
+			      loff_t *off);
+
+static long utp_ioctl(struct file *file,
+	      unsigned int cmd, unsigned long arg);
+static struct utp_user_data *utp_user_data_alloc(size_t size);
+static void utp_user_data_free(struct utp_user_data *uud);
+static int utp_get_sense(struct fsg_dev *fsg);
+static int utp_do_read(struct fsg_dev *fsg, void *data, size_t size);
+static int utp_do_write(struct fsg_dev *fsg, void *data, size_t size);
+static inline void utp_set_sense(struct fsg_dev *fsg, u16 code, u64 reply);
+static int utp_handle_message(struct fsg_dev *fsg,
+			      char *cdb_data,
+			      int default_reply);
+
+#define UTP_REPLY_PASS		0
+#define UTP_REPLY_EXIT		0x8001
+#define UTP_REPLY_BUSY		0x8002
+#define UTP_REPLY_SIZE		0x8003
+#define UTP_SENSE_KEY		9
+
+#define UTP_MINOR		222
+/* MISC_DYNAMIC_MINOR would be better, but... */
+
+#define UTP_COMMAND_SIZE	80
+
+#define UTP_SS_EXIT(fsg, r) 	utp_set_sense(fsg, UTP_REPLY_EXIT, (u64)r)
+#define UTP_SS_PASS(fsg)	utp_set_sense(fsg, UTP_REPLY_PASS, 0)
+#define UTP_SS_BUSY(fsg, r)	utp_set_sense(fsg, UTP_REPLY_BUSY, (u64)r)
+#define UTP_SS_SIZE(fsg, r)	utp_set_sense(fsg, UTP_REPLY_SIZE, (u64)r)
+
+#define	UTP_IOCTL_BASE	'U'
+#define	UTP_GET_CPU_ID	_IOR(UTP_IOCTL_BASE, 0, int)
+/* the structure of utp message which is mapped to 16-byte SCSI CBW's CDB */
+#pragma pack(1)
+struct utp_msg {
+	u8  f0;
+	u8  utp_msg_type;
+	u32 utp_msg_tag;
+	union {
+		struct {
+			u32 param_lsb;
+			u32 param_msb;
+		};
+		u64 param;
+	};
+};
+
+enum utp_msg_type {
+	UTP_POLL = 0,
+	UTP_EXEC,
+	UTP_GET,
+	UTP_PUT,
+};
+
+static struct utp_context {
+	wait_queue_head_t wq;
+	wait_queue_head_t list_full_wq;
+	struct mutex lock;
+	struct list_head read;
+	struct list_head write;
+	u32 sd, sdinfo, sdinfo_h;			/* sense data */
+	int processed;
+	u8 *buffer;
+	u32 counter;
+	u64 utp_version;
+	u32 cur_state;
+} utp_context;
+
+static const struct file_operations utp_fops = {
+	.open	= nonseekable_open,
+	.read	= utp_file_read,
+	.write	= utp_file_write,
+	.unlocked_ioctl = utp_ioctl,
+};
+
+static struct miscdevice utp_dev = {
+	.minor 	= UTP_MINOR,
+	.name 	= "utp",
+	.fops	= &utp_fops,
+};
+
+#define UTP_FLAG_COMMAND	0x00000001
+#define UTP_FLAG_DATA		0x00000002
+#define UTP_FLAG_STATUS		0x00000004
+#define UTP_FLAG_REPORT_BUSY	0x10000000
+struct utp_message {
+	u32 	flags;
+	size_t 	size;
+	union {
+		struct {
+			u64 payload;
+			char command[1];
+		};
+		struct {
+			size_t bufsize;
+			u8 data[1];
+		};
+		u32 status;
+	};
+};
+
+struct utp_user_data {
+	struct  list_head 	link;
+	struct  utp_message	data;
+};
+#pragma pack()
+
+static inline struct utp_context *UTP_CTX(struct fsg_dev *fsg)
+{
+	return (struct utp_context *)fsg->utp;
+}
+
+#endif /* __FSL_UPDATER_H */
+
diff --git a/drivers/usb/gadget/imx_usb_charger.c b/drivers/usb/gadget/imx_usb_charger.c
new file mode 100644
index 0000000..33242a7
--- /dev/null
+++ b/drivers/usb/gadget/imx_usb_charger.c
@@ -0,0 +1,343 @@
+/*
+ * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * NOTICE: Currently, it only supports i.mx6q usb charger detect
+ */
+
+static void my_batt_ext_power_changed(struct power_supply *psy)
+{
+	int mA;
+	union power_supply_propval ret = {0,};
+	printk(KERN_INFO "my_batt_ext_power_changed!\n");
+	if (!power_supply_am_i_supplied(psy)) {
+		/* stop charging */
+		printk(KERN_ERR "It is not usb supply!\n");
+		return;
+	}
+	power_supply_get_supplier_property(psy,
+		POWER_SUPPLY_PROP_ONLINE, &ret);
+
+	printk(KERN_INFO "imx6 usb charger online:%d\n", ret.intval);
+
+	power_supply_get_supplier_property(psy,
+		POWER_SUPPLY_PROP_CURRENT_MAX, &ret);
+		/* maximum milliamps we are allowed to draw from VBUS */
+	mA = ret.intval;
+	printk(KERN_INFO "imx6 usb charger limit mA: %d\n", mA);
+}
+
+
+static int usb_charger_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct usb_charger *charger =
+		container_of(psy, struct usb_charger, psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->online;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->max_current;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void usb_charger_work(struct work_struct *data)
+{
+	int			ret;
+	struct usb_charger	*charger =
+			container_of(data, struct usb_charger, work);
+
+	if (!charger->online)
+		return;
+
+	mutex_lock(&charger->lock);
+
+	/* Start the primary charger detection. */
+	if (charger->detect) {
+		ret = charger->detect(charger);
+		if (ret <= 0)
+			dev_err(charger->dev, "Error occurs during usb charger \
+					detection\n");
+		else
+			charger->present = ret;
+	}
+
+	switch (charger->psy.type) {
+	case POWER_SUPPLY_TYPE_USB_DCP:
+		charger->max_current = 1500;
+		break;
+	case POWER_SUPPLY_TYPE_USB_CDP:
+		charger->max_current = 900;
+		break;
+	case POWER_SUPPLY_TYPE_USB: /* SDP */
+		charger->max_current = 500;
+	default:
+		if (charger->dp_pullup)
+			charger->dp_pullup(true);
+		break;
+	}
+
+	power_supply_changed(&charger->psy);
+
+	mutex_unlock(&charger->lock);
+}
+
+/* Return value if the charger is present */
+static int usb_charger_detect(struct usb_charger *charger)
+{
+	void __iomem *addr = charger->charger_base_addr;
+	int i;
+
+	BUG_ON(!addr);
+
+	/* Enable the vdd3p0 curret limiter */
+	writel(BM_ANADIG_REG_3P0_ENABLE_LINREG |
+			BM_ANADIG_REG_3P0_ENABLE_ILIMIT,
+			addr + HW_ANADIG_REG_3P0_SET);
+
+	/* check if vbus is valid */
+	if (!(readl(addr + HW_ANADIG_USB1_VBUS_DET_STAT) &
+			BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID)) {
+		dev_err(charger->dev, "vbus is error\n");
+		return 0;
+	}
+
+	/* Enable charger detector */
+	writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B,
+			addr + HW_ANADIG_USB1_CHRG_DETECT_CLR);
+	/*
+	 * - Do not check whether a charger is connected to the USB port
+	 * - Check whether the USB plug has been in contact with each other
+	 */
+	writel(BM_ANADIG_USB1_CHRG_DETECT_CHK_CONTACT
+			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+			addr + HW_ANADIG_USB1_CHRG_DETECT_SET);
+
+	/* Check if plug is connected */
+	for (i = 0; i < 1000; i = i + 1) {
+		if (readl(addr + HW_ANADIG_USB1_CHRG_DET_STAT) &
+			BM_ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT) {
+			dev_dbg(charger->dev, "Plug Contact = 1\n");
+			break;
+		} else if (i > 800) {
+			dev_err(charger->dev, "VBUS is coming from a dedicated power supply.\n");
+			return 0;
+		} else
+			msleep(1);
+	}
+
+	/*
+	 * - Do check whether a charger is connected to the USB port
+	 * - Do not Check whether the USB plug has been in contact with each other
+	 */
+	writel(BM_ANADIG_USB1_CHRG_DETECT_CHK_CONTACT
+			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+			addr + HW_ANADIG_USB1_CHRG_DETECT_CLR);
+
+	msleep(40);
+
+	/* Check if it is a charger */
+	if (!(readl(addr + HW_ANADIG_USB1_CHRG_DET_STAT) &
+			BM_ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED)) {
+		dev_info(charger->dev, "It is a stardard downstream port\n");
+		charger->psy.type = POWER_SUPPLY_TYPE_USB;
+
+		/* Disable Charger detector */
+		writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B
+			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+			addr + HW_ANADIG_USB1_CHRG_DETECT);
+
+		/* Disable the vdd3p0 curret limiter */
+		writel(BM_ANADIG_REG_3P0_ENABLE_ILIMIT,
+				addr + HW_ANADIG_REG_3P0_CLR);
+		return 1;
+	}
+
+	/* Begin to detect CDP and DCP */
+
+	/* Disable Charger detector */
+	writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B
+		| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		addr + HW_ANADIG_USB1_CHRG_DETECT);
+
+	msleep(40);
+
+	/* Disable the vdd3p0 curret limiter */
+	writel(BM_ANADIG_REG_3P0_ENABLE_ILIMIT,
+			addr + HW_ANADIG_REG_3P0_CLR);
+
+	/* pull up dp */
+	if (charger->dp_pullup)
+		charger->dp_pullup(true);
+
+	msleep(40);
+
+	if ((readl(&dr_regs->portsc1) & PORTSCX_LINE_STATUS_KSTATE)) {
+		dev_info(charger->dev, "It is a dedicate charging port\n");
+		charger->psy.type = POWER_SUPPLY_TYPE_USB_DCP;
+	} else {
+		dev_info(charger->dev, "It is a charging downstream port\n");
+		charger->psy.type = POWER_SUPPLY_TYPE_USB_CDP;
+	}
+
+	return 1;
+}
+
+static void usb_charger_init(struct usb_charger *charger)
+{
+	charger->bc = BATTERY_CHARGING_SPEC_1_2;
+	charger->detect = usb_charger_detect;
+}
+
+/*
+ * imx_usb_create_charger - create a USB charger
+ * @charger: the charger to be initialized
+ * @name: name for the power supply
+
+ * Registers a power supply for the charger. The PHY/UDC driver will
+ * call this after filling struct usb_charger. All the users are
+ * expected to be in the supplied_to parameter.
+ */
+int imx_usb_create_charger(struct usb_charger *charger,
+		const char *name)
+{
+	int			ret = 0;
+	struct power_supply	*psy = &charger->psy;
+
+	if (!charger->dev)
+		return -EINVAL;
+
+	if (name)
+		psy->name = name;
+	else
+		psy->name = "usb_charger";
+
+	usb_charger_init(charger);
+
+	psy->type		= POWER_SUPPLY_TYPE_USB;
+	psy->properties		= power_props;
+	psy->num_properties	= ARRAY_SIZE(power_props);
+	psy->get_property	= usb_charger_get_property;
+
+	psy->supplied_to	= usb_charger_supplied_to;
+	psy->num_supplicants	= sizeof(usb_charger_supplied_to)/sizeof(char *);
+	psy->external_power_changed = my_batt_ext_power_changed;
+
+	ret = power_supply_register(charger->dev, psy);
+	if (ret)
+		goto fail;
+
+	mutex_init(&charger->lock);
+	INIT_WORK(&charger->work, usb_charger_work);
+
+fail:
+	return ret;
+}
+EXPORT_SYMBOL(imx_usb_create_charger);
+
+/*
+ * imx_usb_remove_charger - remove a USB charger
+ * @charger: the charger to be removed
+ *
+ * Unregister the chargers power supply.
+ */
+void imx_usb_remove_charger(struct usb_charger *charger)
+{
+	power_supply_unregister(&charger->psy);
+}
+EXPORT_SYMBOL(imx_usb_remove_charger);
+
+/*
+ * imx_usb_set_power - Set the maximum power allowed to draw
+ * @charger: the usb charger
+ * @mA: maximum current in milliamps
+ *
+ * Called from the controller after enumeration to inform the maximum
+ * power from the configuration, and after bus suspend and resume.
+ */
+int imx_usb_set_power(struct usb_charger *charger, unsigned mA)
+{
+	if (!charger->online)
+		return 0;
+
+	if (charger->max_current == mA)
+		return 0;
+
+	charger->max_current = mA;
+
+	power_supply_changed(&charger->psy);
+
+	return 0;
+}
+EXPORT_SYMBOL(imx_usb_set_power);
+
+/*
+ * imx_usb_vbus_connect - inform about VBUS connection
+ * @charger: the usb charger
+ *
+ * Inform the charger VBUS is connected. The USB device controller is
+ * expected to keep the dataline pullups disabled until dp_pullup()
+ * is called.
+ */
+int imx_usb_vbus_connect(struct usb_charger *charger)
+{
+	/* if charger is disabled, set usbcmd.rs=1 and return directly */
+	if (!charger->enable) {
+		if (charger->dp_pullup)
+			charger->dp_pullup(true);
+		return 0;
+	}
+
+	charger->online = 1;
+	schedule_work(&charger->work);
+
+	return 0;
+}
+EXPORT_SYMBOL(imx_usb_vbus_connect);
+
+/*
+ * imx_usb_vbus_disconnect - inform about VBUS disconnection
+ * @charger: the usb charger
+ *
+ * Inform the charger that VBUS is disconnected. The charging will be
+ * stopped and the charger properties cleared.
+ */
+int imx_usb_vbus_disconnect(struct usb_charger *charger)
+{
+	if (!charger->enable)
+		return 0;
+
+	/* in case, the charger detect is doing or pending */
+	cancel_work_sync(&charger->work);
+
+	charger->online = 0;
+	charger->present = 0;
+	charger->max_current = 0;
+	charger->psy.type = POWER_SUPPLY_TYPE_USB;
+
+	if (charger->disconnect)
+		charger->disconnect(charger);
+
+	power_supply_changed(&charger->psy);
+
+	return 0;
+}
+EXPORT_SYMBOL(imx_usb_vbus_disconnect);
diff --git a/drivers/usb/gadget/imx_usb_charger.h b/drivers/usb/gadget/imx_usb_charger.h
new file mode 100644
index 0000000..b3beb0f
--- /dev/null
+++ b/drivers/usb/gadget/imx_usb_charger.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * NOTICE: Currently, it only supports i.mx6q usb charger detect
+ */
+
+#ifndef __IMXUSB_CHARGER_H
+#define __IMXUSB_CHARGER_H
+
+#define HW_ANADIG_REG_3P0	(0x00000120)
+#define HW_ANADIG_REG_3P0_SET	(0x00000124)
+#define HW_ANADIG_REG_3P0_CLR	(0x00000128)
+#define HW_ANADIG_REG_3P0_TOG	(0x0000012c)
+#define BM_ANADIG_REG_3P0_ENABLE_ILIMIT 0x00000004
+#define BM_ANADIG_REG_3P0_ENABLE_LINREG 0x00000001
+
+#define HW_ANADIG_USB1_VBUS_DETECT	(0x000001a0)
+#define HW_ANADIG_USB1_VBUS_DETECT_SET	(0x000001a4)
+#define HW_ANADIG_USB1_VBUS_DETECT_CLR	(0x000001a8)
+#define HW_ANADIG_USB1_VBUS_DETECT_TOG	(0x000001ac)
+
+#define BM_ANADIG_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR 0x80000000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD2      28
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD2 0x70000000
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD2(v)  \
+	(((v) << 28) & BM_ANADIG_USB1_VBUS_DETECT_RSVD2)
+#define BM_ANADIG_USB1_VBUS_DETECT_CHARGE_VBUS 0x08000000
+#define BM_ANADIG_USB1_VBUS_DETECT_DISCHARGE_VBUS 0x04000000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD1      21
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD1 0x03E00000
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB1_VBUS_DETECT_RSVD1)
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS 0x00100000
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_5VDETECT 0x00080000
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_TO_B 0x00040000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD0      8
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD0 0x0003FF00
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD0(v)  \
+	(((v) << 8) & BM_ANADIG_USB1_VBUS_DETECT_RSVD0)
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE 0x00000080
+#define BM_ANADIG_USB1_VBUS_DETECT_AVALID_OVERRIDE 0x00000040
+#define BM_ANADIG_USB1_VBUS_DETECT_BVALID_OVERRIDE 0x00000020
+#define BM_ANADIG_USB1_VBUS_DETECT_SESSEND_OVERRIDE 0x00000010
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN 0x00000008
+#define BP_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH      0
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH 0x00000007
+#define BF_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH(v)  \
+	(((v) << 0) & BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH)
+
+#define HW_ANADIG_USB1_CHRG_DETECT	(0x000001b0)
+#define HW_ANADIG_USB1_CHRG_DETECT_SET	(0x000001b4)
+#define HW_ANADIG_USB1_CHRG_DETECT_CLR	(0x000001b8)
+#define HW_ANADIG_USB1_CHRG_DETECT_TOG	(0x000001bc)
+
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD2      24
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD2 0xFF000000
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD2(v) \
+	(((v) << 24) & BM_ANADIG_USB1_CHRG_DETECT_RSVD2)
+#define BM_ANADIG_USB1_CHRG_DETECT_BGR_BIAS 0x00800000
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD1      21
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD1 0x00600000
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB1_CHRG_DETECT_RSVD1)
+#define BM_ANADIG_USB1_CHRG_DETECT_EN_B 0x00100000
+#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B 0x00080000
+#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CONTACT 0x00040000
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD0      1
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD0 0x0003FFFE
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD0(v)  \
+	(((v) << 1) & BM_ANADIG_USB1_CHRG_DETECT_RSVD0)
+#define BM_ANADIG_USB1_CHRG_DETECT_FORCE_DETECT 0x00000001
+
+#define HW_ANADIG_USB1_VBUS_DET_STAT	(0x000001c0)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_SET	(0x000001c4)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_CLR	(0x000001c8)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_TOG	(0x000001cc)
+
+#define BP_ANADIG_USB1_VBUS_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB1_VBUS_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB1_VBUS_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB1_VBUS_DET_STAT_RSVD0)
+#define BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID 0x00000008
+#define BM_ANADIG_USB1_VBUS_DET_STAT_AVALID 0x00000004
+#define BM_ANADIG_USB1_VBUS_DET_STAT_BVALID 0x00000002
+#define BM_ANADIG_USB1_VBUS_DET_STAT_SESSEND 0x00000001
+
+#define HW_ANADIG_USB1_CHRG_DET_STAT	(0x000001d0)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_SET	(0x000001d4)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_CLR	(0x000001d8)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_TOG	(0x000001dc)
+
+#define BP_ANADIG_USB1_CHRG_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB1_CHRG_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB1_CHRG_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB1_CHRG_DET_STAT_RSVD0)
+#define BM_ANADIG_USB1_CHRG_DET_STAT_DP_STATE 0x00000008
+#define BM_ANADIG_USB1_CHRG_DET_STAT_DM_STATE 0x00000004
+#define BM_ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED 0x00000002
+#define BM_ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT 0x00000001
+
+#define HW_ANADIG_USB1_LOOPBACK	(0x000001e0)
+#define HW_ANADIG_USB1_LOOPBACK_SET	(0x000001e4)
+#define HW_ANADIG_USB1_LOOPBACK_CLR	(0x000001e8)
+#define HW_ANADIG_USB1_LOOPBACK_TOG	(0x000001ec)
+
+#define BP_ANADIG_USB1_LOOPBACK_RSVD0      9
+#define BM_ANADIG_USB1_LOOPBACK_RSVD0 0xFFFFFE00
+#define BF_ANADIG_USB1_LOOPBACK_RSVD0(v) \
+	(((v) << 9) & BM_ANADIG_USB1_LOOPBACK_RSVD0)
+#define BM_ANADIG_USB1_LOOPBACK_UTMO_DIG_TST1 0x00000100
+#define BM_ANADIG_USB1_LOOPBACK_UTMO_DIG_TST0 0x00000080
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_HIZ 0x00000040
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_EN 0x00000020
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_LS_MODE 0x00000010
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_HS_MODE 0x00000008
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST1 0x00000004
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST0 0x00000002
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_TESTSTART 0x00000001
+
+#define HW_ANADIG_USB1_MISC	(0x000001f0)
+#define HW_ANADIG_USB1_MISC_SET	(0x000001f4)
+#define HW_ANADIG_USB1_MISC_CLR	(0x000001f8)
+#define HW_ANADIG_USB1_MISC_TOG	(0x000001fc)
+
+#define BM_ANADIG_USB1_MISC_RSVD1 0x80000000
+#define BM_ANADIG_USB1_MISC_EN_CLK_UTMI 0x40000000
+#define BM_ANADIG_USB1_MISC_RX_VPIN_FS 0x20000000
+#define BM_ANADIG_USB1_MISC_RX_VMIN_FS 0x10000000
+#define BM_ANADIG_USB1_MISC_RX_RXD_FS 0x08000000
+#define BM_ANADIG_USB1_MISC_RX_SQUELCH 0x04000000
+#define BM_ANADIG_USB1_MISC_RX_DISCON_DET 0x02000000
+#define BM_ANADIG_USB1_MISC_RX_HS_DATA 0x01000000
+#define BP_ANADIG_USB1_MISC_RSVD0      2
+#define BM_ANADIG_USB1_MISC_RSVD0 0x00FFFFFC
+#define BF_ANADIG_USB1_MISC_RSVD0(v)  \
+	(((v) << 2) & BM_ANADIG_USB1_MISC_RSVD0)
+#define BM_ANADIG_USB1_MISC_EN_DEGLITCH 0x00000002
+#define BM_ANADIG_USB1_MISC_HS_USE_EXTERNAL_R 0x00000001
+
+#include <linux/power_supply.h>
+enum battery_charging_spec {
+	BATTERY_CHARGING_SPEC_NONE = 0,
+	BATTERY_CHARGING_SPEC_UNKNOWN,
+	BATTERY_CHARGING_SPEC_1_0,
+	BATTERY_CHARGING_SPEC_1_1,
+	BATTERY_CHARGING_SPEC_1_2,
+};
+
+struct usb_charger {
+	void __iomem 		*charger_base_addr; /* Get from MSL if exists */
+	struct device		*dev; /* udc supplies */
+	/* charger detect can be enabled/disabled by kernel config */
+	bool 			enable;
+	struct power_supply	psy;
+	struct work_struct	work;
+	struct mutex		lock;
+
+	/* Compliant with Battery Charging Specification version (if any) */
+	enum battery_charging_spec	bc;
+
+	/* properties */
+	unsigned		present:1;
+	unsigned		online:1;
+	unsigned		max_current;
+	/* pull up/down dp during the charger detect, udc supplies */
+	void 	(*dp_pullup)(bool);
+	int	(*connect)(struct usb_charger *charger);
+	int	(*disconnect)(struct usb_charger *charger);
+	int	(*set_power)(struct usb_charger *charger, unsigned mA);
+
+	int	(*detect)(struct usb_charger *charger);
+};
+
+static char *usb_charger_supplied_to[] = {
+	"imx_usb_charger",
+};
+
+static enum power_supply_property power_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,	/* Charger detected */
+	POWER_SUPPLY_PROP_ONLINE,	/* VBUS online */
+	POWER_SUPPLY_PROP_CURRENT_MAX,	/* Maximum current in mA */
+};
+
+#endif /* __IMXUSB_CHARGER_H */
diff --git a/drivers/usb/gadget/u_uac1.c b/drivers/usb/gadget/u_uac1.c
index af98989..79a321a 100644
--- a/drivers/usb/gadget/u_uac1.c
+++ b/drivers/usb/gadget/u_uac1.c
@@ -39,6 +39,10 @@ static char *fn_cntl = FILE_CONTROL;
 module_param(fn_cntl, charp, S_IRUGO);
 MODULE_PARM_DESC(fn_cntl, "Control device file name");
 
+static int audio_sample_rate = 48000;
+module_param(audio_sample_rate, int, S_IRUGO);
+MODULE_PARM_DESC(audio_sample_rate, "Audio Sample Rate");
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -122,13 +126,23 @@ static int playback_default_hw_params(struct gaudio_snd_dev *snd)
 	snd->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
 	snd->format = SNDRV_PCM_FORMAT_S16_LE;
 	snd->channels = 2;
-	snd->rate = 48000;
+	if (audio_sample_rate == 44100)
+		snd->rate = 44100;
+	else if (audio_sample_rate == 48000)
+		snd->rate = 48000;
 
 	params = kzalloc(sizeof(*params), GFP_KERNEL);
 	if (!params)
 		return -ENOMEM;
 
 	_snd_pcm_hw_params_any(params);
+
+	if (audio_sample_rate == 44100) {
+		_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, \
+					       2*1024, 0);
+		_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, \
+						       16*1024, 0);
+	}
 	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,
 			snd->access, 0);
 	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,
@@ -193,6 +207,7 @@ try_again:
 	set_fs(KERNEL_DS);
 	result = snd_pcm_lib_write(snd->substream, buf, frames);
 	if (result != frames) {
+		msleep_interruptible(2);
 		ERROR(card, "Playback error: %d\n", (int)result);
 		set_fs(old_fs);
 		goto try_again;
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c532b6e..e4eefee 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -63,6 +63,13 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config FSL_USB_TEST_MODE
+	bool "FSL High-speed Electrical Test Mode Support"
+	depends on USB_EHCI_ARC
+	default n
+	---help---
+	    enable freescale test mode
+
 config USB_EHCI_ARC
 	bool "Support for Freescale controller"
 	depends on USB_EHCI_HCD && (ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS)
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 0982bcc..9d18a7a 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -41,3 +41,4 @@ obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_MIPS_ALCHEMY)	+= alchemy-common.o
+obj-$(CONFIG_FSL_USB_TEST_MODE)	+= arc_hset.o
diff --git a/drivers/usb/host/arc_hset.c b/drivers/usb/host/arc_hset.c
new file mode 100644
index 0000000..2ec9055
--- /dev/null
+++ b/drivers/usb/host/arc_hset.c
@@ -0,0 +1,468 @@
+/*
+ * HS USB Host-mode HSET driver for ARC USB controller
+ * Copyright 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Zhang Yan <jasper.zhang@freescale.com>
+ * Peter Chen <peter.chen@freescale.com>  */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define EHCI_IAA_MSECS		10		/* arbitrary */
+#include <linux/usb/hcd.h>
+#include "../core/usb.h"
+#include "ehci-fsl.h"
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <mach/arc_otg.h>
+#include "ehci.h"
+
+#define rh_level 1
+#define SINGLE_STEP_SLEEP_COUNT  15000
+#define USB_HIGH_SPEED		0x01
+#define USB_FULL_SPEED		0x02
+#define USB_LOW_SPEED		0x03
+
+/* ARC port test mode */
+#define PORTSC_PTC_TEST_MODE_DISABLE	0x00
+#define PORTSC_PTC_TEST_J		0x01
+#define PORTSC_PTC_TEST_K		0x02
+#define PORTSC_PTC_SE0_NAK		0x03
+#define PORTSC_PTC_TEST_PACKET		0x04
+#define PORTSC_PTC_FORCE_ENABLE_HS	0x05
+#define PORTSC_PTC_FORCE_ENABLE_FS	0x06
+#define PORTSC_PTC_FORCE_ENABLE_LS	0x07
+
+/* Other test */
+#define HSET_TEST_SUSPEND_RESUME	0x08
+#define HSET_TEST_GET_DEV_DESC		0x09
+#define HSET_TEST_GET_DEV_DESC_DATA	0x0A
+
+
+#define TEST_DEVICE_VID	 0x1A0A
+static struct usb_device_id archset_table[] = {
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0101) },	/* Test_SE0_NAK */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0102) },	/* Test_J */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0103) },	/* Test_K */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0104) },	/* Test_Packet */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0105) },	/* Force enable */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0108) },	/* SINGLE_STEP_GET_DEV_DESC_DATA */
+	{ }	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, archset_table);
+
+/* Private data */
+struct usb_archset {
+	struct usb_device    *udev;	/* the usb device for this device */
+	struct usb_interface *interface;	/* the interface for this device */
+	struct kref           kref;
+	struct ehci_hcd       *ehci;	/* the usb controller */
+	char                  ptcname[24];
+};
+
+ void set_single_step_desc_data_on(void);
+ void clear_single_step_desc_data_on(void);
+
+static void arc_kill_per_sched(struct ehci_hcd *ehci)
+{
+	u32 command = 0;
+	command = ehci_readl(ehci, &ehci->regs->command);
+	command &= ~(CMD_PSE);
+	ehci_writel(ehci, command, &ehci->regs->command);
+	printk(KERN_INFO "+++ %s: Periodic Schedule Stopped", __func__);
+}
+
+static void arc_hset_test(struct ehci_hcd *ehci, int mode)
+{
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc &= ~(0xf << 16);
+	portsc |= (mode << 16);
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static inline void hub_set_testmode(struct usb_device *udev, u8
+			test_mode)
+{
+	struct usb_device *hub_dev;
+	int i;
+	int max_port;
+	int status;
+	u8 level = udev->level;
+
+	if (level == 0)
+		return;
+	else {
+		printk(KERN_INFO "run %s at tie %d hub\n", __func__, level);
+		/* get the port number of parent */
+		if (udev->parent != NULL) {
+			hub_dev = udev->parent;
+			max_port = hub_dev->maxchild;
+		} else {
+			printk(KERN_INFO "device don't have parent hub\n");
+			return;
+		}
+
+		for (i = 0; i < max_port; i++) {
+			status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RT_PORT,
+				USB_PORT_FEAT_SUSPEND, i+1,
+				NULL, 0, 1000);
+			if (status >= 0)
+				printk(KERN_INFO "send port_suspend to port %d\n", i+1);
+			else {
+				printk(KERN_INFO "send port_suspend error %d to port %d\n",
+					status, i+1);
+				continue;
+			}
+		}
+		msleep(1000);
+		status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE/*USB_REQ_CLEAR_FEATURE*/, USB_RT_PORT,
+				USB_PORT_FEAT_TEST, (__u16) ((test_mode << 8) | udev->portnum),
+				NULL, 0, 1000);
+		if (status >= 0)
+			printk(KERN_INFO "send cmd %d to port %d\n", test_mode, udev->portnum);
+		else
+			printk(KERN_INFO "send cmd %d error %d to port %d\n", test_mode, status, udev->portnum);
+	}
+}
+
+static inline void test_j(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	if (level == rh_level) {
+		printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_J);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_J);
+}
+
+static inline void test_k(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_K);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_K);
+}
+
+static inline void test_se0_nak(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_SE0_NAK);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_SE0_NAK);
+}
+
+static inline void test_packet(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_PACKET);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_PACKET);
+}
+
+static inline void test_force_enable(struct usb_archset *hset, int
+			forcemode)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	int ptc_fmode = 0;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == 0) {
+		switch (forcemode) {
+		case USB_HIGH_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_HS;
+			break;
+		case USB_FULL_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_FS;
+			break;
+		case USB_LOW_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_LS;
+			break;
+		default:
+			printk(KERN_ERR "unknown speed mode %d\n", forcemode);
+			return;
+		}
+		arc_hset_test(hset->ehci, ptc_fmode);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_FORCE_ENABLE_HS);
+}
+
+static void suspend(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_SUSPEND;	/* Set suspend */
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+
+static void resume(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_RESUME;
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static void test_suspend_resume(struct usb_archset *hset)
+{
+	printk(KERN_INFO "%s\n", __func__);
+
+	suspend(hset);
+	msleep(15000);	/* Wait for 15s */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev = hset->udev;
+	int    result;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+
+	result = usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "usb_get_device_descriptor failed %d\n", result);
+	else
+		printk(KERN_INFO "usb_get_device_descriptor passed\n");
+}
+static void test_single_step_get_dev_desc_data(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	struct usb_device_descriptor *desc;
+	int    result;
+	unsigned int size = sizeof(struct usb_device_descriptor);
+	printk(KERN_INFO "%s size = %d\n", __func__, size);
+	desc = kmalloc(sizeof(*desc), GFP_NOIO);
+	if (!desc) {
+		printk(KERN_ERR "alloc desc failed\n");
+		return ;
+	}
+
+	set_single_step_desc_data_on();
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the setup transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the setup transaction passed\n");
+
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size,	USB_CTRL_GET_TIMEOUT);
+	if (result <= 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the data transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the data transaction passed\n");
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the status transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the status transaction passed\n");
+
+	clear_single_step_desc_data_on();
+
+	kfree(desc);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+	printk(KERN_INFO "test_single_step_get_dev_desc_data finished\n");
+}
+
+
+void test_single_step_set_feature(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, 0, 0, 0,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+static struct usb_archset *the_hset[4];
+static struct usb_archset *init_hset_dev(void *controller)
+{
+	struct ehci_hcd *ehci = (struct ehci_hcd *)controller;
+	struct usb_archset *hset = NULL;
+	int ctrid = 0;
+
+	ctrid = ehci_to_hcd(ehci)->self.busnum-1;
+	if (the_hset[ctrid]) {
+		kref_get(&the_hset[ctrid]->kref);
+		return the_hset[ctrid];
+	}
+
+	hset = kzalloc(sizeof(struct usb_archset), GFP_KERNEL);
+	if (hset == NULL) {
+		printk(KERN_ERR "Out of memory!\n");
+		return NULL;
+	}
+	hset->ehci = (struct ehci_hcd *)controller;
+	kref_init(&hset->kref);
+	the_hset[ctrid] = hset;
+
+	return hset;
+}
+
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_archset *hset = container_of(kref, struct usb_archset,
+								kref);
+
+	kfree(hset);
+}
+
+static int archset_probe(struct usb_interface *iface,
+		const struct usb_device_id *id)
+{
+	struct usb_archset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+
+	udev = usb_get_dev(interface_to_usbdev(iface));
+	hcd = bus_to_hcd(udev->bus);
+	hset = init_hset_dev((void *)hcd_to_ehci(hcd));
+	if (hset == NULL)
+		return -ENOMEM;
+
+	hset->udev = udev;
+	usb_set_intfdata(iface, hset);
+	switch (id->idProduct) {
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		printk(KERN_INFO "Force FS/FS/LS ?\n");
+		test_force_enable(hset, USB_HIGH_SPEED);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR\n");
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR_DATA\n");
+		test_single_step_get_dev_desc_data(hset);
+		break;
+	}
+
+	return 0;
+}
+
+static void archset_disconnect(struct usb_interface *iface)
+{
+	struct usb_archset *hset;
+
+	hset = usb_get_intfdata(iface);
+	usb_set_intfdata(iface, NULL);
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+
+static struct usb_driver archset_driver = {
+	.name = "arc hset",
+	.probe = archset_probe,
+	.disconnect = archset_disconnect,
+	.id_table = archset_table,
+};
+
+static int __init usb_hset_init(void)
+{
+	int ret = 0;
+	printk(KERN_ERR "usb register error with %d\n", ret);
+	/* register driver to usb subsystem */
+	ret = usb_register(&archset_driver);
+    if (ret)
+		printk(KERN_ERR "usb register error with %d\n", ret);
+	else
+		printk(KERN_INFO "usb hset init succeed\n");
+
+	return ret;
+}
+
+static void __exit usb_hset_exit(void)
+{
+	usb_deregister(&archset_driver);
+}
+
+module_init(usb_hset_init);
+module_exit(usb_hset_exit);
+MODULE_DESCRIPTION("Freescale USB Host Test Mode Driver");
+MODULE_AUTHOR("Jasper Zhang");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
index 66af0bc..55e1bfa 100644
--- a/drivers/usb/host/ehci-arc.c
+++ b/drivers/usb/host/ehci-arc.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2005 MontaVista Software
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -127,7 +127,7 @@ void fsl_usb_recover_hcd(struct platform_device *pdev)
 	 * CMDRUN bit in 20ms to keep port status.
 	 */
 	cmd = ehci_readl(ehci, &ehci->regs->command);
-	if (!(cmd & CMD_RUN) || (ehci->rh_state == EHCI_RH_RUNNING)) {
+	if (!(cmd & CMD_RUN) || (hcd->state == HC_STATE_SUSPENDED)) {
 		ehci_writel(ehci, ehci->command, &ehci->regs->command);
 		/* Resume root hub here? */
 		usb_hcd_resume_root_hub(hcd);
@@ -159,16 +159,6 @@ static irqreturn_t ehci_fsl_pre_irq(int irq, void *dev)
 		pdata->wakeup_event = WAKEUP_EVENT_INVALID;
 		fsl_usb_recover_hcd(pdev);
 		return IRQ_HANDLED;
-	} else {
-		u32 portsc = 0;
-		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-		portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
-		/* PORT_USB11 macro is used to judge line state K*/
-		if ((PORT_USB11(portsc)) && (portsc & PORT_SUSPEND)) {
-			pdata = hcd->self.controller->platform_data;
-			if (pdata->platform_resume)
-				pdata->platform_resume(pdata);
-		}
 	}
 	return IRQ_NONE;
 }
@@ -256,6 +246,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
 	if (pdata->init && pdata->init(pdev)) {
+		pdata->lowpower = false;
 		retval = -ENODEV;
 		goto err4;
 	}
@@ -324,7 +315,7 @@ err2:
 	usb_put_hcd(hcd);
 err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
-	if (pdata->exit)
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
 	return retval;
 }
@@ -349,20 +340,17 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 		if (pdata->usb_clock_for_pm)
 			pdata->usb_clock_for_pm(true);
 
+		/*disable the wakeup to avoid an abnormal wakeup interrupt*/
+		usb_host_set_wakeup(hcd->self.controller, false);
+
 		tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
 		if (tmp & PORT_PTS_PHCD) {
 			tmp &= ~PORT_PTS_PHCD;
 			ehci_writel(ehci, tmp, &ehci->regs->port_status[0]);
 			msleep(100);
-
-			if (pdata->usb_clock_for_pm)
-				pdata->usb_clock_for_pm(false);
 		}
 	}
 
-	/* DDD shouldn't we turn off the power here? */
-	fsl_platform_set_vbus_power(pdata, 0);
-
 	if (ehci->transceiver) {
 		(void)otg_set_host(ehci->transceiver->otg, 0);
 		usb_put_transceiver(ehci->transceiver);
@@ -371,17 +359,21 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 	}
 	/*disable the host wakeup and put phy to low power mode */
 	usb_host_set_wakeup(hcd->self.controller, false);
-	fsl_usb_lowpower_mode(pdata, true);
 	/*free the ehci_fsl_pre_irq  */
 	free_irq(hcd->irq, (void *)pdev);
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
 
+	fsl_usb_lowpower_mode(pdata, true);
+
+	/* DDD shouldn't we turn off the power here? */
+	fsl_platform_set_vbus_power(pdata, 0);
+
 	/*
 	 * do platform specific un-initialization:
 	 * release iomux pins clocks, etc.
 	 */
-	if (pdata->exit)
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
 
 	iounmap(hcd->regs);
@@ -418,11 +410,23 @@ static void fsl_setup_phy(struct ehci_hcd *ehci,
 	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
 }
 
+static void ehci_fsl_stream_disable(struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg_ptr;
+	u32		tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
+	tmp = ehci_readl(ehci, reg_ptr);
+	tmp |= CI_USBMODE_SDIS;
+	ehci_writel(ehci, tmp, reg_ptr);
+}
+
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_fsl_reinit(struct ehci_hcd *ehci)
 {
 	fsl_platform_usb_setup(ehci);
 	ehci_port_power(ehci, 0);
+	ehci_fsl_stream_disable(ehci);
 
 	return 0;
 }
@@ -485,10 +489,10 @@ static int ehci_fsl_bus_resume(struct usb_hcd *hcd)
 	}
 
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
-		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 		fsl_usb_clk_gate(hcd->self.controller->platform_data, true);
 		usb_host_set_wakeup(hcd->self.controller, false);
 		fsl_usb_lowpower_mode(pdata, false);
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	}
 
 	if (pdata->platform_resume)
@@ -710,7 +714,7 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	}
 	usb_unlock_device(roothub);
 
-	if (!(ehci->rh_state & EHCI_RH_RUNNING)) {
+	if (!(hcd->state & HC_STATE_SUSPENDED)) {
 		printk(KERN_DEBUG "will suspend roothub and its children\n");
 		usb_lock_device(roothub);
 		usb_suspend(&roothub->dev, PMSG_USER_SUSPEND);
@@ -815,13 +819,14 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	ehci_writel(ehci, pdata->pm_configured_flag,
 		    &ehci->regs->configured_flag);
 
+	ehci_fsl_stream_disable(ehci);
 
 	tmp = ehci_readl(ehci, &ehci->regs->command);
 	tmp |= CMD_RUN;
 	ehci_writel(ehci, tmp, &ehci->regs->command);
 	spin_unlock_irqrestore(&ehci->lock, flags);
 
-	if ((ehci->rh_state & EHCI_RH_RUNNING)) {
+	if ((hcd->state & HC_STATE_SUSPENDED)) {
 		printk(KERN_DEBUG "will resume roothub and its children\n");
 		usb_lock_device(roothub);
 		usb_resume(&roothub->dev, PMSG_USER_RESUME);
@@ -844,6 +849,6 @@ static struct platform_driver ehci_fsl_driver = {
 	.resume = ehci_fsl_drv_resume,
 #endif
 	.driver = {
-		.name = "fsl-ehci",
+		   .name = "fsl-ehci",
 	},
 };
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index 5c072d4..7fe577b 100644
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -37,6 +37,7 @@
 #define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
 #define USBMODE_CM_HOST		(3 << 0)	/* controller mode: host */
 #define USBMODE_ES		(1 << 2)	/* (Big) Endian Select */
+#define CI_USBMODE_SDIS		(1 << 4)	/* Chipidea Stream Disable bit */
 
 #define FSL_SOC_USB_USBGENCTRL	0x200
 #define USBGENCTRL_PPP		(1 << 3)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 987db27..7cd0c0c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -51,6 +51,21 @@
 #include <asm/firmware.h>
 #endif
 
+
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u32 single_step_desc_data_on;
+void set_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 1;
+}
+EXPORT_SYMBOL_GPL(set_single_step_desc_data_on);
+
+void clear_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 0;
+}
+EXPORT_SYMBOL_GPL(clear_single_step_desc_data_on);
+#endif
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1012,8 +1027,22 @@ static int ehci_urb_enqueue (
 		/* FALLTHROUGH */
 	/* case PIPE_BULK: */
 	default:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		if (!single_step_desc_data_on) {
+			printk(KERN_DEBUG "in test mode, but single step NOT on\n");
+			if (!qh_urb_transaction(ehci, urb, &qtd_list,
+						mem_flags))
+				return -ENOMEM;
+		} else {
+			printk(KERN_DEBUG "in test mode, single step on\n");
+			if (!single_step_qh_urb_transaction(ehci, urb,
+				&qtd_list, mem_flags))
+				return -ENOMEM;
+		}
+#else
+		if (!qh_urb_transaction(ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
+#endif
 		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7261e8f..1e3e260 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -609,6 +609,187 @@ static void qtd_list_free (
 	}
 }
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+/*
+ * create a list of filled qtds for this URB; won't link into qh.
+ */
+static struct list_head *
+single_step_qh_urb_transaction(
+	struct ehci_hcd		*ehci,
+	struct urb		*urb,
+	struct list_head	*head,
+	gfp_t			flags
+) {
+	struct ehci_qtd		*qtd, *qtd_prev;
+	dma_addr_t		buf;
+	int			len, this_sg_len, maxpacket;
+	int			is_input;
+	u32			token;
+	int			i;
+	struct scatterlist	*sg;
+#define SINGLE_STEP_PHASE_SETUP  0
+#define SINGLE_STEP_PHASE_DATA   1
+#define SINGLE_STEP_PHASE_STATUS 2
+#define SINGLE_STEP_PHASE_NONE   0xFF
+	static u32  phase_state = SINGLE_STEP_PHASE_NONE;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+	qtd = ehci_qtd_alloc(ehci, flags);
+	if (unlikely(!qtd))
+		return NULL;
+	list_add_tail(&qtd->qtd_list, head);
+	qtd->urb = urb;
+
+	token = QTD_STS_ACTIVE;
+	token |= (EHCI_TUNE_CERR << 10);
+	/* for split transactions, SplitXState initialized to zero */
+	len = urb->transfer_buffer_length;
+	is_input = usb_pipein(urb->pipe);
+	if (!is_input) {
+		printk(KERN_INFO "single step can only send IN\n");
+		return NULL;
+	}
+
+	if (!usb_pipecontrol(urb->pipe)) {
+		printk(KERN_INFO "single step can only send control pipe\n");
+		return NULL;
+	}
+
+	if (phase_state == SINGLE_STEP_PHASE_NONE) {
+		/*
+		 * SETUP pid
+		 * we use transfer_buffer_length to identfiy whether it
+		 * is in setup phase or data phase
+		 */
+		qtd_fill(ehci, qtd, urb->setup_dma,
+				sizeof(struct usb_ctrlrequest),
+				token | (2 /* "setup" */ << 8), 8);
+
+		/* ... and always at least one more pid */
+		qtd->urb = urb;
+		phase_state = SINGLE_STEP_PHASE_SETUP;
+	}
+	/*
+	 * data transfer stage:  buffer setup
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_SETUP &&
+		len != 0) {
+		i = urb->num_sgs;
+		if (len > 0 && i > 0) {
+			sg = urb->sg;
+			buf = sg_dma_address(sg);
+
+			/* urb->transfer_buffer_length may be smaller than the
+			* size of the scatterlist (or vice versa)
+			*/
+			this_sg_len = min_t(int, sg_dma_len(sg), len);
+		} else {
+			sg = NULL;
+			buf = urb->transfer_dma;
+			this_sg_len = len;
+		}
+
+		if (is_input)
+			token |= (1 /* "in" */ << 8);
+		/* else it's already initted to "out" pid (0 << 8) */
+		maxpacket = max_packet(usb_maxpacket(urb->dev,
+						urb->pipe, !is_input));
+		/* for the first data qtd, the toggle should be 1 */
+		token ^= QTD_TOGGLE;
+
+		/*
+		 * buffer gets wrapped in one or more qtds;
+		 * last one may be "short" (including zero len)
+		 * and may serve as a control status ack
+		 */
+		for (;;) {
+			int this_qtd_len;
+
+			this_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len,
+							token, maxpacket);
+			this_sg_len -= this_qtd_len;
+			len -= this_qtd_len;
+			buf += this_qtd_len;
+
+			/*
+			* short reads advance to a "magic" dummy instead of
+			* the next qtd ... that forces the queue to stop, for
+			* manual cleanup. (will usually be overridden later.)
+			*/
+			if (is_input)
+				qtd->hw_alt_next = ehci->async->hw->hw_alt_next;
+
+			/* qh makes control packets use qtd toggle; switch it*/
+			if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+				token ^= QTD_TOGGLE;
+
+			if (likely(this_sg_len <= 0)) {
+				if (--i <= 0 || len <= 0)
+					break;
+				sg = sg_next(sg);
+				buf = sg_dma_address(sg);
+				this_sg_len = min_t(int, sg_dma_len(sg), len);
+			}
+
+			qtd_prev = qtd;
+			qtd = ehci_qtd_alloc(ehci, flags);
+			if (unlikely(!qtd))
+				goto cleanup;
+			qtd->urb = urb;
+			qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
+			list_add_tail(&qtd->qtd_list, head);
+		}
+
+		phase_state = SINGLE_STEP_PHASE_DATA;
+
+		/*
+		 * unless the caller requires manual cleanup after short reads,
+		 * have the alt_next mechanism keep the queue running after the
+		 * last data qtd (the only one, for control and other cases).
+		 */
+		if (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
+					|| usb_pipecontrol(urb->pipe)))
+			qtd->hw_alt_next = EHCI_LIST_END(ehci);
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_DATA) {
+		int	one_more = 0;
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			/* for single step, it always be out here */
+			token &= ~(3 << 8);
+			token |= QTD_TOGGLE;	/* force DATA1 */
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length % maxpacket)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			/* never any data in such packets */
+			qtd_fill(ehci, qtd, 0, 0, token, 0);
+		}
+	}
+
+	/* by default, enable interrupt on urb completion */
+	if (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))
+		qtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);
+	return head;
+
+cleanup:
+	qtd_list_free(ehci, urb, head);
+	phase_state = SINGLE_STEP_PHASE_NONE;
+	return NULL;
+}
+#endif
+
 /*
  * create a list of filled qtds for this URB; won't link into qh.
  */
diff --git a/drivers/usb/otg/arc_otg.c b/drivers/usb/otg/arc_otg.c
index d8ec4a8..b3abd4b 100644
--- a/drivers/usb/otg/arc_otg.c
+++ b/drivers/usb/otg/arc_otg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Author: Li Yang <LeoLi@freescale.com>
  *         Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -494,17 +494,17 @@ void otg_reset_controller(void)
 /* Call suspend/resume routines in host driver */
 int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 {
-	struct usb_otg *otg = fsm->otg;
+	struct usb_otg *xceiv = fsm->otg;
 	struct device *dev;
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev = container_of(xceiv->phy, struct fsl_otg, phy);
 	struct platform_driver *host_pdrv;
 	struct platform_device *host_pdev;
 	struct fsl_usb2_platform_data *pdata;
 	u32 retval = 0;
 
-	if (!otg->host)
+	if (!xceiv->host)
 		return -ENODEV;
-	dev = otg->host->controller;
+	dev = xceiv->host->controller;
 	host_pdrv = container_of((dev->driver), struct platform_driver, driver);
 	host_pdev = to_platform_device(dev);
 	pdata = host_pdev->dev.platform_data;
@@ -572,17 +572,17 @@ end:
  */
 int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
 {
-	struct usb_otg *otg = fsm->otg;
+	struct usb_otg *xceiv = fsm->otg;
 	struct device *dev;
 	struct platform_driver *gadget_pdrv;
 	struct platform_device *gadget_pdev;
 	struct fsl_usb2_platform_data *pdata;
 
-	if (!otg->gadget || !otg->gadget->dev.parent)
+	if (!xceiv->gadget || !xceiv->gadget->dev.parent)
 		return -ENODEV;
 
 	VDBG("gadget %s \n", on ? "on" : "off");
-	dev = otg->gadget->dev.parent;
+	dev = xceiv->gadget->dev.parent;
 
 	gadget_pdrv = container_of((dev->driver),
 			struct platform_driver, driver);
@@ -604,22 +604,25 @@ int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
 /* Called by initialization code of host driver.  Register host controller
  * to the OTG.  Suspend host for OTG role detection.
  */
-static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
+static int fsl_otg_set_host(struct usb_otg *otg_p, struct usb_bus *host)
 {
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev = container_of(otg_p->phy, struct fsl_otg, phy);
+	struct fsl_usb2_platform_data *pdata;
 
-	if (!otg || otg_dev != fsl_otg_dev)
+	pdata = otg_dev->phy.dev->platform_data;
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
-	otg->host = host;
+	otg_p->host = host;
 
 	otg_dev->fsm.a_bus_drop = 0;
 	otg_dev->fsm.a_bus_req = 1;
 
 	if (host) {
 		VDBG("host off......\n");
-		otg->host->otg_port = fsl_otg_initdata.otg_port;
-		otg->host->is_b_host = otg_dev->fsm.id;
+		otg_p->host->otg_port = fsl_otg_initdata.otg_port;
+		otg_p->host->is_b_host = otg_dev->fsm.id;
 		/* must leave time for khubd to finish its thing
 		 * before yanking the host driver out from under it,
 		 * so suspend the host after a short delay.
@@ -628,11 +631,18 @@ static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 
 		if (otg_dev->fsm.id) {
 			otg_dev->host_first_call = true;
+			/* The discharge will be false when the controller
+			 * is ready to use.
+			 */
+			if (pdata->dr_discharge_line)
+				pdata->dr_discharge_line(true);
 			schedule_otg_work(&otg_dev->otg_event, 100);
 		}
 		else {
 			/* if the device is already at the port */
 			otg_drv_vbus(&otg_dev->fsm, 1);
+			if (pdata->dr_discharge_line)
+				pdata->dr_discharge_line(false);
 			fsl_otg_wait_stable_vbus(true);
 			b_session_irq_enable(false);
 			fsl_otg_start_host(&otg_dev->fsm, 1);
@@ -646,13 +656,13 @@ static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 			/* Mini-A cable connected */
 			struct otg_fsm *fsm = &otg_dev->fsm;
 
-			otg->phy->state = OTG_STATE_UNDEFINED;
+			otg_p->phy->state = OTG_STATE_UNDEFINED;
 			fsm->protocol = PROTO_UNDEF;
 		}
 		if (gpio_id) {
 			if (gpio_get_value(gpio_id)) {
 				struct otg_fsm *fsm = &otg_dev->fsm;
-				otg->phy->state = OTG_STATE_UNDEFINED;
+				otg_p->phy->state = OTG_STATE_UNDEFINED;
 				fsm->protocol = PROTO_UNDEF;
 			}
 		}
@@ -666,32 +676,32 @@ static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 }
 
 /* Called by initialization code of udc.  Register udc to OTG.*/
-static int fsl_otg_set_peripheral(struct usb_otg *otg,
+static int fsl_otg_set_peripheral(struct usb_otg *otg_p,
 				  struct usb_gadget *gadget)
 {
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev = container_of(otg_p->phy, struct fsl_otg, phy);
 	struct fsl_usb2_platform_data *pdata;
 
 	pdata = otg_dev->phy.dev->platform_data;
 	VDBG("otg_dev 0x%x\n", (int)otg_dev);
 	VDBG("fsl_otg_dev 0x%x\n", (int)fsl_otg_dev);
 
-	if (!otg || otg_dev != fsl_otg_dev)
+	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
 	if (!gadget) {
-		if (!otg->default_a)
-			otg->gadget->ops->vbus_draw(otg->gadget, 0);
-		usb_gadget_vbus_disconnect(otg->gadget);
-		otg->gadget = 0;
+		if (!otg_p->default_a)
+			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
+		usb_gadget_vbus_disconnect(otg_p->gadget);
+		otg_p->gadget = 0;
 		otg_dev->fsm.b_bus_req = 0;
 		pdata->port_enables = 0;
 		otg_statemachine(&otg_dev->fsm);
 		return 0;
 	}
 	pdata->port_enables = 1;
-	otg->gadget = gadget;
-	otg->gadget->is_a_peripheral = !otg_dev->fsm.id;
+	otg_p->gadget = gadget;
+	otg_p->gadget->is_a_peripheral = !otg_dev->fsm.id;
 
 	otg_dev->fsm.b_bus_req = 1;
 
@@ -748,6 +758,8 @@ static void fsl_otg_event(struct work_struct *work)
 		fsm->a_conn = 0;
 
 	if (fsm->id) {		/* switch to gadget */
+		if ((og->host_first_call == false) && pdata->dr_discharge_line)
+			pdata->dr_discharge_line(true);
 		fsl_otg_start_host(fsm, 0);
 		if (pdata->wake_up_enable)
 			pdata->wake_up_enable(pdata, false);
@@ -787,12 +799,12 @@ static void fsl_otg_event(struct work_struct *work)
 }
 
 /* B-device start SRP */
-static int fsl_otg_start_srp(struct usb_otg *otg)
+static int fsl_otg_start_srp(struct usb_otg *otg_p)
 {
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev = container_of(otg_p->phy, struct fsl_otg, phy);
 
-	if (!otg || otg_dev != fsl_otg_dev
-	    || otg->phy->state != OTG_STATE_B_IDLE)
+	if (!otg_p || otg_dev != fsl_otg_dev
+	    || otg_p->phy->state != OTG_STATE_B_IDLE)
 		return -ENODEV;
 
 	otg_dev->fsm.b_bus_req = 1;
@@ -802,11 +814,11 @@ static int fsl_otg_start_srp(struct usb_otg *otg)
 }
 
 /* A_host suspend will call this function to start hnp */
-static int fsl_otg_start_hnp(struct usb_otg *otg)
+static int fsl_otg_start_hnp(struct usb_otg *otg_p)
 {
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev = container_of(otg_p->phy, struct fsl_otg, phy);
 
-	if (!otg || otg_dev != fsl_otg_dev)
+	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
 	/* printk("start_hnp.............\n"); */
@@ -825,6 +837,7 @@ irqreturn_t fsl_otg_isr_gpio(int irq, void *dev_id)
 	struct fsl_otg *f_otg;
 	struct usb_phy *otg_trans = usb_get_transceiver();
 	int value;
+
 	f_otg = container_of(otg_trans, struct fsl_otg, phy);
 	fsm = &f_otg->fsm;
 
@@ -1408,6 +1421,7 @@ static int fsl_otg_remove(struct platform_device *pdev)
 
 	kfree(fsl_otg_dev);
 
+	fsl_otg_dev = NULL;
 	remove_proc_file();
 
 	unregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);
-- 
1.7.5.4

