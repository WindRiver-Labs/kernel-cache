From d54aa1a7e7937a3a439af854f4565124b29fc5ec Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Jun 2013 17:08:49 +0800
Subject: [PATCH 03/38] fsl_imx6q: Update platform and head for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-mxc/Kconfig                          |   18 +
 arch/arm/plat-mxc/Makefile                         |    6 +-
 arch/arm/plat-mxc/ahci_sata.c                      |  194 ++
 arch/arm/plat-mxc/clock.c                          |  226 ++-
 arch/arm/plat-mxc/cpu.c                            |   10 +
 arch/arm/plat-mxc/cpufreq.c                        |  309 ++-
 arch/arm/plat-mxc/devices/Kconfig                  |   56 +
 arch/arm/plat-mxc/devices/Makefile                 |   19 +
 arch/arm/plat-mxc/devices/platform-ahci-imx.c      |  157 +-
 arch/arm/plat-mxc/devices/platform-dma.c           |   41 +
 arch/arm/plat-mxc/devices/platform-fec.c           |    7 +
 arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c  |   52 +-
 arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c  |   58 +-
 .../plat-mxc/devices/platform-fsl-usb2-wakeup.c    |    9 +-
 .../plat-mxc/devices/platform-imx-anatop-thermal.c |   18 +-
 arch/arm/plat-mxc/devices/platform-imx-caam.c      |  107 +
 arch/arm/plat-mxc/devices/platform-imx-dcp.c       |   71 +
 arch/arm/plat-mxc/devices/platform-imx-dma.c       |  274 ++-
 arch/arm/plat-mxc/devices/platform-imx-elcdif-fb.c |   57 +
 arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c   |   63 +
 arch/arm/plat-mxc/devices/platform-imx-fsl-csi.c   |   55 +
 arch/arm/plat-mxc/devices/platform-imx-gpmi-nfc.c  |  109 +
 .../plat-mxc/devices/platform-imx-hdmi-soc-dai.c   |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c  |    6 +-
 arch/arm/plat-mxc/devices/platform-imx-iim.c       |   59 +
 arch/arm/plat-mxc/devices/platform-imx-keypad.c    |    5 +
 arch/arm/plat-mxc/devices/platform-imx-mipi_dsi.c  |   63 +
 arch/arm/plat-mxc/devices/platform-imx-pcie.c      |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-perfmon.c   |  157 +
 arch/arm/plat-mxc/devices/platform-imx-pm.c        |    7 +-
 arch/arm/plat-mxc/devices/platform-imx-pmu.c       |   20 +-
 arch/arm/plat-mxc/devices/platform-imx-pxp.c       |   80 +
 arch/arm/plat-mxc/devices/platform-imx-rngb.c      |   56 +
 arch/arm/plat-mxc/devices/platform-imx-scc2.c      |  284 ++
 arch/arm/plat-mxc/devices/platform-imx-spdc-fb.c   |   56 +
 arch/arm/plat-mxc/devices/platform-imx-ssi.c       |    6 +-
 arch/arm/plat-mxc/devices/platform-imx-uart.c      |   24 +-
 arch/arm/plat-mxc/devices/platform-imx-vdoa.c      |   60 +
 arch/arm/plat-mxc/devices/platform-imx-viim.c      |   44 +
 arch/arm/plat-mxc/devices/platform-imx2-wdt.c      |    5 +
 arch/arm/plat-mxc/devices/platform-imx_ipuv3.c     |  239 ++
 arch/arm/plat-mxc/devices/platform-imx_srtc.c      |   63 +
 arch/arm/plat-mxc/devices/platform-imx_tve.c       |   47 +
 arch/arm/plat-mxc/devices/platform-imx_vpu.c       |    5 +-
 arch/arm/plat-mxc/devices/platform-mxc-ehci.c      |   74 +-
 arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c |    5 +-
 arch/arm/plat-mxc/devices/platform-mxc_gpu.c       |  101 +
 arch/arm/plat-mxc/devices/platform-mxc_hdmi.c      |    7 +-
 arch/arm/plat-mxc/devices/platform-mxc_mlb.c       |   76 +
 arch/arm/plat-mxc/devices/platform-mxc_pwm.c       |    9 +
 .../plat-mxc/devices/platform-sdhci-esdhc-imx.c    |   52 +-
 arch/arm/plat-mxc/devices/platform-viv_gpu.c       |   54 +-
 arch/arm/plat-mxc/dvfs_core.c                      |   72 +-
 arch/arm/plat-mxc/fuse.c                           |  165 ++
 arch/arm/plat-mxc/gpio.c                           |  372 +++
 arch/arm/plat-mxc/include/mach/arc_otg.h           |    5 +
 arch/arm/plat-mxc/include/mach/audmux.h            |   60 +
 arch/arm/plat-mxc/include/mach/clkdev.h            |    7 +
 arch/arm/plat-mxc/include/mach/common.h            |   14 +-
 arch/arm/plat-mxc/include/mach/debug-macro.S       |   14 +-
 arch/arm/plat-mxc/include/mach/devices-common.h    |  158 +-
 arch/arm/plat-mxc/include/mach/dma.h               |   43 +-
 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h  |  169 ++
 arch/arm/plat-mxc/include/mach/entry-macro.S       |   97 +
 arch/arm/plat-mxc/include/mach/epdc.h              |   68 +
 arch/arm/plat-mxc/include/mach/esdhc.h             |   33 +-
 arch/arm/plat-mxc/include/mach/gpio.h              |   55 +-
 arch/arm/plat-mxc/include/mach/gpmi-nfc.h          |   71 +
 arch/arm/plat-mxc/include/mach/hardware.h          |   58 +-
 arch/arm/plat-mxc/include/mach/i2c.h               |    4 +
 arch/arm/plat-mxc/include/mach/imx-uart.h          |    4 +
 arch/arm/plat-mxc/include/mach/imx_rfkill.h        |   27 +
 arch/arm/plat-mxc/include/mach/iomux-mx6dl.h       |  127 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6q.h        |  160 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6sl.h       | 3092 ++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/iomux-v1.h          |    6 +-
 arch/arm/plat-mxc/include/mach/iomux-v3.h          |   37 +-
 arch/arm/plat-mxc/include/mach/ipu-v3.h            |   25 +-
 arch/arm/plat-mxc/include/mach/irqs.h              |   12 +-
 arch/arm/plat-mxc/include/mach/memory.h            |   77 +
 arch/arm/plat-mxc/include/mach/mipi_dsi.h          |  225 ++
 arch/arm/plat-mxc/include/mach/mx6q.h              |  170 +-
 arch/arm/plat-mxc/include/mach/mxc.h               |   65 +-
 arch/arm/plat-mxc/include/mach/mxc91231.h          |  256 ++
 arch/arm/plat-mxc/include/mach/mxc_dvfs.h          |    4 +
 arch/arm/plat-mxc/include/mach/mxc_edid.h          |   29 +-
 arch/arm/plat-mxc/include/mach/mxc_gpu.h           |   24 +
 arch/arm/plat-mxc/include/mach/mxc_hdmi.h          |   31 +-
 arch/arm/plat-mxc/include/mach/mxc_uart.h          |    1 -
 arch/arm/plat-mxc/include/mach/mxc_vpu.h           |    6 +
 arch/arm/plat-mxc/include/mach/mxs.h               |  113 +
 arch/arm/plat-mxc/include/mach/sdma.h              |    9 +-
 arch/arm/plat-mxc/include/mach/sdram_autogating.h  |   56 +
 arch/arm/plat-mxc/include/mach/system.h            |   48 +
 arch/arm/plat-mxc/include/mach/timex.h             |   19 +-
 arch/arm/plat-mxc/include/mach/uncompress.h        |   11 +-
 arch/arm/plat-mxc/include/mach/vmalloc.h           |   22 +
 arch/arm/plat-mxc/iomux-v1.c                       |   34 +-
 arch/arm/plat-mxc/iomux-v3.c                       |   58 +-
 arch/arm/plat-mxc/irq-common.c                     |   28 +-
 arch/arm/plat-mxc/irq-common.h                     |    3 +-
 arch/arm/plat-mxc/pwm.c                            |   61 +-
 arch/arm/plat-mxc/serialxc.c                       |   64 +
 arch/arm/plat-mxc/system.c                         |   50 +-
 arch/arm/plat-mxc/time.c                           |   49 +-
 arch/arm/plat-mxc/usb_common.c                     |   55 +-
 arch/arm/plat-mxc/usb_hsic_xcvr.c                  |    1 +
 arch/arm/plat-mxc/usb_wakeup.c                     |   48 +-
 include/linux/fec.h                                |    5 +
 include/linux/fsl_devices.h                        |   74 +
 include/linux/mfd/max17135.h                       |  217 ++
 include/linux/mfd/mxc-hdmi-core.h                  |    1 +
 include/linux/mfd/pfuze.h                          |  111 +
 include/linux/mtd/gpmi-nand.h                      |    5 +-
 include/linux/power/sabresd_battery.h              |   63 +
 include/linux/regulator/anatop-regulator.h         |   39 +-
 116 files changed, 9912 insertions(+), 765 deletions(-)
 create mode 100644 arch/arm/plat-mxc/ahci_sata.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-dma.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-caam.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-dcp.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-elcdif-fb.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-fsl-csi.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-gpmi-nfc.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-iim.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-mipi_dsi.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-perfmon.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-pxp.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-rngb.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-scc2.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-spdc-fb.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-vdoa.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-viim.c
 mode change 100755 => 100644 arch/arm/plat-mxc/devices/platform-imx_dvfs.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx_srtc.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx_tve.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-mxc_gpu.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-mxc_mlb.c
 create mode 100644 arch/arm/plat-mxc/fuse.c
 create mode 100644 arch/arm/plat-mxc/gpio.c
 create mode 100644 arch/arm/plat-mxc/include/mach/audmux.h
 create mode 100644 arch/arm/plat-mxc/include/mach/clkdev.h
 create mode 100755 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
 create mode 100644 arch/arm/plat-mxc/include/mach/entry-macro.S
 create mode 100644 arch/arm/plat-mxc/include/mach/epdc.h
 create mode 100644 arch/arm/plat-mxc/include/mach/gpmi-nfc.h
 create mode 100755 arch/arm/plat-mxc/include/mach/imx_rfkill.h
 create mode 100755 arch/arm/plat-mxc/include/mach/iomux-mx6sl.h
 create mode 100644 arch/arm/plat-mxc/include/mach/memory.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mipi_dsi.h
 create mode 100755 arch/arm/plat-mxc/include/mach/mxc91231.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_gpu.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxs.h
 create mode 100755 arch/arm/plat-mxc/include/mach/sdram_autogating.h
 create mode 100644 arch/arm/plat-mxc/include/mach/system.h
 create mode 100644 arch/arm/plat-mxc/include/mach/vmalloc.h
 create mode 100755 arch/arm/plat-mxc/serialxc.c
 create mode 100644 include/linux/mfd/max17135.h
 create mode 100644 include/linux/mfd/pfuze.h
 create mode 100644 include/linux/power/sabresd_battery.h

diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 1cbbd7e..32e93d6 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -75,6 +75,17 @@ config MXC_DEBUG_BOARD
 config HAVE_EPIT
 	bool
 
+config MXC_REBOOT_MFGMODE
+	bool "Enable reboot to MFG mode function"
+	help
+	  Enable this config to perform "reboot download" to enter download mode.
+
+config MXC_REBOOT_ANDROID_CMD
+	bool "Enable reboot to android recovery and android fastboot"
+	help
+	  Enable this config to use "reboot fastboot", "reboot recovery" to
+	  enter fastboot and recovery mode.
+
 config MXC_USE_EPIT
 	bool "Use EPIT instead of GPT"
 	depends on HAVE_EPIT
@@ -100,4 +111,11 @@ config IRAM_ALLOC
 	bool
 	select GENERIC_ALLOCATOR
 
+config DMA_ZONE_SIZE
+	int "DMA memory zone size"
+	range 0 184
+	default 24
+	help
+	  This is the size in MB for the DMA zone. The DMA zone is used for
+	  dedicated memory for large contiguous video buffers
 endif
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 3ab1651..fd8e07d 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := clock.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o
+obj-y := clock.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o fuse.o
 
 obj-$(CONFIG_MXC_TZIC) += tzic.o
 obj-$(CONFIG_MXC_AVIC) += avic.o
@@ -23,9 +23,11 @@ endif
 
 obj-y += devices/
 
-obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_DVFS) += dvfs_core.o
+obj-$(CONFIG_ARCH_MX6) += dvfs_core.o
 
 # USB support
 obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
 obj-$(CONFIG_USB) += utmixc.o
 obj-$(CONFIG_USB) += usb_hsic_xcvr.o
+obj-$(CONFIG_USB) += serialxc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_AHCI)	+= ahci_sata.o
diff --git a/arch/arm/plat-mxc/ahci_sata.c b/arch/arm/plat-mxc/ahci_sata.c
new file mode 100644
index 0000000..de172a9
--- /dev/null
+++ b/arch/arm/plat-mxc/ahci_sata.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/errno.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+#include <mach/ahci_sata.h>
+
+int write_phy_ctl_ack_polling(u32 data, void __iomem *mmio,
+		int max_iterations, u32 exp_val)
+{
+	u32 i, val;
+
+	writel(data, mmio + PORT_PHY_CTL);
+
+	for (i = 0; i < max_iterations + 1; i++) {
+		val = readl(mmio + PORT_PHY_SR);
+		val =  (val >> PORT_PHY_STAT_ACK_LOC) & 0x1;
+		if (val == exp_val)
+			return 0;
+		if (i == max_iterations) {
+			pr_err("Wait for CR ACK error!\n");
+			return 1;
+		}
+		usleep_range(100, 200);
+	}
+	return 0;
+}
+
+int sata_phy_cr_addr(u32 addr, void __iomem *mmio)
+{
+	u32 temp_wr_data;
+
+	/* write addr */
+	temp_wr_data = addr;
+	writel(temp_wr_data, mmio + PORT_PHY_CTL);
+
+	/* capture addr */
+	temp_wr_data |= PORT_PHY_CTL_CAP_ADR_LOC;
+
+	/* wait for ack */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 1))
+		return 1;
+
+	/* deassert cap addr */
+	temp_wr_data &= 0xffff;
+
+	/* wait for ack de-assetion */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 0))
+		return 1;
+
+	return 0;
+}
+
+int sata_phy_cr_write(u32 data, void __iomem *mmio)
+{
+	u32 temp_wr_data;
+
+	/* write data */
+	temp_wr_data = data;
+
+	/* capture data */
+	temp_wr_data |= PORT_PHY_CTL_CAP_DAT_LOC;
+
+	/* wait for ack */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 1))
+		return 1;
+
+	/* deassert cap data */
+	temp_wr_data &= 0xffff;
+
+	/* wait for ack de-assetion */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 0))
+		return 1;
+
+	/* assert wr signal */
+	temp_wr_data |= PORT_PHY_CTL_WRITE_LOC;
+
+	/* wait for ack */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 1))
+		return 1;
+
+	/* deassert wr _signal */
+	temp_wr_data = 0x0;
+
+	/* wait for ack de-assetion */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 0))
+		return 1;
+
+	return 0;
+}
+
+int sata_phy_cr_read(u32 *data, void __iomem *mmio)
+{
+	u32 temp_rd_data, temp_wr_data;
+
+	/* assert rd signal */
+	temp_wr_data = PORT_PHY_CTL_READ_LOC;
+
+	/* wait for ack */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 1))
+		return 1;
+
+	/* after got ack return data */
+	temp_rd_data = readl(mmio + PORT_PHY_SR);
+	*data = (temp_rd_data & 0xffff);
+
+	/* deassert rd _signal */
+	temp_wr_data = 0x0 ;
+
+	/* wait for ack de-assetion */
+	if (write_phy_ctl_ack_polling(temp_wr_data, mmio, 100, 0))
+		return 1;
+
+	return 0;
+}
+
+/* AHCI module Initialization, if return 0, initialization is successful. */
+int sata_init(void __iomem *addr, unsigned long timer1ms)
+{
+	u32 tmpdata;
+	int iterations = 20;
+
+	/*
+	 * Make sure that SATA PHY is enabled
+	 * The PDDQ mode is disabled.
+	 */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata & (~PORT_PHY_CTL_PDDQ_LOC), addr + PORT_PHY_CTL);
+
+	/* Reset HBA */
+	writel(HOST_RESET, addr + HOST_CTL);
+
+	tmpdata = 0;
+	while (readl(addr + HOST_CAP) == 0) {
+		tmpdata++;
+		if (tmpdata > 100000) {
+			pr_err("Can't recover from RESET HBA!\n");
+			break;
+		}
+	}
+
+	tmpdata = readl(addr + HOST_CAP);
+	if (!(tmpdata & HOST_CAP_SSS)) {
+		tmpdata |= HOST_CAP_SSS;
+		writel(tmpdata, addr + HOST_CAP);
+	}
+
+	if (!(readl(addr + HOST_PORTS_IMPL) & 0x1))
+		writel((readl(addr + HOST_PORTS_IMPL) | 0x1),
+			addr + HOST_PORTS_IMPL);
+
+	writel(timer1ms, addr + HOST_TIMER1MS);
+
+	/* Release resources when there is no device on the port */
+	do {
+		if ((readl(addr + PORT_SATA_SR) & 0xF) == 0)
+			usleep_range(1000, 2000);
+		else
+			break;
+
+		if (iterations == 0) {
+			pr_info("No sata disk.\n");
+			/* Enter into PDDQ mode, save power */
+			tmpdata = readl(addr + PORT_PHY_CTL);
+			writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC,
+					addr + PORT_PHY_CTL);
+			return -ENODEV;
+		}
+	} while (iterations-- > 0);
+
+	return 0;
+}
diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
index 17a8d5d..d2e3f18 100644
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -4,7 +4,7 @@
  * Copyright (C) 2004 - 2005 Nokia corporation
  * Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  * Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2012 Freescale Semiconductor, Inc.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -37,10 +37,16 @@
 #include <linux/proc_fs.h>
 #include <linux/semaphore.h>
 #include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/hardirq.h>
 
 #include <mach/clock.h>
 #include <mach/hardware.h>
 
+extern int dvfs_core_is_active;
+extern void bus_freq_update(struct clk *clk, bool flag);
+
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
@@ -52,7 +58,11 @@ static void __clk_disable(struct clk *clk)
 {
 	if (clk == NULL || IS_ERR(clk))
 		return;
-	WARN_ON(!clk->usecount);
+
+	if (!clk->usecount) {
+		WARN(1, "clock enable/disable mismatch!\n");
+		return;
+	}
 
 	if (!(--clk->usecount)) {
 		if (clk->disable)
@@ -82,11 +92,24 @@ static int __clk_enable(struct clk *clk)
  */
 int clk_enable(struct clk *clk)
 {
+	/* unsigned long flags; */
 	int ret = 0;
 
+	if (in_interrupt()) {
+		printk(KERN_ERR " clk_enable cannot be called in an interrupt context\n");
+		dump_stack();
+		BUG();
+	}
+
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
+	if ((clk->flags & AHB_HIGH_SET_POINT) ||
+		(clk->flags & AHB_MED_SET_POINT) ||
+		(clk->flags & AHB_AUDIO_SET_POINT) ||
+		(clk->flags & CPU_FREQ_TRIG_UPDATE))
+		bus_freq_update(clk, true);
+
 	mutex_lock(&clocks_mutex);
 	ret = __clk_enable(clk);
 	mutex_unlock(&clocks_mutex);
@@ -101,15 +124,49 @@ EXPORT_SYMBOL(clk_enable);
  */
 void clk_disable(struct clk *clk)
 {
+	/* unsigned long flags; */
+
+	if (in_interrupt()) {
+		printk(KERN_ERR " clk_disable cannot be called in an interrupt context\n");
+		dump_stack();
+		BUG();
+	}
+
 	if (clk == NULL || IS_ERR(clk))
 		return;
 
 	mutex_lock(&clocks_mutex);
 	__clk_disable(clk);
 	mutex_unlock(&clocks_mutex);
+
+	if ((clk->flags & AHB_HIGH_SET_POINT) ||
+		(clk->flags & AHB_MED_SET_POINT) ||
+		(clk->flags & AHB_AUDIO_SET_POINT) ||
+		(clk->flags & CPU_FREQ_TRIG_UPDATE))
+		bus_freq_update(clk, false);
 }
+
 EXPORT_SYMBOL(clk_disable);
 
+/*!
+ * @brief Function to get the usage count for the requested clock.
+ *
+ * This function returns the reference count for the clock.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ * @return Returns the usage count for the requested clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+
+EXPORT_SYMBOL(clk_get_usecount);
+
 /* Retrieve the *current* clock rate. If the clock itself
  * does not provide a special calculation routine, ask
  * its parent and so on, until one is able to return
@@ -168,10 +225,18 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	    IS_ERR(parent) || clk->set_parent == NULL)
 		return ret;
 
-	if (clk->usecount)
-		clk_enable(parent);
-
 	mutex_lock(&clocks_mutex);
+
+	if (clk->usecount) {
+		if (in_interrupt()) {
+			printk(KERN_ERR " clk_enable cannot be called in an interrupt context\n");
+			dump_stack();
+			mutex_unlock(&clocks_mutex);
+			BUG();
+		}
+		__clk_enable(parent);
+	}
+
 	ret = clk->set_parent(clk, parent);
 	if (ret == 0) {
 		old = clk->parent;
@@ -179,10 +244,10 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	} else {
 		old = parent;
 	}
-	mutex_unlock(&clocks_mutex);
-
 	if (clk->usecount)
-		clk_disable(old);
+		__clk_disable(old);
+
+	mutex_unlock(&clocks_mutex);
 
 	return ret;
 }
@@ -200,25 +265,6 @@ struct clk *clk_get_parent(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_get_parent);
 
-/*!
- * @brief Function to get the usage count for the requested clock.
- *
- * This function returns the reference count for the clock.
- *
- * @param clk 	Handle to clock to disable.
- *
- * @return Returns the usage count for the requested clock.
- */
-int clk_get_usecount(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return 0;
-
-	return clk->usecount;
-}
-
-EXPORT_SYMBOL(clk_get_usecount);
-
 /*
  * Get the resulting clock rate from a PLL register value and the input
  * frequency. PLLs with this register layout can at least be found on
@@ -263,3 +309,129 @@ unsigned long mxc_decode_pll(unsigned int reg_val, u32 freq)
 
 	return ll;
 }
+
+#ifdef CONFIG_CLK_DEBUG
+/*
+ *	debugfs support to trace clock tree hierarchy and attributes
+ */
+static int clk_debug_rate_get(void *data, u64 *val)
+{
+	struct clk *clk = data;
+
+	*val = (u64)clk_get_rate(clk);
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(clk_debug_rate_fops, clk_debug_rate_get, NULL,
+		"%llu\n");
+
+
+static struct dentry *clk_root;
+static int clk_debug_register_one(struct clk *clk)
+{
+	int err;
+	struct dentry *d, *child, *child_tmp;
+	struct clk *pa = clk_get_parent(clk);
+
+	if (pa && !IS_ERR(pa))
+		d = debugfs_create_dir(clk->name, pa->dentry);
+	else {
+		if (!clk_root)
+			clk_root = debugfs_create_dir("clock", NULL);
+		if (!clk_root)
+			return -ENOMEM;
+		d = debugfs_create_dir(clk->name, clk_root);
+	}
+
+	if (!d)
+		return -ENOMEM;
+
+	clk->dentry = d;
+
+	d = debugfs_create_u8("usecount", S_IRUGO, clk->dentry,
+			(u8 *)&clk->usecount);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	d = debugfs_create_file("rate", S_IRUGO, clk->dentry, (void *)clk,
+			&clk_debug_rate_fops);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	d = debugfs_create_u32("flags", S_IRUGO, clk->dentry,
+			(u32 *)&clk->flags);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	d = clk->dentry;
+	list_for_each_entry_safe(child, child_tmp, &d->d_subdirs, d_u.d_child)
+		debugfs_remove(child);
+	debugfs_remove(clk->dentry);
+	return err;
+}
+
+struct preinit_clk {
+	struct list_head list;
+	struct clk *clk;
+};
+static LIST_HEAD(preinit_clks);
+static DEFINE_MUTEX(preinit_lock);
+static int init_done;
+
+void clk_debug_register(struct clk *clk)
+{
+	int err;
+	struct clk *pa;
+
+	if (init_done) {
+		pa = clk_get_parent(clk);
+
+		if (pa && !IS_ERR(pa) && !pa->dentry)
+			clk_debug_register(pa);
+
+		if (!clk->dentry) {
+			err = clk_debug_register_one(clk);
+			if (err)
+				return;
+		}
+	} else {
+		struct preinit_clk *p;
+		mutex_lock(&preinit_lock);
+		p = kmalloc(sizeof(*p), GFP_KERNEL);
+		if (p) {
+			p->clk = clk;
+			list_add(&p->list, &preinit_clks);
+		}
+		mutex_unlock(&preinit_lock);
+	}
+}
+EXPORT_SYMBOL_GPL(clk_debug_register);
+
+static int __init clk_debugfs_init(void)
+{
+	struct preinit_clk *pclk, *tmp;
+
+	init_done = 1;
+
+	mutex_lock(&preinit_lock);
+	list_for_each_entry(pclk, &preinit_clks, list) {
+		clk_debug_register(pclk->clk);
+	}
+
+	list_for_each_entry_safe(pclk, tmp, &preinit_clks, list) {
+		list_del(&pclk->list);
+		kfree(pclk);
+	}
+	mutex_unlock(&preinit_lock);
+	return 0;
+}
+late_initcall(clk_debugfs_init);
+#endif
diff --git a/arch/arm/plat-mxc/cpu.c b/arch/arm/plat-mxc/cpu.c
index 3b416234..9af8fc7 100644
--- a/arch/arm/plat-mxc/cpu.c
+++ b/arch/arm/plat-mxc/cpu.c
@@ -9,6 +9,8 @@ EXPORT_SYMBOL(__mxc_cpu_type);
 void (*set_num_cpu_op)(int num);
 int mxc_jtag_enabled;		/* OFF: 0 (default), ON: 1 */
 int uart_at_24; 			/* OFF: 0 (default); ON: 1 */
+extern int mxc_early_serial_console_init(unsigned long base, struct clk *clk);
+
 /*
  * Here are the JTAG options from the command line. By default JTAG
  * is OFF which means JTAG is not connected and WFI is enabled
@@ -30,6 +32,14 @@ static int __init jtag_wfi_setup(char *p)
 }
 early_param("jtag", jtag_wfi_setup);
 
+static int __init setup_debug_uart(char *p)
+{
+	uart_at_24 = 1;
+	return 0;
+}
+
+early_param("debug_uart", setup_debug_uart);
+
 void mxc_set_cpu_type(unsigned int type)
 {
 	__mxc_cpu_type = type;
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
index 61d314f..77ea7e6 100644
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -16,7 +16,6 @@
  * The CPUFREQ driver is for controlling CPU frequency. It allows you to change
  * the CPU clock speed on the fly.
  */
-
 #include <linux/module.h>
 #include <linux/cpufreq.h>
 #include <linux/clk.h>
@@ -24,8 +23,11 @@
 #include <linux/slab.h>
 #include <linux/regulator/consumer.h>
 #include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/suspend.h>
 #include <asm/smp_plat.h>
 #include <asm/cpu.h>
+
 #include <mach/hardware.h>
 #include <mach/clock.h>
 
@@ -43,64 +45,163 @@ static struct cpufreq_frequency_table *imx_freq_table;
 static int cpu_op_nr;
 static struct cpu_op *cpu_op_tbl;
 static u32 pre_suspend_rate;
+static bool cpufreq_suspend;
+static struct mutex set_cpufreq_lock;
 
 extern struct regulator *cpu_regulator;
+extern struct regulator *soc_regulator;
+extern struct regulator *pu_regulator;
 extern int dvfs_core_is_active;
-extern int low_bus_freq_mode;
-extern int high_bus_freq_mode;
-extern int set_low_bus_freq(void);
-extern int set_high_bus_freq(int high_bus_speed);
-extern int low_freq_bus_used(void);
+extern void bus_freq_update(struct clk *clk, bool flag);
+extern void mx6_arm_regulator_bypass(void);
+extern void mx6_soc_pu_regulator_bypass(void);
 
 int set_cpu_freq(int freq)
 {
-	int ret = 0;
+	int i, ret = 0;
 	int org_cpu_rate;
-	int i, gp_volt = 0;
+	int gp_volt = 0, org_gp_volt = 0;
+	int soc_volt = 0, org_soc_volt = 0;
+	int pu_volt = 0, org_pu_volt = 0;
 
 	org_cpu_rate = clk_get_rate(cpu_clk);
 	if (org_cpu_rate == freq)
 		return ret;
 
 	for (i = 0; i < cpu_op_nr; i++) {
-		if (freq == cpu_op_tbl[i].cpu_rate)
+		if (freq == cpu_op_tbl[i].cpu_rate) {
 			gp_volt = cpu_op_tbl[i].cpu_voltage;
+			soc_volt = cpu_op_tbl[i].soc_voltage;
+			pu_volt = cpu_op_tbl[i].pu_voltage;
+		}
+		if (org_cpu_rate == cpu_op_tbl[i].cpu_rate) {
+			org_gp_volt = cpu_op_tbl[i].cpu_voltage;
+			org_soc_volt = cpu_op_tbl[i].soc_voltage;
+			org_pu_volt = cpu_op_tbl[i].pu_voltage;
+		}
 	}
-
 	if (gp_volt == 0)
 		return ret;
-
 	/*Set the voltage for the GP domain. */
 	if (freq > org_cpu_rate) {
-		if (low_bus_freq_mode)
-			set_high_bus_freq(0);
+		/* Check if the bus freq needs to be increased first */
+		bus_freq_update(cpu_clk, true);
+
+		if (!IS_ERR(soc_regulator)) {
+			ret = regulator_set_voltage(soc_regulator, soc_volt,
+							soc_volt);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"COULD NOT SET SOC VOLTAGE!!!!\n");
+				goto err1;
+			}
+		}
+		/*if pu_regulator is enabled, it will be tracked with VDDARM*/
+		if (!IS_ERR(pu_regulator) &&
+			regulator_is_enabled(pu_regulator)) {
+			ret = regulator_set_voltage(pu_regulator, pu_volt,
+							pu_volt);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"COULD NOT SET PU VOLTAGE!!!!\n");
+				goto err2;
+			}
+		}
 		ret = regulator_set_voltage(cpu_regulator, gp_volt,
 					    gp_volt);
 		if (ret < 0) {
-			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
-			return ret;
+			printk(KERN_ERR "COULD NOT SET GP VOLTAGE!!!!\n");
+			goto err3;
 		}
-		udelay(50);
 	}
-
 	ret = clk_set_rate(cpu_clk, freq);
 	if (ret != 0) {
-		printk(KERN_DEBUG "cannot set CPU clock rate\n");
-		return ret;
+		printk(KERN_ERR "cannot set CPU clock rate\n");
+		goto err4;
 	}
 
 	if (freq < org_cpu_rate) {
 		ret = regulator_set_voltage(cpu_regulator, gp_volt,
 					    gp_volt);
 		if (ret < 0) {
-			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
-			return ret;
+			printk(KERN_ERR "COULD NOT SET GP VOLTAGE!!!!\n");
+			goto err5;
+		}
+		if (!IS_ERR(soc_regulator)) {
+			ret = regulator_set_voltage(soc_regulator, soc_volt,
+							soc_volt);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"COULD NOT SET SOC VOLTAGE BACK!!!!\n");
+				goto err6;
+			}
+		}
+		/*if pu_regulator is enabled, it will be tracked with VDDARM*/
+		if (!IS_ERR(pu_regulator) &&
+			regulator_is_enabled(pu_regulator)) {
+			ret = regulator_set_voltage(pu_regulator, pu_volt,
+							pu_volt);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"COULD NOT SET PU VOLTAGE!!!!\n");
+				goto err7;
+			}
 		}
-		if (low_freq_bus_used() && !low_bus_freq_mode)
-			set_low_bus_freq();
+		/* Check if the bus freq can be decreased.*/
+		bus_freq_update(cpu_clk, false);
 	}
 
 	return ret;
+	/*Restore back if any regulator or clock rate set fail.*/
+err7:
+	ret = regulator_set_voltage(soc_regulator, org_soc_volt,
+							org_soc_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE SOC VOLTAGE!!!!\n");
+		goto err7;
+	}
+
+err6:
+	ret = regulator_set_voltage(cpu_regulator, org_gp_volt, org_gp_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE GP VOLTAGE!!!!\n");
+		goto err6;
+	}
+
+err5:
+	ret = clk_set_rate(cpu_clk, org_cpu_rate);
+	if (ret != 0) {
+		printk(KERN_ERR "cannot restore CPU clock rate\n");
+		goto err5;
+	}
+	return -1;
+
+err4:
+	ret = regulator_set_voltage(cpu_regulator, org_gp_volt, org_gp_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE GP VOLTAGE!!!!\n");
+		goto err4;
+	}
+
+err3:
+	if (!IS_ERR(pu_regulator) &&
+		regulator_is_enabled(pu_regulator)) {
+		ret = regulator_set_voltage(pu_regulator, org_pu_volt, org_pu_volt);
+		if (ret < 0) {
+			printk(KERN_ERR "COULD NOT RESTORE PU VOLTAGE!!!!\n");
+			goto err3;
+		}
+	}
+err2:
+	ret = regulator_set_voltage(soc_regulator, org_soc_volt,
+							org_soc_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE SOC VOLTAGE!!!!\n");
+		goto err2;
+	}
+err1:
+	return -1;
+
 }
 
 static int mxc_verify_speed(struct cpufreq_policy *policy)
@@ -131,7 +232,6 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	num_cpus = num_possible_cpus();
 	if (policy->cpu > num_cpus)
 		return 0;
-
 	if (dvfs_core_is_active) {
 		struct cpufreq_freqs freqs;
 
@@ -146,6 +246,11 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 		return ret;
 	}
 
+	mutex_lock(&set_cpufreq_lock);
+	if (cpufreq_suspend) {
+		mutex_unlock(&set_cpufreq_lock);
+		return ret;
+	}
 	cpufreq_frequency_table_target(policy, imx_freq_table,
 			target_freq, relation, &index);
 	freq_Hz = imx_freq_table[index].frequency * 1000;
@@ -154,51 +259,46 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	freqs.new = freq_Hz / 1000;
 	freqs.cpu = policy->cpu;
 	freqs.flags = 0;
-
 	for (i = 0; i < num_cpus; i++) {
 		freqs.cpu = i;
 		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 	}
-
 	ret = set_cpu_freq(freq_Hz);
-
+	if (ret) {
+		/*restore cpufreq and tell cpufreq core if set fail*/
+		freqs.old = clk_get_rate(cpu_clk) / 1000;
+		freqs.new = freqs.old;
+		freqs.cpu = policy->cpu;
+		freqs.flags = 0;
+		for (i = 0; i < num_cpus; i++) {
+			freqs.cpu = i;
+			cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		}
+		goto  Set_finish;
+	}
 #ifdef CONFIG_SMP
 	/* Loops per jiffy is not updated by the CPUFREQ driver for SMP systems.
 	  * So update it for all CPUs.
 	  */
 
-	for_each_cpu(i, policy->cpus)
+	for_each_possible_cpu(i)
 		per_cpu(cpu_data, i).loops_per_jiffy =
 		cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
 					freqs.old, freqs.new);
+	/* Update global loops_per_jiffy to cpu0's loops_per_jiffy,
+	 * as all CPUs are running at same freq */
+	loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
 #endif
+Set_finish:
 	for (i = 0; i < num_cpus; i++) {
 		freqs.cpu = i;
 		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
 	}
-
+	mutex_unlock(&set_cpufreq_lock);
 
 	return ret;
 }
 
-static int mxc_cpufreq_suspend(struct cpufreq_policy *policy)
-{
-	pre_suspend_rate = clk_get_rate(cpu_clk);
-	/* Set to max freq and voltage */
-	if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000))
-		set_cpu_freq(imx_freq_table[0].frequency);
-
-	return 0;
-}
-
-static int mxc_cpufreq_resume(struct cpufreq_policy *policy)
-{
-	if (clk_get_rate(cpu_clk) != pre_suspend_rate)
-		set_cpu_freq(pre_suspend_rate);
-
-	return 0;
-}
-
 static int __devinit mxc_cpufreq_init(struct cpufreq_policy *policy)
 {
 	int ret;
@@ -290,6 +390,10 @@ static int mxc_cpufreq_exit(struct cpufreq_policy *policy)
 	return 0;
 }
 
+static struct freq_attr *imx_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
 static struct cpufreq_driver mxc_driver = {
 	.flags = CPUFREQ_STICKY,
 	.verify = mxc_verify_speed,
@@ -297,13 +401,118 @@ static struct cpufreq_driver mxc_driver = {
 	.get = mxc_get_speed,
 	.init = mxc_cpufreq_init,
 	.exit = mxc_cpufreq_exit,
-	.suspend = mxc_cpufreq_suspend,
-	.resume = mxc_cpufreq_resume,
 	.name = "imx",
+	.attr = imx_cpufreq_attr,
 };
 
+static int cpufreq_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	unsigned int i;
+	int num_cpus;
+	int ret;
+	struct cpufreq_freqs freqs;
+
+	num_cpus = num_possible_cpus();
+	mutex_lock(&set_cpufreq_lock);
+	if (event == PM_SUSPEND_PREPARE) {
+		pre_suspend_rate = clk_get_rate(cpu_clk);
+		if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000)) {
+			/*notify cpufreq core will raise up cpufreq to highest*/
+			freqs.old = pre_suspend_rate / 1000;
+			freqs.new = imx_freq_table[0].frequency;
+			freqs.flags = 0;
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+			}
+			ret = set_cpu_freq(imx_freq_table[0].frequency * 1000);
+			/*restore cpufreq and tell cpufreq core if set fail*/
+			if (ret) {
+				freqs.old =  clk_get_rate(cpu_clk)/1000;
+				freqs.new = freqs.old;
+				freqs.flags = 0;
+				for (i = 0; i < num_cpus; i++) {
+					freqs.cpu = i;
+					cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+				}
+				goto Notify_finish;/*if update freq error,return*/
+			}
+#ifdef CONFIG_SMP
+			for_each_possible_cpu(i)
+				per_cpu(cpu_data, i).loops_per_jiffy =
+					cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
+					pre_suspend_rate / 1000, imx_freq_table[0].frequency);
+			loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
+#else
+			loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
+				pre_suspend_rate / 1000, imx_freq_table[0].frequency);
+#endif
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+			}
+		}
+		cpufreq_suspend = true;
+	} else if (event == PM_POST_SUSPEND) {
+		if (clk_get_rate(cpu_clk) != pre_suspend_rate) {
+			/*notify cpufreq core will restore rate before suspend*/
+			freqs.old = imx_freq_table[0].frequency;
+			freqs.new = pre_suspend_rate / 1000;
+			freqs.flags = 0;
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+			}
+			ret = set_cpu_freq(pre_suspend_rate);
+			/*restore cpufreq and tell cpufreq core if set fail*/
+			if (ret) {
+				freqs.old =  clk_get_rate(cpu_clk)/1000;
+				freqs.new = freqs.old;
+				freqs.flags = 0;
+				for (i = 0; i < num_cpus; i++) {
+					freqs.cpu = i;
+					cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+				}
+				goto Notify_finish;/*if update freq error,return*/
+			}
+#ifdef CONFIG_SMP
+			for_each_possible_cpu(i)
+				per_cpu(cpu_data, i).loops_per_jiffy =
+					cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
+					imx_freq_table[0].frequency, pre_suspend_rate / 1000);
+			loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
+#else
+			loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
+				imx_freq_table[0].frequency, pre_suspend_rate / 1000);
+#endif
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+			}
+		}
+		cpufreq_suspend = false;
+	}
+	mutex_unlock(&set_cpufreq_lock);
+	return NOTIFY_OK;
+
+Notify_finish:
+	for (i = 0; i < num_cpus; i++) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+	mutex_unlock(&set_cpufreq_lock);
+	return NOTIFY_OK;
+}
+static struct notifier_block imx_cpufreq_pm_notifier = {
+	.notifier_call = cpufreq_pm_notify,
+};
+extern void mx6_cpu_regulator_init(void);
 static int __init mxc_cpufreq_driver_init(void)
 {
+	mx6_cpu_regulator_init();
+	mutex_init(&set_cpufreq_lock);
+	register_pm_notifier(&imx_cpufreq_pm_notifier);
 	return cpufreq_register_driver(&mxc_driver);
 }
 
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index fd803f5..7cdd602 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -24,6 +24,7 @@ config IMX_HAVE_PLATFORM_IMXDI_RTC
 
 config IMX_HAVE_PLATFORM_IMX_FB
 	bool
+	select HAVE_FB_IMX
 
 config IMX_HAVE_PLATFORM_IMX_I2C
 	bool
@@ -137,3 +138,58 @@ config IMX_HAVE_PLATFORM_IMX_ASRC
 
 config IMX_HAVE_PLATFORM_IMX_ESAI
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_VDOA
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_MIPI_DSI
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_CAAM
+	bool
+	default y if SOC_IMX6Q
+
+config IMX_HAVE_PLATFORM_IMX_VIIM
+	bool
+
+config IMX_HAVE_PLATFORM_DMA
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_PXP
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_EPDC
+	bool
+
+config IMX_HAVE_PLATFORM_PERFMON
+	bool
+
+config IMX_HAVE_PLATFORM_MXC_MLB
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_TVE
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_IIM
+	bool
+
+config IMX_HAVE_PLATFORM_MXC_GPU
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_DCP
+	bool
+
+config IMX_HAVE_PLATFORM_RANDOM_RNGC
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_ELCDIF
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_SPDC
+	bool
+
+config IMX_HAVE_PLATFORM_GPMI_NFC
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_FSL_CSI
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index faed531..b37c617 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -50,3 +50,22 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SPDIF) += platform-imx-spdif-dai.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SPDIF) += platform-imx-spdif-audio.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_PCIE) += platform-imx-pcie.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_ASRC) += platform-imx-asrc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_VDOA) += platform-imx-vdoa.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_MIPI_DSI) += platform-imx-mipi_dsi.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_CAAM) += platform-imx-caam.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_VIIM) += platform-imx-viim.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_DMA) += platform-dma.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_PXP) += platform-imx-pxp.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_EPDC) += platform-imx-epdc-fb.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_PERFMON) += platform-imx-perfmon.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_MLB) += platform-mxc_mlb.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_TVE) += platform-imx_tve.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_IIM)	+= platform-imx-iim.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_GPU) += platform-mxc_gpu.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_DCP) += platform-imx-dcp.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_RANDOM_RNGC) += platform-imx-rngb.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_ELCDIF) += platform-imx-elcdif-fb.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SPDC) += platform-imx-spdc-fb.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_GPMI_NFC) += platform-imx-gpmi-nfc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_FSL_CSI) += platform-imx-fsl-csi.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_ESAI) += platform-imx-esai.o
diff --git a/arch/arm/plat-mxc/devices/platform-ahci-imx.c b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
index c6dd6ba..90d994c 100644
--- a/arch/arm/plat-mxc/devices/platform-ahci-imx.c
+++ b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -18,148 +18,28 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/dma-mapping.h>
 #include <asm/sizes.h>
 #include <mach/hardware.h>
 #include <mach/devices-common.h>
 
-#define imx_ahci_imx_data_entry_single(soc, _devid)		\
+#define imx_ahci_data_entry_single(soc)					\
 	{								\
-		.devid = _devid,					\
 		.iobase = soc ## _SATA_BASE_ADDR,			\
-		.irq = soc ## _INT_SATA,				\
+		.irq = soc ## _INT_SATA,					\
 	}
 
 #ifdef CONFIG_SOC_IMX53
-const struct imx_ahci_imx_data imx53_ahci_imx_data __initconst =
-	imx_ahci_imx_data_entry_single(MX53, "imx53-ahci");
+const struct imx_ahci_data imx53_ahci_data __initconst =
+	imx_ahci_data_entry_single(MX53);
 #endif
 
 #ifdef CONFIG_SOC_IMX6Q
-const struct imx_ahci_imx_data imx6q_ahci_imx_data __initconst =
-	imx_ahci_imx_data_entry_single(MX6Q, "imx6q-ahci");
+const struct imx_ahci_data imx6q_ahci_data __initconst =
+	imx_ahci_data_entry_single(MX6Q);
 #endif
 
-enum {
-	HOST_CAP = 0x00,
-	HOST_CAP_SSS = (1 << 27), /* Staggered Spin-up */
-	HOST_PORTS_IMPL	= 0x0c,
-	HOST_TIMER1MS = 0xe0, /* Timer 1-ms */
-
-	PORT_SATA_SR = 0x128, /*  Port0 PHY Control */
-	PORT_PHY_CTL = 0x178, /*  Port0 PHY Control */
-	PORT_PHY_CTL_PDDQ_LOC = 0x100000,
-};
-
-static struct clk *sata_clk, *sata_ref_clk;
-
-/* AHCI module Initialization, if return 0, initialization is successful. */
-static int imx_sata_init(struct device *dev, void __iomem *addr)
-{
-	u32 tmpdata;
-	int ret = 0, iterations = 200;
-	struct clk *clk;
-
-	sata_clk = clk_get(dev, "ahci");
-	if (IS_ERR(sata_clk)) {
-		dev_err(dev, "no sata clock.\n");
-		return PTR_ERR(sata_clk);
-	}
-	ret = clk_prepare_enable(sata_clk);
-	if (ret) {
-		dev_err(dev, "can't prepare/enable sata clock.\n");
-		goto put_sata_clk;
-	}
-
-	/* Get the AHCI SATA PHY CLK */
-	sata_ref_clk = clk_get(dev, "ahci_phy");
-	if (IS_ERR(sata_ref_clk)) {
-		dev_err(dev, "no sata ref clock.\n");
-		ret = PTR_ERR(sata_ref_clk);
-		goto release_sata_clk;
-	}
-	ret = clk_prepare_enable(sata_ref_clk);
-	if (ret) {
-		dev_err(dev, "can't prepare/enable sata ref clock.\n");
-		goto put_sata_ref_clk;
-	}
-
-	/* Get the AHB clock rate, and configure the TIMER1MS reg later */
-	clk = clk_get(dev, "ahci_dma");
-	if (IS_ERR(clk)) {
-		dev_err(dev, "no dma clock.\n");
-		ret = PTR_ERR(clk);
-		goto release_sata_ref_clk;
-	}
-	tmpdata = clk_get_rate(clk) / 1000;
-	clk_put(clk);
-
-	writel(tmpdata, addr + HOST_TIMER1MS);
-
-	tmpdata = readl(addr + HOST_CAP);
-	if (!(tmpdata & HOST_CAP_SSS)) {
-		tmpdata |= HOST_CAP_SSS;
-		writel(tmpdata, addr + HOST_CAP);
-	}
-
-	if (!(readl(addr + HOST_PORTS_IMPL) & 0x1))
-		writel((readl(addr + HOST_PORTS_IMPL) | 0x1),
-			addr + HOST_PORTS_IMPL);
-
-	/* Release resources when there is no device on the port */
-	do {
-		if ((readl(addr + PORT_SATA_SR) & 0xF) == 0)
-			usleep_range(2000, 3000);
-		else
-			break;
-
-		if (iterations == 0) {
-			/*  Enter into PDDQ mode, save power */
-			pr_info("No sata disk, enter into PDDQ mode.\n");
-			tmpdata = readl(addr + PORT_PHY_CTL);
-			writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC,
-					addr + PORT_PHY_CTL);
-			ret = -ENODEV;
-			goto release_sata_ref_clk;
-		}
-	} while (iterations-- > 0);
-
-	return 0;
-
-release_sata_ref_clk:
-	clk_disable_unprepare(sata_ref_clk);
-put_sata_ref_clk:
-	clk_put(sata_ref_clk);
-release_sata_clk:
-	clk_disable_unprepare(sata_clk);
-put_sata_clk:
-	clk_put(sata_clk);
-
-	return ret;
-}
-
-static void imx_sata_exit(struct device *dev)
-{
-	clk_disable_unprepare(sata_ref_clk);
-	clk_put(sata_ref_clk);
-
-	clk_disable_unprepare(sata_clk);
-	clk_put(sata_clk);
-
-}
-
-struct ahci_platform_data imx_sata_pdata = {
-	.init = imx_sata_init,
-	.exit = imx_sata_exit,
-};
-
-struct platform_device *__init imx_add_ahci_imx(
-		const struct imx_ahci_imx_data *data,
+struct platform_device *__init imx_add_ahci(
+		const struct imx_ahci_data *data,
 		const struct ahci_platform_data *pdata)
 {
 	struct resource res[] = {
@@ -174,21 +54,10 @@ struct platform_device *__init imx_add_ahci_imx(
 		},
 	};
 
-	return imx_add_platform_device_dmamask(data->devid, 0,
+	if (!fuse_dev_is_available(MXC_DEV_SATA))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("ahci", 0 /* -1? */,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata),  DMA_BIT_MASK(32));
 }
-
-#ifdef CONFIG_SOC_IMX53
-struct platform_device *__init imx53_add_ahci_imx(void)
-{
-	return imx_add_ahci_imx(&imx53_ahci_imx_data, &imx_sata_pdata);
-}
-#endif
-
-#ifdef CONFIG_SOC_IMX6Q
-struct platform_device *__init imx6q_add_ahci_imx(void)
-{
-	return imx_add_ahci_imx(&imx6q_ahci_imx_data, &imx_sata_pdata);
-}
-#endif
diff --git a/arch/arm/plat-mxc/devices/platform-dma.c b/arch/arm/plat-mxc/devices/platform-dma.c
new file mode 100644
index 0000000..7f73195
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-dma.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <linux/compiler.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_dma_res_data imx50_dma_res_data __initconst = {
+	.iobase = MX50_APBHDMA_BASE_ADDR,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_dma_res_data imx6q_dma_res_data __initconst = {
+	.iobase = APBH_DMA_ARB_BASE_ADDR,
+};
+#endif
+
+struct platform_device *__init imx_add_dma(
+			const struct imx_dma_res_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_8K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxs-dma-apbh", -1,
+				res, ARRAY_SIZE(res), NULL, 0,
+				DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-fec.c b/arch/arm/plat-mxc/devices/platform-fec.c
index 86a4d24..2f9eef5 100644
--- a/arch/arm/plat-mxc/devices/platform-fec.c
+++ b/arch/arm/plat-mxc/devices/platform-fec.c
@@ -55,6 +55,9 @@ const struct imx_fec_data imx53_fec_data __initconst =
 #ifdef CONFIG_SOC_IMX6Q
 const struct imx_fec_data imx6q_fec_data __initconst =
 	imx_fec_data_entry_single(MX6Q, "imx6q-fec");
+
+const struct imx_fec_data imx6sl_fec_data __initconst =
+	imx_fec_data_entry_single(MX6DL, "fec");
 #endif
 
 struct platform_device *__init imx_add_fec(
@@ -73,6 +76,10 @@ struct platform_device *__init imx_add_fec(
 		},
 	};
 
+#ifdef CONFIG_SOC_IMX6Q
+	if (!fuse_dev_is_available(MXC_DEV_ENET))
+		return ERR_PTR(-ENODEV);
+#endif
 	return imx_add_platform_device_dmamask(data->devid, 0,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
index f32593c..da7b221 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Based on Uwe Kleine-Koenig's platform-fsl-usb2-udc.c
  * Copyright (C) 2010 Pengutronix
@@ -39,7 +39,51 @@ struct platform_device *__init imx_add_fsl_usb2_otg(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-usb2-otg", -1,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+
+	int ret = -ENOMEM;
+	const char *name = "fsl-usb2-otg";
+	int id = -1;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+	if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(imx_add_fsl_usb2_otg);
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
index 2f1e238f..4c54e11 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
  * Copyright (C) 2010 Pengutronix
  * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
  *
@@ -36,11 +38,6 @@ const struct imx_fsl_usb2_udc_data imx35_fsl_usb2_udc_data __initconst =
 	imx_fsl_usb2_udc_data_entry_single(MX35);
 #endif /* ifdef CONFIG_SOC_IMX35 */
 
-#ifdef CONFIG_SOC_IMX51
-const struct imx_fsl_usb2_udc_data imx51_fsl_usb2_udc_data __initconst =
-	imx_fsl_usb2_udc_data_entry_single(MX51);
-#endif
-
 #ifdef CONFIG_SOC_IMX6Q
 const struct imx_fsl_usb2_udc_data imx6q_fsl_usb2_udc_data __initconst =
 	imx_fsl_usb2_udc_data_entry_single(MX6Q);
@@ -61,7 +58,52 @@ struct platform_device *__init imx_add_fsl_usb2_udc(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-usb2-udc", -1,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+
+	int ret = -ENOMEM;
+	const char *name = "fsl-usb2-udc";
+	int id = -1;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+	if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(imx_add_fsl_usb2_udc);
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
index 523c5d4..3dacd28 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Copyright (C) 2010 Pengutronix
  * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
@@ -25,6 +25,12 @@ const struct imx_fsl_usb2_wakeup_data imx6q_fsl_hs_wakeup_data[] __initconst = {
 	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 2, HS2),
 	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 3, HS3),
 };
+
+const struct imx_fsl_usb2_wakeup_data imx6sl_fsl_hs_wakeup_data[] __initconst = {
+	imx_fsl_usb2_wakeup_data_entry_single(MX6SL, 1, HS1),
+	imx_fsl_usb2_wakeup_data_entry_single(MX6SL, 2, HS2),
+	imx_fsl_usb2_wakeup_data_entry_single(MX6SL, 3, HS3),
+};
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
 struct platform_device *__init imx_add_fsl_usb2_wakeup(
@@ -46,3 +52,4 @@ struct platform_device *__init imx_add_fsl_usb2_wakeup(
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
+EXPORT_SYMBOL(imx_add_fsl_usb2_wakeup);
diff --git a/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c b/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
index b96bc6f..352d0f0 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,9 +20,11 @@
 #include <mach/hardware.h>
 #include <mach/devices-common.h>
 
-#define imx_anatop_thermal_imx_data_entry_single(soc)				\
-	{								\
+#define imx_anatop_thermal_imx_data_entry_single(soc)		\
+	{							\
 		.iobase = ANATOP_BASE_ADDR,			\
+		.calibration_addr = OCOTP_BASE_ADDR + 0x4E0,	\
+		.irq = MXC_INT_ANATOP_TEMPSNSR			\
 	}
 
 #ifdef CONFIG_SOC_IMX6Q
@@ -40,6 +42,16 @@ struct platform_device *__init imx_add_anatop_thermal_imx(
 			.end = data->iobase + SZ_4K - 1,
 			.flags = IORESOURCE_MEM,
 		},
+		{
+			.start = data->calibration_addr,
+			.end = data->calibration_addr + SZ_4 - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
 	};
 
 	return imx_add_platform_device("anatop_thermal", 0,
diff --git a/arch/arm/plat-mxc/devices/platform-imx-caam.c b/arch/arm/plat-mxc/devices/platform-imx-caam.c
new file mode 100644
index 0000000..aaaf501
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-caam.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+/*
+ * security violation interrupt is used as CAAM base _INT_SNVS_SEC
+ * SNVS consolidated = _INT_SNVS
+ * JR0 = MXC_INT_CAAM_INT0_NUM
+ * JR1 = MXC_INT_CAAM_INT1_NUM
+ */
+
+const struct imx_caam_data imx6q_imx_caam_data __initconst = {
+	.iobase_caam = MXC_CAAM_BASE_ADDR,
+	.iobase_caam_sm = CAAM_SECMEM_BASE_ADDR,
+	.iobase_snvs = MX6Q_SNVS_BASE_ADDR,
+	.irq_sec_vio = MXC_INT_SNVS_SEC,
+	.irq_snvs = MX6Q_INT_SNVS,
+	.jr[0].offset_jr = 0x1000,
+	.jr[0].irq_jr = MXC_INT_CAAM_INT0_NUM,
+	.jr[1].offset_jr = 0x2000,
+	.jr[1].irq_jr = MXC_INT_CAAM_INT1_NUM,
+};
+
+struct platform_device *__init imx_add_caam(
+		const struct imx_caam_data *data)
+{
+	u32 res_count = 0;
+	struct resource res[] = {
+		{
+			/* Define base range for entire CAAM register map */
+			.name = "iobase_caam",
+			.start = data->iobase_caam,
+			.end = data->iobase_caam + SZ_64K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			/* Define range for secure memory */
+			.name = "iobase_caam_sm",
+			.start = data->iobase_caam_sm,
+			.end = data->iobase_caam_sm + SZ_16K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			/* Define range for SNVS */
+			.name = "iobase_snvs",
+			.start = data->iobase_snvs,
+			.end = data->iobase_snvs + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			/* Define interrupt for security violations */
+			.name = "irq_sec_vio",
+			.start = data->irq_sec_vio,
+			.end = data->irq_sec_vio,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			/* Define general SNVS interrupt */
+			.name = "irq_snvs",
+			.start = data->irq_snvs,
+			.end = data->irq_snvs,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.name = "offset_jr0",
+			.start = data->jr[0].offset_jr,
+			.end = data->jr[0].offset_jr,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.name = "irq_jr0",
+			.start = data->jr[0].irq_jr,
+			.end = data->jr[0].irq_jr,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.name = "offset_jr1",
+			.start = data->jr[1].offset_jr,
+			.end = data->jr[1].offset_jr,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.name = "irq_jr1",
+			.start = data->jr[1].irq_jr,
+			.end = data->jr[1].irq_jr,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	res_count = ARRAY_SIZE(res);
+	BUG_ON(!res_count);
+
+	return imx_add_platform_device("caam", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-dcp.c b/arch/arm/plat-mxc/devices/platform-imx-dcp.c
new file mode 100644
index 0000000..a77840b
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-dcp.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2010 Pengutronix
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#ifdef CONFIG_SOC_IMX50
+#define imx_dcp_data_entry_single(soc)	\
+{						\
+	.iobase = soc ## _DCP_BASE_ADDR,	\
+	.irq1 = soc ## _INT_DCP_CHAN0,		\
+	.irq2 = soc ## _INT_DCP_CHAN1_3,	\
+}
+
+const struct imx_dcp_data imx50_dcp_data __initconst =
+	imx_dcp_data_entry_single(MX50);
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
+#ifdef CONFIG_SOC_IMX6SL
+#define imx_dcp_data_entry_single(soc)	\
+{						\
+	.iobase = soc ## _DCP_BASE_ADDR,	\
+	.irq1 = soc ## _INT_DCP_CH0,		\
+	.irq2 = soc ## _INT_DCP_GEN,		\
+}
+
+const struct imx_dcp_data imx6sl_dcp_data __initconst =
+	imx_dcp_data_entry_single(MX6SL);
+#endif /* ifdef CONFIG_SOC_IMX6SL */
+
+struct platform_device *__init imx_add_dcp(
+		const struct imx_dcp_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_8K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->irq1,
+			.end = data->irq1,
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = data->irq2,
+			.end = data->irq2,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("dcp", 0,
+			res, ARRAY_SIZE(res), NULL, 0, DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-dma.c b/arch/arm/plat-mxc/devices/platform-imx-dma.c
index 7fa7e9c..e7caaf4 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-dma.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-dma.c
@@ -6,29 +6,277 @@
  * the terms of the GNU General Public License version 2 as published by the
  * Free Software Foundation.
  */
+#include <linux/compiler.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
 #include <mach/devices-common.h>
+#include <mach/sdma.h>
 
-struct platform_device __init __maybe_unused *imx_add_imx_dma(void)
-{
-	return platform_device_register_resndata(&mxc_ahb_bus,
-			"imx-dma", -1, NULL, 0, NULL, 0);
-}
+struct imx_imx_sdma_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+	struct sdma_platform_data pdata;
+};
+
+#define imx_imx_sdma_data_entry_single(soc, _sdma_version, _cpu_name, _to_version)\
+	{								\
+		.iobase = soc ## _SDMA ## _BASE_ADDR,			\
+		.irq = soc ## _INT_SDMA,				\
+		.pdata = {						\
+			.sdma_version = _sdma_version,			\
+			.cpu_name = _cpu_name,				\
+			.to_version = _to_version,			\
+		},							\
+	}
+
+#ifdef CONFIG_SOC_IMX25
+struct imx_imx_sdma_data imx25_imx_sdma_data __initconst =
+	imx_imx_sdma_data_entry_single(MX25, 1, "imx25", 0);
+#endif /* ifdef CONFIG_SOC_IMX25 */
+
+#ifdef CONFIG_SOC_IMX31
+struct imx_imx_sdma_data imx31_imx_sdma_data __initdata =
+	imx_imx_sdma_data_entry_single(MX31, 1, "imx31", 0);
+#endif /* ifdef CONFIG_SOC_IMX31 */
+
+#ifdef CONFIG_SOC_IMX35
+struct imx_imx_sdma_data imx35_imx_sdma_data __initdata =
+	imx_imx_sdma_data_entry_single(MX35, 2, "imx35", 0);
+#endif /* ifdef CONFIG_SOC_IMX35 */
+
+#ifdef CONFIG_SOC_IMX51
+struct imx_imx_sdma_data imx51_imx_sdma_data __initconst =
+	imx_imx_sdma_data_entry_single(MX51, 2, "imx51", 0);
+#endif /* ifdef CONFIG_SOC_IMX51 */
 
-struct platform_device __init __maybe_unused *imx_add_imx_sdma(char *name,
-	resource_size_t iobase, int irq, struct sdma_platform_data *pdata)
+#ifdef CONFIG_SOC_IMX53
+struct imx_imx_sdma_data imx53_imx_sdma_data __initconst =
+	imx_imx_sdma_data_entry_single(MX53, 2, "imx53", 1);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX6Q
+struct imx_imx_sdma_data imx6q_imx_sdma_data __initconst =
+	imx_imx_sdma_data_entry_single(MX6Q, 2, "imx6q", 1);
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+static struct platform_device __init __maybe_unused *imx_add_imx_sdma(
+		const struct imx_imx_sdma_data *data)
 {
 	struct resource res[] = {
 		{
-			.start = iobase,
-			.end = iobase + SZ_16K - 1,
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
 			.flags = IORESOURCE_MEM,
 		}, {
-			.start = irq,
-			.end = irq,
+			.start = data->irq,
+			.end = data->irq,
 			.flags = IORESOURCE_IRQ,
 		},
 	};
 
-	return platform_device_register_resndata(&mxc_ahb_bus, name,
-			-1, res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+	return imx_add_platform_device("imx-sdma", -1,
+			res, ARRAY_SIZE(res),
+			&data->pdata, sizeof(data->pdata));
+}
+
+static struct platform_device __init __maybe_unused *imx_add_imx_dma(void)
+{
+	return imx_add_platform_device("imx-dma", -1, NULL, 0, NULL, 0);
+}
+
+#ifdef CONFIG_SOC_IMX25
+static struct sdma_script_start_addrs addr_imx25_to1 = {
+	.ap_2_ap_addr = 729,
+	.uart_2_mcu_addr = 904,
+	.per_2_app_addr = 1255,
+	.mcu_2_app_addr = 834,
+	.uartsh_2_mcu_addr = 1120,
+	.per_2_shp_addr = 1329,
+	.mcu_2_shp_addr = 1048,
+	.ata_2_mcu_addr = 1560,
+	.mcu_2_ata_addr = 1479,
+	.app_2_per_addr = 1189,
+	.app_2_mcu_addr = 770,
+	.shp_2_per_addr = 1407,
+	.shp_2_mcu_addr = 979,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX31
+static struct sdma_script_start_addrs addr_imx31_to1 = {
+	.per_2_per_addr = 1677,
+};
+
+static struct sdma_script_start_addrs addr_imx31_to2 = {
+	.ap_2_ap_addr = 423,
+	.ap_2_bp_addr = 829,
+	.bp_2_ap_addr = 1029,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX35
+static struct sdma_script_start_addrs addr_imx35_to1 = {
+	.ap_2_ap_addr = 642,
+	.uart_2_mcu_addr = 817,
+	.mcu_2_app_addr = 747,
+	.uartsh_2_mcu_addr = 1183,
+	.per_2_shp_addr = 1033,
+	.mcu_2_shp_addr = 961,
+	.ata_2_mcu_addr = 1333,
+	.mcu_2_ata_addr = 1252,
+	.app_2_mcu_addr = 683,
+	.shp_2_per_addr = 1111,
+	.shp_2_mcu_addr = 892,
+};
+
+static struct sdma_script_start_addrs addr_imx35_to2 = {
+	.ap_2_ap_addr = 729,
+	.uart_2_mcu_addr = 904,
+	.per_2_app_addr = 1597,
+	.mcu_2_app_addr = 834,
+	.uartsh_2_mcu_addr = 1270,
+	.per_2_shp_addr = 1120,
+	.mcu_2_shp_addr = 1048,
+	.ata_2_mcu_addr = 1429,
+	.mcu_2_ata_addr = 1339,
+	.app_2_per_addr = 1531,
+	.app_2_mcu_addr = 770,
+	.shp_2_per_addr = 1198,
+	.shp_2_mcu_addr = 979,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX51
+static struct sdma_script_start_addrs addr_imx51_to3 = {
+	.ap_2_ap_addr = 642,
+	.uart_2_mcu_addr = 817,
+	.mcu_2_app_addr = 747,
+	.mcu_2_shp_addr = 961,
+	.ata_2_mcu_addr = 1473,
+	.mcu_2_ata_addr = 1392,
+	.app_2_per_addr = 1033,
+	.app_2_mcu_addr = 683,
+	.shp_2_per_addr = 1251,
+	.shp_2_mcu_addr = 892,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+static struct sdma_script_start_addrs addr_imx53_to1 = {
+	.ap_2_ap_addr = 642,
+	.uart_2_mcu_addr = 817,
+	.mcu_2_app_addr = 747,
+	.per_2_per_addr = 6331,
+	.uartsh_2_mcu_addr = 1032,
+	.mcu_2_shp_addr = 960,
+	.app_2_mcu_addr = 683,
+	.shp_2_mcu_addr = 891,
+	.spdif_2_mcu_addr = 1100,
+	.mcu_2_spdif_addr = 1134,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+static struct sdma_script_start_addrs addr_imx6q_to1 = {
+	.ap_2_ap_addr = 642,
+	.uart_2_mcu_addr = 817,
+	.mcu_2_app_addr = 747,
+	.per_2_per_addr = 6331,
+	.uartsh_2_mcu_addr = 1032,
+	.mcu_2_shp_addr = 960,
+	.app_2_mcu_addr = 683,
+	.shp_2_mcu_addr = 891,
+	.spdif_2_mcu_addr = 1100,
+	.mcu_2_spdif_addr = 1134,
+	.mcu_2_ssish_addr = 6242,
+	.ssish_2_mcu_addr = 6678,
+};
+#endif
+
+static int __init imxXX_add_imx_dma(void)
+{
+	struct platform_device *ret;
+
+#if defined(CONFIG_SOC_IMX21) || defined(CONFIG_SOC_IMX27)
+	if (cpu_is_mx21() || cpu_is_mx27())
+		ret = imx_add_imx_dma();
+	else
+#endif
+
+#if defined(CONFIG_SOC_IMX25)
+	if (cpu_is_mx25()) {
+		imx25_imx_sdma_data.pdata.script_addrs = &addr_imx25_to1;
+		ret = imx_add_imx_sdma(&imx25_imx_sdma_data);
+	} else
+#endif
+
+#if defined(CONFIG_SOC_IMX31)
+	if (cpu_is_mx31()) {
+		int to_version = mx31_revision() >> 4;
+		imx31_imx_sdma_data.pdata.to_version = to_version;
+		if (to_version == 1)
+			imx31_imx_sdma_data.pdata.script_addrs =
+							&addr_imx31_to1;
+		else
+			imx31_imx_sdma_data.pdata.script_addrs =
+							&addr_imx31_to2;
+		ret = imx_add_imx_sdma(&imx31_imx_sdma_data);
+	} else
+#endif
+
+#if defined(CONFIG_SOC_IMX35)
+	if (cpu_is_mx35()) {
+		int to_version = mx35_revision() >> 4;
+		imx35_imx_sdma_data.pdata.to_version = to_version;
+		if (to_version == 1)
+			imx35_imx_sdma_data.pdata.script_addrs =
+							&addr_imx35_to1;
+		else
+			imx35_imx_sdma_data.pdata.script_addrs =
+							&addr_imx35_to2;
+		ret = imx_add_imx_sdma(&imx35_imx_sdma_data);
+	} else
+#endif
+
+#if defined(CONFIG_SOC_IMX51)
+	if (cpu_is_mx51()) {
+		int to_version = mx51_revision() >> 4;
+		imx51_imx_sdma_data.pdata.to_version = to_version;
+		if (to_version == 3)
+			imx51_imx_sdma_data.pdata.script_addrs =
+							&addr_imx51_to3;
+		ret = imx_add_imx_sdma(&imx51_imx_sdma_data);
+	} else
+#endif
+#if defined(CONFIG_SOC_IMX53)
+	if (cpu_is_mx53()) {
+		int to_version = 1;
+		imx53_imx_sdma_data.pdata.to_version = to_version;
+		if (to_version == 1)
+			imx53_imx_sdma_data.pdata.script_addrs =
+							&addr_imx53_to1;
+		ret = imx_add_imx_sdma(&imx53_imx_sdma_data);
+	} else
+#endif
+#if defined(CONFIG_ARCH_MX6)
+	int to_version = 1;
+	imx6q_imx_sdma_data.pdata.to_version = to_version;
+	if (to_version == 1)
+		imx6q_imx_sdma_data.pdata.script_addrs =
+						&addr_imx6q_to1;
+	ret = imx_add_imx_sdma(&imx6q_imx_sdma_data);
+	if (IS_ERR(ret))
+		return PTR_ERR(ret);
+
+	return 0;
+#endif
+		ret = ERR_PTR(-ENODEV);
+
+	if (IS_ERR(ret))
+		return PTR_ERR(ret);
+
+	return 0;
 }
+arch_initcall(imxXX_add_imx_dma);
diff --git a/arch/arm/plat-mxc/devices/platform-imx-elcdif-fb.c b/arch/arm/plat-mxc/devices/platform-imx-elcdif-fb.c
new file mode 100644
index 0000000..6aa4654
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-elcdif-fb.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <linux/dma-mapping.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_elcdif_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _ELCDIF_BASE_ADDR,			\
+		.irq = soc ## _INT_ELCDIF,				\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_elcdif_data imx6dl_elcdif_data __initconst =
+			imx_elcdif_data_entry_single(MX6DL, SZ_16K);
+#endif
+
+struct platform_device *__init imx_add_imx_elcdif(
+		const struct imx_elcdif_data *data,
+		const struct mxc_fb_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxc_elcdif_fb", -1,
+		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
new file mode 100644
index 0000000..1f9c221
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_epdc_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _EPDC_BASE_ADDR,			\
+		.irq = soc ## _INT_EPDC,				\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_epdc_data imx50_epdc_data __initconst =
+			imx_epdc_data_entry_single(MX50, SZ_4K);
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_epdc_data imx6dl_epdc_data __initconst =
+			imx_epdc_data_entry_single(MX6DL, SZ_16K);
+#endif
+
+struct platform_device *__init imx_add_imx_epdc(
+		const struct imx_epdc_data *data,
+		const struct imx_epdc_fb_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	if (!fuse_dev_is_available(MXC_DEV_EPDC))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("imx_epdc_fb", -1,
+		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-fsl-csi.c b/arch/arm/plat-mxc/devices/platform-imx-fsl-csi.c
new file mode 100644
index 0000000..8b6601c
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-fsl-csi.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_fsl_csi_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _CSI_BASE_ADDR,			\
+		.irq = soc ## _INT_CSI,					\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_fsl_csi_data imx6sl_csi_data __initconst =
+			imx_fsl_csi_data_entry_single(MX6SL, SZ_16K);
+#endif
+
+struct platform_device *__init imx_add_fsl_csi(
+		const struct imx_fsl_csi_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("fsl_csi", -1,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx-gpmi-nfc.c b/arch/arm/plat-mxc/devices/platform-imx-gpmi-nfc.c
new file mode 100644
index 0000000..a1e297d
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-gpmi-nfc.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/mtd/gpmi-nand.h>
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#ifdef CONFIG_SOC_IMX50
+struct platform_device *__init
+imx_add_gpmi(const struct gpmi_nfc_platform_data *platform_data)
+{
+	struct resource res[] = {
+	{ /* GPMI */
+		 .name  = GPMI_NFC_GPMI_REGS_ADDR_RES_NAME,
+		 .flags = IORESOURCE_MEM,
+		 .start = MX50_GPMI_BASE_ADDR,
+		 .end   = MX50_GPMI_BASE_ADDR + SZ_8K - 1,
+	}, {
+		 .name  = GPMI_NFC_GPMI_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start = MX50_INT_RAWNAND_GPMI,
+		 .end   = MX50_INT_RAWNAND_GPMI,
+	}, { /* BCH */
+		 .name  = GPMI_NFC_BCH_REGS_ADDR_RES_NAME,
+		 .flags = IORESOURCE_MEM,
+		 .start = MX50_BCH_BASE_ADDR,
+		 .end   = MX50_BCH_BASE_ADDR + SZ_8K - 1,
+	}, {
+		 .name  = GPMI_NFC_BCH_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start = MX50_INT_RAWNAND_BCH,
+		 .end   = MX50_INT_RAWNAND_BCH,
+	}, { /* DMA */
+		 .name  = GPMI_NFC_DMA_CHANNELS_RES_NAME,
+		 .flags = IORESOURCE_DMA,
+		 .start	= MX50_DMA_CHANNEL_AHB_APBH_GPMI0,
+		 .end	= MX50_DMA_CHANNEL_AHB_APBH_GPMI7,
+	}, {
+		 .name  = GPMI_NFC_DMA_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start = MX50_INT_APBHDMA_CHAN0,
+		 .end   = MX50_INT_APBHDMA_CHAN7,
+	}, };
+
+	return imx_add_platform_device_dmamask("imx50-gpmi-nfc", 0,
+			res, ARRAY_SIZE(res), platform_data,
+			sizeof(*platform_data), DMA_BIT_MASK(32));
+}
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
+#ifdef CONFIG_SOC_IMX6Q
+struct platform_device *__init
+imx_add_gpmi(const struct gpmi_nand_platform_data *platform_data)
+{
+	struct resource res[] = {
+	{ /* GPMI */
+		 .name  = GPMI_NAND_GPMI_REGS_ADDR_RES_NAME,
+		 .flags = IORESOURCE_MEM,
+		 .start = MX6Q_GPMI_BASE_ADDR,
+		 .end   = MX6Q_GPMI_BASE_ADDR + SZ_8K - 1,
+	}, {
+		 .name  = GPMI_NAND_GPMI_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start	= MXC_INT_RAWNAND_GPMI,
+		 .end	= MXC_INT_RAWNAND_GPMI,
+	}, { /* BCH */
+		 .name  = GPMI_NAND_BCH_REGS_ADDR_RES_NAME,
+		 .flags = IORESOURCE_MEM,
+		 .start = MX6Q_BCH_BASE_ADDR,
+		 .end   = MX6Q_BCH_BASE_ADDR + SZ_8K - 1,
+	}, {
+		 .name  = GPMI_NAND_BCH_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start	= MXC_INT_RAWNAND_BCH,
+		 .end	= MXC_INT_RAWNAND_BCH,
+	}, { /* DMA */
+		 .name  = GPMI_NAND_DMA_CHANNELS_RES_NAME,
+		 .flags = IORESOURCE_DMA,
+		 .start	= MX6Q_DMA_CHANNEL_AHB_APBH_GPMI0,
+		 .end	= MX6Q_DMA_CHANNEL_AHB_APBH_GPMI7,
+	}, {
+		 .name  = GPMI_NAND_DMA_INTERRUPT_RES_NAME,
+		 .flags = IORESOURCE_IRQ,
+		 .start	= MXC_INT_APBHDMA_DMA,
+		 .end	= MXC_INT_APBHDMA_DMA,
+	}, };
+
+	return imx_add_platform_device_dmamask("imx6q-gpmi-nand", 0,
+			res, ARRAY_SIZE(res), platform_data,
+			sizeof(*platform_data), DMA_BIT_MASK(32));
+}
+#endif
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
index 813f954..26f4ae7 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -42,6 +42,9 @@ struct platform_device *__init imx_add_hdmi_soc_dai(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-hdmi-soc-dai", 0,
 				res, ARRAY_SIZE(res), NULL, 0);
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
index bd0b8ad..a2277b2 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,6 +23,10 @@
 
 struct platform_device *__init imx_add_hdmi_soc(void)
 {
+
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("mxc_hdmi_soc", 0,
 				       NULL, 0, NULL, 0);
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-iim.c b/arch/arm/plat-mxc/devices/platform-imx-iim.c
new file mode 100644
index 0000000..74043de
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-iim.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_iim_data_entry_single(soc)				\
+	{							\
+		.iobase = soc ## _IIM_BASE_ADDR,		\
+		.irq = soc ## _INT_IIM,				\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_iim_data imx51_imx_iim_data __initconst =
+			imx5_iim_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_iim_data imx53_imx_iim_data __initconst =
+			imx5_iim_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_iim(
+		const struct imx_iim_data *data,
+		const struct mxc_iim_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_16 - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_iim", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx-keypad.c b/arch/arm/plat-mxc/devices/platform-imx-keypad.c
index 479c3e9..6fbfa05 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-keypad.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-keypad.c
@@ -51,6 +51,11 @@ const struct imx_imx_keypad_data imx53_imx_keypad_data __initconst =
 	imx_imx_keypad_data_entry_single(MX53, SZ_16);
 #endif /* ifdef CONFIG_SOC_IMX53 */
 
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_imx_keypad_data imx6sl_imx_keypad_data __initconst =
+	imx_imx_keypad_data_entry_single(MX6SL, SZ_16);
+#endif /* ifdef CONFIG_SOC_IMX6SL */
+
 struct platform_device *__init imx_add_imx_keypad(
 		const struct imx_imx_keypad_data *data,
 		const struct matrix_keymap_data *pdata)
diff --git a/arch/arm/plat-mxc/devices/platform-imx-mipi_dsi.c b/arch/arm/plat-mxc/devices/platform-imx-mipi_dsi.c
new file mode 100644
index 0000000..136a8fc
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-mipi_dsi.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_mipi_dsi_data_entry_single(soc, _id, _hwid, size)		\
+	{								\
+		.id = _id,						\
+		.iobase = soc ## _MIPI_DSI ## _hwid ## _BASE_ADDR,	\
+		.iosize = size,						\
+		.irq	= soc ## _INT_DSI ## _hwid,			\
+	}
+
+#define imx_mipi_dsi_data_entry(soc, _id, _hwid, _size)			\
+	[_id] = imx_mipi_dsi_data_entry_single(soc, _id, _hwid, _size)
+
+#ifdef CONFIG_SOC_IMX6Q
+#define SOC_IOMUXC_BASE_ADDR MX6Q_IOMUXC_BASE_ADDR
+const struct imx_mipi_dsi_data imx6q_mipi_dsi_data __initconst =
+			imx_mipi_dsi_data_entry_single(MX6Q, 0, , SZ_4K);
+#endif
+
+struct platform_device *__init imx_add_mipi_dsi(
+		const struct imx_mipi_dsi_data *data,
+		const struct mipi_dsi_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = SOC_IOMUXC_BASE_ADDR,
+			.end = SOC_IOMUXC_BASE_ADDR + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_mipi_dsi", -1,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pcie.c b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
index cf36093..7e0d630 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pcie.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,6 +55,9 @@ struct platform_device *__init imx_add_pcie(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_PCIE))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-pcie", -1,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata));
diff --git a/arch/arm/plat-mxc/devices/platform-imx-perfmon.c b/arch/arm/plat-mxc/devices/platform-imx-perfmon.c
new file mode 100644
index 0000000..b7a79ca
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-perfmon.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/fsl_devices.h>
+#include <mach/iomux-v3.h>
+
+#ifdef CONFIG_SOC_IMX50
+static struct mxs_perfmon_bit_config
+mx50_perfmon_bit_config[] = {
+	{.field = (1 << 0),	.name = "MID0-CORE" },
+	{.field = (1 << 1),	.name = "MID1-DCP" },
+	{.field = (1 << 2),	.name = "MID2-PXP" },
+	{.field = (1 << 3),	.name = "MID3-USB" },
+	{.field = (1 << 4),	.name = "MID4-GPU2D" },
+	{.field = (1 << 5),	.name = "MID5-BCH" },
+	{.field = (1 << 6),	.name = "MID6-AHB" },
+	{.field = (1 << 7),	.name = "MID7-EPDC" },
+	{.field = (1 << 8),	.name = "MID8-LCDIF" },
+	{.field = (1 << 9),	.name = "MID9-SDMA" },
+	{.field = (1 << 10),	.name = "MID10-FEC" },
+	{.field = (1 << 11),	.name = "MID11-MSHC" }
+};
+
+struct mxs_platform_perfmon_data mxc_perfmon_data = {
+	.bit_config_tab = mx50_perfmon_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx50_perfmon_bit_config),
+};
+
+
+const struct imx_perfmon_data imx50_perfmon_data = {
+	.iobase = MX50_PERFMON_BASE_ADDR,
+	.pdata = &mxc_perfmon_data,
+};
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+static struct mxs_perfmon_bit_config
+mx6q_perfmon1_bit_config[] = {
+	{.field = (1 << 0),	.name = "MID0-GPU_3D" },
+	{.field = (1 << 1),	.name = "MID1-GPU_2D" },
+	{.field = (1 << 2),	.name = "MID2-VDOA" },
+	{.field = (1 << 3),	.name = "MID3-Unused" },
+	{.field = (1 << 4),	.name = "MID4-OPENVG" }
+};
+
+static struct mxs_perfmon_bit_config
+mx6q_perfmon2_bit_config[] = {
+	{.field = (1 << 0),	.name = "MID0-IPU1.ld00" },
+	{.field = (1 << 1),	.name = "MID1-IPU1.ld01" },
+	{.field = (1 << 2),	.name = "MID2-IPU1.ld10" },
+	{.field = (1 << 3),	.name = "MID3-IPU1.ld11" }
+};
+
+static struct mxs_perfmon_bit_config
+mx6q_perfmon3_bit_config[] = {
+	{.field = (1 << 0),	.name = "MID0-CORES" },
+	{.field = (1 << 1),	.name = "MID1-L2-BUF" },
+	{.field = (1 << 2),	.name = "MID2-Unused" },
+	{.field = (1 << 3),	.name = "MID3-L2-EVIC" },
+	{.field = (1 << 4),	.name = "MID4-Unused" }
+};
+
+static int init;
+
+static void platform_perfmon_init(void)
+{
+	if (init)
+		return;
+
+	if (mx6q_revision() == IMX_CHIP_REVISION_1_0 || cpu_is_mx6dl())
+		/* GPR11 bit[16] must be set for TO1.0(6q & 6dl), it's a bug */
+		mxc_iomux_set_gpr_register(11, 16, 1, 1);
+
+	mxc_iomux_set_gpr_register(11, 0, 1, 1);
+	init = true;
+}
+
+static void platform_perfmon_exit(void)
+{
+	if (!init)
+		return;
+
+	mxc_iomux_set_gpr_register(11, 0, 1, 0);
+	init = false;
+}
+
+struct mxs_platform_perfmon_data mxc_perfmon_data1 = {
+	.bit_config_tab = mx6q_perfmon1_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx6q_perfmon1_bit_config),
+	.plt_init = platform_perfmon_init,
+	.plt_exit = platform_perfmon_exit,
+};
+
+struct mxs_platform_perfmon_data mxc_perfmon_data2 = {
+	.bit_config_tab = mx6q_perfmon2_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx6q_perfmon2_bit_config),
+	.plt_init = platform_perfmon_init,
+};
+
+struct mxs_platform_perfmon_data mxc_perfmon_data3 = {
+	.bit_config_tab = mx6q_perfmon3_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx6q_perfmon3_bit_config),
+	.plt_init = platform_perfmon_init,
+};
+
+const struct imx_perfmon_data imx6q_perfmon_data[3] = {
+	{
+		.iobase = IP2APB_PERFMON1_BASE_ADDR,
+		.pdata = &mxc_perfmon_data1,
+	},
+	{
+		.iobase = IP2APB_PERFMON2_BASE_ADDR,
+		.pdata = &mxc_perfmon_data2,
+	},
+	{
+		.iobase = IP2APB_PERFMON3_BASE_ADDR,
+		.pdata = &mxc_perfmon_data3,
+	}
+};
+#endif
+
+struct platform_device *__init imx_add_perfmon(
+		const struct imx_perfmon_data *data)
+{
+	static int id;
+
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}
+	};
+
+	return imx_add_platform_device("mxs-perfmon", id++,
+			res, ARRAY_SIZE(res), data->pdata,
+			sizeof(struct mxs_platform_perfmon_data));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pm.c b/arch/arm/plat-mxc/devices/platform-imx-pm.c
index f901e18..5b865ad 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pm.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,6 +30,11 @@ const struct imx_pm_imx_data imx6q_pm_imx_data[] __initconst =
 	imx_pm_imx_data_entry_single(MX6Q);
 #endif
 
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_pm_imx_data imx6sl_pm_imx_data[] __initconst =
+	imx_pm_imx_data_entry_single(MX6SL);
+#endif
+
 struct platform_device *__init imx_add_pm_imx(
 		const struct imx_pm_imx_data *data,
 		const struct pm_platform_data *pdata)
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pmu.c b/arch/arm/plat-mxc/devices/platform-imx-pmu.c
index 7c5b897..cf29415 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pmu.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pmu.c
@@ -23,21 +23,6 @@
 #include <mach/devices-common.h>
 #include <asm/pmu.h>
 
-static struct resource mx53_pmu_resources[] = {
-	[0] = {
-		.start	= MX53_INT_PMU,
-		.end	= MX53_INT_PMU,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device mx53_pmu_device = {
-	.name		= "arm-pmu",
-	.id		= ARM_PMU_DEVICE_CPU,
-	.num_resources	= ARRAY_SIZE(mx53_pmu_resources),
-	.resource	= mx53_pmu_resources,
-};
-
 static struct resource mx6_pmu_resources[] = {
 	[0] = {
 		.start	= MXC_INT_CHEETAH_PERFORM,
@@ -55,8 +40,5 @@ struct platform_device mx6_pmu_device = {
 
 void __init imx_add_imx_armpmu()
 {
-	if (cpu_is_mx6())
-		platform_device_register(&mx6_pmu_device);
-	else if (cpu_is_mx53())
-		platform_device_register(&mx53_pmu_device);
+	platform_device_register(&mx6_pmu_device);
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pxp.c b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
new file mode 100644
index 0000000..fed58d0
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_pxp_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _EPXP_BASE_ADDR,			\
+		.irq = soc ## _INT_EPXP,				\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_pxp_data imx50_pxp_data __initconst =
+			imx_pxp_data_entry_single(MX50, SZ_4K);
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_pxp_data imx6dl_pxp_data __initconst =
+			imx_pxp_data_entry_single(MX6DL, SZ_16K);
+#endif
+
+struct platform_device *__init imx_add_imx_pxp(
+		const struct imx_pxp_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("imx-pxp", -1,
+		res, ARRAY_SIZE(res), NULL, 0, DMA_BIT_MASK(32));
+}
+
+struct platform_device *__init imx_add_imx_pxp_client()
+{
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("imx-pxp-client", -1,
+		NULL, 0, NULL, 0);
+}
+
+struct platform_device *__init imx_add_imx_pxp_v4l2()
+{
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("pxp-v4l2", -1,
+		NULL, 0, NULL, 0, DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-rngb.c b/arch/arm/plat-mxc/devices/platform-imx-rngb.c
new file mode 100644
index 0000000..9a0a652
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-rngb.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_rngb_data_entry_single(soc)	\
+{						\
+	.iobase = soc ## _RNGB_BASE_ADDR,	\
+	.irq = soc ## _INT_RNGB,		\
+}
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_rngb_data imx50_rngb_data __initconst =
+	imx_rngb_data_entry_single(MX50);
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_rngb_data imx6sl_rngb_data __initconst =
+	imx_rngb_data_entry_single(MX6SL);
+#endif /* ifdef CONFIG_SOC_IMX6SL */
+
+struct platform_device *__init imx_add_rngb(
+		const struct imx_rngb_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("fsl_rngc", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-scc2.c b/arch/arm/plat-mxc/devices/platform-imx-scc2.c
new file mode 100644
index 0000000..10e03b66
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-scc2.c
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/mxc_scc2_driver.h>
+#include <linux/delay.h>
+
+#define imx_scc2_data_entry_single(soc)	\
+{						\
+	.iobase = soc ## _SCC_BASE_ADDR,	\
+	.ram_start = soc ## _SCC_RAM_BASE_ADDR,	\
+	.irq_smn = soc ## _INT_SCC_SMN,		\
+	.irq_scm = soc ## _INT_SCC_SCM,		\
+}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_mxc_scc2_data imx51_mxc_scc2_data __initconst =
+	imx_scc2_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_mxc_scc2_data imx53_mxc_scc2_data __initconst =
+	imx_scc2_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+#define SCM_RD_DELAY	1000000 /* in nanoseconds */
+#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
+static __init void mxc_init_scc_iram(struct resource res[])
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint8_t *UMID_base;
+	uint32_t *MAP_base;
+	uint8_t i;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint32_t ram_partitions, ram_partition_size, ram_size;
+	uint32_t scm_version_register;
+	struct timespec stime;
+	struct timespec curtime;
+	long scm_rd_timeout = 0;
+	long cur_ns = 0;
+	long start_ns = 0;
+
+	scc_base = ioremap((uint32_t) res[0].start, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC REGS\n");
+		return;
+	}
+
+	scm_version_register = __raw_readl(scc_base + SCM_VERSION_REG);
+	ram_partitions = 1 + ((scm_version_register & SCM_VER_NP_MASK)
+		>> SCM_VER_NP_SHIFT);
+	ram_partition_size = (uint32_t) (1 <<
+		((scm_version_register & SCM_VER_BPP_MASK)
+		>> SCM_VER_BPP_SHIFT));
+
+	ram_size = (uint32_t)(ram_partitions * ram_partition_size);
+
+	scm_ram_base = ioremap((uint32_t) res[1].start, ram_size);
+
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC RAM\n");
+		return;
+	}
+
+	/* Wait for any running SCC operations to finish or fail */
+	getnstimeofday(&stime);
+	do {
+		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec > stime.tv_nsec)
+			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
+		else{
+			/*Converted second to nanosecond and add to
+			nsec when current nanosec is less than
+			start time nanosec.*/
+			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+			curtime.tv_nsec;
+			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+				stime.tv_nsec;
+			scm_rd_timeout = cur_ns - start_ns;
+		}
+	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
+
+	/* Check for failures */
+	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
+		/* Special message for bad secret key fuses */
+		if (reg_value & SCM_STATUS_KST_BAD_KEY)
+			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
+		else
+		    printk(KERN_ERR "SECURE RAM FAILURE\n");
+
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	scm_rd_timeout = 0;
+
+#ifdef CONFIG_ARCH_MX5
+	/* Release all partitions for SCC2 driver on MX53*/
+	if (cpu_is_mx53())
+		scc_partno = 0;
+	/* Release final two partitions for SCC2 driver on MX51 */
+	else
+		scc_partno = ram_partitions -
+			(MX51_SCC_RAM_SIZE / ram_partition_size);
+#else
+	scc_partno = 0;
+#endif
+
+
+	for (partition_no = scc_partno; partition_no < ram_partitions;
+	     partition_no++) {
+		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
+			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
+			SCM_ZCMD_CCMD_MASK));
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		udelay(1);
+		/* Wait for zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else {
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+	}
+
+	/* 4 partitions on MX53 */
+	if (cpu_is_mx53())
+		reg_mask = 0xFF;
+
+	/*Check all expected partitions released */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != 0) {
+		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	/* we are done if this is MX53, since no sharing of IRAM and SCC_RAM */
+	if (cpu_is_mx53())
+		goto exit;
+
+	reg_mask = 0;
+	scm_rd_timeout = 0;
+	/* Allocate remaining partitions for general use */
+	for (partition_no = 0; partition_no < scc_partno; partition_no++) {
+		/* Supervisor mode claims a partition for it's own use
+		by writing zero to SMID register.*/
+		__raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
+
+		/* Wait for any zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else{
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+		/* Set UMID=0 and permissions for universal data
+		read/write access */
+		MAP_base = scm_ram_base +
+			(uint32_t) (partition_no * ram_partition_size);
+		UMID_base = (uint8_t *) MAP_base + 0x10;
+		for (i = 0; i < 16; i++)
+			UMID_base[i] = 0;
+
+		MAP_base[0] = (SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
+			SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
+			SCM_PERM_HD_EXECUTE | SCM_PERM_TH_READ |
+			SCM_PERM_TH_WRITE);
+		reg_mask |= (3 << (2 * (partition_no)));
+	}
+
+	/* Check all expected partitions allocated */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != reg_mask) {
+		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+exit:
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+}
+
+
+struct platform_device *__init imx_add_mxc_scc2(
+		const struct imx_mxc_scc2_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->ram_start,
+			.end = data->ram_start + SZ_128K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq_smn,
+			.end = data->irq_smn,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.start = data->irq_scm,
+			.end = data->irq_scm,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	mxc_init_scc_iram(res);
+
+	return imx_add_platform_device("mxc_scc", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-spdc-fb.c b/arch/arm/plat-mxc/devices/platform-imx-spdc-fb.c
new file mode 100644
index 0000000..72010e2
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-spdc-fb.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_spdc_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _SIPIX_BASE_ADDR,			\
+		.irq = soc ## _INT_SPDC,				\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_epdc_data imx6sl_spdc_data __initconst =
+			imx_spdc_data_entry_single(MX6SL, SZ_16K);
+#endif
+
+struct platform_device *__init imx_add_imx_spdc(
+		const struct imx_epdc_data *data,
+		const struct imx_spdc_fb_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("imx_spdc_fb", -1,
+		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx-ssi.c b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
index 3676d82..6e62967 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-ssi.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Pengutronix
+ * Copyright (C) 2010-2012 Pengutronix
  * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or modify it under
@@ -69,7 +69,7 @@ const struct imx_imx_ssi_data imx35_imx_ssi_data[] __initconst = {
 #ifdef CONFIG_SOC_IMX51
 const struct imx_imx_ssi_data imx51_imx_ssi_data[] __initconst = {
 #define imx51_imx_ssi_data_entry(_id, _hwid)				\
-	imx_imx_ssi_data_entry(MX51, _id, _hwid, SZ_16K)
+	imx_imx_ssi_data_entry(MX51, _id, _hwid, SZ_4K)
 	imx51_imx_ssi_data_entry(0, 1),
 	imx51_imx_ssi_data_entry(1, 2),
 	imx51_imx_ssi_data_entry(2, 3),
@@ -79,7 +79,7 @@ const struct imx_imx_ssi_data imx51_imx_ssi_data[] __initconst = {
 #ifdef CONFIG_SOC_IMX53
 const struct imx_imx_ssi_data imx53_imx_ssi_data[] __initconst = {
 #define imx53_imx_ssi_data_entry(_id, _hwid)				\
-	imx_imx_ssi_data_entry(MX53, _id, _hwid, SZ_16K)
+	imx_imx_ssi_data_entry(MX53, _id, _hwid, SZ_4K)
 	imx53_imx_ssi_data_entry(0, 1),
 	imx53_imx_ssi_data_entry(1, 2),
 	imx53_imx_ssi_data_entry(2, 3),
diff --git a/arch/arm/plat-mxc/devices/platform-imx-uart.c b/arch/arm/plat-mxc/devices/platform-imx-uart.c
index fd158a8..e76b026 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-uart.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-uart.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2010 Pengutronix
+ * Copyright (C) 2009-2012 Pengutronix
  * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or modify it under
@@ -123,8 +123,6 @@ const struct imx_imx_uart_1irq_data imx53_imx_uart_data[] __initconst = {
 	imx53_imx_uart_data_entry(0, 1),
 	imx53_imx_uart_data_entry(1, 2),
 	imx53_imx_uart_data_entry(2, 3),
-	imx53_imx_uart_data_entry(3, 4),
-	imx53_imx_uart_data_entry(4, 5),
 };
 #endif /* ifdef CONFIG_SOC_IMX53 */
 
@@ -136,9 +134,22 @@ const struct imx_imx_uart_1irq_data imx6q_imx_uart_data[] __initconst = {
 	imx6q_imx_uart_data_entry(1, 2),
 	imx6q_imx_uart_data_entry(2, 3),
 	imx6q_imx_uart_data_entry(3, 4),
+	imx6q_imx_uart_data_entry(4, 5),
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_imx_uart_1irq_data imx6sl_imx_uart_data[] __initconst = {
+#define imx6sl_imx_uart_data_entry(_id, _hwid)				\
+	imx_imx_uart_1irq_data_entry(MX6SL, _id, _hwid, SZ_4K)
+	imx6sl_imx_uart_data_entry(0, 1),
+	imx6sl_imx_uart_data_entry(1, 2),
+	imx6sl_imx_uart_data_entry(2, 3),
+	imx6sl_imx_uart_data_entry(3, 4),
+	imx6sl_imx_uart_data_entry(4, 5),
+};
+#endif /* ifdef CONFIG_SOC_IMX6SL */
+
 struct platform_device *__init imx_add_imx_uart_3irq(
 		const struct imx_imx_uart_3irq_data *data,
 		const struct imxuart_platform_data *pdata)
@@ -163,7 +174,7 @@ struct platform_device *__init imx_add_imx_uart_3irq(
 		},
 	};
 
-	return imx_add_platform_device("imx1-uart", data->id, res,
+	return imx_add_platform_device("imx-uart", data->id, res,
 			ARRAY_SIZE(res), pdata, sizeof(*pdata));
 }
 
@@ -183,7 +194,6 @@ struct platform_device *__init imx_add_imx_uart_1irq(
 		},
 	};
 
-	/* i.mx21 type uart runs on all i.mx except i.mx1 */
-	return imx_add_platform_device("imx21-uart", data->id,
-			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+	return imx_add_platform_device("imx-uart", data->id, res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-vdoa.c b/arch/arm/plat-mxc/devices/platform-imx-vdoa.c
new file mode 100644
index 0000000..057fda6
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-vdoa.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_vdoa_data_entry_single(soc, _id, _hwid, size)		\
+	{								\
+		.id = _id,						\
+		.iobase = soc ## _VDOA ## _hwid ## _BASE_ADDR,	\
+		.iosize = size,						\
+		.irq	= soc ## _INT_VDOA ## _hwid,			\
+	}
+
+#define imx_vdoa_data_entry(soc, _id, _hwid, _size)			\
+	[_id] = imx_vdoa_data_entry_single(soc, _id, _hwid, _size)
+
+#ifdef CONFIG_SOC_IMX6Q
+#define MX6Q_VDOA_BASE_ADDR VDOA_BASE_ADDR
+#define SOC_VDOA_BASE_ADDR MX6Q_VDOA_BASE_ADDR
+#define MX6Q_INT_VDOA MXC_INT_VDOA
+const struct imx_vdoa_data imx6q_vdoa_data __initconst =
+			imx_vdoa_data_entry_single(MX6Q, 0, , SZ_4K);
+#endif
+
+struct platform_device *__init imx_add_vdoa(
+		const struct imx_vdoa_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_vdoa", -1,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-viim.c b/arch/arm/plat-mxc/devices/platform-imx-viim.c
new file mode 100644
index 0000000..8ac3d81
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-viim.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/fsl_devices.h>
+
+#ifdef CONFIG_SOC_IMX51
+#define GPT_REG_BASE_ADDR (MX50_GPT1_BASE_ADDR)
+const struct imx_viim_data imx50_viim_data = {
+	.iobase = MX50_OCOTP_CTRL_BASE_ADDR,
+};
+#endif
+
+#if defined(CONFIG_SOC_IMX6Q) || defined(CONFIG_SOC_IMX6SL)
+#define GPT_REG_BASE_ADDR (GPT_BASE_ADDR)
+const struct imx_viim_data imx6q_viim_data = {
+	.iobase = OCOTP_BASE_ADDR,
+};
+#endif
+
+struct platform_device *__init imx_add_viim(
+		const struct imx_viim_data *data)
+{
+	struct resource res[] = {
+		[0] = {
+			.start = GPT_REG_BASE_ADDR,
+			.end   = GPT_REG_BASE_ADDR + PAGE_SIZE - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start  = data->iobase,
+			.end    = data->iobase + PAGE_SIZE - 1,
+			.flags  = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device("mxs_viim", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx2-wdt.c b/arch/arm/plat-mxc/devices/platform-imx2-wdt.c
index 872515a..53cfb8d 100644
--- a/arch/arm/plat-mxc/devices/platform-imx2-wdt.c
+++ b/arch/arm/plat-mxc/devices/platform-imx2-wdt.c
@@ -15,6 +15,7 @@
 		.id = _id,						\
 		.iobase = soc ## _WDOG ## _hwid ## _BASE_ADDR,		\
 		.iosize = _size,					\
+		.irq = soc ## _INT_WDOG ## _hwid,			\
 	}
 #define imx_imx2_wdt_data_entry(soc, _id, _hwid, _size)			\
 	[_id] = imx_imx2_wdt_data_entry_single(soc, _id, _hwid, _size)
@@ -79,6 +80,10 @@ struct platform_device *__init imx_add_imx2_wdt(
 			.start = data->iobase,
 			.end = data->iobase + data->iosize - 1,
 			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
 		},
 	};
 	return imx_add_platform_device("imx2-wdt", data->id,
diff --git a/arch/arm/plat-mxc/devices/platform-imx_dvfs.c b/arch/arm/plat-mxc/devices/platform-imx_dvfs.c
old mode 100755
new mode 100644
diff --git a/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c b/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
new file mode 100644
index 0000000..c5b4d99
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/clk.h>
+
+#define imx5_ipuv3_data_entry_single(soc, size, ipu_init, ipu_pg)	\
+	{								\
+		.iobase = soc ## _IPU_CTRL_BASE_ADDR,			\
+		.irq_err = soc ## _INT_IPU_ERR,				\
+		.irq = soc ## _INT_IPU_SYN,				\
+		.irq_start = MXC_IPU_IRQ_START, 			\
+		.iosize = size,						\
+		.init = ipu_init,					\
+		.pg = ipu_pg,						\
+	}
+
+#define imx6_ipuv3_data_entry_single(soc, id, size, ipu_init, ipu_pg)	\
+	{								\
+		.iobase = soc ## _IPU ## id ## _ARB_BASE_ADDR,			\
+		.irq_err = soc ## _INT_IPU ## id ## _ERR,			\
+		.irq = soc ## _INT_IPU ## id ## _SYN,				\
+		.irq_start = MXC_IPU_IRQ_START, 			\
+		.iosize = size,						\
+		.init = ipu_init,					\
+		.pg = ipu_pg,						\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+/*
+ * The MIPI HSC unit has been removed from the i.MX51 Reference Manual by
+ * the Freescale marketing division. However this did not remove the
+ * hardware from the chip which still needs to be configured...
+ */
+static int __init ipu_mipi_setup(void)
+{
+	struct clk *hsc_clk;
+	void __iomem *hsc_addr;
+	int ret = 0;
+
+	hsc_addr = ioremap(MX51_MIPI_HSC_BASE_ADDR, PAGE_SIZE);
+	if (!hsc_addr)
+		return -ENOMEM;
+
+	hsc_clk = clk_get_sys(NULL, "mipi_hsp");
+	if (IS_ERR(hsc_clk)) {
+		ret = PTR_ERR(hsc_clk);
+		goto unmap;
+	}
+	clk_enable(hsc_clk);
+
+	/* setup MIPI module to legacy mode */
+	writel(0xF00, hsc_addr);
+
+	/* CSI mode: reserved; DI control mode: legacy (from Freescale BSP) */
+	writel(readl(hsc_addr + 0x800) | 0x30ff,
+			hsc_addr + 0x800);
+
+	clk_disable(hsc_clk);
+	clk_put(hsc_clk);
+unmap:
+	iounmap(hsc_addr);
+
+	return ret;
+}
+
+int __init mx51_ipuv3_init(int id)
+{
+	int ret = 0;
+	u32 val;
+
+	ret = ipu_mipi_setup();
+
+	/* hard reset the IPU */
+	val = readl(MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+	val |= 1 << 3;
+	writel(val, MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+
+	return ret;
+}
+
+void mx51_ipuv3_pg(int enable)
+{
+	if (enable) {
+		writel(MXC_PGCR_PCR, MX51_PGC_IPU_PGCR);
+		writel(MXC_PGSR_PSR, MX51_PGC_IPU_PGSR);
+	} else {
+		writel(0x0, MX51_PGC_IPU_PGCR);
+		if (readl(MX51_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		writel(MXC_PGSR_PSR, MX51_PGC_IPU_PGSR);
+	}
+}
+
+const struct imx_ipuv3_data imx51_ipuv3_data __initconst =
+			imx5_ipuv3_data_entry_single(MX51, SZ_512M,
+					mx51_ipuv3_init, mx51_ipuv3_pg);
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+int __init mx53_ipuv3_init(int id)
+{
+	int ret = 0;
+	u32 val;
+
+	/* hard reset the IPU */
+	val = readl(MX53_IO_ADDRESS(MX53_SRC_BASE_ADDR));
+	val |= 1 << 3;
+	writel(val, MX53_IO_ADDRESS(MX53_SRC_BASE_ADDR));
+
+	return ret;
+}
+
+void mx53_ipuv3_pg(int enable)
+{
+	if (enable) {
+		writel(MXC_PGCR_PCR, MX53_PGC_IPU_PGCR);
+		writel(MXC_PGSR_PSR, MX53_PGC_IPU_PGSR);
+	} else {
+		writel(0x0, MX53_PGC_IPU_PGCR);
+		if (readl(MX53_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		writel(MXC_PGSR_PSR, MX53_PGC_IPU_PGSR);
+	}
+}
+
+const struct imx_ipuv3_data imx53_ipuv3_data __initconst =
+			imx5_ipuv3_data_entry_single(MX53, SZ_128M,
+					mx53_ipuv3_init, mx53_ipuv3_pg);
+#endif
+
+#ifdef CONFIG_SOC_IMX6Q
+int __init mx6q_ipuv3_init(int id)
+{
+	int ret = 0;
+	u32 val;
+
+	/* hard reset the IPU */
+	val = readl(MX6_IO_ADDRESS(SRC_BASE_ADDR));
+	if (id == 0)
+		val |= 1 << 3;
+	else
+		val |= 1 << 12;
+	writel(val, MX6_IO_ADDRESS(SRC_BASE_ADDR));
+
+	return ret;
+}
+
+void mx6q_ipuv3_pg(int enable)
+{
+	/*TODO*/
+}
+
+const struct imx_ipuv3_data imx6q_ipuv3_data[] __initconst = {
+	imx6_ipuv3_data_entry_single(MX6Q, 1, SZ_4M,
+			mx6q_ipuv3_init, mx6q_ipuv3_pg),
+	imx6_ipuv3_data_entry_single(MX6Q, 2, SZ_4M,
+			mx6q_ipuv3_init, mx6q_ipuv3_pg),
+};
+#endif
+
+struct platform_device *__init imx_add_ipuv3(
+		const int id,
+		const struct imx_ipuv3_data *data,
+		struct imx_ipuv3_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq_err,
+			.end = data->irq_err,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	pdata->init = data->init;
+	pdata->pg = data->pg;
+
+	return imx_add_platform_device_dmamask("imx-ipuv3", id,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata),
+			DMA_BIT_MASK(32));
+}
+
+struct platform_device *__init imx_add_ipuv3_fb(
+		const int id,
+		const struct ipuv3_fb_platform_data *pdata)
+{
+	if (pdata->res_size[0] > 0) {
+		struct resource res[] = {
+			{
+				.start = pdata->res_base[0],
+				.end = pdata->res_base[0] + pdata->res_size[0] - 1,
+				.flags = IORESOURCE_MEM,
+			}, {
+				.start = 0,
+				.end = 0,
+				.flags = IORESOURCE_MEM,
+			},
+		};
+
+		if (pdata->res_size[1] > 0) {
+			res[1].start = pdata->res_base[1];
+			res[1].end = pdata->res_base[1] +
+					pdata->res_size[1] - 1;
+		}
+
+		return imx_add_platform_device_dmamask("mxc_sdc_fb",
+				id, res, ARRAY_SIZE(res), pdata,
+				sizeof(*pdata), DMA_BIT_MASK(32));
+	} else
+		return imx_add_platform_device_dmamask("mxc_sdc_fb", id,
+				NULL, 0, pdata, sizeof(*pdata),
+				DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx_srtc.c b/arch/arm/plat-mxc/devices/platform-imx_srtc.c
new file mode 100644
index 0000000..9e4191e
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_srtc.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_imx_srtc_data_entry_single(soc)				\
+	{								\
+		.iobase = soc ## _SRTC_BASE_ADDR,			\
+		.irq = soc ## _INT_SRTC_NTZ,				\
+	}
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_srtc_data imx50_imx_srtc_data __initconst =
+	imx_imx_srtc_data_entry_single(MX50);
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_srtc_data imx51_imx_srtc_data __initconst =
+	imx_imx_srtc_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_srtc_data imx53_imx_srtc_data __initconst =
+	imx_imx_srtc_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_srtc(
+		const struct imx_srtc_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_16K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_rtc", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx_tve.c b/arch/arm/plat-mxc/devices/platform-imx_tve.c
new file mode 100644
index 0000000..6dc23d5
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_tve.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Jason Chen <jason.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_tve_data_entry_single(soc)				\
+	{							\
+		.iobase = soc ## _TVE_BASE_ADDR,		\
+		.irq = soc ## _INT_TVE,				\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_tve_data imx51_tve_data __initconst =
+			imx5_tve_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_tve_data imx53_tve_data __initconst =
+			imx5_tve_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_tve(
+		const struct imx_tve_data *data,
+		const struct fsl_mxc_tve_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_tve", -1,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx_vpu.c b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
index 2dae732..890d436 100644
--- a/arch/arm/plat-mxc/devices/platform-imx_vpu.c
+++ b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  * Jason Chen <jason.chen@freescale.com>
  *
  * This program is free software; you can redistribute it and/or modify it under
@@ -167,6 +167,9 @@ struct platform_device *__init imx_add_vpu(
 	pdata.iram_enable = data->iram_enable;
 	pdata.iram_size = data->iram_size;
 
+	if (!fuse_dev_is_available(MXC_DEV_VPU))
+		return ERR_PTR(-ENODEV);
+
 	if (cpu_is_mx6dl())
 		pdata.iram_enable = false;
 
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
index f10d07e..984fa29 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
@@ -9,7 +9,6 @@
 #include <linux/dma-mapping.h>
 #include <mach/hardware.h>
 #include <mach/devices-common.h>
-
 #define imx_mxc_ehci_data_entry_single(soc, _id, hs)			\
 	{								\
 		.id = _id,						\
@@ -49,21 +48,6 @@ const struct imx_mxc_ehci_data imx35_mxc_ehci_hs_data __initconst =
 	imx_mxc_ehci_data_entry_single(MX35, 1, HS);
 #endif /* ifdef CONFIG_SOC_IMX35 */
 
-#ifdef CONFIG_SOC_IMX51
-const struct imx_mxc_ehci_data imx51_mxc_ehci_otg_data __initconst =
-	imx_mxc_ehci_data_entry_single(MX51, 0, OTG);
-const struct imx_mxc_ehci_data imx51_mxc_ehci_hs_data[] __initconst = {
-	imx_mxc_ehci_data_entry_single(MX51, 1, HS1),
-	imx_mxc_ehci_data_entry_single(MX51, 2, HS2),
-};
-#endif /* ifdef CONFIG_SOC_IMX51 */
-
-#ifdef CONFIG_SOC_IMX53
-const struct imx_mxc_ehci_data imx53_mxc_ehci_hs_data[] __initconst = {
-	imx_mxc_ehci_data_entry_single(MX53, 1, H1),
-};
-#endif /* ifdef CONFIG_SOC_IMX53 */
-
 #ifdef CONFIG_SOC_IMX6Q
 const struct imx_mxc_ehci_data imx6q_mxc_ehci_otg_data __initconst =
 	imx_mxc_ehci_data_entry_single(MX6Q, 0, OTG);
@@ -72,6 +56,12 @@ const struct imx_mxc_ehci_data imx6q_mxc_ehci_hs_data[] __initconst = {
 	imx_mxc_ehci_data_entry_single(MX6Q, 2, HS2),
 	imx_mxc_ehci_data_entry_single(MX6Q, 3, HS3),
 };
+
+const struct imx_mxc_ehci_data imx6sl_mxc_ehci_hs_data[] __initconst = {
+	imx_mxc_ehci_data_entry_single(MX6SL, 1, HS1),
+	imx_mxc_ehci_data_entry_single(MX6SL, 2, HS2),
+	imx_mxc_ehci_data_entry_single(MX6SL, 3, HS3),
+};
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
 struct platform_device *__init imx_add_mxc_ehci(
@@ -93,6 +83,7 @@ struct platform_device *__init imx_add_mxc_ehci(
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
+EXPORT_SYMBOL(imx_add_mxc_ehci);
 
 /* FSL internal non-upstream code */
 struct platform_device *__init imx_add_fsl_ehci(
@@ -110,7 +101,52 @@ struct platform_device *__init imx_add_fsl_ehci(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-ehci", data->id,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+	int ret = -ENOMEM;
+	const char *name = "fsl-ehci";
+	int id = data->id;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+    if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
+
 }
+EXPORT_SYMBOL(imx_add_fsl_ehci);
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
index e0c1906..2c9a32a 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,6 +45,9 @@ struct platform_device *__init imx_add_mxc_hdmi_core(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("mxc_hdmi_core", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_gpu.c b/arch/arm/plat-mxc/devices/platform-mxc_gpu.c
new file mode 100644
index 0000000..06ac156
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-mxc_gpu.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_mxc_gpu_entry_3d_2d(soc)					\
+	{								\
+		.irq_3d = soc ## _INT_GPU,				\
+		.irq_2d = soc ## _INT_GPU2_IRQ,				\
+		.iobase_3d = soc ## _GPU_BASE_ADDR,			\
+		.iobase_2d = soc ## _GPU2D_BASE_ADDR,			\
+		.gmem_base = soc ## _GPU_GMEM_BASE_ADDR,		\
+		.gmem_size = soc ## _GPU_GMEM_SIZE,			\
+	}
+
+#define imx_mxc_gpu_entry_2d(soc)					\
+	{								\
+		.irq_2d = soc ## _INT_GPU2_IRQ,				\
+		.iobase_2d = soc ## _GPU2D_BASE_ADDR,			\
+	}
+
+#ifdef CONFIG_SOC_IMX35
+const struct imx_mxc_gpu_data imx35_gpu_data __initconst =
+	imx_mxc_gpu_entry_2d(MX35);
+#endif
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_mxc_gpu_data imx50_gpu_data __initconst =
+	imx_mxc_gpu_entry_2d(MX50);
+#endif
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_mxc_gpu_data imx51_gpu_data __initconst =
+	imx_mxc_gpu_entry_3d_2d(MX51);
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_mxc_gpu_data imx53_gpu_data __initconst =
+	imx_mxc_gpu_entry_3d_2d(MX53);
+#endif
+
+struct platform_device *__init imx_add_mxc_gpu(
+		const struct imx_mxc_gpu_data *data,
+		const struct mxc_gpu_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->irq_2d,
+			.end = data->irq_2d,
+			.name = "gpu_2d_irq",
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = data->irq_3d,
+			.end = data->irq_3d,
+			.name = "gpu_3d_irq",
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = data->iobase_2d,
+			.end = data->iobase_2d + SZ_4K - 1,
+			.name = "gpu_2d_registers",
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->iobase_3d,
+			.end = data->iobase_3d + SZ_128K - 1,
+			.name = "gpu_3d_registers",
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->gmem_base,
+			.end = data->gmem_base + data->gmem_size - 1,
+			.name = "gpu_graphics_mem",
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxc_gpu", 0,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
index 25cf313..f3ad3b4 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,6 +44,11 @@ struct platform_device *__init imx_add_mxc_hdmi(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
+	imx_add_platform_device("mxc_hdmi_cec", 0,
+				       res, ARRAY_SIZE(res), NULL, 0);
 	return imx_add_platform_device_dmamask("mxc_hdmi", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_mlb.c b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
new file mode 100644
index 0000000..8925f3e
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#ifdef CONFIG_SOC_IMX53
+struct platform_device *__init imx_add_mlb(
+		const struct mxc_mlb_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = MX53_MLB_BASE_ADDR,
+			.end = MX53_MLB_BASE_ADDR + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = MX53_INT_MLB,
+			.end = MX53_INT_MLB,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+	return imx_add_platform_device("mxc_mlb", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+#ifdef CONFIG_SOC_IMX6Q
+
+struct platform_device *__init imx_add_mlb(
+		const struct mxc_mlb_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = MLB_BASE_ADDR,
+			.end = MLB_BASE_ADDR + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = MXC_INT_MLB,
+			.end = MXC_INT_MLB,
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = MXC_INT_MLB_AHB0,
+			.end = MXC_INT_MLB_AHB0,
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = MXC_INT_MLB_AHB1,
+			.end = MXC_INT_MLB_AHB1,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	if (!fuse_dev_is_available(MXC_DEV_MLB))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("mxc_mlb150", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+#endif
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
index dffa1b7..a8521b9 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
@@ -49,6 +49,15 @@ const struct imx_mxc_pwm_data imx51_mxc_pwm_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX53
+const struct imx_mxc_pwm_data imx53_mxc_pwm_data[] __initconst = {
+#define imx53_mxc_pwm_data_entry(_id, _hwid)				\
+	imx_mxc_pwm_data_entry(MX53, _id, _hwid, SZ_16K)
+	imx53_mxc_pwm_data_entry(0, 1),
+	imx53_mxc_pwm_data_entry(1, 2),
+};
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
 #ifdef CONFIG_SOC_IMX6Q
 const struct imx_mxc_pwm_data imx6q_mxc_pwm_data[] __initconst = {
 #define imx6q_mxc_pwm_data_entry(_id, _hwid)				\
diff --git a/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c b/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
index 6a8b8d4..735ea8e 100644
--- a/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
+++ b/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
@@ -10,33 +10,31 @@
 #include <mach/devices-common.h>
 #include <mach/esdhc.h>
 
-#define imx_sdhci_esdhc_imx_data_entry_single(soc, _devid, _id, hwid) \
+#define imx_sdhci_esdhc_imx_data_entry_single(soc, _id, hwid) \
 	{								\
-		.devid = _devid,					\
 		.id = _id,						\
 		.iobase = soc ## _ESDHC ## hwid ## _BASE_ADDR,	\
 		.irq = soc ## _INT_ESDHC ## hwid,			\
 	}
 
-#define imx_sdhci_usdhc_imx_data_entry_single(soc, _devid, _id, hwid) \
+#define imx_sdhci_usdhc_imx_data_entry_single(soc, _id, hwid) \
 	{								\
-		.devid = _devid,					\
 		.id = _id,						\
 		.iobase = soc ## _USDHC ## hwid ## _BASE_ADDR,	\
 		.irq = soc ## _INT_USDHC ## hwid,			\
 	}
 
-#define imx_sdhci_esdhc_imx_data_entry(soc, devid, id, hwid)	\
-	[id] = imx_sdhci_esdhc_imx_data_entry_single(soc, devid, id, hwid)
+#define imx_sdhci_esdhc_imx_data_entry(soc, id, hwid)	\
+	[id] = imx_sdhci_esdhc_imx_data_entry_single(soc, id, hwid)
 
-#define imx_sdhci_usdhc_imx_data_entry(soc, devid, id, hwid)	\
-	[id] = imx_sdhci_usdhc_imx_data_entry_single(soc, devid, id, hwid)
+#define imx_sdhci_usdhc_imx_data_entry(soc, id, hwid)	\
+	[id] = imx_sdhci_usdhc_imx_data_entry_single(soc, id, hwid)
 
 #ifdef CONFIG_SOC_IMX25
 const struct imx_sdhci_esdhc_imx_data
 imx25_sdhci_esdhc_imx_data[] __initconst = {
 #define imx25_sdhci_esdhc_imx_data_entry(_id, _hwid)			\
-	imx_sdhci_esdhc_imx_data_entry(MX25, "sdhci-esdhc-imx25", _id, _hwid)
+	imx_sdhci_esdhc_imx_data_entry(MX25, _id, _hwid)
 	imx25_sdhci_esdhc_imx_data_entry(0, 1),
 	imx25_sdhci_esdhc_imx_data_entry(1, 2),
 };
@@ -46,18 +44,30 @@ imx25_sdhci_esdhc_imx_data[] __initconst = {
 const struct imx_sdhci_esdhc_imx_data
 imx35_sdhci_esdhc_imx_data[] __initconst = {
 #define imx35_sdhci_esdhc_imx_data_entry(_id, _hwid)			\
-	imx_sdhci_esdhc_imx_data_entry(MX35, "sdhci-esdhc-imx35", _id, _hwid)
+	imx_sdhci_esdhc_imx_data_entry(MX35, _id, _hwid)
 	imx35_sdhci_esdhc_imx_data_entry(0, 1),
 	imx35_sdhci_esdhc_imx_data_entry(1, 2),
 	imx35_sdhci_esdhc_imx_data_entry(2, 3),
 };
 #endif /* ifdef CONFIG_SOC_IMX35 */
 
+#ifdef CONFIG_SOC_IMX50
+const struct imx_sdhci_esdhc_imx_data
+imx50_sdhci_esdhc_imx_data[] __initconst = {
+#define imx50_sdhci_esdhc_imx_data_entry(_id, _hwid)			\
+	imx_sdhci_esdhc_imx_data_entry(MX50, _id, _hwid)
+	imx50_sdhci_esdhc_imx_data_entry(0, 1),
+	imx50_sdhci_esdhc_imx_data_entry(1, 2),
+	imx50_sdhci_esdhc_imx_data_entry(2, 3),
+	imx50_sdhci_esdhc_imx_data_entry(3, 4),
+};
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
 #ifdef CONFIG_SOC_IMX51
 const struct imx_sdhci_esdhc_imx_data
 imx51_sdhci_esdhc_imx_data[] __initconst = {
 #define imx51_sdhci_esdhc_imx_data_entry(_id, _hwid)			\
-	imx_sdhci_esdhc_imx_data_entry(MX51, "sdhci-esdhc-imx51", _id, _hwid)
+	imx_sdhci_esdhc_imx_data_entry(MX51, _id, _hwid)
 	imx51_sdhci_esdhc_imx_data_entry(0, 1),
 	imx51_sdhci_esdhc_imx_data_entry(1, 2),
 	imx51_sdhci_esdhc_imx_data_entry(2, 3),
@@ -69,7 +79,7 @@ imx51_sdhci_esdhc_imx_data[] __initconst = {
 const struct imx_sdhci_esdhc_imx_data
 imx53_sdhci_esdhc_imx_data[] __initconst = {
 #define imx53_sdhci_esdhc_imx_data_entry(_id, _hwid)			\
-	imx_sdhci_esdhc_imx_data_entry(MX53, "sdhci-esdhc-imx53", _id, _hwid)
+	imx_sdhci_esdhc_imx_data_entry(MX53, _id, _hwid)
 	imx53_sdhci_esdhc_imx_data_entry(0, 1),
 	imx53_sdhci_esdhc_imx_data_entry(1, 2),
 	imx53_sdhci_esdhc_imx_data_entry(2, 3),
@@ -81,7 +91,7 @@ imx53_sdhci_esdhc_imx_data[] __initconst = {
 const struct imx_sdhci_esdhc_imx_data
 imx6q_sdhci_usdhc_imx_data[] __initconst = {
 #define imx6q_sdhci_usdhc_imx_data_entry(_id, _hwid)			\
-	imx_sdhci_usdhc_imx_data_entry(MX6Q, "sdhci-usdhc-imx6q", _id, _hwid)
+	imx_sdhci_usdhc_imx_data_entry(MX6Q, _id, _hwid)
 	imx6q_sdhci_usdhc_imx_data_entry(0, 1),
 	imx6q_sdhci_usdhc_imx_data_entry(1, 2),
 	imx6q_sdhci_usdhc_imx_data_entry(2, 3),
@@ -89,11 +99,6 @@ imx6q_sdhci_usdhc_imx_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
-static const struct esdhc_platform_data default_esdhc_pdata __initconst = {
-	.wp_type = ESDHC_WP_NONE,
-	.cd_type = ESDHC_CD_NONE,
-};
-
 struct platform_device *__init imx_add_sdhci_esdhc_imx(
 		const struct imx_sdhci_esdhc_imx_data *data,
 		const struct esdhc_platform_data *pdata)
@@ -110,13 +115,6 @@ struct platform_device *__init imx_add_sdhci_esdhc_imx(
 		},
 	};
 
-	/*
-	 * If machine does not provide pdata, use the default one
-	 * which means no WP/CD support
-	 */
-	if (!pdata)
-		pdata = &default_esdhc_pdata;
-
-	return imx_add_platform_device(data->devid, data->id, res,
-			ARRAY_SIZE(res), pdata, sizeof(*pdata));
+	return imx_add_platform_device_dmamask("sdhci-usdhc-imx6q", data->id, res,
+			ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-viv_gpu.c b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
index dad9d5a..52c9b08 100644
--- a/arch/arm/plat-mxc/devices/platform-viv_gpu.c
+++ b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,7 +22,19 @@
 #include <mach/devices-common.h>
 
 #ifdef CONFIG_ARCH_MX6
+#ifdef CONFIG_SOC_IMX6SL
 const struct imx_viv_gpu_data imx6_gpu_data __initconst = {
+	.phys_baseaddr = MX6SL_MMDC0_ARB_BASE_ADDR,
+	.iobase_3d = 0,
+	.irq_3d = -1,
+	.iobase_2d = MX6SL_GPU_2D_ARB_BASE_ADDR,
+	.irq_2d = MXC_INT_GPU2D_IRQ,
+	.iobase_vg = OPENVG_ARB_BASE_ADDR,
+	.irq_vg = MXC_INT_OPENVG_XAQ2,
+};
+#else
+const struct imx_viv_gpu_data imx6_gpu_data __initconst = {
+	.phys_baseaddr = 0,
 	.iobase_3d = GPU_3D_ARB_BASE_ADDR,
 	.irq_3d = MXC_INT_GPU3D_IRQ,
 	.iobase_2d = GPU_2D_ARB_BASE_ADDR,
@@ -31,6 +43,7 @@ const struct imx_viv_gpu_data imx6_gpu_data __initconst = {
 	.irq_vg = MXC_INT_OPENVG_XAQ2,
 };
 #endif
+#endif
 
 struct platform_device *__init imx_add_viv_gpu(
 		const struct imx_viv_gpu_data *data,
@@ -39,6 +52,12 @@ struct platform_device *__init imx_add_viv_gpu(
 	u32 res_count = 0;
 	struct resource res[] = {
 		{
+			.name = "phys_baseaddr",
+			.start = data->phys_baseaddr,
+			.end = data->phys_baseaddr,
+			.flags = IORESOURCE_MEM,
+		}, {
+
 			.name = "iobase_3d",
 			.start = data->iobase_3d,
 			.end = data->iobase_3d + SZ_16K - 1,
@@ -71,13 +90,36 @@ struct platform_device *__init imx_add_viv_gpu(
 		},
 	};
 
-	if (cpu_is_mx6q())
-		res_count = ARRAY_SIZE(res);
-	else if (cpu_is_mx6dl())
-		/* No openVG on i.mx6 Solo/DL */
-		res_count = ARRAY_SIZE(res) - 2;
+	res_count = ARRAY_SIZE(res);
 	BUG_ON(!res_count);
 
+	if (!fuse_dev_is_available(MXC_DEV_3D)) {
+		res[1].start = 0;
+		res[1].end = 0;
+		res[2].start = -1;
+		res[2].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_2D)) {
+		res[3].start = 0;
+		res[3].end = 0;
+		res[4].start = -1;
+		res[4].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_OVG)) {
+		res[5].start = 0;
+		res[5].end = 0;
+		res[6].start = -1;
+		res[6].end = -1;
+	}
+
+	/* None GPU core exists */
+	if ((res[2].start == -1) &&
+			(res[4].start == -1) &&
+			(res[6].start == -1))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("galcore", 0,
 			res, res_count,
 			pdata, sizeof(*pdata),
diff --git a/arch/arm/plat-mxc/dvfs_core.c b/arch/arm/plat-mxc/dvfs_core.c
index 271bac3..3b4df91 100644
--- a/arch/arm/plat-mxc/dvfs_core.c
+++ b/arch/arm/plat-mxc/dvfs_core.c
@@ -153,6 +153,7 @@ extern int high_bus_freq_mode;
 extern int set_low_bus_freq(void);
 extern int set_high_bus_freq(int high_bus_speed);
 extern int low_freq_bus_used(void);
+extern struct mutex bus_freq_mutex;
 
 DEFINE_SPINLOCK(mxc_dvfs_core_lock);
 
@@ -426,7 +427,7 @@ static int set_cpu_freq(int op)
 {
 	int ret = 0;
 
-	if (cpu_is_mx6q() || cpu_is_mx6dl())
+	if (cpu_is_mx6())
 		ret = mx6_set_cpu_freq(op);
 	else
 		ret = mx5_set_cpu_freq(op);
@@ -475,7 +476,7 @@ static int start_dvfs(void)
 	/* GPCIRQ=1, select ARM IRQ */
 	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
 	/* ADU=1, select ARM domain */
-	if (!(cpu_is_mx6q() || cpu_is_mx6dl()))
+	if (!cpu_is_mx6())
 		reg |= MXC_GPCCNTR_ADU;
 	__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
 
@@ -508,7 +509,7 @@ static int start_dvfs(void)
 	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	/* Enable DVFS */
-	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+	if (cpu_is_mx6()) {
 		unsigned long cpu_wfi = 0;
 		int num_cpus = num_possible_cpus();
 		reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_EMAC);
@@ -602,8 +603,12 @@ static void dvfs_core_work_handler(struct work_struct *work)
 	if (fsvai == FSVAI_FREQ_DECREASE) {
 		if (curr_cpu <= cpu_op_tbl[cpu_op_nr - 1].cpu_rate) {
 			minf = 1;
-			if (low_bus_freq_mode)
+			mutex_lock(&bus_freq_mutex);
+			if (low_bus_freq_mode) {
+				mutex_unlock(&bus_freq_mutex);
 				goto END;
+			} else
+				mutex_unlock(&bus_freq_mutex);
 		} else {
 			/* freq down */
 			curr_op++;
@@ -620,6 +625,7 @@ static void dvfs_core_work_handler(struct work_struct *work)
 			maxf = 1;
 			goto END;
 		} else {
+			mutex_lock(&bus_freq_mutex);
 			if (!high_bus_freq_mode &&
 				dvfs_config_setpoint == (cpu_op_nr + 1)) {
 				/* bump up LP freq first. */
@@ -632,10 +638,12 @@ static void dvfs_core_work_handler(struct work_struct *work)
 				minf = 0;
 				dvfs_load_config(0);
 			}
+			mutex_unlock(&bus_freq_mutex);
 		}
 	}
 
 	low_freq_bus_ready = low_freq_bus_used();
+	mutex_lock(&bus_freq_mutex);
 	if ((curr_op == cpu_op_nr - 1) && (!low_bus_freq_mode)
 	    && (low_freq_bus_ready) && !bus_incr) {
 		if (!minf)
@@ -647,9 +655,13 @@ static void dvfs_core_work_handler(struct work_struct *work)
 			set_low_bus_freq();
 			dvfs_load_config(cpu_op_nr + 1);
 		}
+		mutex_unlock(&bus_freq_mutex);
 	} else {
-		if (!high_bus_freq_mode)
+		if (!high_bus_freq_mode) {
+			mutex_unlock(&bus_freq_mutex);
 			set_high_bus_freq(1);
+		} else
+			mutex_unlock(&bus_freq_mutex);
 		if (!bus_incr)
 			ret = set_cpu_freq(curr_op);
 		bus_incr = 0;
@@ -709,6 +721,9 @@ void stop_dvfs(void)
 	unsigned long flags;
 	u32 curr_cpu;
 	int cpu;
+#ifndef CONFIG_SMP
+	unsigned long old_loops_per_jiffy;
+#endif
 
 	if (dvfs_core_is_active) {
 
@@ -721,8 +736,12 @@ void stop_dvfs(void)
 				  + MXC_DVFSCORE_CNTR);
 
 		curr_op = 0;
-		if (!high_bus_freq_mode)
+		mutex_lock(&bus_freq_mutex);
+		if (!high_bus_freq_mode) {
+			mutex_unlock(&bus_freq_mutex);
 			set_high_bus_freq(1);
+		} else
+			mutex_unlock(&bus_freq_mutex);
 
 		curr_cpu = clk_get_rate(cpu_clk);
 		if (curr_cpu != cpu_op_tbl[curr_op].cpu_rate) {
@@ -735,7 +754,7 @@ void stop_dvfs(void)
 				dvfs_cpu_jiffies(per_cpu(cpu_data, cpu).loops_per_jiffy,
 					curr_cpu/1000, clk_get_rate(cpu_clk) / 1000);
 #else
-		u32 old_loops_per_jiffy = loops_per_jiffy;
+		old_loops_per_jiffy = loops_per_jiffy;
 
 		loops_per_jiffy =
 			dvfs_cpu_jiffies(old_loops_per_jiffy,
@@ -833,43 +852,6 @@ void dump_dvfs_core_regs()
 			__raw_readl(dvfs_data->membase
 				    + MXC_DVFSCORE_THRS + 0x40));
 }
-#if 0
-static ssize_t downthreshold_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downthr);
-}
-
-static ssize_t downthreshold_store(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t size)
-{
-	int ret = 0;
-	int val;
-	ret = sscanf(buf, "%u", &val);
-	dvfs_core_setpoint[0].downthr = val;
-
-	return size;
-}
-
-static ssize_t downcount_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downcnt);
-}
-
-static ssize_t downcount_store(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t size)
-{
-	int ret = 0;
-	int val;
-	ret = sscanf(buf, "%u", &val);
-	dvfs_core_setpoint[0].downcnt = val;
-
-	return size;
-}
-#endif
 
 static ssize_t dvfs_enable_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -946,7 +928,7 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 		printk(KERN_ERR "%s: failed to get cpu clock\n", __func__);
 		return PTR_ERR(cpu_clk);
 	}
-	if (!(cpu_is_mx6q() || cpu_is_mx6dl())) {
+	if (!cpu_is_mx6()) {
 		dvfs_clk = clk_get(NULL, dvfs_data->clk2_id);
 		if (IS_ERR(dvfs_clk)) {
 			printk(KERN_ERR "%s: failed to get dvfs clock\n", __func__);
diff --git a/arch/arm/plat-mxc/fuse.c b/arch/arm/plat-mxc/fuse.c
new file mode 100644
index 0000000..1238e76
--- /dev/null
+++ b/arch/arm/plat-mxc/fuse.c
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+
+#define HW_OCOTP_CFGn(n)	(0x00000410 + (n) * 0x10)
+
+/* Note: the names oder is the same as device enum order defined in mxc.h */
+static char *names[] = {
+	"pxp", "ovg", "dsi_csi2", "enet", "mlb",
+	"epdc", "hdmi", "pcie", "sata", "dtcp",
+	"2d", "3d", "vpu", "divx3", "rv",
+	"sorensen",
+};
+
+int fuse_dev_is_available(enum mxc_dev_type dev)
+{
+	u32 uninitialized_var(reg);
+	u32 uninitialized_var(mask);
+	int ret;
+
+	if (!cpu_is_mx6())
+		return 1;
+
+	/* mx6sl is still not supported */
+	if (cpu_is_mx6sl())
+		return 1;
+
+	switch (dev) {
+	case MXC_DEV_PXP:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x80000000;
+		}
+		break;
+	case MXC_DEV_OVG:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x40000000;
+		}
+		break;
+	case MXC_DEV_DSI_CSI2:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x10000000;
+		}
+		break;
+	case MXC_DEV_ENET:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x08000000;
+		}
+		break;
+	case MXC_DEV_MLB:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x04000000;
+		}
+		break;
+	case MXC_DEV_EPDC:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x02000000;
+		}
+		break;
+	case MXC_DEV_HDMI:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000080;
+		}
+		break;
+	case MXC_DEV_PCIE:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000040;
+		}
+		break;
+	case MXC_DEV_SATA:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000020;
+		}
+		break;
+	case MXC_DEV_DTCP:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000010;
+		}
+		break;
+	case MXC_DEV_2D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000008;
+		}
+		break;
+	case MXC_DEV_3D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000004;
+		}
+		break;
+	case MXC_DEV_VPU:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00008000;
+		}
+		break;
+	case MXC_DEV_DIVX3:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000400;
+		}
+		break;
+	case MXC_DEV_RV:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000200;
+		}
+		break;
+	case MXC_DEV_SORENSEN:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000100;
+		}
+		break;
+	default:
+		/* we treat the unkown device is avaiable by default */
+		return 1;
+	}
+
+	ret = readl(MX6_IO_ADDRESS(OCOTP_BASE_ADDR) + reg) & mask;
+	pr_debug("fuse_check: %s is %s\n", names[dev], ret ?
+					"unavailable" : "available");
+
+	return !ret;
+}
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
new file mode 100644
index 0000000..f9856f1
--- /dev/null
+++ b/arch/arm/plat-mxc/gpio.c
@@ -0,0 +1,372 @@
+/*
+ * MXC GPIO support. (c) 2008 Daniel Mack <daniel@caiaq.de>
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * Based on code from Freescale,
+ * Copyright (C) 2004-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <asm-generic/bug.h>
+#include <asm/mach/irq.h>
+
+static struct mxc_gpio_port *mxc_gpio_ports;
+static int gpio_table_size;
+
+#define cpu_is_mx1_mx2()	(cpu_is_mx1() || cpu_is_mx2())
+
+#define GPIO_DR		(cpu_is_mx1_mx2() ? 0x1c : 0x00)
+#define GPIO_GDIR	(cpu_is_mx1_mx2() ? 0x00 : 0x04)
+#define GPIO_PSR	(cpu_is_mx1_mx2() ? 0x24 : 0x08)
+#define GPIO_ICR1	(cpu_is_mx1_mx2() ? 0x28 : 0x0C)
+#define GPIO_ICR2	(cpu_is_mx1_mx2() ? 0x2C : 0x10)
+#define GPIO_IMR	(cpu_is_mx1_mx2() ? 0x30 : 0x14)
+#define GPIO_ISR	(cpu_is_mx1_mx2() ? 0x34 : 0x18)
+
+#define GPIO_INT_LOW_LEV	(cpu_is_mx1_mx2() ? 0x3 : 0x0)
+#define GPIO_INT_HIGH_LEV	(cpu_is_mx1_mx2() ? 0x2 : 0x1)
+#define GPIO_INT_RISE_EDGE	(cpu_is_mx1_mx2() ? 0x0 : 0x2)
+#define GPIO_INT_FALL_EDGE	(cpu_is_mx1_mx2() ? 0x1 : 0x3)
+#define GPIO_INT_NONE		0x4
+
+/* Note: This driver assumes 32 GPIOs are handled in one register */
+
+static void _clear_gpio_irqstatus(struct mxc_gpio_port *port, u32 index)
+{
+	__raw_writel(1 << index, port->base + GPIO_ISR);
+}
+
+static void _set_gpio_irqenable(struct mxc_gpio_port *port, u32 index,
+				int enable)
+{
+	u32 l;
+
+	l = __raw_readl(port->base + GPIO_IMR);
+	l = (l & (~(1 << index))) | (!!enable << index);
+	__raw_writel(l, port->base + GPIO_IMR);
+}
+
+static void gpio_ack_irq(struct irq_data *d)
+{
+	u32 gpio = irq_to_gpio(d->irq);
+	_clear_gpio_irqstatus(&mxc_gpio_ports[gpio / 32], gpio & 0x1f);
+}
+
+static void gpio_mask_irq(struct irq_data *d)
+{
+	u32 gpio = irq_to_gpio(d->irq);
+	_set_gpio_irqenable(&mxc_gpio_ports[gpio / 32], gpio & 0x1f, 0);
+}
+
+static void gpio_unmask_irq(struct irq_data *d)
+{
+	u32 gpio = irq_to_gpio(d->irq);
+	_set_gpio_irqenable(&mxc_gpio_ports[gpio / 32], gpio & 0x1f, 1);
+}
+
+static int mxc_gpio_get(struct gpio_chip *chip, unsigned offset);
+
+static int gpio_set_irq_type(struct irq_data *d, u32 type)
+{
+	u32 gpio = irq_to_gpio(d->irq);
+	struct mxc_gpio_port *port = &mxc_gpio_ports[gpio / 32];
+	u32 bit, val;
+	int edge;
+	void __iomem *reg = port->base;
+
+	port->both_edges &= ~(1 << (gpio & 31));
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		edge = GPIO_INT_RISE_EDGE;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		edge = GPIO_INT_FALL_EDGE;
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		val = mxc_gpio_get(&port->chip, gpio & 31);
+		if (val) {
+			edge = GPIO_INT_LOW_LEV;
+			pr_debug("mxc: set GPIO %d to low trigger\n", gpio);
+		} else {
+			edge = GPIO_INT_HIGH_LEV;
+			pr_debug("mxc: set GPIO %d to high trigger\n", gpio);
+		}
+		port->both_edges |= 1 << (gpio & 31);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		edge = GPIO_INT_LOW_LEV;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		edge = GPIO_INT_HIGH_LEV;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	reg += GPIO_ICR1 + ((gpio & 0x10) >> 2); /* lower or upper register */
+	bit = gpio & 0xf;
+	val = __raw_readl(reg) & ~(0x3 << (bit << 1));
+	__raw_writel(val | (edge << (bit << 1)), reg);
+	_clear_gpio_irqstatus(port, gpio & 0x1f);
+
+	return 0;
+}
+
+static void mxc_flip_edge(struct mxc_gpio_port *port, u32 gpio)
+{
+	void __iomem *reg = port->base;
+	u32 bit, val;
+	int edge;
+
+	reg += GPIO_ICR1 + ((gpio & 0x10) >> 2); /* lower or upper register */
+	bit = gpio & 0xf;
+	val = __raw_readl(reg);
+	edge = (val >> (bit << 1)) & 3;
+	val &= ~(0x3 << (bit << 1));
+	if (edge == GPIO_INT_HIGH_LEV) {
+		edge = GPIO_INT_LOW_LEV;
+		pr_debug("mxc: switch GPIO %d to low trigger\n", gpio);
+	} else if (edge == GPIO_INT_LOW_LEV) {
+		edge = GPIO_INT_HIGH_LEV;
+		pr_debug("mxc: switch GPIO %d to high trigger\n", gpio);
+	} else {
+		pr_err("mxc: invalid configuration for GPIO %d: %x\n",
+		       gpio, edge);
+		return;
+	}
+	__raw_writel(val | (edge << (bit << 1)), reg);
+}
+
+/* handle 32 interrupts in one status register */
+static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)
+{
+	u32 gpio_irq_no_base = port->virtual_irq_start;
+
+	while (irq_stat != 0) {
+		int irqoffset = fls(irq_stat) - 1;
+
+		if (port->both_edges & (1 << irqoffset))
+			mxc_flip_edge(port, irqoffset);
+
+		generic_handle_irq(gpio_irq_no_base + irqoffset);
+
+		irq_stat &= ~(1 << irqoffset);
+	}
+}
+
+/* MX1 and MX3 has one interrupt *per* gpio port */
+static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 irq_stat;
+	struct mxc_gpio_port *port = irq_get_handler_data(irq);
+	struct irq_chip *chip = irq_get_chip(irq);
+
+	chained_irq_enter(chip, desc);
+
+	irq_stat = __raw_readl(port->base + GPIO_ISR) &
+			__raw_readl(port->base + GPIO_IMR);
+
+	mxc_gpio_irq_handler(port, irq_stat);
+
+	chained_irq_exit(chip, desc);
+}
+
+/* MX2 has one interrupt *for all* gpio ports */
+static void mx2_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	int i;
+	u32 irq_msk, irq_stat;
+	struct mxc_gpio_port *port = irq_get_handler_data(irq);
+
+	/* walk through all interrupt status registers */
+	for (i = 0; i < gpio_table_size; i++) {
+		irq_msk = __raw_readl(port[i].base + GPIO_IMR);
+		if (!irq_msk)
+			continue;
+
+		irq_stat = __raw_readl(port[i].base + GPIO_ISR) & irq_msk;
+		if (irq_stat)
+			mxc_gpio_irq_handler(&port[i], irq_stat);
+	}
+}
+
+/*
+ * Set interrupt number "irq" in the GPIO as a wake-up source.
+ * While system is running, all registered GPIO interrupts need to have
+ * wake-up enabled. When system is suspended, only selected GPIO interrupts
+ * need to have wake-up enabled.
+ * @param  irq          interrupt source number
+ * @param  enable       enable as wake-up if equal to non-zero
+ * @return       This function returns 0 on success.
+ */
+static int gpio_set_wake_irq(struct irq_data *d, u32 enable)
+{
+	u32 gpio = irq_to_gpio(d->irq);
+	u32 gpio_idx = gpio & 0x1F;
+	struct mxc_gpio_port *port = &mxc_gpio_ports[gpio / 32];
+
+	if (enable) {
+		if (port->irq_high && (gpio_idx >= 16))
+			enable_irq_wake(port->irq_high);
+		else
+			enable_irq_wake(port->irq);
+	} else {
+		if (port->irq_high && (gpio_idx >= 16))
+			disable_irq_wake(port->irq_high);
+		else
+			disable_irq_wake(port->irq);
+	}
+
+	return 0;
+}
+
+static struct irq_chip gpio_irq_chip = {
+	.name = "GPIO",
+	.irq_ack = gpio_ack_irq,
+	.irq_mask = gpio_mask_irq,
+	.irq_unmask = gpio_unmask_irq,
+	.irq_set_type = gpio_set_irq_type,
+	.irq_set_wake = gpio_set_wake_irq,
+};
+
+static void _set_gpio_direction(struct gpio_chip *chip, unsigned offset,
+				int dir)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+	u32 l;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	l = __raw_readl(port->base + GPIO_GDIR);
+	if (dir)
+		l |= 1 << offset;
+	else
+		l &= ~(1 << offset);
+	__raw_writel(l, port->base + GPIO_GDIR);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void mxc_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+	void __iomem *reg = port->base + GPIO_DR;
+	u32 l;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	l = (__raw_readl(reg) & (~(1 << offset))) | (!!value << offset);
+	__raw_writel(l, reg);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int mxc_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+
+	return (__raw_readl(port->base + GPIO_PSR) >> offset) & 1;
+}
+
+static int mxc_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	_set_gpio_direction(chip, offset, 0);
+	return 0;
+}
+
+static int mxc_gpio_direction_output(struct gpio_chip *chip,
+				     unsigned offset, int value)
+{
+	mxc_gpio_set(chip, offset, value);
+	_set_gpio_direction(chip, offset, 1);
+	return 0;
+}
+
+/*
+ * This lock class tells lockdep that GPIO irqs are in a different
+ * category than their parents, so it won't report false recursion.
+ */
+static struct lock_class_key gpio_lock_class;
+
+int mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
+{
+	int i, j;
+	static bool initialed;
+
+	/* save for local usage */
+	mxc_gpio_ports = port;
+	gpio_table_size = cnt;
+
+	printk(KERN_INFO "MXC GPIO hardware\n");
+
+	for (i = 0; i < cnt; i++) {
+		/* disable the interrupt and clear the status */
+		__raw_writel(0, port[i].base + GPIO_IMR);
+		__raw_writel(~0, port[i].base + GPIO_ISR);
+		for (j = port[i].virtual_irq_start;
+			j < port[i].virtual_irq_start + 32; j++) {
+			irq_set_lockdep_class(j, &gpio_lock_class);
+			irq_set_chip_and_handler(j, &gpio_irq_chip,
+						 handle_level_irq);
+			set_irq_flags(j, IRQF_VALID);
+		}
+
+		/* register gpio chip */
+		port[i].chip.direction_input = mxc_gpio_direction_input;
+		port[i].chip.direction_output = mxc_gpio_direction_output;
+		port[i].chip.get = mxc_gpio_get;
+		port[i].chip.set = mxc_gpio_set;
+		port[i].chip.base = i * 32;
+		port[i].chip.ngpio = 32;
+
+		spin_lock_init(&port[i].lock);
+
+		if (!initialed)
+			/* its a serious configuration bug when it fails */
+			BUG_ON(gpiochip_add(&port[i].chip) < 0);
+
+		if (cpu_is_mx1() || cpu_is_mx3() || cpu_is_mx25() ||
+			cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx6q() ||
+			cpu_is_mx6dl() || cpu_is_mx6sl()) {
+			/* setup one handler for each entry */
+			irq_set_chained_handler(port[i].irq,
+						mx3_gpio_irq_handler);
+			irq_set_handler_data(port[i].irq, &port[i]);
+			if (port[i].irq_high) {
+				/* setup handler for GPIO 16 to 31 */
+				irq_set_chained_handler(port[i].irq_high,
+							mx3_gpio_irq_handler);
+				irq_set_handler_data(port[i].irq_high,
+						     &port[i]);
+			}
+		}
+	}
+	initialed = true;
+	if (cpu_is_mx2()) {
+		/* setup one handler for all GPIO interrupts */
+		irq_set_chained_handler(port[0].irq, mx2_gpio_irq_handler);
+		irq_set_handler_data(port[0].irq, port);
+	}
+
+	return 0;
+}
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index 0d7b163..00e9b4b 100644
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -246,6 +246,11 @@ extern void __iomem *imx_otg_base;
 #define PORTSC_PTS_SERIAL		(3 << 30)	/* serial */
 #define PORTSC_STS			(1 << 29)	/* serial xcvr select */
 #define PORTSC_PTW                      (1 << 28)       /* UTMI width */
+#define PORTSC_PORT_SPEED_FULL		(0x0<<26)
+#define PORTSC_PORT_SPEED_LOW		       (0x1<<26)
+#define PORTSC_PORT_SPEED_HIGH		(0x2<<26)
+#define PORTSC_PORT_SPEED_UNDEF		(0x3<<26)
+#define PORTSC_PORT_SPEED_MASK		(0x3<<26)
 #define PORTSC_HSIC_MODE                (1 << 25)       /* Only for HSIC */
 #define PORTSC_PHCD                     (1 << 23)       /* Low Power Suspend */
 #define PORTSC_WKDC			(1 << 21)	/* wakeup on discnt*/
diff --git a/arch/arm/plat-mxc/include/mach/audmux.h b/arch/arm/plat-mxc/include/mach/audmux.h
new file mode 100644
index 0000000..6fda788
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/audmux.h
@@ -0,0 +1,60 @@
+#ifndef __MACH_AUDMUX_H
+#define __MACH_AUDMUX_H
+
+#define MX27_AUDMUX_HPCR1_SSI0		0
+#define MX27_AUDMUX_HPCR2_SSI1		1
+#define MX27_AUDMUX_HPCR3_SSI_PINS_4	2
+#define MX27_AUDMUX_PPCR1_SSI_PINS_1	3
+#define MX27_AUDMUX_PPCR2_SSI_PINS_2	4
+#define MX27_AUDMUX_PPCR3_SSI_PINS_3	5
+
+#define MX31_AUDMUX_PORT1_SSI0		0
+#define MX31_AUDMUX_PORT2_SSI1		1
+#define MX31_AUDMUX_PORT3_SSI_PINS_3	2
+#define MX31_AUDMUX_PORT4_SSI_PINS_4	3
+#define MX31_AUDMUX_PORT5_SSI_PINS_5	4
+#define MX31_AUDMUX_PORT6_SSI_PINS_6	5
+
+#define MX51_AUDMUX_PORT1_SSI0		0
+#define MX51_AUDMUX_PORT2_SSI1		1
+#define MX51_AUDMUX_PORT3		2
+#define MX51_AUDMUX_PORT4		3
+#define MX51_AUDMUX_PORT5		4
+#define MX51_AUDMUX_PORT6		5
+#define MX51_AUDMUX_PORT7		6
+
+/* Register definitions for the i.MX21/27 Digital Audio Multiplexer */
+#define MXC_AUDMUX_V1_PCR_INMMASK(x)	((x) & 0xff)
+#define MXC_AUDMUX_V1_PCR_INMEN		(1 << 8)
+#define MXC_AUDMUX_V1_PCR_TXRXEN	(1 << 10)
+#define MXC_AUDMUX_V1_PCR_SYN		(1 << 12)
+#define MXC_AUDMUX_V1_PCR_RXDSEL(x)	(((x) & 0x7) << 13)
+#define MXC_AUDMUX_V1_PCR_RFCSEL(x)	(((x) & 0xf) << 20)
+#define MXC_AUDMUX_V1_PCR_RCLKDIR	(1 << 24)
+#define MXC_AUDMUX_V1_PCR_RFSDIR	(1 << 25)
+#define MXC_AUDMUX_V1_PCR_TFCSEL(x)	(((x) & 0xf) << 26)
+#define MXC_AUDMUX_V1_PCR_TCLKDIR	(1 << 30)
+#define MXC_AUDMUX_V1_PCR_TFSDIR	(1 << 31)
+
+/* Register definitions for the i.MX25/31/35/51 Digital Audio Multiplexer */
+#define MXC_AUDMUX_V2_PTCR_TFSDIR	(1 << 31)
+#define MXC_AUDMUX_V2_PTCR_TFSEL(x)	(((x) & 0xf) << 27)
+#define MXC_AUDMUX_V2_PTCR_TCLKDIR	(1 << 26)
+#define MXC_AUDMUX_V2_PTCR_TCSEL(x)	(((x) & 0xf) << 22)
+#define MXC_AUDMUX_V2_PTCR_RFSDIR	(1 << 21)
+#define MXC_AUDMUX_V2_PTCR_RFSEL(x)	(((x) & 0xf) << 17)
+#define MXC_AUDMUX_V2_PTCR_RCLKDIR	(1 << 16)
+#define MXC_AUDMUX_V2_PTCR_RCSEL(x)	(((x) & 0xf) << 12)
+#define MXC_AUDMUX_V2_PTCR_SYN		(1 << 11)
+
+#define MXC_AUDMUX_V2_PDCR_RXDSEL(x)	(((x) & 0x7) << 13)
+#define MXC_AUDMUX_V2_PDCR_TXRXEN	(1 << 12)
+#define MXC_AUDMUX_V2_PDCR_MODE(x)	(((x) & 0x3) << 8)
+#define MXC_AUDMUX_V2_PDCR_INMMASK(x)	((x) & 0xff)
+
+int mxc_audmux_v1_configure_port(unsigned int port, unsigned int pcr);
+
+int mxc_audmux_v2_configure_port(unsigned int port, unsigned int ptcr,
+		unsigned int pdcr);
+
+#endif /* __MACH_AUDMUX_H */
diff --git a/arch/arm/plat-mxc/include/mach/clkdev.h b/arch/arm/plat-mxc/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 052d8a1..9ff9e9e 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -11,6 +11,7 @@
 #ifndef __ASM_ARCH_MXC_COMMON_H__
 #define __ASM_ARCH_MXC_COMMON_H__
 
+struct fec_platform_data;
 struct platform_device;
 struct clk;
 enum mxc_cpu_pwr_mode;
@@ -58,7 +59,6 @@ extern void imx53_soc_init(void);
 extern void mx6_init_irq(void);
 extern void epit_timer_init(struct clk *timer_clk, void __iomem *base, int irq);
 extern void mxc_timer_init(struct clk *timer_clk, void __iomem *, int);
-extern unsigned long mx6_timer_rate(void);
 extern int mx1_clocks_init(unsigned long fref);
 extern int mx21_clocks_init(unsigned long lref, unsigned long fref);
 extern int mx25_clocks_init(void);
@@ -75,6 +75,8 @@ extern int mx53_clocks_init_dt(void);
 extern int mx6q_clocks_init(void);
 extern int mx6_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
+extern int mx6sl_clocks_init(unsigned long ckil, unsigned long osc,
+			unsigned long ckih1, unsigned long ckih2);
 extern struct platform_device *mxc_register_gpio(char *name, int id,
 	resource_size_t iobase, resource_size_t iosize, int irq, int irq_high);
 extern void mxc_set_cpu_type(unsigned int type);
@@ -88,9 +90,9 @@ enum mxc_cpu_pwr_mode {
 	WAIT_CLOCKED,		/* wfi only */
 	WAIT_UNCLOCKED,		/* WAIT */
 	WAIT_UNCLOCKED_POWER_OFF,	/* WAIT + SRPG */
-	STOP_POWER_ON,		/* just STOP */
-	STOP_POWER_OFF,		/* STOP + SRPG */
-	ARM_POWER_OFF,          /* STOP + SRPG + ARM power off */
+	STOP_XTAL_ON,		/* STOP + SRPG + XTAL_ON*/
+	STOP_POWER_OFF,		/* STOP + XTAL_OFF */
+	ARM_POWER_OFF,		/* STOP + SRPG + ARM power off */
 };
 
 enum mx3_cpu_pwr_mode {
@@ -152,6 +154,10 @@ extern int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode);
 extern void imx6q_clock_map_io(void);
 extern void early_console_setup(unsigned long base, struct clk *clk);
 extern int mxc_register_device(struct platform_device *pdev, void *data);
+extern void mx6_cpu_regulator_init(void);
+extern int mx6q_sabreauto_init_pfuze100(u32 int_gpio);
+extern int mx6q_sabresd_init_pfuze100(u32 int_gpio);
+extern void imx6_init_fec(struct fec_platform_data fec_data);
 
 #ifdef CONFIG_PM
 extern void imx6q_pm_init(void);
diff --git a/arch/arm/plat-mxc/include/mach/debug-macro.S b/arch/arm/plat-mxc/include/mach/debug-macro.S
index 761e45f..aba0044 100644
--- a/arch/arm/plat-mxc/include/mach/debug-macro.S
+++ b/arch/arm/plat-mxc/include/mach/debug-macro.S
@@ -24,13 +24,25 @@
 #define UART_PADDR	MX51_UART1_BASE_ADDR
 #elif defined (CONFIG_DEBUG_IMX50_IMX53_UART)
 #define UART_PADDR	MX53_UART1_BASE_ADDR
+#endif
+
+#ifdef CONFIG_ARCH_MX6Q
+#ifdef UART_PADDR
+#error "CONFIG_DEBUG_LL is incompatible with multiple archs"
+#endif
+
+#if defined (CONFIG_DEBUG_IMX6Q_UART1)
+#define UART_PADDR	MX6Q_UART1_BASE_ADDR
 #elif defined (CONFIG_DEBUG_IMX6Q_UART2)
 #define UART_PADDR	MX6Q_UART2_BASE_ADDR
 #elif defined (CONFIG_DEBUG_IMX6Q_UART4)
 #define UART_PADDR	MX6Q_UART4_BASE_ADDR
+#else
+#define UART_PADDR	MX6Q_UART4_BASE_ADDR
+#endif
 #endif
 
-#define UART_VADDR	IMX_IO_ADDRESS(UART_PADDR)
+#define UART_VADDR	(UART_PADDR) + 0xf2000000
 
 		.macro	addruart, rp, rv, tmp
 		ldr	\rp, =UART_PADDR	@ physical
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index 16c7489..d30b13d 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -6,6 +6,9 @@
  * the terms of the GNU General Public License version 2 as published by the
  * Free Software Foundation.
  */
+#ifndef __DEVICES_COMMON_H__
+#define __DEVICES_COMMON_H__
+
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 #include <linux/init.h>
@@ -97,6 +100,7 @@ struct imx_imx2_wdt_data {
 	int id;
 	resource_size_t iobase;
 	resource_size_t iosize;
+	resource_size_t irq;
 };
 struct platform_device *__init imx_add_imx2_wdt(
 		const struct imx_imx2_wdt_data *data);
@@ -178,6 +182,26 @@ struct platform_device *__init imx_add_fsl_usb2_wakeup(
 		const struct imx_fsl_usb2_wakeup_data *data,
 		const struct fsl_usb2_wakeup_platform_data *pdata);
 
+struct imx_vdoa_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_vdoa(
+		const struct imx_vdoa_data *data);
+
+#include <mach/mipi_dsi.h>
+struct imx_mipi_dsi_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_mipi_dsi(
+		const struct imx_mipi_dsi_data *data,
+		const struct mipi_dsi_platform_data *pdata);
+
 #include <mach/mipi_csi2.h>
 struct imx_mipi_csi2_data {
 	int id;
@@ -188,6 +212,15 @@ struct platform_device *__init imx_add_mipi_csi2(
 		const struct imx_mipi_csi2_data *data,
 		const struct mipi_csi2_platform_data *pdata);
 
+struct imx_dcp_data {
+	resource_size_t iobase;
+	resource_size_t irq1;
+	resource_size_t irq2;
+};
+
+struct platform_device *__init imx_add_dcp(
+		const struct imx_dcp_data *data);
+
 #include <mach/imx-uart.h>
 struct imx_imx_uart_3irq_data {
 	int id;
@@ -418,10 +451,6 @@ struct platform_device *__init imx_add_spi_imx(
 		const struct imx_spi_imx_data *data,
 		const struct spi_imx_master *pdata);
 
-struct platform_device *imx_add_imx_dma(void);
-struct platform_device *imx_add_imx_sdma(char *name,
-	resource_size_t iobase, int irq, struct sdma_platform_data *pdata);
-
 #include <linux/ahci_platform.h>
 struct imx_ahci_imx_data {
 	const char *devid;
@@ -434,6 +463,7 @@ struct platform_device *__init imx_add_ahci_imx(
 
 #include <mach/viv_gpu.h>
 struct imx_viv_gpu_data {
+	resource_size_t phys_baseaddr;
 	resource_size_t irq_3d;
 	resource_size_t iobase_3d;
 	resource_size_t irq_2d;
@@ -445,10 +475,33 @@ struct platform_device *__init imx_add_viv_gpu(
 		const struct imx_viv_gpu_data *data,
 		const struct viv_gpu_platform_data *pdata);
 
+#include <mach/mxc_gpu.h>
+struct imx_mxc_gpu_data {
+	resource_size_t irq_2d;
+	resource_size_t irq_3d;
+	resource_size_t iobase_2d;
+	resource_size_t iobase_3d;
+	resource_size_t gmem_base;
+	resource_size_t gmem_size;
+};
+
+struct platform_device *__init imx_add_mxc_gpu(
+		const struct imx_mxc_gpu_data *data,
+		const struct mxc_gpu_platform_data *pdata);
+
+struct imx_perfmon_data {
+	resource_size_t iobase;
+	struct mxs_platform_perfmon_data *pdata;
+};
+
+struct platform_device *__init imx_add_perfmon(
+		const struct imx_perfmon_data *data);
+
 #include <mach/anatop_thermal.h>
 struct imx_anatop_thermal_imx_data {
 	int id;
 	resource_size_t iobase;
+	resource_size_t calibration_addr;
 	resource_size_t irq;
 };
 struct platform_device *__init imx_add_anatop_thermal_imx(
@@ -506,6 +559,20 @@ struct imx_mxc_scc_data {
 struct platform_device *__init imx_add_mxc_scc(
 		const struct imx_mxc_scc_data *data);
 
+#include <mach/epdc.h>
+struct imx_epdc_data {
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_imx_epdc(
+		const struct imx_epdc_data *data,
+		const struct imx_epdc_fb_platform_data *pdata);
+
+struct platform_device *__init imx_add_imx_spdc(
+		const struct imx_epdc_data *data,
+		const struct imx_spdc_fb_platform_data *pdata);
+
 struct imx_spdif_data {
 	resource_size_t iobase;
 	resource_size_t irq;
@@ -565,3 +632,86 @@ struct imx_imx_esai_data {
 struct platform_device *__init imx_add_imx_esai(
 		const struct imx_imx_esai_data *data,
 		const struct imx_esai_platform_data *pdata);
+
+struct imx_caam_jr_data {
+	resource_size_t offset_jr;
+	resource_size_t irq_jr;
+};
+
+struct imx_caam_data {
+	resource_size_t iobase_caam;	/* entirety of CAAM register map */
+	resource_size_t iobase_caam_sm;	/* base of secure memory */
+	resource_size_t iobase_snvs;	/* base of SNVS */
+	resource_size_t irq_sec_vio;	/* SNVS security violation */
+	resource_size_t irq_snvs;	/* SNVS consolidated (incl. RTC) */
+	struct imx_caam_jr_data jr[4];	/* offset+IRQ for each possible ring */
+};
+
+struct platform_device *__init imx_add_caam(
+		const struct imx_caam_data *data);
+
+#include <linux/ahci_platform.h>
+struct imx_ahci_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_ahci(
+		const struct imx_ahci_data *data,
+		const struct ahci_platform_data *pdata);
+
+struct imx_viim_data {
+	resource_size_t iobase;
+};
+
+struct platform_device *__init imx_add_viim(
+		const struct imx_viim_data *data);
+
+struct imx_dma_res_data {
+	resource_size_t iobase;
+};
+struct platform_device *__init imx_add_dma(const struct imx_dma_res_data *data);
+struct imx_pxp_data {
+    resource_size_t iobase;
+    resource_size_t iosize;
+    resource_size_t irq;
+};
+struct platform_device *__init imx_add_imx_pxp(
+	const struct imx_pxp_data *data);
+struct platform_device *__init imx_add_imx_pxp_client(void);
+struct platform_device *__init imx_add_imx_pxp_v4l2(void);
+
+#include <linux/mtd/gpmi-nand.h>
+struct platform_device *__init imx_add_gpmi(
+		const struct gpmi_nand_platform_data *data);
+
+struct imx_rngb_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+
+struct platform_device *__init imx_add_rngb(
+		const struct imx_rngb_data *data);
+
+struct platform_device *__init imx_add_mlb(
+		const struct mxc_mlb_platform_data *pdata);
+
+struct imx_elcdif_data {
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq;
+};
+
+struct platform_device *__init imx_add_imx_elcdif(
+		const struct imx_elcdif_data *data,
+		const struct mxc_fb_platform_data *pdata);
+
+struct imx_fsl_csi_data {
+    resource_size_t iobase;
+    resource_size_t iosize;
+    resource_size_t irq;
+};
+
+struct platform_device *__init imx_add_fsl_csi(
+		const struct imx_fsl_csi_data *data);
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/dma.h b/arch/arm/plat-mxc/include/mach/dma.h
index 1b90803..af2edb8 100644
--- a/arch/arm/plat-mxc/include/mach/dma.h
+++ b/arch/arm/plat-mxc/include/mach/dma.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,6 +13,12 @@
 #include <linux/device.h>
 #include <linux/dmaengine.h>
 
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
 /*
  * This enumerates peripheral types. Used for SDMA.
  */
@@ -39,6 +45,7 @@ enum sdma_peripheral_type {
 	IMX_DMATYPE_IPU_MEMORY,	/* IPU Memory */
 	IMX_DMATYPE_ASRC,	/* ASRC */
 	IMX_DMATYPE_ESAI,	/* ESAI */
+	IMX_DMATYPE_HDMI,
 };
 
 enum imx_dma_prio {
@@ -49,8 +56,17 @@ enum imx_dma_prio {
 
 struct imx_dma_data {
 	int dma_request; /* DMA request line */
+	int dma_request_p2p;
 	enum sdma_peripheral_type peripheral_type;
 	int priority;
+	void *private;
+};
+
+struct imx_pcm_dma_params {
+	enum sdma_peripheral_type peripheral_type;
+	int dma;
+	unsigned long dma_addr;
+	int burstsize;
 };
 
 static inline int imx_dma_is_ipu(struct dma_chan *chan)
@@ -58,10 +74,33 @@ static inline int imx_dma_is_ipu(struct dma_chan *chan)
 	return !strcmp(dev_name(chan->device->dev), "ipu-core");
 }
 
+static inline int imx_dma_is_pxp(struct dma_chan *chan)
+{
+	return !strcmp(dev_name(chan->device->dev), "imx-pxp");
+}
+
 static inline int imx_dma_is_general_purpose(struct dma_chan *chan)
 {
-	return strstr(dev_name(chan->device->dev), "sdma") ||
+	return !strcmp(dev_name(chan->device->dev), "imx-sdma") ||
 		!strcmp(dev_name(chan->device->dev), "imx-dma");
 }
 
+struct mxs_dma_data {
+	int chan_irq;
+};
+
+#define MXS_DMA_F_APPEND	(1 << 0)
+#define MXS_DMA_F_WAIT4END	(1 << 1)
+static inline int mxs_dma_is_apbh(struct dma_chan *chan)
+{
+	return !strcmp(dev_name(chan->device->dev), "mxs-dma-apbh");
+}
+
+static inline int mxs_dma_is_apbx(struct dma_chan *chan)
+{
+	return !strcmp(dev_name(chan->device->dev), "mxs-dma-apbx");
+}
+
+void sdma_set_event_pending(struct dma_chan *chan);
+
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
new file mode 100755
index 0000000..560b056
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/dvfs_dptc_struct.h
+ *
+ * @brief MXC dvfs & dptc structure definitions file.
+ *
+ * @ingroup PM_MX27 PM_MX31 PM_MXC91321 PM_MXC91311
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+#define __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+
+#include <linux/semaphore.h>
+#include <mach/pm_api.h>
+
+/*!
+ * Number of entries in the DPTC log buffer
+ */
+#define LOG_ENTRIES 1024
+
+/*!
+ * Log buffer Structure.\n
+ * This structure records the DPTC changes. \n
+ * This structure can be read by the user using the proc file system DPTC read entry.
+ */
+typedef struct {
+	/*!
+	 * Index to the head of the log buffer
+	 */
+	int head;
+
+	/*!
+	 * Index to the tail of the log buffer
+	 */
+	int tail;
+
+	/*!
+	 * Mutex to allow access to the log buffer
+	 */
+	struct semaphore mutex;
+
+	/*!
+	 * Array of log buffer entries
+	 */
+	dptc_log_entry_s entries[LOG_ENTRIES];
+} dptc_log_s;
+
+/*!
+ * DPTC driver data structure.\n
+ * Holds all driver parameters and data structures.
+ */
+typedef struct {
+	/*!
+	 * This variable holds the current frequency index
+	 */
+	int current_freq_index;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dptc_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE turbo mode enable
+	 * if FALSE turbo mode disabled
+	 */
+	int turbo_mode_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DVFS module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dvfs_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is suspended
+	 */
+	int suspended;
+
+	unsigned char rc_state;
+
+	/*!
+	 * Pointer to the DVFS & DPTC translation table
+	 */
+	dvfs_dptc_tables_s *dvfs_dptc_tables_ptr;
+
+	/*!
+	 * The DPTC log buffer
+	 */
+	dptc_log_s dptc_log_buffer;
+
+	/*!
+	 * The DVFS log buffer
+	 */
+	unsigned char *dvfs_log_buffer;
+
+	/*!
+	 * The DVFS log buffer physical address (for SDMA)
+	 */
+	dma_addr_t dvfs_log_buffer_phys;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/*!
+	 * SDMA channel number
+	 */
+	int sdma_channel;
+
+	/*!
+	 * This holds the previous working point
+	 */
+	int prev_wp;
+
+	/*!
+	 * Wait entry for predictive DVFS
+	 */
+	wait_queue_head_t dvfs_pred_wait;
+#endif
+
+	/*!
+	 * This holds the current DVFS mode
+	 */
+	unsigned int dvfs_mode;
+
+	/*!
+	 * Log buffer read pointer
+	 */
+	unsigned char *read_ptr;
+
+	/*
+	 * Number of characters in log buffer
+	 */
+	int chars_in_buffer;
+} dvfs_dptc_params_s;
+
+/*!
+ * This struct contains the array with values of supported frequencies in Hz
+ */
+typedef struct {
+	/*
+	 * Number of supported states
+	 */
+	unsigned int num_of_states;
+	/*!
+	 * Array of frequencies
+	 */
+	unsigned int *freqs;
+} dvfs_states_table;
+
+/*
+ * if not defined define TREU and FALSE values.
+ */
+#ifndef TRUE
+#define TRUE  1
+#define FALSE 0
+#endif				/* TRUE */
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/entry-macro.S b/arch/arm/plat-mxc/include/mach/entry-macro.S
new file mode 100644
index 0000000..927f0d3
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/entry-macro.S
@@ -0,0 +1,97 @@
+/*
+ *  Copyright (C) 2007 Lennert Buytenhek <buytenh@wantstofly.org>
+ *  Copyright (C) 2004-2011 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <mach/hardware.h>
+
+#if defined(CONFIG_ARM_GIC)
+#include <asm/hardware/entry-macro-gic.S>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
+
+#else
+
+#define AVIC_NIMASK	0x04
+
+	@ this macro disables fast irq (not implemented)
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+#ifndef CONFIG_MXC_TZIC
+	ldr	\base, =avic_base
+	ldr	\base, [\base]
+#ifdef CONFIG_MXC_IRQ_PRIOR
+	ldr	r4, [\base, #AVIC_NIMASK]
+#endif
+#elif defined CONFIG_MXC_TZIC
+	ldr	\base, =tzic_base
+	ldr	\base, [\base]
+#endif /* CONFIG_MXC_TZIC */
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	@ this macro checks which interrupt occurred
+	@ and returns its number in irqnr
+	@ and returns if an interrupt occurred in irqstat
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#ifndef CONFIG_MXC_TZIC
+	@ Load offset & priority of the highest priority
+	@ interrupt pending from AVIC_NIVECSR
+	ldr	\irqstat, [\base, #0x40]
+	@ Shift to get the decoded IRQ number, using ASR so
+	@ 'no interrupt pending' becomes 0xffffffff
+	mov	\irqnr, \irqstat, asr #16
+	@ set zero flag if IRQ + 1 == 0
+	adds	\tmp, \irqnr, #1
+#ifdef CONFIG_MXC_IRQ_PRIOR
+	bicne	\tmp, \irqstat, #0xFFFFFFE0
+	strne	\tmp, [\base, #AVIC_NIMASK]
+	streq	r4, [\base, #AVIC_NIMASK]
+#endif
+#elif defined CONFIG_MXC_TZIC
+	@ Load offset & priority of the highest priority
+	@ interrupt pending.
+	@ 0x080 is INTSEC0 register
+	@ 0xD80 is HIPND0 register
+	mov     \irqnr, #0
+1000:	add	\irqstat, \base, \irqnr, lsr #3
+	ldr	\tmp, [\irqstat, #0xd80]
+	ldr	\irqstat, [\irqstat, #0x080]
+	ands	\tmp, \tmp, \irqstat
+	bne	1001f
+	add	\irqnr, \irqnr, #32
+	cmp     \irqnr, #128
+	blo     1000b
+	b       2001f
+1001:	mov     \irqstat, #1
+1002:	tst     \tmp, \irqstat
+	bne     2002f
+	movs    \tmp, \tmp, lsr #1
+	addne   \irqnr, \irqnr, #1
+	bne     1002b
+2001:
+	mov  \irqnr, #0
+2002:
+	movs \irqnr, \irqnr
+#endif
+	.endm
+
+	@ irq priority table (not used)
+	.macro	irq_prio_table
+	.endm
+#endif
+
diff --git a/arch/arm/plat-mxc/include/mach/epdc.h b/arch/arm/plat-mxc/include/mach/epdc.h
new file mode 100644
index 0000000..36aac88
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/epdc.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __MACH_EPDC_H_
+#define __MACH_EPDC_H_
+
+struct imx_epdc_fb_mode {
+    struct fb_videomode *vmode;
+    int vscan_holdoff;
+    int sdoed_width;
+    int sdoed_delay;
+    int sdoez_width;
+    int sdoez_delay;
+    int gdclk_hp_offs;
+    int gdsp_offs;
+    int gdoe_offs;
+    int gdclk_offs;
+    int num_ce;
+};
+
+struct imx_epdc_fb_platform_data {
+    struct imx_epdc_fb_mode *epdc_mode;
+    int num_modes;
+    int (*get_pins) (void);
+    void (*put_pins) (void);
+    void (*enable_pins) (void);
+    void (*disable_pins) (void);
+};
+
+struct imx_spdc_panel_init_set {
+    bool yoe_pol;
+    bool dual_gate;
+    u8 resolution;
+    bool ud;
+    bool rl;
+    bool data_filter_n;
+    bool power_ready;
+    bool rgbw_mode_enable;
+    bool hburst_len_en;
+};
+
+struct imx_spdc_fb_mode {
+    struct fb_videomode *vmode;
+    struct imx_spdc_panel_init_set *init_set;
+    const char *wave_timing;
+};
+
+struct imx_spdc_fb_platform_data {
+    struct imx_spdc_fb_mode *spdc_mode;
+    int num_modes;
+    int (*get_pins) (void);
+    void (*put_pins) (void);
+    void (*enable_pins) (void);
+    void (*disable_pins) (void);
+};
+
+#endif /* __MACH_EPDC_H_ */
diff --git a/arch/arm/plat-mxc/include/mach/esdhc.h b/arch/arm/plat-mxc/include/mach/esdhc.h
index 5590282..bb15db1 100644
--- a/arch/arm/plat-mxc/include/mach/esdhc.h
+++ b/arch/arm/plat-mxc/include/mach/esdhc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Wolfram Sang <w.sang@pengutronix.de>
+ * Copyright 2011 Wolfram Sang <w.sang@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -10,36 +10,31 @@
 #ifndef __ASM_ARCH_IMX_ESDHC_H
 #define __ASM_ARCH_IMX_ESDHC_H
 
-enum wp_types {
-	ESDHC_WP_NONE,		/* no WP, neither controller nor gpio */
-	ESDHC_WP_CONTROLLER,	/* mmc controller internal WP */
-	ESDHC_WP_GPIO,		/* external gpio pin for WP */
-};
-
 enum cd_types {
-	ESDHC_CD_NONE,		/* no CD, neither controller nor gpio */
-	ESDHC_CD_CONTROLLER,	/* mmc controller internal CD */
-	ESDHC_CD_GPIO,		/* external gpio pin for CD */
-	ESDHC_CD_PERMANENT,	/* no CD, card permanently wired to host */
+	ESDHC_CD_NONE,          /* no CD, neither controller nor gpio */
+	ESDHC_CD_CONTROLLER,    /* mmc controller internal CD */
+	ESDHC_CD_GPIO,          /* external gpio pin for CD */
+	ESDHC_CD_PERMANENT,     /* no CD, card permanently wired to host */
 };
 
 /**
- * struct esdhc_platform_data - platform data for esdhc on i.MX
+ * struct esdhc_platform_data - optional platform data for esdhc on i.MX
  *
- * ESDHC_WP(CD)_CONTROLLER type is not available on i.MX25/35.
+ * strongly recommended for i.MX25/35, not needed for other variants
  *
- * @wp_gpio:	gpio for write_protect
- * @cd_gpio:	gpio for card_detect interrupt
- * @wp_type:	type of write_protect method (see wp_types enum above)
- * @cd_type:	type of card_detect method (see cd_types enum above)
+ * @wp_gpio:	gpio for write_protect (-EINVAL if unused)
+ * @cd_gpio:	gpio for card_detect interrupt (-EINVAL if unused)
  */
 
 struct esdhc_platform_data {
 	unsigned int wp_gpio;
 	unsigned int cd_gpio;
-	enum wp_types wp_type;
 	enum cd_types cd_type;
+	unsigned int always_present;
+	unsigned int support_18v;
+	unsigned int support_8bit;
 	unsigned int keep_power_at_suspend;
-	int (*platform_pad_change)(int clock);
+	unsigned int delay_line;
+	int (*platform_pad_change)(unsigned int index, int clock);
 };
 #endif /* __ASM_ARCH_IMX_ESDHC_H */
diff --git a/arch/arm/plat-mxc/include/mach/gpio.h b/arch/arm/plat-mxc/include/mach/gpio.h
index 40a8c17..85fe4b8 100644
--- a/arch/arm/plat-mxc/include/mach/gpio.h
+++ b/arch/arm/plat-mxc/include/mach/gpio.h
@@ -1 +1,54 @@
-/* empty */
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_GPIO_H__
+#define __ASM_ARCH_MXC_GPIO_H__
+
+#include <linux/spinlock.h>
+#include <mach/hardware.h>
+#include <asm-generic/gpio.h>
+
+
+/* There's a off-by-one betweem the gpio bank number and the gpiochip */
+/* range e.g. GPIO_1_5 is gpio 5 under linux */
+#define IMX_GPIO_NR(bank, nr)		(((bank) - 1) * 32 + (nr))
+
+/* use gpiolib dispatchers */
+#define gpio_get_value		__gpio_get_value
+#define gpio_set_value		__gpio_set_value
+#define gpio_cansleep		__gpio_cansleep
+
+#define gpio_to_irq(gpio)	(MXC_GPIO_IRQ_START + (gpio))
+#define irq_to_gpio(irq)	((irq) - MXC_GPIO_IRQ_START)
+
+#define DEFINE_IMX_GPIO_PORT_IRQ_HIGH(soc, _id, _hwid, _irq, _irq_high)	\
+	{								\
+		.chip.label = "gpio-" #_id,				\
+		.irq = _irq,						\
+		.irq_high = _irq_high,					\
+		.base = soc ## _IO_ADDRESS(				\
+				soc ## _GPIO ## _hwid ## _BASE_ADDR),	\
+		.virtual_irq_start = MXC_GPIO_IRQ_START + (_id) * 32,	\
+	}
+
+#define DEFINE_IMX_GPIO_PORT_IRQ(soc, _id, _hwid, _irq)			\
+	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(soc, _id, _hwid, _irq, 0)
+#define DEFINE_IMX_GPIO_PORT(soc, _id, _hwid)				\
+	DEFINE_IMX_GPIO_PORT_IRQ(soc, _id, _hwid, 0)
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/gpmi-nfc.h b/arch/arm/plat-mxc/include/mach/gpmi-nfc.h
new file mode 100644
index 0000000..25fc605
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/gpmi-nfc.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __INCLUDE_GPMI_NFC_H
+#define __INCLUDE_GPMI_NFC_H
+
+/* The size of the resource is fixed. */
+#define RES_SIZE	6
+
+/* Resource names for the GPMI NFC driver. */
+#define GPMI_NFC_GPMI_REGS_ADDR_RES_NAME  "GPMI NFC GPMI Registers"
+#define GPMI_NFC_GPMI_INTERRUPT_RES_NAME  "GPMI NFC GPMI Interrupt"
+#define GPMI_NFC_BCH_REGS_ADDR_RES_NAME   "GPMI NFC BCH Registers"
+#define GPMI_NFC_BCH_INTERRUPT_RES_NAME   "GPMI NFC BCH Interrupt"
+#define GPMI_NFC_DMA_CHANNELS_RES_NAME    "GPMI NFC DMA Channels"
+#define GPMI_NFC_DMA_INTERRUPT_RES_NAME   "GPMI NFC DMA Interrupt"
+
+/**
+ * struct gpmi_nfc_platform_data - GPMI NFC driver platform data.
+ *
+ * This structure communicates platform-specific information to the GPMI NFC
+ * driver that can't be expressed as resources.
+ *
+ * @platform_init:           A pointer to a function the driver will call to
+ *                           initialize the platform (e.g., set up the pin mux).
+ * @platform_exit:           A pointer to a function the driver will call to
+ *                           exit the platform (e.g., free pins).
+ * @min_prop_delay_in_ns:    Minimum propagation delay of GPMI signals to and
+ *                           from the NAND Flash device, in nanoseconds.
+ * @max_prop_delay_in_ns:    Maximum propagation delay of GPMI signals to and
+ *                           from the NAND Flash device, in nanoseconds.
+ * @max_chip_count:          The maximum number of chips for which the driver
+ *                           should configure the hardware. This value most
+ *                           likely reflects the number of pins that are
+ *                           connected to a NAND Flash device. If this is
+ *                           greater than the SoC hardware can support, the
+ *                           driver will print a message and fail to initialize.
+ * @partitions:              An optional pointer to an array of partition
+ *                           descriptions.
+ * @partition_count:         The number of elements in the partitions array.
+ */
+struct gpmi_nfc_platform_data {
+	/* SoC hardware information. */
+	int		(*platform_init)(void);
+	void		(*platform_exit)(void);
+
+	/* NAND Flash information. */
+	unsigned int	min_prop_delay_in_ns;
+	unsigned int	max_prop_delay_in_ns;
+	unsigned int	max_chip_count;
+
+	/* Medium information. */
+	struct mtd_partition *partitions;
+	unsigned	partition_count;
+};
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/hardware.h b/arch/arm/plat-mxc/include/mach/hardware.h
index 0630513..4d89977 100644
--- a/arch/arm/plat-mxc/include/mach/hardware.h
+++ b/arch/arm/plat-mxc/include/mach/hardware.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2012 Freescale Semiconductor, Inc.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -22,9 +22,6 @@
 
 #include <asm/sizes.h>
 
-#define addr_in_module(addr, mod) \
-	((unsigned long)(addr) - mod ## _BASE_ADDR < mod ## _SIZE)
-
 #define IMX_IO_P2V_MODULE(addr, module)					\
 	(((addr) - module ## _BASE_ADDR) < module ## _SIZE ?		\
 	 (addr) - (module ## _BASE_ADDR) + (module ## _BASE_ADDR_VIRT) : 0)
@@ -78,24 +75,14 @@
  *	AIPS1	0x53f00000+0x100000	->	0xf5700000+0x100000
  *	AIPS2	0x63f00000+0x100000	->	0xf5300000+0x100000
  * mx51:
- *	TZIC	0xe0000000+0x004000	->	0xf5000000+0x004000
  *	IRAM	0x1ffe0000+0x020000	->	0xf4fe0000+0x020000
+ *	DEBUG	0x60000000+0x100000	->	0xf5000000+0x100000
  *	SPBA0	0x70000000+0x100000	->	0xf5400000+0x100000
  *	AIPS1	0x73f00000+0x100000	->	0xf5700000+0x100000
  *	AIPS2	0x83f00000+0x100000	->	0xf4300000+0x100000
- * mx53:
- *	TZIC	0x0fffc000+0x004000	->	0xf4bfc000+0x004000
- *	SPBA0	0x50000000+0x100000	->	0xf5400000+0x100000
- *	AIPS1	0x53f00000+0x100000	->	0xf5700000+0x100000
- *	AIPS2	0x63f00000+0x100000	->	0xf5300000+0x100000
- * mx6q:
- *	SCU	0x00a00000+0x001000	->	0xf4000000+0x001000
- *	CCM	0x020c4000+0x004000	->	0xf42c4000+0x004000
- *	ANATOP	0x020c8000+0x001000	->	0xf42c8000+0x001000
- *	UART4	0x021f0000+0x004000	->	0xf42f0000+0x004000
  */
 #define IMX_IO_P2V(x)	(						\
-			0xf4000000 +					\
+			0xf2000000 +					\
 			(((x) & 0x50000000) >> 6) +			\
 			(((x) & 0x0b000000) >> 4) +			\
 			(((x) & 0x000fffff)))
@@ -104,18 +91,39 @@
 
 #include <mach/mxc.h>
 
-#include <mach/mx6q.h>
+#ifdef CONFIG_ARCH_MX5
 #include <mach/mx50.h>
 #include <mach/mx51.h>
 #include <mach/mx53.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX6
+#include <mach/mx6q.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX3
 #include <mach/mx3x.h>
 #include <mach/mx31.h>
 #include <mach/mx35.h>
-#include <mach/mx2x.h>
-#include <mach/mx21.h>
-#include <mach/mx27.h>
-#include <mach/mx1.h>
-#include <mach/mx25.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX2
+# include <mach/mx2x.h>
+# ifdef CONFIG_MACH_MX21
+#  include <mach/mx21.h>
+# endif
+# ifdef CONFIG_MACH_MX27
+#  include <mach/mx27.h>
+# endif
+#endif
+
+#ifdef CONFIG_ARCH_MX1
+# include <mach/mx1.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX25
+# include <mach/mx25.h>
+#endif
 
 #define imx_map_entry(soc, name, _type)	{				\
 	.virtual = soc ## _IO_P2V(soc ## _ ## name ## _BASE_ADDR),	\
@@ -124,10 +132,4 @@
 	.type = _type,							\
 }
 
-/* There's a off-by-one betweem the gpio bank number and the gpiochip */
-/* range e.g. GPIO_1_5 is gpio 5 under linux */
-#define IMX_GPIO_NR(bank, nr)		(((bank) - 1) * 32 + (nr))
-
-#define IMX_GPIO_TO_IRQ(gpio)	(MXC_GPIO_IRQ_START + (gpio))
-
 #endif /* __ASM_ARCH_MXC_HARDWARE_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/i2c.h b/arch/arm/plat-mxc/include/mach/i2c.h
index 375cdd0..4a5dc5c 100644
--- a/arch/arm/plat-mxc/include/mach/i2c.h
+++ b/arch/arm/plat-mxc/include/mach/i2c.h
@@ -11,10 +11,14 @@
 
 /**
  * struct imxi2c_platform_data - structure of platform data for MXC I2C driver
+ * @init:	Initialise gpio's and other board specific things
+ * @exit:	Free everything initialised by @init
  * @bitrate:	Bus speed measured in Hz
  *
  **/
 struct imxi2c_platform_data {
+	int (*init)(struct device *dev);
+	void (*exit)(struct device *dev);
 	int bitrate;
 };
 
diff --git a/arch/arm/plat-mxc/include/mach/imx-uart.h b/arch/arm/plat-mxc/include/mach/imx-uart.h
index 4adec9b..21dcdaf 100644
--- a/arch/arm/plat-mxc/include/mach/imx-uart.h
+++ b/arch/arm/plat-mxc/include/mach/imx-uart.h
@@ -21,6 +21,8 @@
 
 #define IMXUART_HAVE_RTSCTS (1<<0)
 #define IMXUART_IRDA        (1<<1)
+#define IMXUART_USE_DCEDTE  (1<<2)
+#define IMXUART_SDMA        (1<<3)
 
 struct imxuart_platform_data {
 	int (*init)(struct platform_device *pdev);
@@ -30,6 +32,8 @@ struct imxuart_platform_data {
 	unsigned int irda_inv_rx:1;
 	unsigned int irda_inv_tx:1;
 	unsigned short transceiver_delay;
+	unsigned int dma_req_rx;
+	unsigned int dma_req_tx;
 };
 
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/imx_rfkill.h b/arch/arm/plat-mxc/include/mach/imx_rfkill.h
new file mode 100755
index 0000000..d7263f5
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/imx_rfkill.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef IMX_RFKILL_H
+#define IMX_RFKILL_H
+struct imx_bt_rfkill_platform_data {
+	int (*power_change) (int status);
+};
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
index 650a0e7..513cc8d 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -39,8 +39,8 @@
 		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
 #define MX6DL_USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
-		PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
-		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
 #define MX6DL_USDHC_PAD_CTRL_50MHZ_40OHM (PAD_CTL_PKE | PAD_CTL_PUE |		\
 		PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
@@ -58,6 +58,9 @@
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
 		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define MX6DL_ENET_REF_CLK_PAD_CTRL     (PAD_CTL_PUE |  \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |       \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
 
 #define MX6DL_I2C_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE   |		\
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
@@ -73,11 +76,22 @@
 #define MX6DL_ECSPI_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define MX6DL_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
+#define MX6DL_ADU_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
+		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
+
 #define MX6DL_GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
 #define MX6DL_GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | PAD_CTL_SRE_FAST)
 #define MX6DL_GPMI_PAD_CTRL2 (MX6DL_GPMI_PAD_CTRL0 | MX6DL_GPMI_PAD_CTRL1)
 #define MX6DL_SPDIF_OUT_PAD_CTRL (PAD_CTL_DSE_120ohm | PAD_CTL_SRE_FAST)
 
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define MX6DL_PAD_CSI0_DAT10__IPU1_CSI0_D_10                                   \
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT10__AUDMUX_AUD3_RXC                                  \
@@ -294,7 +308,7 @@
 #define MX6DL_PAD_CSI0_DAT5__KPP_ROW_5                                         \
 		IOMUX_PAD(0x038C, 0x0078, 3, 0x08CC, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD                                   \
-		IOMUX_PAD(0x038C, 0x0078, 4, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x038C, 0x0078, 4, 0x0000, 0, MX6DL_ADU_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT5__GPIO_5_23                                         \
 		IOMUX_PAD(0x038C, 0x0078, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT5__MMDC_MMDC_DEBUG_44                                \
@@ -328,7 +342,7 @@
 #define MX6DL_PAD_CSI0_DAT7__KPP_ROW_6                                         \
 		IOMUX_PAD(0x0394, 0x0080, 3, 0x08D0, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD                                   \
-		IOMUX_PAD(0x0394, 0x0080, 4, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0394, 0x0080, 4, 0x0000, 0, MX6DL_ADU_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT7__GPIO_5_25                                         \
 		IOMUX_PAD(0x0394, 0x0080, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT7__MMDC_MMDC_DEBUG_46                                \
@@ -1251,7 +1265,7 @@
 		IOMUX_PAD(0x04DC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A16__WEIM_WEIM_A_16                                      \
-		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_DI1_DISP_CLK                                   \
 		IOMUX_PAD(0x04E0, 0x0110, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_CSI1_PIXCLK                                    \
@@ -1268,7 +1282,7 @@
 		IOMUX_PAD(0x04E0, 0x0110, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A17__WEIM_WEIM_A_17                                      \
-		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_DISP1_DAT_12                                   \
 		IOMUX_PAD(0x04E4, 0x0114, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_CSI1_D_12                                      \
@@ -1285,7 +1299,7 @@
 		IOMUX_PAD(0x04E4, 0x0114, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A18__WEIM_WEIM_A_18                                      \
-		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_DISP1_DAT_13                                   \
 		IOMUX_PAD(0x04E8, 0x0118, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_CSI1_D_13                                      \
@@ -1302,7 +1316,7 @@
 		IOMUX_PAD(0x04E8, 0x0118, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A19__WEIM_WEIM_A_19                                      \
-		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_DISP1_DAT_14                                   \
 		IOMUX_PAD(0x04EC, 0x011C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_CSI1_D_14                                      \
@@ -1319,7 +1333,7 @@
 		IOMUX_PAD(0x04EC, 0x011C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A20__WEIM_WEIM_A_20                                      \
-		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_DISP1_DAT_15                                   \
 		IOMUX_PAD(0x04F0, 0x0120, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_CSI1_D_15                                      \
@@ -1336,7 +1350,7 @@
 		IOMUX_PAD(0x04F0, 0x0120, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A21__WEIM_WEIM_A_21                                      \
-		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_DISP1_DAT_16                                   \
 		IOMUX_PAD(0x04F4, 0x0124, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_CSI1_D_16                                      \
@@ -1353,7 +1367,7 @@
 		IOMUX_PAD(0x04F4, 0x0124, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A22__WEIM_WEIM_A_22                                      \
-		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_DISP1_DAT_17                                   \
 		IOMUX_PAD(0x04F8, 0x0128, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_CSI1_D_17                                      \
@@ -1368,7 +1382,7 @@
 		IOMUX_PAD(0x04F8, 0x0128, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A23__WEIM_WEIM_A_23                                      \
-		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_DISP1_DAT_18                                   \
 		IOMUX_PAD(0x04FC, 0x012C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_CSI1_D_18                                      \
@@ -1464,7 +1478,7 @@
 		IOMUX_PAD(0x0510, 0x0140, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D16__WEIM_WEIM_D_16                                      \
-		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__ECSPI1_SCLK                                         \
 		IOMUX_PAD(0x0514, 0x0144, 1, 0x07D8, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__IPU1_DI0_PIN5                                       \
@@ -1483,7 +1497,7 @@
 		IOMUX_PAD(0x0514, 0x0144, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D17__WEIM_WEIM_D_17                                      \
-		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__ECSPI1_MISO                                         \
 		IOMUX_PAD(0x0518, 0x0148, 1, 0x07DC, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__IPU1_DI0_PIN6                                       \
@@ -1502,7 +1516,7 @@
 		IOMUX_PAD(0x0518, 0x0148, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D18__WEIM_WEIM_D_18                                      \
-		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__ECSPI1_MOSI                                         \
 		IOMUX_PAD(0x051C, 0x014C, 1, 0x07E0, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__IPU1_DI0_PIN7                                       \
@@ -1521,7 +1535,7 @@
 		IOMUX_PAD(0x051C, 0x014C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D19__WEIM_WEIM_D_19                                      \
-		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__ECSPI1_SS1                                          \
 		IOMUX_PAD(0x0520, 0x0150, 1, 0x07E8, 1, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__IPU1_DI0_PIN8                                       \
@@ -1542,7 +1556,7 @@
 		IOMUX_PAD(0x0520, 0x0150, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D20__WEIM_WEIM_D_20                                      \
-		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__ECSPI4_SS0                                          \
 		IOMUX_PAD(0x0524, 0x0154, 1, 0x0808, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__IPU1_DI0_PIN16                                      \
@@ -1561,7 +1575,7 @@
 		IOMUX_PAD(0x0524, 0x0154, 7, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D21__WEIM_WEIM_D_21                                      \
-		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__ECSPI4_SCLK                                         \
 		IOMUX_PAD(0x0528, 0x0158, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__IPU1_DI0_PIN17                                      \
@@ -1578,7 +1592,7 @@
 		IOMUX_PAD(0x0528, 0x0158, 7, 0x08F0, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D22__WEIM_WEIM_D_22                                      \
-		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__ECSPI4_MISO                                         \
 		IOMUX_PAD(0x052C, 0x015C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__IPU1_DI0_PIN1                                       \
@@ -1597,7 +1611,7 @@
 		IOMUX_PAD(0x052C, 0x015C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D23__WEIM_WEIM_D_23                                      \
-		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__IPU1_DI0_D0_CS                                      \
 		IOMUX_PAD(0x0530, 0x0160, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__UART3_CTS                                           \
@@ -1618,7 +1632,7 @@
 		IOMUX_PAD(0x0530, 0x0160, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D24__WEIM_WEIM_D_24                                      \
-		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__ECSPI4_SS2                                          \
 		IOMUX_PAD(0x0534, 0x0164, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__UART3_TXD                                           \
@@ -1639,7 +1653,7 @@
 		IOMUX_PAD(0x0534, 0x0164, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D25__WEIM_WEIM_D_25                                      \
-		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__ECSPI4_SS3                                          \
 		IOMUX_PAD(0x0538, 0x0168, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__UART3_TXD                                           \
@@ -1660,7 +1674,7 @@
 		IOMUX_PAD(0x0538, 0x0168, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D26__WEIM_WEIM_D_26                                      \
-		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_DI1_PIN11                                      \
 		IOMUX_PAD(0x053C, 0x016C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_CSI0_D_1                                       \
@@ -1681,7 +1695,7 @@
 		IOMUX_PAD(0x053C, 0x016C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D27__WEIM_WEIM_D_27                                      \
-		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_DI1_PIN13                                      \
 		IOMUX_PAD(0x0540, 0x0170, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_CSI0_D_0                                       \
@@ -1702,7 +1716,7 @@
 		IOMUX_PAD(0x0540, 0x0170, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D28__WEIM_WEIM_D_28                                      \
-		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__I2C1_SDA                                            \
 		IOMUX_PAD(0x0544, 0x0174, 1 | IOMUX_CONFIG_SION, 0x086C, 1, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__ECSPI4_MOSI                                         \
@@ -1723,7 +1737,7 @@
 		IOMUX_PAD(0x0544, 0x0174, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D29__WEIM_WEIM_D_29                                      \
-		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__IPU1_DI1_PIN15                                      \
 		IOMUX_PAD(0x0548, 0x0178, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__ECSPI4_SS0                                          \
@@ -1742,7 +1756,7 @@
 		IOMUX_PAD(0x0548, 0x0178, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D30__WEIM_WEIM_D_30                                      \
-		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DISP1_DAT_21                                   \
 		IOMUX_PAD(0x054C, 0x017C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DI0_PIN11                                      \
@@ -1763,7 +1777,7 @@
 		IOMUX_PAD(0x054C, 0x017C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D31__WEIM_WEIM_D_31                                      \
-		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DISP1_DAT_20                                   \
 		IOMUX_PAD(0x0550, 0x0180, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DI0_PIN12                                      \
@@ -1786,7 +1800,7 @@
 		IOMUX_PAD(0x0550, 0x0180, 9, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA0__WEIM_WEIM_DA_A_0                                    \
-		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_DISP1_DAT_9                                    \
 		IOMUX_PAD(0x0554, 0x0184, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_CSI1_D_9                                       \
@@ -1803,7 +1817,7 @@
 		IOMUX_PAD(0x0554, 0x0184, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA1__WEIM_WEIM_DA_A_1                                    \
-		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_DISP1_DAT_8                                    \
 		IOMUX_PAD(0x0558, 0x0188, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_CSI1_D_8                                       \
@@ -1822,7 +1836,7 @@
 		IOMUX_PAD(0x0558, 0x0188, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA10__WEIM_WEIM_DA_A_10                                  \
-		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_DI1_PIN15                                     \
 		IOMUX_PAD(0x055C, 0x018C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_CSI1_DATA_EN                                  \
@@ -1839,7 +1853,7 @@
 		IOMUX_PAD(0x055C, 0x018C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA11__WEIM_WEIM_DA_A_11                                  \
-		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_DI1_PIN2                                      \
 		IOMUX_PAD(0x0560, 0x0190, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_CSI1_HSYNC                                    \
@@ -1858,7 +1872,7 @@
 		IOMUX_PAD(0x0560, 0x0190, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA12__WEIM_WEIM_DA_A_12                                  \
-		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_DI1_PIN3                                      \
 		IOMUX_PAD(0x0564, 0x0194, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_CSI1_VSYNC                                    \
@@ -1877,7 +1891,7 @@
 		IOMUX_PAD(0x0564, 0x0194, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA13__WEIM_WEIM_DA_A_13                                  \
-		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__IPU1_DI1_D0_CS                                     \
 		IOMUX_PAD(0x0568, 0x0198, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__CCM_DI1_EXT_CLK                                    \
@@ -1896,7 +1910,7 @@
 		IOMUX_PAD(0x0568, 0x0198, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA14__WEIM_WEIM_DA_A_14                                  \
-		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__IPU1_DI1_D1_CS                                     \
 		IOMUX_PAD(0x056C, 0x019C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__CCM_DI0_EXT_CLK                                    \
@@ -1915,7 +1929,7 @@
 		IOMUX_PAD(0x056C, 0x019C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA15__WEIM_WEIM_DA_A_15                                  \
-		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN1                                      \
 		IOMUX_PAD(0x0570, 0x01A0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN4                                      \
@@ -1932,7 +1946,7 @@
 		IOMUX_PAD(0x0570, 0x01A0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA2__WEIM_WEIM_DA_A_2                                    \
-		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_DISP1_DAT_7                                    \
 		IOMUX_PAD(0x0574, 0x01A4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_CSI1_D_7                                       \
@@ -1951,7 +1965,7 @@
 		IOMUX_PAD(0x0574, 0x01A4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA3__WEIM_WEIM_DA_A_3                                    \
-		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_DISP1_DAT_6                                    \
 		IOMUX_PAD(0x0578, 0x01A8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_CSI1_D_6                                       \
@@ -1970,7 +1984,7 @@
 		IOMUX_PAD(0x0578, 0x01A8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA4__WEIM_WEIM_DA_A_4                                    \
-		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_DISP1_DAT_5                                    \
 		IOMUX_PAD(0x057C, 0x01AC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_CSI1_D_5                                       \
@@ -1989,7 +2003,7 @@
 		IOMUX_PAD(0x057C, 0x01AC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA5__WEIM_WEIM_DA_A_5                                    \
-		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_DISP1_DAT_4                                    \
 		IOMUX_PAD(0x0580, 0x01B0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_CSI1_D_4                                       \
@@ -2008,7 +2022,7 @@
 		IOMUX_PAD(0x0580, 0x01B0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA6__WEIM_WEIM_DA_A_6                                    \
-		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_DISP1_DAT_3                                    \
 		IOMUX_PAD(0x0584, 0x01B4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_CSI1_D_3                                       \
@@ -2027,7 +2041,7 @@
 		IOMUX_PAD(0x0584, 0x01B4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA7__WEIM_WEIM_DA_A_7                                    \
-		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_DISP1_DAT_2                                    \
 		IOMUX_PAD(0x0588, 0x01B8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_CSI1_D_2                                       \
@@ -2044,7 +2058,7 @@
 		IOMUX_PAD(0x0588, 0x01B8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA8__WEIM_WEIM_DA_A_8                                    \
-		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_DISP1_DAT_1                                    \
 		IOMUX_PAD(0x058C, 0x01BC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_CSI1_D_1                                       \
@@ -2061,7 +2075,7 @@
 		IOMUX_PAD(0x058C, 0x01BC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA9__WEIM_WEIM_DA_A_9                                    \
-		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_DISP1_DAT_0                                    \
 		IOMUX_PAD(0x0590, 0x01C0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_CSI1_D_0                                       \
@@ -2253,7 +2267,7 @@
 		IOMUX_PAD(0x05BC, 0x01EC, 6, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_ENET_REF_CLK__ENET_TX_CLK                                    \
-		IOMUX_PAD(0x05C0, 0x01F0, 1, 0x0000, 0, MX6DL_ENET_PAD_CTRL)
+		IOMUX_PAD(0x05C0, 0x01F0, 1, 0x0000, 0, MX6DL_ENET_REF_CLK_PAD_CTRL)
 #define MX6DL_PAD_ENET_REF_CLK__ESAI1_FSR                                      \
 		IOMUX_PAD(0x05C0, 0x01F0, 2, 0x082C, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_ENET_REF_CLK__SDMA_DEBUG_BUS_DEVICE_4                        \
@@ -2513,10 +2527,14 @@
 #define MX6DL_PAD_GPIO_5__SIMBA_EVENTI                                         \
 		IOMUX_PAD(0x0600, 0x0230, 7, 0x0000, 0, NO_PAD_CTRL)
 
-#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
-		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+#define MX6DL_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1                           \
+		IOMUX_PAD(0x0604, 0x0234, 1 | IOMUX_CONFIG_SION, 0x0000, 0, ENET_IRQ_PAD_CTRL)
+#else
 #define MX6DL_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1                           \
 		IOMUX_PAD(0x0604, 0x0234, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
+		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__I2C3_SDA                                             \
 		IOMUX_PAD(0x0604, 0x0234, 2 | IOMUX_CONFIG_SION, 0x087C, 2, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__CCM_CCM_OUT_0                                        \
@@ -2529,6 +2547,7 @@
 		IOMUX_PAD(0x0604, 0x0234, 6, 0x0000, 0, MX6DL_USDHC_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__MLB_MLBSIG                                           \
 		IOMUX_PAD(0x0604, 0x0234, 7, 0x08E4, 1, MX6DL_MLB150_PAD_CTRL)
+#endif
 
 #define MX6DL_PAD_GPIO_7__ESAI1_TX4_RX1                                        \
 		IOMUX_PAD(0x0608, 0x0238, 0, 0x0854, 1, NO_PAD_CTRL)
@@ -2665,11 +2684,13 @@
 #define MX6DL_PAD_KEY_COL3__ENET_CRS                                           \
 		IOMUX_PAD(0x0638, 0x0250, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_COL3__HDMI_TX_DDC_SCL                                    \
-		IOMUX_PAD(0x0638, 0x0250, 2, 0x0860, 1, NO_PAD_CTRL)
+		IOMUX_PAD(0x0638, 0x0250, 2 | IOMUX_CONFIG_SION, 0x0860, 1,            \
+				MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_KEY_COL3__KPP_COL_3                                          \
 		IOMUX_PAD(0x0638, 0x0250, 3, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_COL3__I2C2_SCL                                           \
-		IOMUX_PAD(0x0638, 0x0250, 4 | IOMUX_CONFIG_SION, 0x0870, 1, MX6DL_I2C_PAD_CTRL)
+		IOMUX_PAD(0x0638, 0x0250, 4 | IOMUX_CONFIG_SION, 0x0870, 1,            \
+				MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_KEY_COL3__GPIO_4_12                                          \
 		IOMUX_PAD(0x0638, 0x0250, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_COL3__SPDIF_IN1                                          \
@@ -2756,11 +2777,13 @@
 #define MX6DL_PAD_KEY_ROW3__ASRC_ASRC_EXT_CLK                                  \
 		IOMUX_PAD(0x064C, 0x0264, 1, 0x0794, 2, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA                                    \
-		IOMUX_PAD(0x064C, 0x0264, 2, 0x0864, 1, NO_PAD_CTRL)
+		IOMUX_PAD(0x064C, 0x0264, 2 | IOMUX_CONFIG_SION, 0x0864, 1,            \
+				MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW3__KPP_ROW_3                                          \
 		IOMUX_PAD(0x064C, 0x0264, 3, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW3__I2C2_SDA                                           \
-		IOMUX_PAD(0x064C, 0x0264, 4 | IOMUX_CONFIG_SION, 0x0874, 1, MX6DL_I2C_PAD_CTRL)
+		IOMUX_PAD(0x064C, 0x0264, 4 | IOMUX_CONFIG_SION, 0x0874, 1,            \
+				MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW3__GPIO_4_13                                          \
 		IOMUX_PAD(0x064C, 0x0264, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW3__USDHC1_VSELECT                                     \
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
index ec6b228..557fc43 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,23 +24,6 @@
 
 #include <mach/iomux-v3.h>
 
-/*
- * various IOMUX alternate output functions (1-7)
- */
-typedef enum iomux_config {
-	IOMUX_CONFIG_ALT0,
-	IOMUX_CONFIG_ALT1,
-	IOMUX_CONFIG_ALT2,
-	IOMUX_CONFIG_ALT3,
-	IOMUX_CONFIG_ALT4,
-	IOMUX_CONFIG_ALT5,
-	IOMUX_CONFIG_ALT6,
-	IOMUX_CONFIG_ALT7,
-	IOMUX_CONFIG_GPIO,      /* added to help user use GPIO mode */
-	} iomux_pin_cfg_t;
-
-#define NON_MUX_I       0x3FF
-#define NON_PAD_I       0x7FF
 #define MX6Q_CCM_CLK0_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_47K_UP | PAD_CTL_SPEED_LOW |	\
 		PAD_CTL_DSE_80ohm | PAD_CTL_SRE_FAST | PAD_CTL_HYS)
@@ -74,6 +57,10 @@ typedef enum iomux_config {
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+#define MX6Q_ENET_REF_CLK_PAD_CTRL	(PAD_CTL_PUE |	\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	\
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
 #define MX6Q_GPIO_16_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |    \
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED  |    \
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
@@ -98,6 +85,21 @@ typedef enum iomux_config {
 #define MX6Q_ECSPI_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+#define MX6Q_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | \
+		PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_ODE | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
+
+#define MX6Q_ADU_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
+		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
+
+#define MX6Q_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define _MX6Q_PAD_SD2_DAT1__USDHC2_DAT1				\
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, 0)
 #define _MX6Q_PAD_SD2_DAT1__ECSPI5_SS0				\
@@ -575,7 +577,7 @@ typedef enum iomux_config {
 #define _MX6Q_PAD_EIM_D30__IPU1_CSI0_D_3				\
 		IOMUX_PAD(0x03E0, 0x00CC, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__UART3_CTS			\
-		IOMUX_PAD(0x03E0, 0x00CC, 4, 0x092C, 2, 0)
+		IOMUX_PAD(0x03E0, 0x00CC, 4, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__GPIO_3_30			\
 		IOMUX_PAD(0x03E0, 0x00CC, 5, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__USBOH3_USBH1_OC		\
@@ -2197,7 +2199,7 @@ typedef enum iomux_config {
 #define _MX6Q_PAD_KEY_COL3__ENET_CRS			\
 		IOMUX_PAD(0x05E0, 0x0210, 1, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL			\
-		IOMUX_PAD(0x05E0, 0x0210, 2, 0x0890, 1, 0)
+		IOMUX_PAD(0x05E0, 0x0210, 2 | IOMUX_CONFIG_SION, 0x0890, 1, 0)
 #define _MX6Q_PAD_KEY_COL3__KPP_COL_3			\
 		IOMUX_PAD(0x05E0, 0x0210, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_COL3__I2C2_SCL			\
@@ -2214,7 +2216,7 @@ typedef enum iomux_config {
 #define _MX6Q_PAD_KEY_ROW3__ASRC_ASRC_EXT_CLK		\
 		IOMUX_PAD(0x05E4, 0x0214, 1, 0x07B0, 0, 0)
 #define _MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA			\
-		IOMUX_PAD(0x05E4, 0x0214, 2, 0x0894, 1, 0)
+		IOMUX_PAD(0x05E4, 0x0214, 2 | IOMUX_CONFIG_SION, 0x0894, 1, 0)
 #define _MX6Q_PAD_KEY_ROW3__KPP_ROW_3			\
 		IOMUX_PAD(0x05E4, 0x0214, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW3__I2C2_SDA			\
@@ -2254,7 +2256,7 @@ typedef enum iomux_config {
 #define _MX6Q_PAD_KEY_ROW4__KPP_ROW_4			\
 		IOMUX_PAD(0x05EC, 0x021C, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__UART5_CTS			\
-		IOMUX_PAD(0x05EC, 0x021C, 4, 0x093C, 1, 0)
+		IOMUX_PAD(0x05EC, 0x021C, 4, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__GPIO_4_15			\
 		IOMUX_PAD(0x05EC, 0x021C, 5, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__MMDC_MMDC_DEBUG_50		\
@@ -2330,8 +2332,13 @@ typedef enum iomux_config {
 
 #define _MX6Q_PAD_GPIO_6__ESAI1_SCKT			\
 		IOMUX_PAD(0x0600, 0x0230, 0, 0x0870, 1, 0)
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+#define _MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
+		IOMUX_PAD(0x0600, 0x0230, 1 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+#else
 #define _MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		IOMUX_PAD(0x0600, 0x0230, 1, 0x0000, 0, 0)
+#endif
 #define _MX6Q_PAD_GPIO_6__I2C3_SDA			\
 		IOMUX_PAD(0x0600, 0x0230, 2 | IOMUX_CONFIG_SION, 0x08AC, 1, 0)
 #define _MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0			\
@@ -3885,7 +3892,7 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_EIM_A25__GPIO_5_2		\
 		(_MX6Q_PAD_EIM_A25__GPIO_5_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE		\
-		(_MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE | MUX_PAD_CTRL(MX6Q_HDMICEC_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A25__PL301_MX6QPER1_HBURST_0		\
 		(_MX6Q_PAD_EIM_A25__PL301_MX6QPER1_HBURST_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
@@ -3907,7 +3914,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_EB2__SRC_BT_CFG_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16		\
-		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__ECSPI1_SCLK		\
 		(_MX6Q_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__IPU1_DI0_PIN5		\
@@ -3922,7 +3929,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D16__I2C2_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17		\
-		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__ECSPI1_MISO		\
 		(_MX6Q_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__IPU1_DI0_PIN6		\
@@ -3939,7 +3946,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D17__PL301_MX6QPER1_HBURST_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18		\
-		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__ECSPI1_MOSI		\
 		(_MX6Q_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__IPU1_DI0_PIN7		\
@@ -3956,7 +3963,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D18__PL301_MX6QPER1_HBURST_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19		\
-		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__ECSPI1_SS1		\
 		(_MX6Q_PAD_EIM_D19__ECSPI1_SS1 | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__IPU1_DI0_PIN8		\
@@ -3973,7 +3980,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D19__PL301_MX6QPER1_HRESP | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20		\
-		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__ECSPI4_SS0		\
 		(_MX6Q_PAD_EIM_D20__ECSPI4_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__IPU1_DI0_PIN16		\
@@ -3990,7 +3997,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D20__EPIT2_EPITO | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21		\
-		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__ECSPI4_SCLK		\
 		(_MX6Q_PAD_EIM_D21__ECSPI4_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__IPU1_DI0_PIN17		\
@@ -4007,7 +4014,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D21__SPDIF_IN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22		\
-		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__ECSPI4_MISO		\
 		(_MX6Q_PAD_EIM_D22__ECSPI4_MISO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__IPU1_DI0_PIN1		\
@@ -4024,7 +4031,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D22__PL301_MX6QPER1_HWRITE | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23		\
-		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS		\
 		(_MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__UART3_CTS		\
@@ -4060,7 +4067,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_EB3__SRC_BT_CFG_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24		\
-		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__ECSPI4_SS2		\
 		(_MX6Q_PAD_EIM_D24__ECSPI4_SS2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__UART3_TXD		\
@@ -4079,7 +4086,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D24__UART1_DTR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25		\
-		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__ECSPI4_SS3		\
 		(_MX6Q_PAD_EIM_D25__ECSPI4_SS3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__UART3_TXD		\
@@ -4098,7 +4105,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D25__UART1_DSR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26		\
-		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11		\
 		(_MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_CSI0_D_1		\
@@ -4117,7 +4124,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D26__IPU1_DISP1_DAT_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27		\
-		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13		\
 		(_MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_CSI0_D_0		\
@@ -4136,7 +4143,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D27__IPU1_DISP1_DAT_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28		\
-		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__I2C1_SDA		\
 		(_MX6Q_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__ECSPI4_MOSI		\
@@ -4155,7 +4162,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D28__IPU1_DI0_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29		\
-		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__ECSPI4_SS0		\
@@ -4172,7 +4179,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D29__IPU1_DI0_PIN14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30		\
-		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21		\
 		(_MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DI0_PIN11		\
@@ -4189,7 +4196,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_D30__PL301_MX6QPER1_HPROT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31		\
-		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20		\
 		(_MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DI0_PIN12		\
@@ -4225,7 +4232,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A24__SRC_BT_CFG_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23		\
-		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18		\
 		(_MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU2_CSI1_D_18		\
@@ -4242,7 +4249,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A23__SRC_BT_CFG_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22		\
-		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17		\
 		(_MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU2_CSI1_D_17		\
@@ -4255,7 +4262,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A22__SRC_BT_CFG_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21		\
-		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16		\
 		(_MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU2_CSI1_D_16		\
@@ -4272,7 +4279,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A21__SRC_BT_CFG_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20		\
-		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15		\
 		(_MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU2_CSI1_D_15		\
@@ -4289,7 +4296,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A20__SRC_BT_CFG_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19		\
-		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14		\
 		(_MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU2_CSI1_D_14		\
@@ -4306,7 +4313,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A19__SRC_BT_CFG_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18		\
-		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13		\
 		(_MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU2_CSI1_D_13		\
@@ -4323,7 +4330,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A18__SRC_BT_CFG_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17		\
-		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12		\
 		(_MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU2_CSI1_D_12		\
@@ -4340,7 +4347,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_A17__SRC_BT_CFG_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16		\
-		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK		\
 		(_MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU2_CSI1_PIXCLK		\
@@ -4454,7 +4461,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_EB1__SRC_BT_CFG_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0		\
-		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9		\
 		(_MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU2_CSI1_D_9		\
@@ -4469,7 +4476,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA0__SRC_BT_CFG_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1		\
-		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8		\
 		(_MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU2_CSI1_D_8		\
@@ -4486,7 +4493,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA1__SRC_BT_CFG_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2		\
-		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7		\
 		(_MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU2_CSI1_D_7		\
@@ -4503,7 +4510,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA2__SRC_BT_CFG_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3		\
-		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6		\
 		(_MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU2_CSI1_D_6		\
@@ -4520,7 +4527,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA3__SRC_BT_CFG_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4		\
-		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5		\
 		(_MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU2_CSI1_D_5		\
@@ -4537,7 +4544,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA4__SRC_BT_CFG_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5		\
-		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4		\
 		(_MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU2_CSI1_D_4		\
@@ -4554,7 +4561,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA5__SRC_BT_CFG_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6		\
-		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3		\
 		(_MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU2_CSI1_D_3		\
@@ -4571,7 +4578,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA6__SRC_BT_CFG_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7		\
-		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2		\
 		(_MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU2_CSI1_D_2		\
@@ -4586,7 +4593,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA7__SRC_BT_CFG_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8		\
-		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1		\
 		(_MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU2_CSI1_D_1		\
@@ -4601,7 +4608,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA8__SRC_BT_CFG_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9		\
-		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0		\
 		(_MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU2_CSI1_D_0		\
@@ -4616,7 +4623,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA9__SRC_BT_CFG_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10		\
-		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU2_CSI1_DATA_EN		\
@@ -4631,7 +4638,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA10__SRC_BT_CFG_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11		\
-		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2		\
 		(_MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU2_CSI1_HSYNC		\
@@ -4648,7 +4655,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA11__SRC_BT_CFG_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12		\
-		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3		\
 		(_MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU2_CSI1_VSYNC		\
@@ -4665,7 +4672,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA12__SRC_BT_CFG_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13		\
-		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS		\
 		(_MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__CCM_DI1_EXT_CLK		\
@@ -4682,7 +4689,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA13__SRC_BT_CFG_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14		\
-		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS		\
 		(_MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__CCM_DI0_EXT_CLK		\
@@ -4699,7 +4706,7 @@ typedef enum iomux_config {
 		(_MX6Q_PAD_EIM_DA14__SRC_BT_CFG_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15		\
-		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1		\
 		(_MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN4		\
@@ -5225,7 +5232,7 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_ENET_REF_CLK__RESERVED_RESERVED		\
 		(_MX6Q_PAD_ENET_REF_CLK__RESERVED_RESERVED | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK		\
-		(_MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(MX6Q_ENET_PAD_CTRL))
+		(_MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(MX6Q_ENET_REF_CLK_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR		\
 		(_MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR | MUX_PAD_CTRL(MX6Q_ESAI_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__SDMA_DEBUG_BUS_DEVICE_4		\
@@ -5795,7 +5802,7 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_KEY_ROW2__GPIO_4_11		\
 		(_MX6Q_PAD_KEY_ROW2__GPIO_4_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE		\
-		(_MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE | MUX_PAD_CTRL(MX6Q_HDMICEC_PAD_CTRL))
 #define  MX6Q_PAD_KEY_ROW2__PL301_MX6QPER1_HADDR_4		\
 		(_MX6Q_PAD_KEY_ROW2__PL301_MX6QPER1_HADDR_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
@@ -5804,7 +5811,7 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_KEY_COL3__ENET_CRS		\
 		(_MX6Q_PAD_KEY_COL3__ENET_CRS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL		\
-		(_MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 #define  MX6Q_PAD_KEY_COL3__KPP_COL_3		\
 		(_MX6Q_PAD_KEY_COL3__KPP_COL_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_KEY_COL3__I2C2_SCL		\
@@ -5821,7 +5828,7 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_KEY_ROW3__ASRC_ASRC_EXT_CLK		\
 		(_MX6Q_PAD_KEY_ROW3__ASRC_ASRC_EXT_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA		\
-		(_MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 #define  MX6Q_PAD_KEY_ROW3__KPP_ROW_3		\
 		(_MX6Q_PAD_KEY_ROW3__KPP_ROW_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_KEY_ROW3__I2C2_SDA		\
@@ -5933,22 +5940,27 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_GPIO_3__MLB_MLBCLK		\
 		(_MX6Q_PAD_GPIO_3__MLB_MLBCLK | MUX_PAD_CTRL(MX6Q_MLB150_PAD_CTRL))
 
-#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
-		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+#define  MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
+		(_MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1 | MUX_PAD_CTRL(ENET_IRQ_PAD_CTRL))
+#else
 #define  MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		(_MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
+		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
+		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__I2C3_SDA		\
 		(_MX6Q_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0		\
 		(_MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB		\
 		(_MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
-		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__USDHC2_LCTL		\
 		(_MX6Q_PAD_GPIO_6__USDHC2_LCTL | MUX_PAD_CTRL(MX6Q_USDHC_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__MLB_MLBSIG		\
 		(_MX6Q_PAD_GPIO_6__MLB_MLBSIG | MUX_PAD_CTRL(MX6Q_MLB150_PAD_CTRL))
+#endif
 
 #define  MX6Q_PAD_GPIO_2__ESAI1_FST		\
 		(_MX6Q_PAD_GPIO_2__ESAI1_FST | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -6190,7 +6202,8 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_CSI0_DAT5__KPP_ROW_5		\
 		(_MX6Q_PAD_CSI0_DAT5__KPP_ROW_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD		\
-		(_MX6Q_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD | \
+					MUX_PAD_CTRL(MX6Q_ADU_PAD_CTRL))
 #define  MX6Q_PAD_CSI0_DAT5__GPIO_5_23		\
 		(_MX6Q_PAD_CSI0_DAT5__GPIO_5_23 | MUX_PAD_CTRL(MX6Q_HIGH_DRV))
 #define  MX6Q_PAD_CSI0_DAT5__MMDC_MMDC_DEBUG_44		\
@@ -6224,7 +6237,8 @@ typedef enum iomux_config {
 #define  MX6Q_PAD_CSI0_DAT7__KPP_ROW_6		\
 		(_MX6Q_PAD_CSI0_DAT7__KPP_ROW_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD		\
-		(_MX6Q_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD | \
+					MUX_PAD_CTRL(MX6Q_ADU_PAD_CTRL))
 #define  MX6Q_PAD_CSI0_DAT7__GPIO_5_25		\
 		(_MX6Q_PAD_CSI0_DAT7__GPIO_5_25 | MUX_PAD_CTRL(MX6Q_HIGH_DRV))
 #define  MX6Q_PAD_CSI0_DAT7__MMDC_MMDC_DEBUG_46		\
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6sl.h b/arch/arm/plat-mxc/include/mach/iomux-mx6sl.h
new file mode 100755
index 0000000..90de1dd
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6sl.h
@@ -0,0 +1,3092 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Auto Generate file, please don't edit it
+ *
+ */
+
+#ifndef __MACH_IOMUX_MX6SL_H__
+#define __MACH_IOMUX_MX6SL_H__
+
+#include <mach/iomux-v3.h>
+
+#define MX6SL_HIGH_DRV		PAD_CTL_DSE_120ohm
+#define MX6SL_DISP_PAD_CLT	MX6SL_HIGH_DRV
+
+#define MX6SL_CCM_CLKO_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define MX6SL_UART_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE  |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define MX6SL_USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+#define MX6SL_USDHC_PAD_CTRL_100MHZ (PAD_CTL_PKE | PAD_CTL_PUE |	\
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_34ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define MX6SL_USDHC_PAD_CTRL_200MHZ (PAD_CTL_PKE | PAD_CTL_PUE |	\
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_HIGH |		\
+		PAD_CTL_DSE_34ohm   | PAD_CTL_SRE_FAST   | PAD_CTL_HYS)
+
+#define MX6SL_ENET_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE  |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define MX6SL_I2C_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE   |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  |		\
+		PAD_CTL_HYS         | PAD_CTL_ODE)
+
+#define MX6SL_ECSPI_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED |	\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define MX6SL_USB_HSIC_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define MX6SL_HP_DET_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+#define MX6SL_LCDIF_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP |	\
+				PAD_CTL_PUE | PAD_CTL_PKE |		\
+				PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define MX6SL_KEYPAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+				PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_120ohm)
+
+#define MX6SL_TSPAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+				PAD_CTL_PUS_47K_UP)
+#define MX6SL_ADU_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
+		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
+#define MX6SL_CHG_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_47K_UP)
+
+
+#define MX6SL_PAD_AUD_MCLK		0x02A4
+#define MX6SL_PAD_AUD_RXD		0x02AC
+#define MX6SL_PAD_AUD_TXC		0x02B4
+#define MX6SL_PAD_AUD_TXD		0x02B8
+#define MX6SL_PAD_AUD_TXFS		0x02BC
+#define MX6SL_PAD_HSIC_DAT		0x0444
+#define MX6SL_PAD_HSIC_STROBE		0x0448
+
+#define MX6SL_PAD_AUD_MCLK__AUDMUX_AUDIO_CLK_OUT                              \
+		IOMUX_PAD(0x02A4, 0x004C, 0, 0x0000, 0, MX6SL_ADU_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__PWM4_PWMO                                         \
+		IOMUX_PAD(0x02A4, 0x004C, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__ECSPI3_RDY                                        \
+		IOMUX_PAD(0x02A4, 0x004C, 2, 0x06B4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__FEC_MDC                                           \
+		IOMUX_PAD(0x02A4, 0x004C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__WDOG2_WDOG_RST_B_DEB                              \
+		IOMUX_PAD(0x02A4, 0x004C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__GPIO_1_6                                          \
+		IOMUX_PAD(0x02A4, 0x004C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__SPDIF_SPDIF_EXT_CLK                               \
+		IOMUX_PAD(0x02A4, 0x004C, 6, 0x07F4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_MCLK__TPSMP_HDATA_27                                    \
+		IOMUX_PAD(0x02A4, 0x004C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_RXC__AUDMUX_AUD3_RXC                                    \
+		IOMUX_PAD(0x02A8, 0x0050, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__I2C1_SDA                                           \
+		IOMUX_PAD(0x02A8, 0x0050, 1 | IOMUX_CONFIG_SION, 0x0720, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__UART3_TXD                                          \
+		IOMUX_PAD(0x02A8, 0x0050, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__UART3_RXD                                          \
+		IOMUX_PAD(0x02A8, 0x0050, 2, 0x080C, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__FEC_TX_CLK                                         \
+		IOMUX_PAD(0x02A8, 0x0050, 3, 0x070C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__I2C3_SDA                                           \
+		IOMUX_PAD(0x02A8, 0x0050, 4 | IOMUX_CONFIG_SION, 0x0730, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__GPIO_1_1                                           \
+		IOMUX_PAD(0x02A8, 0x0050, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__ECSPI3_SS1                                         \
+		IOMUX_PAD(0x02A8, 0x0050, 6, 0x06C4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXC__PL301_SIM_MX6SL_PER1_HREADYOUT                     \
+		IOMUX_PAD(0x02A8, 0x0050, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_RXD__AUDMUX_AUD3_RXD                                    \
+		IOMUX_PAD(0x02AC, 0x0054, 0, 0x0000, 0, MX6SL_ADU_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__ECSPI3_MOSI                                        \
+		IOMUX_PAD(0x02AC, 0x0054, 1, 0x06BC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__UART4_TXD                                          \
+		IOMUX_PAD(0x02AC, 0x0054, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__UART4_RXD                                          \
+		IOMUX_PAD(0x02AC, 0x0054, 2, 0x0814, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__FEC_RX_ER                                          \
+		IOMUX_PAD(0x02AC, 0x0054, 3, 0x0708, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__USDHC1_LCTL                                        \
+		IOMUX_PAD(0x02AC, 0x0054, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__GPIO_1_2                                           \
+		IOMUX_PAD(0x02AC, 0x0054, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__SRC_INT_BOOT                                       \
+		IOMUX_PAD(0x02AC, 0x0054, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXD__PL301_SIM_MX6SL_PER1_HRESP                         \
+		IOMUX_PAD(0x02AC, 0x0054, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_RXFS__AUDMUX_AUD3_RXFS                                  \
+		IOMUX_PAD(0x02B0, 0x0058, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__I2C1_SCL                                          \
+		IOMUX_PAD(0x02B0, 0x0058, 1 | IOMUX_CONFIG_SION, 0x071C, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__UART3_TXD                                         \
+		IOMUX_PAD(0x02B0, 0x0058, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__UART3_RXD                                         \
+		IOMUX_PAD(0x02B0, 0x0058, 2, 0x080C, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__FEC_MDIO                                          \
+		IOMUX_PAD(0x02B0, 0x0058, 3, 0x06F4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__I2C3_SCL                                          \
+		IOMUX_PAD(0x02B0, 0x0058, 4 | IOMUX_CONFIG_SION, 0x072C, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__GPIO_1_0                                          \
+		IOMUX_PAD(0x02B0, 0x0058, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__ECSPI3_SS0                                        \
+		IOMUX_PAD(0x02B0, 0x0058, 6, 0x06C0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_RXFS__PL301_SIM_MX6SL_PER1_HPROT_1                      \
+		IOMUX_PAD(0x02B0, 0x0058, 7, 0x07EC, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_TXC__AUDMUX_AUD3_TXC                                    \
+		IOMUX_PAD(0x02B4, 0x005C, 0, 0x0000, 0, MX6SL_ADU_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__ECSPI3_MISO                                        \
+		IOMUX_PAD(0x02B4, 0x005C, 1, 0x06B8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__UART4_TXD                                          \
+		IOMUX_PAD(0x02B4, 0x005C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__UART4_RXD                                          \
+		IOMUX_PAD(0x02B4, 0x005C, 2, 0x0814, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__FEC_RX_DV                                          \
+		IOMUX_PAD(0x02B4, 0x005C, 3, 0x0704, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__USDHC2_LCTL                                        \
+		IOMUX_PAD(0x02B4, 0x005C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__GPIO_1_3                                           \
+		IOMUX_PAD(0x02B4, 0x005C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__SRC_SYSTEM_RST                                     \
+		IOMUX_PAD(0x02B4, 0x005C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXC__TPSMP_HDATA_24                                     \
+		IOMUX_PAD(0x02B4, 0x005C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_TXD__AUDMUX_AUD3_TXD                                    \
+		IOMUX_PAD(0x02B8, 0x0060, 0, 0x0000, 0, MX6SL_ADU_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__ECSPI3_SCLK                                        \
+		IOMUX_PAD(0x02B8, 0x0060, 1, 0x06B0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__UART4_CTS                                          \
+		IOMUX_PAD(0x02B8, 0x0060, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__UART4_RTS                                          \
+		IOMUX_PAD(0x02B8, 0x0060, 2, 0x0810, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__FEC_TDATA_0                                        \
+		IOMUX_PAD(0x02B8, 0x0060, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__USDHC4_LCTL                                        \
+		IOMUX_PAD(0x02B8, 0x0060, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__GPIO_1_5                                           \
+		IOMUX_PAD(0x02B8, 0x0060, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__ANATOP_ANATOP_TESTI_1                              \
+		IOMUX_PAD(0x02B8, 0x0060, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXD__TPSMP_HDATA_26                                     \
+		IOMUX_PAD(0x02B8, 0x0060, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_AUD_TXFS__AUDMUX_AUD3_TXFS                                  \
+		IOMUX_PAD(0x02BC, 0x0064, 0, 0x0000, 0, MX6SL_ADU_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__PWM3_PWMO                                         \
+		IOMUX_PAD(0x02BC, 0x0064, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__UART4_CTS                                         \
+		IOMUX_PAD(0x02BC, 0x0064, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__UART4_RTS                                         \
+		IOMUX_PAD(0x02BC, 0x0064, 2, 0x0810, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__FEC_RDATA_1                                       \
+		IOMUX_PAD(0x02BC, 0x0064, 3, 0x06FC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__USDHC3_LCTL                                       \
+		IOMUX_PAD(0x02BC, 0x0064, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__GPIO_1_4                                          \
+		IOMUX_PAD(0x02BC, 0x0064, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__ANATOP_ANATOP_TESTI_0                             \
+		IOMUX_PAD(0x02BC, 0x0064, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_AUD_TXFS__TPSMP_HDATA_25                                    \
+		IOMUX_PAD(0x02BC, 0x0064, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_BOOT_MODE0__SRC_BOOT_MODE_0                                 \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_BOOT_MODE1__SRC_BOOT_MODE_1                                 \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A0__MMDC_DRAM_A_0                                      \
+		IOMUX_PAD(0x02C0, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A1__MMDC_DRAM_A_1                                      \
+		IOMUX_PAD(0x02C4, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A10__MMDC_DRAM_A_10                                    \
+		IOMUX_PAD(0x02C8, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A11__MMDC_DRAM_A_11                                    \
+		IOMUX_PAD(0x02CC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A12__MMDC_DRAM_A_12                                    \
+		IOMUX_PAD(0x02D0, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A13__MMDC_DRAM_A_13                                    \
+		IOMUX_PAD(0x02D4, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A14__MMDC_DRAM_A_14                                    \
+		IOMUX_PAD(0x02D8, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A15__MMDC_DRAM_A_15                                    \
+		IOMUX_PAD(0x02DC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A2__MMDC_DRAM_A_2                                      \
+		IOMUX_PAD(0x02E0, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A3__MMDC_DRAM_A_3                                      \
+		IOMUX_PAD(0x02E4, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A4__MMDC_DRAM_A_4                                      \
+		IOMUX_PAD(0x02E8, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A5__MMDC_DRAM_A_5                                      \
+		IOMUX_PAD(0x02EC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A6__MMDC_DRAM_A_6                                      \
+		IOMUX_PAD(0x02F0, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A7__MMDC_DRAM_A_7                                      \
+		IOMUX_PAD(0x02F4, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A8__MMDC_DRAM_A_8                                      \
+		IOMUX_PAD(0x02F8, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_A9__MMDC_DRAM_A_9                                      \
+		IOMUX_PAD(0x02FC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_CAS__MMDC_DRAM_CAS                                     \
+		IOMUX_PAD(0x0300, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_CS0__MMDC_DRAM_CS_0                                    \
+		IOMUX_PAD(0x0304, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_CS1__MMDC_DRAM_CS_1                                    \
+		IOMUX_PAD(0x0308, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D0__MMDC_DRAM_D_0                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D1__MMDC_DRAM_D_1                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D10__MMDC_DRAM_D_10                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D11__MMDC_DRAM_D_11                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D12__MMDC_DRAM_D_12                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D13__MMDC_DRAM_D_13                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D14__MMDC_DRAM_D_14                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D15__MMDC_DRAM_D_15                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D16__MMDC_DRAM_D_16                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D17__MMDC_DRAM_D_17                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D18__MMDC_DRAM_D_18                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D19__MMDC_DRAM_D_19                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D2__MMDC_DRAM_D_2                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D20__MMDC_DRAM_D_20                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D21__MMDC_DRAM_D_21                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D22__MMDC_DRAM_D_22                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D23__MMDC_DRAM_D_23                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D24__MMDC_DRAM_D_24                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D25__MMDC_DRAM_D_25                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D26__MMDC_DRAM_D_26                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D27__MMDC_DRAM_D_27                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D28__MMDC_DRAM_D_28                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D29__MMDC_DRAM_D_29                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D3__MMDC_DRAM_D_3                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D30__MMDC_DRAM_D_30                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D31__MMDC_DRAM_D_31                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D4__MMDC_DRAM_D_4                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D5__MMDC_DRAM_D_5                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D6__MMDC_DRAM_D_6                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D7__MMDC_DRAM_D_7                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D8__MMDC_DRAM_D_8                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_D9__MMDC_DRAM_D_9                                      \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_DQM0__MMDC_DRAM_DQM_0                                  \
+		IOMUX_PAD(0x030C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_DQM1__MMDC_DRAM_DQM_1                                  \
+		IOMUX_PAD(0x0310, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_DQM2__MMDC_DRAM_DQM_2                                  \
+		IOMUX_PAD(0x0314, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_DQM3__MMDC_DRAM_DQM_3                                  \
+		IOMUX_PAD(0x0318, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_RAS__MMDC_DRAM_RAS                                     \
+		IOMUX_PAD(0x031C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_RESET__MMDC_DRAM_RESET                                 \
+		IOMUX_PAD(0x0320, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDBA0__MMDC_DRAM_SDBA_0                                \
+		IOMUX_PAD(0x0324, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDBA1__MMDC_DRAM_SDBA_1                                \
+		IOMUX_PAD(0x0328, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDBA2__MMDC_DRAM_SDBA_2                                \
+		IOMUX_PAD(0x032C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDCKE0__MMDC_DRAM_SDCKE_0                              \
+		IOMUX_PAD(0x0330, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDCKE1__MMDC_DRAM_SDCKE_1                              \
+		IOMUX_PAD(0x0334, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDCLK_0__MMDC_DRAM_SDCLK0                              \
+		IOMUX_PAD(0x0338, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDODT0__MMDC_DRAM_ODT_0                                \
+		IOMUX_PAD(0x033C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDODT1__MMDC_DRAM_ODT_1                                \
+		IOMUX_PAD(0x0340, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDQS0__MMDC_DRAM_SDQS_0                                \
+		IOMUX_PAD(0x0344, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDQS1__MMDC_DRAM_SDQS_1                                \
+		IOMUX_PAD(0x0348, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDQS2__MMDC_DRAM_SDQS_2                                \
+		IOMUX_PAD(0x034C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDQS3__MMDC_DRAM_SDQS_3                                \
+		IOMUX_PAD(0x0350, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_DRAM_SDWE__MMDC_DRAM_SDWE                                   \
+		IOMUX_PAD(0x0354, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI1_MISO__ECSPI1_MISO                                    \
+		IOMUX_PAD(0x0358, 0x0068, 0, 0x0684, 0, MX6SL_ECSPI_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__AUDMUX_AUD4_TXFS                               \
+		IOMUX_PAD(0x0358, 0x0068, 1, 0x05F8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__UART5_CTS                                      \
+		IOMUX_PAD(0x0358, 0x0068, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__UART5_RTS                                      \
+		IOMUX_PAD(0x0358, 0x0068, 2, 0x0818, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__EPDC_BDR_0                                     \
+		IOMUX_PAD(0x0358, 0x0068, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__USDHC2_WP                                      \
+		IOMUX_PAD(0x0358, 0x0068, 4, 0x0834, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__GPIO_4_10                                      \
+		IOMUX_PAD(0x0358, 0x0068, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__CCM_PLL3_BYP                                   \
+		IOMUX_PAD(0x0358, 0x0068, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MISO__MMDC_MMDC_DEBUG_40                             \
+		IOMUX_PAD(0x0358, 0x0068, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI1_MOSI__ECSPI1_MOSI                                    \
+		IOMUX_PAD(0x035C, 0x006C, 0, 0x0688, 0, MX6SL_ECSPI_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__AUDMUX_AUD4_TXC                                \
+		IOMUX_PAD(0x035C, 0x006C, 1, 0x05F4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__UART5_TXD                                      \
+		IOMUX_PAD(0x035C, 0x006C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__UART5_RXD                                      \
+		IOMUX_PAD(0x035C, 0x006C, 2, 0x081C, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__EPDC_VCOM_1                                    \
+		IOMUX_PAD(0x035C, 0x006C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__USDHC2_VSELECT                                 \
+		IOMUX_PAD(0x035C, 0x006C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__GPIO_4_9                                       \
+		IOMUX_PAD(0x035C, 0x006C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__CCM_PLL2_BYP                                   \
+		IOMUX_PAD(0x035C, 0x006C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_MOSI__MMDC_MMDC_DEBUG_49                             \
+		IOMUX_PAD(0x035C, 0x006C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI1_SCLK__ECSPI1_SCLK                                    \
+		IOMUX_PAD(0x0360, 0x0070, 0, 0x067C, 0, MX6SL_ECSPI_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__AUDMUX_AUD4_TXD                                \
+		IOMUX_PAD(0x0360, 0x0070, 1, 0x05E8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__UART5_TXD                                      \
+		IOMUX_PAD(0x0360, 0x0070, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__UART5_RXD                                      \
+		IOMUX_PAD(0x0360, 0x0070, 2, 0x081C, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__EPDC_VCOM_0                                    \
+		IOMUX_PAD(0x0360, 0x0070, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__USDHC2_RST                                     \
+		IOMUX_PAD(0x0360, 0x0070, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__GPIO_4_8                                       \
+		IOMUX_PAD(0x0360, 0x0070, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__USB_USBOTG2_OC                                 \
+		IOMUX_PAD(0x0360, 0x0070, 6, 0x0820, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SCLK__TPSMP_HDATA_18                                 \
+		IOMUX_PAD(0x0360, 0x0070, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI1_SS0__ECSPI1_SS0                                      \
+		IOMUX_PAD(0x0364, 0x0074, 0, 0x068C, 0, MX6SL_ECSPI_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__AUDMUX_AUD4_RXD                                 \
+		IOMUX_PAD(0x0364, 0x0074, 1, 0x05E4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__UART5_CTS                                       \
+		IOMUX_PAD(0x0364, 0x0074, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__UART5_RTS                                       \
+		IOMUX_PAD(0x0364, 0x0074, 2, 0x0818, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__EPDC_BDR_1                                      \
+		IOMUX_PAD(0x0364, 0x0074, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__USDHC2_CD                                       \
+		IOMUX_PAD(0x0364, 0x0074, 4, 0x0830, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__GPIO_4_11                                       \
+		IOMUX_PAD(0x0364, 0x0074, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__USB_USBOTG2_PWR                                 \
+		IOMUX_PAD(0x0364, 0x0074, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI1_SS0__PL301_SIM_MX6SL_PER1_HADDR_23                   \
+		IOMUX_PAD(0x0364, 0x0074, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI2_MISO__GPIO_4_14                                      \
+		IOMUX_PAD(0x0368, 0x0078, 5, 0x0000, 0, MX6SL_CHG_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__USB_USBOTG1_OC                                 \
+		IOMUX_PAD(0x0368, 0x0078, 6, 0x0824, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__TPSMP_HDATA_23                                 \
+		IOMUX_PAD(0x0368, 0x0078, 7, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__ECSPI2_MISO                                    \
+		IOMUX_PAD(0x0368, 0x0078, 0, 0x06A0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__SDMA_SDMA_EXT_EVENT_0                          \
+		IOMUX_PAD(0x0368, 0x0078, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__UART3_CTS                                      \
+		IOMUX_PAD(0x0368, 0x0078, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__UART3_RTS                                      \
+		IOMUX_PAD(0x0368, 0x0078, 2, 0x0808, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__CSI_MCLK                                       \
+		IOMUX_PAD(0x0368, 0x0078, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MISO__USDHC1_WP                                      \
+		IOMUX_PAD(0x0368, 0x0078, 4, 0x082C, 0, MX6SL_USDHC_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI2_MOSI__ECSPI2_MOSI                                    \
+		IOMUX_PAD(0x036C, 0x007C, 0, 0x06A4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__SDMA_SDMA_EXT_EVENT_1                          \
+		IOMUX_PAD(0x036C, 0x007C, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__UART3_TXD                                      \
+		IOMUX_PAD(0x036C, 0x007C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__UART3_RXD                                      \
+		IOMUX_PAD(0x036C, 0x007C, 2, 0x080C, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__CSI_HSYNC                                      \
+		IOMUX_PAD(0x036C, 0x007C, 3, 0x0670, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__USDHC1_VSELECT                                 \
+		IOMUX_PAD(0x036C, 0x007C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__GPIO_4_13                                      \
+		IOMUX_PAD(0x036C, 0x007C, 5, 0x0000, 0, MX6SL_CHG_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__ANATOP_ANATOP_TESTO_1                          \
+		IOMUX_PAD(0x036C, 0x007C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_MOSI__TPSMP_HDATA_22                                 \
+		IOMUX_PAD(0x036C, 0x007C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI2_SCLK__ECSPI2_SCLK                                    \
+		IOMUX_PAD(0x0370, 0x0080, 0, 0x069C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__SPDIF_SPDIF_EXT_CLK                            \
+		IOMUX_PAD(0x0370, 0x0080, 1, 0x07F4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__UART3_TXD                                      \
+		IOMUX_PAD(0x0370, 0x0080, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__UART3_RXD                                      \
+		IOMUX_PAD(0x0370, 0x0080, 2, 0x080C, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__CSI_PIXCLK                                     \
+		IOMUX_PAD(0x0370, 0x0080, 3, 0x0674, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__USDHC1_RST                                     \
+		IOMUX_PAD(0x0370, 0x0080, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__GPIO_4_12                                      \
+		IOMUX_PAD(0x0370, 0x0080, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__USB_USBOTG2_OC                                 \
+		IOMUX_PAD(0x0370, 0x0080, 6, 0x0820, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SCLK__TPSMP_HDATA_21                                 \
+		IOMUX_PAD(0x0370, 0x0080, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_ECSPI2_SS0__ECSPI2_SS0                                      \
+		IOMUX_PAD(0x0374, 0x0084, 0, 0x06A8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__ECSPI1_SS3                                      \
+		IOMUX_PAD(0x0374, 0x0084, 1, 0x0698, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__UART3_CTS                                       \
+		IOMUX_PAD(0x0374, 0x0084, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__UART3_RTS                                       \
+		IOMUX_PAD(0x0374, 0x0084, 2, 0x0808, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__CSI_VSYNC                                       \
+		IOMUX_PAD(0x0374, 0x0084, 3, 0x0678, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__USDHC1_CD                                       \
+		IOMUX_PAD(0x0374, 0x0084, 4, 0x0828, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__GPIO_4_15                                       \
+		IOMUX_PAD(0x0374, 0x0084, 5, 0x0000, 0, MX6SL_CHG_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__USB_USBOTG1_PWR                                 \
+		IOMUX_PAD(0x0374, 0x0084, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_ECSPI2_SS0__PL301_SIM_MX6SL_PER1_HADDR_24                   \
+		IOMUX_PAD(0x0374, 0x0084, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_BDR0__EPDC_BDR_0                                       \
+		IOMUX_PAD(0x0378, 0x0088, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__USDHC4_CLK                                       \
+		IOMUX_PAD(0x0378, 0x0088, 1, 0x0850, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__UART3_CTS                                        \
+		IOMUX_PAD(0x0378, 0x0088, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__UART3_RTS                                        \
+		IOMUX_PAD(0x0378, 0x0088, 2, 0x0808, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__WEIM_WEIM_A_26                                   \
+		IOMUX_PAD(0x0378, 0x0088, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__TCON_RL                                          \
+		IOMUX_PAD(0x0378, 0x0088, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__GPIO_2_5                                         \
+		IOMUX_PAD(0x0378, 0x0088, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__EPDC_SDCE_7                                      \
+		IOMUX_PAD(0x0378, 0x0088, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR0__MMDC_MMDC_DEBUG_9                                \
+		IOMUX_PAD(0x0378, 0x0088, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_BDR1__EPDC_BDR_1                                       \
+		IOMUX_PAD(0x037C, 0x008C, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__USDHC4_CMD                                       \
+		IOMUX_PAD(0x037C, 0x008C, 1, 0x0858, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__UART3_CTS                                        \
+		IOMUX_PAD(0x037C, 0x008C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__UART3_RTS                                        \
+		IOMUX_PAD(0x037C, 0x008C, 2, 0x0808, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__WEIM_WEIM_CRE                                    \
+		IOMUX_PAD(0x037C, 0x008C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__TCON_UD                                          \
+		IOMUX_PAD(0x037C, 0x008C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__GPIO_2_6                                         \
+		IOMUX_PAD(0x037C, 0x008C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__EPDC_SDCE_8                                      \
+		IOMUX_PAD(0x037C, 0x008C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_BDR1__MMDC_MMDC_DEBUG_8                                \
+		IOMUX_PAD(0x037C, 0x008C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D0__EPDC_SDDO_0                                        \
+		IOMUX_PAD(0x0380, 0x0090, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__ECSPI4_MOSI                                        \
+		IOMUX_PAD(0x0380, 0x0090, 1, 0x06D8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__LCDIF_DAT_24                                       \
+		IOMUX_PAD(0x0380, 0x0090, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__CSI_D_0                                            \
+		IOMUX_PAD(0x0380, 0x0090, 3, 0x0630, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__TCON_E_DATA_0                                      \
+		IOMUX_PAD(0x0380, 0x0090, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__GPIO_1_7                                           \
+		IOMUX_PAD(0x0380, 0x0090, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__ANATOP_USBPHY1_TSTI_TX_HS_MODE                     \
+		IOMUX_PAD(0x0380, 0x0090, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D0__OBSERVE_MUX_OUT_0                                  \
+		IOMUX_PAD(0x0380, 0x0090, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D1__EPDC_SDDO_1                                        \
+		IOMUX_PAD(0x0384, 0x0094, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__ECSPI4_MISO                                        \
+		IOMUX_PAD(0x0384, 0x0094, 1, 0x06D4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__LCDIF_DAT_25                                       \
+		IOMUX_PAD(0x0384, 0x0094, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__CSI_D_1                                            \
+		IOMUX_PAD(0x0384, 0x0094, 3, 0x0634, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__TCON_E_DATA_1                                      \
+		IOMUX_PAD(0x0384, 0x0094, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__GPIO_1_8                                           \
+		IOMUX_PAD(0x0384, 0x0094, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__ANATOP_USBPHY1_TSTI_TX_LS_MODE                     \
+		IOMUX_PAD(0x0384, 0x0094, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D1__OBSERVE_MUX_OUT_1                                  \
+		IOMUX_PAD(0x0384, 0x0094, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D10__EPDC_SDDO_10                                      \
+		IOMUX_PAD(0x0388, 0x0098, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__ECSPI3_SS0                                        \
+		IOMUX_PAD(0x0388, 0x0098, 1, 0x06C0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__EPDC_PWRCTRL_2                                    \
+		IOMUX_PAD(0x0388, 0x0098, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__WEIM_WEIM_A_18                                    \
+		IOMUX_PAD(0x0388, 0x0098, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__TCON_E_DATA_10                                    \
+		IOMUX_PAD(0x0388, 0x0098, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__GPIO_1_17                                         \
+		IOMUX_PAD(0x0388, 0x0098, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__USDHC4_WP                                         \
+		IOMUX_PAD(0x0388, 0x0098, 6, 0x087C, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D10__MMDC_MMDC_DEBUG_29                                \
+		IOMUX_PAD(0x0388, 0x0098, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D11__EPDC_SDDO_11                                      \
+		IOMUX_PAD(0x038C, 0x009C, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__ECSPI3_SCLK                                       \
+		IOMUX_PAD(0x038C, 0x009C, 1, 0x06B0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__EPDC_PWRCTRL_3                                    \
+		IOMUX_PAD(0x038C, 0x009C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__WEIM_WEIM_A_19                                    \
+		IOMUX_PAD(0x038C, 0x009C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__TCON_E_DATA_11                                    \
+		IOMUX_PAD(0x038C, 0x009C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__GPIO_1_18                                         \
+		IOMUX_PAD(0x038C, 0x009C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__USDHC4_CD                                         \
+		IOMUX_PAD(0x038C, 0x009C, 6, 0x0854, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D11__MMDC_MMDC_DEBUG_28                                \
+		IOMUX_PAD(0x038C, 0x009C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D12__EPDC_SDDO_12                                      \
+		IOMUX_PAD(0x0390, 0x00A0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__UART2_TXD                                         \
+		IOMUX_PAD(0x0390, 0x00A0, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__UART2_RXD                                         \
+		IOMUX_PAD(0x0390, 0x00A0, 1, 0x0804, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__EPDC_PWRCOM                                       \
+		IOMUX_PAD(0x0390, 0x00A0, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__WEIM_WEIM_A_20                                    \
+		IOMUX_PAD(0x0390, 0x00A0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__TCON_E_DATA_12                                    \
+		IOMUX_PAD(0x0390, 0x00A0, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__GPIO_1_19                                         \
+		IOMUX_PAD(0x0390, 0x00A0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__ECSPI3_SS1                                        \
+		IOMUX_PAD(0x0390, 0x00A0, 6, 0x06C4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D12__MMDC_MMDC_DEBUG_27                                \
+		IOMUX_PAD(0x0390, 0x00A0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D13__EPDC_SDDO_13                                      \
+		IOMUX_PAD(0x0394, 0x00A4, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__UART2_TXD                                         \
+		IOMUX_PAD(0x0394, 0x00A4, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__UART2_RXD                                         \
+		IOMUX_PAD(0x0394, 0x00A4, 1, 0x0804, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__EPDC_PWRIRQ                                       \
+		IOMUX_PAD(0x0394, 0x00A4, 2, 0x06E8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__WEIM_WEIM_A_21                                    \
+		IOMUX_PAD(0x0394, 0x00A4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__TCON_E_DATA_13                                    \
+		IOMUX_PAD(0x0394, 0x00A4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__GPIO_1_20                                         \
+		IOMUX_PAD(0x0394, 0x00A4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__ECSPI3_SS2                                        \
+		IOMUX_PAD(0x0394, 0x00A4, 6, 0x06C8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D13__MMDC_MMDC_DEBUG_26                                \
+		IOMUX_PAD(0x0394, 0x00A4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D14__EPDC_SDDO_14                                      \
+		IOMUX_PAD(0x0398, 0x00A8, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__UART2_CTS                                         \
+		IOMUX_PAD(0x0398, 0x00A8, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__UART2_RTS                                         \
+		IOMUX_PAD(0x0398, 0x00A8, 1, 0x0800, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__EPDC_PWRSTAT                                      \
+		IOMUX_PAD(0x0398, 0x00A8, 2, 0x06EC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__WEIM_WEIM_A_22                                    \
+		IOMUX_PAD(0x0398, 0x00A8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__TCON_E_DATA_14                                    \
+		IOMUX_PAD(0x0398, 0x00A8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__GPIO_1_21                                         \
+		IOMUX_PAD(0x0398, 0x00A8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__ECSPI3_SS3                                        \
+		IOMUX_PAD(0x0398, 0x00A8, 6, 0x06CC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D14__MMDC_MMDC_DEBUG_25                                \
+		IOMUX_PAD(0x0398, 0x00A8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D15__EPDC_SDDO_15                                      \
+		IOMUX_PAD(0x039C, 0x00AC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__UART2_CTS                                         \
+		IOMUX_PAD(0x039C, 0x00AC, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__UART2_RTS                                         \
+		IOMUX_PAD(0x039C, 0x00AC, 1, 0x0800, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__EPDC_PWRWAKE                                      \
+		IOMUX_PAD(0x039C, 0x00AC, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__WEIM_WEIM_A_23                                    \
+		IOMUX_PAD(0x039C, 0x00AC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__TCON_E_DATA_15                                    \
+		IOMUX_PAD(0x039C, 0x00AC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__GPIO_1_22                                         \
+		IOMUX_PAD(0x039C, 0x00AC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__ECSPI3_RDY                                        \
+		IOMUX_PAD(0x039C, 0x00AC, 6, 0x06B4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D15__MMDC_MMDC_DEBUG_24                                \
+		IOMUX_PAD(0x039C, 0x00AC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D2__EPDC_SDDO_2                                        \
+		IOMUX_PAD(0x03A0, 0x00B0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__ECSPI4_SS0                                         \
+		IOMUX_PAD(0x03A0, 0x00B0, 1, 0x06DC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__LCDIF_DAT_26                                       \
+		IOMUX_PAD(0x03A0, 0x00B0, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__CSI_D_2                                            \
+		IOMUX_PAD(0x03A0, 0x00B0, 3, 0x0638, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__TCON_E_DATA_2                                      \
+		IOMUX_PAD(0x03A0, 0x00B0, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__GPIO_1_9                                           \
+		IOMUX_PAD(0x03A0, 0x00B0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__ANATOP_USBPHY1_TSTI_TX_DN                          \
+		IOMUX_PAD(0x03A0, 0x00B0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D2__TPSMP_HDATA_28                                     \
+		IOMUX_PAD(0x03A0, 0x00B0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D3__EPDC_SDDO_3                                        \
+		IOMUX_PAD(0x03A4, 0x00B4, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__ECSPI4_SCLK                                        \
+		IOMUX_PAD(0x03A4, 0x00B4, 1, 0x06D0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__LCDIF_DAT_27                                       \
+		IOMUX_PAD(0x03A4, 0x00B4, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__CSI_D_3                                            \
+		IOMUX_PAD(0x03A4, 0x00B4, 3, 0x063C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__TCON_E_DATA_3                                      \
+		IOMUX_PAD(0x03A4, 0x00B4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__GPIO_1_10                                          \
+		IOMUX_PAD(0x03A4, 0x00B4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__ANATOP_USBPHY1_TSTI_TX_DP                          \
+		IOMUX_PAD(0x03A4, 0x00B4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D3__TPSMP_HDATA_29                                     \
+		IOMUX_PAD(0x03A4, 0x00B4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D4__EPDC_SDDO_4                                        \
+		IOMUX_PAD(0x03A8, 0x00B8, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__ECSPI4_SS1                                         \
+		IOMUX_PAD(0x03A8, 0x00B8, 1, 0x06E0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__LCDIF_DAT_28                                       \
+		IOMUX_PAD(0x03A8, 0x00B8, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__CSI_D_4                                            \
+		IOMUX_PAD(0x03A8, 0x00B8, 3, 0x0640, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__TCON_E_DATA_4                                      \
+		IOMUX_PAD(0x03A8, 0x00B8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__GPIO_1_11                                          \
+		IOMUX_PAD(0x03A8, 0x00B8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__ANATOP_USBPHY1_TSTI_TX_EN                          \
+		IOMUX_PAD(0x03A8, 0x00B8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D4__TPSMP_HDATA_30                                     \
+		IOMUX_PAD(0x03A8, 0x00B8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D5__EPDC_SDDO_5                                        \
+		IOMUX_PAD(0x03AC, 0x00BC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__ECSPI4_SS2                                         \
+		IOMUX_PAD(0x03AC, 0x00BC, 1, 0x06E4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__LCDIF_DAT_29                                       \
+		IOMUX_PAD(0x03AC, 0x00BC, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__CSI_D_5                                            \
+		IOMUX_PAD(0x03AC, 0x00BC, 3, 0x0644, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__TCON_E_DATA_5                                      \
+		IOMUX_PAD(0x03AC, 0x00BC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__GPIO_1_12                                          \
+		IOMUX_PAD(0x03AC, 0x00BC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__ANATOP_USBPHY1_TSTI_TX_HIZ                         \
+		IOMUX_PAD(0x03AC, 0x00BC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D5__TPSMP_HDATA_31                                     \
+		IOMUX_PAD(0x03AC, 0x00BC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D6__EPDC_SDDO_6                                        \
+		IOMUX_PAD(0x03B0, 0x00C0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__ECSPI4_SS3                                         \
+		IOMUX_PAD(0x03B0, 0x00C0, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__LCDIF_DAT_30                                       \
+		IOMUX_PAD(0x03B0, 0x00C0, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__CSI_D_6                                            \
+		IOMUX_PAD(0x03B0, 0x00C0, 3, 0x0648, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__TCON_E_DATA_6                                      \
+		IOMUX_PAD(0x03B0, 0x00C0, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__GPIO_1_13                                          \
+		IOMUX_PAD(0x03B0, 0x00C0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__ANATOP_USBPHY2_TSTO_RX_DISCON_DET                  \
+		IOMUX_PAD(0x03B0, 0x00C0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D6__TPSMP_HDATA_20                                     \
+		IOMUX_PAD(0x03B0, 0x00C0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D7__EPDC_SDDO_7                                        \
+		IOMUX_PAD(0x03B4, 0x00C4, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__ECSPI4_RDY                                         \
+		IOMUX_PAD(0x03B4, 0x00C4, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__LCDIF_DAT_31                                       \
+		IOMUX_PAD(0x03B4, 0x00C4, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__CSI_D_7                                            \
+		IOMUX_PAD(0x03B4, 0x00C4, 3, 0x064C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__TCON_E_DATA_7                                      \
+		IOMUX_PAD(0x03B4, 0x00C4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__GPIO_1_14                                          \
+		IOMUX_PAD(0x03B4, 0x00C4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__ANATOP_USBPHY2_TSTO_RX_FS_RXD                      \
+		IOMUX_PAD(0x03B4, 0x00C4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D7__MMDC_MMDC_DEBUG_32                                 \
+		IOMUX_PAD(0x03B4, 0x00C4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D8__EPDC_SDDO_8                                        \
+		IOMUX_PAD(0x03B8, 0x00C8, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__ECSPI3_MOSI                                        \
+		IOMUX_PAD(0x03B8, 0x00C8, 1, 0x06BC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__EPDC_PWRCTRL_0                                     \
+		IOMUX_PAD(0x03B8, 0x00C8, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__WEIM_WEIM_A_16                                     \
+		IOMUX_PAD(0x03B8, 0x00C8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__TCON_E_DATA_8                                      \
+		IOMUX_PAD(0x03B8, 0x00C8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__GPIO_1_15                                          \
+		IOMUX_PAD(0x03B8, 0x00C8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__USDHC4_RST                                         \
+		IOMUX_PAD(0x03B8, 0x00C8, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D8__MMDC_MMDC_DEBUG_31                                 \
+		IOMUX_PAD(0x03B8, 0x00C8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_D9__EPDC_SDDO_9                                        \
+		IOMUX_PAD(0x03BC, 0x00CC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__ECSPI3_MISO                                        \
+		IOMUX_PAD(0x03BC, 0x00CC, 1, 0x06B8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__EPDC_PWRCTRL_1                                     \
+		IOMUX_PAD(0x03BC, 0x00CC, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__WEIM_WEIM_A_17                                     \
+		IOMUX_PAD(0x03BC, 0x00CC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__TCON_E_DATA_9                                      \
+		IOMUX_PAD(0x03BC, 0x00CC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__GPIO_1_16                                          \
+		IOMUX_PAD(0x03BC, 0x00CC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__USDHC4_VSELECT                                     \
+		IOMUX_PAD(0x03BC, 0x00CC, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_D9__MMDC_MMDC_DEBUG_30                                 \
+		IOMUX_PAD(0x03BC, 0x00CC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_GDCLK__EPDC_GDCLK                                      \
+		IOMUX_PAD(0x03C0, 0x00D0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__ECSPI2_SS2                                      \
+		IOMUX_PAD(0x03C0, 0x00D0, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__TCON_YCKR                                       \
+		IOMUX_PAD(0x03C0, 0x00D0, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__CSI_PIXCLK                                      \
+		IOMUX_PAD(0x03C0, 0x00D0, 3, 0x0674, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__TCON_YCKL                                       \
+		IOMUX_PAD(0x03C0, 0x00D0, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__GPIO_1_31                                       \
+		IOMUX_PAD(0x03C0, 0x00D0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__USDHC2_RST                                      \
+		IOMUX_PAD(0x03C0, 0x00D0, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDCLK__MMDC_MMDC_DEBUG_15                              \
+		IOMUX_PAD(0x03C0, 0x00D0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_GDOE__EPDC_GDOE                                        \
+		IOMUX_PAD(0x03C4, 0x00D4, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__ECSPI2_SS3                                       \
+		IOMUX_PAD(0x03C4, 0x00D4, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__TCON_YOER                                        \
+		IOMUX_PAD(0x03C4, 0x00D4, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__CSI_HSYNC                                        \
+		IOMUX_PAD(0x03C4, 0x00D4, 3, 0x0670, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__TCON_YOEL                                        \
+		IOMUX_PAD(0x03C4, 0x00D4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__GPIO_2_0                                         \
+		IOMUX_PAD(0x03C4, 0x00D4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__USDHC2_VSELECT                                   \
+		IOMUX_PAD(0x03C4, 0x00D4, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDOE__MMDC_MMDC_DEBUG_14                               \
+		IOMUX_PAD(0x03C4, 0x00D4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_GDRL__EPDC_GDRL                                        \
+		IOMUX_PAD(0x03C8, 0x00D8, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__ECSPI2_RDY                                       \
+		IOMUX_PAD(0x03C8, 0x00D8, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__TCON_YDIOUR                                      \
+		IOMUX_PAD(0x03C8, 0x00D8, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__CSI_MCLK                                         \
+		IOMUX_PAD(0x03C8, 0x00D8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__TCON_YDIOUL                                      \
+		IOMUX_PAD(0x03C8, 0x00D8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__GPIO_2_1                                         \
+		IOMUX_PAD(0x03C8, 0x00D8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__USDHC2_WP                                        \
+		IOMUX_PAD(0x03C8, 0x00D8, 6, 0x0834, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDRL__MMDC_MMDC_DEBUG_13                               \
+		IOMUX_PAD(0x03C8, 0x00D8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_GDSP__EPDC_GDSP                                        \
+		IOMUX_PAD(0x03CC, 0x00DC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__PWM4_PWMO                                        \
+		IOMUX_PAD(0x03CC, 0x00DC, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__TCON_YDIODR                                      \
+		IOMUX_PAD(0x03CC, 0x00DC, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__CSI_VSYNC                                        \
+		IOMUX_PAD(0x03CC, 0x00DC, 3, 0x0678, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__TCON_YDIODL                                      \
+		IOMUX_PAD(0x03CC, 0x00DC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__GPIO_2_2                                         \
+		IOMUX_PAD(0x03CC, 0x00DC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__USDHC2_CD                                        \
+		IOMUX_PAD(0x03CC, 0x00DC, 6, 0x0830, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_GDSP__MMDC_MMDC_DEBUG_12                               \
+		IOMUX_PAD(0x03CC, 0x00DC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRCOM__EPDC_PWRCOM                                    \
+		IOMUX_PAD(0x03D0, 0x00E0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__USDHC4_DAT0                                    \
+		IOMUX_PAD(0x03D0, 0x00E0, 1, 0x085C, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__LCDIF_DAT_20                                   \
+		IOMUX_PAD(0x03D0, 0x00E0, 2, 0x07C8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__WEIM_WEIM_BCLK                                 \
+		IOMUX_PAD(0x03D0, 0x00E0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID                              \
+		IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__GPIO_2_11                                      \
+		IOMUX_PAD(0x03D0, 0x00E0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__USDHC3_RST                                     \
+		IOMUX_PAD(0x03D0, 0x00E0, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCOM__MMDC_MMDC_DEBUG_3                              \
+		IOMUX_PAD(0x03D0, 0x00E0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRCTRL0__EPDC_PWRCTRL_0                               \
+		IOMUX_PAD(0x03D4, 0x00E4, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__AUDMUX_AUD5_RXC                              \
+		IOMUX_PAD(0x03D4, 0x00E4, 1, 0x0604, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__LCDIF_DAT_16                                 \
+		IOMUX_PAD(0x03D4, 0x00E4, 2, 0x07B8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__WEIM_WEIM_RW                                 \
+		IOMUX_PAD(0x03D4, 0x00E4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__TCON_YCKL                                    \
+		IOMUX_PAD(0x03D4, 0x00E4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7                                     \
+		IOMUX_PAD(0x03D4, 0x00E4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__USDHC4_RST                                   \
+		IOMUX_PAD(0x03D4, 0x00E4, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL0__MMDC_MMDC_DEBUG_7                            \
+		IOMUX_PAD(0x03D4, 0x00E4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRCTRL1__EPDC_PWRCTRL_1                               \
+		IOMUX_PAD(0x03D8, 0x00E8, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__AUDMUX_AUD5_TXFS                             \
+		IOMUX_PAD(0x03D8, 0x00E8, 1, 0x0610, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__LCDIF_DAT_17                                 \
+		IOMUX_PAD(0x03D8, 0x00E8, 2, 0x07BC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__WEIM_WEIM_OE                                 \
+		IOMUX_PAD(0x03D8, 0x00E8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__TCON_YOEL                                    \
+		IOMUX_PAD(0x03D8, 0x00E8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__GPIO_2_8                                     \
+		IOMUX_PAD(0x03D8, 0x00E8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__USDHC4_VSELECT                               \
+		IOMUX_PAD(0x03D8, 0x00E8, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL1__MMDC_MMDC_DEBUG_6                            \
+		IOMUX_PAD(0x03D8, 0x00E8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRCTRL2__EPDC_PWRCTRL_2                               \
+		IOMUX_PAD(0x03DC, 0x00EC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__AUDMUX_AUD5_TXD                              \
+		IOMUX_PAD(0x03DC, 0x00EC, 1, 0x0600, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__LCDIF_DAT_18                                 \
+		IOMUX_PAD(0x03DC, 0x00EC, 2, 0x07C0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__WEIM_WEIM_CS_0                               \
+		IOMUX_PAD(0x03DC, 0x00EC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__TCON_YDIOUL                                  \
+		IOMUX_PAD(0x03DC, 0x00EC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__GPIO_2_9                                     \
+		IOMUX_PAD(0x03DC, 0x00EC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__USDHC4_WP                                    \
+		IOMUX_PAD(0x03DC, 0x00EC, 6, 0x087C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL2__MMDC_MMDC_DEBUG_5                            \
+		IOMUX_PAD(0x03DC, 0x00EC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRCTRL3__EPDC_PWRCTRL_3                               \
+		IOMUX_PAD(0x03E0, 0x00F0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__AUDMUX_AUD5_TXC                              \
+		IOMUX_PAD(0x03E0, 0x00F0, 1, 0x060C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__LCDIF_DAT_19                                 \
+		IOMUX_PAD(0x03E0, 0x00F0, 2, 0x07C4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__WEIM_WEIM_CS_1                               \
+		IOMUX_PAD(0x03E0, 0x00F0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__TCON_YDIODL                                  \
+		IOMUX_PAD(0x03E0, 0x00F0, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__GPIO_2_10                                    \
+		IOMUX_PAD(0x03E0, 0x00F0, 5, 0x0000, 0, MX6SL_TSPAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__USDHC4_CD                                    \
+		IOMUX_PAD(0x03E0, 0x00F0, 6, 0x0854, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRCTRL3__MMDC_MMDC_DEBUG_4                            \
+		IOMUX_PAD(0x03E0, 0x00F0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRINT__EPDC_PWRIRQ                                    \
+		IOMUX_PAD(0x03E4, 0x00F4, 0, 0x06E8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__USDHC4_DAT1                                    \
+		IOMUX_PAD(0x03E4, 0x00F4, 1, 0x0860, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__LCDIF_DAT_21                                   \
+		IOMUX_PAD(0x03E4, 0x00F4, 2, 0x07CC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__WEIM_ACLK_FREERUN                              \
+		IOMUX_PAD(0x03E4, 0x00F4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__ANATOP_USBOTG2_ID                              \
+		IOMUX_PAD(0x03E4, 0x00F4, 4, 0x05E0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__GPIO_2_12                                      \
+		IOMUX_PAD(0x03E4, 0x00F4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__USDHC3_VSELECT                                 \
+		IOMUX_PAD(0x03E4, 0x00F4, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRINT__MMDC_MMDC_DEBUG_2                              \
+		IOMUX_PAD(0x03E4, 0x00F4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRSTAT__EPDC_PWRSTAT                                  \
+		IOMUX_PAD(0x03E8, 0x00F8, 0, 0x06EC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__USDHC4_DAT2                                   \
+		IOMUX_PAD(0x03E8, 0x00F8, 1, 0x0864, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__LCDIF_DAT_22                                  \
+		IOMUX_PAD(0x03E8, 0x00F8, 2, 0x07D0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__WEIM_WEIM_WAIT                                \
+		IOMUX_PAD(0x03E8, 0x00F8, 3, 0x0884, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__KITTEN_EVENTI                                 \
+		IOMUX_PAD(0x03E8, 0x00F8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13                                     \
+		IOMUX_PAD(0x03E8, 0x00F8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__USDHC3_WP                                     \
+		IOMUX_PAD(0x03E8, 0x00F8, 6, 0x084C, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRSTAT__MMDC_MMDC_DEBUG_1                             \
+		IOMUX_PAD(0x03E8, 0x00F8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_PWRWAKEUP__EPDC_PWRWAKE                                \
+		IOMUX_PAD(0x03EC, 0x00FC, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__USDHC4_DAT3                                 \
+		IOMUX_PAD(0x03EC, 0x00FC, 1, 0x0868, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__LCDIF_DAT_23                                \
+		IOMUX_PAD(0x03EC, 0x00FC, 2, 0x07D4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__WEIM_WEIM_DTACK_B                           \
+		IOMUX_PAD(0x03EC, 0x00FC, 3, 0x0880, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__KITTEN_EVENTO                               \
+		IOMUX_PAD(0x03EC, 0x00FC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14                                   \
+		IOMUX_PAD(0x03EC, 0x00FC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__USDHC3_CD                                   \
+		IOMUX_PAD(0x03EC, 0x00FC, 6, 0x0838, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_EPDC_PWRWAKEUP__MMDC_MMDC_DEBUG_0                           \
+		IOMUX_PAD(0x03EC, 0x00FC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDCE0__EPDC_SDCE_0                                     \
+		IOMUX_PAD(0x03F0, 0x0100, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__ECSPI2_SS1                                      \
+		IOMUX_PAD(0x03F0, 0x0100, 1, 0x06AC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__PWM3_PWMO                                       \
+		IOMUX_PAD(0x03F0, 0x0100, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__WEIM_WEIM_CS_2                                  \
+		IOMUX_PAD(0x03F0, 0x0100, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__TCON_YCKR                                       \
+		IOMUX_PAD(0x03F0, 0x0100, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__GPIO_1_27                                       \
+		IOMUX_PAD(0x03F0, 0x0100, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__ANATOP_USBPHY1_TSTO_PLL_CLK20DIV                \
+		IOMUX_PAD(0x03F0, 0x0100, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE0__MMDC_MMDC_DEBUG_19                              \
+		IOMUX_PAD(0x03F0, 0x0100, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDCE1__EPDC_SDCE_1                                     \
+		IOMUX_PAD(0x03F4, 0x0104, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__WDOG2_WDOG_B                                    \
+		IOMUX_PAD(0x03F4, 0x0104, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__PWM4_PWMO                                       \
+		IOMUX_PAD(0x03F4, 0x0104, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__WEIM_WEIM_LBA                                   \
+		IOMUX_PAD(0x03F4, 0x0104, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__TCON_YOER                                       \
+		IOMUX_PAD(0x03F4, 0x0104, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__GPIO_1_28                                       \
+		IOMUX_PAD(0x03F4, 0x0104, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__ANATOP_USBPHY1_TSTO_RX_FS_RXD                   \
+		IOMUX_PAD(0x03F4, 0x0104, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE1__MMDC_MMDC_DEBUG_18                              \
+		IOMUX_PAD(0x03F4, 0x0104, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDCE2__EPDC_SDCE_2                                     \
+		IOMUX_PAD(0x03F8, 0x0108, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__I2C3_SCL                                        \
+		IOMUX_PAD(0x03F8, 0x0108, 1 | IOMUX_CONFIG_SION, 0x072C, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__PWM1_PWMO                                       \
+		IOMUX_PAD(0x03F8, 0x0108, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__WEIM_WEIM_EB_0                                  \
+		IOMUX_PAD(0x03F8, 0x0108, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__TCON_YDIOUR                                     \
+		IOMUX_PAD(0x03F8, 0x0108, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__GPIO_1_29                                       \
+		IOMUX_PAD(0x03F8, 0x0108, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__ANATOP_USBPHY1_TSTO_RX_HS_RXD                   \
+		IOMUX_PAD(0x03F8, 0x0108, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE2__MMDC_MMDC_DEBUG_17                              \
+		IOMUX_PAD(0x03F8, 0x0108, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDCE3__EPDC_SDCE_3                                     \
+		IOMUX_PAD(0x03FC, 0x010C, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__I2C3_SDA                                        \
+		IOMUX_PAD(0x03FC, 0x010C, 1 | IOMUX_CONFIG_SION, 0x0730, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__PWM2_PWMO                                       \
+		IOMUX_PAD(0x03FC, 0x010C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__WEIM_WEIM_EB_1                                  \
+		IOMUX_PAD(0x03FC, 0x010C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__TCON_YDIODR                                     \
+		IOMUX_PAD(0x03FC, 0x010C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__GPIO_1_30                                       \
+		IOMUX_PAD(0x03FC, 0x010C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__ANATOP_USBPHY1_TSTO_RX_SQUELCH                  \
+		IOMUX_PAD(0x03FC, 0x010C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCE3__MMDC_MMDC_DEBUG_16                              \
+		IOMUX_PAD(0x03FC, 0x010C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDCLK__EPDC_SDCLK                                      \
+		IOMUX_PAD(0x0400, 0x0110, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__ECSPI2_MOSI                                     \
+		IOMUX_PAD(0x0400, 0x0110, 1, 0x06A4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__I2C2_SCL                                        \
+		IOMUX_PAD(0x0400, 0x0110, 2 | IOMUX_CONFIG_SION, 0x0724, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__CSI_D_8                                         \
+		IOMUX_PAD(0x0400, 0x0110, 3, 0x0650, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__TCON_CL                                         \
+		IOMUX_PAD(0x0400, 0x0110, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__GPIO_1_23                                       \
+		IOMUX_PAD(0x0400, 0x0110, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__ANATOP_USBPHY2_TSTO_RX_HS_RXD                   \
+		IOMUX_PAD(0x0400, 0x0110, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDCLK__MMDC_MMDC_DEBUG_23                              \
+		IOMUX_PAD(0x0400, 0x0110, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDLE__EPDC_SDLE                                        \
+		IOMUX_PAD(0x0404, 0x0114, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__ECSPI2_MISO                                      \
+		IOMUX_PAD(0x0404, 0x0114, 1, 0x06A0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__I2C2_SDA                                         \
+		IOMUX_PAD(0x0404, 0x0114, 2 | IOMUX_CONFIG_SION, 0x0728, 0, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__CSI_D_9                                          \
+		IOMUX_PAD(0x0404, 0x0114, 3, 0x0654, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__TCON_LD                                          \
+		IOMUX_PAD(0x0404, 0x0114, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__GPIO_1_24                                        \
+		IOMUX_PAD(0x0404, 0x0114, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__ANATOP_USBPHY2_TSTO_RX_SQUELCH                   \
+		IOMUX_PAD(0x0404, 0x0114, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDLE__MMDC_MMDC_DEBUG_22                               \
+		IOMUX_PAD(0x0404, 0x0114, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDOE__EPDC_SDOE                                        \
+		IOMUX_PAD(0x0408, 0x0118, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__ECSPI2_SS0                                       \
+		IOMUX_PAD(0x0408, 0x0118, 1, 0x06A8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__TCON_XDIOR                                       \
+		IOMUX_PAD(0x0408, 0x0118, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__CSI_D_10                                         \
+		IOMUX_PAD(0x0408, 0x0118, 3, 0x0658, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__TCON_XDIOL                                       \
+		IOMUX_PAD(0x0408, 0x0118, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__GPIO_1_25                                        \
+		IOMUX_PAD(0x0408, 0x0118, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__ANATOP_USBPHY2_TSTO_PLL_CLK20DIV                 \
+		IOMUX_PAD(0x0408, 0x0118, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDOE__MMDC_MMDC_DEBUG_21                               \
+		IOMUX_PAD(0x0408, 0x0118, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_SDSHR__EPDC_SDSHR                                      \
+		IOMUX_PAD(0x040C, 0x011C, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__ECSPI2_SCLK                                     \
+		IOMUX_PAD(0x040C, 0x011C, 1, 0x069C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__EPDC_SDCE_4                                     \
+		IOMUX_PAD(0x040C, 0x011C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__CSI_D_11                                        \
+		IOMUX_PAD(0x040C, 0x011C, 3, 0x065C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__TCON_XDIOR                                      \
+		IOMUX_PAD(0x040C, 0x011C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__GPIO_1_26                                       \
+		IOMUX_PAD(0x040C, 0x011C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__ANATOP_USBPHY1_TSTO_RX_DISCON_DET               \
+		IOMUX_PAD(0x040C, 0x011C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_SDSHR__MMDC_MMDC_DEBUG_20                              \
+		IOMUX_PAD(0x040C, 0x011C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_VCOM0__EPDC_VCOM_0                                     \
+		IOMUX_PAD(0x0410, 0x0120, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__AUDMUX_AUD5_RXFS                                \
+		IOMUX_PAD(0x0410, 0x0120, 1, 0x0608, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__UART3_TXD                                       \
+		IOMUX_PAD(0x0410, 0x0120, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__UART3_RXD                                       \
+		IOMUX_PAD(0x0410, 0x0120, 2, 0x080C, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__WEIM_WEIM_A_24                                  \
+		IOMUX_PAD(0x0410, 0x0120, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__TCON_VCOM_0                                     \
+		IOMUX_PAD(0x0410, 0x0120, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__GPIO_2_3                                        \
+		IOMUX_PAD(0x0410, 0x0120, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__EPDC_SDCE_5                                     \
+		IOMUX_PAD(0x0410, 0x0120, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM0__MMDC_MMDC_DEBUG_11                              \
+		IOMUX_PAD(0x0410, 0x0120, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_EPDC_VCOM1__EPDC_VCOM_1                                     \
+		IOMUX_PAD(0x0414, 0x0124, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__AUDMUX_AUD5_RXD                                 \
+		IOMUX_PAD(0x0414, 0x0124, 1, 0x05FC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__UART3_TXD                                       \
+		IOMUX_PAD(0x0414, 0x0124, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__UART3_RXD                                       \
+		IOMUX_PAD(0x0414, 0x0124, 2, 0x080C, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__WEIM_WEIM_A_25                                  \
+		IOMUX_PAD(0x0414, 0x0124, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__TCON_VCOM_1                                     \
+		IOMUX_PAD(0x0414, 0x0124, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__GPIO_2_4                                        \
+		IOMUX_PAD(0x0414, 0x0124, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__EPDC_SDCE_6                                     \
+		IOMUX_PAD(0x0414, 0x0124, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_EPDC_VCOM1__MMDC_MMDC_DEBUG_10                              \
+		IOMUX_PAD(0x0414, 0x0124, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_CRS_DV__FEC_RX_DV                                       \
+		IOMUX_PAD(0x0418, 0x0128, 0, 0x0704, 1, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__USDHC4_DAT1                                     \
+		IOMUX_PAD(0x0418, 0x0128, 1, 0x0860, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__AUDMUX_AUD6_TXC                                 \
+		IOMUX_PAD(0x0418, 0x0128, 2, 0x0624, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__ECSPI4_MISO                                     \
+		IOMUX_PAD(0x0418, 0x0128, 3, 0x06D4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__GPT_CMPOUT2                                     \
+		IOMUX_PAD(0x0418, 0x0128, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__GPIO_4_25                                       \
+		IOMUX_PAD(0x0418, 0x0128, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__KITTEN_TRACE_31                                 \
+		IOMUX_PAD(0x0418, 0x0128, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_CRS_DV__PL301_SIM_MX6SL_PER1_HADDR_3                    \
+		IOMUX_PAD(0x0418, 0x0128, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_MDC__FEC_MDC                                            \
+		IOMUX_PAD(0x041C, 0x012C, 0, 0x0000, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__USDHC4_DAT4                                        \
+		IOMUX_PAD(0x041C, 0x012C, 1, 0x086C, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__AUDMUX_AUDIO_CLK_OUT                               \
+		IOMUX_PAD(0x041C, 0x012C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__USDHC1_RST                                         \
+		IOMUX_PAD(0x041C, 0x012C, 3, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__USDHC3_RST                                         \
+		IOMUX_PAD(0x041C, 0x012C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__GPIO_4_23                                          \
+		IOMUX_PAD(0x041C, 0x012C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__KITTEN_TRACE_29                                    \
+		IOMUX_PAD(0x041C, 0x012C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDC__PL301_SIM_MX6SL_PER1_HADDR_8                       \
+		IOMUX_PAD(0x041C, 0x012C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_MDIO__FEC_MDIO                                          \
+		IOMUX_PAD(0x0420, 0x0130, 0, 0x06F4, 1, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__USDHC4_CLK                                        \
+		IOMUX_PAD(0x0420, 0x0130, 1, 0x0850, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__AUDMUX_AUD6_RXFS                                  \
+		IOMUX_PAD(0x0420, 0x0130, 2, 0x0620, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__ECSPI4_SS0                                        \
+		IOMUX_PAD(0x0420, 0x0130, 3, 0x06DC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__GPT_CAPIN1                                        \
+		IOMUX_PAD(0x0420, 0x0130, 4, 0x0710, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__GPIO_4_20                                         \
+		IOMUX_PAD(0x0420, 0x0130, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__KITTEN_TRACE_26                                   \
+		IOMUX_PAD(0x0420, 0x0130, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_MDIO__PL301_SIM_MX6SL_PER1_HADDR_15                     \
+		IOMUX_PAD(0x0420, 0x0130, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_REF_CLK__FEC_REF_OUT                                    \
+		IOMUX_PAD(0x0424, 0x0134, 0x10, 0x0000, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__USDHC4_RST                                     \
+		IOMUX_PAD(0x0424, 0x0134, 1, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__WDOG1_WDOG_B                                   \
+		IOMUX_PAD(0x0424, 0x0134, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__PWM4_PWMO                                      \
+		IOMUX_PAD(0x0424, 0x0134, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__CCM_PMIC_RDY                                   \
+		IOMUX_PAD(0x0424, 0x0134, 4, 0x062C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__GPIO_4_26                                      \
+		IOMUX_PAD(0x0424, 0x0134, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__SPDIF_SPDIF_EXT_CLK                            \
+		IOMUX_PAD(0x0424, 0x0134, 6, 0x07F4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_REF_CLK__PL301_SIM_MX6SL_PER1_HADDR_0                   \
+		IOMUX_PAD(0x0424, 0x0134, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_RX_ER__GPIO_4_19                                        \
+		IOMUX_PAD(0x0428, 0x0138, 5, 0x0000, 0, MX6SL_HP_DET_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__KITTEN_TRACE_25                                  \
+		IOMUX_PAD(0x0428, 0x0138, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__PL301_SIM_MX6SL_PER1_HADDR_5                     \
+		IOMUX_PAD(0x0428, 0x0138, 7, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__FEC_RX_ER                                        \
+		IOMUX_PAD(0x0428, 0x0138, 0, 0x0708, 1, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__USDHC4_DAT0                                      \
+		IOMUX_PAD(0x0428, 0x0138, 1, 0x085C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__AUDMUX_AUD6_RXD                                  \
+		IOMUX_PAD(0x0428, 0x0138, 2, 0x0614, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__ECSPI4_MOSI                                      \
+		IOMUX_PAD(0x0428, 0x0138, 3, 0x06D8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RX_ER__GPT_CMPOUT1                                      \
+		IOMUX_PAD(0x0428, 0x0138, 4, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_RXD0__FEC_RDATA_0                                       \
+		IOMUX_PAD(0x042C, 0x013C, 0, 0x06F8, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__USDHC4_DAT5                                       \
+		IOMUX_PAD(0x042C, 0x013C, 1, 0x0870, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__ANATOP_USBOTG1_ID                                 \
+		IOMUX_PAD(0x042C, 0x013C, 2, 0x05DC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__USDHC1_VSELECT                                    \
+		IOMUX_PAD(0x042C, 0x013C, 3, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__USDHC3_VSELECT                                    \
+		IOMUX_PAD(0x042C, 0x013C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__GPIO_4_17                                         \
+		IOMUX_PAD(0x042C, 0x013C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__KITTEN_TRACE_24                                   \
+		IOMUX_PAD(0x042C, 0x013C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD0__PL301_SIM_MX6SL_PER1_HADDR_7                      \
+		IOMUX_PAD(0x042C, 0x013C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_RXD1__FEC_RDATA_1                                       \
+		IOMUX_PAD(0x0430, 0x0140, 0, 0x06FC, 1, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__USDHC4_DAT2                                       \
+		IOMUX_PAD(0x0430, 0x0140, 1, 0x0864, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__AUDMUX_AUD6_TXFS                                  \
+		IOMUX_PAD(0x0430, 0x0140, 2, 0x0628, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__ECSPI4_SS1                                        \
+		IOMUX_PAD(0x0430, 0x0140, 3, 0x06E0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__GPT_CMPOUT3                                       \
+		IOMUX_PAD(0x0430, 0x0140, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__GPIO_4_18                                         \
+		IOMUX_PAD(0x0430, 0x0140, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__FEC_COL                                           \
+		IOMUX_PAD(0x0430, 0x0140, 6, 0x06F0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_RXD1__PL301_SIM_MX6SL_PER1_HADDR_9                      \
+		IOMUX_PAD(0x0430, 0x0140, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_TX_CLK__FEC_TX_CLK                                      \
+		IOMUX_PAD(0x0434, 0x0144, 0, 0x070C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__USDHC4_CMD                                      \
+		IOMUX_PAD(0x0434, 0x0144, 1, 0x0858, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__AUDMUX_AUD6_RXC                                 \
+		IOMUX_PAD(0x0434, 0x0144, 2, 0x061C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__ECSPI4_SCLK                                     \
+		IOMUX_PAD(0x0434, 0x0144, 3, 0x06D0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__GPT_CAPIN2                                      \
+		IOMUX_PAD(0x0434, 0x0144, 4, 0x0714, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__GPIO_4_21                                       \
+		IOMUX_PAD(0x0434, 0x0144, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__KITTEN_TRACE_27                                 \
+		IOMUX_PAD(0x0434, 0x0144, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_CLK__PL301_SIM_MX6SL_PER1_HADDR_4                    \
+		IOMUX_PAD(0x0434, 0x0144, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_TX_EN__FEC_TX_EN                                        \
+		IOMUX_PAD(0x0438, 0x0148, 0, 0x0000, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__USDHC4_DAT6                                      \
+		IOMUX_PAD(0x0438, 0x0148, 1, 0x0874, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__SPDIF_IN1                                        \
+		IOMUX_PAD(0x0438, 0x0148, 2, 0x07F0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__USDHC1_WP                                        \
+		IOMUX_PAD(0x0438, 0x0148, 3, 0x082C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__USDHC3_WP                                        \
+		IOMUX_PAD(0x0438, 0x0148, 4, 0x084C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__GPIO_4_22                                        \
+		IOMUX_PAD(0x0438, 0x0148, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__KITTEN_TRACE_28                                  \
+		IOMUX_PAD(0x0438, 0x0148, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TX_EN__PL301_SIM_MX6SL_PER1_HADDR_1                     \
+		IOMUX_PAD(0x0438, 0x0148, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_TXD0__FEC_TDATA_0                                       \
+		IOMUX_PAD(0x043C, 0x014C, 0, 0x0000, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__USDHC4_DAT3                                       \
+		IOMUX_PAD(0x043C, 0x014C, 1, 0x0868, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__AUDMUX_AUD6_TXD                                   \
+		IOMUX_PAD(0x043C, 0x014C, 2, 0x0618, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__ECSPI4_SS2                                        \
+		IOMUX_PAD(0x043C, 0x014C, 3, 0x06E4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__GPT_CLKIN                                         \
+		IOMUX_PAD(0x043C, 0x014C, 4, 0x0718, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__GPIO_4_24                                         \
+		IOMUX_PAD(0x043C, 0x014C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__KITTEN_TRACE_30                                   \
+		IOMUX_PAD(0x043C, 0x014C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD0__PL301_SIM_MX6SL_PER1_HADDR_2                      \
+		IOMUX_PAD(0x043C, 0x014C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_FEC_TXD1__FEC_TDATA_1                                       \
+		IOMUX_PAD(0x0440, 0x0150, 0, 0x0000, 0, MX6SL_ENET_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__USDHC4_DAT7                                       \
+		IOMUX_PAD(0x0440, 0x0150, 1, 0x0878, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__SPDIF_OUT1                                        \
+		IOMUX_PAD(0x0440, 0x0150, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__USDHC1_CD                                         \
+		IOMUX_PAD(0x0440, 0x0150, 3, 0x0828, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__USDHC3_CD                                         \
+		IOMUX_PAD(0x0440, 0x0150, 4, 0x0838, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__GPIO_4_16                                         \
+		IOMUX_PAD(0x0440, 0x0150, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__FEC_RX_CLK                                        \
+		IOMUX_PAD(0x0440, 0x0150, 6, 0x0700, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_FEC_TXD1__PL301_SIM_MX6SL_PER1_HADDR_6                      \
+		IOMUX_PAD(0x0440, 0x0150, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_HSIC_DAT__USB_H_DATA                                        \
+		IOMUX_PAD(0x0444, 0x0154, 0, 0x0000, 0, MX6SL_USB_HSIC_PAD_CTRL)
+#define MX6SL_PAD_HSIC_DAT__I2C1_SCL                                          \
+		IOMUX_PAD(0x0444, 0x0154, 1 | IOMUX_CONFIG_SION, 0x071C, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_HSIC_DAT__PWM1_PWMO                                         \
+		IOMUX_PAD(0x0444, 0x0154, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_HSIC_DAT__ANATOP_ANATOP_24M_OUT                             \
+		IOMUX_PAD(0x0444, 0x0154, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_HSIC_DAT__OSC32K_32K_OUT                                    \
+		IOMUX_PAD(0x0444, 0x0154, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_HSIC_DAT__GPIO_3_19                                         \
+		IOMUX_PAD(0x0444, 0x0154, 5, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_HSIC_STROBE__USB_H_STROBE                                   \
+		IOMUX_PAD(0x0448, 0x0158, 0, 0x0000, 0, MX6SL_USB_HSIC_PAD_CTRL)
+#define MX6SL_PAD_HSIC_STROBE__USB_H_STROBE_START                                   \
+		IOMUX_PAD(0x0448, 0x0158, 0, 0x0000, 0, MX6SL_USB_HSIC_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+#define MX6SL_PAD_HSIC_STROBE__I2C1_SDA                                       \
+		IOMUX_PAD(0x0448, 0x0158, 1 | IOMUX_CONFIG_SION, 0x0720, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_HSIC_STROBE__PWM2_PWMO                                      \
+		IOMUX_PAD(0x0448, 0x0158, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_HSIC_STROBE__ANATOP_ANATOP_32K_OUT                          \
+		IOMUX_PAD(0x0448, 0x0158, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_HSIC_STROBE__GPIO_3_20                                      \
+		IOMUX_PAD(0x0448, 0x0158, 5, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_I2C1_SCL__I2C1_SCL                                          \
+		IOMUX_PAD(0x044C, 0x015C, 0 | IOMUX_CONFIG_SION, 0x071C, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__UART1_CTS                                         \
+		IOMUX_PAD(0x044C, 0x015C, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__UART1_RTS                                         \
+		IOMUX_PAD(0x044C, 0x015C, 1, 0x07F8, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__ECSPI3_SS2                                        \
+		IOMUX_PAD(0x044C, 0x015C, 2, 0x06C8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__FEC_RDATA_0                                       \
+		IOMUX_PAD(0x044C, 0x015C, 3, 0x06F8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__USDHC3_RST                                        \
+		IOMUX_PAD(0x044C, 0x015C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__GPIO_3_12                                         \
+		IOMUX_PAD(0x044C, 0x015C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__ECSPI1_SS1                                        \
+		IOMUX_PAD(0x044C, 0x015C, 6, 0x0690, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SCL__PL301_SIM_MX6SL_PER1_HSIZE_0                      \
+		IOMUX_PAD(0x044C, 0x015C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_I2C1_SDA__I2C1_SDA                                          \
+		IOMUX_PAD(0x0450, 0x0160, 0 | IOMUX_CONFIG_SION, 0x0720, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__UART1_CTS                                         \
+		IOMUX_PAD(0x0450, 0x0160, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__UART1_RTS                                         \
+		IOMUX_PAD(0x0450, 0x0160, 1, 0x07F8, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__ECSPI3_SS3                                        \
+		IOMUX_PAD(0x0450, 0x0160, 2, 0x06CC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__FEC_TX_EN                                         \
+		IOMUX_PAD(0x0450, 0x0160, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__USDHC3_VSELECT                                    \
+		IOMUX_PAD(0x0450, 0x0160, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__GPIO_3_13                                         \
+		IOMUX_PAD(0x0450, 0x0160, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__ECSPI1_SS2                                        \
+		IOMUX_PAD(0x0450, 0x0160, 6, 0x0694, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C1_SDA__PL301_SIM_MX6SL_PER1_HSIZE_1                      \
+		IOMUX_PAD(0x0450, 0x0160, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_I2C2_SCL__I2C2_SCL                                          \
+		IOMUX_PAD(0x0454, 0x0164, 0 | IOMUX_CONFIG_SION, 0x0724, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__AUDMUX_AUD4_RXFS                                  \
+		IOMUX_PAD(0x0454, 0x0164, 1, 0x05F0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__SPDIF_IN1                                         \
+		IOMUX_PAD(0x0454, 0x0164, 2, 0x07F0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__FEC_TDATA_1                                       \
+		IOMUX_PAD(0x0454, 0x0164, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__USDHC3_WP                                         \
+		IOMUX_PAD(0x0454, 0x0164, 4, 0x084C, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__GPIO_3_14                                         \
+		IOMUX_PAD(0x0454, 0x0164, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__ECSPI1_RDY                                        \
+		IOMUX_PAD(0x0454, 0x0164, 6, 0x0680, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SCL__PL301_SIM_MX6SL_PER1_HSIZE_2                      \
+		IOMUX_PAD(0x0454, 0x0164, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_I2C2_SDA__I2C2_SDA                                          \
+		IOMUX_PAD(0x0458, 0x0168, 0 | IOMUX_CONFIG_SION, 0x0728, 1, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__AUDMUX_AUD4_RXC                                   \
+		IOMUX_PAD(0x0458, 0x0168, 1, 0x05EC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__SPDIF_OUT1                                        \
+		IOMUX_PAD(0x0458, 0x0168, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__FEC_REF_OUT                                       \
+		IOMUX_PAD(0x0458, 0x0168, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__USDHC3_CD                                         \
+		IOMUX_PAD(0x0458, 0x0168, 4, 0x0838, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__GPIO_3_15                                         \
+		IOMUX_PAD(0x0458, 0x0168, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__ANATOP_ANATOP_TESTO_0                             \
+		IOMUX_PAD(0x0458, 0x0168, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_I2C2_SDA__PL301_SIM_MX6SL_PER1_HWRITE                       \
+		IOMUX_PAD(0x0458, 0x0168, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_MOD__SJC_MOD                                           \
+		IOMUX_PAD(0x045C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_TCK__SJC_TCK                                           \
+		IOMUX_PAD(0x0460, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_TDI__SJC_TDI                                           \
+		IOMUX_PAD(0x0464, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_TDO__SJC_TDO                                           \
+		IOMUX_PAD(0x0468, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_TMS__SJC_TMS                                           \
+		IOMUX_PAD(0x046C, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_JTAG_TRSTB__SJC_TRSTB                                       \
+		IOMUX_PAD(0x0470, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL0__KPP_COL_0                                         \
+		IOMUX_PAD(0x0474, 0x016C, 0, 0x0734, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__I2C2_SCL                                          \
+		IOMUX_PAD(0x0474, 0x016C, 1 | IOMUX_CONFIG_SION, 0x0724, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__LCDIF_DAT_0                                       \
+		IOMUX_PAD(0x0474, 0x016C, 2, 0x0778, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__WEIM_WEIM_DA_A_0                                  \
+		IOMUX_PAD(0x0474, 0x016C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__USDHC1_CD                                         \
+		IOMUX_PAD(0x0474, 0x016C, 4, 0x0828, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__GPIO_3_24                                         \
+		IOMUX_PAD(0x0474, 0x016C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__MSHC_SCLK                                         \
+		IOMUX_PAD(0x0474, 0x016C, 6, 0x07E8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL0__TPSMP_HDATA_0                                     \
+		IOMUX_PAD(0x0474, 0x016C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL1__KPP_COL_1                                         \
+		IOMUX_PAD(0x0478, 0x0170, 0, 0x0738, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__ECSPI4_MOSI                                       \
+		IOMUX_PAD(0x0478, 0x0170, 1, 0x06D8, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__LCDIF_DAT_2                                       \
+		IOMUX_PAD(0x0478, 0x0170, 2, 0x0780, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__WEIM_WEIM_DA_A_2                                  \
+		IOMUX_PAD(0x0478, 0x0170, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__USDHC3_DAT4                                       \
+		IOMUX_PAD(0x0478, 0x0170, 4, 0x083C, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__GPIO_3_26                                         \
+		IOMUX_PAD(0x0478, 0x0170, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__MSHC_DATA_0                                       \
+		IOMUX_PAD(0x0478, 0x0170, 6, 0x07D8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL1__TPSMP_HDATA_2                                     \
+		IOMUX_PAD(0x0478, 0x0170, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL2__KPP_COL_2                                         \
+		IOMUX_PAD(0x047C, 0x0174, 0, 0x073C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__ECSPI4_SS0                                        \
+		IOMUX_PAD(0x047C, 0x0174, 1, 0x06DC, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__LCDIF_DAT_4                                       \
+		IOMUX_PAD(0x047C, 0x0174, 2, 0x0788, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__WEIM_WEIM_DA_A_4                                  \
+		IOMUX_PAD(0x047C, 0x0174, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__USDHC3_DAT6                                       \
+		IOMUX_PAD(0x047C, 0x0174, 4, 0x0844, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__GPIO_3_28                                         \
+		IOMUX_PAD(0x047C, 0x0174, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__MSHC_DATA_2                                       \
+		IOMUX_PAD(0x047C, 0x0174, 6, 0x07E0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL2__TPSMP_HDATA_4                                     \
+		IOMUX_PAD(0x047C, 0x0174, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL3__KPP_COL_3                                         \
+		IOMUX_PAD(0x0480, 0x0178, 0, 0x0740, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__AUDMUX_AUD6_RXFS                                  \
+		IOMUX_PAD(0x0480, 0x0178, 1, 0x0620, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__LCDIF_DAT_6                                       \
+		IOMUX_PAD(0x0480, 0x0178, 2, 0x0790, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__WEIM_WEIM_DA_A_6                                  \
+		IOMUX_PAD(0x0480, 0x0178, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__USDHC4_DAT6                                       \
+		IOMUX_PAD(0x0480, 0x0178, 4, 0x0874, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__GPIO_3_30                                         \
+		IOMUX_PAD(0x0480, 0x0178, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__USDHC1_RST                                        \
+		IOMUX_PAD(0x0480, 0x0178, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL3__TPSMP_HDATA_6                                     \
+		IOMUX_PAD(0x0480, 0x0178, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL4__KPP_COL_4                                         \
+		IOMUX_PAD(0x0484, 0x017C, 0, 0x0744, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__AUDMUX_AUD6_RXD                                   \
+		IOMUX_PAD(0x0484, 0x017C, 1, 0x0614, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__LCDIF_DAT_8                                       \
+		IOMUX_PAD(0x0484, 0x017C, 2, 0x0798, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__WEIM_WEIM_DA_A_8                                  \
+		IOMUX_PAD(0x0484, 0x017C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__USDHC4_CLK                                        \
+		IOMUX_PAD(0x0484, 0x017C, 4, 0x0850, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__GPIO_4_0                                          \
+		IOMUX_PAD(0x0484, 0x017C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__USB_USBOTG1_PWR                                   \
+		IOMUX_PAD(0x0484, 0x017C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL4__TPSMP_HDATA_8                                     \
+		IOMUX_PAD(0x0484, 0x017C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL5__KPP_COL_5                                         \
+		IOMUX_PAD(0x0488, 0x0180, 0, 0x0748, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__AUDMUX_AUD6_TXFS                                  \
+		IOMUX_PAD(0x0488, 0x0180, 1, 0x0628, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__LCDIF_DAT_10                                      \
+		IOMUX_PAD(0x0488, 0x0180, 2, 0x07A0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__WEIM_WEIM_DA_A_10                                 \
+		IOMUX_PAD(0x0488, 0x0180, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__USDHC4_DAT0                                       \
+		IOMUX_PAD(0x0488, 0x0180, 4, 0x085C, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__GPIO_4_2                                          \
+		IOMUX_PAD(0x0488, 0x0180, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__USB_USBOTG2_PWR                                   \
+		IOMUX_PAD(0x0488, 0x0180, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL5__TPSMP_HDATA_10                                    \
+		IOMUX_PAD(0x0488, 0x0180, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL6__KPP_COL_6                                         \
+		IOMUX_PAD(0x048C, 0x0184, 0, 0x074C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__UART4_TXD                                         \
+		IOMUX_PAD(0x048C, 0x0184, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__UART4_RXD                                         \
+		IOMUX_PAD(0x048C, 0x0184, 1, 0x0814, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__LCDIF_DAT_12                                      \
+		IOMUX_PAD(0x048C, 0x0184, 2, 0x07A8, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__WEIM_WEIM_DA_A_12                                 \
+		IOMUX_PAD(0x048C, 0x0184, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__USDHC4_DAT2                                       \
+		IOMUX_PAD(0x048C, 0x0184, 4, 0x0864, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__GPIO_4_4                                          \
+		IOMUX_PAD(0x048C, 0x0184, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__USDHC3_RST                                        \
+		IOMUX_PAD(0x048C, 0x0184, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL6__TPSMP_HDATA_12                                    \
+		IOMUX_PAD(0x048C, 0x0184, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_COL7__KPP_COL_7                                         \
+		IOMUX_PAD(0x0490, 0x0188, 0, 0x0750, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__UART4_CTS                                         \
+		IOMUX_PAD(0x0490, 0x0188, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__UART4_RTS                                         \
+		IOMUX_PAD(0x0490, 0x0188, 1, 0x0810, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__LCDIF_DAT_14                                      \
+		IOMUX_PAD(0x0490, 0x0188, 2, 0x07B0, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__WEIM_WEIM_DA_A_14                                 \
+		IOMUX_PAD(0x0490, 0x0188, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__USDHC4_DAT4                                       \
+		IOMUX_PAD(0x0490, 0x0188, 4, 0x086C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__GPIO_4_6                                          \
+		IOMUX_PAD(0x0490, 0x0188, 5, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__USDHC1_WP                                         \
+		IOMUX_PAD(0x0490, 0x0188, 6, 0x082C, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_COL7__TPSMP_HDATA_14                                    \
+		IOMUX_PAD(0x0490, 0x0188, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW0__KPP_ROW_0                                         \
+		IOMUX_PAD(0x0494, 0x018C, 0, 0x0754, 0, MX6SL_KEYPAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__I2C2_SDA                                          \
+		IOMUX_PAD(0x0494, 0x018C, 1 | IOMUX_CONFIG_SION, 0x0728, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__LCDIF_DAT_1                                       \
+		IOMUX_PAD(0x0494, 0x018C, 2, 0x077C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__WEIM_WEIM_DA_A_1                                  \
+		IOMUX_PAD(0x0494, 0x018C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__USDHC1_WP                                         \
+		IOMUX_PAD(0x0494, 0x018C, 4, 0x082C, 3, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__GPIO_3_25                                         \
+		IOMUX_PAD(0x0494, 0x018C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__MSHC_BS                                           \
+		IOMUX_PAD(0x0494, 0x018C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW0__TPSMP_HDATA_1                                     \
+		IOMUX_PAD(0x0494, 0x018C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW1__KPP_ROW_1                                         \
+		IOMUX_PAD(0x0498, 0x0190, 0, 0x0758, 0, MX6SL_KEYPAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__ECSPI4_MISO                                       \
+		IOMUX_PAD(0x0498, 0x0190, 1, 0x06D4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__LCDIF_DAT_3                                       \
+		IOMUX_PAD(0x0498, 0x0190, 2, 0x0784, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__WEIM_WEIM_DA_A_3                                  \
+		IOMUX_PAD(0x0498, 0x0190, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__USDHC3_DAT5                                       \
+		IOMUX_PAD(0x0498, 0x0190, 4, 0x0840, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__GPIO_3_27                                         \
+		IOMUX_PAD(0x0498, 0x0190, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__MSHC_DATA_1                                       \
+		IOMUX_PAD(0x0498, 0x0190, 6, 0x07DC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW1__TPSMP_HDATA_3                                     \
+		IOMUX_PAD(0x0498, 0x0190, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW2__KPP_ROW_2                                         \
+		IOMUX_PAD(0x049C, 0x0194, 0, 0x075C, 0, MX6SL_KEYPAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__ECSPI4_SCLK                                       \
+		IOMUX_PAD(0x049C, 0x0194, 1, 0x06D0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__LCDIF_DAT_5                                       \
+		IOMUX_PAD(0x049C, 0x0194, 2, 0x078C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__WEIM_WEIM_DA_A_5                                  \
+		IOMUX_PAD(0x049C, 0x0194, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__USDHC3_DAT7                                       \
+		IOMUX_PAD(0x049C, 0x0194, 4, 0x0848, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__GPIO_3_29                                         \
+		IOMUX_PAD(0x049C, 0x0194, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__MSHC_DATA_3                                       \
+		IOMUX_PAD(0x049C, 0x0194, 6, 0x07E4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW2__TPSMP_HDATA_5                                     \
+		IOMUX_PAD(0x049C, 0x0194, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW3__KPP_ROW_3                                         \
+		IOMUX_PAD(0x04A0, 0x0198, 0, 0x0760, 0, MX6SL_KEYPAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__AUDMUX_AUD6_RXC                                   \
+		IOMUX_PAD(0x04A0, 0x0198, 1, 0x061C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__LCDIF_DAT_7                                       \
+		IOMUX_PAD(0x04A0, 0x0198, 2, 0x0794, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__WEIM_WEIM_DA_A_7                                  \
+		IOMUX_PAD(0x04A0, 0x0198, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__USDHC4_DAT7                                       \
+		IOMUX_PAD(0x04A0, 0x0198, 4, 0x0878, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__GPIO_3_31                                         \
+		IOMUX_PAD(0x04A0, 0x0198, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__USDHC1_VSELECT                                    \
+		IOMUX_PAD(0x04A0, 0x0198, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW3__TPSMP_HDATA_7                                     \
+		IOMUX_PAD(0x04A0, 0x0198, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW4__KPP_ROW_4                                         \
+		IOMUX_PAD(0x04A4, 0x019C, 0, 0x0764, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__AUDMUX_AUD6_TXC                                   \
+		IOMUX_PAD(0x04A4, 0x019C, 1, 0x0624, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__LCDIF_DAT_9                                       \
+		IOMUX_PAD(0x04A4, 0x019C, 2, 0x079C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__WEIM_WEIM_DA_A_9                                  \
+		IOMUX_PAD(0x04A4, 0x019C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__USDHC4_CMD                                        \
+		IOMUX_PAD(0x04A4, 0x019C, 4, 0x0858, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__GPIO_4_1                                          \
+		IOMUX_PAD(0x04A4, 0x019C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__USB_USBOTG1_OC                                    \
+		IOMUX_PAD(0x04A4, 0x019C, 6, 0x0824, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW4__TPSMP_HDATA_9                                     \
+		IOMUX_PAD(0x04A4, 0x019C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW5__KPP_ROW_5                                         \
+		IOMUX_PAD(0x04A8, 0x01A0, 0, 0x0768, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__AUDMUX_AUD6_TXD                                   \
+		IOMUX_PAD(0x04A8, 0x01A0, 1, 0x0618, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__LCDIF_DAT_11                                      \
+		IOMUX_PAD(0x04A8, 0x01A0, 2, 0x07A4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__WEIM_WEIM_DA_A_11                                 \
+		IOMUX_PAD(0x04A8, 0x01A0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__USDHC4_DAT1                                       \
+		IOMUX_PAD(0x04A8, 0x01A0, 4, 0x0860, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__GPIO_4_3                                          \
+		IOMUX_PAD(0x04A8, 0x01A0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__USB_USBOTG2_OC                                    \
+		IOMUX_PAD(0x04A8, 0x01A0, 6, 0x0820, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW5__TPSMP_HDATA_11                                    \
+		IOMUX_PAD(0x04A8, 0x01A0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW6__KPP_ROW_6                                         \
+		IOMUX_PAD(0x04AC, 0x01A4, 0, 0x076C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__UART4_TXD                                         \
+		IOMUX_PAD(0x04AC, 0x01A4, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__UART4_RXD                                         \
+		IOMUX_PAD(0x04AC, 0x01A4, 1, 0x0814, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__LCDIF_DAT_13                                      \
+		IOMUX_PAD(0x04AC, 0x01A4, 2, 0x07AC, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__WEIM_WEIM_DA_A_13                                 \
+		IOMUX_PAD(0x04AC, 0x01A4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__USDHC4_DAT3                                       \
+		IOMUX_PAD(0x04AC, 0x01A4, 4, 0x0868, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__GPIO_4_5                                          \
+		IOMUX_PAD(0x04AC, 0x01A4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__USDHC3_VSELECT                                    \
+		IOMUX_PAD(0x04AC, 0x01A4, 6, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW6__TPSMP_HDATA_13                                    \
+		IOMUX_PAD(0x04AC, 0x01A4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_KEY_ROW7__KPP_ROW_7                                         \
+		IOMUX_PAD(0x04B0, 0x01A8, 0, 0x0770, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__UART4_CTS                                         \
+		IOMUX_PAD(0x04B0, 0x01A8, 1, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__UART4_RTS                                         \
+		IOMUX_PAD(0x04B0, 0x01A8, 1, 0x0810, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__LCDIF_DAT_15                                      \
+		IOMUX_PAD(0x04B0, 0x01A8, 2, 0x07B4, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__WEIM_WEIM_DA_A_15                                 \
+		IOMUX_PAD(0x04B0, 0x01A8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__USDHC4_DAT5                                       \
+		IOMUX_PAD(0x04B0, 0x01A8, 4, 0x0870, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__GPIO_4_7                                          \
+		IOMUX_PAD(0x04B0, 0x01A8, 5, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__USDHC1_CD                                         \
+		IOMUX_PAD(0x04B0, 0x01A8, 6, 0x0828, 3, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_KEY_ROW7__TPSMP_HDATA_15                                    \
+		IOMUX_PAD(0x04B0, 0x01A8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_CLK__LCDIF_CLK                                          \
+		IOMUX_PAD(0x04B4, 0x01AC, 0, 0x0000, 0, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__USDHC4_DAT4                                        \
+		IOMUX_PAD(0x04B4, 0x01AC, 1, 0x086C, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__LCDIF_WR_RWN                                       \
+		IOMUX_PAD(0x04B4, 0x01AC, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__WEIM_WEIM_RW                                       \
+		IOMUX_PAD(0x04B4, 0x01AC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__PWM4_PWMO                                          \
+		IOMUX_PAD(0x04B4, 0x01AC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__GPIO_2_15                                          \
+		IOMUX_PAD(0x04B4, 0x01AC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__SRC_EARLY_RST                                      \
+		IOMUX_PAD(0x04B4, 0x01AC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_CLK__TPSMP_HTRANS_0                                     \
+		IOMUX_PAD(0x04B4, 0x01AC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT0__LCDIF_DAT_0                                       \
+		IOMUX_PAD(0x04B8, 0x01B0, 0, 0x0778, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__ECSPI1_MOSI                                       \
+		IOMUX_PAD(0x04B8, 0x01B0, 1, 0x0688, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__ANATOP_USBOTG2_ID                                 \
+		IOMUX_PAD(0x04B8, 0x01B0, 2, 0x05E0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__PWM1_PWMO                                         \
+		IOMUX_PAD(0x04B8, 0x01B0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__UART5_DTR                                         \
+		IOMUX_PAD(0x04B8, 0x01B0, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__GPIO_2_20                                         \
+		IOMUX_PAD(0x04B8, 0x01B0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__KITTEN_TRACE_0                                    \
+		IOMUX_PAD(0x04B8, 0x01B0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT0__SRC_BT_CFG_0                                      \
+		IOMUX_PAD(0x04B8, 0x01B0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT1__LCDIF_DAT_1                                       \
+		IOMUX_PAD(0x04BC, 0x01B4, 0, 0x077C, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__ECSPI1_MISO                                       \
+		IOMUX_PAD(0x04BC, 0x01B4, 1, 0x0684, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__ANATOP_USBOTG1_ID                                 \
+		IOMUX_PAD(0x04BC, 0x01B4, 2, 0x05DC, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__PWM2_PWMO                                         \
+		IOMUX_PAD(0x04BC, 0x01B4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__AUDMUX_AUD4_RXFS                                  \
+		IOMUX_PAD(0x04BC, 0x01B4, 4, 0x05F0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__GPIO_2_21                                         \
+		IOMUX_PAD(0x04BC, 0x01B4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__KITTEN_TRACE_1                                    \
+		IOMUX_PAD(0x04BC, 0x01B4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT1__SRC_BT_CFG_1                                      \
+		IOMUX_PAD(0x04BC, 0x01B4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT10__LCDIF_DAT_10                                     \
+		IOMUX_PAD(0x04C0, 0x01B8, 0, 0x07A0, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__KPP_COL_1                                        \
+		IOMUX_PAD(0x04C0, 0x01B8, 1, 0x0738, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__CSI_D_7                                          \
+		IOMUX_PAD(0x04C0, 0x01B8, 2, 0x064C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__WEIM_WEIM_D_4                                    \
+		IOMUX_PAD(0x04C0, 0x01B8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__ECSPI2_MISO                                      \
+		IOMUX_PAD(0x04C0, 0x01B8, 4, 0x06A0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__GPIO_2_30                                        \
+		IOMUX_PAD(0x04C0, 0x01B8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__KITTEN_TRACE_10                                  \
+		IOMUX_PAD(0x04C0, 0x01B8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT10__SRC_BT_CFG_10                                    \
+		IOMUX_PAD(0x04C0, 0x01B8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT11__LCDIF_DAT_11                                     \
+		IOMUX_PAD(0x04C4, 0x01BC, 0, 0x07A4, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__KPP_ROW_1                                        \
+		IOMUX_PAD(0x04C4, 0x01BC, 1, 0x0758, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__CSI_D_6                                          \
+		IOMUX_PAD(0x04C4, 0x01BC, 2, 0x0648, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__WEIM_WEIM_D_5                                    \
+		IOMUX_PAD(0x04C4, 0x01BC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__ECSPI2_SS1                                       \
+		IOMUX_PAD(0x04C4, 0x01BC, 4, 0x06AC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__GPIO_2_31                                        \
+		IOMUX_PAD(0x04C4, 0x01BC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__KITTEN_TRACE_11                                  \
+		IOMUX_PAD(0x04C4, 0x01BC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT11__SRC_BT_CFG_11                                    \
+		IOMUX_PAD(0x04C4, 0x01BC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT12__LCDIF_DAT_12                                     \
+		IOMUX_PAD(0x04C8, 0x01C0, 0, 0x07A8, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__KPP_COL_2                                        \
+		IOMUX_PAD(0x04C8, 0x01C0, 1, 0x073C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__CSI_D_5                                          \
+		IOMUX_PAD(0x04C8, 0x01C0, 2, 0x0644, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__WEIM_WEIM_D_6                                    \
+		IOMUX_PAD(0x04C8, 0x01C0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__UART5_CTS                                        \
+		IOMUX_PAD(0x04C8, 0x01C0, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__UART5_RTS                                        \
+		IOMUX_PAD(0x04C8, 0x01C0, 4, 0x0818, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__GPIO_3_0                                         \
+		IOMUX_PAD(0x04C8, 0x01C0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__KITTEN_TRACE_12                                  \
+		IOMUX_PAD(0x04C8, 0x01C0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT12__SRC_BT_CFG_12                                    \
+		IOMUX_PAD(0x04C8, 0x01C0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT13__LCDIF_DAT_13                                     \
+		IOMUX_PAD(0x04CC, 0x01C4, 0, 0x07AC, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__KPP_ROW_2                                        \
+		IOMUX_PAD(0x04CC, 0x01C4, 1, 0x075C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__CSI_D_4                                          \
+		IOMUX_PAD(0x04CC, 0x01C4, 2, 0x0640, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__WEIM_WEIM_D_7                                    \
+		IOMUX_PAD(0x04CC, 0x01C4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__UART5_CTS                                        \
+		IOMUX_PAD(0x04CC, 0x01C4, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__UART5_RTS                                        \
+		IOMUX_PAD(0x04CC, 0x01C4, 4, 0x0818, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__GPIO_3_1                                         \
+		IOMUX_PAD(0x04CC, 0x01C4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__KITTEN_TRACE_13                                  \
+		IOMUX_PAD(0x04CC, 0x01C4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT13__SRC_BT_CFG_13                                    \
+		IOMUX_PAD(0x04CC, 0x01C4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT14__LCDIF_DAT_14                                     \
+		IOMUX_PAD(0x04D0, 0x01C8, 0, 0x07B0, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__KPP_COL_3                                        \
+		IOMUX_PAD(0x04D0, 0x01C8, 1, 0x0740, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__CSI_D_3                                          \
+		IOMUX_PAD(0x04D0, 0x01C8, 2, 0x063C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__WEIM_WEIM_D_8                                    \
+		IOMUX_PAD(0x04D0, 0x01C8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__UART5_TXD                                        \
+		IOMUX_PAD(0x04D0, 0x01C8, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__UART5_RXD                                        \
+		IOMUX_PAD(0x04D0, 0x01C8, 4, 0x081C, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__GPIO_3_2                                         \
+		IOMUX_PAD(0x04D0, 0x01C8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__KITTEN_TRACE_14                                  \
+		IOMUX_PAD(0x04D0, 0x01C8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT14__SRC_BT_CFG_14                                    \
+		IOMUX_PAD(0x04D0, 0x01C8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT15__LCDIF_DAT_15                                     \
+		IOMUX_PAD(0x04D4, 0x01CC, 0, 0x07B4, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__KPP_ROW_3                                        \
+		IOMUX_PAD(0x04D4, 0x01CC, 1, 0x0760, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__CSI_D_2                                          \
+		IOMUX_PAD(0x04D4, 0x01CC, 2, 0x0638, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__WEIM_WEIM_D_9                                    \
+		IOMUX_PAD(0x04D4, 0x01CC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__UART5_TXD                                        \
+		IOMUX_PAD(0x04D4, 0x01CC, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__UART5_RXD                                        \
+		IOMUX_PAD(0x04D4, 0x01CC, 4, 0x081C, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__GPIO_3_3                                         \
+		IOMUX_PAD(0x04D4, 0x01CC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__KITTEN_TRACE_15                                  \
+		IOMUX_PAD(0x04D4, 0x01CC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT15__SRC_BT_CFG_15                                    \
+		IOMUX_PAD(0x04D4, 0x01CC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT16__LCDIF_DAT_16                                     \
+		IOMUX_PAD(0x04D8, 0x01D0, 0, 0x07B8, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__KPP_COL_4                                        \
+		IOMUX_PAD(0x04D8, 0x01D0, 1, 0x0744, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__CSI_D_1                                          \
+		IOMUX_PAD(0x04D8, 0x01D0, 2, 0x0634, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__WEIM_WEIM_D_10                                   \
+		IOMUX_PAD(0x04D8, 0x01D0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__I2C2_SCL                                         \
+		IOMUX_PAD(0x04D8, 0x01D0, 4 | IOMUX_CONFIG_SION, 0x0724, 3, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__GPIO_3_4                                         \
+		IOMUX_PAD(0x04D8, 0x01D0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__KITTEN_TRACE_16                                  \
+		IOMUX_PAD(0x04D8, 0x01D0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT16__SRC_BT_CFG_24                                    \
+		IOMUX_PAD(0x04D8, 0x01D0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT17__LCDIF_DAT_17                                     \
+		IOMUX_PAD(0x04DC, 0x01D4, 0, 0x07BC, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__KPP_ROW_4                                        \
+		IOMUX_PAD(0x04DC, 0x01D4, 1, 0x0764, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__CSI_D_0                                          \
+		IOMUX_PAD(0x04DC, 0x01D4, 2, 0x0630, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__WEIM_WEIM_D_11                                   \
+		IOMUX_PAD(0x04DC, 0x01D4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__I2C2_SDA                                         \
+		IOMUX_PAD(0x04DC, 0x01D4, 4 | IOMUX_CONFIG_SION, 0x0728, 3, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__GPIO_3_5                                         \
+		IOMUX_PAD(0x04DC, 0x01D4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__KITTEN_TRACE_17                                  \
+		IOMUX_PAD(0x04DC, 0x01D4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT17__SRC_BT_CFG_25                                    \
+		IOMUX_PAD(0x04DC, 0x01D4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT18__LCDIF_DAT_18                                     \
+		IOMUX_PAD(0x04E0, 0x01D8, 0, 0x07C0, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__KPP_COL_5                                        \
+		IOMUX_PAD(0x04E0, 0x01D8, 1, 0x0748, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__CSI_D_15                                         \
+		IOMUX_PAD(0x04E0, 0x01D8, 2, 0x066C, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__WEIM_WEIM_D_12                                   \
+		IOMUX_PAD(0x04E0, 0x01D8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__GPT_CAPIN1                                       \
+		IOMUX_PAD(0x04E0, 0x01D8, 4, 0x0710, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__GPIO_3_6                                         \
+		IOMUX_PAD(0x04E0, 0x01D8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__KITTEN_TRACE_18                                  \
+		IOMUX_PAD(0x04E0, 0x01D8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT18__SRC_BT_CFG_26                                    \
+		IOMUX_PAD(0x04E0, 0x01D8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT19__LCDIF_DAT_19                                     \
+		IOMUX_PAD(0x04E4, 0x01DC, 0, 0x07C4, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__KPP_ROW_5                                        \
+		IOMUX_PAD(0x04E4, 0x01DC, 1, 0x0768, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__CSI_D_14                                         \
+		IOMUX_PAD(0x04E4, 0x01DC, 2, 0x0668, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__WEIM_WEIM_D_13                                   \
+		IOMUX_PAD(0x04E4, 0x01DC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__GPT_CAPIN2                                       \
+		IOMUX_PAD(0x04E4, 0x01DC, 4, 0x0714, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__GPIO_3_7                                         \
+		IOMUX_PAD(0x04E4, 0x01DC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__KITTEN_TRACE_19                                  \
+		IOMUX_PAD(0x04E4, 0x01DC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT19__SRC_BT_CFG_27                                    \
+		IOMUX_PAD(0x04E4, 0x01DC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT2__LCDIF_DAT_2                                       \
+		IOMUX_PAD(0x04E8, 0x01E0, 0, 0x0780, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__ECSPI1_SS0                                        \
+		IOMUX_PAD(0x04E8, 0x01E0, 1, 0x068C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__EPIT2_EPITO                                       \
+		IOMUX_PAD(0x04E8, 0x01E0, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__PWM3_PWMO                                         \
+		IOMUX_PAD(0x04E8, 0x01E0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__AUDMUX_AUD4_RXC                                   \
+		IOMUX_PAD(0x04E8, 0x01E0, 4, 0x05EC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__GPIO_2_22                                         \
+		IOMUX_PAD(0x04E8, 0x01E0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__KITTEN_TRACE_2                                    \
+		IOMUX_PAD(0x04E8, 0x01E0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT2__SRC_BT_CFG_2                                      \
+		IOMUX_PAD(0x04E8, 0x01E0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT20__LCDIF_DAT_20                                     \
+		IOMUX_PAD(0x04EC, 0x01E4, 0, 0x07C8, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__KPP_COL_6                                        \
+		IOMUX_PAD(0x04EC, 0x01E4, 1, 0x074C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__CSI_D_13                                         \
+		IOMUX_PAD(0x04EC, 0x01E4, 2, 0x0664, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__WEIM_WEIM_D_14                                   \
+		IOMUX_PAD(0x04EC, 0x01E4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__GPT_CMPOUT1                                      \
+		IOMUX_PAD(0x04EC, 0x01E4, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__GPIO_3_8                                         \
+		IOMUX_PAD(0x04EC, 0x01E4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__KITTEN_TRACE_20                                  \
+		IOMUX_PAD(0x04EC, 0x01E4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT20__SRC_BT_CFG_28                                    \
+		IOMUX_PAD(0x04EC, 0x01E4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT21__LCDIF_DAT_21                                     \
+		IOMUX_PAD(0x04F0, 0x01E8, 0, 0x07CC, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__KPP_ROW_6                                        \
+		IOMUX_PAD(0x04F0, 0x01E8, 1, 0x076C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__CSI_D_12                                         \
+		IOMUX_PAD(0x04F0, 0x01E8, 2, 0x0660, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__WEIM_WEIM_D_15                                   \
+		IOMUX_PAD(0x04F0, 0x01E8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__GPT_CMPOUT2                                      \
+		IOMUX_PAD(0x04F0, 0x01E8, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__GPIO_3_9                                         \
+		IOMUX_PAD(0x04F0, 0x01E8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__KITTEN_TRACE_21                                  \
+		IOMUX_PAD(0x04F0, 0x01E8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT21__SRC_BT_CFG_29                                    \
+		IOMUX_PAD(0x04F0, 0x01E8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT22__LCDIF_DAT_22                                     \
+		IOMUX_PAD(0x04F4, 0x01EC, 0, 0x07D0, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__KPP_COL_7                                        \
+		IOMUX_PAD(0x04F4, 0x01EC, 1, 0x0750, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__CSI_D_11                                         \
+		IOMUX_PAD(0x04F4, 0x01EC, 2, 0x065C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__WEIM_WEIM_EB_3                                   \
+		IOMUX_PAD(0x04F4, 0x01EC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__GPT_CMPOUT3                                      \
+		IOMUX_PAD(0x04F4, 0x01EC, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__GPIO_3_10                                        \
+		IOMUX_PAD(0x04F4, 0x01EC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__KITTEN_TRACE_22                                  \
+		IOMUX_PAD(0x04F4, 0x01EC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT22__SRC_BT_CFG_30                                    \
+		IOMUX_PAD(0x04F4, 0x01EC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT23__LCDIF_DAT_23                                     \
+		IOMUX_PAD(0x04F8, 0x01F0, 0, 0x07D4, 1, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__KPP_ROW_7                                        \
+		IOMUX_PAD(0x04F8, 0x01F0, 1, 0x0770, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__CSI_D_10                                         \
+		IOMUX_PAD(0x04F8, 0x01F0, 2, 0x0658, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__WEIM_WEIM_EB_2                                   \
+		IOMUX_PAD(0x04F8, 0x01F0, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__GPT_CLKIN                                        \
+		IOMUX_PAD(0x04F8, 0x01F0, 4, 0x0718, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__GPIO_3_11                                        \
+		IOMUX_PAD(0x04F8, 0x01F0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__KITTEN_TRACE_23                                  \
+		IOMUX_PAD(0x04F8, 0x01F0, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT23__SRC_BT_CFG_31                                    \
+		IOMUX_PAD(0x04F8, 0x01F0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT3__LCDIF_DAT_3                                       \
+		IOMUX_PAD(0x04FC, 0x01F4, 0, 0x0784, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__ECSPI1_SCLK                                       \
+		IOMUX_PAD(0x04FC, 0x01F4, 1, 0x067C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__UART5_DSR                                         \
+		IOMUX_PAD(0x04FC, 0x01F4, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__PWM4_PWMO                                         \
+		IOMUX_PAD(0x04FC, 0x01F4, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__AUDMUX_AUD4_RXD                                   \
+		IOMUX_PAD(0x04FC, 0x01F4, 4, 0x05E4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__GPIO_2_23                                         \
+		IOMUX_PAD(0x04FC, 0x01F4, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__KITTEN_TRACE_3                                    \
+		IOMUX_PAD(0x04FC, 0x01F4, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT3__SRC_BT_CFG_3                                      \
+		IOMUX_PAD(0x04FC, 0x01F4, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT4__LCDIF_DAT_4                                       \
+		IOMUX_PAD(0x0500, 0x01F8, 0, 0x0788, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__ECSPI1_SS1                                        \
+		IOMUX_PAD(0x0500, 0x01F8, 1, 0x0690, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__CSI_VSYNC                                         \
+		IOMUX_PAD(0x0500, 0x01F8, 2, 0x0678, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__WDOG2_WDOG_RST_B_DEB                              \
+		IOMUX_PAD(0x0500, 0x01F8, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__AUDMUX_AUD4_TXC                                   \
+		IOMUX_PAD(0x0500, 0x01F8, 4, 0x05F4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__GPIO_2_24                                         \
+		IOMUX_PAD(0x0500, 0x01F8, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__KITTEN_TRACE_4                                    \
+		IOMUX_PAD(0x0500, 0x01F8, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT4__SRC_BT_CFG_4                                      \
+		IOMUX_PAD(0x0500, 0x01F8, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT5__LCDIF_DAT_5                                       \
+		IOMUX_PAD(0x0504, 0x01FC, 0, 0x078C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__ECSPI1_SS2                                        \
+		IOMUX_PAD(0x0504, 0x01FC, 1, 0x0694, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__CSI_HSYNC                                         \
+		IOMUX_PAD(0x0504, 0x01FC, 2, 0x0670, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__WEIM_WEIM_CS_3                                    \
+		IOMUX_PAD(0x0504, 0x01FC, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__AUDMUX_AUD4_TXFS                                  \
+		IOMUX_PAD(0x0504, 0x01FC, 4, 0x05F8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__GPIO_2_25                                         \
+		IOMUX_PAD(0x0504, 0x01FC, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__KITTEN_TRACE_5                                    \
+		IOMUX_PAD(0x0504, 0x01FC, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT5__SRC_BT_CFG_5                                      \
+		IOMUX_PAD(0x0504, 0x01FC, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT6__LCDIF_DAT_6                                       \
+		IOMUX_PAD(0x0508, 0x0200, 0, 0x0790, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__ECSPI1_SS3                                        \
+		IOMUX_PAD(0x0508, 0x0200, 1, 0x0698, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__CSI_PIXCLK                                        \
+		IOMUX_PAD(0x0508, 0x0200, 2, 0x0674, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__WEIM_WEIM_D_0                                     \
+		IOMUX_PAD(0x0508, 0x0200, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__AUDMUX_AUD4_TXD                                   \
+		IOMUX_PAD(0x0508, 0x0200, 4, 0x05E8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__GPIO_2_26                                         \
+		IOMUX_PAD(0x0508, 0x0200, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__KITTEN_TRACE_6                                    \
+		IOMUX_PAD(0x0508, 0x0200, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT6__SRC_BT_CFG_6                                      \
+		IOMUX_PAD(0x0508, 0x0200, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT7__LCDIF_DAT_7                                       \
+		IOMUX_PAD(0x050C, 0x0204, 0, 0x0794, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__ECSPI1_RDY                                        \
+		IOMUX_PAD(0x050C, 0x0204, 1, 0x0680, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__CSI_MCLK                                          \
+		IOMUX_PAD(0x050C, 0x0204, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__WEIM_WEIM_D_1                                     \
+		IOMUX_PAD(0x050C, 0x0204, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__AUDMUX_AUDIO_CLK_OUT                              \
+		IOMUX_PAD(0x050C, 0x0204, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__GPIO_2_27                                         \
+		IOMUX_PAD(0x050C, 0x0204, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__KITTEN_TRACE_7                                    \
+		IOMUX_PAD(0x050C, 0x0204, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT7__SRC_BT_CFG_7                                      \
+		IOMUX_PAD(0x050C, 0x0204, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT8__LCDIF_DAT_8                                       \
+		IOMUX_PAD(0x0510, 0x0208, 0, 0x0798, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__KPP_COL_0                                         \
+		IOMUX_PAD(0x0510, 0x0208, 1, 0x0734, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__CSI_D_9                                           \
+		IOMUX_PAD(0x0510, 0x0208, 2, 0x0654, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__WEIM_WEIM_D_2                                     \
+		IOMUX_PAD(0x0510, 0x0208, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__ECSPI2_SCLK                                       \
+		IOMUX_PAD(0x0510, 0x0208, 4, 0x069C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__GPIO_2_28                                         \
+		IOMUX_PAD(0x0510, 0x0208, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__KITTEN_TRACE_8                                    \
+		IOMUX_PAD(0x0510, 0x0208, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT8__SRC_BT_CFG_8                                      \
+		IOMUX_PAD(0x0510, 0x0208, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_DAT9__LCDIF_DAT_9                                       \
+		IOMUX_PAD(0x0514, 0x020C, 0, 0x079C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__KPP_ROW_0                                         \
+		IOMUX_PAD(0x0514, 0x020C, 1, 0x0754, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__CSI_D_8                                           \
+		IOMUX_PAD(0x0514, 0x020C, 2, 0x0650, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__WEIM_WEIM_D_3                                     \
+		IOMUX_PAD(0x0514, 0x020C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__ECSPI2_MOSI                                       \
+		IOMUX_PAD(0x0514, 0x020C, 4, 0x06A4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__GPIO_2_29                                         \
+		IOMUX_PAD(0x0514, 0x020C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__KITTEN_TRACE_9                                    \
+		IOMUX_PAD(0x0514, 0x020C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_DAT9__SRC_BT_CFG_9                                      \
+		IOMUX_PAD(0x0514, 0x020C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_ENABLE__LCDIF_ENABLE                                    \
+		IOMUX_PAD(0x0518, 0x0210, 0, 0x0000, 0, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__USDHC4_DAT5                                     \
+		IOMUX_PAD(0x0518, 0x0210, 1, 0x0870, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__LCDIF_RD_E                                      \
+		IOMUX_PAD(0x0518, 0x0210, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__WEIM_WEIM_OE                                    \
+		IOMUX_PAD(0x0518, 0x0210, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__UART2_TXD                                       \
+		IOMUX_PAD(0x0518, 0x0210, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__UART2_RXD                                       \
+		IOMUX_PAD(0x0518, 0x0210, 4, 0x0804, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__GPIO_2_16                                       \
+		IOMUX_PAD(0x0518, 0x0210, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__OCOTP_CTRL_WRAPPER_FUSE_LATCHED                 \
+		IOMUX_PAD(0x0518, 0x0210, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_ENABLE__TPSMP_HTRANS_1                                  \
+		IOMUX_PAD(0x0518, 0x0210, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_HSYNC__LCDIF_HSYNC                                      \
+		IOMUX_PAD(0x051C, 0x0214, 0, 0x0774, 0, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__USDHC4_DAT6                                      \
+		IOMUX_PAD(0x051C, 0x0214, 1, 0x0874, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__LCDIF_CS                                         \
+		IOMUX_PAD(0x051C, 0x0214, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__WEIM_WEIM_CS_0                                   \
+		IOMUX_PAD(0x051C, 0x0214, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__UART2_TXD                                        \
+		IOMUX_PAD(0x051C, 0x0214, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__UART2_RXD                                        \
+		IOMUX_PAD(0x051C, 0x0214, 4, 0x0804, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__GPIO_2_17                                        \
+		IOMUX_PAD(0x051C, 0x0214, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__KITTEN_TRCLK                                     \
+		IOMUX_PAD(0x051C, 0x0214, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_HSYNC__TPSMP_HDATA_16                                   \
+		IOMUX_PAD(0x051C, 0x0214, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_RESET__LCDIF_RESET                                      \
+		IOMUX_PAD(0x0520, 0x0218, 0, 0x0000, 0, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__WEIM_WEIM_DTACK_B                                \
+		IOMUX_PAD(0x0520, 0x0218, 1, 0x0880, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__LCDIF_BUSY                                       \
+		IOMUX_PAD(0x0520, 0x0218, 2, 0x0774, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__WEIM_WEIM_WAIT                                   \
+		IOMUX_PAD(0x0520, 0x0218, 3, 0x0884, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__UART2_CTS                                        \
+		IOMUX_PAD(0x0520, 0x0218, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__UART2_RTS                                        \
+		IOMUX_PAD(0x0520, 0x0218, 4, 0x0800, 2, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__GPIO_2_19                                        \
+		IOMUX_PAD(0x0520, 0x0218, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__CCM_PMIC_RDY                                     \
+		IOMUX_PAD(0x0520, 0x0218, 6, 0x062C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_RESET__TPSMP_HDATA_DIR                                  \
+		IOMUX_PAD(0x0520, 0x0218, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_LCD_VSYNC__LCDIF_VSYNC                                      \
+		IOMUX_PAD(0x0524, 0x021C, 0, 0x0000, 0, MX6SL_LCDIF_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__USDHC4_DAT7                                      \
+		IOMUX_PAD(0x0524, 0x021C, 1, 0x0878, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__LCDIF_RS                                         \
+		IOMUX_PAD(0x0524, 0x021C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__WEIM_WEIM_CS_1                                   \
+		IOMUX_PAD(0x0524, 0x021C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__UART2_CTS                                        \
+		IOMUX_PAD(0x0524, 0x021C, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__UART2_RTS                                        \
+		IOMUX_PAD(0x0524, 0x021C, 4, 0x0800, 3, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__GPIO_2_18                                        \
+		IOMUX_PAD(0x0524, 0x021C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__KITTEN_TRCTL                                     \
+		IOMUX_PAD(0x0524, 0x021C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_LCD_VSYNC__TPSMP_HDATA_17                                   \
+		IOMUX_PAD(0x0524, 0x021C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_PMIC_ON_REQ__SNVS_LP_WRAPPER_SNVS_WAKEUP_ALARM              \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_PMIC_STBY_REQ__CCM_PMIC_VSTBY_REQ                           \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_POR_B__SRC_POR_B                                            \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_PWM1__PWM1_PWMO                                             \
+		IOMUX_PAD(0x0528, 0x0220, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__CCM_CLKO                                              \
+		IOMUX_PAD(0x0528, 0x0220, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__AUDMUX_AUDIO_CLK_OUT                                  \
+		IOMUX_PAD(0x0528, 0x0220, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__FEC_REF_OUT                                           \
+		IOMUX_PAD(0x0528, 0x0220, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__CSI_MCLK                                              \
+		IOMUX_PAD(0x0528, 0x0220, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__GPIO_3_23                                             \
+		IOMUX_PAD(0x0528, 0x0220, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__EPIT1_EPITO                                           \
+		IOMUX_PAD(0x0528, 0x0220, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_PWM1__OBSERVE_MUX_OUT_4                                     \
+		IOMUX_PAD(0x0528, 0x0220, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_REF_CLK_24M__ANATOP_ANATOP_24M_OUT                          \
+		IOMUX_PAD(0x052C, 0x0224, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__I2C3_SCL                                       \
+		IOMUX_PAD(0x052C, 0x0224, 1 | IOMUX_CONFIG_SION, 0x072C, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__PWM3_PWMO                                      \
+		IOMUX_PAD(0x052C, 0x0224, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__ANATOP_USBOTG2_ID                              \
+		IOMUX_PAD(0x052C, 0x0224, 3, 0x05E0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__CCM_PMIC_RDY                                   \
+		IOMUX_PAD(0x052C, 0x0224, 4, 0x062C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__GPIO_3_21                                      \
+		IOMUX_PAD(0x052C, 0x0224, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__USDHC3_WP                                      \
+		IOMUX_PAD(0x052C, 0x0224, 6, 0x084C, 3, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_24M__TPSMP_HDATA_19                                 \
+		IOMUX_PAD(0x052C, 0x0224, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_REF_CLK_32K__ANATOP_ANATOP_32K_OUT                          \
+		IOMUX_PAD(0x0530, 0x0228, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__I2C3_SDA                                       \
+		IOMUX_PAD(0x0530, 0x0228, 1 | IOMUX_CONFIG_SION, 0x0730, 2, MX6SL_I2C_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__PWM4_PWMO                                      \
+		IOMUX_PAD(0x0530, 0x0228, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__ANATOP_USBOTG1_ID                              \
+		IOMUX_PAD(0x0530, 0x0228, 3, 0x05DC, 3, NO_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__USDHC1_LCTL                                    \
+		IOMUX_PAD(0x0530, 0x0228, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__GPIO_3_22                                      \
+		IOMUX_PAD(0x0530, 0x0228, 5, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__USDHC3_CD                                      \
+		IOMUX_PAD(0x0530, 0x0228, 6, 0x0838, 3, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_REF_CLK_32K__OBSERVE_MUX_OUT_3                              \
+		IOMUX_PAD(0x0530, 0x0228, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_RESET_IN_B__SRC_RESET_B                                     \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_CLK__USDHC1_CLK_50MHZ                                   \
+		IOMUX_PAD(0x0534, 0x022C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__USDHC1_CLK_100MHZ                                  \
+	IOMUX_PAD(0x0534, 0x022C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_CLK__USDHC1_CLK_200MHZ                                  \
+	IOMUX_PAD(0x0534, 0x022C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_CLK__FEC_MDIO                                           \
+		IOMUX_PAD(0x0534, 0x022C, 1, 0x06F4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__KPP_COL_0                                          \
+		IOMUX_PAD(0x0534, 0x022C, 2, 0x0734, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__EPDC_SDCE_4                                        \
+		IOMUX_PAD(0x0534, 0x022C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__MSHC_SCLK                                          \
+		IOMUX_PAD(0x0534, 0x022C, 4, 0x07E8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__GPIO_5_15                                          \
+		IOMUX_PAD(0x0534, 0x022C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__ANATOP_ANATOP_TESTO_2                              \
+		IOMUX_PAD(0x0534, 0x022C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CLK__PL301_SIM_MX6SL_PER1_HADDR_25                      \
+		IOMUX_PAD(0x0534, 0x022C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_CMD__USDHC1_CMD_50MHZ                                   \
+		IOMUX_PAD(0x0538, 0x0230, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__USDHC1_CMD_100MHZ                                  \
+	IOMUX_PAD(0x0538, 0x0230, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_CMD__USDHC1_CMD_200MHZ                                  \
+	IOMUX_PAD(0x0538, 0x0230, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_CMD__FEC_TX_CLK                                         \
+		IOMUX_PAD(0x0538, 0x0230, 1, 0x070C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__KPP_ROW_0                                          \
+		IOMUX_PAD(0x0538, 0x0230, 2, 0x0754, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__EPDC_SDCE_5                                        \
+		IOMUX_PAD(0x0538, 0x0230, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__MSHC_BS                                            \
+		IOMUX_PAD(0x0538, 0x0230, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__GPIO_5_14                                          \
+		IOMUX_PAD(0x0538, 0x0230, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__ANATOP_ANATOP_TESTO_3                              \
+		IOMUX_PAD(0x0538, 0x0230, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_CMD__PL301_SIM_MX6SL_PER1_HADDR_26                      \
+		IOMUX_PAD(0x0538, 0x0230, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT0__USDHC1_DAT0_50MHZ                                 \
+		IOMUX_PAD(0x053C, 0x0234, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__USDHC1_DAT0_100MHZ                                \
+	IOMUX_PAD(0x053C, 0x0234, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT0__USDHC1_DAT0_200MHZ                                \
+	IOMUX_PAD(0x053C, 0x0234, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT0__FEC_RX_ER                                         \
+		IOMUX_PAD(0x053C, 0x0234, 1, 0x0708, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__KPP_COL_1                                         \
+		IOMUX_PAD(0x053C, 0x0234, 2, 0x0738, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__EPDC_SDCE_6                                       \
+		IOMUX_PAD(0x053C, 0x0234, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__MSHC_DATA_0                                       \
+		IOMUX_PAD(0x053C, 0x0234, 4, 0x07D8, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__GPIO_5_11                                         \
+		IOMUX_PAD(0x053C, 0x0234, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__ANATOP_ANATOP_TESTO_4                             \
+		IOMUX_PAD(0x053C, 0x0234, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT0__PL301_SIM_MX6SL_PER1_HADDR_27                     \
+		IOMUX_PAD(0x053C, 0x0234, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT1__USDHC1_DAT1_50MHZ                                 \
+		IOMUX_PAD(0x0540, 0x0238, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__USDHC1_DAT1_100MHZ                                \
+	IOMUX_PAD(0x0540, 0x0238, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT1__USDHC1_DAT1_200MHZ                                \
+	IOMUX_PAD(0x0540, 0x0238, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT1__FEC_RX_DV                                         \
+		IOMUX_PAD(0x0540, 0x0238, 1, 0x0704, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__KPP_ROW_1                                         \
+		IOMUX_PAD(0x0540, 0x0238, 2, 0x0758, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__EPDC_SDCE_7                                       \
+		IOMUX_PAD(0x0540, 0x0238, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__MSHC_DATA_1                                       \
+		IOMUX_PAD(0x0540, 0x0238, 4, 0x07DC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__GPIO_5_8                                          \
+		IOMUX_PAD(0x0540, 0x0238, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__ANATOP_ANATOP_TESTO_5                             \
+		IOMUX_PAD(0x0540, 0x0238, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT1__PL301_SIM_MX6SL_PER1_HADDR_28                     \
+		IOMUX_PAD(0x0540, 0x0238, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT2__USDHC1_DAT2_50MHZ                                 \
+		IOMUX_PAD(0x0544, 0x023C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__USDHC1_DAT2_100MHZ                                \
+	IOMUX_PAD(0x0544, 0x023C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT2__USDHC1_DAT2_200MHZ                                \
+	IOMUX_PAD(0x0544, 0x023C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT2__FEC_RDATA_1                                       \
+		IOMUX_PAD(0x0544, 0x023C, 1, 0x06FC, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__KPP_COL_2                                         \
+		IOMUX_PAD(0x0544, 0x023C, 2, 0x073C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__EPDC_SDCE_8                                       \
+		IOMUX_PAD(0x0544, 0x023C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__MSHC_DATA_2                                       \
+		IOMUX_PAD(0x0544, 0x023C, 4, 0x07E0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__GPIO_5_13                                         \
+		IOMUX_PAD(0x0544, 0x023C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__ANATOP_ANATOP_TESTO_6                             \
+		IOMUX_PAD(0x0544, 0x023C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT2__PL301_SIM_MX6SL_PER1_HADDR_29                     \
+		IOMUX_PAD(0x0544, 0x023C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT3__USDHC1_DAT3_50MHZ                                 \
+		IOMUX_PAD(0x0548, 0x0240, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__USDHC1_DAT3_100MHZ                                \
+	IOMUX_PAD(0x0548, 0x0240, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT3__USDHC1_DAT3_200MHZ                                \
+	IOMUX_PAD(0x0548, 0x0240, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT3__FEC_TDATA_0                                       \
+		IOMUX_PAD(0x0548, 0x0240, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__KPP_ROW_2                                         \
+		IOMUX_PAD(0x0548, 0x0240, 2, 0x075C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__EPDC_SDCE_9                                       \
+		IOMUX_PAD(0x0548, 0x0240, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__MSHC_DATA_3                                       \
+		IOMUX_PAD(0x0548, 0x0240, 4, 0x07E4, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__GPIO_5_6                                          \
+		IOMUX_PAD(0x0548, 0x0240, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__ANATOP_ANATOP_TESTO_7                             \
+		IOMUX_PAD(0x0548, 0x0240, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT3__PL301_SIM_MX6SL_PER1_HADDR_30                     \
+		IOMUX_PAD(0x0548, 0x0240, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT4__USDHC1_DAT4_50MHZ                                 \
+		IOMUX_PAD(0x054C, 0x0244, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__USDHC1_DAT4_100MHZ                                \
+	IOMUX_PAD(0x054C, 0x0244, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT4__USDHC1_DAT4_200MHZ                                \
+	IOMUX_PAD(0x054C, 0x0244, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT4__FEC_MDC                                           \
+		IOMUX_PAD(0x054C, 0x0244, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__KPP_COL_3                                         \
+		IOMUX_PAD(0x054C, 0x0244, 2, 0x0740, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__EPDC_SDCLKN                                       \
+		IOMUX_PAD(0x054C, 0x0244, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__UART4_TXD                                         \
+		IOMUX_PAD(0x054C, 0x0244, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__UART4_RXD                                         \
+		IOMUX_PAD(0x054C, 0x0244, 4, 0x0814, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__GPIO_5_12                                         \
+		IOMUX_PAD(0x054C, 0x0244, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__ANATOP_ANATOP_TESTO_8                             \
+		IOMUX_PAD(0x054C, 0x0244, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT4__PL301_SIM_MX6SL_PER1_HADDR_31                     \
+		IOMUX_PAD(0x054C, 0x0244, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT5__USDHC1_DAT5_50MHZ                                 \
+		IOMUX_PAD(0x0550, 0x0248, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__USDHC1_DAT5_100MHZ                                \
+	IOMUX_PAD(0x0550, 0x0248, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT5__USDHC1_DAT5_200MHZ                                \
+	IOMUX_PAD(0x0550, 0x0248, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT5__FEC_RDATA_0                                       \
+		IOMUX_PAD(0x0550, 0x0248, 1, 0x06F8, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__KPP_ROW_3                                         \
+		IOMUX_PAD(0x0550, 0x0248, 2, 0x0760, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__EPDC_SDOED                                        \
+		IOMUX_PAD(0x0550, 0x0248, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__UART4_TXD                                         \
+		IOMUX_PAD(0x0550, 0x0248, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__UART4_RXD                                         \
+		IOMUX_PAD(0x0550, 0x0248, 4, 0x0814, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__GPIO_5_9                                          \
+		IOMUX_PAD(0x0550, 0x0248, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__ANATOP_ANATOP_TESTO_9                             \
+		IOMUX_PAD(0x0550, 0x0248, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT5__PL301_SIM_MX6SL_PER1_HPROT_3                      \
+		IOMUX_PAD(0x0550, 0x0248, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT6__USDHC1_DAT6_50MHZ                                 \
+		IOMUX_PAD(0x0554, 0x024C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__USDHC1_DAT6_100MHZ                                \
+	IOMUX_PAD(0x0554, 0x024C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT6__USDHC1_DAT6_200MHZ                                \
+	IOMUX_PAD(0x0554, 0x024C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT6__FEC_TX_EN                                         \
+		IOMUX_PAD(0x0554, 0x024C, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__KPP_COL_4                                         \
+		IOMUX_PAD(0x0554, 0x024C, 2, 0x0744, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__EPDC_SDOEZ                                        \
+		IOMUX_PAD(0x0554, 0x024C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__UART4_CTS                                         \
+		IOMUX_PAD(0x0554, 0x024C, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__UART4_RTS                                         \
+		IOMUX_PAD(0x0554, 0x024C, 4, 0x0810, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__GPIO_5_7                                          \
+		IOMUX_PAD(0x0554, 0x024C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__ANATOP_ANATOP_TESTO_10                            \
+		IOMUX_PAD(0x0554, 0x024C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT6__PL301_SIM_MX6SL_PER1_HPROT_2                      \
+		IOMUX_PAD(0x0554, 0x024C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD1_DAT7__USDHC1_DAT7_50MHZ                                 \
+		IOMUX_PAD(0x0558, 0x0250, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__USDHC1_DAT7_100MHZ                                \
+	IOMUX_PAD(0x0558, 0x0250, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD1_DAT7__USDHC1_DAT7_200MHZ                                \
+	IOMUX_PAD(0x0558, 0x0250, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD1_DAT7__FEC_TDATA_1                                       \
+		IOMUX_PAD(0x0558, 0x0250, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__KPP_ROW_4                                         \
+		IOMUX_PAD(0x0558, 0x0250, 2, 0x0764, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__CCM_PMIC_RDY                                      \
+		IOMUX_PAD(0x0558, 0x0250, 3, 0x062C, 3, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__UART4_CTS                                         \
+		IOMUX_PAD(0x0558, 0x0250, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__UART4_RTS                                         \
+		IOMUX_PAD(0x0558, 0x0250, 4, 0x0810, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__GPIO_5_10                                         \
+		IOMUX_PAD(0x0558, 0x0250, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__ANATOP_ANATOP_TESTO_11                            \
+		IOMUX_PAD(0x0558, 0x0250, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD1_DAT7__PL301_SIM_MX6SL_PER1_HMASTLOCK                    \
+		IOMUX_PAD(0x0558, 0x0250, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_CLK__USDHC2_CLK_50MHZ                                   \
+		IOMUX_PAD(0x055C, 0x0254, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__USDHC2_CLK_100MHZ                                  \
+	IOMUX_PAD(0x055C, 0x0254, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_CLK__USDHC2_CLK_200MHZ                                  \
+	IOMUX_PAD(0x055C, 0x0254, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_CLK__AUDMUX_AUD4_RXFS                                   \
+		IOMUX_PAD(0x055C, 0x0254, 1, 0x05F0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__ECSPI3_SCLK                                        \
+		IOMUX_PAD(0x055C, 0x0254, 2, 0x06B0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__CSI_D_0                                            \
+		IOMUX_PAD(0x055C, 0x0254, 3, 0x0630, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__OSC32K_32K_OUT                                     \
+		IOMUX_PAD(0x055C, 0x0254, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__GPIO_5_5                                           \
+		IOMUX_PAD(0x055C, 0x0254, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__ANATOP_ANATOP_TESTO_13                             \
+		IOMUX_PAD(0x055C, 0x0254, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CLK__PL301_SIM_MX6SL_PER1_HPROT_1                       \
+		IOMUX_PAD(0x055C, 0x0254, 7, 0x07EC, 1, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_CMD__USDHC2_CMD_50MHZ                                   \
+		IOMUX_PAD(0x0560, 0x0258, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__USDHC2_CMD_100MHZ                                  \
+	IOMUX_PAD(0x0560, 0x0258, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_CMD__USDHC2_CMD_200MHZ                                  \
+	IOMUX_PAD(0x0560, 0x0258, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_CMD__AUDMUX_AUD4_RXC                                    \
+		IOMUX_PAD(0x0560, 0x0258, 1, 0x05EC, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__ECSPI3_SS0                                         \
+		IOMUX_PAD(0x0560, 0x0258, 2, 0x06C0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__CSI_D_1                                            \
+		IOMUX_PAD(0x0560, 0x0258, 3, 0x0634, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__EPIT1_EPITO                                        \
+		IOMUX_PAD(0x0560, 0x0258, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__GPIO_5_4                                           \
+		IOMUX_PAD(0x0560, 0x0258, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__ANATOP_ANATOP_TESTO_14                             \
+		IOMUX_PAD(0x0560, 0x0258, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_CMD__PL301_SIM_MX6SL_PER1_HADDR_21                      \
+		IOMUX_PAD(0x0560, 0x0258, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_50MHZ                                 \
+		IOMUX_PAD(0x0564, 0x025C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_100MHZ                                \
+	IOMUX_PAD(0x0564, 0x025C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_200MHZ                                \
+	IOMUX_PAD(0x0564, 0x025C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT0__AUDMUX_AUD4_RXD                                   \
+		IOMUX_PAD(0x0564, 0x025C, 1, 0x05E4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__ECSPI3_MOSI                                       \
+		IOMUX_PAD(0x0564, 0x025C, 2, 0x06BC, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__CSI_D_2                                           \
+		IOMUX_PAD(0x0564, 0x025C, 3, 0x0638, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__UART5_CTS                                         \
+		IOMUX_PAD(0x0564, 0x025C, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__UART5_RTS                                         \
+		IOMUX_PAD(0x0564, 0x025C, 4, 0x0818, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__GPIO_5_1                                          \
+		IOMUX_PAD(0x0564, 0x025C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__ANATOP_ANATOP_TESTO_15                            \
+		IOMUX_PAD(0x0564, 0x025C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT0__PL301_SIM_MX6SL_PER1_HPROT_0                      \
+		IOMUX_PAD(0x0564, 0x025C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_50MHZ                                 \
+		IOMUX_PAD(0x0568, 0x0260, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_100MHZ                                \
+	IOMUX_PAD(0x0568, 0x0260, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_200MHZ                                \
+	IOMUX_PAD(0x0568, 0x0260, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT1__AUDMUX_AUD4_TXC                                   \
+		IOMUX_PAD(0x0568, 0x0260, 1, 0x05F4, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__ECSPI3_MISO                                       \
+		IOMUX_PAD(0x0568, 0x0260, 2, 0x06B8, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__CSI_D_3                                           \
+		IOMUX_PAD(0x0568, 0x0260, 3, 0x063C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__UART5_CTS                                         \
+		IOMUX_PAD(0x0568, 0x0260, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__UART5_RTS                                         \
+		IOMUX_PAD(0x0568, 0x0260, 4, 0x0818, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__GPIO_4_30                                         \
+		IOMUX_PAD(0x0568, 0x0260, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__MMDC_MMDC_DEBUG_39                                \
+		IOMUX_PAD(0x0568, 0x0260, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT1__PL301_SIM_MX6SL_PER1_HBURST_1                     \
+		IOMUX_PAD(0x0568, 0x0260, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_50MHZ                                 \
+		IOMUX_PAD(0x056C, 0x0264, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_100MHZ                                \
+	IOMUX_PAD(0x056C, 0x0264, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_200MHZ                                \
+	IOMUX_PAD(0x056C, 0x0264, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT2__AUDMUX_AUD4_TXFS                                  \
+		IOMUX_PAD(0x056C, 0x0264, 1, 0x05F8, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__FEC_COL                                           \
+		IOMUX_PAD(0x056C, 0x0264, 2, 0x06F0, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__CSI_D_4                                           \
+		IOMUX_PAD(0x056C, 0x0264, 3, 0x0640, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__UART5_TXD                                         \
+		IOMUX_PAD(0x056C, 0x0264, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__UART5_RXD                                         \
+		IOMUX_PAD(0x056C, 0x0264, 4, 0x081C, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__GPIO_5_3                                          \
+		IOMUX_PAD(0x056C, 0x0264, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__MMDC_MMDC_DEBUG_38                                \
+		IOMUX_PAD(0x056C, 0x0264, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT2__PL301_SIM_MX6SL_PER1_HADDR_22                     \
+		IOMUX_PAD(0x056C, 0x0264, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_50MHZ                                 \
+		IOMUX_PAD(0x0570, 0x0268, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_100MHZ                                \
+	IOMUX_PAD(0x0570, 0x0268, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_200MHZ                                \
+	IOMUX_PAD(0x0570, 0x0268, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT3__AUDMUX_AUD4_TXD                                   \
+		IOMUX_PAD(0x0570, 0x0268, 1, 0x05E8, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__FEC_RX_CLK                                        \
+		IOMUX_PAD(0x0570, 0x0268, 2, 0x0700, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__CSI_D_5                                           \
+		IOMUX_PAD(0x0570, 0x0268, 3, 0x0644, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__UART5_TXD                                         \
+		IOMUX_PAD(0x0570, 0x0268, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__UART5_RXD                                         \
+		IOMUX_PAD(0x0570, 0x0268, 4, 0x081C, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__GPIO_4_28                                         \
+		IOMUX_PAD(0x0570, 0x0268, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__MMDC_MMDC_DEBUG_37                                \
+		IOMUX_PAD(0x0570, 0x0268, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT3__PL301_SIM_MX6SL_PER1_HBURST_0                     \
+		IOMUX_PAD(0x0570, 0x0268, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT4__USDHC2_DAT4_50MHZ                                 \
+		IOMUX_PAD(0x0574, 0x026C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__USDHC2_DAT4_100MHZ                                \
+	IOMUX_PAD(0x0574, 0x026C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT4__USDHC2_DAT4_200MHZ                                \
+	IOMUX_PAD(0x0574, 0x026C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT4__USDHC3_DAT4                                       \
+		IOMUX_PAD(0x0574, 0x026C, 1, 0x083C, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__UART2_TXD                                         \
+		IOMUX_PAD(0x0574, 0x026C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__UART2_RXD                                         \
+		IOMUX_PAD(0x0574, 0x026C, 2, 0x0804, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__CSI_D_6                                           \
+		IOMUX_PAD(0x0574, 0x026C, 3, 0x0648, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__SPDIF_OUT1                                        \
+		IOMUX_PAD(0x0574, 0x026C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__GPIO_5_2                                          \
+		IOMUX_PAD(0x0574, 0x026C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__MMDC_MMDC_DEBUG_36                                \
+		IOMUX_PAD(0x0574, 0x026C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT4__PL301_SIM_MX6SL_PER1_HADDR_10                     \
+		IOMUX_PAD(0x0574, 0x026C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT5__USDHC2_DAT5_50MHZ                                 \
+		IOMUX_PAD(0x0578, 0x0270, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__USDHC2_DAT5_100MHZ                                \
+	IOMUX_PAD(0x0578, 0x0270, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT5__USDHC2_DAT5_200MHZ                                \
+	IOMUX_PAD(0x0578, 0x0270, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT5__USDHC3_DAT5                                       \
+		IOMUX_PAD(0x0578, 0x0270, 1, 0x0840, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__UART2_TXD                                         \
+		IOMUX_PAD(0x0578, 0x0270, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__UART2_RXD                                         \
+		IOMUX_PAD(0x0578, 0x0270, 2, 0x0804, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__CSI_D_7                                           \
+		IOMUX_PAD(0x0578, 0x0270, 3, 0x064C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__SPDIF_IN1                                         \
+		IOMUX_PAD(0x0578, 0x0270, 4, 0x07F0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__GPIO_4_31                                         \
+		IOMUX_PAD(0x0578, 0x0270, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__MMDC_MMDC_DEBUG_35                                \
+		IOMUX_PAD(0x0578, 0x0270, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT5__PL301_SIM_MX6SL_PER1_HADDR_20                     \
+		IOMUX_PAD(0x0578, 0x0270, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT6__USDHC2_DAT6_50MHZ                                 \
+		IOMUX_PAD(0x057C, 0x0274, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__USDHC2_DAT6_100MHZ                                \
+	IOMUX_PAD(0x057C, 0x0274, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT6__USDHC2_DAT6_200MHZ                                \
+	IOMUX_PAD(0x057C, 0x0274, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT6__USDHC3_DAT6                                       \
+		IOMUX_PAD(0x057C, 0x0274, 1, 0x0844, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__UART2_CTS                                         \
+		IOMUX_PAD(0x057C, 0x0274, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__UART2_RTS                                         \
+		IOMUX_PAD(0x057C, 0x0274, 2, 0x0800, 4, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__CSI_D_8                                           \
+		IOMUX_PAD(0x057C, 0x0274, 3, 0x0650, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__USDHC2_WP                                         \
+		IOMUX_PAD(0x057C, 0x0274, 4, 0x0834, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__GPIO_4_29                                         \
+		IOMUX_PAD(0x057C, 0x0274, 5, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__MMDC_MMDC_DEBUG_34                                \
+		IOMUX_PAD(0x057C, 0x0274, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT6__PL301_SIM_MX6SL_PER1_HADDR_19                     \
+		IOMUX_PAD(0x057C, 0x0274, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_DAT7__USDHC2_DAT7_50MHZ                                 \
+		IOMUX_PAD(0x0580, 0x0278, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__USDHC2_DAT7_100MHZ                                \
+	IOMUX_PAD(0x0580, 0x0278, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD2_DAT7__USDHC2_DAT7_200MHZ                                \
+	IOMUX_PAD(0x0580, 0x0278, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD2_DAT7__USDHC3_DAT7                                       \
+		IOMUX_PAD(0x0580, 0x0278, 1, 0x0848, 1, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__UART2_CTS                                         \
+		IOMUX_PAD(0x0580, 0x0278, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__UART2_RTS                                         \
+		IOMUX_PAD(0x0580, 0x0278, 2, 0x0800, 5, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__CSI_D_9                                           \
+		IOMUX_PAD(0x0580, 0x0278, 3, 0x0654, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__USDHC2_CD                                         \
+		IOMUX_PAD(0x0580, 0x0278, 4, 0x0830, 2, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__GPIO_5_0                                          \
+		IOMUX_PAD(0x0580, 0x0278, 5, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__MMDC_MMDC_DEBUG_33                                \
+		IOMUX_PAD(0x0580, 0x0278, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_DAT7__PL301_SIM_MX6SL_PER1_HADDR_16                     \
+		IOMUX_PAD(0x0580, 0x0278, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD2_RST__USDHC2_RST                                         \
+		IOMUX_PAD(0x0584, 0x027C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__FEC_REF_OUT                                        \
+		IOMUX_PAD(0x0584, 0x027C, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__WDOG2_WDOG_B                                       \
+		IOMUX_PAD(0x0584, 0x027C, 2, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__SPDIF_OUT1                                         \
+		IOMUX_PAD(0x0584, 0x027C, 3, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__CSI_MCLK                                           \
+		IOMUX_PAD(0x0584, 0x027C, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__GPIO_4_27                                          \
+		IOMUX_PAD(0x0584, 0x027C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__ANATOP_ANATOP_TESTO_12                             \
+		IOMUX_PAD(0x0584, 0x027C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD2_RST__PL301_SIM_MX6SL_PER1_HBURST_2                      \
+		IOMUX_PAD(0x0584, 0x027C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_CLK__USDHC3_CLK_50MHZ                                   \
+		IOMUX_PAD(0x0588, 0x0280, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__USDHC3_CLK_100MHZ                                  \
+	IOMUX_PAD(0x0588, 0x0280, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_CLK__USDHC3_CLK_200MHZ                                  \
+	IOMUX_PAD(0x0588, 0x0280, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_CLK__AUDMUX_AUD5_RXFS                                   \
+		IOMUX_PAD(0x0588, 0x0280, 1, 0x0608, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__KPP_COL_5                                          \
+		IOMUX_PAD(0x0588, 0x0280, 2, 0x0748, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__CSI_D_10                                           \
+		IOMUX_PAD(0x0588, 0x0280, 3, 0x0658, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__WDOG1_WDOG_RST_B_DEB                               \
+		IOMUX_PAD(0x0588, 0x0280, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__GPIO_5_18                                          \
+		IOMUX_PAD(0x0588, 0x0280, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__USB_USBOTG1_PWR                                    \
+		IOMUX_PAD(0x0588, 0x0280, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CLK__PL301_SIM_MX6SL_PER1_HADDR_13                      \
+		IOMUX_PAD(0x0588, 0x0280, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_CMD__USDHC3_CMD_50MHZ                                   \
+		IOMUX_PAD(0x058C, 0x0284, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__USDHC3_CMD_100MHZ                                  \
+	IOMUX_PAD(0x058C, 0x0284, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_CMD__USDHC3_CMD_200MHZ                                  \
+	IOMUX_PAD(0x058C, 0x0284, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_CMD__AUDMUX_AUD5_RXC                                    \
+		IOMUX_PAD(0x058C, 0x0284, 1, 0x0604, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__KPP_ROW_5                                          \
+		IOMUX_PAD(0x058C, 0x0284, 2, 0x0768, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__CSI_D_11                                           \
+		IOMUX_PAD(0x058C, 0x0284, 3, 0x065C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__ANATOP_USBOTG2_ID                                  \
+		IOMUX_PAD(0x058C, 0x0284, 4, 0x05E0, 3, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__GPIO_5_21                                          \
+		IOMUX_PAD(0x058C, 0x0284, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__USB_USBOTG2_PWR                                    \
+		IOMUX_PAD(0x058C, 0x0284, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_CMD__PL301_SIM_MX6SL_PER1_HADDR_18                      \
+		IOMUX_PAD(0x058C, 0x0284, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ                                 \
+		IOMUX_PAD(0x0590, 0x0288, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_100MHZ                                \
+	IOMUX_PAD(0x0590, 0x0288, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_200MHZ                                \
+	IOMUX_PAD(0x0590, 0x0288, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_DAT0__AUDMUX_AUD5_RXD                                   \
+		IOMUX_PAD(0x0590, 0x0288, 1, 0x05FC, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__KPP_COL_6                                         \
+		IOMUX_PAD(0x0590, 0x0288, 2, 0x074C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__CSI_D_12                                          \
+		IOMUX_PAD(0x0590, 0x0288, 3, 0x0660, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__ANATOP_USBOTG1_ID                                 \
+		IOMUX_PAD(0x0590, 0x0288, 4, 0x05DC, 4, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__GPIO_5_19                                         \
+		IOMUX_PAD(0x0590, 0x0288, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__SJC_JTAG_ACT                                      \
+		IOMUX_PAD(0x0590, 0x0288, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT0__PL301_SIM_MX6SL_PER1_HADDR_11                     \
+		IOMUX_PAD(0x0590, 0x0288, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ                                 \
+		IOMUX_PAD(0x0594, 0x028C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_100MHZ                                \
+	IOMUX_PAD(0x0594, 0x028C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_200MHZ                                \
+	IOMUX_PAD(0x0594, 0x028C, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_DAT1__AUDMUX_AUD5_TXC                                   \
+		IOMUX_PAD(0x0594, 0x028C, 1, 0x060C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__KPP_ROW_6                                         \
+		IOMUX_PAD(0x0594, 0x028C, 2, 0x076C, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__CSI_D_13                                          \
+		IOMUX_PAD(0x0594, 0x028C, 3, 0x0664, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__USDHC1_VSELECT                                    \
+		IOMUX_PAD(0x0594, 0x028C, 4, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__GPIO_5_20                                         \
+		IOMUX_PAD(0x0594, 0x028C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__SJC_DE_B                                          \
+		IOMUX_PAD(0x0594, 0x028C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT1__PL301_SIM_MX6SL_PER1_HADDR_17                     \
+		IOMUX_PAD(0x0594, 0x028C, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ                                 \
+		IOMUX_PAD(0x0598, 0x0290, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_100MHZ                                \
+	IOMUX_PAD(0x0598, 0x0290, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_200MHZ                                \
+	IOMUX_PAD(0x0598, 0x0290, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_DAT2__AUDMUX_AUD5_TXFS                                  \
+		IOMUX_PAD(0x0598, 0x0290, 1, 0x0610, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__KPP_COL_7                                         \
+		IOMUX_PAD(0x0598, 0x0290, 2, 0x0750, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__CSI_D_14                                          \
+		IOMUX_PAD(0x0598, 0x0290, 3, 0x0668, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__EPIT1_EPITO                                       \
+		IOMUX_PAD(0x0598, 0x0290, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__GPIO_5_16                                         \
+		IOMUX_PAD(0x0598, 0x0290, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__USB_USBOTG2_OC                                    \
+		IOMUX_PAD(0x0598, 0x0290, 6, 0x0820, 3, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT2__PL301_SIM_MX6SL_PER1_HADDR_14                     \
+		IOMUX_PAD(0x0598, 0x0290, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ                                 \
+		IOMUX_PAD(0x059C, 0x0294, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_100MHZ                                \
+	IOMUX_PAD(0x059C, 0x0294, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_100MHZ)
+#define MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_200MHZ                                \
+	IOMUX_PAD(0x059C, 0x0294, 0, 0x0000, 0, MX6SL_USDHC_PAD_CTRL_200MHZ)
+#define MX6SL_PAD_SD3_DAT3__AUDMUX_AUD5_TXD                                   \
+		IOMUX_PAD(0x059C, 0x0294, 1, 0x0600, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__KPP_ROW_7                                         \
+		IOMUX_PAD(0x059C, 0x0294, 2, 0x0770, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__CSI_D_15                                          \
+		IOMUX_PAD(0x059C, 0x0294, 3, 0x066C, 1, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__EPIT2_EPITO                                       \
+		IOMUX_PAD(0x059C, 0x0294, 4, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__GPIO_5_17                                         \
+		IOMUX_PAD(0x059C, 0x0294, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__USB_USBOTG1_OC                                    \
+		IOMUX_PAD(0x059C, 0x0294, 6, 0x0824, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_SD3_DAT3__PL301_SIM_MX6SL_PER1_HADDR_12                     \
+		IOMUX_PAD(0x059C, 0x0294, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_TAMPER__SNVS_LP_WRAPPER_SNVS_TD1                            \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_TEST_MODE__TCU_TEST_MODE                                    \
+		IOMUX_PAD(NO_PAD_I, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_UART1_RXD__UART1_TXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 0, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__UART1_RXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 0, 0x07FC, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__PWM1_PWMO                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__UART4_TXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__UART4_RXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 2, 0x0814, 6, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__FEC_COL                                          \
+		IOMUX_PAD(0x05A0, 0x0298, 3, 0x06F0, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__UART5_TXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__UART5_RXD                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 4, 0x081C, 6, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__GPIO_3_16                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__ANATOP_ANATOP_TESTI_2                            \
+		IOMUX_PAD(0x05A0, 0x0298, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_RXD__TPSMP_CLK                                        \
+		IOMUX_PAD(0x05A0, 0x0298, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#define MX6SL_PAD_UART1_TXD__UART1_TXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 0, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART1_RXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 0, 0x07FC, 1, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__PWM2_PWMO                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART4_TXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART4_RXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 2, 0x0814, 7, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__FEC_RX_CLK                                       \
+		IOMUX_PAD(0x05A4, 0x029C, 3, 0x0700, 2, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART5_TXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 4, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART5_RXD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 4, 0x081C, 7, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__GPIO_3_17                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__ANATOP_ANATOP_TESTI_3                            \
+		IOMUX_PAD(0x05A4, 0x029C, 6, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_UART1_TXD__UART5_DCD                                        \
+		IOMUX_PAD(0x05A4, 0x029C, 7, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+
+#define MX6SL_PAD_WDOG_B__WDOG1_WDOG_B                                        \
+		IOMUX_PAD(0x05A8, 0x02A0, 0, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_WDOG_B__WDOG1_WDOG_RST_B_DEB                                \
+		IOMUX_PAD(0x05A8, 0x02A0, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_WDOG_B__UART5_RI                                            \
+		IOMUX_PAD(0x05A8, 0x02A0, 2, 0x0000, 0, MX6SL_UART_PAD_CTRL)
+#define MX6SL_PAD_WDOG_B__GPIO_3_18                                           \
+		IOMUX_PAD(0x05A8, 0x02A0, 5, 0x0000, 0, NO_PAD_CTRL)
+#define MX6SL_PAD_WDOG_B__OBSERVE_MUX_OUT_2                                   \
+		IOMUX_PAD(0x05A8, 0x02A0, 7, 0x0000, 0, NO_PAD_CTRL)
+
+#endif /* __MACH_IOMUX_MX6SL_H__*/
diff --git a/arch/arm/plat-mxc/include/mach/iomux-v1.h b/arch/arm/plat-mxc/include/mach/iomux-v1.h
index f7d1804..c07d302 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-v1.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-v1.h
@@ -85,6 +85,9 @@
 #define GPIO_BOUT_0	(2 << GPIO_BOUT_SHIFT)
 #define GPIO_BOUT_1	(3 << GPIO_BOUT_SHIFT)
 
+/* decode irq number to use with IMR(x), ISR(x) and friends */
+#define IRQ_TO_REG(irq) ((irq - MXC_INTERNAL_IRQS) >> 5)
+
 #define IRQ_GPIOA(x)  (MXC_GPIO_IRQ_START + x)
 #define IRQ_GPIOB(x)  (IRQ_GPIOA(32) + x)
 #define IRQ_GPIOC(x)  (IRQ_GPIOB(32) + x)
@@ -95,7 +98,8 @@
 extern int mxc_gpio_mode(int gpio_mode);
 extern int mxc_gpio_setup_multiple_pins(const int *pin_list, unsigned count,
 		const char *label);
+extern void mxc_gpio_release_multiple_pins(const int *pin_list, int count);
 
-extern int imx_iomuxv1_init(void __iomem *base, int numports);
+extern int __init imx_iomuxv1_init(void __iomem *base, int numports);
 
 #endif /* __MACH_IOMUX_V1_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/iomux-v3.h b/arch/arm/plat-mxc/include/mach/iomux-v3.h
index 4374d51..8bdfe79 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-v3.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-v3.h
@@ -2,6 +2,8 @@
  * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH,
  *			<armlinux@phytec.de>
  *
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
@@ -48,8 +50,8 @@
  * PAD_CTRL_OFS:	   12..23 (12)
  * SEL_INPUT_OFS:	   24..35 (12)
  * MUX_MODE + SION:	   36..40  (5)
- * PAD_CTRL + NO_PAD_CTRL: 41..57 (17)
- * SEL_INP:		   58..61  (4)
+ * PAD_CTRL + NO_PAD_CTRL: 41..58 (18)
+ * SEL_INP:		   59..62  (4)
  * reserved:		     63    (1)
 */
 
@@ -65,8 +67,8 @@ typedef u64 iomux_v3_cfg_t;
 #define MUX_MODE_SHIFT		36
 #define MUX_MODE_MASK		((iomux_v3_cfg_t)0x1f << MUX_MODE_SHIFT)
 #define MUX_PAD_CTRL_SHIFT	41
-#define MUX_PAD_CTRL_MASK	((iomux_v3_cfg_t)0x1ffff << MUX_PAD_CTRL_SHIFT)
-#define MUX_SEL_INPUT_SHIFT	58
+#define MUX_PAD_CTRL_MASK	((iomux_v3_cfg_t)0x3ffff << MUX_PAD_CTRL_SHIFT)
+#define MUX_SEL_INPUT_SHIFT	59
 #define MUX_SEL_INPUT_MASK	((iomux_v3_cfg_t)0xf << MUX_SEL_INPUT_SHIFT)
 
 #define MUX_PAD_CTRL(x)		((iomux_v3_cfg_t)(x) << MUX_PAD_CTRL_SHIFT)
@@ -80,11 +82,20 @@ typedef u64 iomux_v3_cfg_t;
 		((iomux_v3_cfg_t)(_sel_input_ofs) << MUX_SEL_INPUT_OFS_SHIFT) | \
 		((iomux_v3_cfg_t)(_sel_input) << MUX_SEL_INPUT_SHIFT))
 
-#define NEW_PAD_CTRL(cfg, pad)	(((cfg) & ~MUX_PAD_CTRL_MASK) | MUX_PAD_CTRL(pad))
+#define NEW_PAD_CTRL(cfg, pad)	(((cfg) & ~MUX_PAD_CTRL_MASK) | \
+		MUX_PAD_CTRL(pad))
 /*
  * Use to set PAD control
  */
+#define NO_PAD_CTRL			(1 << 17)
+#define NO_PAD_I			0
+#define NO_MUX_I			0
 #ifdef CONFIG_SOC_IMX6Q
+#define PAD_CTL_LVE			(1 << 22)
+#define PAD_CTL_LVE_MASK		(1 << 22)
+#define PAD_CTL_DDR_SEL_LPDDR2		(2 << 18)
+#define PAD_CTL_DDR_SEL_DDR3		(3 << 18)
+#define PAD_CTL_DDR_SEL_MASK		(3 << 18)
 #define PAD_CTL_HYS			(1 << 16)
 
 #define PAD_CTL_PUS_100K_DOWN		(0 << 14)
@@ -109,13 +120,10 @@ typedef u64 iomux_v3_cfg_t;
 #define PAD_CTL_DSE_40ohm		(6 << 3)
 #define PAD_CTL_DSE_34ohm		(7 << 3)
 
-#define NO_PAD_CTRL			(1 << 16)
 #define PAD_CTL_SRE_FAST		(1 << 0)
 #define PAD_CTL_SRE_SLOW		(0 << 0)
 
 #else
-
-#define NO_PAD_CTRL			(1 << 16)
 #define PAD_CTL_DVS			(1 << 13)
 #define PAD_CTL_HYS			(1 << 8)
 
@@ -136,7 +144,6 @@ typedef u64 iomux_v3_cfg_t;
 #define PAD_CTL_SRE_FAST		(1 << 0)
 #define PAD_CTL_SRE_SLOW		(0 << 0)
 #endif
-
 #define IOMUX_CONFIG_SION		(0x1 << 4)
 
 #define MX51_NUM_GPIO_PORT	4
@@ -154,14 +161,16 @@ typedef u64 iomux_v3_cfg_t;
 #define GPIO_PORTF	(5 << GPIO_PORT_SHIFT)
 
 /*
- * setups a single pad in the iomuxer
+ * read/write a single pad in the iomuxer
  */
+int mxc_iomux_v3_get_pad(iomux_v3_cfg_t *pad);
 int mxc_iomux_v3_setup_pad(iomux_v3_cfg_t pad);
 
 /*
- * setups mutliple pads
+ * read/write mutliple pads
  * convenient way to call the above function with tables
  */
+ int mxc_iomux_v3_get_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count);
 int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count);
 
 /*
@@ -173,5 +182,11 @@ void mxc_iomux_v3_init(void __iomem *iomux_v3_base);
  * Set bits for general purpose registers
  */
 void mxc_iomux_set_gpr_register(int group, int start_bit, int num_bits, int value);
+
+/*
+ * Set special bits for iomux registers, such as LVE bit, DDR_SEL bits
+ */
+void mxc_iomux_set_specialbits_register(u32 pad_addr, u32 value, u32 mask);
+
 #endif /* __MACH_IOMUX_V3_H__*/
 
diff --git a/arch/arm/plat-mxc/include/mach/ipu-v3.h b/arch/arm/plat-mxc/include/mach/ipu-v3.h
index 82da102..d5ee6af 100644
--- a/arch/arm/plat-mxc/include/mach/ipu-v3.h
+++ b/arch/arm/plat-mxc/include/mach/ipu-v3.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -419,10 +419,10 @@ typedef struct {
  * Enumeration of CSI data bus widths.
  */
 enum {
-	IPU_CSI_DATA_WIDTH_4,
-	IPU_CSI_DATA_WIDTH_8,
-	IPU_CSI_DATA_WIDTH_10,
-	IPU_CSI_DATA_WIDTH_16,
+	IPU_CSI_DATA_WIDTH_4 = 0,
+	IPU_CSI_DATA_WIDTH_8 = 1,
+	IPU_CSI_DATA_WIDTH_10 = 3,
+	IPU_CSI_DATA_WIDTH_16 = 9,
 };
 
 /*!
@@ -587,6 +587,7 @@ struct ipu_soc;
 struct ipu_soc *ipu_get_soc(int id);
 int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
 void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel);
+void ipu_disable_hsp_clk(struct ipu_soc *ipu);
 
 static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
 {
@@ -737,6 +738,13 @@ struct ipuv3_fb_platform_data {
 	/* reserved mem */
 	resource_size_t 		res_base[2];
 	resource_size_t 		res_size[2];
+
+	/*
+	 * Late init to avoid display channel being
+	 * re-initialized as we've probably setup the
+	 * channel in bootloader.
+	 */
+	bool                            late_init;
 };
 
 struct imx_ipuv3_platform_data {
@@ -745,6 +753,13 @@ struct imx_ipuv3_platform_data {
 	void (*pg) (int);
 
 	char *csi_clk[2];
+
+	/*
+	 * Bypass reset to avoid display channel being
+	 * stopped by probe since it may starts to work
+	 * in bootloader.
+	 */
+	bool bypass_reset;
 };
 
 #endif /* __MACH_IPU_V3_H_ */
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index fd9efb0..c4ffe6f 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,16 +12,11 @@
 #define __ASM_ARCH_MXC_IRQS_H__
 
 #include <asm-generic/gpio.h>
-
 /*
- * SoCs with GIC interrupt controller have 160 IRQs, those with TZIC
- * have 128 IRQs, and those with AVIC have 64.
- *
- * To support single image, the biggest number should be defined on
- * top of the list.
+ * SoCs with TZIC interrupt controller have 128 IRQs, those with AVIC have 64
  */
 #if defined CONFIG_ARM_GIC
-#define MXC_INTERNAL_IRQS	160
+#define MXC_INTERNAL_IRQS      160
 #elif defined CONFIG_MXC_TZIC
 #define MXC_INTERNAL_IRQS	128
 #else
@@ -51,7 +46,6 @@
 #else
 #define MX3_IPU_IRQS 0
 #endif
-/* REVISIT: Add IPU irqs on IMX51 */
 
 #define NR_IRQS			(MXC_IPU_IRQ_START + MX3_IPU_IRQS)
 
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
new file mode 100644
index 0000000..e0a08b7
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_MEMORY_H__
+#define __ASM_ARCH_MXC_MEMORY_H__
+
+#include <asm/sizes.h>
+#include <asm/page.h>
+
+#define MX1_PHYS_OFFSET		UL(0x08000000)
+#define MX21_PHYS_OFFSET	UL(0xc0000000)
+#define MX25_PHYS_OFFSET	UL(0x80000000)
+#define MX27_PHYS_OFFSET	UL(0xa0000000)
+#define MX3x_PHYS_OFFSET	UL(0x80000000)
+#define MX50_PHYS_OFFSET	UL(0x70000000)
+#define MX51_PHYS_OFFSET	UL(0x90000000)
+#define MX53_PHYS_OFFSET	UL(0x70000000)
+#define MX6_PHYS_OFFSET		UL(0x10000000)
+#define MX6SL_PHYS_OFFSET	UL(0x80000000)
+
+#if !defined(CONFIG_RUNTIME_PHYS_OFFSET)
+# if defined CONFIG_ARCH_MX1
+#  define PLAT_PHYS_OFFSET		MX1_PHYS_OFFSET
+# elif defined CONFIG_MACH_MX21
+#  define PLAT_PHYS_OFFSET		MX21_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX25
+#  define PLAT_PHYS_OFFSET		MX25_PHYS_OFFSET
+# elif defined CONFIG_MACH_MX27
+#  define PLAT_PHYS_OFFSET		MX27_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX3
+#  define PLAT_PHYS_OFFSET		MX3x_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX50
+#  define PLAT_PHYS_OFFSET		MX50_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX51
+#  define PLAT_PHYS_OFFSET		MX51_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX53
+#  define PLAT_PHYS_OFFSET		MX53_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX50
+#  define PLAT_PHYS_OFFSET		MX50_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX6
+#  define PLAT_PHYS_OFFSET		MX6_PHYS_OFFSET
+# endif
+#endif
+
+#if defined(CONFIG_MX3_VIDEO)
+/*
+ * Increase size of DMA-consistent memory region.
+ * This is required for mx3 camera driver to capture at least two QXGA frames.
+ */
+#define CONSISTENT_DMA_SIZE SZ_8M
+
+#elif defined(CONFIG_MX1_VIDEO) || defined(CONFIG_VIDEO_MX2_HOSTSUPPORT)
+/*
+ * Increase size of DMA-consistent memory region.
+ * This is required for i.MX camera driver to capture at least four VGA frames.
+ */
+#define CONSISTENT_DMA_SIZE SZ_4M
+#else
+
+#if defined(CONFIG_ARCH_MX5) || defined(CONFIG_ARCH_MX6)
+#define ARM_DMA_ZONE_SIZE	(184 * SZ_1M)
+#define CONSISTENT_DMA_SIZE	ARM_DMA_ZONE_SIZE
+#else
+#define CONSISTENT_DMA_SIZE     (32 * SZ_1M)
+#endif
+
+#endif /* CONFIG_MX1_VIDEO || CONFIG_VIDEO_MX2_HOSTSUPPORT */
+
+
+#endif /* __ASM_ARCH_MXC_MEMORY_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mipi_dsi.h b/arch/arm/plat-mxc/include/mach/mipi_dsi.h
new file mode 100644
index 0000000..0dd1f08
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mipi_dsi.h
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __INCLUDE_MIPI_DSI_H
+#define __INCLUDE_MIPI_DSI_H
+
+#define     MIPI_DSI_VERSION		(0x000)
+#define     MIPI_DSI_PWR_UP		(0x004)
+#define     MIPI_DSI_CLKMGR_CFG		(0x008)
+#define     MIPI_DSI_DPI_CFG		(0x00c)
+#define     MIPI_DSI_DBI_CFG		(0x010)
+#define     MIPI_DSI_DBIS_CMDSIZE	(0x014)
+#define     MIPI_DSI_PCKHDL_CFG		(0x018)
+#define     MIPI_DSI_VID_MODE_CFG	(0x01c)
+#define     MIPI_DSI_VID_PKT_CFG	(0x020)
+#define     MIPI_DSI_CMD_MODE_CFG	(0x024)
+#define     MIPI_DSI_TMR_LINE_CFG	(0x028)
+#define     MIPI_DSI_VTIMING_CFG	(0x02c)
+#define     MIPI_DSI_PHY_TMR_CFG	(0x030)
+#define     MIPI_DSI_GEN_HDR		(0x034)
+#define     MIPI_DSI_GEN_PLD_DATA	(0x038)
+#define     MIPI_DSI_CMD_PKT_STATUS	(0x03c)
+#define     MIPI_DSI_TO_CNT_CFG		(0x040)
+#define     MIPI_DSI_ERROR_ST0		(0x044)
+#define     MIPI_DSI_ERROR_ST1		(0x048)
+#define     MIPI_DSI_ERROR_MSK0		(0x04c)
+#define     MIPI_DSI_ERROR_MSK1		(0x050)
+#define     MIPI_DSI_PHY_RSTZ		(0x054)
+#define     MIPI_DSI_PHY_IF_CFG		(0x058)
+#define     MIPI_DSI_PHY_IF_CTRL	(0x05c)
+#define     MIPI_DSI_PHY_STATUS		(0x060)
+#define     MIPI_DSI_PHY_TST_CTRL0	(0x064)
+#define     MIPI_DSI_PHY_TST_CTRL1	(0x068)
+
+#define		DSI_PWRUP_RESET					(0x0 << 0)
+#define		DSI_PWRUP_POWERUP				(0x1 << 0)
+
+#define		DSI_DPI_CFG_VID_SHIFT				(0)
+#define		DSI_DPI_CFG_VID_MASK				(0x3)
+#define		DSI_DPI_CFG_COLORCODE_SHIFT			(2)
+#define		DSI_DPI_CFG_COLORCODE_MASK			(0x7)
+#define		DSI_DPI_CFG_DATAEN_ACT_LOW			(0x1 << 5)
+#define		DSI_DPI_CFG_DATAEN_ACT_HIGH			(0x0 << 5)
+#define		DSI_DPI_CFG_VSYNC_ACT_LOW			(0x1 << 6)
+#define		DSI_DPI_CFG_VSYNC_ACT_HIGH			(0x0 << 6)
+#define		DSI_DPI_CFG_HSYNC_ACT_LOW			(0x1 << 7)
+#define		DSI_DPI_CFG_HSYNC_ACT_HIGH			(0x0 << 7)
+#define		DSI_DPI_CFG_SHUTD_ACT_LOW			(0x1 << 8)
+#define		DSI_DPI_CFG_SHUTD_ACT_HIGH			(0x0 << 8)
+#define		DSI_DPI_CFG_COLORMODE_ACT_LOW			(0x1 << 9)
+#define		DSI_DPI_CFG_COLORMODE_ACT_HIGH			(0x0 << 9)
+#define		DSI_DPI_CFG_EN18LOOSELY				(0x1 << 10)
+
+#define		DSI_PCKHDL_CFG_EN_EOTP_TX			(0x1 << 0)
+#define		DSI_PCKHDL_CFG_EN_EOTP_RX			(0x1 << 1)
+#define		DSI_PCKHDL_CFG_EN_BTA				(0x1 << 2)
+#define		DSI_PCKHDL_CFG_EN_ECC_RX			(0x1 << 3)
+#define		DSI_PCKHDL_CFG_EN_CRC_RX			(0x1 << 4)
+#define		DSI_PCKHDL_CFG_GEN_VID_RX_MASK			(0x3)
+#define		DSI_PCKHDL_CFG_GEN_VID_RX_SHIFT			(5)
+
+#define		DSI_VID_MODE_CFG_EN				(0x1 << 0)
+#define		DSI_VID_MODE_CFG_EN_BURSTMODE			(0x3 << 1)
+#define		DSI_VID_MODE_CFG_TYPE_MASK			(0x3)
+#define		DSI_VID_MODE_CFG_TYPE_SHIFT			(1)
+#define		DSI_VID_MODE_CFG_EN_LP_VSA			(0x1 << 3)
+#define		DSI_VID_MODE_CFG_EN_LP_VBP			(0x1 << 4)
+#define		DSI_VID_MODE_CFG_EN_LP_VFP			(0x1 << 5)
+#define		DSI_VID_MODE_CFG_EN_LP_VACT			(0x1 << 6)
+#define		DSI_VID_MODE_CFG_EN_LP_HBP			(0x1 << 7)
+#define		DSI_VID_MODE_CFG_EN_LP_HFP			(0x1 << 8)
+#define		DSI_VID_MODE_CFG_EN_MULTI_PKT			(0x1 << 9)
+#define		DSI_VID_MODE_CFG_EN_NULL_PKT			(0x1 << 10)
+#define		DSI_VID_MODE_CFG_EN_FRAME_ACK			(0x1 << 11)
+#define		DSI_VID_MODE_CFG_EN_LP_MODE (DSI_VID_MODE_CFG_EN_LP_VSA | \
+						 DSI_VID_MODE_CFG_EN_LP_VBP | \
+						 DSI_VID_MODE_CFG_EN_LP_VFP | \
+						 DSI_VID_MODE_CFG_EN_LP_HFP | \
+						 DSI_VID_MODE_CFG_EN_LP_HBP | \
+						 DSI_VID_MODE_CFG_EN_LP_VACT)
+
+
+
+#define		DSI_VID_PKT_CFG_VID_PKT_SZ_MASK			(0x7ff)
+#define		DSI_VID_PKT_CFG_VID_PKT_SZ_SHIFT		(0)
+#define		DSI_VID_PKT_CFG_NUM_CHUNKS_MASK			(0x3ff)
+#define		DSI_VID_PKT_CFG_NUM_CHUNKS_SHIFT		(11)
+#define		DSI_VID_PKT_CFG_NULL_PKT_SZ_MASK		(0x3ff)
+#define		DSI_VID_PKT_CFG_NULL_PKT_SZ_SHIFT		(21)
+
+#define		MIPI_DSI_CMD_MODE_CFG_EN_LOWPOWER		(0x1FFF)
+#define		MIPI_DSI_CMD_MODE_CFG_EN_CMD_MODE		(0x1 << 0)
+
+#define		DSI_TME_LINE_CFG_HSA_TIME_MASK			(0x1ff)
+#define		DSI_TME_LINE_CFG_HSA_TIME_SHIFT			(0)
+#define		DSI_TME_LINE_CFG_HBP_TIME_MASK			(0x1ff)
+#define		DSI_TME_LINE_CFG_HBP_TIME_SHIFT			(9)
+#define		DSI_TME_LINE_CFG_HLINE_TIME_MASK		(0x3fff)
+#define		DSI_TME_LINE_CFG_HLINE_TIME_SHIFT		(18)
+
+#define		DSI_VTIMING_CFG_VSA_LINES_MASK			(0xf)
+#define		DSI_VTIMING_CFG_VSA_LINES_SHIFT			(0)
+#define		DSI_VTIMING_CFG_VBP_LINES_MASK			(0x3f)
+#define		DSI_VTIMING_CFG_VBP_LINES_SHIFT			(4)
+#define		DSI_VTIMING_CFG_VFP_LINES_MASK			(0x3f)
+#define		DSI_VTIMING_CFG_VFP_LINES_SHIFT			(10)
+#define		DSI_VTIMING_CFG_V_ACT_LINES_MASK		(0x7ff)
+#define		DSI_VTIMING_CFG_V_ACT_LINES_SHIFT		(16)
+
+#define		DSI_PHY_TMR_CFG_BTA_TIME_MASK			(0xfff)
+#define		DSI_PHY_TMR_CFG_BTA_TIME_SHIFT			(0)
+#define		DSI_PHY_TMR_CFG_LP2HS_TIME_MASK			(0xff)
+#define		DSI_PHY_TMR_CFG_LP2HS_TIME_SHIFT		(12)
+#define		DSI_PHY_TMR_CFG_HS2LP_TIME_MASK			(0xff)
+#define		DSI_PHY_TMR_CFG_HS2LP_TIME_SHIFT		(20)
+
+#define		DSI_PHY_IF_CFG_N_LANES_MASK			(0x3)
+#define		DSI_PHY_IF_CFG_N_LANES_SHIFT			(0)
+#define		DSI_PHY_IF_CFG_WAIT_TIME_MASK			(0xff)
+#define		DSI_PHY_IF_CFG_WAIT_TIME_SHIFT			(2)
+
+#define		DSI_PHY_RSTZ_EN_CLK				(0x1 << 2)
+#define		DSI_PHY_RSTZ_DISABLE_RST			(0x1 << 1)
+#define		DSI_PHY_RSTZ_DISABLE_SHUTDOWN			(0x1 << 0)
+#define		DSI_PHY_RSTZ_RST				(0x0)
+
+#define		DSI_PHY_STATUS_LOCK				(0x1 << 0)
+#define		DSI_PHY_STATUS_STOPSTATE_CLK_LANE		(0x1 << 2)
+
+#define		DSI_GEN_HDR_TYPE_MASK				(0xff)
+#define		DSI_GEN_HDR_TYPE_SHIFT				(0)
+#define		DSI_GEN_HDR_DATA_MASK				(0xffff)
+#define		DSI_GEN_HDR_DATA_SHIFT				(8)
+
+#define		DSI_CMD_PKT_STATUS_GEN_CMD_EMPTY		(0x1 << 0)
+#define		DSI_CMD_PKT_STATUS_GEN_CMD_FULL			(0x1 << 1)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_W_EMPTY		(0x1 << 2)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_W_FULL		(0x1 << 3)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_R_EMPTY		(0x1 << 4)
+#define		DSI_CMD_PKT_STATUS_GEN_RD_CMD_BUSY		(0x1 << 6)
+
+#define		DSI_ERROR_MSK0_ALL_MASK				(0x1fffff)
+#define		DSI_ERROR_MSK1_ALL_MASK				(0x3ffff)
+
+#define		DSI_PHY_IF_CTRL_RESET				(0x0)
+#define		DSI_PHY_IF_CTRL_TX_REQ_CLK_HS			(0x1 << 0)
+#define		DSI_PHY_IF_CTRL_TX_REQ_CLK_ULPS			(0x1 << 1)
+#define		DSI_PHY_IF_CTRL_TX_EXIT_CLK_ULPS		(0x1 << 2)
+#define		DSI_PHY_IF_CTRL_TX_REQ_DATA_ULPS		(0x1 << 3)
+#define		DSI_PHY_IF_CTRL_TX_EXIT_DATA_ULPS		(0x1 << 4)
+#define		DSI_PHY_IF_CTRL_TX_TRIG_MASK			(0xF)
+#define		DSI_PHY_IF_CTRL_TX_TRIG_SHIFT			(5)
+
+#define		DSI_PHY_CLK_INIT_COMMAND			(0x44)
+#define		DSI_GEN_PLD_DATA_BUF_SIZE			(0x4)
+/**
+ * struct mipi_dsi_platform_data - MIPI DSI driver platform data.
+ *
+ * This structure communicates platform-specific information to the MIPI DSI
+ * driver that can't be expressed as resources.
+ *
+ * @ipu_id:	 the id of IPUs on which this MIPI DSI works
+ *
+ * @disp_id:	 the id of IPU display interfaces
+ *
+ * @lcd_panel:	 the supported mipi LCD panel string
+ *
+ * @init:	 A pointer to a function the driver will call to
+ *              initialize the platform (e.g., set up the pin mux).
+ * @exit:         A pointer to a function the driver will call to
+ *                           exit the platform (e.g., free pins).
+ * @io_regulator:	 io regulator name for MIPI DSI display module
+ *
+ * @core_regulator:	 core regulator name for MIPI DSI display module
+ *
+ * @analog_regulator:	 analog regulator name for MIPI DSI display module
+ *
+ * @io_volt:	 io regulator voltage for MIPI DSI display module
+ *
+ * @core_volt:	 core regulator voltage for MIPI DSI display module
+ *
+ * @analog_volt:	 analog regulator voltage for MIPI DSI display module
+ *
+ * @reset:		 A pointer to a function the driver will call to
+ *                           reset the MIPI DSI display module
+ * @lcd_power:		 A pointer to a function the drvier will call to
+ *                           configure the power of MIPI LCD panel
+ * @backlight_power:         A pointer to a function the drvier will call to
+ *                           configure the power of MIPI LCD backlight
+ */
+struct mipi_dsi_platform_data {
+	/* SoC hardware information. */
+	int	ipu_id;
+	int	disp_id;
+	char	*lcd_panel;
+	int	(*init)(struct platform_device *);
+	void	(*exit)(struct platform_device *);
+
+	/* board related information. */
+	char	 *io_regulator;
+	char	 *core_regulator;
+	char	 *analog_regulator;
+	int	io_volt;
+	int	core_volt;
+	int	analog_volt;
+	void	 (*reset) (void);
+	void	 (*lcd_power)(int);
+	void	 (*backlight_power)(int);
+};
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mx6q.h b/arch/arm/plat-mxc/include/mach/mx6q.h
index 0c40a1e..7d0f3ff 100644
--- a/arch/arm/plat-mxc/include/mach/mx6q.h
+++ b/arch/arm/plat-mxc/include/mach/mx6q.h
@@ -1,39 +1,44 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc. All Rights Reserved.
- * Copyright 2011 Linaro Ltd.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef __MACH_MX6Q_H__
-#define __MACH_MX6Q_H__
+#ifndef __ASM_ARCH_MXC_MX6_H__
+#define __ASM_ARCH_MXC_MX6_H__
+
 
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
 #error "Do not include directly."
 #endif
 
-#define MX6Q_IO_P2V(x)			IMX_IO_P2V(x)
-#define MX6Q_IO_ADDRESS(x)		IOMEM(MX6Q_IO_P2V(x))
+#define MX6Q_IO_P2V(x)                 IMX_IO_P2V(x)
+#define MX6Q_IO_ADDRESS(x)             IOMEM(MX6Q_IO_P2V(x))
 
 /*
  * The following are the blocks that need to be statically mapped.
  * For other blocks, the base address really should be retrieved from
  * device tree.
  */
-#define MX6Q_SCU_BASE_ADDR		0x00a00000
-#define MX6Q_SCU_SIZE			0x1000
-#define MX6Q_CCM_BASE_ADDR		0x020c4000
-#define MX6Q_CCM_SIZE			0x4000
-#define MX6Q_ANATOP_BASE_ADDR		0x020c8000
-#define MX6Q_ANATOP_SIZE		0x1000
-#define MX6Q_UART2_BASE_ADDR		0x021e8000
-#define MX6Q_UART4_BASE_ADDR		0x021f0000
-#define MX6Q_UART_SIZE			0x4000
+#define MX6Q_SCU_BASE_ADDR             0x00a00000
+#define MX6Q_SCU_SIZE                  0x1000
+#define MX6Q_CCM_BASE_ADDR             0x020c4000
+#define MX6Q_CCM_SIZE                  0x4000
+#define MX6Q_ANATOP_BASE_ADDR          0x020c8000
+#define MX6Q_ANATOP_SIZE               0x1000
+#define MX6Q_UART_SIZE                 0x4000
 
 /*!
  * @file arch-mxc/mx6.h
@@ -76,6 +81,8 @@
 #define MMDC0_ARB_END_ADDR		0x7FFFFFFF
 #define MMDC1_ARB_BASE_ADDR		0x80000000
 #define MMDC1_ARB_END_ADDR		0xFFFFFFFF
+#define MX6SL_MMDC0_ARB_BASE_ADDR	0x80000000	/* only MX6SL */
+#define MX6SL_MMDC0_ARB_END_ADDR	0xFFFFFFFF
 #define OCRAM_ARB_BASE_ADDR		0x00900000
 #define OCRAM_ARB_END_ADDR		0x009FFFFF
 #define IRAM_BASE_ADDR			OCRAM_ARB_BASE_ADDR
@@ -87,14 +94,14 @@
 #define MX6Q_IRAM_BASE_ADDR		IRAM_BASE_ADDR
 /* The last 4K is for cpu hotplug to workaround wdog issue*/
 #define MX6Q_IRAM_SIZE			(SZ_256K - SZ_4K)
-#define MX6DL_IRAM_SIZE			(SZ_128K - SZ_4K)
+#define MX6DL_MX6SL_IRAM_SIZE			(SZ_128K - SZ_4K)
 
 /* Blocks connected via pl301periph */
 #define ROMCP_ARB_BASE_ADDR		0x00000000
 #define ROMCP_ARB_END_ADDR		0x000FFFFF
 #define BOOT_ROM_BASE_ADDR		ROMCP_ARB_BASE_ADDR
-#define CAAM_ARB_BASE_ADDR		0x00100000
-#define CAAM_ARB_END_ADDR		0x00103FFF
+#define CAAM_SECMEM_BASE_ADDR		0x00100000
+#define CAAM_SECMEM_END_ADDR		0x00103FFF
 #define APBH_DMA_ARB_BASE_ADDR		0x00110000
 #define APBH_DMA_ARB_END_ADDR		0x00117FFF
 #define MX6Q_HDMI_ARB_BASE_ADDR		0x00120000
@@ -103,6 +110,8 @@
 #define GPU_3D_ARB_END_ADDR		0x00133FFF
 #define GPU_2D_ARB_BASE_ADDR		0x00134000
 #define GPU_2D_ARB_END_ADDR		0x00137FFF
+#define MX6SL_GPU_2D_ARB_BASE_ADDR	0x02200000	/* MX6SL */
+#define MX6SL_GPU_2D_ARB_END_ADDR	0x02203FFF	/* MX6SL */
 #define DTCP_ARB_BASE_ADDR		0x00138000
 #define DTCP_ARB_END_ADDR		0x0013BFFF
 
@@ -110,6 +119,7 @@
 #define GPV0_BASE_ADDR			0x00B00000
 #define GPV1_BASE_ADDR			0x00C00000
 #define GPV2_BASE_ADDR			0x00200000
+#define MX6SL_GPV2_BASE_ADDR		0x00D00000	/* GPV0-2 for MX6SL */
 #define GPV3_BASE_ADDR			0x00300000
 #define GPV4_BASE_ADDR			0x00800000
 
@@ -149,12 +159,17 @@
 #define MX6Q_ECSPI3_BASE_ADDR		(ATZ1_BASE_ADDR + 0x10000) /* slot 4 */
 #define MX6Q_ECSPI4_BASE_ADDR		(ATZ1_BASE_ADDR + 0x14000) /* slot 5 */
 #define MX6Q_ECSPI5_BASE_ADDR		(ATZ1_BASE_ADDR + 0x18000) /* slot 6 */
+#define MX6SL_UART5_BASE_ADDR		(ATZ1_BASE_ADDR + 0x18000) /* MX6SL */
 #define UART1_BASE_ADDR			(ATZ1_BASE_ADDR + 0x20000) /* slot 8 */
 #define ESAI1_BASE_ADDR			(ATZ1_BASE_ADDR + 0x24000) /* slot 9 */
+#define MX6SL_UART1_BASE_ADDR		(ATZ1_BASE_ADDR + 0x20000) /* MX6SL */
+#define MX6SL_UART2_BASE_ADDR		(ATZ1_BASE_ADDR + 0x24000) /* MX6SL */
 #define MX6Q_SSI1_BASE_ADDR		(ATZ1_BASE_ADDR + 0x28000) /* slot 10 */
 #define MX6Q_SSI2_BASE_ADDR		(ATZ1_BASE_ADDR + 0x2C000) /* slot 11 */
 #define MX6Q_SSI3_BASE_ADDR		(ATZ1_BASE_ADDR + 0x30000) /* slot 12 */
 #define MX6Q_ASRC_BASE_ADDR		(ATZ1_BASE_ADDR + 0x34000) /* slot 13 */
+#define MX6SL_UART3_BASE_ADDR		(ATZ1_BASE_ADDR + 0x34000) /* MX6SL */
+#define MX6SL_UART4_BASE_ADDR		(ATZ1_BASE_ADDR + 0x38000) /* MX6SL */
 #define SPBA_BASE_ADDR			(ATZ1_BASE_ADDR + 0x3C000) /* slot 15 */
 #define MX6Q_VPU_BASE_ADDR		(ATZ1_BASE_ADDR + 0x40000) /* slot 33,
 					global en[1], til 0x7BFFF */
@@ -170,7 +185,9 @@
 #define MX6Q_PWM3_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x8000)
 #define MX6Q_PWM4_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0xC000)
 #define MX6Q_CAN1_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x10000)
+#define MX6SL_DBGMON_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x10000)
 #define MX6Q_CAN2_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x14000)
+#define MX6SL_QOSC_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x14000)
 #define GPT_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x18000)
 #define GPIO1_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x1C000)
 #define GPIO2_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x20000)
@@ -179,7 +196,7 @@
 #define GPIO5_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x2C000)
 #define GPIO6_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x30000)
 #define GPIO7_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x34000)
-#define KPP_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x38000)
+#define MX6SL_KPP_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x38000)
 #define MX6Q_WDOG1_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x3C000)
 #define MX6Q_WDOG2_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x40000)
 #define CCM_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x44000)
@@ -193,11 +210,14 @@
 #define GPC_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x5C000)
 #define MX6Q_IOMUXC_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x60000)
 #define DCIC1_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x64000)
+#define MX6SL_CSI_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x64000)
 #define DCIC2_BASE_ADDR			(AIPS1_OFF_BASE_ADDR + 0x68000)
+#define MX6SL_SIPIX_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x68000)
 #define MX6Q_SDMA_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x6C000)
 #define MX6DL_EPXP_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x70000)
 #define MX6DL_EPDC_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x74000)
-#define MX6DL_LCDIF_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x78000)
+#define MX6DL_ELCDIF_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x78000)
+#define MX6SL_DCP_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x7C000)
 #define MX6Q_DVFSCORE_BASE_ADDR		(GPC_BASE_ADDR + 0x180)
 
 /* ATZ#2- On Platform */
@@ -213,13 +233,27 @@
 /* ARM Cortex A9 MPCore Platform */
 #define MX6Q_A9_PLATFRM_BASE		(ARM_BASE_ADDR + 0x20000)
 
+/* ARM Cortex A9 PTM */
+#define MX6Q_PTM0_BASE_ADDR		0x0215C000
+#define MX6Q_PTM1_BASE_ADDR		0x0215D000
+#define MX6Q_PTM2_BASE_ADDR		0x0215E000
+#define MX6Q_PTM3_BASE_ADDR		0x0215F000
+#define MX6Q_FUNNEL_BASE_ADDR		0x02144000
+#define MX6Q_ETB_BASE_ADDR		0x02141000
+
 #define MX6Q_PL301_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x0000)
 #define MX6Q_USB_OTG_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4000)
 #define MX6Q_USB_HS1_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4200)
 #define MX6Q_USB_HS2_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4400)
 #define MX6Q_USB_HS3_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4600)
+#define MX6SL_USB_HS1_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4200)
+#define MX6SL_USB_HS2_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4400)
+#define MX6SL_USB_HS3_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x4600)
 #define ENET_BASE_ADDR			(AIPS2_OFF_BASE_ADDR+0x8000)
 #define MLB_BASE_ADDR			(AIPS2_OFF_BASE_ADDR+0xC000)
+#define MX6SL_MSHC_BASE_ADDR		(AIPS2_OFF_BASE_ADDR+0xC000)
+
+#define MXC_CAAM_BASE_ADDR		(AIPS2_ARB_BASE_ADDR + 0x00000)
 
 #define MX6Q_USDHC1_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x10000)
 #define MX6Q_USDHC2_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x14000)
@@ -228,9 +262,11 @@
 #define MX6Q_I2C1_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x20000)
 #define MX6Q_I2C2_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x24000)
 #define MX6Q_I2C3_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x28000)
+#define MX6SL_I2C4_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x78000)
 #define ROMCP_BASE_ADDR			(AIPS2_OFF_BASE_ADDR + 0x2C000)
 #define MMDC_P0_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x30000)
 #define MMDC_P1_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x34000)
+#define MX6SL_RNGB_BASE_ADDR		(AIPS2_OFF_BASE_ADDR + 0x34000)
 #define WEIM_BASE_ADDR			(AIPS2_OFF_BASE_ADDR + 0x38000)
 #define OCOTP_BASE_ADDR			(AIPS2_OFF_BASE_ADDR + 0x3C000)
 #define CSU_BASE_ADDR			(AIPS2_OFF_BASE_ADDR + 0x40000)
@@ -261,14 +297,18 @@
 
 
 #define MX6Q_UART1_BASE_ADDR		UART1_BASE_ADDR
+#define MX6Q_UART2_BASE_ADDR		UART2_BASE_ADDR
 #define MX6Q_UART3_BASE_ADDR		UART3_BASE_ADDR
+#define MX6Q_UART4_BASE_ADDR		UART4_BASE_ADDR
 #define MX6Q_UART5_BASE_ADDR		UART5_BASE_ADDR
+
 #define MX6Q_FEC_BASE_ADDR		ENET_BASE_ADDR
+#define MX6DL_FEC_BASE_ADDR		ENET_BASE_ADDR
 #define MX6Q_MIPI_DSI_BASE_ADDR		MIPI_DSI_BASE_ADDR
 #define	MX6Q_MIPI_CSI2_BASE_ADDR	MIPI_CSI2_BASE_ADDR
 
 /* define virtual address */
-#define PERIPBASE_VIRT			0xF6000000
+#define PERIPBASE_VIRT			0xF2000000
 #define BOOT_ROM_BASE_ADDR_VIRT		(PERIPBASE_VIRT + BOOT_ROM_BASE_ADDR)
 #define AIPS1_BASE_ADDR_VIRT		(PERIPBASE_VIRT + AIPS1_ARB_BASE_ADDR)
 #define AIPS2_BASE_ADDR_VIRT		(PERIPBASE_VIRT + AIPS2_ARB_BASE_ADDR)
@@ -278,6 +318,11 @@
 #define AIPS2_SIZE			SZ_1M
 #define ARM_PERIPHBASE_SIZE		(SZ_8K + SZ_4K)
 
+#define SRC_GPR9			0x40
+#define SRC_GPR10			0x44
+
+#define SNVS_LPGPR			0x68
+
 /* GPC offsets */
 #define MXC_GPC_CNTR_OFFSET		0x0
 
@@ -293,7 +338,7 @@
 	(((((x) >= (unsigned long)AIPS1_ARB_BASE_ADDR) && \
 	  ((x) <= (unsigned long)AIPS2_ARB_END_ADDR)) || \
 	  ((x) >= (unsigned long)ARM_PERIPHBASE && \
-	  ((x) <= (unsigned long)(ARM_PERIPHBASE + ARM_PERIPHBASE)))) ? \
+	  ((x) <= (unsigned long)(ARM_PERIPHBASE + ARM_PERIPHBASE_SIZE)))) ? \
 	   MX6_IO_ADDRESS(x) : (void __force __iomem *)0xDEADBEEF)
 
 /*
@@ -304,10 +349,15 @@
 #define MXC_INT_CHEETAH_CSYSPWRUPREQ	33
 #define MX6Q_INT_SDMA			34
 #define MX6Q_INT_VPU_JPG		35
+#define MX6DL_INT_MSHC			35
 #define MXC_INT_INTERRUPT_36_NUM	36
 #define MX6Q_INT_IPU1_ERR		37
+#define MX6SL_INT_RNGB			37
 #define MX6Q_INT_IPU1_SYN		38
+#define MX6SL_INT_SPDC			38
 #define MX6Q_INT_IPU2_ERR		39
+#define MX6DL_INT_CSI			39
+#define MX6SL_INT_CSI			39
 #define MX6Q_INT_IPU2_SYN		40
 #define MXC_INT_GPU3D_IRQ		41
 #define MXC_INT_GPU2D_IRQ		42
@@ -341,19 +391,26 @@
 #define MX6Q_INT_I2C2			69
 #define MX6Q_INT_I2C3			70
 #define MX6Q_INT_SATA			71
-#define MX6DL_INT_LCDIF			71
+#define MX6DL_INT_ELCDIF		71
 #define MX6Q_INT_USB_HS1		72
+#define MX6SL_INT_USB_HS1		74
 #define MX6Q_INT_USB_HS2		73
+#define MX6SL_INT_USB_HS2		72
 #define MX6Q_INT_USB_HS3		74
+#define MX6SL_INT_USB_HS3		73
 #define MX6Q_INT_USB_OTG		75
 #define MX6Q_INT_USB_PHY0		76
 #define MX6Q_INT_USB_PHY1		77
+#define MX6SL_INT_USB_PHY0		76
+#define MX6SL_INT_USB_PHY1		77
 /*
  * MX6Q_INT_USB_PHY2, MX6Q_INT_USB_PHY3 are dummy interrupts
  * In order to compile pass for platform device's definition
  */
 #define MX6Q_INT_USB_PHY2		73
 #define MX6Q_INT_USB_PHY3		74
+#define MX6SL_INT_USB_PHY2		72
+#define MX6SL_INT_USB_PHY3		73
 #define MX6Q_INT_SSI1			78
 #define MX6Q_INT_SSI2			79
 #define MX6Q_INT_SSI3			80
@@ -363,6 +420,7 @@
 #define MX6Q_INT_SPDIF			84
 #define MXC_INT_MLB			85
 #define MXC_INT_ANATOP_ANA1		86
+#define MXDL_INT_PMU			86
 #define MXC_INT_GPT			87
 #define MXC_INT_EPIT1			88
 #define MXC_INT_EPIT2			89
@@ -374,23 +432,24 @@
 #define MXC_INT_GPIO1_INT2_NUM		95
 #define MXC_INT_GPIO1_INT1_NUM		96
 #define MXC_INT_GPIO1_INT0_NUM		97
-#define MXC_INT_GPIO1_LOW		98
-#define MXC_INT_GPIO1_HIGH		99
-#define MXC_INT_GPIO2_LOW		100
-#define MXC_INT_GPIO2_HIGH		101
-#define MXC_INT_GPIO3_LOW		102
-#define MXC_INT_GPIO3_HIGH		103
-#define MXC_INT_GPIO4_LOW		104
-#define MXC_INT_GPIO4_HIGH		105
-#define MXC_INT_GPIO5_LOW		106
-#define MXC_INT_GPIO5_HIGH		107
-#define MXC_INT_GPIO6_LOW		108
-#define MXC_INT_GPIO6_HIGH		109
-#define MXC_INT_GPIO7_LOW		110
-#define MXC_INT_GPIO7_HIGH		111
-#define MXC_INT_WDOG1			112
-#define MXC_INT_WDOG2			113
+#define MXC_INT_GPIO1_INT15_0_NUM	98
+#define MXC_INT_GPIO1_INT31_16_NUM	99
+#define MXC_INT_GPIO2_INT15_0_NUM	100
+#define MXC_INT_GPIO2_INT31_16_NUM	101
+#define MXC_INT_GPIO3_INT15_0_NUM	102
+#define MXC_INT_GPIO3_INT31_16_NUM	103
+#define MXC_INT_GPIO4_INT15_0_NUM	104
+#define MXC_INT_GPIO4_INT31_16_NUM	105
+#define MXC_INT_GPIO5_INT15_0_NUM	106
+#define MXC_INT_GPIO5_INT31_16_NUM	107
+#define MXC_INT_GPIO6_INT15_0_NUM	108
+#define MXC_INT_GPIO6_INT31_16_NUM	109
+#define MXC_INT_GPIO7_INT15_0_NUM	110
+#define MXC_INT_GPIO7_INT31_16_NUM	111
+#define MX6Q_INT_WDOG1			112
+#define MX6Q_INT_WDOG2			113
 #define MXC_INT_KPP			114
+#define MX6SL_INT_KPP			114
 #define MX6Q_INT_PWM1			115
 #define MX6Q_INT_PWM2			116
 #define MX6Q_INT_PWM3			117
@@ -408,6 +467,9 @@
 #define MX6DL_INT_EPDC			129
 #define MX6DL_INT_EPXP			130
 #define MXC_INT_INTERRUPT_131_NUM	131
+#define MX6SL_INT_DCP_GEN		131
+#define MX6SL_INT_DCP_CH0		132
+#define MX6SL_INT_DCP_SEC		133
 #define MXC_INT_CSI_INTR1		132
 #define MXC_INT_CSI_INTR2		133
 #define MXC_INT_DSI			134
@@ -423,6 +485,7 @@
 #define MX6Q_INT_PERFMON1		144
 #define MX6Q_INT_PERFMON2		145
 #define MX6Q_INT_PERFMON3		146
+#define MX6DL_INT_FEC			146
 #define MX6Q_INT_HDMI_TX		147
 #define MX6Q_INT_HDMI_TX_WAKEUP		148
 #define MXC_INT_MLB_AHB0		149
@@ -443,6 +506,11 @@
 #define MX6Q_INT_UART3			MXC_INT_UART3_ANDED
 #define MX6Q_INT_UART4			MXC_INT_UART4_ANDED
 #define MX6Q_INT_UART5			MXC_INT_UART5_ANDED
+#define MX6SL_INT_UART1			MXC_INT_UART1_ANDED
+#define MX6SL_INT_UART2			MXC_INT_UART2_ANDED
+#define MX6SL_INT_UART3			MXC_INT_UART3_ANDED
+#define MX6SL_INT_UART4			MXC_INT_UART4_ANDED
+#define MX6SL_INT_UART5			MXC_INT_UART5_ANDED
 #define MX6Q_INT_FEC			MXC_INT_ENET1
 #define MX6Q_INT_DSI			MXC_INT_DSI
 
@@ -518,8 +586,10 @@
 #define MX6Q_DMA_REQ_SSI3_TX0		46
 #define MX6Q_DMA_REQ_DTCP		47
 
-/*
- * AHCI SATA
- */
-#define MX6Q_SATA_BASE_ADDR            0x02200000
-#endif	/* __MACH_MX6Q_H__ */
+#if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
+extern int mx6q_revision(void);
+extern int mx6dl_revision(void);
+extern int mx6sl_revision(void);
+#endif
+
+#endif				/*  __ASM_ARCH_MXC_MX6_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index ab56a9a..77fc76e2 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -37,6 +37,7 @@
 #define MXC_CPU_MX53		53
 #define MXC_CPU_MX6Q		63
 #define MXC_CPU_MX6DL		61
+#define MXC_CPU_MX6SL		60
 
 #define IMX_CHIP_REVISION_1_0		0x10
 #define IMX_CHIP_REVISION_1_1		0x11
@@ -52,6 +53,24 @@
 #define IMX_CHIP_REVISION_3_3		0x33
 #define IMX_CHIP_REVISION_UNKNOWN	0xff
 
+#define IMX_CHIP_REVISION_1_0_STRING		"1.0"
+#define IMX_CHIP_REVISION_1_1_STRING		"1.1"
+#define IMX_CHIP_REVISION_1_2_STRING		"1.2"
+#define IMX_CHIP_REVISION_1_3_STRING		"1.3"
+#define IMX_CHIP_REVISION_2_0_STRING		"2.0"
+#define IMX_CHIP_REVISION_2_1_STRING		"2.1"
+#define IMX_CHIP_REVISION_2_2_STRING		"2.2"
+#define IMX_CHIP_REVISION_2_3_STRING		"2.3"
+#define IMX_CHIP_REVISION_3_0_STRING		"3.0"
+#define IMX_CHIP_REVISION_3_1_STRING		"3.1"
+#define IMX_CHIP_REVISION_3_2_STRING		"3.2"
+#define IMX_CHIP_REVISION_3_3_STRING		"3.3"
+#define IMX_CHIP_REVISION_UNKNOWN_STRING	"unknown"
+#define IMX_BOARD_REV_1		0x000
+#define IMX_BOARD_REV_2		0x100
+#define IMX_BOARD_REV_3		0x200
+#define IMX_BOARD_REV_4		0x300
+
 #ifndef __ASSEMBLY__
 extern unsigned int __mxc_cpu_type;
 extern unsigned int system_rev;
@@ -59,8 +78,14 @@ extern unsigned int system_rev;
 #define imx_cpu_ver()		(system_rev & 0xFF)
 
 #ifdef CONFIG_SOC_IMX6Q
+#define board_is_mx6q_arm2() (cpu_is_mx6q() && \
+	board_is_rev(IMX_BOARD_REV_1))
 #define board_is_mx6q_sabre_lite() (cpu_is_mx6q() && \
 	board_is_rev(IMX_BOARD_REV_2))
+#define board_is_mx6q_sabre_auto() (cpu_is_mx6q() && \
+	board_is_rev(IMX_BOARD_REV_3))
+#define board_is_mx6sl_evk() (cpu_is_mx6sl() && \
+	board_is_rev(IMX_BOARD_REV_3))
 
 #define board_is_mx6_unknown() \
 	board_is_rev(IMX_BOARD_REV_1)
@@ -186,28 +211,27 @@ extern unsigned int system_rev;
 # define mxc_cpu_type __mxc_cpu_type
 # define cpu_is_mx6q()		(mxc_cpu_type == MXC_CPU_MX6Q)
 # define cpu_is_mx6dl()		(mxc_cpu_type == MXC_CPU_MX6DL)
+# define cpu_is_mx6sl()		(mxc_cpu_type == MXC_CPU_MX6SL)
 #else
 # define cpu_is_mx6q()		(0)
 # define cpu_is_mx6dl()		(0)
+# define cpu_is_mx6sl()		(0)
 #endif
 
 #ifndef __ASSEMBLY__
 
-#ifdef CONFIG_SOC_IMX6Q
-extern int mx6q_revision(void);
-#else
-#define mx6q_revision(void)    (0)
-#endif
-
 struct cpu_op {
 	u32 pll_reg;
 	u32 pll_rate;
+	u32 pll_lpm_rate;
 	u32 cpu_rate;
 	u32 pdr0_reg;
 	u32 pdf;
 	u32 mfi;
 	u32 mfd;
 	u32 mfn;
+	u32 pu_voltage;
+	u32 soc_voltage;
 	u32 cpu_voltage;
 	u32 cpu_podf;
 };
@@ -215,10 +239,37 @@ struct cpu_op {
 int tzic_enable_wake(void);
 
 extern struct cpu_op *(*get_cpu_op)(int *op);
+
+/* available disableable devices in fuse */
+enum mxc_dev_type {
+	MXC_DEV_PXP,
+	MXC_DEV_OVG,
+	MXC_DEV_DSI_CSI2,
+	MXC_DEV_ENET,
+	MXC_DEV_MLB,
+	MXC_DEV_EPDC,
+	MXC_DEV_HDMI,
+	MXC_DEV_PCIE,
+	MXC_DEV_SATA,
+	MXC_DEV_DTCP,
+	MXC_DEV_2D,
+	MXC_DEV_3D,
+	MXC_DEV_VPU,
+	MXC_DEV_DIVX3,
+	MXC_DEV_RV,
+	MXC_DEV_SORENSEN,
+};
+extern int fuse_dev_is_available(enum mxc_dev_type dev);
+
 #endif
 
+#define cpu_is_mx5()    (cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx50())
 #define cpu_is_mx3()	(cpu_is_mx31() || cpu_is_mx35())
 #define cpu_is_mx2()	(cpu_is_mx21() || cpu_is_mx27())
-#define cpu_is_mx6()	(cpu_is_mx6q() || cpu_is_mx6dl())
+#define cpu_is_mx6()	(cpu_is_mx6q() || cpu_is_mx6dl() || cpu_is_mx6sl())
 
+#define MXC_PGCR_PCR		1
+#define MXC_SRPGCR_PCR		1
+#define MXC_EMPGCR_PCR		1
+#define MXC_PGSR_PSR		1
 #endif /*  __ASM_ARCH_MXC_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc91231.h b/arch/arm/plat-mxc/include/mach/mxc91231.h
new file mode 100755
index 0000000..765190f
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc91231.h
@@ -0,0 +1,256 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *    - Platform specific register memory map
+ *
+ *  Copyright 2005-2007 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MACH_MXC91231_H__
+#define __MACH_MXC91231_H__
+
+/*
+ * L2CC
+ */
+#define MXC91231_L2CC_BASE_ADDR		0x30000000
+#define MXC91231_L2CC_SIZE		SZ_64K
+
+/*
+ * AIPS 1
+ */
+#define MXC91231_AIPS1_BASE_ADDR	0x43F00000
+#define MXC91231_AIPS1_SIZE		SZ_1M
+
+#define MXC91231_AIPS1_CTRL_BASE_ADDR	MXC91231_AIPS1_BASE_ADDR
+#define MXC91231_MAX_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x04000)
+#define MXC91231_EVTMON_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x08000)
+#define MXC91231_CLKCTL_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x0C000)
+#define MXC91231_ETB_SLOT4_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x10000)
+#define MXC91231_ETB_SLOT5_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x14000)
+#define MXC91231_ECT_CTIO_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x18000)
+#define MXC91231_I2C_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x80000)
+#define MXC91231_MU_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x88000)
+#define MXC91231_UART1_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x90000)
+#define MXC91231_UART2_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x94000)
+#define MXC91231_DSM_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x98000)
+#define MXC91231_OWIRE_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x9C000)
+#define MXC91231_SSI1_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0xA0000)
+#define MXC91231_KPP_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0xA8000)
+#define MXC91231_IOMUX_AP_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0xAC000)
+#define MXC91231_CTI_AP_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0xB8000)
+
+/*
+ * AIPS 2
+ */
+#define MXC91231_AIPS2_BASE_ADDR	0x53F00000
+#define MXC91231_AIPS2_SIZE		SZ_1M
+
+#define MXC91231_GEMK_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0x8C000)
+#define MXC91231_GPT1_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0x90000)
+#define MXC91231_EPIT1_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0x94000)
+#define MXC91231_SCC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xAC000)
+#define MXC91231_RNGA_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xB0000)
+#define MXC91231_IPU_CTRL_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xC0000)
+#define MXC91231_AUDMUX_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xC4000)
+#define MXC91231_EDIO_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xC8000)
+#define MXC91231_GPIO1_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xCC000)
+#define MXC91231_GPIO2_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xD0000)
+#define MXC91231_SDMA_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xD4000)
+#define MXC91231_RTC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xD8000)
+#define MXC91231_WDOG1_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xDC000)
+#define MXC91231_PWM_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xE0000)
+#define MXC91231_GPIO3_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xE4000)
+#define MXC91231_WDOG2_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xE8000)
+#define MXC91231_RTIC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xEC000)
+#define MXC91231_LPMC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xF0000)
+
+/*
+ * SPBA global module 0
+ */
+#define MXC91231_SPBA0_BASE_ADDR	0x50000000
+#define MXC91231_SPBA0_SIZE		SZ_1M
+
+#define MXC91231_MMC_SDHC1_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x04000)
+#define MXC91231_MMC_SDHC2_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x08000)
+#define MXC91231_UART3_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x0C000)
+#define MXC91231_CSPI2_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x10000)
+#define MXC91231_SSI2_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x14000)
+#define MXC91231_SIM_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x18000)
+#define MXC91231_IIM_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x1C000)
+#define MXC91231_CTI_SDMA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x20000)
+#define MXC91231_USBOTG_CTRL_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x24000)
+#define MXC91231_USBOTG_DATA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x28000)
+#define MXC91231_CSPI1_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x30000)
+#define MXC91231_SPBA_CTRL_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x3C000)
+#define MXC91231_IOMUX_COM_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x40000)
+#define MXC91231_CRM_COM_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x44000)
+#define MXC91231_CRM_AP_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x48000)
+#define MXC91231_PLL0_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x4C000)
+#define MXC91231_PLL1_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x50000)
+#define MXC91231_PLL2_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x54000)
+#define MXC91231_GPIO4_SH_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x58000)
+#define MXC91231_HAC_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x5C000)
+#define MXC91231_SAHARA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x5C000)
+#define MXC91231_PLL3_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x60000)
+
+/*
+ * SPBA global module 1
+ */
+#define MXC91231_SPBA1_BASE_ADDR	0x52000000
+#define MXC91231_SPBA1_SIZE		SZ_1M
+
+#define MXC91231_MQSPI_BASE_ADDR	(MXC91231_SPBA1_BASE_ADDR + 0x34000)
+#define MXC91231_EL1T_BASE_ADDR		(MXC91231_SPBA1_BASE_ADDR + 0x38000)
+
+/*!
+ * Defines for SPBA modules
+ */
+#define MXC91231_SPBA_SDHC1		0x04
+#define MXC91231_SPBA_SDHC2		0x08
+#define MXC91231_SPBA_UART3		0x0C
+#define MXC91231_SPBA_CSPI2		0x10
+#define MXC91231_SPBA_SSI2		0x14
+#define MXC91231_SPBA_SIM		0x18
+#define MXC91231_SPBA_IIM		0x1C
+#define MXC91231_SPBA_CTI_SDMA		0x20
+#define MXC91231_SPBA_USBOTG_CTRL_REGS	0x24
+#define MXC91231_SPBA_USBOTG_DATA_REGS	0x28
+#define MXC91231_SPBA_CSPI1		0x30
+#define MXC91231_SPBA_MQSPI		0x34
+#define MXC91231_SPBA_EL1T		0x38
+#define MXC91231_SPBA_IOMUX		0x40
+#define MXC91231_SPBA_CRM_COM		0x44
+#define MXC91231_SPBA_CRM_AP		0x48
+#define MXC91231_SPBA_PLL0		0x4C
+#define MXC91231_SPBA_PLL1		0x50
+#define MXC91231_SPBA_PLL2		0x54
+#define MXC91231_SPBA_GPIO4		0x58
+#define MXC91231_SPBA_SAHARA		0x5C
+
+/*
+ * ROMP and AVIC
+ */
+#define MXC91231_ROMP_BASE_ADDR		0x60000000
+#define MXC91231_ROMP_SIZE		SZ_64K
+
+#define MXC91231_AVIC_BASE_ADDR		0x68000000
+#define MXC91231_AVIC_SIZE		SZ_64K
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define MXC91231_X_MEMC_BASE_ADDR	0xB8000000
+#define MXC91231_X_MEMC_SIZE		SZ_64K
+
+#define MXC91231_NFC_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x0000)
+#define MXC91231_ESDCTL_BASE_ADDR	(MXC91231_X_MEMC_BASE_ADDR + 0x1000)
+#define MXC91231_WEIM_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x2000)
+#define MXC91231_M3IF_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x3000)
+#define MXC91231_EMI_CTL_BASE_ADDR	(MXC91231_X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * Memory regions and CS
+ * CPLD is connected on CS4
+ * CS5 is TP1021 or it is not connected
+ * */
+#define MXC91231_FB_RAM_BASE_ADDR	0x78000000
+#define MXC91231_FB_RAM_SIZE		SZ_256K
+#define MXC91231_CSD0_BASE_ADDR		0x80000000
+#define MXC91231_CSD1_BASE_ADDR		0x90000000
+#define MXC91231_CS0_BASE_ADDR		0xA0000000
+#define MXC91231_CS1_BASE_ADDR		0xA8000000
+#define MXC91231_CS2_BASE_ADDR		0xB0000000
+#define MXC91231_CS3_BASE_ADDR		0xB2000000
+#define MXC91231_CS4_BASE_ADDR		0xB4000000
+#define MXC91231_CS5_BASE_ADDR		0xB6000000
+
+/*
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address.
+ */
+#define MXC91231_IO_P2V(x)		IMX_IO_P2V(x)
+#define MXC91231_IO_ADDRESS(x)		IOMEM(MXC91231_IO_P2V(x))
+
+/*
+ * Interrupt numbers
+ */
+#define MXC91231_INT_GPIO3		0
+#define MXC91231_INT_EL1T_CI		1
+#define MXC91231_INT_EL1T_RFCI		2
+#define MXC91231_INT_EL1T_RFI		3
+#define MXC91231_INT_EL1T_MCU		4
+#define MXC91231_INT_EL1T_IPI		5
+#define MXC91231_INT_MU_GEN		6
+#define MXC91231_INT_GPIO4		7
+#define MXC91231_INT_MMC_SDHC2		8
+#define MXC91231_INT_MMC_SDHC1		9
+#define MXC91231_INT_I2C		10
+#define MXC91231_INT_SSI2		11
+#define MXC91231_INT_SSI1		12
+#define MXC91231_INT_CSPI2		13
+#define MXC91231_INT_CSPI1		14
+#define MXC91231_INT_RTIC		15
+#define MXC91231_INT_SAHARA		15
+#define MXC91231_INT_HAC		15
+#define MXC91231_INT_UART3_RX		16
+#define MXC91231_INT_UART3_TX		17
+#define MXC91231_INT_UART3_MINT		18
+#define MXC91231_INT_ECT		19
+#define MXC91231_INT_SIM_IPB		20
+#define MXC91231_INT_SIM_DATA		21
+#define MXC91231_INT_RNGA		22
+#define MXC91231_INT_DSM_AP		23
+#define MXC91231_INT_KPP		24
+#define MXC91231_INT_RTC		25
+#define MXC91231_INT_PWM		26
+#define MXC91231_INT_GEMK_AP		27
+#define MXC91231_INT_EPIT		28
+#define MXC91231_INT_GPT		29
+#define MXC91231_INT_UART2_RX		30
+#define MXC91231_INT_UART2_TX		31
+#define MXC91231_INT_UART2_MINT		32
+#define MXC91231_INT_NANDFC		33
+#define MXC91231_INT_SDMA		34
+#define MXC91231_INT_USB_WAKEUP		35
+#define MXC91231_INT_USB_SOF		36
+#define MXC91231_INT_PMU_EVTMON		37
+#define MXC91231_INT_USB_FUNC		38
+#define MXC91231_INT_USB_DMA		39
+#define MXC91231_INT_USB_CTRL		40
+#define MXC91231_INT_IPU_ERR		41
+#define MXC91231_INT_IPU_SYN		42
+#define MXC91231_INT_UART1_RX		43
+#define MXC91231_INT_UART1_TX		44
+#define MXC91231_INT_UART1_MINT		45
+#define MXC91231_INT_IIM		46
+#define MXC91231_INT_MU_RX_OR		47
+#define MXC91231_INT_MU_TX_OR		48
+#define MXC91231_INT_SCC_SCM		49
+#define MXC91231_INT_SCC_SMN		50
+#define MXC91231_INT_GPIO2		51
+#define MXC91231_INT_GPIO1		52
+#define MXC91231_INT_MQSPI1		53
+#define MXC91231_INT_MQSPI2		54
+#define MXC91231_INT_WDOG2		55
+#define MXC91231_INT_EXT_INT7		56
+#define MXC91231_INT_EXT_INT6		57
+#define MXC91231_INT_EXT_INT5		58
+#define MXC91231_INT_EXT_INT4		59
+#define MXC91231_INT_EXT_INT3		60
+#define MXC91231_INT_EXT_INT2		61
+#define MXC91231_INT_EXT_INT1		62
+#define MXC91231_INT_EXT_INT0		63
+
+#define MXC91231_MAX_INT_LINES		63
+#define MXC91231_MAX_EXT_LINES		8
+
+#endif /* __MACH_MXC91231_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
index fd00395..8943156 100755
--- a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
@@ -136,6 +136,10 @@ struct dvfs_op {
 struct mxc_dvfs_platform_data {
 	/** Supply voltage regulator name string */
 	char *reg_id;
+	/*vdd_soc regulator name string*/
+	char *soc_id;
+	/*vdd_pu regulator name string*/
+	char *pu_id;
 	/* CPU clock name string */
 	char *clk1_id;
 	/* DVFS clock name string */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_edid.h b/arch/arm/plat-mxc/include/mach/mxc_edid.h
index 10baa01..38bad6b 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_edid.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_edid.h
@@ -51,6 +51,13 @@ enum cea_audio_coding_types {
 	AUDIO_CODING_TYPE_RESERVED		= 15,
 };
 
+struct mxc_hdmi_3d_format {
+	unsigned char vic_order_2d;
+	unsigned char struct_3d;
+	unsigned char detail_3d;
+	unsigned char reserved;
+};
+
 struct mxc_edid_cfg {
 	bool cea_underscan;
 	bool cea_basicaudio;
@@ -59,20 +66,40 @@ struct mxc_edid_cfg {
 	bool hdmi_cap;
 
 	/*VSD*/
+	bool vsd_support_ai;
 	bool vsd_dc_48bit;
 	bool vsd_dc_36bit;
 	bool vsd_dc_30bit;
 	bool vsd_dc_y444;
 	bool vsd_dvi_dual;
 
+	bool vsd_cnc0;
+	bool vsd_cnc1;
+	bool vsd_cnc2;
+	bool vsd_cnc3;
+
+	u8 vsd_video_latency;
+	u8 vsd_audio_latency;
+	u8 vsd_I_video_latency;
+	u8 vsd_I_audio_latency;
+
+	u8 physical_address[4];
+	u8 hdmi_vic[64];
+	struct mxc_hdmi_3d_format hdmi_3d_format[64];
+	u16 hdmi_3d_mask_all;
+	u16 hdmi_3d_struct_all;
+	u32 vsd_max_tmdsclk_rate;
+
 	u8 max_channels;
 	u8 sample_sizes;
 	u8 sample_rates;
+	u8 speaker_alloc;
 };
 
 int mxc_edid_var_to_vic(struct fb_var_screeninfo *var);
 int mxc_edid_mode_to_vic(const struct fb_videomode *mode);
 int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
 	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi);
-
+int mxc_edid_parse_ext_blk(unsigned char *edid, struct mxc_edid_cfg *cfg,
+	struct fb_monspecs *specs);
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_gpu.h b/arch/arm/plat-mxc/include/mach/mxc_gpu.h
new file mode 100644
index 0000000..a43d6ec
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_gpu.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __MACH_MXC_GPU_H_
+#define __MACH_MXC_GPU_H_
+
+struct mxc_gpu_platform_data {
+	int z160_revision;
+	resource_size_t reserved_mem_base;
+	resource_size_t reserved_mem_size;
+};
+
+#endif /* __MACH_MXC_GPU_H_ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
index 6001ca8..60946ca 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -538,7 +538,7 @@
 
 /* I2C Master Registers (E-DDC) */
 #define HDMI_I2CM_SLAVE                         0x7E00
-#define HDMI_I2CMESS                            0x7E01
+#define HDMI_I2CM_ADDRESS                       0x7E01
 #define HDMI_I2CM_DATAO                         0x7E02
 #define HDMI_I2CM_DATAI                         0x7E03
 #define HDMI_I2CM_OPERATION                     0x7E04
@@ -583,6 +583,16 @@ enum {
 	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
 	HDMI_IH_PHY_STAT0_HPD = 0x1,
 
+/* IH_CEC_STAT0 field values */
+	HDMI_IH_CEC_STAT0_WAKEUP = 0x40,
+	HDMI_IH_CEC_STAT0_ERROR_FOLL = 0x20,
+	HDMI_IH_CEC_STAT0_ERROR_INIT = 0x10,
+	HDMI_IH_CEC_STAT0_ARB_LOST = 0x8,
+	HDMI_IH_CEC_STAT0_NACK = 0x4,
+	HDMI_IH_CEC_STAT0_EOM = 0x2,
+	HDMI_IH_CEC_STAT0_DONE = 0x1,
+
+
 /* IH_MUTE_I2CMPHY_STAT0 field values */
 	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
 	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
@@ -1056,6 +1066,23 @@ enum {
 	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
 	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
 	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
+
+
+/* I2CM_OPERATION field values */
+	HDMI_I2CM_OPERATION_WRITE = 0x10,
+	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
+	HDMI_I2CM_OPERATION_READ = 0x1,
+
+/* HDMI_I2CM_INT */
+	HDMI_I2CM_INT_DONE_POL = 0x08,
+	HDMI_I2CM_INT_DONE_MASK = 0x04,
+
+/* HDMI_I2CM_CTLINT */
+	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
+	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
+	HDMI_I2CM_CTLINT_ARBITRATION_POL = 0x08,
+	HDMI_I2CM_CTLINT_ARBITRATION_MASK = 0x04,
+
 };
 
 #endif /* __MXC_HDMI_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_uart.h b/arch/arm/plat-mxc/include/mach/mxc_uart.h
index 29ed95d..689aaad 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_uart.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_uart.h
@@ -262,7 +262,6 @@ typedef struct {
 /* Bit definations of UTS */
 #define MXC_UARTUTS_LOOP        0x1000
 
-extern int mxc_early_serial_console_init(unsigned long base, struct clk *clk);
 #endif				/* __KERNEL__ */
 
 #endif				/* __ASM_ARCH_MXC_UART_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_vpu.h b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
index da4f39d..7a6e24f 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_vpu.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
@@ -57,6 +57,7 @@ struct vpu_mem_desc {
 #define VPU_IOC_GET_SHARE_MEM   _IO(VPU_IOC_MAGIC, 12)
 #define VPU_IOC_QUERY_BITWORK_MEM  _IO(VPU_IOC_MAGIC, 13)
 #define VPU_IOC_SET_BITWORK_MEM    _IO(VPU_IOC_MAGIC, 14)
+#define VPU_IOC_PHYMEM_CHECK	_IO(VPU_IOC_MAGIC, 15)
 
 #define BIT_CODE_RUN			0x000
 #define BIT_CODE_DOWN			0x004
@@ -66,6 +67,7 @@ struct vpu_mem_desc {
 #define BIT_INT_REASON			0x174
 
 #define MJPEG_PIC_STATUS_REG		0x3004
+#define MBC_SET_SUBBLK_EN		0x4A0
 
 #define BIT_WORK_CTRL_BUF_BASE		0x100
 #define BIT_WORK_CTRL_BUF_REG(i)	(BIT_WORK_CTRL_BUF_BASE + i * 4)
@@ -76,7 +78,11 @@ struct vpu_mem_desc {
 #define BIT_FRAME_MEM_CTRL		BIT_WORK_CTRL_BUF_REG(4)
 #define BIT_BIT_STREAM_PARAM		BIT_WORK_CTRL_BUF_REG(5)
 
+#ifndef CONFIG_ARCH_MX6
 #define BIT_RESET_CTRL			0x11C
+#else
+#define BIT_RESET_CTRL			0x128
+#endif
 
 /* i could be 0, 1, 2, 3 */
 #define	BIT_RD_PTR_BASE			0x120
diff --git a/arch/arm/plat-mxc/include/mach/mxs.h b/arch/arm/plat-mxc/include/mach/mxs.h
new file mode 100644
index 0000000..3d67fed
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxs.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __MACH_MXS_H__
+#define __MACH_MXS_H__
+
+#ifndef __ASSEMBLER__
+#include <linux/io.h>
+#endif
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+
+/*
+ * MXS CPU types
+ */
+#define cpu_is_mx23()		(					\
+		machine_is_mx23evk() ||					\
+		0)
+#define cpu_is_mx28()		(					\
+		machine_is_mx28evk() ||					\
+		machine_is_tx28() ||					\
+		0)
+
+#if 0
+/*
+ * IO addresses common to MXS-based
+ */
+#define MXS_IO_BASE_ADDR		0x80000000
+#define MXS_IO_SIZE			SZ_1M
+
+#define MXS_ICOLL_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x000000)
+#define MXS_APBH_DMA_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x004000)
+#define MXS_BCH_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x00a000)
+#define MXS_GPMI_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x00c000)
+#define MXS_PINCTRL_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x018000)
+#define MXS_DIGCTL_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x01c000)
+#define MXS_APBX_DMA_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x024000)
+#define MXS_DCP_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x028000)
+#define MXS_PXP_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x02a000)
+#define MXS_OCOTP_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x02c000)
+#define MXS_AXI_AHB0_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x02e000)
+#define MXS_LCDIF_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x030000)
+#define MXS_CLKCTRL_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x040000)
+#define MXS_SAIF0_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x042000)
+#define MXS_POWER_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x044000)
+#define MXS_SAIF1_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x046000)
+#define MXS_LRADC_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x050000)
+#define MXS_SPDIF_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x054000)
+#define MXS_I2C0_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x058000)
+#define MXS_PWM_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x064000)
+#define MXS_TIMROT_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x068000)
+#define MXS_AUART1_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x06c000)
+#define MXS_AUART2_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x06e000)
+#define MXS_DRAM_BASE_ADDR		(MXS_IO_BASE_ADDR + 0x0e0000)
+#endif
+
+/*
+ * It maps the whole address space to [0xf4000000, 0xf50fffff].
+ *
+ *	OCRAM	0x00000000+0x020000	->	0xf4000000+0x020000
+ *	IO	0x80000000+0x100000	->	0xf5000000+0x100000
+ */
+#define MXS_IO_P2V(x)	(0xf4000000 +					\
+			(((x) & 0x80000000) >> 7) +			\
+			(((x) & 0x000fffff)))
+
+#define MXS_IO_ADDRESS(x)	IOMEM(MXS_IO_P2V(x))
+
+#define mxs_map_entry(soc, name, _type)	{				\
+	.virtual = soc ## _IO_P2V(soc ## _ ## name ## _BASE_ADDR),	\
+	.pfn = __phys_to_pfn(soc ## _ ## name ## _BASE_ADDR),		\
+	.length = soc ## _ ## name ## _SIZE,				\
+	.type = _type,							\
+}
+
+#define MXS_SET_ADDR		0x4
+#define MXS_CLR_ADDR		0x8
+#define MXS_TOG_ADDR		0xc
+
+#ifndef __ASSEMBLER__
+static inline void __mxs_setl(u32 mask, void __iomem *reg)
+{
+	__raw_writel(mask, reg + MXS_SET_ADDR);
+}
+
+static inline void __mxs_clrl(u32 mask, void __iomem *reg)
+{
+	__raw_writel(mask, reg + MXS_CLR_ADDR);
+}
+
+static inline void __mxs_togl(u32 mask, void __iomem *reg)
+{
+	__raw_writel(mask, reg + MXS_TOG_ADDR);
+}
+#endif
+
+#endif /* __MACH_MXS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/sdma.h b/arch/arm/plat-mxc/include/mach/sdma.h
index 19cfa9a..cee7fe4 100644
--- a/arch/arm/plat-mxc/include/mach/sdma.h
+++ b/arch/arm/plat-mxc/include/mach/sdma.h
@@ -45,16 +45,21 @@ struct sdma_script_start_addrs {
 	s32 ram_code_start_addr;
 	s32 mcu_2_ssish_addr;
 	s32 ssish_2_mcu_addr;
+	s32 hdmi_dma_addr;
 };
 
 /**
  * struct sdma_platform_data - platform specific data for SDMA engine
  *
- * @fw_name		The firmware name
+ * @sdma_version	The version of this SDMA engine
+ * @cpu_name		used to generate the firmware name
+ * @to_version		CPU Tape out version
  * @script_addrs	SDMA scripts addresses in SDMA ROM
  */
 struct sdma_platform_data {
-	char *fw_name;
+	int sdma_version;
+	char *cpu_name;
+	int to_version;
 	struct sdma_script_start_addrs *script_addrs;
 };
 
diff --git a/arch/arm/plat-mxc/include/mach/sdram_autogating.h b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
new file mode 100755
index 0000000..e102add
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DVFS Dynamic Voltage and Frequency Scaling (DVFS) Driver
+ */
+
+/*!
+ * @file arch-mxc/sdram_autogating.h
+ *
+ * @brief This file contains the SDRAM autogating function prototypes
+ *
+ *
+ * @ingroup PM
+ */
+
+#ifndef __ASM_ARCH_SDRAM_AUTOGATING_H__
+#define __ASM_ARCH_SDRAM_AUTOGATING_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+
+#ifdef CONFIG_ARCH_MX5
+extern void start_sdram_autogating(void);
+extern void stop_sdram_autogating(void);
+extern int sdram_autogating_active(void);
+#else
+static inline void start_sdram_autogating(void)
+{}
+
+static inline void stop_sdram_autogating(void)
+{}
+
+static inline int sdram_autogating_active(void)
+{
+	return 0;
+}
+#endif
+
+#endif				/*__KERNEL__ */
+#endif				/* __ASM_ARCH_MXC_DVFS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
new file mode 100644
index 0000000..649a97c
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_MXC_SYSTEM_H__
+#define __ASM_ARCH_MXC_SYSTEM_H__
+
+#include <mach/hardware.h>
+#include <mach/common.h>
+
+#define LDO_MODE_DEFAULT	0
+#define LDO_MODE_BYPASSED	1
+#define LDO_MODE_ENABLED	2
+extern void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
+
+void arch_idle(void);
+
+void arch_reset(char mode, const char *cmd);
+
+#ifdef CONFIG_MXC_REBOOT_MFGMODE
+void do_switch_mfgmode(void);
+void mxc_clear_mfgmode(void);
+#else
+#define do_switch_mfgmode() do {} while (0)
+#define mxc_clear_mfgmode() do {} while (0)
+#endif
+
+#ifdef CONFIG_MXC_REBOOT_ANDROID_CMD
+void do_switch_recovery(void);
+void do_switch_fastboot(void);
+#else
+#define do_switch_recovery() do {} while (0)
+#define do_switch_fastboot() do {} while (0)
+#endif
+
+#endif /* __ASM_ARCH_MXC_SYSTEM_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/timex.h b/arch/arm/plat-mxc/include/mach/timex.h
index 10343d1..695063b 100644
--- a/arch/arm/plat-mxc/include/mach/timex.h
+++ b/arch/arm/plat-mxc/include/mach/timex.h
@@ -1,6 +1,6 @@
 /*
- *  Copyright (C) 1999 ARM Limited
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -16,7 +16,18 @@
 #ifndef __ASM_ARCH_MXC_TIMEX_H__
 #define __ASM_ARCH_MXC_TIMEX_H__
 
-/* Bogus value */
-#define CLOCK_TICK_RATE	12345678
+#if defined CONFIG_ARCH_MX1
+#define CLOCK_TICK_RATE		16000000
+#elif defined CONFIG_ARCH_MX2
+#define CLOCK_TICK_RATE		13300000
+#elif defined CONFIG_ARCH_MX3
+#define CLOCK_TICK_RATE		16625000
+#elif defined CONFIG_ARCH_MX25
+#define CLOCK_TICK_RATE		16000000
+#elif defined CONFIG_ARCH_MX5
+#define CLOCK_TICK_RATE		8000000
+#elif defined CONFIG_ARCH_MX6
+#define CLOCK_TICK_RATE		8000000
+#endif
 
 #endif				/* __ASM_ARCH_MXC_TIMEX_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/uncompress.h b/arch/arm/plat-mxc/include/mach/uncompress.h
index 7e67b02..92e777e 100644
--- a/arch/arm/plat-mxc/include/mach/uncompress.h
+++ b/arch/arm/plat-mxc/include/mach/uncompress.h
@@ -101,7 +101,6 @@ static __inline__ void __arch_decomp_setup(unsigned long arch_id)
 	case MACH_TYPE_PCM043:
 	case MACH_TYPE_LILLY1131:
 	case MACH_TYPE_VPR200:
-	case MACH_TYPE_EUKREA_CPUIMX35SD:
 		uart_base = MX3X_UART1_BASE_ADDR;
 		break;
 	case MACH_TYPE_MAGX_ZN5:
@@ -121,12 +120,20 @@ static __inline__ void __arch_decomp_setup(unsigned long arch_id)
 	case MACH_TYPE_MX53_EVK:
 	case MACH_TYPE_MX53_LOCO:
 	case MACH_TYPE_MX53_SMD:
-	case MACH_TYPE_MX53_ARD:
 		uart_base = MX53_UART1_BASE_ADDR;
 		break;
+	case MACH_TYPE_MX6Q_ARM2:
+		uart_base = MX6Q_UART4_BASE_ADDR;
+		break;
 	case MACH_TYPE_MX6Q_SABRELITE:
 		uart_base = MX6Q_UART2_BASE_ADDR;
 		break;
+	case MACH_TYPE_MX6Q_SABRESD:
+		uart_base = MX6Q_UART1_BASE_ADDR;
+		break;
+	case MACH_TYPE_MX6Q_SABREAUTO:
+		uart_base = MX6Q_UART4_BASE_ADDR;
+		break;
 	default:
 		break;
 	}
diff --git a/arch/arm/plat-mxc/include/mach/vmalloc.h b/arch/arm/plat-mxc/include/mach/vmalloc.h
new file mode 100644
index 0000000..44ea15a
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/vmalloc.h
@@ -0,0 +1,22 @@
+/*
+ *  Copyright (C) 2000 Russell King.
+ *  Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_MXC_VMALLOC_H__
+#define __ASM_ARCH_MXC_VMALLOC_H__
+
+/* vmalloc ending address */
+#define VMALLOC_END       0xf2000000UL
+
+#endif /* __ASM_ARCH_MXC_VMALLOC_H__ */
diff --git a/arch/arm/plat-mxc/iomux-v1.c b/arch/arm/plat-mxc/iomux-v1.c
index 1f73963..3238c10 100644
--- a/arch/arm/plat-mxc/iomux-v1.c
+++ b/arch/arm/plat-mxc/iomux-v1.c
@@ -157,7 +157,7 @@ EXPORT_SYMBOL(mxc_gpio_mode);
 static int imx_iomuxv1_setup_multiple(const int *list, unsigned count)
 {
 	size_t i;
-	int ret = 0;
+	int ret;
 
 	for (i = 0; i < count; ++i) {
 		ret = mxc_gpio_mode(list[i]);
@@ -172,13 +172,45 @@ static int imx_iomuxv1_setup_multiple(const int *list, unsigned count)
 int mxc_gpio_setup_multiple_pins(const int *pin_list, unsigned count,
 		const char *label)
 {
+	size_t i;
 	int ret;
 
+	for (i = 0; i < count; ++i) {
+		unsigned gpio = pin_list[i] & (GPIO_PIN_MASK | GPIO_PORT_MASK);
+
+		ret = gpio_request(gpio, label);
+		if (ret)
+			goto err_gpio_request;
+	}
+
 	ret = imx_iomuxv1_setup_multiple(pin_list, count);
+	if (ret)
+		goto err_setup;
+
+	return 0;
+
+err_setup:
+	BUG_ON(i != count);
+
+err_gpio_request:
+	mxc_gpio_release_multiple_pins(pin_list, i);
+
 	return ret;
 }
 EXPORT_SYMBOL(mxc_gpio_setup_multiple_pins);
 
+void mxc_gpio_release_multiple_pins(const int *pin_list, int count)
+{
+	size_t i;
+
+	for (i = 0; i < count; ++i) {
+		unsigned gpio = pin_list[i] & (GPIO_PIN_MASK | GPIO_PORT_MASK);
+
+		gpio_free(gpio);
+	}
+}
+EXPORT_SYMBOL(mxc_gpio_release_multiple_pins);
+
 int __init imx_iomuxv1_init(void __iomem *base, int numports)
 {
 	imx_iomuxv1_baseaddr = base;
diff --git a/arch/arm/plat-mxc/iomux-v3.c b/arch/arm/plat-mxc/iomux-v3.c
index 9ce15ce..c3fc761 100644
--- a/arch/arm/plat-mxc/iomux-v3.c
+++ b/arch/arm/plat-mxc/iomux-v3.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2012 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
  * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH,
  *                       <armlinux@phytec.de>
@@ -71,6 +71,36 @@ void mxc_iomux_set_gpr_register(int group, int start_bit, int num_bits, int valu
 }
 EXPORT_SYMBOL(mxc_iomux_set_gpr_register);
 
+/*
+ * Read a single pad in the iomuxer
+ */
+int mxc_iomux_v3_get_pad(iomux_v3_cfg_t *pad)
+{
+	u32 mux_ctrl_ofs = (*pad & MUX_CTRL_OFS_MASK) >> MUX_CTRL_OFS_SHIFT;
+	u32 pad_ctrl_ofs = (*pad & MUX_PAD_CTRL_OFS_MASK)
+						>> MUX_PAD_CTRL_OFS_SHIFT;
+	u32 sel_input_ofs = (*pad & MUX_SEL_INPUT_OFS_MASK)
+						>> MUX_SEL_INPUT_OFS_SHIFT;
+	u32 mux_mode = 0;
+	u32 sel_input = 0;
+	u32 pad_ctrl = 0;
+	iomux_v3_cfg_t pad_info = 0;
+
+	mux_mode = __raw_readl(base + mux_ctrl_ofs) & 0xFF;
+	pad_ctrl = __raw_readl(base + pad_ctrl_ofs) & 0x1FFFF;
+	sel_input = __raw_readl(base + sel_input_ofs) & 0x7;
+
+	pad_info = (((iomux_v3_cfg_t)mux_mode << MUX_MODE_SHIFT) | \
+		((iomux_v3_cfg_t)pad_ctrl << MUX_PAD_CTRL_SHIFT) | \
+		((iomux_v3_cfg_t)sel_input << MUX_SEL_INPUT_SHIFT));
+
+	*pad &= ~(MUX_MODE_MASK | MUX_PAD_CTRL_MASK | MUX_SEL_INPUT_MASK);
+	*pad |= pad_info;
+
+	return 0;
+}
+
+
 int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
 {
 	iomux_v3_cfg_t *p = pad_list;
@@ -87,6 +117,32 @@ int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
 }
 EXPORT_SYMBOL(mxc_iomux_v3_setup_multiple_pads);
 
+/*
+ * Read multiple pads in the iomuxer
+ */
+int mxc_iomux_v3_get_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
+{
+	iomux_v3_cfg_t *p = pad_list;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		mxc_iomux_v3_get_pad(p);
+		p++;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(mxc_iomux_v3_get_multiple_pads);
+
+void mxc_iomux_set_specialbits_register(u32 pad_addr, u32 value, u32 mask)
+{
+	u32 reg;
+	reg = __raw_readl(base + pad_addr);
+	reg &= ~mask;
+	reg |= value;
+	__raw_writel(reg, base + pad_addr);
+}
+EXPORT_SYMBOL(mxc_iomux_set_specialbits_register);
+
 void mxc_iomux_v3_init(void __iomem *iomux_v3_base)
 {
 	base = iomux_v3_base;
diff --git a/arch/arm/plat-mxc/irq-common.c b/arch/arm/plat-mxc/irq-common.c
index b6e1145..e1c6eff 100644
--- a/arch/arm/plat-mxc/irq-common.c
+++ b/arch/arm/plat-mxc/irq-common.c
@@ -23,17 +23,17 @@
 
 int imx_irq_set_priority(unsigned char irq, unsigned char prio)
 {
-	struct irq_chip_generic *gc;
-	struct mxc_extra_irq *exirq;
+	struct mxc_irq_chip *chip;
+	struct irq_chip *base;
 	int ret;
 
 	ret = -ENOSYS;
 
-	gc = irq_get_chip_data(irq);
-	if (gc && gc->private) {
-		exirq = gc->private;
-		if (exirq->set_priority)
-			ret = exirq->set_priority(irq, prio);
+	base = irq_get_chip(irq);
+	if (base) {
+		chip = container_of(base, struct mxc_irq_chip, base);
+		if (chip->set_priority)
+			ret = chip->set_priority(irq, prio);
 	}
 
 	return ret;
@@ -42,17 +42,17 @@ EXPORT_SYMBOL(imx_irq_set_priority);
 
 int mxc_set_irq_fiq(unsigned int irq, unsigned int type)
 {
-	struct irq_chip_generic *gc;
-	struct mxc_extra_irq *exirq;
+	struct mxc_irq_chip *chip;
+	struct irq_chip *base;
 	int ret;
 
 	ret = -ENOSYS;
 
-	gc = irq_get_chip_data(irq);
-	if (gc && gc->private) {
-		exirq = gc->private;
-		if (exirq->set_irq_fiq)
-			ret = exirq->set_irq_fiq(irq, type);
+	base = irq_get_chip(irq);
+	if (base) {
+		chip = container_of(base, struct mxc_irq_chip, base);
+		if (chip->set_irq_fiq)
+			ret = chip->set_irq_fiq(irq, type);
 	}
 
 	return ret;
diff --git a/arch/arm/plat-mxc/irq-common.h b/arch/arm/plat-mxc/irq-common.h
index 6ccb3a1..7203543 100644
--- a/arch/arm/plat-mxc/irq-common.h
+++ b/arch/arm/plat-mxc/irq-common.h
@@ -19,8 +19,9 @@
 #ifndef __PLAT_MXC_IRQ_COMMON_H__
 #define __PLAT_MXC_IRQ_COMMON_H__
 
-struct mxc_extra_irq
+struct mxc_irq_chip
 {
+	struct irq_chip	base;
 	int (*set_priority)(unsigned char irq, unsigned char prio);
 	int (*set_irq_fiq)(unsigned int irq, unsigned int type);
 };
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
index f6689ff..c7f83f5 100644
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -6,6 +6,7 @@
  * published by the Free Software Foundation.
  *
  * Derived from pxa PWM driver by eric miao <eric.miao@marvell.com>
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -16,6 +17,8 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/pwm.h>
+#include <linux/fsl_devices.h>
+#include <linux/export.h>
 #include <mach/hardware.h>
 
 
@@ -40,7 +43,12 @@
 #define MX3_PWMCR_SWR             (1 << 3)
 #define MX3_PWMCR_EN              (1 << 0)
 
-
+#define MX3_PWMCR_STOPEN		(1 << 25)
+#define MX3_PWMCR_DOZEEN                (1 << 24)
+#define MX3_PWMCR_WAITEN                (1 << 23)
+#define MX3_PWMCR_DBGEN			(1 << 22)
+#define MX3_PWMCR_CLKSRC_IPG		(1 << 16)
+#define MX3_PWMCR_CLKSRC_IPG_32k	(3 << 16)
 
 struct pwm_device {
 	struct list_head	node;
@@ -54,6 +62,9 @@ struct pwm_device {
 
 	unsigned int	use_count;
 	unsigned int	pwm_id;
+	int		pwmo_invert;
+	void (*enable_pwm_pad)(void);
+	void (*disable_pwm_pad)(void);
 };
 
 int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
@@ -66,6 +77,9 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		unsigned long period_cycles, duty_cycles, prescale;
 		u32 cr;
 
+		if (pwm->pwmo_invert)
+			duty_ns = period_ns - duty_ns;
+
 		c = clk_get_rate(pwm->clk);
 		c = c * period_ns;
 		do_div(c, 1000000000);
@@ -74,11 +88,7 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		prescale = period_cycles / 0x10000 + 1;
 
 		period_cycles /= prescale;
-		/* the chip document says the counter counts up to
-		 * period_cycles + 1 and then is reset to 0, so the
-		 *  actual period of the PWM wave is period_cycles + 2
-		 */
-		c = (unsigned long long)(period_cycles + 2) * duty_ns;
+		c = (unsigned long long)period_cycles * duty_ns;
 		do_div(c, period_ns);
 		duty_cycles = c;
 
@@ -95,8 +105,8 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		writel(period_cycles, pwm->mmio_base + MX3_PWMPR);
 
 		cr = MX3_PWMCR_PRESCALER(prescale) |
-			MX3_PWMCR_DOZEEN | MX3_PWMCR_WAITEN |
-			MX3_PWMCR_DBGEN | MX3_PWMCR_EN;
+			MX3_PWMCR_STOPEN | MX3_PWMCR_DOZEEN |
+			MX3_PWMCR_WAITEN | MX3_PWMCR_DBGEN;
 
 		if (cpu_is_mx25())
 			cr |= MX3_PWMCR_CLKSRC_IPG;
@@ -122,7 +132,10 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		 * (/2 .. /16).
 		 */
 		u32 max = readl(pwm->mmio_base + MX1_PWMP);
-		u32 p = max * duty_ns / period_ns;
+		u32 p;
+		if (pwm->pwmo_invert)
+			duty_ns = period_ns - duty_ns;
+		p = max * duty_ns / period_ns;
 		writel(max - p, pwm->mmio_base + MX1_PWMS);
 	} else {
 		BUG();
@@ -134,25 +147,37 @@ EXPORT_SYMBOL(pwm_config);
 
 int pwm_enable(struct pwm_device *pwm)
 {
+	unsigned long reg;
 	int rc = 0;
 
 	if (!pwm->clk_enabled) {
-		rc = clk_prepare_enable(pwm->clk);
+		rc = clk_enable(pwm->clk);
 		if (!rc)
 			pwm->clk_enabled = 1;
 	}
+
+	reg = readl(pwm->mmio_base + MX3_PWMCR);
+	reg |= MX3_PWMCR_EN;
+	writel(reg, pwm->mmio_base + MX3_PWMCR);
+
+	if (pwm->enable_pwm_pad)
+		pwm->enable_pwm_pad();
+
 	return rc;
 }
 EXPORT_SYMBOL(pwm_enable);
 
 void pwm_disable(struct pwm_device *pwm)
 {
+	if (pwm->disable_pwm_pad)
+		pwm->disable_pwm_pad();
+
 	writel(MX3_PWMCR_SWR, pwm->mmio_base + MX3_PWMCR);
 	while (readl(pwm->mmio_base + MX3_PWMCR) & MX3_PWMCR_SWR)
 		;
 
 	if (pwm->clk_enabled) {
-		clk_disable_unprepare(pwm->clk);
+		clk_disable(pwm->clk);
 		pwm->clk_enabled = 0;
 	}
 }
@@ -207,6 +232,7 @@ static int __devinit mxc_pwm_probe(struct platform_device *pdev)
 {
 	struct pwm_device *pwm;
 	struct resource *r;
+	struct mxc_pwm_platform_data *plat_data = pdev->dev.platform_data;
 	int ret = 0;
 
 	pwm = kzalloc(sizeof(struct pwm_device), GFP_KERNEL);
@@ -227,6 +253,11 @@ static int __devinit mxc_pwm_probe(struct platform_device *pdev)
 	pwm->use_count = 0;
 	pwm->pwm_id = pdev->id;
 	pwm->pdev = pdev;
+	if (plat_data != NULL) {
+		pwm->pwmo_invert = plat_data->pwmo_invert;
+		pwm->enable_pwm_pad = plat_data->enable_pwm_pad;
+		pwm->disable_pwm_pad = plat_data->disable_pwm_pad;
+	}
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (r == NULL) {
@@ -235,14 +266,14 @@ static int __devinit mxc_pwm_probe(struct platform_device *pdev)
 		goto err_free_clk;
 	}
 
-	r = request_mem_region(r->start, resource_size(r), pdev->name);
+	r = request_mem_region(r->start, r->end - r->start + 1, pdev->name);
 	if (r == NULL) {
 		dev_err(&pdev->dev, "failed to request memory resource\n");
 		ret = -EBUSY;
 		goto err_free_clk;
 	}
 
-	pwm->mmio_base = ioremap(r->start, resource_size(r));
+	pwm->mmio_base = ioremap(r->start, r->end - r->start + 1);
 	if (pwm->mmio_base == NULL) {
 		dev_err(&pdev->dev, "failed to ioremap() registers\n");
 		ret = -ENODEV;
@@ -257,7 +288,7 @@ static int __devinit mxc_pwm_probe(struct platform_device *pdev)
 	return 0;
 
 err_free_mem:
-	release_mem_region(r->start, resource_size(r));
+	release_mem_region(r->start, r->end - r->start + 1);
 err_free_clk:
 	clk_put(pwm->clk);
 err_free:
@@ -281,7 +312,7 @@ static int __devexit mxc_pwm_remove(struct platform_device *pdev)
 	iounmap(pwm->mmio_base);
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(r->start, resource_size(r));
+	release_mem_region(r->start, r->end - r->start + 1);
 
 	clk_put(pwm->clk);
 
diff --git a/arch/arm/plat-mxc/serialxc.c b/arch/arm/plat-mxc/serialxc.c
new file mode 100755
index 0000000..a3eeef9
--- /dev/null
+++ b/arch/arm/plat-mxc/serialxc.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+
+static void usb_serial_init(struct fsl_xcvr_ops *this)
+{
+}
+
+static void usb_serial_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+static struct fsl_xcvr_ops serial_ops = {
+	.name = "serial",
+	.xcvr_type = PORTSC_PTS_SERIAL,
+	.init = usb_serial_init,
+	.uninit = usb_serial_uninit,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init serialxc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&serial_ops);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit serialxc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&serial_ops);
+}
+
+subsys_initcall(serialxc_init);
+module_exit(serialxc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("serial xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/system.c b/arch/arm/plat-mxc/system.c
index 362d39a..b643113c 100644
--- a/arch/arm/plat-mxc/system.c
+++ b/arch/arm/plat-mxc/system.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1999 ARM Limited
  * Copyright (C) 2000 Deep Blue Solutions Ltd
- * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2012 Freescale Semiconductor, Inc.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  * Copyright 2009 Ilya Yanok, Emcraft Systems Ltd, yanok@emcraft.com
  *
@@ -21,18 +21,33 @@
 #include <linux/io.h>
 #include <linux/err.h>
 #include <linux/delay.h>
-#include <linux/module.h>
-
+#include <linux/string.h>
 #include <mach/hardware.h>
 #include <mach/common.h>
-#include <asm/system_misc.h>
+#include <mach/system.h>
 #include <asm/proc-fns.h>
+#include <asm/system.h>
+#ifdef CONFIG_SMP
+#include <linux/smp.h>
+#endif
 #include <asm/mach-types.h>
 
-void __iomem *(*imx_ioremap)(unsigned long, size_t, unsigned int) = NULL;
-EXPORT_SYMBOL_GPL(imx_ioremap);
-
 static void __iomem *wdog_base;
+extern u32 enable_ldo_mode;
+
+
+static void arch_reset_special_mode(char mode, const char *cmd)
+{
+	if (!cmd)
+		return;
+
+	if (strcmp(cmd, "download") == 0)
+		do_switch_mfgmode();
+	else if (strcmp(cmd, "recovery") == 0)
+		do_switch_recovery();
+	else if (strcmp(cmd, "fastboot") == 0)
+		do_switch_fastboot();
+}
 
 /*
  * Reset the system. It is called by machine_restart().
@@ -41,10 +56,18 @@ void mxc_restart(char mode, const char *cmd)
 {
 	unsigned int wcr_enable;
 
+	arch_reset_special_mode(mode, cmd);
+
 #ifdef CONFIG_ARCH_MX6
 	/* wait for reset to assert... */
-	wcr_enable = (1 << 2);
-
+	if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*On Sabresd board use WDOG2 to reset external PMIC, so here do
+		* more WDOG2 reset.*/
+		wcr_enable = 0x14;
+		__raw_writew(wcr_enable, IO_ADDRESS(MX6Q_WDOG2_BASE_ADDR));
+		__raw_writew(wcr_enable, IO_ADDRESS(MX6Q_WDOG2_BASE_ADDR));
+	} else
+		wcr_enable = (1 << 2);
 	__raw_writew(wcr_enable, wdog_base);
 	/* errata TKT039676, SRS bit may be missed when
 	SRC sample it, need to write the wdog controller
@@ -59,6 +82,13 @@ void mxc_restart(char mode, const char *cmd)
 	return;
 #endif
 
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+	if (machine_is_mx51_efikamx()) {
+		mx51_efikamx_reset();
+		return;
+	}
+#endif
+
 	if (cpu_is_mx1()) {
 		wcr_enable = (1 << 0);
 	} else {
@@ -66,7 +96,7 @@ void mxc_restart(char mode, const char *cmd)
 
 		clk = clk_get_sys("imx2-wdt.0", NULL);
 		if (!IS_ERR(clk))
-			clk_prepare_enable(clk);
+			clk_enable(clk);
 		wcr_enable = (1 << 2);
 	}
 
diff --git a/arch/arm/plat-mxc/time.c b/arch/arm/plat-mxc/time.c
index 3a1b22a..ec7666e 100644
--- a/arch/arm/plat-mxc/time.c
+++ b/arch/arm/plat-mxc/time.c
@@ -58,9 +58,9 @@
 #define V2_TCTL_WAITEN		(1 << 3) /* Wait enable mode */
 #define V2_TCTL_CLK_IPG		(1 << 6)
 #define V2_TCTL_CLK_PER		(2 << 6)
-#define V2_TCTL_CLK_OSC_DIV8	(5 << 6)
+#define V2_TCTL_CLK_OSC_DIV8	 (5 << 6)
 #define V2_TCTL_CLK_OSC		(7 << 6)
-#define V2_TCTL_FRR		(1 << 9)
+#define V2_TCTL_FRR			(1 << 9)
 #define V2_TCTL_ENABLE24M	(1 << 10)
 #define V2_TPRER_PRE24M_DIV8	7
 #define V2_TPRER_PRE24M_MASK	0xF
@@ -156,8 +156,7 @@ static int v2_set_next_event(unsigned long evt,
 
 	__raw_writel(tcmp, timer_base + V2_TCMP);
 
-	return (int)(tcmp - __raw_readl(timer_base + V2_TCN)) < 0 ?
-				-ETIME : 0;
+	return 0;
 }
 
 #ifdef DEBUG
@@ -265,34 +264,6 @@ static struct clock_event_device clockevent_mxc = {
 	.rating		= 200,
 };
 
-#ifdef CONFIG_ARCH_MX6
-unsigned long mx6_timer_rate()
-{
-	struct clk *osc_clk = clk_get(NULL, "osc");
-	u32 parent_rate = clk_get_rate(osc_clk);
-
-	u32 reg = __raw_readl(timer_base + MXC_TCTL);
-	u32 div;
-
-	clk_put(osc_clk);
-
-	if ((reg & V2_TCTL_CLK_OSC_DIV8) == V2_TCTL_CLK_OSC_DIV8) {
-		if (cpu_is_mx6q())
-			/* For MX6Q, only options are 24MHz or 24MHz/8*/
-			return parent_rate / 8;
-		else {
-			/* For MX6DLS and MX6Solo, the rate is based on the
-			  * divider value set in prescalar register. */
-			div = __raw_readl(timer_base + MXC_TPRER);
-			div = (div >> V2_TPRER_PRE24M_OFFSET) &
-					V2_TPRER_PRE24M_MASK;
-			return parent_rate / (div + 1);
-		}
-	}
-	return 0;
-}
-#endif
-
 static int __init mxc_clockevent_init(struct clk *timer_clk)
 {
 	unsigned int c = clk_get_rate(timer_clk);
@@ -331,12 +302,22 @@ void __init mxc_timer_init(struct clk *timer_clk, void __iomem *base, int irq)
 	__raw_writel(0, timer_base + MXC_TPRER); /* see datasheet note */
 
 	if (timer_is_v2()) {
-		if (mx6q_revision() == IMX_CHIP_REVISION_1_0)
+		if (cpu_is_mx5() || cpu_is_mx6sl() ||
+			mx6q_revision() == IMX_CHIP_REVISION_1_0)
 			tctl_val = V2_TCTL_CLK_PER | V2_TCTL_FRR |
 						V2_TCTL_WAITEN | MXC_TCTL_TEN;
-		else
+		else {
 			tctl_val = V2_TCTL_CLK_OSC_DIV8 | V2_TCTL_FRR |
 						V2_TCTL_WAITEN | MXC_TCTL_TEN;
+			if (!cpu_is_mx6q()) {
+				reg = __raw_readl(timer_base + MXC_TPRER);
+				reg |= (V2_TPRER_PRE24M_DIV8 <<
+							V2_TPRER_PRE24M_OFFSET);
+				__raw_writel(reg, timer_base + MXC_TPRER);
+				/* Enable the 24MHz input clock. */
+				tctl_val |= V2_TCTL_ENABLE24M;
+			}
+		}
 	} else
 		tctl_val = MX1_2_TCTL_FRR | MX1_2_TCTL_CLK_PCLK1 | MXC_TCTL_TEN;
 
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index 04d0cdf..f5db4b6 100644
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -49,12 +49,53 @@
 #include <mach/arc_otg.h>
 #include <mach/hardware.h>
 #include <mach/mxc.h>
+typedef void (*driver_vbus_func)(bool);
 
 void __iomem *imx_otg_base;
+static  driver_vbus_func s_h1_driver_vbus;
+static  driver_vbus_func s_otg_driver_vbus;
+
+EXPORT_SYMBOL(imx_otg_base);
 
 #define MXC_NUMBER_USB_TRANSCEIVER 6
 struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
 
+bool usb_icbug_swfix_need(void)
+{
+	if (cpu_is_mx6sl())
+		return false;
+	else if ((mx6q_revision() > IMX_CHIP_REVISION_1_1))
+		return false;
+	else if ((mx6dl_revision() > IMX_CHIP_REVISION_1_0))
+		return false;
+	return true;
+}
+EXPORT_SYMBOL(usb_icbug_swfix_need);
+
+void mx6_set_host1_vbus_func(driver_vbus_func driver_vbus)
+{
+	s_h1_driver_vbus = driver_vbus;
+}
+
+void mx6_get_host1_vbus_func(driver_vbus_func *driver_vbus)
+{
+	*driver_vbus = s_h1_driver_vbus;
+}
+EXPORT_SYMBOL(mx6_get_host1_vbus_func);
+
+void mx6_set_otghost_vbus_func(driver_vbus_func driver_vbus)
+{
+	s_otg_driver_vbus = driver_vbus;
+}
+
+void mx6_get_otghost_vbus_func(driver_vbus_func *driver_vbus)
+{
+	*driver_vbus = s_otg_driver_vbus;
+}
+EXPORT_SYMBOL(mx6_get_otghost_vbus_func);
+
+
+
 enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata)
 {
 	enum fsl_usb2_modes mode;
@@ -88,7 +129,7 @@ static int fsl_check_usbclk(void)
 
 	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
 	if (clk_enable(usb_ahb_clk)) {
-		if (cpu_is_mx6q() || cpu_is_mx6dl())
+		if (cpu_is_mx6())
 			return 0; /* there is no ahb clock at mx6 */
 		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
 		return -EINVAL;
@@ -97,7 +138,7 @@ static int fsl_check_usbclk(void)
 
 	usb_clk = clk_get(NULL, "usb_clk");
 	if (clk_enable(usb_clk)) {
-		if (cpu_is_mx6q() || cpu_is_mx6dl())
+		if (cpu_is_mx6())
 			return 0; /* there is usb_clk at mx6 */
 		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
 		return -EINVAL;
@@ -141,7 +182,7 @@ void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
 
 	pr_debug("%s\n", __func__);
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (g_xc_ops[i] == xcvr_ops) {
+		if (g_xc_ops[i] && (g_xc_ops[i] == xcvr_ops)) {
 			g_xc_ops[i] = NULL;
 			return;
 		}
@@ -162,7 +203,7 @@ static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
 	}
 
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+		if (g_xc_ops[i] && (strcmp(g_xc_ops[i]->name, name) == 0)) {
 			return g_xc_ops[i];
 		}
 	}
@@ -502,7 +543,7 @@ int fsl_usb_host_init(struct platform_device *pdev)
 
 	if (usb_register_remote_wakeup(pdev))
 		pr_debug("%s port is not a wakeup source.\n", pdata->name);
-	if (!(cpu_is_mx6q() || cpu_is_mx6dl())) {
+	if (!(cpu_is_mx6())) {
 		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
 			if (cpu_is_mx35()) {
 				usbh2_set_serial_xcvr();
@@ -815,7 +856,7 @@ int usbotg_init(struct platform_device *pdev)
 			return -EINVAL;
 		if (xops->init)
 			xops->init(xops);
-		if (!((cpu_is_mx6q() || cpu_is_mx6dl()))) {
+		if (!(cpu_is_mx6())) {
 			UOG_PORTSC1 = UOG_PORTSC1 & ~PORTSC_PHCD;
 
 
diff --git a/arch/arm/plat-mxc/usb_hsic_xcvr.c b/arch/arm/plat-mxc/usb_hsic_xcvr.c
index fd2dfc3..9dbbdc4 100644
--- a/arch/arm/plat-mxc/usb_hsic_xcvr.c
+++ b/arch/arm/plat-mxc/usb_hsic_xcvr.c
@@ -21,6 +21,7 @@
 #include <linux/err.h>
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
+#include <linux/pmic_external.h>
 #include <linux/usb/fsl_xcvr.h>
 
 #include <mach/hardware.h>
diff --git a/arch/arm/plat-mxc/usb_wakeup.c b/arch/arm/plat-mxc/usb_wakeup.c
index 3c84a25..00af25f 100644
--- a/arch/arm/plat-mxc/usb_wakeup.c
+++ b/arch/arm/plat-mxc/usb_wakeup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,11 +32,11 @@
 struct wakeup_ctrl {
 	int wakeup_irq;
 	int usb_irq;
+	bool thread_close;
 	struct fsl_usb2_wakeup_platform_data *pdata;
 	struct task_struct *thread;
 	struct completion  event;
 };
-static struct wakeup_ctrl *g_ctrl;
 
 extern int usb_event_is_otg_wakeup(struct fsl_usb2_platform_data *pdata);
 extern void usb_debounce_id_vbus(void);
@@ -46,6 +46,20 @@ static void wakeup_clk_gate(struct fsl_usb2_wakeup_platform_data *pdata, bool on
 	if (pdata->usb_clock_for_pm)
 		pdata->usb_clock_for_pm(on);
 }
+static bool phy_in_lowpower_mode(struct fsl_usb2_platform_data *pdata)
+{
+	unsigned long flags;
+	bool ret = true;
+
+	spin_lock_irqsave(&pdata->lock, flags);
+
+	if (!pdata->lowpower)
+		ret = false;
+
+	spin_unlock_irqrestore(&pdata->lock, flags);
+
+	return ret;
+}
 
 static bool usb2_is_in_lowpower(struct wakeup_ctrl *ctrl)
 {
@@ -53,8 +67,8 @@ static bool usb2_is_in_lowpower(struct wakeup_ctrl *ctrl)
 	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
 	/* all the usb module related the wakeup is in lowpower mode */
 	for (i = 0; i < 3; i++) {
-		if (pdata->usb_pdata[i]) {
-			if (pdata->usb_pdata[i]->phy_lowpower_suspend && !pdata->usb_pdata[i]->lowpower)
+		if (pdata->usb_pdata[i] && pdata->usb_pdata[i]->phy_lowpower_suspend) {
+			if (!phy_in_lowpower_mode(pdata->usb_pdata[i]))
 				return false;
 		}
 	}
@@ -145,12 +159,18 @@ static int wakeup_event_thread(void *param)
 {
 	struct wakeup_ctrl *ctrl = (struct wakeup_ctrl *)param;
 	struct sched_param sch_param = {.sched_priority = 1};
+	u32 timeout = 0;
 
 	sched_setscheduler(current, SCHED_RR, &sch_param);
 	while (1) {
 		wait_for_completion_interruptible(&ctrl->event);
-		if (kthread_should_stop())
+		if (ctrl->thread_close) {
+			while (!kthread_should_stop() && (timeout < 1000)) {
+				timeout++;
+				msleep(1);
+			}
 			break;
+		}
 		wakeup_event_handler(ctrl);
 		enable_irq(ctrl->wakeup_irq);
 		if ((ctrl->usb_irq > 0) && (ctrl->wakeup_irq != ctrl->usb_irq))
@@ -184,6 +204,7 @@ static int wakeup_dev_probe(struct platform_device *pdev)
 	 */
 	ctrl->wakeup_irq = platform_get_irq(pdev, 1);
 	ctrl->usb_irq = platform_get_irq(pdev, 1);
+	ctrl->thread_close = false;
 	if (ctrl->wakeup_irq != ctrl->usb_irq)
 		interrupt_flag = IRQF_DISABLED;
 	else
@@ -196,7 +217,7 @@ static int wakeup_dev_probe(struct platform_device *pdev)
 	status = IS_ERR(ctrl->thread) ? -1 : 0;
 	if (status)
 		goto error2;
-	g_ctrl = ctrl;
+	platform_set_drvdata(pdev, ctrl);
 
 	printk(KERN_DEBUG "the wakeup pdata is 0x%p\n", pdata);
 	return 0;
@@ -209,12 +230,14 @@ error1:
 
 static int  wakeup_dev_exit(struct platform_device *pdev)
 {
-	if (g_ctrl->thread) {
-		complete(&g_ctrl->event);
-		kthread_stop(g_ctrl->thread);
-	}
-	free_irq(g_ctrl->wakeup_irq, (void *)g_ctrl);
-	kfree(g_ctrl);
+	struct wakeup_ctrl *wctrl = platform_get_drvdata(pdev);
+
+	wctrl->thread_close = true;
+	complete(&wctrl->event);
+	kthread_stop(wctrl->thread);
+	free_irq(wctrl->wakeup_irq, (void *)wctrl);
+	kfree(wctrl);
+
 	return 0;
 }
 static struct platform_driver wakeup_d = {
@@ -236,3 +259,4 @@ static void __exit wakeup_dev_uninit(void)
 
 subsys_initcall(wakeup_dev_init);
 module_exit(wakeup_dev_uninit);
+
diff --git a/include/linux/fec.h b/include/linux/fec.h
index bcff455..ecfc95a 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -17,8 +17,13 @@
 #include <linux/phy.h>
 
 struct fec_platform_data {
+	int (*init) (struct phy_device *);
+	int (*power_hibernate) (struct phy_device *);
 	phy_interface_t phy;
 	unsigned char mac[ETH_ALEN];
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	unsigned int gpio_irq;
+#endif
 };
 
 #endif
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index ee89785..9c5e699 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -18,6 +18,7 @@
 #define _FSL_DEVICE_H_
 
 #include <linux/types.h>
+#include <linux/cdev.h>
 
 struct mxc_otp_platform_data {
 	char    **fuse_name;
@@ -34,11 +35,25 @@ struct fsl_mxc_camera_platform_data {
 	char *analog_regulator;
 	char *gpo_regulator;
 	u32 mclk;
+	u8 mclk_source;
 	u32 csi;
 	void (*pwdn)(int pwdn);
 	void (*io_init)(void);
 };
 
+struct fsl_mxc_tvin_platform_data {
+	char *dvddio_reg;
+	char *dvdd_reg;
+	char *avdd_reg;
+	char *pvdd_reg;
+	void (*pwdn)(int pwdn);
+	void (*reset)(void);
+	void (*io_init)(void);
+	bool cvbs;
+	/* adv7280 mipi-csi i2c slave addr */
+	u8 csi_tx_addr;
+};
+
 /*
  * Some conventions on how we handle peripherals on Freescale chips
  *
@@ -166,6 +181,8 @@ struct fsl_usb2_platform_data {
 	u32		pmflags;	/* PM from otg or system */
 	spinlock_t lock;
 
+	void __iomem *charger_base_addr; /* used for i.mx6 usb charger detect */
+
 	/* register save area for suspend/resume */
 	u32		pm_command;
 	u32		pm_status;
@@ -201,6 +218,17 @@ struct fsl_usb2_wakeup_platform_data {
 
 #define FLS_USB2_WORKAROUND_ENGCM09152	(1 << 0)
 
+struct mxc_mlb_platform_data {
+	struct device *dev;
+	u32 buf_addr;
+	u32 phy_addr;
+	char *reg_nvcc;
+	char *mlb_clk;
+	char *mlb_pll_clk;
+	void (*fps_sel)(int mlbfs);
+	struct cdev cdev;
+};
+
 struct spi_device;
 
 struct fsl_spi_platform_data {
@@ -218,6 +246,16 @@ struct fsl_spi_platform_data {
 	u32	sysclk;
 };
 
+struct fsl_mxc_tve_platform_data {
+	char *dac_reg;
+	char *dig_reg;
+};
+
+struct fsl_mxc_lightsensor_platform_data {
+	char *vdd_reg;
+	int rext;
+};
+
 struct fsl_mxc_ldb_platform_data {
 	char *lvds_bg_reg;
 	u32 ext_ref;
@@ -238,6 +276,13 @@ struct fsl_mxc_ldb_platform_data {
 	int sec_disp_id;
 };
 
+struct mxc_fb_platform_data {
+	struct fb_videomode *mode;
+	int num_modes;
+	char *mode_str;
+	u32 interface_pix_fmt;
+};
+
 struct fsl_mxc_lcd_platform_data {
 	char *io_reg;
 	char *core_reg;
@@ -266,6 +311,9 @@ struct fsl_mxc_hdmi_platform_data {
 	void (*put_pins) (void);
 	void (*enable_pins) (void);
 	void (*disable_pins) (void);
+	/* HDMI PHY register config for pass HCT */
+	u16 phy_reg_vlev;
+	u16 phy_reg_cksymtx;
 };
 
 struct fsl_mxc_hdmi_core_platform_data {
@@ -273,6 +321,13 @@ struct fsl_mxc_hdmi_core_platform_data {
 	int disp_id;
 };
 
+struct fsl_mxc_capture_platform_data {
+	int csi;
+	int ipu;
+	u8 mclk_source;
+	u8 is_mipi;
+};
+
 /*
  * This struct is to define the number of SSIs on a platform,
  * DAM source port config, DAM external port config,
@@ -309,6 +364,12 @@ struct mxc_audio_codec_platform_data {
 	int rates; /* codec platform data */
 };
 
+struct mxc_pwm_platform_data {
+	int pwmo_invert;
+	void (*enable_pwm_pad) (void);
+	void (*disable_pwm_pad) (void);
+};
+
 struct mxc_spdif_platform_data {
 	int spdif_tx;		/* S/PDIF tx enabled for this board */
 	int spdif_rx;		/* S/PDIF rx enabled for this board */
@@ -342,4 +403,17 @@ int fsl_deep_sleep(void);
 static inline int fsl_deep_sleep(void) { return 0; }
 #endif
 
+struct mxs_perfmon_bit_config {
+	int reg;
+	int field;
+	const char *name;
+};
+
+struct mxs_platform_perfmon_data {
+	struct mxs_perfmon_bit_config *bit_config_tab;
+	int bit_config_cnt;
+	void (*plt_init) (void);
+	void (*plt_exit) (void);
+};
+
 #endif /* _FSL_DEVICE_H_ */
diff --git a/include/linux/mfd/max17135.h b/include/linux/mfd/max17135.h
new file mode 100644
index 0000000..5785ed4
--- /dev/null
+++ b/include/linux/mfd/max17135.h
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __LINUX_REGULATOR_MAX17135_H_
+#define __LINUX_REGULATOR_MAX17135_H_
+
+/*
+ * PMIC Register Addresses
+ */
+enum {
+    REG_MAX17135_EXT_TEMP = 0x0,
+    REG_MAX17135_CONFIG,
+    REG_MAX17135_INT_TEMP = 0x4,
+    REG_MAX17135_STATUS,
+    REG_MAX17135_PRODUCT_REV,
+    REG_MAX17135_PRODUCT_ID,
+    REG_MAX17135_DVR,
+    REG_MAX17135_ENABLE,
+    REG_MAX17135_FAULT,  /*0x0A*/
+    REG_MAX17135_HVINP,
+    REG_MAX17135_PRGM_CTRL,
+    REG_MAX17135_TIMING1 = 0x10,    /* Timing regs base address is 0x10 */
+    REG_MAX17135_TIMING2,
+    REG_MAX17135_TIMING3,
+    REG_MAX17135_TIMING4,
+    REG_MAX17135_TIMING5,
+    REG_MAX17135_TIMING6,
+    REG_MAX17135_TIMING7,
+    REG_MAX17135_TIMING8,
+};
+#define MAX17135_REG_NUM        21
+#define MAX17135_MAX_REGISTER   0xFF
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Shift and width values for each register bitfield
+ */
+#define EXT_TEMP_LSH    7
+#define EXT_TEMP_WID    9
+
+#define THERMAL_SHUTDOWN_LSH    0
+#define THERMAL_SHUTDOWN_WID    1
+
+#define INT_TEMP_LSH    7
+#define INT_TEMP_WID    9
+
+#define STAT_BUSY_LSH   0
+#define STAT_BUSY_WID   1
+#define STAT_OPEN_LSH   1
+#define STAT_OPEN_WID   1
+#define STAT_SHRT_LSH   2
+#define STAT_SHRT_WID   1
+
+#define PROD_REV_LSH    0
+#define PROD_REV_WID    8
+
+#define PROD_ID_LSH     0
+#define PROD_ID_WID     8
+
+#define DVR_LSH         0
+#define DVR_WID         8
+
+#define ENABLE_LSH      0
+#define ENABLE_WID      1
+#define VCOM_ENABLE_LSH 1
+#define VCOM_ENABLE_WID 1
+
+#define FAULT_FBPG_LSH      0
+#define FAULT_FBPG_WID      1
+#define FAULT_HVINP_LSH     1
+#define FAULT_HVINP_WID     1
+#define FAULT_HVINN_LSH     2
+#define FAULT_HVINN_WID     1
+#define FAULT_FBNG_LSH      3
+#define FAULT_FBNG_WID      1
+#define FAULT_HVINPSC_LSH   4
+#define FAULT_HVINPSC_WID   1
+#define FAULT_HVINNSC_LSH   5
+#define FAULT_HVINNSC_WID   1
+#define FAULT_OT_LSH        6
+#define FAULT_OT_WID        1
+#define FAULT_POK_LSH       7
+#define FAULT_POK_WID       1
+
+#define HVINP_LSH           0
+#define HVINP_WID           4
+
+#define CTRL_DVR_LSH        0
+#define CTRL_DVR_WID        1
+#define CTRL_TIMING_LSH     1
+#define CTRL_TIMING_WID     1
+
+#define TIMING1_LSH         0
+#define TIMING1_WID         8
+#define TIMING2_LSH         0
+#define TIMING2_WID         8
+#define TIMING3_LSH         0
+#define TIMING3_WID         8
+#define TIMING4_LSH         0
+#define TIMING4_WID         8
+#define TIMING5_LSH         0
+#define TIMING5_WID         8
+#define TIMING6_LSH         0
+#define TIMING6_WID         8
+#define TIMING7_LSH         0
+#define TIMING7_WID         8
+#define TIMING8_LSH         0
+#define TIMING8_WID         8
+
+struct max17135 {
+	/* chip revision */
+	int rev;
+
+	struct device *dev;
+
+	/* Platform connection */
+	struct i2c_client *i2c_client;
+
+	/* Client devices */
+	struct platform_device *pdev[MAX17135_REG_NUM];
+
+	/* Timings */
+	unsigned int gvee_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vpos_pwrup;
+	unsigned int gvdd_pwrup;
+	unsigned int gvdd_pwrdn;
+	unsigned int vpos_pwrdn;
+	unsigned int vneg_pwrdn;
+	unsigned int gvee_pwrdn;
+
+	/* GPIOs */
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_v3p3;
+	int gpio_pmic_intr;
+
+	/* MAX17135 part variables */
+	int pass_num;
+	int vcom_uV;
+
+	/* One-time VCOM setup marker */
+	bool vcom_setup;
+	bool init_done;
+
+	/* powerup/powerdown wait time */
+	int max_wait;
+};
+
+enum {
+    /* In alphabetical order */
+    MAX17135_DISPLAY, /* virtual master enable */
+    MAX17135_GVDD,
+    MAX17135_GVEE,
+    MAX17135_HVINN,
+    MAX17135_HVINP,
+    MAX17135_VCOM,
+    MAX17135_VNEG,
+    MAX17135_VPOS,
+    MAX17135_V3P3,
+    MAX17135_NUM_REGULATORS,
+};
+
+/*
+ * Declarations
+ */
+struct regulator_init_data;
+
+struct max17135_platform_data {
+	unsigned int gvee_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vpos_pwrup;
+	unsigned int gvdd_pwrup;
+	unsigned int gvdd_pwrdn;
+	unsigned int vpos_pwrdn;
+	unsigned int vneg_pwrdn;
+	unsigned int gvee_pwrdn;
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_v3p3;
+	int gpio_pmic_intr;
+	int pass_num;
+	int vcom_uV;
+	struct regulator_init_data *regulator_init;
+	int (*init)(struct max17135 *);
+};
+
+int max17135_register_regulator(struct max17135 *max17135, int reg,
+				     struct regulator_init_data *initdata);
+
+int max17135_reg_read(int reg_num, unsigned int *reg_val);
+int max17135_reg_write(int reg_num, const unsigned int reg_val);
+
+#endif
diff --git a/include/linux/mfd/mxc-hdmi-core.h b/include/linux/mfd/mxc-hdmi-core.h
index cf87502..f69ddb2 100644
--- a/include/linux/mfd/mxc-hdmi-core.h
+++ b/include/linux/mfd/mxc-hdmi-core.h
@@ -54,6 +54,7 @@ extern int mxc_hdmi_disp_id;
 
 void hdmi_set_registered(int registered);
 int hdmi_get_registered(void);
+unsigned int hdmi_SDMA_check(void);
 int mxc_hdmi_abort_stream(void);
 int mxc_hdmi_register_audio(struct snd_pcm_substream *substream);
 void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream);
diff --git a/include/linux/mfd/pfuze.h b/include/linux/mfd/pfuze.h
new file mode 100644
index 0000000..92e34af
--- /dev/null
+++ b/include/linux/mfd/pfuze.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __LINUX_MFD_PFUZE_H
+#define __LINUX_MFD_PFUZE_H
+
+#include <linux/interrupt.h>
+
+struct mc_pfuze;
+void pfuze_lock(struct mc_pfuze *mc_pfuze);
+void pfuze_unlock(struct mc_pfuze *mc_pfuze);
+int pfuze_reg_read(struct mc_pfuze *mc_pfuze, unsigned int offset,
+		   unsigned char *val);
+int pfuze_reg_write(struct mc_pfuze *mc_pfuze, unsigned int offset,
+		    unsigned char val);
+int pfuze_reg_rmw(struct mc_pfuze *mc_pfuze, unsigned int offset,
+		  unsigned char mask, unsigned char val);
+int pfuze_irq_mask(struct mc_pfuze *mc_pfuze, int irq);
+int pfuze_irq_unmask(struct mc_pfuze *mc_pfuze, int irq);
+int pfuze_irq_status(struct mc_pfuze *mc_pfuze, int irq, int *enabled,
+		     int *pending);
+int pfuze_irq_status(struct mc_pfuze *mc_pfuze, int irq, int *enabled,
+		     int *pending);
+int pfuze_irq_ack(struct mc_pfuze *mc_pfuze, int irq);
+int pfuze_irq_request_nounmask(struct mc_pfuze *mc_pfuze, int irq,
+			       irq_handler_t handler, const char *name,
+			       void *dev);
+int pfuze_irq_request(struct mc_pfuze *mc_pfuze, int irq, irq_handler_t handler,
+		      const char *name, void *dev);
+int pfuze_irq_free(struct mc_pfuze *mc_pfuze, int irq, void *dev);
+unsigned int pfuze_get_flags(struct mc_pfuze *mc_pfuze);
+
+#define PFUZE_I2C_RETRY_TIMES   10
+#define PFUZE_NUM_IRQ		56
+#define PFUZE_NUMREGS		128
+#define PFUZE_IRQ_PWRONI	0
+#define PFUZE_IRQ_LOWBATT	1
+#define PFUZE_IRQ_THERM110	2
+#define PFUZE_IRQ_THERM120	3
+#define PFUZE_IRQ_THERM125	4
+#define PFUZE_IRQ_THERM130	5
+#define PFUZE_IRQ_SW1AFAULT	8
+#define PFUZE_IRQ_SW1BFAULT	9
+#define PFUZE_IRQ_SW1CFAULT	10
+#define PFUZE_IRQ_SW2FAULT	11
+#define PFUZE_IRQ_SW3AFAULT	12
+#define PFUZE_IRQ_SW3BFAULT	13
+#define PFUZE_IRQ_SW4FAULT	14
+#define PFUZE_IRQ_SWBSTFAULT	24
+#define PFUZE_IRQ_OTPECC	31
+#define PFUZE_IRQ_VGEN1FAULT	32
+#define PFUZE_IRQ_VGEN2FAULT	33
+#define PFUZE_IRQ_VGEN3FAULT	34
+#define PFUZE_IRQ_VGEN4FAULT	35
+#define PFUZE_IRQ_VGEN5FAULT	36
+#define PFUZE_IRQ_VGEN6FAULT	37
+
+#define PFUZE100_SW1A		0
+#define PFUZE100_SW1B		1
+#define PFUZE100_SW1C		2
+#define PFUZE100_SW2		3
+#define PFUZE100_SW3A		4
+#define PFUZE100_SW3B		5
+#define PFUZE100_SW4		6
+#define PFUZE100_SWBST		7
+#define PFUZE100_VSNVS		8
+#define PFUZE100_VREFDDR	9
+#define PFUZE100_VGEN1		10
+#define PFUZE100_VGEN2		11
+#define PFUZE100_VGEN3		12
+#define PFUZE100_VGEN4		13
+#define PFUZE100_VGEN5		14
+#define PFUZE100_VGEN6		15
+#define PFUZE100_SW2_VOL6	1
+#define PFUZE100_SW3_VOL6	0
+#define PFUZE100_SW4_VOL6	1
+/*#define PFUZE100_FIRST_VERSION*/
+
+struct regulator_init_data;
+struct pfuze_regulator_init_data {
+	int id;
+	struct regulator_init_data *init_data;
+};
+struct pfuze_regulator_platform_data {
+	int num_regulators;
+	struct pfuze_regulator_init_data *regulators;
+	int (*pfuze_init)(struct mc_pfuze *pfuze);
+};
+
+struct pfuze_platform_data {
+#define PFUZE_USE_REGULATOR	(1 << 0)
+	unsigned int flags;
+	int num_regulators;
+	struct pfuze_regulator_init_data *regulators;
+	int (*pfuze_init)(struct mc_pfuze *pfuze);
+};
+#endif
diff --git a/include/linux/mtd/gpmi-nand.h b/include/linux/mtd/gpmi-nand.h
index 69b6dbf..e4b52f2 100644
--- a/include/linux/mtd/gpmi-nand.h
+++ b/include/linux/mtd/gpmi-nand.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -51,6 +51,7 @@
  * @partitions:              An optional pointer to an array of partition
  *                           descriptions.
  * @partition_count:         The number of elements in the partitions array.
+ * @enable_bbt:              Enable the BBT or not.
  */
 struct gpmi_nand_platform_data {
 	/* SoC hardware information. */
@@ -64,5 +65,7 @@ struct gpmi_nand_platform_data {
 	/* Medium information. */
 	struct		mtd_partition *partitions;
 	unsigned	partition_count;
+	unsigned int	enable_bbt:1;
+	unsigned int	enable_ddr:1;
 };
 #endif
diff --git a/include/linux/power/sabresd_battery.h b/include/linux/power/sabresd_battery.h
new file mode 100644
index 0000000..463fa90
--- /dev/null
+++ b/include/linux/power/sabresd_battery.h
@@ -0,0 +1,63 @@
+/*
+ * sabresd_battery.h - Maxim 8903 USB/Adapter Charger Driver
+ *
+ * Copyright (C) 2011 Samsung Electronics
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Based on max8903_charger.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MAX8903_SABRESD_H__
+#define __MAX8903_SABRESD_H__
+
+struct max8903_pdata {
+	/*
+	 * GPIOs
+	 * cen, chg, flt, and usus are optional.
+	 * dok, dcm, and uok are not optional depending on the status of
+	 * dc_valid and usb_valid.
+	 */
+	int cen;	/* Charger Enable input */
+	int dok;	/* DC(Adapter) Power OK output */
+	int uok;	/* USB Power OK output */
+	int chg;	/* Charger status output */
+	int flt;	/* Fault output */
+	int dcm;	/* Current-Limit Mode input (1: DC, 2: USB) */
+	int usus;	/* USB Suspend Input (1: suspended) */
+	int feature_flag;/*battery capacity feature(0:enable, 1:disable)*/
+
+    /* DCM wired to Logic High
+       Set this true when DCM pin connect to Logic high.*/
+	bool dcm_always_high;
+
+	/*
+	 * DC(Adapter/TA) is wired
+	 * When dc_valid is true,
+	 *	dok and dcm should be valid.
+	 *
+	 * At least one of dc_valid or usb_valid should be true.
+	 */
+	bool dc_valid;
+	/*
+	 * USB is wired
+	 * When usb_valid is true,
+	 *	uok should be valid.
+	 */
+	bool usb_valid;
+};
+
+#endif /* __SABRESD_BATTERY_H__ */
diff --git a/include/linux/regulator/anatop-regulator.h b/include/linux/regulator/anatop-regulator.h
index c761cc6..a1d98ed 100644
--- a/include/linux/regulator/anatop-regulator.h
+++ b/include/linux/regulator/anatop-regulator.h
@@ -34,16 +34,45 @@ enum anatop_regulator_supplies {
 };
 
 struct anatop_regulator {
-	const char name[80];
+	struct regulator_desc regulator;
+	struct anatop_regulator *parent;
+	struct anatop_regulator_data *rdata;
+	struct completion done;
+
+	spinlock_t         lock;
+	wait_queue_head_t  wait_q;
+	struct notifier_block nb;
+
+	int mode;
+	int cur_voltage;
+	int cur_current;
+	int next_current;
+};
+
+
+struct anatop_regulator_data {
+	char name[80];
+	char *parent_name;
+	int (*reg_register)(struct anatop_regulator *sreg);
+	int (*set_voltage)(struct anatop_regulator *sreg, int uv);
+	int (*get_voltage)(struct anatop_regulator *sreg);
+	int (*set_current)(struct anatop_regulator *sreg, int uA);
+	int (*get_current)(struct anatop_regulator *sreg);
+	int (*enable)(struct anatop_regulator *sreg);
+	int (*disable)(struct anatop_regulator *sreg);
+	int (*is_enabled)(struct anatop_regulator *sreg);
+	int (*set_mode)(struct anatop_regulator *sreg, int mode);
+	int (*get_mode)(struct anatop_regulator *sreg);
+	int (*get_optimum_mode)(struct anatop_regulator *sreg,
+			int input_uV, int output_uV, int load_uA);
 	u32 control_reg;
-	struct anatop *mfd;
 	int vol_bit_shift;
-	int vol_bit_width;
+	int vol_bit_mask;
 	int min_bit_val;
 	int min_voltage;
 	int max_voltage;
-	struct regulator_desc rdesc;
-	struct regulator_init_data *initdata;
+	int max_current;
+	struct regulation_constraints *cnstraints;
 };
 
 int anatop_register_regulator(
-- 
1.7.5.4

