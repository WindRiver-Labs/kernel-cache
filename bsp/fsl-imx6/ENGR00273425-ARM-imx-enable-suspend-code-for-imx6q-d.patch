From 7d6e6614cd11372f180f7c0e8fb12d930e858364 Mon Sep 17 00:00:00 2001
From: Robin Gong <b38343@freescale.com>
Date: Mon, 5 Aug 2013 17:40:02 +0800
Subject: [PATCH 0086/1072] ENGR00273425 ARM: imx: enable suspend code for
 imx6q/dl

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 57a111a54fd638beb67d6a9ff3e3b3569be29dc3

Enable DSM code for imx6, the code porting form kernel 3.5.7.So with the patch,
we can suspend imx6q, imx6dl from iram to decrease power number of DDR IO:
save ~15mA@1.5V on imx6qsabresd, but need more ~30us in suspend and resume back.

Signed-off-by: Robin Gong <b38343@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/Makefile       |    3 +-
 arch/arm/mach-imx/common.h       |    2 +
 arch/arm/mach-imx/hardware.h     |    5 +-
 arch/arm/mach-imx/mach-imx6q.c   |    1 +
 arch/arm/mach-imx/mx6.h          |   35 ++
 arch/arm/mach-imx/pm-imx6q.c     |   77 +++++-
 arch/arm/mach-imx/suspend-imx6.S |  640 ++++++++++++++++++++++++++++++++++++++
 7 files changed, 760 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/mach-imx/mx6.h
 create mode 100644 arch/arm/mach-imx/suspend-imx6.S

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index 7e1ed9b..1a76d59 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -101,8 +101,9 @@ obj-$(CONFIG_HOTPLUG_CPU) += hotplug.o
 obj-$(CONFIG_SOC_IMX6Q) += clk-imx6q.o mach-imx6q.o
 obj-$(CONFIG_SOC_IMX6SL) += clk-imx6sl.o mach-imx6sl.o
 
+AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
 ifeq ($(CONFIG_PM),y)
-obj-$(CONFIG_SOC_IMX6Q) += pm-imx6q.o headsmp.o
+obj-$(CONFIG_SOC_IMX6Q) += pm-imx6q.o headsmp.o suspend-imx6.o
 endif
 
 # i.MX5 based machines
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 161f8f8..64666bd 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -126,6 +126,8 @@ static inline void imx_scu_map_io(void) {}
 static inline void imx_smp_prepare(void) {}
 static inline void imx_scu_standby_enable(void) {}
 #endif
+extern void imx6_pm_map_io(void);
+extern void imx6_suspend(void);
 extern void imx_src_init(void);
 extern void imx_src_prepare_restart(void);
 extern void imx_gpc_init(void);
diff --git a/arch/arm/mach-imx/hardware.h b/arch/arm/mach-imx/hardware.h
index a3b0b04..2b3516d 100644
--- a/arch/arm/mach-imx/hardware.h
+++ b/arch/arm/mach-imx/hardware.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -20,7 +20,9 @@
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
 #define __ASM_ARCH_MXC_HARDWARE_H__
 
+#ifndef __ASSEMBLY__
 #include <asm/io.h>
+#endif
 #include <asm/sizes.h>
 
 #define addr_in_module(addr, mod) \
@@ -105,6 +107,7 @@
 
 #include "mx51.h"
 #include "mx53.h"
+#include "mx6.h"
 #include "mx3x.h"
 #include "mx31.h"
 #include "mx35.h"
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 487c163..55f9aec 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -286,6 +286,7 @@ static void __init imx6q_map_io(void)
 {
 	debug_ll_io_init();
 	imx_scu_map_io();
+	imx6_pm_map_io();
 }
 
 static void __init imx6q_init_irq(void)
diff --git a/arch/arm/mach-imx/mx6.h b/arch/arm/mach-imx/mx6.h
new file mode 100644
index 0000000..16f7eea
--- /dev/null
+++ b/arch/arm/mach-imx/mx6.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_IOMAP_H__
+#define __ASM_ARCH_MXC_IOMAP_H__
+
+#define MX6Q_IO_P2V(x)                  IMX_IO_P2V(x)
+#define MX6Q_IO_ADDRESS(x)              IOMEM(MX6Q_IO_P2V(x))
+
+#define MX6Q_L2_BASE_ADDR               0x00a02000
+#define MX6Q_L2_SIZE			0x1000
+#define MX6Q_IOMUXC_BASE_ADDR		0x020e0000
+#define MX6Q_IOMUXC_SIZE		0x4000
+#define MX6Q_SRC_BASE_ADDR		0x020d8000
+#define MX6Q_SRC_SIZE			0x4000
+#define MX6Q_CCM_BASE_ADDR		0x020c4000
+#define MX6Q_CCM_SIZE			0x4000
+#define MX6Q_ANATOP_BASE_ADDR		0x020c8000
+#define MX6Q_ANATOP_SIZE		0x1000
+#define MX6Q_GPC_BASE_ADDR		0x020dc000
+#define MX6Q_GPC_SIZE			0x4000
+#define MX6Q_MMDC_P0_BASE_ADDR		0x021b0000
+#define MX6Q_MMDC_P0_SIZE		0x4000
+#define MX6Q_MMDC_P1_BASE_ADDR		0x021b4000
+#define MX6Q_MMDC_P1_SIZE		0x4000
+
+#define MX6_SUSPEND_IRAM_SIZE		0x1000
+#endif
diff --git a/arch/arm/mach-imx/pm-imx6q.c b/arch/arm/mach-imx/pm-imx6q.c
index 2049427..f86c762 100644
--- a/arch/arm/mach-imx/pm-imx6q.c
+++ b/arch/arm/mach-imx/pm-imx6q.c
@@ -13,18 +13,33 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/suspend.h>
+#include <linux/genalloc.h>
 #include <asm/cacheflush.h>
+#include <asm/fncpy.h>
 #include <asm/proc-fns.h>
 #include <asm/suspend.h>
 #include <asm/hardware/cache-l2x0.h>
+#include <asm/mach/map.h>
 
 #include "common.h"
 #include "hardware.h"
 
+static struct gen_pool *iram_pool;
+static void *suspend_iram_base;
+static unsigned long iram_size, iram_paddr;
+static int (*suspend_in_iram_fn)(void *iram_vbase,
+	unsigned long iram_pbase, unsigned int cpu_type);
+static unsigned int cpu_type;
+
 static int imx6q_suspend_finish(unsigned long val)
 {
-	cpu_do_idle();
+	/*
+	 * call low level suspend function in iram,
+	 * as we need to float DDR IO.
+	 */
+	suspend_in_iram_fn(suspend_iram_base, iram_paddr, cpu_type);
 	return 0;
 }
 
@@ -50,6 +65,22 @@ static int imx6q_pm_enter(suspend_state_t state)
 	return 0;
 }
 
+static struct map_desc imx6_pm_io_desc[] __initdata = {
+	imx_map_entry(MX6Q, MMDC_P0, MT_DEVICE),
+	imx_map_entry(MX6Q, MMDC_P1, MT_DEVICE),
+	imx_map_entry(MX6Q, SRC, MT_DEVICE),
+	imx_map_entry(MX6Q, IOMUXC, MT_DEVICE),
+	imx_map_entry(MX6Q, CCM, MT_DEVICE),
+	imx_map_entry(MX6Q, ANATOP, MT_DEVICE),
+	imx_map_entry(MX6Q, GPC, MT_DEVICE),
+	imx_map_entry(MX6Q, L2, MT_DEVICE),
+};
+
+void __init imx6_pm_map_io(void)
+{
+	iotable_init(imx6_pm_io_desc, ARRAY_SIZE(imx6_pm_io_desc));
+}
+
 static const struct platform_suspend_ops imx6q_pm_ops = {
 	.enter = imx6q_pm_enter,
 	.valid = suspend_valid_only_mem,
@@ -57,5 +88,49 @@ static const struct platform_suspend_ops imx6q_pm_ops = {
 
 void __init imx6q_pm_init(void)
 {
+	struct device_node *node;
+	unsigned long iram_base;
+	struct platform_device *pdev;
+
+	node = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	if (!node) {
+		pr_err("failed to find ocram node!\n");
+		return;
+	}
+
+	pdev = of_find_device_by_node(node);
+	if (!pdev) {
+		pr_err("failed to find ocram device!\n");
+		return;
+	}
+
+	iram_pool = dev_get_gen_pool(&pdev->dev);
+	if (!iram_pool) {
+		pr_err("iram pool unavailable!\n");
+		return;
+	}
+
+	iram_size = MX6_SUSPEND_IRAM_SIZE;
+
+	iram_base = gen_pool_alloc(iram_pool, iram_size);
+	if (!iram_base) {
+		pr_err("unable to alloc iram!\n");
+		return;
+	}
+
+	iram_paddr = gen_pool_virt_to_phys(iram_pool, iram_base);
+
+	suspend_iram_base = __arm_ioremap(iram_paddr, iram_size,
+			MT_MEMORY_NONCACHED);
+
+	suspend_in_iram_fn = (void *)fncpy(suspend_iram_base,
+		&imx6_suspend, iram_size);
+
 	suspend_set_ops(&imx6q_pm_ops);
+
+	/* Set cpu_type for DSM */
+	if (cpu_is_imx6q())
+		cpu_type = MXC_CPU_IMX6Q;
+	else if (cpu_is_imx6dl())
+		cpu_type = MXC_CPU_IMX6DL;
 }
diff --git a/arch/arm/mach-imx/suspend-imx6.S b/arch/arm/mach-imx/suspend-imx6.S
new file mode 100644
index 0000000..1e60640
--- /dev/null
+++ b/arch/arm/mach-imx/suspend-imx6.S
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/hardware/cache-l2x0.h>
+#include "hardware.h"
+
+#define MX6Q_SRC_GPR1	0x20
+#define MX6Q_SRC_GPR2	0x24
+#define MX6Q_MMDC_MAPSR	0x404
+#define MX6Q_GPC_IMR1	0x08
+#define MX6Q_GPC_IMR2	0x0c
+#define MX6Q_GPC_IMR3	0x10
+#define MX6Q_GPC_IMR4	0x14
+#define MX6Q_CCM_CCR	0x0
+#define MX6Q_ANATOP_CORE	0x140
+
+	.align 3
+
+	.macro	imx6dl_ddr_io_save
+
+	ldr	r4, [r8, #0x470] /* DRAM_DQM0 */
+	ldr	r5, [r8, #0x474] /* DRAM_DQM1 */
+	ldr	r6, [r8, #0x478] /* DRAM_DQM2 */
+	ldr	r7, [r8, #0x47c] /* DRAM_DQM3 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x480] /* DRAM_DQM4 */
+	ldr	r5, [r8, #0x484] /* DRAM_DQM5 */
+	ldr	r6, [r8, #0x488] /* DRAM_DQM6 */
+	ldr	r7, [r8, #0x48c] /* DRAM_DQM7 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x464] /* DRAM_CAS */
+	ldr	r5, [r8, #0x490] /* DRAM_RAS */
+	ldr	r6, [r8, #0x4ac] /* DRAM_SDCLK_0 */
+	ldr	r7, [r8, #0x4b0] /* DRAM_SDCLK_1 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r5, [r8, #0x750] /* DDRMODE_CTL */
+	ldr	r6, [r8, #0x760] /* DDRMODE */
+	stmfd	r10!, {r5-r6}
+
+	ldr	r4, [r8, #0x4bc] /* DRAM_SDQS0 */
+	ldr	r5, [r8, #0x4c0] /* DRAM_SDQS1 */
+	ldr	r6, [r8, #0x4c4] /* DRAM_SDQS2 */
+	ldr	r7, [r8, #0x4c8] /* DRAM_SDQS3 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x4cc] /* DRAM_SDQS4 */
+	ldr	r5, [r8, #0x4d0] /* DRAM_SDQS5 */
+	ldr	r6, [r8, #0x4d4] /* DRAM_SDQS6 */
+	ldr	r7, [r8, #0x4d8] /* DRAM_SDQS7 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x764] /* GPR_B0DS */
+	ldr	r5, [r8, #0x770] /* GPR_B1DS */
+	ldr	r6, [r8, #0x778] /* GPR_B2DS */
+	ldr	r7, [r8, #0x77c] /* GPR_B3DS */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x780] /* GPR_B4DS */
+	ldr	r5, [r8, #0x784] /* GPR_B5DS */
+	ldr	r6, [r8, #0x78c] /* GPR_B6DS */
+	ldr	r7, [r8, #0x748] /* GPR_B7DS */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r5, [r8, #0x74c] /* GPR_ADDS*/
+	ldr	r6, [r8, #0x4b4] /* DRAM_SODT0*/
+	ldr	r7, [r8, #0x4b8] /* DRAM_SODT1*/
+	stmfd	r10!, {r5-r7}
+
+	.endm
+
+	.macro	imx6dl_ddr_io_restore
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x470] /* DRAM_DQM0 */
+	str	r5, [r8, #0x474] /* DRAM_DQM1 */
+	str	r6, [r8, #0x478] /* DRAM_DQM2 */
+	str	r7, [r8, #0x47c] /* DRAM_DQM3 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x480] /* DRAM_DQM4 */
+	str	r5, [r8, #0x484] /* DRAM_DQM5 */
+	str	r6, [r8, #0x488] /* DRAM_DQM6 */
+	str	r7, [r8, #0x48c] /* DRAM_DQM7 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x464] /* DRAM_CAS */
+	str	r5, [r8, #0x490] /* DRAM_RAS */
+	str	r6, [r8, #0x4ac] /* DRAM_SDCLK_0 */
+	str	r7, [r8, #0x4b0] /* DRAM_SDCLK_1 */
+
+	ldmea	r10!, {r5-r6}
+	str	r5, [r8, #0x750] /* DDRMODE_CTL */
+	str	r6, [r8, #0x760] /* DDRMODE */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x4bc] /* DRAM_SDQS0 */
+	str	r5, [r8, #0x4c0] /* DRAM_SDQS1 */
+	str	r6, [r8, #0x4c4] /* DRAM_SDQS2 */
+	str	r7, [r8, #0x4c8] /* DRAM_SDQS3 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x4cc] /* DRAM_SDQS4 */
+	str	r5, [r8, #0x4d0] /* DRAM_SDQS5 */
+	str	r6, [r8, #0x4d4] /* DRAM_SDQS6 */
+	str	r7, [r8, #0x4d8] /* DRAM_SDQS7 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x764] /* GPR_B0DS */
+	str	r5, [r8, #0x770] /* GPR_B1DS */
+	str	r6, [r8, #0x778] /* GPR_B2DS */
+	str	r7, [r8, #0x77c] /* GPR_B3DS */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x780] /* GPR_B4DS */
+	str	r5, [r8, #0x784] /* GPR_B5DS */
+	str	r6, [r8, #0x78c] /* GPR_B6DS */
+	str	r7, [r8, #0x748] /* GPR_B7DS */
+
+	ldmea	r10!, {r5-r7}
+	str	r5, [r8, #0x74c] /* GPR_ADDS*/
+	str	r6, [r8, #0x4b4] /* DRAM_SODT0*/
+	str	r7, [r8, #0x4b8] /* DRAM_SODT1*/
+
+	.endm
+
+	.macro	imx6dl_ddr_io_set_lpm
+
+	mov	r10, #0
+	str	r10, [r8, #0x470] /* DRAM_DQM0 */
+	str	r10, [r8, #0x474] /* DRAM_DQM1 */
+	str	r10, [r8, #0x478] /* DRAM_DQM2 */
+	str	r10, [r8, #0x47c] /* DRAM_DQM3 */
+
+	str	r10, [r8, #0x480] /* DRAM_DQM4 */
+	str	r10, [r8, #0x484] /* DRAM_DQM5 */
+	str	r10, [r8, #0x488] /* DRAM_DQM6 */
+	str	r10, [r8, #0x48c] /* DRAM_DQM7 */
+
+	str	r10, [r8, #0x464] /* DRAM_CAS */
+	str	r10, [r8, #0x490] /* DRAM_RAS */
+	str	r10, [r8, #0x4ac] /* DRAM_SDCLK_0 */
+	str	r10, [r8, #0x4b0] /* DRAM_SDCLK_1 */
+
+	str	r10, [r8, #0x750] /* DDRMODE_CTL */
+	str	r10, [r8, #0x760] /* DDRMODE */
+
+	str	r10, [r8, #0x4bc] /* DRAM_SDQS0 */
+	str	r10, [r8, #0x4c0] /* DRAM_SDQS1 */
+	str	r10, [r8, #0x4c4] /* DRAM_SDQS2 */
+	str	r10, [r8, #0x4c8] /* DRAM_SDQS3 */
+
+	str	r10, [r8, #0x4cc] /* DRAM_SDQS4 */
+	str	r10, [r8, #0x4d0] /* DRAM_SDQS5 */
+	str	r10, [r8, #0x4d4] /* DRAM_SDQS6 */
+	str	r10, [r8, #0x4d8] /* DRAM_SDQS7 */
+
+	str	r10, [r8, #0x764] /* GPR_B0DS */
+	str	r10, [r8, #0x770] /* GPR_B1DS */
+	str	r10, [r8, #0x778] /* GPR_B2DS */
+	str	r10, [r8, #0x77c] /* GPR_B3DS */
+
+	str	r10, [r8, #0x780] /* GPR_B4DS */
+	str	r10, [r8, #0x784] /* GPR_B5DS */
+	str	r10, [r8, #0x78c] /* GPR_B6DS */
+	str	r10, [r8, #0x748] /* GPR_B7DS */
+
+	str	r10, [r8, #0x74c] /* GPR_ADDS*/
+	str	r10, [r8, #0x4b4] /* DRAM_SODT0*/
+	str	r10, [r8, #0x4b8] /* DRAM_SODT1*/
+
+	.endm
+
+	.macro	imx6dq_ddr_io_save
+
+	ldr	r4, [r8, #0x5ac] /* DRAM_DQM0 */
+	ldr	r5, [r8, #0x5b4] /* DRAM_DQM1 */
+	ldr	r6, [r8, #0x528] /* DRAM_DQM2 */
+	ldr	r7, [r8, #0x520] /* DRAM_DQM3 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x514] /* DRAM_DQM4 */
+	ldr	r5, [r8, #0x510] /* DRAM_DQM5 */
+	ldr	r6, [r8, #0x5bc] /* DRAM_DQM6 */
+	ldr	r7, [r8, #0x5c4] /* DRAM_DQM7 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x56c] /* DRAM_CAS */
+	ldr	r5, [r8, #0x578] /* DRAM_RAS */
+	ldr	r6, [r8, #0x588] /* DRAM_SDCLK_0 */
+	ldr	r7, [r8, #0x594] /* DRAM_SDCLK_1 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r5, [r8, #0x750] /* DDRMODE_CTL */
+	ldr	r6, [r8, #0x774] /* DDRMODE */
+	stmfd	r10!, {r5-r6}
+
+	ldr	r4, [r8, #0x5a8] /* DRAM_SDQS0 */
+	ldr	r5, [r8, #0x5b0] /* DRAM_SDQS1 */
+	ldr	r6, [r8, #0x524] /* DRAM_SDQS2 */
+	ldr	r7, [r8, #0x51c] /* DRAM_SDQS3 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x518] /* DRAM_SDQS4 */
+	ldr	r5, [r8, #0x50c] /* DRAM_SDQS5 */
+	ldr	r6, [r8, #0x5b8] /* DRAM_SDQS6 */
+	ldr	r7, [r8, #0x5c0] /* DRAM_SDQS7 */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x784] /* GPR_B0DS */
+	ldr	r5, [r8, #0x788] /* GPR_B1DS */
+	ldr	r6, [r8, #0x794] /* GPR_B2DS */
+	ldr	r7, [r8, #0x79c] /* GPR_B3DS */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r4, [r8, #0x7a0] /* GPR_B4DS */
+	ldr	r5, [r8, #0x7a4] /* GPR_B5DS */
+	ldr	r6, [r8, #0x7a8] /* GPR_B6DS */
+	ldr	r7, [r8, #0x748] /* GPR_B7DS */
+	stmfd	r10!, {r4-r7}
+
+	ldr	r5, [r8, #0x74c] /* GPR_ADDS*/
+	ldr	r6, [r8, #0x59c] /* DRAM_SODT0*/
+	ldr	r7, [r8, #0x5a0] /* DRAM_SODT1*/
+	stmfd	r10!, {r5-r7}
+
+	.endm
+
+	.macro	imx6dq_ddr_io_restore
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x5ac] /* DRAM_DQM0 */
+	str	r5, [r8, #0x5b4] /* DRAM_DQM1 */
+	str	r6, [r8, #0x528] /* DRAM_DQM2 */
+	str	r7, [r8, #0x520] /* DRAM_DQM3 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x514] /* DRAM_DQM4 */
+	str	r5, [r8, #0x510] /* DRAM_DQM5 */
+	str	r6, [r8, #0x5bc] /* DRAM_DQM6 */
+	str	r7, [r8, #0x5c4] /* DRAM_DQM7 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x56c] /* DRAM_CAS */
+	str	r5, [r8, #0x578] /* DRAM_RAS */
+	str	r6, [r8, #0x588] /* DRAM_SDCLK_0 */
+	str	r7, [r8, #0x594] /* DRAM_SDCLK_1 */
+
+	ldmea	r10!, {r5-r6}
+	str	r5, [r8, #0x750] /* DDRMODE_CTL */
+	str	r6, [r8, #0x774] /* DDRMODE */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x5a8] /* DRAM_SDQS0 */
+	str	r5, [r8, #0x5b0] /* DRAM_SDQS1 */
+	str	r6, [r8, #0x524] /* DRAM_SDQS2 */
+	str	r7, [r8, #0x51c] /* DRAM_SDQS3 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x518] /* DRAM_SDQS4 */
+	str	r5, [r8, #0x50c] /* DRAM_SDQS5 */
+	str	r6, [r8, #0x5b8] /* DRAM_SDQS6 */
+	str	r7, [r8, #0x5c0] /* DRAM_SDQS7 */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x784] /* GPR_B0DS */
+	str	r5, [r8, #0x788] /* GPR_B1DS */
+	str	r6, [r8, #0x794] /* GPR_B2DS */
+	str	r7, [r8, #0x79c] /* GPR_B3DS */
+
+	ldmea	r10!, {r4-r7}
+	str	r4, [r8, #0x7a0] /* GPR_B4DS */
+	str	r5, [r8, #0x7a4] /* GPR_B5DS */
+	str	r6, [r8, #0x7a8] /* GPR_B6DS */
+	str	r7, [r8, #0x748] /* GPR_B7DS */
+
+	ldmea	r10!, {r5-r7}
+	str	r5, [r8, #0x74c] /* GPR_ADDS*/
+	str	r6, [r8, #0x59c] /* DRAM_SODT0*/
+	str	r7, [r8, #0x5a0] /* DRAM_SODT1*/
+
+	.endm
+
+	.macro	imx6dq_ddr_io_set_lpm
+
+	mov	r10, #0
+	str	r10, [r8, #0x5ac] /* DRAM_DQM0 */
+	str	r10, [r8, #0x5b4] /* DRAM_DQM1 */
+	str	r10, [r8, #0x528] /* DRAM_DQM2 */
+	str	r10, [r8, #0x520] /* DRAM_DQM3 */
+
+	str	r10, [r8, #0x514] /* DRAM_DQM4 */
+	str	r10, [r8, #0x510] /* DRAM_DQM5 */
+	str	r10, [r8, #0x5bc] /* DRAM_DQM6 */
+	str	r10, [r8, #0x5c4] /* DRAM_DQM7 */
+
+	str	r10, [r8, #0x56c] /* DRAM_CAS */
+	str	r10, [r8, #0x578] /* DRAM_RAS */
+	str	r10, [r8, #0x588] /* DRAM_SDCLK_0 */
+	str	r10, [r8, #0x594] /* DRAM_SDCLK_1 */
+
+	str	r10, [r8, #0x750] /* DDRMODE_CTL */
+	str	r10, [r8, #0x774] /* DDRMODE */
+
+	str	r10, [r8, #0x5a8] /* DRAM_SDQS0 */
+	str	r10, [r8, #0x5b0] /* DRAM_SDQS1 */
+	str	r10, [r8, #0x524] /* DRAM_SDQS2 */
+	str	r10, [r8, #0x51c] /* DRAM_SDQS3 */
+
+	str	r10, [r8, #0x518] /* DRAM_SDQS4 */
+	str	r10, [r8, #0x50c] /* DRAM_SDQS5 */
+	str	r10, [r8, #0x5b8] /* DRAM_SDQS6 */
+	str	r10, [r8, #0x5c0] /* DRAM_SDQS7 */
+
+	str	r10, [r8, #0x784] /* GPR_B0DS */
+	str	r10, [r8, #0x788] /* GPR_B1DS */
+	str	r10, [r8, #0x794] /* GPR_B2DS */
+	str	r10, [r8, #0x79c] /* GPR_B3DS */
+
+	str	r10, [r8, #0x7a0] /* GPR_B4DS */
+	str	r10, [r8, #0x7a4] /* GPR_B5DS */
+	str	r10, [r8, #0x7a8] /* GPR_B6DS */
+	str	r10, [r8, #0x748] /* GPR_B7DS */
+
+	str	r10, [r8, #0x74c] /* GPR_ADDS*/
+	str	r10, [r8, #0x59c] /* DRAM_SODT0*/
+	str	r10, [r8, #0x5a0] /* DRAM_SODT1*/
+
+	.endm
+
+	.macro  sync_l2_cache
+
+	/* sync L2 cache to drain L2's buffers to DRAM. */
+#ifdef CONFIG_CACHE_L2X0
+	ldr	r8, =IMX_IO_P2V(MX6Q_L2_BASE_ADDR)
+	mov	r5, #0x0
+	str	r5, [r8, #L2X0_CACHE_SYNC]
+1:
+	ldr	r5, [r8, #L2X0_CACHE_SYNC]
+	ands	r5, r5, #0x1
+	bne	1b
+#endif
+	.endm
+
+ENTRY(imx6_suspend)
+
+	/*
+	 * counting the resume address in iram
+	 * to set it in SRC register.
+	 */
+	ldr	r4, =imx6_suspend
+	ldr	r5, =resume
+	sub	r5, r5, r4
+	add	r9, r1, r5
+
+	/*
+	 * make sure TLB contain the addr we want,
+	 * as we will access after DDR IO floated.
+	 */
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_ANATOP_BASE_ADDR)
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	ldr	r8, =IMX_IO_P2V(MX6Q_CCM_BASE_ADDR)
+	ldr	r7, [r8, #0x0]
+	ldr	r8, =IMX_IO_P2V(MX6Q_GPC_BASE_ADDR)
+	ldr	r7, [r8, #0x0]
+
+	/* use r8 to store the IO address */
+	ldr	r8, =IMX_IO_P2V(MX6Q_SRC_BASE_ADDR)
+
+	/*
+	 * read previous resume address from SRC
+	 * register, which is v7_cpu_resume, this
+	 * is for the jump when we finish DDR IO
+	 * restore.
+	 */
+	ldr	r5, [r8, #MX6Q_SRC_GPR1]
+	add	r10, r0, #MX6_SUSPEND_IRAM_SIZE
+	stmfd	r10!, {r5}
+
+	/* save cpu type */
+	stmfd	r10!, {r2}
+
+	str	r9, [r8, #MX6Q_SRC_GPR1]
+	add	r3, r1, #MX6_SUSPEND_IRAM_SIZE
+	str	r3, [r8, #MX6Q_SRC_GPR2]
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_IOMUXC_BASE_ADDR)
+
+	cmp	r2, #MXC_CPU_IMX6Q
+	bne	dl_io_dsm_save
+	imx6dq_ddr_io_save
+	b	ddr_io_save_dsm_done
+dl_io_dsm_save:
+	imx6dl_ddr_io_save
+ddr_io_save_dsm_done:
+
+	/* need to sync L2 cache before DSM. */
+	sync_l2_cache
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_MMDC_P0_BASE_ADDR)
+	/*
+	 * put DDR explicitly into self-refresh and
+	 * disable Automatic power savings.
+	 */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	orr	r7, r7, #0x01
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+
+	/* make the DDR explicitly enter self-refresh. */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	orr	r7, r7, #(1 << 21)
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+
+poll_dvfs_set_1:
+	ldr	r7, [r8, #0x404]
+	ands	r7, r7, #(1 << 25)
+	beq	poll_dvfs_set_1
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_IOMUXC_BASE_ADDR)
+
+	cmp	r2, #MXC_CPU_IMX6Q
+	bne	dl_io_dsm_set_lpm
+	imx6dq_ddr_io_set_lpm
+	b	ddr_io_set_lpm_dsm_done
+dl_io_dsm_set_lpm:
+	imx6dl_ddr_io_set_lpm
+ddr_io_set_lpm_dsm_done:
+
+	/*
+	 * mask all GPC interrupts before
+	 * enabling the RBC counters to
+	 * avoid the counter starting too
+	 * early if an interupt is already
+	 * pending.
+	 */
+	ldr	r8, =IMX_IO_P2V(MX6Q_CCM_BASE_ADDR)
+	/* save CCM base in r9 */
+	mov	r9, r8
+	ldr	r8, =IMX_IO_P2V(MX6Q_GPC_BASE_ADDR)
+	ldr	r4, [r8, #MX6Q_GPC_IMR1]
+	ldr	r5, [r8, #MX6Q_GPC_IMR2]
+	ldr	r6, [r8, #MX6Q_GPC_IMR3]
+	ldr	r7, [r8, #MX6Q_GPC_IMR4]
+
+	ldr	r3, =0xffffffff
+	str	r3, [r8, #MX6Q_GPC_IMR1]
+	str	r3, [r8, #MX6Q_GPC_IMR2]
+	str	r3, [r8, #MX6Q_GPC_IMR3]
+	str	r3, [r8, #MX6Q_GPC_IMR4]
+
+	/*
+	 * enable the RBC bypass counter here
+	 * to hold off the interrupts. RBC counter
+	 * = 32 (1ms), Minimum RBC delay should be
+	 * 400us for the analog LDOs to power down.
+	 */
+	ldr	r3, [r9, #MX6Q_CCM_CCR]
+	bic	r3, r3, #(0x3f << 21)
+	orr	r3, r3, #(0x20 << 21)
+	str	r3, [r9, #MX6Q_CCM_CCR]
+
+	/* enable the counter. */
+	ldr	r3, [r9, #MX6Q_CCM_CCR]
+	orr	r3, r3, #(0x1 << 27)
+	str	r3, [r9, #MX6Q_CCM_CCR]
+
+	/* unmask all the GPC interrupts. */
+	str	r4, [r8, #MX6Q_GPC_IMR1]
+	str	r5, [r8, #MX6Q_GPC_IMR2]
+	str	r6, [r8, #MX6Q_GPC_IMR3]
+	str	r7, [r8, #MX6Q_GPC_IMR4]
+
+	/*
+	 * now delay for a short while (3usec)
+	 * ARM is at 1GHz at this point
+	 * so a short loop should be enough.
+	 * this delay is required to ensure that
+	 * the RBC counter can start counting in
+	 * case an interrupt is already pending
+	 * or in case an interrupt arrives just
+	 * as ARM is about to assert DSM_request.
+	 */
+	ldr     r4, =2000
+rbc_loop:
+	sub     r4, r4, #0x1
+	cmp     r4, #0x0
+	bne     rbc_loop
+
+	/*
+	 * if internal ldo(VDDARM) bypassed,analog bypass
+	 * it for DSM(0x1e) and restore it when resume(0x1f).
+	 */
+	ldr	r8, =IMX_IO_P2V(MX6Q_ANATOP_BASE_ADDR)
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	ands	r7, r7, #0x1f
+	beq	ldo_check_done1
+ldo_analog_bypass:
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	bic	r7, r7, #0x1f
+	orr	r7, r7, #0x1e
+	str	r7, [r8, #MX6Q_ANATOP_CORE]
+ldo_check_done1:
+
+	/* Zzz, enter stop mode */
+	wfi
+	nop
+	nop
+	nop
+	nop
+
+	/*
+	 * run to here means there is pending
+	 * wakeup source, system should auto
+	 * resume, we need to restore DDR IO first
+	 */
+
+	/* restore it with 0x1f if use ldo bypass mode.*/
+	ldr	r8, =IMX_IO_P2V(MX6Q_ANATOP_BASE_ADDR)
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	and	r7, r7, #0x1f
+	cmp	r7, #0x1e
+	bne	ldo_check_done2
+ldo_bypass_restore:
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	orr	r7, r7, #0x1f
+	str	r7, [r8, #MX6Q_ANATOP_CORE]
+ldo_check_done2:
+
+	add	r10, r0, #MX6_SUSPEND_IRAM_SIZE
+	/* skip the lr saved in iram */
+	sub	r10, r10, #0x4
+	/* skip the cpu type saved in iram */
+	sub	r10, r10, #0x4
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_IOMUXC_BASE_ADDR)
+
+	cmp	r2, #MXC_CPU_IMX6Q
+	bne	dl_io_restore
+	imx6dq_ddr_io_restore
+	b	ddr_io_restore_done
+dl_io_restore:
+	imx6dl_ddr_io_restore
+ddr_io_restore_done:
+
+	ldr	r8, =IMX_IO_P2V(MX6Q_MMDC_P0_BASE_ADDR)
+	/* let DDR out of self-refresh. */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	bic	r7, r7, #(1 << 21)
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+
+poll_dvfs_clear_2:
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	ands	r7, r7, #(1 << 25)
+	bne     poll_dvfs_clear_2
+	/* enable DDR auto power saving */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	bic	r7, r7, #0x1
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+	/* return to suspend finish */
+	mov	pc, lr
+
+resume:
+	/* invalidate L1 I-cache first */
+	mov     r1,     #0x0
+	mcr     p15, 0, r1, c7, c5, 0
+	mcr     p15, 0, r1, c7, c5, 0
+	mcr     p15, 0, r1, c7, c5, 6
+	/* enable the Icache and branch prediction */
+	mov     r1, #0x1800
+	mcr     p15, 0, r1, c1, c0, 0
+	isb
+
+	/* restore it with 0x1f if use ldo bypass mode.*/
+	ldr	r8, =MX6Q_ANATOP_BASE_ADDR
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	and	r7, r7, #0x1f
+	cmp	r7, #0x1e
+	bne	ldo_check_done3
+	ldr	r7, [r8, #MX6Q_ANATOP_CORE]
+	orr	r7, r7, #0x1f
+	str	r7, [r8, #MX6Q_ANATOP_CORE]
+ldo_check_done3:
+
+	ldr	r5, =MX6Q_SRC_BASE_ADDR
+	ldr	r10, [r5, #MX6Q_SRC_GPR2]
+	ldmea	r10!, {lr}
+
+	/* get cpu tpye */
+	ldmea	r10!, {r2}
+
+	/* clear core0's entry and parameter */
+	ldr	r8, =MX6Q_SRC_BASE_ADDR
+	mov	r7, #0
+	str	r7, [r8, #MX6Q_SRC_GPR1]
+	str	r7, [r8, #MX6Q_SRC_GPR2]
+
+	ldr	r8, =MX6Q_IOMUXC_BASE_ADDR
+
+	cmp	r2, #MXC_CPU_IMX6Q
+	bne	dl_io_dsm_restore
+	imx6dq_ddr_io_restore
+	b	ddr_io_restore_dsm_done
+dl_io_dsm_restore:
+	imx6dl_ddr_io_restore
+ddr_io_restore_dsm_done:
+
+	ldr	r8, =MX6Q_MMDC_P0_BASE_ADDR
+	/* let DDR out of self-refresh */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	bic	r7, r7, #(1 << 21)
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+
+poll_dvfs_clear_1:
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	ands	r7, r7, #(1 << 25)
+	bne	poll_dvfs_clear_1
+	/* enable DDR auto power saving */
+	ldr	r7, [r8, #MX6Q_MMDC_MAPSR]
+	bic	r7, r7, #0x1
+	str	r7, [r8, #MX6Q_MMDC_MAPSR]
+	mov	pc, lr
-- 
1.7.5.4

