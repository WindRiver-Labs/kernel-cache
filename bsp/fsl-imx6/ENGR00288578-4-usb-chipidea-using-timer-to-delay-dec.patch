From 07c1baf1614c62376b216f49060fb61a7ff9b5d6 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Tue, 19 Nov 2013 15:42:32 +0800
Subject: [PATCH 0744/1072] ENGR00288578-4 usb: chipidea: using timer to delay
 decreasing power.usage_count

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 649c7670512e2ec3fb8c17efb11e3760813b7316

We need to keep controller as active until the udc or host driver
requests its power.usage_count, otherwise, the system will hang
due to access register at low power mode.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
(cherry picked from commit 8e590389f16ae637142af1d7026ecf5f3f4e5b13)
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/usb/chipidea/ci.h   |    3 +++
 drivers/usb/chipidea/core.c |   11 ++++++++++-
 2 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index cbd6d10..a37255e 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -138,6 +138,8 @@ struct hw_bank {
  * @imx28_write_fix: for fsl imx28 write
  * @supports_runtime_pm: if runtime pm is supported
  * @in_lpm: if the core in low power mode
+ * @wakeup_int: if wakeup interrupt occur
+ * @timer: timer to delay clock closing
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -181,6 +183,7 @@ struct ci_hdrc {
 	bool				supports_runtime_pm;
 	bool				in_lpm;
 	bool				wakeup_int;
+	struct timer_list		timer;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)
diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index 96b15fd..5085409 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -178,6 +178,13 @@ static void hw_wait_phy_stable(void)
 	usleep_range(2000, 2500);
 }
 
+static void delay_runtime_pm_put_timer(unsigned long arg)
+{
+	struct ci_hdrc *ci = (struct ci_hdrc *)arg;
+
+	pm_runtime_put(ci->dev);
+}
+
 /* The PHY enters/leaves low power mode */
 static void ci_hdrc_enter_lpm(struct ci_hdrc *ci, bool enable)
 {
@@ -676,6 +683,8 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 		pm_runtime_enable(&pdev->dev);
 	}
 
+	setup_timer(&ci->timer, delay_runtime_pm_put_timer,
+			(unsigned long)ci);
 	ret = dbg_create_files(ci);
 	if (!ret)
 		return 0;
@@ -757,7 +766,7 @@ static int ci_controller_resume(struct device *dev)
 	if (ci->wakeup_int) {
 		ci->wakeup_int = false;
 		enable_irq(ci->irq);
-		pm_runtime_put(ci->dev);
+		mod_timer(&ci->timer, jiffies + msecs_to_jiffies(2000));
 	}
 
 	return 0;
-- 
1.7.5.4

