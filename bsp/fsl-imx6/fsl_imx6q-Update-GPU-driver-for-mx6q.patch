From 476918966428f4d049896899e8f3d343042ced2b Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 13 Jun 2013 17:57:50 +0800
Subject: [PATCH 24/38] fsl_imx6q: Update GPU driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mxc/gpu-viv/Kbuild                         |   12 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.c |    5 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.h |    5 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.c   |   46 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.h   |    7 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.c   |   62 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.h   |    5 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c  | 1599 ++++++++++++++++---
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h  |   30 +-
 drivers/mxc/gpu-viv/config                         |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     | 1480 +++++++++++++++--
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |  208 +++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |  390 ++++-
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |  146 ++-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |  142 ++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |   10 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |  421 ++++--
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c    |    4 +-
 .../hal/kernel/gc_hal_kernel_interrupt_vg.c        |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |  361 ++++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c  |   25 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c   |  347 ++++
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |  169 ++-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h  |    7 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        |   62 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |  296 +++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  258 +++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h   |  804 +++++++++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |  333 +++--
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h  |   30 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h   |    3 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h    |  418 ++---
 .../hal/kernel/inc/gc_hal_eglplatform_type.h       |  286 ++++
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |  197 +++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |   12 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   75 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h  |   49 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_md5.h    |  112 --
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |   16 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |  161 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |   31 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |   35 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h |    4 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h |  115 ++
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   60 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    8 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |   42 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debug.h      |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.c    |  795 +++++++++
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.h    |   84 +
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  291 ++--
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   52 +-
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |  315 +++-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |   20 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |    6 +-
 .../hal/os/linux/kernel/gc_hal_kernel_math.c       |    4 +-
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c | 1747 ++++++++++++--------
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |   19 +-
 59 files changed, 9754 insertions(+), 2489 deletions(-)
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
 delete mode 100644 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_md5.h
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h

diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index aebe795..0b18a7b 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -42,7 +42,8 @@ OBJS := $(OS_KERNEL_DIR)/gc_hal_kernel_device.o \
         $(OS_KERNEL_DIR)/gc_hal_kernel_driver.o \
         $(OS_KERNEL_DIR)/gc_hal_kernel_linux.o \
         $(OS_KERNEL_DIR)/gc_hal_kernel_math.o \
-        $(OS_KERNEL_DIR)/gc_hal_kernel_os.o
+        $(OS_KERNEL_DIR)/gc_hal_kernel_os.o \
+        $(OS_KERNEL_DIR)/gc_hal_kernel_debugfs.o
 
 ifeq ($(USE_3D_VG), 1)
 
@@ -53,7 +54,8 @@ OBJS += $(HAL_KERNEL_DIR)/gc_hal_kernel.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_event.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_heap.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_mmu.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o \
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_power.o
 
 OBJS += $(ARCH_KERNEL_DIR)/gc_hal_kernel_context.o \
         $(ARCH_KERNEL_DIR)/gc_hal_kernel_hardware.o
@@ -133,12 +135,6 @@ else
 EXTRA_CFLAGS += -DgcdPOWER_MANAGEMENT=0
 endif
 
-ifeq ($(USE_OPENCL), 1)
-EXTRA_CFLAGS += -DgcdUSE_OPENCL=1
-else
-EXTRA_CFLAGS += -DgcdUSE_OPENCL=0
-endif
-
 ifneq ($(USE_PLATFORM_DRIVER), 0)
 EXTRA_CFLAGS += -DUSE_PLATFORM_DRIVER=1
 else
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
index 9532137..cf40e3f 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
@@ -927,3 +929,4 @@ gckVGCOMMAND_EndCommand(
 }
 
 #endif /* gcdENABLE_VG */
+
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
index d1a6a17..aa767ee 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #ifndef __gc_hal_kernel_hardware_command_vg_h_
 #define __gc_hal_kernel_hardware_command_vg_h_
 
@@ -314,3 +316,4 @@ gckVGCOMMAND_EndCommand(
     );
 
 #endif  /* __gc_hal_kernel_hardware_command_h_ */
+
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
index c26fa68..4a6010d 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_hardware_command_vg.h"
@@ -310,6 +308,7 @@ gckVGHARDWARE_Construct(
 
     do
     {
+        gcmkERR_BREAK(gckOS_SetGPUPower(Os, gcvCORE_VG, gcvTRUE, gcvTRUE));
         status = _ResetGPU(Os);
 
         if (status != gcvSTATUS_OK)
@@ -342,7 +341,7 @@ gckVGHARDWARE_Construct(
 
         hardware->powerMutex            = gcvNULL;
         hardware->idleSignal            = gcvNULL;
-        hardware->chipPowerState        = gcvPOWER_OFF;
+        hardware->chipPowerState        = gcvPOWER_ON;
         hardware->chipPowerStateGlobal  = gcvPOWER_ON;
         hardware->clockState            = gcvTRUE;
         hardware->powerState            = gcvTRUE;
@@ -362,6 +361,8 @@ gckVGHARDWARE_Construct(
         /* Set default event mask. */
         hardware->eventMask = 0xFFFFFFFF;
 
+        gcmkERR_BREAK(gckOS_AtomConstruct(Os, &hardware->pageTableDirty));
+
         /* Set fast clear to auto. */
         gcmkVERIFY_OK(gckVGHARDWARE_SetFastClear(hardware, -1));
 
@@ -384,6 +385,11 @@ gckVGHARDWARE_Construct(
     }
     while (gcvFALSE);
 
+    if (hardware->pageTableDirty != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Os, hardware->pageTableDirty));
+    }
+
     if (hardware != gcvNULL)
     {
         gcmkVERIFY_OK(gckOS_Free(Os, hardware));
@@ -439,6 +445,11 @@ gckVGHARDWARE_Destroy(
             Hardware->os, Hardware->idleSignal));
     }
 
+    if (Hardware->pageTableDirty != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pageTableDirty));
+    }
+
     /* Free the object. */
     status = gckOS_Free(Hardware->os, Hardware);
     gcmkFOOTER();
@@ -1277,26 +1288,6 @@ gceSTATUS gckVGHARDWARE_FlushMMU(
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
-#if gcdPOWER_MANAGEMENT
-        /* Acquire the power management semaphore. */
-        gcmkERR_BREAK(gckOS_AcquireSemaphore(Hardware->os,
-                               command->powerSemaphore));
-
-        status = gckVGCOMMAND_Execute(
-                            command,
-                            commandBuffer
-                            );
-        /* Acquire the power management semaphore. */
-        gcmkVERIFY_OK(gckOS_ReleaseSemaphore(Hardware->os,
-                               command->powerSemaphore));
-
-        gcmkERR_BREAK(status);
-#else
-        gcmkERR_BREAK(gckVGCOMMAND_Execute(
-            command,
-            commandBuffer
-            ));
-#endif
     }
     while(gcvFALSE);
 
@@ -1476,7 +1467,7 @@ static gceSTATUS _CommandStall(
         gcmkERR_BREAK(gckOS_WaitSignal(
             command->os,
             command->powerStallSignal,
-            gcvINFINITE));
+            gcdGPU_TIMEOUT));
 
 
     }
@@ -1750,7 +1741,7 @@ gckVGHARDWARE_SetPowerManagementState(
     if (flag & (gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_CLOCK_ON))
     {
         /* Turn on the power. */
-        gcmkONERROR(gckOS_SetGPUPower(os, gcvCORE_VG , gcvTRUE, gcvTRUE));
+        gcmkONERROR(gckOS_SetGPUPower(os, gcvCORE_VG, gcvTRUE, gcvTRUE));
 
         /* Mark clock and power as enabled. */
         Hardware->clockState = gcvTRUE;
@@ -1809,6 +1800,8 @@ gckVGHARDWARE_SetPowerManagementState(
 
     if (flag & gcvPOWER_FLAG_INITIALIZE)
     {
+        gcmkONERROR(gckVGHARDWARE_SetMMU(Hardware, Hardware->kernel->mmu->pageTableLogical));
+
         /* Force the command queue to reload the next context. */
         command->currentContext = 0;
     }
@@ -2046,3 +2039,4 @@ OnError:
     return status;
 }
 #endif /* gcdENABLE_VG */
+
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
index 2e3cbb8..83a603e 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #ifndef __gc_hal_kernel_hardware_vg_h_
 #define __gc_hal_kernel_hardware_vg_h_
 
@@ -63,7 +65,8 @@ struct _gckVGHARDWARE
     gctUINT32                   powerOffTimeout;
     gctTHREAD                   timeIdleThread;
     gctBOOL                     killThread;
-
+    gctPOINTER                  pageTableDirty;
 };
 
 #endif /* __gc_hal_kernel_hardware_h_ */
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
index e46c377..22e1f27 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_context.h"
@@ -204,6 +206,7 @@ _FlushPipe(
     return 6;
 }
 
+#if !defined(VIVANTE_NO_3D)
 static gctSIZE_T
 _SemaphoreStall(
     IN gckCONTEXT Context,
@@ -239,6 +242,7 @@ _SemaphoreStall(
     /* Semaphore/stall takes 4 slots. */
     return 4;
 }
+#endif
 
 static gctSIZE_T
 _SwitchPipe(
@@ -467,10 +471,12 @@ _InitializeContextBuffer(
     index += _SwitchPipe(Context, index, gcvPIPE_3D);
 
     /* Current context pointer. */
-#if gcdDEBUG && 1
+#if gcdDEBUG 
     index += _State(Context, index, 0x03850 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 #endif
 
+    index += _FlushPipe(Context, index, gcvPIPE_3D);
+
     /* Global states. */
     index += _State(Context, index, 0x03814 >> 2, 0x00000001, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x03818 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
@@ -539,7 +545,8 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x00A38 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00A3C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00A80 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x00A84 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+    index += _State(Context, index, 0x00A84 >> 2, 0x00000000, 1, gcvTRUE, gcvFALSE);
+    index += _State(Context, index, 0x00A8C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
     /* Setup states. */
     index += _State(Context, index, 0x00C00 >> 2, 0x00000000, 1, gcvTRUE, gcvFALSE);
@@ -550,8 +557,8 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x00C14 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00C18 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00C1C >> 2, 0x42000000, 1, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x00C20 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x00C24 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+    index += _State(Context, index, 0x00C20 >> 2, 0x00000000, 1, gcvTRUE, gcvFALSE);
+    index += _State(Context, index, 0x00C24 >> 2, 0x00000000, 1, gcvTRUE, gcvFALSE);
 
     /* Raster states. */
     index += _State(Context, index, 0x00E00 >> 2, 0x00000001, 1, gcvFALSE, gcvFALSE);
@@ -613,6 +620,7 @@ _InitializeContextBuffer(
         index += _State(Context, index, 0x10180 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10200 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10280 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x02C00 >> 2, 0x00000000, 256, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10300 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10380 >> 2, 0x00321000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10400 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
@@ -704,7 +712,6 @@ _InitializeContextBuffer(
     /* Store the index of the "XD" entry. */
     Context->entryOffsetXDFrom3D = index * gcmSIZEOF(gctUINT32);
 
-    index += _FlushPipe(Context, index, gcvPIPE_3D);
 
     /* Pixel Engine states. */
     index += _State(Context, index, 0x01400 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
@@ -729,6 +736,7 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x014B4 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x014A4 >> 2, 0x000E400C, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01580 >> 2, 0x00000000, 3, gcvFALSE, gcvFALSE);
+    index += _State(Context, index, 0x014B8 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
     /* Composition states. */
     index += _State(Context, index, 0x03008 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
@@ -895,13 +903,25 @@ _DestroyContext(
             /* Free state delta map. */
             if (buffer->logical != gcvNULL)
             {
-                gcmkONERROR(gckOS_FreeContiguous(
-                    Context->os,
+#if gcdVIRTUAL_COMMAND_BUFFER
+                gcmkONERROR(gckEVENT_DestroyVirtualCommandBuffer(
+                    Context->hardware->kernel->eventObj,
+                    Context->totalSize,
                     buffer->physical,
                     buffer->logical,
-                    Context->totalSize
+                    gcvKERNEL_PIXEL
                     ));
 
+#else
+                gcmkONERROR(gckEVENT_FreeContiguousMemory(
+                    Context->hardware->kernel->eventObj,
+                    Context->totalSize,
+                    buffer->physical,
+                    buffer->logical,
+                    gcvKERNEL_PIXEL
+                    ));
+#endif
+
                 buffer->logical = gcvNULL;
             }
 
@@ -1138,6 +1158,16 @@ gckCONTEXT_Construct(
             ));
 
         /* Create a new physical context buffer. */
+#if gcdVIRTUAL_COMMAND_BUFFER
+        gcmkONERROR(gckKERNEL_AllocateVirtualCommandBuffer(
+            context->hardware->kernel,
+            gcvFALSE,
+            &context->totalSize,
+            &buffer->physical,
+            &pointer
+            ));
+
+#else
         gcmkONERROR(gckOS_AllocateContiguous(
             Os,
             gcvFALSE,
@@ -1145,6 +1175,7 @@ gckCONTEXT_Construct(
             &buffer->physical,
             &pointer
             ));
+#endif
 
         buffer->logical = pointer;
 
@@ -1223,11 +1254,11 @@ gckCONTEXT_Construct(
             }
 
             /* Copy the current context. */
-            gcmkONERROR(gckOS_MemCopy(
+            gckOS_MemCopy(
                 tempContext->logical,
                 currContext->logical,
                 context->totalSize
-                ));
+                );
 
             /* Get the next context buffer. */
             tempContext = tempContext->next;
@@ -1408,7 +1439,7 @@ gckCONTEXT_Update(
             gcmkONERROR(gckKERNEL_OpenUserData(
                 kernel, needCopy,
                 Context->recordArray,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1517,13 +1548,13 @@ gckCONTEXT_Update(
             gcmkASSERT(kDelta->refCount >= 0);
 
             /* Get the next state delta. */
-            nDelta = kDelta->next;
+            nDelta = gcmUINT64_TO_PTR(kDelta->next);
 
             /* Get access to the state records. */
             gcmkONERROR(gckKERNEL_CloseUserData(
                 kernel, needCopy,
                 gcvFALSE,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1670,7 +1701,7 @@ OnError:
         gcmkVERIFY_OK(gckKERNEL_CloseUserData(
             kernel, needCopy,
             gcvFALSE,
-            kDelta->recordArray, Context->recordArraySize,
+            gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
             (gctPOINTER *) &recordArray
             ));
 	}
@@ -1690,3 +1721,4 @@ OnError:
     return gcvSTATUS_OK;
 #endif
 }
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
index df37b2f..7554045 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #ifndef __gc_hal_kernel_context_h_
 #define __gc_hal_kernel_context_h_
 
@@ -139,3 +141,4 @@ struct _gckCONTEXT
 #endif
 
 #endif /* __gc_hal_kernel_context_h_ */
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
index c5e5b22..a87259e 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,11 +17,25 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_HARDWARE
 
+typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
+typedef struct _gcsiDEBUG_REGISTERS
+{
+    gctSTRING       module;
+    gctUINT         index;
+    gctUINT         shift;
+    gctUINT         data;
+    gctUINT         count;
+    gctUINT32       signature;
+}
+gcsiDEBUG_REGISTERS;
+
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -53,6 +67,7 @@ _IdentifyHardware(
     gctUINT32 instructionCount = 0;
     gctUINT32 numConstants = 0;
     gctUINT32 bufferSize = 0;
+    gctUINT32 varyingsCount = 0;
 
     gcmkHEADER_ARG("Os=0x%x", Os);
 
@@ -201,17 +216,53 @@ _IdentifyHardware(
         }
     }
 
+    /* Get the Supertile layout in the hardware. */
+    if (((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))))
+     || ((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))))
+    {
+        Identity->superTileMode = 2;
+    }
+    else if (((((gctUINT32) (Identity->chipMinorFeatures)) >> (0 ? 27:27) & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))))
+    {
+        Identity->superTileMode = 1;
+    }
+    else
+    {
+        Identity->superTileMode = 0;
+    }
+
+    /* Exception for GC1000, revision 5035 &  GC800, revision 4612 */
+    if (((Identity->chipModel == gcv1000) && (Identity->chipRevision == 0x5035))
+	 || ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4612)))
+    {
+        Identity->superTileMode = 1;
+    }
+
+
+
 	/* Disable HZ when EZ is present for older chips. */
-    if (!((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))))
-        &&
-        !((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))))
-        )
+	if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
     {
         /* Disable HIERARCHICAL_Z. */
         Identity->chipMinorFeatures
             = ((((gctUINT32) (Identity->chipMinorFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) << (0 ? 27:27))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) << (0 ? 27:27)));
     }
 
+    /* Disable rectangle primitive when chip is gc880_5_1_0_rc6*/
+    if ((Identity->chipModel == gcv880) && (Identity->chipRevision == 0x5106))
+    {
+        /* Disable rectangle primitive. */
+        Identity->chipMinorFeatures2
+            = ((((gctUINT32) (Identity->chipMinorFeatures2)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
+    }
+
+    if ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4605))
+    {
+        /* Correct feature bit: RTL does not have such feature. */
+        Identity->chipFeatures
+            = ((((gctUINT32) (Identity->chipFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)));
+    }
+
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                    "Identity: chipFeatures=0x%08X",
                    Identity->chipFeatures);
@@ -238,7 +289,7 @@ _IdentifyHardware(
 
     if (((((gctUINT32) (Identity->chipMinorFeatures)) >> (0 ? 21:21) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))))
     {
-        gctUINT32 specs, specs2;
+        gctUINT32 specs, specs2, specs3;
 
         /* Read gcChipSpecs register. */
         gcmkONERROR(
@@ -264,6 +315,14 @@ _IdentifyHardware(
         instructionCount       = (((((gctUINT32) (specs2)) >> (0 ? 15:8)) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1)))))) );
         numConstants           = (((((gctUINT32) (specs2)) >> (0 ? 31:16)) & ((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1)))))) );
         bufferSize             = (((((gctUINT32) (specs2)) >> (0 ? 7:0)) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1)))))) );
+
+        /* Read gcChipSpecs3 register. */
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Os, Core,
+                                 0x0008C,
+                                 &specs3));
+
+        varyingsCount          = (((((gctUINT32) (specs3)) >> (0 ? 8:4)) & ((gctUINT32) ((((1 ? 8:4) - (0 ? 8:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:4) - (0 ? 8:4) + 1)))))) );
     }
 
     /* Get the number of pixel pipes. */
@@ -343,9 +402,19 @@ _IdentifyHardware(
     Identity->instructionCount = (instructionCount == 0) ? 256
                                : (instructionCount == 1) ? 1024
                                : (instructionCount == 2) ? 2048
+                               : (instructionCount == 0xFF) ? 512
                                : 256;
 
-    if (Identity->chipModel == gcv2000 && Identity->chipRevision == 0x5108)
+    if (Identity->instructionCount == 256)
+    {
+        if ((Identity->chipModel == gcv2000 && Identity->chipRevision == 0x5108)
+        ||  Identity->chipModel == gcv880)
+        {
+            Identity->instructionCount = 512;
+        }
+    }
+
+    if (((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 3:3) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))))
     {
         Identity->instructionCount = 512;
     }
@@ -356,7 +425,7 @@ _IdentifyHardware(
                    (instructionCount == 0) ? " (default)" : "");
 
     /* Get the number of constants. */
-    Identity->numConstants = numConstants;
+    Identity->numConstants = (numConstants == 0) ? 168 : numConstants;
 
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                    "Specs: numConstants=%u%s",
@@ -371,6 +440,22 @@ _IdentifyHardware(
                    Identity->bufferSize,
                    (bufferSize == 0) ? " (default)" : "");
 
+
+     if (varyingsCount != 0)
+     {
+         /* Bug 4480. */
+         /*Identity->varyingsCount = varyingsCount;*/
+         Identity->varyingsCount = 12;
+     }
+     else if (((((gctUINT32) (Identity->chipMinorFeatures1)) >> (0 ? 23:23) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))))
+     {
+         Identity->varyingsCount = 12;
+     }
+     else
+     {
+         Identity->varyingsCount = 8;
+     }
+
     /* Success. */
     gcmkFOOTER();
     return gcvSTATUS_OK;
@@ -381,6 +466,171 @@ OnError:
     return status;
 }
 
+#if gcdPOWEROFF_TIMEOUT
+void
+_PowerTimerFunction(
+    gctPOINTER Data
+    )
+{
+    gckHARDWARE hardware = (gckHARDWARE)Data;
+    gcmkVERIFY_OK(
+        gckHARDWARE_SetPowerManagementState(hardware, gcvPOWER_OFF_TIMEOUT));
+}
+#endif
+
+static gceSTATUS
+_VerifyDMA(
+    IN gckOS Os,
+    IN gceCORE Core,
+    gctUINT32_PTR Address1,
+    gctUINT32_PTR Address2,
+    gctUINT32_PTR State1,
+    gctUINT32_PTR State2
+    )
+{
+    gceSTATUS status;
+    gctUINT32 i;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
+
+        if (*Address1 != *Address2)
+        {
+            break;
+        }
+
+        if (*State1 != *State2)
+        {
+            break;
+        }
+    }
+
+OnError:
+    return status;
+}
+
+static gceSTATUS
+_DumpDebugRegisters(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gcsiDEBUG_REGISTERS_PTR Descriptor
+    )
+{
+    gceSTATUS status;
+    gctUINT32 select;
+    gctUINT32 data;
+    gctUINT i;
+
+    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
+
+    gcmkPRINT_N(4, "    %s debug registers:\n", Descriptor->module);
+
+    for (i = 0; i < Descriptor->count; i += 1)
+    {
+        select = i << Descriptor->shift;
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        gcmkPRINT_N(12, "      [0x%02X] 0x%08X\n", i, data);
+    }
+
+    select = 0xF << Descriptor->shift;
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        if (data == Descriptor->signature)
+        {
+            break;
+        }
+    }
+
+    if (i == 500)
+    {
+        gcmkPRINT_N(4, "      failed to obtain the signature (read 0x%08X).\n", data);
+    }
+    else
+    {
+        gcmkPRINT_N(8, "      signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
+    }
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
+#if gcdPOWER_MANAGEMENT
+static gceSTATUS
+_IsGPUPresent(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gcsHAL_QUERY_CHIP_IDENTITY identity;
+    gctUINT32 control;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &control));
+
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      control));
+
+    /* Identify the hardware. */
+    gcmkONERROR(_IdentifyHardware(Hardware->os,
+                                  Hardware->core,
+                                  &identity));
+
+    /* Check if these are the same values as saved before. */
+    if ((Hardware->identity.chipModel          != identity.chipModel)
+    ||  (Hardware->identity.chipRevision       != identity.chipRevision)
+    ||  (Hardware->identity.chipFeatures       != identity.chipFeatures)
+    ||  (Hardware->identity.chipMinorFeatures  != identity.chipMinorFeatures)
+    ||  (Hardware->identity.chipMinorFeatures1 != identity.chipMinorFeatures1)
+    ||  (Hardware->identity.chipMinorFeatures2 != identity.chipMinorFeatures2)
+    )
+    {
+        gcmkPRINT("[galcore]: GPU is not present.");
+        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
+    }
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
 /******************************************************************************\
 ****************************** gckHARDWARE API code *****************************
 \******************************************************************************/
@@ -426,7 +676,10 @@ gckHARDWARE_Construct(
 
     /* Enable the GPU. */
     gcmkONERROR(gckOS_SetGPUPower(Os, Core, gcvTRUE, gcvTRUE));
-    gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, 0x00000, 0));
+    gcmkONERROR(gckOS_WriteRegisterEx(Os,
+                                      Core,
+                                      0x00000,
+                                      0x00000900));
 
     /* Allocate the gckHARDWARE object. */
     gcmkONERROR(gckOS_Allocate(Os,
@@ -498,7 +751,7 @@ gckHARDWARE_Construct(
     /* Initialize the fast clear. */
     gcmkONERROR(gckHARDWARE_SetFastClear(hardware, -1, -1));
 
-#if !gcdENABLE_128B_MERGE && 1 && 1
+#if !gcdENABLE_128B_MERGE  
 
     if (((((gctUINT32) (hardware->identity.chipMinorFeatures2)) >> (0 ? 21:21) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))))
     {
@@ -514,17 +767,32 @@ gckHARDWARE_Construct(
     hardware->powerState      = gcvTRUE;
     hardware->lastWaitLink    = ~0U;
     hardware->globalSemaphore = gcvNULL;
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    hardware->powerOnFscaleVal = 64;
+#endif
 
     gcmkONERROR(gckOS_CreateMutex(Os, &hardware->powerMutex));
     gcmkONERROR(gckOS_CreateSemaphore(Os, &hardware->globalSemaphore));
+    hardware->startIsr = gcvNULL;
+    hardware->stopIsr = gcvNULL;
 
 #if gcdPOWEROFF_TIMEOUT
-    gcmkONERROR(gckOS_CreateSignal(Os, gcvFALSE, &hardware->powerOffSignal));
     hardware->powerOffTimeout = gcdPOWEROFF_TIMEOUT;
+
+    gcmkVERIFY_OK(gckOS_CreateTimer(Os,
+                                    _PowerTimerFunction,
+                                    (gctPOINTER)hardware,
+                                    &hardware->powerOffTimer));
 #endif
 
     gcmkONERROR(gckOS_AtomConstruct(Os, &hardware->pageTableDirty));
 
+#if gcdLINK_QUEUE_SIZE
+    hardware->linkQueue.front = 0;
+    hardware->linkQueue.rear = 0;
+    hardware->linkQueue.count = 0;
+#endif
+
     /* Return pointer to the gckHARDWARE object. */
     *Hardware = hardware;
 
@@ -537,7 +805,7 @@ OnError:
     if (hardware != gcvNULL)
     {
         /* Turn off the power. */
-        gcmkVERIFY_OK(gckOS_SetGPUPower(Os, hardware->core, gcvFALSE, gcvFALSE));
+        gcmkVERIFY_OK(gckOS_SetGPUPower(Os, Core, gcvFALSE, gcvFALSE));
 
         if (hardware->globalSemaphore != gcvNULL)
         {
@@ -553,9 +821,10 @@ OnError:
         }
 
 #if gcdPOWEROFF_TIMEOUT
-        if (hardware->powerOffSignal != gcvNULL)
+        if (hardware->powerOffTimer != gcvNULL)
         {
-            gcmkVERIFY_OK(gckOS_DestroySignal(Os, hardware->powerOffSignal));
+            gcmkVERIFY_OK(gckOS_StopTimer(Os, hardware->powerOffTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, hardware->powerOffTimer));
         }
 #endif
 
@@ -607,7 +876,8 @@ gckHARDWARE_Destroy(
     gcmkVERIFY_OK(gckOS_DeleteMutex(Hardware->os, Hardware->powerMutex));
 
 #if gcdPOWEROFF_TIMEOUT
-    gcmkVERIFY_OK(gckOS_DestroySignal(Hardware->os, Hardware->powerOffSignal));
+    gcmkVERIFY_OK(gckOS_StopTimer(Hardware->os, Hardware->powerOffTimer));
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Hardware->os, Hardware->powerOffTimer));
 #endif
 
     gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pageTableDirty));
@@ -681,6 +951,7 @@ gckHARDWARE_InitializeHardware(
     gceSTATUS status;
     gctUINT32 baseAddress;
     gctUINT32 chipRev;
+    gctUINT32 control;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
@@ -703,7 +974,18 @@ gckHARDWARE_InitializeHardware(
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
                                       Hardware->core,
                                       0x00000,
-                                      ((((gctUINT32) (0x00000100)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)))));
+                                      ((((gctUINT32) (0x00000900)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)))));
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &control));
+
+    /* Enable debug register. */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:11) - (0 ? 11:11) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:11) - (0 ? 11:11) + 1))))))) << (0 ? 11:11))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:11) - (0 ? 11:11) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:11) - (0 ? 11:11) + 1))))))) << (0 ? 11:11)))));
 
     /* Reset memory counters. */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
@@ -745,7 +1027,7 @@ gckHARDWARE_InitializeHardware(
                                       0x00424,
                                       baseAddress));
 
-#if !VIVANTE_PROFILER && 1
+#if !VIVANTE_PROFILER 
     {
         gctUINT32 data;
 
@@ -853,6 +1135,88 @@ gckHARDWARE_InitializeHardware(
         }
     }
 
+    if (Hardware->identity.chipModel >= gcv400
+    &&  Hardware->identity.chipModel != gcv420)
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 Hardware->powerBaseAddress
+                                 + 0x00104,
+                                 &data));
+
+        /* Disable PA clock gating. */
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
+
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  Hardware->powerBaseAddress
+                                  + 0x00104,
+                                  data));
+    }
+
+#if gcdHZ_L2_DISALBE
+    /* Disable HZ-L2. */
+    if (((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) == gcvTRUE ||
+            ((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))) == gcvTRUE)
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 0x00414,
+                                 &data));
+
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)));
+
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  0x00414,
+                                  data));
+    }
+#endif
+
+    /* Limit 2D outstanding request. */
+    if ((Hardware->identity.chipModel == gcv320)
+        && ((Hardware->identity.chipRevision == 0x5007)
+        || (Hardware->identity.chipRevision == 0x5220)))
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 0x0002C,
+                                 &data));
+        if (data != 33956864)
+        {
+            gcmkONERROR(
+                gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00414,
+                                     &data));
+
+            data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (Hardware->identity.chipRevision == 0x5220 ? 8 : (Hardware->identity.chipRevision == 0x5007 ? 16 : 0)) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)));
+
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00414,
+                                      data));
+        }
+    }
+
+    /* Update GPU AXI cache atttribute. */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00008,
+                                      0x00002200));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -1050,6 +1414,8 @@ gckHARDWARE_QueryChipIdentity(
     Identity->instructionCount       = Hardware->identity.instructionCount;
     Identity->numConstants           = Hardware->identity.numConstants;
     Identity->bufferSize             = Hardware->identity.bufferSize;
+    Identity->varyingsCount          = Hardware->identity.varyingsCount;
+    Identity->superTileMode          = Hardware->identity.superTileMode;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1093,27 +1459,35 @@ gckHARDWARE_SplitMemory(
     gcmkVERIFY_ARGUMENT(Pool != gcvNULL);
     gcmkVERIFY_ARGUMENT(Offset != gcvNULL);
 
-    /* Dispatch on memory type. */
-    switch ((((((gctUINT32) (Address)) >> (0 ? 31:31)) & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1)))))) ))
+    if (Hardware->mmuVersion == 0)
     {
-    case 0x0:
-        /* System memory. */
-        *Pool = gcvPOOL_SYSTEM;
-        break;
+        /* Dispatch on memory type. */
+        switch ((((((gctUINT32) (Address)) >> (0 ? 31:31)) & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1)))))) ))
+        {
+        case 0x0:
+            /* System memory. */
+            *Pool = gcvPOOL_SYSTEM;
+            break;
 
-    case 0x1:
-        /* Virtual memory. */
-        *Pool = gcvPOOL_VIRTUAL;
-        break;
+        case 0x1:
+            /* Virtual memory. */
+            *Pool = gcvPOOL_VIRTUAL;
+            break;
 
-    default:
-        /* Invalid memory type. */
-        gcmkFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
-        return gcvSTATUS_INVALID_ARGUMENT;
-    }
+        default:
+            /* Invalid memory type. */
+            gcmkFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
+            return gcvSTATUS_INVALID_ARGUMENT;
+        }
 
-    /* Return offset of address. */
-    *Offset = (((((gctUINT32) (Address)) >> (0 ? 30:0)) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1)))))) );
+        /* Return offset of address. */
+        *Offset = (((((gctUINT32) (Address)) >> (0 ? 30:0)) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1)))))) );
+    }
+    else
+    {
+        *Pool = gcvPOOL_SYSTEM;
+        *Offset = Address;
+    }
 
     /* Success. */
     gcmkFOOTER_ARG("*Pool=%d *Offset=0x%08x", *Pool, *Offset);
@@ -1323,9 +1697,7 @@ gckHARDWARE_WaitLink(
 
         /* Send FE-PE stall token. */
         logical[4]
-            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
-            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0F00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
         logical[5]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
@@ -2045,7 +2417,7 @@ gckHARDWARE_Link(
 
         /* Append LINK(bytes / 8), FetchAddress. */
         link = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x08 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (bytes >> 3) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (bytes >> 3) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
         gcmkONERROR(
             gckOS_WriteMemory(Hardware->os, logical, link));
@@ -2053,6 +2425,13 @@ gckHARDWARE_Link(
         /* Memory barrier. */
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical));
+
+#if gcdLINK_QUEUE_SIZE && gcdVIRTUAL_COMMAND_BUFFER
+        if (address >= 0x80000000)
+        {
+            gckLINKQUEUE_Enqueue(&Hardware->linkQueue, address, address + bytes);
+        }
+#endif
     }
 
     if (Bytes != gcvNULL)
@@ -2162,6 +2541,7 @@ gckHARDWARE_ConvertLogical(
 {
     gctUINT32 address;
     gceSTATUS status;
+    gctUINT32 baseAddress;
 
     gcmkHEADER_ARG("Hardware=0x%x Logical=0x%x", Hardware, Logical);
 
@@ -2170,15 +2550,32 @@ gckHARDWARE_ConvertLogical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
-    /* Convert logical address into a physical address. */
-    gcmkONERROR(
-        gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
+#if gcdVIRTUAL_COMMAND_BUFFER
+    status = gckKERNEL_GetGPUAddress(Hardware->kernel, Logical, Address);
 
-    /* Return hardware specific address. */
-    *Address = (Hardware->mmuVersion == 0)
-             ? ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
-               | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0))) | (((gctUINT32) ((gctUINT32) (address) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0)))
-             : address;
+    if (status == gcvSTATUS_INVALID_ADDRESS)
+#endif
+    {
+        /* Convert logical address into a physical address. */
+        gcmkONERROR(
+            gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
+
+        /* For old MMU, get GPU address according to baseAddress. */
+        if (Hardware->mmuVersion == 0)
+        {
+            gcmkONERROR(gckOS_GetBaseAddress(Hardware->os, &baseAddress));
+
+            /* Subtract base address to get a GPU address. */
+            gcmkASSERT(address >= baseAddress);
+            address -= baseAddress;
+        }
+
+        /* Return hardware specific address. */
+        *Address = (Hardware->mmuVersion == 0)
+                 ? ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
+                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0))) | (((gctUINT32) ((gctUINT32) (address) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0)))
+                 : address;
+    }
 
     /* Success. */
     gcmkFOOTER_ARG("*Address=0x%08x", *Address);
@@ -2219,6 +2616,7 @@ gckHARDWARE_ConvertPhysical(
     )
 {
     gctUINT32 address;
+    gctUINT32 baseAddress;
 
     gcmkHEADER_ARG("Hardware=0x%x Physical=0x%x", Hardware, Physical);
 
@@ -2229,6 +2627,16 @@ gckHARDWARE_ConvertPhysical(
 
     address = gcmPTR2INT(Physical);
 
+    /* For old MMU, get GPU address according to baseAddress. */
+    if (Hardware->mmuVersion == 0)
+    {
+        gcmkVERIFY_OK(gckOS_GetBaseAddress(Hardware->os, &baseAddress));
+
+        /* Subtract base address to get a GPU address. */
+        gcmkASSERT(address >= baseAddress);
+        address -= baseAddress;
+    }
+
     /* Return hardware specific address. */
     *Address = (Hardware->mmuVersion == 0)
              ? ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
@@ -2290,12 +2698,7 @@ gckHARDWARE_Interrupt(
                                  0x00010,
                                  &data));
 
-        if (data & 0x80000000)
-        {
-            gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE, "AXI BUS ERROR");
-        }
-
-        if (data == 0)
+        if (data == 0)
         {
             /* Not our interrupt. */
             status = gcvSTATUS_NOT_OUR_INTERRUPT;
@@ -2303,7 +2706,7 @@ gckHARDWARE_Interrupt(
         else
         {
             /* Inform gckEVENT of the interrupt. */
-            status = gckEVENT_Interrupt(eventObj, data & 0x7FFFFFFF);
+            status = gckEVENT_Interrupt(eventObj, data);
         }
     }
     else
@@ -2431,7 +2834,7 @@ gckHARDWARE_QuerySystemMemory(
     return gcvSTATUS_OK;
 }
 
-#if !defined(VIVANTE_NO_3D)
+#ifndef VIVANTE_NO_3D
 /*******************************************************************************
 **
 **  gckHARDWARE_QueryShaderCaps
@@ -2497,14 +2900,7 @@ gckHARDWARE_QueryShaderCaps(
     if (Varyings != gcvNULL)
     {
 		/* Return the shader varyings count. */
-        if (((((gctUINT32) (Hardware->identity.chipMinorFeatures1)) >> (0 ? 23:23) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))))
-        {
-		    *Varyings = 12;
-        }
-        else
-        {
-		    *Varyings = 8;
-        }
+        *Varyings = Hardware->identity.varyingsCount;
     }
 
     /* Success. */
@@ -2663,10 +3059,10 @@ gckHARDWARE_FlushMMU(
 
         buffer[1]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
-              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
-              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
-              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
-              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
 
         gcmkONERROR(gckCOMMAND_Execute(command, 8));
     }
@@ -2674,9 +3070,9 @@ gckHARDWARE_FlushMMU(
     {
         flushSize =  16 * 4;
 
-    gcmkONERROR(gckCOMMAND_Reserve(
+        gcmkONERROR(gckCOMMAND_Reserve(
             command, flushSize, &pointer, &bufferSize
-        ));
+            ));
 
         buffer = (gctUINT32_PTR) pointer;
 
@@ -2685,8 +3081,8 @@ gckHARDWARE_FlushMMU(
         gcmkONERROR(gckOS_GetPhysicalAddress(command->os, buffer, &physical));
 
         /* Flush cache. */
-    buffer[0]
-        = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+        buffer[0]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
@@ -2728,7 +3124,7 @@ gckHARDWARE_FlushMMU(
         buffer[8]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0061) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-        | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
         buffer[9]
             = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) );
@@ -2815,6 +3211,7 @@ gckHARDWARE_SetMMUv2(
     gctSIZE_T bufferSize;
     gctBOOL commitEntered = gcvFALSE;
     gctPOINTER pointer = gcvNULL;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Hardware=0x%x Enable=%d", Hardware, Enable);
 
@@ -2891,6 +3288,17 @@ gckHARDWARE_SetMMUv2(
 
     gcmkONERROR(gckCOMMAND_Execute(command, 16));
 
+    if (FromPower == gcvFALSE)
+    {
+        /* Acquire global semaphore to suspend power management until MMU
+        ** is enabled. And acquired it before gckCOMMAND_ExitCommit to
+        ** make sure GPU keeps ON. */
+        gcmkONERROR(
+            gckOS_AcquireSemaphore(Hardware->os, Hardware->globalSemaphore));
+
+        acquired = gcvTRUE;
+    }
+
     /* Release the command queue. */
     gcmkONERROR(gckCOMMAND_ExitCommit(command, FromPower));
     commitEntered = gcvFALSE;
@@ -2910,6 +3318,15 @@ gckHARDWARE_SetMMUv2(
                               0x0018C,
                               ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (Enable) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))));
 
+    if (FromPower == gcvFALSE)
+    {
+        /* Relase global semaphore. */
+        gcmkVERIFY_OK(
+            gckOS_ReleaseSemaphore(Hardware->os, Hardware->globalSemaphore));
+
+        acquired = gcvFALSE;
+    }
+
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
         "call gckCOMMAND_Stall to check MMU available.\n");
 
@@ -2927,7 +3344,13 @@ OnError:
     {
         /* Release the command queue mutex. */
         gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Hardware->kernel->command,
-                                            gcvFALSE));
+                                            FromPower));
+    }
+
+    if (acquired)
+    {
+        gcmkVERIFY_OK(
+            gckOS_ReleaseSemaphore(Hardware->os, Hardware->globalSemaphore));
     }
 
     /* Return the status. */
@@ -3183,8 +3606,13 @@ gckHARDWARE_SetFastClear(
         /* Set fast clear bypass. */
         debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (Enable == 0) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
 
-        /* Set compression bypass. */
-        debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression == 0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
+        if (
+            ((((gctUINT32) (Hardware->identity.chipMinorFeatures2)) >> (0 ? 27:27) & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) ||
+            (Hardware->identity.chipModel >= gcv4000))
+        {
+            /* Set compression bypass. */
+            debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression == 0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
+        }
 
         /* Write back AQMemoryDebug register. */
         gcmkONERROR(
@@ -3201,25 +3629,6 @@ gckHARDWARE_SetFastClear(
                        "FastClear=%d Compression=%d", Enable, Compression);
     }
 
-    /* Special patch for 0x320 0x5220. */
-    if (Hardware->identity.chipRevision == 0x5220 && Hardware->identity.chipModel == gcv320)
-    {
-        gctUINT32 debug;
-
-        /* Read AQMemoryDebug register. */
-        gcmkONERROR(
-                gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00414, &debug));
-
-        debug |= 8;
-
-        /* Write back AQMemoryDebug register. */
-        gcmkONERROR(
-                gckOS_WriteRegisterEx(Hardware->os,
-                    Hardware->core,
-                    0x00414,
-                    debug));
-    }
-
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -3316,12 +3725,16 @@ gckHARDWARE_SetPowerManagementState(
 #endif
     gctUINT32 process, thread;
     gctBOOL commitEntered = gcvFALSE;
+    gctBOOL commandStarted = gcvFALSE;
+    gctBOOL isrStarted = gcvFALSE;
+
 #if gcdENABLE_PROFILING
     gctUINT64 time, freq, mutexTime, onTime, stallTime, stopTime, delayTime,
               initTime, offTime, startTime, totalTime;
 #endif
     gctBOOL global = gcvFALSE;
     gctBOOL globalAcquired = gcvFALSE;
+    gctBOOL configMmu = gcvFALSE;
 
     /* State transition flags. */
     static const gctUINT flags[4][4] =
@@ -3516,9 +3929,9 @@ gckHARDWARE_SetPowerManagementState(
                 gcmkFOOTER_NO();
                 return gcvSTATUS_OK;
             }
-            else if (State == gcvPOWER_IDLE)
+            else if (State == gcvPOWER_IDLE || State == gcvPOWER_SUSPEND)
             {
-                /* gcvPOWER_IDLE_BROADCAST is from IST,
+                /* Called from IST,
                 ** so waiting here will cause deadlock,
                 ** if lock holder call gckCOMMAND_Stall() */
                 gcmkONERROR(gcvSTATUS_INVALID_REQUEST);
@@ -3549,6 +3962,32 @@ gckHARDWARE_SetPowerManagementState(
     flag  = flags[Hardware->chipPowerState][State];
     clock = clocks[State];
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    if (State == gcvPOWER_ON)
+    {
+        clock = ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (Hardware->powerOnFscaleVal) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)));
+    }
+#endif
+
+    if (State == gcvPOWER_SUSPEND && Hardware->chipPowerState == gcvPOWER_OFF && broadcast)
+    {
+#if gcdPOWER_SUSNPEND_WHEN_IDLE
+	/* Do nothing */
+
+    	/* Release the power mutex. */
+        gcmkONERROR(gckOS_ReleaseMutex(os, Hardware->powerMutex));
+
+       	gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+#else
+	/* Clock should be on when switch power from off to suspend */
+        clock = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) |
+                ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) |
+                ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) |
+                ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) ;
+#endif
+    }
+
 #if gcdPOWEROFF_TIMEOUT
     if (timeout)
     {
@@ -3557,7 +3996,12 @@ gckHARDWARE_SetPowerManagementState(
         gcmkONERROR(
             gckOS_TicksAfter(Hardware->powerOffTime, currentTime, &isAfter));
 
-        if (isAfter || Hardware->chipPowerState != gcvPOWER_IDLE)
+        /* powerOffTime is pushed forward, give up.*/
+        if (isAfter
+        /* Expect a transition start from IDLE or SUSPEND. */
+        ||  (Hardware->chipPowerState == gcvPOWER_ON)
+        ||  (Hardware->chipPowerState == gcvPOWER_OFF)
+        )
         {
             /* Release the power mutex. */
             gcmkONERROR(gckOS_ReleaseMutex(os, Hardware->powerMutex));
@@ -3568,8 +4012,8 @@ gckHARDWARE_SetPowerManagementState(
         }
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-                       "Power Off GPU at %i [supposed to be at %i]",
-                       currentTime, Hardware->powerOffTime);
+                       "Power Off GPU[%d] at %u [supposed to be at %u]",
+                       Hardware->core, currentTime, Hardware->powerOffTime);
     }
 #endif
 
@@ -3592,7 +4036,7 @@ gckHARDWARE_SetPowerManagementState(
         status = gckOS_TryAcquireSemaphore(os, Hardware->globalSemaphore);
         if (status == gcvSTATUS_TIMEOUT)
         {
-            if (State == gcvPOWER_IDLE)
+            if (State == gcvPOWER_IDLE || State == gcvPOWER_SUSPEND)
             {
                 /* Called from thread routine which should NEVER sleep.*/
                 gcmkONERROR(gcvSTATUS_INVALID_REQUEST);
@@ -3687,6 +4131,43 @@ gckHARDWARE_SetPowerManagementState(
         /* Mark clock and power as enabled. */
         Hardware->clockState = gcvTRUE;
         Hardware->powerState = gcvTRUE;
+
+        for (;;)
+        {
+            /* Check if GPU is present and awake. */
+            status = _IsGPUPresent(Hardware);
+
+            /* Check if the GPU is not responding. */
+            if (status == gcvSTATUS_GPU_NOT_RESPONDING)
+            {
+                /* Turn off the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvFALSE, gcvFALSE));
+
+                Hardware->clockState = gcvFALSE;
+                Hardware->powerState = gcvFALSE;
+
+                /* Wait a little. */
+                gckOS_Delay(os, 1);
+
+                /* Turn on the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvTRUE, gcvTRUE));
+
+                Hardware->clockState = gcvTRUE;
+                Hardware->powerState = gcvTRUE;
+
+                /* We need to initialize the hardware and start the command
+                 * processor. */
+                flag |= gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_START;
+            }
+            else
+            {
+                /* Test for error. */
+                gcmkONERROR(status);
+
+                /* Break out of loop. */
+                break;
+            }
+        }
     }
 
     /* Get time until powered on. */
@@ -3776,14 +4257,20 @@ gckHARDWARE_SetPowerManagementState(
         gcmkONERROR(gckCOMMAND_Stop(command, gcvFALSE));
 
         /* Stop the Isr. */
-        gcmkONERROR(Hardware->stopIsr(Hardware->isrContext));
+        if (Hardware->stopIsr)
+        {
+            gcmkONERROR(Hardware->stopIsr(Hardware->isrContext));
+        }
     }
 
     /* Get time until stopped. */
     gcmkPROFILE_QUERY(time, stopTime);
 
     /* Only process this when hardware is enabled. */
-    if (Hardware->clockState && Hardware->powerState)
+    if (Hardware->clockState && Hardware->powerState
+    /* Don't touch clock control if dynamic frequency scaling is available. */
+    && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_DYNAMIC_FREQUENCY_SCALING) != gcvTRUE
+    )
     {
         if (flag & (gcvPOWER_FLAG_POWER_OFF | gcvPOWER_FLAG_CLOCK_OFF))
         {
@@ -3828,6 +4315,9 @@ gckHARDWARE_SetPowerManagementState(
 
         /* Force the command queue to reload the next context. */
         command->currContext = gcvNULL;
+
+        /* Need to config mmu after command start. */
+        configMmu = gcvTRUE;
     }
 
     /* Get time until initialized. */
@@ -3858,12 +4348,17 @@ gckHARDWARE_SetPowerManagementState(
     {
         /* Start the command processor. */
         gcmkONERROR(gckCOMMAND_Start(command));
+        commandStarted = gcvTRUE;
 
-        /* Start the Isr. */
-        gcmkONERROR(Hardware->startIsr(Hardware->isrContext));
+        if (Hardware->startIsr)
+        {
+            /* Start the Isr. */
+            gcmkONERROR(Hardware->startIsr(Hardware->isrContext));
+            isrStarted = gcvTRUE;
+        }
 
         /* Set NEW MMU. */
-        if (Hardware->mmuVersion != 0)
+        if (Hardware->mmuVersion != 0 && configMmu)
         {
             gcmkONERROR(
                     gckHARDWARE_SetMMUv2(
@@ -3909,15 +4404,32 @@ gckHARDWARE_SetPowerManagementState(
     /* Save the new power state. */
     Hardware->chipPowerState = State;
 
+#if gcdDVFS
+    if (State == gcvPOWER_ON && Hardware->kernel->dvfs)
+    {
+        gckDVFS_Start(Hardware->kernel->dvfs);
+    }
+#endif
+
 #if gcdPOWEROFF_TIMEOUT
     /* Reset power off time */
     gcmkONERROR(gckOS_GetTicks(&currentTime));
 
     Hardware->powerOffTime = currentTime + Hardware->powerOffTimeout;
 
-    if (State == gcvPOWER_IDLE)
+    if (State == gcvPOWER_IDLE || State == gcvPOWER_SUSPEND)
     {
-        gcmkONERROR(gckOS_Signal(os, Hardware->powerOffSignal, gcvTRUE));
+        /* Start a timer to power off GPU when GPU enters IDLE or SUSPEND. */
+        gcmkVERIFY_OK(gckOS_StartTimer(os,
+                                       Hardware->powerOffTimer,
+                                       Hardware->powerOffTimeout));
+    }
+    else
+    {
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE, "Cancel powerOfftimer");
+
+        /* Cancel running timer when GPU enters ON or OFF. */
+        gcmkVERIFY_OK(gckOS_StopTimer(os, Hardware->powerOffTimer));
     }
 #endif
 
@@ -3940,6 +4452,16 @@ gckHARDWARE_SetPowerManagementState(
     return gcvSTATUS_OK;
 
 OnError:
+    if (commandStarted)
+    {
+        gcmkVERIFY_OK(gckCOMMAND_Stop(command, gcvFALSE));
+    }
+
+    if (isrStarted)
+    {
+        gcmkVERIFY_OK(Hardware->stopIsr(Hardware->isrContext));
+    }
+
     if (commitEntered)
     {
         /* Release the command queue mutex. */
@@ -4008,6 +4530,113 @@ gckHARDWARE_QueryPowerManagementState(
     return gcvSTATUS_OK;
 }
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+gceSTATUS
+gckHARDWARE_SetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32   FscaleValue
+    )
+{
+    gceSTATUS status;
+    gctUINT32 clock;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Hardware=0x%x FscaleValue=%d", Hardware, FscaleValue);
+
+    gcmkVERIFY_ARGUMENT(FscaleValue > 0 && FscaleValue <= 64);
+
+    gcmkONERROR(
+        gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE));
+    acquired =  gcvTRUE;
+
+    Hardware->powerOnFscaleVal = FscaleValue;
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 Hardware->powerBaseAddress
+                                 + 0x00104,
+                                 &data));
+
+        /* Disable all clock gating. */
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  Hardware->powerBaseAddress
+                                  + 0x00104,
+                                  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))) << (0 ? 8:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))) << (0 ? 8:8)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))
+                                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:11) - (0 ? 11:11) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:11) - (0 ? 11:11) + 1))))))) << (0 ? 11:11))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 11:11) - (0 ? 11:11) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:11) - (0 ? 11:11) + 1))))))) << (0 ? 11:11)))));
+
+        clock = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
+              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
+              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (FscaleValue) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)))
+              | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)));
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x00000,
+                                          clock));
+
+        /* Done loading the frequency scaler. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x00000,
+                                          ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
+
+        /* Restore all clock gating. */
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  Hardware->powerBaseAddress
+                                  + 0x00104,
+                                  data));
+    }
+
+    gcmkVERIFY(gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY(gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_GetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT * FscaleValue,
+    IN gctUINT * MinFscaleValue,
+    IN gctUINT * MaxFscaleValue
+    )
+{
+    *FscaleValue = Hardware->powerOnFscaleVal;
+    *MinFscaleValue = 1;
+    *MaxFscaleValue = 64;
+
+    return gcvSTATUS_OK;
+}
+
+#endif
+
 #if gcdPOWEROFF_TIMEOUT
 gceSTATUS
 gckHARDWARE_SetPowerOffTimeout(
@@ -4194,12 +4823,12 @@ gckHARDWARE_ProfileEngine2D(
                                  &Profile->cycleCount));
 
         /* Read pixels rendered by 2D engine. */
-        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (11) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (11) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pixelsRendered));
 
         /* Reset counter. */
-        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
     }
 
@@ -4217,6 +4846,7 @@ OnError:
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Reset,
     OUT gcsPROFILER_COUNTERS * Counters
     )
 {
@@ -4245,135 +4875,151 @@ gckHARDWARE_QueryProfileRegisters(
                              0x00438,
                              &profiler->gpuCyclesCounter));
 
-    /* Reset counters. */
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
     gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00078,
+                             &profiler->gpuTotalCyclesCounter));
+
     gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+        gckOS_ReadRegisterEx(Hardware->os,
+	                     Hardware->core,
+                             0x0007C,
+                             &profiler->gpuIdleCyclesCounter));
 
+    if(Reset){
+
+            /* Reset counters. */
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
+        }
     /* PE */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
-));
+    if(Reset){     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
+)); }
 
     /* SH */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->ps_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->rendered_pixel_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vs_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->rendered_vertice_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (11) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (11) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vtx_branch_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (12) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (12) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vtx_texld_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (13) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (13) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_branch_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_texld_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24)))
-));
+    if(Reset){  gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
+));}
 
     /* PA */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_input_vtx_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (4) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (4) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_input_prim_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_output_prim_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_depth_clipped_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_trivial_rejected_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
+));}
 
     /* SE */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_triangle_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
+));}
 
     /* RA */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_pixel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_quad_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_quad_count_after_early_z));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_primitive_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
+));}
 
     /* TX */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_bilinear_requests));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_trilinear_requests));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_discarded_texture_requests));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_texture_requests));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_mem_read_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_mem_read_in_8B_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_hit_texel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
+));}
 
     /* MC */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_pipeline));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_IP));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
+));}
 
     /* HI */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_read_request_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_request_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) ));
-gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)))
-));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
+));}
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -4400,7 +5046,7 @@ _ResetGPU(
     {
         /* Disable clock gating. */
         gcmkONERROR(gckOS_WriteRegisterEx(Os,
-                                     Core,
+                    Core,
                     Hardware->powerBaseAddress +
                     0x00104,
                     0x00000000));
@@ -4425,19 +5071,19 @@ _ResetGPU(
 
         gcmkONERROR(gckOS_WriteRegisterEx(Os,
                     Core,
-                                     0x00000,
-                    ((((gctUINT32) (0x00000100)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
+                    0x00000,
+                    ((((gctUINT32) (0x00000900)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
 
         gcmkONERROR(gckOS_WriteRegisterEx(Os,
                     Core,
                     0x00000,
-                    0x00000100));
+                    0x00000900));
 
         /* Wait for clock being stable. */
         gcmkONERROR(gckOS_Delay(Os, 1));
 
         /* Isolate the GPU. */
-        control = ((((gctUINT32) (0x00000100)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+        control = ((((gctUINT32) (0x00000900)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
 
         gcmkONERROR(gckOS_WriteRegisterEx(Os,
                                           Core,
@@ -4512,6 +5158,8 @@ gckHARDWARE_Reset(
     gceSTATUS status;
     gckCOMMAND command;
     gctBOOL acquired = gcvFALSE;
+    gctBOOL mutexAcquired = gcvFALSE;
+    gctUINT32 process, thread;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
@@ -4527,6 +5175,25 @@ gckHARDWARE_Reset(
         gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
     }
 
+    status = gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, 0);
+    if (status == gcvSTATUS_TIMEOUT)
+    {
+        gcmkONERROR(gckOS_GetProcessID(&process));
+        gcmkONERROR(gckOS_GetThreadID(&thread));
+
+        if ((Hardware->powerProcess == process)
+        &&  (Hardware->powerThread  == thread))
+        {
+            /* No way to recovery from a error in power management. */
+            gcmkFOOTER_NO();
+            return gcvSTATUS_OK;
+        }
+    }
+    else
+    {
+        mutexAcquired = gcvTRUE;
+    }
+
     if (Hardware->chipPowerState == gcvPOWER_ON)
     {
         /* Acquire the power management semaphore. */
@@ -4544,13 +5211,25 @@ gckHARDWARE_Reset(
     }
 
     /* Stop isr, we will start it again when power on GPU. */
-    gcmkONERROR(Hardware->stopIsr(Hardware->isrContext));
+    if (Hardware->stopIsr)
+    {
+        gcmkONERROR(Hardware->stopIsr(Hardware->isrContext));
+    }
+
+    /* Hardware reset. */
+    status = gckOS_ResetGPU(Hardware->os, Hardware->core);
 
-    gcmkONERROR(_ResetGPU(Hardware, Hardware->os, Hardware->core));
+    if (gcmIS_ERROR(status))
+    {
+        /* Soft reset. */
+        gcmkONERROR(_ResetGPU(Hardware, Hardware->os, Hardware->core));
+    }
 
     /* Force an OFF to ON power switch. */
     Hardware->chipPowerState = gcvPOWER_OFF;
-    gcmkONERROR(gckHARDWARE_SetPowerManagementState(Hardware, gcvPOWER_ON));
+
+    gcmkONERROR(gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex));
+    mutexAcquired = gcvFALSE;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -4564,6 +5243,11 @@ OnError:
             gckOS_ReleaseSemaphore(Hardware->os, command->powerSemaphore));
     }
 
+    if (mutexAcquired)
+    {
+        gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+    }
+
     /* Return the error. */
     gcmkFOOTER();
     return status;
@@ -4803,6 +5487,11 @@ gckHARDWARE_IsFeatureAvailable(
     case gcvFEATURE_MC20:
         available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures)) >> (0 ? 22:22) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))));
         break;
+    case gcvFEATURE_DYNAMIC_FREQUENCY_SCALING:
+        /* This feature doesn't apply for 2D cores. */
+        available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures2)) >> (0 ? 14:14) & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))))
+            &&      ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
+        break;
 
     default:
         gcmkFATAL("Invalid feature has been requested.");
@@ -4814,6 +5503,350 @@ gckHARDWARE_IsFeatureAvailable(
     return available ? gcvSTATUS_TRUE : gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_DumpMMUException
+**
+**  Dump the MMU debug info on an MMU exception.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckHARDWARE_DumpMMUException(
+    IN gckHARDWARE Hardware
+    )
+{
+#if !gcdPOWER_SUSNPEND_WHEN_IDLE && !gcdPOWEROFF_TIMEOUT
+    gctUINT32 mmu, mmuStatus, address, i;
+#if gcdDEBUG
+    gctUINT32 mtlb, stlb, offset;
+#endif
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkPRINT("GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+              Hardware->core,
+              Hardware->identity.chipModel,
+              Hardware->identity.chipRevision);
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***   MMU ERROR DUMP   ***\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkVERIFY_OK(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00188,
+                             &mmuStatus));
+
+    gcmkPRINT("  MMU status = 0x%08X\n", mmuStatus);
+
+    for (i = 0; i < 4; i += 1)
+    {
+        mmu = mmuStatus & 0xF;
+        mmuStatus >>= 4;
+
+        if (mmu == 0)
+        {
+            continue;
+        }
+
+        switch (mmu)
+        {
+        case 1:
+              gcmkPRINT("  MMU%d: slave not present\n", i);
+              break;
+
+        case 2:
+              gcmkPRINT("  MMU%d: page not present\n", i);
+              break;
+
+        case 3:
+              gcmkPRINT("  MMU%d: write violation\n", i);
+              break;
+
+        default:
+              gcmkPRINT("  MMU%d: unknown state\n", i);
+        }
+
+        gcmkVERIFY_OK(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 0x00190 + i * 4,
+                                 &address));
+
+        mtlb   = (address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
+        stlb   = (address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+        offset =  address & gcdMMU_OFFSET_4K_MASK;
+
+        gcmkPRINT("  MMU%d: exception address = 0x%08X\n", i, address);
+
+        gcmkPRINT("    MTLB entry = %d\n", mtlb);
+
+        gcmkPRINT("    STLB entry = %d\n", stlb);
+
+        gcmkPRINT("    Offset = 0x%08X (%d)\n", offset, offset);
+
+        gckMMU_DumpPageTableEntry(Hardware->kernel->mmu, address);
+
+    }
+
+	gcmkFOOTER_NO();
+#else
+    /* If clock could be off automatically, we can't read mmu debug
+    ** register here; build driver with gcdPOWER_SUSPEND_WHEN_IDLE = 0
+    ** and gcdPOWEROFF_TIMEOUT = 0 to make it safe to read mmu register. */
+    gcmkPRINT("[galcore] %s(%d): MMU Exception!", __FUNCTION__, __LINE__);
+#endif
+
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckHARDWARE_DumpGPUState
+**
+**  Dump the GPU debug registers.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    )
+{
+    static gctCONST_STRING _cmdState[] =
+    {
+        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
+        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
+        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
+        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
+        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
+        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
+    };
+
+    static gctCONST_STRING _cmdDmaState[] =
+    {
+        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
+    };
+
+    static gctCONST_STRING _cmdFetState[] =
+    {
+        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
+    };
+
+    static gctCONST_STRING _reqDmaState[] =
+    {
+        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
+    };
+
+    static gctCONST_STRING _calState[] =
+    {
+        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
+    };
+
+    static gctCONST_STRING _veReqState[] =
+    {
+        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
+    };
+
+    static gcsiDEBUG_REGISTERS _dbgRegs[] =
+    {
+        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
+        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
+        { "FE", 0x470, 0, 0x450, 16, 0xBABEF00D },
+        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
+        { "DE", 0x470, 8, 0x458, 16, 0xBABEF00D },
+        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
+        { "PA", 0x474, 0, 0x460, 16, 0x0000AAAA },
+        { "SE", 0x474, 8, 0x464, 16, 0x5E5E5E5E },
+        { "MC", 0x478, 0, 0x468, 16, 0x12345678 },
+        { "HI", 0x478, 8, 0x46C, 16, 0xAAAAAAAA }
+    };
+
+    static gctUINT32 _otherRegs[] =
+    {
+        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
+        0x43c, 0x440, 0x444, 0x414,
+    };
+
+    gceSTATUS status;
+    gckKERNEL kernel;
+    gctUINT32 idle, axi;
+    gctUINT32 dmaAddress1, dmaAddress2;
+    gctUINT32 dmaState1, dmaState2;
+    gctUINT32 dmaLow, dmaHigh;
+    gctUINT32 cmdState, cmdDmaState, cmdFetState;
+    gctUINT32 dmaReqState, calState, veReqState;
+    gctUINT i;
+    gctUINT pipe, pixelPipes;
+    gctUINT32 control, oldControl;
+    gckOS os = Hardware->os;
+    gceCORE core = Hardware->core;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    kernel = Hardware->kernel;
+
+    gcmkPRINT_N(12, "GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+                core,
+                Hardware->identity.chipModel,
+                Hardware->identity.chipRevision);
+
+    pixelPipes = Hardware->identity.pixelPipes
+               ? Hardware->identity.pixelPipes
+               : 1;
+
+    /* Reset register values. */
+    idle        = axi         =
+    dmaState1   = dmaState2   =
+    dmaAddress1 = dmaAddress2 =
+    dmaLow      = dmaHigh     = 0;
+
+    /* Verify whether DMA is running. */
+    gcmkONERROR(_VerifyDMA(
+        os, core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
+        ));
+
+    cmdState    =  dmaState2        & 0x1F;
+    cmdDmaState = (dmaState2 >>  8) & 0x03;
+    cmdFetState = (dmaState2 >> 10) & 0x03;
+    dmaReqState = (dmaState2 >> 12) & 0x03;
+    calState    = (dmaState2 >> 14) & 0x03;
+    veReqState  = (dmaState2 >> 16) & 0x03;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x004, &idle));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00C, &axi));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x668, &dmaLow));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x66C, &dmaHigh));
+
+    gcmkPRINT_N(0, "**************************\n");
+    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
+    gcmkPRINT_N(0, "**************************\n");
+
+    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
+
+    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
+    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
+    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
+    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
+    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
+    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
+    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
+    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
+    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
+    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
+    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
+    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
+    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
+    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
+
+    if (
+        (dmaAddress1 == dmaAddress2)
+     && (dmaState1 == dmaState2)
+    )
+    {
+        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
+        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+    }
+    else
+    {
+        if (dmaAddress1 == dmaAddress2)
+        {
+            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
+        }
+        else
+        {
+            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
+        }
+    }
+    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
+    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
+    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
+    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState, _cmdState   [cmdState]);
+    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
+    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
+    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
+    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState, _calState   [calState]);
+    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState, _veReqState [veReqState]);
+
+    /* Record control. */
+    gckOS_ReadRegisterEx(os, core, 0x0, &oldControl);
+
+    for (pipe = 0; pipe < pixelPipes; pipe++)
+    {
+        gcmkPRINT_N(4, "  Debug registers of pipe[%d]:\n", pipe);
+
+        /* Switch pipe. */
+        gckOS_ReadRegisterEx(os, core, 0x0, &control);
+        control &= ~(0xF << 20);
+        control |= (pipe << 20);
+        gckOS_WriteRegisterEx(os, core, 0x0, control);
+
+        for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
+        {
+            gcmkONERROR(_DumpDebugRegisters(os, core, &_dbgRegs[i]));
+        }
+
+        gcmkPRINT_N(0, "    Other Registers:\n");
+        for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
+        {
+            gctUINT32 read;
+            gcmkONERROR(gckOS_ReadRegisterEx(os, core, _otherRegs[i], &read));
+            gcmkPRINT_N(12, "      [0x%04X] 0x%08X\n", _otherRegs[i], read);
+        }
+    }
+
+    if (kernel->hardware->identity.chipFeatures & (1 << 4))
+    {
+        gctUINT32 read0, read1, write;
+
+        read0 = read1 = write = 0;
+
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x43C, &read0));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x440, &read1));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x444, &write));
+
+        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
+        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
+        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
+    }
+
+    /* Restore control. */
+    gckOS_WriteRegisterEx(os, core, 0x0, oldControl);
+
+    /* dump stack. */
+    gckOS_DumpCallStack(os);
+
+OnError:
+
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
+
 #if gcdFRAME_DB
 static gceSTATUS
 gckHARDWARE_ReadPerformanceRegister(
@@ -5211,3 +6244,195 @@ OnError:
     return status;
 }
 #endif
+
+#if gcdDVFS
+#define READ_FROM_EATER1 0
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    )
+{
+    gctUINT32 debug1;
+    gceSTATUS status;
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Load != gcvNULL);
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00110,
+                                         Load));
+#if READ_FROM_EATER1
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00134,
+                                         Load));
+#endif
+
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00114,
+                                         &debug1));
+
+        /* Patch result of 0x110 with result of 0x114. */
+        if ((debug1 & 0xFF) == 1)
+        {
+            *Load &= ~0xFF;
+            *Load |= 1;
+        }
+
+        if (((debug1 & 0xFF00) >> 8) == 1)
+        {
+            *Load &= ~(0xFF << 8);
+            *Load |= 1 << 8;
+        }
+
+        if (((debug1 & 0xFF0000) >> 16) == 1)
+        {
+            *Load &= ~(0xFF << 16);
+            *Load |= 1 << 16;
+        }
+
+        if (((debug1 & 0xFF000000) >> 24) == 1)
+        {
+            *Load &= ~(0xFF << 24);
+            *Load |= 1 << 24;
+        }
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 Frequency
+    )
+{
+    gceSTATUS status;
+    gctUINT32 period;
+    gctUINT32 eater;
+
+#if READ_FROM_EATER1
+    gctUINT32 period1;
+    gctUINT32 eater1;
+#endif
+
+    gcmkHEADER_ARG("Hardware=0x%X Frequency=%d", Hardware, Frequency);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    period = 0;
+
+    while((64 << period) < (gcdDVFS_ANAYLSE_WINDOW * Frequency * 1000) )
+    {
+        period++;
+    }
+
+#if READ_FROM_EATER1
+    /*
+    *  Peroid = F * 1000 * 1000 / (60 * 16 * 1024);
+    */
+    period1 = Frequency * 6250 / 6114;
+#endif
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        /* Get current configure. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x0010C,
+                                         &eater));
+
+        /* Change peroid. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x0010C,
+                                          ((((gctUINT32) (eater)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (period) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))));
+
+#if READ_FROM_EATER1
+        /* Config eater1. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00130,
+                                         &eater1));
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x00130,
+                                          ((((gctUINT32) (eater1)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16))) | (((gctUINT32) ((gctUINT32) (period1) & ((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16)))));
+#endif
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gctUINT32 data;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x0010C,
+                                     &data));
+
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22)));
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                   "DVFS Configure=0x%X",
+                   data);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x0010C,
+                                      data));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
index e894e66..517b35c 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -17,6 +17,8 @@
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *****************************************************************************/
+
+
 #ifndef __gc_hal_kernel_hardware_h_
 #define __gc_hal_kernel_hardware_h_
 
@@ -74,11 +76,20 @@ struct _gckHARDWARE
 
 #if gcdPOWEROFF_TIMEOUT
     gctUINT32                   powerOffTime;
-    gctSIGNAL                   powerOffSignal;
     gctUINT32                   powerOffTimeout;
+    gctPOINTER                  powerOffTimer;
 #endif
 
     gctPOINTER                  pageTableDirty;
+
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    /* FSCALE_VAL when gcvPOWER_ON. */
+    gctUINT32                   powerOnFscaleVal;
+#endif
+
+#if gcdLINK_QUEUE_SIZE
+    struct _gckLINKQUEUE        linkQueue;
+#endif
 };
 
 gceSTATUS
@@ -100,8 +111,23 @@ gckHARDWARE_GetFrameInfo(
     OUT gcsHAL_FRAME_INFO * FrameInfo
     );
 
+gceSTATUS
+gckHARDWARE_SetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32   FscaleValue
+    );
+
+gceSTATUS
+gckHARDWARE_GetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT * FscaleValue,
+    IN gctUINT * MinFscaleValue,
+    IN gctUINT * MaxFscaleValue
+    );
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* __gc_hal_kernel_hardware_h_ */
+
diff --git a/drivers/mxc/gpu-viv/config b/drivers/mxc/gpu-viv/config
index bce014f..1196efa 100644
--- a/drivers/mxc/gpu-viv/config
+++ b/drivers/mxc/gpu-viv/config
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
 
 ARCH_TYPE                         ?= arm
 SDK_DIR                           ?= $(AQROOT)/build/sdk
-USE_3D_VG	= 1
+USE_3D_VG                         ?= 1
 USE_POWER_MANAGEMENT              ?= 1
 FORCE_ALL_VIDEO_MEMORY_CACHED     ?= 0
 NONPAGED_MEMORY_CACHEABLE         ?= 0
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 90991fd..7964585 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -70,6 +68,9 @@ gctCONST_STRING _DispatchText[] =
     gcmDEFINE2TEXT(gcvHAL_GET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_SET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_READ_ALL_PROFILE_REGISTERS),
+#if VIVANTE_PROFILER_PERDRAW
+    gcmDEFINE2TEXT(gcvHAL_READ_PROFILER_REGISTER_SETTING),
+#endif
     gcmDEFINE2TEXT(gcvHAL_PROFILE_REGISTERS_2D),
     gcmDEFINE2TEXT(gcvHAL_SET_POWER_MANAGEMENT_STATE),
     gcmDEFINE2TEXT(gcvHAL_QUERY_POWER_MANAGEMENT_STATE),
@@ -89,6 +90,18 @@ gctCONST_STRING _DispatchText[] =
 };
 #endif
 
+#if gcdENABLE_RECOVERY
+void
+_ResetFinishFunction(
+    gctPOINTER Data
+    )
+{
+    gckKERNEL kernel = (gckKERNEL)Data;
+
+    gckOS_AtomSet(kernel->os, kernel->resetAtom, 0);
+}
+#endif
+
 /*******************************************************************************
 **
 **  gckKERNEL_Construct
@@ -161,6 +174,15 @@ gckKERNEL_Construct(
     kernel->command      = gcvNULL;
     kernel->eventObj     = gcvNULL;
     kernel->mmu          = gcvNULL;
+#if gcdDVFS
+    kernel->dvfs         = gcvNULL;
+#endif
+
+    /* Initialize the gckKERNEL object. */
+    kernel->object.type = gcvOBJ_KERNEL;
+    kernel->os          = Os;
+    kernel->core        = Core;
+
 
     if (SharedDB == gcvNULL)
     {
@@ -185,6 +207,12 @@ gckKERNEL_Construct(
 
         /* Construct a database mutex. */
         gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->dbMutex));
+
+        /* Construct a id-pointer database. */
+        gcmkONERROR(gckKERNEL_CreateIntegerDatabase(kernel, &kernel->db->pointerDatabase));
+
+        /* Construct a id-pointer database mutex. */
+        gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->pointerDatabaseMutex));
     }
     else
     {
@@ -200,14 +228,17 @@ gckKERNEL_Construct(
 
     kernel->timeOut      = gcdGPU_TIMEOUT;
 
-    /* Initialize the gckKERNEL object. */
-    kernel->object.type = gcvOBJ_KERNEL;
-    kernel->os          = Os;
-    kernel->core        = Core;
-
     /* Save context. */
     kernel->context = Context;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+    kernel->virtualBufferHead =
+    kernel->virtualBufferTail = gcvNULL;
+
+    gcmkONERROR(
+        gckOS_CreateMutex(Os, (gctPOINTER)&kernel->virtualBufferLock));
+#endif
+
     /* Construct atom holding number of clients. */
     kernel->atomClients = gcvNULL;
     gcmkONERROR(gckOS_AtomConstruct(Os, &kernel->atomClients));
@@ -246,6 +277,27 @@ gckKERNEL_Construct(
         /* Construct the gckMMU object. */
         gcmkONERROR(
             gckMMU_Construct(kernel, gcdMMU_SIZE, &kernel->mmu));
+
+#if gcdENABLE_RECOVERY
+        gcmkONERROR(
+            gckOS_AtomConstruct(Os, &kernel->resetAtom));
+
+        gcmkVERIFY_OK(
+            gckOS_CreateTimer(Os,
+                              (gctTIMERFUNCTION)_ResetFinishFunction,
+                              (gctPOINTER)kernel,
+                              &kernel->resetFlagClearTimer));
+        kernel->resetTimeStamp = 0;
+#endif
+
+#if gcdDVFS
+        if (gckHARDWARE_IsFeatureAvailable(kernel->hardware,
+                                           gcvFEATURE_DYNAMIC_FREQUENCY_SCALING))
+        {
+            gcmkONERROR(gckDVFS_Construct(kernel->hardware, &kernel->dvfs));
+            gcmkONERROR(gckDVFS_Start(kernel->dvfs));
+        }
+#endif
     }
 
 #if VIVANTE_PROFILER
@@ -255,6 +307,7 @@ gckKERNEL_Construct(
 #else
     kernel->profileEnable = gcvTRUE;
 #endif
+    kernel->profileCleanRegister = gcvTRUE;
 
     gcmkVERIFY_OK(
         gckOS_MemCopy(kernel->profileFileName,
@@ -289,7 +342,10 @@ OnError:
             if (kernel->hardware != gcvNULL)
             {
                 /* Turn off the power. */
-                gcmkVERIFY_OK(gckOS_SetGPUPower(kernel->hardware->os, kernel->hardware->core, gcvFALSE, gcvFALSE));
+                gcmkVERIFY_OK(gckOS_SetGPUPower(kernel->hardware->os,
+                                                kernel->hardware->core,
+                                                gcvFALSE,
+                                                gcvFALSE));
                 gcmkVERIFY_OK(gckHARDWARE_Destroy(kernel->hardware));
             }
         }
@@ -299,6 +355,19 @@ OnError:
             gcmkVERIFY_OK(gckOS_AtomDestroy(Os, kernel->atomClients));
         }
 
+#if gcdENABLE_RECOVERY
+        if (kernel->resetAtom != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_AtomDestroy(Os, kernel->resetAtom));
+        }
+
+        if (kernel->resetFlagClearTimer)
+        {
+            gcmkVERIFY_OK(gckOS_StopTimer(Os, kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, kernel->resetFlagClearTimer));
+        }
+#endif
+
         if (kernel->dbCreated && kernel->db != gcvNULL)
         {
             if (kernel->db->dbMutex != gcvNULL)
@@ -310,6 +379,22 @@ OnError:
             gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel->db));
         }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+        if (kernel->virtualBufferLock != gcvNULL)
+        {
+            /* Destroy the virtual command buffer mutex. */
+            gcmkVERIFY_OK(gckOS_DeleteMutex(Os, kernel->virtualBufferLock));
+        }
+#endif
+
+#if gcdDVFS
+        if (kernel->dvfs)
+        {
+            gcmkVERIFY_OK(gckDVFS_Stop(kernel->dvfs));
+            gcmkVERIFY_OK(gckDVFS_Destroy(kernel->dvfs));
+        }
+#endif
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel));
     }
 
@@ -385,6 +470,13 @@ gckKERNEL_Destroy(
 
         /* Destroy the database mutex. */
         gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->dbMutex));
+
+
+        /* Destroy id-pointer database. */
+        gcmkVERIFY_OK(gckKERNEL_DestroyIntegerDatabase(Kernel, Kernel->db->pointerDatabase));
+
+        /* Destroy id-pointer database mutex. */
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->pointerDatabaseMutex));
     }
 
 #if gcdENABLE_VG
@@ -406,11 +498,33 @@ gckKERNEL_Destroy(
 
         /* Destroy the gckHARDWARE object. */
         gcmkVERIFY_OK(gckHARDWARE_Destroy(Kernel->hardware));
+
+#if gcdENABLE_RECOVERY
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Kernel->os, Kernel->resetAtom));
+
+        if (Kernel->resetFlagClearTimer)
+        {
+            gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->resetFlagClearTimer));
+        }
+#endif
     }
 
     /* Detsroy the client atom. */
     gcmkVERIFY_OK(gckOS_AtomDestroy(Kernel->os, Kernel->atomClients));
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->virtualBufferLock));
+#endif
+
+#if gcdDVFS
+    if (Kernel->dvfs)
+    {
+        gcmkVERIFY_OK(gckDVFS_Stop(Kernel->dvfs));
+        gcmkVERIFY_OK(gckDVFS_Destroy(Kernel->dvfs));
+    }
+#endif
+
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -422,6 +536,97 @@ gckKERNEL_Destroy(
     return gcvSTATUS_OK;
 }
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/oom.h>
+#include <linux/sched.h>
+#include <linux/notifier.h>
+
+extern struct task_struct *lowmem_deathpending;
+static unsigned long lowmem_deathpending_timeout;
+
+static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
+{
+	struct task_struct *p;
+	struct task_struct *selected = NULL;
+	int tasksize;
+        int ret = -1;
+	int min_adj = 0;
+	int selected_tasksize = 0;
+	int selected_oom_adj;
+	/*
+	 * If we already have a death outstanding, then
+	 * bail out right away; indicating to vmscan
+	 * that we have nothing further to offer on
+	 * this pass.
+	 *
+	 */
+	if (lowmem_deathpending &&
+	    time_before_eq(jiffies, lowmem_deathpending_timeout))
+		return 0;
+	selected_oom_adj = min_adj;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		struct mm_struct *mm;
+		struct signal_struct *sig;
+                gcuDATABASE_INFO info;
+		int oom_adj;
+
+		task_lock(p);
+		mm = p->mm;
+		sig = p->signal;
+		if (!mm || !sig) {
+			task_unlock(p);
+			continue;
+		}
+		oom_adj = sig->oom_adj;
+		if (oom_adj < min_adj) {
+			task_unlock(p);
+			continue;
+		}
+
+		tasksize = 0;
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_CONTIGUOUS, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+
+		task_unlock(p);
+
+		if (tasksize <= 0)
+			continue;
+
+		gckOS_Print("<gpu> pid %d (%s), adj %d, size %d \n", p->pid, p->comm, oom_adj, tasksize);
+
+		if (selected) {
+			if (oom_adj < selected_oom_adj)
+				continue;
+			if (oom_adj == selected_oom_adj &&
+			    tasksize <= selected_tasksize)
+				continue;
+		}
+		selected = p;
+		selected_tasksize = tasksize;
+		selected_oom_adj = oom_adj;
+	}
+	if (selected) {
+		gckOS_Print("<gpu> send sigkill to %d (%s), adj %d, size %d\n",
+			     selected->pid, selected->comm,
+			     selected_oom_adj, selected_tasksize);
+		lowmem_deathpending = selected;
+		lowmem_deathpending_timeout = jiffies + HZ;
+		force_sig(SIGKILL, selected);
+		ret = 0;
+	}
+	read_unlock(&tasklist_lock);
+	return ret;
+}
+
+#endif
 
 /*******************************************************************************
 **
@@ -461,6 +666,7 @@ _AllocateMemory(
     gctINT loopCount;
     gcuVIDMEM_NODE_PTR node = gcvNULL;
     gctBOOL tileStatusInVirtual;
+    gctBOOL forceContiguous = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x *Pool=%d Bytes=%lu Alignment=%lu Type=%d",
                    Kernel, *Pool, Bytes, Alignment, Type);
@@ -468,9 +674,14 @@ _AllocateMemory(
     gcmkVERIFY_ARGUMENT(Pool != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes != 0);
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+_AllocateMemory_Retry:
+#endif
     /* Get initial pool. */
     switch (pool = *Pool)
     {
+    case gcvPOOL_DEFAULT_FORCE_CONTIGUOUS:
+        forceContiguous = gcvTRUE;
     case gcvPOOL_DEFAULT:
     case gcvPOOL_LOCAL:
         pool      = gcvPOOL_LOCAL_INTERNAL;
@@ -486,6 +697,12 @@ _AllocateMemory(
         loopCount = (gctINT) gcvPOOL_NUMBER_OF_POOLS;
         break;
 
+    case gcvPOOL_DEFAULT_FORCE_CONTIGUOUS_CACHEABLE:
+        pool      = gcvPOOL_CONTIGUOUS;
+        loopCount = 1;
+        forceContiguous = gcvTRUE;
+        break;
+
     default:
         loopCount = 1;
         break;
@@ -506,9 +723,19 @@ _AllocateMemory(
         else
         if (pool == gcvPOOL_CONTIGUOUS)
         {
-            /* Create a gcuVIDMEM_NODE for contiguous memory. */
-            status = gckVIDMEM_ConstructVirtual(Kernel, gcvTRUE, Bytes, &node);
-            if (gcmIS_SUCCESS(status))
+#if gcdCONTIGUOUS_SIZE_LIMIT
+            if (Bytes > gcdCONTIGUOUS_SIZE_LIMIT && forceContiguous == gcvFALSE)
+            {
+                status = gcvSTATUS_OUT_OF_MEMORY;
+            }
+            else
+#endif
+            {
+                /* Create a gcuVIDMEM_NODE from contiguous memory. */
+                status = gckVIDMEM_ConstructVirtual(Kernel, gcvTRUE, Bytes, &node);
+            }
+
+            if (gcmIS_SUCCESS(status) || forceContiguous == gcvTRUE)
             {
                 /* Memory allocated. */
                 break;
@@ -595,11 +822,22 @@ _AllocateMemory(
 
     if (node == gcvNULL)
     {
+
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+        if(forceContiguous == gcvTRUE)
+        {
+            if(force_contiguous_lowmem_shrink(Kernel) == 0)
+            {
+                 /* Sleep 1 millisecond. */
+                 gckOS_Delay(gcvNULL, 1);
+                 goto _AllocateMemory_Retry;
+            }
+        }
+#endif
         /* Nothing allocated. */
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-
     /* Return node and pool used for allocation. */
     *Node = node;
     *Pool = pool;
@@ -651,11 +889,14 @@ gckKERNEL_Dispatch(
     gcuVIDMEM_NODE_PTR node;
     gctBOOL locked = gcvFALSE;
     gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctPOINTER info = gcvNULL;
+    gckCONTEXT context = gcvNULL;
     gctUINT32 address;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
 #if gcdSECURE_USER
     gcskSECURE_CACHE_PTR cache;
-    gctPOINTER logical;
 #endif
     gctBOOL asynchronous;
     gctPOINTER paddr = gcvNULL;
@@ -713,123 +954,185 @@ gckKERNEL_Dispatch(
         break;
 
     case gcvHAL_MAP_MEMORY:
-        physical = Interface->u.MapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.MapMemory.physical);
 
         /* Map memory. */
         gcmkONERROR(
             gckKERNEL_MapMemory(Kernel,
                                 physical,
-                                Interface->u.MapMemory.bytes,
-                                &Interface->u.MapMemory.logical));
+                                (gctSIZE_T) Interface->u.MapMemory.bytes,
+                                &logical));
+
+        Interface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_MEMORY,
-                                   Interface->u.MapMemory.logical,
+                                   logical,
                                    physical,
-                                   Interface->u.MapMemory.bytes));
+                                   (gctSIZE_T) Interface->u.MapMemory.bytes));
         break;
 
     case gcvHAL_UNMAP_MEMORY:
-        physical = Interface->u.UnmapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.UnmapMemory.physical);
 
         /* Unmap memory. */
         gcmkONERROR(
             gckKERNEL_UnmapMemory(Kernel,
                                   physical,
-                                  Interface->u.UnmapMemory.bytes,
-                                  Interface->u.UnmapMemory.logical));
+                                  (gctSIZE_T) Interface->u.UnmapMemory.bytes,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_MEMORY,
-                                      Interface->u.UnmapMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         break;
 
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateNonPagedMemory.bytes;
+
         /* Allocate non-paged memory. */
         gcmkONERROR(
             gckOS_AllocateNonPagedMemory(
                 Kernel->os,
                 FromUser,
-                &Interface->u.AllocateNonPagedMemory.bytes,
-                &Interface->u.AllocateNonPagedMemory.physical,
-                &Interface->u.AllocateNonPagedMemory.logical));
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateNonPagedMemory.bytes    = bytes;
+        Interface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_NON_PAGED,
-                                   Interface->u.AllocateNonPagedMemory.logical,
-                                   Interface->u.AllocateNonPagedMemory.physical,
-                                   Interface->u.AllocateNonPagedMemory.bytes));
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateNonPagedMemory.physical),
+                                   bytes));
+
+        break;
+
+    case gcvHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER:
+#if gcdVIRTUAL_COMMAND_BUFFER
+        bytes = (gctSIZE_T) Interface->u.AllocateVirtualCommandBuffer.bytes;
+
+        gcmkONERROR(
+            gckKERNEL_AllocateVirtualCommandBuffer(
+                Kernel,
+                FromUser,
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateVirtualCommandBuffer.bytes    = bytes;
+        Interface->u.AllocateVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateVirtualCommandBuffer.physical = gcmPTR_TO_NAME(physical);
+
+        gcmkVERIFY_OK(
+            gckKERNEL_AddProcessDB(Kernel,
+                                   processID, gcvDB_COMMAND_BUFFER,
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateVirtualCommandBuffer.physical),
+                                   bytes));
+#else
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
-        physical = Interface->u.FreeNonPagedMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical);
+
+        /* Unmap user logical out of physical memory first. */
+        gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
+                                           physical,
+                                           (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         /* Free non-paged memory. */
         gcmkONERROR(
             gckOS_FreeNonPagedMemory(Kernel->os,
-                                     Interface->u.FreeNonPagedMemory.bytes,
+                                     (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
                                      physical,
-                                     Interface->u.FreeNonPagedMemory.logical));
+                                     gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_NON_PAGED,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeNonPagedMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical),
             Interface->u.FreeNonPagedMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeNonPagedMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateContiguousMemory.bytes;
+
         /* Allocate contiguous memory. */
         gcmkONERROR(gckOS_AllocateContiguous(
             Kernel->os,
             FromUser,
-            &Interface->u.AllocateContiguousMemory.bytes,
-            &Interface->u.AllocateContiguousMemory.physical,
-            &Interface->u.AllocateContiguousMemory.logical));
+            &bytes,
+            &physical,
+            &logical));
+
+        Interface->u.AllocateContiguousMemory.bytes    = bytes;
+        Interface->u.AllocateContiguousMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateContiguousMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkONERROR(gckHARDWARE_ConvertLogical(
             Kernel->hardware,
-            Interface->u.AllocateContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.AllocateContiguousMemory.logical),
             &Interface->u.AllocateContiguousMemory.address));
 
         gcmkVERIFY_OK(gckKERNEL_AddProcessDB(
             Kernel,
             processID, gcvDB_CONTIGUOUS,
-            Interface->u.AllocateContiguousMemory.logical,
-            Interface->u.AllocateContiguousMemory.physical,
-            Interface->u.AllocateContiguousMemory.bytes));
+            logical,
+            gcmINT2PTR(Interface->u.AllocateContiguousMemory.physical),
+            bytes));
+
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
-        physical = Interface->u.FreeContiguousMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical);
+
+        /* Unmap user logical out of physical memory first. */
+        gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
+                                           physical,
+                                           (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
 
         /* Free contiguous memory. */
         gcmkONERROR(
             gckOS_FreeContiguous(Kernel->os,
                                  physical,
-                                 Interface->u.FreeContiguousMemory.logical,
-                                 Interface->u.FreeContiguousMemory.bytes));
+                                 gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
+                                 (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_CONTIGUOUS,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
             Interface->u.FreeContiguousMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeContiguousMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -846,10 +1149,8 @@ gckKERNEL_Dispatch(
                             Interface->u.AllocateLinearVideoMemory.bytes,
                             Interface->u.AllocateLinearVideoMemory.alignment,
                             Interface->u.AllocateLinearVideoMemory.type,
-                            &Interface->u.AllocateLinearVideoMemory.node));
+                            &node));
 
-        /* Get actual size of node. */
-        node = Interface->u.AllocateLinearVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             bytes = node->VidMem.bytes;
@@ -862,14 +1163,17 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY,
-                                   Interface->u.AllocateLinearVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    bytes));
+
+        /* Get the node. */
+        Interface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
-        node = Interface->u.FreeVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM
          && node->VidMem.logical != gcvNULL)
         {
@@ -883,25 +1187,27 @@ gckKERNEL_Dispatch(
 #endif
         /* Free video memory. */
         gcmkONERROR(
-            gckVIDMEM_Free(Interface->u.FreeVideoMemory.node));
+            gckVIDMEM_Free(node));
 
         gcmkONERROR(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_VIDEO_MEMORY,
-                                      Interface->u.FreeVideoMemory.node));
+                                      node));
+
         break;
 
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkONERROR(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
                            Interface->u.LockVideoMemory.cacheable,
                            &Interface->u.LockVideoMemory.address));
 
         locked = gcvTRUE;
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -918,18 +1224,20 @@ gckKERNEL_Dispatch(
         }
         gcmkASSERT(node->VidMem.logical != gcvNULL);
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkONERROR(
                 gckKERNEL_MapVideoMemory(Kernel,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -938,12 +1246,12 @@ gckKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            Interface->u.LockVideoMemory.memory;
 #endif
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                   Interface->u.LockVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    0));
 
@@ -951,7 +1259,7 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -990,26 +1298,25 @@ gckKERNEL_Dispatch(
             gcmkONERROR(
                 gckKERNEL_RemoveProcessDB(Kernel,
                                           processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                          Interface->u.UnlockVideoMemory.node));
+                                          node));
         }
-
         break;
 
     case gcvHAL_EVENT_COMMIT:
         /* Commit an event queue. */
         gcmkONERROR(
             gckEVENT_Commit(Kernel->eventObj,
-                            Interface->u.Event.queue));
+                            gcmUINT64_TO_PTR(Interface->u.Event.queue)));
         break;
 
     case gcvHAL_COMMIT:
         /* Commit a command and context buffer. */
         gcmkONERROR(
             gckCOMMAND_Commit(Kernel->command,
-                              Interface->u.Commit.context,
-                              Interface->u.Commit.commandBuffer,
-                              Interface->u.Commit.delta,
-                              Interface->u.Commit.queue,
+                              gcmNAME_TO_PTR(Interface->u.Commit.context),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.commandBuffer),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.delta),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.queue),
                               processID));
         break;
 
@@ -1021,43 +1328,51 @@ gckKERNEL_Dispatch(
     case gcvHAL_MAP_USER_MEMORY:
         /* Map user memory to DMA. */
         gcmkONERROR(
-            gckOS_MapUserMemoryEx(Kernel->os,
-                                  Kernel->core,
-                                  Interface->u.MapUserMemory.memory,
-                                  Interface->u.MapUserMemory.size,
-                                  &Interface->u.MapUserMemory.info,
-                                  &Interface->u.MapUserMemory.address));
+            gckOS_MapUserMemory(Kernel->os,
+                                Kernel->core,
+                                gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
+                                Interface->u.MapUserMemory.physical,
+                                (gctSIZE_T) Interface->u.MapUserMemory.size,
+                                &info,
+                                &Interface->u.MapUserMemory.address));
+
+        Interface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_USER_MEMORY,
-                                   Interface->u.MapUserMemory.memory,
-                                   Interface->u.MapUserMemory.info,
-                                   Interface->u.MapUserMemory.size));
+                                   gcmINT2PTR(Interface->u.MapUserMemory.info),
+                                   gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
+                                   (gctSIZE_T) Interface->u.MapUserMemory.size));
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
-        address = Interface->u.MapUserMemory.address;
+        address = Interface->u.UnmapUserMemory.address;
+        info = gcmNAME_TO_PTR(Interface->u.UnmapUserMemory.info);
 
         /* Unmap user memory. */
         gcmkONERROR(
-            gckOS_UnmapUserMemoryEx(Kernel->os,
-                                    Kernel->core,
-                                    Interface->u.UnmapUserMemory.memory,
-                                    Interface->u.UnmapUserMemory.size,
-                                    Interface->u.UnmapUserMemory.info,
-                                    address));
+            gckOS_UnmapUserMemory(Kernel->os,
+                                  Kernel->core,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
+                                  (gctSIZE_T) Interface->u.UnmapUserMemory.size,
+                                  info,
+                                  address));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.UnmapUserMemory.memory,
+            gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
             Interface->u.UnmapUserMemory.size));
 #endif
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_USER_MEMORY,
-                                      Interface->u.UnmapUserMemory.memory));
+                                      gcmINT2PTR(Interface->u.UnmapUserMemory.info)));
+
+        gcmRELEASE_NAME(Interface->u.UnmapUserMemory.info);
+
         break;
 
 #if !USE_NEW_LINUX_SIGNAL
@@ -1101,17 +1416,77 @@ gckKERNEL_Dispatch(
             break;
 
         case gcvUSER_SIGNAL_WAIT:
-            /* Wait on the signal. */
-            status = gckOS_WaitUserSignal(Kernel->os,
-                                          Interface->u.UserSignal.id,
-                                          Interface->u.UserSignal.wait);
+#if gcdGPU_TIMEOUT
+            if (Interface->u.UserSignal.wait == gcvINFINITE)
+            {
+                gckHARDWARE hardware;
+                gctUINT32 timer = 0;
+
+                for(;;)
+                {
+                    /* Wait on the signal. */
+                    status = gckOS_WaitUserSignal(Kernel->os,
+                                                  Interface->u.UserSignal.id,
+                                                  gcdGPU_ADVANCETIMER);
+
+                    if (status == gcvSTATUS_TIMEOUT)
+                    {
+                        gcmkONERROR(
+                            gckOS_SignalQueryHardware(Kernel->os,
+                                                      (gctSIGNAL)(gctUINTPTR_T)Interface->u.UserSignal.id,
+                                                      &hardware));
+
+                        if (hardware)
+                        {
+                            /* This signal is bound to a hardware,
+                            ** so the timeout is limited by gcdGPU_TIMEOUT.
+                            */
+                            timer += gcdGPU_ADVANCETIMER;
+                        }
+
+                        if (timer >= gcdGPU_TIMEOUT)
+                        {
+                            gcmkONERROR(
+                                gckOS_Broadcast(Kernel->os,
+                                                hardware,
+                                                gcvBROADCAST_GPU_STUCK));
+
+                            timer = 0;
+
+                            /* If a few process try to reset GPU, only one
+                            ** of them can do the real reset, other processes
+                            ** still need to wait for this signal is triggered,
+                            ** which menas reset is finished.
+                            */
+                            continue;
+                        }
+                    }
+                    else
+                    {
+                        /* Bail out on other error. */
+                        gcmkONERROR(status);
+
+                        /* Wait for signal successfully. */
+                        break;
+                    }
+                }
+            }
+            else
+#endif
+            {
+                /* Wait on the signal. */
+                status = gckOS_WaitUserSignal(Kernel->os,
+                                              Interface->u.UserSignal.id,
+                                              Interface->u.UserSignal.wait);
+            }
+
             break;
 
         case gcvUSER_SIGNAL_MAP:
             gcmkONERROR(
                 gckOS_MapSignal(Kernel->os,
-                               (gctSIGNAL)Interface->u.UserSignal.id,
-                               (gctHANDLE)processID,
+                               (gctSIGNAL)(gctUINTPTR_T)Interface->u.UserSignal.id,
+                               (gctHANDLE)(gctUINTPTR_T)processID,
                                &signal));
 
             gcmkVERIFY_OK(
@@ -1168,9 +1543,10 @@ gckKERNEL_Dispatch(
 #if gcdREGISTER_ACCESS_FROM_USER
         {
             gceCHIPPOWERSTATE power;
+
+            gckOS_AcquireMutex(Kernel->os, Kernel->hardware->powerMutex, gcvINFINITE);
             gcmkONERROR(gckHARDWARE_QueryPowerManagementState(Kernel->hardware,
                                                               &power));
-
             if (power == gcvPOWER_ON)
             {
                 /* Read a register. */
@@ -1186,6 +1562,7 @@ gckKERNEL_Dispatch(
                 Interface->u.ReadRegisterData.data = 0;
                 status = gcvSTATUS_CHIP_NOT_READY;
             }
+            gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->hardware->powerMutex));
         }
 #else
         /* No access from user land to read registers. */
@@ -1196,12 +1573,29 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_WRITE_REGISTER:
 #if gcdREGISTER_ACCESS_FROM_USER
-        /* Write a register. */
-        gcmkONERROR(
-            gckOS_WriteRegisterEx(Kernel->os,
-                                  Kernel->core,
-                                  Interface->u.WriteRegisterData.address,
-                                  Interface->u.WriteRegisterData.data));
+        {
+            gceCHIPPOWERSTATE power;
+
+            gckOS_AcquireMutex(Kernel->os, Kernel->hardware->powerMutex, gcvINFINITE);
+            gcmkONERROR(gckHARDWARE_QueryPowerManagementState(Kernel->hardware,
+                                                                  &power));
+            if (power == gcvPOWER_ON)
+            {
+                /* Write a register. */
+                gcmkONERROR(
+                    gckOS_WriteRegisterEx(Kernel->os,
+                                          Kernel->core,
+                                          Interface->u.WriteRegisterData.address,
+                                          Interface->u.WriteRegisterData.data));
+            }
+            else
+            {
+                /* Chip is in power-state. */
+                Interface->u.WriteRegisterData.data = 0;
+                status = gcvSTATUS_CHIP_NOT_READY;
+            }
+            gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->hardware->powerMutex));
+        }
 #else
         /* No access from user land to write registers. */
         status = gcvSTATUS_NOT_SUPPORTED;
@@ -1214,6 +1608,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_QueryProfileRegisters(
                 Kernel->hardware,
+                Kernel->profileCleanRegister,
                 &Interface->u.RegisterProfileData.counters));
 #else
         status = gcvSTATUS_OK;
@@ -1226,7 +1621,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_ProfileEngine2D(
                 Kernel->hardware,
-                Interface->u.RegisterProfileData2D.hwProfile2D));
+                gcmUINT64_TO_PTR(Interface->u.RegisterProfileData2D.hwProfile2D)));
 #else
         status = gcvSTATUS_OK;
 #endif
@@ -1245,7 +1640,6 @@ gckKERNEL_Dispatch(
 
         status = gcvSTATUS_OK;
         break;
-
     case gcvHAL_SET_PROFILE_SETTING:
 #if VIVANTE_PROFILER
         /* Set profile setting */
@@ -1260,6 +1654,15 @@ gckKERNEL_Dispatch(
         status = gcvSTATUS_OK;
         break;
 
+#if VIVANTE_PROFILER_PERDRAW
+    case gcvHAL_READ_PROFILER_REGISTER_SETTING:
+    #if VIVANTE_PROFILER
+        Kernel->profileCleanRegister = Interface->u.SetProfilerRegisterClear.bclear;
+    #endif
+        status = gcvSTATUS_OK;
+        break;
+#endif
+
     case gcvHAL_QUERY_KERNEL_SETTINGS:
         /* Get kernel settings. */
         gcmkONERROR(
@@ -1310,7 +1713,11 @@ gckKERNEL_Dispatch(
             {
                 Interface->u.ReadRegisterData.data = 1;
                 gcmkVERIFY_OK(
-                    gckOS_DumpGPUState(Kernel->os, Kernel->core));
+                    gckHARDWARE_DumpGPUState(Kernel->hardware));
+#if gcdVIRTUAL_COMMAND_BUFFER
+                gcmkVERIFY_OK(
+                    gckCOMMAND_DumpExecutingBuffer(Kernel->command));
+#endif
             }
             else
             {
@@ -1322,19 +1729,22 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_DUMP_EVENT:
         /* Dump GPU event */
-        gcmkVERIFY_OK(
-            gckEVENT_Dump(Kernel->eventObj));
+        gcmkVERIFY_OK(gckEVENT_Dump(Kernel->eventObj));
+
+        /* Dump Process DB. */
+        gcmkVERIFY_OK(gckKERNEL_DumpProcessDB(Kernel));
         break;
 
     case gcvHAL_CACHE:
-        if (Interface->u.Cache.node == gcvNULL)
+        node = gcmUINT64_TO_PTR(Interface->u.Cache.node);
+        if (node == gcvNULL)
         {
             /* FIXME Surface wrap some memory which is not allocated by us,
             ** So we don't have physical address to handle outer cache, ignore it*/
             status = gcvSTATUS_OK;
             break;
         }
-        else if (Interface->u.Cache.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        else if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Video memory has no physical handles. */
             physical = gcvNULL;
@@ -1342,9 +1752,11 @@ gckKERNEL_Dispatch(
         else
         {
             /* Grab physical handle. */
-            physical = Interface->u.Cache.node->Virtual.physical;
+            physical = node->Virtual.physical;
         }
 
+        logical = gcmUINT64_TO_PTR(Interface->u.Cache.logical);
+        bytes = (gctSIZE_T) Interface->u.Cache.bytes;
         switch(Interface->u.Cache.operation)
         {
         case gcvCACHE_FLUSH:
@@ -1353,8 +1765,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_CLEAN:
             /* Clean the cache. */
@@ -1362,8 +1774,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_INVALIDATE:
             /* Invalidate the cache. */
@@ -1371,13 +1783,13 @@ gckKERNEL_Dispatch(
                                            processID,
                                            physical,
                                            paddr,
-                                           Interface->u.Cache.logical,
-                                           Interface->u.Cache.bytes);
+                                           logical,
+                                           bytes);
             break;
 
 	case gcvCACHE_MEMORY_BARRIER:
 	   status = gckOS_MemoryBarrier(Kernel->os,
-                                        Interface->u.Cache.logical);
+                                        logical);
 	   break;
         default:
             status = gcvSTATUS_INVALID_ARGUMENT;
@@ -1477,14 +1889,17 @@ gckKERNEL_Dispatch(
         /* Attach user process. */
         gcmkONERROR(
             gckCOMMAND_Attach(Kernel->command,
-                              &Interface->u.Attach.context,
-                              &Interface->u.Attach.stateCount,
+                              &context,
+                              &bytes,
                               processID));
 
+        Interface->u.Attach.stateCount = bytes;
+        Interface->u.Attach.context = gcmPTR_TO_NAME(context);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_CONTEXT,
-                                   Interface->u.Attach.context,
+                                   gcmINT2PTR(Interface->u.Attach.context),
                                    gcvNULL,
                                    0));
         break;
@@ -1493,15 +1908,18 @@ gckKERNEL_Dispatch(
         /* Detach user process. */
         gcmkONERROR(
             gckCOMMAND_Detach(Kernel->command,
-                              Interface->u.Detach.context));
+                              gcmNAME_TO_PTR(Interface->u.Detach.context)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                               processID, gcvDB_CONTEXT,
-                              Interface->u.Detach.context));
+                              gcmINT2PTR(Interface->u.Detach.context)));
+
+        gcmRELEASE_NAME(Interface->u.Detach.context);
         break;
 
     case gcvHAL_COMPOSE:
+        Interface->u.Compose.physical = gcmPTR_TO_UINT64(gcmNAME_TO_PTR(Interface->u.Compose.physical));
         /* Start composition. */
         gcmkONERROR(
             gckEVENT_Compose(Kernel->eventObj,
@@ -1517,11 +1935,13 @@ gckKERNEL_Dispatch(
     case gcvHAL_GET_FRAME_INFO:
         gcmkONERROR(gckHARDWARE_GetFrameInfo(
             Kernel->hardware,
-            Interface->u.GetFrameInfo.frameInfo));
+            gcmUINT64_TO_PTR(Interface->u.GetFrameInfo.frameInfo)));
         break;
 #endif
 
     case gcvHAL_GET_SHARED_INFO:
+        bytes = (gctSIZE_T) Interface->u.GetSharedInfo.size;
+
         if (Interface->u.GetSharedInfo.dataId != 0)
         {
             gcmkONERROR(gckKERNEL_FindProcessDB(Kernel,
@@ -1532,7 +1952,7 @@ gckKERNEL_Dispatch(
                         &record));
 
             /* find a record in db, check size */
-            if (record.bytes != Interface->u.GetSharedInfo.size)
+            if (record.bytes != bytes)
             {
                 /* Size change is not allowed */
                 gcmkONERROR(gcvSTATUS_INVALID_DATA);
@@ -1542,13 +1962,13 @@ gckKERNEL_Dispatch(
             gcmkONERROR(gckOS_CopyToUserData(
                 Kernel->os,
                 record.physical,
-                Interface->u.GetSharedInfo.data,
-                Interface->u.GetSharedInfo.size
+                gcmUINT64_TO_PTR(Interface->u.GetSharedInfo.data),
+                bytes
                 ));
 
         }
 
-        if ((node = Interface->u.GetSharedInfo.node) != gcvNULL)
+        if ((node = gcmUINT64_TO_PTR(Interface->u.GetSharedInfo.node)) != gcvNULL)
         {
             switch (Interface->u.GetSharedInfo.infoType)
                 {
@@ -1567,7 +1987,7 @@ gckKERNEL_Dispatch(
                          gcmkONERROR(gckOS_CopyToUserData(
                              Kernel->os,
                              data,
-                             Interface->u.GetSharedInfo.nodeData,
+                             gcmUINT64_TO_PTR(Interface->u.GetSharedInfo.nodeData),
                              sizeof(gcsVIDMEM_NODE_SHARED_INFO)
                              ));
                     }
@@ -1605,7 +2025,7 @@ gckKERNEL_Dispatch(
                         gcmkONERROR(gckOS_CopyToUserData(
                             Kernel->os,
                             &alignedSharedInfo,
-                            Interface->u.GetSharedInfo.nodeData,
+                            gcmUINT64_TO_PTR(Interface->u.GetSharedInfo.nodeData),
                             sizeof(gcsVIDMEM_NODE_SHARED_INFO)
                             ));
 
@@ -1628,6 +2048,8 @@ gckKERNEL_Dispatch(
         break;
 
     case gcvHAL_SET_SHARED_INFO:
+        bytes = (gctSIZE_T) Interface->u.SetSharedInfo.size;
+
         if (Interface->u.SetSharedInfo.dataId != 0)
         {
             status = gckKERNEL_FindProcessDB(Kernel, processID, 0,
@@ -1641,7 +2063,7 @@ gckKERNEL_Dispatch(
                 /* Note: we count on DestoryProcessDB to free it */
                 gcmkONERROR(gckOS_AllocateMemory(
                     Kernel->os,
-                    Interface->u.SetSharedInfo.size,
+                    bytes,
                     &data
                     ));
 
@@ -1650,7 +2072,7 @@ gckKERNEL_Dispatch(
                         gcvDB_SHARED_INFO,
                         gcmINT2PTR(Interface->u.SetSharedInfo.dataId),
                         data,
-                        Interface->u.SetSharedInfo.size
+                        bytes
                         ));
             }
             else
@@ -1659,7 +2081,7 @@ gckKERNEL_Dispatch(
                 gcmkONERROR(status);
 
                 /* find a record in db, check size */
-                if (record.bytes != Interface->u.SetSharedInfo.size)
+                if (record.bytes != bytes)
                 {
                     /* Size change is not allowed */
                     gcmkONERROR(gcvSTATUS_INVALID_DATA);
@@ -1672,12 +2094,12 @@ gckKERNEL_Dispatch(
             gcmkONERROR(gckOS_CopyFromUserData(
                 Kernel->os,
                 data,
-                Interface->u.SetSharedInfo.data,
-                Interface->u.SetSharedInfo.size
+                gcmUINT64_TO_PTR(Interface->u.SetSharedInfo.data),
+                bytes
                 ));
         }
 
-        if ((node = Interface->u.SetSharedInfo.node) != gcvNULL)
+        if ((node = gcmUINT64_TO_PTR(Interface->u.SetSharedInfo.node)) != gcvNULL)
         {
             switch (Interface->u.SetSharedInfo.infoType)
                 {
@@ -1695,7 +2117,7 @@ gckKERNEL_Dispatch(
                         gcmkONERROR(gckOS_CopyFromUserData(
                             Kernel->os,
                             data,
-                            Interface->u.SetSharedInfo.nodeData,
+                            gcmUINT64_TO_PTR(Interface->u.SetSharedInfo.nodeData),
                             sizeof(gcsVIDMEM_NODE_SHARED_INFO)
                             ));
                     }
@@ -1711,7 +2133,7 @@ gckKERNEL_Dispatch(
                         gcmkONERROR(gckOS_CopyFromUserData(
                             Kernel->os,
                             &newSharedInfo,
-                            Interface->u.SetSharedInfo.nodeData,
+                            gcmUINT64_TO_PTR(Interface->u.SetSharedInfo.nodeData),
                             gcmSIZEOF(gcsVIDMEM_NODE_SHARED_INFO)
                             ));
 
@@ -1763,6 +2185,33 @@ gckKERNEL_Dispatch(
 
         break;
 
+    case gcvHAL_SET_FSCALE_VALUE:
+#if gcdENABLE_FSCALE_VAL_ADJUST
+        status = gckHARDWARE_SetFscaleValue(Kernel->hardware,
+                                            Interface->u.SetFscaleValue.value);
+#else
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
+        break;
+    case gcvHAL_GET_FSCALE_VALUE:
+#if gcdENABLE_FSCALE_VAL_ADJUST
+        status = gckHARDWARE_GetFscaleValue(Kernel->hardware,
+                                            &Interface->u.GetFscaleValue.value,
+                                            &Interface->u.GetFscaleValue.minValue,
+                                            &Interface->u.GetFscaleValue.maxValue);
+#else
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
+        break;
+
+    case gcvHAL_QUERY_RESET_TIME_STAMP:
+#if gcdENABLE_RECOVERY
+        Interface->u.QueryResetTimeStamp.timeStamp = Kernel->resetTimeStamp;
+#else
+        Interface->u.QueryResetTimeStamp.timeStamp = 0;
+#endif
+        break;
+
     default:
         /* Invalid command. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -1779,7 +2228,7 @@ OnError:
             /* Roll back the lock. */
             gcmkVERIFY_OK(
                 gckVIDMEM_Unlock(Kernel,
-                                 Interface->u.LockVideoMemory.node,
+                                 gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                  gcvSURF_TYPE_UNKNOWN,
                                  &asynchronous));
 
@@ -1788,7 +2237,7 @@ OnError:
                 /* Bottom Half */
                 gcmkVERIFY_OK(
                     gckVIDMEM_Unlock(Kernel,
-                                     Interface->u.LockVideoMemory.node,
+                                     gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                      gcvSURF_TYPE_UNKNOWN,
                                      gcvNULL));
             }
@@ -1923,6 +2372,24 @@ gckKERNEL_AttachProcessEx(
             Kernel->db->lastProcessID = PID;
         }
 
+#if gcdENABLE_VG
+        if (Kernel->vg == gcvNULL)
+#endif
+        {
+            status = gckEVENT_Submit(Kernel->eventObj, gcvTRUE, gcvFALSE);
+
+            if (status == gcvSTATUS_INTERRUPTED && Kernel->eventObj->submitTimer)
+            {
+                gcmkONERROR(gckOS_StartTimer(Kernel->os,
+                                             Kernel->eventObj->submitTimer,
+                                             1));
+            }
+            else
+            {
+                gcmkONERROR(status);
+            }
+        }
+
         /* Decrement the number of clients attached. */
         gcmkONERROR(
             gckOS_AtomDecrement(Kernel->os, Kernel->atomClients, &old));
@@ -2470,6 +2937,7 @@ gckKERNEL_Recovery(
     )
 {
 #if gcdENABLE_RECOVERY
+#define gcdEVENT_MASK 0x3FFFFFFF
     gceSTATUS status;
     gckEVENT eventObj;
     gckHARDWARE hardware;
@@ -2477,7 +2945,7 @@ gckKERNEL_Recovery(
     gctUINT32 processID;
     gcskSECURE_CACHE_PTR cache;
 #endif
-
+    gctUINT32 oldValue;
     gcmkHEADER_ARG("Kernel=0x%x", Kernel);
 
     /* Validate the arguemnts. */
@@ -2491,22 +2959,6 @@ gckKERNEL_Recovery(
     hardware = Kernel->hardware;
     gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
 
-    /* Handle all outstanding events now. */
-#if gcdSMP
-    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, ~0U));
-#else
-    eventObj->pending = ~0U;
-#endif
-    gcmkONERROR(gckEVENT_Notify(eventObj, 1));
-
-    /* Again in case more events got submitted. */
-#if gcdSMP
-    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, ~0U));
-#else
-    eventObj->pending = ~0U;
-#endif
-    gcmkONERROR(gckEVENT_Notify(eventObj, 2));
-
 #if gcdSECURE_USER
     /* Flush the secure mapping cache. */
     gcmkONERROR(gckOS_GetProcessID(&processID));
@@ -2514,6 +2966,23 @@ gckKERNEL_Recovery(
     gcmkONERROR(gckKERNEL_FlushTranslationCache(Kernel, cache, gcvNULL, 0));
 #endif
 
+    gcmkONERROR(
+        gckOS_AtomicExchange(Kernel->os, Kernel->resetAtom, 1, &oldValue));
+
+    if (oldValue)
+    {
+        /* Some one else will recovery GPU. */
+        return gcvSTATUS_OK;
+    }
+
+    /* Start a timer to clear reset flag, before timer is expired,
+    ** other recovery request is ignored. */
+    gcmkVERIFY_OK(
+        gckOS_StartTimer(Kernel->os,
+                         Kernel->resetFlagClearTimer,
+                         gcdGPU_TIMEOUT - 500));
+
+
     /* Try issuing a soft reset for the GPU. */
     status = gckHARDWARE_Reset(hardware);
     if (status == gcvSTATUS_NOT_SUPPORTED)
@@ -2530,6 +2999,24 @@ gckKERNEL_Recovery(
         gcmkONERROR(status);
     }
 
+    /* Handle all outstanding events now. */
+#if gcdSMP
+    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
+#else
+    eventObj->pending = gcdEVENT_MASK;
+#endif
+    gcmkONERROR(gckEVENT_Notify(eventObj, 1));
+
+    /* Again in case more events got submitted. */
+#if gcdSMP
+    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
+#else
+    eventObj->pending = gcdEVENT_MASK;
+#endif
+    gcmkONERROR(gckEVENT_Notify(eventObj, 2));
+
+    Kernel->resetTimeStamp++;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -2728,8 +3215,691 @@ gckKERNEL_SetTimeOut(
     gcmkFOOTER_NO();
 }
 
-
-
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckKERNEL_AllocateVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    )
+{
+    gckOS os = Kernel->os;
+    gceSTATUS status;
+    gctPOINTER logical;
+    gctSIZE_T pageCount;
+    gctSIZE_T bytes = *Bytes;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+
+    gcmkHEADER_ARG("Os=0x%X InUserSpace=%d *Bytes=%lu",
+                   os, InUserSpace, gcmOPT_VALUE(Bytes));
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes != gcvNULL);
+    gcmkVERIFY_ARGUMENT(*Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+    gcmkONERROR(gckOS_Allocate(os,
+                               sizeof(gckVIRTUAL_COMMAND_BUFFER),
+                               (gctPOINTER)&buffer));
+
+    gcmkONERROR(gckOS_ZeroMemory(buffer, sizeof(gckVIRTUAL_COMMAND_BUFFER)));
+
+    gcmkONERROR(gckOS_AllocatePagedMemoryEx(os,
+                                            gcvFALSE,
+                                            bytes,
+                                            &buffer->physical));
+
+    if (InUserSpace)
+    {
+        gcmkONERROR(gckOS_LockPages(os,
+                                    buffer->physical,
+                                    bytes,
+                                    gcvFALSE,
+                                    &logical,
+                                    &pageCount));
+
+        *Logical =
+        buffer->userLogical = logical;
+    }
+    else
+    {
+        gcmkONERROR(
+            gckOS_CreateKernelVirtualMapping(buffer->physical,
+                                             &pageCount,
+                                             &logical));
+        *Logical =
+        buffer->kernelLogical = logical;
+    }
+
+    buffer->pageCount = pageCount;
+    buffer->kernel = Kernel;
+
+    gcmkONERROR(gckOS_GetProcessID(&buffer->pid));
+
+    gcmkONERROR(gckMMU_AllocatePages(Kernel->mmu,
+                                     pageCount,
+                                     &buffer->pageTable,
+                                     &buffer->gpuAddress));
+
+    gcmkONERROR(gckOS_MapPagesEx(os,
+                                 Kernel->core,
+                                 buffer->physical,
+                                 pageCount,
+                                 buffer->pageTable));
+
+    gcmkONERROR(gckMMU_Flush(Kernel->mmu));
+
+    *Physical = buffer;
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_KERNEL,
+                   "gpuAddress = %x pageCount = %d kernelLogical = %x userLogical=%x",
+                   buffer->gpuAddress, buffer->pageCount,
+                   buffer->kernelLogical, buffer->userLogical);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    if (Kernel->virtualBufferHead == gcvNULL)
+    {
+        Kernel->virtualBufferHead =
+        Kernel->virtualBufferTail = buffer;
+    }
+    else
+    {
+        buffer->prev = Kernel->virtualBufferTail;
+        Kernel->virtualBufferTail->next = buffer;
+        Kernel->virtualBufferTail = buffer;
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Kernel->virtualBufferLock));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (buffer->gpuAddress)
+    {
+        gcmkVERIFY_OK(
+            gckMMU_FreePages(Kernel->mmu, buffer->pageTable, buffer->pageCount));
+    }
+
+    if (buffer->userLogical)
+    {
+        gcmkVERIFY_OK(
+            gckOS_UnlockPages(os, buffer->physical, bytes, buffer->userLogical));
+    }
+
+    if (buffer->kernelLogical)
+    {
+        gcmkVERIFY_OK(
+            gckOS_DestroyKernelVirtualMapping(buffer->kernelLogical));
+    }
+
+    if (buffer->physical)
+    {
+        gcmkVERIFY_OK(gckOS_FreePagedMemory(os, buffer->physical, bytes));
+    }
+
+    gcmkVERIFY_OK(gckOS_Free(os, buffer));
+
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_DestroyVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    )
+{
+    gckOS os;
+    gckKERNEL kernel;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer = (gckVIRTUAL_COMMAND_BUFFER_PTR)Physical;
+
+    gcmkHEADER();
+    gcmkVERIFY_ARGUMENT(buffer != gcvNULL);
+
+    kernel = buffer->kernel;
+    os = kernel->os;
+
+    if (buffer->userLogical)
+    {
+        gcmkVERIFY_OK(gckOS_UnlockPages(os, buffer->physical, Bytes, Logical));
+    }
+    else
+    {
+        gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(Logical));
+    }
+
+    gcmkVERIFY_OK(
+        gckMMU_FreePages(kernel->mmu, buffer->pageTable, buffer->pageCount));
+
+    gcmkVERIFY_OK(gckOS_FreePagedMemory(os, buffer->physical, Bytes));
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, kernel->virtualBufferLock, gcvINFINITE));
+
+    if (buffer == kernel->virtualBufferHead)
+    {
+        if ((kernel->virtualBufferHead = buffer->next) == gcvNULL)
+        {
+            kernel->virtualBufferTail = gcvNULL;
+        }
+    }
+    else
+    {
+        buffer->prev->next = buffer->next;
+
+        if (buffer == kernel->virtualBufferTail)
+        {
+            kernel->virtualBufferTail = buffer->prev;
+        }
+        else
+        {
+            buffer->next->prev = buffer->prev;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, kernel->virtualBufferLock));
+
+    gcmkVERIFY_OK(gckOS_Free(os, buffer));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckKERNEL_GetGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    )
+{
+    gceSTATUS status;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctPOINTER start;
+    gctINT pid;
+
+    gcmkHEADER_ARG("Logical = %x", Logical);
+
+    gckOS_GetProcessID(&pid);
+
+    status = gcvSTATUS_INVALID_ADDRESS;
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    /* Walk all command buffer. */
+    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    {
+        if (buffer->userLogical)
+        {
+            start = buffer->userLogical;
+        }
+        else
+        {
+            start = buffer->kernelLogical;
+        }
+
+        if (Logical >= start
+        && (Logical < (start + buffer->pageCount * 4096))
+        && pid == buffer->pid
+        )
+        {
+            * Address = buffer->gpuAddress + (Logical - start);
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+
+    gcmkFOOTER_NO();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    )
+{
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 start;
+    gceSTATUS status = gcvSTATUS_NOT_SUPPORTED;
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    /* Walk all command buffers. */
+    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    {
+        start = (gctUINT32)buffer->gpuAddress;
+
+        if (GpuAddress >= start && GpuAddress < (start + buffer->pageCount * 4096))
+        {
+            /* Find a range matched. */
+            *Buffer = buffer;
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+
+    return status;
+}
+#endif
+
+#if gcdLINK_QUEUE_SIZE
+static void
+gckLINKQUEUE_Dequeue(
+    IN gckLINKQUEUE LinkQueue
+    )
+{
+    gcmASSERT(LinkQueue->count == gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count--;
+    LinkQueue->front = (LinkQueue->front + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    )
+{
+    if (LinkQueue->count == gcdLINK_QUEUE_SIZE)
+    {
+        gckLINKQUEUE_Dequeue(LinkQueue);
+    }
+
+    gcmkASSERT(LinkQueue->count < gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count++;
+
+    LinkQueue->data[LinkQueue->rear].start = start;
+    LinkQueue->data[LinkQueue->rear].end = end;
+
+    gcmkVERIFY_OK(
+        gckOS_GetProcessID(&LinkQueue->data[LinkQueue->rear].pid));
+
+    LinkQueue->rear = (LinkQueue->rear + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    )
+{
+    gcmkASSERT(Index >= 0 && Index < gcdLINK_QUEUE_SIZE);
+
+    *Data = &LinkQueue->data[(Index + LinkQueue->front) % gcdLINK_QUEUE_SIZE];
+}
+#endif
+
+/******************************************************************************\
+*************************** Pointer - ID translation ***************************
+\******************************************************************************/
+#define gcdID_TABLE_LENGTH 1024
+typedef struct _gcsINTEGERDB * gckINTEGERDB;
+typedef struct _gcsINTEGERDB
+{
+    gckOS                       os;
+    gctPOINTER*                 table;
+    gctPOINTER                  mutex;
+    gctUINT32                   tableLen;
+    gctUINT32                   currentID;
+    gctUINT32                   unused;
+}
+gcsINTEGERDB;
+
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = gcvNULL;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Allocate a database. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gcsINTEGERDB), (gctPOINTER *)&database));
+
+    gckOS_ZeroMemory(database, gcmSIZEOF(gcsINTEGERDB));
+
+    /* Allocate a pointer table. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH, (gctPOINTER *)&database->table));
+
+    gckOS_ZeroMemory(database->table, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+    /* Allocate a database mutex. */
+    gcmkONERROR(gckOS_CreateMutex(Kernel->os, &database->mutex));
+
+    /* Initialize. */
+    database->currentID = 0;
+    database->unused = gcdID_TABLE_LENGTH;
+    database->os = Kernel->os;
+    database->tableLen = gcdID_TABLE_LENGTH;
+
+    *Database = database;
+
+    gcmkFOOTER_ARG("*Database=0x%08X", *Database);
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Rollback. */
+    if (database)
+    {
+        if (database->table)
+        {
+            gcmkOS_SAFE_FREE(Kernel->os, database->table);
+        }
+
+        gcmkOS_SAFE_FREE(Kernel->os, database);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    )
+{
+    gckINTEGERDB database = Database;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Destroy pointer table. */
+    gcmkOS_SAFE_FREE(Kernel->os, database->table);
+
+    /* Destroy database mutex. */
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, database->mutex));
+
+    /* Destroy database. */
+    gcmkOS_SAFE_FREE(Kernel->os, database);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctUINT32 i, unused, currentID, tableLen;
+    gctPOINTER * table;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Pointer=0x%08X", Database, Pointer);
+
+    gcmkVERIFY_ARGUMENT(Id != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (database->unused < 1)
+    {
+        /* Extend table. */
+        gcmkONERROR(
+            gckOS_Allocate(os,
+                           gcmSIZEOF(gctPOINTER) * (database->tableLen + gcdID_TABLE_LENGTH),
+                           (gctPOINTER *)&table));
+
+        gckOS_ZeroMemory(table + database->tableLen,
+                         gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+        /* Copy data from old table. */
+        gckOS_MemCopy(table,
+                      database->table,
+                      database->tableLen * gcmSIZEOF(gctPOINTER));
+
+        gcmkOS_SAFE_FREE(os, database->table);
+
+        /* Update databse with new allocated table. */
+        database->table = table;
+        database->currentID = database->tableLen;
+        database->tableLen += gcdID_TABLE_LENGTH;
+        database->unused += gcdID_TABLE_LENGTH;
+    }
+
+    table = database->table;
+    currentID = database->currentID;
+    tableLen = database->tableLen;
+    unused = database->unused;
+
+    /* Connect id with pointer. */
+    table[currentID] = Pointer;
+
+    *Id = currentID + 1;
+
+    /* Update the currentID. */
+    if (--unused > 0)
+    {
+        for (i = 0; i < tableLen; i++)
+        {
+            if (++currentID >= tableLen)
+            {
+                /* Wrap to the begin. */
+                currentID = 0;
+            }
+
+            if (table[currentID] == gcvNULL)
+            {
+                break;
+            }
+        }
+    }
+
+    database->table = table;
+    database->currentID = currentID;
+    database->tableLen = tableLen;
+    database->unused = unused;
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_ARG("*Id=%d", *Id);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    database->table[Id] = gcvNULL;
+
+    if (database->unused++ == 0)
+    {
+        database->currentID = Id;
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctPOINTER pointer;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+    gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    pointer = database->table[Id];
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    if (pointer)
+    {
+        *Pointer = pointer;
+    }
+    else
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    gcmkFOOTER_ARG("*Pointer=0x%08X", *Pointer);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    )
+{
+    gceSTATUS status;
+    gctUINT32 name;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Pointer=0x%X", Kernel, Pointer);
+
+    gcmkONERROR(
+        gckKERNEL_AllocateIntegerId(database, Pointer, &name));
+
+    gcmkFOOTER_ARG("name=%d", name);
+    return name;
+
+OnError:
+    gcmkFOOTER();
+    return 0;
+}
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer = gcvNULL;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=%d", Kernel, Name);
+
+    /* Lookup in database to get pointer. */
+    gcmkONERROR(gckKERNEL_QueryIntegerId(database, Name, &pointer));
+
+    gcmkFOOTER_ARG("pointer=0x%X", pointer);
+    return pointer;
+
+OnError:
+    gcmkFOOTER();
+    return gcvNULL;
+}
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=0x%X", Kernel, Name);
+
+    /* Free name if exists. */
+    gcmkVERIFY_OK(gckKERNEL_FreeIntegerId(database, Name));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
 /*******************************************************************************
 ***** Test Code ****************************************************************
 *******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 0be0c22..1da80b7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_h_
 #define __gc_hal_kernel_h_
 
@@ -64,6 +62,12 @@ extern "C" {
 #define gcdMMU_STLB_64K_MASK        ((~((1U << gcdMMU_STLB_64K_SHIFT)-1)) ^ gcdMMU_MTLB_MASK)
 #define gcdMMU_PAGE_64K_MASK        (gcdMMU_PAGE_64K_SIZE - 1)
 
+/* Page offset definitions. */
+#define gcdMMU_OFFSET_4K_BITS       (32 - gcdMMU_MTLB_BITS - gcdMMU_STLB_4K_BITS)
+#define gcdMMU_OFFSET_4K_MASK       ((1U << gcdMMU_OFFSET_4K_BITS) - 1)
+#define gcdMMU_OFFSET_16K_BITS      (32 - gcdMMU_MTLB_BITS - gcdMMU_STLB_16K_BITS)
+#define gcdMMU_OFFSET_16K_MASK      ((1U << gcdMMU_OFFSET_16K_BITS) - 1)
+
 /*******************************************************************************
 ***** Process Secure Cache ****************************************************/
 
@@ -128,6 +132,7 @@ gcskSECURE_CACHE;
 typedef enum _gceDATABASE_TYPE
 {
     gcvDB_VIDEO_MEMORY = 1,             /* Video memory created. */
+    gcvDB_COMMAND_BUFFER,               /* Command Buffer. */
     gcvDB_NON_PAGED,                    /* Non paged memory. */
     gcvDB_CONTIGUOUS,                   /* Contiguous memory. */
     gcvDB_SIGNAL,                       /* Signal. */
@@ -187,6 +192,9 @@ typedef struct _gcsDATABASE
     /* Secure cache. */
     gcskSECURE_CACHE                    cache;
 #endif
+
+    gctPOINTER                          handleDatabase;
+    gctPOINTER                          handleDatabaseMutex;
 }
 gcsDATABASE;
 
@@ -245,6 +253,63 @@ gckKERNEL_QueryProcessDB(
     OUT gcuDATABASE_INFO * Info
     );
 
+/* Dump the process database. */
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    );
+
+/* ID database */
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    );
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    );
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    );
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    );
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    );
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    );
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
 #if gcdSECURE_USER
 /* Get secure cache from the process database. */
 gceSTATUS
@@ -284,8 +349,29 @@ struct _gckDB
     gctUINT64                   idleTime;
     gctUINT64                   lastSlowdown;
     gctUINT64                   lastSlowdownIdle;
+    /* ID - Pointer database*/
+    gctPOINTER                  pointerDatabase;
+    gctPOINTER                  pointerDatabaseMutex;
 };
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+typedef struct _gckVIRTUAL_COMMAND_BUFFER * gckVIRTUAL_COMMAND_BUFFER_PTR;
+typedef struct _gckVIRTUAL_COMMAND_BUFFER
+{
+    gctPHYS_ADDR                physical;
+    gctPOINTER                  userLogical;
+    gctPOINTER                  kernelLogical;
+    gctSIZE_T                   pageCount;
+    gctPOINTER                  pageTable;
+    gctUINT32                   gpuAddress;
+    gctUINT                     pid;
+    gckVIRTUAL_COMMAND_BUFFER_PTR   next;
+    gckVIRTUAL_COMMAND_BUFFER_PTR   prev;
+    gckKERNEL                   kernel;
+}
+gckVIRTUAL_COMMAND_BUFFER;
+#endif
+
 /* gckKERNEL object. */
 struct _gckKERNEL
 {
@@ -322,6 +408,10 @@ struct _gckKERNEL
 
     /* The profile file name */
     gctCHAR                     profileFileName[gcdMAX_PROFILE_FILE_NAME];
+
+    /* Clear profile register or not*/
+    gctBOOL                     profileCleanRegister;
+
 #endif
 
 #ifdef QNX_SINGLE_THREADED_DEBUGGING
@@ -332,6 +422,12 @@ struct _gckKERNEL
     gckDB                       db;
     gctBOOL                     dbCreated;
 
+#if gcdENABLE_RECOVERY
+    gctPOINTER                  resetFlagClearTimer;
+    gctPOINTER                  resetAtom;
+    gctUINT64                   resetTimeStamp;
+#endif
+
     /* Pointer to gckEVENT object. */
     gcsTIMER                    timers[8];
     gctUINT32                   timeOut;
@@ -339,6 +435,36 @@ struct _gckKERNEL
 #if gcdENABLE_VG
     gckVGKERNEL                 vg;
 #endif
+
+#if gcdVIRTUAL_COMMAND_BUFFER
+    gckVIRTUAL_COMMAND_BUFFER_PTR virtualBufferHead;
+    gckVIRTUAL_COMMAND_BUFFER_PTR virtualBufferTail;
+    gctPOINTER                    virtualBufferLock;
+#endif
+
+#if gcdDVFS
+    gckDVFS                     dvfs;
+#endif
+};
+
+struct _FrequencyHistory
+{
+    gctUINT32                   frequency;
+    gctUINT32                   count;
+};
+
+/* gckDVFS object. */
+struct _gckDVFS
+{
+    gckOS                       os;
+    gckHARDWARE                 hardware;
+    gctPOINTER                  timer;
+    gctUINT32                   pollingTime;
+    gctBOOL                     stop;
+    gctUINT32                   totalConfig;
+    gctUINT32                   loads[8];
+    gctUINT8                    currentScale;
+    struct _FrequencyHistory    frequencyHistory[16];
 };
 
 /* gckCOMMAND object. */
@@ -441,6 +567,8 @@ typedef struct _gcsEVENT
     /* Kernel. */
     gckKERNEL                   kernel;
 #endif
+
+    gctBOOL                     fromKernel;
 }
 gcsEVENT;
 
@@ -519,6 +647,8 @@ struct _gckEVENT
     gcsEVENT_QUEUE_PTR          freeList;
     gcsEVENT_QUEUE              repoList[gcdREPO_LIST_COUNT];
     gctPOINTER                  eventListMutex;
+
+    gctPOINTER                  submitTimer;
 };
 
 /* Free all events belonging to a process. */
@@ -607,24 +737,24 @@ typedef union _gcuVIDMEM_NODE
         gctSIZE_T               pageCount;
 
         /* Used only when node is not contiguous */
-        gctPOINTER              pageTables[gcdCORE_COUNT];
+        gctPOINTER              pageTables[gcdMAX_GPU_COUNT];
         /* Pointer to gckKERNEL object who lock this. */
-        gckKERNEL               lockKernels[gcdCORE_COUNT];
+        gckKERNEL               lockKernels[gcdMAX_GPU_COUNT];
         /* Actual physical address */
-        gctUINT32               addresses[gcdCORE_COUNT];
+        gctUINT32               addresses[gcdMAX_GPU_COUNT];
 
         /* Mutex. */
         gctPOINTER              mutex;
 
         /* Locked counter. */
-        gctINT32                lockeds[gcdCORE_COUNT];
+        gctINT32                lockeds[gcdMAX_GPU_COUNT];
 
 #ifdef __QNXNTO__
         /* Single linked list of nodes. */
         gcuVIDMEM_NODE_PTR      next;
 
         /* Unlock pending flag. */
-        gctBOOL                 unlockPendings[gcdCORE_COUNT];
+        gctBOOL                 unlockPendings[gcdMAX_GPU_COUNT];
 
         /* Free pending flag. */
         gctBOOL                 freePending;
@@ -722,6 +852,51 @@ struct _gckMMU
 #endif
 };
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckOS_CreateKernelVirtualMapping(
+    IN gctPHYS_ADDR Physical,
+    OUT gctSIZE_T * PageCount,
+    OUT gctPOINTER * Logical
+    );
+
+gceSTATUS
+gckOS_DestroyKernelVirtualMapping(
+    IN gctPOINTER Logical
+    );
+
+gceSTATUS
+gckKERNEL_AllocateVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+gceSTATUS
+gckKERNEL_DestroyVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    );
+
+gceSTATUS
+gckKERNEL_GetGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    );
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    );
+#endif
+
 gceSTATUS
 gckKERNEL_AttachProcess(
     IN gckKERNEL Kernel,
@@ -782,6 +957,23 @@ gckCONTEXT_Update(
     IN gcsSTATE_DELTA_PTR StateDelta
     );
 
+#if gcdLINK_QUEUE_SIZE
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    );
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    );
+#endif
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index e341b6e..66ce0d1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_context.h"
 
@@ -30,9 +28,6 @@
 
 #define _GC_OBJ_ZONE            gcvZONE_COMMAND
 
-/* When enabled, extra messages needed by the dump parser are left out. */
-#define gcdSIMPLE_COMMAND_DUMP  1
-
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -68,7 +63,7 @@ _NewQueue(
     newIndex     = (currentIndex + 1) % gcdCOMMAND_QUEUES;
 
     /* Wait for availability. */
-#if gcdDUMP_COMMAND && !gcdSIMPLE_COMMAND_DUMP
+#if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.waitsignal]");
 #endif
 
@@ -253,7 +248,7 @@ _ProcessHints(
         if (Command->hintArrayAllocated &&
             (Command->hintArraySize < CommandBuffer->hintArraySize))
         {
-            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
             Command->hintArraySize = gcvFALSE;
         }
 
@@ -267,18 +262,18 @@ _ProcessHints(
                 &pointer
                 ));
 
-            Command->hintArray          = pointer;
+            Command->hintArray          = gcmPTR_TO_UINT64(pointer);
             Command->hintArrayAllocated = gcvTRUE;
             Command->hintArraySize      = CommandBuffer->hintArraySize;
         }
 
-        hintArray = Command->hintArray;
+        hintArray = gcmUINT64_TO_PTR(Command->hintArray);
         copySize   = hintCount * gcmSIZEOF(gctUINT32);
 
         gcmkONERROR(gckOS_CopyFromUserData(
             Command->os,
             hintArray,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             copySize
             ));
     }
@@ -288,7 +283,7 @@ _ProcessHints(
 
         gcmkONERROR(gckOS_MapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             &pointer
             ));
@@ -314,7 +309,7 @@ OnError:
     {
         gcmkVERIFY_OK(gckOS_UnmapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             hintArray
             ));
@@ -351,6 +346,86 @@ OnError:
     return status;
 }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+static void
+_DumpBuffer(
+    IN gctPOINTER Buffer,
+    IN gctUINT32 GpuAddress,
+    IN gctSIZE_T Size
+    )
+{
+    gctINT i, line, left;
+    gctUINT32_PTR data = Buffer;
+
+    line = Size / 32;
+    left = Size % 32;
+
+
+    for (i = 0; i < line; i++)
+    {
+        gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X %08X ",
+                  GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]);
+        data += 8;
+        GpuAddress += 8 * 4;
+    }
+
+    switch(left)
+    {
+        case 28:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6]);
+            break;
+        case 24:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5]);
+            break;
+        case 20:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4]);
+            break;
+        case 16:
+            gcmkPRINT("%X : %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3]);
+            break;
+        case 12:
+            gcmkPRINT("%X : %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2]);
+            break;
+        case 8:
+            gcmkPRINT("%X : %08X %08X ",
+                      GpuAddress, data[0], data[1]);
+            break;
+        case 4:
+            gcmkPRINT("%X : %08X ",
+                      GpuAddress, data[0]);
+            break;
+        default:
+            break;
+    }
+}
+
+static void
+_DumpKernelCommandBuffer(
+    IN gckCOMMAND Command
+)
+{
+    gctINT i;
+    gctUINT32 physical;
+    gctPOINTER entry;
+
+    for (i = 0; i < gcdCOMMAND_QUEUES; i++)
+    {
+        entry = Command->queues[i].logical;
+
+        gckOS_GetPhysicalAddress(Command->os, entry, &physical);
+
+        gcmkPRINT("Kernel command buffer %d\n", i);
+
+        _DumpBuffer(entry, physical, Command->pageSize);
+    }
+}
+#endif
+
 /******************************************************************************\
 ****************************** gckCOMMAND API Code ******************************
 \******************************************************************************/
@@ -600,7 +675,7 @@ gckCOMMAND_Destroy(
     /* Free state array. */
     if (Command->hintArrayAllocated)
     {
-        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
         Command->hintArrayAllocated = gcvFALSE;
     }
 #endif
@@ -1142,7 +1217,7 @@ gckCOMMAND_Commit(
 
     /* Compute the command buffer entry and the size. */
     commandBufferLogical
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->startOffset;
 
     gcmkONERROR(gckOS_GetPhysicalAddress(
@@ -1815,7 +1890,7 @@ gckCOMMAND_Commit(
 
     /* Determine the location of the LINK command in the command buffer. */
     commandBufferLink
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->offset;
 
     /* Generate a LINK from the end of the command buffer being scheduled
@@ -1914,7 +1989,7 @@ gckCOMMAND_Commit(
         hardware, Command->logical, Command->offset
         ));
 
-#if gcdDUMP_COMMAND && !gcdSIMPLE_COMMAND_DUMP
+#if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.commit]");
 #endif
 #endif /* gcdNULL_DRIVER */
@@ -1953,11 +2028,11 @@ gckCOMMAND_Commit(
 
         /* Append event record to event queue. */
         gcmkONERROR(gckEVENT_AddList(
-            Command->kernel->eventObj, &eventRecord->iface, gcvKERNEL_PIXEL, gcvTRUE
+            Command->kernel->eventObj, &eventRecord->iface, gcvKERNEL_PIXEL, gcvTRUE, gcvFALSE
             ));
 
         /* Next record in the queue. */
-        nextEventRecord = eventRecord->next;
+        nextEventRecord = gcmUINT64_TO_PTR(eventRecord->next);
 
         if (!needCopy)
         {
@@ -1972,17 +2047,19 @@ gckCOMMAND_Commit(
         EventQueue = nextEventRecord;
     }
 
+#if gcdPOWER_MANAGEMENT
     if (Command->kernel->eventObj->queueHead == gcvNULL)
     {
         /* Commit done event by which work thread knows all jobs done. */
         gcmkVERIFY_OK(
             gckEVENT_CommitDone(Command->kernel->eventObj, gcvKERNEL_PIXEL));
     }
+#endif
 
     /* Submit events. */
-    status = (gckEVENT_Submit(Command->kernel->eventObj, gcvTRUE, gcvFALSE));
+    status = gckEVENT_Submit(Command->kernel->eventObj, gcvTRUE, gcvFALSE);
 
-    if (status == gcvSTATUS_INTERRUPTED || status == gcvSTATUS_TIMEOUT)
+    if (status == gcvSTATUS_INTERRUPTED)
     {
         gcmkTRACE(
             gcvLEVEL_INFO,
@@ -2307,7 +2384,7 @@ gckCOMMAND_Execute(
         Command->kernel->hardware, Command->logical, Command->offset
         ));
 
-#if gcdDUMP_COMMAND && !gcdSIMPLE_COMMAND_DUMP
+#if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.execute]");
 #endif
 
@@ -2384,7 +2461,7 @@ gckCOMMAND_Stall(
     /* Submit the event queue. */
     gcmkONERROR(gckEVENT_Submit(eventObject, gcvTRUE, FromPower));
 
-#if gcdDUMP_COMMAND && !gcdSIMPLE_COMMAND_DUMP
+#if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.stall]");
 #endif
 
@@ -2478,8 +2555,6 @@ gckCOMMAND_Stall(
         gcmkONERROR(gckOS_Broadcast(
             os, hardware, gcvBROADCAST_GPU_STUCK
             ));
-
-        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
     }
 
     /* Delete the signal. */
@@ -2622,6 +2697,12 @@ gckCOMMAND_Detach(
     /* Construct a gckCONTEXT object. */
     gcmkONERROR(gckCONTEXT_Destroy(Context));
 
+    if (Command->currContext == Context)
+    {
+        /* Detach from gckCOMMAND object if the destoryed context is current context. */
+        Command->currContext = gcvNULL;
+    }
+
     /* Release the context switching mutex. */
     gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexContext));
     acquired = gcvFALSE;
@@ -2643,3 +2724,262 @@ OnError:
     gcmkFOOTER();
     return status;
 }
+
+#if gcdVIRTUAL_COMMAND_BUFFER
+/*******************************************************************************
+**
+**  gckCOMMAND_DumpExecutingBuffer
+**
+**  Dump the command buffer which GPU is executing.
+**
+**  INPUT:
+**
+**      gckCOMMAND Command
+**          Pointer to a gckCOMMAND object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    )
+{
+    gceSTATUS status;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 gpuAddress;
+    gctSIZE_T pageCount;
+    gctPOINTER entry;
+    gckOS os = Command->os;
+    gckKERNEL kernel = Command->kernel;
+#if gcdLINK_QUEUE_SIZE
+    gctINT pid;
+    gctINT i, rear;
+    gctUINT32 start, end;
+    gctUINT32 dumpFront, dumpRear;
+    gckLINKQUEUE queue = &kernel->hardware->linkQueue;
+    gckLINKQUEUE queueMirror;
+    gctUINT32 bytes;
+    gckLINKDATA linkData;
+#endif
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("**** COMMAND BUF DUMP ****\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkVERIFY_OK(gckOS_ReadRegisterEx(os, kernel->core, 0x664, &gpuAddress));
+
+    gcmkPRINT("DMA Address 0x%08X", gpuAddress);
+
+#if gcdLINK_QUEUE_SIZE
+    /* Duplicate queue because it will be changed.*/
+    gcmkONERROR(gckOS_AllocateMemory(os,
+                                     sizeof(struct _gckLINKQUEUE),
+                                     (gctPOINTER *)&queueMirror));
+
+    gcmkONERROR(gckOS_MemCopy(queueMirror,
+                              queue,
+                              sizeof(struct _gckLINKQUEUE)));
+
+    /* If kernel command buffer link to a context buffer, then link to a user command
+    ** buffer, the second link will be in queue first, so we must fix this.
+    **     In Queue:    C1 U1 U2 C2 U3 U4 U5 C3
+    **         Real: C1 X1 U1 C2 U2 U3 U4 C3 U5
+    ** Command buffer X1 which is after C1 is out of queue, so C1 is meaningless.
+    */
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            /* Can't find it in virtual command buffer list, ignore it. */
+            continue;
+        }
+
+        if (buffer->kernelLogical)
+        {
+            /* It is a context buffer. */
+            if (i == 0)
+            {
+                /* The real command buffer is out, so clear this slot. */
+                linkData->start = 0;
+                linkData->end = 0;
+                linkData->pid = 0;
+            }
+            else
+            {
+                /* switch context buffer and command buffer. */
+                struct _gckLINKDATA tmp = *linkData;
+                gckLINKDATA linkDataPrevious;
+
+                gckLINKQUEUE_GetData(queueMirror, i - 1, &linkDataPrevious);
+                *linkData = *linkDataPrevious;
+                *linkDataPrevious = tmp;
+           }
+        }
+    }
+
+    /* Clear search result. */
+    dumpFront = dumpRear = gcvINFINITE;
+
+    gcmkPRINT("Link Stack:");
+
+    /* Search stuck address in link queue from rear. */
+    rear = gcdLINK_QUEUE_SIZE - 1;
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        start = linkData->start;
+        end = linkData->end;
+        pid = linkData->pid;
+
+        if (gpuAddress >= start && gpuAddress < end)
+        {
+            /* Find latest matched command buffer. */
+            gcmkPRINT("  %d, [%08X - %08X]", pid, start, end);
+
+            /* Initiliaze dump information. */
+            dumpFront = dumpRear = rear;
+        }
+
+        /* Advance to previous one. */
+        rear--;
+
+        if (dumpFront != gcvINFINITE)
+        {
+            break;
+        }
+    }
+
+    if (dumpFront == gcvINFINITE)
+    {
+        /* Can't find matched record in link queue, dump kernel command buffer. */
+        _DumpKernelCommandBuffer(Command);
+
+        /* Free local copy. */
+        gcmkOS_SAFE_FREE(os, queueMirror);
+        return gcvSTATUS_OK;
+    }
+
+    /* Search the last context buffer linked. */
+    while (rear >= 0)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        gcmkPRINT("  %d, [%08X - %08X]",
+                  linkData->pid,
+                  linkData->start,
+                  linkData->end);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_SUCCESS(status) && buffer->kernelLogical)
+        {
+            /* Find a context buffer. */
+            dumpFront = rear;
+            break;
+        }
+
+        rear--;
+    }
+
+    /* Dump from last context buffer to last command buffer where hang happens. */
+    for (i = dumpFront; i <= dumpRear; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        /* Get gpu address of this command buffer. */
+        gpuAddress = linkData->start;
+        bytes = linkData->end - gpuAddress;
+
+        /* Get the whole buffer. */
+        status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            gcmkPRINT("Buffer [%08X - %08X] is lost",
+                      linkData->start,
+                      linkData->end);
+            continue;
+        }
+
+        /* Get kernel logical for dump. */
+        if (buffer->kernelLogical)
+        {
+            /* Get kernel logical directly if it is a context buffer. */
+            entry = buffer->kernelLogical;
+            gcmkPRINT("Context Buffer:");
+        }
+        else
+        {
+            /* Make it accessiable by kernel if it is a user command buffer. */
+            gcmkVERIFY_OK(
+                gckOS_CreateKernelVirtualMapping(buffer->physical,
+                                                 &pageCount,
+                                                 &entry));
+            gcmkPRINT("User Command Buffer:");
+        }
+
+        /* Dump from the entry. */
+        _DumpBuffer(entry + (gpuAddress - buffer->gpuAddress), gpuAddress, bytes);
+
+        /* Release kernel logical address if neccessary. */
+        if (!buffer->kernelLogical)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(entry));
+        }
+    }
+
+    /* Free local copy. */
+    gcmkOS_SAFE_FREE(os, queueMirror);
+    return gcvSTATUS_OK;
+OnError:
+    return status;
+#else
+    /* Without link queue information, we don't know the entry of last command
+    ** buffer, just dump the page where GPU stuck. */
+    status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+    if (gcmIS_SUCCESS(status))
+    {
+        gcmkVERIFY_OK(
+            gckOS_CreateKernelVirtualMapping(buffer->physical, &pageCount, &entry));
+
+        if (entry)
+        {
+            gctUINT32 offset = gpuAddress - buffer->gpuAddress;
+            gctPOINTER entryDump = entry;
+
+            /* Dump one pages. */
+            gctUINT32 bytes = 4096;
+
+            /* Align to page. */
+            offset &= 0xfffff000;
+
+            /* Kernel address of page where stall point stay. */
+            entryDump += offset;
+
+            /* Align to page. */
+            gpuAddress &= 0xfffff000;
+
+            gcmkPRINT("User Command Buffer:\n");
+            _DumpBuffer(entryDump, gpuAddress, bytes);
+        }
+
+        gcmkVERIFY_OK(
+            gckOS_DestroyKernelVirtualMapping(entry));
+    }
+    else
+    {
+        _DumpKernelCommandBuffer(Command);
+    }
+
+    return gcvSTATUS_OK;
+#endif
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index 60f50890..9685a5d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
@@ -97,6 +95,30 @@ gcsQUEUE_UPDATE_CONTROL;
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
+static gceSTATUS
+_FlushMMU(
+    IN gckVGCOMMAND Command
+    )
+{
+    gceSTATUS status;
+    gctUINT32 oldValue;
+    gckVGHARDWARE hardware = Command->hardware;
+
+    gcmkONERROR(gckOS_AtomicExchange(Command->os,
+                                     hardware->pageTableDirty,
+                                     0,
+                                     &oldValue));
+
+    if (oldValue)
+    {
+        /* Page Table is upated, flush mmu before commit. */
+        gcmkONERROR(gckVGHARDWARE_FlushMMU(hardware));
+    }
+
+    return gcvSTATUS_OK;
+OnError:
+    return status;
+}
 
 static gceSTATUS
 _WaitForIdle(
@@ -577,6 +599,67 @@ _FreeTaskContainer(
     }
 }
 
+gceSTATUS
+_RemoveRecordFromProcesDB(
+    IN gckVGCOMMAND Command,
+    IN gcsTASK_HEADER_PTR Task
+    )
+{
+    gcsTASK_PTR task = (gcsTASK_PTR)((gctUINT8_PTR)Task - sizeof(gcsTASK));
+    gcsTASK_FREE_VIDEO_MEMORY_PTR freeVideoMemory;
+    gcsTASK_UNLOCK_VIDEO_MEMORY_PTR unlockVideoMemory;
+    gctINT pid;
+    gctUINT32 size;
+
+    /* Get the total size of all tasks. */
+    size = task->size;
+
+    gcmkVERIFY_OK(gckOS_GetProcessID((gctUINT32_PTR)&pid));
+
+    do
+    {
+        switch (Task->id)
+        {
+        case gcvTASK_FREE_VIDEO_MEMORY:
+            freeVideoMemory = (gcsTASK_FREE_VIDEO_MEMORY_PTR)Task;
+
+            /* Remove record from process db. */
+            gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
+                Command->kernel->kernel,
+                pid,
+                gcvDB_VIDEO_MEMORY,
+                gcmUINT64_TO_PTR(freeVideoMemory->node)));
+
+            /* Advance to next task. */
+            size -= sizeof(gcsTASK_FREE_VIDEO_MEMORY);
+            Task = (gcsTASK_HEADER_PTR)(freeVideoMemory + 1);
+
+            break;
+        case gcvTASK_UNLOCK_VIDEO_MEMORY:
+            unlockVideoMemory = (gcsTASK_UNLOCK_VIDEO_MEMORY_PTR)Task;
+
+            /* Remove record from process db. */
+            gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
+                Command->kernel->kernel,
+                pid,
+                gcvDB_VIDEO_MEMORY_LOCKED,
+                gcmUINT64_TO_PTR(unlockVideoMemory->node)));
+
+            /* Advance to next task. */
+            size -= sizeof(gcsTASK_UNLOCK_VIDEO_MEMORY);
+            Task = (gcsTASK_HEADER_PTR)(unlockVideoMemory + 1);
+
+            break;
+        default:
+            /* Skip the whole task. */
+            size = 0;
+            break;
+        }
+    }
+    while(size);
+
+    return gcvSTATUS_OK;
+}
 
 /******************************************************************************\
 ********************************* Task Scheduling ******************************
@@ -701,6 +784,8 @@ _ScheduleTasks(
                 {
                     gcsTASK_HEADER_PTR taskHeader = (gcsTASK_HEADER_PTR) (userTask + 1);
 
+                    gcmkVERIFY_OK(_RemoveRecordFromProcesDB(Command, taskHeader));
+
                     gcmkTRACE_ZONE(
                         gcvLEVEL_VERBOSE, gcvZONE_COMMAND,
                         "    task ID = %d, size = %d\n",
@@ -828,7 +913,7 @@ _HardwareToKernel(
     }
 
     offset = Address - nodePhysical;
-    *KernelPointer = (gctPOINTER)((gctUINT32)Node->VidMem.kernelVirtual + offset);
+    *KernelPointer = (gctPOINTER)((gctUINT8_PTR)Node->VidMem.kernelVirtual + offset);
 #else
     /* Determine the header offset within the pool it is allocated in. */
     offset = Address - memory->baseAddress;
@@ -876,7 +961,7 @@ _ConvertUserCommandBufferPointer(
         /* Translate the logical address to the kernel space. */
         gcmkERR_BREAK(_HardwareToKernel(
             Command->os,
-            mappedUserCommandBuffer->node,
+            gcmUINT64_TO_PTR(mappedUserCommandBuffer->node),
             headerAddress,
             (gctPOINTER *) KernelCommandBuffer
             ));
@@ -1050,7 +1135,7 @@ _AllocateCommandBuffer(
 
         /* Initialize the structure. */
         commandBuffer->completion    = gcvVACANT_BUFFER;
-        commandBuffer->node          = node;
+        commandBuffer->node          = gcmPTR_TO_UINT64(node);
         commandBuffer->address       = address + alignedHeaderSize;
         commandBuffer->bufferOffset  = alignedHeaderSize;
         commandBuffer->size          = requestedSize;
@@ -1105,7 +1190,7 @@ _FreeCommandBuffer(
     gceSTATUS status;
 
     /* Free the buffer. */
-    status = _FreeLinear(Kernel, CommandBuffer->node);
+    status = _FreeLinear(Kernel, gcmUINT64_TO_PTR(CommandBuffer->node));
 
     /* Return status. */
     return status;
@@ -1236,12 +1321,6 @@ _TaskUnmapUserMemory(
     gcsBLOCK_TASK_ENTRY_PTR TaskHeader
     );
 
-static gceSTATUS
-_TaskUnmapMemory(
-    gckVGCOMMAND Command,
-    gcsBLOCK_TASK_ENTRY_PTR TaskHeader
-    );
-
 static gctTASKROUTINE _taskRoutine[] =
 {
     _TaskLink,                  /* gcvTASK_LINK                   */
@@ -1254,7 +1333,6 @@ static gctTASKROUTINE _taskRoutine[] =
     _TaskFreeVideoMemory,       /* gcvTASK_FREE_VIDEO_MEMORY      */
     _TaskFreeContiguousMemory,  /* gcvTASK_FREE_CONTIGUOUS_MEMORY */
     _TaskUnmapUserMemory,       /* gcvTASK_UNMAP_USER_MEMORY      */
-    _TaskUnmapMemory,           /* gcvTASK_UNMAP_MEMORY           */
 };
 
 static gceSTATUS
@@ -1569,7 +1647,7 @@ _TaskUnlockVideoMemory(
         /* Unlock video memory. */
         gcmkERR_BREAK(gckVIDMEM_Unlock(
             Command->kernel->kernel,
-            task->node,
+            gcmUINT64_TO_PTR(task->node),
             gcvSURF_TYPE_UNKNOWN,
             gcvNULL));
 
@@ -1600,7 +1678,7 @@ _TaskFreeVideoMemory(
             = (gcsTASK_FREE_VIDEO_MEMORY_PTR) TaskHeader->task;
 
         /* Free video memory. */
-        gcmkERR_BREAK(gckVIDMEM_Free(task->node));
+        gcmkERR_BREAK(gckVIDMEM_Free(gcmUINT64_TO_PTR(task->node)));
 
         /* Update the reference counter. */
         TaskHeader->container->referenceCount -= 1;
@@ -1660,7 +1738,7 @@ _TaskUnmapUserMemory(
             = (gcsTASK_UNMAP_USER_MEMORY_PTR) TaskHeader->task;
 
         /* Unmap the user memory. */
-        gcmkERR_BREAK(gckOS_UnmapUserMemoryEx(
+        gcmkERR_BREAK(gckOS_UnmapUserMemory(
             Command->os, gcvCORE_VG, task->memory, task->size, task->info, task->address
             ));
 
@@ -1676,38 +1754,6 @@ _TaskUnmapUserMemory(
     return status;
 }
 
-static gceSTATUS
-_TaskUnmapMemory(
-    gckVGCOMMAND Command,
-    gcsBLOCK_TASK_ENTRY_PTR TaskHeader
-    )
-{
-    gceSTATUS status;
-
-    do
-    {
-        /* Cast the task pointer. */
-        gcsTASK_UNMAP_MEMORY_PTR task
-            = (gcsTASK_UNMAP_MEMORY_PTR) TaskHeader->task;
-
-        /* Unmap memory. */
-        gcmkERR_BREAK(gckKERNEL_UnmapMemory(
-            Command->kernel->kernel, task->physical, task->bytes, task->logical
-            ));
-
-        /* Update the reference counter. */
-        TaskHeader->container->referenceCount -= 1;
-
-        /* Update the task pointer. */
-        TaskHeader->task = (gcsTASK_HEADER_PTR) (task + 1);
-    }
-    while (gcvFALSE);
-
-    /* Return status. */
-    return status;
-}
-
-
 /******************************************************************************\
 ************ Hardware Block Interrupt Handlers For Scheduled Events ************
 \******************************************************************************/
@@ -3402,6 +3448,8 @@ gckVGCOMMAND_Commit(
             break;
         }
 #endif
+        gcmkERR_BREAK(_FlushMMU(Command));
+
         do
         {
             /* Assign a context ID if not yet assigned. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index ca53c74..1fb18fb 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_DATABASE
@@ -1085,6 +1083,9 @@ gckKERNEL_DestroyProcessDB(
     gcsDATABASE_PTR database;
     gcsDATABASE_RECORD_PTR record, next;
     gctBOOL asynchronous;
+    gctPHYS_ADDR physical;
+    gcuVIDMEM_NODE_PTR node;
+    gckKERNEL kernel = Kernel;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -1136,7 +1137,7 @@ gckKERNEL_DestroyProcessDB(
         {
         case gcvDB_VIDEO_MEMORY:
             /* Free the video memory. */
-            status = gckVIDMEM_Free(record->data);
+            status = gckVIDMEM_Free(gcmUINT64_TO_PTR(record->data));
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY 0x%x (status=%d)",
@@ -1144,23 +1145,56 @@ gckKERNEL_DestroyProcessDB(
             break;
 
         case gcvDB_NON_PAGED:
+            physical = gcmNAME_TO_PTR(record->physical);
+            /* Unmap user logical memory first. */
+            status = gckOS_UnmapUserLogical(Kernel->os,
+                                            physical,
+                                            record->bytes,
+                                            record->data);
+
             /* Free the non paged memory. */
             status = gckOS_FreeNonPagedMemory(Kernel->os,
                                               record->bytes,
-                                              record->physical,
+                                              physical,
                                               record->data);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: NON_PAGED 0x%x, bytes=%lu (status=%d)",
                            record->data, record->bytes, status);
             break;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+        case gcvDB_COMMAND_BUFFER:
+            /* Free the command buffer. */
+            status = gckEVENT_DestroyVirtualCommandBuffer(record->kernel->eventObj,
+                                                          record->bytes,
+                                                          gcmNAME_TO_PTR(record->physical),
+                                                          record->data,
+                                                          gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
+
+            gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
+                           "DB: COMMAND_BUFFER 0x%x, bytes=%lu (status=%d)",
+                           record->data, record->bytes, status);
+            break;
+#endif
+
         case gcvDB_CONTIGUOUS:
+            physical = gcmNAME_TO_PTR(record->physical);
+            /* Unmap user logical memory first. */
+            status = gckOS_UnmapUserLogical(Kernel->os,
+                                            physical,
+                                            record->bytes,
+                                            record->data);
+
             /* Free the contiguous memory. */
-            status = gckOS_FreeContiguous(Kernel->os,
-                                          record->physical,
-                                          record->data,
-                                          record->bytes);
+            status = gckEVENT_FreeContiguousMemory(Kernel->eventObj,
+                                                   record->bytes,
+                                                   physical,
+                                                   record->data,
+                                                   gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTIGUOUS 0x%x bytes=%lu (status=%d)",
@@ -1178,13 +1212,14 @@ gckKERNEL_DestroyProcessDB(
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: SIGNAL %d (status=%d)",
-                           (gctINT) record->data, status);
+                           (gctINT)(gctUINTPTR_T)record->data, status);
             break;
 
         case gcvDB_VIDEO_MEMORY_LOCKED:
+            node = gcmUINT64_TO_PTR(record->data);
             /* Unlock what we still locked */
             status = gckVIDMEM_Unlock(record->kernel,
-                                      record->data,
+                                      node,
                                       gcvSURF_TYPE_UNKNOWN,
                                       &asynchronous);
 
@@ -1192,19 +1227,20 @@ gckKERNEL_DestroyProcessDB(
             {
                 /* TODO: we maybe need to schedule a event here */
                 status = gckVIDMEM_Unlock(record->kernel,
-                                          record->data,
+                                          node,
                                           gcvSURF_TYPE_UNKNOWN,
                                           gcvNULL);
             }
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY_LOCKED 0x%x (status=%d)",
-                           record->data, status);
+                           node, status);
             break;
 
         case gcvDB_CONTEXT:
             /* TODO: Free the context */
-            status = gckCOMMAND_Detach(Kernel->command, record->data);
+            status = gckCOMMAND_Detach(Kernel->command, gcmNAME_TO_PTR(record->data));
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTEXT 0x%x (status=%d)",
@@ -1225,12 +1261,13 @@ gckKERNEL_DestroyProcessDB(
 
         case gcvDB_MAP_USER_MEMORY:
             /* TODO: Unmap user memory. */
-            status = gckOS_UnmapUserMemoryEx(Kernel->os,
-                                             Kernel->core,
-                                             record->data,
-                                             record->bytes,
-                                             record->physical,
-                                             0);
+            status = gckOS_UnmapUserMemory(Kernel->os,
+                                           Kernel->core,
+                                           record->physical,
+                                           record->bytes,
+                                           gcmNAME_TO_PTR(record->data),
+                                           0);
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: MAP USER MEMORY %d (status=%d)",
@@ -1322,21 +1359,21 @@ gckKERNEL_QueryProcessDB(
     switch (Type)
     {
     case gcvDB_VIDEO_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->vidMem,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_NON_PAGED:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->nonPaged,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_CONTIGUOUS:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->contiguous,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_IDLE:
@@ -1345,15 +1382,15 @@ gckKERNEL_QueryProcessDB(
         break;
 
     case gcvDB_MAP_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapMemory,
-                                  gcmSIZEOF(database->mapMemory)));
+                                  gcmSIZEOF(database->mapMemory));
         break;
 
     case gcvDB_MAP_USER_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapUserMemory,
-                                  gcmSIZEOF(database->mapUserMemory)));
+                                  gcmSIZEOF(database->mapUserMemory));
         break;
 
     default:
@@ -1421,3 +1458,48 @@ OnError:
     return status;
 }
 #endif
+
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    )
+{
+    gcsDATABASE_PTR database;
+    gctINT i, pid;
+    gctUINT8 name[24];
+
+    gcmkHEADER_ARG("Kernel=0x%x", Kernel);
+
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***  PROCESS DB DUMP   ***\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkPRINT_N(8, "%-8s%s\n", "PID", "NAME");
+    /* Walk the databases. */
+    for (i = 0; i < gcmCOUNTOF(Kernel->db->db); ++i)
+    {
+        for (database = Kernel->db->db[i];
+             database != gcvNULL;
+             database = database->next)
+        {
+            pid = database->processID;
+
+            gcmkVERIFY_OK(gckOS_ZeroMemory(name, gcmSIZEOF(name)));
+
+            gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
+
+            gcmkPRINT_N(8, "%-8d%s\n", pid, name);
+        }
+    }
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index 77ea27a..a689bc3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include <gc_hal_kernel_debug.h>
 
@@ -1596,7 +1594,7 @@ _GetOutputBuffer(
 
 #if gcdTHREAD_BUFFERS > 1
     /* Get the current thread ID. */
-    gctUINT32 threadID = gcmkGETTHREADID();
+    gctUINT32 ThreadID = gcmkGETTHREADID();
 
     /* Locate the output buffer for the thread. */
     outputBuffer = _outputBufferHead;
@@ -1629,10 +1627,14 @@ _GetOutputBuffer(
 
         /* Reset the buffer. */
         outputBuffer->threadID   = ThreadID;
+#if gcdBUFFERED_OUTPUT
         outputBuffer->start      = 0;
         outputBuffer->index      = 0;
         outputBuffer->count      = 0;
+#endif
+#if gcdSHOW_LINE_NUMBER
         outputBuffer->lineNumber = 0;
+#endif
     }
 #else
     outputBuffer = _outputBufferHead;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index c83f630..f78d096 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_buffer.h"
 
@@ -140,8 +138,6 @@ OnError:
     return gcvSTATUS_OK;
 }
 
-#ifndef __QNXNTO__
-
 static gceSTATUS
 gckEVENT_IsEmpty(
     IN gckEVENT Event,
@@ -198,30 +194,61 @@ OnError:
     return status;
 }
 
-#endif
-
 static gceSTATUS
 _TryToIdleGPU(
     IN gckEVENT Event
 )
 {
-#ifndef __QNXNTO__
     gceSTATUS status;
     gctBOOL empty = gcvFALSE, idle = gcvFALSE;
+    gctUINT32 process, thread;
+    gctBOOL powerLocked = gcvFALSE;
+    gckHARDWARE hardware;
+
 
     gcmkHEADER_ARG("Event=0x%x", Event);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
 
+    /* Grab gckHARDWARE object. */
+    hardware = Event->kernel->hardware;
+    gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
+
+
     /* Check whether the event queue is empty. */
     gcmkONERROR(gckEVENT_IsEmpty(Event, &empty));
 
     if (empty)
     {
+        status = gckOS_AcquireMutex(hardware->os, hardware->powerMutex, 0);
+        if (status == gcvSTATUS_TIMEOUT)
+        {
+            gcmkONERROR(gckOS_GetProcessID(&process));
+            gcmkONERROR(gckOS_GetThreadID(&thread));
+
+            /* Just return to prevent deadlock. */
+            if ((hardware->powerProcess != process)
+            ||  (hardware->powerThread  != thread))
+            {
+                gcmkFOOTER_NO();
+                return gcvSTATUS_OK;
+            }
+        }
+        else
+        {
+            powerLocked = gcvTRUE;
+        }
+
         /* Query whether the hardware is idle. */
         gcmkONERROR(gckHARDWARE_QueryIdle(Event->kernel->hardware, &idle));
 
+        if (powerLocked)
+        {
+            gcmkONERROR(gckOS_ReleaseMutex(hardware->os, hardware->powerMutex));
+            powerLocked = gcvFALSE;
+        }
+
         if (idle)
         {
             /* Inform the system of idle GPU. */
@@ -235,11 +262,15 @@ _TryToIdleGPU(
     return gcvSTATUS_OK;
 
 OnError:
+
+    if (powerLocked)
+    {
+        gcmkONERROR(gckOS_ReleaseMutex(hardware->os, hardware->powerMutex));
+        powerLocked = gcvFALSE;
+    }
+
     gcmkFOOTER();
     return status;
-#else
-    return gcvSTATUS_OK;
-#endif
 }
 
 static gceSTATUS
@@ -253,6 +284,21 @@ __RemoveRecordFromProcessDB(
 
     while (Record != gcvNULL)
     {
+        if (Record->info.command == gcvHAL_SIGNAL)
+        {
+            /* TODO: Find a better place to bind signal to hardware.*/
+            gcmkVERIFY_OK(gckOS_SignalSetHardware(Event->os,
+                        gcmUINT64_TO_PTR(Record->info.u.Signal.signal),
+                        Event->kernel->hardware));
+        }
+
+        if (Record->fromKernel)
+        {
+            /* No need to check db if event is from kernel. */
+            Record = Record->next;
+            continue;
+        }
+
         switch (Record->info.command)
         {
         case gcvHAL_FREE_NON_PAGED_MEMORY:
@@ -260,7 +306,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_NON_PAGED,
-                Record->info.u.FreeNonPagedMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeNonPagedMemory.logical)));
             break;
 
         case gcvHAL_FREE_CONTIGUOUS_MEMORY:
@@ -268,7 +314,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_CONTIGUOUS,
-                Record->info.u.FreeContiguousMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeContiguousMemory.logical)));
             break;
 
         case gcvHAL_FREE_VIDEO_MEMORY:
@@ -276,7 +322,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY,
-                Record->info.u.FreeVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.FreeVideoMemory.node)));
             break;
 
         case gcvHAL_UNLOCK_VIDEO_MEMORY:
@@ -284,7 +330,23 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY_LOCKED,
-                Record->info.u.UnlockVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.UnlockVideoMemory.node)));
+            break;
+
+        case gcvHAL_UNMAP_USER_MEMORY:
+            gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
+                Event->kernel,
+                Record->processID,
+                gcvDB_MAP_USER_MEMORY,
+                gcmINT2PTR(Record->info.u.UnmapUserMemory.info)));
+            break;
+
+        case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+            gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
+                Event->kernel,
+                Record->processID,
+                gcvDB_COMMAND_BUFFER,
+                gcmUINT64_TO_PTR(Record->info.u.FreeVirtualCommandBuffer.logical)));
             break;
 
         default:
@@ -297,6 +359,15 @@ __RemoveRecordFromProcessDB(
     return gcvSTATUS_OK;
 }
 
+void
+_SubmitTimerFunction(
+    gctPOINTER Data
+    )
+{
+    gckEVENT event = (gckEVENT)Data;
+    gcmkVERIFY_OK(gckEVENT_Submit(event, gcvTRUE, gcvFALSE));
+}
+
 /******************************************************************************\
 ******************************* gckEVENT API Code *******************************
 \******************************************************************************/
@@ -389,6 +460,11 @@ gckEVENT_Construct(
     gcmkONERROR(gckOS_AtomConstruct(os, &eventObj->pending));
 #endif
 
+    gcmkVERIFY_OK(gckOS_CreateTimer(os,
+                                    _SubmitTimerFunction,
+                                    (gctPOINTER)eventObj,
+                                    &eventObj->submitTimer));
+
     /* Return pointer to the gckEVENT object. */
     *Event = eventObj;
 
@@ -470,6 +546,12 @@ gckEVENT_Destroy(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
 
+    if (Event->submitTimer != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_StopTimer(Event->os, Event->submitTimer));
+        gcmkVERIFY_OK(gckOS_DestroyTimer(Event->os, Event->submitTimer));
+    }
+
     /* Delete the queue mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->eventQueueMutex));
 
@@ -531,6 +613,7 @@ gckEVENT_Destroy(
 #if gcdSMP
     gcmkVERIFY_OK(gckOS_AtomDestroy(Event->os, Event->pending));
 #endif
+
     /* Mark the gckEVENT object as unknown. */
     Event->object.type = gcvOBJ_UNKNOWN;
 
@@ -681,11 +764,6 @@ gckEVENT_GetEvent(
                 __FUNCTION__, __LINE__
                 );
 
-            /* Broadcast GPU stuck. */
-            gcmkONERROR(gckOS_Broadcast(Event->os,
-                                        Event->kernel->hardware,
-                                        gcvBROADCAST_GPU_STUCK));
-
             /* Bail out. */
             gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
         }
@@ -820,13 +898,15 @@ gckEVENT_AddList(
     IN gckEVENT Event,
     IN gcsHAL_INTERFACE_PTR Interface,
     IN gceKERNEL_WHERE FromWhere,
-    IN gctBOOL AllocateAllowed
+    IN gctBOOL AllocateAllowed,
+    IN gctBOOL FromKernel
     )
 {
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsEVENT_PTR record = gcvNULL;
     gcsEVENT_QUEUE_PTR queue;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Interface=0x%x",
                    Event, Interface);
@@ -850,6 +930,7 @@ gckEVENT_AddList(
         || (Interface->command == gcvHAL_UNMAP_USER_MEMORY)
         || (Interface->command == gcvHAL_TIMESTAMP)
         || (Interface->command == gcvHAL_COMMIT_DONE)
+        || (Interface->command == gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER)
         );
 
     /* Validate the source. */
@@ -865,8 +946,11 @@ gckEVENT_AddList(
     /* Termninate the record. */
     record->next = gcvNULL;
 
+    /* Record the committer. */
+    record->fromKernel = FromKernel;
+
     /* Copy the event interface into the record. */
-    gcmkONERROR(gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info)));
+    gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info));
 
     /* Get process ID. */
     gcmkONERROR(gckOS_GetProcessID(&record->processID));
@@ -880,7 +964,7 @@ gckEVENT_AddList(
     acquired = gcvTRUE;
 
     /* Do we need to allocate a new queue? */
-    if ((Event->queueTail == gcvNULL) || (Event->queueTail->source != FromWhere))
+    if ((Event->queueTail == gcvNULL) || (Event->queueTail->source < FromWhere))
     {
         /* Allocate a new queue. */
         gcmkONERROR(gckEVENT_AllocateQueue(Event, &queue));
@@ -919,6 +1003,31 @@ gckEVENT_AddList(
         queue->tail       = record;
     }
 
+    /* Unmap user space logical address.
+     * Linux kernel does not support unmap the memory of other process any more since 3.5.
+     * Let's unmap memory of self process before submit the event to gpu.
+     * */
+    switch(Interface->command)
+    {
+    case gcvHAL_FREE_NON_PAGED_MEMORY:
+        gcmkONERROR(gckOS_UnmapUserLogical(
+                        Event->os,
+                        gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
+        break;
+    case gcvHAL_FREE_CONTIGUOUS_MEMORY:
+        gcmkONERROR(gckOS_UnmapUserLogical(
+                        Event->os,
+                        gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
+        break;
+    default:
+        break;
+    }
+
+
     /* Release the mutex. */
     gcmkONERROR(gckOS_ReleaseMutex(Event->os, Event->eventListMutex));
 
@@ -988,12 +1097,12 @@ gckEVENT_Unlock(
 
     /* Mark the event as an unlock. */
     iface.command                           = gcvHAL_UNLOCK_VIDEO_MEMORY;
-    iface.u.UnlockVideoMemory.node          = Node;
+    iface.u.UnlockVideoMemory.node          = gcmPTR_TO_UINT64(Node);
     iface.u.UnlockVideoMemory.type          = Type;
     iface.u.UnlockVideoMemory.asynchroneous = 0;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1045,10 +1154,10 @@ gckEVENT_FreeVideoMemory(
 
     /* Create an event. */
     iface.command = gcvHAL_FREE_VIDEO_MEMORY;
-    iface.u.FreeVideoMemory.node = VideoMemory;
+    iface.u.FreeVideoMemory.node = gcmPTR_TO_UINT64(VideoMemory);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1094,6 +1203,7 @@ gckEVENT_FreeNonPagedMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1108,11 +1218,53 @@ gckEVENT_FreeNonPagedMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_NON_PAGED_MEMORY;
     iface.u.FreeNonPagedMemory.bytes    = Bytes;
-    iface.u.FreeNonPagedMemory.physical = Physical;
-    iface.u.FreeNonPagedMemory.logical  = Logical;
+    iface.u.FreeNonPagedMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeNonPagedMemory.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckEVENT_DestroyVirtualCommandBuffer(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    )
+{
+    gceSTATUS status;
+    gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
+
+    gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
+                   "FromWhere=%d",
+                   Event, Bytes, Physical, Logical, FromWhere);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+
+    /* Create an event. */
+    iface.command = gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER;
+    iface.u.FreeVirtualCommandBuffer.bytes    = Bytes;
+    iface.u.FreeVirtualCommandBuffer.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(Logical);
+
+    /* Append it to the queue. */
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1158,6 +1310,7 @@ gckEVENT_FreeContiguousMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1172,11 +1325,11 @@ gckEVENT_FreeContiguousMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_CONTIGUOUS_MEMORY;
     iface.u.FreeContiguousMemory.bytes    = Bytes;
-    iface.u.FreeContiguousMemory.physical = Physical;
-    iface.u.FreeContiguousMemory.logical  = Logical;
+    iface.u.FreeContiguousMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeContiguousMemory.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1228,16 +1381,16 @@ gckEVENT_Signal(
 
     /* Mark the event as a signal. */
     iface.command            = gcvHAL_SIGNAL;
-    iface.u.Signal.signal    = Signal;
+    iface.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     iface.u.Signal.coid      = 0;
     iface.u.Signal.rcvid     = 0;
 #endif
-    iface.u.Signal.auxSignal = gcvNULL;
-    iface.u.Signal.process   = gcvNULL;
+    iface.u.Signal.auxSignal = 0;
+    iface.u.Signal.process   = 0;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1284,7 +1437,7 @@ gckEVENT_CommitDone(
     iface.command = gcvHAL_COMMIT_DONE;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1366,7 +1519,6 @@ gckEVENT_Submit(
             gcmkONERROR(gckEVENT_GetEvent(Event, Wait, &id, queue->source));
 
             /* Copy event list to event ID queue. */
-            Event->queues[id].source = queue->source;
             Event->queues[id].head   = queue->head;
 
             /* Remove the top queue from the list. */
@@ -1400,7 +1552,7 @@ gckEVENT_Submit(
             gcmkONERROR(gckHARDWARE_Event(Event->kernel->hardware,
                                           gcvNULL,
                                           id,
-                                          gcvKERNEL_PIXEL,
+                                          Event->queues[id].source,
                                           &bytes));
 
             /* Reserve space in the command queue. */
@@ -1453,6 +1605,14 @@ OnError:
         Event->queues[id].head = gcvNULL;
     }
 
+    if (status == gcvSTATUS_GPU_NOT_RESPONDING)
+    {
+        /* Broadcast GPU stuck. */
+        status = gckOS_Broadcast(Event->os,
+                                 Event->kernel->hardware,
+                                 gcvBROADCAST_GPU_STUCK);
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1529,10 +1689,10 @@ gckEVENT_Commit(
 
         /* Append event record to event queue. */
         gcmkONERROR(
-            gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvTRUE));
+            gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvTRUE, gcvFALSE));
 
         /* Next record in the queue. */
-        next = record->next;
+        next = gcmUINT64_TO_PTR(record->next);
 
         if (!needCopy)
         {
@@ -1625,12 +1785,12 @@ gckEVENT_Compose(
     tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
     tempRecord->info.u.Signal.signal    = Info->signal;
-    tempRecord->info.u.Signal.auxSignal = gcvNULL;
+    tempRecord->info.u.Signal.auxSignal = 0;
     tempRecord->next = gcvNULL;
     tempRecord->processID = processID;
 
     /* Allocate another record for user signal #1. */
-    if (Info->userSignal1 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal1) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1645,13 +1805,13 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal1;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
 
     /* Allocate another record for user signal #2. */
-    if (Info->userSignal2 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal2) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1666,7 +1826,7 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal2;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
@@ -1677,7 +1837,7 @@ gckEVENT_Compose(
     /* Start composition. */
     gcmkONERROR(gckHARDWARE_Compose(
         Event->kernel->hardware, processID,
-        Info->physical, Info->logical, Info->offset, Info->size, id
+        gcmUINT64_TO_PTR(Info->physical), gcmUINT64_TO_PTR(Info->logical), Info->offset, Info->size, id
         ));
 
     /* Success. */
@@ -1760,11 +1920,14 @@ gckEVENT_Notify(
     gcsEVENT_QUEUE * queue;
     gctUINT mask = 0;
     gctBOOL acquired = gcvFALSE;
-#ifdef __QNXNTO__
     gcuVIDMEM_NODE_PTR node;
-#endif
+    gctPOINTER info;
+    gctSIGNAL signal;
     gctUINT pending;
+    gckKERNEL kernel = Event->kernel;
+#if !gcdSMP
     gctBOOL suspended = gcvFALSE;
+#endif
 #if gcmIS_DEBUG(gcdDEBUG_TRACE)
     gctINT eventNumber = 0;
 #endif
@@ -1799,20 +1962,21 @@ gckEVENT_Notify(
     {
         gcsEVENT_PTR record;
 
+#if gcdSMP
+        /* Get current interrupts. */
+        gckOS_AtomGet(Event->os, Event->pending, (gctINT32_PTR)&pending);
+#else
         /* Suspend interrupts. */
         gcmkONERROR(gckOS_SuspendInterruptEx(Event->os, Event->kernel->core));
         suspended = gcvTRUE;
 
         /* Get current interrupts. */
-#if gcdSMP
-        gckOS_AtomGet(Event->os, Event->pending, (gctINT32_PTR)&pending);
-#else
         pending = Event->pending;
-#endif
 
         /* Resume interrupts. */
         gcmkONERROR(gckOS_ResumeInterruptEx(Event->os, Event->kernel->core));
         suspended = gcvFALSE;
+#endif
 
         if (pending == 0)
         {
@@ -1820,6 +1984,20 @@ gckEVENT_Notify(
             break;
         }
 
+        if (pending & 0x80000000)
+        {
+            gckOS_Print("!!!!!!!!!!!!! AXI BUS ERROR !!!!!!!!!!!!!\n");
+            gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_EVENT, "AXI BUS ERROR");
+            pending &= 0x7FFFFFFF;
+        }
+
+        if (pending & 0x40000000)
+        {
+            gckHARDWARE_DumpMMUException(Event->kernel->hardware);
+
+            pending &= 0xBFFFFFFF;
+        }
+
         gcmkTRACE_ZONE_N(
             gcvLEVEL_INFO, gcvZONE_EVENT,
             gcmSIZEOF(pending),
@@ -1875,23 +2053,24 @@ gckEVENT_Notify(
                 pending
                 );
 
-            /* Suspend interrupts. */
-            gcmkONERROR(gckOS_SuspendInterruptEx(Event->os, Event->kernel->core));
-            suspended = gcvTRUE;
-
-            /* Mark pending interrupts as handled. */
 #if gcdSMP
+            /* Mark pending interrupts as handled. */
             gckOS_AtomClearMask(Event->pending, pending);
 #elif defined(__QNXNTO__)
+            /* Mark pending interrupts as handled. */
             atomic_clr((gctUINT32_PTR)&Event->pending, pending);
 #else
+            /* Suspend interrupts. */
+            gcmkONERROR(gckOS_SuspendInterruptEx(Event->os, Event->kernel->core));
+            suspended = gcvTRUE;
+
+            /* Mark pending interrupts as handled. */
             Event->pending &= ~pending;
-#endif
 
             /* Resume interrupts. */
             gcmkONERROR(gckOS_ResumeInterruptEx(Event->os, Event->kernel->core));
             suspended = gcvFALSE;
-
+#endif
             break;
         }
 
@@ -1900,7 +2079,7 @@ gckEVENT_Notify(
         {
             if ((Event->queues[i].head != gcvNULL)
             &&  (Event->queues[i].stamp < queue->stamp)
-            &&  (Event->queues[i].source == queue->source)
+            &&  (Event->queues[i].source <= queue->source)
             )
             {
                 gcmkTRACE_N(
@@ -1928,22 +2107,24 @@ gckEVENT_Notify(
 #endif
         }
 
-        /* Suspend interrupts. */
-        gcmkONERROR(gckOS_SuspendInterruptEx(Event->os, Event->kernel->core));
-        suspended = gcvTRUE;
-
-        /* Mark pending interrupt as handled. */
 #if gcdSMP
+        /* Mark pending interrupt as handled. */
         gckOS_AtomClearMask(Event->pending, mask);
 #elif defined(__QNXNTO__)
+        /* Mark pending interrupt as handled. */
         atomic_clr(&Event->pending, mask);
 #else
+        /* Suspend interrupts. */
+        gcmkONERROR(gckOS_SuspendInterruptEx(Event->os, Event->kernel->core));
+        suspended = gcvTRUE;
+
+        /* Mark pending interrupt as handled. */
         Event->pending &= ~mask;
-#endif
 
         /* Resume interrupts. */
         gcmkONERROR(gckOS_ResumeInterruptEx(Event->os, Event->kernel->core));
         suspended = gcvFALSE;
+#endif
 
         /* Grab the mutex queue. */
         gcmkONERROR(gckOS_AcquireMutex(Event->os,
@@ -1982,7 +2163,7 @@ gckEVENT_Notify(
             /* Assign record->processID as the pid for this galcore thread.
              * Used in OS calls like gckOS_UnlockMemory() which do not take a pid.
              */
-            drv_thread_specific_key_assign(record->processID, 0);
+            drv_thread_specific_key_assign(record->processID, 0, Event->kernel->core);
 #endif
 
 #if gcdSECURE_USER
@@ -2004,14 +2185,14 @@ gckEVENT_Notify(
             case gcvHAL_FREE_NON_PAGED_MEMORY:
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_NON_PAGED_MEMORY: 0x%x",
-                               record->info.u.FreeNonPagedMemory.physical);
+                               gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical));
 
                 /* Free non-paged memory. */
                 status = gckOS_FreeNonPagedMemory(
                             Event->os,
-                            record->info.u.FreeNonPagedMemory.bytes,
-                            record->info.u.FreeNonPagedMemory.physical,
-                            record->info.u.FreeNonPagedMemory.logical);
+                            (gctSIZE_T) record->info.u.FreeNonPagedMemory.bytes,
+                            gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeNonPagedMemory.logical));
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2019,24 +2200,25 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        record->event.u.FreeNonPagedMemory.logical,
-                        record->event.u.FreeNonPagedMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeNonPagedMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeNonPagedMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeNonPagedMemory.physical);
                 break;
 
             case gcvHAL_FREE_CONTIGUOUS_MEMORY:
                 gcmkTRACE_ZONE(
                     gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                     "gcvHAL_FREE_CONTIGUOUS_MEMORY: 0x%x",
-                    record->info.u.FreeContiguousMemory.physical);
+                    gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical));
 
                 /* Unmap the user memory. */
                 status = gckOS_FreeContiguous(
                             Event->os,
-                            record->info.u.FreeContiguousMemory.physical,
-                            record->info.u.FreeContiguousMemory.logical,
-                            record->info.u.FreeContiguousMemory.bytes);
+                            gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeContiguousMemory.logical),
+                            (gctSIZE_T) record->info.u.FreeContiguousMemory.bytes);
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2044,19 +2226,19 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.FreeContiguousMemory.logical,
-                        event->event.u.FreeContiguousMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeContiguousMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeContiguousMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeContiguousMemory.physical);
                 break;
 
             case gcvHAL_FREE_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.FreeVideoMemory.node);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_VIDEO_MEMORY: 0x%x",
-                               record->info.u.FreeVideoMemory.node);
-
+                               node);
 #ifdef __QNXNTO__
-                node = record->info.u.FreeVideoMemory.node;
 #if gcdUSE_VIDMEM_PER_PID
                 /* Check if the VidMem object still exists. */
                 if (gckKERNEL_GetVideoMemoryPoolPid(record->kernel,
@@ -2085,7 +2267,7 @@ gckEVENT_Notify(
 
                 /* Free video memory. */
                 status =
-                    gckVIDMEM_Free(record->info.u.FreeVideoMemory.node);
+                    gckVIDMEM_Free(node);
 
                 break;
 
@@ -2120,13 +2302,14 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_UNLOCK_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.UnlockVideoMemory.node);
+
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNLOCK_VIDEO_MEMORY: 0x%x",
-                               record->info.u.UnlockVideoMemory.node);
+                               node);
 
                 /* Save node information before it disappears. */
 #if gcdSECURE_USER
-                node = event->event.u.UnlockVideoMemory.node;
                 if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
                 {
                     logical = gcvNULL;
@@ -2142,7 +2325,7 @@ gckEVENT_Notify(
                 /* Unlock. */
                 status = gckVIDMEM_Unlock(
                     Event->kernel,
-                    record->info.u.UnlockVideoMemory.node,
+                    node,
                     record->info.u.UnlockVideoMemory.type,
                     gcvNULL);
 
@@ -2159,9 +2342,10 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_SIGNAL:
+                signal = gcmUINT64_TO_PTR(record->info.u.Signal.signal);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_SIGNAL: 0x%x",
-                               record->info.u.Signal.signal);
+                               signal);
 
 #ifdef __QNXNTO__
                 if ((record->info.u.Signal.coid == 0)
@@ -2171,7 +2355,7 @@ gckEVENT_Notify(
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2179,18 +2363,18 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
+                                         signal,
                                          record->info.u.Signal.rcvid,
                                          record->info.u.Signal.coid));
                 }
 #else
                 /* Set signal. */
-                if (record->info.u.Signal.process == gcvNULL)
+                if (gcmUINT64_TO_PTR(record->info.u.Signal.process) == gcvNULL)
                 {
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2198,26 +2382,27 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
-                                         record->info.u.Signal.process));
+                                         signal,
+                                         gcmUINT64_TO_PTR(record->info.u.Signal.process)));
                 }
 
-                gcmkASSERT(record->info.u.Signal.auxSignal == gcvNULL);
+                gcmkASSERT(record->info.u.Signal.auxSignal == 0);
 #endif
                 break;
 
             case gcvHAL_UNMAP_USER_MEMORY:
+                info = gcmNAME_TO_PTR(record->info.u.UnmapUserMemory.info);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNMAP_USER_MEMORY: 0x%x",
-                               record->info.u.UnmapUserMemory.info);
+                               info);
 
                 /* Unmap the user memory. */
-                status = gckOS_UnmapUserMemoryEx(
+                status = gckOS_UnmapUserMemory(
                     Event->os,
                     Event->kernel->core,
-                    record->info.u.UnmapUserMemory.memory,
-                    record->info.u.UnmapUserMemory.size,
-                    record->info.u.UnmapUserMemory.info,
+                    gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                    (gctSIZE_T) record->info.u.UnmapUserMemory.size,
+                    info,
                     record->info.u.UnmapUserMemory.address);
 
 #if gcdSECURE_USER
@@ -2226,14 +2411,11 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.UnmapUserMemory.memory,
-                        event->event.u.UnmapUserMemory.size));
+                        gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                        (gctSIZE_T) record->info.u.UnmapUserMemory.size));
                 }
 #endif
-                gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
-                        Event->kernel,
-                        record->processID, gcvDB_MAP_USER_MEMORY,
-                        record->info.u.UnmapUserMemory.memory));
+                gcmRELEASE_NAME(record->info.u.UnmapUserMemory.info);
                 break;
 
             case gcvHAL_TIMESTAMP:
@@ -2270,6 +2452,18 @@ gckEVENT_Notify(
                 }
                 break;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+             case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+                 gcmkVERIFY_OK(
+                     gckKERNEL_DestroyVirtualCommandBuffer(Event->kernel,
+                         (gctSIZE_T) record->info.u.FreeVirtualCommandBuffer.bytes,
+                         gcmNAME_TO_PTR(record->info.u.FreeVirtualCommandBuffer.physical),
+                         gcmUINT64_TO_PTR(record->info.u.FreeVirtualCommandBuffer.logical)
+                         ));
+                 gcmRELEASE_NAME(record->info.u.FreeVirtualCommandBuffer.physical);
+                 break;
+#endif
+
             case gcvHAL_COMMIT_DONE:
                 break;
 
@@ -2323,11 +2517,13 @@ OnError:
         gcmkVERIFY_OK(gckOS_ReleaseMutex(Event->os, Event->eventQueueMutex));
     }
 
+#if !gcdSMP
     if (suspended)
     {
         /* Resume interrupts. */
         gcmkVERIFY_OK(gckOS_ResumeInterruptEx(Event->os, Event->kernel->core));
     }
+#endif
 
     /* Return the status. */
     gcmkFOOTER();
@@ -2514,13 +2710,13 @@ gckEVENT_Stop(
     record->next = gcvNULL;
     record->processID               = ProcessID;
     record->info.command            = gcvHAL_SIGNAL;
-    record->info.u.Signal.signal    = Signal;
+    record->info.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     record->info.u.Signal.coid      = 0;
     record->info.u.Signal.rcvid     = 0;
 #endif
-    record->info.u.Signal.auxSignal = gcvNULL;
-    record->info.u.Signal.process   = gcvNULL;
+    record->info.u.Signal.auxSignal = 0;
+    record->info.u.Signal.process   = 0;
 
     /* Append the record. */
     Event->queues[id].head      = record;
@@ -2601,6 +2797,11 @@ _PrintRecord(
         gcmkPRINT("      gcvHAL_COMMIT_DONE");
         break;
 
+    case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+        gcmkPRINT("      gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER logical=0x%08x",
+                  record->info.u.FreeVirtualCommandBuffer.logical);
+        break;
+
     default:
         gcmkPRINT("      Illegal Event %d", record->info.command);
         break;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
index c68e0c1..a5affb9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /**
 **  @file
 **  gckHEAP object for kernel HAL layer.  The heap implemented here is an arena-
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
index e2f84f6..8ac187b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index 48e5e09..0c71e28 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_MMU
@@ -37,6 +35,8 @@ gceMMU_TYPE;
 
 #define gcdMMU_TABLE_DUMP       0
 
+#define gcdUSE_MMU_EXCEPTION    0
+
 /*
     gcdMMU_CLEAR_VALUE
 
@@ -68,7 +68,7 @@ typedef struct _gcsSharedPageTable
     gckMMU          mmu;
 
     /* Hardwares which use this shared pagetable. */
-    gckHARDWARE     hardwares[gcdCORE_COUNT];
+    gckHARDWARE     hardwares[gcdMAX_GPU_COUNT];
 
     /* Number of cores use this shared pagetable. */
     gctUINT32       reference;
@@ -78,6 +78,42 @@ gcsSharedPageTable;
 static gcsSharedPageTable_PTR sharedPageTable = gcvNULL;
 #endif
 
+#if gcdMIRROR_PAGETABLE
+typedef struct _gcsMirrorPageTable * gcsMirrorPageTable_PTR;
+typedef struct _gcsMirrorPageTable
+{
+    /* gckMMU objects. */
+    gckMMU          mmus[gcdMAX_GPU_COUNT];
+
+    /* Hardwares which use this shared pagetable. */
+    gckHARDWARE     hardwares[gcdMAX_GPU_COUNT];
+
+    /* Number of cores use this shared pagetable. */
+    gctUINT32       reference;
+}
+gcsMirrorPageTable;
+
+static gcsMirrorPageTable_PTR mirrorPageTable = gcvNULL;
+static gctPOINTER mirrorPageTableMutex = gcvNULL;
+#endif
+
+static gceSTATUS
+_FillPageTable(
+    IN gctUINT32_PTR PageTable,
+    IN gctUINT32     PageCount,
+    IN gctUINT32     EntryValue
+)
+{
+    gctUINT i;
+
+    for (i = 0; i < PageCount; i++)
+    {
+        PageTable[i] = EntryValue;
+    }
+
+    return gcvSTATUS_OK;
+}
+
 static gceSTATUS
 _Link(
     IN gckMMU Mmu,
@@ -444,9 +480,16 @@ _SetupDynamicSpace(
                 &Mmu->pageTablePhysical,
                 (gctPOINTER)&Mmu->pageTableLogical));
 
+#if gcdUSE_MMU_EXCEPTION
+    gcmkONERROR(_FillPageTable(Mmu->pageTableLogical,
+                               Mmu->pageTableEntries,
+                               /* Enable exception */
+                               1 << 1));
+#else
     /* Invalidate all entries. */
     gcmkONERROR(gckOS_ZeroMemory(Mmu->pageTableLogical,
                 Mmu->pageTableSize));
+#endif
 
     /* Initilization. */
     pageTable      = Mmu->pageTableLogical;
@@ -856,6 +899,47 @@ OnError:
 
     gcmkFOOTER();
     return status;
+#elif gcdMIRROR_PAGETABLE
+    gceSTATUS status;
+    gctPOINTER pointer;
+
+    gcmkHEADER_ARG("Kernel=0x%08x", Kernel);
+
+    if (mirrorPageTable == gcvNULL)
+    {
+        gcmkONERROR(
+            gckOS_Allocate(Kernel->os,
+                           sizeof(struct _gcsMirrorPageTable),
+                           &pointer));
+        mirrorPageTable = pointer;
+
+        gcmkONERROR(
+            gckOS_ZeroMemory(mirrorPageTable,
+                    sizeof(struct _gcsMirrorPageTable)));
+
+        gcmkONERROR(
+            gckOS_CreateMutex(Kernel->os, &mirrorPageTableMutex));
+    }
+
+    gcmkONERROR(_Construct(Kernel, MmuSize, Mmu));
+
+    mirrorPageTable->mmus[mirrorPageTable->reference] = *Mmu;
+
+    mirrorPageTable->hardwares[mirrorPageTable->reference] = Kernel->hardware;
+
+    mirrorPageTable->reference++;
+
+    gcmkFOOTER_ARG("mirrorPageTable->reference=%lu", mirrorPageTable->reference);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (mirrorPageTable && mirrorPageTable->reference == 0)
+    {
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, mirrorPageTable));
+    }
+
+    gcmkFOOTER();
+    return status;
 #else
     return _Construct(Kernel, MmuSize, Mmu);
 #endif
@@ -880,6 +964,16 @@ gckMMU_Destroy(
     }
 
     return gcvSTATUS_OK;
+#elif gcdMIRROR_PAGETABLE
+    mirrorPageTable->reference--;
+
+    if (mirrorPageTable->reference == 0)
+    {
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, mirrorPageTable));
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, mirrorPageTableMutex));
+    }
+
+    return _Destroy(Mmu);
 #else
     return _Destroy(Mmu);
 #endif
@@ -909,7 +1003,7 @@ gckMMU_Destroy(
 **          Pointer to a variable that receives the hardware specific address.
 */
 gceSTATUS
-gckMMU_AllocatePages(
+_AllocatePages(
     IN gckMMU Mmu,
     IN gctSIZE_T PageCount,
     OUT gctPOINTER * PageTable,
@@ -932,6 +1026,9 @@ gckMMU_AllocatePages(
 
     if (PageCount > Mmu->pageTableEntries)
     {
+        gcmkPRINT("[galcore]: %s(%d): Run out of free page entry.",
+                  __FUNCTION__, __LINE__);
+
         /* Not enough pages avaiable. */
         gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
     }
@@ -993,6 +1090,9 @@ gckMMU_AllocatePages(
             }
             else
             {
+                gcmkPRINT("[galcore]: %s(%d): Run out of free page entry.",
+                          __FUNCTION__, __LINE__);
+
                 /* Out of resources. */
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
@@ -1036,7 +1136,7 @@ gckMMU_AllocatePages(
     }
 
     /* Mark node as used. */
-    pageTable[index] = gcvMMU_USED;
+    gcmkONERROR(_FillPageTable(&pageTable[index], PageCount, gcvMMU_USED));
 
     /* Return pointer to page table. */
     *PageTable = &pageTable[index];
@@ -1105,13 +1205,15 @@ OnError:
 **      Nothing.
 */
 gceSTATUS
-gckMMU_FreePages(
+_FreePages(
     IN gckMMU Mmu,
     IN gctPOINTER PageTable,
     IN gctSIZE_T PageCount
     )
 {
     gctUINT32_PTR pageTable;
+    gceSTATUS status;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Mmu=0x%x PageTable=0x%x PageCount=%lu",
                    Mmu, PageTable, PageCount);
@@ -1124,7 +1226,11 @@ gckMMU_FreePages(
     /* Convert the pointer. */
     pageTable = (gctUINT32_PTR) PageTable;
 
+    gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
 #if gcdMMU_CLEAR_VALUE
+    if (Mmu->hardware->mmuVersion == 0)
     {
         gctUINT32 i;
 
@@ -1138,21 +1244,151 @@ gckMMU_FreePages(
     if (PageCount == 1)
     {
         /* Single page node. */
-        pageTable[0] = (~((1U<<8)-1)) | gcvMMU_SINGLE;
+        pageTable[0] = (~((1U<<8)-1)) | gcvMMU_SINGLE
+#if gcdUSE_MMU_EXCEPTION
+                     /* Enable exception */
+                     | (1 << 1)
+#endif
+                     ;
     }
     else
     {
         /* Mark the node as free. */
-        pageTable[0] = (PageCount << 8) | gcvMMU_FREE;
+        pageTable[0] = (PageCount << 8) | gcvMMU_FREE
+#if gcdUSE_MMU_EXCEPTION
+                     /* Enable exception */
+                     | (1 << 1)
+#endif
+                     ;
         pageTable[1] = ~0U;
+
+#if gcdUSE_MMU_EXCEPTION
+        /* Enable exception */
+        gcmkVERIFY_OK(_FillPageTable(pageTable + 2, PageCount - 2, 1 << 1));
+#endif
     }
 
     /* We have free nodes. */
     Mmu->freeNodes = gcvTRUE;
 
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    acquired = gcvFALSE;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckMMU_AllocatePages(
+    IN gckMMU Mmu,
+    IN gctSIZE_T PageCount,
+    OUT gctPOINTER * PageTable,
+    OUT gctUINT32 * Address
+    )
+{
+#if gcdMIRROR_PAGETABLE
+    gceSTATUS status;
+    gctPOINTER pageTable;
+    gctUINT32 address;
+    gctINT i;
+    gckMMU mmu;
+    gctBOOL acquired = gcvFALSE;
+    gctBOOL allocated = gcvFALSE;
+
+    gckOS_AcquireMutex(Mmu->os, mirrorPageTableMutex, gcvINFINITE);
+    acquired = gcvTRUE;
+
+    /* Allocate page table for current MMU. */
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        if (Mmu == mirrorPageTable->mmus[i])
+        {
+            gcmkONERROR(_AllocatePages(Mmu, PageCount, PageTable, Address));
+            allocated = gcvTRUE;
+        }
+    }
+
+    /* Allocate page table for other MMUs. */
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (Mmu != mmu)
+        {
+            gcmkONERROR(_AllocatePages(mmu, PageCount, &pageTable, &address));
+            gcmkASSERT(address == *Address);
+        }
+    }
+
+    gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    acquired = gcvFALSE;
+
+    return gcvSTATUS_OK;
+OnError:
+
+    if (allocated)
+    {
+        /* Page tables for multiple GPU always keep the same. So it is impossible
+         * the fist one allocates successfully but others fail.
+         */
+        gcmkASSERT(0);
+    }
+
+    if (acquired)
+    {
+        gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    }
+
+    return status;
+#else
+    return _AllocatePages(Mmu, PageCount, PageTable, Address);
+#endif
+}
+
+gceSTATUS
+gckMMU_FreePages(
+    IN gckMMU Mmu,
+    IN gctPOINTER PageTable,
+    IN gctSIZE_T PageCount
+    )
+{
+#if gcdMIRROR_PAGETABLE
+    gctINT i;
+    gctUINT32 offset;
+    gckMMU mmu;
+
+    gckOS_AcquireMutex(Mmu->os, mirrorPageTableMutex, gcvINFINITE);
+
+    gcmkVERIFY_OK(_FreePages(Mmu, PageTable, PageCount));
+
+    offset = (gctUINT32)PageTable - (gctUINT32)Mmu->pageTableLogical;
+
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (mmu != Mmu)
+        {
+            gcmkVERIFY_OK(_FreePages(mmu, mmu->pageTableLogical + offset/4, PageCount));
+        }
+    }
+
+    gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+
+    return gcvSTATUS_OK;
+#else
+    return _FreePages(Mmu, PageTable, PageCount);
+#endif
 }
 
 gceSTATUS
@@ -1163,6 +1399,10 @@ gckMMU_Enable(
     )
 {
     gceSTATUS status;
+#if gcdSHARED_PAGETABLE
+    gckHARDWARE hardware;
+    gctINT i;
+#endif
 
     gcmkHEADER_ARG("Mmu=0x%x", Mmu);
 
@@ -1196,6 +1436,24 @@ gckMMU_Enable(
 
         gcmkONERROR(_SetupDynamicSpace(Mmu));
 
+#if gcdSHARED_PAGETABLE
+        for(i = 0; i < gcdMAX_GPU_COUNT; i++)
+        {
+            hardware = sharedPageTable->hardwares[i];
+            if (hardware != gcvNULL)
+            {
+                gcmkONERROR(
+                    gckHARDWARE_SetMMUv2(
+                        hardware,
+                        gcvTRUE,
+                        Mmu->mtlbLogical,
+                        gcvMMU_MODE_4K,
+                        (gctUINT8_PTR)Mmu->mtlbLogical + gcdMMU_MTLB_SIZE,
+                        gcvFALSE
+                        ));
+            }
+        }
+#else
         gcmkONERROR(
             gckHARDWARE_SetMMUv2(
                 Mmu->hardware,
@@ -1205,6 +1463,7 @@ gckMMU_Enable(
                 (gctUINT8_PTR)Mmu->mtlbLogical + gcdMMU_MTLB_SIZE,
                 gcvFALSE
                 ));
+#endif
 
         Mmu->enabled = gcvTRUE;
 
@@ -1226,6 +1485,14 @@ gckMMU_SetPage(
     IN gctUINT32 *PageEntry
     )
 {
+#if gcdMIRROR_PAGETABLE
+    gctUINT32_PTR pageEntry;
+    gctINT i;
+    gckMMU mmu;
+    gctUINT32 offset = (gctUINT32)PageEntry - (gctUINT32)Mmu->pageTableLogical;
+#endif
+
+    gctUINT32 data;
     gcmkHEADER_ARG("Mmu=0x%x", Mmu);
 
     /* Verify the arguments. */
@@ -1235,13 +1502,40 @@ gckMMU_SetPage(
 
     if (Mmu->hardware->mmuVersion == 0)
     {
-        *PageEntry = PageAddress;
+        data = PageAddress;
     }
     else
     {
-        *PageEntry = _SetPage(PageAddress);
+        data = _SetPage(PageAddress);
+    }
+
+    if (Mmu->hardware->bigEndian)
+    {
+        data = gcmSWAB32(data);
     }
 
+    *PageEntry = data;
+#if gcdMIRROR_PAGETABLE
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (mmu != Mmu)
+        {
+            pageEntry = mmu->pageTableLogical + offset / 4;
+
+            if (mmu->hardware->mmuVersion == 0)
+            {
+                *pageEntry = PageAddress;
+            }
+            else
+            {
+                *pageEntry = _SetPage(PageAddress);
+            }
+        }
+
+    }
+#endif
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -1379,7 +1673,7 @@ gckMMU_Flush(
     gckHARDWARE hardware;
 #if gcdSHARED_PAGETABLE
     gctINT i;
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
 #if gcdENABLE_VG
         if (i == gcvCORE_VG)
@@ -1395,6 +1689,16 @@ gckMMU_Flush(
                 gckOS_AtomSet(hardware->os, hardware->pageTableDirty, 1));
         }
     }
+#elif gcdMIRROR_PAGETABLE
+    gctINT i;
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        hardware = mirrorPageTable->hardwares[i];
+
+        /* Notify cores who use this page table. */
+        gcmkVERIFY_OK(
+            gckOS_AtomSet(hardware->os, hardware->pageTableDirty, 1));
+    }
 #else
     hardware = Mmu->hardware;
     gcmkVERIFY_OK(
@@ -1404,6 +1708,39 @@ gckMMU_Flush(
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    )
+{
+    gctUINT32_PTR pageTable;
+    gctUINT32 index;
+    gctUINT32 mtlb, stlb;
+
+    gcmkHEADER_ARG("Mmu=0x%08X Address=0x%08X", Mmu, Address);
+    gcmkVERIFY_OBJECT(Mmu, gcvOBJ_MMU);
+
+    gcmkASSERT(Mmu->hardware->mmuVersion > 0);
+
+    mtlb   = (Address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
+    stlb   = (Address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+
+    if (Address >= 0x80000000)
+    {
+        pageTable = Mmu->pageTableLogical;
+
+        index = (mtlb - Mmu->dynamicMappingStart)
+              * gcdMMU_STLB_4K_ENTRY_NUM
+              + stlb;
+
+        gcmkPRINT("    Page table entry = 0x%08X", pageTable[index]);
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 /******************************************************************************
 ****************************** T E S T   C O D E ******************************
 ******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
index a4a5e0c..0c20290 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
@@ -344,9 +342,6 @@ gceSTATUS gckVGMMU_AllocatePages(
 
     if (!allocated)
     {
-        /* Flush the MMU. */
-        status = gckVGHARDWARE_FlushMMU(Mmu->hardware);
-
         if (status >= 0)
         {
             /* Walk all entries until we find enough slots. */
@@ -506,4 +501,22 @@ gckVGMMU_SetPage(
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckVGMMU_Flush(
+   IN gckVGMMU Mmu
+   )
+{
+    gckVGHARDWARE hardware;
+
+    gcmkHEADER_ARG("Mmu=0x%x", Mmu);
+
+    hardware = Mmu->hardware;
+    gcmkVERIFY_OK(
+        gckOS_AtomSet(hardware->os, hardware->pageTableDirty, 1));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 #endif /* gcdENABLE_VG */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
new file mode 100644
index 0000000..df7579d
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
@@ -0,0 +1,347 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include "gc_hal_kernel_precomp.h"
+
+#define _GC_OBJ_ZONE    gcvZONE_POWER
+
+/******************************************************************************\
+************************ Dynamic Voltage Frequency Setting *********************
+\******************************************************************************/
+#if gcdDVFS
+static gctUINT32
+_GetLoadHistory(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Select,
+    IN gctUINT32 Index
+)
+{
+    return Dvfs->loads[Index];
+}
+
+static void
+_IncreaseScale(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    if (Dvfs->currentScale < 32)
+    {
+        *Scale = Dvfs->currentScale + 8;
+    }
+    else
+    {
+        *Scale = Dvfs->currentScale + 8;
+        *Scale = gcmMIN(64, *Scale);
+    }
+}
+
+static void
+_RecordFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory *history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        if (history->frequency == 0)
+        {
+            history->frequency = Frequency;
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        history->count++;
+    }
+}
+
+static gctUINT32
+_GetFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory * history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        return history->count;
+    }
+
+    return 0;
+}
+
+static void
+_Policy(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    gctUINT8 load[4], nextLoad;
+    gctUINT8 scale;
+
+    /* Last 4 history. */
+    load[0] = (Load & 0xFF);
+    load[1] = (Load & 0xFF00) >> 8;
+    load[2] = (Load & 0xFF0000) >> 16;
+    load[3] = (Load & 0xFF000000) >> 24;
+
+    /* Determine target scale. */
+    if (load[0] > 54)
+    {
+        _IncreaseScale(Dvfs, Load, &scale);
+    }
+    else
+    {
+        nextLoad = (load[0] + load[1] + load[2] + load[3])/4;
+
+        scale = Dvfs->currentScale * (nextLoad) / 54;
+
+        scale = gcmMAX(1, scale);
+        scale = gcmMIN(64, scale);
+    }
+
+    Dvfs->totalConfig++;
+
+    Dvfs->loads[(load[0]-1)/8]++;
+
+    *Scale = scale;
+
+
+    if (Dvfs->totalConfig % 100 == 0)
+    {
+        gcmkPRINT("=======================================================");
+        gcmkPRINT("GPU Load:       %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                                   8, 16, 24, 32, 40, 48, 56, 64);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                  _GetLoadHistory(Dvfs,2, 0),
+                  _GetLoadHistory(Dvfs,2, 1),
+                  _GetLoadHistory(Dvfs,2, 2),
+                  _GetLoadHistory(Dvfs,2, 3),
+                  _GetLoadHistory(Dvfs,2, 4),
+                  _GetLoadHistory(Dvfs,2, 5),
+                  _GetLoadHistory(Dvfs,2, 6),
+                  _GetLoadHistory(Dvfs,2, 7)
+                  );
+
+        gcmkPRINT("Frequency(MHz)  %-8d %-8d %-8d %-8d %-8d",
+                  58, 120, 240, 360, 480);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d",
+                  _GetFrequencyHistory(Dvfs, 58),
+                  _GetFrequencyHistory(Dvfs,120),
+                  _GetFrequencyHistory(Dvfs,240),
+                  _GetFrequencyHistory(Dvfs,360),
+                  _GetFrequencyHistory(Dvfs,480)
+                  );
+    }
+}
+
+static void
+_TimerFunction(
+    gctPOINTER Data
+    )
+{
+    gceSTATUS status;
+    gckDVFS dvfs = (gckDVFS) Data;
+    gckHARDWARE hardware = dvfs->hardware;
+    gctUINT32 value;
+    gctUINT32 frequency;
+    gctUINT8 scale;
+    gctUINT32 t1, t2, consumed;
+
+    gckOS_GetTicks(&t1);
+
+    gcmkONERROR(gckHARDWARE_QueryLoad(hardware, &value));
+
+    /* determine target sacle. */
+    _Policy(dvfs, value, &scale);
+
+    /* Set frequency and voltage. */
+    gcmkONERROR(gckOS_SetGPUFrequency(hardware->os, hardware->core, scale));
+
+    /* Query real frequency. */
+    gcmkONERROR(
+        gckOS_QueryGPUFrequency(hardware->os,
+                                hardware->core,
+                                &frequency,
+                                &dvfs->currentScale));
+
+    _RecordFrequencyHistory(dvfs, frequency);
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_POWER,
+                   "Current frequency = %d",
+                   frequency);
+
+    /* Set period. */
+    gcmkONERROR(gckHARDWARE_SetDVFSPeroid(hardware, frequency));
+
+OnError:
+    /* Determine next querying time. */
+    gckOS_GetTicks(&t2);
+
+    consumed = gcmMIN(((long)t2 - (long)t1), 5);
+
+    if (dvfs->stop == gcvFALSE)
+    {
+        gcmkVERIFY_OK(gckOS_StartTimer(hardware->os,
+                                       dvfs->timer,
+                                       dvfs->pollingTime - consumed));
+    }
+
+    return;
+}
+
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Dvfs
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer;
+    gckDVFS dvfs = gcvNULL;
+    gckOS os = Hardware->os;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Allocate a gckDVFS manager. */
+    gcmkONERROR(gckOS_Allocate(os, gcmSIZEOF(struct _gckDVFS), &pointer));
+
+    gckOS_ZeroMemory(pointer, gcmSIZEOF(struct _gckDVFS));
+
+    dvfs = pointer;
+
+    /* Initialization. */
+    dvfs->hardware = Hardware;
+    dvfs->pollingTime = gcdDVFS_POLLING_TIME;
+    dvfs->os = Hardware->os;
+    dvfs->currentScale = 64;
+
+    /* Create a polling timer. */
+    gcmkONERROR(gckOS_CreateTimer(os, _TimerFunction, pointer, &dvfs->timer));
+
+    /* Initialize frequency and voltage adjustment helper. */
+    gcmkONERROR(gckOS_PrepareGPUFrequency(os, Hardware->core));
+
+    /* Return result. */
+    *Dvfs = dvfs;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Roll back. */
+    if (dvfs)
+    {
+        if (dvfs->timer)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyTimer(os, dvfs->timer));
+        }
+
+        gcmkOS_SAFE_FREE(os, dvfs);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Deinitialize helper fuunction. */
+    gcmkVERIFY_OK(gckOS_FinishGPUFrequency(Dvfs->os, Dvfs->hardware->core));
+
+    /* DestroyTimer. */
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Dvfs->os, Dvfs->timer));
+
+    gcmkOS_SAFE_FREE(Dvfs->os, Dvfs);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    gckHARDWARE_InitDVFS(Dvfs->hardware);
+
+    Dvfs->stop = gcvFALSE;
+
+    gckOS_StartTimer(Dvfs->os, Dvfs->timer, Dvfs->pollingTime);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    Dvfs->stop = gcvTRUE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
index 004e6bd..1e764c2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_precomp_h_
 #define __gc_hal_kernel_precomp_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index 5c1d809..7d0032e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,12 +19,12 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
 
+#define ENABLE_VG_TRY_VIRTUAL_MEMORY 0
+
 #define _GC_OBJ_ZONE            gcvZONE_VG
 
 /******************************************************************************\
@@ -333,11 +333,18 @@ gckKERNEL_AllocateLinearMemory(
         else if (pool == gcvPOOL_SYSTEM)
         {
             /* Advance to virtual memory. */
+#if ENABLE_VG_TRY_VIRTUAL_MEMORY
             pool = gcvPOOL_VIRTUAL;
+#else
+            /*VG non-contiguous memory support is not ready yet, disable it temporary*/
+            status = gcvSTATUS_OUT_OF_MEMORY;
+            break;
+#endif
         }
         else
         {
             /* Out of pools. */
+            status = gcvSTATUS_OUT_OF_MEMORY;
             break;
         }
     }
@@ -388,6 +395,11 @@ gceSTATUS gckVGKERNEL_Dispatch(
     gcsHAL_INTERFACE * kernelInterface = Interface;
     gcuVIDMEM_NODE_PTR node;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
+    gctPOINTER info = gcvNULL;
+    gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctSIZE_T bytes = 0;
 
     gcmkHEADER_ARG("Kernel=0x%x Interface=0x%x ", Kernel, Interface);
 
@@ -427,45 +439,78 @@ gceSTATUS gckVGKERNEL_Dispatch(
             ));
         break;
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate non-paged memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
+
+        /* Unmap user logical out of physical memory first. */
+        gcmkERR_BREAK(gckOS_UnmapUserLogical(
+            Kernel->os,
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
+            ));
+
         /* Free non-paged memory. */
         gcmkERR_BREAK(gckOS_FreeNonPagedMemory(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate contiguous memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
+        /* Unmap user logical out of physical memory first. */
+        gcmkERR_BREAK(gckOS_UnmapUserLogical(
+            Kernel->os,
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
+            ));
+
         /* Free contiguous memory. */
         gcmkERR_BREAK(gckOS_FreeContiguous(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical),
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -507,8 +552,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
                 bytes,
                 64,
                 kernelInterface->u.AllocateVideoMemory.type,
-                &kernelInterface->u.AllocateVideoMemory.node
+                &node
                 ));
+
+            kernelInterface->u.AllocateVideoMemory.node = gcmPTR_TO_UINT64(node);
         }
         break;
 
@@ -520,14 +567,23 @@ gceSTATUS gckVGKERNEL_Dispatch(
             kernelInterface->u.AllocateLinearVideoMemory.bytes,
             kernelInterface->u.AllocateLinearVideoMemory.alignment,
             kernelInterface->u.AllocateLinearVideoMemory.type,
-            &kernelInterface->u.AllocateLinearVideoMemory.node
+            &node
             ));
+
+        gcmkERR_BREAK(gckKERNEL_AddProcessDB(Kernel,
+           processID, gcvDB_VIDEO_MEMORY,
+           node,
+           gcvNULL,
+           kernelInterface->u.AllocateLinearVideoMemory.bytes
+           ));
+
+        kernelInterface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
         /* Unmap the video memory */
-        node = Interface->u.FreeVideoMemory.node;
 
         if ((node->VidMem.memory->object.type == gcvOBJ_VIDMEM) &&
             (node->VidMem.logical != gcvNULL))
@@ -542,27 +598,35 @@ gceSTATUS gckVGKERNEL_Dispatch(
 
         /* Free video memory. */
         gcmkERR_BREAK(gckVIDMEM_Free(
-            Interface->u.FreeVideoMemory.node
+            node
             ));
+
+        gcmkERR_BREAK(gckKERNEL_RemoveProcessDB(
+            Kernel,
+            processID, gcvDB_VIDEO_MEMORY,
+            node
+            ));
+
         break;
 
     case gcvHAL_MAP_MEMORY:
         /* Map memory. */
         gcmkERR_BREAK(gckKERNEL_MapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            &kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            &logical
             ));
+        kernelInterface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
         break;
 
     case gcvHAL_UNMAP_MEMORY:
         /* Unmap memory. */
         gcmkERR_BREAK(gckKERNEL_UnmapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapMemory.logical)
             ));
         break;
 
@@ -570,32 +634,38 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Map user memory to DMA. */
         gcmkERR_BREAK(gckOS_MapUserMemory(
             Kernel->os,
-            kernelInterface->u.MapUserMemory.memory,
-            kernelInterface->u.MapUserMemory.size,
-            &kernelInterface->u.MapUserMemory.info,
+            gcvCORE_VG,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapUserMemory.memory),
+            kernelInterface->u.MapUserMemory.physical,
+            (gctSIZE_T) kernelInterface->u.MapUserMemory.size,
+            &info,
             &kernelInterface->u.MapUserMemory.address
             ));
+
+        kernelInterface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
         /* Unmap user memory. */
         gcmkERR_BREAK(gckOS_UnmapUserMemory(
             Kernel->os,
-            kernelInterface->u.UnmapUserMemory.memory,
-            kernelInterface->u.UnmapUserMemory.size,
-            kernelInterface->u.UnmapUserMemory.info,
+            gcvCORE_VG,
+            gcmUINT64_TO_PTR(kernelInterface->u.UnmapUserMemory.memory),
+            (gctSIZE_T) kernelInterface->u.UnmapUserMemory.size,
+            gcmNAME_TO_PTR(kernelInterface->u.UnmapUserMemory.info),
             kernelInterface->u.UnmapUserMemory.address
             ));
         break;
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkERR_BREAK(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
 						   gcvFALSE,
                            &Interface->u.LockVideoMemory.address));
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -611,19 +681,20 @@ gceSTATUS gckVGKERNEL_Dispatch(
                                          &node->VidMem.logical));
         }
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkERR_BREAK(
                 gckKERNEL_MapVideoMemoryEx(Kernel,
                                          gcvCORE_VG,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -632,13 +703,19 @@ gceSTATUS gckVGKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            (gctUINT32)(Interface->u.LockVideoMemory.memory);
 #endif
+        gcmkERR_BREAK(
+            gckKERNEL_AddProcessDB(Kernel,
+                                   processID, gcvDB_VIDEO_MEMORY_LOCKED,
+                                   node,
+                                   gcvNULL,
+                                   0));
         break;
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -671,6 +748,16 @@ gceSTATUS gckVGKERNEL_Dispatch(
                                                           bytes));
         }
 #endif
+
+        if (Interface->u.UnlockVideoMemory.asynchroneous == gcvFALSE)
+        {
+            /* There isn't a event to unlock this node, remove record now */
+            gcmkERR_BREAK(
+                    gckKERNEL_RemoveProcessDB(Kernel,
+                        processID, gcvDB_VIDEO_MEMORY_LOCKED,
+                        node));
+        }
+
         break;
     case gcvHAL_USER_SIGNAL:
 #if !USE_NEW_LINUX_SIGNAL
@@ -730,10 +817,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Commit a command and context buffer. */
         gcmkERR_BREAK(gckVGCOMMAND_Commit(
             Kernel->vg->command,
-            kernelInterface->u.VGCommit.context,
-            kernelInterface->u.VGCommit.queue,
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.context),
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.queue),
             kernelInterface->u.VGCommit.entryCount,
-            kernelInterface->u.VGCommit.taskTable
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.taskTable)
             ));
         break;
     case gcvHAL_VERSION:
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
index 04fccf4..b6c6d7e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,10 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
-
 #ifndef __gc_hal_kernel_vg_h_
 #define __gc_hal_kernel_vg_h_
 
@@ -34,7 +30,6 @@
 ********************************** Structures **********************************
 \******************************************************************************/
 
-
 /* gckKERNEL object. */
 struct _gckVGKERNEL
 {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index 288b330..d49aa64 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_VIDMEM
@@ -245,7 +243,7 @@ gckVIDMEM_ConstructVirtual(
     node->Virtual.contiguous    = Contiguous;
     node->Virtual.logical       = gcvNULL;
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         node->Virtual.lockeds[i]        = 0;
         node->Virtual.pageTables[i]     = gcvNULL;
@@ -259,7 +257,7 @@ gckVIDMEM_ConstructVirtual(
 #ifdef __QNXNTO__
     node->Virtual.next          = gcvNULL;
     node->Virtual.freePending   = gcvFALSE;
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         node->Virtual.unlockPendings[i] = gcvFALSE;
     }
@@ -366,7 +364,7 @@ gckVIDMEM_DestroyVirtual(
     /* Delete the mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(os, Node->Virtual.mutex));
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (Node->Virtual.pageTables[i] != gcvNULL)
         {
@@ -1246,7 +1244,7 @@ gckVIDMEM_Free(
     gckVIDMEM memory = gcvNULL;
     gcuVIDMEM_NODE_PTR node;
     gctBOOL mutexAcquired = gcvFALSE;
-    gckOS os = gcvFALSE;
+    gckOS os = gcvNULL;
     gctBOOL acquired = gcvFALSE;
     gctINT32 i, totalLocked;
 
@@ -1392,7 +1390,7 @@ gckVIDMEM_Free(
 
     acquired = gcvTRUE;
 
-    for (i = 0, totalLocked = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0, totalLocked = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         totalLocked += Node->Virtual.lockeds[i];
     }
@@ -1590,7 +1588,7 @@ _NeedVirtualMapping(
     gcmkVERIFY_ARGUMENT(Kernel != gcvNULL);
     gcmkVERIFY_ARGUMENT(Node != gcvNULL);
     gcmkVERIFY_ARGUMENT(NeedMapping != gcvNULL);
-    gcmkVERIFY_ARGUMENT(Core < gcdCORE_COUNT);
+    gcmkVERIFY_ARGUMENT(Core < gcdMAX_GPU_COUNT);
 
     if (Node->Virtual.contiguous)
     {
@@ -1603,7 +1601,7 @@ _NeedVirtualMapping(
 #endif
         {
             /* For cores which can't access all physical address. */
-            gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os,
+            gcmkONERROR(gckHARDWARE_ConvertLogical(Kernel->hardware,
                         Node->Virtual.logical,
                         &phys));
 
@@ -1663,6 +1661,7 @@ gckVIDMEM_Lock(
     gctBOOL locked = gcvFALSE;
     gckOS os = gcvNULL;
     gctBOOL needMapping;
+    gctUINT32 baseAddress;
 
     gcmkHEADER_ARG("Node=0x%x", Node);
 
@@ -1689,7 +1688,7 @@ gckVIDMEM_Lock(
         /* Increment the lock count. */
         Node->VidMem.locked ++;
 
-        /* Return the address of the node. */
+        /* Return the physical address of the node. */
 #if !gcdUSE_VIDMEM_PER_PID
         *Address = Node->VidMem.memory->baseAddress
                  + Node->VidMem.offset
@@ -1698,6 +1697,20 @@ gckVIDMEM_Lock(
         *Address = Node->VidMem.physical;
 #endif
 
+        /* Get hardware specific address. */
+#if gcdENABLE_VG
+        if (Kernel->vg == gcvNULL)
+#endif
+        {
+            if (Kernel->hardware->mmuVersion == 0)
+            {
+                /* Convert physical to GPU address for old mmu. */
+                gcmkONERROR(gckOS_GetBaseAddress(Kernel->os, &baseAddress));
+                gcmkASSERT(*Address > baseAddress);
+                *Address -= baseAddress;
+            }
+        }
+
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                       "Locked node 0x%x (%d) @ 0x%08X",
                       Node,
@@ -1755,10 +1768,21 @@ gckVIDMEM_Lock(
 
             if (needMapping == gcvFALSE)
             {
-                /* Get physical address directly */
-                 gcmkONERROR(gckOS_GetPhysicalAddress(os,
-                             Node->Virtual.logical,
-                             &Node->Virtual.addresses[Kernel->core]));
+                /* Get hardware specific address. */
+#if gcdENABLE_VG
+                if (Kernel->vg != gcvNULL)
+                {
+                    gcmkONERROR(gckVGHARDWARE_ConvertLogical(Kernel->vg->hardware,
+                                Node->Virtual.logical,
+                                &Node->Virtual.addresses[Kernel->core]));
+                }
+                else
+#endif
+                {
+                    gcmkONERROR(gckHARDWARE_ConvertLogical(Kernel->hardware,
+                                Node->Virtual.logical,
+                                &Node->Virtual.addresses[Kernel->core]));
+                }
             }
             else
             {
@@ -1804,7 +1828,11 @@ gckVIDMEM_Lock(
 #endif
 
 #if gcdENABLE_VG
-                if (Kernel->core != gcvCORE_VG)
+                if (Kernel->core == gcvCORE_VG)
+                {
+                    gcmkONERROR(gckVGMMU_Flush(Kernel->vg->mmu));
+                }
+                else
 #endif
                 {
                     gcmkONERROR(gckMMU_Flush(Kernel->mmu));
@@ -2052,7 +2080,7 @@ gckVIDMEM_Unlock(
 #endif
             }
 
-            for (i = 0, totalLocked = 0; i < gcdCORE_COUNT; i++)
+            for (i = 0, totalLocked = 0; i < gcdMAX_GPU_COUNT; i++)
             {
                 totalLocked += Node->Virtual.lockeds[i];
             }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index a7e6e7a..7077412 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_h_
 #define __gc_hal_h_
 
@@ -30,6 +28,9 @@
 #include "gc_hal_base.h"
 #include "gc_hal_profiler.h"
 #include "gc_hal_driver.h"
+#ifndef VIVANTE_NO_3D
+#include "gc_hal_statistics.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -46,7 +47,7 @@ extern "C" {
 
 #define gcmALIGN_BASE(n, align) \
 ( \
-    (n) & ~((align) - 1) \
+    ((n) & ~((align) - 1)) \
 )
 
 /******************************************************************************\
@@ -64,6 +65,65 @@ extern "C" {
 )
 
 /******************************************************************************\
+********************************* Cast Macro **********************************
+\******************************************************************************/
+#define gcmNAME_TO_PTR(na) \
+        gckKERNEL_QueryPointerFromName(kernel, gcmALL_TO_UINT32(na))
+
+#define gcmPTR_TO_NAME(ptr) \
+        gckKERNEL_AllocateNameFromPointer(kernel, ptr)
+
+#define gcmRELEASE_NAME(na) \
+        gckKERNEL_DeleteName(kernel, gcmALL_TO_UINT32(na))
+
+#ifdef __LP64__
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (gctUINTPTR_T) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (u)\
+)
+
+#else /* 32 bit */
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (gctUINTPTR_T) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (gctUINTPTR_T) (u)\
+)
+
+#endif
+
+#define gcmUINT64_TO_TYPE(u, t) \
+( \
+    (t) (gctUINTPTR_T) (u)\
+)
+
+/******************************************************************************\
+******************************** Useful Macro *********************************
+\******************************************************************************/
+
+#define gcvINVALID_ADDRESS          ~0U
+
+/******************************************************************************\
 ******************************** gcsOBJECT Object *******************************
 \******************************************************************************/
 
@@ -131,7 +191,7 @@ typedef enum _gceCORE
 }
 gceCORE;
 
-#define gcdCORE_COUNT               3
+#define gcdMAX_GPU_COUNT               3
 
 /*******************************************************************************
 **
@@ -497,6 +557,17 @@ gckOS_UnmapMemory(
     IN gctPOINTER Logical
     );
 
+/* Unmap user logical memory out of physical memory.
+ * This function is only supported in Linux currently.
+ */
+gceSTATUS
+gckOS_UnmapUserLogical(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    );
+
 /* Create a new mutex. */
 gceSTATUS
 gckOS_CreateMutex(
@@ -559,11 +630,19 @@ gckOS_AtomClearMask(
 #endif
 
 gceSTATUS
-gckOS_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
+gckOS_DumpCallStack(
+    IN gckOS Os
     );
 
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
+    );
+
+
+
 /*******************************************************************************
 **
 **  gckOS_AtomConstruct
@@ -1026,18 +1105,9 @@ gckOS_UnmapSignal(
 gceSTATUS
 gckOS_MapUserMemory(
     IN gckOS Os,
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Size,
-    OUT gctPOINTER * Info,
-    OUT gctUINT32_PTR Address
-    );
-
-/* Map user memory. */
-gceSTATUS
-gckOS_MapUserMemoryEx(
-    IN gckOS Os,
     IN gceCORE Core,
     IN gctPOINTER Memory,
+    IN gctUINT32 Physical,
     IN gctSIZE_T Size,
     OUT gctPOINTER * Info,
     OUT gctUINT32_PTR Address
@@ -1047,16 +1117,6 @@ gckOS_MapUserMemoryEx(
 gceSTATUS
 gckOS_UnmapUserMemory(
     IN gckOS Os,
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Size,
-    IN gctPOINTER Info,
-    IN gctUINT32 Address
-    );
-
-/* Unmap user memory. */
-gceSTATUS
-gckOS_UnmapUserMemoryEx(
-    IN gckOS Os,
     IN gceCORE Core,
     IN gctPOINTER Memory,
     IN gctSIZE_T Size,
@@ -1239,8 +1299,8 @@ gckOS_BroadcastCalibrateSpeed(
 **      gckOS Os
 **          Pointer to a gckOS object.ß
 **
-**      gceCORE Core
-**          Core type.
+**      gckCORE Core
+**          GPU whose power is set.
 **
 **      gctBOOL Clock
 **          gcvTRUE to turn on the clock, or gcvFALSE to turn off the clock.
@@ -1260,6 +1320,39 @@ gckOS_SetGPUPower(
     IN gctBOOL Power
     );
 
+gceSTATUS
+gckOS_ResetGPU(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    );
+
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    );
+
 /*******************************************************************************
 ** Semaphores.
 */
@@ -1307,6 +1400,43 @@ gckOS_ReleaseSemaphore(
     IN gctPOINTER Semaphore
     );
 
+/*******************************************************************************
+** Timer API.
+*/
+
+typedef void (*gctTIMERFUNCTION)(gctPOINTER);
+
+/* Create a timer. */
+gceSTATUS
+gckOS_CreateTimer(
+    IN gckOS Os,
+    IN gctTIMERFUNCTION Function,
+    IN gctPOINTER Data,
+    OUT gctPOINTER * Timer
+    );
+
+/* Destory a timer. */
+gceSTATUS
+gckOS_DestroyTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    );
+
+/* Start a timer. */
+gceSTATUS
+gckOS_StartTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer,
+    IN gctUINT32 Delay
+    );
+
+/* Stop a timer. */
+gceSTATUS
+gckOS_StopTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    );
+
 /******************************************************************************\
 ********************************* gckHEAP Object ********************************
 \******************************************************************************/
@@ -1362,6 +1492,7 @@ gckHEAP_ProfileEnd(
 typedef struct _gckVIDMEM *         gckVIDMEM;
 typedef struct _gckKERNEL *         gckKERNEL;
 typedef struct _gckDB *             gckDB;
+typedef struct _gckDVFS *           gckDVFS;
 
 /* Construct a new gckVIDMEM object. */
 gceSTATUS
@@ -1652,6 +1783,27 @@ gckKERNEL_CloseUserData(
     OUT gctPOINTER * KernelPointer
     );
 
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Frequency
+    );
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    );
+
 /******************************************************************************\
 ******************************* gckHARDWARE Object *****************************
 \******************************************************************************/
@@ -1920,6 +2072,22 @@ gckHARDWARE_QueryPowerManagementState(
     OUT gceCHIPPOWERSTATE* State
     );
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+gceSTATUS
+gckHARDWARE_SetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32   FscaleValue
+    );
+
+gceSTATUS
+gckHARDWARE_GetFscaleValue(
+    IN gckHARDWARE Hardware,
+    IN gctUINT * FscaleValue,
+    IN gctUINT * MinFscaleValue,
+    IN gctUINT * MaxFscaleValue
+    );
+#endif
+
 #if gcdPOWEROFF_TIMEOUT
 gceSTATUS
 gckHARDWARE_SetPowerOffTimeout(
@@ -1980,6 +2148,33 @@ gckHARDWARE_IsFeatureAvailable(
     IN gceFEATURE Feature
     );
 
+gceSTATUS
+gckHARDWARE_DumpMMUException(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    );
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Frequency
+    );
+
 #if !gcdENABLE_VG
 /******************************************************************************\
 ***************************** gckINTERRUPT Object ******************************
@@ -2049,7 +2244,8 @@ gckEVENT_AddList(
     IN gckEVENT Event,
     IN gcsHAL_INTERFACE_PTR Interface,
     IN gceKERNEL_WHERE FromWhere,
-    IN gctBOOL AllocateAllowed
+    IN gctBOOL AllocateAllowed,
+    IN gctBOOL FromKernel
     );
 
 /* Schedule a FreeNonPagedMemory event. */
@@ -2103,6 +2299,18 @@ gckEVENT_CommitDone(
     IN gceKERNEL_WHERE FromWhere
     );
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+/* Schedule a FreeVirtualCommandBuffer event. */
+gceSTATUS
+gckEVENT_DestroyVirtualCommandBuffer(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    );
+#endif
+
 gceSTATUS
 gckEVENT_Submit(
     IN gckEVENT Event,
@@ -2238,6 +2446,13 @@ gckCOMMAND_Detach(
     IN gckCONTEXT Context
     );
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    );
+#endif
+
 /******************************************************************************\
 ********************************* gckMMU Object ********************************
 \******************************************************************************/
@@ -2317,16 +2532,35 @@ gckMMU_Flush(
     IN gckMMU Mmu
     );
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    );
+
 
 #if VIVANTE_PROFILER
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Clear,
     OUT gcsPROFILER_COUNTERS * Counters
     );
 #endif
 
+gceSTATUS
+gckOS_SignalQueryHardware(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    OUT gckHARDWARE * Hardware
+    );
 
+gceSTATUS
+gckOS_SignalSetHardware(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    gckHARDWARE Hardware
+    );
 
 #ifdef __cplusplus
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 72e23ad..ac86399 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_base_h_
 #define __gc_hal_base_h_
 
@@ -28,7 +26,6 @@
 #include "gc_hal_types.h"
 
 #include "gc_hal_dump.h"
-#include "gc_hal_md5.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -59,6 +56,8 @@ typedef struct _gcoDUMP *               gcoDUMP;
 typedef struct _gcoHARDWARE *           gcoHARDWARE;
 typedef union  _gcuVIDMEM_NODE *        gcuVIDMEM_NODE_PTR;
 
+typedef struct gcsATOM *                gcsATOM_PTR;
+
 #if gcdENABLE_VG
 typedef struct _gcoVG *                 gcoVG;
 typedef struct _gcsCOMPLETION_SIGNAL *	gcsCOMPLETION_SIGNAL_PTR;
@@ -67,6 +66,11 @@ typedef struct _gcsCONTEXT_MAP *		gcsCONTEXT_MAP_PTR;
 typedef void *                          gcoVG;
 #endif
 
+#if gcdSYNC
+typedef struct _gcoFENCE *              gcoFENCE;
+typedef struct _gcsSYNC_CONTEXT  *      gcsSYNC_CONTEXT_PTR;
+#endif
+
 /******************************************************************************\
 ******************************* Process local storage *************************
 \******************************************************************************/
@@ -96,6 +100,17 @@ typedef struct _gcsPLS
     /* EGL-specific process-wide objects. */
     gctPOINTER                  eglDisplayInfo;
     gctPOINTER                  eglSurfaceInfo;
+    gceSURF_FORMAT              eglConfigFormat;
+
+    /* PorcessID of the constrcutor process */
+    gctUINT32                   processID;
+
+    /* Reference count for destructor. */
+    gcsATOM_PTR                 reference;
+#if gcdUSE_NPOT_PATCH
+    gctBOOL                     bNeedSupportNP2Texture;
+#endif
+
 }
 gcsPLS;
 
@@ -128,7 +143,11 @@ typedef struct _gcsTLS
 #ifndef VIVANTE_NO_3D
 	gco3D						engine3D;
 #endif
+#if gcdSYNC
+    gctBOOL                     fenceEnable;
+#endif
 	gco2D						engine2D;
+    gctBOOL                     copied;
 }
 gcsTLS;
 
@@ -139,7 +158,8 @@ gcsTLS;
 typedef enum _gcePLS_VALUE
 {
   gcePLS_VALUE_EGL_DISPLAY_INFO,
-  gcePLS_VALUE_EGL_SURFACE_INFO
+  gcePLS_VALUE_EGL_SURFACE_INFO,
+  gcePLS_VALUE_EGL_CONFIG_FORMAT_INFO,
 }
 gcePLS_VALUE;
 
@@ -156,6 +176,8 @@ typedef enum _gcePOOL
     gcvPOOL_VIRTUAL,
     gcvPOOL_USER,
     gcvPOOL_CONTIGUOUS,
+    gcvPOOL_DEFAULT_FORCE_CONTIGUOUS,
+    gcvPOOL_DEFAULT_FORCE_CONTIGUOUS_CACHEABLE,
 
     gcvPOOL_NUMBER_OF_POOLS
 }
@@ -343,6 +365,23 @@ gcoHAL_Get2DEngine(
     OUT gco2D * Engine
     );
 
+gceSTATUS
+gcoHAL_SetFscaleValue(
+    IN gctUINT FscaleValue
+    );
+
+gceSTATUS
+gcoHAL_GetFscaleValue(
+    OUT gctUINT * FscaleValue,
+    OUT gctUINT * MinFscaleValue,
+    OUT gctUINT * MaxFscaleValue
+    );
+
+gceSTATUS
+gcoHAL_SetBltNP2Texture(
+    gctBOOL enable
+    );
+
 #ifndef VIVANTE_NO_3D
 /* Get pointer to gco3D object. */
 gceSTATUS
@@ -441,6 +480,25 @@ gcoHAL_ScheduleUnmapMemory(
     IN gctPOINTER Logical
     );
 
+/* Map user memory. */
+gceSTATUS
+gcoHAL_MapUserMemory(
+    IN gctPOINTER Logical,
+    IN gctUINT32 Physical,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * Info,
+    OUT gctUINT32_PTR GPUAddress
+    );
+
+/* Unmap user memory. */
+gceSTATUS
+gcoHAL_UnmapUserMemory(
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Size,
+    IN gctPOINTER Info,
+    IN gctUINT32 GPUAddress
+    );
+
 /* Schedule an unmap of a user buffer using event mechanism. */
 gceSTATUS
 gcoHAL_ScheduleUnmapUserMemory(
@@ -473,7 +531,7 @@ gcoHAL_Compact(
     IN gcoHAL Hal
     );
 
-#if VIVANTE_PROFILER /*gcdENABLE_PROFILING*/
+#if VIVANTE_PROFILER
 gceSTATUS
 gcoHAL_ProfileStart(
     IN gcoHAL Hal
@@ -600,6 +658,8 @@ gcoHAL_QueryChipFeature(
     IN gceFEATURE   Feature);
 
 #endif
+
+
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
 \******************************************************************************/
@@ -623,6 +683,9 @@ gcoOS_GetTLS(
     OUT gcsTLS_PTR * TLS
     );
 
+    /* Copy the TLS from a source thread. */
+    gceSTATUS gcoOS_CopyTLS(IN gcsTLS_PTR Source);
+
 /* Destroy the objects associated with the current thread. */
 void
 gcoOS_FreeThreadData(
@@ -706,6 +769,25 @@ gcoOS_FreeContiguous(
     IN gctSIZE_T Bytes
     );
 
+/* Allocate video memory. */
+gceSTATUS
+gcoOS_AllocateVideoMemory(
+    IN gcoOS Os,
+    IN gctBOOL InUserSpace,
+    IN gctBOOL InCacheable,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctUINT32 * Physical,
+    OUT gctPOINTER * Logical,
+    OUT gctPOINTER * Handle
+    );
+
+/* Free video memory. */
+gceSTATUS
+gcoOS_FreeVideoMemory(
+    IN gcoOS Os,
+    IN gctPOINTER Handle
+    );
+
 #if gcdENABLE_BANK_ALIGNMENT
 gceSTATUS
 gcoSURF_GetBankOffsetBytes(
@@ -726,6 +808,17 @@ gcoOS_MapUserMemory(
     OUT gctUINT32_PTR Address
     );
 
+/* Map user memory. */
+gceSTATUS
+gcoOS_MapUserMemoryEx(
+    IN gcoOS Os,
+    IN gctPOINTER Memory,
+    IN gctUINT32 Physical,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * Info,
+    OUT gctUINT32_PTR Address
+    );
+
 /* Unmap user memory. */
 gceSTATUS
 gcoOS_UnmapUserMemory(
@@ -935,29 +1028,6 @@ gcoOS_GetPos(
     OUT gctUINT32 * Position
     );
 
-/* Perform a memory copy. */
-gceSTATUS
-gcoOS_MemCopy(
-    IN gctPOINTER Destination,
-    IN gctCONST_POINTER Source,
-    IN gctSIZE_T Bytes
-    );
-
-/* Perform a memory fill. */
-gceSTATUS
-gcoOS_MemFill(
-    IN gctPOINTER Destination,
-    IN gctUINT8 Filler,
-    IN gctSIZE_T Bytes
-    );
-
-/* Zero memory. */
-gceSTATUS
-gcoOS_ZeroMemory(
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Bytes
-    );
-
 /* Same as strstr. */
 gceSTATUS
 gcoOS_StrStr(
@@ -975,12 +1045,6 @@ gcoOS_StrFindReverse(
     );
 
 gceSTATUS
-gcoOS_StrLen(
-    IN gctCONST_STRING String,
-    OUT gctSIZE_T * Length
-    );
-
-gceSTATUS
 gcoOS_StrDup(
     IN gcoOS Os,
     IN gctCONST_STRING String,
@@ -1026,13 +1090,15 @@ gcoOS_StrToFloat(
     );
 
 /* Convert hex string to integer. */
-gceSTATUS gcoOS_HexStrToInt(
+gceSTATUS
+gcoOS_HexStrToInt(
 	IN gctCONST_STRING String,
 	OUT gctINT * Int
 	);
 
 /* Convert hex string to float. */
-gceSTATUS gcoOS_HexStrToFloat(
+gceSTATUS
+gcoOS_HexStrToFloat(
 	IN gctCONST_STRING String,
 	OUT gctFLOAT * Float
 	);
@@ -1091,7 +1157,7 @@ gcoOS_AddSignalHandler (
     IN gceSignalHandlerType SignalHandlerType
     );
 
-#if VIVANTE_PROFILER /*gcdENABLE_PROFILING*/
+#if VIVANTE_PROFILER
 gceSTATUS
 gcoOS_ProfileStart(
     IN gcoOS Os
@@ -1111,6 +1177,11 @@ gcoOS_SetProfileSetting(
         );
 #endif
 
+gctBOOL
+gcoOS_IsNeededSupportNP2Texture(
+    IN gctCHAR* ProcName
+    );
+
 /* Query the video memory. */
 gceSTATUS
 gcoOS_QueryVideoMemory(
@@ -1125,15 +1196,25 @@ gcoOS_QueryVideoMemory(
 
 /* Detect if the process is the executable specified. */
 gceSTATUS
+gcoOS_DetectProcessByNamePid(
+    IN gctCONST_STRING Name,
+    IN gctHANDLE Pid
+    );
+
+/* Detect if the current process is the executable specified. */
+gceSTATUS
 gcoOS_DetectProcessByName(
     IN gctCONST_STRING Name
     );
 
+gceSTATUS
+gcoOS_DetectProcessByEncryptedName(
+    IN gctCONST_STRING Name
+    );
+
 /*----------------------------------------------------------------------------*/
 /*----- Atoms ----------------------------------------------------------------*/
 
-typedef struct gcsATOM * gcsATOM_PTR;
-
 /* Construct an atom. */
 gceSTATUS
 gcoOS_AtomConstruct(
@@ -1343,7 +1424,7 @@ gcoOS_ReadRegister(
 gceSTATUS
 gcoOS_CacheClean(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1351,7 +1432,7 @@ gcoOS_CacheClean(
 gceSTATUS
 gcoOS_CacheFlush(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1359,7 +1440,7 @@ gcoOS_CacheFlush(
 gceSTATUS
 gcoOS_CacheInvalidate(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1689,7 +1770,7 @@ gcoSURF_MapUserSurface(
 gceSTATUS
 gcoSURF_QueryVidMemNode(
     IN gcoSURF Surface,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gcePOOL * Pool,
     OUT gctUINT_PTR Bytes
     );
@@ -1949,6 +2030,10 @@ gcoSURF_SetLinearResolveAddress(
     IN gctUINT32 Address,
     IN gctPOINTER Memory
     );
+
+    gceSTATUS
+    gcoSURF_Swap(IN gcoSURF Surface1, IN gcoSURF Surface2);
+
 /******************************************************************************\
 ********************************* gcoDUMP Object ********************************
 \******************************************************************************/
@@ -2020,6 +2105,11 @@ gcoDUMP_Delete(
     IN gctUINT32 Address
     );
 
+/* Enable dump or not. */
+gceSTATUS
+gcoDUMP_SetDumpFlag(
+    IN gctBOOL DumpState
+    );
 
 /******************************************************************************\
 ******************************* gcsRECT Structure ******************************
@@ -2147,7 +2237,7 @@ gcoHEAP_Free(
     IN gctPOINTER Node
     );
 
-#if (VIVANTE_PROFILER /*gcdENABLE_PROFILING*/ || gcdDEBUG)
+#if (VIVANTE_PROFILER  || gcdDEBUG)
 /* Profile the heap. */
 gceSTATUS
 gcoHEAP_ProfileStart(
@@ -2344,6 +2434,7 @@ gcoOS_DebugTrace(
 #define gcvZONE_DEVICE          (1 << 10)
 #define gcvZONE_DATABASE        (1 << 11)
 #define gcvZONE_INTERRUPT       (1 << 12)
+#define gcvZONE_POWER           (1 << 13)
 
 /* User zones. */
 #define gcvZONE_HAL             (1 << 3)
@@ -2377,6 +2468,7 @@ gcoOS_DebugTrace(
 #define gcvZONE_API_DFB         (7 << 28)
 #define gcvZONE_API_GDI         (8 << 28)
 #define gcvZONE_API_D3D         (9 << 28)
+#define gcvZONE_API_ES30        (10 << 28)
 
 
 #define gcmZONE_GET_API(zone)   ((zone) >> 28)
@@ -2747,9 +2839,10 @@ gcoOS_ProfileDB(
 #   define gcmkFOOTER_ARG               __dummy_kfooter_arg
 #endif
 
-#define gcmOPT_VALUE(ptr)           (((ptr) == gcvNULL) ? 0 : *(ptr))
-#define gcmOPT_POINTER(ptr)         (((ptr) == gcvNULL) ? gcvNULL : *(ptr))
-#define gcmOPT_STRING(ptr)          (((ptr) == gcvNULL) ? "(nil)" : (ptr))
+#define gcmOPT_VALUE(ptr)               (((ptr) == gcvNULL) ? 0 : *(ptr))
+#define gcmOPT_VALUE_INDEX(ptr, index)  (((ptr) == gcvNULL) ? 0 : ptr[index])
+#define gcmOPT_POINTER(ptr)             (((ptr) == gcvNULL) ? gcvNULL : *(ptr))
+#define gcmOPT_STRING(ptr)              (((ptr) == gcvNULL) ? "(nil)" : (ptr))
 
 void
 gckOS_Print(
@@ -3006,12 +3099,8 @@ gcfDumpBuffer(
 **
 **      ...         Optional arguments.
 */
+gceSTATUS gcfDumpApi(IN gctCONST_STRING String, ...);
 #if gcdDUMP_API
-    gceSTATUS
-    gcfDumpApi(
-        IN gctCONST_STRING String,
-        ...
-        );
 #   define gcmDUMP_API           gcfDumpApi
 #elif gcdHAS_ELLIPSES
 #   define gcmDUMP_API(...)
@@ -3037,12 +3126,8 @@ gcfDumpBuffer(
 **      gctUINT32_PTR   Pointer to array.
 **      gctUINT32       Size.
 */
+gceSTATUS gcfDumpArray(IN gctCONST_POINTER Data, IN gctUINT32 Size);
 #if gcdDUMP_API
-    gceSTATUS
-    gcfDumpArray(
-        IN gctCONST_POINTER Data,
-        IN gctUINT32 Size
-    );
 #   define gcmDUMP_API_ARRAY        gcfDumpArray
 #elif gcdHAS_ELLIPSES
 #   define gcmDUMP_API_ARRAY(...)
@@ -3068,12 +3153,8 @@ gcfDumpBuffer(
 **      gctUINT32_PTR   Pointer to array.
 **      gctUINT32       Termination.
 */
+gceSTATUS gcfDumpArrayToken(IN gctCONST_POINTER Data, IN gctUINT32 Termination);
 #if gcdDUMP_API
-    gceSTATUS
-    gcfDumpArrayToken(
-        IN gctCONST_POINTER Data,
-        IN gctUINT32 Termination
-    );
 #   define gcmDUMP_API_ARRAY_TOKEN  gcfDumpArrayToken
 #elif gcdHAS_ELLIPSES
 #   define gcmDUMP_API_ARRAY_TOKEN(...)
@@ -3099,12 +3180,8 @@ gcfDumpBuffer(
 **      gctCONST_POINTER    Pointer to array.
 **      gctSIZE_T           Size.
 */
+gceSTATUS gcfDumpApiData(IN gctCONST_POINTER Data, IN gctSIZE_T Size);
 #if gcdDUMP_API
-    gceSTATUS
-    gcfDumpApiData(
-        IN gctCONST_POINTER Data,
-        IN gctSIZE_T Size
-    );
 #   define gcmDUMP_API_DATA         gcfDumpApiData
 #elif gcdHAS_ELLIPSES
 #   define gcmDUMP_API_DATA(...)
@@ -3459,7 +3536,7 @@ gckOS_DebugStatus2Name(
 **      surfaceInfo Pointer to the surface iniformational structure.
 */
 #define gcmVERIFY_NODE_LOCK(surfaceNode) \
-    if (!surfaceNode->valid) \
+    if (!(surfaceNode)->valid) \
     { \
         status = gcvSTATUS_MEMORY_UNLOCKED; \
         break; \
@@ -3572,6 +3649,7 @@ gckOS_DebugStatus2Name(
 #   define gcmDEBUG_VERIFY_ARGUMENT(arg)
 #   define gcmkDEBUG_VERIFY_ARGUMENT(arg)
 #endif
+
 /*******************************************************************************
 **
 **  gcmVERIFY_ARGUMENT_RETURN
@@ -3605,6 +3683,48 @@ gckOS_DebugStatus2Name(
 
 #define MAX_LOOP_COUNT 0x7FFFFFFF
 
+/******************************************************************************\
+****************************** User Debug Option ******************************
+\******************************************************************************/
+
+/* User option. */
+typedef enum _gceDEBUG_MSG
+{
+    gcvDEBUG_MSG_NONE,
+    gcvDEBUG_MSG_ERROR,
+    gcvDEBUG_MSG_WARNING
+}
+gceDEBUG_MSG;
+
+typedef struct _gcsUSER_DEBUG_OPTION
+{
+    gceDEBUG_MSG        debugMsg;
+}
+gcsUSER_DEBUG_OPTION;
+
+gcsUSER_DEBUG_OPTION *
+gcGetUserDebugOption(
+    void
+    );
+
+#if gcdHAS_ELLIPSES
+#define gcmUSER_DEBUG_MSG(level, ...) \
+    do \
+    { \
+        if (level <= gcGetUserDebugOption()->debugMsg) \
+        { \
+            gcoOS_Print(__VA_ARGS__); \
+        } \
+    } while (gcvFALSE)
+
+#define gcmUSER_DEBUG_ERROR_MSG(...)   gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_ERROR, "Error: " __VA_ARGS__)
+#define gcmUSER_DEBUG_WARNING_MSG(...) gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_WARNING, "Warring: " __VA_ARGS__)
+#else
+#define gcmUSER_DEBUG_MSG
+#define gcmUSER_DEBUG_ERROR_MSG
+#define gcmUSER_DEBUG_WARNING_MSG
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
index ecdb763..4a0870f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file the defines the front- and back-end compilers, as well as the
 **	objects they use.
@@ -41,6 +39,9 @@ extern "C" {
 #define GC_ENABLE_LOADTIME_OPT      1
 #endif
 
+#define TEMP_OPT_CONSTANT_TEXLD_COORD    1
+
+#define TEMP_SHADER_PATCH            1
 /******************************* IR VERSION ******************/
 #define gcdSL_IR_VERSION gcmCC('\0','\0','\0','\1')
 
@@ -48,6 +49,126 @@ extern "C" {
 |******************************* SHADER LANGUAGE ******************************|
 \******************************************************************************/
 
+    /* allocator/deallocator function pointer */
+typedef gceSTATUS (*gctAllocatorFunc)(
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+typedef gceSTATUS (*gctDeallocatorFunc)(
+    IN gctPOINTER Memory
+    );
+
+typedef gctBOOL (*compareFunc) (
+     IN void *    data,
+     IN void *    key
+     );
+
+typedef struct _gcsListNode gcsListNode;
+struct _gcsListNode
+{
+    gcsListNode *       next;
+    void *              data;
+};
+
+typedef struct _gcsAllocator
+{
+    gctAllocatorFunc    allocate;
+    gctDeallocatorFunc  deallocate;
+} gcsAllocator;
+
+/* simple map structure */
+typedef struct _SimpleMap SimpleMap;
+struct _SimpleMap
+{
+    gctUINT32     key;
+    gctUINT32     val;
+    SimpleMap    *next;
+    gcsAllocator *allocator;
+
+};
+
+/* SimpleMap Operations */
+/* return -1 if not found, otherwise return the mapped value */
+gctUINT32
+gcSimpleMap_Find(
+     IN SimpleMap *Map,
+     IN gctUINT32    Key
+     );
+
+gceSTATUS
+gcSimpleMap_Destory(
+     IN SimpleMap *    Map,
+     IN gcsAllocator * Allocator
+     );
+
+/* Add a pair <Key, Val> to the Map head, the user should be aware that the
+ * map pointer is always changed when adding a new node :
+ *
+ *   gcSimpleMap_AddNode(&theMap, key, val, allocator);
+ *
+ */
+gceSTATUS
+gcSimpleMap_AddNode(
+     IN SimpleMap **   Map,
+     IN gctUINT32      Key,
+     IN gctUINT32      Val,
+     IN gcsAllocator * Allocator
+     );
+
+/* gcsList data structure and related operations */
+typedef struct _gcsList
+{
+    gcsListNode  *head;
+    gcsListNode  *tail;
+    gctINT        count;
+    gcsAllocator *allocator;
+} gcsList;
+
+/* List operations */
+void
+gcList_Init(
+    IN gcsList *list,
+    IN gcsAllocator *allocator
+    );
+
+gceSTATUS
+gcList_CreateNode(
+    IN void *             Data,
+    IN gctAllocatorFunc   Allocator,
+    OUT gcsListNode **    ListNode
+    );
+
+gceSTATUS
+gcList_Clean(
+    IN gcsList *          List,
+    IN gctBOOL            FreeData
+    );
+
+gcsListNode *
+gcList_FindNode(
+    IN gcsList *      List,
+    IN void *         Key,
+    IN compareFunc    compare
+    );
+
+gceSTATUS
+gcList_AddNode(
+    IN gcsList *          List,
+    IN void *             Data
+    );
+
+gceSTATUS
+gcList_RemoveNode(
+    IN gcsList *          List,
+    IN gcsListNode *      Node
+    );
+
+/*  link list structure for code list */
+typedef gcsList gcsCodeList;
+typedef gcsCodeList * gctCodeList;
+typedef gcsListNode gcsCodeListNode;
+
 /* Possible shader language opcodes. */
 typedef enum _gcSL_OPCODE
 {
@@ -146,6 +267,7 @@ typedef enum _gcSL_OPCODE
 	gcSL_ADDSAT,						/* 0x5C */  /* Integer only. */
 	gcSL_SUBSAT,						/* 0x5D */  /* Integer only. */
 	gcSL_MULSAT,						/* 0x5E */  /* Integer only. */
+	gcSL_MAXOPCODE
 }
 gcSL_OPCODE;
 
@@ -321,16 +443,15 @@ typedef enum _gcGL_DRIVER_VERSION {
     gcGL_DRIVER_ES30     /* OpenGL ES 3.0 */
 } gcGL_DRIVER_VERSION;
 
-#define gcm
 /* gcSHADER objects. */
-typedef struct _gcSHADER *			gcSHADER;
+typedef struct _gcSHADER *              gcSHADER;
 typedef struct _gcATTRIBUTE *			gcATTRIBUTE;
-typedef struct _gcUNIFORM *			gcUNIFORM;
-typedef struct _gcOUTPUT *			gcOUTPUT;
+typedef struct _gcUNIFORM *             gcUNIFORM;
+typedef struct _gcOUTPUT *              gcOUTPUT;
 typedef struct _gcsFUNCTION *			gcFUNCTION;
-typedef struct _gcsKERNEL_FUNCTION *		gcKERNEL_FUNCTION;
-typedef struct _gcsHINT *			gcsHINT_PTR;
-typedef struct _gcSHADER_PROFILER *     	gcSHADER_PROFILER;
+typedef struct _gcsKERNEL_FUNCTION *	gcKERNEL_FUNCTION;
+typedef struct _gcsHINT *               gcsHINT_PTR;
+typedef struct _gcSHADER_PROFILER *     gcSHADER_PROFILER;
 typedef struct _gcVARIABLE *			gcVARIABLE;
 
 struct _gcsHINT
@@ -341,6 +462,14 @@ struct _gcsHINT
     /* Flag whether the VS has point size or not. */
     gctBOOL     vsHasPointSize;
 
+#if gcdUSE_WCLIP_PATCH
+    /* Flag whether the VS gl_position.z depends on gl_position.w
+       it's a hint for wclipping */
+    gctBOOL     vsPositionZDependsOnW;
+#endif
+
+    gctBOOL     clipW;
+
     /* Element count. */
     gctUINT32   elementCount;
 
@@ -368,13 +497,32 @@ struct _gcsHINT
 	/* Flag whether the ThreadWalker is in PS. */
 	gctBOOL		threadWalkerInPS;
 
+#if gcdALPHA_KILL_IN_SHADER
+    /* States to set when alpha kill is enabled. */
+    gctUINT32   killStateAddress;
+    gctUINT32   alphaKillStateValue;
+    gctUINT32   colorKillStateValue;
+
+    /* Shader instructiuon. */
+    gctUINT32   killInstructionAddress;
+    gctUINT32   alphaKillInstruction[3];
+    gctUINT32   colorKillInstruction[3];
+#endif
+
+#if TEMP_SHADER_PATCH
+	gctUINT32	pachedShaderIdentifier;
+#endif
 };
 
+#if TEMP_SHADER_PATCH
+#define INVALID_SHADER_IDENTIFIER 0xFFFFFFFF
+#endif
+
 /* gcSHADER_TYPE enumeration. */
 typedef enum _gcSHADER_TYPE
 {
-	gcSHADER_FLOAT_X1,				/* 0x00 */
-	gcSHADER_FLOAT_X2,				/* 0x01 */
+    gcSHADER_FLOAT_X1   = 0,        /* 0x00 */
+    gcSHADER_FLOAT_X2,				/* 0x01 */
 	gcSHADER_FLOAT_X3,				/* 0x02 */
 	gcSHADER_FLOAT_X4,				/* 0x03 */
 	gcSHADER_FLOAT_2X2,				/* 0x04 */
@@ -412,10 +560,50 @@ typedef enum _gcSHADER_TYPE
 	gcSHADER_USAMPLER_3D,			/* 0x24 */
 	gcSHADER_USAMPLER_CUBIC,		/* 0x25 */
 	gcSHADER_SAMPLER_EXTERNAL_OES,		/* 0x26 */
-    gcSHADER_TYPE_COUNT
-}
+
+	gcSHADER_UINT_X1,			/* 0x27 */
+	gcSHADER_UINT_X2,			/* 0x28 */
+	gcSHADER_UINT_X3,			/* 0x29 */
+	gcSHADER_UINT_X4,			/* 0x2A */
+
+    gcSHADER_UNKONWN_TYPE,      /* do not add type after this */
+    gcSHADER_TYPE_COUNT         /* must to change gcvShaderTypeInfo at the
+                                 * same time if you add any new type! */}
 gcSHADER_TYPE;
 
+typedef enum _gcSHADER_TYPE_KIND
+{
+    gceTK_UNKOWN,
+    gceTK_FLOAT,
+    gceTK_INT,
+    gceTK_UINT,
+    gceTK_BOOL,
+    gceTK_FIXED,
+    gceTK_SAMPLER,
+    gceTK_IMAGE,
+    gceTK_OTHER
+} gcSHADER_TYPE_KIND;
+
+typedef struct _gcSHADER_TYPEINFO
+{
+    gcSHADER_TYPE      type;              /* e.g. gcSHADER_FLOAT_2X4 */
+    gctINT             components;        /* e.g. 4 components       */
+    gctINT             rows;              /* e.g. 2 rows             */
+    gcSHADER_TYPE      componentType;     /* e.g. gcSHADER_FLOAT_X4  */
+    gcSHADER_TYPE_KIND kind;              /* e.g. gceTK_FLOAT */
+    gctCONST_STRING    name;              /* e.g. "FLOAT_2X4" */
+} gcSHADER_TYPEINFO;
+
+extern gcSHADER_TYPEINFO gcvShaderTypeInfo[];
+
+#define gcmType_Comonents(Type)    (gcvShaderTypeInfo[Type].components)
+#define gcmType_Rows(Type)         (gcvShaderTypeInfo[Type].rows)
+#define gcmType_ComonentType(Type) (gcvShaderTypeInfo[Type].componentType)
+#define gcmType_Kind(Type)         (gcvShaderTypeInfo[Type].kind)
+#define gcmType_Name(Type)         (gcvShaderTypeInfo[Type].name)
+
+#define gcmType_isMatrix(type) (gcmType_Rows(type) > 1)
+
 typedef enum _gcSHADER_VAR_CATEGORY
 {
     gcSHADER_VAR_CATEGORY_NORMAL  =  0, /* primitive type and its array */
@@ -423,8 +611,15 @@ typedef enum _gcSHADER_VAR_CATEGORY
 }
 gcSHADER_VAR_CATEGORY;
 
-#if GC_ENABLE_LOADTIME_OPT
+typedef enum _gceTYPE_QUALIFIER
+{
+    gcvTYPE_QUALIFIER_NONE         = 0x0, /* unqualified */
+    gcvTYPE_QUALIFIER_VOLATILE     = 0x1, /* volatile */
+}gceTYPE_QUALIFIER;
 
+typedef gctUINT16  gctTYPE_QUALIFIER;
+
+#if GC_ENABLE_LOADTIME_OPT
 typedef struct _gcSHADER_TYPE_INFO
 {
     gcSHADER_TYPE    type;        /* eg. gcSHADER_FLOAT_2X3 is the type */
@@ -435,6 +630,8 @@ typedef struct _gcSHADER_TYPE_INFO
     gctINT           size;        /* the size in byte */
 } gcSHADER_TYPE_INFO;
 
+extern gcSHADER_TYPE_INFO shader_type_info[];
+
 enum gceLTCDumpOption {
     gceLTC_DUMP_UNIFORM      = 0x0001,
     gceLTC_DUMP_EVALUATION   = 0x0002,
@@ -444,11 +641,8 @@ enum gceLTCDumpOption {
 
 gctBOOL gcDumpOption(gctINT Opt);
 
-extern gcSHADER_TYPE_INFO shader_type_info[];
-
 #endif /* GC_ENABLE_LOADTIME_OPT */
 
-
 #define IS_MATRIX_TYPE(type) \
     (((type >= gcSHADER_FLOAT_2X2) && (type <= gcSHADER_FLOAT_4X4)) || \
      ((type >= gcSHADER_FLOAT_2X3) && (type <= gcSHADER_FLOAT_4X3)))
@@ -471,23 +665,307 @@ typedef enum _gceSHADER_FLAGS
 	gcvSHADER_RESOURCE_USAGE			= 0x02,
 	gcvSHADER_OPTIMIZER					= 0x04,
 	gcvSHADER_USE_GL_Z					= 0x08,
-          /*
-                The GC family of GPU cores model GC860 and under require the Z
-                to be from 0 <= z <= w.
-                However, OpenGL specifies the Z to be from -w <= z <= w.  So we
-                have to a conversion here:
+    /*
+        The GC family of GPU cores model GC860 and under require the Z
+        to be from 0 <= z <= w.
+        However, OpenGL specifies the Z to be from -w <= z <= w.  So we
+        have to a conversion here:
 
-                    z = (z + w) / 2.
+            z = (z + w) / 2.
 
-                So here we append two instructions to the vertex shader.
-            */
+        So here we append two instructions to the vertex shader.
+    */
 	gcvSHADER_USE_GL_POSITION			= 0x10,
 	gcvSHADER_USE_GL_FACE				= 0x20,
 	gcvSHADER_USE_GL_POINT_COORD		= 0x40,
 	gcvSHADER_LOADTIME_OPTIMIZER		= 0x80,
+#if gcdALPHA_KILL_IN_SHADER
+    gcvSHADER_USE_ALPHA_KILL            = 0x100,
+#endif
+
 }
 gceSHADER_FLAGS;
 
+gceSTATUS
+gcSHADER_CheckClipW(
+    IN gctCONST_STRING VertexSource,
+    IN gctCONST_STRING FragmentSource,
+    OUT gctBOOL * clipW);
+
+/*******************************************************************************
+**							gcOptimizer Data Structures
+*******************************************************************************/
+typedef enum _gceSHADER_OPTIMIZATION
+{
+    /*  No optimization. */
+	gcvOPTIMIZATION_NONE,
+
+    /*  Flow graph construction. */
+	gcvOPTIMIZATION_CONSTRUCTION                = 1 << 0,
+
+    /*  Dead code elimination. */
+	gcvOPTIMIZATION_DEAD_CODE                   = 1 << 1,
+
+    /*  Redundant move instruction elimination. */
+	gcvOPTIMIZATION_REDUNDANT_MOVE              = 1 << 2,
+
+    /*  Inline expansion. */
+	gcvOPTIMIZATION_INLINE_EXPANSION            = 1 << 3,
+
+    /*  Constant propagation. */
+	gcvOPTIMIZATION_CONSTANT_PROPAGATION        = 1 << 4,
+
+    /*  Redundant bounds/checking elimination. */
+	gcvOPTIMIZATION_REDUNDANT_CHECKING          = 1 << 5,
+
+    /*  Loop invariant movement. */
+	gcvOPTIMIZATION_LOOP_INVARIANT              = 1 << 6,
+
+    /*  Induction variable removal. */
+	gcvOPTIMIZATION_INDUCTION_VARIABLE          = 1 << 7,
+
+    /*  Common subexpression elimination. */
+	gcvOPTIMIZATION_COMMON_SUBEXPRESSION        = 1 << 8,
+
+    /*  Control flow/banch optimization. */
+	gcvOPTIMIZATION_CONTROL_FLOW                = 1 << 9,
+
+    /*  Vector component operation merge. */
+	gcvOPTIMIZATION_VECTOR_INSTRUCTION_MERGE    = 1 << 10,
+
+    /*  Algebra simplificaton. */
+	gcvOPTIMIZATION_ALGEBRAIC_SIMPLIFICATION    = 1 << 11,
+
+    /*  Pattern matching and replacing. */
+	gcvOPTIMIZATION_PATTERN_MATCHING            = 1 << 12,
+
+    /*  Interprocedural constant propagation. */
+	gcvOPTIMIZATION_IP_CONSTANT_PROPAGATION     = 1 << 13,
+
+    /*  Interprecedural register optimization. */
+	gcvOPTIMIZATION_IP_REGISTRATION             = 1 << 14,
+
+    /*  Optimization option number. */
+	gcvOPTIMIZATION_OPTION_NUMBER               = 1 << 15,
+
+	/*  Loadtime constant. */
+    gcvOPTIMIZATION_LOADTIME_CONSTANT           = 1 << 16,
+
+    /*  MAD instruction optimization. */
+	gcvOPTIMIZATION_MAD_INSTRUCTION             = 1 << 17,
+
+    /*  Special optimization for LOAD SW workaround. */
+	gcvOPTIMIZATION_LOAD_SW_WORKAROUND          = 1 << 18,
+
+    /* move code into conditional block if possile */
+	gcvOPTIMIZATION_CONDITIONALIZE              = 1 << 19,
+
+    /* expriemental: power optimization mode
+        1. add extra dummy texld to tune performance
+        2. insert NOP after high power instrucitons
+        3. split high power vec3/vec4 instruciton to vec2/vec1 operation
+        4. ...
+     */
+	gcvOPTIMIZATION_POWER_OPTIMIZATION           = 1 << 20,
+
+    /* optimize varying packing */
+    gcvOPTIMIZATION_VARYINGPACKING              = 1 << 22,
+
+    /*  Full optimization. */
+    /*  Note that gcvOPTIMIZATION_LOAD_SW_WORKAROUND is off. */
+	gcvOPTIMIZATION_FULL                        = 0x7FFFFFFF &
+                                                  ~gcvOPTIMIZATION_LOAD_SW_WORKAROUND &
+                                                  ~gcvOPTIMIZATION_POWER_OPTIMIZATION,
+
+	/* Optimization Unit Test flag. */
+    gcvOPTIMIZATION_UNIT_TEST                   = 1 << 31
+}
+gceSHADER_OPTIMIZATION;
+
+typedef enum _gceOPTIMIZATION_VaryingPaking
+{
+    gcvOPTIMIZATION_VARYINGPACKING_NONE = 0,
+    gcvOPTIMIZATION_VARYINGPACKING_NOSPLIT,
+    gcvOPTIMIZATION_VARYINGPACKING_SPLIT
+} gceOPTIMIZATION_VaryingPaking;
+
+typedef struct _gcOPTIMIZER_OPTION
+{
+    gceSHADER_OPTIMIZATION     optFlags;
+
+    /* debug & dump options:
+
+         VC_OPTION=-DUMP:SRC:OPT|:OPTV|:CG|:CGV:|ALL|ALLV
+
+         SRC:  dump shader source code
+         OPT:  dump incoming and final IR
+         OPTV: dump result IR in each optimization phase
+         CG:   dump generated machine code
+         CGV:  dump BE tree and optimization detail
+
+         ALL = SRC|OPT|CG
+         ALLV = SRC|OPT|OPTV|CG|CGV
+     */
+    gctBOOL     dumpShaderSource;      /* dump shader source code */
+    gctBOOL     dumpOptimizer;         /* dump incoming and final IR */
+    gctBOOL     dumpOptimizerVerbose;  /* dump result IR in each optimization phase */
+    gctBOOL     dumpBEGenertedCode;    /* dump generated machine code */
+    gctBOOL     dumpBEVerbose;         /* dump BE tree and optimization detail */
+
+    /* Code generation */
+
+    /* Varying Packing:
+
+          VC_OPTION=-PACKVARYING:[0-2]|:T[-]m[,n]|:LshaderIdx,min,max
+
+          0: turn off varying packing
+          1: pack varyings, donot split any varying
+          2: pack varyings, may split to make fully packed output
+
+          Tm:    only packing shader pair which vertex shader id is m
+          Tm,n:  only packing shader pair which vertex shader id
+                   is in range of [m, n]
+          T-m:   do not packing shader pair which vertex shader id is m
+          T-m,n: do not packing shader pair which vertex shader id
+                   is in range of [m, n]
+
+          LshaderIdx,min,max : set  load balance (min, max) for shaderIdx
+                               if shaderIdx is -1, all shaders are impacted
+                               newMin = origMin * (min/100.);
+                               newMax = origMax * (max/100.);
+     */
+    gceOPTIMIZATION_VaryingPaking    packVarying;
+    gctINT                           _triageStart;
+    gctINT                           _triageEnd;
+    gctINT                           _loadBalanceShaderIdx;
+    gctINT                           _loadBalanceMin;
+    gctINT                           _loadBalanceMax;
+
+    /* Do not generate immdeiate
+
+          VC_OPTION=-NOIMM
+
+       Force generate immediate even the machine model don't support it,
+       for testing purpose only
+
+          VC_OPTION=-FORCEIMM
+     */
+    gctBOOL     noImmediate;
+    gctBOOL     forceImmediate;
+
+    /* Power reduction mode options */
+    gctBOOL   needPowerOptimization;
+
+    /* Patch TEXLD instruction by adding dummy texld
+       (can be used to tune GPU power usage):
+         for every TEXLD we seen, add n dummy TEXLD
+
+        it can be enabled by environment variable:
+
+          VC_OPTION=-PATCH_TEXLD:M:N
+
+        (for each M texld, add N dummy texld)
+     */
+    gctINT      patchEveryTEXLDs;
+    gctINT      patchDummyTEXLDs;
+
+    /* Insert NOP after high power consumption instructions
+
+         VC_OPTION="-INSERTNOP:MUL:MULLO:DP3:DP4:SEENTEXLD"
+     */
+    gctBOOL     insertNOP;
+    gctBOOL     insertNOPAfterMUL;
+    gctBOOL     insertNOPAfterMULLO;
+    gctBOOL     insertNOPAfterDP3;
+    gctBOOL     insertNOPAfterDP4;
+    gctBOOL     insertNOPOnlyWhenTexldSeen;
+
+    /* split MAD to MUL and ADD:
+
+         VC_OPTION=-SPLITMAD
+     */
+    gctBOOL     splitMAD;
+
+    /* Convert vect3/vec4 operations to multiple vec2/vec1 operations
+
+         VC_OPTION=-SPLITVEC:MUL:MULLO:DP3:DP4
+     */
+    gctBOOL     splitVec;
+    gctBOOL     splitVec4MUL;
+    gctBOOL     splitVec4MULLO;
+    gctBOOL     splitVec4DP3;
+    gctBOOL     splitVec4DP4;
+
+    /* turn/off features:
+
+          VC_OPTION=-F:n,[0|1]
+          Note: n must be decimal number
+     */
+    gctUINT     featureBits;
+
+    /* inline level (default 2 at O1):
+
+          VC_OPTION=-INLINELEVEL:[0-3]
+             0:  no inline
+             1:  only inline the function only called once or small function
+             2:  inline functions be called less than 5 times or medium size function
+             3:  inline everything possible
+     */
+    gctUINT     inlineLevel;
+} gcOPTIMIZER_OPTION;
+
+extern gcOPTIMIZER_OPTION theOptimizerOption;
+#define gcmGetOptimizerOption() gcGetOptimizerOption()
+
+#define gcmOPT_DUMP_SHADER_SRC()         \
+             (gcmGetOptimizerOption()->dumpShaderSource != 0)
+#define gcmOPT_DUMP_OPTIMIZER()          \
+             (gcmGetOptimizerOption()->dumpOptimizer != 0 || \
+              gcmOPT_DUMP_OPTIMIZER_VERBOSE() )
+#define gcmOPT_DUMP_OPTIMIZER_VERBOSE()  \
+             (gcmGetOptimizerOption()->dumpOptimizerVerbose != 0)
+#define gcmOPT_DUMP_CODEGEN()            \
+             (gcmGetOptimizerOption()->dumpBEGenertedCode != 0 || \
+              gcmOPT_DUMP_CODEGEN_VERBOSE() )
+#define gcmOPT_DUMP_CODEGEN_VERBOSE()    \
+             (gcmGetOptimizerOption()->dumpBEVerbose != 0)
+
+#define gcmOPT_SET_DUMP_SHADER_SRC(v)   \
+             gcmGetOptimizerOption()->dumpShaderSource = (v)
+
+#define gcmOPT_PATCH_TEXLD()  (gcmGetOptimizerOption()->patchDummyTEXLDs != 0)
+#define gcmOPT_INSERT_NOP()   (gcmGetOptimizerOption()->insertNOP == gcvTRUE)
+#define gcmOPT_SPLITMAD()     (gcmGetOptimizerOption()->splitMAD == gcvTRUE)
+#define gcmOPT_SPLITVEC()     (gcmGetOptimizerOption()->splitVec == gcvTRUE)
+
+#define gcmOPT_NOIMMEDIATE()  (gcmGetOptimizerOption()->noImmediate == gcvTRUE)
+#define gcmOPT_FORCEIMMEDIATE()  (gcmGetOptimizerOption()->forceImmediate == gcvTRUE)
+
+#define gcmOPT_PACKVARYING()     (gcmGetOptimizerOption()->packVarying)
+#define gcmOPT_PACKVARYING_triageStart()   (gcmGetOptimizerOption()->_triageStart)
+#define gcmOPT_PACKVARYING_triageEnd()     (gcmGetOptimizerOption()->_triageEnd)
+
+#define gcmOPT_INLINELEVEL()     (gcmGetOptimizerOption()->inlineLevel)
+
+/* Setters */
+#define gcmOPT_SetPatchTexld(m,n) (gcmGetOptimizerOption()->patchEveryTEXLDs = (m),\
+                                   gcmGetOptimizerOption()->patchDummyTEXLDs = (n))
+#define gcmOPT_SetSplitVecMUL() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4MUL = gcvTRUE)
+#define gcmOPT_SetSplitVecMULLO() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                  gcmGetOptimizerOption()->splitVec4MULLO = gcvTRUE)
+#define gcmOPT_SetSplitVecDP3() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP3 = gcvTRUE)
+#define gcmOPT_SetSplitVecDP4() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP4 = gcvTRUE)
+
+#define gcmOPT_SetPackVarying(v)     (gcmGetOptimizerOption()->packVarying = v)
+
+#define FB_LIVERANGE_FIX1     0x0001
+
+
+#define PredefinedDummySamplerId       8
+
 /* Function argument qualifier */
 typedef enum _gceINPUT_OUTPUT
 {
@@ -522,6 +1000,7 @@ typedef enum _gceUNIFORM_FLAGS
 	gcvUNIFORM_KERNEL_ARG_LOCAL_MEM_SIZE	= 0x1000,
 	gcvUNIFORM_KERNEL_ARG_PRIVATE		= 0x2000,
 	gcvUNIFORM_LOADTIME_CONSTANT		= 0x4000,
+    gcvUNIFORM_IS_ARRAY                 = 0x8000,
 }
 gceUNIFORM_FLAGS;
 
@@ -533,10 +1012,55 @@ gceUNIFORM_FLAGS;
 
 typedef enum _gceVARIABLE_UPDATE_FLAGS
 {
-    gceVARIABLE_UPDATE_NOUPDATE = 0,
-    gceVARIABLE_UPDATE_TEMPREG,
+    gcvVARIABLE_UPDATE_NOUPDATE = 0,
+    gcvVARIABLE_UPDATE_TEMPREG,
+    gcvVARIABLE_UPDATE_TYPE_QUALIFIER,
 }gceVARIABLE_UPDATE_FLAGS;
 
+typedef struct _gcMACHINE_INST
+{
+    gctUINT        state0;
+    gctUINT        state1;
+    gctUINT        state2;
+    gctUINT        state3;
+}gcMACHINE_INST, *gcMACHINE_INST_PTR;
+
+typedef struct _gcMACHINECODE
+{
+    gcMACHINE_INST_PTR   pCode;          /* machine code  */
+    gctUINT              instCount;      /* 128-bit count */
+    gctUINT              maxConstRegNo;
+    gctUINT              maxTempRegNo;
+    gctUINT              endPCOfMainRoutine;
+}gcMACHINECODE, *gcMACHINECODE_PTR;
+
+typedef enum NP2_ADDRESS_MODE
+{
+    NP2_ADDRESS_MODE_CLAMP  = 0,
+    NP2_ADDRESS_MODE_REPEAT = 1,
+    NP2_ADDRESS_MODE_MIRROR = 2
+}NP2_ADDRESS_MODE;
+
+typedef struct _gcNPOT_PATCH_PARAM
+{
+    gctINT               samplerSlot;
+    NP2_ADDRESS_MODE     addressMode[3];
+    gctINT               texDimension;    /* 2 or 3 */
+}gcNPOT_PATCH_PARAM, *gcNPOT_PATCH_PARAM_PTR;
+
+void
+gcGetOptionFromEnv(
+    IN OUT gcOPTIMIZER_OPTION * Option
+    );
+
+void
+gcSetOptimizerOption(
+    IN gceSHADER_FLAGS Flags
+    );
+
+gcOPTIMIZER_OPTION *
+gcGetOptimizerOption();
+
 /*******************************************************************************
 **  gcSHADER_SetCompilerVersion
 **
@@ -597,6 +1121,9 @@ gcSHADER_GetType(
     IN gcSHADER Shader,
     OUT gctINT *Type
     );
+
+gctUINT
+gcSHADER_NextId();
 /*******************************************************************************
 **                             gcSHADER_Construct
 ********************************************************************************
@@ -1053,6 +1580,65 @@ gcSHADER_AddUniformEx(
 	);
 
 /*******************************************************************************
+**							   gcSHADER_AddUniformEx1
+********************************************************************************
+**
+**	Add an uniform to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the uniform to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the uniform to add.
+**
+**      gcSHADER_PRECISION precision
+**          Precision of the uniform to add.
+**
+**		gctSIZE_T Length
+**			Array length of the uniform to add.  'Length' must be at least 1.
+**
+**      gcSHADER_VAR_CATEGORY varCategory
+**          Variable category, normal or struct.
+**
+**      gctUINT16 numStructureElement
+**          If struct, its element number.
+**
+**      gctINT16 parent
+**          If struct, parent index in gcSHADER.variables.
+**
+**      gctINT16 prevSibling
+**          If struct, previous sibling index in gcSHADER.variables.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM * Uniform
+**			Pointer to a variable receiving the gcUNIFORM object pointer.
+**
+**      gctINT16* ThisUniformIndex
+**          Returned value about uniform index in gcSHADER.
+*/
+gceSTATUS
+gcSHADER_AddUniformEx1(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+    IN gcSHADER_PRECISION precision,
+	IN gctSIZE_T Length,
+    IN gctINT    IsArray,
+    IN gcSHADER_VAR_CATEGORY varCategory,
+    IN gctUINT16 numStructureElement,
+    IN gctINT16 parent,
+    IN gctINT16 prevSibling,
+    OUT gctINT16* ThisUniformIndex,
+	OUT gcUNIFORM * Uniform
+	);
+
+/*******************************************************************************
 **                          gcSHADER_GetUniformCount
 ********************************************************************************
 **
@@ -1100,6 +1686,45 @@ gcSHADER_GetUniform(
 	OUT gcUNIFORM * Uniform
 	);
 
+
+/*******************************************************************************
+**                             gcSHADER_GetUniformIndexingRange
+********************************************************************************
+**
+**	Get the gcUNIFORM object pointer for an indexed uniform for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctINT uniformIndex
+**			Index of the start uniform.
+**
+**		gctINT offset
+**			Offset to indexing.
+**
+**	OUTPUT:
+**
+**		gctINT * LastUniformIndex
+**			Pointer to index of last uniform in indexing range.
+**
+**		gctINT * OffsetUniformIndex
+**			Pointer to index of uniform that indexing at offset.
+**
+**		gctINT * DeviationInOffsetUniform
+**			Pointer to offset in uniform picked up.
+*/
+gceSTATUS
+gcSHADER_GetUniformIndexingRange(
+	IN gcSHADER Shader,
+	IN gctINT uniformIndex,
+    IN gctINT offset,
+	OUT gctINT * LastUniformIndex,
+    OUT gctINT * OffsetUniformIndex,
+    OUT gctINT * DeviationInOffsetUniform
+	);
+
 /*******************************************************************************
 **  gcSHADER_GetKernelFucntion
 **
@@ -1382,15 +2007,13 @@ gcSHADER_AddVariable(
 **      gctINT16 parent
 **          If struct, parent index in gcSHADER.variables.
 **
-**      gctINT16 preSibling
+**      gctINT16 prevSibling
 **          If struct, previous sibling index in gcSHADER.variables.
 **
-**      gctINT16* ThisVarIndex
-**          Returned value about variable index in gcSHADER.
-**
 **  OUTPUT:
 **
-**      Nothing.
+**      gctINT16* ThisVarIndex
+**          Returned value about variable index in gcSHADER.
 */
 gceSTATUS
 gcSHADER_AddVariableEx(
@@ -1402,7 +2025,7 @@ gcSHADER_AddVariableEx(
     IN gcSHADER_VAR_CATEGORY varCategory,
     IN gctUINT16 numStructureElement,
     IN gctINT16 parent,
-    IN gctINT16 preSibling,
+    IN gctINT16 prevSibling,
     OUT gctINT16* ThisVarIndex
     );
 
@@ -1423,7 +2046,7 @@ gcSHADER_AddVariableEx(
 **		gceVARIABLE_UPDATE_FLAGS flag
 **			Flag which property of variable will be updated.
 **
-**      gctUINT16 newValue
+**      gctUINT newValue
 **          New value to update.
 **
 **  OUTPUT:
@@ -1435,7 +2058,7 @@ gcSHADER_UpdateVariable(
     IN gcSHADER Shader,
     IN gctUINT Index,
     IN gceVARIABLE_UPDATE_FLAGS flag,
-    IN gctUINT16 newValue
+    IN gctUINT newValue
     );
 
 /*******************************************************************************
@@ -1487,6 +2110,40 @@ gcSHADER_GetVariable(
 	);
 
 /*******************************************************************************
+**							   gcSHADER_GetVariableIndexingRange
+********************************************************************************
+**
+**	Get the gcVARIABLE indexing range.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcVARIABLE variable
+**			Start variable.
+**
+**		gctBOOL whole
+**			Indicate whether maximum indexing range is queried
+**
+**	OUTPUT:
+**
+**		gctUINT *Start
+**			Pointer to range start (temp register index).
+**
+**		gctUINT *End
+**			Pointer to range end (temp register index).
+*/
+gceSTATUS
+gcSHADER_GetVariableIndexingRange(
+	IN gcSHADER Shader,
+    IN gcVARIABLE variable,
+    IN gctBOOL whole,
+    OUT gctUINT *Start,
+    OUT gctUINT *End
+	);
+
+/*******************************************************************************
 **							   gcSHADER_AddOpcode
 ********************************************************************************
 **
@@ -2372,6 +3029,14 @@ gcSHADER_CheckValidity(
     IN gcSHADER Shader
     );
 
+#if gcdUSE_WCLIP_PATCH
+gceSTATUS
+gcATTRIBUTE_IsPosition(
+        IN gcATTRIBUTE Attribute,
+        OUT gctBOOL * IsPosition
+        );
+#endif
+
 /*******************************************************************************
 **                             gcATTRIBUTE_GetType
 ********************************************************************************
@@ -2757,6 +3422,26 @@ gcUNIFORM_SetValueF(
 	);
 
 /*******************************************************************************
+**						 gcUNIFORM_GetModelViewProjMatrix
+********************************************************************************
+**
+**	Get the value of uniform modelViewProjMatrix ID if present.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gctUINT
+gcUNIFORM_GetModelViewProjMatrix(
+    IN gcUNIFORM Uniform
+    );
+
+/*******************************************************************************
 **								gcOUTPUT_GetType
 ********************************************************************************
 **
@@ -3159,7 +3844,9 @@ gcLinkShaders(
 	IN gceSHADER_FLAGS Flags,
 	OUT gctSIZE_T * StateBufferSize,
 	OUT gctPOINTER * StateBuffer,
-	OUT gcsHINT_PTR * Hints
+	OUT gcsHINT_PTR * Hints,
+    OUT gcMACHINECODE_PTR *ppVsMachineCode,
+    OUT gcMACHINECODE_PTR *ppFsMachineCode
 	);
 
 /*******************************************************************************
@@ -3191,6 +3878,24 @@ gcLoadShaders(
 	IN gcsHINT_PTR Hints
 	);
 
+gceSTATUS
+gcRecompileShaders(
+    IN gcoHAL Hal,
+    IN gcMACHINECODE_PTR pVsMachineCode,
+    IN gcMACHINECODE_PTR pPsMachineCode,
+    /*Recompile variables*/
+    IN OUT gctPOINTER *ppRecompileStateBuffer,
+    IN OUT gctSIZE_T *pRecompileStateBufferSize,
+    IN OUT gcsHINT_PTR *ppRecompileHints,
+    /* natvie state*/
+    IN gctPOINTER pNativeStateBuffer,
+    IN gctSIZE_T nativeStateBufferSize,
+    IN gcsHINT_PTR pNativeHints,
+    /* npt info */
+    IN gctUINT32 Samplers,
+    IN gctUINT32 *SamplerWrapS,
+    IN gctUINT32 *SamplerWrapT
+    );
 /*******************************************************************************
 **                                gcSaveProgram
 ********************************************************************************
@@ -3392,6 +4097,31 @@ gcInvokeThreadWalker(
     IN gcsTHREAD_WALKER_INFO_PTR Info
     );
 
+void
+gcTYPE_GetTypeInfo(
+    IN gcSHADER_TYPE      Type,
+    OUT gctINT *          Components,
+    OUT gctINT *          Rows,
+    OUT gctCONST_STRING * Name
+    );
+
+gctBOOL
+gcOPT_doVaryingPackingForShader(
+	IN gcSHADER Shader
+    );
+
+gceSTATUS
+gcSHADER_PatchNPOTForMachineCode(
+    IN     gcSHADER_KIND          shaderType,
+    IN     gcMACHINECODE_PTR      pMachineCode,
+    IN     gcNPOT_PATCH_PARAM_PTR pPatchParam,
+    IN     gctUINT                countOfPatchParam,
+    IN     gctUINT                hwSupportedInstCount,
+    OUT    gctPOINTER*            ppCmdBuffer,
+    OUT    gctUINT32*             pByteSizeOfCmdBuffer,
+    IN OUT gcsHINT_PTR            pHints /* User needs copy original hints to this one, then passed this one in */
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 7c9d163..028bbd1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_driver_h_
 #define __gc_hal_driver_h_
 
@@ -95,6 +93,9 @@ typedef enum _gceHAL_COMMAND_CODES
 
     gcvHAL_READ_ALL_PROFILE_REGISTERS,
     gcvHAL_PROFILE_REGISTERS_2D,
+#if VIVANTE_PROFILER_PERDRAW
+    gcvHAL_READ_PROFILER_REGISTER_SETTING,
+#endif
 
     /* Power management. */
     gcvHAL_SET_POWER_MANAGEMENT_STATE,
@@ -153,7 +154,18 @@ typedef enum _gceHAL_COMMAND_CODES
 
     /* GPU and event dump */
     gcvHAL_DUMP_GPU_STATE,
-    gcvHAL_DUMP_EVENT
+    gcvHAL_DUMP_EVENT,
+
+    /* Virtual command buffer. */
+    gcvHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER,
+    gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER,
+
+    /* FSCALE_VAL. */
+    gcvHAL_SET_FSCALE_VALUE,
+    gcvHAL_GET_FSCALE_VALUE,
+
+    /* Reset time stamp. */
+    gcvHAL_QUERY_RESET_TIME_STAMP,
 }
 gceHAL_COMMAND_CODES;
 
@@ -220,14 +232,19 @@ typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
     gctUINT32                   pixelPipes;
 
     /* Number of instructions. */
-	gctUINT32                   instructionCount;
+    gctUINT32                   instructionCount;
 
     /* Number of constants. */
-	gctUINT32                   numConstants;
+    gctUINT32                   numConstants;
+
+    /* Buffer size */
+    gctUINT32                   bufferSize;
 
-	/* Buffer size */
-	gctUINT32                   bufferSize;
+    /* Number of varyings */
+    gctUINT32                   varyingsCount;
 
+    /* Supertile layout style in hardware */
+    gctUINT32                   superTileMode;
 }
 gcsHAL_QUERY_CHIP_IDENTITY;
 
@@ -236,19 +253,19 @@ typedef struct _gcsHAL_COMPOSE * gcsHAL_COMPOSE_PTR;
 typedef struct _gcsHAL_COMPOSE
 {
     /* Composition state buffer. */
-    gctPHYS_ADDR                physical;
-    gctPOINTER                  logical;
-    gctSIZE_T                   offset;
-    gctSIZE_T                   size;
+    gctUINT64                   physical;
+    gctUINT64                   logical;
+    gctUINT                     offset;
+    gctUINT                     size;
 
     /* Composition end signal. */
-    gctHANDLE                   process;
-    gctSIGNAL                   signal;
+    gctUINT64                   process;
+    gctUINT64                   signal;
 
     /* User signals. */
-    gctHANDLE                   userProcess;
-    gctSIGNAL                   userSignal1;
-    gctSIGNAL                   userSignal2;
+    gctUINT64                   userProcess;
+    gctUINT64                   userSignal1;
+    gctUINT64                   userSignal2;
 
 #if defined(__QNXNTO__)
     /* Client pulse side-channel connection ID. */
@@ -260,6 +277,7 @@ typedef struct _gcsHAL_COMPOSE
 }
 gcsHAL_COMPOSE;
 
+
 typedef struct _gcsHAL_INTERFACE
 {
     /* Command code. */
@@ -272,7 +290,7 @@ typedef struct _gcsHAL_INTERFACE
     gceSTATUS                   status;
 
     /* Handle to this interface channel. */
-    gctHANDLE                   handle;
+    gctUINT64                   handle;
 
     /* Pid of the client. */
     gctUINT32                   pid;
@@ -291,23 +309,23 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_QUERY_VIDEO_MEMORY */
         struct _gcsHAL_QUERY_VIDEO_MEMORY
         {
-            /* Physical memory address of internal memory. */
-            OUT gctPHYS_ADDR            internalPhysical;
+            /* Physical memory address of internal memory. Just a name. */
+            OUT gctUINT32               internalPhysical;
 
-            /* Size in bytes of internal memory.*/
-            OUT gctSIZE_T               internalSize;
+            /* Size in bytes of internal memory. */
+            OUT gctUINT64               internalSize;
 
-            /* Physical memory address of external memory. */
-            OUT gctPHYS_ADDR            externalPhysical;
+            /* Physical memory address of external memory. Just a name. */
+            OUT gctUINT32               externalPhysical;
 
             /* Size in bytes of external memory.*/
-            OUT gctSIZE_T               externalSize;
+            OUT gctUINT64               externalSize;
 
-            /* Physical memory address of contiguous memory. */
-            OUT gctPHYS_ADDR            contiguousPhysical;
+            /* Physical memory address of contiguous memory. Just a name. */
+            OUT gctUINT32               contiguousPhysical;
 
             /* Size in bytes of contiguous memory.*/
-            OUT gctSIZE_T               contiguousSize;
+            OUT gctUINT64               contiguousSize;
         }
         QueryVideoMemory;
 
@@ -317,28 +335,28 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_MAP_MEMORY */
         struct _gcsHAL_MAP_MEMORY
         {
-            /* Physical memory address to map. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to map. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to map. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         MapMemory;
 
         /* gcvHAL_UNMAP_MEMORY */
         struct _gcsHAL_UNMAP_MEMORY
         {
-            /* Physical memory address to unmap. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to unmap. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to unmap. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory to unmap. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         UnmapMemory;
 
@@ -357,8 +375,8 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateLinearVideoMemory;
 
@@ -383,24 +401,24 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateVideoMemory;
 
         /* gcvHAL_FREE_VIDEO_MEMORY */
         struct _gcsHAL_FREE_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64        node;
 
 #ifdef __QNXNTO__
 /* TODO: This is part of the unlock - why is it here? */
             /* Mapped logical address to unmap in user space. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64       memory;
 
             /* Number of bytes to allocated. */
-            OUT gctSIZE_T               bytes;
+            OUT gctUINT64       bytes;
 #endif
         }
         FreeVideoMemory;
@@ -408,33 +426,33 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_LOCK_VIDEO_MEMORY */
         struct _gcsHAL_LOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory gcuVIDMEM_NODE gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Cache configuration. */
             /* Only gcvPOOL_CONTIGUOUS and gcvPOOL_VIRUTAL
             ** can be configured */
-            IN gctBOOL                  cacheable;
+            IN gctBOOL              cacheable;
 
             /* Hardware specific address. */
-            OUT gctUINT32               address;
+            OUT gctUINT32           address;
 
             /* Mapped logical address. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64           memory;
         }
         LockVideoMemory;
 
         /* gcvHAL_UNLOCK_VIDEO_MEMORY */
         struct _gcsHAL_UNLOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Type of surface. */
-            IN gceSURF_TYPE             type;
+            IN gceSURF_TYPE         type;
 
             /* Flag to unlock surface asynchroneously. */
-            IN OUT gctBOOL              asynchroneous;
+            IN OUT gctBOOL          asynchroneous;
         }
         UnlockVideoMemory;
 
@@ -442,13 +460,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_NON_PAGED_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64        bytes;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64           logical;
         }
         AllocateNonPagedMemory;
 
@@ -456,38 +474,66 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_NON_PAGED_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64            bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64            logical;
         }
         FreeNonPagedMemory;
 
+        /* gcvHAL_ALLOCATE_NON_PAGED_MEMORY */
+        struct _gcsHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER
+        {
+            /* Number of bytes to allocate. */
+            IN OUT gctUINT64        bytes;
+
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
+
+            /* Logical address of allocation. */
+            OUT gctUINT64           logical;
+        }
+        AllocateVirtualCommandBuffer;
+
+        /* gcvHAL_FREE_NON_PAGED_MEMORY */
+        struct _gcsHAL_FREE_VIRTUAL_COMMAND_BUFFER
+        {
+            /* Number of bytes allocated. */
+            IN gctUINT64            bytes;
+
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
+
+            /* Logical address of allocation. */
+            IN gctUINT64            logical;
+        }
+        FreeVirtualCommandBuffer;
+
         /* gcvHAL_EVENT_COMMIT. */
         struct _gcsHAL_EVENT_COMMIT
         {
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64             queue;
         }
         Event;
 
         /* gcvHAL_COMMIT */
         struct _gcsHAL_COMMIT
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. */
+            IN gctUINT64            context;
 
-            /* Command buffer. */
-            IN gcoCMDBUF                commandBuffer;
+            /* Command buffer gcoCMDBUF. */
+            IN gctUINT64            commandBuffer;
 
-            /* State delta buffer. */
-            gcsSTATE_DELTA_PTR          delta;
+            /* State delta buffer in gcsSTATE_DELTA. */
+            gctUINT64               delta;
 
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64            queue;
         }
         Commit;
 
@@ -495,13 +541,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_MAP_USER_MEMORY
         {
             /* Base address of user memory to map. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
+
+            /* Physical address of user memory to map. */
+            IN gctUINT32                physical;
 
             /* Size of user memory in bytes to map. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. */
-            OUT gctPOINTER              info;
+            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. Just a name. */
+            OUT gctUINT32               info;
 
             /* Physical address of mapped memory. */
             OUT gctUINT32               address;
@@ -512,13 +561,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_UNMAP_USER_MEMORY
         {
             /* Base address of user memory to unmap. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
 
             /* Size of user memory in bytes to unmap. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record returned by gcvHAL_MAP_USER_MEMORY. */
-            IN gctPOINTER               info;
+            /* Info record returned by gcvHAL_MAP_USER_MEMORY. Just a name. */
+            IN gctUINT32                info;
 
             /* Physical address of mapped memory as returned by
                gcvHAL_MAP_USER_MEMORY. */
@@ -550,14 +599,14 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_SIGNAL. */
         struct _gcsHAL_SIGNAL
         {
-            /* Signal handle to signal. */
-            IN gctSIGNAL                signal;
+            /* Signal handle to signal gctSIGNAL. */
+            IN gctUINT64                signal;
 
-            /* Reserved. */
-            IN gctSIGNAL                auxSignal;
+            /* Reserved gctSIGNAL. */
+            IN gctUINT64                auxSignal;
 
-            /* Process owning the signal. */
-            IN gctHANDLE                process;
+            /* Process owning the signal gctHANDLE. */
+            IN gctUINT64                process;
 
 #if defined(__QNXNTO__)
             /* Client pulse side-channel connection ID. Set by client in gcoOS_CreateSignal. */
@@ -586,16 +635,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64            bytes;
 
             /* Hardware address of allocation. */
             OUT gctUINT32               address;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32               physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         AllocateContiguousMemory;
 
@@ -603,13 +652,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32                physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         FreeContiguousMemory;
 
@@ -658,6 +707,16 @@ typedef struct _gcsHAL_INTERFACE
         }
         SetProfileSetting;
 
+#if VIVANTE_PROFILER_PERDRAW
+        /* gcvHAL_READ_PROFILER_REGISTER_SETTING */
+        struct _gcsHAL_READ_PROFILER_REGISTER_SETTING
+         {
+            /*Should Clear Register*/
+            IN gctBOOL               bclear;
+         }
+        SetProfilerRegisterClear;
+#endif
+
         /* gcvHAL_READ_ALL_PROFILE_REGISTERS */
         struct _gcsHAL_READ_ALL_PROFILE_REGISTERS
         {
@@ -669,8 +728,8 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_PROFILE_REGISTERS_2D */
         struct _gcsHAL_PROFILE_REGISTERS_2D
         {
-            /* Data read. */
-            OUT gcs2D_PROFILE_PTR       hwProfile2D;
+            /* Data read in gcs2D_PROFILE. */
+            OUT gctUINT64       hwProfile2D;
         }
         RegisterProfileData2D;
 #endif
@@ -709,7 +768,7 @@ typedef struct _gcsHAL_INTERFACE
             IN gctBOOL                  map;
 
             /* Physical address. */
-            IN OUT gctPHYS_ADDR         physical;
+            IN OUT gctUINT64            physical;
         }
         MapPhysical;
 
@@ -734,10 +793,12 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_CACHE
         {
             IN gceCACHEOPERATION        operation;
-            IN gctHANDLE                process;
-            IN gctPOINTER               logical;
-            IN gctSIZE_T                bytes;
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* gctHANDLE */
+            IN gctUINT64                process;
+            IN gctUINT64                logical;
+            IN gctUINT64                bytes;
+            /* gcuVIDMEM_NODE_PTR */
+            IN gctUINT64                node;
         }
         Cache;
 
@@ -804,29 +865,30 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_ATTACH */
         struct _gcsHAL_ATTACH
         {
-            /* Context buffer object. */
-            OUT gckCONTEXT              context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            OUT gctUINT32               context;
 
             /* Number of states in the buffer. */
-            OUT gctSIZE_T               stateCount;
+            OUT gctUINT64               stateCount;
         }
         Attach;
 
         /* gcvHAL_DETACH */
         struct _gcsHAL_DETACH
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            IN gctUINT32                context;
         }
         Detach;
 
         /* gcvHAL_COMPOSE. */
-        gcsHAL_COMPOSE                  Compose;
+        gcsHAL_COMPOSE            Compose;
 
         /* gcvHAL_GET_FRAME_INFO. */
         struct _gcsHAL_GET_FRAME_INFO
         {
-            OUT gcsHAL_FRAME_INFO *     frameInfo;
+            /* gcsHAL_FRAME_INFO* */
+            OUT gctUINT64     frameInfo;
         }
         GetFrameInfo;
 
@@ -841,17 +903,17 @@ typedef struct _gcsHAL_INTERFACE
 		/* gcvHAL_COMMIT */
 		struct _gcsHAL_VGCOMMIT
 		{
-			/* Context buffer. */
-			IN gcsVGCONTEXT_PTR			context;
+			/* Context buffer in gcsVGCONTEXT. */
+			IN gctUINT64			context;
 
-			/* Command queue. */
-			IN gcsVGCMDQUEUE_PTR			queue;
+			/* Command queue in gcsVGCMDQUEUE. */
+			IN gctUINT64			queue;
 
 			/* Number of entries in the queue. */
-			IN gctUINT					entryCount;
+			IN gctUINT			entryCount;
 
-			/* Task table. */
-			IN gcsTASK_MASTER_TABLE_PTR	taskTable;
+			/* Task table in gcsTASK_MASTER_TABLE. */
+			IN gctUINT64	                taskTable;
 		}
 		VGCommit;
 
@@ -869,11 +931,13 @@ typedef struct _gcsHAL_INTERFACE
         {
             IN gctUINT32            pid;
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            OUT gctUINT8_PTR        data;
-            /* fix size */
-            OUT gctUINT8_PTR        nodeData;
-            gctSIZE_T               size;
+            /* gcuVIDMEM_NODE_PTR */
+            IN gctUINT64            node;
+            /* gctUINT8_PTR */
+            OUT gctUINT64           data;
+            /* fix size. gctUINT8_PTR*/
+            OUT gctUINT64           nodeData;
+            gctUINT64               size;
             IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
         }
         GetSharedInfo;
@@ -881,13 +945,36 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_SET_SHARED_INFO
         {
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            IN gctUINT8_PTR         data;
-            IN gctUINT8_PTR         nodeData;
-            IN gctSIZE_T            size;
+            /* gcuVIDMEM_NODE_PTR */
+            IN gctUINT64   node;
+            /* gctUINT8_PTR */
+            IN gctUINT64         data;
+            /* gctUINT8_PTR */
+            IN gctUINT64         nodeData;
+            IN gctUINT64            size;
             IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
         }
         SetSharedInfo;
+
+        struct _gcsHAL_SET_FSCALE_VALUE
+        {
+            IN gctUINT              value;
+        }
+        SetFscaleValue;
+
+        struct _gcsHAL_GET_FSCALE_VALUE
+        {
+            OUT gctUINT             value;
+            OUT gctUINT             minValue;
+            OUT gctUINT             maxValue;
+        }
+        GetFscaleValue;
+
+        struct _gcsHAL_QUERY_RESET_TIME_STAMP
+        {
+            OUT gctUINT64           timeStamp;
+        }
+        QueryResetTimeStamp;
     }
     u;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
index fe57968..b54752f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,10 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
-
 #ifndef __gc_hal_driver_vg_h_
 #define __gc_hal_driver_vg_h_
 
@@ -109,8 +105,7 @@ typedef enum _gceTASK
     gcvTASK_UNLOCK_VIDEO_MEMORY,
     gcvTASK_FREE_VIDEO_MEMORY,
     gcvTASK_FREE_CONTIGUOUS_MEMORY,
-    gcvTASK_UNMAP_USER_MEMORY,
-    gcvTASK_UNMAP_MEMORY
+    gcvTASK_UNMAP_USER_MEMORY
 }
 gceTASK;
 
@@ -215,7 +210,7 @@ typedef struct _gcsTASK_UNLOCK_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_UNLOCK_VIDEO_MEMORY;
 
@@ -226,7 +221,7 @@ typedef struct _gcsTASK_FREE_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_FREE_VIDEO_MEMORY;
 
@@ -268,23 +263,6 @@ typedef struct _gcsTASK_UNMAP_USER_MEMORY
 }
 gcsTASK_UNMAP_USER_MEMORY;
 
-typedef struct _gcsTASK_UNMAP_MEMORY * gcsTASK_UNMAP_MEMORY_PTR;
-typedef struct _gcsTASK_UNMAP_MEMORY
-{
-    /* Task ID (gcvTASK_UNMAP_MEMORY). */
-    IN gceTASK                  id;
-
-    /* Physical memory address to unmap. */
-    IN gctPHYS_ADDR             physical;
-
-    /* Number of bytes in physical memory to unmap. */
-    IN gctSIZE_T                bytes;
-
-    /* Address of mapped memory to unmap. */
-    IN gctPOINTER               logical;
-}
-gcsTASK_UNMAP_MEMORY;
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
index 9b2db22..ffd45e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_dump_h_
 #define __gc_hal_dump_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
index 08442ae..496276e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,224 +19,17 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_eglplatform_h_
 #define __gc_hal_eglplatform_h_
 
 /* Include VDK types. */
 #include "gc_hal_types.h"
 #include "gc_hal_base.h"
+#include "gc_hal_eglplatform_type.h"
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-/*******************************************************************************
-** Events. *********************************************************************
-*/
-
-typedef enum _halEventType
-{
-	/* Keyboard event. */
-    HAL_KEYBOARD,
-
-	/* Mouse move event. */
-    HAL_POINTER,
-
-	/* Mouse button event. */
-    HAL_BUTTON,
-
-	/* Application close event. */
-	HAL_CLOSE,
-
-	/* Application window has been updated. */
-	HAL_WINDOW_UPDATE
-}
-halEventType;
-
-/* Scancodes for keyboard. */
-typedef enum _halKeys
-{
-    HAL_UNKNOWN = -1,
-
-    HAL_BACKSPACE = 0x08,
-    HAL_TAB,
-    HAL_ENTER = 0x0D,
-    HAL_ESCAPE = 0x1B,
-
-    HAL_SPACE = 0x20,
-    HAL_SINGLEQUOTE = 0x27,
-    HAL_PAD_ASTERISK = 0x2A,
-    HAL_COMMA = 0x2C,
-    HAL_HYPHEN,
-    HAL_PERIOD,
-    HAL_SLASH,
-    HAL_0,
-    HAL_1,
-    HAL_2,
-    HAL_3,
-    HAL_4,
-    HAL_5,
-    HAL_6,
-    HAL_7,
-    HAL_8,
-    HAL_9,
-    HAL_SEMICOLON = 0x3B,
-    HAL_EQUAL = 0x3D,
-    HAL_A = 0x41,
-    HAL_B,
-    HAL_C,
-    HAL_D,
-    HAL_E,
-    HAL_F,
-    HAL_G,
-    HAL_H,
-    HAL_I,
-    HAL_J,
-    HAL_K,
-    HAL_L,
-    HAL_M,
-    HAL_N,
-    HAL_O,
-    HAL_P,
-    HAL_Q,
-    HAL_R,
-    HAL_S,
-    HAL_T,
-    HAL_U,
-    HAL_V,
-    HAL_W,
-    HAL_X,
-    HAL_Y,
-    HAL_Z,
-    HAL_LBRACKET,
-    HAL_BACKSLASH,
-    HAL_RBRACKET,
-    HAL_BACKQUOTE = 0x60,
-
-    HAL_F1 = 0x80,
-    HAL_F2,
-    HAL_F3,
-    HAL_F4,
-    HAL_F5,
-    HAL_F6,
-    HAL_F7,
-    HAL_F8,
-    HAL_F9,
-    HAL_F10,
-    HAL_F11,
-    HAL_F12,
-
-    HAL_LCTRL,
-    HAL_RCTRL,
-    HAL_LSHIFT,
-    HAL_RSHIFT,
-    HAL_LALT,
-    HAL_RALT,
-    HAL_CAPSLOCK,
-    HAL_NUMLOCK,
-    HAL_SCROLLLOCK,
-    HAL_PAD_0,
-    HAL_PAD_1,
-    HAL_PAD_2,
-    HAL_PAD_3,
-    HAL_PAD_4,
-    HAL_PAD_5,
-    HAL_PAD_6,
-    HAL_PAD_7,
-    HAL_PAD_8,
-    HAL_PAD_9,
-    HAL_PAD_HYPHEN,
-    HAL_PAD_PLUS,
-    HAL_PAD_SLASH,
-    HAL_PAD_PERIOD,
-    HAL_PAD_ENTER,
-    HAL_SYSRQ,
-    HAL_PRNTSCRN,
-    HAL_BREAK,
-    HAL_UP,
-    HAL_LEFT,
-    HAL_RIGHT,
-    HAL_DOWN,
-    HAL_HOME,
-    HAL_END,
-    HAL_PGUP,
-    HAL_PGDN,
-    HAL_INSERT,
-    HAL_DELETE,
-    HAL_LWINDOW,
-    HAL_RWINDOW,
-    HAL_MENU,
-    HAL_POWER,
-    HAL_SLEEP,
-    HAL_WAKE
-}
-halKeys;
-
-/* Structure that defined keyboard mapping. */
-typedef struct _halKeyMap
-{
-	/* Normal key. */
-    halKeys normal;
-
-	/* Extended key. */
-    halKeys extended;
-}
-halKeyMap;
-
-/* Event structure. */
-typedef struct _halEvent
-{
-	/* Event type. */
-    halEventType type;
-
-	/* Event data union. */
-    union _halEventData
-    {
-		/* Event data for keyboard. */
-        struct _halKeyboard
-        {
-			/* Scancode. */
-            halKeys	scancode;
-
-			/* ASCII characte of the key pressed. */
-            gctCHAR	key;
-
-			/* Flag whether the key was pressed (1) or released (0). */
-            gctCHAR	pressed;
-        }
-        keyboard;
-
-		/* Event data for pointer. */
-        struct _halPointer
-        {
-			/* Current pointer coordinate. */
-            gctINT		x;
-            gctINT		y;
-        }
-        pointer;
-
-		/* Event data for mouse buttons. */
-        struct _halButton
-        {
-			/* Left button state. */
-            gctINT		left;
-
-			/* Middle button state. */
-            gctINT		middle;
-
-			/* Right button state. */
-            gctINT		right;
-
-			/* Current pointer coordinate. */
-			gctINT		x;
-			gctINT		y;
-        }
-        button;
-    }
-    data;
-}
-halEvent;
 
 #if defined(_WIN32) || defined(__VC32__) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
 /* Win32 and Windows CE platforms. */
@@ -250,12 +43,77 @@ typedef struct __BITFIELDINFO{
     RGBQUAD       bmiColors[2];
 } BITFIELDINFO;
 
+#elif defined(LINUX) && defined(EGL_API_DFB) && !defined(__APPLE__)
+#include <directfb.h>
+typedef struct _DFBDisplay * HALNativeDisplayType;
+typedef IDirectFBWindow *  HALNativeWindowType;
+typedef struct _DFBPixmap *  HALNativePixmapType;
+
 #elif defined(LINUX) && defined(EGL_API_FB) && !defined(__APPLE__)
+
+#if defined(EGL_API_WL)
+/* Wayland platform. */
+#include "wayland-server.h"
+#include <wayland-egl.h>
+
+#define WL_EGL_NUM_BACKBUFFERS 2
+
+typedef struct _gcsWL_VIV_BUFFER
+{
+   struct wl_buffer wl_buffer;
+   gcoSURF surface;
+} gcsWL_VIV_BUFFER;
+
+typedef struct _gcsWL_EGL_DISPLAY
+{
+   struct wl_display* wl_display;
+   struct wl_viv* wl_viv;
+} gcsWL_EGL_DISPLAY;
+
+typedef struct _gcsWL_EGL_BUFFER_INFO
+{
+   gctINT32 width;
+   gctINT32 height;
+   gctINT32 stride;
+   gceSURF_FORMAT format;
+   gcuVIDMEM_NODE_PTR node;
+   gcePOOL pool;
+   gctUINT bytes;
+   gcoSURF surface;
+} gcsWL_EGL_BUFFER_INFO;
+
+typedef struct _gcsWL_EGL_BUFFER
+{
+   struct wl_buffer* wl_buffer;
+   gcsWL_EGL_BUFFER_INFO info;
+} gcsWL_EGL_BUFFER;
+
+typedef struct _gcsWL_EGL_WINDOW_INFO
+{
+   gctUINT width;
+   gctUINT height;
+   gceSURF_FORMAT format;
+   gctUINT bpp;
+} gcsWL_EGL_WINDOW_INFO;
+
+struct wl_egl_window
+{
+   gcsWL_EGL_BUFFER backbuffers[WL_EGL_NUM_BACKBUFFERS];
+   gcsWL_EGL_WINDOW_INFO info;
+   gctUINT current;
+   struct wl_surface* surface;
+   struct wl_callback* pending;
+};
+
+typedef void*   HALNativeDisplayType;
+typedef void*   HALNativeWindowType;
+typedef void*   HALNativePixmapType;
+#else
 /* Linux platform for FBDEV. */
 typedef struct _FBDisplay * HALNativeDisplayType;
 typedef struct _FBWindow *  HALNativeWindowType;
 typedef struct _FBPixmap *  HALNativePixmapType;
-
+#endif
 #elif defined(__ANDROID__) || defined(ANDROID)
 
 struct egl_native_pixmap_t;
@@ -302,11 +160,12 @@ typedef Pixmap      HALNativePixmapType;
 #endif
 
 #elif defined(__QNXNTO__)
+#include <screen/screen.h>
 
 /* VOID */
-typedef void *  HALNativeDisplayType;
-typedef void *  HALNativeWindowType;
-typedef void *  HALNativePixmapType;
+typedef int              HALNativeDisplayType;
+typedef screen_window_t  HALNativeWindowType;
+typedef screen_pixmap_t  HALNativePixmapType;
 
 #else
 
@@ -319,7 +178,16 @@ typedef void *  HALNativePixmapType;
 
 #endif
 
-
+/* define DUMMY according to the system */
+#if defined(EGL_API_WL)
+#   define WL_DUMMY (31415926)
+#   define EGL_DUMMY WL_DUMMY
+#elif defined(__ANDROID__) || defined(ANDROID)
+#   define ANDROID_DUMMY (31415926)
+#   define EGL_DUMMY ANDROID_DUMMY
+#else
+#   define EGL_DUMMY (31415926)
+#endif
 
 /*******************************************************************************
 ** Display. ********************************************************************
@@ -327,13 +195,15 @@ typedef void *  HALNativePixmapType;
 
 gceSTATUS
 gcoOS_GetDisplay(
-    OUT HALNativeDisplayType * Display
+    OUT HALNativeDisplayType * Display,
+    IN gctPOINTER Context
     );
 
 gceSTATUS
 gcoOS_GetDisplayByIndex(
     IN gctINT DisplayIndex,
-    OUT HALNativeDisplayType * Display
+    OUT HALNativeDisplayType * Display,
+    IN gctPOINTER Context
     );
 
 gceSTATUS
@@ -346,49 +216,7 @@ gcoOS_GetDisplayInfo(
     OUT gctINT * BitsPerPixel
     );
 
-/* VFK_DISPLAY_INFO structure defining information returned by
-   vdkGetDisplayInfoEx. */
-typedef struct _halDISPLAY_INFO
-{
-    /* The size of the display in pixels. */
-    gctINT                         width;
-    gctINT                         height;
-
-    /* The stride of the dispay. -1 is returned if the stride is not known
-    ** for the specified display.*/
-    gctINT                         stride;
-
-    /* The color depth of the display in bits per pixel. */
-    gctINT                         bitsPerPixel;
-
-    /* The logical pointer to the display memory buffer. NULL is returned
-    ** if the pointer is not known for the specified display. */
-    gctPOINTER                      logical;
 
-    /* The physical address of the display memory buffer. ~0 is returned
-    ** if the address is not known for the specified display. */
-    gctSIZE_T               physical;
-
-#ifndef __QNXNTO__
-    /* 355_FB_MULTI_BUFFER */
-    gctINT                      multiBuffer;
-    gctINT                      backBufferY;
-#endif
-
-    /* The color info of the display. */
-    gctUINT                alphaLength;
-    gctUINT                alphaOffset;
-    gctUINT                redLength;
-    gctUINT                redOffset;
-    gctUINT                greenLength;
-    gctUINT                greenOffset;
-    gctUINT                blueLength;
-    gctUINT                blueOffset;
-
-    /* Display flip support. */
-    gctINT                         flip;
-}
-halDISPLAY_INFO;
 
 gceSTATUS
 gcoOS_GetDisplayInfoEx(
@@ -434,6 +262,30 @@ gcoOS_SetDisplayVirtual(
     );
 
 gceSTATUS
+gcoOS_SetDisplayVirtualEx(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctPOINTER Context,
+    IN gcoSURF Surface,
+    IN gctUINT Offset,
+    IN gctINT X,
+    IN gctINT Y
+    );
+
+gceSTATUS
+gcoOS_SetSwapInterval(
+	IN HALNativeDisplayType Display,
+	IN gctINT Interval
+);
+
+gceSTATUS
+gcoOS_GetSwapInterval(
+	IN HALNativeDisplayType Display,
+	IN gctINT_PTR Min,
+	IN gctINT_PTR Max
+);
+
+gceSTATUS
 gcoOS_DisplayBufferRegions(
     IN HALNativeDisplayType Display,
     IN HALNativeWindowType Window,
@@ -448,11 +300,13 @@ gcoOS_DestroyDisplay(
 
 gceSTATUS
 gcoOS_InitLocalDisplayInfo(
+    IN HALNativeDisplayType Display,
     IN OUT gctPOINTER * localDisplay
     );
 
 gceSTATUS
 gcoOS_DeinitLocalDisplayInfo(
+    IN HALNativeDisplayType Display,
     IN OUT gctPOINTER * localDisplay
     );
 
@@ -488,6 +342,10 @@ gcoOS_GetNativeVisualId(
     OUT gctINT* nativeVisualId
     );
 
+gctBOOL
+gcoOS_SynchronousFlip(
+    IN HALNativeDisplayType Display
+    );
 
 /*******************************************************************************
 ** Windows. ********************************************************************
@@ -512,9 +370,6 @@ gcoOS_GetWindowInfo(
     OUT gctINT * Width,
     OUT gctINT * Height,
     OUT gctINT * BitsPerPixel,
-#ifdef __QNXNTO__
-    OUT gctINT * Format,
-#endif
     OUT gctUINT * Offset
     );
 
@@ -712,7 +567,48 @@ gcoOS_DestroyClientBuffer(
     IN gctPOINTER ClientBuffer
     );
 
+gceSTATUS
+gcoOS_DestroyContext(
+    IN gctPOINTER Display,
+    IN gctPOINTER Context
+    );
+
+gceSTATUS
+gcoOS_CreateContext(
+    IN gctPOINTER LocalDisplay,
+    IN gctPOINTER Context
+    );
 
+gceSTATUS
+gcoOS_MakeCurrent(
+    IN gctPOINTER LocalDisplay,
+    IN HALNativeWindowType DrawDrawable,
+    IN HALNativeWindowType ReadDrawable,
+    IN gctPOINTER Context,
+    IN gcoSURF ResolveTarget
+    );
+
+gceSTATUS
+gcoOS_CreateDrawable(
+    IN gctPOINTER LocalDisplay,
+    IN HALNativeWindowType Drawable
+    );
+
+gceSTATUS
+gcoOS_DestroyDrawable(
+    IN gctPOINTER LocalDisplay,
+    IN HALNativeWindowType Drawable
+    );
+gceSTATUS
+gcoOS_SwapBuffers(
+    IN gctPOINTER LocalDisplay,
+    IN HALNativeWindowType Drawable,
+    IN gcoSURF RenderTarget,
+    IN gcoSURF ResolveTarget,
+    IN gctPOINTER ResolveBits,
+    OUT gctUINT *Width,
+    OUT gctUINT *Height
+    );
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
new file mode 100644
index 0000000..4f5c3ce
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
@@ -0,0 +1,286 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifndef __gc_hal_eglplatform_type_h_
+#define __gc_hal_eglplatform_type_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+** Events. *********************************************************************
+*/
+
+typedef enum _halEventType
+{
+	/* Keyboard event. */
+    HAL_KEYBOARD,
+
+	/* Mouse move event. */
+    HAL_POINTER,
+
+	/* Mouse button event. */
+    HAL_BUTTON,
+
+	/* Application close event. */
+	HAL_CLOSE,
+
+	/* Application window has been updated. */
+	HAL_WINDOW_UPDATE
+}
+halEventType;
+
+/* Scancodes for keyboard. */
+typedef enum _halKeys
+{
+    HAL_UNKNOWN = -1,
+
+    HAL_BACKSPACE = 0x08,
+    HAL_TAB,
+    HAL_ENTER = 0x0D,
+    HAL_ESCAPE = 0x1B,
+
+    HAL_SPACE = 0x20,
+    HAL_SINGLEQUOTE = 0x27,
+    HAL_PAD_ASTERISK = 0x2A,
+    HAL_COMMA = 0x2C,
+    HAL_HYPHEN,
+    HAL_PERIOD,
+    HAL_SLASH,
+    HAL_0,
+    HAL_1,
+    HAL_2,
+    HAL_3,
+    HAL_4,
+    HAL_5,
+    HAL_6,
+    HAL_7,
+    HAL_8,
+    HAL_9,
+    HAL_SEMICOLON = 0x3B,
+    HAL_EQUAL = 0x3D,
+    HAL_A = 0x41,
+    HAL_B,
+    HAL_C,
+    HAL_D,
+    HAL_E,
+    HAL_F,
+    HAL_G,
+    HAL_H,
+    HAL_I,
+    HAL_J,
+    HAL_K,
+    HAL_L,
+    HAL_M,
+    HAL_N,
+    HAL_O,
+    HAL_P,
+    HAL_Q,
+    HAL_R,
+    HAL_S,
+    HAL_T,
+    HAL_U,
+    HAL_V,
+    HAL_W,
+    HAL_X,
+    HAL_Y,
+    HAL_Z,
+    HAL_LBRACKET,
+    HAL_BACKSLASH,
+    HAL_RBRACKET,
+    HAL_BACKQUOTE = 0x60,
+
+    HAL_F1 = 0x80,
+    HAL_F2,
+    HAL_F3,
+    HAL_F4,
+    HAL_F5,
+    HAL_F6,
+    HAL_F7,
+    HAL_F8,
+    HAL_F9,
+    HAL_F10,
+    HAL_F11,
+    HAL_F12,
+
+    HAL_LCTRL,
+    HAL_RCTRL,
+    HAL_LSHIFT,
+    HAL_RSHIFT,
+    HAL_LALT,
+    HAL_RALT,
+    HAL_CAPSLOCK,
+    HAL_NUMLOCK,
+    HAL_SCROLLLOCK,
+    HAL_PAD_0,
+    HAL_PAD_1,
+    HAL_PAD_2,
+    HAL_PAD_3,
+    HAL_PAD_4,
+    HAL_PAD_5,
+    HAL_PAD_6,
+    HAL_PAD_7,
+    HAL_PAD_8,
+    HAL_PAD_9,
+    HAL_PAD_HYPHEN,
+    HAL_PAD_PLUS,
+    HAL_PAD_SLASH,
+    HAL_PAD_PERIOD,
+    HAL_PAD_ENTER,
+    HAL_SYSRQ,
+    HAL_PRNTSCRN,
+    HAL_BREAK,
+    HAL_UP,
+    HAL_LEFT,
+    HAL_RIGHT,
+    HAL_DOWN,
+    HAL_HOME,
+    HAL_END,
+    HAL_PGUP,
+    HAL_PGDN,
+    HAL_INSERT,
+    HAL_DELETE,
+    HAL_LWINDOW,
+    HAL_RWINDOW,
+    HAL_MENU,
+    HAL_POWER,
+    HAL_SLEEP,
+    HAL_WAKE
+}
+halKeys;
+
+/* Structure that defined keyboard mapping. */
+typedef struct _halKeyMap
+{
+	/* Normal key. */
+    halKeys normal;
+
+	/* Extended key. */
+    halKeys extended;
+}
+halKeyMap;
+
+/* Event structure. */
+typedef struct _halEvent
+{
+	/* Event type. */
+    halEventType type;
+
+	/* Event data union. */
+    union _halEventData
+    {
+		/* Event data for keyboard. */
+        struct _halKeyboard
+        {
+			/* Scancode. */
+            halKeys	scancode;
+
+			/* ASCII characte of the key pressed. */
+            char	key;
+
+			/* Flag whether the key was pressed (1) or released (0). */
+            char	pressed;
+        }
+        keyboard;
+
+		/* Event data for pointer. */
+        struct _halPointer
+        {
+			/* Current pointer coordinate. */
+            int		x;
+            int		y;
+        }
+        pointer;
+
+		/* Event data for mouse buttons. */
+        struct _halButton
+        {
+			/* Left button state. */
+            int		left;
+
+			/* Middle button state. */
+            int		middle;
+
+			/* Right button state. */
+            int		right;
+
+			/* Current pointer coordinate. */
+			int		x;
+			int		y;
+        }
+        button;
+    }
+    data;
+}
+halEvent;
+
+/* VFK_DISPLAY_INFO structure defining information returned by
+   vdkGetDisplayInfoEx. */
+typedef struct _halDISPLAY_INFO
+{
+    /* The size of the display in pixels. */
+    int                         width;
+    int                         height;
+
+    /* The stride of the dispay. -1 is returned if the stride is not known
+    ** for the specified display.*/
+    int                         stride;
+
+    /* The color depth of the display in bits per pixel. */
+    int                         bitsPerPixel;
+
+    /* The logical pointer to the display memory buffer. NULL is returned
+    ** if the pointer is not known for the specified display. */
+    void *                      logical;
+
+    /* The physical address of the display memory buffer. ~0 is returned
+    ** if the address is not known for the specified display. */
+    unsigned long               physical;
+
+    int                wrapFB;   /* true if compositor, false otherwise. */
+
+#ifndef __QNXNTO__
+    /* 355_FB_MULTI_BUFFER */
+    int                      multiBuffer;
+    int                      backBufferY;
+#endif
+
+    /* The color info of the display. */
+    unsigned int                alphaLength;
+    unsigned int                alphaOffset;
+    unsigned int                redLength;
+    unsigned int                redOffset;
+    unsigned int                greenLength;
+    unsigned int                greenOffset;
+    unsigned int                blueLength;
+    unsigned int                blueOffset;
+
+    /* Display flip support. */
+    int                         flip;
+}
+halDISPLAY_INFO;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_eglplatform_type_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 22cdc2f..d441d1d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_engine_h_
 #define __gc_hal_engine_h_
 
@@ -391,6 +389,37 @@ gcoSURF_IsRenderable(
     IN gcoSURF Surface
     );
 
+#if gcdSYNC
+gceSTATUS
+gcoSURF_GetFence(
+    IN gcoSURF Surface
+    );
+gceSTATUS
+gcoSURF_WaitFence(
+    IN gcoSURF Surface
+    );
+
+gceSTATUS
+gcoSTREAM_GetFence(
+    IN gcoSTREAM stream
+    );
+
+gceSTATUS
+gcoSTREAM_WaitFence(
+    IN gcoSTREAM stream
+    );
+
+gceSTATUS
+gcoINDEX_GetFence(
+    IN gcoINDEX index
+    );
+
+gceSTATUS
+gcoINDEX_WaitFence(
+    IN gcoINDEX index
+    );
+#endif
+
 /******************************************************************************\
 ******************************** gcoINDEX Object *******************************
 \******************************************************************************/
@@ -469,6 +498,22 @@ gcoINDEX_UploadOffset(
     IN gctSIZE_T Bytes
     );
 
+/*Merge index2 to index1 from 0, index2 must subset of inex1*/
+gceSTATUS
+gcoINDEX_Merge(
+    IN gcoINDEX Index1,
+    IN gcoINDEX Index2
+    );
+
+/*check if index buffer is enough for this draw*/
+gctBOOL
+gcoINDEX_CheckRange(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type,
+    IN gctINT Count,
+    IN gctUINT32  Indices
+    );
+
 /* Query the index capabilities. */
 gceSTATUS
 gcoINDEX_QueryCaps(
@@ -835,6 +880,14 @@ gco3D_SetDepthScaleBiasF(
     IN gctFLOAT DepthBias
     );
 
+/* Set depth near and far clipping plane. */
+gceSTATUS
+gco3D_SetDepthPlaneF(
+    IN gco3D Engine,
+    IN gctFLOAT Near,
+    IN gctFLOAT Far
+    );
+
 /* Enable or disable dithering. */
 gceSTATUS
 gco3D_EnableDither(
@@ -863,6 +916,19 @@ gco3D_SetAllEarlyDepthModes(
     IN gctBOOL Disable
     );
 
+/* Switch dynamic early mode */
+gceSTATUS
+gco3D_SwitchDynamicEarlyDepthMode(
+    IN gco3D Engine
+    );
+
+/* Set dynamic early mode */
+gceSTATUS
+gco3D_DisableDynamicEarlyDepthMode(
+    IN gco3D Engine,
+    IN gctBOOL Disable
+    );
+
 /* Enable or disable depth-only mode. */
 gceSTATUS
 gco3D_SetDepthOnly(
@@ -875,8 +941,10 @@ typedef struct _gcsSTENCIL_INFO
 {
     gceSTENCIL_MODE         mode;
 
-    gctUINT8                mask;
-    gctUINT8                writeMask;
+    gctUINT8                maskFront;
+	gctUINT8                maskBack;
+    gctUINT8                writeMaskFront;
+    gctUINT8                writeMaskBack;
 
     gctUINT8                referenceFront;
 
@@ -907,6 +975,13 @@ gco3D_SetStencilMask(
     IN gctUINT8 Mask
     );
 
+/* Set stencil back mask. */
+gceSTATUS
+gco3D_SetStencilMaskBack(
+    IN gco3D Engine,
+    IN gctUINT8 Mask
+    );
+
 /* Set stencil write mask. */
 gceSTATUS
 gco3D_SetStencilWriteMask(
@@ -914,6 +989,13 @@ gco3D_SetStencilWriteMask(
     IN gctUINT8 Mask
     );
 
+/* Set stencil back write mask. */
+gceSTATUS
+gco3D_SetStencilWriteMaskBack(
+    IN gco3D Engine,
+    IN gctUINT8 Mask
+    );
+
 /* Set stencil reference. */
 gceSTATUS
 gco3D_SetStencilReference(
@@ -1165,6 +1247,38 @@ gco3D_InvokeThreadWalker(
     IN gcsTHREAD_WALKER_INFO_PTR Info
     );
 
+/* Set w clip and w plane limit value. */
+gceSTATUS
+gco3D_SetWClipEnable(
+	IN gco3D Engine,
+	IN gctBOOL Enable
+    );
+
+gceSTATUS
+gco3D_GetWClipEnable(
+    IN gco3D Engine,
+    OUT gctBOOL * Enable
+    );
+
+gceSTATUS
+gco3D_SetWPlaneLimitF(
+	IN gco3D Engine,
+	IN gctFLOAT Value
+    );
+
+gceSTATUS
+gco3D_SetWPlaneLimitX(
+	IN gco3D Engine,
+	IN gctFIXED_POINT Value
+    );
+
+
+gceSTATUS
+gco3D_SetWPlaneLimit(
+        IN gco3D Engine,
+        IN gctFLOAT Value
+        );
+
 /*----------------------------------------------------------------------------*/
 /*-------------------------- gco3D Fragment Processor ------------------------*/
 
@@ -1331,7 +1445,7 @@ typedef struct _gcsTEXTURE
     gceTEXTURE_FILTER           magFilter;
     gceTEXTURE_FILTER           mipFilter;
     gctUINT                     anisoFilter;
-
+    gctBOOL                     forceTopLevel;
     /* Level of detail. */
     gctFIXED_POINT              lodBias;
     gctFIXED_POINT              lodMin;
@@ -1366,6 +1480,20 @@ gcoTEXTURE_Destroy(
     IN gcoTEXTURE Texture
     );
 
+/* Replace a mipmap in gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_ReplaceMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctINT imageFormat,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Depth,
+    IN gctUINT Faces,
+    IN gcePOOL Pool
+    );
+
 /* Upload data to an gcoTEXTURE object. */
 gceSTATUS
 gcoTEXTURE_Upload(
@@ -1407,6 +1535,29 @@ gcoTEXTURE_UploadCompressed(
     IN gctSIZE_T Bytes
     );
 
+/* Upload compressed sub data to an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_UploadCompressedSub(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    IN gceTEXTURE_FACE Face,
+    IN gctUINT XOffset,
+    IN gctUINT YOffset,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Slice,
+    IN gctCONST_POINTER Memory,
+    IN gctSIZE_T Size
+    );
+
+/* GetImageFormat of texture. */
+gceSTATUS
+gcoTEXTURE_GetImageFormat(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    OUT gctINT *  ImageFormat
+    );
+
 /* Get gcoSURF object for a mipmap level. */
 gceSTATUS
 gcoTEXTURE_GetMipMap(
@@ -1429,6 +1580,7 @@ gceSTATUS
 gcoTEXTURE_AddMipMap(
     IN gcoTEXTURE Texture,
     IN gctINT Level,
+    IN gctINT imageFormat,
     IN gceSURF_FORMAT Format,
     IN gctUINT Width,
     IN gctUINT Height,
@@ -1453,6 +1605,12 @@ gcoTEXTURE_AddMipMapFromSurface(
     );
 
 gceSTATUS
+gcoTEXTURE_SetMaxLevel(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Levels
+    );
+
+gceSTATUS
 gcoTEXTURE_SetEndianHint(
     IN gcoTEXTURE Texture,
     IN gceENDIAN_HINT EndianHint
@@ -1702,8 +1860,15 @@ typedef struct _gcsVERTEXARRAY
     /* Generic values for attribute. */
     gctFLOAT            genericValue[4];
 
+    /* Generic size for attribute. */
+    gctINT              genericSize;
+
     /* Vertex shader linkage. */
     gctUINT             linkage;
+
+#if gcdUSE_WCLIP_PATCH
+    gctBOOL             isPosition;
+#endif
 }
 gcsVERTEXARRAY,
 * gcsVERTEXARRAY_PTR;
@@ -1730,9 +1895,25 @@ gcoVERTEXARRAY_Bind(
     IN gcoINDEX IndexObject,
     IN gctPOINTER IndexMemory,
     IN OUT gcePRIMITIVE * PrimitiveType,
+#if gcdUSE_WCLIP_PATCH
+    IN OUT gctUINT * PrimitiveCount,
+    IN OUT gctFLOAT * wLimitRms,
+    IN OUT gctBOOL * wLimitDirty
+#else
     IN OUT gctUINT * PrimitiveCount
+#endif
     );
 
+gctUINT
+gcoVERTEXARRAY_GetMaxStream(
+    IN gcoVERTEXARRAY Vertex
+);
+
+gceSTATUS
+gcoVERTEXARRAY_SetMaxStream(
+    IN gcoVERTEXARRAY Vertex,
+    gctUINT maxStreams
+);
 /*******************************************************************************
 ***** Composition *************************************************************/
 
@@ -1824,7 +2005,7 @@ gcoHAL_GetSharedInfo(
     IN gctUINT32 DataId,
     OUT gctUINT8_PTR Data,
     IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     OUT gctUINT8_PTR NodeData,
     IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
     );
@@ -1834,7 +2015,7 @@ gcoHAL_SetSharedInfo(
     IN gctUINT32 DataId,
     IN gctUINT8_PTR Data,
     IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctUINT8_PTR NodeData,
     IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
     );
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 571e03e..4bb6772 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,10 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
-
 #ifndef __gc_hal_engine_vg_h_
 #define __gc_hal_engine_vg_h_
 
@@ -528,14 +524,14 @@ gcoHAL_CombineAddress(
 gceSTATUS
 gcoHAL_ScheduleVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Free linear video memory allocated with gcoHAL_AllocateLinearVideoMemory. */
 gceSTATUS
 gcoHAL_FreeVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Query command buffer attributes. */
@@ -551,7 +547,7 @@ gcoHAL_AllocateLinearVideoMemory(
     IN gctUINT Size,
     IN gctUINT Alignment,
     IN gcePOOL Pool,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gctUINT32 * Address,
     OUT gctPOINTER * Memory
     );
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index 7d67828..cf6b425 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_enum_h_
 #define __gc_hal_enum_h_
 
@@ -140,7 +138,18 @@ typedef enum _gceFEATURE
     gcvFEATURE_RECT_PRIMITIVE,
 	gcvFEATURE_BUG_FIXES11,
 	gcvFEATURE_SUPERTILED_TEXTURE,
-    gcvFEATURE_2D_NO_COLORBRUSH_INDEX8
+    gcvFEATURE_2D_NO_COLORBRUSH_INDEX8,
+    gcvFEATURE_RS_YUV_TARGET,
+    gcvFEATURE_2D_FC_SOURCE,
+	gcvFEATURE_PE_DITHER_FIX,
+    gcvFEATURE_2D_YUV_SEPARATE_STRIDE,
+    gcvFEATURE_FRUSTUM_CLIP_FIX,
+    gcvFEATURE_TEXTURE_LINEAR,
+    gcvFEATURE_TEXTURE_YUV_ASSEMBLER,
+    gcvFEATURE_DYNAMIC_FREQUENCY_SCALING,
+    gcvFEATURE_BUGFIX15,
+    gcvFEATURE_2D_MIRROR_EXTENSION,
+    gcvFEATURE_ELEMENT_INDEX_UINT,
 }
 gceFEATURE;
 
@@ -157,9 +166,7 @@ typedef enum _gceCHIPPOWERSTATE
     gcvPOWER_SUSPEND_BROADCAST,
     gcvPOWER_OFF_BROADCAST,
     gcvPOWER_OFF_RECOVERY,
-#if gcdPOWEROFF_TIMEOUT
     gcvPOWER_OFF_TIMEOUT,
-#endif
     gcvPOWER_ON_AUTO
 }
 gceCHIPPOWERSTATE;
@@ -206,10 +213,14 @@ typedef enum _gceSURF_TYPE
 #if gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
     gcvSURF_FLIP           = 0x800, /* The Resolve Target the will been flip resolve from RT */
 #endif
+    gcvSURF_TILE_STATUS_DIRTY  = 0x1000, /* Init tile status to all dirty */
 
     gcvSURF_RENDER_TARGET_NO_TILE_STATUS = gcvSURF_RENDER_TARGET
                                          | gcvSURF_NO_TILE_STATUS,
 
+    gcvSURF_RENDER_TARGET_TS_DIRTY = gcvSURF_RENDER_TARGET
+                                         | gcvSURF_TILE_STATUS_DIRTY,
+
     gcvSURF_DEPTH_NO_TILE_STATUS         = gcvSURF_DEPTH
                                          | gcvSURF_NO_TILE_STATUS,
 
@@ -262,6 +273,13 @@ typedef enum _gceSURF_ROTATION
 }
 gceSURF_ROTATION;
 
+typedef enum _gceMIPMAP_IMAGE_FORMAT
+{
+    gcvUNKNOWN_MIPMAP_IMAGE_FORMAT  = -2
+}
+gceMIPMAP_IMAGE_FORMAT;
+
+
 /* Surface formats. */
 typedef enum _gceSURF_FORMAT
 {
@@ -333,6 +351,16 @@ typedef enum _gceSURF_FORMAT
     gcvSURF_DXT5,
     gcvSURF_CXV8U8,
     gcvSURF_ETC1,
+    gcvSURF_R11_EAC,
+    gcvSURF_SIGNED_R11_EAC,
+    gcvSURF_RG11_EAC,
+    gcvSURF_SIGNED_RG11_EAC,
+    gcvSURF_RGB8_ETC2,
+    gcvSURF_SRGB8_ETC2,
+    gcvSURF_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_RGBA8_ETC2_EAC,
+    gcvSURF_SRGB8_ALPHA8_ETC2_EAC,
 
     /* YUV formats. */
     gcvSURF_YUY2                = 500,
@@ -463,6 +491,17 @@ typedef enum _gceSURF_ALIGNMENT
 }
 gceSURF_ALIGNMENT;
 
+
+/* Surface Addressing. */
+typedef enum _gceSURF_ADDRESSING
+{
+    gcvSURF_NO_STRIDE_TILED = 0,
+    gcvSURF_NO_STRIDE_LINEAR,
+    gcvSURF_STRIDE_TILED,
+    gcvSURF_STRIDE_LINEAR
+}
+gceSURF_ADDRESSING;
+
 /* Transparency modes. */
 typedef enum _gce2D_TRANSPARENCY
 {
@@ -618,6 +657,30 @@ typedef enum _gce2D_COMMAND
 }
 gce2D_COMMAND;
 
+typedef enum _gce2D_TILE_STATUS_CONFIG
+{
+    gcv2D_TSC_DISABLE       = 0,
+    gcv2D_TSC_ENABLE        = 0x00000001,
+    gcv2D_TSC_COMPRESSED    = 0x00000002,
+    gcv2D_TSC_DOWN_SAMPLER  = 0x00000004,
+}
+gce2D_TILE_STATUS_CONFIG;
+
+typedef enum _gce2D_QUERY
+{
+    gcv2D_QUERY_RGB_ADDRESS_MAX_ALIGN       = 0,
+    gcv2D_QUERY_RGB_STRIDE_MAX_ALIGN,
+    gcv2D_QUERY_YUV_ADDRESS_MAX_ALIGN,
+    gcv2D_QUERY_YUV_STRIDE_MAX_ALIGN,
+}
+gce2D_QUERY;
+
+typedef enum _gce2D_STATE
+{
+    gcv2D_STATE_SPECIAL_FILTER_MIRROR_MODE       = 1,
+}
+gce2D_STATE;
+
 #ifndef VIVANTE_NO_3D
 /* Texture functions. */
 typedef enum _gceTEXTURE_FUNCTION
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
index 24edc0b..0608e43 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_buffer_h_
 #define __gc_hal_kernel_buffer_h_
 
@@ -59,11 +57,6 @@ typedef struct _gcsSTATE_DELTA
     gctUINT                     num;
 #endif
 
-    /* For dumping. */
-#if gcdDUMP
-    gcoOS                       os;
-#endif
-
     /* Main state delta ID. Every time state delta structure gets reinitialized,
        main ID is incremented. If main state ID overflows, all map entry IDs get
        reinitialized to make sure there is no potential erroneous match after
@@ -79,22 +72,22 @@ typedef struct _gcsSTATE_DELTA
     /* Number of states currently stored in the record array. */
     gctUINT                     recordCount;
 
-    /* Record array; holds all modified states. */
-    gcsSTATE_DELTA_RECORD_PTR   recordArray;
+    /* Record array; holds all modified states in gcsSTATE_DELTA_RECORD. */
+    gctUINT64                   recordArray;
 
     /* Map entry ID is used for map entry validation. If map entry ID does not
        match the main state delta ID, the entry and the corresponding state are
        considered not in use. */
-    gctUINT_PTR                 mapEntryID;
+    gctUINT64                   mapEntryID;
     gctUINT                     mapEntryIDSize;
 
     /* If the map entry ID matches the main state delta ID, index points to
        the state record in the record array. */
-    gctUINT_PTR                 mapEntryIndex;
+    gctUINT64                   mapEntryIndex;
 
-    /* Previous and next state deltas. */
-    gcsSTATE_DELTA_PTR          prev;
-    gcsSTATE_DELTA_PTR          next;
+    /* Previous and next state deltas in gcsSTATE_DELTA. */
+    gctUINT64                   prev;
+    gctUINT64                   next;
 }
 gcsSTATE_DELTA;
 
@@ -114,38 +107,38 @@ struct _gcoCMDBUF
     gctBOOL                     usingFilterBlit;
     gctBOOL                     usingPalette;
 
-    /* Physical address of command buffer. */
-    gctPHYS_ADDR                physical;
+    /* Physical address of command buffer. Just a name. */
+    gctUINT32                   physical;
 
     /* Logical address of command buffer. */
-    gctPOINTER                  logical;
+    gctUINT64                   logical;
 
     /* Number of bytes in command buffer. */
-    gctSIZE_T                   bytes;
+    gctUINT                     bytes;
 
     /* Start offset into the command buffer. */
-    gctUINT32                   startOffset;
+    gctUINT                     startOffset;
 
     /* Current offset into the command buffer. */
-    gctUINT32                   offset;
+    gctUINT                     offset;
 
     /* Number of free bytes in command buffer. */
-    gctSIZE_T                   free;
+    gctUINT                     free;
 
     /* Location of the last reserved area. */
-    gctPOINTER                  lastReserve;
+    gctUINT64                   lastReserve;
     gctUINT                     lastOffset;
 
 #if gcdSECURE_USER
     /* Hint array for the current command buffer. */
     gctUINT                     hintArraySize;
-    gctUINT32_PTR               hintArray;
-    gctUINT32_PTR               hintArrayTail;
+    gctUINT64                   hintArray;
+    gctUINT64                   hintArrayTail;
 #endif
 
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
     /* Last load state command location and hardware address. */
-    gctUINT32_PTR               lastLoadStatePtr;
+    gctUINT64                   lastLoadStatePtr;
     gctUINT32                   lastLoadStateAddress;
     gctUINT32                   lastLoadStateCount;
 #endif
@@ -153,8 +146,8 @@ struct _gcoCMDBUF
 
 typedef struct _gcsQUEUE
 {
-    /* Pointer to next gcsQUEUE structure. */
-    gcsQUEUE_PTR                next;
+    /* Pointer to next gcsQUEUE structure in gcsQUEUE. */
+    gctUINT64                   next;
 
     /* Event information. */
     gcsHAL_INTERFACE            iface;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_md5.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_md5.h
deleted file mode 100644
index bc56d95..0000000
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_md5.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/****************************************************************************
-*
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
-*
-*    This program is free software; you can redistribute it and/or modify
-*    it under the terms of the GNU General Public License as published by
-*    the Free Software Foundation; either version 2 of the license, or
-*    (at your option) any later version.
-*
-*    This program is distributed in the hope that it will be useful,
-*    but WITHOUT ANY WARRANTY; without even the implied warranty of
-*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public License for more details.
-*
-*    You should have received a copy of the GNU General Public License
-*    along with this program; if not write to the Free Software
-*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-*****************************************************************************/
-
-
-/*
-  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  L. Peter Deutsch
-  ghost@aladdin.com
-
- */
-/* $Id: gc_hal_md5.h,v 1.1.4.1 2012/02/08 23:31:39 semih.demirer Exp $ */
-/*
-  Independent implementation of MD5 (RFC 1321).
-
-  This code implements the MD5 Algorithm defined in RFC 1321, whose
-  text is available at
-	http://www.ietf.org/rfc/rfc1321.txt
-  The code is derived from the text of the RFC, including the test suite
-  (section A.5) but excluding the rest of Appendix A.  It does not include
-  any code or documentation that is identified in the RFC as being
-  copyrighted.
-
-  The original and principal author of md5.h is L. Peter Deutsch
-  <ghost@aladdin.com>.  Other authors are noted in the change history
-  that follows (in reverse chronological order):
-
-  2002-04-13 lpd Removed support for non-ANSI compilers; removed
-	references to Ghostscript; clarified derivation from RFC 1321;
-	now handles byte order either statically or dynamically.
-  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
-  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
-	added conditionalization for C++ compilation from Martin
-	Purschke <purschke@bnl.gov>.
-  1999-05-03 lpd Original version.
- */
-
-
-#ifndef __gc_hal_md5_h_
-#define __gc_hal_md5_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * This package supports both compile-time and run-time determination of CPU
- * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be
- * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is
- * defined as non-zero, the code will be compiled to run only on big-endian
- * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to
- * run on either big- or little-endian CPUs, but will run slightly less
- * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.
- */
-
-typedef unsigned char gctMD5_Byte; /* 8-bit byte */
-typedef unsigned int gctMD5_Word; /* 32-bit word */
-
-/* Define the state of the MD5 Algorithm. */
-typedef struct _gcsMD5_State {
-    gctMD5_Word count[2];	/* message length in bits, lsw first */
-    gctMD5_Word abcd[4];		/* digest buffer */
-    gctMD5_Byte buf[64];		/* accumulate block */
-} gcsMD5_State;
-
-/* Initialize the algorithm. */
-void gcoMD5_Init(gcsMD5_State *pms);
-
-/* Append a string to the message. */
-void gcoMD5_Append(gcsMD5_State *pms, const gctMD5_Byte *data, int nbytes);
-
-/* Finish the message and return the digest. */
-void gcoMD5_Finish(gcsMD5_State *pms, gctMD5_Byte digest[16]);
-
-#ifdef __cplusplus
-}  /* end extern "C" */
-#endif
-
-#endif /* md5_INCLUDED */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index e64f7e7..9e32878 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file for the local memory management.
 */
@@ -176,7 +174,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
 	gcmERR_RETURN(gcfMEM_FSMemPoolGetANode(MemPool, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -233,7 +231,7 @@ gceSTATUS \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
 	gcmERR_RETURN(gcfMEM_VSMemPoolGetANode(MemPool, Size, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -276,7 +274,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
 	gcmERR_RETURN(gcfMEM_AFSMemPoolGetANode(MemPool, Count, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -323,7 +321,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -370,7 +368,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Size, \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -417,7 +415,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Count * gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index 9d03a66..86e9133 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_options_h_
 #define __gc_hal_options_h_
 
@@ -43,15 +41,6 @@
 #endif
 
 /*
-    NO_USER_DIRECT_ACCESS_FROM_KERNEL
-
-        This define enables the Linux kernel behavior accessing user memory.
-*/
-#ifndef NO_USER_DIRECT_ACCESS_FROM_KERNEL
-#   define NO_USER_DIRECT_ACCESS_FROM_KERNEL    0
-#endif
-
-/*
     VIVANTE_PROFILER
 
         This define enables the profiler.
@@ -60,6 +49,10 @@
 #   define VIVANTE_PROFILER                     0
 #endif
 
+#ifndef VIVANTE_PROFILER_PERDRAW
+#   define  VIVANTE_PROFILER_PERDRAW    0
+#endif
+
 /*
     gcdUSE_VG
 
@@ -152,6 +145,22 @@
 #   define gcdDUMP_FRAMERATE					0
 #endif
 
+/*
+    gcdVIRTUAL_COMMAND_BUFFER
+        When set to 1, user command buffer and context buffer will be allocated
+        from gcvPOOL_VIRTUAL.
+*/
+#ifndef gcdVIRTUAL_COMMAND_BUFFER
+#   define gcdVIRTUAL_COMMAND_BUFFER            0
+#endif
+
+/*
+    gcdENABLE_FSCALE_VAL_ADJUST
+        When non-zero, FSCALE_VAL when gcvPOWER_ON can be adjusted externally.
+ */
+#ifndef gcdENABLE_FSCALE_VAL_ADJUST
+#   define gcdENABLE_FSCALE_VAL_ADJUST          1
+#endif
 
 /*
     gcdDUMP_IN_KERNEL
@@ -192,7 +201,7 @@
     Set to 3 for bypassing the drivers.
 */
 #ifndef gcdNULL_DRIVER
-#   define gcdNULL_DRIVER  0
+#   define gcdNULL_DRIVER                       0
 #endif
 
 /*
@@ -252,13 +261,27 @@
 #endif
 
 /*
+    gcdMIRROR_PAGETABLE
+
+        Enable it when GPUs with old MMU and new MMU exist at same SoC. It makes
+        each GPU use same virtual address to access same physical memory.
+*/
+#ifndef gcdMIRROR_PAGETABLE
+#   define gcdMIRROR_PAGETABLE                  0
+#endif
+
+/*
     gcdMMU_SIZE
 
         Size of the MMU page table in bytes.  Each 4 bytes can hold 4kB worth of
         virtual data.
 */
 #ifndef gcdMMU_SIZE
-#   define gcdMMU_SIZE                          (128 << 10)
+#if gcdMIRROR_PAGETABLE
+#   define gcdMMU_SIZE                          0x200000
+#else
+#   define gcdMMU_SIZE                          (2048 << 10)
+#endif
 #endif
 
 /*
@@ -342,6 +365,16 @@
 #endif
 
 /*
+    gcdPOWER_SUSNPEND_WHEN_IDLE
+
+        Set to 1 to make GPU enter gcvPOWER_SUSPEND when idle detected,
+        otherwise GPU will enter gcvPOWER_IDLE.
+*/
+#ifndef gcdPOWER_SUSNPEND_WHEN_IDLE
+#   define gcdPOWER_SUSNPEND_WHEN_IDLE          1
+#endif
+
+/*
     gcdFPGA_BUILD
 
         This define enables work arounds for FPGA images.
@@ -363,7 +396,7 @@
 #   if gcdFPGA_BUILD
 #       define gcdGPU_TIMEOUT                   0
 #   else
-#       define gcdGPU_TIMEOUT                   (2000 * 5)
+#       define gcdGPU_TIMEOUT                   20000
 #   endif
 #endif
 
@@ -599,11 +632,11 @@
 
         When non-zero, GPU will power off automatically from
         idle state, and gcdPOWEROFF_TIMEOUT is also the default
-        timeout value.
+        timeout in milliseconds.
  */
 
 #ifndef gcdPOWEROFF_TIMEOUT
-#   define gcdPOWEROFF_TIMEOUT                  5000
+#   define gcdPOWEROFF_TIMEOUT                  300
 #endif
 
 /*
@@ -720,18 +753,15 @@
 #   define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
 #endif
 
+#ifndef gcdENABLE_PE_DITHER_FIX
+#   define gcdENABLE_PE_DITHER_FIX              1
+#endif
+
 #ifndef gcdSHARED_PAGETABLE
 #   define gcdSHARED_PAGETABLE                  1
 #endif
-
-/*
-    gcdBLOB_CACHE_ENABLED
-        When non-zero, Android blob cache extension will be enabled.
-        Otherwise, caching will be by-passed.
- */
-
-#ifndef gcdBLOB_CACHE_ENABLED
-#   define gcdBLOB_CACHE_ENABLED                0
+#ifndef gcdUSE_PVR
+#   define gcdUSE_PVR			                1
 #endif
 
 /*
@@ -749,4 +779,83 @@
 #   define gcdRATIO_FOR_SMALL_MEMORY            32
 #endif
 
+/*
+    gcdCONTIGUOUS_SIZE_LIMIT
+        When non-zero, size of video node from gcvPOOL_CONTIGUOUS is
+        limited by gcdCONTIGUOUS_SIZE_LIMIT.
+ */
+#ifndef gcdCONTIGUOUS_SIZE_LIMIT
+#   define gcdCONTIGUOUS_SIZE_LIMIT             0
+#endif
+
+#ifndef gcdDISALBE_EARLY_EARLY_Z
+#   define gcdDISALBE_EARLY_EARLY_Z             1
+#endif
+
+/*
+    gcdLINK_QUEUE_SIZE
+
+        When non-zero, driver maintains a queue to record information of
+        latest lined context buffer and command buffer. Data in this queue
+        is be used to debug.
+*/
+#ifndef gcdLINK_QUEUE_SIZE
+#   define gcdLINK_QUEUE_SIZE                  0
+#endif
+
+/*  gcdALPHA_KILL_IN_SHADER
+ *
+ *  Enable alpha kill inside the shader. This will be set automatically by the
+ *  HAL if certain states match a criteria.
+ */
+#ifndef gcdALPHA_KILL_IN_SHADER
+#   define gcdALPHA_KILL_IN_SHADER              1
+#endif
+
+/*  gcdHIGH_PRECISION_DELAY_ENABLE
+ *
+ *  Enable high precision schedule delay with 1ms unit. otherwise schedule delay up to 10ms.
+ *  Browser app performance will have obvious drop without this enablement
+ */
+#ifndef gcdHIGH_PRECISION_DELAY_ENABLE
+#   define gcdHIGH_PRECISION_DELAY_ENABLE        1
+#endif
+
+#ifndef gcdUSE_WCLIP_PATCH
+#   define gcdUSE_WCLIP_PATCH                   1
+#endif
+
+#ifndef gcdHZ_L2_DISALBE
+#   define gcdHZ_L2_DISALBE                     1
+#endif
+
+#ifndef gcdBUGFIX15_DISABLE
+#   define gcdBUGFIX15_DISABLE                  1
+#endif
+
+#ifndef gcdDISABLE_HZ_FAST_CLEAR
+#   define gcdDISABLE_HZ_FAST_CLEAR             1
+#endif
+
+#ifndef gcdUSE_NPOT_PATCH
+#define gcdUSE_NPOT_PATCH                       1
+#endif
+
+
+#ifndef gcdSYNC
+#   define gcdSYNC                              1
+#endif
+
+/*
+    gcdDVFS
+
+        When non-zero, software will make use of dynamic voltage and
+        frequency feature.
+ */
+#ifndef gcdDVFS
+#   define gcdDVFS                               0
+#   define gcdDVFS_ANAYLSE_WINDOW                4
+#   define gcdDVFS_POLLING_TIME                  (gcdDVFS_ANAYLSE_WINDOW * 4)
+#endif
+
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index ee4a2ce..3e450ba 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -361,7 +361,8 @@ extern "C" {
 #define ES20_GLMAPBUFFEROES                         (ES20_DELETEVERTEXARRAYOES                  +   1)
 #define ES20_GLUNMAPBUFFEROES                       (ES20_GLMAPBUFFEROES                        +   1)
 #define ES20_GLGETBUFFERPOINTERVOES                 (ES20_GLUNMAPBUFFEROES                      +   1)
-#define	ES20_CALLS									(ES20_GLGETBUFFERPOINTERVOES				+	1)
+#define ES20_DISCARDFRAMEBUFFEREXT                  (ES20_GLGETBUFFERPOINTERVOES				+	1)
+#define	ES20_CALLS									(ES20_DISCARDFRAMEBUFFEREXT 				+	1)
 #define	ES20_DRAWCALLS								(ES20_CALLS									+	1)
 #define	ES20_STATECHANGECALLS						(ES20_DRAWCALLS								+	1)
 #define	ES20_POINTCOUNT								(ES20_STATECHANGECALLS						+	1)
@@ -480,6 +481,8 @@ extern "C" {
 #define GPU_CYCLES		1
 #define GPU_READ64BYTE	(GPU_CYCLES		+ 1)
 #define GPU_WRITE64BYTE	(GPU_READ64BYTE	+ 1)
+#define GPU_TOTALCYCLES	(GPU_WRITE64BYTE	+ 1)
+#define GPU_IDLECYCLES	(GPU_TOTALCYCLES	+ 1)
 
 #define VS_INSTCOUNT			1
 #define VS_BRANCHINSTCOUNT		(VS_INSTCOUNT		+ 1)
@@ -572,7 +575,11 @@ extern "C" {
 #define VPG_PROG        0x140000
 #define VPG_PVS         0x150000
 #define VPG_PPS         0x160000
-#define VPG_FRAME       0x170000
+#define VPG_ES11_TIME   0x170000
+#define VPG_ES20_TIME   0x180000
+#define VPG_FRAME       0x190000
+#define VPG_ES11_DRAW 0x200000
+#define VPG_ES20_DRAW 0x210000
 #define VPG_END         0xff0000
 
 /* Info. */
@@ -1010,6 +1017,8 @@ extern "C" {
 #define VPC_GPUCYCLES                   (VPG_GPU + GPU_CYCLES)
 #define VPC_GPUREAD64BYTE               (VPG_GPU + GPU_READ64BYTE)
 #define VPC_GPUWRITE64BYTE              (VPG_GPU + GPU_WRITE64BYTE)
+#define VPC_GPUTOTALCYCLES              (VPG_GPU + GPU_TOTALCYCLES)
+#define VPC_GPUIDLECYCLES              (VPG_GPU + GPU_IDLECYCLES)
 
 /* HW: Shader Counters. */
 #define VPC_VSINSTCOUNT                 (VPG_VS + VS_INSTCOUNT)
@@ -1086,6 +1095,12 @@ extern "C" {
 #define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
 #define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
 
+
+#define VPG_ES20_DRAW_NO  (VPG_ES20_DRAW + 1)
+#define VPG_ES11_DRAW_NO  (VPG_ES11_DRAW + 1)
+
+#define VPG_FRAME_USEVBO (VPG_FRAME + 1)
+
 #endif
 
 
@@ -1103,6 +1118,8 @@ typedef struct _gcsPROFILER_COUNTERS
 
     /* HW vairable counters. */
     gctUINT32       gpuCyclesCounter;
+	gctUINT32       gpuTotalCyclesCounter;
+	gctUINT32       gpuIdleCyclesCounter;
     gctUINT32       gpuTotalRead64BytesPerFrame;
     gctUINT32       gpuTotalWrite64BytesPerFrame;
 
@@ -1173,6 +1190,7 @@ typedef struct _gcsPROFILER
     gctBOOL         enableHal;
     gctBOOL         enableHW;
     gctBOOL         enableSH;
+	gctBOOL         isSyncMode;
 
     gctBOOL         useSocket;
     gctINT          sockFd;
@@ -1282,6 +1300,13 @@ gcoPROFILER_EndFrame(
     IN gcoHAL Hal
     );
 
+/* Call to signal end of draw. */
+gceSTATUS
+gcoPROFILER_EndDraw(
+    IN gcoHAL Hal,
+    IN gctBOOL FirstDraw
+    );
+
 /* Increase profile counter Enum by Value. */
 gceSTATUS
 gcoPROFILER_Count(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index c303462..bc4171e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_raster_h_
 #define __gc_hal_raster_h_
 
@@ -416,6 +414,14 @@ gco2D_SetTargetEx(
 
 /* Calculate and program the stretch factors. */
 gceSTATUS
+gco2D_CalcStretchFactor(
+    IN gco2D Engine,
+    IN gctINT32 SrcSize,
+    IN gctINT32 DestSize,
+    OUT gctUINT32_PTR Factor
+    );
+
+gceSTATUS
 gco2D_SetStretchFactors(
 	IN gco2D Engine,
 	IN gctUINT32 HorFactor,
@@ -926,6 +932,29 @@ gco2D_SetGdiStretchMode(
     IN gctBOOL Enable
     );
 
+gceSTATUS
+gco2D_SetSourceTileStatus(
+    IN gco2D Engine,
+    IN gce2D_TILE_STATUS_CONFIG TSControl,
+    IN gceSURF_FORMAT CompressedFormat,
+    IN gctUINT32 ClearValue,
+    IN gctUINT32 GpuAddress
+    );
+
+gceSTATUS
+gco2D_QueryU32(
+    IN gco2D Engine,
+    IN gce2D_QUERY Item,
+    OUT gctUINT32_PTR Value
+    );
+
+gceSTATUS
+gco2D_SetStateU32(
+    IN gco2D Engine,
+    IN gce2D_STATE State,
+    IN gctUINT32 Value
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
index ed6718d..6c10fbf 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_rename_h_
 #define __gc_hal_rename_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
new file mode 100644
index 0000000..82336e8
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifndef __gc_hal_statistics_h_
+#define __gc_hal_statistics_h_
+
+
+#define VIV_STAT_ENABLE_STATISTICS              0
+
+/*  Toal number of frames for which the frame time is accounted. We have storage
+    to keep frame times for last this many frames.
+*/
+#define VIV_STAT_FRAME_BUFFER_SIZE              30
+
+/*
+    Total number of frames sampled for a mode. This means
+
+    # of frames for HZ Current  : VIV_STAT_EARLY_Z_SAMPLE_FRAMES
+    # of frames for HZ Switched : VIV_STAT_EARLY_Z_SAMPLE_FRAMES
+  +
+  --------------------------------------------------------
+                                : (2 * VIV_STAT_EARLY_Z_SAMPLE_FRAMES) frames needed
+
+    IMPORTANT: This total must be smaller than VIV_STAT_FRAME_BUFFER_SIZE
+*/
+#define VIV_STAT_EARLY_Z_SAMPLE_FRAMES          7
+#define VIV_STAT_EARLY_Z_LATENCY_FRAMES         2
+
+/* Multiplication factor for previous Hz off mode. Make it more than 1.0 to advertise HZ on.*/
+#define VIV_STAT_EARLY_Z_FACTOR                 (1.05f)
+
+/* Defines the statistical data keys monitored by the statistics module */
+typedef enum _gceSTATISTICS
+{
+    gcvFRAME_FPS        =   1,
+}
+gceSTATISTICS;
+
+/* HAL statistics information. */
+typedef struct _gcsSTATISTICS_EARLYZ
+{
+    gctUINT                     switchBackCount;
+    gctUINT                     nextCheckPoint;
+    gctBOOL                     disabled;
+}
+gcsSTATISTICS_EARLYZ;
+
+
+/* Defines the statistical data keys monitored by the statistics module */
+typedef enum _gceSTATISTICS_Call
+{
+	gcvSTAT_ES11_GLDRAWELEMENTS      =   1,
+}
+gceSTATISTICS_Call;
+
+
+/* HAL statistics information. */
+typedef struct _gcsSTATISTICS
+{
+    gctUINT64                   frameTime[VIV_STAT_FRAME_BUFFER_SIZE];
+    gctUINT64                   previousFrameTime;
+    gctUINT                     frame;
+    gcsSTATISTICS_EARLYZ        earlyZ;
+	gctUINT						ES11_drawElementsCount;
+	gctBOOL						applyRTestVAFix;
+}
+gcsSTATISTICS;
+
+
+/* Add a frame based data into current statistics. */
+void
+gcfSTATISTICS_AddData(
+    IN gceSTATISTICS Key,
+    IN gctUINT Value
+    );
+
+/* Marks the frame end and triggers statistical calculations and decisions.*/
+void
+gcfSTATISTICS_MarkFrameEnd (
+    void
+    );
+
+/* Sets whether the dynmaic HZ is disabled or not .*/
+void
+gcfSTATISTICS_DisableDynamicEarlyZ (
+    IN gctBOOL Disabled
+    );
+
+/* Checks whether or not glDrawArray function call will be discarded */
+gctBOOL
+gcfSTATISTICS_DiscardCall(
+	gceSTATISTICS_Call Function
+	);
+
+
+#endif /*__gc_hal_statistics_h_ */
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index e6d38c1..5c0877d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_types_h_
 #define __gc_hal_types_h_
 
@@ -146,6 +144,7 @@ typedef unsigned char           gctUINT8;
 typedef unsigned short          gctUINT16;
 typedef unsigned int            gctUINT32;
 typedef unsigned long long      gctUINT64;
+typedef unsigned long           gctUINTPTR_T;
 
 typedef gctUINT *               gctUINT_PTR;
 typedef gctUINT8 *              gctUINT8_PTR;
@@ -285,6 +284,8 @@ typedef enum _gceSTATUS
 	gcvSTATUS_EXECUTED				=	18,
     gcvSTATUS_TERMINATE             =   19,
 
+    gcvSTATUS_CONVERT_TO_SINGLE_STREAM    =   20,
+
     gcvSTATUS_INVALID_ARGUMENT      =   -1,
     gcvSTATUS_INVALID_OBJECT        =   -2,
     gcvSTATUS_OUT_OF_MEMORY         =   -3,
@@ -312,6 +313,7 @@ typedef enum _gceSTATUS
     gcvSTATUS_LOCKED                =   -25,
     gcvSTATUS_INTERRUPTED           =   -26,
     gcvSTATUS_DEVICE                =   -27,
+    gcvSTATUS_NOT_MULTI_PIPE_ALIGNED =   -28,
 
     /* Linker errors. */
     gcvSTATUS_GLOBAL_TYPE_MISMATCH  =   -1000,
@@ -324,6 +326,10 @@ typedef enum _gceSTATUS
     gcvSTATUS_NAME_MISMATCH         =   -1007,
     gcvSTATUS_INVALID_INDEX         =   -1008,
     gcvSTATUS_UNIFORM_TYPE_MISMATCH =   -1009,
+
+    /* Compiler errors. */
+    gcvSTATUS_COMPILER_FE_PREPROCESSOR_ERROR = -2000,
+    gcvSTATUS_COMPILER_FE_PARSER_ERROR = -2001,
 }
 gceSTATUS;
 
@@ -580,13 +586,13 @@ gceSTATUS;
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
 
 #   define gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count) \
-        CommandBuffer->lastLoadStatePtr     = Memory; \
+        CommandBuffer->lastLoadStatePtr     = gcmPTR_TO_UINT64(Memory); \
         CommandBuffer->lastLoadStateAddress = Address; \
         CommandBuffer->lastLoadStateCount   = Count
 
 #   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address) \
         gcmASSERT( \
-            (gctUINT) (Memory  - CommandBuffer->lastLoadStatePtr - 1) \
+            (gctUINT) (Memory  - gcmUINT64_TO_TYPE(CommandBuffer->lastLoadStatePtr, gctUINT32_PTR) - 1) \
             == \
             (gctUINT) (Address - CommandBuffer->lastLoadStateAddress) \
             ); \
@@ -615,10 +621,10 @@ gceSTATUS;
 #   define gcmBEGINSECUREUSER() \
         __secure_user_offset__ = reserve->lastOffset; \
         \
-        __secure_user_hintArray__ = reserve->hintArrayTail
+        __secure_user_hintArray__ = gcmUINT64_TO_PTR(reserve->hintArrayTail)
 
 #   define gcmENDSECUREUSER() \
-        reserve->hintArrayTail = __secure_user_hintArray__
+        reserve->hintArrayTail = gcmPTR_TO_UINT64(__secure_user_hintArray__)
 
 #   define gcmSKIPSECUREUSER() \
         __secure_user_offset__ += gcmSIZEOF(gctUINT32)
@@ -674,7 +680,7 @@ gceSTATUS;
         Hardware->buffer, ReserveSize, gcvTRUE, &CommandBuffer \
         )); \
     \
-    Memory = (gctUINT32_PTR) CommandBuffer->lastReserve; \
+    Memory =  gcmUINT64_TO_PTR(CommandBuffer->lastReserve); \
     \
     StateDelta = Hardware->delta; \
     \
@@ -686,7 +692,7 @@ gceSTATUS;
     gcmENDSECUREUSER(); \
     \
     gcmASSERT( \
-        ((gctUINT8_PTR) CommandBuffer->lastReserve) + ReserveSize \
+        gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT8_PTR) + ReserveSize \
         == \
          (gctUINT8_PTR) Memory \
         ); \
@@ -696,7 +702,8 @@ gceSTATUS;
 
 #define gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, Count) \
 { \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
+    gcmASSERT((gctUINT32)Count <= 1024); \
     \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
@@ -715,7 +722,7 @@ gceSTATUS;
 { \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
 }
 
 /*----------------------------------------------------------------------------*/
@@ -882,19 +889,25 @@ gceSTATUS;
     gcmPTR2INT(& (((struct s *) 0)->field)) \
 )
 
+#define gcmSWAB32(x) ((gctUINT32)( \
+        (((gctUINT32)(x) & (gctUINT32)0x000000FFUL) << 24) | \
+        (((gctUINT32)(x) & (gctUINT32)0x0000FF00UL) << 8)  | \
+        (((gctUINT32)(x) & (gctUINT32)0x00FF0000UL) >> 8)  | \
+        (((gctUINT32)(x) & (gctUINT32)0xFF000000UL) >> 24)))
+
 /*******************************************************************************
 ***** Database ****************************************************************/
 
 typedef struct _gcsDATABASE_COUNTERS
 {
     /* Number of currently allocated bytes. */
-    gctSIZE_T                   bytes;
+    gctUINT64                   bytes;
 
     /* Maximum number of bytes allocated (memory footprint). */
-    gctSIZE_T                   maxBytes;
+    gctUINT64                   maxBytes;
 
     /* Total number of bytes allocated. */
-    gctSIZE_T                   totalBytes;
+    gctUINT64                   totalBytes;
 }
 gcsDATABASE_COUNTERS;
 
@@ -963,6 +976,25 @@ typedef struct _gcsHAL_FRAME_INFO
 }
 gcsHAL_FRAME_INFO;
 
+#if gcdLINK_QUEUE_SIZE
+typedef struct _gckLINKDATA * gckLINKDATA;
+struct _gckLINKDATA
+{
+    gctUINT32                   start;
+    gctUINT32                   end;
+    gctINT                      pid;
+};
+
+typedef struct _gckLINKQUEUE * gckLINKQUEUE;
+struct _gckLINKQUEUE
+{
+    struct _gckLINKDATA         data[gcdLINK_QUEUE_SIZE];
+    gctUINT32                   rear;
+    gctUINT32                   front;
+    gctUINT32                   count;
+};
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index 2cb52a0..2881604 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_version_h_
 #define __gc_hal_version_h_
 
@@ -28,9 +26,9 @@
 
 #define gcvVERSION_MINOR        6
 
-#define gcvVERSION_PATCH        6
+#define gcvVERSION_PATCH        9
 
-#define gcvVERSION_BUILD        1394
+#define gcvVERSION_BUILD     1210
 
 #define gcvVERSION_DATE      __DATE__
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 2060170..5ff0281 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,10 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
-
 #ifndef __gc_hal_vg_h_
 #define __gc_hal_vg_h_
 
@@ -249,32 +245,6 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 )
 
 /* some platforms need to fix the physical address for HW to access*/
-#ifdef __QNXNTO__
-
-gcmINLINE static gctUINT32 _qnxFixAddress(gctUINT32 Address)
-{
-    gctUINT32 baseAddress = 0;
-
-    if (gcmIS_ERROR(gcoOS_GetBaseAddress(gcvNULL, &baseAddress)))
-    {
-        baseAddress = 0;
-    }
-
-    return Address + baseAddress;
-}
-
-#define gcmFIXADDRESS       _qnxFixAddress
-
-gcmINLINE static gctUINT32 _qnxkFixAddress(gctUINT32 Address)
-{
-    extern unsigned long baseAddress;
-    return Address + baseAddress;
-}
-
-#define gcmkFIXADDRESS      _qnxkFixAddress
-
-#else
-
 #define gcmFIXADDRESS(address) \
 (\
     (address)\
@@ -285,8 +255,6 @@ gcmINLINE static gctUINT32 _qnxkFixAddress(gctUINT32 Address)
     (address)\
 )
 
-#endif
-
 /******************************************************************************\
 ****************************** Kernel Debug Macro ******************************
 \******************************************************************************/
@@ -617,7 +585,7 @@ typedef struct _gcsCMDBUFFER
     /* The user sets this to the node of the container buffer whitin which
        this particular command buffer resides. The kernel sets this to the
        node of the internally allocated buffer. */
-    gcuVIDMEM_NODE_PTR          node;
+    gctUINT64                   node;
 
     /* Command buffer hardware address. */
     gctUINT32                   address;
@@ -924,6 +892,12 @@ gckVGMMU_SetPage(
    IN gctUINT32 *PageEntry
    );
 
+/* Flush MMU */
+gceSTATUS
+gckVGMMU_Flush(
+   IN gckVGMMU Mmu
+   );
+
 #endif /* gcdENABLE_VG */
 
 #ifdef __cplusplus
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
index 5bbc893..339dff4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_debug_h_
 #define __gc_hal_kernel_debug_h_
 
@@ -71,9 +69,13 @@ typedef va_list gctARGUMENTS;
 #endif
 
 #define gcmkOUTPUT_STRING(String) \
-    printk(String); \
+   if(gckDebugFileSystemIsEnabled()) \
+   	gckDebugFileSystemPrint(String);\
+   else\
+   	printk(String); \
     touch_softlockup_watchdog()
 
+
 #define gcmkSPRINTF(Destination, Size, Message, Value) \
     snprintf(Destination, Size, Message, Value)
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
new file mode 100644
index 0000000..6bdc5a6
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -0,0 +1,795 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifdef MODULE
+#include <linux/module.h>
+#endif
+#include <linux/init.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/completion.h>
+#include "gc_hal_kernel_linux.h"
+
+/*
+   Prequsite:
+
+   1) Debugfs feature must be enabled in the kernel.
+       1.a) You can enable this, in the compilation of the uImage, all you have to do is, In the "make menuconfig" part,
+       you have to enable the debugfs in the kernel hacking part of the menu.
+
+   HOW TO USE:
+   1) insert the driver with the following option logFileSize, Ex: insmod galcore.ko ...... logFileSize=10240
+   This gives a circular buffer of 10 MB
+
+   2)Usually after inserting the driver, the debug file system is mounted under /sys/kernel/debug/
+
+        2.a)If the debugfs is not mounted, you must do "mount -t debugfs none /sys/kernel/debug"
+
+   3) To read what is being printed in the debugfs file system:
+        Ex : cat /sys/kernel/debug/gpu/galcore_trace
+
+   4)To write into the debug file system from user side :
+        Ex: echo "hello" > cat /sys/kernel/debug/gpu/galcore_trace
+
+   5)To write into debugfs from kernel side, Use the function called gckDebugFileSystemPrint
+
+
+   USECASE Kernel Dump:
+
+   1) Go to /hal/inc/gc_hal_options.h, and enable the following flags:
+        - #   define gcdDUMP                              1
+        - #   define gcdDUMP_IN_KERNEL          1
+        - #   define gcdDUMP_COMMAND          1
+
+    2) Go to /hal/kernel/gc_hal_kernel_command.c and disable the following flag
+        -#define gcdSIMPLE_COMMAND_DUMP  0
+
+    3) Compile the driver
+    4) insmod it with the logFileSize option
+    5) Run an application
+    6) You can get the dump by cat /sys/kernel/debug/gpu/galcore_trace
+
+ */
+
+/**/
+typedef va_list gctDBGARGS ;
+#define gcmkARGS_START(argument, pointer)   va_start(argument, pointer)
+#define gcmkARGS_END(argument)              	      va_end(argument)
+
+#define gcmkDBGFSPRINT(ArgumentSize, Message) \
+  { \
+	  gctDBGARGS __arguments__; \
+	  gcmkARGS_START(__arguments__, Message); \
+	  _DebugFSPrint(ArgumentSize, Message, __arguments__);\
+	  gcmkARGS_END(__arguments__); \
+  }
+
+/*Debug File System Node Struct*/
+struct _gcsDebugFileSystemNode
+{
+    /*wait queues for read and write operations*/
+#if defined(DECLARE_WAIT_QUEUE_HEAD)
+    wait_queue_head_t read_q , write_q ;
+#else
+    struct wait_queue *read_q , *write_q ;
+#endif
+    struct dentry *parent ; /*parent directory*/
+    struct dentry *filen ; /*filename*/
+    struct semaphore sem ; /* mutual exclusion semaphore */
+    char *data ; /* The circular buffer data */
+    int size ; /* Size of the buffer pointed to by 'data' */
+    int refcount ; /* Files that have this buffer open */
+    int read_point ; /* Offset in circ. buffer of oldest data */
+    int write_point ; /* Offset in circ. buffer of newest data */
+    int offset ; /* Byte number of read_point in the stream */
+    struct _gcsDebugFileSystemNode *next ;
+} ;
+
+/* amount of data in the queue */
+#define gcmkNODE_QLEN(node) ( (node)->write_point >= (node)->read_point ? \
+         (node)->write_point - (node)->read_point : \
+         (node)->size - (node)->read_point + (node)->write_point)
+
+/* byte number of the last byte in the queue */
+#define gcmkNODE_FIRST_EMPTY_BYTE(node) ((node)->offset + gcmkNODE_QLEN(node))
+
+/*Synchronization primitives*/
+#define gcmkNODE_READQ(node) (&((node)->read_q))
+#define gcmkNODE_WRITEQ(node) (&((node)->write_q))
+#define gcmkNODE_SEM(node) (&((node)->sem))
+
+/*Utilities*/
+#define gcmkMIN(x, y) ((x) < (y) ? (x) : y)
+
+/*Debug File System Struct*/
+typedef struct _gcsDebugFileSystem
+{
+    gcsDebugFileSystemNode* linkedlist ;
+    gcsDebugFileSystemNode* currentNode ;
+    int isInited ;
+} gcsDebugFileSystem ;
+
+
+/*debug file system*/
+static gcsDebugFileSystem gc_dbgfs ;
+
+
+
+/*******************************************************************************
+ **
+ **		READ & WRITE FUNCTIONS (START)
+ **
+ *******************************************************************************/
+
+/*******************************************************************************
+ **
+ **  _ReadFromNode
+ **
+ **	1) reading bytes out of a circular buffer with wraparound.
+ **	2)returns caddr_t, pointer to data read, which the caller must free.
+ **	3) length is (a pointer to) the number of bytes to be read, which will be set by this function to
+ **	    be the number of bytes actually returned
+ **
+ *******************************************************************************/
+static caddr_t
+_ReadFromNode (
+                gcsDebugFileSystemNode* Node ,
+                size_t *Length ,
+                loff_t *Offset
+                )
+{
+    caddr_t retval ;
+    int bytes_copied = 0 , n , start_point , remaining ;
+
+    /* is the user trying to read data that has already scrolled off? */
+    if ( *Offset < Node->offset )
+    {
+        *Offset = Node->offset ;
+    }
+
+    /* is the user trying to read past EOF? */
+    if ( *Offset >= gcmkNODE_FIRST_EMPTY_BYTE ( Node ) )
+    {
+        return NULL ;
+    }
+
+    /* find the smaller of the total bytes we have available and what
+     * the user is asking for */
+
+    *Length = gcmkMIN ( *Length , gcmkNODE_FIRST_EMPTY_BYTE ( Node ) - *Offset ) ;
+
+    remaining = * Length ;
+
+    /* figure out where to start based on user's Offset */
+    start_point = Node->read_point + ( *Offset - Node->offset ) ;
+
+    start_point = start_point % Node->size ;
+
+    /* allocate memory to return */
+    if ( ( retval = kmalloc ( sizeof (char ) * remaining , GFP_KERNEL ) ) == NULL )
+        return NULL ;
+
+    /* copy the (possibly noncontiguous) data to our buffer */
+    while ( remaining )
+    {
+        n = gcmkMIN ( remaining , Node->size - start_point ) ;
+        memcpy ( retval + bytes_copied , Node->data + start_point , n ) ;
+        bytes_copied += n ;
+        remaining -= n ;
+        start_point = ( start_point + n ) % Node->size ;
+    }
+
+    /* advance user's file pointer */
+    *Offset += * Length ;
+
+    return retval ;
+}
+
+/*******************************************************************************
+ **
+ **  _WriteToNode
+ **
+ ** 1) writes to a circular buffer with wraparound.
+ ** 2)in case of an overflow, it overwrites the oldest unread data.
+ **
+ *********************************************************************************/
+static void
+_WriteToNode (
+               gcsDebugFileSystemNode* Node ,
+               caddr_t Buf ,
+               int Length
+               )
+{
+    int bytes_copied = 0 ;
+    int overflow = 0 ;
+    int n ;
+
+    if ( Length + gcmkNODE_QLEN ( Node ) >= ( Node->size - 1 ) )
+    {
+        overflow = 1 ;
+
+        /* in case of overflow, figure out where the new buffer will
+         * begin.  we start by figuring out where the current buffer ENDS:
+         * node->parent->offset +  gcmkNODE_QLEN.	we then advance the end-offset
+         * by the Length of the current write, and work backwards to
+         * figure out what the oldest unoverwritten data will be (i.e.,
+         * size of the buffer). */
+        Node->offset = Node->offset + gcmkNODE_QLEN ( Node ) + Length
+                - Node->size + 1 ;
+    }
+
+    while ( Length )
+    {
+        /* how many contiguous bytes are available from the write point to
+         * the end of the circular buffer? */
+        n = gcmkMIN ( Length , Node->size - Node->write_point ) ;
+        memcpy ( Node->data + Node->write_point , Buf + bytes_copied , n ) ;
+        bytes_copied += n ;
+        Length -= n ;
+        Node->write_point = ( Node->write_point + n ) % Node->size ;
+    }
+
+    /* if there is an overflow, reset the read point to read whatever is
+     * the oldest data that we have, that has not yet been
+     * overwritten. */
+    if ( overflow )
+    {
+        Node->read_point = ( Node->write_point + 1 ) % Node->size ;
+    }
+}
+
+
+/*******************************************************************************
+ **
+ ** 		PRINTING UTILITY (START)
+ **
+ *******************************************************************************/
+
+/*******************************************************************************
+ **
+ **  _GetArgumentSize
+ **
+ **
+ *******************************************************************************/
+static gctINT
+_GetArgumentSize (
+                   IN gctCONST_STRING Message
+                   )
+{
+    gctINT i , count ;
+
+    for ( i = 0 , count = 0 ; Message[i] ; i += 1 )
+    {
+        if ( Message[i] == '%' )
+        {
+            count += 1 ;
+        }
+    }
+    return count * sizeof (unsigned int ) ;
+}
+
+/*******************************************************************************
+ **
+ ** _AppendString
+ **
+ **
+ *******************************************************************************/
+static ssize_t
+_AppendString (
+                IN gcsDebugFileSystemNode* Node ,
+                IN gctCONST_STRING String ,
+                IN int Length
+                )
+{
+    caddr_t message = NULL ;
+    int n ;
+
+    /* if the message is longer than the buffer, just take the beginning
+     * of it, in hopes that the reader (if any) will have time to read
+     * before we wrap around and obliterate it */
+    n = gcmkMIN ( Length , Node->size - 1 ) ;
+
+    /* make sure we have the memory for it */
+    if ( ( message = kmalloc ( n , GFP_KERNEL ) ) == NULL )
+        return - ENOMEM ;
+
+    /* copy into our temp buffer */
+    memcpy ( message , String , n ) ;
+
+    /* now copy it into the circular buffer and free our temp copy */
+    _WriteToNode ( Node , message , n ) ;
+    kfree ( message ) ;
+    return n ;
+}
+
+/*******************************************************************************
+ **
+ ** _DebugFSPrint
+ **
+ **
+ *******************************************************************************/
+static void
+_DebugFSPrint (
+                IN unsigned int ArgumentSize ,
+                IN const char* Message ,
+                IN gctDBGARGS Arguments
+
+                )
+{
+    char buffer[MAX_LINE_SIZE] ;
+    int len ;
+    down ( gcmkNODE_SEM ( gc_dbgfs.currentNode ) ) ;
+    len = vsnprintf ( buffer , sizeof (buffer ) , Message , *( va_list * ) & Arguments ) ;
+    buffer[len] = '\0' ;
+
+    /* Add end-of-line if missing. */
+    if ( buffer[len - 1] != '\n' )
+    {
+        buffer[len ++] = '\n' ;
+        buffer[len] = '\0' ;
+    }
+    _AppendString ( gc_dbgfs.currentNode , buffer , len ) ;
+    up ( gcmkNODE_SEM ( gc_dbgfs.currentNode ) ) ;
+    wake_up_interruptible ( gcmkNODE_READQ ( gc_dbgfs.currentNode ) ) ; /* blocked in read*/
+}
+
+/*******************************************************************************
+ **
+ **                     LINUX SYSTEM FUNCTIONS (START)
+ **
+ *******************************************************************************/
+
+/*******************************************************************************
+ **
+ **  find the vivlog structure associated with an inode.
+ **  	returns a	pointer to the structure if found, NULL if not found
+ **
+ *******************************************************************************/
+static gcsDebugFileSystemNode*
+_GetNodeInfo (
+               IN struct inode *Inode
+               )
+{
+    gcsDebugFileSystemNode* node ;
+
+    if ( Inode == NULL )
+        return NULL ;
+
+    for ( node = gc_dbgfs.linkedlist ; node != NULL ; node = node->next )
+        if ( node->filen->d_inode->i_ino == Inode->i_ino )
+            return node ;
+
+    return NULL ;
+}
+
+/*******************************************************************************
+ **
+ **   _DebugFSRead
+ **
+ *******************************************************************************/
+static ssize_t
+_DebugFSRead (
+               struct file *file ,
+               char __user * buffer ,
+               size_t length ,
+               loff_t * offset
+               )
+{
+    int retval ;
+    caddr_t data_to_return ;
+    gcsDebugFileSystemNode* node ;
+    /* get the metadata about this emlog */
+    if ( ( node = _GetNodeInfo ( file->f_dentry->d_inode ) ) == NULL )
+    {
+        printk ( "debugfs_read: record not found\n" ) ;
+        return - EIO ;
+    }
+
+    if ( down_interruptible ( gcmkNODE_SEM ( node ) ) )
+    {
+        return - ERESTARTSYS ;
+    }
+
+    /* wait until there's data available (unless we do nonblocking reads) */
+    while ( *offset >= gcmkNODE_FIRST_EMPTY_BYTE ( node ) )
+    {
+        up ( gcmkNODE_SEM ( node ) ) ;
+        if ( file->f_flags & O_NONBLOCK )
+        {
+            return - EAGAIN ;
+        }
+        if ( wait_event_interruptible ( ( *( gcmkNODE_READQ ( node ) ) ) , ( *offset < gcmkNODE_FIRST_EMPTY_BYTE ( node ) ) ) )
+        {
+            return - ERESTARTSYS ; /* signal: tell the fs layer to handle it */
+        }
+        /* otherwise loop, but first reacquire the lock */
+        if ( down_interruptible ( gcmkNODE_SEM ( node ) ) )
+        {
+            return - ERESTARTSYS ;
+        }
+    }
+    data_to_return = _ReadFromNode ( node , &length , offset ) ;
+    if ( data_to_return == NULL )
+    {
+        retval = 0 ;
+        goto unlock ;
+    }
+    if ( copy_to_user ( buffer , data_to_return , length ) > 0 )
+    {
+        retval = - EFAULT ;
+    }
+    else
+    {
+        retval = length ;
+    }
+    kfree ( data_to_return ) ;
+unlock:
+    up ( gcmkNODE_SEM ( node ) ) ;
+    wake_up_interruptible ( gcmkNODE_WRITEQ ( node ) ) ;
+    return retval ;
+}
+
+/*******************************************************************************
+ **
+ **_DebugFSWrite
+ **
+ *******************************************************************************/
+static ssize_t
+_DebugFSWrite (
+                struct file *file ,
+                const char __user * buffer ,
+                size_t length ,
+                loff_t * offset
+                )
+{
+    caddr_t message = NULL ;
+    int n ;
+    gcsDebugFileSystemNode*node ;
+
+    /* get the metadata about this log */
+    if ( ( node = _GetNodeInfo ( file->f_dentry->d_inode ) ) == NULL )
+    {
+        return - EIO ;
+    }
+
+    if ( down_interruptible ( gcmkNODE_SEM ( node ) ) )
+    {
+        return - ERESTARTSYS ;
+    }
+
+    /* if the message is longer than the buffer, just take the beginning
+     * of it, in hopes that the reader (if any) will have time to read
+     * before we wrap around and obliterate it */
+    n = gcmkMIN ( length , node->size - 1 ) ;
+
+    /* make sure we have the memory for it */
+    if ( ( message = kmalloc ( n , GFP_KERNEL ) ) == NULL )
+    {
+        up ( gcmkNODE_SEM ( node ) ) ;
+        return - ENOMEM ;
+    }
+
+    /* copy into our temp buffer */
+    if ( copy_from_user ( message , buffer , n ) > 0 )
+    {
+        up ( gcmkNODE_SEM ( node ) ) ;
+        kfree ( message ) ;
+        return - EFAULT ;
+    }
+
+    /* now copy it into the circular buffer and free our temp copy */
+    _WriteToNode ( node , message , n ) ;
+
+    kfree ( message ) ;
+    up ( gcmkNODE_SEM ( node ) ) ;
+
+    /* wake up any readers that might be waiting for the data.  we call
+     * schedule in the vague hope that a reader will run before the
+     * writer's next write, to avoid losing data. */
+    wake_up_interruptible ( gcmkNODE_READQ ( node ) ) ;
+
+    return n ;
+}
+
+/*******************************************************************************
+ **
+ ** File Operations Table
+ **
+ *******************************************************************************/
+static const struct file_operations debugfs_operations = {
+                                                          .owner = THIS_MODULE ,
+                                                          .read = _DebugFSRead ,
+                                                          .write = _DebugFSWrite ,
+} ;
+
+/*******************************************************************************
+ **
+ **                             INTERFACE FUNCTIONS (START)
+ **
+ *******************************************************************************/
+
+/*******************************************************************************
+ **
+ **  gckDebugFileSystemIsEnabled
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+
+
+gctINT
+gckDebugFileSystemIsEnabled ( void )
+{
+    return gc_dbgfs.isInited ;
+}
+/*******************************************************************************
+ **
+ **  gckDebugFileSystemInitialize
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+
+gctINT
+gckDebugFileSystemInitialize ( void )
+{
+    if ( ! gc_dbgfs.isInited )
+    {
+        gc_dbgfs.linkedlist = gcvNULL ;
+        gc_dbgfs.currentNode = gcvNULL ;
+        gc_dbgfs.isInited = 1 ;
+    }
+    return gc_dbgfs.isInited ;
+}
+/*******************************************************************************
+ **
+ **  gckDebugFileSystemTerminate
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+
+gctINT
+gckDebugFileSystemTerminate ( void )
+{
+    gcsDebugFileSystemNode * next = gcvNULL ;
+    gcsDebugFileSystemNode * temp = gcvNULL ;
+    if ( gc_dbgfs.isInited )
+    {
+        temp = gc_dbgfs.linkedlist ;
+        while ( temp != gcvNULL )
+        {
+            next = temp->next ;
+            gckDebugFileSystemFreeNode ( temp ) ;
+            kfree ( temp ) ;
+            temp = next ;
+        }
+        gc_dbgfs.isInited = 0 ;
+    }
+    return 0 ;
+}
+
+
+/*******************************************************************************
+ **
+ **  gckDebugFileSystemCreateNode
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ **	 gckDebugFileSystemFreeNode * Device
+ **		  Pointer to a variable receiving the gcsDebugFileSystemNode object pointer on
+ **		  success.
+ *********************************************************************************/
+
+gctINT
+gckDebugFileSystemCreateNode (
+                               IN gctINT SizeInKB ,
+                               IN gctCONST_STRING ParentName ,
+                               IN gctCONST_STRING NodeName ,
+                               OUT gcsDebugFileSystemNode **Node
+                               )
+{
+    gcsDebugFileSystemNode*node ;
+    /* allocate space for our metadata and initialize it */
+    if ( ( node = kmalloc ( sizeof (gcsDebugFileSystemNode ) , GFP_KERNEL ) ) == NULL )
+        goto struct_malloc_failed ;
+
+    /*Zero it out*/
+    memset ( node , 0 , sizeof (gcsDebugFileSystemNode ) ) ;
+
+    /*Init the sync primitives*/
+#if defined(DECLARE_WAIT_QUEUE_HEAD)
+    init_waitqueue_head ( gcmkNODE_READQ ( node ) ) ;
+#else
+    init_waitqueue ( gcmkNODE_READQ ( node ) ) ;
+#endif
+
+#if defined(DECLARE_WAIT_QUEUE_HEAD)
+    init_waitqueue_head ( gcmkNODE_WRITEQ ( node ) ) ;
+#else
+    init_waitqueue ( gcmkNODE_WRITEQ ( node ) ) ;
+#endif
+    sema_init ( gcmkNODE_SEM ( node ) , 1 ) ;
+    /*End the sync primitives*/
+
+
+    /* figure out how much of a buffer this should be and allocate the buffer */
+    node->size = 1024 * SizeInKB ;
+    if ( ( node->data = ( char * ) vmalloc ( sizeof (char ) * node->size ) ) == NULL )
+        goto data_malloc_failed ;
+
+    /*creating the debug file system*/
+    node->parent = debugfs_create_dir ( ParentName , NULL ) ;
+
+    /*creating the file*/
+    node->filen = debugfs_create_file ( NodeName , S_IRUGO | S_IWUSR , node->parent , NULL ,
+                                        &debugfs_operations ) ;
+
+    /* add it to our linked list */
+    node->next = gc_dbgfs.linkedlist ;
+    gc_dbgfs.linkedlist = node ;
+
+    /* pass the struct back */
+    *Node = node ;
+    return 0 ;
+
+    vfree ( node->data ) ;
+data_malloc_failed:
+    kfree ( node ) ;
+struct_malloc_failed:
+    return - ENOMEM ;
+}
+
+/*******************************************************************************
+ **
+ **  gckDebugFileSystemFreeNode
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+void
+gckDebugFileSystemFreeNode (
+                             IN gcsDebugFileSystemNode * Node
+                             )
+{
+
+    gcsDebugFileSystemNode **ptr ;
+
+    if ( Node == NULL )
+    {
+        printk ( "null passed to free_vinfo\n" ) ;
+        return ;
+    }
+
+    down ( gcmkNODE_SEM ( Node ) ) ;
+    /*free data*/
+    vfree ( Node->data ) ;
+
+    /*Close Debug fs*/
+    if ( Node->filen )
+    {
+        debugfs_remove ( Node->filen ) ;
+    }
+    if ( Node->parent )
+    {
+        debugfs_remove ( Node->parent ) ;
+    }
+
+    /* now delete the node from the linked list */
+    ptr = & ( gc_dbgfs.linkedlist ) ;
+    while ( *ptr != Node )
+    {
+        if ( ! *ptr )
+        {
+            printk ( "corrupt info list!\n" ) ;
+            break ;
+        }
+        else
+            ptr = & ( ( **ptr ).next ) ;
+    }
+    *ptr = Node->next ;
+    up ( gcmkNODE_SEM ( Node ) ) ;
+}
+
+/*******************************************************************************
+ **
+ **   gckDebugFileSystemSetCurrentNode
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+void
+gckDebugFileSystemSetCurrentNode (
+                                   IN gcsDebugFileSystemNode * Node
+                                   )
+{
+    gc_dbgfs.currentNode = Node ;
+}
+
+/*******************************************************************************
+ **
+ **   gckDebugFileSystemGetCurrentNode
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+void
+gckDebugFileSystemGetCurrentNode (
+                                   OUT gcsDebugFileSystemNode ** Node
+                                   )
+{
+    *Node = gc_dbgfs.currentNode ;
+}
+
+/*******************************************************************************
+ **
+ **   gckDebugFileSystemPrint
+ **
+ **
+ **  INPUT:
+ **
+ **  OUTPUT:
+ **
+ *******************************************************************************/
+void
+gckDebugFileSystemPrint (
+                          IN gctCONST_STRING Message ,
+                          ...
+                          )
+{
+    gcmkDBGFSPRINT ( _GetArgumentSize ( Message ) , Message ) ;
+}
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
new file mode 100644
index 0000000..78d8199
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -0,0 +1,84 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include <stdarg.h>
+
+#ifndef __gc_hal_kernel_debugfs_h_
+#define __gc_hal_kernel_debugfs_h_
+
+ #define MAX_LINE_SIZE 768  	     /* Max bytes for a line of debug info */
+
+
+ typedef struct _gcsDebugFileSystemNode gcsDebugFileSystemNode ;
+
+
+/*******************************************************************************
+ **
+ **                             System Related
+ **
+ *******************************************************************************/
+
+gctINT    gckDebugFileSystemIsEnabled(void);
+
+gctINT   gckDebugFileSystemInitialize(void);
+
+gctINT   gckDebugFileSystemTerminate(void);
+
+
+/*******************************************************************************
+ **
+ **                             Node Related
+ **
+ *******************************************************************************/
+
+gctINT gckDebugFileSystemCreateNode(
+ 			IN gctINT SizeInKB,
+                        IN gctCONST_STRING  ParentName ,
+                        IN gctCONST_STRING  NodeName,
+                        OUT gcsDebugFileSystemNode  **Node
+                        );
+
+
+void gckDebugFileSystemFreeNode(
+			IN gcsDebugFileSystemNode  * Node
+			);
+
+
+
+void gckDebugFileSystemSetCurrentNode(
+			IN gcsDebugFileSystemNode  * Node
+			);
+
+
+
+void gckDebugFileSystemGetCurrentNode(
+			OUT gcsDebugFileSystemNode  ** Node
+			);
+
+
+void gckDebugFileSystemPrint(
+    			IN gctCONST_STRING  Message,
+    			...
+   			 );
+
+#endif
+
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index efdaef8..7168f0e 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 #include <linux/pagemap.h>
 #include <linux/seq_file.h>
@@ -28,9 +26,14 @@
 #include <linux/mman.h>
 #include <linux/slab.h>
 #include <mach/hardware.h>
+#include <linux/pm_runtime.h>
 
 #define _GC_OBJ_ZONE    gcvZONE_DEVICE
 
+#define DEBUG_FILE 			"galcore_trace"
+#define PARENT_FILE 		"gpu"
+
+
 #ifdef FLAREON
     static struct dove_gpio_irq_handler gc500_handle;
 #endif
@@ -140,7 +143,7 @@ static int threadRoutine(void *ctxt)
         static int down;
 
         down = down_interruptible(&device->semas[gcvCORE_MAJOR]);
-        if (down); /* To make gcc4.6 happy */
+        if (down); /*To make gcc 4.6 happye*/
         device->dataReadys[gcvCORE_MAJOR] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
@@ -193,7 +196,7 @@ static int threadRoutine2D(void *ctxt)
         static int down;
 
         down = down_interruptible(&device->semas[gcvCORE_2D]);
-        if (down); /* To make gcc4.6 happy */
+        if (down); /*To make gcc 4.6 happye*/
         device->dataReadys[gcvCORE_2D] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
@@ -244,7 +247,7 @@ static int threadRoutineVG(void *ctxt)
         static int down;
 
         down = down_interruptible(&device->semas[gcvCORE_VG]);
-        if (down); /* To make gcc4.6 happy */
+        if (down); /*To make gcc 4.6 happye*/
         device->dataReadys[gcvCORE_VG] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
@@ -262,65 +265,6 @@ static int threadRoutineVG(void *ctxt)
     }
 }
 
-#if gcdPOWEROFF_TIMEOUT
-/*
-** PM Thread Routine
-**/
-static int _threadRoutinePM(gckGALDEVICE Device, gckHARDWARE Hardware)
-{
-    gceCHIPPOWERSTATE state;
-
-    for(;;)
-    {
-        /* wait for idle */
-        gcmkVERIFY_OK(
-            gckOS_WaitSignal(Device->os, Hardware->powerOffSignal, gcvINFINITE));
-
-        /* We try to power off every 200 ms, until GPU is not idle */
-        do
-        {
-            if (Device->killThread == gcvTRUE)
-            {
-                /* The daemon exits. */
-                while (!kthread_should_stop())
-                {
-                    gckOS_Delay(Device->os, 1);
-                }
-                return 0;
-            }
-
-            gcmkVERIFY_OK(
-                gckHARDWARE_SetPowerManagementState(
-                    Hardware,
-                    gcvPOWER_OFF_TIMEOUT));
-
-            /* relax cpu 200 ms before retry */
-            gckOS_Delay(Device->os, 200);
-
-            gcmkVERIFY_OK(
-                gckHARDWARE_QueryPowerManagementState(Hardware, &state));
-        }
-        while (state == gcvPOWER_IDLE);
-    }
-}
-
-static int threadRoutinePM(void *ctxt)
-{
-    gckGALDEVICE device = (gckGALDEVICE) ctxt;
-    gckHARDWARE hardware = device->kernels[gcvCORE_MAJOR]->hardware;
-
-    return _threadRoutinePM(device, hardware);
-}
-
-static int threadRoutinePM_2D(void *ctxt)
-{
-    gckGALDEVICE device = (gckGALDEVICE) ctxt;
-    gckHARDWARE hardware = device->kernels[gcvCORE_2D]->hardware;
-
-    return _threadRoutinePM(device, hardware);
-}
-#endif
-
 /******************************************************************************\
 ******************************* gckGALDEVICE Code ******************************
 \******************************************************************************/
@@ -358,6 +302,8 @@ gckGALDEVICE_Construct(
     IN gctUINT32 PhysBaseAddr,
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
+    IN gctUINT LogFileSize,
+    IN struct device *pdev,
     OUT gckGALDEVICE *Device
     )
 {
@@ -372,6 +318,7 @@ gckGALDEVICE_Construct(
     gctINT32 i;
     gceHARDWARE_TYPE type;
     gckDB sharedDB = gcvNULL;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("IrqLine=%d RegisterMemBase=0x%08x RegisterMemSize=%u "
                    "IrqLine2D=%d RegisterMemBase2D=0x%08x RegisterMemSize2D=%u "
@@ -394,12 +341,50 @@ gckGALDEVICE_Construct(
 
     memset(device, 0, sizeof(struct _gckGALDEVICE));
 
+   device->dbgnode = gcvNULL;
+   if(LogFileSize != 0)
+   {
+	if(gckDebugFileSystemCreateNode(LogFileSize,PARENT_FILE,DEBUG_FILE,&(device->dbgnode)) != 0)
+	{
+		gcmkTRACE_ZONE(
+		gcvLEVEL_ERROR, gcvZONE_DRIVER,
+		"%s(%d): Failed to create  the debug file system  %s/%s \n",
+		__FUNCTION__, __LINE__,
+		PARENT_FILE, DEBUG_FILE
+		);
+	}
+	else
+	{
+		/*Everything is OK*/
+	 	gckDebugFileSystemSetCurrentNode(device->dbgnode);
+	}
+    }
+#ifdef CONFIG_PM
+    /*Init runtime pm for gpu*/
+    pm_runtime_enable(pdev);
+    device->pmdev = pdev;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    device->gpu_regulator =(struct regulator*)0xffffffff ;
+#else
+    /*get gpu regulator*/
+    device->gpu_regulator = regulator_get(pdev, "cpu_vddgpu");
+    if (IS_ERR(device->gpu_regulator)) {
+	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+		"%s(%d): Failed to get gpu regulator  %s/%s \n",
+		__FUNCTION__, __LINE__,
+		PARENT_FILE, DEBUG_FILE);
+	gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+#endif
     /*Initialize the clock structure*/
     if (IrqLine != -1) {
-        device->clk_3d_core = clk_get(NULL, "gpu3d_clk");
+        device->clk_3d_core = clk_get(pdev, "gpu3d_clk");
         if (!IS_ERR(device->clk_3d_core)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
             if (cpu_is_mx6q()) {
-	            device->clk_3d_shader = clk_get(NULL, "gpu3d_shader_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
 	            if (IS_ERR(device->clk_3d_shader)) {
 	                IrqLine = -1;
 	                clk_put(device->clk_3d_core);
@@ -407,7 +392,18 @@ gckGALDEVICE_Construct(
 	                device->clk_3d_shader = NULL;
 	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
 	            }
-            }
+	          }
+#else
+	            device->clk_3d_axi = clk_get(pdev, "gpu3d_axi_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
+	            if (IS_ERR(device->clk_3d_shader)) {
+	                IrqLine = -1;
+	                clk_put(device->clk_3d_core);
+	                device->clk_3d_core = NULL;
+	                device->clk_3d_shader = NULL;
+	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
+	            }
+#endif
         } else {
             IrqLine = -1;
             device->clk_3d_core = NULL;
@@ -415,7 +411,7 @@ gckGALDEVICE_Construct(
         }
     }
     if ((IrqLine2D != -1) || (IrqLineVG != -1)) {
-        device->clk_2d_core = clk_get(NULL, "gpu2d_clk");
+        device->clk_2d_core = clk_get(pdev, "gpu2d_clk");
         if (IS_ERR(device->clk_2d_core)) {
             IrqLine2D = -1;
             IrqLineVG = -1;
@@ -423,7 +419,7 @@ gckGALDEVICE_Construct(
             gckOS_Print("galcore: clk_get 2d core clock failed, disable 2d/vg!\n");
         } else {
 	    if (IrqLine2D != -1) {
-                device->clk_2d_axi = clk_get(NULL, "gpu2d_axi_clk");
+                device->clk_2d_axi = clk_get(pdev, "gpu2d_axi_clk");
                 if (IS_ERR(device->clk_2d_axi)) {
                     device->clk_2d_axi = NULL;
                     IrqLine2D = -1;
@@ -431,7 +427,7 @@ gckGALDEVICE_Construct(
                 }
             }
             if (IrqLineVG != -1) {
-                device->clk_vg_axi = clk_get(NULL, "openvg_axi_clk");
+                device->clk_vg_axi = clk_get(pdev, "openvg_axi_clk");
                 if (IS_ERR(device->clk_vg_axi)) {
                     IrqLineVG = -1;
 	                device->clk_vg_axi = NULL;
@@ -463,7 +459,7 @@ gckGALDEVICE_Construct(
     device->requestedContiguousSize  = 0;
 
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         physical = device->requestedRegisterMemBases[i];
 
@@ -641,19 +637,22 @@ gckGALDEVICE_Construct(
     device->irqLines[gcvCORE_VG]    = IrqLineVG;
 
     /* Initialize the kernel thread semaphores. */
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (device->irqLines[i] != -1) sema_init(&device->semas[i], 0);
     }
 
     device->signal = Signal;
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (device->kernels[i] != gcvNULL) break;
     }
 
-    if (i == gcdCORE_COUNT) gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    if (i == gcdMAX_GPU_COUNT)
+	{
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
 
 #if gcdENABLE_VG
     if (i == gcvCORE_VG)
@@ -692,6 +691,16 @@ gckGALDEVICE_Construct(
     }
 
 
+    /* Grab the first availiable kernel */
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+    {
+        if (device->irqLines[i] != -1)
+        {
+            kernel = device->kernels[i];
+            break;
+        }
+    }
+
     /* Set up the internal memory region. */
     if (device->internalSize > 0)
     {
@@ -717,7 +726,8 @@ gckGALDEVICE_Construct(
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
 
-            device->internalPhysical = (gctPHYS_ADDR) physical;
+            device->internalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->internalPhysicalName = gcmPTR_TO_NAME(device->internalPhysical);
             physical += device->internalSize;
         }
     }
@@ -747,7 +757,8 @@ gckGALDEVICE_Construct(
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
 
-            device->externalPhysical = (gctPHYS_ADDR) physical;
+            device->externalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->externalPhysicalName = gcmPTR_TO_NAME(device->externalPhysical);
             physical += device->externalSize;
         }
     }
@@ -772,6 +783,7 @@ gckGALDEVICE_Construct(
 
                 if (gcmIS_SUCCESS(status))
                 {
+                    device->contiguousPhysicalName = gcmPTR_TO_NAME(device->contiguousPhysical);
                     status = gckVIDMEM_Construct(
                         device->os,
                         physAddr | device->systemMemoryBaseAddress,
@@ -792,6 +804,7 @@ gckGALDEVICE_Construct(
                         device->contiguousPhysical
                         ));
 
+                    gcmRELEASE_NAME(device->contiguousPhysicalName);
                     device->contiguousBase     = gcvNULL;
                     device->contiguousPhysical = gcvNULL;
                 }
@@ -811,8 +824,8 @@ gckGALDEVICE_Construct(
             /* Create the contiguous memory heap. */
             status = gckVIDMEM_Construct(
                 device->os,
-                (ContiguousBase - device->baseAddress) | device->systemMemoryBaseAddress,
-                 ContiguousSize,
+                ContiguousBase | device->systemMemoryBaseAddress,
+                ContiguousSize,
                 64, BankSize,
                 &device->contiguousVidMem
                 );
@@ -863,7 +876,8 @@ gckGALDEVICE_Construct(
                 }
 #endif
 
-                device->contiguousPhysical = (gctPHYS_ADDR) ContiguousBase;
+                device->contiguousPhysical = gcvNULL;
+                device->contiguousPhysicalName = 0;
                 device->contiguousSize     = ContiguousSize;
                 device->contiguousMapped   = gcvTRUE;
             }
@@ -908,12 +922,39 @@ gckGALDEVICE_Destroy(
 {
     gctINT i;
     gceSTATUS status = gcvSTATUS_OK;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("Device=0x%x", Device);
 
     if (Device != gcvNULL)
     {
-        for (i = 0; i < gcdCORE_COUNT; i++)
+        /* Grab the first availiable kernel */
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+        {
+            if (Device->irqLines[i] != -1)
+            {
+                kernel = Device->kernels[i];
+                break;
+            }
+        }
+        if (Device->internalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->internalPhysicalName);
+            Device->internalPhysicalName = 0;
+        }
+        if (Device->externalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->externalPhysicalName);
+            Device->externalPhysicalName = 0;
+        }
+        if (Device->contiguousPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->contiguousPhysicalName);
+            Device->contiguousPhysicalName = 0;
+        }
+
+
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (Device->kernels[i] != gcvNULL)
             {
@@ -996,7 +1037,16 @@ gckGALDEVICE_Destroy(
             }
         }
 
-        for (i = 0; i < gcdCORE_COUNT; i++)
+	{
+	    if(gckDebugFileSystemIsEnabled())
+	    {
+		 gckDebugFileSystemFreeNode(Device->dbgnode);
+		 kfree(Device->dbgnode);
+		 Device->dbgnode = gcvNULL;
+	    }
+	}
+
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (Device->registerBases[i] != gcvNULL)
             {
@@ -1014,6 +1064,12 @@ gckGALDEVICE_Destroy(
         }
 
         /*Disable clock*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+        if (Device->clk_3d_axi) {
+           clk_put(Device->clk_3d_axi);
+           Device->clk_3d_axi = NULL;
+        }
+#endif
         if (Device->clk_3d_core) {
            clk_put(Device->clk_3d_core);
            Device->clk_3d_core = NULL;
@@ -1035,7 +1091,19 @@ gckGALDEVICE_Destroy(
            Device->clk_vg_axi = NULL;
         }
 
+#ifdef CONFIG_PM
+        if(Device->pmdev)
+            pm_runtime_disable(Device->pmdev);
+#endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+        /*NULL*/
+#else
+        if (Device->gpu_regulator) {
+           regulator_put(Device->gpu_regulator);
+           Device->gpu_regulator = NULL;
+        }
+#endif
 
         /* Destroy the gckOS object. */
         if (Device->os != gcvNULL)
@@ -1398,25 +1466,6 @@ gckGALDEVICE_Start_Threads(
 
         Device->threadCtxts[gcvCORE_MAJOR]          = task;
         Device->threadInitializeds[gcvCORE_MAJOR]   = gcvTRUE;
-
-#if gcdPOWEROFF_TIMEOUT
-        /* Start the kernel thread. */
-        task = kthread_run(threadRoutinePM, Device, "galcore pm thread");
-
-        if (IS_ERR(task))
-        {
-            gcmkTRACE_ZONE(
-                gcvLEVEL_ERROR, gcvZONE_DRIVER,
-                "%s(%d): Could not start the kernel thread.\n",
-                __FUNCTION__, __LINE__
-                );
-
-            gcmkONERROR(gcvSTATUS_GENERIC_IO);
-        }
-
-        Device->pmThreadCtxts[gcvCORE_MAJOR]          = task;
-        Device->pmThreadInitializeds[gcvCORE_MAJOR]   = gcvTRUE;
-#endif
     }
 
     if (Device->kernels[gcvCORE_2D] != gcvNULL)
@@ -1437,25 +1486,6 @@ gckGALDEVICE_Start_Threads(
 
         Device->threadCtxts[gcvCORE_2D]         = task;
         Device->threadInitializeds[gcvCORE_2D]  = gcvTRUE;
-
-#if gcdPOWEROFF_TIMEOUT
-        /* Start the kernel thread. */
-        task = kthread_run(threadRoutinePM_2D, Device, "galcore pm 2d thread");
-
-        if (IS_ERR(task))
-        {
-            gcmkTRACE_ZONE(
-                gcvLEVEL_ERROR, gcvZONE_DRIVER,
-                "%s(%d): Could not start the kernel thread.\n",
-                __FUNCTION__, __LINE__
-                );
-
-            gcmkONERROR(gcvSTATUS_GENERIC_IO);
-        }
-
-        Device->pmThreadCtxts[gcvCORE_2D]          = task;
-        Device->pmThreadInitializeds[gcvCORE_2D]   = gcvTRUE;
-#endif
     }
     else
     {
@@ -1525,7 +1555,7 @@ gckGALDEVICE_Stop_Threads(
 
     gcmkVERIFY_ARGUMENT(Device != NULL);
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         /* Stop the kernel threads. */
         if (Device->threadInitializeds[i])
@@ -1537,20 +1567,6 @@ gckGALDEVICE_Stop_Threads(
             Device->threadCtxts[i]        = gcvNULL;
             Device->threadInitializeds[i] = gcvFALSE;
         }
-
-#if gcdPOWEROFF_TIMEOUT
-        /* Stop the kernel threads. */
-        if (Device->pmThreadInitializeds[i])
-        {
-            gckHARDWARE hardware = Device->kernels[i]->hardware;
-            Device->killThread = gcvTRUE;
-            gckOS_Signal(Device->os, hardware->powerOffSignal, gcvTRUE);
-
-            kthread_stop(Device->pmThreadCtxts[i]);
-            Device->pmThreadCtxts[i]        = gcvNULL;
-            Device->pmThreadInitializeds[i] = gcvFALSE;
-        }
-#endif
     }
 
     gcmkFOOTER_NO();
@@ -1616,6 +1632,11 @@ gckGALDEVICE_Start(
     {
         /* Setup the ISR routine. */
         gcmkONERROR(gckGALDEVICE_Setup_ISR_VG(Device));
+
+        /* Switch to SUSPEND power state. */
+        gcmkONERROR(gckVGHARDWARE_SetPowerManagementState(
+            Device->kernels[gcvCORE_VG]->vg->hardware, gcvPOWER_OFF_BROADCAST
+            ));
     }
 
     gcmkFOOTER_NO();
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index 5bbbd66..460f022 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,17 +19,9 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_device_h_
 #define __gc_hal_kernel_device_h_
 
-#ifdef ANDROID
-#define gcdkREPORT_VIDMEM_LEAK      0
-#else
-#define gcdkREPORT_VIDMEM_LEAK      1
-#endif
-
 /******************************************************************************\
 ******************************* gckGALDEVICE Structure *******************************
 \******************************************************************************/
@@ -38,42 +30,45 @@ typedef struct _gckGALDEVICE
 {
     /* Objects. */
     gckOS               os;
-    gckKERNEL           kernels[gcdCORE_COUNT];
+    gckKERNEL           kernels[gcdMAX_GPU_COUNT];
 
     /* Attributes. */
     gctSIZE_T           internalSize;
     gctPHYS_ADDR        internalPhysical;
+    gctUINT32           internalPhysicalName;
     gctPOINTER          internalLogical;
     gckVIDMEM           internalVidMem;
     gctSIZE_T           externalSize;
     gctPHYS_ADDR        externalPhysical;
+    gctUINT32           externalPhysicalName;
     gctPOINTER          externalLogical;
     gckVIDMEM           externalVidMem;
     gckVIDMEM           contiguousVidMem;
     gctPOINTER          contiguousBase;
     gctPHYS_ADDR        contiguousPhysical;
+    gctUINT32           contiguousPhysicalName;
     gctSIZE_T           contiguousSize;
     gctBOOL             contiguousMapped;
     gctPOINTER          contiguousMappedUser;
     gctSIZE_T           systemMemorySize;
     gctUINT32           systemMemoryBaseAddress;
-    gctPOINTER          registerBases[gcdCORE_COUNT];
-    gctSIZE_T           registerSizes[gcdCORE_COUNT];
+    gctPOINTER          registerBases[gcdMAX_GPU_COUNT];
+    gctSIZE_T           registerSizes[gcdMAX_GPU_COUNT];
     gctUINT32           baseAddress;
-    gctUINT32           requestedRegisterMemBases[gcdCORE_COUNT];
-    gctSIZE_T           requestedRegisterMemSizes[gcdCORE_COUNT];
+    gctUINT32           requestedRegisterMemBases[gcdMAX_GPU_COUNT];
+    gctSIZE_T           requestedRegisterMemSizes[gcdMAX_GPU_COUNT];
     gctUINT32           requestedContiguousBase;
     gctSIZE_T           requestedContiguousSize;
 
     /* IRQ management. */
-    gctINT              irqLines[gcdCORE_COUNT];
-    gctBOOL             isrInitializeds[gcdCORE_COUNT];
-    gctBOOL             dataReadys[gcdCORE_COUNT];
+    gctINT              irqLines[gcdMAX_GPU_COUNT];
+    gctBOOL             isrInitializeds[gcdMAX_GPU_COUNT];
+    gctBOOL             dataReadys[gcdMAX_GPU_COUNT];
 
     /* Thread management. */
-    struct task_struct  *threadCtxts[gcdCORE_COUNT];
-    struct semaphore    semas[gcdCORE_COUNT];
-    gctBOOL             threadInitializeds[gcdCORE_COUNT];
+    struct task_struct  *threadCtxts[gcdMAX_GPU_COUNT];
+    struct semaphore    semas[gcdMAX_GPU_COUNT];
+    gctBOOL             threadInitializeds[gcdMAX_GPU_COUNT];
     gctBOOL             killThread;
 
     /* Signal management. */
@@ -83,19 +78,24 @@ typedef struct _gckGALDEVICE
     gceCORE             coreMapping[8];
 
     /* States before suspend. */
-    gceCHIPPOWERSTATE   statesStored[gcdCORE_COUNT];
+    gceCHIPPOWERSTATE   statesStored[gcdMAX_GPU_COUNT];
+
+    /*Device Debug File System Entry in Kernel*/
+   struct _gcsDebugFileSystemNode * dbgnode;
 
     /* Clock management.*/
     struct clk         *clk_3d_core;
     struct clk         *clk_3d_shader;
+    struct clk		   *clk_3d_axi;
     struct clk         *clk_2d_core;
     struct clk         *clk_2d_axi;
     struct clk         *clk_vg_axi;
 
-#if gcdPOWEROFF_TIMEOUT
-    struct task_struct  *pmThreadCtxts[gcdCORE_COUNT];
-    gctBOOL             pmThreadInitializeds[gcdCORE_COUNT];
-#endif
+    /*Power management.*/
+    struct regulator      *gpu_regulator;
+
+	/*Run time pm*/
+	struct device		*pmdev;
 }
 * gckGALDEVICE;
 
@@ -167,6 +167,8 @@ gceSTATUS gckGALDEVICE_Construct(
     IN gctUINT32 PhysBaseAddr,
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
+    IN gctUINT LogFileSize,
+    IN struct device *pdev,
     OUT gckGALDEVICE *Device
     );
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index 30e6a30..4e3819c 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *    Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
 *
 *    This program is free software; you can redistribute it and/or modify
@@ -20,12 +20,9 @@
 *****************************************************************************/
 
 
-
-
 #include <linux/device.h>
 #include <linux/slab.h>
-#include <mach/viv_gpu.h>
-
+#include <linux/notifier.h>
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_driver.h"
 
@@ -39,9 +36,49 @@
 #endif
 
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#    include <linux/resmem_account.h>
+#    include <linux/kernel.h>
+#    include <linux/mm.h>
+#    include <linux/oom.h>
+#    include <linux/sched.h>
+#    include <linux/notifier.h>
+
+struct task_struct *lowmem_deathpending;
+
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data);
+
+static struct notifier_block task_nb = {
+	.notifier_call	= task_notify_func,
+};
+
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data)
+{
+	struct task_struct *task = data;
+
+	if (task == lowmem_deathpending)
+		lowmem_deathpending = NULL;
+
+	return NOTIFY_OK;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+#include <mach/viv_gpu.h>
+#else
+#include <linux/pm_runtime.h>
+#include <mach/busfreq.h>
+#endif
 /* Zone used for header/footer. */
 #define _GC_OBJ_ZONE    gcvZONE_DRIVER
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+extern int register_thermal_notifier(struct notifier_block *nb);
+extern int unregister_thermal_notifier(struct notifier_block *nb);
+#endif
+
 MODULE_DESCRIPTION("Vivante Graphics Driver");
 MODULE_LICENSE("GPL");
 
@@ -49,44 +86,44 @@ static struct class* gpuClass;
 
 static gckGALDEVICE galDevice;
 
-static int major = 199;
-module_param(major, int, 0644);
+static uint major = 199;
+module_param(major, uint, 0644);
 
 static int irqLine = -1;
 module_param(irqLine, int, 0644);
 
-static long registerMemBase = 0x80000000;
-module_param(registerMemBase, long, 0644);
+static ulong registerMemBase = 0x80000000;
+module_param(registerMemBase, ulong, 0644);
 
-static ulong registerMemSize = 256 << 10;
+static ulong registerMemSize = 2 << 10;
 module_param(registerMemSize, ulong, 0644);
 
 static int irqLine2D = -1;
 module_param(irqLine2D, int, 0644);
 
-static long registerMemBase2D = 0x00000000;
-module_param(registerMemBase2D, long, 0644);
+static ulong registerMemBase2D = 0x00000000;
+module_param(registerMemBase2D, ulong, 0644);
 
-static ulong registerMemSize2D = 256 << 10;
+static ulong registerMemSize2D = 2 << 10;
 module_param(registerMemSize2D, ulong, 0644);
 
 static int irqLineVG = -1;
 module_param(irqLineVG, int, 0644);
 
-static long registerMemBaseVG = 0x00000000;
-module_param(registerMemBaseVG, long, 0644);
+static ulong registerMemBaseVG = 0x00000000;
+module_param(registerMemBaseVG, ulong, 0644);
 
-static ulong registerMemSizeVG = 256 << 10;
+static ulong registerMemSizeVG = 2 << 10;
 module_param(registerMemSizeVG, ulong, 0644);
 
-static long contiguousSize = 4 << 20;
-module_param(contiguousSize, long, 0644);
+static ulong contiguousSize = 4 << 20;
+module_param(contiguousSize, ulong, 0644);
 
 static ulong contiguousBase = 0;
 module_param(contiguousBase, ulong, 0644);
 
-static long bankSize = 32 << 20;
-module_param(bankSize, long, 0644);
+static ulong bankSize = 0;
+module_param(bankSize, ulong, 0644);
 
 static int fastClear = -1;
 module_param(fastClear, int, 0644);
@@ -103,6 +140,9 @@ module_param(baseAddress, ulong, 0644);
 static ulong physSize = 0;
 module_param(physSize, ulong, 0644);
 
+static uint logFileSize=0;
+module_param(logFileSize,uint, 0644);
+
 static int showArgs = 0;
 module_param(showArgs, int, 0644);
 
@@ -134,12 +174,40 @@ static int drv_mmap(
 
 static struct file_operations driver_fops =
 {
+    .owner      = THIS_MODULE,
     .open       = drv_open,
     .release    = drv_release,
     .unlocked_ioctl = drv_ioctl,
+#ifdef HAVE_COMPAT_IOCTL
+    .compat_ioctl = drv_ioctl,
+#endif
     .mmap       = drv_mmap,
 };
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+static size_t viv_gpu_resmem_query(struct task_struct *p, struct reserved_memory_account *m);
+static struct reserved_memory_account viv_gpu_resmem_handler = {
+    .name = "viv_gpu",
+    .get_page_used_by_process = viv_gpu_resmem_query,
+};
+
+size_t viv_gpu_resmem_query(struct task_struct *p, struct reserved_memory_account *m)
+{
+    gcuDATABASE_INFO info;
+    unsigned int processid = p->pid;
+    gckKERNEL gpukernel = m->data;
+
+    /* ignore error happens in this api. */
+    if (gckKERNEL_QueryProcessDB(gpukernel, processid, false, gcvDB_VIDEO_MEMORY, &info) != gcvSTATUS_OK)
+	return 0;
+
+    /* we return pages. */
+    if (info.counters.bytes > 0)
+	return info.counters.bytes / PAGE_SIZE;
+    return 0;
+}
+#endif
+
 int drv_open(
     struct inode* inode,
     struct file* filp
@@ -182,7 +250,7 @@ int drv_open(
     gcmkONERROR(gckOS_GetProcessID(&data->pidOpen));
 
     /* Attached the process. */
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (galDevice->kernels[i] != gcvNULL)
         {
@@ -199,20 +267,6 @@ int drv_open(
             galDevice->contiguousSize,
             &data->contiguousLogical
             ));
-
-        for (i = 0; i < gcdCORE_COUNT; i++)
-        {
-            if (galDevice->kernels[i] != gcvNULL)
-            {
-                gcmkVERIFY_OK(gckKERNEL_AddProcessDB(
-                    galDevice->kernels[i],
-                    data->pidOpen,
-                    gcvDB_MAP_MEMORY,
-                    data->contiguousLogical,
-                    galDevice->contiguousPhysical,
-                    galDevice->contiguousSize));
-            }
-        }
     }
 
     filp->private_data = data;
@@ -239,7 +293,7 @@ OnError:
 
     if (attached)
     {
-        for (i = 0; i < gcdCORE_COUNT; i++)
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (galDevice->kernels[i] != gcvNULL)
             {
@@ -261,8 +315,6 @@ int drv_release(
     gcsHAL_PRIVATE_DATA_PTR data;
     gckGALDEVICE device;
     gctINT i;
-    gctUINT32 processID;
-
 
     gcmkHEADER_ARG("inode=0x%08X filp=0x%08X", inode, filp);
 
@@ -307,7 +359,6 @@ int drv_release(
     {
         if (data->contiguousLogical != gcvNULL)
         {
-            gcmkVERIFY_OK(gckOS_GetProcessID(&processID));
             gcmkONERROR(gckOS_UnmapMemoryEx(
                 galDevice->os,
                 galDevice->contiguousPhysical,
@@ -316,27 +367,12 @@ int drv_release(
                 data->pidOpen
                 ));
 
-            for (i = 0; i < gcdCORE_COUNT; i++)
-            {
-                if (galDevice->kernels[i] != gcvNULL)
-                {
-                    gcmkVERIFY_OK(
-                         gckKERNEL_RemoveProcessDB(galDevice->kernels[i],
-                                                   processID, gcvDB_MAP_MEMORY,
-                                                   data->contiguousLogical));
-                }
-            }
-
             data->contiguousLogical = gcvNULL;
         }
     }
 
-    /* Clean user signals if exit unnormally. */
-    gcmkVERIFY_OK(gckOS_GetProcessID(&processID));
-    gcmkVERIFY_OK(gckOS_CleanProcessSignal(galDevice->os, (gctHANDLE)processID));
-
     /* A process gets detached. */
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (galDevice->kernels[i] != gcvNULL)
         {
@@ -457,7 +493,7 @@ long drv_ioctl(
     }
 
     copyLen = copy_from_user(
-        &iface, drvArgs.InputBuffer, sizeof(gcsHAL_INTERFACE)
+        &iface, gcmUINT64_TO_PTR(drvArgs.InputBuffer), sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -474,7 +510,7 @@ long drv_ioctl(
     if (iface.command == gcvHAL_CHIP_INFO)
     {
         count = 0;
-        for (i = 0; i < gcdCORE_COUNT; i++)
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (device->kernels[i] != gcvNULL)
             {
@@ -494,7 +530,7 @@ long drv_ioctl(
         }
 
         iface.u.ChipInfo.count = count;
-        status = gcvSTATUS_OK;
+        iface.status = status = gcvSTATUS_OK;
     }
     else
     {
@@ -535,25 +571,26 @@ long drv_ioctl(
 
     if (gcmIS_SUCCESS(status) && (iface.command == gcvHAL_LOCK_VIDEO_MEMORY))
     {
+        gcuVIDMEM_NODE_PTR node = gcmUINT64_TO_PTR(iface.u.LockVideoMemory.node);
         /* Special case for mapped memory. */
         if ((data->mappedMemory != gcvNULL)
-        &&  (iface.u.LockVideoMemory.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        &&  (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         )
         {
             /* Compute offset into mapped memory. */
             gctUINT32 offset
-                = (gctUINT8 *) iface.u.LockVideoMemory.memory
+                = (gctUINT8 *) gcmUINT64_TO_PTR(iface.u.LockVideoMemory.memory)
                 - (gctUINT8 *) device->contiguousBase;
 
             /* Compute offset into user-mapped region. */
             iface.u.LockVideoMemory.memory =
-                (gctUINT8 *) data->mappedMemory + offset;
+                gcmPTR_TO_UINT64((gctUINT8 *) data->mappedMemory + offset);
         }
     }
 
     /* Copy data back to the user. */
     copyLen = copy_to_user(
-        drvArgs.OutputBuffer, &iface, sizeof(gcsHAL_INTERFACE)
+        gcmUINT64_TO_PTR(drvArgs.OutputBuffer), &iface, sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -581,7 +618,7 @@ static int drv_mmap(
     struct vm_area_struct* vma
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gcsHAL_PRIVATE_DATA_PTR data;
     gckGALDEVICE device;
 
@@ -633,11 +670,23 @@ static int drv_mmap(
     if (device->contiguousMapped)
     {
         unsigned long size = vma->vm_end - vma->vm_start;
+        int ret = 0;
+
+        if (size > device->contiguousSize)
+        {
+            gcmkTRACE_ZONE(
+                gcvLEVEL_ERROR, gcvZONE_DRIVER,
+                "%s(%d): Invalid mapping size.\n",
+                __FUNCTION__, __LINE__
+                );
 
-        int ret = io_remap_pfn_range(
+            gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        }
+
+        ret = io_remap_pfn_range(
             vma,
             vma->vm_start,
-            (gctUINT32) device->contiguousPhysical >> PAGE_SHIFT,
+            device->requestedContiguousBase >> PAGE_SHIFT,
             size,
             vma->vm_page_prot
             );
@@ -657,11 +706,12 @@ static int drv_mmap(
         }
 
         data->mappedMemory = (gctPOINTER) vma->vm_start;
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return 0;
     }
 
-    /* Success. */
-    gcmkFOOTER_NO();
-    return 0;
 
 OnError:
     gcmkFOOTER();
@@ -672,7 +722,7 @@ OnError:
 #if !USE_PLATFORM_DRIVER
 static int __init drv_init(void)
 #else
-static int drv_init(void)
+static int drv_init(struct device *pdev)
 #endif
 {
     int ret;
@@ -757,11 +807,17 @@ static int drv_init(void)
         printk("  signal            = %d\n",      signal);
         printk("  baseAddress       = 0x%08lX\n", baseAddress);
         printk("  physSize          = 0x%08lX\n", physSize);
+	printk(" logFileSize         = %d KB \n",     logFileSize);
 #if ENABLE_GPU_CLOCK_BY_DRIVER
         printk("  coreClock       = %lu\n",     coreClock);
 #endif
     }
 
+    if(logFileSize != 0)
+    {
+    	gckDebugFileSystemInitialize();
+    }
+
     /* Create the GAL device. */
     gcmkONERROR(gckGALDEVICE_Construct(
         irqLine,
@@ -772,6 +828,8 @@ static int drv_init(void)
         registerMemBaseVG, registerMemSizeVG,
         contiguousBase, contiguousSize,
         bankSize, fastClear, compression, baseAddress, physSize, signal,
+        logFileSize,
+        pdev,
         &device
         ));
 
@@ -798,6 +856,13 @@ static int drv_init(void)
         device->baseAddress = 0;
     }
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_register(&task_nb);
+    viv_gpu_resmem_handler.data = device->kernels[gcvCORE_MAJOR];
+    register_reserved_memory_account(&viv_gpu_resmem_handler);
+#endif
+
+
     /* Register the character device. */
     ret = register_chrdev(major, DRV_NAME, &driver_fops);
 
@@ -877,6 +942,11 @@ static void drv_exit(void)
 {
     gcmkHEADER();
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_unregister(&task_nb);
+    unregister_reserved_memory_account(&viv_gpu_resmem_handler);
+#endif
+
     gcmkASSERT(gpuClass != gcvNULL);
     device_destroy(gpuClass, MKDEV(major, 0));
     class_destroy(gpuClass);
@@ -886,6 +956,11 @@ static void drv_exit(void)
     gcmkVERIFY_OK(gckGALDEVICE_Stop(galDevice));
     gcmkVERIFY_OK(gckGALDEVICE_Destroy(galDevice));
 
+   if(gckDebugFileSystemIsEnabled())
+   {
+   	 gckDebugFileSystemTerminate();
+   }
+
 #if ENABLE_GPU_CLOCK_BY_DRIVER && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
     {
 # if 0
@@ -914,14 +989,50 @@ static void drv_exit(void)
 #   define DEVICE_NAME "galcore"
 #endif
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+static int thermal_hot_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+    static gctUINT orgFscale, minFscale, maxFscale;
+    static gctBOOL bAlreadyTooHot = gcvFALSE;
+    gckHARDWARE hardware = galDevice->kernels[gcvCORE_MAJOR]->hardware;
+
+    if (event && !bAlreadyTooHot) {
+        gckHARDWARE_GetFscaleValue(hardware,&orgFscale,&minFscale, &maxFscale);
+        gckHARDWARE_SetFscaleValue(hardware, minFscale);
+        bAlreadyTooHot = gcvTRUE;
+        gckOS_Print("System is too hot. GPU3D will work at %d/64 clock.\n", minFscale);
+    } else if (!event && bAlreadyTooHot) {
+        gckHARDWARE_SetFscaleValue(hardware, orgFscale);
+        gckOS_Print("Hot alarm is canceled. GPU3D clock will return to %d/64\n", orgFscale);
+        bAlreadyTooHot = gcvFALSE;
+    }
+    return NOTIFY_OK;
+}
+
+static struct notifier_block thermal_hot_pm_notifier = {
+    .notifier_call = thermal_hot_pm_notify,
+    };
+#endif
+
+
+
 static int __devinit gpu_probe(struct platform_device *pdev)
 {
     int ret = -ENODEV;
     struct resource* res;
-    struct viv_gpu_platform_data *pdata;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	struct device_node *dn =pdev->dev.of_node;
+	const u32 *prop;
+#else
+	struct viv_gpu_platform_data *pdata;
+#endif
     gcmkHEADER();
 
+    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phys_baseaddr");
+    if (res)
+        baseAddress = res->start;
+
     res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "irq_3d");
     if (res)
         irqLine = res->start;
@@ -955,22 +1066,36 @@ static int __devinit gpu_probe(struct platform_device *pdev)
         registerMemSizeVG = res->end - res->start + 1;
     }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	prop = of_get_property(dn, "contiguousbase", NULL);
+	if(prop)
+		contiguousBase = *prop;
+	of_property_read_u32(dn,"contiguoussize", (u32 *)&contiguousSize);
+#else
     pdata = pdev->dev.platform_data;
     if (pdata) {
         contiguousBase = pdata->reserved_mem_base;
         contiguousSize = pdata->reserved_mem_size;
      }
-
-    ret = drv_init();
+#endif
+    if (contiguousSize == 0)
+       gckOS_Print("Warning: No contiguous memory is reserverd for gpu.!\n ");
+    ret = drv_init(&pdev->dev);
 
     if (!ret)
     {
         platform_set_drvdata(pdev, galDevice);
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+        if(galDevice->kernels[gcvCORE_MAJOR])
+            register_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
         gcmkFOOTER_NO();
         return ret;
     }
-
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     gcmkFOOTER_ARG(KERN_INFO "Failed to register gpu driver: %d\n", ret);
     return ret;
 }
@@ -978,6 +1103,10 @@ static int __devinit gpu_probe(struct platform_device *pdev)
 static int __devinit gpu_remove(struct platform_device *pdev)
 {
     gcmkHEADER();
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    if(galDevice->kernels[gcvCORE_MAJOR])
+        unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     drv_exit();
     gcmkFOOTER_NO();
     return 0;
@@ -991,7 +1120,7 @@ static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state
 
     device = platform_get_drvdata(dev);
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (device->kernels[i] != gcvNULL)
         {
@@ -1022,8 +1151,6 @@ static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state
             {
                 status = gckHARDWARE_SetPowerManagementState(device->kernels[i]->hardware, gcvPOWER_OFF);
             }
-            /*gpu clock must be turned on before power down*/
-            gckOS_SetGPUPower(device->os, i, gcvTRUE, gcvFALSE);
             if (gcmIS_ERROR(status))
             {
                 return -1;
@@ -1044,7 +1171,7 @@ static int __devinit gpu_resume(struct platform_device *dev)
 
     device = platform_get_drvdata(dev);
 
-    for (i = 0; i < gcdCORE_COUNT; i++)
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (device->kernels[i] != gcvNULL)
         {
@@ -1106,6 +1233,32 @@ static int __devinit gpu_resume(struct platform_device *dev)
     return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+static const struct of_device_id mxs_gpu_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-gpu", },
+	{/* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, mxs_gpu_dt_ids);
+
+#ifdef CONFIG_PM
+int gpu_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+int gpu_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static const struct dev_pm_ops gpu_pm_ops = {
+	SET_RUNTIME_PM_OPS(gpu_runtime_suspend, gpu_runtime_resume, NULL)
+};
+#endif
+#endif
+
 static struct platform_driver gpu_driver = {
     .probe      = gpu_probe,
     .remove     = gpu_remove,
@@ -1115,6 +1268,12 @@ static struct platform_driver gpu_driver = {
 
     .driver     = {
         .name   = DEVICE_NAME,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+		.of_match_table = mxs_gpu_dt_ids,
+#if CONFIG_PM
+		.pm		= &gpu_pm_ops,
+#endif
+#endif
     }
 };
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
index cba2040..22c4071 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -65,15 +63,15 @@ gckKERNEL_QueryVideoMemory(
 
     /* Get internal memory size and physical address. */
     Interface->u.QueryVideoMemory.internalSize = device->internalSize;
-    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysical;
+    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysicalName;
 
     /* Get external memory size and physical address. */
     Interface->u.QueryVideoMemory.externalSize = device->externalSize;
-    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysical;
+    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysicalName;
 
     /* Get contiguous memory size and physical address. */
     Interface->u.QueryVideoMemory.contiguousSize = device->contiguousSize;
-    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysical;
+    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysicalName;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -181,7 +179,10 @@ gckKERNEL_MapMemory(
     OUT gctPOINTER * Logical
     )
 {
-    return gckOS_MapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_MapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
@@ -216,7 +217,10 @@ gckKERNEL_UnmapMemory(
     IN gctPOINTER Logical
     )
 {
-    return gckOS_UnmapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_UnmapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index 6b69f0c..9c0bcd5 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_linux_h_
 #define __gc_hal_kernel_linux_h_
 
@@ -47,6 +45,7 @@
 
 #if ENABLE_GPU_CLOCK_BY_DRIVER && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
 #include <linux/clk.h>
+#include <linux/regulator/consumer.h>
 #endif
 
 #define NTSTRSAFE_NO_CCH_FUNCTIONS
@@ -55,6 +54,7 @@
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_device.h"
 #include "gc_hal_kernel_os.h"
+#include "gc_hal_kernel_debugfs.h"
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
 #define FIND_TASK_BY_PID(x) pid_task(find_vpid(x), PIDTYPE_PID)
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
index a4cb717..992aeff 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 gctINT
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 857fc85..c07ded8 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #include <linux/pagemap.h>
@@ -33,9 +31,17 @@
 #include <linux/slab.h>
 #include <linux/idr.h>
 #include <mach/hardware.h>
+#include <linux/workqueue.h>
+#include <linux/idr.h>
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
 #include <linux/math64.h>
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#include <mach/common.h>
+#endif
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
@@ -160,6 +166,7 @@ struct _gckOS
     gctUINT32                   kernelProcessID;
 
     /* Signal management. */
+
     /* Lock. */
     gctPOINTER                  signalMutex;
 
@@ -174,6 +181,9 @@ struct _gckOS
     gcsNonPagedMemoryCache *     cacheHead;
     gcsNonPagedMemoryCache *     cacheTail;
 #endif
+
+    /* workqueue for os timer. */
+    struct workqueue_struct *   workqueue;
 };
 
 typedef struct _gcsSIGNAL * gcsSIGNAL_PTR;
@@ -191,9 +201,10 @@ typedef struct _gcsSIGNAL
     /* The owner of the signal. */
     gctHANDLE process;
 
+    gckHARDWARE hardware;
+
     /* ID. */
     gctUINT32 id;
-
 }
 gcsSIGNAL;
 
@@ -205,332 +216,18 @@ typedef struct _gcsPageInfo
 }
 gcsPageInfo;
 
-typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
-typedef struct _gcsiDEBUG_REGISTERS
+typedef struct _gcsOSTIMER * gcsOSTIMER_PTR;
+typedef struct _gcsOSTIMER
 {
-    gctSTRING       module;
-    gctUINT         index;
-    gctUINT         shift;
-    gctUINT         data;
-    gctUINT         count;
-    gctUINT32       signature;
-}
-gcsiDEBUG_REGISTERS;
-
+    struct delayed_work     work;
+    gctTIMERFUNCTION        function;
+    gctPOINTER              data;
+} gcsOSTIMER;
 
 /******************************************************************************\
 ******************************* Private Functions ******************************
 \******************************************************************************/
 
-static gceSTATUS
-_VerifyDMA(
-    IN gckOS Os,
-    IN gceCORE Core,
-    gctUINT32_PTR Address1,
-    gctUINT32_PTR Address2,
-    gctUINT32_PTR State1,
-    gctUINT32_PTR State2
-    )
-{
-    gceSTATUS status;
-    gctUINT32 i;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
-
-        if (*Address1 != *Address2)
-        {
-            break;
-        }
-
-#if gcdDETECT_DMA_STATE
-        if (*State1 != *State2)
-        {
-            break;
-        }
-#endif
-    }
-
-OnError:
-    return status;
-}
-
-static gceSTATUS
-_DumpDebugRegisters(
-    IN gckOS Os,
-    IN gcsiDEBUG_REGISTERS_PTR Descriptor
-    )
-{
-    gceSTATUS status;
-    gctUINT32 select;
-    gctUINT32 data;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
-
-    gcmkPRINT_N(4, "  %s debug registers:\n", Descriptor->module);
-
-    select = 0xF << Descriptor->shift;
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        if (data == Descriptor->signature)
-        {
-            break;
-        }
-    }
-
-    if (i == 500)
-    {
-        gcmkPRINT_N(4, "    failed to obtain the signature (read 0x%08X).\n", data);
-    }
-    else
-    {
-        gcmkPRINT_N(8, "    signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
-    }
-
-    for (i = 0; i < Descriptor->count; i += 1)
-    {
-        select = i << Descriptor->shift;
-
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        gcmkPRINT_N(12, "    [0x%02X] 0x%08X\n", i, data);
-    }
-
-OnError:
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
-static gceSTATUS
-_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
-    )
-{
-    static gctCONST_STRING _cmdState[] =
-    {
-        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
-        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
-        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
-        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
-        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
-        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
-    };
-
-    static gctCONST_STRING _cmdDmaState[] =
-    {
-        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
-    };
-
-    static gctCONST_STRING _cmdFetState[] =
-    {
-        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
-    };
-
-    static gctCONST_STRING _reqDmaState[] =
-    {
-        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
-    };
-
-    static gctCONST_STRING _calState[] =
-    {
-        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
-    };
-
-    static gctCONST_STRING _veReqState[] =
-    {
-        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
-    };
-
-    static gcsiDEBUG_REGISTERS _dbgRegs[] =
-    {
-        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
-        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
-        { "FE", 0x470,  0, 0x450, 16, 0xBABEF00D },
-        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
-        { "DE", 0x470,  8, 0x458, 16, 0xBABEF00D },
-        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
-        { "PA", 0x474,  0, 0x460, 16, 0x0000AAAA },
-        { "SE", 0x474,  8, 0x464, 16, 0x5E5E5E5E },
-        { "MC", 0x478,  0, 0x468, 16, 0x12345678 },
-        { "HI", 0x478,  8, 0x46C, 16, 0xAAAAAAAA }
-    };
-
-    static gctUINT32 _otherRegs[] =
-    {
-        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
-        0x43c, 0x440, 0x444, 0x414,
-    };
-
-    gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
-    gckGALDEVICE device;
-    gckKERNEL kernel;
-    gctUINT32 idle, axi;
-    gctUINT32 dmaAddress1, dmaAddress2;
-    gctUINT32 dmaState1, dmaState2;
-    gctUINT32 dmaLow, dmaHigh;
-    gctUINT32 cmdState, cmdDmaState, cmdFetState;
-    gctUINT32 dmaReqState, calState, veReqState;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X, Core=%d", Os, Core);
-
-    gcmkONERROR(gckOS_AcquireMutex(Os, Os->debugLock, gcvINFINITE));
-    acquired = gcvTRUE;
-
-    /* Extract the pointer to the gckGALDEVICE class. */
-    device = (gckGALDEVICE) Os->device;
-
-    /* TODO: Kernel shortcut. */
-    kernel = device->kernels[Core];
-    gcmkPRINT_N(4, "Core = 0x%d\n",Core);
-
-    if (kernel == gcvNULL)
-    {
-        gcmkFOOTER();
-        return gcvSTATUS_OK;
-    }
-
-    /* Reset register values. */
-    idle        = axi         =
-    dmaState1   = dmaState2   =
-    dmaAddress1 = dmaAddress2 =
-    dmaLow      = dmaHigh     = 0;
-
-    /* Verify whether DMA is running. */
-    gcmkONERROR(_VerifyDMA(
-        Os, kernel->core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
-        ));
-
-    cmdState    =  dmaState2        & 0x1F;
-    cmdDmaState = (dmaState2 >>  8) & 0x03;
-    cmdFetState = (dmaState2 >> 10) & 0x03;
-    dmaReqState = (dmaState2 >> 12) & 0x03;
-    calState    = (dmaState2 >> 14) & 0x03;
-    veReqState  = (dmaState2 >> 16) & 0x03;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x004, &idle));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x00C, &axi));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x668, &dmaLow));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x66C, &dmaHigh));
-
-    gcmkPRINT_N(0, "**************************\n");
-    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
-    gcmkPRINT_N(0, "**************************\n");
-
-    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
-
-    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
-    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
-    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
-    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
-    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
-    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
-    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
-    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
-    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
-    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
-    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
-    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
-    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
-    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
-
-    if (
-        (dmaAddress1 == dmaAddress2)
-
-#if gcdDETECT_DMA_STATE
-     && (dmaState1 == dmaState2)
-#endif
-    )
-    {
-        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
-        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-    }
-    else
-    {
-        if (dmaAddress1 == dmaAddress2)
-        {
-            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
-        }
-        else
-        {
-            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
-        }
-    }
-
-    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
-    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
-    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
-    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState,    _cmdState   [cmdState]);
-    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
-    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
-    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
-    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState,    _calState   [calState]);
-    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState,  _veReqState [veReqState]);
-
-    for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
-    {
-        gcmkONERROR(_DumpDebugRegisters(Os, &_dbgRegs[i]));
-    }
-
-    if (kernel->hardware->identity.chipFeatures & (1 << 4))
-    {
-        gctUINT32 read0, read1, write;
-
-        read0 = read1 = write = 0;
-
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x43C, &read0));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x440, &read1));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x444, &write));
-
-        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
-        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
-        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
-    }
-
-    gcmkPRINT_N(0, "  Other Registers:\n");
-    for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
-    {
-        gctUINT32 read;
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, _otherRegs[i], &read));
-        gcmkPRINT_N(12, "    [0x%04X] 0x%08X\n", _otherRegs[i], read);
-    }
-
-OnError:
-    if (acquired)
-    {
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->debugLock));
-    }
-
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
 static gctINT
 _GetProcessID(
     void
@@ -564,7 +261,7 @@ _CreateMdl(
 
     gcmkHEADER_ARG("ProcessID=%d", ProcessID);
 
-    mdl = (PLINUX_MDL)kmalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | __GFP_NOWARN);
+    mdl = (PLINUX_MDL)kzalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | __GFP_NOWARN);
     if (mdl == gcvNULL)
     {
         gcmkFOOTER_NO();
@@ -1052,9 +749,9 @@ _FreeAllNonPagedMemoryCache(
 
 #endif /* gcdUSE_NON_PAGED_MEMORY_CACHE */
 
- /*******************************************************************************
-+** Integer Id Management.
-+*/
+/*******************************************************************************
+** Integer Id Management.
+*/
 gceSTATUS
 _AllocateIntegerId(
     IN gcsINTEGER_DB_PTR Database,
@@ -1097,7 +794,6 @@ _QueryIntegerId(
     OUT gctPOINTER * KernelPointer
     )
 {
-    gceSTATUS status;
     gctPOINTER pointer;
 
     spin_lock(&Database->lock);
@@ -1109,7 +805,7 @@ _QueryIntegerId(
     if(pointer)
     {
         *KernelPointer = pointer;
-        status = gcvSTATUS_OK;
+        return gcvSTATUS_OK;
     }
     else
     {
@@ -1118,10 +814,8 @@ _QueryIntegerId(
                 "%s(%d) Id = %d is not found",
                 __FUNCTION__, __LINE__, Id);
 
-        status = gcvSTATUS_NOT_FOUND;
+        return gcvSTATUS_NOT_FOUND;
     }
-
-    return status;
 }
 
 gceSTATUS
@@ -1139,6 +833,42 @@ _DestroyIntegerId(
     return gcvSTATUS_OK;
 }
 
+static void
+_UnmapUserLogical(
+    IN gctINT Pid,
+    IN gctPOINTER Logical,
+    IN gctUINT32  Size
+)
+{
+    if (unlikely(current->mm == gcvNULL))
+    {
+        /* Do nothing if process is exiting. */
+        return;
+    }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    if (vm_munmap((unsigned long)Logical, Size) < 0)
+    {
+        gcmkTRACE_ZONE(
+                gcvLEVEL_WARNING, gcvZONE_OS,
+                "%s(%d): vm_munmap failed",
+                __FUNCTION__, __LINE__
+                );
+    }
+#else
+    down_write(&current->mm->mmap_sem);
+    if (do_munmap(current->mm, (unsigned long)Logical, Size) < 0)
+    {
+        gcmkTRACE_ZONE(
+                gcvLEVEL_WARNING, gcvZONE_OS,
+                "%s(%d): do_munmap failed",
+                __FUNCTION__, __LINE__
+                );
+    }
+    up_write(&current->mm->mmap_sem);
+#endif
+}
+
 /*******************************************************************************
 **
 **  gckOS_Construct
@@ -1223,6 +953,15 @@ gckOS_Construct(
     os->cacheTail = gcvNULL;
 #endif
 
+    /* Create a workqueue for os timer. */
+    os->workqueue = create_singlethread_workqueue("galcore workqueue");
+
+    if (os->workqueue == gcvNULL)
+    {
+        /* Out of memory. */
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
     /* Return pointer to the gckOS object. */
     *Os = os;
 
@@ -1261,6 +1000,11 @@ OnError:
             gckOS_DeleteMutex(os, os->debugLock));
     }
 
+    if (os->workqueue != gcvNULL)
+    {
+        destroy_workqueue(os->workqueue);
+    }
+
     kfree(os);
 
     /* Return the error. */
@@ -1304,7 +1048,6 @@ gckOS_Destroy(
      */
 
     /* Destroy the mutex. */
-
     gcmkVERIFY_OK(gckOS_DeleteMutex(Os, Os->signalMutex));
 
     if (Os->heap != gcvNULL)
@@ -1324,6 +1067,12 @@ gckOS_Destroy(
     /* Destroy debug lock mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(Os, Os->debugLock));
 
+    /* Wait for all works done. */
+    flush_workqueue(Os->workqueue);
+
+    /* Destory work queue. */
+    destroy_workqueue(Os->workqueue);
+
     /* Flush the debug cache. */
     gcmkDEBUGFLUSH(~0U);
 
@@ -1338,39 +1087,60 @@ gckOS_Destroy(
     return gcvSTATUS_OK;
 }
 
-#ifdef NO_DMA_COHERENT
 static gctSTRING
 _CreateKernelVirtualMapping(
-    IN struct page * Page,
-    IN gctINT NumPages
+    IN PLINUX_MDL Mdl
     )
 {
     gctSTRING addr = 0;
+    gctINT numPages = Mdl->numPages;
 
 #if gcdNONPAGED_MEMORY_CACHEABLE
-    addr = page_address(Page);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+    if (Mdl->contiguous)
+    {
+        addr = page_address(Mdl->u.contiguousPages);
+    }
+    else
+    {
+        addr = vmap(Mdl->u.nonContiguousPages,
+                    numPages,
+                    0,
+                    PAGE_KERNEL);
+    }
+#else
     struct page ** pages;
+    gctBOOL free = gcvFALSE;
     gctINT i;
 
-    pages = kmalloc(sizeof(struct page *) * NumPages, GFP_KERNEL | __GFP_NOWARN);
-
-    if (!pages)
+    if (Mdl->contiguous)
     {
-        return gcvNULL;
-    }
+        pages = kmalloc(sizeof(struct page *) * numPages, GFP_KERNEL | __GFP_NOWARN);
 
-    for (i = 0; i < NumPages; i++)
+        if (!pages)
+        {
+            return gcvNULL;
+        }
+
+        for (i = 0; i < numPages; i++)
+        {
+            pages[i] = nth_page(Mdl->u.contiguousPages, i);
+        }
+
+        free = gcvTRUE;
+    }
+    else
     {
-        pages[i] = nth_page(Page, i);
+        pages = Mdl->u.nonContiguousPages;
     }
 
     /* ioremap() can't work on system memory since 2.6.38. */
-    addr = vmap(pages, NumPages, 0, gcmkNONPAGED_MEMROY_PROT(PAGE_KERNEL));
+    addr = vmap(pages, numPages, 0, gcmkNONPAGED_MEMROY_PROT(PAGE_KERNEL));
+
+    if (free)
+    {
+        kfree(pages);
+    }
 
-    kfree(pages);
-#else
-    addr = gcmkIOREMAP(page_to_phys(Page), NumPages * PAGE_SIZE);
 #endif
 
     return addr;
@@ -1382,14 +1152,31 @@ _DestoryKernelVirtualMapping(
     )
 {
 #if !gcdNONPAGED_MEMORY_CACHEABLE
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
     vunmap(Addr);
-#   else
-    iounmap(Addr);
-#   endif
 #endif
 }
-#endif
+
+gceSTATUS
+gckOS_CreateKernelVirtualMapping(
+    IN gctPHYS_ADDR Physical,
+    OUT gctSIZE_T * PageCount,
+    OUT gctPOINTER * Logical
+    )
+{
+    *PageCount = ((PLINUX_MDL)Physical)->numPages;
+    *Logical = _CreateKernelVirtualMapping((PLINUX_MDL)Physical);
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_DestroyKernelVirtualMapping(
+    IN gctPOINTER Logical
+    )
+{
+    _DestoryKernelVirtualMapping((gctSTRING)Logical);
+    return gcvSTATUS_OK;
+}
 
 /*******************************************************************************
 **
@@ -1662,15 +1449,26 @@ gckOS_MapMemory(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (char *)vm_mmap(gcvNULL,
+                    0L,
+                    mdl->numPages * PAGE_SIZE,
+                    PROT_READ | PROT_WRITE,
+                    MAP_SHARED,
+                    0);
+#else
         down_write(&current->mm->mmap_sem);
 
-        mdlMap->vmaAddr = (char *)do_mmap(gcvNULL,
+        mdlMap->vmaAddr = (char *)do_mmap_pgoff(gcvNULL,
                     0L,
                     mdl->numPages * PAGE_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED,
                     0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE(
@@ -1689,14 +1487,14 @@ gckOS_MapMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             MEMORY_UNLOCK(Os);
 
             gcmkFOOTER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (!mdlMap->vma)
@@ -1867,7 +1665,6 @@ gckOS_UnmapMemoryEx(
 {
     PLINUX_MDL_MAP          mdlMap;
     PLINUX_MDL              mdl = (PLINUX_MDL)Physical;
-    struct task_struct *    task;
 
     gcmkHEADER_ARG("Os=0x%X Physical=0x%X Bytes=%lu Logical=0x%X PID=%d",
                    Os, Physical, Bytes, Logical, PID);
@@ -1893,24 +1690,7 @@ gckOS_UnmapMemoryEx(
             return gcvSTATUS_INVALID_ARGUMENT;
         }
 
-        /* Get the current pointer for the task with stored pid. */
-        task = FIND_TASK_BY_PID(mdlMap->pid);
-
-        if (task != gcvNULL && task->mm != gcvNULL)
-        {
-            down_write(&task->mm->mmap_sem);
-            do_munmap(task->mm, (unsigned long)Logical, mdl->numPages*PAGE_SIZE);
-            up_write(&task->mm->mmap_sem);
-        }
-        else
-        {
-            gcmkTRACE_ZONE(
-                gcvLEVEL_INFO, gcvZONE_OS,
-                "%s(%d): can't find the task with pid->%d. No unmapping",
-                __FUNCTION__, __LINE__,
-                mdlMap->pid
-                );
-        }
+        _UnmapUserLogical(PID, mdlMap->vmaAddr, mdl->numPages * PAGE_SIZE);
 
         gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
     }
@@ -1924,6 +1704,55 @@ gckOS_UnmapMemoryEx(
 
 /*******************************************************************************
 **
+**  gckOS_UnmapUserLogical
+**
+**  Unmap user logical memory out of physical memory.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to an gckOS object.
+**
+**      gctPHYS_ADDR Physical
+**          Start of physical address memory.
+**
+**      gctSIZE_T Bytes
+**          Number of bytes to unmap.
+**
+**      gctPOINTER Memory
+**          Pointer to a previously mapped memory region.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_UnmapUserLogical(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    )
+{
+    gcmkHEADER_ARG("Os=0x%X Physical=0x%X Bytes=%lu Logical=0x%X",
+                   Os, Physical, Bytes, Logical);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != 0);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+    gckOS_UnmapMemory(Os, Physical, Bytes, Logical);
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+}
+
+/*******************************************************************************
+**
 **  gckOS_AllocateNonPagedMemory
 **
 **  Allocate a number of pages from non-paged memory.
@@ -2035,17 +1864,21 @@ gckOS_AllocateNonPagedMemory(
     }
 
     vaddr           = (gctPOINTER)page_address(page);
-    addr            = _CreateKernelVirtualMapping(page, mdl->numPages);
+    mdl->contiguous = gcvTRUE;
+    mdl->u.contiguousPages = page;
+    addr            = _CreateKernelVirtualMapping(mdl);
     mdl->dmaHandle  = virt_to_phys(vaddr);
     mdl->kaddr      = vaddr;
     mdl->u.contiguousPages = page;
 
+#if !defined(CONFIG_PPC)
     /* Cache invalidate. */
     dma_sync_single_for_device(
                 gcvNULL,
                 page_to_phys(page),
                 bytes,
                 DMA_FROM_DEVICE);
+#endif
 
     while (size > 0)
     {
@@ -2085,15 +1918,26 @@ gckOS_AllocateNonPagedMemory(
         /* Only after mmap this will be valid. */
 
         /* We need to map this to user space. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING) vm_mmap(gcvNULL,
+                0L,
+                mdl->numPages * PAGE_SIZE,
+                PROT_READ | PROT_WRITE,
+                MAP_SHARED,
+                0);
+#else
         down_write(&current->mm->mmap_sem);
 
-        mdlMap->vmaAddr = (gctSTRING) do_mmap(gcvNULL,
+        mdlMap->vmaAddr = (gctSTRING) do_mmap_pgoff(gcvNULL,
                 0L,
                 mdl->numPages * PAGE_SIZE,
                 PROT_READ | PROT_WRITE,
                 MAP_SHARED,
                 0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE_ZONE(
@@ -2104,11 +1948,11 @@ gckOS_AllocateNonPagedMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -2256,7 +2100,6 @@ gceSTATUS gckOS_FreeNonPagedMemory(
 {
     PLINUX_MDL mdl;
     PLINUX_MDL_MAP mdlMap;
-    struct task_struct * task;
 #ifdef NO_DMA_COHERENT
     unsigned size;
     gctPOINTER vaddr;
@@ -2319,28 +2162,8 @@ gceSTATUS gckOS_FreeNonPagedMemory(
     {
         if (mdlMap->vmaAddr != gcvNULL)
         {
-            /* Get the current pointer for the task with stored pid. */
-            task = FIND_TASK_BY_PID(mdlMap->pid);
-
-            if (task != gcvNULL && task->mm != gcvNULL)
-            {
-                down_write(&task->mm->mmap_sem);
-
-                if (do_munmap(task->mm,
-                              (unsigned long)mdlMap->vmaAddr,
-                              mdl->numPages * PAGE_SIZE) < 0)
-                {
-                    gcmkTRACE_ZONE(
-                        gcvLEVEL_WARNING, gcvZONE_OS,
-                        "%s(%d): do_munmap failed",
-                        __FUNCTION__, __LINE__
-                        );
-                }
-
-                up_write(&task->mm->mmap_sem);
-            }
-
-            mdlMap->vmaAddr = gcvNULL;
+            /* No mapped memory exists when free nonpaged memory */
+            gcmkASSERT(0);
         }
 
         mdlMap = mdlMap->next;
@@ -2828,13 +2651,6 @@ gckOS_GetPhysicalAddressProcess(
 
     gcmkONERROR(status);
 
-    if (Os->device->baseAddress != 0)
-    {
-        /* Subtract base address to get a GPU physical address. */
-        gcmkASSERT(*Address >= Os->device->baseAddress);
-        *Address -= Os->device->baseAddress;
-    }
-
     /* Success. */
     gcmkFOOTER_ARG("*Address=0x%08x", *Address);
     return gcvSTATUS_OK;
@@ -2878,7 +2694,7 @@ gckOS_MapPhysical(
 {
     gctPOINTER logical;
     PLINUX_MDL mdl;
-    gctUINT32 physical;
+    gctUINT32 physical = Physical;
 
     gcmkHEADER_ARG("Os=0x%X Physical=0x%X Bytes=%lu", Os, Physical, Bytes);
 
@@ -2889,9 +2705,6 @@ gckOS_MapPhysical(
 
     MEMORY_LOCK(Os);
 
-    /* Compute true physical address (before subtraction of the baseAddress). */
-    physical = Physical + Os->device->baseAddress;
-
     /* Go through our mapping to see if we know this physical address already. */
     mdl = Os->mdlHead;
 
@@ -3033,27 +2846,28 @@ gckOS_CreateMutex(
     OUT gctPOINTER * Mutex
     )
 {
+    gceSTATUS status;
+
     gcmkHEADER_ARG("Os=0x%X", Os);
 
     /* Validate the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-    /* Allocate a FAST_MUTEX structure. */
-    *Mutex = (gctPOINTER)kmalloc(sizeof(struct semaphore), GFP_KERNEL | __GFP_NOWARN);
-
-    if (*Mutex == gcvNULL)
-    {
-        gcmkFOOTER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
-        return gcvSTATUS_OUT_OF_MEMORY;
-    }
+    /* Allocate the mutex structure. */
+    gcmkONERROR(gckOS_Allocate(Os, gcmSIZEOF(struct mutex), Mutex));
 
-    /* Initialize the semaphore.. Come up in unlocked state. */
-    sema_init(*Mutex, 1);
+    /* Initialize the mutex. */
+    mutex_init(*Mutex);
 
     /* Return status. */
     gcmkFOOTER_ARG("*Mutex=0x%X", *Mutex);
     return gcvSTATUS_OK;
+
+OnError:
+    /* Return status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
@@ -3080,17 +2894,27 @@ gckOS_DeleteMutex(
     IN gctPOINTER Mutex
     )
 {
+    gceSTATUS status;
+
     gcmkHEADER_ARG("Os=0x%X Mutex=0x%X", Os, Mutex);
 
     /* Validate the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-    /* Delete the fast mutex. */
-    kfree(Mutex);
+    /* Destroy the mutex. */
+    mutex_destroy(Mutex);
+
+    /* Free the mutex structure. */
+    gcmkONERROR(gckOS_Free(Os, Mutex));
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
+
+OnError:
+    /* Return status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
@@ -3139,7 +2963,7 @@ gckOS_AcquireMutex(
     for (;;)
     {
         /* Try to acquire the mutex. */
-        if (!down_trylock((struct semaphore *) Mutex))
+        if (mutex_trylock(Mutex))
         {
             /* Success. */
             gcmkFOOTER_NO();
@@ -3203,7 +3027,8 @@ gckOS_AcquireMutex(
 #else
     if (Timeout == gcvINFINITE)
     {
-        down((struct semaphore *) Mutex);
+        /* Lock the mutex. */
+        mutex_lock(Mutex);
 
         /* Success. */
         gcmkFOOTER_NO();
@@ -3213,7 +3038,7 @@ gckOS_AcquireMutex(
     for (;;)
     {
         /* Try to acquire the mutex. */
-        if (!down_trylock((struct semaphore *) Mutex))
+        if (mutex_trylock(Mutex))
         {
             /* Success. */
             gcmkFOOTER_NO();
@@ -3265,8 +3090,8 @@ gckOS_ReleaseMutex(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-    /* Release the fast mutex. */
-    up((struct semaphore *) Mutex);
+    /* Release the mutex. */
+    mutex_unlock(Mutex);
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -3356,7 +3181,7 @@ gckOS_AtomicExchangePtr(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
     /* Exchange the pair of pointers. */
-    *OldValue = (gctPOINTER) atomic_xchg((atomic_t *) Target, (int) NewValue);
+    *OldValue = (gctPOINTER)(gctUINTPTR_T) atomic_xchg((atomic_t *) Target, (int)(gctUINTPTR_T) NewValue);
 
     /* Success. */
     gcmkFOOTER_ARG("*OldValue=0x%X", *OldValue);
@@ -3718,22 +3543,18 @@ gckOS_Delay(
     IN gctUINT32 Delay
     )
 {
-    struct timeval now;
-    unsigned long jiffies;
-
     gcmkHEADER_ARG("Os=0x%X Delay=%u", Os, Delay);
 
     if (Delay > 0)
     {
-        /* Convert milliseconds into seconds and microseconds. */
-        now.tv_sec  = Delay / 1000;
-        now.tv_usec = (Delay % 1000) * 1000;
-
-        /* Convert timeval to jiffies. */
-        jiffies = timeval_to_jiffies(&now);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+        ktime_t delay = ktime_set(0, Delay * NSEC_PER_MSEC);
+        __set_current_state(TASK_UNINTERRUPTIBLE);
+        schedule_hrtimeout(&delay, HRTIMER_MODE_REL);
+#else
+        msleep(Delay);
+#endif
 
-        /* Schedule timeout. */
-        schedule_timeout_interruptible(jiffies);
     }
 
     /* Success. */
@@ -3762,7 +3583,7 @@ gckOS_GetTicks(
 {
      gcmkHEADER();
 
-    *Time = jiffies * 1000 / HZ;
+    *Time = jiffies_to_msecs(jiffies);
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -3987,7 +3808,7 @@ gckOS_AllocatePagedMemoryEx(
         /* Get contiguous pages, and suppress warning (stack dump) from kernel when
            we run out of memory. */
         mdl->u.contiguousPages =
-            alloc_pages(GFP_KERNEL | __GFP_NOWARN, GetOrder(numPages));
+            alloc_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY, GetOrder(numPages));
 
         if (mdl->u.contiguousPages == gcvNULL)
         {
@@ -4030,7 +3851,7 @@ gckOS_AllocatePagedMemoryEx(
         {
             gcmkVERIFY_OK(
                 gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(page),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(page),
                                  page_address(page),
                                  PAGE_SIZE));
         }
@@ -4252,27 +4073,36 @@ gckOS_LockPages(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING)vm_mmap(gcvNULL,
+                        0L,
+                        mdl->numPages * PAGE_SIZE,
+                        PROT_READ | PROT_WRITE,
+                        MAP_SHARED,
+                        0);
+#else
         down_write(&current->mm->mmap_sem);
 
-        mdlMap->vmaAddr = (gctSTRING)do_mmap(gcvNULL,
+        mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
                         0L,
                         mdl->numPages * PAGE_SIZE,
                         PROT_READ | PROT_WRITE,
                         MAP_SHARED,
                         0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         gcmkTRACE_ZONE(
             gcvLEVEL_INFO, gcvZONE_OS,
             "%s(%d): vmaAddr->0x%X for phys_addr->0x%X",
             __FUNCTION__, __LINE__,
-            (gctUINT32) mdlMap->vmaAddr,
-            (gctUINT32) mdl
+            (gctUINT32)(gctUINTPTR_T)mdlMap->vmaAddr,
+            (gctUINT32)(gctUINTPTR_T)mdl
             );
 
         if (IS_ERR(mdlMap->vmaAddr))
         {
-            up_write(&current->mm->mmap_sem);
-
             gcmkTRACE_ZONE(
                 gcvLEVEL_INFO, gcvZONE_OS,
                 "%s(%d): do_mmap_pgoff error",
@@ -4287,6 +4117,8 @@ gckOS_LockPages(
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -4363,10 +4195,10 @@ gckOS_LockPages(
                         gcvLEVEL_INFO, gcvZONE_OS,
                         "%s(%d): gctPHYS_ADDR->0x%X Logical->0x%X Unable to map addr->0x%X to start->0x%X",
                         __FUNCTION__, __LINE__,
-                        (gctUINT32) Physical,
-                        (gctUINT32) *Logical,
-                        (gctUINT32) addr,
-                        (gctUINT32) start
+                        (gctUINT32)(gctUINTPTR_T)Physical,
+                        (gctUINT32)(gctUINTPTR_T)*Logical,
+                        (gctUINT32)(gctUINTPTR_T)addr,
+                        (gctUINT32)(gctUINTPTR_T)start
                         );
 
                     mdlMap->vmaAddr = gcvNULL;
@@ -4404,6 +4236,15 @@ gckOS_LockPages(
 
     MEMORY_UNLOCK(Os);
 
+    gcmkVERIFY_OK(gckOS_CacheFlush(
+        Os,
+        _GetProcessID(),
+        Physical,
+        gcvNULL,
+        (gctPOINTER)mdlMap->vmaAddr,
+        mdl->numPages * PAGE_SIZE
+        ));
+
     /* Success. */
     gcmkFOOTER_ARG("*Logical=0x%X *PageCount=%lu", *Logical, *PageCount);
     return gcvSTATUS_OK;
@@ -4484,8 +4325,8 @@ gckOS_MapPagesEx(
         gcvLEVEL_INFO, gcvZONE_OS,
         "%s(%d): Physical->0x%X PageCount->0x%X PagedMemory->?%d",
         __FUNCTION__, __LINE__,
-        (gctUINT32) Physical,
-        (gctUINT32) PageCount,
+        (gctUINT32)(gctUINTPTR_T)Physical,
+        (gctUINT32)(gctUINTPTR_T)PageCount,
         mdl->pagedMem
         );
 
@@ -4638,7 +4479,6 @@ gckOS_UnlockPages(
 {
     PLINUX_MDL_MAP          mdlMap;
     PLINUX_MDL              mdl = (PLINUX_MDL)Physical;
-    struct task_struct *    task;
 
     gcmkHEADER_ARG("Os=0x%X Physical=0x%X Bytes=%u Logical=0x%X",
                    Os, Physical, Bytes, Logical);
@@ -4660,16 +4500,7 @@ gckOS_UnlockPages(
     {
         if ((mdlMap->vmaAddr != gcvNULL) && (_GetProcessID() == mdlMap->pid))
         {
-            /* Get the current pointer for the task with stored pid. */
-            task = FIND_TASK_BY_PID(mdlMap->pid);
-
-            if (task != gcvNULL && task->mm != gcvNULL)
-            {
-                down_write(&task->mm->mmap_sem);
-                do_munmap(task->mm, (unsigned long)mdlMap->vmaAddr, mdl->numPages * PAGE_SIZE);
-                up_write(&task->mm->mmap_sem);
-            }
-
+            _UnmapUserLogical(mdlMap->pid, mdlMap->vmaAddr, mdl->numPages * PAGE_SIZE);
             mdlMap->vmaAddr = gcvNULL;
         }
 
@@ -4951,13 +4782,11 @@ gckOS_MapUserPointer(
     OUT gctPOINTER * KernelPointer
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
-
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
     gctPOINTER buf = gcvNULL;
     gctUINT32 len;
 
+    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
+
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
@@ -4996,10 +4825,6 @@ gckOS_MapUserPointer(
     }
 
     *KernelPointer = buf;
-}
-#else
-    *KernelPointer = Pointer;
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_ARG("*KernelPointer=0x%X", *KernelPointer);
     return gcvSTATUS_OK;
@@ -5037,12 +4862,11 @@ gckOS_UnmapUserPointer(
     IN gctPOINTER KernelPointer
     )
 {
+    gctUINT32 len;
+
     gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu KernelPointer=0x%X",
                    Os, Pointer, Size, KernelPointer);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
-    gctUINT32 len;
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
@@ -5065,8 +4889,6 @@ gckOS_UnmapUserPointer(
         gcmkFOOTER_ARG("status=%d", gcvSTATUS_GENERIC_IO);
         return gcvSTATUS_GENERIC_IO;
     }
-}
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -5106,13 +4928,8 @@ gckOS_QueryNeedCopy(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(NeedCopy != gcvNULL);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     /* We need to copy data. */
     *NeedCopy = gcvTRUE;
-#else
-    /* No need to copy data. */
-    *NeedCopy = gcvFALSE;
-#endif
 
     /* Success. */
     gcmkFOOTER_ARG("*NeedCopy=%d", *NeedCopy);
@@ -5274,7 +5091,6 @@ gckOS_WriteMemory(
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
     /* Write memory. */
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     if (access_ok(VERIFY_WRITE, Address, 4))
     {
         /* User address. */
@@ -5284,7 +5100,6 @@ gckOS_WriteMemory(
         }
     }
     else
-#endif
     {
         /* Kernel address. */
         *(gctUINT32 *)Address = Data;
@@ -5327,20 +5142,9 @@ OnError:
 gceSTATUS
 gckOS_MapUserMemory(
     IN gckOS Os,
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Size,
-    OUT gctPOINTER * Info,
-    OUT gctUINT32_PTR Address
-    )
-{
-    return gckOS_MapUserMemoryEx(Os, gcvCORE_MAJOR, Memory, Size, Info, Address);
-}
-
-gceSTATUS
-gckOS_MapUserMemoryEx(
-    IN gckOS Os,
     IN gceCORE Core,
     IN gctPOINTER Memory,
+    IN gctUINT32 Physical,
     IN gctSIZE_T Size,
     OUT gctPOINTER * Info,
     OUT gctUINT32_PTR Address
@@ -5364,7 +5168,8 @@ OnError:
     gctSIZE_T pageCount, i, j;
     gctUINT32_PTR pageTable;
     gctUINT32 address = 0, physical = ~0U;
-    gctUINT32 start, end, memory;
+    gctUINTPTR_T start, end, memory;
+    gctUINT32 offset;
     gctINT result = 0;
 
     gcsPageInfo_PTR info = gcvNULL;
@@ -5372,14 +5177,14 @@ OnError:
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL || Physical != ~0U);
     gcmkVERIFY_ARGUMENT(Size > 0);
     gcmkVERIFY_ARGUMENT(Info != gcvNULL);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
     do
     {
-        memory = (gctUINT32) Memory;
+        memory = (gctUINTPTR_T) Memory;
 
         /* Get the number of required pages. */
         end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
@@ -5393,13 +5198,6 @@ OnError:
             pageCount
             );
 
-        /* Invalid argument. */
-        if (pageCount == 0)
-        {
-            gcmkFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
-            return gcvSTATUS_INVALID_ARGUMENT;
-        }
-
         /* Overflow. */
         if ((memory + Size) < memory)
         {
@@ -5427,9 +5225,19 @@ OnError:
             break;
         }
 
-        /* Get the user pages. */
-        down_read(&current->mm->mmap_sem);
-        result = get_user_pages(current,
+        if (Physical != ~0U)
+        {
+            for (i = 0; i < pageCount; i++)
+            {
+                pages[i] = pfn_to_page((Physical >> PAGE_SHIFT) + i);
+                get_page(pages[i]);
+            }
+        }
+        else
+        {
+            /* Get the user pages. */
+            down_read(&current->mm->mmap_sem);
+            result = get_user_pages(current,
                     current->mm,
                     memory & PAGE_MASK,
                     pageCount,
@@ -5438,87 +5246,84 @@ OnError:
                     pages,
                     gcvNULL
                     );
-        up_read(&current->mm->mmap_sem);
-
-        if (result <=0 || result < pageCount)
-        {
-            struct vm_area_struct *vma;
+            up_read(&current->mm->mmap_sem);
 
-            /* Free the page table. */
-            if (pages != gcvNULL)
+            if (result <=0 || result < pageCount)
             {
-                /* Release the pages if any. */
-                if (result > 0)
+                struct vm_area_struct *vma;
+
+                /* Free the page table. */
+                if (pages != gcvNULL)
                 {
-                    for (i = 0; i < result; i++)
+                    /* Release the pages if any. */
+                    if (result > 0)
                     {
-                        if (pages[i] == gcvNULL)
+                        for (i = 0; i < result; i++)
                         {
-                            break;
-                        }
+                            if (pages[i] == gcvNULL)
+                            {
+                                break;
+                            }
 
-                        page_cache_release(pages[i]);
+                            page_cache_release(pages[i]);
+                        }
                     }
-                }
-
-                kfree(pages);
-                pages = gcvNULL;
-            }
 
-            vma = find_vma(current->mm, memory);
+                    kfree(pages);
+                    pages = gcvNULL;
+                }
 
-            if (vma && (vma->vm_flags & VM_PFNMAP) )
-            {
-                pte_t       * pte;
-                spinlock_t  * ptl;
-                unsigned long pfn;
+                vma = find_vma(current->mm, memory);
 
-                pgd_t * pgd = pgd_offset(current->mm, memory);
-                pud_t * pud = pud_offset(pgd, memory);
-                if (pud)
+                if (vma && (vma->vm_flags & VM_PFNMAP) )
                 {
-                    pmd_t * pmd = pmd_offset(pud, memory);
-                    pte = pte_offset_map_lock(current->mm, pmd, memory, &ptl);
-                    if (!pte)
+                    pte_t       * pte;
+                    spinlock_t  * ptl;
+                    unsigned long pfn;
+
+                    pgd_t * pgd = pgd_offset(current->mm, memory);
+                    pud_t * pud = pud_offset(pgd, memory);
+                    if (pud)
+                    {
+                        pmd_t * pmd = pmd_offset(pud, memory);
+                        pte = pte_offset_map_lock(current->mm, pmd, memory, &ptl);
+                        if (!pte)
+                        {
+                            gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                        }
+                    }
+                    else
                     {
                         gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
                     }
-                }
-                else
-                {
-                    gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
-                }
 
-                pfn      = pte_pfn(*pte);
+                    pfn      = pte_pfn(*pte);
 
-                physical = (pfn << PAGE_SHIFT) | (memory & ~PAGE_MASK);
+                    physical = (pfn << PAGE_SHIFT) | (memory & ~PAGE_MASK);
 
-                pte_unmap_unlock(pte, ptl);
+                    pte_unmap_unlock(pte, ptl);
 
-                if ((Os->device->kernels[Core]->hardware->mmuVersion == 0)
-                    && !((physical - Os->device->baseAddress) & 0x80000000))
-                {
-                    /* Release page info struct. */
-                    if (info != gcvNULL)
+                    if ((Os->device->kernels[Core]->hardware->mmuVersion == 0)
+                            && !((physical - Os->device->baseAddress) & 0x80000000))
                     {
-                        /* Free the page info struct. */
-                        kfree(info);
-                    }
+                        info->pages = gcvNULL;
+                        info->pageTable = gcvNULL;
 
-                    MEMORY_MAP_UNLOCK(Os);
+                        MEMORY_MAP_UNLOCK(Os);
 
-                    *Address = physical - Os->device->baseAddress;
-                    *Info    = gcvNULL;
+                        *Address = physical - Os->device->baseAddress;
+                        *Info    = info;
 
-                    gcmkFOOTER_ARG("*Info=0x%X *Address=0x%08x",
-                                   *Info, *Address);
+                        gcmkFOOTER_ARG("*Info=0x%X *Address=0x%08x",
+                                *Info, *Address);
 
-                    return gcvSTATUS_OK;
+                        return gcvSTATUS_OK;
+                    }
+                }
+                else
+                {
+                    gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
                 }
-            }
-            else
-            {
-                gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
         }
 
@@ -5528,7 +5333,7 @@ OnError:
             {
                 /* Flush(clean) the data cache. */
                 gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(pages[i]),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(pages[i]),
                                  (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
                                  PAGE_SIZE));
             }
@@ -5537,10 +5342,9 @@ OnError:
         {
             /* Flush(clean) the data cache. */
             gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                             (gctPOINTER)(physical & PAGE_MASK),
+                             (gctPOINTER)(gctUINTPTR_T)(physical & PAGE_MASK),
                              (gctPOINTER)(memory & PAGE_MASK),
                              PAGE_SIZE * pageCount));
-
         }
 
 #if gcdENABLE_VG
@@ -5608,7 +5412,11 @@ OnError:
         }
 
 #if gcdENABLE_VG
-        if (Core != gcvCORE_VG)
+        if (Core == gcvCORE_VG)
+        {
+            gcmkONERROR(gckVGMMU_Flush(Os->device->kernels[Core]->vg->mmu));
+        }
+        else
 #endif
         {
             gcmkONERROR(gckMMU_Flush(Os->device->kernels[Core]->mmu));
@@ -5629,8 +5437,12 @@ OnError:
             info
             );
 
+        offset = (Physical != ~0U)
+               ? (Physical & ~PAGE_MASK)
+               : (memory & ~PAGE_MASK);
+
         /* Return address. */
-        *Address = address + (memory & ~PAGE_MASK);
+        *Address = address + offset;
 
         gcmkTRACE_ZONE(
             gcvLEVEL_INFO, gcvZONE_OS,
@@ -5747,18 +5559,6 @@ OnError:
 gceSTATUS
 gckOS_UnmapUserMemory(
     IN gckOS Os,
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Size,
-    IN gctPOINTER Info,
-    IN gctUINT32 Address
-    )
-{
-    return gckOS_UnmapUserMemoryEx(Os, gcvCORE_MAJOR, Memory, Size, Info, Address);
-}
-
-gceSTATUS
-gckOS_UnmapUserMemoryEx(
-    IN gckOS Os,
     IN gceCORE Core,
     IN gctPOINTER Memory,
     IN gctSIZE_T Size,
@@ -5782,7 +5582,7 @@ OnError:
     return status;
 #else
 {
-    gctUINT32 memory, start, end;
+    gctUINTPTR_T memory, start, end;
     gcsPageInfo_PTR info;
     gctSIZE_T pageCount, i;
     struct page **pages;
@@ -5795,8 +5595,6 @@ OnError:
 
     do
     {
-        /*gctUINT32 physical = ~0U;*/
-
         info = (gcsPageInfo_PTR) Info;
 
         pages = info->pages;
@@ -5809,22 +5607,15 @@ OnError:
             );
 
         /* Invalid page array. */
-        if (pages == gcvNULL)
+        if (pages == gcvNULL && info->pageTable == gcvNULL)
         {
-            if (info->pageTable == gcvNULL)
-            {
-                kfree(info);
+            kfree(info);
 
-                gcmkFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
-                return gcvSTATUS_INVALID_ARGUMENT;
-            }
-            else
-            {
-                /*physical = (*info->pageTable) & PAGE_MASK;*/
-            }
+            gcmkFOOTER_NO();
+            return gcvSTATUS_OK;
         }
 
-        memory = (gctUINT32) Memory;
+        memory = (gctUINTPTR_T)Memory;
         end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
         start = memory >> PAGE_SHIFT;
         pageCount = end - start;
@@ -5836,13 +5627,6 @@ OnError:
             return gcvSTATUS_INVALID_ARGUMENT;
         }
 
-        /* Invalid argument. */
-        if (pageCount == 0)
-        {
-            gcmkFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
-            return gcvSTATUS_INVALID_ARGUMENT;
-        }
-
         gcmkTRACE_ZONE(
             gcvLEVEL_INFO, gcvZONE_OS,
             "%s(%d): memory: 0x%X, pageCount: %d, pageTable: 0x%X.",
@@ -5852,6 +5636,8 @@ OnError:
 
         MEMORY_MAP_LOCK(Os);
 
+        gcmkASSERT(info->pageTable != gcvNULL);
+
 #if gcdENABLE_VG
         if (Core == gcvCORE_VG)
         {
@@ -6135,7 +5921,7 @@ _HandleOuterCache(
     else
     {
         /* Non contiguous virtual memory */
-        vaddr = (gctPOINTER)gcmALIGN_BASE((gctUINT32)Logical, PAGE_SIZE);
+        vaddr = (gctPOINTER)gcmALIGN_BASE((gctUINTPTR_T)Logical, PAGE_SIZE);
         pageNum = GetPageCount(Bytes, 0);
 
         for (i = 0; i < pageNum; i += 1)
@@ -6234,6 +6020,10 @@ gckOS_CacheClean(
 
     dma_cache_wback((unsigned long) Logical, Bytes);
 
+#elif defined(CONFIG_PPC)
+
+    /* TODO */
+
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6311,6 +6101,8 @@ gckOS_CacheInvalidate(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6383,6 +6175,8 @@ gckOS_CacheFlush(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_wback_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6476,7 +6270,11 @@ gckOS_Broadcast(
         /* Put GPU IDLE. */
         gcmkONERROR(
             gckHARDWARE_SetPowerManagementState(Hardware,
+#if gcdPOWER_SUSNPEND_WHEN_IDLE
+                                                gcvPOWER_SUSPEND_BROADCAST));
+#else
                                                 gcvPOWER_IDLE_BROADCAST));
+#endif
 
         /* Add idle process DB. */
         gcmkONERROR(gckKERNEL_AddProcessDB(Hardware->kernel,
@@ -6501,13 +6299,15 @@ gckOS_Broadcast(
 
     case gcvBROADCAST_GPU_STUCK:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_GPU_STUCK\n");
-        gcmkONERROR(_DumpGPUState(Os, gcvCORE_MAJOR));
+#if !gcdENABLE_RECOVERY
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
+#endif
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
 
     case gcvBROADCAST_AXI_BUS_ERROR:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_AXI_BUS_ERROR\n");
-        gcmkONERROR(_DumpGPUState(Os, gcvCORE_MAJOR));
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
     }
@@ -6899,8 +6699,8 @@ gckOS_GetThreadID(
 **      gckOS Os
 **          Pointer to a gckOS object.
 **
-**      gceCORE Core
-**          Core type.
+**      gckCORE Core
+**          GPU whose power is set.
 **
 **      gctBOOL Clock
 **          gcvTRUE to turn on the clock, or gcvFALSE to turn off the clock.
@@ -6922,53 +6722,340 @@ gckOS_SetGPUPower(
 {
     struct clk *clk_3dcore = Os->device->clk_3d_core;
     struct clk *clk_3dshader = Os->device->clk_3d_shader;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    struct clk *clk_3d_axi = Os->device->clk_3d_axi;
+#endif
     struct clk *clk_2dcore = Os->device->clk_2d_core;
     struct clk *clk_2d_axi = Os->device->clk_2d_axi;
     struct clk *clk_vg_axi = Os->device->clk_vg_axi;
 
-    gcmkHEADER_ARG("Os=0x%X Core=%d Clock=%d Power=%d", Os, Core, Clock, Power);
-    if (Clock == gcvTRUE) {
-        switch (Core) {
-        case gcvCORE_MAJOR:
-            clk_enable(clk_3dcore);
-            if (cpu_is_mx6q())
-                clk_enable(clk_3dshader);
-            break;
-        case gcvCORE_2D:
-            clk_enable(clk_2dcore);
-            clk_enable(clk_2d_axi);
-            break;
-        case gcvCORE_VG:
-            clk_enable(clk_2dcore);
-            clk_enable(clk_vg_axi);
-            break;
-        default:
-            break;
-        }
-    } else {
-        switch (Core) {
-        case gcvCORE_MAJOR:
-            if (cpu_is_mx6q())
-                clk_disable(clk_3dshader);
-            clk_disable(clk_3dcore);
-            break;
-        case gcvCORE_2D:
-            clk_disable(clk_2dcore);
-            clk_disable(clk_2d_axi);
-            break;
-        case gcvCORE_VG:
-            clk_disable(clk_2dcore);
-            clk_disable(clk_vg_axi);
-            break;
-        default:
-            break;
-        }
-    }
-    /* TODO: Put your code here. */
+    gctBOOL oldClockState = gcvFALSE;
+    gctBOOL oldPowerState = gcvFALSE;
 
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-}
+    gcmkHEADER_ARG("Os=0x%X Core=%d Clock=%d Power=%d", Os, Core, Clock, Power);
+
+    if (Os->device->kernels[Core] != NULL)
+    {
+#if gcdENABLE_VG
+        if (Core == gcvCORE_VG)
+        {
+            oldClockState = Os->device->kernels[Core]->vg->hardware->clockState;
+            oldPowerState = Os->device->kernels[Core]->vg->hardware->powerState;
+        }
+        else
+        {
+#endif
+            oldClockState = Os->device->kernels[Core]->hardware->clockState;
+            oldPowerState = Os->device->kernels[Core]->hardware->powerState;
+#if gcdENABLE_VG
+        }
+#endif
+    }
+	if((Power == gcvTRUE) && (oldPowerState == gcvFALSE))
+	{
+		if(!IS_ERR(Os->device->gpu_regulator))
+            regulator_enable(Os->device->gpu_regulator);
+#ifdef CONFIG_PM
+		pm_runtime_get_sync(Os->device->pmdev);
+#endif
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+    if (Clock == gcvTRUE) {
+        if (oldClockState == gcvFALSE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_enable(clk_3dcore);
+                if (cpu_is_mx6q())
+                    clk_enable(clk_3dshader);
+                break;
+            case gcvCORE_2D:
+                clk_enable(clk_2dcore);
+                clk_enable(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_enable(clk_2dcore);
+                clk_enable(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    } else {
+        if (oldClockState == gcvTRUE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                if (cpu_is_mx6q())
+                    clk_disable(clk_3dshader);
+                clk_disable(clk_3dcore);
+                break;
+           case gcvCORE_2D:
+                clk_disable(clk_2dcore);
+                clk_disable(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_disable(clk_2dcore);
+                clk_disable(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+#else
+    if (Clock == gcvTRUE) {
+        if (oldClockState == gcvFALSE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_prepare(clk_3dcore);
+                clk_enable(clk_3dcore);
+                clk_prepare(clk_3dshader);
+                clk_enable(clk_3dshader);
+                clk_prepare(clk_3d_axi);
+                clk_enable(clk_3d_axi);
+                break;
+            case gcvCORE_2D:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_2d_axi);
+                clk_enable(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_vg_axi);
+                clk_enable(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    } else {
+        if (oldClockState == gcvTRUE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_disable(clk_3dshader);
+                clk_unprepare(clk_3dshader);
+                clk_disable(clk_3dcore);
+                clk_unprepare(clk_3dcore);
+                clk_disable(clk_3d_axi);
+                clk_unprepare(clk_3d_axi);
+                break;
+           case gcvCORE_2D:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_2d_axi);
+                clk_unprepare(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_vg_axi);
+                clk_unprepare(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+#endif
+	if((Power == gcvFALSE) && (oldPowerState == gcvTRUE))
+	{
+#ifdef CONFIG_PM
+		pm_runtime_put_sync(Os->device->pmdev);
+#endif
+		if(!IS_ERR(Os->device->gpu_regulator))
+            regulator_disable(Os->device->gpu_regulator);
+	}
+    /* TODO: Put your code here. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_ResetGPU
+**
+**  Reset the GPU.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_ResetGPU(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+#define SRC_SCR_OFFSET 0
+#define BP_SRC_SCR_GPU3D_RST 1
+#define BP_SRC_SCR_GPU2D_RST 4
+    void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
+    gctUINT32 bit_offset,val;
+
+    gcmkHEADER_ARG("Os=0x%X Core=%d", Os, Core);
+
+    if(Core == gcvCORE_MAJOR) {
+        bit_offset = BP_SRC_SCR_GPU3D_RST;
+    } else if((Core == gcvCORE_VG)
+            ||(Core == gcvCORE_2D)) {
+        bit_offset = BP_SRC_SCR_GPU2D_RST;
+    } else {
+        return gcvSTATUS_INVALID_CONFIG;
+    }
+    val = __raw_readl(src_base + SRC_SCR_OFFSET);
+    val &= ~(1 << (bit_offset));
+    val |= (1 << (bit_offset));
+    __raw_writel(val, src_base + SRC_SCR_OFFSET);
+
+    while ((__raw_readl(src_base + SRC_SCR_OFFSET) &
+                (1 << (bit_offset))) != 0) {
+    }
+
+    gcmkFOOTER_NO();
+#else
+    imx_src_reset_gpu((int)Core);
+#endif
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_PrepareGPUFrequency
+**
+**  Prepare to set GPU frequency and voltage.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage will be set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_FinishGPUFrequency
+**
+**  Finish GPU frequency setting.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage is set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_QueryGPUFrequency
+**
+**  Query the current frequency of the GPU.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT32 * Frequency
+**          Pointer to a gctUINT32 to obtain current frequency, in MHz.
+**
+**      gctUINT8 * Scale
+**          Pointer to a gctUINT8 to obtain current scale(1 - 64).
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_SetGPUFrequency
+**
+**  Set frequency and voltage of the GPU.
+**
+**      1. DVFS manager gives the target scale of full frequency, BSP must find
+**         a real frequency according to this scale and board's configure.
+**
+**      2. BSP should find a suitable voltage for this frequency.
+**
+**      3. BSP must make sure setting take effect before this function returns.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT8 Scale
+**          Target scale of full frequency, range is [1, 64]. 1 means 1/64 of
+**          full frequency and 64 means 64/64 of full frequency.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    )
+{
+    return gcvSTATUS_OK;
+}
 
 /*----------------------------------------------------------------------------*/
 /*----- Profile --------------------------------------------------------------*/
@@ -7100,14 +7187,15 @@ gckOS_CreateSignal(
     }
 
     /* Save the process ID. */
-    signal->process = (gctHANDLE) _GetProcessID();
+    signal->process = (gctHANDLE)(gctUINTPTR_T) _GetProcessID();
     signal->manualReset = ManualReset;
+    signal->hardware = gcvNULL;
     init_completion(&signal->obj);
     atomic_set(&signal->ref, 1);
 
     gcmkONERROR(_AllocateIntegerId(&Os->signalDB, signal, &signal->id));
 
-    *Signal = (gctSIGNAL)signal->id;
+    *Signal = (gctSIGNAL)(gctUINTPTR_T)signal->id;
 
     gcmkFOOTER_ARG("*Signal=0x%X", *Signal);
     return gcvSTATUS_OK;
@@ -7122,6 +7210,61 @@ OnError:
     return status;
 }
 
+gceSTATUS
+gckOS_SignalQueryHardware(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    OUT gckHARDWARE * Hardware
+    )
+{
+    gceSTATUS status;
+    gcsSIGNAL_PTR signal;
+
+    gcmkHEADER_ARG("Os=0x%X Signal=0x%X Hardware=0x%X", Os, Signal, Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
+
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
+
+    *Hardware = signal->hardware;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_SignalSetHardware(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gcsSIGNAL_PTR signal;
+
+    gcmkHEADER_ARG("Os=0x%X Signal=0x%X Hardware=0x%X", Os, Signal, Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
+
+    signal->hardware = Hardware;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckOS_DestroySignal
@@ -7159,9 +7302,9 @@ gckOS_DestroySignal(
     gcmkONERROR(gckOS_AcquireMutex(Os, Os->signalMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     if (atomic_dec_and_test(&signal->ref))
     {
@@ -7177,6 +7320,7 @@ gckOS_DestroySignal(
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
+
 OnError:
     if (acquired)
     {
@@ -7230,12 +7374,15 @@ gckOS_Signal(
     gcmkONERROR(gckOS_AcquireMutex(Os, Os->signalMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     if (State)
     {
+        /* unbind the signal from hardware. */
+        signal->hardware = gcvNULL;
+
         /* Set the event to a signaled state. */
         complete(&signal->obj);
     }
@@ -7276,7 +7423,7 @@ gckOS_SetSignalVG(
     struct task_struct * userTask;
     struct siginfo info;
 
-    userTask = FIND_TASK_BY_PID((pid_t) Process);
+    userTask = FIND_TASK_BY_PID((pid_t)(gctUINTPTR_T) Process);
 
     if (userTask != gcvNULL)
     {
@@ -7355,7 +7502,7 @@ gckOS_UserSignal(
     gctSIGNAL signal;
 
     gcmkHEADER_ARG("Os=0x%X Signal=0x%X Process=%d",
-                   Os, Signal, (gctINT32) Process);
+                   Os, Signal, (gctINT32)(gctUINTPTR_T)Process);
 
     /* Map the signal into kernel space. */
     gcmkONERROR(gckOS_MapSignal(Os, Signal, Process, &signal));
@@ -7413,9 +7560,9 @@ gckOS_WaitSignal(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     might_sleep();
 
@@ -7582,15 +7729,14 @@ gckOS_MapSignal(
 {
     gceSTATUS status;
     gcsSIGNAL_PTR signal;
-
     gcmkHEADER_ARG("Os=0x%X Signal=0x%X Process=0x%X", Os, Signal, Process);
 
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
     gcmkVERIFY_ARGUMENT(MappedSignal != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    if (atomic_inc_return(&signal->ref) <= 1)
+    if(atomic_inc_return(&signal->ref) <= 1)
     {
         /* The previous value is 0, it has been deleted. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -7659,7 +7805,14 @@ gckOS_CreateUserSignal(
     OUT gctINT * SignalID
     )
 {
-    return gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) SignalID);
+    gceSTATUS status;
+    gctSIZE_T signal;
+
+    /* Create a new signal. */
+    status = gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) &signal);
+    *SignalID = (gctINT) signal;
+
+    return status;
 }
 
 /*******************************************************************************
@@ -7686,7 +7839,7 @@ gckOS_DestroyUserSignal(
     IN gctINT SignalID
     )
 {
-    return gckOS_DestroySignal(Os, (gctSIGNAL)SignalID);
+    return gckOS_DestroySignal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID);
 }
 
 /*******************************************************************************
@@ -7718,7 +7871,7 @@ gckOS_WaitUserSignal(
     IN gctUINT32 Wait
     )
 {
-    return gckOS_WaitSignal(Os, (gctSIGNAL)SignalID, Wait);
+    return gckOS_WaitSignal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID, Wait);
 }
 
 /*******************************************************************************
@@ -7750,16 +7903,7 @@ gckOS_SignalUserSignal(
     IN gctBOOL State
     )
 {
-    return gckOS_Signal(Os, (gctSIGNAL)SignalID, State);
-}
-
-gceSTATUS
-gckOS_CleanProcessSignal(
-    gckOS Os,
-    gctHANDLE Process
-    )
-{
-    return gcvSTATUS_OK;
+    return gckOS_Signal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID, State);
 }
 
 #if gcdENABLE_VG
@@ -7892,7 +8036,7 @@ gckOS_SetSignal(
     struct task_struct * userTask;
     struct siginfo info;
 
-    userTask = FIND_TASK_BY_PID((pid_t) Process);
+    userTask = FIND_TASK_BY_PID((pid_t)(gctUINTPTR_T) Process);
 
     if (userTask != gcvNULL)
     {
@@ -8026,37 +8170,252 @@ gckOS_VerifyThread(
 }
 #endif
 
+/******************************************************************************\
+******************************** Software Timer ********************************
+\******************************************************************************/
+
+void
+_TimerFunction(
+    struct work_struct * work
+    )
+{
+    gcsOSTIMER_PTR timer = (gcsOSTIMER_PTR)work;
+
+    gctTIMERFUNCTION function = timer->function;
+
+    function(timer->data);
+}
+
 /*******************************************************************************
 **
-**  gckOS_DumpGPUState
+**  gckOS_CreateTimer
 **
-**  Dump GPU state.
+**  Create a software timer.
 **
 **  INPUT:
 **
 **      gckOS Os
 **          Pointer to the gckOS object.
 **
-**      gceCORE Core
-**          The core type of kernel.
+**      gctTIMERFUNCTION Function.
+**          Pointer to a call back function which will be called when timer is
+**          expired.
+**
+**      gctPOINTER Data.
+**          Private data which will be passed to call back function.
 **
 **  OUTPUT:
 **
-**      Nothing.
+**      gctPOINTER * Timer
+**          Pointer to a variable receiving the created timer.
 */
 gceSTATUS
-gckOS_DumpGPUState(
+gckOS_CreateTimer(
     IN gckOS Os,
-    IN gceCORE Core
+    IN gctTIMERFUNCTION Function,
+    IN gctPOINTER Data,
+    OUT gctPOINTER * Timer
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Core=%d", Os, Core);
+    gceSTATUS status;
+    gcsOSTIMER_PTR pointer;
+    gcmkHEADER_ARG("Os=0x%X Function=0x%X Data=0x%X", Os, Function, Data);
+
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Timer != gcvNULL);
+
+    gcmkONERROR(gckOS_Allocate(Os, sizeof(gcsOSTIMER), (gctPOINTER)&pointer));
+
+    pointer->function = Function;
+    pointer->data = Data;
+
+    INIT_DELAYED_WORK(&pointer->work, _TimerFunction);
 
-    _DumpGPUState(Os, Core);
+    *Timer = pointer;
 
     gcmkFOOTER_NO();
-    /* Success. */
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
+/*******************************************************************************
+**
+**  gckOS_DestroyTimer
+**
+**  Destory a software timer.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Timer
+**          Pointer to the timer to be destoryed.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_DestroyTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    )
+{
+    gcsOSTIMER_PTR timer;
+    gcmkHEADER_ARG("Os=0x%X Timer=0x%X", Os, Timer);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Timer != gcvNULL);
+
+    timer = (gcsOSTIMER_PTR)Timer;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+    cancel_delayed_work_sync(&timer->work);
+#else
+    cancel_delayed_work(&timer->work);
+    flush_workqueue(Os->workqueue);
+#endif
+
+    gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, Timer));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_StartTimer
+**
+**  Schedule a software timer.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Timer
+**          Pointer to the timer to be scheduled.
+**
+**      gctUINT32 Delay
+**          Delay in milliseconds.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_StartTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer,
+    IN gctUINT32 Delay
+    )
+{
+    gcsOSTIMER_PTR timer;
+
+    gcmkHEADER_ARG("Os=0x%X Timer=0x%X Delay=%u", Os, Timer, Delay);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Timer != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Delay != 0);
+
+    timer = (gcsOSTIMER_PTR)Timer;
+
+    if (unlikely(delayed_work_pending(&timer->work)))
+    {
+        cancel_delayed_work(&timer->work);
+    }
+
+    queue_delayed_work(Os->workqueue, &timer->work, msecs_to_jiffies(Delay));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_StopTimer
+**
+**  Cancel a unscheduled timer.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Timer
+**          Pointer to the timer to be cancel.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_StopTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    )
+{
+    gcsOSTIMER_PTR timer;
+    gcmkHEADER_ARG("Os=0x%X Timer=0x%X", Os, Timer);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Timer != gcvNULL);
+
+    timer = (gcsOSTIMER_PTR)Timer;
+
+    cancel_delayed_work(&timer->work);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+
+gceSTATUS
+gckOS_DumpCallStack(
+    IN gckOS Os
+    )
+{
+    gcmkHEADER_ARG("Os=0x%X", Os);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    dump_stack();
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
+    )
+{
+    struct task_struct *task;
+
+    /* Get the task_struct of the task with pid. */
+    rcu_read_lock();
+
+    task = FIND_TASK_BY_PID(Pid);
+
+    if (task == gcvNULL)
+    {
+        rcu_read_unlock();
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    /* Get name of process. */
+    strncpy(String, task->comm, Length);
+
+    rcu_read_unlock();
+
     return gcvSTATUS_OK;
 }
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 021e77f..e970477 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_os_h_
 #define __gc_hal_kernel_os_h_
 
@@ -71,18 +69,11 @@ FindMdlMap(
 
 typedef struct _DRIVER_ARGS
 {
-    gctPOINTER              InputBuffer;
-    gctUINT32               InputBufferSize;
-    gctPOINTER              OutputBuffer;
-    gctUINT32               OutputBufferSize;
+    gctUINT64               InputBuffer;
+    gctUINT64               InputBufferSize;
+    gctUINT64               OutputBuffer;
+    gctUINT64               OutputBufferSize;
 }
 DRIVER_ARGS;
 
-/* Cleanup the signal table. */
-gceSTATUS
-gckOS_CleanProcessSignal(
-    gckOS Os,
-    gctHANDLE Process
-    );
-
 #endif /* __gc_hal_kernel_os_h_ */
-- 
1.7.5.4

