From be75654254c64eb453db7fcf820944c1461856b7 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Thu, 14 Nov 2013 14:38:20 +0800
Subject: [PATCH 0736/1072] ENGR00287992-4 usb: chipidea: Add usb charger
 detect notify

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 9c3ceb845f1334c04e34c097598979e4173045f8

- Change .notify's return value from void to int.
- Add CI_HDRC_CONTROLLER_CHARGER_EVENT and
CI_HDRC_CONTROLLER_CHARGER_POST_EVENT to finish the USB charger
detection flow.
- Add usb_gadget_vbus_connect for only notify udc when vbus
is on, the main reason we add it is we don't want the first
notification when the vbus is off, it causes the
dev->power.usage_count equals -1 when do charger detection.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/usb/chipidea/otg.c   |   18 ++++++++++++++++++
 drivers/usb/chipidea/otg.h   |    1 +
 drivers/usb/chipidea/udc.c   |   30 ++++++++++++++++++++++++++++--
 include/linux/usb/chipidea.h |    5 ++++-
 4 files changed, 51 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c
index 49b4e25..bdf3f41 100644
--- a/drivers/usb/chipidea/otg.c
+++ b/drivers/usb/chipidea/otg.c
@@ -39,6 +39,24 @@ enum ci_role ci_otg_role(struct ci_hdrc *ci)
 	return role;
 }
 
+void ci_handle_vbus_connected(struct ci_hdrc *ci)
+{
+	u32 otgsc;
+
+	/*
+	 * TODO: if the platform does not supply 5v to udc, or use other way
+	 * to supply 5v, it needs to use other conditions to call
+	 * usb_gadget_vbus_connect.
+	 */
+	if (!ci->is_otg)
+		return;
+
+	otgsc = hw_read(ci, OP_OTGSC, ~0);
+
+	if (otgsc & OTGSC_BSV)
+		usb_gadget_vbus_connect(&ci->gadget);
+}
+
 void ci_handle_vbus_change(struct ci_hdrc *ci)
 {
 	u32 otgsc;
diff --git a/drivers/usb/chipidea/otg.h b/drivers/usb/chipidea/otg.h
index 2d9f090..f171e6b 100644
--- a/drivers/usb/chipidea/otg.h
+++ b/drivers/usb/chipidea/otg.h
@@ -31,5 +31,6 @@ int ci_hdrc_otg_init(struct ci_hdrc *ci);
 void ci_hdrc_otg_destroy(struct ci_hdrc *ci);
 enum ci_role ci_otg_role(struct ci_hdrc *ci);
 void ci_handle_vbus_change(struct ci_hdrc *ci);
+void ci_handle_vbus_connected(struct ci_hdrc *ci);
 
 #endif /* __DRIVERS_USB_CHIPIDEA_OTG_H */
diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c
index b34c819..2359ce5 100644
--- a/drivers/usb/chipidea/udc.c
+++ b/drivers/usb/chipidea/udc.c
@@ -1448,6 +1448,7 @@ static int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
 	struct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);
 	unsigned long flags;
 	int gadget_ready = 0;
+	int ret;
 
 	spin_lock_irqsave(&ci->lock, flags);
 	ci->vbus_active = is_active;
@@ -1455,6 +1456,31 @@ static int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
 		gadget_ready = 1;
 	spin_unlock_irqrestore(&ci->lock, flags);
 
+	/* Charger Detection */
+	if (ci->platdata->notify_event) {
+		/*
+		 * Keep controller active when the cable is connected,
+		 * It can make disconnect interrupt (BSV 1->0) occur when
+		 * the cable is disconnected.
+		 */
+		if (is_active)
+			pm_runtime_get_sync(&_gadget->dev);
+		else
+			pm_runtime_put_sync(&_gadget->dev);
+
+		ret = ci->platdata->notify_event
+			(ci, CI_HDRC_CONTROLLER_CHARGER_EVENT);
+		if (ret == CI_HDRC_NOTIFY_RET_DEFER_EVENT) {
+			hw_device_reset(ci, USBMODE_CM_DC);
+			/* Pull up dp */
+			hw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);
+			ci->platdata->notify_event
+				(ci, CI_HDRC_CONTROLLER_CHARGER_POST_EVENT);
+			/* Pull down dp */
+			hw_write(ci, OP_USBCMD, USBCMD_RS, 0);
+		}
+	}
+
 	if (gadget_ready) {
 		if (is_active) {
 			pm_runtime_get_sync(&_gadget->dev);
@@ -1795,8 +1821,8 @@ static int udc_start(struct ci_hdrc *ci)
 	pm_runtime_no_callbacks(&ci->gadget.dev);
 	pm_runtime_enable(&ci->gadget.dev);
 
-	/* Update ci->vbus_active */
-	ci_handle_vbus_change(ci);
+	/* Notify vbus connected event if it is existed */
+	ci_handle_vbus_connected(ci);
 
 	return retval;
 
diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 8c3b7e2..c75433e 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -30,7 +30,10 @@ struct ci_hdrc_platform_data {
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
-	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+#define CI_HDRC_CONTROLLER_CHARGER_EVENT	2
+#define CI_HDRC_CONTROLLER_CHARGER_POST_EVENT	3
+	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+#define CI_HDRC_NOTIFY_RET_DEFER_EVENT		1
 	struct regulator	*reg_vbus;
 };
 
-- 
1.7.5.4

