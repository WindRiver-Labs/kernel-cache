From 2a59e214b9a245214af4547e7a3a8dc9a96bb5ec Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Mon, 12 Aug 2013 17:17:57 -0400
Subject: [PATCH 0096/1072] ENGR00274768-2 ARM: imx: Use irq #32 for cpuidle
 instead of irq #125

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit cb48392514841a0f80738093bbc0286637402f17

IRQ #125's status is not constant on different boards, IRQ #32 is
IOMUXC's interrupt which can be triggered manually at anytime, use
this irq instead of #125 to generate interrupt for avoiding CCM enter
low power mode by mistake.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/clk-imx6q.c  |    6 +++---
 arch/arm/mach-imx/mach-imx6q.c |   12 ++++++++++++
 2 files changed, 15 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index de5fcb5..fa35c74 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -64,7 +64,7 @@
 #define CGPR				0x64
 #define BM_CGPR_CHICKEN_BIT		(0x1 << 17)
 
-#define MX6Q_INT_PARITY_CHECK_ERROR	125
+#define MX6Q_INT_IOMUXC			32
 
 static void __iomem *ccm_base;
 
@@ -140,7 +140,7 @@ static void imx6q_enable_wb(bool enable)
 int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode)
 {
 	u32 val = readl_relaxed(ccm_base + CLPCR);
-	struct irq_desc *desc = irq_to_desc(MX6Q_INT_PARITY_CHECK_ERROR);
+	struct irq_desc *desc = irq_to_desc(MX6Q_INT_IOMUXC);
 
 	/*
 	 * CCM state machine has restriction, before enabling
@@ -148,7 +148,7 @@ int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode)
 	 * by dsm_wakeup_signal, which means the wakeup source
 	 * must be seen by GPC, then CCM will clean its state machine
 	 * and re-sample necessary signal to decide whether it can
-	 * enter LPM mode. Here we use the forever pending irq #125,
+	 * enter LPM mode. We force irq #32 to be always pending,
 	 * unmask it before we enable LPM mode and mask it after LPM
 	 * is enabled, this flow will make sure CCM state machine in
 	 * reliable status before entering LPM mode. Otherwise, CCM
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index c7f9478..855b1b2 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -302,6 +302,18 @@ static struct platform_device imx6q_cpufreq_pdev = {
 
 static void __init imx6q_init_late(void)
 {
+	struct regmap *gpr;
+
+	/*
+	 * Need to force IOMUXC irq pending to meet CCM low power mode
+	 * restriction, this is recommended by hardware team.
+	 */
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (!IS_ERR(gpr))
+		regmap_update_bits(gpr, IOMUXC_GPR1,
+			IMX6Q_GPR1_GINT_MASK,
+			IMX6Q_GPR1_GINT_ASSERT);
+
 	/*
 	 * WAIT mode is broken on TO 1.0 and 1.1, so there is no point
 	 * to run cpuidle on them.
-- 
1.7.5.4

