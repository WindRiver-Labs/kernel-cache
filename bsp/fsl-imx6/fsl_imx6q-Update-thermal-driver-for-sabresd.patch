From 120a27c487fcfad919a430e7be55a9c0f18e648e Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 13 Jun 2013 17:19:51 +0800
Subject: [PATCH 22/38] fsl_imx6q: Update thermal driver for sabresd

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mxc/thermal/anatop_driver.h |    2 +-
 drivers/mxc/thermal/cooling.c       |   10 +-
 drivers/mxc/thermal/thermal.c       |  333 +++++++++++++++++++++++++----------
 drivers/thermal/thermal_sys.c       |   25 +++
 4 files changed, 279 insertions(+), 91 deletions(-)

diff --git a/drivers/mxc/thermal/anatop_driver.h b/drivers/mxc/thermal/anatop_driver.h
index 63cbdc7..0013eb8 100644
--- a/drivers/mxc/thermal/anatop_driver.h
+++ b/drivers/mxc/thermal/anatop_driver.h
@@ -135,6 +135,6 @@ extern int anatop_thermal_cpu_hotplug(bool cpu_on);
 extern int anatop_thermal_cpufreq_up(void);
 extern int anatop_thermal_cpufreq_down(void);
 extern struct thermal_cooling_device_ops imx_processor_cooling_ops;
-extern void arch_reset(char mode, const char *cmd);
+extern void mxc_restart(char mode, const char *cmd);
 
 #endif /*__ANATOP_DRIVERS_H__*/
diff --git a/drivers/mxc/thermal/cooling.c b/drivers/mxc/thermal/cooling.c
index e5fda9f..50441de 100644
--- a/drivers/mxc/thermal/cooling.c
+++ b/drivers/mxc/thermal/cooling.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,6 +57,8 @@ cpufreq, it minor 1, and when we promote cpufreq, it add 1, so
 if it is 0, mean we didn't change the cpufreq */
 static int cpufreq_change_count;
 
+extern atomic_t thermal_on;
+extern int thermal_notifier_call_chain(unsigned long val);
 int anatop_thermal_get_cpufreq_cur(void)
 {
 	int ret = -EINVAL;
@@ -177,6 +179,7 @@ int anatop_thermal_cpu_hotplug(bool cpu_on)
 					sys_write(fd, (char *)"1", MAX_CPU_ONLINE_LEN);
 					cpu_mask &= ~(0x1 << cpu);
 					ret = 0;
+					sys_close(fd);
 					break;
 				}
 				sys_close(fd);
@@ -198,6 +201,7 @@ int anatop_thermal_cpu_hotplug(bool cpu_on)
 					sys_write(fd, (char *)"0", MAX_CPU_ONLINE_LEN);
 					cpu_mask |= 0x1 << cpu;
 					ret = 0;
+					sys_close(fd);
 					break;
 				}
 				sys_close(fd);
@@ -235,6 +239,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 	secondary CPUs that detached by thermal driver */
 	if (cooling_cpuhotplug) {
 		if (!state) {
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			for (i = 1; i < 4; i++) {
 				if (cpu_mask && (0x1 << i)) {
 					anatop_thermal_cpu_hotplug(true);
@@ -245,6 +251,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 		}
 	} else {
 		if (!state) {
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			if (cpufreq_change_count < 0)
 				anatop_thermal_cpufreq_up();
 			else if (cpufreq_change_count > 0)
diff --git a/drivers/mxc/thermal/thermal.c b/drivers/mxc/thermal/thermal.c
index 9ba1f67..26bf202 100644
--- a/drivers/mxc/thermal/thermal.c
+++ b/drivers/mxc/thermal/thermal.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *  Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -38,17 +38,22 @@
 #include <linux/thermal.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/interrupt.h>
 #include <linux/syscalls.h>
 #include <linux/cpufreq.h>
-#include <mach/common.h>
-
+#include <linux/clk.h>
 #include "anatop_driver.h"
+#include <mach/hardware.h>
 
 /* register define of anatop */
 #define HW_ANADIG_ANA_MISC0	(0x00000150)
 #define HW_ANADIG_ANA_MISC0_SET	(0x00000154)
 #define HW_ANADIG_ANA_MISC0_CLR	(0x00000158)
 #define HW_ANADIG_ANA_MISC0_TOG	(0x0000015c)
+#define HW_ANADIG_ANA_MISC1	(0x00000160)
+#define HW_ANADIG_ANA_MISC1_SET	(0x00000164)
+#define HW_ANADIG_ANA_MISC1_CLR	(0x00000168)
+#define HW_ANADIG_ANA_MISC1_TOG	(0x0000016c)
 
 #define HW_ANADIG_TEMPSENSE0	(0x00000180)
 #define HW_ANADIG_TEMPSENSE0_SET	(0x00000184)
@@ -60,7 +65,12 @@
 #define HW_ANADIG_TEMPSENSE1_CLR	(0x00000198)
 
 #define BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF 0x00000008
+#define BM_ANADIG_ANA_MISC1_IRQ_TEMPSENSE 0x20000000
 
+#define BP_ANADIG_TEMPSENSE0_ALARM_VALUE      20
+#define BM_ANADIG_TEMPSENSE0_ALARM_VALUE 0xFFF00000
+#define BF_ANADIG_TEMPSENSE0_ALARM_VALUE(v)  \
+	(((v) << 20) & BM_ANADIG_TEMPSENSE0_ALARM_VALUE)
 #define BP_ANADIG_TEMPSENSE0_TEMP_VALUE      8
 #define BM_ANADIG_TEMPSENSE0_TEMP_VALUE 0x000FFF00
 #define BF_ANADIG_TEMPSENSE0_TEMP_VALUE(v)  \
@@ -119,27 +129,42 @@
 #define TEMP_CRITICAL			373 /* 100 C*/
 #define TEMP_HOT				363 /* 90 C*/
 #define TEMP_ACTIVE				353 /* 80 C*/
-#define MEASURE_FREQ			327  /* 327 RTC clocks delay, 10ms */
+#define MEASURE_FREQ			3276  /* 3276 RTC clocks delay, 100ms */
 #define KELVIN_TO_CEL(t, off) (((t) - (off)))
 #define CEL_TO_KELVIN(t, off) (((t) + (off)))
 #define DEFAULT_RATIO			145
-#define DEFAULT_N25C			1541
-#define REG_VALUE_TO_CEL(ratio, raw) ((raw_n25c - raw) * 100 / ratio - 25)
+#define DEFAULT_N40C			1563
+#define REG_VALUE_TO_CEL(ratio, raw) ((raw_n40c - raw) * 100 / ratio - 40)
 #define ANATOP_DEBUG			false
 #define THERMAL_FUSE_NAME		"/sys/fsl_otp/HW_OCOTP_ANA1"
 
+#define	FACTOR1		15976
+#define	FACTOR2		4297157
+
 /* variables */
 unsigned long anatop_base;
 unsigned int ratio;
-unsigned int raw_25c, raw_hot, hot_temp, raw_n25c;
+unsigned int raw_25c, raw_hot, hot_temp, raw_n40c, raw_125c, raw_critical;
+static struct clk *pll3_clk;
 static bool full_run = true;
+static bool suspend_flag;
+static unsigned int thermal_irq;
 bool cooling_cpuhotplug;
 bool cooling_device_disable;
+static bool calibration_valid;
 unsigned long temperature_cooling;
 static const struct anatop_device_id thermal_device_ids[] = {
 	{ANATOP_THERMAL_HID},
 	{""},
 };
+atomic_t thermal_on = ATOMIC_INIT(1);
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_VERBOSE = 1U << 1,
+};
+static int debug_mask = DEBUG_USER_STATE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
 
 /* functions */
 static int anatop_thermal_add(struct anatop_device *device);
@@ -147,10 +172,7 @@ static int anatop_thermal_remove(struct platform_device *pdev);
 static int anatop_thermal_suspend(struct platform_device *pdev,
 		pm_message_t state);
 static int anatop_thermal_resume(struct platform_device *pdev);
-#ifdef CONFIG_FSL_OTP
-static int anatop_thermal_get_calibration_data(unsigned int *fuse);
 static int anatop_thermal_counting_ratio(unsigned int fuse_data);
-#endif
 
 /* struct */
 struct anatop_thermal_state {
@@ -233,46 +255,54 @@ static int anatop_dump_temperature_register(void)
 			__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0));
 	pr_info("HW_ANADIG_TEMPSENSE1 = 0x%x\n",
 			__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE1));
+	pr_info("HW_ANADIG_MISC1 = 0x%x\n",
+			__raw_readl(anatop_base + HW_ANADIG_ANA_MISC1));
 	return 0;
 }
+static void anatop_update_alarm(unsigned int alarm_value)
+{
+	if (cooling_device_disable || suspend_flag)
+		return;
+	/* set alarm value */
+	__raw_writel(BM_ANADIG_TEMPSENSE0_ALARM_VALUE,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BF_ANADIG_TEMPSENSE0_ALARM_VALUE(alarm_value),
+		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
+
+	return;
+}
 static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
-				   unsigned long *temp)
+			    unsigned long *temp)
 {
 	struct anatop_thermal *tz = thermal->devdata;
 	unsigned int tmp;
 	unsigned int reg;
-	unsigned int i;
 
 	if (!tz)
 		return -EINVAL;
-#ifdef CONFIG_FSL_OTP
-	if (!ratio) {
-		anatop_thermal_get_calibration_data(&tmp);
+
+	if (!ratio || suspend_flag) {
 		*temp = KELVIN_TO_CEL(TEMP_ACTIVE, KELVIN_OFFSET);
 		return 0;
 	}
-#else
-	if (!cooling_device_disable)
-		pr_info("%s: can't get calibration data, disable cooling!!!\n", __func__);
-	cooling_device_disable = true;
-	ratio = DEFAULT_RATIO;
-#endif
 
 	tz->last_temperature = tz->temperature;
 
-	/* now we only using single measure, every time we measure
-	the temperature, we will power on/down the anadig module*/
-	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
+	if ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0) &
+		BM_ANADIG_TEMPSENSE0_POWER_DOWN) != 0) {
+		/* need to keep sensor power up as we enable alarm
+		function */
+		__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
 			anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
-	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
+		__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
 			anatop_base + HW_ANADIG_ANA_MISC0_SET);
 
-	/* write measure freq */
-	reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE1);
-	reg &= ~BM_ANADIG_TEMPSENSE1_MEASURE_FREQ;
-	reg |= MEASURE_FREQ;
-	__raw_writel(reg, anatop_base + HW_ANADIG_TEMPSENSE1);
-
+		/* write measure freq */
+		reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE1);
+		reg &= ~BM_ANADIG_TEMPSENSE1_MEASURE_FREQ;
+		reg |= MEASURE_FREQ;
+		__raw_writel(reg, anatop_base + HW_ANADIG_TEMPSENSE1);
+	}
 	__raw_writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP,
 		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
 	__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
@@ -281,31 +311,30 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
 
 	tmp = 0;
-	/* read five times of temperature values to get average*/
-	for (i = 0; i < 5; i++) {
-		while ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0)
-			& BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
-			msleep(10);
-		reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0);
-		tmp += (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
-				>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
-		__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
-			anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
-		if (ANATOP_DEBUG)
-			anatop_dump_temperature_register();
-	}
+	/* read temperature values */
+	while ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0)
+		& BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
+		msleep(10);
+
+	reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0);
+	tmp = (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
+		>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
+	__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
 
-	tmp = tmp / 5;
-	if (tmp <= raw_n25c)
+	if (ANATOP_DEBUG)
+		anatop_dump_temperature_register();
+	/* only the temp between -40C and 125C is valid, this
+	is for save */
+	if (tmp <= raw_n40c && tmp >= raw_125c)
 		tz->temperature = REG_VALUE_TO_CEL(ratio, tmp);
-	else
-		tz->temperature = -25;
-	pr_debug("Temperature is %lu C\n", tz->temperature);
-	/* power down anatop thermal sensor */
-	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
-			anatop_base + HW_ANADIG_TEMPSENSE0_SET);
-	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
-			anatop_base + HW_ANADIG_ANA_MISC0_CLR);
+	else {
+		printk(KERN_WARNING "Invalid temperature, force it to 25C\n");
+		tz->temperature = 25;
+	}
+
+	if (debug_mask & DEBUG_VERBOSE)
+		pr_info("Cooling device Temperature is %lu C\n", tz->temperature);
 
 	*temp = (cooling_device_disable && tz->temperature >= KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET)) ?
 			KELVIN_TO_CEL(TEMP_CRITICAL - 1, KELVIN_OFFSET) : tz->temperature;
@@ -454,9 +483,12 @@ static int anatop_thermal_set_trip_temp(struct thermal_zone_device *thermal,
 	switch (trip) {
 	case ANATOP_TRIPS_POINT_CRITICAL:
 		/* Critical Shutdown */
-		if (tz->trips.critical.flags.valid)
+		if (tz->trips.critical.flags.valid) {
 			tz->trips.critical.temperature = CEL_TO_KELVIN(
 				*temp, tz->kelvin_offset);
+			raw_critical = raw_25c - ratio * (*temp - 25) / 100;
+			anatop_update_alarm(raw_critical);
+		}
 		break;
 	case ANATOP_TRIPS_POINT_HOT:
 		/* Hot */
@@ -540,6 +572,27 @@ static int anatop_thermal_get_crit_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 }
 
+static BLOCKING_NOTIFIER_HEAD(thermal_chain_head);
+
+int register_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(register_thermal_notifier);
+
+int unregister_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_thermal_notifier);
+
+int thermal_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&thermal_chain_head, val, NULL)
+		== NOTIFY_BAD) ? -EINVAL : 0;
+}
+EXPORT_SYMBOL_GPL(thermal_notifier_call_chain);
+
 static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			   enum thermal_trip_type trip_type)
 {
@@ -557,6 +610,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 		printk(KERN_WARNING "thermal_notify: trip_critical reached!\n");
 		mxc_restart(mode, cmd);
 	} else if (trip_type == THERMAL_TRIP_HOT) {
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(1);
 		printk(KERN_DEBUG "thermal_notify: trip_hot reached!\n");
 		type = ANATOP_THERMAL_NOTIFY_HOT;
 		/* if temperature increase, continue to detach secondary CPUs*/
@@ -571,6 +626,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			printk(KERN_INFO "No secondary CPUs detached!\n");
 		full_run = false;
 	} else {
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(0);
 		if (!full_run) {
 			temperature_cooling = 0;
 			if (cooling_cpuhotplug)
@@ -794,42 +851,26 @@ static int __init anatop_thermal_cooling_device_disable(char *str)
 }
 __setup("no_cooling_device", anatop_thermal_cooling_device_disable);
 
-#ifdef CONFIG_FSL_OTP
-static int anatop_thermal_get_calibration_data(unsigned int *fuse)
+static int __init anatop_thermal_use_calibration(char *str)
 {
-	int ret = -EINVAL;
-	int fd;
-	char fuse_data[11];
-
-	if (fuse == NULL) {
-		printk(KERN_ERR "%s: NULL pointer!\n", __func__);
-		return ret;
-	}
-
-	fd = sys_open((const char __user __force *)THERMAL_FUSE_NAME,
-		O_RDWR, 0700);
-	if (fd < 0)
-		return ret;
-
-	sys_read(fd, fuse_data, sizeof(fuse_data));
-	sys_close(fd);
-	ret = 0;
-
-	*fuse = simple_strtol(fuse_data, NULL, 0);
-	pr_info("Thermal: fuse data 0x%x\n", *fuse);
-	anatop_thermal_counting_ratio(*fuse);
+	calibration_valid = true;
+	pr_info("%s: use calibration data for thermal sensor!\n", __func__);
 
-	return ret;
+	return 1;
 }
+__setup("use_calibration", anatop_thermal_use_calibration);
 
 static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 {
 	int ret = -EINVAL;
 
-	if (fuse_data == 0 || fuse_data == 0xffffffff) {
+	pr_info("Thermal calibration data is 0x%x\n", fuse_data);
+	if (fuse_data == 0 || fuse_data == 0xffffffff ||
+		(fuse_data & 0xfff00000) == 0) {
 		pr_info("%s: invalid calibration data, disable cooling!!!\n", __func__);
 		cooling_device_disable = true;
 		ratio = DEFAULT_RATIO;
+		disable_irq(thermal_irq);
 		return ret;
 	}
 
@@ -842,18 +883,77 @@ static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 	raw_hot = (fuse_data & 0xfff00) >> 8;
 	hot_temp = fuse_data & 0xff;
 
-	ratio = ((raw_25c - raw_hot) * 100) / (hot_temp - 25);
-	raw_n25c = raw_25c + ratio / 2;
+	if (!calibration_valid && !cpu_is_mx6sl())
+		/*
+		 * The universal equation for thermal sensor
+		 * is slope = 0.4297157 - (0.0015976 * 25C fuse),
+		 * here we convert them to integer to make them
+		 * easy for counting, FACTOR1 is 15976,
+		 * FACTOR2 is 4297157. Our ratio = -100 * slope.
+		 */
+		ratio = ((FACTOR1 * raw_25c - FACTOR2) + 50000) / 100000;
+	else
+		ratio = ((raw_25c - raw_hot) * 100) / (hot_temp - 25);
+
+	pr_info("Thermal sensor with ratio = %d\n", ratio);
+	raw_n40c = raw_25c + (13 * ratio) / 20;
+	raw_125c = raw_25c - ratio;
+	/* Init default critical temp to set alarm */
+	raw_critical = raw_25c - ratio * (KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET) - 25) / 100;
+	clk_enable(pll3_clk);
+	anatop_update_alarm(raw_critical);
 
 	return ret;
 }
-#endif
+
+static irqreturn_t anatop_thermal_alarm_handler(int irq, void *dev_id)
+{
+	char mode = 'r';
+	const char *cmd = "reboot";
+
+	if (cooling_device_disable)
+		return IRQ_HANDLED;
+	printk(KERN_WARNING "\nChip is too hot, reboot!!!\n");
+	/* reboot */
+	mxc_restart(mode, cmd);
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t anatop_thermal_flag_show(struct device *dev,
+		struct device_attribute *attr, char *buf) {
+	return sprintf(buf, "read thermal_hot_flag:%d\n",
+			atomic_read(&thermal_on));
+}
+
+static ssize_t anatop_thermal_flag_store(struct device *dev,
+		struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	int ret;
+	unsigned long data;
+	ret = strict_strtoul(buf, 10, &data);
+	if (data == 0)
+		atomic_set(&thermal_on, 0);
+	else
+		atomic_set(&thermal_on, 1);
+	return count;
+}
+
+static struct device_attribute anatop_thermal_flag_dev_attr = {
+	.attr = {
+		.name = "thermal_hot_flag",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.show = anatop_thermal_flag_show,
+	.store = anatop_thermal_flag_store,
+};
 
 static int anatop_thermal_probe(struct platform_device *pdev)
 {
 	int retval = 0;
-	struct resource *res;
-	void __iomem *base;
+	struct resource *res_io, *res_irq, *res_calibration;
+	void __iomem *base, *calibration_addr;
 	struct anatop_device *device;
 
 	device = kzalloc(sizeof(*device), GFP_KERNEL);
@@ -865,22 +965,57 @@ static int anatop_thermal_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, device);
 
 	/* ioremap the base address */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res == NULL) {
+	res_io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_io == NULL) {
 		dev_err(&pdev->dev, "No anatop base address provided!\n");
 		goto anatop_failed;
 	}
 
-	base = ioremap(res->start, res->end - res->start);
+	base = ioremap(res_io->start, res_io->end - res_io->start);
 	if (base == NULL) {
 		dev_err(&pdev->dev, "failed to remap anatop base address!\n");
 		goto anatop_failed;
 	}
 	anatop_base = (unsigned long)base;
-	raw_n25c = DEFAULT_N25C;
+	/* ioremap the calibration data address */
+	res_calibration = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res_calibration == NULL) {
+		dev_err(&pdev->dev, "No anatop calibration data address provided!\n");
+		goto anatop_failed;
+	}
+
+	calibration_addr = ioremap(res_calibration->start,
+		res_calibration->end - res_calibration->start);
+	if (calibration_addr == NULL) {
+		dev_err(&pdev->dev, "failed to remap anatop calibration data address!\n");
+		goto anatop_failed;
+	}
+
+	pll3_clk = clk_get(NULL, "pll3_main_clk");
+	if (IS_ERR(pll3_clk)) {
+		retval = -ENOENT;
+		goto anatop_failed;
+	}
+
+	raw_n40c = DEFAULT_N40C;
+	/* use calibration data to get ratio */
+	anatop_thermal_counting_ratio(__raw_readl(calibration_addr));
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res_irq == NULL) {
+		dev_err(&pdev->dev, "No anatop thermal irq provided!\n");
+		goto anatop_failed;
+	}
+	retval = request_irq(res_irq->start, anatop_thermal_alarm_handler, 0, "THERMAL_ALARM_IRQ",
+			  NULL);
+	thermal_irq = res_irq->start;
+
 
 	anatop_thermal_add(device);
 	anatop_thermal_cpufreq_init();
+	retval = device_create_file(&pdev->dev, &anatop_thermal_flag_dev_attr);
+	if (retval)
+		dev_err(&pdev->dev, "create device file failed!\n");
 	pr_info("%s: default cooling device is cpufreq!\n", __func__);
 
 	goto success;
@@ -910,10 +1045,30 @@ static int anatop_thermal_remove(struct platform_device *pdev)
 static int anatop_thermal_suspend(struct platform_device *pdev,
 		pm_message_t state)
 {
+	/* turn off alarm */
+	anatop_update_alarm(0);
+	suspend_flag = true;
+	/* Power down anatop thermal sensor */
+	__raw_writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
+		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
+	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
+		anatop_base + HW_ANADIG_ANA_MISC0_CLR);
 	return 0;
 }
 static int anatop_thermal_resume(struct platform_device *pdev)
 {
+	/* Power up anatop thermal sensor */
+	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
+		anatop_base + HW_ANADIG_ANA_MISC0_SET);
+	suspend_flag = false;
+	/* turn on alarm */
+	anatop_update_alarm(raw_critical);
 	return 0;
 }
 
diff --git a/drivers/thermal/thermal_sys.c b/drivers/thermal/thermal_sys.c
index 914877b..3de4412 100644
--- a/drivers/thermal/thermal_sys.c
+++ b/drivers/thermal/thermal_sys.c
@@ -903,9 +903,34 @@ static void thermal_release(struct device *dev)
 	}
 }
 
+static int thermal_suspend(struct device *dev, pm_message_t state)
+{
+	struct thermal_zone_device *tz;
+	if (!strncmp(dev_name(dev), "thermal_zone", strlen("thermal_zone"))) {
+		tz = to_thermal_zone(dev);
+		thermal_zone_device_set_polling(tz, 0);
+	}
+	return 0;
+}
+
+static int themal_resume(struct device *dev)
+{
+	struct thermal_zone_device *tz;
+	if (!strncmp(dev_name(dev), "thermal_zone", strlen("thermal_zone"))) {
+		tz = to_thermal_zone(dev);
+		if (tz->passive)
+			thermal_zone_device_set_polling(tz, tz->passive_delay);
+		else if (tz->polling_delay)
+			thermal_zone_device_set_polling(tz, tz->polling_delay);
+	}
+	return 0;
+}
+
 static struct class thermal_class = {
 	.name = "thermal",
 	.dev_release = thermal_release,
+	.suspend = thermal_suspend,
+	.resume = themal_resume,
 };
 
 /**
-- 
1.7.5.4

