From f6153ae77e17620a1dc0b32e705d5b493a3e88fa Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Jun 2013 17:22:05 +0800
Subject: [PATCH 07/38] fsl_imx6q: Update SDMA driver and firmware

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/clock.c                 |    2 +-
 drivers/dma/Kconfig                       |   10 +
 drivers/dma/Makefile                      |    1 +
 drivers/dma/imx-sdma.c                    |  612 +++++++----
 drivers/dma/pxp/Makefile                  |    3 +
 drivers/dma/pxp/pxp_device.c              |  521 +++++++++
 drivers/dma/pxp/pxp_dma.c                 | 1565 +++++++++++++++++++++++++++
 drivers/dma/pxp/pxp_dma_v2.c              | 1683 +++++++++++++++++++++++++++++
 drivers/dma/pxp/regs-pxp.h                |  949 ++++++++++++++++
 drivers/dma/pxp/regs-pxp_v2.h             | 1152 ++++++++++++++++++++
 firmware/imx/sdma/sdma-imx6q-to1.bin.ihex |  194 ++--
 11 files changed, 6381 insertions(+), 311 deletions(-)
 create mode 100644 drivers/dma/pxp/Makefile
 create mode 100644 drivers/dma/pxp/pxp_device.c
 create mode 100644 drivers/dma/pxp/pxp_dma.c
 create mode 100644 drivers/dma/pxp/pxp_dma_v2.c
 create mode 100644 drivers/dma/pxp/regs-pxp.h
 create mode 100644 drivers/dma/pxp/regs-pxp_v2.h

diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index 6198fe5..ddc2f1a 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -5240,7 +5240,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "ipg_clk", ipg_clk),
 	_REGISTER_CLOCK(NULL, "ipg_perclk", ipg_perclk),
 	_REGISTER_CLOCK(NULL, "spba", spba_clk),
-	_REGISTER_CLOCK("imx35-sdma", NULL, sdma_clk[0]),
+	_REGISTER_CLOCK("imx-sdma", NULL, sdma_clk[0]),
 	_REGISTER_CLOCK(NULL, "gpu2d_axi_clk", gpu2d_axi_clk),
 	_REGISTER_CLOCK(NULL, "gpu3d_axi_clk", gpu3d_axi_clk),
 	_REGISTER_CLOCK(NULL, "pcie_axi_clk", pcie_axi_clk),
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index ef378b5..93fef18 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -121,6 +121,16 @@ config MV_XOR
 	---help---
 	  Enable support for the Marvell XOR engine.
 
+config MXC_PXP_V2
+    bool "MXC PxP V2 support"
+    depends on ARCH_MX6
+    select DMA_ENGINE
+
+config MXC_PXP_CLIENT_DEVICE
+    bool "MXC PxP Client Device"
+    default y
+    depends on MXC_PXP || MXC_PXP_V2
+
 config MX3_IPU
 	bool "MX3x Image Processing Unit support"
 	depends on ARCH_MXC
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 59c10e5..b4ea16b 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -28,3 +28,4 @@ obj-$(CONFIG_PCH_DMA) += pch_dma.o
 obj-$(CONFIG_AMBA_PL08X) += amba-pl08x.o
 obj-$(CONFIG_EP93XX_DMA) += ep93xx_dma.o
 obj-$(CONFIG_DMA_SA11X0) += sa11x0-dma.o
+obj-y += pxp/
diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index 52529f5..b08bd1e 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -7,7 +7,7 @@
  *
  * Based on code from Freescale:
  *
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2012 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -18,13 +18,11 @@
  */
 
 #include <linux/init.h>
-#include <linux/module.h>
 #include <linux/types.h>
-#include <linux/bitops.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/clk.h>
-#include <linux/delay.h>
+#include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/semaphore.h>
 #include <linux/spinlock.h>
@@ -34,16 +32,14 @@
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <mach/sdma.h>
 #include <mach/dma.h>
 #include <mach/hardware.h>
 
-#include "dmaengine.h"
-
 /* SDMA registers */
 #define SDMA_H_C0PTR		0x000
 #define SDMA_H_INTR		0x004
@@ -71,8 +67,8 @@
 #define SDMA_ONCE_RTB		0x060
 #define SDMA_XTRIG_CONF1	0x070
 #define SDMA_XTRIG_CONF2	0x074
-#define SDMA_CHNENBL0_IMX35	0x200
-#define SDMA_CHNENBL0_IMX31	0x080
+#define SDMA_CHNENBL0_V2	0x200
+#define SDMA_CHNENBL0_V1	0x080
 #define SDMA_CHNPRI_0		0x100
 
 /*
@@ -232,6 +228,14 @@ struct sdma_context_data {
 
 struct sdma_engine;
 
+enum sdma_mode {
+	SDMA_MODE_INVALID = 0,
+	SDMA_MODE_LOOP,
+	SDMA_MODE_NORMAL,
+	SDMA_MODE_P2P,
+	SDMA_MODE_NO_BD,
+};
+
 /**
  * struct sdma_channel - housekeeping for a SDMA channel
  *
@@ -259,22 +263,27 @@ struct sdma_channel {
 	unsigned int			num_bd;
 	struct sdma_buffer_descriptor	*bd;
 	dma_addr_t			bd_phys;
-	unsigned int			pc_from_device, pc_to_device;
-	unsigned long			flags;
-	dma_addr_t			per_address;
-	unsigned long			event_mask[2];
-	unsigned long			watermark_level;
+	unsigned int			pc_from_device;
+	unsigned int			pc_to_device;
+	unsigned int			device_to_device;
+	unsigned int			other_script;
+	unsigned int                    pc_to_pc;
+	enum sdma_mode			mode;
+	dma_addr_t			per_address, per_address2;
+	u32				event_mask0, event_mask1;
+	u32				watermark_level;
 	u32				shp_addr, per_addr;
+	u32				data_addr1, data_addr2;
 	struct dma_chan			chan;
 	spinlock_t			lock;
 	struct dma_async_tx_descriptor	desc;
+	dma_cookie_t			last_completed;
 	enum dma_status			status;
 	unsigned int			chn_count;
 	unsigned int			chn_real_count;
+	unsigned int			irq_handling;
 };
 
-#define IMX_DMA_SG_LOOP		BIT(0)
-
 #define MAX_DMA_CHANNELS 32
 #define MXC_SDMA_DEFAULT_PRIORITY 1
 #define MXC_SDMA_MIN_PRIORITY 1
@@ -306,56 +315,31 @@ struct sdma_firmware_header {
 	u32	ram_code_size;
 };
 
-enum sdma_devtype {
-	IMX31_SDMA,	/* runs on i.mx31 */
-	IMX35_SDMA,	/* runs on i.mx35 and later */
-};
-
 struct sdma_engine {
 	struct device			*dev;
 	struct device_dma_parameters	dma_parms;
 	struct sdma_channel		channel[MAX_DMA_CHANNELS];
 	struct sdma_channel_control	*channel_control;
 	void __iomem			*regs;
-	enum sdma_devtype		devtype;
+	unsigned int			version;
 	unsigned int			num_events;
 	struct sdma_context_data	*context;
 	dma_addr_t			context_phys;
 	struct dma_device		dma_device;
 	struct clk			*clk;
-	spinlock_t			channel_0_lock;
 	struct sdma_script_start_addrs	*script_addrs;
+	spinlock_t			irq_reg_lock;
 };
 
-static struct platform_device_id sdma_devtypes[] = {
-	{
-		.name = "imx31-sdma",
-		.driver_data = IMX31_SDMA,
-	}, {
-		.name = "imx35-sdma",
-		.driver_data = IMX35_SDMA,
-	}, {
-		/* sentinel */
-	}
-};
-MODULE_DEVICE_TABLE(platform, sdma_devtypes);
-
-static const struct of_device_id sdma_dt_ids[] = {
-	{ .compatible = "fsl,imx31-sdma", .data = &sdma_devtypes[IMX31_SDMA], },
-	{ .compatible = "fsl,imx35-sdma", .data = &sdma_devtypes[IMX35_SDMA], },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, sdma_dt_ids);
-
-#define SDMA_H_CONFIG_DSPDMA	BIT(12) /* indicates if the DSPDMA is used */
-#define SDMA_H_CONFIG_RTD_PINS	BIT(11) /* indicates if Real-Time Debug pins are enabled */
-#define SDMA_H_CONFIG_ACR	BIT(4)  /* indicates if AHB freq /core freq = 2 or 1 */
+#define SDMA_H_CONFIG_DSPDMA	(1 << 12) /* indicates if the DSPDMA is used */
+#define SDMA_H_CONFIG_RTD_PINS	(1 << 11) /* indicates if Real-Time Debug pins are enabled */
+#define SDMA_H_CONFIG_ACR	(1 << 4)  /* indicates if AHB freq /core freq = 2 or 1 */
 #define SDMA_H_CONFIG_CSM	(3)       /* indicates which context switch mode is selected*/
 
 static inline u32 chnenbl_ofs(struct sdma_engine *sdma, unsigned int event)
 {
-	u32 chnenbl0 = (sdma->devtype == IMX31_SDMA ? SDMA_CHNENBL0_IMX31 :
-						      SDMA_CHNENBL0_IMX35);
+	u32 chnenbl0 = (sdma->version == 2 ? SDMA_CHNENBL0_V2 : SDMA_CHNENBL0_V1);
+
 	return chnenbl0 + event * 4;
 }
 
@@ -364,7 +348,7 @@ static int sdma_config_ownership(struct sdma_channel *sdmac,
 {
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
-	unsigned long evt, mcu, dsp;
+	u32 evt, mcu, dsp;
 
 	if (event_override && mcu_override && dsp_override)
 		return -EINVAL;
@@ -374,19 +358,19 @@ static int sdma_config_ownership(struct sdma_channel *sdmac,
 	dsp = readl_relaxed(sdma->regs + SDMA_H_DSPOVR);
 
 	if (dsp_override)
-		__clear_bit(channel, &dsp);
+		dsp &= ~(1 << channel);
 	else
-		__set_bit(channel, &dsp);
+		dsp |= (1 << channel);
 
 	if (event_override)
-		__clear_bit(channel, &evt);
+		evt &= ~(1 << channel);
 	else
-		__set_bit(channel, &evt);
+		evt |= (1 << channel);
 
 	if (mcu_override)
-		__clear_bit(channel, &mcu);
+		mcu &= ~(1 << channel);
 	else
-		__set_bit(channel, &mcu);
+		mcu |= (1 << channel);
 
 	writel_relaxed(evt, sdma->regs + SDMA_H_EVTOVR);
 	writel_relaxed(mcu, sdma->regs + SDMA_H_HOSTOVR);
@@ -395,33 +379,21 @@ static int sdma_config_ownership(struct sdma_channel *sdmac,
 	return 0;
 }
 
-static void sdma_enable_channel(struct sdma_engine *sdma, int channel)
-{
-	writel(BIT(channel), sdma->regs + SDMA_H_START);
-}
-
 /*
- * sdma_run_channel0 - run a channel and wait till it's done
+ * sdma_run_channel - run a channel and wait till it's done
  */
-static int sdma_run_channel0(struct sdma_engine *sdma)
+static int sdma_run_channel(struct sdma_channel *sdmac)
 {
+	struct sdma_engine *sdma = sdmac->sdma;
+	int channel = sdmac->channel;
 	int ret;
-	unsigned long timeout = 500;
 
-	sdma_enable_channel(sdma, 0);
+	init_completion(&sdmac->done);
 
-	while (!(ret = readl_relaxed(sdma->regs + SDMA_H_INTR) & 1)) {
-		if (timeout-- <= 0)
-			break;
-		udelay(1);
-	}
+	wmb();
+	writel_relaxed(1 << channel, sdma->regs + SDMA_H_START);
 
-	if (ret) {
-		/* Clear the interrupt status */
-		writel_relaxed(ret, sdma->regs + SDMA_H_INTR);
-	} else {
-		dev_err(sdma->dev, "Timeout waiting for CH0 ready\n");
-	}
+	ret = wait_for_completion_timeout(&sdmac->done, HZ);
 
 	return ret ? 0 : -ETIMEDOUT;
 }
@@ -433,16 +405,12 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 	void *buf_virt;
 	dma_addr_t buf_phys;
 	int ret;
-	unsigned long flags;
 
 	buf_virt = dma_alloc_coherent(NULL,
 			size,
 			&buf_phys, GFP_KERNEL);
-	if (!buf_virt) {
+	if (!buf_virt)
 		return -ENOMEM;
-	}
-
-	spin_lock_irqsave(&sdma->channel_0_lock, flags);
 
 	bd0->mode.command = C0_SETPM;
 	bd0->mode.status = BD_DONE | BD_INTR | BD_WRAP | BD_EXTD;
@@ -452,9 +420,7 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 
 	memcpy(buf_virt, buf, size);
 
-	ret = sdma_run_channel0(sdma);
-
-	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
+	ret = sdma_run_channel(&sdma->channel[0]);
 
 	dma_free_coherent(NULL, size, buf_virt, buf_phys);
 
@@ -465,11 +431,11 @@ static void sdma_event_enable(struct sdma_channel *sdmac, unsigned int event)
 {
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
-	unsigned long val;
+	u32 val;
 	u32 chnenbl = chnenbl_ofs(sdma, event);
 
 	val = readl_relaxed(sdma->regs + chnenbl);
-	__set_bit(channel, &val);
+	val |= (1 << channel);
 	writel_relaxed(val, sdma->regs + chnenbl);
 }
 
@@ -478,17 +444,16 @@ static void sdma_event_disable(struct sdma_channel *sdmac, unsigned int event)
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
 	u32 chnenbl = chnenbl_ofs(sdma, event);
-	unsigned long val;
+	u32 val;
 
 	val = readl_relaxed(sdma->regs + chnenbl);
-	__clear_bit(channel, &val);
+	val &= ~(1 << channel);
 	writel_relaxed(val, sdma->regs + chnenbl);
 }
 
 static void sdma_handle_channel_loop(struct sdma_channel *sdmac)
 {
 	struct sdma_buffer_descriptor *bd;
-
 	/*
 	 * loop mode. Iterate over descriptors, re-setup them and
 	 * call callback function.
@@ -536,7 +501,16 @@ static void mxc_sdma_handle_channel_normal(struct sdma_channel *sdmac)
 	else
 		sdmac->status = DMA_SUCCESS;
 
-	dma_cookie_complete(&sdmac->desc);
+	sdmac->last_completed = sdmac->desc.cookie;
+	if (sdmac->desc.callback)
+		sdmac->desc.callback(sdmac->desc.callback_param);
+}
+
+
+static void sdma_handle_other_intr(struct sdma_channel *sdmac)
+{
+	sdmac->last_completed = sdmac->desc.cookie;
+
 	if (sdmac->desc.callback)
 		sdmac->desc.callback(sdmac->desc.callback_param);
 }
@@ -545,29 +519,56 @@ static void mxc_sdma_handle_channel(struct sdma_channel *sdmac)
 {
 	complete(&sdmac->done);
 
-	if (sdmac->flags & IMX_DMA_SG_LOOP)
+	/* not interested in channel 0 interrupts */
+	if (sdmac->channel == 0)
+		return;
+
+	switch (sdmac->mode) {
+	case SDMA_MODE_LOOP:
 		sdma_handle_channel_loop(sdmac);
-	else
+		break;
+	case SDMA_MODE_NORMAL:
 		mxc_sdma_handle_channel_normal(sdmac);
+		break;
+	case SDMA_MODE_NO_BD:
+		sdma_handle_other_intr(sdmac);
+		break;
+	default:
+		pr_err("Unvalid SDMA MODE!\n");
+		break;
+	}
 }
 
 static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 {
 	struct sdma_engine *sdma = dev_id;
-	unsigned long stat;
+	struct sdma_channel *sdmac;
+	unsigned long flag;
+	int channel;
+	u32 stat, stat_bak;
 
+	spin_lock_irqsave(&sdma->irq_reg_lock, flag);
 	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
-	/* not interested in channel 0 interrupts */
-	stat &= ~1;
 	writel_relaxed(stat, sdma->regs + SDMA_H_INTR);
+	spin_unlock_irqrestore(&sdma->irq_reg_lock, flag);
+
+	stat_bak = stat;
+	while (stat_bak) {
+		channel = fls(stat_bak) - 1;
+		sdmac = &sdma->channel[channel];
+		sdmac->irq_handling = 1;
+		stat_bak &= ~(1 << channel);
+	}
 
 	while (stat) {
-		int channel = fls(stat) - 1;
-		struct sdma_channel *sdmac = &sdma->channel[channel];
+		channel = fls(stat) - 1;
+		sdmac = &sdma->channel[channel];
 
-		mxc_sdma_handle_channel(sdmac);
+		if (sdmac->irq_handling)
+			mxc_sdma_handle_channel(sdmac);
 
-		__clear_bit(channel, &stat);
+		stat &= ~(1 << channel);
+		sdmac->irq_handling = 0;
 	}
 
 	return IRQ_HANDLED;
@@ -586,9 +587,13 @@ static void sdma_get_pc(struct sdma_channel *sdmac,
 	 * two peripherals or memory-to-memory transfers
 	 */
 	int per_2_per = 0, emi_2_emi = 0;
+	int other = 0;
 
 	sdmac->pc_from_device = 0;
 	sdmac->pc_to_device = 0;
+	sdmac->device_to_device = 0;
+	sdmac->other_script = 0;
+	sdmac->pc_to_pc = 0;
 
 	switch (peripheral_type) {
 	case IMX_DMATYPE_MEMORY:
@@ -621,6 +626,9 @@ static void sdma_get_pc(struct sdma_channel *sdmac,
 		emi_2_per = sdma->script_addrs->mcu_2_app_addr;
 		break;
 	case IMX_DMATYPE_SSI_SP:
+		per_2_emi = sdma->script_addrs->ssish_2_mcu_addr;
+		emi_2_per = sdma->script_addrs->mcu_2_ssish_addr;
+		break;
 	case IMX_DMATYPE_MMC:
 	case IMX_DMATYPE_SDHC:
 	case IMX_DMATYPE_CSPI_SP:
@@ -648,12 +656,37 @@ static void sdma_get_pc(struct sdma_channel *sdmac,
 	case IMX_DMATYPE_IPU_MEMORY:
 		emi_2_per = sdma->script_addrs->ext_mem_2_ipu_addr;
 		break;
+	case IMX_DMATYPE_HDMI:
+		other = sdma->script_addrs->hdmi_dma_addr;
 	default:
 		break;
 	}
 
 	sdmac->pc_from_device = per_2_emi;
 	sdmac->pc_to_device = emi_2_per;
+	sdmac->device_to_device = per_2_per;
+	sdmac->other_script = other;
+	sdmac->pc_to_pc = emi_2_emi;
+}
+
+static int sdma_set_context_reg(struct sdma_channel *sdmac,
+				struct sdma_context_data *context)
+{
+	switch (sdmac->peripheral_type) {
+	case IMX_DMATYPE_HDMI:
+		context->gReg[4] = sdmac->data_addr1;
+		context->gReg[6] = sdmac->data_addr2;
+		break;
+	default:
+		context->gReg[0] = sdmac->event_mask1;
+		context->gReg[1] = sdmac->event_mask0;
+		context->gReg[2] = sdmac->per_addr;
+		context->gReg[6] = sdmac->shp_addr;
+		context->gReg[7] = sdmac->watermark_level;
+		break;
+	}
+
+	return 0;
 }
 
 static int sdma_load_context(struct sdma_channel *sdmac)
@@ -664,25 +697,29 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	struct sdma_context_data *context = sdma->context;
 	struct sdma_buffer_descriptor *bd0 = sdma->channel[0].bd;
 	int ret;
-	unsigned long flags;
 
-	if (sdmac->direction == DMA_DEV_TO_MEM) {
+
+	if (sdmac->direction == DMA_DEV_TO_MEM)
 		load_address = sdmac->pc_from_device;
-	} else {
+	else if (sdmac->direction == DMA_DEV_TO_DEV)
+		load_address = sdmac->device_to_device;
+	else if (sdmac->direction == DMA_MEM_TO_DEV)
 		load_address = sdmac->pc_to_device;
-	}
+	else if (sdmac->direction == DMA_MEM_TO_MEM)
+		load_address = sdmac->pc_to_pc;
+	else
+		load_address = sdmac->other_script;
+
 
 	if (load_address < 0)
 		return load_address;
 
 	dev_dbg(sdma->dev, "load_address = %d\n", load_address);
-	dev_dbg(sdma->dev, "wml = 0x%08x\n", (u32)sdmac->watermark_level);
+	dev_dbg(sdma->dev, "wml = 0x%08x\n", sdmac->watermark_level);
 	dev_dbg(sdma->dev, "shp_addr = 0x%08x\n", sdmac->shp_addr);
 	dev_dbg(sdma->dev, "per_addr = 0x%08x\n", sdmac->per_addr);
-	dev_dbg(sdma->dev, "event_mask0 = 0x%08x\n", (u32)sdmac->event_mask[0]);
-	dev_dbg(sdma->dev, "event_mask1 = 0x%08x\n", (u32)sdmac->event_mask[1]);
-
-	spin_lock_irqsave(&sdma->channel_0_lock, flags);
+	dev_dbg(sdma->dev, "event_mask0 = 0x%08x\n", sdmac->event_mask0);
+	dev_dbg(sdma->dev, "event_mask1 = 0x%08x\n", sdmac->event_mask1);
 
 	memset(context, 0, sizeof(*context));
 	context->channel_state.pc = load_address;
@@ -690,20 +727,15 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	/* Send by context the event mask,base address for peripheral
 	 * and watermark level
 	 */
-	context->gReg[0] = sdmac->event_mask[1];
-	context->gReg[1] = sdmac->event_mask[0];
-	context->gReg[2] = sdmac->per_addr;
-	context->gReg[6] = sdmac->shp_addr;
-	context->gReg[7] = sdmac->watermark_level;
+	sdma_set_context_reg(sdmac, context);
 
 	bd0->mode.command = C0_SETDM;
 	bd0->mode.status = BD_DONE | BD_INTR | BD_WRAP | BD_EXTD;
 	bd0->mode.count = sizeof(*context) / 4;
 	bd0->buffer_addr = sdma->context_phys;
 	bd0->ext_buffer_addr = 2048 + (sizeof(*context) / 4) * channel;
-	ret = sdma_run_channel0(sdma);
 
-	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
+	ret = sdma_run_channel(&sdma->channel[0]);
 
 	return ret;
 }
@@ -713,26 +745,56 @@ static void sdma_disable_channel(struct sdma_channel *sdmac)
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
 
-	writel_relaxed(BIT(channel), sdma->regs + SDMA_H_STATSTOP);
+	writel_relaxed(1 << channel, sdma->regs + SDMA_H_STATSTOP);
 	sdmac->status = DMA_ERROR;
 }
 
+static int sdma_set_chan_private_data(struct sdma_channel *sdmac)
+{
+	struct sdma_engine *sdma = sdmac->sdma;
+	struct imx_dma_data *data = sdmac->chan.private;
+
+	sdmac->shp_addr = 0;
+	sdmac->per_addr = 0;
+	sdmac->data_addr1 = 0;
+	sdmac->data_addr2 = 0;
+
+
+	if (sdmac->direction == DMA_DEV_TO_DEV) {
+		sdmac->per_addr = sdmac->per_address;
+		sdmac->shp_addr = sdmac->per_address2;
+	} else if (sdmac->direction == DMA_TRANS_NONE) {
+		switch (sdmac->peripheral_type) {
+		case IMX_DMATYPE_HDMI:
+			sdmac->data_addr1 = *(u32 *)data->private;;
+			sdmac->data_addr2 = *((u32 *)data->private + 1);
+			break;
+		default:
+			dev_dbg(sdma->dev,
+			"periphal type not support for DMA_TRANS_NONE!\n");
+			break;
+		}
+	} else {
+		sdmac->shp_addr = sdmac->per_address;
+	}
+
+	return 0;
+}
+
 static int sdma_config_channel(struct sdma_channel *sdmac)
 {
 	int ret;
 
 	sdma_disable_channel(sdmac);
 
-	sdmac->event_mask[0] = 0;
-	sdmac->event_mask[1] = 0;
-	sdmac->shp_addr = 0;
-	sdmac->per_addr = 0;
+	sdmac->event_mask0 = 0;
+	sdmac->event_mask1 = 0;
 
-	if (sdmac->event_id0) {
-		if (sdmac->event_id0 >= sdmac->sdma->num_events)
-			return -EINVAL;
+	if (sdmac->event_id0)
 		sdma_event_enable(sdmac, sdmac->event_id0);
-	}
+
+	if (sdmac->event_id1)
+		sdma_event_enable(sdmac, sdmac->event_id1);
 
 	switch (sdmac->peripheral_type) {
 	case IMX_DMATYPE_DSP:
@@ -749,25 +811,50 @@ static int sdma_config_channel(struct sdma_channel *sdmac)
 	sdma_get_pc(sdmac, sdmac->peripheral_type);
 
 	if ((sdmac->peripheral_type != IMX_DMATYPE_MEMORY) &&
-			(sdmac->peripheral_type != IMX_DMATYPE_DSP)) {
+			(sdmac->peripheral_type != IMX_DMATYPE_DSP) &&
+			(sdmac->peripheral_type != IMX_DMATYPE_HDMI)) {
 		/* Handle multiple event channels differently */
 		if (sdmac->event_id1) {
-			sdmac->event_mask[1] = BIT(sdmac->event_id1 % 32);
-			if (sdmac->event_id1 > 31)
-				__set_bit(31, &sdmac->watermark_level);
-			sdmac->event_mask[0] = BIT(sdmac->event_id0 % 32);
-			if (sdmac->event_id0 > 31)
-				__set_bit(30, &sdmac->watermark_level);
+			if (sdmac->event_id0 > 31) {
+				sdmac->watermark_level |= 1 << 28;
+				sdmac->event_mask0 |= 0;
+				sdmac->event_mask1 |=
+					1 << ((sdmac->event_id0)%32);
+			} else {
+				sdmac->event_mask0 |=
+					1 << ((sdmac->event_id0)%32);
+				sdmac->event_mask1 |= 0;
+			}
+			if (sdmac->event_id1 > 31) {
+				sdmac->watermark_level |= 1 << 29;
+				sdmac->event_mask0 |= 0;
+				sdmac->event_mask1 |=
+					1 << ((sdmac->event_id1)%32);
+			} else {
+				sdmac->event_mask0 |=
+					1 << ((sdmac->event_id1)%32);
+				sdmac->event_mask1 |= 0;
+			}
+			sdmac->watermark_level |= (unsigned int)(3<<11);
+			sdmac->watermark_level |= (unsigned int)(1<<31);
+			sdmac->watermark_level |= (unsigned int)(2<<24);
 		} else {
-			__set_bit(sdmac->event_id0, sdmac->event_mask);
+			if (sdmac->event_id0 > 31) {
+				sdmac->event_mask0 = 0;
+				sdmac->event_mask1 =
+					1 << ((sdmac->event_id0)%32);
+			} else {
+				sdmac->event_mask0 =
+					1 << ((sdmac->event_id0)%32);
+				sdmac->event_mask1 = 0;
+			}
 		}
 		/* Watermark Level */
 		sdmac->watermark_level |= sdmac->watermark_level;
-		/* Address */
-		sdmac->shp_addr = sdmac->per_address;
 	} else {
 		sdmac->watermark_level = 0; /* FIXME: M3_BASE_ADDRESS */
 	}
+	sdma_set_chan_private_data(sdmac);
 
 	ret = sdma_load_context(sdmac);
 
@@ -807,18 +894,41 @@ static int sdma_request_channel(struct sdma_channel *sdmac)
 	sdma->channel_control[channel].base_bd_ptr = sdmac->bd_phys;
 	sdma->channel_control[channel].current_bd_ptr = sdmac->bd_phys;
 
+	clk_enable(sdma->clk);
+
 	sdma_set_channel_priority(sdmac, MXC_SDMA_DEFAULT_PRIORITY);
 
 	init_completion(&sdmac->done);
 
 	sdmac->buf_tail = 0;
 
+	sdmac->irq_handling = 0;
+
 	return 0;
 out:
 
 	return ret;
 }
 
+static void sdma_enable_channel(struct sdma_engine *sdma, int channel)
+{
+	wmb();
+	writel(1 << channel, sdma->regs + SDMA_H_START);
+}
+
+static dma_cookie_t sdma_assign_cookie(struct sdma_channel *sdmac)
+{
+	dma_cookie_t cookie = sdmac->chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	sdmac->chan.cookie = cookie;
+	sdmac->desc.cookie = cookie;
+
+	return cookie;
+}
+
 static struct sdma_channel *to_sdma_chan(struct dma_chan *chan)
 {
 	return container_of(chan, struct sdma_channel, chan);
@@ -826,15 +936,18 @@ static struct sdma_channel *to_sdma_chan(struct dma_chan *chan)
 
 static dma_cookie_t sdma_tx_submit(struct dma_async_tx_descriptor *tx)
 {
-	unsigned long flags;
 	struct sdma_channel *sdmac = to_sdma_chan(tx->chan);
+	struct sdma_engine *sdma = sdmac->sdma;
 	dma_cookie_t cookie;
+	unsigned long flag;
 
-	spin_lock_irqsave(&sdmac->lock, flags);
+	spin_lock_irqsave(&sdmac->lock, flag);
 
-	cookie = dma_cookie_assign(tx);
+	cookie = sdma_assign_cookie(sdmac);
 
-	spin_unlock_irqrestore(&sdmac->lock, flags);
+	sdma_enable_channel(sdma, sdmac->channel);
+
+	spin_unlock_irqrestore(&sdmac->lock, flag);
 
 	return cookie;
 }
@@ -863,9 +976,10 @@ static int sdma_alloc_chan_resources(struct dma_chan *chan)
 
 	sdmac->peripheral_type = data->peripheral_type;
 	sdmac->event_id0 = data->dma_request;
-
-	clk_enable(sdmac->sdma->clk);
-
+	if (data->dma_request_p2p > 0)
+		sdmac->event_id1 = data->dma_request_p2p;
+	else
+		sdmac->event_id1 = 0;
 	ret = sdma_request_channel(sdmac);
 	if (ret)
 		return ret;
@@ -879,14 +993,47 @@ static int sdma_alloc_chan_resources(struct dma_chan *chan)
 	/* txd.flags will be overwritten in prep funcs */
 	sdmac->desc.flags = DMA_CTRL_ACK;
 
+	/* Set SDMA channel mode to unvalid to avoid misconfig */
+	sdmac->mode = SDMA_MODE_INVALID;
+
 	return 0;
 }
 
+static void sdma_irq_pending_check(struct sdma_channel *sdmac)
+{
+	struct sdma_engine *sdma = sdmac->sdma;
+	unsigned long flag;
+	u32 stat;
+
+	spin_lock_irqsave(&sdma->irq_reg_lock, flag);
+	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
+
+	/*Check if the current channel's IRQ hasn't been responded*/
+	if (stat & (1 << sdmac->channel)) {
+		/*Handle the irq manually*/
+		writel_relaxed(1 << sdmac->channel, sdma->regs + SDMA_H_INTR);
+		spin_unlock_irqrestore(&sdma->irq_reg_lock, flag);
+
+		/*Prevent irq_handler from doing handle_channel() again*/
+		sdmac->irq_handling = 0;
+		mxc_sdma_handle_channel(sdmac);
+	} else {
+		spin_unlock_irqrestore(&sdma->irq_reg_lock, flag);
+	}
+
+	/*Wait here until irq_handler's finished*/
+	while (sdmac->irq_handling)
+		udelay(100);
+}
+
 static void sdma_free_chan_resources(struct dma_chan *chan)
 {
 	struct sdma_channel *sdmac = to_sdma_chan(chan);
 	struct sdma_engine *sdma = sdmac->sdma;
 
+	/*Check if irq to the channel is still pending*/
+	sdma_irq_pending_check(sdmac);
+
 	sdma_disable_channel(sdmac);
 
 	if (sdmac->event_id0)
@@ -915,11 +1062,23 @@ static struct dma_async_tx_descriptor *sdma_prep_slave_sg(
 	int channel = sdmac->channel;
 	struct scatterlist *sg;
 
-	if (sdmac->status == DMA_IN_PROGRESS)
-		return NULL;
+	/*
+	 * For SDMA M2M use, we need 2 scatterlists, the src addresses are
+	 * stored in the first sg, and the dst addresses are stored in the
+	 * second sg. In the former code, when the first sg entered 'sdma_
+	 * prep_slave_sg', 'sdmac->status' would be set to 'DMA_IN_PROGRESS',
+	 * and the second sg would return 'NULL' when entered 'sdma_prep_slave
+	 * _sg'. To avoid this error, in the code, we check if for M2M use,
+	 * the second sg will not return 'NULL' when enters 'sdma_prep_slave
+	 * _sg'.
+	 */
+	if (!((direction == DMA_MEM_TO_MEM) && (flags == 0))) {
+		if (sdmac->status == DMA_IN_PROGRESS)
+			return NULL;
+	}
 	sdmac->status = DMA_IN_PROGRESS;
 
-	sdmac->flags = 0;
+	sdmac->mode = SDMA_MODE_NORMAL;
 
 	dev_dbg(sdma->dev, "setting up %d entries for channel %d.\n",
 			sg_len, channel);
@@ -941,6 +1100,12 @@ static struct dma_async_tx_descriptor *sdma_prep_slave_sg(
 		struct sdma_buffer_descriptor *bd = &sdmac->bd[i];
 		int param;
 
+		if (sdmac->direction == DMA_MEM_TO_MEM) {
+			if (flags == 1)
+				bd->buffer_addr = sg->dma_address;
+			if (flags == 0)
+				bd->ext_buffer_addr = sg->dma_address;
+		} else
 		bd->buffer_addr = sg->dma_address;
 
 		count = sg->length;
@@ -1010,7 +1175,7 @@ static struct dma_async_tx_descriptor *sdma_prep_dma_cyclic(
 {
 	struct sdma_channel *sdmac = to_sdma_chan(chan);
 	struct sdma_engine *sdma = sdmac->sdma;
-	int num_periods = buf_len / period_len;
+	int num_periods;
 	int channel = sdmac->channel;
 	int ret, i = 0, buf = 0;
 
@@ -1020,13 +1185,33 @@ static struct dma_async_tx_descriptor *sdma_prep_dma_cyclic(
 		return NULL;
 
 	sdmac->status = DMA_IN_PROGRESS;
-
-	sdmac->flags |= IMX_DMA_SG_LOOP;
 	sdmac->direction = direction;
+
+	switch (sdmac->direction) {
+	case DMA_DEV_TO_DEV:
+		sdmac->mode = SDMA_MODE_P2P;
+		break;
+	case DMA_TRANS_NONE:
+		sdmac->mode = SDMA_MODE_NO_BD;
+		break;
+	case DMA_MEM_TO_DEV:
+	case DMA_DEV_TO_MEM:
+		sdmac->mode = SDMA_MODE_LOOP;
+		break;
+	default:
+		pr_err("SDMA direction is not support!");
+		return NULL;
+	}
+
 	ret = sdma_load_context(sdmac);
 	if (ret)
 		goto err_out;
 
+	if (period_len)
+		num_periods = buf_len / period_len;
+	else
+		return &sdmac->desc;
+
 	if (num_periods > NUM_BD) {
 		dev_err(sdma->dev, "SDMA channel %d: maximum number of sg exceeded: %d > %d\n",
 				channel, num_periods, NUM_BD);
@@ -1091,15 +1276,24 @@ static int sdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		sdma_disable_channel(sdmac);
 		return 0;
 	case DMA_SLAVE_CONFIG:
-		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+		if (dmaengine_cfg->direction == DMA_DEV_TO_DEV) {
 			sdmac->per_address = dmaengine_cfg->src_addr;
-			sdmac->watermark_level = dmaengine_cfg->src_maxburst *
-						dmaengine_cfg->src_addr_width;
+			sdmac->per_address2 = dmaengine_cfg->dst_addr;
+			sdmac->watermark_level = 0;
+			sdmac->watermark_level |=
+				dmaengine_cfg->src_maxburst;
+			sdmac->watermark_level |=
+				dmaengine_cfg->dst_maxburst << 16;
+			sdmac->word_size = dmaengine_cfg->dst_addr_width;
+		} else if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+			sdmac->per_address = dmaengine_cfg->src_addr;
+			sdmac->watermark_level = dmaengine_cfg->src_maxburst;
 			sdmac->word_size = dmaengine_cfg->src_addr_width;
-		} else {
+		} else if (dmaengine_cfg->direction == DMA_MEM_TO_DEV) {
 			sdmac->per_address = dmaengine_cfg->dst_addr;
-			sdmac->watermark_level = dmaengine_cfg->dst_maxburst *
-						dmaengine_cfg->dst_addr_width;
+			sdmac->watermark_level = dmaengine_cfg->dst_maxburst;
+			sdmac->word_size = dmaengine_cfg->dst_addr_width;
+		} else if (dmaengine_cfg->direction == DMA_MEM_TO_MEM) {
 			sdmac->word_size = dmaengine_cfg->dst_addr_width;
 		}
 		sdmac->direction = dmaengine_cfg->direction;
@@ -1120,7 +1314,7 @@ static enum dma_status sdma_tx_status(struct dma_chan *chan,
 
 	last_used = chan->cookie;
 
-	dma_set_tx_state(txstate, chan->completed_cookie, last_used,
+	dma_set_tx_state(txstate, sdmac->last_completed, last_used,
 			sdmac->chn_count - sdmac->chn_real_count);
 
 	return sdmac->status;
@@ -1128,14 +1322,28 @@ static enum dma_status sdma_tx_status(struct dma_chan *chan,
 
 static void sdma_issue_pending(struct dma_chan *chan)
 {
+	/*
+	 * Nothing to do. We only have a single descriptor
+	 */
+}
+
+void sdma_set_event_pending(struct dma_chan *chan)
+{
 	struct sdma_channel *sdmac = to_sdma_chan(chan);
 	struct sdma_engine *sdma = sdmac->sdma;
+	u32 reg;
+	u32 channel;
 
-	if (sdmac->status == DMA_IN_PROGRESS)
-		sdma_enable_channel(sdma, sdmac->channel);
+	channel = sdmac->channel;
+	reg = readl_relaxed(sdma->regs + SDMA_H_EVTPEND);
+	reg |= 1 << channel;
+	writel_relaxed(reg, sdma->regs + SDMA_H_EVTPEND);
+
+	return;
 }
+EXPORT_SYMBOL(sdma_set_event_pending);
 
-#define SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1	34
+#define SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1	38
 
 static void sdma_add_scripts(struct sdma_engine *sdma,
 		const struct sdma_script_start_addrs *addr)
@@ -1149,17 +1357,27 @@ static void sdma_add_scripts(struct sdma_engine *sdma,
 			saddr_arr[i] = addr_arr[i];
 }
 
-static void sdma_load_firmware(const struct firmware *fw, void *context)
+static int __init sdma_get_firmware(struct sdma_engine *sdma,
+		const char *cpu_name, int to_version)
 {
-	struct sdma_engine *sdma = context;
+	const struct firmware *fw;
+	char *fwname;
 	const struct sdma_firmware_header *header;
+	int ret;
 	const struct sdma_script_start_addrs *addr;
 	unsigned short *ram_code;
 
-	if (!fw) {
-		dev_err(sdma->dev, "firmware not found\n");
-		return;
+	fwname = kasprintf(GFP_KERNEL, "imx/sdma/sdma-%s-to%d.bin",
+				cpu_name, to_version);
+	if (!fwname)
+		return -ENOMEM;
+
+	ret = request_firmware(&fw, fwname, sdma->dev);
+	if (ret) {
+		kfree(fwname);
+		return ret;
 	}
+	kfree(fwname);
 
 	if (fw->size < sizeof(*header))
 		goto err_firmware;
@@ -1174,7 +1392,6 @@ static void sdma_load_firmware(const struct firmware *fw, void *context)
 	addr = (void *)header + header->script_addrs_start;
 	ram_code = (void *)header + header->ram_code_start;
 
-	clk_enable(sdma->clk);
 	/* download the RAM image for SDMA */
 	sdma_load_script(sdma, ram_code,
 			header->ram_code_size,
@@ -1189,16 +1406,6 @@ static void sdma_load_firmware(const struct firmware *fw, void *context)
 
 err_firmware:
 	release_firmware(fw);
-}
-
-static int __init sdma_get_firmware(struct sdma_engine *sdma,
-		const char *fw_name)
-{
-	int ret;
-
-	ret = request_firmware_nowait(THIS_MODULE,
-			FW_ACTION_HOTPLUG, fw_name, sdma->dev,
-			GFP_KERNEL, sdma, sdma_load_firmware);
 
 	return ret;
 }
@@ -1208,16 +1415,15 @@ static int __init sdma_init(struct sdma_engine *sdma)
 	int i, ret;
 	dma_addr_t ccb_phys;
 
-	switch (sdma->devtype) {
-	case IMX31_SDMA:
+	switch (sdma->version) {
+	case 1:
 		sdma->num_events = 32;
 		break;
-	case IMX35_SDMA:
+	case 2:
 		sdma->num_events = 48;
 		break;
 	default:
-		dev_err(sdma->dev, "Unknown sdma type %d. aborting\n",
-			sdma->devtype);
+		dev_err(sdma->dev, "Unknown version %d. aborting\n", sdma->version);
 		return -ENODEV;
 	}
 
@@ -1286,29 +1492,22 @@ err_dma_alloc:
 
 static int __init sdma_probe(struct platform_device *pdev)
 {
-	const struct of_device_id *of_id =
-			of_match_device(sdma_dt_ids, &pdev->dev);
-	struct device_node *np = pdev->dev.of_node;
-	const char *fw_name;
 	int ret;
 	int irq;
 	struct resource *iores;
 	struct sdma_platform_data *pdata = pdev->dev.platform_data;
 	int i;
 	struct sdma_engine *sdma;
-	s32 *saddr_arr;
 
 	sdma = kzalloc(sizeof(*sdma), GFP_KERNEL);
 	if (!sdma)
 		return -ENOMEM;
 
-	spin_lock_init(&sdma->channel_0_lock);
-
 	sdma->dev = &pdev->dev;
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(pdev, 0);
-	if (!iores || irq < 0) {
+	if (!iores || irq < 0 || !pdata) {
 		ret = -EINVAL;
 		goto err_irq;
 	}
@@ -1335,23 +1534,16 @@ static int __init sdma_probe(struct platform_device *pdev)
 		goto err_request_irq;
 
 	sdma->script_addrs = kzalloc(sizeof(*sdma->script_addrs), GFP_KERNEL);
-	if (!sdma->script_addrs) {
-		ret = -ENOMEM;
+	if (!sdma->script_addrs)
 		goto err_alloc;
-	}
 
-	/* initially no scripts available */
-	saddr_arr = (s32 *)sdma->script_addrs;
-	for (i = 0; i < SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1; i++)
-		saddr_arr[i] = -EINVAL;
-
-	if (of_id)
-		pdev->id_entry = of_id->data;
-	sdma->devtype = pdev->id_entry->driver_data;
+	sdma->version = pdata->sdma_version;
 
 	dma_cap_set(DMA_SLAVE, sdma->dma_device.cap_mask);
 	dma_cap_set(DMA_CYCLIC, sdma->dma_device.cap_mask);
 
+	spin_lock_init(&sdma->irq_reg_lock);
+
 	INIT_LIST_HEAD(&sdma->dma_device.channels);
 	/* Initialize channel parameters */
 	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
@@ -1361,7 +1553,6 @@ static int __init sdma_probe(struct platform_device *pdev)
 		spin_lock_init(&sdmac->lock);
 
 		sdmac->chan.device = &sdma->dma_device;
-		dma_cookie_init(&sdmac->chan);
 		sdmac->channel = i;
 
 		/*
@@ -1378,29 +1569,10 @@ static int __init sdma_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_init;
 
-	if (pdata && pdata->script_addrs)
+	if (pdata->script_addrs)
 		sdma_add_scripts(sdma, pdata->script_addrs);
 
-	if (pdata) {
-		ret = sdma_get_firmware(sdma, pdata->fw_name);
-		if (ret)
-			dev_warn(&pdev->dev, "failed to get firmware from platform data\n");
-	} else {
-		/*
-		 * Because that device tree does not encode ROM script address,
-		 * the RAM script in firmware is mandatory for device tree
-		 * probe, otherwise it fails.
-		 */
-		ret = of_property_read_string(np, "fsl,sdma-ram-script-name",
-					      &fw_name);
-		if (ret)
-			dev_warn(&pdev->dev, "failed to get firmware name\n");
-		else {
-			ret = sdma_get_firmware(sdma, fw_name);
-			if (ret)
-				dev_warn(&pdev->dev, "failed to get firmware from device tree\n");
-		}
-	}
+	sdma_get_firmware(sdma, pdata->cpu_name, pdata->to_version);
 
 	sdma->dma_device.dev = &pdev->dev;
 
@@ -1448,9 +1620,7 @@ static int __exit sdma_remove(struct platform_device *pdev)
 static struct platform_driver sdma_driver = {
 	.driver		= {
 		.name	= "imx-sdma",
-		.of_match_table = sdma_dt_ids,
 	},
-	.id_table	= sdma_devtypes,
 	.remove		= __exit_p(sdma_remove),
 };
 
diff --git a/drivers/dma/pxp/Makefile b/drivers/dma/pxp/Makefile
new file mode 100644
index 0000000..7372a8c
--- /dev/null
+++ b/drivers/dma/pxp/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_MXC_PXP) += pxp_dma.o
+obj-$(CONFIG_MXC_PXP_V2) += pxp_dma_v2.o
+obj-$(CONFIG_MXC_PXP_CLIENT_DEVICE) += pxp_device.o
diff --git a/drivers/dma/pxp/pxp_device.c b/drivers/dma/pxp/pxp_device.c
new file mode 100644
index 0000000..fc31373
--- /dev/null
+++ b/drivers/dma/pxp/pxp_device.c
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/pxp_dma.h>
+
+#include <linux/atomic.h>
+
+#include <mach/dma.h>
+
+static atomic_t open_count = ATOMIC_INIT(0);
+
+static DEFINE_SPINLOCK(pxp_mem_lock);
+static DEFINE_SPINLOCK(pxp_chan_lock);
+static LIST_HEAD(head);
+static LIST_HEAD(list);
+static struct pxp_irq_info irq_info[NR_PXP_VIRT_CHANNEL];
+
+struct pxp_chan_handle {
+	int chan_id;
+	int hist_status;
+};
+
+/* To track the allocated memory buffer */
+struct memalloc_record {
+	struct list_head list;
+	struct pxp_mem_desc mem;
+};
+
+struct pxp_chan_info {
+	int chan_id;
+	struct dma_chan *dma_chan;
+	struct list_head list;
+};
+
+static int pxp_alloc_dma_buffer(struct pxp_mem_desc *mem)
+{
+	mem->cpu_addr = (unsigned long)
+	    dma_alloc_coherent(NULL, PAGE_ALIGN(mem->size),
+			       (dma_addr_t *) (&mem->phys_addr),
+			       GFP_DMA | GFP_KERNEL);
+	pr_debug("[ALLOC] mem alloc phys_addr = 0x%x\n", mem->phys_addr);
+	if ((void *)(mem->cpu_addr) == NULL) {
+		printk(KERN_ERR "Physical memory allocation error!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void pxp_free_dma_buffer(struct pxp_mem_desc *mem)
+{
+	if (mem->cpu_addr != 0) {
+		dma_free_coherent(0, PAGE_ALIGN(mem->size),
+				  (void *)mem->cpu_addr, mem->phys_addr);
+	}
+}
+
+static int pxp_free_buffers(void)
+{
+	struct memalloc_record *rec, *n;
+	struct pxp_mem_desc mem;
+
+	list_for_each_entry_safe(rec, n, &head, list) {
+		mem = rec->mem;
+		if (mem.cpu_addr != 0) {
+			pxp_free_dma_buffer(&mem);
+			pr_debug("[FREE] freed paddr=0x%08X\n", mem.phys_addr);
+			/* delete from list */
+			list_del(&rec->list);
+			kfree(rec);
+		}
+	}
+
+	return 0;
+}
+
+/* Callback function triggered after PxP receives an EOF interrupt */
+static void pxp_dma_done(void *arg)
+{
+	struct pxp_tx_desc *tx_desc = to_tx_desc(arg);
+	struct dma_chan *chan = tx_desc->txd.chan;
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	int chan_id = pxp_chan->dma_chan.chan_id;
+
+	pr_debug("DMA Done ISR, chan_id %d\n", chan_id);
+
+	irq_info[chan_id].irq_pending++;
+	irq_info[chan_id].hist_status = tx_desc->hist_status;
+
+	wake_up_interruptible(&(irq_info[chan_id].waitq));
+}
+
+static int pxp_ioc_config_chan(unsigned long arg)
+{
+	struct scatterlist sg[3];
+	struct pxp_tx_desc *desc;
+	struct dma_async_tx_descriptor *txd;
+	struct pxp_chan_info *info;
+	struct pxp_config_data pxp_conf;
+	dma_cookie_t cookie;
+	int chan_id;
+	int i, length, ret;
+
+	ret = copy_from_user(&pxp_conf,
+			     (struct pxp_config_data *)arg,
+			     sizeof(struct pxp_config_data));
+	if (ret)
+		return -EFAULT;
+
+	chan_id = pxp_conf.chan_id;
+	if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+		return -ENODEV;
+
+	init_waitqueue_head(&(irq_info[chan_id].waitq));
+
+	/* find the channel */
+	spin_lock(&pxp_chan_lock);
+	list_for_each_entry(info, &list, list) {
+		if (info->dma_chan->chan_id == chan_id)
+			break;
+	}
+	spin_unlock(&pxp_chan_lock);
+
+	sg_init_table(sg, 3);
+
+	txd =
+	    info->dma_chan->device->device_prep_slave_sg(info->dma_chan,
+							 sg, 3,
+							 DMA_TO_DEVICE,
+							 DMA_PREP_INTERRUPT,
+							 NULL);
+	if (!txd) {
+		pr_err("Error preparing a DMA transaction descriptor.\n");
+		return -EIO;
+	}
+
+	txd->callback_param = txd;
+	txd->callback = pxp_dma_done;
+
+	desc = to_tx_desc(txd);
+
+	length = desc->len;
+	for (i = 0; i < length; i++) {
+		if (i == 0) {	/* S0 */
+			memcpy(&desc->proc_data,
+			       &pxp_conf.proc_data,
+			       sizeof(struct pxp_proc_data));
+			memcpy(&desc->layer_param.s0_param,
+			       &pxp_conf.s0_param,
+			       sizeof(struct pxp_layer_param));
+		} else if (i == 1) {	/* Output */
+			memcpy(&desc->layer_param.out_param,
+			       &pxp_conf.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {
+			/* OverLay */
+			memcpy(&desc->layer_param.ol_param,
+			       &pxp_conf.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		desc = desc->next;
+	}
+
+	cookie = txd->tx_submit(txd);
+	if (cookie < 0) {
+		pr_err("Error tx_submit\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int pxp_device_open(struct inode *inode, struct file *filp)
+{
+	atomic_inc(&open_count);
+
+	return 0;
+}
+
+static int pxp_device_release(struct inode *inode, struct file *filp)
+{
+	if (atomic_dec_and_test(&open_count))
+		pxp_free_buffers();
+
+	return 0;
+}
+
+static int pxp_device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct memalloc_record *rec, *n;
+	int request_size, found;
+
+	request_size = vma->vm_end - vma->vm_start;
+	found = 0;
+
+	pr_debug("start=0x%x, pgoff=0x%x, size=0x%x\n",
+		 (unsigned int)(vma->vm_start), (unsigned int)(vma->vm_pgoff),
+		 request_size);
+
+	spin_lock(&pxp_mem_lock);
+	list_for_each_entry_safe(rec, n, &head, list) {
+		if (rec->mem.phys_addr == (vma->vm_pgoff << PAGE_SHIFT) &&
+			(rec->mem.size <= request_size)) {
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock(&pxp_mem_lock);
+
+	if (found == 0)
+		return -ENOMEM;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			       request_size, vma->vm_page_prot) ? -EAGAIN : 0;
+}
+
+static bool chan_filter(struct dma_chan *chan, void *arg)
+{
+	if (imx_dma_is_pxp(chan))
+		return true;
+	else
+		return false;
+}
+
+static long pxp_device_ioctl(struct file *filp,
+			    unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case PXP_IOC_GET_CHAN:
+		{
+			struct pxp_chan_info *info;
+			dma_cap_mask_t mask;
+
+			pr_debug("drv: PXP_IOC_GET_CHAN Line %d\n", __LINE__);
+			info = kzalloc(sizeof(*info), GFP_KERNEL);
+			if (!info) {
+				pr_err("%d: alloc err\n", __LINE__);
+				return -ENOMEM;
+			}
+
+			dma_cap_zero(mask);
+			dma_cap_set(DMA_SLAVE, mask);
+			dma_cap_set(DMA_PRIVATE, mask);
+			info->dma_chan = dma_request_channel(mask, chan_filter, NULL);
+			if (!info->dma_chan) {
+				pr_err("Unsccessfully received channel!\n");
+				kfree(info);
+				return -EBUSY;
+			}
+			pr_debug("Successfully received channel."
+				 "chan_id %d\n", info->dma_chan->chan_id);
+
+			spin_lock(&pxp_chan_lock);
+			list_add_tail(&info->list, &list);
+			spin_unlock(&pxp_chan_lock);
+
+			if (put_user
+			    (info->dma_chan->chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			break;
+		}
+	case PXP_IOC_PUT_CHAN:
+		{
+			int chan_id;
+			struct pxp_chan_info *info;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			pr_debug("%d release chan_id %d\n", __LINE__,
+				 info->dma_chan->chan_id);
+			/* REVISIT */
+			dma_release_channel(info->dma_chan);
+			spin_lock(&pxp_chan_lock);
+			list_del_init(&info->list);
+			spin_unlock(&pxp_chan_lock);
+			kfree(info);
+
+			break;
+		}
+	case PXP_IOC_CONFIG_CHAN:
+		{
+
+			int ret;
+
+			ret = pxp_ioc_config_chan(arg);
+			if (ret)
+				return ret;
+
+			break;
+		}
+	case PXP_IOC_START_CHAN:
+		{
+			struct pxp_chan_info *info;
+			int chan_id;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			/* find the channel */
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			dma_async_issue_pending(info->dma_chan);
+
+			break;
+		}
+	case PXP_IOC_GET_PHYMEM:
+		{
+			struct memalloc_record *rec;
+
+			rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+			if (!rec)
+				return -ENOMEM;
+
+			ret = copy_from_user(&(rec->mem),
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				return -EFAULT;
+			}
+
+			pr_debug("[ALLOC] mem alloc size = 0x%x\n",
+				 rec->mem.size);
+
+			ret = pxp_alloc_dma_buffer(&(rec->mem));
+			if (ret == -1) {
+				kfree(rec);
+				printk(KERN_ERR
+				       "Physical memory allocation error!\n");
+				break;
+			}
+			ret = copy_to_user((void __user *)arg, &(rec->mem),
+					   sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				ret = -EFAULT;
+				break;
+			}
+
+			spin_lock(&pxp_mem_lock);
+			list_add(&rec->list, &head);
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_PUT_PHYMEM:
+		{
+			struct memalloc_record *rec, *n;
+			struct pxp_mem_desc pxp_mem;
+
+			ret = copy_from_user(&pxp_mem,
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret)
+				return -EACCES;
+
+			pr_debug("[FREE] mem freed cpu_addr = 0x%x\n",
+				 pxp_mem.cpu_addr);
+			if ((void *)pxp_mem.cpu_addr != NULL)
+				pxp_free_dma_buffer(&pxp_mem);
+
+			spin_lock(&pxp_mem_lock);
+			list_for_each_entry_safe(rec, n, &head, list) {
+				if (rec->mem.cpu_addr == pxp_mem.cpu_addr) {
+					/* delete from list */
+					list_del(&rec->list);
+					kfree(rec);
+					break;
+				}
+			}
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_WAIT4CMPLT:
+		{
+			struct pxp_chan_handle chan_handle;
+			int ret, chan_id;
+
+			ret = copy_from_user(&chan_handle,
+					     (struct pxp_chan_handle *)arg,
+					     sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+
+			chan_id = chan_handle.chan_id;
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			if (!wait_event_interruptible_timeout
+			    (irq_info[chan_id].waitq,
+			     (irq_info[chan_id].irq_pending != 0), 2 * HZ)) {
+				pr_warning("pxp blocking: timeout.\n");
+				return -ETIME;
+			} else if (signal_pending(current)) {
+				printk(KERN_WARNING
+				       "pxp interrupt received.\n");
+				return -ERESTARTSYS;
+			} else
+				irq_info[chan_id].irq_pending--;
+
+			chan_handle.hist_status = irq_info[chan_id].hist_status;
+			ret = copy_to_user((struct pxp_chan_handle *)arg,
+					   &chan_handle,
+					   sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+			break;
+		}
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations pxp_device_fops = {
+	.open = pxp_device_open,
+	.release = pxp_device_release,
+	.unlocked_ioctl = pxp_device_ioctl,
+	.mmap = pxp_device_mmap,
+};
+
+static struct miscdevice pxp_device_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "pxp_device",
+	.fops = &pxp_device_fops,
+};
+
+static int __devinit pxp_device_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = misc_register(&pxp_device_miscdev);
+	if (ret)
+		return ret;
+
+	pr_debug("PxP_Device Probe Successfully\n");
+	return 0;
+}
+
+static int __devexit pxp_device_remove(struct platform_device *pdev)
+{
+	misc_deregister(&pxp_device_miscdev);
+
+	return 0;
+}
+
+static struct platform_driver pxp_client_driver = {
+	.probe = pxp_device_probe,
+	.remove = __exit_p(pxp_device_remove),
+	.driver = {
+		   .name = "imx-pxp-client",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init pxp_device_init(void)
+{
+	return platform_driver_register(&pxp_client_driver);
+}
+
+static void __exit pxp_device_exit(void)
+{
+	platform_driver_unregister(&pxp_client_driver);
+}
+
+module_init(pxp_device_init);
+module_exit(pxp_device_exit);
+
+MODULE_DESCRIPTION("i.MX PxP client driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/pxp_dma.c b/drivers/dma/pxp/pxp_dma.c
new file mode 100644
index 0000000..ddd1c0c
--- /dev/null
+++ b/drivers/dma/pxp/pxp_dma.c
@@ -0,0 +1,1565 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+
+#include "regs-pxp.h"
+
+#define	PXP_DOWNSCALE_THRESHOLD		0x4000
+
+static LIST_HEAD(head);
+static int timeout_in_ms = 600;
+
+struct pxp_dma {
+	struct dma_device dma;
+};
+
+struct pxps {
+	struct platform_device *pdev;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;		/* PXP IRQ to the CPU */
+
+	spinlock_t lock;
+	struct mutex clk_mutex;
+	int clk_stat;
+#define	CLK_STAT_OFF		0
+#define	CLK_STAT_ON		1
+	int pxp_ongoing;
+	int lut_state;
+
+	struct device *dev;
+	struct pxp_dma pxp_dma;
+	struct pxp_channel channel[NR_PXP_VIRT_CHANNEL];
+	wait_queue_head_t done;
+	struct work_struct work;
+
+	/* describes most recent processing configuration */
+	struct pxp_config_data pxp_conf_state;
+
+	/* to turn clock off when pxp is inactive */
+	struct timer_list clk_timer;
+};
+
+#define to_pxp_dma(d) container_of(d, struct pxp_dma, dma)
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+#define to_pxp(id) container_of(id, struct pxps, pxp_dma)
+
+#define PXP_DEF_BUFS	2
+#define PXP_MIN_PIX	8
+
+#define PXP_WAITCON	((__raw_readl(pxp->base + HW_PXP_STAT) & \
+				BM_PXP_STAT_IRQ) != BM_PXP_STAT_IRQ)
+
+static uint32_t pxp_s0_formats[] = {
+	PXP_PIX_FMT_RGB24,
+	PXP_PIX_FMT_RGB565,
+	PXP_PIX_FMT_RGB555,
+	PXP_PIX_FMT_YUV420P,
+	PXP_PIX_FMT_YUV422P,
+};
+
+/*
+ * PXP common functions
+ */
+static void dump_pxp_reg(struct pxps *pxp)
+{
+	dev_dbg(pxp->dev, "PXP_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CTRL));
+	dev_dbg(pxp->dev, "PXP_STAT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_STAT));
+	dev_dbg(pxp->dev, "PXP_OUTBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTBUF));
+	dev_dbg(pxp->dev, "PXP_OUTBUF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTBUF2));
+	dev_dbg(pxp->dev, "PXP_OUTSIZE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTSIZE));
+	dev_dbg(pxp->dev, "PXP_S0BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0BUF));
+	dev_dbg(pxp->dev, "PXP_S0UBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0UBUF));
+	dev_dbg(pxp->dev, "PXP_S0VBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0VBUF));
+	dev_dbg(pxp->dev, "PXP_S0PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0PARAM));
+	dev_dbg(pxp->dev, "PXP_S0BACKGROUND 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0BACKGROUND));
+	dev_dbg(pxp->dev, "PXP_S0CROP 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0CROP));
+	dev_dbg(pxp->dev, "PXP_S0SCALE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0SCALE));
+	dev_dbg(pxp->dev, "PXP_OLn 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLn(0)));
+	dev_dbg(pxp->dev, "PXP_OLnSIZE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLnSIZE(0)));
+	dev_dbg(pxp->dev, "PXP_OLnPARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLnPARAM(0)));
+	dev_dbg(pxp->dev, "PXP_CSCCOEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSCCOEF0));
+	dev_dbg(pxp->dev, "PXP_CSCCOEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSCCOEF1));
+	dev_dbg(pxp->dev, "PXP_CSCCOEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSCCOEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2CTRL));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF0));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF1));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF3));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF4 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF4));
+	dev_dbg(pxp->dev, "PXP_CSC2COEF5 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF5));
+	dev_dbg(pxp->dev, "PXP_LUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_CTRL));
+	dev_dbg(pxp->dev, "PXP_LUT 0x%x", __raw_readl(pxp->base + HW_PXP_LUT));
+	dev_dbg(pxp->dev, "PXP_HIST_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST_CTRL));
+	dev_dbg(pxp->dev, "PXP_HIST2_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST2_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST4_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST4_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM2));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM3));
+}
+
+static bool is_yuv(u32 pix_fmt)
+{
+	if ((pix_fmt == PXP_PIX_FMT_YUYV) |
+	    (pix_fmt == PXP_PIX_FMT_UYVY) |
+	    (pix_fmt == PXP_PIX_FMT_Y41P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV444) |
+	    (pix_fmt == PXP_PIX_FMT_NV12) |
+	    (pix_fmt == PXP_PIX_FMT_GREY) |
+	    (pix_fmt == PXP_PIX_FMT_GY04) |
+	    (pix_fmt == PXP_PIX_FMT_YVU410P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV410P) |
+	    (pix_fmt == PXP_PIX_FMT_YVU420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P2) |
+	    (pix_fmt == PXP_PIX_FMT_YVU422P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV422P)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void pxp_set_ctrl(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 ctrl;
+	u32 fmt_ctrl;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__YUV420;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__YUV420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__YUV422;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+	ctrl = BF_PXP_CTRL_S0_FORMAT(fmt_ctrl);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P422;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__MONOC8;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__MONOC4;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+	ctrl |= BF_PXP_CTRL_OUTBUF_FORMAT(fmt_ctrl);
+
+	ctrl |= BM_PXP_CTRL_CROP;
+
+	if (proc_data->scaling)
+		ctrl |= BM_PXP_CTRL_SCALE;
+	if (proc_data->vflip)
+		ctrl |= BM_PXP_CTRL_VFLIP;
+	if (proc_data->hflip)
+		ctrl |= BM_PXP_CTRL_HFLIP;
+	if (proc_data->rotate)
+		ctrl |= BF_PXP_CTRL_ROTATE(proc_data->rotate / 90);
+
+	__raw_writel(ctrl, pxp->base + HW_PXP_CTRL);
+}
+
+static int pxp_start(struct pxps *pxp)
+{
+	__raw_writel(BM_PXP_CTRL_IRQ_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	__raw_writel(BM_PXP_CTRL_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+
+	return 0;
+}
+
+static void pxp_set_outbuf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	__raw_writel(out_params->paddr, pxp->base + HW_PXP_OUTBUF);
+
+	__raw_writel(BF_PXP_OUTSIZE_WIDTH(out_params->width) |
+		     BF_PXP_OUTSIZE_HEIGHT(out_params->height),
+		     pxp->base + HW_PXP_OUTSIZE);
+}
+
+static void pxp_set_s0colorkey(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (s0_params->color_key == -1) {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_S0COLORKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_S0COLORKEYHIGH);
+	} else {
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_S0COLORKEYLOW);
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_S0COLORKEYHIGH);
+	}
+}
+
+static void pxp_set_olcolorkey(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[layer_no];
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (ol_params->color_key_enable != 0 && ol_params->color_key != -1) {
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_OLCOLORKEYLOW);
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_OLCOLORKEYHIGH);
+	} else {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_OLCOLORKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_OLCOLORKEYHIGH);
+	}
+}
+
+static void pxp_set_oln(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	dma_addr_t phys_addr = olparams_data->paddr;
+	__raw_writel(phys_addr, pxp->base + HW_PXP_OLn(layer_no));
+
+	/* Fixme */
+	__raw_writel(BF_PXP_OLnSIZE_WIDTH(olparams_data->width >> 3) |
+		     BF_PXP_OLnSIZE_HEIGHT(olparams_data->height >> 3),
+		     pxp->base + HW_PXP_OLnSIZE(layer_no));
+}
+
+static void pxp_set_olparam(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	u32 olparam;
+
+	olparam = BF_PXP_OLnPARAM_ALPHA(olparams_data->global_alpha);
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		olparam |=
+		    BF_PXP_OLnPARAM_FORMAT(BV_PXP_OLnPARAM_FORMAT__RGB888);
+	else
+		olparam |=
+		    BF_PXP_OLnPARAM_FORMAT(BV_PXP_OLnPARAM_FORMAT__RGB565);
+	if (olparams_data->global_alpha_enable)
+		olparam |=
+		    BF_PXP_OLnPARAM_ALPHA_CNTL
+		    (BV_PXP_OLnPARAM_ALPHA_CNTL__Override);
+	if (olparams_data->color_key_enable)
+		olparam |= BM_PXP_OLnPARAM_ENABLE_COLORKEY;
+	if (olparams_data->combine_enable)
+		olparam |= BM_PXP_OLnPARAM_ENABLE;
+	__raw_writel(olparam, pxp->base + HW_PXP_OLnPARAM(layer_no));
+}
+
+static void pxp_set_s0param(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0params_data = &pxp_conf->s0_param;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 s0param;
+
+	s0param = BF_PXP_S0PARAM_XBASE(proc_data->drect.left >> 3);
+	s0param |= BF_PXP_S0PARAM_YBASE(proc_data->drect.top >> 3);
+	s0param |= BF_PXP_S0PARAM_WIDTH(s0params_data->width >> 3);
+	s0param |= BF_PXP_S0PARAM_HEIGHT(s0params_data->height >> 3);
+	__raw_writel(s0param, pxp->base + HW_PXP_S0PARAM);
+}
+
+static void pxp_set_s0crop(struct pxps *pxp)
+{
+	u32 s0crop;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+
+	s0crop = BF_PXP_S0CROP_XBASE(proc_data->srect.left >> 3);
+	s0crop |= BF_PXP_S0CROP_YBASE(proc_data->srect.top >> 3);
+	s0crop |= BF_PXP_S0CROP_WIDTH(proc_data->drect.width >> 3);
+	s0crop |= BF_PXP_S0CROP_HEIGHT(proc_data->drect.height >> 3);
+	__raw_writel(s0crop, pxp->base + HW_PXP_S0CROP);
+}
+
+static int pxp_set_scaling(struct pxps *pxp)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+	struct pxp_layer_param *s0params_data = &pxp->pxp_conf_state.s0_param;
+
+	if ((s0params_data->pixel_fmt != PXP_PIX_FMT_YUV420P) &&
+	    (s0params_data->pixel_fmt != PXP_PIX_FMT_YUV422P)) {
+		proc_data->scaling = 0;
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if ((proc_data->srect.width == proc_data->drect.width) &&
+	    (proc_data->srect.height == proc_data->drect.height)) {
+		proc_data->scaling = 0;
+		__raw_writel(0x10001000, pxp->base + HW_PXP_S0SCALE);
+		goto out;
+	}
+
+	proc_data->scaling = 1;
+	xscale = proc_data->srect.width * 0x1000 / proc_data->drect.width;
+	yscale = proc_data->srect.height * 0x1000 / proc_data->drect.height;
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_S0SCALE_YSCALE(yscale) | BF_PXP_S0SCALE_XSCALE(xscale);
+	__raw_writel(s0scale, pxp->base + HW_PXP_S0SCALE);
+
+out:
+	pxp_set_ctrl(pxp);
+
+	return ret;
+}
+
+static void pxp_set_bg(struct pxps *pxp)
+{
+	__raw_writel(pxp->pxp_conf_state.proc_data.bgcolor,
+		     pxp->base + HW_PXP_S0BACKGROUND);
+}
+
+static void pxp_set_lut(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	int lut_op = pxp_conf->proc_data.lut_transform;
+	u32 reg_val;
+	int i;
+	bool use_cmap = (lut_op & PXP_LUT_USE_CMAP) ? true : false;
+	u8 *cmap = pxp_conf->proc_data.lut_map;
+	u32 entry_src;
+
+	/*
+	 * If LUT already configured as needed, return...
+	 * Unless CMAP is needed and it has been updated.
+	 */
+	if ((pxp->lut_state == lut_op) &&
+		!(use_cmap && pxp_conf->proc_data.lut_map_updated))
+		return;
+
+	if (lut_op == PXP_LUT_NONE) {
+		__raw_writel(BM_PXP_LUT_CTRL_BYPASS,
+			     pxp->base + HW_PXP_LUT_CTRL);
+	} else if (((lut_op & PXP_LUT_INVERT) != 0)
+		&& ((lut_op & PXP_LUT_BLACK_WHITE) != 0)) {
+		/* Fill out LUT table with inverted monochromized values */
+
+		/* Initialize LUT address to 0 and clear bypass bit */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_CTRL);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (i = 0; i < 256; i++) {
+			reg_val =
+			    __raw_readl(pxp->base +
+					HW_PXP_LUT_CTRL) & BM_PXP_LUT_CTRL_ADDR;
+			entry_src = use_cmap ? cmap[i] : reg_val;
+			reg_val = (entry_src < 0x80) ? 0x00 : 0xFF;
+			reg_val = ~reg_val & BM_PXP_LUT_DATA;
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT);
+		}
+	} else if ((lut_op & PXP_LUT_INVERT) != 0) {
+		/* Fill out LUT table with 8-bit inverted values */
+
+		/* Initialize LUT address to 0 and clear bypass bit */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_CTRL);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (i = 0; i < 256; i++) {
+			reg_val =
+			    __raw_readl(pxp->base +
+					HW_PXP_LUT_CTRL) & BM_PXP_LUT_CTRL_ADDR;
+			entry_src = use_cmap ? cmap[i] : reg_val;
+			reg_val = ~entry_src & BM_PXP_LUT_DATA;
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT);
+		}
+	} else if ((lut_op & PXP_LUT_BLACK_WHITE) != 0) {
+		/* Fill out LUT table with 8-bit monochromized values */
+
+		/* Initialize LUT address to 0 and clear bypass bit */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_CTRL);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (i = 0; i < 256; i++) {
+			reg_val =
+			    __raw_readl(pxp->base +
+					HW_PXP_LUT_CTRL) & BM_PXP_LUT_CTRL_ADDR;
+			entry_src = use_cmap ? cmap[i] : reg_val;
+			reg_val = (entry_src < 0x80) ? 0x00 : 0xFF;
+			reg_val = reg_val & BM_PXP_LUT_DATA;
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT);
+		}
+	} else if (use_cmap) {
+		/* Fill out LUT table using colormap values */
+
+		/* Initialize LUT address to 0 and clear bypass bit */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_CTRL);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (i = 0; i < 256; i++) {
+			reg_val = cmap[i] & BM_PXP_LUT_DATA;
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT);
+		}
+	}
+
+	pxp->lut_state = lut_op;
+}
+
+static void pxp_set_csc(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[0];
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	bool input_is_YUV = is_yuv(s0_params->pixel_fmt);
+	bool output_is_YUV = is_yuv(out_params->pixel_fmt);
+
+	if (input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = YUV, Output = YUV
+		 * No CSC unless we need to do combining
+		 */
+		if (ol_params->combine_enable) {
+			/* Must convert to RGB for combining with RGB overlay */
+
+			/* CSC1 - YUV->RGB */
+			__raw_writel(0x04030000, pxp->base + HW_PXP_CSCCOEF0);
+			__raw_writel(0x01230208, pxp->base + HW_PXP_CSCCOEF1);
+			__raw_writel(0x076b079c, pxp->base + HW_PXP_CSCCOEF2);
+
+			/* CSC2 - RGB->YUV */
+			__raw_writel(0x4, pxp->base + HW_PXP_CSC2CTRL);
+			__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2COEF0);
+			__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2COEF1);
+			__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2COEF2);
+			__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2COEF3);
+			__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2COEF4);
+			__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2COEF5);
+		} else {
+			/* Input & Output both YUV, so bypass both CSCs */
+
+			/* CSC1 - Bypass */
+			__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+			/* CSC2 - Bypass */
+			__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+		}
+	} else if (input_is_YUV && !output_is_YUV) {
+		/*
+		 * Input = YUV, Output = RGB
+		 * Use CSC1 to convert to RGB
+		 */
+
+		/* CSC1 - YUV->RGB */
+		__raw_writel(0x84ab01f0, pxp->base + HW_PXP_CSCCOEF0);
+		__raw_writel(0x01230204, pxp->base + HW_PXP_CSCCOEF1);
+		__raw_writel(0x0730079c, pxp->base + HW_PXP_CSCCOEF2);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+	} else if (!input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = RGB, Output = YUV
+		 * Use CSC2 to convert to YUV
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+		/* CSC2 - RGB->YUV */
+		__raw_writel(0x4, pxp->base + HW_PXP_CSC2CTRL);
+		__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2COEF0);
+		__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2COEF1);
+		__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2COEF2);
+		__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2COEF3);
+		__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2COEF4);
+		__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2COEF5);
+	} else {
+		/*
+		 * Input = RGB, Output = RGB
+		 * Input & Output both RGB, so bypass both CSCs
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+	}
+
+	/* YCrCb colorspace */
+	/* Not sure when we use this...no YCrCb formats are defined for PxP */
+	/*
+	   __raw_writel(0x84ab01f0, HW_PXP_CSCCOEFF0_ADDR);
+	   __raw_writel(0x01230204, HW_PXP_CSCCOEFF1_ADDR);
+	   __raw_writel(0x0730079c, HW_PXP_CSCCOEFF2_ADDR);
+	 */
+
+}
+
+static void pxp_set_s0buf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	dma_addr_t Y, U, V;
+
+	Y = s0_params->paddr;
+	__raw_writel(Y, pxp->base + HW_PXP_S0BUF);
+	if ((s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_YVU420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_GREY)) {
+		/* Set to 1 if YUV format is 4:2:2 rather than 4:2:0 */
+		int s = 2;
+		U = Y + (s0_params->width * s0_params->height);
+		V = U + ((s0_params->width * s0_params->height) >> s);
+		__raw_writel(U, pxp->base + HW_PXP_S0UBUF);
+		__raw_writel(V, pxp->base + HW_PXP_S0VBUF);
+	}
+
+	/* TODO: only support RGB565, Y8 , Y4 */
+	if (s0_params->pixel_fmt == PXP_PIX_FMT_GREY)
+		__raw_writel(s0_params->width, pxp->base + HW_PXP_PS_PITCH);
+	else if (s0_params->pixel_fmt == PXP_PIX_FMT_GY04)
+		 __raw_writel(s0_params->width >> 1, pxp->base + HW_PXP_PS_PITCH);
+	else
+		__raw_writel(s0_params->width * 2, pxp->base + HW_PXP_PS_PITCH);
+}
+
+/**
+ * pxp_config() - configure PxP for a processing task
+ * @pxps:	PXP context.
+ * @pxp_chan:	PXP channel.
+ * @return:	0 on success or negative error code on failure.
+ */
+static int pxp_config(struct pxps *pxp, struct pxp_channel *pxp_chan)
+{
+	struct pxp_config_data *pxp_conf_data = &pxp->pxp_conf_state;
+	int ol_nr;
+	int i;
+
+	/* Configure PxP regs */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	pxp_set_scaling(pxp);
+	ol_nr = pxp_conf_data->layer_nr - 2;
+	while (ol_nr > 0) {
+		i = pxp_conf_data->layer_nr - 2 - ol_nr;
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		/* only the color key in higher overlay will take effect. */
+		pxp_set_olcolorkey(i, pxp);
+		ol_nr--;
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	pxp_set_s0buf(pxp);
+	pxp_set_outbuf(pxp);
+
+	return 0;
+}
+
+static void pxp_clk_enable(struct pxps *pxp)
+{
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_ON) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	clk_enable(pxp->clk);
+	pxp->clk_stat = CLK_STAT_ON;
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static void pxp_clk_disable(struct pxps *pxp)
+{
+	unsigned long flags;
+
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_OFF) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head)) {
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		clk_disable(pxp->clk);
+		pxp->clk_stat = CLK_STAT_OFF;
+	} else
+		spin_unlock_irqrestore(&pxp->lock, flags);
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static inline void clkoff_callback(struct work_struct *w)
+{
+	struct pxps *pxp = container_of(w, struct pxps, work);
+
+	pxp_clk_disable(pxp);
+}
+
+static void pxp_clkoff_timer(unsigned long arg)
+{
+	struct pxps *pxp = (struct pxps *)arg;
+
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head))
+		schedule_work(&pxp->work);
+	else
+		mod_timer(&pxp->clk_timer,
+			  jiffies + msecs_to_jiffies(timeout_in_ms));
+}
+
+static struct pxp_tx_desc *pxpdma_first_active(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->active_list.next, struct pxp_tx_desc, list);
+}
+
+static struct pxp_tx_desc *pxpdma_first_queued(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->queue.next, struct pxp_tx_desc, list);
+}
+
+/* called with pxp_chan->lock held */
+static void __pxpdma_dostart(struct pxp_channel *pxp_chan)
+{
+	struct pxp_dma *pxp_dma = to_pxp_dma(pxp_chan->dma_chan.device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc;
+	struct pxp_tx_desc *child;
+	int i = 0;
+
+	/* so far we presume only one transaction on active_list */
+	/* S0 */
+	desc = pxpdma_first_active(pxp_chan);
+	memcpy(&pxp->pxp_conf_state.s0_param,
+	       &desc->layer_param.s0_param, sizeof(struct pxp_layer_param));
+	memcpy(&pxp->pxp_conf_state.proc_data,
+	       &desc->proc_data, sizeof(struct pxp_proc_data));
+
+	/* Save PxP configuration */
+	list_for_each_entry(child, &desc->tx_list, list) {
+		if (i == 0) {	/* Output */
+			memcpy(&pxp->pxp_conf_state.out_param,
+			       &child->layer_param.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {	/* Overlay */
+			memcpy(&pxp->pxp_conf_state.ol_param[i - 1],
+			       &child->layer_param.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		i++;
+	}
+	pr_debug("%s:%d S0 w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.s0_param.width,
+		 pxp->pxp_conf_state.s0_param.height,
+		 pxp->pxp_conf_state.s0_param.paddr);
+	pr_debug("%s:%d OUT w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.out_param.width,
+		 pxp->pxp_conf_state.out_param.height,
+		 pxp->pxp_conf_state.out_param.paddr);
+}
+
+static void pxpdma_dostart_work(struct pxps *pxp)
+{
+	struct pxp_channel *pxp_chan = NULL;
+	unsigned long flags, flags1;
+
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+
+	spin_lock_irqsave(&pxp_chan->lock, flags1);
+	if (!list_empty(&pxp_chan->active_list)) {
+		struct pxp_tx_desc *desc;
+		/* REVISIT */
+		desc = pxpdma_first_active(pxp_chan);
+		__pxpdma_dostart(pxp_chan);
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags1);
+
+	/* Configure PxP */
+	pxp_config(pxp, pxp_chan);
+
+	pxp_start(pxp);
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+}
+
+static void pxpdma_dequeue(struct pxp_channel *pxp_chan, struct list_head *list)
+{
+	struct pxp_tx_desc *desc = NULL;
+	do {
+		desc = pxpdma_first_queued(pxp_chan);
+		list_move_tail(&desc->list, list);
+	} while (!list_empty(&pxp_chan->queue));
+}
+
+static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct pxp_tx_desc *desc = to_tx_desc(tx);
+	struct pxp_channel *pxp_chan = to_pxp_channel(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "received TX\n");
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	cookie = pxp_chan->dma_chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	/* from dmaengine.h: "last cookie value returned to client" */
+	pxp_chan->dma_chan.cookie = cookie;
+	tx->cookie = cookie;
+
+	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	/* Here we add the tx descriptor to our PxP task queue. */
+	list_add_tail(&desc->list, &pxp_chan->queue);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "done TX\n");
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+	return cookie;
+}
+
+/* Called with pxp_chan->chan_mutex held */
+static int pxp_desc_alloc(struct pxp_channel *pxp_chan, int n)
+{
+	struct pxp_tx_desc *desc = vmalloc(n * sizeof(struct pxp_tx_desc));
+
+	if (!desc)
+		return -ENOMEM;
+
+	pxp_chan->n_tx_desc = n;
+	pxp_chan->desc = desc;
+	INIT_LIST_HEAD(&pxp_chan->active_list);
+	INIT_LIST_HEAD(&pxp_chan->queue);
+	INIT_LIST_HEAD(&pxp_chan->free_list);
+
+	while (n--) {
+		struct dma_async_tx_descriptor *txd = &desc->txd;
+
+		memset(txd, 0, sizeof(*txd));
+		INIT_LIST_HEAD(&desc->tx_list);
+		dma_async_tx_descriptor_init(txd, &pxp_chan->dma_chan);
+		txd->tx_submit = pxp_tx_submit;
+
+		list_add(&desc->list, &pxp_chan->free_list);
+
+		desc++;
+	}
+
+	return 0;
+}
+
+/**
+ * pxp_init_channel() - initialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_init_channel(struct pxp_dma *pxp_dma,
+			    struct pxp_channel *pxp_chan)
+{
+	unsigned long flags;
+	struct pxps *pxp = to_pxp(pxp_dma);
+	int ret = 0, n_desc = 0;
+
+	/*
+	 * We are using _virtual_ channel here.
+	 * Each channel contains all parameters of corresponding layers
+	 * for one transaction; each layer is represented as one descriptor
+	 * (i.e., pxp_tx_desc) here.
+	 */
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	/* max desc nr: S0+OL+OUT = 1+8+1 */
+	n_desc = 16;
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	if (n_desc && !pxp_chan->desc)
+		ret = pxp_desc_alloc(pxp_chan, n_desc);
+
+	return ret;
+}
+
+/**
+ * pxp_uninit_channel() - uninitialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_uninit_channel(struct pxp_dma *pxp_dma,
+			      struct pxp_channel *pxp_chan)
+{
+	int ret = 0;
+
+	if (pxp_chan->desc)
+		vfree(pxp_chan->desc);
+
+	pxp_chan->desc = NULL;
+
+	return ret;
+}
+
+static irqreturn_t pxp_irq(int irq, void *dev_id)
+{
+	struct pxps *pxp = dev_id;
+	struct pxp_channel *pxp_chan;
+	struct pxp_tx_desc *desc;
+	dma_async_tx_callback callback;
+	void *callback_param;
+	unsigned long flags;
+	u32 hist_status;
+
+	dump_pxp_reg(pxp);
+
+	hist_status =
+	    __raw_readl(pxp->base + HW_PXP_HIST_CTRL) & BM_PXP_HIST_CTRL_STATUS;
+
+	__raw_writel(BM_PXP_STAT_IRQ, pxp->base + HW_PXP_STAT_CLR);
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+	list_del_init(&pxp_chan->list);
+
+	if (list_empty(&pxp_chan->active_list)) {
+		pr_debug("PXP_IRQ pxp_chan->active_list empty. chan_id %d\n",
+			 pxp_chan->dma_chan.chan_id);
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* Get descriptor and call callback */
+	desc = pxpdma_first_active(pxp_chan);
+
+	pxp_chan->completed = desc->txd.cookie;
+
+	callback = desc->txd.callback;
+	callback_param = desc->txd.callback_param;
+
+	/* Send histogram status back to caller */
+	desc->hist_status = hist_status;
+
+	if ((desc->txd.flags & DMA_PREP_INTERRUPT) && callback)
+		callback(callback_param);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+	list_move(&desc->list, &pxp_chan->free_list);
+
+	wake_up(&pxp->done);
+	pxp->pxp_ongoing = 0;
+	mod_timer(&pxp->clk_timer, jiffies + msecs_to_jiffies(timeout_in_ms));
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* called with pxp_chan->lock held */
+static struct pxp_tx_desc *pxpdma_desc_get(struct pxp_channel *pxp_chan)
+{
+	struct pxp_tx_desc *desc, *_desc;
+	struct pxp_tx_desc *ret = NULL;
+
+	list_for_each_entry_safe(desc, _desc, &pxp_chan->free_list, list) {
+		list_del_init(&desc->list);
+		ret = desc;
+		break;
+	}
+
+	return ret;
+}
+
+/* called with pxp_chan->lock held */
+static void pxpdma_desc_put(struct pxp_channel *pxp_chan,
+			    struct pxp_tx_desc *desc)
+{
+	if (desc) {
+		struct device *dev = &pxp_chan->dma_chan.dev->device;
+		struct pxp_tx_desc *child;
+
+		list_for_each_entry(child, &desc->tx_list, list)
+		    dev_info(dev, "moving child desc %p to freelist\n", child);
+		list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+		dev_info(dev, "moving desc %p to freelist\n", desc);
+		list_add(&desc->list, &pxp_chan->free_list);
+	}
+}
+
+/* Allocate and initialise a transfer descriptor. */
+static struct dma_async_tx_descriptor *pxp_prep_slave_sg(struct dma_chan *chan,
+							 struct scatterlist
+							 *sgl,
+							 unsigned int sg_len,
+							 enum dma_data_direction
+							 direction,
+							 unsigned long tx_flags)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc = NULL;
+	struct pxp_tx_desc *first = NULL, *prev = NULL;
+	struct scatterlist *sg;
+	unsigned long flags;
+	dma_addr_t phys_addr;
+	int i;
+
+	if (direction != DMA_FROM_DEVICE && direction != DMA_TO_DEVICE) {
+		dev_err(chan->device->dev, "Invalid DMA direction %d!\n",
+			direction);
+		return NULL;
+	}
+
+	if (unlikely(sg_len < 2))
+		return NULL;
+
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	for_each_sg(sgl, sg, sg_len, i) {
+		desc = pxpdma_desc_get(pxp_chan);
+		if (!desc) {
+			pxpdma_desc_put(pxp_chan, first);
+			dev_err(chan->device->dev, "Can't get DMA desc.\n");
+			spin_unlock_irqrestore(&pxp_chan->lock, flags);
+			return NULL;
+		}
+
+		phys_addr = sg_dma_address(sg);
+
+		if (!first) {
+			first = desc;
+
+			desc->layer_param.s0_param.paddr = phys_addr;
+		} else {
+			list_add_tail(&desc->list, &first->tx_list);
+			prev->next = desc;
+			desc->next = NULL;
+
+			if (i == 1)
+				desc->layer_param.out_param.paddr = phys_addr;
+			else
+				desc->layer_param.ol_param.paddr = phys_addr;
+		}
+
+		prev = desc;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp->pxp_conf_state.layer_nr = sg_len;
+	first->txd.flags = tx_flags;
+	first->len = sg_len;
+	pr_debug("%s:%d first %p, first->len %d, flags %08x\n",
+		 __func__, __LINE__, first, first->len, first->txd.flags);
+
+	return &first->txd;
+}
+
+static void pxp_issue_pending(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	unsigned long flags0, flags;
+
+	spin_lock_irqsave(&pxp->lock, flags0);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	if (!list_empty(&pxp_chan->queue)) {
+		pxpdma_dequeue(pxp_chan, &pxp_chan->active_list);
+		pxp_chan->status = PXP_CHANNEL_READY;
+		list_add_tail(&pxp_chan->list, &head);
+	} else {
+		spin_unlock_irqrestore(&pxp_chan->lock, flags);
+		spin_unlock_irqrestore(&pxp->lock, flags0);
+		return;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+	spin_unlock_irqrestore(&pxp->lock, flags0);
+
+	pxp_clk_enable(pxp);
+	if (!wait_event_interruptible_timeout(pxp->done, PXP_WAITCON, 2 * HZ) ||
+		signal_pending(current)) {
+		pxp_clk_disable(pxp);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	pxp->pxp_ongoing = 1;
+	spin_unlock_irqrestore(&pxp->lock, flags);
+	pxpdma_dostart_work(pxp);
+}
+
+static void __pxp_terminate_all(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	unsigned long flags;
+
+	/* pchan->queue is modified in ISR, have to spinlock */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	list_splice_init(&pxp_chan->queue, &pxp_chan->free_list);
+	list_splice_init(&pxp_chan->active_list, &pxp_chan->free_list);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+}
+
+static int pxp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			unsigned long arg)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	/* Only supports DMA_TERMINATE_ALL */
+	if (cmd != DMA_TERMINATE_ALL)
+		return -ENXIO;
+
+	mutex_lock(&pxp_chan->chan_mutex);
+	__pxp_terminate_all(chan);
+	mutex_unlock(&pxp_chan->chan_mutex);
+
+	return 0;
+}
+
+static int pxp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	int ret;
+
+	/* dmaengine.c now guarantees to only offer free channels */
+	BUG_ON(chan->client_count > 1);
+	WARN_ON(pxp_chan->status != PXP_CHANNEL_FREE);
+
+	chan->cookie = 1;
+	pxp_chan->completed = -ENXIO;
+
+	pr_debug("%s dma_chan.chan_id %d\n", __func__, chan->chan_id);
+	ret = pxp_init_channel(pxp_dma, pxp_chan);
+	if (ret < 0)
+		goto err_chan;
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	dev_dbg(&chan->dev->device, "Found channel 0x%x, irq %d\n",
+		chan->chan_id, pxp_chan->eof_irq);
+
+	return ret;
+
+err_chan:
+	return ret;
+}
+
+static void pxp_free_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	__pxp_terminate_all(chan);
+
+	pxp_chan->status = PXP_CHANNEL_FREE;
+
+	pxp_uninit_channel(pxp_dma, pxp_chan);
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+}
+
+static enum dma_status pxp_tx_status(struct dma_chan *chan,
+				     dma_cookie_t cookie,
+				     struct dma_tx_state *txstate)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	if (cookie != chan->cookie)
+		return DMA_ERROR;
+
+	if (txstate) {
+		txstate->last = pxp_chan->completed;
+		txstate->used = chan->cookie;
+		txstate->residue = 0;
+	}
+	return DMA_SUCCESS;
+}
+
+static int pxp_hw_init(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 reg_val;
+	int i;
+
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+
+	/* Config defaults */
+
+	/* Initialize non-channel-specific PxP parameters */
+	proc_data->drect.left = proc_data->srect.left = 0;
+	proc_data->drect.top = proc_data->srect.top = 0;
+	proc_data->drect.width = proc_data->srect.width = 0;
+	proc_data->drect.height = proc_data->srect.height = 0;
+	proc_data->scaling = 0;
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
+	/* Initialize S0 channel parameters */
+	pxp_conf->s0_param.pixel_fmt = pxp_s0_formats[0];
+	pxp_conf->s0_param.width = 0;
+	pxp_conf->s0_param.height = 0;
+	pxp_conf->s0_param.color_key = -1;
+	pxp_conf->s0_param.color_key_enable = false;
+
+	/* Initialize OL channel parameters */
+	for (i = 0; i < 8; i++) {
+		pxp_conf->ol_param[i].combine_enable = false;
+		pxp_conf->ol_param[i].width = 0;
+		pxp_conf->ol_param[i].height = 0;
+		pxp_conf->ol_param[i].pixel_fmt = PXP_PIX_FMT_RGB565;
+		pxp_conf->ol_param[i].color_key_enable = false;
+		pxp_conf->ol_param[i].color_key = -1;
+		pxp_conf->ol_param[i].global_alpha_enable = false;
+		pxp_conf->ol_param[i].global_alpha = 0;
+		pxp_conf->ol_param[i].local_alpha_enable = false;
+	}
+
+	/* Initialize Output channel parameters */
+	pxp_conf->out_param.width = 0;
+	pxp_conf->out_param.height = 0;
+	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
+
+	proc_data->overlay_state = 0;
+
+	/* Write default h/w config */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	for (i = 0; i < 8; i++) {
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		pxp_set_olcolorkey(i, pxp);
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	/* One-time histogram configuration */
+	reg_val =
+	    BF_PXP_HIST_CTRL_PANEL_MODE(BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST_CTRL);
+
+	reg_val = BF_PXP_HIST2_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST2_PARAM_VALUE1(0x00F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST2_PARAM);
+
+	reg_val = BF_PXP_HIST4_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST4_PARAM_VALUE1(0x05) |
+	    BF_PXP_HIST4_PARAM_VALUE2(0x0A) | BF_PXP_HIST4_PARAM_VALUE3(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST4_PARAM);
+
+	reg_val = BF_PXP_HIST8_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST8_PARAM0_VALUE1(0x02) |
+	    BF_PXP_HIST8_PARAM0_VALUE2(0x04) | BF_PXP_HIST8_PARAM0_VALUE3(0x06);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM0);
+	reg_val = BF_PXP_HIST8_PARAM1_VALUE4(0x09) |
+	    BF_PXP_HIST8_PARAM1_VALUE5(0x0B) |
+	    BF_PXP_HIST8_PARAM1_VALUE6(0x0D) | BF_PXP_HIST8_PARAM1_VALUE7(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM1);
+
+	reg_val = BF_PXP_HIST16_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST16_PARAM0_VALUE1(0x01) |
+	    BF_PXP_HIST16_PARAM0_VALUE2(0x02) |
+	    BF_PXP_HIST16_PARAM0_VALUE3(0x03);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM0);
+	reg_val = BF_PXP_HIST16_PARAM1_VALUE4(0x04) |
+	    BF_PXP_HIST16_PARAM1_VALUE5(0x05) |
+	    BF_PXP_HIST16_PARAM1_VALUE6(0x06) |
+	    BF_PXP_HIST16_PARAM1_VALUE7(0x07);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM1);
+	reg_val = BF_PXP_HIST16_PARAM2_VALUE8(0x08) |
+	    BF_PXP_HIST16_PARAM2_VALUE9(0x09) |
+	    BF_PXP_HIST16_PARAM2_VALUE10(0x0A) |
+	    BF_PXP_HIST16_PARAM2_VALUE11(0x0B);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM2);
+	reg_val = BF_PXP_HIST16_PARAM3_VALUE12(0x0C) |
+	    BF_PXP_HIST16_PARAM3_VALUE13(0x0D) |
+	    BF_PXP_HIST16_PARAM3_VALUE14(0x0E) |
+	    BF_PXP_HIST16_PARAM3_VALUE15(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM3);
+
+	return 0;
+}
+
+static int pxp_dma_init(struct pxps *pxp)
+{
+	struct pxp_dma *pxp_dma = &pxp->pxp_dma;
+	struct dma_device *dma = &pxp_dma->dma;
+	int i;
+
+	dma_cap_set(DMA_SLAVE, dma->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma->cap_mask);
+
+	/* Compulsory common fields */
+	dma->dev = pxp->dev;
+	dma->device_alloc_chan_resources = pxp_alloc_chan_resources;
+	dma->device_free_chan_resources = pxp_free_chan_resources;
+	dma->device_tx_status = pxp_tx_status;
+	dma->device_issue_pending = pxp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma->device_prep_slave_sg = pxp_prep_slave_sg;
+	dma->device_control = pxp_control;
+
+	/* Initialize PxP Channels */
+	INIT_LIST_HEAD(&dma->channels);
+	for (i = 0; i < NR_PXP_VIRT_CHANNEL; i++) {
+		struct pxp_channel *pxp_chan = pxp->channel + i;
+		struct dma_chan *dma_chan = &pxp_chan->dma_chan;
+
+		spin_lock_init(&pxp_chan->lock);
+		mutex_init(&pxp_chan->chan_mutex);
+
+		/* Only one EOF IRQ for PxP, shared by all channels */
+		pxp_chan->eof_irq = pxp->irq;
+		pxp_chan->status = PXP_CHANNEL_FREE;
+		pxp_chan->completed = -ENXIO;
+		snprintf(pxp_chan->eof_name, sizeof(pxp_chan->eof_name),
+			 "PXP EOF %d", i);
+
+		dma_chan->device = &pxp_dma->dma;
+		dma_chan->cookie = 1;
+		dma_chan->chan_id = i;
+		list_add_tail(&dma_chan->device_node, &dma->channels);
+	}
+
+	return dma_async_device_register(&pxp_dma->dma);
+}
+
+static ssize_t clk_off_timeout_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", timeout_in_ms);
+}
+
+static ssize_t clk_off_timeout_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int val;
+	if (sscanf(buf, "%d", &val) > 0) {
+		timeout_in_ms = val;
+		return count;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(clk_off_timeout, 0644, clk_off_timeout_show,
+		   clk_off_timeout_store);
+
+static int pxp_probe(struct platform_device *pdev)
+{
+	struct pxps *pxp;
+	struct resource *res;
+	int irq;
+	int err = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || irq < 0) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pxp = kzalloc(sizeof(*pxp), GFP_KERNEL);
+	if (!pxp) {
+		dev_err(&pdev->dev, "failed to allocate control object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	pxp->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, pxp);
+	pxp->irq = irq;
+
+	pxp->pxp_ongoing = 0;
+	pxp->lut_state = 0;
+
+	spin_lock_init(&pxp->lock);
+	mutex_init(&pxp->clk_mutex);
+
+	if (!request_mem_region(res->start, resource_size(res), "pxp-mem")) {
+		err = -EBUSY;
+		goto freepxp;
+	}
+
+	pxp->base = ioremap(res->start, SZ_4K);
+	pxp->pdev = pdev;
+
+	pxp->clk = clk_get(NULL, "pxp_axi");
+	clk_enable(pxp->clk);
+
+	err = pxp_hw_init(pxp);
+	if (err) {
+		dev_err(&pdev->dev, "failed to initialize hardware\n");
+		goto release;
+	}
+	clk_disable(pxp->clk);
+
+	err = request_irq(pxp->irq, pxp_irq, 0, "pxp-irq", pxp);
+	if (err)
+		goto release;
+	/* Initialize DMA engine */
+	err = pxp_dma_init(pxp);
+	if (err < 0)
+		goto err_dma_init;
+
+	if (device_create_file(&pdev->dev, &dev_attr_clk_off_timeout)) {
+		dev_err(&pdev->dev,
+			"Unable to create file from clk_off_timeout\n");
+		goto err_dma_init;
+	}
+
+	INIT_WORK(&pxp->work, clkoff_callback);
+	init_waitqueue_head(&pxp->done);
+	init_timer(&pxp->clk_timer);
+	pxp->clk_timer.function = pxp_clkoff_timer;
+	pxp->clk_timer.data = (unsigned long)pxp;
+exit:
+	return err;
+err_dma_init:
+	free_irq(pxp->irq, pxp);
+release:
+	release_mem_region(res->start, resource_size(res));
+freepxp:
+	kfree(pxp);
+	dev_err(&pdev->dev, "Exiting (unsuccessfully) pxp_probe function\n");
+	return err;
+}
+
+static int __devexit pxp_remove(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&pxp->work);
+	del_timer_sync(&pxp->clk_timer);
+	free_irq(pxp->irq, pxp);
+	clk_disable(pxp->clk);
+	clk_put(pxp->clk);
+	iounmap(pxp->base);
+	device_remove_file(&pdev->dev, &dev_attr_clk_off_timeout);
+
+	kfree(pxp);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	__raw_writel(BM_PXP_CTRL_SFTRST, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+
+static int pxp_resume(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+#else
+#define	pxp_suspend	NULL
+#define	pxp_resume	NULL
+#endif
+
+static struct platform_driver pxp_driver = {
+	.driver = {
+		   .name = "imx-pxp",
+		   },
+	.probe = pxp_probe,
+	.remove = __exit_p(pxp_remove),
+	.suspend = pxp_suspend,
+	.resume = pxp_resume,
+};
+
+static int __init pxp_init(void)
+{
+	return platform_driver_register(&pxp_driver);
+}
+
+subsys_initcall(pxp_init);
+
+static void __exit pxp_exit(void)
+{
+	platform_driver_unregister(&pxp_driver);
+}
+
+module_exit(pxp_exit);
+
+MODULE_DESCRIPTION("i.MX PxP driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
new file mode 100644
index 0000000..0d3cfdf
--- /dev/null
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -0,0 +1,1683 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+
+#include "regs-pxp_v2.h"
+
+#define	PXP_DOWNSCALE_THRESHOLD		0x4000
+
+static LIST_HEAD(head);
+static int timeout_in_ms = 600;
+
+struct pxp_dma {
+	struct dma_device dma;
+};
+
+struct pxps {
+	struct platform_device *pdev;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;		/* PXP IRQ to the CPU */
+
+	spinlock_t lock;
+	struct mutex clk_mutex;
+	int clk_stat;
+#define	CLK_STAT_OFF		0
+#define	CLK_STAT_ON		1
+	int pxp_ongoing;
+	int lut_state;
+
+	struct device *dev;
+	struct pxp_dma pxp_dma;
+	struct pxp_channel channel[NR_PXP_VIRT_CHANNEL];
+	wait_queue_head_t done;
+	struct work_struct work;
+
+	/* describes most recent processing configuration */
+	struct pxp_config_data pxp_conf_state;
+
+	/* to turn clock off when pxp is inactive */
+	struct timer_list clk_timer;
+};
+
+#define to_pxp_dma(d) container_of(d, struct pxp_dma, dma)
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+#define to_pxp(id) container_of(id, struct pxps, pxp_dma)
+
+#define PXP_DEF_BUFS	2
+#define PXP_MIN_PIX	8
+
+#define PXP_WAITCON	((__raw_readl(pxp->base + HW_PXP_STAT) & \
+				BM_PXP_STAT_IRQ) != BM_PXP_STAT_IRQ)
+
+static uint32_t pxp_s0_formats[] = {
+	PXP_PIX_FMT_RGB24,
+	PXP_PIX_FMT_RGB565,
+	PXP_PIX_FMT_RGB555,
+	PXP_PIX_FMT_YUV420P,
+	PXP_PIX_FMT_YUV422P,
+};
+
+/*
+ * PXP common functions
+ */
+static void dump_pxp_reg(struct pxps *pxp)
+{
+	dev_dbg(pxp->dev, "PXP_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CTRL));
+	dev_dbg(pxp->dev, "PXP_STAT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_STAT));
+	dev_dbg(pxp->dev, "PXP_OUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_CTRL));
+	dev_dbg(pxp->dev, "PXP_OUT_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_BUF));
+	dev_dbg(pxp->dev, "PXP_OUT_BUF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_BUF2));
+	dev_dbg(pxp->dev, "PXP_OUT_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PITCH));
+	dev_dbg(pxp->dev, "PXP_OUT_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_LRC));
+	dev_dbg(pxp->dev, "PXP_OUT_PS_ULC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PS_ULC));
+	dev_dbg(pxp->dev, "PXP_OUT_PS_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PS_LRC));
+	dev_dbg(pxp->dev, "PXP_OUT_AS_ULC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_AS_ULC));
+	dev_dbg(pxp->dev, "PXP_OUT_AS_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_AS_LRC));
+	dev_dbg(pxp->dev, "PXP_PS_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CTRL));
+	dev_dbg(pxp->dev, "PXP_PS_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_BUF));
+	dev_dbg(pxp->dev, "PXP_PS_UBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_UBUF));
+	dev_dbg(pxp->dev, "PXP_PS_VBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_VBUF));
+	dev_dbg(pxp->dev, "PXP_PS_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_PITCH));
+	dev_dbg(pxp->dev, "PXP_PS_BACKGROUND 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_BACKGROUND));
+	dev_dbg(pxp->dev, "PXP_PS_SCALE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_SCALE));
+	dev_dbg(pxp->dev, "PXP_PS_OFFSET 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_OFFSET));
+	dev_dbg(pxp->dev, "PXP_PS_CLRKEYLOW 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CLRKEYLOW));
+	dev_dbg(pxp->dev, "PXP_PS_CLRKEYHIGH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CLRKEYHIGH));
+	dev_dbg(pxp->dev, "PXP_AS_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CTRL));
+	dev_dbg(pxp->dev, "PXP_AS_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_BUF));
+	dev_dbg(pxp->dev, "PXP_AS_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_PITCH));
+	dev_dbg(pxp->dev, "PXP_AS_CLRKEYLOW 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CLRKEYLOW));
+	dev_dbg(pxp->dev, "PXP_AS_CLRKEYHIGH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CLRKEYHIGH));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF0));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF1));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_CTRL));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF0));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF1));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF3));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF4 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF4));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF5 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF5));
+	dev_dbg(pxp->dev, "PXP_LUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_CTRL));
+	dev_dbg(pxp->dev, "PXP_LUT_ADDR 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_ADDR));
+	dev_dbg(pxp->dev, "PXP_LUT_DATA 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_DATA));
+	dev_dbg(pxp->dev, "PXP_LUT_EXTMEM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_EXTMEM));
+	dev_dbg(pxp->dev, "PXP_CFA 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CFA));
+	dev_dbg(pxp->dev, "PXP_HIST_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST_CTRL));
+	dev_dbg(pxp->dev, "PXP_HIST2_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST2_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST4_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST4_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM2));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM3));
+	dev_dbg(pxp->dev, "PXP_POWER 0x%x",
+		__raw_readl(pxp->base + HW_PXP_POWER));
+	dev_dbg(pxp->dev, "PXP_NEXT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_NEXT));
+	dev_dbg(pxp->dev, "PXP_DEBUGCTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_DEBUGCTRL));
+	dev_dbg(pxp->dev, "PXP_DEBUG 0x%x",
+		__raw_readl(pxp->base + HW_PXP_DEBUG));
+	dev_dbg(pxp->dev, "PXP_VERSION 0x%x",
+		__raw_readl(pxp->base + HW_PXP_VERSION));
+}
+
+static bool is_yuv(u32 pix_fmt)
+{
+	if ((pix_fmt == PXP_PIX_FMT_YUYV) |
+	    (pix_fmt == PXP_PIX_FMT_UYVY) |
+	    (pix_fmt == PXP_PIX_FMT_Y41P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV444) |
+	    (pix_fmt == PXP_PIX_FMT_NV12) |
+	    (pix_fmt == PXP_PIX_FMT_GREY) |
+	    (pix_fmt == PXP_PIX_FMT_GY04) |
+	    (pix_fmt == PXP_PIX_FMT_YVU410P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV410P) |
+	    (pix_fmt == PXP_PIX_FMT_YVU420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P2) |
+	    (pix_fmt == PXP_PIX_FMT_YVU422P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV422P)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void pxp_set_ctrl(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 ctrl;
+	u32 fmt_ctrl;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV420;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__Y8;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__Y4;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV422;
+		break;
+	case PXP_PIX_FMT_UYVY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_PS_CTRL_FORMAT(fmt_ctrl);
+	__raw_writel(ctrl, pxp->base + HW_PXP_PS_CTRL);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__YUV2P420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__YUV2P422;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__Y8;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__Y4;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_OUT_CTRL_FORMAT(fmt_ctrl);
+	__raw_writel(ctrl, pxp->base + HW_PXP_OUT_CTRL);
+
+	ctrl = 0;
+	if (proc_data->scaling)
+		;
+	if (proc_data->vflip)
+		ctrl |= BM_PXP_CTRL_VFLIP;
+	if (proc_data->hflip)
+		ctrl |= BM_PXP_CTRL_HFLIP;
+	if (proc_data->rotate)
+		ctrl |= BF_PXP_CTRL_ROTATE(proc_data->rotate / 90);
+
+	/* H/W support: controls where rotation will occur in the PXP datapath,
+	 * will export an interfance if needed
+	 */
+	/* ctrl |= BM_PXP_CTRL_ROT_POS; post rotation */
+
+	__raw_writel(ctrl, pxp->base + HW_PXP_CTRL);
+}
+
+static int pxp_start(struct pxps *pxp)
+{
+	__raw_writel(BM_PXP_CTRL_IRQ_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	__raw_writel(BM_PXP_CTRL_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	dump_pxp_reg(pxp);
+
+	return 0;
+}
+
+static void pxp_set_outbuf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	__raw_writel(out_params->paddr, pxp->base + HW_PXP_OUT_BUF);
+
+	__raw_writel(BF_PXP_OUT_LRC_X(out_params->width - 1) |
+		     BF_PXP_OUT_LRC_Y(out_params->height - 1),
+		     pxp->base + HW_PXP_OUT_LRC);
+
+	if (out_params->pixel_fmt == PXP_PIX_FMT_RGB24)
+		__raw_writel(out_params->stride << 2,
+				pxp->base + HW_PXP_OUT_PITCH);
+	else if (out_params->pixel_fmt == PXP_PIX_FMT_RGB565)
+		__raw_writel(out_params->stride << 1,
+				pxp->base + HW_PXP_OUT_PITCH);
+	else
+		__raw_writel(out_params->stride, pxp->base + HW_PXP_OUT_PITCH);
+}
+
+static void pxp_set_s0colorkey(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (s0_params->color_key == -1) {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_PS_CLRKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_PS_CLRKEYHIGH);
+	} else {
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_PS_CLRKEYLOW);
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_PS_CLRKEYHIGH);
+	}
+}
+
+static void pxp_set_olcolorkey(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[layer_no];
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (ol_params->color_key_enable != 0 && ol_params->color_key != -1) {
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_AS_CLRKEYLOW);
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_AS_CLRKEYHIGH);
+	} else {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_AS_CLRKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_AS_CLRKEYHIGH);
+	}
+}
+
+static void pxp_set_oln(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	dma_addr_t phys_addr = olparams_data->paddr;
+	__raw_writel(phys_addr, pxp->base + HW_PXP_AS_BUF);
+
+	/* Fixme */
+	__raw_writel(0x0, pxp->base + HW_PXP_OUT_AS_ULC);
+	__raw_writel(BF_PXP_OUT_AS_LRC_X(olparams_data->width) |
+		     BF_PXP_OUT_AS_LRC_Y(olparams_data->height),
+		     pxp->base + HW_PXP_OUT_AS_LRC);
+
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		__raw_writel(olparams_data->width << 2,
+				pxp->base + HW_PXP_AS_PITCH);
+	else
+		__raw_writel(olparams_data->width << 1,
+				pxp->base + HW_PXP_AS_PITCH);
+}
+
+static void pxp_set_olparam(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	u32 olparam;
+
+	olparam = BF_PXP_AS_CTRL_ALPHA(olparams_data->global_alpha);
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		olparam |=
+		    BF_PXP_AS_CTRL_FORMAT(BV_PXP_AS_CTRL_FORMAT__RGB888);
+	else
+		olparam |=
+		    BF_PXP_AS_CTRL_FORMAT(BV_PXP_AS_CTRL_FORMAT__RGB565);
+	if (olparams_data->global_alpha_enable)
+		olparam |=
+		    BF_PXP_AS_CTRL_ALPHA_CTRL
+		    (BV_PXP_AS_CTRL_ALPHA_CTRL__Override);
+	if (olparams_data->color_key_enable)
+		olparam |= BM_PXP_AS_CTRL_ENABLE_COLORKEY;
+	if (olparams_data->combine_enable)
+		;
+	__raw_writel(olparam, pxp->base + HW_PXP_AS_CTRL);
+}
+
+static void pxp_set_s0param(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 s0param;
+
+	/* contains the coordinate for the PS in the OUTPUT buffer. */
+	s0param = BF_PXP_OUT_PS_ULC_X(proc_data->drect.left);
+	s0param |= BF_PXP_OUT_PS_ULC_Y(proc_data->drect.top);
+	__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_ULC);
+	s0param = BF_PXP_OUT_PS_LRC_X(proc_data->drect.left +
+					proc_data->drect.width - 1);
+	s0param |= BF_PXP_OUT_PS_LRC_Y(proc_data->drect.top +
+					proc_data->drect.height - 1);
+	__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_LRC);
+}
+
+/* crop behavior is re-designed in h/w. */
+static void pxp_set_s0crop(struct pxps *pxp)
+{
+	/*
+	 * place-holder, it's implemented in other functions in this driver.
+	 * Refer to "Clipping source images" section in RM for detail.
+	 */
+}
+
+static int pxp_set_scaling(struct pxps *pxp)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+
+	if ((proc_data->srect.width == proc_data->drect.width) &&
+	    (proc_data->srect.height == proc_data->drect.height)) {
+		proc_data->scaling = 0;
+		__raw_writel(0x10001000, pxp->base + HW_PXP_PS_SCALE);
+		goto out;
+	}
+
+	proc_data->scaling = 1;
+	xscale = proc_data->srect.width * 0x1000 / proc_data->drect.width;
+	yscale = proc_data->srect.height * 0x1000 / proc_data->drect.height;
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_PS_SCALE_YSCALE(yscale) |
+		BF_PXP_PS_SCALE_XSCALE(xscale);
+	__raw_writel(s0scale, pxp->base + HW_PXP_PS_SCALE);
+
+out:
+	pxp_set_ctrl(pxp);
+
+	return ret;
+}
+
+static void pxp_set_bg(struct pxps *pxp)
+{
+	__raw_writel(pxp->pxp_conf_state.proc_data.bgcolor,
+		     pxp->base + HW_PXP_PS_BACKGROUND);
+}
+
+static void pxp_set_lut(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	int lut_op = pxp_conf->proc_data.lut_transform;
+	u32 reg_val;
+	int i;
+	bool use_cmap = (lut_op & PXP_LUT_USE_CMAP) ? true : false;
+	u8 *cmap = pxp_conf->proc_data.lut_map;
+	u32 entry_src;
+	u32 pix_val;
+	u8 entry[4];
+
+	/*
+	 * If LUT already configured as needed, return...
+	 * Unless CMAP is needed and it has been updated.
+	 */
+	if ((pxp->lut_state == lut_op) &&
+		!(use_cmap && pxp_conf->proc_data.lut_map_updated))
+		return;
+
+	if (lut_op == PXP_LUT_NONE) {
+		__raw_writel(BM_PXP_LUT_CTRL_BYPASS,
+			     pxp->base + HW_PXP_LUT_CTRL);
+	} else if (((lut_op & PXP_LUT_INVERT) != 0)
+		&& ((lut_op & PXP_LUT_BLACK_WHITE) != 0)) {
+		/* Fill out LUT table with inverted monochromized values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ? cmap[pix_val + i] : pix_val + i;
+				entry[i] = (entry_src < 0x80) ? 0xFF : 0x00;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if ((lut_op & PXP_LUT_INVERT) != 0) {
+		/* Fill out LUT table with 8-bit inverted values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ? cmap[pix_val + i] : pix_val + i;
+				entry[i] = ~entry_src & 0xFF;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if ((lut_op & PXP_LUT_BLACK_WHITE) != 0) {
+		/* Fill out LUT table with 8-bit monochromized values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ? cmap[pix_val + i] : pix_val + i;
+				entry[i] = (entry_src < 0x80) ? 0x00 : 0xFF;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if (use_cmap) {
+		/* Fill out LUT table using colormap values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++)
+				entry[i] = cmap[pix_val + i];
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	}
+
+	pxp->lut_state = lut_op;
+}
+
+static void pxp_set_csc(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[0];
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	bool input_is_YUV = is_yuv(s0_params->pixel_fmt);
+	bool output_is_YUV = is_yuv(out_params->pixel_fmt);
+
+	if (input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = YUV, Output = YUV
+		 * No CSC unless we need to do combining
+		 */
+		if (ol_params->combine_enable) {
+			/* Must convert to RGB for combining with RGB overlay */
+
+			/* CSC1 - YUV->RGB */
+			__raw_writel(0x04030000, pxp->base + HW_PXP_CSC1_COEF0);
+			__raw_writel(0x01230208, pxp->base + HW_PXP_CSC1_COEF1);
+			__raw_writel(0x076b079c, pxp->base + HW_PXP_CSC1_COEF2);
+
+			/* CSC2 - RGB->YUV */
+			__raw_writel(0x4, pxp->base + HW_PXP_CSC2_CTRL);
+			__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2_COEF0);
+			__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2_COEF1);
+			__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2_COEF2);
+			__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2_COEF3);
+			__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2_COEF4);
+			__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2_COEF5);
+		} else {
+			/* Input & Output both YUV, so bypass both CSCs */
+
+			/* CSC1 - Bypass */
+			__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+			/* CSC2 - Bypass */
+			__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+		}
+	} else if (input_is_YUV && !output_is_YUV) {
+		/*
+		 * Input = YUV, Output = RGB
+		 * Use CSC1 to convert to RGB
+		 */
+
+		/* CSC1 - YUV->RGB */
+		__raw_writel(0x84ab01f0, pxp->base + HW_PXP_CSC1_COEF0);
+		__raw_writel(0x01980204, pxp->base + HW_PXP_CSC1_COEF1);
+		__raw_writel(0x0730079c, pxp->base + HW_PXP_CSC1_COEF2);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+	} else if (!input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = RGB, Output = YUV
+		 * Use CSC2 to convert to YUV
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+		/* CSC2 - RGB->YUV */
+		__raw_writel(0x4, pxp->base + HW_PXP_CSC2_CTRL);
+		__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2_COEF0);
+		__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2_COEF1);
+		__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2_COEF2);
+		__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2_COEF3);
+		__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2_COEF4);
+		__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2_COEF5);
+	} else {
+		/*
+		 * Input = RGB, Output = RGB
+		 * Input & Output both RGB, so bypass both CSCs
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+	}
+
+	/* YCrCb colorspace */
+	/* Not sure when we use this...no YCrCb formats are defined for PxP */
+	/*
+	   __raw_writel(0x84ab01f0, HW_PXP_CSCCOEFF0_ADDR);
+	   __raw_writel(0x01230204, HW_PXP_CSCCOEFF1_ADDR);
+	   __raw_writel(0x0730079c, HW_PXP_CSCCOEFF2_ADDR);
+	 */
+
+}
+
+static void pxp_set_s0buf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	dma_addr_t Y, U, V;
+	dma_addr_t Y1, U1, V1;
+	u32 offset, bpp = 1;
+
+	Y = s0_params->paddr;
+
+	if (s0_params->pixel_fmt == PXP_PIX_FMT_RGB565)
+		bpp = 2;
+	else if (s0_params->pixel_fmt == PXP_PIX_FMT_RGB24)
+		bpp = 4;
+	offset = (proc_data->srect.top * s0_params->width +
+		 proc_data->srect.left) * bpp;
+	/* clipping or cropping */
+	Y1 = Y + offset;
+	__raw_writel(Y1, pxp->base + HW_PXP_PS_BUF);
+	if ((s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_YVU420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_GREY)) {
+		/* Set to 1 if YUV format is 4:2:2 rather than 4:2:0 */
+		int s = 2;
+
+		offset = proc_data->srect.top * s0_params->width / 4 +
+			 proc_data->srect.left / 2;
+		U = Y + (s0_params->width * s0_params->height);
+		U1 = U + offset;
+		V = U + ((s0_params->width * s0_params->height) >> s);
+		V1 = V + offset;
+		__raw_writel(U1, pxp->base + HW_PXP_PS_UBUF);
+		__raw_writel(V1, pxp->base + HW_PXP_PS_VBUF);
+	}
+
+	/* TODO: only support RGB565, Y8, Y4, YUV420 */
+	if (s0_params->pixel_fmt == PXP_PIX_FMT_GREY ||
+	    s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P)
+		__raw_writel(s0_params->width, pxp->base + HW_PXP_PS_PITCH);
+	else if (s0_params->pixel_fmt == PXP_PIX_FMT_GY04)
+		__raw_writel(s0_params->width >> 1, pxp->base + HW_PXP_PS_PITCH);
+	else
+		__raw_writel(s0_params->width * 2, pxp->base + HW_PXP_PS_PITCH);
+}
+
+/**
+ * pxp_config() - configure PxP for a processing task
+ * @pxps:	PXP context.
+ * @pxp_chan:	PXP channel.
+ * @return:	0 on success or negative error code on failure.
+ */
+static int pxp_config(struct pxps *pxp, struct pxp_channel *pxp_chan)
+{
+	struct pxp_config_data *pxp_conf_data = &pxp->pxp_conf_state;
+	int ol_nr;
+	int i;
+
+	/* Configure PxP regs */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	pxp_set_scaling(pxp);
+	ol_nr = pxp_conf_data->layer_nr - 2;
+	while (ol_nr > 0) {
+		i = pxp_conf_data->layer_nr - 2 - ol_nr;
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		/* only the color key in higher overlay will take effect. */
+		pxp_set_olcolorkey(i, pxp);
+		ol_nr--;
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	pxp_set_s0buf(pxp);
+	pxp_set_outbuf(pxp);
+
+	return 0;
+}
+
+static void pxp_clk_enable(struct pxps *pxp)
+{
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_ON) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	clk_enable(pxp->clk);
+	pxp->clk_stat = CLK_STAT_ON;
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static void pxp_clk_disable(struct pxps *pxp)
+{
+	unsigned long flags;
+
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_OFF) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head)) {
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		clk_disable(pxp->clk);
+		pxp->clk_stat = CLK_STAT_OFF;
+	} else
+		spin_unlock_irqrestore(&pxp->lock, flags);
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static inline void clkoff_callback(struct work_struct *w)
+{
+	struct pxps *pxp = container_of(w, struct pxps, work);
+
+	pxp_clk_disable(pxp);
+}
+
+static void pxp_clkoff_timer(unsigned long arg)
+{
+	struct pxps *pxp = (struct pxps *)arg;
+
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head))
+		schedule_work(&pxp->work);
+	else
+		mod_timer(&pxp->clk_timer,
+			  jiffies + msecs_to_jiffies(timeout_in_ms));
+}
+
+static struct pxp_tx_desc *pxpdma_first_active(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->active_list.next, struct pxp_tx_desc, list);
+}
+
+static struct pxp_tx_desc *pxpdma_first_queued(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->queue.next, struct pxp_tx_desc, list);
+}
+
+/* called with pxp_chan->lock held */
+static void __pxpdma_dostart(struct pxp_channel *pxp_chan)
+{
+	struct pxp_dma *pxp_dma = to_pxp_dma(pxp_chan->dma_chan.device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc;
+	struct pxp_tx_desc *child;
+	int i = 0;
+
+	/* so far we presume only one transaction on active_list */
+	/* S0 */
+	desc = pxpdma_first_active(pxp_chan);
+	memcpy(&pxp->pxp_conf_state.s0_param,
+	       &desc->layer_param.s0_param, sizeof(struct pxp_layer_param));
+	memcpy(&pxp->pxp_conf_state.proc_data,
+	       &desc->proc_data, sizeof(struct pxp_proc_data));
+
+	/* Save PxP configuration */
+	list_for_each_entry(child, &desc->tx_list, list) {
+		if (i == 0) {	/* Output */
+			memcpy(&pxp->pxp_conf_state.out_param,
+			       &child->layer_param.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {	/* Overlay */
+			memcpy(&pxp->pxp_conf_state.ol_param[i - 1],
+			       &child->layer_param.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		i++;
+	}
+	pr_debug("%s:%d S0 w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.s0_param.width,
+		 pxp->pxp_conf_state.s0_param.height,
+		 pxp->pxp_conf_state.s0_param.paddr);
+	pr_debug("%s:%d OUT w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.out_param.width,
+		 pxp->pxp_conf_state.out_param.height,
+		 pxp->pxp_conf_state.out_param.paddr);
+}
+
+static void pxpdma_dostart_work(struct pxps *pxp)
+{
+	struct pxp_channel *pxp_chan = NULL;
+	unsigned long flags, flags1;
+
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+
+	spin_lock_irqsave(&pxp_chan->lock, flags1);
+	if (!list_empty(&pxp_chan->active_list)) {
+		struct pxp_tx_desc *desc;
+		/* REVISIT */
+		desc = pxpdma_first_active(pxp_chan);
+		__pxpdma_dostart(pxp_chan);
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags1);
+
+	/* Configure PxP */
+	pxp_config(pxp, pxp_chan);
+
+	pxp_start(pxp);
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+}
+
+static void pxpdma_dequeue(struct pxp_channel *pxp_chan, struct list_head *list)
+{
+	struct pxp_tx_desc *desc = NULL;
+	do {
+		desc = pxpdma_first_queued(pxp_chan);
+		list_move_tail(&desc->list, list);
+	} while (!list_empty(&pxp_chan->queue));
+}
+
+static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct pxp_tx_desc *desc = to_tx_desc(tx);
+	struct pxp_channel *pxp_chan = to_pxp_channel(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "received TX\n");
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	cookie = pxp_chan->dma_chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	/* from dmaengine.h: "last cookie value returned to client" */
+	pxp_chan->dma_chan.cookie = cookie;
+	tx->cookie = cookie;
+
+	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	/* Here we add the tx descriptor to our PxP task queue. */
+	list_add_tail(&desc->list, &pxp_chan->queue);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "done TX\n");
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+	return cookie;
+}
+
+/* Called with pxp_chan->chan_mutex held */
+static int pxp_desc_alloc(struct pxp_channel *pxp_chan, int n)
+{
+	struct pxp_tx_desc *desc = vmalloc(n * sizeof(struct pxp_tx_desc));
+
+	if (!desc)
+		return -ENOMEM;
+
+	pxp_chan->n_tx_desc = n;
+	pxp_chan->desc = desc;
+	INIT_LIST_HEAD(&pxp_chan->active_list);
+	INIT_LIST_HEAD(&pxp_chan->queue);
+	INIT_LIST_HEAD(&pxp_chan->free_list);
+
+	while (n--) {
+		struct dma_async_tx_descriptor *txd = &desc->txd;
+
+		memset(txd, 0, sizeof(*txd));
+		INIT_LIST_HEAD(&desc->tx_list);
+		dma_async_tx_descriptor_init(txd, &pxp_chan->dma_chan);
+		txd->tx_submit = pxp_tx_submit;
+
+		list_add(&desc->list, &pxp_chan->free_list);
+
+		desc++;
+	}
+
+	return 0;
+}
+
+/**
+ * pxp_init_channel() - initialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_init_channel(struct pxp_dma *pxp_dma,
+			    struct pxp_channel *pxp_chan)
+{
+	unsigned long flags;
+	struct pxps *pxp = to_pxp(pxp_dma);
+	int ret = 0, n_desc = 0;
+
+	/*
+	 * We are using _virtual_ channel here.
+	 * Each channel contains all parameters of corresponding layers
+	 * for one transaction; each layer is represented as one descriptor
+	 * (i.e., pxp_tx_desc) here.
+	 */
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	/* max desc nr: S0+OL+OUT = 1+8+1 */
+	n_desc = 16;
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	if (n_desc && !pxp_chan->desc)
+		ret = pxp_desc_alloc(pxp_chan, n_desc);
+
+	return ret;
+}
+
+/**
+ * pxp_uninit_channel() - uninitialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_uninit_channel(struct pxp_dma *pxp_dma,
+			      struct pxp_channel *pxp_chan)
+{
+	int ret = 0;
+
+	if (pxp_chan->desc)
+		vfree(pxp_chan->desc);
+
+	pxp_chan->desc = NULL;
+
+	return ret;
+}
+
+static irqreturn_t pxp_irq(int irq, void *dev_id)
+{
+	struct pxps *pxp = dev_id;
+	struct pxp_channel *pxp_chan;
+	struct pxp_tx_desc *desc;
+	dma_async_tx_callback callback;
+	void *callback_param;
+	unsigned long flags;
+	u32 hist_status;
+
+	dump_pxp_reg(pxp);
+
+	hist_status =
+	    __raw_readl(pxp->base + HW_PXP_HIST_CTRL) & BM_PXP_HIST_CTRL_STATUS;
+
+	__raw_writel(BM_PXP_STAT_IRQ, pxp->base + HW_PXP_STAT_CLR);
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+	list_del_init(&pxp_chan->list);
+
+	if (list_empty(&pxp_chan->active_list)) {
+		pr_debug("PXP_IRQ pxp_chan->active_list empty. chan_id %d\n",
+			 pxp_chan->dma_chan.chan_id);
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* Get descriptor and call callback */
+	desc = pxpdma_first_active(pxp_chan);
+
+	pxp_chan->completed = desc->txd.cookie;
+
+	callback = desc->txd.callback;
+	callback_param = desc->txd.callback_param;
+
+	/* Send histogram status back to caller */
+	desc->hist_status = hist_status;
+
+	if ((desc->txd.flags & DMA_PREP_INTERRUPT) && callback)
+		callback(callback_param);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+	list_move(&desc->list, &pxp_chan->free_list);
+
+	wake_up(&pxp->done);
+	pxp->pxp_ongoing = 0;
+	mod_timer(&pxp->clk_timer, jiffies + msecs_to_jiffies(timeout_in_ms));
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* called with pxp_chan->lock held */
+static struct pxp_tx_desc *pxpdma_desc_get(struct pxp_channel *pxp_chan)
+{
+	struct pxp_tx_desc *desc, *_desc;
+	struct pxp_tx_desc *ret = NULL;
+
+	list_for_each_entry_safe(desc, _desc, &pxp_chan->free_list, list) {
+		list_del_init(&desc->list);
+		ret = desc;
+		break;
+	}
+
+	return ret;
+}
+
+/* called with pxp_chan->lock held */
+static void pxpdma_desc_put(struct pxp_channel *pxp_chan,
+			    struct pxp_tx_desc *desc)
+{
+	if (desc) {
+		struct device *dev = &pxp_chan->dma_chan.dev->device;
+		struct pxp_tx_desc *child;
+
+		list_for_each_entry(child, &desc->tx_list, list)
+		    dev_info(dev, "moving child desc %p to freelist\n", child);
+		list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+		dev_info(dev, "moving desc %p to freelist\n", desc);
+		list_add(&desc->list, &pxp_chan->free_list);
+	}
+}
+
+/* Allocate and initialise a transfer descriptor. */
+static struct dma_async_tx_descriptor *pxp_prep_slave_sg(struct dma_chan *chan,
+							 struct scatterlist
+							 *sgl,
+							 unsigned int sg_len,
+							 enum dma_transfer_direction
+							 direction,
+							 unsigned long tx_flags,
+							 void *context)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc = NULL;
+	struct pxp_tx_desc *first = NULL, *prev = NULL;
+	struct scatterlist *sg;
+	unsigned long flags;
+	dma_addr_t phys_addr;
+	int i;
+
+	if (direction != DMA_DEV_TO_MEM && direction != DMA_MEM_TO_DEV) {
+		dev_err(chan->device->dev, "Invalid DMA direction %d!\n",
+			direction);
+		return NULL;
+	}
+
+	if (unlikely(sg_len < 2))
+		return NULL;
+
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	for_each_sg(sgl, sg, sg_len, i) {
+		desc = pxpdma_desc_get(pxp_chan);
+		if (!desc) {
+			pxpdma_desc_put(pxp_chan, first);
+			dev_err(chan->device->dev, "Can't get DMA desc.\n");
+			spin_unlock_irqrestore(&pxp_chan->lock, flags);
+			return NULL;
+		}
+
+		phys_addr = sg_dma_address(sg);
+
+		if (!first) {
+			first = desc;
+
+			desc->layer_param.s0_param.paddr = phys_addr;
+		} else {
+			list_add_tail(&desc->list, &first->tx_list);
+			prev->next = desc;
+			desc->next = NULL;
+
+			if (i == 1)
+				desc->layer_param.out_param.paddr = phys_addr;
+			else
+				desc->layer_param.ol_param.paddr = phys_addr;
+		}
+
+		prev = desc;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp->pxp_conf_state.layer_nr = sg_len;
+	first->txd.flags = tx_flags;
+	first->len = sg_len;
+	pr_debug("%s:%d first %p, first->len %d, flags %08x\n",
+		 __func__, __LINE__, first, first->len, first->txd.flags);
+
+	return &first->txd;
+}
+
+static void pxp_issue_pending(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	unsigned long flags0, flags;
+
+	spin_lock_irqsave(&pxp->lock, flags0);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	if (!list_empty(&pxp_chan->queue)) {
+		pxpdma_dequeue(pxp_chan, &pxp_chan->active_list);
+		pxp_chan->status = PXP_CHANNEL_READY;
+		list_add_tail(&pxp_chan->list, &head);
+	} else {
+		spin_unlock_irqrestore(&pxp_chan->lock, flags);
+		spin_unlock_irqrestore(&pxp->lock, flags0);
+		return;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+	spin_unlock_irqrestore(&pxp->lock, flags0);
+
+	pxp_clk_enable(pxp);
+	if (!wait_event_interruptible_timeout(pxp->done, PXP_WAITCON, 2 * HZ) ||
+		signal_pending(current)) {
+		pxp_clk_disable(pxp);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	pxp->pxp_ongoing = 1;
+	spin_unlock_irqrestore(&pxp->lock, flags);
+	pxpdma_dostart_work(pxp);
+}
+
+static void __pxp_terminate_all(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	unsigned long flags;
+
+	/* pchan->queue is modified in ISR, have to spinlock */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	list_splice_init(&pxp_chan->queue, &pxp_chan->free_list);
+	list_splice_init(&pxp_chan->active_list, &pxp_chan->free_list);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+}
+
+static int pxp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			unsigned long arg)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	/* Only supports DMA_TERMINATE_ALL */
+	if (cmd != DMA_TERMINATE_ALL)
+		return -ENXIO;
+
+	mutex_lock(&pxp_chan->chan_mutex);
+	__pxp_terminate_all(chan);
+	mutex_unlock(&pxp_chan->chan_mutex);
+
+	return 0;
+}
+
+static int pxp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	int ret;
+
+	/* dmaengine.c now guarantees to only offer free channels */
+	BUG_ON(chan->client_count > 1);
+	WARN_ON(pxp_chan->status != PXP_CHANNEL_FREE);
+
+	chan->cookie = 1;
+	pxp_chan->completed = -ENXIO;
+
+	pr_debug("%s dma_chan.chan_id %d\n", __func__, chan->chan_id);
+	ret = pxp_init_channel(pxp_dma, pxp_chan);
+	if (ret < 0)
+		goto err_chan;
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	dev_dbg(&chan->dev->device, "Found channel 0x%x, irq %d\n",
+		chan->chan_id, pxp_chan->eof_irq);
+
+	return ret;
+
+err_chan:
+	return ret;
+}
+
+static void pxp_free_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	__pxp_terminate_all(chan);
+
+	pxp_chan->status = PXP_CHANNEL_FREE;
+
+	pxp_uninit_channel(pxp_dma, pxp_chan);
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+}
+
+static enum dma_status pxp_tx_status(struct dma_chan *chan,
+				     dma_cookie_t cookie,
+				     struct dma_tx_state *txstate)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	if (cookie != chan->cookie)
+		return DMA_ERROR;
+
+	if (txstate) {
+		txstate->last = pxp_chan->completed;
+		txstate->used = chan->cookie;
+		txstate->residue = 0;
+	}
+	return DMA_SUCCESS;
+}
+
+static int pxp_hw_init(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 reg_val;
+
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+
+	/* Config defaults */
+
+	/* Initialize non-channel-specific PxP parameters */
+	proc_data->drect.left = proc_data->srect.left = 0;
+	proc_data->drect.top = proc_data->srect.top = 0;
+	proc_data->drect.width = proc_data->srect.width = 0;
+	proc_data->drect.height = proc_data->srect.height = 0;
+	proc_data->scaling = 0;
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
+	/* Initialize S0 channel parameters */
+	pxp_conf->s0_param.pixel_fmt = pxp_s0_formats[0];
+	pxp_conf->s0_param.width = 0;
+	pxp_conf->s0_param.height = 0;
+	pxp_conf->s0_param.color_key = -1;
+	pxp_conf->s0_param.color_key_enable = false;
+
+	/* Initialize OL channel parameters */
+	pxp_conf->ol_param[0].combine_enable = false;
+	pxp_conf->ol_param[0].width = 0;
+	pxp_conf->ol_param[0].height = 0;
+	pxp_conf->ol_param[0].pixel_fmt = PXP_PIX_FMT_RGB565;
+	pxp_conf->ol_param[0].color_key_enable = false;
+	pxp_conf->ol_param[0].color_key = -1;
+	pxp_conf->ol_param[0].global_alpha_enable = false;
+	pxp_conf->ol_param[0].global_alpha = 0;
+	pxp_conf->ol_param[0].local_alpha_enable = false;
+
+	/* Initialize Output channel parameters */
+	pxp_conf->out_param.width = 0;
+	pxp_conf->out_param.height = 0;
+	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
+
+	proc_data->overlay_state = 0;
+
+	/* Write default h/w config */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	/*
+	 * simply program the ULC to a higher value than the LRC
+	 * to avoid any AS pixels to show up in the output buffer.
+	 */
+	__raw_writel(0xFFFFFFFF, pxp->base + HW_PXP_OUT_AS_ULC);
+	pxp_set_olparam(0, pxp);
+	pxp_set_olcolorkey(0, pxp);
+
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	/* One-time histogram configuration */
+	reg_val =
+	    BF_PXP_HIST_CTRL_PANEL_MODE(BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST_CTRL);
+
+	reg_val = BF_PXP_HIST2_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST2_PARAM_VALUE1(0x00F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST2_PARAM);
+
+	reg_val = BF_PXP_HIST4_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST4_PARAM_VALUE1(0x05) |
+	    BF_PXP_HIST4_PARAM_VALUE2(0x0A) | BF_PXP_HIST4_PARAM_VALUE3(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST4_PARAM);
+
+	reg_val = BF_PXP_HIST8_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST8_PARAM0_VALUE1(0x02) |
+	    BF_PXP_HIST8_PARAM0_VALUE2(0x04) | BF_PXP_HIST8_PARAM0_VALUE3(0x06);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM0);
+	reg_val = BF_PXP_HIST8_PARAM1_VALUE4(0x09) |
+	    BF_PXP_HIST8_PARAM1_VALUE5(0x0B) |
+	    BF_PXP_HIST8_PARAM1_VALUE6(0x0D) | BF_PXP_HIST8_PARAM1_VALUE7(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM1);
+
+	reg_val = BF_PXP_HIST16_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST16_PARAM0_VALUE1(0x01) |
+	    BF_PXP_HIST16_PARAM0_VALUE2(0x02) |
+	    BF_PXP_HIST16_PARAM0_VALUE3(0x03);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM0);
+	reg_val = BF_PXP_HIST16_PARAM1_VALUE4(0x04) |
+	    BF_PXP_HIST16_PARAM1_VALUE5(0x05) |
+	    BF_PXP_HIST16_PARAM1_VALUE6(0x06) |
+	    BF_PXP_HIST16_PARAM1_VALUE7(0x07);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM1);
+	reg_val = BF_PXP_HIST16_PARAM2_VALUE8(0x08) |
+	    BF_PXP_HIST16_PARAM2_VALUE9(0x09) |
+	    BF_PXP_HIST16_PARAM2_VALUE10(0x0A) |
+	    BF_PXP_HIST16_PARAM2_VALUE11(0x0B);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM2);
+	reg_val = BF_PXP_HIST16_PARAM3_VALUE12(0x0C) |
+	    BF_PXP_HIST16_PARAM3_VALUE13(0x0D) |
+	    BF_PXP_HIST16_PARAM3_VALUE14(0x0E) |
+	    BF_PXP_HIST16_PARAM3_VALUE15(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM3);
+
+	return 0;
+}
+
+static int pxp_dma_init(struct pxps *pxp)
+{
+	struct pxp_dma *pxp_dma = &pxp->pxp_dma;
+	struct dma_device *dma = &pxp_dma->dma;
+	int i;
+
+	dma_cap_set(DMA_SLAVE, dma->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma->cap_mask);
+
+	/* Compulsory common fields */
+	dma->dev = pxp->dev;
+	dma->device_alloc_chan_resources = pxp_alloc_chan_resources;
+	dma->device_free_chan_resources = pxp_free_chan_resources;
+	dma->device_tx_status = pxp_tx_status;
+	dma->device_issue_pending = pxp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma->device_prep_slave_sg = pxp_prep_slave_sg;
+	dma->device_control = pxp_control;
+
+	/* Initialize PxP Channels */
+	INIT_LIST_HEAD(&dma->channels);
+	for (i = 0; i < NR_PXP_VIRT_CHANNEL; i++) {
+		struct pxp_channel *pxp_chan = pxp->channel + i;
+		struct dma_chan *dma_chan = &pxp_chan->dma_chan;
+
+		spin_lock_init(&pxp_chan->lock);
+		mutex_init(&pxp_chan->chan_mutex);
+
+		/* Only one EOF IRQ for PxP, shared by all channels */
+		pxp_chan->eof_irq = pxp->irq;
+		pxp_chan->status = PXP_CHANNEL_FREE;
+		pxp_chan->completed = -ENXIO;
+		snprintf(pxp_chan->eof_name, sizeof(pxp_chan->eof_name),
+			 "PXP EOF %d", i);
+
+		dma_chan->device = &pxp_dma->dma;
+		dma_chan->cookie = 1;
+		dma_chan->chan_id = i;
+		list_add_tail(&dma_chan->device_node, &dma->channels);
+	}
+
+	return dma_async_device_register(&pxp_dma->dma);
+}
+
+static ssize_t clk_off_timeout_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", timeout_in_ms);
+}
+
+static ssize_t clk_off_timeout_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int val;
+	if (sscanf(buf, "%d", &val) > 0) {
+		timeout_in_ms = val;
+		return count;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(clk_off_timeout, 0644, clk_off_timeout_show,
+		   clk_off_timeout_store);
+
+static int pxp_probe(struct platform_device *pdev)
+{
+	struct pxps *pxp;
+	struct resource *res;
+	int irq;
+	int err = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || irq < 0) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pxp = kzalloc(sizeof(*pxp), GFP_KERNEL);
+	if (!pxp) {
+		dev_err(&pdev->dev, "failed to allocate control object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	pxp->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, pxp);
+	pxp->irq = irq;
+
+	pxp->pxp_ongoing = 0;
+	pxp->lut_state = 0;
+
+	spin_lock_init(&pxp->lock);
+	mutex_init(&pxp->clk_mutex);
+
+	if (!request_mem_region(res->start, resource_size(res), "pxp-mem")) {
+		err = -EBUSY;
+		goto freepxp;
+	}
+
+	pxp->base = ioremap(res->start, SZ_4K);
+	pxp->pdev = pdev;
+
+	pxp->clk = clk_get(NULL, "pxp_axi");
+	clk_enable(pxp->clk);
+
+	err = pxp_hw_init(pxp);
+	if (err) {
+		dev_err(&pdev->dev, "failed to initialize hardware\n");
+		goto release;
+	}
+	clk_disable(pxp->clk);
+
+	err = request_irq(pxp->irq, pxp_irq, 0, "pxp-irq", pxp);
+	if (err)
+		goto release;
+	/* Initialize DMA engine */
+	err = pxp_dma_init(pxp);
+	if (err < 0)
+		goto err_dma_init;
+
+	if (device_create_file(&pdev->dev, &dev_attr_clk_off_timeout)) {
+		dev_err(&pdev->dev,
+			"Unable to create file from clk_off_timeout\n");
+		goto err_dma_init;
+	}
+	dump_pxp_reg(pxp);
+
+	INIT_WORK(&pxp->work, clkoff_callback);
+	init_waitqueue_head(&pxp->done);
+	init_timer(&pxp->clk_timer);
+	pxp->clk_timer.function = pxp_clkoff_timer;
+	pxp->clk_timer.data = (unsigned long)pxp;
+exit:
+	return err;
+err_dma_init:
+	free_irq(pxp->irq, pxp);
+release:
+	release_mem_region(res->start, resource_size(res));
+freepxp:
+	kfree(pxp);
+	dev_err(&pdev->dev, "Exiting (unsuccessfully) pxp_probe function\n");
+	return err;
+}
+
+static int __devexit pxp_remove(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&pxp->work);
+	del_timer_sync(&pxp->clk_timer);
+	free_irq(pxp->irq, pxp);
+	clk_disable(pxp->clk);
+	clk_put(pxp->clk);
+	iounmap(pxp->base);
+	device_remove_file(&pdev->dev, &dev_attr_clk_off_timeout);
+
+	kfree(pxp);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	__raw_writel(BM_PXP_CTRL_SFTRST, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+
+static int pxp_resume(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+#else
+#define	pxp_suspend	NULL
+#define	pxp_resume	NULL
+#endif
+
+static struct platform_driver pxp_driver = {
+	.driver = {
+		   .name = "imx-pxp",
+		   },
+	.probe = pxp_probe,
+	.remove = __exit_p(pxp_remove),
+	.suspend = pxp_suspend,
+	.resume = pxp_resume,
+};
+
+static int __init pxp_init(void)
+{
+	return platform_driver_register(&pxp_driver);
+}
+
+subsys_initcall(pxp_init);
+
+static void __exit pxp_exit(void)
+{
+	platform_driver_unregister(&pxp_driver);
+}
+
+module_exit(pxp_exit);
+
+MODULE_DESCRIPTION("i.MX PxP driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/regs-pxp.h b/drivers/dma/pxp/regs-pxp.h
new file mode 100644
index 0000000..28c6e3a
--- /dev/null
+++ b/drivers/dma/pxp/regs-pxp.h
@@ -0,0 +1,949 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.6
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+#define BM_PXP_CTRL_RSVD 0x20000000
+#define BM_PXP_CTRL_EN_REPEAT 0x10000000
+#define BP_PXP_CTRL_INTERLACED_OUTPUT      26
+#define BM_PXP_CTRL_INTERLACED_OUTPUT 0x0C000000
+#define BF_PXP_CTRL_INTERLACED_OUTPUT(v)  \
+	(((v) << 26) & BM_PXP_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_CTRL_INTERLACED_INPUT      24
+#define BM_PXP_CTRL_INTERLACED_INPUT 0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+	(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0      0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1      0x3
+#define BM_PXP_CTRL_BLOCK_SIZE 0x00800000
+#define BV_PXP_CTRL_BLOCK_SIZE__8X8   0x0
+#define BV_PXP_CTRL_BLOCK_SIZE__16X16 0x1
+#define BM_PXP_CTRL_ALPHA_OUTPUT 0x00400000
+#define BM_PXP_CTRL_IN_PLACE 0x00200000
+#define BM_PXP_CTRL_DELTA 0x00100000
+#define BM_PXP_CTRL_CROP 0x00080000
+#define BM_PXP_CTRL_SCALE 0x00040000
+#define BM_PXP_CTRL_UPSAMPLE 0x00020000
+#define BM_PXP_CTRL_SUBSAMPLE 0x00010000
+#define BP_PXP_CTRL_S0_FORMAT      12
+#define BM_PXP_CTRL_S0_FORMAT 0x0000F000
+#define BF_PXP_CTRL_S0_FORMAT(v)  \
+	(((v) << 12) & BM_PXP_CTRL_S0_FORMAT)
+#define BV_PXP_CTRL_S0_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_S0_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_S0_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_S0_FORMAT__YUV422    0x8
+#define BV_PXP_CTRL_S0_FORMAT__YUV420    0x9
+#define BV_PXP_CTRL_S0_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_S0_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_VFLIP 0x00000800
+#define BM_PXP_CTRL_HFLIP 0x00000400
+#define BP_PXP_CTRL_ROTATE      8
+#define BM_PXP_CTRL_ROTATE 0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+	(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_OUTBUF_FORMAT      4
+#define BM_PXP_CTRL_OUTBUF_FORMAT 0x000000F0
+#define BF_PXP_CTRL_OUTBUF_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_CTRL_OUTBUF_FORMAT)
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB8888  0x0
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888P   0x2
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB1555  0x3
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV444    0x7
+#define BV_PXP_CTRL_OUTBUF_FORMAT__MONOC8    0x8
+#define BV_PXP_CTRL_OUTBUF_FORMAT__MONOC4    0x9
+#define BV_PXP_CTRL_OUTBUF_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_OUTBUF_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE 0x00000008
+#define BM_PXP_CTRL_NEXT_IRQ_ENABLE 0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX      24
+#define BM_PXP_STAT_BLOCKX 0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+	(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY      16
+#define BM_PXP_STAT_BLOCKY 0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+	(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2      8
+#define BM_PXP_STAT_RSVD2 0x0000FF00
+#define BF_PXP_STAT_RSVD2(v)  \
+	(((v) << 8) & BM_PXP_STAT_RSVD2)
+#define BP_PXP_STAT_AXI_ERROR_ID      4
+#define BM_PXP_STAT_AXI_ERROR_ID 0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+	(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_NEXT_IRQ 0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR 0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR 0x00000002
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define HW_PXP_OUTBUF	(0x00000020)
+
+#define BP_PXP_OUTBUF_ADDR      0
+#define BM_PXP_OUTBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_OUTBUF_ADDR(v)   (v)
+
+#define HW_PXP_OUTBUF2	(0x00000030)
+
+#define BP_PXP_OUTBUF2_ADDR      0
+#define BM_PXP_OUTBUF2_ADDR 0xFFFFFFFF
+#define BF_PXP_OUTBUF2_ADDR(v)   (v)
+
+#define HW_PXP_OUTSIZE	(0x00000040)
+
+#define BP_PXP_OUTSIZE_ALPHA      24
+#define BM_PXP_OUTSIZE_ALPHA 0xFF000000
+#define BF_PXP_OUTSIZE_ALPHA(v) \
+	(((v) << 24) & BM_PXP_OUTSIZE_ALPHA)
+#define BP_PXP_OUTSIZE_WIDTH      12
+#define BM_PXP_OUTSIZE_WIDTH 0x00FFF000
+#define BF_PXP_OUTSIZE_WIDTH(v)  \
+	(((v) << 12) & BM_PXP_OUTSIZE_WIDTH)
+#define BP_PXP_OUTSIZE_HEIGHT      0
+#define BM_PXP_OUTSIZE_HEIGHT 0x00000FFF
+#define BF_PXP_OUTSIZE_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_OUTSIZE_HEIGHT)
+
+#define HW_PXP_S0BUF	(0x00000050)
+
+#define BP_PXP_S0BUF_ADDR      0
+#define BM_PXP_S0BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0BUF_ADDR(v)   (v)
+
+#define HW_PXP_S0UBUF	(0x00000060)
+
+#define BP_PXP_S0UBUF_ADDR      0
+#define BM_PXP_S0UBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0UBUF_ADDR(v)   (v)
+
+#define HW_PXP_S0VBUF	(0x00000070)
+
+#define BP_PXP_S0VBUF_ADDR      0
+#define BM_PXP_S0VBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0VBUF_ADDR(v)   (v)
+
+#define HW_PXP_S0PARAM	(0x00000080)
+
+#define BP_PXP_S0PARAM_XBASE      24
+#define BM_PXP_S0PARAM_XBASE 0xFF000000
+#define BF_PXP_S0PARAM_XBASE(v) \
+	(((v) << 24) & BM_PXP_S0PARAM_XBASE)
+#define BP_PXP_S0PARAM_YBASE      16
+#define BM_PXP_S0PARAM_YBASE 0x00FF0000
+#define BF_PXP_S0PARAM_YBASE(v)  \
+	(((v) << 16) & BM_PXP_S0PARAM_YBASE)
+#define BP_PXP_S0PARAM_WIDTH      8
+#define BM_PXP_S0PARAM_WIDTH 0x0000FF00
+#define BF_PXP_S0PARAM_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_S0PARAM_WIDTH)
+#define BP_PXP_S0PARAM_HEIGHT      0
+#define BM_PXP_S0PARAM_HEIGHT 0x000000FF
+#define BF_PXP_S0PARAM_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_S0PARAM_HEIGHT)
+
+#define HW_PXP_S0BACKGROUND	(0x00000090)
+
+#define BP_PXP_S0BACKGROUND_COLOR      0
+#define BM_PXP_S0BACKGROUND_COLOR 0xFFFFFFFF
+#define BF_PXP_S0BACKGROUND_COLOR(v)   (v)
+
+#define HW_PXP_S0CROP	(0x000000a0)
+
+#define BP_PXP_S0CROP_XBASE      24
+#define BM_PXP_S0CROP_XBASE 0xFF000000
+#define BF_PXP_S0CROP_XBASE(v) \
+	(((v) << 24) & BM_PXP_S0CROP_XBASE)
+#define BP_PXP_S0CROP_YBASE      16
+#define BM_PXP_S0CROP_YBASE 0x00FF0000
+#define BF_PXP_S0CROP_YBASE(v)  \
+	(((v) << 16) & BM_PXP_S0CROP_YBASE)
+#define BP_PXP_S0CROP_WIDTH      8
+#define BM_PXP_S0CROP_WIDTH 0x0000FF00
+#define BF_PXP_S0CROP_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_S0CROP_WIDTH)
+#define BP_PXP_S0CROP_HEIGHT      0
+#define BM_PXP_S0CROP_HEIGHT 0x000000FF
+#define BF_PXP_S0CROP_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_S0CROP_HEIGHT)
+
+#define HW_PXP_S0SCALE	(0x000000b0)
+
+#define BM_PXP_S0SCALE_RSVD2 0x80000000
+#define BP_PXP_S0SCALE_YSCALE      16
+#define BM_PXP_S0SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_S0SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_S0SCALE_YSCALE)
+#define BM_PXP_S0SCALE_RSVD1 0x00008000
+#define BP_PXP_S0SCALE_XSCALE      0
+#define BM_PXP_S0SCALE_XSCALE 0x00007FFF
+#define BF_PXP_S0SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_S0SCALE_XSCALE)
+
+#define HW_PXP_S0OFFSET	(0x000000c0)
+
+#define BP_PXP_S0OFFSET_RSVD2      28
+#define BM_PXP_S0OFFSET_RSVD2 0xF0000000
+#define BF_PXP_S0OFFSET_RSVD2(v) \
+	(((v) << 28) & BM_PXP_S0OFFSET_RSVD2)
+#define BP_PXP_S0OFFSET_YOFFSET      16
+#define BM_PXP_S0OFFSET_YOFFSET 0x0FFF0000
+#define BF_PXP_S0OFFSET_YOFFSET(v)  \
+	(((v) << 16) & BM_PXP_S0OFFSET_YOFFSET)
+#define BP_PXP_S0OFFSET_RSVD1      12
+#define BM_PXP_S0OFFSET_RSVD1 0x0000F000
+#define BF_PXP_S0OFFSET_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_S0OFFSET_RSVD1)
+#define BP_PXP_S0OFFSET_XOFFSET      0
+#define BM_PXP_S0OFFSET_XOFFSET 0x00000FFF
+#define BF_PXP_S0OFFSET_XOFFSET(v)  \
+	(((v) << 0) & BM_PXP_S0OFFSET_XOFFSET)
+
+#define HW_PXP_CSCCOEF0	(0x000000d0)
+
+#define BM_PXP_CSCCOEF0_YCBCR_MODE 0x80000000
+#define BM_PXP_CSCCOEF0_BYPASS 0x40000000
+#define BM_PXP_CSCCOEF0_RSVD1 0x20000000
+#define BP_PXP_CSCCOEF0_C0      18
+#define BM_PXP_CSCCOEF0_C0 0x1FFC0000
+#define BF_PXP_CSCCOEF0_C0(v)  \
+	(((v) << 18) & BM_PXP_CSCCOEF0_C0)
+#define BP_PXP_CSCCOEF0_UV_OFFSET      9
+#define BM_PXP_CSCCOEF0_UV_OFFSET 0x0003FE00
+#define BF_PXP_CSCCOEF0_UV_OFFSET(v)  \
+	(((v) << 9) & BM_PXP_CSCCOEF0_UV_OFFSET)
+#define BP_PXP_CSCCOEF0_Y_OFFSET      0
+#define BM_PXP_CSCCOEF0_Y_OFFSET 0x000001FF
+#define BF_PXP_CSCCOEF0_Y_OFFSET(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF0_Y_OFFSET)
+
+#define HW_PXP_CSCCOEF1	(0x000000e0)
+
+#define BP_PXP_CSCCOEF1_RSVD1      27
+#define BM_PXP_CSCCOEF1_RSVD1 0xF8000000
+#define BF_PXP_CSCCOEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSCCOEF1_RSVD1)
+#define BP_PXP_CSCCOEF1_C1      16
+#define BM_PXP_CSCCOEF1_C1 0x07FF0000
+#define BF_PXP_CSCCOEF1_C1(v)  \
+	(((v) << 16) & BM_PXP_CSCCOEF1_C1)
+#define BP_PXP_CSCCOEF1_RSVD0      11
+#define BM_PXP_CSCCOEF1_RSVD0 0x0000F800
+#define BF_PXP_CSCCOEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSCCOEF1_RSVD0)
+#define BP_PXP_CSCCOEF1_C4      0
+#define BM_PXP_CSCCOEF1_C4 0x000007FF
+#define BF_PXP_CSCCOEF1_C4(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF1_C4)
+
+#define HW_PXP_CSCCOEF2	(0x000000f0)
+
+#define BP_PXP_CSCCOEF2_RSVD1      27
+#define BM_PXP_CSCCOEF2_RSVD1 0xF8000000
+#define BF_PXP_CSCCOEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSCCOEF2_RSVD1)
+#define BP_PXP_CSCCOEF2_C2      16
+#define BM_PXP_CSCCOEF2_C2 0x07FF0000
+#define BF_PXP_CSCCOEF2_C2(v)  \
+	(((v) << 16) & BM_PXP_CSCCOEF2_C2)
+#define BP_PXP_CSCCOEF2_RSVD0      11
+#define BM_PXP_CSCCOEF2_RSVD0 0x0000F800
+#define BF_PXP_CSCCOEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSCCOEF2_RSVD0)
+#define BP_PXP_CSCCOEF2_C3      0
+#define BM_PXP_CSCCOEF2_C3 0x000007FF
+#define BF_PXP_CSCCOEF2_C3(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF2_C3)
+
+#define HW_PXP_NEXT	(0x00000100)
+#define HW_PXP_NEXT_SET	(0x00000104)
+#define HW_PXP_NEXT_CLR	(0x00000108)
+#define HW_PXP_NEXT_TOG	(0x0000010c)
+
+#define BP_PXP_NEXT_POINTER      2
+#define BM_PXP_NEXT_POINTER 0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+	(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD 0x00000002
+#define BM_PXP_NEXT_ENABLED 0x00000001
+
+#define HW_PXP_S0COLORKEYLOW	(0x00000180)
+
+#define BP_PXP_S0COLORKEYLOW_RSVD1      24
+#define BM_PXP_S0COLORKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_S0COLORKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_S0COLORKEYLOW_RSVD1)
+#define BP_PXP_S0COLORKEYLOW_PIXEL      0
+#define BM_PXP_S0COLORKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_S0COLORKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_S0COLORKEYLOW_PIXEL)
+
+#define HW_PXP_S0COLORKEYHIGH	(0x00000190)
+
+#define BP_PXP_S0COLORKEYHIGH_RSVD1      24
+#define BM_PXP_S0COLORKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_S0COLORKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_S0COLORKEYHIGH_RSVD1)
+#define BP_PXP_S0COLORKEYHIGH_PIXEL      0
+#define BM_PXP_S0COLORKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_S0COLORKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_S0COLORKEYHIGH_PIXEL)
+
+#define HW_PXP_OLCOLORKEYLOW	(0x000001a0)
+
+#define BP_PXP_OLCOLORKEYLOW_RSVD1      24
+#define BM_PXP_OLCOLORKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_OLCOLORKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_OLCOLORKEYLOW_RSVD1)
+#define BP_PXP_OLCOLORKEYLOW_PIXEL      0
+#define BM_PXP_OLCOLORKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_OLCOLORKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_OLCOLORKEYLOW_PIXEL)
+
+#define HW_PXP_OLCOLORKEYHIGH	(0x000001b0)
+
+#define BP_PXP_OLCOLORKEYHIGH_RSVD1      24
+#define BM_PXP_OLCOLORKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_OLCOLORKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_OLCOLORKEYHIGH_RSVD1)
+#define BP_PXP_OLCOLORKEYHIGH_PIXEL      0
+#define BM_PXP_OLCOLORKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_OLCOLORKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_OLCOLORKEYHIGH_PIXEL)
+
+#define HW_PXP_DEBUGCTRL	(0x000001d0)
+
+#define BP_PXP_DEBUGCTRL_RSVD      8
+#define BM_PXP_DEBUGCTRL_RSVD 0xFFFFFF00
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+	(((v) << 8) & BM_PXP_DEBUGCTRL_RSVD)
+#define BP_PXP_DEBUGCTRL_SELECT      0
+#define BM_PXP_DEBUGCTRL_SELECT 0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+	(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__S0REGS   0x2
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAX    0x3
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAY    0x4
+#define BV_PXP_DEBUGCTRL_SELECT__PXBUF    0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION 0x6
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF0  0x7
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF1  0x8
+
+#define HW_PXP_DEBUG	(0x000001e0)
+
+#define BP_PXP_DEBUG_DATA      0
+#define BM_PXP_DEBUG_DATA 0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)   (v)
+
+#define HW_PXP_VERSION	(0x000001f0)
+
+#define BP_PXP_VERSION_MAJOR      24
+#define BM_PXP_VERSION_MAJOR 0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR      16
+#define BM_PXP_VERSION_MINOR 0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP      0
+#define BM_PXP_VERSION_STEP 0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)  \
+	(((v) << 0) & BM_PXP_VERSION_STEP)
+
+/*
+ *  multi-register-define name HW_PXP_OLn
+ *              base 0x00000200
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLn(n)	(0x00000200 + (n) * 0x40)
+#define BP_PXP_OLn_ADDR      0
+#define BM_PXP_OLn_ADDR 0xFFFFFFFF
+#define BF_PXP_OLn_ADDR(v)   (v)
+
+/*
+ *  multi-register-define name HW_PXP_OLnSIZE
+ *              base 0x00000210
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnSIZE(n)	(0x00000210 + (n) * 0x40)
+#define BP_PXP_OLnSIZE_XBASE      24
+#define BM_PXP_OLnSIZE_XBASE 0xFF000000
+#define BF_PXP_OLnSIZE_XBASE(v) \
+	(((v) << 24) & BM_PXP_OLnSIZE_XBASE)
+#define BP_PXP_OLnSIZE_YBASE      16
+#define BM_PXP_OLnSIZE_YBASE 0x00FF0000
+#define BF_PXP_OLnSIZE_YBASE(v)  \
+	(((v) << 16) & BM_PXP_OLnSIZE_YBASE)
+#define BP_PXP_OLnSIZE_WIDTH      8
+#define BM_PXP_OLnSIZE_WIDTH 0x0000FF00
+#define BF_PXP_OLnSIZE_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_OLnSIZE_WIDTH)
+#define BP_PXP_OLnSIZE_HEIGHT      0
+#define BM_PXP_OLnSIZE_HEIGHT 0x000000FF
+#define BF_PXP_OLnSIZE_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_OLnSIZE_HEIGHT)
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM
+ *              base 0x00000220
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM(n)	(0x00000220 + (n) * 0x40)
+#define BP_PXP_OLnPARAM_RSVD1      20
+#define BM_PXP_OLnPARAM_RSVD1 0xFFF00000
+#define BF_PXP_OLnPARAM_RSVD1(v) \
+	(((v) << 20) & BM_PXP_OLnPARAM_RSVD1)
+#define BP_PXP_OLnPARAM_ROP      16
+#define BM_PXP_OLnPARAM_ROP 0x000F0000
+#define BF_PXP_OLnPARAM_ROP(v)  \
+	(((v) << 16) & BM_PXP_OLnPARAM_ROP)
+#define BV_PXP_OLnPARAM_ROP__MASKOL     0x0
+#define BV_PXP_OLnPARAM_ROP__MASKNOTOL  0x1
+#define BV_PXP_OLnPARAM_ROP__MASKOLNOT  0x2
+#define BV_PXP_OLnPARAM_ROP__MERGEOL    0x3
+#define BV_PXP_OLnPARAM_ROP__MERGENOTOL 0x4
+#define BV_PXP_OLnPARAM_ROP__MERGEOLNOT 0x5
+#define BV_PXP_OLnPARAM_ROP__NOTCOPYOL  0x6
+#define BV_PXP_OLnPARAM_ROP__NOT        0x7
+#define BV_PXP_OLnPARAM_ROP__NOTMASKOL  0x8
+#define BV_PXP_OLnPARAM_ROP__NOTMERGEOL 0x9
+#define BV_PXP_OLnPARAM_ROP__XOROL      0xA
+#define BV_PXP_OLnPARAM_ROP__NOTXOROL   0xB
+#define BP_PXP_OLnPARAM_ALPHA      8
+#define BM_PXP_OLnPARAM_ALPHA 0x0000FF00
+#define BF_PXP_OLnPARAM_ALPHA(v)  \
+	(((v) << 8) & BM_PXP_OLnPARAM_ALPHA)
+#define BP_PXP_OLnPARAM_FORMAT      4
+#define BM_PXP_OLnPARAM_FORMAT 0x000000F0
+#define BF_PXP_OLnPARAM_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_OLnPARAM_FORMAT)
+#define BV_PXP_OLnPARAM_FORMAT__ARGB8888 0x0
+#define BV_PXP_OLnPARAM_FORMAT__RGB888   0x1
+#define BV_PXP_OLnPARAM_FORMAT__ARGB1555 0x3
+#define BV_PXP_OLnPARAM_FORMAT__RGB565   0x4
+#define BV_PXP_OLnPARAM_FORMAT__RGB555   0x5
+#define BM_PXP_OLnPARAM_ENABLE_COLORKEY 0x00000008
+#define BP_PXP_OLnPARAM_ALPHA_CNTL      1
+#define BM_PXP_OLnPARAM_ALPHA_CNTL 0x00000006
+#define BF_PXP_OLnPARAM_ALPHA_CNTL(v)  \
+	(((v) << 1) & BM_PXP_OLnPARAM_ALPHA_CNTL)
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Embedded 0x0
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Override 0x1
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Multiply 0x2
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__ROPs     0x3
+#define BM_PXP_OLnPARAM_ENABLE 0x00000001
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM2
+ *              base 0x00000230
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM2(n)	(0x00000230 + (n) * 0x40)
+#define BP_PXP_OLnPARAM2_RSVD      0
+#define BM_PXP_OLnPARAM2_RSVD 0xFFFFFFFF
+#define BF_PXP_OLnPARAM2_RSVD(v)   (v)
+
+#define HW_PXP_CSC2CTRL	(0x00000400)
+
+#define BP_PXP_CSC2CTRL_RSVD      3
+#define BM_PXP_CSC2CTRL_RSVD 0xFFFFFFF8
+#define BF_PXP_CSC2CTRL_RSVD(v) \
+	(((v) << 3) & BM_PXP_CSC2CTRL_RSVD)
+#define BP_PXP_CSC2CTRL_CSC_MODE      1
+#define BM_PXP_CSC2CTRL_CSC_MODE 0x00000006
+#define BF_PXP_CSC2CTRL_CSC_MODE(v)  \
+	(((v) << 1) & BM_PXP_CSC2CTRL_CSC_MODE)
+#define BV_PXP_CSC2CTRL_CSC_MODE__YUV2RGB   0x0
+#define BV_PXP_CSC2CTRL_CSC_MODE__YCbCr2RGB 0x1
+#define BV_PXP_CSC2CTRL_CSC_MODE__RGB2YUV   0x2
+#define BV_PXP_CSC2CTRL_CSC_MODE__RGB2YCbCr 0x3
+#define BM_PXP_CSC2CTRL_BYPASS 0x00000001
+
+#define HW_PXP_CSC2COEF0	(0x00000410)
+
+#define BP_PXP_CSC2COEF0_RSVD1      27
+#define BM_PXP_CSC2COEF0_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF0_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF0_RSVD1)
+#define BP_PXP_CSC2COEF0_A2      16
+#define BM_PXP_CSC2COEF0_A2 0x07FF0000
+#define BF_PXP_CSC2COEF0_A2(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF0_A2)
+#define BP_PXP_CSC2COEF0_RSVD0      11
+#define BM_PXP_CSC2COEF0_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF0_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF0_RSVD0)
+#define BP_PXP_CSC2COEF0_A1      0
+#define BM_PXP_CSC2COEF0_A1 0x000007FF
+#define BF_PXP_CSC2COEF0_A1(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF0_A1)
+
+#define HW_PXP_CSC2COEF1	(0x00000420)
+
+#define BP_PXP_CSC2COEF1_RSVD1      27
+#define BM_PXP_CSC2COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF1_RSVD1)
+#define BP_PXP_CSC2COEF1_B1      16
+#define BM_PXP_CSC2COEF1_B1 0x07FF0000
+#define BF_PXP_CSC2COEF1_B1(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF1_B1)
+#define BP_PXP_CSC2COEF1_RSVD0      11
+#define BM_PXP_CSC2COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF1_RSVD0)
+#define BP_PXP_CSC2COEF1_A3      0
+#define BM_PXP_CSC2COEF1_A3 0x000007FF
+#define BF_PXP_CSC2COEF1_A3(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF1_A3)
+
+#define HW_PXP_CSC2COEF2	(0x00000430)
+
+#define BP_PXP_CSC2COEF2_RSVD1      27
+#define BM_PXP_CSC2COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF2_RSVD1)
+#define BP_PXP_CSC2COEF2_B3      16
+#define BM_PXP_CSC2COEF2_B3 0x07FF0000
+#define BF_PXP_CSC2COEF2_B3(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF2_B3)
+#define BP_PXP_CSC2COEF2_RSVD0      11
+#define BM_PXP_CSC2COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF2_RSVD0)
+#define BP_PXP_CSC2COEF2_B2      0
+#define BM_PXP_CSC2COEF2_B2 0x000007FF
+#define BF_PXP_CSC2COEF2_B2(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF2_B2)
+
+#define HW_PXP_CSC2COEF3	(0x00000440)
+
+#define BP_PXP_CSC2COEF3_RSVD1      27
+#define BM_PXP_CSC2COEF3_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF3_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF3_RSVD1)
+#define BP_PXP_CSC2COEF3_C2      16
+#define BM_PXP_CSC2COEF3_C2 0x07FF0000
+#define BF_PXP_CSC2COEF3_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF3_C2)
+#define BP_PXP_CSC2COEF3_RSVD0      11
+#define BM_PXP_CSC2COEF3_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF3_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF3_RSVD0)
+#define BP_PXP_CSC2COEF3_C1      0
+#define BM_PXP_CSC2COEF3_C1 0x000007FF
+#define BF_PXP_CSC2COEF3_C1(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF3_C1)
+
+#define HW_PXP_CSC2COEF4	(0x00000450)
+
+#define BP_PXP_CSC2COEF4_RSVD1      25
+#define BM_PXP_CSC2COEF4_RSVD1 0xFE000000
+#define BF_PXP_CSC2COEF4_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2COEF4_RSVD1)
+#define BP_PXP_CSC2COEF4_D1      16
+#define BM_PXP_CSC2COEF4_D1 0x01FF0000
+#define BF_PXP_CSC2COEF4_D1(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF4_D1)
+#define BP_PXP_CSC2COEF4_RSVD0      11
+#define BM_PXP_CSC2COEF4_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF4_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF4_RSVD0)
+#define BP_PXP_CSC2COEF4_C3      0
+#define BM_PXP_CSC2COEF4_C3 0x000007FF
+#define BF_PXP_CSC2COEF4_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF4_C3)
+
+#define HW_PXP_CSC2COEF5	(0x00000460)
+
+#define BP_PXP_CSC2COEF5_RSVD1      25
+#define BM_PXP_CSC2COEF5_RSVD1 0xFE000000
+#define BF_PXP_CSC2COEF5_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2COEF5_RSVD1)
+#define BP_PXP_CSC2COEF5_D3      16
+#define BM_PXP_CSC2COEF5_D3 0x01FF0000
+#define BF_PXP_CSC2COEF5_D3(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF5_D3)
+#define BP_PXP_CSC2COEF5_RSVD0      9
+#define BM_PXP_CSC2COEF5_RSVD0 0x0000FE00
+#define BF_PXP_CSC2COEF5_RSVD0(v)  \
+	(((v) << 9) & BM_PXP_CSC2COEF5_RSVD0)
+#define BP_PXP_CSC2COEF5_D2      0
+#define BM_PXP_CSC2COEF5_D2 0x000001FF
+#define BF_PXP_CSC2COEF5_D2(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF5_D2)
+
+#define HW_PXP_LUT_CTRL	(0x00000470)
+
+#define BM_PXP_LUT_CTRL_BYPASS 0x80000000
+#define BP_PXP_LUT_CTRL_RSVD      8
+#define BM_PXP_LUT_CTRL_RSVD 0x7FFFFF00
+#define BF_PXP_LUT_CTRL_RSVD(v)  \
+	(((v) << 8) & BM_PXP_LUT_CTRL_RSVD)
+#define BP_PXP_LUT_CTRL_ADDR      0
+#define BM_PXP_LUT_CTRL_ADDR 0x000000FF
+#define BF_PXP_LUT_CTRL_ADDR(v)  \
+	(((v) << 0) & BM_PXP_LUT_CTRL_ADDR)
+
+#define HW_PXP_LUT	(0x00000480)
+
+#define BP_PXP_LUT_RSVD      8
+#define BM_PXP_LUT_RSVD 0xFFFFFF00
+#define BF_PXP_LUT_RSVD(v) \
+	(((v) << 8) & BM_PXP_LUT_RSVD)
+#define BP_PXP_LUT_DATA      0
+#define BM_PXP_LUT_DATA 0x000000FF
+#define BF_PXP_LUT_DATA(v)  \
+	(((v) << 0) & BM_PXP_LUT_DATA)
+
+#define HW_PXP_HIST_CTRL	(0x00000490)
+
+#define BP_PXP_HIST_CTRL_RSVD      6
+#define BM_PXP_HIST_CTRL_RSVD 0xFFFFFFC0
+#define BF_PXP_HIST_CTRL_RSVD(v) \
+	(((v) << 6) & BM_PXP_HIST_CTRL_RSVD)
+#define BP_PXP_HIST_CTRL_PANEL_MODE      4
+#define BM_PXP_HIST_CTRL_PANEL_MODE 0x00000030
+#define BF_PXP_HIST_CTRL_PANEL_MODE(v)  \
+	(((v) << 4) & BM_PXP_HIST_CTRL_PANEL_MODE)
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY4  0x0
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY8  0x1
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16 0x2
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY32 0x3
+#define BP_PXP_HIST_CTRL_STATUS      0
+#define BM_PXP_HIST_CTRL_STATUS 0x0000000F
+#define BF_PXP_HIST_CTRL_STATUS(v)  \
+	(((v) << 0) & BM_PXP_HIST_CTRL_STATUS)
+
+#define HW_PXP_HIST2_PARAM	(0x000004a0)
+
+#define BP_PXP_HIST2_PARAM_RSVD      16
+#define BM_PXP_HIST2_PARAM_RSVD 0xFFFF0000
+#define BF_PXP_HIST2_PARAM_RSVD(v) \
+	(((v) << 16) & BM_PXP_HIST2_PARAM_RSVD)
+#define BP_PXP_HIST2_PARAM_RSVD1      13
+#define BM_PXP_HIST2_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST2_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST2_PARAM_RSVD1)
+#define BP_PXP_HIST2_PARAM_VALUE1      8
+#define BM_PXP_HIST2_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST2_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST2_PARAM_VALUE1)
+#define BP_PXP_HIST2_PARAM_RSVD0      5
+#define BM_PXP_HIST2_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST2_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST2_PARAM_RSVD0)
+#define BP_PXP_HIST2_PARAM_VALUE0      0
+#define BM_PXP_HIST2_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST2_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST2_PARAM_VALUE0)
+
+#define HW_PXP_HIST4_PARAM	(0x000004b0)
+
+#define BP_PXP_HIST4_PARAM_RSVD3      29
+#define BM_PXP_HIST4_PARAM_RSVD3 0xE0000000
+#define BF_PXP_HIST4_PARAM_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST4_PARAM_RSVD3)
+#define BP_PXP_HIST4_PARAM_VALUE3      24
+#define BM_PXP_HIST4_PARAM_VALUE3 0x1F000000
+#define BF_PXP_HIST4_PARAM_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST4_PARAM_VALUE3)
+#define BP_PXP_HIST4_PARAM_RSVD2      21
+#define BM_PXP_HIST4_PARAM_RSVD2 0x00E00000
+#define BF_PXP_HIST4_PARAM_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST4_PARAM_RSVD2)
+#define BP_PXP_HIST4_PARAM_VALUE2      16
+#define BM_PXP_HIST4_PARAM_VALUE2 0x001F0000
+#define BF_PXP_HIST4_PARAM_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST4_PARAM_VALUE2)
+#define BP_PXP_HIST4_PARAM_RSVD1      13
+#define BM_PXP_HIST4_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST4_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST4_PARAM_RSVD1)
+#define BP_PXP_HIST4_PARAM_VALUE1      8
+#define BM_PXP_HIST4_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST4_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST4_PARAM_VALUE1)
+#define BP_PXP_HIST4_PARAM_RSVD0      5
+#define BM_PXP_HIST4_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST4_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST4_PARAM_RSVD0)
+#define BP_PXP_HIST4_PARAM_VALUE0      0
+#define BM_PXP_HIST4_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST4_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST4_PARAM_VALUE0)
+
+#define HW_PXP_HIST8_PARAM0	(0x000004c0)
+
+#define BP_PXP_HIST8_PARAM0_RSVD3      29
+#define BM_PXP_HIST8_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST8_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM0_RSVD3)
+#define BP_PXP_HIST8_PARAM0_VALUE3      24
+#define BM_PXP_HIST8_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST8_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM0_VALUE3)
+#define BP_PXP_HIST8_PARAM0_RSVD2      21
+#define BM_PXP_HIST8_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST8_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM0_RSVD2)
+#define BP_PXP_HIST8_PARAM0_VALUE2      16
+#define BM_PXP_HIST8_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST8_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM0_VALUE2)
+#define BP_PXP_HIST8_PARAM0_RSVD1      13
+#define BM_PXP_HIST8_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST8_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM0_RSVD1)
+#define BP_PXP_HIST8_PARAM0_VALUE1      8
+#define BM_PXP_HIST8_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST8_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM0_VALUE1)
+#define BP_PXP_HIST8_PARAM0_RSVD0      5
+#define BM_PXP_HIST8_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST8_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM0_RSVD0)
+#define BP_PXP_HIST8_PARAM0_VALUE0      0
+#define BM_PXP_HIST8_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST8_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM0_VALUE0)
+
+#define HW_PXP_HIST8_PARAM1	(0x000004d0)
+
+#define BP_PXP_HIST8_PARAM1_RSVD7      29
+#define BM_PXP_HIST8_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST8_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM1_RSVD7)
+#define BP_PXP_HIST8_PARAM1_VALUE7      24
+#define BM_PXP_HIST8_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST8_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM1_VALUE7)
+#define BP_PXP_HIST8_PARAM1_RSVD6      21
+#define BM_PXP_HIST8_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST8_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM1_RSVD6)
+#define BP_PXP_HIST8_PARAM1_VALUE6      16
+#define BM_PXP_HIST8_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST8_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM1_VALUE6)
+#define BP_PXP_HIST8_PARAM1_RSVD5      13
+#define BM_PXP_HIST8_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST8_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM1_RSVD5)
+#define BP_PXP_HIST8_PARAM1_VALUE5      8
+#define BM_PXP_HIST8_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST8_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM1_VALUE5)
+#define BP_PXP_HIST8_PARAM1_RSVD4      5
+#define BM_PXP_HIST8_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST8_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM1_RSVD4)
+#define BP_PXP_HIST8_PARAM1_VALUE4      0
+#define BM_PXP_HIST8_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST8_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM0	(0x000004e0)
+
+#define BP_PXP_HIST16_PARAM0_RSVD3      29
+#define BM_PXP_HIST16_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST16_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM0_RSVD3)
+#define BP_PXP_HIST16_PARAM0_VALUE3      24
+#define BM_PXP_HIST16_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST16_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM0_VALUE3)
+#define BP_PXP_HIST16_PARAM0_RSVD2      21
+#define BM_PXP_HIST16_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST16_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM0_RSVD2)
+#define BP_PXP_HIST16_PARAM0_VALUE2      16
+#define BM_PXP_HIST16_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST16_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM0_VALUE2)
+#define BP_PXP_HIST16_PARAM0_RSVD1      13
+#define BM_PXP_HIST16_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST16_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM0_RSVD1)
+#define BP_PXP_HIST16_PARAM0_VALUE1      8
+#define BM_PXP_HIST16_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST16_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM0_VALUE1)
+#define BP_PXP_HIST16_PARAM0_RSVD0      5
+#define BM_PXP_HIST16_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST16_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM0_RSVD0)
+#define BP_PXP_HIST16_PARAM0_VALUE0      0
+#define BM_PXP_HIST16_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST16_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM0_VALUE0)
+
+#define HW_PXP_HIST16_PARAM1	(0x000004f0)
+
+#define BP_PXP_HIST16_PARAM1_RSVD7      29
+#define BM_PXP_HIST16_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST16_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM1_RSVD7)
+#define BP_PXP_HIST16_PARAM1_VALUE7      24
+#define BM_PXP_HIST16_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST16_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM1_VALUE7)
+#define BP_PXP_HIST16_PARAM1_RSVD6      21
+#define BM_PXP_HIST16_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST16_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM1_RSVD6)
+#define BP_PXP_HIST16_PARAM1_VALUE6      16
+#define BM_PXP_HIST16_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST16_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM1_VALUE6)
+#define BP_PXP_HIST16_PARAM1_RSVD5      13
+#define BM_PXP_HIST16_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST16_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM1_RSVD5)
+#define BP_PXP_HIST16_PARAM1_VALUE5      8
+#define BM_PXP_HIST16_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST16_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM1_VALUE5)
+#define BP_PXP_HIST16_PARAM1_RSVD4      5
+#define BM_PXP_HIST16_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST16_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM1_RSVD4)
+#define BP_PXP_HIST16_PARAM1_VALUE4      0
+#define BM_PXP_HIST16_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST16_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM2	(0x00000500)
+
+#define BP_PXP_HIST16_PARAM2_RSVD11      29
+#define BM_PXP_HIST16_PARAM2_RSVD11 0xE0000000
+#define BF_PXP_HIST16_PARAM2_RSVD11(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM2_RSVD11)
+#define BP_PXP_HIST16_PARAM2_VALUE11      24
+#define BM_PXP_HIST16_PARAM2_VALUE11 0x1F000000
+#define BF_PXP_HIST16_PARAM2_VALUE11(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM2_VALUE11)
+#define BP_PXP_HIST16_PARAM2_RSVD10      21
+#define BM_PXP_HIST16_PARAM2_RSVD10 0x00E00000
+#define BF_PXP_HIST16_PARAM2_RSVD10(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM2_RSVD10)
+#define BP_PXP_HIST16_PARAM2_VALUE10      16
+#define BM_PXP_HIST16_PARAM2_VALUE10 0x001F0000
+#define BF_PXP_HIST16_PARAM2_VALUE10(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM2_VALUE10)
+#define BP_PXP_HIST16_PARAM2_RSVD9      13
+#define BM_PXP_HIST16_PARAM2_RSVD9 0x0000E000
+#define BF_PXP_HIST16_PARAM2_RSVD9(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM2_RSVD9)
+#define BP_PXP_HIST16_PARAM2_VALUE9      8
+#define BM_PXP_HIST16_PARAM2_VALUE9 0x00001F00
+#define BF_PXP_HIST16_PARAM2_VALUE9(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM2_VALUE9)
+#define BP_PXP_HIST16_PARAM2_RSVD8      5
+#define BM_PXP_HIST16_PARAM2_RSVD8 0x000000E0
+#define BF_PXP_HIST16_PARAM2_RSVD8(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM2_RSVD8)
+#define BP_PXP_HIST16_PARAM2_VALUE8      0
+#define BM_PXP_HIST16_PARAM2_VALUE8 0x0000001F
+#define BF_PXP_HIST16_PARAM2_VALUE8(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM2_VALUE8)
+
+#define HW_PXP_HIST16_PARAM3	(0x00000510)
+
+#define BP_PXP_HIST16_PARAM3_RSVD15      29
+#define BM_PXP_HIST16_PARAM3_RSVD15 0xE0000000
+#define BF_PXP_HIST16_PARAM3_RSVD15(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM3_RSVD15)
+#define BP_PXP_HIST16_PARAM3_VALUE15      24
+#define BM_PXP_HIST16_PARAM3_VALUE15 0x1F000000
+#define BF_PXP_HIST16_PARAM3_VALUE15(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM3_VALUE15)
+#define BP_PXP_HIST16_PARAM3_RSVD14      21
+#define BM_PXP_HIST16_PARAM3_RSVD14 0x00E00000
+#define BF_PXP_HIST16_PARAM3_RSVD14(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM3_RSVD14)
+#define BP_PXP_HIST16_PARAM3_VALUE14      16
+#define BM_PXP_HIST16_PARAM3_VALUE14 0x001F0000
+#define BF_PXP_HIST16_PARAM3_VALUE14(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM3_VALUE14)
+#define BP_PXP_HIST16_PARAM3_RSVD13      13
+#define BM_PXP_HIST16_PARAM3_RSVD13 0x0000E000
+#define BF_PXP_HIST16_PARAM3_RSVD13(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM3_RSVD13)
+#define BP_PXP_HIST16_PARAM3_VALUE13      8
+#define BM_PXP_HIST16_PARAM3_VALUE13 0x00001F00
+#define BF_PXP_HIST16_PARAM3_VALUE13(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM3_VALUE13)
+#define BP_PXP_HIST16_PARAM3_RSVD12      5
+#define BM_PXP_HIST16_PARAM3_RSVD12 0x000000E0
+#define BF_PXP_HIST16_PARAM3_RSVD12(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM3_RSVD12)
+#define BP_PXP_HIST16_PARAM3_VALUE12      0
+#define BM_PXP_HIST16_PARAM3_VALUE12 0x0000001F
+#define BF_PXP_HIST16_PARAM3_VALUE12(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM3_VALUE12)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/drivers/dma/pxp/regs-pxp_v2.h b/drivers/dma/pxp/regs-pxp_v2.h
new file mode 100644
index 0000000..5ac56ce
--- /dev/null
+++ b/drivers/dma/pxp/regs-pxp_v2.h
@@ -0,0 +1,1152 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.29
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+#define BM_PXP_CTRL_RSVD4 0x20000000
+#define BM_PXP_CTRL_EN_REPEAT 0x10000000
+#define BP_PXP_CTRL_RSVD3      26
+#define BM_PXP_CTRL_RSVD3 0x0C000000
+#define BF_PXP_CTRL_RSVD3(v)  \
+	(((v) << 26) & BM_PXP_CTRL_RSVD3)
+#define BP_PXP_CTRL_INTERLACED_INPUT	  24
+#define BM_PXP_CTRL_INTERLACED_INPUT 0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+	(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0	  0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1	  0x3
+#define BM_PXP_CTRL_BLOCK_SIZE 0x00800000
+#define BV_PXP_CTRL_BLOCK_SIZE__8X8   0x0
+#define BV_PXP_CTRL_BLOCK_SIZE__16X16 0x1
+#define BM_PXP_CTRL_ROT_POS 0x00400000
+#define BM_PXP_CTRL_IN_PLACE 0x00200000
+#define BP_PXP_CTRL_RSVD1      12
+#define BM_PXP_CTRL_RSVD1 0x001FF000
+#define BF_PXP_CTRL_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_CTRL_RSVD1)
+#define BM_PXP_CTRL_VFLIP 0x00000800
+#define BM_PXP_CTRL_HFLIP 0x00000400
+#define BP_PXP_CTRL_ROTATE	8
+#define BM_PXP_CTRL_ROTATE 0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+	(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_RSVD0      5
+#define BM_PXP_CTRL_RSVD0 0x000000E0
+#define BF_PXP_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_CTRL_RSVD0)
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE 0x00000010
+#define BM_PXP_CTRL_LUT_DMA_IRQ_ENABLE 0x00000008
+#define BM_PXP_CTRL_NEXT_IRQ_ENABLE 0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX	24
+#define BM_PXP_STAT_BLOCKX 0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+	(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY	16
+#define BM_PXP_STAT_BLOCKY 0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+	(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2      9
+#define BM_PXP_STAT_RSVD2 0x0000FE00
+#define BF_PXP_STAT_RSVD2(v)  \
+	(((v) << 9) & BM_PXP_STAT_RSVD2)
+#define BM_PXP_STAT_LUT_DMA_LOAD_DONE_IRQ 0x00000100
+#define BP_PXP_STAT_AXI_ERROR_ID      4
+#define BM_PXP_STAT_AXI_ERROR_ID 0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+	(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_NEXT_IRQ 0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR 0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR 0x00000002
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define HW_PXP_OUT_CTRL	(0x00000020)
+#define HW_PXP_OUT_CTRL_SET	(0x00000024)
+#define HW_PXP_OUT_CTRL_CLR	(0x00000028)
+#define HW_PXP_OUT_CTRL_TOG	(0x0000002c)
+
+#define BP_PXP_OUT_CTRL_ALPHA	   24
+#define BM_PXP_OUT_CTRL_ALPHA 0xFF000000
+#define BF_PXP_OUT_CTRL_ALPHA(v) \
+	(((v) << 24) & BM_PXP_OUT_CTRL_ALPHA)
+#define BM_PXP_OUT_CTRL_ALPHA_OUTPUT 0x00800000
+#define BP_PXP_OUT_CTRL_RSVD1	   10
+#define BM_PXP_OUT_CTRL_RSVD1 0x007FFC00
+#define BF_PXP_OUT_CTRL_RSVD1(v)  \
+	(((v) << 10) & BM_PXP_OUT_CTRL_RSVD1)
+#define BP_PXP_OUT_CTRL_INTERLACED_OUTPUT      8
+#define BM_PXP_OUT_CTRL_INTERLACED_OUTPUT 0x00000300
+#define BF_PXP_OUT_CTRL_INTERLACED_OUTPUT(v)  \
+	(((v) << 8) & BM_PXP_OUT_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_OUT_CTRL_RSVD0	   5
+#define BM_PXP_OUT_CTRL_RSVD0 0x000000E0
+#define BF_PXP_OUT_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_OUT_CTRL_RSVD0)
+#define BP_PXP_OUT_CTRL_FORMAT	    0
+#define BM_PXP_OUT_CTRL_FORMAT 0x0000001F
+#define BF_PXP_OUT_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_OUT_CTRL_FORMAT)
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB8888  0x0
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888	  0x4
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888P   0x5
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB1555  0x8
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB4444  0x9
+#define BV_PXP_OUT_CTRL_FORMAT__RGB555	  0xC
+#define BV_PXP_OUT_CTRL_FORMAT__RGB444	  0xD
+#define BV_PXP_OUT_CTRL_FORMAT__RGB565	  0xE
+#define BV_PXP_OUT_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_OUT_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_OUT_CTRL_FORMAT__VYUY1P422 0x13
+#define BV_PXP_OUT_CTRL_FORMAT__Y8	  0x14
+#define BV_PXP_OUT_CTRL_FORMAT__Y4	  0x15
+#define BV_PXP_OUT_CTRL_FORMAT__YUV2P422  0x18
+#define BV_PXP_OUT_CTRL_FORMAT__YUV2P420  0x19
+#define BV_PXP_OUT_CTRL_FORMAT__YVU2P422  0x1A
+#define BV_PXP_OUT_CTRL_FORMAT__YVU2P420  0x1B
+
+#define HW_PXP_OUT_BUF	(0x00000030)
+
+#define BP_PXP_OUT_BUF_ADDR	 0
+#define BM_PXP_OUT_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_OUT_BUF_ADDR(v)	 (v)
+
+#define HW_PXP_OUT_BUF2	(0x00000040)
+
+#define BP_PXP_OUT_BUF2_ADDR	  0
+#define BM_PXP_OUT_BUF2_ADDR 0xFFFFFFFF
+#define BF_PXP_OUT_BUF2_ADDR(v)   (v)
+
+#define HW_PXP_OUT_PITCH	(0x00000050)
+
+#define BP_PXP_OUT_PITCH_RSVD	   16
+#define BM_PXP_OUT_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_OUT_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_OUT_PITCH_RSVD)
+#define BP_PXP_OUT_PITCH_PITCH	    0
+#define BM_PXP_OUT_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_OUT_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_OUT_PITCH_PITCH)
+
+#define HW_PXP_OUT_LRC	(0x00000060)
+
+#define BP_PXP_OUT_LRC_RSVD1	  30
+#define BM_PXP_OUT_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_LRC_RSVD1)
+#define BP_PXP_OUT_LRC_X      16
+#define BM_PXP_OUT_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_LRC_X(v)  \
+	(((v) << 16) & BM_PXP_OUT_LRC_X)
+#define BP_PXP_OUT_LRC_RSVD0	  14
+#define BM_PXP_OUT_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_LRC_RSVD0)
+#define BP_PXP_OUT_LRC_Y      0
+#define BM_PXP_OUT_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_LRC_Y(v)  \
+	(((v) << 0) & BM_PXP_OUT_LRC_Y)
+
+#define HW_PXP_OUT_PS_ULC	(0x00000070)
+
+#define BP_PXP_OUT_PS_ULC_RSVD1      30
+#define BM_PXP_OUT_PS_ULC_RSVD1 0xC0000000
+#define BF_PXP_OUT_PS_ULC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_PS_ULC_RSVD1)
+#define BP_PXP_OUT_PS_ULC_X	 16
+#define BM_PXP_OUT_PS_ULC_X 0x3FFF0000
+#define BF_PXP_OUT_PS_ULC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_PS_ULC_X)
+#define BP_PXP_OUT_PS_ULC_RSVD0      14
+#define BM_PXP_OUT_PS_ULC_RSVD0 0x0000C000
+#define BF_PXP_OUT_PS_ULC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_PS_ULC_RSVD0)
+#define BP_PXP_OUT_PS_ULC_Y	 0
+#define BM_PXP_OUT_PS_ULC_Y 0x00003FFF
+#define BF_PXP_OUT_PS_ULC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_PS_ULC_Y)
+
+#define HW_PXP_OUT_PS_LRC	(0x00000080)
+
+#define BP_PXP_OUT_PS_LRC_RSVD1      30
+#define BM_PXP_OUT_PS_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_PS_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_PS_LRC_RSVD1)
+#define BP_PXP_OUT_PS_LRC_X	 16
+#define BM_PXP_OUT_PS_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_PS_LRC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_PS_LRC_X)
+#define BP_PXP_OUT_PS_LRC_RSVD0      14
+#define BM_PXP_OUT_PS_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_PS_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_PS_LRC_RSVD0)
+#define BP_PXP_OUT_PS_LRC_Y	 0
+#define BM_PXP_OUT_PS_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_PS_LRC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_PS_LRC_Y)
+
+#define HW_PXP_OUT_AS_ULC	(0x00000090)
+
+#define BP_PXP_OUT_AS_ULC_RSVD1      30
+#define BM_PXP_OUT_AS_ULC_RSVD1 0xC0000000
+#define BF_PXP_OUT_AS_ULC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_AS_ULC_RSVD1)
+#define BP_PXP_OUT_AS_ULC_X	 16
+#define BM_PXP_OUT_AS_ULC_X 0x3FFF0000
+#define BF_PXP_OUT_AS_ULC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_AS_ULC_X)
+#define BP_PXP_OUT_AS_ULC_RSVD0      14
+#define BM_PXP_OUT_AS_ULC_RSVD0 0x0000C000
+#define BF_PXP_OUT_AS_ULC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_AS_ULC_RSVD0)
+#define BP_PXP_OUT_AS_ULC_Y	 0
+#define BM_PXP_OUT_AS_ULC_Y 0x00003FFF
+#define BF_PXP_OUT_AS_ULC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_AS_ULC_Y)
+
+#define HW_PXP_OUT_AS_LRC	(0x000000a0)
+
+#define BP_PXP_OUT_AS_LRC_RSVD1      30
+#define BM_PXP_OUT_AS_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_AS_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_AS_LRC_RSVD1)
+#define BP_PXP_OUT_AS_LRC_X	 16
+#define BM_PXP_OUT_AS_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_AS_LRC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_AS_LRC_X)
+#define BP_PXP_OUT_AS_LRC_RSVD0      14
+#define BM_PXP_OUT_AS_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_AS_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_AS_LRC_RSVD0)
+#define BP_PXP_OUT_AS_LRC_Y	 0
+#define BM_PXP_OUT_AS_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_AS_LRC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_AS_LRC_Y)
+
+#define HW_PXP_PS_CTRL	(0x000000b0)
+#define HW_PXP_PS_CTRL_SET	(0x000000b4)
+#define HW_PXP_PS_CTRL_CLR	(0x000000b8)
+#define HW_PXP_PS_CTRL_TOG	(0x000000bc)
+
+#define BP_PXP_PS_CTRL_RSVD1	  12
+#define BM_PXP_PS_CTRL_RSVD1 0xFFFFF000
+#define BF_PXP_PS_CTRL_RSVD1(v) \
+	(((v) << 12) & BM_PXP_PS_CTRL_RSVD1)
+#define BP_PXP_PS_CTRL_DECX	 10
+#define BM_PXP_PS_CTRL_DECX 0x00000C00
+#define BF_PXP_PS_CTRL_DECX(v)	\
+	(((v) << 10) & BM_PXP_PS_CTRL_DECX)
+#define BV_PXP_PS_CTRL_DECX__DISABLE 0x0
+#define BV_PXP_PS_CTRL_DECX__DECX2   0x1
+#define BV_PXP_PS_CTRL_DECX__DECX4   0x2
+#define BV_PXP_PS_CTRL_DECX__DECX8   0x3
+#define BP_PXP_PS_CTRL_DECY	 8
+#define BM_PXP_PS_CTRL_DECY 0x00000300
+#define BF_PXP_PS_CTRL_DECY(v)	\
+	(((v) << 8) & BM_PXP_PS_CTRL_DECY)
+#define BV_PXP_PS_CTRL_DECY__DISABLE 0x0
+#define BV_PXP_PS_CTRL_DECY__DECY2   0x1
+#define BV_PXP_PS_CTRL_DECY__DECY4   0x2
+#define BV_PXP_PS_CTRL_DECY__DECY8   0x3
+#define BP_PXP_PS_CTRL_RSVD0	  5
+#define BM_PXP_PS_CTRL_RSVD0 0x000000E0
+#define BF_PXP_PS_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_RSVD0)
+#define BP_PXP_PS_CTRL_FORMAT	   0
+#define BM_PXP_PS_CTRL_FORMAT 0x0000001F
+#define BF_PXP_PS_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_PS_CTRL_FORMAT)
+#define BV_PXP_PS_CTRL_FORMAT__RGB888	 0x4
+#define BV_PXP_PS_CTRL_FORMAT__RGB555	 0xC
+#define BV_PXP_PS_CTRL_FORMAT__RGB444	 0xD
+#define BV_PXP_PS_CTRL_FORMAT__RGB565	 0xE
+#define BV_PXP_PS_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_PS_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_PS_CTRL_FORMAT__VYUY1P422 0x13
+#define BV_PXP_PS_CTRL_FORMAT__Y8	 0x14
+#define BV_PXP_PS_CTRL_FORMAT__Y4	 0x15
+#define BV_PXP_PS_CTRL_FORMAT__YUV2P422  0x18
+#define BV_PXP_PS_CTRL_FORMAT__YUV2P420  0x19
+#define BV_PXP_PS_CTRL_FORMAT__YVU2P422  0x1A
+#define BV_PXP_PS_CTRL_FORMAT__YVU2P420  0x1B
+#define BV_PXP_PS_CTRL_FORMAT__YUV422	 0x1E
+#define BV_PXP_PS_CTRL_FORMAT__YUV420	 0x1F
+
+#define HW_PXP_PS_BUF	(0x000000c0)
+
+#define BP_PXP_PS_BUF_ADDR	0
+#define BM_PXP_PS_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_BUF_ADDR(v)	(v)
+
+#define HW_PXP_PS_UBUF	(0x000000d0)
+
+#define BP_PXP_PS_UBUF_ADDR	 0
+#define BM_PXP_PS_UBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_UBUF_ADDR(v)	 (v)
+
+#define HW_PXP_PS_VBUF	(0x000000e0)
+
+#define BP_PXP_PS_VBUF_ADDR	 0
+#define BM_PXP_PS_VBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_VBUF_ADDR(v)	 (v)
+
+#define HW_PXP_PS_PITCH	(0x000000f0)
+
+#define BP_PXP_PS_PITCH_RSVD	  16
+#define BM_PXP_PS_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_PS_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_PS_PITCH_RSVD)
+#define BP_PXP_PS_PITCH_PITCH	   0
+#define BM_PXP_PS_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_PS_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_PS_PITCH_PITCH)
+
+#define HW_PXP_PS_BACKGROUND	(0x00000100)
+
+#define BP_PXP_PS_BACKGROUND_RSVD      24
+#define BM_PXP_PS_BACKGROUND_RSVD 0xFF000000
+#define BF_PXP_PS_BACKGROUND_RSVD(v) \
+	(((v) << 24) & BM_PXP_PS_BACKGROUND_RSVD)
+#define BP_PXP_PS_BACKGROUND_COLOR	0
+#define BM_PXP_PS_BACKGROUND_COLOR 0x00FFFFFF
+#define BF_PXP_PS_BACKGROUND_COLOR(v)  \
+	(((v) << 0) & BM_PXP_PS_BACKGROUND_COLOR)
+
+#define HW_PXP_PS_SCALE	(0x00000110)
+
+#define BM_PXP_PS_SCALE_RSVD2 0x80000000
+#define BP_PXP_PS_SCALE_YSCALE	    16
+#define BM_PXP_PS_SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_PS_SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_PS_SCALE_YSCALE)
+#define BM_PXP_PS_SCALE_RSVD1 0x00008000
+#define BP_PXP_PS_SCALE_XSCALE	    0
+#define BM_PXP_PS_SCALE_XSCALE 0x00007FFF
+#define BF_PXP_PS_SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_PS_SCALE_XSCALE)
+
+#define HW_PXP_PS_OFFSET	(0x00000120)
+
+#define BP_PXP_PS_OFFSET_RSVD2	    28
+#define BM_PXP_PS_OFFSET_RSVD2 0xF0000000
+#define BF_PXP_PS_OFFSET_RSVD2(v) \
+	(((v) << 28) & BM_PXP_PS_OFFSET_RSVD2)
+#define BP_PXP_PS_OFFSET_YOFFSET      16
+#define BM_PXP_PS_OFFSET_YOFFSET 0x0FFF0000
+#define BF_PXP_PS_OFFSET_YOFFSET(v)  \
+	(((v) << 16) & BM_PXP_PS_OFFSET_YOFFSET)
+#define BP_PXP_PS_OFFSET_RSVD1	    12
+#define BM_PXP_PS_OFFSET_RSVD1 0x0000F000
+#define BF_PXP_PS_OFFSET_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_PS_OFFSET_RSVD1)
+#define BP_PXP_PS_OFFSET_XOFFSET      0
+#define BM_PXP_PS_OFFSET_XOFFSET 0x00000FFF
+#define BF_PXP_PS_OFFSET_XOFFSET(v)  \
+	(((v) << 0) & BM_PXP_PS_OFFSET_XOFFSET)
+
+#define HW_PXP_PS_CLRKEYLOW	(0x00000130)
+
+#define BP_PXP_PS_CLRKEYLOW_RSVD1      24
+#define BM_PXP_PS_CLRKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_PS_CLRKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_PS_CLRKEYLOW_RSVD1)
+#define BP_PXP_PS_CLRKEYLOW_PIXEL      0
+#define BM_PXP_PS_CLRKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_PS_CLRKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_PS_CLRKEYLOW_PIXEL)
+
+#define HW_PXP_PS_CLRKEYHIGH	(0x00000140)
+
+#define BP_PXP_PS_CLRKEYHIGH_RSVD1	24
+#define BM_PXP_PS_CLRKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_PS_CLRKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_PS_CLRKEYHIGH_RSVD1)
+#define BP_PXP_PS_CLRKEYHIGH_PIXEL	0
+#define BM_PXP_PS_CLRKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_PS_CLRKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_PS_CLRKEYHIGH_PIXEL)
+
+#define HW_PXP_AS_CTRL	(0x00000150)
+
+#define BP_PXP_AS_CTRL_RSVD1	  21
+#define BM_PXP_AS_CTRL_RSVD1 0xFFE00000
+#define BF_PXP_AS_CTRL_RSVD1(v) \
+	(((v) << 21) & BM_PXP_AS_CTRL_RSVD1)
+#define BM_PXP_AS_CTRL_ALPHA_INVERT 0x00100000
+#define BP_PXP_AS_CTRL_ROP	16
+#define BM_PXP_AS_CTRL_ROP 0x000F0000
+#define BF_PXP_AS_CTRL_ROP(v)  \
+	(((v) << 16) & BM_PXP_AS_CTRL_ROP)
+#define BV_PXP_AS_CTRL_ROP__MASKAS     0x0
+#define BV_PXP_AS_CTRL_ROP__MASKNOTAS  0x1
+#define BV_PXP_AS_CTRL_ROP__MASKASNOT  0x2
+#define BV_PXP_AS_CTRL_ROP__MERGEAS    0x3
+#define BV_PXP_AS_CTRL_ROP__MERGENOTAS 0x4
+#define BV_PXP_AS_CTRL_ROP__MERGEASNOT 0x5
+#define BV_PXP_AS_CTRL_ROP__NOTCOPYAS  0x6
+#define BV_PXP_AS_CTRL_ROP__NOT        0x7
+#define BV_PXP_AS_CTRL_ROP__NOTMASKAS  0x8
+#define BV_PXP_AS_CTRL_ROP__NOTMERGEAS 0x9
+#define BV_PXP_AS_CTRL_ROP__XORAS      0xA
+#define BV_PXP_AS_CTRL_ROP__NOTXORAS   0xB
+#define BP_PXP_AS_CTRL_ALPHA	  8
+#define BM_PXP_AS_CTRL_ALPHA 0x0000FF00
+#define BF_PXP_AS_CTRL_ALPHA(v)  \
+	(((v) << 8) & BM_PXP_AS_CTRL_ALPHA)
+#define BP_PXP_AS_CTRL_FORMAT	   4
+#define BM_PXP_AS_CTRL_FORMAT 0x000000F0
+#define BF_PXP_AS_CTRL_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_AS_CTRL_FORMAT)
+#define BV_PXP_AS_CTRL_FORMAT__ARGB8888 0x0
+#define BV_PXP_AS_CTRL_FORMAT__RGB888	0x4
+#define BV_PXP_AS_CTRL_FORMAT__ARGB1555 0x8
+#define BV_PXP_AS_CTRL_FORMAT__ARGB4444 0x9
+#define BV_PXP_AS_CTRL_FORMAT__RGB555	0xC
+#define BV_PXP_AS_CTRL_FORMAT__RGB444	0xD
+#define BV_PXP_AS_CTRL_FORMAT__RGB565	0xE
+#define BM_PXP_AS_CTRL_ENABLE_COLORKEY 0x00000008
+#define BP_PXP_AS_CTRL_ALPHA_CTRL      1
+#define BM_PXP_AS_CTRL_ALPHA_CTRL 0x00000006
+#define BF_PXP_AS_CTRL_ALPHA_CTRL(v)  \
+	(((v) << 1) & BM_PXP_AS_CTRL_ALPHA_CTRL)
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Embedded 0x0
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Override 0x1
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Multiply 0x2
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__ROPs     0x3
+#define BM_PXP_AS_CTRL_RSVD0 0x00000001
+
+#define HW_PXP_AS_BUF	(0x00000160)
+
+#define BP_PXP_AS_BUF_ADDR	0
+#define BM_PXP_AS_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_AS_BUF_ADDR(v)	(v)
+
+#define HW_PXP_AS_PITCH	(0x00000170)
+
+#define BP_PXP_AS_PITCH_RSVD	  16
+#define BM_PXP_AS_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_AS_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_AS_PITCH_RSVD)
+#define BP_PXP_AS_PITCH_PITCH	   0
+#define BM_PXP_AS_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_AS_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_AS_PITCH_PITCH)
+
+#define HW_PXP_AS_CLRKEYLOW	(0x00000180)
+
+#define BP_PXP_AS_CLRKEYLOW_RSVD1      24
+#define BM_PXP_AS_CLRKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_AS_CLRKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_AS_CLRKEYLOW_RSVD1)
+#define BP_PXP_AS_CLRKEYLOW_PIXEL      0
+#define BM_PXP_AS_CLRKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_AS_CLRKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_AS_CLRKEYLOW_PIXEL)
+
+#define HW_PXP_AS_CLRKEYHIGH	(0x00000190)
+
+#define BP_PXP_AS_CLRKEYHIGH_RSVD1	24
+#define BM_PXP_AS_CLRKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_AS_CLRKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_AS_CLRKEYHIGH_RSVD1)
+#define BP_PXP_AS_CLRKEYHIGH_PIXEL	0
+#define BM_PXP_AS_CLRKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_AS_CLRKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_AS_CLRKEYHIGH_PIXEL)
+
+#define HW_PXP_CSC1_COEF0	(0x000001a0)
+
+#define BM_PXP_CSC1_COEF0_YCBCR_MODE 0x80000000
+#define BM_PXP_CSC1_COEF0_BYPASS 0x40000000
+#define BM_PXP_CSC1_COEF0_RSVD1 0x20000000
+#define BP_PXP_CSC1_COEF0_C0	  18
+#define BM_PXP_CSC1_COEF0_C0 0x1FFC0000
+#define BF_PXP_CSC1_COEF0_C0(v)  \
+	(((v) << 18) & BM_PXP_CSC1_COEF0_C0)
+#define BP_PXP_CSC1_COEF0_UV_OFFSET	 9
+#define BM_PXP_CSC1_COEF0_UV_OFFSET 0x0003FE00
+#define BF_PXP_CSC1_COEF0_UV_OFFSET(v)	\
+	(((v) << 9) & BM_PXP_CSC1_COEF0_UV_OFFSET)
+#define BP_PXP_CSC1_COEF0_Y_OFFSET	0
+#define BM_PXP_CSC1_COEF0_Y_OFFSET 0x000001FF
+#define BF_PXP_CSC1_COEF0_Y_OFFSET(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF0_Y_OFFSET)
+
+#define HW_PXP_CSC1_COEF1	(0x000001b0)
+
+#define BP_PXP_CSC1_COEF1_RSVD1      27
+#define BM_PXP_CSC1_COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC1_COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC1_COEF1_RSVD1)
+#define BP_PXP_CSC1_COEF1_C1	  16
+#define BM_PXP_CSC1_COEF1_C1 0x07FF0000
+#define BF_PXP_CSC1_COEF1_C1(v)  \
+	(((v) << 16) & BM_PXP_CSC1_COEF1_C1)
+#define BP_PXP_CSC1_COEF1_RSVD0      11
+#define BM_PXP_CSC1_COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC1_COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC1_COEF1_RSVD0)
+#define BP_PXP_CSC1_COEF1_C4	  0
+#define BM_PXP_CSC1_COEF1_C4 0x000007FF
+#define BF_PXP_CSC1_COEF1_C4(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF1_C4)
+
+#define HW_PXP_CSC1_COEF2	(0x000001c0)
+
+#define BP_PXP_CSC1_COEF2_RSVD1      27
+#define BM_PXP_CSC1_COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC1_COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC1_COEF2_RSVD1)
+#define BP_PXP_CSC1_COEF2_C2	  16
+#define BM_PXP_CSC1_COEF2_C2 0x07FF0000
+#define BF_PXP_CSC1_COEF2_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC1_COEF2_C2)
+#define BP_PXP_CSC1_COEF2_RSVD0      11
+#define BM_PXP_CSC1_COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC1_COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC1_COEF2_RSVD0)
+#define BP_PXP_CSC1_COEF2_C3	  0
+#define BM_PXP_CSC1_COEF2_C3 0x000007FF
+#define BF_PXP_CSC1_COEF2_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF2_C3)
+
+#define HW_PXP_CSC2_CTRL	(0x000001d0)
+
+#define BP_PXP_CSC2_CTRL_RSVD	   3
+#define BM_PXP_CSC2_CTRL_RSVD 0xFFFFFFF8
+#define BF_PXP_CSC2_CTRL_RSVD(v) \
+	(((v) << 3) & BM_PXP_CSC2_CTRL_RSVD)
+#define BP_PXP_CSC2_CTRL_CSC_MODE      1
+#define BM_PXP_CSC2_CTRL_CSC_MODE 0x00000006
+#define BF_PXP_CSC2_CTRL_CSC_MODE(v)  \
+	(((v) << 1) & BM_PXP_CSC2_CTRL_CSC_MODE)
+#define BV_PXP_CSC2_CTRL_CSC_MODE__YUV2RGB   0x0
+#define BV_PXP_CSC2_CTRL_CSC_MODE__YCbCr2RGB 0x1
+#define BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YUV   0x2
+#define BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YCbCr 0x3
+#define BM_PXP_CSC2_CTRL_BYPASS 0x00000001
+
+#define HW_PXP_CSC2_COEF0	(0x000001e0)
+
+#define BP_PXP_CSC2_COEF0_RSVD1      27
+#define BM_PXP_CSC2_COEF0_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF0_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF0_RSVD1)
+#define BP_PXP_CSC2_COEF0_A2	  16
+#define BM_PXP_CSC2_COEF0_A2 0x07FF0000
+#define BF_PXP_CSC2_COEF0_A2(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF0_A2)
+#define BP_PXP_CSC2_COEF0_RSVD0      11
+#define BM_PXP_CSC2_COEF0_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF0_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF0_RSVD0)
+#define BP_PXP_CSC2_COEF0_A1	  0
+#define BM_PXP_CSC2_COEF0_A1 0x000007FF
+#define BF_PXP_CSC2_COEF0_A1(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF0_A1)
+
+#define HW_PXP_CSC2_COEF1	(0x000001f0)
+
+#define BP_PXP_CSC2_COEF1_RSVD1      27
+#define BM_PXP_CSC2_COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF1_RSVD1)
+#define BP_PXP_CSC2_COEF1_B1	  16
+#define BM_PXP_CSC2_COEF1_B1 0x07FF0000
+#define BF_PXP_CSC2_COEF1_B1(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF1_B1)
+#define BP_PXP_CSC2_COEF1_RSVD0      11
+#define BM_PXP_CSC2_COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF1_RSVD0)
+#define BP_PXP_CSC2_COEF1_A3	  0
+#define BM_PXP_CSC2_COEF1_A3 0x000007FF
+#define BF_PXP_CSC2_COEF1_A3(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF1_A3)
+
+#define HW_PXP_CSC2_COEF2	(0x00000200)
+
+#define BP_PXP_CSC2_COEF2_RSVD1      27
+#define BM_PXP_CSC2_COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF2_RSVD1)
+#define BP_PXP_CSC2_COEF2_B3	  16
+#define BM_PXP_CSC2_COEF2_B3 0x07FF0000
+#define BF_PXP_CSC2_COEF2_B3(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF2_B3)
+#define BP_PXP_CSC2_COEF2_RSVD0      11
+#define BM_PXP_CSC2_COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF2_RSVD0)
+#define BP_PXP_CSC2_COEF2_B2	  0
+#define BM_PXP_CSC2_COEF2_B2 0x000007FF
+#define BF_PXP_CSC2_COEF2_B2(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF2_B2)
+
+#define HW_PXP_CSC2_COEF3	(0x00000210)
+
+#define BP_PXP_CSC2_COEF3_RSVD1      27
+#define BM_PXP_CSC2_COEF3_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF3_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF3_RSVD1)
+#define BP_PXP_CSC2_COEF3_C2	  16
+#define BM_PXP_CSC2_COEF3_C2 0x07FF0000
+#define BF_PXP_CSC2_COEF3_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF3_C2)
+#define BP_PXP_CSC2_COEF3_RSVD0      11
+#define BM_PXP_CSC2_COEF3_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF3_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF3_RSVD0)
+#define BP_PXP_CSC2_COEF3_C1	  0
+#define BM_PXP_CSC2_COEF3_C1 0x000007FF
+#define BF_PXP_CSC2_COEF3_C1(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF3_C1)
+
+#define HW_PXP_CSC2_COEF4	(0x00000220)
+
+#define BP_PXP_CSC2_COEF4_RSVD1      25
+#define BM_PXP_CSC2_COEF4_RSVD1 0xFE000000
+#define BF_PXP_CSC2_COEF4_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2_COEF4_RSVD1)
+#define BP_PXP_CSC2_COEF4_D1	  16
+#define BM_PXP_CSC2_COEF4_D1 0x01FF0000
+#define BF_PXP_CSC2_COEF4_D1(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF4_D1)
+#define BP_PXP_CSC2_COEF4_RSVD0      11
+#define BM_PXP_CSC2_COEF4_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF4_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF4_RSVD0)
+#define BP_PXP_CSC2_COEF4_C3	  0
+#define BM_PXP_CSC2_COEF4_C3 0x000007FF
+#define BF_PXP_CSC2_COEF4_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF4_C3)
+
+#define HW_PXP_CSC2_COEF5	(0x00000230)
+
+#define BP_PXP_CSC2_COEF5_RSVD1      25
+#define BM_PXP_CSC2_COEF5_RSVD1 0xFE000000
+#define BF_PXP_CSC2_COEF5_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2_COEF5_RSVD1)
+#define BP_PXP_CSC2_COEF5_D3	  16
+#define BM_PXP_CSC2_COEF5_D3 0x01FF0000
+#define BF_PXP_CSC2_COEF5_D3(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF5_D3)
+#define BP_PXP_CSC2_COEF5_RSVD0      9
+#define BM_PXP_CSC2_COEF5_RSVD0 0x0000FE00
+#define BF_PXP_CSC2_COEF5_RSVD0(v)  \
+	(((v) << 9) & BM_PXP_CSC2_COEF5_RSVD0)
+#define BP_PXP_CSC2_COEF5_D2	  0
+#define BM_PXP_CSC2_COEF5_D2 0x000001FF
+#define BF_PXP_CSC2_COEF5_D2(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF5_D2)
+
+#define HW_PXP_LUT_CTRL	(0x00000240)
+
+#define BM_PXP_LUT_CTRL_BYPASS 0x80000000
+#define BP_PXP_LUT_CTRL_RSVD3	   26
+#define BM_PXP_LUT_CTRL_RSVD3 0x7C000000
+#define BF_PXP_LUT_CTRL_RSVD3(v)  \
+	(((v) << 26) & BM_PXP_LUT_CTRL_RSVD3)
+#define BP_PXP_LUT_CTRL_LOOKUP_MODE	 24
+#define BM_PXP_LUT_CTRL_LOOKUP_MODE 0x03000000
+#define BF_PXP_LUT_CTRL_LOOKUP_MODE(v)	\
+	(((v) << 24) & BM_PXP_LUT_CTRL_LOOKUP_MODE)
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__CACHE_RGB565  0x0
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8	   0x1
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_RGB444 0x2
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_RGB454 0x3
+#define BP_PXP_LUT_CTRL_RSVD2	   18
+#define BM_PXP_LUT_CTRL_RSVD2 0x00FC0000
+#define BF_PXP_LUT_CTRL_RSVD2(v)  \
+	(((v) << 18) & BM_PXP_LUT_CTRL_RSVD2)
+#define BP_PXP_LUT_CTRL_OUT_MODE      16
+#define BM_PXP_LUT_CTRL_OUT_MODE 0x00030000
+#define BF_PXP_LUT_CTRL_OUT_MODE(v)  \
+	(((v) << 16) & BM_PXP_LUT_CTRL_OUT_MODE)
+#define BV_PXP_LUT_CTRL_OUT_MODE__RESERVED    0x0
+#define BV_PXP_LUT_CTRL_OUT_MODE__Y8	      0x1
+#define BV_PXP_LUT_CTRL_OUT_MODE__RGBW4444CFA 0x2
+#define BV_PXP_LUT_CTRL_OUT_MODE__RGB888      0x3
+#define BP_PXP_LUT_CTRL_RSVD1	   11
+#define BM_PXP_LUT_CTRL_RSVD1 0x0000F800
+#define BF_PXP_LUT_CTRL_RSVD1(v)  \
+	(((v) << 11) & BM_PXP_LUT_CTRL_RSVD1)
+#define BM_PXP_LUT_CTRL_SEL_8KB 0x00000400
+#define BM_PXP_LUT_CTRL_LRU_UPD 0x00000200
+#define BM_PXP_LUT_CTRL_INVALID 0x00000100
+#define BP_PXP_LUT_CTRL_RSVD0	   1
+#define BM_PXP_LUT_CTRL_RSVD0 0x000000FE
+#define BF_PXP_LUT_CTRL_RSVD0(v)  \
+	(((v) << 1) & BM_PXP_LUT_CTRL_RSVD0)
+#define BM_PXP_LUT_CTRL_DMA_START 0x00000001
+
+#define HW_PXP_LUT_ADDR	(0x00000250)
+
+#define BM_PXP_LUT_ADDR_RSVD2 0x80000000
+#define BP_PXP_LUT_ADDR_NUM_BYTES      16
+#define BM_PXP_LUT_ADDR_NUM_BYTES 0x7FFF0000
+#define BF_PXP_LUT_ADDR_NUM_BYTES(v)  \
+	(((v) << 16) & BM_PXP_LUT_ADDR_NUM_BYTES)
+#define BP_PXP_LUT_ADDR_RSVD1	   14
+#define BM_PXP_LUT_ADDR_RSVD1 0x0000C000
+#define BF_PXP_LUT_ADDR_RSVD1(v)  \
+	(((v) << 14) & BM_PXP_LUT_ADDR_RSVD1)
+#define BP_PXP_LUT_ADDR_ADDR	  0
+#define BM_PXP_LUT_ADDR_ADDR 0x00003FFF
+#define BF_PXP_LUT_ADDR_ADDR(v)  \
+	(((v) << 0) & BM_PXP_LUT_ADDR_ADDR)
+
+#define HW_PXP_LUT_DATA	(0x00000260)
+
+#define BP_PXP_LUT_DATA_DATA	  0
+#define BM_PXP_LUT_DATA_DATA 0xFFFFFFFF
+#define BF_PXP_LUT_DATA_DATA(v)   (v)
+
+#define HW_PXP_LUT_EXTMEM	(0x00000270)
+
+#define BP_PXP_LUT_EXTMEM_ADDR	    0
+#define BM_PXP_LUT_EXTMEM_ADDR 0xFFFFFFFF
+#define BF_PXP_LUT_EXTMEM_ADDR(v)   (v)
+
+#define HW_PXP_CFA	(0x00000280)
+
+#define BP_PXP_CFA_DATA      0
+#define BM_PXP_CFA_DATA 0xFFFFFFFF
+#define BF_PXP_CFA_DATA(v)   (v)
+
+#define HW_PXP_HIST_CTRL	(0x00000290)
+
+#define BP_PXP_HIST_CTRL_RSVD	   6
+#define BM_PXP_HIST_CTRL_RSVD 0xFFFFFFC0
+#define BF_PXP_HIST_CTRL_RSVD(v) \
+	(((v) << 6) & BM_PXP_HIST_CTRL_RSVD)
+#define BP_PXP_HIST_CTRL_PANEL_MODE	 4
+#define BM_PXP_HIST_CTRL_PANEL_MODE 0x00000030
+#define BF_PXP_HIST_CTRL_PANEL_MODE(v)	\
+	(((v) << 4) & BM_PXP_HIST_CTRL_PANEL_MODE)
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY4  0x0
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY8  0x1
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16 0x2
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY32 0x3
+#define BP_PXP_HIST_CTRL_STATUS      0
+#define BM_PXP_HIST_CTRL_STATUS 0x0000000F
+#define BF_PXP_HIST_CTRL_STATUS(v)  \
+	(((v) << 0) & BM_PXP_HIST_CTRL_STATUS)
+
+#define HW_PXP_HIST2_PARAM	(0x000002a0)
+
+#define BP_PXP_HIST2_PARAM_RSVD      16
+#define BM_PXP_HIST2_PARAM_RSVD 0xFFFF0000
+#define BF_PXP_HIST2_PARAM_RSVD(v) \
+	(((v) << 16) & BM_PXP_HIST2_PARAM_RSVD)
+#define BP_PXP_HIST2_PARAM_RSVD1      13
+#define BM_PXP_HIST2_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST2_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST2_PARAM_RSVD1)
+#define BP_PXP_HIST2_PARAM_VALUE1      8
+#define BM_PXP_HIST2_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST2_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST2_PARAM_VALUE1)
+#define BP_PXP_HIST2_PARAM_RSVD0      5
+#define BM_PXP_HIST2_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST2_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST2_PARAM_RSVD0)
+#define BP_PXP_HIST2_PARAM_VALUE0      0
+#define BM_PXP_HIST2_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST2_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST2_PARAM_VALUE0)
+
+#define HW_PXP_HIST4_PARAM	(0x000002b0)
+
+#define BP_PXP_HIST4_PARAM_RSVD3      29
+#define BM_PXP_HIST4_PARAM_RSVD3 0xE0000000
+#define BF_PXP_HIST4_PARAM_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST4_PARAM_RSVD3)
+#define BP_PXP_HIST4_PARAM_VALUE3      24
+#define BM_PXP_HIST4_PARAM_VALUE3 0x1F000000
+#define BF_PXP_HIST4_PARAM_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST4_PARAM_VALUE3)
+#define BP_PXP_HIST4_PARAM_RSVD2      21
+#define BM_PXP_HIST4_PARAM_RSVD2 0x00E00000
+#define BF_PXP_HIST4_PARAM_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST4_PARAM_RSVD2)
+#define BP_PXP_HIST4_PARAM_VALUE2      16
+#define BM_PXP_HIST4_PARAM_VALUE2 0x001F0000
+#define BF_PXP_HIST4_PARAM_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST4_PARAM_VALUE2)
+#define BP_PXP_HIST4_PARAM_RSVD1      13
+#define BM_PXP_HIST4_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST4_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST4_PARAM_RSVD1)
+#define BP_PXP_HIST4_PARAM_VALUE1      8
+#define BM_PXP_HIST4_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST4_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST4_PARAM_VALUE1)
+#define BP_PXP_HIST4_PARAM_RSVD0      5
+#define BM_PXP_HIST4_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST4_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST4_PARAM_RSVD0)
+#define BP_PXP_HIST4_PARAM_VALUE0      0
+#define BM_PXP_HIST4_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST4_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST4_PARAM_VALUE0)
+
+#define HW_PXP_HIST8_PARAM0	(0x000002c0)
+
+#define BP_PXP_HIST8_PARAM0_RSVD3      29
+#define BM_PXP_HIST8_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST8_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM0_RSVD3)
+#define BP_PXP_HIST8_PARAM0_VALUE3	24
+#define BM_PXP_HIST8_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST8_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM0_VALUE3)
+#define BP_PXP_HIST8_PARAM0_RSVD2      21
+#define BM_PXP_HIST8_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST8_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM0_RSVD2)
+#define BP_PXP_HIST8_PARAM0_VALUE2	16
+#define BM_PXP_HIST8_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST8_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM0_VALUE2)
+#define BP_PXP_HIST8_PARAM0_RSVD1      13
+#define BM_PXP_HIST8_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST8_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM0_RSVD1)
+#define BP_PXP_HIST8_PARAM0_VALUE1	8
+#define BM_PXP_HIST8_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST8_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM0_VALUE1)
+#define BP_PXP_HIST8_PARAM0_RSVD0      5
+#define BM_PXP_HIST8_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST8_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM0_RSVD0)
+#define BP_PXP_HIST8_PARAM0_VALUE0	0
+#define BM_PXP_HIST8_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST8_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM0_VALUE0)
+
+#define HW_PXP_HIST8_PARAM1	(0x000002d0)
+
+#define BP_PXP_HIST8_PARAM1_RSVD7      29
+#define BM_PXP_HIST8_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST8_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM1_RSVD7)
+#define BP_PXP_HIST8_PARAM1_VALUE7	24
+#define BM_PXP_HIST8_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST8_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM1_VALUE7)
+#define BP_PXP_HIST8_PARAM1_RSVD6      21
+#define BM_PXP_HIST8_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST8_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM1_RSVD6)
+#define BP_PXP_HIST8_PARAM1_VALUE6	16
+#define BM_PXP_HIST8_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST8_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM1_VALUE6)
+#define BP_PXP_HIST8_PARAM1_RSVD5      13
+#define BM_PXP_HIST8_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST8_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM1_RSVD5)
+#define BP_PXP_HIST8_PARAM1_VALUE5	8
+#define BM_PXP_HIST8_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST8_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM1_VALUE5)
+#define BP_PXP_HIST8_PARAM1_RSVD4      5
+#define BM_PXP_HIST8_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST8_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM1_RSVD4)
+#define BP_PXP_HIST8_PARAM1_VALUE4	0
+#define BM_PXP_HIST8_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST8_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM0	(0x000002e0)
+
+#define BP_PXP_HIST16_PARAM0_RSVD3	29
+#define BM_PXP_HIST16_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST16_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM0_RSVD3)
+#define BP_PXP_HIST16_PARAM0_VALUE3	 24
+#define BM_PXP_HIST16_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST16_PARAM0_VALUE3(v)	\
+	(((v) << 24) & BM_PXP_HIST16_PARAM0_VALUE3)
+#define BP_PXP_HIST16_PARAM0_RSVD2	21
+#define BM_PXP_HIST16_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST16_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM0_RSVD2)
+#define BP_PXP_HIST16_PARAM0_VALUE2	 16
+#define BM_PXP_HIST16_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST16_PARAM0_VALUE2(v)	\
+	(((v) << 16) & BM_PXP_HIST16_PARAM0_VALUE2)
+#define BP_PXP_HIST16_PARAM0_RSVD1	13
+#define BM_PXP_HIST16_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST16_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM0_RSVD1)
+#define BP_PXP_HIST16_PARAM0_VALUE1	 8
+#define BM_PXP_HIST16_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST16_PARAM0_VALUE1(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM0_VALUE1)
+#define BP_PXP_HIST16_PARAM0_RSVD0	5
+#define BM_PXP_HIST16_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST16_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM0_RSVD0)
+#define BP_PXP_HIST16_PARAM0_VALUE0	 0
+#define BM_PXP_HIST16_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST16_PARAM0_VALUE0(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM0_VALUE0)
+
+#define HW_PXP_HIST16_PARAM1	(0x000002f0)
+
+#define BP_PXP_HIST16_PARAM1_RSVD7	29
+#define BM_PXP_HIST16_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST16_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM1_RSVD7)
+#define BP_PXP_HIST16_PARAM1_VALUE7	 24
+#define BM_PXP_HIST16_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST16_PARAM1_VALUE7(v)	\
+	(((v) << 24) & BM_PXP_HIST16_PARAM1_VALUE7)
+#define BP_PXP_HIST16_PARAM1_RSVD6	21
+#define BM_PXP_HIST16_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST16_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM1_RSVD6)
+#define BP_PXP_HIST16_PARAM1_VALUE6	 16
+#define BM_PXP_HIST16_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST16_PARAM1_VALUE6(v)	\
+	(((v) << 16) & BM_PXP_HIST16_PARAM1_VALUE6)
+#define BP_PXP_HIST16_PARAM1_RSVD5	13
+#define BM_PXP_HIST16_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST16_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM1_RSVD5)
+#define BP_PXP_HIST16_PARAM1_VALUE5	 8
+#define BM_PXP_HIST16_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST16_PARAM1_VALUE5(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM1_VALUE5)
+#define BP_PXP_HIST16_PARAM1_RSVD4	5
+#define BM_PXP_HIST16_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST16_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM1_RSVD4)
+#define BP_PXP_HIST16_PARAM1_VALUE4	 0
+#define BM_PXP_HIST16_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST16_PARAM1_VALUE4(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM2	(0x00000300)
+
+#define BP_PXP_HIST16_PARAM2_RSVD11	 29
+#define BM_PXP_HIST16_PARAM2_RSVD11 0xE0000000
+#define BF_PXP_HIST16_PARAM2_RSVD11(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM2_RSVD11)
+#define BP_PXP_HIST16_PARAM2_VALUE11	  24
+#define BM_PXP_HIST16_PARAM2_VALUE11 0x1F000000
+#define BF_PXP_HIST16_PARAM2_VALUE11(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM2_VALUE11)
+#define BP_PXP_HIST16_PARAM2_RSVD10	 21
+#define BM_PXP_HIST16_PARAM2_RSVD10 0x00E00000
+#define BF_PXP_HIST16_PARAM2_RSVD10(v)	\
+	(((v) << 21) & BM_PXP_HIST16_PARAM2_RSVD10)
+#define BP_PXP_HIST16_PARAM2_VALUE10	  16
+#define BM_PXP_HIST16_PARAM2_VALUE10 0x001F0000
+#define BF_PXP_HIST16_PARAM2_VALUE10(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM2_VALUE10)
+#define BP_PXP_HIST16_PARAM2_RSVD9	13
+#define BM_PXP_HIST16_PARAM2_RSVD9 0x0000E000
+#define BF_PXP_HIST16_PARAM2_RSVD9(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM2_RSVD9)
+#define BP_PXP_HIST16_PARAM2_VALUE9	 8
+#define BM_PXP_HIST16_PARAM2_VALUE9 0x00001F00
+#define BF_PXP_HIST16_PARAM2_VALUE9(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM2_VALUE9)
+#define BP_PXP_HIST16_PARAM2_RSVD8	5
+#define BM_PXP_HIST16_PARAM2_RSVD8 0x000000E0
+#define BF_PXP_HIST16_PARAM2_RSVD8(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM2_RSVD8)
+#define BP_PXP_HIST16_PARAM2_VALUE8	 0
+#define BM_PXP_HIST16_PARAM2_VALUE8 0x0000001F
+#define BF_PXP_HIST16_PARAM2_VALUE8(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM2_VALUE8)
+
+#define HW_PXP_HIST16_PARAM3	(0x00000310)
+
+#define BP_PXP_HIST16_PARAM3_RSVD15	 29
+#define BM_PXP_HIST16_PARAM3_RSVD15 0xE0000000
+#define BF_PXP_HIST16_PARAM3_RSVD15(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM3_RSVD15)
+#define BP_PXP_HIST16_PARAM3_VALUE15	  24
+#define BM_PXP_HIST16_PARAM3_VALUE15 0x1F000000
+#define BF_PXP_HIST16_PARAM3_VALUE15(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM3_VALUE15)
+#define BP_PXP_HIST16_PARAM3_RSVD14	 21
+#define BM_PXP_HIST16_PARAM3_RSVD14 0x00E00000
+#define BF_PXP_HIST16_PARAM3_RSVD14(v)	\
+	(((v) << 21) & BM_PXP_HIST16_PARAM3_RSVD14)
+#define BP_PXP_HIST16_PARAM3_VALUE14	  16
+#define BM_PXP_HIST16_PARAM3_VALUE14 0x001F0000
+#define BF_PXP_HIST16_PARAM3_VALUE14(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM3_VALUE14)
+#define BP_PXP_HIST16_PARAM3_RSVD13	 13
+#define BM_PXP_HIST16_PARAM3_RSVD13 0x0000E000
+#define BF_PXP_HIST16_PARAM3_RSVD13(v)	\
+	(((v) << 13) & BM_PXP_HIST16_PARAM3_RSVD13)
+#define BP_PXP_HIST16_PARAM3_VALUE13	  8
+#define BM_PXP_HIST16_PARAM3_VALUE13 0x00001F00
+#define BF_PXP_HIST16_PARAM3_VALUE13(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM3_VALUE13)
+#define BP_PXP_HIST16_PARAM3_RSVD12	 5
+#define BM_PXP_HIST16_PARAM3_RSVD12 0x000000E0
+#define BF_PXP_HIST16_PARAM3_RSVD12(v)	\
+	(((v) << 5) & BM_PXP_HIST16_PARAM3_RSVD12)
+#define BP_PXP_HIST16_PARAM3_VALUE12	  0
+#define BM_PXP_HIST16_PARAM3_VALUE12 0x0000001F
+#define BF_PXP_HIST16_PARAM3_VALUE12(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM3_VALUE12)
+
+#define HW_PXP_POWER	(0x00000320)
+
+#define BP_PXP_POWER_CTRL      12
+#define BM_PXP_POWER_CTRL 0xFFFFF000
+#define BF_PXP_POWER_CTRL(v) \
+	(((v) << 12) & BM_PXP_POWER_CTRL)
+#define BP_PXP_POWER_ROT_MEM_LP_STATE	   9
+#define BM_PXP_POWER_ROT_MEM_LP_STATE 0x00000E00
+#define BF_PXP_POWER_ROT_MEM_LP_STATE(v)  \
+	(((v) << 9) & BM_PXP_POWER_ROT_MEM_LP_STATE)
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__NONE 0x0
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__LS   0x1
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__DS   0x2
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY1_BANKN	  6
+#define BM_PXP_POWER_LUT_LP_STATE_WAY1_BANKN 0x000001C0
+#define BF_PXP_POWER_LUT_LP_STATE_WAY1_BANKN(v)  \
+	(((v) << 6) & BM_PXP_POWER_LUT_LP_STATE_WAY1_BANKN)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY0_BANKN	  3
+#define BM_PXP_POWER_LUT_LP_STATE_WAY0_BANKN 0x00000038
+#define BF_PXP_POWER_LUT_LP_STATE_WAY0_BANKN(v)  \
+	(((v) << 3) & BM_PXP_POWER_LUT_LP_STATE_WAY0_BANKN)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY0_BANK0	  0
+#define BM_PXP_POWER_LUT_LP_STATE_WAY0_BANK0 0x00000007
+#define BF_PXP_POWER_LUT_LP_STATE_WAY0_BANK0(v)  \
+	(((v) << 0) & BM_PXP_POWER_LUT_LP_STATE_WAY0_BANK0)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__SD   0x4
+
+#define HW_PXP_NEXT	(0x00000400)
+
+#define BP_PXP_NEXT_POINTER	 2
+#define BM_PXP_NEXT_POINTER 0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+	(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD 0x00000002
+#define BM_PXP_NEXT_ENABLED 0x00000001
+
+#define HW_PXP_DEBUGCTRL	(0x00000410)
+
+#define BP_PXP_DEBUGCTRL_RSVD	   12
+#define BM_PXP_DEBUGCTRL_RSVD 0xFFFFF000
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+	(((v) << 12) & BM_PXP_DEBUGCTRL_RSVD)
+#define BP_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT      8
+#define BM_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT 0x00000F00
+#define BF_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT(v)  \
+	(((v) << 8) & BM_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT)
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__MISS_CNT 0x1
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__HIT_CNT  0x2
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__LAT_CNT  0x4
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__MAX_LAT  0x8
+#define BP_PXP_DEBUGCTRL_SELECT      0
+#define BM_PXP_DEBUGCTRL_SELECT 0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+	(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE	     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL	     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__PSBUF	     0x2
+#define BV_PXP_DEBUGCTRL_SELECT__PSBAX	     0x3
+#define BV_PXP_DEBUGCTRL_SELECT__PSBAY	     0x4
+#define BV_PXP_DEBUGCTRL_SELECT__ASBUF	     0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION    0x6
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF0     0x7
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF1     0x8
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF2     0x9
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_STAT    0x10
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_MISS    0x11
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_HIT     0x12
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_LAT     0x13
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_MAX_LAT 0x14
+
+#define HW_PXP_DEBUG	(0x00000420)
+
+#define BP_PXP_DEBUG_DATA      0
+#define BM_PXP_DEBUG_DATA 0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)   (v)
+
+#define HW_PXP_VERSION	(0x00000430)
+
+#define BP_PXP_VERSION_MAJOR	  24
+#define BM_PXP_VERSION_MAJOR 0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR	  16
+#define BM_PXP_VERSION_MINOR 0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP	 0
+#define BM_PXP_VERSION_STEP 0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)	\
+	(((v) << 0) & BM_PXP_VERSION_STEP)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex b/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex
index b969928..2e561f0 100644
--- a/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex
+++ b/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex
@@ -1,5 +1,5 @@
 :1000000053444D4101000000010000001C000000AD
-:1000100025000000B000000078050000820200000A
+:1000100026000000B40000007A0600008202000002
 :10002000FFFFFFFF00000000FFFFFFFFFFFFFFFFDC
 :10003000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD0
 :10004000FFFFFFFFFFFFFFFF6A1A0000FFFFFFFF38
@@ -9,92 +9,108 @@
 :10008000FFFFFFFFFFFFFFFF4C0400006E040000B6
 :10009000FFFFFFFF00180000FFFFFFFFFFFFFFFF54
 :1000A000000000000018000062180000161A00008E
-:1000B000E3C1DB57E35FE357F352016A8F00D500DA
-:1000C000017D8D00A005EB5D7804037D79042C7D16
-:1000D000367C79041F7CEE56000F6006057D0965AD
-:1000E000437E0A62417E20980A623E7E09653C7E1C
-:1000F00012051205AD026007037DFB55D36D2B98E9
-:10010000FB55041DD36DC86A2F7F011F03200048D3
-:10011000E47C5398FB55D76D150005780962C86AD1
-:100120000962C86AD76D5298FB55D76D1500150046
-:1001300005780A62C86A0A62C86AD76D5298FB5588
-:10014000D76D15001500150005780B62C86A0B62A3
-:10015000C86AD76D097CDF6D077F0000EB55004D45
-:10016000077DFAC1E35706980700CC680C6813C2F4
-:100170000AC20398D9C1E3C1DB57E35FE357F352E7
-:10018000216A8F00D500017D8D00A005EB5DFB5637
-:100190007804037D79042A7D317C7904207C700BFE
-:1001A0001103EB53000F6003057D0965377E0A627A
-:1001B000357E86980A62327E0965307E1205120508
-:1001C000AD026007027C065A8E98265A277F011FCF
-:1001D00003200048E87C700B11031353AF981500FF
-:1001E00004780962065A0962265AAE98150015006D
-:1001F00004780A62065A0A62265AAE98150015005B
-:10020000150004780B62065A0B62265A077C000020
-:10021000EB55004D067DFAC1E357699807000C685D
-:1002200013C20AC26698700B110313536C07017C4A
-:10023000D9C1FB5E8A066B07017CD9C1F35EDB592D
-:10024000D3588F0110010F398B003CC12B7DC05A50
-:10025000C85B4EC1277C88038906E35CFF0D11054E
-:10026000FF1DBC053E07004D187D700811007E077C
-:10027000097D7D07027D2852E698F852DB54BC02C6
-:10028000CC02097C7C07027D2852EF98F852D354A7
-:10029000BC02CC02097D0004DD988B00C052C8531B
-:1002A00059C1D67D0002CD98FF08BF007F07157D9C
-:1002B0008804D500017D8D00A005EB5D8F02120240
-:1002C0001202FF3ADA05027C3E071899A402DD0209
-:1002D000027D3E0718995E071899EB559805EB5D6E
-:1002E000F352FB546A07267D6C07017D55996B0715
-:1002F000577C6907047D6807027D010E2F9993588A
-:10030000D600017D8E009355A005935DA00602786E
-:100310000255045D1D7C004E087C6907037D025573
-:10032000177E3C99045D147F890693500048017D37
-:100330002799A099150006780255045D4F070255CC
-:10034000245D2F07017CA09917006F07017C012015
-:1003500093559D000700A7D9F598D36C6907047DD4
-:100360006807027D010E64999358D600017D8E00C6
-:100370009355A005935DA00602780255C86D0F7CC9
-:10038000004E087C6907037D0255097E7199C86D8E
-:10039000067F890693500048017D5C99A0999A993F
-:1003A000C36A6907047D6807027D010E8799935827
-:1003B000D600017D8E009355A005935DA0060278BE
-:1003C000C865045D0F7C004E087C6907037DC86525
-:1003D000097E9499045D067F890693500048017D4B
-:1003E0007F99A09993559D000700FF6CA7D9F598B8
-:1003F0000000E354EB55004D017CF598DD98E35483
-:10040000EB55FF0A1102FF1A7F07027CA005B49981
-:100410009D008C05BA05A0051002BA04AD04540471
-:100420000600E3C1DB57FB52C36AF352056A8F0033
-:10043000D500017D8D00A005EB5D7804037D790476
-:100440002B7D1E7C7904337CEE56000FFB55600734
-:10045000027DC36DD599041DC36DC8623B7E6006E5
-:10046000027D10021202096A357F1202096A327F88
-:100470001202096A2F7F011F03200048E77C099AB6
-:10048000FB55C76D1500150015000578C8620B6A8D
-:10049000C8620B6AC76D089AFB55C76D1500150039
-:1004A0000578C8620A6AC8620A6AC76D089AFB556D
-:1004B000C76D15000578C862096AC862096AC76D08
-:1004C000097C286A077F0000EB55004D057DFAC1C5
-:1004D000DB57BF9977C254040AC2BA99D9C1E3C1A4
-:1004E000DB57F352056A8F00D500017D8D00A00512
-:1004F000FB567804037D7904297D1F7C79042E7CCA
-:10050000E35D700D1105ED55000F6007027D065289
-:10051000329A2652337E6005027D10021202096A69
-:100520002D7F1202096A2A7F1202096A277F011FA2
-:1005300003200048EA7CE3555D9A1500150015007C
-:10054000047806520B6A26520B6A5C9A1500150055
-:10055000047806520A6A26520A6A5C9A15000478E0
-:100560000652096A2652096A097C286A077F000038
-:10057000DB57004D057DFAC1DB571B9A77C2540447
-:100580000AC2189AE3C1DB57F352056AFB568E0282
-:10059000941AC36AC8626902247D941EC36ED36E26
-:1005A000C8624802C86A9426981EC36ED36EC86299
-:1005B0004C02C86A9826C36E981EC36EC8629826FD
-:1005C000C36E6002097CC8626E02247D096A1E7FC8
-:1005D0000125004D257D849A286A187F04627AC21D
-:1005E000B89AE36E8F00D805017D8D00A005C86222
-:1005F0006E02107D096A0A7F0120F97C286A067F55
-:100600000000004D0D7DFAC1DB576E9A07000462B1
-:100610000C6AB59A286AFA7F04627AC258045404B4
-:08062000286AF47F0AC26B9AFC
+:1000B000061B0000E3C1DB57E35FE357F352016A1D
+:1000C0008F00D500017D8D00A005EB5D7804037DD8
+:1000D00079042C7D367C79041F7CEE56000F600677
+:1000E000057D0965437E0A62417E20980A623E7E54
+:1000F00009653C7E12051205AD026007037DFB55C4
+:10010000D36D2B98FB55041DD36DC86A2F7F011F3B
+:1001100003200048E47C5398FB55D76D1500057803
+:100120000962C86A0962C86AD76D5298FB55D76DD3
+:100130001500150005780A62C86A0A62C86AD76D98
+:100140005298FB55D76D15001500150005780B6208
+:10015000C86A0B62C86AD76D097CDF6D077F000033
+:10016000EB55004D077DFAC1E35706980700CC68B0
+:100170000C6813C20AC20398D9C1E3C1DB57E35F1D
+:10018000E357F352216A8F00D500017D8D00A00551
+:10019000EB5DFB567804037D79042A7D317C79047C
+:1001A000207C700B1103EB53000F6003057D096584
+:1001B000377E0A62357E86980A62327E0965307E15
+:1001C00012051205AD026007027C065A8E98265A67
+:1001D000277F011F03200048E87C700B1103135395
+:1001E000AF98150004780962065A0962265AAE983B
+:1001F0001500150004780A62065A0A62265AAE985B
+:1002000015001500150004780B62065A0B62265A79
+:10021000077C0000EB55004D067DFAC1E357699855
+:1002200007000C6813C20AC26698700B11031353BF
+:100230006C07017CD9C1FB5E8A066B07017CD9C1C2
+:10024000F35EDB59D3588F0110010F398B003CC18D
+:100250002B7DC05AC85B4EC1277C88038906E35CAE
+:10026000FF0D1105FF1DBC053E07004D187D7008F0
+:1002700011007E07097D7D07027D2852E698F8521D
+:10028000DB54BC02CC02097C7C07027D2852EF982B
+:10029000F852D354BC02CC02097D0004DD988B00D7
+:1002A000C052C85359C1D67D0002CD98FF08BF0087
+:1002B0007F07157D8804D500017D8D00A005EB5DCD
+:1002C0008F0212021202FF3ADA05027C3E071899E9
+:1002D000A402DD02027D3E0718995E071899EB55CE
+:1002E0009805EB5DF352FB546A07267D6C07017D90
+:1002F00055996B07577C6907047D6807027D010EDD
+:100300002F999358D600017D8E009355A005935DDB
+:10031000A00602780255045D1D7C004E087C69072A
+:10032000037D0255177E3C99045D147F8906935026
+:100330000048017D2799A099150006780255045DB3
+:100340004F070255245D2F07017CA09917006F0706
+:10035000017C012093559D000700A7D9F598D36C27
+:100360006907047D6807027D010E64999358D600E1
+:10037000017D8E009355A005935DA006027802557D
+:10038000C86D0F7C004E087C6907037D0255097E0D
+:100390007199C86D067F890693500048017D5C996C
+:1003A000A0999A99C36A6907047D6807027D010EC6
+:1003B00087999358D600017D8E009355A005935DD3
+:1003C000A0060278C865045D0F7C004E087C6907B2
+:1003D000037DC865097E9499045D067F8906935064
+:1003E0000048017D7F99A09993559D000700FF6CFF
+:1003F000A7D9F5980000E354EB55004D017CF59822
+:10040000DD98E354EB55FF0A1102FF1A7F07027CC7
+:10041000A005B4999D008C05BA05A0051002BA0488
+:10042000AD0454040600E3C1DB57FB52C36AF35228
+:10043000056A8F00D500017D8D00A005EB5D780475
+:10044000037D79042B7D1E7C7904337CEE56000FEE
+:10045000FB556007027DC36DD599041DC36DC8624D
+:100460003B7E6006027D10021202096A357F12028D
+:10047000096A327F1202096A2F7F011F0320004898
+:10048000E77C099AFB55C76D150015001500057826
+:10049000C8620B6AC8620B6AC76D089AFB55C76DC4
+:1004A000150015000578C8620A6AC8620A6AC76D35
+:1004B000089AFB55C76D15000578C862096AC862BD
+:1004C000096AC76D097C286A077F0000EB55004D5B
+:1004D000057DFAC1DB57BF9977C254040AC2BA99A5
+:1004E000D9C1E3C1DB57F352056A8F00D500017D06
+:1004F0008D00A005FB567804037D7904297D1F7CBF
+:1005000079042E7CE35D700D1105ED55000F600739
+:10051000027D0652329A2652337E6005027D100219
+:100520001202096A2D7F1202096A2A7F1202096AE1
+:10053000277F011F03200048EA7CE3555D9A1500E0
+:1005400015001500047806520B6A26520B6A5C9A55
+:1005500015001500047806520A6A26520A6A5C9A47
+:10056000150004780652096A2652096A097C286A2D
+:10057000077F0000DB57004D057DFAC1DB571B9A52
+:1005800077C254040AC2189AE3C1DB57F352056AD2
+:10059000FB568E02941AC36AC8626902247D941EB7
+:1005A000C36ED36EC8624802C86A9426981EC36E92
+:1005B000D36EC8624C02C86A9826C36E981EC36E7A
+:1005C000C8629826C36E6002097CC8626E02247DF0
+:1005D000096A1E7F0125004D257D849A286A187FAF
+:1005E00004627AC2B89AE36E8F00D805017D8D004F
+:1005F000A005C8626E02107D096A0A7F0120F97C9D
+:10060000286A067F0000004D0D7DFAC1DB576E9A07
+:10061000070004620C6AB59A286AFA7F04627AC2FB
+:1006200058045404286AF47F0AC26B9AD9C1E3C102
+:10063000DB57F352056AFB568E02941A0252690286
+:100640001D7D941E06524802065A9426981E065294
+:100650004C02065A9826981E065260020A7C98267A
+:1006600006526E02237D096A1D7F0125004D247DFF
+:10067000D19A286A177F04627AC2029B8F00D8053C
+:10068000017D8D00A00506526E02107D096A0A7F69
+:100690000120F97C286A067F0000004D0D7DFAC11B
+:1006A000DB57C19A070004620C6AFF9A286AFA7F36
+:1006B00004627AC258045404286AF47F0AC2BE9ABB
+:1006C000016E0B612F7E0B622D7E0B632B7E0C0D5A
+:1006D0001704170417049D04081DCC05017C0C0D9C
+:1006E000D16A000F4207C86FDD6F1C7F8E009D002E
+:1006F00001680B67177ED56B04080278C86F120774
+:10070000117C0B670F7E04080278C86F12070A7C01
+:10071000DD6F087FD169010FC86FDD6F037F0101B5
+:0E0720000004129B0700FF680C680002129B89
 :00000001FF
-- 
1.7.5.4

