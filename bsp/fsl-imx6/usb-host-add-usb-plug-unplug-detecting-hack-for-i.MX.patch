From 943165c3db3d72e491813606e04beeb1ce3919be Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 19 Sep 2012 13:26:14 +0800
Subject: [PATCH 5/7] usb: host: add usb plug/unplug detecting hack for i.MX6

The usb host controller on the i.MX6 has plug/unplug detecting bug,
we need modify hcd driver to fix this hardware bug.

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/core/hub.c      | 59 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/ehci-hub.c | 21 ++++++++++++++++
 2 files changed, 80 insertions(+)

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 1481e52..9ea4a3b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -31,6 +31,11 @@
 
 #include "usb.h"
 
+#ifdef CONFIG_ARCH_MX6
+#define MX6_USB_HOST_HACK
+#include <linux/fsl_devices.h>
+#endif
+
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -2833,6 +2838,16 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 		msleep(25);
 
+#ifdef MX6_USB_HOST_HACK
+		if (hub->hdev->parent == NULL) {
+			struct usb_device *hdev = hub->hdev;
+			struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+			struct fsl_usb2_platform_data *pdata;
+			pdata = hcd->self.controller->platform_data;
+			if (pdata && pdata->platform_rh_resume)
+				pdata->platform_rh_resume(pdata);
+		}
+#endif
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
 		 * sequence.
@@ -2844,6 +2859,16 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	}
 
  SuspendCleared:
+#ifdef MX6_USB_HOST_HACK
+	if (hub->hdev->parent == NULL) {
+		struct usb_device *hdev = hub->hdev;
+		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+		struct fsl_usb2_platform_data *pdata;
+		pdata = hcd->self.controller->platform_data;
+		if (pdata && pdata->platform_rh_resume)
+			pdata->platform_rh_resume(pdata);
+	}
+#endif
 	if (status == 0) {
 		if (hub_is_superspeed(hub->hdev)) {
 			if (portchange & USB_PORT_STAT_C_LINK_STATE)
@@ -3330,6 +3355,21 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 			break;
 		}
 	}
+
+#ifdef MX6_USB_HOST_HACK
+	{	/*Must enable HOSTDISCONDETECT after second reset*/
+		if ((port1 == 1) && (udev->level == 1)) {
+			if (udev->speed == USB_SPEED_HIGH) {
+				struct device *dev = hcd->self.controller;
+				struct fsl_usb2_platform_data *pdata;
+				pdata = (struct fsl_usb2_platform_data *)
+					 dev->platform_data;
+				if (pdata && pdata->platform_set_disconnect_det)
+					pdata->platform_set_disconnect_det(pdata, 1);
+			}
+		}
+	}
+#endif
 	if (retval)
 		goto fail;
 
@@ -3532,6 +3572,25 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_disconnect(&hdev->children[port1-1]);
 	clear_bit(port1, hub->change_bits);
 
+#ifdef MX6_USB_HOST_HACK
+	{
+		struct device *dev = hcd->self.controller;
+		struct fsl_usb2_platform_data *pdata;
+
+		pdata = (struct fsl_usb2_platform_data *)dev->platform_data;
+		if (dev->parent && (hdev->level == 0) && dev->type) {
+			if (port1 == 1 && pdata && pdata->init)
+				pdata->init(NULL);
+		}
+		if ((port1 == 1) && (hdev->level == 0)) {
+			/* Must clear HOSTDISCONDETECT when port connect change happen*/
+			if (pdata && pdata->platform_set_disconnect_det)
+				pdata->platform_set_disconnect_det(pdata, 0);
+
+		}
+	}
+#endif
+
 	/* We can forget about a "removed" device when there's a physical
 	 * disconnect or the connect status changes.
 	 */
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3cb52a9..d7f5b6a 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -29,6 +29,11 @@
 /*-------------------------------------------------------------------------*/
 #include <linux/usb/otg.h>
 
+#ifdef CONFIG_ARCH_MX6
+#define MX6_USB_HOST_HACK
+#include <linux/fsl_devices.h>
+#endif
+
 #define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
 
 #ifdef	CONFIG_PM
@@ -420,6 +425,14 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		spin_unlock_irq(&ehci->lock);
 		msleep(20);
 		spin_lock_irq(&ehci->lock);
+#ifdef MX6_USB_HOST_HACK
+		{
+			struct fsl_usb2_platform_data *pdata;
+			pdata = hcd->self.controller->platform_data;
+			if (pdata && pdata->platform_rh_resume)
+				pdata->platform_rh_resume(pdata);
+		}
+#endif
 	}
 
 	i = HCS_N_PORTS (ehci->hcs_params);
@@ -990,6 +1003,14 @@ static int ehci_hub_control (
 			temp &= ~PORT_WKCONN_E;
 			temp |= PORT_WKDISC_E | PORT_WKOC_E;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+#ifdef MX6_USB_HOST_HACK
+			{
+				struct fsl_usb2_platform_data *pdata;
+				pdata = hcd->self.controller->platform_data;
+				if (pdata && pdata->platform_rh_suspend)
+					pdata->platform_rh_suspend(pdata);
+			}
+#endif
 			if (hostpc_reg) {
 				spin_unlock_irqrestore(&ehci->lock, flags);
 				msleep(5);/* 5ms for HCD enter low pwr mode */
-- 
1.7.11

