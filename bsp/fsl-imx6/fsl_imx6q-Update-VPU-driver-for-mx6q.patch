From fd596e08bcff689158085d08993024bf31af61a8 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 19 Jul 2013 09:40:19 +0800
Subject: [PATCH 15/38] fsl_imx6q: Update VPU driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mxc/vpu/Kconfig   |    9 +
 drivers/mxc/vpu/mxc_vpu.c |  361 ++++++++++++++++++++++++++++++++++-----------
 2 files changed, 285 insertions(+), 85 deletions(-)

diff --git a/drivers/mxc/vpu/Kconfig b/drivers/mxc/vpu/Kconfig
index dada204..6562697 100644
--- a/drivers/mxc/vpu/Kconfig
+++ b/drivers/mxc/vpu/Kconfig
@@ -19,4 +19,13 @@ config MXC_VPU_DEBUG
 	  This is an option for the developers; most people should
 	  say N here.  This enables MXC VPU driver debugging.
 
+config MX6_VPU_352M
+	bool "MX6 VPU 352M"
+	depends on MXC_VPU
+	default n
+	help
+	 Increase VPU frequncy to 352M, the config will disable bus frequency
+	 adjust dynamic, and CPU lowest setpoint will be 352Mhz.
+	 This config is used for special VPU use case.
+
 endmenu
diff --git a/drivers/mxc/vpu/mxc_vpu.c b/drivers/mxc/vpu/mxc_vpu.c
index 6546385..eea6b2d 100644
--- a/drivers/mxc/vpu/mxc_vpu.c
+++ b/drivers/mxc/vpu/mxc_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -19,8 +19,8 @@
  * @ingroup VPU
  */
 
-#include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
@@ -40,6 +40,13 @@
 #include <linux/workqueue.h>
 #include <linux/sched.h>
 #include <linux/vmalloc.h>
+#include <linux/regulator/consumer.h>
+#include <linux/page-flags.h>
+#include <linux/mm_types.h>
+#include <linux/types.h>
+#include <linux/memblock.h>
+#include <linux/memory.h>
+#include <asm/page.h>
 #include <asm/sizes.h>
 #include <mach/clock.h>
 #include <mach/hardware.h>
@@ -85,6 +92,7 @@ static struct vpu_mem_desc vshare_mem = { 0 };
 static void __iomem *vpu_base;
 static int vpu_ipi_irq;
 static u32 phy_vpu_base_addr;
+static phys_addr_t top_address_DRAM;
 static struct mxc_vpu_platform_data *vpu_plat;
 
 /* IRAM setting */
@@ -104,6 +112,8 @@ static int vpu_jpu_irq;
 #endif
 
 static unsigned int regBk[64];
+static struct regulator *vpu_regulator;
+static unsigned int pc_before_suspend;
 
 #define	READ_REG(x)		__raw_readl(vpu_base + x)
 #define	WRITE_REG(val, x)	__raw_writel(val, vpu_base + x)
@@ -174,7 +184,6 @@ static inline void vpu_worker_callback(struct work_struct *w)
 	 * codec is done.
 	 */
 	if (codec_done) {
-		clk_disable(vpu_clk);
 		codec_done = 0;
 	}
 
@@ -219,14 +228,42 @@ static irqreturn_t vpu_jpu_irq_handler(int irq, void *dev_id)
 #endif
 
 /*!
+ * @brief check phy memory prepare to pass to vpu is valid or not, we
+ * already address some issue that if pass a wrong address to vpu
+ * (like virtual address), system will hang.
+ *
+ * @return true return is a valid phy memory address, false return not.
+ */
+bool vpu_is_valid_phy_memory(u32 paddr)
+{
+	if (paddr > top_address_DRAM)
+		return false;
+
+	return true;
+}
+
+/*!
  * @brief open function for vpu file operation
  *
  * @return  0 on success or negative error code on error
  */
 static int vpu_open(struct inode *inode, struct file *filp)
 {
+
 	mutex_lock(&vpu_data.lock);
-	open_count++;
+
+	if (open_count++ == 0) {
+		if (!IS_ERR(vpu_regulator))
+			regulator_enable(vpu_regulator);
+
+#ifdef CONFIG_SOC_IMX6Q
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC))
+			printk(KERN_DEBUG "Not power off before vpu open!\n");
+		clk_disable(vpu_clk);
+#endif
+	}
+
 	filp->private_data = (void *)(&vpu_data);
 	mutex_unlock(&vpu_data.lock);
 	return 0;
@@ -467,9 +504,35 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
 		break;
 	case VPU_IOC_PHYMEM_DUMP:
 		break;
+	case VPU_IOC_PHYMEM_CHECK:
+	{
+		struct vpu_mem_desc check_memory;
+		ret = copy_from_user(&check_memory,
+				     (void __user *)arg,
+				     sizeof(struct vpu_mem_desc));
+		if (ret != 0) {
+			printk(KERN_ERR "copy from user failure:%d\n", ret);
+			ret = -EFAULT;
+			break;
+		}
+		ret = vpu_is_valid_phy_memory((u32)check_memory.phy_addr);
+
+		pr_debug("vpu: memory phy:0x%x %s phy memory\n",
+		       check_memory.phy_addr, (ret ? "is" : "isn't"));
+		/* borrow .size to pass back the result. */
+		check_memory.size = ret;
+		ret = copy_to_user((void __user *)arg, &check_memory,
+				   sizeof(struct vpu_mem_desc));
+		if (ret) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+	}
 	default:
 		{
 			printk(KERN_ERR "No such IOCTL, cmd is %d\n", cmd);
+			ret = -EINVAL;
 			break;
 		}
 	}
@@ -482,8 +545,70 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
  */
 static int vpu_release(struct inode *inode, struct file *filp)
 {
+	int i;
+	unsigned long timeout;
+
 	mutex_lock(&vpu_data.lock);
+
 	if (open_count > 0 && !(--open_count)) {
+
+		/* Wait for vpu go to idle state */
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC)) {
+
+			timeout = jiffies + HZ;
+			while (READ_REG(BIT_BUSY_FLAG)) {
+				msleep(1);
+				if (time_after(jiffies, timeout)) {
+					printk(KERN_WARNING "VPU timeout during release\n");
+					break;
+				}
+			}
+			clk_disable(vpu_clk);
+
+			/* Clean up interrupt */
+			cancel_work_sync(&vpu_data.work);
+			flush_workqueue(vpu_data.workqueue);
+			irq_status = 0;
+
+			clk_enable(vpu_clk);
+			if (READ_REG(BIT_BUSY_FLAG)) {
+
+				if (cpu_is_mx51() || cpu_is_mx53()) {
+					printk(KERN_ERR
+						"fatal error: can't gate/power off when VPU is busy\n");
+					clk_disable(vpu_clk);
+					mutex_unlock(&vpu_data.lock);
+					return -EFAULT;
+				}
+
+#ifdef CONFIG_SOC_IMX6Q
+				if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+					WRITE_REG(0x11, 0x10F0);
+					timeout = jiffies + HZ;
+					while (READ_REG(0x10F4) != 0x77) {
+						msleep(1);
+						if (time_after(jiffies, timeout))
+							break;
+					}
+
+					if (READ_REG(0x10F4) != 0x77) {
+						printk(KERN_ERR
+							"fatal error: can't gate/power off when VPU is busy\n");
+						WRITE_REG(0x0, 0x10F0);
+						clk_disable(vpu_clk);
+						mutex_unlock(&vpu_data.lock);
+						return -EFAULT;
+					} else {
+						if (vpu_plat->reset)
+							vpu_plat->reset();
+					}
+				}
+#endif
+			}
+		}
+		clk_disable(vpu_clk);
+
 		vpu_free_buffers();
 
 		/* Free shared memory when vpu device is idle */
@@ -491,6 +616,14 @@ static int vpu_release(struct inode *inode, struct file *filp)
 		share_mem.cpu_addr = 0;
 		vfree((void *)vshare_mem.cpu_addr);
 		vshare_mem.cpu_addr = 0;
+
+		vpu_clk_usercount = clk_get_usecount(vpu_clk);
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_disable(vpu_clk);
+
+		if (!IS_ERR(vpu_regulator))
+			regulator_disable(vpu_regulator);
+
 	}
 	mutex_unlock(&vpu_data.lock);
 
@@ -658,6 +791,19 @@ static int vpu_dev_probe(struct platform_device *pdev)
 			  (void *)(&vpu_data));
 	if (err)
 		goto err_out_class;
+	vpu_regulator = regulator_get(NULL, "cpu_vddvpu");
+	if (IS_ERR(vpu_regulator)) {
+		if (!(cpu_is_mx51() || cpu_is_mx53())) {
+			printk(KERN_ERR
+				"%s: failed to get vpu regulator\n", __func__);
+			goto err_out_class;
+		} else {
+			/* regulator_get will return error on MX5x,
+			 * just igore it everywhere*/
+			printk(KERN_WARNING
+				"%s: failed to get vpu regulator\n", __func__);
+		}
+	}
 
 #ifdef MXC_VPU_HAS_JPU
 	vpu_jpu_irq = platform_get_irq_byname(pdev, "vpu_jpu_irq");
@@ -705,7 +851,8 @@ static int vpu_dev_remove(struct platform_device *pdev)
 	iounmap(vpu_base);
 	if (vpu_plat && vpu_plat->iram_enable && vpu_plat->iram_size)
 		iram_free(iram.start,  vpu_plat->iram_size);
-
+	if (!IS_ERR(vpu_regulator))
+		regulator_put(vpu_regulator);
 	return 0;
 }
 
@@ -715,114 +862,154 @@ static int vpu_suspend(struct platform_device *pdev, pm_message_t state)
 	int i;
 	unsigned long timeout;
 
-	/* Wait for vpu go to idle state, suspect vpu cannot be changed
-	   to idle state after about 1 sec */
-	if (open_count > 0) {
+	mutex_lock(&vpu_data.lock);
+	if (open_count == 0) {
+		/* VPU is released (all instances are freed),
+		 * clock is already off, context is no longer needed,
+		 * power is already off on MX6,
+		 * gate power on MX51 */
+		if (cpu_is_mx51()) {
+			if (vpu_plat->pg)
+				vpu_plat->pg(1);
+		}
+	} else {
+		/* Wait for vpu go to idle state, suspect vpu cannot be changed
+		   to idle state after about 1 sec */
 		timeout = jiffies + HZ;
 		clk_enable(vpu_clk);
 		while (READ_REG(BIT_BUSY_FLAG)) {
 			msleep(1);
-			if (time_after(jiffies, timeout))
-				goto out;
+			if (time_after(jiffies, timeout)) {
+				clk_disable(vpu_clk);
+				mutex_unlock(&vpu_data.lock);
+				return -EAGAIN;
+			}
 		}
 		clk_disable(vpu_clk);
-	}
-
-	/* Make sure clock is disabled before suspend */
-	vpu_clk_usercount = clk_get_usecount(vpu_clk);
-	for (i = 0; i < vpu_clk_usercount; i++)
-		clk_disable(vpu_clk);
 
-	if (cpu_is_mx53())
-		return 0;
+		/* Make sure clock is disabled before suspend */
+		vpu_clk_usercount = clk_get_usecount(vpu_clk);
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_disable(vpu_clk);
 
-	if (bitwork_mem.cpu_addr != 0) {
-		clk_enable(vpu_clk);
-		/* Save 64 registers from BIT_CODE_BUF_ADDR */
-		for (i = 0; i < 64; i++)
-			regBk[i] = READ_REG(BIT_CODE_BUF_ADDR + (i * 4));
-		clk_disable(vpu_clk);
-	}
+		if (cpu_is_mx53()) {
+			mutex_unlock(&vpu_data.lock);
+			return 0;
+		}
 
-	if (vpu_plat->pg)
-		vpu_plat->pg(1);
+		if (bitwork_mem.cpu_addr != 0) {
+			clk_enable(vpu_clk);
+			/* Save 64 registers from BIT_CODE_BUF_ADDR */
+			for (i = 0; i < 64; i++)
+				regBk[i] = READ_REG(BIT_CODE_BUF_ADDR + (i * 4));
+			pc_before_suspend = READ_REG(BIT_CUR_PC);
+			clk_disable(vpu_clk);
+		}
 
-	return 0;
+		if (vpu_plat->pg)
+			vpu_plat->pg(1);
 
-out:
-	clk_disable(vpu_clk);
-	return -EAGAIN;
+		/* If VPU is working before suspend, disable
+		 * regulator to make usecount right. */
+		if (!IS_ERR(vpu_regulator))
+			regulator_disable(vpu_regulator);
+	}
 
+	mutex_unlock(&vpu_data.lock);
+	return 0;
 }
 
 static int vpu_resume(struct platform_device *pdev)
 {
 	int i;
 
-	if (cpu_is_mx53())
-		goto recover_clk;
+	mutex_lock(&vpu_data.lock);
+	if (open_count == 0) {
+		/* VPU is released (all instances are freed),
+		 * clock should be kept off, context is no longer needed,
+		 * power should be kept off on MX6,
+		 * disable power gating on MX51 */
+		if (cpu_is_mx51()) {
+			if (vpu_plat->pg)
+				vpu_plat->pg(0);
+		}
+	} else {
+		if (cpu_is_mx53())
+			goto recover_clk;
 
-	if (vpu_plat->pg)
-		vpu_plat->pg(0);
+		/* If VPU is working before suspend, enable
+		 * regulator to make usecount right. */
+		if (!IS_ERR(vpu_regulator))
+			regulator_enable(vpu_regulator);
 
-	if (bitwork_mem.cpu_addr != 0) {
-		u32 *p = (u32 *) bitwork_mem.cpu_addr;
-		u32 data, pc;
-		u16 data_hi;
-		u16 data_lo;
+		if (vpu_plat->pg)
+			vpu_plat->pg(0);
 
-		clk_enable(vpu_clk);
+		if (bitwork_mem.cpu_addr != 0) {
+			u32 *p = (u32 *) bitwork_mem.cpu_addr;
+			u32 data, pc;
+			u16 data_hi;
+			u16 data_lo;
 
-		/* reset VPU in case of voltage change */
-		if (vpu_plat->reset)
-			vpu_plat->reset();
+			clk_enable(vpu_clk);
 
-		pc = READ_REG(BIT_CUR_PC);
-		if (pc) {
-			clk_disable(vpu_clk);
-			goto recover_clk;
-		}
+			pc = READ_REG(BIT_CUR_PC);
+			if (pc) {
+				printk(KERN_WARNING "Not power off after suspend (PC=0x%x)\n", pc);
+				clk_disable(vpu_clk);
+				goto recover_clk;
+			}
 
-		/* Restore registers */
-		for (i = 0; i < 64; i++)
-			WRITE_REG(regBk[i], BIT_CODE_BUF_ADDR + (i * 4));
-
-		WRITE_REG(0x0, BIT_RESET_CTRL);
-		WRITE_REG(0x0, BIT_CODE_RUN);
-
-		/*
-		 * Re-load boot code, from the codebuffer in external RAM.
-		 * Thankfully, we only need 4096 bytes, same for all platforms.
-		 */
-		for (i = 0; i < 2048; i += 4) {
-			data = p[(i / 2) + 1];
-			data_hi = (data >> 16) & 0xFFFF;
-			data_lo = data & 0xFFFF;
-			WRITE_REG((i << 16) | data_hi, BIT_CODE_DOWN);
-			WRITE_REG(((i + 1) << 16) | data_lo,
-				  BIT_CODE_DOWN);
-
-			data = p[i / 2];
-			data_hi = (data >> 16) & 0xFFFF;
-			data_lo = data & 0xFFFF;
-			WRITE_REG(((i + 2) << 16) | data_hi,
-				  BIT_CODE_DOWN);
-			WRITE_REG(((i + 3) << 16) | data_lo,
-				  BIT_CODE_DOWN);
-		}
+			/* Restore registers */
+			for (i = 0; i < 64; i++)
+				WRITE_REG(regBk[i], BIT_CODE_BUF_ADDR + (i * 4));
 
-		WRITE_REG(0x1, BIT_BUSY_FLAG);
-		WRITE_REG(0x1, BIT_CODE_RUN);
-		while (READ_REG(BIT_BUSY_FLAG))
-			;
-		clk_disable(vpu_clk);
-	}
+			WRITE_REG(0x0, BIT_RESET_CTRL);
+			WRITE_REG(0x0, BIT_CODE_RUN);
+			/* MX6 RTL has a bug not to init MBC_SET_SUBBLK_EN on reset */
+#ifdef CONFIG_SOC_IMX6Q
+			WRITE_REG(0x0, MBC_SET_SUBBLK_EN);
+#endif
+
+			/*
+			 * Re-load boot code, from the codebuffer in external RAM.
+			 * Thankfully, we only need 4096 bytes, same for all platforms.
+			 */
+			for (i = 0; i < 2048; i += 4) {
+				data = p[(i / 2) + 1];
+				data_hi = (data >> 16) & 0xFFFF;
+				data_lo = data & 0xFFFF;
+				WRITE_REG((i << 16) | data_hi, BIT_CODE_DOWN);
+				WRITE_REG(((i + 1) << 16) | data_lo,
+						BIT_CODE_DOWN);
+
+				data = p[i / 2];
+				data_hi = (data >> 16) & 0xFFFF;
+				data_lo = data & 0xFFFF;
+				WRITE_REG(((i + 2) << 16) | data_hi,
+						BIT_CODE_DOWN);
+				WRITE_REG(((i + 3) << 16) | data_lo,
+						BIT_CODE_DOWN);
+			}
+
+			if (pc_before_suspend) {
+				WRITE_REG(0x1, BIT_BUSY_FLAG);
+				WRITE_REG(0x1, BIT_CODE_RUN);
+				while (READ_REG(BIT_BUSY_FLAG))
+					;
+			} else {
+				printk(KERN_WARNING "PC=0 before suspend\n");
+			}
+			clk_disable(vpu_clk);
+		}
 
 recover_clk:
-	/* Recover vpu clock */
-	for (i = 0; i < vpu_clk_usercount; i++)
-		clk_enable(vpu_clk);
+		/* Recover vpu clock */
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_enable(vpu_clk);
+	}
 
+	mutex_unlock(&vpu_data.lock);
 	return 0;
 }
 #else
@@ -849,6 +1036,10 @@ static int __init vpu_init(void)
 
 	init_waitqueue_head(&vpu_queue);
 
+
+	memblock_allow_resize();
+	top_address_DRAM = memblock_end_of_DRAM_with_reserved();
+
 	return ret;
 }
 
-- 
1.7.5.4

