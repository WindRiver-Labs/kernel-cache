From 9d317cfa84b609dd2bb88080a4164f5a9455d8d1 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Jun 2013 17:25:25 +0800
Subject: [PATCH 11/38] fsl_imx6q: Update IPU driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mxc/Kconfig                       |    1 +
 drivers/mxc/ipu3/ipu_calc_stripes_sizes.c |   44 ++--
 drivers/mxc/ipu3/ipu_capture.c            |   56 +++---
 drivers/mxc/ipu3/ipu_common.c             |  352 ++++++++++++++++-------------
 drivers/mxc/ipu3/ipu_device.c             |  260 ++++++++++++++++------
 drivers/mxc/ipu3/ipu_disp.c               |  128 +++++++----
 drivers/mxc/ipu3/ipu_ic.c                 |   33 ++-
 drivers/mxc/ipu3/ipu_param_mem.h          |   36 +++-
 drivers/mxc/ipu3/ipu_prv.h                |   16 +-
 drivers/mxc/ipu3/ipu_regs.h               |    5 +
 drivers/mxc/ipu3/vdoa.c                   |   48 +++-
 drivers/mxc/ipu3/vdoa.h                   |    2 +-
 include/linux/ipu.h                       |   12 +-
 13 files changed, 631 insertions(+), 362 deletions(-)

diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 89be5d7..bb15fa1 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -9,6 +9,7 @@ config MXC_IPU
 	depends on !ARCH_MX21
 	depends on !ARCH_MX27
 	depends on !ARCH_MX25
+	select MXC_IPU_V1 if !ARCH_MX37 && !ARCH_MX5 && !ARCH_MX6Q
 	select MXC_IPU_V3 if ARCH_MX37 || ARCH_MX5 || ARCH_MX6Q
 	select MXC_IPU_V3D if ARCH_MX37
 	select MXC_IPU_V3EX if ARCH_MX5
diff --git a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
index aa9fdaf..3a27195 100644
--- a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
+++ b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 
 #include <linux/module.h>
 #include <mach/ipu-v3.h>
-#include <asm/div64.h>
+#include <linux/math64.h>
 
 #define BPP_32 0
 #define BPP_16 3
@@ -30,21 +30,13 @@
 #define BPP_12 4
 #define BPP_18 2
 
-static u64 _do_div(u64 a, u32 b)
-{
-	u64 div;
-	div = a;
-	do_div(div, b);
-	return div;
-}
-
 static u32 truncate(u32 up, /* 0: down; else: up */
 					u64 a, /* must be non-negative */
 					u32 b)
 {
 	u32 d;
 	u64 div;
-	div = _do_div(a, b);
+	div = div_u64(a, b);
 	d = b * (div >> 32);
 	if (up && (a > (((u64)d) << 32)))
 		return d+b;
@@ -61,6 +53,7 @@ static unsigned int f_calc(unsigned int pfs, unsigned int bpp, unsigned int *wri
 	case IPU_PIX_FMT_YUV420P2:
 	case IPU_PIX_FMT_YUV420P:
 	case IPU_PIX_FMT_YVU420P:
+	case IPU_PIX_FMT_YUV444P:
 		f_calculated = 16;
 		break;
 
@@ -114,6 +107,7 @@ static unsigned int m_calc(unsigned int pfs)
 	case IPU_PIX_FMT_YVU422P:
 	case IPU_PIX_FMT_YUV422P:
 	case IPU_PIX_FMT_YVU420P:
+	case IPU_PIX_FMT_YUV444P:
 	case IPU_PIX_FMT_NV12:
 		m_calculated = 8;
 		break;
@@ -227,9 +221,9 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 	if ((input_frame_width < 4) || (output_frame_width < 4))
 		return 1;
 
-	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+	irr_opt = div_u64((((u64)(input_frame_width - 1)) << 32),
 			  (output_frame_width - 1));
-	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+	rr_opt = div_u64((((u64)(output_frame_width - 1)) << 32),
 			 (input_frame_width - 1));
 
 	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
@@ -263,7 +257,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 				output_frame_width >> 1;
 			left->input_column = 0;
 			left->output_column = 0;
-			div = _do_div(((((u64)irr_steps) << 32) *
+			div = div_u64(((((u64)irr_steps) << 32) *
 				       (right->input_width - 1)), (right->output_width - 1));
 			left->irr = right->irr = truncate(0, div, 1);
 		} else { /* with overlap */
@@ -273,7 +267,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* this is the maximal inw which allows the same resizing ratio */
 			/* in both stripes */
 			onw = truncate(1, (inw * rr_opt), output_f);
-			div = _do_div((((u64)(irr_steps * inw)) <<
+			div = div_u64((((u64)(irr_steps * inw)) <<
 				       32), onw);
 			left->irr = right->irr = truncate(0, div, 1);
 			left->output_width = right->output_width =
@@ -281,14 +275,14 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* These are valid assignments for output_width, */
 			/* assuming output_f is a multiple of output_m */
 			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
-			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+			div = (((u64)1) << 32) + div_u64(div, irr_steps);
 
 			left->input_width = right->input_width = truncate(1, div, input_m);
 
-			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+			div = div_u64((((u64)((right->output_width - 1) * right->irr)) <<
 				       32), irr_steps);
 			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
-			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 			left->input_column = truncate(0, div, input_f);
 
 
@@ -313,13 +307,13 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		/* in both stripes */
 		onw = truncate(1, inw * rr_opt, output_f);
 		do {
-			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 			left->irr = truncate(0, div, 1);
-			div = _do_div((((u64)(onw * left->irr)) << 32),
+			div = div_u64((((u64)(onw * left->irr)) << 32),
 				      irr_steps);
 			dinw = (((u64)inw) << 32) - div;
 
-			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+			div = div_u64((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
 				       32), irr_steps);
 
 			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
@@ -339,7 +333,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 
 		inw = inw_best;
 		onw = truncate(1, inw * rr_opt, output_f);
-		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 		left->irr = truncate(0, div, 1);
 
 		left->output_width = onw;
@@ -350,18 +344,18 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
 					      32, input_m);
 
-		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+		div = div_u64((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
 			       32), (right->output_width - 1));
 		right->irr = truncate(0, div, 1);
 		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
 		if (temp < right->irr)
 			right->irr = temp;
-		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+		div = div_u64(((u64)((right->output_width - 1) * right->irr) <<
 			       32), irr_steps);
 		difwr = (u64)(input_frame_width - 1 - inw) - div;
 
 
-		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 		left->input_column = truncate(0, div, input_f);
 
 		/* This splits the truncated input columns evenly */
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
index 4e32d43..c768d8b 100644
--- a/drivers/mxc/ipu3/ipu_capture.c
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,7 +20,6 @@
  */
 #include <linux/types.h>
 #include <linux/init.h>
-#include <linux/module.h>
 #include <linux/io.h>
 #include <linux/errno.h>
 #include <linux/spinlock.h>
@@ -126,14 +125,10 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	ipu_csi_write(ipu, csi, data, CSI_SENS_CONF);
 
-	/* Setup the mclk */
-	if (cfg_param.mclk > 0)
-		_ipu_csi_mclk_set(ipu, cfg_param.mclk, csi);
-
 	/* Setup sensor frame size */
 	ipu_csi_write(ipu, csi, (width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE);
 
@@ -145,34 +140,35 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		if (width == 720 && height == 625) {
 			/* PAL case */
 			/*
-			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
-			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
+			 * Field0BlankEnd = 0x6, Field0BlankStart = 0x2,
+			 * Field0ActiveEnd = 0x4, Field0ActiveStart = 0
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 * Field1BlankEnd = 0x7, Field1BlankStart = 0x3,
+			 * Field1ActiveEnd = 0x5, Field1ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 
 		} else if (width == 720 && height == 525) {
 			/* NTSC case */
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
-			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
-			/*
 			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
 			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			/*
+			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
+			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 */
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 		} else {
 			dev_err(ipu->dev, "Unsupported CCIR656 interlaced "
 					"video mode\n");
-			_ipu_unlock(ipu);
+			mutex_unlock(&ipu->mutex_lock);
 			_ipu_put(ipu);
 			return -EINVAL;
 		}
@@ -198,7 +194,7 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 	dev_dbg(ipu->dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
 		ipu_csi_read(ipu, csi, CSI_ACT_FRM_SIZE));
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 
@@ -264,13 +260,13 @@ void ipu_csi_get_window_size(struct ipu_soc *ipu, uint32_t *width, uint32_t *hei
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	reg = ipu_csi_read(ipu, csi, CSI_ACT_FRM_SIZE);
 	*width = (reg & 0xFFFF) + 1;
 	*height = (reg >> 16 & 0xFFFF) + 1;
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 }
@@ -288,11 +284,11 @@ void ipu_csi_set_window_size(struct ipu_soc *ipu, uint32_t width, uint32_t heigh
 {
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	ipu_csi_write(ipu, csi, (width - 1) | (height - 1) << 16, CSI_ACT_FRM_SIZE);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 }
@@ -312,14 +308,14 @@ void ipu_csi_set_window_pos(struct ipu_soc *ipu, uint32_t left, uint32_t top, ui
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	temp = ipu_csi_read(ipu, csi, CSI_OUT_FRM_CTRL);
 	temp &= ~(CSI_HSC_MASK | CSI_VSC_MASK);
 	temp |= ((top << CSI_VSC_SHIFT) | (left << CSI_HSC_SHIFT));
 	ipu_csi_write(ipu, csi, temp, CSI_OUT_FRM_CTRL);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 }
@@ -793,8 +789,12 @@ void _ipu_csi_wait4eof(struct ipu_soc *ipu, ipu_channel_t channel)
 		irq = IPU_IRQ_CSI2_OUT_EOF;
 	else if (channel == CSI_MEM3)
 		irq = IPU_IRQ_CSI3_OUT_EOF;
+	else if (channel == CSI_PRP_ENC_MEM)
+		irq = IPU_IRQ_PRP_ENC_OUT_EOF;
+	else if (channel == CSI_PRP_VF_MEM)
+		irq = IPU_IRQ_PRP_VF_OUT_EOF;
 	else{
-		dev_err(ipu->dev, "Not a CSI SMFC channel\n");
+		dev_err(ipu->dev, "Not a CSI channel\n");
 		return;
 	}
 
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index e444682..9c47cd9 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,7 +44,8 @@ static struct ipu_soc ipu_array[MXC_IPU_MAX_NUM];
 int g_ipu_hw_rev;
 
 /* Static functions */
-static irqreturn_t ipu_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc);
 
 static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
 {
@@ -97,6 +98,18 @@ static inline int _ipu_is_trb_chan(uint32_t dma_chan)
 		(g_ipu_hw_rev >= 2));
 }
 
+/*
+ * We usually use IDMAC 23 as full plane and IDMAC 27 as partial
+ * plane.
+ * IDMAC 23/24/28/41 can drive a display respectively - primary
+ * IDMAC 27 depends on IDMAC 23 - nonprimary
+ */
+static inline int _ipu_is_primary_disp_chan(uint32_t dma_chan)
+{
+	return ((dma_chan == 23) || (dma_chan == 24) ||
+		(dma_chan == 28) || (dma_chan == 41));
+}
+
 #define idma_is_valid(ch)	(ch != NO_DMA)
 #define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
 #define idma_is_set(ipu, reg, dma)	(ipu_idmac_read(ipu, reg(dma)) & idma_mask(dma))
@@ -137,8 +150,8 @@ static int __devinit ipu_clk_setup_enable(struct ipu_soc *ipu,
 	}
 	dev_dbg(ipu->dev, "ipu_clk = %lu\n", clk_get_rate(ipu->ipu_clk));
 
-	ipu->pixel_clk[0] = ipu_pixel_clk[0];
-	ipu->pixel_clk[1] = ipu_pixel_clk[1];
+	ipu->pixel_clk[0] = ipu_pixel_clk[pdev->id][0];
+	ipu->pixel_clk[1] = ipu_pixel_clk[pdev->id][1];
 
 	ipu_lookups[pdev->id][0].clk = &ipu->pixel_clk[0];
 	ipu_lookups[pdev->id][1].clk = &ipu->pixel_clk[1];
@@ -150,10 +163,21 @@ static int __devinit ipu_clk_setup_enable(struct ipu_soc *ipu,
 	clk_debug_register(&ipu->pixel_clk[0]);
 	clk_debug_register(&ipu->pixel_clk[1]);
 
+	/*
+	 * Enable ipu hsp clock anyway, so that we
+	 * may keep the clock on until user space
+	 * triggers frame buffer set_par(), i.e., any
+	 * ipu interface which enables/disables ipu
+	 * hsp clock with pair(called in IPUv3 fb
+	 * driver or mxc v4l2 driver<probed after fb
+	 * driver>) cannot eventually disables the
+	 * clock to damage the channel setup by
+	 * bootloader.
+	 */
 	clk_enable(ipu->ipu_clk);
 
-	clk_set_parent(&ipu->pixel_clk[0], ipu->ipu_clk);
-	clk_set_parent(&ipu->pixel_clk[1], ipu->ipu_clk);
+	ipu->pixel_clk[0].parent = ipu->ipu_clk;
+	ipu->pixel_clk[1].parent = ipu->ipu_clk;
 
 	ipu->di_clk[0] = clk_get(ipu->dev, di0_clk);
 	ipu->di_clk[1] = clk_get(ipu->dev, di1_clk);
@@ -175,20 +199,6 @@ struct ipu_soc *ipu_get_soc(int id)
 }
 EXPORT_SYMBOL_GPL(ipu_get_soc);
 
-void _ipu_lock(struct ipu_soc *ipu)
-{
-	/*TODO:remove in_irq() condition after v4l2 driver rewrite*/
-	if (!in_irq() && !in_softirq())
-		mutex_lock(&ipu->mutex_lock);
-}
-
-void _ipu_unlock(struct ipu_soc *ipu)
-{
-	/*TODO:remove in_irq() condition after v4l2 driver rewrite*/
-	if (!in_irq() && !in_softirq())
-		mutex_unlock(&ipu->mutex_lock);
-}
-
 void _ipu_get(struct ipu_soc *ipu)
 {
 	int ret;
@@ -203,6 +213,12 @@ void _ipu_put(struct ipu_soc *ipu)
 	clk_disable(ipu->ipu_clk);
 }
 
+void ipu_disable_hsp_clk(struct ipu_soc *ipu)
+{
+	_ipu_put(ipu);
+}
+EXPORT_SYMBOL(ipu_disable_hsp_clk);
+
 /*!
  * This function is called by the driver framework to initialize the IPU
  * hardware.
@@ -226,16 +242,14 @@ static int __devinit ipu_probe(struct platform_device *pdev)
 	ipu = &ipu_array[pdev->id];
 	memset(ipu, 0, sizeof(struct ipu_soc));
 
-	spin_lock_init(&ipu->spin_lock);
+	spin_lock_init(&ipu->int_reg_spin_lock);
+	spin_lock_init(&ipu->rdy_reg_spin_lock);
 	mutex_init(&ipu->mutex_lock);
 
 	g_ipu_hw_rev = plat_data->rev;
 
 	ipu->dev = &pdev->dev;
 
-	if (plat_data->init)
-		plat_data->init(pdev->id);
-
 	ipu->irq_err = platform_get_irq(pdev, 0);
 	ipu->irq_sync = platform_get_irq(pdev, 1);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -245,19 +259,17 @@ static int __devinit ipu_probe(struct platform_device *pdev)
 		goto failed_get_res;
 	}
 
-	if (request_irq(ipu->irq_sync, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
+	ret = request_irq(ipu->irq_sync, ipu_sync_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
 		dev_err(ipu->dev, "request SYNC interrupt failed\n");
-		ret = -EBUSY;
 		goto failed_req_irq_sync;
 	}
-	/* Some platforms have 2 IPU interrupts */
-	if (ipu->irq_err >= 0) {
-		if (request_irq
-		    (ipu->irq_err, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
-			dev_err(ipu->dev, "request ERR interrupt failed\n");
-			ret = -EBUSY;
-			goto failed_req_irq_err;
-		}
+	ret = request_irq(ipu->irq_err, ipu_err_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
+		dev_err(ipu->dev, "request ERR interrupt failed\n");
+		goto failed_req_irq_err;
 	}
 
 	ipu_base = res->start;
@@ -322,23 +334,30 @@ static int __devinit ipu_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ipu);
 
-	ipu_reset(ipu);
+	if (!plat_data->bypass_reset) {
+		if (plat_data->init)
+			plat_data->init(pdev->id);
 
-	/* Enable error interrupts by default */
-	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
-	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(6));
-	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(9));
-	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(10));
+		ipu_reset(ipu);
+
+		ipu_disp_init(ipu);
 
-	ipu_disp_init(ipu);
+		/* Set MCU_T to divide MCU access window into 2 */
+		ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
+			     IPU_DISP_GEN);
+	}
 
 	/* Set sync refresh channels and CSI->mem channel as high priority */
 	ipu_idmac_write(ipu, 0x18800001L, IDMAC_CHA_PRI(0));
 
-	/* Set MCU_T to divide MCU access window into 2 */
-	ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18), IPU_DISP_GEN);
+	/* Enable error interrupts by default */
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(6));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(9));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(10));
 
-	clk_disable(ipu->ipu_clk);
+	if (!plat_data->bypass_reset)
+		clk_disable(ipu->ipu_clk);
 
 	register_ipu_device(ipu, pdev->id);
 
@@ -364,8 +383,7 @@ failed_clk_setup:
 	iounmap(ipu->disp_base[1]);
 	iounmap(ipu->vdi_reg);
 failed_ioremap:
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_err, ipu);
 failed_req_irq_err:
 	free_irq(ipu->irq_sync, ipu);
 failed_req_irq_sync:
@@ -379,10 +397,8 @@ int __devexit ipu_remove(struct platform_device *pdev)
 
 	unregister_ipu_device(ipu, pdev->id);
 
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_sync, ipu);
-	if (ipu->irq_err)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_sync, ipu);
+	free_irq(ipu->irq_err, ipu);
 
 	clk_put(ipu->ipu_clk);
 
@@ -479,7 +495,7 @@ int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	/* Re-enable error interrupts every time a channel is initialized */
 	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
@@ -769,7 +785,7 @@ int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel
 	ipu_cm_write(ipu, ipu_conf, IPU_CONF);
 
 err:
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	return ret;
 }
 EXPORT_SYMBOL(ipu_init_channel);
@@ -785,13 +801,14 @@ void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 	uint32_t reg;
 	uint32_t in_dma, out_dma = 0;
 	uint32_t ipu_conf;
+	uint32_t dc_chan = 0;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	if ((ipu->channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
 		dev_dbg(ipu->dev, "Channel already uninitialized %d\n",
 			IPU_CHAN_ID(channel));
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return;
 	}
 
@@ -805,7 +822,7 @@ void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 		dev_err(ipu->dev,
 			"Channel %d is not disabled, disable first\n",
 			IPU_CHAN_ID(channel));
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return;
 	}
 
@@ -917,12 +934,14 @@ void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 		_ipu_ic_uninit_rotate_pp(ipu);
 		break;
 	case MEM_DC_SYNC:
+		dc_chan = 1;
 		_ipu_dc_uninit(ipu, 1);
 		ipu->di_use_count[ipu->dc_di_assignment[1]]--;
 		ipu->dc_use_count--;
 		ipu->dmfc_use_count--;
 		break;
 	case MEM_BG_SYNC:
+		dc_chan = 5;
 		_ipu_dp_uninit(ipu, channel);
 		_ipu_dc_uninit(ipu, 5);
 		ipu->di_use_count[ipu->dc_di_assignment[5]]--;
@@ -937,11 +956,13 @@ void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 		ipu->dmfc_use_count--;
 		break;
 	case DIRECT_ASYNC0:
+		dc_chan = 8;
 		_ipu_dc_uninit(ipu, 8);
 		ipu->di_use_count[ipu->dc_di_assignment[8]]--;
 		ipu->dc_use_count--;
 		break;
 	case DIRECT_ASYNC1:
+		dc_chan = 9;
 		_ipu_dc_uninit(ipu, 9);
 		ipu->di_use_count[ipu->dc_di_assignment[9]]--;
 		ipu->dc_use_count--;
@@ -978,7 +999,15 @@ void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 
 	ipu->channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
 
-	_ipu_unlock(ipu);
+	/*
+	 * Disable pixel clk and its parent clock(if the parent clock
+	 * usecount is 1) after clearing DC/DP/DI bits in IPU_CONF
+	 * register to prevent LVDS display channel starvation.
+	 */
+	if (_ipu_is_primary_disp_chan(in_dma))
+		clk_disable(&ipu->pixel_clk[ipu->dc_di_assignment[dc_chan]]);
+
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 
@@ -1087,7 +1116,7 @@ int32_t ipu_init_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 		return -EINVAL;
 	}
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	/* Build parameter memory data for DMA channel */
 	_ipu_ch_param_init(ipu, dma_chan, pixel_fmt, width, height, stride, u, v, 0,
@@ -1259,7 +1288,7 @@ int32_t ipu_init_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 
 	}
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return 0;
 }
@@ -1288,12 +1317,12 @@ int32_t ipu_update_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 	uint32_t reg;
 	int ret = 0;
 	uint32_t dma_chan = channel_2_dma(channel, type);
+	unsigned long lock_flags;
 
 	if (dma_chan == IDMA_CHAN_INVALID)
 		return -EINVAL;
 
-	_ipu_lock(ipu);
-
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	if (bufNum == 0)
 		reg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(dma_chan));
 	else if (bufNum == 1)
@@ -1305,8 +1334,7 @@ int32_t ipu_update_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 		_ipu_ch_param_set_buffer(ipu, dma_chan, bufNum, phyaddr);
 	else
 		ret = -EACCES;
-
-	_ipu_unlock(ipu);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 
 	return ret;
 }
@@ -1338,7 +1366,7 @@ int32_t ipu_set_channel_bandmode(struct ipu_soc *ipu, ipu_channel_t channel,
 	if ((2 > band_height) || (8 < band_height))
 		return -EINVAL;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	reg = ipu_idmac_read(ipu, IDMAC_BAND_EN(dma_chan));
 	reg |= 1 << (dma_chan % 32);
@@ -1347,7 +1375,7 @@ int32_t ipu_set_channel_bandmode(struct ipu_soc *ipu, ipu_channel_t channel,
 	_ipu_ch_param_set_bandmode(ipu, dma_chan, band_height);
 	dev_dbg(ipu->dev, "dma_chan:%d, band_height:%d.\n\n",
 				dma_chan, 1 << band_height);
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return ret;
 }
@@ -1399,12 +1427,12 @@ int32_t ipu_update_channel_offset(struct ipu_soc *ipu,
 {
 	int ret = 0;
 	uint32_t dma_chan = channel_2_dma(channel, type);
+	unsigned long lock_flags;
 
 	if (dma_chan == IDMA_CHAN_INVALID)
 		return -EINVAL;
 
-	_ipu_lock(ipu);
-
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	if ((ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(dma_chan)) & idma_mask(dma_chan)) ||
 	    (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(dma_chan)) & idma_mask(dma_chan)) ||
 	    ((ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(dma_chan)) & idma_mask(dma_chan)) &&
@@ -1414,8 +1442,8 @@ int32_t ipu_update_channel_offset(struct ipu_soc *ipu,
 	else
 		_ipu_ch_offset_update(ipu, dma_chan, pixel_fmt, width, height, stride,
 				      u, v, 0, vertical_offset, horizontal_offset);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 
-	_ipu_unlock(ipu);
 	return ret;
 }
 EXPORT_SYMBOL(ipu_update_channel_offset);
@@ -1438,12 +1466,13 @@ int32_t ipu_select_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 			ipu_buffer_t type, uint32_t bufNum)
 {
 	uint32_t dma_chan = channel_2_dma(channel, type);
+	unsigned long lock_flags;
 
 	if (dma_chan == IDMA_CHAN_INVALID)
 		return -EINVAL;
 
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	/* Mark buffer to be ready. */
-	_ipu_lock(ipu);
 	if (bufNum == 0)
 		ipu_cm_write(ipu, idma_mask(dma_chan),
 			     IPU_CHA_BUF0_RDY(dma_chan));
@@ -1453,7 +1482,8 @@ int32_t ipu_select_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 	else
 		ipu_cm_write(ipu, idma_mask(dma_chan),
 			     IPU_CHA_BUF2_RDY(dma_chan));
-	_ipu_unlock(ipu);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
+
 	return 0;
 }
 EXPORT_SYMBOL(ipu_select_buffer);
@@ -1475,14 +1505,16 @@ int32_t ipu_select_multi_vdi_buffer(struct ipu_soc *ipu, uint32_t bufNum)
 		idma_mask(channel_2_dma(MEM_VDI_PRP_VF_MEM_P, IPU_INPUT_BUFFER))|
 		idma_mask(dma_chan)|
 		idma_mask(channel_2_dma(MEM_VDI_PRP_VF_MEM_N, IPU_INPUT_BUFFER));
+	unsigned long lock_flags;
 
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	/* Mark buffers to be ready. */
-	_ipu_lock(ipu);
 	if (bufNum == 0)
 		ipu_cm_write(ipu, mask_bit, IPU_CHA_BUF0_RDY(dma_chan));
 	else
 		ipu_cm_write(ipu, mask_bit, IPU_CHA_BUF1_RDY(dma_chan));
-	_ipu_unlock(ipu);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
+
 	return 0;
 }
 EXPORT_SYMBOL(ipu_select_multi_vdi_buffer);
@@ -1520,7 +1552,7 @@ int32_t ipu_link_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_channel
 	uint32_t fs_proc_flow3;
 	uint32_t fs_disp_flow1;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	fs_proc_flow1 = ipu_cm_read(ipu, IPU_FS_PROC_FLOW1);
 	fs_proc_flow2 = ipu_cm_read(ipu, IPU_FS_PROC_FLOW2);
@@ -1718,7 +1750,7 @@ int32_t ipu_link_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_channel
 	ipu_cm_write(ipu, fs_disp_flow1, IPU_FS_DISP_FLOW1);
 
 err:
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	return retval;
 }
 EXPORT_SYMBOL(ipu_link_channels);
@@ -1745,7 +1777,7 @@ int32_t ipu_unlink_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_chann
 	uint32_t fs_proc_flow3;
 	uint32_t fs_disp_flow1;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	fs_proc_flow1 = ipu_cm_read(ipu, IPU_FS_PROC_FLOW1);
 	fs_proc_flow2 = ipu_cm_read(ipu, IPU_FS_PROC_FLOW2);
@@ -1854,7 +1886,7 @@ int32_t ipu_unlink_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_chann
 	ipu_cm_write(ipu, fs_disp_flow1, IPU_FS_DISP_FLOW1);
 
 err:
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	return retval;
 }
 EXPORT_SYMBOL(ipu_unlink_channels);
@@ -1905,12 +1937,12 @@ int32_t ipu_enable_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 	uint32_t sec_dma;
 	uint32_t thrd_dma;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	if (ipu->channel_enable_mask & (1L << IPU_CHAN_ID(channel))) {
 		dev_err(ipu->dev, "Warning: channel already enabled %d\n",
 			IPU_CHAN_ID(channel));
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return -EACCES;
 	}
 
@@ -1993,7 +2025,7 @@ int32_t ipu_enable_channel(struct ipu_soc *ipu, ipu_channel_t channel)
 
 	ipu->channel_enable_mask |= 1L << IPU_CHAN_ID(channel);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return 0;
 }
@@ -2016,16 +2048,19 @@ int32_t ipu_check_buffer_ready(struct ipu_soc *ipu, ipu_channel_t channel, ipu_b
 {
 	uint32_t dma_chan = channel_2_dma(channel, type);
 	uint32_t reg;
+	unsigned long lock_flags;
 
 	if (dma_chan == IDMA_CHAN_INVALID)
 		return -EINVAL;
 
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	if (bufNum == 0)
 		reg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(dma_chan));
 	else if (bufNum == 1)
 		reg = ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(dma_chan));
 	else
 		reg = ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(dma_chan));
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 
 	if (reg & idma_mask(dma_chan))
 		return 1;
@@ -2070,9 +2105,11 @@ void _ipu_clear_buffer_ready(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buf
 void ipu_clear_buffer_ready(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
 		uint32_t bufNum)
 {
-	_ipu_lock(ipu);
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	_ipu_clear_buffer_ready(ipu, channel, type, bufNum);
-	_ipu_unlock(ipu);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 }
 EXPORT_SYMBOL(ipu_clear_buffer_ready);
 
@@ -2096,13 +2133,14 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 	uint32_t sec_dma = NO_DMA;
 	uint32_t thrd_dma = NO_DMA;
 	uint16_t fg_pos_x, fg_pos_y;
+	unsigned long lock_flags;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	if ((ipu->channel_enable_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
 		dev_dbg(ipu->dev, "Channel already disabled %d\n",
 			IPU_CHAN_ID(channel));
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return -EACCES;
 	}
 
@@ -2114,7 +2152,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 		!idma_is_set(ipu, IDMAC_CHA_EN, in_dma))
 		&& (idma_is_valid(out_dma) &&
 		!idma_is_set(ipu, IDMAC_CHA_EN, out_dma))) {
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return -EINVAL;
 	}
 
@@ -2153,10 +2191,8 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 				}
 			}
 		}
-	} else if ((channel == CSI_MEM0) || (channel == CSI_MEM1) ||
-			(channel == CSI_MEM2) || (channel == CSI_MEM3))
-		_ipu_csi_wait4eof(ipu, channel);
-	else if (wait_for_stop) {
+	} else if (wait_for_stop && !_ipu_is_smfc_chan(out_dma) &&
+		   channel != CSI_PRP_VF_MEM && channel != CSI_PRP_ENC_MEM) {
 		while (idma_is_set(ipu, IDMAC_CHA_BUSY, in_dma) ||
 		       idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma) ||
 			(ipu->sec_chan_en[IPU_CHAN_ID(channel)] &&
@@ -2164,7 +2200,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			(ipu->thrd_chan_en[IPU_CHAN_ID(channel)] &&
 			idma_is_set(ipu, IDMAC_CHA_BUSY, thrd_dma))) {
 			uint32_t irq = 0xffffffff;
-			int timeout = 50;
+			int timeout = 50000;
 
 			if (idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma))
 				irq = out_dma;
@@ -2190,7 +2226,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			while (((ipu_cm_read(ipu, IPUIRQ_2_STATREG(irq))
 				& IPUIRQ_2_MASK(irq)) == 0) &&
 				(idma_is_set(ipu, IDMAC_CHA_BUSY, irq))) {
-				msleep(10);
+				udelay(10);
 				timeout -= 10;
 				if (timeout <= 0) {
 					ipu_dump_registers(ipu);
@@ -2198,6 +2234,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 					break;
 				}
 			}
+			dev_dbg(ipu->dev, "wait_time:%d\n", 50000 - timeout);
 
 		}
 	}
@@ -2250,6 +2287,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 	if (channel == MEM_FG_SYNC)
 		_ipu_disp_set_window_pos(ipu, channel, fg_pos_x, fg_pos_y);
 
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	/* Set channel buffers NOT to be ready */
 	if (idma_is_valid(in_dma)) {
 		_ipu_clear_buffer_ready(ipu, channel, IPU_VIDEO_IN_BUFFER, 0);
@@ -2268,10 +2306,11 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 		_ipu_clear_buffer_ready(ipu, channel, IPU_ALPHA_IN_BUFFER, 0);
 		_ipu_clear_buffer_ready(ipu, channel, IPU_ALPHA_IN_BUFFER, 1);
 	}
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 
 	ipu->channel_enable_mask &= ~(1L << IPU_CHAN_ID(channel));
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return 0;
 }
@@ -2296,7 +2335,7 @@ int32_t ipu_enable_csi(struct ipu_soc *ipu, uint32_t csi)
 	}
 
 	_ipu_get(ipu);
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 	ipu->csi_use_count[csi]++;
 
 	if (ipu->csi_use_count[csi] == 1) {
@@ -2306,7 +2345,7 @@ int32_t ipu_enable_csi(struct ipu_soc *ipu, uint32_t csi)
 		else
 			ipu_cm_write(ipu, reg | IPU_CONF_CSI1_EN, IPU_CONF);
 	}
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	_ipu_put(ipu);
 	return 0;
 }
@@ -2330,91 +2369,87 @@ int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi)
 		return -EINVAL;
 	}
 	_ipu_get(ipu);
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 	ipu->csi_use_count[csi]--;
 	if (ipu->csi_use_count[csi] == 0) {
+		_ipu_csi_wait4eof(ipu, ipu->csi_channel[csi]);
 		reg = ipu_cm_read(ipu, IPU_CONF);
 		if (csi == 0)
 			ipu_cm_write(ipu, reg & ~IPU_CONF_CSI0_EN, IPU_CONF);
 		else
 			ipu_cm_write(ipu, reg & ~IPU_CONF_CSI1_EN, IPU_CONF);
 	}
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	_ipu_put(ipu);
 	return 0;
 }
 EXPORT_SYMBOL(ipu_disable_csi);
 
-static irqreturn_t ipu_irq_handler(int irq, void *desc)
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc)
 {
 	struct ipu_soc *ipu = desc;
 	int i;
-	uint32_t line;
-	uint32_t bit;
+	uint32_t line, bit, int_stat, int_ctrl;
 	irqreturn_t result = IRQ_NONE;
-	uint32_t int_stat;
-	uint32_t int_ctrl;
-	const int err_reg[] = { 5, 6, 9, 10, 0 };
 	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
-	unsigned long lock_flags;
-	uint32_t oneshot;
-
-	for (i = 0;; i++) {
-		if (err_reg[i] == 0)
-			break;
-
-		spin_lock_irqsave(&ipu->spin_lock, lock_flags);
-
-		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
-		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
-		if (int_stat) {
-			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
-			dev_warn(ipu->dev,
-				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
-				err_reg[i], int_stat);
-			/* Disable interrupts so we only get error once */
-			int_stat =
-			    ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) & ~int_stat;
-			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
-		}
 
-		spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
-	}
+	spin_lock(&ipu->int_reg_spin_lock);
 
-	for (i = 0;; i++) {
-		if (int_reg[i] == 0)
-			break;
-		spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	for (i = 0; int_reg[i] != 0; i++) {
 		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(int_reg[i]));
 		int_ctrl = ipu_cm_read(ipu, IPU_INT_CTRL(int_reg[i]));
 		int_stat &= int_ctrl;
 		ipu_cm_write(ipu, int_stat, IPU_INT_STAT(int_reg[i]));
-		spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
-		oneshot = 0;
 		while ((line = ffs(int_stat)) != 0) {
 			bit = --line;
 			int_stat &= ~(1UL << line);
 			line += (int_reg[i] - 1) * 32;
-			if (ipu->irq_list[line].flags & IPU_IRQF_ONESHOT)
-				oneshot |= 1UL << bit;
 			result |=
 			    ipu->irq_list[line].handler(line,
 						       ipu->irq_list[line].
 						       dev_id);
-		}
-		if (oneshot) {
-			spin_lock_irqsave(&ipu->spin_lock, lock_flags);
-			if ((~int_ctrl) & oneshot)
-				BUG();
-			int_ctrl &= ~oneshot;
-			ipu_cm_write(ipu, int_ctrl, IPU_INT_CTRL(int_reg[i]));
-			spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+			if (ipu->irq_list[line].flags & IPU_IRQF_ONESHOT) {
+				int_ctrl &= ~(1UL << bit);
+				ipu_cm_write(ipu, int_ctrl,
+						IPU_INT_CTRL(int_reg[i]));
+			}
 		}
 	}
 
+	spin_unlock(&ipu->int_reg_spin_lock);
+
 	return result;
 }
 
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc)
+{
+	struct ipu_soc *ipu = desc;
+	int i;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+
+	spin_lock(&ipu->int_reg_spin_lock);
+
+	for (i = 0; err_reg[i] != 0; i++) {
+		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
+		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_warn(ipu->dev,
+				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+			/* Disable interrupts so we only get error once */
+			int_stat = ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) &
+					~int_stat;
+			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	spin_unlock(&ipu->int_reg_spin_lock);
+
+	return IRQ_HANDLED;
+}
+
 /*!
  * This function enables the interrupt for the specified interrupt line.
  * The interrupt lines are defined in \b ipu_irq_line enum.
@@ -2430,13 +2465,13 @@ void ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq)
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
 
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 }
@@ -2457,13 +2492,13 @@ void ipu_disable_irq(struct ipu_soc *ipu, uint32_t irq)
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg &= ~IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
 
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 }
@@ -2483,11 +2518,11 @@ void ipu_clear_irq(struct ipu_soc *ipu, uint32_t irq)
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
 	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
 
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 }
@@ -2510,9 +2545,9 @@ bool ipu_get_irq_status(struct ipu_soc *ipu, uint32_t irq)
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 	reg = ipu_cm_read(ipu, IPUIRQ_2_STATREG(irq));
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 
@@ -2555,12 +2590,12 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
 	if (ipu->irq_list[irq].handler != NULL) {
 		dev_err(ipu->dev,
 			"handler already installed on irq %d\n", irq);
-		spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+		spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 		return -EINVAL;
 	}
 
@@ -2576,7 +2611,7 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
 
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 
@@ -2603,7 +2638,7 @@ void ipu_free_irq(struct ipu_soc *ipu, uint32_t irq, void *dev_id)
 
 	_ipu_get(ipu);
 
-	spin_lock_irqsave(&ipu->spin_lock, lock_flags);
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
 	/* disable the interrupt */
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
@@ -2612,7 +2647,7 @@ void ipu_free_irq(struct ipu_soc *ipu, uint32_t irq, void *dev_id)
 	if (ipu->irq_list[irq].dev_id == dev_id)
 		memset(&ipu->irq_list[irq], 0, sizeof(ipu->irq_list[irq]));
 
-	spin_unlock_irqrestore(&ipu->spin_lock, lock_flags);
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 }
@@ -2694,9 +2729,9 @@ uint32_t ipu_channel_status(struct ipu_soc *ipu, ipu_channel_t channel)
 	uint32_t dma_status;
 
 	_ipu_get(ipu);
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 	dma_status = ipu_is_channel_busy(ipu, channel);
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	_ipu_put(ipu);
 
 	dev_dbg(ipu->dev, "%s, dma_status:%d.\n", __func__, dma_status);
@@ -2708,11 +2743,11 @@ EXPORT_SYMBOL(ipu_channel_status);
 int32_t ipu_swap_channel(struct ipu_soc *ipu, ipu_channel_t from_ch, ipu_channel_t to_ch)
 {
 	uint32_t reg;
-
+	unsigned long lock_flags;
 	int from_dma = channel_2_dma(from_ch, IPU_INPUT_BUFFER);
 	int to_dma = channel_2_dma(to_ch, IPU_INPUT_BUFFER);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	/* enable target channel */
 	reg = ipu_idmac_read(ipu, IDMAC_CHA_EN(to_dma));
@@ -2732,11 +2767,13 @@ int32_t ipu_swap_channel(struct ipu_soc *ipu, ipu_channel_t from_ch, ipu_channel
 
 	ipu->channel_enable_mask &= ~(1L << IPU_CHAN_ID(from_ch));
 
+	spin_lock_irqsave(&ipu->rdy_reg_spin_lock, lock_flags);
 	_ipu_clear_buffer_ready(ipu, from_ch, IPU_VIDEO_IN_BUFFER, 0);
 	_ipu_clear_buffer_ready(ipu, from_ch, IPU_VIDEO_IN_BUFFER, 1);
 	_ipu_clear_buffer_ready(ipu, from_ch, IPU_VIDEO_IN_BUFFER, 2);
+	spin_unlock_irqrestore(&ipu->rdy_reg_spin_lock, lock_flags);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return 0;
 }
@@ -2750,6 +2787,7 @@ uint32_t bytes_per_pixel(uint32_t fmt)
 	case IPU_PIX_FMT_YUV420P:
 	case IPU_PIX_FMT_YVU420P:
 	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YUV444P:
 		return 1;
 		break;
 	case IPU_PIX_FMT_RGB565:
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index a1cfbd9..433eebf 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -341,6 +341,7 @@ struct ipu_alloc_list {
 	dma_addr_t phy_addr;
 	void *cpu_addr;
 	u32 size;
+	void *file_index;
 };
 
 static LIST_HEAD(ipu_alloc_list);
@@ -351,7 +352,9 @@ static DEFINE_SPINLOCK(ipu_task_list_lock);
 static DECLARE_WAIT_QUEUE_HEAD(thread_waitq);
 static DECLARE_WAIT_QUEUE_HEAD(res_waitq);
 static atomic_t req_cnt;
+static atomic_t file_index = ATOMIC_INIT(1);
 static int major;
+static int max_ipu_no;
 static int thread_id;
 static atomic_t frame_no;
 static struct class *ipu_class;
@@ -420,6 +423,7 @@ unsigned int fmt_to_bpp(unsigned int pixelformat)
 	case IPU_PIX_FMT_BGR24:
 	case IPU_PIX_FMT_RGB24:
 	case IPU_PIX_FMT_YUV444:
+	case IPU_PIX_FMT_YUV444P:
 		bpp = 24;
 		break;
 	case IPU_PIX_FMT_BGR32:
@@ -465,6 +469,7 @@ cs_t colorspaceofpixel(int fmt)
 	case IPU_PIX_FMT_YVU422P:
 	case IPU_PIX_FMT_YUV422P:
 	case IPU_PIX_FMT_YUV444:
+	case IPU_PIX_FMT_YUV444P:
 	case IPU_PIX_FMT_NV12:
 	case IPU_PIX_FMT_TILED_NV12:
 	case IPU_PIX_FMT_TILED_NV12F:
@@ -497,6 +502,10 @@ static int soc_max_in_width(u32 is_vdoa)
 	return is_vdoa ? 8192 : 4096;
 }
 
+static int soc_max_vdi_in_width(void)
+{
+	return IPU_MAX_VDI_IN_WIDTH;
+}
 static int soc_max_in_height(void)
 {
 	return 4096;
@@ -746,6 +755,11 @@ static void update_offset(unsigned int fmt,
 			+ (width * pos_y)/2 + pos_x/2;
 		*voff = *uoff + (width * height)/2;
 		break;
+	case IPU_PIX_FMT_YUV444P:
+		*off = pos_y * width + pos_x;
+		*uoff = width * height;
+		*voff = width * height * 2;
+		break;
 	case IPU_PIX_FMT_NV12:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
@@ -760,7 +774,7 @@ static void update_offset(unsigned int fmt,
 		 * = line * stride + pixel * 16
 		 */
 		*off = pos_y * width + (pos_x << 4);
-		*uoff = ALIGN(width * height, SZ_4K) + (*off >> 1);
+		*uoff = ALIGN(width * height, SZ_4K) + (*off >> 1) - *off;
 		break;
 	case IPU_PIX_FMT_TILED_NV12F:
 		/*
@@ -769,7 +783,7 @@ static void update_offset(unsigned int fmt,
 		 * instead of 256
 		 */
 		*off = (pos_y >> 1) * width + (pos_x << 3);
-		*uoff = ALIGN(width * height/2, SZ_4K) + (*off >> 1);
+		*uoff = ALIGN(width * height/2, SZ_4K) + (*off >> 1) - *off;
 		break;
 	default:
 		*off = (pos_y * width + pos_x) * fmt_to_bpp(fmt)/8;
@@ -778,13 +792,14 @@ static void update_offset(unsigned int fmt,
 	*stride = width * bytes_per_pixel(fmt);
 }
 
-static int update_split_setting(struct ipu_task_entry *t)
+static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 {
 	struct stripe_param left_stripe;
 	struct stripe_param right_stripe;
 	struct stripe_param up_stripe;
 	struct stripe_param down_stripe;
 	u32 iw, ih, ow, oh;
+	u32 max_width;
 
 	if (t->output.rotate >= IPU_ROTATE_90_RIGHT)
 		return IPU_CHECK_ERR_SPLIT_WITH_ROT;
@@ -796,9 +811,13 @@ static int update_split_setting(struct ipu_task_entry *t)
 	oh = t->output.crop.h;
 
 	if (t->set.split_mode & RL_SPLIT) {
+		if (vdi_split)
+			max_width = soc_max_vdi_in_width();
+		else
+			max_width = soc_max_out_width();
 		ipu_calc_stripes_sizes(iw,
 				ow,
-				soc_max_out_width(),
+				max_width,
 				(((unsigned long long)1) << 32), /* 32bit for fractional*/
 				1, /* equal stripes */
 				t->input.format,
@@ -867,6 +886,7 @@ static int check_task(struct ipu_task_entry *t)
 	int tmp;
 	int ret = IPU_CHECK_OK;
 	int timeout;
+	bool vdi_split = false;
 
 	if ((IPU_PIX_FMT_TILED_NV12 == t->overlay.format) ||
 		(IPU_PIX_FMT_TILED_NV12F == t->overlay.format) ||
@@ -1023,6 +1043,11 @@ static int check_task(struct ipu_task_entry *t)
 			t->set.split_mode |= RL_SPLIT;
 		if (t->output.crop.h > soc_max_out_height())
 			t->set.split_mode |= UD_SPLIT;
+		if (!t->set.split_mode && (t->set.mode & VDI_MODE) &&
+				(t->input.crop.w > soc_max_vdi_in_width())) {
+			t->set.split_mode |= RL_SPLIT;
+			vdi_split = true;
+		}
 		if (t->set.split_mode) {
 			if ((t->set.split_mode == RL_SPLIT) ||
 				 (t->set.split_mode == UD_SPLIT))
@@ -1032,7 +1057,7 @@ static int check_task(struct ipu_task_entry *t)
 			if (t->timeout < timeout)
 				t->timeout = timeout;
 
-			ret = update_split_setting(t);
+			ret = update_split_setting(t, vdi_split);
 			if (ret > IPU_CHECK_ERR_MIN)
 				goto done;
 		}
@@ -1089,7 +1114,7 @@ static int prepare_task(struct ipu_task_entry *t)
 		if (t->set.task != 0) {
 			dev_err(t->dev, "ERR: vdoa only task:0x%x, [0x%p].\n",
 					t->set.task, t);
-			BUG();
+			return -EINVAL;
 		}
 		t->set.task |= VDOA_ONLY;
 	}
@@ -1148,10 +1173,11 @@ static int _get_vdoa_ipu_res(struct ipu_task_entry *t)
 		}
 	}
 
-	for (i = 0; i < MXC_IPU_MAX_NUM; i++) {
+	for (i = 0; i < max_ipu_no; i++) {
 		ipu = ipu_get_soc(i);
 		if (IS_ERR(ipu))
-			BUG();
+			dev_err(t->dev, "no:0x%x,found_vdoa:%d, ipu:%d\n",
+				 t->task_no, found_vdoa, i);
 
 		used = &tbl->used[i][IPU_PP_CH_VF];
 		if (t->set.mode & VDI_MODE) {
@@ -1172,15 +1198,17 @@ static int _get_vdoa_ipu_res(struct ipu_task_entry *t)
 				break;
 			}
 		} else
-			BUG();
+			dev_err(t->dev, "no:0x%x,found_vdoa:%d, mode:0x%x\n",
+				 t->task_no, found_vdoa, t->set.mode);
 	}
 	if (found_ipu)
 		goto next;
 
-	for (i = 0; i < MXC_IPU_MAX_NUM; i++) {
+	for (i = 0; i < max_ipu_no; i++) {
 		ipu = ipu_get_soc(i);
 		if (IS_ERR(ipu))
-			BUG();
+			dev_err(t->dev, "no:0x%x,found_vdoa:%d, ipu:%d\n",
+				 t->task_no, found_vdoa, i);
 
 		if ((t->set.mode & IC_MODE) || only_rot(t->set.mode)) {
 			used = &tbl->used[i][IPU_PP_CH_PP];
@@ -1203,7 +1231,9 @@ next:
 		t->ipu_id = i;
 		t->dev = ipu->dev;
 		if (atomic_inc_return(&t->res_get) == 2)
-			BUG();
+			dev_err(t->dev,
+				"ERR no:0x%x,found_vdoa:%d,get ipu twice\n",
+				 t->task_no, found_vdoa);
 	}
 out:
 	dev_dbg(t->dev,
@@ -1224,12 +1254,12 @@ static void put_vdoa_ipu_res(struct ipu_task_entry *tsk, int vdoa_only)
 	int rel_vdoa = 0, rel_ipu = 0;
 	struct ipu_channel_tabel	*tbl = &ipu_ch_tbl;
 
-	if (!tsk)
-		BUG();
 	mutex_lock(&tbl->lock);
 	if (tsk->set.mode & VDOA_MODE) {
 		if (!tbl->vdoa_used && tsk->vdoa_handle)
-			BUG();
+			dev_err(tsk->dev,
+				"ERR no:0x%x,vdoa not used,mode:0x%x\n",
+				 tsk->task_no, tsk->set.mode);
 		if (tbl->vdoa_used && tsk->vdoa_handle) {
 			tbl->vdoa_used = 0;
 			vdoa_put_handle(&tsk->vdoa_handle);
@@ -1241,13 +1271,13 @@ static void put_vdoa_ipu_res(struct ipu_task_entry *tsk, int vdoa_only)
 		}
 	}
 
-	if (tsk) {
-		tbl->used[tsk->ipu_id][tsk->task_id - 1] = 0;
-		rel_ipu = 1;
-		ret = atomic_inc_return(&tsk->res_free);
-		if (ret == 2)
-			BUG();
-	}
+	tbl->used[tsk->ipu_id][tsk->task_id - 1] = 0;
+	rel_ipu = 1;
+	ret = atomic_inc_return(&tsk->res_free);
+	if (ret == 2)
+		dev_err(tsk->dev,
+			"ERR no:0x%x,rel_vdoa:%d,put ipu twice\n",
+			 tsk->task_no, rel_vdoa);
 out:
 	dev_dbg(tsk->dev,
 		"%s:no:0x%x,rel_vdoa:%d, rel_ipu:%d\n",
@@ -1278,12 +1308,16 @@ static int get_vdoa_ipu_res(struct ipu_task_entry *t)
 			goto out;
 		} else {
 			if (!(t->set.task & VDOA_ONLY) && (!t->ipu))
-				BUG();
+				dev_err(t->dev,
+					"ERR[no-0x%x] can not get ipu!\n",
+					t->task_no);
 			ret = atomic_read(&req_cnt);
 			if (ret > 0)
 				ret = atomic_dec_return(&req_cnt);
 			else
-				BUG();
+				dev_err(t->dev,
+					"ERR[no-0x%x] req_cnt:%d mismatch!\n",
+					t->task_no, ret);
 			dev_dbg(t->dev, "no-0x%x,[0x%p],req_cnt:%d, got_res!\n",
 						t->task_no, t, ret);
 			found = 1;
@@ -1705,7 +1739,7 @@ static int init_tiled_buf(struct ipu_soc *ipu, struct ipu_task_entry *t,
 		return -EINVAL;
 	else if (param.band_mode)
 		param.band_lines = (1 << t->set.band_lines);
-	for (i = 0; i < MXC_IPU_MAX_NUM; i++) {
+	for (i = 0; i < max_ipu_no; i++) {
 		ipu_idx = ipu_get_soc(i);
 		if (!IS_ERR(ipu_idx) && ipu_idx == ipu)
 			break;
@@ -1713,7 +1747,7 @@ static int init_tiled_buf(struct ipu_soc *ipu, struct ipu_task_entry *t,
 	if (t->set.task & VDOA_ONLY)
 		/* dummy, didn't need ipu res */
 		i = 0;
-	if (MXC_IPU_MAX_NUM == i) {
+	if (max_ipu_no == i) {
 		dev_err(t->dev, "ERR:[0x%p] get ipu num\n", t);
 		return -EINVAL;
 	}
@@ -1750,7 +1784,9 @@ static int init_tiled_buf(struct ipu_soc *ipu, struct ipu_task_entry *t,
 			return -EINVAL;
 		}
 	}
-	vdoa_setup(t->vdoa_handle, &param);
+	ret = vdoa_setup(t->vdoa_handle, &param);
+	if (ret)
+		goto done;
 	vdoa_get_output_buf(t->vdoa_handle, &buf);
 	if (t->set.task & VDOA_ONLY)
 		goto done;
@@ -1803,7 +1839,8 @@ static int init_tiled_ch_bufs(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		CHECK_RETCODE(ret < 0, "init tiled_ch-n", t->state, done, ret);
 	} else {
 		ret = -EINVAL;
-		BUG();
+		dev_err(t->dev, "ERR[no-0x%x] invalid fmt:0x%x!\n",
+			t->task_no, t->input.format);
 	}
 
 done:
@@ -1820,6 +1857,7 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	int out_uoff = 0, out_voff = 0, out_rot;
 	int out_w = 0, out_h = 0, out_stride;
 	int out_fmt;
+	u32 vdi_frame_idx = 0;
 
 	memset(&params, 0, sizeof(params));
 
@@ -1863,8 +1901,9 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		params.mem_prp_vf_mem.graphics_combine_en = 1;
 		if (t->overlay.alpha.mode == IPU_ALPHA_MODE_GLOBAL)
 			params.mem_prp_vf_mem.global_alpha_en = 1;
-		else
+		else if (t->overlay.alpha.loc_alp_paddr)
 			params.mem_prp_vf_mem.alpha_chan_en = 1;
+		/* otherwise, alpha bending per pixel is used. */
 		params.mem_prp_vf_mem.alpha = t->overlay.alpha.gvalue;
 		if (t->overlay.colorkey.enable) {
 			params.mem_prp_vf_mem.key_color_en = 1;
@@ -1872,6 +1911,19 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		}
 	}
 
+	if (t->input.deinterlace.enable) {
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_FIELD_MASK)
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_BOTTOM;
+		else
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_TOP;
+
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+			vdi_frame_idx = t->input.deinterlace.field_fmt &
+						IPU_DEINTERLACE_RATE_FRAME1;
+	}
+
 	if (t->set.mode & VDOA_MODE)
 		ipu->vdoa_en = 1;
 
@@ -1885,12 +1937,6 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	}
 
 	if (deinterlace_3_field(t)) {
-		if (IPU_DEINTERLACE_FIELD_TOP == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_TB;
-		else if (IPU_DEINTERLACE_FIELD_BOTTOM == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_BT;
-		else
-			BUG();
 		ret = ipu_init_channel(ipu, t->set.vdi_ic_p_chan, &params);
 		if (ret < 0) {
 			t->state = STATE_INIT_CHAN_FAIL;
@@ -1912,13 +1958,57 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	} else {
 		if ((deinterlace_3_field(t)) &&
 			(IPU_PIX_FMT_TILED_NV12F != t->input.format)) {
-				inbuf_p = t->input.paddr + t->set.istride +
-						t->set.i_off;
-				inbuf = t->input.paddr_n + t->set.i_off;
-				inbuf_n = t->input.paddr_n + t->set.istride +
-						t->set.i_off;
-		} else
-			inbuf = t->input.paddr + t->set.i_off;
+			if (params.mem_prp_vf_mem.field_fmt ==
+				IPU_DEINTERLACE_FIELD_TOP) {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_BOTTOM;
+				} else {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+				}
+			} else {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_TOP;
+				} else {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+				}
+			}
+		} else {
+			if (t->input.deinterlace.enable) {
+				if (params.mem_prp_vf_mem.field_fmt ==
+					IPU_DEINTERLACE_FIELD_TOP) {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_BOTTOM;
+					} else
+						inbuf = t->input.paddr + t->set.i_off;
+				} else {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_TOP;
+					} else
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+				}
+			} else
+				inbuf = t->input.paddr + t->set.i_off;
+		}
 
 		if (t->overlay_en)
 			ovbuf = t->overlay.paddr + t->set.ov_off;
@@ -2208,8 +2298,10 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	unsigned char  *base_off;
 	struct ipu_task_entry *parent = t->parent;
 
-	if (!parent)
-		BUG();
+	if (!parent) {
+		dev_err(t->dev, "ERR[0x%x]invalid parent\n", t->task_no);
+		return;
+	}
 	stripe_mode = t->task_no & 0xf;
 	task_no = t->task_no >> 4;
 
@@ -2520,13 +2612,15 @@ static void do_task(struct ipu_task_entry *t)
 		busy = ic_vf_pp_is_busy(ipu, true);
 	else if (t->task_id == IPU_TASK_ID_PP)
 		busy = ic_vf_pp_is_busy(ipu, false);
-	else
-		BUG();
+	else {
+		dev_err(ipu->dev, "ERR[no:0x%x]ipu task_id:%d invalid!\n",
+				t->task_no, t->task_id);
+		return;
+	}
 	if (busy) {
 		dev_err(ipu->dev, "ERR[0x%p-no:0x%x]ipu task_id:%d busy!\n",
 				(void *)t, t->task_no, t->task_id);
 		t->state = STATE_IPU_BUSY;
-		BUG();
 		return;
 	}
 
@@ -2578,7 +2672,7 @@ static void do_task(struct ipu_task_entry *t)
 			ipu->rot_dma[rot_idx].vaddr = dma_alloc_coherent(t->dev,
 						r_size,
 						&ipu->rot_dma[rot_idx].paddr,
-						GFP_KERNEL);
+						GFP_DMA | GFP_KERNEL);
 			CHECK_RETCODE(ipu->rot_dma[rot_idx].vaddr == NULL,
 					"ic_and_rot", STATE_SYS_NO_MEM,
 					chan_setup, -ENOMEM);
@@ -2605,7 +2699,6 @@ static void do_task(struct ipu_task_entry *t)
 	} else {
 		dev_err(t->dev, "ERR [0x%p]do task: should not be here\n", t);
 		t->state = STATE_ERR;
-		BUG();
 		return;
 	}
 
@@ -2808,13 +2901,15 @@ static void get_res_do_task(struct ipu_task_entry *t)
 
 	found = get_vdoa_ipu_res(t);
 	if (!found) {
-		BUG();
+		dev_err(t->dev, "ERR:[0x%p] no-0x%x can not get res\n",
+			t, t->task_no);
+		return;
 	} else {
 		if (t->set.task & VDOA_ONLY)
 			do_task_vdoa_only(t);
 		else if ((IPU_PIX_FMT_TILED_NV12F == t->input.format) &&
 				(t->set.mode & VDOA_BAND_MODE) &&
-				(t->input.crop.w > soc_max_out_width()))
+				(t->input.crop.w > soc_max_vdi_in_width()))
 			do_task_vdoa_vdi(t);
 		else
 			do_task(t);
@@ -2862,12 +2957,18 @@ static void wait_split_task_complete(struct ipu_task_entry *parent,
 			ret = -ETIMEDOUT;
 			goto out;
 		} else {
-			if (idx < 0)
-				BUG();
+			if (idx < 0) {
+				dev_err(parent->dev,
+				"ERR:[0x%p] no-0x%x, invalid task idx:%d\n",
+				 parent, parent->task_no, idx);
+				continue;
+			}
 			tsk = sp_task[idx].child_task;
 			mutex_lock(lock);
 			if (!tsk->split_done || !tsk->ipu)
-				BUG();
+				dev_err(tsk->dev,
+				"ERR:no-0x%x,split not done:%d/null ipu:0x%p\n",
+				 tsk->task_no, tsk->split_done, tsk->ipu);
 			tsk->split_done = 0;
 			mutex_unlock(lock);
 
@@ -2884,10 +2985,11 @@ static void wait_split_task_complete(struct ipu_task_entry *parent,
 out:
 	if (ret == -ETIMEDOUT) {
 		/* debug */
-		for (k = 0; k < MXC_IPU_MAX_NUM; k++) {
+		for (k = 0; k < max_ipu_no; k++) {
 			ipu = ipu_get_soc(k);
 			if (IS_ERR(ipu)) {
-				BUG();
+				dev_err(parent->dev, "no:0x%x, null ipu:%d\n",
+				 parent->task_no, k);
 			} else {
 				busy_vf = ic_vf_pp_is_busy(ipu, true);
 				busy_pp = ic_vf_pp_is_busy(ipu, false);
@@ -2964,7 +3066,9 @@ static inline int find_task(struct ipu_task_entry **t, int thread_id)
 			"thread_id:%d,[0x%p] task_no:0x%x,mode:0x%x list_del\n",
 			thread_id, tsk, tsk->task_no, tsk->set.mode);
 		} else
-			BUG();
+			dev_err(tsk->dev,
+			"thread_id:%d,task_no:0x%x,mode:0x%x not on list_del\n",
+			thread_id, tsk->task_no, tsk->set.mode);
 	}
 	spin_unlock_irqrestore(&ipu_task_list_lock, flags);
 
@@ -2999,7 +3103,6 @@ static int ipu_task_thread(void *argv)
 			&cpu_mask);
 		if (ret < 0) {
 			pr_err("%s: sched_setaffinity fail:%d.\n", __func__, ret);
-			BUG();
 		}
 		pr_debug("%s: sched_setaffinity cpu:%d.\n", __func__, cpu);
 	}
@@ -3011,8 +3114,11 @@ static int ipu_task_thread(void *argv)
 
 		wait_event(thread_waitq, find_task(&tsk, curr_thread_id));
 
-		if (!tsk)
-			BUG();
+		if (!tsk) {
+			pr_err("thread:%d can not find task.\n",
+				curr_thread_id);
+			continue;
+		}
 
 		/* note: other threads run split child task */
 		split_parent = need_split(tsk) && !tsk->parent;
@@ -3055,7 +3161,9 @@ static int ipu_task_thread(void *argv)
 				/* FIXME: ensure the correct sequence for split
 					4size: 5/6->9/a*/
 				if (!sp_tsk0)
-					BUG();
+					dev_err(tsk->dev,
+					"ERR: no-0x%x,can not get split_tsk0\n",
+					tsk->task_no);
 				wake_up(&thread_waitq);
 				get_res_do_task(sp_tsk0);
 				dev_dbg(sp_tsk0->dev,
@@ -3099,8 +3207,7 @@ static int ipu_task_thread(void *argv)
 		kref_put(&tsk->refcount, task_mem_free);
 	}
 
-	pr_info("%s exit.\n", __func__);
-	BUG();
+	pr_info("ERR %s exit.\n", __func__);
 	return 0;
 }
 
@@ -3222,6 +3329,7 @@ EXPORT_SYMBOL_GPL(ipu_queue_task);
 
 static int mxc_ipu_open(struct inode *inode, struct file *file)
 {
+	file->private_data = (void *)atomic_inc_return(&file_index);
 	return 0;
 }
 
@@ -3273,11 +3381,12 @@ static long mxc_ipu_ioctl(struct file *file,
 
 			mem->cpu_addr = dma_alloc_coherent(ipu_dev, size,
 							   &mem->phy_addr,
-							   GFP_KERNEL);
+							   GFP_DMA | GFP_KERNEL);
 			if (mem->cpu_addr == NULL) {
 				kfree(mem);
 				return -ENOMEM;
 			}
+			mem->file_index = file->private_data;
 			mutex_lock(&ipu_alloc_lock);
 			list_add(&mem->list, &ipu_alloc_list);
 			mutex_unlock(&ipu_alloc_lock);
@@ -3361,6 +3470,26 @@ static int mxc_ipu_mmap(struct file *file, struct vm_area_struct *vma)
 
 static int mxc_ipu_release(struct inode *inode, struct file *file)
 {
+	struct ipu_alloc_list *mem;
+	struct ipu_alloc_list *n;
+
+	mutex_lock(&ipu_alloc_lock);
+	list_for_each_entry_safe(mem, n, &ipu_alloc_list, list) {
+		if ((mem->cpu_addr != 0) &&
+			(file->private_data == mem->file_index)) {
+			list_del(&mem->list);
+			dma_free_coherent(ipu_dev,
+					  mem->size,
+					  mem->cpu_addr,
+					  mem->phy_addr);
+			dev_dbg(ipu_dev, "rel-free %d bytes @ 0x%08X\n",
+				mem->size, mem->phy_addr);
+			kfree(mem);
+		}
+	}
+	mutex_unlock(&ipu_alloc_lock);
+	atomic_dec(&file_index);
+
 	return 0;
 }
 
@@ -3404,6 +3533,7 @@ int register_ipu_device(struct ipu_soc *ipu, int id)
 
 		mutex_init(&ipu_ch_tbl.lock);
 	}
+	max_ipu_no = ++id;
 	ipu->rot_dma[0].size = 0;
 	ipu->rot_dma[1].size = 0;
 
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index a6576ae..210f011 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -19,9 +19,9 @@
  * @ingroup IPU
  */
 
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/io.h>
@@ -40,6 +40,7 @@ struct dp_csc_param_t {
 };
 
 #define SYNC_WAVE 0
+#define NULL_WAVE (-1)
 #define ASYNC_SER_WAVE 6
 
 /* DC display ID assignments */
@@ -175,44 +176,68 @@ static int _ipu_pixel_clk_set_parent(struct clk *clk, struct clk *parent)
 #else
 #define __INIT_CLK_DEBUG(n)
 #endif
-struct clk ipu_pixel_clk[] = {
+struct clk ipu_pixel_clk[MXC_IPU_MAX_NUM][MXC_DI_NUM_PER_IPU] = {
 	{
-		__INIT_CLK_DEBUG(pixel_clk_0)
-			.id = 0,
-		.get_rate = _ipu_pixel_clk_get_rate,
-		.set_rate = _ipu_pixel_clk_set_rate,
-		.round_rate = _ipu_pixel_clk_round_rate,
-		.set_parent = _ipu_pixel_clk_set_parent,
-		.enable = _ipu_pixel_clk_enable,
-		.disable = _ipu_pixel_clk_disable,
+		{
+		 __INIT_CLK_DEBUG(ipu1_pixel_clk_0)
+		 .id = 0,
+		 .get_rate = _ipu_pixel_clk_get_rate,
+		 .set_rate = _ipu_pixel_clk_set_rate,
+		 .round_rate = _ipu_pixel_clk_round_rate,
+		 .set_parent = _ipu_pixel_clk_set_parent,
+		 .enable = _ipu_pixel_clk_enable,
+		 .disable = _ipu_pixel_clk_disable,
+		},
+		{
+		 __INIT_CLK_DEBUG(ipu1_pixel_clk_1)
+		 .id = 1,
+		 .get_rate = _ipu_pixel_clk_get_rate,
+		 .set_rate = _ipu_pixel_clk_set_rate,
+		 .round_rate = _ipu_pixel_clk_round_rate,
+		 .set_parent = _ipu_pixel_clk_set_parent,
+		 .enable = _ipu_pixel_clk_enable,
+		 .disable = _ipu_pixel_clk_disable,
+		},
 	},
 	{
-		__INIT_CLK_DEBUG(pixel_clk_1)
-			.id = 1,
-		.get_rate = _ipu_pixel_clk_get_rate,
-		.set_rate = _ipu_pixel_clk_set_rate,
-		.round_rate = _ipu_pixel_clk_round_rate,
-		.set_parent = _ipu_pixel_clk_set_parent,
-		.enable = _ipu_pixel_clk_enable,
-		.disable = _ipu_pixel_clk_disable,
+		{
+		 __INIT_CLK_DEBUG(ipu2_pixel_clk_0)
+		 .id = 0,
+		 .get_rate = _ipu_pixel_clk_get_rate,
+		 .set_rate = _ipu_pixel_clk_set_rate,
+		 .round_rate = _ipu_pixel_clk_round_rate,
+		 .set_parent = _ipu_pixel_clk_set_parent,
+		 .enable = _ipu_pixel_clk_enable,
+		 .disable = _ipu_pixel_clk_disable,
+		},
+		{
+		 __INIT_CLK_DEBUG(ipu2_pixel_clk_1)
+		 .id = 1,
+		 .get_rate = _ipu_pixel_clk_get_rate,
+		 .set_rate = _ipu_pixel_clk_set_rate,
+		 .round_rate = _ipu_pixel_clk_round_rate,
+		 .set_parent = _ipu_pixel_clk_set_parent,
+		 .enable = _ipu_pixel_clk_enable,
+		 .disable = _ipu_pixel_clk_disable,
+		},
 	},
 };
 
-struct clk_lookup ipu_lookups[MXC_IPU_MAX_NUM][2] = {
+struct clk_lookup ipu_lookups[MXC_IPU_MAX_NUM][MXC_DI_NUM_PER_IPU] = {
 	{
 		{
-			.con_id = "pixel_clk_0",
+			.con_id = "ipu1_pixel_clk_0",
 		},
 		{
-			.con_id = "pixel_clk_1",
+			.con_id = "ipu1_pixel_clk_1",
 		},
 	},
 	{
 		{
-			.con_id = "pixel_clk_0",
+			.con_id = "ipu2_pixel_clk_0",
 		},
 		{
-			.con_id = "pixel_clk_1",
+			.con_id = "ipu2_pixel_clk_1",
 		},
 	},
 };
@@ -770,7 +795,7 @@ void _ipu_dc_init(struct ipu_soc *ipu, int dc_chan, int di, bool interlaced, uin
 			if (di) {
 				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NL, 2, 3);
 				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_EOL, 3, 2);
-				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NEW_DATA, 4, 1);
+				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NEW_DATA, 1, 1);
 				if ((pixel_fmt == IPU_PIX_FMT_YUYV) ||
 				(pixel_fmt == IPU_PIX_FMT_UYVY) ||
 				(pixel_fmt == IPU_PIX_FMT_YVYU) ||
@@ -781,7 +806,7 @@ void _ipu_dc_init(struct ipu_soc *ipu, int dc_chan, int di, bool interlaced, uin
 			} else {
 				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NL, 5, 3);
 				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_EOL, 6, 2);
-				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NEW_DATA, 7, 1);
+				_ipu_dc_link_event(ipu, dc_chan, DC_EVT_NEW_DATA, 12, 1);
 				if ((pixel_fmt == IPU_PIX_FMT_YUYV) ||
 				(pixel_fmt == IPU_PIX_FMT_UYVY) ||
 				(pixel_fmt == IPU_PIX_FMT_YVYU) ||
@@ -885,6 +910,9 @@ void _ipu_dp_dc_enable(struct ipu_soc *ipu, ipu_channel_t channel)
 		reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
 		ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
 		return;
+	} else if (channel == MEM_BG_SYNC) {
+		reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+		ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
 	}
 
 	di = ipu->dc_di_assignment[dc_chan];
@@ -998,10 +1026,7 @@ void _ipu_dp_dc_disable(struct ipu_soc *ipu, ipu_channel_t channel, bool swap)
 		reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
 		reg ^= DC_WR_CH_CONF_PROG_DI_ID;
 		ipu_dc_write(ipu, reg, DC_WR_CH_CONF(dc_chan));
-	} else
-		/* Clock is already off because it must be done quickly, but
-		   we need to fix the ref count */
-		clk_disable(&ipu->pixel_clk[ipu->dc_di_assignment[dc_chan]]);
+	}
 }
 
 void _ipu_init_dc_mappings(struct ipu_soc *ipu)
@@ -1274,7 +1299,7 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 	/* Get integer portion of divider */
 	div = clk_get_rate(clk_get_parent(&ipu->pixel_clk[disp])) / rounded_pixel_clk;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	_ipu_di_data_wave_config(ipu, disp, SYNC_WAVE, div - 1, div - 1);
 	_ipu_di_data_pin_config(ipu, disp, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
@@ -1282,7 +1307,7 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 	map = _ipu_pixfmt_to_map(pixel_fmt);
 	if (map < 0) {
 		dev_dbg(ipu->dev, "IPU_DISP: No MAP\n");
-		_ipu_unlock(ipu);
+		mutex_unlock(&ipu->mutex_lock);
 		return -EINVAL;
 	}
 
@@ -1617,8 +1642,10 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 				ipu_dc_write(ipu, (width - 1), DC_UGDE_3(disp));
 			}
 			_ipu_dc_write_tmpl(ipu, 2, WROD(0), 0, map, SYNC_WAVE, 8, 5, 1);
-			_ipu_dc_write_tmpl(ipu, 3, WRG, 0, map, SYNC_WAVE, 4, 5, 1);
-			_ipu_dc_write_tmpl(ipu, 4, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);
+			_ipu_dc_write_tmpl(ipu, 3, WROD(0), 0, map, SYNC_WAVE, 4, 5, 0);
+			_ipu_dc_write_tmpl(ipu, 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);
+			_ipu_dc_write_tmpl(ipu, 1, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);
+
 		} else {
 			if ((pixel_fmt == IPU_PIX_FMT_YUYV) ||
 				(pixel_fmt == IPU_PIX_FMT_UYVY) ||
@@ -1630,8 +1657,9 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 				ipu_dc_write(ipu, width - 1, DC_UGDE_3(disp));
 			}
 		   _ipu_dc_write_tmpl(ipu, 5, WROD(0), 0, map, SYNC_WAVE, 8, 5, 1);
-		   _ipu_dc_write_tmpl(ipu, 6, WRG, 0, map, SYNC_WAVE, 4, 5, 1);
-		   _ipu_dc_write_tmpl(ipu, 7, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);
+		   _ipu_dc_write_tmpl(ipu, 6, WROD(0), 0, map, SYNC_WAVE, 4, 5, 0);
+		   _ipu_dc_write_tmpl(ipu, 7, WRG, 0, map, NULL_WAVE, 0, 0, 1);
+		   _ipu_dc_write_tmpl(ipu, 12, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);
 		}
 
 		if (sig.Hsync_pol) {
@@ -1669,7 +1697,7 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 
 	ipu_dc_write(ipu, width, DC_DISP_CONF2(DC_DISP_ID_SYNC(disp)));
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	return 0;
 }
@@ -1683,7 +1711,7 @@ void ipu_uninit_sync_panel(struct ipu_soc *ipu, int disp)
 	if ((disp != 0) || (disp != 1))
 		return;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	di_gen = ipu_di_read(ipu, disp, DI_GENERAL);
 	di_gen |= 0x3ff | DI_GEN_POLARITY_DISP_CLK;
@@ -1693,7 +1721,7 @@ void ipu_uninit_sync_panel(struct ipu_soc *ipu, int disp)
 	reg |= 0x3ffffff;
 	ipu_di_write(ipu, disp, reg, DI_POL);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 }
 EXPORT_SYMBOL(ipu_uninit_sync_panel);
 
@@ -1713,7 +1741,7 @@ int ipu_init_async_panel(struct ipu_soc *ipu, int disp, int type, uint32_t cycle
 	if (map < 0)
 		return -EINVAL;
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	if (type == IPU_PANEL_SERIAL) {
 		ipu_di_write(ipu, disp, (div << 24) | ((sig.ifc_width - 1) << 4),
@@ -1742,7 +1770,7 @@ int ipu_init_async_panel(struct ipu_soc *ipu, int disp, int type, uint32_t cycle
 		ipu_di_write(ipu, disp, ser_conf, DI_SER_CONF);
 	}
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	return 0;
 }
 EXPORT_SYMBOL(ipu_init_async_panel);
@@ -1786,7 +1814,7 @@ int32_t ipu_disp_set_global_alpha(struct ipu_soc *ipu, ipu_channel_t channel,
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	if (bg_chan) {
 		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
@@ -1811,7 +1839,7 @@ int32_t ipu_disp_set_global_alpha(struct ipu_soc *ipu, ipu_channel_t channel,
 	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
 	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 
@@ -1849,7 +1877,7 @@ int32_t ipu_disp_set_color_key(struct ipu_soc *ipu, ipu_channel_t channel,
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	ipu->color_key_4rgb = true;
 	/* Transform color key from rgb to yuv if CSC is enabled */
@@ -1888,7 +1916,7 @@ int32_t ipu_disp_set_color_key(struct ipu_soc *ipu, ipu_channel_t channel,
 	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
 	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 
@@ -1925,7 +1953,7 @@ int32_t ipu_disp_set_gamma_correction(struct ipu_soc *ipu, ipu_channel_t channel
 
 	_ipu_get(ipu);
 
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 
 	for (i = 0; i < 8; i++)
 		ipu_dp_write(ipu, (constk[2*i] & 0x1ff) | ((constk[2*i+1] & 0x1ff) << 16), DP_GAMMA_C(flow, i));
@@ -1946,7 +1974,7 @@ int32_t ipu_disp_set_gamma_correction(struct ipu_soc *ipu, ipu_channel_t channel
 	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
 	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
 
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 
 	_ipu_put(ipu);
 
@@ -2010,9 +2038,9 @@ int32_t ipu_disp_set_window_pos(struct ipu_soc *ipu, ipu_channel_t channel,
 	int ret;
 
 	_ipu_get(ipu);
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 	ret = _ipu_disp_set_window_pos(ipu, channel, x_pos, y_pos);
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	_ipu_put(ipu);
 	return ret;
 }
@@ -2046,9 +2074,9 @@ int32_t ipu_disp_get_window_pos(struct ipu_soc *ipu, ipu_channel_t channel,
 	int ret;
 
 	_ipu_get(ipu);
-	_ipu_lock(ipu);
+	mutex_lock(&ipu->mutex_lock);
 	ret = _ipu_disp_get_window_pos(ipu, channel, x_pos, y_pos);
-	_ipu_unlock(ipu);
+	mutex_unlock(&ipu->mutex_lock);
 	_ipu_put(ipu);
 	return ret;
 }
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
index 9e77153..a2f44e7 100644
--- a/drivers/mxc/ipu3/ipu_ic.c
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -69,6 +69,7 @@ void _ipu_vdi_set_motion(struct ipu_soc *ipu, ipu_motion_sel motion_sel)
 		reg |= VDI_C_MOT_SEL_LOW;
 
 	ipu_vdi_write(ipu, reg, VDI_C);
+	dev_dbg(ipu->dev, "VDI_C = \t0x%08X\n", reg);
 }
 
 void ic_dump_register(struct ipu_soc *ipu)
@@ -215,10 +216,10 @@ void _ipu_vdi_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_param
 	}
 	ipu_vdi_write(ipu, reg, VDI_C);
 
-	if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_TB)
-		_ipu_vdi_set_top_field_man(ipu, false);
-	else if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_BT)
+	if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_TOP)
 		_ipu_vdi_set_top_field_man(ipu, true);
+	else if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_BOTTOM)
+		_ipu_vdi_set_top_field_man(ipu, false);
 
 	_ipu_vdi_set_motion(ipu, params->mem_prp_vf_mem.motion_sel);
 
@@ -240,7 +241,9 @@ void _ipu_ic_init_prpvf(struct ipu_soc *ipu, ipu_channel_params_t *params, bool
 	ipu_color_space_t in_fmt, out_fmt;
 
 	/* Setup vertical resizing */
-	if (!(params->mem_prp_vf_mem.outv_resize_ratio)) {
+	if (!(params->mem_prp_vf_mem.outv_resize_ratio) ||
+		(params->mem_prp_vf_mem.outv_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_prp_vf_mem.in_height,
 				params->mem_prp_vf_mem.out_height,
 				&resizeCoeff, &downsizeCoeff);
@@ -250,7 +253,9 @@ void _ipu_ic_init_prpvf(struct ipu_soc *ipu, ipu_channel_params_t *params, bool
 
 	/* Setup horizontal resizing */
 	/* Upadeted for IC split case */
-	if (!(params->mem_prp_vf_mem.outh_resize_ratio)) {
+	if (!(params->mem_prp_vf_mem.outh_resize_ratio) ||
+		(params->mem_prp_vf_mem.outh_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_prp_vf_mem.in_width,
 				params->mem_prp_vf_mem.out_width,
 				&resizeCoeff, &downsizeCoeff);
@@ -365,7 +370,9 @@ void _ipu_ic_init_prpenc(struct ipu_soc *ipu, ipu_channel_params_t *params, bool
 	ipu_color_space_t in_fmt, out_fmt;
 
 	/* Setup vertical resizing */
-	if (!(params->mem_prp_enc_mem.outv_resize_ratio)) {
+	if (!(params->mem_prp_enc_mem.outv_resize_ratio) ||
+		(params->mem_prp_enc_mem.outv_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_prp_enc_mem.in_height,
 				params->mem_prp_enc_mem.out_height,
 				&resizeCoeff, &downsizeCoeff);
@@ -375,7 +382,9 @@ void _ipu_ic_init_prpenc(struct ipu_soc *ipu, ipu_channel_params_t *params, bool
 
 	/* Setup horizontal resizing */
 	/* Upadeted for IC split case */
-	if (!(params->mem_prp_enc_mem.outh_resize_ratio)) {
+	if (!(params->mem_prp_enc_mem.outh_resize_ratio) ||
+		(params->mem_prp_enc_mem.outh_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_prp_enc_mem.in_width,
 				params->mem_prp_enc_mem.out_width,
 				&resizeCoeff, &downsizeCoeff);
@@ -444,7 +453,9 @@ void _ipu_ic_init_pp(struct ipu_soc *ipu, ipu_channel_params_t *params)
 	ipu_color_space_t in_fmt, out_fmt;
 
 	/* Setup vertical resizing */
-	if (!(params->mem_pp_mem.outv_resize_ratio)) {
+	if (!(params->mem_pp_mem.outv_resize_ratio) ||
+		(params->mem_pp_mem.outv_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_pp_mem.in_height,
 			    params->mem_pp_mem.out_height,
 			    &resizeCoeff, &downsizeCoeff);
@@ -455,7 +466,9 @@ void _ipu_ic_init_pp(struct ipu_soc *ipu, ipu_channel_params_t *params)
 
 	/* Setup horizontal resizing */
 	/* Upadeted for IC split case */
-	if (!(params->mem_pp_mem.outh_resize_ratio)) {
+	if (!(params->mem_pp_mem.outh_resize_ratio) ||
+		(params->mem_pp_mem.outh_resize_ratio >=
+						IC_RSZ_MAX_RESIZE_RATIO)) {
 		_calc_resize_coeffs(ipu, params->mem_pp_mem.in_width,
 							params->mem_pp_mem.out_width,
 							&resizeCoeff, &downsizeCoeff);
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
index 8ae0a5e..1387c49 100644
--- a/drivers/mxc/ipu3/ipu_param_mem.h
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -415,6 +415,14 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 		u_offset = (u == 0) ? stride * height : u;
 		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
 		break;
+	case IPU_PIX_FMT_YUV444P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		uv_stride = stride;
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset * 2 : v;
+		break;
 	case IPU_PIX_FMT_NV12:
 		/* BPP & pixel format */
 		ipu_ch_param_set_field(&params, 1, 85, 4, 4);	/* pix format */
@@ -469,13 +477,17 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 	dev_dbg(ipu->dev, "initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ipu, ch));
 	fill_cpmem(ipu, ch, &params);
 	if (addr2) {
-		ipu_ch_param_set_field(&params, 1, 0, 29, addr2 >> 3);
-		ipu_ch_param_set_field(&params, 1, 29, 29, 0);
-
 		sub_ch = __ipu_ch_get_third_buf_cpmem_num(ch);
 		if (sub_ch <= 0)
 			return;
 
+		ipu_ch_param_set_field(&params, 1, 0, 29, addr2 >> 3);
+		ipu_ch_param_set_field(&params, 1, 29, 29, 0);
+		if (addr2%8)
+			dev_warn(ipu->dev,
+				 "IDMAC%d's sub-CPMEM entry%d EBA0 is not "
+				 "8-byte aligned\n", ch, sub_ch);
+
 		dev_dbg(ipu->dev, "initializing idma ch %d @ %p sub cpmem\n", ch,
 					ipu_ch_param_addr(ipu, sub_ch));
 		fill_cpmem(ipu, sub_ch, &params);
@@ -773,6 +785,24 @@ static inline void _ipu_ch_offset_update(struct ipu_soc *ipu,
 					v_offset;
 		break;
 
+	case IPU_PIX_FMT_YUV444P:
+		uv_stride = stride;
+		u_offset = stride * (height - vertical_offset - 1) +
+					(stride - horizontal_offset) +
+					(uv_stride * vertical_offset) +
+					horizontal_offset;
+		v_offset = u_offset + uv_stride * height;
+		u_fix = u ? (u + (uv_stride * vertical_offset) +
+					horizontal_offset -
+					(stride * vertical_offset) -
+					(horizontal_offset)) :
+					u_offset;
+		v_fix = v ? (v + (uv_stride * vertical_offset) +
+					horizontal_offset -
+					(stride * vertical_offset) -
+					(horizontal_offset)) :
+					v_offset;
+		break;
 	case IPU_PIX_FMT_NV12:
 		uv_stride = stride;
 		u_offset = stride * (height - vertical_offset - 1) +
diff --git a/drivers/mxc/ipu3/ipu_prv.h b/drivers/mxc/ipu3/ipu_prv.h
index 91d9e73..a0d71dd 100644
--- a/drivers/mxc/ipu3/ipu_prv.h
+++ b/drivers/mxc/ipu3/ipu_prv.h
@@ -20,16 +20,13 @@
 #include <linux/interrupt.h>
 #include <linux/fsl_devices.h>
 
-#ifdef CONFIG_MXC_IPU_V3H
-#define MXC_IPU_MAX_NUM	2
-#else
-#define MXC_IPU_MAX_NUM	1
-#endif
+#define MXC_IPU_MAX_NUM		2
+#define MXC_DI_NUM_PER_IPU	2
 
 /* Globals */
 extern int dmfc_type_setup;
-extern struct clk ipu_pixel_clk[];
-extern struct clk_lookup ipu_lookups[MXC_IPU_MAX_NUM][2];
+extern struct clk ipu_pixel_clk[MXC_IPU_MAX_NUM][MXC_DI_NUM_PER_IPU];
+extern struct clk_lookup ipu_lookups[MXC_IPU_MAX_NUM][MXC_DI_NUM_PER_IPU];
 
 #define IDMA_CHAN_INVALID	0xFF
 #define HIGH_RESOLUTION_WIDTH	1024
@@ -103,7 +100,8 @@ struct ipu_soc {
 	int csi_use_count[2];
 
 	struct mutex mutex_lock;
-	spinlock_t spin_lock;
+	spinlock_t int_reg_spin_lock;
+	spinlock_t rdy_reg_spin_lock;
 
 	int dmfc_size_28;
 	int dmfc_size_29;
@@ -325,6 +323,4 @@ int32_t _ipu_disp_get_window_pos(struct ipu_soc *ipu, ipu_channel_t channel,
 		int16_t *x_pos, int16_t *y_pos);
 void _ipu_get(struct ipu_soc *ipu);
 void _ipu_put(struct ipu_soc *ipu);
-void _ipu_lock(struct ipu_soc *ipu);
-void _ipu_unlock(struct ipu_soc *ipu);
 #endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu3/ipu_regs.h b/drivers/mxc/ipu3/ipu_regs.h
index c06ac9f..458b0e0 100644
--- a/drivers/mxc/ipu3/ipu_regs.h
+++ b/drivers/mxc/ipu3/ipu_regs.h
@@ -28,6 +28,9 @@
  */
 extern int g_ipu_hw_rev;
 
+#define IPU_MAX_VDI_IN_WIDTH	({g_ipu_hw_rev >= 3 ? \
+				   (968) : \
+				   (720); })
 #define IPU_DISP0_BASE		0x00000000
 #define IPU_MCU_T_DEFAULT	8
 #define IPU_DISP1_BASE		({g_ipu_hw_rev < 4 ? \
@@ -456,6 +459,8 @@ enum {
 	IC_CONF_RWS_EN = 0x40000000,
 	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
 
+	IC_RSZ_MAX_RESIZE_RATIO = 0x00004000,
+
 	IC_IDMAC_1_CB0_BURST_16 = 0x00000001,
 	IC_IDMAC_1_CB1_BURST_16 = 0x00000002,
 	IC_IDMAC_1_CB2_BURST_16 = 0x00000004,
diff --git a/drivers/mxc/ipu3/vdoa.c b/drivers/mxc/ipu3/vdoa.c
index 967611f..22f24e7 100644
--- a/drivers/mxc/ipu3/vdoa.c
+++ b/drivers/mxc/ipu3/vdoa.c
@@ -26,10 +26,10 @@
 #include <linux/iram_alloc.h>
 
 #include "vdoa.h"
-/* FIXME: use cmdline to specify the iram size */
 /* 6band(3field* double buffer) * (width*2) * bandline(8)
 	= 6x1024x2x8 = 96k or 72k(1.5byte) */
-#define VDOA_IRAM_SIZE	(1024*96)
+#define MAX_VDOA_IRAM_SIZE	(1024*96)
+#define VDOA_IRAM_SIZE		(1024*72)
 
 #define VDOAC_BAND_HEIGHT_32LINES	(32)
 #define VDOAC_BAND_HEIGHT_16LINES	(16)
@@ -124,6 +124,7 @@ struct vdoa_info {
 };
 
 static struct vdoa_info *g_vdoa;
+static unsigned long iram_size;
 static DEFINE_MUTEX(vdoa_lock);
 
 static inline void vdoa_read_register(struct vdoa_info *vdoa,
@@ -149,15 +150,16 @@ static void dump_registers(struct vdoa_info *vdoa)
 		vdoa_read_register(vdoa, i, &data);
 }
 
-void vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params)
+int vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params)
 {
 	int	band_size;
+	int	total_band_size = 0;
 	int	ipu_stride;
 	u32	data;
 	struct vdoa_info *vdoa = (struct vdoa_info *)handle;
 
 	CHECK_NULL_PTR(vdoa);
-	CHECK_STATE(VDOA_GET | VDOA_GET_OBUF | VDOA_STOP, return);
+	CHECK_STATE(VDOA_GET | VDOA_GET_OBUF | VDOA_STOP, return -EINVAL);
 	if (VDOA_GET == vdoa->state) {
 		dev_dbg(vdoa->dev, "w:%d, h:%d.\n",
 			 params->width, params->height);
@@ -194,6 +196,12 @@ void vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params)
 		band_size = ((params->width * 3) >> 1) *
 						params->band_lines;
 	if (params->interlaced) {
+		total_band_size = 6 * band_size; /* 3 frames*double buffer */
+		if (iram_size < total_band_size) {
+			dev_err(vdoa->dev, "iram_size:0x%lx is smaller than "
+				"request:0x%x!\n", iram_size, total_band_size);
+			return -EINVAL;
+		}
 		if (params->vfield_buf.prev_veba) {
 			if (params->band_mode) {
 				vdoa_write_register(vdoa, VDOAIEBA00,
@@ -266,6 +274,7 @@ void vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params)
 					params->width * params->height);
 	}
 	vdoa->state = VDOA_SETUP;
+	return 0;
 }
 
 void vdoa_get_output_buf(vdoa_handle_t handle, struct vdoa_ipu_buf *buf)
@@ -331,7 +340,7 @@ void vdoa_stop(vdoa_handle_t handle)
 	struct vdoa_info *vdoa = (struct vdoa_info *)handle;
 
 	CHECK_NULL_PTR(vdoa);
-	CHECK_STATE(VDOA_START | VDOA_INIRQ, return);
+	CHECK_STATE(VDOA_GET | VDOA_START | VDOA_INIRQ, return);
 	vdoa->state = VDOA_STOP;
 
 	disable_irq(vdoa->irq);
@@ -395,6 +404,21 @@ static irqreturn_t vdoa_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+/* IRAM Size in Kbytes, example:vdoa_iram_size=64, 64KBytes */
+static int __init vdoa_iram_size_setup(char *options)
+{
+	int ret;
+
+	ret = strict_strtoul(options, 0, &iram_size);
+	if (ret)
+		iram_size = 0;
+	else
+		iram_size *= SZ_1K;
+
+	return 1;
+}
+__setup("vdoa_iram_size=", vdoa_iram_size_setup);
+
 static int vdoa_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -452,16 +476,16 @@ static int vdoa_probe(struct platform_device *pdev)
 		ret = PTR_ERR(vdoa->clk);
 		goto err_clk;
 	}
-
-	vdoa->iram_base = iram_alloc(VDOA_IRAM_SIZE, &vdoa->iram_paddr);
+	if ((iram_size == 0) || (iram_size > MAX_VDOA_IRAM_SIZE))
+		iram_size = VDOA_IRAM_SIZE;
+	vdoa->iram_base = iram_alloc(iram_size, &vdoa->iram_paddr);
 	if (!vdoa->iram_base) {
-		dev_err(dev, "failed to get iram memory:0x%x\n",
-				VDOA_IRAM_SIZE);
+		dev_err(dev, "failed to get iram memory:0x%lx\n", iram_size);
 		ret = -ENOMEM;
 		goto err_iram_alloc;
 	}
-	dev_dbg(dev, "iram_base:0x%p,iram_paddr:0x%lx,size:0x%x\n",
-		 vdoa->iram_base, vdoa->iram_paddr, VDOA_IRAM_SIZE);
+	dev_dbg(dev, "iram_base:0x%p,iram_paddr:0x%lx,size:0x%lx\n",
+		 vdoa->iram_base, vdoa->iram_paddr, iram_size);
 
 	vdoa->state = VDOA_INIT;
 	dev_set_drvdata(dev, vdoa);
@@ -492,7 +516,7 @@ static int __devexit vdoa_remove(struct platform_device *pdev)
 
 	clk_put(vdoa->clk);
 	clk_disable(vdoa->clk);
-	iram_free(vdoa->iram_paddr, VDOA_IRAM_SIZE);
+	iram_free(vdoa->iram_paddr, iram_size);
 	iounmap(vdoa->reg_base);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
diff --git a/drivers/mxc/ipu3/vdoa.h b/drivers/mxc/ipu3/vdoa.h
index 82b0ee1..23d7249 100644
--- a/drivers/mxc/ipu3/vdoa.h
+++ b/drivers/mxc/ipu3/vdoa.h
@@ -60,7 +60,7 @@ struct vdoa_ipu_buf {
 struct vdoa_info;
 typedef void *vdoa_handle_t;
 
-void vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params);
+int vdoa_setup(vdoa_handle_t handle, struct vdoa_params *params);
 void vdoa_get_output_buf(vdoa_handle_t handle, struct vdoa_ipu_buf *buf);
 int  vdoa_start(vdoa_handle_t handle, int timeout_ms);
 void vdoa_stop(vdoa_handle_t handle);
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
index e0c9e90..ef55d80 100644
--- a/include/linux/ipu.h
+++ b/include/linux/ipu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -139,6 +139,8 @@ typedef enum {
 #define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
 #define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
 #define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/* non-interleaved 4:4:4 */
+#define IPU_PIX_FMT_YUV444P fourcc('4', '4', '4', 'P')	/*!< 24 YUV 4:4:4 */
 /*! @} */
 #define IPU_PIX_FMT_TILED_NV12_MBALIGN	(16)
 #define TILED_NV12_FRAME_SIZE(w, h)	\
@@ -166,6 +168,14 @@ struct ipu_deinterlace {
 	u8	motion; /*see ipu_motion_sel*/
 #define IPU_DEINTERLACE_FIELD_TOP	0
 #define IPU_DEINTERLACE_FIELD_BOTTOM	1
+#define IPU_DEINTERLACE_FIELD_MASK	\
+		(IPU_DEINTERLACE_FIELD_TOP | IPU_DEINTERLACE_FIELD_BOTTOM)
+	/* deinterlace frame rate double flags */
+#define IPU_DEINTERLACE_RATE_EN		0x80
+#define IPU_DEINTERLACE_RATE_FRAME1	0x40
+#define IPU_DEINTERLACE_RATE_MASK	\
+		(IPU_DEINTERLACE_RATE_EN | IPU_DEINTERLACE_RATE_FRAME1)
+#define IPU_DEINTERLACE_MAX_FRAME	2
 	u8	field_fmt;
 };
 
-- 
1.7.5.4

