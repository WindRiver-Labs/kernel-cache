From 8bc733811e647a487e833fb5bba2847a4c6fa925 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <b02247@freescale.com>
Date: Mon, 12 Aug 2013 14:08:08 +0800
Subject: [PATCH 0506/1072] ENGR00274585-3 ASoC: fsl: add asrc p2p driver.

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit f2ac678211d5ec3966b33aa82ea59e965fa31379

add asrc p2p driver.
add bindings document of asrc p2p.

Signed-off-by: Shengjiu Wang <b02247@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 .../devicetree/bindings/sound/fsl-asrc-p2p.txt     |   23 +
 sound/soc/fsl/Kconfig                              |    3 +
 sound/soc/fsl/Makefile                             |    6 +-
 sound/soc/fsl/fsl_asrc.c                           |  490 ++++++++++++++++++++
 sound/soc/fsl/fsl_asrc.h                           |   48 ++
 sound/soc/fsl/fsl_asrc_pcm.c                       |   41 ++
 6 files changed, 610 insertions(+), 1 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/fsl-asrc-p2p.txt
 create mode 100644 sound/soc/fsl/fsl_asrc.c
 create mode 100644 sound/soc/fsl/fsl_asrc.h
 create mode 100644 sound/soc/fsl/fsl_asrc_pcm.c

diff --git a/Documentation/devicetree/bindings/sound/fsl-asrc-p2p.txt b/Documentation/devicetree/bindings/sound/fsl-asrc-p2p.txt
new file mode 100644
index 0000000..de48f05
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/fsl-asrc-p2p.txt
@@ -0,0 +1,23 @@
+* Freescale Asynchronous Sample Rate Converter (ASRC)
+
+This document is for asrc p2p node. p2p is one of asrc mode. asrc p2p depend on
+MXC_ASRC.
+
+Required properties:
+  - compatible: Should be "fsl,<chip>-asrc-p2p".
+  - fsl,output-rate: the output rate of asrc p2p. which can be <32000> to <192000>,
+  - fsl,output-width: the output width of asrc p2p. which can be <16>, <24>.
+  - fsl,asrc-dma-rx-events: The rx dma event of the asrc, <a b c> corresponding
+			    to 3 pair of asrc.
+  - fsl,asrc-dma-tx-events: The tx dma event of the esai, <a b c> corresponding
+			    to 3 pair of asrc.
+
+Example:
+asrc_p2p: asrc_p2p {
+	compatible = "fsl,imx6q-asrc-p2p";
+	fsl,output-rate  = <48000>;
+	fsl,output-width = <16>;
+	fsl,asrc-dma-rx-events = <17 18 19>;
+	fsl,asrc-dma-tx-events = <20 21 22>;
+	status = "okay";
+};
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index aa43854..50077f6 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -1,6 +1,9 @@
 config SND_SOC_FSL_SSI
 	tristate
 
+config SND_SOC_FSL_ASRC
+	tristate
+
 config SND_SOC_FSL_UTILS
 	tristate
 
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index d4b4aa8..5ae5380 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -10,11 +10,15 @@ obj-$(CONFIG_SND_SOC_P1022_DS) += snd-soc-p1022-ds.o
 snd-soc-p1022-rdk-objs := p1022_rdk.o
 obj-$(CONFIG_SND_SOC_P1022_RDK) += snd-soc-p1022-rdk.o
 
-# Freescale PowerPC SSI/DMA Platform Support
+# Freescale PowerPC SSI/DMA/ASRC Platform Support
 snd-soc-fsl-ssi-objs := fsl_ssi.o
+snd-soc-fsl-asrc-pcm-objs := fsl_asrc_pcm.o
+snd-soc-fsl-asrc-objs := fsl_asrc.o
 snd-soc-fsl-utils-objs := fsl_utils.o
 snd-soc-fsl-dma-objs := fsl_dma.o
 obj-$(CONFIG_SND_SOC_FSL_SSI) += snd-soc-fsl-ssi.o
+obj-$(CONFIG_SND_SOC_FSL_ASRC) += snd-soc-fsl-asrc-pcm.o
+obj-$(CONFIG_SND_SOC_FSL_ASRC) += snd-soc-fsl-asrc.o
 obj-$(CONFIG_SND_SOC_FSL_UTILS) += snd-soc-fsl-utils.o
 obj-$(CONFIG_SND_SOC_POWERPC_DMA) += snd-soc-fsl-dma.o
 
diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
new file mode 100644
index 0000000..13097a5
--- /dev/null
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_i2c.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/mxc_asrc.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "fsl_asrc.h"
+#include "imx-pcm.h"
+
+static bool filter(struct dma_chan *chan, void *param)
+{
+	if (!imx_dma_is_general_purpose(chan))
+		return false;
+
+	chan->private = param;
+
+	return true;
+}
+
+static int asrc_p2p_request_channel(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai     = rtd->cpu_dai;
+	struct fsl_asrc_p2p *asrc_p2p   = snd_soc_dai_get_drvdata(cpu_dai);
+	enum dma_slave_buswidth buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	struct snd_dmaengine_dai_dma_data *dma_params_be = NULL;
+	struct snd_dmaengine_dai_dma_data *dma_params_fe = NULL;
+	struct imx_dma_data *fe_filter_data = NULL;
+	struct imx_dma_data *be_filter_data = NULL;
+
+	struct dma_slave_config slave_config;
+	dma_cap_mask_t mask;
+	struct dma_chan *chan;
+	int ret;
+	struct snd_soc_dpcm *dpcm;
+
+	/* find the be for this fe stream */
+	list_for_each_entry(dpcm, &rtd->dpcm[substream->stream].be_clients, list_be) {
+		if (dpcm->fe == rtd) {
+			struct snd_soc_pcm_runtime *be = dpcm->be;
+			struct snd_soc_dai *dai = be->cpu_dai;
+			struct snd_pcm_substream *be_substream;
+			be_substream = snd_soc_dpcm_get_substream(be, substream->stream);
+			dma_params_be = snd_soc_dai_get_dma_data(dai, be_substream);
+			break;
+		}
+	}
+
+	if (!dma_params_be) {
+		dev_err(rtd->card->dev, "can not get be substream\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_params_fe = &asrc_p2p->dma_params_tx;
+	else
+		dma_params_fe = &asrc_p2p->dma_params_rx;
+
+	fe_filter_data = dma_params_fe->filter_data;
+	be_filter_data = dma_params_be->filter_data;
+
+	if (asrc_p2p->output_width == 16)
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	else
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	/* reconfig memory to FIFO dma request */
+	dma_params_fe->addr = asrc_p2p->asrc_ops.asrc_p2p_per_addr(
+						asrc_p2p->asrc_index, 1);
+	fe_filter_data->dma_request0 = asrc_p2p->dmarx[asrc_p2p->asrc_index];
+	dma_params_fe->maxburst = dma_params_be->maxburst;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_CYCLIC, mask);
+
+	/* config p2p dma channel */
+	asrc_p2p->asrc_p2p_dma_data.peripheral_type = IMX_DMATYPE_ASRC;
+	asrc_p2p->asrc_p2p_dma_data.priority        = DMA_PRIO_HIGH;
+	asrc_p2p->asrc_p2p_dma_data.dma_request1    = asrc_p2p->dmatx[asrc_p2p->asrc_index];
+	/* need to get target device's dma dma_addr, burstsize */
+	asrc_p2p->asrc_p2p_dma_data.dma_request0    = be_filter_data->dma_request0;
+
+	/* Request channel */
+	asrc_p2p->asrc_p2p_dma_chan =
+		dma_request_channel(mask, filter, &asrc_p2p->asrc_p2p_dma_data);
+
+	if (!asrc_p2p->asrc_p2p_dma_chan) {
+		dev_err(rtd->card->dev, "can not request dma channel\n");
+		goto error;
+	}
+	chan = asrc_p2p->asrc_p2p_dma_chan;
+
+	/*
+	 * Buswidth is not used in the sdma for p2p. Here we set the maxburst fix to
+	 * twice of dma_params's burstsize.
+	 */
+	slave_config.direction      = DMA_DEV_TO_DEV;
+	slave_config.src_addr       = asrc_p2p->asrc_ops.asrc_p2p_per_addr(asrc_p2p->asrc_index, 0);
+	slave_config.src_addr_width = buswidth;
+	slave_config.src_maxburst   = dma_params_be->maxburst * 2;
+	slave_config.dst_addr       = dma_params_be->addr;
+	slave_config.dst_addr_width = buswidth;
+	slave_config.dst_maxburst   = dma_params_be->maxburst * 2;
+	slave_config.dma_request0   = be_filter_data->dma_request0;
+	slave_config.dma_request1   = asrc_p2p->dmatx[asrc_p2p->asrc_index];
+
+	ret = dmaengine_slave_config(asrc_p2p->asrc_p2p_dma_chan,
+							&slave_config);
+	if (ret) {
+		dev_err(rtd->card->dev, "can not config dma channel\n");
+		goto error;
+	}
+	asrc_p2p->asrc_p2p_desc = chan->device->device_prep_dma_cyclic(
+						chan,
+						0xffff,
+						64,
+						64,
+						DMA_DEV_TO_DEV,
+						0,
+						NULL);
+	if (!asrc_p2p->asrc_p2p_desc) {
+		dev_err(&chan->dev->device,
+				"cannot prepare slave dma\n");
+		goto error;
+	}
+
+	return 0;
+error:
+	if (asrc_p2p->asrc_p2p_dma_chan) {
+		dma_release_channel(asrc_p2p->asrc_p2p_dma_chan);
+		asrc_p2p->asrc_p2p_dma_chan = NULL;
+	}
+
+	return -EINVAL;
+}
+
+static int config_asrc(struct snd_pcm_substream *substream,
+					 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai     = rtd->cpu_dai;
+	struct fsl_asrc_p2p *asrc_p2p   = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned int rate    = params_rate(params);
+	unsigned int channel = params_channels(params);
+	struct asrc_config config = {0};
+	int output_word_width = 0;
+	int input_word_width = 0;
+	int ret = 0;
+	if ((channel != 2) && (channel != 4) && (channel != 6)) {
+		dev_err(cpu_dai->dev, "param channel is not correct\n");
+		return -EINVAL;
+	}
+
+	ret = asrc_p2p->asrc_ops.asrc_p2p_req_pair(channel, &asrc_p2p->asrc_index);
+	if (ret < 0) {
+		dev_err(cpu_dai->dev, "Fail to request asrc pair\n");
+		return -EINVAL;
+	}
+
+	if (asrc_p2p->output_width == 16)
+		output_word_width = ASRC_WIDTH_16_BIT;
+	else
+		output_word_width = ASRC_WIDTH_24_BIT;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_U16:
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		input_word_width = ASRC_WIDTH_16_BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S20_3BE:
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_S24_3BE:
+	case SNDRV_PCM_FORMAT_S24_BE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_U24_BE:
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FORMAT_U24_3BE:
+	case SNDRV_PCM_FORMAT_U24_3LE:
+		input_word_width =  ASRC_WIDTH_24_BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S8:
+	case SNDRV_PCM_FORMAT_U8:
+	case SNDRV_PCM_FORMAT_S32:
+	case SNDRV_PCM_FORMAT_U32:
+	default:
+		dev_err(cpu_dai->dev, "Format is not support!\n");
+		return -EINVAL;
+	}
+
+	config.input_word_width   = input_word_width;
+	config.output_word_width  = output_word_width;
+	config.pair               = asrc_p2p->asrc_index;
+	config.channel_num        = channel;
+	config.input_sample_rate  = rate;
+	config.output_sample_rate = asrc_p2p->output_rate;
+	config.inclk              = INCLK_NONE;
+
+	switch (asrc_p2p->per_dev) {
+	case SSI1:
+		config.outclk    = OUTCLK_SSI1_TX;
+		break;
+	case SSI2:
+		config.outclk    = OUTCLK_SSI2_TX;
+		break;
+	case SSI3:
+		config.outclk    = OUTCLK_SSI3_TX;
+		break;
+	case ESAI:
+		config.outclk    = OUTCLK_ESAI_TX;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "peripheral device is not correct\n");
+		return -EINVAL;
+	}
+
+	ret = asrc_p2p->asrc_ops.asrc_p2p_config_pair(&config);
+	if (ret < 0) {
+		dev_err(cpu_dai->dev, "Fail to config asrc\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int fsl_asrc_p2p_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *cpu_dai)
+{
+	int ret = 0;
+
+	ret = config_asrc(substream, params);
+	if (ret < 0)
+		return ret;
+
+	return asrc_p2p_request_channel(substream);
+}
+
+static int fsl_asrc_p2p_hw_free(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct fsl_asrc_p2p *asrc_p2p = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (asrc_p2p->asrc_p2p_dma_chan) {
+		/* Release p2p dma resource */
+		dma_release_channel(asrc_p2p->asrc_p2p_dma_chan);
+		asrc_p2p->asrc_p2p_dma_chan = NULL;
+	}
+
+	if (asrc_p2p->asrc_index != -1) {
+		asrc_p2p->asrc_ops.asrc_p2p_release_pair(asrc_p2p->asrc_index);
+		asrc_p2p->asrc_ops.asrc_p2p_finish_conv(asrc_p2p->asrc_index);
+	}
+	asrc_p2p->asrc_index = -1;
+
+	return 0;
+}
+
+static int fsl_asrc_p2p_trigger(struct snd_pcm_substream *substream, int cmd,
+			    struct snd_soc_dai *cpu_dai)
+{
+	struct fsl_asrc_p2p *asrc_p2p = snd_soc_dai_get_drvdata(cpu_dai);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dmaengine_submit(asrc_p2p->asrc_p2p_desc);
+		dma_async_issue_pending(asrc_p2p->asrc_p2p_dma_chan);
+		asrc_p2p->asrc_ops.asrc_p2p_start_conv(asrc_p2p->asrc_index);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		dmaengine_terminate_all(asrc_p2p->asrc_p2p_dma_chan);
+		asrc_p2p->asrc_ops.asrc_p2p_stop_conv(asrc_p2p->asrc_index);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#define IMX_ASRC_RATES  SNDRV_PCM_RATE_8000_192000
+
+#define IMX_ASRC_FORMATS \
+	(SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FORMAT_S20_3LE)
+
+static struct snd_soc_dai_ops fsl_asrc_p2p_dai_ops = {
+	.trigger      = fsl_asrc_p2p_trigger,
+	.hw_params    = fsl_asrc_p2p_hw_params,
+	.hw_free      = fsl_asrc_p2p_hw_free,
+};
+
+static int fsl_asrc_p2p_dai_probe(struct snd_soc_dai *dai)
+{
+	struct fsl_asrc_p2p *asrc_p2p = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &asrc_p2p->dma_params_tx;
+	dai->capture_dma_data = &asrc_p2p->dma_params_rx;
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver fsl_asrc_p2p_dai = {
+	.probe = fsl_asrc_p2p_dai_probe,
+	.playback = {
+		.stream_name = "asrc-Playback",
+		.channels_min = 1,
+		.channels_max = 10,
+		.rates = IMX_ASRC_RATES,
+		.formats = IMX_ASRC_FORMATS,
+	},
+	.capture  = {
+		.stream_name = "asrc-Capture",
+		.channels_min = 1,
+		.channels_max = 4,
+		.rates = IMX_ASRC_RATES,
+		.formats = IMX_ASRC_FORMATS,
+	},
+	.ops      = &fsl_asrc_p2p_dai_ops,
+};
+
+static const struct snd_soc_component_driver fsl_asrc_p2p_component = {
+	.name		= "fsl-asrc-p2p",
+};
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ */
+static int fsl_asrc_p2p_probe(struct platform_device *pdev)
+{
+	struct fsl_asrc_p2p *asrc_p2p;
+	struct device_node *np = pdev->dev.of_node;
+	const char *p;
+	const uint32_t *iprop_rate, *iprop_width;
+	int ret = 0;
+
+	if (!of_device_is_available(np)) {
+		dev_err(&pdev->dev, "There is no device node\n");
+		return -ENODEV;
+	}
+
+	asrc_p2p = devm_kzalloc(&pdev->dev, sizeof(struct fsl_asrc_p2p), GFP_KERNEL);
+	if (!asrc_p2p) {
+		dev_err(&pdev->dev, "can not alloc memory\n");
+		return -ENOMEM;
+	}
+	asrc_p2p->asrc_ops.asrc_p2p_start_conv      = asrc_start_conv;
+	asrc_p2p->asrc_ops.asrc_p2p_stop_conv       = asrc_stop_conv;
+	asrc_p2p->asrc_ops.asrc_p2p_per_addr        = asrc_get_per_addr;
+	asrc_p2p->asrc_ops.asrc_p2p_req_pair        = asrc_req_pair;
+	asrc_p2p->asrc_ops.asrc_p2p_config_pair     = asrc_config_pair;
+	asrc_p2p->asrc_ops.asrc_p2p_release_pair    = asrc_release_pair;
+	asrc_p2p->asrc_ops.asrc_p2p_finish_conv     = asrc_finish_conv;
+
+	asrc_p2p->asrc_index = -1;
+
+	iprop_rate = of_get_property(np, "fsl,output-rate", NULL);
+	if (iprop_rate)
+		asrc_p2p->output_rate = be32_to_cpup(iprop_rate);
+	else {
+		dev_err(&pdev->dev, "There is no output-rate in dts\n");
+		return -EINVAL;
+	}
+	iprop_width = of_get_property(np, "fsl,output-width", NULL);
+	if (iprop_width)
+		asrc_p2p->output_width = be32_to_cpup(iprop_width);
+
+	if (asrc_p2p->output_width != 16 && asrc_p2p->output_width != 24) {
+		dev_err(&pdev->dev, "output_width is not acceptable\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32_array(np,
+			"fsl,asrc-dma-tx-events", asrc_p2p->dmatx, 3);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get fsl,asrc-dma-tx-events.\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32_array(np,
+			"fsl,asrc-dma-rx-events", asrc_p2p->dmarx, 3);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get fsl,asrc-dma-rx-events.\n");
+		return -EINVAL;
+	}
+
+	asrc_p2p->filter_data_tx.peripheral_type = IMX_DMATYPE_ASRC;
+	asrc_p2p->filter_data_rx.peripheral_type = IMX_DMATYPE_ASRC;
+
+	asrc_p2p->dma_params_tx.filter_data = &asrc_p2p->filter_data_tx;
+	asrc_p2p->dma_params_rx.filter_data = &asrc_p2p->filter_data_rx;
+
+	platform_set_drvdata(pdev, asrc_p2p);
+
+	p = strrchr(np->full_name, '/') + 1;
+	strcpy(asrc_p2p->name, p);
+	fsl_asrc_p2p_dai.name = asrc_p2p->name;
+
+	ret = snd_soc_register_component(&pdev->dev, &fsl_asrc_p2p_component,
+					 &fsl_asrc_p2p_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "register DAI failed\n");
+		goto failed_register;
+	}
+
+	asrc_p2p->soc_platform_pdev = platform_device_register_simple(
+					"imx-pcm-asrc", -1, NULL, 0);
+	if (IS_ERR(asrc_p2p->soc_platform_pdev)) {
+		ret = PTR_ERR(asrc_p2p->soc_platform_pdev);
+		goto failed_pdev_alloc;
+	}
+
+	ret = imx_pcm_dma_init(asrc_p2p->soc_platform_pdev, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
+				     SND_DMAENGINE_PCM_FLAG_NO_DT |
+				     SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (ret) {
+		dev_err(&pdev->dev, "init pcm dma failed\n");
+		goto failed_pcm_init;
+	}
+
+	return 0;
+
+failed_pcm_init:
+	platform_device_unregister(asrc_p2p->soc_platform_pdev);
+failed_pdev_alloc:
+	snd_soc_unregister_component(&pdev->dev);
+failed_register:
+
+	return ret;
+}
+
+static int fsl_asrc_p2p_remove(struct platform_device *pdev)
+{
+	struct fsl_asrc_p2p *asrc_p2p = platform_get_drvdata(pdev);
+
+	imx_pcm_dma_exit(asrc_p2p->soc_platform_pdev);
+	platform_device_unregister(asrc_p2p->soc_platform_pdev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id fsl_asrc_p2p_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-asrc-p2p", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver fsl_asrc_p2p_driver = {
+	.probe = fsl_asrc_p2p_probe,
+	.remove = fsl_asrc_p2p_remove,
+	.driver = {
+		.name = "fsl-asrc-p2p",
+		.owner = THIS_MODULE,
+		.of_match_table = fsl_asrc_p2p_dt_ids,
+	},
+};
+module_platform_driver(fsl_asrc_p2p_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX ASoC ASRC P2P driver");
+MODULE_ALIAS("platform:fsl-asrc-p2p");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/fsl_asrc.h b/sound/soc/fsl/fsl_asrc.h
new file mode 100644
index 0000000..c85ab87
--- /dev/null
+++ b/sound/soc/fsl/fsl_asrc.h
@@ -0,0 +1,48 @@
+/*
+ * fsl_asrc.h - ALSA ASRC interface
+ *
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.  This file is licensed
+ * under the terms of the GNU General Public License version 2.  This
+ * program is licensed "as is" without any warranty of any kind, whether
+ * express or implied.
+ */
+
+#ifndef _FSL_ASRC_P2P_H
+#define _FSL_ASRC_P2P_H
+
+#include <linux/mxc_asrc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/platform_data/dma-imx.h>
+
+enum peripheral_device_type {
+	UNKNOWN,
+	SSI1,
+	SSI2,
+	SSI3,
+	ESAI,
+};
+
+struct fsl_asrc_p2p {
+	int output_rate;
+	int output_width;
+	enum asrc_pair_index asrc_index;
+	enum peripheral_device_type per_dev;
+	struct asrc_p2p_ops asrc_ops;
+
+	struct snd_dmaengine_dai_dma_data dma_params_rx;
+	struct snd_dmaengine_dai_dma_data dma_params_tx;
+	struct imx_dma_data filter_data_tx;
+	struct imx_dma_data filter_data_rx;
+
+	struct dma_async_tx_descriptor  *asrc_p2p_desc;
+	struct dma_chan                 *asrc_p2p_dma_chan;
+	struct imx_dma_data              asrc_p2p_dma_data;
+	struct platform_device *soc_platform_pdev;
+
+	int dmarx[3];
+	int dmatx[3];
+
+	char name[32];
+};
+
+#endif
diff --git a/sound/soc/fsl/fsl_asrc_pcm.c b/sound/soc/fsl/fsl_asrc_pcm.c
new file mode 100644
index 0000000..0a83b1f
--- /dev/null
+++ b/sound/soc/fsl/fsl_asrc_pcm.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+
+/*
+ *     Here add one platform module "imx-pcm-asrc" as pcm platform module.
+ *     If we use the asrc_p2p node as the pcm platform, there will be one issue.
+ * snd_soc_dapm_new_dai_widgets will be called twice, one in probe link_dais,
+ * one in probe platform. so there will be two dai_widgets added to widget list.
+ * but only the seconed one will be recorded in dai->playback_widget.
+ *     Machine driver will add the audio route, but when it go through the
+ * widget list, it will found the cpu_dai widget is the first one in the list.
+ * add use the first one to link the audio route.
+ *     when use the fe/be architecture for asrc p2p, it need to go through from
+ * the fe->cpu_dai->playback_widget. but this is the second widget, so the
+ * result is that it can't find a availble audio route for p2p case. So here
+ * use another pcm platform to avoid this issue.
+ */
+static struct platform_driver imx_pcm_driver = {
+	.driver = {
+		.name = "imx-pcm-asrc",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(imx_pcm_driver);
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX ASoC PCM driver");
+MODULE_ALIAS("platform:imx-pcm-asrc");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

