From 00c97baa5bf503f7f9f262d634f6d46cf66977d4 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 13 Mar 2013 08:47:04 +0800
Subject: [PATCH 11/13] ARM: imx6: exit coherency when shutting down a cpu

commit: 602bf40971d7f9a1ec0b7ba2b7e6427849828651 upstream

There is a system hang issue on imx6q which can easily be seen with
running a cpu hotplug stress testing (hotplug secondary cores from
user space via sysfs interface for thousands iterations).

It turns out that the issue is caused by coherency of the cpu that
is being shut down.  When shutting down a cpu, we need to have the
cpu exit coherency to prevent it from receiving cache, TLB, or BTB
maintenance operations broadcast by other CPUs in the cluster.

Copy cpu_enter_lowpower() and cpu_leave_lowpower() from mach-vexpress
to have coherency properly handled in platform_cpu_die(), thus fix
the issue.

Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
Cc: stable@kernel.org
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/plat_hotplug.c |   71 ++++++++++++++++++++++---------------
 1 files changed, 42 insertions(+), 29 deletions(-)

diff --git a/arch/arm/mach-mx6/plat_hotplug.c b/arch/arm/mach-mx6/plat_hotplug.c
index 4ae4676..d916cc5 100644
--- a/arch/arm/mach-mx6/plat_hotplug.c
+++ b/arch/arm/mach-mx6/plat_hotplug.c
@@ -25,22 +25,13 @@
 #include "src-reg.h"
 #include <linux/sched.h>
 #include <asm/cacheflush.h>
+#include <asm/cp15.h>
 
-static atomic_t cpu_die_done = ATOMIC_INIT(0);
 int platform_cpu_kill(unsigned int cpu)
 {
 	void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
 	unsigned int val;
 
-	val = jiffies;
-	/* wait secondary cpu to die, timeout is 50ms */
-	while (atomic_read(&cpu_die_done) == 0) {
-		if (time_after(jiffies, (unsigned long)(val + HZ / 20))) {
-			printk(KERN_WARNING "cpu %d: cpu could not die\n", cpu);
-			break;
-		}
-	}
-
 	/*
 	 * we're ready for shutdown now, so do it
 	 */
@@ -49,42 +40,64 @@ int platform_cpu_kill(unsigned int cpu)
 	val |= (1 << (BP_SRC_SCR_CORE0_RST + cpu));
 	__raw_writel(val, src_base + SRC_SCR_OFFSET);
 
-	val = jiffies;
-	/* wait secondary cpu reset done, timeout is 10ms */
-	while ((__raw_readl(src_base + SRC_SCR_OFFSET) &
-		(1 << (BP_SRC_SCR_CORE0_RST + cpu))) != 0) {
-		if (time_after(jiffies, (unsigned long)(val + HZ / 100))) {
-			printk(KERN_WARNING "cpu %d: cpu reset fail\n", cpu);
-			break;
-		}
-	}
-
-	atomic_set(&cpu_die_done, 0);
 	return 1;
 }
 
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+		"mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, %3\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0), "ir" (CR_C), "ir" (0x40)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(
+		"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "ir" (CR_C), "ir" (0x40)
+	  : "cc");
+}
+
 /*
  * platform-specific code to shutdown a CPU
  * Called with IRQs disabled
  */
 void platform_cpu_die(unsigned int cpu)
 {
-	if (cpu == 0) {
-		printk(KERN_ERR "CPU0 can't be disabled!\n");
-		return;
-	}
-
-	flush_cache_all();
-	dsb();
+	cpu_enter_lowpower();
 
 	/* tell cpu0 to kill me */
-	atomic_set(&cpu_die_done, 1);
 	for (;;) {
 		/*
 		 * Execute WFI
 		 */
 		cpu_do_idle();
 	}
+
+	cpu_leave_lowpower();
 }
 
 int platform_cpu_disable(unsigned int cpu)
-- 
1.7.0

