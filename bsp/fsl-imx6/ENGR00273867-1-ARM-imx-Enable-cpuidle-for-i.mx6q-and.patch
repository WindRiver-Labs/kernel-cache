From 19c4d0ee74b2289802a7cca364a09431200b0106 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Mon, 5 Aug 2013 17:02:26 -0400
Subject: [PATCH 0082/1072] ENGR00273867-1 ARM: imx: Enable cpuidle for i.mx6q
 and i.mx6dl

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 221fd6fe95d19310d415548b68351bfcfba8afe0

Enable cpuidle for i.mx6q and i.mx6dl, two cpuidle levels
supported:

1. Simple WFI;
2. WAIT mode enabled;

Currently only i.mx6q > TO1.1 and i.mx6dl > TO1.0 support this
feature, as they have WAIT mode available.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/clk-imx6q.c  |   21 +++++++++++++++++++++
 arch/arm/mach-imx/common.h     |    3 +++
 arch/arm/mach-imx/gpc.c        |    4 ++--
 arch/arm/mach-imx/mach-imx6q.c |    9 ++++++++-
 4 files changed, 34 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 3d4d899..de5fcb5 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -64,6 +64,8 @@
 #define CGPR				0x64
 #define BM_CGPR_CHICKEN_BIT		(0x1 << 17)
 
+#define MX6Q_INT_PARITY_CHECK_ERROR	125
+
 static void __iomem *ccm_base;
 
 void imx6q_set_chicken_bit(void)
@@ -138,6 +140,23 @@ static void imx6q_enable_wb(bool enable)
 int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode)
 {
 	u32 val = readl_relaxed(ccm_base + CLPCR);
+	struct irq_desc *desc = irq_to_desc(MX6Q_INT_PARITY_CHECK_ERROR);
+
+	/*
+	 * CCM state machine has restriction, before enabling
+	 * LPM mode, need to make sure last LPM mode is waked up
+	 * by dsm_wakeup_signal, which means the wakeup source
+	 * must be seen by GPC, then CCM will clean its state machine
+	 * and re-sample necessary signal to decide whether it can
+	 * enter LPM mode. Here we use the forever pending irq #125,
+	 * unmask it before we enable LPM mode and mask it after LPM
+	 * is enabled, this flow will make sure CCM state machine in
+	 * reliable status before entering LPM mode. Otherwise, CCM
+	 * may enter LPM mode by mistake which will cause system bus
+	 * locked by CPU access not finished, as when CCM enter
+	 * LPM mode, CPU will stop running.
+	 */
+	imx_gpc_irq_unmask(&desc->irq_data);
 
 	val &= ~BM_CLPCR_LPM;
 	switch (mode) {
@@ -166,10 +185,12 @@ int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode)
 		imx6q_enable_rbc(true);
 		break;
 	default:
+		imx_gpc_irq_mask(&desc->irq_data);
 		return -EINVAL;
 	}
 
 	writel_relaxed(val, ccm_base + CLPCR);
+	imx_gpc_irq_mask(&desc->irq_data);
 
 	return 0;
 }
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 558e95f..161f8f8 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -14,6 +14,7 @@
 struct platform_device;
 struct pt_regs;
 struct clk;
+struct irq_data;
 enum mxc_cpu_pwr_mode;
 
 extern void mx1_map_io(void);
@@ -131,6 +132,8 @@ extern void imx_gpc_init(void);
 extern void imx_gpc_pre_suspend(void);
 extern void imx_gpc_post_resume(void);
 extern void imx_gpc_mask_all(void);
+extern void imx_gpc_irq_mask(struct irq_data *d);
+extern void imx_gpc_irq_unmask(struct irq_data *d);
 extern void imx_gpc_restore_all(void);
 extern void imx_gpc_xpu_enable(void);
 extern void imx_anatop_init(void);
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index b90fc0a..bda2cc5 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -96,7 +96,7 @@ void imx_gpc_restore_all(void)
 		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);
 }
 
-static void imx_gpc_irq_unmask(struct irq_data *d)
+void imx_gpc_irq_unmask(struct irq_data *d)
 {
 	void __iomem *reg;
 	u32 val;
@@ -111,7 +111,7 @@ static void imx_gpc_irq_unmask(struct irq_data *d)
 	writel_relaxed(val, reg);
 }
 
-static void imx_gpc_irq_mask(struct irq_data *d)
+void imx_gpc_irq_mask(struct irq_data *d)
 {
 	void __iomem *reg;
 	u32 val;
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index e04abe9..487c163 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -46,6 +46,11 @@ int imx6q_revision(void)
 	return chip_revision;
 }
 
+int imx6dl_revision(void)
+{
+	return chip_revision;
+}
+
 static void __init imx6q_init_revision(void)
 {
 	u32 rev = imx_anatop_get_digprog();
@@ -266,7 +271,9 @@ static void __init imx6q_init_late(void)
 	 * WAIT mode is broken on TO 1.0 and 1.1, so there is no point
 	 * to run cpuidle on them.
 	 */
-	if (imx6q_revision() > IMX_CHIP_REVISION_1_1)
+	if ((cpu_is_imx6q() && imx6q_revision() > IMX_CHIP_REVISION_1_1)
+		|| (cpu_is_imx6dl() && imx6dl_revision() >
+		IMX_CHIP_REVISION_1_0))
 		imx6q_cpuidle_init();
 
 	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ)) {
-- 
1.7.5.4

