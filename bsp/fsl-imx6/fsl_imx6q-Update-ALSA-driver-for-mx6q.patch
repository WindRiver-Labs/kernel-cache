From 785c64106f0051f06a981d9a9a0575a5e02fd3fa Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 4 Jul 2013 19:01:14 +0800
Subject: [PATCH 18/38] fsl_imx6q: Update ALSA driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                |    1 +
 arch/arm/mach-mx6/board-mx6q_sabrelite.c |   39 +
 drivers/mxc/asrc/mxc_asrc.c              |  809 +++++---
 include/linux/mxc_asrc.h                 |   75 +-
 sound/soc/codecs/Kconfig                 |    8 +
 sound/soc/codecs/cs42888.c               | 1112 +++++++++
 sound/soc/codecs/cs42888.h               |   31 +
 sound/soc/codecs/mxc_spdif.c             |   64 +-
 sound/soc/codecs/sgtl5000.c              |  558 ++++--
 sound/soc/codecs/si4763.c                |  109 +
 sound/soc/codecs/wm8962.c                | 3732 +++++++++++++++++-------------
 sound/soc/imx/Kconfig                    |  103 +-
 sound/soc/imx/Makefile                   |   32 +-
 sound/soc/imx/imx-cs42888.c              |  444 ++++
 sound/soc/imx/imx-esai.c                 |   21 +-
 sound/soc/imx/imx-esai.h                 |    3 -
 sound/soc/imx/imx-pcm-dma-mx2.c          |  437 ++++-
 sound/soc/imx/imx-pcm.h                  |   86 +-
 sound/soc/imx/imx-sgtl5000.c             |   14 +-
 sound/soc/imx/imx-si4763.c               |  199 ++
 sound/soc/imx/imx-si4763.h               |   19 +
 sound/soc/imx/imx-spdif-dai.c            |   13 +-
 sound/soc/imx/imx-spdif.c                |    1 -
 sound/soc/imx/imx-ssi.c                  |  362 +++-
 sound/soc/imx/imx-ssi.h                  |   10 +-
 sound/soc/imx/imx-wm8958.c               |  363 +++
 sound/soc/imx/imx-wm8962.c               |  621 +++++
 sound/soc/soc-core.c                     |   35 +-
 sound/soc/soc-pcm.c                      |    7 +
 29 files changed, 7048 insertions(+), 2260 deletions(-)
 create mode 100644 sound/soc/codecs/cs42888.c
 create mode 100644 sound/soc/codecs/cs42888.h
 create mode 100644 sound/soc/codecs/si4763.c
 create mode 100644 sound/soc/imx/imx-cs42888.c
 create mode 100644 sound/soc/imx/imx-si4763.c
 create mode 100644 sound/soc/imx/imx-si4763.h
 create mode 100644 sound/soc/imx/imx-wm8958.c
 create mode 100644 sound/soc/imx/imx-wm8962.c

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 7f1fb61..b7e59bd 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -191,6 +191,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_MIPI_CSI2
 	select IMX_HAVE_PLATFORM_IMX_DVFS
 	select IMX_HAVE_PLATFORM_PERFMON
+	select IMX_HAVE_PLATFORM_IMX_SPDIF
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/board-mx6q_sabrelite.c b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
index aa0f850..a024b20 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
@@ -200,7 +200,12 @@ static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	MX6Q_PAD_EIM_DA15__GPIO_3_15,	/* J12 - Boot Mode Select */
 
 	/* GPIO4 */
+#ifdef CONFIG_SND_SOC_IMX_SPDIF
+	/* SPDIF TX */
+	MX6Q_PAD_GPIO_19__SPDIF_OUT1,
+#else
 	MX6Q_PAD_GPIO_19__GPIO_4_5,	/* J14 - Volume Down */
+#endif
 
 	/* GPIO5 */
 	MX6Q_PAD_EIM_WAIT__GPIO_5_0,	/* J12 - Boot Mode Select */
@@ -1183,6 +1188,34 @@ static void __init mx6_soc_init(void)
 				ARRAY_SIZE(imx6q_audmux_res));
 }
 
+static int spdif_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long rate_actual;
+	rate_actual = clk_round_rate(clk, rate);
+	clk_set_rate(clk, rate_actual);
+
+	return 0;
+}
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx               = 1,
+	.spdif_rx               = 0,
+	/*
+	 * spdif0_clk will be 454.7MHz divided by ccm dividers.
+	 *
+	 * 44.1KHz: 454.7MHz / 7 (ccm) / 23 (spdif) = 44,128 Hz ~ 0.06% error
+	 * 48KHz:   454.7MHz / 4 (ccm) / 37 (spdif) = 48,004 Hz ~ 0.01% error
+	 * 32KHz:   454.7MHz / 6 (ccm) / 37 (spdif) = 32,003 Hz ~ 0.01% error
+	 */
+	.spdif_clk_44100        = 1,    /* tx clk from spdif0_clk_root */
+	.spdif_clk_48000        = 1,    /* tx clk from spdif0_clk_root */
+	.spdif_div_44100        = 23,
+	.spdif_div_48000        = 37,
+	.spdif_div_32000        = 37,
+	.spdif_clk_set_rate     = spdif_clk_set_rate,
+	.spdif_clk              = NULL,
+};
+
 /*!
  * Board specific initialization.
  */
@@ -1320,6 +1353,12 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_perfmon(0);
 	imx6q_add_perfmon(1);
 	imx6q_add_perfmon(2);
+
+	mxc_spdif_data.spdif_core_clk = clk_get_sys("mxc_spdif.0", NULL);
+	clk_put(mxc_spdif_data.spdif_core_clk);
+	imx6q_add_spdif(&mxc_spdif_data);
+	imx6q_add_spdif_dai();
+	imx6q_add_spdif_audio_device();
 }
 
 static void __init mx6_sabrelite_timer_init(void)
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
index cbfa9ff..25c8ce6 100644
--- a/drivers/mxc/asrc/mxc_asrc.c
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -17,7 +17,7 @@
  * @brief MXC Asynchronous Sample Rate Converter
  *
  * @ingroup SOUND
- */
+*/
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -41,12 +41,15 @@
 #include <asm/memory.h>
 #include <mach/dma.h>
 #include <mach/mxc_asrc.h>
+#include <linux/delay.h>
+
 
 #define ASRC_PROC_PATH        "driver/asrc"
 
 #define ASRC_RATIO_DECIMAL_DEPTH 26
 
 DEFINE_SPINLOCK(data_lock);
+DEFINE_SPINLOCK(pair_lock);
 DEFINE_SPINLOCK(input_int_lock);
 DEFINE_SPINLOCK(output_int_lock);
 
@@ -151,11 +154,13 @@ static unsigned char output_clk_map_v2[] = {
 
 static unsigned char *input_clk_map, *output_clk_map;
 
+struct asrc_p2p_ops asrc_pcm_p2p_ops_asrc;
+
 static struct dma_chan *imx_asrc_dma_alloc(u32 dma_req);
-struct dma_async_tx_descriptor *imx_asrc_dma_config(
+static int imx_asrc_dma_config(
 					struct asrc_pair_params *params,
 					struct dma_chan *chan,
-					u32 dma_addr, dma_addr_t buf_addr,
+					u32 dma_addr, void *buf_addr,
 					u32 buf_len, bool in,
 					enum asrc_word_width word_width);
 
@@ -448,6 +453,9 @@ int asrc_config_pair(struct asrc_config *config)
 			reg |= 7 << AOCPA;
 		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
 			reg |= 6 << AOCPA;
+		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
+				((config->inclk & 0x0f) == INCLK_NONE))
+			reg |= 5 << AOCPA;
 		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
 			tmp =
 			    asrc_get_asrck_clock_divider(config->
@@ -490,6 +498,9 @@ int asrc_config_pair(struct asrc_config *config)
 			reg |= 7 << AOCPB;
 		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
 			reg |= 6 << AOCPB;
+		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
+				((config->inclk & 0x0f) == INCLK_NONE))
+			reg |= 5 << AOCPB;
 		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
 			tmp =
 			    asrc_get_asrck_clock_divider(config->
@@ -532,6 +543,9 @@ int asrc_config_pair(struct asrc_config *config)
 			reg |= 7 << AOCPC;
 		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
 			reg |= 6 << AOCPC;
+		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
+				((config->inclk & 0x0f) == INCLK_NONE))
+			reg |= 5 << AOCPC;
 		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
 			tmp =
 			    asrc_get_asrck_clock_divider(config->
@@ -632,11 +646,46 @@ int asrc_config_pair(struct asrc_config *config)
 	__raw_writel(reg,
 		 g_asrc->vaddr + ASRC_ASRMCR1A_REG + (config->pair << 2));
 
+
+	/* Enable BUFFER STALL*/
+	reg = __raw_readl(
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (config->pair << 3));
+	reg |= 1 << 21;
+	reg |= 1 << 22;
+	reg &= ~0x3f;
+	reg += ASRC_INPUTFIFO_THRESHOLD;
+	reg &= ~(0x3f << 12);
+	reg += ASRC_OUTPUTFIFO_THRESHOLD << 12;
+	__raw_writel(reg,
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (config->pair << 3));
+
 	return err;
 }
 
 EXPORT_SYMBOL(asrc_config_pair);
 
+int asrc_set_watermark(enum asrc_pair_index index, u32 in_wm, u32 out_wm)
+{
+	u32 reg;
+
+	if ((in_wm > 63) || (out_wm > 63)) {
+		pr_err("error watermark!\n");
+		return -EINVAL;
+	}
+
+	reg = __raw_readl(
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (index << 3));
+	reg |= 1 << 22;
+	reg &= ~0x3f;
+	reg += in_wm;
+	reg &= ~(0x3f << 12);
+	reg += out_wm << 12;
+	__raw_writel(reg,
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (index << 3));
+	return 0;
+}
+EXPORT_SYMBOL(asrc_set_watermark);
+
 void asrc_start_conv(enum asrc_pair_index index)
 {
 	int reg, reg_1;
@@ -842,88 +891,192 @@ static void asrc_input_dma_callback(void *data)
 	unsigned long lock_flags;
 
 	params = data;
+	dma_unmap_sg(NULL, params->input_sg,
+		params->input_sg_nodes, DMA_MEM_TO_DEV);
 	spin_lock_irqsave(&input_int_lock, lock_flags);
-	params->input_queue_empty--;
 	params->input_counter++;
 	wake_up_interruptible(&params->input_wait_queue);
 	spin_unlock_irqrestore(&input_int_lock, lock_flags);
+	schedule_work(&params->task_output_work);
 	return;
 }
 
 static void asrc_output_dma_callback(void *data)
 {
 	struct asrc_pair_params *params;
-	unsigned long lock_flags;
 
 	params = data;
+	dma_unmap_sg(NULL, params->output_sg,
+		params->output_sg_nodes, DMA_MEM_TO_DEV);
+	return;
+}
+
+static unsigned int asrc_get_output_FIFO_size(enum asrc_pair_index index)
+{
+	u32 reg;
+
+	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRFSTA_REG + (index << 3));
+	return (reg & ASRC_ASRFSTX_OUTPUT_FIFO_MASK)
+			>> ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET;
+}
+
+static unsigned int asrc_get_input_FIFO_size(enum asrc_pair_index index)
+{
+	u32 reg;
+
+	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRFSTA_REG + (index << 3));
+	return (reg & ASRC_ASRFSTX_INPUT_FIFO_MASK) >>
+				ASRC_ASRFSTX_INPUT_FIFO_OFFSET;
+}
+
+
+static u32 asrc_read_one_from_output_FIFO(enum asrc_pair_index index)
+{
+	return __raw_readl(g_asrc->vaddr + ASRC_ASRDOA_REG + (index << 3));
+}
+
+static void asrc_write_one_to_output_FIFO(enum asrc_pair_index index, u32 value)
+{
+	__raw_writel(value, g_asrc->vaddr + ASRC_ASRDIA_REG + (index << 3));
+}
+
+static void asrc_read_output_FIFO_S16(struct asrc_pair_params *params)
+{
+	u32 size, i, j, reg, t_size;
+	u16 *index = params->output_last_period.dma_vaddr;
+
+	t_size = 0;
+	udelay(100);
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (i = 0; i < size; i++) {
+			for (j = 0; j < params->channel_nums; j++) {
+				reg = asrc_read_one_from_output_FIFO(
+							params->index);
+				*(index) = (u16)reg;
+				index++;
+			}
+		}
+		t_size += size;
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	if (t_size > ASRC_OUTPUT_LAST_SAMPLE)
+		t_size = ASRC_OUTPUT_LAST_SAMPLE;
+	params->output_last_period.length = t_size * params->channel_nums * 2;
+}
+
+static void asrc_read_output_FIFO_S24(struct asrc_pair_params *params)
+{
+	u32 size, i, j, reg, t_size;
+	u32 *index = params->output_last_period.dma_vaddr;
+
+	t_size = 0;
+	udelay(100);
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (i = 0; i < size; i++) {
+			for (j = 0; j < params->channel_nums; j++) {
+				reg = asrc_read_one_from_output_FIFO(
+							params->index);
+				*(index) = reg;
+				index++;
+			}
+		}
+		t_size += size;
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	if (t_size > ASRC_OUTPUT_LAST_SAMPLE)
+		t_size = ASRC_OUTPUT_LAST_SAMPLE;
+	params->output_last_period.length = t_size * params->channel_nums * 4;
+}
+
+
+static void asrc_output_task_worker(struct work_struct *w)
+{
+	struct asrc_pair_params *params =
+		container_of(w, struct asrc_pair_params, task_output_work);
+	unsigned long lock_flags;
 
+	/* asrc output work struct */
+	spin_lock_irqsave(&pair_lock, lock_flags);
+	if (!params->pair_hold) {
+		spin_unlock_irqrestore(&pair_lock, lock_flags);
+		return;
+	}
+	switch (params->output_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		asrc_read_output_FIFO_S24(params);
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		asrc_read_output_FIFO_S16(params);
+		break;
+	default:
+		pr_err("%s: error word width\n", __func__);
+	}
+	spin_unlock_irqrestore(&pair_lock, lock_flags);
+
+	/* finish receiving all output data */
 	spin_lock_irqsave(&output_int_lock, lock_flags);
-	params->output_queue_empty--;
 	params->output_counter++;
 	wake_up_interruptible(&params->output_wait_queue);
 	spin_unlock_irqrestore(&output_int_lock, lock_flags);
-	return;
 }
 
 static void mxc_free_dma_buf(struct asrc_pair_params *params)
 {
 	if (params->input_dma_total.dma_vaddr != NULL) {
-		dma_free_coherent(g_asrc->dev,
-			params->input_dma_total.length,
-			params->input_dma_total.dma_vaddr,
-			params->input_dma_total.dma_paddr);
+		kfree(params->input_dma_total.dma_vaddr);
 		params->input_dma_total.dma_vaddr = NULL;
 	}
 
 	if (params->output_dma_total.dma_vaddr != NULL) {
-		dma_free_coherent(g_asrc->dev,
-			params->output_dma_total.length,
-			params->output_dma_total.dma_vaddr,
-			params->output_dma_total.dma_paddr);
+		kfree(params->input_dma_total.dma_vaddr);
 		params->output_dma_total.dma_vaddr = NULL;
 	}
 
+	if (params->output_last_period.dma_vaddr) {
+		dma_free_coherent(
+			g_asrc->dev, 4096,
+			params->output_last_period.dma_vaddr,
+			params->output_last_period.dma_paddr);
+		params->output_last_period.dma_vaddr = NULL;
+	}
+
 	return;
 }
 
 static int mxc_allocate_dma_buf(struct asrc_pair_params *params)
 {
-	int i;
-	struct dma_block *input_a, *output_a;
-
+	struct dma_block *input_a, *output_a, *last_period;
 	input_a = &params->input_dma_total;
 	output_a = &params->output_dma_total;
+	last_period = &params->output_last_period;
 
-	input_a->dma_vaddr =
-		dma_alloc_coherent(g_asrc->dev,
-			input_a->length, &input_a->dma_paddr,
-			GFP_KERNEL | GFP_DMA);
-	if (!input_a->dma_vaddr)
+	input_a->dma_vaddr = kzalloc(input_a->length, GFP_KERNEL);
+	if (!input_a->dma_vaddr) {
+		pr_err("fail to allocate input dma buffer!\n");
 		goto exit;
-
-	for (i = 0; i < params->buffer_num; i++) {
-		params->input_dma[i].dma_vaddr =
-			input_a->dma_vaddr + i * params->input_buffer_size;
-		params->input_dma[i].dma_paddr =
-			input_a->dma_paddr + i * params->input_buffer_size;
-		if (params->input_dma[i].dma_vaddr == NULL)
-			goto exit;
 	}
+	input_a->dma_paddr = virt_to_dma(NULL, input_a->dma_vaddr);
 
-	output_a->dma_vaddr =
-		dma_alloc_coherent(g_asrc->dev,
-			output_a->length, &output_a->dma_paddr,
-			GFP_KERNEL | GFP_DMA);
-	if (!output_a->dma_vaddr)
+	output_a->dma_vaddr = kzalloc(output_a->length, GFP_KERNEL);
+	if (!output_a->dma_vaddr) {
+		pr_err("fail to allocate output dma buffer!\n");
 		goto exit;
-	for (i = 0; i < params->buffer_num; i++) {
-		params->output_dma[i].dma_vaddr =
-			output_a->dma_vaddr + i * params->output_buffer_size;
-		params->output_dma[i].dma_paddr =
-			output_a->dma_paddr + i * params->output_buffer_size;
-		if (params->output_dma[i].dma_vaddr == NULL)
-			goto exit;
 	}
+	output_a->dma_paddr = virt_to_dma(NULL, output_a->dma_vaddr);
+
+	last_period->dma_vaddr =
+		dma_alloc_coherent(NULL,
+			4096,
+			&last_period->dma_paddr,
+			GFP_KERNEL);
+
 	return 0;
 
 exit:
@@ -957,18 +1110,30 @@ static struct dma_chan *imx_asrc_dma_alloc(u32 dma_req)
 	return dma_request_channel(mask, filter, &dma_data);
 }
 
-
-struct dma_async_tx_descriptor *imx_asrc_dma_config(
+static int imx_asrc_dma_config(
 				struct asrc_pair_params *params,
 				struct dma_chan *chan,
-				u32 dma_addr, dma_addr_t buf_addr,
+				u32 dma_addr, void *buf_addr,
 				u32 buf_len, bool in,
 				enum asrc_word_width word_width)
 {
 	struct dma_slave_config slave_config;
 	enum dma_slave_buswidth buswidth;
+	struct scatterlist *sg;
+	unsigned int sg_nent, sg_index;
+	struct dma_async_tx_descriptor *desc;
 	int ret;
 
+	if (in) {
+		sg = params->input_sg;
+		sg_nent = params->input_sg_nodes;
+		desc = params->desc_in;
+	} else {
+		sg = params->output_sg;
+		sg_nent = params->output_sg_nodes;
+		desc = params->desc_out;
+	}
+
 	switch (word_width) {
 	case ASRC_WIDTH_16_BIT:
 		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
@@ -978,7 +1143,7 @@ struct dma_async_tx_descriptor *imx_asrc_dma_config(
 		break;
 	default:
 		pr_err("Error word_width\n");
-		return NULL;
+		return -EINVAL;
 	}
 
 	if (in) {
@@ -986,26 +1151,252 @@ struct dma_async_tx_descriptor *imx_asrc_dma_config(
 		slave_config.dst_addr = dma_addr;
 		slave_config.dst_addr_width = buswidth;
 		slave_config.dst_maxburst =
-			ASRC_INPUTFIFO_THRESHOLD * params->channel_nums;
+			params->input_wm * params->channel_nums;
 	} else {
 		slave_config.direction = DMA_DEV_TO_MEM;
 		slave_config.src_addr = dma_addr;
 		slave_config.src_addr_width = buswidth;
 		slave_config.src_maxburst =
-			ASRC_OUTPUTFIFO_THRESHOLD * params->channel_nums;
+			params->output_wm * params->channel_nums;
 	}
 	ret = dmaengine_slave_config(chan, &slave_config);
 	if (ret) {
 		pr_err("imx_asrc_dma_config(%d) failed\r\n", in);
-		return NULL;
+		return -EINVAL;
+	}
+
+	sg_init_table(sg, sg_nent);
+	switch (sg_nent) {
+	case 1:
+		sg_init_one(sg, buf_addr, buf_len);
+		break;
+	case 2:
+	case 3:
+	case 4:
+		for (sg_index = 0; sg_index < (sg_nent - 1); sg_index++) {
+			sg_set_buf(&sg[sg_index],
+				buf_addr + sg_index * ASRC_MAX_BUFFER_SIZE,
+				ASRC_MAX_BUFFER_SIZE);
+		}
+		sg_set_buf(&sg[sg_index],
+			buf_addr + sg_index * ASRC_MAX_BUFFER_SIZE,
+			buf_len - ASRC_MAX_BUFFER_SIZE * sg_index);
+		break;
+	default:
+		pr_err("Error Input DMA nodes number[%d]!", sg_nent);
+		return -EINVAL;
+	}
+
+	ret = dma_map_sg(NULL, sg, sg_nent, slave_config.direction);
+	if (ret != sg_nent) {
+		pr_err("DMA mapping error!!\n");
+		return -EINVAL;
+	}
+
+	desc = chan->device->device_prep_slave_sg(chan,
+						  sg, sg_nent, slave_config.direction, 1, NULL);
+
+	if (in) {
+		params->desc_in = desc;
+		params->desc_in->callback = asrc_input_dma_callback;
+	} else {
+		params->desc_out = desc;
+		params->desc_out->callback = asrc_output_dma_callback;
+	}
+	if (desc) {
+		desc->callback = in ?
+			asrc_input_dma_callback : asrc_output_dma_callback;
+		desc->callback_param = params;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int mxc_asrc_prepare_input_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	u32 word_size;
+
+	switch (params->input_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		word_size = 4;
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		word_size = 2;
+		break;
+	default:
+		pr_err("error input word size!\n");
+		return -EINVAL;
+	}
+
+	if (pbuf->input_buffer_length <
+		word_size * params->channel_nums * params->input_wm) {
+		pr_err("input buffer size[%d] is too small!\n",
+					pbuf->input_buffer_length);
+		return -EINVAL;
 	}
 
-	return chan->device->device_prep_dma_cyclic(chan, buf_addr,
-			buf_len * params->buffer_num,
-			buf_len,
-			in == true ?
-			DMA_TO_DEVICE : DMA_FROM_DEVICE,
-			NULL);
+	/* copy origin data into input buffer */
+	if (copy_from_user(
+		params->input_dma_total.dma_vaddr,
+		(void __user *)pbuf->input_buffer_vaddr,
+		pbuf->input_buffer_length)) {
+		return -EFAULT;
+	}
+
+	params->input_dma_total.length = pbuf->input_buffer_length;
+	params->input_sg_nodes =
+		params->input_dma_total.length / ASRC_MAX_BUFFER_SIZE + 1;
+
+	return imx_asrc_dma_config(
+			params,
+			params->input_dma_channel,
+			asrc_get_per_addr(params->index, 1),
+			params->input_dma_total.dma_vaddr,
+			params->input_dma_total.length, 1,
+			params->input_word_width);
+
+}
+
+static int mxc_asrc_prepare_output_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	u32 word_size;
+
+	switch (params->output_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		word_size = 4;
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		word_size = 2;
+		break;
+	default:
+		pr_err("error word size!\n");
+		return -EINVAL;
+	}
+
+	if (pbuf->output_buffer_length <
+		ASRC_OUTPUT_LAST_SAMPLE * word_size * params->channel_nums) {
+		pr_err("output buffer size[%d] is wrong.\n",
+				pbuf->output_buffer_length);
+		return -EINVAL;
+	}
+
+	params->output_dma_total.length =
+		pbuf->output_buffer_length -
+		ASRC_OUTPUT_LAST_SAMPLE * word_size * params->channel_nums ;
+
+	params->output_sg_nodes =
+		params->output_dma_total.length / ASRC_MAX_BUFFER_SIZE + 1;
+
+	return imx_asrc_dma_config(
+			params,
+			params->output_dma_channel,
+			asrc_get_per_addr(params->index, 0),
+			params->output_dma_total.dma_vaddr,
+			params->output_dma_total.length, 0,
+			params->output_word_width);
+}
+
+int mxc_asrc_process_output_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	unsigned long lock_flags;
+
+	if (!wait_event_interruptible_timeout
+	    (params->output_wait_queue,
+	     params->output_counter != 0, 10 * HZ)) {
+		pr_info
+		    ("ASRC_DQ_OUTBUF timeout counter %x\n",
+		     params->output_counter);
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		pr_info("ASRC_DQ_INBUF interrupt received\n");
+		return -ERESTARTSYS;
+	}
+	spin_lock_irqsave(&output_int_lock, lock_flags);
+	params->output_counter--;
+	spin_unlock_irqrestore(&output_int_lock, lock_flags);
+
+	pbuf->output_buffer_length = params->output_dma_total.length;
+
+	if (copy_to_user((void __user *)pbuf->output_buffer_vaddr,
+				params->output_dma_total.dma_vaddr,
+				params->output_dma_total.length))
+		return -EFAULT;
+
+	pbuf->output_buffer_length += params->output_last_period.length;
+
+	if (copy_to_user((void __user *)(pbuf->output_buffer_vaddr +
+				params->output_dma_total.length),
+				params->output_last_period.dma_vaddr,
+				params->output_last_period.length))
+		return -EFAULT;
+
+	return 0;
+
+}
+
+int mxc_asrc_process_input_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	unsigned long lock_flags;
+
+	if (!wait_event_interruptible_timeout
+	    (params->input_wait_queue,
+	     params->input_counter != 0, 10 * HZ)) {
+		pr_info
+		    ("ASRC_DQ_INBUF timeout counter %x\n",
+		     params->input_counter);
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		pr_info("ASRC_DQ_INBUF interrupt received\n");
+		return -ERESTARTSYS;
+	}
+	spin_lock_irqsave(&input_int_lock, lock_flags);
+	params->input_counter--;
+	spin_unlock_irqrestore(&input_int_lock, lock_flags);
+
+	pbuf->input_buffer_length = params->input_dma_total.length;
+
+	return 0;
+}
+
+static void mxc_asrc_submit_dma(struct asrc_pair_params *params)
+{
+	enum asrc_pair_index index;
+	u32 size, i, j;
+	index = params->index;
+
+	/*  read all data in OUTPUT FIFO*/
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (j = 0; j < size; j++) {
+			for (i = 0; i < params->channel_nums; i++)
+				asrc_read_one_from_output_FIFO(params->index);
+		}
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	/* Fill the input FIFO until reach the stall level */
+	size = asrc_get_input_FIFO_size(params->index);
+	while (size < 3) {
+		for (i = 0; i < params->channel_nums; i++)
+			asrc_write_one_to_output_FIFO(params->index, 0);
+		size = asrc_get_input_FIFO_size(params->index);
+	}
+
+	/* submit dma request */
+	dmaengine_submit(params->desc_in);
+	dmaengine_submit(params->desc_out);
+	sdma_set_event_pending(params->input_dma_channel);
+
 }
 
 /*!
@@ -1064,6 +1455,13 @@ static long asrc_ioctl(struct file *file,
 			err = asrc_config_pair(&config);
 			if (err < 0)
 				break;
+
+			params->input_wm = 4;
+			params->output_wm = 2;
+			err = asrc_set_watermark(config.pair,
+					params->input_wm, params->output_wm);
+			if (err < 0)
+				break;
 			params->output_buffer_size = config.dma_buffer_size;
 			params->input_buffer_size = config.dma_buffer_size;
 			if (config.buffer_num > ASRC_DMA_BUFFER_NUM)
@@ -1071,10 +1469,14 @@ static long asrc_ioctl(struct file *file,
 			else
 				params->buffer_num = config.buffer_num;
 
-			params->input_dma_total.length =
-				params->input_buffer_size * params->buffer_num;
-			params->output_dma_total.length =
-				params->output_buffer_size * params->buffer_num;
+			params->input_dma_total.length = ASRC_DMA_BUFFER_SIZE;
+			params->output_dma_total.length = ASRC_DMA_BUFFER_SIZE;
+
+			params->input_word_width = config.input_word_width;
+			params->output_word_width = config.output_word_width;
+
+			params->input_sample_rate = config.input_sample_rate;
+			params->output_sample_rate = config.output_sample_rate;
 
 			err = mxc_allocate_dma_buf(params);
 			if (err < 0)
@@ -1104,51 +1506,18 @@ static long asrc_ioctl(struct file *file,
 				err = -EBUSY;
 			}
 
-			params->desc_in = imx_asrc_dma_config(params,
-					params->input_dma_channel,
-					asrc_get_per_addr(params->index, 1),
-					params->input_dma[0].dma_paddr,
-					params->input_buffer_size, 1,
-					config.input_word_width);
-			if (params->desc_in) {
-				params->desc_in->callback =
-						asrc_input_dma_callback;
-				params->desc_in->callback_param = params;
-			} else {
-				pr_err("unable to get desc_in\r\n");
-				err = -EINVAL;
-				break;
-			}
-
 			params->output_dma_channel = imx_asrc_dma_alloc(tx_id);
 			if (params->output_dma_channel == NULL) {
 				pr_err("unable to get tx channel %d\n", tx_id);
 				err = -EBUSY;
 			}
-			params->desc_out = imx_asrc_dma_config(params,
-					params->output_dma_channel,
-					asrc_get_per_addr(params->index, 0),
-					params->output_dma[0].dma_paddr,
-					params->output_buffer_size, 0,
-					config.output_word_width);
-			if (params->desc_out) {
-				params->desc_out->callback =
-						asrc_output_dma_callback;
-				params->desc_out->callback_param = params;
-			} else {
-				pr_err("unable to get desc_out\r\n");
-				err = -EINVAL;
-				break;
-			}
 
-			params->input_queue_empty = 0;
-			params->output_queue_empty = 0;
-			INIT_LIST_HEAD(&params->input_queue);
-			INIT_LIST_HEAD(&params->input_done_queue);
-			INIT_LIST_HEAD(&params->output_queue);
-			INIT_LIST_HEAD(&params->output_done_queue);
 			init_waitqueue_head(&params->input_wait_queue);
 			init_waitqueue_head(&params->output_wait_queue);
+			/* Add work struct to cover the task of
+			 * receive last period of output data.*/
+			INIT_WORK(&params->task_output_work,
+						asrc_output_task_worker);
 
 			if (copy_to_user
 			    ((void __user *)arg, &config,
@@ -1156,35 +1525,10 @@ static long asrc_ioctl(struct file *file,
 				err = -EFAULT;
 			break;
 		}
-	case ASRC_QUERYBUF:
-		{
-			struct asrc_querybuf buffer;
-			unsigned int index_n;
-			if (copy_from_user
-			    (&buffer, (void __user *)arg,
-			     sizeof(struct asrc_querybuf))) {
-				err = -EFAULT;
-				break;
-			}
-			index_n = buffer.buffer_index;
-
-			buffer.input_offset = (unsigned long)
-				params->input_dma[index_n].dma_paddr;
-			buffer.input_length = params->input_buffer_size;
-
-			buffer.output_offset = (unsigned long)
-				params->output_dma[index_n].dma_paddr;
-			buffer.output_length = params->output_buffer_size;
-
-			if (copy_to_user
-			    ((void __user *)arg, &buffer,
-			     sizeof(struct asrc_querybuf)))
-				err = -EFAULT;
-			break;
-		}
 	case ASRC_RELEASE_PAIR:
 		{
 			enum asrc_pair_index index;
+			unsigned long lock_flags;
 			if (copy_from_user
 			    (&index, (void __user *)arg,
 			     sizeof(enum asrc_pair_index))) {
@@ -1192,6 +1536,17 @@ static long asrc_ioctl(struct file *file,
 				break;
 			}
 
+			if (index < 0) {
+				pr_err("unvalid index: %d!\n", index);
+				err = -EFAULT;
+				break;
+			}
+
+			params->asrc_active = 0;
+
+			spin_lock_irqsave(&pair_lock, lock_flags);
+			params->pair_hold = 0;
+			spin_unlock_irqrestore(&pair_lock, lock_flags);
 			if (params->input_dma_channel)
 				dma_release_channel(params->input_dma_channel);
 			if (params->output_dma_channel)
@@ -1200,192 +1555,53 @@ static long asrc_ioctl(struct file *file,
 			mxc_free_dma_buf(params);
 			asrc_release_pair(index);
 			asrc_finish_conv(index);
-			params->pair_hold = 0;
 			break;
 		}
-	case ASRC_Q_INBUF:
+	case ASRC_CONVERT:
 		{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
+			struct asrc_convert_buffer buf;
 			if (copy_from_user
 			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
+			     sizeof(struct asrc_convert_buffer))) {
 				err = -EFAULT;
 				break;
 			}
 
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			params->input_dma[buf.index].index = buf.index;
-			params->input_dma[buf.index].length = buf.length;
-			list_add_tail(&params->input_dma[buf.index].
-				      queue, &params->input_queue);
-			if (!list_empty(&params->input_queue)) {
-				block =
-				    list_entry(params->input_queue.next,
-					       struct dma_block, queue);
-
-				params->input_queue_empty++;
-				list_del(params->input_queue.next);
-				list_add_tail(&block->queue,
-					      &params->input_done_queue);
-			}
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
-			break;
-		}
-	case ASRC_DQ_INBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
-				break;
-			}
-			/* if ASRC is inactive, nonsense to DQ buffer */
-			if (params->asrc_active == 0) {
-				err = -EFAULT;
-				buf.buf_valid = ASRC_BUF_NA;
-				if (copy_to_user
-				    ((void __user *)arg, &buf,
-				     sizeof(struct asrc_buffer)))
-					err = -EFAULT;
+			err = mxc_asrc_prepare_input_buffer(params, &buf);
+			if (err)
 				break;
-			}
 
-			if (!wait_event_interruptible_timeout
-			    (params->input_wait_queue,
-			     params->input_counter != 0, 10 * HZ)) {
-				pr_info
-				    ("ASRC_DQ_INBUF timeout counter %x\n",
-				     params->input_counter);
-				err = -ETIME;
+			err = mxc_asrc_prepare_output_buffer(params, &buf);
+			if (err)
 				break;
-			} else if (signal_pending(current)) {
-				pr_info("ASRC_DQ_INBUF interrupt received\n");
-				err = -ERESTARTSYS;
-				break;
-			}
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			params->input_counter--;
-			block =
-			    list_entry(params->input_done_queue.next,
-				       struct dma_block, queue);
-			list_del(params->input_done_queue.next);
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
-			buf.index = block->index;
-			buf.length = block->length;
-			buf.buf_valid = ASRC_BUF_AV;
-			if (copy_to_user
-			    ((void __user *)arg, &buf,
-			     sizeof(struct asrc_buffer)))
-				err = -EFAULT;
 
-			break;
-		}
-	case ASRC_Q_OUTBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
-				break;
-			}
+			mxc_asrc_submit_dma(params);
 
-			spin_lock_irqsave(&output_int_lock, lock_flags);
-			params->output_dma[buf.index].index = buf.index;
-			params->output_dma[buf.index].length = buf.length;
-			list_add_tail(&params->output_dma[buf.index].
-				      queue, &params->output_queue);
-			if (!list_empty(&params->output_queue)) {
-				block =
-				    list_entry(params->output_queue.
-					       next, struct dma_block, queue);
-				list_del(params->output_queue.next);
-				list_add_tail(&block->queue,
-					      &params->output_done_queue);
-				params->output_queue_empty++;
-			}
-
-			spin_unlock_irqrestore(&output_int_lock, lock_flags);
-			break;
-		}
-	case ASRC_DQ_OUTBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
-				break;
-			}
-			/* if ASRC is inactive, nonsense to DQ buffer */
-			if (params->asrc_active == 0) {
-				buf.buf_valid = ASRC_BUF_NA;
-				err = -EFAULT;
-				if (copy_to_user
-				    ((void __user *)arg, &buf,
-				     sizeof(struct asrc_buffer)))
-					err = -EFAULT;
+			err = mxc_asrc_process_output_buffer(params, &buf);
+			if (err)
 				break;
-			}
 
-			if (!wait_event_interruptible_timeout
-			    (params->output_wait_queue,
-			     params->output_counter != 0, 10 * HZ)) {
-				pr_info
-				    ("ASRC_DQ_OUTBUF timeout counter %x\n",
-				     params->output_counter);
-				err = -ETIME;
+			err = mxc_asrc_process_input_buffer(params, &buf);
+			if (err)
 				break;
-			} else if (signal_pending(current)) {
-				pr_info("ASRC_DQ_INBUF interrupt received\n");
-				err = -ERESTARTSYS;
-				break;
-			}
-			spin_lock_irqsave(&output_int_lock, lock_flags);
-			params->output_counter--;
-			block =
-			    list_entry(params->output_done_queue.next,
-				       struct dma_block, queue);
-			list_del(params->output_done_queue.next);
-			spin_unlock_irqrestore(&output_int_lock, lock_flags);
-			buf.index = block->index;
-			buf.length = block->length;
-			buf.buf_valid = ASRC_BUF_AV;
+
 			if (copy_to_user
 			    ((void __user *)arg, &buf,
-			     sizeof(struct asrc_buffer)))
+			     sizeof(struct asrc_convert_buffer)))
 				err = -EFAULT;
 
 			break;
 		}
 	case ASRC_START_CONV:{
 			enum asrc_pair_index index;
-			unsigned long lock_flags;
 			if (copy_from_user
 			    (&index, (void __user *)arg,
 			     sizeof(enum asrc_pair_index))) {
 				err = -EFAULT;
 				break;
 			}
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			if (params->input_queue_empty == 0) {
-				err = -EFAULT;
-				pr_info
-				    ("ASRC_START_CONV - no block available\n");
-				break;
-			}
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
+
 			params->asrc_active = 1;
-			dmaengine_submit(params->desc_in);
-			dmaengine_submit(params->desc_out);
-			dma_async_issue_pending(params->input_dma_channel);
-			dma_async_issue_pending(params->output_dma_channel);
 			asrc_start_conv(index);
 
 			break;
@@ -1425,22 +1641,14 @@ static long asrc_ioctl(struct file *file,
 			u32 rx_id, tx_id;
 			char *rx_name, *tx_name;
 			spin_lock_irqsave(&input_int_lock, lock_flags);
-			while (!list_empty(&params->input_queue))
-				list_del(params->input_queue.next);
-			while (!list_empty(&params->input_done_queue))
-				list_del(params->input_done_queue.next);
+
 			params->input_counter = 0;
-			params->input_queue_empty = 0;
 			spin_unlock_irqrestore(&input_int_lock, lock_flags);
 
 			/* flush output dma buffer */
 			spin_lock_irqsave(&output_int_lock, lock_flags);
-			while (!list_empty(&params->output_queue))
-				list_del(params->output_queue.next);
-			while (!list_empty(&params->output_done_queue))
-				list_del(params->output_done_queue.next);
+
 			params->output_counter = 0;
-			params->output_queue_empty = 0;
 			spin_unlock_irqrestore(&output_int_lock, lock_flags);
 
 			/* release DMA and request again */
@@ -1521,9 +1729,11 @@ static int mxc_asrc_open(struct inode *inode, struct file *file)
 static int mxc_asrc_close(struct inode *inode, struct file *file)
 {
 	struct asrc_pair_params *pair_params;
+	unsigned long lock_flags;
 	pair_params = file->private_data;
 	if (pair_params) {
 		if (pair_params->asrc_active) {
+			pair_params->asrc_active = 0;
 			dmaengine_terminate_all(
 					pair_params->input_dma_channel);
 			dmaengine_terminate_all(
@@ -1533,6 +1743,9 @@ static int mxc_asrc_close(struct inode *inode, struct file *file)
 			wake_up_interruptible(&pair_params->output_wait_queue);
 		}
 		if (pair_params->pair_hold) {
+			spin_lock_irqsave(&pair_lock, lock_flags);
+			pair_params->pair_hold = 0;
+			spin_unlock_irqrestore(&pair_lock, lock_flags);
 			if (pair_params->input_dma_channel)
 				dma_release_channel(
 					pair_params->input_dma_channel);
@@ -1833,6 +2046,19 @@ static struct platform_driver mxc_asrc_driver = {
 static __init int asrc_init(void)
 {
 	int ret;
+
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_start_conv = asrc_start_conv;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_stop_conv = asrc_stop_conv;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_get_dma_request = asrc_get_dma_request;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_per_addr = asrc_get_per_addr;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_req_pair = asrc_req_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_config_pair = asrc_config_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_release_pair = asrc_release_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_finish_conv = asrc_finish_conv;
+
+#ifdef CONFIG_SND_MXC_SOC_MX2
+	asrc_p2p_hook(&asrc_pcm_p2p_ops_asrc);
+#endif
 	ret = platform_driver_register(&mxc_asrc_driver);
 	return ret;
 }
@@ -1840,9 +2066,12 @@ static __init int asrc_init(void)
 /*!
  * Exit and free the asrc data
  *
- */
-static void __exit asrc_exit(void)
+ */ static void __exit asrc_exit(void)
 {
+#ifdef CONFIG_SND_MXC_SOC_MX2
+	asrc_p2p_hook(NULL);
+#endif
+
 	platform_driver_unregister(&mxc_asrc_driver);
 	return;
 }
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
index 081fafa..7594ee6 100644
--- a/include/linux/mxc_asrc.h
+++ b/include/linux/mxc_asrc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,18 +27,14 @@
 #define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
 #define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
 #define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
-#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
-#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
-#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
-#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
-#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
-#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
-#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
-#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 10, struct asrc_status_flags)
-#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 11, enum asrc_pair_index)
-
+#define ASRC_CONVERT	_IOW(ASRC_IOC_MAGIC, 3, struct asrc_convert_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 4, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 5, enum asrc_pair_index)
+#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_status_flags)
+#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 7, enum asrc_pair_index)
 
 enum asrc_pair_index {
+	ASRC_UNVALID_PAIR = -1,
 	ASRC_PAIR_A,
 	ASRC_PAIR_B,
 	ASRC_PAIR_C
@@ -112,12 +108,21 @@ struct asrc_querybuf {
 	unsigned long output_offset;
 };
 
+struct asrc_convert_buffer {
+	void *input_buffer_vaddr;
+	void *output_buffer_vaddr;
+	unsigned int input_buffer_length;
+	unsigned int output_buffer_length;
+};
+
 struct asrc_buffer {
 	unsigned int index;
 	unsigned int length;
+	unsigned int output_last_length;
 	int buf_valid;
 };
 
+
 struct asrc_status_flags {
 	enum asrc_pair_index index;
 	unsigned int overload_error;
@@ -134,10 +139,15 @@ enum asrc_error_status {
 };
 
 #ifdef __KERNEL__
+#include <linux/scatterlist.h>
 
 #define ASRC_DMA_BUFFER_NUM		2
 #define ASRC_INPUTFIFO_THRESHOLD	32
 #define ASRC_OUTPUTFIFO_THRESHOLD	32
+#define ASRC_DMA_BUFFER_SIZE	(1024 * 48 * 4)
+#define ASRC_MAX_BUFFER_SIZE	(1024 * 48)
+#define ASRC_OUTPUT_LAST_SAMPLE	8
+
 
 #define ASRC_ASRCTR_REG 	0x00
 #define ASRC_ASRIER_REG 	0x04
@@ -182,10 +192,19 @@ enum asrc_error_status {
 #define ASRC_ASRMCR1C_REG   0xC8
 
 
+#define ASRC_ASRFSTX_INPUT_FIFO_WIDTH	7
+#define ASRC_ASRFSTX_INPUT_FIFO_OFFSET	0
+#define ASRC_ASRFSTX_INPUT_FIFO_MASK	0x7F
+
+#define ASRC_ASRFSTX_OUTPUT_FIFO_WIDTH	7
+#define ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET	12
+#define ASRC_ASRFSTX_OUTPUT_FIFO_MASK (0x7F << ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET)
+
+
 struct dma_block {
 	unsigned int index;
 	unsigned int length;
-	unsigned char *dma_vaddr;
+	void *dma_vaddr;
 	dma_addr_t dma_paddr;
 	struct list_head queue;
 };
@@ -197,16 +216,10 @@ struct asrc_p2p_params {
 
 struct asrc_pair_params {
 	enum asrc_pair_index index;
-	struct list_head input_queue;
-	struct list_head input_done_queue;
-	struct list_head output_queue;
-	struct list_head output_done_queue;
 	wait_queue_head_t input_wait_queue;
 	wait_queue_head_t output_wait_queue;
 	unsigned int input_counter;
 	unsigned int output_counter;
-	unsigned int input_queue_empty;
-	unsigned int output_queue_empty;
 	struct dma_chan *input_dma_channel;
 	struct dma_chan *output_dma_channel;
 	unsigned int input_buffer_size;
@@ -219,8 +232,19 @@ struct asrc_pair_params {
 	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
 	struct dma_block output_dma_total;
 	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_last_period;
 	struct dma_async_tx_descriptor *desc_in;
 	struct dma_async_tx_descriptor *desc_out;
+	struct work_struct task_output_work;
+	unsigned int		input_sg_nodes;
+	unsigned int		output_sg_nodes;
+	struct scatterlist	input_sg[4], output_sg[4];
+	enum asrc_word_width input_word_width;
+	enum asrc_word_width output_word_width;
+	u32 input_sample_rate;
+	u32 output_sample_rate;
+	u32 input_wm;
+	u32 output_wm;
 };
 
 struct asrc_data {
@@ -236,6 +260,19 @@ struct asrc_data {
 	struct device *dev;
 };
 
+struct asrc_p2p_ops {
+	void (*asrc_p2p_start_conv)(enum asrc_pair_index);
+	void (*asrc_p2p_stop_conv)(enum asrc_pair_index);
+	int (*asrc_p2p_get_dma_request)(enum asrc_pair_index, bool);
+	u32 (*asrc_p2p_per_addr)(enum asrc_pair_index, bool);
+	int (*asrc_p2p_req_pair)(int, enum asrc_pair_index *index);
+	int (*asrc_p2p_config_pair)(struct asrc_config *config);
+	void (*asrc_p2p_release_pair)(enum asrc_pair_index);
+	void (*asrc_p2p_finish_conv)(enum asrc_pair_index);
+};
+
+extern void asrc_p2p_hook(struct asrc_p2p_ops *asrc_p2p_ct);
+
 extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
 extern void asrc_release_pair(enum asrc_pair_index index);
 extern int asrc_config_pair(struct asrc_config *config);
@@ -245,6 +282,8 @@ extern void asrc_stop_conv(enum asrc_pair_index index);
 extern u32 asrc_get_per_addr(enum asrc_pair_index index, bool i);
 extern int asrc_get_dma_request(enum asrc_pair_index index, bool i);
 extern void asrc_finish_conv(enum asrc_pair_index index);
+extern int asrc_set_watermark(enum asrc_pair_index index,
+					u32 in_wm, u32 out_wm);
 
 #endif				/* __kERNEL__ */
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 18ae19a..9a59629 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -36,6 +36,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_DA7210 if I2C
 	select SND_SOC_DFBMCS320
 	select SND_SOC_JZ4740_CODEC
+	select SND_SOC_CS42888 if I2C
 	select SND_SOC_LM4857 if I2C
 	select SND_SOC_MAX98088 if I2C
 	select SND_SOC_MAX98095 if I2C
@@ -250,6 +251,13 @@ config SND_SOC_SIGMADSP
 config SND_SOC_SN95031
 	tristate
 
+#CLI CS42888 codec
+config SND_SOC_CS42888
+	tristate
+
+config SND_SOC_SI4763
+        tristate
+
 config SND_SOC_SPDIF
 	tristate
 
diff --git a/sound/soc/codecs/cs42888.c b/sound/soc/codecs/cs42888.c
new file mode 100644
index 0000000..7cd15b2
--- /dev/null
+++ b/sound/soc/codecs/cs42888.c
@@ -0,0 +1,1112 @@
+/*
+ * cs42888.c  -- CS42888 ALSA SoC Audio Driver
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/fsl_devices.h>
+#include <mach/hardware.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+#include "cs42888.h"
+
+#include "../imx/imx-pcm.h"
+#define CS42888_NUM_SUPPLIES 4
+static const char *cs42888_supply_names[CS42888_NUM_SUPPLIES] = {
+	"VA",
+	"VD",
+	"VLS",
+	"VLC",
+};
+
+#define CS42888_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/* CS42888 registers addresses */
+#define CS42888_CHIPID		0x01	/* Chip ID */
+#define CS42888_PWRCTL		0x02	/* Power Control */
+#define CS42888_MODE		0x03	/* Functional Mode */
+#define CS42888_FORMAT		0x04	/* Interface Formats */
+#define CS42888_ADCCTL		0x05	/* ADC Control */
+#define CS42888_TRANS		0x06	/* Transition Control */
+#define CS42888_MUTE		0x07	/* Mute Control */
+#define CS42888_VOLAOUT1	0x08	/* Volume Control AOUT1*/
+#define CS42888_VOLAOUT2	0x09	/* Volume Control AOUT2*/
+#define CS42888_VOLAOUT3	0x0A	/* Volume Control AOUT3*/
+#define CS42888_VOLAOUT4	0x0B	/* Volume Control AOUT4*/
+#define CS42888_VOLAOUT5	0x0C	/* Volume Control AOUT5*/
+#define CS42888_VOLAOUT6	0x0D	/* Volume Control AOUT6*/
+#define CS42888_VOLAOUT7	0x0E	/* Volume Control AOUT7*/
+#define CS42888_VOLAOUT8	0x0F	/* Volume Control AOUT8*/
+#define CS42888_DACINV		0x10	/* DAC Channel Invert */
+#define CS42888_VOLAIN1		0x11	/* Volume Control AIN1 */
+#define CS42888_VOLAIN2		0x12	/* Volume Control AIN2 */
+#define CS42888_VOLAIN3		0x13	/* Volume Control AIN3 */
+#define CS42888_VOLAIN4		0x14	/* Volume Control AIN4 */
+#define CS42888_ADCINV		0x17	/* ADC Channel Invert */
+#define CS42888_STATUSCTL	0x18	/* Status Control */
+#define CS42888_STATUS		0x19	/* Status */
+#define CS42888_STATUSMASK	0x1A	/* Status Mask */
+
+#define CS42888_FIRSTREG	0x01
+#define CS42888_LASTREG		0x1A
+#define CS42888_NUMREGS	(CS42888_LASTREG - CS42888_FIRSTREG + 1)
+#define CS42888_I2C_INCR	0x80
+
+/* Bit masks for the CS42888 registers */
+#define CS42888_CHIPID_ID_MASK	0xF0
+#define CS42888_CHIPID_REV	0x0F
+#define CS42888_PWRCTL_PDN_ADC2_OFFSET		6
+#define CS42888_PWRCTL_PDN_ADC1_OFFSET		5
+#define CS42888_PWRCTL_PDN_DAC4_OFFSET		4
+#define CS42888_PWRCTL_PDN_DAC3_OFFSET		3
+#define CS42888_PWRCTL_PDN_DAC2_OFFSET		2
+#define CS42888_PWRCTL_PDN_DAC1_OFFSET		1
+#define CS42888_PWRCTL_PDN_OFFSET		0
+#define CS42888_PWRCTL_PDN_ADC2_MASK	(1 << CS42888_PWRCTL_PDN_ADC2_OFFSET)
+#define CS42888_PWRCTL_PDN_ADC1_MASK	(1 << CS42888_PWRCTL_PDN_ADC1_OFFSET)
+#define CS42888_PWRCTL_PDN_DAC4_MASK	(1 << CS42888_PWRCTL_PDN_DAC4_OFFSET)
+#define CS42888_PWRCTL_PDN_DAC3_MASK	(1 << CS42888_PWRCTL_PDN_DAC3_OFFSET)
+#define CS42888_PWRCTL_PDN_DAC2_MASK	(1 << CS42888_PWRCTL_PDN_DAC2_OFFSET)
+#define CS42888_PWRCTL_PDN_DAC1_MASK	(1 << CS42888_PWRCTL_PDN_DAC1_OFFSET)
+#define CS42888_PWRCTL_PDN_MASK		(1 << CS42888_PWRCTL_PDN_OFFSET)
+
+#define CS42888_MODE_SPEED_MASK	0xF0
+#define CS42888_MODE_1X		0x00
+#define CS42888_MODE_2X		0x50
+#define CS42888_MODE_4X		0xA0
+#define CS42888_MODE_SLAVE	0xF0
+#define CS42888_MODE_DIV_MASK	0x0E
+#define CS42888_MODE_DIV1	0x00
+#define CS42888_MODE_DIV2	0x02
+#define CS42888_MODE_DIV3	0x04
+#define CS42888_MODE_DIV4	0x06
+#define CS42888_MODE_DIV5	0x08
+
+#define CS42888_FORMAT_FREEZE_OFFSET	7
+#define CS42888_FORMAT_AUX_DIF_OFFSET	6
+#define CS42888_FORMAT_DAC_DIF_OFFSET	3
+#define CS42888_FORMAT_ADC_DIF_OFFSET	0
+#define CS42888_FORMAT_FREEZE_MASK	(1 << CS42888_FORMAT_FREEZE_OFFSET)
+#define CS42888_FORMAT_AUX_DIF_MASK	(1 << CS42888_FORMAT_AUX_DIF_OFFSET)
+#define CS42888_FORMAT_DAC_DIF_MASK	(7 << CS42888_FORMAT_DAC_DIF_OFFSET)
+#define CS42888_FORMAT_ADC_DIF_MASK	(7 << CS42888_FORMAT_ADC_DIF_OFFSET)
+
+#define CS42888_TRANS_DAC_SNGVOL_OFFSET	    7
+#define CS42888_TRANS_DAC_SZC_OFFSET	    5
+#define CS42888_TRANS_AMUTE_OFFSET	    4
+#define CS42888_TRANS_MUTE_ADC_SP_OFFSET    3
+#define CS42888_TRANS_ADC_SNGVOL_OFFSET	    2
+#define CS42888_TRANS_ADC_SZC_OFFSET	    0
+#define CS42888_TRANS_DAC_SNGVOL_MASK	(1 << CS42888_TRANS_DAC_SNGVOL_OFFSET)
+#define CS42888_TRANS_DAC_SZC_MASK	(3 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_AMUTE_MASK	(1 << CS42888_TRANS_AMUTE_OFFSET)
+#define CS42888_TRANS_MUTE_ADC_SP_MASK	(1 << CS42888_TRANS_MUTE_ADC_SP_OFFSET)
+#define CS42888_TRANS_ADC_SNGVOL_MASK	(1 << CS42888_TRANS_ADC_SNGVOL_OFFSET)
+#define CS42888_TRANS_ADC_SZC_MASK	(3 << CS42888_TRANS_ADC_SZC_OFFSET)
+
+#define CS42888_TRANS_DAC_SZC_IC     (0 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_ZC     (1 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SR     (2 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SRZC   (3 << CS42888_TRANS_DAC_SZC_OFFSET)
+
+#define CS42888_MUTE_AOUT8	(0x1 << 7)
+#define CS42888_MUTE_AOUT7	(0x1 << 6)
+#define CS42888_MUTE_AOUT6	(0x1 << 5)
+#define CS42888_MUTE_AOUT5	(0x1 << 4)
+#define CS42888_MUTE_AOUT4	(0x1 << 3)
+#define CS42888_MUTE_AOUT3	(0x1 << 2)
+#define CS42888_MUTE_AOUT2	(0x1 << 1)
+#define CS42888_MUTE_AOUT1	(0x1 << 0)
+#define CS42888_MUTE_ALL	(CS42888_MUTE_AOUT1 | CS42888_MUTE_AOUT2 | \
+				CS42888_MUTE_AOUT3 | CS42888_MUTE_AOUT4 | \
+				CS42888_MUTE_AOUT5 | CS42888_MUTE_AOUT6 | \
+				CS42888_MUTE_AOUT7 | CS42888_MUTE_AOUT8)
+
+#define DIF_LEFT_J		0
+#define DIF_I2S			1
+#define DIF_RIGHT_J		2
+#define DIF_TDM			6
+
+/* Private data for the CS42888 */
+struct cs42888_private {
+	struct snd_soc_codec *codec;
+	u8 reg_cache[CS42888_NUMREGS + 1];
+	unsigned int mclk; /* Input frequency of the MCLK pin */
+	unsigned int mode; /* The mode (I2S or left-justified) */
+	unsigned int slave_mode;
+	unsigned int manual_mute;
+	struct regulator_bulk_data supplies[CS42888_NUM_SUPPLIES];
+	struct mxc_audio_codec_platform_data pdata;
+};
+
+/**
+ * cs42888_fill_cache - pre-fill the CS42888 register cache.
+ * @codec: the codec for this CS42888
+ *
+ * This function fills in the CS42888 register cache by reading the register
+ * values from the hardware.
+ *
+ * This CS42888 registers are cached to avoid excessive I2C I/O operations.
+ * After the initial read to pre-fill the cache, the CS42888 never updates
+ * the register values, so we won't have a cache coherency problem.
+ *
+ * We use the auto-increment feature of the CS42888 to read all registers in
+ * one shot.
+ */
+static int cs42888_fill_cache(struct snd_soc_codec *codec)
+{
+	u8 *cache = codec->reg_cache;
+	struct i2c_client *i2c_client = codec->control_data;
+	s32 length;
+
+	length = i2c_smbus_read_i2c_block_data(i2c_client,
+		CS42888_FIRSTREG | CS42888_I2C_INCR, CS42888_NUMREGS, \
+		cache + 1);
+
+	if (length != CS42888_NUMREGS) {
+		dev_err(codec->dev, "i2c read failure, addr=0x%x\n",
+		       i2c_client->addr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+#ifdef CS42888_DEBUG
+static void dump_reg(struct snd_soc_codec *codec)
+{
+	int i, reg;
+	int ret;
+	u8 *cache = codec->reg_cache + 1;
+
+	printk(KERN_DEBUG "dump begin\n");
+	printk(KERN_DEBUG "reg value in cache\n");
+	for (i = 0; i < CS42888_NUMREGS; i++)
+		printk(KERN_DEBUG "reg[%d] = 0x%x\n", i, cache[i]);
+
+	printk(KERN_DEBUG "real reg value\n");
+	ret = cs42888_fill_cache(codec);
+	if (ret < 0) {
+		pr_err("failed to fill register cache\n");
+		return ret;
+	}
+	for (i = 0; i < CS42888_NUMREGS; i++)
+		printk(KERN_DEBUG "reg[%d] = 0x%x\n", i, cache[i]);
+
+	printk(KERN_DEBUG "dump end\n");
+}
+#else
+static void dump_reg(struct snd_soc_codec *codec)
+{
+}
+#endif
+
+/* -127.5dB to 0dB with step of 0.5dB */
+static const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);
+/* -64dB to 24dB with step of 0.5dB */
+static const DECLARE_TLV_DB_SCALE(adc_tlv, -6400, 50, 1);
+
+static int cs42888_out_vu(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	int ret;
+	u16 val;
+
+	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* Now write again with the volume update bit set */
+	val = snd_soc_read(codec, reg);
+	ret = snd_soc_write(codec, reg, val);
+
+	val = snd_soc_read(codec, reg2);
+	ret = snd_soc_write(codec, reg2, val);
+	return 0;
+}
+
+int cs42888_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
+	int min = mc->min;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max-min;
+	return 0;
+}
+
+int cs42888_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	int min = mc->min;
+	int val = snd_soc_read(codec, reg);
+
+	ucontrol->value.integer.value[0] =
+		((signed char)(val))-min;
+
+	val = snd_soc_read(codec, reg2);
+	ucontrol->value.integer.value[1] =
+		((signed char)(val))-min;
+	return 0;
+}
+
+int cs42888_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	int min = mc->min;
+	unsigned short val;
+	int ret;
+
+	val = (ucontrol->value.integer.value[0]+min);
+	ret = snd_soc_write(codec, reg, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	val = ((ucontrol->value.integer.value[1]+min));
+	ret = snd_soc_write(codec, reg2, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+#define SOC_CS42888_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, \
+				    xinvert, tlv_array)			\
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		SNDRV_CTL_ELEM_ACCESS_READWRITE,  \
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, \
+	.put = cs42888_out_vu, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, \
+		    .rreg = reg_right, \
+		    .shift = xshift, \
+		    .max = xmax, \
+		    .invert = xinvert} \
+}
+
+#define SOC_CS42888_DOUBLE_R_S8_TLV(xname, reg_left, reg_right, xmin, xmax, \
+				    tlv_array) \
+{	.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
+		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.tlv.p  = (tlv_array), \
+	.info   = cs42888_info_volsw_s8, .get = cs42888_get_volsw_s8, \
+	.put    = cs42888_put_volsw_s8, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, \
+		    .rreg = reg_right, \
+		    .min = xmin, \
+		    .max = xmax} \
+}
+
+static const char *cs42888_adcfilter[] = { "None", "High Pass" };
+static const char *cs42888_dacinvert[] = { "Disabled", "Enabled" };
+static const char *cs42888_adcinvert[] = { "Disabled", "Enabled" };
+static const char *cs42888_dacamute[] = { "Disabled", "AutoMute" };
+static const char *cs42888_dac_sngvol[] = { "Disabled", "Enabled" };
+static const char *cs42888_dac_szc[] = { "Immediate Change", "Zero Cross",
+				"Soft Ramp", "Soft Ramp on Zero Cross" };
+static const char *cs42888_mute_adc[] = { "UnMute", "Mute" };
+static const char *cs42888_adc_sngvol[] = { "Disabled", "Enabled" };
+static const char *cs42888_adc_szc[] = { "Immediate Change", "Zero Cross",
+				"Soft Ramp", "Soft Ramp on Zero Cross" };
+static const char *cs42888_dac_dem[] = { "No-De-Emphasis", "De-Emphasis" };
+static const char *cs42888_adc_single[] = { "Differential", "Single-Ended" };
+
+static const struct soc_enum cs42888_enum[] = {
+	SOC_ENUM_SINGLE(CS42888_ADCCTL, 7, 2, cs42888_adcfilter),
+	SOC_ENUM_DOUBLE(CS42888_DACINV, 0, 1, 2, cs42888_dacinvert),
+	SOC_ENUM_DOUBLE(CS42888_DACINV, 2, 3, 2, cs42888_dacinvert),
+	SOC_ENUM_DOUBLE(CS42888_DACINV, 4, 5, 2, cs42888_dacinvert),
+	SOC_ENUM_DOUBLE(CS42888_DACINV, 6, 7, 2, cs42888_dacinvert),
+	SOC_ENUM_DOUBLE(CS42888_ADCINV, 0, 1, 2, cs42888_adcinvert),
+	SOC_ENUM_DOUBLE(CS42888_ADCINV, 2, 3, 2, cs42888_adcinvert),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 4, 2, cs42888_dacamute),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 7, 2, cs42888_dac_sngvol),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 5, 4, cs42888_dac_szc),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 3, 2, cs42888_mute_adc),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 2, 2, cs42888_adc_sngvol),
+	SOC_ENUM_SINGLE(CS42888_TRANS, 0, 4, cs42888_adc_szc),
+	SOC_ENUM_SINGLE(CS42888_ADCCTL, 5, 2, cs42888_dac_dem),
+	SOC_ENUM_SINGLE(CS42888_ADCCTL, 4, 2, cs42888_adc_single),
+	SOC_ENUM_SINGLE(CS42888_ADCCTL, 3, 2, cs42888_adc_single),
+};
+
+static const struct snd_kcontrol_new cs42888_snd_controls[] = {
+SOC_CS42888_DOUBLE_R_TLV("DAC1 Playback Volume",
+			    CS42888_VOLAOUT1,
+			    CS42888_VOLAOUT2,
+			    0, 0xff, 1, dac_tlv),
+SOC_CS42888_DOUBLE_R_TLV("DAC2 Playback Volume",
+			    CS42888_VOLAOUT3,
+			    CS42888_VOLAOUT4,
+			    0, 0xff, 1, dac_tlv),
+SOC_CS42888_DOUBLE_R_TLV("DAC3 Playback Volume",
+			    CS42888_VOLAOUT5,
+			    CS42888_VOLAOUT6,
+			    0, 0xff, 1, dac_tlv),
+SOC_CS42888_DOUBLE_R_TLV("DAC4 Playback Volume",
+			    CS42888_VOLAOUT7,
+			    CS42888_VOLAOUT8,
+			    0, 0xff, 1, dac_tlv),
+SOC_CS42888_DOUBLE_R_S8_TLV("ADC1 Capture Volume",
+			    CS42888_VOLAIN1,
+			    CS42888_VOLAIN2,
+			    -128, 48, adc_tlv),
+SOC_CS42888_DOUBLE_R_S8_TLV("ADC2 Capture Volume",
+			    CS42888_VOLAIN3,
+			    CS42888_VOLAIN4,
+			    -128, 48, adc_tlv),
+SOC_ENUM("ADC High-Pass Filter Switch", cs42888_enum[0]),
+SOC_ENUM("DAC1 Invert Switch", cs42888_enum[1]),
+SOC_ENUM("DAC2 Invert Switch", cs42888_enum[2]),
+SOC_ENUM("DAC3 Invert Switch", cs42888_enum[3]),
+SOC_ENUM("DAC4 Invert Switch", cs42888_enum[4]),
+SOC_ENUM("ADC1 Invert Switch", cs42888_enum[5]),
+SOC_ENUM("ADC2 Invert Switch", cs42888_enum[6]),
+SOC_ENUM("DAC Auto Mute Switch", cs42888_enum[7]),
+SOC_ENUM("DAC Single Volume Control Switch", cs42888_enum[8]),
+SOC_ENUM("DAC Soft Ramp and Zero Cross Control Switch", cs42888_enum[9]),
+SOC_ENUM("Mute ADC Serial Port Switch", cs42888_enum[10]),
+SOC_ENUM("ADC Single Volume Control Switch", cs42888_enum[11]),
+SOC_ENUM("ADC Soft Ramp and Zero Cross Control Switch", cs42888_enum[12]),
+SOC_ENUM("DAC Deemphasis Switch", cs42888_enum[13]),
+SOC_ENUM("ADC1 Single Ended Mode Switch", cs42888_enum[14]),
+SOC_ENUM("ADC2 Single Ended Mode Switch", cs42888_enum[15]),
+};
+
+
+static const struct snd_soc_dapm_widget cs42888_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC1", "Playback", CS42888_PWRCTL, 1, 1),
+SND_SOC_DAPM_DAC("DAC2", "Playback", CS42888_PWRCTL, 2, 1),
+SND_SOC_DAPM_DAC("DAC3", "Playback", CS42888_PWRCTL, 3, 1),
+SND_SOC_DAPM_DAC("DAC4", "Playback", CS42888_PWRCTL, 4, 1),
+
+SND_SOC_DAPM_OUTPUT("AOUT1L"),
+SND_SOC_DAPM_OUTPUT("AOUT1R"),
+SND_SOC_DAPM_OUTPUT("AOUT2L"),
+SND_SOC_DAPM_OUTPUT("AOUT2R"),
+SND_SOC_DAPM_OUTPUT("AOUT3L"),
+SND_SOC_DAPM_OUTPUT("AOUT3R"),
+SND_SOC_DAPM_OUTPUT("AOUT4L"),
+SND_SOC_DAPM_OUTPUT("AOUT4R"),
+
+SND_SOC_DAPM_ADC("ADC1", "Capture", CS42888_PWRCTL, 5, 1),
+SND_SOC_DAPM_ADC("ADC2", "Capture", CS42888_PWRCTL, 6, 1),
+
+SND_SOC_DAPM_INPUT("AIN1L"),
+SND_SOC_DAPM_INPUT("AIN1R"),
+SND_SOC_DAPM_INPUT("AIN2L"),
+SND_SOC_DAPM_INPUT("AIN2R"),
+
+SND_SOC_DAPM_PGA_E("PWR", CS42888_PWRCTL, 0, 1, NULL, 0,
+			NULL, 0),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Playback */
+	{ "PWR", NULL, "DAC1" },
+	{ "PWR", NULL, "DAC1" },
+
+	{ "PWR", NULL, "DAC2" },
+	{ "PWR", NULL, "DAC2" },
+
+	{ "PWR", NULL, "DAC3" },
+	{ "PWR", NULL, "DAC3" },
+
+	{ "PWR", NULL, "DAC4" },
+	{ "PWR", NULL, "DAC4" },
+
+	{ "AOUT1L", NULL, "PWR" },
+	{ "AOUT1R", NULL, "PWR" },
+
+	{ "AOUT2L", NULL, "PWR" },
+	{ "AOUT2R", NULL, "PWR" },
+
+	{ "AOUT3L", NULL, "PWR" },
+	{ "AOUT3R", NULL, "PWR" },
+
+	{ "AOUT4L", NULL, "PWR" },
+	{ "AOUT4R", NULL, "PWR" },
+
+	/* Capture */
+	{ "PWR", NULL, "AIN1L" },
+	{ "PWR", NULL, "AIN1R" },
+
+	{ "PWR", NULL, "AIN2L" },
+	{ "PWR", NULL, "AIN2R" },
+
+	{ "ADC1", NULL, "PWR" },
+	{ "ADC1", NULL, "PWR" },
+
+	{ "ADC2", NULL, "PWR" },
+	{ "ADC2", NULL, "PWR" },
+};
+
+
+static int cs42888_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(&codec->dapm, cs42888_dapm_widgets,
+				  ARRAY_SIZE(cs42888_dapm_widgets));
+
+	snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(&codec->dapm);
+	return 0;
+}
+
+/**
+ * struct cs42888_mode_ratios - clock ratio tables
+ * @ratio: the ratio of MCLK to the sample rate
+ * @speed_mode: the Speed Mode bits to set in the Mode Control register for
+ *              this ratio
+ * @mclk: the Ratio Select bits to set in the Mode Control register for this
+ *        ratio
+ *
+ * The data for this chart is taken from Table 10 of the CS42888 reference
+ * manual.
+ *
+ * This table is used to determine how to program the Functional Mode register.
+ * It is also used by cs42888_set_dai_sysclk() to tell ALSA which sampling
+ * rates the CS42888 currently supports.
+ *
+ * @speed_mode is the corresponding bit pattern to be written to the
+ * MODE bits of the Mode Control Register
+ *
+ * @mclk is the corresponding bit pattern to be wirten to the MCLK bits of
+ * the Mode Control Register.
+ *
+ */
+struct cs42888_mode_ratios {
+	unsigned int ratio;
+	u8 speed_mode;
+	u8 mclk;
+};
+
+static struct cs42888_mode_ratios cs42888_mode_ratios[] = {
+	{64, CS42888_MODE_4X, CS42888_MODE_DIV1},
+	{96, CS42888_MODE_4X, CS42888_MODE_DIV2},
+	{128, CS42888_MODE_2X, CS42888_MODE_DIV1},
+	{192, CS42888_MODE_2X, CS42888_MODE_DIV2},
+	{256, CS42888_MODE_1X, CS42888_MODE_DIV1},
+	{384, CS42888_MODE_2X, CS42888_MODE_DIV4},
+	{512, CS42888_MODE_1X, CS42888_MODE_DIV3},
+	{768, CS42888_MODE_1X, CS42888_MODE_DIV4},
+	{1024, CS42888_MODE_1X, CS42888_MODE_DIV5}
+};
+
+/* The number of MCLK/LRCK ratios supported by the CS42888 */
+#define NUM_MCLK_RATIOS		ARRAY_SIZE(cs42888_mode_ratios)
+
+/**
+ * cs42888_set_dai_sysclk - determine the CS42888 samples rates.
+ * @codec_dai: the codec DAI
+ * @clk_id: the clock ID (ignored)
+ * @freq: the MCLK input frequency
+ * @dir: the clock direction (ignored)
+ *
+ * This function is used to tell the codec driver what the input MCLK
+ * frequency is.
+ *
+ */
+static int cs42888_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct cs42888_private *cs42888 = snd_soc_codec_get_drvdata(codec);
+
+	cs42888->mclk = freq;
+	return 0;
+}
+
+/**
+ * cs42888_set_dai_fmt - configure the codec for the selected audio format
+ * @codec_dai: the codec DAI
+ * @format: a SND_SOC_DAIFMT_x value indicating the data format
+ *
+ * This function takes a bitmask of SND_SOC_DAIFMT_x bits and programs the
+ * codec accordingly.
+ *
+ * Currently, this function only supports SND_SOC_DAIFMT_I2S and
+ * SND_SOC_DAIFMT_LEFT_J.  The CS42888 codec also supports right-justified
+ * data for playback only, but ASoC currently does not support different
+ * formats for playback vs. record.
+ */
+static int cs42888_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int format)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct cs42888_private *cs42888 =  snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+	u8 val;
+
+	val = snd_soc_read(codec, CS42888_FORMAT);
+	val &= ~CS42888_FORMAT_DAC_DIF_MASK;
+	val &= ~CS42888_FORMAT_ADC_DIF_MASK;
+	/* set DAI format */
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		val |= DIF_LEFT_J << CS42888_FORMAT_DAC_DIF_OFFSET;
+		val |= DIF_LEFT_J << CS42888_FORMAT_ADC_DIF_OFFSET;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val |= DIF_I2S << CS42888_FORMAT_DAC_DIF_OFFSET;
+		val |= DIF_I2S << CS42888_FORMAT_ADC_DIF_OFFSET;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val |= DIF_RIGHT_J << CS42888_FORMAT_DAC_DIF_OFFSET;
+		val |= DIF_RIGHT_J << CS42888_FORMAT_ADC_DIF_OFFSET;
+		break;
+	default:
+		dev_err(codec->dev, "invalid dai format\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = snd_soc_write(codec, CS42888_FORMAT, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	val = snd_soc_read(codec, CS42888_MODE);
+	/* set master/slave audio interface */
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		cs42888->slave_mode = 1;
+		val &= ~CS42888_MODE_SPEED_MASK;
+		val |= CS42888_MODE_SLAVE;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		cs42888->slave_mode = 0;
+		break;
+	default:
+		/* all other modes are unsupported by the hardware */
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = snd_soc_write(codec, CS42888_MODE, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	dump_reg(codec);
+	return ret;
+}
+
+/**
+ * cs42888_hw_params - program the CS42888 with the given hardware parameters.
+ * @substream: the audio stream
+ * @params: the hardware parameters to set
+
+ * @dai: the SOC DAI (ignored)
+ *
+ * This function programs the hardware with the values provided.
+ * Specifically, the sample rate and the data format.
+ *
+ * The .ops functions are used to provide board-specific data, like input
+ * frequencies, to this driver.  This function takes that information,
+ * combines it with the hardware parameters provided, and programs the
+ * hardware accordingly.
+ */
+static int cs42888_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct cs42888_private *cs42888 =  snd_soc_codec_get_drvdata(codec);
+	int ret;
+	unsigned int i;
+	unsigned int rate;
+	unsigned int ratio;
+	u32 val;
+
+	if (iprtd->asrc_enable)
+		rate = iprtd->p2p->p2p_rate;
+	else
+		rate = params_rate(params);	/* Sampling rate, in Hz */
+	ratio = cs42888->mclk / rate;	/* MCLK/LRCK ratio */
+	for (i = 0; i < NUM_MCLK_RATIOS; i++) {
+		if (cs42888_mode_ratios[i].ratio == ratio)
+			break;
+	}
+
+	if (i == NUM_MCLK_RATIOS) {
+		/* We did not find a matching ratio */
+		dev_err(codec->dev, "could not find matching ratio\n");
+		return -EINVAL;
+	}
+
+	if (!cs42888->slave_mode) {
+		val = snd_soc_read(codec, CS42888_MODE);
+		val &= ~CS42888_MODE_SPEED_MASK;
+		val |= cs42888_mode_ratios[i].speed_mode;
+		val &= ~CS42888_MODE_DIV_MASK;
+		val |= cs42888_mode_ratios[i].mclk;
+	} else {
+		val = snd_soc_read(codec, CS42888_MODE);
+		val &= ~CS42888_MODE_SPEED_MASK;
+		val |= CS42888_MODE_SLAVE;
+		val &= ~CS42888_MODE_DIV_MASK;
+		val |= cs42888_mode_ratios[i].mclk;
+	}
+	ret = snd_soc_write(codec, CS42888_MODE, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	/* Unmute all the channels */
+	val = snd_soc_read(codec, CS42888_MUTE);
+	val &= ~CS42888_MUTE_ALL;
+	ret = snd_soc_write(codec, CS42888_MUTE, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+
+	ret = cs42888_fill_cache(codec);
+	if (ret < 0) {
+		pr_err("failed to fill register cache\n");
+		return ret;
+	}
+
+	dump_reg(codec);
+	return ret;
+}
+
+/**
+ * cs42888_shutdown - cs42888 enters into low power mode again.
+ * @substream: the audio stream
+ * @dai: the SOC DAI (ignored)
+ *
+ * The .ops functions are used to provide board-specific data, like input
+ * frequencies, to this driver.  This function takes that information,
+ * combines it with the hardware parameters provided, and programs the
+ * hardware accordingly.
+ */
+static void cs42888_shutdown(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	int ret;
+	u8 val;
+
+	/* Mute all the channels */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		val = snd_soc_read(codec, CS42888_MUTE);
+		val |= CS42888_MUTE_ALL;
+		ret = snd_soc_write(codec, CS42888_MUTE, val);
+		if (ret < 0)
+			pr_err("i2c write failed\n");
+	}
+
+}
+
+static int cs42888_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_dai *tmp_codec_dai;
+	struct snd_soc_pcm_runtime *tmp_rtd;
+	u32 i;
+
+	for (i = 0; i < card->num_rtd; i++) {
+		tmp_codec_dai = card->rtd[i].codec_dai;
+		tmp_rtd = (struct snd_soc_pcm_runtime *)(card->rtd + i);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+			tmp_codec_dai->pop_wait) {
+			tmp_codec_dai->pop_wait = 0;
+			cancel_delayed_work(&tmp_rtd->delayed_work);
+		}
+	}
+	return 0;
+}
+
+static struct snd_soc_dai_ops cs42888_dai_ops = {
+	.set_fmt	= cs42888_set_dai_fmt,
+	.set_sysclk	= cs42888_set_dai_sysclk,
+	.hw_params	= cs42888_hw_params,
+	.shutdown	= cs42888_shutdown,
+	.prepare	= cs42888_prepare,
+};
+
+
+struct snd_soc_dai_driver cs42888_dai[] = {
+	{
+	.name = "CS42888",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = (SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |
+			SNDRV_PCM_RATE_192000),
+		.formats = CS42888_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 4,
+		.rates = (SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |
+			SNDRV_PCM_RATE_192000),
+		.formats = CS42888_FORMATS,
+	},
+	.ops = &cs42888_dai_ops,
+	},
+	{
+		.name = "CS42888_ASRC",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = CS42888_FORMATS,
+		},
+		.ops = &cs42888_dai_ops,
+	},
+};
+
+/**
+ * cs42888_probe - ASoC probe function
+ * @pdev: platform device
+ *
+ * This function is called when ASoC has all the pieces it needs to
+ * instantiate a sound driver.
+ */
+static int cs42888_probe(struct snd_soc_codec *codec)
+{
+	int ret, i;
+	int val;
+
+	struct cs42888_private *cs42888 = snd_soc_codec_get_drvdata(codec);
+	cs42888->codec = codec;
+
+	/* setup i2c data ops */
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+		for (i = 0; i < ARRAY_SIZE(cs42888->supplies); i++)
+			cs42888->supplies[i].supply = cs42888_supply_names[i];
+
+		ret = regulator_bulk_get(codec->dev,
+			ARRAY_SIZE(cs42888->supplies), cs42888->supplies);
+		if (ret != 0) {
+			dev_err(codec->dev, "Failed to request supplies: %d\n",
+				ret);
+			return ret;
+		}
+
+		ret = regulator_bulk_enable(ARRAY_SIZE(cs42888->supplies),
+				cs42888->supplies);
+		if (ret != 0) {
+			dev_err(codec->dev, "Failed to enable supplies: %d\n",
+				ret);
+			goto err;
+		}
+	}
+	msleep(1);
+
+	/* The I2C interface is set up, so pre-fill our register cache */
+	ret = cs42888_fill_cache(codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to fill register cache\n");
+		goto err;
+	}
+
+	/* Enter low power state */
+	val = snd_soc_read(codec, CS42888_PWRCTL);
+	val |= CS42888_PWRCTL_PDN_MASK;
+	ret = snd_soc_write(codec, CS42888_PWRCTL, val);
+	if (ret < 0) {
+		dev_err(codec->dev, "i2c write failed\n");
+		return ret;
+	}
+
+	/* Disable auto-mute */
+	val = snd_soc_read(codec, CS42888_TRANS);
+	val &= ~CS42888_TRANS_AMUTE_MASK;
+	val &= ~CS42888_TRANS_DAC_SZC_MASK;
+	val |=  CS42888_TRANS_DAC_SZC_SR;
+	ret = snd_soc_write(codec, CS42888_TRANS, val);
+	if (ret < 0) {
+		pr_err("i2c write failed\n");
+		return ret;
+	}
+	/* Add the non-DAPM controls */
+	snd_soc_add_codec_controls(codec, cs42888_snd_controls,
+				ARRAY_SIZE(cs42888_snd_controls));
+
+	/* Add DAPM controls */
+	cs42888_add_widgets(codec);
+
+	return 0;
+err:
+	regulator_bulk_disable(ARRAY_SIZE(cs42888->supplies),
+						cs42888->supplies);
+	regulator_bulk_free(ARRAY_SIZE(cs42888->supplies),
+				cs42888->supplies);
+	return ret;
+}
+
+/**
+ * cs42888_remove - ASoC remove function
+ * @pdev: platform device
+ *
+ * This function is the counterpart to cs42888_probe().
+ */
+static int cs42888_remove(struct snd_soc_codec *codec)
+{
+	struct cs42888_private *cs42888 = snd_soc_codec_get_drvdata(codec);
+
+	regulator_bulk_disable(ARRAY_SIZE(cs42888->supplies),
+						cs42888->supplies);
+	regulator_bulk_free(ARRAY_SIZE(cs42888->supplies),
+				cs42888->supplies);
+
+	return 0;
+};
+
+/*
+ * ASoC codec device structure
+ *
+ * Assign this variable to the codec_dev field of the machine driver's
+ * snd_soc_device structure.
+ */
+struct snd_soc_codec_driver cs42888_driver = {
+	.probe =	cs42888_probe,
+	.remove =	cs42888_remove,
+	.reg_cache_size = CS42888_NUMREGS + 1,
+	.reg_word_size = sizeof(u8),
+	.reg_cache_step = 1,
+};
+
+/**
+ * cs42888_i2c_probe - initialize the I2C interface of the CS42888
+ * @i2c_client: the I2C client object
+ * @id: the I2C device ID (ignored)
+ *
+ * This function is called whenever the I2C subsystem finds a device that
+ * matches the device ID given via a prior call to i2c_add_driver().
+ */
+static int cs42888_i2c_probe(struct i2c_client *i2c_client,
+	const struct i2c_device_id *id)
+{
+	struct cs42888_private *cs42888;
+	int ret;
+	int val;
+
+	/* Verify that we have a CS42888 */
+	val = i2c_smbus_read_byte_data(i2c_client, CS42888_CHIPID);
+	if (val < 0) {
+		pr_err("Device with ID register %x is not a CS42888", val);
+		return -ENODEV;
+	}
+	/* The top four bits of the chip ID should be 0000. */
+	if ((val & CS42888_CHIPID_ID_MASK) != 0x00) {
+		dev_err(&i2c_client->dev, "device is not a CS42888\n");
+		return -ENODEV;
+	}
+
+	dev_info(&i2c_client->dev, "found device at i2c address %X\n",
+		i2c_client->addr);
+	dev_info(&i2c_client->dev, "hardware revision %X\n", val & 0xF);
+
+	/* Allocate enough space for the snd_soc_codec structure
+	   and our private data together. */
+	cs42888 = kzalloc(sizeof(struct cs42888_private), GFP_KERNEL);
+	if (!cs42888) {
+		dev_err(&i2c_client->dev, "could not allocate codec\n");
+		return -ENOMEM;
+	}
+
+	if (i2c_client->dev.platform_data) {
+		memcpy(&cs42888->pdata, i2c_client->dev.platform_data,
+				sizeof(cs42888->pdata));
+		cs42888_dai[0].playback.rates = cs42888->pdata.rates;
+		cs42888_dai[0].capture.rates = cs42888->pdata.rates;
+	}
+
+	i2c_set_clientdata(i2c_client, cs42888);
+
+	ret = snd_soc_register_codec(&i2c_client->dev,
+		&cs42888_driver, cs42888_dai, 2);
+	if (ret) {
+		dev_err(&i2c_client->dev, "Failed to register codec:%d\n", ret);
+		kfree(cs42888);
+	return ret;
+	}
+	return 0;
+}
+
+/**
+ * cs42888_i2c_remove - remove an I2C device
+ * @i2c_client: the I2C client object
+ *
+ * This function is the counterpart to cs42888_i2c_probe().
+ */
+static int cs42888_i2c_remove(struct i2c_client *i2c_client)
+{
+	struct cs42888_private *cs42888 = i2c_get_clientdata(i2c_client);
+
+	snd_soc_unregister_codec(&i2c_client->dev);
+	kfree(cs42888);
+
+	return 0;
+}
+
+/*
+ * cs42888_i2c_id - I2C device IDs supported by this driver
+ */
+static struct i2c_device_id cs42888_i2c_id[] = {
+	{"cs42888", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, cs42888_i2c_id);
+
+#ifdef CONFIG_PM
+/* This suspend/resume implementation can handle both - a simple standby
+ * where the codec remains powered, and a full suspend, where the voltage
+ * domain the codec is connected to is teared down and/or any other hardware
+ * reset condition is asserted.
+ *
+ * The codec's own power saving features are enabled in the suspend callback,
+ * and all registers are written back to the hardware when resuming.
+ */
+
+static int cs42888_i2c_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct cs42888_private *cs42888 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = cs42888->codec;
+	int reg = snd_soc_read(codec, CS42888_PWRCTL) | CS42888_PWRCTL_PDN_MASK;
+
+	return snd_soc_write(codec, CS42888_PWRCTL, reg);
+}
+
+static int cs42888_i2c_resume(struct i2c_client *client)
+{
+	struct cs42888_private *cs42888 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = cs42888->codec;
+	int reg;
+
+	/* In case the device was put to hard reset during sleep, we need to
+	 * wait 500ns here before any I2C communication. */
+	ndelay(500);
+
+	/* first restore the entire register cache ... */
+	for (reg = CS42888_FIRSTREG; reg <= CS42888_LASTREG; reg++) {
+		u8 val = snd_soc_read(codec, reg);
+
+		if (i2c_smbus_write_byte_data(client, reg, val)) {
+			dev_err(codec->dev, "i2c write failed\n");
+			return -EIO;
+		}
+	}
+
+	/* ... then disable the power-down bits */
+	reg = snd_soc_read(codec, CS42888_PWRCTL);
+	reg &= ~CS42888_PWRCTL_PDN_MASK;
+
+	return snd_soc_write(codec, CS42888_PWRCTL, reg);
+}
+#else
+#define cs42888_i2c_suspend	NULL
+#define cs42888_i2c_resume	NULL
+#endif /* CONFIG_PM */
+
+/*
+ * cs42888_i2c_driver - I2C device identification
+ *
+ * This structure tells the I2C subsystem how to identify and support a
+ * given I2C device type.
+ */
+static struct i2c_driver cs42888_i2c_driver = {
+	.driver = {
+		.name = "cs42888",
+		.owner = THIS_MODULE,
+	},
+	.probe = cs42888_i2c_probe,
+	.remove = cs42888_i2c_remove,
+	.suspend = cs42888_i2c_suspend,
+	.resume = cs42888_i2c_resume,
+	.id_table = cs42888_i2c_id,
+};
+
+static int __init cs42888_init(void)
+{
+	pr_info("Cirrus Logic CS42888 ALSA SoC Codec Driver\n");
+	return i2c_add_driver(&cs42888_i2c_driver);
+}
+module_init(cs42888_init);
+
+static void __exit cs42888_exit(void)
+{
+	i2c_del_driver(&cs42888_i2c_driver);
+}
+module_exit(cs42888_exit);
+
+MODULE_AUTHOR("Xu Lionel <R63889@freescale.com>");
+MODULE_DESCRIPTION("Cirrus Logic CS42888 ALSA SoC Codec Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/cs42888.h b/sound/soc/codecs/cs42888.h
new file mode 100644
index 0000000..a7c92d5
--- /dev/null
+++ b/sound/soc/codecs/cs42888.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _CS42888_H
+#define _CS42888_H
+
+/*
+ * The ASoC codec DAI structure for the CS42888.  Assign this structure to
+ * the .codec_dai field of your machine driver's snd_soc_dai_link structure.
+ */
+extern struct snd_soc_dai_driver cs42888_dai[];
+
+/*
+ * The ASoC codec device structure for the CS42888.  Assign this structure
+ * to the .codec_dev field of your machine driver's snd_soc_device
+ * structure.
+ */
+extern struct snd_soc_codec_device soc_codec_device_cs42888;
+
+extern void gpio_cs42888_pdwn(int pdwn);
+#endif
diff --git a/sound/soc/codecs/mxc_spdif.c b/sound/soc/codecs/mxc_spdif.c
index 3597210..eaa7e6e 100644
--- a/sound/soc/codecs/mxc_spdif.c
+++ b/sound/soc/codecs/mxc_spdif.c
@@ -1,7 +1,7 @@
 /*
  * MXC SPDIF ALSA Soc Codec Driver
  *
- * Copyright (C) 2007-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -379,10 +379,8 @@ static void spdif_write_channel_status(void)
 	ch_status = reverse_bits(mxc_spdif_control.ch_status[3]) << 16;
 	__raw_writel(ch_status, SPDIF_REG_STCSCL + spdif_base_addr);
 
-	pr_debug("STCSCH: 0x%06x\n",
-			__raw_readl(spdif_base_addr + SPDIF_REG_STCSCH));
-	pr_debug("STCSCL: 0x%06x\n",
-			__raw_readl(spdif_base_addr + SPDIF_REG_STCSCL));
+	pr_debug("STCSCH: 0x%06x\n", __raw_readl(spdif_base_addr + SPDIF_REG_STCSCH));
+	pr_debug("STCSCL: 0x%06x\n", __raw_readl(spdif_base_addr + SPDIF_REG_STCSCL));
 }
 
 /*
@@ -470,7 +468,7 @@ static int spdif_set_sample_rate(struct snd_soc_codec *codec, int sample_rate)
 		break;
 
 	default:
-		pr_err("%s: unsupported sample rate %d\n",__func__, sample_rate);
+		pr_err("%s: unsupported sample rate %d\n", __func__, sample_rate);
 		return -EINVAL;
 	}
 
@@ -860,9 +858,11 @@ static int mxc_pb_spdif_put(struct snd_kcontrol *kcontrol,
 	mxc_spdif_control.ch_status[2] = uvalue->value.iec958.status[2];
 	mxc_spdif_control.ch_status[3] = uvalue->value.iec958.status[3];
 
-	clk_enable(plat_data->spdif_core_clk);
+	clk_enable(plat_data->spdif_clk);
+
 	spdif_write_channel_status();
-	clk_disable(plat_data->spdif_core_clk);
+
+	clk_disable(plat_data->spdif_clk);
 
 	return 0;
 }
@@ -881,15 +881,17 @@ static int mxc_spdif_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_value *ucontrol)
 {
-	unsigned int cstatus;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
+	unsigned int cstatus;
 
-	clk_enable(plat_data->spdif_core_clk);
+	clk_enable(plat_data->spdif_clk);
 
-	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW))
+	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW)) {
+		clk_disable(plat_data->spdif_clk);
 		return -EAGAIN;
+	}
 
 	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLH);
 	ucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;
@@ -903,7 +905,7 @@ static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 	/* clear intr */
 	__raw_writel(INT_CNEW, spdif_base_addr + SPDIF_REG_SIC);
 
-	clk_disable(plat_data->spdif_core_clk);
+	clk_disable(plat_data->spdif_clk);
 
 	return 0;
 }
@@ -987,16 +989,19 @@ static int mxc_spdif_vbit_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_vbit_get(struct snd_kcontrol *kcontrol,
 			      struct snd_ctl_elem_value *ucontrol)
 {
-	unsigned int int_val;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
+	unsigned int int_val;
+
+	clk_enable(plat_data->spdif_clk);
 
-	clk_enable(plat_data->spdif_core_clk);
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SIS);
-	ucontrol->value.integer.value[0] = !!(int_val & INT_VAL_NOGOOD);
+	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) != 0;
 	__raw_writel(INT_VAL_NOGOOD, spdif_base_addr + SPDIF_REG_SIC);
-	clk_disable(plat_data->spdif_core_clk);
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1026,16 +1031,15 @@ static int mxc_spdif_rxrate_get(struct snd_kcontrol *kcontrol,
 
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 
-	clk_enable(plat_data->spdif_core_clk);
 	if (atomic_read(&spdif_priv->dpll_locked)) {
+		clk_enable(plat_data->spdif_clk);
 		ucontrol->value.integer.value[0] =
 		    spdif_get_rxclk_rate(plat_data->spdif_clk,
 					 SPDIF_DEFAULT_GAINSEL);
+		clk_disable(plat_data->spdif_clk);
 	} else {
 		ucontrol->value.integer.value[0] = 0;
 	}
-	clk_disable(plat_data->spdif_core_clk);
-
 	return 0;
 }
 
@@ -1060,16 +1064,18 @@ static int mxc_spdif_usync_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
-	unsigned int int_val;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
-
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
+	unsigned int int_val;
+
+	clk_enable(plat_data->spdif_clk);
 
-	clk_enable(plat_data->spdif_core_clk);
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SRCD);
 	ucontrol->value.integer.value[0] = (int_val & SRCD_CD_USER) != 0;
-	clk_disable(plat_data->spdif_core_clk);
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1081,16 +1087,18 @@ static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_put(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
-	unsigned int int_val;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
-
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
+	unsigned int int_val;
+
+	clk_enable(plat_data->spdif_clk);
 
-	clk_enable(plat_data->spdif_core_clk);
 	int_val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;
 	__raw_writel(int_val, spdif_base_addr + SPDIF_REG_SRCD);
-	clk_disable(plat_data->spdif_core_clk);
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1103,7 +1111,7 @@ static struct snd_kcontrol_new mxc_spdif_ctrls[] = {
 	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	 .name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
 	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE |
-		SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	 .info = mxc_pb_spdif_info,
 	 .get = mxc_pb_spdif_get,
 	 .put = mxc_pb_spdif_put,
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index c5b2ed9..11e23cc 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -16,10 +16,10 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/platform_device.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/regulator/consumer.h>
-#include <linux/of_device.h>
 #include <sound/core.h>
 #include <sound/tlv.h>
 #include <sound/pcm.h>
@@ -112,6 +112,7 @@ struct sgtl5000_priv {
 	int fmt;	/* i2s data format */
 	struct regulator_bulk_data supplies[SGTL5000_SUPPLY_NUM];
 	struct ldo_regulator *ldo;
+	int mic_bias_impedance;
 };
 
 /*
@@ -126,40 +127,62 @@ struct sgtl5000_priv {
 static int mic_bias_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
+	struct sgtl5000_priv *sgtl5000;
+	int impedance = SGTL5000_BIAS_R_off;
+
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		/* change mic bias resistor to 4Kohm */
-		snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
-				SGTL5000_BIAS_R_MASK,
-				SGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT);
+		sgtl5000 = snd_soc_codec_get_drvdata(w->codec);
+		if (sgtl5000)
+			impedance = sgtl5000->mic_bias_impedance;
 		break;
 
 	case SND_SOC_DAPM_PRE_PMD:
-		snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
-				SGTL5000_BIAS_R_MASK, 0);
 		break;
+	default:
+		return 0;
 	}
+	snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
+		SGTL5000_BIAS_R_MASK, impedance << SGTL5000_BIAS_R_SHIFT);
+	pr_info("%s: %d %04x\n", __func__, impedance, snd_soc_read(w->codec, SGTL5000_CHIP_MIC_CTRL));
 	return 0;
 }
 
 /*
- * As manual described, ADC/DAC only works when VAG powerup,
- * So enabled VAG before ADC/DAC up.
- * In power down case, we need wait 400ms when vag fully ramped down.
+ * using codec assist to small pop, hp_powerup or lineout_powerup
+ * should stay setting until vag_powerup is fully ramped down,
+ * vag fully ramped down require 400ms.
  */
-static int power_vag_event(struct snd_soc_dapm_widget *w,
+static int small_pop_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,
-			SGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);
 		break;
 
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,
-			SGTL5000_VAG_POWERUP, 0);
-		msleep(400);
+	case SND_SOC_DAPM_PRE_PMD:
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int dap_enable_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(w->codec, SGTL5000_DAP_CTRL,
+			0x1, 0x1);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(w->codec, SGTL5000_DAP_CTRL,
+			0x1, 0);
+		snd_soc_dapm_disable_pin(&w->codec->dapm, "DAP_MIXER Mixer Channel");
+		snd_soc_dapm_sync(&w->codec->dapm);
 		break;
 	default:
 		break;
@@ -180,15 +203,50 @@ static const struct snd_kcontrol_new adc_mux =
 SOC_DAPM_ENUM("Capture Mux", adc_enum);
 
 /* input sources for DAC */
-static const char *dac_mux_text[] = {
+static const char *hp_mux_text[] = {
 	"DAC", "LINE_IN"
 };
 
-static const struct soc_enum dac_enum =
-SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 6, 2, dac_mux_text);
+static const struct soc_enum hp_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 6, 2, hp_mux_text);
+
+static const struct snd_kcontrol_new hp_mux =
+SOC_DAPM_ENUM("Headphone Mux", hp_enum);
+
+static const char *dap_in_mux_text[] = {
+	"ADC", "I2S_IN"
+};
+static const struct soc_enum dap_in_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_SSS_CTRL, 6, 2, dap_in_mux_text);
+
+static const struct snd_kcontrol_new dap_in_mux =
+SOC_DAPM_ENUM("DAP input mux", dap_in_enum);
+
+static const struct soc_enum dap_mixer_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_SSS_CTRL, 8, 2, dap_in_mux_text);
+
+static const struct snd_kcontrol_new dap_mixer_mux =
+SOC_DAPM_ENUM("DAP mixer channel mux", dap_mixer_enum);
+
+static const char *dap_out_mux_text[] = {
+	"ADC", "I2S_IN", "reserved", "DAP"
+};
+
+static const struct soc_enum dac_in_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_SSS_CTRL, 4, 4, dap_out_mux_text);
 
-static const struct snd_kcontrol_new dac_mux =
-SOC_DAPM_ENUM("Headphone Mux", dac_enum);
+static const struct snd_kcontrol_new dac_in_mux =
+SOC_DAPM_ENUM("DAC input mux", dac_in_enum);
+
+static const struct soc_enum i2s_out_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_SSS_CTRL, 0, 4, dap_out_mux_text);
+
+static const struct snd_kcontrol_new i2s_out_mux =
+SOC_DAPM_ENUM("i2s output mux", i2s_out_enum);
+
+static const struct snd_kcontrol_new dap_mixer_controls[] = {
+SOC_DAPM_SINGLE("Mixer Channel", SGTL5000_DAP_CTRL, 4, 1, 0),
+};
 
 static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("LINE_IN"),
@@ -197,16 +255,6 @@ static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
 	SND_SOC_DAPM_OUTPUT("HP_OUT"),
 	SND_SOC_DAPM_OUTPUT("LINE_OUT"),
 
-	SND_SOC_DAPM_MICBIAS_E("Mic Bias", SGTL5000_CHIP_MIC_CTRL, 8, 0,
-				mic_bias_event,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-
-	SND_SOC_DAPM_PGA("HP", SGTL5000_CHIP_ANA_POWER, 4, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("LO", SGTL5000_CHIP_ANA_POWER, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX("Capture Mux", SND_SOC_NOPM, 0, 0, &adc_mux),
-	SND_SOC_DAPM_MUX("Headphone Mux", SND_SOC_NOPM, 0, 0, &dac_mux),
-
 	/* aif for i2s input */
 	SND_SOC_DAPM_AIF_IN("AIFIN", "Playback",
 				0, SGTL5000_CHIP_DIG_POWER,
@@ -217,26 +265,61 @@ static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
 				0, SGTL5000_CHIP_DIG_POWER,
 				1, 0),
 
-	SND_SOC_DAPM_SUPPLY("VAG_POWER", SGTL5000_CHIP_ANA_POWER, 7, 0,
-			    power_vag_event,
-			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MICBIAS_E("Mic Bias", SND_SOC_NOPM, 0, 0,
+				mic_bias_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	SND_SOC_DAPM_PGA_E("HP", SGTL5000_CHIP_ANA_POWER, 4, 0, NULL, 0,
+			small_pop_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_PGA_E("LO", SGTL5000_CHIP_ANA_POWER, 0, 0, NULL, 0,
+			small_pop_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	SND_SOC_DAPM_MUX("Capture Mux", SND_SOC_NOPM, 0, 0, &adc_mux),
+	SND_SOC_DAPM_MUX("Headphone Mux", SND_SOC_NOPM, 0, 0, &hp_mux),
+	SND_SOC_DAPM_MUX_E("DAP_IN", SGTL5000_CHIP_DIG_POWER, 4, 0, &dap_in_mux,
+				dap_enable_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MUX("MIX_MUX", SND_SOC_NOPM, 0, 0, &dap_mixer_mux),
+	SND_SOC_DAPM_MUX("DAC_IN", SND_SOC_NOPM, 0, 0, &dac_in_mux),
+	SND_SOC_DAPM_MUX("I2S_OUT", SND_SOC_NOPM, 0, 0, &i2s_out_mux),
+
+	SND_SOC_DAPM_MIXER("DAP_MIXER", SND_SOC_NOPM, 0, 0,
+		&dap_mixer_controls[0],
+		ARRAY_SIZE(dap_mixer_controls)),
 
 	SND_SOC_DAPM_ADC("ADC", "Capture", SGTL5000_CHIP_ANA_POWER, 1, 0),
 	SND_SOC_DAPM_DAC("DAC", "Playback", SGTL5000_CHIP_ANA_POWER, 3, 0),
 };
 
 /* routes for sgtl5000 */
-static const struct snd_soc_dapm_route sgtl5000_dapm_routes[] = {
+static const struct snd_soc_dapm_route audio_map[] = {
 	{"Capture Mux", "LINE_IN", "LINE_IN"},	/* line_in --> adc_mux */
-	{"Mic Bias", NULL, "MIC_IN"},           /* mic_in --> mic bias */
-	{"Capture Mux", "MIC_IN", "Mic Bias"},  /* mic bias --> adc_mux */
+	{"Mic Bias", NULL, "MIC_IN"},		/* mic_in --> mic bias */
+	{"Capture Mux", "MIC_IN", "Mic Bias"},	/* mic bias --> adc_mux */
 
-	{"ADC", NULL, "VAG_POWER"},
 	{"ADC", NULL, "Capture Mux"},		/* adc_mux --> adc */
-	{"AIFOUT", NULL, "ADC"},		/* adc --> i2s_out */
 
-	{"DAC", NULL, "VAG_POWER"},
-	{"DAC", NULL, "AIFIN"},			/* i2s-->dac,skip audio mux */
+	{"DAP_IN", "ADC", "ADC"},
+	{"DAP_IN", "I2S_IN", "AIFIN"},
+
+	{"MIX_MUX", "ADC", "ADC"},
+	{"MIX_MUX", "I2S_IN", "AIFIN"},
+
+	{"DAP_MIXER", NULL, "DAP_IN"},
+	{"DAP_MIXER", "Mixer Channel", "MIX_MUX"},
+
+	{"I2S_OUT", "ADC", "ADC"},		/* ADC --> I2S_OUT */
+	{"I2S_OUT", "I2S_IN", "AIFIN"},		/* ADC --> Audio Switch */
+	{"I2S_OUT", "DAP", "DAP_MIXER"},	/* ADC --> Audio Switch */
+	{"AIFOUT", NULL, "I2S_OUT"},		/* ADC --> Audio Switch */
+
+	{"DAC_IN", "ADC", "ADC"},		/* i2s-->dac,skip audio mux */
+	{"DAC_IN", "I2S_IN", "AIFIN"},		/* i2s-->dac,skip audio mux */
+	{"DAC_IN", "DAP", "DAP_MIXER"},		/* i2s-->dac,skip audio mux */
+	{"DAC", NULL, "DAC_IN"},
+
 	{"Headphone Mux", "DAC", "DAC"},	/* dac --> hp_mux */
 	{"LO", NULL, "DAC"},			/* dac --> line_out */
 
@@ -254,7 +337,7 @@ static int dac_info_volsw(struct snd_kcontrol *kcontrol,
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 0xfc - 0x3c;
+	uinfo->value.integer.max = 0xfc - 0x60;
 	return 0;
 }
 
@@ -297,9 +380,9 @@ static int dac_get_volsw(struct snd_kcontrol *kcontrol,
 	/* get right channel volume */
 	r = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) >> SGTL5000_DAC_VOL_RIGHT_SHIFT;
 
-	/* make sure value fall in (0x3c,0xfc) */
-	l = clamp(l, 0x3c, 0xfc);
-	r = clamp(r, 0x3c, 0xfc);
+	/* make sure value fall in (0x60,0xfc) */
+	l = clamp(l, 0x60, 0xfc);
+	r = clamp(r, 0x60, 0xfc);
 
 	/* invert it and map to userspace value */
 	l = 0xfc - l;
@@ -345,9 +428,9 @@ static int dac_put_volsw(struct snd_kcontrol *kcontrol,
 	l = ucontrol->value.integer.value[0];
 	r = ucontrol->value.integer.value[1];
 
-	/* make sure userspace volume fall in (0, 0xfc-0x3c) */
-	l = clamp(l, 0, 0xfc - 0x3c);
-	r = clamp(r, 0, 0xfc - 0x3c);
+	/* make sure userspace volume fall in (0, 0xfc-0x60) */
+	l = clamp(l, 0, 0xfc - 0x60);
+	r = clamp(r, 0, 0xfc - 0x60);
 
 	/* invert it, get the value can be set to register */
 	l = 0xfc - l;
@@ -362,6 +445,117 @@ static int dac_put_volsw(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+/*
+ * we need to caculator threshold dB by:
+ * register_value = ((10^(dB/20))*0.636)*2^15 ==>
+ * dB = (fls(register_value) - 14.347)*6.02
+ */
+static int avc_thrd_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u16 reg = snd_soc_read(codec, SGTL5000_DAP_AVC_THRESHOLD);
+	int l;
+	/* 1/1000 of dB */
+	int fraction[5] = {585, 322, 170, 87, 44};
+	int i;
+	int tmp;
+
+	if (!reg) {
+		ucontrol->value.integer.value[0] = 96;
+		ucontrol->value.integer.value[1] = 96;
+		return 0;
+	}
+
+	/* caculate fls(register_value) */
+	l = fls(reg) - 1;
+	tmp = l * 1000; /* scale-up 1000 times */
+	for (i = l-1; i >= 0 && i >= l-5; i--) {
+		if (reg & 0x1 << i)
+			tmp += fraction[l-1-i];
+	}
+	tmp = ((tmp - 14347) * 6) / 1000;
+	tmp = clamp(-tmp, 0, 96);
+
+	ucontrol->value.integer.value[0] = tmp;
+	ucontrol->value.integer.value[1] = tmp;
+
+	return 0;
+}
+
+/*
+ * we need to caculator threshold dB by:
+ * register_value = ((10^(dB/20))*0.636)*2^15
+ *		  = 2^(3.322*db/20 + 15) * 0.636
+ *		  = 2^(3.322*db/20 + 15 - 0.653)
+ */
+static int avc_thrd_put(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u16 reg;
+	int db;
+	int tmp;
+	int remain;
+	int i;
+	int fraction[5] = {1414, 1189, 1091, 1044, 1022};
+
+	db = -(ucontrol->value.integer.value[0]);
+
+	tmp = ((3322 * db) / 20 + 15000 - 653);
+	tmp = clamp(tmp, 0, 16000);
+
+	remain = tmp % 1000;
+	tmp = tmp / 1000;
+
+	reg = 0x1 << tmp;
+
+	for (i = 0; i < 5; i++) {
+		int level = 1000 / (0x1 << (i+1));
+		if (remain >= level) {
+			remain -= level;
+			reg = reg * fraction[i] / 1000;
+		}
+	}
+
+	snd_soc_write(codec, SGTL5000_DAP_AVC_THRESHOLD, reg);
+
+	return 0;
+}
+
+static int mixer_vol_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *control =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	u16 reg = snd_soc_read(codec, control->reg);
+	int vol;
+
+	vol = (reg * 100) >> 15;
+
+	ucontrol->value.integer.value[0] = vol;
+	ucontrol->value.integer.value[1] = vol;
+	return 0;
+}
+
+static int mixer_vol_put(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *control =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	u16 reg;
+	int vol;
+
+	vol = ucontrol->value.integer.value[0];
+	reg = (vol << 15) / 100;
+	snd_soc_write(codec, control->reg, reg);
+
+	return 0;
+}
+
+
 static const DECLARE_TLV_DB_SCALE(capture_6db_attenuate, -600, 600, 0);
 
 /* tlv for mic gain, 0db 20db 30db 40db */
@@ -373,6 +567,37 @@ static const unsigned int mic_gain_tlv[] = {
 
 /* tlv for hp volume, -51.5db to 12.0db, step .5db */
 static const DECLARE_TLV_DB_SCALE(headphone_volume, -5150, 50, 0);
+static const unsigned int bass_high_filter_freq[] = {
+	TLV_DB_RANGE_HEAD(7),
+	0, 0, TLV_DB_SCALE_ITEM(80, 0, 0),
+	1, 6, TLV_DB_SCALE_ITEM(100, 25, 0),
+};
+static const DECLARE_TLV_DB_SCALE(avc_max_gain, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(avc_threshold, 0, 1, 0);
+static const DECLARE_TLV_DB_SCALE(mixer_volume, 0, 1, 0);
+
+
+static int sgtl500_mic_bias_impedance_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
+
+	ucontrol->value.integer.value[0] = sgtl5000->mic_bias_impedance;
+	return 0;
+}
+
+static int sgtl500_mic_bias_impedance_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
+	int v = ucontrol->value.integer.value[0];
+
+	sgtl5000->mic_bias_impedance = v;
+	return 1;
+}
+
 
 static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
 	/* SOC_DOUBLE_S8_TLV with invert */
@@ -402,6 +627,42 @@ static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
 
 	SOC_SINGLE_TLV("Mic Volume", SGTL5000_CHIP_MIC_CTRL,
 			0, 4, 0, mic_gain_tlv),
+
+	/* mic bias voltage, 1.25V - 3.00V by .250V */
+	SOC_SINGLE("Mic Bias Volt", SGTL5000_CHIP_MIC_CTRL, 4, 7, 0),
+	SOC_SINGLE_EXT("Mic Bias Impedance", SGTL5000_CHIP_MIC_CTRL, 8, 3, 0,
+			sgtl500_mic_bias_impedance_get, sgtl500_mic_bias_impedance_put),
+
+	/* Bass Enhance enable */
+	SOC_SINGLE("Bass Enable", SGTL5000_DAP_BASS_ENHANCE,
+			0, 1, 0),
+	SOC_SINGLE_TLV("Bass Filter Feq", SGTL5000_DAP_BASS_ENHANCE,
+			6, 7, 0, bass_high_filter_freq),
+	SOC_SINGLE("Bass Volume", SGTL5000_DAP_BASS_ENHANCE_CTRL,
+			8, 0x3f, 1),
+	/* Bass Harmonic Level Control */
+	SOC_SINGLE("Bass Level", SGTL5000_DAP_BASS_ENHANCE_CTRL,
+			0, 0x7f, 1),
+
+	/* DAP Surround */
+	SOC_SINGLE("Surround Width", SGTL5000_DAP_SURROUND,
+			4, 0x7, 0),
+
+	/* DAP MAIN Channel Voluem */
+	SOC_SINGLE_EXT_TLV("Main Channel Volume", SGTL5000_DAP_MAIN_CHAN,
+			0, 200, 0, mixer_vol_get, mixer_vol_put, mixer_volume),
+	SOC_SINGLE_EXT_TLV("Mixer Channel Volume", SGTL5000_DAP_MIX_CHAN,
+			0, 200, 0, mixer_vol_get, mixer_vol_put, mixer_volume),
+
+	/* DAP AVC */
+	SOC_SINGLE("AVC Enable", SGTL5000_DAP_AVC_CTRL,
+			0, 1, 0),
+	SOC_SINGLE("AVC Hard Limit", SGTL5000_DAP_AVC_CTRL,
+			5, 1, 0),
+	SOC_SINGLE_TLV("AVC Max Gain", SGTL5000_DAP_AVC_CTRL,
+			12, 2, 0, avc_max_gain),
+	SOC_SINGLE_EXT_TLV("AVC Threshold (-dB)", SGTL5000_DAP_AVC_THRESHOLD,
+			0, 96, 0, avc_thrd_get, avc_thrd_put, avc_threshold),
 };
 
 /* mute the codec used by alsa core */
@@ -725,8 +986,8 @@ static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	snd_soc_update_bits(codec, SGTL5000_CHIP_I2S_CTRL,
-			    SGTL5000_I2S_DLEN_MASK | SGTL5000_I2S_SCLKFREQ_MASK,
-			    i2s_ctl);
+			SGTL5000_I2S_DLEN_MASK | SGTL5000_I2S_SCLKFREQ_MASK,
+			i2s_ctl);
 
 	return 0;
 }
@@ -739,6 +1000,11 @@ static int ldo_regulator_is_enabled(struct regulator_dev *dev)
 	return ldo->enabled;
 }
 
+/*
+ * enable internal VDDD power supply. Since register
+ * cache not fill yet, we have to use hw_read and write
+ * instead of snd_soc_read and snd_soc_write.
+ */
 static int ldo_regulator_enable(struct regulator_dev *dev)
 {
 	struct ldo_regulator *ldo = rdev_get_drvdata(dev);
@@ -759,14 +1025,17 @@ static int ldo_regulator_enable(struct regulator_dev *dev)
 	snd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,
 				SGTL5000_LINREG_VDDD_MASK, reg);
 
+	reg = snd_soc_read(codec, SGTL5000_CHIP_ANA_POWER);
+	reg |= SGTL5000_LINEREG_D_POWERUP;
 	snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
-				SGTL5000_LINEREG_D_POWERUP,
-				SGTL5000_LINEREG_D_POWERUP);
+				SGTL5000_LINEREG_D_POWERUP, reg);
 
+	reg &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
 	/* when internal ldo enabled, simple digital power can be disabled */
 	snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
-				SGTL5000_LINREG_SIMPLE_POWERUP,
-				0);
+				SGTL5000_LINREG_SIMPLE_POWERUP, reg);
+
+	udelay(10);
 
 	ldo->enabled = 1;
 	return 0;
@@ -783,7 +1052,7 @@ static int ldo_regulator_disable(struct regulator_dev *dev)
 
 	/* clear voltage info */
 	snd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,
-				SGTL5000_LINREG_VDDD_MASK, 0);
+				(0x1 << 4) - 1, 0);
 
 	ldo->enabled = 0;
 
@@ -809,7 +1078,6 @@ static int ldo_regulator_register(struct snd_soc_codec *codec,
 				int voltage)
 {
 	struct ldo_regulator *ldo;
-	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
 	ldo = kzalloc(sizeof(struct ldo_regulator), GFP_KERNEL);
 
@@ -844,7 +1112,6 @@ static int ldo_regulator_register(struct snd_soc_codec *codec,
 
 		return ret;
 	}
-	sgtl5000->ldo = ldo;
 
 	return 0;
 }
@@ -868,7 +1135,6 @@ static int ldo_regulator_register(struct snd_soc_codec *codec,
 				struct regulator_init_data *init_data,
 				int voltage)
 {
-	dev_err(codec->dev, "this setup needs regulator support in the kernel\n");
 	return -EINVAL;
 }
 
@@ -894,9 +1160,24 @@ static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
 	int ret;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
+	if (codec->dapm.bias_level == level)
+		return 0;
+
 	switch (level) {
 	case SND_SOC_BIAS_ON:
+
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);
+		if (ret)
+			msleep(400);
+		break;
+
 	case SND_SOC_BIAS_PREPARE:
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
+
 		break;
 	case SND_SOC_BIAS_STANDBY:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
@@ -908,8 +1189,17 @@ static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
 			udelay(10);
 		}
 
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
 		break;
 	case SND_SOC_BIAS_OFF:
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
+
 		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
 		break;
@@ -924,7 +1214,7 @@ static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
 			SNDRV_PCM_FMTBIT_S24_LE |\
 			SNDRV_PCM_FMTBIT_S32_LE)
 
-static const struct snd_soc_dai_ops sgtl5000_ops = {
+static struct snd_soc_dai_ops sgtl5000_ops = {
 	.hw_params = sgtl5000_pcm_hw_params,
 	.digital_mute = sgtl5000_digital_mute,
 	.set_fmt = sgtl5000_set_dai_fmt,
@@ -935,7 +1225,7 @@ static struct snd_soc_dai_driver sgtl5000_dai = {
 	.name = "sgtl5000",
 	.playback = {
 		.stream_name = "Playback",
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 2,
 		/*
 		 * only support 8~48K + 96K,
@@ -946,7 +1236,7 @@ static struct snd_soc_dai_driver sgtl5000_dai = {
 	},
 	.capture = {
 		.stream_name = "Capture",
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_96000,
 		.formats = SGTL5000_FORMATS,
@@ -955,8 +1245,7 @@ static struct snd_soc_dai_driver sgtl5000_dai = {
 	.symmetric_rates = 1,
 };
 
-static int sgtl5000_volatile_register(struct snd_soc_codec *codec,
-					unsigned int reg)
+static int sgtl5000_volatile_register(struct snd_soc_codec *codec, unsigned int reg)
 {
 	switch (reg) {
 	case SGTL5000_CHIP_ID:
@@ -1087,7 +1376,7 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 	/* according to datasheet, maximum voltage of supplies */
 	if (vdda > 3600 || vddio > 3600 || vddd > 1980) {
 		dev_err(codec->dev,
-			"exceed max voltage vdda %dmV vddio %dmV vddd %dmV\n",
+			"exceed max voltage vdda %dmv vddio %dma vddd %dma\n",
 			vdda, vddio, vddd);
 
 		return -EINVAL;
@@ -1127,7 +1416,7 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 
 	/* set voltage to register */
 	snd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,
-				SGTL5000_LINREG_VDDD_MASK, 0x8);
+				(0x1 << 4) - 1, 0x8);
 
 	/*
 	 * if vddd linear reg has been enabled,
@@ -1158,7 +1447,8 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 		vag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;
 
 	snd_soc_update_bits(codec, SGTL5000_CHIP_REF_CTRL,
-			SGTL5000_ANA_GND_MASK, vag << SGTL5000_ANA_GND_SHIFT);
+			SGTL5000_ANA_GND_MASK,
+			vag << SGTL5000_ANA_GND_SHIFT);
 
 	/* set line out VAG to vddio / 2, in range (0.8v, 1.675v) */
 	vag = vddio / 2;
@@ -1172,8 +1462,8 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 		    SGTL5000_LINE_OUT_GND_STP;
 
 	snd_soc_update_bits(codec, SGTL5000_CHIP_LINE_OUT_CTRL,
-			SGTL5000_LINE_OUT_CURRENT_MASK |
-			SGTL5000_LINE_OUT_GND_MASK,
+			SGTL5000_LINE_OUT_GND_MASK |
+			SGTL5000_LINE_OUT_CURRENT_MASK,
 			vag << SGTL5000_LINE_OUT_GND_SHIFT |
 			SGTL5000_LINE_OUT_CURRENT_360u <<
 				SGTL5000_LINE_OUT_CURRENT_SHIFT);
@@ -1181,34 +1471,6 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 	return 0;
 }
 
-static int sgtl5000_replace_vddd_with_ldo(struct snd_soc_codec *codec)
-{
-	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
-	int ret;
-
-	/* set internal ldo to 1.2v */
-	ret = ldo_regulator_register(codec, &ldo_init_data, LDO_VOLTAGE);
-	if (ret) {
-		dev_err(codec->dev,
-			"Failed to register vddd internal supplies: %d\n", ret);
-		return ret;
-	}
-
-	sgtl5000->supplies[VDDD].supply = LDO_CONSUMER_NAME;
-
-	ret = regulator_bulk_get(codec->dev, ARRAY_SIZE(sgtl5000->supplies),
-			sgtl5000->supplies);
-
-	if (ret) {
-		ldo_regulator_remove(codec);
-		dev_err(codec->dev, "Failed to request supplies: %d\n", ret);
-		return ret;
-	}
-
-	dev_info(codec->dev, "Using internal LDO instead of VDDD\n");
-	return 0;
-}
-
 static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 {
 	u16 reg;
@@ -1226,9 +1488,29 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	if (!ret)
 		external_vddd = 1;
 	else {
-		ret = sgtl5000_replace_vddd_with_ldo(codec);
-		if (ret)
+		/* set internal ldo to 1.2v */
+		int voltage = LDO_VOLTAGE;
+
+		ret = ldo_regulator_register(codec, &ldo_init_data, voltage);
+		if (ret) {
+			dev_err(codec->dev,
+			"Failed to register vddd internal supplies: %d\n",
+				ret);
+			return ret;
+		}
+
+		sgtl5000->supplies[VDDD].supply = LDO_CONSUMER_NAME;
+		ret = regulator_bulk_get(codec->dev,
+				ARRAY_SIZE(sgtl5000->supplies),
+				sgtl5000->supplies);
+
+		if (ret) {
+			ldo_regulator_remove(codec);
+			dev_err(codec->dev,
+				"Failed to request supplies: %d\n", ret);
+
 			return ret;
+		}
 	}
 
 	ret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),
@@ -1250,13 +1532,14 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	}
 
 	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
-	dev_info(codec->dev, "sgtl5000 revision 0x%x\n", rev);
+	dev_info(codec->dev, "sgtl5000 revision %d\n", rev);
 
 	/*
 	 * workaround for revision 0x11 and later,
 	 * roll back to use internal LDO
 	 */
 	if (external_vddd && rev >= 0x11) {
+		int voltage = LDO_VOLTAGE;
 		/* disable all regulator first */
 		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
@@ -1264,10 +1547,23 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 		regulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
 
-		ret = sgtl5000_replace_vddd_with_ldo(codec);
+		ret = ldo_regulator_register(codec, &ldo_init_data, voltage);
 		if (ret)
 			return ret;
 
+		sgtl5000->supplies[VDDD].supply = LDO_CONSUMER_NAME;
+
+		ret = regulator_bulk_get(codec->dev,
+				ARRAY_SIZE(sgtl5000->supplies),
+				sgtl5000->supplies);
+		if (ret) {
+			ldo_regulator_remove(codec);
+			dev_err(codec->dev,
+				"Failed to request supplies: %d\n", ret);
+
+			return ret;
+		}
+
 		ret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),
 						sgtl5000->supplies);
 		if (ret)
@@ -1291,7 +1587,6 @@ err_regulator_free:
 
 }
 
-#if defined(CONFIG_ARCH_MX6)
 static int sgtl5000_fill_reg_cache(struct snd_soc_codec *codec)
 {
 	int reg;
@@ -1299,19 +1594,14 @@ static int sgtl5000_fill_reg_cache(struct snd_soc_codec *codec)
 	u16 *cache = codec->reg_cache;
 
 	for (reg = SGTL5000_DAP_REG_OFFSET;
-		reg < SGTL5000_MAX_REG_OFFSET; reg += step)
-	{
+		reg <= SGTL5000_MAX_REG_OFFSET; reg += step)
 		cache[reg] = snd_soc_read(codec, reg);
-	}
 
 	for (reg = 0; reg <= SGTL5000_CHIP_SHORT_CTRL; reg += step)
-	{
 		cache[reg] = snd_soc_read(codec, reg);
-	}
 
 	return 0;
 }
-#endif
 
 static int sgtl5000_probe(struct snd_soc_codec *codec)
 {
@@ -1330,7 +1620,6 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 	sgtl5000_fill_reg_cache(codec);
 	codec->cache_bypass = 0;
 #endif
-
 	ret = sgtl5000_enable_regulators(codec);
 	if (ret)
 		return ret;
@@ -1369,20 +1658,34 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 			SGTL5000_HP_ZCD_EN |
 			SGTL5000_ADC_ZCD_EN);
 
-	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
+	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 2 | (((2250 - 1250) / 250) << 4));
+
+	snd_soc_write(codec, SGTL5000_CHIP_DAC_VOL, 0x6060);
+	snd_soc_write(codec, SGTL5000_CHIP_ANA_ADC_CTRL,
+		(0xf << SGTL5000_ADC_VOL_LEFT_SHIFT) |\
+		(0xf << SGTL5000_ADC_VOL_RIGHT_SHIFT));
 
 	/*
 	 * disable DAP
 	 * TODO:
 	 * Enable DAP in kcontrol and dapm.
 	 */
-	snd_soc_write(codec, SGTL5000_DAP_CTRL, 0);
+	snd_soc_write(codec, SGTL5000_DAP_CTRL, 2);
 
 	/* leading to standby state */
 	ret = sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 	if (ret)
 		goto err;
 
+	snd_soc_add_codec_controls(codec, sgtl5000_snd_controls,
+			     ARRAY_SIZE(sgtl5000_snd_controls));
+
+	snd_soc_dapm_new_controls(&codec->dapm, sgtl5000_dapm_widgets,
+				  ARRAY_SIZE(sgtl5000_dapm_widgets));
+
+	snd_soc_dapm_add_routes(&codec->dapm, audio_map,
+				ARRAY_SIZE(audio_map));
+
 	snd_soc_dapm_new_widgets(&codec->dapm);
 
 	return 0;
@@ -1418,17 +1721,10 @@ static struct snd_soc_codec_driver sgtl5000_driver = {
 	.suspend = sgtl5000_suspend,
 	.resume = sgtl5000_resume,
 	.set_bias_level = sgtl5000_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(sgtl5000_regs),
+	.reg_cache_size = SGTL5000_MAX_REG_OFFSET,
 	.reg_word_size = sizeof(u16),
 	.reg_cache_step = 2,
-	.reg_cache_default = sgtl5000_regs,
 	.volatile_register = sgtl5000_volatile_register,
-	.controls = sgtl5000_snd_controls,
-	.num_controls = ARRAY_SIZE(sgtl5000_snd_controls),
-	.dapm_widgets = sgtl5000_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(sgtl5000_dapm_widgets),
-	.dapm_routes = sgtl5000_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(sgtl5000_dapm_routes),
 };
 
 static __devinit int sgtl5000_i2c_probe(struct i2c_client *client,
@@ -1437,22 +1733,31 @@ static __devinit int sgtl5000_i2c_probe(struct i2c_client *client,
 	struct sgtl5000_priv *sgtl5000;
 	int ret;
 
-	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
-								GFP_KERNEL);
+	sgtl5000 = kzalloc(sizeof(struct sgtl5000_priv), GFP_KERNEL);
 	if (!sgtl5000)
 		return -ENOMEM;
 
+	sgtl5000->mic_bias_impedance = SGTL5000_BIAS_R_4k;
 	i2c_set_clientdata(client, sgtl5000);
 
 	ret = snd_soc_register_codec(&client->dev,
 			&sgtl5000_driver, &sgtl5000_dai, 1);
-	return ret;
+	if (ret) {
+		dev_err(&client->dev, "Failed to register codec: %d\n", ret);
+		kfree(sgtl5000);
+		return ret;
+	}
+
+	return 0;
 }
 
 static __devexit int sgtl5000_i2c_remove(struct i2c_client *client)
 {
+	struct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);
+
 	snd_soc_unregister_codec(&client->dev);
 
+	kfree(sgtl5000);
 	return 0;
 }
 
@@ -1463,17 +1768,10 @@ static const struct i2c_device_id sgtl5000_id[] = {
 
 MODULE_DEVICE_TABLE(i2c, sgtl5000_id);
 
-static const struct of_device_id sgtl5000_dt_ids[] = {
-	{ .compatible = "fsl,sgtl5000", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, sgtl5000_dt_ids);
-
 static struct i2c_driver sgtl5000_i2c_driver = {
 	.driver = {
 		   .name = "sgtl5000",
 		   .owner = THIS_MODULE,
-		   .of_match_table = sgtl5000_dt_ids,
 		   },
 	.probe = sgtl5000_i2c_probe,
 	.remove = __devexit_p(sgtl5000_i2c_remove),
@@ -1493,5 +1791,5 @@ static void __exit sgtl5000_exit(void)
 module_exit(sgtl5000_exit);
 
 MODULE_DESCRIPTION("Freescale SGTL5000 ALSA SoC Codec Driver");
-MODULE_AUTHOR("Zeng Zhaoming <zengzm.kernel@gmail.com>");
+MODULE_AUTHOR("Zeng Zhaoming <zhaoming.zeng@freescale.com>");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/si4763.c b/sound/soc/codecs/si4763.c
new file mode 100644
index 0000000..b2c5dc9
--- /dev/null
+++ b/sound/soc/codecs/si4763.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#define SI4763_RATES SNDRV_PCM_RATE_48000
+
+#define SI4763_FORMATS SNDRV_PCM_FMTBIT_S16_LE
+
+static struct snd_soc_dai_driver si4763_codec_dai = {
+	.name = "si4763",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = SI4763_RATES,
+		    .formats = SI4763_FORMATS,
+		    },
+};
+
+static int mxc_si4763_codec_soc_probe(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+static struct snd_soc_codec_driver soc_codec_dev_si4763 = {
+	.probe = mxc_si4763_codec_soc_probe,
+};
+
+static int si4763_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	dev_info(&pdev->dev, "SI4763 Audio codec\n");
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_si4763,
+					&si4763_codec_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register codec\n");
+		return ret;
+	}
+
+	return 0;
+
+}
+
+/* power down chip */
+static int si4763_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int si4763_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int si4763_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+struct platform_driver si4763_driver = {
+	.driver = {
+		.name = "si4763",
+		.owner = THIS_MODULE,
+		},
+	.probe = si4763_probe,
+	.remove = si4763_remove,
+	.suspend = si4763_suspend,
+	.resume = si4763_resume,
+};
+
+static int __init si4763_codec_init(void)
+{
+	return platform_driver_register(&si4763_driver);
+}
+
+static void __exit si4763_codec_exit(void)
+{
+	return platform_driver_unregister(&si4763_driver);
+}
+
+module_init(si4763_codec_init);
+module_exit(si4763_codec_exit);
+
+MODULE_DESCRIPTION("ASoC si4763 codec driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index 96f6f9f..a1cb3bf 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -5,6 +5,7 @@
  *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,8 +21,7 @@
 #include <linux/gpio.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
-#include <linux/pm_runtime.h>
-#include <linux/regmap.h>
+#include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
@@ -51,7 +51,6 @@ static const char *wm8962_supply_names[WM8962_NUM_SUPPLIES] = {
 
 /* codec private data */
 struct wm8962_priv {
-	struct regmap *regmap;
 	struct snd_soc_codec *codec;
 
 	int sysclk;
@@ -97,7 +96,7 @@ static int wm8962_regulator_event_##n(struct notifier_block *nb, \
 	struct wm8962_priv *wm8962 = container_of(nb, struct wm8962_priv, \
 						  disable_nb[n]); \
 	if (event & REGULATOR_EVENT_DISABLE) { \
-		regcache_mark_dirty(wm8962->regmap);	\
+		wm8962->codec->cache_sync = 1; \
 	} \
 	return 0; \
 }
@@ -111,1345 +110,1865 @@ WM8962_REGULATOR_EVENT(5)
 WM8962_REGULATOR_EVENT(6)
 WM8962_REGULATOR_EVENT(7)
 
-static struct reg_default wm8962_reg[] = {
-	{ 0, 0x009F },   /* R0     - Left Input volume */
-	{ 1, 0x049F },   /* R1     - Right Input volume */
-	{ 2, 0x0000 },   /* R2     - HPOUTL volume */
-	{ 3, 0x0000 },   /* R3     - HPOUTR volume */
-
-	{ 5, 0x0018 },   /* R5     - ADC & DAC Control 1 */
-	{ 6, 0x2008 },   /* R6     - ADC & DAC Control 2 */
-	{ 7, 0x000A },   /* R7     - Audio Interface 0 */
-
-	{ 9, 0x0300 },   /* R9     - Audio Interface 1 */
-	{ 10, 0x00C0 },  /* R10    - Left DAC volume */
-	{ 11, 0x00C0 },  /* R11    - Right DAC volume */
-
-	{ 14, 0x0040 },   /* R14    - Audio Interface 2 */
-	{ 15, 0x6243 },   /* R15    - Software Reset */
-
-	{ 17, 0x007B },   /* R17    - ALC1 */
-
-	{ 19, 0x1C32 },   /* R19    - ALC3 */
-	{ 20, 0x3200 },   /* R20    - Noise Gate */
-	{ 21, 0x00C0 },   /* R21    - Left ADC volume */
-	{ 22, 0x00C0 },   /* R22    - Right ADC volume */
-	{ 23, 0x0160 },   /* R23    - Additional control(1) */
-	{ 24, 0x0000 },   /* R24    - Additional control(2) */
-	{ 25, 0x0000 },   /* R25    - Pwr Mgmt (1) */
-	{ 26, 0x0000 },   /* R26    - Pwr Mgmt (2) */
-	{ 27, 0x0010 },   /* R27    - Additional Control (3) */
-	{ 28, 0x0000 },   /* R28    - Anti-pop */
+static const u16 wm8962_reg[WM8962_MAX_REGISTER + 1] = {
+	[0] = 0x009F,     /* R0     - Left Input volume */
+	[1] = 0x049F,     /* R1     - Right Input volume */
+	[2] = 0x0000,     /* R2     - HPOUTL volume */
+	[3] = 0x0000,     /* R3     - HPOUTR volume */
+	[4] = 0x0020,     /* R4     - Clocking1 */
+	[5] = 0x0018,     /* R5     - ADC & DAC Control 1 */
+	[6] = 0x2008,     /* R6     - ADC & DAC Control 2 */
+	[7] = 0x000A,     /* R7     - Audio Interface 0 */
+	[8] = 0x01E4,     /* R8     - Clocking2 */
+	[9] = 0x0300,     /* R9     - Audio Interface 1 */
+	[10] = 0x00C0,    /* R10    - Left DAC volume */
+	[11] = 0x00C0,    /* R11    - Right DAC volume */
+
+	[14] = 0x0040,     /* R14    - Audio Interface 2 */
+	[15] = 0x6243,     /* R15    - Software Reset */
+
+	[17] = 0x007B,     /* R17    - ALC1 */
+	[18] = 0x0000,     /* R18    - ALC2 */
+	[19] = 0x1C32,     /* R19    - ALC3 */
+	[20] = 0x3200,     /* R20    - Noise Gate */
+	[21] = 0x00C0,     /* R21    - Left ADC volume */
+	[22] = 0x00C0,     /* R22    - Right ADC volume */
+	[23] = 0x0160,     /* R23    - Additional control(1) */
+	[24] = 0x0000,     /* R24    - Additional control(2) */
+	[25] = 0x0000,     /* R25    - Pwr Mgmt (1) */
+	[26] = 0x0000,     /* R26    - Pwr Mgmt (2) */
+	[27] = 0x0010,     /* R27    - Additional Control (3) */
+	[28] = 0x0000,     /* R28    - Anti-pop */
+
+	[30] = 0x005E,     /* R30    - Clocking 3 */
+	[31] = 0x0000,     /* R31    - Input mixer control (1) */
+	[32] = 0x0145,     /* R32    - Left input mixer volume */
+	[33] = 0x0145,     /* R33    - Right input mixer volume */
+	[34] = 0x0009,     /* R34    - Input mixer control (2) */
+	[35] = 0x0003,     /* R35    - Input bias control */
+	[37] = 0x0008,     /* R37    - Left input PGA control */
+	[38] = 0x0008,     /* R38    - Right input PGA control */
+
+	[40] = 0x0000,     /* R40    - SPKOUTL volume */
+	[41] = 0x0000,     /* R41    - SPKOUTR volume */
+
+	[47] = 0x0000,     /* R47    - Thermal Shutdown Status */
+	[48] = 0x8027,     /* R48    - Additional Control (4) */
+	[49] = 0x0010,     /* R49    - Class D Control 1 */
+
+	[51] = 0x0003,     /* R51    - Class D Control 2 */
+
+	[56] = 0x0506,     /* R56    - Clocking 4 */
+	[57] = 0x0000,     /* R57    - DAC DSP Mixing (1) */
+	[58] = 0x0000,     /* R58    - DAC DSP Mixing (2) */
+
+	[60] = 0x0300,     /* R60    - DC Servo 0 */
+	[61] = 0x0300,     /* R61    - DC Servo 1 */
+
+	[64] = 0x0810,     /* R64    - DC Servo 4 */
+
+	[66] = 0x0000,     /* R66    - DC Servo 6 */
+
+	[68] = 0x001B,     /* R68    - Analogue PGA Bias */
+	[69] = 0x0000,     /* R69    - Analogue HP 0 */
+
+	[71] = 0x01FB,     /* R71    - Analogue HP 2 */
+	[72] = 0x0000,     /* R72    - Charge Pump 1 */
+
+	[82] = 0x0004,     /* R82    - Charge Pump B */
+
+	[87] = 0x0000,     /* R87    - Write Sequencer Control 1 */
+
+	[90] = 0x0000,     /* R90    - Write Sequencer Control 2 */
+
+	[93] = 0x0000,     /* R93    - Write Sequencer Control 3 */
+	[94] = 0x0000,     /* R94    - Control Interface */
+
+	[99] = 0x0000,     /* R99    - Mixer Enables */
+	[100] = 0x0000,     /* R100   - Headphone Mixer (1) */
+	[101] = 0x0000,     /* R101   - Headphone Mixer (2) */
+	[102] = 0x013F,     /* R102   - Headphone Mixer (3) */
+	[103] = 0x013F,     /* R103   - Headphone Mixer (4) */
+
+	[105] = 0x0000,     /* R105   - Speaker Mixer (1) */
+	[106] = 0x0000,     /* R106   - Speaker Mixer (2) */
+	[107] = 0x013F,     /* R107   - Speaker Mixer (3) */
+	[108] = 0x013F,     /* R108   - Speaker Mixer (4) */
+	[109] = 0x0003,     /* R109   - Speaker Mixer (5) */
+	[110] = 0x0002,     /* R110   - Beep Generator (1) */
+
+	[115] = 0x0006,     /* R115   - Oscillator Trim (3) */
+	[116] = 0x0026,     /* R116   - Oscillator Trim (4) */
+
+	[119] = 0x0000,     /* R119   - Oscillator Trim (7) */
+
+	[124] = 0x0011,     /* R124   - Analogue Clocking1 */
+	[125] = 0x004B,     /* R125   - Analogue Clocking2 */
+	[126] = 0x000D,     /* R126   - Analogue Clocking3 */
+	[127] = 0x0000,     /* R127   - PLL Software Reset */
+
+	[129] = 0x0000,     /* R129   - PLL2 */
+
+	[131] = 0x0000,     /* R131   - PLL 4 */
+
+	[136] = 0x0067,     /* R136   - PLL 9 */
+	[137] = 0x001C,     /* R137   - PLL 10 */
+	[138] = 0x0071,     /* R138   - PLL 11 */
+	[139] = 0x00C7,     /* R139   - PLL 12 */
+	[140] = 0x0067,     /* R140   - PLL 13 */
+	[141] = 0x0048,     /* R141   - PLL 14 */
+	[142] = 0x0022,     /* R142   - PLL 15 */
+	[143] = 0x0097,     /* R143   - PLL 16 */
+
+	[155] = 0x000C,     /* R155   - FLL Control (1) */
+	[156] = 0x0039,     /* R156   - FLL Control (2) */
+	[157] = 0x0180,     /* R157   - FLL Control (3) */
+
+	[159] = 0x0032,     /* R159   - FLL Control (5) */
+	[160] = 0x0018,     /* R160   - FLL Control (6) */
+	[161] = 0x007D,     /* R161   - FLL Control (7) */
+	[162] = 0x0008,     /* R162   - FLL Control (8) */
+
+	[252] = 0x0005,     /* R252   - General test 1 */
+
+	[256] = 0x0000,     /* R256   - DF1 */
+	[257] = 0x0000,     /* R257   - DF2 */
+	[258] = 0x0000,     /* R258   - DF3 */
+	[259] = 0x0000,     /* R259   - DF4 */
+	[260] = 0x0000,     /* R260   - DF5 */
+	[261] = 0x0000,     /* R261   - DF6 */
+	[262] = 0x0000,     /* R262   - DF7 */
+
+	[264] = 0x0000,     /* R264   - LHPF1 */
+	[265] = 0x0000,     /* R265   - LHPF2 */
+
+	[268] = 0x0000,     /* R268   - THREED1 */
+	[269] = 0x0000,     /* R269   - THREED2 */
+	[270] = 0x0000,     /* R270   - THREED3 */
+	[271] = 0x0000,     /* R271   - THREED4 */
+
+	[276] = 0x000C,     /* R276   - DRC 1 */
+	[277] = 0x0925,     /* R277   - DRC 2 */
+	[278] = 0x0000,     /* R278   - DRC 3 */
+	[279] = 0x0000,     /* R279   - DRC 4 */
+	[280] = 0x0000,     /* R280   - DRC 5 */
+
+	[285] = 0x0000,     /* R285   - Tloopback */
+
+	[335] = 0x0004,     /* R335   - EQ1 */
+	[336] = 0x6318,     /* R336   - EQ2 */
+	[337] = 0x6300,     /* R337   - EQ3 */
+	[338] = 0x0FCA,     /* R338   - EQ4 */
+	[339] = 0x0400,     /* R339   - EQ5 */
+	[340] = 0x00D8,     /* R340   - EQ6 */
+	[341] = 0x1EB5,     /* R341   - EQ7 */
+	[342] = 0xF145,     /* R342   - EQ8 */
+	[343] = 0x0B75,     /* R343   - EQ9 */
+	[344] = 0x01C5,     /* R344   - EQ10 */
+	[345] = 0x1C58,     /* R345   - EQ11 */
+	[346] = 0xF373,     /* R346   - EQ12 */
+	[347] = 0x0A54,     /* R347   - EQ13 */
+	[348] = 0x0558,     /* R348   - EQ14 */
+	[349] = 0x168E,     /* R349   - EQ15 */
+	[350] = 0xF829,     /* R350   - EQ16 */
+	[351] = 0x07AD,     /* R351   - EQ17 */
+	[352] = 0x1103,     /* R352   - EQ18 */
+	[353] = 0x0564,     /* R353   - EQ19 */
+	[354] = 0x0559,     /* R354   - EQ20 */
+	[355] = 0x4000,     /* R355   - EQ21 */
+	[356] = 0x6318,     /* R356   - EQ22 */
+	[357] = 0x6300,     /* R357   - EQ23 */
+	[358] = 0x0FCA,     /* R358   - EQ24 */
+	[359] = 0x0400,     /* R359   - EQ25 */
+	[360] = 0x00D8,     /* R360   - EQ26 */
+	[361] = 0x1EB5,     /* R361   - EQ27 */
+	[362] = 0xF145,     /* R362   - EQ28 */
+	[363] = 0x0B75,     /* R363   - EQ29 */
+	[364] = 0x01C5,     /* R364   - EQ30 */
+	[365] = 0x1C58,     /* R365   - EQ31 */
+	[366] = 0xF373,     /* R366   - EQ32 */
+	[367] = 0x0A54,     /* R367   - EQ33 */
+	[368] = 0x0558,     /* R368   - EQ34 */
+	[369] = 0x168E,     /* R369   - EQ35 */
+	[370] = 0xF829,     /* R370   - EQ36 */
+	[371] = 0x07AD,     /* R371   - EQ37 */
+	[372] = 0x1103,     /* R372   - EQ38 */
+	[373] = 0x0564,     /* R373   - EQ39 */
+	[374] = 0x0559,     /* R374   - EQ40 */
+	[375] = 0x4000,     /* R375   - EQ41 */
+
+	[513] = 0x0000,     /* R513   - GPIO 2 */
+	[514] = 0x0000,     /* R514   - GPIO 3 */
+
+	[516] = 0x8100,     /* R516   - GPIO 5 */
+	[517] = 0x8100,     /* R517   - GPIO 6 */
+
+	[560] = 0x0000,     /* R560   - Interrupt Status 1 */
+	[561] = 0x0000,     /* R561   - Interrupt Status 2 */
+
+	[568] = 0x0030,     /* R568   - Interrupt Status 1 Mask */
+	[569] = 0xFFED,     /* R569   - Interrupt Status 2 Mask */
+
+	[576] = 0x0000,     /* R576   - Interrupt Control */
+
+	[584] = 0x002D,     /* R584   - IRQ Debounce */
+
+	[586] = 0x0000,     /* R586   -  MICINT Source Pol */
+
+	[768] = 0x1C00,     /* R768   - DSP2 Power Management */
+
+	[1037] = 0x0000,     /* R1037  - DSP2_ExecControl */
+
+	[8192] = 0x0000,     /* R8192  - DSP2 Instruction RAM 0 */
+
+	[9216] = 0x0030,     /* R9216  - DSP2 Address RAM 2 */
+	[9217] = 0x0000,     /* R9217  - DSP2 Address RAM 1 */
+	[9218] = 0x0000,     /* R9218  - DSP2 Address RAM 0 */
+
+	[12288] = 0x0000,     /* R12288 - DSP2 Data1 RAM 1 */
+	[12289] = 0x0000,     /* R12289 - DSP2 Data1 RAM 0 */
+
+	[13312] = 0x0000,     /* R13312 - DSP2 Data2 RAM 1 */
+	[13313] = 0x0000,     /* R13313 - DSP2 Data2 RAM 0 */
+
+	[14336] = 0x0000,     /* R14336 - DSP2 Data3 RAM 1 */
+	[14337] = 0x0000,     /* R14337 - DSP2 Data3 RAM 0 */
+
+	[15360] = 0x000A,     /* R15360 - DSP2 Coeff RAM 0 */
+
+	[16384] = 0x0000,     /* R16384 - RETUNEADC_SHARED_COEFF_1 */
+	[16385] = 0x0000,     /* R16385 - RETUNEADC_SHARED_COEFF_0 */
+	[16386] = 0x0000,     /* R16386 - RETUNEDAC_SHARED_COEFF_1 */
+	[16387] = 0x0000,     /* R16387 - RETUNEDAC_SHARED_COEFF_0 */
+	[16388] = 0x0000,     /* R16388 - SOUNDSTAGE_ENABLES_1 */
+	[16389] = 0x0000,     /* R16389 - SOUNDSTAGE_ENABLES_0 */
+
+	[16896] = 0x0002,     /* R16896 - HDBASS_AI_1 */
+	[16897] = 0xBD12,     /* R16897 - HDBASS_AI_0 */
+	[16898] = 0x007C,     /* R16898 - HDBASS_AR_1 */
+	[16899] = 0x586C,     /* R16899 - HDBASS_AR_0 */
+	[16900] = 0x0053,     /* R16900 - HDBASS_B_1 */
+	[16901] = 0x8121,     /* R16901 - HDBASS_B_0 */
+	[16902] = 0x003F,     /* R16902 - HDBASS_K_1 */
+	[16903] = 0x8BD8,     /* R16903 - HDBASS_K_0 */
+	[16904] = 0x0032,     /* R16904 - HDBASS_N1_1 */
+	[16905] = 0xF52D,     /* R16905 - HDBASS_N1_0 */
+	[16906] = 0x0065,     /* R16906 - HDBASS_N2_1 */
+	[16907] = 0xAC8C,     /* R16907 - HDBASS_N2_0 */
+	[16908] = 0x006B,     /* R16908 - HDBASS_N3_1 */
+	[16909] = 0xE087,     /* R16909 - HDBASS_N3_0 */
+	[16910] = 0x0072,     /* R16910 - HDBASS_N4_1 */
+	[16911] = 0x1483,     /* R16911 - HDBASS_N4_0 */
+	[16912] = 0x0072,     /* R16912 - HDBASS_N5_1 */
+	[16913] = 0x1483,     /* R16913 - HDBASS_N5_0 */
+	[16914] = 0x0043,     /* R16914 - HDBASS_X1_1 */
+	[16915] = 0x3525,     /* R16915 - HDBASS_X1_0 */
+	[16916] = 0x0006,     /* R16916 - HDBASS_X2_1 */
+	[16917] = 0x6A4A,     /* R16917 - HDBASS_X2_0 */
+	[16918] = 0x0043,     /* R16918 - HDBASS_X3_1 */
+	[16919] = 0x6079,     /* R16919 - HDBASS_X3_0 */
+	[16920] = 0x0008,     /* R16920 - HDBASS_ATK_1 */
+	[16921] = 0x0000,     /* R16921 - HDBASS_ATK_0 */
+	[16922] = 0x0001,     /* R16922 - HDBASS_DCY_1 */
+	[16923] = 0x0000,     /* R16923 - HDBASS_DCY_0 */
+	[16924] = 0x0059,     /* R16924 - HDBASS_PG_1 */
+	[16925] = 0x999A,     /* R16925 - HDBASS_PG_0 */
+
+	[17048] = 0x0083,     /* R17408 - HPF_C_1 */
+	[17049] = 0x98AD,     /* R17409 - HPF_C_0 */
+
+	[17920] = 0x007F,     /* R17920 - ADCL_RETUNE_C1_1 */
+	[17921] = 0xFFFF,     /* R17921 - ADCL_RETUNE_C1_0 */
+	[17922] = 0x0000,     /* R17922 - ADCL_RETUNE_C2_1 */
+	[17923] = 0x0000,     /* R17923 - ADCL_RETUNE_C2_0 */
+	[17924] = 0x0000,     /* R17924 - ADCL_RETUNE_C3_1 */
+	[17925] = 0x0000,     /* R17925 - ADCL_RETUNE_C3_0 */
+	[17926] = 0x0000,     /* R17926 - ADCL_RETUNE_C4_1 */
+	[17927] = 0x0000,     /* R17927 - ADCL_RETUNE_C4_0 */
+	[17928] = 0x0000,     /* R17928 - ADCL_RETUNE_C5_1 */
+	[17929] = 0x0000,     /* R17929 - ADCL_RETUNE_C5_0 */
+	[17930] = 0x0000,     /* R17930 - ADCL_RETUNE_C6_1 */
+	[17931] = 0x0000,     /* R17931 - ADCL_RETUNE_C6_0 */
+	[17932] = 0x0000,     /* R17932 - ADCL_RETUNE_C7_1 */
+	[17933] = 0x0000,     /* R17933 - ADCL_RETUNE_C7_0 */
+	[17934] = 0x0000,     /* R17934 - ADCL_RETUNE_C8_1 */
+	[17935] = 0x0000,     /* R17935 - ADCL_RETUNE_C8_0 */
+	[17936] = 0x0000,     /* R17936 - ADCL_RETUNE_C9_1 */
+	[17937] = 0x0000,     /* R17937 - ADCL_RETUNE_C9_0 */
+	[17938] = 0x0000,     /* R17938 - ADCL_RETUNE_C10_1 */
+	[17939] = 0x0000,     /* R17939 - ADCL_RETUNE_C10_0 */
+	[17940] = 0x0000,     /* R17940 - ADCL_RETUNE_C11_1 */
+	[17941] = 0x0000,     /* R17941 - ADCL_RETUNE_C11_0 */
+	[17942] = 0x0000,     /* R17942 - ADCL_RETUNE_C12_1 */
+	[17943] = 0x0000,     /* R17943 - ADCL_RETUNE_C12_0 */
+	[17944] = 0x0000,     /* R17944 - ADCL_RETUNE_C13_1 */
+	[17945] = 0x0000,     /* R17945 - ADCL_RETUNE_C13_0 */
+	[17946] = 0x0000,     /* R17946 - ADCL_RETUNE_C14_1 */
+	[17947] = 0x0000,     /* R17947 - ADCL_RETUNE_C14_0 */
+	[17948] = 0x0000,     /* R17948 - ADCL_RETUNE_C15_1 */
+	[17949] = 0x0000,     /* R17949 - ADCL_RETUNE_C15_0 */
+	[17950] = 0x0000,     /* R17950 - ADCL_RETUNE_C16_1 */
+	[17951] = 0x0000,     /* R17951 - ADCL_RETUNE_C16_0 */
+	[17952] = 0x0000,     /* R17952 - ADCL_RETUNE_C17_1 */
+	[17953] = 0x0000,     /* R17953 - ADCL_RETUNE_C17_0 */
+	[17954] = 0x0000,     /* R17954 - ADCL_RETUNE_C18_1 */
+	[17955] = 0x0000,     /* R17955 - ADCL_RETUNE_C18_0 */
+	[17956] = 0x0000,     /* R17956 - ADCL_RETUNE_C19_1 */
+	[17957] = 0x0000,     /* R17957 - ADCL_RETUNE_C19_0 */
+	[17958] = 0x0000,     /* R17958 - ADCL_RETUNE_C20_1 */
+	[17959] = 0x0000,     /* R17959 - ADCL_RETUNE_C20_0 */
+	[17960] = 0x0000,     /* R17960 - ADCL_RETUNE_C21_1 */
+	[17961] = 0x0000,     /* R17961 - ADCL_RETUNE_C21_0 */
+	[17962] = 0x0000,     /* R17962 - ADCL_RETUNE_C22_1 */
+	[17963] = 0x0000,     /* R17963 - ADCL_RETUNE_C22_0 */
+	[17964] = 0x0000,     /* R17964 - ADCL_RETUNE_C23_1 */
+	[17965] = 0x0000,     /* R17965 - ADCL_RETUNE_C23_0 */
+	[17966] = 0x0000,     /* R17966 - ADCL_RETUNE_C24_1 */
+	[17967] = 0x0000,     /* R17967 - ADCL_RETUNE_C24_0 */
+	[17968] = 0x0000,     /* R17968 - ADCL_RETUNE_C25_1 */
+	[17969] = 0x0000,     /* R17969 - ADCL_RETUNE_C25_0 */
+	[17970] = 0x0000,     /* R17970 - ADCL_RETUNE_C26_1 */
+	[17971] = 0x0000,     /* R17971 - ADCL_RETUNE_C26_0 */
+	[17972] = 0x0000,     /* R17972 - ADCL_RETUNE_C27_1 */
+	[17973] = 0x0000,     /* R17973 - ADCL_RETUNE_C27_0 */
+	[17974] = 0x0000,     /* R17974 - ADCL_RETUNE_C28_1 */
+	[17975] = 0x0000,     /* R17975 - ADCL_RETUNE_C28_0 */
+	[17976] = 0x0000,     /* R17976 - ADCL_RETUNE_C29_1 */
+	[17977] = 0x0000,     /* R17977 - ADCL_RETUNE_C29_0 */
+	[17978] = 0x0000,     /* R17978 - ADCL_RETUNE_C30_1 */
+	[17979] = 0x0000,     /* R17979 - ADCL_RETUNE_C30_0 */
+	[17980] = 0x0000,     /* R17980 - ADCL_RETUNE_C31_1 */
+	[17981] = 0x0000,     /* R17981 - ADCL_RETUNE_C31_0 */
+	[17982] = 0x0000,     /* R17982 - ADCL_RETUNE_C32_1 */
+	[17983] = 0x0000,     /* R17983 - ADCL_RETUNE_C32_0 */
+
+	[18432] = 0x0020,     /* R18432 - RETUNEADC_PG2_1 */
+	[18433] = 0x0000,     /* R18433 - RETUNEADC_PG2_0 */
+	[18434] = 0x0040,     /* R18434 - RETUNEADC_PG_1 */
+	[18435] = 0x0000,     /* R18435 - RETUNEADC_PG_0 */
+
+	[18944] = 0x007F,     /* R18944 - ADCR_RETUNE_C1_1 */
+	[18945] = 0xFFFF,     /* R18945 - ADCR_RETUNE_C1_0 */
+	[18946] = 0x0000,     /* R18946 - ADCR_RETUNE_C2_1 */
+	[18947] = 0x0000,     /* R18947 - ADCR_RETUNE_C2_0 */
+	[18948] = 0x0000,     /* R18948 - ADCR_RETUNE_C3_1 */
+	[18949] = 0x0000,     /* R18949 - ADCR_RETUNE_C3_0 */
+	[18950] = 0x0000,     /* R18950 - ADCR_RETUNE_C4_1 */
+	[18951] = 0x0000,     /* R18951 - ADCR_RETUNE_C4_0 */
+	[18952] = 0x0000,     /* R18952 - ADCR_RETUNE_C5_1 */
+	[18953] = 0x0000,     /* R18953 - ADCR_RETUNE_C5_0 */
+	[18954] = 0x0000,     /* R18954 - ADCR_RETUNE_C6_1 */
+	[18955] = 0x0000,     /* R18955 - ADCR_RETUNE_C6_0 */
+	[18956] = 0x0000,     /* R18956 - ADCR_RETUNE_C7_1 */
+	[18957] = 0x0000,     /* R18957 - ADCR_RETUNE_C7_0 */
+	[18958] = 0x0000,     /* R18958 - ADCR_RETUNE_C8_1 */
+	[18959] = 0x0000,     /* R18959 - ADCR_RETUNE_C8_0 */
+	[18960] = 0x0000,     /* R18960 - ADCR_RETUNE_C9_1 */
+	[18961] = 0x0000,     /* R18961 - ADCR_RETUNE_C9_0 */
+	[18962] = 0x0000,     /* R18962 - ADCR_RETUNE_C10_1 */
+	[18963] = 0x0000,     /* R18963 - ADCR_RETUNE_C10_0 */
+	[18964] = 0x0000,     /* R18964 - ADCR_RETUNE_C11_1 */
+	[18965] = 0x0000,     /* R18965 - ADCR_RETUNE_C11_0 */
+	[18966] = 0x0000,     /* R18966 - ADCR_RETUNE_C12_1 */
+	[18967] = 0x0000,     /* R18967 - ADCR_RETUNE_C12_0 */
+	[18968] = 0x0000,     /* R18968 - ADCR_RETUNE_C13_1 */
+	[18969] = 0x0000,     /* R18969 - ADCR_RETUNE_C13_0 */
+	[18970] = 0x0000,     /* R18970 - ADCR_RETUNE_C14_1 */
+	[18971] = 0x0000,     /* R18971 - ADCR_RETUNE_C14_0 */
+	[18972] = 0x0000,     /* R18972 - ADCR_RETUNE_C15_1 */
+	[18973] = 0x0000,     /* R18973 - ADCR_RETUNE_C15_0 */
+	[18974] = 0x0000,     /* R18974 - ADCR_RETUNE_C16_1 */
+	[18975] = 0x0000,     /* R18975 - ADCR_RETUNE_C16_0 */
+	[18976] = 0x0000,     /* R18976 - ADCR_RETUNE_C17_1 */
+	[18977] = 0x0000,     /* R18977 - ADCR_RETUNE_C17_0 */
+	[18978] = 0x0000,     /* R18978 - ADCR_RETUNE_C18_1 */
+	[18979] = 0x0000,     /* R18979 - ADCR_RETUNE_C18_0 */
+	[18980] = 0x0000,     /* R18980 - ADCR_RETUNE_C19_1 */
+	[18981] = 0x0000,     /* R18981 - ADCR_RETUNE_C19_0 */
+	[18982] = 0x0000,     /* R18982 - ADCR_RETUNE_C20_1 */
+	[18983] = 0x0000,     /* R18983 - ADCR_RETUNE_C20_0 */
+	[18984] = 0x0000,     /* R18984 - ADCR_RETUNE_C21_1 */
+	[18985] = 0x0000,     /* R18985 - ADCR_RETUNE_C21_0 */
+	[18986] = 0x0000,     /* R18986 - ADCR_RETUNE_C22_1 */
+	[18987] = 0x0000,     /* R18987 - ADCR_RETUNE_C22_0 */
+	[18988] = 0x0000,     /* R18988 - ADCR_RETUNE_C23_1 */
+	[18989] = 0x0000,     /* R18989 - ADCR_RETUNE_C23_0 */
+	[18990] = 0x0000,     /* R18990 - ADCR_RETUNE_C24_1 */
+	[18991] = 0x0000,     /* R18991 - ADCR_RETUNE_C24_0 */
+	[18992] = 0x0000,     /* R18992 - ADCR_RETUNE_C25_1 */
+	[18993] = 0x0000,     /* R18993 - ADCR_RETUNE_C25_0 */
+	[18994] = 0x0000,     /* R18994 - ADCR_RETUNE_C26_1 */
+	[18995] = 0x0000,     /* R18995 - ADCR_RETUNE_C26_0 */
+	[18996] = 0x0000,     /* R18996 - ADCR_RETUNE_C27_1 */
+	[18997] = 0x0000,     /* R18997 - ADCR_RETUNE_C27_0 */
+	[18998] = 0x0000,     /* R18998 - ADCR_RETUNE_C28_1 */
+	[18999] = 0x0000,     /* R18999 - ADCR_RETUNE_C28_0 */
+	[19000] = 0x0000,     /* R19000 - ADCR_RETUNE_C29_1 */
+	[19001] = 0x0000,     /* R19001 - ADCR_RETUNE_C29_0 */
+	[19002] = 0x0000,     /* R19002 - ADCR_RETUNE_C30_1 */
+	[19003] = 0x0000,     /* R19003 - ADCR_RETUNE_C30_0 */
+	[19004] = 0x0000,     /* R19004 - ADCR_RETUNE_C31_1 */
+	[19005] = 0x0000,     /* R19005 - ADCR_RETUNE_C31_0 */
+	[19006] = 0x0000,     /* R19006 - ADCR_RETUNE_C32_1 */
+	[19007] = 0x0000,     /* R19007 - ADCR_RETUNE_C32_0 */
+
+	[19456] = 0x007F,     /* R19456 - DACL_RETUNE_C1_1 */
+	[19457] = 0xFFFF,     /* R19457 - DACL_RETUNE_C1_0 */
+	[19458] = 0x0000,     /* R19458 - DACL_RETUNE_C2_1 */
+	[19459] = 0x0000,     /* R19459 - DACL_RETUNE_C2_0 */
+	[19460] = 0x0000,     /* R19460 - DACL_RETUNE_C3_1 */
+	[19461] = 0x0000,     /* R19461 - DACL_RETUNE_C3_0 */
+	[19462] = 0x0000,     /* R19462 - DACL_RETUNE_C4_1 */
+	[19463] = 0x0000,     /* R19463 - DACL_RETUNE_C4_0 */
+	[19464] = 0x0000,     /* R19464 - DACL_RETUNE_C5_1 */
+	[19465] = 0x0000,     /* R19465 - DACL_RETUNE_C5_0 */
+	[19466] = 0x0000,     /* R19466 - DACL_RETUNE_C6_1 */
+	[19467] = 0x0000,     /* R19467 - DACL_RETUNE_C6_0 */
+	[19468] = 0x0000,     /* R19468 - DACL_RETUNE_C7_1 */
+	[19469] = 0x0000,     /* R19469 - DACL_RETUNE_C7_0 */
+	[19470] = 0x0000,     /* R19470 - DACL_RETUNE_C8_1 */
+	[19471] = 0x0000,     /* R19471 - DACL_RETUNE_C8_0 */
+	[19472] = 0x0000,     /* R19472 - DACL_RETUNE_C9_1 */
+	[19473] = 0x0000,     /* R19473 - DACL_RETUNE_C9_0 */
+	[19474] = 0x0000,     /* R19474 - DACL_RETUNE_C10_1 */
+	[19475] = 0x0000,     /* R19475 - DACL_RETUNE_C10_0 */
+	[19476] = 0x0000,     /* R19476 - DACL_RETUNE_C11_1 */
+	[19477] = 0x0000,     /* R19477 - DACL_RETUNE_C11_0 */
+	[19478] = 0x0000,     /* R19478 - DACL_RETUNE_C12_1 */
+	[19479] = 0x0000,     /* R19479 - DACL_RETUNE_C12_0 */
+	[19480] = 0x0000,     /* R19480 - DACL_RETUNE_C13_1 */
+	[19481] = 0x0000,     /* R19481 - DACL_RETUNE_C13_0 */
+	[19482] = 0x0000,     /* R19482 - DACL_RETUNE_C14_1 */
+	[19483] = 0x0000,     /* R19483 - DACL_RETUNE_C14_0 */
+	[19484] = 0x0000,     /* R19484 - DACL_RETUNE_C15_1 */
+	[19485] = 0x0000,     /* R19485 - DACL_RETUNE_C15_0 */
+	[19486] = 0x0000,     /* R19486 - DACL_RETUNE_C16_1 */
+	[19487] = 0x0000,     /* R19487 - DACL_RETUNE_C16_0 */
+	[19488] = 0x0000,     /* R19488 - DACL_RETUNE_C17_1 */
+	[19489] = 0x0000,     /* R19489 - DACL_RETUNE_C17_0 */
+	[19490] = 0x0000,     /* R19490 - DACL_RETUNE_C18_1 */
+	[19491] = 0x0000,     /* R19491 - DACL_RETUNE_C18_0 */
+	[19492] = 0x0000,     /* R19492 - DACL_RETUNE_C19_1 */
+	[19493] = 0x0000,     /* R19493 - DACL_RETUNE_C19_0 */
+	[19494] = 0x0000,     /* R19494 - DACL_RETUNE_C20_1 */
+	[19495] = 0x0000,     /* R19495 - DACL_RETUNE_C20_0 */
+	[19496] = 0x0000,     /* R19496 - DACL_RETUNE_C21_1 */
+	[19497] = 0x0000,     /* R19497 - DACL_RETUNE_C21_0 */
+	[19498] = 0x0000,     /* R19498 - DACL_RETUNE_C22_1 */
+	[19499] = 0x0000,     /* R19499 - DACL_RETUNE_C22_0 */
+	[19500] = 0x0000,     /* R19500 - DACL_RETUNE_C23_1 */
+	[19501] = 0x0000,     /* R19501 - DACL_RETUNE_C23_0 */
+	[19502] = 0x0000,     /* R19502 - DACL_RETUNE_C24_1 */
+	[19503] = 0x0000,     /* R19503 - DACL_RETUNE_C24_0 */
+	[19504] = 0x0000,     /* R19504 - DACL_RETUNE_C25_1 */
+	[19505] = 0x0000,     /* R19505 - DACL_RETUNE_C25_0 */
+	[19506] = 0x0000,     /* R19506 - DACL_RETUNE_C26_1 */
+	[19507] = 0x0000,     /* R19507 - DACL_RETUNE_C26_0 */
+	[19508] = 0x0000,     /* R19508 - DACL_RETUNE_C27_1 */
+	[19509] = 0x0000,     /* R19509 - DACL_RETUNE_C27_0 */
+	[19510] = 0x0000,     /* R19510 - DACL_RETUNE_C28_1 */
+	[19511] = 0x0000,     /* R19511 - DACL_RETUNE_C28_0 */
+	[19512] = 0x0000,     /* R19512 - DACL_RETUNE_C29_1 */
+	[19513] = 0x0000,     /* R19513 - DACL_RETUNE_C29_0 */
+	[19514] = 0x0000,     /* R19514 - DACL_RETUNE_C30_1 */
+	[19515] = 0x0000,     /* R19515 - DACL_RETUNE_C30_0 */
+	[19516] = 0x0000,     /* R19516 - DACL_RETUNE_C31_1 */
+	[19517] = 0x0000,     /* R19517 - DACL_RETUNE_C31_0 */
+	[19518] = 0x0000,     /* R19518 - DACL_RETUNE_C32_1 */
+	[19519] = 0x0000,     /* R19519 - DACL_RETUNE_C32_0 */
+
+	[19968] = 0x0020,     /* R19968 - RETUNEDAC_PG2_1 */
+	[19969] = 0x0000,     /* R19969 - RETUNEDAC_PG2_0 */
+	[19970] = 0x0040,     /* R19970 - RETUNEDAC_PG_1 */
+	[19971] = 0x0000,     /* R19971 - RETUNEDAC_PG_0 */
+
+	[20480] = 0x007F,     /* R20480 - DACR_RETUNE_C1_1 */
+	[20481] = 0xFFFF,     /* R20481 - DACR_RETUNE_C1_0 */
+	[20482] = 0x0000,     /* R20482 - DACR_RETUNE_C2_1 */
+	[20483] = 0x0000,     /* R20483 - DACR_RETUNE_C2_0 */
+	[20484] = 0x0000,     /* R20484 - DACR_RETUNE_C3_1 */
+	[20485] = 0x0000,     /* R20485 - DACR_RETUNE_C3_0 */
+	[20486] = 0x0000,     /* R20486 - DACR_RETUNE_C4_1 */
+	[20487] = 0x0000,     /* R20487 - DACR_RETUNE_C4_0 */
+	[20488] = 0x0000,     /* R20488 - DACR_RETUNE_C5_1 */
+	[20489] = 0x0000,     /* R20489 - DACR_RETUNE_C5_0 */
+	[20490] = 0x0000,     /* R20490 - DACR_RETUNE_C6_1 */
+	[20491] = 0x0000,     /* R20491 - DACR_RETUNE_C6_0 */
+	[20492] = 0x0000,     /* R20492 - DACR_RETUNE_C7_1 */
+	[20493] = 0x0000,     /* R20493 - DACR_RETUNE_C7_0 */
+	[20494] = 0x0000,     /* R20494 - DACR_RETUNE_C8_1 */
+	[20495] = 0x0000,     /* R20495 - DACR_RETUNE_C8_0 */
+	[20496] = 0x0000,     /* R20496 - DACR_RETUNE_C9_1 */
+	[20497] = 0x0000,     /* R20497 - DACR_RETUNE_C9_0 */
+	[20498] = 0x0000,     /* R20498 - DACR_RETUNE_C10_1 */
+	[20499] = 0x0000,     /* R20499 - DACR_RETUNE_C10_0 */
+	[20500] = 0x0000,     /* R20500 - DACR_RETUNE_C11_1 */
+	[20501] = 0x0000,     /* R20501 - DACR_RETUNE_C11_0 */
+	[20502] = 0x0000,     /* R20502 - DACR_RETUNE_C12_1 */
+	[20503] = 0x0000,     /* R20503 - DACR_RETUNE_C12_0 */
+	[20504] = 0x0000,     /* R20504 - DACR_RETUNE_C13_1 */
+	[20505] = 0x0000,     /* R20505 - DACR_RETUNE_C13_0 */
+	[20506] = 0x0000,     /* R20506 - DACR_RETUNE_C14_1 */
+	[20507] = 0x0000,     /* R20507 - DACR_RETUNE_C14_0 */
+	[20508] = 0x0000,     /* R20508 - DACR_RETUNE_C15_1 */
+	[20509] = 0x0000,     /* R20509 - DACR_RETUNE_C15_0 */
+	[20510] = 0x0000,     /* R20510 - DACR_RETUNE_C16_1 */
+	[20511] = 0x0000,     /* R20511 - DACR_RETUNE_C16_0 */
+	[20512] = 0x0000,     /* R20512 - DACR_RETUNE_C17_1 */
+	[20513] = 0x0000,     /* R20513 - DACR_RETUNE_C17_0 */
+	[20514] = 0x0000,     /* R20514 - DACR_RETUNE_C18_1 */
+	[20515] = 0x0000,     /* R20515 - DACR_RETUNE_C18_0 */
+	[20516] = 0x0000,     /* R20516 - DACR_RETUNE_C19_1 */
+	[20517] = 0x0000,     /* R20517 - DACR_RETUNE_C19_0 */
+	[20518] = 0x0000,     /* R20518 - DACR_RETUNE_C20_1 */
+	[20519] = 0x0000,     /* R20519 - DACR_RETUNE_C20_0 */
+	[20520] = 0x0000,     /* R20520 - DACR_RETUNE_C21_1 */
+	[20521] = 0x0000,     /* R20521 - DACR_RETUNE_C21_0 */
+	[20522] = 0x0000,     /* R20522 - DACR_RETUNE_C22_1 */
+	[20523] = 0x0000,     /* R20523 - DACR_RETUNE_C22_0 */
+	[20524] = 0x0000,     /* R20524 - DACR_RETUNE_C23_1 */
+	[20525] = 0x0000,     /* R20525 - DACR_RETUNE_C23_0 */
+	[20526] = 0x0000,     /* R20526 - DACR_RETUNE_C24_1 */
+	[20527] = 0x0000,     /* R20527 - DACR_RETUNE_C24_0 */
+	[20528] = 0x0000,     /* R20528 - DACR_RETUNE_C25_1 */
+	[20529] = 0x0000,     /* R20529 - DACR_RETUNE_C25_0 */
+	[20530] = 0x0000,     /* R20530 - DACR_RETUNE_C26_1 */
+	[20531] = 0x0000,     /* R20531 - DACR_RETUNE_C26_0 */
+	[20532] = 0x0000,     /* R20532 - DACR_RETUNE_C27_1 */
+	[20533] = 0x0000,     /* R20533 - DACR_RETUNE_C27_0 */
+	[20534] = 0x0000,     /* R20534 - DACR_RETUNE_C28_1 */
+	[20535] = 0x0000,     /* R20535 - DACR_RETUNE_C28_0 */
+	[20536] = 0x0000,     /* R20536 - DACR_RETUNE_C29_1 */
+	[20537] = 0x0000,     /* R20537 - DACR_RETUNE_C29_0 */
+	[20538] = 0x0000,     /* R20538 - DACR_RETUNE_C30_1 */
+	[20539] = 0x0000,     /* R20539 - DACR_RETUNE_C30_0 */
+	[20540] = 0x0000,     /* R20540 - DACR_RETUNE_C31_1 */
+	[20541] = 0x0000,     /* R20541 - DACR_RETUNE_C31_0 */
+	[20542] = 0x0000,     /* R20542 - DACR_RETUNE_C32_1 */
+	[20543] = 0x0000,     /* R20543 - DACR_RETUNE_C32_0 */
+
+	[20992] = 0x008C,     /* R20992 - VSS_XHD2_1 */
+	[20993] = 0x0200,     /* R20993 - VSS_XHD2_0 */
+	[20994] = 0x0035,     /* R20994 - VSS_XHD3_1 */
+	[20995] = 0x0700,     /* R20995 - VSS_XHD3_0 */
+	[20996] = 0x003A,     /* R20996 - VSS_XHN1_1 */
+	[20997] = 0x4100,     /* R20997 - VSS_XHN1_0 */
+	[20998] = 0x008B,     /* R20998 - VSS_XHN2_1 */
+	[20999] = 0x7D00,     /* R20999 - VSS_XHN2_0 */
+	[21000] = 0x003A,     /* R21000 - VSS_XHN3_1 */
+	[21001] = 0x4100,     /* R21001 - VSS_XHN3_0 */
+	[21002] = 0x008C,     /* R21002 - VSS_XLA_1 */
+	[21003] = 0xFEE8,     /* R21003 - VSS_XLA_0 */
+	[21004] = 0x0078,     /* R21004 - VSS_XLB_1 */
+	[21005] = 0x0000,     /* R21005 - VSS_XLB_0 */
+	[21006] = 0x003F,     /* R21006 - VSS_XLG_1 */
+	[21007] = 0xB260,     /* R21007 - VSS_XLG_0 */
+	[21008] = 0x002D,     /* R21008 - VSS_PG2_1 */
+	[21009] = 0x1818,     /* R21009 - VSS_PG2_0 */
+	[21010] = 0x0020,     /* R21010 - VSS_PG_1 */
+	[21011] = 0x0000,     /* R21011 - VSS_PG_0 */
+	[21012] = 0x00F1,     /* R21012 - VSS_XTD1_1 */
+	[21013] = 0x8340,     /* R21013 - VSS_XTD1_0 */
+	[21014] = 0x00FB,     /* R21014 - VSS_XTD2_1 */
+	[21015] = 0x8300,     /* R21015 - VSS_XTD2_0 */
+	[21016] = 0x00EE,     /* R21016 - VSS_XTD3_1 */
+	[21017] = 0xAEC0,     /* R21017 - VSS_XTD3_0 */
+	[21018] = 0x00FB,     /* R21018 - VSS_XTD4_1 */
+	[21019] = 0xAC40,     /* R21019 - VSS_XTD4_0 */
+	[21020] = 0x00F1,     /* R21020 - VSS_XTD5_1 */
+	[21021] = 0x7F80,     /* R21021 - VSS_XTD5_0 */
+	[21022] = 0x00F4,     /* R21022 - VSS_XTD6_1 */
+	[21023] = 0x3B40,     /* R21023 - VSS_XTD6_0 */
+	[21024] = 0x00F5,     /* R21024 - VSS_XTD7_1 */
+	[21025] = 0xFB00,     /* R21025 - VSS_XTD7_0 */
+	[21026] = 0x00EA,     /* R21026 - VSS_XTD8_1 */
+	[21027] = 0x10C0,     /* R21027 - VSS_XTD8_0 */
+	[21028] = 0x00FC,     /* R21028 - VSS_XTD9_1 */
+	[21029] = 0xC580,     /* R21029 - VSS_XTD9_0 */
+	[21030] = 0x00E2,     /* R21030 - VSS_XTD10_1 */
+	[21031] = 0x75C0,     /* R21031 - VSS_XTD10_0 */
+	[21032] = 0x0004,     /* R21032 - VSS_XTD11_1 */
+	[21033] = 0xB480,     /* R21033 - VSS_XTD11_0 */
+	[21034] = 0x00D4,     /* R21034 - VSS_XTD12_1 */
+	[21035] = 0xF980,     /* R21035 - VSS_XTD12_0 */
+	[21036] = 0x0004,     /* R21036 - VSS_XTD13_1 */
+	[21037] = 0x9140,     /* R21037 - VSS_XTD13_0 */
+	[21038] = 0x00D8,     /* R21038 - VSS_XTD14_1 */
+	[21039] = 0xA480,     /* R21039 - VSS_XTD14_0 */
+	[21040] = 0x0002,     /* R21040 - VSS_XTD15_1 */
+	[21041] = 0x3DC0,     /* R21041 - VSS_XTD15_0 */
+	[21042] = 0x00CF,     /* R21042 - VSS_XTD16_1 */
+	[21043] = 0x7A80,     /* R21043 - VSS_XTD16_0 */
+	[21044] = 0x00DC,     /* R21044 - VSS_XTD17_1 */
+	[21045] = 0x0600,     /* R21045 - VSS_XTD17_0 */
+	[21046] = 0x00F2,     /* R21046 - VSS_XTD18_1 */
+	[21047] = 0xDAC0,     /* R21047 - VSS_XTD18_0 */
+	[21048] = 0x00BA,     /* R21048 - VSS_XTD19_1 */
+	[21049] = 0xF340,     /* R21049 - VSS_XTD19_0 */
+	[21050] = 0x000A,     /* R21050 - VSS_XTD20_1 */
+	[21051] = 0x7940,     /* R21051 - VSS_XTD20_0 */
+	[21052] = 0x001C,     /* R21052 - VSS_XTD21_1 */
+	[21053] = 0x0680,     /* R21053 - VSS_XTD21_0 */
+	[21054] = 0x00FD,     /* R21054 - VSS_XTD22_1 */
+	[21055] = 0x2D00,     /* R21055 - VSS_XTD22_0 */
+	[21056] = 0x001C,     /* R21056 - VSS_XTD23_1 */
+	[21057] = 0xE840,     /* R21057 - VSS_XTD23_0 */
+	[21058] = 0x000D,     /* R21058 - VSS_XTD24_1 */
+	[21059] = 0xDC40,     /* R21059 - VSS_XTD24_0 */
+	[21060] = 0x00FC,     /* R21060 - VSS_XTD25_1 */
+	[21061] = 0x9D00,     /* R21061 - VSS_XTD25_0 */
+	[21062] = 0x0009,     /* R21062 - VSS_XTD26_1 */
+	[21063] = 0x5580,     /* R21063 - VSS_XTD26_0 */
+	[21064] = 0x00FE,     /* R21064 - VSS_XTD27_1 */
+	[21065] = 0x7E80,     /* R21065 - VSS_XTD27_0 */
+	[21066] = 0x000E,     /* R21066 - VSS_XTD28_1 */
+	[21067] = 0xAB40,     /* R21067 - VSS_XTD28_0 */
+	[21068] = 0x00F9,     /* R21068 - VSS_XTD29_1 */
+	[21069] = 0x9880,     /* R21069 - VSS_XTD29_0 */
+	[21070] = 0x0009,     /* R21070 - VSS_XTD30_1 */
+	[21071] = 0x87C0,     /* R21071 - VSS_XTD30_0 */
+	[21072] = 0x00FD,     /* R21072 - VSS_XTD31_1 */
+	[21073] = 0x2C40,     /* R21073 - VSS_XTD31_0 */
+	[21074] = 0x0009,     /* R21074 - VSS_XTD32_1 */
+	[21075] = 0x4800,     /* R21075 - VSS_XTD32_0 */
+	[21076] = 0x0003,     /* R21076 - VSS_XTS1_1 */
+	[21077] = 0x5F40,     /* R21077 - VSS_XTS1_0 */
+	[21078] = 0x0000,     /* R21078 - VSS_XTS2_1 */
+	[21079] = 0x8700,     /* R21079 - VSS_XTS2_0 */
+	[21080] = 0x00FA,     /* R21080 - VSS_XTS3_1 */
+	[21081] = 0xE4C0,     /* R21081 - VSS_XTS3_0 */
+	[21082] = 0x0000,     /* R21082 - VSS_XTS4_1 */
+	[21083] = 0x0B40,     /* R21083 - VSS_XTS4_0 */
+	[21084] = 0x0004,     /* R21084 - VSS_XTS5_1 */
+	[21085] = 0xE180,     /* R21085 - VSS_XTS5_0 */
+	[21086] = 0x0001,     /* R21086 - VSS_XTS6_1 */
+	[21087] = 0x1F40,     /* R21087 - VSS_XTS6_0 */
+	[21088] = 0x00F8,     /* R21088 - VSS_XTS7_1 */
+	[21089] = 0xB000,     /* R21089 - VSS_XTS7_0 */
+	[21090] = 0x00FB,     /* R21090 - VSS_XTS8_1 */
+	[21091] = 0xCBC0,     /* R21091 - VSS_XTS8_0 */
+	[21092] = 0x0004,     /* R21092 - VSS_XTS9_1 */
+	[21093] = 0xF380,     /* R21093 - VSS_XTS9_0 */
+	[21094] = 0x0007,     /* R21094 - VSS_XTS10_1 */
+	[21095] = 0xDF40,     /* R21095 - VSS_XTS10_0 */
+	[21096] = 0x00FF,     /* R21096 - VSS_XTS11_1 */
+	[21097] = 0x0700,     /* R21097 - VSS_XTS11_0 */
+	[21098] = 0x00EF,     /* R21098 - VSS_XTS12_1 */
+	[21099] = 0xD700,     /* R21099 - VSS_XTS12_0 */
+	[21100] = 0x00FB,     /* R21100 - VSS_XTS13_1 */
+	[21101] = 0xAF40,     /* R21101 - VSS_XTS13_0 */
+	[21102] = 0x0010,     /* R21102 - VSS_XTS14_1 */
+	[21103] = 0x8A80,     /* R21103 - VSS_XTS14_0 */
+	[21104] = 0x0011,     /* R21104 - VSS_XTS15_1 */
+	[21105] = 0x07C0,     /* R21105 - VSS_XTS15_0 */
+	[21106] = 0x00E0,     /* R21106 - VSS_XTS16_1 */
+	[21107] = 0x0800,     /* R21107 - VSS_XTS16_0 */
+	[21108] = 0x00D2,     /* R21108 - VSS_XTS17_1 */
+	[21109] = 0x7600,     /* R21109 - VSS_XTS17_0 */
+	[21110] = 0x0020,     /* R21110 - VSS_XTS18_1 */
+	[21111] = 0xCF40,     /* R21111 - VSS_XTS18_0 */
+	[21112] = 0x0030,     /* R21112 - VSS_XTS19_1 */
+	[21113] = 0x2340,     /* R21113 - VSS_XTS19_0 */
+	[21114] = 0x00FD,     /* R21114 - VSS_XTS20_1 */
+	[21115] = 0x69C0,     /* R21115 - VSS_XTS20_0 */
+	[21116] = 0x0028,     /* R21116 - VSS_XTS21_1 */
+	[21117] = 0x3500,     /* R21117 - VSS_XTS21_0 */
+	[21118] = 0x0006,     /* R21118 - VSS_XTS22_1 */
+	[21119] = 0x3300,     /* R21119 - VSS_XTS22_0 */
+	[21120] = 0x00D9,     /* R21120 - VSS_XTS23_1 */
+	[21121] = 0xF6C0,     /* R21121 - VSS_XTS23_0 */
+	[21122] = 0x00F3,     /* R21122 - VSS_XTS24_1 */
+	[21123] = 0x3340,     /* R21123 - VSS_XTS24_0 */
+	[21124] = 0x000F,     /* R21124 - VSS_XTS25_1 */
+	[21125] = 0x4200,     /* R21125 - VSS_XTS25_0 */
+	[21126] = 0x0004,     /* R21126 - VSS_XTS26_1 */
+	[21127] = 0x0C80,     /* R21127 - VSS_XTS26_0 */
+	[21128] = 0x00FB,     /* R21128 - VSS_XTS27_1 */
+	[21129] = 0x3F80,     /* R21129 - VSS_XTS27_0 */
+	[21130] = 0x00F7,     /* R21130 - VSS_XTS28_1 */
+	[21131] = 0x57C0,     /* R21131 - VSS_XTS28_0 */
+	[21132] = 0x0003,     /* R21132 - VSS_XTS29_1 */
+	[21133] = 0x5400,     /* R21133 - VSS_XTS29_0 */
+	[21134] = 0x0000,     /* R21134 - VSS_XTS30_1 */
+	[21135] = 0xC6C0,     /* R21135 - VSS_XTS30_0 */
+	[21136] = 0x0003,     /* R21136 - VSS_XTS31_1 */
+	[21137] = 0x12C0,     /* R21137 - VSS_XTS31_0 */
+	[21138] = 0x00FD,     /* R21138 - VSS_XTS32_1 */
+	[21139] = 0x8580,     /* R21139 - VSS_XTS32_0 */
+};
 
-	{ 30, 0x005E },   /* R30    - Clocking 3 */
-	{ 31, 0x0000 },   /* R31    - Input mixer control (1) */
-	{ 32, 0x0145 },   /* R32    - Left input mixer volume */
-	{ 33, 0x0145 },   /* R33    - Right input mixer volume */
-	{ 34, 0x0009 },   /* R34    - Input mixer control (2) */
-	{ 35, 0x0003 },   /* R35    - Input bias control */
-	{ 37, 0x0008 },   /* R37    - Left input PGA control */
-	{ 38, 0x0008 },   /* R38    - Right input PGA control */
-
-	{ 40, 0x0000 },   /* R40    - SPKOUTL volume */
-	{ 41, 0x0000 },   /* R41    - SPKOUTR volume */
-
-	{ 51, 0x0003 },   /* R51    - Class D Control 2 */
-
-	{ 56, 0x0506 },   /* R56    - Clocking 4 */
-	{ 57, 0x0000 },   /* R57    - DAC DSP Mixing (1) */
-	{ 58, 0x0000 },   /* R58    - DAC DSP Mixing (2) */
-
-	{ 60, 0x0300 },   /* R60    - DC Servo 0 */
-	{ 61, 0x0300 },   /* R61    - DC Servo 1 */
-
-	{ 64, 0x0810 },   /* R64    - DC Servo 4 */
-
-	{ 68, 0x001B },   /* R68    - Analogue PGA Bias */
-	{ 69, 0x0000 },   /* R69    - Analogue HP 0 */
-
-	{ 71, 0x01FB },   /* R71    - Analogue HP 2 */
-	{ 72, 0x0000 },   /* R72    - Charge Pump 1 */
-
-	{ 82, 0x0004 },   /* R82    - Charge Pump B */
-
-	{ 87, 0x0000 },   /* R87    - Write Sequencer Control 1 */
-
-	{ 90, 0x0000 },   /* R90    - Write Sequencer Control 2 */
-
-	{ 93, 0x0000 },   /* R93    - Write Sequencer Control 3 */
-	{ 94, 0x0000 },   /* R94    - Control Interface */
-
-	{ 99, 0x0000 },   /* R99    - Mixer Enables */
-	{ 100, 0x0000 },   /* R100   - Headphone Mixer (1) */
-	{ 101, 0x0000 },   /* R101   - Headphone Mixer (2) */
-	{ 102, 0x013F },   /* R102   - Headphone Mixer (3) */
-	{ 103, 0x013F },   /* R103   - Headphone Mixer (4) */
-
-	{ 105, 0x0000 },   /* R105   - Speaker Mixer (1) */
-	{ 106, 0x0000 },   /* R106   - Speaker Mixer (2) */
-	{ 107, 0x013F },   /* R107   - Speaker Mixer (3) */
-	{ 108, 0x013F },   /* R108   - Speaker Mixer (4) */
-	{ 109, 0x0003 },   /* R109   - Speaker Mixer (5) */
-	{ 110, 0x0002 },   /* R110   - Beep Generator (1) */
-
-	{ 115, 0x0006 },   /* R115   - Oscillator Trim (3) */
-	{ 116, 0x0026 },   /* R116   - Oscillator Trim (4) */
-
-	{ 119, 0x0000 },   /* R119   - Oscillator Trim (7) */
-
-	{ 124, 0x0011 },   /* R124   - Analogue Clocking1 */
-	{ 125, 0x004B },   /* R125   - Analogue Clocking2 */
-	{ 126, 0x000D },   /* R126   - Analogue Clocking3 */
-	{ 127, 0x0000 },   /* R127   - PLL Software Reset */
-
-	{ 131, 0x0000 },   /* R131   - PLL 4 */
-
-	{ 136, 0x0067 },   /* R136   - PLL 9 */
-	{ 137, 0x001C },   /* R137   - PLL 10 */
-	{ 138, 0x0071 },   /* R138   - PLL 11 */
-	{ 139, 0x00C7 },   /* R139   - PLL 12 */
-	{ 140, 0x0067 },   /* R140   - PLL 13 */
-	{ 141, 0x0048 },   /* R141   - PLL 14 */
-	{ 142, 0x0022 },   /* R142   - PLL 15 */
-	{ 143, 0x0097 },   /* R143   - PLL 16 */
-
-	{ 155, 0x000C },   /* R155   - FLL Control (1) */
-	{ 156, 0x0039 },   /* R156   - FLL Control (2) */
-	{ 157, 0x0180 },   /* R157   - FLL Control (3) */
-
-	{ 159, 0x0032 },   /* R159   - FLL Control (5) */
-	{ 160, 0x0018 },   /* R160   - FLL Control (6) */
-	{ 161, 0x007D },   /* R161   - FLL Control (7) */
-	{ 162, 0x0008 },   /* R162   - FLL Control (8) */
-
-	{ 252, 0x0005 },   /* R252   - General test 1 */
-
-	{ 256, 0x0000 },   /* R256   - DF1 */
-	{ 257, 0x0000 },   /* R257   - DF2 */
-	{ 258, 0x0000 },   /* R258   - DF3 */
-	{ 259, 0x0000 },   /* R259   - DF4 */
-	{ 260, 0x0000 },   /* R260   - DF5 */
-	{ 261, 0x0000 },   /* R261   - DF6 */
-	{ 262, 0x0000 },   /* R262   - DF7 */
-
-	{ 264, 0x0000 },   /* R264   - LHPF1 */
-	{ 265, 0x0000 },   /* R265   - LHPF2 */
-
-	{ 268, 0x0000 },   /* R268   - THREED1 */
-	{ 269, 0x0000 },   /* R269   - THREED2 */
-	{ 270, 0x0000 },   /* R270   - THREED3 */
-	{ 271, 0x0000 },   /* R271   - THREED4 */
-
-	{ 276, 0x000C },   /* R276   - DRC 1 */
-	{ 277, 0x0925 },   /* R277   - DRC 2 */
-	{ 278, 0x0000 },   /* R278   - DRC 3 */
-	{ 279, 0x0000 },   /* R279   - DRC 4 */
-	{ 280, 0x0000 },   /* R280   - DRC 5 */
-
-	{ 285, 0x0000 },   /* R285   - Tloopback */
-
-	{ 335, 0x0004 },   /* R335   - EQ1 */
-	{ 336, 0x6318 },   /* R336   - EQ2 */
-	{ 337, 0x6300 },   /* R337   - EQ3 */
-	{ 338, 0x0FCA },   /* R338   - EQ4 */
-	{ 339, 0x0400 },   /* R339   - EQ5 */
-	{ 340, 0x00D8 },   /* R340   - EQ6 */
-	{ 341, 0x1EB5 },   /* R341   - EQ7 */
-	{ 342, 0xF145 },   /* R342   - EQ8 */
-	{ 343, 0x0B75 },   /* R343   - EQ9 */
-	{ 344, 0x01C5 },   /* R344   - EQ10 */
-	{ 345, 0x1C58 },   /* R345   - EQ11 */
-	{ 346, 0xF373 },   /* R346   - EQ12 */
-	{ 347, 0x0A54 },   /* R347   - EQ13 */
-	{ 348, 0x0558 },   /* R348   - EQ14 */
-	{ 349, 0x168E },   /* R349   - EQ15 */
-	{ 350, 0xF829 },   /* R350   - EQ16 */
-	{ 351, 0x07AD },   /* R351   - EQ17 */
-	{ 352, 0x1103 },   /* R352   - EQ18 */
-	{ 353, 0x0564 },   /* R353   - EQ19 */
-	{ 354, 0x0559 },   /* R354   - EQ20 */
-	{ 355, 0x4000 },   /* R355   - EQ21 */
-	{ 356, 0x6318 },   /* R356   - EQ22 */
-	{ 357, 0x6300 },   /* R357   - EQ23 */
-	{ 358, 0x0FCA },   /* R358   - EQ24 */
-	{ 359, 0x0400 },   /* R359   - EQ25 */
-	{ 360, 0x00D8 },   /* R360   - EQ26 */
-	{ 361, 0x1EB5 },   /* R361   - EQ27 */
-	{ 362, 0xF145 },   /* R362   - EQ28 */
-	{ 363, 0x0B75 },   /* R363   - EQ29 */
-	{ 364, 0x01C5 },   /* R364   - EQ30 */
-	{ 365, 0x1C58 },   /* R365   - EQ31 */
-	{ 366, 0xF373 },   /* R366   - EQ32 */
-	{ 367, 0x0A54 },   /* R367   - EQ33 */
-	{ 368, 0x0558 },   /* R368   - EQ34 */
-	{ 369, 0x168E },   /* R369   - EQ35 */
-	{ 370, 0xF829 },   /* R370   - EQ36 */
-	{ 371, 0x07AD },   /* R371   - EQ37 */
-	{ 372, 0x1103 },   /* R372   - EQ38 */
-	{ 373, 0x0564 },   /* R373   - EQ39 */
-	{ 374, 0x0559 },   /* R374   - EQ40 */
-	{ 375, 0x4000 },   /* R375   - EQ41 */
-
-	{ 513, 0x0000 },   /* R513   - GPIO 2 */
-	{ 514, 0x0000 },   /* R514   - GPIO 3 */
-
-	{ 516, 0x8100 },   /* R516   - GPIO 5 */
-	{ 517, 0x8100 },   /* R517   - GPIO 6 */
-
-	{ 568, 0x0030 },   /* R568   - Interrupt Status 1 Mask */
-	{ 569, 0xFFED },   /* R569   - Interrupt Status 2 Mask */
-
-	{ 576, 0x0000 },   /* R576   - Interrupt Control */
-
-	{ 584, 0x002D },   /* R584   - IRQ Debounce */
-
-	{ 586, 0x0000 },   /* R586   -  MICINT Source Pol */
-
-	{ 768, 0x1C00 },   /* R768   - DSP2 Power Management */
-
-	{ 8192, 0x0000 },   /* R8192  - DSP2 Instruction RAM 0 */
-
-	{ 9216, 0x0030 },   /* R9216  - DSP2 Address RAM 2 */
-	{ 9217, 0x0000 },   /* R9217  - DSP2 Address RAM 1 */
-	{ 9218, 0x0000 },   /* R9218  - DSP2 Address RAM 0 */
-
-	{ 12288, 0x0000 },   /* R12288 - DSP2 Data1 RAM 1 */
-	{ 12289, 0x0000 },   /* R12289 - DSP2 Data1 RAM 0 */
-
-	{ 13312, 0x0000 },   /* R13312 - DSP2 Data2 RAM 1 */
-	{ 13313, 0x0000 },   /* R13313 - DSP2 Data2 RAM 0 */
-
-	{ 14336, 0x0000 },   /* R14336 - DSP2 Data3 RAM 1 */
-	{ 14337, 0x0000 },   /* R14337 - DSP2 Data3 RAM 0 */
-
-	{ 15360, 0x000A },   /* R15360 - DSP2 Coeff RAM 0 */
-
-	{ 16384, 0x0000 },   /* R16384 - RETUNEADC_SHARED_COEFF_1 */
-	{ 16385, 0x0000 },   /* R16385 - RETUNEADC_SHARED_COEFF_0 */
-	{ 16386, 0x0000 },   /* R16386 - RETUNEDAC_SHARED_COEFF_1 */
-	{ 16387, 0x0000 },   /* R16387 - RETUNEDAC_SHARED_COEFF_0 */
-	{ 16388, 0x0000 },   /* R16388 - SOUNDSTAGE_ENABLES_1 */
-	{ 16389, 0x0000 },   /* R16389 - SOUNDSTAGE_ENABLES_0 */
-
-	{ 16896, 0x0002 },   /* R16896 - HDBASS_AI_1 */
-	{ 16897, 0xBD12 },   /* R16897 - HDBASS_AI_0 */
-	{ 16898, 0x007C },   /* R16898 - HDBASS_AR_1 */
-	{ 16899, 0x586C },   /* R16899 - HDBASS_AR_0 */
-	{ 16900, 0x0053 },   /* R16900 - HDBASS_B_1 */
-	{ 16901, 0x8121 },   /* R16901 - HDBASS_B_0 */
-	{ 16902, 0x003F },   /* R16902 - HDBASS_K_1 */
-	{ 16903, 0x8BD8 },   /* R16903 - HDBASS_K_0 */
-	{ 16904, 0x0032 },   /* R16904 - HDBASS_N1_1 */
-	{ 16905, 0xF52D },   /* R16905 - HDBASS_N1_0 */
-	{ 16906, 0x0065 },   /* R16906 - HDBASS_N2_1 */
-	{ 16907, 0xAC8C },   /* R16907 - HDBASS_N2_0 */
-	{ 16908, 0x006B },   /* R16908 - HDBASS_N3_1 */
-	{ 16909, 0xE087 },   /* R16909 - HDBASS_N3_0 */
-	{ 16910, 0x0072 },   /* R16910 - HDBASS_N4_1 */
-	{ 16911, 0x1483 },   /* R16911 - HDBASS_N4_0 */
-	{ 16912, 0x0072 },   /* R16912 - HDBASS_N5_1 */
-	{ 16913, 0x1483 },   /* R16913 - HDBASS_N5_0 */
-	{ 16914, 0x0043 },   /* R16914 - HDBASS_X1_1 */
-	{ 16915, 0x3525 },   /* R16915 - HDBASS_X1_0 */
-	{ 16916, 0x0006 },   /* R16916 - HDBASS_X2_1 */
-	{ 16917, 0x6A4A },   /* R16917 - HDBASS_X2_0 */
-	{ 16918, 0x0043 },   /* R16918 - HDBASS_X3_1 */
-	{ 16919, 0x6079 },   /* R16919 - HDBASS_X3_0 */
-	{ 16920, 0x0008 },   /* R16920 - HDBASS_ATK_1 */
-	{ 16921, 0x0000 },   /* R16921 - HDBASS_ATK_0 */
-	{ 16922, 0x0001 },   /* R16922 - HDBASS_DCY_1 */
-	{ 16923, 0x0000 },   /* R16923 - HDBASS_DCY_0 */
-	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
-	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
-
-	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */
-	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */
-
-	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
-	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
-	{ 17922, 0x0000 },   /* R17922 - ADCL_RETUNE_C2_1 */
-	{ 17923, 0x0000 },   /* R17923 - ADCL_RETUNE_C2_0 */
-	{ 17924, 0x0000 },   /* R17924 - ADCL_RETUNE_C3_1 */
-	{ 17925, 0x0000 },   /* R17925 - ADCL_RETUNE_C3_0 */
-	{ 17926, 0x0000 },   /* R17926 - ADCL_RETUNE_C4_1 */
-	{ 17927, 0x0000 },   /* R17927 - ADCL_RETUNE_C4_0 */
-	{ 17928, 0x0000 },   /* R17928 - ADCL_RETUNE_C5_1 */
-	{ 17929, 0x0000 },   /* R17929 - ADCL_RETUNE_C5_0 */
-	{ 17930, 0x0000 },   /* R17930 - ADCL_RETUNE_C6_1 */
-	{ 17931, 0x0000 },   /* R17931 - ADCL_RETUNE_C6_0 */
-	{ 17932, 0x0000 },   /* R17932 - ADCL_RETUNE_C7_1 */
-	{ 17933, 0x0000 },   /* R17933 - ADCL_RETUNE_C7_0 */
-	{ 17934, 0x0000 },   /* R17934 - ADCL_RETUNE_C8_1 */
-	{ 17935, 0x0000 },   /* R17935 - ADCL_RETUNE_C8_0 */
-	{ 17936, 0x0000 },   /* R17936 - ADCL_RETUNE_C9_1 */
-	{ 17937, 0x0000 },   /* R17937 - ADCL_RETUNE_C9_0 */
-	{ 17938, 0x0000 },   /* R17938 - ADCL_RETUNE_C10_1 */
-	{ 17939, 0x0000 },   /* R17939 - ADCL_RETUNE_C10_0 */
-	{ 17940, 0x0000 },   /* R17940 - ADCL_RETUNE_C11_1 */
-	{ 17941, 0x0000 },   /* R17941 - ADCL_RETUNE_C11_0 */
-	{ 17942, 0x0000 },   /* R17942 - ADCL_RETUNE_C12_1 */
-	{ 17943, 0x0000 },   /* R17943 - ADCL_RETUNE_C12_0 */
-	{ 17944, 0x0000 },   /* R17944 - ADCL_RETUNE_C13_1 */
-	{ 17945, 0x0000 },   /* R17945 - ADCL_RETUNE_C13_0 */
-	{ 17946, 0x0000 },   /* R17946 - ADCL_RETUNE_C14_1 */
-	{ 17947, 0x0000 },   /* R17947 - ADCL_RETUNE_C14_0 */
-	{ 17948, 0x0000 },   /* R17948 - ADCL_RETUNE_C15_1 */
-	{ 17949, 0x0000 },   /* R17949 - ADCL_RETUNE_C15_0 */
-	{ 17950, 0x0000 },   /* R17950 - ADCL_RETUNE_C16_1 */
-	{ 17951, 0x0000 },   /* R17951 - ADCL_RETUNE_C16_0 */
-	{ 17952, 0x0000 },   /* R17952 - ADCL_RETUNE_C17_1 */
-	{ 17953, 0x0000 },   /* R17953 - ADCL_RETUNE_C17_0 */
-	{ 17954, 0x0000 },   /* R17954 - ADCL_RETUNE_C18_1 */
-	{ 17955, 0x0000 },   /* R17955 - ADCL_RETUNE_C18_0 */
-	{ 17956, 0x0000 },   /* R17956 - ADCL_RETUNE_C19_1 */
-	{ 17957, 0x0000 },   /* R17957 - ADCL_RETUNE_C19_0 */
-	{ 17958, 0x0000 },   /* R17958 - ADCL_RETUNE_C20_1 */
-	{ 17959, 0x0000 },   /* R17959 - ADCL_RETUNE_C20_0 */
-	{ 17960, 0x0000 },   /* R17960 - ADCL_RETUNE_C21_1 */
-	{ 17961, 0x0000 },   /* R17961 - ADCL_RETUNE_C21_0 */
-	{ 17962, 0x0000 },   /* R17962 - ADCL_RETUNE_C22_1 */
-	{ 17963, 0x0000 },   /* R17963 - ADCL_RETUNE_C22_0 */
-	{ 17964, 0x0000 },   /* R17964 - ADCL_RETUNE_C23_1 */
-	{ 17965, 0x0000 },   /* R17965 - ADCL_RETUNE_C23_0 */
-	{ 17966, 0x0000 },   /* R17966 - ADCL_RETUNE_C24_1 */
-	{ 17967, 0x0000 },   /* R17967 - ADCL_RETUNE_C24_0 */
-	{ 17968, 0x0000 },   /* R17968 - ADCL_RETUNE_C25_1 */
-	{ 17969, 0x0000 },   /* R17969 - ADCL_RETUNE_C25_0 */
-	{ 17970, 0x0000 },   /* R17970 - ADCL_RETUNE_C26_1 */
-	{ 17971, 0x0000 },   /* R17971 - ADCL_RETUNE_C26_0 */
-	{ 17972, 0x0000 },   /* R17972 - ADCL_RETUNE_C27_1 */
-	{ 17973, 0x0000 },   /* R17973 - ADCL_RETUNE_C27_0 */
-	{ 17974, 0x0000 },   /* R17974 - ADCL_RETUNE_C28_1 */
-	{ 17975, 0x0000 },   /* R17975 - ADCL_RETUNE_C28_0 */
-	{ 17976, 0x0000 },   /* R17976 - ADCL_RETUNE_C29_1 */
-	{ 17977, 0x0000 },   /* R17977 - ADCL_RETUNE_C29_0 */
-	{ 17978, 0x0000 },   /* R17978 - ADCL_RETUNE_C30_1 */
-	{ 17979, 0x0000 },   /* R17979 - ADCL_RETUNE_C30_0 */
-	{ 17980, 0x0000 },   /* R17980 - ADCL_RETUNE_C31_1 */
-	{ 17981, 0x0000 },   /* R17981 - ADCL_RETUNE_C31_0 */
-	{ 17982, 0x0000 },   /* R17982 - ADCL_RETUNE_C32_1 */
-	{ 17983, 0x0000 },   /* R17983 - ADCL_RETUNE_C32_0 */
-
-	{ 18432, 0x0020 },   /* R18432 - RETUNEADC_PG2_1 */
-	{ 18433, 0x0000 },   /* R18433 - RETUNEADC_PG2_0 */
-	{ 18434, 0x0040 },   /* R18434 - RETUNEADC_PG_1 */
-	{ 18435, 0x0000 },   /* R18435 - RETUNEADC_PG_0 */
-
-	{ 18944, 0x007F },   /* R18944 - ADCR_RETUNE_C1_1 */
-	{ 18945, 0xFFFF },   /* R18945 - ADCR_RETUNE_C1_0 */
-	{ 18946, 0x0000 },   /* R18946 - ADCR_RETUNE_C2_1 */
-	{ 18947, 0x0000 },   /* R18947 - ADCR_RETUNE_C2_0 */
-	{ 18948, 0x0000 },   /* R18948 - ADCR_RETUNE_C3_1 */
-	{ 18949, 0x0000 },   /* R18949 - ADCR_RETUNE_C3_0 */
-	{ 18950, 0x0000 },   /* R18950 - ADCR_RETUNE_C4_1 */
-	{ 18951, 0x0000 },   /* R18951 - ADCR_RETUNE_C4_0 */
-	{ 18952, 0x0000 },   /* R18952 - ADCR_RETUNE_C5_1 */
-	{ 18953, 0x0000 },   /* R18953 - ADCR_RETUNE_C5_0 */
-	{ 18954, 0x0000 },   /* R18954 - ADCR_RETUNE_C6_1 */
-	{ 18955, 0x0000 },   /* R18955 - ADCR_RETUNE_C6_0 */
-	{ 18956, 0x0000 },   /* R18956 - ADCR_RETUNE_C7_1 */
-	{ 18957, 0x0000 },   /* R18957 - ADCR_RETUNE_C7_0 */
-	{ 18958, 0x0000 },   /* R18958 - ADCR_RETUNE_C8_1 */
-	{ 18959, 0x0000 },   /* R18959 - ADCR_RETUNE_C8_0 */
-	{ 18960, 0x0000 },   /* R18960 - ADCR_RETUNE_C9_1 */
-	{ 18961, 0x0000 },   /* R18961 - ADCR_RETUNE_C9_0 */
-	{ 18962, 0x0000 },   /* R18962 - ADCR_RETUNE_C10_1 */
-	{ 18963, 0x0000 },   /* R18963 - ADCR_RETUNE_C10_0 */
-	{ 18964, 0x0000 },   /* R18964 - ADCR_RETUNE_C11_1 */
-	{ 18965, 0x0000 },   /* R18965 - ADCR_RETUNE_C11_0 */
-	{ 18966, 0x0000 },   /* R18966 - ADCR_RETUNE_C12_1 */
-	{ 18967, 0x0000 },   /* R18967 - ADCR_RETUNE_C12_0 */
-	{ 18968, 0x0000 },   /* R18968 - ADCR_RETUNE_C13_1 */
-	{ 18969, 0x0000 },   /* R18969 - ADCR_RETUNE_C13_0 */
-	{ 18970, 0x0000 },   /* R18970 - ADCR_RETUNE_C14_1 */
-	{ 18971, 0x0000 },   /* R18971 - ADCR_RETUNE_C14_0 */
-	{ 18972, 0x0000 },   /* R18972 - ADCR_RETUNE_C15_1 */
-	{ 18973, 0x0000 },   /* R18973 - ADCR_RETUNE_C15_0 */
-	{ 18974, 0x0000 },   /* R18974 - ADCR_RETUNE_C16_1 */
-	{ 18975, 0x0000 },   /* R18975 - ADCR_RETUNE_C16_0 */
-	{ 18976, 0x0000 },   /* R18976 - ADCR_RETUNE_C17_1 */
-	{ 18977, 0x0000 },   /* R18977 - ADCR_RETUNE_C17_0 */
-	{ 18978, 0x0000 },   /* R18978 - ADCR_RETUNE_C18_1 */
-	{ 18979, 0x0000 },   /* R18979 - ADCR_RETUNE_C18_0 */
-	{ 18980, 0x0000 },   /* R18980 - ADCR_RETUNE_C19_1 */
-	{ 18981, 0x0000 },   /* R18981 - ADCR_RETUNE_C19_0 */
-	{ 18982, 0x0000 },   /* R18982 - ADCR_RETUNE_C20_1 */
-	{ 18983, 0x0000 },   /* R18983 - ADCR_RETUNE_C20_0 */
-	{ 18984, 0x0000 },   /* R18984 - ADCR_RETUNE_C21_1 */
-	{ 18985, 0x0000 },   /* R18985 - ADCR_RETUNE_C21_0 */
-	{ 18986, 0x0000 },   /* R18986 - ADCR_RETUNE_C22_1 */
-	{ 18987, 0x0000 },   /* R18987 - ADCR_RETUNE_C22_0 */
-	{ 18988, 0x0000 },   /* R18988 - ADCR_RETUNE_C23_1 */
-	{ 18989, 0x0000 },   /* R18989 - ADCR_RETUNE_C23_0 */
-	{ 18990, 0x0000 },   /* R18990 - ADCR_RETUNE_C24_1 */
-	{ 18991, 0x0000 },   /* R18991 - ADCR_RETUNE_C24_0 */
-	{ 18992, 0x0000 },   /* R18992 - ADCR_RETUNE_C25_1 */
-	{ 18993, 0x0000 },   /* R18993 - ADCR_RETUNE_C25_0 */
-	{ 18994, 0x0000 },   /* R18994 - ADCR_RETUNE_C26_1 */
-	{ 18995, 0x0000 },   /* R18995 - ADCR_RETUNE_C26_0 */
-	{ 18996, 0x0000 },   /* R18996 - ADCR_RETUNE_C27_1 */
-	{ 18997, 0x0000 },   /* R18997 - ADCR_RETUNE_C27_0 */
-	{ 18998, 0x0000 },   /* R18998 - ADCR_RETUNE_C28_1 */
-	{ 18999, 0x0000 },   /* R18999 - ADCR_RETUNE_C28_0 */
-	{ 19000, 0x0000 },   /* R19000 - ADCR_RETUNE_C29_1 */
-	{ 19001, 0x0000 },   /* R19001 - ADCR_RETUNE_C29_0 */
-	{ 19002, 0x0000 },   /* R19002 - ADCR_RETUNE_C30_1 */
-	{ 19003, 0x0000 },   /* R19003 - ADCR_RETUNE_C30_0 */
-	{ 19004, 0x0000 },   /* R19004 - ADCR_RETUNE_C31_1 */
-	{ 19005, 0x0000 },   /* R19005 - ADCR_RETUNE_C31_0 */
-	{ 19006, 0x0000 },   /* R19006 - ADCR_RETUNE_C32_1 */
-	{ 19007, 0x0000 },   /* R19007 - ADCR_RETUNE_C32_0 */
-
-	{ 19456, 0x007F },   /* R19456 - DACL_RETUNE_C1_1 */
-	{ 19457, 0xFFFF },   /* R19457 - DACL_RETUNE_C1_0 */
-	{ 19458, 0x0000 },   /* R19458 - DACL_RETUNE_C2_1 */
-	{ 19459, 0x0000 },   /* R19459 - DACL_RETUNE_C2_0 */
-	{ 19460, 0x0000 },   /* R19460 - DACL_RETUNE_C3_1 */
-	{ 19461, 0x0000 },   /* R19461 - DACL_RETUNE_C3_0 */
-	{ 19462, 0x0000 },   /* R19462 - DACL_RETUNE_C4_1 */
-	{ 19463, 0x0000 },   /* R19463 - DACL_RETUNE_C4_0 */
-	{ 19464, 0x0000 },   /* R19464 - DACL_RETUNE_C5_1 */
-	{ 19465, 0x0000 },   /* R19465 - DACL_RETUNE_C5_0 */
-	{ 19466, 0x0000 },   /* R19466 - DACL_RETUNE_C6_1 */
-	{ 19467, 0x0000 },   /* R19467 - DACL_RETUNE_C6_0 */
-	{ 19468, 0x0000 },   /* R19468 - DACL_RETUNE_C7_1 */
-	{ 19469, 0x0000 },   /* R19469 - DACL_RETUNE_C7_0 */
-	{ 19470, 0x0000 },   /* R19470 - DACL_RETUNE_C8_1 */
-	{ 19471, 0x0000 },   /* R19471 - DACL_RETUNE_C8_0 */
-	{ 19472, 0x0000 },   /* R19472 - DACL_RETUNE_C9_1 */
-	{ 19473, 0x0000 },   /* R19473 - DACL_RETUNE_C9_0 */
-	{ 19474, 0x0000 },   /* R19474 - DACL_RETUNE_C10_1 */
-	{ 19475, 0x0000 },   /* R19475 - DACL_RETUNE_C10_0 */
-	{ 19476, 0x0000 },   /* R19476 - DACL_RETUNE_C11_1 */
-	{ 19477, 0x0000 },   /* R19477 - DACL_RETUNE_C11_0 */
-	{ 19478, 0x0000 },   /* R19478 - DACL_RETUNE_C12_1 */
-	{ 19479, 0x0000 },   /* R19479 - DACL_RETUNE_C12_0 */
-	{ 19480, 0x0000 },   /* R19480 - DACL_RETUNE_C13_1 */
-	{ 19481, 0x0000 },   /* R19481 - DACL_RETUNE_C13_0 */
-	{ 19482, 0x0000 },   /* R19482 - DACL_RETUNE_C14_1 */
-	{ 19483, 0x0000 },   /* R19483 - DACL_RETUNE_C14_0 */
-	{ 19484, 0x0000 },   /* R19484 - DACL_RETUNE_C15_1 */
-	{ 19485, 0x0000 },   /* R19485 - DACL_RETUNE_C15_0 */
-	{ 19486, 0x0000 },   /* R19486 - DACL_RETUNE_C16_1 */
-	{ 19487, 0x0000 },   /* R19487 - DACL_RETUNE_C16_0 */
-	{ 19488, 0x0000 },   /* R19488 - DACL_RETUNE_C17_1 */
-	{ 19489, 0x0000 },   /* R19489 - DACL_RETUNE_C17_0 */
-	{ 19490, 0x0000 },   /* R19490 - DACL_RETUNE_C18_1 */
-	{ 19491, 0x0000 },   /* R19491 - DACL_RETUNE_C18_0 */
-	{ 19492, 0x0000 },   /* R19492 - DACL_RETUNE_C19_1 */
-	{ 19493, 0x0000 },   /* R19493 - DACL_RETUNE_C19_0 */
-	{ 19494, 0x0000 },   /* R19494 - DACL_RETUNE_C20_1 */
-	{ 19495, 0x0000 },   /* R19495 - DACL_RETUNE_C20_0 */
-	{ 19496, 0x0000 },   /* R19496 - DACL_RETUNE_C21_1 */
-	{ 19497, 0x0000 },   /* R19497 - DACL_RETUNE_C21_0 */
-	{ 19498, 0x0000 },   /* R19498 - DACL_RETUNE_C22_1 */
-	{ 19499, 0x0000 },   /* R19499 - DACL_RETUNE_C22_0 */
-	{ 19500, 0x0000 },   /* R19500 - DACL_RETUNE_C23_1 */
-	{ 19501, 0x0000 },   /* R19501 - DACL_RETUNE_C23_0 */
-	{ 19502, 0x0000 },   /* R19502 - DACL_RETUNE_C24_1 */
-	{ 19503, 0x0000 },   /* R19503 - DACL_RETUNE_C24_0 */
-	{ 19504, 0x0000 },   /* R19504 - DACL_RETUNE_C25_1 */
-	{ 19505, 0x0000 },   /* R19505 - DACL_RETUNE_C25_0 */
-	{ 19506, 0x0000 },   /* R19506 - DACL_RETUNE_C26_1 */
-	{ 19507, 0x0000 },   /* R19507 - DACL_RETUNE_C26_0 */
-	{ 19508, 0x0000 },   /* R19508 - DACL_RETUNE_C27_1 */
-	{ 19509, 0x0000 },   /* R19509 - DACL_RETUNE_C27_0 */
-	{ 19510, 0x0000 },   /* R19510 - DACL_RETUNE_C28_1 */
-	{ 19511, 0x0000 },   /* R19511 - DACL_RETUNE_C28_0 */
-	{ 19512, 0x0000 },   /* R19512 - DACL_RETUNE_C29_1 */
-	{ 19513, 0x0000 },   /* R19513 - DACL_RETUNE_C29_0 */
-	{ 19514, 0x0000 },   /* R19514 - DACL_RETUNE_C30_1 */
-	{ 19515, 0x0000 },   /* R19515 - DACL_RETUNE_C30_0 */
-	{ 19516, 0x0000 },   /* R19516 - DACL_RETUNE_C31_1 */
-	{ 19517, 0x0000 },   /* R19517 - DACL_RETUNE_C31_0 */
-	{ 19518, 0x0000 },   /* R19518 - DACL_RETUNE_C32_1 */
-	{ 19519, 0x0000 },   /* R19519 - DACL_RETUNE_C32_0 */
-
-	{ 19968, 0x0020 },   /* R19968 - RETUNEDAC_PG2_1 */
-	{ 19969, 0x0000 },   /* R19969 - RETUNEDAC_PG2_0 */
-	{ 19970, 0x0040 },   /* R19970 - RETUNEDAC_PG_1 */
-	{ 19971, 0x0000 },   /* R19971 - RETUNEDAC_PG_0 */
-
-	{ 20480, 0x007F },   /* R20480 - DACR_RETUNE_C1_1 */
-	{ 20481, 0xFFFF },   /* R20481 - DACR_RETUNE_C1_0 */
-	{ 20482, 0x0000 },   /* R20482 - DACR_RETUNE_C2_1 */
-	{ 20483, 0x0000 },   /* R20483 - DACR_RETUNE_C2_0 */
-	{ 20484, 0x0000 },   /* R20484 - DACR_RETUNE_C3_1 */
-	{ 20485, 0x0000 },   /* R20485 - DACR_RETUNE_C3_0 */
-	{ 20486, 0x0000 },   /* R20486 - DACR_RETUNE_C4_1 */
-	{ 20487, 0x0000 },   /* R20487 - DACR_RETUNE_C4_0 */
-	{ 20488, 0x0000 },   /* R20488 - DACR_RETUNE_C5_1 */
-	{ 20489, 0x0000 },   /* R20489 - DACR_RETUNE_C5_0 */
-	{ 20490, 0x0000 },   /* R20490 - DACR_RETUNE_C6_1 */
-	{ 20491, 0x0000 },   /* R20491 - DACR_RETUNE_C6_0 */
-	{ 20492, 0x0000 },   /* R20492 - DACR_RETUNE_C7_1 */
-	{ 20493, 0x0000 },   /* R20493 - DACR_RETUNE_C7_0 */
-	{ 20494, 0x0000 },   /* R20494 - DACR_RETUNE_C8_1 */
-	{ 20495, 0x0000 },   /* R20495 - DACR_RETUNE_C8_0 */
-	{ 20496, 0x0000 },   /* R20496 - DACR_RETUNE_C9_1 */
-	{ 20497, 0x0000 },   /* R20497 - DACR_RETUNE_C9_0 */
-	{ 20498, 0x0000 },   /* R20498 - DACR_RETUNE_C10_1 */
-	{ 20499, 0x0000 },   /* R20499 - DACR_RETUNE_C10_0 */
-	{ 20500, 0x0000 },   /* R20500 - DACR_RETUNE_C11_1 */
-	{ 20501, 0x0000 },   /* R20501 - DACR_RETUNE_C11_0 */
-	{ 20502, 0x0000 },   /* R20502 - DACR_RETUNE_C12_1 */
-	{ 20503, 0x0000 },   /* R20503 - DACR_RETUNE_C12_0 */
-	{ 20504, 0x0000 },   /* R20504 - DACR_RETUNE_C13_1 */
-	{ 20505, 0x0000 },   /* R20505 - DACR_RETUNE_C13_0 */
-	{ 20506, 0x0000 },   /* R20506 - DACR_RETUNE_C14_1 */
-	{ 20507, 0x0000 },   /* R20507 - DACR_RETUNE_C14_0 */
-	{ 20508, 0x0000 },   /* R20508 - DACR_RETUNE_C15_1 */
-	{ 20509, 0x0000 },   /* R20509 - DACR_RETUNE_C15_0 */
-	{ 20510, 0x0000 },   /* R20510 - DACR_RETUNE_C16_1 */
-	{ 20511, 0x0000 },   /* R20511 - DACR_RETUNE_C16_0 */
-	{ 20512, 0x0000 },   /* R20512 - DACR_RETUNE_C17_1 */
-	{ 20513, 0x0000 },   /* R20513 - DACR_RETUNE_C17_0 */
-	{ 20514, 0x0000 },   /* R20514 - DACR_RETUNE_C18_1 */
-	{ 20515, 0x0000 },   /* R20515 - DACR_RETUNE_C18_0 */
-	{ 20516, 0x0000 },   /* R20516 - DACR_RETUNE_C19_1 */
-	{ 20517, 0x0000 },   /* R20517 - DACR_RETUNE_C19_0 */
-	{ 20518, 0x0000 },   /* R20518 - DACR_RETUNE_C20_1 */
-	{ 20519, 0x0000 },   /* R20519 - DACR_RETUNE_C20_0 */
-	{ 20520, 0x0000 },   /* R20520 - DACR_RETUNE_C21_1 */
-	{ 20521, 0x0000 },   /* R20521 - DACR_RETUNE_C21_0 */
-	{ 20522, 0x0000 },   /* R20522 - DACR_RETUNE_C22_1 */
-	{ 20523, 0x0000 },   /* R20523 - DACR_RETUNE_C22_0 */
-	{ 20524, 0x0000 },   /* R20524 - DACR_RETUNE_C23_1 */
-	{ 20525, 0x0000 },   /* R20525 - DACR_RETUNE_C23_0 */
-	{ 20526, 0x0000 },   /* R20526 - DACR_RETUNE_C24_1 */
-	{ 20527, 0x0000 },   /* R20527 - DACR_RETUNE_C24_0 */
-	{ 20528, 0x0000 },   /* R20528 - DACR_RETUNE_C25_1 */
-	{ 20529, 0x0000 },   /* R20529 - DACR_RETUNE_C25_0 */
-	{ 20530, 0x0000 },   /* R20530 - DACR_RETUNE_C26_1 */
-	{ 20531, 0x0000 },   /* R20531 - DACR_RETUNE_C26_0 */
-	{ 20532, 0x0000 },   /* R20532 - DACR_RETUNE_C27_1 */
-	{ 20533, 0x0000 },   /* R20533 - DACR_RETUNE_C27_0 */
-	{ 20534, 0x0000 },   /* R20534 - DACR_RETUNE_C28_1 */
-	{ 20535, 0x0000 },   /* R20535 - DACR_RETUNE_C28_0 */
-	{ 20536, 0x0000 },   /* R20536 - DACR_RETUNE_C29_1 */
-	{ 20537, 0x0000 },   /* R20537 - DACR_RETUNE_C29_0 */
-	{ 20538, 0x0000 },   /* R20538 - DACR_RETUNE_C30_1 */
-	{ 20539, 0x0000 },   /* R20539 - DACR_RETUNE_C30_0 */
-	{ 20540, 0x0000 },   /* R20540 - DACR_RETUNE_C31_1 */
-	{ 20541, 0x0000 },   /* R20541 - DACR_RETUNE_C31_0 */
-	{ 20542, 0x0000 },   /* R20542 - DACR_RETUNE_C32_1 */
-	{ 20543, 0x0000 },   /* R20543 - DACR_RETUNE_C32_0 */
-
-	{ 20992, 0x008C },   /* R20992 - VSS_XHD2_1 */
-	{ 20993, 0x0200 },   /* R20993 - VSS_XHD2_0 */
-	{ 20994, 0x0035 },   /* R20994 - VSS_XHD3_1 */
-	{ 20995, 0x0700 },   /* R20995 - VSS_XHD3_0 */
-	{ 20996, 0x003A },   /* R20996 - VSS_XHN1_1 */
-	{ 20997, 0x4100 },   /* R20997 - VSS_XHN1_0 */
-	{ 20998, 0x008B },   /* R20998 - VSS_XHN2_1 */
-	{ 20999, 0x7D00 },   /* R20999 - VSS_XHN2_0 */
-	{ 21000, 0x003A },   /* R21000 - VSS_XHN3_1 */
-	{ 21001, 0x4100 },   /* R21001 - VSS_XHN3_0 */
-	{ 21002, 0x008C },   /* R21002 - VSS_XLA_1 */
-	{ 21003, 0xFEE8 },   /* R21003 - VSS_XLA_0 */
-	{ 21004, 0x0078 },   /* R21004 - VSS_XLB_1 */
-	{ 21005, 0x0000 },   /* R21005 - VSS_XLB_0 */
-	{ 21006, 0x003F },   /* R21006 - VSS_XLG_1 */
-	{ 21007, 0xB260 },   /* R21007 - VSS_XLG_0 */
-	{ 21008, 0x002D },   /* R21008 - VSS_PG2_1 */
-	{ 21009, 0x1818 },   /* R21009 - VSS_PG2_0 */
-	{ 21010, 0x0020 },   /* R21010 - VSS_PG_1 */
-	{ 21011, 0x0000 },   /* R21011 - VSS_PG_0 */
-	{ 21012, 0x00F1 },   /* R21012 - VSS_XTD1_1 */
-	{ 21013, 0x8340 },   /* R21013 - VSS_XTD1_0 */
-	{ 21014, 0x00FB },   /* R21014 - VSS_XTD2_1 */
-	{ 21015, 0x8300 },   /* R21015 - VSS_XTD2_0 */
-	{ 21016, 0x00EE },   /* R21016 - VSS_XTD3_1 */
-	{ 21017, 0xAEC0 },   /* R21017 - VSS_XTD3_0 */
-	{ 21018, 0x00FB },   /* R21018 - VSS_XTD4_1 */
-	{ 21019, 0xAC40 },   /* R21019 - VSS_XTD4_0 */
-	{ 21020, 0x00F1 },   /* R21020 - VSS_XTD5_1 */
-	{ 21021, 0x7F80 },   /* R21021 - VSS_XTD5_0 */
-	{ 21022, 0x00F4 },   /* R21022 - VSS_XTD6_1 */
-	{ 21023, 0x3B40 },   /* R21023 - VSS_XTD6_0 */
-	{ 21024, 0x00F5 },   /* R21024 - VSS_XTD7_1 */
-	{ 21025, 0xFB00 },   /* R21025 - VSS_XTD7_0 */
-	{ 21026, 0x00EA },   /* R21026 - VSS_XTD8_1 */
-	{ 21027, 0x10C0 },   /* R21027 - VSS_XTD8_0 */
-	{ 21028, 0x00FC },   /* R21028 - VSS_XTD9_1 */
-	{ 21029, 0xC580 },   /* R21029 - VSS_XTD9_0 */
-	{ 21030, 0x00E2 },   /* R21030 - VSS_XTD10_1 */
-	{ 21031, 0x75C0 },   /* R21031 - VSS_XTD10_0 */
-	{ 21032, 0x0004 },   /* R21032 - VSS_XTD11_1 */
-	{ 21033, 0xB480 },   /* R21033 - VSS_XTD11_0 */
-	{ 21034, 0x00D4 },   /* R21034 - VSS_XTD12_1 */
-	{ 21035, 0xF980 },   /* R21035 - VSS_XTD12_0 */
-	{ 21036, 0x0004 },   /* R21036 - VSS_XTD13_1 */
-	{ 21037, 0x9140 },   /* R21037 - VSS_XTD13_0 */
-	{ 21038, 0x00D8 },   /* R21038 - VSS_XTD14_1 */
-	{ 21039, 0xA480 },   /* R21039 - VSS_XTD14_0 */
-	{ 21040, 0x0002 },   /* R21040 - VSS_XTD15_1 */
-	{ 21041, 0x3DC0 },   /* R21041 - VSS_XTD15_0 */
-	{ 21042, 0x00CF },   /* R21042 - VSS_XTD16_1 */
-	{ 21043, 0x7A80 },   /* R21043 - VSS_XTD16_0 */
-	{ 21044, 0x00DC },   /* R21044 - VSS_XTD17_1 */
-	{ 21045, 0x0600 },   /* R21045 - VSS_XTD17_0 */
-	{ 21046, 0x00F2 },   /* R21046 - VSS_XTD18_1 */
-	{ 21047, 0xDAC0 },   /* R21047 - VSS_XTD18_0 */
-	{ 21048, 0x00BA },   /* R21048 - VSS_XTD19_1 */
-	{ 21049, 0xF340 },   /* R21049 - VSS_XTD19_0 */
-	{ 21050, 0x000A },   /* R21050 - VSS_XTD20_1 */
-	{ 21051, 0x7940 },   /* R21051 - VSS_XTD20_0 */
-	{ 21052, 0x001C },   /* R21052 - VSS_XTD21_1 */
-	{ 21053, 0x0680 },   /* R21053 - VSS_XTD21_0 */
-	{ 21054, 0x00FD },   /* R21054 - VSS_XTD22_1 */
-	{ 21055, 0x2D00 },   /* R21055 - VSS_XTD22_0 */
-	{ 21056, 0x001C },   /* R21056 - VSS_XTD23_1 */
-	{ 21057, 0xE840 },   /* R21057 - VSS_XTD23_0 */
-	{ 21058, 0x000D },   /* R21058 - VSS_XTD24_1 */
-	{ 21059, 0xDC40 },   /* R21059 - VSS_XTD24_0 */
-	{ 21060, 0x00FC },   /* R21060 - VSS_XTD25_1 */
-	{ 21061, 0x9D00 },   /* R21061 - VSS_XTD25_0 */
-	{ 21062, 0x0009 },   /* R21062 - VSS_XTD26_1 */
-	{ 21063, 0x5580 },   /* R21063 - VSS_XTD26_0 */
-	{ 21064, 0x00FE },   /* R21064 - VSS_XTD27_1 */
-	{ 21065, 0x7E80 },   /* R21065 - VSS_XTD27_0 */
-	{ 21066, 0x000E },   /* R21066 - VSS_XTD28_1 */
-	{ 21067, 0xAB40 },   /* R21067 - VSS_XTD28_0 */
-	{ 21068, 0x00F9 },   /* R21068 - VSS_XTD29_1 */
-	{ 21069, 0x9880 },   /* R21069 - VSS_XTD29_0 */
-	{ 21070, 0x0009 },   /* R21070 - VSS_XTD30_1 */
-	{ 21071, 0x87C0 },   /* R21071 - VSS_XTD30_0 */
-	{ 21072, 0x00FD },   /* R21072 - VSS_XTD31_1 */
-	{ 21073, 0x2C40 },   /* R21073 - VSS_XTD31_0 */
-	{ 21074, 0x0009 },   /* R21074 - VSS_XTD32_1 */
-	{ 21075, 0x4800 },   /* R21075 - VSS_XTD32_0 */
-	{ 21076, 0x0003 },   /* R21076 - VSS_XTS1_1 */
-	{ 21077, 0x5F40 },   /* R21077 - VSS_XTS1_0 */
-	{ 21078, 0x0000 },   /* R21078 - VSS_XTS2_1 */
-	{ 21079, 0x8700 },   /* R21079 - VSS_XTS2_0 */
-	{ 21080, 0x00FA },   /* R21080 - VSS_XTS3_1 */
-	{ 21081, 0xE4C0 },   /* R21081 - VSS_XTS3_0 */
-	{ 21082, 0x0000 },   /* R21082 - VSS_XTS4_1 */
-	{ 21083, 0x0B40 },   /* R21083 - VSS_XTS4_0 */
-	{ 21084, 0x0004 },   /* R21084 - VSS_XTS5_1 */
-	{ 21085, 0xE180 },   /* R21085 - VSS_XTS5_0 */
-	{ 21086, 0x0001 },   /* R21086 - VSS_XTS6_1 */
-	{ 21087, 0x1F40 },   /* R21087 - VSS_XTS6_0 */
-	{ 21088, 0x00F8 },   /* R21088 - VSS_XTS7_1 */
-	{ 21089, 0xB000 },   /* R21089 - VSS_XTS7_0 */
-	{ 21090, 0x00FB },   /* R21090 - VSS_XTS8_1 */
-	{ 21091, 0xCBC0 },   /* R21091 - VSS_XTS8_0 */
-	{ 21092, 0x0004 },   /* R21092 - VSS_XTS9_1 */
-	{ 21093, 0xF380 },   /* R21093 - VSS_XTS9_0 */
-	{ 21094, 0x0007 },   /* R21094 - VSS_XTS10_1 */
-	{ 21095, 0xDF40 },   /* R21095 - VSS_XTS10_0 */
-	{ 21096, 0x00FF },   /* R21096 - VSS_XTS11_1 */
-	{ 21097, 0x0700 },   /* R21097 - VSS_XTS11_0 */
-	{ 21098, 0x00EF },   /* R21098 - VSS_XTS12_1 */
-	{ 21099, 0xD700 },   /* R21099 - VSS_XTS12_0 */
-	{ 21100, 0x00FB },   /* R21100 - VSS_XTS13_1 */
-	{ 21101, 0xAF40 },   /* R21101 - VSS_XTS13_0 */
-	{ 21102, 0x0010 },   /* R21102 - VSS_XTS14_1 */
-	{ 21103, 0x8A80 },   /* R21103 - VSS_XTS14_0 */
-	{ 21104, 0x0011 },   /* R21104 - VSS_XTS15_1 */
-	{ 21105, 0x07C0 },   /* R21105 - VSS_XTS15_0 */
-	{ 21106, 0x00E0 },   /* R21106 - VSS_XTS16_1 */
-	{ 21107, 0x0800 },   /* R21107 - VSS_XTS16_0 */
-	{ 21108, 0x00D2 },   /* R21108 - VSS_XTS17_1 */
-	{ 21109, 0x7600 },   /* R21109 - VSS_XTS17_0 */
-	{ 21110, 0x0020 },   /* R21110 - VSS_XTS18_1 */
-	{ 21111, 0xCF40 },   /* R21111 - VSS_XTS18_0 */
-	{ 21112, 0x0030 },   /* R21112 - VSS_XTS19_1 */
-	{ 21113, 0x2340 },   /* R21113 - VSS_XTS19_0 */
-	{ 21114, 0x00FD },   /* R21114 - VSS_XTS20_1 */
-	{ 21115, 0x69C0 },   /* R21115 - VSS_XTS20_0 */
-	{ 21116, 0x0028 },   /* R21116 - VSS_XTS21_1 */
-	{ 21117, 0x3500 },   /* R21117 - VSS_XTS21_0 */
-	{ 21118, 0x0006 },   /* R21118 - VSS_XTS22_1 */
-	{ 21119, 0x3300 },   /* R21119 - VSS_XTS22_0 */
-	{ 21120, 0x00D9 },   /* R21120 - VSS_XTS23_1 */
-	{ 21121, 0xF6C0 },   /* R21121 - VSS_XTS23_0 */
-	{ 21122, 0x00F3 },   /* R21122 - VSS_XTS24_1 */
-	{ 21123, 0x3340 },   /* R21123 - VSS_XTS24_0 */
-	{ 21124, 0x000F },   /* R21124 - VSS_XTS25_1 */
-	{ 21125, 0x4200 },   /* R21125 - VSS_XTS25_0 */
-	{ 21126, 0x0004 },   /* R21126 - VSS_XTS26_1 */
-	{ 21127, 0x0C80 },   /* R21127 - VSS_XTS26_0 */
-	{ 21128, 0x00FB },   /* R21128 - VSS_XTS27_1 */
-	{ 21129, 0x3F80 },   /* R21129 - VSS_XTS27_0 */
-	{ 21130, 0x00F7 },   /* R21130 - VSS_XTS28_1 */
-	{ 21131, 0x57C0 },   /* R21131 - VSS_XTS28_0 */
-	{ 21132, 0x0003 },   /* R21132 - VSS_XTS29_1 */
-	{ 21133, 0x5400 },   /* R21133 - VSS_XTS29_0 */
-	{ 21134, 0x0000 },   /* R21134 - VSS_XTS30_1 */
-	{ 21135, 0xC6C0 },   /* R21135 - VSS_XTS30_0 */
-	{ 21136, 0x0003 },   /* R21136 - VSS_XTS31_1 */
-	{ 21137, 0x12C0 },   /* R21137 - VSS_XTS31_0 */
-	{ 21138, 0x00FD },   /* R21138 - VSS_XTS32_1 */
-	{ 21139, 0x8580 },   /* R21139 - VSS_XTS32_0 */
+static const struct wm8962_reg_access {
+	u16 read;
+	u16 write;
+	u16 vol;
+} wm8962_reg_access[WM8962_MAX_REGISTER + 1] = {
+	[0] = { 0x00FF, 0x01FF, 0x0000 }, /* R0     - Left Input volume */
+	[1] = { 0xFEFF, 0x01FF, 0xFFFF }, /* R1     - Right Input volume */
+	[2] = { 0x00FF, 0x01FF, 0x0000 }, /* R2     - HPOUTL volume */
+	[3] = { 0x00FF, 0x01FF, 0x0000 }, /* R3     - HPOUTR volume */
+	[4] = { 0x07FE, 0x07FE, 0xFFFF }, /* R4     - Clocking1 */
+	[5] = { 0x007F, 0x007F, 0x0000 }, /* R5     - ADC & DAC Control 1 */
+	[6] = { 0x37ED, 0x37ED, 0x0000 }, /* R6     - ADC & DAC Control 2 */
+	[7] = { 0x1FFF, 0x1FFF, 0x0000 }, /* R7     - Audio Interface 0 */
+	[8] = { 0x0FEF, 0x0FEF, 0xFFFF }, /* R8     - Clocking2 */
+	[9] = { 0x0B9F, 0x039F, 0x0000 }, /* R9     - Audio Interface 1 */
+	[10] = { 0x00FF, 0x01FF, 0x0000 }, /* R10    - Left DAC volume */
+	[11] = { 0x00FF, 0x01FF, 0x0000 }, /* R11    - Right DAC volume */
+	[14] = { 0x07FF, 0x07FF, 0x0000 }, /* R14    - Audio Interface 2 */
+	[15] = { 0xFFFF, 0xFFFF, 0xFFFF }, /* R15    - Software Reset */
+	[17] = { 0x07FF, 0x07FF, 0x0000 }, /* R17    - ALC1 */
+	[18] = { 0xF8FF, 0x00FF, 0xFFFF }, /* R18    - ALC2 */
+	[19] = { 0x1DFF, 0x1DFF, 0x0000 }, /* R19    - ALC3 */
+	[20] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20    - Noise Gate */
+	[21] = { 0x00FF, 0x01FF, 0x0000 }, /* R21    - Left ADC volume */
+	[22] = { 0x00FF, 0x01FF, 0x0000 }, /* R22    - Right ADC volume */
+	[23] = { 0x0161, 0x0161, 0x0000 }, /* R23    - Additional control(1) */
+	[24] = { 0x0008, 0x0008, 0x0000 }, /* R24    - Additional control(2) */
+	[25] = { 0x07FE, 0x07FE, 0x0000 }, /* R25    - Pwr Mgmt (1) */
+	[26] = { 0x01FB, 0x01FB, 0x0000 }, /* R26    - Pwr Mgmt (2) */
+	[27] = { 0x0017, 0x0017, 0x0000 }, /* R27    - Additional Control (3) */
+	[28] = { 0x001C, 0x001C, 0x0000 }, /* R28    - Anti-pop */
+
+	[30] = { 0xFFFE, 0xFFFE, 0x0000 }, /* R30    - Clocking 3 */
+	[31] = { 0x000F, 0x000F, 0x0000 }, /* R31    - Input mixer control (1) */
+	[32] = { 0x01FF, 0x01FF, 0x0000 }, /* R32    - Left input mixer volume */
+	[33] = { 0x01FF, 0x01FF, 0x0000 }, /* R33    - Right input mixer volume */
+	[34] = { 0x003F, 0x003F, 0x0000 }, /* R34    - Input mixer control (2) */
+	[35] = { 0x003F, 0x003F, 0x0000 }, /* R35    - Input bias control */
+	[37] = { 0x001F, 0x001F, 0x0000 }, /* R37    - Left input PGA control */
+	[38] = { 0x001F, 0x001F, 0x0000 }, /* R38    - Right input PGA control */
+	[40] = { 0x00FF, 0x01FF, 0x0000 }, /* R40    - SPKOUTL volume */
+	[41] = { 0x00FF, 0x01FF, 0x0000 }, /* R41    - SPKOUTR volume */
+
+	[47] = { 0x000F, 0x0000, 0xFFFF }, /* R47    - Thermal Shutdown Status*/
+	[48] = { 0x7EC7, 0x7E07, 0xFFFF }, /* R48    - Additional Control (4) */
+	[49] = { 0x00D3, 0x00D7, 0xFFFF }, /* R49    - Class D Control 1 */
+	[51] = { 0x0047, 0x0047, 0x0000 }, /* R51    - Class D Control 2 */
+	[56] = { 0x001E, 0x001E, 0x0000 }, /* R56    - Clocking 4 */
+	[57] = { 0x02FC, 0x02FC, 0x0000 }, /* R57    - DAC DSP Mixing (1) */
+	[58] = { 0x00FC, 0x00FC, 0x0000 }, /* R58    - DAC DSP Mixing (2) */
+	[60] = { 0x00CC, 0x00CC, 0x0000 }, /* R60    - DC Servo 0 */
+	[61] = { 0x00DD, 0x00DD, 0x0000 }, /* R61    - DC Servo 1 */
+	[64] = { 0x3F80, 0x3F80, 0x0000 }, /* R64    - DC Servo 4 */
+	[66] = { 0x0780, 0x0000, 0xFFFF }, /* R66    - DC Servo 6 */
+	[68] = { 0x0007, 0x0007, 0x0000 }, /* R68    - Analogue PGA Bias */
+	[69] = { 0x00FF, 0x00FF, 0x0000 }, /* R69    - Analogue HP 0 */
+	[71] = { 0x01FF, 0x01FF, 0x0000 }, /* R71    - Analogue HP 2 */
+	[72] = { 0x0001, 0x0001, 0x0000 }, /* R72    - Charge Pump 1 */
+	[82] = { 0x0001, 0x0001, 0x0000 }, /* R82    - Charge Pump B */
+	[87] = { 0x00A0, 0x00A0, 0x0000 }, /* R87    - Write Sequencer Control 1 */
+	[90] = { 0x007F, 0x01FF, 0x0000 }, /* R90    - Write Sequencer Control 2 */
+	[93] = { 0x03F9, 0x0000, 0x0000 }, /* R93    - Write Sequencer Control 3 */
+	[94] = { 0x0070, 0x0070, 0x0000 }, /* R94    - Control Interface */
+	[99] = { 0x000F, 0x000F, 0x0000 }, /* R99    - Mixer Enables */
+	[100] = { 0x00BF, 0x00BF, 0x0000 }, /* R100   - Headphone Mixer (1) */
+	[101] = { 0x00BF, 0x00BF, 0x0000 }, /* R101   - Headphone Mixer (2) */
+	[102] = { 0x01FF, 0x01FF, 0x0000 }, /* R102   - Headphone Mixer (3) */
+	[103] = { 0x01FF, 0x01FF, 0x0000 }, /* R103   - Headphone Mixer (4) */
+	[105] = { 0x00BF, 0x00BF, 0x0000 }, /* R105   - Speaker Mixer (1) */
+	[106] = { 0x00BF, 0x00BF, 0x0000 }, /* R106   - Speaker Mixer (2) */
+	[107] = { 0x01FF, 0x01FF, 0x0000 }, /* R107   - Speaker Mixer (3) */
+	[108] = { 0x01FF, 0x01FF, 0x0000 }, /* R108   - Speaker Mixer (4) */
+	[109] = { 0x00F0, 0x00F0, 0x0000 }, /* R109   - Speaker Mixer (5) */
+	[110] = { 0x00F7, 0x00F7, 0x0000 }, /* R110   - Beep Generator (1) */
+	[115] = { 0x001F, 0x001F, 0x0000 }, /* R115   - Oscillator Trim (3) */
+	[116] = { 0x001F, 0x001F, 0x0000 }, /* R116   - Oscillator Trim (4) */
+	[119] = { 0x00FF, 0x00FF, 0x0000 }, /* R119   - Oscillator Trim (7) */
+	[124] = { 0x0079, 0x0079, 0x0000 }, /* R124   - Analogue Clocking1 */
+	[125] = { 0x00DF, 0x00DF, 0x0000 }, /* R125   - Analogue Clocking2 */
+	[126] = { 0x000D, 0x000D, 0x0000 }, /* R126   - Analogue Clocking3 */
+	[127] = { 0x0000, 0xFFFF, 0x0000 }, /* R127   - PLL Software Reset */
+	[129] = { 0x00B0, 0x00B0, 0x0000 }, /* R129   - PLL2 */
+	[131] = { 0x0003, 0x0003, 0x0000 }, /* R131   - PLL 4 */
+	[136] = { 0x005F, 0x005F, 0x0000 }, /* R136   - PLL 9 */
+	[137] = { 0x00FF, 0x00FF, 0x0000 }, /* R137   - PLL 10 */
+	[138] = { 0x00FF, 0x00FF, 0x0000 }, /* R138   - PLL 11 */
+	[139] = { 0x00FF, 0x00FF, 0x0000 }, /* R139   - PLL 12 */
+	[140] = { 0x005F, 0x005F, 0x0000 }, /* R140   - PLL 13 */
+	[141] = { 0x00FF, 0x00FF, 0x0000 }, /* R141   - PLL 14 */
+	[142] = { 0x00FF, 0x00FF, 0x0000 }, /* R142   - PLL 15 */
+	[143] = { 0x00FF, 0x00FF, 0x0000 }, /* R143   - PLL 16 */
+	[155] = { 0x0067, 0x0067, 0x0000 }, /* R155   - FLL Control (1) */
+	[156] = { 0x01FB, 0x01FB, 0x0000 }, /* R156   - FLL Control (2) */
+	[157] = { 0x0007, 0x0007, 0x0000 }, /* R157   - FLL Control (3) */
+	[159] = { 0x007F, 0x007F, 0x0000 }, /* R159   - FLL Control (5) */
+	[160] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R160   - FLL Control (6) */
+	[161] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R161   - FLL Control (7) */
+	[162] = { 0x03FF, 0x03FF, 0x0000 }, /* R162   - FLL Control (8) */
+	[252] = { 0x0005, 0x0005, 0x0000 }, /* R252   - General test 1 */
+	[256] = { 0x000F, 0x000F, 0x0000 }, /* R256   - DF1 */
+	[257] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R257   - DF2 */
+	[258] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R258   - DF3 */
+	[259] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R259   - DF4 */
+	[260] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R260   - DF5 */
+	[261] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R261   - DF6 */
+	[262] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R262   - DF7 */
+	[264] = { 0x0003, 0x0003, 0x0000 }, /* R264   - LHPF1 */
+	[265] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R265   - LHPF2 */
+	[268] = { 0x0077, 0x0077, 0x0000 }, /* R268   - THREED1 */
+	[269] = { 0xFFFC, 0xFFFC, 0x0000 }, /* R269   - THREED2 */
+	[270] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R270   - THREED3 */
+	[271] = { 0xFFFC, 0xFFFC, 0x0000 }, /* R271   - THREED4 */
+	[276] = { 0x7FFF, 0x7FFF, 0x0000 }, /* R276   - DRC 1 */
+	[277] = { 0x1FFF, 0x1FFF, 0x0000 }, /* R277   - DRC 2 */
+	[278] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R278   - DRC 3 */
+	[279] = { 0x07FF, 0x07FF, 0x0000 }, /* R279   - DRC 4 */
+	[280] = { 0x03FF, 0x03FF, 0x0000 }, /* R280   - DRC 5 */
+	[285] = { 0x0003, 0x0003, 0x0000 }, /* R285   - Tloopback */
+	[335] = { 0x0007, 0x0007, 0x0000 }, /* R335   - EQ1 */
+	[336] = { 0xFFFE, 0xFFFE, 0x0000 }, /* R336   - EQ2 */
+	[337] = { 0xFFC0, 0xFFC0, 0x0000 }, /* R337   - EQ3 */
+	[338] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R338   - EQ4 */
+	[339] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R339   - EQ5 */
+	[340] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R340   - EQ6 */
+	[341] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R341   - EQ7 */
+	[342] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R342   - EQ8 */
+	[343] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R343   - EQ9 */
+	[344] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R344   - EQ10 */
+	[345] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R345   - EQ11 */
+	[346] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R346   - EQ12 */
+	[347] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R347   - EQ13 */
+	[348] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R348   - EQ14 */
+	[349] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R349   - EQ15 */
+	[350] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R350   - EQ16 */
+	[351] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R351   - EQ17 */
+	[352] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R352   - EQ18 */
+	[353] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R353   - EQ19 */
+	[354] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R354   - EQ20 */
+	[355] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R355   - EQ21 */
+	[356] = { 0xFFFE, 0xFFFE, 0x0000 }, /* R356   - EQ22 */
+	[357] = { 0xFFC0, 0xFFC0, 0x0000 }, /* R357   - EQ23 */
+	[358] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R358   - EQ24 */
+	[359] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R359   - EQ25 */
+	[360] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R360   - EQ26 */
+	[361] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R361   - EQ27 */
+	[362] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R362   - EQ28 */
+	[363] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R363   - EQ29 */
+	[364] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R364   - EQ30 */
+	[365] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R365   - EQ31 */
+	[366] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R366   - EQ32 */
+	[367] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R367   - EQ33 */
+	[368] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R368   - EQ34 */
+	[369] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R369   - EQ35 */
+	[370] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R370   - EQ36 */
+	[371] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R371   - EQ37 */
+	[372] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R372   - EQ38 */
+	[373] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R373   - EQ39 */
+	[374] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R374   - EQ40 */
+	[375] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R375   - EQ41 */
+	[513] = { 0x045F, 0x045F, 0x0000 }, /* R513   - GPIO 2 */
+	[514] = { 0x045F, 0x045F, 0x0000 }, /* R514   - GPIO 3 */
+	[516] = { 0xE75F, 0xE75F, 0x0000 }, /* R516   - GPIO 5 */
+	[517] = { 0xE75F, 0xE75F, 0x0000 }, /* R517   - GPIO 6 */
+	[560] = { 0x0030, 0x0030, 0xFFFF }, /* R560   - Interrupt Status 1 */
+	[561] = { 0xFFED, 0xFFED, 0xFFFF }, /* R561   - Interrupt Status 2 */
+	[568] = { 0x0030, 0x0030, 0x0000 }, /* R568   - Interrupt Status 1 Mask */
+	[569] = { 0xFFED, 0xFFED, 0x0000 }, /* R569   - Interrupt Status 2 Mask */
+	[576] = { 0x0001, 0x0001, 0x0000 }, /* R576   - Interrupt Control */
+	[584] = { 0x002D, 0x002D, 0x0000 }, /* R584   - IRQ Debounce */
+	[586] = { 0xC000, 0xC000, 0x0000 }, /* R586   -  MICINT Source Pol */
+	[768] = { 0x0001, 0x0001, 0x0000 }, /* R768   - DSP2 Power Management */
+	[1037] = { 0x0000, 0x003F, 0xFFFF }, /* R1037  - DSP2_ExecControl */
+	[4096] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4096  - Write Sequencer 0 */
+	[4097] = { 0x00FF, 0x00FF, 0x0000 }, /* R4097  - Write Sequencer 1 */
+	[4098] = { 0x070F, 0x070F, 0x0000 }, /* R4098  - Write Sequencer 2 */
+	[4099] = { 0x010F, 0x010F, 0x0000 }, /* R4099  - Write Sequencer 3 */
+	[4100] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4100  - Write Sequencer 4 */
+	[4101] = { 0x00FF, 0x00FF, 0x0000 }, /* R4101  - Write Sequencer 5 */
+	[4102] = { 0x070F, 0x070F, 0x0000 }, /* R4102  - Write Sequencer 6 */
+	[4103] = { 0x010F, 0x010F, 0x0000 }, /* R4103  - Write Sequencer 7 */
+	[4104] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4104  - Write Sequencer 8 */
+	[4105] = { 0x00FF, 0x00FF, 0x0000 }, /* R4105  - Write Sequencer 9 */
+	[4106] = { 0x070F, 0x070F, 0x0000 }, /* R4106  - Write Sequencer 10 */
+	[4107] = { 0x010F, 0x010F, 0x0000 }, /* R4107  - Write Sequencer 11 */
+	[4108] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4108  - Write Sequencer 12 */
+	[4109] = { 0x00FF, 0x00FF, 0x0000 }, /* R4109  - Write Sequencer 13 */
+	[4110] = { 0x070F, 0x070F, 0x0000 }, /* R4110  - Write Sequencer 14 */
+	[4111] = { 0x010F, 0x010F, 0x0000 }, /* R4111  - Write Sequencer 15 */
+	[4112] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4112  - Write Sequencer 16 */
+	[4113] = { 0x00FF, 0x00FF, 0x0000 }, /* R4113  - Write Sequencer 17 */
+	[4114] = { 0x070F, 0x070F, 0x0000 }, /* R4114  - Write Sequencer 18 */
+	[4115] = { 0x010F, 0x010F, 0x0000 }, /* R4115  - Write Sequencer 19 */
+	[4116] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4116  - Write Sequencer 20 */
+	[4117] = { 0x00FF, 0x00FF, 0x0000 }, /* R4117  - Write Sequencer 21 */
+	[4118] = { 0x070F, 0x070F, 0x0000 }, /* R4118  - Write Sequencer 22 */
+	[4119] = { 0x010F, 0x010F, 0x0000 }, /* R4119  - Write Sequencer 23 */
+	[4120] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4120  - Write Sequencer 24 */
+	[4121] = { 0x00FF, 0x00FF, 0x0000 }, /* R4121  - Write Sequencer 25 */
+	[4122] = { 0x070F, 0x070F, 0x0000 }, /* R4122  - Write Sequencer 26 */
+	[4123] = { 0x010F, 0x010F, 0x0000 }, /* R4123  - Write Sequencer 27 */
+	[4124] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4124  - Write Sequencer 28 */
+	[4125] = { 0x00FF, 0x00FF, 0x0000 }, /* R4125  - Write Sequencer 29 */
+	[4126] = { 0x070F, 0x070F, 0x0000 }, /* R4126  - Write Sequencer 30 */
+	[4127] = { 0x010F, 0x010F, 0x0000 }, /* R4127  - Write Sequencer 31 */
+	[4128] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4128  - Write Sequencer 32 */
+	[4129] = { 0x00FF, 0x00FF, 0x0000 }, /* R4129  - Write Sequencer 33 */
+	[4130] = { 0x070F, 0x070F, 0x0000 }, /* R4130  - Write Sequencer 34 */
+	[4131] = { 0x010F, 0x010F, 0x0000 }, /* R4131  - Write Sequencer 35 */
+	[4132] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4132  - Write Sequencer 36 */
+	[4133] = { 0x00FF, 0x00FF, 0x0000 }, /* R4133  - Write Sequencer 37 */
+	[4134] = { 0x070F, 0x070F, 0x0000 }, /* R4134  - Write Sequencer 38 */
+	[4135] = { 0x010F, 0x010F, 0x0000 }, /* R4135  - Write Sequencer 39 */
+	[4136] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4136  - Write Sequencer 40 */
+	[4137] = { 0x00FF, 0x00FF, 0x0000 }, /* R4137  - Write Sequencer 41 */
+	[4138] = { 0x070F, 0x070F, 0x0000 }, /* R4138  - Write Sequencer 42 */
+	[4139] = { 0x010F, 0x010F, 0x0000 }, /* R4139  - Write Sequencer 43 */
+	[4140] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4140  - Write Sequencer 44 */
+	[4141] = { 0x00FF, 0x00FF, 0x0000 }, /* R4141  - Write Sequencer 45 */
+	[4142] = { 0x070F, 0x070F, 0x0000 }, /* R4142  - Write Sequencer 46 */
+	[4143] = { 0x010F, 0x010F, 0x0000 }, /* R4143  - Write Sequencer 47 */
+	[4144] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4144  - Write Sequencer 48 */
+	[4145] = { 0x00FF, 0x00FF, 0x0000 }, /* R4145  - Write Sequencer 49 */
+	[4146] = { 0x070F, 0x070F, 0x0000 }, /* R4146  - Write Sequencer 50 */
+	[4147] = { 0x010F, 0x010F, 0x0000 }, /* R4147  - Write Sequencer 51 */
+	[4148] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4148  - Write Sequencer 52 */
+	[4149] = { 0x00FF, 0x00FF, 0x0000 }, /* R4149  - Write Sequencer 53 */
+	[4150] = { 0x070F, 0x070F, 0x0000 }, /* R4150  - Write Sequencer 54 */
+	[4151] = { 0x010F, 0x010F, 0x0000 }, /* R4151  - Write Sequencer 55 */
+	[4152] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4152  - Write Sequencer 56 */
+	[4153] = { 0x00FF, 0x00FF, 0x0000 }, /* R4153  - Write Sequencer 57 */
+	[4154] = { 0x070F, 0x070F, 0x0000 }, /* R4154  - Write Sequencer 58 */
+	[4155] = { 0x010F, 0x010F, 0x0000 }, /* R4155  - Write Sequencer 59 */
+	[4156] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4156  - Write Sequencer 60 */
+	[4157] = { 0x00FF, 0x00FF, 0x0000 }, /* R4157  - Write Sequencer 61 */
+	[4158] = { 0x070F, 0x070F, 0x0000 }, /* R4158  - Write Sequencer 62 */
+	[4159] = { 0x010F, 0x010F, 0x0000 }, /* R4159  - Write Sequencer 63 */
+	[4160] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4160  - Write Sequencer 64 */
+	[4161] = { 0x00FF, 0x00FF, 0x0000 }, /* R4161  - Write Sequencer 65 */
+	[4162] = { 0x070F, 0x070F, 0x0000 }, /* R4162  - Write Sequencer 66 */
+	[4163] = { 0x010F, 0x010F, 0x0000 }, /* R4163  - Write Sequencer 67 */
+	[4164] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4164  - Write Sequencer 68 */
+	[4165] = { 0x00FF, 0x00FF, 0x0000 }, /* R4165  - Write Sequencer 69 */
+	[4166] = { 0x070F, 0x070F, 0x0000 }, /* R4166  - Write Sequencer 70 */
+	[4167] = { 0x010F, 0x010F, 0x0000 }, /* R4167  - Write Sequencer 71 */
+	[4168] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4168  - Write Sequencer 72 */
+	[4169] = { 0x00FF, 0x00FF, 0x0000 }, /* R4169  - Write Sequencer 73 */
+	[4170] = { 0x070F, 0x070F, 0x0000 }, /* R4170  - Write Sequencer 74 */
+	[4171] = { 0x010F, 0x010F, 0x0000 }, /* R4171  - Write Sequencer 75 */
+	[4172] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4172  - Write Sequencer 76 */
+	[4173] = { 0x00FF, 0x00FF, 0x0000 }, /* R4173  - Write Sequencer 77 */
+	[4174] = { 0x070F, 0x070F, 0x0000 }, /* R4174  - Write Sequencer 78 */
+	[4175] = { 0x010F, 0x010F, 0x0000 }, /* R4175  - Write Sequencer 79 */
+	[4176] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4176  - Write Sequencer 80 */
+	[4177] = { 0x00FF, 0x00FF, 0x0000 }, /* R4177  - Write Sequencer 81 */
+	[4178] = { 0x070F, 0x070F, 0x0000 }, /* R4178  - Write Sequencer 82 */
+	[4179] = { 0x010F, 0x010F, 0x0000 }, /* R4179  - Write Sequencer 83 */
+	[4180] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4180  - Write Sequencer 84 */
+	[4181] = { 0x00FF, 0x00FF, 0x0000 }, /* R4181  - Write Sequencer 85 */
+	[4182] = { 0x070F, 0x070F, 0x0000 }, /* R4182  - Write Sequencer 86 */
+	[4183] = { 0x010F, 0x010F, 0x0000 }, /* R4183  - Write Sequencer 87 */
+	[4184] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4184  - Write Sequencer 88 */
+	[4185] = { 0x00FF, 0x00FF, 0x0000 }, /* R4185  - Write Sequencer 89 */
+	[4186] = { 0x070F, 0x070F, 0x0000 }, /* R4186  - Write Sequencer 90 */
+	[4187] = { 0x010F, 0x010F, 0x0000 }, /* R4187  - Write Sequencer 91 */
+	[4188] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4188  - Write Sequencer 92 */
+	[4189] = { 0x00FF, 0x00FF, 0x0000 }, /* R4189  - Write Sequencer 93 */
+	[4190] = { 0x070F, 0x070F, 0x0000 }, /* R4190  - Write Sequencer 94 */
+	[4191] = { 0x010F, 0x010F, 0x0000 }, /* R4191  - Write Sequencer 95 */
+	[4192] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4192  - Write Sequencer 96 */
+	[4193] = { 0x00FF, 0x00FF, 0x0000 }, /* R4193  - Write Sequencer 97 */
+	[4194] = { 0x070F, 0x070F, 0x0000 }, /* R4194  - Write Sequencer 98 */
+	[4195] = { 0x010F, 0x010F, 0x0000 }, /* R4195  - Write Sequencer 99 */
+	[4196] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4196  - Write Sequencer 100 */
+	[4197] = { 0x00FF, 0x00FF, 0x0000 }, /* R4197  - Write Sequencer 101 */
+	[4198] = { 0x070F, 0x070F, 0x0000 }, /* R4198  - Write Sequencer 102 */
+	[4199] = { 0x010F, 0x010F, 0x0000 }, /* R4199  - Write Sequencer 103 */
+	[4200] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4200  - Write Sequencer 104 */
+	[4201] = { 0x00FF, 0x00FF, 0x0000 }, /* R4201  - Write Sequencer 105 */
+	[4202] = { 0x070F, 0x070F, 0x0000 }, /* R4202  - Write Sequencer 106 */
+	[4203] = { 0x010F, 0x010F, 0x0000 }, /* R4203  - Write Sequencer 107 */
+	[4204] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4204  - Write Sequencer 108 */
+	[4205] = { 0x00FF, 0x00FF, 0x0000 }, /* R4205  - Write Sequencer 109 */
+	[4206] = { 0x070F, 0x070F, 0x0000 }, /* R4206  - Write Sequencer 110 */
+	[4207] = { 0x010F, 0x010F, 0x0000 }, /* R4207  - Write Sequencer 111 */
+	[4208] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4208  - Write Sequencer 112 */
+	[4209] = { 0x00FF, 0x00FF, 0x0000 }, /* R4209  - Write Sequencer 113 */
+	[4210] = { 0x070F, 0x070F, 0x0000 }, /* R4210  - Write Sequencer 114 */
+	[4211] = { 0x010F, 0x010F, 0x0000 }, /* R4211  - Write Sequencer 115 */
+	[4212] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4212  - Write Sequencer 116 */
+	[4213] = { 0x00FF, 0x00FF, 0x0000 }, /* R4213  - Write Sequencer 117 */
+	[4214] = { 0x070F, 0x070F, 0x0000 }, /* R4214  - Write Sequencer 118 */
+	[4215] = { 0x010F, 0x010F, 0x0000 }, /* R4215  - Write Sequencer 119 */
+	[4216] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4216  - Write Sequencer 120 */
+	[4217] = { 0x00FF, 0x00FF, 0x0000 }, /* R4217  - Write Sequencer 121 */
+	[4218] = { 0x070F, 0x070F, 0x0000 }, /* R4218  - Write Sequencer 122 */
+	[4219] = { 0x010F, 0x010F, 0x0000 }, /* R4219  - Write Sequencer 123 */
+	[4220] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4220  - Write Sequencer 124 */
+	[4221] = { 0x00FF, 0x00FF, 0x0000 }, /* R4221  - Write Sequencer 125 */
+	[4222] = { 0x070F, 0x070F, 0x0000 }, /* R4222  - Write Sequencer 126 */
+	[4223] = { 0x010F, 0x010F, 0x0000 }, /* R4223  - Write Sequencer 127 */
+	[4224] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4224  - Write Sequencer 128 */
+	[4225] = { 0x00FF, 0x00FF, 0x0000 }, /* R4225  - Write Sequencer 129 */
+	[4226] = { 0x070F, 0x070F, 0x0000 }, /* R4226  - Write Sequencer 130 */
+	[4227] = { 0x010F, 0x010F, 0x0000 }, /* R4227  - Write Sequencer 131 */
+	[4228] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4228  - Write Sequencer 132 */
+	[4229] = { 0x00FF, 0x00FF, 0x0000 }, /* R4229  - Write Sequencer 133 */
+	[4230] = { 0x070F, 0x070F, 0x0000 }, /* R4230  - Write Sequencer 134 */
+	[4231] = { 0x010F, 0x010F, 0x0000 }, /* R4231  - Write Sequencer 135 */
+	[4232] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4232  - Write Sequencer 136 */
+	[4233] = { 0x00FF, 0x00FF, 0x0000 }, /* R4233  - Write Sequencer 137 */
+	[4234] = { 0x070F, 0x070F, 0x0000 }, /* R4234  - Write Sequencer 138 */
+	[4235] = { 0x010F, 0x010F, 0x0000 }, /* R4235  - Write Sequencer 139 */
+	[4236] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4236  - Write Sequencer 140 */
+	[4237] = { 0x00FF, 0x00FF, 0x0000 }, /* R4237  - Write Sequencer 141 */
+	[4238] = { 0x070F, 0x070F, 0x0000 }, /* R4238  - Write Sequencer 142 */
+	[4239] = { 0x010F, 0x010F, 0x0000 }, /* R4239  - Write Sequencer 143 */
+	[4240] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4240  - Write Sequencer 144 */
+	[4241] = { 0x00FF, 0x00FF, 0x0000 }, /* R4241  - Write Sequencer 145 */
+	[4242] = { 0x070F, 0x070F, 0x0000 }, /* R4242  - Write Sequencer 146 */
+	[4243] = { 0x010F, 0x010F, 0x0000 }, /* R4243  - Write Sequencer 147 */
+	[4244] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4244  - Write Sequencer 148 */
+	[4245] = { 0x00FF, 0x00FF, 0x0000 }, /* R4245  - Write Sequencer 149 */
+	[4246] = { 0x070F, 0x070F, 0x0000 }, /* R4246  - Write Sequencer 150 */
+	[4247] = { 0x010F, 0x010F, 0x0000 }, /* R4247  - Write Sequencer 151 */
+	[4248] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4248  - Write Sequencer 152 */
+	[4249] = { 0x00FF, 0x00FF, 0x0000 }, /* R4249  - Write Sequencer 153 */
+	[4250] = { 0x070F, 0x070F, 0x0000 }, /* R4250  - Write Sequencer 154 */
+	[4251] = { 0x010F, 0x010F, 0x0000 }, /* R4251  - Write Sequencer 155 */
+	[4252] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4252  - Write Sequencer 156 */
+	[4253] = { 0x00FF, 0x00FF, 0x0000 }, /* R4253  - Write Sequencer 157 */
+	[4254] = { 0x070F, 0x070F, 0x0000 }, /* R4254  - Write Sequencer 158 */
+	[4255] = { 0x010F, 0x010F, 0x0000 }, /* R4255  - Write Sequencer 159 */
+	[4256] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4256  - Write Sequencer 160 */
+	[4257] = { 0x00FF, 0x00FF, 0x0000 }, /* R4257  - Write Sequencer 161 */
+	[4258] = { 0x070F, 0x070F, 0x0000 }, /* R4258  - Write Sequencer 162 */
+	[4259] = { 0x010F, 0x010F, 0x0000 }, /* R4259  - Write Sequencer 163 */
+	[4260] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4260  - Write Sequencer 164 */
+	[4261] = { 0x00FF, 0x00FF, 0x0000 }, /* R4261  - Write Sequencer 165 */
+	[4262] = { 0x070F, 0x070F, 0x0000 }, /* R4262  - Write Sequencer 166 */
+	[4263] = { 0x010F, 0x010F, 0x0000 }, /* R4263  - Write Sequencer 167 */
+	[4264] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4264  - Write Sequencer 168 */
+	[4265] = { 0x00FF, 0x00FF, 0x0000 }, /* R4265  - Write Sequencer 169 */
+	[4266] = { 0x070F, 0x070F, 0x0000 }, /* R4266  - Write Sequencer 170 */
+	[4267] = { 0x010F, 0x010F, 0x0000 }, /* R4267  - Write Sequencer 171 */
+	[4268] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4268  - Write Sequencer 172 */
+	[4269] = { 0x00FF, 0x00FF, 0x0000 }, /* R4269  - Write Sequencer 173 */
+	[4270] = { 0x070F, 0x070F, 0x0000 }, /* R4270  - Write Sequencer 174 */
+	[4271] = { 0x010F, 0x010F, 0x0000 }, /* R4271  - Write Sequencer 175 */
+	[4272] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4272  - Write Sequencer 176 */
+	[4273] = { 0x00FF, 0x00FF, 0x0000 }, /* R4273  - Write Sequencer 177 */
+	[4274] = { 0x070F, 0x070F, 0x0000 }, /* R4274  - Write Sequencer 178 */
+	[4275] = { 0x010F, 0x010F, 0x0000 }, /* R4275  - Write Sequencer 179 */
+	[4276] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4276  - Write Sequencer 180 */
+	[4277] = { 0x00FF, 0x00FF, 0x0000 }, /* R4277  - Write Sequencer 181 */
+	[4278] = { 0x070F, 0x070F, 0x0000 }, /* R4278  - Write Sequencer 182 */
+	[4279] = { 0x010F, 0x010F, 0x0000 }, /* R4279  - Write Sequencer 183 */
+	[4280] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4280  - Write Sequencer 184 */
+	[4281] = { 0x00FF, 0x00FF, 0x0000 }, /* R4281  - Write Sequencer 185 */
+	[4282] = { 0x070F, 0x070F, 0x0000 }, /* R4282  - Write Sequencer 186 */
+	[4283] = { 0x010F, 0x010F, 0x0000 }, /* R4283  - Write Sequencer 187 */
+	[4284] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4284  - Write Sequencer 188 */
+	[4285] = { 0x00FF, 0x00FF, 0x0000 }, /* R4285  - Write Sequencer 189 */
+	[4286] = { 0x070F, 0x070F, 0x0000 }, /* R4286  - Write Sequencer 190 */
+	[4287] = { 0x010F, 0x010F, 0x0000 }, /* R4287  - Write Sequencer 191 */
+	[4288] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4288  - Write Sequencer 192 */
+	[4289] = { 0x00FF, 0x00FF, 0x0000 }, /* R4289  - Write Sequencer 193 */
+	[4290] = { 0x070F, 0x070F, 0x0000 }, /* R4290  - Write Sequencer 194 */
+	[4291] = { 0x010F, 0x010F, 0x0000 }, /* R4291  - Write Sequencer 195 */
+	[4292] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4292  - Write Sequencer 196 */
+	[4293] = { 0x00FF, 0x00FF, 0x0000 }, /* R4293  - Write Sequencer 197 */
+	[4294] = { 0x070F, 0x070F, 0x0000 }, /* R4294  - Write Sequencer 198 */
+	[4295] = { 0x010F, 0x010F, 0x0000 }, /* R4295  - Write Sequencer 199 */
+	[4296] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4296  - Write Sequencer 200 */
+	[4297] = { 0x00FF, 0x00FF, 0x0000 }, /* R4297  - Write Sequencer 201 */
+	[4298] = { 0x070F, 0x070F, 0x0000 }, /* R4298  - Write Sequencer 202 */
+	[4299] = { 0x010F, 0x010F, 0x0000 }, /* R4299  - Write Sequencer 203 */
+	[4300] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4300  - Write Sequencer 204 */
+	[4301] = { 0x00FF, 0x00FF, 0x0000 }, /* R4301  - Write Sequencer 205 */
+	[4302] = { 0x070F, 0x070F, 0x0000 }, /* R4302  - Write Sequencer 206 */
+	[4303] = { 0x010F, 0x010F, 0x0000 }, /* R4303  - Write Sequencer 207 */
+	[4304] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4304  - Write Sequencer 208 */
+	[4305] = { 0x00FF, 0x00FF, 0x0000 }, /* R4305  - Write Sequencer 209 */
+	[4306] = { 0x070F, 0x070F, 0x0000 }, /* R4306  - Write Sequencer 210 */
+	[4307] = { 0x010F, 0x010F, 0x0000 }, /* R4307  - Write Sequencer 211 */
+	[4308] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4308  - Write Sequencer 212 */
+	[4309] = { 0x00FF, 0x00FF, 0x0000 }, /* R4309  - Write Sequencer 213 */
+	[4310] = { 0x070F, 0x070F, 0x0000 }, /* R4310  - Write Sequencer 214 */
+	[4311] = { 0x010F, 0x010F, 0x0000 }, /* R4311  - Write Sequencer 215 */
+	[4312] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4312  - Write Sequencer 216 */
+	[4313] = { 0x00FF, 0x00FF, 0x0000 }, /* R4313  - Write Sequencer 217 */
+	[4314] = { 0x070F, 0x070F, 0x0000 }, /* R4314  - Write Sequencer 218 */
+	[4315] = { 0x010F, 0x010F, 0x0000 }, /* R4315  - Write Sequencer 219 */
+	[4316] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4316  - Write Sequencer 220 */
+	[4317] = { 0x00FF, 0x00FF, 0x0000 }, /* R4317  - Write Sequencer 221 */
+	[4318] = { 0x070F, 0x070F, 0x0000 }, /* R4318  - Write Sequencer 222 */
+	[4319] = { 0x010F, 0x010F, 0x0000 }, /* R4319  - Write Sequencer 223 */
+	[4320] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4320  - Write Sequencer 224 */
+	[4321] = { 0x00FF, 0x00FF, 0x0000 }, /* R4321  - Write Sequencer 225 */
+	[4322] = { 0x070F, 0x070F, 0x0000 }, /* R4322  - Write Sequencer 226 */
+	[4323] = { 0x010F, 0x010F, 0x0000 }, /* R4323  - Write Sequencer 227 */
+	[4324] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4324  - Write Sequencer 228 */
+	[4325] = { 0x00FF, 0x00FF, 0x0000 }, /* R4325  - Write Sequencer 229 */
+	[4326] = { 0x070F, 0x070F, 0x0000 }, /* R4326  - Write Sequencer 230 */
+	[4327] = { 0x010F, 0x010F, 0x0000 }, /* R4327  - Write Sequencer 231 */
+	[4328] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4328  - Write Sequencer 232 */
+	[4329] = { 0x00FF, 0x00FF, 0x0000 }, /* R4329  - Write Sequencer 233 */
+	[4330] = { 0x070F, 0x070F, 0x0000 }, /* R4330  - Write Sequencer 234 */
+	[4331] = { 0x010F, 0x010F, 0x0000 }, /* R4331  - Write Sequencer 235 */
+	[4332] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4332  - Write Sequencer 236 */
+	[4333] = { 0x00FF, 0x00FF, 0x0000 }, /* R4333  - Write Sequencer 237 */
+	[4334] = { 0x070F, 0x070F, 0x0000 }, /* R4334  - Write Sequencer 238 */
+	[4335] = { 0x010F, 0x010F, 0x0000 }, /* R4335  - Write Sequencer 239 */
+	[4336] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4336  - Write Sequencer 240 */
+	[4337] = { 0x00FF, 0x00FF, 0x0000 }, /* R4337  - Write Sequencer 241 */
+	[4338] = { 0x070F, 0x070F, 0x0000 }, /* R4338  - Write Sequencer 242 */
+	[4339] = { 0x010F, 0x010F, 0x0000 }, /* R4339  - Write Sequencer 243 */
+	[4340] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4340  - Write Sequencer 244 */
+	[4341] = { 0x00FF, 0x00FF, 0x0000 }, /* R4341  - Write Sequencer 245 */
+	[4342] = { 0x070F, 0x070F, 0x0000 }, /* R4342  - Write Sequencer 246 */
+	[4343] = { 0x010F, 0x010F, 0x0000 }, /* R4343  - Write Sequencer 247 */
+	[4344] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4344  - Write Sequencer 248 */
+	[4345] = { 0x00FF, 0x00FF, 0x0000 }, /* R4345  - Write Sequencer 249 */
+	[4346] = { 0x070F, 0x070F, 0x0000 }, /* R4346  - Write Sequencer 250 */
+	[4347] = { 0x010F, 0x010F, 0x0000 }, /* R4347  - Write Sequencer 251 */
+	[4348] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4348  - Write Sequencer 252 */
+	[4349] = { 0x00FF, 0x00FF, 0x0000 }, /* R4349  - Write Sequencer 253 */
+	[4350] = { 0x070F, 0x070F, 0x0000 }, /* R4350  - Write Sequencer 254 */
+	[4351] = { 0x010F, 0x010F, 0x0000 }, /* R4351  - Write Sequencer 255 */
+	[4352] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4352  - Write Sequencer 256 */
+	[4353] = { 0x00FF, 0x00FF, 0x0000 }, /* R4353  - Write Sequencer 257 */
+	[4354] = { 0x070F, 0x070F, 0x0000 }, /* R4354  - Write Sequencer 258 */
+	[4355] = { 0x010F, 0x010F, 0x0000 }, /* R4355  - Write Sequencer 259 */
+	[4356] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4356  - Write Sequencer 260 */
+	[4357] = { 0x00FF, 0x00FF, 0x0000 }, /* R4357  - Write Sequencer 261 */
+	[4358] = { 0x070F, 0x070F, 0x0000 }, /* R4358  - Write Sequencer 262 */
+	[4359] = { 0x010F, 0x010F, 0x0000 }, /* R4359  - Write Sequencer 263 */
+	[4360] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4360  - Write Sequencer 264 */
+	[4361] = { 0x00FF, 0x00FF, 0x0000 }, /* R4361  - Write Sequencer 265 */
+	[4362] = { 0x070F, 0x070F, 0x0000 }, /* R4362  - Write Sequencer 266 */
+	[4363] = { 0x010F, 0x010F, 0x0000 }, /* R4363  - Write Sequencer 267 */
+	[4364] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4364  - Write Sequencer 268 */
+	[4365] = { 0x00FF, 0x00FF, 0x0000 }, /* R4365  - Write Sequencer 269 */
+	[4366] = { 0x070F, 0x070F, 0x0000 }, /* R4366  - Write Sequencer 270 */
+	[4367] = { 0x010F, 0x010F, 0x0000 }, /* R4367  - Write Sequencer 271 */
+	[4368] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4368  - Write Sequencer 272 */
+	[4369] = { 0x00FF, 0x00FF, 0x0000 }, /* R4369  - Write Sequencer 273 */
+	[4370] = { 0x070F, 0x070F, 0x0000 }, /* R4370  - Write Sequencer 274 */
+	[4371] = { 0x010F, 0x010F, 0x0000 }, /* R4371  - Write Sequencer 275 */
+	[4372] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4372  - Write Sequencer 276 */
+	[4373] = { 0x00FF, 0x00FF, 0x0000 }, /* R4373  - Write Sequencer 277 */
+	[4374] = { 0x070F, 0x070F, 0x0000 }, /* R4374  - Write Sequencer 278 */
+	[4375] = { 0x010F, 0x010F, 0x0000 }, /* R4375  - Write Sequencer 279 */
+	[4376] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4376  - Write Sequencer 280 */
+	[4377] = { 0x00FF, 0x00FF, 0x0000 }, /* R4377  - Write Sequencer 281 */
+	[4378] = { 0x070F, 0x070F, 0x0000 }, /* R4378  - Write Sequencer 282 */
+	[4379] = { 0x010F, 0x010F, 0x0000 }, /* R4379  - Write Sequencer 283 */
+	[4380] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4380  - Write Sequencer 284 */
+	[4381] = { 0x00FF, 0x00FF, 0x0000 }, /* R4381  - Write Sequencer 285 */
+	[4382] = { 0x070F, 0x070F, 0x0000 }, /* R4382  - Write Sequencer 286 */
+	[4383] = { 0x010F, 0x010F, 0x0000 }, /* R4383  - Write Sequencer 287 */
+	[4384] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4384  - Write Sequencer 288 */
+	[4385] = { 0x00FF, 0x00FF, 0x0000 }, /* R4385  - Write Sequencer 289 */
+	[4386] = { 0x070F, 0x070F, 0x0000 }, /* R4386  - Write Sequencer 290 */
+	[4387] = { 0x010F, 0x010F, 0x0000 }, /* R4387  - Write Sequencer 291 */
+	[4388] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4388  - Write Sequencer 292 */
+	[4389] = { 0x00FF, 0x00FF, 0x0000 }, /* R4389  - Write Sequencer 293 */
+	[4390] = { 0x070F, 0x070F, 0x0000 }, /* R4390  - Write Sequencer 294 */
+	[4391] = { 0x010F, 0x010F, 0x0000 }, /* R4391  - Write Sequencer 295 */
+	[4392] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4392  - Write Sequencer 296 */
+	[4393] = { 0x00FF, 0x00FF, 0x0000 }, /* R4393  - Write Sequencer 297 */
+	[4394] = { 0x070F, 0x070F, 0x0000 }, /* R4394  - Write Sequencer 298 */
+	[4395] = { 0x010F, 0x010F, 0x0000 }, /* R4395  - Write Sequencer 299 */
+	[4396] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4396  - Write Sequencer 300 */
+	[4397] = { 0x00FF, 0x00FF, 0x0000 }, /* R4397  - Write Sequencer 301 */
+	[4398] = { 0x070F, 0x070F, 0x0000 }, /* R4398  - Write Sequencer 302 */
+	[4399] = { 0x010F, 0x010F, 0x0000 }, /* R4399  - Write Sequencer 303 */
+	[4400] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4400  - Write Sequencer 304 */
+	[4401] = { 0x00FF, 0x00FF, 0x0000 }, /* R4401  - Write Sequencer 305 */
+	[4402] = { 0x070F, 0x070F, 0x0000 }, /* R4402  - Write Sequencer 306 */
+	[4403] = { 0x010F, 0x010F, 0x0000 }, /* R4403  - Write Sequencer 307 */
+	[4404] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4404  - Write Sequencer 308 */
+	[4405] = { 0x00FF, 0x00FF, 0x0000 }, /* R4405  - Write Sequencer 309 */
+	[4406] = { 0x070F, 0x070F, 0x0000 }, /* R4406  - Write Sequencer 310 */
+	[4407] = { 0x010F, 0x010F, 0x0000 }, /* R4407  - Write Sequencer 311 */
+	[4408] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4408  - Write Sequencer 312 */
+	[4409] = { 0x00FF, 0x00FF, 0x0000 }, /* R4409  - Write Sequencer 313 */
+	[4410] = { 0x070F, 0x070F, 0x0000 }, /* R4410  - Write Sequencer 314 */
+	[4411] = { 0x010F, 0x010F, 0x0000 }, /* R4411  - Write Sequencer 315 */
+	[4412] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4412  - Write Sequencer 316 */
+	[4413] = { 0x00FF, 0x00FF, 0x0000 }, /* R4413  - Write Sequencer 317 */
+	[4414] = { 0x070F, 0x070F, 0x0000 }, /* R4414  - Write Sequencer 318 */
+	[4415] = { 0x010F, 0x010F, 0x0000 }, /* R4415  - Write Sequencer 319 */
+	[4416] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4416  - Write Sequencer 320 */
+	[4417] = { 0x00FF, 0x00FF, 0x0000 }, /* R4417  - Write Sequencer 321 */
+	[4418] = { 0x070F, 0x070F, 0x0000 }, /* R4418  - Write Sequencer 322 */
+	[4419] = { 0x010F, 0x010F, 0x0000 }, /* R4419  - Write Sequencer 323 */
+	[4420] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4420  - Write Sequencer 324 */
+	[4421] = { 0x00FF, 0x00FF, 0x0000 }, /* R4421  - Write Sequencer 325 */
+	[4422] = { 0x070F, 0x070F, 0x0000 }, /* R4422  - Write Sequencer 326 */
+	[4423] = { 0x010F, 0x010F, 0x0000 }, /* R4423  - Write Sequencer 327 */
+	[4424] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4424  - Write Sequencer 328 */
+	[4425] = { 0x00FF, 0x00FF, 0x0000 }, /* R4425  - Write Sequencer 329 */
+	[4426] = { 0x070F, 0x070F, 0x0000 }, /* R4426  - Write Sequencer 330 */
+	[4427] = { 0x010F, 0x010F, 0x0000 }, /* R4427  - Write Sequencer 331 */
+	[4428] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4428  - Write Sequencer 332 */
+	[4429] = { 0x00FF, 0x00FF, 0x0000 }, /* R4429  - Write Sequencer 333 */
+	[4430] = { 0x070F, 0x070F, 0x0000 }, /* R4430  - Write Sequencer 334 */
+	[4431] = { 0x010F, 0x010F, 0x0000 }, /* R4431  - Write Sequencer 335 */
+	[4432] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4432  - Write Sequencer 336 */
+	[4433] = { 0x00FF, 0x00FF, 0x0000 }, /* R4433  - Write Sequencer 337 */
+	[4434] = { 0x070F, 0x070F, 0x0000 }, /* R4434  - Write Sequencer 338 */
+	[4435] = { 0x010F, 0x010F, 0x0000 }, /* R4435  - Write Sequencer 339 */
+	[4436] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4436  - Write Sequencer 340 */
+	[4437] = { 0x00FF, 0x00FF, 0x0000 }, /* R4437  - Write Sequencer 341 */
+	[4438] = { 0x070F, 0x070F, 0x0000 }, /* R4438  - Write Sequencer 342 */
+	[4439] = { 0x010F, 0x010F, 0x0000 }, /* R4439  - Write Sequencer 343 */
+	[4440] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4440  - Write Sequencer 344 */
+	[4441] = { 0x00FF, 0x00FF, 0x0000 }, /* R4441  - Write Sequencer 345 */
+	[4442] = { 0x070F, 0x070F, 0x0000 }, /* R4442  - Write Sequencer 346 */
+	[4443] = { 0x010F, 0x010F, 0x0000 }, /* R4443  - Write Sequencer 347 */
+	[4444] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4444  - Write Sequencer 348 */
+	[4445] = { 0x00FF, 0x00FF, 0x0000 }, /* R4445  - Write Sequencer 349 */
+	[4446] = { 0x070F, 0x070F, 0x0000 }, /* R4446  - Write Sequencer 350 */
+	[4447] = { 0x010F, 0x010F, 0x0000 }, /* R4447  - Write Sequencer 351 */
+	[4448] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4448  - Write Sequencer 352 */
+	[4449] = { 0x00FF, 0x00FF, 0x0000 }, /* R4449  - Write Sequencer 353 */
+	[4450] = { 0x070F, 0x070F, 0x0000 }, /* R4450  - Write Sequencer 354 */
+	[4451] = { 0x010F, 0x010F, 0x0000 }, /* R4451  - Write Sequencer 355 */
+	[4452] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4452  - Write Sequencer 356 */
+	[4453] = { 0x00FF, 0x00FF, 0x0000 }, /* R4453  - Write Sequencer 357 */
+	[4454] = { 0x070F, 0x070F, 0x0000 }, /* R4454  - Write Sequencer 358 */
+	[4455] = { 0x010F, 0x010F, 0x0000 }, /* R4455  - Write Sequencer 359 */
+	[4456] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4456  - Write Sequencer 360 */
+	[4457] = { 0x00FF, 0x00FF, 0x0000 }, /* R4457  - Write Sequencer 361 */
+	[4458] = { 0x070F, 0x070F, 0x0000 }, /* R4458  - Write Sequencer 362 */
+	[4459] = { 0x010F, 0x010F, 0x0000 }, /* R4459  - Write Sequencer 363 */
+	[4460] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4460  - Write Sequencer 364 */
+	[4461] = { 0x00FF, 0x00FF, 0x0000 }, /* R4461  - Write Sequencer 365 */
+	[4462] = { 0x070F, 0x070F, 0x0000 }, /* R4462  - Write Sequencer 366 */
+	[4463] = { 0x010F, 0x010F, 0x0000 }, /* R4463  - Write Sequencer 367 */
+	[4464] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4464  - Write Sequencer 368 */
+	[4465] = { 0x00FF, 0x00FF, 0x0000 }, /* R4465  - Write Sequencer 369 */
+	[4466] = { 0x070F, 0x070F, 0x0000 }, /* R4466  - Write Sequencer 370 */
+	[4467] = { 0x010F, 0x010F, 0x0000 }, /* R4467  - Write Sequencer 371 */
+	[4468] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4468  - Write Sequencer 372 */
+	[4469] = { 0x00FF, 0x00FF, 0x0000 }, /* R4469  - Write Sequencer 373 */
+	[4470] = { 0x070F, 0x070F, 0x0000 }, /* R4470  - Write Sequencer 374 */
+	[4471] = { 0x010F, 0x010F, 0x0000 }, /* R4471  - Write Sequencer 375 */
+	[4472] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4472  - Write Sequencer 376 */
+	[4473] = { 0x00FF, 0x00FF, 0x0000 }, /* R4473  - Write Sequencer 377 */
+	[4474] = { 0x070F, 0x070F, 0x0000 }, /* R4474  - Write Sequencer 378 */
+	[4475] = { 0x010F, 0x010F, 0x0000 }, /* R4475  - Write Sequencer 379 */
+	[4476] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4476  - Write Sequencer 380 */
+	[4477] = { 0x00FF, 0x00FF, 0x0000 }, /* R4477  - Write Sequencer 381 */
+	[4478] = { 0x070F, 0x070F, 0x0000 }, /* R4478  - Write Sequencer 382 */
+	[4479] = { 0x010F, 0x010F, 0x0000 }, /* R4479  - Write Sequencer 383 */
+	[4480] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4480  - Write Sequencer 384 */
+	[4481] = { 0x00FF, 0x00FF, 0x0000 }, /* R4481  - Write Sequencer 385 */
+	[4482] = { 0x070F, 0x070F, 0x0000 }, /* R4482  - Write Sequencer 386 */
+	[4483] = { 0x010F, 0x010F, 0x0000 }, /* R4483  - Write Sequencer 387 */
+	[4484] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4484  - Write Sequencer 388 */
+	[4485] = { 0x00FF, 0x00FF, 0x0000 }, /* R4485  - Write Sequencer 389 */
+	[4486] = { 0x070F, 0x070F, 0x0000 }, /* R4486  - Write Sequencer 390 */
+	[4487] = { 0x010F, 0x010F, 0x0000 }, /* R4487  - Write Sequencer 391 */
+	[4488] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4488  - Write Sequencer 392 */
+	[4489] = { 0x00FF, 0x00FF, 0x0000 }, /* R4489  - Write Sequencer 393 */
+	[4490] = { 0x070F, 0x070F, 0x0000 }, /* R4490  - Write Sequencer 394 */
+	[4491] = { 0x010F, 0x010F, 0x0000 }, /* R4491  - Write Sequencer 395 */
+	[4492] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4492  - Write Sequencer 396 */
+	[4493] = { 0x00FF, 0x00FF, 0x0000 }, /* R4493  - Write Sequencer 397 */
+	[4494] = { 0x070F, 0x070F, 0x0000 }, /* R4494  - Write Sequencer 398 */
+	[4495] = { 0x010F, 0x010F, 0x0000 }, /* R4495  - Write Sequencer 399 */
+	[4496] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4496  - Write Sequencer 400 */
+	[4497] = { 0x00FF, 0x00FF, 0x0000 }, /* R4497  - Write Sequencer 401 */
+	[4498] = { 0x070F, 0x070F, 0x0000 }, /* R4498  - Write Sequencer 402 */
+	[4499] = { 0x010F, 0x010F, 0x0000 }, /* R4499  - Write Sequencer 403 */
+	[4500] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4500  - Write Sequencer 404 */
+	[4501] = { 0x00FF, 0x00FF, 0x0000 }, /* R4501  - Write Sequencer 405 */
+	[4502] = { 0x070F, 0x070F, 0x0000 }, /* R4502  - Write Sequencer 406 */
+	[4503] = { 0x010F, 0x010F, 0x0000 }, /* R4503  - Write Sequencer 407 */
+	[4504] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4504  - Write Sequencer 408 */
+	[4505] = { 0x00FF, 0x00FF, 0x0000 }, /* R4505  - Write Sequencer 409 */
+	[4506] = { 0x070F, 0x070F, 0x0000 }, /* R4506  - Write Sequencer 410 */
+	[4507] = { 0x010F, 0x010F, 0x0000 }, /* R4507  - Write Sequencer 411 */
+	[4508] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4508  - Write Sequencer 412 */
+	[4509] = { 0x00FF, 0x00FF, 0x0000 }, /* R4509  - Write Sequencer 413 */
+	[4510] = { 0x070F, 0x070F, 0x0000 }, /* R4510  - Write Sequencer 414 */
+	[4511] = { 0x010F, 0x010F, 0x0000 }, /* R4511  - Write Sequencer 415 */
+	[4512] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4512  - Write Sequencer 416 */
+	[4513] = { 0x00FF, 0x00FF, 0x0000 }, /* R4513  - Write Sequencer 417 */
+	[4514] = { 0x070F, 0x070F, 0x0000 }, /* R4514  - Write Sequencer 418 */
+	[4515] = { 0x010F, 0x010F, 0x0000 }, /* R4515  - Write Sequencer 419 */
+	[4516] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4516  - Write Sequencer 420 */
+	[4517] = { 0x00FF, 0x00FF, 0x0000 }, /* R4517  - Write Sequencer 421 */
+	[4518] = { 0x070F, 0x070F, 0x0000 }, /* R4518  - Write Sequencer 422 */
+	[4519] = { 0x010F, 0x010F, 0x0000 }, /* R4519  - Write Sequencer 423 */
+	[4520] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4520  - Write Sequencer 424 */
+	[4521] = { 0x00FF, 0x00FF, 0x0000 }, /* R4521  - Write Sequencer 425 */
+	[4522] = { 0x070F, 0x070F, 0x0000 }, /* R4522  - Write Sequencer 426 */
+	[4523] = { 0x010F, 0x010F, 0x0000 }, /* R4523  - Write Sequencer 427 */
+	[4524] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4524  - Write Sequencer 428 */
+	[4525] = { 0x00FF, 0x00FF, 0x0000 }, /* R4525  - Write Sequencer 429 */
+	[4526] = { 0x070F, 0x070F, 0x0000 }, /* R4526  - Write Sequencer 430 */
+	[4527] = { 0x010F, 0x010F, 0x0000 }, /* R4527  - Write Sequencer 431 */
+	[4528] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4528  - Write Sequencer 432 */
+	[4529] = { 0x00FF, 0x00FF, 0x0000 }, /* R4529  - Write Sequencer 433 */
+	[4530] = { 0x070F, 0x070F, 0x0000 }, /* R4530  - Write Sequencer 434 */
+	[4531] = { 0x010F, 0x010F, 0x0000 }, /* R4531  - Write Sequencer 435 */
+	[4532] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4532  - Write Sequencer 436 */
+	[4533] = { 0x00FF, 0x00FF, 0x0000 }, /* R4533  - Write Sequencer 437 */
+	[4534] = { 0x070F, 0x070F, 0x0000 }, /* R4534  - Write Sequencer 438 */
+	[4535] = { 0x010F, 0x010F, 0x0000 }, /* R4535  - Write Sequencer 439 */
+	[4536] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4536  - Write Sequencer 440 */
+	[4537] = { 0x00FF, 0x00FF, 0x0000 }, /* R4537  - Write Sequencer 441 */
+	[4538] = { 0x070F, 0x070F, 0x0000 }, /* R4538  - Write Sequencer 442 */
+	[4539] = { 0x010F, 0x010F, 0x0000 }, /* R4539  - Write Sequencer 443 */
+	[4540] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4540  - Write Sequencer 444 */
+	[4541] = { 0x00FF, 0x00FF, 0x0000 }, /* R4541  - Write Sequencer 445 */
+	[4542] = { 0x070F, 0x070F, 0x0000 }, /* R4542  - Write Sequencer 446 */
+	[4543] = { 0x010F, 0x010F, 0x0000 }, /* R4543  - Write Sequencer 447 */
+	[4544] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4544  - Write Sequencer 448 */
+	[4545] = { 0x00FF, 0x00FF, 0x0000 }, /* R4545  - Write Sequencer 449 */
+	[4546] = { 0x070F, 0x070F, 0x0000 }, /* R4546  - Write Sequencer 450 */
+	[4547] = { 0x010F, 0x010F, 0x0000 }, /* R4547  - Write Sequencer 451 */
+	[4548] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4548  - Write Sequencer 452 */
+	[4549] = { 0x00FF, 0x00FF, 0x0000 }, /* R4549  - Write Sequencer 453 */
+	[4550] = { 0x070F, 0x070F, 0x0000 }, /* R4550  - Write Sequencer 454 */
+	[4551] = { 0x010F, 0x010F, 0x0000 }, /* R4551  - Write Sequencer 455 */
+	[4552] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4552  - Write Sequencer 456 */
+	[4553] = { 0x00FF, 0x00FF, 0x0000 }, /* R4553  - Write Sequencer 457 */
+	[4554] = { 0x070F, 0x070F, 0x0000 }, /* R4554  - Write Sequencer 458 */
+	[4555] = { 0x010F, 0x010F, 0x0000 }, /* R4555  - Write Sequencer 459 */
+	[4556] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4556  - Write Sequencer 460 */
+	[4557] = { 0x00FF, 0x00FF, 0x0000 }, /* R4557  - Write Sequencer 461 */
+	[4558] = { 0x070F, 0x070F, 0x0000 }, /* R4558  - Write Sequencer 462 */
+	[4559] = { 0x010F, 0x010F, 0x0000 }, /* R4559  - Write Sequencer 463 */
+	[4560] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4560  - Write Sequencer 464 */
+	[4561] = { 0x00FF, 0x00FF, 0x0000 }, /* R4561  - Write Sequencer 465 */
+	[4562] = { 0x070F, 0x070F, 0x0000 }, /* R4562  - Write Sequencer 466 */
+	[4563] = { 0x010F, 0x010F, 0x0000 }, /* R4563  - Write Sequencer 467 */
+	[4564] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4564  - Write Sequencer 468 */
+	[4565] = { 0x00FF, 0x00FF, 0x0000 }, /* R4565  - Write Sequencer 469 */
+	[4566] = { 0x070F, 0x070F, 0x0000 }, /* R4566  - Write Sequencer 470 */
+	[4567] = { 0x010F, 0x010F, 0x0000 }, /* R4567  - Write Sequencer 471 */
+	[4568] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4568  - Write Sequencer 472 */
+	[4569] = { 0x00FF, 0x00FF, 0x0000 }, /* R4569  - Write Sequencer 473 */
+	[4570] = { 0x070F, 0x070F, 0x0000 }, /* R4570  - Write Sequencer 474 */
+	[4571] = { 0x010F, 0x010F, 0x0000 }, /* R4571  - Write Sequencer 475 */
+	[4572] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4572  - Write Sequencer 476 */
+	[4573] = { 0x00FF, 0x00FF, 0x0000 }, /* R4573  - Write Sequencer 477 */
+	[4574] = { 0x070F, 0x070F, 0x0000 }, /* R4574  - Write Sequencer 478 */
+	[4575] = { 0x010F, 0x010F, 0x0000 }, /* R4575  - Write Sequencer 479 */
+	[4576] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4576  - Write Sequencer 480 */
+	[4577] = { 0x00FF, 0x00FF, 0x0000 }, /* R4577  - Write Sequencer 481 */
+	[4578] = { 0x070F, 0x070F, 0x0000 }, /* R4578  - Write Sequencer 482 */
+	[4579] = { 0x010F, 0x010F, 0x0000 }, /* R4579  - Write Sequencer 483 */
+	[4580] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4580  - Write Sequencer 484 */
+	[4581] = { 0x00FF, 0x00FF, 0x0000 }, /* R4581  - Write Sequencer 485 */
+	[4582] = { 0x070F, 0x070F, 0x0000 }, /* R4582  - Write Sequencer 486 */
+	[4583] = { 0x010F, 0x010F, 0x0000 }, /* R4583  - Write Sequencer 487 */
+	[4584] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4584  - Write Sequencer 488 */
+	[4585] = { 0x00FF, 0x00FF, 0x0000 }, /* R4585  - Write Sequencer 489 */
+	[4586] = { 0x070F, 0x070F, 0x0000 }, /* R4586  - Write Sequencer 490 */
+	[4587] = { 0x010F, 0x010F, 0x0000 }, /* R4587  - Write Sequencer 491 */
+	[4588] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4588  - Write Sequencer 492 */
+	[4589] = { 0x00FF, 0x00FF, 0x0000 }, /* R4589  - Write Sequencer 493 */
+	[4590] = { 0x070F, 0x070F, 0x0000 }, /* R4590  - Write Sequencer 494 */
+	[4591] = { 0x010F, 0x010F, 0x0000 }, /* R4591  - Write Sequencer 495 */
+	[4592] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4592  - Write Sequencer 496 */
+	[4593] = { 0x00FF, 0x00FF, 0x0000 }, /* R4593  - Write Sequencer 497 */
+	[4594] = { 0x070F, 0x070F, 0x0000 }, /* R4594  - Write Sequencer 498 */
+	[4595] = { 0x010F, 0x010F, 0x0000 }, /* R4595  - Write Sequencer 499 */
+	[4596] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4596  - Write Sequencer 500 */
+	[4597] = { 0x00FF, 0x00FF, 0x0000 }, /* R4597  - Write Sequencer 501 */
+	[4598] = { 0x070F, 0x070F, 0x0000 }, /* R4598  - Write Sequencer 502 */
+	[4599] = { 0x010F, 0x010F, 0x0000 }, /* R4599  - Write Sequencer 503 */
+	[4600] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4600  - Write Sequencer 504 */
+	[4601] = { 0x00FF, 0x00FF, 0x0000 }, /* R4601  - Write Sequencer 505 */
+	[4602] = { 0x070F, 0x070F, 0x0000 }, /* R4602  - Write Sequencer 506 */
+	[4603] = { 0x010F, 0x010F, 0x0000 }, /* R4603  - Write Sequencer 507 */
+	[4604] = { 0x3FFF, 0x3FFF, 0x0000 }, /* R4604  - Write Sequencer 508 */
+	[4605] = { 0x00FF, 0x00FF, 0x0000 }, /* R4605  - Write Sequencer 509 */
+	[4606] = { 0x070F, 0x070F, 0x0000 }, /* R4606  - Write Sequencer 510 */
+	[4607] = { 0x010F, 0x010F, 0x0000 }, /* R4607  - Write Sequencer 511 */
+	[8192] = { 0x03FF, 0x03FF, 0x0000 }, /* R8192  - DSP2 Instruction RAM 0 */
+	[9216] = { 0x003F, 0x003F, 0x0000 }, /* R9216  - DSP2 Address RAM 2 */
+	[9217] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R9217  - DSP2 Address RAM 1 */
+	[9218] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R9218  - DSP2 Address RAM 0 */
+	[12288] = { 0x00FF, 0x00FF, 0x0000 }, /* R12288 - DSP2 Data1 RAM 1 */
+	[12289] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R12289 - DSP2 Data1 RAM 0 */
+	[13312] = { 0x00FF, 0x00FF, 0x0000 }, /* R13312 - DSP2 Data2 RAM 1 */
+	[13313] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R13313 - DSP2 Data2 RAM 0 */
+	[14336] = { 0x00FF, 0x00FF, 0x0000 }, /* R14336 - DSP2 Data3 RAM 1 */
+	[14337] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R14337 - DSP2 Data3 RAM 0 */
+	[15360] = { 0x07FF, 0x07FF, 0x0000 }, /* R15360 - DSP2 Coeff RAM 0 */
+	[16384] = { 0x00FF, 0x00FF, 0x0000 }, /* R16384 - RETUNEADC_SHARED_COEFF_1 */
+	[16385] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16385 - RETUNEADC_SHARED_COEFF_0 */
+	[16386] = { 0x00FF, 0x00FF, 0x0000 }, /* R16386 - RETUNEDAC_SHARED_COEFF_1 */
+	[16387] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16387 - RETUNEDAC_SHARED_COEFF_0 */
+	[16388] = { 0x00FF, 0x00FF, 0x0000 }, /* R16388 - SOUNDSTAGE_ENABLES_1 */
+	[16389] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16389 - SOUNDSTAGE_ENABLES_0 */
+	[16896] = { 0x00FF, 0x00FF, 0x0000 }, /* R16896 - HDBASS_AI_1 */
+	[16897] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16897 - HDBASS_AI_0 */
+	[16898] = { 0x00FF, 0x00FF, 0x0000 }, /* R16898 - HDBASS_AR_1 */
+	[16899] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16899 - HDBASS_AR_0 */
+	[16900] = { 0x00FF, 0x00FF, 0x0000 }, /* R16900 - HDBASS_B_1 */
+	[16901] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16901 - HDBASS_B_0 */
+	[16902] = { 0x00FF, 0x00FF, 0x0000 }, /* R16902 - HDBASS_K_1 */
+	[16903] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16903 - HDBASS_K_0 */
+	[16904] = { 0x00FF, 0x00FF, 0x0000 }, /* R16904 - HDBASS_N1_1 */
+	[16905] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16905 - HDBASS_N1_0 */
+	[16906] = { 0x00FF, 0x00FF, 0x0000 }, /* R16906 - HDBASS_N2_1 */
+	[16907] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16907 - HDBASS_N2_0 */
+	[16908] = { 0x00FF, 0x00FF, 0x0000 }, /* R16908 - HDBASS_N3_1 */
+	[16909] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16909 - HDBASS_N3_0 */
+	[16910] = { 0x00FF, 0x00FF, 0x0000 }, /* R16910 - HDBASS_N4_1 */
+	[16911] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16911 - HDBASS_N4_0 */
+	[16912] = { 0x00FF, 0x00FF, 0x0000 }, /* R16912 - HDBASS_N5_1 */
+	[16913] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16913 - HDBASS_N5_0 */
+	[16914] = { 0x00FF, 0x00FF, 0x0000 }, /* R16914 - HDBASS_X1_1 */
+	[16915] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16915 - HDBASS_X1_0 */
+	[16916] = { 0x00FF, 0x00FF, 0x0000 }, /* R16916 - HDBASS_X2_1 */
+	[16917] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16917 - HDBASS_X2_0 */
+	[16918] = { 0x00FF, 0x00FF, 0x0000 }, /* R16918 - HDBASS_X3_1 */
+	[16919] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16919 - HDBASS_X3_0 */
+	[16920] = { 0x00FF, 0x00FF, 0x0000 }, /* R16920 - HDBASS_ATK_1 */
+	[16921] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16921 - HDBASS_ATK_0 */
+	[16922] = { 0x00FF, 0x00FF, 0x0000 }, /* R16922 - HDBASS_DCY_1 */
+	[16923] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16923 - HDBASS_DCY_0 */
+	[16924] = { 0x00FF, 0x00FF, 0x0000 }, /* R16924 - HDBASS_PG_1 */
+	[16925] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R16925 - HDBASS_PG_0 */
+	[17408] = { 0x00FF, 0x00FF, 0x0000 }, /* R17408 - HPF_C_1 */
+	[17409] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17409 - HPF_C_0 */
+	[17920] = { 0x00FF, 0x00FF, 0x0000 }, /* R17920 - ADCL_RETUNE_C1_1 */
+	[17921] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17921 - ADCL_RETUNE_C1_0 */
+	[17922] = { 0x00FF, 0x00FF, 0x0000 }, /* R17922 - ADCL_RETUNE_C2_1 */
+	[17923] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17923 - ADCL_RETUNE_C2_0 */
+	[17924] = { 0x00FF, 0x00FF, 0x0000 }, /* R17924 - ADCL_RETUNE_C3_1 */
+	[17925] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17925 - ADCL_RETUNE_C3_0 */
+	[17926] = { 0x00FF, 0x00FF, 0x0000 }, /* R17926 - ADCL_RETUNE_C4_1 */
+	[17927] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17927 - ADCL_RETUNE_C4_0 */
+	[17928] = { 0x00FF, 0x00FF, 0x0000 }, /* R17928 - ADCL_RETUNE_C5_1 */
+	[17929] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17929 - ADCL_RETUNE_C5_0 */
+	[17930] = { 0x00FF, 0x00FF, 0x0000 }, /* R17930 - ADCL_RETUNE_C6_1 */
+	[17931] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17931 - ADCL_RETUNE_C6_0 */
+	[17932] = { 0x00FF, 0x00FF, 0x0000 }, /* R17932 - ADCL_RETUNE_C7_1 */
+	[17933] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17933 - ADCL_RETUNE_C7_0 */
+	[17934] = { 0x00FF, 0x00FF, 0x0000 }, /* R17934 - ADCL_RETUNE_C8_1 */
+	[17935] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17935 - ADCL_RETUNE_C8_0 */
+	[17936] = { 0x00FF, 0x00FF, 0x0000 }, /* R17936 - ADCL_RETUNE_C9_1 */
+	[17937] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17937 - ADCL_RETUNE_C9_0 */
+	[17938] = { 0x00FF, 0x00FF, 0x0000 }, /* R17938 - ADCL_RETUNE_C10_1 */
+	[17939] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17939 - ADCL_RETUNE_C10_0 */
+	[17940] = { 0x00FF, 0x00FF, 0x0000 }, /* R17940 - ADCL_RETUNE_C11_1 */
+	[17941] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17941 - ADCL_RETUNE_C11_0 */
+	[17942] = { 0x00FF, 0x00FF, 0x0000 }, /* R17942 - ADCL_RETUNE_C12_1 */
+	[17943] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17943 - ADCL_RETUNE_C12_0 */
+	[17944] = { 0x00FF, 0x00FF, 0x0000 }, /* R17944 - ADCL_RETUNE_C13_1 */
+	[17945] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17945 - ADCL_RETUNE_C13_0 */
+	[17946] = { 0x00FF, 0x00FF, 0x0000 }, /* R17946 - ADCL_RETUNE_C14_1 */
+	[17947] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17947 - ADCL_RETUNE_C14_0 */
+	[17948] = { 0x00FF, 0x00FF, 0x0000 }, /* R17948 - ADCL_RETUNE_C15_1 */
+	[17949] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17949 - ADCL_RETUNE_C15_0 */
+	[17950] = { 0x00FF, 0x00FF, 0x0000 }, /* R17950 - ADCL_RETUNE_C16_1 */
+	[17951] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17951 - ADCL_RETUNE_C16_0 */
+	[17952] = { 0x00FF, 0x00FF, 0x0000 }, /* R17952 - ADCL_RETUNE_C17_1 */
+	[17953] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17953 - ADCL_RETUNE_C17_0 */
+	[17954] = { 0x00FF, 0x00FF, 0x0000 }, /* R17954 - ADCL_RETUNE_C18_1 */
+	[17955] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17955 - ADCL_RETUNE_C18_0 */
+	[17956] = { 0x00FF, 0x00FF, 0x0000 }, /* R17956 - ADCL_RETUNE_C19_1 */
+	[17957] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17957 - ADCL_RETUNE_C19_0 */
+	[17958] = { 0x00FF, 0x00FF, 0x0000 }, /* R17958 - ADCL_RETUNE_C20_1 */
+	[17959] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17959 - ADCL_RETUNE_C20_0 */
+	[17960] = { 0x00FF, 0x00FF, 0x0000 }, /* R17960 - ADCL_RETUNE_C21_1 */
+	[17961] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17961 - ADCL_RETUNE_C21_0 */
+	[17962] = { 0x00FF, 0x00FF, 0x0000 }, /* R17962 - ADCL_RETUNE_C22_1 */
+	[17963] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17963 - ADCL_RETUNE_C22_0 */
+	[17964] = { 0x00FF, 0x00FF, 0x0000 }, /* R17964 - ADCL_RETUNE_C23_1 */
+	[17965] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17965 - ADCL_RETUNE_C23_0 */
+	[17966] = { 0x00FF, 0x00FF, 0x0000 }, /* R17966 - ADCL_RETUNE_C24_1 */
+	[17967] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17967 - ADCL_RETUNE_C24_0 */
+	[17968] = { 0x00FF, 0x00FF, 0x0000 }, /* R17968 - ADCL_RETUNE_C25_1 */
+	[17969] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17969 - ADCL_RETUNE_C25_0 */
+	[17970] = { 0x00FF, 0x00FF, 0x0000 }, /* R17970 - ADCL_RETUNE_C26_1 */
+	[17971] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17971 - ADCL_RETUNE_C26_0 */
+	[17972] = { 0x00FF, 0x00FF, 0x0000 }, /* R17972 - ADCL_RETUNE_C27_1 */
+	[17973] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17973 - ADCL_RETUNE_C27_0 */
+	[17974] = { 0x00FF, 0x00FF, 0x0000 }, /* R17974 - ADCL_RETUNE_C28_1 */
+	[17975] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17975 - ADCL_RETUNE_C28_0 */
+	[17976] = { 0x00FF, 0x00FF, 0x0000 }, /* R17976 - ADCL_RETUNE_C29_1 */
+	[17977] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17977 - ADCL_RETUNE_C29_0 */
+	[17978] = { 0x00FF, 0x00FF, 0x0000 }, /* R17978 - ADCL_RETUNE_C30_1 */
+	[17979] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17979 - ADCL_RETUNE_C30_0 */
+	[17980] = { 0x00FF, 0x00FF, 0x0000 }, /* R17980 - ADCL_RETUNE_C31_1 */
+	[17981] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17981 - ADCL_RETUNE_C31_0 */
+	[17982] = { 0x00FF, 0x00FF, 0x0000 }, /* R17982 - ADCL_RETUNE_C32_1 */
+	[17983] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R17983 - ADCL_RETUNE_C32_0 */
+	[18432] = { 0x00FF, 0x00FF, 0x0000 }, /* R18432 - RETUNEADC_PG2_1 */
+	[18433] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18433 - RETUNEADC_PG2_0 */
+	[18434] = { 0x00FF, 0x00FF, 0x0000 }, /* R18434 - RETUNEADC_PG_1 */
+	[18435] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18435 - RETUNEADC_PG_0 */
+	[18944] = { 0x00FF, 0x00FF, 0x0000 }, /* R18944 - ADCR_RETUNE_C1_1 */
+	[18945] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18945 - ADCR_RETUNE_C1_0 */
+	[18946] = { 0x00FF, 0x00FF, 0x0000 }, /* R18946 - ADCR_RETUNE_C2_1 */
+	[18947] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18947 - ADCR_RETUNE_C2_0 */
+	[18948] = { 0x00FF, 0x00FF, 0x0000 }, /* R18948 - ADCR_RETUNE_C3_1 */
+	[18949] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18949 - ADCR_RETUNE_C3_0 */
+	[18950] = { 0x00FF, 0x00FF, 0x0000 }, /* R18950 - ADCR_RETUNE_C4_1 */
+	[18951] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18951 - ADCR_RETUNE_C4_0 */
+	[18952] = { 0x00FF, 0x00FF, 0x0000 }, /* R18952 - ADCR_RETUNE_C5_1 */
+	[18953] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18953 - ADCR_RETUNE_C5_0 */
+	[18954] = { 0x00FF, 0x00FF, 0x0000 }, /* R18954 - ADCR_RETUNE_C6_1 */
+	[18955] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18955 - ADCR_RETUNE_C6_0 */
+	[18956] = { 0x00FF, 0x00FF, 0x0000 }, /* R18956 - ADCR_RETUNE_C7_1 */
+	[18957] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18957 - ADCR_RETUNE_C7_0 */
+	[18958] = { 0x00FF, 0x00FF, 0x0000 }, /* R18958 - ADCR_RETUNE_C8_1 */
+	[18959] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18959 - ADCR_RETUNE_C8_0 */
+	[18960] = { 0x00FF, 0x00FF, 0x0000 }, /* R18960 - ADCR_RETUNE_C9_1 */
+	[18961] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18961 - ADCR_RETUNE_C9_0 */
+	[18962] = { 0x00FF, 0x00FF, 0x0000 }, /* R18962 - ADCR_RETUNE_C10_1 */
+	[18963] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18963 - ADCR_RETUNE_C10_0 */
+	[18964] = { 0x00FF, 0x00FF, 0x0000 }, /* R18964 - ADCR_RETUNE_C11_1 */
+	[18965] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18965 - ADCR_RETUNE_C11_0 */
+	[18966] = { 0x00FF, 0x00FF, 0x0000 }, /* R18966 - ADCR_RETUNE_C12_1 */
+	[18967] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18967 - ADCR_RETUNE_C12_0 */
+	[18968] = { 0x00FF, 0x00FF, 0x0000 }, /* R18968 - ADCR_RETUNE_C13_1 */
+	[18969] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18969 - ADCR_RETUNE_C13_0 */
+	[18970] = { 0x00FF, 0x00FF, 0x0000 }, /* R18970 - ADCR_RETUNE_C14_1 */
+	[18971] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18971 - ADCR_RETUNE_C14_0 */
+	[18972] = { 0x00FF, 0x00FF, 0x0000 }, /* R18972 - ADCR_RETUNE_C15_1 */
+	[18973] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18973 - ADCR_RETUNE_C15_0 */
+	[18974] = { 0x00FF, 0x00FF, 0x0000 }, /* R18974 - ADCR_RETUNE_C16_1 */
+	[18975] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18975 - ADCR_RETUNE_C16_0 */
+	[18976] = { 0x00FF, 0x00FF, 0x0000 }, /* R18976 - ADCR_RETUNE_C17_1 */
+	[18977] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18977 - ADCR_RETUNE_C17_0 */
+	[18978] = { 0x00FF, 0x00FF, 0x0000 }, /* R18978 - ADCR_RETUNE_C18_1 */
+	[18979] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18979 - ADCR_RETUNE_C18_0 */
+	[18980] = { 0x00FF, 0x00FF, 0x0000 }, /* R18980 - ADCR_RETUNE_C19_1 */
+	[18981] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18981 - ADCR_RETUNE_C19_0 */
+	[18982] = { 0x00FF, 0x00FF, 0x0000 }, /* R18982 - ADCR_RETUNE_C20_1 */
+	[18983] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18983 - ADCR_RETUNE_C20_0 */
+	[18984] = { 0x00FF, 0x00FF, 0x0000 }, /* R18984 - ADCR_RETUNE_C21_1 */
+	[18985] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18985 - ADCR_RETUNE_C21_0 */
+	[18986] = { 0x00FF, 0x00FF, 0x0000 }, /* R18986 - ADCR_RETUNE_C22_1 */
+	[18987] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18987 - ADCR_RETUNE_C22_0 */
+	[18988] = { 0x00FF, 0x00FF, 0x0000 }, /* R18988 - ADCR_RETUNE_C23_1 */
+	[18989] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18989 - ADCR_RETUNE_C23_0 */
+	[18990] = { 0x00FF, 0x00FF, 0x0000 }, /* R18990 - ADCR_RETUNE_C24_1 */
+	[18991] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18991 - ADCR_RETUNE_C24_0 */
+	[18992] = { 0x00FF, 0x00FF, 0x0000 }, /* R18992 - ADCR_RETUNE_C25_1 */
+	[18993] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18993 - ADCR_RETUNE_C25_0 */
+	[18994] = { 0x00FF, 0x00FF, 0x0000 }, /* R18994 - ADCR_RETUNE_C26_1 */
+	[18995] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18995 - ADCR_RETUNE_C26_0 */
+	[18996] = { 0x00FF, 0x00FF, 0x0000 }, /* R18996 - ADCR_RETUNE_C27_1 */
+	[18997] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18997 - ADCR_RETUNE_C27_0 */
+	[18998] = { 0x00FF, 0x00FF, 0x0000 }, /* R18998 - ADCR_RETUNE_C28_1 */
+	[18999] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R18999 - ADCR_RETUNE_C28_0 */
+	[19000] = { 0x00FF, 0x00FF, 0x0000 }, /* R19000 - ADCR_RETUNE_C29_1 */
+	[19001] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19001 - ADCR_RETUNE_C29_0 */
+	[19002] = { 0x00FF, 0x00FF, 0x0000 }, /* R19002 - ADCR_RETUNE_C30_1 */
+	[19003] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19003 - ADCR_RETUNE_C30_0 */
+	[19004] = { 0x00FF, 0x00FF, 0x0000 }, /* R19004 - ADCR_RETUNE_C31_1 */
+	[19005] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19005 - ADCR_RETUNE_C31_0 */
+	[19006] = { 0x00FF, 0x00FF, 0x0000 }, /* R19006 - ADCR_RETUNE_C32_1 */
+	[19007] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19007 - ADCR_RETUNE_C32_0 */
+	[19456] = { 0x00FF, 0x00FF, 0x0000 }, /* R19456 - DACL_RETUNE_C1_1 */
+	[19457] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19457 - DACL_RETUNE_C1_0 */
+	[19458] = { 0x00FF, 0x00FF, 0x0000 }, /* R19458 - DACL_RETUNE_C2_1 */
+	[19459] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19459 - DACL_RETUNE_C2_0 */
+	[19460] = { 0x00FF, 0x00FF, 0x0000 }, /* R19460 - DACL_RETUNE_C3_1 */
+	[19461] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19461 - DACL_RETUNE_C3_0 */
+	[19462] = { 0x00FF, 0x00FF, 0x0000 }, /* R19462 - DACL_RETUNE_C4_1 */
+	[19463] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19463 - DACL_RETUNE_C4_0 */
+	[19464] = { 0x00FF, 0x00FF, 0x0000 }, /* R19464 - DACL_RETUNE_C5_1 */
+	[19465] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19465 - DACL_RETUNE_C5_0 */
+	[19466] = { 0x00FF, 0x00FF, 0x0000 }, /* R19466 - DACL_RETUNE_C6_1 */
+	[19467] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19467 - DACL_RETUNE_C6_0 */
+	[19468] = { 0x00FF, 0x00FF, 0x0000 }, /* R19468 - DACL_RETUNE_C7_1 */
+	[19469] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19469 - DACL_RETUNE_C7_0 */
+	[19470] = { 0x00FF, 0x00FF, 0x0000 }, /* R19470 - DACL_RETUNE_C8_1 */
+	[19471] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19471 - DACL_RETUNE_C8_0 */
+	[19472] = { 0x00FF, 0x00FF, 0x0000 }, /* R19472 - DACL_RETUNE_C9_1 */
+	[19473] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19473 - DACL_RETUNE_C9_0 */
+	[19474] = { 0x00FF, 0x00FF, 0x0000 }, /* R19474 - DACL_RETUNE_C10_1 */
+	[19475] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19475 - DACL_RETUNE_C10_0 */
+	[19476] = { 0x00FF, 0x00FF, 0x0000 }, /* R19476 - DACL_RETUNE_C11_1 */
+	[19477] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19477 - DACL_RETUNE_C11_0 */
+	[19478] = { 0x00FF, 0x00FF, 0x0000 }, /* R19478 - DACL_RETUNE_C12_1 */
+	[19479] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19479 - DACL_RETUNE_C12_0 */
+	[19480] = { 0x00FF, 0x00FF, 0x0000 }, /* R19480 - DACL_RETUNE_C13_1 */
+	[19481] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19481 - DACL_RETUNE_C13_0 */
+	[19482] = { 0x00FF, 0x00FF, 0x0000 }, /* R19482 - DACL_RETUNE_C14_1 */
+	[19483] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19483 - DACL_RETUNE_C14_0 */
+	[19484] = { 0x00FF, 0x00FF, 0x0000 }, /* R19484 - DACL_RETUNE_C15_1 */
+	[19485] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19485 - DACL_RETUNE_C15_0 */
+	[19486] = { 0x00FF, 0x00FF, 0x0000 }, /* R19486 - DACL_RETUNE_C16_1 */
+	[19487] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19487 - DACL_RETUNE_C16_0 */
+	[19488] = { 0x00FF, 0x00FF, 0x0000 }, /* R19488 - DACL_RETUNE_C17_1 */
+	[19489] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19489 - DACL_RETUNE_C17_0 */
+	[19490] = { 0x00FF, 0x00FF, 0x0000 }, /* R19490 - DACL_RETUNE_C18_1 */
+	[19491] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19491 - DACL_RETUNE_C18_0 */
+	[19492] = { 0x00FF, 0x00FF, 0x0000 }, /* R19492 - DACL_RETUNE_C19_1 */
+	[19493] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19493 - DACL_RETUNE_C19_0 */
+	[19494] = { 0x00FF, 0x00FF, 0x0000 }, /* R19494 - DACL_RETUNE_C20_1 */
+	[19495] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19495 - DACL_RETUNE_C20_0 */
+	[19496] = { 0x00FF, 0x00FF, 0x0000 }, /* R19496 - DACL_RETUNE_C21_1 */
+	[19497] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19497 - DACL_RETUNE_C21_0 */
+	[19498] = { 0x00FF, 0x00FF, 0x0000 }, /* R19498 - DACL_RETUNE_C22_1 */
+	[19499] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19499 - DACL_RETUNE_C22_0 */
+	[19500] = { 0x00FF, 0x00FF, 0x0000 }, /* R19500 - DACL_RETUNE_C23_1 */
+	[19501] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19501 - DACL_RETUNE_C23_0 */
+	[19502] = { 0x00FF, 0x00FF, 0x0000 }, /* R19502 - DACL_RETUNE_C24_1 */
+	[19503] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19503 - DACL_RETUNE_C24_0 */
+	[19504] = { 0x00FF, 0x00FF, 0x0000 }, /* R19504 - DACL_RETUNE_C25_1 */
+	[19505] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19505 - DACL_RETUNE_C25_0 */
+	[19506] = { 0x00FF, 0x00FF, 0x0000 }, /* R19506 - DACL_RETUNE_C26_1 */
+	[19507] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19507 - DACL_RETUNE_C26_0 */
+	[19508] = { 0x00FF, 0x00FF, 0x0000 }, /* R19508 - DACL_RETUNE_C27_1 */
+	[19509] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19509 - DACL_RETUNE_C27_0 */
+	[19510] = { 0x00FF, 0x00FF, 0x0000 }, /* R19510 - DACL_RETUNE_C28_1 */
+	[19511] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19511 - DACL_RETUNE_C28_0 */
+	[19512] = { 0x00FF, 0x00FF, 0x0000 }, /* R19512 - DACL_RETUNE_C29_1 */
+	[19513] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19513 - DACL_RETUNE_C29_0 */
+	[19514] = { 0x00FF, 0x00FF, 0x0000 }, /* R19514 - DACL_RETUNE_C30_1 */
+	[19515] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19515 - DACL_RETUNE_C30_0 */
+	[19516] = { 0x00FF, 0x00FF, 0x0000 }, /* R19516 - DACL_RETUNE_C31_1 */
+	[19517] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19517 - DACL_RETUNE_C31_0 */
+	[19518] = { 0x00FF, 0x00FF, 0x0000 }, /* R19518 - DACL_RETUNE_C32_1 */
+	[19519] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19519 - DACL_RETUNE_C32_0 */
+	[19968] = { 0x00FF, 0x00FF, 0x0000 }, /* R19968 - RETUNEDAC_PG2_1 */
+	[19969] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19969 - RETUNEDAC_PG2_0 */
+	[19970] = { 0x00FF, 0x00FF, 0x0000 }, /* R19970 - RETUNEDAC_PG_1 */
+	[19971] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R19971 - RETUNEDAC_PG_0 */
+	[20480] = { 0x00FF, 0x00FF, 0x0000 }, /* R20480 - DACR_RETUNE_C1_1 */
+	[20481] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20481 - DACR_RETUNE_C1_0 */
+	[20482] = { 0x00FF, 0x00FF, 0x0000 }, /* R20482 - DACR_RETUNE_C2_1 */
+	[20483] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20483 - DACR_RETUNE_C2_0 */
+	[20484] = { 0x00FF, 0x00FF, 0x0000 }, /* R20484 - DACR_RETUNE_C3_1 */
+	[20485] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20485 - DACR_RETUNE_C3_0 */
+	[20486] = { 0x00FF, 0x00FF, 0x0000 }, /* R20486 - DACR_RETUNE_C4_1 */
+	[20487] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20487 - DACR_RETUNE_C4_0 */
+	[20488] = { 0x00FF, 0x00FF, 0x0000 }, /* R20488 - DACR_RETUNE_C5_1 */
+	[20489] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20489 - DACR_RETUNE_C5_0 */
+	[20490] = { 0x00FF, 0x00FF, 0x0000 }, /* R20490 - DACR_RETUNE_C6_1 */
+	[20491] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20491 - DACR_RETUNE_C6_0 */
+	[20492] = { 0x00FF, 0x00FF, 0x0000 }, /* R20492 - DACR_RETUNE_C7_1 */
+	[20493] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20493 - DACR_RETUNE_C7_0 */
+	[20494] = { 0x00FF, 0x00FF, 0x0000 }, /* R20494 - DACR_RETUNE_C8_1 */
+	[20495] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20495 - DACR_RETUNE_C8_0 */
+	[20496] = { 0x00FF, 0x00FF, 0x0000 }, /* R20496 - DACR_RETUNE_C9_1 */
+	[20497] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20497 - DACR_RETUNE_C9_0 */
+	[20498] = { 0x00FF, 0x00FF, 0x0000 }, /* R20498 - DACR_RETUNE_C10_1 */
+	[20499] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20499 - DACR_RETUNE_C10_0 */
+	[20500] = { 0x00FF, 0x00FF, 0x0000 }, /* R20500 - DACR_RETUNE_C11_1 */
+	[20501] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20501 - DACR_RETUNE_C11_0 */
+	[20502] = { 0x00FF, 0x00FF, 0x0000 }, /* R20502 - DACR_RETUNE_C12_1 */
+	[20503] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20503 - DACR_RETUNE_C12_0 */
+	[20504] = { 0x00FF, 0x00FF, 0x0000 }, /* R20504 - DACR_RETUNE_C13_1 */
+	[20505] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20505 - DACR_RETUNE_C13_0 */
+	[20506] = { 0x00FF, 0x00FF, 0x0000 }, /* R20506 - DACR_RETUNE_C14_1 */
+	[20507] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20507 - DACR_RETUNE_C14_0 */
+	[20508] = { 0x00FF, 0x00FF, 0x0000 }, /* R20508 - DACR_RETUNE_C15_1 */
+	[20509] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20509 - DACR_RETUNE_C15_0 */
+	[20510] = { 0x00FF, 0x00FF, 0x0000 }, /* R20510 - DACR_RETUNE_C16_1 */
+	[20511] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20511 - DACR_RETUNE_C16_0 */
+	[20512] = { 0x00FF, 0x00FF, 0x0000 }, /* R20512 - DACR_RETUNE_C17_1 */
+	[20513] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20513 - DACR_RETUNE_C17_0 */
+	[20514] = { 0x00FF, 0x00FF, 0x0000 }, /* R20514 - DACR_RETUNE_C18_1 */
+	[20515] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20515 - DACR_RETUNE_C18_0 */
+	[20516] = { 0x00FF, 0x00FF, 0x0000 }, /* R20516 - DACR_RETUNE_C19_1 */
+	[20517] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20517 - DACR_RETUNE_C19_0 */
+	[20518] = { 0x00FF, 0x00FF, 0x0000 }, /* R20518 - DACR_RETUNE_C20_1 */
+	[20519] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20519 - DACR_RETUNE_C20_0 */
+	[20520] = { 0x00FF, 0x00FF, 0x0000 }, /* R20520 - DACR_RETUNE_C21_1 */
+	[20521] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20521 - DACR_RETUNE_C21_0 */
+	[20522] = { 0x00FF, 0x00FF, 0x0000 }, /* R20522 - DACR_RETUNE_C22_1 */
+	[20523] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20523 - DACR_RETUNE_C22_0 */
+	[20524] = { 0x00FF, 0x00FF, 0x0000 }, /* R20524 - DACR_RETUNE_C23_1 */
+	[20525] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20525 - DACR_RETUNE_C23_0 */
+	[20526] = { 0x00FF, 0x00FF, 0x0000 }, /* R20526 - DACR_RETUNE_C24_1 */
+	[20527] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20527 - DACR_RETUNE_C24_0 */
+	[20528] = { 0x00FF, 0x00FF, 0x0000 }, /* R20528 - DACR_RETUNE_C25_1 */
+	[20529] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20529 - DACR_RETUNE_C25_0 */
+	[20530] = { 0x00FF, 0x00FF, 0x0000 }, /* R20530 - DACR_RETUNE_C26_1 */
+	[20531] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20531 - DACR_RETUNE_C26_0 */
+	[20532] = { 0x00FF, 0x00FF, 0x0000 }, /* R20532 - DACR_RETUNE_C27_1 */
+	[20533] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20533 - DACR_RETUNE_C27_0 */
+	[20534] = { 0x00FF, 0x00FF, 0x0000 }, /* R20534 - DACR_RETUNE_C28_1 */
+	[20535] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20535 - DACR_RETUNE_C28_0 */
+	[20536] = { 0x00FF, 0x00FF, 0x0000 }, /* R20536 - DACR_RETUNE_C29_1 */
+	[20537] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20537 - DACR_RETUNE_C29_0 */
+	[20538] = { 0x00FF, 0x00FF, 0x0000 }, /* R20538 - DACR_RETUNE_C30_1 */
+	[20539] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20539 - DACR_RETUNE_C30_0 */
+	[20540] = { 0x00FF, 0x00FF, 0x0000 }, /* R20540 - DACR_RETUNE_C31_1 */
+	[20541] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20541 - DACR_RETUNE_C31_0 */
+	[20542] = { 0x00FF, 0x00FF, 0x0000 }, /* R20542 - DACR_RETUNE_C32_1 */
+	[20543] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20543 - DACR_RETUNE_C32_0 */
+	[20992] = { 0x00FF, 0x00FF, 0x0000 }, /* R20992 - VSS_XHD2_1 */
+	[20993] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20993 - VSS_XHD2_0 */
+	[20994] = { 0x00FF, 0x00FF, 0x0000 }, /* R20994 - VSS_XHD3_1 */
+	[20995] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20995 - VSS_XHD3_0 */
+	[20996] = { 0x00FF, 0x00FF, 0x0000 }, /* R20996 - VSS_XHN1_1 */
+	[20997] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20997 - VSS_XHN1_0 */
+	[20998] = { 0x00FF, 0x00FF, 0x0000 }, /* R20998 - VSS_XHN2_1 */
+	[20999] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R20999 - VSS_XHN2_0 */
+	[21000] = { 0x00FF, 0x00FF, 0x0000 }, /* R21000 - VSS_XHN3_1 */
+	[21001] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21001 - VSS_XHN3_0 */
+	[21002] = { 0x00FF, 0x00FF, 0x0000 }, /* R21002 - VSS_XLA_1 */
+	[21003] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21003 - VSS_XLA_0 */
+	[21004] = { 0x00FF, 0x00FF, 0x0000 }, /* R21004 - VSS_XLB_1 */
+	[21005] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21005 - VSS_XLB_0 */
+	[21006] = { 0x00FF, 0x00FF, 0x0000 }, /* R21006 - VSS_XLG_1 */
+	[21007] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21007 - VSS_XLG_0 */
+	[21008] = { 0x00FF, 0x00FF, 0x0000 }, /* R21008 - VSS_PG2_1 */
+	[21009] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21009 - VSS_PG2_0 */
+	[21010] = { 0x00FF, 0x00FF, 0x0000 }, /* R21010 - VSS_PG_1 */
+	[21011] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21011 - VSS_PG_0 */
+	[21012] = { 0x00FF, 0x00FF, 0x0000 }, /* R21012 - VSS_XTD1_1 */
+	[21013] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21013 - VSS_XTD1_0 */
+	[21014] = { 0x00FF, 0x00FF, 0x0000 }, /* R21014 - VSS_XTD2_1 */
+	[21015] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21015 - VSS_XTD2_0 */
+	[21016] = { 0x00FF, 0x00FF, 0x0000 }, /* R21016 - VSS_XTD3_1 */
+	[21017] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21017 - VSS_XTD3_0 */
+	[21018] = { 0x00FF, 0x00FF, 0x0000 }, /* R21018 - VSS_XTD4_1 */
+	[21019] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21019 - VSS_XTD4_0 */
+	[21020] = { 0x00FF, 0x00FF, 0x0000 }, /* R21020 - VSS_XTD5_1 */
+	[21021] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21021 - VSS_XTD5_0 */
+	[21022] = { 0x00FF, 0x00FF, 0x0000 }, /* R21022 - VSS_XTD6_1 */
+	[21023] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21023 - VSS_XTD6_0 */
+	[21024] = { 0x00FF, 0x00FF, 0x0000 }, /* R21024 - VSS_XTD7_1 */
+	[21025] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21025 - VSS_XTD7_0 */
+	[21026] = { 0x00FF, 0x00FF, 0x0000 }, /* R21026 - VSS_XTD8_1 */
+	[21027] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21027 - VSS_XTD8_0 */
+	[21028] = { 0x00FF, 0x00FF, 0x0000 }, /* R21028 - VSS_XTD9_1 */
+	[21029] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21029 - VSS_XTD9_0 */
+	[21030] = { 0x00FF, 0x00FF, 0x0000 }, /* R21030 - VSS_XTD10_1 */
+	[21031] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21031 - VSS_XTD10_0 */
+	[21032] = { 0x00FF, 0x00FF, 0x0000 }, /* R21032 - VSS_XTD11_1 */
+	[21033] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21033 - VSS_XTD11_0 */
+	[21034] = { 0x00FF, 0x00FF, 0x0000 }, /* R21034 - VSS_XTD12_1 */
+	[21035] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21035 - VSS_XTD12_0 */
+	[21036] = { 0x00FF, 0x00FF, 0x0000 }, /* R21036 - VSS_XTD13_1 */
+	[21037] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21037 - VSS_XTD13_0 */
+	[21038] = { 0x00FF, 0x00FF, 0x0000 }, /* R21038 - VSS_XTD14_1 */
+	[21039] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21039 - VSS_XTD14_0 */
+	[21040] = { 0x00FF, 0x00FF, 0x0000 }, /* R21040 - VSS_XTD15_1 */
+	[21041] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21041 - VSS_XTD15_0 */
+	[21042] = { 0x00FF, 0x00FF, 0x0000 }, /* R21042 - VSS_XTD16_1 */
+	[21043] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21043 - VSS_XTD16_0 */
+	[21044] = { 0x00FF, 0x00FF, 0x0000 }, /* R21044 - VSS_XTD17_1 */
+	[21045] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21045 - VSS_XTD17_0 */
+	[21046] = { 0x00FF, 0x00FF, 0x0000 }, /* R21046 - VSS_XTD18_1 */
+	[21047] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21047 - VSS_XTD18_0 */
+	[21048] = { 0x00FF, 0x00FF, 0x0000 }, /* R21048 - VSS_XTD19_1 */
+	[21049] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21049 - VSS_XTD19_0 */
+	[21050] = { 0x00FF, 0x00FF, 0x0000 }, /* R21050 - VSS_XTD20_1 */
+	[21051] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21051 - VSS_XTD20_0 */
+	[21052] = { 0x00FF, 0x00FF, 0x0000 }, /* R21052 - VSS_XTD21_1 */
+	[21053] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21053 - VSS_XTD21_0 */
+	[21054] = { 0x00FF, 0x00FF, 0x0000 }, /* R21054 - VSS_XTD22_1 */
+	[21055] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21055 - VSS_XTD22_0 */
+	[21056] = { 0x00FF, 0x00FF, 0x0000 }, /* R21056 - VSS_XTD23_1 */
+	[21057] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21057 - VSS_XTD23_0 */
+	[21058] = { 0x00FF, 0x00FF, 0x0000 }, /* R21058 - VSS_XTD24_1 */
+	[21059] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21059 - VSS_XTD24_0 */
+	[21060] = { 0x00FF, 0x00FF, 0x0000 }, /* R21060 - VSS_XTD25_1 */
+	[21061] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21061 - VSS_XTD25_0 */
+	[21062] = { 0x00FF, 0x00FF, 0x0000 }, /* R21062 - VSS_XTD26_1 */
+	[21063] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21063 - VSS_XTD26_0 */
+	[21064] = { 0x00FF, 0x00FF, 0x0000 }, /* R21064 - VSS_XTD27_1 */
+	[21065] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21065 - VSS_XTD27_0 */
+	[21066] = { 0x00FF, 0x00FF, 0x0000 }, /* R21066 - VSS_XTD28_1 */
+	[21067] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21067 - VSS_XTD28_0 */
+	[21068] = { 0x00FF, 0x00FF, 0x0000 }, /* R21068 - VSS_XTD29_1 */
+	[21069] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21069 - VSS_XTD29_0 */
+	[21070] = { 0x00FF, 0x00FF, 0x0000 }, /* R21070 - VSS_XTD30_1 */
+	[21071] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21071 - VSS_XTD30_0 */
+	[21072] = { 0x00FF, 0x00FF, 0x0000 }, /* R21072 - VSS_XTD31_1 */
+	[21073] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21073 - VSS_XTD31_0 */
+	[21074] = { 0x00FF, 0x00FF, 0x0000 }, /* R21074 - VSS_XTD32_1 */
+	[21075] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21075 - VSS_XTD32_0 */
+	[21076] = { 0x00FF, 0x00FF, 0x0000 }, /* R21076 - VSS_XTS1_1 */
+	[21077] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21077 - VSS_XTS1_0 */
+	[21078] = { 0x00FF, 0x00FF, 0x0000 }, /* R21078 - VSS_XTS2_1 */
+	[21079] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21079 - VSS_XTS2_0 */
+	[21080] = { 0x00FF, 0x00FF, 0x0000 }, /* R21080 - VSS_XTS3_1 */
+	[21081] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21081 - VSS_XTS3_0 */
+	[21082] = { 0x00FF, 0x00FF, 0x0000 }, /* R21082 - VSS_XTS4_1 */
+	[21083] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21083 - VSS_XTS4_0 */
+	[21084] = { 0x00FF, 0x00FF, 0x0000 }, /* R21084 - VSS_XTS5_1 */
+	[21085] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21085 - VSS_XTS5_0 */
+	[21086] = { 0x00FF, 0x00FF, 0x0000 }, /* R21086 - VSS_XTS6_1 */
+	[21087] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21087 - VSS_XTS6_0 */
+	[21088] = { 0x00FF, 0x00FF, 0x0000 }, /* R21088 - VSS_XTS7_1 */
+	[21089] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21089 - VSS_XTS7_0 */
+	[21090] = { 0x00FF, 0x00FF, 0x0000 }, /* R21090 - VSS_XTS8_1 */
+	[21091] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21091 - VSS_XTS8_0 */
+	[21092] = { 0x00FF, 0x00FF, 0x0000 }, /* R21092 - VSS_XTS9_1 */
+	[21093] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21093 - VSS_XTS9_0 */
+	[21094] = { 0x00FF, 0x00FF, 0x0000 }, /* R21094 - VSS_XTS10_1 */
+	[21095] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21095 - VSS_XTS10_0 */
+	[21096] = { 0x00FF, 0x00FF, 0x0000 }, /* R21096 - VSS_XTS11_1 */
+	[21097] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21097 - VSS_XTS11_0 */
+	[21098] = { 0x00FF, 0x00FF, 0x0000 }, /* R21098 - VSS_XTS12_1 */
+	[21099] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21099 - VSS_XTS12_0 */
+	[21100] = { 0x00FF, 0x00FF, 0x0000 }, /* R21100 - VSS_XTS13_1 */
+	[21101] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21101 - VSS_XTS13_0 */
+	[21102] = { 0x00FF, 0x00FF, 0x0000 }, /* R21102 - VSS_XTS14_1 */
+	[21103] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21103 - VSS_XTS14_0 */
+	[21104] = { 0x00FF, 0x00FF, 0x0000 }, /* R21104 - VSS_XTS15_1 */
+	[21105] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21105 - VSS_XTS15_0 */
+	[21106] = { 0x00FF, 0x00FF, 0x0000 }, /* R21106 - VSS_XTS16_1 */
+	[21107] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21107 - VSS_XTS16_0 */
+	[21108] = { 0x00FF, 0x00FF, 0x0000 }, /* R21108 - VSS_XTS17_1 */
+	[21109] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21109 - VSS_XTS17_0 */
+	[21110] = { 0x00FF, 0x00FF, 0x0000 }, /* R21110 - VSS_XTS18_1 */
+	[21111] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21111 - VSS_XTS18_0 */
+	[21112] = { 0x00FF, 0x00FF, 0x0000 }, /* R21112 - VSS_XTS19_1 */
+	[21113] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21113 - VSS_XTS19_0 */
+	[21114] = { 0x00FF, 0x00FF, 0x0000 }, /* R21114 - VSS_XTS20_1 */
+	[21115] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21115 - VSS_XTS20_0 */
+	[21116] = { 0x00FF, 0x00FF, 0x0000 }, /* R21116 - VSS_XTS21_1 */
+	[21117] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21117 - VSS_XTS21_0 */
+	[21118] = { 0x00FF, 0x00FF, 0x0000 }, /* R21118 - VSS_XTS22_1 */
+	[21119] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21119 - VSS_XTS22_0 */
+	[21120] = { 0x00FF, 0x00FF, 0x0000 }, /* R21120 - VSS_XTS23_1 */
+	[21121] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21121 - VSS_XTS23_0 */
+	[21122] = { 0x00FF, 0x00FF, 0x0000 }, /* R21122 - VSS_XTS24_1 */
+	[21123] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21123 - VSS_XTS24_0 */
+	[21124] = { 0x00FF, 0x00FF, 0x0000 }, /* R21124 - VSS_XTS25_1 */
+	[21125] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21125 - VSS_XTS25_0 */
+	[21126] = { 0x00FF, 0x00FF, 0x0000 }, /* R21126 - VSS_XTS26_1 */
+	[21127] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21127 - VSS_XTS26_0 */
+	[21128] = { 0x00FF, 0x00FF, 0x0000 }, /* R21128 - VSS_XTS27_1 */
+	[21129] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21129 - VSS_XTS27_0 */
+	[21130] = { 0x00FF, 0x00FF, 0x0000 }, /* R21130 - VSS_XTS28_1 */
+	[21131] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21131 - VSS_XTS28_0 */
+	[21132] = { 0x00FF, 0x00FF, 0x0000 }, /* R21132 - VSS_XTS29_1 */
+	[21133] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21133 - VSS_XTS29_0 */
+	[21134] = { 0x00FF, 0x00FF, 0x0000 }, /* R21134 - VSS_XTS30_1 */
+	[21135] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21135 - VSS_XTS30_0 */
+	[21136] = { 0x00FF, 0x00FF, 0x0000 }, /* R21136 - VSS_XTS31_1 */
+	[21137] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21137 - VSS_XTS31_0 */
+	[21138] = { 0x00FF, 0x00FF, 0x0000 }, /* R21138 - VSS_XTS32_1 */
+	[21139] = { 0xFFFF, 0xFFFF, 0x0000 }, /* R21139 - VSS_XTS32_0 */
 };
 
-static bool wm8962_volatile_register(struct device *dev, unsigned int reg)
+static int wm8962_volatile_register(struct snd_soc_codec *codec, unsigned int reg)
 {
-	switch (reg) {
-	case WM8962_CLOCKING1:
-	case WM8962_CLOCKING2:
-	case WM8962_SOFTWARE_RESET:
-	case WM8962_ALC2:
-	case WM8962_THERMAL_SHUTDOWN_STATUS:
-	case WM8962_ADDITIONAL_CONTROL_4:
-	case WM8962_CLASS_D_CONTROL_1:
-	case WM8962_DC_SERVO_6:
-	case WM8962_INTERRUPT_STATUS_1:
-	case WM8962_INTERRUPT_STATUS_2:
-	case WM8962_DSP2_EXECCONTROL:
-		return true;
-	default:
-		return false;
-	}
+	if (wm8962_reg_access[reg].vol)
+		return 1;
+	else
+		return 0;
 }
 
-static bool wm8962_readable_register(struct device *dev, unsigned int reg)
+static int wm8962_readable_register(struct snd_soc_codec *codec, unsigned int reg)
 {
-	switch (reg) {
-	case WM8962_LEFT_INPUT_VOLUME:
-	case WM8962_RIGHT_INPUT_VOLUME:
-	case WM8962_HPOUTL_VOLUME:
-	case WM8962_HPOUTR_VOLUME:
-	case WM8962_CLOCKING1:
-	case WM8962_ADC_DAC_CONTROL_1:
-	case WM8962_ADC_DAC_CONTROL_2:
-	case WM8962_AUDIO_INTERFACE_0:
-	case WM8962_CLOCKING2:
-	case WM8962_AUDIO_INTERFACE_1:
-	case WM8962_LEFT_DAC_VOLUME:
-	case WM8962_RIGHT_DAC_VOLUME:
-	case WM8962_AUDIO_INTERFACE_2:
-	case WM8962_SOFTWARE_RESET:
-	case WM8962_ALC1:
-	case WM8962_ALC2:
-	case WM8962_ALC3:
-	case WM8962_NOISE_GATE:
-	case WM8962_LEFT_ADC_VOLUME:
-	case WM8962_RIGHT_ADC_VOLUME:
-	case WM8962_ADDITIONAL_CONTROL_1:
-	case WM8962_ADDITIONAL_CONTROL_2:
-	case WM8962_PWR_MGMT_1:
-	case WM8962_PWR_MGMT_2:
-	case WM8962_ADDITIONAL_CONTROL_3:
-	case WM8962_ANTI_POP:
-	case WM8962_CLOCKING_3:
-	case WM8962_INPUT_MIXER_CONTROL_1:
-	case WM8962_LEFT_INPUT_MIXER_VOLUME:
-	case WM8962_RIGHT_INPUT_MIXER_VOLUME:
-	case WM8962_INPUT_MIXER_CONTROL_2:
-	case WM8962_INPUT_BIAS_CONTROL:
-	case WM8962_LEFT_INPUT_PGA_CONTROL:
-	case WM8962_RIGHT_INPUT_PGA_CONTROL:
-	case WM8962_SPKOUTL_VOLUME:
-	case WM8962_SPKOUTR_VOLUME:
-	case WM8962_THERMAL_SHUTDOWN_STATUS:
-	case WM8962_ADDITIONAL_CONTROL_4:
-	case WM8962_CLASS_D_CONTROL_1:
-	case WM8962_CLASS_D_CONTROL_2:
-	case WM8962_CLOCKING_4:
-	case WM8962_DAC_DSP_MIXING_1:
-	case WM8962_DAC_DSP_MIXING_2:
-	case WM8962_DC_SERVO_0:
-	case WM8962_DC_SERVO_1:
-	case WM8962_DC_SERVO_4:
-	case WM8962_DC_SERVO_6:
-	case WM8962_ANALOGUE_PGA_BIAS:
-	case WM8962_ANALOGUE_HP_0:
-	case WM8962_ANALOGUE_HP_2:
-	case WM8962_CHARGE_PUMP_1:
-	case WM8962_CHARGE_PUMP_B:
-	case WM8962_WRITE_SEQUENCER_CONTROL_1:
-	case WM8962_WRITE_SEQUENCER_CONTROL_2:
-	case WM8962_WRITE_SEQUENCER_CONTROL_3:
-	case WM8962_CONTROL_INTERFACE:
-	case WM8962_MIXER_ENABLES:
-	case WM8962_HEADPHONE_MIXER_1:
-	case WM8962_HEADPHONE_MIXER_2:
-	case WM8962_HEADPHONE_MIXER_3:
-	case WM8962_HEADPHONE_MIXER_4:
-	case WM8962_SPEAKER_MIXER_1:
-	case WM8962_SPEAKER_MIXER_2:
-	case WM8962_SPEAKER_MIXER_3:
-	case WM8962_SPEAKER_MIXER_4:
-	case WM8962_SPEAKER_MIXER_5:
-	case WM8962_BEEP_GENERATOR_1:
-	case WM8962_OSCILLATOR_TRIM_3:
-	case WM8962_OSCILLATOR_TRIM_4:
-	case WM8962_OSCILLATOR_TRIM_7:
-	case WM8962_ANALOGUE_CLOCKING1:
-	case WM8962_ANALOGUE_CLOCKING2:
-	case WM8962_ANALOGUE_CLOCKING3:
-	case WM8962_PLL_SOFTWARE_RESET:
-	case WM8962_PLL2:
-	case WM8962_PLL_4:
-	case WM8962_PLL_9:
-	case WM8962_PLL_10:
-	case WM8962_PLL_11:
-	case WM8962_PLL_12:
-	case WM8962_PLL_13:
-	case WM8962_PLL_14:
-	case WM8962_PLL_15:
-	case WM8962_PLL_16:
-	case WM8962_FLL_CONTROL_1:
-	case WM8962_FLL_CONTROL_2:
-	case WM8962_FLL_CONTROL_3:
-	case WM8962_FLL_CONTROL_5:
-	case WM8962_FLL_CONTROL_6:
-	case WM8962_FLL_CONTROL_7:
-	case WM8962_FLL_CONTROL_8:
-	case WM8962_GENERAL_TEST_1:
-	case WM8962_DF1:
-	case WM8962_DF2:
-	case WM8962_DF3:
-	case WM8962_DF4:
-	case WM8962_DF5:
-	case WM8962_DF6:
-	case WM8962_DF7:
-	case WM8962_LHPF1:
-	case WM8962_LHPF2:
-	case WM8962_THREED1:
-	case WM8962_THREED2:
-	case WM8962_THREED3:
-	case WM8962_THREED4:
-	case WM8962_DRC_1:
-	case WM8962_DRC_2:
-	case WM8962_DRC_3:
-	case WM8962_DRC_4:
-	case WM8962_DRC_5:
-	case WM8962_TLOOPBACK:
-	case WM8962_EQ1:
-	case WM8962_EQ2:
-	case WM8962_EQ3:
-	case WM8962_EQ4:
-	case WM8962_EQ5:
-	case WM8962_EQ6:
-	case WM8962_EQ7:
-	case WM8962_EQ8:
-	case WM8962_EQ9:
-	case WM8962_EQ10:
-	case WM8962_EQ11:
-	case WM8962_EQ12:
-	case WM8962_EQ13:
-	case WM8962_EQ14:
-	case WM8962_EQ15:
-	case WM8962_EQ16:
-	case WM8962_EQ17:
-	case WM8962_EQ18:
-	case WM8962_EQ19:
-	case WM8962_EQ20:
-	case WM8962_EQ21:
-	case WM8962_EQ22:
-	case WM8962_EQ23:
-	case WM8962_EQ24:
-	case WM8962_EQ25:
-	case WM8962_EQ26:
-	case WM8962_EQ27:
-	case WM8962_EQ28:
-	case WM8962_EQ29:
-	case WM8962_EQ30:
-	case WM8962_EQ31:
-	case WM8962_EQ32:
-	case WM8962_EQ33:
-	case WM8962_EQ34:
-	case WM8962_EQ35:
-	case WM8962_EQ36:
-	case WM8962_EQ37:
-	case WM8962_EQ38:
-	case WM8962_EQ39:
-	case WM8962_EQ40:
-	case WM8962_EQ41:
-	case WM8962_GPIO_BASE:
-	case WM8962_GPIO_2:
-	case WM8962_GPIO_3:
-	case WM8962_GPIO_5:
-	case WM8962_GPIO_6:
-	case WM8962_INTERRUPT_STATUS_1:
-	case WM8962_INTERRUPT_STATUS_2:
-	case WM8962_INTERRUPT_STATUS_1_MASK:
-	case WM8962_INTERRUPT_STATUS_2_MASK:
-	case WM8962_INTERRUPT_CONTROL:
-	case WM8962_IRQ_DEBOUNCE:
-	case WM8962_MICINT_SOURCE_POL:
-	case WM8962_DSP2_POWER_MANAGEMENT:
-	case WM8962_DSP2_EXECCONTROL:
-	case WM8962_DSP2_INSTRUCTION_RAM_0:
-	case WM8962_DSP2_ADDRESS_RAM_2:
-	case WM8962_DSP2_ADDRESS_RAM_1:
-	case WM8962_DSP2_ADDRESS_RAM_0:
-	case WM8962_DSP2_DATA1_RAM_1:
-	case WM8962_DSP2_DATA1_RAM_0:
-	case WM8962_DSP2_DATA2_RAM_1:
-	case WM8962_DSP2_DATA2_RAM_0:
-	case WM8962_DSP2_DATA3_RAM_1:
-	case WM8962_DSP2_DATA3_RAM_0:
-	case WM8962_DSP2_COEFF_RAM_0:
-	case WM8962_RETUNEADC_SHARED_COEFF_1:
-	case WM8962_RETUNEADC_SHARED_COEFF_0:
-	case WM8962_RETUNEDAC_SHARED_COEFF_1:
-	case WM8962_RETUNEDAC_SHARED_COEFF_0:
-	case WM8962_SOUNDSTAGE_ENABLES_1:
-	case WM8962_SOUNDSTAGE_ENABLES_0:
-	case WM8962_HDBASS_AI_1:
-	case WM8962_HDBASS_AI_0:
-	case WM8962_HDBASS_AR_1:
-	case WM8962_HDBASS_AR_0:
-	case WM8962_HDBASS_B_1:
-	case WM8962_HDBASS_B_0:
-	case WM8962_HDBASS_K_1:
-	case WM8962_HDBASS_K_0:
-	case WM8962_HDBASS_N1_1:
-	case WM8962_HDBASS_N1_0:
-	case WM8962_HDBASS_N2_1:
-	case WM8962_HDBASS_N2_0:
-	case WM8962_HDBASS_N3_1:
-	case WM8962_HDBASS_N3_0:
-	case WM8962_HDBASS_N4_1:
-	case WM8962_HDBASS_N4_0:
-	case WM8962_HDBASS_N5_1:
-	case WM8962_HDBASS_N5_0:
-	case WM8962_HDBASS_X1_1:
-	case WM8962_HDBASS_X1_0:
-	case WM8962_HDBASS_X2_1:
-	case WM8962_HDBASS_X2_0:
-	case WM8962_HDBASS_X3_1:
-	case WM8962_HDBASS_X3_0:
-	case WM8962_HDBASS_ATK_1:
-	case WM8962_HDBASS_ATK_0:
-	case WM8962_HDBASS_DCY_1:
-	case WM8962_HDBASS_DCY_0:
-	case WM8962_HDBASS_PG_1:
-	case WM8962_HDBASS_PG_0:
-	case WM8962_HPF_C_1:
-	case WM8962_HPF_C_0:
-	case WM8962_ADCL_RETUNE_C1_1:
-	case WM8962_ADCL_RETUNE_C1_0:
-	case WM8962_ADCL_RETUNE_C2_1:
-	case WM8962_ADCL_RETUNE_C2_0:
-	case WM8962_ADCL_RETUNE_C3_1:
-	case WM8962_ADCL_RETUNE_C3_0:
-	case WM8962_ADCL_RETUNE_C4_1:
-	case WM8962_ADCL_RETUNE_C4_0:
-	case WM8962_ADCL_RETUNE_C5_1:
-	case WM8962_ADCL_RETUNE_C5_0:
-	case WM8962_ADCL_RETUNE_C6_1:
-	case WM8962_ADCL_RETUNE_C6_0:
-	case WM8962_ADCL_RETUNE_C7_1:
-	case WM8962_ADCL_RETUNE_C7_0:
-	case WM8962_ADCL_RETUNE_C8_1:
-	case WM8962_ADCL_RETUNE_C8_0:
-	case WM8962_ADCL_RETUNE_C9_1:
-	case WM8962_ADCL_RETUNE_C9_0:
-	case WM8962_ADCL_RETUNE_C10_1:
-	case WM8962_ADCL_RETUNE_C10_0:
-	case WM8962_ADCL_RETUNE_C11_1:
-	case WM8962_ADCL_RETUNE_C11_0:
-	case WM8962_ADCL_RETUNE_C12_1:
-	case WM8962_ADCL_RETUNE_C12_0:
-	case WM8962_ADCL_RETUNE_C13_1:
-	case WM8962_ADCL_RETUNE_C13_0:
-	case WM8962_ADCL_RETUNE_C14_1:
-	case WM8962_ADCL_RETUNE_C14_0:
-	case WM8962_ADCL_RETUNE_C15_1:
-	case WM8962_ADCL_RETUNE_C15_0:
-	case WM8962_ADCL_RETUNE_C16_1:
-	case WM8962_ADCL_RETUNE_C16_0:
-	case WM8962_ADCL_RETUNE_C17_1:
-	case WM8962_ADCL_RETUNE_C17_0:
-	case WM8962_ADCL_RETUNE_C18_1:
-	case WM8962_ADCL_RETUNE_C18_0:
-	case WM8962_ADCL_RETUNE_C19_1:
-	case WM8962_ADCL_RETUNE_C19_0:
-	case WM8962_ADCL_RETUNE_C20_1:
-	case WM8962_ADCL_RETUNE_C20_0:
-	case WM8962_ADCL_RETUNE_C21_1:
-	case WM8962_ADCL_RETUNE_C21_0:
-	case WM8962_ADCL_RETUNE_C22_1:
-	case WM8962_ADCL_RETUNE_C22_0:
-	case WM8962_ADCL_RETUNE_C23_1:
-	case WM8962_ADCL_RETUNE_C23_0:
-	case WM8962_ADCL_RETUNE_C24_1:
-	case WM8962_ADCL_RETUNE_C24_0:
-	case WM8962_ADCL_RETUNE_C25_1:
-	case WM8962_ADCL_RETUNE_C25_0:
-	case WM8962_ADCL_RETUNE_C26_1:
-	case WM8962_ADCL_RETUNE_C26_0:
-	case WM8962_ADCL_RETUNE_C27_1:
-	case WM8962_ADCL_RETUNE_C27_0:
-	case WM8962_ADCL_RETUNE_C28_1:
-	case WM8962_ADCL_RETUNE_C28_0:
-	case WM8962_ADCL_RETUNE_C29_1:
-	case WM8962_ADCL_RETUNE_C29_0:
-	case WM8962_ADCL_RETUNE_C30_1:
-	case WM8962_ADCL_RETUNE_C30_0:
-	case WM8962_ADCL_RETUNE_C31_1:
-	case WM8962_ADCL_RETUNE_C31_0:
-	case WM8962_ADCL_RETUNE_C32_1:
-	case WM8962_ADCL_RETUNE_C32_0:
-	case WM8962_RETUNEADC_PG2_1:
-	case WM8962_RETUNEADC_PG2_0:
-	case WM8962_RETUNEADC_PG_1:
-	case WM8962_RETUNEADC_PG_0:
-	case WM8962_ADCR_RETUNE_C1_1:
-	case WM8962_ADCR_RETUNE_C1_0:
-	case WM8962_ADCR_RETUNE_C2_1:
-	case WM8962_ADCR_RETUNE_C2_0:
-	case WM8962_ADCR_RETUNE_C3_1:
-	case WM8962_ADCR_RETUNE_C3_0:
-	case WM8962_ADCR_RETUNE_C4_1:
-	case WM8962_ADCR_RETUNE_C4_0:
-	case WM8962_ADCR_RETUNE_C5_1:
-	case WM8962_ADCR_RETUNE_C5_0:
-	case WM8962_ADCR_RETUNE_C6_1:
-	case WM8962_ADCR_RETUNE_C6_0:
-	case WM8962_ADCR_RETUNE_C7_1:
-	case WM8962_ADCR_RETUNE_C7_0:
-	case WM8962_ADCR_RETUNE_C8_1:
-	case WM8962_ADCR_RETUNE_C8_0:
-	case WM8962_ADCR_RETUNE_C9_1:
-	case WM8962_ADCR_RETUNE_C9_0:
-	case WM8962_ADCR_RETUNE_C10_1:
-	case WM8962_ADCR_RETUNE_C10_0:
-	case WM8962_ADCR_RETUNE_C11_1:
-	case WM8962_ADCR_RETUNE_C11_0:
-	case WM8962_ADCR_RETUNE_C12_1:
-	case WM8962_ADCR_RETUNE_C12_0:
-	case WM8962_ADCR_RETUNE_C13_1:
-	case WM8962_ADCR_RETUNE_C13_0:
-	case WM8962_ADCR_RETUNE_C14_1:
-	case WM8962_ADCR_RETUNE_C14_0:
-	case WM8962_ADCR_RETUNE_C15_1:
-	case WM8962_ADCR_RETUNE_C15_0:
-	case WM8962_ADCR_RETUNE_C16_1:
-	case WM8962_ADCR_RETUNE_C16_0:
-	case WM8962_ADCR_RETUNE_C17_1:
-	case WM8962_ADCR_RETUNE_C17_0:
-	case WM8962_ADCR_RETUNE_C18_1:
-	case WM8962_ADCR_RETUNE_C18_0:
-	case WM8962_ADCR_RETUNE_C19_1:
-	case WM8962_ADCR_RETUNE_C19_0:
-	case WM8962_ADCR_RETUNE_C20_1:
-	case WM8962_ADCR_RETUNE_C20_0:
-	case WM8962_ADCR_RETUNE_C21_1:
-	case WM8962_ADCR_RETUNE_C21_0:
-	case WM8962_ADCR_RETUNE_C22_1:
-	case WM8962_ADCR_RETUNE_C22_0:
-	case WM8962_ADCR_RETUNE_C23_1:
-	case WM8962_ADCR_RETUNE_C23_0:
-	case WM8962_ADCR_RETUNE_C24_1:
-	case WM8962_ADCR_RETUNE_C24_0:
-	case WM8962_ADCR_RETUNE_C25_1:
-	case WM8962_ADCR_RETUNE_C25_0:
-	case WM8962_ADCR_RETUNE_C26_1:
-	case WM8962_ADCR_RETUNE_C26_0:
-	case WM8962_ADCR_RETUNE_C27_1:
-	case WM8962_ADCR_RETUNE_C27_0:
-	case WM8962_ADCR_RETUNE_C28_1:
-	case WM8962_ADCR_RETUNE_C28_0:
-	case WM8962_ADCR_RETUNE_C29_1:
-	case WM8962_ADCR_RETUNE_C29_0:
-	case WM8962_ADCR_RETUNE_C30_1:
-	case WM8962_ADCR_RETUNE_C30_0:
-	case WM8962_ADCR_RETUNE_C31_1:
-	case WM8962_ADCR_RETUNE_C31_0:
-	case WM8962_ADCR_RETUNE_C32_1:
-	case WM8962_ADCR_RETUNE_C32_0:
-	case WM8962_DACL_RETUNE_C1_1:
-	case WM8962_DACL_RETUNE_C1_0:
-	case WM8962_DACL_RETUNE_C2_1:
-	case WM8962_DACL_RETUNE_C2_0:
-	case WM8962_DACL_RETUNE_C3_1:
-	case WM8962_DACL_RETUNE_C3_0:
-	case WM8962_DACL_RETUNE_C4_1:
-	case WM8962_DACL_RETUNE_C4_0:
-	case WM8962_DACL_RETUNE_C5_1:
-	case WM8962_DACL_RETUNE_C5_0:
-	case WM8962_DACL_RETUNE_C6_1:
-	case WM8962_DACL_RETUNE_C6_0:
-	case WM8962_DACL_RETUNE_C7_1:
-	case WM8962_DACL_RETUNE_C7_0:
-	case WM8962_DACL_RETUNE_C8_1:
-	case WM8962_DACL_RETUNE_C8_0:
-	case WM8962_DACL_RETUNE_C9_1:
-	case WM8962_DACL_RETUNE_C9_0:
-	case WM8962_DACL_RETUNE_C10_1:
-	case WM8962_DACL_RETUNE_C10_0:
-	case WM8962_DACL_RETUNE_C11_1:
-	case WM8962_DACL_RETUNE_C11_0:
-	case WM8962_DACL_RETUNE_C12_1:
-	case WM8962_DACL_RETUNE_C12_0:
-	case WM8962_DACL_RETUNE_C13_1:
-	case WM8962_DACL_RETUNE_C13_0:
-	case WM8962_DACL_RETUNE_C14_1:
-	case WM8962_DACL_RETUNE_C14_0:
-	case WM8962_DACL_RETUNE_C15_1:
-	case WM8962_DACL_RETUNE_C15_0:
-	case WM8962_DACL_RETUNE_C16_1:
-	case WM8962_DACL_RETUNE_C16_0:
-	case WM8962_DACL_RETUNE_C17_1:
-	case WM8962_DACL_RETUNE_C17_0:
-	case WM8962_DACL_RETUNE_C18_1:
-	case WM8962_DACL_RETUNE_C18_0:
-	case WM8962_DACL_RETUNE_C19_1:
-	case WM8962_DACL_RETUNE_C19_0:
-	case WM8962_DACL_RETUNE_C20_1:
-	case WM8962_DACL_RETUNE_C20_0:
-	case WM8962_DACL_RETUNE_C21_1:
-	case WM8962_DACL_RETUNE_C21_0:
-	case WM8962_DACL_RETUNE_C22_1:
-	case WM8962_DACL_RETUNE_C22_0:
-	case WM8962_DACL_RETUNE_C23_1:
-	case WM8962_DACL_RETUNE_C23_0:
-	case WM8962_DACL_RETUNE_C24_1:
-	case WM8962_DACL_RETUNE_C24_0:
-	case WM8962_DACL_RETUNE_C25_1:
-	case WM8962_DACL_RETUNE_C25_0:
-	case WM8962_DACL_RETUNE_C26_1:
-	case WM8962_DACL_RETUNE_C26_0:
-	case WM8962_DACL_RETUNE_C27_1:
-	case WM8962_DACL_RETUNE_C27_0:
-	case WM8962_DACL_RETUNE_C28_1:
-	case WM8962_DACL_RETUNE_C28_0:
-	case WM8962_DACL_RETUNE_C29_1:
-	case WM8962_DACL_RETUNE_C29_0:
-	case WM8962_DACL_RETUNE_C30_1:
-	case WM8962_DACL_RETUNE_C30_0:
-	case WM8962_DACL_RETUNE_C31_1:
-	case WM8962_DACL_RETUNE_C31_0:
-	case WM8962_DACL_RETUNE_C32_1:
-	case WM8962_DACL_RETUNE_C32_0:
-	case WM8962_RETUNEDAC_PG2_1:
-	case WM8962_RETUNEDAC_PG2_0:
-	case WM8962_RETUNEDAC_PG_1:
-	case WM8962_RETUNEDAC_PG_0:
-	case WM8962_DACR_RETUNE_C1_1:
-	case WM8962_DACR_RETUNE_C1_0:
-	case WM8962_DACR_RETUNE_C2_1:
-	case WM8962_DACR_RETUNE_C2_0:
-	case WM8962_DACR_RETUNE_C3_1:
-	case WM8962_DACR_RETUNE_C3_0:
-	case WM8962_DACR_RETUNE_C4_1:
-	case WM8962_DACR_RETUNE_C4_0:
-	case WM8962_DACR_RETUNE_C5_1:
-	case WM8962_DACR_RETUNE_C5_0:
-	case WM8962_DACR_RETUNE_C6_1:
-	case WM8962_DACR_RETUNE_C6_0:
-	case WM8962_DACR_RETUNE_C7_1:
-	case WM8962_DACR_RETUNE_C7_0:
-	case WM8962_DACR_RETUNE_C8_1:
-	case WM8962_DACR_RETUNE_C8_0:
-	case WM8962_DACR_RETUNE_C9_1:
-	case WM8962_DACR_RETUNE_C9_0:
-	case WM8962_DACR_RETUNE_C10_1:
-	case WM8962_DACR_RETUNE_C10_0:
-	case WM8962_DACR_RETUNE_C11_1:
-	case WM8962_DACR_RETUNE_C11_0:
-	case WM8962_DACR_RETUNE_C12_1:
-	case WM8962_DACR_RETUNE_C12_0:
-	case WM8962_DACR_RETUNE_C13_1:
-	case WM8962_DACR_RETUNE_C13_0:
-	case WM8962_DACR_RETUNE_C14_1:
-	case WM8962_DACR_RETUNE_C14_0:
-	case WM8962_DACR_RETUNE_C15_1:
-	case WM8962_DACR_RETUNE_C15_0:
-	case WM8962_DACR_RETUNE_C16_1:
-	case WM8962_DACR_RETUNE_C16_0:
-	case WM8962_DACR_RETUNE_C17_1:
-	case WM8962_DACR_RETUNE_C17_0:
-	case WM8962_DACR_RETUNE_C18_1:
-	case WM8962_DACR_RETUNE_C18_0:
-	case WM8962_DACR_RETUNE_C19_1:
-	case WM8962_DACR_RETUNE_C19_0:
-	case WM8962_DACR_RETUNE_C20_1:
-	case WM8962_DACR_RETUNE_C20_0:
-	case WM8962_DACR_RETUNE_C21_1:
-	case WM8962_DACR_RETUNE_C21_0:
-	case WM8962_DACR_RETUNE_C22_1:
-	case WM8962_DACR_RETUNE_C22_0:
-	case WM8962_DACR_RETUNE_C23_1:
-	case WM8962_DACR_RETUNE_C23_0:
-	case WM8962_DACR_RETUNE_C24_1:
-	case WM8962_DACR_RETUNE_C24_0:
-	case WM8962_DACR_RETUNE_C25_1:
-	case WM8962_DACR_RETUNE_C25_0:
-	case WM8962_DACR_RETUNE_C26_1:
-	case WM8962_DACR_RETUNE_C26_0:
-	case WM8962_DACR_RETUNE_C27_1:
-	case WM8962_DACR_RETUNE_C27_0:
-	case WM8962_DACR_RETUNE_C28_1:
-	case WM8962_DACR_RETUNE_C28_0:
-	case WM8962_DACR_RETUNE_C29_1:
-	case WM8962_DACR_RETUNE_C29_0:
-	case WM8962_DACR_RETUNE_C30_1:
-	case WM8962_DACR_RETUNE_C30_0:
-	case WM8962_DACR_RETUNE_C31_1:
-	case WM8962_DACR_RETUNE_C31_0:
-	case WM8962_DACR_RETUNE_C32_1:
-	case WM8962_DACR_RETUNE_C32_0:
-	case WM8962_VSS_XHD2_1:
-	case WM8962_VSS_XHD2_0:
-	case WM8962_VSS_XHD3_1:
-	case WM8962_VSS_XHD3_0:
-	case WM8962_VSS_XHN1_1:
-	case WM8962_VSS_XHN1_0:
-	case WM8962_VSS_XHN2_1:
-	case WM8962_VSS_XHN2_0:
-	case WM8962_VSS_XHN3_1:
-	case WM8962_VSS_XHN3_0:
-	case WM8962_VSS_XLA_1:
-	case WM8962_VSS_XLA_0:
-	case WM8962_VSS_XLB_1:
-	case WM8962_VSS_XLB_0:
-	case WM8962_VSS_XLG_1:
-	case WM8962_VSS_XLG_0:
-	case WM8962_VSS_PG2_1:
-	case WM8962_VSS_PG2_0:
-	case WM8962_VSS_PG_1:
-	case WM8962_VSS_PG_0:
-	case WM8962_VSS_XTD1_1:
-	case WM8962_VSS_XTD1_0:
-	case WM8962_VSS_XTD2_1:
-	case WM8962_VSS_XTD2_0:
-	case WM8962_VSS_XTD3_1:
-	case WM8962_VSS_XTD3_0:
-	case WM8962_VSS_XTD4_1:
-	case WM8962_VSS_XTD4_0:
-	case WM8962_VSS_XTD5_1:
-	case WM8962_VSS_XTD5_0:
-	case WM8962_VSS_XTD6_1:
-	case WM8962_VSS_XTD6_0:
-	case WM8962_VSS_XTD7_1:
-	case WM8962_VSS_XTD7_0:
-	case WM8962_VSS_XTD8_1:
-	case WM8962_VSS_XTD8_0:
-	case WM8962_VSS_XTD9_1:
-	case WM8962_VSS_XTD9_0:
-	case WM8962_VSS_XTD10_1:
-	case WM8962_VSS_XTD10_0:
-	case WM8962_VSS_XTD11_1:
-	case WM8962_VSS_XTD11_0:
-	case WM8962_VSS_XTD12_1:
-	case WM8962_VSS_XTD12_0:
-	case WM8962_VSS_XTD13_1:
-	case WM8962_VSS_XTD13_0:
-	case WM8962_VSS_XTD14_1:
-	case WM8962_VSS_XTD14_0:
-	case WM8962_VSS_XTD15_1:
-	case WM8962_VSS_XTD15_0:
-	case WM8962_VSS_XTD16_1:
-	case WM8962_VSS_XTD16_0:
-	case WM8962_VSS_XTD17_1:
-	case WM8962_VSS_XTD17_0:
-	case WM8962_VSS_XTD18_1:
-	case WM8962_VSS_XTD18_0:
-	case WM8962_VSS_XTD19_1:
-	case WM8962_VSS_XTD19_0:
-	case WM8962_VSS_XTD20_1:
-	case WM8962_VSS_XTD20_0:
-	case WM8962_VSS_XTD21_1:
-	case WM8962_VSS_XTD21_0:
-	case WM8962_VSS_XTD22_1:
-	case WM8962_VSS_XTD22_0:
-	case WM8962_VSS_XTD23_1:
-	case WM8962_VSS_XTD23_0:
-	case WM8962_VSS_XTD24_1:
-	case WM8962_VSS_XTD24_0:
-	case WM8962_VSS_XTD25_1:
-	case WM8962_VSS_XTD25_0:
-	case WM8962_VSS_XTD26_1:
-	case WM8962_VSS_XTD26_0:
-	case WM8962_VSS_XTD27_1:
-	case WM8962_VSS_XTD27_0:
-	case WM8962_VSS_XTD28_1:
-	case WM8962_VSS_XTD28_0:
-	case WM8962_VSS_XTD29_1:
-	case WM8962_VSS_XTD29_0:
-	case WM8962_VSS_XTD30_1:
-	case WM8962_VSS_XTD30_0:
-	case WM8962_VSS_XTD31_1:
-	case WM8962_VSS_XTD31_0:
-	case WM8962_VSS_XTD32_1:
-	case WM8962_VSS_XTD32_0:
-	case WM8962_VSS_XTS1_1:
-	case WM8962_VSS_XTS1_0:
-	case WM8962_VSS_XTS2_1:
-	case WM8962_VSS_XTS2_0:
-	case WM8962_VSS_XTS3_1:
-	case WM8962_VSS_XTS3_0:
-	case WM8962_VSS_XTS4_1:
-	case WM8962_VSS_XTS4_0:
-	case WM8962_VSS_XTS5_1:
-	case WM8962_VSS_XTS5_0:
-	case WM8962_VSS_XTS6_1:
-	case WM8962_VSS_XTS6_0:
-	case WM8962_VSS_XTS7_1:
-	case WM8962_VSS_XTS7_0:
-	case WM8962_VSS_XTS8_1:
-	case WM8962_VSS_XTS8_0:
-	case WM8962_VSS_XTS9_1:
-	case WM8962_VSS_XTS9_0:
-	case WM8962_VSS_XTS10_1:
-	case WM8962_VSS_XTS10_0:
-	case WM8962_VSS_XTS11_1:
-	case WM8962_VSS_XTS11_0:
-	case WM8962_VSS_XTS12_1:
-	case WM8962_VSS_XTS12_0:
-	case WM8962_VSS_XTS13_1:
-	case WM8962_VSS_XTS13_0:
-	case WM8962_VSS_XTS14_1:
-	case WM8962_VSS_XTS14_0:
-	case WM8962_VSS_XTS15_1:
-	case WM8962_VSS_XTS15_0:
-	case WM8962_VSS_XTS16_1:
-	case WM8962_VSS_XTS16_0:
-	case WM8962_VSS_XTS17_1:
-	case WM8962_VSS_XTS17_0:
-	case WM8962_VSS_XTS18_1:
-	case WM8962_VSS_XTS18_0:
-	case WM8962_VSS_XTS19_1:
-	case WM8962_VSS_XTS19_0:
-	case WM8962_VSS_XTS20_1:
-	case WM8962_VSS_XTS20_0:
-	case WM8962_VSS_XTS21_1:
-	case WM8962_VSS_XTS21_0:
-	case WM8962_VSS_XTS22_1:
-	case WM8962_VSS_XTS22_0:
-	case WM8962_VSS_XTS23_1:
-	case WM8962_VSS_XTS23_0:
-	case WM8962_VSS_XTS24_1:
-	case WM8962_VSS_XTS24_0:
-	case WM8962_VSS_XTS25_1:
-	case WM8962_VSS_XTS25_0:
-	case WM8962_VSS_XTS26_1:
-	case WM8962_VSS_XTS26_0:
-	case WM8962_VSS_XTS27_1:
-	case WM8962_VSS_XTS27_0:
-	case WM8962_VSS_XTS28_1:
-	case WM8962_VSS_XTS28_0:
-	case WM8962_VSS_XTS29_1:
-	case WM8962_VSS_XTS29_0:
-	case WM8962_VSS_XTS30_1:
-	case WM8962_VSS_XTS30_0:
-	case WM8962_VSS_XTS31_1:
-	case WM8962_VSS_XTS31_0:
-	case WM8962_VSS_XTS32_1:
-	case WM8962_VSS_XTS32_0:
-		return true;
-	default:
-		return false;
-	}
+	if (wm8962_reg_access[reg].read)
+		return 1;
+	else
+		return 0;
 }
 
-static int wm8962_reset(struct wm8962_priv *wm8962)
+static int wm8962_reset(struct snd_soc_codec *codec)
 {
 	int ret;
 
-	ret = regmap_write(wm8962->regmap, WM8962_SOFTWARE_RESET, 0x6243);
+	ret = snd_soc_write(codec, WM8962_SOFTWARE_RESET, 0x6243);
 	if (ret != 0)
 		return ret;
 
-	return regmap_write(wm8962->regmap, WM8962_PLL_SOFTWARE_RESET, 0);
+	return snd_soc_write(codec, WM8962_PLL_SOFTWARE_RESET, 0);
 }
 
 static const DECLARE_TLV_DB_SCALE(inpga_tlv, -2325, 75, 0);
@@ -1702,8 +2221,6 @@ SOC_DOUBLE_R_TLV("Sidetone Volume", WM8962_DAC_DSP_MIXING_1,
 SOC_DOUBLE_R_TLV("Digital Playback Volume", WM8962_LEFT_DAC_VOLUME,
 		 WM8962_RIGHT_DAC_VOLUME, 1, 127, 0, digital_tlv),
 SOC_SINGLE("DAC High Performance Switch", WM8962_ADC_DAC_CONTROL_2, 0, 1, 0),
-SOC_SINGLE("DAC L/R Swap Switch", WM8962_AUDIO_INTERFACE_0, 5, 1, 0),
-SOC_SINGLE("ADC L/R Swap Switch", WM8962_AUDIO_INTERFACE_0, 8, 1, 0),
 
 SOC_SINGLE("ADC High Performance Switch", WM8962_ADDITIONAL_CONTROL_1,
 	   5, 1, 0),
@@ -1820,6 +2337,61 @@ SOC_SINGLE_TLV("SPKOUTR Mixer DACR Volume", WM8962_SPEAKER_MIXER_5,
 	       4, 1, 0, inmix_tlv),
 };
 
+static int sysclk_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);
+	unsigned long timeout;
+	int src;
+	int fll;
+
+	src = snd_soc_read(codec, WM8962_CLOCKING2) & WM8962_SYSCLK_SRC_MASK;
+
+	switch (src) {
+	case 0:      /* MCLK */
+		fll = 0;
+		break;
+	case 0x200:  /* FLL */
+		fll = 1;
+		break;
+	default:
+		dev_err(codec->dev, "Unknown SYSCLK source %x\n", src);
+		return -EINVAL;
+	}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		if (fll) {
+			try_wait_for_completion(&wm8962->fll_lock);
+
+			snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
+					    WM8962_FLL_ENA, WM8962_FLL_ENA);
+
+			timeout = msecs_to_jiffies(5);
+			timeout = wait_for_completion_timeout(&wm8962->fll_lock,
+							      timeout);
+
+			if (wm8962->irq && timeout == 0)
+				dev_err(codec->dev,
+					"Timed out starting FLL\n");
+		}
+		break;
+
+	case SND_SOC_DAPM_POST_PMD:
+		/* After Power-down, close FLL if FLL-enabled */
+		snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
+				WM8962_FLL_ENA, 0);
+		break;
+
+	default:
+		BUG();
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int cp_event(struct snd_soc_dapm_widget *w,
 		    struct snd_kcontrol *kcontrol, int event)
 {
@@ -1988,7 +2560,7 @@ static int dsp2_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
-static const char *st_text[] = { "None", "Left", "Right" };
+static const char *st_text[] = { "None", "Right", "Left" };
 
 static const struct soc_enum str_enum =
 	SOC_ENUM_SINGLE(WM8962_DAC_DSP_MIXING_1, 2, 3, st_text);
@@ -2099,21 +2671,22 @@ SND_SOC_DAPM_INPUT("IN3L"),
 SND_SOC_DAPM_INPUT("IN3R"),
 SND_SOC_DAPM_INPUT("IN4L"),
 SND_SOC_DAPM_INPUT("IN4R"),
-SND_SOC_DAPM_SIGGEN("Beep"),
+SND_SOC_DAPM_INPUT("Beep"),
 SND_SOC_DAPM_INPUT("DMICDAT"),
 
 SND_SOC_DAPM_SUPPLY("MICBIAS", WM8962_PWR_MGMT_1, 1, 0, NULL, 0),
 
 SND_SOC_DAPM_SUPPLY("Class G", WM8962_CHARGE_PUMP_B, 0, 1, NULL, 0),
-SND_SOC_DAPM_SUPPLY("SYSCLK", WM8962_CLOCKING2, 5, 0, NULL, 0),
+SND_SOC_DAPM_SUPPLY("SYSCLK", WM8962_CLOCKING2, 5, 0, sysclk_event,
+		    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
 SND_SOC_DAPM_SUPPLY("Charge Pump", WM8962_CHARGE_PUMP_1, 0, 0, cp_event,
 		    SND_SOC_DAPM_POST_PMU),
 SND_SOC_DAPM_SUPPLY("TOCLK", WM8962_ADDITIONAL_CONTROL_1, 0, 0, NULL, 0),
+SND_SOC_DAPM_SUPPLY("TEMP_HP", WM8962_ADDITIONAL_CONTROL_4, 2, 0, NULL, 0),
+SND_SOC_DAPM_SUPPLY("TEMP_SPK", WM8962_ADDITIONAL_CONTROL_4, 1, 0, NULL, 0),
 SND_SOC_DAPM_SUPPLY_S("DSP2", 1, WM8962_DSP2_POWER_MANAGEMENT,
 		      WM8962_DSP2_ENA_SHIFT, 0, dsp2_event,
 		      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-SND_SOC_DAPM_SUPPLY("TEMP_HP", WM8962_ADDITIONAL_CONTROL_4, 2, 0, NULL, 0),
-SND_SOC_DAPM_SUPPLY("TEMP_SPK", WM8962_ADDITIONAL_CONTROL_4, 1, 0, NULL, 0),
 
 SND_SOC_DAPM_MIXER("INPGAL", WM8962_LEFT_INPUT_PGA_CONTROL, 4, 0,
 		   inpgal, ARRAY_SIZE(inpgal)),
@@ -2219,11 +2792,9 @@ static const struct snd_soc_dapm_route wm8962_intercon[] = {
 
 	{ "STL", "Left", "ADCL" },
 	{ "STL", "Right", "ADCR" },
-	{ "STL", NULL, "Class G" },
 
 	{ "STR", "Left", "ADCL" },
 	{ "STR", "Right", "ADCR" },
-	{ "STR", NULL, "Class G" },
 
 	{ "DACL", NULL, "SYSCLK" },
 	{ "DACL", NULL, "TOCLK" },
@@ -2369,13 +2940,40 @@ static int wm8962_add_widgets(struct snd_soc_codec *codec)
 	return 0;
 }
 
+static void wm8962_sync_cache(struct snd_soc_codec *codec)
+{
+	u16 *reg_cache = codec->reg_cache;
+	int i;
+
+	if (!codec->cache_sync)
+		return;
+
+	dev_dbg(codec->dev, "Syncing cache\n");
+
+	codec->cache_only = 0;
+
+	/* Sync back cached values if they're different from the
+	 * hardware default.
+	 */
+	for (i = 1; i < codec->driver->reg_cache_size; i++) {
+		if (i == WM8962_SOFTWARE_RESET)
+			continue;
+		if (reg_cache[i] == wm8962_reg[i])
+			continue;
+
+		snd_soc_write(codec, i, reg_cache[i]);
+	}
+
+	codec->cache_sync = 0;
+}
+
 /* -1 for reserved values */
 static const int bclk_divs[] = {
 	1, -1, 2, 3, 4, -1, 6, 8, -1, 12, 16, 24, -1, 32, 32, 32
 };
 
 static const int sysclk_rates[] = {
-	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536, 3072, 6144
+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536,
 };
 
 static void wm8962_configure_bclk(struct snd_soc_codec *codec)
@@ -2409,8 +3007,6 @@ static void wm8962_configure_bclk(struct snd_soc_codec *codec)
 		return;
 	}
 
-	dev_dbg(codec->dev, "Selected sysclk ratio %d\n", sysclk_rates[i]);
-
 	snd_soc_update_bits(codec, WM8962_CLOCKING_4,
 			    WM8962_SYSCLK_RATE_MASK, clocking4);
 
@@ -2469,6 +3065,9 @@ static void wm8962_configure_bclk(struct snd_soc_codec *codec)
 static int wm8962_set_bias_level(struct snd_soc_codec *codec,
 				 enum snd_soc_bias_level level)
 {
+	struct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
 	if (level == codec->dapm.bias_level)
 		return 0;
 
@@ -2485,18 +3084,50 @@ static int wm8962_set_bias_level(struct snd_soc_codec *codec,
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),
+						    wm8962->supplies);
+			if (ret != 0) {
+				dev_err(codec->dev,
+					"Failed to enable supplies: %d\n",
+					ret);
+				return ret;
+			}
+
+			wm8962_sync_cache(codec);
+
+			snd_soc_update_bits(codec, WM8962_ANTI_POP,
+					    WM8962_STARTUP_BIAS_ENA |
+					    WM8962_VMID_BUF_ENA,
+					    WM8962_STARTUP_BIAS_ENA |
+					    WM8962_VMID_BUF_ENA);
+
+			/* Bias enable at 2*50k for ramp */
+			snd_soc_update_bits(codec, WM8962_PWR_MGMT_1,
+					    WM8962_VMID_SEL_MASK |
+					    WM8962_BIAS_ENA,
+					    WM8962_BIAS_ENA | 0x180);
+
+			msleep(5);
+		}
+
 		/* VMID 2*250k */
 		snd_soc_update_bits(codec, WM8962_PWR_MGMT_1,
 				    WM8962_VMID_SEL_MASK, 0x100);
-
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
-			msleep(100);
 		break;
 
 	case SND_SOC_BIAS_OFF:
+		snd_soc_update_bits(codec, WM8962_PWR_MGMT_1,
+				    WM8962_VMID_SEL_MASK | WM8962_BIAS_ENA, 0);
+
+		snd_soc_update_bits(codec, WM8962_ANTI_POP,
+				    WM8962_STARTUP_BIAS_ENA |
+				    WM8962_VMID_BUF_ENA, 0);
+
+		regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies),
+				       wm8962->supplies);
 		break;
 	}
-
 	codec->dapm.bias_level = level;
 	return 0;
 }
@@ -2571,8 +3202,15 @@ static int wm8962_hw_params(struct snd_pcm_substream *substream,
 			    WM8962_SAMPLE_RATE_INT_MODE |
 			    WM8962_SAMPLE_RATE_MASK, adctl3);
 
-	if (codec->dapm.bias_level == SND_SOC_BIAS_ON)
-		wm8962_configure_bclk(codec);
+	wm8962_configure_bclk(codec);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (snd_soc_dapm_get_pin_status(&codec->dapm, "DMIC_ENA"))
+			snd_soc_update_bits(codec, WM8962_THREED1, WM8962_ADC_MONOMIX_MASK, 0);
+		else
+			snd_soc_update_bits(codec, WM8962_THREED1,
+						WM8962_ADC_MONOMIX_MASK, WM8962_ADC_MONOMIX);
+	}
 
 	return 0;
 }
@@ -2602,8 +3240,6 @@ static int wm8962_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 
 	wm8962->sysclk_rate = freq;
 
-	wm8962_configure_bclk(codec);
-
 	return 0;
 }
 
@@ -2779,10 +3415,10 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 			  unsigned int Fref, unsigned int Fout)
 {
 	struct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);
-	struct _fll_div fll_div;
+	struct _fll_div fll_div = {0};
 	unsigned long timeout;
 	int ret;
-	int fll1 = 0;
+	int fll1 = snd_soc_read(codec, WM8962_FLL_CONTROL_1) & WM8962_FLL_ENA;
 
 	/* Any change? */
 	if (source == wm8962->fll_src && Fref == wm8962->fll_fref &&
@@ -2798,8 +3434,6 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 		snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
 				    WM8962_FLL_ENA, 0);
 
-		pm_runtime_put(codec->dev);
-
 		return 0;
 	}
 
@@ -2807,9 +3441,6 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 	if (ret != 0)
 		return ret;
 
-	/* Parameters good, disable so we can reprogram */
-	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1, WM8962_FLL_ENA, 0);
-
 	switch (fll_id) {
 	case WM8962_FLL_MCLK:
 	case WM8962_FLL_BCLK:
@@ -2848,11 +3479,9 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 
 	try_wait_for_completion(&wm8962->fll_lock);
 
-	pm_runtime_get_sync(codec->dev);
-
 	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
 			    WM8962_FLL_FRAC | WM8962_FLL_REFCLK_SRC_MASK |
-			    WM8962_FLL_ENA, fll1 | WM8962_FLL_ENA);
+			    WM8962_FLL_ENA, fll1);
 
 	dev_dbg(codec->dev, "FLL configured for %dHz->%dHz\n", Fref, Fout);
 
@@ -2897,12 +3526,13 @@ static int wm8962_mute(struct snd_soc_dai *dai, int mute)
 				   WM8962_DAC_MUTE, val);
 }
 
-#define WM8962_RATES SNDRV_PCM_RATE_8000_96000
+#define WM8962_RATES (SNDRV_PCM_RATE_8000_48000 |\
+			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
 
 #define WM8962_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
 			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
-static const struct snd_soc_dai_ops wm8962_dai_ops = {
+static struct snd_soc_dai_ops wm8962_dai_ops = {
 	.hw_params = wm8962_hw_params,
 	.set_sysclk = wm8962_set_dai_sysclk,
 	.set_fmt = wm8962_set_dai_fmt,
@@ -2913,7 +3543,7 @@ static struct snd_soc_dai_driver wm8962_dai = {
 	.name = "wm8962",
 	.playback = {
 		.stream_name = "Playback",
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 2,
 		.rates = WM8962_RATES,
 		.formats = WM8962_FORMATS,
@@ -2961,73 +3591,54 @@ static void wm8962_mic_work(struct work_struct *work)
 
 static irqreturn_t wm8962_irq(int irq, void *data)
 {
-	struct device *dev = data;
-	struct wm8962_priv *wm8962 = dev_get_drvdata(dev);
-	unsigned int mask;
-	unsigned int active;
-	int reg, ret;
-
-	ret = regmap_read(wm8962->regmap, WM8962_INTERRUPT_STATUS_2_MASK,
-			  &mask);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read interrupt mask: %d\n",
-			ret);
-		return IRQ_NONE;
-	}
+	struct snd_soc_codec *codec = data;
+	struct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);
+	int mask;
+	int active;
+	int reg;
 
-	ret = regmap_read(wm8962->regmap, WM8962_INTERRUPT_STATUS_2, &active);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read interrupt: %d\n", ret);
-		return IRQ_NONE;
-	}
+	mask = snd_soc_read(codec, WM8962_INTERRUPT_STATUS_2_MASK);
 
+	active = snd_soc_read(codec, WM8962_INTERRUPT_STATUS_2);
 	active &= ~mask;
 
 	if (!active)
 		return IRQ_NONE;
 
 	/* Acknowledge the interrupts */
-	ret = regmap_write(wm8962->regmap, WM8962_INTERRUPT_STATUS_2, active);
-	if (ret != 0)
-		dev_warn(dev, "Failed to ack interrupt: %d\n", ret);
+	snd_soc_write(codec, WM8962_INTERRUPT_STATUS_2, active);
 
 	if (active & WM8962_FLL_LOCK_EINT) {
-		dev_dbg(dev, "FLL locked\n");
+		dev_dbg(codec->dev, "FLL locked\n");
 		complete(&wm8962->fll_lock);
 	}
 
 	if (active & WM8962_FIFOS_ERR_EINT)
-		dev_err(dev, "FIFO error\n");
+		dev_err(codec->dev, "FIFO error\n");
 
 	if (active & WM8962_TEMP_SHUT_EINT) {
-		dev_crit(dev, "Thermal shutdown\n");
+		dev_crit(codec->dev, "Thermal shutdown\n");
 
-		ret = regmap_read(wm8962->regmap,
-				  WM8962_THERMAL_SHUTDOWN_STATUS,  &reg);
-		if (ret != 0) {
-			dev_warn(dev, "Failed to read thermal status: %d\n",
-				 ret);
-			reg = 0;
-		}
+		reg = snd_soc_read(codec, WM8962_THERMAL_SHUTDOWN_STATUS);
 
 		if (reg & WM8962_TEMP_ERR_HP)
-			dev_crit(dev, "Headphone thermal error\n");
+			dev_crit(codec->dev, "Headphone thermal error\n");
 		if (reg & WM8962_TEMP_WARN_HP)
-			dev_crit(dev, "Headphone thermal warning\n");
+			dev_crit(codec->dev, "Headphone thermal warning\n");
 		if (reg & WM8962_TEMP_ERR_SPK)
-			dev_crit(dev, "Speaker thermal error\n");
+			dev_crit(codec->dev, "Speaker thermal error\n");
 		if (reg & WM8962_TEMP_WARN_SPK)
-			dev_crit(dev, "Speaker thermal warning\n");
+			dev_crit(codec->dev, "Speaker thermal warning\n");
 	}
 
 	if (active & (WM8962_MICSCD_EINT | WM8962_MICD_EINT)) {
-		dev_dbg(dev, "Microphone event detected\n");
+		dev_dbg(codec->dev, "Microphone event detected\n");
 
 #ifndef CONFIG_SND_SOC_WM8962_MODULE
-		trace_snd_soc_jack_irq(dev_name(dev));
+		trace_snd_soc_jack_irq(dev_name(codec->dev));
 #endif
 
-		pm_wakeup_event(dev, 300);
+		pm_wakeup_event(codec->dev, 300);
 
 		schedule_delayed_work(&wm8962->mic_work,
 				      msecs_to_jiffies(250));
@@ -3297,17 +3908,13 @@ static int wm8962_gpio_direction_out(struct gpio_chip *chip,
 {
 	struct wm8962_priv *wm8962 = gpio_to_wm8962(chip);
 	struct snd_soc_codec *codec = wm8962->codec;
-	int ret, val;
+	int val;
 
 	/* Force function 1 (logic output) */
 	val = (1 << WM8962_GP2_FN_SHIFT) | (value << WM8962_GP2_LVL_SHIFT);
 
-	ret = snd_soc_update_bits(codec, WM8962_GPIO_BASE + offset,
-				  WM8962_GP2_FN_MASK | WM8962_GP2_LVL, val);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return snd_soc_update_bits(codec, WM8962_GPIO_BASE + offset,
+				   WM8962_GP2_FN_MASK | WM8962_GP2_LVL, val);
 }
 
 static struct gpio_chip wm8962_template_chip = {
@@ -3368,12 +3975,26 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 	bool dmicclk, dmicdat;
 
 	wm8962->codec = codec;
-	codec->control_data = wm8962->regmap;
+	INIT_DELAYED_WORK(&wm8962->mic_work, wm8962_mic_work);
+	init_completion(&wm8962->fll_lock);
+
+	codec->cache_sync = 1;
+	codec->dapm.idle_bias_off = 1;
 
-	ret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);
+	ret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_I2C);
 	if (ret != 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
+		goto err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++)
+		wm8962->supplies[i].supply = wm8962_supply_names[i];
+
+	ret = regulator_bulk_get(codec->dev, ARRAY_SIZE(wm8962->supplies),
+				 wm8962->supplies);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to request supplies: %d\n", ret);
+		goto err;
 	}
 
 	wm8962->disable_nb[0].notifier_call = wm8962_regulator_event_0;
@@ -3396,6 +4017,43 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 		}
 	}
 
+	ret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),
+				    wm8962->supplies);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
+		goto err_get;
+	}
+	msleep(100);
+	ret = snd_soc_read(codec, WM8962_SOFTWARE_RESET);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to read ID register\n");
+		goto err_enable;
+	}
+	if (ret != wm8962_reg[WM8962_SOFTWARE_RESET]) {
+		dev_err(codec->dev, "Device is not a WM8962, ID %x != %x\n",
+			ret, wm8962_reg[WM8962_SOFTWARE_RESET]);
+		ret = -EINVAL;
+		goto err_enable;
+	}
+
+	ret = snd_soc_read(codec, WM8962_RIGHT_INPUT_VOLUME);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to read device revision: %d\n",
+			ret);
+		goto err_enable;
+	}
+	
+	dev_info(codec->dev, "customer id %x revision %c\n",
+		 (ret & WM8962_CUST_ID_MASK) >> WM8962_CUST_ID_SHIFT,
+		 ((ret & WM8962_CHIP_REV_MASK) >> WM8962_CHIP_REV_SHIFT)
+		 + 'A');
+
+	ret = wm8962_reset(codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to issue reset\n");
+		goto err_enable;
+	}
+
 	/* SYSCLK defaults to on; make sure it is off so we can safely
 	 * write to registers if the device is declocked.
 	 */
@@ -3410,6 +4068,8 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 			    WM8962_OSC_ENA | WM8962_PLL2_ENA | WM8962_PLL3_ENA,
 			    0);
 
+/* regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);*/
+
 	if (pdata) {
 		/* Apply static configuration for GPIOs */
 		for (i = 0; i < ARRAY_SIZE(pdata->gpio_init); i++)
@@ -3435,6 +4095,28 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 					    pdata->mic_cfg);
 	}
 
+	/* set the default volume for playback and record*/
+	snd_soc_update_bits(codec, WM8962_HPOUTL_VOLUME,
+			    WM8962_HPOUTL_VOL_MASK, 0x5d);
+	snd_soc_update_bits(codec, WM8962_HPOUTR_VOLUME,
+			    WM8962_HPOUTR_VOL_MASK, 0x5d);
+	snd_soc_update_bits(codec, WM8962_SPKOUTL_VOLUME,
+			    WM8962_SPKOUTL_VOL_MASK, 0x72);
+	snd_soc_update_bits(codec, WM8962_SPKOUTR_VOLUME,
+			    WM8962_SPKOUTR_VOL_MASK, 0x72);
+
+	snd_soc_update_bits(codec, WM8962_LEFT_INPUT_VOLUME,
+			    WM8962_INL_VOL_MASK, 0x3f);
+	snd_soc_update_bits(codec, WM8962_RIGHT_INPUT_VOLUME,
+			    WM8962_INR_VOL_MASK, 0x3f);
+	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
+			    WM8962_ADCL_VOL_MASK, 0xd8);
+	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
+			    WM8962_ADCR_VOL_MASK, 0xd8);
+	snd_soc_update_bits(codec, WM8962_RIGHT_INPUT_MIXER_VOLUME,
+			    WM8962_IN3R_MIXINR_VOL_MASK, 0x7);
+
+
 	/* Latch volume update bits */
 	snd_soc_update_bits(codec, WM8962_LEFT_INPUT_VOLUME,
 			    WM8962_IN_VU, WM8962_IN_VU);
@@ -3460,12 +4142,6 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 	/* Stereo control for EQ */
 	snd_soc_update_bits(codec, WM8962_EQ1, WM8962_EQ_SHARED_COEFF, 0);
 
-	/* Don't debouce interrupts so we don't need SYSCLK */
-	snd_soc_update_bits(codec, WM8962_IRQ_DEBOUNCE,
-			    WM8962_FLL_LOCK_DB | WM8962_PLL3_LOCK_DB |
-			    WM8962_PLL2_LOCK_DB | WM8962_TEMP_SHUT_DB,
-			    0);
-
 	wm8962_add_widgets(codec);
 
 	/* Save boards having to disable DMIC when not in use */
@@ -3508,7 +4184,7 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 
 		ret = request_threaded_irq(wm8962->irq, NULL, wm8962_irq,
 					   trigger | IRQF_ONESHOT,
-					   "wm8962", codec->dev);
+					   "wm8962", codec);
 		if (ret != 0) {
 			dev_err(codec->dev, "Failed to request IRQ %d: %d\n",
 				wm8962->irq, ret);
@@ -3525,6 +4201,13 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 	}
 
 	return 0;
+
+err_enable:
+	regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
+err_get:
+	regulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
+err:
+	return ret;
 }
 
 static int wm8962_remove(struct snd_soc_codec *codec)
@@ -3542,6 +4225,7 @@ static int wm8962_remove(struct snd_soc_codec *codec)
 	for (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++)
 		regulator_unregister_notifier(wm8962->supplies[i].consumer,
 					      &wm8962->disable_nb[i]);
+	regulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
 
 	return 0;
 }
@@ -3550,216 +4234,44 @@ static struct snd_soc_codec_driver soc_codec_dev_wm8962 = {
 	.probe =	wm8962_probe,
 	.remove =	wm8962_remove,
 	.set_bias_level = wm8962_set_bias_level,
+	.reg_cache_size = WM8962_MAX_REGISTER + 1,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_default = wm8962_reg,
+	.volatile_register = wm8962_volatile_register,
+	.readable_register = wm8962_readable_register,
 	.set_pll = wm8962_set_fll,
-	.idle_bias_off = true,
-};
-
-/* Improve power consumption for IN4 DC measurement mode */
-static const struct reg_default wm8962_dc_measure[] = {
-	{ 0xfd, 0x1 },
-	{ 0xcc, 0x40 },
-	{ 0xfd, 0 },
-};
-
-static const struct regmap_config wm8962_regmap = {
-	.reg_bits = 16,
-	.val_bits = 16,
-
-	.max_register = WM8962_MAX_REGISTER,
-	.reg_defaults = wm8962_reg,
-	.num_reg_defaults = ARRAY_SIZE(wm8962_reg),
-	.volatile_reg = wm8962_volatile_register,
-	.readable_reg = wm8962_readable_register,
-	.cache_type = REGCACHE_RBTREE,
 };
 
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 static __devinit int wm8962_i2c_probe(struct i2c_client *i2c,
 				      const struct i2c_device_id *id)
 {
-	struct wm8962_pdata *pdata = dev_get_platdata(&i2c->dev);
 	struct wm8962_priv *wm8962;
-	unsigned int reg;
-	int ret, i;
+	int ret;
 
-	wm8962 = devm_kzalloc(&i2c->dev, sizeof(struct wm8962_priv),
-			      GFP_KERNEL);
+	wm8962 = kzalloc(sizeof(struct wm8962_priv), GFP_KERNEL);
 	if (wm8962 == NULL)
 		return -ENOMEM;
 
 	i2c_set_clientdata(i2c, wm8962);
 
-	INIT_DELAYED_WORK(&wm8962->mic_work, wm8962_mic_work);
-	init_completion(&wm8962->fll_lock);
 	wm8962->irq = i2c->irq;
 
-	for (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++)
-		wm8962->supplies[i].supply = wm8962_supply_names[i];
-
-	ret = regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8962->supplies),
-				 wm8962->supplies);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);
-		goto err;
-	}
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),
-				    wm8962->supplies);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);
-		goto err_get;
-	}
-
-	wm8962->regmap = regmap_init_i2c(i2c, &wm8962_regmap);
-	if (IS_ERR(wm8962->regmap)) {
-		ret = PTR_ERR(wm8962->regmap);
-		dev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);
-		goto err_enable;
-	}
-
-	/*
-	 * We haven't marked the chip revision as volatile due to
-	 * sharing a register with the right input volume; explicitly
-	 * bypass the cache to read it.
-	 */
-	regcache_cache_bypass(wm8962->regmap, true);
-
-	ret = regmap_read(wm8962->regmap, WM8962_SOFTWARE_RESET, &reg);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "Failed to read ID register\n");
-		goto err_regmap;
-	}
-	if (reg != 0x6243) {
-		dev_err(&i2c->dev,
-			"Device is not a WM8962, ID %x != 0x6243\n", reg);
-		ret = -EINVAL;
-		goto err_regmap;
-	}
-
-	ret = regmap_read(wm8962->regmap, WM8962_RIGHT_INPUT_VOLUME, &reg);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "Failed to read device revision: %d\n",
-			ret);
-		goto err_regmap;
-	}
-
-	dev_info(&i2c->dev, "customer id %x revision %c\n",
-		 (reg & WM8962_CUST_ID_MASK) >> WM8962_CUST_ID_SHIFT,
-		 ((reg & WM8962_CHIP_REV_MASK) >> WM8962_CHIP_REV_SHIFT)
-		 + 'A');
-
-	regcache_cache_bypass(wm8962->regmap, false);
-
-	ret = wm8962_reset(wm8962);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "Failed to issue reset\n");
-		goto err_regmap;
-	}
-
-	if (pdata && pdata->in4_dc_measure) {
-		ret = regmap_register_patch(wm8962->regmap,
-					    wm8962_dc_measure,
-					    ARRAY_SIZE(wm8962_dc_measure));
-		if (ret != 0)
-			dev_err(&i2c->dev,
-				"Failed to configure for DC mesurement: %d\n",
-				ret);
-	}
-
-	pm_runtime_enable(&i2c->dev);
-	pm_request_idle(&i2c->dev);
-
 	ret = snd_soc_register_codec(&i2c->dev,
 				     &soc_codec_dev_wm8962, &wm8962_dai, 1);
 	if (ret < 0)
-		goto err_regmap;
+		kfree(wm8962);
 
-	/* The drivers should power up as needed */
-	regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
-
-	return 0;
-
-err_regmap:
-	regmap_exit(wm8962->regmap);
-err_enable:
-	regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
-err_get:
-	regulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
-err:
 	return ret;
 }
 
 static __devexit int wm8962_i2c_remove(struct i2c_client *client)
 {
-	struct wm8962_priv *wm8962 = dev_get_drvdata(&client->dev);
-
 	snd_soc_unregister_codec(&client->dev);
-	regmap_exit(wm8962->regmap);
-	regulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);
+	kfree(i2c_get_clientdata(client));
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
-static int wm8962_runtime_resume(struct device *dev)
-{
-	struct wm8962_priv *wm8962 = dev_get_drvdata(dev);
-	int ret;
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),
-				    wm8962->supplies);
-	if (ret != 0) {
-		dev_err(dev,
-			"Failed to enable supplies: %d\n", ret);
-		return ret;
-	}
-
-	regcache_cache_only(wm8962->regmap, false);
-
-	wm8962_reset(wm8962);
-
-	regcache_sync(wm8962->regmap);
-
-	regmap_update_bits(wm8962->regmap, WM8962_ANTI_POP,
-			   WM8962_STARTUP_BIAS_ENA | WM8962_VMID_BUF_ENA,
-			   WM8962_STARTUP_BIAS_ENA | WM8962_VMID_BUF_ENA);
-
-	/* Bias enable at 2*50k for ramp */
-	regmap_update_bits(wm8962->regmap, WM8962_PWR_MGMT_1,
-			   WM8962_VMID_SEL_MASK | WM8962_BIAS_ENA,
-			   WM8962_BIAS_ENA | 0x180);
-
-	msleep(5);
-
-	/* VMID back to 2x250k for standby */
-	regmap_update_bits(wm8962->regmap, WM8962_PWR_MGMT_1,
-			   WM8962_VMID_SEL_MASK, 0x100);
-
-	return 0;
-}
-
-static int wm8962_runtime_suspend(struct device *dev)
-{
-	struct wm8962_priv *wm8962 = dev_get_drvdata(dev);
-
-	regmap_update_bits(wm8962->regmap, WM8962_PWR_MGMT_1,
-			   WM8962_VMID_SEL_MASK | WM8962_BIAS_ENA, 0);
-
-	regmap_update_bits(wm8962->regmap, WM8962_ANTI_POP,
-			   WM8962_STARTUP_BIAS_ENA |
-			   WM8962_VMID_BUF_ENA, 0);
-
-	regcache_cache_only(wm8962->regmap, true);
-
-	regulator_bulk_disable(ARRAY_SIZE(wm8962->supplies),
-			       wm8962->supplies);
-
-	return 0;
-}
-#endif
-
-static struct dev_pm_ops wm8962_pm = {
-	SET_RUNTIME_PM_OPS(wm8962_runtime_suspend, wm8962_runtime_resume, NULL)
-};
-
 static const struct i2c_device_id wm8962_i2c_id[] = {
 	{ "wm8962", 0 },
 	{ }
@@ -3770,14 +4282,34 @@ static struct i2c_driver wm8962_i2c_driver = {
 	.driver = {
 		.name = "wm8962",
 		.owner = THIS_MODULE,
-		.pm = &wm8962_pm,
 	},
 	.probe =    wm8962_i2c_probe,
 	.remove =   __devexit_p(wm8962_i2c_remove),
 	.id_table = wm8962_i2c_id,
 };
+#endif
 
-module_i2c_driver(wm8962_i2c_driver);
+static int __init wm8962_modinit(void)
+{
+	int ret;
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	ret = i2c_add_driver(&wm8962_i2c_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register WM8962 I2C driver: %d\n",
+		       ret);
+	}
+#endif
+	return 0;
+}
+module_init(wm8962_modinit);
+
+static void __exit wm8962_exit(void)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8962_i2c_driver);
+#endif
+}
+module_exit(wm8962_exit);
 
 MODULE_DESCRIPTION("ASoC WM8962 driver");
 MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index b87855d4..c35b3c4 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -1,6 +1,9 @@
 menuconfig SND_IMX_SOC
 	tristate "SoC Audio for Freescale i.MX CPUs"
 	depends on ARCH_MXC
+	select SND_PCM
+	select FIQ
+	select SND_SOC_AC97_BUS
 	help
 	  Say Y or M if you want to add support for codecs attached to
 	  the i.MX SSI interface.
@@ -11,23 +14,13 @@ if SND_IMX_SOC
 config SND_MXC_SOC_ESAI
 	tristate
 
-config SND_SOC_IMX_SSI
-	tristate
-
-config SND_SOC_IMX_PCM
-	tristate
-
 config SND_MXC_SOC_FIQ
 	tristate
-	select FIQ
-	select SND_SOC_IMX_PCM
 
 config SND_MXC_SOC_MX2
-	select SND_SOC_DMAENGINE_PCM
 	tristate
-	select SND_SOC_IMX_PCM
 
-config SND_SOC_IMX_AUDMUX
+config SND_MXC_SOC_HDMI
 	tristate
 
 config SND_MXC_SOC_SPDIF_DAI
@@ -38,19 +31,15 @@ config SND_MXC_SOC_WM1133_EV1
 	depends on MACH_MX31ADS_WM1133_EV1 && EXPERIMENTAL
 	select SND_SOC_WM8350
 	select SND_MXC_SOC_FIQ
-	select SND_SOC_IMX_AUDMUX
-	select SND_SOC_IMX_SSI
 	help
 	  Enable support for audio on the i.MX31ADS with the WM1133-EV1
 	  PMIC board with WM8835x fitted.
 
 config SND_SOC_MX27VIS_AIC32X4
 	tristate "SoC audio support for Visstrim M10 boards"
-	depends on MACH_IMX27_VISSTRIM_M10 && I2C
-	select SND_SOC_TLV320AIC32X4
+	depends on MACH_IMX27_VISSTRIM_M10
+	select SND_SOC_TVL320AIC32X4
 	select SND_MXC_SOC_MX2
-	select SND_SOC_IMX_AUDMUX
-	select SND_SOC_IMX_SSI
 	help
 	  Say Y if you want to add support for SoC audio on Visstrim SM10
 	  board with TLV320AIC32X4 codec.
@@ -58,57 +47,91 @@ config SND_SOC_MX27VIS_AIC32X4
 config SND_SOC_PHYCORE_AC97
 	tristate "SoC Audio support for Phytec phyCORE (and phyCARD) boards"
 	depends on MACH_PCM043 || MACH_PCA100
-	select SND_SOC_AC97_BUS
 	select SND_SOC_WM9712
 	select SND_MXC_SOC_FIQ
-	select SND_SOC_IMX_AUDMUX
-	select SND_SOC_IMX_SSI
 	help
 	  Say Y if you want to add support for SoC audio on Phytec phyCORE
 	  and phyCARD boards in AC97 mode
 
+config SND_SOC_IMX_SGTL5000
+	tristate "SoC Audio support for i.MX boards with sgtl5000"
+	depends on I2C && (MACH_MX35_3DS || MACH_MX51_BABBAGE \
+			|| MACH_MX6Q_SABRELITE || MACH_MX6Q_ARM2)
+	select SND_SOC_SGTL5000
+	select SND_MXC_SOC_MX2
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a sgtl5000 codec.
+
+config SND_SOC_IMX_WM8958
+	tristate "SoC Audio support for IMX boards with WM8958"
+	depends on MFD_WM8994
+	select SND_MXC_SOC_MX2
+	select SND_SOC_WM8994
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a WM8958 codec.
+
+config SND_SOC_IMX_WM8962
+	tristate "SoC Audio support for IMX boards with WM8962"
+	select SND_MXC_SOC_MX2
+	select SND_SOC_WM8962
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a WM8962 codec.
+
+config SND_SOC_IMX_CS42888
+	tristate "SoC Audio support for i.MX boards with cs42888"
+	depends on I2C && (MACH_MX6Q_ARM2 || MACH_MX6Q_SABREAUTO || MACH_MX53_ARD)
+	select SND_SOC_CS42888
+	select SND_MXC_SOC_MX2
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a cs42888 codec
+
+config SND_SOC_IMX_SI4763
+	tristate "SoC Audio support for IMX SI4763"
+	select SND_MXC_SOC_SSI
+	select SND_SOC_SI4763
+	help
+	  Say Y if you want to add support for Soc audio for the AMFM Tuner chip
+	  SI4763 module.
+
 config SND_SOC_EUKREA_TLV320
 	tristate "Eukrea TLV320"
 	depends on MACH_EUKREA_MBIMX27_BASEBOARD \
 		|| MACH_EUKREA_MBIMXSD25_BASEBOARD \
 		|| MACH_EUKREA_MBIMXSD35_BASEBOARD \
 		|| MACH_EUKREA_MBIMXSD51_BASEBOARD
-	depends on I2C
 	select SND_SOC_TLV320AIC23
 	select SND_MXC_SOC_FIQ
-	select SND_SOC_IMX_AUDMUX
-	select SND_SOC_IMX_SSI
 	help
 	  Enable I2S based access to the TLV320AIC23B codec attached
 	  to the SSI interface
 
-config SND_SOC_IMX_SGTL5000
-	tristate "SoC Audio support for i.MX boards with sgtl5000"
-	depends on I2C && (MACH_MX35_3DS || MACH_MX51_BABBAGE \
-			|| MACH_MX6Q_SABRELITE || MACH_MX6Q_ARM2)
-	select SND_SOC_SGTL5000
+config SND_SOC_IMX_SPDIF
+	tristate "SoC Audio support for IMX - S/PDIF"
+	default n
+	select SND_MXC_SOC_SPDIF_DAI
+	select SND_SOC_MXC_SPDIF
 	select SND_MXC_SOC_MX2
-	select SND_SOC_IMX_SSI
-	select SND_SOC_IMX_AUDMUX
 	help
-	  Say Y if you want to add support for SoC audio on an i.MX board with
-	  a sgtl5000 codec.
+	  Say Y if you want to add support for SoC audio on a IMX development
+	  board with S/PDIF.
 
 config SND_SOC_IMX_HDMI
 	tristate "SoC Audio support for IMX - HDMI"
 	default n
+	select SND_MXC_SOC_HDMI
 	select SND_SOC_MXC_HDMI
 	select MFD_MXC_HDMI
 	help
 	  Say Y if you want to add support for SoC audio through IMX HDMI.
 
-config SND_SOC_IMX_SPDIF
-	tristate "SoC Audio support for IMX - S/PDIF"
-	default n
-	select SND_MXC_SOC_SPDIF_DAI
-	select SND_SOC_MXC_SPDIF
-	select SND_MXC_SOC_MX2
+config SND_MXC_SOC_IRAM
+	bool "Locate SSI Audio DMA playback buffers in IRAM"
+	depends on MACH_MX6SL_EVK && MACH_MX6SL_ARM2
 	help
-	  Say Y if you want to add support for SoC audio on a IMX development
-	  board with S/PDIF.
+	  Say Y if you don't want Audio playback buffers in external ram
+
 endif	# SND_IMX_SOC
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index 8e9eedf..9c17ff7 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -1,31 +1,39 @@
 # i.MX Platform Support
-snd-soc-imx-ssi-objs := imx-ssi.o imx-esai.o
-snd-soc-imx-audmux-objs := imx-audmux.o
+snd-soc-imx-objs := imx-ssi.o imx-esai.o imx-hdmi-dai.o hdmi_pcm.o imx-audmux.o
+snd-soc-imx-fiq-objs := imx-pcm-fiq.o
+snd-soc-imx-mx2-objs := imx-pcm-dma-mx2.o
+snd-soc-imx-spdif-dai-objs := imx-spdif-dai.o
+snd-soc-imx-hdmi-dai-objs := imx-hdmi-dma.o
 
-obj-$(CONFIG_SND_SOC_IMX_SSI) += snd-soc-imx-ssi.o
-obj-$(CONFIG_SND_SOC_IMX_AUDMUX) += snd-soc-imx-audmux.o
-
-obj-$(CONFIG_SND_SOC_IMX_PCM) += snd-soc-imx-pcm.o
-snd-soc-imx-pcm-y := imx-pcm.o
-snd-soc-imx-pcm-$(CONFIG_SND_MXC_SOC_FIQ) += imx-pcm-fiq.o
-snd-soc-imx-pcm-$(CONFIG_SND_MXC_SOC_MX2) += imx-pcm-dma-mx2.o
-snd-soc-imx-pcm-$(CONFIG_SND_MXC_SOC_SPDIF_DAI) += imx-spdif-dai.o
+obj-$(CONFIG_SND_IMX_SOC) += snd-soc-imx.o
+obj-$(CONFIG_SND_MXC_SOC_FIQ) += snd-soc-imx-fiq.o
+obj-$(CONFIG_SND_MXC_SOC_MX2) += snd-soc-imx-mx2.o
+obj-$(CONFIG_SND_MXC_SOC_SPDIF_DAI) += snd-soc-imx-spdif-dai.o
+obj-$(CONFIG_SND_MXC_SOC_HDMI) += snd-soc-imx-hdmi-dai.o
 
 # i.MX Machine Support
 snd-soc-eukrea-tlv320-objs := eukrea-tlv320.o
 snd-soc-phycore-ac97-objs := phycore-ac97.o
 snd-soc-mx27vis-aic32x4-objs := mx27vis-aic32x4.o
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
-snd-soc-imx-hdmi-objs := imx-hdmi.o imx-hdmi-dai.o imx-hdmi-dma.o hdmi_pcm.o
+snd-soc-imx-wm8958-objs := imx-wm8958.o
+snd-soc-imx-wm8962-objs := imx-wm8962.o
 snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
+snd-soc-imx-cs42888-objs := imx-cs42888.o
 snd-soc-imx-spdif-objs := imx-spdif.o
+snd-soc-imx-si4763-objs := imx-si4763.o
+snd-soc-imx-hdmi-objs := imx-hdmi.o
 
 obj-$(CONFIG_SND_SOC_EUKREA_TLV320) += snd-soc-eukrea-tlv320.o
 obj-$(CONFIG_SND_SOC_PHYCORE_AC97) += snd-soc-phycore-ac97.o
 obj-$(CONFIG_SND_SOC_MX27VIS_AIC32X4) += snd-soc-mx27vis-aic32x4.o
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
-obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
+obj-$(CONFIG_SND_SOC_IMX_WM8958) += snd-soc-imx-wm8958.o
+obj-$(CONFIG_SND_SOC_IMX_WM8962) += snd-soc-imx-wm8962.o
 obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_CS42888) += snd-soc-imx-cs42888.o
 obj-$(CONFIG_SND_SOC_IMX_SPDIF) += snd-soc-imx-spdif.o
+obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
+obj-$(CONFIG_SND_SOC_IMX_SI4763) += snd-soc-imx-si4763.o
 
 AFLAGS_hdmi_pcm.o := -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
diff --git a/sound/soc/imx/imx-cs42888.c b/sound/soc/imx/imx-cs42888.c
new file mode 100644
index 0000000..62d221f
--- /dev/null
+++ b/sound/soc/imx/imx-cs42888.c
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <linux/mxc_asrc.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/soc-dai.h>
+#include <sound/pcm_params.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+
+#include "imx-esai.h"
+#include "../codecs/cs42888.h"
+#include "imx-pcm.h"
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_IMX_HAVE_PLATFORM_IMX_ASRC)
+
+static enum asrc_word_width get_asrc_input_width(
+			struct snd_pcm_hw_params *params)
+{
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_U16:
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		return ASRC_WIDTH_16_BIT;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S20_3BE:
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_S24_3BE:
+	case SNDRV_PCM_FORMAT_S24_BE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_U24_BE:
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FORMAT_U24_3BE:
+	case SNDRV_PCM_FORMAT_U24_3LE:
+		return ASRC_WIDTH_24_BIT;
+	case SNDRV_PCM_FORMAT_S8:
+	case SNDRV_PCM_FORMAT_U8:
+	case SNDRV_PCM_FORMAT_S32:
+	case SNDRV_PCM_FORMAT_U32:
+	default:
+		pr_err("Format is not support!\n");
+		return -EINVAL;
+	}
+}
+
+static int config_asrc(struct snd_pcm_substream *substream,
+					 struct snd_pcm_hw_params *params)
+{
+	unsigned int rate = params_rate(params);
+	unsigned int channel = params_channels(params);
+	struct imx_pcm_runtime_data *iprtd =
+				substream->runtime->private_data;
+	struct asrc_config config = {0};
+	int ret = 0;
+
+	if ((channel != 2) && (channel != 4) && (channel != 6))
+		return -EINVAL;
+
+	ret = iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_req_pair(channel, &iprtd->asrc_index);
+	if (ret < 0) {
+		pr_err("Fail to request asrc pair\n");
+		return -EINVAL;
+	}
+
+	config.input_word_width = get_asrc_input_width(params);
+	config.output_word_width = iprtd->p2p->p2p_width;
+	config.pair = iprtd->asrc_index;
+	config.channel_num = channel;
+	config.input_sample_rate = rate;
+	config.output_sample_rate = iprtd->p2p->p2p_rate;
+	config.inclk = INCLK_NONE;
+	config.outclk = OUTCLK_ESAI_TX;
+
+	ret = iprtd->asrc_pcm_p2p_ops_ko->asrc_p2p_config_pair(&config);
+	if (ret < 0) {
+		pr_err("Fail to config asrc\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+struct imx_priv_state {
+	int hw;
+};
+
+static struct asrc_p2p_params *esai_asrc;
+static struct imx_priv_state hw_state;
+unsigned int mclk_freq;
+
+static int imx_3stack_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	if (!cpu_dai->active) {
+		hw_state.hw = 0;
+	}
+
+	return 0;
+}
+
+static void imx_3stack_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	if (!cpu_dai->active)
+		hw_state.hw = 0;
+}
+
+static int imx_3stack_surround_hw_free(struct snd_pcm_substream *substream)
+{
+	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
+
+	if (iprtd->asrc_enable) {
+		if (iprtd->asrc_index != -1) {
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_release_pair(
+						iprtd->asrc_index);
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_finish_conv(iprtd->asrc_index);
+		}
+		iprtd->asrc_index = -1;
+	}
+
+	return 0;
+}
+static int imx_3stack_surround_hw_params(struct snd_pcm_substream *substream,
+					 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
+	unsigned int rate = params_rate(params);
+	u32 dai_format;
+	unsigned int lrclk_ratio = 0;
+	int err = 0;
+
+	if (iprtd->asrc_enable) {
+		err = config_asrc(substream, params);
+		if (err < 0)
+			return err;
+		rate = iprtd->p2p->p2p_rate;
+	}
+
+	if (hw_state.hw)
+		return 0;
+	hw_state.hw = 1;
+
+	if (cpu_is_mx53() || machine_is_mx6q_sabreauto()) {
+		switch (rate) {
+		case 32000:
+			lrclk_ratio = 3;
+			break;
+		case 48000:
+			lrclk_ratio = 3;
+			break;
+		case 64000:
+			lrclk_ratio = 1;
+			break;
+		case 96000:
+			lrclk_ratio = 1;
+			break;
+		case 128000:
+			lrclk_ratio = 1;
+			break;
+		case 44100:
+			lrclk_ratio = 3;
+			break;
+		case 88200:
+			lrclk_ratio = 1;
+			break;
+		case 176400:
+			lrclk_ratio = 0;
+			break;
+		case 192000:
+			lrclk_ratio = 0;
+			break;
+		default:
+			pr_info("Rate not support.\n");
+			return -EINVAL;;
+		}
+	} else if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+		switch (rate) {
+		case 32000:
+			lrclk_ratio = 5;
+			break;
+		case 48000:
+			lrclk_ratio = 5;
+			break;
+		case 64000:
+			lrclk_ratio = 2;
+			break;
+		case 96000:
+			lrclk_ratio = 2;
+			break;
+		case 128000:
+			lrclk_ratio = 2;
+			break;
+		case 44100:
+			lrclk_ratio = 5;
+			break;
+		case 88200:
+			lrclk_ratio = 2;
+			break;
+		case 176400:
+			lrclk_ratio = 0;
+			break;
+		case 192000:
+			lrclk_ratio = 0;
+			break;
+		default:
+			pr_info("Rate not support.\n");
+			return -EINVAL;;
+		}
+	}
+	dai_format = SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS;
+
+	/* set cpu DAI configuration */
+	snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, 32);
+	/* set the ESAI system clock as output */
+	if (cpu_is_mx53() || machine_is_mx6q_sabreauto()) {
+		snd_soc_dai_set_sysclk(cpu_dai, ESAI_CLK_EXTAL,
+			mclk_freq, SND_SOC_CLOCK_OUT);
+	} else if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+		snd_soc_dai_set_sysclk(cpu_dai, ESAI_CLK_EXTAL_DIV,
+			mclk_freq, SND_SOC_CLOCK_OUT);
+	}
+	/* set the ratio */
+	snd_soc_dai_set_clkdiv(cpu_dai, ESAI_TX_DIV_PSR, 1);
+	if (cpu_is_mx53() || machine_is_mx6q_sabreauto())
+		snd_soc_dai_set_clkdiv(cpu_dai, ESAI_TX_DIV_PM, 0);
+	else if (cpu_is_mx6q() || cpu_is_mx6dl())
+		snd_soc_dai_set_clkdiv(cpu_dai, ESAI_TX_DIV_PM, 2);
+	snd_soc_dai_set_clkdiv(cpu_dai, ESAI_TX_DIV_FP, lrclk_ratio);
+
+	snd_soc_dai_set_clkdiv(cpu_dai, ESAI_RX_DIV_PSR, 1);
+	if (cpu_is_mx53() || machine_is_mx6q_sabreauto())
+		snd_soc_dai_set_clkdiv(cpu_dai, ESAI_RX_DIV_PM, 0);
+	else if (cpu_is_mx6q() || cpu_is_mx6dl())
+		snd_soc_dai_set_clkdiv(cpu_dai, ESAI_RX_DIV_PM, 2);
+	snd_soc_dai_set_clkdiv(cpu_dai, ESAI_RX_DIV_FP, lrclk_ratio);
+
+	/* set codec DAI configuration */
+	snd_soc_dai_set_fmt(codec_dai, dai_format);
+	/* set codec Master clock */
+	snd_soc_dai_set_sysclk(codec_dai, 0, mclk_freq, SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_3stack_surround_ops = {
+	.startup = imx_3stack_startup,
+	.shutdown = imx_3stack_shutdown,
+	.hw_params = imx_3stack_surround_hw_params,
+	.hw_free = imx_3stack_surround_hw_free,
+};
+
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Line out jack */
+	{"Line Out Jack", NULL, "AOUT1L"},
+	{"Line Out Jack", NULL, "AOUT1R"},
+	{"Line Out Jack", NULL, "AOUT2L"},
+	{"Line Out Jack", NULL, "AOUT2R"},
+	{"Line Out Jack", NULL, "AOUT3L"},
+	{"Line Out Jack", NULL, "AOUT3R"},
+	{"Line Out Jack", NULL, "AOUT4L"},
+	{"Line Out Jack", NULL, "AOUT4R"},
+	{"AIN1L", NULL, "Line In Jack"},
+	{"AIN1R", NULL, "Line In Jack"},
+	{"AIN2L", NULL, "Line In Jack"},
+	{"AIN2R", NULL, "Line In Jack"},
+};
+
+static int imx_3stack_cs42888_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+
+	snd_soc_dapm_new_controls(&codec->dapm, imx_3stack_dapm_widgets,
+				  ARRAY_SIZE(imx_3stack_dapm_widgets));
+	snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+	snd_soc_dapm_sync(&codec->dapm);
+	return 0;
+}
+static int imx_asrc_cs42888_init(struct snd_soc_pcm_runtime *rtd)
+{
+
+	snd_soc_pcm_set_drvdata(rtd, (void *)esai_asrc);
+	return 0;
+}
+
+static struct snd_soc_dai_link imx_3stack_dai[] = {
+	{
+	.name = "HiFi",
+	.stream_name = "HiFi",
+	.codec_dai_name = "CS42888",
+#ifdef CONFIG_SOC_IMX53
+	.codec_name = "cs42888.1-0048",
+#endif
+#ifdef CONFIG_SOC_IMX6Q
+	.codec_name = "cs42888.0-0048",
+#endif
+	.cpu_dai_name = "imx-esai.0",
+	.platform_name = "imx-pcm-audio.0",
+	.init = imx_3stack_cs42888_init,
+	.ops = &imx_3stack_surround_ops,
+	},
+	{
+	.name = "HiFi_ASRC",
+	.stream_name = "HIFI_ASRC",
+	.codec_dai_name = "CS42888_ASRC",
+#ifdef CONFIG_SOC_IMX53
+	.codec_name = "cs42888.1-0048",
+#endif
+#ifdef CONFIG_SOC_IMX6Q
+	.codec_name = "cs42888.0-0048",
+#endif
+	.cpu_dai_name = "imx-esai.0",
+	.platform_name = "imx-pcm-audio.0",
+	.init = imx_asrc_cs42888_init,
+	.ops = &imx_3stack_surround_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_card_imx_3stack = {
+	.name = "cs42888-audio",
+	.dai_link = imx_3stack_dai,
+	.num_links = ARRAY_SIZE(imx_3stack_dai),
+};
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ */
+static int __devinit imx_3stack_cs42888_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat_data = pdev->dev.platform_data;
+
+	if (!plat_data) {
+		dev_err(&pdev->dev, "plat_data is missing\n");
+		return -EINVAL;
+	}
+	mclk_freq = plat_data->sysclk;
+	if (plat_data->codec_name) {
+		imx_3stack_dai[0].codec_name = plat_data->codec_name;
+		imx_3stack_dai[1].codec_name = plat_data->codec_name;
+	}
+	esai_asrc = kzalloc(sizeof(struct asrc_p2p_params), GFP_KERNEL);
+	if (plat_data->priv)
+		memcpy(esai_asrc, plat_data->priv,
+				sizeof(struct asrc_p2p_params));
+	return 0;
+}
+
+static int __devexit imx_3stack_cs42888_remove(struct platform_device *pdev)
+{
+	if (esai_asrc)
+		kfree(esai_asrc);
+	return 0;
+}
+
+static struct platform_driver imx_3stack_cs42888_driver = {
+	.probe = imx_3stack_cs42888_probe,
+	.remove = __devexit_p(imx_3stack_cs42888_remove),
+	.driver = {
+		   .name = "imx-cs42888",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *imx_3stack_snd_device;
+
+static int __init imx_3stack_asoc_init(void)
+{
+	int ret;
+	pr_info("imx_3stack asoc driver\n");
+	ret = platform_driver_register(&imx_3stack_cs42888_driver);
+	if (ret < 0)
+		goto exit;
+
+	imx_3stack_snd_device = platform_device_alloc("soc-audio", 2);
+	if (!imx_3stack_snd_device)
+		goto err_device_alloc;
+	platform_set_drvdata(imx_3stack_snd_device, &snd_soc_card_imx_3stack);
+	ret = platform_device_add(imx_3stack_snd_device);
+	if (0 == ret)
+		goto exit;
+
+	platform_device_unregister(imx_3stack_snd_device);
+err_device_alloc:
+	platform_driver_unregister(&imx_3stack_cs42888_driver);
+exit:
+	return ret;
+}
+
+static void __exit imx_3stack_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_cs42888_driver);
+	platform_device_unregister(imx_3stack_snd_device);
+}
+
+module_init(imx_3stack_asoc_init);
+module_exit(imx_3stack_asoc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("ALSA SoC cs42888 Machine Layer Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-esai.c b/sound/soc/imx/imx-esai.c
index f8b7319..8951a81 100644
--- a/sound/soc/imx/imx-esai.c
+++ b/sound/soc/imx/imx-esai.c
@@ -25,7 +25,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/mxc_asrc.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -309,12 +308,11 @@ static int imx_esai_hw_tx_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *cpu_dai)
 {
+	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
+
 	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
 	u32 tcr, tfcr;
 	unsigned int channels;
-#if defined(CONFIG_MXC_ASRC) && defined(SND_MXC_SOC_ESAI)
-	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
-#endif
 
 	tcr = readl(esai->base + ESAI_TCR);
 	tfcr = readl(esai->base + ESAI_TFCR);
@@ -326,7 +324,6 @@ static int imx_esai_hw_tx_params(struct snd_pcm_substream *substream,
 	tfcr &= ESAI_TFCR_TWA_MASK;
 	tcr &= ESAI_TCR_TSWS_MASK;
 
-#if defined(CONFIG_MXC_ASRC) && defined(SND_MXC_SOC_ESAI)
 	if (iprtd->asrc_enable) {
 		switch (iprtd->p2p->p2p_width) {
 		case ASRC_WIDTH_16_BIT:
@@ -343,9 +340,7 @@ static int imx_esai_hw_tx_params(struct snd_pcm_substream *substream,
 		}
 		tfcr |= ESAI_WORD_LEN_24;
 		tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL24;
-	} else
-#endif
-	{
+	} else {
 		switch (params_format(params)) {
 		case SNDRV_PCM_FORMAT_S16_LE:
 			tfcr |= ESAI_WORD_LEN_16;
@@ -584,7 +579,7 @@ static struct snd_soc_dai_driver imx_esai_dai = {
 	 .suspend = imx_esai_suspend,
 	 .resume = imx_esai_resume,
 	 .playback = {
-		      .channels_min = 2,
+		      .channels_min = 1,
 		      .channels_max = 12,
 		      .rates = IMX_ESAI_RATES,
 		      .formats = IMX_ESAI_FORMATS,
@@ -646,8 +641,8 @@ static int imx_esai_probe(struct platform_device *pdev)
 	esai->dma_params_rx.dma_addr = res->start + ESAI_ERDR;
 	esai->dma_params_tx.dma_addr = res->start + ESAI_ETDR;
 
-	esai->dma_params_tx.shared_peripheral = IMX_DMATYPE_ESAI;
-	esai->dma_params_rx.shared_peripheral = IMX_DMATYPE_ESAI;
+	esai->dma_params_tx.peripheral_type = IMX_DMATYPE_ESAI;
+	esai->dma_params_rx.peripheral_type = IMX_DMATYPE_ESAI;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");
 	if (res)
@@ -664,7 +659,7 @@ static int imx_esai_probe(struct platform_device *pdev)
 		goto failed_register;
 	}
 
-	esai->soc_platform_pdev_fiq =
+	esai->soc_platform_pdev_fiq = \
 		platform_device_alloc("imx-fiq-pcm-audio", pdev->id);
 	if (!esai->soc_platform_pdev_fiq) {
 		ret = -ENOMEM;
@@ -678,7 +673,7 @@ static int imx_esai_probe(struct platform_device *pdev)
 		goto failed_pdev_fiq_add;
 	}
 
-	esai->soc_platform_pdev =
+	esai->soc_platform_pdev = \
 		platform_device_alloc("imx-pcm-audio", pdev->id);
 	if (!esai->soc_platform_pdev) {
 		ret = -ENOMEM;
diff --git a/sound/soc/imx/imx-esai.h b/sound/soc/imx/imx-esai.h
index 9e7b8b3..53c899e 100644
--- a/sound/soc/imx/imx-esai.h
+++ b/sound/soc/imx/imx-esai.h
@@ -298,13 +298,10 @@
 #define ESAI_RX_DIV_PM	4
 #define ESAI_RX_DIV_FP	5
 
-#define IMX_ESAI_DMABUF_SIZE     (64 * 1024)
-
 #define DRV_NAME "imx-esai"
 
 #include <linux/dmaengine.h>
 #include <mach/dma.h>
-#include "imx-pcm.h"
 
 #define IMX_DAI_ESAI_TX 0x04
 #define IMX_DAI_ESAI_RX 0x08
diff --git a/sound/soc/imx/imx-pcm-dma-mx2.c b/sound/soc/imx/imx-pcm-dma-mx2.c
index 0343e994..89d80d8 100644
--- a/sound/soc/imx/imx-pcm-dma-mx2.c
+++ b/sound/soc/imx/imx-pcm-dma-mx2.c
@@ -21,63 +21,396 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/dmaengine.h>
-#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/mxc_asrc.h>
 
 #include <sound/core.h>
 #include <sound/initval.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
-#include <sound/dmaengine_pcm.h>
 
 #include <mach/dma.h>
 
+#include "imx-ssi.h"
 #include "imx-pcm.h"
 
+struct asrc_p2p_ops *asrc_pcm_p2p_ops;
+
+void asrc_p2p_hook(struct asrc_p2p_ops *asrc_p2p_ct)
+{
+	asrc_pcm_p2p_ops = asrc_p2p_ct;
+	return ;
+}
+EXPORT_SYMBOL(asrc_p2p_hook);
+
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+
+	iprtd->offset += iprtd->period_bytes;
+	iprtd->offset %= iprtd->period_bytes * iprtd->periods;
+
+	snd_pcm_period_elapsed(substream);
+}
+
 static bool filter(struct dma_chan *chan, void *param)
 {
+	struct imx_pcm_runtime_data *iprtd = param;
+
 	if (!imx_dma_is_general_purpose(chan))
 		return false;
 
-	chan->private = param;
+        chan->private = &iprtd->dma_data;
 
+        return true;
+}
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_IMX_HAVE_PLATFORM_IMX_ASRC)
+static bool asrc_filter(struct dma_chan *chan, void *param)
+{
+	struct imx_pcm_runtime_data *iprtd = param;
+	if (!imx_dma_is_general_purpose(chan))
+		return false;
+	chan->private = &iprtd->asrc_dma_data;
 	return true;
 }
-
-static int snd_imx_pcm_hw_params(struct snd_pcm_substream *substream,
+static bool asrc_p2p_filter(struct dma_chan *chan, void *param)
+{
+	struct imx_pcm_runtime_data *iprtd = param;
+	if (!imx_dma_is_general_purpose(chan))
+		return false;
+    chan->private = &iprtd->asrc_p2p_dma_data;
+    return true;
+}
+static int imx_ssi_asrc_dma_alloc(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
 	struct imx_pcm_dma_params *dma_params;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
 	struct dma_slave_config slave_config;
+
+	dma_cap_mask_t mask;
+	enum dma_slave_buswidth buswidth;
 	int ret;
 
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		goto error;
+	}
+
 	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	/*config m2p dma channel*/
+	iprtd->asrc_dma_data.peripheral_type = IMX_DMATYPE_ASRC;
+	iprtd->asrc_dma_data.priority = DMA_PRIO_HIGH;
+	iprtd->asrc_dma_data.dma_request =
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_get_dma_request(iprtd->asrc_index, 1);
+	iprtd->asrc_dma_chan = dma_request_channel(mask, asrc_filter, iprtd);
+
+	if (!iprtd->asrc_dma_chan)
+		goto error;
 
-	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
+	slave_config.direction = DMA_TO_DEVICE;
+	slave_config.dst_addr = iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_per_addr(iprtd->asrc_index, 1);
+	slave_config.dst_addr_width = buswidth;
+	slave_config.dst_maxburst = dma_params->burstsize * buswidth;
+
+	ret = dmaengine_slave_config(iprtd->asrc_dma_chan, &slave_config);
 	if (ret)
-		return ret;
+		goto error;
+	/*config p2p dma channel*/
+	iprtd->asrc_p2p_dma_data.peripheral_type = IMX_DMATYPE_ASRC;
+	iprtd->asrc_p2p_dma_data.priority = DMA_PRIO_HIGH;
+	iprtd->asrc_p2p_dma_data.dma_request =
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_get_dma_request(iprtd->asrc_index, 0);
+	iprtd->asrc_p2p_dma_data.dma_request_p2p = dma_params->dma;
+	iprtd->asrc_p2p_dma_chan =
+		dma_request_channel(mask, asrc_p2p_filter, iprtd);
+	if (!iprtd->asrc_p2p_dma_chan)
+		goto error;
+
+	switch (iprtd->p2p->p2p_width) {
+	case ASRC_WIDTH_16_BIT:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case ASRC_WIDTH_24_BIT:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	slave_config.direction = DMA_DEV_TO_DEV;
+	slave_config.src_addr = iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_per_addr(iprtd->asrc_index, 0);
+	slave_config.src_addr_width = buswidth;
+	slave_config.src_maxburst = dma_params->burstsize * buswidth;
+	slave_config.dst_addr = dma_params->dma_addr;
+	slave_config.dst_addr_width = buswidth;
+	slave_config.dst_maxburst = dma_params->burstsize * buswidth;
 
-	slave_config.device_fc = false;
+	ret = dmaengine_slave_config(iprtd->asrc_p2p_dma_chan, &slave_config);
+	if (ret)
+		goto error;
+
+	return 0;
+error:
+	if (iprtd->asrc_dma_chan) {
+		dma_release_channel(iprtd->asrc_dma_chan);
+		iprtd->asrc_dma_chan = NULL;
+	}
+	if (iprtd->asrc_p2p_dma_chan) {
+		dma_release_channel(iprtd->asrc_p2p_dma_chan);
+		iprtd->asrc_p2p_dma_chan = NULL;
+	}
+	return -EINVAL;
+}
+#endif
+
+static int imx_ssi_dma_alloc(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct imx_pcm_dma_params *dma_params;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+	struct dma_slave_config slave_config;
+	dma_cap_mask_t mask;
+	enum dma_slave_buswidth buswidth;
+	int ret;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	iprtd->dma_data.peripheral_type = dma_params->peripheral_type;
+	iprtd->dma_data.priority = DMA_PRIO_HIGH;
+	iprtd->dma_data.dma_request = dma_params->dma;
+
+	/* Try to grab a DMA channel */
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	iprtd->dma_chan = dma_request_channel(mask, filter, iprtd);
+	if (!iprtd->dma_chan)
+		return -EINVAL;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		return 0;
+	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.direction = DMA_TO_DEVICE;
 		slave_config.dst_addr = dma_params->dma_addr;
-		slave_config.dst_maxburst = dma_params->burstsize;
+		slave_config.dst_addr_width = buswidth;
+		slave_config.dst_maxburst = dma_params->burstsize * buswidth;
 	} else {
+		slave_config.direction = DMA_FROM_DEVICE;
 		slave_config.src_addr = dma_params->dma_addr;
-		slave_config.src_maxburst = dma_params->burstsize;
+		slave_config.src_addr_width = buswidth;
+		slave_config.src_maxburst = dma_params->burstsize * buswidth;
 	}
 
-	ret = dmaengine_slave_config(chan, &slave_config);
+	ret = dmaengine_slave_config(iprtd->dma_chan, &slave_config);
 	if (ret)
 		return ret;
 
+	return 0;
+}
+
+static int snd_imx_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+	unsigned long dma_addr;
+	struct dma_chan *chan;
+	struct imx_pcm_dma_params *dma_params;
+	int ret;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	if (iprtd->asrc_enable) {
+		ret = imx_ssi_asrc_dma_alloc(substream, params);
+		if (ret)
+			return ret;
+
+		chan = iprtd->asrc_p2p_dma_chan;
+		iprtd->asrc_p2p_desc =
+			chan->device->device_prep_dma_cyclic(chan, 0xffff,
+							64,
+							64,
+							     DMA_DEV_TO_DEV, NULL);
+		if (!iprtd->asrc_p2p_desc) {
+			dev_err(&chan->dev->device,
+					"cannot prepare slave dma\n");
+			return -EINVAL;
+		}
+		chan = iprtd->asrc_dma_chan;
+	} else {
+		ret = imx_ssi_dma_alloc(substream, params);
+		if (ret)
+			return ret;
+
+		chan = iprtd->dma_chan;
+	}
+
+	iprtd->size = params_buffer_bytes(params);
+	iprtd->periods = params_periods(params);
+	iprtd->period_bytes = params_period_bytes(params);
+	iprtd->offset = 0;
+	iprtd->period_time = HZ / (params_rate(params) /
+					params_period_size(params));
+
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 
+	dma_addr = runtime->dma_addr;
+
+	iprtd->buf = (unsigned int *)substream->dma_buffer.area;
+
+	if (iprtd->asrc_enable) {
+		iprtd->asrc_desc =
+			chan->device->device_prep_dma_cyclic(chan, dma_addr,
+				iprtd->period_bytes * iprtd->periods,
+				iprtd->period_bytes,
+				substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+							     DMA_TO_DEVICE : DMA_FROM_DEVICE, NULL);
+		if (!iprtd->asrc_desc) {
+			dev_err(&chan->dev->device,
+					"cannot prepare slave dma\n");
+			return -EINVAL;
+		}
+
+		iprtd->asrc_desc->callback = audio_dma_irq;
+		iprtd->asrc_desc->callback_param = substream;
+	} else {
+		iprtd->desc = chan->device->device_prep_dma_cyclic(
+			chan, dma_addr,
+			iprtd->period_bytes * iprtd->periods,
+			iprtd->period_bytes,
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			DMA_TO_DEVICE : DMA_FROM_DEVICE, NULL);
+		if (!iprtd->desc) {
+			dev_err(&chan->dev->device,
+					"cannot prepare slave dma\n");
+			return -EINVAL;
+		}
+
+		iprtd->desc->callback = audio_dma_irq;
+		iprtd->desc->callback_param = substream;
+	}
+
+	return 0;
+}
+
+static int snd_imx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+
+	if (iprtd->asrc_enable) {
+		if (iprtd->asrc_dma_chan) {
+			dma_release_channel(iprtd->asrc_dma_chan);
+			iprtd->asrc_dma_chan = NULL;
+		}
+		if (iprtd->asrc_p2p_dma_chan) {
+			dma_release_channel(iprtd->asrc_p2p_dma_chan);
+			iprtd->asrc_p2p_dma_chan = NULL;
+		}
+		iprtd->dma_chan = NULL;
+	} else {
+		if (iprtd->dma_chan) {
+			dma_release_channel(iprtd->dma_chan);
+			iprtd->dma_chan = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int snd_imx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct imx_pcm_dma_params *dma_params;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	return 0;
+}
+
+static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (iprtd->asrc_enable) {
+			dmaengine_submit(iprtd->asrc_p2p_desc);
+			dmaengine_submit(iprtd->asrc_desc);
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_start_conv(iprtd->asrc_index);
+			mdelay(1);
+		} else {
+			dmaengine_submit(iprtd->desc);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (iprtd->asrc_enable) {
+			dmaengine_terminate_all(iprtd->asrc_dma_chan);
+			dmaengine_terminate_all(iprtd->asrc_p2p_dma_chan);
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_stop_conv(iprtd->asrc_index);
+		} else {
+			dmaengine_terminate_all(iprtd->dma_chan);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
+static snd_pcm_uframes_t snd_imx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
+
+	pr_debug("%s: %ld %ld\n", __func__, iprtd->offset,
+			bytes_to_frames(substream->runtime, iprtd->offset));
+
+	return bytes_to_frames(substream->runtime, iprtd->offset);
+}
+
 static struct snd_pcm_hardware snd_imx_hardware = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED |
 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -89,7 +422,7 @@ static struct snd_pcm_hardware snd_imx_hardware = {
 	.rate_min = 8000,
 	.channels_min = 2,
 	.channels_max = 2,
-	.buffer_bytes_max = IMX_SSI_DMABUF_SIZE,
+	.buffer_bytes_max = IMX_DEFAULT_DMABUF_SIZE,
 	.period_bytes_min = 128,
 	.period_bytes_max = 65535, /* Limited by SDMA engine */
 	.periods_min = 2,
@@ -99,37 +432,55 @@ static struct snd_pcm_hardware snd_imx_hardware = {
 
 static int snd_imx_open(struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct imx_pcm_dma_params *dma_params;
-	struct imx_dma_data *dma_data;
+	struct imx_pcm_runtime_data *iprtd;
 	int ret;
 
-	snd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);
-
-	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	iprtd = kzalloc(sizeof(*iprtd), GFP_KERNEL);
+	if (iprtd == NULL)
+		return -ENOMEM;
+	if (!strcmp(rtd->dai_link->name, "HiFi_ASRC")) {
+		iprtd->asrc_enable = true;
+		iprtd->p2p =
+			(struct asrc_p2p_params *)snd_soc_pcm_get_drvdata(rtd);
+		iprtd->asrc_index = -1;
+		if (!asrc_pcm_p2p_ops) {
+			pr_err("ASRC is not loaded!\n");
+			return -EINVAL;
+		}
+		iprtd->asrc_pcm_p2p_ops_ko = asrc_pcm_p2p_ops;
+	}
 
-	dma_data = kzalloc(sizeof(*dma_data), GFP_KERNEL);
-	dma_data->peripheral_type = dma_params->shared_peripheral;
-	dma_data->priority = DMA_PRIO_HIGH;
-	dma_data->dma_request = dma_params->dma;
+	runtime->private_data = iprtd;
 
-	ret = snd_dmaengine_pcm_open(substream, filter, dma_data);
-	if (ret) {
-		kfree(dma_data);
-		return 0;
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		kfree(iprtd);
+		return ret;
 	}
 
-	snd_dmaengine_pcm_set_data(substream, dma_data);
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+		snd_imx_hardware.buffer_bytes_max = IMX_SSI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-esai", strlen("imx-esai")))
+		snd_imx_hardware.buffer_bytes_max = IMX_ESAI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-spdif", strlen("imx-spdif")))
+		snd_imx_hardware.buffer_bytes_max = IMX_SPDIF_DMABUF_SIZE;
+	else
+		snd_imx_hardware.buffer_bytes_max = IMX_DEFAULT_DMABUF_SIZE;
+
+	snd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);
 
 	return 0;
 }
 
 static int snd_imx_close(struct snd_pcm_substream *substream)
 {
-	struct imx_dma_data *dma_data = snd_dmaengine_pcm_get_data(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_pcm_runtime_data *iprtd = runtime->private_data;
 
-	snd_dmaengine_pcm_close(substream);
-	kfree(dma_data);
+	kfree(iprtd);
 
 	return 0;
 }
@@ -139,8 +490,10 @@ static struct snd_pcm_ops imx_pcm_ops = {
 	.close		= snd_imx_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= snd_imx_pcm_hw_params,
-	.trigger	= snd_dmaengine_pcm_trigger,
-	.pointer	= snd_dmaengine_pcm_pointer,
+	.hw_free	= snd_imx_pcm_hw_free,
+	.prepare	= snd_imx_pcm_prepare,
+	.trigger	= snd_imx_pcm_trigger,
+	.pointer	= snd_imx_pcm_pointer,
 	.mmap		= snd_imx_pcm_mmap,
 };
 
@@ -152,6 +505,14 @@ static struct snd_soc_platform_driver imx_soc_platform_mx2 = {
 
 static int __devinit imx_soc_platform_probe(struct platform_device *pdev)
 {
+	struct imx_ssi *ssi = platform_get_drvdata(pdev);
+
+	if (ssi->dma_params_tx.burstsize == 0
+			&& ssi->dma_params_rx.burstsize == 0) {
+		ssi->dma_params_tx.burstsize = 6;
+		ssi->dma_params_rx.burstsize = 4;
+	}
+
 	return snd_soc_register_platform(&pdev->dev, &imx_soc_platform_mx2);
 }
 
@@ -170,6 +531,16 @@ static struct platform_driver imx_pcm_driver = {
 	.remove = __devexit_p(imx_soc_platform_remove),
 };
 
-module_platform_driver(imx_pcm_driver);
+static int __init snd_imx_pcm_init(void)
+{
+	return platform_driver_register(&imx_pcm_driver);
+}
+module_init(snd_imx_pcm_init);
+
+static void __exit snd_imx_pcm_exit(void)
+{
+	platform_driver_unregister(&imx_pcm_driver);
+}
+module_exit(snd_imx_pcm_exit);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:imx-pcm-audio");
diff --git a/sound/soc/imx/imx-pcm.h b/sound/soc/imx/imx-pcm.h
index eb72ced..1b126be 100644
--- a/sound/soc/imx/imx-pcm.h
+++ b/sound/soc/imx/imx-pcm.h
@@ -1,34 +1,76 @@
 /*
- * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
+ * MXC  ALSA Soc Driver
  *
- * This code is based on code copyrighted by Freescale,
- * Liam Girdwood, Javier Martin and probably others.
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #ifndef _IMX_PCM_H
 #define _IMX_PCM_H
 
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/mxc_asrc.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
 #include <mach/dma.h>
-/*
- * Do not change this as the FIQ handler depends on this size
- */
-#define IMX_SSI_DMABUF_SIZE	(64 * 1024)
 
-struct imx_pcm_dma_params {
-	int dma;
-	unsigned long dma_addr;
-	int burstsize;
-	enum sdma_peripheral_type shared_peripheral; /* The peripheral is on SPBA bus */
-};
+#define IMX_DEFAULT_DMABUF_SIZE		(64 * 1024)
+#define IMX_SSI_DMABUF_SIZE			(64 * 1024)
+#define IMX_ESAI_DMABUF_SIZE		(256 * 1024)
+#define IMX_SPDIF_DMABUF_SIZE		(64 * 1024)
 
-int snd_imx_pcm_mmap(struct snd_pcm_substream *substream,
-		     struct vm_area_struct *vma);
-int imx_pcm_new(struct snd_soc_pcm_runtime *rtd);
-void imx_pcm_free(struct snd_pcm *pcm);
+struct imx_pcm_runtime_data {
+	int period_bytes;
+	int periods;
+	int dma;
+	unsigned long offset;
+	unsigned long size;
+	void *buf;
+	int period_time;
+	struct dma_async_tx_descriptor *desc;
+	struct dma_chan *dma_chan;
+	struct imx_dma_data dma_data;
+	int asrc_enable;
+	struct asrc_p2p_ops *asrc_pcm_p2p_ops_ko;
 
-#endif /* _IMX_PCM_H */
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_IMX_HAVE_PLATFORM_IMX_ASRC)
+	enum asrc_pair_index asrc_index;
+	struct dma_async_tx_descriptor *asrc_desc;
+	struct dma_chan *asrc_dma_chan;
+	struct imx_dma_data asrc_dma_data;
+	struct dma_async_tx_descriptor *asrc_p2p_desc;
+	struct dma_chan *asrc_p2p_dma_chan;
+	struct imx_dma_data asrc_p2p_dma_data;
+	struct asrc_p2p_params *p2p;
+#endif
+};
+#endif
diff --git a/sound/soc/imx/imx-sgtl5000.c b/sound/soc/imx/imx-sgtl5000.c
index 412fc85..ad577c2 100644
--- a/sound/soc/imx/imx-sgtl5000.c
+++ b/sound/soc/imx/imx-sgtl5000.c
@@ -145,6 +145,18 @@ static int sgtl5000_set_jack(struct snd_kcontrol *kcontrol,
 	return 1;
 }
 
+static int spk_amp_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *kcontrol, int event)
+{
+	struct imx_sgtl5000_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat->amp_enable)
+		plat->amp_enable(SND_SOC_DAPM_EVENT_ON(event)? 1 : 0);
+	return 0;
+}
+
 static int sgtl5000_get_spk(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *ucontrol)
 {
@@ -199,7 +211,7 @@ static int sgtl5000_set_line_in(struct snd_kcontrol *kcontrol,
 static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
 	SND_SOC_DAPM_MIC("Mic Jack", NULL),
 	SND_SOC_DAPM_LINE("Line In Jack", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", spk_amp_event),
 	SND_SOC_DAPM_HP("Headphone Jack", NULL),
 };
 
diff --git a/sound/soc/imx/imx-si4763.c b/sound/soc/imx/imx-si4763.c
new file mode 100644
index 0000000..3e3e8db
--- /dev/null
+++ b/sound/soc/imx/imx-si4763.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/fsl_devices.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <mach/audmux.h>
+#include <mach/ssi.h>
+
+#include "imx-ssi.h"
+#include "imx-audmux.h"
+
+static struct imx_si4763_priv {
+	int sysclk;
+	int hw;
+	int active;
+	struct platform_device *pdev;
+} card_priv;
+
+static int imx_audmux_config(int slave, int master)
+{
+	unsigned int ptcr, pdcr;
+	slave = slave - 1;
+	master = master - 1;
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN |
+		MXC_AUDMUX_V2_PTCR_TFSDIR |
+		MXC_AUDMUX_V2_PTCR_TFSEL(slave) |
+		MXC_AUDMUX_V2_PTCR_TCLKDIR |
+		MXC_AUDMUX_V2_PTCR_TCSEL(slave);
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(slave);
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN;
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(master);
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	return 0;
+}
+
+
+static int imx_3stack_si4763_startup(struct snd_pcm_substream *substream)
+{
+	struct imx_si4763_priv *priv = &card_priv;
+
+	priv->active++;
+	return 0;
+}
+
+static int imx_3stack_si4763_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	unsigned int channels = params_channels(params);
+	struct imx_ssi *ssi_mode = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+	u32 dai_format;
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS;
+
+	ssi_mode->flags |= IMX_SSI_SYN;
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+			channels == 1 ? 0xfffffffe : 0xfffffffc,
+			channels == 1 ? 0xfffffffe : 0xfffffffc,
+			2, 32);
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set the SSI system clock as input (unused) */
+	snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 4);
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_2, 1);
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PSR, 0);
+	return 0;
+}
+
+static void imx_3stack_si4763_shutdown(struct snd_pcm_substream *substream)
+{
+	struct imx_si4763_priv *priv = &card_priv;
+	priv->active--;
+}
+
+/*
+ * imx_3stack bt DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_si4763_ops = {
+	.startup = imx_3stack_si4763_startup,
+	.hw_params = imx_3stack_si4763_hw_params,
+	.shutdown = imx_3stack_si4763_shutdown,
+};
+
+static struct snd_soc_dai_link imx_3stack_dai = {
+	.name = "imx-si4763",
+	.stream_name = "imx-si4763",
+	.codec_dai_name = "si4763",
+	.codec_name     = "si4763.0",
+	.cpu_dai_name   = "imx-ssi.1",
+	.platform_name  = "imx-pcm-audio.1",
+	.ops = &imx_3stack_si4763_ops,
+};
+
+static struct snd_soc_card snd_soc_card_imx_3stack = {
+	.name = "imx-audio-si4763",
+	.dai_link = &imx_3stack_dai,
+	.num_links = 1,
+};
+
+static int __init imx_3stack_si4763_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	card_priv.pdev = pdev;
+	card_priv.sysclk = plat->sysclk;
+	imx_audmux_config(plat->src_port, plat->ext_port);
+
+	return 0;
+
+}
+
+static int __devexit imx_3stack_si4763_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver imx_3stack_si4763_driver = {
+	.probe = imx_3stack_si4763_probe,
+	.remove = __devexit_p(imx_3stack_si4763_remove),
+	.driver = {
+		   .name = "imx-tuner-si4763",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *imx_3stack_snd_device;
+
+static int __init imx_3stack_asoc_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&imx_3stack_si4763_driver);
+	if (ret < 0)
+		goto exit;
+
+	imx_3stack_snd_device = platform_device_alloc("soc-audio", 6);
+	if (!imx_3stack_snd_device)
+		goto err_device_alloc;
+
+	platform_set_drvdata(imx_3stack_snd_device, &snd_soc_card_imx_3stack);
+	ret = platform_device_add(imx_3stack_snd_device);
+	if (0 == ret)
+		goto exit;
+
+
+	platform_device_put(imx_3stack_snd_device);
+err_device_alloc:
+	platform_driver_unregister(&imx_3stack_si4763_driver);
+exit:
+	return ret;
+}
+
+static void __exit imx_3stack_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_si4763_driver);
+	platform_device_unregister(imx_3stack_snd_device);
+}
+
+module_init(imx_3stack_asoc_init);
+module_exit(imx_3stack_asoc_exit);
+
+/* Module information */
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("ALSA SoC si4763 imx");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-si4763.h b/sound/soc/imx/imx-si4763.h
new file mode 100644
index 0000000..8a641a6
--- /dev/null
+++ b/sound/soc/imx/imx-si4763.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_SI4763PCM_H
+#define _MXC_SI4763PCM_H
+
+extern struct snd_soc_dai si4763_dai;
+extern struct snd_soc_codec_device soc_codec_dev_si4763;
+#endif
diff --git a/sound/soc/imx/imx-spdif-dai.c b/sound/soc/imx/imx-spdif-dai.c
index 8645853..a3b3865 100644
--- a/sound/soc/imx/imx-spdif-dai.c
+++ b/sound/soc/imx/imx-spdif-dai.c
@@ -24,7 +24,6 @@
 #include <mach/dma.h>
 #include <mach/hardware.h>
 
-#include "imx-pcm.h"
 #include "../codecs/mxc_spdif.h"
 
 #define MXC_SPDIF_TXFIFO_WML      0x8
@@ -33,9 +32,9 @@
 struct imx_pcm_dma_params dma_params_tx;
 struct imx_pcm_dma_params dma_params_rx;
 
-static int imx_spdif_startup(struct snd_pcm_substream *substream,
-			   struct snd_soc_dai *cpu_dai)
-
+static int imx_spdif_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *cpu_dai)
 {
 	/* Tx/Rx config */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -47,7 +46,7 @@ static int imx_spdif_startup(struct snd_pcm_substream *substream,
 }
 
 struct snd_soc_dai_ops imx_spdif_dai_ops = {
-	.startup        = imx_spdif_startup,
+	.hw_params      = imx_spdif_hw_params,
 };
 
 struct snd_soc_dai_driver imx_spdif_dai = {
@@ -74,8 +73,8 @@ static int imx_spdif_dai_probe(struct platform_device *pdev)
 	dma_params_tx.burstsize = MXC_SPDIF_TXFIFO_WML;
 	dma_params_rx.burstsize = MXC_SPDIF_RXFIFO_WML;
 
-	dma_params_tx.shared_peripheral = IMX_DMATYPE_SPDIF;
-	dma_params_rx.shared_peripheral = IMX_DMATYPE_SPDIF;
+	dma_params_tx.peripheral_type = IMX_DMATYPE_SPDIF;
+	dma_params_rx.peripheral_type = IMX_DMATYPE_SPDIF;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");
 	if (res)
diff --git a/sound/soc/imx/imx-spdif.c b/sound/soc/imx/imx-spdif.c
index b3f8fd2..542dd9f 100644
--- a/sound/soc/imx/imx-spdif.c
+++ b/sound/soc/imx/imx-spdif.c
@@ -123,7 +123,6 @@ static int __init imx_spdif_init(void)
 	imx_spdif_dai_link.name = "HDMI-Audio";
 	imx_spdif_dai_link.stream_name = "HDMI-Audio";
 #endif
-
 	platform_set_drvdata(imx_spdif_snd_device, &snd_soc_card_imx_spdif);
 
 	ret = platform_device_add(imx_spdif_snd_device);
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
index 2c941c3..e401517 100644
--- a/sound/soc/imx/imx-ssi.c
+++ b/sound/soc/imx/imx-ssi.c
@@ -1,8 +1,13 @@
 /*
  * imx-ssi.c  --  ALSA Soc Audio Layer
  *
+ * Copyright 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
  * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
  *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  * This code is based on code copyrighted by Freescale,
  * Liam Girdwood, Javier Martin and probably others.
  *
@@ -48,11 +53,19 @@
 #include <sound/soc.h>
 
 #include <mach/ssi.h>
+#include <mach/iram.h>
 #include <mach/hardware.h>
 
 #include "imx-ssi.h"
+#include "imx-pcm.h"
 
 #define SSI_SACNT_DEFAULT (SSI_SACNT_AC97EN | SSI_SACNT_FV)
+#define IMX_SSI_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+static int UseIRAM;
+#endif
 
 /*
  * SSI Network Mode or TDM slots configuration.
@@ -96,10 +109,6 @@ static int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 	case SND_SOC_DAIFMT_I2S:
 		/* data on rising edge of bclk, frame low 1clk before data */
 		strcr |= SSI_STCR_TFSI | SSI_STCR_TEFS | SSI_STCR_TXBIT0;
-		if (ssi->flags & IMX_SSI_USE_I2S_SLAVE) {
-			scr &= ~SSI_I2S_MODE_MASK;
-			scr |= SSI_SCR_I2S_MODE_SLAVE;
-		}
 		break;
 	case SND_SOC_DAIFMT_LEFT_J:
 		/* data on rising edge of bclk, frame high with data */
@@ -135,10 +144,21 @@ static int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 
 	/* DAI clock master masks */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		strcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
+		if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S) {
+			scr &= ~SSI_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_MSTR;
+		}
+		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
+		strcr &= ~(SSI_STCR_TFDIR | SSI_STCR_TXDIR);
+		if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S) {
+			scr &= ~SSI_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_SLAVE;
+		}
 		break;
 	default:
-		/* Master mode not implemented, needs handling of clocks. */
 		return -EINVAL;
 	}
 
@@ -147,7 +167,13 @@ static int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 	if (ssi->flags & IMX_SSI_SYN)
 		scr |= SSI_SCR_SYN;
 
+	/* Dual-FIFO support */
+	strcr |= SSI_STCR_TFEN1;
+	scr |= SSI_SCR_TCH_EN;
+
 	writel(strcr, ssi->base + SSI_STCR);
+	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) == SND_SOC_DAIFMT_CBS_CFS)
+		strcr &= ~(SSI_STCR_TFDIR | SSI_STCR_TXDIR);
 	writel(strcr, ssi->base + SSI_SRCR);
 	writel(scr, ssi->base + SSI_SCR);
 
@@ -197,28 +223,40 @@ static int imx_ssi_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
 
 	switch (div_id) {
 	case IMX_SSI_TX_DIV_2:
+		if (div & (~SSI_STCCR_DIV2))
+			return EINVAL;
 		stccr &= ~SSI_STCCR_DIV2;
 		stccr |= div;
 		break;
 	case IMX_SSI_TX_DIV_PSR:
+		if (div & (~SSI_STCCR_PSR))
+			return EINVAL;
 		stccr &= ~SSI_STCCR_PSR;
 		stccr |= div;
 		break;
 	case IMX_SSI_TX_DIV_PM:
-		stccr &= ~0xff;
+		if (div & (~SSI_STCCR_PM_MASK))
+			return EINVAL;
+		stccr &= ~SSI_STCCR_PM_MASK;
 		stccr |= SSI_STCCR_PM(div);
 		break;
 	case IMX_SSI_RX_DIV_2:
-		stccr &= ~SSI_STCCR_DIV2;
-		stccr |= div;
+		if (div & (~SSI_SRCCR_DIV2))
+			return EINVAL;
+		srccr &= ~SSI_SRCCR_DIV2;
+		srccr |= div;
 		break;
 	case IMX_SSI_RX_DIV_PSR:
-		stccr &= ~SSI_STCCR_PSR;
-		stccr |= div;
+		if (div & (~SSI_SRCCR_PSR))
+			return EINVAL;
+		srccr &= ~SSI_SRCCR_PSR;
+		srccr |= div;
 		break;
 	case IMX_SSI_RX_DIV_PM:
-		stccr &= ~0xff;
-		stccr |= SSI_STCCR_PM(div);
+		if (div & (~SSI_SRCCR_PM_MASK))
+			return EINVAL;
+		srccr &= ~SSI_SRCCR_PM_MASK;
+		srccr |= SSI_STCCR_PM(div);
 		break;
 	default:
 		return -EINVAL;
@@ -230,23 +268,6 @@ static int imx_ssi_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
-static int imx_ssi_startup(struct snd_pcm_substream *substream,
-			   struct snd_soc_dai *cpu_dai)
-{
-	struct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);
-	struct imx_pcm_dma_params *dma_data;
-
-	/* Tx/Rx config */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dma_data = &ssi->dma_params_tx;
-	else
-		dma_data = &ssi->dma_params_rx;
-
-	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
-
-	return 0;
-}
-
 /*
  * Should only be called when port is inactive (i.e. SSIEN = 0),
  * although can be called multiple times by upper layers.
@@ -256,18 +277,24 @@ static int imx_ssi_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *cpu_dai)
 {
 	struct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);
+	struct imx_pcm_dma_params *dma_data;
 	u32 reg, sccr, scr;
 	unsigned int channels = params_channels(params);
 
 	/* Tx/Rx config */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		reg = SSI_STCCR;
-	else
+		dma_data = &ssi->dma_params_tx;
+	} else {
 		reg = SSI_SRCCR;
+		dma_data = &ssi->dma_params_rx;
+	}
 
 	if (ssi->flags & IMX_SSI_SYN)
 		reg = SSI_STCCR;
 
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+
 	sccr = readl(ssi->base + reg) & ~SSI_STCCR_WL_MASK;
 
 	/* DAI data (word) size */
@@ -287,9 +314,10 @@ static int imx_ssi_hw_params(struct snd_pcm_substream *substream,
 
 	scr = readl(ssi->base + SSI_SCR);
 
-	if (channels == 1)
+	if (channels == 1) {
 		scr &= ~SSI_SCR_NET;
-	else
+		scr &= ~SSI_I2S_MODE_MASK;
+	} else
 		scr |= SSI_SCR_NET;
 
 	writel(scr, ssi->base + SSI_SCR);
@@ -359,16 +387,226 @@ static int imx_ssi_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-static const struct snd_soc_dai_ops imx_ssi_pcm_dai_ops = {
-	.startup	= imx_ssi_startup,
+static int imx_ssi_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	struct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (cpu_dai->playback_active || cpu_dai->capture_active)
+		return 0;
+
+	clk_enable(ssi->clk);
+
+	return 0;
+}
+
+static void imx_ssi_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);
+
+	/* shutdown SSI if neither Tx or Rx is active */
+	if (cpu_dai->playback_active || cpu_dai->capture_active)
+		return;
+
+	clk_disable(ssi->clk);
+}
+
+static struct snd_soc_dai_ops imx_ssi_pcm_dai_ops = {
 	.hw_params	= imx_ssi_hw_params,
 	.set_fmt	= imx_ssi_set_dai_fmt,
 	.set_clkdiv	= imx_ssi_set_dai_clkdiv,
 	.set_sysclk	= imx_ssi_set_dai_sysclk,
 	.set_tdm_slot	= imx_ssi_set_dai_tdm_slot,
 	.trigger	= imx_ssi_trigger,
+	.startup	= imx_ssi_startup,
+	.shutdown	= imx_ssi_shutdown,
 };
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+};
+
+/*
+	enable user space access to iram buffer
+*/
+static int imx_iram_audio_playback_mmap(struct snd_pcm_substream *substream,
+					struct vm_area_struct *area)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	unsigned long off;
+	unsigned long phys;
+	unsigned long size;
+	int ret = 0;
+
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+
+	off = area->vm_pgoff << PAGE_SHIFT;
+	phys = buf->addr + off;
+	size = area->vm_end - area->vm_start;
+
+	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+	area->vm_flags |= VM_IO;
+	ret =
+	    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+			    size, area->vm_page_prot);
+
+	return ret;
+}
+#endif
+
+int snd_imx_pcm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream)))
+		ret = imx_iram_audio_playback_mmap(substream, vma);
+	else
+		ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
+			runtime->dma_addr, runtime->dma_bytes);
+#else
+	ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
+			runtime->dma_addr, runtime->dma_bytes);
+#endif
+	pr_debug("%s: ret: %d %p 0x%08x 0x%08x\n", __func__, ret,
+			runtime->dma_area,
+			runtime->dma_addr,
+			runtime->dma_bytes);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_imx_pcm_mmap);
+
+static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	unsigned long buf_paddr;
+#endif
+
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+		size = IMX_SSI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-esai", strlen("imx-esai")))
+		size = IMX_ESAI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-spdif", strlen("imx-spdif")))
+		size = IMX_SPDIF_DMABUF_SIZE;
+	else
+		size = IMX_DEFAULT_DMABUF_SIZE;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->bytes = size;
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi"))) {
+		buf->area = iram_alloc(size, &buf_paddr);
+		if (!buf->area) {
+			buf->area =
+			    dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+			if (!buf->area)
+				return -ENOMEM;
+		} else {
+			buf->addr = buf_paddr;
+			UseIRAM |= 1<<substream->stream;
+		}
+	} else {
+		buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+		if (!buf->area)
+			return -ENOMEM;
+
+	}
+#else
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+#endif
+
+	return 0;
+}
+
+static u64 imx_pcm_dmamask = DMA_BIT_MASK(32);
+
+int imx_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &imx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(imx_pcm_new);
+
+void imx_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+#endif
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+		if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream))) {
+			iram_free(buf->addr, IMX_SSI_DMABUF_SIZE);
+			UseIRAM &= ~(1<<substream->stream);
+		} else {
+			dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		}
+#else
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+#endif
+		buf->area = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(imx_pcm_free);
+
 static int imx_ssi_dai_probe(struct snd_soc_dai *dai)
 {
 	struct imx_ssi *ssi = dev_get_drvdata(dai->dev);
@@ -377,25 +615,44 @@ static int imx_ssi_dai_probe(struct snd_soc_dai *dai)
 	snd_soc_dai_set_drvdata(dai, ssi);
 
 	val = SSI_SFCSR_TFWM0(ssi->dma_params_tx.burstsize) |
-		SSI_SFCSR_RFWM0(ssi->dma_params_rx.burstsize);
+		SSI_SFCSR_RFWM0(ssi->dma_params_rx.burstsize) |
+		SSI_SFCSR_TFWM1(ssi->dma_params_tx.burstsize) |
+		SSI_SFCSR_RFWM1(ssi->dma_params_rx.burstsize) ;
 	writel(val, ssi->base + SSI_SFCSR);
 
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int imx_ssi_dai_suspend(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int imx_ssi_dai_resume(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+#else
+#define imx_ssi_suspend	NULL
+#define imx_ssi_resume	NULL
+#endif
+
 static struct snd_soc_dai_driver imx_ssi_dai = {
 	.probe = imx_ssi_dai_probe,
+	.suspend = imx_ssi_dai_suspend,
+	.resume = imx_ssi_dai_resume,
 	.playback = {
 		.channels_min = 1,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_96000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		.formats = IMX_SSI_FORMATS,
 	},
 	.capture = {
 		.channels_min = 1,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_96000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		.formats = IMX_SSI_FORMATS,
 	},
 	.ops = &imx_ssi_pcm_dai_ops,
 };
@@ -430,10 +687,10 @@ static void setup_channel_to_ac97(struct imx_ssi *imx_ssi)
 
 	writel(SSI_SCR_SYN | SSI_SCR_NET, base + SSI_SCR);
 
-	writel(SSI_SFCSR_RFWM0(8) |
-		SSI_SFCSR_TFWM0(8) |
-		SSI_SFCSR_RFWM1(8) |
-		SSI_SFCSR_TFWM1(8), base + SSI_SFCSR);
+	writel(SSI_SFCSR_RFWM0(imx_ssi->dma_params_rx.burstsize) |
+		SSI_SFCSR_TFWM0(imx_ssi->dma_params_tx.burstsize) |
+		SSI_SFCSR_RFWM1(imx_ssi->dma_params_rx.burstsize) |
+		SSI_SFCSR_TFWM1(imx_ssi->dma_params_tx.burstsize), base + SSI_SFCSR);
 
 	writel(SSI_STCCR_WL(16) | SSI_STCCR_DC(12), base + SSI_STCCR);
 	writel(SSI_STCCR_WL(16) | SSI_STCCR_DC(12), base + SSI_SRCCR);
@@ -582,17 +839,17 @@ static int imx_ssi_probe(struct platform_device *pdev)
 		dai = &imx_ssi_dai;
 
 	writel(0x0, ssi->base + SSI_SIER);
+	clk_disable(ssi->clk);
 
 	ssi->dma_params_rx.dma_addr = res->start + SSI_SRX0;
 	ssi->dma_params_tx.dma_addr = res->start + SSI_STX0;
 
-	ssi->dma_params_tx.shared_peripheral = IMX_DMATYPE_SSI_SP;
-	ssi->dma_params_rx.shared_peripheral =
-			ssi->dma_params_tx.shared_peripheral;
-
 	ssi->dma_params_tx.burstsize = 6;
 	ssi->dma_params_rx.burstsize = 4;
 
+	ssi->dma_params_tx.peripheral_type = IMX_DMATYPE_SSI_SP;
+	ssi->dma_params_rx.peripheral_type = IMX_DMATYPE_SSI_SP;
+
 	res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx0");
 	if (res)
 		ssi->dma_params_tx.dma = res->start;
@@ -691,7 +948,18 @@ static struct platform_driver imx_ssi_driver = {
 	},
 };
 
-module_platform_driver(imx_ssi_driver);
+static int __init imx_ssi_init(void)
+{
+	return platform_driver_register(&imx_ssi_driver);
+}
+
+static void __exit imx_ssi_exit(void)
+{
+	platform_driver_unregister(&imx_ssi_driver);
+}
+
+module_init(imx_ssi_init);
+module_exit(imx_ssi_exit);
 
 /* Module information */
 MODULE_AUTHOR("Sascha Hauer, <s.hauer@pengutronix.de>");
diff --git a/sound/soc/imx/imx-ssi.h b/sound/soc/imx/imx-ssi.h
index 5744e86..5a3511e 100644
--- a/sound/soc/imx/imx-ssi.h
+++ b/sound/soc/imx/imx-ssi.h
@@ -187,7 +187,6 @@
 
 #include <linux/dmaengine.h>
 #include <mach/dma.h>
-#include "imx-pcm.h"
 
 struct imx_ssi {
 	struct platform_device *ac97_dev;
@@ -213,4 +212,13 @@ struct imx_ssi {
 	struct platform_device *soc_platform_pdev_fiq;
 };
 
+struct snd_soc_platform *imx_ssi_fiq_init(struct platform_device *pdev,
+		struct imx_ssi *ssi);
+void imx_ssi_fiq_exit(struct platform_device *pdev, struct imx_ssi *ssi);
+struct snd_soc_platform *imx_ssi_dma_mx2_init(struct platform_device *pdev,
+		struct imx_ssi *ssi);
+
+int snd_imx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma);
+int imx_pcm_new(struct snd_soc_pcm_runtime *rtd);
+void imx_pcm_free(struct snd_pcm *pcm);
 #endif /* _IMX_SSI_H */
diff --git a/sound/soc/imx/imx-wm8958.c b/sound/soc/imx/imx-wm8958.c
new file mode 100644
index 0000000..8d27858
--- /dev/null
+++ b/sound/soc/imx/imx-wm8958.c
@@ -0,0 +1,363 @@
+/*
+ * imx-wm8958.c
+ *
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/fsl_devices.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/jack.h>
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <mach/audmux.h>
+
+#include "imx-ssi.h"
+#include "../codecs/wm8994.h"
+#include <linux/mfd/wm8994/registers.h>
+#include "imx-audmux.h"
+
+struct imx_priv {
+	int sysclk;         /*mclk from the outside*/
+	int codec_sysclk;
+	int dai_hifi;
+	struct platform_device *pdev;
+	struct wm8994 *wm8958;
+};
+static struct imx_priv card_priv;
+static struct snd_soc_card snd_soc_card_imx;
+struct clk *codec_mclk;
+static struct snd_soc_jack hs_jack;
+
+/* Headphones jack detection DAPM pins */
+static struct snd_soc_jack_pin hs_jack_pins[] = {
+	{
+		.pin = "Headphone Jack",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+
+/* Headphones jack detection gpios */
+static struct snd_soc_jack_gpio hs_jack_gpios[] = {
+	[0] = {
+		/* gpio is set on per-platform basis */
+		.name		= "hp-gpio",
+		.report		= SND_JACK_HEADPHONE,
+		.debounce_time	= 200,
+	},
+};
+
+static int imx_hifi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	if (!codec_dai->active)
+		clk_enable(codec_mclk);
+
+	return 0;
+}
+
+static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	if (!codec_dai->active)
+		clk_disable(codec_mclk);
+
+	return;
+}
+
+static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	unsigned int channels = params_channels(params);
+	int ret = 0;
+	unsigned int pll_out;
+	u32 dai_format;
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 2, 32);
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	if (params_rate(params) == 8000 || params_rate(params) == 11025)
+		pll_out = params_rate(params) * 512;
+	else
+		pll_out = params_rate(params) * 256;
+
+	ret =
+	    snd_soc_dai_set_pll(codec_dai, WM8994_FLL1, WM8994_FLL_SRC_MCLK1,
+				priv->sysclk, pll_out);
+	if (ret < 0)
+		return ret;
+
+	ret =
+	    snd_soc_dai_set_sysclk(codec_dai, WM8994_SYSCLK_FLL1, pll_out,
+				   SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* ----input ------------------- */
+	/* Mic Jack --> MIC_IN (with automatic bias) */
+	{"MICBIAS2", NULL, "Headset Mic"},
+	{"IN1LP", NULL, "MICBIAS2"},
+	{"IN1LN", NULL, "Headset Mic"},
+
+	{"MICBIAS1", NULL, "Main Mic"},
+	{"IN1RP", NULL, "MICBIAS1"},
+	{"IN1RN", NULL, "Main Mic"},
+
+	/* ----output------------------- */
+	/* HP_OUT --> Headphone Jack */
+	{"Headphone Jack", NULL, "HPOUT1L"},
+	{"Headphone Jack", NULL, "HPOUT1R"},
+
+	/* LINE_OUT --> Ext Speaker */
+	{"Ext Spk", NULL, "SPKOUTLP"},
+	{"Ext Spk", NULL, "SPKOUTLN"},
+	{"Ext Spk", NULL, "SPKOUTRP"},
+	{"Ext Spk", NULL, "SPKOUTRN"},
+
+};
+
+static int imx_wm8958_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	int ret;
+
+/* Add imx specific widgets */
+	snd_soc_dapm_new_controls(&codec->dapm, imx_dapm_widgets,
+				  ARRAY_SIZE(imx_dapm_widgets));
+
+	/* Set up imx specific audio path audio_map */
+	snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
+
+	snd_soc_dapm_sync(&codec->dapm);
+
+	if (hs_jack_gpios[0].gpio != -1) {
+		/* Jack detection API stuff */
+		ret = snd_soc_jack_new(codec, "Headphone Jack",
+					   SND_JACK_HEADPHONE, &hs_jack);
+		if (ret)
+			return ret;
+
+		ret = snd_soc_jack_add_pins(&hs_jack, ARRAY_SIZE(hs_jack_pins),
+					hs_jack_pins);
+		if (ret) {
+			printk(KERN_ERR "failed to call  snd_soc_jack_add_pins\n");
+			return ret;
+		}
+
+		ret = snd_soc_jack_add_gpios(&hs_jack,
+				ARRAY_SIZE(hs_jack_gpios), hs_jack_gpios);
+		if (ret)
+			printk(KERN_WARNING "failed to call snd_soc_jack_add_gpios\n");
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.startup = imx_hifi_startup,
+	.shutdown = imx_hifi_shutdown,
+	.hw_params = imx_hifi_hw_params,
+};
+
+static struct snd_soc_dai_link imx_dai[] = {
+	{
+		.name = "HiFi",
+		.stream_name = "HiFi",
+		.codec_dai_name	= "wm8994-aif1",
+		.codec_name	= "wm8994-codec",
+		.cpu_dai_name	= "imx-ssi.1",
+		.platform_name	= "imx-pcm-audio.1",
+		.init		= imx_wm8958_init,
+		.ops		= &imx_hifi_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_card_imx = {
+	.name		= "wm8958-audio",
+	.dai_link	= imx_dai,
+	.num_links	= ARRAY_SIZE(imx_dai),
+};
+
+static int imx_audmux_config(int slave, int master)
+{
+	unsigned int ptcr, pdcr;
+	slave = slave - 1;
+	master = master - 1;
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN |
+		MXC_AUDMUX_V2_PTCR_TFSDIR |
+		MXC_AUDMUX_V2_PTCR_TFSEL(master) |
+		MXC_AUDMUX_V2_PTCR_TCLKDIR |
+		MXC_AUDMUX_V2_PTCR_TCSEL(master);
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(master);
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN;
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(slave);
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	return 0;
+}
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ */
+static int __devinit imx_wm8958_probe(struct platform_device *pdev)
+{
+
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_priv *priv = &card_priv;
+	struct wm8994 *wm8958 = plat->priv;
+	int ret = 0;
+
+	codec_mclk = clk_get(NULL, "clko_clk");
+	if (IS_ERR(codec_mclk)) {
+		printk(KERN_ERR "can't get CLKO clock.\n");
+		return PTR_ERR(codec_mclk);
+	}
+
+	priv->pdev = pdev;
+	priv->wm8958 = wm8958;
+
+	imx_audmux_config(plat->src_port, plat->ext_port);
+
+	if (plat->init && plat->init()) {
+		ret = -EINVAL;
+		return ret;
+	}
+
+	priv->sysclk = plat->sysclk;
+	hs_jack_gpios[0].gpio = plat->hp_gpio;
+	hs_jack_gpios[0].invert = plat->hp_active_low;
+
+	return ret;
+}
+
+static int __devexit imx_wm8958_remove(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat->finit)
+		plat->finit();
+
+	clk_disable(codec_mclk);
+	clk_put(codec_mclk);
+
+	return 0;
+}
+
+static struct platform_driver imx_wm8958_driver = {
+	.probe = imx_wm8958_probe,
+	.remove = imx_wm8958_remove,
+	.driver = {
+		   .name = "imx-wm8958",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *imx_snd_device;
+
+static int __init imx_asoc_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_wm8958_driver);
+	if (ret < 0)
+		goto exit;
+
+	imx_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!imx_snd_device)
+		goto err_device_alloc;
+
+	platform_set_drvdata(imx_snd_device, &snd_soc_card_imx);
+
+	ret = platform_device_add(imx_snd_device);
+
+	if (0 == ret)
+		goto exit;
+
+	platform_device_put(imx_snd_device);
+
+err_device_alloc:
+	platform_driver_unregister(&imx_wm8958_driver);
+exit:
+	return ret;
+}
+
+static void __exit imx_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_wm8958_driver);
+	platform_device_unregister(imx_snd_device);
+}
+
+module_init(imx_asoc_init);
+module_exit(imx_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC imx wm8958");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-wm8962.c b/sound/soc/imx/imx-wm8962.c
new file mode 100644
index 0000000..101dddf
--- /dev/null
+++ b/sound/soc/imx/imx-wm8962.c
@@ -0,0 +1,621 @@
+/*
+ * imx-wm8962.c
+ *
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/fsl_devices.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/kthread.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/jack.h>
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <mach/audmux.h>
+#include <mach/gpio.h>
+#include <asm/mach-types.h>
+
+#include "imx-ssi.h"
+#include "../codecs/wm8962.h"
+#include "imx-audmux.h"
+struct imx_priv {
+	int sysclk;         /*mclk from the outside*/
+	int codec_sysclk;
+	int dai_hifi;
+	int hp_irq;
+	int hp_status;
+	int amic_irq;
+	int amic_status;
+	struct platform_device *pdev;
+	struct snd_pcm_substream *first_stream;
+	struct snd_pcm_substream *second_stream;
+};
+unsigned int sample_format = SNDRV_PCM_FMTBIT_S16_LE;
+static struct imx_priv card_priv;
+static struct snd_soc_card snd_soc_card_imx;
+static struct snd_soc_codec *gcodec;
+
+static struct snd_soc_jack imx_hp_jack;
+static struct snd_soc_jack_pin imx_hp_jack_pins[] = {
+	{
+		.pin = "Ext Spk",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_hp_jack_gpio = {
+	.name = "headphone detect",
+	.report = SND_JACK_HEADPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
+
+static struct snd_soc_jack imx_mic_jack;
+static struct snd_soc_jack_pin imx_mic_jack_pins[] = {
+	{
+		.pin = "DMIC",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_mic_jack_gpio = {
+	.name = "micphone detect",
+	.report = SND_JACK_MICROPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
+
+static int imx_hifi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	struct mxc_audio_platform_data *plat = priv->pdev->dev.platform_data;
+
+	if (!codec_dai->active)
+		plat->clock_enable(1);
+
+	return 0;
+}
+
+static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	struct mxc_audio_platform_data *plat = priv->pdev->dev.platform_data;
+
+	if (!codec_dai->active)
+		plat->clock_enable(0);
+
+	return;
+}
+
+static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	unsigned int channels = params_channels(params);
+	unsigned int sample_rate = 44100;
+	int ret = 0;
+	u32 dai_format;
+	unsigned int pll_out;
+
+	if (!priv->first_stream)
+		priv->first_stream = substream;
+	else
+		priv->second_stream = substream;
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 2, 32);
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBM_CFM;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	sample_rate = params_rate(params);
+	sample_format = params_format(params);
+
+	if (sample_format == SNDRV_PCM_FORMAT_S24_LE)
+		pll_out = sample_rate * 192;
+	else
+		pll_out = sample_rate * 256;
+
+	ret = snd_soc_dai_set_pll(codec_dai, WM8962_FLL_MCLK,
+				  WM8962_FLL_MCLK, priv->sysclk,
+				  pll_out);
+	if (ret < 0)
+		pr_err("Failed to start FLL: %d\n", ret);
+
+	ret = snd_soc_dai_set_sysclk(codec_dai,
+					 WM8962_SYSCLK_FLL,
+					 pll_out,
+					 SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		pr_err("Failed to set SYSCLK: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int imx_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	int ret;
+
+	if (priv->first_stream == substream)
+		priv->first_stream = priv->second_stream;
+	priv->second_stream = NULL;
+
+	if (!priv->first_stream) {
+		/*
+		 * wm8962 doesn't allow us to continuously setting FLL,
+		 * So we set MCLK as sysclk once, which'd remove the limitation.
+		 */
+		ret = snd_soc_dai_set_sysclk(codec_dai, WM8962_SYSCLK_MCLK,
+				0, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to set SYSCLK: %d\n", ret);
+			return ret;
+		}
+
+		/*
+		 * Continuously setting FLL would cause playback distortion.
+		 * We can fix it just by mute codec after playback.
+		 */
+		ret = snd_soc_dai_digital_mute(codec_dai, 1);
+		if (ret < 0) {
+			pr_err("Failed to set MUTE: %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static void imx_resume_event(struct work_struct *wor)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct snd_soc_jack *jack;
+	int enable;
+	int report;
+
+	if (plat->hp_gpio != -1) {
+		jack = imx_hp_jack_gpio.jack;
+
+		enable = gpio_get_value_cansleep(imx_hp_jack_gpio.gpio);
+		if (imx_hp_jack_gpio.invert)
+			enable = !enable;
+
+		if (enable)
+			report = imx_hp_jack_gpio.report;
+		else
+			report = 0;
+
+		snd_soc_jack_report(jack, report, imx_hp_jack_gpio.report);
+	}
+
+	if (plat->mic_gpio != -1) {
+		jack = imx_mic_jack_gpio.jack;
+
+		enable = gpio_get_value_cansleep(imx_mic_jack_gpio.gpio);
+		if (imx_mic_jack_gpio.invert)
+			enable = !enable;
+
+		if (enable)
+			report = imx_mic_jack_gpio.report;
+		else
+			report = 0;
+
+		snd_soc_jack_report(jack, report, imx_mic_jack_gpio.report);
+	}
+
+	return;
+}
+
+static int imx_event_hp(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	char *envp[3];
+	char *buf;
+
+	if (plat->hp_gpio != -1) {
+		priv->hp_status = gpio_get_value(plat->hp_gpio);
+
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
+
+		if (priv->hp_status != plat->hp_active_low)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
+
+		envp[0] = "NAME=headphone";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
+	}
+
+	return 0;
+}
+
+static int imx_event_mic(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	char *envp[3];
+	char *buf;
+
+	if (plat->mic_gpio != -1) {
+		priv->amic_status = gpio_get_value(plat->mic_gpio);
+
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
+
+		if (priv->amic_status == 0)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
+
+		envp[0] = "NAME=amic";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
+	}
+
+	return 0;
+}
+
+
+static const struct snd_kcontrol_new controls[] = {
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", imx_event_hp),
+	SND_SOC_DAPM_MIC("AMIC", NULL),
+	SND_SOC_DAPM_MIC("DMIC", imx_event_mic),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack", NULL, "HPOUTL" },
+	{ "Headphone Jack", NULL, "HPOUTR" },
+
+	{ "Ext Spk", NULL, "SPKOUTL" },
+	{ "Ext Spk", NULL, "SPKOUTR" },
+
+	{ "MICBIAS", NULL, "AMIC" },
+	{ "IN3R", NULL, "MICBIAS" },
+
+	{ "DMIC", NULL, "MICBIAS" },
+	{ "DMICDAT", NULL, "DMIC" },
+
+};
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	/* determine whether hp is plugged in */
+	priv->hp_status = gpio_get_value(plat->hp_gpio);
+
+	if (priv->hp_status != plat->hp_active_low)
+		strcpy(buf, "headphone\n");
+	else
+		strcpy(buf, "speaker\n");
+
+	return strlen(buf);
+}
+
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+static ssize_t show_amic(struct device_driver *dev, char *buf)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	/* determine whether amic is plugged in */
+	priv->amic_status = gpio_get_value(plat->hp_gpio);
+
+	if (priv->amic_status != plat->mic_active_low)
+		strcpy(buf, "amic\n");
+	else
+		strcpy(buf, "dmic\n");
+
+	return strlen(buf);
+}
+
+static DRIVER_ATTR(amic, S_IRUGO | S_IWUSR, show_amic, NULL);
+
+static DECLARE_DELAYED_WORK(resume_hp_event, imx_resume_event);
+
+int imx_hifi_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (SNDRV_PCM_TRIGGER_RESUME == cmd) {
+		if ((plat->hp_gpio != -1) || (plat->mic_gpio != -1))
+			schedule_delayed_work(&resume_hp_event,
+				msecs_to_jiffies(200));
+	}
+
+	return 0;
+}
+
+static int imx_wm8962_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	int ret = 0;
+
+	gcodec = rtd->codec;
+
+	/* Add imx specific widgets */
+	snd_soc_dapm_new_controls(&codec->dapm, imx_dapm_widgets,
+				  ARRAY_SIZE(imx_dapm_widgets));
+
+	/* Set up imx specific audio path audio_map */
+	snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(&codec->dapm, "AMIC");
+
+	if (plat->hp_gpio != -1) {
+		imx_hp_jack_gpio.gpio = plat->hp_gpio;
+		snd_soc_jack_new(codec, "Ext Spk", SND_JACK_LINEOUT,
+				&imx_hp_jack);
+		snd_soc_jack_add_pins(&imx_hp_jack,
+					ARRAY_SIZE(imx_hp_jack_pins),
+					imx_hp_jack_pins);
+		snd_soc_jack_add_gpios(&imx_hp_jack,
+					1, &imx_hp_jack_gpio);
+
+		ret = driver_create_file(pdev->dev.driver,
+							&driver_attr_headphone);
+		if (ret < 0) {
+			ret = -EINVAL;
+			return ret;
+		}
+	}
+
+	if (plat->mic_gpio != -1) {
+		imx_mic_jack_gpio.gpio = plat->mic_gpio;
+		snd_soc_jack_new(codec, "DMIC", SND_JACK_MICROPHONE,
+				&imx_mic_jack);
+		snd_soc_jack_add_pins(&imx_mic_jack,
+					ARRAY_SIZE(imx_mic_jack_pins),
+					imx_mic_jack_pins);
+		snd_soc_jack_add_gpios(&imx_mic_jack,
+					1, &imx_mic_jack_gpio);
+
+		ret = driver_create_file(pdev->dev.driver,
+							&driver_attr_amic);
+		if (ret < 0) {
+			ret = -EINVAL;
+			return ret;
+		}
+	} else {
+		snd_soc_dapm_nc_pin(&codec->dapm, "DMIC");
+	}
+
+	snd_soc_dapm_sync(&codec->dapm);
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.startup = imx_hifi_startup,
+	.shutdown = imx_hifi_shutdown,
+	.hw_params = imx_hifi_hw_params,
+	.hw_free = imx_hifi_hw_free,
+	.trigger = imx_hifi_trigger,
+};
+
+static struct snd_soc_dai_link imx_dai[] = {
+	{
+		.name = "HiFi",
+		.stream_name = "HiFi",
+		.codec_dai_name	= "wm8962",
+		.codec_name	= "wm8962.0-001a",
+		.cpu_dai_name	= "imx-ssi.1",
+		.platform_name	= "imx-pcm-audio.1",
+		.init		= imx_wm8962_init,
+		.ops		= &imx_hifi_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_card_imx = {
+	.name		= "wm8962-audio",
+	.dai_link	= imx_dai,
+	.num_links	= ARRAY_SIZE(imx_dai),
+};
+
+static int imx_audmux_config(int slave, int master)
+{
+	unsigned int ptcr, pdcr;
+	slave = slave - 1;
+	master = master - 1;
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN |
+		MXC_AUDMUX_V2_PTCR_TFSDIR |
+		MXC_AUDMUX_V2_PTCR_TFSEL(master) |
+		MXC_AUDMUX_V2_PTCR_TCLKDIR |
+		MXC_AUDMUX_V2_PTCR_TCSEL(master);
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(master);
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN;
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(slave);
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	return 0;
+}
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ */
+static int __devinit imx_wm8962_probe(struct platform_device *pdev)
+{
+
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_priv *priv = &card_priv;
+	int ret = 0;
+
+	priv->pdev = pdev;
+
+	imx_audmux_config(plat->src_port, plat->ext_port);
+
+	if (plat->init && plat->init()) {
+		ret = -EINVAL;
+		return ret;
+	}
+
+	priv->sysclk = plat->sysclk;
+
+	priv->first_stream = NULL;
+	priv->second_stream = NULL;
+
+	return ret;
+}
+
+static int __devexit imx_wm8962_remove(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_priv *priv = &card_priv;
+
+	if (plat->finit)
+		plat->finit();
+
+	if (priv->hp_irq)
+		free_irq(priv->hp_irq, priv);
+	if (priv->amic_irq)
+		free_irq(priv->amic_irq, priv);
+
+	return 0;
+}
+
+static struct platform_driver imx_wm8962_driver = {
+	.probe = imx_wm8962_probe,
+	.remove = imx_wm8962_remove,
+	.driver = {
+		   .name = "imx-wm8962",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *imx_snd_device;
+
+static int __init imx_asoc_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_wm8962_driver);
+	if (ret < 0)
+		goto exit;
+
+	if (machine_is_mx6q_sabresd())
+		imx_dai[0].codec_name = "wm8962.0-001a";
+	else if (machine_is_mx6sl_arm2() | machine_is_mx6sl_evk())
+		imx_dai[0].codec_name = "wm8962.1-001a";
+
+	imx_snd_device = platform_device_alloc("soc-audio", 5);
+	if (!imx_snd_device)
+		goto err_device_alloc;
+
+	platform_set_drvdata(imx_snd_device, &snd_soc_card_imx);
+
+	ret = platform_device_add(imx_snd_device);
+
+	if (0 == ret)
+		goto exit;
+
+	platform_device_put(imx_snd_device);
+
+err_device_alloc:
+	platform_driver_unregister(&imx_wm8962_driver);
+exit:
+	return ret;
+}
+
+static void __exit imx_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_wm8962_driver);
+	platform_device_unregister(imx_snd_device);
+}
+
+module_init(imx_asoc_init);
+module_exit(imx_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC imx wm8962");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c88d974..a8df31c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -754,13 +754,17 @@ int snd_soc_resume(struct device *dev)
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 		ac97_control |= cpu_dai->driver->ac97_control;
 	}
-	if (ac97_control) {
-		dev_dbg(dev, "Resuming AC97 immediately\n");
-		soc_resume_deferred(&card->deferred_resume_work);
-	} else {
-		dev_dbg(dev, "Scheduling resume work\n");
-		if (!schedule_work(&card->deferred_resume_work))
-			dev_err(dev, "resume work item may be lost\n");
+
+	if (card->num_rtd) {
+		if (ac97_control) {
+			dev_dbg(dev, "Resuming AC97 immediately\n");
+			soc_resume_deferred(&card->deferred_resume_work);
+		} else {
+			dev_dbg(dev, "Scheduling resume work\n");
+
+			if (!schedule_work(&card->deferred_resume_work))
+				dev_err(dev, "resume work item may be lost\n");
+		}
 	}
 
 	return 0;
@@ -3510,13 +3514,16 @@ int snd_soc_register_codec(struct device *dev,
 		 * kernel might have freed the array by the time we initialize
 		 * the cache.
 		 */
-		if (codec_drv->reg_cache_default) {
-			codec->reg_def_copy = kmemdup(codec_drv->reg_cache_default,
-						      reg_size, GFP_KERNEL);
-			if (!codec->reg_def_copy) {
-				ret = -ENOMEM;
-				goto fail;
-			}
+		if (codec_drv->reg_cache_default)
+			codec->reg_def_copy =
+				kmemdup(codec_drv->reg_cache_default,
+					reg_size, GFP_KERNEL);
+		else
+			codec->reg_def_copy = kzalloc(reg_size, GFP_KERNEL);
+
+		if (!codec->reg_def_copy) {
+			ret = -ENOMEM;
+			goto fail;
 		}
 	}
 
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index 0ad8dca..e6ada7d 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -599,6 +599,13 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		if (ret < 0)
 			return ret;
 	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->trigger) {
+		ret = rtd->dai_link->ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
 	return 0;
 }
 
-- 
1.7.5.4

