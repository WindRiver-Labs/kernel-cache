From aa54f98dc475af742cd29a7b9175fc50bdc1954f Mon Sep 17 00:00:00 2001
From: Nicolin Chen <b42378@freescale.com>
Date: Tue, 8 Oct 2013 16:39:39 +0800
Subject: [PATCH 0536/1072] ENGR00281859-3 ASoC: fsl: Prepare dmaengine before
 submit it

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 0c7a25933a30ed812fe91ba28ca0ae5d3b76dac8

ASRC and HDMI audio might meet unexpected stop, 'ctrl+z' for example,
and then disable its sdma channel. But after 'fg' resume, because sdma
channel's status has already been set into DMA_ERROR, we need to prepare
dmaengine again to clear its error state, otherwise sdma driver would
bypass its channel enabling and 'Input/Output error' would happen to
ALSA lib.
The combined prepare and submit are also being used in soc-dmaengine,
the common ASoC dmaengine driver.

And since we already use a proper way to handle sdma channel status,
there's no need to make an exception for HDMI any more, so drop it.

Signed-off-by: Nicolin Chen <b42378@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/dma/imx-sdma.c       |    3 +--
 sound/soc/fsl/fsl_asrc.c     |   31 +++++++++++++++++++++++--------
 sound/soc/fsl/imx-hdmi-dma.c |   35 ++++++++++++++++++++++++-----------
 3 files changed, 48 insertions(+), 21 deletions(-)

diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index 1c3970b..bde8608 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -1303,8 +1303,7 @@ static void sdma_issue_pending(struct dma_chan *chan)
 	struct sdma_channel *sdmac = to_sdma_chan(chan);
 	struct sdma_engine *sdma = sdmac->sdma;
 
-	/* Only HDMI audio uses other_script, and it does not care status */
-	if (sdmac->status == DMA_IN_PROGRESS || sdmac->other_script)
+	if (sdmac->status == DMA_IN_PROGRESS)
 		sdma_enable_channel(sdma, sdmac->channel);
 }
 
diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
index dc230ff..d91484f 100644
--- a/sound/soc/fsl/fsl_asrc.c
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -133,13 +133,6 @@ static int asrc_p2p_request_channel(struct snd_pcm_substream *substream)
 		dev_err(rtd->card->dev, "can not config dma channel\n");
 		goto error;
 	}
-	asrc_p2p->asrc_p2p_desc = dmaengine_prep_dma_cyclic(chan, 0xffff, 64,
-							64, DMA_DEV_TO_DEV, 0);
-	if (!asrc_p2p->asrc_p2p_desc) {
-		dev_err(&chan->dev->device,
-				"cannot prepare slave dma\n");
-		goto error;
-	}
 
 	return 0;
 error:
@@ -274,16 +267,38 @@ static int fsl_asrc_p2p_hw_free(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int fsl_asrc_dma_prepare_and_submit(struct snd_pcm_substream *substream,
+					struct fsl_asrc_p2p *asrc_p2p)
+{
+	struct dma_async_tx_descriptor *desc = asrc_p2p->asrc_p2p_desc;
+	struct dma_chan *chan = asrc_p2p->asrc_p2p_dma_chan;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->platform->dev;
+
+	desc = dmaengine_prep_dma_cyclic(chan, 0xffff, 64, 64, DMA_DEV_TO_DEV, 0);
+	if (!desc) {
+		dev_err(dev, "failed to prepare slave dma\n");
+		return -EINVAL;
+	}
+
+	dmaengine_submit(desc);
+
+	return 0;
+}
+
 static int fsl_asrc_p2p_trigger(struct snd_pcm_substream *substream, int cmd,
 			    struct snd_soc_dai *cpu_dai)
 {
 	struct fsl_asrc_p2p *asrc_p2p = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		dmaengine_submit(asrc_p2p->asrc_p2p_desc);
+		ret = fsl_asrc_dma_prepare_and_submit(substream, asrc_p2p);
+		if (ret)
+			return ret;
 		dma_async_issue_pending(asrc_p2p->asrc_p2p_dma_chan);
 		asrc_p2p->asrc_ops.asrc_p2p_start_conv(asrc_p2p->asrc_index);
 		break;
diff --git a/sound/soc/fsl/imx-hdmi-dma.c b/sound/soc/fsl/imx-hdmi-dma.c
index 0dc32dc..4155122 100644
--- a/sound/soc/fsl/imx-hdmi-dma.c
+++ b/sound/soc/fsl/imx-hdmi-dma.c
@@ -697,16 +697,6 @@ static int hdmi_sdma_config(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	priv->desc = dmaengine_prep_dma_cyclic(priv->dma_channel, 0, 0, 0,
-						DMA_TRANS_NONE, 0);
-	if (!priv->desc) {
-		dev_err(dev, "failed to prepare slave dma\n");
-		return -EINVAL;
-	}
-
-	priv->desc->callback = hdmi_sdma_callback;
-	priv->desc->callback_param = (void *)priv;
-
 	return 0;
 }
 
@@ -810,12 +800,33 @@ static void hdmi_dma_trigger_init(struct snd_pcm_substream *substream,
 	hdmi_writeb(status, HDMI_IH_AHBDMAAUD_STAT0);
 }
 
+static int hdmi_dma_prepare_and_submit(struct snd_pcm_substream *substream,
+					struct hdmi_dma_priv *priv)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->platform->dev;
+
+	priv->desc = dmaengine_prep_dma_cyclic(priv->dma_channel, 0, 0, 0,
+						DMA_TRANS_NONE, 0);
+	if (!priv->desc) {
+		dev_err(dev, "failed to prepare slave dma\n");
+		return -EINVAL;
+	}
+
+	priv->desc->callback = hdmi_sdma_callback;
+	priv->desc->callback_param = (void *)priv;
+	dmaengine_submit(priv->desc);
+
+	return 0;
+}
+
 static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct hdmi_dma_priv *priv = runtime->private_data;
 	struct device *dev = rtd->platform->dev;
+	int ret;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -831,7 +842,9 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		hdmi_audio_writeb(AHB_DMA_START, START, 0x1);
 		hdmi_dma_irq_set(false);
 		hdmi_set_dma_mode(1);
-		dmaengine_submit(priv->desc);
+		ret = hdmi_dma_prepare_and_submit(substream, priv);
+		if (ret)
+			return ret;
 		dma_async_issue_pending(priv->desc->chan);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-- 
1.7.5.4

