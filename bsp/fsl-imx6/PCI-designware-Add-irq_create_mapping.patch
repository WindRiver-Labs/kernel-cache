From 7b07d8747ee098847d9fdb5591a62eb32cc625b5 Mon Sep 17 00:00:00 2001
From: Pratyush Anand <pratyush.anand@st.com>
Date: Wed, 9 Oct 2013 21:32:12 +0900
Subject: [PATCH 0824/1072] PCI: designware: Add irq_create_mapping()

commit 904d0e7889933fb48d921c998fd1cabb3a9d6635 upstream

Without irq_create_mapping(), the correct IRQ number cannot be
provided.  In this case, it makes problems such as NULL dereference.
Thus, irq_create_mapping() should be added for MSI.

Suggested-by: Kishon Vijay Abraham I <kishon@ti.com>
Signed-off-by: Pratyush Anand <pratyush.anand@st.com>
Signed-off-by: Jingoo Han <jg1.han@samsung.com>
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/pci/host/pcie-designware.c |   25 +++++++++++++------------
 drivers/pci/host/pcie-designware.h |    2 +-
 2 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c
index b42bc6c..a14d705 100644
--- a/drivers/pci/host/pcie-designware.c
+++ b/drivers/pci/host/pcie-designware.c
@@ -159,7 +159,7 @@ static struct irq_chip dw_msi_irq_chip = {
 void dw_handle_msi_irq(struct pcie_port *pp)
 {
 	unsigned long val;
-	int i, pos;
+	int i, pos, irq;
 
 	for (i = 0; i < MAX_MSI_CTRLS; i++) {
 		dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4,
@@ -167,8 +167,9 @@ void dw_handle_msi_irq(struct pcie_port *pp)
 		if (val) {
 			pos = 0;
 			while ((pos = find_next_bit(&val, 32, pos)) != 32) {
-				generic_handle_irq(pp->msi_irq_start
-					+ (i * 32) + pos);
+				irq = irq_find_mapping(pp->irq_domain,
+						i * 32 + pos);
+				generic_handle_irq(irq);
 				pos++;
 			}
 		}
@@ -239,9 +240,8 @@ static int assign_irq(int no_irqs, struct msi_desc *desc, int *pos)
 		}
 	}
 
-	irq = (pp->msi_irq_start + pos0);
-
-	if ((irq + no_irqs) > (pp->msi_irq_start + MAX_MSI_IRQS-1))
+	irq = irq_find_mapping(pp->irq_domain, pos0);
+	if (!irq)
 		goto no_valid_irq;
 
 	i = 0;
@@ -272,6 +272,7 @@ static void clear_irq(unsigned int irq)
 	struct irq_desc *desc;
 	struct msi_desc *msi;
 	struct pcie_port *pp;
+	struct irq_data *data = irq_get_irq_data(irq);
 
 	/* get the port structure */
 	desc = irq_to_desc(irq);
@@ -282,7 +283,7 @@ static void clear_irq(unsigned int irq)
 		return;
 	}
 
-	pos = irq - pp->msi_irq_start;
+	pos = data->hwirq;
 
 	irq_free_desc(irq);
 
@@ -373,8 +374,7 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 	struct of_pci_range range;
 	struct of_pci_range_parser parser;
 	u32 val;
-
-	struct irq_domain *irq_domain;
+	int i;
 
 	if (of_pci_range_parser_init(&parser, np)) {
 		dev_err(pp->dev, "missing ranges property\n");
@@ -443,15 +443,16 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 	}
 
 	if (IS_ENABLED(CONFIG_PCI_MSI)) {
-		irq_domain = irq_domain_add_linear(pp->dev->of_node,
+		pp->irq_domain = irq_domain_add_linear(pp->dev->of_node,
 					MAX_MSI_IRQS, &msi_domain_ops,
 					&dw_pcie_msi_chip);
-		if (!irq_domain) {
+		if (!pp->irq_domain) {
 			dev_err(pp->dev, "irq domain init failed\n");
 			return -ENXIO;
 		}
 
-		pp->msi_irq_start = irq_find_mapping(irq_domain, 0);
+		for (i = 0; i < MAX_MSI_IRQS; i++)
+			irq_create_mapping(pp->irq_domain, i);
 	}
 
 	if (pp->ops->host_init)
diff --git a/drivers/pci/host/pcie-designware.h b/drivers/pci/host/pcie-designware.h
index 890c2ce..c15379b 100644
--- a/drivers/pci/host/pcie-designware.h
+++ b/drivers/pci/host/pcie-designware.h
@@ -50,7 +50,7 @@ struct pcie_port {
 	u32			lanes;
 	struct pcie_host_ops	*ops;
 	int			msi_irq;
-	int			msi_irq_start;
+	struct irq_domain	*irq_domain;
 	unsigned long		msi_data;
 	DECLARE_BITMAP(msi_irq_in_use, MAX_MSI_IRQS);
 };
-- 
1.7.5.4

