From e396f8d07ffcba61fb89d1e0e0ca9e57c17af7fd Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Fri, 22 Nov 2013 00:20:32 -0600
Subject: [PATCH 0363/1072] ENGR00289268 [iMX6x] Ensure there is no TLB miss
 when DDR is in self-refresh

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 7eca811461dbb5fd7ef2d37377facbfff912e9be

During DDR frequency change code or in low power IDLE code (in iMX6SL),
we need to ensure that all register addresses accessed in the IRAM
code are in the TLB. There should be no TLB walks when DDR is in self-refresh.
To ensure this flush the TLB before DDR frequency change and before
low power IDLE (only iMX6SL) procedures.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/busfreq_ddr3.c   |    9 +++++++--
 arch/arm/mach-imx/busfreq_lpddr2.c |   10 +++++++++-
 arch/arm/mach-imx/cpuidle-imx6sl.c |   10 ++++++++--
 arch/arm/mach-imx/imx6sl_wfi.S     |   14 ++++++++------
 4 files changed, 32 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-imx/busfreq_ddr3.c b/arch/arm/mach-imx/busfreq_ddr3.c
index c77b05d..3121e38 100644
--- a/arch/arm/mach-imx/busfreq_ddr3.c
+++ b/arch/arm/mach-imx/busfreq_ddr3.c
@@ -229,6 +229,11 @@ int update_ddr_freq(int ddr_rate)
 	while (cpus_in_wfe != online_cpus)
 		udelay(5);
 
+	/*
+	 * Flush the TLB, to ensure no TLB maintenance occurs
+	 * when DDR is in self-refresh.
+	 */
+	local_flush_tlb_all();
 	/* Now we can change the DDR frequency. */
 	mx6_change_ddr_freq(ddr_rate, iram_ddr_settings,
 		dll_off, iram_iomux_settings);
@@ -288,7 +293,7 @@ int init_mmdc_ddr3_settings(struct platform_device *busfreq_pdev)
 		return -EINVAL;
 	}
 	ccm_base = of_iomap(node, 0);
-	WARN(!mmdc_base, "unable to map mmdc registers\n");
+	WARN(!ccm_base, "unable to map mmdc registers\n");
 
 	node = of_find_compatible_node(NULL, NULL, "arm,pl310-cache");
 	if (!node) {
@@ -296,7 +301,7 @@ int init_mmdc_ddr3_settings(struct platform_device *busfreq_pdev)
 		return -EINVAL;
 	}
 	l2_base = of_iomap(node, 0);
-	WARN(!mmdc_base, "unable to map mmdc registers\n");
+	WARN(!ccm_base, "unable to map mmdc registers\n");
 
 	node = NULL;
 	node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-gic");
diff --git a/arch/arm/mach-imx/busfreq_lpddr2.c b/arch/arm/mach-imx/busfreq_lpddr2.c
index 900d7bd..a6c4f4e 100644
--- a/arch/arm/mach-imx/busfreq_lpddr2.c
+++ b/arch/arm/mach-imx/busfreq_lpddr2.c
@@ -72,13 +72,21 @@ int update_lpddr2_freq(int ddr_rate)
 	if (ddr_rate == curr_ddr_rate)
 		return 0;
 
+	dev_dbg(busfreq_dev, "\nBus freq set to %d start...\n", ddr_rate);
+
+	/*
+	 * Flush the TLB, to ensure no TLB maintenance occurs
+	 * when DDR is in self-refresh.
+	 */
+	local_flush_tlb_all();
+	/* Now change DDR frequency. */
 	mx6_change_lpddr2_freq(ddr_rate,
 		(low_bus_freq_mode | ultra_low_bus_freq_mode),
 		reg_addrs);
 
 	curr_ddr_rate = ddr_rate;
 
-	dev_dbg(busfreq_dev, "\nBus freq set to %d start...\n", ddr_rate);
+	dev_dbg(busfreq_dev, "\nBus freq set to %d done...\n", ddr_rate);
 
 	return 0;
 }
diff --git a/arch/arm/mach-imx/cpuidle-imx6sl.c b/arch/arm/mach-imx/cpuidle-imx6sl.c
index dbb6643..c542f56 100644
--- a/arch/arm/mach-imx/cpuidle-imx6sl.c
+++ b/arch/arm/mach-imx/cpuidle-imx6sl.c
@@ -16,6 +16,7 @@
 #include <asm/fncpy.h>
 #include <asm/mach/map.h>
 #include <asm/proc-fns.h>
+#include <asm/tlb.h>
 
 #include "common.h"
 #include "cpuidle.h"
@@ -37,14 +38,19 @@ static int imx6sl_enter_wait(struct cpuidle_device *dev,
 			    struct cpuidle_driver *drv, int index)
 {
 	imx6_set_lpm(WAIT_UNCLOCKED);
-	if (ultra_low_bus_freq_mode || audio_bus_freq_mode)
+	if (ultra_low_bus_freq_mode || audio_bus_freq_mode) {
+		/*
+		 * Flush the TLB, to ensure no TLB maintenance occurs
+		 * when DDR is in self-refresh.
+		 */
+		local_flush_tlb_all();
 		/*
 		 * Run WFI code from IRAM.
 		 * Drop the DDR freq to 1MHz and AHB to 3MHz
 		 * Also float DDR IO pads.
 		 */
 		imx6sl_wfi_in_iram_fn(wfi_iram_base, iomux_base, reg_addrs, audio_bus_freq_mode);
-	else {
+	} else {
 		imx6sl_set_wait_clk(true);
 		cpu_do_idle();
 		imx6sl_set_wait_clk(false);
diff --git a/arch/arm/mach-imx/imx6sl_wfi.S b/arch/arm/mach-imx/imx6sl_wfi.S
index df5b781..0399e70 100644
--- a/arch/arm/mach-imx/imx6sl_wfi.S
+++ b/arch/arm/mach-imx/imx6sl_wfi.S
@@ -420,18 +420,20 @@ podf_loop:
 	b	do_wfi
 
 do_audio_arm_clk:
-	/* ARM is from PLL2_PFD2_400M here.
+	/*
+	 * ARM is from PLL2_PFD2_400M here.
 	 * Switch ARM to bypassed PLL1.
 	 */
 	ldr	r6, [r2, #0xC]
 	bic	r6, r6, #0x4
 	str	r6, [r2, #0xC]
 
-	/* Set the ARM_PODF to divide by 2
-	* as IPG is at 4MHz, we cannot run
-	* ARM_CLK above 9.6MHz when
-	* system enters WAIT mode.
-	*/
+	/*
+	 * Set the ARM_PODF to divide by 2
+	 * as IPG is at 4MHz, we cannot run
+	 * ARM_CLK above 9.6MHz when
+	 * system enters WAIT mode.
+	 */
 	ldr	r6, =0x2
 	str	r6, [r2, #0x10]
 
-- 
1.7.5.4

