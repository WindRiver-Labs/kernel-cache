From f9dc04cea1a557cbc4bcfdaa3f78b7c0053335de Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Jun 2013 17:23:22 +0800
Subject: [PATCH 08/38] fsl_imx6q: Update SD/MMC for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc-imx.c |  788 ++++++++++++++++++++++++++++++------
 drivers/mmc/host/sdhci-esdhc.h     |   35 +-
 drivers/mmc/host/sdhci-pltfm.h     |    2 +
 drivers/mmc/host/sdhci.c           |  210 +++++++++-
 drivers/mmc/host/sdhci.h           |    3 +
 include/linux/mmc/sdhci.h          |   14 +
 6 files changed, 893 insertions(+), 159 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index d282440..3e7d16a 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -20,7 +20,9 @@
 #include <linux/slab.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
 #include <linux/mmc/sdio.h>
+#include <linux/mmc/sd.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
@@ -28,6 +30,56 @@
 #include "sdhci-pltfm.h"
 #include "sdhci-esdhc.h"
 
+
+/* VENDOR SPEC register */
+#define SDHCI_VENDOR_SPEC		0xC0
+#define  SDHCI_VENDOR_SPEC_SDIO_QUIRK	0x00000002
+
+#define SDHCI_MIX_CTRL_AC23EN		(1 << 7)
+#define SDHCI_MIX_CTRL_EXE_TUNE		(1 << 22)
+#define SDHCI_MIX_CTRL_SMPCLK_SEL	(1 << 23)
+#define SDHCI_MIX_CTRL_AUTO_TUNE	(1 << 24)
+#define SDHCI_MIX_CTRL_FBCLK_SEL	(1 << 25)
+
+#define SDHCI_SYS_CTRL			0x2C
+#define SDHCI_SYS_CTRL_RSTA_LSH 24
+
+#define SDHCI_DLL_CTRL			0x60
+#define SDHCI_DLL_OVERRIDE_OFFSET	0x9
+#define SDHCI_DLL_OVERRIDE_EN_OFFSET	0x8
+
+#define SDHCI_TUNE_CTRL_STATUS		0x68
+#define SDHCI_TUNE_CTRL_STEP		0x1
+#define SDHCI_TUNE_CTRL_MIN		0x0
+#define SDHCI_TUNE_CTRL_MAX		((1 << 7) - 1)
+
+#define  SDHCI_VENDOR_SPEC_VSELECT	(1 << 1)
+#define  SDHCI_VENDOR_SPEC_FRC_SDCLK_ON	(1 << 8)
+
+#define  SDHCI_PRESENT_STATE_CLSL	(1 << 23)
+#define  SDHCI_PRESENT_STATE_DLSL_L4	(0xF << 24)
+#define  SDHCI_PRESENT_STATE_DLSL_H4	(0xF << 28)
+
+#define ESDHC_FLAG_GPIO_FOR_CD_WP	(1 << 0)
+
+
+#define SDHCI_PROT_CTRL_DMASEL_MASK		(3 << 8)
+#define SDHCI_PROT_CTRL_DTW		(3 << 1)
+#define SDHCI_PROT_CTRL_8BIT		(2 << 1)
+#define SDHCI_PROT_CTRL_4BIT		(1 << 1)
+#define SDHCI_PROT_CTRL_1BIT		(0 << 1)
+#define SDHCI_PROT_CTRL_LCTL		(1 << 0)
+
+/* SDHCI_FSL_SVN_300 only for mx6q and mx6dl */
+#define SDHCI_FSL_SVN_300			0x3
+
+#define SDHCI_TUNE_CTRL		0xCC
+#define SDHCI_TUNE_CTRL_STD_TUNING_EN		(1 << 24)
+
+#define SDHCI_HOST_CAP_UHS_MODE_MASK		0x7
+
+#define SDHCI_TUNING_BLOCK_PATTERN_LEN		64
+
 #define	SDHCI_CTRL_D3CD			0x08
 /* VENDOR SPEC register */
 #define SDHCI_VENDOR_SPEC		0xC0
@@ -69,6 +121,7 @@ struct pltfm_imx_data {
 	u32 scratchpad;
 	enum imx_esdhc_type devtype;
 	struct esdhc_platform_data boarddata;
+	unsigned char uhs_mode;
 };
 
 static struct platform_device_id imx_esdhc_devtype[] = {
@@ -128,6 +181,90 @@ static inline int is_imx6q_usdhc(struct pltfm_imx_data *data)
 	return data->devtype == IMX6Q_USDHC;
 }
 
+static void esdhc_prepare_tuning(struct sdhci_host *host, u32 val);
+static void esdhc_post_tuning(struct sdhci_host *host);
+
+static void request_done(struct mmc_request *mrq)
+{
+	complete(&mrq->completion);
+}
+
+static int esdhc_send_tuning_cmd(struct sdhci_host *host)
+{
+	struct mmc_command cmd = {0};
+	struct mmc_request mrq = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+	char tuning_pattern[SDHCI_TUNING_BLOCK_PATTERN_LEN];
+	struct mmc_host *mmc;
+
+	WARN_ON(host == NULL);
+	if (host == NULL)
+		return -EINVAL;
+
+	mmc = host->mmc;
+
+	cmd.opcode = MMC_SEND_TUNING_BLOCK;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = SDHCI_TUNING_BLOCK_PATTERN_LEN;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	sg_init_one(&sg, tuning_pattern, sizeof(tuning_pattern));
+
+	mrq.cmd = &cmd;
+	mrq.cmd->mrq = &mrq;
+	mrq.data = &data;
+	mrq.data->mrq = &mrq;
+	mrq.cmd->data = mrq.data;
+
+	mrq.done = request_done;
+
+	init_completion(&(mrq.completion));
+	mmc->ops->request(host->mmc, &mrq);
+	wait_for_completion(&(mrq.completion));
+
+	if (cmd.error)
+		return cmd.error;
+	if (data.error)
+		return data.error;
+
+	return 0;
+}
+
+static int esdhc_execute_tuning(struct sdhci_host *host)
+{
+	int min, max, avg;
+
+	min = host->tuning_min;
+	while (min < host->tuning_max) {
+		esdhc_prepare_tuning(host, min);
+		if (!esdhc_send_tuning_cmd(host))
+			break;
+		min += host->tuning_step;
+	}
+
+	max = min + host->tuning_step;
+	while (max < host->tuning_max) {
+		esdhc_prepare_tuning(host, max);
+		if (esdhc_send_tuning_cmd(host)) {
+			max -= host->tuning_step;
+			break;
+		}
+		max += host->tuning_step;
+	}
+
+	avg = (min + max) / 2;
+	esdhc_prepare_tuning(host, avg);
+	esdhc_send_tuning_cmd(host);
+	esdhc_post_tuning(host);
+	return 0;
+}
+
 static inline void esdhc_clrset_le(struct sdhci_host *host, u32 mask, u32 val, int reg)
 {
 	void __iomem *base = host->ioaddr + (reg & ~0x3);
@@ -140,19 +277,70 @@ static u32 esdhc_readl_le(struct sdhci_host *host, int reg)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
-	struct esdhc_platform_data *boarddata = &imx_data->boarddata;
+	struct esdhc_platform_data *boarddata
+				= host->mmc->parent->platform_data;
 
-	/* fake CARD_PRESENT flag */
+	/* fake CARD_PRESENT flag on mx25/35 */
 	u32 val = readl(host->ioaddr + reg);
 
-	if (unlikely((reg == SDHCI_PRESENT_STATE)
-			&& gpio_is_valid(boarddata->cd_gpio))) {
-		if (gpio_get_value(boarddata->cd_gpio))
-			/* no card, if a valid gpio says so... */
-			val &= ~SDHCI_CARD_PRESENT;
-		else
-			/* ... in all other cases assume card is present */
+	/*
+	 * mx6q: SDHCI_PRESENT_STATE bit 16, CINST is not functional on SD3.
+	 * So move the section up, and check GPIO for card presence again in
+	 * the following block.
+	 */
+	if (reg == SDHCI_PRESENT_STATE && cpu_is_mx6()) {
+		u32 fsl_prss = readl(host->ioaddr + SDHCI_PRESENT_STATE);
+		/* save the least 20 bits */
+		val |= fsl_prss & 0x000FFFFF;
+		/* move dat[0-3] line signal bits */
+		val |= (fsl_prss & 0x0F000000) >> 4;
+		/* move cmd line signal bits */
+		val |= (fsl_prss & 0x00800000) << 1;
+	}
+
+	if (unlikely(reg == SDHCI_PRESENT_STATE)) {
+		if (boarddata && boarddata->always_present)
 			val |= SDHCI_CARD_PRESENT;
+		else if	(imx_data->flags & ESDHC_FLAG_GPIO_FOR_CD_WP) {
+			if (boarddata && gpio_is_valid(boarddata->cd_gpio)
+					&& gpio_get_value(boarddata->cd_gpio))
+				/* no card, if a valid gpio says so */
+				val &= ~SDHCI_CARD_PRESENT;
+			else
+				/* in all other cases assume card is present */
+				val |= SDHCI_CARD_PRESENT;
+		}
+	}
+
+	if (reg == SDHCI_INT_STATUS && cpu_is_mx6()
+		&& mx6q_revision() == IMX_CHIP_REVISION_1_0) {
+		/*
+		 * on mx6q TO1.0, there is low possibility that
+		 * DATA END interrupt comes ealier than DMA
+		 * END interrupt which is conflict with standard
+		 * host controller spec. In this case, read the
+		 * status register again will workaround this issue.
+		 */
+		if ((val & SDHCI_INT_DATA_END) && \
+			!(val & SDHCI_INT_DMA_END))
+			val = readl(host->ioaddr + reg);
+	} else if (reg == SDHCI_CAPABILITIES_1
+			&& (cpu_is_mx6q() || cpu_is_mx6dl())) {
+		/*
+		 * on mx6q, no cap_1 available, fake one.
+		 */
+		val = SDHCI_SUPPORT_DDR50 | SDHCI_SUPPORT_SDR104 | \
+			  SDHCI_SUPPORT_SDR50;
+	} else if (reg == SDHCI_CAPABILITIES_1 && cpu_is_mx6sl()) {
+		val = readl(host->ioaddr + SDHCI_CAPABILITIES) & 0xFFFF;
+	} else if (reg == SDHCI_MAX_CURRENT && cpu_is_mx6()) {
+		/*
+		 * on mx6q, no max current available, fake one.
+		 */
+		val = 0;
+		val |= 0xFF << SDHCI_MAX_CURRENT_330_SHIFT;
+		val |= 0xFF << SDHCI_MAX_CURRENT_300_SHIFT;
+		val |= 0xFF << SDHCI_MAX_CURRENT_180_SHIFT;
 	}
 
 	if (unlikely(reg == SDHCI_CAPABILITIES)) {
@@ -183,25 +371,41 @@ static void esdhc_writel_le(struct sdhci_host *host, u32 val, int reg)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
-	struct esdhc_platform_data *boarddata = &imx_data->boarddata;
 	u32 data;
 
-	if (unlikely(reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE)) {
-		if (boarddata->cd_type == ESDHC_CD_GPIO)
+	if (unlikely((reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE))) {
+		if (imx_data->flags & ESDHC_FLAG_GPIO_FOR_CD_WP)
 			/*
-			 * These interrupts won't work with a custom
+			 * these interrupts won't work with a custom
 			 * card_detect gpio (only applied to mx25/35)
 			 */
-			val &= ~(SDHCI_INT_CARD_REMOVE | SDHCI_INT_CARD_INSERT);
+			val &= ~(SDHCI_INT_CARD_REMOVE | \
+				SDHCI_INT_CARD_INSERT);
+
+		if (!(val & SDHCI_INT_CARD_INT) && cpu_is_mx6()
+			&& mx6q_revision() == IMX_CHIP_REVISION_1_0)
+			/*
+			 * write 1 to clear card interrupt status bit
+			 * (only applied to mx6q TO1.0)
+			 * uSDHC used for mx6q has such problem which is
+			 * not consistant with standard host controller
+			 * definition.
+			 * eSDHC used for mx25/35/50/51/53 does not have
+			 * such problem.
+			 */
+			writel(SDHCI_INT_CARD_INT, \
+				host->ioaddr + SDHCI_INT_STATUS);
 
-		if (val & SDHCI_INT_CARD_INT) {
+		if (val & SDHCI_INT_CARD_INT && !cpu_is_mx6()) {
 			/*
-			 * Clear and then set D3CD bit to avoid missing the
-			 * card interrupt.  This is a eSDHC controller problem
-			 * so we need to apply the following workaround: clear
-			 * and set D3CD bit will make eSDHC re-sample the card
-			 * interrupt. In case a card interrupt was lost,
-			 * re-sample it by the following steps.
+			 * clear D3CD bit and set D3CD bit to avoid
+			 * losing card interrupt
+			 * (applied to all processors except mx6q)
+			 * eSDHC controller used for mx25/35/50/51/53
+			 * has such issue, so that we need to do following
+			 * operation to avoid losing card interrupt.
+			 * uSDCH controller used for mx6q and after won't
+			 * have such problem.
 			 */
 			data = readl(host->ioaddr + SDHCI_HOST_CONTROL);
 			data &= ~SDHCI_CTRL_D3CD;
@@ -232,29 +436,191 @@ static void esdhc_writel_le(struct sdhci_host *host, u32 val, int reg)
 
 static u16 esdhc_readw_le(struct sdhci_host *host, int reg)
 {
+	u16 ret;
+	u32 val;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
 
-	if (unlikely(reg == SDHCI_HOST_VERSION)) {
+	switch (reg) {
+	case SDHCI_HOST_VERSION:
 		reg ^= 2;
-		if (is_imx6q_usdhc(imx_data)) {
-			/*
-			 * The usdhc register returns a wrong host version.
-			 * Correct it here.
-			 */
-			return SDHCI_SPEC_300;
+		val = readl(host->ioaddr + reg);
+		if ((cpu_is_mx6q() || cpu_is_mx6dl()) &&
+			((val & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT)
+			== SDHCI_FSL_SVN_300) {
+			val &= ~SDHCI_SPEC_VER_MASK;
+			val |= SDHCI_SPEC_300;
 		}
+		ret = 0xFFFF & val;
+		return ret;
+	case SDHCI_HOST_CONTROL2:
+		ret = 0;
+		/* collect bit info from several regs */
+		val = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+		ret |= (val & SDHCI_VENDOR_SPEC_VSELECT)
+			? SDHCI_CTRL_VDD_180 : 0;
+
+		if (cpu_is_mx6sl()) {
+			val = readl(host->ioaddr + SDHCI_ACMD12_ERR);
+			ret |= (val & SDHCI_MIX_CTRL_EXE_TUNE)
+				? SDHCI_CTRL_EXEC_TUNING : 0;
+			ret |= (val & SDHCI_MIX_CTRL_SMPCLK_SEL)
+				? SDHCI_CTRL_TUNED_CLK : 0;
+		} else {
+			val = readl(host->ioaddr + SDHCI_MIX_CTRL);
+			ret |= (val & SDHCI_MIX_CTRL_EXE_TUNE)
+				? SDHCI_CTRL_EXEC_TUNING : 0;
+			ret |= (val & SDHCI_MIX_CTRL_SMPCLK_SEL)
+				? SDHCI_CTRL_TUNED_CLK : 0;
+		}
+		ret |= SDHCI_CTRL_UHS_MASK & imx_data->uhs_mode;
+		/* no preset enable available  */
+		ret &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;
+
+		return ret;
 	}
 
 	return readw(host->ioaddr + reg);
 }
 
+static void esdhc_post_tuning(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+	u32 reg;
+
+	imx_data->scratchpad &= ~SDHCI_MIX_CTRL_EXE_TUNE;
+	reg = readl(host->ioaddr + SDHCI_MIX_CTRL);
+	reg &= ~SDHCI_MIX_CTRL_EXE_TUNE;
+	writel(reg, host->ioaddr + SDHCI_MIX_CTRL);
+}
+
+static void esdhc_reset(struct sdhci_host *host)
+{
+	unsigned long timeout;
+	u32 reg;
+
+	reg = readl(host->ioaddr + SDHCI_SYS_CTRL);
+	reg |= 1 << SDHCI_SYS_CTRL_RSTA_LSH;
+	writel(reg, host->ioaddr + SDHCI_SYS_CTRL);
+
+	/* Wait max 100ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readl(host->ioaddr + SDHCI_SYS_CTRL)
+			& (1 << SDHCI_SYS_CTRL_RSTA_LSH)) {
+		if (timeout == 0) {
+			printk(KERN_ERR "%s: Reset never completed.\n",
+					mmc_hostname(host->mmc));
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+}
+
+static void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)
+{
+	u32 reg;
+
+	esdhc_reset(host);
+	mdelay(1);
+
+	reg = readl(host->ioaddr + SDHCI_MIX_CTRL);
+	reg |= SDHCI_MIX_CTRL_EXE_TUNE | \
+		SDHCI_MIX_CTRL_SMPCLK_SEL | \
+		SDHCI_MIX_CTRL_FBCLK_SEL;
+	writel(reg, host->ioaddr + SDHCI_MIX_CTRL);
+	writel((val << 8), host->ioaddr + SDHCI_TUNE_CTRL_STATUS);
+}
+
+
 static void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct esdhc_platform_data *boarddata =
+				host->mmc->parent->platform_data;
 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+	u32 orig_reg;
 
 	switch (reg) {
+	case SDHCI_CLOCK_CONTROL:
+		orig_reg = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+		if (val & SDHCI_CLOCK_CARD_EN) {
+			writel(orig_reg | SDHCI_VENDOR_SPEC_FRC_SDCLK_ON, \
+				host->ioaddr + SDHCI_VENDOR_SPEC);
+		} else {
+			writel(orig_reg & ~SDHCI_VENDOR_SPEC_FRC_SDCLK_ON, \
+				host->ioaddr + SDHCI_VENDOR_SPEC);
+		}
+
+		return;
+	case SDHCI_HOST_CONTROL2:
+		orig_reg = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+		if (val & SDHCI_CTRL_VDD_180) {
+			orig_reg |= SDHCI_VENDOR_SPEC_VSELECT;
+			writel(orig_reg, host->ioaddr + SDHCI_VENDOR_SPEC);
+		} else {
+			orig_reg &= ~SDHCI_VENDOR_SPEC_VSELECT;
+			writel(orig_reg, host->ioaddr + SDHCI_VENDOR_SPEC);
+		}
+
+		/*
+		 * FSL sdhc controls bus and signal voltage via one bit
+		 * VSELECT in VENDOR_SPEC, which has been set in
+		 * SDHCI_POWER_CONTROL. So we skip the SDHCI_CTRL_VDD_180
+		 * here.
+		 *
+		 * ignore exec_tuning flag written to SDHCI_HOST_CONTROL2,
+		 * tuning will be handled differently for FSL SDHC ip.
+		 */
+		if (cpu_is_mx6sl()) {
+			orig_reg = readl(host->ioaddr + SDHCI_TUNE_CTRL);
+			if (val & SDHCI_CTRL_EXEC_TUNING) {
+				orig_reg |= SDHCI_TUNE_CTRL_STD_TUNING_EN;
+				writel(orig_reg,
+					host->ioaddr + SDHCI_TUNE_CTRL);
+
+				orig_reg =
+					readl(host->ioaddr + SDHCI_ACMD12_ERR);
+				orig_reg |= SDHCI_MIX_CTRL_EXE_TUNE;
+				writel(orig_reg,
+					host->ioaddr + SDHCI_ACMD12_ERR);
+			}
+		} else {
+			orig_reg = readl(host->ioaddr + SDHCI_MIX_CTRL);
+			orig_reg &= ~SDHCI_MIX_CTRL_SMPCLK_SEL;
+			orig_reg |= (val & SDHCI_CTRL_TUNED_CLK)
+				? SDHCI_MIX_CTRL_SMPCLK_SEL : 0;
+		}
+
+		if (val & SDHCI_CTRL_UHS_DDR50) {
+			orig_reg |= SDHCI_MIX_CTRL_DDREN;
+			imx_data->scratchpad |= SDHCI_MIX_CTRL_DDREN;
+		} else {
+			orig_reg &= ~SDHCI_MIX_CTRL_DDREN;
+			imx_data->scratchpad &= ~SDHCI_MIX_CTRL_DDREN;
+		}
+		writel(orig_reg, host->ioaddr + SDHCI_MIX_CTRL);
+
+		/* set clock frequency again */
+		esdhc_set_clock(host, host->clock);
+		imx_data->uhs_mode = val & SDHCI_CTRL_UHS_MASK;
+
+		/* delay line setting */
+		if (!boarddata->delay_line)
+			return;
+
+		if (val & SDHCI_CTRL_UHS_DDR50)
+			writel((boarddata->delay_line \
+					<< SDHCI_DLL_OVERRIDE_OFFSET) \
+					| (1 << SDHCI_DLL_OVERRIDE_EN_OFFSET),
+					host->ioaddr + SDHCI_DLL_CTRL);
+		else
+			writel(0, host->ioaddr + SDHCI_DLL_CTRL);
+
+		return;
 	case SDHCI_TRANSFER_MODE:
 		/*
 		 * Postpone this write, we must do it together with a
@@ -270,6 +636,10 @@ static void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)
 			writel(v, host->ioaddr + SDHCI_VENDOR_SPEC);
 		}
 		imx_data->scratchpad = val;
+
+		if (val & SDHCI_TRNS_AUTO_CMD23)
+			imx_data->scratchpad |= SDHCI_MIX_CTRL_AC23EN;
+
 		return;
 	case SDHCI_COMMAND:
 		if ((host->cmd->opcode == MMC_STOP_TRANSMISSION ||
@@ -277,15 +647,24 @@ static void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)
 	            (imx_data->flags & ESDHC_FLAG_MULTIBLK_NO_INT))
 			val |= SDHCI_CMD_ABORTCMD;
 
-		if (is_imx6q_usdhc(imx_data)) {
-			u32 m = readl(host->ioaddr + SDHCI_MIX_CTRL);
-			m = imx_data->scratchpad | (m & 0xffff0000);
-			writel(m, host->ioaddr + SDHCI_MIX_CTRL);
+		writel(0x08800880, host->ioaddr + SDHCI_CAPABILITIES_1);
+		if (cpu_is_mx6()) {
+			imx_data->scratchpad |= \
+			(readl(host->ioaddr + SDHCI_MIX_CTRL) & \
+				(SDHCI_MIX_CTRL_EXE_TUNE | \
+				SDHCI_MIX_CTRL_SMPCLK_SEL | \
+				SDHCI_MIX_CTRL_AUTO_TUNE | \
+				SDHCI_MIX_CTRL_FBCLK_SEL | \
+				SDHCI_MIX_CTRL_DDREN));
+
+			writel(imx_data->scratchpad,
+				host->ioaddr + SDHCI_MIX_CTRL);
+
 			writel(val << 16,
-			       host->ioaddr + SDHCI_TRANSFER_MODE);
+				host->ioaddr + SDHCI_TRANSFER_MODE);
 		} else {
 			writel(val << 16 | imx_data->scratchpad,
-			       host->ioaddr + SDHCI_TRANSFER_MODE);
+				host->ioaddr + SDHCI_TRANSFER_MODE);
 		}
 		return;
 	case SDHCI_BLOCK_SIZE:
@@ -295,6 +674,62 @@ static void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)
 	esdhc_clrset_le(host, 0xffff, val, reg);
 }
 
+static u8 esdhc_readb_le(struct sdhci_host *host, int reg)
+{
+	u8 ret;
+	u32 reg_val;
+
+	ret = 0;
+	switch (reg) {
+	case SDHCI_POWER_CONTROL:
+		reg_val = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+		ret |= reg_val & SDHCI_VENDOR_SPEC_VSELECT
+				? SDHCI_POWER_180 : SDHCI_POWER_300;
+		/* could not power off */
+		ret |= SDHCI_POWER_ON;
+		return ret;
+	case SDHCI_HOST_CONTROL:
+		reg_val = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+		if (reg_val & SDHCI_PROT_CTRL_LCTL)
+			ret |= SDHCI_CTRL_LED;
+		else
+			ret &= ~SDHCI_CTRL_LED;
+
+		ret |= (reg_val & SDHCI_PROT_CTRL_DMASEL_MASK) >> 5;
+		if (SDHCI_PROT_CTRL_8BIT == (reg_val & SDHCI_PROT_CTRL_DTW)) {
+			ret &= ~SDHCI_CTRL_4BITBUS;
+			ret |= SDHCI_CTRL_8BITBUS;
+		} else if (SDHCI_PROT_CTRL_4BIT
+				== (reg_val & SDHCI_PROT_CTRL_DTW)) {
+			ret &= ~SDHCI_CTRL_8BITBUS;
+			ret |= SDHCI_CTRL_4BITBUS;
+		} else if (SDHCI_PROT_CTRL_1BIT
+				== (reg_val & SDHCI_PROT_CTRL_DTW))
+			ret &= ~(SDHCI_CTRL_8BITBUS | SDHCI_CTRL_4BITBUS);
+		return ret;
+	case SDHCI_SOFTWARE_RESET:
+		reg_val = readl(host->ioaddr + SDHCI_CLOCK_CONTROL);
+		ret = reg_val >> 24;
+		return ret;
+	case SDHCI_RESPONSE + 3:
+		reg_val = readl(host->ioaddr + SDHCI_RESPONSE);
+		ret = reg_val >> 24;
+		return ret;
+	case SDHCI_RESPONSE + 7:
+		reg_val = readl(host->ioaddr + SDHCI_RESPONSE + 4);
+		ret = reg_val >> 24;
+		return ret;
+	case SDHCI_RESPONSE + 11:
+		reg_val = readl(host->ioaddr + SDHCI_RESPONSE + 8);
+		ret = reg_val >> 24;
+		return ret;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
 static void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)
 {
 	u32 new_val;
@@ -305,12 +740,37 @@ static void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)
 		 * FSL put some DMA bits here
 		 * If your board has a regulator, code should be here
 		 */
+		if (val == (SDHCI_POWER_ON | SDHCI_POWER_180)) {
+			u32 reg;
+
+			/* stop sd clock */
+			reg = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+			writel(reg & ~SDHCI_VENDOR_SPEC_FRC_SDCLK_ON, \
+				host->ioaddr + SDHCI_VENDOR_SPEC);
+
+			/* switch to 1.8V */
+			reg = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+			reg |= SDHCI_VENDOR_SPEC_VSELECT;
+			writel(reg, host->ioaddr + SDHCI_VENDOR_SPEC);
+
+		} else {
+			u32 reg;
+
+			reg = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
+			reg &= ~SDHCI_VENDOR_SPEC_VSELECT;
+			writel(reg, host->ioaddr + SDHCI_VENDOR_SPEC);
+		}
 		return;
 	case SDHCI_HOST_CONTROL:
 		/* FSL messed up here, so we can just keep those three */
-		new_val = val & (SDHCI_CTRL_LED | \
-				SDHCI_CTRL_4BITBUS | \
-				SDHCI_CTRL_D3CD);
+		new_val = val & (SDHCI_CTRL_LED);
+		if (val & SDHCI_CTRL_8BITBUS) {
+			new_val |= SDHCI_PROT_CTRL_8BIT;
+			new_val &= ~SDHCI_PROT_CTRL_4BIT;
+		} else if (val & SDHCI_CTRL_4BITBUS) {
+			new_val &= ~SDHCI_PROT_CTRL_8BIT;
+			new_val |= SDHCI_PROT_CTRL_4BIT;
+		}
 		/* ensure the endianess */
 		new_val |= ESDHC_HOST_CONTROL_LE;
 		/* DMA mode bits are shifted */
@@ -320,17 +780,6 @@ static void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)
 		return;
 	}
 	esdhc_clrset_le(host, 0xff, val, reg);
-
-	/*
-	 * The esdhc has a design violation to SDHC spec which tells
-	 * that software reset should not affect card detection circuit.
-	 * But esdhc clears its SYSCTL register bits [0..2] during the
-	 * software reset.  This will stop those clocks that card detection
-	 * circuit relies on.  To work around it, we turn the clocks on back
-	 * to keep card detection circuit functional.
-	 */
-	if ((reg == SDHCI_SOFTWARE_RESET) && (val & 1))
-		esdhc_clrset_le(host, 0x7, 0x7, ESDHC_SYSTEM_CONTROL);
 }
 
 static unsigned int esdhc_pltfm_get_max_clock(struct sdhci_host *host)
@@ -349,52 +798,88 @@ static unsigned int esdhc_pltfm_get_min_clock(struct sdhci_host *host)
 
 static unsigned int esdhc_pltfm_get_ro(struct sdhci_host *host)
 {
+	struct esdhc_platform_data *boarddata = host->mmc->parent->platform_data;
+
+	if (boarddata && gpio_is_valid(boarddata->wp_gpio))
+		return gpio_get_value(boarddata->wp_gpio);
+	else
+		return -ENOSYS;
+}
+
+static int plt_8bit_width(struct sdhci_host *host, int width)
+{
+	u32 reg = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+
+	reg &= ~SDHCI_PROT_CTRL_DTW;
+
+	if (width == MMC_BUS_WIDTH_8)
+		reg |= SDHCI_PROT_CTRL_8BIT;
+	else if (width == MMC_BUS_WIDTH_4)
+		reg |= SDHCI_PROT_CTRL_4BIT;
+
+	writel(reg, host->ioaddr + SDHCI_HOST_CONTROL);
+	return 0;
+}
+
+static void plt_clk_ctrl(struct sdhci_host *host, bool enable)
+{
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct pltfm_imx_data *imx_data = pltfm_host->priv;
-	struct esdhc_platform_data *boarddata = &imx_data->boarddata;
 
-	switch (boarddata->wp_type) {
-	case ESDHC_WP_GPIO:
-		if (gpio_is_valid(boarddata->wp_gpio))
-			return gpio_get_value(boarddata->wp_gpio);
-	case ESDHC_WP_CONTROLLER:
-		return !(readl(host->ioaddr + SDHCI_PRESENT_STATE) &
-			       SDHCI_WRITE_PROTECT);
-	case ESDHC_WP_NONE:
-		break;
+	if (enable) {
+		clk_prepare_enable(pltfm_host->clk);
+		host->clk_status = true;
+	} else {
+		clk_disable_unprepare(pltfm_host->clk);
+		host->clk_status = false;
 	}
-
-	return -ENOSYS;
 }
 
 static struct sdhci_ops sdhci_esdhc_ops = {
 	.read_l = esdhc_readl_le,
 	.read_w = esdhc_readw_le,
+	.read_b = esdhc_readb_le,
 	.write_l = esdhc_writel_le,
 	.write_w = esdhc_writew_le,
 	.write_b = esdhc_writeb_le,
 	.set_clock = esdhc_set_clock,
 	.get_max_clock = esdhc_pltfm_get_max_clock,
 	.get_min_clock = esdhc_pltfm_get_min_clock,
-	.get_ro = esdhc_pltfm_get_ro,
-};
-
-static struct sdhci_pltfm_data sdhci_esdhc_imx_pdata = {
-	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_NO_HISPD_BIT
-			| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC
-			| SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC
-			| SDHCI_QUIRK_BROKEN_CARD_DETECTION,
-	.ops = &sdhci_esdhc_ops,
+	.platform_8bit_width = plt_8bit_width,
+	.platform_clk_ctrl = plt_clk_ctrl,
 };
 
 static irqreturn_t cd_irq(int irq, void *data)
 {
 	struct sdhci_host *sdhost = (struct sdhci_host *)data;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(sdhost);
+	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+
+	writel(0, sdhost->ioaddr + SDHCI_MIX_CTRL);
+	writel(0, sdhost->ioaddr + SDHCI_TUNE_CTRL_STATUS);
+
+	if (cpu_is_mx6()) {
+		imx_data->scratchpad &= ~SDHCI_MIX_CTRL_DDREN;
+		imx_data->scratchpad &= ~SDHCI_MIX_CTRL_FBCLK_SEL;
+		imx_data->scratchpad &= ~SDHCI_MIX_CTRL_SMPCLK_SEL;
+	}
+
+	esdhc_reset(sdhost);
+	mdelay(1);
 
 	tasklet_schedule(&sdhost->card_tasklet);
 	return IRQ_HANDLED;
 };
 
+struct sdhci_pltfm_data sdhci_esdhc_imx_pdata = {
+	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC
+			| SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC
+			| SDHCI_QUIRK_BROKEN_CARD_DETECTION
+			| SDHCI_QUIRK_BROKEN_ADMA
+			| SDHCI_QUIRK_NO_HISPD_BIT,
+	/* ADMA has issues. Might be fixable */
+	.ops = &sdhci_esdhc_ops,
+};
+
 #ifdef CONFIG_OF
 static int __devinit
 sdhci_esdhc_imx_probe_dt(struct platform_device *pdev,
@@ -443,6 +928,7 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 	struct clk *clk;
 	int err;
 	struct pltfm_imx_data *imx_data;
+	u32 reg;
 
 	host = sdhci_pltfm_init(pdev, &sdhci_esdhc_imx_pdata);
 	if (IS_ERR(host))
@@ -450,16 +936,8 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 
 	pltfm_host = sdhci_priv(host);
 
-	imx_data = kzalloc(sizeof(struct pltfm_imx_data), GFP_KERNEL);
-	if (!imx_data) {
-		err = -ENOMEM;
-		goto err_imx_data;
-	}
-
 	if (of_id)
 		pdev->id_entry = of_id->data;
-	imx_data->devtype = pdev->id_entry->driver_data;
-	pltfm_host->priv = imx_data;
 
 	clk = clk_get(mmc_dev(host->mmc), NULL);
 	if (IS_ERR(clk)) {
@@ -467,25 +945,20 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 		err = PTR_ERR(clk);
 		goto err_clk_get;
 	}
+
 	clk_prepare_enable(clk);
 	pltfm_host->clk = clk;
 
-	host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
-
-	if (is_imx25_esdhc(imx_data) || is_imx35_esdhc(imx_data))
-		/* Fix errata ENGcm07207 present on i.MX25 and i.MX35 */
-		host->quirks |= SDHCI_QUIRK_NO_MULTIBLOCK
-			| SDHCI_QUIRK_BROKEN_ADMA;
+	imx_data = kzalloc(sizeof(struct pltfm_imx_data), GFP_KERNEL);
+	if (!imx_data) {
+		err = -ENOMEM;
+		goto err_imx_data;
+	}
 
-	if (is_imx53_esdhc(imx_data))
-		imx_data->flags |= ESDHC_FLAG_MULTIBLK_NO_INT;
+	imx_data->devtype = pdev->id_entry->driver_data;
+	pltfm_host->priv = imx_data;
 
-	/*
-	 * The imx6q ROM code will change the default watermark level setting
-	 * to something insane.  Change it back here.
-	 */
-	if (is_imx6q_usdhc(imx_data))
-		writel(0x08100810, host->ioaddr + SDHCI_WTMK_LVL);
+	host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 
 	boarddata = &imx_data->boarddata;
 	if (sdhci_esdhc_imx_probe_dt(pdev, boarddata) < 0) {
@@ -495,33 +968,89 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 			goto no_board_data;
 		}
 		imx_data->boarddata = *((struct esdhc_platform_data *)
-					host->mmc->parent->platform_data);
+		host->mmc->parent->platform_data);
+	}
+
+	if (cpu_is_mx25() || cpu_is_mx35())
+		/* Fix errata ENGcm07207 present on i.MX25 and i.MX35 */
+		host->quirks |= SDHCI_QUIRK_NO_MULTIBLOCK
+			| SDHCI_QUIRK_BROKEN_ADMA;
+
+	/*
+	 * on mx6dl TO 1.1, ADMA can work when ahb bus frequency is low,
+	 * like 24Mhz.
+	 */
+	if (mx6dl_revision() >= IMX_CHIP_REVISION_1_1)
+		host->quirks &= ~SDHCI_QUIRK_BROKEN_ADMA;
+
+	if (cpu_is_mx6())
+		host->quirks2 |= SDHCI_QUIRK2_HOST_OFF_CARD_ON,
+
+	/* write_protect can't be routed to controller, use gpio */
+	sdhci_esdhc_ops.get_ro = esdhc_pltfm_get_ro;
+
+	if (!(cpu_is_mx25() || cpu_is_mx35() || cpu_is_mx51() || cpu_is_mx6()))
+		imx_data->flags |= ESDHC_FLAG_MULTIBLK_NO_INT;
+
+	host->ocr_avail_sd = MMC_VDD_29_30 | MMC_VDD_30_31 | \
+			MMC_VDD_32_33 | MMC_VDD_33_34;
+	host->ocr_avail_mmc = MMC_VDD_29_30 | MMC_VDD_30_31 | \
+			MMC_VDD_32_33 | MMC_VDD_33_34;
+	host->ocr_avail_sdio = MMC_VDD_29_30 | MMC_VDD_30_31 | \
+			MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
+		sdhci_esdhc_ops.platform_execute_tuning = esdhc_execute_tuning;
+
+	if (boarddata->support_18v) {
+		host->ocr_avail_sd |= MMC_VDD_165_195;
+		host->ocr_avail_mmc |= MMC_VDD_165_195;
+		host->ocr_avail_sdio |= MMC_VDD_165_195;
 	}
 
+	if (boarddata->support_8bit)
+		host->mmc->caps |= MMC_CAP_8_BIT_DATA;
 	if (boarddata->keep_power_at_suspend)
-		host->mmc->pm_caps |= MMC_PM_KEEP_POWER;
+		host->mmc->pm_caps |= (MMC_PM_KEEP_POWER | \
+					MMC_PM_WAKE_SDIO_IRQ);
+	if (boarddata->cd_type == ESDHC_CD_PERMANENT)
+		host->mmc->caps |= MMC_CAP_NONREMOVABLE;
+	else if (boarddata->cd_type == ESDHC_CD_CONTROLLER
+		|| boarddata->cd_type == ESDHC_CD_NONE
+		|| boarddata->cd_type == ESDHC_CD_GPIO)
+		host->mmc->caps &= ~MMC_CAP_NONREMOVABLE;
+	if (cpu_is_mx6()) {
+		host->mmc->caps |= MMC_CAP_1_8V_DDR;
+		host->tuning_min = SDHCI_TUNE_CTRL_MIN;
+		host->tuning_max = SDHCI_TUNE_CTRL_MAX;
+		host->tuning_step = SDHCI_TUNE_CTRL_STEP;
+		host->clk_mgr_en = true;
+	}
+
+	reg = readl(host->ioaddr + SDHCI_MIX_CTRL);
+	reg &= ~SDHCI_MIX_CTRL_DDREN;
+	writel(reg, host->ioaddr + SDHCI_MIX_CTRL);
+
+	if (boarddata) {
+		/* Device is always present, e.x, populated emmc device */
+		if (boarddata->always_present) {
+			/* remove BROKEN_CD to disable card polling */
+			host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
+			/* if it is always present, invalid cd_gpio */
+			boarddata->cd_gpio = ARCH_NR_GPIOS + 1;
+			goto out_host;
+		}
 
-	/* write_protect */
-	if (boarddata->wp_type == ESDHC_WP_GPIO) {
 		err = gpio_request_one(boarddata->wp_gpio, GPIOF_IN, "ESDHC_WP");
 		if (err) {
 			dev_warn(mmc_dev(host->mmc),
-				 "no write-protect pin available!\n");
-			boarddata->wp_gpio = -EINVAL;
+				"no write-protect pin available!\n");
+			boarddata->wp_gpio = err;
 		}
-	} else {
-		boarddata->wp_gpio = -EINVAL;
-	}
 
-	/* card_detect */
-	if (boarddata->cd_type != ESDHC_CD_GPIO)
-		boarddata->cd_gpio = -EINVAL;
-
-	switch (boarddata->cd_type) {
-	case ESDHC_CD_GPIO:
 		err = gpio_request_one(boarddata->cd_gpio, GPIOF_IN, "ESDHC_CD");
 		if (err) {
-			dev_err(mmc_dev(host->mmc),
+			dev_warn(mmc_dev(host->mmc),
 				"no card-detect pin available!\n");
 			goto no_card_detect_pin;
 		}
@@ -530,24 +1059,22 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 				 IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
 				 mmc_hostname(host->mmc), host);
 		if (err) {
-			dev_err(mmc_dev(host->mmc), "request irq error\n");
+			dev_warn(mmc_dev(host->mmc), "request irq error\n");
 			goto no_card_detect_irq;
 		}
-		/* fall through */
 
-	case ESDHC_CD_CONTROLLER:
-		/* we have a working card_detect back */
+		imx_data->flags |= ESDHC_FLAG_GPIO_FOR_CD_WP;
+		/* Now we have a working card_detect again */
 		host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
-		break;
-
-	case ESDHC_CD_PERMANENT:
-		host->mmc->caps = MMC_CAP_NONREMOVABLE;
-		break;
-
-	case ESDHC_CD_NONE:
-		break;
 	}
 
+#ifdef CONFIG_PM_RUNTIME
+	host->mmc->caps |= MMC_CAP_POWER_OFF_CARD;
+#endif
+out_host:
+	if (host->clk_mgr_en)
+		clk_disable_unprepare(pltfm_host->clk);
+
 	err = sdhci_add_host(host);
 	if (err)
 		goto err_add_host;
@@ -560,15 +1087,17 @@ err_add_host:
 no_card_detect_irq:
 	if (gpio_is_valid(boarddata->cd_gpio))
 		gpio_free(boarddata->cd_gpio);
+no_card_detect_pin:
 	if (gpio_is_valid(boarddata->wp_gpio))
 		gpio_free(boarddata->wp_gpio);
-no_card_detect_pin:
 no_board_data:
-	clk_disable_unprepare(pltfm_host->clk);
-	clk_put(pltfm_host->clk);
-err_clk_get:
 	kfree(imx_data);
 err_imx_data:
+	if (host->clk_mgr_en) {
+		clk_disable_unprepare(pltfm_host->clk);
+	}
+	clk_put(pltfm_host->clk);
+err_clk_get:
 	sdhci_pltfm_free(pdev);
 	return err;
 }
@@ -583,15 +1112,18 @@ static int __devexit sdhci_esdhc_imx_remove(struct platform_device *pdev)
 
 	sdhci_remove_host(host, dead);
 
-	if (gpio_is_valid(boarddata->wp_gpio))
+	if (boarddata && gpio_is_valid(boarddata->wp_gpio))
 		gpio_free(boarddata->wp_gpio);
 
-	if (gpio_is_valid(boarddata->cd_gpio)) {
-		free_irq(gpio_to_irq(boarddata->cd_gpio), host);
+	if (boarddata && gpio_is_valid(boarddata->cd_gpio)) {
 		gpio_free(boarddata->cd_gpio);
+
+		if (!(host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION))
+			free_irq(gpio_to_irq(boarddata->cd_gpio), host);
 	}
 
-	clk_disable_unprepare(pltfm_host->clk);
+	if (!host->clk_mgr_en)
+		clk_disable_unprepare(pltfm_host->clk);
 	clk_put(pltfm_host->clk);
 	kfree(imx_data);
 
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index e1ce00b..82e0455 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -1,7 +1,7 @@
 /*
  * Freescale eSDHC controller driver generics for OF and pltfm.
  *
- * Copyright (c) 2007 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007, 2011, 2012 Freescale Semiconductor, Inc.
  * Copyright (c) 2009 MontaVista Software, Inc.
  * Copyright (c) 2010 Pengutronix e.K.
  *   Author: Wolfram Sang <w.sang@pengutronix.de>
@@ -13,6 +13,7 @@
 
 #ifndef _DRIVERS_MMC_SDHCI_ESDHC_H
 #define _DRIVERS_MMC_SDHCI_ESDHC_H
+#include <linux/platform_device.h>
 
 /*
  * Ops and quirks for the Freescale eSDHC controller.
@@ -42,25 +43,35 @@
 
 #define ESDHC_HOST_CONTROL_RES	0x05
 
+#define SDHCI_MIX_CTRL			0x48
+#define SDHCI_MIX_CTRL_DDREN		(1 << 3)
+
 static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 {
 	int pre_div = 2;
 	int div = 1;
 	u32 temp;
-#ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	struct esdhc_platform_data *boarddata;
+	int ddr_mode = 0;
+	struct platform_device *pdev = to_platform_device(host->mmc->parent);
 
 	boarddata = host->mmc->parent->platform_data;
-#endif
-
-	if (clock == 0)
-		goto out;
-
+	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+		pre_div = 1;
+		if (readl(host->ioaddr + SDHCI_MIX_CTRL) &
+				SDHCI_MIX_CTRL_DDREN) {
+			ddr_mode = 1;
+			pre_div = 2;
+		}
+	}
 	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
 	temp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
 		| ESDHC_CLOCK_MASK);
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 
+	if (clock == 0)
+		goto out;
+
 	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
 		pre_div *= 2;
 
@@ -70,7 +81,7 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
 		clock, host->max_clk / pre_div / div);
 
-	pre_div >>= 1;
+	pre_div >>= (1 + ddr_mode);
 	div--;
 
 	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
@@ -80,15 +91,15 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 	mdelay(1);
 
-#ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	/* if there's board callback function
 	 * for pad setting change, that means
 	 * board needs to reconfig its pad for
 	 * corresponding sd bus frequency
 	 */
-	if (boarddata->platform_pad_change)
-		boarddata->platform_pad_change(clock);
-#endif
+	if (boarddata->platform_pad_change) {
+		BUG_ON(!pdev);
+		boarddata->platform_pad_change(pdev->id, clock);
+	}
 out:
 	host->clock = clock;
 }
diff --git a/drivers/mmc/host/sdhci-pltfm.h b/drivers/mmc/host/sdhci-pltfm.h
index 37e0e18..84affdf 100644
--- a/drivers/mmc/host/sdhci-pltfm.h
+++ b/drivers/mmc/host/sdhci-pltfm.h
@@ -18,6 +18,8 @@
 struct sdhci_pltfm_data {
 	struct sdhci_ops *ops;
 	unsigned int quirks;
+	int (*init)(struct sdhci_host *host, struct sdhci_pltfm_data *pdata, struct platform_device *pdev);
+	void (*exit)(struct sdhci_host *host);
 };
 
 struct sdhci_pltfm_host {
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index b4618a4..c38ee33 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1,7 +1,7 @@
 /*
  *  linux/drivers/mmc/host/sdhci.c - Secure Digital Host Controller Interface driver
  *
- *  Copyright (C) 2005-2008 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2005-2011 Pierre Ossman, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,13 +32,15 @@
 #include "sdhci.h"
 
 #define DRIVER_NAME "sdhci"
+#define CLK_TIMEOUT (1 * HZ)
 
 #define DBG(f, x...) \
 	pr_debug(DRIVER_NAME " [%s()]: " f, __func__,## x)
 
 #if defined(CONFIG_LEDS_CLASS) || (defined(CONFIG_LEDS_CLASS_MODULE) && \
 	defined(CONFIG_MMC_SDHCI_MODULE))
-#define SDHCI_USE_LEDS_CLASS
+/* FIXME: temp workaround for calling clk_enable in an interrupt context */
+#define SDHCI_USE_LEDS_CLASS_BROKEN
 #endif
 
 #define MAX_TUNING_LOOP 40
@@ -67,6 +69,44 @@ static inline int sdhci_runtime_pm_put(struct sdhci_host *host)
 }
 #endif
 
+static void sdhci_clk_worker(struct work_struct *work)
+{
+	struct sdhci_host *host =
+		container_of(work, struct sdhci_host, clk_worker.work);
+
+	if (host->ops->platform_clk_ctrl && host->clk_status)
+		host->ops->platform_clk_ctrl(host, false);
+}
+
+static inline bool sdhci_is_sdio_attached(struct sdhci_host *host)
+{
+	struct mmc_card *card = host->mmc->card;
+
+	if (card && card->sdio_func[0])
+		return true;
+	return false;
+}
+
+static void sdhci_enable_clk(struct sdhci_host *host)
+{
+	if (host->clk_mgr_en) {
+		cancel_delayed_work_sync(&host->clk_worker);
+		if (!host->clk_status && host->ops->platform_clk_ctrl)
+			host->ops->platform_clk_ctrl(host, true);
+	}
+}
+
+static void sdhci_disable_clk(struct sdhci_host *host, int delay)
+{
+	if (host->clk_mgr_en) {
+		if (delay == 0 && !in_interrupt()) {
+			if (host->ops->platform_clk_ctrl && host->clk_status)
+				host->ops->platform_clk_ctrl(host, false);
+		} else
+			schedule_delayed_work(&host->clk_worker, delay);
+	}
+}
+
 static void sdhci_dumpregs(struct sdhci_host *host)
 {
 	pr_debug(DRIVER_NAME ": =========== REGISTER DUMP (%s)===========\n",
@@ -273,6 +313,7 @@ static void sdhci_led_control(struct led_classdev *led,
 	struct sdhci_host *host = container_of(led, struct sdhci_host, led);
 	unsigned long flags;
 
+	sdhci_enable_clk(host);
 	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->runtime_suspended)
@@ -284,6 +325,8 @@ static void sdhci_led_control(struct led_classdev *led,
 		sdhci_activate_led(host);
 out:
 	spin_unlock_irqrestore(&host->lock, flags);
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, CLK_TIMEOUT);
 }
 #endif
 
@@ -1254,6 +1297,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	sdhci_runtime_pm_get(host);
 
+	sdhci_enable_clk(host);
 	spin_lock_irqsave(&host->lock, flags);
 
 	WARN_ON(host->mrq != NULL);
@@ -1327,13 +1371,11 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	int vdd_bit = -1;
 	u8 ctrl;
 
+	sdhci_enable_clk(host);
 	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD) {
-		spin_unlock_irqrestore(&host->lock, flags);
-		if (host->vmmc && ios->power_mode == MMC_POWER_OFF)
-			mmc_regulator_set_ocr(host->mmc, host->vmmc, 0);
-		return;
+		goto out;
 	}
 
 	/*
@@ -1482,9 +1524,12 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	 */
 	if(host->quirks & SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS)
 		sdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
-
+out:
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (ios->power_mode == MMC_POWER_OFF)
+		sdhci_disable_clk(host, 0);
 }
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -1501,6 +1546,7 @@ static int sdhci_check_ro(struct sdhci_host *host)
 	unsigned long flags;
 	int is_readonly;
 
+	sdhci_enable_clk(host);
 	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD)
@@ -1512,6 +1558,8 @@ static int sdhci_check_ro(struct sdhci_host *host)
 				& SDHCI_WRITE_PROTECT);
 
 	spin_unlock_irqrestore(&host->lock, flags);
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, CLK_TIMEOUT);
 
 	/* This quirk needs to be replaced by a callback-function later */
 	return host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT ?
@@ -1742,6 +1790,14 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		return 0;
 	}
 
+	if (ctrl & SDHCI_CTRL_EXEC_TUNING) {
+		if (host->ops->platform_execute_tuning) {
+			spin_unlock(&host->lock);
+			enable_irq(host->irq);
+			return host->ops->platform_execute_tuning(host);
+		}
+	}
+
 	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
 	/*
@@ -1936,8 +1992,79 @@ static void sdhci_enable_preset_value(struct mmc_host *mmc, bool enable)
 	sdhci_runtime_pm_put(host);
 }
 
+static void sdhci_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
+				int err)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+
+	if (host->flags & SDHCI_REQ_USE_DMA) {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+			     data->flags & MMC_DATA_WRITE ? \
+			     DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		data->host_cookie = 0;
+	}
+}
+
+static int sdhci_pre_dma_transfer(struct sdhci_host *host,
+				       struct mmc_data *data,
+				       struct sdhci_host_next *next)
+{
+	int dma_len;
+
+	if (!next && data->host_cookie &&
+	    data->host_cookie != host->next_data.cookie) {
+		printk(KERN_WARNING "[%s] invalid cookie: data->host_cookie %d"
+		       " host->next_data.cookie %d\n",
+		       __func__, data->host_cookie, host->next_data.cookie);
+		data->host_cookie = 0;
+	}
+
+	/* Check if next job is already prepared */
+	if (next ||
+	    (!next && data->host_cookie != host->next_data.cookie)) {
+		dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				     data->sg_len,
+				     data->flags & MMC_DATA_WRITE ? \
+				     DMA_TO_DEVICE : DMA_FROM_DEVICE);
+
+	} else {
+		dma_len = host->next_data.dma_len;
+		host->next_data.dma_len = 0;
+	}
+
+
+	if (dma_len == 0)
+		return -EINVAL;
+
+	if (next) {
+		next->dma_len = dma_len;
+		data->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;
+	}
+
+	return 0;
+}
+
+static void sdhci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,
+			       bool is_first_req)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (mrq->data->host_cookie) {
+		mrq->data->host_cookie = 0;
+		return ;
+	}
+
+	if (host->flags & SDHCI_REQ_USE_DMA)
+		if (sdhci_pre_dma_transfer(host, mrq->data,
+						&host->next_data))
+			mrq->data->host_cookie = 0;
+}
+
 static const struct mmc_host_ops sdhci_ops = {
 	.request	= sdhci_request,
+	.post_req	= sdhci_post_req,
+	.pre_req	= sdhci_pre_req,
 	.set_ios	= sdhci_set_ios,
 	.get_ro		= sdhci_get_ro,
 	.hw_reset	= sdhci_hw_reset,
@@ -1962,6 +2089,9 @@ static void sdhci_tasklet_card(unsigned long param)
 
 	spin_lock_irqsave(&host->lock, flags);
 
+	if (host->clk_mgr_en)
+		goto out;
+
 	/* Check host->mrq first in case we are runtime suspended */
 	if (host->mrq &&
 	    !(sdhci_readl(host, SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)) {
@@ -1976,10 +2106,10 @@ static void sdhci_tasklet_card(unsigned long param)
 		host->mrq->cmd->error = -ENOMEDIUM;
 		tasklet_schedule(&host->finish_tasklet);
 	}
-
+out:
 	spin_unlock_irqrestore(&host->lock, flags);
 
-	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
 }
 
 static void sdhci_tasklet_finish(unsigned long param)
@@ -2041,7 +2171,8 @@ static void sdhci_tasklet_finish(unsigned long param)
 
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
-
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, CLK_TIMEOUT);
 	mmc_request_done(host->mmc, mrq);
 	sdhci_runtime_pm_put(host);
 }
@@ -2398,6 +2529,7 @@ int sdhci_suspend_host(struct sdhci_host *host)
 	if (host->ops->platform_suspend)
 		host->ops->platform_suspend(host);
 
+	sdhci_enable_clk(host);
 	sdhci_disable_card_detection(host);
 
 	/* Disable tuning since we are suspending */
@@ -2418,11 +2550,19 @@ int sdhci_suspend_host(struct sdhci_host *host)
 
 		sdhci_enable_card_detection(host);
 
-		return ret;
+		goto out;
 	}
 
 	free_irq(host->irq, host);
 
+out:
+	/* sync worker
+	 * mmc_suspend_host may disable the clk
+	 */
+	sdhci_enable_clk(host);
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, 0);
+
 	return ret;
 }
 
@@ -2432,6 +2572,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 {
 	int ret;
 
+	sdhci_enable_clk(host);
 	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
 		if (host->ops->enable_dma)
 			host->ops->enable_dma(host);
@@ -2440,7 +2581,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
 			  mmc_hostname(host->mmc), host);
 	if (ret)
-		return ret;
+		goto out;
 
 	if ((host->mmc->pm_flags & MMC_PM_KEEP_POWER) &&
 	    (host->quirks2 & SDHCI_QUIRK2_HOST_OFF_CARD_ON)) {
@@ -2455,11 +2596,19 @@ int sdhci_resume_host(struct sdhci_host *host)
 	}
 
 	ret = mmc_resume_host(host->mmc);
+
+	/* mmc_resume_host may disable the clk */
+	sdhci_enable_clk(host);
 	sdhci_enable_card_detection(host);
 
 	if (host->ops->platform_resume)
 		host->ops->platform_resume(host);
 
+out:
+	/* sync worker */
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, 0);
+
 	/* Set the re-tuning expiration flag */
 	if ((host->version >= SDHCI_SPEC_300) && host->tuning_count &&
 	    (host->tuning_mode == SDHCI_TUNING_MODE_1))
@@ -2473,9 +2622,14 @@ EXPORT_SYMBOL_GPL(sdhci_resume_host);
 void sdhci_enable_irq_wakeups(struct sdhci_host *host)
 {
 	u8 val;
+
+	sdhci_enable_clk(host);
 	val = sdhci_readb(host, SDHCI_WAKE_UP_CONTROL);
 	val |= SDHCI_WAKE_ON_INT;
 	sdhci_writeb(host, val, SDHCI_WAKE_UP_CONTROL);
+
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, CLK_TIMEOUT);
 }
 
 EXPORT_SYMBOL_GPL(sdhci_enable_irq_wakeups);
@@ -2611,6 +2765,11 @@ int sdhci_add_host(struct sdhci_host *host)
 	if (debug_quirks2)
 		host->quirks2 = debug_quirks2;
 
+	if (host->clk_mgr_en)
+		INIT_DELAYED_WORK(&host->clk_worker, sdhci_clk_worker);
+
+	sdhci_enable_clk(host);
+
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
 	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
@@ -2704,6 +2863,8 @@ int sdhci_add_host(struct sdhci_host *host)
 		if (!host->ops->get_max_clock) {
 			pr_err("%s: Hardware doesn't specify base clock "
 			       "frequency.\n", mmc_hostname(mmc));
+			if (!sdhci_is_sdio_attached(host))
+				sdhci_disable_clk(host, 0);
 			return -ENODEV;
 		}
 		host->max_clk = host->ops->get_max_clock(host);
@@ -2750,6 +2911,8 @@ int sdhci_add_host(struct sdhci_host *host)
 				SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)) {
 			pr_err("%s: Hardware doesn't specify timeout clock "
 			       "frequency.\n", mmc_hostname(mmc));
+			if (!sdhci_is_sdio_attached(host))
+				sdhci_disable_clk(host, 0);
 			return -ENODEV;
 		}
 	}
@@ -2768,6 +2931,7 @@ int sdhci_add_host(struct sdhci_host *host)
 
 	/* Auto-CMD23 stuff only works in ADMA or PIO. */
 	if ((host->version >= SDHCI_SPEC_300) &&
+	    !(host->quirks2 & SDHCI_QUIRK2_HOST_OFF_CARD_ON) &&
 	    ((host->flags & SDHCI_USE_ADMA) ||
 	     !(host->flags & SDHCI_USE_SDMA))) {
 		host->flags |= SDHCI_AUTO_CMD23;
@@ -2923,6 +3087,8 @@ int sdhci_add_host(struct sdhci_host *host)
 	if (mmc->ocr_avail == 0) {
 		pr_err("%s: Hardware doesn't report any "
 			"support voltages.\n", mmc_hostname(mmc));
+		if (!sdhci_is_sdio_attached(host))
+			sdhci_disable_clk(host, 0);
 		return -ENODEV;
 	}
 
@@ -3001,11 +3167,6 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->tuning_timer.function = sdhci_tuning_timer;
 	}
 
-	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
-		mmc_hostname(mmc), host);
-	if (ret)
-		goto untasklet;
-
 	host->vmmc = regulator_get(mmc_dev(mmc), "vmmc");
 	if (IS_ERR(host->vmmc)) {
 		pr_info("%s: no vmmc regulator found\n", mmc_hostname(mmc));
@@ -3014,6 +3175,11 @@ int sdhci_add_host(struct sdhci_host *host)
 
 	sdhci_init(host, 0);
 
+	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
+		mmc_hostname(mmc), host);
+	if (ret)
+		goto untasklet;
+
 #ifdef CONFIG_MMC_DEBUG
 	sdhci_dumpregs(host);
 #endif
@@ -3041,7 +3207,8 @@ int sdhci_add_host(struct sdhci_host *host)
 		(host->flags & SDHCI_USE_SDMA) ? "DMA" : "PIO");
 
 	sdhci_enable_card_detection(host);
-
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, CLK_TIMEOUT);
 	return 0;
 
 #ifdef SDHCI_USE_LEDS_CLASS
@@ -3052,7 +3219,8 @@ reset:
 untasklet:
 	tasklet_kill(&host->card_tasklet);
 	tasklet_kill(&host->finish_tasklet);
-
+	if (!sdhci_is_sdio_attached(host))
+		sdhci_disable_clk(host, 0);
 	return ret;
 }
 
@@ -3062,6 +3230,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 {
 	unsigned long flags;
 
+	sdhci_enable_clk(host);
 	if (dead) {
 		spin_lock_irqsave(&host->lock, flags);
 
@@ -3078,6 +3247,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 		spin_unlock_irqrestore(&host->lock, flags);
 	}
 
+	sdhci_enable_clk(host);
 	sdhci_disable_card_detection(host);
 
 	mmc_remove_host(host->mmc);
@@ -3086,8 +3256,10 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	led_classdev_unregister(&host->led);
 #endif
 
+	sdhci_enable_clk(host);
 	if (!dead)
 		sdhci_reset(host, SDHCI_RESET_ALL);
+	sdhci_disable_clk(host, 0);
 
 	free_irq(host->irq, host);
 
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index f761f23..2843b7c 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -277,6 +277,9 @@ struct sdhci_ops {
 	void	(*hw_reset)(struct sdhci_host *host);
 	void	(*platform_suspend)(struct sdhci_host *host);
 	void	(*platform_resume)(struct sdhci_host *host);
+
+	void		(*platform_clk_ctrl)(struct sdhci_host *host, bool enable);
+	int		(*platform_execute_tuning)(struct sdhci_host *host);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index e9051e1..f85d2c5 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -17,6 +17,11 @@
 #include <linux/io.h>
 #include <linux/mmc/host.h>
 
+struct sdhci_host_next {
+	unsigned int    dma_len;
+	s32		cookie;
+};
+
 struct sdhci_host {
 	/* Data set by hardware interface driver */
 	const char *hw_name;	/* Hardware bus name */
@@ -169,6 +174,15 @@ struct sdhci_host {
 #define SDHCI_TUNING_MODE_1	0
 	struct timer_list	tuning_timer;	/* Timer for tuning */
 
+	unsigned int		tuning_min;
+	unsigned int		tuning_max;
+	unsigned int		tuning_step;
+
+	struct delayed_work	clk_worker;	/* Clock delayed worker */
+	unsigned int		clk_mgr_en;
+	unsigned int		clk_status;
+	struct sdhci_host_next	next_data;
+
 	unsigned long private[0] ____cacheline_aligned;
 };
 #endif /* LINUX_MMC_SDHCI_H */
-- 
1.7.5.4

