From 4f5f6df643a93d68ebd8726b8388f9383496abb8 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Fri, 6 Sep 2013 23:10:55 +0800
Subject: [PATCH 0775/1072] ENGR00278646-11 mmc: sdhci-esdhc-imx: improve
 sd3.0 stability

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit c99a884a2155407e473635b8c250a2c83b3c58a0

We observed on some sd3.0 cards(Toshiba SDHC U1) that it may require
to reset host controller before sending the next tuning command
or the tuning may fail and cause the card can not work on uhs mode.
The root cause why the card fails on tuning without reset is still unknow.
This could be treated as a workaround before finding root cause.

Signed-off-by: Dong Aisheng <b29396@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc-imx.c |   43 ++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci-esdhc.h     |    1 +
 2 files changed, 44 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index af41a3f..b23f68e 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -574,10 +574,53 @@ static int esdhc_pltfm_bus_width(struct sdhci_host *host, int width)
 	return 0;
 }
 
+static void esdhc_reset(struct sdhci_host *host, u32 rst_bits)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+	u32 timeout;
+	u32 reg;
+
+	reg = readl(host->ioaddr + ESDHC_SYSTEM_CONTROL);
+	reg |= rst_bits;
+	writel(reg, host->ioaddr + ESDHC_SYSTEM_CONTROL);
+
+	/* Wait for max 100ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readl(host->ioaddr + ESDHC_SYSTEM_CONTROL) & rst_bits) {
+		if (timeout == 0) {
+			dev_err(mmc_dev(host->mmc),
+				"Reset never completes!\n");
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	/*
+	* The RSTA, reset all, on usdhc will not clear following regs:
+	* > SDHCI_MIX_CTRL
+	* > SDHCI_TUNE_CTRL_STATUS
+	*
+	* Do it manually here.
+	*/
+	if ((rst_bits & ESDHC_SYS_CTRL_RSTA) && is_imx6q_usdhc(imx_data)) {
+		writel(0, host->ioaddr + ESDHC_MIX_CTRL);
+		writel(0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);
+		/* FIXME: delay for clear tuning status or some cards may not work */
+		mdelay(1);
+	}
+}
+
 static void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)
 {
 	u32 reg;
 
+	/* reset controller before tuning or it may fail on some cards */
+	esdhc_reset(host, ESDHC_SYS_CTRL_RSTA);
+
 	reg = readl(host->ioaddr + ESDHC_MIX_CTRL);
 	reg |= ESDHC_MIX_CTRL_EXE_TUNE | ESDHC_MIX_CTRL_SMPCLK_SEL |
 			ESDHC_MIX_CTRL_FBCLK_SEL;
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index eb3b0dd..1b46939 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -26,6 +26,7 @@
 				SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
 
 #define ESDHC_SYSTEM_CONTROL	0x2c
+#define ESDHC_SYS_CTRL_RSTA	(1 << 24)
 #define ESDHC_CLOCK_MASK	0x0000fff0
 #define ESDHC_PREDIV_SHIFT	8
 #define ESDHC_DIVIDER_SHIFT	4
-- 
1.7.5.4

