From 8a2067a9577fd1d9c8c2bd6372a0df0f140a2696 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 19 Jun 2013 15:49:15 +0800
Subject: [PATCH 09/38] fsl_imx6q: Update ethernet driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/clock.c                 |    2 +-
 arch/arm/plat-mxc/devices/platform-fec.c  |   25 +-
 drivers/net/ethernet/freescale/Kconfig    |   29 +
 drivers/net/ethernet/freescale/Makefile   |    5 +
 drivers/net/ethernet/freescale/fec.c      | 1270 +++++++++++++++++------------
 drivers/net/ethernet/freescale/fec.h      |  145 +---
 drivers/net/ethernet/freescale/fec_1588.c |  659 +++++++++++++++
 drivers/net/ethernet/freescale/fec_1588.h |  227 +++++
 drivers/net/phy/micrel.c                  |   28 +-
 9 files changed, 1734 insertions(+), 656 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/fec_1588.c
 create mode 100644 drivers/net/ethernet/freescale/fec_1588.h

diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index ddc2f1a..0995612 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -5303,7 +5303,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm_clk[2]),
 	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm_clk[3]),
 	_REGISTER_CLOCK(NULL, "pcie_clk", pcie_clk[0]),
-	_REGISTER_CLOCK("imx6q-fec.0", NULL, enet_clk[0]),
+	_REGISTER_CLOCK("enet.0", NULL, enet_clk[0]),
 	_REGISTER_CLOCK(NULL, "imx_sata_clk", sata_clk[0]),
 	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
 	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy1_clk),
diff --git a/arch/arm/plat-mxc/devices/platform-fec.c b/arch/arm/plat-mxc/devices/platform-fec.c
index 2f9eef5..0a03ea9 100644
--- a/arch/arm/plat-mxc/devices/platform-fec.c
+++ b/arch/arm/plat-mxc/devices/platform-fec.c
@@ -5,6 +5,8 @@
  * This program is free software; you can redistribute it and/or modify it under
  * the terms of the GNU General Public License version 2 as published by the
  * Free Software Foundation.
+ *
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 #include <linux/dma-mapping.h>
 #include <asm/sizes.h>
@@ -13,48 +15,44 @@
 
 #define imx_fec_data_entry_single(soc, _devid)				\
 	{								\
-		.devid = _devid,					\
 		.iobase = soc ## _FEC_BASE_ADDR,			\
 		.irq = soc ## _INT_FEC,					\
+		.devid = _devid,					\
 	}
 
 #ifdef CONFIG_SOC_IMX25
 const struct imx_fec_data imx25_fec_data __initconst =
-	imx_fec_data_entry_single(MX25, "imx25-fec");
+	imx_fec_data_entry_single(MX25, "imx28-fec");
 #endif /* ifdef CONFIG_SOC_IMX25 */
 
 #ifdef CONFIG_SOC_IMX27
 const struct imx_fec_data imx27_fec_data __initconst =
-	imx_fec_data_entry_single(MX27, "imx27-fec");
+	imx_fec_data_entry_single(MX27, "imx28-fec");
 #endif /* ifdef CONFIG_SOC_IMX27 */
 
 #ifdef CONFIG_SOC_IMX35
-/* i.mx35 has the i.mx27 type fec */
 const struct imx_fec_data imx35_fec_data __initconst =
-	imx_fec_data_entry_single(MX35, "imx27-fec");
+	imx_fec_data_entry_single(MX35, "imx28-fec");
 #endif
 
 #ifdef CONFIG_SOC_IMX50
-/* i.mx50 has the i.mx25 type fec */
 const struct imx_fec_data imx50_fec_data __initconst =
-	imx_fec_data_entry_single(MX50, "imx25-fec");
+	imx_fec_data_entry_single(MX50, "fec");
 #endif
 
 #ifdef CONFIG_SOC_IMX51
-/* i.mx51 has the i.mx27 type fec */
 const struct imx_fec_data imx51_fec_data __initconst =
-	imx_fec_data_entry_single(MX51, "imx27-fec");
+	imx_fec_data_entry_single(MX51, "fec");
 #endif
 
 #ifdef CONFIG_SOC_IMX53
-/* i.mx53 has the i.mx25 type fec */
 const struct imx_fec_data imx53_fec_data __initconst =
-	imx_fec_data_entry_single(MX53, "imx25-fec");
+	imx_fec_data_entry_single(MX53, "fec");
 #endif
 
 #ifdef CONFIG_SOC_IMX6Q
 const struct imx_fec_data imx6q_fec_data __initconst =
-	imx_fec_data_entry_single(MX6Q, "imx6q-fec");
+	imx_fec_data_entry_single(MX6Q, "enet");
 
 const struct imx_fec_data imx6sl_fec_data __initconst =
 	imx_fec_data_entry_single(MX6DL, "fec");
@@ -76,10 +74,9 @@ struct platform_device *__init imx_add_fec(
 		},
 	};
 
-#ifdef CONFIG_SOC_IMX6Q
 	if (!fuse_dev_is_available(MXC_DEV_ENET))
 		return ERR_PTR(-ENODEV);
-#endif
+
 	return imx_add_platform_device_dmamask(data->devid, 0,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index cf7aa07..c9fe120 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -30,6 +30,35 @@ config FEC
 	  Say Y here if you want to use the built-in 10/100 Fast ethernet
 	  controller on some Motorola ColdFire and Freescale i.MX processors.
 
+config FEC_NAPI
+       bool "Use NAPI for FEC driver"
+       depends on FEC
+       help
+         This option enables NAPI support for the FEC's on-chip
+         Fast Ethernet Controller driver.
+
+config FEC_1588
+	bool "Enable FEC 1588 timestamping"
+	depends on FEC
+
+choice
+	prompt "IEEE 1588 operation mode"
+	depends on (ARCH_MX5 || ARCH_MX6) && FEC_1588
+	default OUT_OF_BAND
+
+config OUT_OF_BAND
+	bool "out-of-band mode"
+	help
+	  IEEE 1588 operation mode is out-of-band, in this mode, the Tx and Rx
+	  timestamp will be caputred into special registers.
+
+config IN_BAND
+	bool "in-band mode"
+	help
+	  IEEE 1588 operation mode is in-band, in this mode, the Tx timestamp
+	  will be captured into special retisters, but the Rx timestamp will be
+	  captured into the first eight bytes of received ethernet packet.
+endchoice
 config FEC_MPC52xx
 	tristate "FEC MPC52xx driver"
 	depends on PPC_MPC52xx && PPC_BESTCOMM
diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index 4bd4c5a..1a875bf 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -3,6 +3,11 @@
 #
 
 obj-$(CONFIG_FEC) += fec.o
+
+ifeq ($(CONFIG_ARCH_MX6),y)
+	obj-$(CONFIG_FEC_1588) += fec_1588.o
+endif
+
 obj-$(CONFIG_FEC_PTP) += fec_ptp.o
 obj-$(CONFIG_FEC_MPC52xx) += fec_mpc52xx.o
 ifeq ($(CONFIG_FEC_MPC52xx_MDIO),y)
diff --git a/drivers/net/ethernet/freescale/fec.c b/drivers/net/ethernet/freescale/fec.c
index 6ae829e..14ee0de 100644
--- a/drivers/net/ethernet/freescale/fec.c
+++ b/drivers/net/ethernet/freescale/fec.c
@@ -18,7 +18,8 @@
  * Bug fixes and cleanup by Philippe De Muyter (phdm@macqel.be)
  * Copyright (c) 2004-2006 Macq Electronique SA.
  *
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Support for FEC IEEE 1588.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  */
 
 #include <linux/module.h>
@@ -26,6 +27,7 @@
 #include <linux/string.h>
 #include <linux/ptrace.h>
 #include <linux/errno.h>
+#include <linux/gpio.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -41,13 +43,10 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/clk.h>
+#include <mach/clock.h>
 #include <linux/platform_device.h>
 #include <linux/phy.h>
 #include <linux/fec.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_gpio.h>
-#include <linux/of_net.h>
 
 #include <asm/cacheflush.h>
 
@@ -57,8 +56,9 @@
 #endif
 
 #include "fec.h"
+#include "fec_1588.h"
 
-#if defined(CONFIG_ARM)
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28)
 #define FEC_ALIGNMENT	0xf
 #else
 #define FEC_ALIGNMENT	0x3
@@ -70,49 +70,22 @@
 #define FEC_QUIRK_ENET_MAC		(1 << 0)
 /* Controller needs driver to swap frame */
 #define FEC_QUIRK_SWAP_FRAME		(1 << 1)
-/* Controller uses gasket */
-#define FEC_QUIRK_USE_GASKET		(1 << 2)
-/* Controller has GBIT support */
-#define FEC_QUIRK_HAS_GBIT		(1 << 3)
 
 static struct platform_device_id fec_devtype[] = {
 	{
-		/* keep it for coldfire */
-		.name = DRIVER_NAME,
-		.driver_data = 0,
-	}, {
-		.name = "imx25-fec",
-		.driver_data = FEC_QUIRK_USE_GASKET,
-	}, {
-		.name = "imx27-fec",
+		.name = "enet",
+		.driver_data = FEC_QUIRK_ENET_MAC,
+	},
+	{
+		.name = "fec",
 		.driver_data = 0,
-	}, {
+	},
+	{
 		.name = "imx28-fec",
 		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_SWAP_FRAME,
-	}, {
-		.name = "imx6q-fec",
-		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_HAS_GBIT,
-	}, {
-		/* sentinel */
-	}
-};
-MODULE_DEVICE_TABLE(platform, fec_devtype);
-
-enum imx_fec_type {
-	IMX25_FEC = 1,	/* runs on i.mx25/50/53 */
-	IMX27_FEC,	/* runs on i.mx27/35/51 */
-	IMX28_FEC,
-	IMX6Q_FEC,
-};
-
-static const struct of_device_id fec_dt_ids[] = {
-	{ .compatible = "fsl,imx25-fec", .data = &fec_devtype[IMX25_FEC], },
-	{ .compatible = "fsl,imx27-fec", .data = &fec_devtype[IMX27_FEC], },
-	{ .compatible = "fsl,imx28-fec", .data = &fec_devtype[IMX28_FEC], },
-	{ .compatible = "fsl,imx6q-fec", .data = &fec_devtype[IMX6Q_FEC], },
-	{ /* sentinel */ }
+	},
+	{ }
 };
-MODULE_DEVICE_TABLE(of, fec_dt_ids);
 
 static unsigned char macaddr[ETH_ALEN];
 module_param_array(macaddr, byte, NULL, 0);
@@ -132,15 +105,28 @@ MODULE_PARM_DESC(macaddr, "FEC Ethernet MAC address");
 #elif defined (CONFIG_M5272C3)
 #define	FEC_FLASHMAC	(0xffe04000 + 4)
 #elif defined(CONFIG_MOD5272)
-#define FEC_FLASHMAC	0xffc0406b
+#define FEC_FLASHMAC 	0xffc0406b
 #else
 #define	FEC_FLASHMAC	0
 #endif
 #endif /* CONFIG_M5272 */
 
-#if (((RX_RING_SIZE + TX_RING_SIZE) * 8) > PAGE_SIZE)
-#error "FEC: descriptor ring size constants too large"
-#endif
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it it best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#define FEC_ENET_RX_PAGES	192
+#define FEC_ENET_RX_FRSIZE	2048
+#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
+#define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
+#define FEC_ENET_TX_FRSIZE	2048
+#define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
+#define TX_RING_SIZE		128	/* Must be power of two */
+#define TX_RING_MOD_MASK	127	/*   for this to work */
+
+#define BUFDES_SIZE ((RX_RING_SIZE + TX_RING_SIZE) * sizeof(struct bufdesc))
 
 /* Interrupt events/masks. */
 #define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
@@ -153,8 +139,17 @@ MODULE_PARM_DESC(macaddr, "FEC Ethernet MAC address");
 #define FEC_ENET_RXB	((uint)0x01000000)	/* A buffer was received */
 #define FEC_ENET_MII	((uint)0x00800000)	/* MII interrupt */
 #define FEC_ENET_EBERR	((uint)0x00400000)	/* SDMA bus error */
+#define FEC_ENET_TS_AVAIL       ((uint)0x00010000)
+#define FEC_ENET_TS_TIMER       ((uint)0x00008000)
+#define FEC_ENET_MII_CLK       ((uint)2500000)
+#define FEC_ENET_HOLD_TIME     ((uint)0x100)  /* 2 internal clock cycle*/
 
 #define FEC_DEFAULT_IMASK (FEC_ENET_TXF | FEC_ENET_RXF | FEC_ENET_MII)
+#if defined(CONFIG_FEC_1588)
+#define FEC_1588_IMASK	  (FEC_ENET_TS_AVAIL | FEC_ENET_TS_TIMER)
+#else
+#define FEC_1588_IMASK	0
+#endif
 
 /* The FEC stores dest/src/type, data, and checksum for receive packets.
  */
@@ -162,18 +157,102 @@ MODULE_PARM_DESC(macaddr, "FEC Ethernet MAC address");
 #define PKT_MINBUF_SIZE		64
 #define PKT_MAXBLR_SIZE		1520
 
+/* Pause frame feild and FIFO threshold */
+#define FEC_ENET_FCE		(1 << 5)
+#define FEC_ENET_RSEM_V		0x84
+#define FEC_ENET_RSFL_V		16
+#define FEC_ENET_RAEM_V		0x8
+#define FEC_ENET_RAFL_V		0x8
+#define FEC_ENET_OPD_V		0xFFF0
+
 /*
  * The 5270/5271/5280/5282/532x RX control register also contains maximum frame
  * size bits. Other FEC hardware does not, so we need to take that into
  * account when setting it.
  */
 #if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M520x) || defined(CONFIG_M532x) || defined(CONFIG_ARM)
+    defined(CONFIG_M520x) || defined(CONFIG_M532x) || \
+    defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28)
 #define	OPT_FRAME_SIZE	(PKT_MAXBUF_SIZE << 16)
 #else
 #define	OPT_FRAME_SIZE	0
 #endif
 
+/* The FEC buffer descriptors track the ring buffers.  The rx_bd_base and
+ * tx_bd_base always point to the base of the buffer descriptors.  The
+ * cur_rx and cur_tx point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct fec_enet_private {
+	/* Hardware registers of the FEC device */
+	void __iomem *hwp;
+
+	struct net_device *netdev;
+
+	struct clk *clk;
+
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	unsigned char *tx_bounce[TX_RING_SIZE];
+	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
+	struct	sk_buff* rx_skbuff[RX_RING_SIZE];
+	ushort	skb_cur;
+	ushort	skb_dirty;
+
+	/* CPM dual port RAM relative addresses */
+	dma_addr_t	bd_dma;
+	/* Address of Rx and Tx buffers */
+	struct bufdesc	*rx_bd_base;
+	struct bufdesc	*tx_bd_base;
+	/* The next free ring entry */
+	struct bufdesc	*cur_rx, *cur_tx;
+	/* The ring entries to be free()ed */
+	struct bufdesc	*dirty_tx;
+
+	uint	tx_full;
+	/* hold while accessing the HW like ringbuffer for tx/rx but not MAC */
+	spinlock_t hw_lock;
+
+	struct	platform_device *pdev;
+
+	int	opened;
+
+	/* Phylib and MDIO interface */
+	struct	mii_bus *mii_bus;
+	struct	phy_device *phy_dev;
+	int	mii_timeout;
+	uint	phy_speed;
+	phy_interface_t	phy_interface;
+	int	index;
+	int	link;
+	int	full_duplex;
+	struct	completion mdio_done;
+
+	struct  fec_ptp_private *ptp_priv;
+	uint    ptimer_present;
+
+	struct napi_struct napi;
+	int	napi_weight;
+	bool	use_napi;
+};
+
+#define FEC_NAPI_WEIGHT 64
+#ifdef CONFIG_FEC_NAPI
+#define FEC_NAPI_ENABLE TRUE
+#else
+#define FEC_NAPI_ENABLE FALSE
+#endif
+
+static irqreturn_t fec_enet_interrupt(int irq, void * dev_id);
+static void fec_enet_tx(struct net_device *dev);
+static int fec_rx_poll(struct napi_struct *napi, int budget);
+static void fec_enet_rx(struct net_device *dev);
+static int fec_enet_close(struct net_device *dev);
+static void fec_restart(struct net_device *dev, int duplex);
+static void fec_stop(struct net_device *dev);
+
 /* FEC MII MMFR bits definition */
 #define FEC_MMFR_ST		(1 << 30)
 #define FEC_MMFR_OP_READ	(2 << 28)
@@ -183,13 +262,11 @@ MODULE_PARM_DESC(macaddr, "FEC Ethernet MAC address");
 #define FEC_MMFR_TA		(2 << 16)
 #define FEC_MMFR_DATA(v)	(v & 0xffff)
 
-#define FEC_MII_TIMEOUT		30000 /* us */
+#define FEC_MII_TIMEOUT		30 /* ms */
 
 /* Transmitter timeout */
 #define TX_TIMEOUT (2 * HZ)
 
-static int mii_cnt;
-
 static void *swap_buffer(void *bufaddr, int len)
 {
 	int i;
@@ -210,6 +287,7 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	struct bufdesc *bdp;
 	void *bufaddr;
 	unsigned short	status;
+	unsigned long   estatus;
 	unsigned long flags;
 
 	spin_lock_irqsave(&fep->hw_lock, flags);
@@ -222,7 +300,6 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* Fill in a Tx ring entry */
 	bdp = fep->cur_tx;
-
 	status = bdp->cbd_sc;
 
 	if (status & BD_ENET_TX_READY) {
@@ -254,6 +331,17 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 		memcpy(bufaddr, (void *)skb->data, skb->len);
 	}
 
+	if (fep->ptimer_present) {
+		if (fec_ptp_do_txstamp(skb)) {
+			estatus = BD_ENET_TX_TS;
+			status |= BD_ENET_TX_PTP;
+		} else
+			estatus = 0;
+#ifdef CONFIG_ENHANCED_BD
+		bdp->cbd_esc = (estatus | BD_ENET_TX_INT);
+		bdp->cbd_bdu = 0;
+#endif
+	}
 	/*
 	 * Some design made an incorrect assumption on endian mode of
 	 * the system that it's running on. As the result, driver has to
@@ -281,17 +369,6 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 			| BD_ENET_TX_LAST | BD_ENET_TX_TC);
 	bdp->cbd_sc = status;
 
-#ifdef CONFIG_FEC_PTP
-	bdp->cbd_bdu = 0;
-	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&
-			fep->hwts_tx_en)) {
-			bdp->cbd_esc = (BD_ENET_TX_TS | BD_ENET_TX_INT);
-			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-	} else {
-
-		bdp->cbd_esc = BD_ENET_TX_INT;
-	}
-#endif
 	/* Trigger transmission start */
 	writel(0, fep->hwp + FEC_X_DES_ACTIVE);
 
@@ -308,238 +385,62 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	fep->cur_tx = bdp;
 
-	skb_tx_timestamp(skb);
-
 	spin_unlock_irqrestore(&fep->hw_lock, flags);
 
 	return NETDEV_TX_OK;
 }
 
-/* Init TX buffer descriptors
- */
-static void fec_enet_txbd_init(struct net_device *dev)
-{
-	struct fec_enet_private *fep = netdev_priv(dev);
-	struct bufdesc *bdp;
-	int i;
-
-	/* ...and the same for transmit */
-	bdp = fep->tx_bd_base;
-	for (i = 0; i < TX_RING_SIZE; i++) {
-
-		/* Initialize the BD for every fragment in the page. */
-		bdp->cbd_sc = 0;
-		bdp++;
-	}
-
-	/* Set the last buffer to wrap */
-	bdp--;
-	bdp->cbd_sc |= BD_SC_WRAP;
-}
-
-/* This function is called to start or restart the FEC during a link
- * change.  This only happens when switching between half and full
- * duplex.
- */
 static void
-fec_restart(struct net_device *ndev, int duplex)
+fec_timeout(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
-	const struct platform_device_id *id_entry =
-				platform_get_device_id(fep->pdev);
-	int i;
-	u32 temp_mac[2];
-	u32 rcntl = OPT_FRAME_SIZE | 0x04;
-	u32 ecntl = 0x2; /* ETHEREN */
-
-	/* Whack a reset.  We should wait for this. */
-	writel(1, fep->hwp + FEC_ECNTRL);
-	udelay(10);
-
-	/*
-	 * enet-mac reset will reset mac address registers too,
-	 * so need to reconfigure it.
-	 */
-	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC) {
-		memcpy(&temp_mac, ndev->dev_addr, ETH_ALEN);
-		writel(cpu_to_be32(temp_mac[0]), fep->hwp + FEC_ADDR_LOW);
-		writel(cpu_to_be32(temp_mac[1]), fep->hwp + FEC_ADDR_HIGH);
-	}
-
-	/* Clear any outstanding interrupt. */
-	writel(0xffc00000, fep->hwp + FEC_IEVENT);
-
-	/* Reset all multicast.	*/
-	writel(0, fep->hwp + FEC_GRP_HASH_TABLE_HIGH);
-	writel(0, fep->hwp + FEC_GRP_HASH_TABLE_LOW);
-#ifndef CONFIG_M5272
-	writel(0, fep->hwp + FEC_HASH_TABLE_HIGH);
-	writel(0, fep->hwp + FEC_HASH_TABLE_LOW);
-#endif
-
-	/* Set maximum receive buffer size. */
-	writel(PKT_MAXBLR_SIZE, fep->hwp + FEC_R_BUFF_SIZE);
-
-	/* Set receive and transmit descriptor base. */
-	writel(fep->bd_dma, fep->hwp + FEC_R_DES_START);
-	writel((unsigned long)fep->bd_dma + sizeof(struct bufdesc) * RX_RING_SIZE,
-			fep->hwp + FEC_X_DES_START);
-
-	/* Reinit transmit descriptors */
-	fec_enet_txbd_init(ndev);
-
-	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
-	fep->cur_rx = fep->rx_bd_base;
-
-	/* Reset SKB transmit buffers. */
-	fep->skb_cur = fep->skb_dirty = 0;
-	for (i = 0; i <= TX_RING_MOD_MASK; i++) {
-		if (fep->tx_skbuff[i]) {
-			dev_kfree_skb_any(fep->tx_skbuff[i]);
-			fep->tx_skbuff[i] = NULL;
-		}
-	}
-
-	/* Enable MII mode */
-	if (duplex) {
-		/* FD enable */
-		writel(0x04, fep->hwp + FEC_X_CNTRL);
-	} else {
-		/* No Rcv on Xmit */
-		rcntl |= 0x02;
-		writel(0x0, fep->hwp + FEC_X_CNTRL);
-	}
-
-	fep->full_duplex = duplex;
-
-	/* Set MII speed */
-	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
-
-	/*
-	 * The phy interface and speed need to get configured
-	 * differently on enet-mac.
-	 */
-	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC) {
-		/* Enable flow control and length check */
-		rcntl |= 0x40000000 | 0x00000020;
-
-		/* RGMII, RMII or MII */
-		if (fep->phy_interface == PHY_INTERFACE_MODE_RGMII)
-			rcntl |= (1 << 6);
-		else if (fep->phy_interface == PHY_INTERFACE_MODE_RMII)
-			rcntl |= (1 << 8);
-		else
-			rcntl &= ~(1 << 8);
-
-		/* 1G, 100M or 10M */
-		if (fep->phy_dev) {
-			if (fep->phy_dev->speed == SPEED_1000)
-				ecntl |= (1 << 5);
-			else if (fep->phy_dev->speed == SPEED_100)
-				rcntl &= ~(1 << 9);
-			else
-				rcntl |= (1 << 9);
-		}
-	} else {
-#ifdef FEC_MIIGSK_ENR
-		if (id_entry->driver_data & FEC_QUIRK_USE_GASKET) {
-			u32 cfgr;
-			/* disable the gasket and wait */
-			writel(0, fep->hwp + FEC_MIIGSK_ENR);
-			while (readl(fep->hwp + FEC_MIIGSK_ENR) & 4)
-				udelay(1);
-
-			/*
-			 * configure the gasket:
-			 *   RMII, 50 MHz, no loopback, no echo
-			 *   MII, 25 MHz, no loopback, no echo
-			 */
-			cfgr = (fep->phy_interface == PHY_INTERFACE_MODE_RMII)
-				? BM_MIIGSK_CFGR_RMII : BM_MIIGSK_CFGR_MII;
-			if (fep->phy_dev && fep->phy_dev->speed == SPEED_10)
-				cfgr |= BM_MIIGSK_CFGR_FRCONT_10M;
-			writel(cfgr, fep->hwp + FEC_MIIGSK_CFGR);
-
-			/* re-enable the gasket */
-			writel(2, fep->hwp + FEC_MIIGSK_ENR);
-		}
-#endif
-	}
-	writel(rcntl, fep->hwp + FEC_R_CNTRL);
-
-	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC) {
-		/* enable ENET endian swap */
-		ecntl |= (1 << 8);
-		/* enable ENET store and forward mode */
-		writel(1 << 8, fep->hwp + FEC_X_WMRK);
-	}
 
-#ifdef CONFIG_FEC_PTP
-	ecntl |= (1 << 4);
-#endif
+	ndev->stats.tx_errors++;
 
-	/* And last, enable the transmit and receive processing */
-	writel(ecntl, fep->hwp + FEC_ECNTRL);
-	writel(0, fep->hwp + FEC_R_DES_ACTIVE);
+	netif_device_detach(ndev);
+	fec_stop(ndev);
 
-#ifdef CONFIG_FEC_PTP
-	fec_ptp_start_cyclecounter(ndev);
-#endif
-	/* Enable interrupts we wish to service */
-	writel(FEC_DEFAULT_IMASK, fep->hwp + FEC_IMASK);
+	fec_restart(ndev, fep->full_duplex);
+	netif_device_attach(ndev);
+	ndev->trans_start = jiffies; /* prevent tx timeout */
+	if (fep->link && !fep->tx_full)
+		netif_wake_queue(ndev);
 }
 
 static void
-fec_stop(struct net_device *ndev)
+fec_rx_int_is_enabled(struct net_device *ndev, bool enabled)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
-	const struct platform_device_id *id_entry =
-				platform_get_device_id(fep->pdev);
-	u32 rmii_mode = readl(fep->hwp + FEC_R_CNTRL) & (1 << 8);
+	uint    int_events;
 
-	/* We cannot expect a graceful transmit stop without link !!! */
-	if (fep->link) {
-		writel(1, fep->hwp + FEC_X_CNTRL); /* Graceful transmit stop */
-		udelay(10);
-		if (!(readl(fep->hwp + FEC_IEVENT) & FEC_ENET_GRA))
-			printk("fec_stop : Graceful transmit stop did not complete !\n");
-	}
-
-	/* Whack a reset.  We should wait for this. */
-	writel(1, fep->hwp + FEC_ECNTRL);
-	udelay(10);
-	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
-	writel(FEC_DEFAULT_IMASK, fep->hwp + FEC_IMASK);
-
-	/* We have to keep ENET enabled to have MII interrupt stay working */
-	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC) {
-		writel(2, fep->hwp + FEC_ECNTRL);
-		writel(rmii_mode, fep->hwp + FEC_R_CNTRL);
-	}
+	int_events = readl(fep->hwp + FEC_IMASK);
+	if (enabled)
+		int_events |= FEC_ENET_RXF;
+	else
+		int_events &= ~FEC_ENET_RXF;
+	writel(int_events, fep->hwp + FEC_IMASK);
 }
 
-
-static void
-fec_timeout(struct net_device *ndev)
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void fec_enet_netpoll(struct net_device *ndev)
 {
-	struct fec_enet_private *fep = netdev_priv(ndev);
-
-	ndev->stats.tx_errors++;
-
-	fec_restart(ndev, fep->full_duplex);
-	if (fep->link && !fep->tx_full)
-		netif_wake_queue(ndev);
+	disable_irq(ndev->irq);
+	fec_enet_interrupt(ndev->irq, ndev);
+	enable_irq(ndev->irq);
 }
+#endif
 
 static void
 fec_enet_tx(struct net_device *ndev)
 {
 	struct	fec_enet_private *fep;
+	struct  fec_ptp_private *fpp;
 	struct bufdesc *bdp;
 	unsigned short status;
 	struct	sk_buff	*skb;
 
 	fep = netdev_priv(ndev);
+	fpp = fep->ptp_priv;
 	spin_lock(&fep->hw_lock);
 	bdp = fep->dirty_tx;
 
@@ -547,7 +448,8 @@ fec_enet_tx(struct net_device *ndev)
 		if (bdp == fep->cur_tx && fep->tx_full == 0)
 			break;
 
-		dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
+		if (bdp->cbd_bufaddr)
+			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 				FEC_ENET_TX_FRSIZE, DMA_TO_DEVICE);
 		bdp->cbd_bufaddr = 0;
 
@@ -573,19 +475,6 @@ fec_enet_tx(struct net_device *ndev)
 			ndev->stats.tx_packets++;
 		}
 
-#ifdef CONFIG_FEC_PTP
-		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
-			struct skb_shared_hwtstamps shhwtstamps;
-			unsigned long flags;
-
-			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
-			spin_lock_irqsave(&fep->tmreg_lock, flags);
-			shhwtstamps.hwtstamp = ns_to_ktime(
-				timecounter_cyc2time(&fep->tc, bdp->ts));
-			spin_unlock_irqrestore(&fep->tmreg_lock, flags);
-			skb_tstamp_tx(skb, &shhwtstamps);
-		}
-#endif
 		if (status & BD_ENET_TX_READY)
 			printk("HEY! Enet xmit interrupt and TX_READY.\n");
 
@@ -595,6 +484,18 @@ fec_enet_tx(struct net_device *ndev)
 		if (status & BD_ENET_TX_DEF)
 			ndev->stats.collisions++;
 
+#if defined(CONFIG_ENHANCED_BD)
+		if (fep->ptimer_present) {
+			if (bdp->cbd_esc & BD_ENET_TX_TS)
+				fec_ptp_store_txstamp(fpp, skb, bdp);
+		}
+#elif defined(CONFIG_IN_BAND)
+		if (fep->ptimer_present) {
+			if (status & BD_ENET_TX_PTP)
+				fec_ptp_store_txstamp(fpp, skb, bdp);
+		}
+#endif
+
 		/* Free the sk buffer associated with this last transmit */
 		dev_kfree_skb_any(skb);
 		fep->tx_skbuff[fep->skb_dirty] = NULL;
@@ -618,6 +519,144 @@ fec_enet_tx(struct net_device *ndev)
 	spin_unlock(&fep->hw_lock);
 }
 
+/*NAPI polling Receive packets */
+static int fec_rx_poll(struct napi_struct *napi, int budget)
+{
+	struct  fec_enet_private *fep =
+		container_of(napi, struct fec_enet_private, napi);
+	struct net_device *ndev = napi->dev;
+	struct  fec_ptp_private *fpp = fep->ptp_priv;
+	const struct platform_device_id *id_entry =
+				platform_get_device_id(fep->pdev);
+	int pkt_received = 0;
+	struct bufdesc *bdp;
+	unsigned short status;
+	struct	sk_buff	*skb;
+	ushort	pkt_len;
+	__u8 *data;
+
+	if (fep->use_napi)
+		WARN_ON(!budget);
+
+#ifdef CONFIG_M532x
+	flush_cache_all();
+#endif
+
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = fep->cur_rx;
+
+	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
+		if (pkt_received >= budget)
+			break;
+		pkt_received++;
+
+		/* Since we have allocated space to hold a complete frame,
+		 * the last indicator should be set.
+		 */
+		if ((status & BD_ENET_RX_LAST) == 0)
+			dev_err(&ndev->dev, "FEC ENET: rcv is not +last\n");
+
+		if (!fep->opened)
+			goto rx_processing_done;
+
+		/* Check for errors. */
+		if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO |
+			   BD_ENET_RX_CR | BD_ENET_RX_OV)) {
+			ndev->stats.rx_errors++;
+			if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH)) {
+				/* Frame too long or too short. */
+				ndev->stats.rx_length_errors++;
+			}
+			if (status & BD_ENET_RX_NO)	/* Frame alignment */
+				ndev->stats.rx_frame_errors++;
+			if (status & BD_ENET_RX_CR)	/* CRC Error */
+				ndev->stats.rx_crc_errors++;
+			if (status & BD_ENET_RX_OV)	/* FIFO overrun */
+				ndev->stats.rx_fifo_errors++;
+		}
+
+		/* Report late collisions as a frame error.
+		 * On this error, the BD is closed, but we don't know what we
+		 * have in the buffer.  So, just drop this frame on the floor.
+		 */
+		if (status & BD_ENET_RX_CL) {
+			ndev->stats.rx_errors++;
+			ndev->stats.rx_frame_errors++;
+			goto rx_processing_done;
+		}
+
+		/* Process the incoming frame. */
+		ndev->stats.rx_packets++;
+		pkt_len = bdp->cbd_datlen;
+		ndev->stats.rx_bytes += pkt_len;
+		data = (__u8 *)__va(bdp->cbd_bufaddr);
+
+		if (bdp->cbd_bufaddr)
+			dma_unmap_single(&ndev->dev, bdp->cbd_bufaddr,
+				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
+
+		if (id_entry->driver_data & FEC_QUIRK_SWAP_FRAME)
+			swap_buffer(data, pkt_len);
+
+		/* This does 16 byte alignment, exactly what we need.
+		 * The packet length includes FCS, but we don't want to
+		 * include that when passing upstream as it messes up
+		 * bridging applications.
+		 */
+		skb = dev_alloc_skb(pkt_len - 4 + NET_IP_ALIGN);
+
+		if (unlikely(!skb)) {
+			dev_err(&ndev->dev,
+			"%s: Memory squeeze, dropping packet.\n", ndev->name);
+			ndev->stats.rx_dropped++;
+		} else {
+			skb_reserve(skb, NET_IP_ALIGN);
+			skb_put(skb, pkt_len - 4);	/* Make room */
+			skb_copy_to_linear_data(skb, data, pkt_len - 4);
+			/* 1588 messeage TS handle */
+			if (fep->ptimer_present)
+				fec_ptp_store_rxstamp(fpp, skb, bdp);
+			skb->protocol = eth_type_trans(skb, ndev);
+			netif_receive_skb(skb);
+		}
+
+		bdp->cbd_bufaddr = dma_map_single(&ndev->dev, data,
+				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
+rx_processing_done:
+		/* Clear the status flags for this buffer */
+		status &= ~BD_ENET_RX_STATS;
+
+		/* Mark the buffer empty */
+		status |= BD_ENET_RX_EMPTY;
+		bdp->cbd_sc = status;
+#ifdef CONFIG_ENHANCED_BD
+		bdp->cbd_esc = BD_ENET_RX_INT;
+		bdp->cbd_prot = 0;
+		bdp->cbd_bdu = 0;
+#endif
+
+		/* Update BD pointer to next entry */
+		if (status & BD_ENET_RX_WRAP)
+			bdp = fep->rx_bd_base;
+		else
+			bdp++;
+		/* Doing this here will keep the FEC running while we process
+		 * incoming frames.  On a heavily loaded network, we should be
+		 * able to keep up at the expense of system resources.
+		 */
+		writel(0, fep->hwp + FEC_R_DES_ACTIVE);
+	}
+	fep->cur_rx = bdp;
+
+	if (pkt_received < budget) {
+		napi_complete(napi);
+		fec_rx_int_is_enabled(ndev, true);
+	}
+
+	return pkt_received;
+}
 
 /* During a receive, the cur_rx points to the current incoming buffer.
  * When we update through the ring, if the next incoming buffer has
@@ -628,6 +667,7 @@ static void
 fec_enet_rx(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct  fec_ptp_private *fpp = fep->ptp_priv;
 	const struct platform_device_id *id_entry =
 				platform_get_device_id(fep->pdev);
 	struct bufdesc *bdp;
@@ -640,8 +680,6 @@ fec_enet_rx(struct net_device *ndev)
 	flush_cache_all();
 #endif
 
-	spin_lock(&fep->hw_lock);
-
 	/* First, grab all of the stats for the incoming packet.
 	 * These get messed up if we get called due to a busy condition.
 	 */
@@ -690,7 +728,8 @@ fec_enet_rx(struct net_device *ndev)
 		ndev->stats.rx_bytes += pkt_len;
 		data = (__u8*)__va(bdp->cbd_bufaddr);
 
-		dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
+		if (bdp->cbd_bufaddr)
+			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 				FEC_ENET_TX_FRSIZE, DMA_FROM_DEVICE);
 
 		if (id_entry->driver_data & FEC_QUIRK_SWAP_FRAME)
@@ -701,7 +740,7 @@ fec_enet_rx(struct net_device *ndev)
 		 * include that when passing upstream as it messes up
 		 * bridging applications.
 		 */
-		skb = netdev_alloc_skb(ndev, pkt_len - 4 + NET_IP_ALIGN);
+		skb = dev_alloc_skb(pkt_len - 4 + NET_IP_ALIGN);
 
 		if (unlikely(!skb)) {
 			printk("%s: Memory squeeze, dropping packet.\n",
@@ -711,24 +750,11 @@ fec_enet_rx(struct net_device *ndev)
 			skb_reserve(skb, NET_IP_ALIGN);
 			skb_put(skb, pkt_len - 4);	/* Make room */
 			skb_copy_to_linear_data(skb, data, pkt_len - 4);
+			/* 1588 messeage TS handle */
+			if (fep->ptimer_present)
+				fec_ptp_store_rxstamp(fpp, skb, bdp);
 			skb->protocol = eth_type_trans(skb, ndev);
-#ifdef CONFIG_FEC_PTP
-			/* Get receive timestamp from the skb */
-			if (fep->hwts_rx_en) {
-				struct skb_shared_hwtstamps *shhwtstamps =
-							    skb_hwtstamps(skb);
-				unsigned long flags;
-
-				memset(shhwtstamps, 0, sizeof(*shhwtstamps));
-
-				spin_lock_irqsave(&fep->tmreg_lock, flags);
-				shhwtstamps->hwtstamp = ns_to_ktime(
-				    timecounter_cyc2time(&fep->tc, bdp->ts));
-				spin_unlock_irqrestore(&fep->tmreg_lock, flags);
-			}
-#endif
-			if (!skb_defer_rx_timestamp(skb))
-				netif_rx(skb);
+			netif_rx(skb);
 		}
 
 		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, data,
@@ -740,8 +766,7 @@ rx_processing_done:
 		/* Mark the buffer empty */
 		status |= BD_ENET_RX_EMPTY;
 		bdp->cbd_sc = status;
-
-#ifdef CONFIG_FEC_PTP
+#ifdef CONFIG_ENHANCED_BD
 		bdp->cbd_esc = BD_ENET_RX_INT;
 		bdp->cbd_prot = 0;
 		bdp->cbd_bdu = 0;
@@ -759,8 +784,6 @@ rx_processing_done:
 		writel(0, fep->hwp + FEC_R_DES_ACTIVE);
 	}
 	fep->cur_rx = bdp;
-
-	spin_unlock(&fep->hw_lock);
 }
 
 static irqreturn_t
@@ -768,7 +791,9 @@ fec_enet_interrupt(int irq, void *dev_id)
 {
 	struct net_device *ndev = dev_id;
 	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct fec_ptp_private *fpp = fep->ptp_priv;
 	uint int_events;
+	ulong flags;
 	irqreturn_t ret = IRQ_NONE;
 
 	do {
@@ -777,7 +802,18 @@ fec_enet_interrupt(int irq, void *dev_id)
 
 		if (int_events & FEC_ENET_RXF) {
 			ret = IRQ_HANDLED;
-			fec_enet_rx(ndev);
+			spin_lock_irqsave(&fep->hw_lock, flags);
+
+			if (fep->use_napi) {
+				/* Disable the RX interrupt */
+				if (napi_schedule_prep(&fep->napi)) {
+					fec_rx_int_is_enabled(ndev, false);
+					__napi_schedule(&fep->napi);
+				}
+			} else
+				fec_enet_rx(ndev);
+
+			spin_unlock_irqrestore(&fep->hw_lock, flags);
 		}
 
 		/* Transmit OK, or non-fatal error. Update the buffer
@@ -789,6 +825,12 @@ fec_enet_interrupt(int irq, void *dev_id)
 			fec_enet_tx(ndev);
 		}
 
+		if (int_events & FEC_ENET_TS_TIMER) {
+			ret = IRQ_HANDLED;
+			if (fep->ptimer_present && fpp)
+				fpp->prtc++;
+		}
+
 		if (int_events & FEC_ENET_MII) {
 			ret = IRQ_HANDLED;
 			complete(&fep->mdio_done);
@@ -812,25 +854,11 @@ static void __inline__ fec_get_mac(struct net_device *ndev)
 	 *
 	 * 1) module parameter via kernel command line in form
 	 *    fec.macaddr=0x00,0x04,0x9f,0x01,0x30,0xe0
-	 */
-	iap = macaddr;
-
-#ifdef CONFIG_OF
-	/*
-	 * 2) from device tree data
-	 */
-	if (!is_valid_ether_addr(iap)) {
-		struct device_node *np = fep->pdev->dev.of_node;
-		if (np) {
-			const char *mac = of_get_mac_address(np);
-			if (mac)
-				iap = (unsigned char *) mac;
-		}
-	}
-#endif
+	 */
+	iap = macaddr;
 
 	/*
-	 * 3) from flash or fuse (via platform data)
+	 * 2) from flash or fuse (via platform data)
 	 */
 	if (!is_valid_ether_addr(iap)) {
 #ifdef CONFIG_M5272
@@ -838,12 +866,12 @@ static void __inline__ fec_get_mac(struct net_device *ndev)
 			iap = (unsigned char *)FEC_FLASHMAC;
 #else
 		if (pdata)
-			iap = (unsigned char *)&pdata->mac;
+			memcpy(iap, pdata->mac, ETH_ALEN);
 #endif
 	}
 
 	/*
-	 * 4) FEC mac registers set by bootloader
+	 * 3) FEC mac registers set by bootloader
 	 */
 	if (!is_valid_ether_addr(iap)) {
 		*((unsigned long *) &tmpaddr[0]) =
@@ -857,7 +885,7 @@ static void __inline__ fec_get_mac(struct net_device *ndev)
 
 	/* Adjust MAC if using macaddr */
 	if (iap == macaddr)
-		 ndev->dev_addr[ETH_ALEN-1] = macaddr[ETH_ALEN-1] + fep->dev_id;
+		 ndev->dev_addr[ETH_ALEN-1] = macaddr[ETH_ALEN-1] + fep->pdev->id;
 }
 
 /* ------------------------------------------------------------------------- */
@@ -869,6 +897,7 @@ static void fec_enet_adjust_link(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	struct phy_device *phy_dev = fep->phy_dev;
+	struct fec_platform_data *pdata = fep->pdev->dev.platform_data;
 	unsigned long flags;
 
 	int status_change = 0;
@@ -885,8 +914,6 @@ static void fec_enet_adjust_link(struct net_device *ndev)
 	if (phy_dev->link) {
 		if (fep->full_duplex != phy_dev->duplex) {
 			fec_restart(ndev, phy_dev->duplex);
-			/* prevent unnecessary second fec_restart() below */
-			fep->link = phy_dev->link;
 			status_change = 1;
 		}
 	}
@@ -906,8 +933,11 @@ static void fec_enet_adjust_link(struct net_device *ndev)
 spin_unlock:
 	spin_unlock_irqrestore(&fep->hw_lock, flags);
 
-	if (status_change)
+	if (status_change) {
+		if (!phy_dev->link && phy_dev && pdata && pdata->power_hibernate)
+			pdata->power_hibernate(phy_dev);
 		phy_print_status(phy_dev);
+	}
 }
 
 static int fec_enet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
@@ -925,10 +955,10 @@ static int fec_enet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 
 	/* wait for end of transfer */
 	time_left = wait_for_completion_timeout(&fep->mdio_done,
-			usecs_to_jiffies(FEC_MII_TIMEOUT));
+			msecs_to_jiffies(FEC_MII_TIMEOUT));
 	if (time_left == 0) {
 		fep->mii_timeout = 1;
-		printk(KERN_ERR "FEC: MDIO read timeout\n");
+		printk(KERN_ERR "FEC: MDIO read timeout, mii_id=%d\n", mii_id);
 		return -ETIMEDOUT;
 	}
 
@@ -953,10 +983,10 @@ static int fec_enet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
 
 	/* wait for end of transfer */
 	time_left = wait_for_completion_timeout(&fep->mdio_done,
-			usecs_to_jiffies(FEC_MII_TIMEOUT));
+			msecs_to_jiffies(FEC_MII_TIMEOUT));
 	if (time_left == 0) {
 		fep->mii_timeout = 1;
-		printk(KERN_ERR "FEC: MDIO write timeout\n");
+		printk(KERN_ERR "FEC: MDIO write timeout, mii_id=%d\n", mii_id);
 		return -ETIMEDOUT;
 	}
 
@@ -971,13 +1001,11 @@ static int fec_enet_mdio_reset(struct mii_bus *bus)
 static int fec_enet_mii_probe(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
-	const struct platform_device_id *id_entry =
-				platform_get_device_id(fep->pdev);
 	struct phy_device *phy_dev = NULL;
 	char mdio_bus_id[MII_BUS_ID_SIZE];
 	char phy_name[MII_BUS_ID_SIZE + 3];
 	int phy_id;
-	int dev_id = fep->dev_id;
+	int dev_id = fep->pdev->id;
 
 	fep->phy_dev = NULL;
 
@@ -996,36 +1024,38 @@ static int fec_enet_mii_probe(struct net_device *ndev)
 	}
 
 	if (phy_id >= PHY_MAX_ADDR) {
-		printk(KERN_INFO
-			"%s: no PHY, assuming direct connection to switch\n",
-			ndev->name);
-		strncpy(mdio_bus_id, "fixed-0", MII_BUS_ID_SIZE);
+		printk(KERN_INFO "%s: no PHY, assuming direct connection "
+			"to switch\n", ndev->name);
+		strncpy(mdio_bus_id, "0", MII_BUS_ID_SIZE);
 		phy_id = 0;
 	}
 
-	snprintf(phy_name, sizeof(phy_name), PHY_ID_FMT, mdio_bus_id, phy_id);
+	snprintf(phy_name, MII_BUS_ID_SIZE, PHY_ID_FMT, mdio_bus_id, phy_id);
 	phy_dev = phy_connect(ndev, phy_name, &fec_enet_adjust_link, 0,
-			      fep->phy_interface);
+		fep->phy_interface);
+
 	if (IS_ERR(phy_dev)) {
 		printk(KERN_ERR "%s: could not attach to PHY\n", ndev->name);
 		return PTR_ERR(phy_dev);
 	}
 
 	/* mask with MAC supported features */
-	if (id_entry->driver_data & FEC_QUIRK_HAS_GBIT)
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		phy_dev->supported &= PHY_GBIT_FEATURES;
 	else
 		phy_dev->supported &= PHY_BASIC_FEATURES;
 
+	/* enable phy pause frame for any platform */
+	phy_dev->supported |= ADVERTISED_Pause;
+
 	phy_dev->advertising = phy_dev->supported;
 
 	fep->phy_dev = phy_dev;
 	fep->link = 0;
 	fep->full_duplex = 0;
 
-	printk(KERN_INFO
-		"%s: Freescale FEC PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
-		ndev->name,
+	printk(KERN_INFO "%s: Freescale FEC PHY driver [%s] "
+		"(mii_bus:phy_addr=%s, irq=%d)\n", ndev->name,
 		fep->phy_dev->drv->name, dev_name(&fep->phy_dev->dev),
 		fep->phy_dev->irq);
 
@@ -1057,30 +1087,24 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 	 * mdio interface in board design, and need to be configured by
 	 * fec0 mii_bus.
 	 */
-	if ((id_entry->driver_data & FEC_QUIRK_ENET_MAC) && fep->dev_id > 0) {
+	if ((id_entry->driver_data & FEC_QUIRK_ENET_MAC) && pdev->id) {
 		/* fec1 uses fec0 mii_bus */
-		if (mii_cnt && fec0_mii_bus) {
-			fep->mii_bus = fec0_mii_bus;
-			mii_cnt++;
-			return 0;
-		}
-		return -ENOENT;
+		fep->mii_bus = fec0_mii_bus;
+		return 0;
 	}
 
 	fep->mii_timeout = 0;
 
 	/*
 	 * Set MII speed to 2.5 MHz (= clk_get_rate() / 2 * phy_speed)
-	 *
-	 * The formula for FEC MDC is 'ref_freq / (MII_SPEED x 2)' while
-	 * for ENET-MAC is 'ref_freq / ((MII_SPEED + 1) x 2)'.  The i.MX28
-	 * Reference Manual has an error on this, and gets fixed on i.MX6Q
-	 * document.
 	 */
-	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk), 5000000);
-	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC)
-		fep->phy_speed--;
-	fep->phy_speed <<= 1;
+	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk),
+					(FEC_ENET_MII_CLK << 2)) << 1;
+
+	/* set hold time to 2 internal clock cycle */
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
+		fep->phy_speed |= FEC_ENET_HOLD_TIME;
+
 	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
 
 	fep->mii_bus = mdiobus_alloc();
@@ -1093,8 +1117,7 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 	fep->mii_bus->read = fec_enet_mdio_read;
 	fep->mii_bus->write = fec_enet_mdio_write;
 	fep->mii_bus->reset = fec_enet_mdio_reset;
-	snprintf(fep->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
-		pdev->name, fep->dev_id + 1);
+	snprintf(fep->mii_bus->id, MII_BUS_ID_SIZE, "%x", pdev->id + 1);
 	fep->mii_bus->priv = fep;
 	fep->mii_bus->parent = &pdev->dev;
 
@@ -1110,8 +1133,6 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 	if (mdiobus_register(fep->mii_bus))
 		goto err_out_free_mdio_irq;
 
-	mii_cnt++;
-
 	/* save fec0 mii_bus */
 	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC)
 		fec0_mii_bus = fep->mii_bus;
@@ -1128,11 +1149,11 @@ err_out:
 
 static void fec_enet_mii_remove(struct fec_enet_private *fep)
 {
-	if (--mii_cnt == 0) {
-		mdiobus_unregister(fep->mii_bus);
-		kfree(fep->mii_bus->irq);
-		mdiobus_free(fep->mii_bus);
-	}
+	if (fep->phy_dev)
+		phy_disconnect(fep->phy_dev);
+	mdiobus_unregister(fep->mii_bus);
+	kfree(fep->mii_bus->irq);
+	mdiobus_free(fep->mii_bus);
 }
 
 static int fec_enet_get_settings(struct net_device *ndev,
@@ -1169,7 +1190,7 @@ static void fec_enet_get_drvinfo(struct net_device *ndev,
 	strcpy(info->bus_info, dev_name(&ndev->dev));
 }
 
-static const struct ethtool_ops fec_enet_ethtool_ops = {
+static struct ethtool_ops fec_enet_ethtool_ops = {
 	.get_settings		= fec_enet_get_settings,
 	.set_settings		= fec_enet_set_settings,
 	.get_drvinfo		= fec_enet_get_drvinfo,
@@ -1179,7 +1200,9 @@ static const struct ethtool_ops fec_enet_ethtool_ops = {
 static int fec_enet_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct fec_ptp_private *priv = fep->ptp_priv;
 	struct phy_device *phydev = fep->phy_dev;
+	int retVal = 0;
 
 	if (!netif_running(ndev))
 		return -EINVAL;
@@ -1187,11 +1210,16 @@ static int fec_enet_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 	if (!phydev)
 		return -ENODEV;
 
-#ifdef CONFIG_FEC_PTP
-	if (cmd == SIOCSHWTSTAMP)
-		return fec_ptp_ioctl(ndev, rq, cmd);
-#endif
-	return phy_mii_ioctl(phydev, rq, cmd);
+	if ((cmd >= PTP_ENBL_TXTS_IOCTL) &&
+			(cmd <= PTP_FLUSH_TIMESTAMP)) {
+		if (fep->ptimer_present)
+			retVal = fec_ptp_ioctl(priv, rq, cmd);
+		else
+			retVal = -ENODEV;
+	} else
+		retVal = phy_mii_ioctl(phydev, rq, cmd);
+
+	return retVal;
 }
 
 static void fec_enet_free_buffers(struct net_device *ndev)
@@ -1227,7 +1255,7 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 
 	bdp = fep->rx_bd_base;
 	for (i = 0; i < RX_RING_SIZE; i++) {
-		skb = netdev_alloc_skb(ndev, FEC_ENET_RX_FRSIZE);
+		skb = dev_alloc_skb(FEC_ENET_RX_FRSIZE);
 		if (!skb) {
 			fec_enet_free_buffers(ndev);
 			return -ENOMEM;
@@ -1237,7 +1265,7 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, skb->data,
 				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
 		bdp->cbd_sc = BD_ENET_RX_EMPTY;
-#ifdef CONFIG_FEC_PTP
+#ifdef CONFIG_ENHANCED_BD
 		bdp->cbd_esc = BD_ENET_RX_INT;
 #endif
 		bdp++;
@@ -1257,9 +1285,8 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 
 		bdp->cbd_sc = 0;
 		bdp->cbd_bufaddr = 0;
-
-#ifdef CONFIG_FEC_PTP
-		bdp->cbd_esc = BD_ENET_RX_INT;
+#ifdef CONFIG_ENHANCED_BD
+		bdp->cbd_esc = BD_ENET_TX_INT;
 #endif
 		bdp++;
 	}
@@ -1275,12 +1302,16 @@ static int
 fec_enet_open(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct fec_platform_data *pdata = fep->pdev->dev.platform_data;
 	int ret;
 
+	if (fep->use_napi)
+		napi_enable(&fep->napi);
+
 	/* I should reset the ring buffers here, but I don't yet know
 	 * a simple way to do that.
 	 */
-
+	clk_enable(fep->clk);
 	ret = fec_enet_alloc_buffers(ndev);
 	if (ret)
 		return ret;
@@ -1291,9 +1322,15 @@ fec_enet_open(struct net_device *ndev)
 		fec_enet_free_buffers(ndev);
 		return ret;
 	}
+
 	phy_start(fep->phy_dev);
 	netif_start_queue(ndev);
 	fep->opened = 1;
+
+	ret = -EINVAL;
+	if (pdata->init && pdata->init(fep->phy_dev))
+		return ret;
+
 	return 0;
 }
 
@@ -1302,9 +1339,10 @@ fec_enet_close(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 
-	/* Don't know what to do yet. */
 	fep->opened = 0;
-	netif_stop_queue(ndev);
+	if (fep->use_napi)
+		napi_disable(&fep->napi);
+
 	fec_stop(ndev);
 
 	if (fep->phy_dev) {
@@ -1314,6 +1352,9 @@ fec_enet_close(struct net_device *ndev)
 
 	fec_enet_free_buffers(ndev);
 
+	/* Clock gate close for saving power */
+	clk_disable(fep->clk);
+
 	return 0;
 }
 
@@ -1364,6 +1405,10 @@ static void set_multicast_list(struct net_device *ndev)
 	writel(0, fep->hwp + FEC_GRP_HASH_TABLE_LOW);
 
 	netdev_for_each_mc_addr(ha, ndev) {
+		/* Only support group multicast for now */
+		if (!(ha->addr[0] & 1))
+			continue;
+
 		/* calculate crc32 value of mac address */
 		crc = 0xffffffff;
 
@@ -1412,29 +1457,6 @@ fec_set_mac_address(struct net_device *ndev, void *p)
 	return 0;
 }
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/*
- * fec_poll_controller: FEC Poll controller function
- * @dev: The FEC network adapter
- *
- * Polled functionality used by netconsole and others in non interrupt mode
- *
- */
-void fec_poll_controller(struct net_device *dev)
-{
-	int i;
-	struct fec_enet_private *fep = netdev_priv(dev);
-
-	for (i = 0; i < FEC_IRQ_NUM; i++) {
-		if (fep->irq[i] > 0) {
-			disable_irq(fep->irq[i]);
-			fec_enet_interrupt(fep->irq[i], dev);
-			enable_irq(fep->irq[i]);
-		}
-	}
-}
-#endif
-
 static const struct net_device_ops fec_netdev_ops = {
 	.ndo_open		= fec_enet_open,
 	.ndo_stop		= fec_enet_close,
@@ -1446,10 +1468,32 @@ static const struct net_device_ops fec_netdev_ops = {
 	.ndo_set_mac_address	= fec_set_mac_address,
 	.ndo_do_ioctl		= fec_enet_ioctl,
 #ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller	= fec_poll_controller,
+	.ndo_poll_controller    = fec_enet_netpoll,
 #endif
 };
 
+/* Init TX buffer descriptors
+ */
+static void fec_enet_txbd_init(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	struct bufdesc *bdp;
+	int i;
+
+	/* ...and the same for transmit */
+	bdp = fep->tx_bd_base;
+	for (i = 0; i < TX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page. */
+		bdp->cbd_sc = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+}
+
  /*
   * XXX:  We need to clean up on failure exits here.
   *
@@ -1462,7 +1506,7 @@ static int fec_enet_init(struct net_device *ndev)
 	int i;
 
 	/* Allocate memory for buffer descriptors. */
-	cbd_base = dma_alloc_coherent(NULL, PAGE_SIZE, &fep->bd_dma,
+	cbd_base = dma_alloc_coherent(NULL, BUFDES_SIZE, &fep->bd_dma,
 			GFP_KERNEL);
 	if (!cbd_base) {
 		printk("FEC: allocate descriptor memory failed?\n");
@@ -1485,12 +1529,20 @@ static int fec_enet_init(struct net_device *ndev)
 	ndev->netdev_ops = &fec_netdev_ops;
 	ndev->ethtool_ops = &fec_enet_ethtool_ops;
 
+	fep->use_napi = FEC_NAPI_ENABLE;
+	fep->napi_weight = FEC_NAPI_WEIGHT;
+	if (fep->use_napi) {
+		fec_rx_int_is_enabled(ndev, false);
+		netif_napi_add(ndev, &fep->napi, fec_rx_poll, fep->napi_weight);
+	}
+
 	/* Initialize the receive buffer descriptors. */
 	bdp = fep->rx_bd_base;
 	for (i = 0; i < RX_RING_SIZE; i++) {
 
 		/* Initialize the BD for every fragment in the page. */
 		bdp->cbd_sc = 0;
+		bdp->cbd_bufaddr = 0;
 		bdp++;
 	}
 
@@ -1506,48 +1558,230 @@ static int fec_enet_init(struct net_device *ndev)
 	return 0;
 }
 
-#ifdef CONFIG_OF
-static int __devinit fec_get_phy_mode_dt(struct platform_device *pdev)
+/* This function is called to start or restart the FEC during a link
+ * change.  This only happens when switching between half and full
+ * duplex.
+ */
+static void
+fec_restart(struct net_device *dev, int duplex)
 {
-	struct device_node *np = pdev->dev.of_node;
+	struct fec_enet_private *fep = netdev_priv(dev);
+	const struct platform_device_id *id_entry =
+				platform_get_device_id(fep->pdev);
+	int i, ret;
+	u32 val, temp_mac[2], reg = 0;
 
-	if (np)
-		return of_get_phy_mode(np);
+	/* Whack a reset.  We should wait for this. */
+	writel(1, fep->hwp + FEC_ECNTRL);
+	udelay(10);
 
-	return -ENODEV;
-}
+	/* if uboot don't set MAC address, get MAC address
+	 * from command line; if command line don't set MAC
+	 * address, get from OCOTP; otherwise, allocate random
+	 * address.
+	 */
+	memcpy(&temp_mac, dev->dev_addr, ETH_ALEN);
+	writel(cpu_to_be32(temp_mac[0]), fep->hwp + FEC_ADDR_LOW);
+	writel(cpu_to_be32(temp_mac[1]), fep->hwp + FEC_ADDR_HIGH);
 
-static void __devinit fec_reset_phy(struct platform_device *pdev)
-{
-	int err, phy_reset;
-	struct device_node *np = pdev->dev.of_node;
+	/* Clear any outstanding interrupt. */
+	writel(0xffc00000, fep->hwp + FEC_IEVENT);
 
-	if (!np)
-		return;
+	/* Reset all multicast.	*/
+	writel(0, fep->hwp + FEC_GRP_HASH_TABLE_HIGH);
+	writel(0, fep->hwp + FEC_GRP_HASH_TABLE_LOW);
+#ifndef CONFIG_M5272
+	writel(0, fep->hwp + FEC_HASH_TABLE_HIGH);
+	writel(0, fep->hwp + FEC_HASH_TABLE_LOW);
+#endif
 
-	phy_reset = of_get_named_gpio(np, "phy-reset-gpios", 0);
-	err = gpio_request_one(phy_reset, GPIOF_OUT_INIT_LOW, "phy-reset");
-	if (err) {
-		pr_debug("FEC: failed to get gpio phy-reset: %d\n", err);
-		return;
+	/* Set maximum receive buffer size. */
+	writel(PKT_MAXBLR_SIZE, fep->hwp + FEC_R_BUFF_SIZE);
+
+	/* Set receive and transmit descriptor base. */
+	writel(fep->bd_dma, fep->hwp + FEC_R_DES_START);
+	writel((unsigned long)fep->bd_dma + sizeof(struct bufdesc) * RX_RING_SIZE,
+			fep->hwp + FEC_X_DES_START);
+	/* Reinit transmit descriptors */
+	fec_enet_txbd_init(dev);
+
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->cur_rx = fep->rx_bd_base;
+
+	/* Reset SKB transmit buffers. */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i = 0; i <= TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i]) {
+			dev_kfree_skb_any(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
 	}
-	msleep(1);
-	gpio_set_value(phy_reset, 1);
-}
-#else /* CONFIG_OF */
-static inline int fec_get_phy_mode_dt(struct platform_device *pdev)
-{
-	return -ENODEV;
-}
 
-static inline void fec_reset_phy(struct platform_device *pdev)
-{
+	/* Enable MII mode */
+	if (duplex) {
+		/* MII enable / FD enable */
+		writel(OPT_FRAME_SIZE | 0x04, fep->hwp + FEC_R_CNTRL);
+		writel(0x04, fep->hwp + FEC_X_CNTRL);
+	} else {
+		/* MII enable / No Rcv on Xmit */
+		writel(OPT_FRAME_SIZE | 0x06, fep->hwp + FEC_R_CNTRL);
+		writel(0x0, fep->hwp + FEC_X_CNTRL);
+	}
+	fep->full_duplex = duplex;
+
+	/* Set MII speed */
+	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
+
 	/*
-	 * In case of platform probe, the reset has been done
-	 * by machine code.
+	 * The phy interface and speed need to get configured
+	 * differently on enet-mac.
+	 */
+	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC) {
+		val = readl(fep->hwp + FEC_R_CNTRL);
+
+		/* MII or RMII */
+		if (fep->phy_interface == PHY_INTERFACE_MODE_RGMII)
+			val |= (1 << 6);
+		else if (fep->phy_interface == PHY_INTERFACE_MODE_RMII)
+			val |= (1 << 8);
+		else
+			val &= ~(1 << 8);
+
+		/* 10M or 100M */
+		if (fep->phy_dev && fep->phy_dev->speed == SPEED_100)
+			val &= ~(1 << 9);
+		else
+			val |= (1 << 9);
+
+		/* Enable pause frame
+		 * ENET pause frame has two issues as ticket TKT116501
+		 * The issues have been fixed on Rigel TO1.1 and Arik TO1.2
+		 */
+		if ((cpu_is_mx6q() &&
+			(mx6q_revision() >= IMX_CHIP_REVISION_1_2)) ||
+			(cpu_is_mx6dl() &&
+			(mx6dl_revision() >= IMX_CHIP_REVISION_1_1)))
+			val |= FEC_ENET_FCE;
+
+		writel(val, fep->hwp + FEC_R_CNTRL);
+	}
+
+	if (fep->ptimer_present) {
+		/* Set Timer count */
+		ret = fec_ptp_start(fep->ptp_priv);
+		if (ret) {
+			fep->ptimer_present = 0;
+			reg = 0x0;
+		} else
+#if defined(CONFIG_SOC_IMX28) || defined(CONFIG_ARCH_MX6)
+			reg = 0x00000010;
+#else
+			reg = 0x0;
+#endif
+	} else
+		reg = 0x0;
+
+	if (cpu_is_mx25() || cpu_is_mx53() || cpu_is_mx6sl()) {
+		if (fep->phy_interface == PHY_INTERFACE_MODE_RMII) {
+			/* disable the gasket and wait */
+			writel(0, fep->hwp + FEC_MIIGSK_ENR);
+			while (readl(fep->hwp + FEC_MIIGSK_ENR) & 4)
+				udelay(1);
+
+			/*
+			 * configure the gasket:
+			 *   RMII, 50 MHz, no loopback, no echo
+			 */
+			writel(1, fep->hwp + FEC_MIIGSK_CFGR);
+
+			/* re-enable the gasket */
+			writel(2, fep->hwp + FEC_MIIGSK_ENR);
+			udelay(10);
+			if (!(readl(fep->hwp + FEC_MIIGSK_ENR) & 4)) {
+				udelay(100);
+				if (!(readl(fep->hwp + FEC_MIIGSK_ENR) & 4))
+					dev_err(&fep->pdev->dev,
+						"switch to RMII failed!\n");
+			}
+		}
+	}
+
+	/* ENET enable */
+	val = reg | (0x1 << 1);
+
+	/* if phy work at 1G mode, set ENET RGMII speed to 1G */
+	if (fep->phy_dev && (fep->phy_dev->supported &
+		(SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)) &&
+		fep->phy_interface == PHY_INTERFACE_MODE_RGMII &&
+		fep->phy_dev->speed == SPEED_1000)
+		val |= (0x1 << 5);
+
+	/* RX FIFO threshold setting for ENET pause frame feature
+	 * Only set the parameters after ticket TKT116501 fixed.
+	 * The issue has been fixed on Rigel TO1.1 and Arik TO1.2
 	 */
+	if ((cpu_is_mx6q() &&
+		(mx6q_revision() >= IMX_CHIP_REVISION_1_2)) ||
+		(cpu_is_mx6dl() &&
+		(mx6dl_revision() >= IMX_CHIP_REVISION_1_1))) {
+		writel(FEC_ENET_RSEM_V, fep->hwp + FEC_R_FIFO_RSEM);
+		writel(FEC_ENET_RSFL_V, fep->hwp + FEC_R_FIFO_RSFL);
+		writel(FEC_ENET_RAEM_V, fep->hwp + FEC_R_FIFO_RAEM);
+		writel(FEC_ENET_RAFL_V, fep->hwp + FEC_R_FIFO_RAFL);
+
+		/* OPD */
+		writel(FEC_ENET_OPD_V, fep->hwp + FEC_OPD);
+	}
+
+	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
+		/* enable endian swap */
+		val |= (0x1 << 8);
+		/* enable ENET store and forward mode */
+		writel(0x1 << 8, fep->hwp + FEC_X_WMRK);
+	}
+	writel(val, fep->hwp + FEC_ECNTRL);
+
+	writel(0, fep->hwp + FEC_R_DES_ACTIVE);
+
+	/* Enable interrupts we wish to service */
+	if (cpu_is_mx6q() || cpu_is_mx6dl() || cpu_is_mx2() || cpu_is_mx3())
+		val = (FEC_1588_IMASK | FEC_DEFAULT_IMASK);
+	else
+		val = FEC_DEFAULT_IMASK;
+	writel(val, fep->hwp + FEC_IMASK);
+}
+
+static void
+fec_stop(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	/* We cannot expect a graceful transmit stop without link !!! */
+	if (fep->link) {
+		writel(1, fep->hwp + FEC_X_CNTRL); /* Graceful transmit stop */
+		udelay(10);
+		if (!(readl(fep->hwp + FEC_IEVENT) & FEC_ENET_GRA))
+			printk("fec_stop : Graceful transmit stop did not complete !\n");
+	}
+
+	/* Whack a reset.  We should wait for this. */
+	writel(1, fep->hwp + FEC_ECNTRL);
+	udelay(10);
+
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
+		/* FIXME: we have to enable enet to keep mii interrupt works. */
+		writel(2, fep->hwp + FEC_ECNTRL);
+
+	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
+	if (fep->ptimer_present)
+		fec_ptp_stop(fep->ptp_priv);
+	writel(FEC_DEFAULT_IMASK, fep->hwp + FEC_IMASK);
+
+	if (netif_running(dev))
+		netif_stop_queue(dev);
+	netif_carrier_off(dev);     /* prevent tx timeout */
+	fep->link = 0;
 }
-#endif /* CONFIG_OF */
 
 static int __devinit
 fec_probe(struct platform_device *pdev)
@@ -1557,12 +1791,6 @@ fec_probe(struct platform_device *pdev)
 	struct net_device *ndev;
 	int i, irq, ret = 0;
 	struct resource *r;
-	const struct of_device_id *of_id;
-	static int dev_id;
-
-	of_id = of_match_device(fec_dt_ids, &pdev->dev);
-	if (of_id)
-		pdev->id_entry = of_id->data;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!r)
@@ -1586,7 +1814,6 @@ fec_probe(struct platform_device *pdev)
 
 	fep->hwp = ioremap(r->start, resource_size(r));
 	fep->pdev = pdev;
-	fep->dev_id = dev_id++;
 
 	if (!fep->hwp) {
 		ret = -ENOMEM;
@@ -1595,27 +1822,26 @@ fec_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ndev);
 
-	ret = fec_get_phy_mode_dt(pdev);
-	if (ret < 0) {
-		pdata = pdev->dev.platform_data;
-		if (pdata)
-			fep->phy_interface = pdata->phy;
-		else
-			fep->phy_interface = PHY_INTERFACE_MODE_MII;
-	} else {
-		fep->phy_interface = ret;
-	}
+	pdata = pdev->dev.platform_data;
+	if (pdata)
+		fep->phy_interface = pdata->phy;
 
-	fec_reset_phy(pdev);
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	gpio_request(pdata->gpio_irq, "gpio_enet_irq");
+	gpio_direction_input(pdata->gpio_irq);
 
-	for (i = 0; i < FEC_IRQ_NUM; i++) {
+	irq = gpio_to_irq(pdata->gpio_irq);
+	ret = request_irq(irq, fec_enet_interrupt,
+			IRQF_TRIGGER_RISING,
+			 pdev->name, ndev);
+	if (ret)
+		goto failed_irq;
+#else
+	/* This device has up to three irqs on some platforms */
+	for (i = 0; i < 3; i++) {
 		irq = platform_get_irq(pdev, i);
-		if (irq < 0) {
-			if (i)
-				break;
-			ret = irq;
-			goto failed_irq;
-		}
+		if (i && irq < 0)
+			break;
 		ret = request_irq(irq, fec_enet_interrupt, IRQF_DISABLED, pdev->name, ndev);
 		if (ret) {
 			while (--i >= 0) {
@@ -1624,26 +1850,16 @@ fec_probe(struct platform_device *pdev)
 			}
 			goto failed_irq;
 		}
-		fep->irq[i] = irq;
 	}
+#endif
 
-	fep->clk = clk_get(&pdev->dev, NULL);
+	fep->clk = clk_get(&pdev->dev, "fec_clk");
 	if (IS_ERR(fep->clk)) {
 		ret = PTR_ERR(fep->clk);
 		goto failed_clk;
 	}
+	clk_enable(fep->clk);
 
-#ifdef CONFIG_FEC_PTP
-	fep->clk_ptp = clk_get(&pdev->dev, "ptp");
-	if (IS_ERR(fep->clk_ptp)) {
-		ret = PTR_ERR(fep->clk_ptp);
-		goto failed_clk;
-	}
-#endif
-	clk_prepare_enable(fep->clk);
-#ifdef CONFIG_FEC_PTP
-	clk_prepare_enable(fep->clk_ptp);
-#endif
 	ret = fec_enet_init(ndev);
 	if (ret)
 		goto failed_init;
@@ -1652,34 +1868,47 @@ fec_probe(struct platform_device *pdev)
 	if (ret)
 		goto failed_mii_init;
 
+	if (fec_ptp_malloc_priv(&(fep->ptp_priv))) {
+		if (fep->ptp_priv) {
+			fep->ptp_priv->hwp = fep->hwp;
+			ret = fec_ptp_init(fep->ptp_priv, pdev->id);
+			if (ret)
+				printk(KERN_WARNING "IEEE1588: ptp-timer is unavailable\n");
+			else
+				fep->ptimer_present = 1;
+		} else
+			printk(KERN_ERR "IEEE1588: failed to malloc memory\n");
+	}
+
 	/* Carrier starts down, phylib will bring it up */
 	netif_carrier_off(ndev);
+	clk_disable(fep->clk);
 
 	ret = register_netdev(ndev);
 	if (ret)
 		goto failed_register;
 
-#ifdef CONFIG_FEC_PTP
-	fec_ptp_init(ndev, pdev);
-#endif
-
 	return 0;
 
 failed_register:
 	fec_enet_mii_remove(fep);
+	if (fep->ptimer_present)
+		fec_ptp_cleanup(fep->ptp_priv);
+	kfree(fep->ptp_priv);
 failed_mii_init:
 failed_init:
-	clk_disable_unprepare(fep->clk);
-#ifdef CONFIG_FEC_PTP
-	clk_disable_unprepare(fep->clk_ptp);
-#endif
+	clk_disable(fep->clk);
 	clk_put(fep->clk);
 failed_clk:
-	for (i = 0; i < FEC_IRQ_NUM; i++) {
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	free_irq(irq, ndev);
+#else
+	for (i = 0; i < 3; i++) {
 		irq = platform_get_irq(pdev, i);
 		if (irq > 0)
 			free_irq(irq, ndev);
 	}
+#endif
 failed_irq:
 	iounmap(fep->hwp);
 failed_ioremap:
@@ -1696,24 +1925,16 @@ fec_drv_remove(struct platform_device *pdev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	struct resource *r;
-	int i;
 
-	unregister_netdev(ndev);
+	fec_stop(ndev);
 	fec_enet_mii_remove(fep);
-	for (i = 0; i < FEC_IRQ_NUM; i++) {
-		int irq = platform_get_irq(pdev, i);
-		if (irq > 0)
-			free_irq(irq, ndev);
-	}
-	clk_disable_unprepare(fep->clk);
+	clk_disable(fep->clk);
 	clk_put(fep->clk);
-#ifdef CONFIG_FEC_PTP
-	del_timer_sync(&fep->time_keep);
-	clk_disable_unprepare(fep->clk_ptp);
-	if (fep->ptp_clock)
-		ptp_clock_unregister(fep->ptp_clock);
-#endif
-	iounmap(fep->hwp);
+	iounmap((void __iomem *)ndev->base_addr);
+	if (fep->ptimer_present)
+		fec_ptp_cleanup(fep->ptp_priv);
+	kfree(fep->ptp_priv);
+	unregister_netdev(ndev);
 	free_netdev(ndev);
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1733,10 +1954,10 @@ fec_suspend(struct device *dev)
 	struct fec_enet_private *fep = netdev_priv(ndev);
 
 	if (netif_running(ndev)) {
-		fec_stop(ndev);
 		netif_device_detach(ndev);
+		fec_stop(ndev);
+		clk_disable(fep->clk);
 	}
-	clk_disable_unprepare(fep->clk);
 
 	return 0;
 }
@@ -1747,8 +1968,8 @@ fec_resume(struct device *dev)
 	struct net_device *ndev = dev_get_drvdata(dev);
 	struct fec_enet_private *fep = netdev_priv(ndev);
 
-	clk_prepare_enable(fep->clk);
 	if (netif_running(ndev)) {
+		clk_enable(fep->clk);
 		fec_restart(ndev, fep->full_duplex);
 		netif_device_attach(ndev);
 	}
@@ -1773,13 +1994,52 @@ static struct platform_driver fec_driver = {
 #ifdef CONFIG_PM
 		.pm	= &fec_pm_ops,
 #endif
-		.of_match_table = fec_dt_ids,
 	},
 	.id_table = fec_devtype,
 	.probe	= fec_probe,
 	.remove	= __devexit_p(fec_drv_remove),
 };
 
-module_platform_driver(fec_driver);
+static int fec_mac_addr_setup(char *mac_addr)
+{
+	char *ptr, *p = mac_addr;
+	unsigned long tmp;
+	int i = 0, ret = 0;
+
+	while (p && (*p) && i < 6) {
+		ptr = strchr(p, ':');
+		if (ptr)
+			*ptr++ = '\0';
+
+		if (strlen(p)) {
+			ret = strict_strtoul(p, 16, &tmp);
+			if (ret < 0 || tmp > 0xff)
+				break;
+			macaddr[i++] = tmp;
+		}
+		p = ptr;
+	}
+
+	return 0;
+}
+
+__setup("fec_mac=", fec_mac_addr_setup);
+
+static int __init
+fec_enet_module_init(void)
+{
+	printk(KERN_INFO "FEC Ethernet Driver\n");
+
+	return platform_driver_register(&fec_driver);
+}
+
+static void __exit
+fec_enet_cleanup(void)
+{
+	platform_driver_unregister(&fec_driver);
+}
+
+module_exit(fec_enet_cleanup);
+module_init(fec_enet_module_init);
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index 3a46001..0c26c6c 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -13,15 +13,10 @@
 #define	FEC_H
 /****************************************************************************/
 
-#ifdef CONFIG_FEC_PTP
-#include <linux/clocksource.h>
-#include <linux/net_tstamp.h>
-#include <linux/ptp_clock_kernel.h>
-#endif
-
 #if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
     defined(CONFIG_M520x) || defined(CONFIG_M532x) || \
-    defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28)
+    defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28) || \
+    defined(CONFIG_ARCH_MX6)
 /*
  *	Just figures, Motorola would have to change the offsets for
  *	registers in the same peripheral device on different models
@@ -50,13 +45,23 @@
 #define FEC_R_DES_START		0x180 /* Receive descriptor ring */
 #define FEC_X_DES_START		0x184 /* Transmit descriptor ring */
 #define FEC_R_BUFF_SIZE		0x188 /* Maximum receive buff size */
+#define FEC_R_FIFO_RSFL		0x190 /* Receive FIFO section full threshold */
+#define FEC_R_FIFO_RSEM		0x194 /* Receive FIFO section empty threshold */
+#define FEC_R_FIFO_RAEM		0x198 /* Receive FIFO almost empty threshold */
+#define FEC_R_FIFO_RAFL		0x19c /* Receive FIFO almost full threshold */
 #define FEC_MIIGSK_CFGR		0x300 /* MIIGSK Configuration reg */
 #define FEC_MIIGSK_ENR		0x308 /* MIIGSK Enable reg */
 
-#define BM_MIIGSK_CFGR_MII		0x00
-#define BM_MIIGSK_CFGR_RMII		0x01
-#define BM_MIIGSK_CFGR_FRCONT_10M	0x40
-
+/* Define the FEC 1588 registers offset */
+#if defined(CONFIG_SOC_IMX28) || defined(CONFIG_ARCH_MX6)
+#define FEC_ATIME_CTRL		0x400
+#define FEC_ATIME		0x404
+#define FEC_ATIME_EVT_OFFSET	0x408
+#define FEC_ATIME_EVT_PERIOD	0x40c
+#define FEC_ATIME_CORR		0x410
+#define FEC_ATIME_INC		0x414
+#define FEC_TS_TIMESTAMP	0x418
+#endif
 #else
 
 #define FEC_ECNTRL		0x000 /* Ethernet control reg */
@@ -86,15 +91,21 @@
 #endif /* CONFIG_M5272 */
 
 
+#if (defined(CONFIG_SOC_IMX28) || defined(CONFIG_ARCH_MX6)) \
+				&& defined(CONFIG_FEC_1588)
+#define CONFIG_ENHANCED_BD
+#endif
+
 /*
  *	Define the buffer descriptor structure.
  */
-#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28)
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_SOC_IMX28) || \
+				defined(CONFIG_ARCH_MX6)
 struct bufdesc {
 	unsigned short cbd_datlen;	/* Data length */
 	unsigned short cbd_sc;	/* Control and status info */
 	unsigned long cbd_bufaddr;	/* Buffer address */
-#ifdef CONFIG_FEC_PTP
+#ifdef CONFIG_ENHANCED_BD
 	unsigned long cbd_esc;
 	unsigned long cbd_prot;
 	unsigned long cbd_bdu;
@@ -143,6 +154,9 @@ struct bufdesc {
 #define BD_ENET_RX_CL           ((ushort)0x0001)
 #define BD_ENET_RX_STATS        ((ushort)0x013f)        /* All status bits */
 
+#define BD_ENET_RX_INT          0x00800000
+#define BD_ENET_RX_PTP          ((ushort)0x0400)
+
 /* Buffer descriptor control/status used by Ethernet transmit.
 */
 #define BD_ENET_TX_READY        ((ushort)0x8000)
@@ -160,111 +174,8 @@ struct bufdesc {
 #define BD_ENET_TX_CSL          ((ushort)0x0001)
 #define BD_ENET_TX_STATS        ((ushort)0x03ff)        /* All status bits */
 
-/*enhanced buffer desciptor control/status used by Ethernet transmit*/
 #define BD_ENET_TX_INT          0x40000000
-#define BD_ENET_TX_TS           0x20000000
-
-
-/* This device has up to three irqs on some platforms */
-#define FEC_IRQ_NUM		3
-
-/* The number of Tx and Rx buffers.  These are allocated from the page
- * pool.  The code may assume these are power of two, so it it best
- * to keep them that size.
- * We don't need to allocate pages for the transmitter.  We just use
- * the skbuffer directly.
- */
-
-#define FEC_ENET_RX_PAGES	8
-#define FEC_ENET_RX_FRSIZE	2048
-#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
-#define FEC_ENET_TX_FRSIZE	2048
-#define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
-#define TX_RING_SIZE		16	/* Must be power of two */
-#define TX_RING_MOD_MASK	15	/*   for this to work */
-
-#define BD_ENET_RX_INT          0x00800000
-#define BD_ENET_RX_PTP          ((ushort)0x0400)
-
-/* The FEC buffer descriptors track the ring buffers.  The rx_bd_base and
- * tx_bd_base always point to the base of the buffer descriptors.  The
- * cur_rx and cur_tx point to the currently available buffer.
- * The dirty_tx tracks the current buffer that is being sent by the
- * controller.  The cur_tx and dirty_tx are equal under both completely
- * empty and completely full conditions.  The empty/ready indicator in
- * the buffer descriptor determines the actual condition.
- */
-struct fec_enet_private {
-	/* Hardware registers of the FEC device */
-	void __iomem *hwp;
-
-	struct net_device *netdev;
-
-	struct clk *clk;
-
-#ifdef CONFIG_FEC_PTP
-	struct clk *clk_ptp;
-#endif
-	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
-	unsigned char *tx_bounce[TX_RING_SIZE];
-	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
-	struct	sk_buff* rx_skbuff[RX_RING_SIZE];
-	ushort	skb_cur;
-	ushort	skb_dirty;
-
-	/* CPM dual port RAM relative addresses */
-	dma_addr_t	bd_dma;
-	/* Address of Rx and Tx buffers */
-	struct bufdesc	*rx_bd_base;
-	struct bufdesc	*tx_bd_base;
-	/* The next free ring entry */
-	struct bufdesc	*cur_rx, *cur_tx;
-	/* The ring entries to be free()ed */
-	struct bufdesc	*dirty_tx;
-
-	uint	tx_full;
-	/* hold while accessing the HW like ringbuffer for tx/rx but not MAC */
-	spinlock_t hw_lock;
-
-	struct	platform_device *pdev;
-
-	int	opened;
-	int	dev_id;
-
-	/* Phylib and MDIO interface */
-	struct	mii_bus *mii_bus;
-	struct	phy_device *phy_dev;
-	int	mii_timeout;
-	uint	phy_speed;
-	phy_interface_t	phy_interface;
-	int	link;
-	int	full_duplex;
-	struct	completion mdio_done;
-	int	irq[FEC_IRQ_NUM];
-
-#ifdef CONFIG_FEC_PTP
-	struct ptp_clock *ptp_clock;
-	struct ptp_clock_info ptp_caps;
-	unsigned long last_overflow_check;
-	spinlock_t tmreg_lock;
-	struct cyclecounter cc;
-	struct timecounter tc;
-	int rx_hwtstamp_filter;
-	u32 base_incval;
-	u32 cycle_speed;
-	int hwts_rx_en;
-	int hwts_tx_en;
-	struct timer_list time_keep;
-#endif
-
-};
-
-#ifdef CONFIG_FEC_PTP
-void fec_ptp_init(struct net_device *ndev, struct platform_device *pdev);
-void fec_ptp_start_cyclecounter(struct net_device *ndev);
-int fec_ptp_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd);
-#endif
+#define BD_ENET_TX_PTP          ((ushort)0x0100)
 
 /****************************************************************************/
 #endif /* FEC_H */
diff --git a/drivers/net/ethernet/freescale/fec_1588.c b/drivers/net/ethernet/freescale/fec_1588.c
new file mode 100644
index 0000000..74fa168
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fec_1588.c
@@ -0,0 +1,659 @@
+/*
+ * drivers/net/fec_1588.c
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2009 IXXAT Automation, GmbH
+ *
+ * FEC Ethernet Driver -- IEEE 1588 interface functionality
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include "fec.h"
+#include "fec_1588.h"
+
+#if defined(CONFIG_ARCH_MX28)
+static struct fec_ptp_private *ptp_private[2];
+#elif defined(CONFIG_ARCH_MX6)
+static struct fec_ptp_private *ptp_private[1];
+#endif
+
+/* Alloc the ring resource */
+static int fec_ptp_init_circ(struct fec_ptp_circular *buf, int size)
+{
+	buf->data_buf = (struct fec_ptp_ts_data *)
+		vmalloc(size * sizeof(struct fec_ptp_ts_data));
+
+	if (!buf->data_buf)
+		return 1;
+	buf->front = 0;
+	buf->end = 0;
+	buf->size = size;
+	return 0;
+}
+
+static inline int fec_ptp_calc_index(int size, int curr_index, int offset)
+{
+	return (curr_index + offset) % size;
+}
+
+static int fec_ptp_is_empty(struct fec_ptp_circular *buf)
+{
+	return (buf->front == buf->end);
+}
+
+static int fec_ptp_nelems(struct fec_ptp_circular *buf)
+{
+	const int front = buf->front;
+	const int end = buf->end;
+	const int size = buf->size;
+	int n_items;
+
+	if (end > front)
+		n_items = end - front;
+	else if (end < front)
+		n_items = size - (front - end);
+	else
+		n_items = 0;
+
+	return n_items;
+}
+
+static int fec_ptp_is_full(struct fec_ptp_circular *buf)
+{
+	if (fec_ptp_nelems(buf) == (buf->size - 1))
+		return 1;
+	else
+		return 0;
+}
+
+static int fec_ptp_insert(struct fec_ptp_circular *ptp_buf,
+			  struct fec_ptp_ts_data *data)
+
+{
+	struct fec_ptp_ts_data *tmp;
+
+	if (fec_ptp_is_full(ptp_buf))
+		ptp_buf->end = fec_ptp_calc_index(ptp_buf->size,
+						ptp_buf->end, 1);
+
+	tmp = (ptp_buf->data_buf + ptp_buf->end);
+	memcpy(tmp, data, sizeof(struct fec_ptp_ts_data));
+	ptp_buf->end = fec_ptp_calc_index(ptp_buf->size, ptp_buf->end, 1);
+
+	return 0;
+}
+
+static int fec_ptp_find_and_remove(struct fec_ptp_circular *ptp_buf,
+			struct fec_ptp_ident *ident, struct ptp_time *ts)
+{
+	int i;
+	int size = ptp_buf->size, end = ptp_buf->end;
+	struct fec_ptp_ident *tmp_ident;
+
+	if (fec_ptp_is_empty(ptp_buf))
+		return 1;
+
+	i = ptp_buf->front;
+	while (i != end) {
+		tmp_ident = &(ptp_buf->data_buf + i)->ident;
+		if (tmp_ident->version == ident->version) {
+			if (tmp_ident->message_type == ident->message_type) {
+				if ((tmp_ident->netw_prot == ident->netw_prot)
+				|| (ident->netw_prot ==
+					FEC_PTP_PROT_DONTCARE)) {
+					if (tmp_ident->seq_id ==
+							ident->seq_id) {
+						int ret =
+						memcmp(tmp_ident->spid,
+							ident->spid,
+							PTP_SOURCE_PORT_LENGTH);
+						if (0 == ret)
+							break;
+					}
+				}
+			}
+		}
+		/* get next */
+		i = fec_ptp_calc_index(size, i, 1);
+	}
+
+	/* not found ? */
+	if (i == end) {
+		/* buffer full ? */
+		if (fec_ptp_is_full(ptp_buf))
+			/* drop one in front */
+			ptp_buf->front =
+			fec_ptp_calc_index(size, ptp_buf->front, 1);
+
+		return 1;
+	}
+	*ts = (ptp_buf->data_buf + i)->ts;
+
+	return 0;
+}
+
+/* 1588 Module intialization */
+int fec_ptp_start(struct fec_ptp_private *priv)
+{
+	struct fec_ptp_private *fpp = priv;
+
+	/* Select 1588 Timer source and enable module for starting Tmr Clock *
+	 * When enable both FEC0 and FEC1 1588 Timer in the same time,       *
+	 * enable FEC1 timer's slave mode. */
+	if ((fpp == ptp_private[0]) || !(ptp_private[0]->ptp_active)) {
+		writel(FEC_T_CTRL_RESTART, fpp->hwp + FEC_ATIME_CTRL);
+		writel(FEC_T_INC_CLK << FEC_T_INC_OFFSET,
+				fpp->hwp + FEC_ATIME_INC);
+		writel(FEC_T_PERIOD_ONE_SEC, fpp->hwp + FEC_ATIME_EVT_PERIOD);
+		/* start counter */
+		writel(FEC_T_CTRL_PERIOD_RST | FEC_T_CTRL_ENABLE,
+				fpp->hwp + FEC_ATIME_CTRL);
+		fpp->ptp_slave = 0;
+		fpp->ptp_active = 1;
+
+		#if defined(CONFIG_ARCH_MX28)
+		/* if the FEC1 timer was enabled, set it to slave mode */
+		if ((fpp == ptp_private[0]) && (ptp_private[1]->ptp_active)) {
+			writel(0, ptp_private[1]->hwp + FEC_ATIME_CTRL);
+			fpp->prtc = ptp_private[1]->prtc;
+			writel(FEC_T_CTRL_RESTART,
+					ptp_private[1]->hwp + FEC_ATIME_CTRL);
+			writel(FEC_T_INC_CLK << FEC_T_INC_OFFSET,
+					ptp_private[1]->hwp + FEC_ATIME_INC);
+			/* Set the timer as slave mode */
+			writel(FEC_T_CTRL_SLAVE,
+					ptp_private[1]->hwp + FEC_ATIME_CTRL);
+			ptp_private[1]->ptp_slave = 1;
+			ptp_private[1]->ptp_active = 1;
+		}
+		#endif
+	} else {
+		writel(FEC_T_INC_CLK << FEC_T_INC_OFFSET,
+				fpp->hwp + FEC_ATIME_INC);
+		/* Set the timer as slave mode */
+		writel(FEC_T_CTRL_SLAVE, fpp->hwp + FEC_ATIME_CTRL);
+		fpp->ptp_slave = 1;
+		fpp->ptp_active = 1;
+	}
+
+	return 0;
+}
+
+/* Cleanup routine for 1588 module.
+ * When PTP is disabled this routing is called */
+void fec_ptp_stop(struct fec_ptp_private *priv)
+{
+	struct fec_ptp_private *fpp = priv;
+
+	writel(0, fpp->hwp + FEC_ATIME_CTRL);
+	writel(FEC_T_CTRL_RESTART, fpp->hwp + FEC_ATIME_CTRL);
+	priv->ptp_active = 0;
+	priv->ptp_slave = 0;
+}
+
+static void fec_get_curr_cnt(struct fec_ptp_private *priv,
+			struct ptp_rtc_time *curr_time)
+{
+	u32 tempval;
+	struct fec_ptp_private *tmp_priv;
+
+	if (!priv->ptp_slave)
+		tmp_priv = priv;
+	else
+		tmp_priv = ptp_private[0];
+
+	tempval = readl(priv->hwp + FEC_ATIME_CTRL);
+	tempval |= FEC_T_CTRL_CAPTURE;
+
+	writel(tempval, priv->hwp + FEC_ATIME_CTRL);
+	writel(tempval, priv->hwp + FEC_ATIME_CTRL);
+	curr_time->rtc_time.nsec = readl(priv->hwp + FEC_ATIME);
+	curr_time->rtc_time.sec = tmp_priv->prtc;
+
+	writel(tempval, priv->hwp + FEC_ATIME_CTRL);
+	tempval = readl(priv->hwp + FEC_ATIME);
+
+	if (tempval < curr_time->rtc_time.nsec) {
+		curr_time->rtc_time.nsec = tempval;
+		curr_time->rtc_time.sec = tmp_priv->prtc;
+	}
+}
+
+/* Set the 1588 timer counter registers */
+static void fec_set_1588cnt(struct fec_ptp_private *priv,
+			struct ptp_rtc_time *fec_time)
+{
+	u32 tempval;
+	unsigned long flags;
+	struct fec_ptp_private *tmp_priv;
+
+	if (!priv->ptp_slave)
+		tmp_priv = priv;
+	else
+		tmp_priv = ptp_private[0];
+
+	spin_lock_irqsave(&priv->cnt_lock, flags);
+	tmp_priv->prtc = fec_time->rtc_time.sec;
+
+	tempval = fec_time->rtc_time.nsec;
+	writel(tempval, tmp_priv->hwp + FEC_ATIME);
+	spin_unlock_irqrestore(&priv->cnt_lock, flags);
+}
+
+/**
+ * Parse packets if they are PTP.
+ * The PTP header can be found in an IPv4, IPv6 or in an IEEE802.3
+ * ethernet frame. The function returns the position of the PTP packet
+ * or NULL, if no PTP found
+ */
+u8 *fec_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
+{
+	u8 *position = skb->data + ETH_ALEN + ETH_ALEN;
+	u8 *ptp_loc = NULL;
+
+	*eth_type = *((u16 *)position);
+	/* Check if outer vlan tag is here */
+	if (*eth_type == ETH_P_8021Q) {
+		position += FEC_VLAN_TAG_LEN;
+		*eth_type = *((u16 *)position);
+	}
+
+	/* set position after ethertype */
+	position += FEC_ETHTYPE_LEN;
+	if (ETH_P_1588 == *eth_type) {
+		ptp_loc = position;
+		/* IEEE1588 event message which needs timestamping */
+		if ((ptp_loc[0] & 0xF) <= 3) {
+			if (skb->len >=
+			((ptp_loc - skb->data) + PTP_HEADER_SZE))
+				return ptp_loc;
+		}
+	} else if (ETH_P_IP == ntohs(*eth_type)) {
+		u8 *ip_header, *prot, *udp_header;
+		u8 ip_version, ip_hlen;
+		ip_header = position;
+		ip_version = ip_header[0] >> 4; /* correct IP version? */
+		if (0x04 == ip_version) { /* IPv4 */
+			prot = ip_header + 9; /* protocol */
+			if (FEC_PACKET_TYPE_UDP == *prot) {
+				u16 udp_dstPort;
+				/* retrieve the size of the ip-header
+				 * with the first byte of the ip-header:
+				 * version ( 4 bits) + Internet header
+				 * length (4 bits)
+				 */
+				ip_hlen   = (*ip_header & 0xf) * 4;
+				udp_header = ip_header + ip_hlen;
+				udp_dstPort = *((u16 *)(udp_header + 2));
+				/* check the destination port address
+				 * ( 319 (0x013F) = PTP event port )
+				 */
+				if (ntohs(udp_dstPort) == PTP_EVENT_PORT) {
+					ptp_loc = udp_header + 8;
+					/* long enough ? */
+					if (skb->len >= ((ptp_loc - skb->data)
+							+ PTP_HEADER_SZE))
+						return ptp_loc;
+				}
+			}
+		}
+	} else if (ETH_P_IPV6 == ntohs(*eth_type)) {
+		u8 *ip_header, *udp_header, *prot;
+		u8 ip_version;
+		ip_header = position;
+		ip_version = ip_header[0] >> 4;
+		if (0x06 == ip_version) {
+			prot = ip_header + 6;
+			if (FEC_PACKET_TYPE_UDP == *prot) {
+				u16 udp_dstPort;
+				udp_header = ip_header + 40;
+				udp_dstPort = *((u16 *)(udp_header + 2));
+				/* check the destination port address
+				 * ( 319 (0x013F) = PTP event port )
+				 */
+				if (ntohs(udp_dstPort) == PTP_EVENT_PORT) {
+					ptp_loc = udp_header + 8;
+					/* long enough ? */
+					if (skb->len >= ((ptp_loc - skb->data)
+							+ PTP_HEADER_SZE))
+						return ptp_loc;
+				}
+			}
+		}
+	}
+
+	return NULL; /* no PTP frame */
+}
+
+/* Set the BD to ptp */
+int fec_ptp_do_txstamp(struct sk_buff *skb)
+{
+	u8 *ptp_loc;
+	u16 eth_type;
+
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL)
+		return 1;
+
+	return 0;
+}
+
+void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
+			   struct sk_buff *skb,
+			   struct bufdesc *bdp)
+{
+	struct fec_ptp_ts_data tmp_tx_time;
+	struct fec_ptp_private *fpp;
+	u8 *ptp_loc;
+	u16 eth_type;
+
+	if (!priv->ptp_slave)
+		fpp = priv;
+	else
+		fpp = ptp_private[0];
+
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL) {
+		/* store identification data */
+		switch (ntohs(eth_type)) {
+		case ETH_P_IP:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_IPV4;
+			break;
+		case ETH_P_IPV6:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_IPV6;
+			break;
+		case ETH_P_1588:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_802_3;
+			break;
+		default:
+			return;
+		}
+		tmp_tx_time.ident.version = (*(ptp_loc + 1)) & 0X0F;
+		tmp_tx_time.ident.message_type = (*(ptp_loc)) & 0x0F;
+		tmp_tx_time.ident.seq_id =
+			ntohs(*((u16 *)(ptp_loc + PTP_HEADER_SEQ_OFFS)));
+		memcpy(tmp_tx_time.ident.spid, &ptp_loc[PTP_SPID_OFFS],
+						PTP_SOURCE_PORT_LENGTH);
+		/* store tx timestamp */
+		tmp_tx_time.ts.sec = fpp->prtc;
+		tmp_tx_time.ts.nsec = bdp->ts;
+		/* insert timestamp in circular buffer */
+		fec_ptp_insert(&(priv->tx_timestamps), &tmp_tx_time);
+	}
+}
+
+void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
+			   struct sk_buff *skb,
+			   struct bufdesc *bdp)
+{
+	struct fec_ptp_ts_data tmp_rx_time;
+	struct fec_ptp_private *fpp;
+	u8 *ptp_loc;
+	u16 eth_type;
+
+	if (!priv->ptp_slave)
+		fpp = priv;
+	else
+		fpp = ptp_private[0];
+
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL) {
+		/* store identification data */
+		tmp_rx_time.ident.version = (*(ptp_loc + 1)) & 0X0F;
+		tmp_rx_time.ident.message_type = (*(ptp_loc)) & 0x0F;
+		switch (ntohs(eth_type)) {
+		case ETH_P_IP:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_IPV4;
+			break;
+		case ETH_P_IPV6:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_IPV6;
+			break;
+		case ETH_P_1588:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_802_3;
+			break;
+		default:
+			return;
+		}
+		tmp_rx_time.ident.seq_id =
+			ntohs(*((u16 *)(ptp_loc + PTP_HEADER_SEQ_OFFS)));
+		memcpy(tmp_rx_time.ident.spid, &ptp_loc[PTP_SPID_OFFS],
+						PTP_SOURCE_PORT_LENGTH);
+		/* store rx timestamp */
+		tmp_rx_time.ts.sec = fpp->prtc;
+		tmp_rx_time.ts.nsec = bdp->ts;
+
+		/* insert timestamp in circular buffer */
+		fec_ptp_insert(&(fpp->rx_timestamps), &tmp_rx_time);
+	}
+}
+
+static uint8_t fec_get_tx_timestamp(struct fec_ptp_private *priv,
+				    struct fec_ptp_ts_data *pts,
+				    struct ptp_time *tx_time)
+{
+	int ret = 0;
+
+	ret = fec_ptp_find_and_remove(&(priv->tx_timestamps),
+					&pts->ident, tx_time);
+
+	return ret;
+}
+
+static uint8_t fec_get_rx_timestamp(struct fec_ptp_private *priv,
+				    struct fec_ptp_ts_data *pts,
+				    struct ptp_time *rx_time)
+{
+	int ret = 0;
+
+	ret = fec_ptp_find_and_remove(&(priv->rx_timestamps),
+					&pts->ident, rx_time);
+
+	return ret;
+}
+
+static void fec_handle_ptpdrift(struct ptp_set_comp *comp,
+				struct ptp_time_correct *ptc)
+{
+	u32 ndrift;
+	u32 i, adj_inc, adj_period;
+	u32 tmp_current, tmp_winner;
+
+	ndrift = comp->drift;
+
+	if (ndrift == 0) {
+		ptc->corr_inc = 0;
+		ptc->corr_period = 0;
+		return;
+	} else if (ndrift >= FEC_ATIME_CLK) {
+		ptc->corr_inc = (u32)(ndrift / FEC_ATIME_CLK);
+		ptc->corr_period = 1;
+		return;
+	} else {
+		tmp_winner = 0xFFFFFFFF;
+		adj_inc = 1;
+
+		if (ndrift > (FEC_ATIME_CLK / FEC_T_INC_CLK)) {
+			adj_inc = FEC_T_INC_CLK / FEC_PTP_SPINNER_2;
+		} else if (ndrift > (FEC_ATIME_CLK /
+			(FEC_T_INC_CLK * FEC_PTP_SPINNER_4))) {
+			adj_inc = FEC_T_INC_CLK / FEC_PTP_SPINNER_4;
+			adj_period = FEC_PTP_SPINNER_2;
+		} else {
+			adj_inc = FEC_PTP_SPINNER_4;
+			adj_period = FEC_PTP_SPINNER_4;
+		}
+
+		for (i = 1; i < adj_inc; i++) {
+			tmp_current = (FEC_ATIME_CLK * i) % ndrift;
+			if (tmp_current == 0) {
+				ptc->corr_inc = i;
+				ptc->corr_period = (u32)((FEC_ATIME_CLK *
+						adj_period * i)	/ ndrift);
+				break;
+			} else if (tmp_current < tmp_winner) {
+				ptc->corr_inc = i;
+				ptc->corr_period = (u32)((FEC_ATIME_CLK *
+						adj_period * i)	/ ndrift);
+				tmp_winner = tmp_current;
+			}
+		}
+	}
+}
+
+static void fec_set_drift(struct fec_ptp_private *priv,
+			  struct ptp_set_comp *comp)
+{
+	struct ptp_time_correct	tc;
+	struct fec_ptp_private *fpp;
+	u32 tmp, corr_ns;
+
+	memset(&tc, 0, sizeof(struct ptp_time_correct));
+	fec_handle_ptpdrift(comp, &tc);
+	if (tc.corr_inc == 0)
+		return;
+
+	if (comp->o_ops == TRUE)
+		corr_ns = FEC_T_INC_CLK + tc.corr_inc;
+	else
+		corr_ns = FEC_T_INC_CLK - tc.corr_inc;
+
+	if (!priv->ptp_slave)
+		fpp = priv;
+	else
+		fpp = ptp_private[0];
+
+	tmp = readl(fpp->hwp + FEC_ATIME_INC) & FEC_T_INC_MASK;
+	tmp |= corr_ns << FEC_T_INC_CORR_OFFSET;
+	writel(tmp, fpp->hwp + FEC_ATIME_INC);
+	writel(tc.corr_period, fpp->hwp + FEC_ATIME_CORR);
+}
+
+int fec_ptp_ioctl(struct fec_ptp_private *priv, struct ifreq *ifr, int cmd)
+{
+	struct ptp_rtc_time curr_time;
+	struct ptp_time rx_time, tx_time;
+	struct fec_ptp_ts_data p_ts;
+	struct fec_ptp_ts_data *p_ts_user;
+	struct ptp_set_comp p_comp;
+	u32 freq_compensation;
+	int retval = 0;
+
+	switch (cmd) {
+	case PTP_ENBL_TXTS_IOCTL:
+	case PTP_DSBL_TXTS_IOCTL:
+	case PTP_ENBL_RXTS_IOCTL:
+	case PTP_DSBL_RXTS_IOCTL:
+		break;
+	case PTP_GET_RX_TIMESTAMP:
+		p_ts_user = (struct fec_ptp_ts_data *)ifr->ifr_data;
+		if (0 != copy_from_user(&p_ts.ident,
+			&p_ts_user->ident, sizeof(p_ts.ident)))
+			return -EINVAL;
+		if (fec_get_rx_timestamp(priv, &p_ts, &rx_time) != 0)
+			return -EAGAIN;
+		if (copy_to_user((void __user *)(&p_ts_user->ts),
+			&rx_time, sizeof(rx_time)))
+			return -EFAULT;
+		break;
+	case PTP_GET_TX_TIMESTAMP:
+		p_ts_user = (struct fec_ptp_ts_data *)ifr->ifr_data;
+		if (0 != copy_from_user(&p_ts.ident,
+			&p_ts_user->ident, sizeof(p_ts.ident)))
+			return -EINVAL;
+		retval = fec_get_tx_timestamp(priv, &p_ts, &tx_time);
+		if (retval == 0 &&
+			copy_to_user((void __user *)(&p_ts_user->ts),
+				&tx_time, sizeof(tx_time)))
+			retval = -EFAULT;
+		break;
+	case PTP_GET_CURRENT_TIME:
+		fec_get_curr_cnt(priv, &curr_time);
+		if (0 != copy_to_user(ifr->ifr_data,
+					&(curr_time.rtc_time),
+					sizeof(struct ptp_time)))
+			return -EFAULT;
+		break;
+	case PTP_SET_RTC_TIME:
+		if (0 != copy_from_user(&(curr_time.rtc_time),
+					ifr->ifr_data,
+					sizeof(struct ptp_time)))
+			return -EINVAL;
+		fec_set_1588cnt(priv, &curr_time);
+		break;
+	case PTP_FLUSH_TIMESTAMP:
+		/* reset tx-timestamping buffer */
+		priv->tx_timestamps.front = 0;
+		priv->tx_timestamps.end = 0;
+		priv->tx_timestamps.size = (DEFAULT_PTP_TX_BUF_SZ + 1);
+		/* reset rx-timestamping buffer */
+		priv->rx_timestamps.front = 0;
+		priv->rx_timestamps.end = 0;
+		priv->rx_timestamps.size = (DEFAULT_PTP_RX_BUF_SZ + 1);
+		break;
+	case PTP_SET_COMPENSATION:
+		if (0 != copy_from_user(&p_comp, ifr->ifr_data,
+			sizeof(struct ptp_set_comp)))
+			return -EINVAL;
+		fec_set_drift(priv, &p_comp);
+		break;
+	case PTP_GET_ORIG_COMP:
+		freq_compensation = FEC_PTP_ORIG_COMP;
+		if (copy_to_user(ifr->ifr_data, &freq_compensation,
+					sizeof(freq_compensation)) > 0)
+			return -EFAULT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * Resource required for accessing 1588 Timer Registers.
+ */
+int fec_ptp_init(struct fec_ptp_private *priv, int id)
+{
+	/* initialize circular buffer for tx timestamps */
+	if (fec_ptp_init_circ(&(priv->tx_timestamps),
+			(DEFAULT_PTP_TX_BUF_SZ+1)))
+		return 1;
+	/* initialize circular buffer for rx timestamps */
+	if (fec_ptp_init_circ(&(priv->rx_timestamps),
+			(DEFAULT_PTP_RX_BUF_SZ+1)))
+		return 1;
+
+	spin_lock_init(&priv->cnt_lock);
+	ptp_private[id] = priv;
+	priv->dev_id = id;
+	return 0;
+}
+EXPORT_SYMBOL(fec_ptp_init);
+
+void fec_ptp_cleanup(struct fec_ptp_private *priv)
+{
+	if (priv->tx_timestamps.data_buf)
+		vfree(priv->tx_timestamps.data_buf);
+	if (priv->rx_timestamps.data_buf)
+		vfree(priv->rx_timestamps.data_buf);
+}
+EXPORT_SYMBOL(fec_ptp_cleanup);
diff --git a/drivers/net/ethernet/freescale/fec_1588.h b/drivers/net/ethernet/freescale/fec_1588.h
new file mode 100644
index 0000000..9daf9de
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fec_1588.h
@@ -0,0 +1,227 @@
+/*
+ * drivers/net/fec_1588.h
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef FEC_1588_H
+#define FEC_1588_H
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/circ_buf.h>
+
+#define FALSE			0
+#define TRUE			1
+
+/* FEC 1588 register bits */
+#define FEC_T_CTRL_SLAVE		0x00002000
+#define FEC_T_CTRL_CAPTURE		0x00000800
+#define FEC_T_CTRL_RESTART		0x00000200
+#define FEC_T_CTRL_PERIOD_RST		0x00000030
+#define FEC_T_CTRL_ENABLE		0x00000001
+
+#define FEC_T_INC_MASK			0x0000007f
+#define FEC_T_INC_OFFSET		0
+#define FEC_T_INC_CORR_MASK		0x00007f00
+#define FEC_T_INC_CORR_OFFSET		8
+
+#define FEC_T_INC_50MHZ			20
+#define FEC_ATIME_50MHZ			50000000
+#define FEC_T_INC_CLK			FEC_T_INC_50MHZ
+#define FEC_ATIME_CLK			FEC_ATIME_50MHZ
+
+#define FEC_T_PERIOD_ONE_SEC		0x3B9ACA00
+
+/* IEEE 1588 definition */
+#define FEC_ECNTRL_TS_EN	0x10
+
+#define DEFAULT_PTP_RX_BUF_SZ		64
+#define DEFAULT_PTP_TX_BUF_SZ		64
+
+/* 1588stack API defines */
+#define PTP_ENBL_TXTS_IOCTL	SIOCDEVPRIVATE
+#define PTP_DSBL_TXTS_IOCTL	(SIOCDEVPRIVATE + 1)
+#define PTP_ENBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 2)
+#define PTP_DSBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 3)
+#define PTP_GET_TX_TIMESTAMP	(SIOCDEVPRIVATE + 4)
+#define PTP_GET_RX_TIMESTAMP	(SIOCDEVPRIVATE + 5)
+#define PTP_SET_RTC_TIME	(SIOCDEVPRIVATE + 6)
+#define PTP_GET_CURRENT_TIME	(SIOCDEVPRIVATE + 7)
+#define PTP_SET_COMPENSATION	(SIOCDEVPRIVATE + 9)
+#define PTP_GET_ORIG_COMP	(SIOCDEVPRIVATE + 10)
+#define PTP_FLUSH_TIMESTAMP	(SIOCDEVPRIVATE + 11)
+
+/* IEEE1588 ptp head format */
+#define PTP_CTRL_OFFS		0x52
+#define PTP_SOURCE_PORT_LENGTH	10
+#define	PTP_HEADER_SEQ_OFFS	30
+#define PTP_HEADER_CTL_OFFS	32
+#define PTP_SPID_OFFS		20
+#define PTP_HEADER_SZE		34
+#define PTP_EVENT_PORT		0x013F
+
+#define FEC_VLAN_TAG_LEN	0x04
+#define FEC_ETHTYPE_LEN		0x02
+
+/* 1588-2008 network protocol enumeration values */
+#define FEC_PTP_PROT_IPV4		1
+#define FEC_PTP_PROT_IPV6		2
+#define FEC_PTP_PROT_802_3		3
+#define FEC_PTP_PROT_DONTCARE		0xFFFF
+#define FEC_PACKET_TYPE_UDP		0x11
+
+#define FEC_PTP_ORIG_COMP		0x15555555
+#define FEC_PTP_SPINNER_2		2
+#define FEC_PTP_SPINNER_4		4
+
+/* PTP standard time representation structure */
+struct ptp_time{
+	u64 sec;	/* seconds */
+	u32 nsec;	/* nanoseconds */
+};
+
+/* struct needed to identify a timestamp */
+struct fec_ptp_ident {
+	u8	version;
+	u8	message_type;
+	u16	netw_prot;
+	u16	seq_id;
+	u8	spid[10];
+};
+
+/* interface for PTP driver command GET_TX_TIME */
+struct fec_ptp_ts_data {
+	struct fec_ptp_ident ident;
+	/* PTP timestamp */
+	struct ptp_time ts;
+};
+
+/* circular buffer for ptp timestamps over ioctl */
+struct fec_ptp_circular {
+	int	front;
+	int	end;
+	int	size;
+	struct	fec_ptp_ts_data	*data_buf;
+};
+
+/* interface for PTP driver command SET_RTC_TIME/GET_CURRENT_TIME */
+struct ptp_rtc_time {
+	struct ptp_time rtc_time;
+};
+
+/* interface for PTP driver command SET_COMPENSATION */
+struct ptp_set_comp {
+	u32 drift;
+	bool o_ops;
+	u32 freq_compensation;
+};
+
+/* interface for PTP driver command GET_ORIG_COMP */
+struct ptp_get_comp {
+	/* the initial compensation value */
+	u32 dw_origcomp;
+	/* the minimum compensation value */
+	u32 dw_mincomp;
+	/*the max compensation value*/
+	u32 dw_maxcomp;
+	/*the min drift applying min compensation value in ppm*/
+	u32 dw_mindrift;
+	/*the max drift applying max compensation value in ppm*/
+	u32 dw_maxdrift;
+};
+
+struct ptp_time_correct {
+	u32 corr_period;
+	u32 corr_inc;
+};
+
+/* PTP message version */
+#define PTP_1588_MSG_VER_1	1
+#define PTP_1588_MSG_VER_2	2
+
+#define BD_ENET_TX_TS		0x20000000
+#define BD_ENET_TX_BDU		0x80000000
+
+struct fec_ptp_private {
+	void __iomem *hwp;
+	int	dev_id;
+
+	struct fec_ptp_circular tx_timestamps;
+	struct fec_ptp_circular rx_timestamps;
+	spinlock_t cnt_lock;
+
+	u64	prtc;
+	u8	ptp_active;
+	u8	ptp_slave;
+	struct circ_buf	txstamp;
+};
+
+#ifdef CONFIG_FEC_1588
+static inline int fec_ptp_malloc_priv(struct fec_ptp_private **priv)
+{
+	*priv = kzalloc(sizeof(struct fec_ptp_private), GFP_KERNEL);
+	return 1;
+}
+extern int fec_ptp_init(struct fec_ptp_private *priv, int id);
+extern void fec_ptp_cleanup(struct fec_ptp_private *priv);
+extern int fec_ptp_start(struct fec_ptp_private *priv);
+extern void fec_ptp_stop(struct fec_ptp_private *priv);
+extern int fec_ptp_do_txstamp(struct sk_buff *skb);
+extern void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
+				  struct sk_buff *skb,
+				  struct bufdesc *bdp);
+extern void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
+				  struct sk_buff *skb,
+				  struct bufdesc *bdp);
+extern int fec_ptp_ioctl(struct fec_ptp_private *priv,
+				struct ifreq *ifr, int cmd);
+#else
+static inline int fec_ptp_malloc_priv(struct fec_ptp_private **priv)
+{
+	return 0;
+}
+static inline int fec_ptp_init(struct fec_ptp_private *priv, int id)
+{
+	return 1;
+}
+static inline void fec_ptp_cleanup(struct fec_ptp_private *priv) { }
+static inline int fec_ptp_start(struct fec_ptp_private *priv)
+{
+	return 1;
+}
+static inline void fec_ptp_stop(struct fec_ptp_private *priv) {}
+static inline int fec_ptp_do_txstamp(struct sk_buff *skb)
+{
+	return 0;
+}
+static inline void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
+					 struct sk_buff *skb,
+					 struct bufdesc *bdp) {}
+static inline void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
+					 struct sk_buff *skb,
+					 struct bufdesc *bdp) {}
+static inline int fec_ptp_ioctl(struct fec_ptp_private *priv,
+				struct ifreq *ifr, int cmd)
+{
+	return 0;
+}
+
+#endif /* 1588 */
+
+#endif
diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c
index 7916184..80747d2 100644
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@ -116,7 +116,7 @@ static int ks8051_config_init(struct phy_device *phydev)
 
 static struct phy_driver ks8737_driver = {
 	.phy_id		= PHY_ID_KS8737,
-	.phy_id_mask	= 0x00fffff0,
+	.phy_id_mask	= 0x00ffffff,
 	.name		= "Micrel KS8737",
 	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
@@ -130,7 +130,7 @@ static struct phy_driver ks8737_driver = {
 
 static struct phy_driver ks8041_driver = {
 	.phy_id		= PHY_ID_KS8041,
-	.phy_id_mask	= 0x00fffff0,
+	.phy_id_mask	= 0x00ffffff,
 	.name		= "Micrel KS8041",
 	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
 				| SUPPORTED_Asym_Pause),
@@ -145,7 +145,7 @@ static struct phy_driver ks8041_driver = {
 
 static struct phy_driver ks8051_driver = {
 	.phy_id		= PHY_ID_KS8051,
-	.phy_id_mask	= 0x00fffff0,
+	.phy_id_mask	= 0x00ffffff,
 	.name		= "Micrel KS8051",
 	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
 				| SUPPORTED_Asym_Pause),
@@ -174,7 +174,7 @@ static struct phy_driver ks8001_driver = {
 
 static struct phy_driver ksz9021_driver = {
 	.phy_id		= PHY_ID_KSZ9021,
-	.phy_id_mask	= 0x000ffffe,
+	.phy_id_mask	= 0x00ffffff,
 	.name		= "Micrel KSZ9021 Gigabit PHY",
 	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause
 				| SUPPORTED_Asym_Pause),
@@ -191,7 +191,6 @@ static int __init ksphy_init(void)
 {
 	int ret;
 
-#if 0
 	ret = phy_driver_register(&ks8001_driver);
 	if (ret)
 		goto err1;
@@ -206,18 +205,12 @@ static int __init ksphy_init(void)
 	ret = phy_driver_register(&ks8041_driver);
 	if (ret)
 		goto err4;
-#endif
 	ret = phy_driver_register(&ks8051_driver);
 	if (ret)
-		goto err2;
-
-	ret = phy_driver_register(&ksz9021_driver);
-	if (ret)
-		goto err1;
+		goto err5;
 
 	return 0;
 
-#if 0
 err5:
 	phy_driver_unregister(&ks8041_driver);
 err4:
@@ -226,9 +219,6 @@ err3:
 	phy_driver_unregister(&ksz9021_driver);
 err2:
 	phy_driver_unregister(&ks8001_driver);
-#endif
-err2:
-	phy_driver_unregister(&ks8051_driver);
 err1:
 	return ret;
 }
@@ -250,11 +240,11 @@ MODULE_AUTHOR("David J. Choi");
 MODULE_LICENSE("GPL");
 
 static struct mdio_device_id __maybe_unused micrel_tbl[] = {
-	{ PHY_ID_KSZ9021, 0x000ffffe },
+	{ PHY_ID_KSZ9021, 0x00ffffff },
 	{ PHY_ID_KS8001, 0x00ffffff },
-	{ PHY_ID_KS8737, 0x00fffff0 },
-	{ PHY_ID_KS8041, 0x00fffff0 },
-	{ PHY_ID_KS8051, 0x00fffff0 },
+	{ PHY_ID_KS8737, 0x00ffffff },
+	{ PHY_ID_KS8041, 0x00ffffff },
+	{ PHY_ID_KS8051, 0x00ffffff },
 	{ }
 };
 
-- 
1.7.5.4

