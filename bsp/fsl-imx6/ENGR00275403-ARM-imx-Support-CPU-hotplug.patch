From ffde429247fe5fde097260049c5fe78023a66e09 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Thu, 15 Aug 2013 16:18:22 -0400
Subject: [PATCH 0122/1072] ENGR00275403 ARM: imx: Support CPU hotplug

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 53b61c4559ecb89b1d7b373296c620095ac61e9d

When doing secondary cores enable/disable, the enable bit
and reset bit in SRC should be written together. Without
this, CPU hotplug can NOT pass stress test, and with this,
it can passed over 500k iterations CPU hotplug test with
many threads running in background, at least three boards
are tested.

When trying hotplug a secondary core, it should stay
in idle forever before it is disabled from SRC.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/hotplug.c |    5 +++--
 arch/arm/mach-imx/src.c     |    3 ++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/hotplug.c b/arch/arm/mach-imx/hotplug.c
index 3daf1ed..a40919b 100644
--- a/arch/arm/mach-imx/hotplug.c
+++ b/arch/arm/mach-imx/hotplug.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011, 2013 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -52,7 +52,8 @@ void imx_cpu_die(unsigned int cpu)
 	 * the register being cleared to kill the cpu.
 	 */
 	imx_set_cpu_arg(cpu, ~0);
-	cpu_do_idle();
+	for (;;)
+		cpu_do_idle();
 }
 
 int imx_cpu_kill(unsigned int cpu)
diff --git a/arch/arm/mach-imx/src.c b/arch/arm/mach-imx/src.c
index 10a6b1a..9e589d9 100644
--- a/arch/arm/mach-imx/src.c
+++ b/arch/arm/mach-imx/src.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011, 2013 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -91,6 +91,7 @@ void imx_enable_cpu(int cpu, bool enable)
 	spin_lock(&scr_lock);
 	val = readl_relaxed(src_base + SRC_SCR);
 	val = enable ? val | mask : val & ~mask;
+	val |= 1 << (BP_SRC_SCR_CORE1_RST + cpu - 1);
 	writel_relaxed(val, src_base + SRC_SCR);
 	spin_unlock(&scr_lock);
 }
-- 
1.7.5.4

