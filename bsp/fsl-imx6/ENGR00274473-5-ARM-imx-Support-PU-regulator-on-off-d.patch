From c3aa0a749b009399df82220b8030795ec8d89ecd Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Thu, 8 Aug 2013 17:20:39 -0400
Subject: [PATCH 0105/1072] ENGR00274473-5 ARM: imx: Support PU regulator
 on/off dynamically

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 3a63130db7817020023a01526c104c88a2632320

1. Change GPC to platform driver to support regulator nofication
in order to implement dynamical PU regulator on/off;

2. Remove previous enabling PU regulator during kernel boot up,
PU modules will handle it.

3. Support dynamical PU regulator on/off according to regulator
notification.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/anatop.c    |   57 -------------
 arch/arm/mach-imx/clk-imx6q.c |    6 --
 arch/arm/mach-imx/common.h    |    1 -
 arch/arm/mach-imx/gpc.c       |  176 +++++++++++++++++++++++++++++++++--------
 4 files changed, 142 insertions(+), 98 deletions(-)

diff --git a/arch/arm/mach-imx/anatop.c b/arch/arm/mach-imx/anatop.c
index e4f0718..ad42a06 100644
--- a/arch/arm/mach-imx/anatop.c
+++ b/arch/arm/mach-imx/anatop.c
@@ -9,7 +9,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/of.h>
@@ -25,7 +24,6 @@
 #define ANADIG_REG_2P5		0x130
 #define ANADIG_REG_CORE		0x140
 #define ANADIG_ANA_MISC0	0x150
-#define ANADIG_ANA_MISC2	0x170
 #define ANADIG_USB1_CHRG_DETECT	0x1b0
 #define ANADIG_USB2_CHRG_DETECT	0x210
 #define ANADIG_DIGPROG		0x260
@@ -37,55 +35,8 @@
 #define BM_ANADIG_USB_CHRG_DETECT_CHK_CHRG_B	0x80000
 #define BM_ANADIG_USB_CHRG_DETECT_EN_B		0x100000
 
-#define ANADIG_ANA_MISC2_REG1_STEP_OFFSET	26
-#define ANADIG_ANA_MISC2_REG_STEP_MASK		0x3
-#define ANADIG_REG_CORE_REG_MASK		0x1f
-#define ANADIG_REG_CORE_REG2_OFFSET		18	/* VDDSOC */
-#define ANADIG_REG_CORE_REG1_OFFSET		9	/* VDDPU */
-
-#define LDO_RAMP_UP_UNIT_IN_CYCLES		64	/* 64 cycles per step */
-#define LDO_RAMP_UP_FREQ_IN_MHZ			24	/* base on 24M OSC */
-
 static struct regmap *anatop;
 
-static void imx_anatop_pu_enable(bool enable)
-{
-	u32 val, vddsoc;
-
-	regmap_read(anatop, ANADIG_REG_CORE, &val);
-	if (enable) {
-		/* VDDPU track with VDDSOC if enable */
-		val &= ~(ANADIG_REG_CORE_REG_MASK <<
-			ANADIG_REG_CORE_REG1_OFFSET);
-		vddsoc = val & (ANADIG_REG_CORE_REG_MASK <<
-			ANADIG_REG_CORE_REG2_OFFSET);
-		val |= vddsoc >> (ANADIG_REG_CORE_REG2_OFFSET -
-			ANADIG_REG_CORE_REG1_OFFSET);
-	} else
-		/* power off pu */
-		val &= ~(ANADIG_REG_CORE_REG_MASK <<
-			ANADIG_REG_CORE_REG1_OFFSET);
-	regmap_write(anatop, ANADIG_REG_CORE, val);
-
-	if (enable) {
-		/*
-		 * the delay time for LDO ramp up time is
-		 * based on the register setting, we need
-		 * to calculate how many steps LDO need to
-		 * ramp up, and how much delay needed. (us)
-		 */
-		static u32 new_vol, delay_u;
-		regmap_read(anatop, ANADIG_ANA_MISC2, &val);
-		val = (val >> ANADIG_ANA_MISC2_REG1_STEP_OFFSET) &
-			ANADIG_ANA_MISC2_REG_STEP_MASK;
-		new_vol = (vddsoc >> ANADIG_REG_CORE_REG2_OFFSET) &
-			ANADIG_REG_CORE_REG_MASK;
-		delay_u = new_vol * ((LDO_RAMP_UP_UNIT_IN_CYCLES <<
-			val) / LDO_RAMP_UP_FREQ_IN_MHZ + 1);
-		udelay(delay_u);
-	}
-}
-
 static void imx_anatop_enable_weak2p5(bool enable)
 {
 	u32 reg, val;
@@ -168,12 +119,4 @@ void __init imx_anatop_init(void)
 		pr_err("%s: failed to find imx6q-anatop regmap!\n", __func__);
 		return;
 	}
-
-	/*
-	 * PU is turned off in uboot, so we need to turn it on here
-	 * to avoid kernel hang during GPU init, will remove
-	 * this code after PU power management done.
-	 */
-	imx_anatop_pu_enable(true);
-	imx_gpc_xpu_enable();
 }
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index fb5896c..d46835a 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -595,12 +595,6 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	clk_register_clkdev(clk[arm], NULL, "cpu0");
 	clk_register_clkdev(clk[pll4_post_div], "pll4_post_div", NULL);
 	clk_register_clkdev(clk[pll4_audio], "pll4_audio", NULL);
-	clk_register_clkdev(clk[gpu3d_core], "gpu3d_core", NULL);
-	clk_register_clkdev(clk[gpu3d_shader], "gpu3d_shader", NULL);
-	clk_register_clkdev(clk[gpu2d_core], "gpu2d_core", NULL);
-	clk_register_clkdev(clk[gpu2d_axi], "gpu2d_axi", NULL);
-	clk_register_clkdev(clk[openvg_axi], "openvg_axi", NULL);
-	clk_register_clkdev(clk[vpu_axi], "vpu_axi", NULL);
 
 	if ((imx_get_soc_revision() != IMX_CHIP_REVISION_1_0) || cpu_is_imx6dl()) {
 		clk_set_parent(clk[ldb_di0_sel], clk[pll5_video_div]);
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index dba45f5..273db61 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -140,7 +140,6 @@ extern void imx_gpc_mask_all(void);
 extern void imx_gpc_irq_mask(struct irq_data *d);
 extern void imx_gpc_irq_unmask(struct irq_data *d);
 extern void imx_gpc_restore_all(void);
-extern void imx_gpc_xpu_enable(void);
 extern void imx_anatop_init(void);
 extern void imx_anatop_pre_suspend(void);
 extern void imx_anatop_post_resume(void);
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index bda2cc5..d27f165 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -11,19 +11,30 @@
  */
 
 #include <linux/clk.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/platform_device.h>
 #include <linux/irqchip/arm-gic.h>
+#include <linux/regulator/consumer.h>
 #include "common.h"
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0
 #define GPC_PGC_GPU_PDN		0x260
+#define GPC_PGC_GPU_PUPSCR	0x264
+#define GPC_PGC_GPU_PDNSCR	0x268
+#define GPC_PGC_GPU_SW_SHIFT		0
+#define GPC_PGC_GPU_SW_MASK		0x3f
+#define GPC_PGC_GPU_SW2ISO_SHIFT	8
+#define GPC_PGC_GPU_SW2ISO_MASK		0x3f
 #define GPC_CNTR		0x0
-#define GPC_CNTR_xPU_UP_REQ_SHIFT	0x1
+#define GPC_CNTR_PU_UP_REQ_SHIFT	0x1
+#define GPC_CNTR_PU_DOWN_REQ_SHIFT	0x0
 
 #define IMR_NUM			4
 
@@ -31,7 +42,10 @@ static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 static struct clk *gpu3d_clk, *gpu3d_shader_clk, *gpu2d_clk, *gpu2d_axi_clk;
-static struct clk *openvg_axi_clk, *vpu_clk;
+static struct clk *openvg_axi_clk, *vpu_clk, *ipg_clk;
+static struct device *gpc_dev;
+struct regulator *pu_reg;
+struct notifier_block nb;
 
 void imx_gpc_pre_suspend(void)
 {
@@ -126,26 +140,6 @@ void imx_gpc_irq_mask(struct irq_data *d)
 	writel_relaxed(val, reg);
 }
 
-static void imx_gpc_pu_clk_init(void)
-{
-	if (gpu3d_clk != NULL &&  gpu3d_shader_clk != NULL
-		&& gpu2d_clk != NULL && gpu2d_axi_clk != NULL
-		&& openvg_axi_clk != NULL && vpu_clk != NULL)
-		return;
-
-	/* Get gpu&vpu clk for power up PU by GPC */
-	gpu3d_clk = clk_get(NULL, "gpu3d_core");
-	gpu3d_shader_clk = clk_get(NULL, "gpu3d_shader");
-	gpu2d_clk = clk_get(NULL, "gpu2d_core");
-	gpu2d_axi_clk = clk_get(NULL, "gpu2d_axi");
-	openvg_axi_clk = clk_get(NULL, "openvg_axi");
-	vpu_clk = clk_get(NULL, "vpu_axi");
-	if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
-		|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
-		|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk))
-		printk(KERN_ERR "%s: failed to get clk!\n", __func__);
-}
-
 static void imx_pu_clk(bool enable)
 {
 	if (enable) {
@@ -165,19 +159,79 @@ static void imx_pu_clk(bool enable)
 	}
 }
 
-void imx_gpc_xpu_enable(void)
+static void imx_gpc_pu_enable(bool enable)
 {
-	/*
-	 * PU is turned off in uboot, so we need to turn it on here
-	 * to avoid kernel hang during GPU init, will remove
-	 * this code after PU power management done.
-	 */
-	imx_gpc_pu_clk_init();
-	imx_pu_clk(true);
-	writel_relaxed(1, gpc_base + GPC_PGC_GPU_PDN);
-	writel_relaxed(1 << GPC_CNTR_xPU_UP_REQ_SHIFT, gpc_base + GPC_CNTR);
-	while (readl_relaxed(gpc_base + GPC_CNTR) & 0x2)
-		;
+	u32 rate, delay_us;
+	u32 gpu_pupscr_sw2iso, gpu_pdnscr_sw2iso;
+	u32 gpu_pupscr_sw, gpu_pdnscr_sw;
+
+	/* get ipg clk rate for PGC delay */
+	rate = clk_get_rate(ipg_clk);
+
+	if (enable) {
+		/*
+		 * need to add necessary delay between powering up PU LDO and
+		 * disabling PU isolation in PGC, the counter of PU isolation
+		 * is based on ipg clk.
+		 */
+		gpu_pupscr_sw2iso = (readl_relaxed(gpc_base +
+			GPC_PGC_GPU_PUPSCR) >> GPC_PGC_GPU_SW2ISO_SHIFT)
+			& GPC_PGC_GPU_SW2ISO_MASK;
+		gpu_pupscr_sw = (readl_relaxed(gpc_base +
+			GPC_PGC_GPU_PUPSCR) >> GPC_PGC_GPU_SW_SHIFT)
+			& GPC_PGC_GPU_SW_MASK;
+		delay_us = (gpu_pupscr_sw2iso + gpu_pupscr_sw) * 1000000
+			/ rate + 1;
+		udelay(delay_us);
+
+		imx_pu_clk(true);
+		writel_relaxed(1, gpc_base + GPC_PGC_GPU_PDN);
+		writel_relaxed(1 << GPC_CNTR_PU_UP_REQ_SHIFT,
+			gpc_base + GPC_CNTR);
+		while (readl_relaxed(gpc_base + GPC_CNTR) &
+			(1 << GPC_CNTR_PU_UP_REQ_SHIFT))
+			;
+		imx_pu_clk(false);
+	} else {
+		writel_relaxed(1, gpc_base + GPC_PGC_GPU_PDN);
+		writel_relaxed(1 << GPC_CNTR_PU_DOWN_REQ_SHIFT,
+			gpc_base + GPC_CNTR);
+		while (readl_relaxed(gpc_base + GPC_CNTR) &
+			(1 << GPC_CNTR_PU_DOWN_REQ_SHIFT))
+			;
+		/*
+		 * need to add necessary delay between enabling PU isolation
+		 * in PGC and powering down PU LDO , the counter of PU isolation
+		 * is based on ipg clk.
+		 */
+		gpu_pdnscr_sw2iso = (readl_relaxed(gpc_base +
+			GPC_PGC_GPU_PDNSCR) >> GPC_PGC_GPU_SW2ISO_SHIFT)
+			& GPC_PGC_GPU_SW2ISO_MASK;
+		gpu_pdnscr_sw = (readl_relaxed(gpc_base +
+			GPC_PGC_GPU_PDNSCR) >> GPC_PGC_GPU_SW_SHIFT)
+			& GPC_PGC_GPU_SW_MASK;
+		delay_us = (gpu_pdnscr_sw2iso + gpu_pdnscr_sw) * 1000000
+			/ rate + 1;
+		udelay(delay_us);
+	}
+}
+
+static int imx_gpc_regulator_notify(struct notifier_block *nb,
+					unsigned long event,
+					void *ignored)
+{
+	switch (event) {
+	case REGULATOR_EVENT_PRE_DISABLE:
+		imx_gpc_pu_enable(false);
+		break;
+	case REGULATOR_EVENT_ENABLE:
+		imx_gpc_pu_enable(true);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
 }
 
 void __init imx_gpc_init(void)
@@ -198,3 +252,57 @@ void __init imx_gpc_init(void)
 	gic_arch_extn.irq_unmask = imx_gpc_irq_unmask;
 	gic_arch_extn.irq_set_wake = imx_gpc_irq_set_wake;
 }
+
+static int imx_gpc_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	gpc_dev = &pdev->dev;
+
+	pu_reg = devm_regulator_get(gpc_dev, "pu");
+	nb.notifier_call = &imx_gpc_regulator_notify;
+
+	/* Get gpu&vpu clk for power up PU by GPC */
+	gpu3d_clk = devm_clk_get(gpc_dev, "gpu3d_core");
+	gpu3d_shader_clk = devm_clk_get(gpc_dev, "gpu3d_shader");
+	gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_core");
+	gpu2d_axi_clk = devm_clk_get(gpc_dev, "gpu2d_axi");
+	openvg_axi_clk = devm_clk_get(gpc_dev, "openvg_axi");
+	vpu_clk = devm_clk_get(gpc_dev, "vpu_axi");
+	ipg_clk = devm_clk_get(gpc_dev, "ipg");
+	if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
+		|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
+		|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk)
+		|| IS_ERR(ipg_clk)) {
+		dev_err(gpc_dev, "failed to get clk!\n");
+		return -ENOENT;
+	}
+
+	ret = regulator_register_notifier(pu_reg, &nb);
+	if (ret) {
+		dev_err(gpc_dev,
+			"regulator notifier request failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id imx_gpc_ids[] = {
+	{ .compatible = "fsl,imx6q-gpc" },
+};
+MODULE_DEVICE_TABLE(of, imx_gpc_ids);
+
+static struct platform_driver imx_gpc_platdrv = {
+	.driver = {
+		.name	= "imx-gpc",
+		.owner	= THIS_MODULE,
+		.of_match_table = imx_gpc_ids,
+	},
+	.probe		= imx_gpc_probe,
+};
+module_platform_driver(imx_gpc_platdrv);
+
+MODULE_AUTHOR("Anson Huang <b20788@freescale.com>");
+MODULE_DESCRIPTION("Freescale i.MX GPC driver");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

