From 2101dc12d6d29f891addd06cad1e4912fd134454 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Mon, 18 Nov 2013 16:20:33 -0600
Subject: [PATCH 0352/1072] ENGR00288506 [iMX6SL] Improve Audio playback power

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 5f97f4a6558b48cc5d1d4f50e368d3f48dad732d

When ARM executes WFI in audio playback mode, its possible to
lower the power consumed on the VDDHIGH_IN and VDDSOC_IN rails
by:
1. Putting DDR into self-refresh
2. Lower DDR frequency to 25MHz
3. Float DDR IO pads.

Also drop AHB to 8MHz in audio playback mode (aligning with 3.0.35)

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/busfreq-imx6.c   |    3 ++
 arch/arm/mach-imx/cpuidle-imx6sl.c |    8 ++--
 arch/arm/mach-imx/imx6sl_wfi.S     |   57 ++++++++++++++++++++++++++++++++++-
 3 files changed, 62 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-imx/busfreq-imx6.c b/arch/arm/mach-imx/busfreq-imx6.c
index eddc5a0..527b042 100644
--- a/arch/arm/mach-imx/busfreq-imx6.c
+++ b/arch/arm/mach-imx/busfreq-imx6.c
@@ -115,6 +115,9 @@ static void enter_lpm_imx6sl(void)
 		clk_set_rate(ocram_clk, LPAPM_CLK);
 	}
 	if (audio_bus_count) {
+		/* Set AHB to 8MHz to lower pwer.*/
+		clk_set_rate(ahb_clk, LPAPM_CLK / 3);
+
 		/* Set up DDR to 100MHz. */
 		spin_lock_irqsave(&freq_lock, flags);
 		update_lpddr2_freq(LPDDR2_AUDIO_CLK);
diff --git a/arch/arm/mach-imx/cpuidle-imx6sl.c b/arch/arm/mach-imx/cpuidle-imx6sl.c
index 841b657..dbb6643 100644
--- a/arch/arm/mach-imx/cpuidle-imx6sl.c
+++ b/arch/arm/mach-imx/cpuidle-imx6sl.c
@@ -20,7 +20,7 @@
 #include "common.h"
 #include "cpuidle.h"
 
-extern u32 low_bus_freq_mode;
+extern u32 audio_bus_freq_mode;
 extern u32 ultra_low_bus_freq_mode;
 extern unsigned long reg_addrs[];
 extern void imx6sl_low_power_wfi(void);
@@ -29,7 +29,7 @@ static void __iomem *iomux_base;
 static void *wfi_iram_base;
 
 void (*imx6sl_wfi_in_iram_fn)(void *wfi_iram_base,
-	void *iomux_addr, void *regs_addr) = NULL;
+	void *iomux_addr, void *regs_addr, u32 audio_mode) = NULL;
 
 #define WFI_IN_IRAM_SIZE	0x1000
 
@@ -37,13 +37,13 @@ static int imx6sl_enter_wait(struct cpuidle_device *dev,
 			    struct cpuidle_driver *drv, int index)
 {
 	imx6_set_lpm(WAIT_UNCLOCKED);
-	if (ultra_low_bus_freq_mode)
+	if (ultra_low_bus_freq_mode || audio_bus_freq_mode)
 		/*
 		 * Run WFI code from IRAM.
 		 * Drop the DDR freq to 1MHz and AHB to 3MHz
 		 * Also float DDR IO pads.
 		 */
-		imx6sl_wfi_in_iram_fn(wfi_iram_base, iomux_base, reg_addrs);
+		imx6sl_wfi_in_iram_fn(wfi_iram_base, iomux_base, reg_addrs, audio_bus_freq_mode);
 	else {
 		imx6sl_set_wait_clk(true);
 		cpu_do_idle();
diff --git a/arch/arm/mach-imx/imx6sl_wfi.S b/arch/arm/mach-imx/imx6sl_wfi.S
index 2fe8bae..df5b781 100644
--- a/arch/arm/mach-imx/imx6sl_wfi.S
+++ b/arch/arm/mach-imx/imx6sl_wfi.S
@@ -155,13 +155,17 @@ fifo_reset2_wait:
  * r0: WFI IRAMcode base address.
  * r1: IOMUX base address
  * r2: Base address of CCM, ANATOP and MMDC
+ * r3: 1 if in audio_bus_freq_mode
  */
 	.align 3
 ENTRY(imx6sl_low_power_wfi)
 
-	push {r4-r10}
+	push {r4-r11}
 
 mx6sl_lpm_wfi:
+	/* Store audio_bus_freq_mode */
+	mov	r11, r3
+
 	mov	r4,r2
 	/* Get the IRAM data storage address. */
 	mov	r10, r0
@@ -228,6 +232,8 @@ poll_dvfs_set_1:
 	orr	r6, r6, #0x100
 	str	r6, [r8, #0x410]
 
+	cmp	r11, #1
+	beq	audio_mode
 	/*
 	 * Now set DDR rate to 1MHz.
 	 * DDR is from bypassed PLL2 on periph2_clk2 path.
@@ -242,6 +248,15 @@ poll_dvfs_set_1:
 	bic	r6, r6, #0x38
 	orr	r6, r6, #0x10
 	str	r6, [r2, #0x14]
+	b	mmdc_podf
+
+audio_mode:
+	/* MMDC is from PLL2_200M.
+	 * Set the mmdc_podf to div by 8.
+	 */
+	ldr	r6, [r2, #0x14]
+	orr	r6, r6, #0x38
+	str	r6, [r2, #0x14]
 
 	/* Loop till podf is accepted. */
 mmdc_podf:
@@ -252,6 +267,9 @@ mmdc_podf:
 	/* Set the DDR IO in LPM state. */
 	sl_ddr_io_set_lpm
 
+	cmp	r11, #1
+	beq	do_audio_arm_clk
+
 	/*
 	 * Check if none of the PLLs are
 	 * locked, except PLL1 which will get
@@ -399,6 +417,30 @@ podf_loop:
 	orr	r6, r6, #0x1
 	str	r6, [r3, #0x150]
 
+	b	do_wfi
+
+do_audio_arm_clk:
+	/* ARM is from PLL2_PFD2_400M here.
+	 * Switch ARM to bypassed PLL1.
+	 */
+	ldr	r6, [r2, #0xC]
+	bic	r6, r6, #0x4
+	str	r6, [r2, #0xC]
+
+	/* Set the ARM_PODF to divide by 2
+	* as IPG is at 4MHz, we cannot run
+	* ARM_CLK above 9.6MHz when
+	* system enters WAIT mode.
+	*/
+	ldr	r6, =0x2
+	str	r6, [r2, #0x10]
+
+	/* Loop till podf is accepted. */
+podf_loop_audio:
+	ldr	r6, [r2, #0x48]
+	cmp	r6, #0x0
+	bne	podf_loop_audio
+
 do_wfi:
 	/* Now do WFI. */
 	wfi
@@ -412,6 +454,9 @@ podf_loop1:
 	cmp	r6, #0x0
 	bne	podf_loop1
 
+	cmp	r11, #1
+	beq	audio_arm_clk_restore
+
 	/*
 	 * Check if powered down
 	 * analog components.
@@ -497,6 +542,14 @@ ahb_podf1:
 	cmp	r6, #0x0
 	bne	podf_loop1
 
+	b	wfi_restore
+
+	audio_arm_clk_restore:
+	/* Move ARM back to PLL2_PFD2_400M */
+	ldr	r6, [r2, #0xC]
+	orr	r6, r6, #0x4
+	str	r6, [r2, #0xC]
+
 wfi_restore:
 	/* get suspend_iram_base */
 	mov	r9, r10
@@ -578,7 +631,7 @@ poll_dvfs_clear_1:
 	str	r6, [r8, #0x410]
 
 
-	pop {r4-r10}
+	pop {r4-r11}
 
 	/* Restore registers */
 	mov	pc, lr
-- 
1.7.5.4

