From 3aeaf481542b62625bac8fad2384023c18964db4 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Tue, 15 Oct 2013 12:36:42 -0500
Subject: [PATCH 0304/1072] ENGR00281769 [iMX6SL] Allow uart to be sourced
 from 24MHz XTAL

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit a25e49ff3dc65a43b1ff67d31bec1042d2e8e230

In order to optmize low power IDLE numbers all PLLs should be in bypass.
On imx6sl, UART can be sourced directly from the 24MHz XTAL. Its frequency
is limited to 4MHz due to an internal divide by 6 divider.
For customer who don't require higher uart speeds add "uart_at_4M"
to the kernel command line.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/clk-imx6sl.c           |   27 +++++++++++++++++++++------
 include/dt-bindings/clock/imx6sl-clock.h |    3 ++-
 2 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 9ee6a16..c8c9f22 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -13,6 +13,7 @@
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/err.h>
+#include <linux/init.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -22,6 +23,7 @@
 #include "clk.h"
 #include "common.h"
 
+static bool uart_from_osc;
 static const char const *step_sels[]		= { "osc", "pll2_pfd2", };
 static const char const *pll1_sw_sels[]		= { "pll1_sys", "step", };
 static const char const *ocram_alt_sels[]	= { "pll2_pfd2", "pll3_pfd1", };
@@ -44,7 +46,7 @@ static const char const *lcdif_pix_sels[]	= { "pll2_bus", "pll3_usb_otg", "pll5_
 static const char const *epdc_pix_sels[]	= { "pll2_bus", "pll3_usb_otg", "pll5_video_div", "pll2_pfd0", "pll2_pfd1", "pll3_pfd1", };
 static const char const *audio_sels[]		= { "pll4_audio_div", "pll3_pfd2", "pll3_pfd3", "pll3_usb_otg", };
 static const char const *ecspi_sels[]		= { "pll3_60m", "osc", };
-static const char const *uart_sels[]		= { "pll3_80m", "osc", };
+static const char const *uart_sels[]		= { "pll3_80m", "uart_osc_4M", };
 
 static struct clk_div_table clk_enet_ref_table[] = {
 	{ .val = 0, .div = 20, },
@@ -133,6 +135,14 @@ void imx6sl_set_wait_clk(bool enter)
 	}
 }
 
+static int __init setup_uart_clk(char *uart_rate)
+{
+	uart_from_osc = true;
+	return 1;
+}
+
+__setup("uart_at_4M", setup_uart_clk);
+
 static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 {
 	struct device_node *np;
@@ -187,11 +197,12 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clks[IMX6SL_CLK_PLL3_PFD2] = imx_clk_pfd("pll3_pfd2", "pll3_usb_otg", base + 0xf0,  2);
 	clks[IMX6SL_CLK_PLL3_PFD3] = imx_clk_pfd("pll3_pfd3", "pll3_usb_otg", base + 0xf0,  3);
 
-	/*                                                name         parent_name     mult div */
-	clks[IMX6SL_CLK_PLL2_198M] = imx_clk_fixed_factor("pll2_198m", "pll2_pfd2",      1, 2);
-	clks[IMX6SL_CLK_PLL3_120M] = imx_clk_fixed_factor("pll3_120m", "pll3_usb_otg",   1, 4);
-	clks[IMX6SL_CLK_PLL3_80M]  = imx_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6);
-	clks[IMX6SL_CLK_PLL3_60M]  = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
+	/*                                                       name         parent_name     mult div */
+	clks[IMX6SL_CLK_PLL2_198M]    = imx_clk_fixed_factor("pll2_198m", "pll2_pfd2",      1, 2);
+	clks[IMX6SL_CLK_PLL3_120M]    = imx_clk_fixed_factor("pll3_120m", "pll3_usb_otg",   1, 4);
+	clks[IMX6SL_CLK_PLL3_80M]     = imx_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6);
+	clks[IMX6SL_CLK_PLL3_60M]     = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
+	clks[IMX6SL_CLK_UART_OSC_4M]  = imx_clk_fixed_factor("uart_osc_4M", "osc",          1, 6);
 
 	np = ccm_node;
 	base = of_iomap(np, 0);
@@ -380,6 +391,10 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	reg |= 1 << CCDR_CH0_HS_BYP;
 	writel_relaxed(reg, base + CCM_CCDR_OFFSET);
 
+	/* Set the UART parent if needed. */
+	if (uart_from_osc)
+		ret = clk_set_parent(clks[IMX6SL_CLK_UART_SEL], clks[IMX6SL_CLK_UART_OSC_4M]);
+
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6sl-gpt");
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
diff --git a/include/dt-bindings/clock/imx6sl-clock.h b/include/dt-bindings/clock/imx6sl-clock.h
index c33e7f8..9b90165 100644
--- a/include/dt-bindings/clock/imx6sl-clock.h
+++ b/include/dt-bindings/clock/imx6sl-clock.h
@@ -145,6 +145,7 @@
 #define IMX6SL_CLK_USDHC4		132
 #define IMX6SL_CLK_PLL4_AUDIO_DIV	133
 #define IMX6SL_CLK_ENET			134
-#define IMX6SL_CLK_CLK_END		135
+#define IMX6SL_CLK_UART_OSC_4M	135
+#define IMX6SL_CLK_CLK_END		136
 
 #endif /* __DT_BINDINGS_CLOCK_IMX6SL_H */
-- 
1.7.5.4

