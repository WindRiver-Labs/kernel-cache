From 071bd0ef142f471a1ef6f50180542adcb856b031 Mon Sep 17 00:00:00 2001
From: Sandor Yu <R01008@freescale.com>
Date: Tue, 13 Aug 2013 16:48:32 +0800
Subject: [PATCH 0552/1072] ENGR00274059-01 MX6 HDMI: Add fsl,hdcp property

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit e293f8fa32971bf8c12baab0d19c84d4c1eadacb

- Initialize hdmi driver to support hdcp according dts property fsl,hdcp.
- Remove unused code.
- Add fsl,hdcp property description in mxc_hdmi_video.txt

Signed-off-by: Sandor Yu <R01008@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 .../devicetree/bindings/video/mxc_hdmi_video.txt   |    3 +
 drivers/video/mxc/mxc_hdmi.c                       |   57 ++++++--------------
 2 files changed, 19 insertions(+), 41 deletions(-)

diff --git a/Documentation/devicetree/bindings/video/mxc_hdmi_video.txt b/Documentation/devicetree/bindings/video/mxc_hdmi_video.txt
index cb9ca73..d105420 100644
--- a/Documentation/devicetree/bindings/video/mxc_hdmi_video.txt
+++ b/Documentation/devicetree/bindings/video/mxc_hdmi_video.txt
@@ -2,6 +2,8 @@ Device-Tree bindings for hdmi video driver
 
 Required properties:
 - compatible: value should be "fsl,imx6q-hdmi-video".
+- fsl,hdcp: define the property in dts, hdmi driver will initalize for hdcp,
+  otherwise hdcp function will not supported.
 - fsl,phy_reg_vlev: hdmi phy register,Voltage Level Control Register offset 0x0e,
   adjust hdmi phy signal voltage level.
 - fsl,phy_reg_cksymtx: hdmi phy register, clock symbol and transmitter control
@@ -11,6 +13,7 @@ Example:
 
 	hdmi_video {
 		compatible = "fsl,imx6q-hdmi-video";
+		fsl,hdcp;
 		fsl,phy_reg_vlev = <0x0294>;
 		fsl,phy_reg_cksymtx = <0x800d>;
 	};
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 7840464..373dd0b 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -205,11 +205,11 @@ struct mxc_hdmi {
 static int hdmi_major;
 static struct class *hdmi_class;
 
-
 struct i2c_client *hdmi_i2c;
 struct mxc_hdmi *g_hdmi;
 
 static bool hdmi_inited;
+static bool hdcp_init;
 
 extern const struct fb_videomode mxc_cea_mode[64];
 extern void mxc_hdmi_cec_handle(u16 cec_stat);
@@ -253,14 +253,6 @@ static void dump_fb_videomode(struct fb_videomode *m)
 {}
 #endif
 
-static int hdcp_init;
-static int __init early_init_hdcp(char *p)
-{
-	hdcp_init = 1;
-	return 0;
-}
-early_param("hdcp", early_init_hdcp);
-
 static ssize_t mxc_hdmi_show_name(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -1306,19 +1298,6 @@ static void mxc_hdmi_phy_init(struct mxc_hdmi *hdmi)
 	hdmi->phy_enabled = true;
 }
 
-static void hdmi_tx_hdcp_config(struct mxc_hdmi *hdmi)
-{
-#if 0
-	if (hdmi->hdmi_data.hdcp_enable) {
-		/* Enable HDMI DDC pin */
-		mxc_hdmi_enable_pins(hdmi);
-	} else {
-		/* Disable HDMI DDC pin */
-		mxc_hdmi_disable_pins(hdmi);
-	}
-#endif
-}
-
 static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
 {
 	u8 val;
@@ -1688,22 +1667,6 @@ static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 	return HDMI_EDID_SUCCESS;
 }
 
-#if 0
-static void mxc_hdmi_enable_pins(struct mxc_hdmi *hdmi)
-{
-
-	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
-
-}
-
-static void mxc_hdmi_disable_pins(struct mxc_hdmi *hdmi)
-{
-
-	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
-
-}
-#endif
-
 static void mxc_hdmi_phy_disable(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
@@ -2295,7 +2258,6 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	hdmi_video_packetize(hdmi);
 	hdmi_video_csc(hdmi);
 	hdmi_video_sample(hdmi);
-	hdmi_tx_hdcp_config(hdmi);
 
 	mxc_hdmi_clear_overflow(hdmi);
 
@@ -2460,6 +2422,18 @@ static void hdmi_init_route(struct mxc_hdmi *hdmi)
 */
 }
 
+static void hdmi_hdcp_get_property(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	/* Check hdcp enable by dts.*/
+	hdcp_init = of_property_read_bool(np, "fsl,hdcp");
+	if (hdcp_init)
+		dev_dbg(&pdev->dev, "hdcp enable\n");
+	else
+		dev_dbg(&pdev->dev, "hdcp disable\n");
+}
+
 static void hdmi_get_of_property(struct mxc_hdmi *hdmi)
 {
 	struct platform_device *pdev = hdmi->pdev;
@@ -2776,8 +2750,9 @@ static int mxc_hdmi_probe(struct platform_device *pdev)
 	struct resource *res;
 	int ret = 0;
 
-	/* Check that I2C driver is loaded and available */
-	/* Skip I2C driver available check when HDCP enable */
+	/* Check I2C driver is loaded and available
+	 * check hdcp function is enable by dts */
+	hdmi_hdcp_get_property(pdev);
 	if (!hdmi_i2c && !hdcp_init)
 		return -ENODEV;
 
-- 
1.7.5.4

