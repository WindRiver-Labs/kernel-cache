From 38724dc218a765c7cd9e94f7f3728e6a20ac75e3 Mon Sep 17 00:00:00 2001
From: Loren HUANG <b02279@freescale.com>
Date: Mon, 2 Sep 2013 13:43:59 +0800
Subject: [PATCH 0580/1072] ENGR00278350 gpu:viante 4.6.9p13 kernel part
 integration

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 9d655a4630a77f6a816fdc884a1f389101b740c1

Integrated 4.6.9p13 kernel part change.

Signed-off-by: Loren HUANG <b02279@freescale.com>
Acked-by: Shawn Guo
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/mxc/gpu-viv/Kbuild                         |   33 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.c   |  177 ++--
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.h   |    9 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.c   |    8 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.h   |   13 +
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c  |  736 +++++++++++++-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h  |    1 +
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     |  125 ++-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |   24 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |   57 +
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |   45 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |   12 +
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |   29 +
 .../hal/kernel/gc_hal_kernel_interrupt_vg.c        |    3 +
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |    8 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        |   20 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |   84 ++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  170 +++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h   |  142 +++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |   37 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |   46 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |  125 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |   86 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   | 1078 +++-----------------
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |   48 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   79 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |    7 +
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |    1 +
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |   18 +-
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |  619 ++++++++++--
 .../hal/os/linux/kernel/gc_hal_kernel_sync.c       |  174 ++++
 .../hal/os/linux/kernel/gc_hal_kernel_sync.h       |   71 ++
 33 files changed, 2835 insertions(+), 1252 deletions(-)
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h

diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index 93b1259..2b277d6 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -45,8 +45,6 @@ OBJS := $(OS_KERNEL_DIR)/gc_hal_kernel_device.o \
         $(OS_KERNEL_DIR)/gc_hal_kernel_os.o \
         $(OS_KERNEL_DIR)/gc_hal_kernel_debugfs.o
 
-ifeq ($(USE_3D_VG), 1)
-
 OBJS += $(HAL_KERNEL_DIR)/gc_hal_kernel.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_command.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_db.o \
@@ -69,19 +67,9 @@ OBJS +=\
           $(ARCH_VG_KERNEL_DIR)/gc_hal_kernel_hardware_command_vg.o\
           $(ARCH_VG_KERNEL_DIR)/gc_hal_kernel_hardware_vg.o
 endif
-else
-
-OBJS += $(HAL_KERNEL_DIR)/gc_hal_kernel.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_command.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_heap.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_interrupt.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_mmu.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o \
-        $(OS_KERNEL_DIR)/gc_hal_kernel_debug.o
-
-OBJS += $(ARCH_KERNEL_DIR)/gc_hal_kernel_hardware.o \
-        $(ARCH_KERNEL_DIR)/gc_hal_kernel_hardware_command.o
 
+ifneq ($(CONFIG_SYNC),)
+OBJS += $(OS_KERNEL_DIR)/gc_hal_kernel_sync.o
 endif
 
 ifeq ($(KERNELRELEASE), )
@@ -129,23 +117,16 @@ ifeq ($(CONFIG_DOVE_GPU), 1)
 EXTRA_CFLAGS += -DCONFIG_DOVE_GPU=1
 endif
 
-ifeq ($(USE_POWER_MANAGEMENT), 1)
-EXTRA_CFLAGS += -DgcdPOWER_MANAGEMENT=1
-else
-EXTRA_CFLAGS += -DgcdPOWER_MANAGEMENT=0
-endif
-
 ifneq ($(USE_PLATFORM_DRIVER), 0)
 EXTRA_CFLAGS += -DUSE_PLATFORM_DRIVER=1
 else
 EXTRA_CFLAGS += -DUSE_PLATFORM_DRIVER=0
 endif
 
-ifeq ($(USE_PROFILER), 1)
+
 EXTRA_CFLAGS += -DVIVANTE_PROFILER=1
-else
-EXTRA_CFLAGS += -DVIVANTE_PROFILER=0
-endif
+EXTRA_CFLAGS += -DVIVANTE_PROFILER_CONTEXT=1
+
 
 ifeq ($(ANDROID), 1)
 EXTRA_CFLAGS += -DANDROID=1
@@ -235,6 +216,10 @@ ifeq ($(USE_BANK_ALIGNMENT), 1)
     endif
 endif
 
+ifneq ($(CONFIG_SYNC),)
+EXTRA_CFLAGS += -DgcdANDROID_NATIVE_FENCE_SYNC=1
+endif
+
 EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel/inc
 EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel
 EXTRA_CFLAGS += -I$(AQARCH)/hal/kernel
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
index 70c2cd6..a17d2fd 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
@@ -217,50 +217,17 @@ _IdentifyHardware(
     return status;
 }
 
-static gctTHREADFUNCRESULT gctTHREADFUNCTYPE
-_TimeIdleThread(
-    gctTHREADFUNCPARAMETER ThreadParameter
+#if gcdPOWEROFF_TIMEOUT
+void
+_VGPowerTimerFunction(
+    gctPOINTER Data
     )
 {
-    gctUINT32           currentTime = 0;
-    gctBOOL             isAfter = gcvFALSE;
-    gceCHIPPOWERSTATE   state;
-
-    /* Cast the object. */
-    gckVGHARDWARE hardware = (gckVGHARDWARE) ThreadParameter;
-
-    while(gcvTRUE)
-    {
-        gcmkVERIFY_OK(gckOS_WaitSignal(hardware->os,
-            hardware->idleSignal, gcvINFINITE));
-
-        if (hardware->killThread)
-        {
-            break;
-        }
-
-        do
-        {
-            gcmkVERIFY_OK(gckOS_GetTicks(&currentTime));
-
-            gcmkVERIFY_OK(
-                gckOS_TicksAfter(currentTime, hardware->powerOffTime, &isAfter));
-
-            if (isAfter)
-            {
-                gcmkVERIFY_OK(gckVGHARDWARE_SetPowerManagementState(
-                    hardware, gcvPOWER_OFF_BROADCAST));
-            }
-
-            gcmkVERIFY_OK(gckOS_Delay(hardware->os, 200));
-
-            gcmkVERIFY_OK(gckVGHARDWARE_QueryPowerManagementState(
-                hardware, &state));
-
-        } while (state == gcvPOWER_IDLE);
-    }
-    return 0;
+    gckVGHARDWARE hardware = (gckVGHARDWARE)Data;
+    gcmkVERIFY_OK(
+        gckVGHARDWARE_SetPowerManagementState(hardware, gcvPOWER_OFF_TIMEOUT));
 }
+#endif
 
 /******************************************************************************\
 ****************************** gckVGHARDWARE API code *****************************
@@ -338,15 +305,21 @@ gckVGHARDWARE_Construct(
         hardware->chipMinorFeatures2 = chipMinorFeatures2;
 
         hardware->powerMutex            = gcvNULL;
-        hardware->idleSignal            = gcvNULL;
         hardware->chipPowerState        = gcvPOWER_ON;
         hardware->chipPowerStateGlobal  = gcvPOWER_ON;
         hardware->clockState            = gcvTRUE;
         hardware->powerState            = gcvTRUE;
-        hardware->powerOffTimeout       = gcdPOWEROFF_TIMEOUT;
+
         hardware->powerOffTime          = 0;
-        hardware->timeIdleThread        = gcvNULL;
-        hardware->killThread            = gcvFALSE;
+#if gcdPOWEROFF_TIMEOUT
+        hardware->powerOffTimeout = gcdPOWEROFF_TIMEOUT;
+
+        gcmkVERIFY_OK(gckOS_CreateTimer(Os,
+                                        _VGPowerTimerFunction,
+                                        (gctPOINTER)hardware,
+                                        &hardware->powerOffTimer));
+#endif
+
         /* Determine whether FE 2.0 is present. */
         hardware->fe20 = ((((gctUINT32) (hardware->chipFeatures)) >> (0 ? 28:28) & ((gctUINT32) ((((1 ? 28:28) - (0 ? 28:28) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 28:28) - (0 ? 28:28) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 28:28) - (0 ? 28:28) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 28:28) - (0 ? 28:28) + 1)))))));
 
@@ -365,18 +338,10 @@ gckVGHARDWARE_Construct(
         gcmkVERIFY_OK(gckVGHARDWARE_SetFastClear(hardware, -1));
 
         gcmkERR_BREAK(gckOS_CreateMutex(Os, &hardware->powerMutex));
-        gcmkERR_BREAK(gckOS_CreateSignal(Os, gcvFALSE, &hardware->idleSignal));
 
         /* Enable power management by default. */
         hardware->powerManagement = gcvTRUE;
 
-        gcmkERR_BREAK(gckOS_StartThread(
-            hardware->os,
-            _TimeIdleThread,
-            hardware,
-            &hardware->timeIdleThread
-            ));
-
         /* Return pointer to the gckVGHARDWARE object. */
         *Hardware = hardware;
 
@@ -386,6 +351,14 @@ gckVGHARDWARE_Construct(
     }
     while (gcvFALSE);
 
+#if gcdPOWEROFF_TIMEOUT
+        if (hardware->powerOffTimer != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_StopTimer(Os, hardware->powerOffTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, hardware->powerOffTimer));
+        }
+#endif
+
     if (hardware->pageTableDirty != gcvNULL)
     {
         gcmkVERIFY_OK(gckOS_AtomDestroy(Os, hardware->pageTableDirty));
@@ -428,10 +401,6 @@ gckVGHARDWARE_Destroy(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-    Hardware->killThread  = gcvTRUE;
-    gcmkVERIFY_OK(gckOS_Signal(Hardware->os, Hardware->idleSignal, gcvTRUE));
-    gcmkVERIFY_OK(gckOS_StopThread(Hardware->os, Hardware->timeIdleThread));
-
     /* Mark the object as unknown. */
     Hardware->object.type = gcvOBJ_UNKNOWN;
 
@@ -441,11 +410,10 @@ gckVGHARDWARE_Destroy(
             Hardware->os, Hardware->powerMutex));
     }
 
-    if (Hardware->idleSignal != gcvNULL)
-    {
-        gcmkVERIFY_OK(gckOS_DestroySignal(
-            Hardware->os, Hardware->idleSignal));
-    }
+#if gcdPOWEROFF_TIMEOUT
+    gcmkVERIFY_OK(gckOS_StopTimer(Hardware->os, Hardware->powerOffTimer));
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Hardware->os, Hardware->powerOffTimer));
+#endif
 
     if (Hardware->pageTableDirty != gcvNULL)
     {
@@ -1510,11 +1478,15 @@ gckVGHARDWARE_SetPowerManagementState(
     gctBOOL commitMutex     = gcvFALSE;
     gctBOOL mutexAcquired   = gcvFALSE;
 
+#if gcdPOWEROFF_TIMEOUT
+    gctBOOL timeout = gcvFALSE;
+    gctBOOL isAfter = gcvFALSE;
+    gctUINT32 currentTime;
+#endif
+
     gctBOOL broadcast = gcvFALSE;
     gctUINT32 process, thread;
     gctBOOL global = gcvFALSE;
-    gctUINT32   currentTime;
-
 
 #if gcdENABLE_PROFILING
     gctUINT64 time, freq, mutexTime, onTime, stallTime, stopTime, delayTime,
@@ -1661,6 +1633,16 @@ gckVGHARDWARE_SetPowerManagementState(
         global = gcvTRUE;
         break;
 
+#if gcdPOWEROFF_TIMEOUT
+    case gcvPOWER_OFF_TIMEOUT:
+        /* Convert to OFF and note we are inside broadcast. */
+        State     = gcvPOWER_OFF;
+        broadcast = gcvTRUE;
+        /* Check time out */
+        timeout = gcvTRUE;
+        break;
+#endif
+
     default:
         break;
     }
@@ -1719,6 +1701,31 @@ gckVGHARDWARE_SetPowerManagementState(
     flag  = flags[Hardware->chipPowerState][State];
     /*clock = clocks[State];*/
 
+#if gcdPOWEROFF_TIMEOUT
+    if (timeout)
+    {
+        gcmkONERROR(gckOS_GetTicks(&currentTime));
+
+        gcmkONERROR(
+            gckOS_TicksAfter(Hardware->powerOffTime, currentTime, &isAfter));
+
+        /* powerOffTime is pushed forward, give up.*/
+        if (isAfter
+        /* Expect a transition start from IDLE. */
+        ||  (Hardware->chipPowerState == gcvPOWER_ON)
+        ||  (Hardware->chipPowerState == gcvPOWER_OFF)
+        )
+        {
+            /* Release the power mutex. */
+            gcmkONERROR(gckOS_ReleaseMutex(os, Hardware->powerMutex));
+
+            /* No need to do anything. */
+            gcmkFOOTER_NO();
+            return gcvSTATUS_OK;
+        }
+    }
+#endif
+
     if (flag == 0)
     {
         /* Release the power mutex. */
@@ -1742,6 +1749,18 @@ gckVGHARDWARE_SetPowerManagementState(
             return gcvSTATUS_OK;
         }
     }
+    else
+    {
+        if (flag & gcvPOWER_FLAG_ACQUIRE)
+        {
+            /* Acquire the power management semaphore. */
+            gcmkONERROR(gckOS_AcquireSemaphore(os, command->powerSemaphore));
+            acquired = gcvTRUE;
+
+            /* avoid acquiring again. */
+            flag &= ~gcvPOWER_FLAG_ACQUIRE;
+        }
+    }
 
     if (flag & (gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_CLOCK_ON))
     {
@@ -1858,14 +1877,6 @@ gckVGHARDWARE_SetPowerManagementState(
         Hardware->chipPowerStateGlobal = State;
     }
 
-    if (State == gcvPOWER_IDLE)
-    {
-        gcmkVERIFY_OK(gckOS_Signal(os, Hardware->idleSignal, gcvTRUE));
-    }
-        /* Reset power off time */
-    gcmkVERIFY_OK(gckOS_GetTicks(&currentTime));
-    Hardware->powerOffTime = currentTime + Hardware->powerOffTimeout;
-
     if (commitMutex)
     {
         /* Acquire the mutex. */
@@ -1875,6 +1886,28 @@ gckVGHARDWARE_SetPowerManagementState(
             ));
     }
 
+#if gcdPOWEROFF_TIMEOUT
+    /* Reset power off time */
+    gcmkONERROR(gckOS_GetTicks(&currentTime));
+
+    Hardware->powerOffTime = currentTime + Hardware->powerOffTimeout;
+
+    if (State == gcvPOWER_IDLE)
+    {
+        /* Start a timer to power off GPU when GPU enters IDLE or SUSPEND. */
+        gcmkVERIFY_OK(gckOS_StartTimer(os,
+                                       Hardware->powerOffTimer,
+                                       Hardware->powerOffTimeout));
+    }
+    else
+    {
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE, "Cancel powerOfftimer");
+
+        /* Cancel running timer when GPU enters ON or OFF. */
+        gcmkVERIFY_OK(gckOS_StopTimer(os, Hardware->powerOffTimer));
+    }
+#endif
+
     /* Release the power mutex. */
     gcmkONERROR(gckOS_ReleaseMutex(os, Hardware->powerMutex));
 
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
index 16b81ae..73d4594 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
@@ -53,7 +53,6 @@ struct _gckVGHARDWARE
     gctBOOL                     clockState;
     gctBOOL                     powerState;
     gctPOINTER                  powerMutex;
-    gctSIGNAL                   idleSignal;
     gctUINT32                   powerProcess;
     gctUINT32                   powerThread;
     gceCHIPPOWERSTATE           chipPowerState;
@@ -61,11 +60,13 @@ struct _gckVGHARDWARE
     gctISRMANAGERFUNC           startIsr;
     gctISRMANAGERFUNC           stopIsr;
     gctPOINTER                  isrContext;
+    gctPOINTER                  pageTableDirty;
+
+#if gcdPOWEROFF_TIMEOUT
     gctUINT32                   powerOffTime;
     gctUINT32                   powerOffTimeout;
-    gctTHREAD                   timeIdleThread;
-    gctBOOL                     killThread;
-    gctPOINTER                  pageTableDirty;
+    gctPOINTER                  powerOffTimer;
+#endif
 
     gctBOOL                     powerManagement;
 };
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
index 24003e7..42e6915 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
@@ -181,7 +181,8 @@ _FlushPipe(
                 ?   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
                 :   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
-                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)));
+                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
+                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
 
         /* Semaphore from FE to PE. */
         *buffer++
@@ -620,7 +621,10 @@ _InitializeContextBuffer(
         index += _State(Context, index, 0x10180 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10200 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10280 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x02C00 >> 2, 0x00000000, 256, gcvFALSE, gcvFALSE);
+        for (i = 0; i < 256 / 16; i += 1)
+        {
+            index += _State(Context, index, (0x02C00 >> 2) + i * 16, 0x00000000, 14, gcvFALSE, gcvFALSE);
+        }
         index += _State(Context, index, 0x10300 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10380 >> 2, 0x00321000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10400 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
index 7554045..5d2c7c7 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
@@ -134,6 +134,19 @@ struct _gckCONTEXT
 #if gcdSECURE_USER
     gctBOOL_PTR                 hint;
 #endif
+
+#if VIVANTE_PROFILER_CONTEXT
+    gcsPROFILER_COUNTERS        latestProfiler;
+    gcsPROFILER_COUNTERS        histroyProfiler;
+    gctUINT32                   prevVSInstCount;
+    gctUINT32                   prevVSBranchInstCount;
+    gctUINT32                   prevVSTexInstCount;
+    gctUINT32                   prevVSVertexCount;
+    gctUINT32                   prevPSInstCount;
+    gctUINT32                   prevPSBranchInstCount;
+    gctUINT32                   prevPSTexInstCount;
+    gctUINT32                   prevPSPixelCount;
+#endif
 };
 
 #ifdef __cplusplus
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
index 6492935..bdf9e13 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
@@ -21,6 +21,9 @@
 
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
+#if VIVANTE_PROFILER_CONTEXT
+#include "gc_hal_kernel_context.h"
+#endif
 
 #define _GC_OBJ_ZONE    gcvZONE_HARDWARE
 
@@ -69,6 +72,7 @@ _IdentifyHardware(
     gctUINT32 numConstants = 0;
     gctUINT32 bufferSize = 0;
     gctUINT32 varyingsCount = 0;
+    gctBOOL useHZ;
 
     gcmkHEADER_ARG("Os=0x%x", Os);
 
@@ -209,6 +213,15 @@ _IdentifyHardware(
                                      0x00088,
                                      &Identity->chipMinorFeatures3));
 
+            /*The BG2 chip has no compression supertiled, and the bit of GCMinorFeature3BugFixes15 is n/a*/
+            if(Identity->chipModel == gcv1000 && Identity->chipRevision == 0x5036)
+            {
+                Identity->chipMinorFeatures3
+                    = ((((gctUINT32) (Identity->chipMinorFeatures3)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
+                Identity->chipMinorFeatures3
+                    = ((((gctUINT32) (Identity->chipMinorFeatures3)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) << (0 ? 27:27))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) << (0 ? 27:27)));
+            }
+
             /* Read chip minor featuress register #4. */
             gcmkONERROR(
                 gckOS_ReadRegisterEx(Os, Core,
@@ -244,14 +257,31 @@ _IdentifyHardware(
     if (((Identity->chipModel == gcv1000) && ((Identity->chipRevision == 0x5035)
                                            || (Identity->chipRevision == 0x5036)
                                            || (Identity->chipRevision == 0x5037)))
-	 || ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4612)))
+	 || ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4612))
+     || ((Identity->chipModel == gcv860) && (Identity->chipRevision == 0x4647)))
     {
         Identity->superTileMode = 1;
     }
 
+    if (Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5245)
+    {
+        useHZ = ((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))))
+             || ((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))));
+    }
+    else
+    {
+        useHZ = gcvFALSE;
+    }
 
-	/* Disable HZ when EZ is present for older chips. */
-	if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
+    if (useHZ)
+    {
+        /* Disable EZ. */
+        Identity->chipFeatures
+            = ((((gctUINT32) (Identity->chipFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+    }
+
+    /* Disable HZ when EZ is present for older chips. */
+    else if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
     {
         /* Disable HIERARCHICAL_Z. */
         Identity->chipMinorFeatures
@@ -470,6 +500,15 @@ _IdentifyHardware(
          Identity->varyingsCount = 8;
      }
 
+     /* For some cores, it consumes two varying for position, so the max varying vectors should minus one. */
+     if ((Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5222) ||
+         (Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5208) ||
+         ((Identity->chipModel == gcv2100 || Identity->chipModel == gcv2000) && Identity->chipRevision == 0x5108) ||
+         (Identity->chipModel == gcv880 && (Identity->chipRevision == 0x5107 || Identity->chipRevision == 0x5106)))
+     {
+         Identity->varyingsCount -= 1;
+     }
+
     /* Success. */
     gcmkFOOTER();
     return gcvSTATUS_OK;
@@ -535,9 +574,9 @@ _DumpDebugRegisters(
     IN gcsiDEBUG_REGISTERS_PTR Descriptor
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gctUINT32 select;
-    gctUINT32 data;
+    gctUINT32 data = 0;
     gctUINT i;
 
     gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
@@ -643,6 +682,42 @@ OnError:
     return status;
 }
 
+gceSTATUS
+_FlushCache(
+    gckHARDWARE Hardware,
+    gckCOMMAND Command
+    )
+{
+    gceSTATUS status;
+    gctSIZE_T bytes, requested;
+    gctPOINTER buffer;
+
+    /* Get the size of the flush command. */
+    gcmkONERROR(gckHARDWARE_Flush(Hardware,
+                                  gcvFLUSH_ALL,
+                                  gcvNULL,
+                                  &requested));
+
+    /* Reserve space in the command queue. */
+    gcmkONERROR(gckCOMMAND_Reserve(Command,
+                                   requested,
+                                   &buffer,
+                                   &bytes));
+
+    /* Append a flush. */
+    gcmkONERROR(gckHARDWARE_Flush(
+        Hardware, gcvFLUSH_ALL, buffer, &bytes
+        ));
+
+    /* Execute the command queue. */
+    gcmkONERROR(gckCOMMAND_Execute(Command, requested));
+
+    return gcvSTATUS_OK;
+
+OnError:
+    return status;
+}
+
 /******************************************************************************\
 ****************************** gckHARDWARE API code *****************************
 \******************************************************************************/
@@ -816,6 +891,9 @@ gckHARDWARE_Construct(
     /* Enable power management by default. */
     hardware->powerManagement = gcvTRUE;
 
+    /* Disable profiler by default */
+    hardware->gpuProfiler = gcvFALSE;
+
     /* Return pointer to the gckHARDWARE object. */
     *Hardware = hardware;
 
@@ -1120,6 +1198,31 @@ gckHARDWARE_InitializeHardware(
                                   ((((gctUINT32) (0x01590880)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23)))));
     }
 
+    if ((gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_HALTI2) == gcvFALSE)
+     || (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_HALTI2) && (Hardware->identity.chipRevision < 0x5422))
+    )
+    {
+        gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 Hardware->powerBaseAddress
+                                 + 0x00104,
+                                 &data));
+
+
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:15) - (0 ? 15:15) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:15) - (0 ? 15:15) + 1))))))) << (0 ? 15:15))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:15) - (0 ? 15:15) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:15) - (0 ? 15:15) + 1))))))) << (0 ? 15:15)));
+
+
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  Hardware->powerBaseAddress
+                                  + 0x00104,
+                                  data));
+    }
+
     /* Special workaround for this core
     ** Make sure FE and TX are on different buses */
     if ((Hardware->identity.chipModel == gcv2000)
@@ -1159,7 +1262,9 @@ gckHARDWARE_InitializeHardware(
     }
 
     if (Hardware->identity.chipModel >= gcv400
-    &&  Hardware->identity.chipModel != gcv420)
+    &&  Hardware->identity.chipModel != gcv420
+    &&  (((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 15:15) & ((gctUINT32) ((((1 ? 15:15) - (0 ? 15:15) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:15) - (0 ? 15:15) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 15:15) - (0 ? 15:15) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:15) - (0 ? 15:15) + 1))))))) != gcvTRUE)
+    )
     {
 		gctUINT32 data;
 
@@ -2898,35 +3003,44 @@ gckHARDWARE_QueryShaderCaps(
     OUT gctUINT * Varyings
     )
 {
+    gctUINT32 vsConstMax;
+    gctUINT32 psConstMax;
+
     gcmkHEADER_ARG("Hardware=0x%x VertexUniforms=0x%x "
                    "FragmentUniforms=0x%x Varyings=0x%x",
                    Hardware, VertexUniforms,
                    FragmentUniforms, Varyings);
 
+    if ((Hardware->identity.chipModel == gcv2000)
+     && (Hardware->identity.chipRevision == 0x5118))
+    {
+        vsConstMax   = 256;
+        psConstMax   = 64;
+    }
+    else if (Hardware->identity.numConstants > 256)
+    {
+        vsConstMax   = 256;
+        psConstMax   = 256;
+    }
+    else if (Hardware->identity.numConstants == 256)
+    {
+        vsConstMax   = 256;
+        psConstMax   = 256;
+    }
+    else
+    {
+        vsConstMax   = 168;
+        psConstMax   = 64;
+    }
+
     if (VertexUniforms != gcvNULL)
     {
-		/* Return the vs shader const count. */
-        if (Hardware->identity.chipModel < gcv4000)
-        {
-            *VertexUniforms = 168;
-        }
-        else
-        {
-            *VertexUniforms = 256;
-        }
+        *VertexUniforms = vsConstMax;
     }
 
     if (FragmentUniforms != gcvNULL)
     {
-		/* Return the ps shader const count. */
-        if (Hardware->identity.chipModel < gcv4000)
-        {
-            *FragmentUniforms = 64;
-        }
-        else
-        {
-            *FragmentUniforms = 256;
-        }
+        *FragmentUniforms = psConstMax;
     }
 
     if (Varyings != gcvNULL)
@@ -3244,12 +3358,28 @@ gckHARDWARE_SetMMUv2(
     gctBOOL commitEntered = gcvFALSE;
     gctPOINTER pointer = gcvNULL;
     gctBOOL acquired = gcvFALSE;
+    gctBOOL config2D;
+    gctSIZE_T configSize;
 
     gcmkHEADER_ARG("Hardware=0x%x Enable=%d", Hardware, Enable);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
+    config2D =  gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_PIPE_3D)
+             && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_PIPE_2D);
+
+    configSize = 4 * 4;
+
+    if (config2D)
+    {
+        configSize +=
+            /* Pipe Select. */
+            4 * 4
+            /* Configure MMU States. */
+          + 4 * 4;
+    }
+
     /* Convert logical address into physical address. */
     gcmkONERROR(
         gckOS_GetPhysicalAddress(Hardware->os, MtlbAddress, &config));
@@ -3296,7 +3426,7 @@ gckHARDWARE_SetMMUv2(
     commitEntered = gcvTRUE;
 
     gcmkONERROR(gckCOMMAND_Reserve(
-        command, 16, &pointer, &bufferSize
+        command, configSize, &pointer, &bufferSize
         ));
 
     buffer = pointer;
@@ -3315,10 +3445,43 @@ gckHARDWARE_SetMMUv2(
 
     buffer[3] = address;
 
+    if (config2D)
+    {
+        /* LoadState(AQPipeSelect, 1), pipe. */
+        buffer[4]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        buffer[5] = 0x1;
+
+        buffer[6]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0061) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        buffer[7] = config;
+
+        buffer[8]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0060) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        buffer[9] = address;
+
+        /* LoadState(AQPipeSelect, 1), pipe. */
+        buffer[10]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        buffer[11] = 0x0;
+    }
+
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
         "Setup MMU: config=%08x, Safe Address=%08x\n.", config, address);
 
-    gcmkONERROR(gckCOMMAND_Execute(command, 16));
+    gcmkONERROR(gckCOMMAND_Execute(command, configSize));
 
     if (FromPower == gcvFALSE)
     {
@@ -3516,6 +3679,8 @@ gckHARDWARE_Flush(
     gctUINT32 flush = 0;
     gctUINT32_PTR logical = (gctUINT32_PTR) Logical;
     gceSTATUS status;
+    gctBOOL fcFlushStall;
+    gctUINT32 reserveBytes = 8;
 
     gcmkHEADER_ARG("Hardware=0x%x Flush=0x%x Logical=0x%x *Bytes=%lu",
                    Hardware, Flush, Logical, gcmOPT_VALUE(Bytes));
@@ -3526,6 +3691,16 @@ gckHARDWARE_Flush(
     /* Get current pipe. */
     pipe = Hardware->kernel->command->pipeSelect;
 
+    fcFlushStall
+        = ((((gctUINT32) (Hardware->identity.chipMinorFeatures1)) >> (0 ? 31:31) & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1)))))))
+        && (Flush == gcvFLUSH_ALL)
+        ;
+
+    if (fcFlushStall)
+    {
+        reserveBytes += 8;
+    }
+
     /* Flush 3D color cache. */
     if ((Flush & gcvFLUSH_COLOR) && (pipe == 0x0))
     {
@@ -3542,6 +3717,7 @@ gckHARDWARE_Flush(
     if ((Flush & gcvFLUSH_TEXTURE) && (pipe == 0x0))
     {
         flush |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)));
+        flush |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
     }
 
     /* Flush 2D cache. */
@@ -3565,7 +3741,7 @@ gckHARDWARE_Flush(
         /* Copy to command queue. */
         if (Logical != gcvNULL)
         {
-            if (*Bytes < 8)
+            if (*Bytes < reserveBytes)
             {
                 /* Command queue too small. */
                 gcmkONERROR(gcvSTATUS_BUFFER_TOO_SMALL);
@@ -3580,12 +3756,26 @@ gckHARDWARE_Flush(
 
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                            "0x%x: FLUSH 0x%x", logical, flush);
+
+            if (fcFlushStall)
+            {
+                logical[2] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                           | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0594) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                           | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+                logical[3] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+
+                gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                               "0x%x: FLUSH 0x%x", logical + 3, logical[3]);
+            }
+
         }
 
         if (Bytes != gcvNULL)
         {
-            /* 8 bytes required. */
-            *Bytes = 8;
+            /* bytes required. */
+            *Bytes = reserveBytes;
         }
     }
 
@@ -4300,6 +4490,48 @@ gckHARDWARE_SetPowerManagementState(
         }
     }
 
+    /* Flush Cache before Power Off. */
+    if (flag & gcvPOWER_FLAG_POWER_OFF)
+    {
+        if (Hardware->clockState == gcvFALSE)
+        {
+            /* Turn off the GPU power. */
+            gcmkONERROR(
+                    gckOS_SetGPUPower(os,
+                        Hardware->core,
+                        gcvTRUE,
+                        gcvTRUE));
+
+            Hardware->clockState = gcvTRUE;
+
+            if (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_DYNAMIC_FREQUENCY_SCALING) != gcvTRUE)
+            {
+                /* Write the clock control register. */
+                gcmkONERROR(gckOS_WriteRegisterEx(os,
+                                                  Hardware->core,
+                                                  0x00000,
+                                                  clocks[0]));
+
+                /* Done loading the frequency scaler. */
+                gcmkONERROR(gckOS_WriteRegisterEx(os,
+                                                  Hardware->core,
+                                                  0x00000,
+                                                  ((((gctUINT32) (clocks[0])) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
+            }
+        }
+
+        gcmkONERROR(gckCOMMAND_Start(command));
+
+        gcmkONERROR(_FlushCache(Hardware, command));
+
+        gckOS_Delay(gcvNULL, 1);
+
+        /* Stop the command parser. */
+        gcmkONERROR(gckCOMMAND_Stop(command, gcvFALSE));
+
+        flag |= gcvPOWER_FLAG_CLOCK_OFF;
+    }
+
     /* Get time until stopped. */
     gcmkPROFILE_QUERY(time, stopTime);
 
@@ -4597,6 +4829,40 @@ gckHARDWARE_SetPowerManagement(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_SetGpuProfiler
+**
+**  Configure GPU profiler function.
+**  Only used in driver initialization stage.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctBOOL GpuProfiler
+**          GOU Profiler State.
+**
+*/
+gceSTATUS
+gckHARDWARE_SetGpuProfiler(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL GpuProfiler
+    )
+{
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    Hardware->gpuProfiler = GpuProfiler;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -5156,6 +5422,402 @@ OnError:
 }
 #endif
 
+#if VIVANTE_PROFILER_CONTEXT
+#define gcmkUPDATE_PROFILE_DATA(data) \
+    profilerHistroy->data += profiler->data
+
+gceSTATUS
+gckHARDWARE_QueryContextProfile(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL   Reset,
+    IN gckCONTEXT Context,
+    OUT gcsPROFILER_COUNTERS * Counters
+    )
+{
+    gceSTATUS status;
+    gckCOMMAND command = Hardware->kernel->command;
+    gcsPROFILER_COUNTERS * profiler = Counters;
+
+    gcmkHEADER_ARG("Hardware=0x%x Counters=0x%x", Hardware, Counters);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    /* Acquire the context sequnence mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(
+        command->os, command->mutexContextSeq, gcvINFINITE
+        ));
+
+    /* Read the counters. */
+    gcmkVERIFY_OK(gckOS_MemCopy(
+        profiler, &Context->histroyProfiler, gcmSIZEOF(gcsPROFILER_COUNTERS)
+        ));
+
+    if (Reset)
+    {
+        /* Reset counters. */
+        gcmkVERIFY_OK(gckOS_ZeroMemory(
+            &Context->histroyProfiler, gcmSIZEOF(gcsPROFILER_COUNTERS)
+            ));
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(
+        command->os, command->mutexContextSeq
+        ));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+
+gceSTATUS
+gckHARDWARE_UpdateContextProfile(
+    IN gckHARDWARE Hardware,
+    IN gckCONTEXT Context
+    )
+{
+    gceSTATUS status;
+    gcsPROFILER_COUNTERS * profiler = &Context->latestProfiler;
+    gcsPROFILER_COUNTERS * profilerHistroy = &Context->histroyProfiler;
+    gctUINT i, clock;
+    gctUINT32 colorKilled, colorDrawn, depthKilled, depthDrawn;
+    gctUINT32 totalRead, totalWrite;
+    gceCHIPMODEL chipModel;
+    gctUINT32 chipRevision;
+    gctUINT32 temp;
+    gctBOOL needResetShader = gcvFALSE;
+
+    gcmkHEADER_ARG("Hardware=0x%x Context=0x%x", Hardware, Context);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_OBJECT(Context, gcvOBJ_CONTEXT);
+
+    chipModel = Hardware->identity.chipModel;
+    chipRevision = Hardware->identity.chipRevision;
+    if (chipModel == gcv2000 || (chipModel == gcv2100 && chipRevision == 0x5118))
+    {
+        needResetShader = gcvTRUE;
+    }
+
+    /* Read the counters. */
+    gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00438,
+                             &profiler->gpuCyclesCounter));
+    gcmkUPDATE_PROFILE_DATA(gpuCyclesCounter);
+
+    gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00078,
+                             &profiler->gpuTotalCyclesCounter));
+    gcmkUPDATE_PROFILE_DATA(gpuTotalCyclesCounter);
+
+    gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x0007C,
+                             &profiler->gpuIdleCyclesCounter));
+    gcmkUPDATE_PROFILE_DATA(gpuIdleCyclesCounter);
+
+    /* Read clock control register. */
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &clock));
+
+    profiler->gpuTotalRead64BytesPerFrame = 0;
+    profiler->gpuTotalWrite64BytesPerFrame = 0;
+    profiler->pe_pixel_count_killed_by_color_pipe = 0;
+    profiler->pe_pixel_count_killed_by_depth_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_color_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_depth_pipe = 0;
+
+    /* Walk through all avaiable pixel pipes. */
+    for (i = 0; i < Hardware->identity.pixelPipes; ++i)
+    {
+        /* Select proper pipe. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                           Hardware->core,
+                                           0x00000,
+                                           ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20))) | (((gctUINT32) ((gctUINT32) (i) & ((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20)))));
+
+        /* BW */
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00040,
+                             &totalRead));
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00044,
+                             &totalWrite));
+
+        profiler->gpuTotalRead64BytesPerFrame += totalRead;
+        profiler->gpuTotalWrite64BytesPerFrame += totalWrite;
+        gcmkUPDATE_PROFILE_DATA(gpuTotalRead64BytesPerFrame);
+        gcmkUPDATE_PROFILE_DATA(gpuTotalWrite64BytesPerFrame);
+
+        /* PE */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorDrawn));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthDrawn));
+
+        profiler->pe_pixel_count_killed_by_color_pipe += colorKilled;
+        profiler->pe_pixel_count_killed_by_depth_pipe += depthKilled;
+        profiler->pe_pixel_count_drawn_by_color_pipe += colorDrawn;
+        profiler->pe_pixel_count_drawn_by_depth_pipe += depthDrawn;
+        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_color_pipe);
+        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_depth_pipe);
+        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_color_pipe);
+        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_depth_pipe);
+    }
+
+    /* Reset clock control register. */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      clock));
+
+
+
+
+    /* Reset counters. */
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
+));
+
+    /* SH */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->ps_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->ps_inst_counter;
+        profiler->ps_inst_counter -= Context->prevPSInstCount;
+        Context->prevPSInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(ps_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->rendered_pixel_counter));
+    if (needResetShader)
+    {
+        temp = profiler->rendered_pixel_counter;
+        profiler->rendered_pixel_counter -= Context->prevPSPixelCount;
+        Context->prevPSPixelCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(rendered_pixel_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vs_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->vs_inst_counter;
+        profiler->vs_inst_counter -= Context->prevVSInstCount;
+        Context->prevVSInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(vs_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->rendered_vertice_counter));
+    if (needResetShader)
+    {
+        temp = profiler->rendered_vertice_counter;
+        profiler->rendered_vertice_counter -= Context->prevVSVertexCount;
+        Context->prevVSVertexCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(rendered_vertice_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (11) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vtx_branch_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->vtx_branch_inst_counter;
+        profiler->vtx_branch_inst_counter -= Context->prevVSBranchInstCount;
+        Context->prevVSBranchInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(vtx_branch_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (12) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->vtx_texld_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->vtx_texld_inst_counter;
+        profiler->vtx_texld_inst_counter -= Context->prevVSTexInstCount;
+        Context->prevVSTexInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(vtx_texld_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (13) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_branch_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->pxl_branch_inst_counter;
+        profiler->pxl_branch_inst_counter -= Context->prevPSBranchInstCount;
+        Context->prevPSBranchInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(pxl_branch_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_texld_inst_counter));
+    if (needResetShader)
+    {
+        temp = profiler->pxl_texld_inst_counter;
+        profiler->pxl_texld_inst_counter -= Context->prevPSTexInstCount;
+        Context->prevPSTexInstCount = temp;
+    }
+    gcmkUPDATE_PROFILE_DATA(pxl_texld_inst_counter);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
+));
+
+    /* PA */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_input_vtx_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_input_vtx_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (4) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_input_prim_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_input_prim_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_output_prim_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_output_prim_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_depth_clipped_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_depth_clipped_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_trivial_rejected_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_trivial_rejected_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
+    gcmkUPDATE_PROFILE_DATA(pa_culled_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
+));
+
+    /* SE */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_triangle_count));
+    gcmkUPDATE_PROFILE_DATA(se_culled_triangle_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
+    gcmkUPDATE_PROFILE_DATA(se_culled_lines_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
+));
+
+    /* RA */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_pixel_count));
+    gcmkUPDATE_PROFILE_DATA(ra_valid_pixel_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_quad_count));
+    gcmkUPDATE_PROFILE_DATA(ra_total_quad_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_quad_count_after_early_z));
+    gcmkUPDATE_PROFILE_DATA(ra_valid_quad_count_after_early_z);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_primitive_count));
+    gcmkUPDATE_PROFILE_DATA(ra_total_primitive_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
+    gcmkUPDATE_PROFILE_DATA(ra_pipe_cache_miss_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
+    gcmkUPDATE_PROFILE_DATA(ra_prefetch_cache_miss_counter);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
+));
+
+    /* TX */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_bilinear_requests));
+    gcmkUPDATE_PROFILE_DATA(tx_total_bilinear_requests);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_trilinear_requests));
+    gcmkUPDATE_PROFILE_DATA(tx_total_trilinear_requests);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_discarded_texture_requests));
+    gcmkUPDATE_PROFILE_DATA(tx_total_discarded_texture_requests);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_total_texture_requests));
+    gcmkUPDATE_PROFILE_DATA(tx_total_texture_requests);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (5) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_mem_read_count));
+    gcmkUPDATE_PROFILE_DATA(tx_mem_read_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (6) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_mem_read_in_8B_count));
+    gcmkUPDATE_PROFILE_DATA(tx_mem_read_in_8B_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_count));
+    gcmkUPDATE_PROFILE_DATA(tx_cache_miss_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_hit_texel_count));
+    gcmkUPDATE_PROFILE_DATA(tx_cache_hit_texel_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
+    gcmkUPDATE_PROFILE_DATA(tx_cache_miss_texel_count);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
+));
+
+    /* MC */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_pipeline));
+    gcmkUPDATE_PROFILE_DATA(mc_total_read_req_8B_from_pipeline);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_IP));
+    gcmkUPDATE_PROFILE_DATA(mc_total_read_req_8B_from_IP);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
+    gcmkUPDATE_PROFILE_DATA(mc_total_write_req_8B_from_pipeline);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
+));
+
+    /* HI */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_read_request_stalled));
+    gcmkUPDATE_PROFILE_DATA(hi_axi_cycles_read_request_stalled);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_request_stalled));
+    gcmkUPDATE_PROFILE_DATA(hi_axi_cycles_write_request_stalled);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
+    gcmkUPDATE_PROFILE_DATA(hi_axi_cycles_write_data_stalled);
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
+));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
 static gceSTATUS
 _ResetGPU(
     IN gckHARDWARE Hardware,
@@ -5617,6 +6279,22 @@ gckHARDWARE_IsFeatureAvailable(
             &&      ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
         break;
 
+    case gcvFEATURE_PIPE_2D:
+        available = ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 9:9) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1)))))));
+        break;
+
+    case gcvFEATURE_PIPE_3D:
+#ifndef VIVANTE_NO_3D
+        available = ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
+#else
+        available = gcvFALSE;
+#endif
+        break;
+
+    case gcvFEATURE_HALTI2:
+        available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures4)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))));
+        break;
+
     default:
         gcmkFATAL("Invalid feature has been requested.");
         available = gcvFALSE;
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
index 37226b7..287ea60 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
@@ -92,6 +92,7 @@ struct _gckHARDWARE
 #endif
 
     gctBOOL                     powerManagement;
+    gctBOOL                     gpuProfiler;
 };
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index b7b0d28..12a5340 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -128,19 +128,6 @@ _ResetFinishFunction(
 **          Pointer to a variable that will hold the pointer to the gckKERNEL
 **          object.
 */
-#ifdef ANDROID
-#if gcdNEW_PROFILER_FILE
-#define DEFAULT_PROFILE_FILE_NAME   "/sdcard/vprofiler.vpd"
-#else
-#define DEFAULT_PROFILE_FILE_NAME   "/sdcard/vprofiler.xml"
-#endif
-#else
-#if gcdNEW_PROFILER_FILE
-#define DEFAULT_PROFILE_FILE_NAME   "vprofiler.vpd"
-#else
-#define DEFAULT_PROFILE_FILE_NAME   "vprofiler.xml"
-#endif
-#endif
 
 gceSTATUS
 gckKERNEL_Construct(
@@ -302,17 +289,12 @@ gckKERNEL_Construct(
 
 #if VIVANTE_PROFILER
     /* Initialize profile setting */
-#if defined ANDROID
     kernel->profileEnable = gcvFALSE;
-#else
-    kernel->profileEnable = gcvTRUE;
-#endif
     kernel->profileCleanRegister = gcvTRUE;
+#endif
 
-    gcmkVERIFY_OK(
-        gckOS_MemCopy(kernel->profileFileName,
-                      DEFAULT_PROFILE_FILE_NAME,
-                      gcmSIZEOF(DEFAULT_PROFILE_FILE_NAME) + 1));
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    gcmkONERROR(gckOS_CreateSyncTimeline(Os, &kernel->timeline));
 #endif
 
     /* Return pointer to the gckKERNEL object. */
@@ -395,6 +377,13 @@ OnError:
         }
 #endif
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+        if (kernel->timeline)
+        {
+            gcmkVERIFY_OK(gckOS_DestroySyncTimeline(Os, kernel->timeline));
+        }
+#endif
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel));
     }
 
@@ -525,6 +514,10 @@ gckKERNEL_Destroy(
     }
 #endif
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    gcmkVERIFY_OK(gckOS_DestroySyncTimeline(Kernel->os, Kernel->timeline));
+#endif
+
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -1310,7 +1303,8 @@ gckKERNEL_Dispatch(
         /* Commit a command and context buffer. */
         gcmkONERROR(
             gckCOMMAND_Commit(Kernel->command,
-                              gcmNAME_TO_PTR(Interface->u.Commit.context),
+                              Interface->u.Commit.context ?
+                                  gcmNAME_TO_PTR(Interface->u.Commit.context) : gcvNULL,
                               gcmUINT64_TO_PTR(Interface->u.Commit.commandBuffer),
                               gcmUINT64_TO_PTR(Interface->u.Commit.delta),
                               gcmUINT64_TO_PTR(Interface->u.Commit.queue),
@@ -1600,7 +1594,15 @@ gckKERNEL_Dispatch(
         break;
 
     case gcvHAL_READ_ALL_PROFILE_REGISTERS:
-#if VIVANTE_PROFILER
+#if VIVANTE_PROFILER && VIVANTE_PROFILER_CONTEXT
+        /* Read profile data according to the context. */
+        gcmkONERROR(
+            gckHARDWARE_QueryContextProfile(
+                Kernel->hardware,
+                Kernel->profileCleanRegister,
+                gcmNAME_TO_PTR(Interface->u.RegisterProfileData.context),
+                &Interface->u.RegisterProfileData.counters));
+#elif VIVANTE_PROFILER
         /* Read all 3D profile registers. */
         gcmkONERROR(
             gckHARDWARE_QueryProfileRegisters(
@@ -1628,11 +1630,6 @@ gckKERNEL_Dispatch(
 #if VIVANTE_PROFILER
         /* Get profile setting */
         Interface->u.GetProfileSetting.enable = Kernel->profileEnable;
-
-        gcmkVERIFY_OK(
-            gckOS_MemCopy(Interface->u.GetProfileSetting.fileName,
-                          Kernel->profileFileName,
-                          gcdMAX_PROFILE_FILE_NAME));
 #endif
 
         status = gcvSTATUS_OK;
@@ -1640,12 +1637,13 @@ gckKERNEL_Dispatch(
     case gcvHAL_SET_PROFILE_SETTING:
 #if VIVANTE_PROFILER
         /* Set profile setting */
-        Kernel->profileEnable = Interface->u.SetProfileSetting.enable;
-
-        gcmkVERIFY_OK(
-            gckOS_MemCopy(Kernel->profileFileName,
-                          Interface->u.SetProfileSetting.fileName,
-                          gcdMAX_PROFILE_FILE_NAME));
+        if(Kernel->hardware->gpuProfiler)
+            Kernel->profileEnable = Interface->u.SetProfileSetting.enable;
+        else
+        {
+            status = gcvSTATUS_NOT_SUPPORTED;
+            break;
+        }
 #endif
 
         status = gcvSTATUS_OK;
@@ -2093,6 +2091,61 @@ gckKERNEL_Dispatch(
 #endif
         break;
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    case gcvHAL_SYNC_POINT:
+        {
+            gctSYNC_POINT syncPoint;
+
+            switch (Interface->u.SyncPoint.command)
+            {
+            case gcvSYNC_POINT_CREATE:
+                gcmkONERROR(gckOS_CreateSyncPoint(Kernel->os, &syncPoint));
+
+                Interface->u.SyncPoint.syncPoint = gcmPTR_TO_UINT64(syncPoint);
+
+                gcmkVERIFY_OK(
+                    gckKERNEL_AddProcessDB(Kernel,
+                                           processID, gcvDB_SYNC_POINT,
+                                           syncPoint,
+                                           gcvNULL,
+                                           0));
+                break;
+
+            case gcvSYNC_POINT_DESTROY:
+                syncPoint = gcmUINT64_TO_PTR(Interface->u.SyncPoint.syncPoint);
+
+                gcmkONERROR(gckOS_DestroySyncPoint(Kernel->os, syncPoint));
+
+                gcmkVERIFY_OK(
+                    gckKERNEL_RemoveProcessDB(Kernel,
+                                              processID, gcvDB_SYNC_POINT,
+                                              syncPoint));
+                break;
+
+            default:
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+                break;
+            }
+        }
+        break;
+
+    case gcvHAL_CREATE_NATIVE_FENCE:
+        {
+            gctINT fenceFD;
+            gctSYNC_POINT syncPoint =
+                gcmUINT64_TO_PTR(Interface->u.CreateNativeFence.syncPoint);
+
+            gcmkONERROR(
+                gckOS_CreateNativeFence(Kernel->os,
+                                        Kernel->timeline,
+                                        syncPoint,
+                                        &fenceFD));
+
+            Interface->u.CreateNativeFence.fenceFD = fenceFD;
+        }
+        break;
+#endif
+
     default:
         /* Invalid command. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -2856,6 +2909,8 @@ gckKERNEL_Recovery(
         return gcvSTATUS_OK;
     }
 
+    gcmkPRINT("[galcore]: GPU[%d] hang, automatic recovery.", Kernel->core);
+
     /* Start a timer to clear reset flag, before timer is expired,
     ** other recovery request is ignored. */
     gcmkVERIFY_OK(
@@ -3382,7 +3437,7 @@ gckLINKQUEUE_Dequeue(
     IN gckLINKQUEUE LinkQueue
     )
 {
-    gcmASSERT(LinkQueue->count == gcdLINK_QUEUE_SIZE);
+    gcmkASSERT(LinkQueue->count == gcdLINK_QUEUE_SIZE);
 
     LinkQueue->count--;
     LinkQueue->front = (LinkQueue->front + 1) % gcdLINK_QUEUE_SIZE;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 5896e93..1c40df2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -140,8 +140,9 @@ typedef enum _gceDATABASE_TYPE
     gcvDB_CONTEXT,                      /* Context */
     gcvDB_IDLE,                         /* GPU idle. */
     gcvDB_MAP_MEMORY,                   /* Map memory */
-    gcvDB_SHARED_INFO,                 /* Private data */
-    gcvDB_MAP_USER_MEMORY               /* Map user memory */
+    gcvDB_SHARED_INFO,                  /* Private data */
+    gcvDB_MAP_USER_MEMORY,              /* Map user memory */
+    gcvDB_SYNC_POINT,                   /* Sync point. */
 }
 gceDATABASE_TYPE;
 
@@ -406,9 +407,6 @@ struct _gckKERNEL
     /* Enable profiling */
     gctBOOL                     profileEnable;
 
-    /* The profile file name */
-    gctCHAR                     profileFileName[gcdMAX_PROFILE_FILE_NAME];
-
     /* Clear profile register or not*/
     gctBOOL                     profileCleanRegister;
 
@@ -445,6 +443,10 @@ struct _gckKERNEL
 #if gcdDVFS
     gckDVFS                     dvfs;
 #endif
+
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    gctHANDLE                   timeline;
+#endif
 };
 
 struct _FrequencyHistory
@@ -496,6 +498,11 @@ struct _gckCOMMAND
     /* Context switching mutex. */
     gctPOINTER                  mutexContext;
 
+#if VIVANTE_PROFILER_CONTEXT
+    /* Context sequence mutex. */
+    gctPOINTER                  mutexContextSeq;
+#endif
+
     /* Command queue power semaphore. */
     gctPOINTER                  powerSemaphore;
 
@@ -649,6 +656,8 @@ struct _gckEVENT
     gctPOINTER                  eventListMutex;
 
     gctPOINTER                  submitTimer;
+
+    volatile gctBOOL            inNotify;
 };
 
 /* Free all events belonging to a process. */
@@ -668,6 +677,11 @@ gckEVENT_Stop(
 	IN OUT gctSIZE_T * waitSize
     );
 
+gceSTATUS
+gckEVENT_WaitEmpty(
+    IN gckEVENT Event
+    );
+
 /* gcuVIDMEM_NODE structure. */
 typedef union _gcuVIDMEM_NODE
 {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index 9ee9ea1..73dab81 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -494,6 +494,11 @@ gckCOMMAND_Construct(
     /* Create the context switching mutex. */
     gcmkONERROR(gckOS_CreateMutex(os, &command->mutexContext));
 
+#if VIVANTE_PROFILER_CONTEXT
+    /* Create the context switching mutex. */
+    gcmkONERROR(gckOS_CreateMutex(os, &command->mutexContextSeq));
+#endif
+
     /* Create the power management semaphore. */
     gcmkONERROR(gckOS_CreateSemaphore(os, &command->powerSemaphore));
 
@@ -572,6 +577,13 @@ OnError:
             gcmkVERIFY_OK(gckOS_DeleteMutex(os, command->mutexContext));
         }
 
+#if VIVANTE_PROFILER_CONTEXT
+        if (command->mutexContextSeq != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_DeleteMutex(os, command->mutexContextSeq));
+        }
+#endif
+
         if (command->mutexQueue != gcvNULL)
         {
             gcmkVERIFY_OK(gckOS_DeleteMutex(os, command->mutexQueue));
@@ -662,6 +674,11 @@ gckCOMMAND_Destroy(
     /* Delete the context switching mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexContext));
 
+#if VIVANTE_PROFILER_CONTEXT
+    if (Command->mutexContextSeq != gcvNULL)
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexContextSeq));
+#endif
+
     /* Delete the command queue mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexQueue));
 
@@ -1127,6 +1144,10 @@ gckCOMMAND_Commit(
 # endif
 #endif
 
+#if VIVANTE_PROFILER_CONTEXT
+    gctBOOL sequenceAcquired = gcvFALSE;
+#endif
+
     gctPOINTER pointer = gcvNULL;
 
     gcmkHEADER_ARG(
@@ -1145,6 +1166,17 @@ gckCOMMAND_Commit(
 
     gcmkONERROR(_FlushMMU(Command));
 
+#if VIVANTE_PROFILER_CONTEXT
+    if((Command->kernel->hardware->gpuProfiler) && (Command->kernel->profileEnable))
+    {
+        /* Acquire the context sequnence mutex. */
+        gcmkONERROR(gckOS_AcquireMutex(
+            Command->os, Command->mutexContextSeq, gcvINFINITE
+            ));
+        sequenceAcquired = gcvTRUE;
+    }
+#endif
+
     /* Acquire the command queue. */
     gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
     commitEntered = gcvTRUE;
@@ -2002,6 +2034,23 @@ gckCOMMAND_Commit(
     gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
     commitEntered = gcvFALSE;
 
+#if VIVANTE_PROFILER_CONTEXT
+    if(sequenceAcquired)
+    {
+        gcmkONERROR(gckCOMMAND_Stall(Command, gcvTRUE));
+        if (Command->currContext)
+        {
+            gcmkONERROR(gckHARDWARE_UpdateContextProfile(
+                hardware,
+                Command->currContext));
+        }
+
+        /* Release the context switching mutex. */
+        gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexContextSeq));
+        sequenceAcquired = gcvFALSE;
+    }
+#endif
+
     /* Loop while there are records in the queue. */
     while (EventQueue != gcvNULL)
     {
@@ -2114,6 +2163,14 @@ OnError:
         gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
     }
 
+#if VIVANTE_PROFILER_CONTEXT
+    if (sequenceAcquired)
+    {
+        /* Release the context sequence mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Command->os, Command->mutexContextSeq));
+    }
+#endif
+
     /* Unmap the command buffer pointer. */
     if (commandBufferMapped)
     {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index 76c1c10..1a7c340 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -2819,6 +2819,7 @@ gckVGCOMMAND_Construct(
         ** Enable TS overflow interrupt.
         */
 
+        command->info.tsOverflowInt = 0;
         gcmkERR_BREAK(gckVGINTERRUPT_Enable(
             Kernel->interrupt,
             &command->info.tsOverflowInt,
@@ -3406,38 +3407,26 @@ gckVGCOMMAND_Commit(
         gctBOOL previousExecuted;
         gctUINT controlIndex;
 
+        gcmkERR_BREAK(gckVGHARDWARE_SetPowerManagementState(
+            Command->hardware, gcvPOWER_ON_AUTO
+            ));
+
+        /* Acquire the power semaphore. */
+        gcmkERR_BREAK(gckOS_AcquireSemaphore(
+            Command->os, Command->powerSemaphore
+            ));
+
         /* Acquire the mutex. */
-        gcmkERR_BREAK(gckOS_AcquireMutex(
+        status = gckOS_AcquireMutex(
             Command->os,
             Command->commitMutex,
             gcvINFINITE
-            ));
-
-        status = gckVGHARDWARE_SetPowerManagementState(
-            Command->hardware, gcvPOWER_ON_AUTO);
-
-        if (gcmIS_ERROR(status))
-        {
-            /* Acquire the mutex. */
-            gcmkVERIFY_OK(gckOS_ReleaseMutex(
-                Command->os,
-                Command->commitMutex
-                ));
-
-            break;
-        }
-            /* Acquire the power semaphore. */
-        status = gckOS_AcquireSemaphore(
-            Command->os, Command->powerSemaphore);
+            );
 
         if (gcmIS_ERROR(status))
         {
-            /* Acquire the mutex. */
-            gcmkVERIFY_OK(gckOS_ReleaseMutex(
-                Command->os,
-                Command->commitMutex
-                ));
-
+            gcmkVERIFY_OK(gckOS_ReleaseSemaphore(
+                Command->os, Command->powerSemaphore));
             break;
         }
 
@@ -3669,14 +3658,14 @@ gckVGCOMMAND_Commit(
         }
         while (gcvFALSE);
 
-        gcmkVERIFY_OK(gckOS_ReleaseSemaphore(
-            Command->os, Command->powerSemaphore));
-
         /* Release the mutex. */
         gcmkCHECK_STATUS(gckOS_ReleaseMutex(
             Command->os,
             Command->commitMutex
             ));
+
+        gcmkVERIFY_OK(gckOS_ReleaseSemaphore(
+            Command->os, Command->powerSemaphore));
     }
     while (gcvFALSE);
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index 673d4f7..134351a 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -1307,6 +1307,18 @@ gckKERNEL_DestroyProcessDB(
             status = gckOS_FreeMemory(Kernel->os, record->physical);
             break;
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+        case gcvDB_SYNC_POINT:
+            /* Free the user signal. */
+            status = gckOS_DestroySyncPoint(Kernel->os,
+                                            (gctSYNC_POINT) record->data);
+
+            gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
+                           "DB: SYNC POINT %d (status=%d)",
+                           (gctINT)(gctUINTPTR_T)record->data, status);
+            break;
+#endif
+
         default:
             gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DATABASE,
                            "DB: Correcupted record=0x%08x type=%d",
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index 217f7f1..2d81a56 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -931,6 +931,7 @@ gckEVENT_AddList(
         || (Interface->command == gcvHAL_TIMESTAMP)
         || (Interface->command == gcvHAL_COMMIT_DONE)
         || (Interface->command == gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER)
+        || (Interface->command == gcvHAL_SYNC_POINT)
         );
 
     /* Validate the source. */
@@ -2131,6 +2132,9 @@ gckEVENT_Notify(
                                        gcvINFINITE));
         acquired = gcvTRUE;
 
+        /* We are in the notify loop. */
+        Event->inNotify = gcvTRUE;
+
         /* Grab the event head. */
         record = queue->head;
 
@@ -2463,6 +2467,17 @@ gckEVENT_Notify(
                  break;
 #endif
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+            case gcvHAL_SYNC_POINT:
+                {
+                    gctSYNC_POINT syncPoint;
+
+                    syncPoint = gcmUINT64_TO_PTR(record->info.u.SyncPoint.syncPoint);
+                    status = gckOS_SignalSyncPoint(Event->os, syncPoint);
+                }
+                break;
+#endif
+
             case gcvHAL_COMMIT_DONE:
                 break;
 
@@ -2505,6 +2520,9 @@ gckEVENT_Notify(
         gcmkONERROR(_TryToIdleGPU(Event));
     }
 
+    /* We are out the notify loop. */
+    Event->inNotify = gcvFALSE;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -2524,6 +2542,9 @@ OnError:
     }
 #endif
 
+    /* We are out the notify loop. */
+    Event->inNotify = gcvFALSE;
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -2871,3 +2892,11 @@ gckEVENT_Dump(
     return gcvSTATUS_OK;
 }
 
+gceSTATUS gckEVENT_WaitEmpty(gckEVENT Event)
+{
+    gctBOOL isEmpty;
+
+    while (Event->inNotify || (gcmIS_SUCCESS(gckEVENT_IsEmpty(Event, &isEmpty)) && !isEmpty)) ;
+
+    return gcvSTATUS_OK;
+}
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
index 8ac187b..50bc63e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
@@ -794,6 +794,9 @@ gckVGINTERRUPT_Enque(
             Interrupt->kernel->hardware, &triggered
             ));
 
+        /* Mask out TS overflow interrupt */
+        triggered &= 0xfffffffe;
+
         /* No interrupts to process? */
         if (triggered == 0)
         {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index c7f67c7..e4ca497 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -1436,7 +1436,7 @@ gckMMU_AllocatePages(
     acquired = gcvTRUE;
 
     /* Allocate page table for current MMU. */
-    for (i = 0; i < mirrorPageTable->reference; i++)
+    for (i = 0; i < (gctINT)mirrorPageTable->reference; i++)
     {
         if (Mmu == mirrorPageTable->mmus[i])
         {
@@ -1446,7 +1446,7 @@ gckMMU_AllocatePages(
     }
 
     /* Allocate page table for other MMUs. */
-    for (i = 0; i < mirrorPageTable->reference; i++)
+    for (i = 0; i < (gctINT)mirrorPageTable->reference; i++)
     {
         mmu = mirrorPageTable->mmus[i];
 
@@ -1500,7 +1500,7 @@ gckMMU_FreePages(
 
     offset = (gctUINT32)PageTable - (gctUINT32)Mmu->pageTableLogical;
 
-    for (i = 0; i < mirrorPageTable->reference; i++)
+    for (i = 0; i < (gctINT)mirrorPageTable->reference; i++)
     {
         mmu = mirrorPageTable->mmus[i];
 
@@ -1639,7 +1639,7 @@ gckMMU_SetPage(
     _WritePageEntry(PageEntry, data);
 
 #if gcdMIRROR_PAGETABLE
-    for (i = 0; i < mirrorPageTable->reference; i++)
+    for (i = 0; i < (gctINT)mirrorPageTable->reference; i++)
     {
         mmu = mirrorPageTable->mmus[i];
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index 8b8bbdc..3b5dd82 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -1582,6 +1582,7 @@ _NeedVirtualMapping(
     gctUINT32 end;
     gcePOOL pool;
     gctUINT32 offset;
+    gctUINT32 baseAddress;
 
     gcmkHEADER_ARG("Node=0x%X", Node);
 
@@ -1601,10 +1602,16 @@ _NeedVirtualMapping(
         else
 #endif
         {
-            /* For cores which can't access all physical address. */
-            gcmkONERROR(gckHARDWARE_ConvertLogical(Kernel->hardware,
-                        Node->Virtual.logical,
-                        &phys));
+            /* Convert logical address into a physical address. */
+            gcmkONERROR(
+                gckOS_GetPhysicalAddress(Kernel->os, Node->Virtual.logical, &phys));
+
+            gcmkONERROR(gckOS_GetBaseAddress(Kernel->os, &baseAddress));
+
+            gcmkASSERT(phys >= baseAddress);
+
+            /* Subtract baseAddress to get a GPU address used for programming. */
+            phys -= baseAddress;
 
             /* If part of region is belong to gcvPOOL_VIRTUAL,
             ** whole region has to be mapped. */
@@ -1734,6 +1741,11 @@ gckVIDMEM_Lock(
         gcmkONERROR(gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
         acquired = gcvTRUE;
 
+#if gcdPAGED_MEMORY_CACHEABLE
+        /* Force video memory cacheable. */
+        Cacheable = gcvTRUE;
+#endif
+
         gcmkONERROR(
             gckOS_LockPages(os,
                             Node->Virtual.physical,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index 4406d7e..7312cc2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -123,6 +123,12 @@ extern "C" {
 
 #define gcvINVALID_ADDRESS          ~0U
 
+#define gcmGET_PRE_ROTATION(rotate) \
+    ((rotate) & (~(gcvSURF_POST_FLIP_X | gcvSURF_POST_FLIP_Y)))
+
+#define gcmGET_POST_ROTATION(rotate) \
+    ((rotate) & (gcvSURF_POST_FLIP_X | gcvSURF_POST_FLIP_Y))
+
 /******************************************************************************\
 ******************************** gcsOBJECT Object *******************************
 \******************************************************************************/
@@ -1124,6 +1130,60 @@ gckOS_UnmapUserMemory(
     IN gctUINT32 Address
     );
 
+/******************************************************************************\
+************************** Android Native Fence Sync ***************************
+\******************************************************************************/
+gceSTATUS
+gckOS_CreateSyncTimeline(
+    IN gckOS Os,
+    OUT gctHANDLE * Timeline
+    );
+
+gceSTATUS
+gckOS_DestroySyncTimeline(
+    IN gckOS Os,
+    IN gctHANDLE Timeline
+    );
+
+gceSTATUS
+gckOS_CreateSyncPoint(
+    IN gckOS Os,
+    OUT gctSYNC_POINT * SyncPoint
+    );
+
+gceSTATUS
+gckOS_ReferenceSyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    );
+
+gceSTATUS
+gckOS_DestroySyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    );
+
+gceSTATUS
+gckOS_SignalSyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    );
+
+gceSTATUS
+gckOS_QuerySyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint,
+    OUT gctBOOL_PTR State
+    );
+
+gceSTATUS
+gckOS_CreateNativeFence(
+    IN gckOS Os,
+    IN gctHANDLE Timeline,
+    IN gctSYNC_POINT SyncPoint,
+    OUT gctINT * FenceFD
+    );
+
 #if !USE_NEW_LINUX_SIGNAL
 /* Create signal to be used in the user space. */
 gceSTATUS
@@ -1758,7 +1818,7 @@ gckKERNEL_Recovery(
 void
 gckKERNEL_SetTimeOut(
     IN gckKERNEL Kernel,
-	IN gctUINT32 timeOut
+    IN gctUINT32 timeOut
     );
 
 /* Get access to the user data. */
@@ -2078,6 +2138,12 @@ gckHARDWARE_SetPowerManagement(
     IN gctBOOL PowerManagement
     );
 
+gceSTATUS
+gckHARDWARE_SetGpuProfiler(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL GpuProfiler
+    );
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -2554,6 +2620,22 @@ gckHARDWARE_QueryProfileRegisters(
     );
 #endif
 
+#if VIVANTE_PROFILER_CONTEXT
+gceSTATUS
+gckHARDWARE_QueryContextProfile(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL   Clear,
+    IN gckCONTEXT Context,
+    OUT gcsPROFILER_COUNTERS * Counters
+    );
+
+gceSTATUS
+gckHARDWARE_UpdateContextProfile(
+    IN gckHARDWARE Hardware,
+    IN gckCONTEXT Context
+    );
+#endif
+
 gceSTATUS
 gckOS_SignalQueryHardware(
     IN gckOS Os,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 926de6e..9c17114 100755
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -71,10 +71,17 @@ typedef struct _gcoFENCE *              gcoFENCE;
 typedef struct _gcsSYNC_CONTEXT  *      gcsSYNC_CONTEXT_PTR;
 #endif
 
+typedef struct _gcoOS_SymbolsList gcoOS_SymbolsList;
+
 /******************************************************************************\
 ******************************* Process local storage *************************
 \******************************************************************************/
 typedef struct _gcsPLS * gcsPLS_PTR;
+
+typedef void (* gctPLS_DESTRUCTOR) (
+    gcsPLS_PTR
+    );
+
 typedef struct _gcsPLS
 {
     /* Global objects. */
@@ -103,6 +110,12 @@ typedef struct _gcsPLS
 
     /* PorcessID of the constrcutor process */
     gctUINT32                   processID;
+#if gcdFORCE_GAL_LOAD_TWICE
+    /* ThreadID of the constrcutor process. */
+    gctSIZE_T                   threadID;
+    /* Flag for calling module destructor. */
+    gctBOOL                     exiting;
+#endif
 
     /* Reference count for destructor. */
     gcsATOM_PTR                 reference;
@@ -111,6 +124,8 @@ typedef struct _gcsPLS
     gctBOOL                     bNeedSupportNP2Texture;
 #endif
 
+    /* Destructor for eglDisplayInfo. */
+    gctPLS_DESTRUCTOR           destructor;
 }
 gcsPLS;
 
@@ -148,6 +163,11 @@ typedef struct _gcsTLS
 #endif
 	gco2D						engine2D;
     gctBOOL                     copied;
+
+#if gcdFORCE_GAL_LOAD_TWICE
+    /* libGAL.so handle */
+    gctHANDLE                   handle;
+#endif
 }
 gcsTLS;
 
@@ -160,6 +180,7 @@ typedef enum _gcePLS_VALUE
   gcePLS_VALUE_EGL_DISPLAY_INFO,
   gcePLS_VALUE_EGL_SURFACE_INFO,
   gcePLS_VALUE_EGL_CONFIG_FORMAT_INFO,
+  gcePLS_VALUE_EGL_DESTRUCTOR_INFO,
 }
 gcePLS_VALUE;
 
@@ -577,6 +598,12 @@ gcoHAL_Call(
     IN OUT gcsHAL_INTERFACE_PTR Interface
     );
 
+gceSTATUS
+gcoHAL_GetPatchID(
+    IN  gcoHAL Hal,
+    OUT gcePATCH_ID * PatchID
+    );
+
 /* Schedule an event. */
 gceSTATUS
 gcoHAL_ScheduleEvent(
@@ -637,6 +664,16 @@ gcoHAL_QuerySeparated3D2D(
     IN gcoHAL Hal
     );
 
+gceSTATUS
+gcoHAL_QuerySpecialHint(
+    IN gceSPECIAL_HINT Hint
+    );
+
+gceSTATUS
+gcoHAL_SetSpecialHintData(
+    IN gcoHARDWARE Hardware
+    );
+
 /* Get pointer to gcoVG object. */
 gceSTATUS
 gcoHAL_GetVGEngine(
@@ -786,7 +823,6 @@ gcoOS_FreeVideoMemory(
     IN gctPOINTER Handle
     );
 
-#if gcdENABLE_BANK_ALIGNMENT
 gceSTATUS
 gcoSURF_GetBankOffsetBytes(
     IN gcoSURF Surfce,
@@ -794,7 +830,6 @@ gcoSURF_GetBankOffsetBytes(
     IN gctUINT32 Stride,
     IN gctUINT32_PTR Bytes
     );
-#endif
 
 /* Map user memory. */
 gceSTATUS
@@ -918,6 +953,21 @@ gcoOS_Flush(
     IN gctFILE File
     );
 
+/* Close a file descriptor. */
+gceSTATUS
+gcoOS_CloseFD(
+    IN gcoOS Os,
+    IN gctINT FD
+    );
+
+/* Dup file descriptor to another. */
+gceSTATUS
+gcoOS_DupFD(
+    IN gcoOS Os,
+    IN gctINT FD,
+    OUT gctINT * FD2
+    );
+
 /* Create an endpoint for communication. */
 gceSTATUS
 gcoOS_Socket(
@@ -977,6 +1027,14 @@ gcoOS_GetEnv(
     OUT gctSTRING * Value
     );
 
+/* Set environment variable value. */
+gceSTATUS
+gcoOS_SetEnv(
+    IN gcoOS Os,
+    IN gctCONST_STRING VarName,
+    IN gctSTRING Value
+    );
+
 /* Get current working directory. */
 gceSTATUS
 gcoOS_GetCwd(
@@ -1210,6 +1268,13 @@ gcoOS_DetectProcessByEncryptedName(
     IN gctCONST_STRING Name
     );
 
+#if defined(ANDROID)
+gceSTATUS
+gcoOS_DetectProgrameByEncryptedSymbols(
+    IN gcoOS_SymbolsList Symbols
+    );
+#endif
+
 /*----------------------------------------------------------------------------*/
 /*----- Atoms ----------------------------------------------------------------*/
 
@@ -1403,6 +1468,42 @@ gcoOS_UnmapSignal(
     IN gctSIGNAL Signal
     );
 
+/*----------------------------------------------------------------------------*/
+/*----- Android Native Fence -------------------------------------------------*/
+
+/* Create sync point. */
+gceSTATUS
+gcoOS_CreateSyncPoint(
+    IN gcoOS Os,
+    OUT gctSYNC_POINT * SyncPoint
+    );
+
+/* Destroy sync point. */
+gceSTATUS
+gcoOS_DestroySyncPoint(
+    IN gcoOS Os,
+    IN gctSYNC_POINT SyncPoint
+    );
+
+/* Create native fence. */
+gceSTATUS
+gcoOS_CreateNativeFence(
+    IN gcoOS Os,
+    IN gctSYNC_POINT SyncPoint,
+    OUT gctINT * FenceFD
+    );
+
+/* Wait on native fence. */
+gceSTATUS
+gcoOS_WaitNativeFence(
+    IN gcoOS Os,
+    IN gctINT FenceFD,
+    IN gctUINT32 Timeout
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Memory Access and Cache ----------------------------------------------*/
+
 /* Write a register. */
 gceSTATUS
 gcoOS_WriteRegister(
@@ -1579,6 +1680,28 @@ typedef struct _gcsRECT
 }
 gcsRECT;
 
+typedef union _gcsPIXEL
+{
+    struct
+    {
+        gctFLOAT r, g, b, a;
+        gctFLOAT d, s;
+    } pf;
+
+    struct
+    {
+        gctINT32 r, g, b, a;
+        gctINT32 d, s;
+    } pi;
+
+    struct
+    {
+        gctUINT32 r, g, b, a;
+        gctUINT32 d, s;
+    } pui;
+
+} gcsPIXEL;
+
 
 /******************************************************************************\
 ********************************* gcoSURF Object ********************************
@@ -1795,6 +1918,18 @@ gcoSURF_SetRotation(
     );
 
 gceSTATUS
+gcoSURF_SetPreRotation(
+    IN gcoSURF Surface,
+    IN gceSURF_ROTATION Rotation
+    );
+
+gceSTATUS
+gcoSURF_GetPreRotation(
+    IN gcoSURF Surface,
+    IN gceSURF_ROTATION *Rotation
+    );
+
+gceSTATUS
 gcoSURF_IsValid(
     IN gcoSURF Surface
     );
@@ -1824,6 +1959,15 @@ gcoSURF_DisableTileStatus(
     IN gcoSURF Surface,
     IN gctBOOL Decompress
     );
+
+gceSTATUS
+gcoSURF_AlignResolveRect(
+    IN gcoSURF Surf,
+    IN gcsPOINT_PTR RectOrigin,
+    IN gcsPOINT_PTR RectSize,
+    OUT gcsPOINT_PTR AlignedOrigin,
+    OUT gcsPOINT_PTR AlignedSize
+    );
 #endif /* VIVANTE_NO_3D */
 
 /* Get surface size. */
@@ -1910,6 +2054,9 @@ gcoSURF_FillFromTile(
     IN gcoSURF Surface
     );
 
+/* Check if surface needs a filler. */
+gceSTATUS gcoSURF_NeedFiller(IN gcoSURF Surface);
+
 /* Fill surface with a value. */
 gceSTATUS
 gcoSURF_Fill(
@@ -1949,6 +2096,19 @@ gcoSURF_SetBuffer(
     IN gctUINT32 Physical
     );
 
+/* Set the underlying video buffer for the surface wrapper. */
+gceSTATUS
+gcoSURF_SetVideoBuffer(
+    IN gcoSURF Surface,
+    IN gceSURF_TYPE Type,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Stride,
+    IN gctPOINTER *LogicalPlane1,
+    IN gctUINT32 *PhysicalPlane1
+    );
+
 /* Set the size of the surface in pixels and map the underlying buffer. */
 gceSTATUS
 gcoSURF_SetWindow(
@@ -3705,6 +3865,12 @@ gcGetUserDebugOption(
     void
     );
 
+struct _gcoOS_SymbolsList
+{
+    gcePATCH_ID patchId;
+    const char * symList[10];
+};
+
 #if gcdHAS_ELLIPSES
 #define gcmUSER_DEBUG_MSG(level, ...) \
     do \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
index 8693c37..062224c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
@@ -39,12 +39,10 @@ extern "C" {
 #define GC_ENABLE_LOADTIME_OPT           1
 #endif
 
-#define TEMP_OPT_CONSTANT_TEXLD_COORD    1
+#define TEMP_OPT_CONSTANT_TEXLD_COORD    0
 
 #define TEMP_SHADER_PATCH                1
 
-#define ADD_PRE_ROTATION_TO_VS           0
-
 #define TEMP_INLINE_ALL_EXPANSION            1
 /******************************* IR VERSION ******************/
 #define gcdSL_IR_VERSION gcmCC('\0','\0','\0','\1')
@@ -271,6 +269,7 @@ typedef enum _gcSL_OPCODE
 	gcSL_ADDSAT,						/* 0x5C */  /* Integer only. */
 	gcSL_SUBSAT,						/* 0x5D */  /* Integer only. */
 	gcSL_MULSAT,						/* 0x5E */  /* Integer only. */
+	gcSL_DP2,							/* 0x5F */
 	gcSL_MAXOPCODE
 }
 gcSL_OPCODE;
@@ -474,6 +473,9 @@ struct _gcsHINT
 
     gctBOOL     clipW;
 
+    /* Flag whether or not the shader has a KILL instruction. */
+    gctBOOL     hasKill;
+
     /* Element count. */
     gctUINT32   elementCount;
 
@@ -495,12 +497,18 @@ struct _gcsHINT
     /* Balance maximum. */
     gctUINT32   balanceMax;
 
+    /* Auto-shift balancing. */
+    gctBOOL     autoShift;
+
     /* Flag whether the PS outputs the depth value or not. */
     gctBOOL     psHasFragDepthOut;
 
 	/* Flag whether the ThreadWalker is in PS. */
 	gctBOOL		threadWalkerInPS;
 
+    /* HW reg number for position of VS */
+    gctUINT32   hwRegNoOfSIVPos;
+
 #if gcdALPHA_KILL_IN_SHADER
     /* States to set when alpha kill is enabled. */
     gctUINT32   killStateAddress;
@@ -687,12 +695,12 @@ typedef enum _gceSHADER_FLAGS
     gcvSHADER_USE_ALPHA_KILL            = 0x100,
 #endif
 
-#if ADD_PRE_ROTATION_TO_VS
+#if gcdPRE_ROTATION && (ANDROID_SDK_VERSION >= 14)
     gcvSHADER_VS_PRE_ROTATION           = 0x200,
 #endif
 
 #if TEMP_INLINE_ALL_EXPANSION
-    gcvSHADER_INLINE_ALL_EXPANSION      = 0x200,
+    gcvSHADER_INLINE_ALL_EXPANSION      = 0x400,
 #endif
 }
 gceSHADER_FLAGS;
@@ -827,6 +835,7 @@ typedef struct _gcOPTIMIZER_OPTION
     gctBOOL     dumpOptimizerVerbose;  /* dump result IR in each optimization phase */
     gctBOOL     dumpBEGenertedCode;    /* dump generated machine code */
     gctBOOL     dumpBEVerbose;         /* dump BE tree and optimization detail */
+    gctBOOL     dumpBEFinalIR;         /* dump BE final IR */
 
     /* Code generation */
 
@@ -945,6 +954,8 @@ extern gcOPTIMIZER_OPTION theOptimizerOption;
               gcmOPT_DUMP_CODEGEN_VERBOSE() )
 #define gcmOPT_DUMP_CODEGEN_VERBOSE()    \
              (gcmGetOptimizerOption()->dumpBEVerbose != 0)
+#define gcmOPT_DUMP_FINAL_IR()    \
+             (gcmGetOptimizerOption()->dumpBEFinalIR != 0)
 
 #define gcmOPT_SET_DUMP_SHADER_SRC(v)   \
              gcmGetOptimizerOption()->dumpShaderSource = (v)
@@ -1064,6 +1075,13 @@ typedef struct _gcNPOT_PATCH_PARAM
     gctINT               texDimension;    /* 2 or 3 */
 }gcNPOT_PATCH_PARAM, *gcNPOT_PATCH_PARAM_PTR;
 
+typedef struct _gcZBIAS_PATCH_PARAM
+{
+    /* Driver uses this to program uniform that designating zbias */
+    gctINT               uniformAddr;
+    gctINT               channel;
+}gcZBIAS_PATCH_PARAM, *gcZBIAS_PATCH_PARAM_PTR;
+
 void
 gcGetOptionFromEnv(
     IN OUT gcOPTIMIZER_OPTION * Option
@@ -1556,6 +1574,43 @@ gcSHADER_AddUniform(
 	OUT gcUNIFORM * Uniform
 	);
 
+/*******************************************************************************
+**							   gcSHADER_AddPreRotationUniform
+********************************************************************************
+**
+**	Add an uniform to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the uniform to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the uniform to add.
+**
+**		gctSIZE_T Length
+**			Array length of the uniform to add.  'Length' must be at least 1.
+**
+**		gctINT col
+**			Which uniform.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM * Uniform
+**			Pointer to a variable receiving the gcUNIFORM object pointer.
+*/
+gceSTATUS
+gcSHADER_AddPreRotationUniform(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+	IN gctSIZE_T Length,
+    IN gctINT col,
+	OUT gcUNIFORM * Uniform
+	);
 
 /*******************************************************************************
 **							   gcSHADER_AddUniformEx
@@ -1677,6 +1732,28 @@ gcSHADER_GetUniformCount(
 	);
 
 /*******************************************************************************
+**                         gcSHADER_GetPreRotationUniform
+********************************************************************************
+**
+**	Get the preRotate Uniform.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM ** pUniform
+**			Pointer to a preRotation uniforms array.
+*/
+gceSTATUS
+gcSHADER_GetPreRotationUniform(
+	IN gcSHADER Shader,
+	OUT gcUNIFORM ** pUniform
+	);
+
+/*******************************************************************************
 **                             gcSHADER_GetUniform
 ********************************************************************************
 **
@@ -3438,6 +3515,34 @@ gcUNIFORM_SetValueF(
 	);
 
 /*******************************************************************************
+**  gcUNIFORM_ProgramF
+**
+**  Set the value of a uniform in floating point.
+**
+**  INPUT:
+**
+**      gctUINT32 Address
+**          Address of Uniform.
+**
+**      gctSIZE_T Row/Col
+**
+**      const gctFLOAT * Value
+**          Pointer to a buffer holding the floating point values for the
+**          uniform.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcUNIFORM_ProgramF(
+    IN gctUINT32 Address,
+    IN gctSIZE_T Row,
+    IN gctSIZE_T Col,
+    IN const gctFLOAT * Value
+    );
+
+/*******************************************************************************
 **						 gcUNIFORM_GetModelViewProjMatrix
 ********************************************************************************
 **
@@ -3912,6 +4017,23 @@ gcRecompileShaders(
     IN gctUINT32 *SamplerWrapS,
     IN gctUINT32 *SamplerWrapT
     );
+
+gceSTATUS
+gcRecompileDepthBias(
+    IN gcoHAL Hal,
+    IN gcMACHINECODE_PTR pVsMachineCode,
+    /*Recompile variables*/
+    IN OUT gctPOINTER *ppRecompileStateBuffer,
+    IN OUT gctSIZE_T *pRecompileStateBufferSize,
+    IN OUT gcsHINT_PTR *ppRecompileHints,
+    /* natvie state*/
+    IN gctPOINTER pNativeStateBuffer,
+    IN gctSIZE_T nativeStateBufferSize,
+    IN gcsHINT_PTR pNativeHints,
+	OUT gctINT * uniformAddr,
+	OUT gctINT * uniformChannel
+    );
+
 /*******************************************************************************
 **                                gcSaveProgram
 ********************************************************************************
@@ -4138,6 +4260,16 @@ gcSHADER_PatchNPOTForMachineCode(
     IN OUT gcsHINT_PTR            pHints /* User needs copy original hints to this one, then passed this one in */
     );
 
+gceSTATUS
+gcSHADER_PatchZBiasForMachineCodeVS(
+    IN     gcMACHINECODE_PTR       pMachineCode,
+    IN OUT gcZBIAS_PATCH_PARAM_PTR pPatchParam,
+    IN     gctUINT                 hwSupportedInstCount,
+    OUT    gctPOINTER*             ppCmdBuffer,
+    OUT    gctUINT32*              pByteSizeOfCmdBuffer,
+    IN OUT gcsHINT_PTR             pHints /* User needs copy original hints to this one, then passed this one in */
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index b056c52..fc8c395 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -166,6 +166,12 @@ typedef enum _gceHAL_COMMAND_CODES
 
     /* Reset time stamp. */
     gcvHAL_QUERY_RESET_TIME_STAMP,
+
+    /* Sync point operations. */
+    gcvHAL_SYNC_POINT,
+
+    /* Create native fence and return its fd. */
+    gcvHAL_CREATE_NATIVE_FENCE,
 }
 gceHAL_COMMAND_CODES;
 
@@ -723,6 +729,10 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_READ_ALL_PROFILE_REGISTERS */
         struct _gcsHAL_READ_ALL_PROFILE_REGISTERS
         {
+#if VIVANTE_PROFILER_CONTEXT
+            /* Context buffer object gckCONTEXT. Just a name. */
+            IN gctUINT32                context;
+#endif
             /* Data read. */
             OUT gcsPROFILER_COUNTERS    counters;
         }
@@ -978,6 +988,33 @@ typedef struct _gcsHAL_INTERFACE
             OUT gctUINT64           timeStamp;
         }
         QueryResetTimeStamp;
+
+        struct _gcsHAL_SYNC_POINT
+        {
+            /* Command. */
+            gceSYNC_POINT_COMMAND_CODES command;
+
+            /* Sync point. */
+            IN OUT gctUINT64            syncPoint;
+
+            /* From where. */
+            IN gceKERNEL_WHERE          fromWhere;
+
+            /* Signaled state. */
+            OUT gctBOOL                 state;
+        }
+        SyncPoint;
+
+        struct _gcsHAL_CREATE_NATIVE_FENCE
+        {
+            /* Signal id to dup. */
+            IN gctUINT64                syncPoint;
+
+            /* Native fence file descriptor. */
+            OUT gctINT                  fenceFD;
+
+        }
+        CreateNativeFence;
     }
     u;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 8481375..3fb2fe4 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -323,6 +323,15 @@ gcoSURF_Resolve(
     IN gcoSURF DestSurface
     );
 
+gceSTATUS
+gcoSURF_IsHWResolveable(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
+    IN gcsPOINT_PTR SrcOrigin,
+    IN gcsPOINT_PTR DestOrigin,
+    IN gcsPOINT_PTR RectSize
+    );
+
 /* Resolve rectangular area of a surface. */
 gceSTATUS
 gcoSURF_ResolveRect(
@@ -345,6 +354,11 @@ gcoSURF_IsRenderable(
     IN gcoSURF Surface
     );
 
+gceSTATUS
+gcoSURF_IsFormatRenderableAsRT(
+    IN gcoSURF Surface
+    );
+
 #if gcdSYNC
 gceSTATUS
 gcoSURF_GetFence(
@@ -1006,6 +1020,7 @@ typedef struct _gcsALPHA_INFO
     gctBOOL                 test;
     gceCOMPARE              compare;
     gctUINT8                reference;
+    gctFLOAT                floatReference;
 
     /* Alpha blending states. */
     gctBOOL                 blend;
@@ -1040,7 +1055,8 @@ gco3D_SetAlphaCompare(
 gceSTATUS
 gco3D_SetAlphaReference(
     IN gco3D Engine,
-    IN gctUINT8 Reference
+    IN gctUINT8 Reference,
+    IN gctFLOAT FloatReference
     );
 
 /* Set alpha test reference in fixed point. */
@@ -1504,6 +1520,19 @@ gcoTEXTURE_UploadSub(
     IN gceSURF_FORMAT Format
     );
 
+/* Upload YUV data to an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_UploadYUV(
+    IN gcoTEXTURE Texture,
+    IN gceTEXTURE_FACE Face,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Slice,
+    IN gctPOINTER Memory[3],
+    IN gctINT Stride[3],
+    IN gceSURF_FORMAT Format
+    );
+
 /* Upload compressed data to an gcoTEXTURE object. */
 gceSTATUS
 gcoTEXTURE_UploadCompressed(
@@ -1621,6 +1650,13 @@ gcoTEXTURE_QueryCaps(
     );
 
 gceSTATUS
+gcoTEXTURE_GetTiling(
+    IN gcoTEXTURE Texture,
+    IN gctINT preferLevel,
+	OUT gceTILING * Tiling
+    );
+
+gceSTATUS
 gcoTEXTURE_GetClosestFormat(
     IN gcoHAL Hal,
     IN gceSURF_FORMAT InFormat,
@@ -2001,6 +2037,14 @@ gcoHAL_SetSharedInfo(
     IN gctSIZE_T Bytes
     );
 
+#if VIVANTE_PROFILER_CONTEXT
+gceSTATUS
+gcoHARDWARE_GetContext(
+    IN gcoHARDWARE Hardware,
+    OUT gctUINT32 * Context
+    );
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index a1d9ae5..8e3c2f8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -146,10 +146,26 @@ typedef enum _gceFEATURE
     gcvFEATURE_FRUSTUM_CLIP_FIX,
     gcvFEATURE_TEXTURE_LINEAR,
     gcvFEATURE_TEXTURE_YUV_ASSEMBLER,
+    gcvFEATURE_SHADER_HAS_INSTRUCTION_CACHE,
     gcvFEATURE_DYNAMIC_FREQUENCY_SCALING,
     gcvFEATURE_BUGFIX15,
+    gcvFEATURE_2D_GAMMA,
+    gcvFEATURE_2D_COLOR_SPACE_CONVERSION,
+    gcvFEATURE_2D_SUPER_TILE_VERSION,
     gcvFEATURE_2D_MIRROR_EXTENSION,
+    gcvFEATURE_2D_SUPER_TILE_V1,
+    gcvFEATURE_2D_SUPER_TILE_V2,
+    gcvFEATURE_2D_SUPER_TILE_V3,
+    gcvFEATURE_2D_MULTI_SOURCE_BLT_EX2,
     gcvFEATURE_ELEMENT_INDEX_UINT,
+    gcvFEATURE_2D_COMPRESSION,
+    gcvFEATURE_2D_OPF_YUV_OUTPUT,
+    gcvFEATURE_2D_MULTI_SRC_BLT_TO_UNIFIED_DST_RECT,
+    gcvFEATURE_2D_YUV_MODE,
+    gcvFEATURE_DECOMPRESS_Z16,
+	gcvFEATURE_LINEAR_RENDER_TARGET,
+    gcvFEATURE_BUG_FIXES8,
+    gcvFEATURE_HALTI2,
 }
 gceFEATURE;
 
@@ -203,11 +219,14 @@ typedef enum _gceSURF_TYPE
     gcvSURF_NO_VIDMEM      = 0x200, /* Used to allocate surfaces with no underlying vidmem node.
                                        In Android, vidmem node is allocated by another process. */
     gcvSURF_CACHEABLE      = 0x400, /* Used to allocate a cacheable surface */
-#if gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
     gcvSURF_FLIP           = 0x800, /* The Resolve Target the will been flip resolve from RT */
-#endif
     gcvSURF_TILE_STATUS_DIRTY  = 0x1000, /* Init tile status to all dirty */
 
+    gcvSURF_LINEAR             = 0x2000,
+
+    gcvSURF_TEXTURE_LINEAR               = gcvSURF_TEXTURE
+                                         | gcvSURF_LINEAR,
+
     gcvSURF_RENDER_TARGET_NO_TILE_STATUS = gcvSURF_RENDER_TARGET
                                          | gcvSURF_NO_TILE_STATUS,
 
@@ -217,6 +236,9 @@ typedef enum _gceSURF_TYPE
     gcvSURF_DEPTH_NO_TILE_STATUS         = gcvSURF_DEPTH
                                          | gcvSURF_NO_TILE_STATUS,
 
+    gcvSURF_DEPTH_TS_DIRTY               = gcvSURF_DEPTH
+                                         | gcvSURF_TILE_STATUS_DIRTY,
+
     /* Supported surface types with no vidmem node. */
     gcvSURF_BITMAP_NO_VIDMEM             = gcvSURF_BITMAP
                                          | gcvSURF_NO_VIDMEM,
@@ -231,10 +253,8 @@ typedef enum _gceSURF_TYPE
     gcvSURF_CACHEABLE_BITMAP             = gcvSURF_BITMAP
                                          | gcvSURF_CACHEABLE,
 
-#if gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
     gcvSURF_FLIP_BITMAP                  = gcvSURF_BITMAP
                                          | gcvSURF_FLIP,
-#endif
 }
 gceSURF_TYPE;
 
@@ -263,6 +283,9 @@ typedef enum _gceSURF_ROTATION
     gcvSURF_270_DEGREE,
     gcvSURF_FLIP_X,
     gcvSURF_FLIP_Y,
+
+	gcvSURF_POST_FLIP_X = 0x40000000,
+    gcvSURF_POST_FLIP_Y = 0x80000000,
 }
 gceSURF_ROTATION;
 
@@ -622,21 +645,16 @@ gce2D_PORTER_DUFF_RULE;
 typedef enum _gce2D_YUV_COLOR_MODE
 {
     gcv2D_YUV_601= 0,
-    gcv2D_YUV_709
-}
-gce2D_YUV_COLOR_MODE;
+    gcv2D_YUV_709,
+    gcv2D_YUV_USER_DEFINED,
+    gcv2D_YUV_USER_DEFINED_CLAMP,
 
-/* 2D Rotation and flipping. */
-typedef enum _gce2D_ORIENTATION
-{
-    gcv2D_0_DEGREE = 0,
-    gcv2D_90_DEGREE,
-    gcv2D_180_DEGREE,
-    gcv2D_270_DEGREE,
-    gcv2D_X_FLIP,
-    gcv2D_Y_FLIP
+    /* Default setting is for src. gcv2D_YUV_DST
+        can be ORed to set dst.
+    */
+    gcv2D_YUV_DST = 0x80000000,
 }
-gce2D_ORIENTATION;
+gce2D_YUV_COLOR_MODE;
 
 typedef enum _gce2D_COMMAND
 {
@@ -656,21 +674,39 @@ typedef enum _gce2D_TILE_STATUS_CONFIG
     gcv2D_TSC_ENABLE        = 0x00000001,
     gcv2D_TSC_COMPRESSED    = 0x00000002,
     gcv2D_TSC_DOWN_SAMPLER  = 0x00000004,
+    gcv2D_TSC_2D_COMPRESSED = 0x00000008,
 }
 gce2D_TILE_STATUS_CONFIG;
 
 typedef enum _gce2D_QUERY
 {
-    gcv2D_QUERY_RGB_ADDRESS_MAX_ALIGN       = 0,
-    gcv2D_QUERY_RGB_STRIDE_MAX_ALIGN,
-    gcv2D_QUERY_YUV_ADDRESS_MAX_ALIGN,
-    gcv2D_QUERY_YUV_STRIDE_MAX_ALIGN,
+    gcv2D_QUERY_RGB_ADDRESS_MIN_ALIGN       = 0,
+    gcv2D_QUERY_RGB_STRIDE_MIN_ALIGN,
+    gcv2D_QUERY_YUV_ADDRESS_MIN_ALIGN,
+    gcv2D_QUERY_YUV_STRIDE_MIN_ALIGN,
 }
 gce2D_QUERY;
 
+typedef enum _gce2D_SUPER_TILE_VERSION
+{
+    gcv2D_SUPER_TILE_VERSION_V1       = 1,
+    gcv2D_SUPER_TILE_VERSION_V2       = 2,
+    gcv2D_SUPER_TILE_VERSION_V3       = 3,
+}
+gce2D_SUPER_TILE_VERSION;
+
 typedef enum _gce2D_STATE
 {
     gcv2D_STATE_SPECIAL_FILTER_MIRROR_MODE       = 1,
+    gcv2D_STATE_SUPER_TILE_VERSION,
+    gcv2D_STATE_EN_GAMMA,
+    gcv2D_STATE_DE_GAMMA,
+    gcv2D_STATE_MULTI_SRC_BLIT_UNIFIED_DST_RECT,
+
+    gcv2D_STATE_ARRAY_EN_GAMMA                   = 0x10001,
+    gcv2D_STATE_ARRAY_DE_GAMMA,
+    gcv2D_STATE_ARRAY_CSC_YUV_TO_RGB,
+    gcv2D_STATE_ARRAY_CSC_RGB_TO_YUV,
 }
 gce2D_STATE;
 
@@ -809,6 +845,15 @@ typedef enum _gceUSER_SIGNAL_COMMAND_CODES
 }
 gceUSER_SIGNAL_COMMAND_CODES;
 
+/* Sync point command codes. */
+typedef enum _gceSYNC_POINT_COMMAND_CODES
+{
+    gcvSYNC_POINT_CREATE,
+    gcvSYNC_POINT_DESTROY,
+    gcvSYNC_POINT_SIGNAL,
+}
+gceSYNC_POINT_COMMAND_CODES;
+
 /* Event locations. */
 typedef enum _gceKERNEL_WHERE
 {
@@ -848,6 +893,44 @@ typedef enum _gceDEBUG_MESSAGE_TYPE
 }
 gceDEBUG_MESSAGE_TYPE;
 
+typedef enum _gceSPECIAL_HINT
+{
+    gceSPECIAL_HINT0,
+    gceSPECIAL_HINT1,
+    gceSPECIAL_HINT2,
+    gceSPECIAL_HINT3,
+    /* For disable dynamic stream/index */
+    gceSPECIAL_HINT4
+}
+gceSPECIAL_HINT;
+
+typedef enum _gceMACHINECODE
+{
+    gcvMACHINECODE_HOVERJET0       = 0x0,
+    gcvMACHINECODE_HOVERJET1      ,
+
+    gcvMACHINECODE_TAIJI0         ,
+    gcvMACHINECODE_TAIJI1         ,
+    gcvMACHINECODE_TAIJI2         ,
+
+    gcvMACHINECODE_ANTUTU0        ,
+
+    gcvMACHINECODE_GLB27_RELEASE_0,
+    gcvMACHINECODE_GLB27_RELEASE_1,
+
+    gcvMACHINECODE_WAVESCAPE0     ,
+    gcvMACHINECODE_WAVESCAPE1     ,
+
+    gcvMACHINECODE_NENAMARKV2_4_0 ,
+    gcvMACHINECODE_NENAMARKV2_4_1 ,
+
+    gcvMACHINECODE_GLB25_RELEASE_0,
+    gcvMACHINECODE_GLB25_RELEASE_1,
+    gcvMACHINECODE_GLB25_RELEASE_2,
+}
+gceMACHINECODE;
+
+
 /******************************************************************************\
 ****************************** Object Declarations *****************************
 \******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index 9e2a8db..b53b618 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -46,7 +46,7 @@
         This define enables the profiler.
 */
 #ifndef VIVANTE_PROFILER
-#   define VIVANTE_PROFILER                     0
+#   define VIVANTE_PROFILER                     1
 #endif
 
 #ifndef VIVANTE_PROFILER_PERDRAW
@@ -54,6 +54,15 @@
 #endif
 
 /*
+    VIVANTE_PROFILER_CONTEXT
+
+        This define enables the profiler according to each hw context.
+*/
+#ifndef VIVANTE_PROFILER_CONTEXT
+#   define VIVANTE_PROFILER_CONTEXT             1
+#endif
+
+/*
     gcdUSE_VG
 
         Enable VG HAL layer (only for GC350).
@@ -729,7 +738,24 @@
         Use linear buffer for GPU apps so HWC can do 2D composition.
 */
 #ifndef gcdGPU_LINEAR_BUFFER_ENABLED
-#   define gcdGPU_LINEAR_BUFFER_ENABLED         0
+#   define gcdGPU_LINEAR_BUFFER_ENABLED         1
+#endif
+
+/*
+    gcdENABLE_RENDER_INTO_WINDOW
+
+        Enable Render-Into-Window (ie, No-Resolve) feature on android.
+        NOTE that even if enabled, it still depends on hardware feature and
+        android application behavior. When hardware feature or application
+        behavior can not support render into window mode, it will fail back
+        to normal mode.
+        When Render-Into-Window is finally used, window back buffer of android
+        applications will be allocated matching render target tiling format.
+        Otherwise buffer tiling is decided by the above option
+        'gcdGPU_LINEAR_BUFFER_ENABLED'.
+*/
+#ifndef gcdENABLE_RENDER_INTO_WINDOW
+#   define gcdENABLE_RENDER_INTO_WINDOW         1
 #endif
 
 /*
@@ -758,7 +784,11 @@
 #endif
 
 #ifndef gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
-#   define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
+#   ifdef ANDROID
+#      define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    1
+#   else
+#      define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
+#   endif
 #endif
 
 #ifndef gcdENABLE_PE_DITHER_FIX
@@ -800,6 +830,10 @@
 #   define gcdDISALBE_EARLY_EARLY_Z             1
 #endif
 
+#ifndef gcdSHADER_SRC_BY_MACHINECODE
+#   define gcdSHADER_SRC_BY_MACHINECODE         1
+#endif
+
 /*
     gcdLINK_QUEUE_SIZE
 
@@ -849,11 +883,20 @@
 #define gcdUSE_NPOT_PATCH                       1
 #endif
 
-
 #ifndef gcdSYNC
 #   define gcdSYNC                              1
 #endif
 
+#ifndef gcdENABLE_SPECIAL_HINT3
+#   define gcdENABLE_SPECIAL_HINT3               1
+#endif
+
+#if defined(ANDROID)
+#ifndef gcdPRE_ROTATION
+#   define gcdPRE_ROTATION                      1
+#endif
+#endif
+
 /*
     gcdDVFS
 
@@ -866,4 +909,39 @@
 #   define gcdDVFS_POLLING_TIME                  (gcdDVFS_ANAYLSE_WINDOW * 4)
 #endif
 
+/*
+    gcdANDROID_NATIVE_FENCE_SYNC
+
+        Enable android native fence sync. It is introduced since jellybean-4.2.
+        Depends on linux kernel option: CONFIG_SYNC.
+
+        0: Disabled
+        1: Build framework for native fence sync feature, and EGL extension
+        2: Enable async swap buffers for client
+           * Native fence sync for client 'queueBuffer' in EGL, which is
+             'acquireFenceFd' for layer in compositor side.
+        3. Enable async hwcomposer composition.
+           * 'releaseFenceFd' for layer in compositor side, which is native
+             fence sync when client 'dequeueBuffer'
+           * Native fence sync for compositor 'queueBuffer' in EGL, which is
+             'acquireFenceFd' for framebuffer target for DC
+ */
+#ifndef gcdANDROID_NATIVE_FENCE_SYNC
+#   define gcdANDROID_NATIVE_FENCE_SYNC        0
+#endif
+
+#ifndef gcdFORCE_MIPMAP
+#   define gcdFORCE_MIPMAP                     0
+#endif
+
+/*
+    gcdFORCE_GAL_LOAD_TWICE
+
+        When non-zero, each thread except the main one will load libGAL.so twice to avoid potential segmetantion fault when app using dlopen/dlclose.
+        If threads exit arbitrarily, libGAL.so may not unload until the process quit.
+ */
+#ifndef gcdFORCE_GAL_LOAD_TWICE
+#   define gcdFORCE_GAL_LOAD_TWICE             0
+#endif
+
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index 3e450ba..aed73aa 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -45,509 +45,115 @@ extern "C" {
 #define gcdNEW_PROFILER_FILE    1
 #endif
 
-/* OpenGL ES11 API IDs. */
-#define	ES11_ACTIVETEXTURE				1
-#define	ES11_ALPHAFUNC					(ES11_ACTIVETEXTURE				+ 1)
-#define	ES11_ALPHAFUNCX					(ES11_ALPHAFUNC					+ 1)
-#define	ES11_BINDBUFFER					(ES11_ALPHAFUNCX 				+ 1)
-#define	ES11_BINDTEXTURE				(ES11_BINDBUFFER 				+ 1)
-#define	ES11_BLENDFUNC					(ES11_BINDTEXTURE				+ 1)
-#define	ES11_BUFFERDATA					(ES11_BLENDFUNC					+ 1)
-#define	ES11_BUFFERSUBDATA				(ES11_BUFFERDATA				+ 1)
-#define	ES11_CLEAR						(ES11_BUFFERSUBDATA				+ 1)
-#define	ES11_CLEARCOLOR					(ES11_CLEAR						+ 1)
-#define	ES11_CLEARCOLORX				(ES11_CLEARCOLOR				+ 1)
-#define	ES11_CLEARDEPTHF				(ES11_CLEARCOLORX 				+ 1)
-#define	ES11_CLEARDEPTHX				(ES11_CLEARDEPTHF 				+ 1)
-#define	ES11_CLEARSTENCIL				(ES11_CLEARDEPTHX 				+ 1)
-#define	ES11_CLIENTACTIVETEXTURE    	(ES11_CLEARSTENCIL				+ 1)
-#define	ES11_CLIPPLANEF      			(ES11_CLIENTACTIVETEXTURE		+ 1)
-#define	ES11_CLIPPLANEX      			(ES11_CLIPPLANEF       			+ 1)
-#define	ES11_COLOR4F 					(ES11_CLIPPLANEX       			+ 1)
-#define	ES11_COLOR4UB        			(ES11_COLOR4F					+ 1)
-#define	ES11_COLOR4X 					(ES11_COLOR4UB					+ 1)
-#define	ES11_COLORMASK       			(ES11_COLOR4X					+ 1)
-#define	ES11_COLORPOINTER    			(ES11_COLORMASK        			+ 1)
-#define	ES11_COMPRESSEDTEXIMAGE2D   	(ES11_COLORPOINTER     			+ 1)
-#define	ES11_COMPRESSEDTEXSUBIMAGE2D	(ES11_COMPRESSEDTEXIMAGE2D    	+ 1)
-#define	ES11_COPYTEXIMAGE2D  			(ES11_COMPRESSEDTEXSUBIMAGE2D 	+ 1)
-#define	ES11_COPYTEXSUBIMAGE2D      	(ES11_COPYTEXIMAGE2D   			+ 1)
-#define	ES11_CULLFACE        			(ES11_COPYTEXSUBIMAGE2D			+ 1)
-#define	ES11_DELETEBUFFERS   			(ES11_CULLFACE         			+ 1)
-#define	ES11_DELETETEXTURES  			(ES11_DELETEBUFFERS    			+ 1)
-#define	ES11_DEPTHFUNC       			(ES11_DELETETEXTURES   			+ 1)
-#define	ES11_DEPTHMASK       			(ES11_DEPTHFUNC        			+ 1)
-#define	ES11_DEPTHRANGEF     			(ES11_DEPTHMASK        			+ 1)
-#define	ES11_DEPTHRANGEX     			(ES11_DEPTHRANGEF      			+ 1)
-#define	ES11_DISABLE 					(ES11_DEPTHRANGEX      			+ 1)
-#define	ES11_DISABLECLIENTSTATE     	(ES11_DISABLE					+ 1)
-#define	ES11_DRAWARRAYS      			(ES11_DISABLECLIENTSTATE		+ 1)
-#define	ES11_DRAWELEMENTS    			(ES11_DRAWARRAYS       			+ 1)
-#define	ES11_ENABLE  					(ES11_DRAWELEMENTS     			+ 1)
-#define	ES11_ENABLECLIENTSTATE      	(ES11_ENABLE					+ 1)
-#define	ES11_FINISH  					(ES11_ENABLECLIENTSTATE			+ 1)
-#define	ES11_FLUSH   					(ES11_FINISH   					+ 1)
-#define	ES11_FOGF    					(ES11_FLUSH    					+ 1)
-#define	ES11_FOGFV   					(ES11_FOGF     					+ 1)
-#define	ES11_FOGX    					(ES11_FOGFV    					+ 1)
-#define	ES11_FOGXV   					(ES11_FOGX     					+ 1)
-#define	ES11_FRONTFACE       			(ES11_FOGXV    					+ 1)
-#define	ES11_FRUSTUMF        			(ES11_FRONTFACE        			+ 1)
-#define	ES11_FRUSTUMX        			(ES11_FRUSTUMF         			+ 1)
-#define	ES11_GENBUFFERS      			(ES11_FRUSTUMX         			+ 1)
-#define	ES11_GENTEXTURES     			(ES11_GENBUFFERS       			+ 1)
-#define	ES11_GETBOOLEANV     			(ES11_GENTEXTURES      			+ 1)
-#define	ES11_GETBUFFERPARAMETERIV   	(ES11_GETBOOLEANV      			+ 1)
-#define	ES11_GETCLIPPLANEF   			(ES11_GETBUFFERPARAMETERIV		+ 1)
-#define	ES11_GETCLIPPLANEX   			(ES11_GETCLIPPLANEF    			+ 1)
-#define	ES11_GETERROR        			(ES11_GETCLIPPLANEX    			+ 1)
-#define	ES11_GETFIXEDV       			(ES11_GETERROR         			+ 1)
-#define	ES11_GETFLOATV       			(ES11_GETFIXEDV        			+ 1)
-#define	ES11_GETINTEGERV     			(ES11_GETFLOATV        			+ 1)
-#define	ES11_GETLIGHTFV      			(ES11_GETINTEGERV      			+ 1)
-#define	ES11_GETLIGHTXV      			(ES11_GETLIGHTFV       			+ 1)
-#define	ES11_GETMATERIALFV   			(ES11_GETLIGHTXV       			+ 1)
-#define	ES11_GETMATERIALXV   			(ES11_GETMATERIALFV    			+ 1)
-#define	ES11_GETPOINTERV     			(ES11_GETMATERIALXV    			+ 1)
-#define	ES11_GETSTRING       			(ES11_GETPOINTERV      			+ 1)
-#define	ES11_GETTEXENVFV     			(ES11_GETSTRING        			+ 1)
-#define	ES11_GETTEXENVIV     			(ES11_GETTEXENVFV      			+ 1)
-#define	ES11_GETTEXENVXV     			(ES11_GETTEXENVIV      			+ 1)
-#define	ES11_GETTEXPARAMETERFV      	(ES11_GETTEXENVXV      			+ 1)
-#define	ES11_GETTEXPARAMETERIV      	(ES11_GETTEXPARAMETERFV       	+ 1)
-#define	ES11_GETTEXPARAMETERXV      	(ES11_GETTEXPARAMETERIV       	+ 1)
-#define	ES11_HINT    					(ES11_GETTEXPARAMETERXV       	+ 1)
-#define	ES11_ISBUFFER        			(ES11_HINT     					+ 1)
-#define	ES11_ISENABLED       			(ES11_ISBUFFER 			        + 1)
-#define	ES11_ISTEXTURE       			(ES11_ISENABLED			        + 1)
-#define	ES11_LIGHTF  					(ES11_ISTEXTURE			        + 1)
-#define	ES11_LIGHTFV 					(ES11_LIGHTF   					+ 1)
-#define	ES11_LIGHTMODELF     			(ES11_LIGHTFV  					+ 1)
-#define	ES11_LIGHTMODELFV    			(ES11_LIGHTMODELF      			+ 1)
-#define	ES11_LIGHTMODELX     			(ES11_LIGHTMODELFV     			+ 1)
-#define	ES11_LIGHTMODELXV    			(ES11_LIGHTMODELX      			+ 1)
-#define	ES11_LIGHTX  					(ES11_LIGHTMODELXV     			+ 1)
-#define	ES11_LIGHTXV 					(ES11_LIGHTX   					+ 1)
-#define	ES11_LINEWIDTH       			(ES11_LIGHTXV  					+ 1)
-#define	ES11_LINEWIDTHX      			(ES11_LINEWIDTH        			+ 1)
-#define	ES11_LOADIDENTITY    			(ES11_LINEWIDTHX       			+ 1)
-#define	ES11_LOADMATRIXF     			(ES11_LOADIDENTITY     			+ 1)
-#define	ES11_LOADMATRIXX     			(ES11_LOADMATRIXF      			+ 1)
-#define	ES11_LOGICOP 					(ES11_LOADMATRIXX      			+ 1)
-#define	ES11_MATERIALF       			(ES11_LOGICOP					+ 1)
-#define	ES11_MATERIALFV      			(ES11_MATERIALF        			+ 1)
-#define	ES11_MATERIALX       			(ES11_MATERIALFV       			+ 1)
-#define	ES11_MATERIALXV      			(ES11_MATERIALX        			+ 1)
-#define	ES11_MATRIXMODE      			(ES11_MATERIALXV       			+ 1)
-#define	ES11_MULTITEXCOORD4F 			(ES11_MATRIXMODE       			+ 1)
-#define	ES11_MULTITEXCOORD4X 			(ES11_MULTITEXCOORD4F  			+ 1)
-#define	ES11_MULTMATRIXF     			(ES11_MULTITEXCOORD4X  			+ 1)
-#define	ES11_MULTMATRIXX     			(ES11_MULTMATRIXF      			+ 1)
-#define	ES11_NORMAL3F        			(ES11_MULTMATRIXX      			+ 1)
-#define	ES11_NORMAL3X        			(ES11_NORMAL3F         			+ 1)
-#define	ES11_NORMALPOINTER   			(ES11_NORMAL3X         			+ 1)
-#define	ES11_ORTHOF  					(ES11_NORMALPOINTER    			+ 1)
-#define	ES11_ORTHOX  					(ES11_ORTHOF   					+ 1)
-#define	ES11_PIXELSTOREI     			(ES11_ORTHOX   					+ 1)
-#define	ES11_POINTPARAMETERF 			(ES11_PIXELSTOREI      			+ 1)
-#define	ES11_POINTPARAMETERFV    		(ES11_POINTPARAMETERF  			+ 1)
-#define	ES11_POINTPARAMETERX 			(ES11_POINTPARAMETERFV 			+ 1)
-#define	ES11_POINTPARAMETERXV    		(ES11_POINTPARAMETERX  			+ 1)
-#define	ES11_POINTSIZE       			(ES11_POINTPARAMETERXV 			+ 1)
-#define	ES11_POINTSIZEX      			(ES11_POINTSIZE        			+ 1)
-#define	ES11_POLYGONOFFSET   			(ES11_POINTSIZEX       			+ 1)
-#define	ES11_POLYGONOFFSETX  			(ES11_POLYGONOFFSET    			+ 1)
-#define	ES11_POPMATRIX       			(ES11_POLYGONOFFSETX   			+ 1)
-#define	ES11_PUSHMATRIX      			(ES11_POPMATRIX        			+ 1)
-#define	ES11_READPIXELS      			(ES11_PUSHMATRIX       			+ 1)
-#define	ES11_ROTATEF 					(ES11_READPIXELS       			+ 1)
-#define	ES11_ROTATEX 					(ES11_ROTATEF  					+ 1)
-#define	ES11_SAMPLECOVERAGE  			(ES11_ROTATEX  					+ 1)
-#define	ES11_SAMPLECOVERAGEX 			(ES11_SAMPLECOVERAGE   			+ 1)
-#define	ES11_SCALEF  					(ES11_SAMPLECOVERAGEX  			+ 1)
-#define	ES11_SCALEX  					(ES11_SCALEF   					+ 1)
-#define	ES11_SCISSOR 					(ES11_SCALEX   					+ 1)
-#define	ES11_SHADEMODEL      			(ES11_SCISSOR  					+ 1)
-#define	ES11_STENCILFUNC     			(ES11_SHADEMODEL       			+ 1)
-#define	ES11_STENCILMASK     			(ES11_STENCILFUNC      			+ 1)
-#define	ES11_STENCILOP       			(ES11_STENCILMASK      			+ 1)
-#define	ES11_TEXCOORDPOINTER 			(ES11_STENCILOP        			+ 1)
-#define	ES11_TEXENVF 					(ES11_TEXCOORDPOINTER  			+ 1)
-#define	ES11_TEXENVFV     				(ES11_TEXENVF					+ 1)
-#define	ES11_TEXENVI 					(ES11_TEXENVFV					+ 1)
-#define	ES11_TEXENVIV     				(ES11_TEXENVI  					+ 1)
-#define	ES11_TEXENVX 					(ES11_TEXENVIV 					+ 1)
-#define	ES11_TEXENVXV        			(ES11_TEXENVX  					+ 1)
-#define	ES11_TEXIMAGE2D      			(ES11_TEXENVXV         			+ 1)
-#define	ES11_TEXPARAMETERF   			(ES11_TEXIMAGE2D       			+ 1)
-#define	ES11_TEXPARAMETERFV  			(ES11_TEXPARAMETERF    			+ 1)
-#define	ES11_TEXPARAMETERI   			(ES11_TEXPARAMETERFV   			+ 1)
-#define	ES11_TEXPARAMETERIV  			(ES11_TEXPARAMETERI    			+ 1)
-#define	ES11_TEXPARAMETERX   			(ES11_TEXPARAMETERIV   			+ 1)
-#define	ES11_TEXPARAMETERXV  			(ES11_TEXPARAMETERX    			+ 1)
-#define	ES11_TEXSUBIMAGE2D   			(ES11_TEXPARAMETERXV   			+ 1)
-#define	ES11_TRANSLATEF      			(ES11_TEXSUBIMAGE2D    			+ 1)
-#define	ES11_TRANSLATEX      			(ES11_TRANSLATEF       			+ 1)
-#define	ES11_VERTEXPOINTER   			(ES11_TRANSLATEX       			+ 1)
-#define	ES11_VIEWPORT        			(ES11_VERTEXPOINTER    			+ 1)
-#define ES11_BLENDEQUATIONOES           (ES11_VIEWPORT         			+ 1)
-#define ES11_BLENDFUNCSEPERATEOES       (ES11_BLENDEQUATIONOES       	+ 1)
-#define ES11_BLENDEQUATIONSEPARATEOES   (ES11_BLENDFUNCSEPERATEOES    	+ 1)
-#define ES11_GLMAPBUFFEROES             (ES11_BLENDEQUATIONSEPARATEOES 	+ 1)
-#define ES11_GLUNMAPBUFFEROES           (ES11_GLMAPBUFFEROES     		+ 1)
-#define ES11_GLGETBUFFERPOINTERVOES     (ES11_GLUNMAPBUFFEROES         	+ 1)
-#define	ES11_CALLS   					(ES11_GLGETBUFFERPOINTERVOES   	+ 1)
-#define	ES11_DRAWCALLS       			(ES11_CALLS						+ 1)
-#define	ES11_STATECHANGECALLS    		(ES11_DRAWCALLS					+ 1)
-#define	ES11_POINTCOUNT      			(ES11_STATECHANGECALLS			+ 1)
-#define	ES11_LINECOUNT       			(ES11_POINTCOUNT       			+ 1)
-#define	ES11_TRIANGLECOUNT   			(ES11_LINECOUNT        			+ 1)
-
-/* OpenGL ES2X API IDs. */
-#define	ES20_ACTIVETEXTURE				1
-#define	ES20_ATTACHSHADER							(ES20_ACTIVETEXTURE							+	1)
-#define	ES20_BINDATTRIBLOCATION						(ES20_ATTACHSHADER							+	1)
-#define	ES20_BINDBUFFER								(ES20_BINDATTRIBLOCATION					+	1)
-#define	ES20_BINDFRAMEBUFFER						(ES20_BINDBUFFER							+	1)
-#define	ES20_BINDRENDERBUFFER						(ES20_BINDFRAMEBUFFER						+	1)
-#define	ES20_BINDTEXTURE							(ES20_BINDRENDERBUFFER						+	1)
-#define	ES20_BLENDCOLOR								(ES20_BINDTEXTURE							+	1)
-#define	ES20_BLENDEQUATION							(ES20_BLENDCOLOR							+	1)
-#define	ES20_BLENDEQUATIONSEPARATE					(ES20_BLENDEQUATION							+	1)
-#define	ES20_BLENDFUNC								(ES20_BLENDEQUATIONSEPARATE					+	1)
-#define	ES20_BLENDFUNCSEPARATE						(ES20_BLENDFUNC								+	1)
-#define	ES20_BUFFERDATA								(ES20_BLENDFUNCSEPARATE						+	1)
-#define	ES20_BUFFERSUBDATA							(ES20_BUFFERDATA							+	1)
-#define	ES20_CHECKFRAMEBUFFERSTATUS					(ES20_BUFFERSUBDATA							+	1)
-#define	ES20_CLEAR									(ES20_CHECKFRAMEBUFFERSTATUS				+	1)
-#define	ES20_CLEARCOLOR								(ES20_CLEAR									+	1)
-#define	ES20_CLEARDEPTHF							(ES20_CLEARCOLOR							+	1)
-#define	ES20_CLEARSTENCIL							(ES20_CLEARDEPTHF							+	1)
-#define	ES20_COLORMASK								(ES20_CLEARSTENCIL							+	1)
-#define	ES20_COMPILESHADER							(ES20_COLORMASK								+	1)
-#define	ES20_COMPRESSEDTEXIMAGE2D					(ES20_COMPILESHADER							+	1)
-#define	ES20_COMPRESSEDTEXSUBIMAGE2D				(ES20_COMPRESSEDTEXIMAGE2D					+	1)
-#define	ES20_COPYTEXIMAGE2D							(ES20_COMPRESSEDTEXSUBIMAGE2D				+	1)
-#define	ES20_COPYTEXSUBIMAGE2D						(ES20_COPYTEXIMAGE2D						+	1)
-#define	ES20_CREATEPROGRAM							(ES20_COPYTEXSUBIMAGE2D						+	1)
-#define	ES20_CREATESHADER							(ES20_CREATEPROGRAM							+	1)
-#define	ES20_CULLFACE								(ES20_CREATESHADER							+	1)
-#define	ES20_DELETEBUFFERS							(ES20_CULLFACE								+	1)
-#define	ES20_DELETEFRAMEBUFFERS						(ES20_DELETEBUFFERS							+	1)
-#define	ES20_DELETEPROGRAM							(ES20_DELETEFRAMEBUFFERS					+	1)
-#define	ES20_DELETERENDERBUFFERS					(ES20_DELETEPROGRAM							+	1)
-#define	ES20_DELETESHADER							(ES20_DELETERENDERBUFFERS					+	1)
-#define	ES20_DELETETEXTURES							(ES20_DELETESHADER							+	1)
-#define	ES20_DEPTHFUNC								(ES20_DELETETEXTURES						+	1)
-#define	ES20_DEPTHMASK								(ES20_DEPTHFUNC								+	1)
-#define	ES20_DEPTHRANGEF							(ES20_DEPTHMASK								+	1)
-#define	ES20_DETACHSHADER							(ES20_DEPTHRANGEF							+	1)
-#define	ES20_DISABLE								(ES20_DETACHSHADER							+	1)
-#define	ES20_DISABLEVERTEXATTRIBARRAY				(ES20_DISABLE								+	1)
-#define	ES20_DRAWARRAYS								(ES20_DISABLEVERTEXATTRIBARRAY				+	1)
-#define	ES20_DRAWELEMENTS							(ES20_DRAWARRAYS							+	1)
-#define	ES20_ENABLE									(ES20_DRAWELEMENTS							+	1)
-#define	ES20_ENABLEVERTEXATTRIBARRAY				(ES20_ENABLE								+	1)
-#define	ES20_FINISH									(ES20_ENABLEVERTEXATTRIBARRAY				+	1)
-#define	ES20_FLUSH									(ES20_FINISH								+	1)
-#define	ES20_FRAMEBUFFERRENDERBUFFER				(ES20_FLUSH									+	1)
-#define	ES20_FRAMEBUFFERTEXTURE2D					(ES20_FRAMEBUFFERRENDERBUFFER				+	1)
-#define	ES20_FRONTFACE								(ES20_FRAMEBUFFERTEXTURE2D					+	1)
-#define	ES20_GENBUFFERS								(ES20_FRONTFACE								+	1)
-#define	ES20_GENERATEMIPMAP							(ES20_GENBUFFERS							+	1)
-#define	ES20_GENFRAMEBUFFERS						(ES20_GENERATEMIPMAP						+	1)
-#define	ES20_GENRENDERBUFFERS						(ES20_GENFRAMEBUFFERS						+	1)
-#define	ES20_GENTEXTURES							(ES20_GENRENDERBUFFERS						+	1)
-#define	ES20_GETACTIVEATTRIB						(ES20_GENTEXTURES							+	1)
-#define	ES20_GETACTIVEUNIFORM						(ES20_GETACTIVEATTRIB						+	1)
-#define	ES20_GETATTACHEDSHADERS						(ES20_GETACTIVEUNIFORM						+	1)
-#define	ES20_GETATTRIBLOCATION						(ES20_GETATTACHEDSHADERS					+	1)
-#define	ES20_GETBOOLEANV							(ES20_GETATTRIBLOCATION						+	1)
-#define	ES20_GETBUFFERPARAMETERIV					(ES20_GETBOOLEANV							+	1)
-#define	ES20_GETERROR								(ES20_GETBUFFERPARAMETERIV					+	1)
-#define	ES20_GETFLOATV								(ES20_GETERROR								+	1)
-#define	ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV	(ES20_GETFLOATV								+	1)
-#define	ES20_GETINTEGERV							(ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV	+	1)
-#define	ES20_GETPROGRAMIV							(ES20_GETINTEGERV							+	1)
-#define	ES20_GETPROGRAMINFOLOG						(ES20_GETPROGRAMIV							+	1)
-#define	ES20_GETRENDERBUFFERPARAMETERIV				(ES20_GETPROGRAMINFOLOG						+	1)
-#define	ES20_GETSHADERIV							(ES20_GETRENDERBUFFERPARAMETERIV			+	1)
-#define	ES20_GETSHADERINFOLOG						(ES20_GETSHADERIV							+	1)
-#define	ES20_GETSHADERPRECISIONFORMAT				(ES20_GETSHADERINFOLOG						+	1)
-#define	ES20_GETSHADERSOURCE						(ES20_GETSHADERPRECISIONFORMAT				+	1)
-#define	ES20_GETSTRING								(ES20_GETSHADERSOURCE						+	1)
-#define	ES20_GETTEXPARAMETERFV						(ES20_GETSTRING								+	1)
-#define	ES20_GETTEXPARAMETERIV						(ES20_GETTEXPARAMETERFV						+	1)
-#define	ES20_GETUNIFORMFV							(ES20_GETTEXPARAMETERIV						+	1)
-#define	ES20_GETUNIFORMIV							(ES20_GETUNIFORMFV							+	1)
-#define	ES20_GETUNIFORMLOCATION						(ES20_GETUNIFORMIV							+	1)
-#define	ES20_GETVERTEXATTRIBFV						(ES20_GETUNIFORMLOCATION					+	1)
-#define	ES20_GETVERTEXATTRIBIV						(ES20_GETVERTEXATTRIBFV						+	1)
-#define	ES20_GETVERTEXATTRIBPOINTERV				(ES20_GETVERTEXATTRIBIV						+	1)
-#define	ES20_HINT									(ES20_GETVERTEXATTRIBPOINTERV				+	1)
-#define	ES20_ISBUFFER								(ES20_HINT									+	1)
-#define	ES20_ISENABLED								(ES20_ISBUFFER								+	1)
-#define	ES20_ISFRAMEBUFFER							(ES20_ISENABLED								+	1)
-#define	ES20_ISPROGRAM								(ES20_ISFRAMEBUFFER							+	1)
-#define	ES20_ISRENDERBUFFER							(ES20_ISPROGRAM								+	1)
-#define	ES20_ISSHADER								(ES20_ISRENDERBUFFER						+	1)
-#define	ES20_ISTEXTURE								(ES20_ISSHADER								+	1)
-#define	ES20_LINEWIDTH								(ES20_ISTEXTURE								+	1)
-#define	ES20_LINKPROGRAM							(ES20_LINEWIDTH								+	1)
-#define	ES20_PIXELSTOREI							(ES20_LINKPROGRAM							+	1)
-#define	ES20_POLYGONOFFSET							(ES20_PIXELSTOREI							+	1)
-#define	ES20_READPIXELS								(ES20_POLYGONOFFSET							+	1)
-#define	ES20_RELEASESHADERCOMPILER					(ES20_READPIXELS							+	1)
-#define	ES20_RENDERBUFFERSTORAGE					(ES20_RELEASESHADERCOMPILER					+	1)
-#define	ES20_SAMPLECOVERAGE							(ES20_RENDERBUFFERSTORAGE					+	1)
-#define	ES20_SCISSOR								(ES20_SAMPLECOVERAGE						+	1)
-#define	ES20_SHADERBINARY							(ES20_SCISSOR								+	1)
-#define	ES20_SHADERSOURCE							(ES20_SHADERBINARY							+	1)
-#define	ES20_STENCILFUNC							(ES20_SHADERSOURCE							+	1)
-#define	ES20_STENCILFUNCSEPARATE					(ES20_STENCILFUNC							+	1)
-#define	ES20_STENCILMASK							(ES20_STENCILFUNCSEPARATE					+	1)
-#define	ES20_STENCILMASKSEPARATE					(ES20_STENCILMASK							+	1)
-#define	ES20_STENCILOP								(ES20_STENCILMASKSEPARATE					+	1)
-#define	ES20_STENCILOPSEPARATE						(ES20_STENCILOP								+	1)
-#define	ES20_TEXIMAGE2D								(ES20_STENCILOPSEPARATE						+	1)
-#define	ES20_TEXPARAMETERF							(ES20_TEXIMAGE2D							+	1)
-#define	ES20_TEXPARAMETERFV							(ES20_TEXPARAMETERF							+	1)
-#define	ES20_TEXPARAMETERI							(ES20_TEXPARAMETERFV						+	1)
-#define	ES20_TEXPARAMETERIV							(ES20_TEXPARAMETERI							+	1)
-#define	ES20_TEXSUBIMAGE2D							(ES20_TEXPARAMETERIV						+	1)
-#define	ES20_UNIFORM1F								(ES20_TEXSUBIMAGE2D							+	1)
-#define	ES20_UNIFORM1FV								(ES20_UNIFORM1F								+	1)
-#define	ES20_UNIFORM1I								(ES20_UNIFORM1FV							+	1)
-#define	ES20_UNIFORM1IV								(ES20_UNIFORM1I								+	1)
-#define	ES20_UNIFORM2F								(ES20_UNIFORM1IV							+	1)
-#define	ES20_UNIFORM2FV								(ES20_UNIFORM2F								+	1)
-#define	ES20_UNIFORM2I								(ES20_UNIFORM2FV							+	1)
-#define	ES20_UNIFORM2IV								(ES20_UNIFORM2I								+	1)
-#define	ES20_UNIFORM3F								(ES20_UNIFORM2IV							+	1)
-#define	ES20_UNIFORM3FV								(ES20_UNIFORM3F								+	1)
-#define	ES20_UNIFORM3I								(ES20_UNIFORM3FV							+	1)
-#define	ES20_UNIFORM3IV								(ES20_UNIFORM3I								+	1)
-#define	ES20_UNIFORM4F								(ES20_UNIFORM3IV							+	1)
-#define	ES20_UNIFORM4FV								(ES20_UNIFORM4F								+	1)
-#define	ES20_UNIFORM4I								(ES20_UNIFORM4FV							+	1)
-#define	ES20_UNIFORM4IV								(ES20_UNIFORM4I								+	1)
-#define	ES20_UNIFORMMATRIX2FV						(ES20_UNIFORM4IV							+	1)
-#define	ES20_UNIFORMMATRIX3FV						(ES20_UNIFORMMATRIX2FV						+	1)
-#define	ES20_UNIFORMMATRIX4FV						(ES20_UNIFORMMATRIX3FV						+	1)
-#define	ES20_USEPROGRAM								(ES20_UNIFORMMATRIX4FV						+	1)
-#define	ES20_VALIDATEPROGRAM						(ES20_USEPROGRAM							+	1)
-#define	ES20_VERTEXATTRIB1F							(ES20_VALIDATEPROGRAM						+	1)
-#define	ES20_VERTEXATTRIB1FV						(ES20_VERTEXATTRIB1F						+	1)
-#define	ES20_VERTEXATTRIB2F							(ES20_VERTEXATTRIB1FV						+	1)
-#define	ES20_VERTEXATTRIB2FV						(ES20_VERTEXATTRIB2F						+	1)
-#define	ES20_VERTEXATTRIB3F							(ES20_VERTEXATTRIB2FV						+	1)
-#define	ES20_VERTEXATTRIB3FV						(ES20_VERTEXATTRIB3F						+	1)
-#define	ES20_VERTEXATTRIB4F							(ES20_VERTEXATTRIB3FV						+	1)
-#define	ES20_VERTEXATTRIB4FV						(ES20_VERTEXATTRIB4F						+	1)
-#define	ES20_VERTEXATTRIBPOINTER					(ES20_VERTEXATTRIB4FV						+	1)
-#define	ES20_VIEWPORT								(ES20_VERTEXATTRIBPOINTER					+	1)
-#define ES20_GETPROGRAMBINARYOES                    (ES20_VIEWPORT                              +   1)
-#define ES20_PROGRAMBINARYOES                       (ES20_GETPROGRAMBINARYOES                   +   1)
-#define ES20_TEXIMAGE3DOES                          (ES20_PROGRAMBINARYOES                      +   1)
-#define ES20_TEXSUBIMAGE3DOES                       (ES20_TEXIMAGE3DOES                         +   1)
-#define ES20_COPYSUBIMAGE3DOES                      (ES20_TEXSUBIMAGE3DOES                      +   1)
-#define ES20_COMPRESSEDTEXIMAGE3DOES                (ES20_COPYSUBIMAGE3DOES                     +   1)
-#define ES20_COMPRESSEDTEXSUBIMAGE3DOES             (ES20_COMPRESSEDTEXIMAGE3DOES               +   1)
-#define ES20_FRAMEBUFFERTEXTURE3DOES                (ES20_COMPRESSEDTEXSUBIMAGE3DOES            +   1)
-#define ES20_BINDVERTEXARRAYOES                     (ES20_FRAMEBUFFERTEXTURE3DOES               +   1)
-#define ES20_GENVERTEXARRAYOES                      (ES20_BINDVERTEXARRAYOES                    +   1)
-#define ES20_ISVERTEXARRAYOES                       (ES20_GENVERTEXARRAYOES                     +   1)
-#define ES20_DELETEVERTEXARRAYOES                   (ES20_ISVERTEXARRAYOES                      +   1)
-#define ES20_GLMAPBUFFEROES                         (ES20_DELETEVERTEXARRAYOES                  +   1)
-#define ES20_GLUNMAPBUFFEROES                       (ES20_GLMAPBUFFEROES                        +   1)
-#define ES20_GLGETBUFFERPOINTERVOES                 (ES20_GLUNMAPBUFFEROES                      +   1)
-#define ES20_DISCARDFRAMEBUFFEREXT                  (ES20_GLGETBUFFERPOINTERVOES				+	1)
-#define	ES20_CALLS									(ES20_DISCARDFRAMEBUFFEREXT 				+	1)
-#define	ES20_DRAWCALLS								(ES20_CALLS									+	1)
-#define	ES20_STATECHANGECALLS						(ES20_DRAWCALLS								+	1)
-#define	ES20_POINTCOUNT								(ES20_STATECHANGECALLS						+	1)
-#define	ES20_LINECOUNT								(ES20_POINTCOUNT							+	1)
-#define	ES20_TRIANGLECOUNT							(ES20_LINECOUNT								+	1)
-
-/* OpenVG API IDs. */
-#define	VG11_APPENDPATH			     1
-#define	VG11_APPENDPATHDATA			(VG11_APPENDPATH				+ 1)
-#define	VG11_CHILDIMAGE				(VG11_APPENDPATHDATA			+ 1)
-#define	VG11_CLEAR					(VG11_CHILDIMAGE				+ 1)
-#define	VG11_CLEARGLYPH				(VG11_CLEAR						+ 1)
-#define	VG11_CLEARIMAGE				(VG11_CLEARGLYPH				+ 1)
-#define	VG11_CLEARPATH				(VG11_CLEARIMAGE				+ 1)
-#define	VG11_COLORMATRIX			(VG11_CLEARPATH					+ 1)
-#define	VG11_CONVOLVE				(VG11_COLORMATRIX				+ 1)
-#define	VG11_COPYIMAGE				(VG11_CONVOLVE					+ 1)
-#define	VG11_COPYMASK				(VG11_COPYIMAGE					+ 1)
-#define	VG11_COPYPIXELS				(VG11_COPYMASK					+ 1)
-#define	VG11_CREATEFONT				(VG11_COPYPIXELS				+ 1)
-#define	VG11_CREATEIMAGE			(VG11_CREATEFONT				+ 1)
-#define	VG11_CREATEMASKLAYER		(VG11_CREATEIMAGE				+ 1)
-#define	VG11_CREATEPAINT			(VG11_CREATEMASKLAYER			+ 1)
-#define	VG11_CREATEPATH				(VG11_CREATEPAINT				+ 1)
-#define	VG11_DESTROYFONT			(VG11_CREATEPATH				+ 1)
-#define	VG11_DESTROYIMAGE			(VG11_DESTROYFONT				+ 1)
-#define	VG11_DESTROYMASKLAYER		(VG11_DESTROYIMAGE				+ 1)
-#define	VG11_DESTROYPAINT			(VG11_DESTROYMASKLAYER			+ 1)
-#define	VG11_DESTROYPATH			(VG11_DESTROYPAINT				+ 1)
-#define	VG11_DRAWGLYPH				(VG11_DESTROYPATH				+ 1)
-#define	VG11_DRAWGLYPHS				(VG11_DRAWGLYPH					+ 1)
-#define	VG11_DRAWIMAGE				(VG11_DRAWGLYPHS				+ 1)
-#define	VG11_DRAWPATH				(VG11_DRAWIMAGE					+ 1)
-#define	VG11_FILLMASKLAYER			(VG11_DRAWPATH					+ 1)
-#define	VG11_FINISH					(VG11_FILLMASKLAYER				+ 1)
-#define	VG11_FLUSH					(VG11_FINISH					+ 1)
-#define	VG11_GAUSSIANBLUR			(VG11_FLUSH						+ 1)
-#define	VG11_GETCOLOR				(VG11_GAUSSIANBLUR				+ 1)
-#define	VG11_GETERROR				(VG11_GETCOLOR					+ 1)
-#define	VG11_GETF					(VG11_GETERROR					+ 1)
-#define	VG11_GETFV					(VG11_GETF						+ 1)
-#define	VG11_GETI					(VG11_GETFV						+ 1)
-#define	VG11_GETIMAGESUBDATA		(VG11_GETI						+ 1)
-#define	VG11_GETIV					(VG11_GETIMAGESUBDATA			+ 1)
-#define	VG11_GETMATRIX				(VG11_GETIV						+ 1)
-#define	VG11_GETPAINT				(VG11_GETMATRIX					+ 1)
-#define	VG11_GETPARAMETERF			(VG11_GETPAINT					+ 1)
-#define	VG11_GETPARAMETERFV			(VG11_GETPARAMETERF				+ 1)
-#define	VG11_GETPARAMETERI			(VG11_GETPARAMETERFV			+ 1)
-#define	VG11_GETPARAMETERIV			(VG11_GETPARAMETERI				+ 1)
-#define	VG11_GETPARAMETERVECTORSIZE	(VG11_GETPARAMETERIV			+ 1)
-#define	VG11_GETPARENT				(VG11_GETPARAMETERVECTORSIZE	+ 1)
-#define	VG11_GETPATHCAPABILITIES	(VG11_GETPARENT					+ 1)
-#define	VG11_GETPIXELS				(VG11_GETPATHCAPABILITIES		+ 1)
-#define	VG11_GETSTRING				(VG11_GETPIXELS					+ 1)
-#define	VG11_GETVECTORSIZE			(VG11_GETSTRING					+ 1)
-#define	VG11_HARDWAREQUERY			(VG11_GETVECTORSIZE				+ 1)
-#define	VG11_IMAGESUBDATA			(VG11_HARDWAREQUERY				+ 1)
-#define	VG11_INTERPOLATEPATH		(VG11_IMAGESUBDATA				+ 1)
-#define	VG11_LOADIDENTITY			(VG11_INTERPOLATEPATH			+ 1)
-#define	VG11_LOADMATRIX				(VG11_LOADIDENTITY				+ 1)
-#define	VG11_LOOKUP					(VG11_LOADMATRIX				+ 1)
-#define	VG11_LOOKUPSINGLE			(VG11_LOOKUP					+ 1)
-#define	VG11_MASK					(VG11_LOOKUPSINGLE				+ 1)
-#define	VG11_MODIFYPATHCOORDS		(VG11_MASK						+ 1)
-#define	VG11_MULTMATRIX				(VG11_MODIFYPATHCOORDS			+ 1)
-#define	VG11_PAINTPATTERN			(VG11_MULTMATRIX				+ 1)
-#define	VG11_PATHBOUNDS				(VG11_PAINTPATTERN				+ 1)
-#define	VG11_PATHLENGTH				(VG11_PATHBOUNDS				+ 1)
-#define	VG11_PATHTRANSFORMEDBOUNDS	(VG11_PATHLENGTH				+ 1)
-#define	VG11_POINTALONGPATH			(VG11_PATHTRANSFORMEDBOUNDS		+ 1)
-#define	VG11_READPIXELS				(VG11_POINTALONGPATH			+ 1)
-#define	VG11_REMOVEPATHCAPABILITIES	(VG11_READPIXELS				+ 1)
-#define	VG11_RENDERTOMASK			(VG11_REMOVEPATHCAPABILITIES	+ 1)
-#define	VG11_ROTATE					(VG11_RENDERTOMASK				+ 1)
-#define	VG11_SCALE					(VG11_ROTATE					+ 1)
-#define	VG11_SEPARABLECONVOLVE		(VG11_SCALE						+ 1)
-#define	VG11_SETCOLOR				(VG11_SEPARABLECONVOLVE			+ 1)
-#define	VG11_SETF					(VG11_SETCOLOR					+ 1)
-#define	VG11_SETFV					(VG11_SETF						+ 1)
-#define	VG11_SETGLYPHTOIMAGE		(VG11_SETFV						+ 1)
-#define	VG11_SETGLYPHTOPATH			(VG11_SETGLYPHTOIMAGE			+ 1)
-#define	VG11_SETI					(VG11_SETGLYPHTOPATH			+ 1)
-#define	VG11_SETIV					(VG11_SETI						+ 1)
-#define	VG11_SETPAINT				(VG11_SETIV						+ 1)
-#define	VG11_SETPARAMETERF			(VG11_SETPAINT					+ 1)
-#define	VG11_SETPARAMETERFV			(VG11_SETPARAMETERF				+ 1)
-#define	VG11_SETPARAMETERI			(VG11_SETPARAMETERFV			+ 1)
-#define	VG11_SETPARAMETERIV			(VG11_SETPARAMETERI				+ 1)
-#define	VG11_SETPIXELS				(VG11_SETPARAMETERIV			+ 1)
-#define	VG11_SHEAR					(VG11_SETPIXELS					+ 1)
-#define	VG11_TRANSFORMPATH			(VG11_SHEAR						+ 1)
-#define	VG11_TRANSLATE				(VG11_TRANSFORMPATH				+ 1)
-#define	VG11_WRITEPIXELS			(VG11_TRANSLATE					+ 1)
-#define VG11_CALLS                  (VG11_WRITEPIXELS               + 1)
-#define VG11_DRAWCALLS              (VG11_CALLS                     + 1)
-#define VG11_STATECHANGECALLS       (VG11_DRAWCALLS                 + 1)
-#define VG11_FILLCOUNT              (VG11_STATECHANGECALLS          + 1)
-#define VG11_STROKECOUNT            (VG11_FILLCOUNT                 + 1)
+#define    ES11_CALLS              151
+#define    ES11_DRAWCALLS          (ES11_CALLS             + 1)
+#define    ES11_STATECHANGECALLS   (ES11_DRAWCALLS         + 1)
+#define    ES11_POINTCOUNT         (ES11_STATECHANGECALLS  + 1)
+#define    ES11_LINECOUNT          (ES11_POINTCOUNT        + 1)
+#define    ES11_TRIANGLECOUNT      (ES11_LINECOUNT         + 1)
+
+#define    ES20_CALLS              159
+#define    ES20_DRAWCALLS          (ES20_CALLS             + 1)
+#define    ES20_STATECHANGECALLS   (ES20_DRAWCALLS         + 1)
+#define    ES20_POINTCOUNT         (ES20_STATECHANGECALLS  + 1)
+#define    ES20_LINECOUNT          (ES20_POINTCOUNT        + 1)
+#define    ES20_TRIANGLECOUNT      (ES20_LINECOUNT         + 1)
+
+#define    VG11_CALLS              88
+#define    VG11_DRAWCALLS          (VG11_CALLS              + 1)
+#define    VG11_STATECHANGECALLS   (VG11_DRAWCALLS          + 1)
+#define    VG11_FILLCOUNT          (VG11_STATECHANGECALLS   + 1)
+#define    VG11_STROKECOUNT        (VG11_FILLCOUNT          + 1)
 /* End of Driver API ID Definitions. */
 
 /* HAL & MISC IDs. */
-#define HAL_VERTBUFNEWBYTEALLOC		1
-#define HAL_VERTBUFTOTALBYTEALLOC	(HAL_VERTBUFNEWBYTEALLOC 	+ 1)
-#define HAL_VERTBUFNEWOBJALLOC		(HAL_VERTBUFTOTALBYTEALLOC	+ 1)
-#define HAL_VERTBUFTOTALOBJALLOC	(HAL_VERTBUFNEWOBJALLOC		+ 1)
-#define HAL_INDBUFNEWBYTEALLOC		(HAL_VERTBUFTOTALOBJALLOC	+ 1)
-#define HAL_INDBUFTOTALBYTEALLOC	(HAL_INDBUFNEWBYTEALLOC		+ 1)
-#define HAL_INDBUFNEWOBJALLOC		(HAL_INDBUFTOTALBYTEALLOC	+ 1)
-#define HAL_INDBUFTOTALOBJALLOC		(HAL_INDBUFNEWOBJALLOC		+ 1)
-#define HAL_TEXBUFNEWBYTEALLOC		(HAL_INDBUFTOTALOBJALLOC	+ 1)
-#define HAL_TEXBUFTOTALBYTEALLOC	(HAL_TEXBUFNEWBYTEALLOC		+ 1)
-#define HAL_TEXBUFNEWOBJALLOC		(HAL_TEXBUFTOTALBYTEALLOC	+ 1)
-#define HAL_TEXBUFTOTALOBJALLOC		(HAL_TEXBUFNEWOBJALLOC		+ 1)
-
-#define GPU_CYCLES		1
-#define GPU_READ64BYTE	(GPU_CYCLES		+ 1)
-#define GPU_WRITE64BYTE	(GPU_READ64BYTE	+ 1)
-#define GPU_TOTALCYCLES	(GPU_WRITE64BYTE	+ 1)
-#define GPU_IDLECYCLES	(GPU_TOTALCYCLES	+ 1)
-
-#define VS_INSTCOUNT			1
-#define VS_BRANCHINSTCOUNT		(VS_INSTCOUNT		+ 1)
-#define VS_TEXLDINSTCOUNT		(VS_BRANCHINSTCOUNT	+ 1)
-#define VS_RENDEREDVERTCOUNT	(VS_TEXLDINSTCOUNT	+ 1)
-
-#define PS_INSTCOUNT			1
-#define PS_BRANCHINSTCOUNT		(PS_INSTCOUNT		+ 1)
-#define PS_TEXLDINSTCOUNT		(PS_BRANCHINSTCOUNT	+ 1)
-#define PS_RENDEREDPIXCOUNT		(PS_TEXLDINSTCOUNT	+ 1)
-
-#define PA_INVERTCOUNT		1
-#define	PA_INPRIMCOUNT		(PA_INVERTCOUNT		+ 1)
-#define PA_OUTPRIMCOUNT		(PA_INPRIMCOUNT		+ 1)
-#define PA_DEPTHCLIPCOUNT	(PA_OUTPRIMCOUNT	+ 1)
-#define PA_TRIVIALREJCOUNT	(PA_DEPTHCLIPCOUNT	+ 1)
-#define PA_CULLCOUNT		(PA_TRIVIALREJCOUNT	+ 1)
-
-#define SE_TRIANGLECOUNT	1
-#define SE_LINECOUNT		(SE_TRIANGLECOUNT	+ 1)
-
-#define RA_VALIDPIXCOUNT		1
-#define RA_TOTALQUADCOUNT		(RA_VALIDPIXCOUNT		+ 1)
-#define RA_VALIDQUADCOUNTEZ		(RA_TOTALQUADCOUNT		+ 1)
-#define RA_TOTALPRIMCOUNT		(RA_VALIDQUADCOUNTEZ	+ 1)
-#define RA_PIPECACHEMISSCOUNT	(RA_TOTALPRIMCOUNT		+ 1)
-#define RA_PREFCACHEMISSCOUNT	(RA_PIPECACHEMISSCOUNT	+ 1)
-#define RA_EEZCULLCOUNT			(RA_PREFCACHEMISSCOUNT	+ 1)
-
-#define TX_TOTBILINEARREQ		1
-#define TX_TOTTRILINEARREQ		(TX_TOTBILINEARREQ		+ 1)
-#define TX_TOTDISCARDTEXREQ		(TX_TOTTRILINEARREQ		+ 1)
-#define TX_TOTTEXREQ			(TX_TOTDISCARDTEXREQ	+ 1)
-#define TX_MEMREADCOUNT			(TX_TOTTEXREQ			+ 1)
-#define TX_MEMREADIN8BCOUNT		(TX_MEMREADCOUNT		+ 1)
-#define TX_CACHEMISSCOUNT		(TX_MEMREADIN8BCOUNT	+ 1)
-#define TX_CACHEHITTEXELCOUNT	(TX_CACHEMISSCOUNT		+ 1)
-#define TX_CACHEMISSTEXELCOUNT	(TX_CACHEHITTEXELCOUNT	+ 1)
-
-#define PE_KILLEDBYCOLOR	1
-#define PE_KILLEDBYDEPTH	(PE_KILLEDBYCOLOR	+ 1)
-#define PE_DRAWNBYCOLOR		(PE_KILLEDBYDEPTH	+ 1)
-#define PE_DRAWNBYDEPTH		(PE_DRAWNBYCOLOR	+ 1)
-
-#define MC_READREQ8BPIPE	1
-#define MC_READREQ8BIP		(MC_READREQ8BPIPE	+ 1)
-#define MC_WRITEREQ8BPIPE	(MC_READREQ8BIP		+ 1)
-
-#define AXI_READREQSTALLED		1
-#define AXI_WRITEREQSTALLED		(AXI_READREQSTALLED		+ 1)
-#define AXI_WRITEDATASTALLED	(AXI_WRITEREQSTALLED	+ 1)
-
-#define PVS_INSTRCOUNT		1
-#define PVS_ALUINSTRCOUNT	(PVS_INSTRCOUNT		+ 1)
-#define PVS_TEXINSTRCOUNT	(PVS_ALUINSTRCOUNT	+ 1)
-#define PVS_ATTRIBCOUNT		(PVS_TEXINSTRCOUNT	+ 1)
-#define PVS_UNIFORMCOUNT	(PVS_ATTRIBCOUNT	+ 1)
-#define PVS_FUNCTIONCOUNT	(PVS_UNIFORMCOUNT	+ 1)
-
-#define PPS_INSTRCOUNT		1
-#define PPS_ALUINSTRCOUNT	(PPS_INSTRCOUNT		+ 1)
-#define PPS_TEXINSTRCOUNT	(PPS_ALUINSTRCOUNT	+ 1)
-#define PPS_ATTRIBCOUNT		(PPS_TEXINSTRCOUNT	+ 1)
-#define PPS_UNIFORMCOUNT	(PPS_ATTRIBCOUNT	+ 1)
-#define PPS_FUNCTIONCOUNT 	(PPS_UNIFORMCOUNT	+ 1)
+#define HAL_VERTBUFNEWBYTEALLOC    1
+#define HAL_VERTBUFTOTALBYTEALLOC  (HAL_VERTBUFNEWBYTEALLOC     + 1)
+#define HAL_VERTBUFNEWOBJALLOC     (HAL_VERTBUFTOTALBYTEALLOC   + 1)
+#define HAL_VERTBUFTOTALOBJALLOC   (HAL_VERTBUFNEWOBJALLOC      + 1)
+#define HAL_INDBUFNEWBYTEALLOC     (HAL_VERTBUFTOTALOBJALLOC    + 1)
+#define HAL_INDBUFTOTALBYTEALLOC   (HAL_INDBUFNEWBYTEALLOC      + 1)
+#define HAL_INDBUFNEWOBJALLOC      (HAL_INDBUFTOTALBYTEALLOC    + 1)
+#define HAL_INDBUFTOTALOBJALLOC    (HAL_INDBUFNEWOBJALLOC       + 1)
+#define HAL_TEXBUFNEWBYTEALLOC     (HAL_INDBUFTOTALOBJALLOC     + 1)
+#define HAL_TEXBUFTOTALBYTEALLOC   (HAL_TEXBUFNEWBYTEALLOC      + 1)
+#define HAL_TEXBUFNEWOBJALLOC      (HAL_TEXBUFTOTALBYTEALLOC    + 1)
+#define HAL_TEXBUFTOTALOBJALLOC    (HAL_TEXBUFNEWOBJALLOC       + 1)
+
+#define GPU_CYCLES           1
+#define GPU_READ64BYTE       (GPU_CYCLES         + 1)
+#define GPU_WRITE64BYTE      (GPU_READ64BYTE     + 1)
+#define GPU_TOTALCYCLES      (GPU_WRITE64BYTE    + 1)
+#define GPU_IDLECYCLES       (GPU_TOTALCYCLES    + 1)
+
+#define VS_INSTCOUNT          1
+#define VS_BRANCHINSTCOUNT    (VS_INSTCOUNT          + 1)
+#define VS_TEXLDINSTCOUNT     (VS_BRANCHINSTCOUNT    + 1)
+#define VS_RENDEREDVERTCOUNT  (VS_TEXLDINSTCOUNT     + 1)
+#define VS_SOURCE             (VS_RENDEREDVERTCOUNT  + 1)
+
+#define PS_INSTCOUNT          1
+#define PS_BRANCHINSTCOUNT    (PS_INSTCOUNT          + 1)
+#define PS_TEXLDINSTCOUNT     (PS_BRANCHINSTCOUNT    + 1)
+#define PS_RENDEREDPIXCOUNT   (PS_TEXLDINSTCOUNT     + 1)
+#define PS_SOURCE             (PS_RENDEREDPIXCOUNT   + 1)
+
+#define PA_INVERTCOUNT        1
+#define PA_INPRIMCOUNT        (PA_INVERTCOUNT      + 1)
+#define PA_OUTPRIMCOUNT       (PA_INPRIMCOUNT      + 1)
+#define PA_DEPTHCLIPCOUNT     (PA_OUTPRIMCOUNT     + 1)
+#define PA_TRIVIALREJCOUNT    (PA_DEPTHCLIPCOUNT   + 1)
+#define PA_CULLCOUNT          (PA_TRIVIALREJCOUNT  + 1)
+
+#define SE_TRIANGLECOUNT      1
+#define SE_LINECOUNT          (SE_TRIANGLECOUNT    + 1)
+
+#define RA_VALIDPIXCOUNT      1
+#define RA_TOTALQUADCOUNT     (RA_VALIDPIXCOUNT      + 1)
+#define RA_VALIDQUADCOUNTEZ   (RA_TOTALQUADCOUNT     + 1)
+#define RA_TOTALPRIMCOUNT     (RA_VALIDQUADCOUNTEZ   + 1)
+#define RA_PIPECACHEMISSCOUNT (RA_TOTALPRIMCOUNT     + 1)
+#define RA_PREFCACHEMISSCOUNT (RA_PIPECACHEMISSCOUNT + 1)
+#define RA_EEZCULLCOUNT       (RA_PREFCACHEMISSCOUNT + 1)
+
+#define TX_TOTBILINEARREQ     1
+#define TX_TOTTRILINEARREQ    (TX_TOTBILINEARREQ      + 1)
+#define TX_TOTDISCARDTEXREQ   (TX_TOTTRILINEARREQ     + 1)
+#define TX_TOTTEXREQ          (TX_TOTDISCARDTEXREQ    + 1)
+#define TX_MEMREADCOUNT       (TX_TOTTEXREQ           + 1)
+#define TX_MEMREADIN8BCOUNT   (TX_MEMREADCOUNT        + 1)
+#define TX_CACHEMISSCOUNT     (TX_MEMREADIN8BCOUNT    + 1)
+#define TX_CACHEHITTEXELCOUNT (TX_CACHEMISSCOUNT      + 1)
+#define TX_CACHEMISSTEXELCOUNT (TX_CACHEHITTEXELCOUNT + 1)
+
+#define PE_KILLEDBYCOLOR      1
+#define PE_KILLEDBYDEPTH      (PE_KILLEDBYCOLOR    + 1)
+#define PE_DRAWNBYCOLOR       (PE_KILLEDBYDEPTH    + 1)
+#define PE_DRAWNBYDEPTH       (PE_DRAWNBYCOLOR     + 1)
+
+#define MC_READREQ8BPIPE      1
+#define MC_READREQ8BIP        (MC_READREQ8BPIPE    + 1)
+#define MC_WRITEREQ8BPIPE     (MC_READREQ8BIP      + 1)
+
+#define AXI_READREQSTALLED    1
+#define AXI_WRITEREQSTALLED   (AXI_READREQSTALLED  + 1)
+#define AXI_WRITEDATASTALLED  (AXI_WRITEREQSTALLED + 1)
+
+#define PVS_INSTRCOUNT        1
+#define PVS_ALUINSTRCOUNT     (PVS_INSTRCOUNT      + 1)
+#define PVS_TEXINSTRCOUNT     (PVS_ALUINSTRCOUNT   + 1)
+#define PVS_ATTRIBCOUNT       (PVS_TEXINSTRCOUNT   + 1)
+#define PVS_UNIFORMCOUNT      (PVS_ATTRIBCOUNT     + 1)
+#define PVS_FUNCTIONCOUNT     (PVS_UNIFORMCOUNT    + 1)
+#define PVS_SOURCE            (PVS_FUNCTIONCOUNT   + 1)
+
+#define PPS_INSTRCOUNT       1
+#define PPS_ALUINSTRCOUNT    (PPS_INSTRCOUNT       + 1)
+#define PPS_TEXINSTRCOUNT    (PPS_ALUINSTRCOUNT    + 1)
+#define PPS_ATTRIBCOUNT      (PPS_TEXINSTRCOUNT    + 1)
+#define PPS_UNIFORMCOUNT     (PPS_ATTRIBCOUNT      + 1)
+#define PPS_FUNCTIONCOUNT    (PPS_UNIFORMCOUNT     + 1)
+#define PPS_SOURCE           (PPS_FUNCTIONCOUNT    + 1)
 /* End of MISC Counter IDs. */
 
 #ifdef gcdNEW_PROFILER_FILE
@@ -578,8 +184,8 @@ extern "C" {
 #define VPG_ES11_TIME   0x170000
 #define VPG_ES20_TIME   0x180000
 #define VPG_FRAME       0x190000
-#define VPG_ES11_DRAW 0x200000
-#define VPG_ES20_DRAW 0x210000
+#define VPG_ES11_DRAW   0x200000
+#define VPG_ES20_DRAW   0x210000
 #define VPG_END         0xff0000
 
 /* Info. */
@@ -592,7 +198,7 @@ extern "C" {
 #define VPC_INFOSCREENSIZE      (VPC_INFODRIVERMODE + 1)
 
 /* Counter Constants. */
-#define VPC_ELAPSETIME  		(VPG_TIME + 1)
+#define VPC_ELAPSETIME          (VPG_TIME + 1)
 #define VPC_CPUTIME             (VPC_ELAPSETIME + 1)
 
 #define VPC_MEMMAXRES           (VPG_MEM + 1)
@@ -600,404 +206,28 @@ extern "C" {
 #define VPC_MEMUNSHAREDDATA     (VPC_MEMSHARED + 1)
 #define VPC_MEMUNSHAREDSTACK    (VPC_MEMUNSHAREDDATA + 1)
 
-/* OpenGL ES11 Counters. */
-#define	VPC_ES11ACTIVETEXTURE			(VPG_ES11 +	ES11_ACTIVETEXTURE)
-#define	VPC_ES11ALPHAFUNC				(VPG_ES11 +	ES11_ALPHAFUNC)
-#define	VPC_ES11ALPHAFUNCX				(VPG_ES11 +	ES11_ALPHAFUNCX)
-#define	VPC_ES11BINDBUFFER				(VPG_ES11 +	ES11_BINDBUFFER)
-#define	VPC_ES11BINDTEXTURE				(VPG_ES11 +	ES11_BINDTEXTURE)
-#define	VPC_ES11BLENDFUNC				(VPG_ES11 +	ES11_BLENDFUNC)
-#define	VPC_ES11BUFFERDATA				(VPG_ES11 +	ES11_BUFFERDATA)
-#define	VPC_ES11BUFFERSUBDATA			(VPG_ES11 +	ES11_BUFFERSUBDATA)
-#define	VPC_ES11CLEAR					(VPG_ES11 +	ES11_CLEAR)
-#define	VPC_ES11CLEARCOLOR				(VPG_ES11 +	ES11_CLEARCOLOR)
-#define	VPC_ES11CLEARCOLORX				(VPG_ES11 +	ES11_CLEARCOLORX)
-#define	VPC_ES11CLEARDEPTHF				(VPG_ES11 +	ES11_CLEARDEPTHF)
-#define	VPC_ES11CLEARDEPTHX				(VPG_ES11 +	ES11_CLEARDEPTHX)
-#define	VPC_ES11CLEARSTENCIL			(VPG_ES11 +	ES11_CLEARSTENCIL)
-#define	VPC_ES11CLIENTACTIVETEXTURE		(VPG_ES11 +	ES11_CLIENTACTIVETEXTURE)
-#define	VPC_ES11CLIPPLANEF				(VPG_ES11 +	ES11_CLIPPLANEF)
-#define	VPC_ES11CLIPPLANEX				(VPG_ES11 +	ES11_CLIPPLANEX)
-#define	VPC_ES11COLOR4F					(VPG_ES11 +	ES11_COLOR4F)
-#define	VPC_ES11COLOR4UB				(VPG_ES11 +	ES11_COLOR4UB)
-#define	VPC_ES11COLOR4X					(VPG_ES11 +	ES11_COLOR4X)
-#define	VPC_ES11COLORMASK				(VPG_ES11 +	ES11_COLORMASK)
-#define	VPC_ES11COLORPOINTER			(VPG_ES11 +	ES11_COLORPOINTER)
-#define	VPC_ES11COMPRESSEDTEXIMAGE2D	(VPG_ES11 +	ES11_COMPRESSEDTEXIMAGE2D)
-#define	VPC_ES11COMPRESSEDTEXSUBIMAGE2D	(VPG_ES11 +	ES11_COMPRESSEDTEXSUBIMAGE2D)
-#define	VPC_ES11COPYTEXIMAGE2D			(VPG_ES11 +	ES11_COPYTEXIMAGE2D)
-#define	VPC_ES11COPYTEXSUBIMAGE2D		(VPG_ES11 +	ES11_COPYTEXSUBIMAGE2D)
-#define	VPC_ES11CULLFACE				(VPG_ES11 +	ES11_CULLFACE)
-#define	VPC_ES11DELETEBUFFERS			(VPG_ES11 +	ES11_DELETEBUFFERS)
-#define	VPC_ES11DELETETEXTURES			(VPG_ES11 +	ES11_DELETETEXTURES)
-#define	VPC_ES11DEPTHFUNC				(VPG_ES11 +	ES11_DEPTHFUNC)
-#define	VPC_ES11DEPTHMASK				(VPG_ES11 +	ES11_DEPTHMASK)
-#define	VPC_ES11DEPTHRANGEF				(VPG_ES11 +	ES11_DEPTHRANGEF)
-#define	VPC_ES11DEPTHRANGEX				(VPG_ES11 +	ES11_DEPTHRANGEX)
-#define	VPC_ES11DISABLE					(VPG_ES11 +	ES11_DISABLE)
-#define	VPC_ES11DISABLECLIENTSTATE		(VPG_ES11 +	ES11_DISABLECLIENTSTATE)
-#define	VPC_ES11DRAWARRAYS				(VPG_ES11 +	ES11_DRAWARRAYS)
-#define	VPC_ES11DRAWELEMENTS			(VPG_ES11 +	ES11_DRAWELEMENTS)
-#define	VPC_ES11ENABLE					(VPG_ES11 +	ES11_ENABLE)
-#define	VPC_ES11ENABLECLIENTSTATE		(VPG_ES11 +	ES11_ENABLECLIENTSTATE)
-#define	VPC_ES11FINISH					(VPG_ES11 +	ES11_FINISH)
-#define	VPC_ES11FLUSH					(VPG_ES11 +	ES11_FLUSH)
-#define	VPC_ES11FOGF					(VPG_ES11 +	ES11_FOGF)
-#define	VPC_ES11FOGFV					(VPG_ES11 +	ES11_FOGFV)
-#define	VPC_ES11FOGX					(VPG_ES11 +	ES11_FOGX)
-#define	VPC_ES11FOGXV					(VPG_ES11 +	ES11_FOGXV)
-#define	VPC_ES11FRONTFACE				(VPG_ES11 +	ES11_FRONTFACE)
-#define	VPC_ES11FRUSTUMF				(VPG_ES11 +	ES11_FRUSTUMF)
-#define	VPC_ES11FRUSTUMX				(VPG_ES11 +	ES11_FRUSTUMX)
-#define	VPC_ES11GENBUFFERS				(VPG_ES11 +	ES11_GENBUFFERS)
-#define	VPC_ES11GENTEXTURES				(VPG_ES11 +	ES11_GENTEXTURES)
-#define	VPC_ES11GETBOOLEANV				(VPG_ES11 +	ES11_GETBOOLEANV)
-#define	VPC_ES11GETBUFFERPARAMETERIV	(VPG_ES11 +	ES11_GETBUFFERPARAMETERIV)
-#define	VPC_ES11GETCLIPPLANEF			(VPG_ES11 +	ES11_GETCLIPPLANEF)
-#define	VPC_ES11GETCLIPPLANEX			(VPG_ES11 +	ES11_GETCLIPPLANEX)
-#define	VPC_ES11GETERROR				(VPG_ES11 +	ES11_GETERROR)
-#define	VPC_ES11GETFIXEDV				(VPG_ES11 +	ES11_GETFIXEDV)
-#define	VPC_ES11GETFLOATV				(VPG_ES11 +	ES11_GETFLOATV)
-#define	VPC_ES11GETINTEGERV				(VPG_ES11 +	ES11_GETINTEGERV)
-#define	VPC_ES11GETLIGHTFV				(VPG_ES11 +	ES11_GETLIGHTFV)
-#define	VPC_ES11GETLIGHTXV				(VPG_ES11 +	ES11_GETLIGHTXV)
-#define	VPC_ES11GETMATERIALFV			(VPG_ES11 +	ES11_GETMATERIALFV)
-#define	VPC_ES11GETMATERIALXV			(VPG_ES11 +	ES11_GETMATERIALXV)
-#define	VPC_ES11GETPOINTERV				(VPG_ES11 +	ES11_GETPOINTERV)
-#define	VPC_ES11GETSTRING				(VPG_ES11 +	ES11_GETSTRING)
-#define	VPC_ES11GETTEXENVFV				(VPG_ES11 +	ES11_GETTEXENVFV)
-#define	VPC_ES11GETTEXENVIV				(VPG_ES11 +	ES11_GETTEXENVIV)
-#define	VPC_ES11GETTEXENVXV				(VPG_ES11 +	ES11_GETTEXENVXV)
-#define	VPC_ES11GETTEXPARAMETERFV		(VPG_ES11 +	ES11_GETTEXPARAMETERFV)
-#define	VPC_ES11GETTEXPARAMETERIV		(VPG_ES11 +	ES11_GETTEXPARAMETERIV)
-#define	VPC_ES11GETTEXPARAMETERXV		(VPG_ES11 +	ES11_GETTEXPARAMETERXV)
-#define	VPC_ES11HINT					(VPG_ES11 +	ES11_HINT)
-#define	VPC_ES11ISBUFFER				(VPG_ES11 +	ES11_ISBUFFER)
-#define	VPC_ES11ISENABLED				(VPG_ES11 +	ES11_ISENABLED)
-#define	VPC_ES11ISTEXTURE				(VPG_ES11 +	ES11_ISTEXTURE)
-#define	VPC_ES11LIGHTF					(VPG_ES11 +	ES11_LIGHTF)
-#define	VPC_ES11LIGHTFV					(VPG_ES11 +	ES11_LIGHTFV)
-#define	VPC_ES11LIGHTMODELF				(VPG_ES11 +	ES11_LIGHTMODELF)
-#define	VPC_ES11LIGHTMODELFV			(VPG_ES11 +	ES11_LIGHTMODELFV)
-#define	VPC_ES11LIGHTMODELX				(VPG_ES11 +	ES11_LIGHTMODELX)
-#define	VPC_ES11LIGHTMODELXV			(VPG_ES11 +	ES11_LIGHTMODELXV)
-#define	VPC_ES11LIGHTX					(VPG_ES11 +	ES11_LIGHTX)
-#define	VPC_ES11LIGHTXV					(VPG_ES11 +	ES11_LIGHTXV)
-#define	VPC_ES11LINEWIDTH				(VPG_ES11 +	ES11_LINEWIDTH)
-#define	VPC_ES11LINEWIDTHX				(VPG_ES11 +	ES11_LINEWIDTHX)
-#define	VPC_ES11LOADIDENTITY			(VPG_ES11 +	ES11_LOADIDENTITY)
-#define	VPC_ES11LOADMATRIXF				(VPG_ES11 +	ES11_LOADMATRIXF)
-#define	VPC_ES11LOADMATRIXX				(VPG_ES11 +	ES11_LOADMATRIXX)
-#define	VPC_ES11LOGICOP					(VPG_ES11 +	ES11_LOGICOP)
-#define	VPC_ES11MATERIALF				(VPG_ES11 +	ES11_MATERIALF)
-#define	VPC_ES11MATERIALFV				(VPG_ES11 +	ES11_MATERIALFV)
-#define	VPC_ES11MATERIALX				(VPG_ES11 +	ES11_MATERIALX)
-#define	VPC_ES11MATERIALXV				(VPG_ES11 +	ES11_MATERIALXV)
-#define	VPC_ES11MATRIXMODE				(VPG_ES11 +	ES11_MATRIXMODE)
-#define	VPC_ES11MULTITEXCOORD4F			(VPG_ES11 +	ES11_MULTITEXCOORD4F)
-#define	VPC_ES11MULTITEXCOORD4X			(VPG_ES11 +	ES11_MULTITEXCOORD4X)
-#define	VPC_ES11MULTMATRIXF				(VPG_ES11 +	ES11_MULTMATRIXF)
-#define	VPC_ES11MULTMATRIXX				(VPG_ES11 +	ES11_MULTMATRIXX)
-#define	VPC_ES11NORMAL3F				(VPG_ES11 +	ES11_NORMAL3F)
-#define	VPC_ES11NORMAL3X				(VPG_ES11 +	ES11_NORMAL3X)
-#define	VPC_ES11NORMALPOINTER			(VPG_ES11 +	ES11_NORMALPOINTER)
-#define	VPC_ES11ORTHOF					(VPG_ES11 +	ES11_ORTHOF)
-#define	VPC_ES11ORTHOX					(VPG_ES11 +	ES11_ORTHOX)
-#define	VPC_ES11PIXELSTOREI				(VPG_ES11 +	ES11_PIXELSTOREI)
-#define	VPC_ES11POINTPARAMETERF			(VPG_ES11 +	ES11_POINTPARAMETERF)
-#define	VPC_ES11POINTPARAMETERFV		(VPG_ES11 +	ES11_POINTPARAMETERFV)
-#define	VPC_ES11POINTPARAMETERX			(VPG_ES11 +	ES11_POINTPARAMETERX)
-#define	VPC_ES11POINTPARAMETERXV		(VPG_ES11 +	ES11_POINTPARAMETERXV)
-#define	VPC_ES11POINTSIZE				(VPG_ES11 +	ES11_POINTSIZE)
-#define	VPC_ES11POINTSIZEX				(VPG_ES11 +	ES11_POINTSIZEX)
-#define	VPC_ES11POLYGONOFFSET			(VPG_ES11 +	ES11_POLYGONOFFSET)
-#define	VPC_ES11POLYGONOFFSETX			(VPG_ES11 +	ES11_POLYGONOFFSETX)
-#define	VPC_ES11POPMATRIX				(VPG_ES11 +	ES11_POPMATRIX)
-#define	VPC_ES11PUSHMATRIX				(VPG_ES11 +	ES11_PUSHMATRIX)
-#define	VPC_ES11READPIXELS				(VPG_ES11 +	ES11_READPIXELS)
-#define	VPC_ES11ROTATEF					(VPG_ES11 +	ES11_ROTATEF)
-#define	VPC_ES11ROTATEX					(VPG_ES11 +	ES11_ROTATEX)
-#define	VPC_ES11SAMPLECOVERAGE			(VPG_ES11 +	ES11_SAMPLECOVERAGE)
-#define	VPC_ES11SAMPLECOVERAGEX			(VPG_ES11 +	ES11_SAMPLECOVERAGEX)
-#define	VPC_ES11SCALEF					(VPG_ES11 +	ES11_SCALEF)
-#define	VPC_ES11SCALEX					(VPG_ES11 +	ES11_SCALEX)
-#define	VPC_ES11SCISSOR					(VPG_ES11 +	ES11_SCISSOR)
-#define	VPC_ES11SHADEMODEL				(VPG_ES11 +	ES11_SHADEMODEL)
-#define	VPC_ES11STENCILFUNC				(VPG_ES11 +	ES11_STENCILFUNC)
-#define	VPC_ES11STENCILMASK				(VPG_ES11 +	ES11_STENCILMASK)
-#define	VPC_ES11STENCILOP				(VPG_ES11 +	ES11_STENCILOP)
-#define	VPC_ES11TEXCOORDPOINTER			(VPG_ES11 +	ES11_TEXCOORDPOINTER)
-#define	VPC_ES11TEXENVF					(VPG_ES11 +	ES11_TEXENVF)
-#define	VPC_ES11TEXENVFV				(VPG_ES11 +	ES11_TEXENVFV)
-#define	VPC_ES11TEXENVI					(VPG_ES11 +	ES11_TEXENVI)
-#define	VPC_ES11TEXENVIV				(VPG_ES11 +	ES11_TEXENVIV)
-#define	VPC_ES11TEXENVX					(VPG_ES11 +	ES11_TEXENVX)
-#define	VPC_ES11TEXENVXV				(VPG_ES11 +	ES11_TEXENVXV)
-#define	VPC_ES11TEXIMAGE2D				(VPG_ES11 +	ES11_TEXIMAGE2D)
-#define	VPC_ES11TEXPARAMETERF			(VPG_ES11 +	ES11_TEXPARAMETERF)
-#define	VPC_ES11TEXPARAMETERFV			(VPG_ES11 +	ES11_TEXPARAMETERFV)
-#define	VPC_ES11TEXPARAMETERI			(VPG_ES11 +	ES11_TEXPARAMETERI)
-#define	VPC_ES11TEXPARAMETERIV			(VPG_ES11 +	ES11_TEXPARAMETERIV)
-#define	VPC_ES11TEXPARAMETERX			(VPG_ES11 +	ES11_TEXPARAMETERX)
-#define	VPC_ES11TEXPARAMETERXV			(VPG_ES11 +	ES11_TEXPARAMETERXV)
-#define	VPC_ES11TEXSUBIMAGE2D			(VPG_ES11 +	ES11_TEXSUBIMAGE2D)
-#define	VPC_ES11TRANSLATEF				(VPG_ES11 +	ES11_TRANSLATEF)
-#define	VPC_ES11TRANSLATEX				(VPG_ES11 +	ES11_TRANSLATEX)
-#define	VPC_ES11VERTEXPOINTER			(VPG_ES11 +	ES11_VERTEXPOINTER)
-#define	VPC_ES11VIEWPORT				(VPG_ES11 +	ES11_VIEWPORT)
 /* OpenGL ES11 Statics Counter IDs. */
-#define	VPC_ES11CALLS					(VPG_ES11 +	ES11_CALLS)
-#define	VPC_ES11DRAWCALLS				(VPG_ES11 +	ES11_DRAWCALLS)
-#define	VPC_ES11STATECHANGECALLS		(VPG_ES11 +	ES11_STATECHANGECALLS)
-#define	VPC_ES11POINTCOUNT				(VPG_ES11 +	ES11_POINTCOUNT)
-#define	VPC_ES11LINECOUNT				(VPG_ES11 +	ES11_LINECOUNT)
-#define	VPC_ES11TRIANGLECOUNT			(VPG_ES11 +	ES11_TRIANGLECOUNT)
-
-/* OpenGLES 2.x */
-#define	VPC_ES20ACTIVETEXTURE						(VPG_ES20 +	ES20_ACTIVETEXTURE)
-#define	VPC_ES20ATTACHSHADER						(VPG_ES20 +	ES20_ATTACHSHADER)
-#define	VPC_ES20BINDATTRIBLOCATION					(VPG_ES20 +	ES20_BINDATTRIBLOCATION)
-#define	VPC_ES20BINDBUFFER							(VPG_ES20 +	ES20_BINDBUFFER)
-#define	VPC_ES20BINDFRAMEBUFFER						(VPG_ES20 +	ES20_BINDFRAMEBUFFER)
-#define	VPC_ES20BINDRENDERBUFFER					(VPG_ES20 +	ES20_BINDRENDERBUFFER)
-#define	VPC_ES20BINDTEXTURE							(VPG_ES20 +	ES20_BINDTEXTURE)
-#define	VPC_ES20BLENDCOLOR							(VPG_ES20 +	ES20_BLENDCOLOR)
-#define	VPC_ES20BLENDEQUATION						(VPG_ES20 +	ES20_BLENDEQUATION)
-#define	VPC_ES20BLENDEQUATIONSEPARATE				(VPG_ES20 +	ES20_BLENDEQUATIONSEPARATE)
-#define	VPC_ES20BLENDFUNC							(VPG_ES20 +	ES20_BLENDFUNC)
-#define	VPC_ES20BLENDFUNCSEPARATE					(VPG_ES20 +	ES20_BLENDFUNCSEPARATE)
-#define	VPC_ES20BUFFERDATA							(VPG_ES20 +	ES20_BUFFERDATA)
-#define	VPC_ES20BUFFERSUBDATA						(VPG_ES20 +	ES20_BUFFERSUBDATA)
-#define	VPC_ES20CHECKFRAMEBUFFERSTATUS				(VPG_ES20 +	ES20_CHECKFRAMEBUFFERSTATUS)
-#define	VPC_ES20CLEAR								(VPG_ES20 +	ES20_CLEAR)
-#define	VPC_ES20CLEARCOLOR							(VPG_ES20 +	ES20_CLEARCOLOR)
-#define	VPC_ES20CLEARDEPTHF							(VPG_ES20 +	ES20_CLEARDEPTHF)
-#define	VPC_ES20CLEARSTENCIL						(VPG_ES20 +	ES20_CLEARSTENCIL)
-#define	VPC_ES20COLORMASK							(VPG_ES20 +	ES20_COLORMASK)
-#define	VPC_ES20COMPILESHADER						(VPG_ES20 +	ES20_COMPILESHADER)
-#define	VPC_ES20COMPRESSEDTEXIMAGE2D				(VPG_ES20 +	ES20_COMPRESSEDTEXIMAGE2D)
-#define	VPC_ES20COMPRESSEDTEXSUBIMAGE2D				(VPG_ES20 +	ES20_COMPRESSEDTEXSUBIMAGE2D)
-#define	VPC_ES20COPYTEXIMAGE2D						(VPG_ES20 +	ES20_COPYTEXIMAGE2D)
-#define	VPC_ES20COPYTEXSUBIMAGE2D					(VPG_ES20 +	ES20_COPYTEXSUBIMAGE2D)
-#define	VPC_ES20CREATEPROGRAM						(VPG_ES20 +	ES20_CREATEPROGRAM)
-#define	VPC_ES20CREATESHADER						(VPG_ES20 +	ES20_CREATESHADER)
-#define	VPC_ES20CULLFACE							(VPG_ES20 +	ES20_CULLFACE)
-#define	VPC_ES20DELETEBUFFERS						(VPG_ES20 +	ES20_DELETEBUFFERS)
-#define	VPC_ES20DELETEFRAMEBUFFERS					(VPG_ES20 +	ES20_DELETEFRAMEBUFFERS)
-#define	VPC_ES20DELETEPROGRAM						(VPG_ES20 +	ES20_DELETEPROGRAM)
-#define	VPC_ES20DELETERENDERBUFFERS					(VPG_ES20 +	ES20_DELETERENDERBUFFERS)
-#define	VPC_ES20DELETESHADER						(VPG_ES20 +	ES20_DELETESHADER)
-#define	VPC_ES20DELETETEXTURES						(VPG_ES20 +	ES20_DELETETEXTURES)
-#define	VPC_ES20DEPTHFUNC							(VPG_ES20 +	ES20_DEPTHFUNC)
-#define	VPC_ES20DEPTHMASK							(VPG_ES20 +	ES20_DEPTHMASK)
-#define	VPC_ES20DEPTHRANGEF							(VPG_ES20 +	ES20_DEPTHRANGEF)
-#define	VPC_ES20DETACHSHADER						(VPG_ES20 +	ES20_DETACHSHADER)
-#define	VPC_ES20DISABLE								(VPG_ES20 +	ES20_DISABLE)
-#define	VPC_ES20DISABLEVERTEXATTRIBARRAY			(VPG_ES20 +	ES20_DISABLEVERTEXATTRIBARRAY)
-#define	VPC_ES20DRAWARRAYS							(VPG_ES20 +	ES20_DRAWARRAYS)
-#define	VPC_ES20DRAWELEMENTS						(VPG_ES20 +	ES20_DRAWELEMENTS)
-#define	VPC_ES20ENABLE								(VPG_ES20 +	ES20_ENABLE)
-#define	VPC_ES20ENABLEVERTEXATTRIBARRAY				(VPG_ES20 +	ES20_ENABLEVERTEXATTRIBARRAY)
-#define	VPC_ES20FINISH								(VPG_ES20 +	ES20_FINISH)
-#define	VPC_ES20FLUSH								(VPG_ES20 +	ES20_FLUSH)
-#define	VPC_ES20FRAMEBUFFERRENDERBUFFER				(VPG_ES20 +	ES20_FRAMEBUFFERRENDERBUFFER)
-#define	VPC_ES20FRAMEBUFFERTEXTURE2D				(VPG_ES20 +	ES20_FRAMEBUFFERTEXTURE2D)
-#define	VPC_ES20FRONTFACE							(VPG_ES20 +	ES20_FRONTFACE)
-#define	VPC_ES20GENBUFFERS							(VPG_ES20 +	ES20_GENBUFFERS)
-#define	VPC_ES20GENERATEMIPMAP						(VPG_ES20 +	ES20_GENERATEMIPMAP)
-#define	VPC_ES20GENFRAMEBUFFERS						(VPG_ES20 +	ES20_GENFRAMEBUFFERS)
-#define	VPC_ES20GENRENDERBUFFERS					(VPG_ES20 +	ES20_GENRENDERBUFFERS)
-#define	VPC_ES20GENTEXTURES							(VPG_ES20 +	ES20_GENTEXTURES)
-#define	VPC_ES20GETACTIVEATTRIB						(VPG_ES20 +	ES20_GETACTIVEATTRIB)
-#define	VPC_ES20GETACTIVEUNIFORM					(VPG_ES20 +	ES20_GETACTIVEUNIFORM)
-#define	VPC_ES20GETATTACHEDSHADERS					(VPG_ES20 +	ES20_GETATTACHEDSHADERS)
-#define	VPC_ES20GETATTRIBLOCATION					(VPG_ES20 +	ES20_GETATTRIBLOCATION)
-#define	VPC_ES20GETBOOLEANV							(VPG_ES20 +	ES20_GETBOOLEANV)
-#define	VPC_ES20GETBUFFERPARAMETERIV				(VPG_ES20 +	ES20_GETBUFFERPARAMETERIV)
-#define	VPC_ES20GETERROR							(VPG_ES20 +	ES20_GETERROR)
-#define	VPC_ES20GETFLOATV							(VPG_ES20 +	ES20_GETFLOATV)
-#define	VPC_ES20GETFRAMEBUFFERATTACHMENTPARAMETERIV	(VPG_ES20 +	ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV)
-#define	VPC_ES20GETINTEGERV							(VPG_ES20 +	ES20_GETINTEGERV)
-#define	VPC_ES20GETPROGRAMIV						(VPG_ES20 +	ES20_GETPROGRAMIV)
-#define	VPC_ES20GETPROGRAMINFOLOG					(VPG_ES20 +	ES20_GETPROGRAMINFOLOG)
-#define	VPC_ES20GETRENDERBUFFERPARAMETERIV			(VPG_ES20 +	ES20_GETRENDERBUFFERPARAMETERIV)
-#define	VPC_ES20GETSHADERIV							(VPG_ES20 +	ES20_GETSHADERIV)
-#define	VPC_ES20GETSHADERINFOLOG					(VPG_ES20 +	ES20_GETSHADERINFOLOG)
-#define	VPC_ES20GETSHADERPRECISIONFORMAT			(VPG_ES20 +	ES20_GETSHADERPRECISIONFORMAT)
-#define	VPC_ES20GETSHADERSOURCE						(VPG_ES20 +	ES20_GETSHADERSOURCE)
-#define	VPC_ES20GETSTRING							(VPG_ES20 +	ES20_GETSTRING)
-#define	VPC_ES20GETTEXPARAMETERFV					(VPG_ES20 +	ES20_GETTEXPARAMETERFV)
-#define	VPC_ES20GETTEXPARAMETERIV					(VPG_ES20 +	ES20_GETTEXPARAMETERIV)
-#define	VPC_ES20GETUNIFORMFV						(VPG_ES20 +	ES20_GETUNIFORMFV)
-#define	VPC_ES20GETUNIFORMIV						(VPG_ES20 +	ES20_GETUNIFORMIV)
-#define	VPC_ES20GETUNIFORMLOCATION					(VPG_ES20 +	ES20_GETUNIFORMLOCATION)
-#define	VPC_ES20GETVERTEXATTRIBFV					(VPG_ES20 +	ES20_GETVERTEXATTRIBFV)
-#define	VPC_ES20GETVERTEXATTRIBIV					(VPG_ES20 +	ES20_GETVERTEXATTRIBIV)
-#define	VPC_ES20GETVERTEXATTRIBPOINTERV				(VPG_ES20 +	ES20_GETVERTEXATTRIBPOINTERV)
-#define	VPC_ES20HINT								(VPG_ES20 +	ES20_HINT)
-#define	VPC_ES20ISBUFFER							(VPG_ES20 +	ES20_ISBUFFER)
-#define	VPC_ES20ISENABLED							(VPG_ES20 +	ES20_ISENABLED)
-#define	VPC_ES20ISFRAMEBUFFER						(VPG_ES20 +	ES20_ISFRAMEBUFFER)
-#define	VPC_ES20ISPROGRAM							(VPG_ES20 +	ES20_ISPROGRAM)
-#define	VPC_ES20ISRENDERBUFFER						(VPG_ES20 +	ES20_ISRENDERBUFFER)
-#define	VPC_ES20ISSHADER							(VPG_ES20 +	ES20_ISSHADER)
-#define	VPC_ES20ISTEXTURE							(VPG_ES20 +	ES20_ISTEXTURE)
-#define	VPC_ES20LINEWIDTH							(VPG_ES20 +	ES20_LINEWIDTH)
-#define	VPC_ES20LINKPROGRAM							(VPG_ES20 +	ES20_LINKPROGRAM)
-#define	VPC_ES20PIXELSTOREI							(VPG_ES20 +	ES20_PIXELSTOREI)
-#define	VPC_ES20POLYGONOFFSET						(VPG_ES20 +	ES20_POLYGONOFFSET)
-#define	VPC_ES20READPIXELS							(VPG_ES20 +	ES20_READPIXELS)
-#define	VPC_ES20RELEASESHADERCOMPILER				(VPG_ES20 +	ES20_RELEASESHADERCOMPILER)
-#define	VPC_ES20RENDERBUFFERSTORAGE					(VPG_ES20 +	ES20_RENDERBUFFERSTORAGE)
-#define	VPC_ES20SAMPLECOVERAGE						(VPG_ES20 +	ES20_SAMPLECOVERAGE)
-#define	VPC_ES20SCISSOR								(VPG_ES20 +	ES20_SCISSOR)
-#define	VPC_ES20SHADERBINARY						(VPG_ES20 +	ES20_SHADERBINARY)
-#define	VPC_ES20SHADERSOURCE						(VPG_ES20 +	ES20_SHADERSOURCE)
-#define	VPC_ES20STENCILFUNC							(VPG_ES20 +	ES20_STENCILFUNC)
-#define	VPC_ES20STENCILFUNCSEPARATE					(VPG_ES20 +	ES20_STENCILFUNCSEPARATE)
-#define	VPC_ES20STENCILMASK							(VPG_ES20 +	ES20_STENCILMASK)
-#define	VPC_ES20STENCILMASKSEPARATE					(VPG_ES20 +	ES20_STENCILMASKSEPARATE)
-#define	VPC_ES20STENCILOP							(VPG_ES20 +	ES20_STENCILOP)
-#define	VPC_ES20STENCILOPSEPARATE					(VPG_ES20 +	ES20_STENCILOPSEPARATE)
-#define	VPC_ES20TEXIMAGE2D							(VPG_ES20 +	ES20_TEXIMAGE2D)
-#define	VPC_ES20TEXPARAMETERF						(VPG_ES20 +	ES20_TEXPARAMETERF)
-#define	VPC_ES20TEXPARAMETERFV						(VPG_ES20 +	ES20_TEXPARAMETERFV)
-#define	VPC_ES20TEXPARAMETERI						(VPG_ES20 +	ES20_TEXPARAMETERI)
-#define	VPC_ES20TEXPARAMETERIV						(VPG_ES20 +	ES20_TEXPARAMETERIV)
-#define	VPC_ES20TEXSUBIMAGE2D						(VPG_ES20 +	ES20_TEXSUBIMAGE2D)
-#define	VPC_ES20UNIFORM1F							(VPG_ES20 +	ES20_UNIFORM1F)
-#define	VPC_ES20UNIFORM1FV							(VPG_ES20 +	ES20_UNIFORM1FV)
-#define	VPC_ES20UNIFORM1I							(VPG_ES20 +	ES20_UNIFORM1I)
-#define	VPC_ES20UNIFORM1IV							(VPG_ES20 +	ES20_UNIFORM1IV)
-#define	VPC_ES20UNIFORM2F							(VPG_ES20 +	ES20_UNIFORM2F)
-#define	VPC_ES20UNIFORM2FV							(VPG_ES20 +	ES20_UNIFORM2FV)
-#define	VPC_ES20UNIFORM2I							(VPG_ES20 +	ES20_UNIFORM2I)
-#define	VPC_ES20UNIFORM2IV							(VPG_ES20 +	ES20_UNIFORM2IV)
-#define	VPC_ES20UNIFORM3F							(VPG_ES20 +	ES20_UNIFORM3F)
-#define	VPC_ES20UNIFORM3FV							(VPG_ES20 +	ES20_UNIFORM3FV)
-#define	VPC_ES20UNIFORM3I							(VPG_ES20 +	ES20_UNIFORM3I)
-#define	VPC_ES20UNIFORM3IV							(VPG_ES20 +	ES20_UNIFORM3IV)
-#define	VPC_ES20UNIFORM4F							(VPG_ES20 +	ES20_UNIFORM4F)
-#define	VPC_ES20UNIFORM4FV							(VPG_ES20 +	ES20_UNIFORM4FV)
-#define	VPC_ES20UNIFORM4I							(VPG_ES20 +	ES20_UNIFORM4I)
-#define	VPC_ES20UNIFORM4IV							(VPG_ES20 +	ES20_UNIFORM4IV)
-#define	VPC_ES20UNIFORMMATRIX2FV					(VPG_ES20 +	ES20_UNIFORMMATRIX2FV)
-#define	VPC_ES20UNIFORMMATRIX3FV					(VPG_ES20 +	ES20_UNIFORMMATRIX3FV)
-#define	VPC_ES20UNIFORMMATRIX4FV					(VPG_ES20 +	ES20_UNIFORMMATRIX4FV)
-#define	VPC_ES20USEPROGRAM							(VPG_ES20 +	ES20_USEPROGRAM)
-#define	VPC_ES20VALIDATEPROGRAM						(VPG_ES20 +	ES20_VALIDATEPROGRAM)
-#define	VPC_ES20VERTEXATTRIB1F						(VPG_ES20 +	ES20_VERTEXATTRIB1F)
-#define	VPC_ES20VERTEXATTRIB1FV						(VPG_ES20 +	ES20_VERTEXATTRIB1FV)
-#define	VPC_ES20VERTEXATTRIB2F						(VPG_ES20 +	ES20_VERTEXATTRIB2F)
-#define	VPC_ES20VERTEXATTRIB2FV						(VPG_ES20 +	ES20_VERTEXATTRIB2FV)
-#define	VPC_ES20VERTEXATTRIB3F						(VPG_ES20 +	ES20_VERTEXATTRIB3F)
-#define	VPC_ES20VERTEXATTRIB3FV						(VPG_ES20 +	ES20_VERTEXATTRIB3FV)
-#define	VPC_ES20VERTEXATTRIB4F						(VPG_ES20 +	ES20_VERTEXATTRIB4F)
-#define	VPC_ES20VERTEXATTRIB4FV						(VPG_ES20 +	ES20_VERTEXATTRIB4FV)
-#define	VPC_ES20VERTEXATTRIBPOINTER					(VPG_ES20 +	ES20_VERTEXATTRIBPOINTER)
-#define	VPC_ES20VIEWPORT							(VPG_ES20 +	ES20_VIEWPORT)
+#define    VPC_ES11CALLS            (VPG_ES11 +    ES11_CALLS)
+#define    VPC_ES11DRAWCALLS        (VPG_ES11 +    ES11_DRAWCALLS)
+#define    VPC_ES11STATECHANGECALLS (VPG_ES11 +    ES11_STATECHANGECALLS)
+#define    VPC_ES11POINTCOUNT       (VPG_ES11 +    ES11_POINTCOUNT)
+#define    VPC_ES11LINECOUNT        (VPG_ES11 +    ES11_LINECOUNT)
+#define    VPC_ES11TRIANGLECOUNT    (VPG_ES11 +    ES11_TRIANGLECOUNT)
+
 /* OpenGL ES20 Statistics Counter IDs. */
-#define	VPC_ES20CALLS								(VPG_ES20 +	ES20_CALLS)
-#define	VPC_ES20DRAWCALLS							(VPG_ES20 +	ES20_DRAWCALLS)
-#define	VPC_ES20STATECHANGECALLS					(VPG_ES20 +	ES20_STATECHANGECALLS)
-#define	VPC_ES20POINTCOUNT							(VPG_ES20 +	ES20_POINTCOUNT)
-#define	VPC_ES20LINECOUNT							(VPG_ES20 +	ES20_LINECOUNT)
-#define	VPC_ES20TRIANGLECOUNT						(VPG_ES20 +	ES20_TRIANGLECOUNT)
-
-/* VG11 Counters. */
-#define	VPC_VG11APPENDPATH				(VPG_VG11 +	VG11_APPENDPATH)
-#define	VPC_VG11APPENDPATHDATA			(VPG_VG11 +	VG11_APPENDPATHDATA)
-#define	VPC_VG11CHILDIMAGE				(VPG_VG11 +	VG11_CHILDIMAGE)
-#define	VPC_VG11CLEAR					(VPG_VG11 +	VG11_CLEAR)
-#define	VPC_VG11CLEARGLYPH				(VPG_VG11 +	VG11_CLEARGLYPH)
-#define	VPC_VG11CLEARIMAGE				(VPG_VG11 +	VG11_CLEARIMAGE)
-#define	VPC_VG11CLEARPATH				(VPG_VG11 +	VG11_CLEARPATH)
-#define	VPC_VG11COLORMATRIX				(VPG_VG11 +	VG11_COLORMATRIX)
-#define	VPC_VG11CONVOLVE				(VPG_VG11 +	VG11_CONVOLVE)
-#define	VPC_VG11COPYIMAGE				(VPG_VG11 +	VG11_COPYIMAGE)
-#define	VPC_VG11COPYMASK				(VPG_VG11 +	VG11_COPYMASK)
-#define	VPC_VG11COPYPIXELS				(VPG_VG11 +	VG11_COPYPIXELS)
-#define	VPC_VG11CREATEFONT				(VPG_VG11 +	VG11_CREATEFONT)
-#define	VPC_VG11CREATEIMAGE				(VPG_VG11 +	VG11_CREATEIMAGE)
-#define	VPC_VG11CREATEMASKLAYER			(VPG_VG11 +	VG11_CREATEMASKLAYER)
-#define	VPC_VG11CREATEPAINT				(VPG_VG11 +	VG11_CREATEPAINT)
-#define	VPC_VG11CREATEPATH				(VPG_VG11 +	VG11_CREATEPATH)
-#define	VPC_VG11DESTROYFONT				(VPG_VG11 +	VG11_DESTROYFONT)
-#define	VPC_VG11DESTROYIMAGE			(VPG_VG11 +	VG11_DESTROYIMAGE)
-#define	VPC_VG11DESTROYMASKLAYER		(VPG_VG11 +	VG11_DESTROYMASKLAYER)
-#define	VPC_VG11DESTROYPAINT			(VPG_VG11 +	VG11_DESTROYPAINT)
-#define	VPC_VG11DESTROYPATH				(VPG_VG11 +	VG11_DESTROYPATH)
-#define	VPC_VG11DRAWGLYPH				(VPG_VG11 +	VG11_DRAWGLYPH)
-#define	VPC_VG11DRAWGLYPHS				(VPG_VG11 +	VG11_DRAWGLYPHS)
-#define	VPC_VG11DRAWIMAGE				(VPG_VG11 +	VG11_DRAWIMAGE)
-#define	VPC_VG11DRAWPATH				(VPG_VG11 +	VG11_DRAWPATH)
-#define	VPC_VG11FILLMASKLAYER			(VPG_VG11 +	VG11_FILLMASKLAYER)
-#define	VPC_VG11FINISH					(VPG_VG11 +	VG11_FINISH)
-#define	VPC_VG11FLUSH					(VPG_VG11 +	VG11_FLUSH)
-#define	VPC_VG11GAUSSIANBLUR			(VPG_VG11 +	VG11_GAUSSIANBLUR)
-#define	VPC_VG11GETCOLOR				(VPG_VG11 +	VG11_GETCOLOR)
-#define	VPC_VG11GETERROR				(VPG_VG11 +	VG11_GETERROR)
-#define	VPC_VG11GETF					(VPG_VG11 +	VG11_GETF)
-#define	VPC_VG11GETFV					(VPG_VG11 +	VG11_GETFV)
-#define	VPC_VG11GETI					(VPG_VG11 +	VG11_GETI)
-#define	VPC_VG11GETIMAGESUBDATA			(VPG_VG11 +	VG11_GETIMAGESUBDATA)
-#define	VPC_VG11GETIV					(VPG_VG11 +	VG11_GETIV)
-#define	VPC_VG11GETMATRIX				(VPG_VG11 +	VG11_GETMATRIX)
-#define	VPC_VG11GETPAINT				(VPG_VG11 +	VG11_GETPAINT)
-#define	VPC_VG11GETPARAMETERF			(VPG_VG11 +	VG11_GETPARAMETERF)
-#define	VPC_VG11GETPARAMETERFV			(VPG_VG11 +	VG11_GETPARAMETERFV)
-#define	VPC_VG11GETPARAMETERI			(VPG_VG11 +	VG11_GETPARAMETERI)
-#define	VPC_VG11GETPARAMETERIV			(VPG_VG11 +	VG11_GETPARAMETERIV)
-#define	VPC_VG11GETPARAMETERVECTORSIZE	(VPG_VG11 +	VG11_GETPARAMETERVECTORSIZE)
-#define	VPC_VG11GETPARENT				(VPG_VG11 +	VG11_GETPARENT)
-#define	VPC_VG11GETPATHCAPABILITIES		(VPG_VG11 +	VG11_GETPATHCAPABILITIES)
-#define	VPC_VG11GETPIXELS				(VPG_VG11 +	VG11_GETPIXELS)
-#define	VPC_VG11GETSTRING				(VPG_VG11 +	VG11_GETSTRING)
-#define	VPC_VG11GETVECTORSIZE			(VPG_VG11 +	VG11_GETVECTORSIZE)
-#define	VPC_VG11HARDWAREQUERY			(VPG_VG11 +	VG11_HARDWAREQUERY)
-#define	VPC_VG11IMAGESUBDATA			(VPG_VG11 +	VG11_IMAGESUBDATA)
-#define	VPC_VG11INTERPOLATEPATH			(VPG_VG11 +	VG11_INTERPOLATEPATH)
-#define	VPC_VG11LOADIDENTITY			(VPG_VG11 +	VG11_LOADIDENTITY)
-#define	VPC_VG11LOADMATRIX				(VPG_VG11 +	VG11_LOADMATRIX)
-#define	VPC_VG11LOOKUP					(VPG_VG11 +	VG11_LOOKUP)
-#define	VPC_VG11LOOKUPSINGLE			(VPG_VG11 +	VG11_LOOKUPSINGLE)
-#define	VPC_VG11MASK					(VPG_VG11 +	VG11_MASK)
-#define	VPC_VG11MODIFYPATHCOORDS		(VPG_VG11 +	VG11_MODIFYPATHCOORDS)
-#define	VPC_VG11MULTMATRIX				(VPG_VG11 +	VG11_MULTMATRIX)
-#define	VPC_VG11PAINTPATTERN			(VPG_VG11 +	VG11_PAINTPATTERN)
-#define	VPC_VG11PATHBOUNDS				(VPG_VG11 +	VG11_PATHBOUNDS)
-#define	VPC_VG11PATHLENGTH				(VPG_VG11 +	VG11_PATHLENGTH)
-#define	VPC_VG11PATHTRANSFORMEDBOUNDS	(VPG_VG11 +	VG11_PATHTRANSFORMEDBOUNDS)
-#define	VPC_VG11POINTALONGPATH			(VPG_VG11 +	VG11_POINTALONGPATH)
-#define	VPC_VG11READPIXELS				(VPG_VG11 +	VG11_READPIXELS)
-#define	VPC_VG11REMOVEPATHCAPABILITIES	(VPG_VG11 +	VG11_REMOVEPATHCAPABILITIES)
-#define	VPC_VG11RENDERTOMASK			(VPG_VG11 +	VG11_RENDERTOMASK)
-#define	VPC_VG11ROTATE					(VPG_VG11 +	VG11_ROTATE)
-#define	VPC_VG11SCALE					(VPG_VG11 +	VG11_SCALE)
-#define	VPC_VG11SEPARABLECONVOLVE		(VPG_VG11 +	VG11_SEPARABLECONVOLVE)
-#define	VPC_VG11SETCOLOR				(VPG_VG11 +	VG11_SETCOLOR)
-#define	VPC_VG11SETF					(VPG_VG11 +	VG11_SETF)
-#define	VPC_VG11SETFV					(VPG_VG11 +	VG11_SETFV)
-#define	VPC_VG11SETGLYPHTOIMAGE			(VPG_VG11 +	VG11_SETGLYPHTOIMAGE)
-#define	VPC_VG11SETGLYPHTOPATH			(VPG_VG11 +	VG11_SETGLYPHTOPATH)
-#define	VPC_VG11SETI					(VPG_VG11 +	VG11_SETI)
-#define	VPC_VG11SETIV					(VPG_VG11 +	VG11_SETIV)
-#define	VPC_VG11SETPAINT				(VPG_VG11 +	VG11_SETPAINT)
-#define	VPC_VG11SETPARAMETERF			(VPG_VG11 +	VG11_SETPARAMETERF)
-#define	VPC_VG11SETPARAMETERFV			(VPG_VG11 +	VG11_SETPARAMETERFV)
-#define	VPC_VG11SETPARAMETERI			(VPG_VG11 +	VG11_SETPARAMETERI)
-#define	VPC_VG11SETPARAMETERIV			(VPG_VG11 +	VG11_SETPARAMETERIV)
-#define	VPC_VG11SETPIXELS				(VPG_VG11 +	VG11_SETPIXELS)
-#define	VPC_VG11SHEAR					(VPG_VG11 +	VG11_SHEAR)
-#define	VPC_VG11TRANSFORMPATH			(VPG_VG11 +	VG11_TRANSFORMPATH)
-#define	VPC_VG11TRANSLATE				(VPG_VG11 +	VG11_TRANSLATE)
-#define	VPC_VG11WRITEPIXELS				(VPG_VG11 +	VG11_WRITEPIXELS)
+#define    VPC_ES20CALLS            (VPG_ES20 +    ES20_CALLS)
+#define    VPC_ES20DRAWCALLS        (VPG_ES20 +    ES20_DRAWCALLS)
+#define    VPC_ES20STATECHANGECALLS (VPG_ES20 +    ES20_STATECHANGECALLS)
+#define    VPC_ES20POINTCOUNT       (VPG_ES20 +    ES20_POINTCOUNT)
+#define    VPC_ES20LINECOUNT        (VPG_ES20 +    ES20_LINECOUNT)
+#define    VPC_ES20TRIANGLECOUNT    (VPG_ES20 +    ES20_TRIANGLECOUNT)
+
 /* OpenVG Statistics Counter IDs. */
-#define	VPC_VG11CALLS					(VPG_VG11 +	VG11_CALLS)
-#define	VPC_VG11DRAWCALLS				(VPG_VG11 +	VG11_DRAWCALLS)
-#define	VPC_VG11STATECHANGECALLS		(VPG_VG11 +	VG11_STATECHANGECALLS)
-#define	VPC_VG11FILLCOUNT				(VPG_VG11 +	VG11_FILLCOUNT)
-#define	VPC_VG11STROKECOUNT				(VPG_VG11 +	VG11_STROKECOUNT)
+#define    VPC_VG11CALLS            (VPG_VG11 +    VG11_CALLS)
+#define    VPC_VG11DRAWCALLS        (VPG_VG11 +    VG11_DRAWCALLS)
+#define    VPC_VG11STATECHANGECALLS (VPG_VG11 +    VG11_STATECHANGECALLS)
+#define    VPC_VG11FILLCOUNT        (VPG_VG11 +    VG11_FILLCOUNT)
+#define    VPC_VG11STROKECOUNT      (VPG_VG11 +    VG11_STROKECOUNT)
 
 /* HAL Counters. */
 #define VPC_HALVERTBUFNEWBYTEALLOC      (VPG_HAL + HAL_VERTBUFNEWBYTEALLOC)
@@ -1018,7 +248,7 @@ extern "C" {
 #define VPC_GPUREAD64BYTE               (VPG_GPU + GPU_READ64BYTE)
 #define VPC_GPUWRITE64BYTE              (VPG_GPU + GPU_WRITE64BYTE)
 #define VPC_GPUTOTALCYCLES              (VPG_GPU + GPU_TOTALCYCLES)
-#define VPC_GPUIDLECYCLES              (VPG_GPU + GPU_IDLECYCLES)
+#define VPC_GPUIDLECYCLES               (VPG_GPU + GPU_IDLECYCLES)
 
 /* HW: Shader Counters. */
 #define VPC_VSINSTCOUNT                 (VPG_VS + VS_INSTCOUNT)
@@ -1026,9 +256,9 @@ extern "C" {
 #define VPC_VSTEXLDINSTCOUNT            (VPG_VS + VS_TEXLDINSTCOUNT)
 #define VPC_VSRENDEREDVERTCOUNT         (VPG_VS + VS_RENDEREDVERTCOUNT)
 /* HW: PS Count. */
-#define VPC_PSINSTCOUNT             	(VPG_PS + PS_INSTCOUNT)
-#define VPC_PSBRANCHINSTCOUNT       	(VPG_PS + PS_BRANCHINSTCOUNT)
-#define VPC_PSTEXLDINSTCOUNT        	(VPG_PS + PS_TEXLDINSTCOUNT)
+#define VPC_PSINSTCOUNT                 (VPG_PS + PS_INSTCOUNT)
+#define VPC_PSBRANCHINSTCOUNT           (VPG_PS + PS_BRANCHINSTCOUNT)
+#define VPC_PSTEXLDINSTCOUNT            (VPG_PS + PS_TEXLDINSTCOUNT)
 #define VPC_PSRENDEREDPIXCOUNT          (VPG_PS + PS_RENDEREDPIXCOUNT)
 
 
@@ -1071,7 +301,7 @@ extern "C" {
 #define VPC_PEDRAWNBYDEPTH              (VPG_PE + PE_DRAWNBYDEPTH)
 
 /* HW: MC Counters. */
-#define VPC_MCREADREQ8BPIPE            	(VPG_MC + MC_READREQ8BPIPE)
+#define VPC_MCREADREQ8BPIPE             (VPG_MC + MC_READREQ8BPIPE)
 #define VPC_MCREADREQ8BIP               (VPG_MC + MC_READREQ8BIP)
 #define VPC_MCWRITEREQ8BPIPE            (VPG_MC + MC_WRITEREQ8BPIPE)
 
@@ -1087,6 +317,7 @@ extern "C" {
 #define VPC_PVSATTRIBCOUNT          (VPG_PVS + PVS_ATTRIBCOUNT)
 #define VPC_PVSUNIFORMCOUNT         (VPG_PVS + PVS_UNIFORMCOUNT)
 #define VPC_PVSFUNCTIONCOUNT        (VPG_PVS + PVS_FUNCTIONCOUNT)
+#define VPC_PVSSOURCE               (VPG_PVS + PVS_SOURCE)
 
 #define VPC_PPSINSTRCOUNT           (VPG_PPS + PPS_INSTRCOUNT)
 #define VPC_PPSALUINSTRCOUNT        (VPG_PPS + PPS_ALUINSTRCOUNT)
@@ -1094,7 +325,9 @@ extern "C" {
 #define VPC_PPSATTRIBCOUNT          (VPG_PPS + PPS_ATTRIBCOUNT)
 #define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
 #define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
+#define VPC_PPSSOURCE               (VPG_PPS + PPS_SOURCE)
 
+#define VPC_PROGRAMHANDLE           (VPG_PROG + 1)
 
 #define VPG_ES20_DRAW_NO  (VPG_ES20_DRAW + 1)
 #define VPG_ES11_DRAW_NO  (VPG_ES11_DRAW + 1)
@@ -1118,8 +351,8 @@ typedef struct _gcsPROFILER_COUNTERS
 
     /* HW vairable counters. */
     gctUINT32       gpuCyclesCounter;
-	gctUINT32       gpuTotalCyclesCounter;
-	gctUINT32       gpuIdleCyclesCounter;
+    gctUINT32       gpuTotalCyclesCounter;
+    gctUINT32       gpuIdleCyclesCounter;
     gctUINT32       gpuTotalRead64BytesPerFrame;
     gctUINT32       gpuTotalWrite64BytesPerFrame;
 
@@ -1158,7 +391,7 @@ typedef struct _gcsPROFILER_COUNTERS
     gctUINT32       ra_total_primitive_count;
     gctUINT32       ra_pipe_cache_miss_counter;
     gctUINT32       ra_prefetch_cache_miss_counter;
-	gctUINT32       ra_eez_culled_counter;
+    gctUINT32       ra_eez_culled_counter;
 
     /* TX */
     gctUINT32       tx_total_bilinear_requests;
@@ -1190,7 +423,7 @@ typedef struct _gcsPROFILER
     gctBOOL         enableHal;
     gctBOOL         enableHW;
     gctBOOL         enableSH;
-	gctBOOL         isSyncMode;
+    gctBOOL         isSyncMode;
 
     gctBOOL         useSocket;
     gctINT          sockFd;
@@ -1234,14 +467,17 @@ typedef struct _gcsPROFILER
     gctUINT32       redundantStateChangeCalls;
 #endif
 
-	gctUINT32       prevVSInstCount;
-	gctUINT32       prevVSBranchInstCount;
-	gctUINT32       prevVSTexInstCount;
-	gctUINT32       prevVSVertexCount;
-	gctUINT32       prevPSInstCount;
-	gctUINT32       prevPSBranchInstCount;
-	gctUINT32       prevPSTexInstCount;
-	gctUINT32       prevPSPixelCount;
+    gctUINT32       prevVSInstCount;
+    gctUINT32       prevVSBranchInstCount;
+    gctUINT32       prevVSTexInstCount;
+    gctUINT32       prevVSVertexCount;
+    gctUINT32       prevPSInstCount;
+    gctUINT32       prevPSBranchInstCount;
+    gctUINT32       prevPSTexInstCount;
+    gctUINT32       prevPSPixelCount;
+
+    char*           psSource;
+    char*           vsSource;
 
 }
 gcsPROFILER;
@@ -1315,6 +551,18 @@ gcoPROFILER_Count(
 	IN gctINT Value
 	);
 
+gceSTATUS
+gcoPROFILER_ShaderSourceFS(
+    IN gcoHAL Hal,
+    IN char* source
+    );
+
+gceSTATUS
+gcoPROFILER_ShaderSourceVS(
+    IN gcoHAL Hal,
+    IN char* source
+    );
+
 /* Profile input vertex shader. */
 gceSTATUS
 gcoPROFILER_ShaderVS(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index bc4171e..6e4d830 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -568,6 +568,23 @@ gco2D_MonoBlit(
 	IN gceSURF_FORMAT DestFormat
 	);
 
+gceSTATUS
+gco2D_MonoBlitEx(
+    IN gco2D        Engine,
+    IN gctPOINTER   StreamBits,
+    IN gctINT32     StreamStride,
+    IN gctINT32     StreamWidth,
+    IN gctINT32     StreamHeight,
+    IN gctINT32     StreamX,
+    IN gctINT32     StreamY,
+    IN gctUINT32    FgColor,
+    IN gctUINT32    BgColor,
+    IN gcsRECT_PTR  SrcRect,
+    IN gcsRECT_PTR  DstRect,
+    IN gctUINT8     FgRop,
+    IN gctUINT8     BgRop
+    );
+
 /* Set kernel size. */
 gceSTATUS
 gco2D_SetKernelSize(
@@ -942,6 +959,15 @@ gco2D_SetSourceTileStatus(
     );
 
 gceSTATUS
+gco2D_SetTargetTileStatus(
+    IN gco2D Engine,
+    IN gce2D_TILE_STATUS_CONFIG TileStatusConfig,
+    IN gceSURF_FORMAT CompressedFormat,
+    IN gctUINT32 ClearValue,
+    IN gctUINT32 GpuAddress
+    );
+
+gceSTATUS
 gco2D_QueryU32(
     IN gco2D Engine,
     IN gce2D_QUERY Item,
@@ -955,6 +981,28 @@ gco2D_SetStateU32(
     IN gctUINT32 Value
     );
 
+gceSTATUS
+gco2D_SetStateArrayI32(
+    IN gco2D Engine,
+    IN gce2D_STATE State,
+    IN gctINT32_PTR Array,
+    IN gctINT32 ArraySize
+    );
+
+gceSTATUS
+gco2D_SetStateArrayU32(
+    IN gco2D Engine,
+    IN gce2D_STATE State,
+    IN gctUINT32_PTR Array,
+    IN gctINT32 ArraySize
+    );
+
+gceSTATUS
+gco2D_SetTargetRect(
+    IN gco2D Engine,
+    IN gcsRECT_PTR Rect
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index 5c0877d..14801aa 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -128,6 +128,7 @@ typedef int                     gctBOOL;
 typedef gctBOOL *               gctBOOL_PTR;
 
 typedef int                     gctINT;
+typedef long                    gctLONG;
 typedef signed char             gctINT8;
 typedef signed short            gctINT16;
 typedef signed int              gctINT32;
@@ -171,6 +172,7 @@ typedef void *                  gctFILE;
 typedef void *                  gctSIGNAL;
 typedef void *                  gctWINDOW;
 typedef void *                  gctIMAGE;
+typedef void *                  gctSYNC_POINT;
 
 typedef void *					gctSEMAPHORE;
 
@@ -941,12 +943,19 @@ typedef struct _gcsHAL_FRAME_INFO
     OUT gctUINT                 readRequests[8];
     OUT gctUINT                 writeRequests[8];
 
+    /* FE counters. */
+    OUT gctUINT                 drawCount;
+    OUT gctUINT                 vertexOutCount;
+    OUT gctUINT                 vertexMissCount;
+
     /* 3D counters. */
     OUT gctUINT                 vertexCount;
     OUT gctUINT                 primitiveCount;
     OUT gctUINT                 rejectedPrimitives;
     OUT gctUINT                 culledPrimitives;
     OUT gctUINT                 clippedPrimitives;
+    OUT gctUINT                 droppedPrimitives;
+    OUT gctUINT                 frustumClippedPrimitives;
     OUT gctUINT                 outPrimitives;
     OUT gctUINT                 inPrimitives;
     OUT gctUINT                 culledQuadCount;
@@ -964,18 +973,86 @@ typedef struct _gcsHAL_FRAME_INFO
     OUT gctUINT                 shaderCycles;
     OUT gctUINT                 vsInstructionCount;
     OUT gctUINT                 vsTextureCount;
+    OUT gctUINT                 vsBranchCount;
+    OUT gctUINT                 vsVertices;
     OUT gctUINT                 psInstructionCount;
     OUT gctUINT                 psTextureCount;
+    OUT gctUINT                 psBranchCount;
+    OUT gctUINT                 psPixels;
 
     /* Texture counters. */
     OUT gctUINT                 bilinearRequests;
     OUT gctUINT                 trilinearRequests;
-    OUT gctUINT                 txBytes8;
+    OUT gctUINT                 txBytes8[2];
     OUT gctUINT                 txHitCount;
     OUT gctUINT                 txMissCount;
 }
 gcsHAL_FRAME_INFO;
 
+typedef enum _gcePATCH_ID
+{
+    gcePATCH_UNKNOWN = 0xFFFFFFFF,
+
+    /* Benchmark list*/
+    gcePATCH_GLB11 = 0x0,
+    gcePATCH_GLB21,
+    gcePATCH_GLB25,
+    gcePATCH_GLB27,
+
+    gcePATCH_BM21,
+    gcePATCH_MM,
+    gcePATCH_MM06,
+    gcePATCH_MM07,
+    gcePATCH_QUADRANT,
+    gcePATCH_ANTUTU,
+    gcePATCH_SMARTBENCH,
+    gcePATCH_JPCT,
+    gcePATCH_NENAMARK,
+    gcePATCH_NENAMARK2,
+    gcePATCH_NEOCORE,
+    gcePATCH_GLB,
+    gcePATCH_GB,
+    gcePATCH_RTESTVA,
+    gcePATCH_BMX,
+    gcePATCH_BMGUI,
+
+    /* Game list */
+    gcePATCH_NBA2013,
+    gcePATCH_BARDTALE,
+    gcePATCH_BUSPARKING3D,
+    gcePATCH_FISHBOODLE,
+    gcePATCH_SUBWAYSURFER,
+    gcePATCH_HIGHWAYDRIVER,
+    gcePATCH_PREMIUM,
+    gcePATCH_RACEILLEGAL,
+    gcePATCH_BLABLA,
+    gcePATCH_MEGARUN,
+    gcePATCH_GALAXYONFIRE2,
+    gcePATCH_GLOFTR3HM,
+    gcePATCH_GLOFTSXHM,
+    gcePATCH_GLOFTF3HM,
+    gcePATCH_GLOFTGANG,
+    gcePATCH_XRUNNER,
+    gcePATCH_WP,
+    gcePATCH_DEVIL,
+    gcePATCH_HOLYARCH,
+    gcePATCH_MUSE,
+    gcePATCH_SG,
+    gcePATCH_SIEGECRAFT,
+    gcePATCH_CARCHALLENGE,
+    gcePATCH_HEROESCALL,
+    gcePATCH_MONOPOLY,
+    gcePATCH_CTGL20,
+    gcePATCH_FIREFOX,
+    gcePATCH_CHORME,
+    gcePATCH_DUOKANTV,
+    gcePATCH_TESTAPP,
+
+    /* Count enum*/
+    gcePATCH_COUNT,
+}
+gcePATCH_ID;
+
 #if gcdLINK_QUEUE_SIZE
 typedef struct _gckLINKDATA * gckLINKDATA;
 struct _gckLINKDATA
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index 03cb4d6..2eab666 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -28,7 +28,7 @@
 
 #define gcvVERSION_PATCH        9
 
-#define gcvVERSION_BUILD     6622
+#define gcvVERSION_BUILD     9754
 
 #define gcvVERSION_DATE      __DATE__
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index 78c8f13..888f35e 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -307,6 +307,7 @@ gckGALDEVICE_Construct(
     IN gctUINT LogFileSize,
     IN struct device *pdev,
     IN gctINT PowerManagement,
+    IN gctINT GpuProfiler,
     OUT gckGALDEVICE *Device
     )
 {
@@ -547,6 +548,10 @@ gckGALDEVICE_Construct(
             device->kernels[gcvCORE_MAJOR]->hardware, PowerManagement
             ));
 
+        gcmkONERROR(gckHARDWARE_SetGpuProfiler(
+            device->kernels[gcvCORE_MAJOR]->hardware, GpuProfiler
+            ));
+
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
         gcmkONERROR(gckCOMMAND_Start(device->kernels[gcvCORE_MAJOR]->command));
@@ -605,6 +610,7 @@ gckGALDEVICE_Construct(
             device->kernels[gcvCORE_2D]->hardware, PowerManagement
             ));
 
+
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
         gcmkONERROR(gckCOMMAND_Start(device->kernels[gcvCORE_2D]->command));
@@ -641,6 +647,7 @@ gckGALDEVICE_Construct(
             device->kernels[gcvCORE_VG]->vg->hardware,
             PowerManagement
             ));
+
 #endif
     }
     else
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index c5d6788..c51432f 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -184,6 +184,7 @@ gceSTATUS gckGALDEVICE_Construct(
     IN gctUINT LogFileSize,
     IN struct device *pdev,
     IN gctINT PowerManagement,
+    IN gctINT GpuProfiler,
     OUT gckGALDEVICE *Device
     );
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index 2e1200b..4fcf45a 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -19,6 +19,7 @@
 *
 *****************************************************************************/
 
+
 #include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/notifier.h>
@@ -150,6 +151,9 @@ module_param(compression, int, 0644);
 static int powerManagement = 1;
 module_param(powerManagement, int, 0644);
 
+static int gpuProfiler = 0;
+module_param(gpuProfiler, int, 0644);
+
 static int signal = 48;
 module_param(signal, int, 0644);
 
@@ -253,7 +257,7 @@ int drv_open(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
-    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL | __GFP_NOWARN);
+    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL);
 
     if (data == gcvNULL)
     {
@@ -802,7 +806,9 @@ static int drv_init(struct device *pdev)
 
     printk(KERN_INFO "Galcore version %d.%d.%d.%d\n",
         gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, gcvVERSION_BUILD);
-
+    /* when enable gpu profiler, we need to turn off gpu powerMangement */
+    if(gpuProfiler)
+        powerManagement = 0;
     if (showArgs)
     {
         printk("galcore options:\n");
@@ -834,6 +840,7 @@ static int drv_init(struct device *pdev)
         printk("  physSize          = 0x%08lX\n", physSize);
         printk("  logFileSize       = %d KB \n",  logFileSize);
         printk("  powerManagement   = %d\n",      powerManagement);
+        printk("  gpuProfiler   = %d\n",      gpuProfiler);
 #if ENABLE_GPU_CLOCK_BY_DRIVER
         printk("  coreClock       = %lu\n",     coreClock);
 #endif
@@ -857,6 +864,7 @@ static int drv_init(struct device *pdev)
         logFileSize,
         pdev,
         powerManagement,
+        gpuProfiler,
         &device
         ));
 
@@ -1048,7 +1056,7 @@ static struct notifier_block thermal_hot_pm_notifier = {
 
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static int gpu_probe(struct platform_device *pdev)
 #else
 static int __devinit gpu_probe(struct platform_device *pdev)
@@ -1167,7 +1175,7 @@ static int __devinit gpu_probe(struct platform_device *pdev)
     return ret;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static int gpu_remove(struct platform_device *pdev)
 #else
 static int __devexit gpu_remove(struct platform_device *pdev)
@@ -1356,7 +1364,7 @@ static const struct dev_pm_ops gpu_pm_ops = {
 
 static struct platform_driver gpu_driver = {
     .probe      = gpu_probe,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
     .remove     = gpu_remove,
 #else
     .remove     = __devexit_p(gpu_remove),
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 8740038..331c73f 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -48,6 +48,12 @@ static inline void imx_gpc_power_up_pu(bool flag) {}
 #include <linux/pm_runtime.h>
 
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+#include <linux/file.h>
+#include "gc_hal_kernel_sync.h"
+#endif
+
+
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
 /*******************************************************************************
@@ -153,6 +159,7 @@ typedef struct _gcsINTEGER_DB
 {
     struct idr                  idr;
     spinlock_t                  lock;
+    gctINT                      curr;
 }
 gcsINTEGER_DB;
 
@@ -185,6 +192,14 @@ struct _gckOS
     /* signal id database. */
     gcsINTEGER_DB               signalDB;
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    /* Lock. */
+    gctPOINTER                  syncPointMutex;
+
+    /* sync point id database. */
+    gcsINTEGER_DB               syncPointDB;
+#endif
+
     gcsUSER_MAPPING_PTR         userMap;
     gctPOINTER                  debugLock;
 
@@ -220,6 +235,25 @@ typedef struct _gcsSIGNAL
 }
 gcsSIGNAL;
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+typedef struct _gcsSYNC_POINT * gcsSYNC_POINT_PTR;
+typedef struct _gcsSYNC_POINT
+{
+    /* The reference counter. */
+    atomic_t ref;
+
+    /* State. */
+    atomic_t state;
+
+    /* timeline. */
+    struct sync_timeline * timeline;
+
+    /* ID. */
+    gctUINT32 id;
+}
+gcsSYNC_POINT;
+#endif
+
 typedef struct _gcsPageInfo * gcsPageInfo_PTR;
 typedef struct _gcsPageInfo
 {
@@ -772,18 +806,31 @@ _AllocateIntegerId(
     )
 {
     int result;
+    gctINT next;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-	spin_lock(&Database->lock);
-	/* Try to get a id greater than 0. */
-	result = idr_alloc(&Database->idr, KernelPointer, 1, 0,
-			   GFP_KERNEL | gcdNOWARN);
-	spin_unlock(&Database->lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+    idr_preload(GFP_KERNEL | gcdNOWARN);
+
+    spin_lock(&Database->lock);
 
-	if (result < 0)
-	    return gcvSTATUS_OUT_OF_RESOURCES;
+    next = (Database->curr + 1 <= 0) ? 1 : Database->curr + 1;
+    result = idr_alloc(&Database->idr, KernelPointer, next, 0, GFP_ATOMIC);
 
-	*Id = result;
+    if (!result)
+    {
+        Database->curr = *Id;
+    }
+
+    spin_unlock(&Database->lock);
+
+    idr_preload_end();
+
+    if (result < 0)
+    {
+        return gcvSTATUS_OUT_OF_RESOURCES;
+    }
+
+    *Id = result;
 #else
 again:
     if (idr_pre_get(&Database->idr, GFP_KERNEL | gcdNOWARN) == 0)
@@ -793,8 +840,15 @@ again:
 
     spin_lock(&Database->lock);
 
-    /* Try to get a id greater than 0. */
-    result = idr_get_new_above(&Database->idr, KernelPointer, 1, Id);
+    next = (Database->curr + 1 <= 0) ? 1 : Database->curr + 1;
+
+    /* Try to get a id greater than current id. */
+    result = idr_get_new_above(&Database->idr, KernelPointer, next, Id);
+
+    if (!result)
+    {
+        Database->curr = *Id;
+    }
 
     spin_unlock(&Database->lock);
 
@@ -1026,6 +1080,21 @@ gckOS_Construct(
     /* Initialize signal id database. */
     idr_init(&os->signalDB.idr);
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    /*
+     * Initialize the sync point manager.
+     */
+
+    /* Initialize mutex. */
+    gcmkONERROR(gckOS_CreateMutex(os, &os->syncPointMutex));
+
+    /* Initialize sync point id database lock. */
+    spin_lock_init(&os->syncPointDB.lock);
+
+    /* Initialize sync point id database. */
+    idr_init(&os->syncPointDB.idr);
+#endif
+
 #if gcdUSE_NON_PAGED_MEMORY_CACHE
     os->cacheSize = 0;
     os->cacheHead = gcvNULL;
@@ -1049,6 +1118,15 @@ gckOS_Construct(
     return gcvSTATUS_OK;
 
 OnError:
+
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    if (os->syncPointMutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+            gckOS_DeleteMutex(os, os->syncPointMutex));
+    }
+#endif
+
     if (os->signalMutex != gcvNULL)
     {
         gcmkVERIFY_OK(
@@ -1122,6 +1200,15 @@ gckOS_Destroy(
     _FreeAllNonPagedMemoryCache(Os);
 #endif
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+    /*
+     * Destroy the sync point manager.
+     */
+
+    /* Destroy the mutex. */
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Os, Os->syncPointMutex));
+#endif
+
     /*
      * Destroy the signal manager.
      */
@@ -1979,12 +2066,6 @@ gckOS_AllocateNonPagedMemory(
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-    if ((Os->device->baseAddress & 0x80000000) != (mdl->dmaHandle & 0x80000000))
-    {
-        mdl->dmaHandle = (mdl->dmaHandle & ~0x80000000)
-                       | (Os->device->baseAddress & 0x80000000);
-    }
-
     mdl->addr = addr;
 
     /* Return allocated memory. */
@@ -2325,6 +2406,7 @@ gckOS_ReadRegisterEx(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Address < Os->device->requestedRegisterMemSizes[Core]);
     gcmkVERIFY_ARGUMENT(Data != gcvNULL);
 
     *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
@@ -2375,6 +2457,8 @@ gckOS_WriteRegisterEx(
 {
     gcmkHEADER_ARG("Os=0x%X Core=%d Address=0x%X Data=0x%08x", Os, Core, Address, Data);
 
+    gcmkVERIFY_ARGUMENT(Address < Os->device->requestedRegisterMemSizes[Core]);
+
     writel(Data, (gctUINT8 *)Os->device->registerBases[Core] + Address);
 
     /* Success. */
@@ -3908,8 +3992,13 @@ gckOS_AllocatePagedMemoryEx(
 
     if (Contiguous)
     {
-        /* Get contiguous pages, and suppress warning (stack dump) from kernel when
-           we run out of memory. */
+        gctUINT32 order = get_order(bytes);
+
+        if (order >= MAX_ORDER)
+        {
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
         addr =
             alloc_pages_exact(numPages * PAGE_SIZE, GFP_KERNEL | gcdNOWARN | __GFP_NORETRY);
@@ -3921,12 +4010,12 @@ gckOS_AllocatePagedMemoryEx(
         mdl->exact = gcvTRUE;
 #else
         mdl->u.contiguousPages =
-            alloc_pages(GFP_KERNEL | gcdNOWARN | __GFP_NORETRY, GetOrder(numPages));
+            alloc_pages(GFP_KERNEL | gcdNOWARN | __GFP_NORETRY, order);
 #endif
         if (mdl->u.contiguousPages == gcvNULL)
         {
             mdl->u.contiguousPages =
-                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN, GetOrder(numPages));
+                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN, order);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
             mdl->exact = gcvFALSE;
@@ -4266,13 +4355,13 @@ gckOS_LockPages(
         }
 
         mdlMap->vma->vm_flags |= gcdVM_FLAGS;
-#if !gcdPAGED_MEMORY_CACHEABLE
+
         if (Cacheable == gcvFALSE)
         {
             /* Make this mapping non-cached. */
             mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
         }
-#endif
+
         addr = mdl->addr;
 
         /* Now map all the vmalloc pages to this user address. */
@@ -5363,6 +5452,7 @@ OnError:
         {
             /* Get the user pages. */
             down_read(&current->mm->mmap_sem);
+
             result = get_user_pages(current,
                     current->mm,
                     memory & PAGE_MASK,
@@ -5372,105 +5462,127 @@ OnError:
                     pages,
                     gcvNULL
                     );
+
             up_read(&current->mm->mmap_sem);
 
             if (result <=0 || result < pageCount)
             {
                 struct vm_area_struct *vma;
 
-                /* Free the page table. */
-                if (pages != gcvNULL)
+                /* Release the pages if any. */
+                if (result > 0)
                 {
-                    /* Release the pages if any. */
-                    if (result > 0)
+                    for (i = 0; i < result; i++)
                     {
-                        for (i = 0; i < result; i++)
+                        if (pages[i] == gcvNULL)
                         {
-                            if (pages[i] == gcvNULL)
-                            {
-                                break;
-                            }
-
-                            page_cache_release(pages[i]);
+                            break;
                         }
+
+                        page_cache_release(pages[i]);
+                        pages[i] = gcvNULL;
                     }
 
-                    kfree(pages);
-                    pages = gcvNULL;
+                    result = 0;
                 }
 
                 vma = find_vma(current->mm, memory);
 
-                if (vma && (vma->vm_flags & VM_PFNMAP) )
+                if (vma && (vma->vm_flags & VM_PFNMAP))
                 {
                     pte_t       * pte;
                     spinlock_t  * ptl;
-                    unsigned long pfn;
+                    gctUINTPTR_T logical = memory;
 
-                    pgd_t * pgd = pgd_offset(current->mm, memory);
-                    pud_t * pud = pud_offset(pgd, memory);
-                    if (pud)
+                    for (i = 0; i < pageCount; i++)
                     {
-                        pmd_t * pmd = pmd_offset(pud, memory);
-                        pte = pte_offset_map_lock(current->mm, pmd, memory, &ptl);
-                        if (!pte)
+                        pgd_t * pgd = pgd_offset(current->mm, logical);
+                        pud_t * pud = pud_offset(pgd, logical);
+
+                        if (pud)
+                        {
+                            pmd_t * pmd = pmd_offset(pud, logical);
+                            pte = pte_offset_map_lock(current->mm, pmd, logical, &ptl);
+                            if (!pte)
+                            {
+                                gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                            }
+                        }
+                        else
                         {
                             gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
                         }
+
+                        pages[i] = pte_page(*pte);
+                        pte_unmap_unlock(pte, ptl);
+
+                        /* Advance to next. */
+                        logical += PAGE_SIZE;
                     }
-                    else
+                }
+                else
+                {
+                    gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                }
+
+                /* Check if this memory is contiguous for old mmu. */
+                if (Os->device->kernels[Core]->hardware->mmuVersion == 0)
+                {
+                    for (i = 1; i < pageCount; i++)
                     {
-                        gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                        if (pages[i] != nth_page(pages[0], i))
+                        {
+                            /* Non-contiguous. */
+                            break;
+                        }
                     }
 
-                    pfn      = pte_pfn(*pte);
-
-                    physical = (pfn << PAGE_SHIFT) | (memory & ~PAGE_MASK);
+                    if (i == pageCount)
+                    {
+                        /* Contiguous memory. */
+                        physical = page_to_phys(pages[0]) | (memory & ~PAGE_MASK);
 
-                    pte_unmap_unlock(pte, ptl);
+                        if (!((physical - Os->device->baseAddress) & 0x80000000))
+                        {
+                            kfree(pages);
+                            pages = gcvNULL;
 
-                    if ((Os->device->kernels[Core]->hardware->mmuVersion == 0)
-                            && !((physical - Os->device->baseAddress) & 0x80000000))
-                    {
-                        info->pages = gcvNULL;
-                        info->pageTable = gcvNULL;
+                            info->pages = gcvNULL;
+                            info->pageTable = gcvNULL;
 
-                        MEMORY_MAP_UNLOCK(Os);
+                            MEMORY_MAP_UNLOCK(Os);
 
-                        *Address = physical - Os->device->baseAddress;
-                        *Info    = info;
+                            *Address = physical - Os->device->baseAddress;
+                            *Info    = info;
 
-                        gcmkFOOTER_ARG("*Info=0x%X *Address=0x%08x",
-                                *Info, *Address);
+                            gcmkFOOTER_ARG("*Info=0x%X *Address=0x%08x",
+                                           *Info, *Address);
 
-                        return gcvSTATUS_OK;
+                            return gcvSTATUS_OK;
+                        }
                     }
                 }
-                else
+
+                /* Reference pages. */
+                for (i = 0; i < pageCount; i++)
                 {
-                    gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                    get_page(pages[i]);
                 }
             }
         }
 
-        if (pages)
-        {
-            for (i = 0; i < pageCount; i++)
-            {
-                /* Flush(clean) the data cache. */
-                gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(pages[i]),
-                                 (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
-                                 PAGE_SIZE));
-            }
-        }
-        else
+        for (i = 0; i < pageCount; i++)
         {
+#ifdef CONFIG_ARM
+            gctUINT32 data;
+            get_user(data, (gctUINT32*)((memory & PAGE_MASK) + i * PAGE_SIZE));
+#endif
+
             /* Flush(clean) the data cache. */
             gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                             (gctPOINTER)(gctUINTPTR_T)(physical & PAGE_MASK),
-                             (gctPOINTER)(memory & PAGE_MASK),
-                             PAGE_SIZE * pageCount));
+                             (gctPOINTER)(gctUINTPTR_T)page_to_phys(pages[i]),
+                             (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
+                             PAGE_SIZE));
         }
 
 #if gcdENABLE_VG
@@ -5491,20 +5603,14 @@ OnError:
                                               (gctPOINTER *) &pageTable,
                                               &address));
         }
+
         /* Fill the page table. */
         for (i = 0; i < pageCount; i++)
         {
             gctUINT32 phys;
             gctUINT32_PTR tab = pageTable + i * (PAGE_SIZE/4096);
 
-            if (pages)
-            {
-                phys = page_to_phys(pages[i]);
-            }
-            else
-            {
-                phys = (physical & PAGE_MASK) + i * PAGE_SIZE;
-            }
+            phys = page_to_phys(pages[i]);
 
 #if gcdENABLE_VG
             if (Core == gcvCORE_VG)
@@ -6153,7 +6259,7 @@ gckOS_CacheClean(
 #else
     dma_sync_single_for_device(
               gcvNULL,
-              Physical,
+              (dma_addr_t)Physical,
               Bytes,
               DMA_TO_DEVICE);
 #endif
@@ -6232,7 +6338,7 @@ gckOS_CacheInvalidate(
 #else
     dma_sync_single_for_device(
               gcvNULL,
-              Physical,
+              (dma_addr_t)Physical,
               Bytes,
               DMA_FROM_DEVICE);
 #endif
@@ -6306,7 +6412,7 @@ gckOS_CacheFlush(
 #else
     dma_sync_single_for_device(
               gcvNULL,
-              Physical,
+              (dma_addr_t)Physical,
               Bytes,
               DMA_BIDIRECTIONAL);
 #endif
@@ -8567,3 +8673,338 @@ gckOS_GetProcessNameByPid(
     return gcvSTATUS_OK;
 }
 
+#if gcdANDROID_NATIVE_FENCE_SYNC
+
+gceSTATUS
+gckOS_CreateSyncPoint(
+    IN gckOS Os,
+    OUT gctSYNC_POINT * SyncPoint
+    )
+{
+    gceSTATUS status;
+    gcsSYNC_POINT_PTR syncPoint;
+
+    gcmkHEADER_ARG("Os=0x%X", Os);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    /* Create an sync point structure. */
+    syncPoint = (gcsSYNC_POINT_PTR) kmalloc(
+            sizeof(gcsSYNC_POINT), GFP_KERNEL | gcdNOWARN);
+
+    if (syncPoint == gcvNULL)
+    {
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    /* Initialize the sync point. */
+    atomic_set(&syncPoint->ref, 1);
+    atomic_set(&syncPoint->state, 0);
+
+    gcmkONERROR(_AllocateIntegerId(&Os->syncPointDB, syncPoint, &syncPoint->id));
+
+    *SyncPoint = (gctSYNC_POINT)(gctUINTPTR_T)syncPoint->id;
+
+    gcmkFOOTER_ARG("*SyncPonint=%d", syncPoint->id);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (syncPoint != gcvNULL)
+    {
+        kfree(syncPoint);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_ReferenceSyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    )
+{
+    gceSTATUS status;
+    gcsSYNC_POINT_PTR syncPoint;
+
+    gcmkHEADER_ARG("Os=0x%X", Os);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(SyncPoint != gcvNULL);
+
+    gcmkONERROR(
+        _QueryIntegerId(&Os->syncPointDB,
+                        (gctUINT32)(gctUINTPTR_T)SyncPoint,
+                        (gctPOINTER)&syncPoint));
+
+    /* Initialize the sync point. */
+    atomic_inc(&syncPoint->ref);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_DestroySyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    )
+{
+    gceSTATUS status;
+    gcsSYNC_POINT_PTR syncPoint;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Os=0x%X SyncPoint=%d", Os, (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(SyncPoint != gcvNULL);
+
+    gcmkONERROR(gckOS_AcquireMutex(Os, Os->syncPointMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    gcmkONERROR(
+        _QueryIntegerId(&Os->syncPointDB,
+                        (gctUINT32)(gctUINTPTR_T)SyncPoint,
+                        (gctPOINTER)&syncPoint));
+
+    gcmkASSERT(syncPoint->id == (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    if (atomic_dec_and_test(&syncPoint->ref))
+    {
+        gcmkVERIFY_OK(_DestroyIntegerId(&Os->syncPointDB, syncPoint->id));
+
+        /* Free the sgianl. */
+        syncPoint->timeline = gcvNULL;
+        kfree(syncPoint);
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->syncPointMutex));
+    acquired = gcvFALSE;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->syncPointMutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_SignalSyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint
+    )
+{
+    gceSTATUS status;
+    gcsSYNC_POINT_PTR syncPoint;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Os=0x%X SyncPoint=%d", Os, (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(SyncPoint != gcvNULL);
+
+    gcmkONERROR(gckOS_AcquireMutex(Os, Os->syncPointMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    gcmkONERROR(
+        _QueryIntegerId(&Os->syncPointDB,
+                        (gctUINT32)(gctUINTPTR_T)SyncPoint,
+                        (gctPOINTER)&syncPoint));
+
+    gcmkASSERT(syncPoint->id == (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    /* Get state. */
+    atomic_set(&syncPoint->state, gcvTRUE);
+
+    /* Signal timeline. */
+    if (syncPoint->timeline)
+    {
+        sync_timeline_signal(syncPoint->timeline);
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->syncPointMutex));
+    acquired = gcvFALSE;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->syncPointMutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_QuerySyncPoint(
+    IN gckOS Os,
+    IN gctSYNC_POINT SyncPoint,
+    OUT gctBOOL_PTR State
+    )
+{
+    gceSTATUS status;
+    gcsSYNC_POINT_PTR syncPoint;
+
+    gcmkHEADER_ARG("Os=0x%X SyncPoint=%d", Os, (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(SyncPoint != gcvNULL);
+
+    gcmkONERROR(
+        _QueryIntegerId(&Os->syncPointDB,
+                        (gctUINT32)(gctUINTPTR_T)SyncPoint,
+                        (gctPOINTER)&syncPoint));
+
+    gcmkASSERT(syncPoint->id == (gctUINT32)(gctUINTPTR_T)SyncPoint);
+
+    /* Get state. */
+    *State = atomic_read(&syncPoint->state);
+
+    /* Success. */
+    gcmkFOOTER_ARG("*State=%d", *State);
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckOS_CreateSyncTimeline(
+    IN gckOS Os,
+    OUT gctHANDLE * Timeline
+    )
+{
+    struct viv_sync_timeline * timeline;
+
+    /* Create viv sync timeline. */
+    timeline = viv_sync_timeline_create("viv timeline", Os);
+
+    if (timeline == gcvNULL)
+    {
+        /* Out of memory. */
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    *Timeline = (gctHANDLE) timeline;
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_DestroySyncTimeline(
+    IN gckOS Os,
+    IN gctHANDLE Timeline
+    )
+{
+    struct viv_sync_timeline * timeline;
+    gcmkASSERT(Timeline != gcvNULL);
+
+    /* Destroy timeline. */
+    timeline = (struct viv_sync_timeline *) Timeline;
+    sync_timeline_destroy(&timeline->obj);
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_CreateNativeFence(
+    IN gckOS Os,
+    IN gctHANDLE Timeline,
+    IN gctSYNC_POINT SyncPoint,
+    OUT gctINT * FenceFD
+    )
+{
+    int fd = -1;
+    struct viv_sync_timeline *timeline;
+    struct sync_pt * pt = gcvNULL;
+    struct sync_fence * fence;
+    char name[32];
+    gcsSYNC_POINT_PTR syncPoint;
+    gceSTATUS status;
+
+    gcmkHEADER_ARG("Os=0x%X Timeline=0x%X SyncPoint=%d",
+                   Os, Timeline, (gctUINT)(gctUINTPTR_T)SyncPoint);
+
+    gcmkONERROR(
+        _QueryIntegerId(&Os->syncPointDB,
+                        (gctUINT32)(gctUINTPTR_T)SyncPoint,
+                        (gctPOINTER)&syncPoint));
+
+    /* Cast timeline. */
+    timeline = (struct viv_sync_timeline *) Timeline;
+
+    fd = get_unused_fd();
+
+    if (fd < 0)
+    {
+        /* Out of resources. */
+        gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+    }
+
+    /* Create viv_sync_pt. */
+    pt = viv_sync_pt_create(timeline, SyncPoint);
+
+    if (pt == gcvNULL)
+    {
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    /* Reference sync_timeline. */
+    syncPoint->timeline = &timeline->obj;
+
+    /* Build fence name. */
+    snprintf(name, 32, "viv sync_fence-%u", (gctUINT)(gctUINTPTR_T)SyncPoint);
+
+    /* Create sync_fence. */
+    fence = sync_fence_create(name, pt);
+
+    if (fence == NULL)
+    {
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    /* Install fence to fd. */
+    sync_fence_install(fence, fd);
+
+    *FenceFD = fd;
+    gcmkFOOTER_ARG("*FenceFD=%d", fd);
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Error roll back. */
+    if (pt)
+    {
+        sync_pt_free(pt);
+    }
+
+    if (fd > 0)
+    {
+        put_unused_fd(fd);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
new file mode 100644
index 0000000..7efae1c
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
@@ -0,0 +1,174 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include <linux/kernel.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+
+#include "gc_hal_kernel_sync.h"
+
+#if gcdANDROID_NATIVE_FENCE_SYNC
+
+static struct sync_pt *
+viv_sync_pt_dup(
+    struct sync_pt * sync_pt
+    )
+{
+    gceSTATUS status;
+    struct viv_sync_pt *pt;
+    struct viv_sync_pt *src;
+    struct viv_sync_timeline *obj;
+
+    src = (struct viv_sync_pt *) sync_pt;
+    obj = (struct viv_sync_timeline *) sync_pt->parent;
+
+    /* Create the new sync_pt. */
+    pt = (struct viv_sync_pt *)
+        sync_pt_create(&obj->obj, sizeof(struct viv_sync_pt));
+
+    pt->stamp = src->stamp;
+    pt->sync = src->sync;
+
+    /* Reference sync point. */
+    status = gckOS_ReferenceSyncPoint(obj->os, pt->sync);
+
+    if (gcmIS_ERROR(status))
+    {
+        sync_pt_free((struct sync_pt *)pt);
+        return NULL;
+    }
+
+    return (struct sync_pt *)pt;
+}
+
+static int
+viv_sync_pt_has_signaled(
+    struct sync_pt * sync_pt
+    )
+{
+    gceSTATUS status;
+    gctBOOL state;
+    struct viv_sync_pt * pt;
+    struct viv_sync_timeline * obj;
+
+    pt  = (struct viv_sync_pt *)sync_pt;
+    obj = (struct viv_sync_timeline *)sync_pt->parent;
+
+    status = gckOS_QuerySyncPoint(obj->os, pt->sync, &state);
+
+    if (gcmIS_ERROR(status))
+    {
+        /* Error. */
+        return -1;
+    }
+
+    return state;
+}
+
+static int
+viv_sync_pt_compare(
+    struct sync_pt * a,
+    struct sync_pt * b
+    )
+{
+    int ret;
+    struct viv_sync_pt * pt1 = (struct viv_sync_pt *) a;
+    struct viv_sync_pt * pt2 = (struct viv_sync_pt *) b;
+
+    ret = (pt1->stamp <  pt2->stamp) ? -1
+        : (pt1->stamp == pt2->stamp) ?  0
+        : 1;
+
+    return ret;
+}
+
+static void
+viv_sync_pt_free(
+    struct sync_pt * sync_pt
+    )
+{
+    struct viv_sync_pt * pt;
+    struct viv_sync_timeline * obj;
+
+    pt  = (struct viv_sync_pt *) sync_pt;
+    obj = (struct viv_sync_timeline *) sync_pt->parent;
+
+    gckOS_DestroySyncPoint(obj->os, pt->sync);
+}
+
+static struct sync_timeline_ops viv_timeline_ops =
+{
+    .driver_name = "viv_sync",
+    .dup = viv_sync_pt_dup,
+    .has_signaled = viv_sync_pt_has_signaled,
+    .compare = viv_sync_pt_compare,
+    .free_pt = viv_sync_pt_free,
+};
+
+struct viv_sync_timeline *
+viv_sync_timeline_create(
+    const char * name,
+    gckOS os
+    )
+{
+    struct viv_sync_timeline * obj;
+
+    obj = (struct viv_sync_timeline *)
+        sync_timeline_create(&viv_timeline_ops, sizeof(struct viv_sync_timeline), name);
+
+    obj->os    = os;
+    obj->stamp = 0;
+
+    return obj;
+}
+
+struct sync_pt *
+viv_sync_pt_create(
+    struct viv_sync_timeline * obj,
+    gctSYNC_POINT SyncPoint
+    )
+{
+    gceSTATUS status;
+    struct viv_sync_pt * pt;
+
+    pt = (struct viv_sync_pt *)
+        sync_pt_create(&obj->obj, sizeof(struct viv_sync_pt));
+
+    pt->stamp = obj->stamp++;
+    pt->sync  = SyncPoint;
+
+    /* Dup signal. */
+    status = gckOS_ReferenceSyncPoint(obj->os, SyncPoint);
+
+    if (gcmIS_ERROR(status))
+    {
+        sync_pt_free((struct sync_pt *)pt);
+        return NULL;
+    }
+
+    return (struct sync_pt *) pt;
+}
+
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h
new file mode 100644
index 0000000..6fc12e5
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h
@@ -0,0 +1,71 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifndef __gc_hal_kernel_sync_h_
+#define __gc_hal_kernel_sync_h_
+
+#include <linux/types.h>
+
+#include <linux/sync.h>
+
+#include <gc_hal.h>
+#include <gc_hal_base.h>
+
+struct viv_sync_timeline
+{
+    /* Parent object. */
+    struct sync_timeline obj;
+
+    /* Timestamp when sync_pt is created. */
+    gctUINT stamp;
+
+    /* Pointer to os struct. */
+    gckOS os;
+};
+
+
+struct viv_sync_pt
+{
+    /* Parent object. */
+    struct sync_pt pt;
+
+    /* Reference sync point*/
+    gctSYNC_POINT sync;
+
+    /* Timestamp when sync_pt is created. */
+    gctUINT stamp;
+};
+
+/* Create viv_sync_timeline object. */
+struct viv_sync_timeline *
+viv_sync_timeline_create(
+    const char * Name,
+    gckOS Os
+    );
+
+/* Create viv_sync_pt object. */
+struct sync_pt *
+viv_sync_pt_create(
+    struct viv_sync_timeline * Obj,
+    gctSYNC_POINT SyncPoint
+    );
+
+#endif /* __gc_hal_kernel_sync_h_ */
-- 
1.7.5.4

