From 2df656c09d9102957a41a8cc58b4bff6a3c1e14d Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Thu, 29 Aug 2013 10:03:30 -0400
Subject: [PATCH 0175/1072] ENGR00277234 ARM: imx: correct RBC/WB setting flow

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 0849886fe013dfa3728f22ece1c45312d6bb4853

Currently RBC is enabled right before DSM in asm code
and disabled after resume, as the RBC enable didn't call
imx6_enable_rbc function, so everytime disabling RBC will
be skipped by the logic inside imx6_enable_rbc, this will
disobey the RBC rules: RBC counter should be cleared
after resume and adding at least 2 CKIL(32KHz) clocks with
all wakeup sources masked in GPC;

Move WB setting into DSM enter/exit path only.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/pm-imx6.c |   17 +++--------------
 1 files changed, 3 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index acb3294..ea1643f 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -91,10 +91,7 @@ void imx6_set_cache_lpm_in_wait(bool enable)
 static void imx6_enable_rbc(bool enable)
 {
 	u32 val;
-	static bool last_rbc_mode;
 
-	if (last_rbc_mode == enable)
-		return;
 	/*
 	 * need to mask all interrupts in GPC before
 	 * operating RBC configurations
@@ -122,17 +119,11 @@ static void imx6_enable_rbc(bool enable)
 
 	/* restore GPC interrupt mask settings */
 	imx_gpc_restore_all();
-
-	last_rbc_mode = enable;
 }
 
 static void imx6_enable_wb(bool enable)
 {
 	u32 val;
-	static bool last_wb_mode;
-
-	if (last_wb_mode == enable)
-		return;
 
 	/* configure well bias enable bit */
 	val = readl_relaxed(ccm_base + CLPCR);
@@ -145,8 +136,6 @@ static void imx6_enable_wb(bool enable)
 	val &= ~BM_CCR_WB_COUNT;
 	val |= enable ? BM_CCR_WB_COUNT : 0;
 	writel_relaxed(val, ccm_base + CCR);
-
-	last_wb_mode = enable;
 }
 
 int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
@@ -173,8 +162,6 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 	val &= ~BM_CLPCR_LPM;
 	switch (mode) {
 	case WAIT_CLOCKED:
-		imx6_enable_wb(false);
-		imx6_enable_rbc(false);
 		break;
 	case WAIT_UNCLOCKED:
 		val |= 0x1 << BP_CLPCR_LPM;
@@ -207,7 +194,6 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 		} else {
 			val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
 		}
-		imx6_enable_wb(true);
 		break;
 	default:
 		imx_gpc_irq_mask(&desc->irq_data);
@@ -259,6 +245,7 @@ static int imx6_pm_enter(suspend_state_t state)
 		imx6_set_lpm(WAIT_CLOCKED);
 		break;
 	case PM_SUSPEND_MEM:
+		imx6_enable_wb(true);
 		imx6_set_cache_lpm_in_wait(false);
 		imx6_set_lpm(STOP_POWER_OFF);
 		imx_gpc_pre_suspend(true);
@@ -270,6 +257,8 @@ static int imx6_pm_enter(suspend_state_t state)
 			imx_smp_prepare();
 		imx_anatop_post_resume();
 		imx_gpc_post_resume();
+		imx6_enable_rbc(false);
+		imx6_enable_wb(false);
 		imx6_set_cache_lpm_in_wait(true);
 		imx6_set_lpm(WAIT_CLOCKED);
 		break;
-- 
1.7.5.4

