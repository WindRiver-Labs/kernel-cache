From 3f82951af535c300db1bc1088d88acd0906e0201 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 8 Feb 2013 13:08:51 +0800
Subject: [PATCH 10/13] fsl_imx6q: Add ESAI driver support

Source: Extract from vendor-drop package, L3.0.35_12.09.01.01_GA_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-mxc/devices/Kconfig               |    3 +
 arch/arm/plat-mxc/devices/platform-imx-esai.c   |   75 +++
 arch/arm/plat-mxc/include/mach/devices-common.h |   13 +
 arch/arm/plat-mxc/include/mach/esai.h           |   18 +
 sound/soc/imx/Kconfig                           |    3 +
 sound/soc/imx/Makefile                          |    2 +-
 sound/soc/imx/imx-esai.c                        |  762 +++++++++++++++++++++++
 sound/soc/imx/imx-esai.h                        |  337 ++++++++++
 8 files changed, 1212 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-esai.c
 create mode 100644 arch/arm/plat-mxc/include/mach/esai.h
 create mode 100644 sound/soc/imx/imx-esai.c
 create mode 100644 sound/soc/imx/imx-esai.h

diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index 6947ebf..fd803f5 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -134,3 +134,6 @@ config IMX_HAVE_PLATFORM_IMX_PCIE
 
 config IMX_HAVE_PLATFORM_IMX_ASRC
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_ESAI
+	bool
diff --git a/arch/arm/plat-mxc/devices/platform-imx-esai.c b/arch/arm/plat-mxc/devices/platform-imx-esai.c
new file mode 100644
index 0000000..03bd53b
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-esai.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx53_esai_data_entry(soc, _id, _size)			\
+	[_id] = {							\
+		.id = _id,						\
+		.iobase = MX53_ESAI_BASE_ADDR,		\
+		.iosize = _size,					\
+		.irq = MX53_INT_ESAI,			\
+		.dmatx = soc ## _DMA_REQ_ESAI ## _TX,		\
+		.dmarx = soc ## _DMA_REQ_ESAI ## _RX,		\
+	}
+
+#define imx6q_esai_data_entry(soc, _id, _size)			\
+	[_id] = {							\
+		.id = _id,						\
+		.iobase = ESAI1_BASE_ADDR,		\
+		.iosize = _size,					\
+		.irq = MXC_INT_ESAI,			\
+		.dmatx = soc ## _DMA_REQ_ESAI ## _TX,		\
+		.dmarx = soc ## _DMA_REQ_ESAI ## _RX,		\
+	}
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_imx_esai_data imx53_imx_esai_data[] __initconst = {
+#define imx53_imx_esai_data_entry(_id)				\
+		imx53_esai_data_entry(MX53, _id, SZ_4K)
+		imx53_imx_esai_data_entry(0),
+};
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_imx_esai_data imx6q_imx_esai_data[] __initconst = {
+#define imx6q_imx_esai_data_entry(_id)				\
+	imx6q_esai_data_entry(MX6Q, _id, SZ_4K)
+	imx6q_imx_esai_data_entry(0),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+struct platform_device *__init imx_add_imx_esai(
+		const struct imx_imx_esai_data *data,
+		const struct imx_esai_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+#define DMARES(_name) {							\
+	.name = #_name,							\
+	.start = data->dma ## _name,					\
+	.end = data->dma ## _name,					\
+	.flags = IORESOURCE_DMA,					\
+}
+		DMARES(tx),
+		DMARES(rx),
+	};
+
+	return imx_add_platform_device("imx-esai", data->id,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata));
+}
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index cfc65cd..16c7489 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -552,3 +552,16 @@ struct imx_imx_asrc_data {
 struct platform_device *__init imx_add_imx_asrc(
 		const struct imx_imx_asrc_data *data,
 		const struct imx_asrc_platform_data *pdata);
+
+#include <mach/esai.h>
+struct imx_imx_esai_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq;
+	resource_size_t dmatx;
+	resource_size_t dmarx;
+};
+struct platform_device *__init imx_add_imx_esai(
+		const struct imx_imx_esai_data *data,
+		const struct imx_esai_platform_data *pdata);
diff --git a/arch/arm/plat-mxc/include/mach/esai.h b/arch/arm/plat-mxc/include/mach/esai.h
new file mode 100644
index 0000000..d77eb15
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/esai.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+
+#ifndef __MACH_ESAI_H
+#define __MACH_ESAI_H
+
+struct imx_esai_platform_data {
+	unsigned int flags;
+#define IMX_ESAI_NET            (1 << 0)
+#define IMX_ESAI_SYN            (1 << 1)
+};
+
+#endif
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 2c8b4df..b87855d 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -8,6 +8,9 @@ menuconfig SND_IMX_SOC
 
 if SND_IMX_SOC
 
+config SND_MXC_SOC_ESAI
+	tristate
+
 config SND_SOC_IMX_SSI
 	tristate
 
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index c7231a2..8e9eedf 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -1,5 +1,5 @@
 # i.MX Platform Support
-snd-soc-imx-ssi-objs := imx-ssi.o
+snd-soc-imx-ssi-objs := imx-ssi.o imx-esai.o
 snd-soc-imx-audmux-objs := imx-audmux.o
 
 obj-$(CONFIG_SND_SOC_IMX_SSI) += snd-soc-imx-ssi.o
diff --git a/sound/soc/imx/imx-esai.c b/sound/soc/imx/imx-esai.c
new file mode 100644
index 0000000..f8b7319
--- /dev/null
+++ b/sound/soc/imx/imx-esai.c
@@ -0,0 +1,762 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file       imx-esai.c
+  * @brief      this file implements the esai interface
+  *             in according to ASoC architeture
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/mxc_asrc.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/esai.h>
+
+#include "imx-esai.h"
+#include "imx-pcm.h"
+
+static struct imx_esai *local_esai;
+
+static int imx_esai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 ecr, tccr, rccr;
+
+	ecr = readl(esai->base + ESAI_ECR);
+	tccr = readl(esai->base + ESAI_TCCR);
+	rccr = readl(esai->base + ESAI_RCCR);
+
+	if (dir == SND_SOC_CLOCK_IN) {
+		tccr &= ~(ESAI_TCCR_THCKD | ESAI_TCCR_TCKD | ESAI_TCCR_TFSD);
+		rccr &= ~(ESAI_RCCR_RHCKD | ESAI_RCCR_RCKD | ESAI_RCCR_RFSD);
+	} else {
+		tccr |= ESAI_TCCR_THCKD | ESAI_TCCR_TCKD | ESAI_TCCR_TFSD;
+		rccr |= ESAI_RCCR_RHCKD | ESAI_RCCR_RCKD | ESAI_RCCR_RFSD;
+
+		if (clk_id == ESAI_CLK_FSYS) {
+			ecr &= ~(ESAI_ECR_ETI | ESAI_ECR_ETO);
+			ecr &= ~(ESAI_ECR_ERI | ESAI_ECR_ERO);
+		} else if (clk_id == ESAI_CLK_EXTAL) {
+			ecr |= ESAI_ECR_ETI;
+			ecr |= ESAI_ECR_ETO;
+			ecr |= ESAI_ECR_ERI;
+			ecr |= ESAI_ECR_ERO;
+		} else if (clk_id == ESAI_CLK_EXTAL_DIV) {
+			ecr |= ESAI_ECR_ETI;
+			ecr &= ~ESAI_ECR_ETO;
+			ecr |= ESAI_ECR_ERI;
+			ecr &= ~ESAI_ECR_ERO;
+		}
+	}
+
+	writel(ecr, esai->base + ESAI_ECR);
+	writel(tccr, esai->base + ESAI_TCCR);
+	writel(rccr, esai->base + ESAI_RCCR);
+
+	ESAI_DUMP();
+	return 0;
+}
+
+static int imx_esai_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				   int div_id, int div)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 tccr, rccr;
+
+	tccr = readl(esai->base + ESAI_TCCR);
+	rccr = readl(esai->base + ESAI_RCCR);
+
+	switch (div_id) {
+	case ESAI_TX_DIV_PSR:
+		tccr &= ESAI_TCCR_TPSR_MASK;
+		if (div)
+			tccr |= ESAI_TCCR_TPSR_BYPASS;
+		else
+			tccr &= ~ESAI_TCCR_TPSR_DIV8;
+		break;
+	case ESAI_TX_DIV_PM:
+		tccr &= ESAI_TCCR_TPM_MASK;
+		tccr |= ESAI_TCCR_TPM(div);
+		break;
+	case ESAI_TX_DIV_FP:
+		tccr &= ESAI_TCCR_TFP_MASK;
+		tccr |= ESAI_TCCR_TFP(div);
+		break;
+	case ESAI_RX_DIV_PSR:
+		rccr &= ESAI_RCCR_RPSR_MASK;
+		if (div)
+			rccr |= ESAI_RCCR_RPSR_BYPASS;
+		else
+			rccr &= ~ESAI_RCCR_RPSR_DIV8;
+		break;
+	case ESAI_RX_DIV_PM:
+		rccr &= ESAI_RCCR_RPM_MASK;
+		rccr |= ESAI_RCCR_RPM(div);
+		break;
+	case ESAI_RX_DIV_FP:
+		rccr &= ESAI_RCCR_RFP_MASK;
+		rccr |= ESAI_RCCR_RFP(div);
+		break;
+		return -EINVAL;
+	}
+	writel(tccr, esai->base + ESAI_TCCR);
+	writel(rccr, esai->base + ESAI_RCCR);
+	return 0;
+}
+
+/*
+ * ESAI Network Mode or TDM slots configuration.
+ */
+static int imx_esai_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 tccr, rccr;
+
+	tccr = readl(esai->base + ESAI_TCCR);
+
+	tccr &= ESAI_TCCR_TDC_MASK;
+	tccr |= ESAI_TCCR_TDC(slots - 1);
+
+	writel(tccr, esai->base + ESAI_TCCR);
+	writel((tx_mask & 0xffff), esai->base + ESAI_TSMA);
+	writel(((tx_mask >> 16) & 0xffff), esai->base + ESAI_TSMB);
+
+	rccr = readl(esai->base + ESAI_RCCR);
+
+	rccr &= ESAI_RCCR_RDC_MASK;
+	rccr |= ESAI_RCCR_RDC(slots - 1);
+
+	writel(rccr, esai->base + ESAI_RCCR);
+	writel((rx_mask & 0xffff), esai->base + ESAI_RSMA);
+	writel(((rx_mask >> 16) & 0xffff), esai->base + ESAI_RSMB);
+
+	ESAI_DUMP();
+	return 0;
+}
+
+/*
+ * ESAI DAI format configuration.
+ */
+static int imx_esai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 tcr, tccr, rcr, rccr, saicr;
+
+	tcr = readl(esai->base + ESAI_TCR);
+	tccr = readl(esai->base + ESAI_TCCR);
+	rcr = readl(esai->base + ESAI_RCR);
+	rccr = readl(esai->base + ESAI_RCCR);
+	saicr = readl(esai->base + ESAI_SAICR);
+
+	/* DAI mode */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		/* data on rising edge of bclk, frame low 1clk before data */
+		tcr &= ~ESAI_TCR_TFSL;
+		tcr |= ESAI_TCR_TFSR;
+		rcr &= ~ESAI_RCR_RFSL;
+		rcr |= ESAI_RCR_RFSR;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		/* data on rising edge of bclk, frame high with data */
+		tcr &= ~(ESAI_TCR_TFSL | ESAI_TCR_TFSR);
+		rcr &= ~(ESAI_RCR_RFSL | ESAI_RCR_RFSR);
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		/* data on rising edge of bclk, frame high with data */
+		tcr |= ESAI_TCR_TFSL;
+		rcr |= ESAI_RCR_RFSL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		/* data on rising edge of bclk, frame high 1clk before data */
+		tcr |= ESAI_TCR_TFSL;
+		rcr |= ESAI_RCR_RFSL;
+		break;
+	}
+
+	/* DAI clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		tccr |= ESAI_TCCR_TFSP;
+		tccr &= ~(ESAI_TCCR_TCKP | ESAI_TCCR_THCKP);
+		rccr &= ~(ESAI_RCCR_RCKP | ESAI_RCCR_RHCKP);
+		rccr |= ESAI_RCCR_RFSP;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		tccr &= ~(ESAI_TCCR_TCKP | ESAI_TCCR_THCKP | ESAI_TCCR_TFSP);
+		rccr &= ~(ESAI_RCCR_RCKP | ESAI_RCCR_RHCKP | ESAI_RCCR_RFSP);
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		tccr |= ESAI_TCCR_TCKP | ESAI_TCCR_THCKP | ESAI_TCCR_TFSP;
+		rccr |= ESAI_RCCR_RCKP | ESAI_RCCR_RHCKP | ESAI_RCCR_RFSP;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		tccr &= ~ESAI_TCCR_TFSP;
+		tccr |= ESAI_TCCR_TCKP | ESAI_TCCR_THCKP;
+		rccr &= ~ESAI_RCCR_RFSP;
+		rccr |= ESAI_RCCR_RCKP | ESAI_RCCR_RHCKP;
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		tccr &= ~(ESAI_TCCR_TFSD | ESAI_TCCR_TCKD);
+		rccr &= ~(ESAI_RCCR_RFSD | ESAI_RCCR_RCKD);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		tccr &= ~ESAI_TCCR_TFSD;
+		tccr |= ESAI_TCCR_TCKD;
+		rccr &= ~ESAI_RCCR_RFSD;
+		rccr |= ESAI_RCCR_RCKD;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		tccr &= ~ESAI_TCCR_TCKD;
+		tccr |= ESAI_TCCR_TFSD;
+		rccr &= ~ESAI_RCCR_RCKD;
+		rccr |= ESAI_RCCR_RFSD;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		tccr |= (ESAI_TCCR_TFSD | ESAI_TCCR_TCKD);
+		rccr |= (ESAI_RCCR_RFSD | ESAI_RCCR_RCKD);
+	}
+
+	/* sync */
+	if (esai->flags & IMX_ESAI_SYN)
+		saicr |= ESAI_SAICR_SYNC;
+	else
+		saicr &= ~ESAI_SAICR_SYNC;
+
+	tcr &= ESAI_TCR_TMOD_MASK;
+	rcr &= ESAI_RCR_RMOD_MASK;
+	if (esai->flags & IMX_ESAI_NET) {
+		tcr |= ESAI_TCR_TMOD_NETWORK;
+		rcr |= ESAI_RCR_RMOD_NETWORK;
+	} else {
+		tcr |= ESAI_TCR_TMOD_NORMAL;
+		rcr |= ESAI_RCR_RMOD_NORMAL;
+	}
+
+	writel(tcr, esai->base + ESAI_TCR);
+	writel(tccr, esai->base + ESAI_TCCR);
+	writel(rcr, esai->base + ESAI_RCR);
+	writel(rccr, esai->base + ESAI_RCCR);
+
+	writel(saicr, esai->base + ESAI_SAICR);
+
+	ESAI_DUMP();
+	return 0;
+}
+
+static int imx_esai_startup(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+			(local_esai->imx_esai_txrx_state & IMX_DAI_ESAI_TX)) {
+		pr_err("error: too much esai playback!\n");
+		return -EINVAL;
+	}
+
+	if (!(local_esai->imx_esai_txrx_state & IMX_DAI_ESAI_TXRX)) {
+		clk_enable(esai->clk);
+
+		writel(ESAI_GPIO_ESAI, esai->base + ESAI_PRRC);
+		writel(ESAI_GPIO_ESAI, esai->base + ESAI_PCRC);
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		local_esai->imx_esai_txrx_state |= IMX_DAI_ESAI_TX;
+	else
+		local_esai->imx_esai_txrx_state |= IMX_DAI_ESAI_RX;
+
+	ESAI_DUMP();
+	return 0;
+}
+
+/*
+ * This function is called to initialize the TX port before enable
+ * the tx port.
+ */
+static int imx_esai_hw_tx_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 tcr, tfcr;
+	unsigned int channels;
+#if defined(CONFIG_MXC_ASRC) && defined(SND_MXC_SOC_ESAI)
+	struct imx_pcm_runtime_data *iprtd = substream->runtime->private_data;
+#endif
+
+	tcr = readl(esai->base + ESAI_TCR);
+	tfcr = readl(esai->base + ESAI_TFCR);
+
+	tfcr |= ESAI_TFCR_TFR;
+	writel(tfcr, esai->base + ESAI_TFCR);
+	tfcr &= ~ESAI_TFCR_TFR;
+	/* DAI data (word) size */
+	tfcr &= ESAI_TFCR_TWA_MASK;
+	tcr &= ESAI_TCR_TSWS_MASK;
+
+#if defined(CONFIG_MXC_ASRC) && defined(SND_MXC_SOC_ESAI)
+	if (iprtd->asrc_enable) {
+		switch (iprtd->p2p->p2p_width) {
+		case ASRC_WIDTH_16_BIT:
+			tfcr |= ESAI_WORD_LEN_16;
+			tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL16;
+			break;
+		case ASRC_WIDTH_24_BIT:
+			tfcr |= ESAI_WORD_LEN_24;
+			tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL24;
+			break;
+		default:
+			return -EINVAL;
+
+		}
+		tfcr |= ESAI_WORD_LEN_24;
+		tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL24;
+	} else
+#endif
+	{
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			tfcr |= ESAI_WORD_LEN_16;
+			tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL16;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			tfcr |= ESAI_WORD_LEN_20;
+			tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL20;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			tfcr |= ESAI_WORD_LEN_24;
+			tcr |= ESAI_TCR_TSHFD_MSB | ESAI_TCR_TSWS_STL32_WDL24;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	channels = params_channels(params);
+	tfcr &= ESAI_TFCR_TE_MASK;
+	tfcr |= ESAI_TFCR_TE(channels);
+
+	tfcr |= ESAI_TFCR_TFWM(64);
+
+	/* Left aligned, Zero padding */
+	tcr |= ESAI_TCR_PADC;
+	/* TDR initialized from the FIFO */
+	tfcr |= ESAI_TFCR_TIEN;
+
+	writel(tcr, esai->base + ESAI_TCR);
+	writel(tfcr, esai->base + ESAI_TFCR);
+
+	ESAI_DUMP();
+	return 0;
+}
+
+/*
+ * This function is called to initialize the RX port before enable
+ * the rx port.
+ */
+static int imx_esai_hw_rx_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 rcr, rfcr;
+	unsigned int channels;
+
+	rcr = readl(esai->base + ESAI_RCR);
+	rfcr = readl(esai->base + ESAI_RFCR);
+
+	rfcr |= ESAI_RFCR_RFR;
+	writel(rfcr, esai->base + ESAI_RFCR);
+	rfcr &= ~ESAI_RFCR_RFR;
+
+	rfcr &= ESAI_RFCR_RWA_MASK;
+	rcr &= ESAI_RCR_RSWS_MASK;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		rfcr |= ESAI_WORD_LEN_16;
+		rcr |= ESAI_RCR_RSHFD_MSB | ESAI_RCR_RSWS_STL32_WDL16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		rfcr |= ESAI_WORD_LEN_20;
+		rcr |= ESAI_RCR_RSHFD_MSB | ESAI_RCR_RSWS_STL32_WDL20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		rfcr |= ESAI_WORD_LEN_24;
+		rcr |= ESAI_RCR_RSHFD_MSB | ESAI_RCR_RSWS_STL32_WDL24;
+		break;
+	}
+
+	channels = params_channels(params);
+	rfcr &= ESAI_RFCR_RE_MASK;
+	rfcr |= ESAI_RFCR_RE(channels);
+
+	rfcr |= ESAI_RFCR_RFWM(64);
+
+	writel(rcr, esai->base + ESAI_RCR);
+	writel(rfcr, esai->base + ESAI_RFCR);
+
+	ESAI_DUMP();
+	return 0;
+}
+
+/*
+ * This function is called to initialize the TX or RX port,
+ */
+static int imx_esai_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	struct imx_pcm_dma_params *dma_data;
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (readl(esai->base + ESAI_TCR) & ESAI_TCR_TE0)
+			return 0;
+
+		dma_data = &esai->dma_params_tx;
+		snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+		return imx_esai_hw_tx_params(substream, params, cpu_dai);
+	} else {
+		if (readl(esai->base + ESAI_RCR) & ESAI_RCR_RE1)
+			return 0;
+
+		dma_data = &esai->dma_params_rx;
+		snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+		return imx_esai_hw_rx_params(substream, params, cpu_dai);
+	}
+}
+
+static void imx_esai_shutdown(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		local_esai->imx_esai_txrx_state &= ~IMX_DAI_ESAI_TX;
+	else
+		local_esai->imx_esai_txrx_state &= ~IMX_DAI_ESAI_RX;
+
+	if (!(local_esai->imx_esai_txrx_state & IMX_DAI_ESAI_TXRX))
+		/* close easi clock */
+		clk_disable(esai->clk);
+}
+
+static int imx_esai_trigger(struct snd_pcm_substream *substream, int cmd,
+			    struct snd_soc_dai *cpu_dai)
+{
+	struct imx_esai *esai = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg, tfcr = 0, rfcr = 0;
+	int i;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		tfcr = readl(esai->base + ESAI_TFCR);
+		reg = readl(esai->base + ESAI_TCR);
+	} else {
+		rfcr = readl(esai->base + ESAI_RFCR);
+		reg = readl(esai->base + ESAI_RCR);
+	}
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tfcr |= ESAI_TFCR_TFEN;
+			writel(tfcr, esai->base + ESAI_TFCR);
+			/* write initial words to ETDR register */
+			for (i = 0; i < substream->runtime->channels; i++)
+				writel(0x0, esai->base + ESAI_ETDR);
+			reg |= ESAI_TCR_TE(substream->runtime->channels);
+			writel(reg, esai->base + ESAI_TCR);
+		} else {
+			rfcr |= ESAI_RFCR_RFEN;
+			writel(rfcr, esai->base + ESAI_RFCR);
+			reg |= ESAI_RCR_RE(substream->runtime->channels);
+			writel(reg, esai->base + ESAI_RCR);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			reg &= ~ESAI_TCR_TE(substream->runtime->channels);
+			writel(reg, esai->base + ESAI_TCR);
+			tfcr |= ESAI_TFCR_TFR;
+			tfcr &= ~ESAI_TFCR_TFEN;
+			writel(tfcr, esai->base + ESAI_TFCR);
+			tfcr &= ~ESAI_TFCR_TFR;
+			writel(tfcr, esai->base + ESAI_TFCR);
+		} else {
+			reg &= ~ESAI_RCR_RE(substream->runtime->channels);
+			writel(reg, esai->base + ESAI_RCR);
+			rfcr |= ESAI_RFCR_RFR;
+			rfcr &= ~ESAI_RFCR_RFEN;
+			writel(rfcr, esai->base + ESAI_RFCR);
+			rfcr &= ~ESAI_RFCR_RFR;
+			writel(rfcr, esai->base + ESAI_RFCR);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ESAI_DUMP();
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imx_esai_suspend(struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+static int imx_esai_resume(struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+#else
+#define imx_esai_suspend	NULL
+#define imx_esai_resume	NULL
+#endif
+
+
+#define IMX_ESAI_RATES  SNDRV_PCM_RATE_8000_192000
+
+#define IMX_ESAI_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops imx_esai_dai_ops = {
+	.startup = imx_esai_startup,
+	.shutdown = imx_esai_shutdown,
+	.trigger = imx_esai_trigger,
+	.hw_params = imx_esai_hw_params,
+	.set_sysclk = imx_esai_set_dai_sysclk,
+	.set_clkdiv = imx_esai_set_dai_clkdiv,
+	.set_fmt = imx_esai_set_dai_fmt,
+	.set_tdm_slot = imx_esai_set_dai_tdm_slot,
+};
+
+static int imx_esai_dai_probe(struct snd_soc_dai *dai)
+{
+	struct imx_esai *esai = dev_get_drvdata(dai->dev);
+	local_esai->imx_esai_txrx_state = 0;
+	snd_soc_dai_set_drvdata(dai, esai);
+	return 0;
+}
+
+static struct snd_soc_dai_driver imx_esai_dai = {
+	 .name = "imx-esai.0",
+	 .probe = imx_esai_dai_probe,
+	 .suspend = imx_esai_suspend,
+	 .resume = imx_esai_resume,
+	 .playback = {
+		      .channels_min = 2,
+		      .channels_max = 12,
+		      .rates = IMX_ESAI_RATES,
+		      .formats = IMX_ESAI_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 1,
+		     .channels_max = 8,
+		     .rates = IMX_ESAI_RATES,
+		     .formats = IMX_ESAI_FORMATS,
+		     },
+	 .ops = &imx_esai_dai_ops,
+};
+
+static int imx_esai_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct imx_esai *esai;
+	struct imx_esai_platform_data *pdata = pdev->dev.platform_data;
+	int ret = 0;
+
+	esai = kzalloc(sizeof(*esai), GFP_KERNEL);
+	if (!esai)
+		return -ENOMEM;
+	local_esai = esai;
+	dev_set_drvdata(&pdev->dev, esai);
+
+	if (pdata)
+		esai->flags = pdata->flags;
+
+	esai->irq = platform_get_irq(pdev, 0);
+
+	esai->clk = clk_get(&pdev->dev, "esai_clk");
+	if (IS_ERR(esai->clk)) {
+		ret = PTR_ERR(esai->clk);
+		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
+			ret);
+		goto failed_clk;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto failed_get_resource;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res), DRV_NAME)) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		ret = -EBUSY;
+		goto failed_get_resource;
+	}
+
+	esai->base = ioremap(res->start, resource_size(res));
+	if (!esai->base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENODEV;
+		goto failed_ioremap;
+	}
+
+	esai->dma_params_rx.dma_addr = res->start + ESAI_ERDR;
+	esai->dma_params_tx.dma_addr = res->start + ESAI_ETDR;
+
+	esai->dma_params_tx.shared_peripheral = IMX_DMATYPE_ESAI;
+	esai->dma_params_rx.shared_peripheral = IMX_DMATYPE_ESAI;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");
+	if (res)
+		esai->dma_params_tx.dma = res->start;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");
+	if (res)
+		esai->dma_params_rx.dma = res->start;
+
+	platform_set_drvdata(pdev, esai);
+	ret = snd_soc_register_dai(&pdev->dev, &imx_esai_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "register DAI failed\n");
+		goto failed_register;
+	}
+
+	esai->soc_platform_pdev_fiq =
+		platform_device_alloc("imx-fiq-pcm-audio", pdev->id);
+	if (!esai->soc_platform_pdev_fiq) {
+		ret = -ENOMEM;
+		goto failed_pdev_fiq_alloc;
+	}
+
+	platform_set_drvdata(esai->soc_platform_pdev_fiq, esai);
+	ret = platform_device_add(esai->soc_platform_pdev_fiq);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add platform device\n");
+		goto failed_pdev_fiq_add;
+	}
+
+	esai->soc_platform_pdev =
+		platform_device_alloc("imx-pcm-audio", pdev->id);
+	if (!esai->soc_platform_pdev) {
+		ret = -ENOMEM;
+		goto failed_pdev_alloc;
+	}
+
+	platform_set_drvdata(esai->soc_platform_pdev, esai);
+	ret = platform_device_add(esai->soc_platform_pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add platform device\n");
+		goto failed_pdev_add;
+	}
+
+	writel(ESAI_ECR_ERST, esai->base + ESAI_ECR);
+	writel(ESAI_ECR_ESAIEN, esai->base + ESAI_ECR);
+
+	return 0;
+
+failed_pdev_add:
+	platform_device_put(esai->soc_platform_pdev);
+failed_pdev_alloc:
+	platform_device_del(esai->soc_platform_pdev_fiq);
+failed_pdev_fiq_add:
+	platform_device_put(esai->soc_platform_pdev_fiq);
+failed_pdev_fiq_alloc:
+	snd_soc_unregister_dai(&pdev->dev);
+failed_register:
+	iounmap(esai->base);
+failed_ioremap:
+	release_mem_region(res->start, resource_size(res));
+failed_get_resource:
+	clk_disable(esai->clk);
+	clk_put(esai->clk);
+failed_clk:
+	kfree(esai);
+
+	return ret;
+}
+static int __devexit imx_esai_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct imx_esai *esai = platform_get_drvdata(pdev);
+
+	platform_device_unregister(esai->soc_platform_pdev);
+	platform_device_unregister(esai->soc_platform_pdev_fiq);
+
+	snd_soc_unregister_dai(&pdev->dev);
+
+	iounmap(esai->base);
+	release_mem_region(res->start, resource_size(res));
+	clk_put(esai->clk);
+	kfree(esai);
+
+	return 0;
+}
+
+
+static struct platform_driver imx_esai_driver = {
+	.probe = imx_esai_probe,
+	.remove = __devexit_p(imx_esai_remove),
+	.driver = {
+		   .name = "imx-esai",
+		   },
+};
+
+static int __init imx_esai_init(void)
+{
+	return platform_driver_register(&imx_esai_driver);
+}
+
+static void __exit imx_esai_exit(void)
+{
+	platform_driver_unregister(&imx_esai_driver);
+}
+
+module_init(imx_esai_init);
+module_exit(imx_esai_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX ASoC ESAI driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-esai.h b/sound/soc/imx/imx-esai.h
new file mode 100644
index 0000000..9e7b8b3
--- /dev/null
+++ b/sound/soc/imx/imx-esai.h
@@ -0,0 +1,337 @@
+/*
+ * imx-esai.h  --  ESAI driver header file for Freescale IMX
+ *
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_ESAI_H
+#define _MXC_ESAI_H
+
+#ifdef IMX_ESAI_DUMP
+#define ESAI_DUMP() \
+	do {pr_info("dump @ %s\n", __func__); \
+	pr_info("ESAI_ECR   0x%08x\n", readl(esai->base + ESAI_ECR)); \
+	pr_info("ESAI_ESR   0x%08x\n", readl(esai->base + ESAI_ESR)); \
+	pr_info("ESAI_TFCR  0x%08x\n", readl(esai->base + ESAI_TFCR)); \
+	pr_info("ESAI_TFSR  0x%08x\n", readl(esai->base + ESAI_TFSR)); \
+	pr_info("ESAI_RFCR  0x%08x\n", readl(esai->base + ESAI_RFCR)); \
+	pr_info("ESAI_RFSR  0x%08x\n", readl(esai->base + ESAI_RFSR)); \
+	pr_info("ESAI_TSR   0x%08x\n", readl(esai->base + ESAI_TSR)); \
+	pr_info("ESAI_SAISR 0x%08x\n", readl(esai->base + ESAI_SAISR)); \
+	pr_info("ESAI_SAICR 0x%08x\n", readl(esai->base + ESAI_SAICR)); \
+	pr_info("ESAI_TCR   0x%08x\n", readl(esai->base + ESAI_TCR)); \
+	pr_info("ESAI_TCCR  0x%08x\n", readl(esai->base + ESAI_TCCR)); \
+	pr_info("ESAI_RCR   0x%08x\n", readl(esai->base + ESAI_RCR)); \
+	pr_info("ESAI_RCCR  0x%08x\n", readl(esai->base + ESAI_RCCR)); \
+	pr_info("ESAI_TSMA  0x%08x\n", readl(esai->base + ESAI_TSMA)); \
+	pr_info("ESAI_TSMB  0x%08x\n", readl(esai->base + ESAI_TSMB)); \
+	pr_info("ESAI_RSMA  0x%08x\n", readl(esai->base + ESAI_RSMA)); \
+	pr_info("ESAI_RSMB  0x%08x\n", readl(esai->base + ESAI_RSMB)); \
+	pr_info("ESAI_PRRC  0x%08x\n", readl(esai->base + ESAI_PRRC)); \
+	pr_info("ESAI_PCRC  0x%08x\n", readl(esai->base + ESAI_PCRC)); \
+	} while (0);
+#else
+#define ESAI_DUMP()
+#endif
+
+#define ESAI_ETDR	0x00
+#define ESAI_ERDR	0x04
+#define ESAI_ECR	0x08
+#define ESAI_ESR	0x0C
+#define ESAI_TFCR	0x10
+#define ESAI_TFSR	0x14
+#define ESAI_RFCR	0x18
+#define ESAI_RFSR	0x1C
+#define ESAI_TX0	0x80
+#define ESAI_TX1	0x84
+#define ESAI_TX2	0x88
+#define ESAI_TX3	0x8C
+#define ESAI_TX4	0x90
+#define ESAI_TX5	0x94
+#define ESAI_TSR	0x98
+#define ESAI_RX0	0xA0
+#define ESAI_RX1	0xA4
+#define ESAI_RX2	0xA8
+#define ESAI_RX3	0xAC
+#define ESAI_SAISR	0xCC
+#define ESAI_SAICR	0xD0
+#define ESAI_TCR	0xD4
+#define ESAI_TCCR	0xD8
+#define ESAI_RCR	0xDC
+#define ESAI_RCCR	0xE0
+#define ESAI_TSMA	0xE4
+#define ESAI_TSMB	0xE8
+#define ESAI_RSMA	0xEC
+#define ESAI_RSMB	0xF0
+#define ESAI_PRRC	0xF8
+#define ESAI_PCRC	0xFC
+
+#define ESAI_ECR_ETI	(1 << 19)
+#define ESAI_ECR_ETO	(1 << 18)
+#define ESAI_ECR_ERI	(1 << 17)
+#define ESAI_ECR_ERO	(1 << 16)
+#define ESAI_ECR_ERST	(1 << 1)
+#define ESAI_ECR_ESAIEN	(1 << 0)
+
+#define ESAI_ESR_TINIT	(1 << 10)
+#define ESAI_ESR_RFF	(1 << 9)
+#define ESAI_ESR_TFE	(1 << 8)
+#define ESAI_ESR_TLS	(1 << 7)
+#define ESAI_ESR_TDE	(1 << 6)
+#define ESAI_ESR_TED	(1 << 5)
+#define ESAI_ESR_TD	(1 << 4)
+#define ESAI_ESR_RLS	(1 << 3)
+#define ESAI_ESR_RDE	(1 << 2)
+#define ESAI_ESR_RED	(1 << 1)
+#define ESAI_ESR_RD	(1 << 0)
+
+#define ESAI_TFCR_TIEN	(1 << 19)
+#define ESAI_TFCR_TE5	(1 << 7)
+#define ESAI_TFCR_TE4	(1 << 6)
+#define ESAI_TFCR_TE3	(1 << 5)
+#define ESAI_TFCR_TE2	(1 << 4)
+#define ESAI_TFCR_TE1	(1 << 3)
+#define ESAI_TFCR_TE0	(1 << 2)
+#define ESAI_TFCR_TFR	(1 << 1)
+#define ESAI_TFCR_TFEN	(1 << 0)
+#define ESAI_TFCR_TE(x) ((0x3f >> (6 - ((x + 1) >> 1))) << 2)
+#define ESAI_TFCR_TE_MASK	0xfff03
+#define ESAI_TFCR_TFWM(x)	((x - 1) << 8)
+#define ESAI_TFCR_TWA_MASK	0xf8ffff
+
+#define ESAI_RFCR_REXT	(1 << 19)
+#define ESAI_RFCR_RE3	(1 << 5)
+#define ESAI_RFCR_RE2	(1 << 4)
+#define ESAI_RFCR_RE1	(1 << 3)
+#define ESAI_RFCR_RE0	(1 << 2)
+#define ESAI_RFCR_RFR	(1 << 1)
+#define ESAI_RFCR_RFEN	(1 << 0)
+#define ESAI_RFCR_RE(x) ((0xf >> (4 - ((x + 1) >> 1))) << 2)
+#define ESAI_RFCR_RE_MASK	0xfffc3
+#define ESAI_RFCR_RFWM(x)       ((x-1) << 8)
+#define ESAI_RFCR_RWA_MASK	0xf8ffff
+
+#define ESAI_WORD_LEN_32	(0x00 << 16)
+#define ESAI_WORD_LEN_28	(0x01 << 16)
+#define ESAI_WORD_LEN_24	(0x02 << 16)
+#define ESAI_WORD_LEN_20	(0x03 << 16)
+#define ESAI_WORD_LEN_16	(0x04 << 16)
+#define ESAI_WORD_LEN_12	(0x05 << 16)
+#define ESAI_WORD_LEN_8	(0x06 << 16)
+#define ESAI_WORD_LEN_4	(0x07 << 16)
+
+#define ESAI_SAISR_TODFE	(1 << 17)
+#define ESAI_SAISR_TEDE	(1 << 16)
+#define ESAI_SAISR_TDE	(1 << 15)
+#define ESAI_SAISR_TUE	(1 << 14)
+#define ESAI_SAISR_TFS	(1 << 13)
+#define ESAI_SAISR_RODF	(1 << 10)
+#define ESAI_SAISR_REDF	(1 << 9)
+#define ESAI_SAISR_RDF	(1 << 8)
+#define ESAI_SAISR_ROE	(1 << 7)
+#define ESAI_SAISR_RFS	(1 << 6)
+#define ESAI_SAISR_IF2	(1 << 2)
+#define ESAI_SAISR_IF1	(1 << 1)
+#define ESAI_SAISR_IF0	(1 << 0)
+
+#define ESAI_SAICR_ALC	(1 << 8)
+#define ESAI_SAICR_TEBE	(1 << 7)
+#define ESAI_SAICR_SYNC	(1 << 6)
+#define ESAI_SAICR_OF2	(1 << 2)
+#define ESAI_SAICR_OF1	(1 << 1)
+#define ESAI_SAICR_OF0	(1 << 0)
+
+#define ESAI_TCR_TLIE	(1 << 23)
+#define ESAI_TCR_TIE	(1 << 22)
+#define ESAI_TCR_TEDIE	(1 << 21)
+#define ESAI_TCR_TEIE	(1 << 20)
+#define ESAI_TCR_TPR	(1 << 19)
+#define ESAI_TCR_PADC	(1 << 17)
+#define ESAI_TCR_TFSR	(1 << 16)
+#define ESAI_TCR_TFSL	(1 << 15)
+#define ESAI_TCR_TWA	(1 << 7)
+#define ESAI_TCR_TSHFD_MSB	(0 << 6)
+#define ESAI_TCR_TSHFD_LSB	(1 << 6)
+#define ESAI_TCR_TE5	(1 << 5)
+#define ESAI_TCR_TE4	(1 << 4)
+#define ESAI_TCR_TE3	(1 << 3)
+#define ESAI_TCR_TE2	(1 << 2)
+#define ESAI_TCR_TE1	(1 << 1)
+#define ESAI_TCR_TE0	(1 << 0)
+#define ESAI_TCR_TE(x) (0x3f >> (6 - ((x + 1) >> 1)))
+
+#define ESAI_TCR_TSWS_MASK	0xff83ff
+#define ESAI_TCR_TSWS_STL8_WDL8	(0x00 << 10)
+#define ESAI_TCR_TSWS_STL12_WDL8	(0x04 << 10)
+#define ESAI_TCR_TSWS_STL12_WDL12	(0x01 << 10)
+#define ESAI_TCR_TSWS_STL16_WDL8	(0x08 << 10)
+#define ESAI_TCR_TSWS_STL16_WDL12	(0x05 << 10)
+#define ESAI_TCR_TSWS_STL16_WDL16	(0x02 << 10)
+#define ESAI_TCR_TSWS_STL20_WDL8	(0x0c << 10)
+#define ESAI_TCR_TSWS_STL20_WDL12	(0x09 << 10)
+#define ESAI_TCR_TSWS_STL20_WDL16	(0x06 << 10)
+#define ESAI_TCR_TSWS_STL20_WDL20	(0x03 << 10)
+#define ESAI_TCR_TSWS_STL24_WDL8	(0x10 << 10)
+#define ESAI_TCR_TSWS_STL24_WDL12	(0x0d << 10)
+#define ESAI_TCR_TSWS_STL24_WDL16	(0x0a << 10)
+#define ESAI_TCR_TSWS_STL24_WDL20	(0x07 << 10)
+#define ESAI_TCR_TSWS_STL24_WDL24	(0x1e << 10)
+#define ESAI_TCR_TSWS_STL32_WDL8	(0x18 << 10)
+#define ESAI_TCR_TSWS_STL32_WDL12	(0x15 << 10)
+#define ESAI_TCR_TSWS_STL32_WDL16	(0x12 << 10)
+#define ESAI_TCR_TSWS_STL32_WDL20	(0x0f << 10)
+#define ESAI_TCR_TSWS_STL32_WDL24	(0x1f << 10)
+
+#define ESAI_TCR_TMOD_MASK	0xfffcff
+#define ESAI_TCR_TMOD_NORMAL	(0x00 << 8)
+#define ESAI_TCR_TMOD_ONDEMAND	(0x01 << 8)
+#define ESAI_TCR_TMOD_NETWORK	(0x01 << 8)
+#define ESAI_TCR_TMOD_RESERVED (0x02 << 8)
+#define ESAI_TCR_TMOD_AC97	(0x03 << 8)
+
+#define ESAI_TCCR_THCKD	(1 << 23)
+#define ESAI_TCCR_TFSD	(1 << 22)
+#define ESAI_TCCR_TCKD	(1 << 21)
+#define ESAI_TCCR_THCKP	(1 << 20)
+#define ESAI_TCCR_TFSP	(1 << 19)
+#define ESAI_TCCR_TCKP	(1 << 18)
+
+#define ESAI_TCCR_TPSR_MASK 0xfffeff
+#define ESAI_TCCR_TPSR_BYPASS (1 << 8)
+#define ESAI_TCCR_TPSR_DIV8 (0 << 8)
+
+#define ESAI_TCCR_TFP_MASK	0xfc3fff
+#define ESAI_TCCR_TFP(x)	((x & 0xf) << 14)
+
+#define ESAI_TCCR_TDC_MASK	0xffc1ff
+#define ESAI_TCCR_TDC(x)	(((x) & 0x1f) << 9)
+
+#define ESAI_TCCR_TPM_MASK	0xffff00
+#define ESAI_TCCR_TPM(x)	(x & 0xff)
+
+#define ESAI_RCR_RLIE	(1 << 23)
+#define ESAI_RCR_RIE	(1 << 22)
+#define ESAI_RCR_REDIE	(1 << 21)
+#define ESAI_RCR_REIE	(1 << 20)
+#define ESAI_RCR_RPR	(1 << 19)
+#define ESAI_RCR_RFSR	(1 << 16)
+#define ESAI_RCR_RFSL	(1 << 15)
+#define ESAI_RCR_RWA	(1 << 7)
+#define ESAI_RCR_RSHFD_MSB (0 << 6)
+#define ESAI_RCR_RSHFD_LSB (1 << 6)
+#define ESAI_RCR_RE3	(1 << 3)
+#define ESAI_RCR_RE2	(1 << 2)
+#define ESAI_RCR_RE1	(1 << 1)
+#define ESAI_RCR_RE0	(1 << 0)
+#define ESAI_RCR_RE(x) (0xf >> (4 - ((x + 1) >> 1)))
+
+#define ESAI_RCR_RSWS_MASK	0xff83ff
+#define ESAI_RCR_RSWS_STL8_WDL8	(0x00 << 10)
+#define ESAI_RCR_RSWS_STL12_WDL8	(0x04 << 10)
+#define ESAI_RCR_RSWS_STL12_WDL12	(0x01 << 10)
+#define ESAI_RCR_RSWS_STL16_WDL8	(0x08 << 10)
+#define ESAI_RCR_RSWS_STL16_WDL12	(0x05 << 10)
+#define ESAI_RCR_RSWS_STL16_WDL16	(0x02 << 10)
+#define ESAI_RCR_RSWS_STL20_WDL8	(0x0c << 10)
+#define ESAI_RCR_RSWS_STL20_WDL12	(0x09 << 10)
+#define ESAI_RCR_RSWS_STL20_WDL16	(0x06 << 10)
+#define ESAI_RCR_RSWS_STL20_WDL20	(0x03 << 10)
+#define ESAI_RCR_RSWS_STL24_WDL8	(0x10 << 10)
+#define ESAI_RCR_RSWS_STL24_WDL12	(0x0d << 10)
+#define ESAI_RCR_RSWS_STL24_WDL16	(0x0a << 10)
+#define ESAI_RCR_RSWS_STL24_WDL20	(0x07 << 10)
+#define ESAI_RCR_RSWS_STL24_WDL24	(0x1e << 10)
+#define ESAI_RCR_RSWS_STL32_WDL8	(0x18 << 10)
+#define ESAI_RCR_RSWS_STL32_WDL12	(0x15 << 10)
+#define ESAI_RCR_RSWS_STL32_WDL16	(0x12 << 10)
+#define ESAI_RCR_RSWS_STL32_WDL20	(0x0f << 10)
+#define ESAI_RCR_RSWS_STL32_WDL24	(0x1f << 10)
+
+#define ESAI_RCR_RMOD_MASK	0xfffcff
+#define ESAI_RCR_RMOD_NORMAL	(0x00 << 8)
+#define ESAI_RCR_RMOD_ONDEMAND	(0x01 << 8)
+#define ESAI_RCR_RMOD_NETWORK	(0x01 << 8)
+#define ESAI_RCR_RMOD_RESERVED (0x02 << 8)
+#define ESAI_RCR_RMOD_AC97	(0x03 << 8)
+
+#define ESAI_RCCR_RHCKD	(1 << 23)
+#define ESAI_RCCR_RFSD	(1 << 22)
+#define ESAI_RCCR_RCKD	(1 << 21)
+#define ESAI_RCCR_RHCKP	(1 << 20)
+#define ESAI_RCCR_RFSP	(1 << 19)
+#define ESAI_RCCR_RCKP	(1 << 18)
+
+#define ESAI_RCCR_RPSR_MASK 0xfffeff
+#define ESAI_RCCR_RPSR_BYPASS (1 << 8)
+#define ESAI_RCCR_RPSR_DIV8 (0 << 8)
+
+#define ESAI_RCCR_RFP_MASK	0xfc3fff
+#define ESAI_RCCR_RFP(x)	((x & 0xf) << 14)
+
+#define ESAI_RCCR_RDC_MASK	0xffc1ff
+#define ESAI_RCCR_RDC(x)	(((x) & 0x1f) << 9)
+
+#define ESAI_RCCR_RPM_MASK	0xffff00
+#define ESAI_RCCR_RPM(x)	(x & 0xff)
+
+#define ESAI_GPIO_ESAI	0xfff
+
+/* ESAI clock source */
+#define ESAI_CLK_FSYS	0
+#define ESAI_CLK_EXTAL 1
+#define ESAI_CLK_EXTAL_DIV 2
+
+/* ESAI clock divider */
+#define ESAI_TX_DIV_PSR	0
+#define ESAI_TX_DIV_PM 1
+#define ESAI_TX_DIV_FP	2
+#define ESAI_RX_DIV_PSR	3
+#define ESAI_RX_DIV_PM	4
+#define ESAI_RX_DIV_FP	5
+
+#define IMX_ESAI_DMABUF_SIZE     (64 * 1024)
+
+#define DRV_NAME "imx-esai"
+
+#include <linux/dmaengine.h>
+#include <mach/dma.h>
+#include "imx-pcm.h"
+
+#define IMX_DAI_ESAI_TX 0x04
+#define IMX_DAI_ESAI_RX 0x08
+#define IMX_DAI_ESAI_TXRX (IMX_DAI_ESAI_TX | IMX_DAI_ESAI_RX)
+
+struct imx_esai {
+	struct platform_device *ac97_dev;
+	struct snd_soc_dai *imx_ac97;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;
+	int fiq_enable;
+	unsigned int offset;
+
+	unsigned int flags;
+
+	void (*ac97_reset) (struct snd_ac97 *ac97);
+	void (*ac97_warm_reset)(struct snd_ac97 *ac97);
+
+	struct imx_pcm_dma_params dma_params_rx;
+	struct imx_pcm_dma_params dma_params_tx;
+
+	int enabled;
+	int imx_esai_txrx_state;
+
+	struct platform_device *soc_platform_pdev;
+	struct platform_device *soc_platform_pdev_fiq;
+};
+
+#endif
-- 
1.7.0

