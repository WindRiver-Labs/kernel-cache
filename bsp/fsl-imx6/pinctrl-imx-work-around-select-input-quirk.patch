From 4fd1d072be1e4764c1fd4701451dd42781ed9aca Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@linaro.org>
Date: Sun, 4 Aug 2013 21:39:23 +0800
Subject: [PATCH 0962/1072] pinctrl: imx: work around select input quirk

commit 94176faf279ba96394f77cde62b1fdb8304ed30d upstream

The select input for some pin may not be implemented using the regular
select input register but the general purpose register.  A real example
is that imx6q designers found the select input for USB OTG ID pin is
missing at the very late stage, and can not add a new select input
register but have to use a general purpose register bit to implement it.

The patch adds a workaround for such select input quirk by interpreting
the input_val cell of pin function ID in a different way, so that all
the info that needed for setting up select input bits in general purpose
register could be decoded from there.

Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
Tested-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/pinctrl/pinctrl-imx.c |   34 ++++++++++++++++++++++++++++++++--
 1 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/drivers/pinctrl/pinctrl-imx.c b/drivers/pinctrl/pinctrl-imx.c
index 57a4eb0..7284b86 100644
--- a/drivers/pinctrl/pinctrl-imx.c
+++ b/drivers/pinctrl/pinctrl-imx.c
@@ -239,8 +239,38 @@ static int imx_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,
 		dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",
 			pin_reg->mux_reg, mux[i]);
 
-		/* some pins also need select input setting, set it if found */
-		if (input_reg[i]) {
+		/*
+		 * If the select input value begins with 0xff, it's a quirky
+		 * select input and the value should be interpreted as below.
+		 *     31     23      15      7        0
+		 *     | 0xff | shift | width | select |
+		 * It's used to work around the problem that the select
+		 * input for some pin is not implemented in the select
+		 * input register but in some general purpose register.
+		 * We encode the select input value, width and shift of
+		 * the bit field into input_val cell of pin function ID
+		 * in device tree, and then decode them here for setting
+		 * up the select input bits in general purpose register.
+		 */
+		if (input_val[i] >> 24 == 0xff) {
+			u32 val = input_val[i];
+			u8 select = val & 0xff;
+			u8 width = (val >> 8) & 0xff;
+			u8 shift = (val >> 16) & 0xff;
+			u32 mask = ((1 << width) - 1) << shift;
+			/*
+			 * The input_reg[i] here is actually some IOMUXC general
+			 * purpose register, not regular select input register.
+			 */
+			val = readl(ipctl->base + input_reg[i]);
+			val &= ~mask;
+			val |= select << shift;
+			writel(val, ipctl->base + input_reg[i]);
+		} else if (input_reg[i]) {
+			/*
+			 * Regular select input register can never be at offset
+			 * 0, and we only print register value for regular case.
+			 */
 			writel(input_val[i], ipctl->base + input_reg[i]);
 			dev_dbg(ipctl->dev,
 				"==>select_input: offset 0x%x val 0x%x\n",
-- 
1.7.5.4

