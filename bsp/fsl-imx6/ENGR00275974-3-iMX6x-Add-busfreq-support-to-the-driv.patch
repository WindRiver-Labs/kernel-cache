From d855d61f97ea28d085f28a111e9014374faad5a0 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Tue, 20 Aug 2013 14:31:40 -0500
Subject: [PATCH 0510/1072] ENGR00275974-3 [iMX6x] Add busfreq support to the
 drivers

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 233502809b9e13d4c217803218032e55733c052b

Add request_bus_freq() and release_bus_freq() calls to the
various drivers to ensure that the DDR and AHB are the requested
frequency before the driver starts its task.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/cpufreq/cpufreq-imx6.c                     |   20 +++++++++-
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |    8 ++--
 drivers/mxc/ipu3/ipu_common.c                      |    7 +--
 drivers/mxc/vpu/mxc_vpu.c                          |   15 +------
 drivers/net/ethernet/freescale/fec_main.c          |   40 +++++++++++++++++++-
 sound/soc/fsl/fsl_ssi.c                            |   28 ++++++++++++++
 6 files changed, 95 insertions(+), 23 deletions(-)

diff --git a/drivers/cpufreq/cpufreq-imx6.c b/drivers/cpufreq/cpufreq-imx6.c
index eb6c4ba..d301984 100644
--- a/drivers/cpufreq/cpufreq-imx6.c
+++ b/drivers/cpufreq/cpufreq-imx6.c
@@ -6,6 +6,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/busfreq-imx6.h>
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/delay.h>
@@ -30,6 +31,7 @@ static struct clk *pll2_pfd2_396m_clk;
 static struct device *cpu_dev;
 static struct cpufreq_frequency_table *freq_table;
 static unsigned int transition_latency;
+
 struct soc_opp {
 	u32 arm_freq;
 	u32 soc_volt;
@@ -102,6 +104,13 @@ static int imx6_set_target(struct cpufreq_policy *policy,
 		freqs.old / 1000, volt_old / 1000,
 		freqs.new / 1000, volt / 1000);
 
+	/*
+	  * CPU freq is increasing, so need to ensure
+	  * that bus frequency is increased too.
+	  */
+	if (freqs.old == freq_table[0].frequency)
+		request_bus_freq(BUS_FREQ_HIGH);
+
 	/* scaling up?  scale voltage before frequency */
 	if (freqs.new > freqs.old) {
 		if (regulator_is_enabled(pu_reg)) {
@@ -196,8 +205,14 @@ static int imx6_set_target(struct cpufreq_policy *policy,
 				goto err1;
 			}
 		}
-
 	}
+	/*
+	  * If CPU is dropped to the lowest level, release the need
+	  * for a high bus frequency.
+	  */
+	if (freqs.new == freq_table[0].frequency)
+		release_bus_freq(BUS_FREQ_HIGH);
+
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 
 	return 0;
@@ -220,6 +235,9 @@ static int imx6_cpufreq_init(struct cpufreq_policy *policy)
 	cpumask_setall(policy->cpus);
 	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 
+	if (policy->cur > freq_table[0].frequency)
+		request_bus_freq(BUS_FREQ_HIGH);
+
 	return 0;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index 64cb08a..2e1200b 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -19,7 +19,6 @@
 *
 *****************************************************************************/
 
-
 #include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/notifier.h>
@@ -69,9 +68,10 @@ task_notify_func(struct notifier_block *self, unsigned long val, void *data)
 #include <mach/viv_gpu.h>
 #else
 #include <linux/pm_runtime.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 #include <mach/busfreq.h>
 #else
+#include <linux/busfreq-imx6.h>
 #include <linux/reset.h>
 #endif
 #endif
@@ -1322,7 +1322,7 @@ MODULE_DEVICE_TABLE(of, mxs_gpu_dt_ids);
 #ifdef CONFIG_PM
 static int gpu_runtime_suspend(struct device *dev)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 7)
 	release_bus_freq(BUS_FREQ_HIGH);
 #endif
 	return 0;
@@ -1330,7 +1330,7 @@ static int gpu_runtime_suspend(struct device *dev)
 
 static int gpu_runtime_resume(struct device *dev)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 7)
 	request_bus_freq(BUS_FREQ_HIGH);
 #endif
 	return 0;
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index e8b4fba..8303bc8 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -18,6 +18,7 @@
  *
  * @ingroup IPU
  */
+#include <linux/busfreq-imx6.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
@@ -3043,19 +3044,17 @@ static int ipu_resume(struct device *dev)
 
 int ipu_runtime_suspend(struct device *dev)
 {
-#if 0
 	release_bus_freq(BUS_FREQ_HIGH);
 	dev_dbg(dev, "ipu busfreq high release.\n");
-#endif
+
 	return 0;
 }
 
 int ipu_runtime_resume(struct device *dev)
 {
-#if 0
 	request_bus_freq(BUS_FREQ_HIGH);
 	dev_dbg(dev, "ipu busfreq high requst.\n");
-#endif
+
 	return 0;
 }
 
diff --git a/drivers/mxc/vpu/mxc_vpu.c b/drivers/mxc/vpu/mxc_vpu.c
index ecd286b..8c016f5 100644
--- a/drivers/mxc/vpu/mxc_vpu.c
+++ b/drivers/mxc/vpu/mxc_vpu.c
@@ -61,11 +61,12 @@
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#include <linux/busfreq-imx6.h>
+#include <linux/clk.h>
 #include <linux/genalloc.h>
+#include <linux/mxc_vpu.h>
 #include <linux/of.h>
 #include <linux/reset.h>
-#include <linux/clk.h>
-#include <linux/mxc_vpu.h>
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
 #include <mach/busfreq.h>
 #include <mach/common.h>
@@ -224,14 +225,6 @@ static void vpu_power_up(bool on)
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
-static void request_bus_freq(int freq)
-{
-}
-
-static void release_bus_freq(int freq)
-{
-}
-
 static int cpu_is_mx53(void)
 {
 	return 0;
@@ -243,8 +236,6 @@ static int cpu_is_mx51(void)
 }
 
 #define VM_RESERVED 0
-#define BUS_FREQ_HIGH 0
-
 #endif
 
 /*!
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index a23156f..ffba46a 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -55,11 +55,19 @@
 #include <linux/of_net.h>
 #include <linux/regulator/consumer.h>
 #include <linux/if_vlan.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
 
 #include <asm/cacheflush.h>
 
 #include "fec.h"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#include <linux/busfreq-imx6.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+#include <mach/busfreq.h>
+#endif
+
 static void set_multicast_list(struct net_device *ndev);
 static void fec_reset_phy(struct platform_device *pdev);
 
@@ -1769,6 +1777,8 @@ fec_enet_open(struct net_device *ndev)
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	int ret;
 
+	pm_runtime_get_sync(ndev->dev.parent);
+
 	napi_enable(&fep->napi);
 
 	/* I should reset the ring buffers here, but I don't yet know
@@ -1785,6 +1795,7 @@ fec_enet_open(struct net_device *ndev)
 		fec_enet_free_buffers(ndev);
 		return ret;
 	}
+
 	phy_start(fep->phy_dev);
 	netif_start_queue(ndev);
 	fep->opened = 1;
@@ -1811,6 +1822,8 @@ fec_enet_close(struct net_device *ndev)
 		phy_disconnect(fep->phy_dev);
 	}
 
+	pm_runtime_put_sync_suspend(ndev->dev.parent);
+
 	fec_enet_free_buffers(ndev);
 
 	return 0;
@@ -2170,6 +2183,8 @@ fec_probe(struct platform_device *pdev)
 		fep->bufdesc_ex = 0;
 	}
 
+	pm_runtime_enable(&pdev->dev);
+
 	clk_prepare_enable(fep->clk_ahb);
 	clk_prepare_enable(fep->clk_ipg);
 	clk_prepare_enable(fep->clk_enet_out);
@@ -2287,7 +2302,7 @@ fec_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 static int
 fec_suspend(struct device *dev)
 {
@@ -2331,9 +2346,30 @@ fec_resume(struct device *dev)
 
 	return 0;
 }
+
+static int fec_runtime_suspend(struct device *dev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+	release_bus_freq(BUS_FREQ_HIGH);
+#endif
+	return 0;
+}
+
+static int fec_runtime_resume(struct device *dev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+	request_bus_freq(BUS_FREQ_HIGH);
+#endif
+	return 0;
+}
+
+static const struct dev_pm_ops fec_pm_ops = {
+	SET_RUNTIME_PM_OPS(fec_runtime_suspend, fec_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(fec_suspend, fec_resume)
+};
+
 #endif /* CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(fec_pm_ops, fec_suspend, fec_resume);
 
 static struct platform_driver fec_driver = {
 	.driver	= {
diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c
index 70df5a0..49ab2bd 100644
--- a/sound/soc/fsl/fsl_ssi.c
+++ b/sound/soc/fsl/fsl_ssi.c
@@ -10,6 +10,7 @@
  * kind, whether express or implied.
  */
 
+#include <linux/busfreq-imx6.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -21,6 +22,7 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -330,6 +332,8 @@ static int fsl_ssi_startup(struct snd_pcm_substream *substream,
 		snd_soc_dai_get_drvdata(rtd->cpu_dai);
 	int synchronous = ssi_private->cpu_dai_drv.symmetric_rates;
 
+	pm_runtime_get_sync(dai->dev);
+
 	clk_enable(ssi_private->clk);
 
 	/*
@@ -577,6 +581,8 @@ static void fsl_ssi_shutdown(struct snd_pcm_substream *substream,
 
 	clk_disable(ssi_private->clk);
 
+	pm_runtime_put_sync(dai->dev);
+
 	/* If this is the last active substream, disable the interrupts. */
 	if (!ssi_private->first_stream) {
 		struct ccsr_ssi __iomem *ssi = ssi_private->ssi;
@@ -813,6 +819,8 @@ static int fsl_ssi_probe(struct platform_device *pdev)
 		goto error_irq;
 	}
 
+	pm_runtime_enable(&pdev->dev);
+
 	/* Register with ASoC */
 	dev_set_drvdata(&pdev->dev, ssi_private);
 
@@ -918,6 +926,26 @@ static int fsl_ssi_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+static int fsl_ssi_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_AUDIO);
+	return 0;
+}
+
+static int fsl_ssi_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_AUDIO);
+	return 0;
+}
+
+static const struct dev_pm_ops fsl_ssi_pm = {
+	SET_RUNTIME_PM_OPS(fsl_ssi_runtime_suspend,
+			fsl_ssi_runtime_resume,
+			NULL)
+};
+#endif
+
 static const struct of_device_id fsl_ssi_ids[] = {
 	{ .compatible = "fsl,mpc8610-ssi", },
 	{ .compatible = "fsl,imx21-ssi", },
-- 
1.7.5.4

