From 3b4d8280096eb0302971c45694ad8ed457bfab09 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Tue, 20 Aug 2013 14:14:41 -0400
Subject: [PATCH 0143/1072] ENGR00275821-2 ARM: imx: Enable suspend/resume for
 i.MX6SL

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 3140b8863e7e0dc7ae0d3b69f016d3a807960569

Enable suspend/resume function for i.MX6SL, currently
support standby and mem mode.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/boot/dts/imx6sl.dtsi   |    6 ++++++
 arch/arm/mach-imx/clk-imx6sl.c  |    1 +
 arch/arm/mach-imx/mach-imx6sl.c |   28 +++++++++++++++++++++++++++-
 arch/arm/mach-imx/pm-imx6.c     |   19 ++++++++++++++++---
 4 files changed, 50 insertions(+), 4 deletions(-)

diff --git a/arch/arm/boot/dts/imx6sl.dtsi b/arch/arm/boot/dts/imx6sl.dtsi
index cb778be..556a9f1 100644
--- a/arch/arm/boot/dts/imx6sl.dtsi
+++ b/arch/arm/boot/dts/imx6sl.dtsi
@@ -546,6 +546,12 @@
 				#reset-cells = <1>;
 			};
 
+			ocram: sram@00900000 {
+				compatible = "mmio-sram";
+				reg = <0x00900000 0x20000>;
+				clocks = <&clks IMX6SL_CLK_OCRAM>;
+			};
+
 			gpc: gpc@020dc000 {
 				compatible = "fsl,imx6sl-gpc", "fsl,imx6q-gpc";
 				reg = <0x020dc000 0x4000>;
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 11856b6..4c367f4 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -127,6 +127,7 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	np = ccm_node;
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
+	imx6_pm_set_ccm_base(base);
 
 	/*                                              name                reg       shift width parent_names     num_parents */
 	clks[IMX6SL_CLK_STEP]             = imx_clk_mux("step",             base + 0xc,  8,  1, step_sels,         ARRAY_SIZE(step_sels));
diff --git a/arch/arm/mach-imx/mach-imx6sl.c b/arch/arm/mach-imx/mach-imx6sl.c
index 6042a69..1613c03 100644
--- a/arch/arm/mach-imx/mach-imx6sl.c
+++ b/arch/arm/mach-imx/mach-imx6sl.c
@@ -49,6 +49,31 @@ static void __init imx6sl_init_machine(void)
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, parent);
 
 	imx6sl_fec_init();
+	imx_anatop_init();
+	imx6_pm_init();
+}
+
+static void __init imx6sl_init_late(void)
+{
+	struct regmap *gpr;
+
+	/*
+	 * Need to force IOMUXC irq pending to meet CCM low power mode
+	 * restriction, this is recommended by hardware team.
+	 */
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6sl-iomuxc-gpr");
+	if (!IS_ERR(gpr))
+		regmap_update_bits(gpr, IOMUXC_GPR1,
+			IMX6Q_GPR1_GINT_MASK,
+			IMX6Q_GPR1_GINT_ASSERT);
+	else
+		pr_err("failed to find fsl,imx6sl-iomux-gpr regmap\n");
+}
+
+static void __init imx6sl_map_io(void)
+{
+	debug_ll_io_init();
+	imx6_pm_map_io();
 }
 
 static void __init imx6sl_init_irq(void)
@@ -71,10 +96,11 @@ static const char *imx6sl_dt_compat[] __initdata = {
 };
 
 DT_MACHINE_START(IMX6SL, "Freescale i.MX6 SoloLite (Device Tree)")
-	.map_io		= debug_ll_io_init,
+	.map_io		= imx6sl_map_io,
 	.init_irq	= imx6sl_init_irq,
 	.init_time	= imx6sl_timer_init,
 	.init_machine	= imx6sl_init_machine,
+	.init_late      = imx6sl_init_late,
 	.dt_compat	= imx6sl_dt_compat,
 	.restart	= mxc_restart,
 MACHINE_END
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index e1c5eb5..1f75d05 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -181,7 +181,12 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 		val |= 0x2 << BP_CLPCR_LPM;
 		val &= ~BM_CLPCR_VSTBY;
 		val &= ~BM_CLPCR_SBYOS;
-		val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
+		if (cpu_is_imx6sl()) {
+			val |= BM_CLPCR_BYPASS_PMIC_READY;
+			val |= BM_CLPCR_BYP_MMDC_CH0_LPM_HS;
+		} else {
+			val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
+		}
 		break;
 	case WAIT_UNCLOCKED_POWER_OFF:
 		val |= 0x1 << BP_CLPCR_LPM;
@@ -193,7 +198,12 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 		val |= 0x3 << BP_CLPCR_STBY_COUNT;
 		val |= BM_CLPCR_VSTBY;
 		val |= BM_CLPCR_SBYOS;
-		val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
+		if (cpu_is_imx6sl()) {
+			val |= BM_CLPCR_BYPASS_PMIC_READY;
+			val |= BM_CLPCR_BYP_MMDC_CH0_LPM_HS;
+		} else {
+			val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
+		}
 		imx6_enable_wb(true);
 		break;
 	default:
@@ -237,7 +247,8 @@ static int imx6_pm_enter(suspend_state_t state)
 		imx_set_cpu_jump(0, v7_cpu_resume);
 		/* Zzz ... */
 		cpu_suspend(0, imx6_suspend_finish);
-		imx_smp_prepare();
+		if (!cpu_is_imx6sl())
+			imx_smp_prepare();
 		imx_anatop_post_resume();
 		imx_gpc_post_resume();
 		imx6_set_cache_lpm_in_wait(true);
@@ -330,4 +341,6 @@ void __init imx6_pm_init(void)
 		cpu_type = MXC_CPU_IMX6Q;
 	else if (cpu_is_imx6dl())
 		cpu_type = MXC_CPU_IMX6DL;
+	else
+		cpu_type = MXC_CPU_IMX6SL;
 }
-- 
1.7.5.4

