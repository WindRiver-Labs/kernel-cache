From 88690829e77fc9e73d99f64472f29d4e5e24c17b Mon Sep 17 00:00:00 2001
From: Robby Cai <R63905@freescale.com>
Date: Tue, 8 Oct 2013 15:25:38 +0800
Subject: [PATCH 0568/1072] ENGR00283216 media: imx6sl: add runtime pm support
 for busfreq

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit fa429b1eb7454ccf13bae37eed216ebeb5975bc2

add runtime pm implementation for eLCDIF/EPDC/PxP

Signed-off-by: Robby Cai <R63905@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v2.c    |   47 +++++++++++++++++++++++++++-----
 drivers/video/mxc/mxc_epdc_fb.c |   57 ++++++++++++++++++++++++++++++--------
 drivers/video/mxsfb.c           |   34 +++++++++++++++++++++++
 3 files changed, 119 insertions(+), 19 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index 9641adc..e4733b3 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -21,6 +21,7 @@
  * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
  */
 
+#include <linux/busfreq-imx6.h>
 #include <linux/dma-mapping.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -29,6 +30,7 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/dmaengine.h>
@@ -804,6 +806,8 @@ static void pxp_clk_enable(struct pxps *pxp)
 		return;
 	}
 
+	pm_runtime_get_sync(pxp->dev);
+
 	clk_prepare_enable(pxp->clk);
 	pxp->clk_stat = CLK_STAT_ON;
 
@@ -829,6 +833,8 @@ static void pxp_clk_disable(struct pxps *pxp)
 	} else
 		spin_unlock_irqrestore(&pxp->lock, flags);
 
+	pm_runtime_put_sync_suspend(pxp->dev);
+
 	mutex_unlock(&pxp->clk_mutex);
 }
 
@@ -1611,6 +1617,8 @@ static int pxp_probe(struct platform_device *pdev)
 
 	register_pxp_device();
 
+	pm_runtime_enable(pxp->dev);
+
 exit:
 	if (err)
 		dev_err(&pdev->dev, "Exiting (unsuccessfully) pxp_probe()\n");
@@ -1630,10 +1638,10 @@ static int pxp_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
+#ifdef CONFIG_PM_SLEEP
+static int pxp_suspend(struct device *dev)
 {
-	struct pxps *pxp = platform_get_drvdata(pdev);
+	struct pxps *pxp = dev_get_drvdata(dev);
 
 	pxp_clk_enable(pxp);
 	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
@@ -1645,9 +1653,9 @@ static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-static int pxp_resume(struct platform_device *pdev)
+static int pxp_resume(struct device *dev)
 {
-	struct pxps *pxp = platform_get_drvdata(pdev);
+	struct pxps *pxp = dev_get_drvdata(dev);
 
 	pxp_clk_enable(pxp);
 	/* Pull PxP out of reset */
@@ -1661,15 +1669,40 @@ static int pxp_resume(struct platform_device *pdev)
 #define	pxp_resume	NULL
 #endif
 
+#ifdef CONFIG_PM_RUNTIME
+static int pxp_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "pxp busfreq high release.\n");
+
+	return 0;
+}
+
+static int pxp_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "pxp busfreq high request.\n");
+
+	return 0;
+}
+#else
+#define	pxp_runtime_suspend	NULL
+#define	pxp_runtime_resume	NULL
+#endif
+
+static const struct dev_pm_ops pxp_pm_ops = {
+	SET_RUNTIME_PM_OPS(pxp_runtime_suspend, pxp_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pxp_suspend, pxp_resume)
+};
+
 static struct platform_driver pxp_driver = {
 	.driver = {
 			.name = "imx-pxp",
 			.of_match_table = of_match_ptr(imx_pxpdma_dt_ids),
+			.pm = &pxp_pm_ops,
 		   },
 	.probe = pxp_probe,
 	.remove = pxp_remove,
-	.suspend = pxp_suspend,
-	.resume = pxp_resume,
 };
 
 module_platform_driver(pxp_driver);
diff --git a/drivers/video/mxc/mxc_epdc_fb.c b/drivers/video/mxc/mxc_epdc_fb.c
index 7bc0e4f..a57c959 100644
--- a/drivers/video/mxc/mxc_epdc_fb.c
+++ b/drivers/video/mxc/mxc_epdc_fb.c
@@ -21,6 +21,7 @@
  * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
  */
 
+#include <linux/busfreq-imx6.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/device.h>
@@ -42,6 +43,7 @@
 #include <linux/kthread.h>
 #include <linux/dmaengine.h>
 #include <linux/pxp_dma.h>
+#include <linux/pm_runtime.h>
 #include <linux/mxcfb.h>
 #include <linux/mxcfb_epdc.h>
 #include <linux/gpio.h>
@@ -1209,6 +1211,8 @@ static void epdc_powerup(struct mxc_epdc_fb_data *fb_data)
 
 	msleep(1);
 
+	pm_runtime_get_sync(fb_data->dev);
+
 	/* Enable clocks to EPDC */
 	clk_prepare_enable(fb_data->epdc_clk_axi);
 	clk_prepare_enable(fb_data->epdc_clk_pix);
@@ -1260,6 +1264,8 @@ static void epdc_powerdown(struct mxc_epdc_fb_data *fb_data)
 	clk_disable_unprepare(fb_data->epdc_clk_pix);
 	clk_disable_unprepare(fb_data->epdc_clk_axi);
 
+	pm_runtime_put_sync_suspend(fb_data->dev);
+
 	/* turn off the V3p3 */
 	regulator_disable(fb_data->v3p3_regulator);
 
@@ -5014,6 +5020,8 @@ int mxc_epdc_fb_probe(struct platform_device *pdev)
 	}
 #endif
 
+	pm_runtime_enable(fb_data->dev);
+
 	goto out;
 
 out_lutmap:
@@ -5107,10 +5115,10 @@ static int mxc_epdc_fb_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int mxc_epdc_fb_suspend(struct platform_device *pdev, pm_message_t state)
+#ifdef CONFIG_PM_SLEEP
+static int mxc_epdc_fb_suspend(struct device *dev)
 {
-	struct mxc_epdc_fb_data *data = platform_get_drvdata(pdev);
+	struct mxc_epdc_fb_data *data = dev_get_drvdata(dev);
 	int ret;
 
 	data->pwrdown_delay = FB_POWERDOWN_DISABLE;
@@ -5122,9 +5130,9 @@ out:
 	return ret;
 }
 
-static int mxc_epdc_fb_resume(struct platform_device *pdev)
+static int mxc_epdc_fb_resume(struct device *dev)
 {
-	struct mxc_epdc_fb_data *data = platform_get_drvdata(pdev);
+	struct mxc_epdc_fb_data *data = dev_get_drvdata(dev);
 
 	mxc_epdc_fb_blank(FB_BLANK_UNBLANK, &data->info);
 	epdc_init_settings(data);
@@ -5132,6 +5140,37 @@ static int mxc_epdc_fb_resume(struct platform_device *pdev)
 
 	return 0;
 }
+#else
+#define mxc_epdc_fb_suspend	NULL
+#define mxc_epdc_fb_resume	NULL
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int mxc_epdc_fb_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "epdc busfreq high release.\n");
+
+	return 0;
+}
+
+static int mxc_epdc_fb_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "epdc busfreq high request.\n");
+
+	return 0;
+}
+#else
+#define mxc_epdc_fb_runtime_suspend	NULL
+#define mxc_epdc_fb_runtime_resume	NULL
+#endif
+
+static const struct dev_pm_ops mxc_epdc_fb_pm_ops = {
+	SET_RUNTIME_PM_OPS(mxc_epdc_fb_runtime_suspend,
+				mxc_epdc_fb_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(mxc_epdc_fb_suspend, mxc_epdc_fb_resume)
+};
 
 static void mxc_epdc_fb_shutdown(struct platform_device *pdev)
 {
@@ -5154,22 +5193,16 @@ static void mxc_epdc_fb_shutdown(struct platform_device *pdev)
 	if (regulator_is_enabled(fb_data->v3p3_regulator))
 		regulator_disable(fb_data->v3p3_regulator);
 }
-#else
-#define mxc_epdc_fb_suspend	NULL
-#define mxc_epdc_fb_resume	NULL
-#define mxc_epdc_fb_shutdown	NULL
-#endif
 
 static struct platform_driver mxc_epdc_fb_driver = {
 	.probe = mxc_epdc_fb_probe,
 	.remove = mxc_epdc_fb_remove,
-	.suspend = mxc_epdc_fb_suspend,
-	.resume = mxc_epdc_fb_resume,
 	.shutdown = mxc_epdc_fb_shutdown,
 	.driver = {
 		   .name = "imx_epdc_fb",
 		   .owner = THIS_MODULE,
 		   .of_match_table = of_match_ptr(imx_epdc_dt_ids),
+		   .pm = &mxc_epdc_fb_pm_ops,
 		   },
 };
 
diff --git a/drivers/video/mxsfb.c b/drivers/video/mxsfb.c
index f10a7d0..c4d0b6c 100644
--- a/drivers/video/mxsfb.c
+++ b/drivers/video/mxsfb.c
@@ -39,10 +39,12 @@
  * the required value in the imx_fb_videomode structure.
  */
 
+#include <linux/busfreq-imx6.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
@@ -423,6 +425,8 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 		}
 	}
 
+	pm_runtime_get_sync(&host->pdev->dev);
+
 	clk_enable_axi(host);
 
 	clk_prepare_enable(host->clk_pix);
@@ -473,6 +477,8 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 
 	clk_disable_unprepare(host->clk_pix);
 
+	pm_runtime_put_sync_suspend(&host->pdev->dev);
+
 	host->enabled = 0;
 
 	if (host->reg_lcd) {
@@ -1216,6 +1222,8 @@ static int mxsfb_probe(struct platform_device *pdev)
 		goto fb_destroy;
 	}
 
+	pm_runtime_enable(&host->pdev->dev);
+
 	dev_info(&pdev->dev, "initialized\n");
 
 	return 0;
@@ -1262,6 +1270,31 @@ static void mxsfb_shutdown(struct platform_device *pdev)
 	clk_disable_axi(host);
 }
 
+#ifdef CONFIG_PM_RUNTIME
+static int mxsfb_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "mxsfb busfreq high release.\n");
+
+	return 0;
+}
+
+static int mxsfb_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	dev_dbg(dev, "mxsfb busfreq high request.\n");
+
+	return 0;
+}
+#else
+#define	mxsfb_runtime_suspend	NULL
+#define	mxsfb_runtime_resume	NULL
+#endif
+
+static const struct dev_pm_ops mxsfb_pm_ops = {
+	SET_RUNTIME_PM_OPS(mxsfb_runtime_suspend, mxsfb_runtime_resume, NULL)
+};
+
 static struct platform_driver mxsfb_driver = {
 	.probe = mxsfb_probe,
 	.remove = mxsfb_remove,
@@ -1270,6 +1303,7 @@ static struct platform_driver mxsfb_driver = {
 	.driver = {
 		   .name = DRIVER_NAME,
 		   .of_match_table = mxsfb_dt_ids,
+		   .pm = &mxsfb_pm_ops,
 	},
 };
 
-- 
1.7.5.4

