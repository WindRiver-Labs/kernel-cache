From 899262e4b7961290dbd681b319221587c4e0bd00 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Mon, 19 Aug 2013 15:14:43 -0400
Subject: [PATCH 0137/1072] ENGR00275542-1 ARM: imx: Enable PU power
 management for i.MX6SL

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit bf48689a115e5ebc801c721045f536a09682b8db

Enable dynamical PU power management for i.MX6SL.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/boot/dts/imx6sl.dtsi  |    5 ++-
 arch/arm/mach-imx/clk-imx6sl.c |    4 ++
 arch/arm/mach-imx/gpc.c        |   72 ++++++++++++++++++++++++++--------------
 3 files changed, 55 insertions(+), 26 deletions(-)

diff --git a/arch/arm/boot/dts/imx6sl.dtsi b/arch/arm/boot/dts/imx6sl.dtsi
index 36a1fa2..93f96791 100644
--- a/arch/arm/boot/dts/imx6sl.dtsi
+++ b/arch/arm/boot/dts/imx6sl.dtsi
@@ -465,7 +465,6 @@
 					regulator-name = "vddpu";
 					regulator-min-microvolt = <725000>;
 					regulator-max-microvolt = <1450000>;
-					regulator-always-on;
 					anatop-reg-offset = <0x140>;
 					anatop-vol-bit-shift = <9>;
 					anatop-vol-bit-width = <5>;
@@ -543,6 +542,10 @@
 				compatible = "fsl,imx6sl-gpc", "fsl,imx6q-gpc";
 				reg = <0x020dc000 0x4000>;
 				interrupts = <0 89 0x04>;
+				clocks = <&clks IMX6SL_CLK_GPU2D_PODF>, <&clks IMX6SL_CLK_GPU2D_OVG>,
+					<&clks IMX6SL_CLK_IPG>;
+				clock-names = "gpu2d_podf", "gpu2d_ovg", "ipg";
+				pu-supply = <&reg_pu>;
 			};
 
 			gpr: iomuxc-gpr@020e0000 {
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 7a8d13a..11856b6 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -268,6 +268,10 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 		clk_prepare_enable(clks[IMX6SL_CLK_USBPHY2_GATE]);
 	}
 
+	clk_set_parent(clks[IMX6SL_CLK_GPU2D_OVG_SEL],
+		clks[IMX6SL_CLK_PLL2_BUS]);
+	clk_set_parent(clks[IMX6SL_CLK_GPU2D_SEL], clks[IMX6SL_CLK_PLL2_BUS]);
+
 	/* set perclk to source from OSC 24MHz */
 	clk_set_parent(clks[IMX6SL_CLK_PERCLK_SEL], clks[IMX6SL_CLK_OSC]);
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6sl-gpt");
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 91e436f..dc6c099 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -22,6 +22,7 @@
 #include <linux/irqchip/arm-gic.h>
 #include <linux/regulator/consumer.h>
 #include "common.h"
+#include "hardware.h"
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0
@@ -150,19 +151,29 @@ void imx_gpc_irq_mask(struct irq_data *d)
 static void imx_pu_clk(bool enable)
 {
 	if (enable) {
-		clk_prepare_enable(gpu3d_clk);
-		clk_prepare_enable(gpu3d_shader_clk);
-		clk_prepare_enable(vpu_clk);
-		clk_prepare_enable(gpu2d_clk);
-		clk_prepare_enable(gpu2d_axi_clk);
-		clk_prepare_enable(openvg_axi_clk);
+		if (cpu_is_imx6sl()) {
+			clk_prepare_enable(gpu2d_clk);
+			clk_prepare_enable(openvg_axi_clk);
+		} else {
+			clk_prepare_enable(gpu3d_clk);
+			clk_prepare_enable(gpu3d_shader_clk);
+			clk_prepare_enable(vpu_clk);
+			clk_prepare_enable(gpu2d_clk);
+			clk_prepare_enable(gpu2d_axi_clk);
+			clk_prepare_enable(openvg_axi_clk);
+		}
 	} else {
-		clk_disable_unprepare(gpu3d_clk);
-		clk_disable_unprepare(gpu3d_shader_clk);
-		clk_disable_unprepare(vpu_clk);
-		clk_disable_unprepare(gpu2d_clk);
-		clk_disable_unprepare(gpu2d_axi_clk);
-		clk_disable_unprepare(openvg_axi_clk);
+		if (cpu_is_imx6sl()) {
+			clk_disable_unprepare(gpu2d_clk);
+			clk_disable_unprepare(openvg_axi_clk);
+		} else {
+			clk_disable_unprepare(gpu3d_clk);
+			clk_disable_unprepare(gpu3d_shader_clk);
+			clk_disable_unprepare(vpu_clk);
+			clk_disable_unprepare(gpu2d_clk);
+			clk_disable_unprepare(gpu2d_axi_clk);
+			clk_disable_unprepare(openvg_axi_clk);
+		}
 	}
 }
 
@@ -307,19 +318,30 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	nb.notifier_call = &imx_gpc_regulator_notify;
 
 	/* Get gpu&vpu clk for power up PU by GPC */
-	gpu3d_clk = devm_clk_get(gpc_dev, "gpu3d_core");
-	gpu3d_shader_clk = devm_clk_get(gpc_dev, "gpu3d_shader");
-	gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_core");
-	gpu2d_axi_clk = devm_clk_get(gpc_dev, "gpu2d_axi");
-	openvg_axi_clk = devm_clk_get(gpc_dev, "openvg_axi");
-	vpu_clk = devm_clk_get(gpc_dev, "vpu_axi");
-	ipg_clk = devm_clk_get(gpc_dev, "ipg");
-	if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
-		|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
-		|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk)
-		|| IS_ERR(ipg_clk)) {
-		dev_err(gpc_dev, "failed to get clk!\n");
-		return -ENOENT;
+	if (cpu_is_imx6sl()) {
+		gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_podf");
+		openvg_axi_clk = devm_clk_get(gpc_dev, "gpu2d_ovg");
+		ipg_clk = devm_clk_get(gpc_dev, "ipg");
+		if (IS_ERR(gpu2d_clk) || IS_ERR(openvg_axi_clk)
+			|| IS_ERR(ipg_clk)) {
+			dev_err(gpc_dev, "failed to get clk!\n");
+			return -ENOENT;
+		}
+	} else {
+		gpu3d_clk = devm_clk_get(gpc_dev, "gpu3d_core");
+		gpu3d_shader_clk = devm_clk_get(gpc_dev, "gpu3d_shader");
+		gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_core");
+		gpu2d_axi_clk = devm_clk_get(gpc_dev, "gpu2d_axi");
+		openvg_axi_clk = devm_clk_get(gpc_dev, "openvg_axi");
+		vpu_clk = devm_clk_get(gpc_dev, "vpu_axi");
+		ipg_clk = devm_clk_get(gpc_dev, "ipg");
+		if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
+			|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
+			|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk)
+			|| IS_ERR(ipg_clk)) {
+			dev_err(gpc_dev, "failed to get clk!\n");
+			return -ENOENT;
+		}
 	}
 
 	ret = regulator_register_notifier(pu_reg, &nb);
-- 
1.7.5.4

