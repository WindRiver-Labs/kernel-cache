From 3335779860d879fa270f2c75185e94324711d44a Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Sat, 9 Nov 2013 08:08:10 +0800
Subject: [PATCH 0735/1072] ENGR00286962-2 usb: chipidea: fix the system will
 be deadlock with ID wakeup

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit 7d6fa1243c29562461752c2115a25cb54dc49217

When we plug in Micro B-TO-A cable at OTG port with u-disk connected,
and enable USB ID wakeup, then, suspend the system, the system
will be deadlock during the resume. See below Sysrq dump.

If the flush_work at block layer is called after system resume
has completed, this problem has fixed (using pm_mutex at ci_otg_work).
It seems if the task is rescheduled before the system resume has
completed (after thaw_processes), it will cause the system dead lock.
Unless the task has been freezed explicitly before system suspend.

The fixes uses wait_event_freezable to wait event, it should call
try_to_freeze during the freeze_processes, and task will not be
scheduled until thaw_processes has called (for frozen process, it will
call wake_up_process explicitly).

--------------------------------------Sysrq dump------------------------------------------
sh              D 80600860     0  1016   1014 0x00000000

[<80600860>] (__schedule+0x1e0/0x5d8) from [<80601274>] (schedule_preempt_disabled+0xc/0x10)

[<80601274>] (schedule_preempt_disabled+0xc/0x10) from [<805ffe00>] (__mutex_lock_slowpath+0x154/0x1f4)

[<805ffe00>] (__mutex_lock_slowpath+0x154/0x1f4) from [<805ffef0>] (mutex_lock+0x50/0x54)

[<805ffef0>] (mutex_lock+0x50/0x54) from [<802f7f84>] (dpm_complete+0xac/0x1ac)

[<802f7f84>] (dpm_complete+0xac/0x1ac) from [<80057a34>] (suspend_devices_and_enter+0x1bc/0x330)

[<80057a34>] (suspend_devices_and_enter+0x1bc/0x330) from [<80057d50>] (pm_suspend+0x1a8/0x240)

[<80057d50>] (pm_suspend+0x1a8/0x240) from [<80056a8c>] (state_store+0x6c/0xbc)

[<80056a8c>] (state_store+0x6c/0xbc) from [<802586c0>] (kobj_attr_store+0x14/0x20)

[<802586c0>] (kobj_attr_store+0x14/0x20) from [<80117374>] (sysfs_write_file+0xfc/0x17c)

[<80117374>] (sysfs_write_file+0xfc/0x17c) from [<800bdcc0>] (vfs_write+0xbc/0x184)

[<800bdcc0>] (vfs_write+0xbc/0x184) from [<800be058>] (SyS_write+0x40/0x68)

[<800be058>] (SyS_write+0x40/0x68) from [<8000e040>] (ret_fast_syscall+0x0/0x30)

kworker/u8:2    D 80600860     0 16146      2 0x00000000

Workqueue: ci_otg ci_otg_work

[<80600860>] (__schedule+0x1e0/0x5d8) from [<805ff374>] (schedule_timeout+0x14c/0x198)

[<805ff374>] (schedule_timeout+0x14c/0x198) from [<80600db8>] (wait_for_common+0xc4/0x17c)

[<80600db8>] (wait_for_common+0xc4/0x17c) from [<8003bbd0>] (flush_work+0xc0/0x160)

[<8003bbd0>] (flush_work+0xc0/0x160) from [<8009d02c>] (bdi_unregister+0x108/0x148)

[<8009d02c>] (bdi_unregister+0x108/0x148) from [<8024b5b4>] (del_gendisk+0xf8/0x1c4)

[<8024b5b4>] (del_gendisk+0xf8/0x1c4) from [<8031e8e8>] (sd_remove+0x64/0x98)

[<8031e8e8>] (sd_remove+0x64/0x98) from [<802f0678>] (__device_release_driver+0x70/0xcc)

[<802f0678>] (__device_release_driver+0x70/0xcc) from [<802f06f0>] (device_release_driver+0x1c/0x28)

[<802f06f0>] (device_release_driver+0x1c/0x28) from [<802f01e4>] (bus_remove_device+0xd8/0xf8)

[<802f01e4>] (bus_remove_device+0xd8/0xf8) from [<802edef8>] (device_del+0xf4/0x178)

[<802edef8>] (device_del+0xf4/0x178) from [<8031abbc>] (__scsi_remove_device+0x48/0xa0)

[<8031abbc>] (__scsi_remove_device+0x48/0xa0) from [<80319bb8>] (scsi_forget_host+0x5c/0x60)

[<80319bb8>] (scsi_forget_host+0x5c/0x60) from [<8031072c>] (scsi_remove_host+0x64/0xf0)

[<8031072c>] (scsi_remove_host+0x64/0xf0) from [<803be150>] (usb_stor_disconnect+0x50/0xc8)

[<803be150>] (usb_stor_disconnect+0x50/0xc8) from [<803ac020>] (usb_unbind_interface+0x58/0x188)

[<803ac020>] (usb_unbind_interface+0x58/0x188) from [<802f0678>] (__device_release_driver+0x70/0xcc)

[<802f0678>] (__device_release_driver+0x70/0xcc) from [<802f06f0>] (device_release_driver+0x1c/0x28)

[<802f06f0>] (device_release_driver+0x1c/0x28) from [<802f01e4>] (bus_remove_device+0xd8/0xf8)

[<802f01e4>] (bus_remove_device+0xd8/0xf8) from [<802edef8>] (device_del+0xf4/0x178)

[<802edef8>] (device_del+0xf4/0x178) from [<803a9e8c>] (usb_disable_device+0xa0/0x1c8)

[<803a9e8c>] (usb_disable_device+0xa0/0x1c8) from [<803a25fc>] (usb_disconnect+0x88/0x1a0)

[<803a25fc>] (usb_disconnect+0x88/0x1a0) from [<803a25e4>] (usb_disconnect+0x70/0x1a0)

[<803a25e4>] (usb_disconnect+0x70/0x1a0) from [<803a5940>] (usb_remove_hcd+0xac/0x15c)

[<803a5940>] (usb_remove_hcd+0xac/0x15c) from [<803c487c>] (host_stop+0x1c/0x3c)

[<803c487c>] (host_stop+0x1c/0x3c) from [<803c1880>] (ci_otg_work+0xc8/0x118)

[<803c1880>] (ci_otg_work+0xc8/0x118) from [<8003c62c>] (process_one_work+0x110/0x360)

[<8003c62c>] (process_one_work+0x110/0x360) from [<8003d180>] (worker_thread+0x144/0x3ac)

[<8003d180>] (worker_thread+0x144/0x3ac) from [<8004272c>] (kthread+0xa4/0xb0)

[<8004272c>] (kthread+0xa4/0xb0) from [<8000e0d8>] (ret_from_fork+0x14/0x3c)

Signed-off-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/usb/chipidea/ci.h   |    8 +++---
 drivers/usb/chipidea/core.c |    4 +-
 drivers/usb/chipidea/otg.c  |   49 ++++++++++++++++++++++++++++++------------
 3 files changed, 41 insertions(+), 20 deletions(-)

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index cdd3c5c..cbd6d10 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -110,8 +110,8 @@ struct hw_bank {
  * @roles: array of supported roles for this controller
  * @role: current role
  * @is_otg: if the device is otg-capable
- * @work: work for role changing
- * @wq: workqueue thread
+ * @otg_task: the thread for handling otg task
+ * @otg_wait: the otg event waitqueue head
  * @qh_pool: allocation pool for queue heads
  * @td_pool: allocation pool for transfer descriptors
  * @gadget: device side representation for peripheral controller
@@ -147,8 +147,8 @@ struct ci_hdrc {
 	struct ci_role_driver		*roles[CI_ROLE_END];
 	enum ci_role			role;
 	bool				is_otg;
-	struct work_struct		work;
-	struct workqueue_struct		*wq;
+	struct task_struct		*otg_task;
+	wait_queue_head_t		otg_wait;
 
 	struct dma_pool			*qh_pool;
 	struct dma_pool			*td_pool;
diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index 9768bee..ac79aa4 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -380,7 +380,7 @@ static irqreturn_t ci_irq(int irq, void *data)
 		ci->id_event = true;
 		ci_clear_otg_interrupt(ci, OTGSC_IDIS);
 		disable_irq_nosync(ci->irq);
-		queue_work(ci->wq, &ci->work);
+		wake_up(&ci->otg_wait);
 		return IRQ_HANDLED;
 	}
 
@@ -392,7 +392,7 @@ static irqreturn_t ci_irq(int irq, void *data)
 		ci->b_sess_valid_event = true;
 		ci_clear_otg_interrupt(ci, OTGSC_BSVIS);
 		disable_irq_nosync(ci->irq);
-		queue_work(ci->wq, &ci->work);
+		wake_up(&ci->otg_wait);
 		return IRQ_HANDLED;
 	}
 
diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c
index 54bc7c0..49b4e25 100644
--- a/drivers/usb/chipidea/otg.c
+++ b/drivers/usb/chipidea/otg.c
@@ -18,6 +18,8 @@
 #include <linux/usb/otg.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/chipidea.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
 
 #include "ci.h"
 #include "bits.h"
@@ -68,14 +70,19 @@ static void ci_handle_id_switch(struct ci_hdrc *ci)
 		ci_role_start(ci, role);
 	}
 }
+
+/* If there is pending otg event */
+static inline bool ci_otg_event_is_pending(struct ci_hdrc *ci)
+{
+	return ci->id_event || ci->b_sess_valid_event;
+}
+
 /**
- * ci_otg_work - perform otg (vbus/id) event handle
- * @work: work struct
+ * ci_otg_event - perform otg (vbus/id) event handle
+ * @ci: ci_hdrc struct
  */
-static void ci_otg_work(struct work_struct *work)
+static void ci_otg_event(struct ci_hdrc *ci)
 {
-	struct ci_hdrc *ci = container_of(work, struct ci_hdrc, work);
-
 	if (ci->id_event) {
 		ci->id_event = false;
 		/* Keep controller active during id switch */
@@ -93,6 +100,23 @@ static void ci_otg_work(struct work_struct *work)
 	enable_irq(ci->irq);
 }
 
+static int ci_otg_thread(void *ptr)
+{
+	struct ci_hdrc *ci = ptr;
+
+	set_freezable();
+
+	do {
+		wait_event_freezable(ci->otg_wait,
+				ci_otg_event_is_pending(ci) ||
+				kthread_should_stop());
+		ci_otg_event(ci);
+	} while (!kthread_should_stop());
+
+	dev_warn(ci->dev, "ci_otg_thread quits\n");
+
+	return 0;
+}
 
 /**
  * ci_hdrc_otg_init - initialize otg struct
@@ -100,11 +124,11 @@ static void ci_otg_work(struct work_struct *work)
  */
 int ci_hdrc_otg_init(struct ci_hdrc *ci)
 {
-	INIT_WORK(&ci->work, ci_otg_work);
-	ci->wq = create_singlethread_workqueue("ci_otg");
-	if (!ci->wq) {
-		dev_err(ci->dev, "can't create workqueue\n");
-		return -ENODEV;
+	init_waitqueue_head(&ci->otg_wait);
+	ci->otg_task = kthread_run(ci_otg_thread, ci, "ci otg thread");
+	if (IS_ERR(ci->otg_task)) {
+		dev_err(ci->dev, "error to create otg thread\n");
+		return PTR_ERR(ci->otg_task);
 	}
 
 	return 0;
@@ -116,10 +140,7 @@ int ci_hdrc_otg_init(struct ci_hdrc *ci)
  */
 void ci_hdrc_otg_destroy(struct ci_hdrc *ci)
 {
-	if (ci->wq) {
-		flush_workqueue(ci->wq);
-		destroy_workqueue(ci->wq);
-	}
+	kthread_stop(ci->otg_task);
 	ci_disable_otg_interrupt(ci, OTGSC_INT_EN_BITS);
 	ci_clear_otg_interrupt(ci, OTGSC_INT_STATUS_BITS);
 }
-- 
1.7.5.4

