From b375759137b8df92ffb3d80effb62d2d1210370d Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Wed, 16 Oct 2013 14:06:50 -0500
Subject: [PATCH 0312/1072] ENGR00284019: [iMX6SL] Add low power mode
 optimizations

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit e954f1c7a55813d9ca7015429daa1a163679fef2

Add optimizations so that the low power IDLE mode numbers match
between the 3.10.9 and 3.0.35 kernel.
Optimizations include:
1. Disable unused PLLs and PFDs in clock init
2. Some of the drivers call clk_prepare in probe and enable much
later. clk_pllv3_prepare locks the PLL disallowing some of the low
power optimizations. For iMX6SL ensure that clk_pllv3_prepare does
not lock the PLL.
3. Ensure that MMDC_CH0_LPM_HS is set when WAIT mode is entered.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 arch/arm/mach-imx/clk-imx6sl.c |   49 ++++++++++++++++++++++++++++++-
 arch/arm/mach-imx/clk-pllv3.c  |   62 +++++++++++++++++----------------------
 arch/arm/mach-imx/pm-imx6.c    |    6 ++++
 3 files changed, 80 insertions(+), 37 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index c837890..8ebd1b7 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -7,8 +7,20 @@
  *
  */
 
-#define CCM_CCDR_OFFSET	0x4
-#define CCDR_CH0_HS_BYP	17
+#define CCM_CCDR_OFFSET		0x4
+#define ANATOP_PLL_USB1		0x10
+#define ANATOP_PLL_USB2		0x20
+#define ANATOP_PLL_ENET		0xE0
+#define ANATOP_PLL_BYPASS_OFFSET	(1 << 16)
+#define ANATOP_PLL_ENABLE_OFFSET	(1 << 13)
+#define ANATOP_PLL_POWER_OFFSET	(1 << 12)
+#define ANATOP_PFD_480n_OFFSET	0xf0
+#define ANATOP_PFD_528n_OFFSET	0x100
+#define PFD0_CLKGATE			(1 << 7)
+#define PFD1_CLK_GATE			(1 << 15)
+#define PFD2_CLK_GATE			(1 << 23)
+#define PFD3_CLK_GATE			(1 << 31)
+#define CCDR_CH0_HS_BYP		17
 
 #include <linux/clk.h>
 #include <linux/clkdev.h>
@@ -204,6 +216,30 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clks[IMX6SL_CLK_PLL3_60M]     = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
 	clks[IMX6SL_CLK_UART_OSC_4M]  = imx_clk_fixed_factor("uart_osc_4M", "osc",          1, 6);
 
+	/* Ensure all PFDs but PLL2_PFD2 are disabled. */
+	reg = readl_relaxed(base + ANATOP_PFD_480n_OFFSET);
+	reg |= (PFD0_CLKGATE | PFD1_CLK_GATE | PFD2_CLK_GATE | PFD3_CLK_GATE);
+	writel_relaxed(reg, base + ANATOP_PFD_480n_OFFSET);
+	reg = readl_relaxed(base + ANATOP_PFD_528n_OFFSET);
+	reg |= (PFD0_CLKGATE | PFD1_CLK_GATE);
+	writel_relaxed(reg, base + ANATOP_PFD_528n_OFFSET);
+
+	/* Ensure Unused PLLs are disabled. */
+	reg = readl_relaxed(base + ANATOP_PLL_USB1);
+	reg |= ANATOP_PLL_BYPASS_OFFSET;
+	reg &= ~(ANATOP_PLL_ENABLE_OFFSET | ANATOP_PLL_POWER_OFFSET);
+	writel_relaxed(reg, base + ANATOP_PLL_USB1);
+
+	reg = readl_relaxed(base + ANATOP_PLL_USB2);
+	reg |= ANATOP_PLL_BYPASS_OFFSET;
+	reg &= ~(ANATOP_PLL_ENABLE_OFFSET | ANATOP_PLL_POWER_OFFSET);
+	writel_relaxed(reg, base + ANATOP_PLL_USB2);
+
+	reg = readl_relaxed(base + ANATOP_PLL_ENET);
+	reg |= (ANATOP_PLL_BYPASS_OFFSET | ANATOP_PLL_POWER_OFFSET);
+	reg &= ~ANATOP_PLL_ENABLE_OFFSET;
+	writel_relaxed(reg, base + ANATOP_PLL_ENET);
+
 	np = ccm_node;
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
@@ -350,6 +386,15 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	if (ret)
 		pr_warn("%s: failed to enable IPG clock %d\n", __func__, ret);
 
+	/*
+	 * Make sure the ARM clk is enabled to maintain the correct usecount
+	 * and enabling/disabling of parent PLLs.
+	 */
+	ret = clk_prepare_enable(clks[IMX6SL_CLK_ARM]);
+	if (ret)
+		pr_warn("%s: failed to enable ARM core clock %d\n",
+			__func__, ret);
+
 	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
 		clk_prepare_enable(clks[IMX6SL_CLK_USBPHY1_GATE]);
 		clk_prepare_enable(clks[IMX6SL_CLK_USBPHY2_GATE]);
diff --git a/arch/arm/mach-imx/clk-pllv3.c b/arch/arm/mach-imx/clk-pllv3.c
index 6559a5c..ab0e48f 100644
--- a/arch/arm/mach-imx/clk-pllv3.c
+++ b/arch/arm/mach-imx/clk-pllv3.c
@@ -72,41 +72,41 @@ static int clk_pllv3_wait_for_lock(struct clk_pllv3 *pll, u32 timeout_ms)
 		return -ETIMEDOUT;
 }
 
-static int clk_pllv3_prepare(struct clk_hw *hw)
+static int clk_pllv3_power_up_down(struct clk_hw *hw, bool enable)
 {
 	struct clk_pllv3 *pll = to_clk_pllv3(hw);
-	u32 val;
-
-	val = readl_relaxed(pll->base);
-	val &= ~BM_PLL_BYPASS;
-	if (pll->powerup_set)
-		val |= BM_PLL_POWER;
-	else
-		val &= ~BM_PLL_POWER;
-	writel_relaxed(val, pll->base);
-
-	return clk_pllv3_wait_for_lock(pll, 10);
+	u32 val, ret = 0;
+
+	if (enable) {
+		val = readl_relaxed(pll->base);
+		val &= ~BM_PLL_BYPASS;
+		if (pll->powerup_set)
+			val |= BM_PLL_POWER;
+		else
+			val &= ~BM_PLL_POWER;
+		writel_relaxed(val, pll->base);
+
+		ret = clk_pllv3_wait_for_lock(pll, 10);
+	} else {
+		val = readl_relaxed(pll->base);
+		val |= BM_PLL_BYPASS;
+		if (pll->powerup_set)
+			val &= ~BM_PLL_POWER;
+		else
+			val |= BM_PLL_POWER;
+		writel_relaxed(val, pll->base);
+	}
+	return ret;
 }
 
-static void clk_pllv3_unprepare(struct clk_hw *hw)
-{
-	struct clk_pllv3 *pll = to_clk_pllv3(hw);
-	u32 val;
-
-	val = readl_relaxed(pll->base);
-	val |= BM_PLL_BYPASS;
-	if (pll->powerup_set)
-		val &= ~BM_PLL_POWER;
-	else
-		val |= BM_PLL_POWER;
-	writel_relaxed(val, pll->base);
-}
 
 static int clk_pllv3_enable(struct clk_hw *hw)
 {
 	struct clk_pllv3 *pll = to_clk_pllv3(hw);
 	u32 val;
 
+	clk_pllv3_power_up_down(hw, true);
+
 	val = readl_relaxed(pll->base);
 	val |= BM_PLL_ENABLE;
 	writel_relaxed(val, pll->base);
@@ -123,6 +123,8 @@ static void clk_pllv3_disable(struct clk_hw *hw)
 	if (!pll->always_on)
 		val &= ~BM_PLL_ENABLE;
 	writel_relaxed(val, pll->base);
+
+	clk_pllv3_power_up_down(hw, false);
 }
 
 static unsigned long clk_pllv3_recalc_rate(struct clk_hw *hw,
@@ -183,8 +185,6 @@ static int clk_pllv3_set_rate(struct clk_hw *hw, unsigned long rate,
 }
 
 static const struct clk_ops clk_pllv3_ops = {
-	.prepare	= clk_pllv3_prepare,
-	.unprepare	= clk_pllv3_unprepare,
 	.enable		= clk_pllv3_enable,
 	.disable	= clk_pllv3_disable,
 	.recalc_rate	= clk_pllv3_recalc_rate,
@@ -239,8 +239,6 @@ static int clk_pllv3_sys_set_rate(struct clk_hw *hw, unsigned long rate,
 }
 
 static const struct clk_ops clk_pllv3_sys_ops = {
-	.prepare	= clk_pllv3_prepare,
-	.unprepare	= clk_pllv3_unprepare,
 	.enable		= clk_pllv3_enable,
 	.disable	= clk_pllv3_disable,
 	.recalc_rate	= clk_pllv3_sys_recalc_rate,
@@ -313,8 +311,6 @@ static int clk_pllv3_av_set_rate(struct clk_hw *hw, unsigned long rate,
 }
 
 static const struct clk_ops clk_pllv3_av_ops = {
-	.prepare	= clk_pllv3_prepare,
-	.unprepare	= clk_pllv3_unprepare,
 	.enable		= clk_pllv3_enable,
 	.disable	= clk_pllv3_disable,
 	.recalc_rate	= clk_pllv3_av_recalc_rate,
@@ -329,16 +325,12 @@ static unsigned long clk_pllv3_enet_recalc_rate(struct clk_hw *hw,
 }
 
 static const struct clk_ops clk_pllv3_enet_ops = {
-	.prepare	= clk_pllv3_prepare,
-	.unprepare	= clk_pllv3_unprepare,
 	.enable		= clk_pllv3_enable,
 	.disable	= clk_pllv3_disable,
 	.recalc_rate	= clk_pllv3_enet_recalc_rate,
 };
 
 static const struct clk_ops clk_pllv3_mlb_ops = {
-	.prepare	= clk_pllv3_prepare,
-	.unprepare	= clk_pllv3_unprepare,
 	.enable		= clk_pllv3_enable,
 	.disable	= clk_pllv3_disable,
 };
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index 0b1e13e..8ef90ee 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -167,6 +167,12 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 	case WAIT_UNCLOCKED:
 		val |= 0x1 << BP_CLPCR_LPM;
 		val |= BM_CLPCR_ARM_CLK_DIS_ON_LPM;
+		val &= ~BM_CLPCR_VSTBY;
+		val &= ~BM_CLPCR_SBYOS;
+		if (cpu_is_imx6sl())
+			val |= BM_CLPCR_BYP_MMDC_CH0_LPM_HS;
+		else
+			val |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;
 		break;
 	case STOP_POWER_ON:
 		val |= 0x2 << BP_CLPCR_LPM;
-- 
1.7.5.4

