From 8858038405a2dc715c9737beab182b4d5312972f Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 19 Jul 2013 09:42:51 +0800
Subject: [PATCH 26/38] fsl_imx6q: Update touchscreen driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/input/touchscreen/Kconfig       |   21 ++
 drivers/input/touchscreen/Makefile      |    1 +
 drivers/input/touchscreen/egalax_ts.c   |  310 +++++++++++++----------
 drivers/input/touchscreen/elan_ts.c     |  417 +++++++++++++++++++++++++++++++
 drivers/input/touchscreen/max11801_ts.c |  307 ++++++++++++++++++-----
 5 files changed, 861 insertions(+), 195 deletions(-)
 create mode 100644 drivers/input/touchscreen/elan_ts.c

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 75838d7..0e2480d 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -230,6 +230,27 @@ config TOUCHSCREEN_EGALAX
 	  To compile this driver as a module, choose M here: the
 	  module will be called egalax_ts.
 
+config TOUCHSCREEN_ELAN
+	tristate "ELAN touchscreen input driver"
+	depends on I2C
+	help
+	  Say Y here if you have an I2C ELAN touchscreen
+	  attached.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called elan-touch.
+
+config TOUCHSCREEN_EGALAX_SINGLE_TOUCH
+	bool "EETI eGalax touchscreen as single-touch"
+	default N
+	depends on TOUCHSCREEN_EGALAX
+	help
+	  If you say yes here you get single-touch touchscreen support
+	  on the eGalax I2C controller.
+	  If you say "no", you'll get the normal multi-touch.
+
 config TOUCHSCREEN_FUJITSU
 	tristate "Fujitsu serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 3d5cf8c..e8c8fa2 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_TOUCHSCREEN_GUNZE)		+= gunze.o
 obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
+obj-$(CONFIG_TOUCHSCREEN_ELAN)		+= elan_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
diff --git a/drivers/input/touchscreen/egalax_ts.c b/drivers/input/touchscreen/egalax_ts.c
index 3d55648..0b6cde7 100644
--- a/drivers/input/touchscreen/egalax_ts.c
+++ b/drivers/input/touchscreen/egalax_ts.c
@@ -6,15 +6,27 @@
  * based on max11801_ts.c
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 /* EETI eGalax serial touch screen controller is a I2C based multiple
- * touch screen controller, it supports 5 point multiple touch. */
+ * touch screen controller, it can supports 5 pointer multiple
+ * touch. */
 
 /* TODO:
   - auto idle mode support
+  - early suspend support for android
 */
 
 #include <linux/module.h>
@@ -27,28 +39,17 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/bitops.h>
-#include <linux/input/mt.h>
-#include <linux/fsl_devices.h>
 
-/*
- * Mouse Mode: some panel may configure the controller to mouse mode,
- * which can only report one point at a given time.
- * This driver will ignore events in this mode.
- */
-#define REPORT_MODE_MOUSE		0x1
-/*
- * Vendor Mode: this mode is used to transfer some vendor specific
- * messages.
- * This driver will ignore events in this mode.
- */
+#define REPORT_MODE_SINGLE		0x1
 #define REPORT_MODE_VENDOR		0x3
-/* Multiple Touch Mode */
 #define REPORT_MODE_MTTOUCH		0x4
 
 #define MAX_SUPPORT_POINTS		5
 
+#define EVENT_MODE		0
+#define EVENT_STATUS		1
 #define EVENT_VALID_OFFSET	7
-#define EVENT_VALID_MASK	(0x1 << EVENT_VALID_OFFSET)
+#define EVENT_VAILD_MASK	(0x1 << EVENT_VALID_OFFSET)
 #define EVENT_ID_OFFSET		2
 #define EVENT_ID_MASK		(0xf << EVENT_ID_OFFSET)
 #define EVENT_IN_RANGE		(0x1 << 1)
@@ -56,45 +57,73 @@
 
 #define MAX_I2C_DATA_LEN	10
 
-#define EGALAX_MAX_X	32760
-#define EGALAX_MAX_Y	32760
-#define EGALAX_MAX_TRIES 100
+struct egalax_pointer {
+	bool valid;
+	bool status;
+	u16 x;
+	u16 y;
+};
 
 struct egalax_ts {
 	struct i2c_client		*client;
 	struct input_dev		*input_dev;
-	unsigned int			irq_gpio;
+	struct egalax_pointer		events[MAX_SUPPORT_POINTS];
 };
 
 static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
 {
-	struct egalax_ts *ts = dev_id;
-	struct input_dev *input_dev = ts->input_dev;
-	struct i2c_client *client = ts->client;
+	struct egalax_ts *data = dev_id;
+	struct input_dev *input_dev = data->input_dev;
+	struct i2c_client *client = data->client;
+	struct egalax_pointer *events = data->events;
 	u8 buf[MAX_I2C_DATA_LEN];
-	int id, ret, x, y, z;
-	int tries = 0;
+	int i, id, ret, x, y;
 	bool down, valid;
 	u8 state;
 
-	do {
-		ret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);
-	} while (ret == -EAGAIN && tries++ < EGALAX_MAX_TRIES);
+retry:
+	ret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);
+	if (ret == -EAGAIN)
+		goto retry;
 
 	if (ret < 0)
 		return IRQ_HANDLED;
 
-	if (buf[0] != REPORT_MODE_MTTOUCH) {
-		/* ignore mouse events and vendor events */
+	dev_dbg(&client->dev, "recv ret:%d", ret);
+	for (i = 0; i < MAX_I2C_DATA_LEN; i++)
+		dev_dbg(&client->dev, " %x ", buf[i]);
+
+	if (buf[0] != REPORT_MODE_VENDOR
+	    && buf[0] != REPORT_MODE_SINGLE
+	    && buf[0] != REPORT_MODE_MTTOUCH) {
+		/* invalid point */
+		return IRQ_HANDLED;
+	}
+
+	if (buf[0] == REPORT_MODE_VENDOR) {
+		dev_dbg(&client->dev, "vendor message, ignored\n");
 		return IRQ_HANDLED;
 	}
 
 	state = buf[1];
 	x = (buf[3] << 8) | buf[2];
 	y = (buf[5] << 8) | buf[4];
-	z = (buf[7] << 8) | buf[6];
 
-	valid = state & EVENT_VALID_MASK;
+	/* Currently, the panel Freescale using on SMD board _NOT_
+	 * support single pointer mode. All event are going to
+	 * multiple pointer mode.  Add single pointer mode according
+	 * to EETI eGalax I2C programming manual.
+	 */
+	if (buf[0] == REPORT_MODE_SINGLE) {
+		input_report_abs(input_dev, ABS_X, x);
+		input_report_abs(input_dev, ABS_Y, y);
+		input_report_key(input_dev, BTN_TOUCH, !!state);
+		input_sync(input_dev);
+		return IRQ_HANDLED;
+	}
+
+	/* deal with multiple touch  */
+	valid = state & EVENT_VAILD_MASK;
 	id = (state & EVENT_ID_MASK) >> EVENT_ID_OFFSET;
 	down = state & EVENT_DOWN_UP;
 
@@ -103,72 +132,92 @@ static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
-	input_mt_slot(input_dev, id);
-	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, down);
-
-	dev_dbg(&client->dev, "%s id:%d x:%d y:%d z:%d",
-		down ? "down" : "up", id, x, y, z);
-
 	if (down) {
-		input_report_abs(input_dev, ABS_MT_POSITION_X, x);
-		input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
-		input_report_abs(input_dev, ABS_MT_PRESSURE, z);
+		/* should also report old pointers */
+		events[id].valid = valid;
+		events[id].status = down;
+		events[id].x = x;
+		events[id].y = y;
+
+#ifdef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
+		input_report_abs(input_dev, ABS_X, x);
+		input_report_abs(input_dev, ABS_Y, y);
+		input_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);
+		input_report_abs(input_dev, ABS_PRESSURE, 1);
+#else
+		for (i = 0; i < MAX_SUPPORT_POINTS; i++) {
+			if (!events[i].valid)
+				continue;
+			dev_dbg(&client->dev, "report id:%d valid:%d x:%d y:%d",
+				i, valid, x, y);
+
+			input_report_abs(input_dev,
+					 ABS_MT_TRACKING_ID, i);
+			input_report_abs(input_dev,
+					 ABS_MT_TOUCH_MAJOR, 1);
+			input_report_abs(input_dev,
+					 ABS_MT_POSITION_X, events[i].x);
+			input_report_abs(input_dev,
+					 ABS_MT_POSITION_Y, events[i].y);
+			input_mt_sync(input_dev);
+		}
+#endif
+	} else {
+		dev_dbg(&client->dev, "release id:%d\n", id);
+		events[id].valid = 0;
+		events[id].status = 0;
+#ifdef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
+		input_report_key(input_dev, BTN_TOUCH, 0);
+		input_report_abs(input_dev, ABS_PRESSURE, 0);
+#else
+		input_report_abs(input_dev, ABS_MT_TRACKING_ID, id);
+		input_event(input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+		input_mt_sync(input_dev);
+#endif
 	}
 
-	input_mt_report_pointer_emulation(input_dev, true);
 	input_sync(input_dev);
-
 	return IRQ_HANDLED;
 }
 
-/* wake up controller by an falling edge of interrupt gpio.  */
-static int egalax_wake_up_device(struct i2c_client *client, unsigned int gpio)
+static int egalax_wake_up_device(struct i2c_client *client)
 {
+	int gpio = irq_to_gpio(client->irq);
 	int ret;
 
 	ret = gpio_request(gpio, "egalax_irq");
 	if (ret < 0) {
-		dev_err(&client->dev,
-			"request gpio failed, cannot wake up controller: %d\n",
-			ret);
+		dev_err(&client->dev, "request gpio failed:%d\n", ret);
 		return ret;
 	}
-
-	/* wake up controller via an falling edge on IRQ gpio. */
-	gpio_direction_output(gpio, 1);
+	/* wake up controller via an falling edge on IRQ. */
 	gpio_direction_output(gpio, 0);
 	gpio_set_value(gpio, 1);
-
 	/* controller should be waken up, return irq.  */
 	gpio_direction_input(gpio);
 	gpio_free(gpio);
-
 	return 0;
 }
 
-static int __devinit egalax_firmware_version(struct i2c_client *client)
+static int egalax_7200_firmware_version(struct i2c_client *client)
 {
 	static const u8 cmd[MAX_I2C_DATA_LEN] = { 0x03, 0x03, 0xa, 0x01, 0x41 };
 	int ret;
-
 	ret = i2c_master_send(client, cmd, MAX_I2C_DATA_LEN);
 	if (ret < 0)
 		return ret;
-
 	return 0;
 }
 
 static int __devinit egalax_ts_probe(struct i2c_client *client,
 				       const struct i2c_device_id *id)
 {
-	struct egalax_ts *ts;
+	struct egalax_ts *data;
 	struct input_dev *input_dev;
-	struct egalax_ts_data *egalax_platform = client->dev.platform_data;
 	int ret;
-	int error;
 
-	ts = kzalloc(sizeof(struct egalax_ts), GFP_KERNEL);
-	if (!ts) {
+	data = kzalloc(sizeof(struct egalax_ts), GFP_KERNEL);
+	if (!data) {
 		dev_err(&client->dev, "Failed to allocate memory\n");
 		return -ENOMEM;
 	}
@@ -176,126 +225,114 @@ static int __devinit egalax_ts_probe(struct i2c_client *client,
 	input_dev = input_allocate_device();
 	if (!input_dev) {
 		dev_err(&client->dev, "Failed to allocate memory\n");
-		error = -ENOMEM;
-		goto err_free_ts;
+		ret = -ENOMEM;
+		goto err_free_data;
 	}
 
-	ts->client = client;
-	ts->input_dev = input_dev;
-
-	if(egalax_platform) {
-		ts->irq_gpio = egalax_platform->irq_gpio;
-		client->irq = gpio_to_irq(ts->irq_gpio);
-	}
-
-	/* controller may be in sleep, wake it up. */
-	ret = egalax_wake_up_device(client, ts->irq_gpio);
+	data->client = client;
+	data->input_dev = input_dev;
+	egalax_wake_up_device(client);
+	ret = egalax_7200_firmware_version(client);
 	if (ret < 0) {
-		dev_err(&client->dev, "Failed to wake up the controller\n");
-		error = ret;
-		goto err_free_dev;
-	}
-
-	msleep(10);
-	/* the controller needs some time to wakeup, otherwise the
-	 * following firmware version read will be failed.
-	 */
-	ret = egalax_firmware_version(client);
-	if (ret < 0) {
-		dev_err(&client->dev, "Failed to read firmware version\n");
-		error = -EIO;
+		dev_err(&client->dev,
+			"egalax_ts: failed to read firmware version\n");
+		ret = -EIO;
 		goto err_free_dev;
 	}
 
-	input_dev->name = "EETI eGalax Touch Screen";
+	input_dev->name = "eGalax Touch Screen";
+	input_dev->phys = "I2C",
 	input_dev->id.bustype = BUS_I2C;
+	input_dev->id.vendor = 0x0EEF;
+	input_dev->id.product = 0x0020;
+	input_dev->id.version = 0x0001;
 	input_dev->dev.parent = &client->dev;
 
 	__set_bit(EV_ABS, input_dev->evbit);
 	__set_bit(EV_KEY, input_dev->evbit);
 	__set_bit(BTN_TOUCH, input_dev->keybit);
+	__set_bit(ABS_X, input_dev->absbit);
+	__set_bit(ABS_Y, input_dev->absbit);
+	__set_bit(ABS_PRESSURE, input_dev->absbit);
+	input_set_abs_params(input_dev, ABS_X, 0, 32767, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, 32767, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+#ifndef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, 32767, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, 32767, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0,
+			     MAX_SUPPORT_POINTS, 0, 0);
+#endif
+	input_set_drvdata(input_dev, data);
 
-	input_set_abs_params(input_dev, ABS_X, 0, EGALAX_MAX_X, 0, 0);
-	input_set_abs_params(input_dev, ABS_Y, 0, EGALAX_MAX_Y, 0, 0);
-	input_set_abs_params(input_dev,
-			     ABS_MT_POSITION_X, 0, EGALAX_MAX_X, 0, 0);
-	input_set_abs_params(input_dev,
-			     ABS_MT_POSITION_X, 0, EGALAX_MAX_Y, 0, 0);
-	input_mt_init_slots(input_dev, MAX_SUPPORT_POINTS);
-
-	input_set_drvdata(input_dev, ts);
-
-	error = request_threaded_irq(client->irq, NULL, egalax_ts_interrupt,
-				     IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-				     "egalax_ts", ts);
-	if (error < 0) {
+	ret = request_threaded_irq(client->irq, NULL, egalax_ts_interrupt,
+				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				   "egalax_ts", data);
+	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register interrupt\n");
 		goto err_free_dev;
 	}
 
-	error = input_register_device(ts->input_dev);
-	if (error)
+	ret = input_register_device(data->input_dev);
+	if (ret < 0)
 		goto err_free_irq;
-
-	i2c_set_clientdata(client, ts);
+	i2c_set_clientdata(client, data);
 	return 0;
 
 err_free_irq:
-	free_irq(client->irq, ts);
+	free_irq(client->irq, data);
 err_free_dev:
 	input_free_device(input_dev);
-err_free_ts:
-	kfree(ts);
+err_free_data:
+	kfree(data);
 
-	return error;
+	return ret;
 }
 
 static __devexit int egalax_ts_remove(struct i2c_client *client)
 {
-	struct egalax_ts *ts = i2c_get_clientdata(client);
+	struct egalax_ts *data = i2c_get_clientdata(client);
 
-	free_irq(client->irq, ts);
-
-	input_unregister_device(ts->input_dev);
-	kfree(ts);
+	free_irq(client->irq, data);
+	input_unregister_device(data->input_dev);
+	input_free_device(data->input_dev);
+	kfree(data);
 
 	return 0;
 }
 
 static const struct i2c_device_id egalax_ts_id[] = {
-	{ "egalax_ts", 0 },
-	{ }
+	{"egalax_ts", 0},
+	{}
 };
 MODULE_DEVICE_TABLE(i2c, egalax_ts_id);
 
 #ifdef CONFIG_PM_SLEEP
 static int egalax_ts_suspend(struct device *dev)
 {
-	static const u8 suspend_cmd[MAX_I2C_DATA_LEN] = {
-		0x3, 0x6, 0xa, 0x3, 0x36, 0x3f, 0x2, 0, 0, 0
-	};
-	struct i2c_client *client = to_i2c_client(dev);
 	int ret;
-
-	ret = i2c_master_send(client, suspend_cmd, MAX_I2C_DATA_LEN);
+	u8 suspend_cmd[MAX_I2C_DATA_LEN] = {0x3, 0x6, 0xa, 0x3, 0x36,
+					    0x3f, 0x2, 0, 0, 0};
+	struct i2c_client *client = to_i2c_client(dev);
+	ret = i2c_master_send(client, suspend_cmd,
+			       MAX_I2C_DATA_LEN);
 	return ret > 0 ? 0 : ret;
 }
 
 static int egalax_ts_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct egalax_ts *ts = i2c_get_clientdata(client);
-
-	return egalax_wake_up_device(client, ts->irq_gpio);
+	return egalax_wake_up_device(client);
 }
 #endif
 
 static SIMPLE_DEV_PM_OPS(egalax_ts_pm_ops, egalax_ts_suspend, egalax_ts_resume);
-
 static struct i2c_driver egalax_ts_driver = {
 	.driver = {
-		.name	= "egalax_ts",
-		.owner	= THIS_MODULE,
+		.name = "egalax_ts",
 		.pm	= &egalax_ts_pm_ops,
 	},
 	.id_table	= egalax_ts_id,
@@ -303,7 +340,18 @@ static struct i2c_driver egalax_ts_driver = {
 	.remove		= __devexit_p(egalax_ts_remove),
 };
 
-module_i2c_driver(egalax_ts_driver);
+static int __init egalax_ts_init(void)
+{
+	return i2c_add_driver(&egalax_ts_driver);
+}
+
+static void __exit egalax_ts_exit(void)
+{
+	i2c_del_driver(&egalax_ts_driver);
+}
+
+module_init(egalax_ts_init);
+module_exit(egalax_ts_exit);
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("Touchscreen driver for EETI eGalax touch controller");
diff --git a/drivers/input/touchscreen/elan_ts.c b/drivers/input/touchscreen/elan_ts.c
new file mode 100644
index 0000000..9027259
--- /dev/null
+++ b/drivers/input/touchscreen/elan_ts.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2007-2008 HTC Corporation.
+ *
+ * This driver is adapted from elan8232_i2c.c written by Shan-Fu Chiou
+ * <sfchiou@gmail.com> and Jay Tu <jay_tu@htc.com>.
+ * This driver is also adapted from the ELAN Touch Screen driver
+ * written by Stanley Zeng <stanley.zeng@emc.com.tw>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/gpio.h>
+
+static const char ELAN_TS_NAME[] = "elan-touch";
+
+#define ELAN_TS_X_MAX 		1088
+#define ELAN_TS_Y_MAX 		768
+#define ELAN_USER_X_MAX		800
+#define ELAN_USER_Y_MAX		600
+#define IDX_PACKET_SIZE		8
+
+enum {
+	hello_packet = 0x55,
+	idx_coordinate_packet = 0x5a,
+};
+
+enum {
+	idx_finger_state = 7,
+};
+
+static struct workqueue_struct *elan_wq;
+
+static struct elan_data {
+	int intr_gpio;
+	int use_irq;
+	struct hrtimer timer;
+	struct work_struct work;
+	struct i2c_client *client;
+	struct input_dev *input;
+	wait_queue_head_t wait;
+} elan_touch_data;
+
+/*--------------------------------------------------------------*/
+static int elan_touch_detect_int_level(void)
+{
+	unsigned v;
+	v = gpio_get_value(elan_touch_data.intr_gpio);
+
+	return v;
+}
+
+static int __elan_touch_poll(struct i2c_client *client)
+{
+	int status = 0, retry = 20;
+
+	do {
+		status = elan_touch_detect_int_level();
+		retry--;
+		mdelay(20);
+	} while (status == 1 && retry > 0);
+
+	return (status == 0 ? 0 : -ETIMEDOUT);
+}
+
+static int elan_touch_poll(struct i2c_client *client)
+{
+	return __elan_touch_poll(client);
+}
+
+static int __hello_packet_handler(struct i2c_client *client)
+{
+	int rc;
+	uint8_t buf_recv[4] = { 0 };
+
+	rc = elan_touch_poll(client);
+
+	if (rc < 0) {
+		return -EINVAL;
+	}
+
+	rc = i2c_master_recv(client, buf_recv, 4);
+
+	if (rc != 4) {
+		return rc;
+	} else {
+		int i;
+		printk("hello packet: [0x%02x 0x%02x 0x%02x 0x%02x]\n",
+		       buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3]);
+
+		for (i = 0; i < 4; i++)
+			if (buf_recv[i] != hello_packet)
+				return -EINVAL;
+	}
+
+	return 0;
+}
+
+static inline int elan_touch_parse_xy(uint8_t *data, uint16_t *x,
+				      uint16_t *y)
+{
+	*x = (data[0] & 0xf0);
+	*x <<= 4;
+	*x |= data[1];
+	if (*x >= ELAN_TS_X_MAX)
+		*x = ELAN_TS_X_MAX;
+	*x = ((((ELAN_TS_X_MAX -
+		 *x) * 1000) / ELAN_TS_X_MAX) * ELAN_USER_X_MAX) / 1000;
+
+	*y = (data[0] & 0x0f);
+	*y <<= 8;
+	*y |= data[2];
+	if (*y >= ELAN_TS_Y_MAX)
+		*y = ELAN_TS_Y_MAX;
+	*y = ((((ELAN_TS_Y_MAX -
+		 *y) * 1000) / ELAN_TS_Y_MAX) * ELAN_USER_Y_MAX) / 1000;
+
+	return 0;
+}
+
+/*	__elan_touch_init -- hand shaking with touch panel
+ *
+ *	1.recv hello packet
+ */
+static int __elan_touch_init(struct i2c_client *client)
+{
+	int rc;
+	rc = __hello_packet_handler(client);
+	if (rc < 0)
+		goto hand_shake_failed;
+
+hand_shake_failed:
+	return rc;
+}
+
+static int elan_touch_recv_data(struct i2c_client *client, uint8_t * buf)
+{
+	int rc, bytes_to_recv = IDX_PACKET_SIZE;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	memset(buf, 0, bytes_to_recv);
+	rc = i2c_master_recv(client, buf, bytes_to_recv);
+	if (rc != bytes_to_recv) {
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static void elan_touch_report_data(struct i2c_client *client, uint8_t * buf)
+{
+	switch (buf[0]) {
+	case idx_coordinate_packet:
+	{
+		uint16_t x1, x2, y1, y2;
+		uint8_t finger_stat;
+
+		finger_stat = (buf[idx_finger_state] & 0x06) >> 1;
+
+		if (finger_stat == 0) {
+			input_report_key(elan_touch_data.input, BTN_TOUCH, 0);
+			input_report_key(elan_touch_data.input, BTN_2, 0);
+		} else if (finger_stat == 1) {
+			elan_touch_parse_xy(&buf[1], &x1, &y1);
+			input_report_abs(elan_touch_data.input, ABS_X, x1);
+			input_report_abs(elan_touch_data.input, ABS_Y, y1);
+			input_report_key(elan_touch_data.input, BTN_TOUCH, 1);
+			input_report_key(elan_touch_data.input, BTN_2, 0);
+		} else if (finger_stat == 2) {
+			elan_touch_parse_xy(&buf[1], &x1, &y1);
+			input_report_abs(elan_touch_data.input, ABS_X, x1);
+			input_report_abs(elan_touch_data.input, ABS_Y, y1);
+			input_report_key(elan_touch_data.input, BTN_TOUCH, 1);
+			elan_touch_parse_xy(&buf[4], &x2, &y2);
+			input_report_abs(elan_touch_data.input, ABS_HAT0X, x2);
+			input_report_abs(elan_touch_data.input, ABS_HAT0Y, y2);
+			input_report_key(elan_touch_data.input, BTN_2, 1);
+		}
+		input_sync(elan_touch_data.input);
+		break;
+	}
+
+	default:
+		break;
+	}
+}
+
+static void elan_touch_work_func(struct work_struct *work)
+{
+	int rc;
+	uint8_t buf[IDX_PACKET_SIZE] = { 0 };
+	struct i2c_client *client = elan_touch_data.client;
+
+	if (elan_touch_detect_int_level())
+		return;
+
+	rc = elan_touch_recv_data(client, buf);
+	if (rc < 0)
+		return;
+
+	elan_touch_report_data(client, buf);
+}
+
+static irqreturn_t elan_touch_ts_interrupt(int irq, void *dev_id)
+{
+	queue_work(elan_wq, &elan_touch_data.work);
+
+	return IRQ_HANDLED;
+}
+
+static enum hrtimer_restart elan_touch_timer_func(struct hrtimer *timer)
+{
+	queue_work(elan_wq, &elan_touch_data.work);
+	hrtimer_start(&elan_touch_data.timer, ktime_set(0, 12500000),
+		      HRTIMER_MODE_REL);
+
+	return HRTIMER_NORESTART;
+}
+
+static int elan_touch_register_interrupt(struct i2c_client *client)
+{
+	int err = 0;
+
+	if (client->irq) {
+		elan_touch_data.use_irq = 1;
+		err =
+		    request_irq(client->irq, elan_touch_ts_interrupt,
+				IRQF_TRIGGER_FALLING, ELAN_TS_NAME,
+				&elan_touch_data);
+
+		if (err < 0) {
+			printk("%s(%s): Can't allocate irq %d\n", __FILE__,
+			       __func__, client->irq);
+			elan_touch_data.use_irq = 0;
+		}
+	}
+
+	if (!elan_touch_data.use_irq) {
+		hrtimer_init(&elan_touch_data.timer, CLOCK_MONOTONIC,
+			     HRTIMER_MODE_REL);
+		elan_touch_data.timer.function = elan_touch_timer_func;
+		hrtimer_start(&elan_touch_data.timer, ktime_set(1, 0),
+			      HRTIMER_MODE_REL);
+	}
+
+	printk("elan ts starts in %s mode.\n",
+	       elan_touch_data.use_irq == 1 ? "interrupt" : "polling");
+
+	return 0;
+}
+
+static int elan_touch_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err = 0;
+
+	elan_wq = create_singlethread_workqueue("elan_wq");
+	if (!elan_wq) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	elan_touch_data.client = client;
+	strlcpy(client->name, ELAN_TS_NAME, I2C_NAME_SIZE);
+
+	INIT_WORK(&elan_touch_data.work, elan_touch_work_func);
+
+	elan_touch_data.intr_gpio = irq_to_gpio(client->irq);
+	pr_debug("irq_to_gpio irq %d, gpio %d\n", client->irq,
+		 elan_touch_data.intr_gpio);
+
+	elan_touch_data.input = input_allocate_device();
+	if (elan_touch_data.input == NULL) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	err = __elan_touch_init(client);
+	if (err < 0) {
+		printk("elan - Read Hello Packet Failed\n");
+		goto fail;
+	}
+
+	elan_touch_data.input->name = ELAN_TS_NAME;
+	elan_touch_data.input->id.bustype = BUS_I2C;
+
+	set_bit(EV_SYN, elan_touch_data.input->evbit);
+
+	set_bit(EV_KEY, elan_touch_data.input->evbit);
+	set_bit(BTN_TOUCH, elan_touch_data.input->keybit);
+	set_bit(BTN_2, elan_touch_data.input->keybit);
+
+	set_bit(EV_ABS, elan_touch_data.input->evbit);
+	set_bit(ABS_X, elan_touch_data.input->absbit);
+	set_bit(ABS_Y, elan_touch_data.input->absbit);
+	set_bit(ABS_HAT0X, elan_touch_data.input->absbit);
+	set_bit(ABS_HAT0Y, elan_touch_data.input->absbit);
+
+	input_set_abs_params(elan_touch_data.input, ABS_X, 0, ELAN_USER_X_MAX,
+			     0, 0);
+	input_set_abs_params(elan_touch_data.input, ABS_Y, 0, ELAN_USER_Y_MAX,
+			     0, 0);
+	input_set_abs_params(elan_touch_data.input, ABS_HAT0X, 0,
+			     ELAN_USER_X_MAX, 0, 0);
+	input_set_abs_params(elan_touch_data.input, ABS_HAT0Y, 0,
+			     ELAN_USER_Y_MAX, 0, 0);
+
+	err = input_register_device(elan_touch_data.input);
+	if (err < 0) {
+		goto fail;
+	}
+
+	elan_touch_register_interrupt(elan_touch_data.client);
+
+	return 0;
+
+fail:
+	input_free_device(elan_touch_data.input);
+	if (elan_wq)
+		destroy_workqueue(elan_wq);
+	return err;
+}
+
+static int elan_touch_remove(struct i2c_client *client)
+{
+	if (elan_wq)
+		destroy_workqueue(elan_wq);
+
+	input_unregister_device(elan_touch_data.input);
+
+	if (elan_touch_data.use_irq)
+		free_irq(client->irq, client);
+	else
+		hrtimer_cancel(&elan_touch_data.timer);
+	return 0;
+}
+
+/* -------------------------------------------------------------------- */
+static const struct i2c_device_id elan_touch_id[] = {
+	{"elan-touch", 0},
+	{}
+};
+
+static int elan_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int elan_resume(struct device *dev)
+{
+	uint8_t buf[IDX_PACKET_SIZE] = { 0 };
+
+	if (0 == elan_touch_detect_int_level()) {
+		dev_dbg(dev, "Got touch during suspend period.\n");
+		/*
+		 * if touch screen during suspend, recv and drop the
+		 * data, then touch interrupt pin will return high after
+		 * receving data.
+		 */
+		elan_touch_recv_data(elan_touch_data.client, buf);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops elan_dev_pm_ops = {
+	.suspend = elan_suspend,
+	.resume  = elan_resume,
+};
+
+static struct i2c_driver elan_touch_driver = {
+	.probe = elan_touch_probe,
+	.remove = elan_touch_remove,
+	.id_table = elan_touch_id,
+	.driver = {
+		   .name = "elan-touch",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &elan_dev_pm_ops,
+#endif
+		   },
+};
+
+static int __init elan_touch_init(void)
+{
+	return i2c_add_driver(&elan_touch_driver);
+}
+
+static void __exit elan_touch_exit(void)
+{
+	i2c_del_driver(&elan_touch_driver);
+}
+
+module_init(elan_touch_init);
+module_exit(elan_touch_exit);
+
+MODULE_AUTHOR("Stanley Zeng <stanley.zeng@emc.com.tw>");
+MODULE_DESCRIPTION("ELAN Touch Screen driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/max11801_ts.c b/drivers/input/touchscreen/max11801_ts.c
index 4eab50b..a1ac2d2 100644
--- a/drivers/input/touchscreen/max11801_ts.c
+++ b/drivers/input/touchscreen/max11801_ts.c
@@ -2,15 +2,14 @@
  * Driver for MAXI MAX11801 - A Resistive touch screen controller with
  * i2c interface
  *
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
  * Author: Zhang Jiejing <jiejing.zhang@freescale.com>
  *
  * Based on mcs5000_ts.c
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * the Free Software Foundation; either version 2 of the License.
  */
 
 /*
@@ -39,6 +38,8 @@
 #include <linux/input.h>
 #include <linux/slab.h>
 #include <linux/bitops.h>
+#include <linux/delay.h>
+
 
 /* Register Address define */
 #define GENERNAL_STATUS_REG		0x00
@@ -54,13 +55,32 @@
 #define AUX_MESURE_CONF_REG		0x0a
 #define OP_MODE_CONF_REG		0x0b
 
+#define Panel_Setup_X	(0x69 << 1)
+#define Panel_Setup_Y	(0x6b << 1)
+
+#define XY_combined_measurement	(0x70 << 1)
+#define X_measurement	(0x78 << 1)
+#define Y_measurement	(0x7a << 1)
+#define AUX_measurement		(0x76 << 1)
+
 /* FIFO is found only in max11800 and max11801 */
 #define FIFO_RD_CMD			(0x50 << 1)
 #define MAX11801_FIFO_INT		(1 << 2)
 #define MAX11801_FIFO_OVERFLOW		(1 << 3)
+#define MAX11801_EDGE_INT      (1 << 1)
+
+#define FIFO_RD_X_MSB			(0x52 << 1)
+#define FIFO_RD_X_LSB			(0x53 << 1)
+#define FIFO_RD_Y_MSB			(0x54 << 1)
+#define FIFO_RD_Y_LSB			(0x55 << 1)
+#define FIFO_RD_AUX_MSB			(0x5a << 1)
+#define FIFO_RD_AUX_LSB			(0x5b << 1)
 
 #define XY_BUFSIZE			4
 #define XY_BUF_OFFSET			4
+#define X_BUFSIZE			2
+#define Y_BUFSIZE			2
+#define AUX_BUFSIZE			2
 
 #define MAX11801_MAX_X			0xfff
 #define MAX11801_MAX_Y			0xfff
@@ -84,6 +104,56 @@ struct max11801_data {
 	struct i2c_client		*client;
 	struct input_dev		*input_dev;
 };
+struct i2c_client *max11801_client;
+unsigned int max11801_workmode;
+u8 aux_buf[AUX_BUFSIZE];
+
+static int max11801_dcm_write_command(struct i2c_client *client, int command)
+{
+	return i2c_smbus_write_byte(client, command);
+}
+
+static u32 max11801_dcm_sample_aux(struct i2c_client *client)
+{
+	u8 temp_buf;
+	int ret;
+	int aux = 0;
+	u32 sample_data = 0;
+	/* AUX_measurement*/
+	max11801_dcm_write_command(client, AUX_measurement);
+	mdelay(5);
+	ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_AUX_MSB,
+						1, &temp_buf);
+	if (ret < 1)
+		printk(KERN_DEBUG "FIFO_RD_AUX_MSB read fails\n");
+	else
+		aux_buf[0] = temp_buf;
+	mdelay(5);
+	ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_AUX_LSB,
+						1, &temp_buf);
+	if (ret < 1)
+		printk(KERN_DEBUG "FIFO_RD_AUX_LSB read fails\n");
+	else
+		aux_buf[1] = temp_buf;
+	aux = (aux_buf[0] << 4) +
+					(aux_buf[1] >> 4);
+	/*
+	voltage = (9170*aux)/7371;
+	voltage is (26.2*3150*aux)/(16.2*0xFFF)
+	V(aux)=3150*sample/0xFFF,V(battery)=212*V(aux)/81
+	sample_data = (14840*aux)/7371-1541;
+	*/
+	sample_data = (14840*aux)/7371;
+	return sample_data;
+}
+
+u32 max11801_read_adc(void)
+{
+	u32 adc_data;
+	adc_data = max11801_dcm_sample_aux(max11801_client);
+	return adc_data;
+}
+EXPORT_SYMBOL_GPL(max11801_read_adc);
 
 static u8 read_register(struct i2c_client *client, int addr)
 {
@@ -97,81 +167,179 @@ static int max11801_write_reg(struct i2c_client *client, int addr, int data)
 	return i2c_smbus_write_byte_data(client, addr << 1, data);
 }
 
+static void calibration_pointer(int *x_orig, int *y_orig)
+{
+	int  y;
+	y = MAX11801_MAX_Y - *y_orig;
+	*y_orig = y;
+}
+
 static irqreturn_t max11801_ts_interrupt(int irq, void *dev_id)
 {
 	struct max11801_data *data = dev_id;
 	struct i2c_client *client = data->client;
 	int status, i, ret;
 	u8 buf[XY_BUFSIZE];
+	u8 x_buf[X_BUFSIZE];
+	u8 y_buf[Y_BUFSIZE];
+	u8 temp_buf[1];
 	int x = -1;
 	int y = -1;
 
 	status = read_register(data->client, GENERNAL_STATUS_REG);
-
-	if (status & (MAX11801_FIFO_INT | MAX11801_FIFO_OVERFLOW)) {
-		status = read_register(data->client, GENERNAL_STATUS_REG);
-
-		ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_CMD,
-						    XY_BUFSIZE, buf);
-
-		/*
-		 * We should get 4 bytes buffer that contains X,Y
-		 * and event tag
-		 */
-		if (ret < XY_BUFSIZE)
-			goto out;
-
-		for (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {
-			if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
-				x = (buf[i] << XY_BUF_OFFSET) +
-				    (buf[i + 1] >> XY_BUF_OFFSET);
-			else if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
-				y = (buf[i] << XY_BUF_OFFSET) +
-				    (buf[i + 1] >> XY_BUF_OFFSET);
-		}
-
-		if ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))
-			goto out;
-
-		switch (buf[1] & EVENT_TAG_MASK) {
-		case EVENT_INIT:
-			/* fall through */
-		case EVENT_MIDDLE:
-			input_report_abs(data->input_dev, ABS_X, x);
-			input_report_abs(data->input_dev, ABS_Y, y);
-			input_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);
-			input_sync(data->input_dev);
-			break;
-
-		case EVENT_RELEASE:
-			input_event(data->input_dev, EV_KEY, BTN_TOUCH, 0);
-			input_sync(data->input_dev);
-			break;
-
-		case EVENT_FIFO_END:
-			break;
-		}
-	}
+	if (max11801_workmode == 0) {
+		if (status & (MAX11801_FIFO_INT | MAX11801_FIFO_OVERFLOW)) {
+				status = read_register(data->client, GENERNAL_STATUS_REG);
+
+				ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_CMD,
+								    XY_BUFSIZE, buf);
+
+				/*
+				 * We should get 4 bytes buffer that contains X,Y
+				 * and event tag
+				 */
+				if (ret < XY_BUFSIZE)
+					goto out;
+
+				for (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {
+					if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
+						x = (buf[i] << XY_BUF_OFFSET) +
+						    (buf[i + 1] >> XY_BUF_OFFSET);
+					else if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
+						y = (buf[i] << XY_BUF_OFFSET) +
+						    (buf[i + 1] >> XY_BUF_OFFSET);
+				}
+
+				if ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))
+					goto out;
+
+				switch (buf[1] & EVENT_TAG_MASK) {
+				case EVENT_INIT:
+					/* fall through */
+				case EVENT_MIDDLE:
+					calibration_pointer(&x, &y);
+					input_report_abs(data->input_dev, ABS_X, x);
+					input_report_abs(data->input_dev, ABS_Y, y);
+					input_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);
+					input_sync(data->input_dev);
+					break;
+
+				case EVENT_RELEASE:
+					input_event(data->input_dev, EV_KEY, BTN_TOUCH, 0);
+					input_sync(data->input_dev);
+					break;
+
+				case EVENT_FIFO_END:
+					break;
+				}
+			}
 out:
-	return IRQ_HANDLED;
+return IRQ_HANDLED;
+		}
+	else if (max11801_workmode == 1) {
+		if (status & (MAX11801_EDGE_INT)) {
+				status = read_register(data->client, GENERNAL_STATUS_REG);
+
+				/* X = panel setup*/
+				max11801_dcm_write_command(client, Panel_Setup_X);
+				/* X_measurement*/
+				max11801_dcm_write_command(client, X_measurement);
+				ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_X_MSB,
+									1, temp_buf);
+				x_buf[0] = temp_buf[0];
+				if (ret < 1)
+					goto out2;
+				ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_X_LSB,
+									1, temp_buf);
+				x_buf[1] = temp_buf[0];
+				if (ret < 1)
+					goto out2;
+				/* Y = panel setup*/
+				max11801_dcm_write_command(client, Panel_Setup_Y);
+				/* Y_measurement*/
+				max11801_dcm_write_command(client, Y_measurement);
+				ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_Y_MSB,
+									1, temp_buf);
+				y_buf[0] = temp_buf[0];
+				if (ret < 1)
+					goto out2;
+				ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_Y_LSB,
+									1, temp_buf);
+				y_buf[1] = temp_buf[0];
+				if (ret < 1)
+					goto out2;
+
+				if ((x_buf[1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
+					x = (x_buf[0] << XY_BUF_OFFSET) +
+						(x_buf[1] >> XY_BUF_OFFSET);
+				if ((y_buf[1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
+					y = (y_buf[0] << XY_BUF_OFFSET) +
+						(y_buf[1] >> XY_BUF_OFFSET);
+
+				if ((x_buf[1] & EVENT_TAG_MASK) != (y_buf[1] & EVENT_TAG_MASK))
+					goto out2;
+
+				switch (x_buf[1] & EVENT_TAG_MASK) {
+				case EVENT_INIT:
+					/* fall through */
+				case EVENT_MIDDLE:
+					calibration_pointer(&x, &y);
+					input_report_abs(data->input_dev, ABS_X, x);
+					input_report_abs(data->input_dev, ABS_Y, y);
+					input_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);
+					input_sync(data->input_dev);
+					break;
+
+				case EVENT_RELEASE:
+					input_event(data->input_dev, EV_KEY, BTN_TOUCH, 0);
+					input_sync(data->input_dev);
+					break;
+
+				case EVENT_FIFO_END:
+					break;
+				}
+			  }
+			}
+out2:
+return IRQ_HANDLED;
 }
 
 static void __devinit max11801_ts_phy_init(struct max11801_data *data)
 {
 	struct i2c_client *client = data->client;
-
-	/* Average X,Y, take 16 samples, average eight media sample */
-	max11801_write_reg(client, MESURE_AVER_CONF_REG, 0xff);
-	/* X,Y panel setup time set to 20us */
-	max11801_write_reg(client, PANEL_SETUPTIME_CONF_REG, 0x11);
-	/* Rough pullup time (2uS), Fine pullup time (10us)  */
-	max11801_write_reg(client, TOUCH_DETECT_PULLUP_CONF_REG, 0x10);
-	/* Auto mode init period = 5ms , scan period = 5ms*/
-	max11801_write_reg(client, AUTO_MODE_TIME_CONF_REG, 0xaa);
-	/* Aperture X,Y set to +- 4LSB */
-	max11801_write_reg(client, APERTURE_CONF_REG, 0x33);
-	/* Enable Power, enable Automode, enable Aperture, enable Average X,Y */
-	max11801_write_reg(client, OP_MODE_CONF_REG, 0x36);
+	max11801_client = client;
+	if (max11801_workmode == 0) {
+		/* Average X,Y, take 16 samples, average eight media sample */
+		max11801_write_reg(client, MESURE_AVER_CONF_REG, 0xff);
+		/* X,Y panel setup time set to 20us */
+		max11801_write_reg(client, PANEL_SETUPTIME_CONF_REG, 0x11);
+		/* Rough pullup time (2uS), Fine pullup time (10us)  */
+		max11801_write_reg(client, TOUCH_DETECT_PULLUP_CONF_REG, 0x10);
+		/* Auto mode init period = 5ms , scan period = 5ms*/
+		max11801_write_reg(client, AUTO_MODE_TIME_CONF_REG, 0xaa);
+		/* Aperture X,Y set to +- 4LSB */
+		max11801_write_reg(client, APERTURE_CONF_REG, 0x33);
+		/* Enable Power, enable Automode, enable Aperture, enable Average X,Y */
+		max11801_write_reg(client, OP_MODE_CONF_REG, 0x36);
+	}
+	if (max11801_workmode == 1) {
+		/* Average X,Y, take 16 samples, average eight media sample */
+		max11801_write_reg(client, MESURE_AVER_CONF_REG, 0xff);
+		/* X,Y panel setup time set to 20us */
+		max11801_write_reg(client, PANEL_SETUPTIME_CONF_REG, 0x11);
+		/* Rough pullup time (2uS), Fine pullup time (10us)  */
+		max11801_write_reg(client, TOUCH_DETECT_PULLUP_CONF_REG, 0x10);
+		/* Auto mode init period = 5ms , scan period = 5ms*/
+		max11801_write_reg(client, AUTO_MODE_TIME_CONF_REG, 0xaa);
+		/* Aperture X,Y set to +- 4LSB */
+		max11801_write_reg(client, APERTURE_CONF_REG, 0x33);
+		/* Enable Power, enable Direct conversion mode , enable Aperture, enable Average X,Y */
+		max11801_write_reg(client, OP_MODE_CONF_REG, 0x16);
+		/* Delay initial=1ms, Sampling time 2us ,Averaging sample depth 2 samples, Resolution 12bit */
+		max11801_write_reg(client, AUX_MESURE_CONF_REG, 0x76);
+		/* Use edge interrupt with direct conversion mode  */
+		max11801_write_reg(client, GENERNAL_CONF_REG, 0xf3);
+	}
 }
 
 static int __devinit max11801_ts_probe(struct i2c_client *client,
@@ -188,7 +356,7 @@ static int __devinit max11801_ts_probe(struct i2c_client *client,
 		error = -ENOMEM;
 		goto err_free_mem;
 	}
-
+	max11801_workmode = *(int *)(client->dev).platform_data;
 	data->client = client;
 	data->input_dev = input_dev;
 
@@ -255,7 +423,18 @@ static struct i2c_driver max11801_ts_driver = {
 	.remove		= __devexit_p(max11801_ts_remove),
 };
 
-module_i2c_driver(max11801_ts_driver);
+static int __init max11801_ts_init(void)
+{
+	return i2c_add_driver(&max11801_ts_driver);
+}
+
+static void __exit max11801_ts_exit(void)
+{
+	i2c_del_driver(&max11801_ts_driver);
+}
+
+module_init(max11801_ts_init);
+module_exit(max11801_ts_exit);
 
 MODULE_AUTHOR("Zhang Jiejing <jiejing.zhang@freescale.com>");
 MODULE_DESCRIPTION("Touchscreen driver for MAXI MAX11801 controller");
-- 
1.7.5.4

