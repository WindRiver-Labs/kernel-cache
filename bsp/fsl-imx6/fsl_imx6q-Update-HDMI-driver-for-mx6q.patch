From a8a1d0296d4fa5b0ed3d3d6f90c84e2bb13425fb Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 21 Jun 2013 17:29:08 +0800
Subject: [PATCH 17/38] fsl_imx6q: Update HDMI driver for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mfd/mxc-hdmi-core.c  |   23 +++-
 drivers/video/mxc_hdmi.c     |  169 ++++++++++++++++---
 sound/soc/codecs/mxc_hdmi.c  |  208 ++++++++++++++++++++++-
 sound/soc/imx/imx-hdmi-dai.c |   10 +-
 sound/soc/imx/imx-hdmi-dma.c |  381 +++++++++++++++++++++++++++++++-----------
 sound/soc/imx/imx-hdmi.c     |   61 ++++---
 6 files changed, 694 insertions(+), 158 deletions(-)

diff --git a/drivers/mfd/mxc-hdmi-core.c b/drivers/mfd/mxc-hdmi-core.c
index c533bd4..b1605c9 100644
--- a/drivers/mfd/mxc-hdmi-core.c
+++ b/drivers/mfd/mxc-hdmi-core.c
@@ -38,9 +38,10 @@
 #include <mach/ipu-v3.h>
 #include <mach/mxc_edid.h>
 #include "../mxc/ipu3/ipu_prv.h"
-#include <mach/hardware.h>
 #include <linux/mfd/mxc-hdmi-core.h>
 #include <linux/fsl_devices.h>
+#include <mach/hardware.h>
+#include <linux/mfd/mxc-hdmi-core.h>
 
 struct mxc_hdmi_data {
 	struct platform_device *pdev;
@@ -82,6 +83,7 @@ unsigned int hdmi_set_cable_state(unsigned int state)
 		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);
 	return 0;
 }
+EXPORT_SYMBOL(hdmi_set_cable_state);
 
 unsigned int hdmi_set_blank_state(unsigned int state)
 {
@@ -97,6 +99,7 @@ unsigned int hdmi_set_blank_state(unsigned int state)
 
 	return 0;
 }
+EXPORT_SYMBOL(hdmi_set_blank_state);
 
 #ifdef CONFIG_SND_SOC_IMX_HDMI
 static void hdmi_audio_abort_stream(struct snd_pcm_substream *substream)
@@ -126,6 +129,7 @@ int mxc_hdmi_abort_stream(void)
 
 	return 0;
 }
+EXPORT_SYMBOL(mxc_hdmi_abort_stream);
 
 int check_hdmi_state(void)
 {
@@ -142,6 +146,7 @@ int check_hdmi_state(void)
 
 	return ret;
 }
+EXPORT_SYMBOL(check_hdmi_state);
 
 #ifdef CONFIG_SND_SOC_IMX_HDMI
 int mxc_hdmi_register_audio(struct snd_pcm_substream *substream)
@@ -166,6 +171,7 @@ int mxc_hdmi_register_audio(struct snd_pcm_substream *substream)
 
 	return ret;
 }
+EXPORT_SYMBOL(mxc_hdmi_register_audio);
 #endif
 
 void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream)
@@ -176,6 +182,7 @@ void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream)
 	hdmi_audio_stream_playback = NULL;
 	spin_unlock_irqrestore(&hdmi_audio_lock, flags);
 }
+EXPORT_SYMBOL(mxc_hdmi_unregister_audio);
 
 u8 hdmi_readb(unsigned int reg)
 {
@@ -187,6 +194,7 @@ u8 hdmi_readb(unsigned int reg)
 
 	return value;
 }
+EXPORT_SYMBOL(hdmi_readb);
 
 #ifdef DEBUG
 static bool overflow_lo;
@@ -215,6 +223,7 @@ bool hdmi_check_overflow(void)
 	return false;
 }
 #endif
+EXPORT_SYMBOL(hdmi_check_overflow);
 
 void hdmi_writeb(u8 value, unsigned int reg)
 {
@@ -223,6 +232,7 @@ void hdmi_writeb(u8 value, unsigned int reg)
 	__raw_writeb(value, hdmi_base + reg);
 	hdmi_check_overflow();
 }
+EXPORT_SYMBOL(hdmi_writeb);
 
 void hdmi_mask_writeb(u8 data, unsigned int reg, u8 shift, u8 mask)
 {
@@ -230,6 +240,7 @@ void hdmi_mask_writeb(u8 data, unsigned int reg, u8 shift, u8 mask)
 	value |= (data << shift) & mask;
 	hdmi_writeb(value, reg);
 }
+EXPORT_SYMBOL(hdmi_mask_writeb);
 
 unsigned int hdmi_read4(unsigned int reg)
 {
@@ -239,6 +250,7 @@ unsigned int hdmi_read4(unsigned int reg)
 		(hdmi_readb(reg + 1) << 8) |
 		hdmi_readb(reg);
 }
+EXPORT_SYMBOL(hdmi_read4);
 
 void hdmi_write4(unsigned int value, unsigned int reg)
 {
@@ -248,6 +260,7 @@ void hdmi_write4(unsigned int value, unsigned int reg)
 	hdmi_writeb((value >> 16) & 0xff, reg + 2);
 	hdmi_writeb((value >> 24) & 0xff, reg + 3);
 }
+EXPORT_SYMBOL(hdmi_write4);
 
 static void initialize_hdmi_ih_mutes(void)
 {
@@ -527,6 +540,7 @@ void hdmi_init_clk_regenerator(void)
 		hdmi_set_clk_regenerator();
 	}
 }
+EXPORT_SYMBOL(hdmi_init_clk_regenerator);
 
 void hdmi_clk_regenerator_update_pixel_clock(u32 pixclock)
 {
@@ -535,17 +549,20 @@ void hdmi_clk_regenerator_update_pixel_clock(u32 pixclock)
 	pixel_clk_rate = PICOS2KHZ(pixclock) * 1000UL;
 	hdmi_set_clk_regenerator();
 }
+EXPORT_SYMBOL(hdmi_clk_regenerator_update_pixel_clock);
 
 void hdmi_set_dma_mode(unsigned int dma_running)
 {
 	hdmi_dma_running = dma_running;
 	hdmi_set_clk_regenerator();
 }
+EXPORT_SYMBOL(hdmi_set_dma_mode);
 
 void hdmi_set_sample_rate(unsigned int rate)
 {
 	sample_rate = rate;
 }
+EXPORT_SYMBOL(hdmi_set_sample_rate);
 
 void hdmi_set_edid_cfg(struct mxc_edid_cfg *cfg)
 {
@@ -555,6 +572,7 @@ void hdmi_set_edid_cfg(struct mxc_edid_cfg *cfg)
 	memcpy(&hdmi_core_edid_cfg, cfg, sizeof(struct mxc_edid_cfg));
 	spin_unlock_irqrestore(&edid_spinlock, flags);
 }
+EXPORT_SYMBOL(hdmi_set_edid_cfg);
 
 void hdmi_get_edid_cfg(struct mxc_edid_cfg *cfg)
 {
@@ -564,16 +582,19 @@ void hdmi_get_edid_cfg(struct mxc_edid_cfg *cfg)
 	memcpy(cfg, &hdmi_core_edid_cfg, sizeof(struct mxc_edid_cfg));
 	spin_unlock_irqrestore(&edid_spinlock, flags);
 }
+EXPORT_SYMBOL(hdmi_get_edid_cfg);
 
 void hdmi_set_registered(int registered)
 {
 	hdmi_core_init = registered;
 }
+EXPORT_SYMBOL(hdmi_set_registered);
 
 int hdmi_get_registered(void)
 {
 	return hdmi_core_init;
 }
+EXPORT_SYMBOL(hdmi_get_registered);
 
 static int mxc_hdmi_core_probe(struct platform_device *pdev)
 {
diff --git a/drivers/video/mxc_hdmi.c b/drivers/video/mxc_hdmi.c
index 069f309..34fb1b2 100644
--- a/drivers/video/mxc_hdmi.c
+++ b/drivers/video/mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,6 +58,7 @@
 
 #include <linux/mfd/mxc-hdmi-core.h>
 #include <mach/mxc_hdmi.h>
+#include <mach/hardware.h>
 
 #define DISPDRV_HDMI	"hdmi"
 #define HDMI_EDID_LEN		512
@@ -93,7 +94,7 @@
 static const struct fb_videomode vga_mode = {
 	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 48, 16, 33, 10, 96, 2, 0,
-	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, FB_MODE_IS_VESA,
 };
 
 static const struct fb_videomode xga_mode = {
@@ -147,9 +148,16 @@ struct hdmi_data_info {
 	unsigned int colorimetry;
 	unsigned int pix_repet_factor;
 	unsigned int hdcp_enable;
+	unsigned int rgb_out_enable;
 	struct hdmi_vmode video_mode;
 };
 
+struct hdmi_phy_reg_config {
+	/* HDMI PHY register config for pass HCT */
+	u16 reg_vlev;
+	u16 reg_cksymtx;
+};
+
 struct mxc_hdmi {
 	struct platform_device *pdev;
 	struct platform_device *core_pdev;
@@ -177,6 +185,8 @@ struct mxc_hdmi {
 	struct fb_videomode previous_mode;
 	struct fb_videomode previous_non_vga_mode;
 	bool requesting_vga_for_initialization;
+
+	struct hdmi_phy_reg_config phy_config;
 };
 
 struct i2c_client *hdmi_i2c;
@@ -184,6 +194,9 @@ struct i2c_client *hdmi_i2c;
 static bool hdmi_inited;
 
 extern const struct fb_videomode mxc_cea_mode[64];
+extern void mxc_hdmi_cec_handle(u16 cec_stat);
+
+static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event);
 
 #ifdef DEBUG
 static void dump_fb_videomode(struct fb_videomode *m)
@@ -244,6 +257,43 @@ static ssize_t mxc_hdmi_show_edid(struct device *dev,
 
 static DEVICE_ATTR(edid, S_IRUGO, mxc_hdmi_show_edid, NULL);
 
+static ssize_t mxc_hdmi_show_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->hdmi_data.rgb_out_enable == true)
+		strcpy(buf, "RGB out\n");
+	else
+		strcpy(buf, "YCbCr out\n");
+
+	return strlen(buf);
+}
+
+static ssize_t mxc_hdmi_store_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	hdmi->hdmi_data.rgb_out_enable = value;
+
+	/* Reconfig HDMI for output color space change */
+	mxc_hdmi_setup(hdmi, 0);
+
+	return count;
+}
+
+static DEVICE_ATTR(rgb_out_enable, S_IRUGO | S_IWUSR,
+				mxc_hdmi_show_rgb_out_enable,
+				mxc_hdmi_store_rgb_out_enable);
+
+
 /*!
  * this submodule is responsible for the video data synchronization.
  * for example, for RGB 4:4:4 input, the data map is defined as
@@ -1042,9 +1092,17 @@ static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
 	/* RESISTANCE TERM 133Ohm Cfg */
 	hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
 	/* PREEMP Cgf 0.00 */
-	hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);  /* CKSYMTXCTRL */
+	hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
 	/* TX/CK LVL 10 */
-	hdmi_phy_i2c_write(hdmi, 0x0210, 0x0E);  /* VLEVCTRL */
+	hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
+
+	/* Board specific setting for PHY register 0x09, 0x0e to pass HCT */
+	if (hdmi->phy_config.reg_cksymtx != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_cksymtx, 0x09);
+
+	if (hdmi->phy_config.reg_vlev != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_vlev, 0x0E);
+
 	/* REMOVE CLK TERM */
 	hdmi_phy_i2c_write(hdmi, 0x8000, 0x05);  /* CKCALCTRL */
 
@@ -1069,7 +1127,7 @@ static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
 	while (val == 0) {
 		udelay(1000);
 		if (msec-- == 0) {
-			dev_err(&hdmi->pdev->dev, "PHY PLL not locked\n");
+			dev_dbg(&hdmi->pdev->dev, "PHY PLL not locked\n");
 			return false;
 		}
 		val = hdmi_readb(HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
@@ -1372,7 +1430,7 @@ static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 	memcpy(edid_old, hdmi->edid, HDMI_EDID_LEN);
 
 	ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr, hdmi->edid,
-			    &hdmi->edid_cfg, hdmi->fbi);
+				&hdmi->edid_cfg, hdmi->fbi);
 
 	if (ret < 0)
 		return HDMI_EDID_FAIL;
@@ -1462,13 +1520,18 @@ static void mxc_hdmi_clear_overflow(void)
 	int count;
 	u8 val;
 
+	/* TMDS software reset */
+	hdmi_writeb((u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
+
 	val = hdmi_readb(HDMI_FC_INVIDCONF);
 
+	if (cpu_is_mx6dl()) {
+		 hdmi_writeb(val, HDMI_FC_INVIDCONF);
+		 return;
+	}
+
 	for (count = 0 ; count < 5 ; count++)
 		hdmi_writeb(val, HDMI_FC_INVIDCONF);
-
-	/* TMDS software reset */
-	hdmi_writeb((u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
 }
 
 static void hdmi_enable_overflow_interrupts(void)
@@ -1483,6 +1546,7 @@ static void hdmi_disable_overflow_interrupts(void)
 	pr_debug("%s\n", __func__);
 	hdmi_writeb(HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,
 		    HDMI_IH_MUTE_FC_STAT2);
+	hdmi_writeb(0xff, HDMI_FC_MASK2);
 }
 
 static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi)
@@ -1550,6 +1614,12 @@ static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
 	console_unlock();
 }
 
+static void  mxc_hdmi_default_edid_cfg(struct mxc_hdmi *hdmi)
+{
+	/* Default setting HDMI working in HDMI mode */
+	hdmi->edid_cfg.hdmi_cap = true;
+}
+
 static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 {
 	u32 i;
@@ -1565,6 +1635,11 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 
 	fb_destroy_modelist(&hdmi->fbi->modelist);
 
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&vga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
+
 	/*Add all no interlaced CEA mode to default modelist */
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		mode = &mxc_cea_mode[i];
@@ -1572,10 +1647,6 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 			fb_add_videomode(mode, &hdmi->fbi->modelist);
 	}
 
-	/*Add XGA and SXGA to default modelist */
-	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
-	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
-
 	console_unlock();
 }
 
@@ -1628,7 +1699,8 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi)
 				"%s: Video mode same as previous\n", __func__);
 		/* update fbi mode in case modelist is updated */
 		hdmi->fbi->mode = (struct fb_videomode *)mode;
-		mxc_hdmi_phy_init(hdmi);
+		/* update hdmi setting in case EDID data updated  */
+		mxc_hdmi_setup(hdmi, 0);
 	} else {
 		dev_dbg(&hdmi->pdev->dev, "%s: New video mode\n", __func__);
 		mxc_hdmi_set_mode_to_vga_dvi(hdmi);
@@ -1651,6 +1723,13 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 	/* HDMI Initialization Step C */
 	edid_status = mxc_hdmi_read_edid(hdmi);
 
+	/* Read EDID again if first EDID read failed */
+	if (edid_status == HDMI_EDID_NO_MODES ||
+			edid_status == HDMI_EDID_FAIL) {
+		dev_info(&hdmi->pdev->dev, "Read EDID again\n");
+		edid_status = mxc_hdmi_read_edid(hdmi);
+	}
+
 	/* HDMI Initialization Steps D, E, F */
 	switch (edid_status) {
 	case HDMI_EDID_SUCCESS:
@@ -1661,8 +1740,10 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 	case HDMI_EDID_SAME:
 		break;
 
-	case HDMI_EDID_NO_MODES:
 	case HDMI_EDID_FAIL:
+		mxc_hdmi_default_edid_cfg(hdmi);
+		/* No break here  */
+	case HDMI_EDID_NO_MODES:
 	default:
 		mxc_hdmi_default_modelist(hdmi);
 		break;
@@ -1730,7 +1811,11 @@ static void hotplug_worker(struct work_struct *work)
 
 			sprintf(event_string, "EVENT=plugin");
 			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+#ifdef CONFIG_MXC_HDMI_CEC
+			mxc_hdmi_cec_handle(0x80);
+#endif
 			hdmi_set_cable_state(1);
+
 		} else if (!(phy_int_pol & HDMI_PHY_HPD)) {
 			/* Plugout event */
 			dev_dbg(&hdmi->pdev->dev, "EVENT=plugout\n");
@@ -1745,6 +1830,9 @@ static void hotplug_worker(struct work_struct *work)
 
 			sprintf(event_string, "EVENT=plugout");
 			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+#ifdef CONFIG_MXC_HDMI_CEC
+			mxc_hdmi_cec_handle(0x100);
+#endif
 
 		} else
 			dev_dbg(&hdmi->pdev->dev, "EVENT=none?\n");
@@ -1865,7 +1953,12 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 		hdmi->hdmi_data.video_mode.mDVI = true;
 	} else {
 		dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
-		hdmi->hdmi_data.video_mode.mDVI = false;
+		if (hdmi->edid_cfg.hdmi_cap)
+			hdmi->hdmi_data.video_mode.mDVI = false;
+		else {
+			dev_dbg(&hdmi->pdev->dev, "CEA mode vic=%d work in DVI\n", hdmi->vic);
+			hdmi->hdmi_data.video_mode.mDVI = true;
+		}
 	}
 
 	if ((hdmi->vic == 6) || (hdmi->vic == 7) ||
@@ -1894,14 +1987,15 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	hdmi->hdmi_data.enc_in_format = RGB;
 
 	hdmi->hdmi_data.enc_out_format = RGB;
-	/*DVI mode not support non-RGB */
-	if (!hdmi->hdmi_data.video_mode.mDVI)
-		if (hdmi->edid_cfg.hdmi_cap) {
-			if (hdmi->edid_cfg.cea_ycbcr444)
-				hdmi->hdmi_data.enc_out_format = YCBCR444;
-			else if (hdmi->edid_cfg.cea_ycbcr422)
-				hdmi->hdmi_data.enc_out_format = YCBCR422_8BITS;
-		}
+
+	/* YCbCr only enabled in HDMI mode */
+	if (!hdmi->hdmi_data.video_mode.mDVI &&
+		!hdmi->hdmi_data.rgb_out_enable) {
+		if (hdmi->edid_cfg.cea_ycbcr444)
+			hdmi->hdmi_data.enc_out_format = YCBCR444;
+		else if (hdmi->edid_cfg.cea_ycbcr422)
+			hdmi->hdmi_data.enc_out_format = YCBCR422_8BITS;
+	}
 
 	/* IPU not support depth color output */
 	hdmi->hdmi_data.enc_color_depth = 8;
@@ -2067,6 +2161,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	int ret = 0;
 	u32 i;
 	const struct fb_videomode *mode;
+	struct fb_videomode m;
 	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
 	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
 	int irq = platform_get_irq(hdmi->pdev, 0);
@@ -2110,6 +2205,10 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	if (plat->init)
 		plat->init(mxc_hdmi_ipu_id, mxc_hdmi_disp_id);
 
+	/* Specific phy config */
+	hdmi->phy_config.reg_cksymtx = plat->phy_reg_cksymtx;
+	hdmi->phy_config.reg_vlev = plat->phy_reg_vlev;
+
 	hdmi->hdmi_isfr_clk = clk_get(&hdmi->pdev->dev, "hdmi_isfr_clk");
 	if (IS_ERR(hdmi->hdmi_isfr_clk)) {
 		ret = PTR_ERR(hdmi->hdmi_isfr_clk);
@@ -2180,6 +2279,21 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	console_unlock();
 
+	/* Find a nearest mode in default modelist */
+	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	dump_fb_videomode(&m);
+
+	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
+	if (!mode) {
+		pr_err("%s: could not find mode in modelist\n", __func__);
+		return -1;
+	}
+
+	fb_videomode_to_var(&hdmi->fbi->var, mode);
+
+	/* Default setting HDMI working in HDMI mode*/
+	hdmi->edid_cfg.hdmi_cap = true;
+
 	INIT_DELAYED_WORK(&hdmi->hotplug_work, hotplug_worker);
 
 	/* Configure registers related to HDMI interrupt
@@ -2196,6 +2310,9 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	memset(&hdmi->hdmi_data, 0, sizeof(struct hdmi_data_info));
 
+	/* Default HDMI working in RGB mode */
+	hdmi->hdmi_data.rgb_out_enable = true;
+
 	ret = request_irq(irq, mxc_hdmi_hotplug, IRQF_SHARED,
 			  dev_name(&hdmi->pdev->dev), hdmi);
 	if (ret < 0) {
@@ -2216,6 +2333,10 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	if (ret < 0)
 		dev_warn(&hdmi->pdev->dev,
 			"cound not create sys node for edid\n");
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_rgb_out_enable);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for rgb out enable\n");
 
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 
diff --git a/sound/soc/codecs/mxc_hdmi.c b/sound/soc/codecs/mxc_hdmi.c
index 8c78676..77c45fe 100644
--- a/sound/soc/codecs/mxc_hdmi.c
+++ b/sound/soc/codecs/mxc_hdmi.c
@@ -2,6 +2,12 @@
  * MXC HDMI ALSA Soc Codec Driver
  *
  * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * Some code from patch_hdmi.c
+ *  Copyright (c) 2008-2010 Intel Corporation. All rights reserved.
+ *  Copyright (c) 2006 ATI Technologies Inc.
+ *  Copyright (c) 2008 NVIDIA Corp.  All rights reserved.
+ *  Copyright (c) 2008 Wei Ni <wni@nvidia.com>
  */
 
 /*
@@ -88,6 +94,181 @@ static void dumpregs(void)
 static void dumpregs(void) {}
 #endif
 
+enum cea_speaker_placement {
+	FL  = (1 <<  0),	/* Front Left           */
+	FC  = (1 <<  1),	/* Front Center         */
+	FR  = (1 <<  2),	/* Front Right          */
+	FLC = (1 <<  3),	/* Front Left Center    */
+	FRC = (1 <<  4),	/* Front Right Center   */
+	RL  = (1 <<  5),	/* Rear Left            */
+	RC  = (1 <<  6),	/* Rear Center          */
+	RR  = (1 <<  7),	/* Rear Right           */
+	RLC = (1 <<  8),	/* Rear Left Center     */
+	RRC = (1 <<  9),	/* Rear Right Center    */
+	LFE = (1 << 10),	/* Low Frequency Effect */
+	FLW = (1 << 11),	/* Front Left Wide      */
+	FRW = (1 << 12),	/* Front Right Wide     */
+	FLH = (1 << 13),	/* Front Left High      */
+	FCH = (1 << 14),	/* Front Center High    */
+	FRH = (1 << 15),	/* Front Right High     */
+	TC  = (1 << 16),	/* Top Center           */
+};
+
+/*
+ * EDID SA bits in the CEA Speaker Allocation data block
+ */
+static int edid_speaker_allocation_bits[] = {
+	[0] = FL | FR,
+	[1] = LFE,
+	[2] = FC,
+	[3] = RL | RR,
+	[4] = RC,
+	[5] = FLC | FRC,
+	[6] = RLC | RRC,
+	[7] = FLW | FRW,
+	[8] = FLH | FRH,
+	[9] = TC,
+	[10] = FCH,
+};
+
+struct cea_channel_speaker_allocation {
+	int ca_index;
+	int speakers[8];
+
+	/* derived values, just for convenience */
+	int channels;
+	int spk_mask;
+};
+
+/*
+ * This is an ordered list!
+ *
+ * The preceding ones have better chances to be selected by
+ * hdmi_channel_allocation().
+ */
+static struct cea_channel_speaker_allocation channel_allocations[] = {
+/*			  channel:   7     6    5    4    3     2    1    0  */
+{ .ca_index = 0x00,  .speakers = {   0,    0,   0,   0,   0,    0,  FR,  FL } },
+				 /* 2.1 */
+{ .ca_index = 0x01,  .speakers = {   0,    0,   0,   0,   0,  LFE,  FR,  FL } },
+				 /* Dolby Surround */
+{ .ca_index = 0x02,  .speakers = {   0,    0,   0,   0,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x03,  .speakers = {   0,    0,   0,   0,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x04,  .speakers = {   0,    0,   0,  RC,   0,    0,  FR,  FL } },
+{ .ca_index = 0x05,  .speakers = {   0,    0,   0,  RC,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x06,  .speakers = {   0,    0,   0,  RC,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x07,  .speakers = {   0,    0,   0,  RC,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x08,  .speakers = {   0,    0,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x09,  .speakers = {   0,    0,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x0a,  .speakers = {   0,    0,  RR,  RL,  FC,    0,  FR,  FL } },
+				 /* surround51 */
+{ .ca_index = 0x0b,  .speakers = {   0,    0,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x0c,  .speakers = {   0,   RC,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x0d,  .speakers = {   0,   RC,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x0e,  .speakers = {   0,   RC,  RR,  RL,  FC,    0,  FR,  FL } },
+				 /* 6.1 */
+{ .ca_index = 0x0f,  .speakers = {   0,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x10,  .speakers = { RRC,  RLC,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x11,  .speakers = { RRC,  RLC,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x12,  .speakers = { RRC,  RLC,  RR,  RL,  FC,    0,  FR,  FL } },
+				 /* surround71 */
+{ .ca_index = 0x13,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x14,  .speakers = { FRC,  FLC,   0,   0,   0,    0,  FR,  FL } },
+{ .ca_index = 0x15,  .speakers = { FRC,  FLC,   0,   0,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x16,  .speakers = { FRC,  FLC,   0,   0,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x17,  .speakers = { FRC,  FLC,   0,   0,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x18,  .speakers = { FRC,  FLC,   0,  RC,   0,    0,  FR,  FL } },
+{ .ca_index = 0x19,  .speakers = { FRC,  FLC,   0,  RC,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x1a,  .speakers = { FRC,  FLC,   0,  RC,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x1b,  .speakers = { FRC,  FLC,   0,  RC,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x1c,  .speakers = { FRC,  FLC,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x1d,  .speakers = { FRC,  FLC,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x1e,  .speakers = { FRC,  FLC,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x1f,  .speakers = { FRC,  FLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x20,  .speakers = {   0,  FCH,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x21,  .speakers = {   0,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x22,  .speakers = {  TC,    0,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x23,  .speakers = {  TC,    0,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x24,  .speakers = { FRH,  FLH,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x25,  .speakers = { FRH,  FLH,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x26,  .speakers = { FRW,  FLW,  RR,  RL,   0,    0,  FR,  FL } },
+{ .ca_index = 0x27,  .speakers = { FRW,  FLW,  RR,  RL,   0,  LFE,  FR,  FL } },
+{ .ca_index = 0x28,  .speakers = {  TC,   RC,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x29,  .speakers = {  TC,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x2a,  .speakers = { FCH,   RC,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x2b,  .speakers = { FCH,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x2c,  .speakers = {  TC,  FCH,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x2d,  .speakers = {  TC,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x2e,  .speakers = { FRH,  FLH,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x2f,  .speakers = { FRH,  FLH,  RR,  RL,  FC,  LFE,  FR,  FL } },
+{ .ca_index = 0x30,  .speakers = { FRW,  FLW,  RR,  RL,  FC,    0,  FR,  FL } },
+{ .ca_index = 0x31,  .speakers = { FRW,  FLW,  RR,  RL,  FC,  LFE,  FR,  FL } },
+};
+
+/*
+ * Compute derived values in channel_allocations[].
+ */
+static void init_channel_allocations(void)
+{
+	int i, j;
+	struct cea_channel_speaker_allocation *p;
+
+	for (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {
+		p = channel_allocations + i;
+		p->channels = 0;
+		p->spk_mask = 0;
+		for (j = 0; j < ARRAY_SIZE(p->speakers); j++)
+			if (p->speakers[j]) {
+				p->channels++;
+				p->spk_mask |= p->speakers[j];
+			}
+	}
+}
+
+/*
+ * The transformation takes two steps:
+ *
+ * speaker_alloc => (edid_speaker_allocation_bits[]) => spk_mask
+ * spk_mask      => (channel_allocations[])         => CA
+ *
+ * TODO: it could select the wrong CA from multiple candidates.
+*/
+static int hdmi_channel_allocation(int channels)
+{
+	int i;
+	int ca = 0;
+	int spk_mask = 0;
+
+	/*
+	 * CA defaults to 0 for basic stereo audio
+	 */
+	if (channels <= 2)
+		return 0;
+
+	/*
+	 * expand EDID's speaker allocation mask
+	 *
+	 * EDID tells the speaker mask in a compact(paired) form,
+	 * expand EDID's notions to match the ones used by Audio InfoFrame.
+	 */
+	for (i = 0; i < ARRAY_SIZE(edid_speaker_allocation_bits); i++) {
+		if (edid_cfg.speaker_alloc & (1 << i))
+			spk_mask |= edid_speaker_allocation_bits[i];
+	}
+
+	/* search for the first working match in the CA table */
+	for (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {
+		if (channels == channel_allocations[i].channels &&
+		    (spk_mask & channel_allocations[i].spk_mask) ==
+				channel_allocations[i].spk_mask) {
+			ca = channel_allocations[i].ca_index;
+			break;
+		}
+	}
+
+	return ca;
+}
+
 static void hdmi_set_audio_flat(u8 value)
 {
 	/* Indicates the subpacket represents a flatline sample */
@@ -103,12 +284,25 @@ static void hdmi_set_layout(unsigned int channels)
 			HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK);
 }
 
-static void hdmi_set_audio_infoframe(void)
+static void hdmi_set_audio_infoframe(unsigned int channels)
 {
-	/* set to 0: means "refer to stream header" */
-	hdmi_writeb(0x00, HDMI_FC_AUDICONF0);
-	hdmi_writeb(0x00, HDMI_FC_AUDICONF1);
-	hdmi_writeb(0x00, HDMI_FC_AUDICONF2);
+	unsigned char audiconf0, audiconf2;
+
+	/* From CEA-861-D spec:
+	 * NOTE: HDMI requires the CT, SS and SF fields to be set to 0 ("Refer
+	 * to Stream Header") as these items are carried in the audio stream.
+	 *
+	 * So we only set the CC and CA fields.
+	 */
+	audiconf0 = ((channels - 1) << HDMI_FC_AUDICONF0_CC_OFFSET) &
+		    HDMI_FC_AUDICONF0_CC_MASK;
+
+	audiconf2 = hdmi_channel_allocation(channels);
+
+	hdmi_writeb(audiconf0, HDMI_FC_AUDICONF0);
+	hdmi_writeb(0, HDMI_FC_AUDICONF1);
+	hdmi_writeb(audiconf2, HDMI_FC_AUDICONF2);
+	hdmi_writeb(0, HDMI_FC_AUDICONF3);
 }
 
 static int cea_audio_rates[HDMI_MAX_RATES] = {
@@ -242,7 +436,6 @@ static int mxc_hdmi_codec_startup(struct snd_pcm_substream *substream,
 		return ret;
 
 	hdmi_set_audio_flat(0);
-	hdmi_set_audio_infoframe();
 
 	return 0;
 }
@@ -252,6 +445,7 @@ static int mxc_hdmi_codec_prepare(struct snd_pcm_substream *substream,
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
+	hdmi_set_audio_infoframe(runtime->channels);
 	hdmi_set_layout(runtime->channels);
 	hdmi_set_sample_rate(runtime->rate);
 	dumpregs();
@@ -371,6 +565,8 @@ static int mxc_hdmi_codec_soc_probe(struct snd_soc_codec *codec)
 	if (ret)
 		goto e_add_ctrls;
 
+	init_channel_allocations();
+
 	snd_soc_codec_set_drvdata(codec, hdmi_priv);
 
 	return 0;
diff --git a/sound/soc/imx/imx-hdmi-dai.c b/sound/soc/imx/imx-hdmi-dai.c
index 6993e5c..06805f3 100644
--- a/sound/soc/imx/imx-hdmi-dai.c
+++ b/sound/soc/imx/imx-hdmi-dai.c
@@ -1,7 +1,7 @@
 /*
  * ALSA SoC HDMI Audio Layer for MXS
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * Based on stmp3xxx_spdif_dai.c
  * Vladimir Barinov <vbarinov@embeddedalley.com>
@@ -42,8 +42,10 @@ static int imx_hdmi_dai_probe(struct platform_device *pdev)
 	struct imx_hdmi *hdmi_data;
 	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		dev_err(&pdev->dev, "Failed: Load HDMI-video first.\n");
+		return -ENODEV;
+	}
 
 	hdmi_data = kzalloc(sizeof(*hdmi_data), GFP_KERNEL);
 	if (!hdmi_data)
@@ -81,7 +83,7 @@ static int imx_hdmi_dai_probe(struct platform_device *pdev)
 		platform_device_put(hdmi_data->soc_platform_pdev);
 		goto e_pdev_add;
 	}
-	printk("imx_hdmi_dai_probe probe finish\n");
+
 	return 0;
 e_pdev_add:
 	platform_device_put(hdmi_data->soc_platform_pdev);
diff --git a/sound/soc/imx/imx-hdmi-dma.c b/sound/soc/imx/imx-hdmi-dma.c
index e79fb41..7040954 100644
--- a/sound/soc/imx/imx-hdmi-dma.c
+++ b/sound/soc/imx/imx-hdmi-dma.c
@@ -36,12 +36,35 @@
 #include <mach/mxc_hdmi.h>
 #include "imx-hdmi.h"
 
+#include <linux/dmaengine.h>
+#include <mach/dma.h>
+#include <linux/iram_alloc.h>
+#include <linux/io.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
 
 #define HDMI_DMA_BURST_UNSPECIFIED_LEGNTH	0
 #define HDMI_DMA_BURST_INCR4			1
 #define HDMI_DMA_BURST_INCR8			2
 #define HDMI_DMA_BURST_INCR16			3
 
+
+
+#define HDMI_BASE_ADDR 0x00120000
+
+struct hdmi_sdma_script_data {
+	int control_reg_addr;
+	int status_reg_addr;
+	int dma_start_addr;
+	u32 buffer[20];
+};
+
+struct imx_hdmi_sdma_params {
+	u32 buffer_num;
+	dma_addr_t phyaddr;
+};
+
+
 struct imx_hdmi_dma_runtime_data {
 	struct snd_pcm_substream *tx_substream;
 
@@ -71,6 +94,15 @@ struct imx_hdmi_dma_runtime_data {
 
 	bool tx_active;
 	spinlock_t irq_lock;
+
+	/*SDMA part*/
+	unsigned int dma_event;
+	struct dma_chan *dma_channel;
+	struct imx_dma_data dma_data;
+	struct hdmi_sdma_script_data *hdmi_sdma_t;
+	dma_addr_t phy_hdmi_sdma_t;
+	struct dma_async_tx_descriptor *desc;
+	struct imx_hdmi_sdma_params sdma_params;
 };
 
 /* bit 0:0:0:b:p(0):c:(u)0:(v)0*/
@@ -87,6 +119,7 @@ void hdmi_dma_copy_24_neon_fast(unsigned int *src, unsigned int *dst,
 			int samples);
 
 hdmi_audio_header_t iec_header;
+EXPORT_SYMBOL(iec_header);
 
 /*
  * Note that the period size for DMA != period size for ALSA because the
@@ -509,12 +542,13 @@ static void hdmi_dma_copy_24(u32 *src, u32 *dest, int framecount, int channelcou
 #endif
 
 static void hdmi_dma_mmap_copy(struct snd_pcm_substream *substream,
-			       int offset, int count)
+				int offset, int count)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
 	u32 framecount;
-	u32 *src32, *dest;
+/*	u32 *src32; */
+	u32 *dest;
 	u16 *src16;
 
 	framecount =  count/(rtd->sample_align * rtd->channels);
@@ -544,12 +578,47 @@ static void hdmi_dma_mmap_copy(struct snd_pcm_substream *substream,
 	}
 }
 
+static void hdmi_sdma_isr(void *data)
+{
+	struct imx_hdmi_dma_runtime_data *rtd = data;
+	struct snd_pcm_substream *substream = rtd->tx_substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long offset, count, appl_bytes;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtd->irq_lock, flags);
+
+	if (runtime && runtime->dma_area && rtd->tx_active) {
+
+		rtd->offset += rtd->period_bytes;
+		rtd->offset %= rtd->period_bytes * rtd->periods;
+
+		/* For mmap access, need to copy data from dma_buffer
+		 * to hw_buffer and add the frame info. */
+		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
+			appl_bytes = frames_to_bytes(runtime,
+						runtime->status->hw_ptr);
+			appl_bytes += 2 * rtd->period_bytes;
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->period_bytes;
+			hdmi_dma_mmap_copy(substream, offset, count);
+		}
+		snd_pcm_period_elapsed(substream);
+
+	}
+
+	spin_unlock_irqrestore(&rtd->irq_lock, flags);
+
+	return;
+}
+
+
 static irqreturn_t hdmi_dma_isr(int irq, void *dev_id)
 {
 	struct imx_hdmi_dma_runtime_data *rtd = dev_id;
 	struct snd_pcm_substream *substream = rtd->tx_substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long offset,  count, space_to_end, appl_bytes;
+	unsigned long offset, count, appl_bytes;
 	unsigned long flags;
 	unsigned int status;
 
@@ -567,36 +636,11 @@ static irqreturn_t hdmi_dma_isr(int irq, void *dev_id)
 		 * to hw_buffer and add the frame info. */
 		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
 			appl_bytes = frames_to_bytes(runtime,
-						runtime->control->appl_ptr);
-
-			if (rtd->appl_bytes > appl_bytes) {
-				if (appl_bytes > rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-				else
-					rtd->appl_bytes = 0;
-			} else {
-				if ((appl_bytes - rtd->appl_bytes) >
-						rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-
-			}
-
-			offset = rtd->appl_bytes % rtd->buffer_bytes;
-			space_to_end = rtd->buffer_bytes - offset;
-			count = appl_bytes - rtd->appl_bytes;
-			if (count > rtd->buffer_bytes)
-				count = rtd->buffer_bytes;
-
-			rtd->appl_bytes = appl_bytes;
-
-			if (count <= space_to_end) {
-				hdmi_dma_mmap_copy(substream, offset, count);
-			} else {
-				hdmi_dma_mmap_copy(substream, offset, space_to_end);
-				hdmi_dma_mmap_copy(substream, 0, count - space_to_end);
-			}
+						runtime->status->hw_ptr);
+			appl_bytes += 2 * rtd->period_bytes;
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->period_bytes;
+			hdmi_dma_mmap_copy(substream, offset, count);
 		}
 		snd_pcm_period_elapsed(substream);
 
@@ -671,25 +715,45 @@ static void hdmi_dma_enable_channels(int channels)
 	}
 }
 
-static void hdmi_dma_configure_dma(int channels)
+static void hdmi_dma_set_thrsld_incrtype(int channels)
 {
-	hdmi_dma_enable_hlock(1);
-
-	switch (channels) {
-	case 2:
-		hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
-		hdmi_writeb(126, HDMI_AHB_DMA_THRSLD);
+	int rev = hdmi_readb(HDMI_REVISION_ID);
+
+	switch (rev) {
+	case 0x0a:
+		{
+			switch (channels) {
+			case 2:
+				hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
+				hdmi_writeb(126, HDMI_AHB_DMA_THRSLD);
+				break;
+			case 4:
+			case 6:
+			case 8:
+				hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
+				hdmi_writeb(124, HDMI_AHB_DMA_THRSLD);
+				break;
+			default:
+				pr_debug("unsupport channel!\r\n");
+			}
+		}
 		break;
-	case 4:
-	case 6:
-	case 8:
-		hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
-		hdmi_writeb(124, HDMI_AHB_DMA_THRSLD);
+	case 0x1a:
+		hdmi_writeb(128, HDMI_AHB_DMA_THRSLD);
+		hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR8);
 		break;
 	default:
-		pr_err("%s %dunsupport channel!\r\n", __func__, __LINE__);
+		pr_debug("error:unrecognized hdmi controller!\r\n");
+		break;
 	}
 
+	pr_debug("HDMI_AHB_DMA_THRSLD          0x%02x\n", hdmi_readb(HDMI_AHB_DMA_THRSLD));
+}
+
+static void hdmi_dma_configure_dma(int channels)
+{
+	hdmi_dma_enable_hlock(1);
+	hdmi_dma_set_thrsld_incrtype(channels);
 	hdmi_dma_enable_channels(channels);
 }
 
@@ -812,11 +876,122 @@ static int hdmi_dma_copy(struct snd_pcm_substream *substream, int channel,
 	return 0;
 }
 
+static bool hdmi_filter(struct dma_chan *chan, void *param)
+{
+
+	if (!imx_dma_is_general_purpose(chan))
+		return false;
+
+	chan->private = param;
+	return true;
+}
+
+
+static int hdmi_init_sdma_buffer(struct imx_hdmi_dma_runtime_data *params)
+{
+	int i;
+	u32 *tmp_addr1, *tmp_addr2;
+
+	if (!params->hdmi_sdma_t) {
+		dev_err(&params->dma_channel->dev->device,
+				"hdmi private addr invalid!!!\n");
+		return -EINVAL;
+	}
+
+	params->hdmi_sdma_t->control_reg_addr =
+			HDMI_BASE_ADDR + HDMI_AHB_DMA_START;
+	params->hdmi_sdma_t->status_reg_addr =
+			HDMI_BASE_ADDR + HDMI_IH_AHBDMAAUD_STAT0;
+	params->hdmi_sdma_t->dma_start_addr =
+			HDMI_BASE_ADDR + HDMI_AHB_DMA_STRADDR0;
+
+	tmp_addr1 = (u32 *)params->hdmi_sdma_t + 3;
+	tmp_addr2 = (u32 *)params->hdmi_sdma_t + 4;
+	for (i = 0; i < params->sdma_params.buffer_num; i++) {
+		*tmp_addr1 = params->hw_buffer.addr +
+				i * params->period_bytes * params->buffer_ratio;
+		*tmp_addr2 = *tmp_addr1 + params->dma_period_bytes - 1;
+		tmp_addr1 += 2;
+		tmp_addr2 += 2;
+	}
+
+	return 0;
+}
+
+static int hdmi_sdma_alloc(struct imx_hdmi_dma_runtime_data *params)
+{
+	dma_cap_mask_t mask;
+
+	params->dma_data.peripheral_type = IMX_DMATYPE_HDMI;
+	params->dma_data.priority = DMA_PRIO_HIGH;
+	params->dma_data.dma_request = MX6Q_DMA_REQ_EXT_DMA_REQ_0;
+	params->dma_data.private = &params->sdma_params;
+
+	/* Try to grab a DMA channel */
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	params->dma_channel = dma_request_channel(
+			mask, hdmi_filter, &params->dma_data);
+	if (params->dma_channel == NULL) {
+		dev_err(&params->dma_channel->dev->device,
+			"HDMI:unable to alloc dma_channel channel\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int hdmi_sdma_config(struct imx_hdmi_dma_runtime_data *params)
+{
+	struct dma_slave_config slave_config;
+	int ret;
+
+	slave_config.direction = DMA_TRANS_NONE;
+	ret = dmaengine_slave_config(params->dma_channel, &slave_config);
+	if (ret) {
+		dev_err(&params->dma_channel->dev->device,
+					"%s failed\r\n", __func__);
+		return -EINVAL;
+	}
+
+	params->desc =
+		params->dma_channel->device->device_prep_dma_cyclic(
+					params->dma_channel, 0,
+					0,
+					0,
+					DMA_TRANS_NONE,
+					NULL);
+	if (!params->desc) {
+		dev_err(&params->dma_channel->dev->device,
+				"cannot prepare slave dma\n");
+		return -EINVAL;
+	}
+
+	params->desc->callback = hdmi_sdma_isr;
+	params->desc->callback_param = (void *)hdmi_dma_priv;
+
+	return 0;
+}
+
+
+
+static int hdmi_dma_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *params = runtime->private_data;
+	if (hdmi_SDMA_check() && (params->dma_channel)) {
+		dma_release_channel(params->dma_channel);
+		params->dma_channel = NULL;
+	}
+	return 0;
+}
+
 static int hdmi_dma_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+	int err;
 
 	rtd->buffer_bytes = params_buffer_bytes(params);
 	rtd->periods = params_periods(params);
@@ -847,6 +1022,23 @@ static int hdmi_dma_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	rtd->dma_period_bytes = rtd->period_bytes * rtd->buffer_ratio;
+	if (hdmi_SDMA_check()) {
+		rtd->sdma_params.buffer_num = rtd->periods;
+		rtd->sdma_params.phyaddr = rtd->phy_hdmi_sdma_t;
+
+		/* Allocate SDMA channel for HDMI */
+		err = hdmi_init_sdma_buffer(rtd);
+		if (err)
+			return err;
+
+		err = hdmi_sdma_alloc(rtd);
+		if (err)
+			return err;
+
+		err = hdmi_sdma_config(rtd);
+		if (err)
+			return err;
+	}
 
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 
@@ -870,6 +1062,7 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
 	unsigned long offset,  count, space_to_end, appl_bytes;
+	unsigned int status;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -880,36 +1073,10 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		rtd->frame_idx = 0;
 		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
 			appl_bytes = frames_to_bytes(runtime,
-						runtime->control->appl_ptr);
-			/* If resume, the rtd->appl_bytes may stil
-			 * keep the old value but the control->
-			 * appl_ptr is clear. Reset it if this
-			 * misalignment happens*/
-			if (rtd->appl_bytes > appl_bytes) {
-				if (appl_bytes > rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-				else
-					rtd->appl_bytes = 0;
-			} else {
-				if ((appl_bytes - rtd->appl_bytes) >
-						rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-
-			}
-
-			offset = rtd->appl_bytes % rtd->buffer_bytes;
+						runtime->status->hw_ptr);
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->buffer_bytes;
 			space_to_end = rtd->buffer_bytes - offset;
-			count = appl_bytes - rtd->appl_bytes;
-
-			if (count > rtd->buffer_bytes) {
-				pr_err("Error Count,ring buffer size[%ld], count[%ld]!\n",
-						rtd->buffer_bytes, count);
-				return -EINVAL;
-			}
-
-			rtd->appl_bytes = appl_bytes;
 
 			if (count <= space_to_end) {
 				hdmi_dma_mmap_copy(substream, offset, count);
@@ -919,17 +1086,21 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 				hdmi_dma_mmap_copy(substream,
 						0, count - space_to_end);
 			}
-
 		}
 		dumpregs();
 
 		hdmi_fifo_reset();
 		udelay(1);
 
+		status = hdmi_dma_get_irq_status();
+		hdmi_dma_clear_irq_status(status);
+
 		hdmi_dma_priv->tx_active = true;
 		hdmi_dma_start();
 		hdmi_dma_irq_mask(0);
 		hdmi_set_dma_mode(1);
+		if (hdmi_SDMA_check())
+			dmaengine_submit(rtd->desc);
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -939,6 +1110,8 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		hdmi_dma_stop();
 		hdmi_set_dma_mode(0);
 		hdmi_dma_irq_mask(1);
+		if (hdmi_SDMA_check())
+			dmaengine_terminate_all(rtd->dma_channel);
 		break;
 
 	default:
@@ -985,7 +1158,10 @@ static void hdmi_dma_irq_enable(struct imx_hdmi_dma_runtime_data *rtd)
 	spin_lock_irqsave(&hdmi_dma_priv->irq_lock, flags);
 
 	hdmi_dma_clear_irq_status(0xff);
-	hdmi_dma_irq_mute(0);
+	if (hdmi_SDMA_check())
+		hdmi_dma_irq_mute(1);
+	else
+		hdmi_dma_irq_mute(0);
 	hdmi_dma_irq_mask(0);
 
 	hdmi_mask(0);
@@ -1062,6 +1238,7 @@ static struct snd_pcm_ops imx_hdmi_dma_pcm_ops = {
 	.close		= hdmi_dma_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= hdmi_dma_hw_params,
+	.hw_free	= hdmi_dma_hw_free,
 	.trigger	= hdmi_dma_trigger,
 	.pointer	= hdmi_dma_pointer,
 	.copy		= hdmi_dma_copy,
@@ -1079,12 +1256,9 @@ static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 					   HDMI_PCM_BUF_SIZE,
 					   &buf->addr, GFP_KERNEL);
 
-	if (!buf->area) {
-		printk("Dma_alloc_writecombine: alloc buffer fail\n");
-		return -ENOMEM;
-	}
-
 	buf->bytes = HDMI_PCM_BUF_SIZE;
+	if (!buf->area)
+		return -ENOMEM;
 
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
@@ -1108,11 +1282,10 @@ static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 static u64 hdmi_dmamask = DMA_BIT_MASK(32);
 
 static int imx_hdmi_dma_pcm_new(struct snd_soc_pcm_runtime *rtd)
-
 {
+	int ret = 0;
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_pcm *pcm = rtd->pcm;
-	int ret = 0;
 
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &hdmi_dmamask;
@@ -1145,7 +1318,7 @@ static void imx_hdmi_dma_pcm_free(struct snd_pcm *pcm)
 			continue;
 
 		dma_free_writecombine(pcm->card->dev, buf->bytes,
-				      buf->area, buf->addr);
+					buf->area, buf->addr);
 		buf->area = NULL;
 	}
 
@@ -1153,7 +1326,7 @@ static void imx_hdmi_dma_pcm_free(struct snd_pcm *pcm)
 	buf = &hdmi_dma_priv->hw_buffer;
 	if (buf->area) {
 		dma_free_writecombine(pcm->card->dev, buf->bytes,
-				      buf->area, buf->addr);
+					buf->area, buf->addr);
 		buf->area = NULL;
 	}
 }
@@ -1172,7 +1345,17 @@ static int __devinit imx_soc_platform_probe(struct platform_device *pdev)
 	hdmi_dma_priv = kzalloc(sizeof(*hdmi_dma_priv), GFP_KERNEL);
 	if (hdmi_dma_priv == NULL)
 		return -ENOMEM;
-	/*To alloc a buffer non cacheable for hdmi script use*/
+
+	if (hdmi_SDMA_check()) {
+		/*To alloc a buffer non cacheable for hdmi script use*/
+		hdmi_dma_priv->hdmi_sdma_t =
+			dma_alloc_coherent(NULL,
+				sizeof(struct hdmi_sdma_script_data),
+				&hdmi_dma_priv->phy_hdmi_sdma_t,
+				GFP_KERNEL);
+		if (hdmi_dma_priv->hdmi_sdma_t == NULL)
+			return -ENOMEM;
+	}
 
 	hdmi_dma_priv->tx_active = false;
 	spin_lock_init(&hdmi_dma_priv->irq_lock);
@@ -1193,19 +1376,21 @@ static int __devinit imx_soc_platform_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Unable to get HDMI ahb clk: %d\n", ret);
 		goto e_clk_get2;
 	}
-
-	if (request_irq(hdmi_dma_priv->irq, hdmi_dma_isr, IRQF_SHARED,
-			"hdmi dma", hdmi_dma_priv)) {
-		dev_err(&pdev->dev, "MXC hdmi: failed to request irq %d\n",
-		       hdmi_dma_priv->irq);
-		ret = -EBUSY;
-		goto e_irq;
+	if (!hdmi_SDMA_check()) {
+		if (request_irq(hdmi_dma_priv->irq, hdmi_dma_isr, IRQF_SHARED,
+				"hdmi dma", hdmi_dma_priv)) {
+			dev_err(&pdev->dev,
+					"MXC hdmi: failed to request irq %d\n",
+					hdmi_dma_priv->irq);
+			ret = -EBUSY;
+			goto e_irq;
+		}
 	}
+
 	ret = snd_soc_register_platform(&pdev->dev, &imx_soc_platform_mx2);
 	if (ret)
 		goto e_irq;
 
-	printk("imx_soc_platform_probe probe successful\n");
 	return 0;
 
 e_irq:
@@ -1221,6 +1406,12 @@ e_clk_get1:
 static int __devexit imx_soc_platform_remove(struct platform_device *pdev)
 {
 	free_irq(hdmi_dma_priv->irq, hdmi_dma_priv);
+	if (hdmi_SDMA_check()) {
+		dma_free_coherent(NULL,
+				sizeof(struct hdmi_sdma_script_data),
+				hdmi_dma_priv->hdmi_sdma_t,
+				hdmi_dma_priv->phy_hdmi_sdma_t);
+	}
 	snd_soc_unregister_platform(&pdev->dev);
 	kfree(hdmi_dma_priv);
 	return 0;
diff --git a/sound/soc/imx/imx-hdmi.c b/sound/soc/imx/imx-hdmi.c
index 0e12acf..f214cff 100644
--- a/sound/soc/imx/imx-hdmi.c
+++ b/sound/soc/imx/imx-hdmi.c
@@ -1,7 +1,7 @@
 /*
  * ASoC HDMI Transmitter driver for IMX development boards
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * based on stmp3780_devb_spdif.c
  *
@@ -36,51 +36,56 @@
 #include "imx-hdmi.h"
 
 /* imx digital audio interface glue - connects codec <--> CPU */
-static struct snd_soc_dai_link imx_hdmi_dai_link[] = {
-	{
-		.name = "IMX HDMI TX",
-		.stream_name = "IMX HDMI TX",
-		.codec_dai_name = "mxc-hdmi-soc",
-		.codec_name = "mxc_hdmi_soc.0",
-		.cpu_dai_name = "imx-hdmi-soc-dai.0",
-		.platform_name = "imx-hdmi-soc-audio.0",
-	},
+static struct snd_soc_dai_link imx_hdmi_dai_link = {
+	.name = "IMX HDMI TX",
+	.stream_name = "IMX HDMI TX",
+	.codec_dai_name = "mxc-hdmi-soc",
+	.codec_name = "mxc_hdmi_soc.0",
+	.cpu_dai_name = "imx-hdmi-soc-dai.0",
+	.platform_name = "imx-hdmi-soc-audio.0",
 };
 
 static struct snd_soc_card snd_soc_card_imx_hdmi = {
-	.name		= "imx-hdmi-soc",
-	.dai_link	= imx_hdmi_dai_link,
-	.num_links	= ARRAY_SIZE(imx_hdmi_dai_link),
+	.name = "imx-hdmi-soc",
+	.dai_link = &imx_hdmi_dai_link,
+	.num_links = 1,
 };
 
-static struct platform_device *imx_snd_device;
+static struct platform_device *imx_hdmi_snd_device;
 
-static int __init imx_audio_init(void)
+static int __init imx_hdmi_init(void)
 {
-	int ret;
+	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		pr_err("Initialize HDMI-audio failed. Load HDMI-video first!\n");
+		return -ENODEV;
+	}
 
-	imx_snd_device = platform_device_alloc("soc-audio", -1);
-	if (!imx_snd_device)
+	imx_hdmi_snd_device = platform_device_alloc("soc-audio", 4);
+	if (!imx_hdmi_snd_device) {
+		pr_err("%s - failed platform_device_alloc\n", __func__);
 		return -ENOMEM;
+	}
 
-	platform_set_drvdata(imx_snd_device, &snd_soc_card_imx_hdmi);
+	platform_set_drvdata(imx_hdmi_snd_device, &snd_soc_card_imx_hdmi);
 
-	ret = platform_device_add(imx_snd_device);
-	if (ret)
-		platform_device_put(imx_snd_device);
+	ret = platform_device_add(imx_hdmi_snd_device);
+	if (ret) {
+		pr_err("ASoC HDMI TX: Platform device allocation failed\n");
+		platform_device_put(imx_hdmi_snd_device);
+	}
 
 	return ret;
 }
-module_init(imx_audio_init);
 
-static void __exit imx_audio_exit(void)
+static void __exit imx_hdmi_exit(void)
 {
-	platform_device_unregister(imx_snd_device);
+	platform_device_unregister(imx_hdmi_snd_device);
 }
-module_exit(imx_audio_exit);
+
+module_init(imx_hdmi_init);
+module_exit(imx_hdmi_exit);
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("IMX HDMI TX ASoC driver");
-- 
1.7.5.4

