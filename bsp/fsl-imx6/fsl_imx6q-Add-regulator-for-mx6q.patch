From 71675b2bb600c82e2a8db3781b30f4037dc16d76 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 19 Jul 2013 09:30:07 +0800
Subject: [PATCH 05/38] fsl_imx6q: Add regulator for mx6q

Source: Extract from vendor-drop package, L3.0.35_4.0.0_130424_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/regulator/Kconfig              |   13 +-
 drivers/regulator/Makefile             |    3 +-
 drivers/regulator/anatop-regulator.c   |  300 ++++++------
 drivers/regulator/max17135-regulator.c |  683 +++++++++++++++++++++++++
 drivers/regulator/pfuze-regulator.h    |  110 ++++
 drivers/regulator/pfuze100-regulator.c |  856 ++++++++++++++++++++++++++++++++
 6 files changed, 1808 insertions(+), 157 deletions(-)
 create mode 100644 drivers/regulator/max17135-regulator.c
 create mode 100644 drivers/regulator/pfuze-regulator.h
 create mode 100644 drivers/regulator/pfuze100-regulator.c

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index e1730a5..4d55d88 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -104,7 +104,6 @@ config REGULATOR_DA9052
 
 config REGULATOR_ANATOP
 	tristate "Freescale i.MX on-chip ANATOP LDO regulators"
-	depends on MFD_ANATOP
 	help
 	  Say y here to support Freescale i.MX on-chip ANATOP LDOs
 	  regulators. It is recommended that this option be
@@ -231,6 +230,13 @@ config REGULATOR_S5M8767
 	 via I2C bus. S5M8767A have 9 Bucks and 28 LDOs output and
 	 supports DVS mode with 8bits of output voltage control.
 
+config REGULATOR_PFUZE100
+	tristate "Support regulators on Freescale PFUZE100 PMIC"
+	depends on MFD_PFUZE
+	help
+	Say y here to support the regulators found on the Freescale PFUZE100
+	  PMIC.
+
 config REGULATOR_AB3100
 	tristate "ST-Ericsson AB3100 Regulator functions"
 	depends on AB3100_CORE
@@ -370,5 +376,10 @@ config REGULATOR_MC34708
 	tristate "MC34708 Regulator Support"
 	depends on MXC_PMIC_MC34708
 
+config REGULATOR_MAX17135
+	tristate "Maxim MAX17135 Regulator Support"
+	depends on MFD_MAX17135
+	default n
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index e1a6b43..51a6cc4 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
 obj-$(CONFIG_REGULATOR_MC34708) += mc34708-regulator.o
-
+obj-$(CONFIG_REGULATOR_PFUZE100) += pfuze100-regulator.o
+obj-$(CONFIG_REGULATOR_MAX17135) += max17135-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/anatop-regulator.c b/drivers/regulator/anatop-regulator.c
index 7f7ef80..439644a 100644
--- a/drivers/regulator/anatop-regulator.c
+++ b/drivers/regulator/anatop-regulator.c
@@ -22,225 +22,215 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/err.h>
-#include <linux/io.h>
 #include <linux/platform_device.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/mfd/anatop.h>
+#include <linux/regulator/machine.h>
 #include <linux/regulator/driver.h>
-#include <linux/regulator/of_regulator.h>
 #include <linux/regulator/anatop-regulator.h>
-#include <mach/hardware.h>
-#include <mach/mx6q.h>
 
 static int anatop_set_voltage(struct regulator_dev *reg, int min_uV,
 				  int max_uV, unsigned *selector)
 {
 	struct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);
-	u32 val, sel, mask;
-	int uv;
-
-	uv = min_uV;
-	dev_dbg(&reg->dev, "%s: uv %d, min %d, max %d\n", __func__,
-		uv, anatop_reg->min_voltage,
-		anatop_reg->max_voltage);
-
-	if (uv < anatop_reg->min_voltage) {
-		if (max_uV > anatop_reg->min_voltage)
-			uv = anatop_reg->min_voltage;
-		else
-			return -EINVAL;
-	}
 
-	if (!anatop_reg->control_reg)
+	if (anatop_reg->rdata->set_voltage)
+		return anatop_reg->rdata->set_voltage(anatop_reg, max_uV);
+	else
 		return -ENOTSUPP;
-
-	sel = DIV_ROUND_UP(uv - anatop_reg->min_voltage, 25000);
-	if (sel * 25000 + anatop_reg->min_voltage > anatop_reg->max_voltage)
-		return -EINVAL;
-	val = anatop_reg->min_bit_val + sel;
-	*selector = sel;
-
-	dev_dbg(&reg->dev, "%s: calculated val %d\n", __func__, val);
-
-	mask = ((1 << anatop_reg->vol_bit_width) - 1) <<
-		anatop_reg->vol_bit_shift;
-	val <<= anatop_reg->vol_bit_shift;
-	anatop_write_reg(anatop_reg->mfd, anatop_reg->control_reg, val, mask);
-
-	return 0;
 }
 
-static int anatop_get_voltage_sel(struct regulator_dev *reg)
+static int anatop_get_voltage(struct regulator_dev *reg)
 {
 	struct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);
-	u32 val, mask;
 
-	if (!anatop_reg->control_reg)
+	if (anatop_reg->rdata->get_voltage)
+		return anatop_reg->rdata->get_voltage(anatop_reg);
+	else
 		return -ENOTSUPP;
+}
 
-	val = anatop_read_reg(anatop_reg->mfd, anatop_reg->control_reg);
-	mask = ((1 << anatop_reg->vol_bit_width) - 1) <<
-		anatop_reg->vol_bit_shift;
-	val = (val & mask) >> anatop_reg->vol_bit_shift;
+static int anatop_enable(struct regulator_dev *reg)
+{
+	struct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);
 
-	return val - anatop_reg->min_bit_val;
+	return anatop_reg->rdata->enable(anatop_reg);
 }
 
-static int anatop_list_voltage(struct regulator_dev *reg, unsigned selector)
+static int anatop_disable(struct regulator_dev *reg)
 {
 	struct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);
-	int uv;
 
-	uv = anatop_reg->min_voltage + selector * 25000;
-	dev_dbg(&reg->dev, "vddio = %d, selector = %u\n", uv, selector);
+	return anatop_reg->rdata->disable(anatop_reg);
+}
 
-	return uv;
+static int anatop_is_enabled(struct regulator_dev *reg)
+{
+	struct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);
+
+	return anatop_reg->rdata->is_enabled(anatop_reg);
 }
 
 static struct regulator_ops anatop_rops = {
-	.set_voltage     = anatop_set_voltage,
-	.get_voltage_sel = anatop_get_voltage_sel,
-	.list_voltage    = anatop_list_voltage,
+	.set_voltage	= anatop_set_voltage,
+	.get_voltage	= anatop_get_voltage,
+	.enable		= anatop_enable,
+	.disable	= anatop_disable,
+	.is_enabled	= anatop_is_enabled,
 };
 
-static int __devinit anatop_regulator_probe(struct platform_device *pdev)
+static struct regulator_desc anatop_reg_desc[] = {
+	{
+		.name = "vddpu",
+		.id = ANATOP_VDDPU,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vddcore",
+		.id = ANATOP_VDDCORE,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vddsoc",
+		.id = ANATOP_VDDSOC,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vdd2p5",
+		.id = ANATOP_VDD2P5,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vdd1p1",
+		.id = ANATOP_VDD1P1,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vdd3p0",
+		.id = ANATOP_VDD3P0,
+		.ops = &anatop_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+};
+
+int anatop_regulator_probe(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
 	struct regulator_desc *rdesc;
 	struct regulator_dev *rdev;
 	struct anatop_regulator *sreg;
 	struct regulator_init_data *initdata;
-	struct anatop *anatopmfd = dev_get_drvdata(pdev->dev.parent);
-	int ret = 0;
 
-	initdata = of_get_regulator_init_data(dev, np);
-	if(!initdata)
-		initdata = pdev->dev.platform_data;
-
-#ifdef CONFIG_OF
-	sreg = devm_kzalloc(dev, sizeof(*sreg), GFP_KERNEL);
-	if (!sreg)
-		return -ENOMEM;
-
-	sreg->name = kstrdup(of_get_property(np, "regulator-name", NULL),
-			     GFP_KERNEL);
-#else
 	sreg = platform_get_drvdata(pdev);
-#endif
-
-	sreg->initdata = initdata;
-
-	rdesc = &sreg->rdesc;
-	memset(rdesc, 0, sizeof(*rdesc));
-	rdesc->name = sreg->name;
-	rdesc->ops = &anatop_rops;
-	rdesc->type = REGULATOR_VOLTAGE;
-	rdesc->owner = THIS_MODULE;
-	sreg->mfd = anatopmfd;
-
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(np, "anatop-reg-offset",
-				   &sreg->control_reg);
-	if (ret) {
-		dev_err(dev, "no anatop-reg-offset property set\n");
-		goto anatop_probe_end;
-	}
-	ret = of_property_read_u32(np, "anatop-vol-bit-width",
-				   &sreg->vol_bit_width);
-	if (ret) {
-		dev_err(dev, "no anatop-vol-bit-width property set\n");
-		goto anatop_probe_end;
-	}
-	ret = of_property_read_u32(np, "anatop-vol-bit-shift",
-				   &sreg->vol_bit_shift);
-	if (ret) {
-		dev_err(dev, "no anatop-vol-bit-shift property set\n");
-		goto anatop_probe_end;
-	}
-	ret = of_property_read_u32(np, "anatop-min-bit-val",
-				   &sreg->min_bit_val);
-	if (ret) {
-		dev_err(dev, "no anatop-min-bit-val property set\n");
-		goto anatop_probe_end;
-	}
-	ret = of_property_read_u32(np, "anatop-min-voltage",
-				   &sreg->min_voltage);
-	if (ret) {
-		dev_err(dev, "no anatop-min-voltage property set\n");
-		goto anatop_probe_end;
-	}
-	ret = of_property_read_u32(np, "anatop-max-voltage",
-				   &sreg->max_voltage);
-	if (ret) {
-		dev_err(dev, "no anatop-max-voltage property set\n");
-		goto anatop_probe_end;
-	}
-#endif
-
-	rdesc->n_voltages = (sreg->max_voltage - sreg->min_voltage)
-		/ 25000 + 1;
+	initdata = pdev->dev.platform_data;
+	sreg->cur_current = 0;
+	sreg->next_current = 0;
+	sreg->cur_voltage = 0;
+
+	init_waitqueue_head(&sreg->wait_q);
+	spin_lock_init(&sreg->lock);
+
+	if (pdev->id > ANATOP_SUPPLY_NUM) {
+		rdesc = kzalloc(sizeof(struct regulator_desc), GFP_KERNEL);
+		memcpy(rdesc, &anatop_reg_desc[ANATOP_SUPPLY_NUM],
+			sizeof(struct regulator_desc));
+		rdesc->name = kstrdup(sreg->rdata->name, GFP_KERNEL);
+	} else
+		rdesc = &anatop_reg_desc[pdev->id];
+
+	pr_debug("probing regulator %s %s %d\n",
+			sreg->rdata->name,
+			rdesc->name,
+			pdev->id);
 
 	/* register regulator */
-	rdev = regulator_register(rdesc, dev,
-				  initdata, sreg, pdev->dev.of_node);
+	rdev = regulator_register(rdesc, &pdev->dev,
+				  initdata, sreg, NULL);
+
 	if (IS_ERR(rdev)) {
-		dev_err(dev, "failed to register %s\n",
+		dev_err(&pdev->dev, "failed to register %s\n",
 			rdesc->name);
-		ret = PTR_ERR(rdev);
-		goto anatop_probe_end;
+		return PTR_ERR(rdev);
 	}
 
-	platform_set_drvdata(pdev, rdev);
-
-anatop_probe_end:
-	if (ret)
-		kfree(sreg->name);
-
-	return ret;
+	return 0;
 }
 
-static int __devexit anatop_regulator_remove(struct platform_device *pdev)
+
+int anatop_regulator_remove(struct platform_device *pdev)
 {
 	struct regulator_dev *rdev = platform_get_drvdata(pdev);
-	struct anatop_regulator *sreg = rdev_get_drvdata(rdev);
-	const char *name = sreg->name;
 
 	regulator_unregister(rdev);
-	kfree(name);
 
 	return 0;
+
 }
 
-static struct of_device_id __devinitdata of_anatop_regulator_match_tbl[] = {
-	{ .compatible = "fsl,anatop-regulator", },
-	{ /* end */ }
-};
+int anatop_register_regulator(
+		struct anatop_regulator *reg_data, int reg,
+			      struct regulator_init_data *initdata)
+{
+	struct platform_device *pdev;
+	int ret;
 
-static struct platform_driver anatop_regulator_driver = {
+	pdev = platform_device_alloc("anatop_reg", reg);
+	if (!pdev)
+		return -ENOMEM;
+
+	pdev->dev.platform_data = initdata;
+
+	platform_set_drvdata(pdev, reg_data);
+	ret = platform_device_add(pdev);
+
+	if (ret != 0) {
+		pr_debug("Failed to register regulator %d: %d\n",
+			reg, ret);
+		platform_device_del(pdev);
+	}
+	pr_debug("register regulator %s, %d: %d\n",
+			reg_data->rdata->name, reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(anatop_register_regulator);
+
+struct platform_driver anatop_reg = {
 	.driver = {
-		.name	= "anatop_regulator",
-		.owner  = THIS_MODULE,
-		.of_match_table = of_anatop_regulator_match_tbl,
+		.name	= "anatop_reg",
 	},
 	.probe	= anatop_regulator_probe,
 	.remove	= anatop_regulator_remove,
 };
 
-static int __init anatop_regulator_init(void)
+int anatop_regulator_init(void)
 {
-	return platform_driver_register(&anatop_regulator_driver);
+	return platform_driver_register(&anatop_reg);
 }
-postcore_initcall(anatop_regulator_init);
 
-static void __exit anatop_regulator_exit(void)
+void anatop_regulator_exit(void)
 {
-	platform_driver_unregister(&anatop_regulator_driver);
+	platform_driver_unregister(&anatop_reg);
 }
+
+postcore_initcall(anatop_regulator_init);
 module_exit(anatop_regulator_exit);
 
-MODULE_AUTHOR("Nancy Chen <Nancy.Chen@freescale.com>, "
-	      "Ying-Chun Liu (PaulLiu) <paul.liu@linaro.org>");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("ANATOP Regulator driver");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/regulator/max17135-regulator.c b/drivers/regulator/max17135-regulator.c
new file mode 100644
index 0000000..7f00fd7
--- /dev/null
+++ b/drivers/regulator/max17135-regulator.c
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <linux/mfd/max17135.h>
+#include <linux/gpio.h>
+
+/*
+ * Regulator definitions
+ *   *_MIN_uV  - minimum microvolt for regulator
+ *   *_MAX_uV  - maximum microvolt for regulator
+ *   *_STEP_uV - microvolts between regulator output levels
+ *   *_MIN_VAL - minimum register field value for regulator
+ *   *_MAX_VAL - maximum register field value for regulator
+ */
+#define MAX17135_HVINP_MIN_uV    5000000
+#define MAX17135_HVINP_MAX_uV   20000000
+#define MAX17135_HVINP_STEP_uV   1000000
+#define MAX17135_HVINP_MIN_VAL         0
+#define MAX17135_HVINP_MAX_VAL         1
+
+#define MAX17135_HVINN_MIN_uV    5000000
+#define MAX17135_HVINN_MAX_uV   20000000
+#define MAX17135_HVINN_STEP_uV   1000000
+#define MAX17135_HVINN_MIN_VAL         0
+#define MAX17135_HVINN_MAX_VAL         1
+
+#define MAX17135_GVDD_MIN_uV    5000000
+#define MAX17135_GVDD_MAX_uV   20000000
+#define MAX17135_GVDD_STEP_uV   1000000
+#define MAX17135_GVDD_MIN_VAL         0
+#define MAX17135_GVDD_MAX_VAL         1
+
+#define MAX17135_GVEE_MIN_uV    5000000
+#define MAX17135_GVEE_MAX_uV   20000000
+#define MAX17135_GVEE_STEP_uV   1000000
+#define MAX17135_GVEE_MIN_VAL         0
+#define MAX17135_GVEE_MAX_VAL         1
+
+#define MAX17135_VCOM_MIN_VAL         0
+#define MAX17135_VCOM_MAX_VAL       255
+
+#define MAX17135_VNEG_MIN_uV    5000000
+#define MAX17135_VNEG_MAX_uV   20000000
+#define MAX17135_VNEG_STEP_uV   1000000
+#define MAX17135_VNEG_MIN_VAL         0
+#define MAX17135_VNEG_MAX_VAL         1
+
+#define MAX17135_VPOS_MIN_uV    5000000
+#define MAX17135_VPOS_MAX_uV   20000000
+#define MAX17135_VPOS_STEP_uV   1000000
+#define MAX17135_VPOS_MIN_VAL         0
+#define MAX17135_VPOS_MAX_VAL         1
+
+struct max17135_vcom_programming_data {
+	int vcom_min_uV;
+	int vcom_max_uV;
+	int vcom_step_uV;
+};
+
+static long unsigned int max17135_pass_num = { 1 };
+static int max17135_vcom = { -1250000 };
+
+struct max17135_vcom_programming_data vcom_data[2] = {
+	{
+		-4325000,
+		-500000,
+		15000,
+	},
+	{
+		-3050000,
+		-500000,
+		10000,
+	},
+};
+
+static int max17135_is_power_good(struct max17135 *max17135);
+
+/*
+ * Regulator operations
+ */
+static int max17135_hvinp_set_voltage(struct regulator_dev *reg,
+					int minuV, int uV, unsigned *selector)
+{
+	unsigned int reg_val;
+	unsigned int fld_val;
+
+	if ((uV >= MAX17135_HVINP_MIN_uV) &&
+	    (uV <= MAX17135_HVINP_MAX_uV))
+		fld_val = (uV - MAX17135_HVINP_MIN_uV) /
+			MAX17135_HVINP_STEP_uV;
+	else
+		return -EINVAL;
+
+	max17135_reg_read(REG_MAX17135_HVINP, &reg_val);
+
+	reg_val &= ~BITFMASK(HVINP);
+	reg_val |= BITFVAL(HVINP, fld_val); /* shift to correct bit */
+
+	return max17135_reg_write(REG_MAX17135_HVINP, reg_val);
+}
+
+static int max17135_hvinp_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int reg_val;
+	unsigned int fld_val;
+	int volt;
+
+	max17135_reg_read(REG_MAX17135_HVINP, &reg_val);
+
+	fld_val = (reg_val & BITFMASK(HVINP)) >> HVINP_LSH;
+
+	if ((fld_val >= MAX17135_HVINP_MIN_VAL) &&
+		(fld_val <= MAX17135_HVINP_MAX_VAL)) {
+		volt = (fld_val * MAX17135_HVINP_STEP_uV) +
+			MAX17135_HVINP_MIN_uV;
+	} else {
+		printk(KERN_ERR "MAX17135: HVINP voltage is out of range\n");
+		volt = 0;
+	}
+	return volt;
+}
+
+static int max17135_hvinp_enable(struct regulator_dev *reg)
+{
+	return 0;
+}
+
+static int max17135_hvinp_disable(struct regulator_dev *reg)
+{
+	return 0;
+}
+
+/* Convert uV to the VCOM register bitfield setting */
+static inline int vcom_uV_to_rs(int uV, int pass_num)
+{
+	return (vcom_data[pass_num].vcom_max_uV - uV)
+		/ vcom_data[pass_num].vcom_step_uV;
+}
+
+/* Convert the VCOM register bitfield setting to uV */
+static inline int vcom_rs_to_uV(int rs, int pass_num)
+{
+	return vcom_data[pass_num].vcom_max_uV
+		- (vcom_data[pass_num].vcom_step_uV * rs);
+}
+
+static int max17135_vcom_set_voltage(struct regulator_dev *reg,
+					int minuV, int uV, unsigned *selector)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+	unsigned int reg_val;
+	int vcom_read;
+
+	if ((uV < vcom_data[max17135->pass_num-1].vcom_min_uV)
+		|| (uV > vcom_data[max17135->pass_num-1].vcom_max_uV))
+		return -EINVAL;
+
+	max17135_reg_read(REG_MAX17135_DVR, &reg_val);
+
+	/*
+	 * Only program VCOM if it is not set to the desired value.
+	 * Programming VCOM excessively degrades ability to keep
+	 * DVR register value persistent.
+	 */
+	vcom_read = vcom_rs_to_uV(reg_val, max17135->pass_num-1);
+	if (vcom_read != max17135->vcom_uV) {
+		reg_val &= ~BITFMASK(DVR);
+		reg_val |= BITFVAL(DVR, vcom_uV_to_rs(uV,
+			max17135->pass_num-1));
+		max17135_reg_write(REG_MAX17135_DVR, reg_val);
+
+		reg_val = BITFVAL(CTRL_DVR, true); /* shift to correct bit */
+		return max17135_reg_write(REG_MAX17135_PRGM_CTRL, reg_val);
+	}
+
+	return 0;
+}
+
+static int max17135_vcom_get_voltage(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+	unsigned int reg_val;
+
+	max17135_reg_read(REG_MAX17135_DVR, &reg_val);
+	return vcom_rs_to_uV(BITFEXT(reg_val, DVR), max17135->pass_num-1);
+}
+
+static int max17135_vcom_enable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	/*
+	 * Check to see if we need to set the VCOM voltage.
+	 * Should only be done one time. And, we can
+	 * only change vcom voltage if we have been enabled.
+	 */
+	if (!max17135->vcom_setup && max17135_is_power_good(max17135)) {
+		max17135_vcom_set_voltage(reg,
+			max17135->vcom_uV,
+			max17135->vcom_uV,
+			NULL);
+		max17135->vcom_setup = true;
+	}
+
+	/* enable VCOM regulator output */
+	if (max17135->pass_num == 1)
+		gpio_set_value(max17135->gpio_pmic_vcom_ctrl, 1);
+	else {
+		unsigned int reg_val;
+
+		max17135_reg_read(REG_MAX17135_ENABLE, &reg_val);
+		reg_val &= ~BITFMASK(VCOM_ENABLE);
+		reg_val |= BITFVAL(VCOM_ENABLE, 1); /* shift to correct bit */
+		max17135_reg_write(REG_MAX17135_ENABLE, reg_val);
+	}
+
+	return 0;
+}
+
+static int max17135_vcom_disable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	if (max17135->pass_num == 1)
+		gpio_set_value(max17135->gpio_pmic_vcom_ctrl, 0);
+	else {
+		unsigned int reg_val;
+
+		max17135_reg_read(REG_MAX17135_ENABLE, &reg_val);
+		reg_val &= ~BITFMASK(VCOM_ENABLE);
+		max17135_reg_write(REG_MAX17135_ENABLE, reg_val);
+	}
+
+	return 0;
+}
+
+static int max17135_vcom_is_enabled(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	/* read VCOM regulator enable setting */
+	if (max17135->pass_num == 1) {
+		int gpio = gpio_get_value(max17135->gpio_pmic_vcom_ctrl);
+		if (gpio == 0)
+			return 0;
+		else
+			return 1;
+	} else {
+		unsigned int reg_val;
+
+		max17135_reg_read(REG_MAX17135_ENABLE, &reg_val);
+		reg_val &= BITFMASK(VCOM_ENABLE);
+		if (reg_val != 0)
+			return 1;
+		else
+			return 0;
+	}
+}
+
+static int max17135_is_power_good(struct max17135 *max17135)
+{
+    unsigned int reg_val;
+    unsigned int fld_val;
+
+    max17135_reg_read(REG_MAX17135_FAULT, &reg_val);
+    fld_val = (reg_val & BITFMASK(FAULT_POK)) >> FAULT_POK_LSH;
+
+    /* Check the POK bit */
+    return fld_val;
+}
+
+static int max17135_wait_power_good(struct max17135 *max17135)
+{
+	int i;
+
+	for (i = 0; i < max17135->max_wait * 3; i++) {
+		if (max17135_is_power_good(max17135))
+			return 0;
+
+		msleep(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int max17135_display_enable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	/* The Pass 1 parts cannot turn on the PMIC via I2C. */
+	if (max17135->pass_num == 1)
+		gpio_set_value(max17135->gpio_pmic_wakeup, 1);
+	else {
+		unsigned int reg_val;
+
+		max17135_reg_read(REG_MAX17135_ENABLE, &reg_val);
+		reg_val &= ~BITFMASK(ENABLE);
+		reg_val |= BITFVAL(ENABLE, 1);
+		max17135_reg_write(REG_MAX17135_ENABLE, reg_val);
+	}
+
+	return max17135_wait_power_good(max17135);
+}
+
+static int max17135_display_disable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	if (max17135->pass_num == 1)
+		gpio_set_value(max17135->gpio_pmic_wakeup, 0);
+	else {
+		unsigned int reg_val;
+
+		max17135_reg_read(REG_MAX17135_ENABLE, &reg_val);
+		reg_val &= ~BITFMASK(ENABLE);
+		max17135_reg_write(REG_MAX17135_ENABLE, reg_val);
+	}
+
+	msleep(max17135->max_wait);
+
+	return 0;
+}
+
+static int max17135_display_is_enabled(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+	int gpio = gpio_get_value(max17135->gpio_pmic_wakeup);
+
+	if (gpio == 0)
+		return 0;
+	else
+		return 1;
+}
+
+static int max17135_v3p3_enable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	gpio_set_value(max17135->gpio_pmic_v3p3, 1);
+	return 0;
+}
+
+static int max17135_v3p3_disable(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+
+	gpio_set_value(max17135->gpio_pmic_v3p3, 0);
+	return 0;
+}
+
+static int max17135_v3p3_is_enabled(struct regulator_dev *reg)
+{
+	struct max17135 *max17135 = rdev_get_drvdata(reg);
+	int gpio = gpio_get_value(max17135->gpio_pmic_v3p3);
+
+	if (gpio == 0)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * Regulator operations
+ */
+
+static struct regulator_ops max17135_display_ops = {
+	.enable = max17135_display_enable,
+	.disable = max17135_display_disable,
+	.is_enabled = max17135_display_is_enabled,
+};
+
+static struct regulator_ops max17135_gvdd_ops = {
+};
+
+static struct regulator_ops max17135_gvee_ops = {
+};
+
+static struct regulator_ops max17135_hvinn_ops = {
+};
+
+static struct regulator_ops max17135_hvinp_ops = {
+	.enable = max17135_hvinp_enable,
+	.disable = max17135_hvinp_disable,
+	.get_voltage = max17135_hvinp_get_voltage,
+	.set_voltage = max17135_hvinp_set_voltage,
+};
+
+static struct regulator_ops max17135_vcom_ops = {
+	.enable = max17135_vcom_enable,
+	.disable = max17135_vcom_disable,
+	.get_voltage = max17135_vcom_get_voltage,
+	.set_voltage = max17135_vcom_set_voltage,
+	.is_enabled = max17135_vcom_is_enabled,
+};
+
+static struct regulator_ops max17135_vneg_ops = {
+};
+
+static struct regulator_ops max17135_vpos_ops = {
+};
+
+static struct regulator_ops max17135_v3p3_ops = {
+	.enable = max17135_v3p3_enable,
+	.disable = max17135_v3p3_disable,
+	.is_enabled = max17135_v3p3_is_enabled,
+};
+
+
+/*
+ * Regulator descriptors
+ */
+static struct regulator_desc max17135_reg[MAX17135_NUM_REGULATORS] = {
+{
+	.name = "DISPLAY",
+	.id = MAX17135_DISPLAY,
+	.ops = &max17135_display_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "GVDD",
+	.id = MAX17135_GVDD,
+	.ops = &max17135_gvdd_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "GVEE",
+	.id = MAX17135_GVEE,
+	.ops = &max17135_gvee_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "HVINN",
+	.id = MAX17135_HVINN,
+	.ops = &max17135_hvinn_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "HVINP",
+	.id = MAX17135_HVINP,
+	.ops = &max17135_hvinp_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "VCOM",
+	.id = MAX17135_VCOM,
+	.ops = &max17135_vcom_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "VNEG",
+	.id = MAX17135_VNEG,
+	.ops = &max17135_vneg_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "VPOS",
+	.id = MAX17135_VPOS,
+	.ops = &max17135_vpos_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "V3P3",
+	.id = MAX17135_V3P3,
+	.ops = &max17135_v3p3_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+};
+
+static void max17135_setup_timings(struct max17135 *max17135)
+{
+	unsigned int reg_val;
+
+	int timing1, timing2, timing3, timing4,
+		timing5, timing6, timing7, timing8;
+
+	max17135_reg_read(REG_MAX17135_TIMING1, &timing1);
+	max17135_reg_read(REG_MAX17135_TIMING2, &timing2);
+	max17135_reg_read(REG_MAX17135_TIMING3, &timing3);
+	max17135_reg_read(REG_MAX17135_TIMING4, &timing4);
+	max17135_reg_read(REG_MAX17135_TIMING5, &timing5);
+	max17135_reg_read(REG_MAX17135_TIMING6, &timing6);
+	max17135_reg_read(REG_MAX17135_TIMING7, &timing7);
+	max17135_reg_read(REG_MAX17135_TIMING8, &timing8);
+
+	if ((timing1 != max17135->gvee_pwrup) ||
+		(timing2 != max17135->vneg_pwrup) ||
+		(timing3 != max17135->vpos_pwrup) ||
+		(timing4 != max17135->gvdd_pwrup) ||
+		(timing5 != max17135->gvdd_pwrdn) ||
+		(timing6 != max17135->vpos_pwrdn) ||
+		(timing7 != max17135->vneg_pwrdn) ||
+		(timing8 != max17135->gvee_pwrdn)) {
+		max17135_reg_write(REG_MAX17135_TIMING1, max17135->gvee_pwrup);
+		max17135_reg_write(REG_MAX17135_TIMING2, max17135->vneg_pwrup);
+		max17135_reg_write(REG_MAX17135_TIMING3, max17135->vpos_pwrup);
+		max17135_reg_write(REG_MAX17135_TIMING4, max17135->gvdd_pwrup);
+		max17135_reg_write(REG_MAX17135_TIMING5, max17135->gvdd_pwrdn);
+		max17135_reg_write(REG_MAX17135_TIMING6, max17135->vpos_pwrdn);
+		max17135_reg_write(REG_MAX17135_TIMING7, max17135->vneg_pwrdn);
+		max17135_reg_write(REG_MAX17135_TIMING8, max17135->gvee_pwrdn);
+
+		reg_val = BITFVAL(CTRL_TIMING, true); /* shift to correct bit */
+		max17135_reg_write(REG_MAX17135_PRGM_CTRL, reg_val);
+	}
+}
+
+
+/*
+ * Regulator init/probing/exit functions
+ */
+static int max17135_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev;
+
+	rdev = regulator_register(&max17135_reg[pdev->id], &pdev->dev,
+				  pdev->dev.platform_data,
+				  dev_get_drvdata(&pdev->dev), pdev->dev.of_node);
+
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s\n",
+			max17135_reg[pdev->id].name);
+		return PTR_ERR(rdev);
+	}
+
+	return 0;
+}
+
+static int max17135_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver max17135_regulator_driver = {
+	.probe = max17135_regulator_probe,
+	.remove = max17135_regulator_remove,
+	.driver = {
+		.name = "max17135-reg",
+	},
+};
+
+int max17135_register_regulator(struct max17135 *max17135, int reg,
+				     struct regulator_init_data *initdata)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	struct i2c_client *client = max17135->i2c_client;
+	/* If we can't find PMIC via I2C, we should not register regulators */
+	if (i2c_smbus_read_byte_data(client,
+		REG_MAX17135_PRODUCT_REV) != 0) {
+		dev_err(max17135->dev,
+			"Max17135 PMIC not found!\n");
+		return -ENXIO;
+	}
+
+	if (max17135->pdev[reg])
+		return -EBUSY;
+
+	pdev = platform_device_alloc("max17135-reg", reg);
+	if (!pdev)
+		return -ENOMEM;
+
+	max17135->pdev[reg] = pdev;
+
+	initdata->driver_data = max17135;
+
+	pdev->dev.platform_data = initdata;
+	pdev->dev.parent = max17135->dev;
+	platform_set_drvdata(pdev, max17135);
+
+	ret = platform_device_add(pdev);
+
+	if (ret != 0) {
+		dev_err(max17135->dev,
+		       "Failed to register regulator %d: %d\n",
+			reg, ret);
+		platform_device_del(pdev);
+		max17135->pdev[reg] = NULL;
+	}
+
+	if (!max17135->init_done) {
+		max17135->pass_num = max17135_pass_num;
+		max17135->vcom_uV = max17135_vcom;
+
+		/*
+		 * Set up PMIC timing values.
+		 * Should only be done one time!  Timing values may only be
+		 * changed a limited number of times according to spec.
+		 */
+		max17135_setup_timings(max17135);
+
+		max17135->init_done = true;
+	}
+
+	return ret;
+}
+
+static int __init max17135_regulator_init(void)
+{
+	return platform_driver_register(&max17135_regulator_driver);
+}
+subsys_initcall(max17135_regulator_init);
+
+static void __exit max17135_regulator_exit(void)
+{
+	platform_driver_unregister(&max17135_regulator_driver);
+}
+module_exit(max17135_regulator_exit);
+
+
+/*
+ * Parse user specified options (`max17135:')
+ * example:
+ *   max17135:pass=2,vcom=-1250000
+ */
+static int __init max17135_setup(char *options)
+{
+	int ret;
+	char *opt;
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "pass=", 5)) {
+			ret = strict_strtoul(opt + 5, 0, &max17135_pass_num);
+			if (ret < 0)
+				return ret;
+		}
+		if (!strncmp(opt, "vcom=", 5)) {
+			int offs = 5;
+			if (opt[5] == '-')
+				offs = 6;
+			ret = strict_strtoul(opt + offs, 0,
+				(long *)&max17135_vcom);
+			if (ret < 0)
+				return ret;
+			max17135_vcom = -max17135_vcom;
+		}
+	}
+
+	return 1;
+}
+
+__setup("max17135:", max17135_setup);
+
+/* Module information */
+MODULE_DESCRIPTION("MAX17135 regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/pfuze-regulator.h b/drivers/regulator/pfuze-regulator.h
new file mode 100644
index 0000000..113355c
--- /dev/null
+++ b/drivers/regulator/pfuze-regulator.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#ifndef __LINUX_REGULATOR_PFUZE_H
+#define __LINUX_REGULATOR_PFUZE_H
+
+#include <linux/regulator/driver.h>
+
+struct pfuze_regulator {
+	struct regulator_desc desc;
+	unsigned int reg;
+	unsigned int stby_reg;
+	unsigned char enable_bit;
+	unsigned char stby_bit;
+	unsigned char vsel_shift;
+	unsigned char vsel_mask;
+	unsigned char stby_vsel_shift;
+	unsigned char stby_vsel_mask;
+	int const *voltages;
+};
+
+struct pfuze_regulator_priv {
+	struct mc_pfuze *pfuze;
+	struct pfuze_regulator *pfuze_regulators;
+	struct regulator_dev *regulators[];
+};
+
+#define PFUZE_DEFINE(prefix, _name, _reg, _voltages, _ops)	\
+	[prefix ## _name] = {				\
+		.desc = {						\
+			.name = #prefix "_" #_name,			\
+			.n_voltages = ARRAY_SIZE(_voltages),		\
+			.ops = &_ops,			\
+			.type = REGULATOR_VOLTAGE,			\
+			.id = prefix ## _name,		\
+			.owner = THIS_MODULE,				\
+		},							\
+		.reg = prefix ## _reg,				\
+		.enable_bit = prefix ## _reg ## _ ## EN,	\
+		.stby_bit = prefix ## _reg ## _ ## STBY,	\
+		.vsel_shift = prefix ## _reg ## _ ## VSEL,\
+		.vsel_mask = prefix ## _reg ## _ ## VSEL_M,\
+		.voltages =  _voltages,					\
+	}
+#define PFUZE_SW_DEFINE(prefix, _name, _reg, _voltages, _ops)	\
+	[prefix ## _name] = {				\
+		.desc = {						\
+			.name = #prefix "_" #_name,			\
+			.n_voltages = ARRAY_SIZE(_voltages),		\
+			.ops = &_ops,			\
+			.type = REGULATOR_VOLTAGE,			\
+			.id = prefix ## _name,		\
+			.owner = THIS_MODULE,				\
+		},							\
+		.reg = prefix ## _reg,				\
+		.vsel_shift = prefix ## _reg ## _ ## VSEL,\
+		.vsel_mask = prefix ## _reg ## _ ## VSEL_M,\
+		.stby_reg = prefix ## _reg ## _ ## STBY,		\
+		.stby_vsel_shift = prefix ## _reg ## _ ## STBY_VSEL,\
+		.stby_vsel_mask = prefix ## _reg ## _ ## STBY_VSEL_M,\
+		.voltages =  _voltages,					\
+	}
+
+#define PFUZE_SWBST_DEFINE(prefix, _name, _reg, _voltages, _ops)	\
+	[prefix ## _name] = {				\
+		.desc = {						\
+			.name = #prefix "_" #_name,			\
+			.n_voltages = ARRAY_SIZE(_voltages),		\
+			.ops = &_ops,			\
+			.type = REGULATOR_VOLTAGE,			\
+			.id = prefix ## _name,		\
+			.owner = THIS_MODULE,				\
+		},							\
+		.reg = prefix ## _reg,				\
+		.vsel_shift = prefix ## _reg ## _ ## VSEL,\
+		.vsel_mask = prefix ## _reg ## _ ## VSEL_M,\
+		.voltages =  _voltages,					\
+	}
+
+#define PFUZE_FIXED_DEFINE(prefix, _name, _reg, _voltages, _ops)	\
+	[prefix ## _name] = {				\
+		.desc = {						\
+			.name = #prefix "_" #_name,			\
+			.n_voltages = ARRAY_SIZE(_voltages),		\
+			.ops = &_ops,		\
+			.type = REGULATOR_VOLTAGE,			\
+			.id = prefix ## _name,		\
+			.owner = THIS_MODULE,				\
+		},							\
+		.reg = prefix ## _reg,				\
+		.enable_bit = prefix ## _reg ## _ ## EN,	\
+		.voltages =  _voltages,					\
+	}
+
+#endif
+
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
new file mode 100644
index 0000000..7ba1c68
--- /dev/null
+++ b/drivers/regulator/pfuze100-regulator.c
@@ -0,0 +1,856 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/module.h>
+#include <linux/mfd/pfuze.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include "pfuze-regulator.h"
+
+static const int pfuze100_sw1[] = {
+#ifdef PFUZE100_FIRST_VERSION
+	650000, 662500, 675000, 687500, 700000, 712500, 725000, 737500,
+	750000, 762500, 775000, 787500, 800000, 812500, 825000, 837500,
+	850000, 862500, 875000, 887500, 900000, 912500, 925000, 937500,
+	950000, 962500, 975000, 987500, 1000000, 1012500, 1025000, 1037500,
+	1050000, 1062500, 1075000, 1087500, 1100000, 1112500, 1125000, 1137500,
+	1150000, 1162500, 1175000, 1187500, 1200000, 1212500, 1225000, 1237500,
+	1250000, 1262500, 1275000, 1287500, 1300000, 1312500, 1325000, 1337500,
+	1350000, 1362500, 1375000, 1387500, 1400000, 1412500, 1425000, 1437500,
+#else
+	300000, 325000, 350000, 375000, 400000, 425000, 450000, 475000,
+	500000, 525000, 550000, 575000, 600000, 625000, 650000, 675000,
+	700000, 725000, 750000, 775000, 800000, 825000, 850000, 875000,
+	900000, 925000, 950000, 975000, 1000000, 1025000, 1050000, 1075000,
+	1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000,
+	1300000, 1325000, 1350000, 1375000, 1400000, 1425000, 1450000, 1475000,
+	1500000, 1525000, 1550000, 1575000, 1600000, 1625000, 1650000, 1675000,
+	1700000, 1725000, 1750000, 1775000, 1800000, 1825000, 1850000, 1875000,
+#endif
+};
+
+#if  PFUZE100_SW2_VOL6
+static const int pfuze100_sw2[] = {
+	800000, 850000, 900000, 950000, 1000000, 1050000, 1100000, 1150000,
+	1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000, 3300000, 3300000, 3300000, 3300000, 3300000,
+	3300000, 3300000, 3300000, 3300000, 3300000, 3300000, 3300000, 3950000,
+};
+#else
+static const int pfuze100_sw2[] = {
+	400000, 425000, 450000, 475000, 500000, 525000, 550000, 575000,
+	600000, 625000, 650000, 675000, 700000, 725000, 750000, 775000,
+	800000, 825000, 850000, 875000, 900000, 925000, 950000, 975000,
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000,
+	1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000,
+	1400000, 1425000, 1450000, 1475000, 1500000, 1525000, 1550000, 1575000,
+	1600000, 1625000, 1650000, 1675000, 1700000, 1725000, 1750000, 1775000,
+	1800000, 1825000, 1850000, 1875000, 1900000, 1925000, 1950000, 1975000,
+};
+#endif
+
+#if PFUZE100_SW3_VOL6
+static const int pfuze100_sw3[] = {
+	800000, 850000, 900000, 950000, 1000000, 1050000, 1100000, 1150000,
+	1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000, 3300000, 3300000, 3300000, 3300000, 3300000,
+	3300000, 3300000, 3300000, 3750000, 3800000, 3850000, 3900000, 3950000,
+};
+#else
+static const int pfuze100_sw3[] = {
+	400000, 425000, 450000, 475000, 500000, 525000, 550000, 575000,
+	600000, 625000, 650000, 675000, 700000, 725000, 750000, 775000,
+	800000, 825000, 850000, 875000, 900000, 925000, 950000, 975000,
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000,
+	1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000,
+	1400000, 1425000, 1450000, 1475000, 1500000, 1525000, 1550000, 1575000,
+	1600000, 1625000, 1650000, 1675000, 1700000, 1725000, 1750000, 1775000,
+	1800000, 1825000, 1850000, 1875000, 1900000, 1925000, 1950000, 1975000,
+};
+#endif
+
+#if PFUZE100_SW4_VOL6
+static const int pfuze100_sw4[] = {
+	800000, 850000, 900000, 950000, 1000000, 1050000, 1100000, 1150000,
+	1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000, 3300000, 3300000, 3300000, 3300000, 3300000,
+	3300000, 3300000, 3300000, 3300000, 3300000, 3300000, 3300000, 3950000,
+};
+
+#else
+static const int pfuze100_sw4[] = {
+	400000, 425000, 450000, 475000, 500000, 525000, 550000, 575000,
+	600000, 625000, 650000, 675000, 700000, 725000, 750000, 775000,
+	800000, 825000, 850000, 875000, 900000, 925000, 950000, 975000,
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000,
+	1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000,
+	1400000, 1425000, 1450000, 1475000, 1500000, 1525000, 1550000, 1575000,
+	1600000, 1625000, 1650000, 1675000, 1700000, 1725000, 1750000, 1775000,
+	1800000, 1825000, 1850000, 1875000, 1900000, 1925000, 1950000, 1975000,
+};
+#endif
+
+static const int pfuze100_swbst[] = {
+	5000000, 5050000, 5100000, 5150000,
+};
+
+static const int pfuze100_vsnvs[] = {
+	1200000, 1500000, 1800000, 3000000,
+};
+
+static const int pfuze100_vrefddr[] = {
+	750000,
+};
+
+static const int pfuze100_vgen12[] = {
+
+#ifdef PFUZE100_FIRST_VERSION
+	1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,
+#else
+	800000, 850000, 900000, 950000, 1000000, 1050000, 1100000, 1150000,
+	1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,
+#endif
+};
+
+static const int pfuze100_vgen36[] = {
+	1800000, 1900000, 2000000, 2100000, 2200000, 2300000, 2400000, 2500000,
+	2600000, 2700000, 2800000, 2900000, 3000000, 3100000, 3200000, 3300000,
+};
+
+static struct regulator_ops pfuze100_ldo_regulator_ops;
+static struct regulator_ops pfuze100_fixed_regulator_ops;
+static struct regulator_ops pfuze100_sw_regulator_ops;
+
+#define PFUZE100_FIXED_VOL_DEFINE(name,	reg, voltages)		\
+	PFUZE_FIXED_DEFINE(PFUZE100_, name, reg, voltages,	\
+			pfuze100_fixed_regulator_ops)
+
+#define PFUZE100_SW_DEFINE(name, reg, voltages)	\
+	PFUZE_SW_DEFINE(PFUZE100_, name, reg, voltages,	\
+			pfuze100_sw_regulator_ops)
+
+#define PFUZE100_SWBST_DEFINE(name, reg, voltages)	\
+	PFUZE_SWBST_DEFINE(PFUZE100_, name, reg, voltages,	\
+			pfuze100_sw_regulator_ops)
+
+#define PFUZE100_VGEN_DEFINE(name, reg, voltages)	\
+	PFUZE_DEFINE(PFUZE100_, name, reg, voltages,	\
+			pfuze100_ldo_regulator_ops)
+/* SW1A */
+#define PFUZE100_SW1AVOL	32
+#define PFUZE100_SW1AVOL_VSEL	0
+#define PFUZE100_SW1AVOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1AVOL_STBY	33
+#define PFUZE100_SW1AVOL_STBY_VSEL	0
+#define PFUZE100_SW1AVOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1AOFF	34
+#define PFUZE100_SW1AOFF_OFF_VAL	(0x0<<0)
+#define PFUZE100_SW1AOFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW1AMODE	35
+#define PFUZE100_SW1AMODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW1AMODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW1AMODE_MODE_VAL	0x7	/*Auto */
+#define PFUZE100_SW1AMODE_MODE_M	(0xf<<0)
+
+#define PFUZE100_SW1ACON		36
+#define PFUZE100_SW1ACON_SPEED_VAL	(0x1<<6)	/*default */
+#define PFUZE100_SW1ACON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW1ACON_PHASE_VAL	(0x1<<4)	/*default */
+#define PFUZE100_SW1ACON_PHASE_M	(0x3<<4)
+#define PFUZE100_SW1ACON_FREQ_VAL	(0x1<<2)	/*1Mhz */
+#define PFUZE100_SW1ACON_FREQ_M	(0x3<<2)
+#define PFUZE100_SW1ACON_LIM_VAL	(0x0<<0)	/*2Imax */
+#define PFUZE100_SW1ACON_LIM_M	(0x3<<0)
+
+/*SW1B*/
+#define PFUZE100_SW1BVOL	39
+#define PFUZE100_SW1BVOL_VSEL	0
+#define PFUZE100_SW1BVOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1BVOL_STBY	40
+#define PFUZE100_SW1BVOL_STBY_VSEL	0
+#define PFUZE100_SW1BVOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1BOFF	41
+#define PFUZE100_SW1BOFF_OFF_VAL	0x0
+#define PFUZE100_SW1BOFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW1BMODE	42
+#define PFUZE100_SW1BMODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW1BMODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW1BMODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW1BMODE_MODE_M	(0xf<<0)
+
+#define PFUZE100_SW1BCON		43
+#define PFUZE100_SW1BCON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW1BCON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW1BCON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW1BCON_PHASE_M	(0x3<<4)
+#define PFUZE100_SW1BCON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW1BCON_FREQ_M	(0x3<<2)
+#define PFUZE100_SW1BCON_LIM_VAL	(0x0<<0)
+#define PFUZE100_SW1BCON_LIM_M	(0x3<<0)
+
+/*SW1C*/
+#define PFUZE100_SW1CVOL	46
+#define PFUZE100_SW1CVOL_VSEL	0
+#define PFUZE100_SW1CVOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1CVOL_STBY	47
+#define PFUZE100_SW1CVOL_STBY_VSEL	0
+#define PFUZE100_SW1CVOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW1COFF	48
+#define PFUZE100_SW1COFF_OFF_VAL	0x0
+#define PFUZE100_SW1COFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW1CMODE	49
+#define PFUZE100_SW1CMODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW1CMODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW1CMODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW1CMODE_MODE_M	(0xf<<0)
+
+#define PFUZE100_SW1CCON		50
+#define PFUZE100_SW1CCON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW1CCON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW1CCON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW1CCON_PHASE_M	(0x3<<4)
+#define PFUZE100_SW1CCON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW1CCON_FREQ_M		(0x3<<2)
+#define PFUZE100_SW1CCON_LIM_VAL	(0x0<<0)
+#define PFUZE100_SW1CCON_LIM_M		(0x3<<0)
+
+/*SW2*/
+#define PFUZE100_SW2VOL		53
+#define PFUZE100_SW2VOL_VSEL	0
+#define PFUZE100_SW2VOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW2VOL_STBY		54
+#define PFUZE100_SW2VOL_STBY_VSEL	0
+#define PFUZE100_SW2VOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW2OFF	55
+#define PFUZE100_SW2OFF_OFF_VAL	0x0
+#define PFUZE100_SW2OFF_OFF_M	(0x7f<<0)
+
+#define PFUZE100_SW2MODE	56
+#define PFUZE100_SW2MODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW2MODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW2MODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW2MODE_MODE_M		(0xf<<0)
+
+#define PFUZE100_SW2CON		57
+#define PFUZE100_SW2CON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW2CON_SPEED_M		(0x3<<6)
+#define PFUZE100_SW2CON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW2CON_PHASE_M		(0x3<<4)
+#define PFUZE100_SW2CON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW2CON_FREQ_M		(0x3<<2)
+#define PFUZE100_SW2CON_LIM_VAL		(0x0<<0)
+#define PFUZE100_SW2CON_LIM_M		(0x3<<0)
+
+/*SW3A*/
+#define PFUZE100_SW3AVOL	60
+#define PFUZE100_SW3AVOL_VSEL	0
+#define PFUZE100_SW3AVOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW3AVOL_STBY	61
+#define PFUZE100_SW3AVOL_STBY_VSEL	0
+#define PFUZE100_SW3AVOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW3AOFF	62
+#define PFUZE100_SW3AOFF_OFF_VAL	0x0
+#define PFUZE100_SW3AOFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW3AMODE	63
+#define PFUZE100_SW3AMODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW3AMODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW3AMODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW3AMODE_MODE_M	(0xf<<0)
+
+#define PFUZE100_SW3ACON		64
+#define PFUZE100_SW3ACON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW3ACON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW3ACON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW3ACON_PHASE_M	(0x3<<4)
+#define PFUZE100_SW3ACON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW3ACON_FREQ_M		(0x3<<2)
+#define PFUZE100_SW3ACON_LIM_VAL	(0x0<<0)
+#define PFUZE100_SW3ACON_LIM_M		(0x3<<0)
+
+/*SW3B*/
+#define PFUZE100_SW3BVOL	67
+#define PFUZE100_SW3BVOL_VSEL	0
+#define PFUZE100_SW3BVOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW3BVOL_STBY	68
+#define PFUZE100_SW3BVOL_STBY_VSEL	0
+#define PFUZE100_SW3BVOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW3BOFF	69
+#define PFUZE100_SW3BOFF_OFF_VAL	0x0
+#define PFUZE100_SW3BOFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW3BMODE	70
+#define PFUZE100_SW3BMODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW3BMODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW3BMODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW3BMODE_MODE_M	(0xf<<0)
+
+#define PFUZE100_SW3BCON		71
+#define PFUZE100_SW3BCON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW3BCON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW3BCON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW3BCON_PHASE_M	(0x3<<4)
+#define PFUZE100_SW3BCON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW3BCON_FREQ_M		(0x3<<2)
+#define PFUZE100_SW3BCON_LIM_VAL	(0x0<<0)
+#define PFUZE100_SW3BCON_LIM_M		(0x3<<0)
+
+/*SW4*/
+#define PFUZE100_SW4VOL		74
+#define PFUZE100_SW4VOL_VSEL	0
+#define PFUZE100_SW4VOL_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW4VOL_STBY		75
+#define PFUZE100_SW4VOL_STBY_VSEL	0
+#define PFUZE100_SW4VOL_STBY_VSEL_M	(0x3f<<0)
+
+#define PFUZE100_SW4OFF		76
+#define PFUZE100_SW4OFF_OFF_VAL	0x0
+#define PFUZE100_SW4OFF_OFF_M	(0x3f<<0)
+
+#define PFUZE100_SW4MODE	77
+#define PFUZE100_SW4MODE_OMODE_VAL	(0x0<<5)
+#define PFUZE100_SW4MODE_OMODE_M	(0x1<<5)
+#define PFUZE100_SW4MODE_MODE_VAL	(0x7<<0)
+#define PFUZE100_SW4MODE_MODE_M		(0xf<<0)
+
+#define PFUZE100_SW4CON		78
+#define PFUZE100_SW4CON_SPEED_VAL	(0x1<<6)
+#define PFUZE100_SW4CON_SPEED_M		(0x3<<6)
+#define PFUZE100_SW4CON_PHASE_VAL	(0x1<<4)
+#define PFUZE100_SW4CON_PHASE_M		(0x3<<4)
+#define PFUZE100_SW4CON_FREQ_VAL	(0x1<<2)
+#define PFUZE100_SW4CON_FREQ_M		(0x3<<2)
+#define PFUZE100_SW4CON_LIM_VAL		(0x0<<0)
+#define PFUZE100_SW4CON_LIM_M		(0x3<<0)
+
+ /*SWBST*/
+#define PFUZE100_SWBSTCON1	102
+#define PFUZE100_SWBSTCON1_SWBSTMOD_VAL	(0x1<<2)
+#define PFUZE100_SWBSTCON1_SWBSTMOD_M	(0x3<<2)
+#define PFUZE100_SWBSTCON1_VSEL	0
+#define PFUZE100_SWBSTCON1_VSEL_M	(0x3<<0)
+     /*VREFDDR*/
+#define PFUZE100_VREFDDRCON	106
+#define PFUZE100_VREFDDRCON_EN	(0x1<<4)
+     /*VSNVS*/
+#define PFUZE100_VSNVSVOL		107
+#define PFUZE100_VSNVSVOL_VSEL	0
+#define PFUZE100_VSNVSVOL_VSEL_M	(0x3<<0)
+/*VGEN1*/
+#define PFUZE100_VGEN1VOL		108
+#define PFUZE100_VGEN1VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN1VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN1VOL_VSEL	0
+#ifdef PFUZE100_FIRST_VERSION
+#define PFUZE100_VGEN1VOL_VSEL_M	(0x7<<0)
+#else
+#define PFUZE100_VGEN1VOL_VSEL_M	(0xf<<0)
+#endif
+/*VGEN2*/
+#define PFUZE100_VGEN2VOL		109
+#define PFUZE100_VGEN2VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN2VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN2VOL_VSEL	0
+#ifdef PFUZE100_FIRST_VERSION
+#define PFUZE100_VGEN2VOL_VSEL_M	(0x7<<0)
+#else
+#define PFUZE100_VGEN2VOL_VSEL_M	(0xf<<0)
+#endif
+/*VGEN3*/
+#define PFUZE100_VGEN3VOL		110
+#define PFUZE100_VGEN3VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN3VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN3VOL_VSEL	0
+#define PFUZE100_VGEN3VOL_VSEL_M	(0xf<<0)
+/*VGEN4*/
+#define PFUZE100_VGEN4VOL		111
+#define PFUZE100_VGEN4VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN4VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN4VOL_VSEL	0
+#define PFUZE100_VGEN4VOL_VSEL_M	(0xf<<0)
+/*VGEN5*/
+#define PFUZE100_VGEN5VOL		112
+#define PFUZE100_VGEN5VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN5VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN5VOL_VSEL	0
+#define PFUZE100_VGEN5VOL_VSEL_M	(0xf<<0)
+/*VGEN6*/
+#define PFUZE100_VGEN6VOL		113
+#define PFUZE100_VGEN6VOL_STBY	(0x1<<5)
+#define PFUZE100_VGEN6VOL_EN	(0x1<<4)
+#define PFUZE100_VGEN6VOL_VSEL	0
+#define PFUZE100_VGEN6VOL_VSEL_M	(0xf<<0)
+static struct pfuze_regulator pfuze100_regulators[] = {
+	PFUZE100_SW_DEFINE(SW1A, SW1AVOL, pfuze100_sw1),
+	PFUZE100_SW_DEFINE(SW1B, SW1BVOL, pfuze100_sw1),
+	PFUZE100_SW_DEFINE(SW1C, SW1CVOL, pfuze100_sw1),
+	PFUZE100_SW_DEFINE(SW2, SW2VOL, pfuze100_sw2),
+	PFUZE100_SW_DEFINE(SW3A, SW3AVOL, pfuze100_sw3),
+	PFUZE100_SW_DEFINE(SW3B, SW3BVOL, pfuze100_sw3),
+	PFUZE100_SW_DEFINE(SW4, SW4VOL, pfuze100_sw4),
+	PFUZE100_SWBST_DEFINE(SWBST, SWBSTCON1, pfuze100_swbst),
+	PFUZE100_SWBST_DEFINE(VSNVS, VSNVSVOL, pfuze100_vsnvs),
+	PFUZE100_FIXED_VOL_DEFINE(VREFDDR, VREFDDRCON, pfuze100_vrefddr),
+	PFUZE100_VGEN_DEFINE(VGEN1, VGEN1VOL, pfuze100_vgen12),
+	PFUZE100_VGEN_DEFINE(VGEN2, VGEN2VOL, pfuze100_vgen12),
+	PFUZE100_VGEN_DEFINE(VGEN3, VGEN3VOL, pfuze100_vgen36),
+	PFUZE100_VGEN_DEFINE(VGEN4, VGEN4VOL, pfuze100_vgen36),
+	PFUZE100_VGEN_DEFINE(VGEN5, VGEN5VOL, pfuze100_vgen36),
+	PFUZE100_VGEN_DEFINE(VGEN6, VGEN6VOL, pfuze100_vgen36),
+};
+
+static int pfuze100_regulator_enable(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].enable_bit,
+			    pfuze100_regulators[id].enable_bit);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+}
+
+static int pfuze100_regulator_disable(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].enable_bit, 0);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+}
+
+static int pfuze100_regulator_is_enabled(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+	unsigned char val;
+
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_read(priv->pfuze, pfuze100_regulators[id].reg, &val);
+	pfuze_unlock(priv->pfuze);
+	if (ret)
+		return ret;
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	return (val & pfuze100_regulators[id].enable_bit) != 0;
+}
+
+int pfuze100_regulator_list_voltage(struct regulator_dev *rdev,
+				    unsigned selector)
+{
+	int id = rdev_get_id(rdev);
+
+	if (selector >= pfuze100_regulators[id].desc.n_voltages)
+		return -EINVAL;
+	return pfuze100_regulators[id].voltages[selector];
+}
+
+int pfuze100_get_best_voltage_index(struct regulator_dev *rdev, int min_uV,
+				    int max_uV)
+{
+	int reg_id = rdev_get_id(rdev);
+	int i, bestmatch, bestindex;
+
+	bestmatch = INT_MAX;
+	bestindex = -1;
+	for (i = 0; i < pfuze100_regulators[reg_id].desc.n_voltages; i++) {
+		if (pfuze100_regulators[reg_id].voltages[i] >= min_uV &&
+		    pfuze100_regulators[reg_id].voltages[i] < bestmatch) {
+			bestmatch = pfuze100_regulators[reg_id].voltages[i];
+			bestindex = i;
+		}
+	}
+	if (bestindex < 0 || bestmatch > max_uV) {
+		dev_warn(&rdev->dev, "no possible value for %d<=x<=%d uV\n",
+			 min_uV, max_uV);
+		return -EINVAL;
+	}
+	return bestindex;
+}
+
+EXPORT_SYMBOL_GPL(pfuze100_get_best_voltage_index);
+
+static int
+pfuze100_regulator_set_voltage(struct regulator_dev *rdev, int min_uV,
+			       int max_uV, unsigned *selector)
+{
+
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int value, id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d min_uV: %d max_uV: %d\n",
+		__func__, id, min_uV, max_uV);
+	/* Find the best index */
+	value = pfuze100_get_best_voltage_index(rdev, min_uV, max_uV);
+	dev_dbg(rdev_get_dev(rdev), "%s best value: %d\n", __func__, value);
+	if (value < 0)
+		return value;
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].vsel_mask,
+			    value << pfuze100_regulators[id].vsel_shift);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+
+}
+
+static int pfuze100_regulator_set_voltage_sel(struct regulator_dev *rdev,
+					      unsigned selector)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int  id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d vol: %d\n",
+		__func__, id, pfuze100_regulators[id].voltages[selector]);
+
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].vsel_mask,
+			    selector << pfuze100_regulators[id].vsel_shift);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+}
+
+static int pfuze100_regulator_get_voltage(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int ret, id = rdev_get_id(rdev);
+	unsigned char val;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_read(priv->pfuze, pfuze100_regulators[id].reg, &val);
+	pfuze_unlock(priv->pfuze);
+	if (ret)
+		return ret;
+	val = (val & pfuze100_regulators[id].vsel_mask)
+	    >> pfuze100_regulators[id].vsel_shift;
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d val: %d\n", __func__, id, val);
+	BUG_ON(val > pfuze100_regulators[id].desc.n_voltages);
+	return pfuze100_regulators[id].voltages[val];
+}
+
+static int pfuze100_regulator_get_voltage_sel(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+	unsigned char val;
+
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_read(priv->pfuze, pfuze100_regulators[id].reg, &val);
+	pfuze_unlock(priv->pfuze);
+	if (ret)
+		return ret;
+
+	val &= pfuze100_regulators[id].vsel_mask;
+	val >>= pfuze100_regulators[id].vsel_shift;
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d, vol=%d\n", __func__, id,
+		pfuze100_regulators[id].voltages[val]);
+	return (int) val;
+}
+
+static int pfuze100_regulator_set_voltage_time_sel(struct regulator_dev *rdev,
+					     unsigned int old_sel,
+					     unsigned int new_sel)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+	unsigned char step_delay;
+
+	pfuze_lock(priv->pfuze);
+	/*read SWxDVSSPEED from SWxCONF,got ramp step value*/
+	ret = pfuze_reg_read(priv->pfuze, pfuze100_regulators[id].reg + 0x4,
+				&step_delay);
+	pfuze_unlock(priv->pfuze);
+
+	if (ret)
+		return ret;
+	/*
+	 * one step
+	 * 00: 2us,
+	 * 01: 4us,
+	 * 02: 8us,
+	 * 03: 16us,
+	 */
+	step_delay >>= 5;
+	step_delay &= 0x3;
+	step_delay <<= 1;
+
+	if (pfuze100_regulators[id].voltages[old_sel] <
+		pfuze100_regulators[id].voltages[new_sel])
+		ret = DIV_ROUND_UP(pfuze100_regulators[id].voltages[new_sel] -
+			pfuze100_regulators[id].voltages[old_sel], 25000)
+			* step_delay;
+	else
+		ret = 0; /* no delay if voltage drop */
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d, new_sel = %d, old_sel = %d, \
+		delay = %d\n", __func__, id, new_sel, old_sel, ret);
+	return ret;
+}
+
+static int pfuze100_regulator_ldo_standby_enable(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].stby_bit,
+			    0);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+}
+
+static int pfuze100_regulator_ldo_standby_disable(struct regulator_dev *rdev)
+{
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].reg,
+			    pfuze100_regulators[id].stby_bit,
+			    pfuze100_regulators[id].stby_bit);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+}
+
+static struct regulator_ops pfuze100_ldo_regulator_ops = {
+	.enable = pfuze100_regulator_enable,
+	.disable = pfuze100_regulator_disable,
+	.is_enabled = pfuze100_regulator_is_enabled,
+	.list_voltage = pfuze100_regulator_list_voltage,
+	.set_voltage = pfuze100_regulator_set_voltage,
+	.get_voltage = pfuze100_regulator_get_voltage,
+	.set_suspend_enable = pfuze100_regulator_ldo_standby_enable,
+	.set_suspend_disable = pfuze100_regulator_ldo_standby_disable,
+};
+
+static int pfuze100_fixed_regulator_set_voltage(struct regulator_dev *rdev,
+						int min_uV, int max_uV,
+						unsigned *selector)
+{
+	int id = rdev_get_id(rdev);
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d min_uV: %d max_uV: %d\n",
+		__func__, id, min_uV, max_uV);
+	if (min_uV >= pfuze100_regulators[id].voltages[0] &&
+	    max_uV <= pfuze100_regulators[id].voltages[0])
+		return 0;
+	else
+		return -EINVAL;
+
+}
+
+static int pfuze100_fixed_regulator_get_voltage(struct regulator_dev *rdev)
+{
+	int id = rdev_get_id(rdev);
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);
+	return pfuze100_regulators[id].voltages[0];
+}
+
+static struct regulator_ops pfuze100_fixed_regulator_ops = {
+	.enable = pfuze100_regulator_enable,
+	.disable = pfuze100_regulator_disable,
+	.is_enabled = pfuze100_regulator_is_enabled,
+	.set_voltage = pfuze100_fixed_regulator_set_voltage,
+	.get_voltage = pfuze100_fixed_regulator_get_voltage,
+};
+
+static int pfuze100_sw_regulator_is_enabled(struct regulator_dev *rdev)
+{
+	return 1;
+}
+
+static int
+pfuze100_regulator_sw_standby_voltage(struct regulator_dev *rdev, int uV)
+{
+
+	struct pfuze_regulator_priv *priv = rdev_get_drvdata(rdev);
+	int value, id = rdev_get_id(rdev);
+	int ret;
+
+	dev_dbg(rdev_get_dev(rdev), "%s id: %d set standby: %d\n",
+		__func__, id, uV);
+	/* Find the best index */
+	value = pfuze100_get_best_voltage_index(rdev, uV, uV);
+	if (value < 0)
+		return value;
+	pfuze_lock(priv->pfuze);
+	ret = pfuze_reg_rmw(priv->pfuze, pfuze100_regulators[id].stby_reg,
+			    pfuze100_regulators[id].stby_vsel_mask,
+			    value << pfuze100_regulators[id].stby_vsel_shift);
+	pfuze_unlock(priv->pfuze);
+	return ret;
+
+}
+
+static int pfuze100_regulator_sw_standby_enable(struct regulator_dev *rdev)
+{
+	return 0;
+}
+static int pfuze100_regulator_sw_standby_disable(struct regulator_dev *rdev)
+{
+	return 0;
+}
+static struct regulator_ops pfuze100_sw_regulator_ops = {
+	.is_enabled = pfuze100_sw_regulator_is_enabled,
+	.list_voltage = pfuze100_regulator_list_voltage,
+	.set_voltage_sel = pfuze100_regulator_set_voltage_sel,
+	.get_voltage_sel = pfuze100_regulator_get_voltage_sel,
+	.set_suspend_enable = pfuze100_regulator_sw_standby_enable,
+	.set_suspend_disable = pfuze100_regulator_sw_standby_disable,
+	.set_suspend_voltage = pfuze100_regulator_sw_standby_voltage,
+	.set_voltage_time_sel = pfuze100_regulator_set_voltage_time_sel,
+
+};
+
+static int __devinit pfuze100_regulator_probe(struct platform_device *pdev)
+{
+	struct pfuze_regulator_priv *priv;
+	struct mc_pfuze *pfuze100 = dev_get_drvdata(pdev->dev.parent);
+	struct pfuze_regulator_platform_data *pdata =
+	    dev_get_platdata(&pdev->dev);
+	struct pfuze_regulator_init_data *init_data;
+	int i, ret;
+
+	priv = kzalloc(sizeof(*priv) +
+		       pdata->num_regulators * sizeof(priv->regulators[0]),
+		       GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->pfuze_regulators = pfuze100_regulators;
+	priv->pfuze = pfuze100;
+	pfuze_lock(pfuze100);
+	ret = pdata->pfuze_init(pfuze100);
+	if (ret)
+		goto err_free;
+	pfuze_unlock(pfuze100);
+	for (i = 0; i < pdata->num_regulators; i++) {
+		init_data = &pdata->regulators[i];
+		priv->regulators[i] =
+		    regulator_register(&pfuze100_regulators[init_data->id].desc,
+				       &pdev->dev, init_data->init_data, priv, NULL);
+		if (IS_ERR(priv->regulators[i])) {
+			dev_err(&pdev->dev, "failed to register regulator %s\n",
+				pfuze100_regulators[i].desc.name);
+			ret = PTR_ERR(priv->regulators[i]);
+			goto err;
+		}
+	}
+	platform_set_drvdata(pdev, priv);
+	return 0;
+err:
+	while (--i >= 0)
+		regulator_unregister(priv->regulators[i]);
+err_free:
+	pfuze_unlock(pfuze100);
+	kfree(priv);
+	return ret;
+}
+
+static int __devexit pfuze100_regulator_remove(struct platform_device *pdev)
+{
+	struct pfuze_regulator_priv *priv = platform_get_drvdata(pdev);
+	struct pfuze_regulator_platform_data *pdata =
+	    dev_get_platdata(&pdev->dev);
+	int i;
+
+	platform_set_drvdata(pdev, NULL);
+	for (i = 0; i < pdata->num_regulators; i++)
+		regulator_unregister(priv->regulators[i]);
+
+	kfree(priv);
+	return 0;
+}
+
+static struct platform_driver pfuze100_regulator_driver = {
+	.driver = {
+		   .name = "pfuze100-regulator",
+		   .owner = THIS_MODULE,
+		   },
+	.remove = __devexit_p(pfuze100_regulator_remove),
+	.probe = pfuze100_regulator_probe,
+};
+
+static int __init pfuze100_regulator_init(void)
+{
+	return platform_driver_register(&pfuze100_regulator_driver);
+}
+
+subsys_initcall(pfuze100_regulator_init);
+static void __exit pfuze100_regulator_exit(void)
+{
+	platform_driver_unregister(&pfuze100_regulator_driver);
+}
+
+module_exit(pfuze100_regulator_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Regulator Driver for Freescale PFUZE100 PMIC");
+MODULE_ALIAS("pfuze100-regulator");
-- 
1.7.5.4

