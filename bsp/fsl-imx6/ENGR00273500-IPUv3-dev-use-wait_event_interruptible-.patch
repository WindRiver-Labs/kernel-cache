From 967f8a66b7b45110aef5f6749822d284493e0c92 Mon Sep 17 00:00:00 2001
From: Liu Ying <Ying.Liu@freescale.com>
Date: Thu, 1 Aug 2013 16:32:11 +0800
Subject: [PATCH 0467/1072] ENGR00273500 IPUv3 dev: use
 wait_event_interruptible for ipu task

git://git.freescale.com/imx/linux-2.6-imx.git imx_3.10.17_1.0.0_beta
commit c348ec9cc69a792540b8b394750098cddab2cbc5

The ipu task thread checks outstanding tasks to be done on waiting
event uninterruptibly on the function find_task()'s return value.
However, sleeping on waiting event uninterruptibly contributes to
system load average value. This patch changes wait_event() to
wait_event_interruptible() to avoid the load average value inflation.

Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
(cherry picked from commit ec9479ffc757eaefa9b8d4942c37e3634e15599c)
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
---
 drivers/mxc/ipu3/ipu_device.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index be36e37..5814adb 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -3155,7 +3155,7 @@ static int ipu_task_thread(void *argv)
 		int split_parent;
 		int split_child;
 
-		wait_event(thread_waitq, find_task(&tsk, curr_thread_id));
+		wait_event_interruptible(thread_waitq, find_task(&tsk, curr_thread_id));
 
 		if (!tsk) {
 			pr_err("thread:%d can not find task.\n",
@@ -3207,7 +3207,7 @@ static int ipu_task_thread(void *argv)
 					dev_err(tsk->dev,
 					"ERR: no-0x%x,can not get split_tsk0\n",
 					tsk->task_no);
-				wake_up(&thread_waitq);
+				wake_up_interruptible(&thread_waitq);
 				get_res_do_task(sp_tsk0);
 				dev_dbg(sp_tsk0->dev,
 					"thread:%d complete tsk no:0x%x.\n",
@@ -3311,7 +3311,7 @@ int ipu_queue_task(struct ipu_task *task)
 	tsk->task_in_list = 1;
 	dev_dbg(tsk->dev, "[0x%p,no-0x%x] list_add_tail\n", tsk, tsk->task_no);
 	spin_unlock_irqrestore(&ipu_task_list_lock, flags);
-	wake_up(&thread_waitq);
+	wake_up_interruptible(&thread_waitq);
 
 	ret = wait_event_timeout(tsk->task_waitq, atomic_read(&tsk->done),
 						msecs_to_jiffies(tsk->timeout));
-- 
1.7.5.4

