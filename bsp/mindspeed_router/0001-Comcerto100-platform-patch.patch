From 495d7ca832767c5550bb8e3b8d52e17a115e4e17 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 30 Oct 2008 20:59:16 +0800
Subject: [PATCH] Comcerto100 platform patch.

Comcerto100 processor is not in mainline kernel, add architecture support
for it.

Signed-off-by: Stanley Miao <stanley.miao@windriver.com>
---
 arch/arm/Kconfig                                   |   11 +-
 arch/arm/Makefile                                  |    1 +
 arch/arm/boot/compressed/Makefile                  |    4 +
 arch/arm/boot/compressed/head-comcerto.S           |    6 +
 arch/arm/boot/compressed/head.S                    |    8 +
 arch/arm/include/asm/pci.h                         |    2 +-
 arch/arm/include/asm/spinlock.h                    |   14 +
 arch/arm/mach-comcerto/Kconfig                     |   65 ++
 arch/arm/mach-comcerto/Makefile                    |   20 +
 arch/arm/mach-comcerto/Makefile.boot               |    4 +
 arch/arm/mach-comcerto/board-router.c              |  480 ++++++++++++++
 arch/arm/mach-comcerto/comcerto-100.c              |  529 ++++++++++++++++
 arch/arm/mach-comcerto/comcerto-common.c           |  273 ++++++++
 .../include/mach/boards/board-router.h             |   84 +++
 arch/arm/mach-comcerto/include/mach/comcerto-100.h |  121 ++++
 .../include/mach/comcerto-100/clk-rst.h            |  111 ++++
 .../include/mach/comcerto-100/exp-bus.h            |   88 +++
 .../mach-comcerto/include/mach/comcerto-100/gpio.h |  126 ++++
 .../mach-comcerto/include/mach/comcerto-100/hif.h  |  152 +++++
 .../mach-comcerto/include/mach/comcerto-100/idma.h |   89 +++
 .../mach-comcerto/include/mach/comcerto-100/intr.h |  120 ++++
 .../mach-comcerto/include/mach/comcerto-100/irqs.h |   96 +++
 .../include/mach/comcerto-100/memory.h             |   73 +++
 .../include/mach/comcerto-100/timer.h              |   76 +++
 .../mach-comcerto/include/mach/comcerto-common.h   |  114 ++++
 .../mach-comcerto/include/mach/comcerto-devices.h  |  144 +++++
 arch/arm/mach-comcerto/include/mach/debug-macro.S  |   51 ++
 arch/arm/mach-comcerto/include/mach/debug.h        |   67 ++
 arch/arm/mach-comcerto/include/mach/dma.h          |   28 +
 arch/arm/mach-comcerto/include/mach/entry-macro.S  |   83 +++
 arch/arm/mach-comcerto/include/mach/hardware.h     |   40 ++
 arch/arm/mach-comcerto/include/mach/io.h           |  431 +++++++++++++
 arch/arm/mach-comcerto/include/mach/irqs.h         |   17 +
 arch/arm/mach-comcerto/include/mach/memory.h       |   31 +
 arch/arm/mach-comcerto/include/mach/system.h       |   51 ++
 arch/arm/mach-comcerto/include/mach/timex.h        |   28 +
 arch/arm/mach-comcerto/include/mach/uncompress.h   |   61 ++
 arch/arm/mach-comcerto/include/mach/vmalloc.h      |   21 +
 arch/arm/mach-comcerto/pci-comcerto100.c           |  662 ++++++++++++++++++++
 arch/arm/mach-comcerto/pci-common.c                |  560 +++++++++++++++++
 arch/arm/mm/Kconfig                                |    4 +-
 arch/arm/mm/cache-v6.S                             |   16 +
 42 files changed, 4958 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/boot/compressed/head-comcerto.S
 create mode 100644 arch/arm/mach-comcerto/Kconfig
 create mode 100644 arch/arm/mach-comcerto/Makefile
 create mode 100644 arch/arm/mach-comcerto/Makefile.boot
 create mode 100644 arch/arm/mach-comcerto/board-router.c
 create mode 100644 arch/arm/mach-comcerto/comcerto-100.c
 create mode 100644 arch/arm/mach-comcerto/comcerto-common.c
 create mode 100644 arch/arm/mach-comcerto/include/mach/boards/board-router.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/clk-rst.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/exp-bus.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/gpio.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/hif.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/idma.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/intr.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/irqs.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/memory.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-100/timer.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-common.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-devices.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-comcerto/include/mach/debug.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/dma.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-comcerto/include/mach/hardware.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/io.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/irqs.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/memory.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/system.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/timex.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-comcerto/pci-comcerto100.c
 create mode 100644 arch/arm/mach-comcerto/pci-common.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0e9745d..1a843fc 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -273,6 +273,13 @@ config ARCH_EP93XX
 	help
 	  This enables support for the Cirrus EP93xx series of CPUs.
 
+config ARCH_COMCERTO
+	bool "Mindspeed Comcerto"
+	help
+	  This enables support for Mindspeed's M825xx-1/M825xx-2/m828xx development boards.
+	  If you would like to build your kernel to run on one of these boards
+	  then you must say 'Y' here. Otherwise say 'N'
+
 config ARCH_FOOTBRIDGE
 	bool "FootBridge"
 	select FOOTBRIDGE
@@ -542,6 +549,8 @@ config ARCH_MSM7X00A
 
 endchoice
 
+source "arch/arm/mach-comcerto/Kconfig"
+
 source "arch/arm/mach-clps711x/Kconfig"
 
 source "arch/arm/mach-ep93xx/Kconfig"
@@ -681,7 +690,7 @@ config ISA_DMA_API
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE || ARCH_COMCERTO
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index c3fadbe..2e18190 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -114,6 +114,7 @@ endif
  machine-$(CONFIG_ARCH_IOP33X)	   := iop33x
  machine-$(CONFIG_ARCH_IOP13XX)	   := iop13xx
     plat-$(CONFIG_PLAT_IOP)	   := iop
+ machine-$(CONFIG_ARCH_COMCERTO)   := comcerto
  machine-$(CONFIG_ARCH_IXP4XX)	   := ixp4xx
  machine-$(CONFIG_ARCH_IXP2000)    := ixp2000
  machine-$(CONFIG_ARCH_IXP23XX)    := ixp23xx
diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index b6f8502..fcc4da5 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -40,6 +40,10 @@ ifeq ($(CONFIG_CPU_XSCALE),y)
 OBJS		+= head-xscale.o
 endif
 
+ifeq ($(CONFIG_ARCH_COMCERTO),y)
+OBJS		+= head-comcerto.o
+endif
+
 ifeq ($(CONFIG_PXA_SHARPSL),y)
 OBJS		+= head-sharpsl.o
 endif
diff --git a/arch/arm/boot/compressed/head-comcerto.S b/arch/arm/boot/compressed/head-comcerto.S
new file mode 100644
index 0000000..e48f6e6
--- /dev/null
+++ b/arch/arm/boot/compressed/head-comcerto.S
@@ -0,0 +1,6 @@
+#include <asm/mach-types.h>
+
+	.section	".start", "ax"
+	ldr	r7,mach_type
+
+mach_type:     .word    MACH_TYPE_COMCERTO
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index d42f89b..502ffc8 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -52,6 +52,14 @@
 		add	\rb, \rb, #0x00010000	@ Ser1
 #endif
 		.endm
+#elif defined(CONFIG_ARCH_COMCERTO)
+		.macro	loadsp, rb
+		mov	\rb, #0x10000000
+		orr	\rb, \rb, #0x00090000
+		.endm
+		.macro	writeb, rb
+		strb	\rb, [r3, #0]
+		.endm
 #elif defined(CONFIG_ARCH_S3C2410)
 		.macro loadsp, rb
 		mov	\rb, #0x50000000
diff --git a/arch/arm/include/asm/pci.h b/arch/arm/include/asm/pci.h
index 918d0cb..ffff6f5 100644
--- a/arch/arm/include/asm/pci.h
+++ b/arch/arm/include/asm/pci.h
@@ -8,7 +8,7 @@
 
 #define pcibios_scan_all_fns(a, b)	0
 
-#ifdef CONFIG_PCI_HOST_ITE8152
+#if defined(CONFIG_PCI_HOST_ITE8152) || defined(CONFIG_ARCH_COMCERTO)
 /* ITE bridge requires setting latency timer to avoid early bus access
    termination by PIC bus mater devices
 */
diff --git a/arch/arm/include/asm/spinlock.h b/arch/arm/include/asm/spinlock.h
index 2b41ebb..242b822 100644
--- a/arch/arm/include/asm/spinlock.h
+++ b/arch/arm/include/asm/spinlock.h
@@ -31,7 +31,10 @@ static inline void __raw_spin_lock(raw_spinlock_t *lock)
 "1:	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
 #ifdef CONFIG_CPU_32v6K
+"	itee	ne\n"
 "	wfene\n"
+#else
+"	itt	eq\n"
 #endif
 "	strexeq	%0, %2, [%1]\n"
 "	teqeq	%0, #0\n"
@@ -50,6 +53,7 @@ static inline int __raw_spin_trylock(raw_spinlock_t *lock)
 	__asm__ __volatile__(
 "	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
+"	it	eq\n"
 "	strexeq	%0, %2, [%1]"
 	: "=&r" (tmp)
 	: "r" (&lock->lock), "r" (1)
@@ -94,7 +98,10 @@ static inline void __raw_write_lock(raw_rwlock_t *rw)
 "1:	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
 #ifdef CONFIG_CPU_32v6K
+"	itee	ne\n"
 "	wfene\n"
+#else
+"	itt	eq\n"
 #endif
 "	strexeq	%0, %2, [%1]\n"
 "	teq	%0, #0\n"
@@ -113,6 +120,7 @@ static inline int __raw_write_trylock(raw_rwlock_t *rw)
 	__asm__ __volatile__(
 "1:	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
+"	it	eq\n"
 "	strexeq	%0, %2, [%1]"
 	: "=&r" (tmp)
 	: "r" (&rw->lock), "r" (0x80000000)
@@ -163,6 +171,11 @@ static inline void __raw_read_lock(raw_rwlock_t *rw)
 	__asm__ __volatile__(
 "1:	ldrex	%0, [%2]\n"
 "	adds	%0, %0, #1\n"
+#ifdef CONFIG_CPU_32v6K
+"	itet	pl\n"
+#else
+"	itt	pl\n"
+#endif
 "	strexpl	%1, %0, [%2]\n"
 #ifdef CONFIG_CPU_32v6K
 "	wfemi\n"
@@ -190,6 +203,7 @@ static inline void __raw_read_unlock(raw_rwlock_t *rw)
 "	bne	1b"
 #ifdef CONFIG_CPU_32v6K
 "\n	cmp	%0, #0\n"
+"	itt	eq\n"
 "	mcreq   p15, 0, %0, c7, c10, 4\n"
 "	seveq"
 #endif
diff --git a/arch/arm/mach-comcerto/Kconfig b/arch/arm/mach-comcerto/Kconfig
new file mode 100644
index 0000000..379c3d8
--- /dev/null
+++ b/arch/arm/mach-comcerto/Kconfig
@@ -0,0 +1,65 @@
+if ARCH_COMCERTO
+
+menu "Comcerto Implementation Options"
+
+choice
+	prompt "Comcerto System Type"
+	default ARCH_M821XX
+
+config ARCH_M821XX
+	bool "M821xx"
+	help
+	  Say Y here if you intend to run this kernel with a Dali device.
+
+endchoice
+
+
+choice
+	prompt "Comcerto Board type"
+	default EVM_ROUTER
+
+config EVM_ROUTER
+	bool "Router"
+	depends on ARCH_M821XX
+	help
+	  Say Y here if you intend to run this kernel with a Router board.
+
+config EVM_PACKET_IAD
+	bool "Packet IAD"
+	depends on ARCH_M821XX
+	help
+	  Say Y here if you intend to run this kernel with a Packet IAD board.
+
+config EVM_FEROUTER
+	bool "FE Router"
+	depends on ARCH_M821XX
+	help
+	  Say Y here if you intend to run this kernel with a FastEthernet Router board.
+
+endchoice
+
+config COMCERTO_PCI_USE_APBB
+	bool "PCI Direct access through APBB"
+	depends on PCI && ARCH_M821XX
+	default n
+
+config COMCERTO_PCI_SINGLE_ACCESS_TYPE
+	bool "HOST PCI does only Memory access through APBB"
+	depends on COMCERTO_PCI_USE_APBB
+	default n
+	help
+	  This is highly experimental. The idea is to configure the PCI
+	  in direct access mode and for one access type (ie memory access).
+	  This setting remove all the write/read and io_remap redirection done
+	  in io.h file. In order to use this mode, the PCI driver MUST only do
+	  memory accesses.
+	  If your are not sure just say no.
+
+config COMCERTO_PCI_DEBUG
+	bool "PCI Debugging"
+	depends on PCI
+	default n
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-comcerto/Makefile b/arch/arm/mach-comcerto/Makefile
new file mode 100644
index 0000000..72aeb9e
--- /dev/null
+++ b/arch/arm/mach-comcerto/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+
+# Object file lists.
+
+obj-y 									+= comcerto-common.o
+obj-$(CONFIG_ARCH_M821XX) 			+= comcerto-100.o
+
+obj-$(CONFIG_EVM_ROUTER) 			+= board-router.o
+
+ifeq ($(CONFIG_PCI),y)
+	obj-y += pci-common.o
+	obj-$(CONFIG_ARCH_M821XX) 		+= pci-comcerto100.o
+endif
+
diff --git a/arch/arm/mach-comcerto/Makefile.boot b/arch/arm/mach-comcerto/Makefile.boot
new file mode 100644
index 0000000..5ad2307
--- /dev/null
+++ b/arch/arm/mach-comcerto/Makefile.boot
@@ -0,0 +1,4 @@
+ifeq ($(CONFIG_ARCH_M821XX),y)
+   zreladdr-y     := 0x80808000
+   params_phys-y  := 0x80800100
+endif
diff --git a/arch/arm/mach-comcerto/board-router.c b/arch/arm/mach-comcerto/board-router.c
new file mode 100644
index 0000000..4b08ae4
--- /dev/null
+++ b/arch/arm/mach-comcerto/board-router.c
@@ -0,0 +1,480 @@
+/*
+ * linux/arch/arm/mach-comcerto/board-router.c
+ *
+ *  Copyright (C) 2004,2007  Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/memory.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+
+#include <mach/hardware.h>
+#include <mach/comcerto-devices.h>
+#include <mach/irqs.h>
+
+extern void comcerto_map_io(void);
+extern void comcerto_init_irq(void);
+extern struct sys_timer comcerto_timer;
+extern void device_init(void);
+
+/************************************************************************
+ * Ressources declaration
+ *
+ ************************************************************************/
+
+/*********************
+ *  Serial interface
+ *********************/
+static struct resource comcerto_uart_resources[] = {
+	{
+	.start = COMCERTO_APB_UART0_BASE,
+	.end = COMCERTO_APB_UART0_BASE + SZ_16K - 1,
+	.flags = IORESOURCE_MEM
+	},
+#if defined(CONFIG_SERIAL_COMCERTO_2ND_UART)
+	{
+	.start = COMCERTO_APB_UART1_BASE,
+	.end = COMCERTO_APB_UART1_BASE + SZ_16K - 1,
+	.flags = IORESOURCE_MEM
+	}
+#endif
+};
+
+static struct plat_serial8250_port comcerto_uart_data[] = {
+	{
+		.mapbase	= COMCERTO_APB_UART0_BASE,
+		.membase	= (char *)APB_VADDR(COMCERTO_APB_UART0_BASE),
+		.irq	= IRQ_UART0 + 32,
+		.flags	= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype	= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= COMCERTO_AHBCLK * 1000 * 1000,
+	},
+#if defined(CONFIG_SERIAL_8250_COMCERTO_2ND_UART) || \
+	defined(CONFIG_SERIAL_COMCERTO_2ND_UART)
+	{
+		.mapbase	= COMCERTO_APB_UART1_BASE,
+		.membase	= (char *)APB_VADDR(COMCERTO_APB_UART1_BASE),
+		.irq	= IRQ_UART1 + 32,
+		.flags	= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype	= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= COMCERTO_AHBCLK * 1000 * 1000,
+	},
+#endif
+	{ },
+};
+
+static struct platform_device comcerto_uart = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data	= comcerto_uart_data,
+	},
+#if defined(CONFIG_SERIAL_COMCERTO_2ND_UART)
+		.num_resources		= 2,
+#else
+		.num_resources		= 1,
+#endif
+	.resource		= comcerto_uart_resources
+};
+
+/*********************
+ *  NOR Flash
+ *********************/
+static struct flash_platform_data router_flash_data = {
+  .map_name	= "cfi_probe",
+  .width	= 2,
+};
+
+static struct resource router_flash_resource = {
+  .start	= NORFLASH_MEMORY_PHY1,
+  .end		= NORFLASH_MEMORY_PHY1 + SZ_16M - 1,
+  .flags	= IORESOURCE_MEM,
+};
+
+static struct platform_device router_flash_device = {
+  .name		= "comcertoflash",
+  .id		= 0,
+   .dev		= {
+    .platform_data	= &router_flash_data,
+  },
+  .num_resources	= 1,
+  .resource	= &router_flash_resource,
+};
+
+/*********************
+ *  NAND / SmartMedia
+ *********************/
+static struct resource comcerto_nand_resources[] = {
+	{
+		.start	= COMCERTO_NAND_FIO_ADDR,
+		.end	= COMCERTO_NAND_FIO_ADDR + COMCERTO_NAND_IO_SZ - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device comcerto_nand_device = {
+	.name		= "comcertonand",
+	.id		= -1,
+	.dev		= {
+				.platform_data	= NULL,
+	},
+	.resource	= comcerto_nand_resources,
+	.num_resources	= ARRAY_SIZE(comcerto_nand_resources),
+};
+
+/*****************************************
+ *  EHCI (USB high speed host controller)
+ *****************************************/
+static struct resource ehci_m821xx_usb0_resources[] = {
+	[0] = {
+		.start  = COMCERTO_AHB_USB0_BASE,
+		.end    = COMCERTO_AHB_USB0_BASE + SZ_8M - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB0,
+		.end  = IRQ_USB0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ehci_m821xx_usb1_resources[] = {
+	[0] = {
+		.start  = COMCERTO_AHB_USB1_BASE,
+		.end    = COMCERTO_AHB_USB1_BASE + SZ_8M - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB1,
+		.end  = IRQ_USB1,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static u64 ehci_dmamask = 0xfffff000;
+static struct platform_device ehci_m821xx_usb0_device = {
+	.name		= "m821xx-ehci",
+	.id		= 1,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ehci_m821xx_usb0_resources),
+	.resource	= ehci_m821xx_usb0_resources,
+};
+
+static struct platform_device ehci_m821xx_usb1_device = {
+	.name		= "m821xx-ehci",
+	.id		= 2,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ehci_m821xx_usb1_resources),
+	.resource	= ehci_m821xx_usb1_resources,
+};
+
+/*********************
+ * IPsec
+ *********************/
+
+static struct resource comcerto_elp_resources[] = {
+	{
+		.name		= "elp",
+		.start		= COMCERTO_IPSEC_BASE,
+		.end		= COMCERTO_IPSEC_BASE + SZ_16M  - 1,
+		.flags		= IORESOURCE_MEM
+	},
+	{
+		.name		= "irq_wrp",
+		.start		= IRQ_IPSEC_WRAP,
+		.end		= IRQ_IPSEC_WRAP,
+		.flags		= IORESOURCE_IRQ
+	},
+	{
+		.name		= "aram",
+		.start		= COMCERTO_ARAM_BASE + ARAM_MEMORY_SIZE - SZ_8K,
+		.end		= COMCERTO_ARAM_BASE + ARAM_MEMORY_SIZE - 1,
+		.flags		= IORESOURCE_MEM
+	}
+};
+
+static struct platform_device  comcerto_elp_device = {
+	.name			= "Elliptic-IPsec EAOE",
+	.id			= 0,
+	.num_resources		= 3,
+	.resource		= comcerto_elp_resources,
+	.dev = {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+};
+/* --------------------------------------------------------------------
+ *  Network
+ * -------------------------------------------------------------------- */
+
+u8 eth0_def_mac[6] = { 0x00, 0xED, 0xCD, 0xEF, 0xAA, 0xCC };
+u8 eth2_def_mac[6] = { 0x00, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E };
+
+struct comcerto_eth_platform_data comcerto_gem0_pdata = {
+	.name = "eth0",
+	.mii_config = CONFIG_COMCERTO_USE_RGMII,
+	.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX | GEMAC_SW_SPEED_1G,
+	.phy_flags = GEMAC_PHY_1000 | GEMAC_PHY_RGMII_ADD_DELAY ,
+	.bus_id = "0",
+	.phy_id = 0,
+	.gem_id = 0,
+	.mac_addr = (u8[]){ 0x00, 0xED, 0xCD, 0xEF, 0xAA, 0xCC },
+};
+
+struct comcerto_eth_platform_data comcerto_gem1_pdata = {
+	.name = "eth2",
+	.mii_config = CONFIG_COMCERTO_USE_RGMII,
+	.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX | GEMAC_SW_SPEED_1G,
+	.phy_flags = GEMAC_PHY_1000 | GEMAC_NO_PHY ,
+	.bus_id = "1",
+	.phy_id = 0,
+	.gem_id = 1,
+	.mac_addr = (u8[]){ 0x00, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E },
+};
+
+
+static struct platform_device comcerto_eth0_device = {
+	.name	= "comcerto-eth",
+	.id	= 0,
+	.dev.platform_data = &comcerto_gem0_pdata,
+	.num_resources	 = 6,
+	.resource = (struct resource[]) {
+		{
+			.name	= "gemac",
+			.start	= COMCERTO_APB_EMAC0_BASE,
+			.end		= COMCERTO_APB_EMAC0_BASE + SZ_64K - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "idma",
+			.start	= COMCERTO_APB_EDMA0_BASE,
+			.end		= COMCERTO_APB_EDMA0_BASE + 0x1FF,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "aram",
+			.start	= COMCERTO_ARAM_BASE + SZ_4K,
+			.end	= COMCERTO_ARAM_BASE + SZ_16K - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "rx",
+			.start	= IRQ_EDMA0RX,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.name	= "tx",
+			.start	= IRQ_EDMA0TX,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.name	= "gemac",
+			.start	= IRQ_EMAC0,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static struct platform_device comcerto_eth1_device = {
+	.name	= "comcerto-eth",
+	.id	= 1,
+	.dev.platform_data = &comcerto_gem1_pdata,
+	.num_resources	 = 6,
+	.resource = (struct resource[]) {
+		{
+			.name	= "gemac",
+			.start	= COMCERTO_APB_EMAC1_BASE,
+			.end		= COMCERTO_APB_EMAC1_BASE + SZ_64K - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "idma",
+			.start	= COMCERTO_APB_EDMA1_BASE,
+			.end		= COMCERTO_APB_EDMA1_BASE + 0x1FF,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "aram",
+			.start	= COMCERTO_ARAM_BASE + SZ_16K,
+			.end	= COMCERTO_ARAM_BASE + SZ_16K + 1024*12 - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "rx",
+			.start	= IRQ_EDMA1RX,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.name	= "tx",
+			.start	= IRQ_EDMA1TX,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.name	= "gemac",
+			.start	= IRQ_EMAC1,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+
+static struct comcerto_mdio_data comcerto_mdio0_pdata = {
+	.phy_mask = 0xFFFFFFFE,
+};
+
+static struct comcerto_mdio_data comcerto_mdio1_pdata = {
+	.phy_mask = 0xFFFFFFFE,
+};
+
+
+static struct platform_device comcerto_mdio0_device = {
+	.name	= "comcerto-mdio",
+	.id		= 0,
+	.dev.platform_data = &comcerto_mdio0_pdata,
+	.num_resources	= 1,
+	.resource = (struct resource[]) {
+		{
+			.start	= COMCERTO_APB_EMAC0_BASE + 0xE000,
+			.end		= COMCERTO_APB_EMAC0_BASE + 0xE400 - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+static struct platform_device comcerto_mdio1_device = {
+	.name	= "comcerto-mdio",
+	.id		= 1,
+	.dev.platform_data = &comcerto_mdio1_pdata,
+	.num_resources	= 1,
+	.resource = (struct resource[]) {
+		{
+			.start	= COMCERTO_APB_EMAC1_BASE + 0xE000,
+			.end		= COMCERTO_APB_EMAC1_BASE + 0xE400 - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+/*********************
+ *  Global
+ *********************/
+static struct platform_device *router_devices[] __initdata = {
+	&router_flash_device,
+	&comcerto_uart,
+	&ehci_m821xx_usb0_device,
+	&ehci_m821xx_usb1_device,
+	&comcerto_elp_device,
+	&comcerto_mdio0_device,
+	&comcerto_eth0_device,
+	&comcerto_mdio1_device,
+	&comcerto_eth1_device,
+	&comcerto_nand_device,
+};
+
+
+
+/************************************************************************
+ *  Expansion bus
+ *
+ ************************************************************************/
+/* This variable is used by comcerto-100.c to initialize the expansion bus */
+int comcerto_exp_values[5][6] = {
+	/* ENABLE, SEG_SZ, CFG, TMG1, TMG2, TMG3 */
+	{1, 0x7FF, EXP_MEM_BUS_SIZE_16, 0x1A1A401F, 0x06060A04, 0x00000002},
+	{0, 0x3FF, EXP_RDY_EN|EXP_MEM_BUS_SIZE_32, 0x1A1A401F, 0x06060A04, \
+								0x00000002},
+	{0, 0x3FF, 0x200, 0x1A1A401F, 0x06060A04, 0x00000002},
+	{0, 0x3FF, 0x200, 0x1A1A401F, 0x06060A04, 0x00000002},
+	{1, 0x000, EXP_NAND_MODE|EXP_MEM_BUS_SIZE_8, 0x1A1A401F, 0x06060A04, \
+								0x00000002},
+};
+
+/************************************************************************
+ *  Machine definition
+ *
+ ************************************************************************/
+static void __init comcerto_router_map_io(void)
+{
+	comcerto_map_io();
+}
+
+static void __init comcerto_router_init_irq(void)
+{
+	comcerto_init_irq();
+}
+
+static void __init comcerto_router_init(void)
+{
+
+	device_init();
+
+	/* Enable SPI block*/
+	 /*Unlock COMCERTO_GPIO_IOCTRL_REG register write access*/
+	__raw_writel(0x55555555, COMCERTO_GPIO_LOCK_REG);
+	__raw_writel(__raw_readl(COMCERTO_GPIO_IOCTRL_REG) | SPI_BUS, \
+						COMCERTO_GPIO_IOCTRL_REG);
+
+	/* In order legerity driver to detect slic,
+	 * TDM and frame sync must be set*/
+
+	/* Configure TDM FSync as an output */
+	__raw_writel(__raw_readl(COMCERTO_GPIO_PAD_CTRL) | 0x4, \
+			COMCERTO_GPIO_PAD_CTRL);
+	/* Set TDM CLock freq to 2MHz */
+	__raw_writel(0x832d70d7, COMCERTO_CLK_TDM_CLK_CNTRL);
+	/* Set Fsync freq to 8KHz */
+	__raw_writel(0x20FF0001, COMCERTO_CLK_FSYNC_CNTRL);
+
+	/*USB PHYs and UART loopback*/
+	__raw_writel(0, COMCERTO_GPIO_GENERAL_CONTROL_REG);
+
+	platform_add_devices(router_devices, ARRAY_SIZE(router_devices));
+}
+
+MACHINE_START(COMCERTO, "Router board")
+.phys_io      = APB_PADDR_BASE,
+	.io_pg_offst  = ((APB_PADDR_BASE) >> 18) & 0xfffc,
+	.boot_params  = COMCERTO_SDRAM_BASE + 0x100,
+	.map_io       = comcerto_router_map_io,
+	.init_irq     = comcerto_router_init_irq,
+	.init_machine = comcerto_router_init,
+	.timer	= &comcerto_timer,
+MACHINE_END
diff --git a/arch/arm/mach-comcerto/comcerto-100.c b/arch/arm/mach-comcerto/comcerto-100.c
new file mode 100644
index 0000000..3311a57
--- /dev/null
+++ b/arch/arm/mach-comcerto/comcerto-100.c
@@ -0,0 +1,529 @@
+/*
+ *  linux/arch/arm/mach-comcerto/comcerto-100.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/kernel_stat.h>
+
+#include <mach/hardware.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <mach/comcerto-devices.h>
+#if defined(CONFIG_CACHE_L2X0)
+#include <asm/hardware/cache-l2x0.h>
+#endif
+
+struct irq_table {
+	unsigned int irq;
+	irq_flow_handler_t handle;
+	unsigned int prio;
+};
+
+extern int noirqdebug;
+/***********************************************************
+ *   Virtual address Mapping                               *
+ *                                                         *
+ ***********************************************************/
+
+static struct map_desc comcerto_io_desc[] __initdata =
+{
+	/* ARAM */
+	{ARAM_MEMORY_VADDR, \
+		__phys_to_pfn(COMCERTO_ARAM_BASE), ARAM_MEMORY_SIZE, \
+							MT_DEVICE},
+	/* SDRAM used by MSP*/
+	{SDRAM_MSP_MEMORY_VADDR, \
+		__phys_to_pfn(SDRAM_MSP_MEMORY_PHY), SDRAM_MSP_MEMORY_SIZE, \
+							MT_DEVICE},
+	/* Block on APB bus */
+	{APB_VADDR(COMCERTO_APB_PHI_BASE), \
+		__phys_to_pfn(COMCERTO_APB_PHI_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_TIMER_BASE), \
+		__phys_to_pfn(COMCERTO_APB_TIMER_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_GPIO_BASE), \
+		__phys_to_pfn(COMCERTO_APB_GPIO_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_UART0_BASE), \
+		__phys_to_pfn(COMCERTO_APB_UART0_BASE), SZ_16K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_UART1_BASE), \
+		__phys_to_pfn(COMCERTO_APB_UART1_BASE), SZ_16K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_SPI_BASE), \
+		__phys_to_pfn(COMCERTO_APB_SPI_BASE), SZ_16K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_I2C_BASE), \
+		__phys_to_pfn(COMCERTO_APB_I2C_BASE), SZ_16K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_INTC_BASE), \
+		__phys_to_pfn(COMCERTO_APB_INTC_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_CLK_BASE), \
+		__phys_to_pfn(COMCERTO_APB_CLK_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_EMAC0_BASE), \
+		__phys_to_pfn(COMCERTO_APB_EMAC0_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_EMAC1_BASE), \
+		__phys_to_pfn(COMCERTO_APB_EMAC1_BASE), SZ_64K, MT_DEVICE},
+	/* Mapped by EMAC driver and MSP */
+	{APB_VADDR(COMCERTO_APB_IDMA_BASE), \
+		__phys_to_pfn(COMCERTO_APB_IDMA_BASE), SZ_64K, MT_DEVICE},
+	{APB_VADDR(COMCERTO_APB_EXPBUS_BASE), \
+		__phys_to_pfn(COMCERTO_APB_EXPBUS_BASE), SZ_64K, MT_DEVICE},
+	{COMCERTO_IPSEC_VADDR_BASE , \
+		__phys_to_pfn(COMCERTO_IPSEC_BASE), SZ_16M, MT_DEVICE},
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB) && \
+	!defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE)
+	{COMCERTO_PCI_MEM_VBASE, \
+		__phys_to_pfn(COMCERTO_HIF_BASE), SZ_128M, MT_DEVICE},
+#endif
+#if defined(CONFIG_CACHE_L2X0)
+	{COMCERTO_L2CC_VADDR_BASE, \
+		__phys_to_pfn(COMCERTO_L2CC_BASE), SZ_4K, MT_DEVICE},
+#endif
+};
+
+void __init comcerto_map_io(void)
+{
+	iotable_init(comcerto_io_desc, ARRAY_SIZE(comcerto_io_desc));
+}
+
+/***********************************************************
+ *   IRQs                                                  *
+ *                                                         *
+ ***********************************************************/
+void comcerto_handle_gpio_irq(unsigned int irq, struct irq_desc *desc)
+{
+	u32 pending;
+	/*
+	 * Mask IRQ.
+	 */
+	desc->chip->mask(irq);
+
+	do {
+		handle_simple_irq(irq, desc);
+		/*
+		 * Ack IRQ.
+		 */
+		desc->chip->ack(irq);
+		/*
+		 * Source interrupts are usually active low
+		 */
+		pending = comcerto_gpio_read(1 << ((irq - 1) % 32)) ? 0 : 1;
+
+	} while (pending);
+
+	/*
+	 * UnMask IRQ.
+	 */
+	desc->chip->unmask(irq);
+}
+
+void
+comcerto_handle_secondary_level_irq(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int cpu = smp_processor_id();
+	struct irqaction *action;
+	irqreturn_t action_ret;
+
+	spin_lock(&desc->lock);
+	desc->chip->mask(irq);
+
+	if (unlikely(desc->status & IRQ_INPROGRESS))
+		goto out_unlock;
+	desc->status &= ~(IRQ_REPLAY | IRQ_WAITING);
+	kstat_cpu(cpu).irqs[irq]++;
+
+	/*
+	 * If its disabled or no action available
+	 * keep it masked and get out of here
+	 */
+	action = desc->action;
+	if (unlikely(!action || (desc->status & IRQ_DISABLED))) {
+		desc->status |= IRQ_PENDING;
+		goto out_unlock;
+	}
+
+	desc->status |= IRQ_INPROGRESS;
+	desc->status &= ~IRQ_PENDING;
+	spin_unlock(&desc->lock);
+
+	action_ret = handle_IRQ_event(irq, action);
+	if (!noirqdebug)
+		note_interrupt(irq, desc, action_ret);
+
+	spin_lock(&desc->lock);
+	desc->status &= ~IRQ_INPROGRESS;
+
+	desc->chip->ack(irq);
+
+	if (!(desc->status & IRQ_DISABLED) && desc->chip->unmask)
+		desc->chip->unmask(irq);
+out_unlock:
+	spin_unlock(&desc->lock);
+}
+
+
+static void comcerto_irq_mask_0(unsigned int irq)
+{
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_0) & ~(1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_0);
+}
+
+static void comcerto_irq_ack_0(unsigned int irq)
+{
+	__raw_writel(1UL << irq, COMCERTO_INTC_STATUS_REG_0);
+}
+
+static void comcerto_irq_mask_ack_0(unsigned int irq)
+{
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_0) & ~(1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_0);
+	__raw_writel(1UL << irq, COMCERTO_INTC_STATUS_REG_0);
+}
+
+static void comcerto_irq_unmask_0(unsigned int irq)
+{
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_0) | (1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_0);
+}
+
+static int comcerto_set_irq_type_0(unsigned int irq, unsigned int type)
+{
+	return 0;
+}
+
+static void comcerto_irq_mask_1(unsigned int irq)
+{
+	irq -= 32;
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_1) & ~(1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_1);
+}
+
+static void comcerto_irq_ack_1(unsigned int irq)
+{
+	irq -= 32;
+	__raw_writel(1UL << irq, COMCERTO_INTC_STATUS_REG_1);
+}
+
+static void comcerto_irq_mask_ack_1(unsigned int irq)
+{
+	irq -= 32;
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_1) & ~(1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_1);
+	__raw_writel(1UL << irq, COMCERTO_INTC_STATUS_REG_1);
+}
+
+static void comcerto_irq_unmask_1(unsigned int irq)
+{
+	irq -= 32;
+	__raw_writel(__raw_readl(COMCERTO_INTC_CSP_IRQMASK_1) | (1UL << irq), \
+						COMCERTO_INTC_CSP_IRQMASK_1);
+}
+
+static int comcerto_set_irq_type_1(unsigned int irq, unsigned int type)
+{
+	return 0;
+}
+
+static struct irq_chip comcerto_irq_chip_0 = {
+	.name		= "COMCERTO100 IC0",
+	.ack		= comcerto_irq_ack_0,
+	.mask		= comcerto_irq_mask_0,
+	.unmask		= comcerto_irq_unmask_0,
+	.set_type	= comcerto_set_irq_type_0,
+	.mask_ack	= comcerto_irq_mask_ack_0,
+};
+
+static struct irq_chip comcerto_irq_chip_1 = {
+	.name		= "COMCERTO100 IC1",
+	.ack		= comcerto_irq_ack_1,
+	.mask		= comcerto_irq_mask_1,
+	.unmask		= comcerto_irq_unmask_1,
+	.set_type	= comcerto_set_irq_type_1,
+	.mask_ack	= comcerto_irq_mask_ack_1,
+};
+
+/* IRQ configuration table */
+static struct irq_table comcerto_irq_table[] __initdata =
+{
+	{IRQ_EDMA0RX,		handle_simple_irq,			0},
+	{IRQ_EDMA1RX,		handle_simple_irq,			1},
+	{IRQ_EDMA0TX,		handle_simple_irq,			2},
+	{IRQ_EDMA1TX,		handle_simple_irq,			3},
+	{IRQ_USB0,		comcerto_handle_secondary_level_irq,	4},
+#ifndef CONFIG_ARCH_M822XX
+	{IRQ_USB1,		comcerto_handle_secondary_level_irq,	5},
+#endif
+	{IRQ_HIF,		comcerto_handle_secondary_level_irq,	6},
+	{STATUS_REG_1,		NULL,					7},
+	{IRQ_PTP0,		handle_level_irq,			8},
+	{IRQ_TIMERB,		comcerto_handle_secondary_level_irq,	9},
+	{IRQ_SPI,		comcerto_handle_secondary_level_irq,	10},
+	{IRQ_EMAC0,		comcerto_handle_secondary_level_irq,	11},
+	{IRQ_EMAC1,		comcerto_handle_secondary_level_irq,	12},
+	{IRQ_IPSEC_WRAP,	comcerto_handle_secondary_level_irq,	13},
+	{IRQ_APBB,		comcerto_handle_secondary_level_irq,	14},
+	{32 + IRQ_CSP_PMU,	handle_level_irq,			-1},
+	{32 + IRQ_UART1,	comcerto_handle_secondary_level_irq,	-1},
+	{32 + IRQ_UART0,	comcerto_handle_secondary_level_irq,	-1},
+	{32 + IRQ_G2,		comcerto_handle_gpio_irq,		-1},
+	{32 + IRQ_G1,		comcerto_handle_gpio_irq,		-1},
+	{32 + IRQ_G0,		comcerto_handle_gpio_irq,		-1},
+	{32 + IRQ_FPP,		handle_level_irq,			-1},
+	{32 + IRQ_VDMA1_TX,	handle_level_irq,			-1},
+	{32 + IRQ_VDMA1_RX,	handle_level_irq,			-1},
+	{32 + IRQ_VDMA0_TX,	handle_level_irq,			-1},
+	{32 + IRQ_VDMA0_RX,	handle_level_irq,			-1},
+	{32 + IRQ_TOFPP_DMA,	handle_level_irq,			-1}
+};
+
+
+/*********************************
+ * void comcerto_init_irq (void)
+ *
+ * Called by kernel
+ *
+ *********************************/
+void __init comcerto_init_irq(void)
+{
+	unsigned int irq, prio;
+	u32 prio_reg, prio_off, prio_mask;
+	int i;
+
+	/* Mask all interrupts */
+	__raw_writel(0, COMCERTO_INTC_CSP_IRQMASK_0);
+	__raw_writel(0, COMCERTO_INTC_CSP_IRQMASK_1);
+
+	for (i = 0; i < ARRAY_SIZE(comcerto_irq_table); i++) {
+		irq = comcerto_irq_table[i].irq;
+
+		/* setup interrupt handler and priority */
+		if (irq < 32) {
+			set_irq_chip(irq, &comcerto_irq_chip_0);
+
+			prio = comcerto_irq_table[i].prio;
+
+			prio_reg = COMCERTO_INTC_CSP_PRTY_0 + 4 * (prio / 4);
+			prio_off = ((prio % 4) << 3);
+			prio_mask = 0x1f << prio_off;
+
+			__raw_writel((__raw_readl(prio_reg) & ~prio_mask) | \
+						(irq << prio_off), prio_reg);
+		} else {
+			set_irq_chip(irq, &comcerto_irq_chip_1);
+		}
+
+		set_irq_handler(irq, comcerto_irq_table[i].handle);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
+
+/***********************************************************
+ *   KERNEL TIMER                                          *
+ *   (Functions called  by the kernel)                     *
+ ***********************************************************/
+
+static unsigned long systimer_mark;
+
+/*
+ * Routine to catch timer interrupts
+ */
+irqreturn_t comcerto_timer_interrupt(int irq, void *dev_id)
+{
+	u32 status;
+	u8 handled = 0;
+
+	status = __raw_readl(COMCERTO_TIMER_STATUS);
+
+	/* timer1 expired */
+	if (status & COMCERTO_TIMER1) {
+		/*Clear status*/
+		__raw_writel(COMCERTO_TIMER1, COMCERTO_TIMER_STATUS);
+
+		timer_tick();
+		systimer_mark = comcerto_timer1_get();
+
+		handled = 1;
+	}
+
+	/* timer2 expired */
+	else if (status & COMCERTO_TIMER2) {
+		printk(KERN_DEBUG "TIMER 2 interrupt.\n");
+		__raw_writel(COMCERTO_TIMER2, COMCERTO_TIMER_STATUS);
+		timer_hw_handler(2);
+		handled = 1;
+	}
+
+	/* timer3 expired */
+	else if (status & COMCERTO_TIMER3) {
+		printk(KERN_DEBUG "TIMER 3 interrupt.\n");
+		__raw_writel(COMCERTO_TIMER3, COMCERTO_TIMER_STATUS);
+		timer_hw_handler(3);
+		handled = 1;
+	}
+	if (handled)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static struct irqaction comcerto_timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_DISABLED,
+	.handler	= comcerto_timer_interrupt,
+};
+
+
+/*
+ * Timer registration, initialisation
+ * Called by the kernel
+ */
+static void __init comcerto_timer_init(void)
+{
+	/*
+	 * DO NOT MODIFY THE CONFIGURATION OF TIMER0
+	 * It is used by the MSP
+	 */
+
+	/* Mask all the timers except timer0 */
+	comcerto_timer_disable(1);
+	comcerto_timer_disable(2);
+	comcerto_timer_disable(3);
+	comcerto_timer_disable(4);
+	comcerto_timer_disable(5);
+
+	/* Clear all the timers except timer0  */
+	__raw_writel(COMCERTO_TIMER_CSP, COMCERTO_TIMER_STATUS);
+
+	/* Register interrupt handler for interrupt on IRQ_TIMERB*/
+	setup_irq(IRQ_TIMERB, &comcerto_timer_irq);
+
+	/* Set and enable the system timer */
+	comcerto_timer1_set(COMCERTO_KERNEL_TIMER_VALUE);
+	comcerto_timer_enable(1);
+}
+
+unsigned long comcerto_gettimeoffset(void)
+{
+	unsigned long delta;
+
+	delta = comcerto_timer1_get();
+	return machinecycles_to_usecs(delta);
+}
+
+struct sys_timer comcerto_timer = {
+	.init		= comcerto_timer_init,
+	.offset		= comcerto_gettimeoffset,
+};
+
+
+/************************************************************************
+ *  GPIO
+ ************************************************************************/
+static __init void gpio_init(void)
+{
+	/*
+	 * Configure each GPIO to be Output or Input
+	 * When Input, Configure to be Input, IRQ
+	 * When Input IRQ, Configure to be IRQ Rising Edge or IRQ falling Edge
+	 */
+
+	/*GPIO Output, others are input*/
+	__raw_writel(COMCERTO_OUTPUT_GPIO , COMCERTO_GPIO_OE_REG);
+
+	/*GPIO Input Rising Edge IRQ*/
+	__raw_writel(COMCERTO_IRQ_RISING_EDGE_GPIO, \
+				COMCERTO_GPIO_HI_INT_ENABLE_REG);
+
+	/*GPIO Input Falling Edge IRQ*/
+	__raw_writel(COMCERTO_IRQ_FALLING_EDGE_GPIO, \
+				COMCERTO_GPIO_LO_INT_ENABLE_REG);
+}
+
+/************************************************************************
+ *  Expansion Bus
+ ************************************************************************/
+
+/*This variable is provided by the board file*/
+extern int comcerto_exp_values[5][6];
+
+static __init void exp_bus_init(void)
+{
+	int cs;
+
+	for (cs = 0; cs < 5 ; cs++) {
+		/* configure only enabled CS */
+		if (comcerto_exp_values[cs][0] == 1) {
+			/*mode configuration*/
+			__raw_writel(comcerto_exp_values[cs][2], \
+						COMCERTO_EXP_CSx_CFG_R(cs));
+
+			/*Chip select Segment size configuration*/
+			__raw_writel(comcerto_exp_values[cs][1], \
+						COMCERTO_EXP_CSx_SEG_R(cs));
+
+			/*Chip select timing configuration*/
+			__raw_writel(comcerto_exp_values[cs][3], \
+						COMCERTO_EXP_CSx_TMG1_R(cs));
+			__raw_writel(comcerto_exp_values[cs][4], \
+						COMCERTO_EXP_CSx_TMG2_R(cs));
+			__raw_writel(comcerto_exp_values[cs][5], \
+						COMCERTO_EXP_CSx_TMG3_R(cs));
+		}
+	}
+
+	/*Chip Select activation*/
+	__raw_writel(COMCERTO_EXP_CS_EN_VALUE, COMCERTO_EXP_CS_EN_R);
+}
+
+void __init idma_init(void)
+{
+	/* IDMA priorities */
+#if defined(CONFIG_ARCH_M822XX)
+	/* For C50 */
+	__raw_writel(0x43287160, COMCERTO_IDMA_PRIORITY0_7);
+#else
+	/* For C100 */
+	__raw_writel((IDMA_PUMM << 28) | (IDMA_MMHI << 24) | (IDMA_HIMM << 20) |
+				(IDMA_HMB << 16) | (IDMA_MMEM1 << 12) |
+				(IDMA_MMEM0 << 8) | (IDMA_EMMM1 << 4) |
+				(IDMA_EMMM0 << 0), COMCERTO_IDMA_PRIORITY0_7);
+#endif
+
+	__raw_writel(IDMA_MMPU, COMCERTO_IDMA_PRIORITY8);
+}
+
+
+/************************************************************************
+ *  Initialization of the device
+ ************************************************************************/
+void __init device_init(void)
+{
+	system_rev = (__raw_readl(COMCERTO_GPIO_PAD_CTRL) >> 4) & 0xf;
+#if defined(CONFIG_CACHE_L2X0)
+	/*L2 Cache Configuration (if needed, to check) */
+	l2x0_init((void *)COMCERTO_L2CC_VADDR_BASE, L210_AUX_CTRL_REG, 0);
+#endif
+	idma_init();
+	exp_bus_init();
+	gpio_init();
+}
diff --git a/arch/arm/mach-comcerto/comcerto-common.c b/arch/arm/mach-comcerto/comcerto-common.c
new file mode 100644
index 0000000..7f446c1
--- /dev/null
+++ b/arch/arm/mach-comcerto/comcerto-common.c
@@ -0,0 +1,273 @@
+/*
+ *  linux/arch/arm/mach-comcerto/comcerto-common.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <mach/comcerto-devices.h>
+/*
+ * HARDWARE TIMER
+ * Can be use by any driver for its own need
+ */
+
+#define COMCERTO_TIMER_DEBUG	1
+#define TIMER_STATUS_ENABLED	(1 << 0)
+#define TIMER_STATUS_FREE		(1 << 1)
+#define COMCERTO_MAX_TIMERS	4
+
+DEFINE_SPINLOCK(timer_lock);
+
+/* List of available timers */
+struct timer_hw {
+	u8 id;
+	u8 status;
+	struct comcerto_timer *t;
+};
+struct timer_hw timer_hw[COMCERTO_MAX_TIMERS] = {
+	{0, 0, NULL},
+	{1, 0, NULL},
+	{2, TIMER_STATUS_FREE, NULL},
+	{3, TIMER_STATUS_FREE, NULL}
+};
+
+
+
+static unsigned long __timer_get(int id)
+{
+	if (id == 2)
+		return comcerto_timer2_get();
+	else if (id == 3)
+		return comcerto_timer3_get();
+	else
+		return 0;
+}
+
+static void __timer_start(struct timer_hw *thw, unsigned long count)
+{
+	thw->status |= TIMER_STATUS_ENABLED;
+
+	if (thw->id == 2)
+		comcerto_timer2_set(0, count, 0);
+	else if (thw->id == 3)
+		comcerto_timer3_set(0, count, 0);
+	else
+		goto out;
+
+	comcerto_timer_enable(thw->id);
+
+out:
+	return;
+}
+
+static void timer_start(struct timer_hw *thw, unsigned long count)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	__timer_start(thw, count);
+	spin_unlock_irqrestore(&timer_lock, flags);
+}
+
+static void __timer_stop(struct timer_hw *thw)
+{
+	comcerto_timer_disable(thw->id);
+	thw->status &= ~TIMER_STATUS_ENABLED;
+}
+
+static void timer_stop(struct timer_hw *thw)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	__timer_stop(thw);
+	spin_unlock_irqrestore(&timer_lock, flags);
+}
+
+static void __timer_free(struct timer_hw *thw)
+{
+	thw->status |= TIMER_STATUS_FREE;
+	thw->t->thw = (unsigned long) NULL;
+	thw->t = NULL;
+}
+
+static void timer_free(struct timer_hw *thw)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	__timer_free(thw);
+	spin_unlock_irqrestore(&timer_lock, flags);
+}
+
+
+static struct timer_hw *__timer_alloc(struct comcerto_timer *t)
+{
+	struct timer_hw *thw;
+	int i;
+
+	for (i = 0; i < COMCERTO_MAX_TIMERS; i++) {
+		thw = &timer_hw[i];
+		if (thw->status & TIMER_STATUS_FREE) {
+			thw->status &= ~TIMER_STATUS_FREE;
+			t->thw = (unsigned long) thw;
+			thw->t = t;
+			goto found;
+		}
+	}
+
+	return NULL;
+found:
+	return thw;
+}
+
+static struct timer_hw *timer_alloc(struct comcerto_timer *t)
+{
+	struct timer_hw *thw;
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	thw = __timer_alloc(t);
+	spin_unlock_irqrestore(&timer_lock, flags);
+
+	return thw;
+}
+
+int comcerto_timer_start(struct comcerto_timer *t)
+{
+	struct timer_hw *thw;
+
+	thw = (struct timer_hw *) t->thw;
+	if (!thw) {
+		thw = timer_alloc(t);
+		if (!thw) {
+			printk(KERN_ERR "Comcerto timer: unable to allocate hardware timer\n");
+			goto err;
+		}
+	}
+#ifdef COMCERTO_TIMER_DEBUG
+	if (thw->t != t) {
+		printk(KERN_ERR
+			"Comcerto timer: timer corruption %#lx %#lx %#lx\n",
+				(unsigned long)thw, (unsigned long)thw->t,
+							(unsigned long)t);
+
+		goto err;
+	}
+#endif /* COMCERTO_TIMER_DEBUG */
+
+	/* timeout in us */
+	timer_start(thw, t->timeout * COMCERTO_AHBCLK);
+
+	return 0;
+
+err:
+	return -1;
+}
+EXPORT_SYMBOL(comcerto_timer_start);
+
+int comcerto_timer_stop(struct comcerto_timer *t)
+{
+	struct timer_hw *thw;
+
+	thw = (struct timer_hw *) t->thw;
+	if (!thw)
+		goto err;
+
+#ifdef COMCERTO_TIMER_DEBUG
+	if (thw->t != t) {
+		printk(KERN_ERR
+			"Comcerto timer: timer corruption %#lx %#lx %#lx\n",
+				(unsigned long) thw, (unsigned long) thw->t,
+							(unsigned long) t);
+
+		goto err;
+	}
+#endif /* COMCERTO_TIMER_DEBUG */
+
+	timer_stop(thw);
+	timer_free(thw);
+
+	return 0;
+
+err:
+	return -1;
+}
+EXPORT_SYMBOL(comcerto_timer_stop);
+
+int comcerto_timer_read(struct comcerto_timer *t)
+{
+	struct timer_hw *thw;
+
+	thw = (struct timer_hw *) t->thw;
+	if (!thw)
+		goto err;
+
+#ifdef COMCERTO_TIMER_DEBUG
+	if (thw->t != t) {
+		printk(KERN_ERR
+			"Comcerto timer: timer corruption %#lx %#lx %#lx\n",
+				(unsigned long) thw, (unsigned long) thw->t,
+							(unsigned long) t);
+
+		goto err;
+	}
+#endif /* COMCERTO_TIMER_DEBUG */
+
+	return __timer_get(thw->id) / COMCERTO_AHBCLK;
+
+err:
+	return -1;
+}
+EXPORT_SYMBOL(comcerto_timer_read);
+
+
+
+
+int timer_hw_handler(u8 id)
+{
+	struct timer_hw *thw;
+	unsigned long flags;
+
+	thw = &timer_hw[id];
+
+	spin_lock_irqsave(&timer_lock, flags);
+
+	if (thw->status & TIMER_STATUS_ENABLED) {
+
+		if (thw->t->flags & COMCERTO_TIMER_RUN_ONCE) {
+			__timer_stop(thw);
+			__timer_free(thw);
+		}
+
+		spin_unlock_irqrestore(&timer_lock, flags);
+
+		thw->t->func(thw->t->data);
+
+	} else {
+		spin_unlock_irqrestore(&timer_lock, flags);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return -1;
+}
+
diff --git a/arch/arm/mach-comcerto/include/mach/boards/board-router.h b/arch/arm/mach-comcerto/include/mach/boards/board-router.h
new file mode 100644
index 0000000..de917bf
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/boards/board-router.h
@@ -0,0 +1,84 @@
+/*
+ * linux/include/asm-arm/arch-comcerto/boards/board-router.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __BOARD_ROUTER_H__
+#define __BOARD_ROUTER_H__
+
+#include <mach/hardware.h>
+
+/***********************************
+ * Expansion bus configuration
+ ***********************************/
+
+/* EXP_CS0 = EEPROM,  EXP_CS1 = NOR, EXP_CS2 = CPLD,
+ * EXP_CS3 unused, EXP_CS4 = NAND */
+#define COMCERTO_EXP_CS_EN_VALUE	\
+	(EXP_CLK_EN | EXP_CS0_EN | EXP_CS1_EN | EXP_CS2_EN | EXP_CS4_EN)
+
+/*	TODO Default value to check*/
+#define COMCERTO_EXP_CLOCK_DIV_VALUE	0x00000007	/*Default value*/
+
+/***********************************
+ * GPIO
+ ***********************************/
+#define COMCERTO_OUTPUT_GPIO 		\
+	(COMCERTO_NAND_CE | COMCERTO_NAND_ALE | \
+	 COMCERTO_NAND_CLE | GPIO_17 | GPIO_5)
+#define COMCERTO_IRQ_RISING_EDGE_GPIO	0
+#define COMCERTO_IRQ_FALLING_EDGE_GPIO	(GPIO_0 | GPIO_1)
+#define COMCERTO_IRQ_LEVEL_GPIO 	GPIO_0
+/*Are pins used either as GPIO or as pins for others IP blocks*/
+#define COMCERTO_GPIO_PIN_USAGE		\
+		(EXP_BUS_A15_A16 | EXP_BUS_A17_A18 | \
+		 EXP_BUS_A19_A21 | UART0_BUS | SPI_BUS)
+
+/***********************************
+ * EEPROM
+ ***********************************/
+
+/***********************************
+ * NOR
+ ***********************************/
+#define NORFLASH_MEMORY_PHY1		COMCERTO_EXP_CS0_BASE
+
+/***********************************
+ * NAND
+ ***********************************/
+#define COMCERTO_EXP_CS4_SEG_SZ		1
+
+#define COMCERTO_NAND_FIO_ADDR		COMCERTO_EXP_CS4_BASE
+#define COMCERTO_NAND_BR		GPIO_6
+#define COMCERTO_NAND_CE		GPIO_29
+#define COMCERTO_NAND_ALE		GPIO_30
+#define COMCERTO_NAND_CLE		GPIO_31
+#define COMCERTO_NAND_IO_SZ	((COMCERTO_EXP_CS4_SEG_SZ << 12) + 0x1000)
+
+/***********************************
+ * PCI
+ ***********************************/
+#define COMCERTO_PCI_GPIO_IRQ		IRQ_G0
+
+/***********************************
+ * SLIC
+ ***********************************/
+#define COMCERTO_SLIC_GPIO_IRQ		IRQ_G1
+
+/***********************************
+ * BT8370 FRAMER
+ ***********************************/
+#define COMCERTO_FRAMER_GPIO_IRQ	IRQ_G1
+#define COMCERTO_FRAMER_FIO_ADDR	COMCERTO_EXP_CS3_BASE
+
+
+/***********************************
+ * RTL8211B(L) - Realtek PHY
+ **********************************/
+#define COMCERTO_RTL_PHY_LED_ADDR   0x18    /* Reg 24 */
+#define COMCERTO_RTL_PHY_MASK1      0x7FF0
+#define COMCERTO_RTL_PHY_MASK2      0x000E
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100.h b/arch/arm/mach-comcerto/include/mach/comcerto-100.h
new file mode 100644
index 0000000..169191f
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100.h
@@ -0,0 +1,121 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef __ASM_ARCH_COMCERTO100_H__
+#define __ASM_ARCH_COMCERTO100_H__
+
+#define REFCLKFREQ			24
+#ifdef CONFIG_ARCH_M822XX
+#define COMCERTO_AHBCLK			125 /* Mhz */
+#define COMCERTO_ARMCLK			150 /* Mhz */
+#else
+#define COMCERTO_AHBCLK			165 /* Mhz */
+#define COMCERTO_ARMCLK			450 /* Mhz */
+#endif
+/* PA of IO on APB bus */
+#define APB_PADDR_BASE			0x10000000
+
+
+/***** Physical address of IO on APB Bus *****/
+
+/* 0x001F0000 Reserved */
+#define COMCERTO_APB_MDMA_BASE			0x101E0000
+#define COMCERTO_APB_TDMA2_BASE			0x101D0000
+/* 0x101B0000 --> 0x101C0000 Reserved */
+#define COMCERTO_APB_EXPBUS_BASE		0x101A0000
+#define COMCERTO_APB_EMAC1_BASE			0x10190000
+/* 0x00110000 --> 0x00180000 Reserved */
+#define COMCERTO_APB_ASAAAB_BASE		0x10108000
+#define COMCERTO_APB_ASAEBUS_BASE		0x10100000
+#define COMCERTO_APB_ARAM_BASE			0x100F0000
+#define COMCERTO_APB_EDMA0_BASE			0x100E0100
+#define COMCERTO_APB_EDMA1_BASE			0x100E0300
+#define COMCERTO_APB_IDMA_BASE			0x100E0000
+#define COMCERTO_APB_EMAC0_BASE			0x100D0000
+#define COMCERTO_APB_PUI_BASE			0x100C0000
+#define COMCERTO_APB_CLK_BASE			0x100B0000
+#define COMCERTO_APB_INTC_BASE			0x100A0000
+#define COMCERTO_APB_I2C_BASE			0x1009C000
+#define COMCERTO_APB_SPI_BASE			0x10098000
+#define COMCERTO_APB_UART1_BASE			0x10094000
+#define COMCERTO_APB_UART0_BASE			0x10090000
+#define COMCERTO_APB_PUI_BASE			0x100C0000
+#define COMCERTO_APB_CLK_BASE			0x100B0000
+#define COMCERTO_APB_INTC_BASE			0x100A0000
+#define COMCERTO_APB_I2C_BASE			0x1009C000
+#define COMCERTO_APB_SPI_BASE			0x10098000
+#define COMCERTO_APB_UART1_BASE			0x10094000
+#define COMCERTO_APB_UART0_BASE			0x10090000
+/*	0x10080000 Reserved*/
+#define COMCERTO_APB_GPIO_BASE			0x10070000
+#define COMCERTO_APB_ASD_BASE			0x10060000
+#define COMCERTO_APB_TIMER_BASE			0x10050000
+#define COMCERTO_APB_ASA_ARAM_BASE		0x10048000
+#define COMCERTO_APB_ASA_DDR_BASE		0x10040000
+/*	0x10030000 Reserved*/
+#define COMCERTO_APB_TDMA_BASE			0x10020000
+#define COMCERTO_APB_PHI_BASE			0x10010000
+#define COMCERTO_APB_TDM_BASE			0x10000000
+
+/***** Physical address on AHB Bus *****/
+#define COMCERTO_AHB_USB1_BASE			0x0F800000
+#define COMCERTO_AHB_USB0_BASE			0x0F000000
+#define COMCERTO_IPSEC_BASE			0x0E000000
+#define COMCERTO_L2CC_BASE			0x0A0A0000
+
+#define COMCERTO_EXP_CS0_BASE			0x20000000
+#define COMCERTO_EXP_CS1_BASE			0x24000000
+#define COMCERTO_EXP_CS2_BASE			0x28000000
+#define COMCERTO_EXP_CS3_BASE			0x2C000000
+#define COMCERTO_EXP_CS4_BASE			0x30000000
+
+#define COMCERTO_HIF_BASE			0x40000000
+
+#define PCIBIOS_MIN_MEM				0x40000000
+#define PCIBIOS_MIN_IO				0x46000000
+
+#define pcibios_assign_all_busses()	1
+
+/*HIF interface*/
+#include <mach/comcerto-100/hif.h>
+
+#include <mach/comcerto-100/idma.h>
+
+#include <mach/comcerto-100/clk-rst.h>
+#include <mach/comcerto-100/timer.h>
+#include <mach/comcerto-100/gpio.h>
+#include <mach/comcerto-100/exp-bus.h>
+#include <mach/comcerto-100/intr.h>
+#include <mach/comcerto-100/memory.h>
+#include <mach/comcerto-100/irqs.h>
+
+#define COMCERTO_INTC_CSP_IRQMASK_0	COMCERTO_INTC_ARM0_IRQMASK_0
+#define COMCERTO_INTC_CSP_IRQMASK_1	COMCERTO_INTC_ARM0_IRQMASK_1
+#define COMCERTO_INTC_CSP_FIQMASK_0	COMCERTO_INTC_ARM0_FIQMASK_0
+#define COMCERTO_INTC_CSP_FIQMASK_1	COMCERTO_INTC_ARM0_FIQMASK_1
+
+#define COMCERTO_INTC_CSP_IRQ_WNR	COMCERTO_INTC_ARM0_IRQ_WNR
+#define COMCERTO_INTC_CSP_PRTY_0	COMCERTO_INTC_ARM0_PRTY_0
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/clk-rst.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/clk-rst.h
new file mode 100644
index 0000000..47a24c6
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/clk-rst.h
@@ -0,0 +1,111 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/clk-rst.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CLK_H__
+#define __CLK_H__
+
+#define COMCERTO_CLK_ARM_CLK_CNTRL	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x00))
+#define COMCERTO_CLK_AHB_CLK_CNTRL	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x04))
+#define COMCERTO_CLK_PLL_STATUS		\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x08))
+#define COMCERTO_CLK_CLKDIV_CNTRL	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x0C))
+#define COMCERTO_CLK_TDM_CLK_CNTRL	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x10))
+#define COMCERTO_CLK_FSYNC_CNTRL	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x14))
+#define COMCERTO_CLK_CLK_PWR_DWN	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x18))
+#define COMCERTO_CLK_RNG_CNTRL		\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x1C))
+#define COMCERTO_CLK_RNG_STATUS		\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x20))
+#define COMCERTO_CLK_ARM_CLK_CNTRL2 	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x24))
+#define COMCERTO_CLK_TDM_REF_DIV_RST 	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x40))
+
+#define ARM_PLL_BY_CTRL			0x80000000
+#define ARM_AHB_BYP			0x04000000
+#define PLL_DISABLE			0x02000000
+#define PLL_CLK_BYPASS			0x01000000
+
+#define AHB_PLL_BY_CTRL			0x80000000
+#define DIV_BYPASS			0x40000000
+#define SYNC_MODE			0x20000000
+
+#define EPHY_CLKDIV_BYPASS		0x00200000
+#define EPHY_CLKDIV_RATIO_SHIFT		16
+#define PUI_CLKDIV_BYPASS		0x00004000
+#define PUI_CLKDIV_SRCCLK		0x00002000
+#define PUI_CLKDIV_RATIO_SHIFT		8
+#define PCI_CLKDIV_BYPASS		0x00000020
+#define PCI_CLKDIV_RATIO_SHIFT		0
+
+#define ARM0_CLK_PD			0x00200000
+#define ARM1_CLK_PD			0x00100000
+#define EPHY_CLK_PD			0x00080000
+#define TDM_CLK_PD			0x00040000
+#define PUI_CLK_PD			0x00020000
+#define PCI_CLK_PD			0x00010000
+#define MDMA_AHBCLK_PD			0x00000400
+#define I2CSPI_AHBCLK_PD		0x00000200
+#define UART_AHBCLK_PD			0x00000100
+#define IPSEC_AHBCLK_PD			0x00000080
+#define TDM_AHBCLK_PD			0x00000040
+#define USB1_AHBCLK_PD			0x00000020
+#define USB0_AHBCLK_PD			0x00000010
+#define GEMAC1_AHBCLK_PD		0x00000008
+#define GEMAC0_AHBCLK_PD		0x00000004
+#define PUI_AHBCLK_PD			0x00000002
+#define HIF_AHBCLK_PD			0x00000001
+
+#define ARM1_DIV_BP			0x00001000
+#define ARM1_DIV_VAL_SHIFT		8
+#define ARM0_DIV_BP			0x00000010
+#define ARM0_DIV_VAL_SHIFT		0
+
+#define AHBCLK_PLL_LOCK			0x00000002
+#define FCLK_PLL_LOCK			0x00000001
+
+
+
+#define COMCERTO_BLOCK_RESET_REG	\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x100))
+#define COMCERTO_CSP_RESET_REG		\
+			APB_VADDR((COMCERTO_APB_CLK_BASE + 0x104))
+
+#define RNG_RST						0x1000
+#define IPSEC_RST					0x0800
+#define DDR_RST						0x0400
+#define USB1_PHY_RST					0x0200
+#define USB0_PHY_RST					0x0100
+#define USB1_RST					0x0080
+#define USB0_RST					0x0040
+#define GEMAC1_RST					0x0020
+#define GEMAC0_RST					0x0010
+#define TDM_RST						0x0008
+#define PUI_RST						0x0004
+#define HIF_RST						0x0002
+#define PCI_RST						0x0001
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/exp-bus.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/exp-bus.h
new file mode 100644
index 0000000..56806c5
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/exp-bus.h
@@ -0,0 +1,88 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/exp-bus.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_EXP_BUS_H__
+#define __COMCERTO_EXP_BUS_H__
+
+/***** Registers address *****/
+
+#define COMCERTO_EXP_SW_RST_R		\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x000)
+#define COMCERTO_EXP_CS_EN_R		\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x004)
+#define COMCERTO_EXP_CSx_SEG_R(x)	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x008 + (0x4 * x))
+#define COMCERTO_EXP_CSx_CFG_R(x)	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x01C + (0x4 * x))
+#define COMCERTO_EXP_CSx_TMG1_R(x)	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x030 + (0x4 * x))
+#define COMCERTO_EXP_CSx_TMG2_R(x)	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x044 + (0x4 * x))
+#define COMCERTO_EXP_CSx_TMG3_R(x)	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x058 + (0x4 * x))
+#define COMCERTO_EXP_CLOCK_DIV_R	\
+			APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x06C)
+
+#define COMCERTO_EXP_MFSM_R	APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x100)
+#define COMCERTO_EXP_CSFSM_R	APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x104)
+#define COMCERTO_EXP_WRSM_R	APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x108)
+#define COMCERTO_EXP_RDSM_R	APB_VADDR(COMCERTO_APB_EXPBUS_BASE + 0x10C)
+
+
+/***** Masks *****/
+
+/* EXP_SWRST_R register*/
+#define EXP_SW_RST			0x00000001
+
+/* EXP_CS_EN_R register*/
+#define EXP_CS4_EN			0x00000020
+#define EXP_CS3_EN			0x00000010
+#define EXP_CS2_EN			0x00000008
+#define EXP_CS1_EN			0x00000004
+#define EXP_CS0_EN			0x00000002
+#define EXP_CLK_EN			0x00000001
+
+/* EXP_CSx_CFG_R register*/
+#define EXP_RDY_EDG			0x00000800
+#define EXP_RDY_EN			0x00000400
+#define EXP_NAND_MODE			0x00000200
+#define EXP_DM_MODE			0x00000100
+#define EXP_STRB_MODE			0x00000080
+#define EXP_ALE_MODE			0x00000040
+#define EXP_RE_CMD_LVL			0x00000020
+#define EXP_WE_CMD_LVL			0x00000010
+#define EXP_CS_LEVEL			0x00000008
+#define EXP_MEM_BUS_SIZE		0x00000006
+#define EXP_MEM_BUS_SIZE_32		0x00000004
+#define EXP_MEM_BUS_SIZE_16		0x00000002
+#define EXP_MEM_BUS_SIZE_8		0x00000000
+
+/* EXP_CSx_TMG1_R register */
+/* EXP_CSx_TMG2_R register */
+/* EXP_CSx_TMG3_R register */
+
+/* EXP_CLOCK_DIV_R register */
+
+/* EXP_MFSM_R register*/
+/* EXP_CSFSM_R register*/
+/* EXP_WRFSM_R register*/
+/* EXP_RDFSM_R register*/
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/gpio.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/gpio.h
new file mode 100644
index 0000000..b9f53ed
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/gpio.h
@@ -0,0 +1,126 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/gpio.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __COMCERTO_GPIO_H__
+#define __COMCERTO_GPIO_H__
+
+/***** GPIO  *****/
+#define COMCERTO_GPIO_OUTPUT_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x00))
+#define COMCERTO_GPIO_OE_REG			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x04))
+#define COMCERTO_GPIO_HI_INT_ENABLE_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x08))
+#define COMCERTO_GPIO_LO_INT_ENABLE_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x0C))
+#define COMCERTO_GPIO_INPUT_REG			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x10))
+#define COMCERTO_GPIO_APB_WS			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x14))
+#define COMCERTO_GPIO_SYSTEM_CONFIG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x1C))
+#define COMCERTO_GPIO_MBIST			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x20))
+#define COMCERTO_GPIO_TDM_MUX			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x28))
+#define COMCERTO_GPIO_ARM_ID			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x30))
+#define COMCERTO_GPIO_PAD_CTRL			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x34))
+#define COMCERTO_GPIO_LOCK_REG			\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x38))
+#define COMCERTO_GPIO_ARBITRER_CONF		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x3C))
+#define COMCERTO_GPIO_BOOTSTRAP_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x40))
+#define COMCERTO_GPIO_IOCTRL_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x44))
+#define COMCERTO_GPIO_USB_PHY_BIST_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x48))
+#define COMCERTO_GPIO_GENERAL_CONTROL_REG	\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x4C))
+#define COMCERTO_GPIO_DEVICE_ID_REG		\
+			APB_VADDR((COMCERTO_APB_GPIO_BASE + 0x50))
+
+#define GPIO_0					0x00000001
+#define GPIO_1					0x00000002
+#define GPIO_2					0x00000004
+#define GPIO_3					0x00000008
+#define GPIO_4					0x00000010
+#define GPIO_5					0x00000020
+#define GPIO_6					0x00000040
+#define GPIO_7					0x00000080
+#define GPIO_8					0x00000100
+#define GPIO_9					0x00000200
+#define GPIO_10				0x00000400
+#define GPIO_11				0x00000800
+#define GPIO_12				0x00001000
+#define GPIO_13				0x00002000
+#define GPIO_14				0x00004000
+#define GPIO_15				0x00008000
+#define GPIO_16				0x00010000
+#define GPIO_17				0x00020000
+#define GPIO_18				0x00040000
+#define GPIO_19				0x00080000
+#define GPIO_20				0x00100000
+#define GPIO_21				0x00200000
+#define GPIO_22				0x00400000
+#define GPIO_23				0x00800000
+#define GPIO_24				0x01000000
+#define GPIO_25				0x02000000
+#define GPIO_26				0x04000000
+#define GPIO_27				0x08000000
+#define GPIO_28				0x10000000
+#define GPIO_29				0x20000000
+#define GPIO_30				0x40000000
+#define GPIO_31				0x80000000
+
+/*IO Control register values*/
+#define HBMODE_SW			0x00000400
+#define SPI_BUS				0x00000200
+#define UART1_BUS			0x00000100
+#define UART0_BUS			0x00000080
+#define I2C_BUS				0x00000040
+#define GPBT3				0x00000020
+#define TIMER_EVENT1				0x00000010
+#define TIMER_EVENT0				0x00000008
+#define EXP_BUS_A19_A21				0x00000004
+#define EXP_BUS_A17_A18				0x00000002
+#define EXP_BUS_A15_A16				0x00000001
+
+/* system config status register values */
+
+#define BOND_DEVTYP		0x00020000
+#define BOND_VOCCH			0x00018000
+#define PCI_HOST			0x00001000
+#define PCI_EN		0x00000400
+#define PLL_MODE			0x00001800
+#define BURNIN		0x00000400
+#define HBUSSIZE_OUT		0x00000300
+#define TDM_CK_OUT_EN		0x00000080
+#define SELFTEST			 	0x00000040
+#define TM_MII1			 	0x00000030
+#define TM_MII0			 	0x0000000C
+#define BOOT_OP1		 	0x00000002
+#define BOOT_OP0		 	0x00000001
+
+#define PCI_HOST_ENABLED	(PCI_HOST | PCI_EN)
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/hif.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/hif.h
new file mode 100644
index 0000000..c7d9385
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/hif.h
@@ -0,0 +1,152 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/hif.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __HIF_H__
+#define __HIF_H__
+
+/* Virtual address of Host Interface Registers*/
+#define COMCERTO_PHI_APB_FIFO_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0000))
+#define COMCERTO_PHI_APB_FIFO_STATUS		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0004))
+#define COMCERTO_PHI_APB_FIFO_INTACK		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0004))
+#define COMCERTO_PHI_APB_BIST_CTRL_STAT		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0008))
+#define COMCERTO_PHI_APB_TX_FIFO_SIZE		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0014))
+#define COMCERTO_PHI_APB_TX_FIFO_HI_THRESH	\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0018))
+#define COMCERTO_PHI_APB_TX_FIFO_LO_THRESH	\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x001C))
+#define COMCERTO_PHI_APB_RX_FIFO_SIZE		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0024))
+#define COMCERTO_PHI_APB_RX_FIFO_HI_THRESH	\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0028))
+#define COMCERTO_PHI_APB_RX_FIFO_LO_THRESH	\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x002C))
+#define COMCERTO_PHI_TX_MAIL0			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0030))
+#define COMCERTO_PHI_TX_MAIL1			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0034))
+#define COMCERTO_PHI_TX_MAIL2			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0038))
+#define COMCERTO_PHI_TX_MAIL3			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x003C))
+#define COMCERTO_PHI_RX_MAIL0			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0040))
+#define COMCERTO_PHI_RX_MAIL1			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0044))
+#define COMCERTO_PHI_RX_MAIL2			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0048))
+#define COMCERTO_PHI_RX_MAIL3			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x004C))
+#define COMCERTO_PHI_PCI_IF_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0050))
+#define COMCERTO_PHI_PCI_IF_STATUS		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0054))
+#define COMCERTO_PHI_BME_DMA_START_ADDR		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0060))
+#define COMCERTO_PHI_BME_DMA_BURST_SIZE		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0064))
+#define COMCERTO_PHI_BME_DMA_XFER_LEN		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0068))
+
+#define COMCERTO_APBB_INT_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0100))
+#define COMCERTO_APBB_INT_STATUS		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0104))
+#define COMCERTO_APBB_CONTROL		        \
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x0108))
+
+#define COMCERTO_PHI_APB_FIFO_DATA_U8		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x4000))
+#define COMCERTO_PHI_APB_FIFO_DATA_U16		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0x8000))
+#define COMCERTO_PHI_APB_FIFO_DATA_U32		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xC000))
+/* Host Memory Bridge */
+#define COMCERTO_HMB_FIFO_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xD000))
+#define COMCERTO_HMB_HCSM_BIST_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xD008))
+#define COMCERTO_HMB_FIFO_DATA_U8		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xE000))
+#define COMCERTO_HMB_FIFO_DATA_U16		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xE100))
+#define COMCERTO_HMB_FIFO_DATA_U32		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xE200))
+#define COMCERTO_HMB_STATE_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF000))
+#define COMCERTO_HMB_MODE_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF004))
+#define COMCERTO_HMB_STATUS			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF008))
+#define COMCERTO_HMB_INTACK			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF008))
+#define COMCERTO_HMB_INT_CONTROL		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF00C))
+#define COMCERTO_HMB_PCI_BASE_ADDR1		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF010))
+#define COMCERTO_HMB_SYS_BASE_ADDR1		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF014))
+#define COMCERTO_HMB_SIZE_MASK1			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF018))
+#define COMCERTO_HMB_PCI_BASE_ADDR2		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF020))
+#define COMCERTO_HMB_SYS_BASE_ADDR2		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF024))
+#define COMCERTO_HMB_SIZE_MASK2			\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF028))
+#define COMCERTO_HMB_AX_FIFO_DEPTH		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF030))
+#define COMCERTO_HMB_AX_FIFO_DATA_ADDR		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF034))
+#define COMCERTO_HMB_AX_FIFO_DATA_LEN		\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF038))
+#define COMCERTO_HMB_PCI_ARBITER_CONTROL	\
+			APB_VADDR((COMCERTO_APB_PHI_BASE + 0xF040))
+
+#define PCI_DEV_VENDOR_ID				0x015018DC
+
+#define BME_RXTRGABRT		0x0080000
+#define BME_MSTRABRT		0x0100000
+#define BME_SYSERROR		0x0200000
+#define BME_PARERROR		0x0400000
+#define BME_RETRY		0x0800000
+
+#define BME_RXTRGABRTIAK	0x008
+#define BME_MSTRABRTIAK		0x010
+#define BME_SYSERRORIAK		0x020
+#define BME_PARERRORIAK		0x040
+#define BME_RETRYIAK		0x100
+
+#define TXFF_RES		0x1000
+#define RXFF_RES		0x2000
+
+#define APBB_CTRL_MEMIO		0x8
+#define APBB_CTRL_LATTMR	0x4
+#define APBB_CTRL_REQLAST	0x2
+#define APBB_CTRL_EN		0x1
+
+#define FLUSH_RX	0x80
+#define MAX_RETRIES	20
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/idma.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/idma.h
new file mode 100644
index 0000000..eac9286
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/idma.h
@@ -0,0 +1,89 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/idma.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __IDMA_H__
+#define __IDMA_H__
+
+#define COMCERTO_HDMA_SOFTRESET			\
+		APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0000)
+#define COMCERTO_MMHI_DMA_ENABLE		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x000C)
+#define COMCERTO_HIMM_DMA_ENABLE		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0010)
+#define COMCERTO_MMHI_BASE_ADDR			\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0040)
+#define COMCERTO_HIMM_BASE_ADDR			\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0044)
+#define COMCERTO_MMHI_BLOCK_SIZE		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0048)
+#define COMCERTO_HIMM_BLOCK_SIZE		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x004C)
+#define COMCERTO_HI_LOCKED_TRANSFER_SIZE	\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0050)
+#define COMCERTO_IDMA_PRIORITY0_7		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0060)
+#define COMCERTO_IDMA_PRIORITY8			\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0064)
+#define COMCERTO_HMDMA_SOFTRESET		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0070)
+#define COMCERTO_HMDMA_STATUS_OUTPUT		\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0070)
+#define COMCERTO_HMDMA_LOCKED_TRANSFER_SIZE	\
+			APB_VADDR(COMCERTO_APB_IDMA_BASE + 0x0074)
+
+
+#define IDMA_FSTATUS_FRAME_DONE_MASK	        0x80000000
+#define IDMA_FSTATUS_STATUS_MASK		0x03FFFFFF
+#define IDMA_FSTATUS_STATUS_GOOD		0x00000400
+
+#define IDMA_FCONTROL_PHY_NB_MASK		0x00000070
+#define IDMA_FCONTROL_PHY_OFFSET		0x00000004
+
+#define IDMA_FCONTROL_SCATTER			0x00000008
+#define IDMA_FCONTROL_IRQEN			0x00000004
+#define IDMA_FCONTROL_FLAST			0x00000002
+#define IDMA_FCONTROL_FREADY			0x00000001
+#define IDMA_FCONTROL_IPSEC_OUT			0x00000010
+#define IDMA_FCONTROL_IPSEC_IN			0x00000020
+
+
+
+#define IDMA_BCONTROL_BLAST			0x00010000
+#define IDMA_BCONTROL_BLEN_MASK			0x0000FFFF
+#define IDMA_BCONTROL_SCATTER_BLAST		0x80000000
+
+#define IDMA_START				0x00000001
+#define IDMA_BURST_MASK			        0x000000FF
+#define IDMA_PRTY_MASK			        0x00000700
+
+#define	FDESC_ALIGN_BYTES			0x10
+
+/* IDMA masters */
+#define IDMA_EMMM0	0
+#define IDMA_MMEM0	1
+#define IDMA_PUMM	2
+#define IDMA_MMPU	3
+#define IDMA_HIMM	4
+#define IDMA_MMHI	5
+#define IDMA_EMMM1	6
+#define IDMA_MMEM1	7
+#define IDMA_HMB	8
+
+#endif /* __IDMA_H__ */
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/intr.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/intr.h
new file mode 100644
index 0000000..b1bf7ca
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/intr.h
@@ -0,0 +1,120 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/intr.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTINTCULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __INTR__H__
+#define __INTR__H__
+
+/*  Comcerto Interrupt Controller */
+#define COMCERTO_INTC_STATUS_REG_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x00))
+#define COMCERTO_INTC_SET_STATUS_REG_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x04))
+#define COMCERTO_INTC_ARM0_IRQMASK_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x08))
+#define COMCERTO_INTC_ARM0_FIQMASK_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x0C))
+#define COMCERTO_INTC_ARM1_IRQMASK_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x10))
+#define COMCERTO_INTC_ARM1_FIQMASK_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x14))
+
+#define COMCERTO_INTC_ARM1_CONTROL_REG	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x18))
+#define COMCERTO_INTC_IRQ_ACK_TEST_REG	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x1C))
+
+#define COMCERTO_INTC_STATUS_REG_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x20))
+#define COMCERTO_INTC_SET_STATUS_REG_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x24))
+#define COMCERTO_INTC_ARM0_IRQMASK_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x28))
+#define COMCERTO_INTC_ARM0_FIQMASK_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x2C))
+#define COMCERTO_INTC_ARM1_IRQMASK_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x30))
+#define COMCERTO_INTC_ARM1_FIQMASK_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x34))
+
+#define COMCERTO_INTC_STATUS_MASK_REG_1	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x38))
+
+#define COMCERTO_INTC_ARM0_PRTY_0	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x40))
+#define COMCERTO_INTC_ARM0_PRTY_1 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x44))
+#define COMCERTO_INTC_ARM0_PRTY_2 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x48))
+#define COMCERTO_INTC_ARM0_PRTY_3 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x4C))
+#define COMCERTO_INTC_ARM0_PRTY_4 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x50))
+#define COMCERTO_INTC_ARM0_PRTY_5 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x54))
+#define COMCERTO_INTC_ARM0_PRTY_6 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x58))
+#define COMCERTO_INTC_ARM0_PRTY_7 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x5C))
+
+#define COMCERTO_INTC_ARM0_IRQ_WNR 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x60))
+#define COMCERTO_INTC_ARM0_SELFCLEAR	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x64))
+#define COMCERTO_INTC_FIQ_PRTY_EN 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x68))
+
+#define COMCERTO_INTC_TDMA_STS 		\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x70))
+#define COMCERTO_INTC_TDMA_CTRL 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x74))
+#define COMCERTO_INTC_TDMA_SET 		\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x78))
+
+#define COMCERTO_INTC_ARM1_PRTY_0 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x80))
+#define COMCERTO_INTC_ARM1_PRTY_1 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x84))
+#define COMCERTO_INTC_ARM1_PRTY_2 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x88))
+#define COMCERTO_INTC_ARM1_PRTY_3 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x8C))
+#define COMCERTO_INTC_ARM1_PRTY_4 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x90))
+#define COMCERTO_INTC_ARM1_PRTY_5 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x94))
+#define COMCERTO_INTC_ARM1_PRTY_6 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x98))
+#define COMCERTO_INTC_ARM1_PRTY_7 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0x9C))
+
+#define COMCERTO_INTC_ARM1_IRQ_WNR 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0xA0))
+
+#define COMCERTO_INTC_ARM0_IRQ_WNR_VBA 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0xB0))
+#define COMCERTO_INTC_ARM1_IRQ_WNR_VBA 	\
+				APB_VADDR((COMCERTO_APB_INTC_BASE + 0xB4))
+
+#define COMCERTO_INTC_ARM0_STS_VEC_ADDR(nb)	\
+			APB_VADDR((COMCERTO_APB_INTC_BASE + 0x100 + 4nb))
+#define COMCERTO_INTC_ARM1_STS_VEC_ADDR(nb)	\
+			APB_VADDR((COMCERTO_APB_INTC_BASE + 0x180 + 4nb))
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/irqs.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/irqs.h
new file mode 100644
index 0000000..54c4b72
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/irqs.h
@@ -0,0 +1,96 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/irqs.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __COMCERTO_IRQS_H__
+#define __COMCERTO_IRQS_H__
+
+/* 32 First IRQs*/
+
+/* This IRQ is used only by the MSP */
+	#define IRQ_TIMERA				31
+/* This IRQ is used only by the CSP */
+	#define IRQ_TIMERB				30
+/*	#define IRQ_Reserved				29
+	#define IRQ_Reserved				28*/
+	#define IRQ_MDMA_DONE			27
+	#define IRQ_EDMA1TX				26
+	#define IRQ_EDMA1RX				25
+/*	#define IRQ_Reserved				24*/
+	#define IRQ_IPSEC_WRAP			23
+	#define IRQ_DDRC					22
+	#define IRQ_APBB					21
+	#define IRQ_EDMA0TX				20
+	#define IRQ_EDMA0RX				19
+	#define IRQ_HITXFUL				18
+	#define IRQ_HIF_RXEMT			17
+	#define IRQ_HIF					16
+	#define IRQ_TDM_TIMER			15
+	#define IRQ_SPI					14
+	#define IRQ_USB1					13
+	#define IRQ_EMAC1					12
+	#define IRQ_USB0					11
+	#define IRQ_I2C					10
+	#define IRQ_IPSEC					9
+	#define IRQ_TDMA1					8
+	#define IRQ_PUDMATX				7
+	#define IRQ_PUDMARX				6
+	#define IRQ_PUI					5
+	#define IRQ_EMAC0					4
+	#define IRQ_PTP2					3
+	#define IRQ_PTP1					2
+	#define IRQ_PTP0					1
+	#define STATUS_REG_1				0
+
+	/* 32 next IRQs*/
+	#define IRQ_MDMA_AHB_ERR		31
+	#define IRQ_IDMA_TX_AHB_ERR	30
+	#define IRQ_IDMA_RX_AHB_ERR	29
+	#define IRQ_TDMA_TX_AHB_ERR	28
+	#define IRQ_TDMA_RX_AHB_ERR	27
+	#define IRQ_UART1					26
+	#define IRQ_FPP					25
+	#define IRQ_VDMA1_TX				24
+	#define IRQ_VDMA1_RX				23
+	#define IRQ_VDMA0_TX				22
+	#define IRQ_VDMA0_RX				21
+/*	#define IRQ_Reserved				20
+	#define IRQ_Reserved				19*/
+	#define IRQ_MSP_PMU				18
+	#define IRQ_CSP_PMU				17
+	#define IRQ_L2_PARRT				16
+	#define IRQ_L2_PARRD				15
+	#define IRQ_L2_BWABT				14
+/*	#define IRQ_Reserved				13
+	#define IRQ_Reserved				12 */
+	#define IRQ_TOFPP_DMA				11
+	#define IRQ_TDMA0					10
+	#define IRQ_UART0					9
+	#define IRQ_G7						8
+	#define IRQ_G6						7
+	#define IRQ_G5						6
+	#define IRQ_G4						5
+	#define IRQ_G3						4
+	#define IRQ_G2						3
+	#define IRQ_G1						2
+	#define IRQ_G0						1
+	#define STATUS_REG_0				0
+
+	#define NR_IRQS					64
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/memory.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/memory.h
new file mode 100644
index 0000000..72d7161
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/memory.h
@@ -0,0 +1,73 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/memory.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef __MEMORY_H__
+#define __MEMORY_H__
+
+/* Physical addresses of memories */
+#define COMCERTO_SDRAM_BASE				0x80800000
+#define COMCERTO_ARAM_BASE				0x0A000000
+#define COMCERTO_ERAM_BASE				0x08000000
+#define COMCERTO_IRAM_BASE				0x09000000
+
+#define ARAM_MEMORY_SIZE				SZ_64K
+
+#define SDRAM_MSP_MEMORY_PHY			0x80000000
+#define SDRAM_MSP_MEMORY_SIZE			SZ_8M
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+
+#define COMCERTO_PCIDMA_SIZE1		0x40000000 /* 1 GiB */
+#define COMCERTO_PCIDMA_SIZE_MASK1	(~(COMCERTO_PCIDMA_SIZE1 - 1))
+/* Must cover all physical memory and be aligned on PCIDMA_SIZE */
+#define COMCERTO_PCIDMA_SYS_BASE_ADDR1	0x80000000
+/* Must be aligned on PCIDMA_SIZE and should
+ * not overlap with PCI IO and PCI MEM */
+#define COMCERTO_PCIDMA_PCI_BASE_ADDR1	0x80000000
+
+#define COMCERTO_PCIDMA_SIZE2		ARAM_MEMORY_SIZE /* 64KiB */
+#define COMCERTO_PCIDMA_SIZE_MASK2	(~(COMCERTO_PCIDMA_SIZE2 - 1))
+#define COMCERTO_PCIDMA_SYS_BASE_ADDR2	COMCERTO_ARAM_BASE
+#define COMCERTO_PCIDMA_PCI_BASE_ADDR2	COMCERTO_ARAM_BASE
+
+
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#define msp_to_virt(p)		\
+		(void *) ((unsigned long)p - \
+		SDRAM_MSP_MEMORY_PHY + SDRAM_MSP_MEMORY_VADDR)
+#define virt_to_msp(v)		\
+		((unsigned long)v + \
+		 SDRAM_MSP_MEMORY_PHY - SDRAM_MSP_MEMORY_VADDR)
+
+#define aram_to_virt(p) (void *)(((unsigned long)p - \
+			COMCERTO_ARAM_BASE) + ARAM_MEMORY_VADDR)
+#define virt_to_aram(v) (((unsigned long)v - \
+			ARAM_MEMORY_VADDR) + COMCERTO_ARAM_BASE)
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-100/timer.h b/arch/arm/mach-comcerto/include/mach/comcerto-100/timer.h
new file mode 100644
index 0000000..5937c17
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-100/timer.h
@@ -0,0 +1,76 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-100/timer.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+/* Comcerto Timers  */
+#define COMCERTO_TIMER0_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x00)
+#define COMCERTO_TIMER0_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x04)
+#define COMCERTO_TIMER1_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x08)
+#define COMCERTO_TIMER1_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x0C)
+#define COMCERTO_TIMER2_LOW_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x10)
+#define COMCERTO_TIMER2_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x14)
+#define COMCERTO_TIMER2_CTRL			\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x18)
+#define COMCERTO_TIMER2_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x1C)
+#define COMCERTO_TIMER3_LOW_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x20)
+#define COMCERTO_TIMER3_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x24)
+#define COMCERTO_TIMER3_CTRL			\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x28)
+#define COMCERTO_TIMER3_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x2C)
+#define COMCERTO_TIMER4_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x30)
+#define COMCERTO_TIMER4_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x34)
+#define COMCERTO_TIMER5_LOW_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x38)
+#define COMCERTO_TIMER5_HIGH_BOUND		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x3C)
+#define COMCERTO_TIMER5_CURRENT_COUNT		\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x40)
+#define COMCERTO_TIMER5_CTRL			\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x44)
+#define COMCERTO_TIMER_IRQ_MASK			\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x48)
+#define COMCERTO_TIMER_STATUS			\
+			APB_VADDR(COMCERTO_APB_TIMER_BASE + 0x50)
+
+/*COMCERTO_TIMER_IRQ_MASK*/
+#define COMCERTO_TIMER0						0x01
+#define COMCERTO_TIMER1						0x02
+#define COMCERTO_TIMER2						0x04
+#define COMCERTO_TIMER3						0x08
+#define COMCERTO_TIMER4						0x10
+#define COMCERTO_TIMER5						0x20
+#define COMCERTO_ALL						0xFF
+#define COMCERTO_TIMER_CSP					0x0E
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-common.h b/arch/arm/mach-comcerto/include/mach/comcerto-common.h
new file mode 100644
index 0000000..dcfea5d
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-common.h
@@ -0,0 +1,114 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/comcerto-common.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef __ASM_COMCERTO_COMMON_H__
+#define __ASM_COMCERTO_COMMON_H__
+
+#include <asm/types.h>
+
+/*
+ * VIRTUAL ADDRESS MAPPING
+ */
+/* VA of IO on APB bus */
+#define APB_VADDR_BASE			0xe0000000
+#define SDRAM_MSP_MEMORY_VADDR		0xf0000000
+#define COMCERTO_PCI_MEM_VBASE		0xf1000000
+#define COMCERTO_PCI_IO_VBASE		0xf7000000
+#define ERAM_MEMORY_VADDR		0xf8000000
+#define IRAM_MEMORY_VADDR		0xf9000000
+#define ARAM_MEMORY_VADDR		0xfa000000
+#define COMCERTO_L2CC_VADDR_BASE	0xfa0a0000
+#define COMCERTO_IPSEC_VADDR_BASE	0xfe000000
+
+/* macro to get virtual address of IO on APB Bus from Physical address*/
+#define APB_VADDR(x)		((x) - APB_PADDR_BASE + APB_VADDR_BASE)
+
+#define IO_SPACE_LIMIT          (PCIBIOS_MIN_IO + 0xffff)
+
+#define COMCERTO_PCI_IO_BASE	PCIBIOS_MIN_IO
+#define COMCERTO_PCI_IO_SIZE	(IO_SPACE_LIMIT - PCIBIOS_MIN_IO)
+
+#define COMCERTO_PCI_MEM_BASE	PCIBIOS_MIN_MEM
+#define COMCERTO_PCI_MEM_SIZE	0x05ffffff
+#define PCIMEM_BASE		COMCERTO_PCI_MEM_VBASE
+
+
+/*
+ * GPIO
+ */
+/* Return GPIO mask from GPIO number*/
+#define comcerto_gpio_mask(gpio_number)		(1 << (gpio_number))
+
+/* Set gpio pins specified by gpiomask to be outputs */
+#define comcerto_gpio_enable_output(gpiomask)	\
+		__raw_writel(__raw_readl(COMCERTO_GPIO_OE_REG) | (gpiomask), \
+		COMCERTO_GPIO_OE_REG)
+
+/* Set output pins specified by gpiomask to low */
+#define comcerto_gpio_set_0(gpiomask)	\
+		__raw_writel(__raw_readl(COMCERTO_GPIO_OUTPUT_REG) \
+		& ~(gpiomask), COMCERTO_GPIO_OUTPUT_REG)
+
+/* Set output pins specified by gpiomask to high */
+#define comcerto_gpio_set_1(gpiomask)	\
+		__raw_writel(__raw_readl(COMCERTO_GPIO_OUTPUT_REG) | \
+		(gpiomask), COMCERTO_GPIO_OUTPUT_REG)
+
+/* Read status of input pins specified by gpiomask */
+#define comcerto_gpio_read(gpiomask)	\
+		(__raw_readl(COMCERTO_GPIO_INPUT_REG) & (gpiomask))
+
+/* a combined ack for all GPIOs */
+#define comcerto_gpio_ack_int(gpiomask)	\
+		__raw_writel((gpiomask), COMCERTO_INTC_STATUS_REG_0)
+
+
+#define comcerto_gpio_ctrl(value, mask)	do { \
+	u32 status; \
+	while (((status = __raw_readl(COMCERTO_GPIO_IOCTRL_REG)) & \
+		(mask)) != (value)) { \
+		__raw_writel(0x55555555, COMCERTO_GPIO_LOCK_REG);  \
+		__raw_writel((status & ~(mask)) | \
+			(value), COMCERTO_GPIO_IOCTRL_REG); } \
+	} while (0)
+
+/*
+ * PROCESSORS AND BUS
+ */
+#define comcerto_get_arm_clk()		\
+	((REFCLKFREQ * (__raw_readl(COMCERTO_PLL_ARM_REG) & 0x3F)) >> 1)
+#define comcerto_get_amba_clk()		\
+	((REFCLKFREQ * (__raw_readl(COMCERTO_PLL_AMBA_REG) & 0x3F)) >> 2)
+#define comcerto_set_arm_clk(mult)	\
+	(__raw_writel(2 * (mult) / REFCLKFREQ, COMCERTO_PLL_ARM_REG))
+#define comcerto_set_amba_clk(mult)	\
+	(__raw_writel(0x04000000 | (4 * (mult) / REFCLKFREQ), \
+					COMCERTO_PLL_AMBA_REG))
+
+#define comcerto_asb_arbitration(arbitration_mask) 	\
+	__raw_writel(__raw_readl(COMCERTO_ASA_TC_CR_REG) | \
+			(arbitration_mask), COMCERTO_ASA_TC_CR_REG)
+
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-devices.h b/arch/arm/mach-comcerto/include/mach/comcerto-devices.h
new file mode 100644
index 0000000..f0a8de6
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-devices.h
@@ -0,0 +1,144 @@
+/*
+ *  linux/include/mach/comcerto-devices.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_COMCERTO_DEVICES_H__
+#define __ASM_COMCERTO_DEVICES_H__
+
+#include <linux/phy.h>
+
+/*
+ * TIMERS
+ */
+
+/* Kernel needs a timer cadenced to 10ms */
+#define COMCERTO_KERNEL_TIMER_VALUE	(COMCERTO_AHBCLK * 1000 * 1000 / HZ)
+#define machinecycles_to_usecs(ticks) ((ticks) / COMCERTO_AHBCLK)
+
+/*Hardware Timer API*/
+#define COMCERTO_TIMER_RUN_ONCE		(1 << 0)
+#define comcerto_timer_enable(t)	\
+	__raw_writel(__raw_readl(COMCERTO_TIMER_IRQ_MASK) | (1 << (t)), \
+						COMCERTO_TIMER_IRQ_MASK)
+
+#define comcerto_timer_disable(t)	\
+	__raw_writel(__raw_readl(COMCERTO_TIMER_IRQ_MASK) & ~(1 << (t)), \
+						COMCERTO_TIMER_IRQ_MASK)
+
+
+#define comcerto_timer0_set(hbound)	\
+		__raw_writel((hbound), COMCERTO_TIMER0_HIGH_BOUND)
+#define comcerto_timer0_get()		\
+		__raw_readl(COMCERTO_TIMER0_CURRENT_COUNT)
+
+#define comcerto_timer1_set(hbound)	\
+		__raw_writel((hbound) & 0x3FFFFFFF, COMCERTO_TIMER1_HIGH_BOUND)
+#define comcerto_timer1_get()		\
+		__raw_readl(COMCERTO_TIMER1_CURRENT_COUNT)
+
+#define comcerto_timer2_set(lbound, hbound, ctrl)  do {\
+		      __raw_writel((ctrl) & 0x1, COMCERTO_TIMER2_CTRL);	\
+		      __raw_writel((lbound), COMCERTO_TIMER2_LOW_BOUND); \
+		      __raw_writel((hbound), COMCERTO_TIMER2_HIGH_BOUND); \
+		   } while (0)
+
+#define comcerto_timer2_get()	__raw_readl(COMCERTO_TIMER2_CURRENT_COUNT)
+
+
+#define comcerto_timer3_set(lbound, hbound, ctrl)  do {	\
+			__raw_writel((ctrl) & 0x1, COMCERTO_TIMER3_CTRL); \
+			__raw_writel((lbound), COMCERTO_TIMER3_LOW_BOUND); \
+			__raw_writel((hbound), COMCERTO_TIMER3_HIGH_BOUND); \
+			} while (0)
+
+#define comcerto_timer3_get()	__raw_readl(COMCERTO_TIMER3_CURRENT_COUNT)
+
+#ifndef __ASSEMBLY__
+struct comcerto_timer {
+	unsigned long timeout;
+	void (*func) (unsigned long data);
+	unsigned long data;
+	u8 flags;
+	unsigned long thw;
+};
+
+
+#define CONFIG_COMCERTO_USE_MII			1
+#define CONFIG_COMCERTO_USE_RMII		2
+#define CONFIG_COMCERTO_USE_GMII		4
+#define CONFIG_COMCERTO_USE_RGMII		8
+
+/* GEMAC configured by SW */
+#define GEMAC_SW_CONF		((1 << 8) | (1 << 11))
+/* GEMAC configured by phy lines (not for MII/GMII) */
+#define GEMAC_PHY_CONF		0
+#define GEMAC_SW_FULL_DUPLEX	(1 << 9)
+#define GEMAC_SW_SPEED_10M	(0 << 12)
+#define GEMAC_SW_SPEED_100M	(1 << 12)
+#define GEMAC_SW_SPEED_1G	(2 << 12)
+
+/* set if a GIg phy available */
+#define GEMAC_PHY_1000			1
+/* set if no phy connected to MAC (ex ethernet switch).
+ * In this case use MAC fixed configuration */
+#define GEMAC_NO_PHY			2
+#define GEMAC_PHY_RGMII_ADD_DELAY 	4
+
+struct comcerto_eth_platform_data {
+	char name[16];
+	/* board specific information */
+	u32 mii_config;
+	u32 gemac_mode;
+	u32 phy_flags;
+	u32 gem_id;
+	char  bus_id[MII_BUS_ID_SIZE];
+	u32 phy_id;
+	u8 *mac_addr;
+};
+
+struct comcerto_mdio_data {
+	int irq[32];
+	u32 phy_mask;
+};
+
+/* L210 cache controller value
+     Configure Aux:
+       [11:9]=[8:6]=[2:0]=001 RAM LAT = 2 cycles
+       [5:3]=000    Data write latency is 1
+       [12]=0       WRAP access is enabled
+       [16:13]=1000 8-way cache
+       [19:17]=001  16KB way
+       [20]=1       Event bus is enabled
+       [21]=1       Parity is enabled
+       [22]=0       Shared accesses treated as noncacheable
+       [23]=0       HPROT is used
+       [24]=1       Abort generation of exclusive access disabled
+*/
+#define L210_AUX_CTRL_REG	0x01330241
+
+
+
+int timer_hw_handler(u8 id);
+int comcerto_timer_start(struct comcerto_timer *t);
+int comcerto_timer_stop(struct comcerto_timer *t);
+int comcerto_timer_read(struct comcerto_timer *t);
+
+#endif
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/debug-macro.S b/arch/arm/mach-comcerto/include/mach/debug-macro.S
new file mode 100644
index 0000000..87943a2
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/debug-macro.S
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/debug-macro.S
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(CONFIG_ARCH_M825XX1)
+#define UART_LSR	0x10
+#else
+#define UART_LSR	0x14
+#endif
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1			@ MMU enabled?
+	moveq	\rx, #0x10000000	@ physical base address
+	movne	\rx, #0xe0000000	@ virtual base
+	orr	\rx, \rx, #0x00090000	@ UART0
+	.endm
+
+	.macro	senduart,rd,rx
+	strb	\rd, [\rx, #0x00]
+	.endm
+
+	.macro	waituart,rd,rx
+1001:	ldrb	\rd, [\rx, #UART_LSR]
+	tst	\rd, #0x20		@ wait for THRE
+	beq	1001b
+	.endm
+
+	.macro	busyuart,rd,rx
+1001:	ldrb	\rd, [\rx, #UART_LSR]
+	and	\rd, \rd, #0x60
+	teq	\rd, #0x60		@ wait for TEMT and THRE
+	bne	1001b
+	.endm
+
diff --git a/arch/arm/mach-comcerto/include/mach/debug.h b/arch/arm/mach-comcerto/include/mach/debug.h
new file mode 100644
index 0000000..cf0ae2f
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/debug.h
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/debug.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#include <linux/kernel.h>
+
+/* debug messages: to disable comment the next line */
+#define DEBUG_MSG
+
+/* several debug levels: 1 enables, 0 disables */
+
+#define DEBUG_ALWAYS 		1
+
+/* prints general information */
+#define DEBUG_INFO			1
+
+/* prints timing information */
+#define DEBUG_TIMING		0
+
+#define DEBUG_DISPLAY 		1
+
+#define VED_INIT_FUNC		1
+#define VED_RX_FUNC		0
+#define VED_TX_FUNC		0
+#define VED_STATE		0
+#define SMI_PART		0
+
+#define SKB_POOL_ERR		1
+#define SKB_POOL_INIT		0
+#define SKB_POOL_FUNC		0
+
+#define MSP_ERR			1
+#define MSP_INIT		0
+#define MSP_FUNC		0
+
+
+/* add other debug messages types here */
+
+/* the debug macro */
+#ifdef DEBUG_MSG
+#define info(fmt, args...) printk(KERN_INFO __FILE__ ": " fmt "\n" , ## args)
+#define PDEBUG(type, fmt, args...) \
+	do {if (type) info("%d: " fmt, __LINE__ , ## args); } while (0)
+#else
+#define PDEBUG(type, fmt, args...) do {} while (0)
+#endif
+
+#endif	/* _DEBUG_H */
diff --git a/arch/arm/mach-comcerto/include/mach/dma.h b/arch/arm/mach-comcerto/include/mach/dma.h
new file mode 100644
index 0000000..93d899d
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/dma.h
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/dma.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
+
diff --git a/arch/arm/mach-comcerto/include/mach/entry-macro.S b/arch/arm/mach-comcerto/include/mach/entry-macro.S
new file mode 100644
index 0000000..ea4cdbf
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/entry-macro.S
@@ -0,0 +1,83 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/entry-macro.S
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <mach/hardware.h>
+
+#if defined(CONFIG_ARCH_COMCERTO)
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+#if defined(CONFIG_ARCH_M821XX)
+
+		mov	\irqnr, #0
+		ldr	\base, =COMCERTO_INTC_CSP_IRQ_WNR
+		ldr	\tmp, [\base]
+		cmp	\tmp, #0
+		beq	10011f
+		cmp	\tmp, #32
+		movne	\irqnr, \tmp
+		bne	1004f
+#else
+		mov	\irqnr, #0
+		ldr	\base, =COMCERTO_INTC_STATUS_REG_0
+		ldr	\tmp, =COMCERTO_INTC_CSP_IRQMASK_0
+		ldr	\irqstat, [\base]
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp
+		beq	10011f
+
+1002:		tst	\irqstat, #1
+		bne	1004f
+		add	\irqnr, \irqnr, #1
+		mov	\irqstat, \irqstat, lsr #1
+		cmp	\irqnr, #32
+		bcc	1002b
+#endif
+
+
+10011:
+		mov	\irqnr, #0
+		ldr	\base, =COMCERTO_INTC_STATUS_REG_1
+		ldr	\tmp, =COMCERTO_INTC_CSP_IRQMASK_1
+		ldr	\irqstat, [\base]
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp
+		beq	1004f
+
+1001:	tst	\irqstat, #1
+		bne	1003f
+		add	\irqnr, \irqnr, #1
+		mov	\irqstat, \irqstat, lsr #1
+		cmp	\irqnr, #32
+		bcc	1001b
+1003:		add	\irqnr, \irqnr, #32
+
+1004:
+		.endm
+
+                .macro  irq_prio_table
+                .endm
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/hardware.h b/arch/arm/mach-comcerto/include/mach/hardware.h
new file mode 100644
index 0000000..6a610b4
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/hardware.h
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/hardware.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/***** Device *****/
+#if defined(CONFIG_ARCH_M821XX)
+	#include <mach/comcerto-100.h>
+#else
+	#error "mach/hardware.h :  Unknown architecture"
+#endif
+
+/***** Board *****/
+#if defined(CONFIG_EVM_ROUTER)
+	#include <mach/boards/board-router.h>
+#else
+	#error "mach/hardware.h :  Unknown board"
+#endif
+
+#include <mach/comcerto-common.h>
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/io.h b/arch/arm/mach-comcerto/include/mach/io.h
new file mode 100644
index 0000000..fb7e1ff
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/io.h
@@ -0,0 +1,431 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/io.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+#if !defined(CONFIG_PCI)
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#else
+
+#define PCI_SPACE_TYPE_CONFIG_TYPE0	0x1
+#define PCI_SPACE_TYPE_CONFIG_TYPE1	0x2
+#define PCI_SPACE_TYPE_IO		0x3
+#define PCI_SPACE_TYPE_MEM		0x4
+
+#if defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE)
+
+#define __mem_pci(a)	(a)
+
+#define outb(v, p)	outb_not_supported
+#define outw(v, p)	outw_not_supported
+#define outl(v, p)	outl_not_supported
+
+#define inb(p)		inb_not_supported
+#define inw(p)		inw_not_supported
+#define inl(p)		inl_not_supported
+
+#define outsb(p, d, l)	outsb_not_supported
+#define outsw(p, d, l)	outsw_not_supported
+#define outsl(p, d, l)	outsl_not_supporte
+
+#define insb(p, d, l)	insb_not_supportedi
+#define insw(p, d, l)	insw_not_supported
+#define insl(p, d, l)	insl_not_supported
+
+#else
+
+#define __comcerto_io(a)	(a)
+#define __comcerto_mem_pci(a)	(a)
+
+extern u8 comcerto_pci_readb(u32 addr, u8 space_type);
+extern u16 comcerto_pci_readw(u32 addr, u8 space_type);
+extern u32 comcerto_pci_readl(u32 addr, u8 space_type);
+
+extern void comcerto_pci_writeb(u32 addr, u8 value, u8 space_type);
+extern void comcerto_pci_writew(u32 addr, u16 value, u8 space_type);
+extern void comcerto_pci_writel(u32 addr, u32 value, u8 space_type);
+
+#define IS_PCI_MEM_PADDR(addr)	\
+	(((unsigned long)(addr) >= COMCERTO_PCI_MEM_BASE) && \
+	 ((unsigned long)(addr) <= (COMCERTO_PCI_MEM_BASE + \
+				COMCERTO_PCI_MEM_SIZE)))
+
+#define IS_PCI_MEM_VADDR(addr)	\
+	(((unsigned long)(addr) >= COMCERTO_PCI_MEM_VBASE) && \
+	 ((unsigned long)(addr) <= (COMCERTO_PCI_MEM_VBASE + \
+				COMCERTO_PCI_MEM_SIZE)))
+
+#define IS_PCI_IO_PADDR(addr)	\
+	(((unsigned long)(addr) >= COMCERTO_PCI_IO_BASE) && \
+	((unsigned long)(addr) <= (COMCERTO_PCI_IO_BASE + \
+					COMCERTO_PCI_IO_SIZE)))
+
+#define IS_PCI_IO_VADDR(addr)	\
+	(((unsigned long)(addr) >= COMCERTO_PCI_IO_VBASE) && \
+	((unsigned long)(addr) <= (COMCERTO_PCI_IO_VBASE + \
+					COMCERTO_PCI_IO_SIZE)))
+
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+#define __iomem_to_pci(virt)	((unsigned long)(virt))
+#define __ioport_to_pci(phy)	((unsigned long)(phy) - COMCERTO_PCI_MEM_BASE \
+						+ COMCERTO_PCI_MEM_VBASE)
+#else
+#define __iomem_to_pci(virt)	((unsigned long)(virt) - \
+			COMCERTO_PCI_MEM_VBASE + COMCERTO_PCI_MEM_BASE)
+#define __ioport_to_pci(phy)	((unsigned long)(phy))
+#endif
+
+#define __pci_to_iomem(phy)	\
+	((void __iomem *)((phy) - \
+		COMCERTO_PCI_MEM_BASE + COMCERTO_PCI_MEM_VBASE))
+
+static
+inline void __comcerto_outsb(unsigned int port, const void *data, int bytelen)
+{
+	unsigned char *datap = (unsigned char *)data;
+	while (bytelen--)
+		comcerto_pci_writeb(__ioport_to_pci(port), *(datap)++, \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_outsw(unsigned int port, const void *data, \
+								int wordlen)
+{
+	unsigned short *datap = (unsigned short *)data;
+	while (wordlen--)
+		comcerto_pci_writew(__ioport_to_pci(port), *(datap)++, \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_outsl(unsigned int port, const void *data, \
+								int longlen)
+{
+	unsigned int *datap = (unsigned int *)data;
+	while (longlen--)
+		comcerto_pci_writel(__ioport_to_pci(port), *(datap)++, \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_insb(unsigned int port, void *data, int bytelen)
+{
+	unsigned char *datap = (unsigned char *)data;
+	while (bytelen--)
+		*(datap)++ = comcerto_pci_readb(__ioport_to_pci(port), \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_insw(unsigned int port, void *data, int wordlen)
+{
+	unsigned short *datap = (unsigned short *)data;
+	while (wordlen--)
+		*(datap)++ = comcerto_pci_readw(__ioport_to_pci(port), \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_insl(unsigned int port, void *data, int longlen)
+{
+	unsigned int *datap = (unsigned int *)data;
+	while (longlen--)
+		*(datap)++ = comcerto_pci_readl(__ioport_to_pci(port), \
+							PCI_SPACE_TYPE_IO);
+}
+
+static inline void __comcerto_writesb(void __iomem *addr, const void *data, \
+								int bytelen)
+{
+	unsigned char *datap = (unsigned char *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (bytelen--)
+			comcerto_pci_writeb(__iomem_to_pci(addr), \
+					*(datap)++, PCI_SPACE_TYPE_MEM);
+	else
+		__raw_writesb(addr, data, bytelen);
+}
+
+static inline void __comcerto_writesw(void __iomem *addr, const void *data, \
+								int wordlen)
+{
+	unsigned short *datap = (unsigned short *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (wordlen--)
+			comcerto_pci_writew(__iomem_to_pci(addr), \
+					*(datap)++, PCI_SPACE_TYPE_MEM);
+	else
+		__raw_writesw(addr, data, wordlen);
+}
+
+static inline
+void __comcerto_writesl(void __iomem *addr, const void *data, int longlen)
+{
+	unsigned int *datap = (unsigned int *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (longlen--)
+			comcerto_pci_writel(__iomem_to_pci(addr), *(datap)++, \
+							PCI_SPACE_TYPE_MEM);
+	else
+		__raw_writesl(addr, data, longlen);
+}
+
+static inline
+void __comcerto_readsb(void __iomem *addr, void *data, int bytelen)
+{
+	unsigned char *datap = (unsigned char *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (bytelen--)
+			*(datap)++ = comcerto_pci_readb(__iomem_to_pci(addr), \
+							PCI_SPACE_TYPE_MEM);
+	else
+		__raw_readsb(addr, data, bytelen);
+}
+
+static inline
+void __comcerto_readsw(void __iomem *addr, void *data, int wordlen)
+{
+	unsigned short *datap = (unsigned short *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (wordlen--)
+			*(datap)++ = comcerto_pci_readw(__iomem_to_pci(addr), \
+							PCI_SPACE_TYPE_MEM);
+	else
+		__raw_readsw(addr, data, wordlen);
+}
+
+static inline
+void __comcerto_readsl(void __iomem *addr, void *data, int longlen)
+{
+	unsigned int *datap = (unsigned int *)data;
+	if (IS_PCI_MEM_VADDR(addr))
+		while (longlen--)
+			*(datap)++ = comcerto_pci_readl(__iomem_to_pci(addr), \
+							PCI_SPACE_TYPE_MEM);
+	else
+		__raw_readsl(addr, data, longlen);
+}
+
+
+#define __comcerto_outb(v, a)	\
+	(comcerto_pci_writeb(__ioport_to_pci(a), (v), PCI_SPACE_TYPE_IO))
+#define __comcerto_outw(v, a)	\
+	(comcerto_pci_writew(__ioport_to_pci(a), (v), PCI_SPACE_TYPE_IO))
+#define __comcerto_outl(v, a)	\
+	(comcerto_pci_writel(__ioport_to_pci(a), (v), PCI_SPACE_TYPE_IO))
+#define __comcerto_inb(a)	\
+	(comcerto_pci_readb(__ioport_to_pci(a), PCI_SPACE_TYPE_IO))
+#define __comcerto_inw(a)	\
+	(comcerto_pci_readw(__ioport_to_pci(a), PCI_SPACE_TYPE_IO))
+#define __comcerto_inl(a)	\
+	(comcerto_pci_readl(__ioport_to_pci(a), PCI_SPACE_TYPE_IO))
+
+#define __comcerto_writeb(v, a)	\
+		(IS_PCI_MEM_VADDR(a) ? \
+		comcerto_pci_writeb(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_MEM)\
+		 : __raw_writeb((v), (a)))
+
+#define __comcerto_writew(v, a)	\
+	(IS_PCI_MEM_VADDR(a) ? \
+	 comcerto_pci_writew(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_MEM) :\
+	 __raw_writew((v), (a)))
+
+#define __comcerto_writel(v, a)	\
+	(IS_PCI_MEM_VADDR(a) ? \
+	 comcerto_pci_writel(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_MEM) : \
+	 __raw_writel((v), (a)))
+
+#define __comcerto_readb(a)	\
+	(IS_PCI_MEM_VADDR(a) ? \
+	 comcerto_pci_readb(__iomem_to_pci(a), PCI_SPACE_TYPE_MEM) : \
+	 __raw_readb(a))
+
+#define __comcerto_readw(a)	\
+	(IS_PCI_MEM_VADDR(a) ? \
+	 comcerto_pci_readw(__iomem_to_pci(a), PCI_SPACE_TYPE_MEM) :\
+	 __raw_readw(a))
+
+#define __comcerto_readl(a)	\
+	(IS_PCI_MEM_VADDR(a) ? \
+	 comcerto_pci_readl(__iomem_to_pci(a), PCI_SPACE_TYPE_MEM) : \
+	 __raw_readl(a))
+
+#define __comcerto_iowrite8(v, a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_writeb(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_IO) : \
+	 __comcerto_writeb((v), (a)))
+
+#define __comcerto_iowrite16(v, a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_writew(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_IO) : \
+	 __comcerto_writew((v), (a)))
+
+#define __comcerto_iowrite32(v, a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_writel(__iomem_to_pci(a), (v), PCI_SPACE_TYPE_IO) : \
+	 __comcerto_writel((v), (a)))
+
+#define __comcerto_ioread8(a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_readb(__iomem_to_pci(a), PCI_SPACE_TYPE_IO) : \
+	 __comcerto_readb(a))
+
+#define __comcerto_ioread16(a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_readw(__iomem_to_pci(a), PCI_SPACE_TYPE_IO) : \
+	 __comcerto_readw(a))
+
+#define __comcerto_ioread32(a)	\
+	(IS_PCI_IO_VADDR(a) ? \
+	 comcerto_pci_readl(__iomem_to_pci(a), PCI_SPACE_TYPE_IO) :\
+	 __comcerto_readl(a))
+
+static inline void
+__iomem *__comcerto_ioremap(unsigned long cookie, size_t size, \
+						unsigned long flag)
+{
+	if (IS_PCI_MEM_PADDR(cookie))
+		return __pci_to_iomem(cookie);
+	else
+		return __arm_ioremap(cookie, size, flag);
+}
+
+static inline void __comcerto_iounmap(void __iomem *addr)
+{
+	if (!IS_PCI_MEM_VADDR(addr))
+		__iounmap(addr);
+}
+
+static inline void
+__iomem *__comcerto_ioport_map(unsigned long port, unsigned int nr)
+{
+	return __pci_to_iomem(port);
+}
+
+static inline void __comcerto_ioport_unmap(void __iomem *addr)
+{
+	return;
+}
+
+
+/*
+ *  IO port access primitives
+ *  -------------------------
+ */
+
+#define outb(v, p)	__comcerto_outb((__u8)v, __comcerto_io(p))
+#define outw(v, p)	__comcerto_outw((__force __u16) \
+		cpu_to_le16(v), __comcerto_io(p))
+#define outl(v, p)	__comcerto_outl((__force __u32) \
+		cpu_to_le32(v), __comcerto_io(p))
+
+#define inb(p)		({ __u8 __v = __comcerto_inb(__comcerto_io(p)); __v; })
+#define inw(p)		({ __u16 __v = le16_to_cpu((__force __le16) \
+			__comcerto_inw(__comcerto_io(p))); __v; })
+#define inl(p)		({ __u32 __v = le32_to_cpu((__force __le32) \
+			__comcerto_inl(__comcerto_io(p))); __v; })
+
+#define outsb(p, d, l)	__comcerto_outsb(__comcerto_io(p), d, l)
+#define outsw(p, d, l)	__comcerto_outsw(__comcerto_io(p), d, l)
+#define outsl(p, d, l)	__comcerto_outsl(__comcerto_io(p), d, l)
+
+#define insb(p, d, l)	__comcerto_insb(__comcerto_io(p), d, l)
+#define insw(p, d, l)	__comcerto_insw(__comcerto_io(p), d, l)
+#define insl(p, d, l)	__comcerto_insl(__comcerto_io(p), d, l)
+
+/*
+ *  Memory access primitives
+ *  ------------------------
+ */
+
+#define readb(c) ({ __u8 __v = __comcerto_readb(__comcerto_mem_pci(c)); __v; })
+#define readw(c) ({ __u16 __v = le16_to_cpu((__force __le16) \
+			__comcerto_readw(__comcerto_mem_pci(c))); __v; })
+#define readl(c) ({ __u32 __v = le32_to_cpu((__force __le32) \
+			__comcerto_readl(__comcerto_mem_pci(c))); __v; })
+
+#define readb_relaxed(addr) readb(addr)
+#define readw_relaxed(addr) readw(addr)
+#define readl_relaxed(addr) readl(addr)
+
+#define readsb(p, d, l)		__comcerto_readsb(__comcerto_mem_pci(p), d, l)
+#define readsw(p, d, l)		__comcerto_readsw(__comcerto_mem_pci(p), d, l)
+#define readsl(p, d, l)		__comcerto_readsl(__comcerto_mem_pci(p), d, l)
+
+#define writeb(v, c)		__comcerto_writeb(v, __comcerto_mem_pci(c))
+#define writew(v, c)		__comcerto_writew((__force __u16) \
+		cpu_to_le16(v), __comcerto_mem_pci(c))
+#define writel(v, c)		__comcerto_writel((__force __u32) \
+		cpu_to_le32(v), __comcerto_mem_pci(c))
+
+#define writesb(p, d, l)	\
+		__comcerto_writesb(__comcerto_mem_pci(p), d, l)
+#define writesw(p, d, l)	\
+		__comcerto_writesw(__comcerto_mem_pci(p), d, l)
+#define writesl(p, d, l)	\
+		__comcerto_writesl(__comcerto_mem_pci(p), d, l)
+
+#define memset_io(c, v, l)	_memset_io(__comcerto_mem_pci(c), (v), (l))
+#define memcpy_fromio(a, c, l)	_memcpy_fromio((a), __comcerto_mem_pci(c), (l))
+#define memcpy_toio(c, a, l)	_memcpy_toio(__comcerto_mem_pci(c), (a), (l))
+
+/*
+ * ioremap and friends.
+ */
+
+#define __arch_ioremap(cookie, size, flag)	\
+		__comcerto_ioremap((cookie), (size), (flag))
+#define __arch_iounmap(cookie)			\
+		__comcerto_iounmap(cookie)
+
+/*
+ * io{read, write}{8,16,32} macros
+ */
+
+#define ioread8(p)	\
+	({ unsigned int __v = __comcerto_ioread8(p); __v; })
+#define ioread16(p)	\
+	({ unsigned int __v = le16_to_cpu(__comcerto_ioread16(p)); __v; })
+#define ioread32(p)	\
+	({ unsigned int __v = le32_to_cpu(__comcerto_ioread32(p)); __v; })
+
+#define iowrite8(v, p)	__comcerto_iowrite8(v, p)
+#define iowrite16(v, p)	__comcerto_iowrite16(cpu_to_le16(v), p)
+#define iowrite32(v, p)	__comcerto_iowrite32(cpu_to_le32(v), p)
+
+
+#define ioread8_rep(p, d, c)	readsb(p, d, c)
+#define ioread16_rep(p, d, c)	readsw(p, d, c)
+#define ioread32_rep(p, d, c)	readsl(p, d, c)
+
+#define iowrite8_rep(p, s, c)	writesb(p, s, c)
+#define iowrite16_rep(p, s, c)	writesw(p, s, c)
+#define iowrite32_rep(p, s, c)	writesl(p, s, c)
+
+#define ioport_map(c, s)		__comcerto_ioport_map(c, s)
+#define ioport_unmap(addr)	__comcerto_ioport_unmap(addr)
+
+#endif /* defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE) */
+#endif /* !defined(CONFIG_PCI) */
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff --git a/arch/arm/mach-comcerto/include/mach/irqs.h b/arch/arm/mach-comcerto/include/mach/irqs.h
new file mode 100644
index 0000000..701fae4
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/irqs.h
@@ -0,0 +1,17 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/irqs.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <mach/hardware.h>
+
+#endif  /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-comcerto/include/mach/memory.h b/arch/arm/mach-comcerto/include/mach/memory.h
new file mode 100644
index 0000000..9bae8ce
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/memory.h
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/memory.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <mach/hardware.h>
+
+#define PHYS_OFFSET	COMCERTO_SDRAM_BASE
+
+#define __virt_to_bus(x)		__virt_to_phys(x)
+#define __bus_to_virt(x)		__phys_to_virt(x)
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/system.h b/arch/arm/mach-comcerto/include/mach/system.h
new file mode 100644
index 0000000..305cba3
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/system.h
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/system.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <mach/hardware.h>
+#include <linux/io.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	unsigned int val;
+
+	while (1) {
+		val = __raw_readl(COMCERTO_PHI_APB_FIFO_INTACK);
+		val |= 0x0100;
+		__raw_writel(val, COMCERTO_PHI_APB_FIFO_INTACK);
+/*
+		val = *(volatile u32*) (COMCERTO_PHI_APB_FIFO_INTACK);
+		val |= 0x0100;
+		*(volatile u32*) (COMCERTO_PHI_APB_FIFO_INTACK) = val;
+*/
+	}
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
diff --git a/arch/arm/mach-comcerto/include/mach/timex.h b/arch/arm/mach-comcerto/include/mach/timex.h
new file mode 100644
index 0000000..da1097c
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/timex.h
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/timex.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+	#include <mach/hardware.h>
+
+	#define CLOCK_TICK_RATE			(COMCERTO_AHBCLK * 1000 * 1000)
+
+#endif
diff --git a/arch/arm/mach-comcerto/include/mach/uncompress.h b/arch/arm/mach-comcerto/include/mach/uncompress.h
new file mode 100644
index 0000000..62c537d
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/uncompress.h
@@ -0,0 +1,61 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/uncompress.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+/* Tx/Rx Register */
+#define COMCERTO_UART0_DR	(*(unsigned long *)0x10090000)
+/* Status register */
+#define M825XX1_UART0_SSR	(*(unsigned long *)0x10090010)
+/* Line Status Register (read only) */
+#define COMCERTO_UART0_LSR	(*(unsigned long *)0x10090014)
+
+
+#if defined(CONFIG_ARCH_M821XX)
+#define UART_DR		COMCERTO_UART0_DR
+#define UART_LSR	COMCERTO_UART0_LSR
+#else
+#define UART_DR		COMCERTO_UART0_DR
+#define UART_LSR	M825XX1_UART0_SSR
+#endif
+
+static inline void putc(int c)
+{
+	while (!(UART_LSR & 0x20))
+		barrier();
+	UART_DR = c;
+}
+
+/*
+ * nothing to do
+ */
+static inline void flush(void)
+{
+}
+
+static inline void arch_decomp_setup(void)
+{
+}
+
+static inline void arch_decomp_wdog(void)
+{
+}
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
diff --git a/arch/arm/mach-comcerto/include/mach/vmalloc.h b/arch/arm/mach-comcerto/include/mach/vmalloc.h
new file mode 100644
index 0000000..89a7899
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/vmalloc.h
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-comcerto/vmalloc.h
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define VMALLOC_END       (0xE0000000)
diff --git a/arch/arm/mach-comcerto/pci-comcerto100.c b/arch/arm/mach-comcerto/pci-comcerto100.c
new file mode 100644
index 0000000..573179d
--- /dev/null
+++ b/arch/arm/mach-comcerto/pci-comcerto100.c
@@ -0,0 +1,662 @@
+/*
+ *  linux/arch/arm/mach-comcerto/pci-comcerto100.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <asm/mach/pci.h>
+#include <asm/mach/irq.h>
+
+#define APBB_CTRL_DEFAULT \
+		(APBB_CTRL_LATTMR | APBB_CTRL_REQLAST | APBB_CTRL_EN)
+
+#define MAX_BURST_LEN	16
+
+extern spinlock_t comcerto_pci_lock;
+
+extern void __comcerto_pci_host_init(void);
+extern  int __comcerto_host_read_config(int where, int size, u32 *value);
+
+#if !defined(CONFIG_COMCERTO_PCI_USE_APBB)
+int __comcerto_pci_check(int rx);
+#endif
+
+#if !defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE)
+/**
+ * comcerto_pci_read -
+ *
+ */
+void comcerto_pci_read(u32 addr, int size, u8 *buf, u8 space_type)
+{
+	unsigned long flags;
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+	BUG();
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#else
+
+	u32 burst = (size + 3) / 4;
+	int rc;
+
+	if (burst > MAX_BURST_LEN)
+		burst = MAX_BURST_LEN;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+	/* load destination of value */
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	/* load length in bytes */
+	__raw_writel(size, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	/* burst length in PCI data cycles, i.e, 32 bits */
+	__raw_writel(burst, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001E, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001F, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(1);
+	if (!rc) {
+		do {
+			if (size >= 4) {
+				*((u32 *)buf) = __raw_readl(\
+						COMCERTO_PHI_APB_FIFO_DATA_U32);
+				buf += 4;
+				size -= 4;
+			} else if (size >= 2) {
+				*((u16 *)buf) = __raw_readw(\
+						COMCERTO_PHI_APB_FIFO_DATA_U16);
+				buf += 2;
+				size -= 2;
+			} else if (size >= 1) {
+				*buf = __raw_readb(\
+						COMCERTO_PHI_APB_FIFO_DATA_U8);
+				buf++;
+				size--;
+			}
+		} while (size);
+	} else
+		printk(KERN_ERR "read: addr: %#x, size: %#x, type: %#x\n", \
+							addr, size, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_read);
+
+
+/**
+ * comcerto_pci_readl -
+ *
+ */
+u32 comcerto_pci_readl(u32 addr, u8 space_type)
+{
+	unsigned long flags;
+	u32 value = 0;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	value = __raw_readl(addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#else
+	int rc;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+	/* load destination of value */
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	/* load length in bytes */
+	__raw_writel(4, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	/* burst length in PCI data cycles, i.e, 32 bits */
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001E, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001F, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(1);
+	if (!rc)
+		value = __raw_readl(COMCERTO_PHI_APB_FIFO_DATA_U32);
+	else
+		printk(KERN_ERR "readl: addr: %#x, value: %#x, type: %#x\n", \
+						addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_readl);
+
+/**
+ * comcerto_pci_readw -
+ *
+ */
+u16 comcerto_pci_readw(u32 addr, u8 space_type)
+{
+	unsigned long flags;
+	u16 value = 0;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	value = __raw_readw(addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#else
+	int rc;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	/* load destination of value */
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	/* load length in bytes */
+	__raw_writel(4, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	/* burst length in PCI data cycles, i.e, 32 bits */
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001E, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001F, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(1);
+	if (!rc)
+		value = __raw_readw(COMCERTO_PHI_APB_FIFO_DATA_U16);
+	else
+		printk(KERN_ERR "readw: addr: %#x, value: %#x, type: %#x\n", \
+					`	addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_readw);
+
+/**
+ * comcerto_pci_readb -
+ *
+ */
+u8 comcerto_pci_readb(u32 addr, u8 space_type)
+{
+	unsigned long flags;
+	u8 value = 0;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	value = __raw_readb(addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#else
+	int rc;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	/* load destination of value */
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	/* load length in bytes */
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	/* burst length in PCI data cycles, i.e, 32 bits */
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001E, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001F, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(1);
+	if (!rc)
+		value = __raw_readb(COMCERTO_PHI_APB_FIFO_DATA_U8);
+	else
+		printk(KERN_ERR "readb: addr: %#x, value: %#x, type: %#x\n",
+						addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return value;
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_readb);
+
+/**
+ * comcerto_pci_write -
+ *
+ */
+void comcerto_pci_write(u32 addr, int size, u8 *buf, u8 space_type)
+{
+	unsigned long flags;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+	BUG();
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#else
+	int size_tmp = size;
+	u32 burst = (size + 3) / 4;
+
+	if (burst > MAX_BURST_LEN)
+		burst = MAX_BURST_LEN;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	do {
+		if (size >= 4) {
+			__raw_writel(*((u32 *)buf), \
+					COMCERTO_PHI_APB_FIFO_DATA_U32);
+			buf += 4;
+			size -= 4;
+		} else if (size >= 2) {
+			__raw_writew(*((u16 *)buf), \
+					COMCERTO_PHI_APB_FIFO_DATA_U16);
+			buf += 2;
+			size -= 2;
+		} else if (size >= 1) {
+			__raw_writeb(*buf, COMCERTO_PHI_APB_FIFO_DATA_U8);
+			buf++;
+			size--;
+		}
+	} while (size);
+
+	__raw_writel(FLUSH_RX, COMCERTO_PHI_APB_FIFO_INTACK);
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	__raw_writel(size_tmp, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	__raw_writel(burst, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001A, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001B, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	if (__comcerto_pci_check(0))
+		printk(KERN_ERR "write: addr: %#x, size: %#x, type: %#x\n",
+						addr, size_tmp, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_write);
+
+/**
+ * comcerto_pci_writeb -
+ *
+ */
+void comcerto_pci_writeb(u32 addr, u8 value, u8 space_type)
+{
+	unsigned long flags;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	__raw_writeb(value, addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#else
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	__raw_writeb(value, COMCERTO_PHI_APB_FIFO_DATA_U8);
+
+	__raw_writel(FLUSH_RX, COMCERTO_PHI_APB_FIFO_INTACK);
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001A, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001B, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	if (__comcerto_pci_check(0))
+		printk(KERN_ERR "writeb: addr: %#x, value: %#x, type: %#x\n",
+						addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_writeb);
+
+/**
+ * comcerto_pci_writew -
+ *
+ */
+void comcerto_pci_writew(u32 addr, u16 value, u8 space_type)
+{
+	unsigned long flags;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	__raw_writew(value, addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#else
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	__raw_writew(value, COMCERTO_PHI_APB_FIFO_DATA_U16);
+	/* flush out the value */
+	__raw_writel(FLUSH_RX, COMCERTO_PHI_APB_FIFO_INTACK);
+	/* load destination of value */
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	/* load length in bytes */
+	__raw_writel(2, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	/* burst length in PCI data cycles, i.e, 32 bits */
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001A, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001B, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	if (__comcerto_pci_check(0))
+		printk(KERN_ERR "writew: addr: %#x, value: %#x, type: %#x\n",
+						addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_writew);
+
+/**
+ * comcerto_pci_writel -
+ *
+ */
+void comcerto_pci_writel(u32 addr, u32 value, u8 space_type)
+{
+	unsigned long flags;
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(APBB_CTRL_DEFAULT, COMCERTO_APBB_CONTROL);
+	else
+		__raw_writel(APBB_CTRL_DEFAULT | APBB_CTRL_MEMIO, \
+						COMCERTO_APBB_CONTROL);
+
+	__raw_writel(value, addr);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#else
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	__raw_writel(value, COMCERTO_PHI_APB_FIFO_DATA_U32);
+
+	__raw_writel(FLUSH_RX, COMCERTO_PHI_APB_FIFO_INTACK);
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	__raw_writel(4, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_IO)
+		__raw_writel(0x0001A, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0x0001B, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	if (__comcerto_pci_check(0))
+		printk(KERN_ERR "writel: addr: %#x, value: %#x, type: %#x\n",
+						addr, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+#endif
+}
+EXPORT_SYMBOL(comcerto_pci_writel);
+
+#endif /* !defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE) */
+
+#if defined(CONFIG_COMCERTO_PCI_DEBUG)
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+
+static irqreturn_t comcerto_pci_apbb_irq(int irq, void *dev_id)
+{
+	u32 status;
+
+	status = __raw_readl(COMCERTO_APBB_INT_STATUS);
+	if (!(status & 0x1b))
+		goto err;
+
+	if (status & 0x1)
+		printk(KERN_ERR "Comcerto PCI APBB: Target Abort error\n");
+
+	if (status & 0x2)
+		printk(KERN_ERR "Comcerto PCI APBB: Master Abort error\n");
+
+	if (status & 0x8)
+		printk(KERN_ERR "Comcerto PCI APBB: Parity error\n");
+
+	if (status & 0x10)
+		printk(KERN_ERR "Comcerto PCI APBB: Retry error\n");
+
+	__raw_writel(0x1b, COMCERTO_APBB_INT_STATUS);
+
+	return IRQ_HANDLED;
+
+err:
+	return IRQ_NONE;
+}
+#endif /* defined(CONFIG_COMCERTO_PCI_USE_APBB) */
+
+static irqreturn_t comcerto_pci_hmb_irq(int irq, void *dev_id)
+{
+	u32 status;
+
+	status = __raw_readl(COMCERTO_HMB_STATUS);
+	if (!(status & 0x3))
+		goto err;
+
+	if (status & 0x1)
+		printk(KERN_ERR "Comcerto PCI: HMB Retry/Disconnect error\n");
+
+	if (status & 0x2)
+		printk(KERN_ERR "Comcerto PCI: HMB PCI System error\n");
+
+	printk(KERN_INFO "Comcerto PCI: HMB error count %#x\n", status >> 16);
+
+	__raw_writel(0x3, COMCERTO_HMB_INTACK);
+
+	return IRQ_HANDLED;
+
+err:
+	return IRQ_NONE;
+}
+
+#endif /* defined(CONFIG_COMCERTO_PCI_DEBUG) */
+
+
+void __init comcerto_preinit(void)
+{
+	u32 ctl, val;
+
+	/* setup PCI clk */
+	ctl = __raw_readl(COMCERTO_CLK_CLKDIV_CNTRL);
+	ctl &= ~(0x1F << PCI_CLKDIV_RATIO_SHIFT);
+	ctl |= (((COMCERTO_AHBCLK+32) / 33) << PCI_CLKDIV_RATIO_SHIFT);
+	__raw_writel(ctl, COMCERTO_CLK_CLKDIV_CNTRL);
+	__raw_writel(ctl & ~PCI_CLKDIV_BYPASS, COMCERTO_CLK_CLKDIV_CNTRL);
+
+	/* De-activate PCI reset */
+	__raw_writel(__raw_readl(COMCERTO_BLOCK_RESET_REG) | PCI_RST | \
+				HIF_RST , COMCERTO_BLOCK_RESET_REG);
+
+	/* HMDMA setup */
+	__raw_writel(0x04, COMCERTO_HMDMA_LOCKED_TRANSFER_SIZE);
+
+	/* config Host Memory Bridge (hmb) Parameters */
+	__raw_writel(COMCERTO_PCIDMA_SYS_BASE_ADDR1, \
+				COMCERTO_HMB_SYS_BASE_ADDR1);
+	__raw_writel(COMCERTO_PCIDMA_SIZE_MASK1, COMCERTO_HMB_SIZE_MASK1);
+
+	__raw_writel(COMCERTO_PCIDMA_SYS_BASE_ADDR2, \
+				COMCERTO_HMB_SYS_BASE_ADDR2);
+	__raw_writel(COMCERTO_PCIDMA_SIZE_MASK2, COMCERTO_HMB_SIZE_MASK2);
+
+	/* only 2 ports are allowed to request for PCI bus arbitration
+	   pci device to be bus master */
+	ctl = __raw_readl(COMCERTO_HMB_PCI_ARBITER_CONTROL);
+	/* priority scheme = round robin,
+	 * ports 1 & 2 enabled, aging period = 255 */
+	__raw_writel(0xff06, COMCERTO_HMB_PCI_ARBITER_CONTROL);
+	ctl = __raw_readl(COMCERTO_HMB_PCI_ARBITER_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: HMB pci arbiter control: %#x\n", ctl);
+
+	/* read prefetch size = 8 words, programio = HMDMA,
+	 * timeout = no timeout, timeout cycles = 5 cycles */
+	__raw_writel(0x59, COMCERTO_HMB_MODE_CONTROL);
+	ctl = __raw_readl(COMCERTO_HMB_MODE_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: HMB mode control: %#x\n", ctl);
+
+#if defined(CONFIG_COMCERTO_PCI_SINGLE_ACCESS_TYPE)
+	__raw_writel(APBB_CTRL_MEMIO | APBB_CTRL_LATTMR | APBB_CTRL_REQLAST, \
+							COMCERTO_APBB_CONTROL);
+#else
+	__raw_writel(APBB_CTRL_LATTMR | APBB_CTRL_REQLAST, \
+							COMCERTO_APBB_CONTROL);
+#endif
+
+	/* clear all error bits */
+	__raw_writel(BME_RXTRGABRTIAK | BME_MSTRABRTIAK | BME_SYSERRORIAK | \
+				BME_PARERRORIAK | BME_RETRYIAK, \
+				COMCERTO_PHI_PCI_IF_STATUS);
+
+	/* Configure Host bus device */
+	if (__comcerto_host_read_config(PCI_VENDOR_ID, 4, &val)) {
+		printk(KERN_ERR \
+			"Comcerto PCI: 1- PCI Host device not detected\n");
+	} else if (val != PCI_DEV_VENDOR_ID) {
+		printk(KERN_ERR \
+		"Comcerto PCI: PCI Host device detected with val %d \n", \
+									val);
+		return;
+	}
+
+	__comcerto_pci_host_init();
+
+	/* enable hmb operation */
+	ctl = __raw_readl(COMCERTO_HMB_STATE_CONTROL);
+	/* HMB Mode = enable */
+	__raw_writel(ctl | 0x01, COMCERTO_HMB_STATE_CONTROL);
+	ctl = __raw_readl(COMCERTO_HMB_STATE_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: HMB state control: %#x\n", ctl);
+
+	ctl = __raw_readl(COMCERTO_APBB_CONTROL);
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	/* APBB Mode = enable */
+	__raw_writel(ctl | APBB_CTRL_EN, COMCERTO_APBB_CONTROL);
+#else
+	/* APBB Mode = disable */
+	__raw_writel(ctl & ~APBB_CTRL_EN, COMCERTO_APBB_CONTROL);
+#endif
+	ctl = __raw_readl(COMCERTO_APBB_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: APBB control: %#x\n", ctl);
+
+#if defined(CONFIG_COMCERTO_PCI_DEBUG)
+	if (request_irq(IRQ_HIF, comcerto_pci_hmb_irq, IRQF_DISABLED,
+						"Comcerto PCI HMB", NULL))
+		/* disable all interrupts */
+		__raw_writel(0x0, COMCERTO_HMB_INT_CONTROL);
+	else
+		/* enable all interrupts */
+		__raw_writel(0x3, COMCERTO_HMB_INT_CONTROL);
+
+#if defined(CONFIG_COMCERTO_PCI_USE_APBB)
+	if (request_irq(IRQ_APBB, comcerto_pci_apbb_irq, IRQF_DISABLED,
+						"Comcerto PCI APBB", NULL))
+		/* disable all interrupts */
+		__raw_writel(0x00, COMCERTO_APBB_INT_CONTROL);
+	else
+		/* enable all interrupts */
+		__raw_writel(0x1b, COMCERTO_APBB_INT_CONTROL);
+#endif
+
+#else
+	/* disable all interrupts */
+	__raw_writel(0x0, COMCERTO_HMB_INT_CONTROL);
+	/* disable all interrupts */
+	__raw_writel(0x00, COMCERTO_APBB_INT_CONTROL);
+#endif
+
+	ctl = __raw_readl(COMCERTO_HMB_INT_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: HMB interrupt control: %#x\n", ctl);
+
+	ctl = __raw_readl(COMCERTO_APBB_INT_CONTROL);
+	printk(KERN_DEBUG "Comcerto PCI: APBB interrupt control: %#x\n", ctl);
+}
+
+void __init comcerto_postinit(void)
+{
+
+}
diff --git a/arch/arm/mach-comcerto/pci-common.c b/arch/arm/mach-comcerto/pci-common.c
new file mode 100644
index 0000000..36030ea
--- /dev/null
+++ b/arch/arm/mach-comcerto/pci-common.c
@@ -0,0 +1,560 @@
+/*
+ *  linux/arch/arm/mach-comcerto/pci-common.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <asm/mach/pci.h>
+
+spinlock_t comcerto_pci_lock;
+
+void __comcerto_pci_host_init(void);
+extern void __init comcerto_preinit(void);
+extern void __init comcerto_postinit(void);
+
+/*
+ *  If we set up a device for bus mastering, we need to check the latency
+ *  timer as certain crappy BIOSes forget to set it properly.
+ */
+unsigned int pcibios_max_latency = 255;
+
+void pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+
+	lat = pcibios_max_latency;
+
+	printk(KERN_DEBUG "PCI: Setting latency timer of device %s to %d\n",
+			pci_name(dev), lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
+/**
+ * __comcerto_pci_reset -
+ *
+ */
+static void __comcerto_pci_reset(void)
+{
+	printk(KERN_INFO "Comcerto PCI: reset\n");
+
+	if (__raw_readl(COMCERTO_HMB_AX_FIFO_DEPTH))
+		printk(KERN_ERR "Comcerto PCI: fifo not empty\n");
+
+	__raw_writel(0x00, COMCERTO_PHI_PCI_IF_CONTROL);
+	__raw_writel(0x3000, COMCERTO_HMB_FIFO_CONTROL);
+
+	comcerto_gpio_ctrl(0x2 << 16, 0x3 << 16);
+
+	mdelay(10);
+
+	comcerto_gpio_ctrl(0x0 << 16, 0x3 << 16);
+
+	__comcerto_pci_host_init();
+
+	__raw_writel(0x0008, COMCERTO_HMB_FIFO_CONTROL);
+}
+
+/**
+ * comcerto_host_cfg_address -
+ *
+ */
+static inline u32 comcerto_host_cfg_address(int where)
+{
+	return (1 << 16) | where;
+}
+
+/**
+ * comcerto_cfg_address -
+ *
+ */
+static u32 comcerto_cfg_address(struct pci_bus *bus, int devfn, int where)
+{
+	u32 addr;
+
+	if (bus->number > 0)
+		addr = (bus->number << 16) | (PCI_SLOT(devfn) << 11);
+	else
+		/* we skip/hide the host slot which is at 0x10000 */
+		addr = 1 << (PCI_SLOT(devfn) + 16 + 1);
+
+	addr |= (PCI_FUNC(devfn) << 8) | where;
+
+	return addr;
+}
+
+/**
+ * __comcerto_pci_check -
+ *
+ */
+int __comcerto_pci_check(int rx)
+{
+	u32 ctrl, status;
+	u32 retry = 0;
+
+	while ((ctrl = __raw_readl(COMCERTO_PHI_PCI_IF_CONTROL)) & 0x02) {
+		status = __raw_readl(COMCERTO_PHI_PCI_IF_STATUS);
+
+		if (status & BME_RXTRGABRT) {
+			if (rx)
+				printk(KERN_ERR
+				"Comcerto PCI: Read Rx Target abort %#x %#x\n",
+								status, ctrl);
+			else
+				printk(KERN_ERR
+				"Comcerto PCI: Write Rx Target abort %#x %#x\n",
+								status, ctrl);
+			goto err;
+
+		} else if (status & BME_MSTRABRT) {
+			if (rx)
+				;
+			else
+				printk(KERN_ERR
+				"Comcerto PCI: Write Master abort %#x %#x\n",
+								status, ctrl);
+
+			goto err;
+
+		} else if (status & BME_SYSERROR) {
+			if (rx)
+				printk(KERN_ERR \
+				"Comcerto PCI: Read System error %#x %#x\n", \
+								status, ctrl);
+			else
+				printk(KERN_ERR \
+				"Comcerto PCI: Write System error %#x %#x\n", \
+								status, ctrl);
+
+			goto err;
+
+		} else if (status & BME_PARERROR) {
+			if (rx)
+				printk(KERN_ERR \
+				"Comcerto PCI: Read Parity error %#x %#x\n", \
+								status, ctrl);
+			else
+				printk(KERN_ERR \
+				"Comcerto PCI: Write Parity error %#x %#x\n", \
+								status, ctrl);
+
+			goto err;
+
+		} else if (status & BME_RETRY) {
+			__raw_writel(BME_RETRYIAK, COMCERTO_PHI_PCI_IF_STATUS);
+
+			if (retry++ > MAX_RETRIES) {
+				if (rx)
+					printk(KERN_ERR \
+					"Comcerto PCI: Excessive Read Retries \
+							%#x, %#x, %d\n", \
+							status, ctrl, retry);
+				else
+					printk(KERN_ERR \
+					"Comcerto PCI: Excessive Write Retries\
+							 %#x, %#x, %d\n", \
+							status, ctrl, retry);
+
+				goto err;
+			}
+		}
+	}
+
+	/* finish config cycle */
+	__raw_writel(0x38, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	return 0;
+
+err:
+	/* finish config cycle */
+	__raw_writel(0x38, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	/* clear all error bits */
+	__raw_writel(BME_RXTRGABRTIAK | BME_MSTRABRTIAK | BME_SYSERRORIAK | \
+		BME_PARERRORIAK | BME_RETRYIAK, COMCERTO_PHI_PCI_IF_STATUS);
+
+	/* reset fifo */
+	/* when reading from PCI target TX fifo is used */
+	/* when writing to PCI target RX fifo is used */
+	if (rx)
+		__raw_writel(TXFF_RES, COMCERTO_PHI_APB_FIFO_CONTROL);
+	else
+		__raw_writel(RXFF_RES, COMCERTO_PHI_APB_FIFO_CONTROL);
+
+	udelay(100);
+
+	if (status & BME_RXTRGABRT)
+		__comcerto_pci_reset();
+
+	return -1;
+}
+
+/**
+ * __comcerto_pci_read_config -
+ *
+ */
+int __comcerto_pci_read_config(u32 addr, int size, u8 space_type, u32 *value)
+{
+	int rc = 0;
+
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	__raw_writel(size, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_CONFIG_TYPE0)
+		__raw_writel(0x4001F, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0xC001F, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(1);
+	if (!rc) {
+		switch (size) {
+		case 1:
+			*value = __raw_readb(\
+					COMCERTO_PHI_APB_FIFO_DATA_U8);
+			break;
+		case 2:
+			*value = __raw_readw(\
+					COMCERTO_PHI_APB_FIFO_DATA_U16);
+			break;
+		case 4:
+			*value = __raw_readl(\
+					COMCERTO_PHI_APB_FIFO_DATA_U32);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+/**
+ * comcerto_pci_read_config -
+ *
+ */
+int comcerto_pci_read_config(u32 addr, int size, u8 space_type, u32 *value)
+{
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	rc = __comcerto_pci_read_config(addr, size, space_type, value);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return rc;
+}
+
+/**
+ * __comcerto_pci_write_config -
+ *
+ */
+int __comcerto_pci_write_config(u32 addr, int size, u32 value, u8 space_type)
+{
+	int rc = 0;
+
+	switch (size) {
+	case 1:
+		__raw_writeb(value, COMCERTO_PHI_APB_FIFO_DATA_U8);
+		break;
+
+	case 2:
+		__raw_writew(value, COMCERTO_PHI_APB_FIFO_DATA_U16);
+		break;
+
+	case 4:
+		__raw_writel(value, COMCERTO_PHI_APB_FIFO_DATA_U32);
+		break;
+	}
+
+	__raw_writel(FLUSH_RX, COMCERTO_PHI_APB_FIFO_INTACK);
+	__raw_writel(addr, COMCERTO_PHI_BME_DMA_START_ADDR);
+	__raw_writel(size, COMCERTO_PHI_BME_DMA_XFER_LEN);
+	__raw_writel(1, COMCERTO_PHI_BME_DMA_BURST_SIZE);
+
+	/* initiate PCI dma */
+	if (space_type == PCI_SPACE_TYPE_CONFIG_TYPE0)
+		__raw_writel(0x4001B, COMCERTO_PHI_PCI_IF_CONTROL);
+	else
+		__raw_writel(0xC001B, COMCERTO_PHI_PCI_IF_CONTROL);
+
+	rc = __comcerto_pci_check(0);
+
+	return rc;
+}
+
+/**
+ * comcerto_pci_write_config -
+ *
+ */
+int comcerto_pci_write_config(u32 addr, int size, u32 value, u8 space_type)
+{
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&comcerto_pci_lock, flags);
+
+	rc = __comcerto_pci_write_config(addr, size, value, space_type);
+
+	spin_unlock_irqrestore(&comcerto_pci_lock, flags);
+
+	return rc;
+}
+
+
+/**
+ * comcerto_read_config -
+ *
+ */
+int comcerto_read_config(struct pci_bus *bus, unsigned int devfn, int where, \
+							int size, u32 *value)
+{
+	u32 addr = comcerto_cfg_address(bus, devfn, where);
+	int rc;
+
+	BUG_ON(((where & 0x3) + size) > 4);
+
+	if (bus->number > 0)
+		rc = comcerto_pci_read_config(addr, size, \
+				PCI_SPACE_TYPE_CONFIG_TYPE1, value);
+	else
+		rc = comcerto_pci_read_config(addr, size, \
+				PCI_SPACE_TYPE_CONFIG_TYPE0, value);
+
+	if (rc)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * __comcerto_host_read_config -
+ *
+ */
+int __comcerto_host_read_config(int where, int size, u32 *value)
+{
+	u32 addr = comcerto_host_cfg_address(where);
+	int rc;
+
+	rc = __comcerto_pci_read_config(addr, size, \
+			PCI_SPACE_TYPE_CONFIG_TYPE0, value);
+
+	if (rc)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+/**
+ * comcerto_write_config -
+ *
+ */
+int comcerto_write_config(struct pci_bus *bus, unsigned int devfn, int where, \
+							int size, u32 value)
+{
+	u32 addr = comcerto_cfg_address(bus, devfn, where);
+	int rc;
+
+	BUG_ON(((where & 0x3) + size) > 4);
+
+	if (bus->number > 0)
+		rc = comcerto_pci_write_config(addr, size, value, \
+					PCI_SPACE_TYPE_CONFIG_TYPE1);
+	else
+		rc = comcerto_pci_write_config(addr, size, value, \
+					PCI_SPACE_TYPE_CONFIG_TYPE0);
+
+	if (rc)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * __comcerto_host_write_config -
+ *
+ */
+int __comcerto_host_write_config(int where, int size, u32 value)
+{
+	u32 addr = comcerto_host_cfg_address(where);
+	int rc;
+
+	rc = __comcerto_pci_write_config(addr, size, value, \
+				PCI_SPACE_TYPE_CONFIG_TYPE0);
+
+	if (rc)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops comcerto_ops = {
+	.read = comcerto_read_config,
+	.write = comcerto_write_config,
+};
+
+void __comcerto_pci_host_init(void)
+{
+	u32 val;
+
+	if (__comcerto_host_write_config(PCI_COMMAND, 2, \
+				PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY))
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_COMMAND write failed\n");
+	else if (__comcerto_host_read_config(PCI_COMMAND, 2, &val)) {
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_COMMAND read failed\n");
+	} else if (val != (PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY))
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_COMMAND write failed %#x\n", \
+									val);
+
+	if (__comcerto_host_write_config(PCI_BASE_ADDRESS_1, 4, \
+					COMCERTO_PCIDMA_PCI_BASE_ADDR1))
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_BASE_ADDRESS_1 write failed\n");
+	else if (__comcerto_host_read_config(PCI_BASE_ADDRESS_1, 4, &val)) {
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_BASE_ADDRESS_1 read failed\n");
+	} else if (val != COMCERTO_PCIDMA_PCI_BASE_ADDR1)
+		printk(KERN_ERR \
+		"Comcerto PCI: host PCI_BASE_ADDRESS_1 write failed %#x\n", \
+									val);
+
+	if (__comcerto_host_write_config(PCI_BASE_ADDRESS_2, 4, \
+					COMCERTO_PCIDMA_PCI_BASE_ADDR2))
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_BASE_ADDRESS_2 write failed\n");
+	else if (__comcerto_host_read_config(PCI_BASE_ADDRESS_2, 4, &val)) {
+		printk(KERN_ERR \
+			"Comcerto PCI: host PCI_BASE_ADDRESS_2 read_failed\n");
+	} else if (val != COMCERTO_PCIDMA_PCI_BASE_ADDR2)
+		printk(KERN_ERR \
+		"Comcerto PCI: host PCI_BASE_ADDRESS_2 write failed %#x\n", \
+									val);
+}
+
+static int __init comcerto_pci_resources(struct resource **resource)
+{
+	struct resource *res;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("Comcerto PCI: unable to alloc resources");
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	/* These are physical address space ranges, though they aren't mapped to
+	   anything at the hardware level, all PCI IO/MEM accesses are done
+	   indirectly */
+	res[0].start = COMCERTO_PCI_IO_BASE;
+	res[0].end   = COMCERTO_PCI_IO_BASE + COMCERTO_PCI_IO_SIZE;
+	res[0].name  = "Comcerto PCI I/O Space";
+	res[0].flags = IORESOURCE_IO;
+
+	res[1].start = COMCERTO_PCI_MEM_BASE;
+	res[1].end   = COMCERTO_PCI_MEM_BASE + COMCERTO_PCI_MEM_SIZE;
+	res[1].name  = "Comcerto PCI Memory Space";
+	res[1].flags = IORESOURCE_MEM;
+
+	request_resource(&ioport_resource, &res[0]);
+	request_resource(&iomem_resource, &res[1]);
+
+	resource[0] = &res[0];
+	resource[1] = &res[1];
+	resource[2] = NULL;
+
+	return 1;
+}
+
+static int __init comcerto_setup(int nr, struct pci_sys_data *sys)
+{
+	if (nr != 0)
+		return 0;
+
+	return comcerto_pci_resources(sys->resource);
+}
+
+static
+struct pci_bus *__init comcerto_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	if (nr != 0)
+		return NULL;
+
+	return pci_scan_bus(sys->busnr, &comcerto_ops, sys);
+}
+
+static int __init comcerto_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	if (!dev)
+		return -1;
+
+	if (dev->bus->number > 0) {
+		irq = dev->bus->self->irq;
+	} else {
+		/* Add 32 because GPIOs are in the 2nd controller */
+		irq = 32 + COMCERTO_PCI_GPIO_IRQ;
+	}
+
+	return irq;
+}
+
+static u8 __init comcerto_swizzle(struct pci_dev *dev, u8 *pin)
+{
+	return PCI_SLOT(dev->devfn);
+}
+
+static struct hw_pci comcerto_pci __initdata = {
+	.swizzle = comcerto_swizzle,
+	.map_irq = comcerto_map_irq,
+	.setup = comcerto_setup,
+	.nr_controllers = 1,
+	.scan = comcerto_scan_bus,
+	.preinit = comcerto_preinit,
+	.postinit = comcerto_postinit,
+};
+
+int __init comcerto_pci_init(void)
+{
+
+	printk(KERN_INFO "Comcerto PCI: init\n");
+	/* Enable PCI bus in host mode */
+	comcerto_gpio_ctrl(0xf << 10, 0xf << 10);
+	spin_lock_init(&comcerto_pci_lock);
+
+	pci_common_init(&comcerto_pci);
+
+	return 0;
+}
+
+subsys_initcall(comcerto_pci_init);
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 546d7e7..353204f 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -400,7 +400,7 @@ config CPU_FEROCEON_OLD_ID
 # ARMv6
 config CPU_V6
 	bool "Support ARM V6 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM7X00A || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM7X00A || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || ARCH_COMCERTO
 	default y if ARCH_MX3
 	default y if ARCH_MSM7X00A
 	select CPU_32v6
@@ -737,7 +737,7 @@ config CACHE_FEROCEON_L2
 
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller"
-	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
+	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || ARCH_COMCERTO
 	default y
 	select OUTER_CACHE
 	help
diff --git a/arch/arm/mm/cache-v6.S b/arch/arm/mm/cache-v6.S
index 2c6c2a7..9d4cea0 100644
--- a/arch/arm/mm/cache-v6.S
+++ b/arch/arm/mm/cache-v6.S
@@ -160,6 +160,10 @@ ENTRY(v6_dma_inv_range)
 #else
 	mcrne	p15, 0, r1, c7, c15, 1		@ clean & invalidate unified line
 #endif
+#ifdef CONFIG_ARCH_COMCERTO
+	sub	r1, r1, #1
+	mcrr		p15, 0, r1, r0, c6
+#else
 1:
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D line
@@ -169,6 +173,7 @@ ENTRY(v6_dma_inv_range)
 	add	r0, r0, #D_CACHE_LINE_SIZE
 	cmp	r0, r1
 	blo	1b
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
@@ -179,6 +184,11 @@ ENTRY(v6_dma_inv_range)
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_clean_range)
+#ifdef CONFIG_ARCH_COMCERTO
+	sub	r1, r1, #1
+	mcrr		p15, 0, r1, r0, c12
+#else
+
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
 #ifdef HARVARD_CACHE
@@ -189,6 +199,7 @@ ENTRY(v6_dma_clean_range)
 	add	r0, r0, #D_CACHE_LINE_SIZE
 	cmp	r0, r1
 	blo	1b
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
@@ -199,6 +210,10 @@ ENTRY(v6_dma_clean_range)
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_flush_range)
+#ifdef CONFIG_ARCH_COMCERTO
+	sub	r1, r1, #1
+	mcrr		p15, 0, r1, r0, c14
+#else
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
 #ifdef HARVARD_CACHE
@@ -209,6 +224,7 @@ ENTRY(v6_dma_flush_range)
 	add	r0, r0, #D_CACHE_LINE_SIZE
 	cmp	r0, r1
 	blo	1b
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
-- 
1.6.0.90.g436ed

