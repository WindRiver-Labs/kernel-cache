From 1bcd6f98aa833c4d86614d6ff76c8118cc41db01 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 30 Oct 2008 20:59:21 +0800
Subject: [PATCH] spi_mspd support.

Add a new directory, SPI_MSPD, which is Mindspeed's SPI bus architecture

vsc7385 is a switch chip, it's on SPI bus.

Signed-off-by: Stanley Miao <stanley.miao@windriver.com>
---
 arch/arm/Kconfig                       |    2 +
 drivers/Makefile                       |    1 +
 drivers/spi_mspd/Kconfig               |   16 +
 drivers/spi_mspd/Makefile              |    7 +
 drivers/spi_mspd/busses/Kconfig        |    9 +
 drivers/spi_mspd/busses/Makefile       |    1 +
 drivers/spi_mspd/busses/comcerto_spi.c |  580 ++++++++++++++++++++++++++++++++
 drivers/spi_mspd/busses/comcerto_spi.h |   85 +++++
 drivers/spi_mspd/chips/Kconfig         |    8 +
 drivers/spi_mspd/chips/Makefile        |    3 +
 drivers/spi_mspd/chips/vsc7385-regs.h  |  226 +++++++++++++
 drivers/spi_mspd/chips/vsc7385.h       |   49 +++
 drivers/spi_mspd/chips/vsc7385_itf.c   |   55 +++
 drivers/spi_mspd/chips/vsc7385_main.c  |  496 +++++++++++++++++++++++++++
 drivers/spi_mspd/spi-core.c            |  433 ++++++++++++++++++++++++
 include/linux/spi_mspd/spi.h           |  130 +++++++
 16 files changed, 2101 insertions(+), 0 deletions(-)
 create mode 100644 drivers/spi_mspd/Kconfig
 create mode 100644 drivers/spi_mspd/Makefile
 create mode 100644 drivers/spi_mspd/busses/Kconfig
 create mode 100644 drivers/spi_mspd/busses/Makefile
 create mode 100644 drivers/spi_mspd/busses/comcerto_spi.c
 create mode 100644 drivers/spi_mspd/busses/comcerto_spi.h
 create mode 100644 drivers/spi_mspd/chips/Kconfig
 create mode 100644 drivers/spi_mspd/chips/Makefile
 create mode 100644 drivers/spi_mspd/chips/vsc7385-regs.h
 create mode 100644 drivers/spi_mspd/chips/vsc7385.h
 create mode 100644 drivers/spi_mspd/chips/vsc7385_itf.c
 create mode 100644 drivers/spi_mspd/chips/vsc7385_main.c
 create mode 100644 drivers/spi_mspd/spi-core.c
 create mode 100644 include/linux/spi_mspd/spi.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 1a843fc..1e93fae 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1216,6 +1216,8 @@ source "drivers/i2c/Kconfig"
 
 source "drivers/spi/Kconfig"
 
+source "drivers/spi_mspd/Kconfig"
+
 source "drivers/gpio/Kconfig"
 
 source "drivers/w1/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 39cfe40..958a5ee 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -54,6 +54,7 @@ obj-y				+= cdrom/
 obj-y				+= auxdisplay/
 obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
+obj-$(CONFIG_SPI_MSPD)		+= spi_mspd/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
 obj-$(CONFIG_SBUS)		+= sbus/
diff --git a/drivers/spi_mspd/Kconfig b/drivers/spi_mspd/Kconfig
new file mode 100644
index 0000000..8f01743
--- /dev/null
+++ b/drivers/spi_mspd/Kconfig
@@ -0,0 +1,16 @@
+#
+# Character device configuration
+#
+
+menu "Mindspeed SPI support"
+	depends on ARCH_M821XX
+config SPI_MSPD
+	tristate "Mindspeed SPI support"
+	help
+	  Mindspeed SPI (Serial Pheripheral Interface bus) core support
+
+source drivers/spi_mspd/busses/Kconfig
+source drivers/spi_mspd/chips/Kconfig
+
+endmenu
+
diff --git a/drivers/spi_mspd/Makefile b/drivers/spi_mspd/Makefile
new file mode 100644
index 0000000..dedcb81
--- /dev/null
+++ b/drivers/spi_mspd/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the spi core.
+#
+
+obj-$(CONFIG_SPI_MSPD) += spi-core.o
+obj-y		  += busses/ chips/
+
diff --git a/drivers/spi_mspd/busses/Kconfig b/drivers/spi_mspd/busses/Kconfig
new file mode 100644
index 0000000..aeea3be
--- /dev/null
+++ b/drivers/spi_mspd/busses/Kconfig
@@ -0,0 +1,9 @@
+
+menu "SPI Hardware Bus support"
+	depends on SPI_MSPD
+
+config COMCERTO_SPI
+	tristate "Comcerto"
+	depends on SPI_MSPD
+
+endmenu
diff --git a/drivers/spi_mspd/busses/Makefile b/drivers/spi_mspd/busses/Makefile
new file mode 100644
index 0000000..c183ca8
--- /dev/null
+++ b/drivers/spi_mspd/busses/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_COMCERTO_SPI)        += comcerto_spi.o
diff --git a/drivers/spi_mspd/busses/comcerto_spi.c b/drivers/spi_mspd/busses/comcerto_spi.c
new file mode 100644
index 0000000..fab2e49
--- /dev/null
+++ b/drivers/spi_mspd/busses/comcerto_spi.c
@@ -0,0 +1,580 @@
+/*
+ *  drivers/spi_mspd/busses/comcerto_spi.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <asm/sizes.h>
+#include <mach/irqs.h>
+
+#include <linux/platform_device.h>
+#include "comcerto_spi.h"
+
+/**
+ * do_write_read_transfer8 -
+ *
+ *
+ */
+static int do_write_read_transfer8(struct comcerto_spi *spi,
+		u8 *wbuf, unsigned int *wlen, u8 *rbuf, unsigned int *rlen)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int wtmp = *wlen, rtmp = *rlen;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	while (wtmp || rtmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > wtmp)
+			len_now = wtmp;
+
+		wtmp -= len_now;
+
+		/* warm-up write fifo to avoid underruns */
+		while (len_now--)
+			__raw_writew(cpu_to_le16((u16) *wbuf++), dr);
+
+
+		len_now = __raw_readl(rxflr);
+		if (len_now > rtmp)
+			len_now = rtmp;
+
+		rtmp -= len_now;
+
+		while (len_now--) {
+			*rbuf = (u8) (le16_to_cpu(__raw_readw(dr)) & 0xff);
+			rbuf++;
+		}
+	}
+
+	*rlen -= rtmp;
+	*wlen -= wtmp;
+
+	return rc;
+}
+
+/**
+ * do_write_read_transfer16 -
+ *
+ *
+ */
+static int do_write_read_transfer16(struct comcerto_spi *spi,
+		u16 *wbuf, unsigned int *wlen, u16 *rbuf, unsigned int *rlen)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int wtmp = *wlen, rtmp = *rlen;
+	unsigned int wpadding, rpadding;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	if (wtmp > rtmp) {
+		wpadding  = 0;
+		rpadding = wtmp - rtmp;
+	} else {
+		wpadding = rtmp - wtmp;
+		rpadding = 0;
+	}
+
+	while (wtmp || rtmp) {
+		len_now = 8 - __raw_readl(txflr);
+
+		if (wtmp) {
+			if (len_now > wtmp)
+				len_now = wtmp;
+
+			wtmp -= len_now;
+
+			while (len_now--)
+				__raw_writew(cpu_to_le16(*wbuf++), dr);
+
+		} else if (wpadding) {
+			if (len_now > wpadding)
+				len_now = wpadding;
+
+			wpadding -= len_now;
+
+			while (len_now--)
+				__raw_writew(0, dr);
+		}
+
+		len_now = __raw_readl(rxflr);
+		if (rtmp) {
+			if (len_now > rtmp)
+				len_now = rtmp;
+
+			rtmp -= len_now;
+
+			while (len_now--) {
+				*rbuf = le16_to_cpu(__raw_readw(dr));
+				rbuf++;
+			}
+		} else if (rpadding) {
+			if (len_now > rpadding)
+				len_now = rpadding;
+
+			rpadding -= len_now;
+
+			while (len_now--)
+				__raw_readw(dr);
+		}
+	}
+
+	*rlen -= rtmp;
+	*wlen -= wtmp;
+
+	return rc;
+}
+
+
+/**
+ * do_write_only_transfer8 -
+ *
+ *
+ */
+static int do_write_only_transfer8(struct comcerto_spi *spi, u8 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+
+	while (tmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--)
+			__raw_writew(cpu_to_le16((u16) *buf++), dr);
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+/**
+ * do_write_only_transfer -
+ *
+ *
+ */
+static int do_write_only_transfer16(struct comcerto_spi *spi, u16 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+
+	while (tmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--)
+			__raw_writew(cpu_to_le16(*buf++), dr);
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+
+/**
+ * do_read_only_transfer -
+ *
+ *
+ */
+static int do_read_only_transfer8(struct comcerto_spi *spi, u8 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	/* start the serial clock */
+	__raw_writew(0, dr);
+
+	while (tmp) {
+		len_now = __raw_readl(rxflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--) {
+			*buf = (u8) (le16_to_cpu(__raw_readw(dr)) & 0xff);
+			buf++;
+		}
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+/**
+ * do_read_only_transfer -
+ *
+ *
+ */
+static int do_read_only_transfer16(struct comcerto_spi *spi, u16 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	/* start the serial clock */
+	__raw_writew(0, dr);
+
+	while (tmp) {
+		len_now = __raw_readl(rxflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--) {
+			*buf = le16_to_cpu(__raw_readw(dr));
+			buf++;
+		}
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+
+/**
+ * comcerto_spi_do_transfer -
+ *
+ *
+ */
+int comcerto_spi_do_transfer(struct spi_adapter *adapter,
+		struct spi_transfer *transfer, struct spi_client_config *config)
+{
+	struct comcerto_spi *spi = (struct comcerto_spi *)adapter->data;
+	u32 ctrlr0, ctrlr1, baudr, ser;
+	int rc;
+
+	/* make sure last transaction is finished */
+	while (__raw_readl(spi->membase + COMCERTO_SPI_SR) & BUSY) ;
+
+	ctrlr0 = ((config->sc_polarity & 0x1) << 7) | \
+		 ((config->sc_phase & 0x1) << 6) | \
+		 (((transfer->fs - 1) & 0xf) << 0);
+
+	baudr = spi->clock_rate / config->sc_rate;
+
+	ser = config->cs_msk & adapter->caps.cs_msk;
+
+	__raw_writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	switch (transfer->mode & 0x0f) {
+		default:
+			rc = -1;
+			break;
+
+		case SPI_TRANSFER_MODE_WRITE_ONLY:
+			ctrlr0 |= (0x0001 << 8);
+
+			__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+			__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+			__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+			__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+			__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+			if (transfer->fs <= 8)
+				rc = do_write_only_transfer8(spi, transfer->wbuf, &transfer->wlen);
+			else
+				rc = do_write_only_transfer16(spi, (u16 *) transfer->wbuf, &transfer->wlen);
+
+			break;
+
+		case SPI_TRANSFER_MODE_READ_ONLY:
+			ctrlr0 |= (0x0002 << 8);
+			ctrlr1 = transfer->rlen - 1;
+
+			__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+			__raw_writel(ctrlr1, spi->membase + COMCERTO_SPI_CTRLR1);
+			__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+			__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+			__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+			__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+			if (transfer->fs <= 8)
+				rc = do_read_only_transfer8(spi, transfer->rbuf, &transfer->rlen);
+			else
+				rc = do_read_only_transfer16(spi, (u16 *) transfer->rbuf, &transfer->rlen);
+
+			break;
+
+		case SPI_TRANSFER_MODE_WRITE_READ:
+			ctrlr0 |= (0x0000 << 8);
+
+			__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+			__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+			__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+			__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+			__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+			__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+			if (transfer->fs <= 8)
+				rc = do_write_read_transfer8(spi, transfer->wbuf, &transfer->wlen, transfer->rbuf, &transfer->rlen);
+			else
+				rc = do_write_read_transfer16(spi, (u16 *) transfer->wbuf, &transfer->wlen, (u16 *) transfer->rbuf, &transfer->rlen);
+
+			break;
+	}
+
+	return rc;
+}
+
+/**
+ * comcerto_spi_hw_init -
+ *
+ *
+ */
+static void comcerto_spi_hw_init(struct comcerto_spi *spi)
+{
+	/* enable SPI bus */
+	comcerto_gpio_ctrl(0x3 << 4, 0x3 << 4);
+
+	/* disable SPI operation */
+	writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	/* mask all SPI irq's */
+	writel(0, spi->membase + COMCERTO_SPI_IMR);
+}
+
+/**
+ * comcerto_spi_hw_reset -
+ *
+ *
+ */
+static void comcerto_spi_hw_reset(struct comcerto_spi *spi)
+{
+	/* disable SPI operation */
+	writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	/* mask all SPI irq's */
+	writel(0, spi->membase + COMCERTO_SPI_IMR);
+
+	/* disable SPI bus */
+	comcerto_gpio_ctrl(0x0 << 4, 0x3 << 4);
+}
+
+struct spi_adapter comcerto_spi_adapter = {
+	.name = "comcerto-spi",
+	.do_transfer = comcerto_spi_do_transfer,
+};
+
+/**
+ * comcerto_spi_probe -
+ *
+ *
+ */
+static int __init comcerto_spi_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi;
+	unsigned long base, len;
+
+	spi = kmalloc(sizeof(struct comcerto_spi), GFP_KERNEL);
+	if (spi == NULL) {
+		printk(KERN_INFO "comcerto_spi: error allocating memory");
+		goto err0;
+	}
+
+	base = pdev->resource[0].start;
+	len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(base, len, COMCERTO_SPI_DRIVER_NAME)) {
+		printk(KERN_INFO "comcerto_spi: error requesting memory region %#lx - %#lx", base, base + len);
+		goto err1;
+	}
+
+	/* io-remaped in arch/arm/mm.c */
+	spi->membase = APB_VADDR(pdev->resource[0].start);
+	spi->irq = pdev->resource[1].start;
+
+	comcerto_spi_hw_init(spi);
+#if 0
+	if (request_irq(spi->irq, comcerto_spi_irq_handler, SA_SHIRQ, COMCERTO_SPI_DRIVER_NAME, spi)) {
+		printk(KERN_INFO "comcerto_spi: error requesting irq %d\n", IRQ_SPI);
+		goto err2;
+	}
+#endif
+	spi->adapter = &comcerto_spi_adapter;
+
+	comcerto_spi_adapter.dev.parent = &pdev->dev;
+	comcerto_spi_adapter.data = spi;
+	comcerto_spi_adapter.caps.max_sc_rate = (COMCERTO_AHBCLK * 1000000) / 2;
+	comcerto_spi_adapter.caps.min_sc_rate = (COMCERTO_AHBCLK * 1000000) / 0xffff;
+	comcerto_spi_adapter.caps.max_fs = 16;
+	comcerto_spi_adapter.caps.min_fs = 4;
+	comcerto_spi_adapter.caps.max_nframe = 0xffff;
+	comcerto_spi_adapter.caps.min_nframe = 1;
+	comcerto_spi_adapter.caps.cs_msk = 0xf;
+
+	if (spi_add_adapter(&comcerto_spi_adapter)) {
+		printk(KERN_INFO "comcerto_spi: error adding adapter\n");
+		goto err3;
+	}
+
+	spi->clock_rate = (COMCERTO_AHBCLK * 1000000);
+	dev_set_drvdata(&pdev->dev, spi);
+	return 0;
+
+err3:
+	release_mem_region(base, len);
+
+err1:
+	kfree(spi);
+
+err0:
+	return -1;
+}
+
+/**
+ * comcerto_spi_remove -
+ *
+ *
+ */
+static int comcerto_spi_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi = dev_get_drvdata(&pdev->dev);
+	unsigned long base, len;
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	spi_del_adapter(spi->adapter);
+
+	comcerto_spi_hw_reset(spi);
+
+	/* free_irq(spi->irq, spi); */
+
+	base = pdev->resource[0].start;
+	len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	release_mem_region(base, len);
+
+	kfree(spi);
+
+	return 0;
+}
+
+static struct resource comcerto_spi_resources[] = {
+	{
+		.start = COMCERTO_APB_SPI_BASE,
+		.end = COMCERTO_APB_SPI_BASE + SZ_4K,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_SPI,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct device_driver comcerto_spi_driver = {
+	.name = "comcerto-spi",
+	.bus = &platform_bus_type,
+	.probe = comcerto_spi_probe,
+	.remove = comcerto_spi_remove,
+};
+
+static void comcerto_spi_release(struct device *dev)
+{
+	/* Just to keep driver model happy */
+}
+
+static struct platform_device comcerto_spi_device = {
+	.name = "comcerto-spi",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(comcerto_spi_resources),
+	.resource = comcerto_spi_resources,
+	.dev = {
+		.release = comcerto_spi_release,
+	},
+};
+
+
+/**
+ * comcerto_spi_init -
+ *
+ *
+ */
+static int __init comcerto_spi_init(void)
+{
+	if (driver_register(&comcerto_spi_driver)) {
+		printk(KERN_INFO "comcerto_spi: error registering driver\n");
+		goto err0;
+	}
+
+	if (platform_device_register(&comcerto_spi_device)) {
+		printk(KERN_INFO "comcerto_spi: error registering device\n");
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	driver_unregister(&comcerto_spi_driver);
+
+err0:
+	return -1;
+}
+
+/**
+ * comcerto_spi_exit -
+ *
+ *
+ */
+static void __exit comcerto_spi_exit(void)
+{
+	platform_device_unregister(&comcerto_spi_device);
+	driver_unregister(&comcerto_spi_driver);
+}
+
+MODULE_AUTHOR("Mindspeed Technologies, Inc.");
+MODULE_DESCRIPTION("Comcerto SPI bus driver");
+MODULE_LICENSE("GPL");
+
+module_init(comcerto_spi_init);
+module_exit(comcerto_spi_exit);
diff --git a/drivers/spi_mspd/busses/comcerto_spi.h b/drivers/spi_mspd/busses/comcerto_spi.h
new file mode 100644
index 0000000..0daf639
--- /dev/null
+++ b/drivers/spi_mspd/busses/comcerto_spi.h
@@ -0,0 +1,85 @@
+/*
+ *  linux/drivers/spi_mspd/busses/comcerto_spi.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _COMCERTO_SPI_H
+#define _COMCERTO_SPI_H
+
+#include <linux/version.h>
+#include <linux/spi_mspd/spi.h>
+
+#define COMCERTO_SPI_DRIVER_NAME	"Comcerto SPI"
+
+
+#define COMCERTO_SPI_CTRLR0               0x00
+#define COMCERTO_SPI_CTRLR1               0x04
+#define COMCERTO_SPI_SSIENR               0x08
+#define COMCERTO_SPI_MWCR                 0x0C
+#define COMCERTO_SPI_SER                  0x10
+#define COMCERTO_SPI_BAUDR                0x14
+#define COMCERTO_SPI_TXFTLR               0x18
+#define COMCERTO_SPI_RXFTLR               0x1C
+#define COMCERTO_SPI_TXFLR                0x20
+#define COMCERTO_SPI_RXFLR                0x24
+#define COMCERTO_SPI_SR                   0x28
+#define COMCERTO_SPI_IMR                  0x2C
+#define COMCERTO_SPI_ISR                  0x30
+#define COMCERTO_SPI_RISR                 0x34
+#define COMCERTO_SPI_TXOICR               0x38
+#define COMCERTO_SPI_RXOICR               0x3C
+#define COMCERTO_SPI_RXUICR               0x40
+#define COMCERTO_SPI_MSTICR               0x44
+#define COMCERTO_SPI_ICR                  0x48
+#define COMCERTO_SPI_IDR                  0x58
+#define COMCERTO_SPI_DR                   0x60
+
+
+/* SR - status register bits */
+#define BUSY		(1<<0)	/* SSI busy flag, serial transfer in progress */
+#define TFNF		(1<<1)	/* Transmit FIFO not full */
+#define TFE		(1<<2)	/* Transmit FIFO empty */
+#define RFNE		(1<<3)	/* Receive FIFO not empty */
+#define RFF		(1<<4)	/* Receive FIFO full */
+#define TXE		(1<<5)	/* Transmission error */
+#define DCOL		(1<<6)	/* Data collision error */
+
+/* Interrupt status after being masked */
+#define TXEIS		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIS		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIS		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIS		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIS		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIS		(1<<5)	/* Multi-Master contention interrupt status */
+
+/* Interrupt status before being masked */
+#define TXEIR		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIR		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIR		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIR		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIR		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIR		(1<<5)	/* Multi-Master contention interrupt status */
+
+
+/* Interrupt mask register */
+#define TXEIM		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIM		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIM		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIM		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIM		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIM		(1<<5)	/* Multi-Master contention interrupt status */
+
+struct comcerto_spi {
+	struct spi_adapter *adapter;
+	unsigned long membase;
+	int irq;
+	unsigned long clock_rate;
+};
+
+
+#endif /* _COMCERTO_SPI_H */
diff --git a/drivers/spi_mspd/chips/Kconfig b/drivers/spi_mspd/chips/Kconfig
new file mode 100644
index 0000000..12cc0a2
--- /dev/null
+++ b/drivers/spi_mspd/chips/Kconfig
@@ -0,0 +1,8 @@
+
+menu "SPI devices support"
+	depends on SPI_MSPD
+
+config SPI_VSC7385
+	tristate "VSC7385"
+	depends on SPI_MSPD
+endmenu
diff --git a/drivers/spi_mspd/chips/Makefile b/drivers/spi_mspd/chips/Makefile
new file mode 100644
index 0000000..90dfbd4
--- /dev/null
+++ b/drivers/spi_mspd/chips/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SPI_VSC7385)        += vsc7385.o
+
+vsc7385-objs := vsc7385_main.o vsc7385_itf.o
diff --git a/drivers/spi_mspd/chips/vsc7385-regs.h b/drivers/spi_mspd/chips/vsc7385-regs.h
new file mode 100644
index 0000000..9928a2d
--- /dev/null
+++ b/drivers/spi_mspd/chips/vsc7385-regs.h
@@ -0,0 +1,226 @@
+/*
+ *  vsc7385-regs.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __VSC7385_REG_H__
+#define __VSC7385_REG_H__
+
+/*System Block Registers (Block 7)*/
+#define VSC7385_CPUMODE			0x00
+#define VSC7385_SIPAD			0x01
+#define VSC7385_PICONF			0x02
+#define VSC7385_GMIIDELAY		0x05
+#define VSC7385_HWSEM			0x13
+#define VSC7385_GLORESET		0x14
+#define VSC7385_CHIPID			0x18
+#define VSC7385_TIMECMP			0x24
+#define VSC7385_SLOWDATA		0x2C
+#define VSC7385_CPUCTRL			0x30
+#define VSC7385_CAPCTRL			0x31
+#define VSC7385_GPIO			0x34
+#define VSC7385_SIMASTER		0x35
+
+/*iCPU Block Registers  (Block 7)*/
+#define VSC7385_ICPU_CTRL			0x10
+#define VSC7385_ICPU_ADDR			0x11
+#define VSC7385_ICPU_DATA			0x12
+#define VSC7385_ICPU_MBOX_VAL		0x15
+#define VSC7385_ICPU_MBOX_SET		0x16
+#define VSC7385_ICPU_MBOX_CLR		0x17
+#define VSC7385_ICPU_RAM_CFG		0x19
+#define VSC7385_ICPU_ROM_CFG		0x1A
+#define VSC7385_ICPU_RAM_MAP		0x1B
+#define VSC7385_ICPU_ROM_MAP		0x1C
+
+/*PORTREG Block Registers (Block 1)*/
+#define VSC7385_REGMODE				0x01
+
+/*MAC Block Registers (Block 1)*/
+#define VSC7385_MAC_CFG				0x00
+#define VSC7385_MACHDXGAP			0x02
+#define VSC7385_FCCONF				0x04
+#define VSC7385_FCMACHI				0x08
+#define VSC7385_FCMACLO				0x0C
+#define VSC7385_MAXLEN				0x10
+#define VSC7385_ADVPORTM			0x19
+#define VSC7385_TXQ_SELECT_CFG		0x28
+#define VSC7385_TXUPDCFG			0x24
+
+/*Shared FIFO block registers (Block 1)*/
+#define VSC7385_CPUTXDAT				0xC0
+#define VSC7385_MISCFIFO				0xC4
+#define VSC7385_MISCSTAT				0xC8
+#define VSC7385_FREEPOOL				0xD8
+#define VSC7385_Q_FLOWC_WM				0xDE
+#define VSC7385_Q_MISC_CONF				0xDF
+#define VSC7385_Q_DROP_WM				0xE0
+
+
+/*Categorizer Block Registers (Block 1)*/
+#define VSC7385_CAT_DROP					0x6E
+#define VSC7385_CAT_PR_MISC_L2				0x6F
+#define VSC7385_CAT_PR_USR_PRIO				0x75
+#define VSC7385_CAT_PR_DSCP_QOS				0x60
+#define VSC7385_CAT_PR_DSCP_VAL_0_3			0x61
+#define VSC7385_CAT_PR_DSCP_VAL_4_6			0x62
+#define VSC7385_CAT_PR_MISC_L3				0x77
+#define VSC7385_CAT_VLAN_MISC				0x79
+#define VSC7385_CAT_PORT_VLAN				0x7A
+#define VSC7385_CAT_OTHER_CFG				0x7B
+#define VSC7385_CAT_GENERIC_PRIO_REMAP		0x7D
+
+/*Detailed Counters Block Registers (Block 1)*/
+#define VSC7385_C_RXOCT				0x50
+#define VSC7385_C_TXOCT				0x51
+#define VSC7385_C_RX0				0x52
+#define VSC7385_C_RX1				0x53
+#define VSC7385_C_RX2				0x54
+#define VSC7385_C_TX0				0x55
+#define VSC7385_C_TX1				0x56
+#define VSC7385_C_TX2				0x57
+#define VSC7385_CNT_CTRL_CFG		0x58
+
+/*MII Management Bus Block Registers (Block 3)*/
+#define VSC7385_MIIMSTAT				0x00
+#define VSC7385_MIIMCMD					0x01
+#define VSC7385_MIIMDATA				0x02
+#define VSC7385_MIIMPRES				0x03
+#define VSC7385_MIIMSCAN				0x04
+#define VSC7385_MIIMSRES				0x05
+
+/*Memory Initialization Block Registers (Block 3)*/
+#define VSC7385_MEMINIT				0x00
+#define VSC7385_MEMRES				0x01
+
+/*Frame Arbitrer Block Registers (Block 5)*/
+#define VSC7385_ARBEMPTY				0x0C
+#define VSC7385_ARBDISC					0x0E
+#define VSC7385_SBACKWDROP				0x12
+#define VSC7385_DBACKWDROP				0x13
+
+
+/*CPU_CAPT Block Registers (Block 4)*/
+#define VSC7385_RAME_DATA				0x00
+
+/*CPU_CAPT_CTRL Bock Registers (Block 4)*/
+#define VSC7385_CAPREADP				0x00
+#define VSC7385_CAPWRP					0x03
+
+/*CPU_CAPT_RST Block Registers (Block 4)*/
+#define VSC7385_CAPRST					0xFF
+
+/*Frame Analyzer Block Registers (Block 2)*/
+#define VSC7385_STORMLIMIT				0x02
+#define VSC7385_ADVLEARN				0x03
+#define VSC7385_IFLODMSK				0x04
+#define VSC7385_VLANMASK				0x05
+#define VSC7385_MACHDATA				0x06
+#define VSC7385_MACLDATA				0x07
+#define VSC7385_ANMOVED					0x08
+#define VSC7385_ANAGEFIL				0x09
+#define VSC7385_ANEVENTS				0x0A
+#define VSC7385_ANCNTMSK				0x0B
+#define VSC7385_ANCNTVAL				0x0C
+#define VSC7385_LEARNMASK				0x0D
+#define VSC7385_UFLODMSK				0x0E
+#define VSC7385_MFLODMSK				0x0F
+#define VSC7385_RECVMASK				0x10
+#define VSC7385_AGGRCTRL				0x20
+#define VSC7385_AGGRMSKS				0x30
+#define VSC7385_DSTMASKS				0x40
+#define VSC7385_SRCMASKS				0x80
+#define VSC7385_CAPENAB					0xA0
+#define VSC7385_MACACCESS				0xB0
+#define VSC7385_MACTINDX				0xC0
+#define VSC7385_VLANACCESS				0xD0
+#define VSC7385_VLANTIDX				0xE0
+#define VSC7385_AGENCTRL				0xF0
+
+/*Standard set block registers (PHY registers)*/
+#define VSC7385_PHY_CTRL					0x00
+#define VSC7385_PHY_STAT					0x01
+#define VSC7385_PHY_IDF1					0x02
+#define VSC7385_PHY_IDF2					0x03
+#define VSC7385_PHY_AUTONEG_ADVERTISMENT	0x04
+#define VSC7385_PHY_AUTONEG_LP_ABILITY		0x05
+#define VSC7385_PHY_AUTONEG_EXP				0x06
+#define VSC7385_PHY_AUTONEG_NEXTPAGE_TX		0x07
+#define VSC7385_PHY_AUTONEG_NEXTPAGE_RX		0x08
+#define VSC7385_PHY_CTRL_1000BT				0x09
+#define VSC7385_PHY_STAT_1000BT				0x0A
+#define VSC7385_PHY_STAT_EXT				0x0F
+#define VSC7385_PHY_STAT_100BTX				0x10
+#define VSC7385_PHY_STAT_1000BT_EXT			0x11
+#define VSC7385_PHY_BYPASS_CTRL				0x12
+#define VSC7385_PHY_CTRL_STAT_EXT			0x16
+#define VSC7385_PHY_CTRL_EXT1				0x17
+#define VSC7385_PHY_CTRL_EXT2				0x18
+#define VSC7385_PHY_LED_CTRL				0x1B
+#define VSC7385_PHY_AUX_CTRL_STAT			0x1C
+#define VSC7385_DELAY_SKEW_STAT				0x1D
+#define VSC7385_PHY_LED_BEHAVIOR_CTRL		0x1E
+#define VSC7385_PHY_MEMORY_PAGE_ACCESS		0x1F
+
+/*Extended Set Block Registers (PHY registers)*/
+#define VSC7385_PHY_CTRL_EXT3				0x14
+#define VSC7385_PHY_CTRL_EXT4				0x17
+#define VSC7385_PHY_VERIPHY_CTRL			0x18
+#define VSC7385_PHY_1000BT_EPG1				0x1D
+#define VSC7385_PHY_1000BT_EPG2				0x1E
+
+/*General Purpose I/O SFR Registers*/
+#define VSC7385_GPIO_IN					0x80
+#define VSC7385_GPIO_OUT				0x90
+#define VSC7385_GPIO_OE					0xA0
+#define VSC7385_GPIO_STAT				0xA1
+
+/*Dual data pointer SFR Registers*/
+#define VSC7385_DPL1				0x84
+#define VSC7385_DPH1				0x85
+#define VSC7385_DPS					0x86
+
+/*Memory Access Control SFR Registers*/
+#define VSC7385_SPC_FNC				0x8F
+#define VSC7385_PG					0xB0
+#define VSC7385_SPC_FNC2			0xF1
+
+/*Frame present SFR Registers*/
+#define VSC7385_FPIE				0xA9
+#define VSC7385_FPSTAT				0xAA
+
+/*Watchdog SFR registers*/
+#define VSC7385_WDDA				0xA2
+#define VSC7385_WDCON				0xA3
+
+
+/*Additionnal Timer-Related SFR Registers*/
+#define VSC7385_CKCON				0x8E
+#define VSC7385_IE					0xA8
+#define VSC7385_IP					0xB8
+#define VSC7385_T2CON				0xC8
+#define VSC7385_RCAP2L				0xCA
+#define VSC7385_RCAP2H				0xCB
+#define VSC7385_TL2					0xCC
+#define VSC7385_TH2					0xCD
+
+/*Chip register Access SFR registers*/
+#define VSC7385_RA_DONE					0xF8
+#define VSC7385_RA_BLK					0xF9
+#define VSC7385_RA_AD_RD				0xFA
+#define VSC7385_RA_AD_WR				0xFB
+#define VSC7385_RA_DA0					0xFC
+#define VSC7385_RA_DA1					0xFD
+#define VSC7385_RA_DA2					0xFE
+#define VSC7385_RA_DA3					0xFF
+
+/*Other SFR registers*/
+#define VSC7385_PSW						0xD0
+
+#endif
+
diff --git a/drivers/spi_mspd/chips/vsc7385.h b/drivers/spi_mspd/chips/vsc7385.h
new file mode 100644
index 0000000..8e03eb7
--- /dev/null
+++ b/drivers/spi_mspd/chips/vsc7385.h
@@ -0,0 +1,49 @@
+/*
+ *  vsc7385.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __VSC7385_H__
+#define __VSC7385_H__
+
+#include <linux/version.h>
+#include <asm/system.h>
+#include <linux/timer.h>
+#include <linux/spi_mspd/spi.h>
+#include <linux/workqueue.h>
+
+
+#define VSC7385_DRIVER_NAME "vsc7385"
+#define VSC7385_PHY_POLL_GAP 1  	/* Polling PHYs gap in seconds */
+
+#ifdef VSC7385_DEBUG
+#define VSC7385_debug(str, args...) printk(KERN_INFO str, ## args)
+#else
+#define VSC7385_debug(str, args...)
+#endif
+#define VSC7385_info(str, args...) printk(KERN_INFO str, ## args)
+#define VSC7385_err(str, args...) printk(KERN_ERR str, ## args)
+
+struct vsc7385_phy_state {
+	enum { LINK_DOWN = 0, LINK_UP} link_state;
+	enum { LINK_10MB, LINK_100MB, LINK_1000MB} link_speed;
+	enum { LINK_HALF_DUPLEX, LINK_FULL_DUPLEX} link_duplex;
+};
+
+struct vsc7385_data {
+	struct spi_client client;
+	struct vsc7385_phy_state phy_state[5];
+	struct delayed_work watchdog_task;
+};
+
+u32 vsc7385_read(struct spi_client *client, u8 BlockID, u8 Subblocks, u8 addr);
+int vsc7385_write(struct spi_client *client, u8 BlockID, u8 Subblocks,
+						u8 addr, u32 data);
+
+#endif
+
diff --git a/drivers/spi_mspd/chips/vsc7385_itf.c b/drivers/spi_mspd/chips/vsc7385_itf.c
new file mode 100644
index 0000000..27d911b
--- /dev/null
+++ b/drivers/spi_mspd/chips/vsc7385_itf.c
@@ -0,0 +1,55 @@
+/*
+ *  vsc7385_itf.c
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include "vsc7385.h"
+
+#define VSC8375_BLOCKID(a, b) do {(ulong)a &= ~0xE0; (ulong)a |= (b&7)<<5; } while (0);
+#define VSC8375_SUBBLOCKID(a, b) do {(ulong)a &= ~0x0F; (ulong)a |= b&0xF; } while (0);
+#define VSC8375_ADDR(a, b) do {(ulong)a &= ~0xFF00; (ulong)a |= (b&0xFF)<<8; } while (0);
+#define VSC8375_WRITE(a) do{ a |= 0x10} while (0);
+#define VSC8375_READ(a) do{ a &= ~0x10} while (0);
+
+u32 vsc7385_read(struct spi_client *client, u8 BlockID, u8 Subblocks, u8 addr)
+{
+	u8 wdata[7];
+	u8 rdata[7];
+	u32 ret;
+
+	wdata[0] = (BlockID << 5) | (Subblocks & 0x0f);
+	wdata[1] = addr;
+	wdata[2] = 0x0;
+	wdata[3] = 0x0;
+	wdata[4] = 0x0;
+	wdata[5] = 0x0;
+	wdata[6] = 0x0;
+	spi_writeread_mem(client, 8, rdata, 7, wdata, 7);
+
+	memcpy(&ret, &(rdata[3]), 4);
+
+	return be32_to_cpu(ret);
+}
+
+int vsc7385_write(struct spi_client *client, u8 BlockID, u8 Subblocks, u8 addr, u32 data)
+{
+	u8 wdata[6];
+
+	wdata[0] = (BlockID << 5) | 0x10 | (Subblocks & 0x0f);
+	wdata[1] = addr;
+
+	wdata[5] = data & 0xff;
+	wdata[4] = (data >> 8) & 0xff;
+	wdata[3] = (data >> 16) & 0xff;
+	wdata[2] = (data >> 24) & 0xff;
+
+	spi_write_mem(client, 8, wdata, 6);
+	return 0;
+}
+
diff --git a/drivers/spi_mspd/chips/vsc7385_main.c b/drivers/spi_mspd/chips/vsc7385_main.c
new file mode 100644
index 0000000..2a24b8b
--- /dev/null
+++ b/drivers/spi_mspd/chips/vsc7385_main.c
@@ -0,0 +1,496 @@
+/*
+ *  vsc7385_main.c
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <mach/hardware.h>
+#include <linux/workqueue.h>
+
+#define VSC7385_COUNTERS 1
+#if 	!defined(VSC7385_COUNTERS)
+#define VSC7385_COUNTERS 0
+#endif
+#if defined(VSC7385_COUNTERS) && (VSC7385_COUNTERS)
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>        /* O_ACCMODE */
+#include <linux/seq_file.h>
+#endif
+
+#include "vsc7385.h"
+#include "vsc7385-regs.h"
+
+static struct vsc7385_data *vsc7385;
+
+/*
+ * mcast_ports - mask controlling propagation of multicast
+ * allowing all ports by default to make code more friendly
+ * to users-without-compiler
+ * Making it external parameter - setting it to 0 would save
+ * resources in a switch if multicast is present, but
+ * unwanted.
+ */
+static unsigned int mcast_ports = 0x5f;
+
+static int vsc7385_phy_read(struct spi_client *client, int phy_addr, int reg);
+static void vsc7385_phy_write(struct spi_client *client, int phy_addr, int reg, short value);
+
+/********************************************
+ * vsc7385_watchdog_task:
+ *
+ * This functionis called as a kernel thread
+ * It polls status of the PHYs
+ * and configure switch MAC blocks to match
+ *
+ ********************************************/
+	static void
+vsc7385_watchdog_task(struct work_struct *work)
+{
+	int i, phy_ctrl, phy_stat;
+	struct spi_client *client = (struct spi_client *)container_of(work, struct vsc7385_data, watchdog_task.work);
+	VSC7385_debug("vsc7385_watchdog_task\n");
+
+	/*The 7385 switch has 5 PHYs*/
+	for (i = 0 ; i < 5 ; i++) {
+		/*Read state of the PHY*/
+		phy_ctrl = vsc7385_phy_read(client, i, VSC7385_PHY_AUX_CTRL_STAT);
+		phy_stat = vsc7385_phy_read(client, i, VSC7385_PHY_STAT);
+
+		/*Check link state*/
+		if ((phy_stat & 0x4) && (vsc7385->phy_state[i].link_state == LINK_DOWN)) {
+			/*Link was down and is now up*/
+			vsc7385->phy_state[i].link_state = LINK_UP;
+
+			/*Enable port forwarding on associated MAC block*/
+			vsc7385_write(client, 2, 0, VSC7385_RECVMASK, vsc7385_read(client, 2, 0, VSC7385_RECVMASK) | (1 << i));
+
+			/*Set MAC_CFG register*/
+			switch (phy_ctrl & 0x0038) {
+				case 0x0000:/*10MB Half Duplex*/
+					VSC7385_info("Switch port %d is up in 10MB Half Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0xB0010474);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x90010444);
+					vsc7385->phy_state[i].link_speed = LINK_10MB;
+					vsc7385->phy_state[i].link_duplex = LINK_HALF_DUPLEX;
+					break;
+
+				case 0x0008:/*100MB Half Duplex*/
+					VSC7385_info("Switch port %d is up in 100MB Half Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0xB0010474);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x90010444);
+					vsc7385->phy_state[i].link_speed = LINK_100MB;
+					vsc7385->phy_state[i].link_duplex = LINK_HALF_DUPLEX;
+					break;
+
+				case 0x0010:/*1GB Half Duplex*/
+					VSC7385_info("Switch port %d is up in 1GB Half Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x300301B4);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x10030184);
+					vsc7385->phy_state[i].link_speed = LINK_1000MB;
+					vsc7385->phy_state[i].link_duplex = LINK_HALF_DUPLEX;
+					break;
+
+				case 0x0020:/*10MB Full Duplex*/
+					VSC7385_info("Switch port %d is up in 10MB Full Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x30050474);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x10050444);
+					vsc7385->phy_state[i].link_speed = LINK_10MB;
+					vsc7385->phy_state[i].link_duplex = LINK_FULL_DUPLEX;
+					break;
+
+				case 0x0028:/*100MB Full Duplex*/
+					VSC7385_info("Switch port %d is up in 100MB Full Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x30050474);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x10050444);
+					vsc7385->phy_state[i].link_speed = LINK_100MB;
+					vsc7385->phy_state[i].link_duplex = LINK_FULL_DUPLEX;
+					break;
+
+				case 0x0030:/*1GB Full*/
+					VSC7385_info("Switch port %d is up in 1GB Full Duplex\n", i);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x300701B4);
+					vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x10070184);
+					vsc7385->phy_state[i].link_speed = LINK_1000MB;
+					vsc7385->phy_state[i].link_duplex = LINK_FULL_DUPLEX;
+					break;
+
+				default: /*Should never enter in that case*/
+					VSC7385_err("Switch port %d is in a state that should never happen\n", i);
+					break;
+			}
+		} else if (((phy_stat & 0x4) == 0) && (vsc7385->phy_state[i].link_state == LINK_UP)) {
+			/*Link was up and is now down*/
+			vsc7385->phy_state[i].link_state = LINK_DOWN;
+
+			VSC7385_info("Switch port %d is down\n", i);
+
+			/*Disable port forwarding on associated MAC block*/
+			vsc7385_write(client, 2, 0, VSC7385_RECVMASK, vsc7385_read(client, 2, 0, VSC7385_RECVMASK) & ~(1 << i));
+
+			/*Set MAC_CFG register*/
+			vsc7385_write(client, 1, i, VSC7385_MAC_CFG, 0x20000030);
+		}
+	}
+
+	/* Re-schedule work */
+	schedule_delayed_work(&vsc7385->watchdog_task, VSC7385_PHY_POLL_GAP * HZ);
+}
+
+/********************************************
+ * vsc7385_phy_read:
+ *
+ * Send a read MII command to a PHY
+ *
+ ********************************************/
+static int vsc7385_phy_read(struct spi_client *client, int phy_addr, int reg)
+{
+	VSC7385_debug("vsc7385_phy_read\n");
+
+	/*Check that MII Management bus is not busy*/
+	while (vsc7385_read(client, 3, 0, VSC7385_MIIMSTAT) != 0)
+		if (need_resched())
+			schedule();
+
+	/*Write the command to send to the PHY*/
+	vsc7385_write(client, 3, 0, VSC7385_MIIMCMD, (1 << 26) | (phy_addr << 21) | (reg << 16));
+
+	/*Wait for command to be performed*/
+	while (vsc7385_read(client, 3, 0, VSC7385_MIIMSTAT) != 0)
+		if (need_resched())
+			schedule();
+
+	/*Read result and return it*/
+	return vsc7385_read(client, 3, 0, VSC7385_MIIMDATA);
+}
+
+/********************************************
+ * vsc7385_phy_write:
+ *
+ * Send a write MII command to a PHY
+ *
+ ********************************************/
+static void vsc7385_phy_write(struct spi_client *client, int phy_addr, int reg, short value)
+{
+	VSC7385_debug("vsc7385_phy_write\n");
+
+	/*Check that MII Management bus is not busy*/
+	while (vsc7385_read(client, 3, 0, VSC7385_MIIMSTAT) != 0)
+		if (need_resched())
+			schedule();
+
+	/*Write the command to send to the PHY*/
+	vsc7385_write(client, 3, 0, VSC7385_MIIMCMD, (phy_addr << 21) | (reg << 16) | value);
+}
+
+
+/********************************************
+ * vsc7385_device_init:
+ *
+ * Do the minimal initialization
+ * to have VSC7385 switch working
+ *
+ ********************************************/
+static int vsc7385_device_init(struct spi_client *client)
+{
+	unsigned int memId, result;
+
+	/*SPI bus timing on switch*/
+	vsc7385_write(client, 7, 0, VSC7385_SIPAD, 0x1);
+
+	/*
+	 * Initialization as advised in datasheet
+	 */
+
+	/*Initialize memories*/
+	for (memId = 0 ; memId < 14 ; memId++)
+		if ((memId != 6) && (memId != 7)) {
+			vsc7385_write(client, 3, 2, VSC7385_MEMINIT, 0x1010400 + memId);
+			mdelay(1);
+		}
+
+	/*Wait 30 ms as defined in the datasheet*/
+	mdelay(30);
+
+	for (memId = 0; memId < 14 ; memId++)
+		if ((memId != 6) && (memId != 7)) {
+			vsc7385_write(client, 3, 2, VSC7385_MEMINIT, 0x20000 + memId);
+			mdelay(1);
+
+			result = vsc7385_read(client, 3, 2, VSC7385_MEMRES);
+			if ((result & 0x3) != 0x3) {
+				VSC7385_err("Error: Switch memory initialization failed: memId: %d, memRes: %x\n", memId, result);
+				goto end;
+			}
+		}
+
+	/* Format memories */
+	vsc7385_write(client, 2, 0, VSC7385_MACACCESS, 5);
+	vsc7385_write(client, 2, 0, VSC7385_VLANACCESS, 3);
+	mdelay(40);
+
+	/*Release reset of PHYs*/
+	vsc7385_write(client, 7, 0, VSC7385_GLORESET, 2);
+
+	/*
+	 * Apply Mindspeed specific settings
+	 */
+
+	/* GMII Clock delay set to 1.7ns both Tx and Rx clock */
+	vsc7385_write(client, 7, 0, VSC7385_GMIIDELAY, 0x22);
+
+	/* Enable interface to RGMII mode (Double Data Rate) */
+	vsc7385_write(client, 1, 6, VSC7385_MAC_CFG, 0x300701B1);
+	vsc7385_write(client, 1, 6, VSC7385_MAC_CFG, 0x10070181);
+	vsc7385_write(client, 1, 6, VSC7385_ADVPORTM, 0x2C);
+
+	/* Accept packets coming from all PHYs*/
+	vsc7385_write(client, 2, 0, VSC7385_RECVMASK, 0x5F);
+	/* Enable multicast propagation on selected ports */
+	vsc7385_write(client, 2, 0, VSC7385_IFLODMSK,
+			((vsc7385_read(client, 2, 0, VSC7385_IFLODMSK) & \
+			  	(~0x5F)) | (mcast_ports & 0x5F)));
+	return 0;
+end:
+	return -1;
+}
+
+#if defined(VSC7385_COUNTERS) && (VSC7385_COUNTERS)
+
+static struct spi_client *vsc7385_proc_client;
+
+
+static void *vsc7385_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/* position is port number*/
+	if (*pos > 0) {
+		*pos = 0;
+		return NULL;
+	}
+	return (void *)vsc7385_proc_client;
+}
+
+static void *vsc7385_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos) += 5;
+	if (*pos >= 5)
+		return NULL;
+	return (void *)vsc7385_proc_client;
+}
+
+static void vsc7385_seq_stop(struct seq_file *s, void *v)
+{
+	/* Actually, there's nothing to do here */
+}
+
+static int vsc7385_seq_show(struct seq_file *s, void *v)
+{
+	int i;
+	for (i = 0; i < 5; i++) {
+		if (vsc7385->phy_state[i].link_state == LINK_UP) {
+			seq_printf(s, "Port %d RxO:0x%x TxO:0x%x rx(0x%x:0x%x:0x%x) tx(0x%x:0x%x:0x%x)\n", i,
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RXOCT),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TXOCT),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX0),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX1),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX2),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX0),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX1),
+					vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX2)
+				  );
+		} else {
+			seq_printf(s, "Port %d is DOWN\n", i);
+		}
+	}
+	i = 6;
+	seq_printf(s, "Host RxO:0x%x TxO:0x%x rx(0x%x:0x%x:0x%x) tx(0x%x:0x%x:0x%x)\n",
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RXOCT),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TXOCT),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX0),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX1),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_RX2),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX0),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX1),
+			vsc7385_read(vsc7385_proc_client, 1, i, VSC7385_C_TX2)
+		  );
+	return 0;
+}
+
+static struct seq_operations vsc7385_seq_ops = {
+	.start = vsc7385_seq_start,
+	.next  = vsc7385_seq_next,
+	.stop  = vsc7385_seq_stop,
+	.show  = vsc7385_seq_show
+};
+
+static int vsc7385_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &vsc7385_seq_ops);
+}
+
+static struct file_operations vsc7385_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = vsc7385_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+
+static void vsc7385_create_proc(void *arg)
+{
+	struct proc_dir_entry *pde;
+	pde = create_proc_entry("vsc7385", 0, NULL);
+	if (pde)
+		pde->proc_fops =  &vsc7385_proc_ops;
+	vsc7385_proc_client = arg;
+}
+
+static void vsc7385_remove_proc(void)
+{
+	vsc7385_proc_client = NULL;
+	remove_proc_entry("vsc7385", NULL);
+}
+#endif	/* defined(VSC7385_COUNTERS) && (VSC7385_COUNTERS) */
+
+static struct spi_driver vsc7385_driver;
+
+/********************************************
+ * vsc7385_attach_adapter -
+ *
+ *
+ ********************************************/
+static int vsc7385_attach_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client;
+
+	VSC7385_debug("vsc7385_attach_adapter\n");
+
+	/*Allocate memory for driver*/
+	vsc7385 = kmalloc(sizeof (struct vsc7385_data), GFP_KERNEL);
+	if (vsc7385 == NULL) {
+		VSC7385_err("vsc7385: Error while allocating memory\n");
+		goto err0;
+	}
+
+	memset(vsc7385, 0, sizeof(struct vsc7385_data));
+
+	client = &vsc7385->client;
+	spi_set_clientdata(client, vsc7385);
+
+	/*SPI Informations*/
+	client->adapter = adapter;
+	client->driver = &vsc7385_driver;
+	client->config.cs_msk = 0x8;		/* Use chip select 4 */
+	client->config.sc_polarity = 1;		/* inactive state of serial clock is high */
+	client->config.sc_phase = 1;		/* serial clock toggles at the start of first data bit */
+	client->config.sc_rate = 4000000;	/* 12 Mhz */
+	client->config.cs_delay = 8;		/* 8 bits */
+
+	if (spi_attach_client(client)) {
+		VSC7385_err("vsc7385: Error while registering to SPI bus\n");
+		goto err1;
+	}
+
+	/*Initialize the device*/
+	if (vsc7385_device_init(client)) {
+		VSC7385_err("vsc7385: Error while initializing device\n");
+		goto err2;
+	}
+
+	/*Start workqueue used to poll PHYs state*/
+	INIT_DELAYED_WORK(&vsc7385->watchdog_task, vsc7385_watchdog_task);
+	schedule_delayed_work(&vsc7385->watchdog_task, VSC7385_PHY_POLL_GAP * HZ);
+
+#if 	defined(VSC7385_COUNTERS) && (VSC7385_COUNTERS)
+	vsc7385_create_proc(client);
+#endif
+
+	return 0;
+
+err2:
+	/*Detach driver from SPI bus*/
+	spi_detach_client(client);
+
+err1:
+	/*Free allocated memory*/
+	kfree(vsc7385);
+
+err0:
+	return -1;
+}
+
+/********************************************
+ * si3220_detach_client -
+ *
+ *
+ ********************************************/
+static int vsc7385_detach_client(struct spi_client *client)
+{
+	struct vsc7385_data *vsc7385 = spi_get_clientdata(client);
+
+	VSC7385_debug("vsc7385_detach_client\n");
+#if 	defined(VSC7385_COUNTERS) && (VSC7385_COUNTERS)
+	vsc7385_remove_proc();
+#endif
+
+	cancel_delayed_work(&vsc7385->watchdog_task);
+
+	/*Detach driver from SPI bus*/
+	spi_detach_client(client);
+
+	/*Free allocated memory*/
+	kfree(vsc7385);
+
+	return 0;
+}
+
+static struct spi_driver vsc7385_driver = {
+	.name = VSC7385_DRIVER_NAME,
+	.attach_adapter = vsc7385_attach_adapter,
+	.detach_client	= vsc7385_detach_client,
+};
+
+
+/********************************************
+ * vsc7385_init -
+ *
+ *
+ ********************************************/
+static int __init vsc7385_driver_init(void)
+{
+	VSC7385_info("Vitesse vsc7385 Switch Linux driver\n");
+	spi_add_driver(&vsc7385_driver);
+
+	return 0;
+}
+
+/********************************************
+ * vsc7385_exit -
+ *
+ *
+ ********************************************/
+static void __exit vsc7385_driver_exit(void)
+{
+	VSC7385_info("vsc7385 driver exit\n");
+	spi_del_driver(&vsc7385_driver);
+}
+
+MODULE_AUTHOR("Mindspeed Technologies");
+MODULE_DESCRIPTION("Vitesse VSC7385 device driver");
+MODULE_LICENSE("GPL");
+
+module_init(vsc7385_driver_init);
+module_exit(vsc7385_driver_exit);
+module_param(mcast_ports, uint, S_IRUGO);
+
diff --git a/drivers/spi_mspd/spi-core.c b/drivers/spi_mspd/spi-core.c
new file mode 100644
index 0000000..b0882f6
--- /dev/null
+++ b/drivers/spi_mspd/spi-core.c
@@ -0,0 +1,433 @@
+/*
+ *  linux/drivers/spi_mspd/spi-core.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/spi_mspd/spi.h>
+
+static LIST_HEAD(spi_adapters);
+static LIST_HEAD(spi_drivers);
+
+/**
+ * spi_write_mem -
+ *
+ *
+ */
+int spi_write_mem(struct spi_client *client, u8 fs, u8 *buffer, int len)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof(struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_WRITE_ONLY;
+	transfer.wbuf = buffer;
+	transfer.wlen = len;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay (1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+
+
+/**
+ * spi_write_single -
+ *
+ *
+ */
+int spi_write_single(struct spi_client *client, u8 fs, u16 value)
+{
+	return spi_write_mem(client, fs, (u8 *)&value, 1);
+}
+
+/**
+ * spi_writen -
+ *
+ *
+ */
+int spi_writen(struct spi_client *client, u4 value)
+{
+	return spi_write_mem(client, 4, (u8 *)&value, 1);
+}
+
+
+/**
+ * spi_writeb -
+ *
+ *
+ */
+int spi_writeb(struct spi_client *client, u8 value)
+{
+	return spi_write_mem(client, 8, &value, 1);
+}
+
+
+/**
+ * spi_writew -
+ *
+ *
+ */
+int spi_writew(struct spi_client *client, u16 value)
+{
+	return spi_write_mem(client, 16, (u8 *)&value, 1);
+}
+
+/**
+ * spi_read_mem -
+ *
+ *
+ */
+int spi_read_mem(struct spi_client *client, u8 fs, u8 *buffer, int len)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof (struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_READ_ONLY;
+	transfer.rbuf = buffer;
+	transfer.rlen = len;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay (1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+
+
+/**
+ * spi_read_single -
+ *
+ *
+ */
+int spi_read_single(struct spi_client *client, u8 fs, u16 *value)
+{
+	return spi_read_mem(client, fs, (u8 *) value, 1);
+}
+
+/**
+ * spi_readn -
+ *
+ *
+ */
+int spi_readn(struct spi_client *client, u4 *value)
+{
+	return spi_read_mem(client, 4, (u8 *)value, 1);
+}
+
+
+/**
+ * spi_readb -
+ *
+ *
+ */
+int spi_readb(struct spi_client *client, u8 *value)
+{
+	return spi_read_mem(client, 8, value, 1);
+}
+
+/**
+ * spi_readw -
+ */
+int spi_readw(struct spi_client *client, u16 *value)
+{
+	return spi_read_mem(client, 16, (u8 *)value, 1);
+}
+
+/**
+ * spi_read_mem -
+ */
+int spi_writeread_mem(struct spi_client *client, u8 fs, u8 *rbuffer, int rlen, u8 *wbuffer, int wlen)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof (struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_WRITE_READ;
+	transfer.rbuf = rbuffer;
+	transfer.rlen = rlen;
+	transfer.wbuf = wbuffer;
+	transfer.wlen = wlen;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay (1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+/**
+ * spi_add_adapter -
+ *
+ *
+ */
+int spi_add_adapter(struct spi_adapter *adapter)
+{
+	struct spi_driver *driver;
+	struct list_head *item;
+
+	printk(KERN_INFO "SPI core: add adapter %s\n", adapter->name);
+
+	list_add(&adapter->list, &spi_adapters);
+	INIT_LIST_HEAD(&adapter->clients);
+
+	adapter->lock = __SPIN_LOCK_UNLOCKED(adapter->lock);
+
+	list_for_each(item, &spi_drivers) {
+		driver = list_entry(item, struct spi_driver, list);
+
+		/* We ignore the return code; if it fails, too bad */
+		driver->attach_adapter(adapter);
+	}
+
+	return 0;
+}
+
+/**
+ * spi_del_adapter -
+ *
+ *
+ */
+int spi_del_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client;
+	struct list_head *item, *_n;
+
+	printk(KERN_INFO "SPI core: del adapter %s\n", adapter->name);
+
+	list_for_each_safe(item, _n, &adapter->clients) {
+		client = list_entry(item, struct spi_client, list);
+
+		if (client->driver->detach_client(client))
+			goto out;
+	}
+
+	list_del(&adapter->list);
+
+out:
+	return 0;
+}
+
+/**
+ * spi_attach_client -
+ *
+ *
+ */
+int spi_attach_client(struct spi_client *client)
+{
+	struct spi_adapter *adapter = client->adapter;
+	struct spi_client_config *config = &client->config;
+	struct spi_adapter_caps *caps = &adapter->caps;
+
+	printk(KERN_INFO "SPI core: attach client to adapter %s\n", client->adapter->name);
+
+	if ((config->sc_rate >= caps->max_sc_rate) || (config->sc_rate < caps->min_sc_rate)) {
+		printk(KERN_INFO "SPI core: client serial clock rate %ld out of range [%ld, %ld]", config->sc_rate,
+				caps->min_sc_rate, caps->max_sc_rate);
+
+		goto err;
+	}
+
+	if (config->cs_msk & ~caps->cs_msk) {
+		printk(KERN_INFO "SPI core: client cs mask %#x not supported %#x", config->cs_msk,
+				caps->cs_msk);
+
+		goto err;
+	}
+
+	list_add(&client->list, &adapter->clients);
+
+	return 0;
+
+err:
+	return -1;
+}
+
+/**
+ * spi_dettach_client -
+ *
+ *
+ */
+int spi_detach_client(struct spi_client *client)
+{
+	printk(KERN_INFO "SPI core: client detach from adapter %s\n", client->adapter->name);
+
+	list_del(&client->list);
+
+	return 0;
+}
+
+/**
+ * spi_add_driver -
+ *
+ *
+ */
+int spi_add_driver(struct spi_driver *driver)
+{
+	struct spi_adapter *adapter;
+	struct list_head *item;
+
+	printk(KERN_INFO "SPI core: add driver %s\n", driver->name);
+
+	list_add(&driver->list, &spi_drivers);
+
+	list_for_each(item, &spi_adapters) {
+		adapter = list_entry(item, struct spi_adapter, list);
+		driver->attach_adapter(adapter);
+	}
+
+	return 0;
+
+}
+
+/**
+ * spi_del_driver -
+ *
+ *
+ */
+int spi_del_driver(struct spi_driver *driver)
+{
+	struct list_head *item1, *item2, *_n;
+	struct spi_adapter *adapter;
+	struct spi_client *client;
+
+	printk(KERN_INFO "SPI core: delete driver %s\n", driver->name);
+
+	list_for_each(item1, &spi_adapters) {
+		adapter = list_entry(item1, struct spi_adapter, list);
+
+		list_for_each_safe(item2, _n, &adapter->clients) {
+			client = list_entry(item2, struct spi_client, list);
+			if (client->driver != driver)
+				continue;
+
+			if (driver->detach_client(client))
+				goto err;
+		}
+	}
+	list_del(&driver->list);
+
+	return 0;
+
+err:
+	return -1;
+}
+
+/* match always succeeds, as we want the probe() to tell if we really accept this match */
+static int spi_device_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+struct bus_type spi_bus_type = {
+	.name = "spi",
+	.match = spi_device_match,
+};
+
+/**
+ * spi_driver_init -
+ *
+ *
+ */
+static int __init spi_driver_init(void)
+{
+	int retval;
+
+	printk(KERN_INFO "SPI core: loaded version 0.2\n");
+
+	retval = bus_register(&spi_bus_type);
+	if (retval)
+		goto err0;
+
+
+	return 0;
+
+
+err0:
+	return retval;
+}
+
+/**
+ * spi_driver_exit -
+ *
+ *
+ */
+static void __exit spi_driver_exit(void)
+{
+	bus_unregister(&spi_bus_type);
+}
+
+subsys_initcall(spi_driver_init);
+
+module_exit(spi_driver_exit);
+
+EXPORT_SYMBOL(spi_add_driver);
+EXPORT_SYMBOL(spi_del_driver);
+
+EXPORT_SYMBOL(spi_add_adapter);
+EXPORT_SYMBOL(spi_del_adapter);
+
+EXPORT_SYMBOL(spi_attach_client);
+EXPORT_SYMBOL(spi_detach_client);
+
+EXPORT_SYMBOL(spi_write_single);
+EXPORT_SYMBOL(spi_write_mem);
+
+EXPORT_SYMBOL(spi_writen);
+EXPORT_SYMBOL(spi_writeb);
+EXPORT_SYMBOL(spi_writew);
+
+EXPORT_SYMBOL(spi_read_mem);
+EXPORT_SYMBOL(spi_read_single);
+EXPORT_SYMBOL(spi_writeread_mem);
+
+EXPORT_SYMBOL(spi_readn);
+EXPORT_SYMBOL(spi_readb);
+EXPORT_SYMBOL(spi_readw);
+
+MODULE_AUTHOR("Rui Sousa <rui.sousa@mindspeed.com>");
+MODULE_DESCRIPTION("SPI core");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/spi_mspd/spi.h b/include/linux/spi_mspd/spi.h
new file mode 100644
index 0000000..b11a6f8
--- /dev/null
+++ b/include/linux/spi_mspd/spi.h
@@ -0,0 +1,130 @@
+/*
+ *  linux/include/linux/spi.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _SPI_H
+#define _SPI_H
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+
+#define SPI_TRANSFER_MODE_WRITE_ONLY	0x01
+#define SPI_TRANSFER_MODE_READ_ONLY	0x02
+#define SPI_TRANSFER_MODE_WRITE_READ	0x03
+
+typedef u8 u4;
+
+struct spi_transfer {
+	u8 *wbuf;
+	unsigned int wlen;
+
+	u8 *rbuf;
+	unsigned int rlen;
+
+	u8 mode;
+
+	u8 fs;				/* transfer frame size (in bits) */
+};
+
+struct spi_adapter_caps {
+	unsigned long min_sc_rate;	/* maximum supported serial clock rate (in MHz) */
+	unsigned long max_sc_rate;	/* minimum supported serial clock rate (in MHz) */
+
+	u8 max_fs;			/* maximum supported frame size (in bits) */
+	u8 min_fs;			/* minimum supported frame size (in bits) */
+
+	u16 cs_msk;			/* mask of supported chip selects */
+
+	u16 max_nframe;			/* maximum supported transfer frame number */
+	u16 min_nframe;			/* minimum supported transfer frame number */
+};
+
+struct spi_client_config {
+	u16 cs_msk;			/* chip select mask for this client */
+	u8 sc_polarity;			/* serial clock polarity */
+	u8 sc_phase;			/* serial clock phase */
+	unsigned long sc_rate;		/* serial clock rate (in MHz)*/
+	u8 cs_delay;			/* chip select deassert time (in serial clock cycles) */
+};
+
+/* A SPI bus adapter instance */
+struct spi_adapter {
+	char *name;
+
+	int (*do_transfer)(struct spi_adapter *adapter, struct spi_transfer *transfer, struct spi_client_config *config);
+
+	void *data;
+	struct device dev;
+	struct list_head list;
+	struct list_head clients;
+
+	struct spi_adapter_caps caps;
+
+	spinlock_t lock;
+};
+
+/* A SPI device instance */
+struct spi_client {
+	struct spi_client_config config;
+
+	struct spi_driver *driver;
+
+	struct spi_adapter *adapter;
+	struct device dev;
+	struct list_head list;
+};
+
+/* A SPI device driver */
+struct spi_driver {
+	char *name;
+
+	int (*attach_adapter)(struct spi_adapter *adapter);
+	int (*detach_client)(struct spi_client *client);
+	struct device_driver driver;
+	struct list_head list;
+};
+
+static inline void *spi_get_clientdata (struct spi_client *dev)
+{
+	return dev_get_drvdata (&dev->dev);
+}
+
+static inline void spi_set_clientdata (struct spi_client *dev, void *data)
+{
+	dev_set_drvdata (&dev->dev, data);
+}
+
+int spi_add_adapter(struct spi_adapter *adapter);
+int spi_del_adapter(struct spi_adapter *adapter);
+
+int spi_add_driver(struct spi_driver *driver);
+int spi_del_driver(struct spi_driver *driver);
+
+int spi_attach_client(struct spi_client *client);
+int spi_detach_client(struct spi_client *client);
+
+int spi_write_mem(struct spi_client *client, u8 fs, u8 *buffer, int len);
+int spi_write_single(struct spi_client *client, u8 fs, u16 value);
+
+int spi_writen(struct spi_client *client, u4 value);
+int spi_writeb(struct spi_client *client, u8 value);
+int spi_writew(struct spi_client *client, u16 value);
+
+int spi_read_mem(struct spi_client *client, u8 fs, u8 *buffer, int len);
+int spi_read_single(struct spi_client *client, u8 fs, u16 *value);
+int spi_writeread_mem(struct spi_client *client, u8 fs, u8 *rbuffer, int rlen, u8 *wbuffer, int wlen);
+
+int spi_readn(struct spi_client *client, u4 *value);
+int spi_readb(struct spi_client *client, u8 *value);
+int spi_readw(struct spi_client *client, u16 *value);
+
+#endif /* _SPI_H */
-- 
1.6.0.90.g436ed

