From 7f3074f41f9e492457d6ba047ed151407e87b0b8 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 19 May 2010 20:12:38 +0800
Subject: [PATCH 10/30] mxc/nand: Add nand driver for mxc nand controller V2 and V3

Nand controller version 2 and 3 can support up to 4K bytes page
size and 26 bytes spare area size nand flash, i also can support
multi-chip nand flash. Now add driver for this controller.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/mtd/nand/Kconfig            |   36 +
 drivers/mtd/nand/Makefile           |    2 +
 drivers/mtd/nand/mxc_nd2.c          | 1501 +++++++++++++++++++++++
 drivers/mtd/nand/mxc_nd2.h          |  701 +++++++++++
 drivers/mtd/nand/nand_device_info.c | 2286 +++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/nand_device_info.h |  140 +++
 include/linux/mtd/nand.h            |    2 +
 7 files changed, 4668 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/nand/mxc_nd2.c
 create mode 100644 drivers/mtd/nand/mxc_nd2.h
 create mode 100644 drivers/mtd/nand/nand_device_info.c
 create mode 100644 drivers/mtd/nand/nand_device_info.h

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 42e5ea4..85510e1 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -449,6 +449,42 @@ config MTD_NAND_MXC
 	  This enables the driver for the NAND flash controller on the
 	  MXC processors.
 
+config MTD_NAND_MXC_V2
+	tristate "MXC NAND Version 2 support"
+	depends on MTD_NAND && ARCH_MXC_HAS_NFC_V2
+	help
+	  This enables the driver for the version 2 of NAND flash controller
+	  on the MXC processors.
+
+config MTD_NAND_MXC_V3
+	tristate "MXC NAND Version 3 support"
+	depends on MTD_NAND && ARCH_MXC_HAS_NFC_V3
+	help
+	  This enables the driver for the version 3 of NAND flash controller
+	  on the MXC processors.
+
+config MTD_NAND_MXC_SWECC
+	bool "Software ECC support "
+	depends on MTD_NAND_MXC || MTD_NAND_MXC_V2 || MTD_NAND_MXC_V3
+	help
+	  This enables the support for Software ECC handling. By
+	  default MXC NAND controller Hardware ECC is supported.
+
+
+config MTD_NAND_MXC_FORCE_CE
+	bool "NAND chip select operation support"
+	 depends on MTD_NAND_MXC || MTD_NAND_MXC_V2|| MTD_NAND_MXC_V3
+	help
+	  This enables the NAND chip select by using CE control line. By
+	  default CE operation is disabled.
+
+config MXC_NAND_LOW_LEVEL_ERASE
+	bool "Low level NAND erase"
+	depends on MTD_NAND_MXC || MTD_NAND_MXC_V2 || MTD_NAND_MXC_V3
+	help
+	  This enables the erase of whole NAND flash. By
+	  default low level erase operation is disabled.
+
 config MTD_NAND_NOMADIK
 	tristate "ST Nomadik 8815 NAND support"
 	depends on ARCH_NOMADIK
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 1407bd1..4663c74 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -37,6 +37,8 @@ obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
 obj-$(CONFIG_MTD_NAND_SH_FLCTL)		+= sh_flctl.o
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
+obj-$(CONFIG_MTD_NAND_MXC_V2)		+= mxc_nd2.o nand_device_info.o
+obj-$(CONFIG_MTD_NAND_MXC_V3)		+= mxc_nd2.o nand_device_info.o
 obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
diff --git a/drivers/mtd/nand/mxc_nd2.c b/drivers/mtd/nand/mxc_nd2.c
new file mode 100644
index 0000000..9d272e5
--- /dev/null
+++ b/drivers/mtd/nand/mxc_nd2.c
@@ -0,0 +1,1501 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+#include <asm/mach/flash.h>
+#include <mach/clock.h>
+#include "mxc_nd2.h"
+#include "nand_device_info.h"
+
+#define DVR_VER "2.5"
+
+/* Global address Variables */
+static void __iomem *nfc_axi_base, *nfc_ip_base;
+
+struct mxc_mtd_s {
+	struct mtd_info mtd;
+	struct nand_chip nand;
+	struct mtd_partition *parts;
+	struct device *dev;
+};
+
+static struct mxc_mtd_s *mxc_nand_data;
+
+/*
+ * Define delay timeout value
+ */
+#define TROP_US_DELAY   (1000 * 1000)
+
+struct nand_info {
+	bool bStatusRequest;
+	u16 colAddr;
+};
+
+static struct nand_info g_nandfc_info;
+
+#ifdef CONFIG_MTD_NAND_MXC_SWECC
+static int hardware_ecc;
+#else
+static int hardware_ecc = 1;
+#endif
+
+static u8 num_of_interleave = 1;
+
+static u8 *data_buf;
+static u8 *oob_buf;
+
+static int g_page_mask;
+
+static struct clk *nfc_clk;
+
+/*
+ * OOB placement block for use with hardware ecc generation
+ */
+static struct nand_ecclayout nand_hw_eccoob_512 = {
+	.eccbytes = 9,
+	.eccpos = {7, 8, 9, 10, 11, 12, 13, 14, 15},
+	.oobavail = 4,
+	.oobfree = { {0, 4} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_2k = {
+	.eccbytes = 9,
+	.eccpos = {7, 8, 9, 10, 11, 12, 13, 14, 15},
+	.oobavail = 4,
+	.oobfree = { {2, 4} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_4k = {
+	.eccbytes = 32,
+	.eccpos = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+		   38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 },
+	.oobavail = 30,
+	.oobfree = {{2, 10}, {28, 10}, {54, 10} }
+};
+
+/*!
+ * @defgroup NAND_MTD NAND Flash MTD Driver for MXC processors
+ */
+
+/*!
+ * @file mxc_nd2.c
+ *
+ * @brief This file contains the hardware specific layer for NAND Flash on
+ * MXC processor
+ *
+ * @ingroup NAND_MTD
+ */
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "RedBoot", "cmdlinepart", NULL };
+#endif
+
+static wait_queue_head_t irq_waitq;
+
+static irqreturn_t mxc_nfc_irq(int irq, void *dev_id)
+{
+	/* Disable Interuupt */
+	raw_write(raw_read(REG_NFC_INTRRUPT) | NFC_INT_MSK, REG_NFC_INTRRUPT);
+	wake_up(&irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+static void nfc_memcpy(void *dest, void *src, int len)
+{
+	u8 *d = dest;
+	u8 *s = src;
+
+	while (len > 0) {
+		if (len >= 4) {
+			*(u32 *)d = *(u32 *)s;
+			d += 4;
+			s += 4;
+			len -= 4;
+		} else {
+			*(u16 *)d = *(u16 *)s;
+			len -= 2;
+			break;
+		}
+	}
+
+	if (len)
+		BUG();
+}
+
+/*
+ * Functions to transfer data to/from spare erea.
+ */
+static void
+copy_spare(struct mtd_info *mtd, void *pbuf, void *pspare, int len, bool bfrom)
+{
+	u16 i, j;
+	u16 m = mtd->oobsize;
+	u16 n = mtd->writesize >> 9;
+	u8 *d = (u8 *) pbuf;
+	u8 *s = (u8 *) pspare;
+	u16 t = SPARE_LEN;
+
+	m /= num_of_interleave;
+	n /= num_of_interleave;
+
+	j = (m / n >> 1) << 1;
+
+	if (bfrom) {
+		for (i = 0; i < n - 1; i++)
+			nfc_memcpy(&d[i * j], &s[i * t], j);
+
+		/* the last section */
+		nfc_memcpy(&d[i * j], &s[i * t], len - i * j);
+	} else {
+		for (i = 0; i < n - 1; i++)
+			nfc_memcpy(&s[i * t], &d[i * j], j);
+
+		/* the last section */
+		nfc_memcpy(&s[i * t], &d[i * j], len - i * j);
+	}
+}
+
+/*!
+ * This function polls the NFC to wait for the basic operation to complete by
+ * checking the INT bit of config2 register.
+ *
+ * @param       maxRetries     number of retry attempts (separated by 1 us)
+ * @param       useirq         True if IRQ should be used rather than polling
+ */
+static void wait_op_done(int maxRetries, bool useirq)
+{
+	if (useirq) {
+		if ((raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT) == 0) {
+			/* Enable Interuupt */
+			raw_write(raw_read(REG_NFC_INTRRUPT) & ~NFC_INT_MSK,
+				  REG_NFC_INTRRUPT);
+			if (!wait_event_timeout(irq_waitq,
+				(raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT),
+				msecs_to_jiffies(TROP_US_DELAY / 1000)) > 0) {
+				printk(KERN_WARNING "%s(%d): INT not set\n",
+						__func__, __LINE__);
+				return;
+			}
+		}
+		WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+				  ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
+	} else {
+		while (1) {
+			maxRetries--;
+			if (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT) {
+				WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+						  ~NFC_OPS_STAT),
+						 REG_NFC_OPS_STAT);
+				break;
+			}
+			udelay(1);
+			if (maxRetries <= 0) {
+				printk(KERN_WARNING "%s(%d): INT not set\n",
+						__func__, __LINE__);
+				break;
+			}
+		}
+	}
+}
+
+static inline void send_atomic_cmd(u16 cmd, bool useirq)
+{
+	/* fill command */
+	raw_write(cmd, REG_NFC_FLASH_CMD);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* send out command */
+	raw_write(NFC_CMD, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr);
+static int mxc_check_ecc_status(struct mtd_info *mtd);
+
+#ifdef NFC_AUTO_MODE_ENABLE
+/*!
+ * This function handle the interleave related work
+ * @param	mtd	mtd info
+ * @param	cmd	command
+ */
+static void auto_cmd_interleave(struct mtd_info *mtd, u16 cmd)
+{
+	u32 i, page_addr, ncs;
+	u32 j = num_of_interleave;
+	struct nand_chip *this = mtd->priv;
+	u32 addr_low = raw_read(NFC_FLASH_ADDR0);
+	u32 addr_high = raw_read(NFC_FLASH_ADDR8);
+	u8 *dbuf = data_buf;
+	u8 *obuf = oob_buf;
+	u32 dlen = mtd->writesize / j;
+	u32 olen = mtd->oobsize / j;
+
+	/* adjust the addr value
+	 * since ADD_OP mode is 01
+	 */
+	if (cmd == NAND_CMD_ERASE2)
+		page_addr = addr_low;
+	else
+		page_addr = addr_low >> 16 | addr_high << 16;
+
+	ncs = page_addr >> (this->chip_shift - this->page_shift);
+
+	if (j > 1) {
+		page_addr *= j;
+	} else {
+		page_addr *= this->numchips;
+		page_addr += ncs;
+	}
+
+	switch (cmd) {
+	case NAND_CMD_PAGEPROG:
+		for (i = 0; i < j; i++) {
+			/* reset addr cycle */
+			mxc_do_addr_cycle(mtd, 0, page_addr++);
+
+			/* data transfer */
+			memcpy(MAIN_AREA0, dbuf, dlen);
+			copy_spare(mtd, obuf, SPARE_AREA0, olen, false);
+
+			/* update the value */
+			dbuf += dlen;
+			obuf += olen;
+
+			NFC_SET_RBA(0);
+			ACK_OPS;
+			raw_write(NFC_AUTO_PROG, REG_NFC_OPS);
+
+			/* wait auto_prog_done bit set */
+			while (!(raw_read(REG_NFC_OPS_STAT) & NFC_OP_DONE))
+				;
+		}
+
+		wait_op_done(TROP_US_DELAY, true);
+		while (!(raw_read(REG_NFC_OPS_STAT) & NFC_RB)) ;
+
+		break;
+	case NAND_CMD_READSTART:
+		for (i = 0; i < j; i++) {
+			/* reset addr cycle */
+			mxc_do_addr_cycle(mtd, 0, page_addr++);
+
+			NFC_SET_RBA(0);
+			ACK_OPS;
+			raw_write(NFC_AUTO_READ, REG_NFC_OPS);
+			wait_op_done(TROP_US_DELAY, true);
+
+			/* check ecc error */
+			mxc_check_ecc_status(mtd);
+
+			/* data transfer */
+			memcpy(dbuf, MAIN_AREA0, dlen);
+			copy_spare(mtd, obuf, SPARE_AREA0, olen, true);
+
+			/* update the value */
+			dbuf += dlen;
+			obuf += olen;
+		}
+		break;
+	case NAND_CMD_ERASE2:
+		for (i = 0; i < j; i++) {
+			mxc_do_addr_cycle(mtd, -1, page_addr++);
+			ACK_OPS;
+			raw_write(NFC_AUTO_ERASE, REG_NFC_OPS);
+			wait_op_done(TROP_US_DELAY, true);
+		}
+		break;
+	case NAND_CMD_RESET:
+		for (i = 0; i < j; i++) {
+			if (j > 1)
+				NFC_SET_NFC_ACTIVE_CS(i);
+			send_atomic_cmd(cmd, false);
+		}
+		break;
+	default:
+		break;
+	}
+}
+#endif
+
+static void send_addr(u16 addr, bool useirq);
+
+/*!
+ * This function issues the specified command to the NAND device and
+ * waits for completion.
+ *
+ * @param       cmd     command for NAND Flash
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_cmd(struct mtd_info *mtd, u16 cmd, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_cmd(0x%x, %d)\n", cmd, useirq);
+
+#ifdef NFC_AUTO_MODE_ENABLE
+	switch (cmd) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READOOB:
+		raw_write(NAND_CMD_READ0, REG_NFC_FLASH_CMD);
+		break;
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_ERASE1:
+		raw_write(cmd, REG_NFC_FLASH_CMD);
+		break;
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_READSTART:
+		raw_write(raw_read(REG_NFC_FLASH_CMD) | cmd << NFC_CMD_1_SHIFT,
+			  REG_NFC_FLASH_CMD);
+		auto_cmd_interleave(mtd, cmd);
+		break;
+	case NAND_CMD_READID:
+		send_atomic_cmd(cmd, useirq);
+		send_addr(0, false);
+		break;
+	case NAND_CMD_RESET:
+		auto_cmd_interleave(mtd, cmd);
+		break;
+	case NAND_CMD_STATUS:
+		send_atomic_cmd(cmd, useirq);
+		break;
+	default:
+		break;
+	}
+#else
+	send_atomic_cmd(cmd, useirq);
+#endif
+}
+
+/*!
+ * This function sends an address (or partial address) to the
+ * NAND device.  The address is used to select the source/destination for
+ * a NAND command.
+ *
+ * @param       addr    address to be written to NFC.
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_addr(u16 addr, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_addr(0x%x %d)\n", addr, useirq);
+
+	/* fill address */
+	raw_write((addr << NFC_FLASH_ADDR_SHIFT), REG_NFC_FLASH_ADDR);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* send out address */
+	raw_write(NFC_ADDR, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+/*!
+ * This function requests the NFC to initate the transfer
+ * of data currently in the NFC RAM buffer to the NAND device.
+ *
+ * @param	buf_id	      Specify Internal RAM Buffer number
+ */
+static void send_prog_page(u8 buf_id)
+{
+#ifndef NFC_AUTO_MODE_ENABLE
+	DEBUG(MTD_DEBUG_LEVEL3, "%s\n", __func__);
+
+	/* set ram buffer id */
+	NFC_SET_RBA(buf_id);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* transfer data from NFC ram to nand */
+	raw_write(NFC_INPUT, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+#endif
+}
+
+/*!
+ * This function requests the NFC to initated the transfer
+ * of data from the NAND device into in the NFC ram buffer.
+ *
+ * @param	buf_id		Specify Internal RAM Buffer number
+ */
+static void send_read_page(u8 buf_id)
+{
+#ifndef NFC_AUTO_MODE_ENABLE
+	DEBUG(MTD_DEBUG_LEVEL3, "%s(%d)\n", _func__, buf_id);
+
+	/* set ram buffer id */
+	NFC_SET_RBA(buf_id);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* transfer data from nand to NFC ram */
+	raw_write(NFC_OUTPUT, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+#endif
+}
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device ID.
+ */
+static void send_read_id(void)
+{
+	/* Set RBA bits for BUFFER0 */
+	NFC_SET_RBA(0);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* Read ID into main buffer */
+	raw_write(NFC_ID, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, false);
+
+}
+
+#ifdef NFC_AUTO_MODE_ENABLE
+static inline void read_dev_status(u16 *status)
+{
+	u32 mask = 0xFF << 16;
+
+	/* clear status */
+	ACK_OPS;
+
+
+	/* use atomic mode to read status instead
+	   of using auto mode,auto-mode has issues
+	   and the status is not correct.
+	*/
+	raw_write(NFC_STATUS, REG_NFC_OPS);
+
+	wait_op_done(TROP_US_DELAY, true);
+
+	*status = (raw_read(NFC_CONFIG1) & mask) >> 16;
+
+}
+#endif
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device status and returns the current status.
+ *
+ * @return  device status
+ */
+static u16 get_dev_status(void)
+{
+#ifdef NFC_AUTO_MODE_ENABLE
+	int i;
+	u16 status = 0;
+	for (i = 0; i < num_of_interleave; i++) {
+
+		/* set ative cs */
+		NFC_SET_NFC_ACTIVE_CS(i);
+
+		/* FIXME, NFC Auto erase may have
+		 * problem, have to pollingit until
+		 * the nand get idle, otherwise
+		 * it may get error
+		 */
+		read_dev_status(&status);
+		if (status & NAND_STATUS_FAIL)
+			break;
+	}
+
+	return status;
+#else
+	volatile u16 *mainBuf = MAIN_AREA1;
+	u8 val = 1;
+	u16 ret;
+
+	/* Set ram buffer id */
+	NFC_SET_RBA(val);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* Read status into main buffer */
+	raw_write(NFC_STATUS, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+
+	/* Status is placed in first word of main buffer */
+	/* get status, then recovery area 1 data */
+	ret = *mainBuf;
+
+	return ret;
+#endif
+}
+
+static void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN);
+	return;
+}
+
+/*
+ * Function to record the ECC corrected/uncorrected errors resulted
+ * after a page read. This NFC detects and corrects upto to 4 symbols
+ * of 9-bits each.
+ */
+static int mxc_check_ecc_status(struct mtd_info *mtd)
+{
+	u32 ecc_stat, err;
+	int no_subpages = 1;
+	int ret = 0;
+	u8 ecc_bit_mask, err_limit;
+
+	ecc_bit_mask = (IS_4BIT_ECC ? 0x7 : 0xf);
+	err_limit = (IS_4BIT_ECC ? 0x4 : 0x8);
+
+	no_subpages = mtd->writesize >> 9;
+
+	no_subpages /= num_of_interleave;
+
+	ecc_stat = GET_NFC_ECC_STATUS();
+	do {
+		err = ecc_stat & ecc_bit_mask;
+		if (err > err_limit) {
+			mtd->ecc_stats.failed++;
+			printk(KERN_WARNING "UnCorrectable RS-ECC Error\n");
+			return -1;
+		} else {
+			ret += err;
+		}
+		ecc_stat >>= 4;
+	} while (--no_subpages);
+
+	mtd->ecc_stats.corrected += ret;
+	pr_debug("%d Symbol Correctable RS-ECC Error\n", ret);
+
+	return ret;
+}
+
+/*
+ * Function to correct the detected errors. This NFC corrects all the errors
+ * detected. So this function just return 0.
+ */
+static int mxc_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)
+{
+	return 0;
+}
+
+/*
+ * Function to calculate the ECC for the data to be stored in the Nand device.
+ * This NFC has a hardware RS(511,503) ECC engine together with the RS ECC
+ * CONTROL blocks are responsible for detection  and correction of up to
+ * 8 symbols of 9 bits each in 528 byte page.
+ * So this function is just return 0.
+ */
+
+static int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				  u_char *ecc_code)
+{
+	return 0;
+}
+
+/*!
+ * This function id is used to read the data buffer from the NAND Flash. To
+ * read the data from NAND Flash first the data output cycle is initiated by
+ * the NFC, which copies the data to RAMbuffer. This data of length \b len is
+ * then copied to buffer \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be read from NAND Flash
+ * @param       len     number of bytes to be read
+ */
+static void mxc_nand_read_buf(struct mtd_info *mtd, u_char * buf, int len)
+{
+	u16 col = g_nandfc_info.colAddr;
+
+	if (mtd->writesize) {
+
+		int j = mtd->writesize - col;
+		int n = mtd->oobsize + j;
+
+		n = min(n, len);
+
+		if (j > 0) {
+			if (n > j) {
+				memcpy(buf, &data_buf[col], j);
+				memcpy(buf + j, &oob_buf[0], n - j);
+			} else {
+				memcpy(buf, &data_buf[col], n);
+			}
+		} else {
+			col -= mtd->writesize;
+			memcpy(buf, &oob_buf[col], len);
+		}
+
+		/* update */
+		g_nandfc_info.colAddr += n;
+
+	} else {
+		/* At flash identify phase,
+		 * mtd->writesize has not been
+		 * set correctly, it should
+		 * be zero.And len will less 2
+		 */
+		memcpy(buf, &data_buf[col], len);
+
+		/* update */
+		g_nandfc_info.colAddr += len;
+	}
+
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static uint8_t mxc_nand_read_byte(struct mtd_info *mtd)
+{
+	uint8_t ret;
+
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest)
+		return get_dev_status() & 0xFF;
+
+	mxc_nand_read_buf(mtd, &ret, 1);
+
+	return ret;
+}
+
+/*!
+  * This function reads word from the NAND Flash
+  *
+  * @param     mtd     MTD structure for the NAND Flash
+  *
+  * @return    data read from the NAND Flash
+  */
+static u16 mxc_nand_read_word(struct mtd_info *mtd)
+{
+	u16 ret;
+
+	mxc_nand_read_buf(mtd, (uint8_t *) &ret, sizeof(u16));
+
+	return ret;
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param     mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static u_char mxc_nand_read_byte16(struct mtd_info *mtd)
+{
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest)
+		return get_dev_status() & 0xFF;
+
+	return mxc_nand_read_word(mtd) & 0xFF;
+}
+
+/*!
+ * This function writes data of length \b len from buffer \b buf to the NAND
+ * internal RAM buffer's MAIN area 0.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be written to NAND Flash
+ * @param       len     number of bytes to be written
+ */
+static void mxc_nand_write_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	u16 col = g_nandfc_info.colAddr;
+	int j = mtd->writesize - col;
+	int n = mtd->oobsize + j;
+
+	n = min(n, len);
+
+	if (j > 0) {
+		if (n > j) {
+			memcpy(&data_buf[col], buf, j);
+			memcpy(&oob_buf[0], buf + j, n - j);
+		} else {
+			memcpy(&data_buf[col], buf, n);
+		}
+	} else {
+		col -= mtd->writesize;
+		memcpy(&oob_buf[col], buf, len);
+	}
+
+	/* update */
+	g_nandfc_info.colAddr += n;
+}
+
+/*!
+ * This function is used by the upper layer to verify the data in NAND Flash
+ * with the data in the \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be verified
+ * @param       len     length of the data to be verified
+ *
+ * @return      -EFAULT if error else 0
+ *
+ */
+static int mxc_nand_verify_buf(struct mtd_info *mtd, const u_char * buf,
+			       int len)
+{
+	u_char *s = data_buf;
+
+	const u_char *p = buf;
+
+	for (; len > 0; len--) {
+		if (*p++ != *s++)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*!
+ * This function is used by upper layer for select and deselect of the NAND
+ * chip
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       chip    val indicating select or deselect
+ */
+static void mxc_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+
+	switch (chip) {
+	case -1:
+		/* Disable the NFC clock */
+		if (clk_get_usecount(nfc_clk) > 0)
+			clk_disable(nfc_clk);
+		break;
+	case 0 ... 7:
+		/* Enable the NFC clock */
+		clk_enable(nfc_clk);
+
+		NFC_SET_NFC_ACTIVE_CS(chip);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*
+ * Function to perform the address cycles.
+ */
+static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)
+{
+#ifdef NFC_AUTO_MODE_ENABLE
+
+	if (page_addr != -1 && column != -1) {
+		u32 mask = 0xFFFF;
+		/* the column address */
+		raw_write(column & mask, NFC_FLASH_ADDR0);
+		raw_write((raw_read(NFC_FLASH_ADDR0) |
+			   ((page_addr & mask) << 16)), NFC_FLASH_ADDR0);
+		/* the row address */
+		raw_write(((raw_read(NFC_FLASH_ADDR8) & (mask << 16)) |
+			   ((page_addr & (mask << 16)) >> 16)),
+			  NFC_FLASH_ADDR8);
+	} else if (page_addr != -1) {
+		raw_write(page_addr, NFC_FLASH_ADDR0);
+		raw_write(0, NFC_FLASH_ADDR8);
+	}
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "AutoMode:the ADDR REGS value is (0x%x, 0x%x)\n",
+	      raw_read(NFC_FLASH_ADDR0), raw_read(NFC_FLASH_ADDR8));
+#else
+
+	u32 page_mask = g_page_mask;
+
+	if (column != -1) {
+		send_addr(column & 0xFF, true);
+		if (IS_2K_PAGE_NAND) {
+			/* another col addr cycle for 2k page */
+			send_addr((column >> 8) & 0xF, true);
+		} else if (IS_4K_PAGE_NAND) {
+			/* another col addr cycle for 4k page */
+			send_addr((column >> 8) & 0x1F, true);
+		}
+	}
+	if (page_addr != -1) {
+		do {
+			send_addr((page_addr & 0xff), true);
+			page_mask >>= 8;
+			page_addr >>= 8;
+		} while (page_mask != 0);
+	}
+#endif
+}
+
+/*!
+ * This function is used by the upper layer to write command to NAND Flash for
+ * different operations to be carried out on NAND Flash
+ *
+ * @param       mtd             MTD structure for the NAND Flash
+ * @param       command         command for NAND Flash
+ * @param       column          column offset for the page read
+ * @param       page_addr       page to be read from NAND Flash
+ */
+static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
+			     int column, int page_addr)
+{
+	bool useirq = true;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",
+	      command, column, page_addr);
+	/*
+	 * Reset command state information
+	 */
+	g_nandfc_info.bStatusRequest = false;
+
+	/*
+	 * Command pre-processing step
+	 */
+	switch (command) {
+	case NAND_CMD_STATUS:
+		g_nandfc_info.colAddr = 0;
+		g_nandfc_info.bStatusRequest = true;
+		break;
+
+	case NAND_CMD_READ0:
+		g_nandfc_info.colAddr = column;
+		break;
+
+	case NAND_CMD_READOOB:
+		g_nandfc_info.colAddr = column;
+		command = NAND_CMD_READ0;
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (column != 0) {
+
+			/* FIXME: before send SEQIN command for
+			 * partial write,We need read one page out.
+			 * FSL NFC does not support partial write
+			 * It alway send out 512+ecc+512+ecc ...
+			 * for large page nand flash. But for small
+			 * page nand flash, it did support SPARE
+			 * ONLY operation. But to make driver
+			 * simple. We take the same as large page,read
+			 * whole page out and update. As for MLC nand
+			 * NOP(num of operation) = 1. Partial written
+			 * on one programed page is not allowed! We
+			 * can't limit it on the driver, it need the
+			 * upper layer applicaiton take care it
+			 */
+
+			mxc_nand_command(mtd, NAND_CMD_READ0, 0, page_addr);
+		}
+
+		g_nandfc_info.colAddr = column;
+		column = 0;
+
+		break;
+
+	case NAND_CMD_PAGEPROG:
+#ifndef NFC_AUTO_MODE_ENABLE
+		/* FIXME:the NFC interal buffer
+		 * access has some limitation, it
+		 * does not allow byte access. To
+		 * make the code simple and ease use
+		 * not every time check the address
+		 * alignment.Use the temp buffer
+		 * to accomadate the data.since We
+		 * know data_buf will be at leat 4
+		 * byte alignment, so we can use
+		 * memcpy safely
+		 */
+		nfc_memcpy(MAIN_AREA0, data_buf, mtd->writesize);
+		copy_spare(mtd, oob_buf, SPARE_AREA0, mtd->oobsize, false);
+#endif
+
+		if (IS_LARGE_PAGE_NAND)
+			PROG_PAGE();
+		else
+			send_prog_page(0);
+
+		break;
+
+	case NAND_CMD_ERASE1:
+		break;
+	case NAND_CMD_ERASE2:
+		break;
+	}
+
+	/*
+	 * Write out the command to the device.
+	 */
+	send_cmd(mtd, command, useirq);
+
+	mxc_do_addr_cycle(mtd, column, page_addr);
+
+	/*
+	 * Command post-processing step
+	 */
+	switch (command) {
+
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		if (IS_LARGE_PAGE_NAND) {
+			/* send read confirm command */
+			send_cmd(mtd, NAND_CMD_READSTART, true);
+			/* read for each AREA */
+			READ_PAGE();
+		} else {
+			send_read_page(0);
+		}
+
+#ifndef NFC_AUTO_MODE_ENABLE
+		/* FIXME, the NFC interal buffer
+		 * access has some limitation, it
+		 * does not allow byte access. To
+		 * make the code simple and ease use
+		 * not every time check the address
+		 * alignment.Use the temp buffer
+		 * to accomadate the data.since We
+		 * know data_buf will be at leat 4
+		 * byte alignment, so we can use
+		 * memcpy safely
+		 */
+		nfc_memcpy(data_buf, MAIN_AREA0, mtd->writesize);
+		copy_spare(mtd, oob_buf, SPARE_AREA0, mtd->oobsize, true);
+#endif
+
+		break;
+
+	case NAND_CMD_READID:
+		send_read_id();
+		g_nandfc_info.colAddr = column;
+		nfc_memcpy(data_buf, MAIN_AREA0, 2048);
+
+		break;
+	}
+}
+
+static int mxc_nand_read_oob(struct mtd_info *mtd,
+			     struct nand_chip *chip, int page, int sndcmd)
+{
+	if (sndcmd) {
+
+		chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
+		sndcmd = 0;
+	}
+
+	memcpy(chip->oob_poi, oob_buf, mtd->oobsize);
+
+	return sndcmd;
+}
+
+static int mxc_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+			      uint8_t *buf, int page)
+{
+
+#ifndef NFC_AUTO_MODE_ENABLE
+	mxc_check_ecc_status(mtd);
+#endif
+
+	memcpy(buf, data_buf, mtd->writesize);
+	memcpy(chip->oob_poi, oob_buf, mtd->oobsize);
+
+	return 0;
+}
+
+static void mxc_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+				const uint8_t *buf)
+{
+	memcpy(data_buf, buf, mtd->writesize);
+	memcpy(oob_buf, chip->oob_poi, mtd->oobsize);
+
+}
+
+/* Define some generic bad / good block scan pattern which are used
+ * while scanning a device for factory marked good / bad blocks. */
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr smallpage_memorybased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr largepage_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+static int mxc_nand_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	g_page_mask = this->pagemask;
+
+	if (IS_2K_PAGE_NAND) {
+		NFC_SET_NFMS(1 << NFMS_NF_PG_SZ);
+		this->ecc.layout = &nand_hw_eccoob_2k;
+	} else if (IS_4K_PAGE_NAND) {
+		NFC_SET_NFMS(1 << NFMS_NF_PG_SZ);
+		this->ecc.layout = &nand_hw_eccoob_4k;
+	} else {
+		this->ecc.layout = &nand_hw_eccoob_512;
+	}
+
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = this->ecc.layout;
+
+	/* jffs2 not write oob */
+	mtd->flags &= ~MTD_OOB_WRITEABLE;
+
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
+	/* update flash based bbt */
+	this->options |= NAND_USE_FLASH_BBT;
+
+	if (!this->badblock_pattern) {
+		this->badblock_pattern = (mtd->writesize > 512) ?
+		    &largepage_memorybased : &smallpage_memorybased;
+	}
+
+	/* Build bad block table */
+	return nand_scan_bbt(mtd, this->badblock_pattern);
+}
+
+static void mxc_nfc_init(void)
+{
+	/* Disable interrupt */
+	raw_write((raw_read(REG_NFC_INTRRUPT) | NFC_INT_MSK), REG_NFC_INTRRUPT);
+
+	/* disable spare enable */
+	raw_write(raw_read(REG_NFC_SP_EN) & ~NFC_SP_EN, REG_NFC_SP_EN);
+
+	/* Unlock the internal RAM Buffer */
+	raw_write(NFC_SET_BLS(NFC_BLS_UNLCOKED), REG_NFC_BLS);
+
+	/* Blocks to be unlocked */
+	UNLOCK_ADDR(0x0, 0xFFFF);
+
+	/* Unlock Block Command for given address range */
+	raw_write(NFC_SET_WPC(NFC_WPC_UNLOCK), REG_NFC_WPC);
+
+	/* Enable symetric mode by default except mx37TO1.0 */
+	if (!(cpu_is_mx37_rev(CHIP_REV_1_0) == 1))
+		raw_write(raw_read(REG_NFC_ONE_CYCLE) |
+			  NFC_ONE_CYCLE, REG_NFC_ONE_CYCLE);
+}
+
+static int mxc_alloc_buf(void)
+{
+	int err = 0;
+
+	data_buf = kzalloc(NAND_MAX_PAGESIZE * NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!data_buf) {
+		printk(KERN_ERR "%s: failed to allocate data_buf\n", __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+	oob_buf = kzalloc(NAND_MAX_OOBSIZE * NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!oob_buf) {
+		printk(KERN_ERR "%s: failed to allocate oob_buf\n", __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+
+out:
+	return err;
+}
+
+static void mxc_free_buf(void)
+{
+	kfree(data_buf);
+	kfree(oob_buf);
+}
+
+int nand_scan_mid(struct mtd_info *mtd)
+{
+	int i;
+	uint8_t id_bytes[NAND_DEVICE_ID_BYTE_COUNT];
+	struct nand_chip *this = mtd->priv;
+	struct nand_device_info  *dev_info;
+
+	if (!IS_LARGE_PAGE_NAND)
+		return 0;
+
+	/* Read ID bytes from the first NAND Flash chip. */
+	this->select_chip(mtd, 0);
+
+	this->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	for (i = 0; i < NAND_DEVICE_ID_BYTE_COUNT; i++)
+		id_bytes[i] = this->read_byte(mtd);
+
+	/* Get information about this device, based on the ID bytes. */
+	dev_info = nand_device_get_info(id_bytes);
+
+	/* Check if we understand this device. */
+	if (!dev_info) {
+		printk(KERN_ERR "Unrecognized NAND Flash device.\n");
+		return !0;
+	}
+
+	/* Correct mtd setting */
+	this->chipsize = dev_info->chip_size_in_bytes;
+	mtd->size = dev_info->chip_size_in_bytes * this->numchips;
+	mtd->writesize = dev_info->page_total_size_in_bytes & ~0x3ff;
+	mtd->oobsize = dev_info->page_total_size_in_bytes & 0x3ff;
+	mtd->erasesize = dev_info->block_size_in_pages * mtd->writesize;
+
+	/* limit to 2G size due to Kernel
+	 * larger 4G space support,need fix
+	 * it later
+	 */
+	if ((u32)mtd->size == 0) {
+		mtd->size = (u32)(1 << 31);
+		this->numchips = 1;
+		this->chipsize = mtd->size;
+	}
+
+	/* Calculate the address shift from the page size */
+	this->page_shift = ffs(mtd->writesize) - 1;
+	/* Convert chipsize to number of pages per chip -1. */
+	this->pagemask = (this->chipsize >> this->page_shift) - 1;
+
+	this->bbt_erase_shift = this->phys_erase_shift =
+		ffs(mtd->erasesize) - 1;
+	this->chip_shift = ffs(this->chipsize) - 1;
+
+	return 0;
+}
+
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and
+ *                remove functions
+ *
+ * @return  The function always returns 0.
+ */
+static int __init mxcnd_probe(struct platform_device *pdev)
+{
+	struct nand_chip *this;
+	struct mtd_info *mtd;
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	int nr_parts = 0, err = 0;
+
+	nfc_axi_base = IO_ADDRESS(NFC_AXI_BASE_ADDR);
+	nfc_ip_base = IO_ADDRESS(NFC_BASE_ADDR);
+
+	/* init the nfc */
+	mxc_nfc_init();
+
+	/* init data buf */
+	if (mxc_alloc_buf())
+		goto out;
+
+	/* Allocate memory for MTD device structure and private data */
+	mxc_nand_data = kzalloc(sizeof(struct mxc_mtd_s), GFP_KERNEL);
+	if (!mxc_nand_data) {
+		printk(KERN_ERR "%s: failed to allocate mtd_info\n",
+		       __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+
+	memset((char *)&g_nandfc_info, 0, sizeof(g_nandfc_info));
+
+	mxc_nand_data->dev = &pdev->dev;
+	/* structures must be linked */
+	this = &mxc_nand_data->nand;
+	mtd = &mxc_nand_data->mtd;
+	mtd->priv = this;
+	mtd->owner = THIS_MODULE;
+
+	this->priv = mxc_nand_data;
+	this->cmdfunc = mxc_nand_command;
+	this->select_chip = mxc_nand_select_chip;
+	this->read_byte = mxc_nand_read_byte;
+	this->read_word = mxc_nand_read_word;
+	this->write_buf = mxc_nand_write_buf;
+	this->read_buf = mxc_nand_read_buf;
+	this->verify_buf = mxc_nand_verify_buf;
+	this->scan_bbt = mxc_nand_scan_bbt;
+
+	this->options |= NAND_OWN_BUFFERS;
+	this->buffers = kzalloc((NAND_MAX_OOBSIZE * 3 + NAND_MAX_PAGESIZE) * \
+				NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!this->buffers)
+		goto out_1;
+
+	/* NAND bus width determines access funtions used by upper layer */
+	if (flash->width == 2) {
+		this->read_byte = mxc_nand_read_byte16;
+		this->options |= NAND_BUSWIDTH_16;
+		NFC_SET_NFMS(1 << NFMS_NF_DWIDTH);
+	} else {
+		NFC_SET_NFMS(0);
+	}
+
+	nfc_clk = clk_get(&pdev->dev, "nfc_clk");
+	clk_enable(nfc_clk);
+
+	init_waitqueue_head(&irq_waitq);
+	err = request_irq(MXC_INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
+	if (err)
+		goto out_2;
+
+	if (hardware_ecc) {
+		this->ecc.read_page = mxc_nand_read_page;
+		this->ecc.write_page = mxc_nand_write_page;
+		this->ecc.read_oob = mxc_nand_read_oob;
+		this->ecc.layout = &nand_hw_eccoob_512;
+		this->ecc.calculate = mxc_nand_calculate_ecc;
+		this->ecc.hwctl = mxc_nand_enable_hwecc;
+		this->ecc.correct = mxc_nand_correct_data;
+		this->ecc.mode = NAND_ECC_HW;
+		this->ecc.size = 512;
+		this->ecc.bytes = 9;
+		raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN),
+			  REG_NFC_ECC_EN);
+	} else {
+		this->ecc.mode = NAND_ECC_SOFT;
+		raw_write((raw_read(REG_NFC_ECC_EN) & ~NFC_ECC_EN),
+			  REG_NFC_ECC_EN);
+	}
+
+	/* config the gpio */
+	if (flash->init)
+		flash->init();
+
+	/* Reset NAND */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Scan to find existence of the device */
+	if (nand_scan_ident(mtd, NFC_GET_MAXCHIP_SP())
+		|| nand_scan_mid(mtd)
+		|| nand_scan_tail(mtd)) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "MXC_ND2: Unable to find any NAND device.\n");
+		err = -ENXIO;
+		goto out_2;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts =
+	    parse_mtd_partitions(mtd, part_probes, &mxc_nand_data->parts, 0);
+	if (nr_parts > 0)
+		add_mtd_partitions(mtd, mxc_nand_data->parts, nr_parts);
+	else if (flash->parts)
+		add_mtd_partitions(mtd, flash->parts, flash->nr_parts);
+	else
+#endif
+	{
+		pr_info("Registering %s as whole device\n", mtd->name);
+		add_mtd_device(mtd);
+	}
+
+	platform_set_drvdata(pdev, mtd);
+
+	return 0;
+out_2:
+	kfree(this->buffers);
+out_1:
+	kfree(mxc_nand_data);
+out:
+	return err;
+
+}
+
+ /*!
+  * Dissociates the driver from the device.
+  *
+  * @param   pdev  the device structure used to give information on which
+  *
+  * @return  The function always returns 0.
+  */
+
+static int __exit mxcnd_remove(struct platform_device *pdev)
+{
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+
+	if (flash->exit)
+		flash->exit();
+
+	mxc_free_buf();
+
+	clk_disable(nfc_clk);
+	clk_put(nfc_clk);
+	platform_set_drvdata(pdev, NULL);
+
+	if (mxc_nand_data) {
+		nand_release(mtd);
+		free_irq(MXC_INT_NANDFC, NULL);
+		kfree(mxc_nand_data);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * This function is called to put the NAND in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+
+static int mxcnd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND suspend\n");
+
+	/* Disable the NFC clock */
+	if (clk_get_usecount(nfc_clk) > 0)
+		clk_disable(nfc_clk);
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the NAND back from a low power state. Refer
+ * to the document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxcnd_resume(struct platform_device *pdev)
+{
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND resume\n");
+
+	/* Enable the NFC clock */
+	clk_enable(nfc_clk);
+
+	return 0;
+}
+
+#else
+#define mxcnd_suspend   NULL
+#define mxcnd_resume    NULL
+#endif				/* CONFIG_PM */
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcnd_driver = {
+	.driver = {
+		   .name = "mxc_nandv2_flash",
+		   },
+	.probe = mxcnd_probe,
+	.remove = __exit_p(mxcnd_remove),
+	.suspend = mxcnd_suspend,
+	.resume = mxcnd_resume,
+};
+
+/*!
+ * Main initialization routine
+ * @return  0 if successful; non-zero otherwise
+ */
+static int __init mxc_nd_init(void)
+{
+	/* Register the device driver structure. */
+	pr_info("MXC MTD nand Driver %s\n", DVR_VER);
+	if (platform_driver_register(&mxcnd_driver) != 0) {
+		printk(KERN_ERR "Driver register failed for mxcnd_driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/*!
+ * Clean up routine
+ */
+static void __exit mxc_nd_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxcnd_driver);
+}
+
+module_init(mxc_nd_init);
+module_exit(mxc_nd_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC NAND MTD driver Version 2-5");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/mxc_nd2.h b/drivers/mtd/nand/mxc_nd2.h
new file mode 100644
index 0000000..5f8e6f9
--- /dev/null
+++ b/drivers/mtd/nand/mxc_nd2.h
@@ -0,0 +1,701 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_nd2.h
+ *
+ * @brief This file contains the NAND Flash Controller register information.
+ *
+ *
+ * @ingroup NAND_MTD
+ */
+
+#ifndef __MXC_ND2_H__
+#define __MXC_ND2_H__
+
+#include <mach/hardware.h>
+
+#define IS_2K_PAGE_NAND         ((mtd->writesize / num_of_interleave) \
+						== NAND_PAGESIZE_2KB)
+#define IS_4K_PAGE_NAND         ((mtd->writesize / num_of_interleave) \
+						== NAND_PAGESIZE_4KB)
+#define IS_LARGE_PAGE_NAND      ((mtd->writesize / num_of_interleave) > 512)
+
+#define GET_NAND_OOB_SIZE	(mtd->oobsize / num_of_interleave)
+
+#define NAND_PAGESIZE_2KB	2048
+#define NAND_PAGESIZE_4KB	4096
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3
+/*
+ * For V3 NFC registers Definition
+ */
+/* AXI Bus Mapped */
+#define NFC_AXI_BASE_ADDR		NFC_BASE_ADDR_AXI
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1)	/* mx37 */
+#define MXC_INT_NANDFC			MXC_INT_EMI
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0x1E00)
+#define NFC_CONFIG1			(nfc_axi_base + 0x1E04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0x1E08)
+#define LAUNCH_NFC			(nfc_axi_base + 0x1E0c)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
+#define NFC_IPC				(nfc_ip_base + 0x18)
+#elif defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define MXC_INT_NANDFC			MXC_INT_NFC
+#define NFC_AUTO_MODE_ENABLE
+#define NFC_FLASH_CMD			(nfc_axi_base + 0x1E00)
+#define NFC_FLASH_ADDR0			(nfc_axi_base + 0x1E04)
+#define NFC_FLASH_ADDR8			(nfc_axi_base + 0x1E24)
+#define NFC_CONFIG1			(nfc_axi_base + 0x1E34)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0x1E38)
+#define NFC_ECC_STATUS_SUM		(nfc_axi_base + 0x1E3C)
+#define LAUNCH_NFC			(nfc_axi_base + 0x1E40)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x24)
+#define NFC_CONFIG3			(nfc_ip_base + 0x28)
+#define NFC_IPC				(nfc_ip_base + 0x2C)
+#define NFC_DELAY_LINE			(nfc_ip_base + 0x34)
+#else				/* skye */
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0xE00)
+#define NFC_CONFIG1			(nfc_axi_base + 0xE04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0xE08)
+#define LAUNCH_NFC			(nfc_axi_base + 0xE0C)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
+#define NFC_IPC				(nfc_ip_base + 0x18)
+#endif
+/*!
+ * Addresses for NFC RAM BUFFER Main area 0
+ */
+#define MAIN_AREA0	((u16 *)(nfc_axi_base + 0x000))
+#define MAIN_AREA1	((u16 *)(nfc_axi_base + 0x200))
+
+/*!
+ * Addresses for NFC SPARE BUFFER Spare area 0
+ */
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define SPARE_AREA0			((u16 *)(nfc_axi_base + 0x1000))
+#define SPARE_LEN			64
+#define SPARE_COUNT			8
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#else
+#define SPARE_AREA0			((u16 *)(nfc_axi_base + 0x800))
+#define SPARE_LEN			16
+#define SPARE_COUNT			4
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#endif
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_SPAS_WIDTH 8
+#define NFC_SPAS_SHIFT 16
+
+#define IS_4BIT_ECC \
+( \
+	cpu_is_mx51_rev(CHIP_REV_2_0) > 0 ? \
+		!((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6) : \
+		((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6) \
+)
+
+#define NFC_SET_SPAS(v)			\
+	raw_write((((raw_read(NFC_CONFIG2) & \
+	NFC_FIELD_RESET(NFC_SPAS_WIDTH, NFC_SPAS_SHIFT)) | ((v) << 16))), \
+	NFC_CONFIG2)
+
+#define NFC_SET_ECC_MODE(v)		\
+do { \
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) { \
+		if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112) \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) | \
+					NFC_ECC_MODE_4), NFC_CONFIG2); \
+		else \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) & \
+					NFC_ECC_MODE_8), NFC_CONFIG2); \
+	} else { \
+		if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112) \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) & \
+					NFC_ECC_MODE_8), NFC_CONFIG2); \
+		else \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) | \
+					NFC_ECC_MODE_4), NFC_CONFIG2); \
+	} \
+} while (0)
+
+#define WRITE_NFC_IP_REG(val, reg)			\
+	do {						\
+		raw_write(NFC_IPC_CREQ, NFC_IPC);	\
+		while (!((raw_read(NFC_IPC) & NFC_IPC_ACK) >> 1)) \
+		;					\
+		raw_write(val, reg);			\
+		raw_write(0, NFC_IPC);			\
+	} while (0)
+
+#else
+#define IS_4BIT_ECC			1
+#define NFC_SET_SPAS(v)
+#define NFC_SET_ECC_MODE(v)
+#define NFC_SET_NFMS(v)	(NFMS |= (v))
+
+#define WRITE_NFC_IP_REG(val , reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  \
+	REG_NFC_OPS_STAT)
+#endif
+
+#define GET_NFC_ECC_STATUS() raw_read(REG_NFC_ECC_STATUS_RESULT);
+
+/*!
+ * Set 1 to specific operation bit, rest to 0 in LAUNCH_NFC Register for
+ * Specific operation
+ */
+#define NFC_CMD				0x1
+#define NFC_ADDR			0x2
+#define NFC_INPUT			0x4
+#define NFC_OUTPUT			0x8
+#define NFC_ID				0x10
+#define NFC_STATUS			0x20
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_AUTO_PROG			0x40
+#define NFC_AUTO_READ			0x80
+#define NFC_AUTO_ERASE			0x200
+#define NFC_COPY_BACK_0			0x400
+#define NFC_COPY_BACK_1			0x800
+#define NFC_AUTO_STATE			0x1000
+#endif
+
+/* Bit Definitions for NFC_IPC*/
+#define NFC_OPS_STAT			(1 << 31)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_OP_DONE			(1 << 30)
+#define NFC_RB				(1 << 28)
+#define NFC_PS_WIDTH			2
+#define NFC_PS_SHIFT			0
+#define NFC_PS_512			0
+#define NFC_PS_2K			1
+#define NFC_PS_4K			2
+#else
+#define NFC_RB				(1 << 29)
+#endif
+
+#define NFC_ONE_CYCLE			(1 << 2)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_INT_MSK			(1 << 15)
+#define NFC_AUTO_PROG_DONE_MSK		(1 << 14)
+#define NFC_NUM_ADDR_PHASE1_WIDTH	2
+#define NFC_NUM_ADDR_PHASE1_SHIFT	12
+
+#define NFC_NUM_ADDR_PHASE0_WIDTH	1
+#define NFC_NUM_ADDR_PHASE0_SHIFT	5
+
+#define NFC_ONE_LESS_PHASE1		0
+#define NFC_TWO_LESS_PHASE1		1
+
+#define NFC_FLASH_ADDR_SHIFT		0
+#else
+#define NFC_INT_MSK			(1 << 4)
+#define NFC_BIG				(1 << 5)
+#define NFC_FLASH_ADDR_SHIFT		16
+#endif
+
+#define NFC_UNLOCK_END_ADDR_SHIFT	16
+
+/* Bit definition for NFC_CONFIGRATION_1 */
+#define NFC_SP_EN			(1 << 0)
+#define NFC_CE				(1 << 1)
+#define NFC_RST				(1 << 2)
+#define NFC_ECC_EN			(1 << 3)
+
+#define NFC_FIELD_RESET(width, shift) (~(((1 << (width)) - 1) << (shift)))
+
+#define NFC_RBA_SHIFT		4
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define NFC_RBA_WIDTH			3
+#else
+#define NFC_RBA_WIDTH			2
+#endif
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define NFC_ITERATION_SHIFT 8
+#define NFC_ITERATION_WIDTH 4
+#define NFC_ACTIVE_CS_SHIFT 12
+#define NFC_ACTIVE_CS_WIDTH 3
+/* bit definition for CONFIGRATION3 */
+#define NFC_NO_SDMA			(1 << 20)
+#define NFC_FMP_SHIFT			16
+#define NFC_FMP_WIDTH			4
+#define NFC_RBB_MODE			(1 << 15)
+#define NFC_NUM_OF_DEVICES_SHIFT	12
+#define NFC_NUM_OF_DEVICES_WIDTH	4
+#define NFC_DMA_MODE_SHIFT		11
+#define NFC_DMA_MODE_WIDTH		1
+#define NFC_SBB_SHIFT			8
+#define NFC_SBB_WIDTH			3
+#define NFC_BIG				(1 << 7)
+#define NFC_SB2R_SHIFT			4
+#define NFC_SB2R_WIDTH			3
+#define NFC_FW_SHIFT			3
+#define NFC_FW_WIDTH			1
+#define NFC_TOO				(1 << 2)
+#define NFC_ADD_OP_SHIFT		0
+#define NFC_ADD_OP_WIDTH		2
+#define NFC_FW_8			1
+#define NFC_FW_16			0
+#define NFC_ST_CMD_SHITF		24
+#define NFC_ST_CMD_WIDTH		8
+#endif
+
+#define NFC_PPB_32			(0 << 7)
+#define NFC_PPB_64			(1 << 7)
+#define NFC_PPB_128			(2 << 7)
+#define NFC_PPB_256			(3 << 7)
+#define NFC_PPB_RESET			(~(3 << 7))
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_BLS_LOCKED			(0 << 6)
+#define NFC_BLS_LOCKED_DEFAULT		(1 << 6)
+#define NFC_BLS_UNLCOKED		(2 << 6)
+#define NFC_BLS_RESET			(~(3 << 6))
+#else
+#define NFC_BLS_LOCKED			(0 << 16)
+#define NFC_BLS_LOCKED_DEFAULT		(1 << 16)
+#define NFC_BLS_UNLCOKED		(2 << 16)
+#define NFC_BLS_RESET			(~(3 << 16))
+#endif
+
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
+#define NFC_WPC_RESET			(~(7))
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) || \
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_ECC_MODE_4			(1 << 6)
+#define NFC_ECC_MODE_8			(~(1 << 6))
+#define NFC_ECC_MODE_MASK		(~(1 << 6))
+#define NFC_SPAS_16			8
+#define NFC_SPAS_64			32
+#define NFC_SPAS_128			64
+#define NFC_SPAS_112			56
+#define NFC_SPAS_218			109
+#define NFC_IPC_CREQ			(1 << 0)
+#define NFC_IPC_ACK			(1 << 1)
+#endif
+
+#define REG_NFC_OPS_STAT		NFC_IPC
+#define REG_NFC_INTRRUPT		NFC_CONFIG2
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR0
+#define REG_NFC_FLASH_CMD		NFC_FLASH_CMD
+#else
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR_CMD
+#define REG_NFC_FLASH_CMD		NFC_FLASH_ADDR_CMD
+#endif
+#define REG_NFC_OPS			LAUNCH_NFC
+#define REG_NFC_SET_RBA			NFC_CONFIG1
+#define REG_NFC_RB			NFC_IPC
+#define REG_NFC_ECC_EN			NFC_CONFIG2
+#define REG_NFC_ECC_STATUS_RESULT	NFC_ECC_STATUS_RESULT
+#define REG_NFC_CE			NFC_CONFIG1
+#define REG_NFC_RST			NFC_CONFIG1
+#define REG_NFC_PPB			NFC_CONFIG2
+#define REG_NFC_SP_EN			NFC_CONFIG1
+#define REG_NFC_BLS			NFC_WRPROT
+#define REG_UNLOCK_BLK_ADD0		NFC_WRPROT_UNLOCK_BLK_ADD0
+#define REG_UNLOCK_BLK_ADD1		NFC_WRPROT_UNLOCK_BLK_ADD1
+#define REG_UNLOCK_BLK_ADD2		NFC_WRPROT_UNLOCK_BLK_ADD2
+#define REG_UNLOCK_BLK_ADD3		NFC_WRPROT_UNLOCK_BLK_ADD3
+#define REG_NFC_WPC			NFC_WRPROT
+#define REG_NFC_ONE_CYCLE		NFC_CONFIG2
+
+/* NFC V3 Specific MACRO functions definitions */
+#define raw_write(v, a)		__raw_writel(v, a)
+#define raw_read(a)		__raw_readl(a)
+
+/* Explcit ack ops status (if any), before issue of any command  */
+#define ACK_OPS	\
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT), \
+	REG_NFC_OPS_STAT);
+
+/* Set RBA buffer id*/
+#define NFC_SET_RBA(val)       \
+	raw_write((raw_read(REG_NFC_SET_RBA) & \
+	(NFC_FIELD_RESET(NFC_RBA_WIDTH, NFC_RBA_SHIFT))) | \
+	((val) << NFC_RBA_SHIFT), REG_NFC_SET_RBA);
+
+#define NFC_SET_PS(val)       \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_PS_WIDTH, NFC_PS_SHIFT))) | \
+	((val) << NFC_PS_SHIFT), NFC_CONFIG2);
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2
+#define UNLOCK_ADDR(start_addr, end_addr)     \
+{ \
+	int i = 0; \
+	for (; i < NAND_MAX_CHIPS; i++)  \
+		raw_write(start_addr |		 \
+			  (end_addr << NFC_UNLOCK_END_ADDR_SHIFT),	\
+			  REG_UNLOCK_BLK_ADD0 + (i << 2));		\
+}
+#define NFC_SET_NFC_ACTIVE_CS(val) \
+	raw_write((raw_read(NFC_CONFIG1) & \
+	(NFC_FIELD_RESET(NFC_ACTIVE_CS_WIDTH, NFC_ACTIVE_CS_SHIFT))) | \
+	((val) << NFC_ACTIVE_CS_SHIFT), NFC_CONFIG1);
+
+#define NFC_GET_MAXCHIP_SP()		8
+
+#else
+#define UNLOCK_ADDR(start_addr, end_addr)     \
+	raw_write(start_addr | \
+	(end_addr << NFC_UNLOCK_END_ADDR_SHIFT), REG_UNLOCK_BLK_ADD0);
+
+#define NFC_SET_NFC_ACTIVE_CS(val)
+#define NFC_GET_MAXCHIP_SP()		1
+#endif
+
+#define NFC_SET_BLS(val) ((raw_read(REG_NFC_BLS) & NFC_BLS_RESET) | val)
+#define NFC_SET_WPC(val) ((raw_read(REG_NFC_WPC) & NFC_WPC_RESET) | val)
+#define CHECK_NFC_RB    (raw_read(REG_NFC_RB) & NFC_RB)
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_SET_NFC_NUM_ADDR_PHASE1(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_NUM_ADDR_PHASE1_WIDTH, \
+	NFC_NUM_ADDR_PHASE1_SHIFT))) | \
+	((val) << NFC_NUM_ADDR_PHASE1_SHIFT), NFC_CONFIG2);
+
+#define NFC_SET_NFC_NUM_ADDR_PHASE0(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_NUM_ADDR_PHASE0_WIDTH, \
+	NFC_NUM_ADDR_PHASE0_SHIFT))) | \
+	((val) << NFC_NUM_ADDR_PHASE0_SHIFT), NFC_CONFIG2);
+
+#define NFC_SET_NFC_ITERATION(val) \
+	raw_write((raw_read(NFC_CONFIG1) & \
+	(NFC_FIELD_RESET(NFC_ITERATION_WIDTH, NFC_ITERATION_SHIFT))) | \
+	((val) << NFC_ITERATION_SHIFT), NFC_CONFIG1);
+
+#define NFC_SET_FW(val) \
+	raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_FW_WIDTH, NFC_FW_SHIFT))) | \
+	((val) << NFC_FW_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_NUM_OF_DEVICE(val) \
+	raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_NUM_OF_DEVICES_WIDTH, \
+	NFC_NUM_OF_DEVICES_SHIFT))) | \
+	((val) << NFC_NUM_OF_DEVICES_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_ADD_OP_MODE(val) \
+	 raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_ADD_OP_WIDTH, NFC_ADD_OP_SHIFT))) | \
+	((val) << NFC_ADD_OP_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_ADD_CS_MODE(val) \
+{ \
+	NFC_SET_ADD_OP_MODE(val); \
+	NFC_SET_NUM_OF_DEVICE(this->numchips - 1); \
+}
+
+#define NFC_SET_ST_CMD(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_ST_CMD_WIDTH, \
+	NFC_ST_CMD_SHITF))) | \
+	((val) << NFC_ST_CMD_SHITF), NFC_CONFIG2);
+
+#define NFMS_NF_DWIDTH 0
+#define NFMS_NF_PG_SZ  1
+#define NFC_CMD_1_SHIFT 8
+
+#define NUM_OF_ADDR_CYCLE (fls(g_page_mask) >> 3)
+#define SET_NFC_DELAY_LINE(val) raw_write((val), NFC_DELAY_LINE)
+
+/*should set the fw,ps,spas,ppb*/
+#define NFC_SET_NFMS(v)	\
+do {	\
+	if (!(v)) \
+		NFC_SET_FW(NFC_FW_8);	\
+	if (((v) & (1 << NFMS_NF_DWIDTH)))	\
+		NFC_SET_FW(NFC_FW_16);	\
+	if (((v) & (1 << NFMS_NF_PG_SZ))) {	\
+		if (IS_2K_PAGE_NAND) {	\
+			NFC_SET_PS(NFC_PS_2K);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_TWO_LESS_PHASE1); \
+		} else if (IS_4K_PAGE_NAND) {       \
+			NFC_SET_PS(NFC_PS_4K);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_TWO_LESS_PHASE1); \
+		} else {	\
+			NFC_SET_PS(NFC_PS_512);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE - 1); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_ONE_LESS_PHASE1); \
+		}	\
+		NFC_SET_ADD_CS_MODE(1); \
+		NFC_SET_SPAS(GET_NAND_OOB_SIZE >> 1);	\
+		NFC_SET_ECC_MODE(GET_NAND_OOB_SIZE >> 1); \
+		NFC_SET_ST_CMD(0x70); \
+		raw_write(raw_read(NFC_CONFIG3) | NFC_NO_SDMA, NFC_CONFIG3); \
+		raw_write(raw_read(NFC_CONFIG3) | NFC_RBB_MODE, NFC_CONFIG3); \
+		SET_NFC_DELAY_LINE(0); \
+	} \
+} while (0)
+#endif
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define NFC_SET_NFMS(v)
+#endif
+
+#define READ_PAGE()	send_read_page(0)
+#define PROG_PAGE()	send_prog_page(0)
+
+#elif CONFIG_ARCH_MXC_HAS_NFC_V2
+
+/*
+ * For V1/V2 NFC registers Definition
+ */
+
+#define NFC_AXI_BASE_ADDR	0x00
+/*
+ * Addresses for NFC registers
+ */
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_REG_BASE			(nfc_ip_base + 0x1000)
+#else
+#define NFC_REG_BASE			nfc_ip_base
+#endif
+#define NFC_BUF_SIZE			(NFC_REG_BASE + 0xE00)
+#define NFC_BUF_ADDR			(NFC_REG_BASE + 0xE04)
+#define NFC_FLASH_ADDR			(NFC_REG_BASE + 0xE06)
+#define NFC_FLASH_CMD			(NFC_REG_BASE + 0xE08)
+#define NFC_CONFIG			(NFC_REG_BASE + 0xE0A)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_ECC_STATUS_RESULT		(NFC_REG_BASE + 0xE0C)
+#define NFC_ECC_STATUS_RESULT_1		(NFC_REG_BASE + 0xE0C)
+#define NFC_ECC_STATUS_RESULT_2		(NFC_REG_BASE + 0xE0E)
+#define NFC_SPAS			(NFC_REG_BASE + 0xE10)
+#else
+#define NFC_ECC_STATUS_RESULT		(NFC_REG_BASE + 0xE0C)
+#define NFC_RSLTMAIN_AREA		(NFC_REG_BASE + 0xE0E)
+#define NFC_RSLTSPARE_AREA		(NFC_REG_BASE + 0xE10)
+#endif
+#define NFC_WRPROT			(NFC_REG_BASE + 0xE12)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_UNLOCKSTART_BLKADDR		(NFC_REG_BASE + 0xE20)
+#define NFC_UNLOCKEND_BLKADDR		(NFC_REG_BASE + 0xE22)
+#define NFC_UNLOCKSTART_BLKADDR1	(NFC_REG_BASE + 0xE24)
+#define NFC_UNLOCKEND_BLKADDR1		(NFC_REG_BASE + 0xE26)
+#define NFC_UNLOCKSTART_BLKADDR2	(NFC_REG_BASE + 0xE28)
+#define NFC_UNLOCKEND_BLKADDR2		(NFC_REG_BASE + 0xE2A)
+#define NFC_UNLOCKSTART_BLKADDR3	(NFC_REG_BASE + 0xE2C)
+#define NFC_UNLOCKEND_BLKADDR3		(NFC_REG_BASE + 0xE2E)
+#else
+#define NFC_UNLOCKSTART_BLKADDR		(NFC_REG_BASE + 0xE14)
+#define NFC_UNLOCKEND_BLKADDR		(NFC_REG_BASE + 0xE16)
+#endif
+#define NFC_NF_WRPRST			(NFC_REG_BASE + 0xE18)
+#define NFC_CONFIG1			(NFC_REG_BASE + 0xE1A)
+#define NFC_CONFIG2			(NFC_REG_BASE + 0xE1C)
+
+/*!
+ * Addresses for NFC RAM BUFFER Main area 0
+ */
+#define MAIN_AREA0		(u16 *)(nfc_ip_base + 0x000)
+#define MAIN_AREA1		(u16 *)(nfc_ip_base + 0x200)
+
+/*!
+ * Addresses for NFC SPARE BUFFER Spare area 0
+ */
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define SPARE_AREA0	(u16 *)(nfc_ip_base + 0x1000)
+#define SPARE_LEN	64
+#define SPARE_COUNT	8
+#else
+#define SPARE_AREA0	(u16 *)(nfc_ip_base + 0x800)
+#define SPARE_LEN	16
+#define SPARE_COUNT	4
+#endif
+#define SPARE_SIZE	(SPARE_LEN * SPARE_COUNT)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define REG_NFC_ECC_MODE NFC_CONFIG1
+#define SPAS_SHIFT	(0)
+#define REG_NFC_SPAS NFC_SPAS
+#define SPAS_MASK	(0xFF00)
+#define IS_4BIT_ECC			\
+	((raw_read(REG_NFC_ECC_MODE) & NFC_ECC_MODE_4) >> 0)
+
+#define NFC_SET_SPAS(v)			\
+	raw_write(((raw_read(REG_NFC_SPAS) & SPAS_MASK) | ((v<<SPAS_SHIFT))), \
+								REG_NFC_SPAS)
+
+#define NFC_SET_ECC_MODE(v)		 \
+do {	\
+	if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112)  {	\
+		raw_write((raw_read(REG_NFC_ECC_MODE) & NFC_ECC_MODE_8), \
+							REG_NFC_ECC_MODE); \
+	} else {	\
+		raw_write((raw_read(REG_NFC_ECC_MODE) | NFC_ECC_MODE_4), \
+							REG_NFC_ECC_MODE); \
+	}	\
+} while (0)
+
+#define GET_ECC_STATUS()  __raw_readl(REG_NFC_ECC_STATUS_RESULT);
+#define NFC_SET_NFMS(v) \
+do { \
+	if (((v) & (1 << NFMS_NF_PG_SZ))) { \
+		if (IS_2K_PAGE_NAND) { \
+			(NFMS |= 0x00000100); \
+			(NFMS &= ~0x00000200); \
+			NFC_SET_SPAS(NFC_SPAS_64); \
+		} else if (IS_4K_PAGE_NAND) { \
+			(NFMS &= ~0x00000100); \
+			(NFMS |= 0x00000200); \
+			GET_NAND_OOB_SIZE == 128 ? \
+			NFC_SET_SPAS(NFC_SPAS_128) : \
+			NFC_SET_SPAS(NFC_SPAS_218); \
+		} else { \
+			printk(KERN_ERR "Err for setting page/oob size"); \
+		} \
+		NFC_SET_ECC_MODE(GET_NAND_OOB_SIZE >> 1); \
+	} \
+} while (0)
+#else
+#define IS_4BIT_ECC			(1)
+#define NFC_SET_SPAS(v)
+#define NFC_SET_ECC_MODE(v)
+#define GET_ECC_STATUS()  raw_read(REG_NFC_ECC_STATUS_RESULT);
+#define NFC_SET_NFMS(v)     (NFMS |= (v))
+#endif
+
+#define WRITE_NFC_IP_REG(val, reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  \
+	REG_NFC_OPS_STAT)
+
+#define GET_NFC_ECC_STATUS() raw_read(REG_NFC_ECC_STATUS_RESULT);
+
+/*!
+ * Set INT to 0, Set 1 to specific operation bit,
+ * rest to 0 in LAUNCH_NFC Register for
+ * Specific operation
+ */
+#define NFC_CMD		0x1
+#define NFC_ADDR	0x2
+#define NFC_INPUT	0x4
+#define NFC_OUTPUT	0x8
+#define NFC_ID		0x10
+#define NFC_STATUS	0x20
+
+/* Bit Definitions */
+#define NFC_OPS_STAT		(1 << 15)
+#define NFC_SP_EN		(1 << 2)
+#define NFC_ECC_EN		(1 << 3)
+#define NFC_INT_MSK		(1 << 4)
+#define NFC_BIG			(1 << 5)
+#define NFC_RST			(1 << 6)
+#define NFC_CE			(1 << 7)
+#define NFC_ONE_CYCLE		(1 << 8)
+#define NFC_BLS_LOCKED		0
+#define NFC_BLS_LOCKED_DEFAULT		1
+#define NFC_BLS_UNLCOKED		2
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
+#define NFC_FLASH_ADDR_SHIFT		0
+#define NFC_UNLOCK_END_ADDR_SHIFT	0
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_ECC_MODE_4		(1<<0)
+#define NFC_ECC_MODE_8		(~(1<<0))
+#define NFC_SPAS_16		 8
+#define NFC_SPAS_64		 32
+#define NFC_SPAS_112		 56
+#define NFC_SPAS_128		 64
+#define NFC_SPAS_218		 109
+#endif
+/* NFC Register Mapping */
+#define REG_NFC_OPS_STAT		NFC_CONFIG2
+#define REG_NFC_INTRRUPT		NFC_CONFIG1
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR
+#define REG_NFC_FLASH_CMD		NFC_FLASH_CMD
+#define REG_NFC_OPS			NFC_CONFIG2
+#define REG_NFC_SET_RBA			NFC_BUF_ADDR
+#define REG_NFC_ECC_EN			NFC_CONFIG1
+#define REG_NFC_ECC_STATUS_RESULT	NFC_ECC_STATUS_RESULT
+#define REG_NFC_CE			NFC_CONFIG1
+#define REG_NFC_SP_EN			NFC_CONFIG1
+#define REG_NFC_BLS			NFC_CONFIG
+#define REG_NFC_WPC			NFC_WRPROT
+#define REG_START_BLKADDR		NFC_UNLOCKSTART_BLKADDR
+#define REG_END_BLKADDR			NFC_UNLOCKEND_BLKADDR
+#define REG_NFC_RST			NFC_CONFIG1
+#define REG_NFC_ONE_CYCLE		NFC_CONFIG1
+
+/* NFC V1/V2 Specific MACRO functions definitions */
+
+#define raw_write(v, a)                  __raw_writew(v, a)
+#define raw_read(a)                     __raw_readw(a)
+
+#define NFC_SET_BLS(val)		val
+
+#define UNLOCK_ADDR(start_addr, end_addr)		\
+{							\
+	raw_write(start_addr, REG_START_BLKADDR);	\
+	raw_write(end_addr, REG_END_BLKADDR);		\
+}
+
+#define NFC_SET_NFC_ACTIVE_CS(val)
+#define NFC_GET_MAXCHIP_SP()		1
+#define NFC_SET_WPC(val)                val
+
+/* NULL Definitions */
+#define ACK_OPS
+#define NFC_SET_RBA(val) raw_write(val, REG_NFC_SET_RBA);
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define READ_PAGE()	send_read_page(0)
+#define PROG_PAGE()	send_prog_page(0)
+#else
+#define READ_PAGE()   \
+do {                     \
+	send_read_page(0);  \
+	send_read_page(1);  \
+	send_read_page(2);  \
+	send_read_page(3);  \
+} while (0)
+
+#define PROG_PAGE()   \
+do {                     \
+	send_prog_page(0);  \
+	send_prog_page(1);  \
+	send_prog_page(2);  \
+	send_prog_page(3);  \
+} while (0)
+#endif
+#define CHECK_NFC_RB            1
+
+#endif
+
+#endif				/* __MXC_ND2_H__ */
diff --git a/drivers/mtd/nand/nand_device_info.c b/drivers/mtd/nand/nand_device_info.c
new file mode 100644
index 0000000..c4e105a
--- /dev/null
+++ b/drivers/mtd/nand/nand_device_info.c
@@ -0,0 +1,2286 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <asm/sizes.h>
+#include <linux/mtd/nand.h>
+
+#include "nand_device_info.h"
+
+/*
+ * Type 2
+ */
+static struct nand_device_info nand_device_info_table_type_2[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND01GW3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F1F08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG0S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND02GW3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UF082G2M, HY27UG082G2M, HY27UG082G1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F2G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F2G08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG1S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 10,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UH084G2M, HY27UG084G2M, HY27UH084G1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG2S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UH088G2M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND08GW3BxANx",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F8G08FABWG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{true}
+};
+
+/*
+ * Large MLC
+ */
+static struct nand_device_info nand_device_info_table_large_mlc[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG1D4BFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG3D4xFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG4D4xFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG2D4BFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9G4G08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 50,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UT084G2M, HY27UU088G5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 40,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 30,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND04GW3C2AN1E",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9G8G08U0M, K9HAG08U1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 60,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 50,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UV08AG5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"Intel JS29F08G08AAMiB1 and Micron MT29F8G08MAA; "
+	"Intel JS29F08G08CAMiB1 and Micron MT29F16G08QAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LAG08U0M K9HBG08U1M K9GAG08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"Intel JS29F32G08FAMiB1 and Micron MT29F32G08TAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F08G08AAMiB2, JS29F08G08CAMiB2",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F32G08FAMiB2",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UW08CGFM",
+	},
+	{true}
+};
+
+/*
+ * Type 7
+ */
+static struct nand_device_info nand_device_info_table_type_7[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F8G08FABWG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08AAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 35,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9K8G08UXM, K9NBG08U5A, K9WAG08U1A",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9WAG08UXM",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F2G08U0A",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F1F08",
+	},
+	{true}
+};
+
+/*
+ * Type 8
+ */
+static struct nand_device_info nand_device_info_table_type_8[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9GAG08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LBG08U0M (32Gb), K9HCG08U1M (64Gb), K9MDG08U5M (128Gb)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 0,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"H27UAG, H27UBG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 23,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 0,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"H27UCG",
+	},
+	{true}
+};
+
+/*
+ * Type 9
+ */
+static struct nand_device_info nand_device_info_table_type_9[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG3D1DTG00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG4D1DTG00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG6D1DTG20",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F16G08AAMC1, JS29F32G08CAMC1",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F16G08MAA, MT29F32G08QAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F64G08TAA (32Gb), MT29F32G08CBAAA (32Gb) MT29F64G08CFAAA (64Gb)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd9,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F128G08CJAAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JSF64G08FAMC1",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LBG08U0D",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9GAG08U0D, K9LBG08U1D, K9HCG08U5D",
+	},
+	{true}
+};
+
+/*
+ * Type 10
+ */
+static struct nand_device_info nand_device_info_table_type_10[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 30,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9NCG08U5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{true}
+};
+
+/*
+ * Type 11
+ */
+static struct nand_device_info nand_device_info_table_type_11[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 376,
+	.ecc_strength_in_bits     = 14,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 8,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 25,
+	"TC58NVG5D2ELAM8 (4GB), TH58NVG6D2ELAM8 (8GB)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xde,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 376,
+	.ecc_strength_in_bits     = 14,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 8,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 25,
+	"TH58NVG7D2ELAM8",
+	},
+	{true}
+};
+
+/*
+ * Type 15
+ */
+static struct nand_device_info nand_device_info_table_type_15[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 436,
+	.ecc_strength_in_bits     = 16,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 25,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"K9GBG08U0M (4GB, 1CE); K9LCG08U1M (8GB, 2CE); K9HDG08U5M (16GB, 4CE)",
+	},
+	{true}
+};
+
+/*
+ * BCH ECC12
+ */
+static struct nand_device_info nand_device_info_table_bch_ecc12[] __initdata = {
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"H27UBG8T2M (4GB, 1CE), H27UCG8UDM (8GB, 2CE), H27UDG8VEM (16GB, 4CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xde,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"H27UEG8YEM (32GB, 4CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 16,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F32G08CBAAA (4GB, 1CE), MT29F64G08CFAAA (8GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd9,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 16,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F128G08CJAAA (16GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x48,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F16G08CBABA (2GB, 1CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x68,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F32G08CBABA (4GB, 1CE); "
+	"MT29F64G08CEABA (8GB, 2CE); "
+	"MT29F64G08CFABA (8GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x88,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F128G08CJABA (16GB, 2CE); "
+	"MT29F128G08CKABA (16GB, 2CE); "
+	"MT29F256G08CUABA (32GB, 4CE)",
+	},
+	{true}
+};
+
+/*
+ * The following macros make it convenient to extract information from an ID
+ * byte array. All these macros begin with the prefix "ID_".
+ *
+ * Macros of the form:
+ *
+ *         ID_GET_[<manufacturer>_[<modifier>_]]<field>
+ *
+ * extract the given field from an ID byte array. Macros of the form:
+ *
+ *         ID_[<manufacturer>_[<modifier>_]]<field>_<meaning>
+ *
+ * contain the value for the given field that has the given meaning.
+ *
+ * If the <manufacturer> appears, it means this macro represents a view of this
+ * field that is specific to the given manufacturer.
+ *
+ * If the <modifier> appears, it means this macro represents a view of this
+ * field that the given manufacturer applies only under specific conditions.
+ *
+ * Here is a simple example:
+ *
+ *         ID_PAGE_SIZE_CODE_2K
+ *
+ * This macro has the value of the "Page Size" field that indicates the page
+ * size is 2K.
+ *
+ * A more complicated example:
+ *
+ *         ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K  (0x2)
+ *
+ * This macro has the value of the "Page Size" field for Samsung parts that
+ * indicates the page size is 8K. However, this interpretation is only correct
+ * for devices that return 6 ID bytes.
+ */
+
+/* Byte 1 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_1(id)    ((id)[0])
+
+#define ID_GET_MFR_CODE(id)  ID_GET_BYTE_1(id)
+
+/* Byte 2 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_2(id)                           ((id)[1])
+
+#define ID_GET_DEVICE_CODE(id)                      ID_GET_BYTE_2(id)
+    #define ID_SAMSUNG_DEVICE_CODE_1_GBIT           (0xf1)
+    #define ID_SAMSUNG_DEVICE_CODE_2_GBIT           (0xda)
+    #define ID_HYNIX_DEVICE_CODE_ECC12              (0xd7)
+    #define ID_HYNIX_DEVICE_CODE_ECC12_LARGE        (0xde)
+    #define ID_MICRON_DEVICE_CODE_ECC12             (0xd7) /* ECC12        */
+    #define ID_MICRON_DEVICE_CODE_ECC12_LARGE       (0xd9) /* ECC12 8GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE  (0x48) /* L63B  2GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE  (0x68) /* L63B  4GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE  (0x88) /* L63B  8GB/CE */
+
+/* Byte 3 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_3(id)               ((id)[2])
+
+#define ID_GET_DIE_COUNT_CODE(id)       ((ID_GET_BYTE_3(id) >> 0) & 0x3)
+
+#define ID_GET_CELL_TYPE_CODE(id)       ((ID_GET_BYTE_3(id) >> 2) & 0x3)
+    #define ID_CELL_TYPE_CODE_SLC       (0x0) /* All others => MLC. */
+
+#define ID_GET_SAMSUNG_SIMUL_PROG(id)   ((ID_GET_BYTE_3(id) >> 4) & 0x3)
+
+#define ID_GET_MICRON_SIMUL_PROG(id)    ((ID_GET_BYTE_3(id) >> 4) & 0x3)
+
+#define ID_GET_CACHE_PROGRAM(id)        ((ID_GET_BYTE_3(id) >> 7) & 0x1)
+
+/* Byte 4 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_4(id)                       ((id)[3])
+    #define ID_HYNIX_BYTE_4_ECC12_DEVICE        (0x25)
+
+#define ID_GET_PAGE_SIZE_CODE(id)               ((ID_GET_BYTE_4(id) >> 0) & 0x3)
+    #define ID_PAGE_SIZE_CODE_1K                (0x0)
+    #define ID_PAGE_SIZE_CODE_2K                (0x1)
+    #define ID_PAGE_SIZE_CODE_4K                (0x2)
+    #define ID_PAGE_SIZE_CODE_8K                (0x3)
+    #define ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K (0x2)
+
+#define ID_GET_OOB_SIZE_CODE(id)                ((ID_GET_BYTE_4(id) >> 2) & 0x1)
+
+#define ID_GET_BLOCK_SIZE_CODE(id)              ((ID_GET_BYTE_4(id) >> 4) & 0x3)
+
+/* Byte 5 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_5(id)                  ((id)[4])
+    #define ID_MICRON_BYTE_5_ECC12         (0x84)
+
+#define ID_GET_SAMSUNG_ECC_LEVEL_CODE(id)  ((ID_GET_BYTE_5(id) >> 4) & 0x7)
+    #define ID_SAMSUNG_ECC_LEVEL_CODE_8    (0x03)
+    #define ID_SAMSUNG_ECC_LEVEL_CODE_24   (0x05)
+
+#define ID_GET_PLANE_COUNT_CODE(id)        ((ID_GET_BYTE_5(id) >> 2) & 0x3)
+
+/* Byte 6 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_6(id)                        ((id)[5])
+    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K  (0x54)
+    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_4K  (0x13)
+
+#define ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id)   ((ID_GET_BYTE_6(id)>>0) & 0x7)
+    #define ID_SAMSUNG_DEVICE_VERSION_CODE_40NM  (0x01)
+
+/* -------------------------------------------------------------------------- */
+
+void nand_device_print_info(struct nand_device_info *info)
+{
+	unsigned    i;
+	const char  *mfr_name;
+	const char  *cell_technology_name;
+	uint64_t    chip_size;
+	const char  *chip_size_units;
+	unsigned    page_data_size_in_bytes;
+	unsigned    page_oob_size_in_bytes;
+
+	/* Check for nonsense. */
+
+	if (!info)
+		return;
+
+	/* Prepare the manufacturer name. */
+
+	mfr_name = "Unknown";
+
+	for (i = 0; nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == info->manufacturer_code) {
+			mfr_name = nand_manuf_ids[i].name;
+			break;
+		}
+	}
+
+	/* Prepare the name of the cell technology. */
+
+	switch (info->cell_technology) {
+	case NAND_DEVICE_CELL_TECH_SLC:
+		cell_technology_name = "SLC";
+		break;
+	case NAND_DEVICE_CELL_TECH_MLC:
+		cell_technology_name = "MLC";
+		break;
+	default:
+		cell_technology_name = "Unknown";
+		break;
+	}
+
+	/* Prepare the chip size. */
+
+	if ((info->chip_size_in_bytes >= SZ_1G) &&
+					!(info->chip_size_in_bytes % SZ_1G)) {
+		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1G);
+		chip_size_units = "GiB";
+	} else if ((info->chip_size_in_bytes >= SZ_1M) &&
+					!(info->chip_size_in_bytes % SZ_1M)) {
+		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1M);
+		chip_size_units = "MiB";
+	} else {
+		chip_size       = info->chip_size_in_bytes;
+		chip_size_units = "B";
+	}
+
+	/* Prepare the page geometry. */
+
+	page_data_size_in_bytes = (1<<(fls(info->page_total_size_in_bytes)-1));
+	page_oob_size_in_bytes  = info->page_total_size_in_bytes -
+							page_data_size_in_bytes;
+
+	/* Print the information. */
+
+	printk(KERN_INFO "Manufacturer      : %s (0x%02x)\n",  mfr_name,
+						info->manufacturer_code);
+	printk(KERN_INFO "Device Code       : 0x%02x\n", info->device_code);
+	printk(KERN_INFO "Cell Technology   : %s\n", cell_technology_name);
+	printk(KERN_INFO "Chip Size         : %llu %s\n", chip_size,
+							chip_size_units);
+	printk(KERN_INFO "Pages per Block   : %u\n",
+						info->block_size_in_pages);
+	printk(KERN_INFO "Page Geometry     : %u+%u\n", page_data_size_in_bytes,
+						page_oob_size_in_bytes);
+	printk(KERN_INFO "ECC Strength      : %u bits\n",
+						info->ecc_strength_in_bits);
+	printk(KERN_INFO "ECC Size          : %u B\n", info->ecc_size_in_bytes);
+	printk(KERN_INFO "Data Setup Time   : %u ns\n", info->data_setup_in_ns);
+	printk(KERN_INFO "Data Hold Time    : %u ns\n", info->data_hold_in_ns);
+	printk(KERN_INFO "Address Setup Time: %u ns\n",
+						info->address_setup_in_ns);
+	printk(KERN_INFO "GPMI Sample Delay : %u ns\n",
+						info->gpmi_sample_delay_in_ns);
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tREA              : %u ns\n",
+							info->tREA_in_ns);
+	else
+		printk(KERN_INFO "tREA              : Unknown\n");
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tRLOH             : %u ns\n",
+							info->tRLOH_in_ns);
+	else
+		printk(KERN_INFO "tRLOH             : Unknown\n");
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tRHOH             : %u ns\n",
+							info->tRHOH_in_ns);
+	else
+		printk(KERN_INFO "tRHOH             : Unknown\n");
+	if (info->description)
+		printk(KERN_INFO "Description       : %s\n", info->description);
+	else
+		printk(KERN_INFO "Description       : <None>\n");
+
+}
+
+static struct nand_device_info *nand_device_info_search(
+	struct nand_device_info *table, uint8_t mfr_code, uint8_t device_code)
+{
+
+	for (; !table->end_of_table; table++) {
+		if (table->manufacturer_code != mfr_code)
+			continue;
+		if (table->device_code != device_code)
+			continue;
+		return table;
+	}
+
+	return 0;
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_toshiba(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	/*
+	 * Look for 8K page Toshiba MLC devices.
+	 *
+	 * The page size field in byte 4 can't be used because the field was
+	 * redefined in the 8K parts so the value meaning "8K page" is the same
+	 * as the value meaning "4K page" on the 4K page devices.
+	 *
+	 * The only identifiable difference between the 4K and 8K page Toshiba
+	 * devices with a device code of 0xd7 is the undocumented 6th ID byte.
+	 * The 4K device returns a value of 0x13 and the 8K a value of 0x54.
+	 * Toshiba has verified that this is an acceptable method to distinguish
+	 * the two device families.
+	 */
+
+	if (ID_GET_BYTE_6(id) == ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K) {
+		/* Type 11 */
+		table = nand_device_info_table_type_11;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Type 9 */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_samsung(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an MLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
+
+		/* Is this a Samsung 8K Page MLC device with 16 bit ECC? */
+		if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
+					ID_SAMSUNG_ECC_LEVEL_CODE_24) &&
+		    (ID_GET_PAGE_SIZE_CODE(id) ==
+					ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K)) {
+			/* Type 15 */
+			table = nand_device_info_table_type_15;
+		}
+		/* Is this a Samsung 42nm ECC8 device with a 6 byte ID? */
+		else if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
+					ID_SAMSUNG_ECC_LEVEL_CODE_8) &&
+			(ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id) ==
+					ID_SAMSUNG_DEVICE_VERSION_CODE_40NM)) {
+			/* Type 9 */
+			table = nand_device_info_table_type_9;
+		} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+			/* Type 8 */
+			table = nand_device_info_table_type_8;
+		} else {
+			/* Large MLC */
+			table = nand_device_info_table_large_mlc;
+		}
+
+	} else {
+
+		/* Check the page size first. */
+		if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+			/* Type 10 */
+			table = nand_device_info_table_type_10;
+		}
+		/* Check the chip size. */
+		else if (ID_GET_DEVICE_CODE(id) ==
+						ID_SAMSUNG_DEVICE_CODE_1_GBIT) {
+			if (!ID_GET_CACHE_PROGRAM(id)) {
+				/*
+				 * 128 MiB Samsung chips without cache program
+				 * are Type 7.
+				 *
+				 * The K9F1G08U0B does not support multi-plane
+				 * program, so the if statement below cannot be
+				 * used to identify it.
+				 */
+				table = nand_device_info_table_type_7;
+
+			} else {
+				/* Smaller sizes are Type 2 by default. */
+				table = nand_device_info_table_type_2;
+			}
+		} else {
+			/* Check number of simultaneously programmed pages. */
+			if (ID_GET_SAMSUNG_SIMUL_PROG(id) &&
+						ID_GET_PLANE_COUNT_CODE(id)) {
+				/* Type 7 */
+				table = nand_device_info_table_type_7;
+			} else {
+				/* Type 2 */
+				table = nand_device_info_table_type_2;
+			}
+
+		}
+
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_stmicro(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC)
+		/* Type 2 */
+		table = nand_device_info_table_type_2;
+	else
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_hynix(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	/*
+	 * Check for ECC12 devices.
+	 *
+	 * We look at the 4th ID byte to distinguish some Hynix ECC12 devices
+	 * from the similar ECC8 part. For example H27UBG8T2M (ECC12) 4th byte
+	 * is 0x25, whereas H27UDG8WFM (ECC8) 4th byte is 0xB6.
+	 */
+
+	if ((ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12 &&
+			ID_GET_BYTE_4(id) == ID_HYNIX_BYTE_4_ECC12_DEVICE) ||
+	    (ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12_LARGE)) {
+		/* BCH ECC 12 */
+		table = nand_device_info_table_bch_ecc12;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/*
+		 * So far, all other Samsung and Hynix 4K page devices are
+		 * Type 8.
+		 */
+		table = nand_device_info_table_type_8;
+	} else
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_micron(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+
+		/* Check number of simultaneously programmed pages. */
+
+		if (ID_GET_MICRON_SIMUL_PROG(id)) {
+			/* Type 7 */
+			table = nand_device_info_table_type_7;
+		} else {
+			/* Zero simultaneously programmed pages means Type 2. */
+			table = nand_device_info_table_type_2;
+		}
+
+		return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+	}
+
+	/*
+	 * We look at the 5th ID byte to distinguish some Micron ECC12 NANDs
+	 * from the similar ECC8 part.
+	 *
+	 * For example MT29F64G08CFAAA (ECC12) 5th byte is 0x84, whereas
+	 * MT29F64G08TAA (ECC8) 5th byte is 0x78.
+	 *
+	 * We also have a special case for the Micron L63B family
+	 * (256 page/block), which has unique device codes but no ID fields that
+	 * can easily be used to distinguish the family.
+	 */
+
+	if ((ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12 &&
+				ID_GET_BYTE_5(id) == ID_MICRON_BYTE_5_ECC12)  ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_LARGE)      ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE) ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE) ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE)) {
+		/* BCH ECC 12 */
+		table = nand_device_info_table_bch_ecc12;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Toshiba devices with 4K pages are Type 9. */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_sandisk(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	} else {
+		/* Type 2 */
+		table = nand_device_info_table_type_2;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_intel(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Type 9 */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+/**
+ * struct nand_device_type_info - Information about a NAND Flash type.
+ *
+ * @name:   A human-readable name for this type.
+ * @table:  The device info table for this type.
+ */
+
+struct nand_device_type_info {
+	struct nand_device_info  *table;
+	const char               *name;
+};
+
+/*
+ * A table that maps manufacturer IDs to device information tables.
+ */
+
+static struct nand_device_type_info  nand_device_type_directory[] __initdata = {
+	{nand_device_info_table_type_2,    "Type 2"   },
+	{nand_device_info_table_large_mlc, "Large MLC"},
+	{nand_device_info_table_type_7,    "Type 7"   },
+	{nand_device_info_table_type_8,    "Type 8"   },
+	{nand_device_info_table_type_9,    "Type 9"   },
+	{nand_device_info_table_type_10,   "Type 10"  },
+	{nand_device_info_table_type_11,   "Type 11"  },
+	{nand_device_info_table_type_15,   "Type 15"  },
+	{nand_device_info_table_bch_ecc12, "BCH ECC12"},
+	{0, 0},
+};
+
+/**
+ * struct nand_device_mfr_info - Information about a NAND Flash manufacturer.
+ *
+ * @id:     The value of the first NAND Flash ID byte, which identifies the
+ *          manufacturer.
+ * @fn:     A pointer to a function to use for identifying devices from the
+ *          given manufacturer.
+ */
+
+struct nand_device_mfr_info {
+	uint8_t                  id;
+	struct nand_device_info  *(*fn)(const uint8_t id[]);
+};
+
+/*
+ * A table that maps manufacturer IDs to device information tables.
+ */
+
+static struct nand_device_mfr_info  nand_device_mfr_directory[] __initdata = {
+	{
+	.id = NAND_MFR_TOSHIBA,
+	.fn = nand_device_info_fn_toshiba,
+	},
+	{
+	.id = NAND_MFR_SAMSUNG,
+	.fn = nand_device_info_fn_samsung,
+	},
+	{
+	.id = NAND_MFR_FUJITSU,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_NATIONAL,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_RENESAS,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_STMICRO,
+	.fn = nand_device_info_fn_stmicro,
+	},
+	{
+	.id = NAND_MFR_HYNIX,
+	.fn = nand_device_info_fn_hynix,
+	},
+	{
+	.id = NAND_MFR_MICRON,
+	.fn = nand_device_info_fn_micron,
+	},
+	{
+	.id = NAND_MFR_AMD,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_SANDISK,
+	.fn = nand_device_info_fn_sandisk,
+	},
+	{
+	.id = NAND_MFR_INTEL,
+	.fn = nand_device_info_fn_intel,
+	},
+	{0, 0}
+};
+
+/**
+ * nand_device_info_test_table - Validate a device info table.
+ *
+ * This function runs tests on the given device info table to check that it
+ * meets the current assumptions.
+ */
+
+static void __init nand_device_info_test_table(
+			struct nand_device_info *table, const char * name)
+{
+	unsigned  i;
+	unsigned  j;
+	uint8_t   mfr_code;
+	uint8_t   device_code;
+
+	/* Loop over entries in this table. */
+
+	for (i = 0; !table[i].end_of_table; i++) {
+
+		/* Get discriminating attributes of the current device. */
+
+		mfr_code    = table[i].manufacturer_code;
+		device_code = table[i].device_code;
+
+		/* Compare with the remaining devices in this table. */
+
+		for (j = i + 1; !table[j].end_of_table; j++) {
+			if ((mfr_code    == table[j].manufacturer_code) &&
+			    (device_code == table[j].device_code))
+				goto error;
+		}
+
+	}
+
+	return;
+
+error:
+
+	printk(KERN_EMERG
+		"\n== NAND Flash device info table failed validity check ==\n");
+
+	printk(KERN_EMERG "\nDevice Info Table: %s\n", name);
+	printk(KERN_EMERG "\nTable Index %u\n", i);
+	nand_device_print_info(table + i);
+	printk(KERN_EMERG "\nTable Index %u\n", j);
+	nand_device_print_info(table + j);
+	printk(KERN_EMERG "\n");
+
+	BUG();
+
+}
+
+/**
+ * nand_device_info_test_data - Test the NAND Flash device data.
+ */
+
+static void __init nand_device_info_test_data(void)
+{
+
+	unsigned  i;
+
+	for (i = 0; nand_device_type_directory[i].name; i++) {
+		nand_device_info_test_table(
+					nand_device_type_directory[i].table,
+					nand_device_type_directory[i].name);
+	}
+
+}
+
+struct nand_device_info * __init nand_device_get_info(const uint8_t id[])
+{
+	unsigned                 i;
+	uint8_t                  mfr_id = ID_GET_MFR_CODE(id);
+	struct nand_device_info  *(*fn)(const uint8_t id[]) = 0;
+
+	/* Test the data. */
+
+	nand_device_info_test_data();
+
+	/* Look for information about this manufacturer. */
+
+	for (i = 0; nand_device_mfr_directory[i].id; i++) {
+		if (nand_device_mfr_directory[i].id == mfr_id) {
+			fn = nand_device_mfr_directory[i].fn;
+			break;
+		}
+	}
+
+	if (!fn)
+		return 0;
+
+	/*
+	 * If control arrives here, we found both a table of device information,
+	 * and a function we can use to identify the current device. Attempt to
+	 * identify the device and return the result.
+	 */
+
+	return fn(id);
+
+}
diff --git a/drivers/mtd/nand/nand_device_info.h b/drivers/mtd/nand/nand_device_info.h
new file mode 100644
index 0000000..a5f56e9
--- /dev/null
+++ b/drivers/mtd/nand/nand_device_info.h
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __DRIVERS_NAND_DEVICE_INFO_H
+#define __DRIVERS_NAND_DEVICE_INFO_H
+
+ /*
+  * The number of ID bytes to read from the NAND Flash device and hand over to
+  * the identification system.
+  */
+
+#define NAND_DEVICE_ID_BYTE_COUNT  (6)
+
+ /*
+  * The number of ID bytes to read from the NAND Flash device and hand over to
+  * the identification system.
+  */
+
+enum nand_device_cell_technology {
+	NAND_DEVICE_CELL_TECH_SLC = 0,
+	NAND_DEVICE_CELL_TECH_MLC = 1,
+};
+
+/**
+ * struct nand_device_info - Information about a single NAND Flash device.
+ *
+ * This structure contains all the *essential* information about a NAND Flash
+ * device, derived from the device's data sheet. For each manufacturer, we have
+ * an array of these structures.
+ *
+ * @end_of_table:              If true, marks the end of a table of device
+ *                             information.
+ * @manufacturer_code:         The manufacturer code (1st ID byte) reported by
+ *                             the device.
+ * @device_code:               The device code (2nd ID byte) reported by the
+ *                             device.
+ * @cell_technology:           The storage cell technology.
+ * @chip_size_in_bytes:        The total size of the storage behind a single
+ *                             chip select, in bytes. Notice that this is *not*
+ *                             necessarily the total size of the storage in a
+ *                             *package*, which may contain several chips.
+ * @block_size_in_pages:       The number of pages in a block.
+ * @page_total_size_in_bytes:  The total size of a page, in bytes, including
+ *                             both the data and the OOB.
+ * @ecc_strength_in_bits:      The strength of the ECC called for by the
+ *                             manufacturer, in number of correctable bits.
+ * @ecc_size_in_bytes:         The size of the data block over which the
+ *                             manufacturer calls for the given ECC algorithm
+ *                             and strength.
+ * @data_setup_in_ns:          The data setup time, in nanoseconds. Usually the
+ *                             maximum of tDS and tWP. A negative value
+ *                             indicates this characteristic isn't known.
+ * @data_hold_in_ns:           The data hold time, in nanoseconds. Usually the
+ *                             maximum of tDH, tWH and tREH. A negative value
+ *                             indicates this characteristic isn't known.
+ * @address_setup_in_ns:       The address setup time, in nanoseconds. Usually
+ *                             the maximum of tCLS, tCS and tALS. A negative
+ *                             value indicates this characteristic isn't known.
+ * @gpmi_sample_delay_in_ns:   A GPMI-specific timing parameter. A negative
+ *                             value indicates this characteristic isn't known.
+ * @tREA_in_ns:                tREA, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ * @tRLOH_in_ns:               tRLOH, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ * @tRHOH_in_ns:               tRHOH, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ */
+
+struct nand_device_info {
+
+	/* End of table marker */
+
+	bool      end_of_table;
+
+	/* Manufacturer and Device codes */
+
+	uint8_t   manufacturer_code;
+	uint8_t   device_code;
+
+	/* Technology */
+
+	enum nand_device_cell_technology  cell_technology;
+
+	/* Geometry */
+
+	uint64_t  chip_size_in_bytes;
+	uint32_t  block_size_in_pages;
+	uint16_t  page_total_size_in_bytes;
+
+	/* ECC */
+
+	uint8_t   ecc_strength_in_bits;
+	uint16_t  ecc_size_in_bytes;
+
+	/* Timing */
+
+	int8_t    data_setup_in_ns;
+	int8_t    data_hold_in_ns;
+	int8_t    address_setup_in_ns;
+	int8_t    gpmi_sample_delay_in_ns;
+	int8_t    tREA_in_ns;
+	int8_t    tRLOH_in_ns;
+	int8_t    tRHOH_in_ns;
+
+	/* Description */
+
+	const char  *description;
+
+};
+
+/**
+ * nand_device_get_info - Get info about a device based on ID bytes.
+ *
+ * @id_bytes:  An array of NAND_DEVICE_ID_BYTE_COUNT ID bytes retrieved from the
+ *             NAND Flash device.
+ */
+
+struct nand_device_info *nand_device_get_info(const uint8_t id_bytes[]);
+
+/**
+ * nand_device_print_info - Prints information about a NAND Flash device.
+ *
+ * @info  A pointer to a NAND Flash device information structure.
+ */
+
+void nand_device_print_info(struct nand_device_info *info);
+
+#endif
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ccab9df..23c266a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -425,6 +425,8 @@ struct nand_chip {
 #define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
 #define NAND_MFR_AMD		0x01
+#define NAND_MFR_SANDISK	0x45
+#define NAND_MFR_INTEL		0x89
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
-- 
1.6.5.2

