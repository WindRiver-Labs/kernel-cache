From aace52500d8d9f0d223d1b1be94bcc007bac044d Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Jun 2009 21:25:40 +0800
Subject: [PATCH] MXC: fix OTG malfunction after system resume

USB udc and host PM functions suspend and resume are called
by OTG engine according to its state machine, but when we
suspend and resume the whole system, the PM functions of
udc and host drivers are also invoked, so it will put OTG
on an uncertain state and finally make OTG unwork. To fix
it, these 2 kinds of PM functions invocation are distinguished
here.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/arm/plat-mxc/include/mach/arc_otg.h |    2 +
 drivers/usb/gadget/arcotg_udc.c          |   38 ++++++++++++++++++++++++++++++
 drivers/usb/gadget/arcotg_udc.h          |    1 +
 drivers/usb/host/ehci-arc.c              |   30 +++++++++++++++++++++++
 4 files changed, 71 insertions(+), 0 deletions(-)

diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index 8b9ad4d..97ff3c6 100644
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -23,6 +23,8 @@ struct arc_usb_config {
 	u32 usbmode;		/* address of usbmode register */
 	u32 does_otg;		/* set IFF it's an OTG port */
 	unsigned power_budget;	/* for hcd->power_budget */
+	unsigned suspended;	/* host suspend status */
+	unsigned already_suspended; /* PM suspend */
 
 	/* register save area for suspend/resume */
 	u32 pm_command;
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 1d432bb..609b254 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -2609,6 +2609,30 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 
 static int udc_suspend(struct fsl_udc *udc)
 {
+	u32 mode, usbcmd;
+
+	mode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;
+	usbcmd = fsl_readl(&dr_regs->usbcmd);
+
+	pr_debug("%s(): mode 0x%x stopped %d\n", __func__, mode, udc->stopped);
+
+	/*
+	 * If the controller is already stopped, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller stopped at PM resume time.
+	 */
+	if (udc->stopped) {
+		pr_debug("gadget already stopped, leaving early\n");
+		udc->already_stopped = 1;
+		return 0;
+	}
+
+	/* stop the controller */
+	usbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
+	fsl_writel(usbcmd, &dr_regs->usbcmd);
+
+	printk(KERN_INFO "USB Gadget suspended\n");
+
 	udc->stopped = 1;
 	return 0;
 }
@@ -2619,6 +2643,10 @@ static int udc_suspend(struct fsl_udc *udc)
  -----------------------------------------------------------------*/
 static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	if ((udc_controller->usb_state > USB_STATE_POWERED) &&
+			(udc_controller->usb_state < USB_STATE_SUSPENDED))
+		return -EBUSY;
+
 	return udc_suspend(udc_controller);
 }
 
@@ -2628,6 +2656,16 @@ static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
  *-----------------------------------------------------------------*/
 static int fsl_udc_resume(struct platform_device *pdev)
 {
+	/*
+	 * If the controller was stopped at suspend time, then
+	 * don't resume it now.
+	 */
+	if (udc_controller->already_stopped) {
+		udc_controller->already_stopped = 0;
+		pr_debug("gadget was already stopped, leaving early\n");
+		return 0;
+	}
+
 	/* Enable DR irq reg and set controller Run */
 	if (udc_controller->stopped) {
 		dr_controller_setup(udc_controller);
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index 5784df1..14d668a 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -533,6 +533,7 @@ struct fsl_udc {
 	unsigned vbus_active:1;
 	unsigned stopped:1;
 	unsigned remote_wakeup:1;
+	unsigned already_stopped:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	struct fsl_req *status_req;	/* ep0 status request */
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
index 26ab8bb..afe76d8 100644
--- a/drivers/usb/host/ehci-arc.c
+++ b/drivers/usb/host/ehci-arc.c
@@ -340,6 +340,17 @@ static int ehci_arc_suspend(struct platform_device *pdev, pm_message_t state)
 	dbg("%s config->usbmode=0x%x  config->set_vbus_power=0x%p\n",
 			__func__, config->usbmode, config->set_vbus_power);
 
+	/*
+	 * If the controller is already suspended, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller suspended at PM resume time.
+	 */
+	if (config->suspended) {
+		pr_debug("%s: already suspended, leaving early\n", __func__);
+		config->already_suspended = 1;
+		return 0;
+	}
+
 	printk(KERN_INFO "USB Host suspended\n");
 
 	hcd->state = HC_STATE_SUSPENDED;
@@ -369,6 +380,8 @@ static int ehci_arc_suspend(struct platform_device *pdev, pm_message_t state)
 	/* clear the W1C bits */
 	config->pm_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);
 
+	config->suspended = 1;
+
 	/* clear PP to cut power to the port */
 	cmd = ehci_readl(ehci, &ehci->regs->port_status[0]);
 	cmd &= ~PORT_POWER;
@@ -393,6 +406,23 @@ static int ehci_arc_resume(struct platform_device *pdev)
 	vdbg("%s ehci->regs=0x%p  hcd->regs=0x%p  usbmode=0x%x\n",
 			__func__, ehci->regs, hcd->regs, config->usbmode);
 
+	/*
+	 * If the controller was already suspended at suspend time,
+	 * then don't resume it now.
+	 */
+	if (config->already_suspended) {
+		pr_debug("already suspended, leaving early\n");
+		config->already_suspended = 0;
+		return 0;
+	}
+
+	if (!config->suspended) {
+		pr_debug("not suspended, leaving early\n");
+		return 0;
+	}
+
+	config->suspended = 0;
+
 	if (config->set_vbus_power)
 		config->set_vbus_power(1);
 
-- 
1.5.5.1

