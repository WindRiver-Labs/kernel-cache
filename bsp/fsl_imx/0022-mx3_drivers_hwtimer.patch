From df376b7dc9e28108421498471ef47344f74a8dd0 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Fri, 24 Oct 2008 11:08:29 +0800
Subject: [PATCH 22/40] mx3_drivers_hwtimer

MX3 hwtimer driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/rtc/rtc-mxc.c |   71 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 70 insertions(+), 1 deletions(-)

diff --git a/drivers/rtc/rtc-mxc.c b/drivers/rtc/rtc-mxc.c
index 88c161c..b0ce0d8 100644
--- a/drivers/rtc/rtc-mxc.c
+++ b/drivers/rtc/rtc-mxc.c
@@ -30,6 +30,10 @@
 #include <mach/clock.h>
 #include <asm/plat-mxc/mxc_rtc.h>
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 /*!
  * @file mxc_rtc.c
  * @brief Real Time Clock interface
@@ -159,6 +163,36 @@ static DEFINE_SPINLOCK(rtc_lock);
 static int mxc_rtc_ioctl(struct device *dev,
 		unsigned int cmd, unsigned long arg);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+
+static int rtc_get_freq(void)
+{
+	return rtc_freq;
+}
+
+static int rtc_set_freq(int freq)
+{
+	unsigned long newfreq;
+	/* Note - assumes freq is power of 2.  Should */
+	/* round freq up to nearest power of 2 */
+	newfreq = freq;
+	return mxc_rtc_ioctl(NULL, RTC_IRQP_SET, newfreq);
+}
+
+static int rtc_start(void)
+{
+	return mxc_rtc_ioctl(NULL, RTC_PIE_ON, 0);
+}
+
+static int rtc_stop(void)
+{
+	return mxc_rtc_ioctl(NULL, RTC_PIE_OFF, 0);
+}
+
+#endif  /* CONFIG_HWTIMER_HOOKS */
+
 /*!
  * This function is used to obtain the RTC time or the alarm value in
  * second.
@@ -293,6 +327,11 @@ static irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)
 			rtc_periodic_alarm(&g_rtc_alarm))
 		rtc_update_alarm(&g_rtc_alarm);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	if (rtc_hwtimer.hook != NULL)
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	spin_unlock(&rtc_lock);
 
 	rtc_update_irq(rtc, 1, events);
@@ -422,7 +461,7 @@ static int mxc_rtc_ioctl(struct device *dev,
 			mxc_rtc_set_time(dev, (struct rtc_time *)arg);
 			return 0;
 	}
-	return -EINVAL;
+	return -ENOIOCTLCMD;
 }
 
 /*!
@@ -725,8 +764,28 @@ static int __init mxc_rtc_probe(struct platform_device *pdev)
 	printk(KERN_INFO "Real TIme clock"
 			"Driver v%s \n", RTC_VERSION);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	rtc_hwtimer_data.name = "mxc_rtc";
+	rtc_hwtimer_data.desc = "Freescale MXC Real Time Clock";
+	rtc_hwtimer_data.def_freq = 2;
+	rtc_hwtimer_data.min_freq = 2;
+	rtc_hwtimer_data.max_freq = MAX_PIE_FREQ;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = rtc_set_freq;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+#endif
+
 	platform_set_drvdata(pdev, rtc);
 
+	device_init_wakeup(&pdev->dev, 1);
+
 	return 0;
 err4:
 	free_irq(rtc_priv->irq, rtc);
@@ -754,6 +813,10 @@ static int __exit mxc_rtc_remove(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	unregister_hwtimer(&rtc_hwtimer);
+#endif
+
 	mxc_rtc_release(rtc_priv->dev);
 
 
@@ -792,6 +855,9 @@ static int mxc_rtc_suspend(struct platform_device *pdev, pm_message_t state)
 	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
 	save_time_delta(&mxc_rtc_delta, &tv);
 
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(platform_get_irq(pdev, 0));
+
 	return 0;
 }
 
@@ -812,6 +878,9 @@ static int mxc_rtc_resume(struct platform_device *pdev)
 	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
 	restore_time_delta(&mxc_rtc_delta, &tv);
 
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(platform_get_irq(pdev, 0));
+
 	return 0;
 }
 
-- 
1.6.3.1

