From 620e5d777e1fe49541198392cb8e5ec28f451f09 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 10:08:03 +0800
Subject: [PATCH] mx3_drivers_mxc_ssi

MX3 ssi driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/ssi/Kconfig     |   13 +
 drivers/mxc/ssi/Makefile    |    9 +
 drivers/mxc/ssi/registers.h |  193 +++++++
 drivers/mxc/ssi/ssi.c       | 1208 +++++++++++++++++++++++++++++++++++++++++++
 drivers/mxc/ssi/ssi.h       |  606 ++++++++++++++++++++++
 drivers/mxc/ssi/ssi_types.h |  361 +++++++++++++
 6 files changed, 2390 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/ssi/Kconfig
 create mode 100644 drivers/mxc/ssi/Makefile
 create mode 100644 drivers/mxc/ssi/registers.h
 create mode 100644 drivers/mxc/ssi/ssi.c
 create mode 100644 drivers/mxc/ssi/ssi.h
 create mode 100644 drivers/mxc/ssi/ssi_types.h

diff --git a/drivers/mxc/ssi/Kconfig b/drivers/mxc/ssi/Kconfig
new file mode 100644
index 0000000..4bfaa8a
--- /dev/null
+++ b/drivers/mxc/ssi/Kconfig
@@ -0,0 +1,13 @@
+#
+# SPI device configuration
+#
+
+menu "MXC SSI support"
+
+config MXC_SSI
+	tristate "SSI support"
+	---help---
+	  Say Y to get the SSI services API available on MXC platform.
+
+endmenu
+
diff --git a/drivers/mxc/ssi/Makefile b/drivers/mxc/ssi/Makefile
new file mode 100644
index 0000000..c0c8872
--- /dev/null
+++ b/drivers/mxc/ssi/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the kernel SSI device drivers.
+#
+
+obj-$(CONFIG_MXC_SSI) 		+= ssimod.o
+
+ssimod-objs := ssi.o
+
+
diff --git a/drivers/mxc/ssi/registers.h b/drivers/mxc/ssi/registers.h
new file mode 100644
index 0000000..6971b24
--- /dev/null
+++ b/drivers/mxc/ssi/registers.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file ../ssi/registers.h
+  * @brief This header file contains SSI driver low level
+  * definition to access module registers.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_REGISTERS_H__
+#define __MXC_SSI_REGISTERS_H__
+
+/*!
+ * This include to define bool type, false and true definitions.
+ */
+#include <mach/hardware.h>
+
+#define SPBA_CPU_SSI            0x07
+
+#define    MXC_SSISTX0		0x00
+#define    MXC_SSISTX1		0x04
+#define    MXC_SSISRX0		0x08
+#define    MXC_SSISRX1   	0x0C
+#define    MXC_SSISCR           0x10
+#define    MXC_SSISISR          0x14
+#define    MXC_SSISIER   	0x18
+#define    MXC_SSISTCR   	0x1C
+#define    MXC_SSISRCR   	0x20
+#define    MXC_SSISTCCR  	0x24
+#define    MXC_SSISRCCR  	0x28
+#define    MXC_SSISFCSR  	0x2C
+#define    MXC_SSISTR           0x30
+#define    MXC_SSISOR           0x34
+#define    MXC_SSISACNT  	0x38
+#define    MXC_SSISACADD 	0x3C
+#define    MXC_SSISACDAT 	0x40
+#define    MXC_SSISATAG  	0x44
+#define    MXC_SSISTMSK  	0x48
+#define    MXC_SSISRMSK  	0x4C
+
+/*! SSI1 registers offset*/
+#define    MXC_SSI1STX0		0x00
+#define    MXC_SSI1STX1		0x04
+#define    MXC_SSI1SRX0		0x08
+#define    MXC_SSI1SRX1   	0x0C
+#define    MXC_SSI1SCR          0x10
+#define    MXC_SSI1SISR         0x14
+#define    MXC_SSI1SIER   	0x18
+#define    MXC_SSI1STCR   	0x1C
+#define    MXC_SSI1SRCR   	0x20
+#define    MXC_SSI1STCCR  	0x24
+#define    MXC_SSI1SRCCR  	0x28
+#define    MXC_SSI1SFCSR  	0x2C
+#define    MXC_SSI1STR          0x30
+#define    MXC_SSI1SOR          0x34
+#define    MXC_SSI1SACNT  	0x38
+#define    MXC_SSI1SACADD 	0x3C
+#define    MXC_SSI1SACDAT 	0x40
+#define    MXC_SSI1SATAG  	0x44
+#define    MXC_SSI1STMSK  	0x48
+#define    MXC_SSI1SRMSK  	0x4C
+
+/*! SSI2 registers offset*/
+#define    MXC_SSI2STX0   	0x00
+#define    MXC_SSI2STX1         0x04
+#define    MXC_SSI2SRX0    	0x08
+#define    MXC_SSI2SRX1         0x0C
+#define    MXC_SSI2SCR          0x10
+#define    MXC_SSI2SISR         0x14
+#define    MXC_SSI2SIER         0x18
+#define    MXC_SSI2STCR         0x1C
+#define    MXC_SSI2SRCR         0x20
+#define    MXC_SSI2STCCR  	0x24
+#define    MXC_SSI2SRCCR   	0x28
+#define    MXC_SSI2SFCSR        0x2C
+#define    MXC_SSI2STR    	0x30
+#define    MXC_SSI2SOR    	0x34
+#define    MXC_SSI2SACNT  	0x38
+#define    MXC_SSI2SACADD 	0x3C
+#define    MXC_SSI2SACDAT 	0x40
+#define    MXC_SSI2SATAG  	0x44
+#define    MXC_SSI2STMSK  	0x48
+#define    MXC_SSI2SRMSK  	0x4C
+
+/*!
+ * SCR Register bit shift definitions
+ */
+#define SSI_ENABLE_SHIFT            0
+#define SSI_TRANSMIT_ENABLE_SHIFT   1
+#define SSI_RECEIVE_ENABLE_SHIFT    2
+#define SSI_NETWORK_MODE_SHIFT      3
+#define SSI_SYNCHRONOUS_MODE_SHIFT  4
+#define SSI_I2S_MODE_SHIFT          5
+#define SSI_SYSTEM_CLOCK_SHIFT      7
+#define SSI_TWO_CHANNEL_SHIFT       8
+#define SSI_CLOCK_IDLE_SHIFT        9
+
+/*!
+ * STCR & SRCR Registers bit shift definitions
+ */
+#define SSI_EARLY_FRAME_SYNC_SHIFT    0
+#define SSI_FRAME_SYNC_LENGTH_SHIFT   1
+#define SSI_FRAME_SYNC_INVERT_SHIFT   2
+#define SSI_CLOCK_POLARITY_SHIFT      3
+#define SSI_SHIFT_DIRECTION_SHIFT     4
+#define SSI_CLOCK_DIRECTION_SHIFT     5
+#define SSI_FRAME_DIRECTION_SHIFT     6
+#define SSI_FIFO_ENABLE_0_SHIFT       7
+#define SSI_FIFO_ENABLE_1_SHIFT       8
+#define SSI_BIT_0_SHIFT               9
+
+/*!
+ * STCCR & SRCCR Registers bit shift definitions
+ */
+#define SSI_PRESCALER_MODULUS_SHIFT          0
+#define SSI_FRAME_RATE_DIVIDER_SHIFT         8
+#define SSI_WORD_LENGTH_SHIFT               13
+#define SSI_PRESCALER_RANGE_SHIFT           17
+#define SSI_DIVIDE_BY_TWO_SHIFT             18
+#define SSI_FRAME_DIVIDER_MASK              31
+#define SSI_MIN_FRAME_DIVIDER_RATIO          1
+#define SSI_MAX_FRAME_DIVIDER_RATIO         32
+#define SSI_PRESCALER_MODULUS_MASK         255
+#define SSI_MIN_PRESCALER_MODULUS_RATIO      1
+#define SSI_MAX_PRESCALER_MODULUS_RATIO    256
+#define SSI_WORD_LENGTH_MASK                15
+/*!
+ * SISR Register definition
+ */
+#define SSI_IRQ_STATUS_NUMBER        19
+
+/*!
+ * SFCSR Register bit shift definitions
+ */
+#define SSI_RX_FIFO_1_COUNT_SHIFT       28
+#define SSI_TX_FIFO_1_COUNT_SHIFT       24
+#define SSI_RX_FIFO_1_WATERMARK_SHIFT   20
+#define SSI_TX_FIFO_1_WATERMARK_SHIFT   16
+#define SSI_RX_FIFO_0_COUNT_SHIFT       12
+#define SSI_TX_FIFO_0_COUNT_SHIFT        8
+#define SSI_RX_FIFO_0_WATERMARK_SHIFT    4
+#define SSI_TX_FIFO_0_WATERMARK_SHIFT    0
+#define SSI_MIN_FIFO_WATERMARK           0
+#define SSI_MAX_FIFO_WATERMARK           8
+
+/*!
+ * SSI Option Register (SOR) bit shift definitions
+ */
+#define SSI_FRAME_SYN_RESET_SHIFT        0
+#define SSI_WAIT_SHIFT                   1
+#define SSI_INIT_SHIFT                   3
+#define SSI_TRANSMITTER_CLEAR_SHIFT      4
+#define SSI_RECEIVER_CLEAR_SHIFT         5
+#define SSI_CLOCK_OFF_SHIFT              6
+#define SSI_WAIT_STATE_MASK            0x3
+
+/*!
+ * SSI AC97 Control Register (SACNT) bit shift definitions
+ */
+#define AC97_MODE_ENABLE_SHIFT           0
+#define AC97_VARIABLE_OPERATION_SHIFT    1
+#define AC97_TAG_IN_FIFO_SHIFT           2
+#define AC97_READ_COMMAND_SHIFT          3
+#define AC97_WRITE_COMMAND_SHIFT         4
+#define AC97_FRAME_RATE_DIVIDER_SHIFT    5
+#define AC97_FRAME_RATE_MASK          0x3F
+
+/*!
+ * SSI Test Register (STR) bit shift definitions
+ */
+#define SSI_TEST_MODE_SHIFT               15
+#define SSI_RCK2TCK_SHIFT                 14
+#define SSI_RFS2TFS_SHIFT                 13
+#define SSI_RXSTATE_SHIFT                 8
+#define SSI_TXD2RXD_SHIFT                 7
+#define SSI_TCK2RCK_SHIFT                 6
+#define SSI_TFS2RFS_SHIFT                 5
+#define SSI_TXSTATE_SHIFT                 0
+
+#endif				/* __MXC_SSI_REGISTERS_H__ */
diff --git a/drivers/mxc/ssi/ssi.c b/drivers/mxc/ssi/ssi.c
new file mode 100644
index 0000000..b0b103e
--- /dev/null
+++ b/drivers/mxc/ssi/ssi.c
@@ -0,0 +1,1208 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ssi.c
+ * @brief This file contains the implementation of the SSI driver main services
+ *
+ *
+ * @ingroup SSI
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+
+#include "registers.h"
+#include "ssi.h"
+
+static spinlock_t ssi_lock;
+
+void set_register_bits(unsigned int mask, unsigned int data,
+		unsigned int offset, unsigned int ssi)
+{
+	volatile unsigned long reg = 0;
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = (ssi == SSI1) ? IO_ADDRESS(SSI1_BASE_ADDR) :
+		IO_ADDRESS(SSI2_BASE_ADDR);
+	reg = __raw_readl(base_addr + offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+}
+
+unsigned long getreg_value(unsigned int offset, unsigned int ssi)
+{
+	volatile unsigned long reg = 0;
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = (ssi == SSI1) ? IO_ADDRESS(SSI1_BASE_ADDR) :
+		IO_ADDRESS(SSI2_BASE_ADDR);
+	reg = __raw_readl(base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+
+	return reg;
+}
+
+void set_register(unsigned int data, unsigned int offset, unsigned int ssi)
+{
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = (ssi == SSI1) ? IO_ADDRESS(SSI1_BASE_ADDR) :
+		IO_ADDRESS(SSI2_BASE_ADDR);
+	__raw_writel(data, base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+
+}
+
+/*!
+ * This function controls the AC97 frame rate divider.
+ *
+ * @param        module               the module number
+ * @param        frame_rate_divider   the AC97 frame rate divider
+ */
+void ssi_ac97_frame_rate_divider(ssi_mod module,
+		unsigned char frame_rate_divider)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	reg |= ((frame_rate_divider & AC97_FRAME_RATE_MASK)
+			<< AC97_FRAME_RATE_DIVIDER_SHIFT);
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_frame_rate_divider);
+
+/*!
+ * This function gets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command address slot information.
+ */
+unsigned int ssi_ac97_get_command_address_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISACADD, module);
+}
+EXPORT_SYMBOL(ssi_ac97_get_command_address_register);
+
+/*!
+ * This function gets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command data slot information.
+ */
+unsigned int ssi_ac97_get_command_data_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISACDAT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_get_command_data_register);
+
+/*!
+ * This function gets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the tag information.
+ */
+unsigned int ssi_ac97_get_tag_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISATAG, module);
+}
+EXPORT_SYMBOL(ssi_ac97_get_tag_register);
+
+/*!
+ * This function controls the AC97 mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 mode
+ * state (enabled or disabled)
+ */
+void ssi_ac97_mode_enable(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true)
+		reg |= (1 << AC97_MODE_ENABLE_SHIFT);
+	else
+		reg &= ~(1 << AC97_MODE_ENABLE_SHIFT);
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_mode_enable);
+
+/*!
+ * This function controls the AC97 tag in FIFO behavior.
+ *
+ * @param        module        the module number
+ * @param        state         the tag in fifo
+ * behavior (Tag info stored in Rx FIFO 0 if true,
+ * Tag info stored in SATAG register otherwise)
+ */
+void ssi_ac97_tag_in_fifo(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true)
+		reg |= (1 << AC97_TAG_IN_FIFO_SHIFT);
+	else
+		reg &= ~(1 << AC97_TAG_IN_FIFO_SHIFT);
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_tag_in_fifo);
+
+/*!
+ * This function controls the AC97 read command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97
+ * command is a read command or not
+ */
+void ssi_ac97_read_command(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true)
+		reg |= (1 << AC97_READ_COMMAND_SHIFT);
+	else
+		reg &= ~(1 << AC97_READ_COMMAND_SHIFT);
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_read_command);
+
+/*!
+ * This function sets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @param        address       the command
+ * address slot information
+ */
+void ssi_ac97_set_command_address_register(ssi_mod module,
+		unsigned int address)
+{
+	set_register(address, MXC_SSISACADD, module);
+}
+EXPORT_SYMBOL(ssi_ac97_set_command_address_register);
+
+/*!
+ * This function sets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @param        data          the command data
+ * slot information
+ */
+void ssi_ac97_set_command_data_register(ssi_mod module,
+		unsigned int data)
+{
+	set_register(data, MXC_SSISACDAT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_set_command_data_register);
+
+/*!
+ * This function sets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @param        tag           the tag information
+ */
+void ssi_ac97_set_tag_register(ssi_mod module, unsigned int tag)
+{
+	set_register(tag, MXC_SSISATAG, module);
+}
+EXPORT_SYMBOL(ssi_ac97_set_tag_register);
+
+/*!
+ * This function controls the AC97 variable mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 variable
+ * mode state (enabled or disabled)
+ */
+void ssi_ac97_variable_mode(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true)
+		reg |= (1 << AC97_VARIABLE_OPERATION_SHIFT);
+	else
+		reg &= ~(1 << AC97_VARIABLE_OPERATION_SHIFT);
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_variable_mode);
+
+/*!
+ * This function controls the AC97 write command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command
+ * is a write command or not
+ */
+void ssi_ac97_write_command(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true)
+		reg |= (1 << AC97_WRITE_COMMAND_SHIFT);
+	else
+		reg &= ~(1 << AC97_WRITE_COMMAND_SHIFT);
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+EXPORT_SYMBOL(ssi_ac97_write_command);
+
+/*!
+ * This function controls the idle state of the
+ * transmit clock port during SSI internal gated mode.
+ *
+ * @param        module        the module number
+ * @param        state         the clock idle state
+ */
+void ssi_clock_idle_state(ssi_mod module, idle_state state)
+{
+	set_register_bits(1 << SSI_CLOCK_IDLE_SHIFT,
+			state << SSI_CLOCK_IDLE_SHIFT, MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_clock_idle_state);
+
+/*!
+ * This function turns off/on the ccm_ssi_clk to
+ * reduce power consumption.
+ *
+ * @param        module        the module number
+ * @param        state         the state for
+ * ccm_ssi_clk (true: turn off, else:turn on)
+ */
+void ssi_clock_off(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_CLOCK_OFF_SHIFT,
+			state << SSI_CLOCK_OFF_SHIFT, MXC_SSISOR, module);
+}
+EXPORT_SYMBOL(ssi_clock_off);
+
+/*!
+ * This function enables/disables the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the state for SSI module
+ */
+void ssi_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_ENABLE_SHIFT,
+			state << SSI_ENABLE_SHIFT, MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_enable);
+
+/*!
+ * This function gets the data word in the
+ * Receive FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the Receive FIFO to read
+ * @return       This function returns the read data.
+ */
+unsigned int ssi_get_data(ssi_mod module, fifo_nb fifo)
+{
+	unsigned int result = 0;
+
+	if (ssi_fifo_0 == fifo)
+		result = getreg_value(MXC_SSISRX0, module);
+	else
+		result = getreg_value(MXC_SSISRX1, module);
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_get_data);
+
+/*!
+ * This function returns the status of the SSI module
+ * (SISR register) as a combination of status.
+ *
+ * @param        module        the module number
+ * @return       This function returns the status of the SSI module
+ */
+ssi_status_enable_mask ssi_get_status(ssi_mod module)
+{
+	unsigned int result;
+
+	result = getreg_value(MXC_SSISISR, module);
+	result &= ((1 << SSI_IRQ_STATUS_NUMBER) - 1);
+
+	return (ssi_status_enable_mask) result;
+}
+EXPORT_SYMBOL(ssi_get_status);
+
+/*!
+ * This function selects the I2S mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mode          the I2S mode
+ */
+void ssi_i2s_mode(ssi_mod module, mode_i2s mode)
+{
+	set_register_bits(3 << SSI_I2S_MODE_SHIFT, mode << SSI_I2S_MODE_SHIFT,
+			MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_i2s_mode);
+
+/*!
+ * This function disables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to disable
+ */
+void ssi_interrupt_disable(ssi_mod module, ssi_status_enable_mask mask)
+{
+	set_register_bits(mask, 0, MXC_SSISIER, module);
+}
+EXPORT_SYMBOL(ssi_interrupt_disable);
+
+/*!
+ * This function enables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to enable
+ */
+void ssi_interrupt_enable(ssi_mod module, ssi_status_enable_mask mask)
+{
+	set_register_bits(0, mask, MXC_SSISIER, module);
+}
+EXPORT_SYMBOL(ssi_interrupt_enable);
+
+/*!
+ * This function enables/disables the network mode
+ * of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the network mode state
+ */
+void ssi_network_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_NETWORK_MODE_SHIFT,
+			state << SSI_NETWORK_MODE_SHIFT, MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_network_mode);
+
+/*!
+ * This function enables/disables the receive
+ * section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the receive section state
+ */
+void ssi_receive_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_RECEIVE_ENABLE_SHIFT,
+			state << SSI_RECEIVE_ENABLE_SHIFT, MXC_SSISCR,
+			module);
+}
+EXPORT_SYMBOL(ssi_receive_enable);
+
+/*!
+ * This function configures the SSI module to receive
+ * data word at bit position 0 or 23 in the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the state to receive at bit 0
+ */
+void ssi_rx_bit0(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_BIT_0_SHIFT, state << SSI_BIT_0_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_bit0);
+
+/*!
+ * This function controls the source of the clock
+ * signal used to clock the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_rx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_CLOCK_DIRECTION_SHIFT,
+			direction << SSI_CLOCK_DIRECTION_SHIFT, MXC_SSISRCR,
+			module);
+}
+EXPORT_SYMBOL(ssi_rx_clock_direction);
+
+/*!
+ * This function configures the divide-by-two divider
+ * of the SSI module for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_rx_clock_divide_by_two(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_DIVIDE_BY_TWO_SHIFT,
+			state << SSI_DIVIDE_BY_TWO_SHIFT, MXC_SSISRCCR,
+			module);
+}
+EXPORT_SYMBOL(ssi_rx_clock_divide_by_two);
+
+/*!
+ * This function controls which bit clock edge is used
+ * to clock in data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_rx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity)
+{
+	set_register_bits(1 << SSI_CLOCK_POLARITY_SHIFT,
+			polarity << SSI_CLOCK_POLARITY_SHIFT, MXC_SSISRCR,
+			module);
+}
+EXPORT_SYMBOL(ssi_rx_clock_polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock
+ * prescaler divider of the SSI module in series with the
+ * variable prescaler for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_rx_clock_prescaler(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_PRESCALER_RANGE_SHIFT,
+			state << SSI_PRESCALER_RANGE_SHIFT,
+			MXC_SSISRCCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_clock_prescaler);
+
+/*!
+ * This function controls the early frame sync configuration.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_rx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early)
+{
+	set_register_bits(1 << SSI_EARLY_FRAME_SYNC_SHIFT,
+			early << SSI_EARLY_FRAME_SYNC_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_early_frame_sync);
+
+/*!
+ * This function gets the number of data words in the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Rx FIFO.
+ */
+unsigned char ssi_rx_fifo_counter(ssi_mod module, fifo_nb fifo)
+{
+	unsigned int temp = 0;
+	unsigned char result;
+	result = 0;
+
+	if (ssi_fifo_0 == fifo) {
+		temp = getreg_value(MXC_SSISFCSR, module);
+		temp &= (0xF << SSI_RX_FIFO_0_COUNT_SHIFT);
+		result = ((temp >> SSI_RX_FIFO_0_COUNT_SHIFT) & 0xff);
+	} else {
+		temp = getreg_value(MXC_SSISFCSR, module);
+		temp &= (0xF << SSI_RX_FIFO_1_COUNT_SHIFT);
+		result = ((temp >> SSI_RX_FIFO_1_COUNT_SHIFT) & 0xff);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_rx_fifo_counter);
+
+/*!
+ * This function enables the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the fifo,
+ * enabled or disabled
+ */
+
+void ssi_rx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable)
+{
+	volatile unsigned int reg;
+
+	reg = getreg_value(MXC_SSISRCR, module);
+	if (enable == true)
+		reg |= ((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	else
+		reg &= ~((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+
+	set_register(reg, MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_fifo_enable);
+
+/*!
+ * This function controls the threshold at which the RFFx
+ * flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the
+ * operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_fifo_full_watermark(ssi_mod module,
+		fifo_nb fifo, unsigned char watermark)
+{
+	int result = -1;
+	result = -1;
+
+	if ((watermark > SSI_MIN_FIFO_WATERMARK) &&
+			(watermark <= SSI_MAX_FIFO_WATERMARK)) {
+		if (ssi_fifo_0 == fifo)
+			set_register_bits(0xf << SSI_RX_FIFO_0_WATERMARK_SHIFT,
+					watermark <<
+					SSI_RX_FIFO_0_WATERMARK_SHIFT,
+					MXC_SSISFCSR, module);
+		else
+			set_register_bits(0xf << SSI_RX_FIFO_1_WATERMARK_SHIFT,
+					watermark <<
+					SSI_RX_FIFO_1_WATERMARK_SHIFT,
+					MXC_SSISFCSR, module);
+
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_rx_fifo_full_watermark);
+
+/*!
+ * This function flushes the Receive FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_rx_flush_fifo(ssi_mod module)
+{
+	set_register_bits(0, 1 << SSI_RECEIVER_CLEAR_SHIFT,
+			MXC_SSISOR, module);
+}
+EXPORT_SYMBOL(ssi_rx_flush_fifo);
+
+/*!
+ * This function controls the direction of the Frame
+ * Sync signal for the receive section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_rx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_FRAME_DIRECTION_SHIFT,
+			direction << SSI_FRAME_DIRECTION_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_frame_direction);
+
+/*!
+ * This function configures the Receive frame rate
+ * divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the
+ * operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_frame_rate(ssi_mod module, unsigned char ratio)
+{
+	int result = -1;
+
+	if ((ratio >= SSI_MIN_FRAME_DIVIDER_RATIO) &&
+			(ratio <= SSI_MAX_FRAME_DIVIDER_RATIO)) {
+		set_register_bits(SSI_FRAME_DIVIDER_MASK <<
+				SSI_FRAME_RATE_DIVIDER_SHIFT,
+				(ratio - 1) << SSI_FRAME_RATE_DIVIDER_SHIFT,
+				MXC_SSISRCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_rx_frame_rate);
+
+/*!
+ * This function controls the Frame Sync active polarity
+ * for the receive section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_rx_frame_sync_active(ssi_mod module,
+		ssi_tx_rx_frame_sync_active active)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_INVERT_SHIFT,
+			active << SSI_FRAME_SYNC_INVERT_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_frame_sync_active);
+
+/*!
+ * This function controls the Frame Sync length
+ * (one word or one bit long) for the receive section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_rx_frame_sync_length(ssi_mod module,
+		ssi_tx_rx_frame_sync_length length)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			length << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_frame_sync_length);
+
+/*!
+ * This function configures the time slot(s) to
+ * mask for the receive section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate
+ * the time slot(s) masked
+ */
+void ssi_rx_mask_time_slot(ssi_mod module, unsigned int mask)
+{
+	set_register_bits(0xFFFFFFFF, mask, MXC_SSISRMSK, module);
+}
+EXPORT_SYMBOL(ssi_rx_mask_time_slot);
+
+/*!
+ * This function configures the Prescale divider
+ * for the receive section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result
+ * of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_prescaler_modulus(ssi_mod module, unsigned int divider)
+{
+	int result = -1;
+
+	if ((divider >= SSI_MIN_PRESCALER_MODULUS_RATIO) &&
+			(divider <= SSI_MAX_PRESCALER_MODULUS_RATIO)) {
+
+		set_register_bits(SSI_PRESCALER_MODULUS_MASK <<
+				SSI_PRESCALER_MODULUS_SHIFT,
+				(divider - 1) << SSI_PRESCALER_MODULUS_SHIFT,
+				MXC_SSISRCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_rx_prescaler_modulus);
+
+/*!
+ * This function controls whether the MSB or LSB
+ * will be received first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_rx_shift_direction(ssi_mod module, ssi_tx_rx_shift_direction direction)
+{
+	set_register_bits(1 << SSI_SHIFT_DIRECTION_SHIFT,
+			direction << SSI_SHIFT_DIRECTION_SHIFT,
+			MXC_SSISRCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_shift_direction);
+
+/*!
+ * This function configures the Receive word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_rx_word_length(ssi_mod module,
+		ssi_word_length length)
+{
+	set_register_bits(SSI_WORD_LENGTH_MASK << SSI_WORD_LENGTH_SHIFT,
+			length << SSI_WORD_LENGTH_SHIFT,
+			MXC_SSISRCCR, module);
+}
+EXPORT_SYMBOL(ssi_rx_word_length);
+
+/*!
+ * This function sets the data word in the Transmit
+ * FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the FIFO number
+ * @param        data          the data to load in the FIFO
+ */
+
+void ssi_set_data(ssi_mod module, fifo_nb fifo, unsigned int data)
+{
+	if (ssi_fifo_0 == fifo)
+		set_register(data, MXC_SSISTX0, module);
+	else
+		set_register(data, MXC_SSISTX1, module);
+}
+EXPORT_SYMBOL(ssi_set_data);
+
+/*!
+ * This function controls the number of wait states
+ * between the core and SSI.
+ *
+ * @param        module        the module number
+ * @param        wait          the number of wait state(s)
+ */
+void ssi_set_wait_states(ssi_mod module, ssi_wait_states wait)
+{
+	set_register_bits(SSI_WAIT_STATE_MASK << SSI_WAIT_SHIFT,
+			wait << SSI_WAIT_SHIFT, MXC_SSISOR, module);
+}
+EXPORT_SYMBOL(ssi_set_wait_states);
+
+/*!
+ * This function enables/disables the synchronous mode
+ * of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the synchronous mode state
+ */
+void ssi_synchronous_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_SYNCHRONOUS_MODE_SHIFT,
+			state << SSI_SYNCHRONOUS_MODE_SHIFT,
+			MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_synchronous_mode);
+
+/*!
+ * This function allows the SSI module to output the
+ * SYS_CLK at the SRCK port.
+ *
+ * @param        module        the module number
+ * @param        state         the system clock state
+ */
+void ssi_system_clock(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_SYSTEM_CLOCK_SHIFT,
+			state << SSI_SYSTEM_CLOCK_SHIFT, MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_system_clock);
+
+/*!
+ * This function enables/disables the transmit section
+ * of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit section state
+ */
+void ssi_transmit_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_TRANSMIT_ENABLE_SHIFT,
+			state << SSI_TRANSMIT_ENABLE_SHIFT,
+			MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_transmit_enable);
+
+/*!
+ * This function allows the SSI module to operate in the
+ * two channel mode.
+ *
+ * @param        module        the module number
+ * @param        state         the two channel mode state
+ */
+void ssi_two_channel_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_TWO_CHANNEL_SHIFT,
+			state << SSI_TWO_CHANNEL_SHIFT, MXC_SSISCR, module);
+}
+EXPORT_SYMBOL(ssi_two_channel_mode);
+
+/*!
+ * This function configures the SSI module to transmit data
+ * word from bit position 0 or 23 in the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit from bit 0 state
+ */
+void ssi_tx_bit0(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_BIT_0_SHIFT,
+			state << SSI_BIT_0_SHIFT, MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_bit0);
+
+/*!
+ * This function controls the direction of the clock signal used
+ * to clock the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_tx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_CLOCK_DIRECTION_SHIFT,
+			direction << SSI_CLOCK_DIRECTION_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_clock_direction);
+
+/*!
+ * This function configures the divide-by-two divider of the
+ * SSI module for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_tx_clock_divide_by_two(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_DIVIDE_BY_TWO_SHIFT,
+			state << SSI_DIVIDE_BY_TWO_SHIFT,
+			MXC_SSISTCCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_clock_divide_by_two);
+
+/*!
+ * This function controls which bit clock edge is used to
+ * clock out data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_tx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity)
+{
+	set_register_bits(1 << SSI_CLOCK_POLARITY_SHIFT,
+			polarity << SSI_CLOCK_POLARITY_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_clock_polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock
+ * prescaler divider of the SSI module in series with the
+ * variable prescaler for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_tx_clock_prescaler(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_PRESCALER_RANGE_SHIFT,
+			state << SSI_PRESCALER_RANGE_SHIFT,
+			MXC_SSISTCCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_clock_prescaler);
+
+/*!
+ * This function controls the early frame sync
+ * configuration for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_tx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early)
+{
+	set_register_bits(1 << SSI_EARLY_FRAME_SYNC_SHIFT,
+			early << SSI_EARLY_FRAME_SYNC_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_early_frame_sync);
+
+/*!
+ * This function gets the number of data words in the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Tx FIFO.
+ */
+unsigned char ssi_tx_fifo_counter(ssi_mod module, fifo_nb fifo)
+{
+	unsigned int temp = 0;
+	unsigned char result = 0;
+
+	if (ssi_fifo_0 == fifo) {
+		temp = getreg_value(MXC_SSISFCSR, module);
+		temp &= (0xF << SSI_TX_FIFO_0_COUNT_SHIFT);
+		result = ((temp >> SSI_TX_FIFO_0_COUNT_SHIFT) & 0xff);
+
+	} else {
+		temp = getreg_value(MXC_SSISFCSR, module);
+		temp &= (0xF << SSI_TX_FIFO_1_COUNT_SHIFT);
+		result = ((temp >> SSI_TX_FIFO_1_COUNT_SHIFT) & 0xff);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_tx_fifo_counter);
+
+/*!
+ * This function controls the threshold at which the TFEx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result
+ * of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_fifo_empty_watermark(ssi_mod module,
+		fifo_nb fifo, unsigned char watermark)
+{
+	int result = -1;
+
+	if ((watermark > SSI_MIN_FIFO_WATERMARK) &&
+			(watermark <= SSI_MAX_FIFO_WATERMARK)) {
+		if (ssi_fifo_0 == fifo) {
+			set_register_bits(0xf << SSI_TX_FIFO_0_WATERMARK_SHIFT,
+					watermark <<
+					SSI_TX_FIFO_0_WATERMARK_SHIFT,
+					MXC_SSISFCSR, module);
+		} else {
+			set_register_bits(0xf << SSI_TX_FIFO_1_WATERMARK_SHIFT,
+					watermark <<
+					SSI_TX_FIFO_1_WATERMARK_SHIFT,
+					MXC_SSISFCSR, module);
+		}
+
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_tx_fifo_empty_watermark);
+
+/*!
+ * This function enables the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the fifo,
+ * enabled or disabled
+ */
+
+void ssi_tx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable)
+{
+	unsigned int reg;
+
+	reg = getreg_value(MXC_SSISTCR, module);
+	if (enable == true)
+		reg |= ((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	else
+		reg &= ~((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+
+	set_register(reg, MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_fifo_enable);
+
+/*!
+ * This function flushes the Transmit FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_tx_flush_fifo(ssi_mod module)
+{
+	set_register_bits(0, 1 << SSI_TRANSMITTER_CLEAR_SHIFT,
+			MXC_SSISOR, module);
+}
+EXPORT_SYMBOL(ssi_tx_flush_fifo);
+
+/*!
+ * This function controls the direction of the Frame Sync
+ * signal for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_tx_frame_direction(ssi_mod module,
+		ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_FRAME_DIRECTION_SHIFT,
+			direction << SSI_FRAME_DIRECTION_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_frame_direction);
+
+/*!
+ * This function configures the Transmit frame rate divider.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the
+ * operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_frame_rate(ssi_mod module, unsigned char ratio)
+{
+	int result = -1;
+
+	if ((ratio >= SSI_MIN_FRAME_DIVIDER_RATIO) &&
+			(ratio <= SSI_MAX_FRAME_DIVIDER_RATIO)) {
+
+		set_register_bits(SSI_FRAME_DIVIDER_MASK <<
+				SSI_FRAME_RATE_DIVIDER_SHIFT,
+				(ratio - 1) << SSI_FRAME_RATE_DIVIDER_SHIFT,
+				MXC_SSISTCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_tx_frame_rate);
+
+/*!
+ * This function controls the Frame Sync active polarity
+ * for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_tx_frame_sync_active(ssi_mod module,
+		ssi_tx_rx_frame_sync_active active)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_INVERT_SHIFT,
+			active << SSI_FRAME_SYNC_INVERT_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_frame_sync_active);
+
+/*!
+ * This function controls the Frame Sync length (one word or
+ * one bit long) for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_tx_frame_sync_length(ssi_mod module,
+		ssi_tx_rx_frame_sync_length length)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			length << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_frame_sync_length);
+
+/*!
+ * This function configures the time slot(s) to mask for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time
+ * slot(s) masked
+ */
+void ssi_tx_mask_time_slot(ssi_mod module, unsigned int mask)
+{
+	set_register_bits(0xFFFFFFFF, mask, MXC_SSISTMSK, module);
+}
+EXPORT_SYMBOL(ssi_tx_mask_time_slot);
+
+/*!
+ * This function configures the Prescale divider for the
+ * transmit section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the
+ * operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_prescaler_modulus(ssi_mod module, unsigned int divider)
+{
+	int result = -1;
+
+	if ((divider >= SSI_MIN_PRESCALER_MODULUS_RATIO) &&
+			(divider <= SSI_MAX_PRESCALER_MODULUS_RATIO)) {
+
+		set_register_bits(SSI_PRESCALER_MODULUS_MASK <<
+				SSI_PRESCALER_MODULUS_SHIFT,
+				(divider - 1) << SSI_PRESCALER_MODULUS_SHIFT,
+				MXC_SSISTCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ssi_tx_prescaler_modulus);
+
+/*!
+ * This function controls whether the MSB or LSB will be
+ * transmitted first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_tx_shift_direction(ssi_mod module,
+		ssi_tx_rx_shift_direction direction)
+{
+	set_register_bits(1 << SSI_SHIFT_DIRECTION_SHIFT,
+			direction << SSI_SHIFT_DIRECTION_SHIFT,
+			MXC_SSISTCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_shift_direction);
+
+/*!
+ * This function configures the Transmit word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_tx_word_length(ssi_mod module, ssi_word_length length)
+{
+	set_register_bits(SSI_WORD_LENGTH_MASK << SSI_WORD_LENGTH_SHIFT,
+			length << SSI_WORD_LENGTH_SHIFT,
+			MXC_SSISTCCR, module);
+}
+EXPORT_SYMBOL(ssi_tx_word_length);
+
+/*!
+ * This function implements the init function of the SSI device.
+ * This function is called when the module is loaded.
+ *
+ * @return       This function returns 0.
+ */
+static int __init ssi_init(void)
+{
+	spin_lock_init(&ssi_lock);
+	printk(KERN_INFO "SSI module loaded successfully\n");
+	return 0;
+}
+
+/*!
+ * This function implements the exit function of the SPI device.
+ * This function is called when the module is unloaded.
+ *
+ */
+static void __exit ssi_exit(void)
+{
+	printk(KERN_INFO "SSI module unloaded successfully\n");
+}
+
+module_init(ssi_init);
+module_exit(ssi_exit);
+
+MODULE_DESCRIPTION("SSI char device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/ssi/ssi.h b/drivers/mxc/ssi/ssi.h
new file mode 100644
index 0000000..6bb408e
--- /dev/null
+++ b/drivers/mxc/ssi/ssi.h
@@ -0,0 +1,606 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @defgroup SSI Synchronous Serial Interface (SSI) Driver
+  */
+
+ /*!
+  * @file ssi.h
+  * @brief This header file contains SSI driver functions prototypes.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_H__
+#define __MXC_SSI_H__
+
+#include "ssi_types.h"
+
+/*!
+ * This function controls the AC97 frame rate divider.
+ *
+ * @param        module               the module number
+ * @param        frame_rate_divider   the AC97 frame rate divider
+ */
+void ssi_ac97_frame_rate_divider(ssi_mod module,
+				 unsigned char frame_rate_divider);
+
+/*!
+ * This function gets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command
+ * address slot information.
+ */
+unsigned int ssi_ac97_get_command_address_register(ssi_mod module);
+
+/*!
+ * This function gets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command
+ * data slot information.
+ */
+unsigned int ssi_ac97_get_command_data_register(ssi_mod module);
+
+/*!
+ * This function gets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the tag information.
+ */
+unsigned int ssi_ac97_get_tag_register(ssi_mod module);
+
+/*!
+ * This function controls the AC97 mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 mode state
+ * (enabled or disabled)
+ */
+void ssi_ac97_mode_enable(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 tag in FIFO behavior.
+ *
+ * @param        module        the module number
+ * @param        state         the tag in fifo behavior
+ * (Tag info stored in Rx FIFO 0 if TRUE,
+ * Tag info stored in SATAG register otherwise)
+ */
+void ssi_ac97_tag_in_fifo(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 read command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command
+ * is a read command or not
+ */
+void ssi_ac97_read_command(ssi_mod module, bool state);
+
+/*!
+ * This function sets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @param        address       the command address slot information
+ */
+void ssi_ac97_set_command_address_register(ssi_mod module,
+					   unsigned int address);
+
+/*!
+ * This function sets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @param        data          the command data slot information
+ */
+void ssi_ac97_set_command_data_register(ssi_mod module,
+		unsigned int data);
+
+/*!
+ * This function sets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @param        tag           the tag information
+ */
+void ssi_ac97_set_tag_register(ssi_mod module, unsigned int tag);
+
+/*!
+ * This function controls the AC97 variable mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 variable mode
+ * state (enabled or disabled)
+ */
+void ssi_ac97_variable_mode(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 write command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command is
+ * a write command or not
+ */
+void ssi_ac97_write_command(ssi_mod module, bool state);
+
+/*!
+ * This function controls the idle state of the transmit
+ * clock port during SSI internal gated mode.
+ *
+ * @param        module        the module number
+ * @param        state         the clock idle state
+ */
+void ssi_clock_idle_state(ssi_mod module, idle_state state);
+
+/*!
+ * This function turns off/on the ccm_ssi_clk to reduce power consumption.
+ *
+ * @param        module        the module number
+ * @param        state         the state for ccm_ssi_clk
+ * (true: turn off, else:turn on)
+ */
+void ssi_clock_off(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the state for SSI module
+ */
+void ssi_enable(ssi_mod module, bool state);
+
+/*!
+ * This function gets the data word in the Receive FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the Receive FIFO to read
+ * @return       This function returns the read data.
+ */
+unsigned int ssi_get_data(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function returns the status of the SSI module
+ * (SISR register) as a combination of status.
+ *
+ * @param        module        the module number
+ * @return       This function returns the status of the SSI module.
+ */
+ssi_status_enable_mask ssi_get_status(ssi_mod module);
+
+/*!
+ * This function selects the I2S mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mode          the I2S mode
+ */
+void ssi_i2s_mode(ssi_mod module, mode_i2s mode);
+
+/*!
+ * This function disables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to disable
+ */
+void ssi_interrupt_disable(ssi_mod module, ssi_status_enable_mask mask);
+
+/*!
+ * This function enables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to enable
+ */
+void ssi_interrupt_enable(ssi_mod module, ssi_status_enable_mask mask);
+
+/*!
+ * This function enables/disables the network mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the network mode state
+ */
+void ssi_network_mode(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the receive section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the receive section state
+ */
+void ssi_receive_enable(ssi_mod module, bool state);
+
+/*!
+ * This function configures the SSI module to receive
+ * data word at bit position 0 or 23 in the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the state to receive at bit 0
+ */
+void ssi_rx_bit0(ssi_mod module, bool state);
+
+/*!
+ * This function controls the source of the clock signal
+ * used to clock the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_rx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the divide-by-two divider
+ * of the SSI module for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_rx_clock_divide_by_two(ssi_mod module, bool state);
+
+/*!
+ * This function controls which bit clock edge is used to clock in data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_rx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock
+ * prescaler divider of the SSI module in series with the
+ * variable prescaler for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_rx_clock_prescaler(ssi_mod module, bool state);
+
+/*!
+ * This function controls the early frame sync configuration.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_rx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early);
+
+/*!
+ * This function gets the number of data words in the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Rx FIFO.
+ */
+unsigned char ssi_rx_fifo_counter(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function enables the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enabled       the state of the fifo, enabled or disabled
+ */
+void ssi_rx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enabled);
+
+/*!
+ * This function controls the threshold at which the RFFx
+ * flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the
+ * operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_fifo_full_watermark(ssi_mod module,
+			       fifo_nb fifo, unsigned char watermark);
+
+/*!
+ * This function flushes the Receive FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_rx_flush_fifo(ssi_mod module);
+
+/*!
+ * This function controls the direction of the Frame Sync signal
+ * for the receive section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_rx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the Receive frame rate divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation
+ * (0 if successful, -1 otherwise).
+ */
+int ssi_rx_frame_rate(ssi_mod module, unsigned char ratio);
+
+/*!
+ * This function controls the Frame Sync active polarity for
+ * the receive section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_rx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active);
+
+/*!
+ * This function controls the Frame Sync length
+ * (one word or one bit long) for the receive section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_rx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length);
+
+/*!
+ * This function configures the time slot(s) to mask for
+ * the receive section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time slot(s) masked
+ */
+void ssi_rx_mask_time_slot(ssi_mod module, unsigned int mask);
+
+/*!
+ * This function configures the Prescale divider for the
+ * receive section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation
+ * (0 if successful, -1 otherwise).
+ */
+int ssi_rx_prescaler_modulus(ssi_mod module, unsigned int divider);
+
+/*!
+ * This function controls whether the MSB or LSB will be received
+ * first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_rx_shift_direction(ssi_mod module,
+			    ssi_tx_rx_shift_direction direction);
+
+/*!
+ * This function configures the Receive word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_rx_word_length(ssi_mod module, ssi_word_length length);
+
+/*!
+ * This function sets the data word in the Transmit FIFO of
+ * the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the FIFO number
+ * @param        data          the data to load in the FIFO
+ */
+void ssi_set_data(ssi_mod module, fifo_nb fifo, unsigned int data);
+
+/*!
+ * This function controls the number of wait states between the core and SSI.
+ *
+ * @param        module        the module number
+ * @param        wait          the number of wait state(s)
+ */
+void ssi_set_wait_states(ssi_mod module, ssi_wait_states wait);
+
+/*!
+ * This function enables/disables the synchronous mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the synchronous mode state
+ */
+void ssi_synchronous_mode(ssi_mod module, bool state);
+
+/*!
+ * This function allows the SSI module to output the SYS_CLK at the SRCK port.
+ *
+ * @param        module        the module number
+ * @param        state         the system clock state
+ */
+void ssi_system_clock(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the transmit section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit section state
+ */
+void ssi_transmit_enable(ssi_mod module, bool state);
+
+/*!
+ * This function allows the SSI module to operate in the two channel mode.
+ *
+ * @param        module        the module number
+ * @param        state         the two channel mode state
+ */
+void ssi_two_channel_mode(ssi_mod module, bool state);
+
+/*!
+ * This function configures the SSI module to transmit data word
+ * from bit position 0 or 23 in the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit from bit 0 state
+ */
+void ssi_tx_bit0(ssi_mod module, bool state);
+
+/*!
+ * This function controls the direction of the clock signal used to
+ * clock the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_tx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the divide-by-two divider of the SSI
+ * module for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_tx_clock_divide_by_two(ssi_mod module, bool state);
+
+/*!
+ * This function controls which bit clock edge is used to clock out data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_tx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock prescaler
+ * divider of the SSI module in series with the variable prescaler
+ * for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_tx_clock_prescaler(ssi_mod module, bool state);
+
+/*!
+ * This function controls the early frame sync configuration for
+ * the transmit section.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_tx_early_frame_sync(ssi_mod module,
+		ssi_tx_rx_early_frame_sync early);
+
+/*!
+ * This function gets the number of data words in the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Tx FIFO.
+ */
+unsigned char ssi_tx_fifo_counter(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function controls the threshold at which the TFEx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the operation
+ * (0 if successful, -1 otherwise).
+ */
+int ssi_tx_fifo_empty_watermark(ssi_mod module, fifo_nb fifo,
+				unsigned char watermark);
+
+/*!
+ * This function enables the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the FIFO, enabled or disabled
+ */
+void ssi_tx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable);
+
+/*!
+ * This function flushes the Transmit FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_tx_flush_fifo(ssi_mod module);
+
+/*!
+ * This function controls the direction of the Frame Sync
+ * signal for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_tx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the Transmit frame rate divider.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation
+ * (0 if successful, -1 otherwise).
+ */
+int ssi_tx_frame_rate(ssi_mod module, unsigned char ratio);
+
+/*!
+ * This function controls the Frame Sync active polarity for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_tx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active);
+
+/*!
+ * This function controls the Frame Sync length
+ * (one word or one bit long) for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_tx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length);
+
+/*!
+ * This function configures the time slot(s) to mask for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the
+ * time slot(s) masked
+ */
+void ssi_tx_mask_time_slot(ssi_mod module, unsigned int mask);
+
+/*!
+ * This function configures the Prescale divider for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation
+ * (0 if successful, -1 otherwise).
+ */
+int ssi_tx_prescaler_modulus(ssi_mod module, unsigned int divider);
+
+/*!
+ * This function controls whether the MSB or LSB will be
+ * transmited first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_tx_shift_direction(ssi_mod module,
+			    ssi_tx_rx_shift_direction direction);
+
+/*!
+ * This function configures the Transmit word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_tx_word_length(ssi_mod module, ssi_word_length length);
+
+#endif				/* __MXC_SSI_H__ */
diff --git a/drivers/mxc/ssi/ssi_types.h b/drivers/mxc/ssi/ssi_types.h
new file mode 100644
index 0000000..c587334
--- /dev/null
+++ b/drivers/mxc/ssi/ssi_types.h
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file ssi_types.h
+  * @brief This header file contains SSI types.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_TYPES_H__
+#define __MXC_SSI_TYPES_H__
+
+/*!
+ * This enumeration describes the FIFO number.
+ */
+typedef enum {
+	/*!
+	 * FIFO 0
+	 */
+	ssi_fifo_0 = 0,
+	/*!
+	 * FIFO 1
+	 */
+	ssi_fifo_1 = 1
+} fifo_nb;
+
+/*!
+ * This enumeration describes the clock idle state.
+ */
+typedef enum {
+	/*!
+	 * Clock idle state is 1
+	 */
+	clock_idle_state_1 = 0,
+	/*!
+	 * Clock idle state is 0
+	 */
+	clock_idle_state_0 = 1
+} idle_state;
+
+/*!
+ * This enumeration describes I2S mode.
+ */
+typedef enum {
+	/*!
+	 * Normal mode
+	 */
+	i2s_normal = 0,
+	/*!
+	 * Master mode
+	 */
+	i2s_master = 1,
+	/*!
+	 * Slave mode
+	 */
+	i2s_slave = 2
+} mode_i2s;
+
+/*!
+ * This enumeration describes index for both SSI1 and SSI2 modules.
+ */
+typedef enum {
+	/*!
+	 * SSI1 index
+	 */
+	SSI1 = 0,
+	/*!
+	 * SSI2 index
+	 */
+	SSI2 = 1
+} ssi_mod;
+
+/*!
+ * This enumeration describes the status/enable bits for
+ * interrupt source of the SSI module.
+ */
+typedef enum {
+	/*!
+	 * SSI Transmit FIFO 0 empty bit
+	 */
+	ssi_tx_fifo_0_empty = 0x00000001,
+	/*!
+	 * SSI Transmit FIFO 1 empty bit
+	 */
+	ssi_tx_fifo_1_empty = 0x00000002,
+	/*!
+	 * SSI Receive FIFO 0 full bit
+	 */
+	ssi_rx_fifo_0_full = 0x00000004,
+	/*!
+	 * SSI Receive FIFO 1 full bit
+	 */
+	ssi_rx_fifo_1_full = 0x00000008,
+	/*!
+	 * SSI Receive Last Time Slot bit
+	 */
+	ssi_rls = 0x00000010,
+	/*!
+	 * SSI Transmit Last Time Slot bit
+	 */
+	ssi_tls = 0x00000020,
+	/*!
+	 * SSI Receive Frame Sync bit
+	 */
+	ssi_rfs = 0x00000040,
+	/*!
+	 * SSI Transmit Frame Sync bit
+	 */
+	ssi_tfs = 0x00000080,
+	/*!
+	 * SSI Transmitter underrun 0 bit
+	 */
+	ssi_transmitter_underrun_0 = 0x00000100,
+	/*!
+	 * SSI Transmitter underrun 1 bit
+	 */
+	ssi_transmitter_underrun_1 = 0x00000200,
+	/*!
+	 * SSI Receiver overrun 0 bit
+	 */
+	ssi_receiver_overrun_0 = 0x00000400,
+	/*!
+	 * SSI Receiver overrun 1 bit
+	 */
+	ssi_receiver_overrun_1 = 0x00000800,
+	/*!
+	 * SSI Transmit Data register empty 0 bit
+	 */
+	ssi_tx_data_reg_empty_0 = 0x00001000,
+	/*!
+	 * SSI Transmit Data register empty 1 bit
+	 */
+	ssi_tx_data_reg_empty_1 = 0x00002000,
+
+	/*!
+	 * SSI Receive Data Ready 0 bit
+	 */
+	ssi_rx_data_ready_0 = 0x00004000,
+	/*!
+	 * SSI Receive Data Ready 1 bit
+	 */
+	ssi_rx_data_ready_1 = 0x00008000,
+	/*!
+	 * SSI Receive tag updated bit
+	 */
+	ssi_rx_tag_updated = 0x00010000,
+	/*!
+	 * SSI Command data register updated bit
+	 */
+	ssi_cmd_data_reg_updated = 0x00020000,
+	/*!
+	 * SSI Command address register updated bit
+	 */
+	ssi_cmd_address_reg_updated = 0x00040000,
+	/*!
+	 * SSI Transmit interrupt enable bit
+	 */
+	ssi_tx_interrupt_enable = 0x00080000,
+	/*!
+	 * SSI Transmit DMA enable bit
+	 */
+	ssi_tx_dma_interrupt_enable = 0x00100000,
+	/*!
+	 * SSI Receive interrupt enable bit
+	 */
+	ssi_rx_interrupt_enable = 0x00200000,
+	/*!
+	 * SSI Receive DMA enable bit
+	 */
+	ssi_rx_dma_interrupt_enable = 0x00400000
+} ssi_status_enable_mask;
+
+/*!
+ * This enumeration describes the clock edge to clock in
+ * or clock out data.
+ */
+typedef enum {
+	/*!
+	 * Clock on rising edge
+	 */
+	ssi_clock_on_rising_edge = 0,
+	/*!
+	 * Clock on falling edge
+	 */
+	ssi_clock_on_falling_edge = 1
+} ssi_tx_rx_clock_polarity;
+
+/*!
+ * This enumeration describes the clock direction.
+ */
+typedef enum {
+	/*!
+	 * Clock is external
+	 */
+	ssi_tx_rx_externally = 0,
+	/*!
+	 * Clock is generated internally
+	 */
+	ssi_tx_rx_internally = 1
+} ssi_tx_rx_direction;
+
+/*!
+ * This enumeration describes the early frame sync behavior.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync starts on the first data bit
+	 */
+	ssi_frame_sync_first_bit = 0,
+	/*!
+	 * Frame Sync starts one bit before the first data bit
+	 */
+	ssi_frame_sync_one_bit_before = 1
+} ssi_tx_rx_early_frame_sync;
+
+/*!
+ * This enumeration describes the Frame Sync active value.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync is active when high
+	 */
+	ssi_frame_sync_active_high = 0,
+	/*!
+	 * Frame Sync is active when low
+	 */
+	ssi_frame_sync_active_low = 1
+} ssi_tx_rx_frame_sync_active;
+
+/*!
+ * This enumeration describes the Frame Sync active length.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync is active when high
+	 */
+	ssi_frame_sync_one_word = 0,
+	/*!
+	 * Frame Sync is active when low
+	 */
+	ssi_frame_sync_one_bit = 1
+} ssi_tx_rx_frame_sync_length;
+
+/*!
+ * This enumeration describes the Tx/Rx frame shift direction.
+ */
+typedef enum {
+	/*!
+	 * MSB first
+	 */
+	ssi_msb_first = 0,
+	/*!
+	 * LSB first
+	 */
+	ssi_lsb_first = 1
+} ssi_tx_rx_shift_direction;
+
+/*!
+ * This enumeration describes the wait state number.
+ */
+typedef enum {
+	/*!
+	 * 0 wait state
+	 */
+	ssi_waitstates0 = 0x0,
+	/*!
+	 * 1 wait state
+	 */
+	ssi_waitstates1 = 0x1,
+	/*!
+	 * 2 wait states
+	 */
+	ssi_waitstates2 = 0x2,
+	/*!
+	 * 3 wait states
+	 */
+	ssi_waitstates3 = 0x3
+} ssi_wait_states;
+
+/*!
+ * This enumeration describes the word length.
+ */
+typedef enum {
+	/*!
+	 * 2 bits long
+	 */
+	ssi_2_bits = 0x0,
+	/*!
+	 * 4 bits long
+	 */
+	ssi_4_bits = 0x1,
+	/*!
+	 * 6 bits long
+	 */
+	ssi_6_bits = 0x2,
+	/*!
+	 * 8 bits long
+	 */
+	ssi_8_bits = 0x3,
+	/*!
+	 * 10 bits long
+	 */
+	ssi_10_bits = 0x4,
+	/*!
+	 * 12 bits long
+	 */
+	ssi_12_bits = 0x5,
+	/*!
+	 * 14 bits long
+	 */
+	ssi_14_bits = 0x6,
+	/*!
+	 * 16 bits long
+	 */
+	ssi_16_bits = 0x7,
+	/*!
+	 * 18 bits long
+	 */
+	ssi_18_bits = 0x8,
+	/*!
+	 * 20 bits long
+	 */
+	ssi_20_bits = 0x9,
+	/*!
+	 * 22 bits long
+	 */
+	ssi_22_bits = 0xA,
+	/*!
+	 * 24 bits long
+	 */
+	ssi_24_bits = 0xB,
+	/*!
+	 * 26 bits long
+	 */
+	ssi_26_bits = 0xC,
+	/*!
+	 * 28 bits long
+	 */
+	ssi_28_bits = 0xD,
+	/*!
+	 * 30 bits long
+	 */
+	ssi_30_bits = 0xE,
+	/*!
+	 * 32 bits long
+	 */
+	ssi_32_bits = 0xF
+} ssi_word_length;
+
+#endif				/* __MXC_SSI_TYPES_H__ */
-- 
1.5.5.1

