From c045d6c4b0afbba36a9488c8baeb2123b4d0d62f Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vbarinov@embeddedalley.com>
Date: Tue, 3 Feb 2009 18:49:21 +0300
Subject: [PATCH] ISP1301 USB transeiver support

IMX: add isp1301 usb transeiver support for IMX platforms

Signed-off-by: Vladimir Barinov <vbarinov@embeddedalley.com>
---
 arch/arm/plat-mxc/Kconfig                |    5 +
 arch/arm/plat-mxc/Makefile               |    1 +
 arch/arm/plat-mxc/include/mach/isp1301.h |   23 +++
 arch/arm/plat-mxc/isp1301.c              |  247 ++++++++++++++++++++++++++++++
 4 files changed, 276 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/isp1301.h
 create mode 100644 arch/arm/plat-mxc/isp1301.c

diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index e14eaad..acb916e 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -23,4 +23,9 @@ source "arch/arm/mach-mx3/Kconfig"
 
 endmenu
 
+config MXC_ISP1301
+	bool "ISP1301 USB transeiver"
+	depends on I2C
+	default y if MACH_MX27ADS
+
 endif
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 89d48ee..4400f67 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -8,3 +8,4 @@ obj-y := irq.o clock.o gpio.o time.o
 obj-$(CONFIG_ARCH_MX2) += iomux-mx1-mx2.o
 obj-$(CONFIG_ARCH_MX3) += cpu_common.o spba.o
 obj-$(CONFIG_MXC_SDMA_API)  += sdma/
+obj-$(CONFIG_MXC_ISP1301) += isp1301.o
\ No newline at end of file
diff --git a/arch/arm/plat-mxc/include/mach/isp1301.h b/arch/arm/plat-mxc/include/mach/isp1301.h
new file mode 100644
index 0000000..0918cb1
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/isp1301.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __MACH_ISP1301_H
+#define __MACH_ISP1301_H
+
+void isp1301_set_host_dev(int bidi, int se);
+void isp1301_set_serial_dev(int bidi, int se);
+void isp1301_pullup(int on);
+void isp1301_set_vbus_power(int on);
+
+#endif /* __MACH_ISP1301_H */
diff --git a/arch/arm/plat-mxc/isp1301.c b/arch/arm/plat-mxc/isp1301.c
new file mode 100644
index 0000000..07e0c77
--- /dev/null
+++ b/arch/arm/plat-mxc/isp1301.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+
+/*
+ * ISP1301 register addresses,all register of ISP1301
+ * is one-byte length register
+ */
+
+/* ISP1301: I2C device address */
+#define ISP1301_DEV_ADDR 		0x2D
+
+/* ISP 1301 register set*/
+#define ISP1301_MODE_REG1_SET		0x04
+#define ISP1301_MODE_REG1_CLR		0x05
+
+#define ISP1301_CTRL_REG1_SET		0x06
+#define ISP1301_CTRL_REG1_CLR		0x07
+
+#define ISP1301_INT_SRC_REG		0x08
+#define ISP1301_INT_LAT_REG_SET		0x0a
+#define ISP1301_INT_LAT_REG_CLR		0x0b
+#define ISP1301_INT_FALSE_REG_SET	0x0c
+#define ISP1301_INT_FALSE_REG_CLR	0x0d
+#define ISP1301_INT_TRUE_REG_SET	0x0e
+#define ISP1301_INT_TRUE_REG_CLR	0x0f
+
+#define ISP1301_CTRL_REG2_SET		0x10
+#define ISP1301_CTRL_REG2_CLR		0x11
+
+#define ISP1301_MODE_REG2_SET		0x12
+#define ISP1301_MODE_REG2_CLR		0x13
+
+#define ISP1301_BCD_DEV_REG0		0x14
+#define ISP1301_BCD_DEV_REG1		0x15
+
+/* OTG Control register bit description */
+#define DP_PULLUP			0x01
+#define DM_PULLUP			0x02
+#define DP_PULLDOWN			0x04
+#define DM_PULLDOWN			0x08
+#define ID_PULLDOWN			0x10
+#define VBUS_DRV			0x20
+#define VBUS_DISCHRG			0x40
+#define VBUS_CHRG			0x80
+
+/* Mode Control 1 register bit description */
+#define SPEED_REG  			0x01
+#define SUSPEND_REG			0x02
+#define DAT_SE0				0x04
+#define TRANSP_EN			0x08
+#define BDIS_ACON_EN			0x10
+#define OE_INT_EN			0x20
+#define UART_EN				0x40
+
+/* Mode Control 2 register bit description */
+#define SPD_SUSP_CTRL			0x02
+#define BI_DI	  			0x04
+
+static int isp1301_attach(struct i2c_adapter *adapter);
+static int isp1301_detach(struct i2c_client *client);
+
+static struct i2c_driver isp1301_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "isp1301 Client",
+		   },
+	.attach_adapter = isp1301_attach,
+	.detach_client = isp1301_detach,
+};
+
+static struct i2c_client isp1301_i2c_client = {
+	.name = "isp1301 I2C dev",
+	.addr = ISP1301_DEV_ADDR,
+	.driver = &isp1301_i2c_driver,
+};
+
+static unsigned short normal_i2c[] = { ISP1301_DEV_ADDR, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static int isp1301_detect_client(struct i2c_adapter *adapter, int address,
+				 int kind)
+{
+	isp1301_i2c_client.adapter = adapter;
+	if (i2c_attach_client(&isp1301_i2c_client)) {
+		isp1301_i2c_client.adapter = NULL;
+		printk(KERN_ERR "isp1301_attach: i2c_attach_client failed\n");
+		return -1;
+	}
+
+	printk(KERN_INFO "isp1301 Detected\n");
+	return 0;
+}
+
+/*!
+ * isp1301 I2C attach function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_attach(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, &isp1301_detect_client);
+}
+
+/*!
+ * isp1301 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_detach(struct i2c_client *client)
+{
+	int err;
+
+	if (!isp1301_i2c_client.adapter)
+		return -1;
+
+	err = i2c_detach_client(&isp1301_i2c_client);
+	isp1301_i2c_client.adapter = NULL;
+
+	return err;
+}
+
+static inline void isp1301_write_reg(char reg, char data)
+{
+	i2c_smbus_write_byte_data(&isp1301_i2c_client, reg, data);
+}
+
+static inline char isp1301_read_reg(char reg)
+{
+	return i2c_smbus_read_byte_data(&isp1301_i2c_client, reg);
+}
+
+/* set ISP1301 as USB host
+ *
+ * @param bidi	1 - bidirectional mode, 0 - unidirectional
+ * @param se 	1 - single-ended mode, 0 - differential
+ */
+void isp1301_set_serial_host(int bidir, int se)
+{
+	isp1301_write_reg(ISP1301_MODE_REG2_CLR, 0xFF);
+	if (bidir)
+		isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL | BI_DI);
+	else
+		isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL);
+
+	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
+	if (se)
+		isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0 | SPEED_REG);
+	else
+		isp1301_write_reg(ISP1301_MODE_REG1_SET, SPEED_REG);
+
+	/* configure transceiver for host mode */
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (VBUS_DRV | DP_PULLDOWN | DM_PULLDOWN));
+}
+
+/* set ISP1301 as USB device
+ *
+ * @param bidi	1 - bidirectional mode, 0 - unidirectional
+ * @param se 	1 - single-ended mode, 0 - differential
+ */
+void isp1301_set_serial_dev(int bidi, int se)
+{
+	isp1301_write_reg(ISP1301_MODE_REG2_CLR, 0xFF);
+	if (bidi)
+		isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL | BI_DI);
+	else
+		isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL);
+
+	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
+	if (se)
+		isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0 | SPEED_REG);
+	else
+		isp1301_write_reg(ISP1301_MODE_REG1_SET, SPEED_REG);
+
+	/* FS mode, DP pull down, DM pull down */
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (DP_PULLDOWN | DM_PULLDOWN | DP_PULLUP));
+}
+
+void isp1301_set_vbus_power(int on)
+{
+	if (on) {
+		/* disable D+ pull-up */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
+		/* enable D+ pull-down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLDOWN);
+		/* turn on Vbus */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, VBUS_DRV);
+	} else {
+		/* D+ pull up, D- pull down  */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+				  (DP_PULLUP | DM_PULLDOWN));
+		/* disable D- pull up, disable D+ pull down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR,
+				  (DM_PULLUP | DP_PULLDOWN));
+	}
+}
+
+/*
+ * Enable or disable the D+ pullup.
+ */
+void isp1301_pullup(int on)
+{
+	if (on)
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLUP);
+	else
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
+}
+
+static int __init isp1301_init(void)
+{
+	i2c_add_driver(&isp1301_i2c_driver);
+
+	return 0;
+}
+
+static void __exit isp1301_exit(void)
+{
+	/* DDD do this for host only: */
+	/* disable OTG VBUS */
+	i2c_del_driver(&isp1301_i2c_driver);
+}
+
+module_init(isp1301_init);
+module_exit(isp1301_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1301");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

