From 03fdd9c492adde11b1c2bd023bb4185501ce65d1 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 20 May 2010 14:02:44 +0800
Subject: [PATCH 25/30] mxc/pmic: add pmic drivers for mxc platforms

On mxc platforms, the power management IC can control power supply to
various devices, besides this function, it can also work as a ADC,
audio CODEC, usb transceiver and gpio.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/mxc/Kconfig                          |    1 +
 drivers/mxc/Makefile                         |    1 +
 drivers/mxc/pmic/Kconfig                     |   64 +
 drivers/mxc/pmic/Makefile                    |    7 +
 drivers/mxc/pmic/core/Makefile               |   21 +
 drivers/mxc/pmic/core/mc13783.c              |  380 ++
 drivers/mxc/pmic/core/mc13892.c              |  333 ++
 drivers/mxc/pmic/core/mc34704.c              |  329 ++
 drivers/mxc/pmic/core/pmic-dev.c             |  324 ++
 drivers/mxc/pmic/core/pmic.h                 |  134 +
 drivers/mxc/pmic/core/pmic_common.c          |   98 +
 drivers/mxc/pmic/core/pmic_core_i2c.c        |  346 ++
 drivers/mxc/pmic/core/pmic_core_spi.c        |  305 ++
 drivers/mxc/pmic/core/pmic_event.c           |  235 +
 drivers/mxc/pmic/core/pmic_external.c        |  100 +
 drivers/mxc/pmic/mc13783/Kconfig             |   55 +
 drivers/mxc/pmic/mc13783/Makefile            |   18 +
 drivers/mxc/pmic/mc13783/pmic_adc.c          | 1542 +++++++
 drivers/mxc/pmic/mc13783/pmic_adc_defs.h     |  321 ++
 drivers/mxc/pmic/mc13783/pmic_audio.c        | 5876 ++++++++++++++++++++++++++
 drivers/mxc/pmic/mc13783/pmic_battery.c      | 1222 ++++++
 drivers/mxc/pmic/mc13783/pmic_battery_defs.h |   81 +
 drivers/mxc/pmic/mc13783/pmic_convity.c      | 2479 +++++++++++
 drivers/mxc/pmic/mc13783/pmic_light.c        | 2769 ++++++++++++
 drivers/mxc/pmic/mc13783/pmic_light_defs.h   |  144 +
 drivers/mxc/pmic/mc13783/pmic_power.c        | 3146 ++++++++++++++
 drivers/mxc/pmic/mc13783/pmic_power_defs.h   |  509 +++
 drivers/mxc/pmic/mc13783/pmic_rtc.c          |  546 +++
 drivers/mxc/pmic/mc13783/pmic_rtc_defs.h     |   47 +
 drivers/mxc/pmic/mc13892/Kconfig             |   48 +
 drivers/mxc/pmic/mc13892/Makefile            |   10 +
 drivers/mxc/pmic/mc13892/pmic_adc.c          |  984 +++++
 drivers/mxc/pmic/mc13892/pmic_battery.c      |  635 +++
 drivers/mxc/pmic/mc13892/pmic_light.c        |  685 +++
 include/linux/mfd/mc13783/core.h             |   72 +
 include/linux/mfd/mc13892/core.h             |   77 +
 include/linux/pmic_adc.h                     |  455 ++
 include/linux/pmic_battery.h                 |  419 ++
 include/linux/pmic_external.h                | 1108 +++++
 include/linux/pmic_light.h                   | 1082 +++++
 include/linux/pmic_rtc.h                     |  153 +
 include/linux/pmic_status.h                  |   82 +
 42 files changed, 27243 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/pmic/Kconfig
 create mode 100644 drivers/mxc/pmic/Makefile
 create mode 100644 drivers/mxc/pmic/core/Makefile
 create mode 100644 drivers/mxc/pmic/core/mc13783.c
 create mode 100644 drivers/mxc/pmic/core/mc13892.c
 create mode 100644 drivers/mxc/pmic/core/mc34704.c
 create mode 100644 drivers/mxc/pmic/core/pmic-dev.c
 create mode 100644 drivers/mxc/pmic/core/pmic.h
 create mode 100644 drivers/mxc/pmic/core/pmic_common.c
 create mode 100644 drivers/mxc/pmic/core/pmic_core_i2c.c
 create mode 100644 drivers/mxc/pmic/core/pmic_core_spi.c
 create mode 100644 drivers/mxc/pmic/core/pmic_event.c
 create mode 100644 drivers/mxc/pmic/core/pmic_external.c
 create mode 100644 drivers/mxc/pmic/mc13783/Kconfig
 create mode 100644 drivers/mxc/pmic/mc13783/Makefile
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_adc.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_adc_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_audio.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_battery.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_battery_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_convity.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_light.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_light_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_power.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_power_defs.h
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_rtc.c
 create mode 100644 drivers/mxc/pmic/mc13783/pmic_rtc_defs.h
 create mode 100644 drivers/mxc/pmic/mc13892/Kconfig
 create mode 100644 drivers/mxc/pmic/mc13892/Makefile
 create mode 100644 drivers/mxc/pmic/mc13892/pmic_adc.c
 create mode 100644 drivers/mxc/pmic/mc13892/pmic_battery.c
 create mode 100644 drivers/mxc/pmic/mc13892/pmic_light.c
 create mode 100644 include/linux/mfd/mc13783/core.h
 create mode 100644 include/linux/mfd/mc13892/core.h
 create mode 100644 include/linux/pmic_adc.h
 create mode 100644 include/linux/pmic_battery.h
 create mode 100644 include/linux/pmic_external.h
 create mode 100644 include/linux/pmic_light.h
 create mode 100644 include/linux/pmic_rtc.h
 create mode 100644 include/linux/pmic_status.h

diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 2e5599c..1abf587 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -21,6 +21,7 @@ source "drivers/mxc/ipu/Kconfig"
 source "drivers/mxc/ipu3/Kconfig"
 source "drivers/mxc/ssi/Kconfig"
 source "drivers/mxc/dam/Kconfig"
+source "drivers/mxc/pmic/Kconfig"
 
 endmenu
 
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index c4f956d..3ffa68b 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_MXC_IPU_V3)		+= ipu3/
 obj-$(CONFIG_MXC_SSI)               	+= ssi/
 obj-$(CONFIG_MXC_DAM)               	+= dam/
 
+obj-$(CONFIG_MXC_PMIC)			+= pmic/
diff --git a/drivers/mxc/pmic/Kconfig b/drivers/mxc/pmic/Kconfig
new file mode 100644
index 0000000..4ee9111
--- /dev/null
+++ b/drivers/mxc/pmic/Kconfig
@@ -0,0 +1,64 @@
+#
+# PMIC device driver configuration
+#
+
+menu "MXC PMIC support"
+
+config MXC_PMIC
+	boolean
+
+config MXC_PMIC_MC13783
+	tristate "MC13783 PMIC"
+	depends on ARCH_MXC && SPI
+	select MXC_PMIC
+	---help---
+	  This is the MXC MC13783(PMIC) support. It include
+	  ADC, Audio, Battery, Connectivity, Light, Power and RTC.
+
+config MXC_PMIC_MC13892
+	tristate "MC13892 PMIC"
+	depends on ARCH_MXC && (I2C || SPI)
+	select MXC_PMIC
+	---help---
+	  This is the MXC MC13892(PMIC) support. It include
+	  ADC, Battery, Connectivity, Light, Power and RTC.
+
+config MXC_PMIC_I2C
+	bool "Support PMIC I2C Interface"
+	depends on MXC_PMIC_MC13892 && I2C
+
+config MXC_PMIC_SPI
+	bool "Support PMIC SPI Interface"
+	depends on (MXC_PMIC_MC13892 || MXC_PMIC_MC13783) && SPI
+
+config MXC_PMIC_MC34704
+	tristate "MC34704 PMIC"
+	depends on ARCH_MXC && I2C
+	select MXC_PMIC
+	  ---help---
+	  This is the MXC MC34704 PMIC support.
+
+config MXC_PMIC_MC9SDZ60
+	tristate "MC9sDZ60 PMIC"
+	depends on ARCH_MXC && I2C
+	select MXC_PMIC
+	  ---help---
+	  This is the MXC MC9sDZ60(MCU) PMIC support.
+
+config MXC_PMIC_CHARDEV
+	tristate "MXC PMIC device interface"
+	depends on MXC_PMIC
+	help
+	  Say Y here to use "pmic" device files, found in the /dev directory
+	  on the system.  They make it possible to have user-space programs
+	  use or controll PMIC. Mainly its useful for notifying PMIC events
+	  to user-space programs.
+
+comment "MXC PMIC Client Drivers"
+	depends on MXC_PMIC
+
+source "drivers/mxc/pmic/mc13783/Kconfig"
+
+source "drivers/mxc/pmic/mc13892/Kconfig"
+
+endmenu
diff --git a/drivers/mxc/pmic/Makefile b/drivers/mxc/pmic/Makefile
new file mode 100644
index 0000000..385c07e
--- /dev/null
+++ b/drivers/mxc/pmic/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the MXC PMIC drivers.
+#
+
+obj-y				+= core/
+obj-$(CONFIG_MXC_PMIC_MC13783)	+= mc13783/
+obj-$(CONFIG_MXC_PMIC_MC13892)	+= mc13892/
diff --git a/drivers/mxc/pmic/core/Makefile b/drivers/mxc/pmic/core/Makefile
new file mode 100644
index 0000000..bb42231
--- /dev/null
+++ b/drivers/mxc/pmic/core/Makefile
@@ -0,0 +1,21 @@
+#
+# Makefile for the PMIC core drivers.
+#
+obj-$(CONFIG_MXC_PMIC_MC13783) += pmic_mc13783_mod.o
+pmic_mc13783_mod-objs := pmic_external.o pmic_event.o pmic_common.o pmic_core_spi.o mc13783.o
+
+obj-$(CONFIG_MXC_PMIC_MC13892) += pmic_mc13892_mod.o
+pmic_mc13892_mod-objs := pmic_external.o pmic_event.o pmic_common.o mc13892.o
+
+ifneq ($(CONFIG_MXC_PMIC_SPI),)
+pmic_mc13892_mod-objs += pmic_core_spi.o
+endif
+
+ifneq ($(CONFIG_MXC_PMIC_I2C),)
+pmic_mc13892_mod-objs += pmic_core_i2c.o
+endif
+
+obj-$(CONFIG_MXC_PMIC_MC34704) += pmic_mc34704_mod.o
+pmic_mc34704_mod-objs := pmic_external.o pmic_event.o mc34704.o
+
+obj-$(CONFIG_MXC_PMIC_CHARDEV)	+= pmic-dev.o
diff --git a/drivers/mxc/pmic/core/mc13783.c b/drivers/mxc/pmic/core/mc13783.c
new file mode 100644
index 0000000..3438834
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc13783.c
@@ -0,0 +1,380 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic/core/mc13783.c
+ * @brief This file contains MC13783 specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/spi/spi.h>
+#include <linux/mfd/mc13783/core.h>
+
+#include <linux/uaccess.h>
+
+#include "pmic.h"
+
+/*
+ * Defines
+ */
+#define EVENT_MASK_0			0x697fdf
+#define EVENT_MASK_1			0x3efffb
+#define MXC_PMIC_FRAME_MASK		0x00FFFFFF
+#define MXC_PMIC_MAX_REG_NUM		0x3F
+#define MXC_PMIC_REG_NUM_SHIFT		0x19
+#define MXC_PMIC_WRITE_BIT_SHIFT	31
+
+static unsigned int events_enabled0;
+static unsigned int events_enabled1;
+struct mxc_pmic pmic_drv_data;
+
+/*!
+ * This function is called to read a register on PMIC.
+ *
+ * @param        reg_num     number of the pmic register to be read
+ * @param        reg_val   return value of register
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+int pmic_read(unsigned int reg_num, unsigned int *reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (reg_num > MXC_PMIC_MAX_REG_NUM)
+		return PMIC_ERROR;
+
+	frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+	ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+	*reg_val = frame & MXC_PMIC_FRAME_MASK;
+
+	return ret;
+}
+
+/*!
+ * This function is called to write a value to the register on PMIC.
+ *
+ * @param        reg_num     number of the pmic register to be written
+ * @param        reg_val   value to be written
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+int pmic_write(int reg_num, const unsigned int reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (reg_num > MXC_PMIC_MAX_REG_NUM)
+		return PMIC_ERROR;
+
+	frame |= (1 << MXC_PMIC_WRITE_BIT_SHIFT);
+
+	frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+	frame |= reg_val & MXC_PMIC_FRAME_MASK;
+
+	ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+	return ret;
+}
+
+void *pmic_alloc_data(struct device *dev)
+{
+	struct mc13783 *mc13783;
+
+	mc13783 = kzalloc(sizeof(struct mc13783), GFP_KERNEL);
+	if (mc13783 == NULL)
+		return NULL;
+
+	mc13783->dev = dev;
+
+	return (void *)mc13783;
+}
+
+/*!
+ * This function initializes the SPI device parameters for this PMIC.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ *
+ * @return   None
+ */
+int pmic_spi_setup(struct spi_device *spi)
+{
+	/* Setup the SPI slave i.e.PMIC */
+	pmic_drv_data.spi = spi;
+
+	spi->mode = SPI_MODE_2 | SPI_CS_HIGH;
+	spi->bits_per_word = 32;
+
+	return spi_setup(spi);
+}
+
+/*!
+ * This function initializes the PMIC registers.
+ *
+ * @return   None
+ */
+int pmic_init_registers(void)
+{
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_MASK_0, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_MASK_1, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_STATUS_0, MXC_PMIC_FRAME_MASK));
+	CHECK_ERROR(pmic_write(REG_INTERRUPT_STATUS_1, MXC_PMIC_FRAME_MASK));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param	ver	pointer to the pmic_version_t structure
+ *
+ * @return       This function returns PMIC version.
+ */
+void pmic_get_revision(pmic_version_t *ver)
+{
+	int rev_id = 0;
+	int rev1 = 0;
+	int rev2 = 0;
+	int finid = 0;
+	int icid = 0;
+
+	ver->id = PMIC_MC13783;
+	pmic_read(REG_REVISION, &rev_id);
+
+	rev1 = (rev_id & 0x018) >> 3;
+	rev2 = (rev_id & 0x007);
+	icid = (rev_id & 0x01C0) >> 6;
+	finid = (rev_id & 0x01E00) >> 9;
+
+	/* Ver 0.2 is actually 3.2a.  Report as 3.2 */
+	if ((rev1 == 0) && (rev2 == 2))
+		rev1 = 3;
+
+
+	if (rev1 == 0 || icid != 2) {
+		ver->revision = -1;
+		printk(KERN_NOTICE
+		       "mc13783: Not detected.\tAccess failed\t!!!\n");
+	} else {
+		ver->revision = ((rev1 * 10) + rev2);
+		printk(KERN_INFO "mc13783 Rev %d.%d FinVer %x detected\n", rev1,
+		       rev2, finid);
+	}
+
+	return;
+
+}
+
+/*!
+ * This function reads the interrupt status registers of PMIC
+ * and determine the current active events.
+ *
+ * @param	active_events array pointer to be used to return active
+ *		event numbers.
+ *
+ * @return       This function returns PMIC version.
+ */
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	unsigned int count = 0;
+	unsigned int status0, status1;
+	int bit_set;
+
+	pmic_read(REG_INTERRUPT_STATUS_0, &status0);
+	pmic_read(REG_INTERRUPT_STATUS_1, &status1);
+	pmic_write(REG_INTERRUPT_STATUS_0, status0);
+	pmic_write(REG_INTERRUPT_STATUS_1, status1);
+	status0 &= events_enabled0;
+	status1 &= events_enabled1;
+
+	while (status0) {
+		bit_set = ffs(status0) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		status0 ^= (1 << bit_set);
+	}
+	while (status1) {
+		bit_set = ffs(status1) - 1;
+		*(active_events + count) = bit_set + 24;
+		count++;
+		status1 ^= (1 << bit_set);
+	}
+
+	return count;
+}
+
+/*!
+ * This function unsets a bit in mask register of pmic to unmask an event IT.
+ *
+ * @param	event	the event to be unmasked
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_unmask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_E1HZI) {
+		mask_reg = REG_INTERRUPT_MASK_0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 |= event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INTERRUPT_MASK_1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 |= event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: unmasking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, 0, event_bit);
+
+	pr_debug("Enable Event : %d\n", event);
+
+	return ret;
+}
+
+/*!
+ * This function sets a bit in mask register of pmic to disable an event IT.
+ *
+ * @param	event	the event to be masked
+ *
+ * @return     This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_mask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_E1HZI) {
+		mask_reg = REG_INTERRUPT_MASK_0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 &= ~event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INTERRUPT_MASK_1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 &= ~event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: masking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, event_bit, event_bit);
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return ret;
+}
+
+/*!
+ * This function is called to read all sensor bits of PMIC.
+ *
+ * @param        sensor    Sensor to be checked.
+ *
+ * @return       This function returns true if the sensor bit is high;
+ *               or returns false if the sensor bit is low.
+ */
+bool pmic_check_sensor(t_sensor sensor)
+{
+	unsigned int reg_val = 0;
+
+	CHECK_ERROR(pmic_read_reg
+		    (REG_INTERRUPT_SENSE_0, &reg_val, PMIC_ALL_BITS));
+
+	if ((1 << sensor) & reg_val)
+		return true;
+	else
+		return false;
+}
+
+/*!
+ * This function checks one sensor of PMIC.
+ *
+ * @param        sensor_bits  structure of all sensor bits.
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits)
+{
+	int sense_0 = 0;
+	int sense_1 = 0;
+
+	memset(sensor_bits, 0, sizeof(t_sensor_bits));
+
+	pmic_read_reg(REG_INTERRUPT_SENSE_0, &sense_0, 0xffffff);
+	pmic_read_reg(REG_INTERRUPT_SENSE_1, &sense_1, 0xffffff);
+
+	sensor_bits->sense_chgdets = (sense_0 & (1 << 6)) ? true : false;
+	sensor_bits->sense_chgovs = (sense_0 & (1 << 7)) ? true : false;
+	sensor_bits->sense_chgrevs = (sense_0 & (1 << 8)) ? true : false;
+	sensor_bits->sense_chgshorts = (sense_0 & (1 << 9)) ? true : false;
+	sensor_bits->sense_cccvs = (sense_0 & (1 << 10)) ? true : false;
+	sensor_bits->sense_chgcurrs = (sense_0 & (1 << 11)) ? true : false;
+	sensor_bits->sense_bpons = (sense_0 & (1 << 12)) ? true : false;
+	sensor_bits->sense_lobatls = (sense_0 & (1 << 13)) ? true : false;
+	sensor_bits->sense_lobaths = (sense_0 & (1 << 14)) ? true : false;
+	sensor_bits->sense_usb4v4s = (sense_0 & (1 << 16)) ? true : false;
+	sensor_bits->sense_usb2v0s = (sense_0 & (1 << 17)) ? true : false;
+	sensor_bits->sense_usb0v8s = (sense_0 & (1 << 18)) ? true : false;
+	sensor_bits->sense_id_floats = (sense_0 & (1 << 19)) ? true : false;
+	sensor_bits->sense_id_gnds = (sense_0 & (1 << 20)) ? true : false;
+	sensor_bits->sense_se1s = (sense_0 & (1 << 21)) ? true : false;
+	sensor_bits->sense_ckdets = (sense_0 & (1 << 22)) ? true : false;
+
+	sensor_bits->sense_onofd1s = (sense_1 & (1 << 3)) ? true : false;
+	sensor_bits->sense_onofd2s = (sense_1 & (1 << 4)) ? true : false;
+	sensor_bits->sense_onofd3s = (sense_1 & (1 << 5)) ? true : false;
+	sensor_bits->sense_pwrrdys = (sense_1 & (1 << 11)) ? true : false;
+	sensor_bits->sense_thwarnhs = (sense_1 & (1 << 12)) ? true : false;
+	sensor_bits->sense_thwarnls = (sense_1 & (1 << 13)) ? true : false;
+	sensor_bits->sense_clks = (sense_1 & (1 << 14)) ? true : false;
+	sensor_bits->sense_mc2bs = (sense_1 & (1 << 17)) ? true : false;
+	sensor_bits->sense_hsdets = (sense_1 & (1 << 18)) ? true : false;
+	sensor_bits->sense_hsls = (sense_1 & (1 << 19)) ? true : false;
+	sensor_bits->sense_alspths = (sense_1 & (1 << 20)) ? true : false;
+	sensor_bits->sense_ahsshorts = (sense_1 & (1 << 21)) ? true : false;
+	return PMIC_SUCCESS;
+}
+
+EXPORT_SYMBOL(pmic_check_sensor);
+EXPORT_SYMBOL(pmic_get_sensors);
diff --git a/drivers/mxc/pmic/core/mc13892.c b/drivers/mxc/pmic/core/mc13892.c
new file mode 100644
index 0000000..abf3f64
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc13892.c
@@ -0,0 +1,333 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic/core/mc13892.c
+ * @brief This file contains MC13892 specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/mfd/mc13892/core.h>
+#include <linux/uaccess.h>
+
+#include <asm/mach-types.h>
+
+#include "pmic.h"
+
+/*
+ * Defines
+ */
+#define MC13892_I2C_RETRY_TIMES 10
+#define MXC_PMIC_FRAME_MASK		0x00FFFFFF
+#define MXC_PMIC_MAX_REG_NUM		0x3F
+#define MXC_PMIC_REG_NUM_SHIFT		0x19
+#define MXC_PMIC_WRITE_BIT_SHIFT		31
+
+static unsigned int events_enabled0;
+static unsigned int events_enabled1;
+static struct mxc_pmic pmic_drv_data;
+#ifndef CONFIG_MXC_PMIC_I2C
+struct i2c_client *mc13892_client;
+#endif
+
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value)
+{
+	unsigned char buf[3];
+	int ret;
+	int i;
+
+	memset(buf, 0, 3);
+	for (i = 0; i < MC13892_I2C_RETRY_TIMES; i++) {
+		ret = i2c_smbus_read_i2c_block_data(client, reg_num, 3, buf);
+		if (ret == 3)
+			break;
+		msleep(1);
+	}
+
+	if (ret == 3) {
+		*value = buf[0] << 16 | buf[1] << 8 | buf[2];
+		return ret;
+	} else {
+		pr_debug("24bit read error, ret = %d\n", ret);
+		return -1;	/* return -1 on failure */
+	}
+}
+
+int pmic_i2c_24bit_write(struct i2c_client *client,
+			 unsigned int reg_num, unsigned int reg_val)
+{
+	char buf[3];
+	int ret;
+	int i;
+
+	buf[0] = (reg_val >> 16) & 0xff;
+	buf[1] = (reg_val >> 8) & 0xff;
+	buf[2] = (reg_val) & 0xff;
+
+	for (i = 0; i < MC13892_I2C_RETRY_TIMES; i++) {
+		ret = i2c_smbus_write_i2c_block_data(client, reg_num, 3, buf);
+		if (ret == 0)
+			break;
+		msleep(1);
+	}
+
+	return ret;
+}
+
+int pmic_read(int reg_num, unsigned int *reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (pmic_drv_data.spi != NULL) {
+		if (reg_num > MXC_PMIC_MAX_REG_NUM)
+			return PMIC_ERROR;
+
+		frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+		ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+		*reg_val = frame & MXC_PMIC_FRAME_MASK;
+	} else {
+		if (mc13892_client == NULL)
+			return PMIC_ERROR;
+
+		if (pmic_i2c_24bit_read(mc13892_client, reg_num, reg_val) == -1)
+			return PMIC_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+int pmic_write(int reg_num, const unsigned int reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (pmic_drv_data.spi != NULL) {
+		if (reg_num > MXC_PMIC_MAX_REG_NUM)
+			return PMIC_ERROR;
+
+		frame |= (1 << MXC_PMIC_WRITE_BIT_SHIFT);
+
+		frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+		frame |= reg_val & MXC_PMIC_FRAME_MASK;
+
+		ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+		return ret;
+	} else {
+		if (mc13892_client == NULL)
+			return PMIC_ERROR;
+
+		return pmic_i2c_24bit_write(mc13892_client, reg_num, reg_val);
+	}
+}
+
+void *pmic_alloc_data(struct device *dev)
+{
+	struct mc13892 *mc13892;
+
+	mc13892 = kzalloc(sizeof(struct mc13892), GFP_KERNEL);
+	if (mc13892 == NULL)
+		return NULL;
+
+	mc13892->dev = dev;
+
+	return (void *)mc13892;
+}
+
+/*!
+ * This function initializes the SPI device parameters for this PMIC.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ *
+ * @return   None
+ */
+int pmic_spi_setup(struct spi_device *spi)
+{
+	/* Setup the SPI slave i.e.PMIC */
+	pmic_drv_data.spi = spi;
+
+	spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
+	spi->bits_per_word = 32;
+
+	return spi_setup(spi);
+}
+
+int pmic_init_registers(void)
+{
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS1, 0xFFFFFF));
+	/* disable auto charge */
+	if (machine_is_mx51_3ds())
+		CHECK_ERROR(pmic_write(REG_CHARGE, 0xB40003));
+
+	pm_power_off = mc13892_power_off;
+
+	return PMIC_SUCCESS;
+}
+
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	unsigned int count = 0;
+	unsigned int status0, status1;
+	int bit_set;
+
+	pmic_read(REG_INT_STATUS0, &status0);
+	pmic_read(REG_INT_STATUS1, &status1);
+	pmic_write(REG_INT_STATUS0, status0);
+	pmic_write(REG_INT_STATUS1, status1);
+	status0 &= events_enabled0;
+	status1 &= events_enabled1;
+
+	while (status0) {
+		bit_set = ffs(status0) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		status0 ^= (1 << bit_set);
+	}
+	while (status1) {
+		bit_set = ffs(status1) - 1;
+		*(active_events + count) = bit_set + 24;
+		count++;
+		status1 ^= (1 << bit_set);
+	}
+
+	return count;
+}
+
+#define EVENT_MASK_0			0x387fff
+#define EVENT_MASK_1			0x1177eb
+
+int pmic_event_unmask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 |= event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 |= event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: unmasking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, 0, event_bit);
+
+	pr_debug("Enable Event : %d\n", event);
+
+	return ret;
+}
+
+int pmic_event_mask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 &= ~event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 &= ~event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: masking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, event_bit, event_bit);
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return ret;
+}
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param	ver	pointer to the pmic_version_t structure
+ *
+ * @return       This function returns PMIC version.
+ */
+void pmic_get_revision(pmic_version_t *ver)
+{
+	int rev_id = 0;
+	int rev1 = 0;
+	int rev2 = 0;
+	int finid = 0;
+	int icid = 0;
+
+	ver->id = PMIC_MC13892;
+	pmic_read(REG_IDENTIFICATION, &rev_id);
+
+	rev1 = (rev_id & 0x018) >> 3;
+	rev2 = (rev_id & 0x007);
+	icid = (rev_id & 0x01C0) >> 6;
+	finid = (rev_id & 0x01E00) >> 9;
+
+	ver->revision = ((rev1 * 10) + rev2);
+	printk(KERN_INFO "mc13892 Rev %d.%d FinVer %x detected\n", rev1,
+	       rev2, finid);
+}
+
+void mc13892_power_off(void)
+{
+	unsigned int value;
+
+	pmic_read_reg(REG_POWER_CTL0, &value, 0xffffff);
+
+	value |= 0x000008;
+
+	pmic_write_reg(REG_POWER_CTL0, value, 0xffffff);
+}
diff --git a/drivers/mxc/pmic/core/mc34704.c b/drivers/mxc/pmic/core/mc34704.c
new file mode 100644
index 0000000..f0ec05a
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc34704.c
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic/core/mc34704.c
+ * @brief This file contains MC34704 specific PMIC code.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/mfd/mc34704/core.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include "pmic.h"
+
+/*
+ * Globals
+ */
+static pmic_version_t mxc_pmic_version = {
+	.id = PMIC_MC34704,
+	.revision = 0,
+};
+static unsigned int events_enabled;
+unsigned int active_events[MAX_ACTIVE_EVENTS];
+struct i2c_client *mc34704_client;
+static void pmic_trigger_poll(void);
+
+#define MAX_MC34704_REG 0x59
+static unsigned int mc34704_reg_readonly[MAX_MC34704_REG / 32 + 1] = {
+	(1 << 0x03) || (1 << 0x05) || (1 << 0x07) || (1 << 0x09) ||
+	    (1 << 0x0B) || (1 << 0x0E) || (1 << 0x11) || (1 << 0x14) ||
+	    (1 << 0x17) || (1 << 0x18),
+	0,
+};
+static unsigned int mc34704_reg_written[MAX_MC34704_REG / 32 + 1];
+static unsigned char mc34704_shadow_regs[MAX_MC34704_REG - 1];
+#define IS_READONLY(r) ((1 << ((r) % 32)) & mc34704_reg_readonly[(r) / 32])
+#define WAS_WRITTEN(r) ((1 << ((r) % 32)) & mc34704_reg_written[(r) / 32])
+#define MARK_WRITTEN(r) do { \
+	mc34704_reg_written[(r) / 32] |= (1 << ((r) % 32)); \
+} while (0)
+
+int pmic_read(int reg_nr, unsigned int *reg_val)
+{
+	int c;
+
+	/*
+	 * Use the shadow register if we've written to it
+	 */
+	if (WAS_WRITTEN(reg_nr)) {
+		*reg_val = mc34704_shadow_regs[reg_nr];
+		return PMIC_SUCCESS;
+	}
+
+	/*
+	 * Otherwise, actually read the real register.
+	 * Write-only registers will read as zero.
+	 */
+	c = i2c_smbus_read_byte_data(mc34704_client, reg_nr);
+	if (c == -1) {
+		pr_debug("mc34704: error reading register 0x%02x\n", reg_nr);
+		return PMIC_ERROR;
+	} else {
+		*reg_val = c;
+		return PMIC_SUCCESS;
+	}
+}
+
+int pmic_write(int reg_nr, const unsigned int reg_val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(mc34704_client, reg_nr, reg_val);
+	if (ret == -1) {
+		return PMIC_ERROR;
+	} else {
+		/*
+		 * Update our software copy of the register since you
+		 * can't read what you wrote.
+		 */
+		if (!IS_READONLY(reg_nr)) {
+			mc34704_shadow_regs[reg_nr] = reg_val;
+			MARK_WRITTEN(reg_nr);
+		}
+		return PMIC_SUCCESS;
+	}
+}
+
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	unsigned int count = 0;
+	unsigned int faults;
+	int bit_set;
+
+	/* Check for any relevant PMIC faults */
+	pmic_read(REG_MC34704_FAULTS, &faults);
+	faults &= events_enabled;
+
+	/*
+	 * Mask all active events, because there is no way to acknowledge
+	 * or dismiss them in the PMIC -- they're sticky.
+	 */
+	events_enabled &= ~faults;
+
+	/* Account for all unmasked faults */
+	while (faults) {
+		bit_set = ffs(faults) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		faults ^= (1 << bit_set);
+	}
+	return count;
+}
+
+int pmic_event_unmask(type_event event)
+{
+	unsigned int event_bit = 0;
+	unsigned int prior_events = events_enabled;
+
+	event_bit = (1 << event);
+	events_enabled |= event_bit;
+
+	pr_debug("Enable Event : %d\n", event);
+
+	/* start the polling task as needed */
+	if (events_enabled && prior_events == 0)
+		pmic_trigger_poll();
+
+	return 0;
+}
+
+int pmic_event_mask(type_event event)
+{
+	unsigned int event_bit = 0;
+
+	event_bit = (1 << event);
+	events_enabled &= ~event_bit;
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return 0;
+}
+
+/*!
+ * PMIC event polling task.  This task is called periodically to poll
+ * for possible MC34704 events (No interrupt supplied by the hardware).
+ */
+static void pmic_event_task(struct work_struct *work);
+DECLARE_DELAYED_WORK(pmic_ws, pmic_event_task);
+
+static void pmic_trigger_poll(void)
+{
+	schedule_delayed_work(&pmic_ws, HZ / 10);
+}
+
+static void pmic_event_task(struct work_struct *work)
+{
+	unsigned int count = 0;
+	int i;
+
+	count = pmic_get_active_events(active_events);
+	pr_debug("active events number %d\n", count);
+
+	/* call handlers for all active events */
+	for (i = 0; i < count; i++)
+		pmic_event_callback(active_events[i]);
+
+	/* re-trigger this task, but only if somebody is watching */
+	if (events_enabled)
+		pmic_trigger_poll();
+
+	return;
+}
+
+pmic_version_t pmic_get_version(void)
+{
+	return mxc_pmic_version;
+}
+EXPORT_SYMBOL(pmic_get_version);
+
+int __devinit pmic_init_registers(void)
+{
+	/*
+	 * Set some registers to what they should be,
+	 * if for no other reason than to initialize our
+	 * software register copies.
+	 */
+	CHECK_ERROR(pmic_write(REG_MC34704_GENERAL2, 0x09));
+	CHECK_ERROR(pmic_write(REG_MC34704_VGSET1, 0));
+	CHECK_ERROR(pmic_write(REG_MC34704_REG2SET1, 0));
+	CHECK_ERROR(pmic_write(REG_MC34704_REG3SET1, 0));
+	CHECK_ERROR(pmic_write(REG_MC34704_REG4SET1, 0));
+	CHECK_ERROR(pmic_write(REG_MC34704_REG5SET1, 0));
+
+	return PMIC_SUCCESS;
+}
+
+static int __devinit is_chip_onboard(struct i2c_client *client)
+{
+	int val;
+
+	/*
+	 * This PMIC has no version or ID register, so just see
+	 * if it ACK's and returns 0 on some write-only register as
+	 * evidence of its presence.
+	 */
+	val = i2c_smbus_read_byte_data(client, REG_MC34704_GENERAL2);
+	if (val != 0)
+		return -1;
+
+	return 0;
+}
+
+static int __devinit pmic_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct mc34704 *mc34704;
+	struct mc34704_platform_data *plat_data = client->dev.platform_data;
+
+	if (!plat_data || !plat_data->init)
+		return -ENODEV;
+
+	ret = is_chip_onboard(client);
+
+	if (ret == -1)
+		return -ENODEV;
+
+	mc34704 = kzalloc(sizeof(struct mc34704), GFP_KERNEL);
+	if (mc34704 == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, mc34704);
+	mc34704->dev = &client->dev;
+	mc34704->i2c_client = client;
+
+	mc34704_client = client;
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize PMI registers */
+	if (pmic_init_registers() != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	ret = plat_data->init(mc34704);
+	if (ret != 0)
+		return PMIC_ERROR;
+
+	dev_info(&client->dev, "Loaded\n");
+
+	return PMIC_SUCCESS;
+}
+
+static int pmic_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int pmic_suspend(struct i2c_client *client, pm_message_t state)
+{
+	return 0;
+}
+
+static int pmic_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id mc34704_id[] = {
+	{"mc34704", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mc34704_id);
+
+static struct i2c_driver pmic_driver = {
+	.driver = {
+		   .name = "mc34704",
+		   .bus = NULL,
+		   },
+	.probe = pmic_probe,
+	.remove = pmic_remove,
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+	.id_table = mc34704_id,
+};
+
+static int __init pmic_init(void)
+{
+	return i2c_add_driver(&pmic_driver);
+}
+
+static void __exit pmic_exit(void)
+{
+	i2c_del_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall_sync(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("MC34704 PMIC driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic-dev.c b/drivers/mxc/pmic/core/pmic-dev.c
new file mode 100644
index 0000000..6296eb5
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic-dev.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic-dev.c
+ * @brief This provides /dev interface to the user program. They make it
+ * possible to have user-space programs use or control PMIC. Mainly its
+ * useful for notifying PMIC events to user-space programs.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kdev_t.h>
+#include <linux/circ_buf.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/signal.h>
+#include <linux/pmic_external.h>
+
+#include <linux/uaccess.h>
+
+#define PMIC_NAME	"pmic"
+#define CIRC_BUF_MAX	16
+#define CIRC_ADD(elem, cir_buf, size)					\
+	do {								\
+		down(&event_mutex);					\
+		if (CIRC_SPACE(cir_buf.head, cir_buf.tail, size)) {	\
+			cir_buf.buf[cir_buf.head] = (char)elem;		\
+			cir_buf.head = (cir_buf.head + 1) & (size - 1);	\
+		} else {						\
+			pr_info("Failed to notify event to the user\n"); \
+		}							\
+		up(&event_mutex);					\
+	} while (0)
+
+#define CIRC_REMOVE(elem, cir_buf, size)				\
+	do {								\
+		down(&event_mutex);					\
+		if (CIRC_CNT(cir_buf.head, cir_buf.tail, size)) {       \
+			elem = (int)cir_buf.buf[cir_buf.tail];          \
+			cir_buf.tail = (cir_buf.tail + 1) & (size - 1); \
+		} else {                                                \
+			elem = -1;                                      \
+			pr_info("No valid notified event\n");           \
+		}							\
+		up(&event_mutex);					\
+	} while (0)
+
+static int pmic_major;
+static struct class *pmic_class;
+static struct fasync_struct *pmic_dev_queue;
+
+static DECLARE_MUTEX(event_mutex);
+static struct circ_buf pmic_events;
+
+static void callbackfn(void *event)
+{
+	printk(KERN_INFO "\n\n DETECTED PMIC EVENT : %d\n\n",
+	       (unsigned int)event);
+}
+
+static void user_notify_callback(void *event)
+{
+	CIRC_ADD((int)event, pmic_events, CIRC_BUF_MAX);
+	kill_fasync(&pmic_dev_queue, SIGIO, POLL_IN);
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_dev_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	register_info reg_info;
+	pmic_event_callback_t event_sub;
+	type_event event;
+	int ret = 0;
+
+	if (_IOC_TYPE(cmd) != 'P')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_READ_REG:
+		if (copy_from_user(&reg_info, (register_info *) arg,
+				   sizeof(register_info))) {
+			return -EFAULT;
+		}
+		ret =
+		    pmic_read_reg(reg_info.reg, &(reg_info.reg_value),
+				  0x00ffffff);
+		pr_debug("read reg %d %x\n", reg_info.reg, reg_info.reg_value);
+		if (copy_to_user((register_info *) arg, &reg_info,
+				 sizeof(register_info))) {
+			return -EFAULT;
+		}
+		break;
+
+	case PMIC_WRITE_REG:
+		if (copy_from_user(&reg_info, (register_info *) arg,
+				   sizeof(register_info))) {
+			return -EFAULT;
+		}
+		ret =
+		    pmic_write_reg(reg_info.reg, reg_info.reg_value,
+				   0x00ffffff);
+		pr_debug("write reg %d %x\n", reg_info.reg, reg_info.reg_value);
+		if (copy_to_user((register_info *) arg, &reg_info,
+				 sizeof(register_info))) {
+			return -EFAULT;
+		}
+		break;
+
+	case PMIC_SUBSCRIBE:
+		if (get_user(event, (int __user *)arg))
+			return -EFAULT;
+
+		event_sub.func = callbackfn;
+		event_sub.param = (void *)event;
+		ret = pmic_event_subscribe(event, event_sub);
+		pr_debug("subscribe done\n");
+		break;
+
+	case PMIC_UNSUBSCRIBE:
+		if (get_user(event, (int __user *)arg))
+			return -EFAULT;
+
+		event_sub.func = callbackfn;
+		event_sub.param = (void *)event;
+		ret = pmic_event_unsubscribe(event, event_sub);
+		pr_debug("unsubscribe done\n");
+		break;
+
+	case PMIC_NOTIFY_USER:
+		if (get_user(event, (int __user *)arg))
+			return -EFAULT;
+
+		event_sub.func = user_notify_callback;
+		event_sub.param = (void *)event;
+		ret = pmic_event_subscribe(event, event_sub);
+		break;
+
+	case PMIC_GET_NOTIFY:
+		CIRC_REMOVE(event, pmic_events, CIRC_BUF_MAX);
+		if (put_user(event, (int __user *)arg))
+			return -EFAULT;
+
+		break;
+
+	default:
+		printk(KERN_ERR "%d unsupported ioctl command\n", (int)cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*!
+ * This function implements the open method on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_dev_open(struct inode *inode, struct file *file)
+{
+	pr_debug("open\n");
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function implements the release method on a PMIC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ *
+ * @return       This function returns 0.
+ */
+static int pmic_dev_free(struct inode *inode, struct file *file)
+{
+	pr_debug("free\n");
+	return PMIC_SUCCESS;
+}
+
+static int pmic_dev_fasync(int fd, struct file *filp, int mode)
+{
+	return fasync_helper(fd, filp, mode, &pmic_dev_queue);
+}
+
+/*!
+ * This structure defines file operations for a PMIC device.
+ */
+static const struct file_operations pmic_fops = {
+	/*!
+	 * the owner
+	 */
+	.owner = THIS_MODULE,
+	/*!
+	 * the ioctl operation
+	 */
+	.ioctl = pmic_dev_ioctl,
+	/*!
+	 * the open operation
+	 */
+	.open = pmic_dev_open,
+	/*!
+	 * the release operation
+	 */
+	.release = pmic_dev_free,
+	/*!
+	 * the release operation
+	 */
+	.fasync = pmic_dev_fasync,
+};
+
+/*!
+ * This function implements the init function of the PMIC char device.
+ * This function is called when the module is loaded. It registers
+ * the character device for PMIC to be used by user-space programs.
+ *
+ * @return       This function returns 0.
+ */
+static int __init pmic_dev_init(void)
+{
+	int ret = 0;
+	struct device *pmic_device;
+	pmic_version_t pmic_ver;
+
+	pmic_ver = pmic_get_version();
+	if (pmic_ver.revision < 0) {
+		printk(KERN_ERR "No PMIC device found\n");
+		return -ENODEV;
+	}
+
+	pmic_major = register_chrdev(0, PMIC_NAME, &pmic_fops);
+	if (pmic_major < 0) {
+		printk(KERN_ERR "unable to get a major for pmic\n");
+		return pmic_major;
+	}
+
+	pmic_class = class_create(THIS_MODULE, PMIC_NAME);
+	if (IS_ERR(pmic_class)) {
+		printk(KERN_ERR "Error creating pmic class.\n");
+		ret = PMIC_ERROR;
+		goto err;
+	}
+
+	pmic_device = device_create(pmic_class, NULL, MKDEV(pmic_major, 0), NULL,
+				    PMIC_NAME);
+	if (IS_ERR(pmic_device)) {
+		printk(KERN_ERR "Error creating pmic class device.\n");
+		ret = PMIC_ERROR;
+		goto err1;
+	}
+
+	pmic_events.buf = kmalloc(CIRC_BUF_MAX * sizeof(char), GFP_KERNEL);
+	if (NULL == pmic_events.buf) {
+		ret = -ENOMEM;
+		goto err2;
+	}
+	pmic_events.head = pmic_events.tail = 0;
+
+	printk(KERN_INFO "PMIC Character device: successfully loaded\n");
+	return ret;
+err2:
+	device_destroy(pmic_class, MKDEV(pmic_major, 0));
+err1:
+	class_destroy(pmic_class);
+err:
+	unregister_chrdev(pmic_major, PMIC_NAME);
+	return ret;
+
+}
+
+/*!
+ * This function implements the exit function of the PMIC character device.
+ * This function is called when the module is unloaded. It unregisters
+ * the PMIC character device.
+ *
+ */
+static void __exit pmic_dev_exit(void)
+{
+	device_destroy(pmic_class, MKDEV(pmic_major, 0));
+	class_destroy(pmic_class);
+
+	unregister_chrdev(pmic_major, PMIC_NAME);
+
+	printk(KERN_INFO "PMIC Character device: successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+module_init(pmic_dev_init);
+module_exit(pmic_dev_exit);
+
+MODULE_DESCRIPTION("PMIC Protocol /dev entries driver");
+MODULE_AUTHOR("FreeScale");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic.h b/drivers/mxc/pmic/core/pmic.h
new file mode 100644
index 0000000..b9935e6
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __PMIC_H__
+#define __PMIC_H__
+
+ /*!
+  * @file pmic.h
+  * @brief This file contains prototypes of all the functions to be
+  * defined for each PMIC chip. The implementation of these may differ
+  * from PMIC chip to PMIC chip.
+  *
+  * @ingroup PMIC_CORE
+  */
+
+#include <linux/spi/spi.h>
+
+#define MAX_ACTIVE_EVENTS		10
+
+/*!
+ * This structure is a way for the PMIC core driver to define their own
+ * \b spi_device structure. This structure includes the core \b spi_device
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and may contain other elements that are required by core driver.
+ */
+struct mxc_pmic {
+	/*!
+	 * Master side proxy for an SPI slave device(PMIC)
+	 */
+	struct spi_device *spi;
+};
+
+/*!
+ * This function is called to transfer data to PMIC on SPI.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ * @param    buf	the pointer to the data buffer
+ * @param    len	the length of the data to be transferred
+ *
+ * @return   Returns 0 on success -1 on failure.
+ */
+static inline int spi_rw(struct spi_device *spi, u8 * buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	if (spi_sync(spi, &m) != 0 || m.status != 0)
+		return PMIC_ERROR;
+	return len - m.actual_length;
+}
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param	ver	pointer to the pmic_version_t structure
+ *
+ * @return       This function returns PMIC version.
+ */
+void pmic_get_revision(pmic_version_t *ver);
+
+/*!
+ * This function initializes the SPI device parameters for this PMIC.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ *
+ * @return   None
+ */
+int pmic_spi_setup(struct spi_device *spi);
+
+/*!
+ * This function initializes the PMIC registers.
+ *
+ * @return   None
+ */
+int pmic_init_registers(void);
+
+/*!
+ * This function reads the interrupt status registers of PMIC
+ * and determine the current active events.
+ *
+ * @param	active_events array pointer to be used to return active
+ *		event numbers.
+ *
+ * @return       This function returns PMIC version.
+ */
+unsigned int pmic_get_active_events(unsigned int *active_events);
+
+/*!
+ * This function sets a bit in mask register of pmic to disable an event IT.
+ *
+ * @param	event	the event to be masked
+ *
+ * @return     This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_mask(type_event event);
+
+/*!
+ * This function unsets a bit in mask register of pmic to unmask an event IT.
+ *
+ * @param	event	the event to be unmasked
+ *
+ * @return    This function returns PMIC_SUCCESS on SUCCESS, error on FAILURE.
+ */
+int pmic_event_unmask(type_event event);
+
+#ifdef CONFIG_MXC_PMIC_FIXARB
+extern PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi);
+#else
+static inline PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+#endif
+
+void *pmic_alloc_data(struct device *dev);
+
+#endif				/* __PMIC_H__ */
diff --git a/drivers/mxc/pmic/core/pmic_common.c b/drivers/mxc/pmic/core/pmic_common.c
new file mode 100644
index 0000000..b42a465
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_common.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_common.c
+ * @brief This is the common file for the PMIC Core/Protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include <linux/uaccess.h>
+
+#include "pmic.h"
+
+/*
+ * Global variables
+ */
+pmic_version_t mxc_pmic_version;
+unsigned int active_events[MAX_ACTIVE_EVENTS];
+struct workqueue_struct *pmic_event_wq;
+
+void pmic_bh_handler(struct work_struct *work);
+/*!
+ * Bottom half handler of PMIC event handling.
+ */
+DECLARE_WORK(pmic_ws, pmic_bh_handler);
+
+/*!
+ * This function is the bottom half handler of the PMIC interrupt.
+ * It checks for active events and launches callback for the
+ * active events.
+ */
+void pmic_bh_handler(struct work_struct *work)
+{
+	unsigned int loop;
+	unsigned int count = 0;
+
+	count = pmic_get_active_events(active_events);
+	pr_debug("active events number %d\n", count);
+
+	for (loop = 0; loop < count; loop++)
+		pmic_event_callback(active_events[loop]);
+
+	return;
+}
+
+/*!
+ * This function is called when pmic interrupt occurs on the processor.
+ * It is the interrupt handler for the pmic module.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+irqreturn_t pmic_irq_handler(int irq, void *dev_id)
+{
+	/* prepare a task */
+	queue_work(pmic_event_wq, &pmic_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+
+pmic_version_t pmic_get_version(void)
+{
+	return mxc_pmic_version;
+}
+EXPORT_SYMBOL(pmic_get_version);
diff --git a/drivers/mxc/pmic/core/pmic_core_i2c.c b/drivers/mxc/pmic/core/pmic_core_i2c.c
new file mode 100644
index 0000000..5e21714
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_i2c.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_core_i2c.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. i2c
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/mfd/mc13892/core.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include <linux/uaccess.h>
+
+#include "pmic.h"
+
+#define MC13892_GENERATION_ID_LSH	6
+#define MC13892_IC_ID_LSH		13
+
+#define MC13892_GENERATION_ID_WID	3
+#define MC13892_IC_ID_WID		6
+
+#define MC13892_GEN_ID_VALUE	0x7
+#define MC13892_IC_ID_VALUE		1
+
+/*
+ * Global variables
+ */
+struct i2c_client *mc13892_client;
+
+extern struct workqueue_struct *pmic_event_wq;
+extern pmic_version_t mxc_pmic_version;
+extern irqreturn_t pmic_irq_handler(int irq, void *dev_id);
+
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+static struct platform_device rleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'r',
+};
+static struct platform_device gleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'g',
+};
+static struct platform_device bleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'b',
+};
+
+static void pmic_pdev_register(struct device *dev)
+{
+	platform_device_register(&adc_ldm);
+	platform_device_register(&battery_ldm);
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+	platform_device_register(&rleds_ldm);
+	platform_device_register(&gleds_ldm);
+	platform_device_register(&bleds_ldm);
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+}
+
+static int __devinit is_chip_onboard(struct i2c_client *client)
+{
+	unsigned int ret = 0;
+
+	/*bind the right device to the driver */
+	if (pmic_i2c_24bit_read(client, REG_IDENTIFICATION, &ret) == -1)
+		return -1;
+
+	if (MC13892_GEN_ID_VALUE != BITFEXT(ret, MC13892_GENERATION_ID)) {
+		/*compare the address value */
+		dev_err(&client->dev,
+			"read generation ID 0x%x is not equal to 0x%x!\n",
+			BITFEXT(ret, MC13892_GENERATION_ID),
+			MC13892_GEN_ID_VALUE);
+		return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t mc13892_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	int i, value;
+	int offset = (REG_TEST4 + 1) / 4;
+
+	for (i = 0; i < offset; i++) {
+		pmic_read(i, &value);
+		pr_info("reg%02d: %06x\t\t", i, value);
+		pmic_read(i + offset, &value);
+		pr_info("reg%02d: %06x\t\t", i + offset, value);
+		pmic_read(i + offset * 2, &value);
+		pr_info("reg%02d: %06x\t\t", i + offset * 2, value);
+		pmic_read(i + offset * 3, &value);
+		pr_info("reg%02d: %06x\n", i + offset * 3, value);
+	}
+
+	return 0;
+}
+
+static ssize_t mc13892_store(struct device *dev,
+			     struct device_attribute *attr, const char *buf,
+			     size_t count)
+{
+	int reg, value, ret;
+	char *p;
+
+	reg = simple_strtoul(buf, NULL, 10);
+
+	p = NULL;
+	p = memchr(buf, ' ', count);
+
+	if (p == NULL) {
+		pmic_read(reg, &value);
+		pr_debug("reg%02d: %06x\n", reg, value);
+		return count;
+	}
+
+	p += 1;
+
+	value = simple_strtoul(p, NULL, 16);
+
+	ret = pmic_write(reg, value);
+	if (ret == 0)
+		pr_debug("write reg%02d: %06x\n", reg, value);
+	else
+		pr_debug("register update failed\n");
+
+	return count;
+}
+
+static struct device_attribute mc13892_dev_attr = {
+	.attr = {
+		 .name = "mc13892_ctl",
+		 .mode = S_IRUSR | S_IWUSR,
+		 },
+	.show = mc13892_show,
+	.store = mc13892_store,
+};
+
+static int __devinit pmic_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int ret = 0;
+	int pmic_irq;
+	struct mc13892 *mc13892;
+	struct mc13892_platform_data *plat_data = client->dev.platform_data;
+
+	ret = is_chip_onboard(client);
+	if (ret == -1)
+		return -ENODEV;
+
+	mc13892 = kzalloc(sizeof(struct mc13892), GFP_KERNEL);
+	if (mc13892 == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, mc13892);
+	mc13892->dev = &client->dev;
+	mc13892->i2c_client = client;
+
+	/* so far, we got matched chip on board */
+
+	mc13892_client = client;
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	gpio_pmic_active();
+
+	/* Get the PMIC Version */
+	pmic_get_revision(&mxc_pmic_version);
+	if (mxc_pmic_version.revision < 0) {
+		dev_err((struct device *)client,
+			"PMIC not detected!!! Access Failed\n");
+		return -ENODEV;
+	} else {
+		dev_dbg((struct device *)client,
+			"Detected pmic core IC version number is %d\n",
+			mxc_pmic_version.revision);
+	}
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_init_registers();
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	pmic_event_wq = create_workqueue("mc13892");
+	if (!pmic_event_wq) {
+		pr_err("mc13892 pmic driver init: fail to create work queue");
+		return -EFAULT;
+	}
+
+	/* Set and install PMIC IRQ handler */
+	pmic_irq = (int)(client->irq);
+	if (pmic_irq == 0)
+		return PMIC_ERROR;
+
+	set_irq_type(pmic_irq, IRQF_TRIGGER_RISING);
+	ret =
+	    request_irq(pmic_irq, pmic_irq_handler, 0, "PMIC_IRQ",
+			0);
+
+	if (ret) {
+		dev_err(&client->dev, "request irq %d error!\n", pmic_irq);
+		return ret;
+	}
+	enable_irq_wake(pmic_irq);
+
+	if (plat_data && plat_data->init) {
+		ret = plat_data->init(mc13892);
+		if (ret != 0)
+			return PMIC_ERROR;
+	}
+
+	ret = device_create_file(&client->dev, &mc13892_dev_attr);
+	if (ret)
+		dev_err(&client->dev, "create device file failed!\n");
+
+	pmic_pdev_register(&client->dev);
+
+	dev_info(&client->dev, "Loaded\n");
+
+	return PMIC_SUCCESS;
+}
+
+static int pmic_remove(struct i2c_client *client)
+{
+	int pmic_irq = (int)(client->irq);
+
+	if (pmic_event_wq)
+		destroy_workqueue(pmic_event_wq);
+
+	free_irq(pmic_irq, 0);
+	pmic_pdev_unregister();
+	return 0;
+}
+
+static int pmic_suspend(struct i2c_client *client, pm_message_t state)
+{
+	return 0;
+}
+
+static int pmic_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id mc13892_id[] = {
+	{"mc13892", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mc13892_id);
+
+static struct i2c_driver pmic_driver = {
+	.driver = {
+		   .name = "mc13892",
+		   .bus = NULL,
+		   },
+	.probe = pmic_probe,
+	.remove = pmic_remove,
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+	.id_table = mc13892_id,
+};
+
+static int __init pmic_init(void)
+{
+	return i2c_add_driver(&pmic_driver);
+}
+
+static void __exit pmic_exit(void)
+{
+	i2c_del_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall_sync(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic_core_spi.c b/drivers/mxc/pmic/core/pmic_core_spi.c
new file mode 100644
index 0000000..243d7d2
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_spi.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_core_spi.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. SPI
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include <linux/uaccess.h>
+
+#include "pmic.h"
+
+/*
+ * Static functions
+ */
+static void pmic_pdev_register(void);
+static void pmic_pdev_unregister(void);
+
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+static struct platform_device rleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'r',
+};
+static struct platform_device gleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'g',
+};
+static struct platform_device bleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'b',
+};
+
+/*
+ * External functions
+ */
+extern void pmic_event_list_init(void);
+extern void pmic_event_callback(type_event event);
+extern void gpio_pmic_active(void);
+extern irqreturn_t pmic_irq_handler(int irq, void *dev_id);
+extern pmic_version_t mxc_pmic_version;
+extern struct workqueue_struct *pmic_event_wq;
+
+/*!
+ * This function registers platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_register(void)
+{
+	platform_device_register(&adc_ldm);
+	platform_device_register(&battery_ldm);
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+	platform_device_register(&rleds_ldm);
+	platform_device_register(&gleds_ldm);
+	platform_device_register(&bleds_ldm);
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+}
+
+/*!
+ * This function puts the SPI slave device in low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ * @param	message	the power state to enter
+ *
+ * @return	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_suspend(struct spi_device *spi, pm_message_t message)
+{
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function brings the SPI slave device back from low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_resume(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+
+static struct spi_driver pmic_driver;
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit pmic_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	struct pmic_platform_data *plat_data = spi->dev.platform_data;
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_spi_setup(spi);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	gpio_pmic_active();
+
+	/* Get the PMIC Version */
+	pmic_get_revision(&mxc_pmic_version);
+	if (mxc_pmic_version.revision < 0) {
+		dev_err((struct device *)spi,
+			"PMIC not detected!!! Access Failed\n");
+		return -ENODEV;
+	} else {
+		dev_dbg((struct device *)spi,
+			"Detected pmic core IC version number is %d\n",
+			mxc_pmic_version.revision);
+	}
+
+	spi_set_drvdata(spi, pmic_alloc_data(&(spi->dev)));
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_init_registers();
+	if (ret != PMIC_SUCCESS) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		return PMIC_ERROR;
+	}
+
+	pmic_event_wq = create_workqueue("pmic_spi");
+	if (!pmic_event_wq) {
+		pr_err("pmic driver init: fail to create work queue");
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		return -EFAULT;
+	}
+
+	/* Set and install PMIC IRQ handler */
+	set_irq_type(spi->irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(spi->irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
+	if (ret) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		dev_err((struct device *)spi, "gpio1: irq%d error.", spi->irq);
+		return ret;
+	}
+
+	enable_irq_wake(spi->irq);
+
+	if (plat_data && plat_data->init) {
+		ret = plat_data->init(spi_get_drvdata(spi));
+		if (ret != 0) {
+			kfree(spi_get_drvdata(spi));
+			spi_set_drvdata(spi, NULL);
+			return PMIC_ERROR;
+		}
+	}
+
+	power_ldm.dev.platform_data = spi->dev.platform_data;
+
+	pmic_pdev_register();
+
+	printk(KERN_INFO "Device %s probed\n", dev_name(&spi->dev));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is called whenever the SPI slave device is removed.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devexit pmic_remove(struct spi_device *spi)
+{
+	if (pmic_event_wq)
+		destroy_workqueue(pmic_event_wq);
+
+	free_irq(spi->irq, 0);
+
+	pmic_pdev_unregister();
+
+	printk(KERN_INFO "Device %s removed\n", dev_name(&spi->dev));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct spi_driver pmic_driver = {
+	.driver = {
+		   .name = "pmic_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = pmic_probe,
+	.remove = __devexit_p(pmic_remove),
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+/*!
+ * This function implements the init function of the PMIC device.
+ * This function is called when the module is loaded. It registers
+ * the PMIC Protocol driver.
+ *
+ * @return       This function returns 0.
+ */
+static int __init pmic_init(void)
+{
+	return spi_register_driver(&pmic_driver);
+}
+
+/*!
+ * This function implements the exit function of the PMIC device.
+ * This function is called when the module is unloaded. It unregisters
+ * the PMIC Protocol driver.
+ *
+ */
+static void __exit pmic_exit(void)
+{
+	pr_debug("Unregistering the PMIC Protocol Driver\n");
+	spi_unregister_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall_sync(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic_event.c b/drivers/mxc/pmic/core/pmic_event.c
new file mode 100644
index 0000000..71404f3
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_event.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_event.c
+ * @brief This file manage all event of PMIC component.
+ *
+ * It contains event subscription, unsubscription and callback
+ * launch methods implemeted.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include "pmic.h"
+
+/*!
+ * This structure is used to keep a list of subscribed
+ * callbacks for an event.
+ */
+typedef struct {
+	/*!
+	 * Keeps a list of subscribed clients to an event.
+	 */
+	struct list_head list;
+
+	/*!
+	 * Callback function with parameter, called when event occurs
+	 */
+	pmic_event_callback_t callback;
+} pmic_event_callback_list_t;
+
+/* Create a mutex to be used to prevent concurrent access to the event list */
+static DECLARE_MUTEX(event_mutex);
+
+/* This is a pointer to the event handler array. It defines the currently
+ * active set of events and user-defined callback functions.
+ */
+static struct list_head pmic_events[PMIC_MAX_EVENTS];
+
+/*!
+ * This function initializes event list for PMIC event handling.
+ *
+ */
+void pmic_event_list_init(void)
+{
+	int i;
+
+	for (i = 0; i < PMIC_MAX_EVENTS; i++)
+		INIT_LIST_HEAD(&pmic_events[i]);
+
+
+	sema_init(&event_mutex, 1);
+	return;
+}
+
+/*!
+ * This function is used to subscribe on an event.
+ *
+ * @param	event   the event number to be subscribed
+ * @param	callback the callback funtion to be subscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback)
+{
+	pmic_event_callback_list_t *new = NULL;
+
+	pr_debug("Event:%d Subscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Create a new linked list entry */
+	new = kmalloc(sizeof(pmic_event_callback_list_t), GFP_KERNEL);
+	if (NULL == new)
+		return -ENOMEM;
+
+	/* Initialize the list node fields */
+	new->callback.func = callback.func;
+	new->callback.param = callback.param;
+	INIT_LIST_HEAD(&new->list);
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex)) {
+		kfree(new);
+		return PMIC_SYSTEM_ERROR_EINTR;
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_unmask(event) != PMIC_SUCCESS) {
+			kfree(new);
+			up(&event_mutex);
+			return PMIC_ERROR;
+		}
+	}
+
+	/* Add this entry to the event list */
+	list_add_tail(&new->list, &pmic_events[event]);
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to unsubscribe on an event.
+ *
+ * @param	event   the event number to be unsubscribed
+ * @param	callback the callback funtion to be unsubscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback)
+{
+	struct list_head *p;
+	struct list_head *n;
+	pmic_event_callback_list_t *temp = NULL;
+	int ret = PMIC_EVENT_NOT_SUBSCRIBED;
+
+	pr_debug("Event:%d Unsubscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+
+	/* Find the entry in the list */
+	list_for_each_safe(p, n, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		if (temp->callback.func == callback.func
+		    && temp->callback.param == callback.param) {
+			/* Remove the entry from the list */
+			list_del(p);
+			kfree(temp);
+			ret = PMIC_SUCCESS;
+			break;
+		}
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_mask(event) != PMIC_SUCCESS)
+			ret = PMIC_UNSUBSCRIBE_ERROR;
+
+	}
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return ret;
+}
+
+/*!
+ * This function calls all callback of a specific event.
+ *
+ * @param	event   the active event number
+ *
+ * @return	None
+ */
+void pmic_event_callback(type_event event)
+{
+	struct list_head *p;
+	pmic_event_callback_list_t *temp = NULL;
+
+	/* Obtain the lock to access the list */
+	if (down_interruptible(&event_mutex))
+		return;
+
+
+	if (list_empty(&pmic_events[event])) {
+		pr_debug("PMIC Event:%d detected. No callback subscribed\n",
+			 event);
+		up(&event_mutex);
+		return;
+	}
+
+	list_for_each(p, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		temp->callback.func(temp->callback.param);
+	}
+
+	/* Release the lock */
+	up(&event_mutex);
+
+	return;
+
+}
+
+EXPORT_SYMBOL(pmic_event_subscribe);
+EXPORT_SYMBOL(pmic_event_unsubscribe);
diff --git a/drivers/mxc/pmic/core/pmic_external.c b/drivers/mxc/pmic/core/pmic_external.c
new file mode 100644
index 0000000..90141fc
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_external.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_external.c
+ * @brief This file contains all external functions of PMIC drivers.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+/*
+ * External Functions
+ */
+extern int pmic_read(int reg_num, unsigned int *reg_val);
+extern int pmic_write(int reg_num, const unsigned int reg_val);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  return value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	*reg_value = (temp & reg_mask);
+
+	pr_debug("Read REG[ %d ] = 0x%x\n", reg, *reg_value);
+
+	return ret;
+}
+
+/*!
+ * This function is called by PMIC clients to write a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	temp = (temp & (~reg_mask)) | reg_value;
+#ifdef CONFIG_MXC_PMIC_MC13783
+	if (reg == REG_POWER_MISCELLANEOUS)
+		temp &= 0xFFFE7FFF;
+#endif
+	ret = pmic_write(reg, temp);
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+
+	pr_debug("Write REG[ %d ] = 0x%x\n", reg, reg_value);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(pmic_read_reg);
+EXPORT_SYMBOL(pmic_write_reg);
diff --git a/drivers/mxc/pmic/mc13783/Kconfig b/drivers/mxc/pmic/mc13783/Kconfig
new file mode 100644
index 0000000..02496c6
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/Kconfig
@@ -0,0 +1,55 @@
+#
+# PMIC Modules configuration
+#
+
+config MXC_MC13783_ADC
+	tristate "MC13783 ADC support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 ADC module driver. This module provides kernel API
+	for the ADC system of MC13783.
+	It controls also the touch screen interface.
+	If you want MC13783 ADC support, you should say Y here
+
+config MXC_MC13783_AUDIO
+	tristate "MC13783 Audio support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 audio module driver. This module provides kernel API
+	for audio part of MC13783.
+	If you want MC13783 audio support, you should say Y here
+config MXC_MC13783_RTC
+	tristate "MC13783 Real Time Clock (RTC) support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 RTC module driver. This module provides kernel API
+	for RTC part of MC13783.
+	If you want MC13783 RTC support, you should say Y here
+config MXC_MC13783_LIGHT
+	tristate "MC13783 Light and Backlight support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 Light module driver. This module provides kernel API
+	for led and backlight control part of MC13783.
+	If you want MC13783 Light support, you should say Y here
+config MXC_MC13783_BATTERY
+	tristate "MC13783 Battery API support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 battery module driver. This module provides kernel API
+	for battery control part of MC13783.
+	If you want MC13783 battery support, you should say Y here
+config MXC_MC13783_CONNECTIVITY
+	tristate "MC13783 Connectivity API support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 connectivity module driver. This module provides kernel API
+	for USB/RS232 connectivity control part of MC13783.
+	If you want MC13783 connectivity support, you should say Y here
+config MXC_MC13783_POWER
+	tristate "MC13783 Power API support"
+	depends on MXC_PMIC_MC13783
+	---help---
+	This is the MC13783 power and supplies module driver. This module provides kernel API
+	for power and regulator control part of MC13783.
+	If you want MC13783 power support, you should say Y here
diff --git a/drivers/mxc/pmic/mc13783/Makefile b/drivers/mxc/pmic/mc13783/Makefile
new file mode 100644
index 0000000..7bbba23
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for the mc13783 pmic drivers.
+#
+
+obj-$(CONFIG_MXC_MC13783_ADC) += pmic_adc-mod.o
+obj-$(CONFIG_MXC_MC13783_AUDIO) += pmic_audio-mod.o
+obj-$(CONFIG_MXC_MC13783_RTC) += pmic_rtc-mod.o
+obj-$(CONFIG_MXC_MC13783_LIGHT) += pmic_light-mod.o
+obj-$(CONFIG_MXC_MC13783_BATTERY) += pmic_battery-mod.o
+obj-$(CONFIG_MXC_MC13783_CONNECTIVITY) += pmic_convity-mod.o
+obj-$(CONFIG_MXC_MC13783_POWER) += pmic_power-mod.o
+pmic_adc-mod-objs := pmic_adc.o
+pmic_audio-mod-objs := pmic_audio.o
+pmic_rtc-mod-objs := pmic_rtc.o
+pmic_light-mod-objs := pmic_light.o
+pmic_battery-mod-objs := pmic_battery.o
+pmic_convity-mod-objs := pmic_convity.o
+pmic_power-mod-objs := pmic_power.o
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc.c b/drivers/mxc/pmic/mc13783/pmic_adc.c
new file mode 100644
index 0000000..fb9ad4b
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_adc.c
@@ -0,0 +1,1542 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_adc.c
+ * @brief This is the main file of PMIC(mc13783) ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
+
+#include "../core/pmic.h"
+#include "pmic_adc_defs.h"
+
+#define NB_ADC_REG      5
+
+static int pmic_adc_major;
+
+/* internal function */
+static void callback_tsi(void *);
+static void callback_adcdone(void *);
+static void callback_adcbisdone(void *);
+static void callback_adc_comp_high(void *);
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the adc devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used by blocking application calls
+ */
+static wait_queue_head_t suspendq;
+
+static struct class *pmic_adc_class;
+
+/*
+ * ADC mc13783 API
+ */
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_adc_init);
+EXPORT_SYMBOL(pmic_adc_deinit);
+EXPORT_SYMBOL(pmic_adc_convert);
+EXPORT_SYMBOL(pmic_adc_convert_8x);
+EXPORT_SYMBOL(pmic_adc_convert_multichnnel);
+EXPORT_SYMBOL(pmic_adc_set_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_sample);
+EXPORT_SYMBOL(pmic_adc_get_battery_current);
+EXPORT_SYMBOL(pmic_adc_active_comparator);
+EXPORT_SYMBOL(pmic_adc_deactive_comparator);
+
+static DECLARE_COMPLETION(adcdone_it);
+static DECLARE_COMPLETION(adcbisdone_it);
+static DECLARE_COMPLETION(adc_tsi);
+static pmic_event_callback_t tsi_event;
+static pmic_event_callback_t event_adc;
+static pmic_event_callback_t event_adc_bis;
+static pmic_event_callback_t adc_comp_h;
+static bool data_ready_adc_1;
+static bool data_ready_adc_2;
+static bool adc_ts;
+static bool wait_ts;
+static bool monitor_en;
+static bool monitor_adc;
+static t_check_mode wcomp_mode;
+static DECLARE_MUTEX(convert_mutex);
+
+void (*monitoring_cb) (void);	/*call back to be called when event is detected. */
+
+static DECLARE_WAIT_QUEUE_HEAD(queue_adc_busy);
+static t_adc_state adc_dev[2];
+
+static unsigned channel_num[] = {
+	0,
+	1,
+	3,
+	4,
+	2,
+	12,
+	13,
+	14,
+	15,
+	-1,
+	5,
+	6,
+	7,
+	8,
+	9,
+	10,
+	11,
+	7,
+	6,
+	-1,
+	-1,
+	-1,
+	-1,
+	5,
+	7
+};
+
+static bool pmic_adc_ready;
+
+int is_pmic_adc_ready()
+{
+	return pmic_adc_ready;
+}
+EXPORT_SYMBOL(is_pmic_adc_ready);
+
+
+/*!
+ * This is the suspend of power management for the mc13783 ADC API.
+ * It supports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	unsigned int reg_value = 0;
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_2, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_4, reg_value, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the mc13783 adc API.
+ * It supports RESTORE state.
+ *
+ * @param        pdev           the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_resume(struct platform_device *pdev)
+{
+	/* nothing for mc13783 adc */
+	unsigned int adc_0_reg, adc_1_reg;
+	suspend_flag = 0;
+
+	/* let interrupt of TSI again */
+	adc_0_reg = ADC_WAIT_TSI_0;
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+	adc_1_reg = ADC_WAIT_TSI_1 | (ADC_BIS * adc_ts);
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*
+ * Call back functions
+ */
+
+/*!
+ * This is the callback function called on TSI mc13783 event, used in synchronous call.
+ */
+static void callback_tsi(void *unused)
+{
+	pr_debug("*** TSI IT mc13783 PMIC_ADC_GET_TOUCH_SAMPLE ***\n");
+	if (wait_ts) {
+		complete(&adc_tsi);
+		pmic_event_mask(EVENT_TSI);
+	}
+}
+
+/*!
+ * This is the callback function called on ADCDone mc13783 event.
+ */
+static void callback_adcdone(void *unused)
+{
+	if (data_ready_adc_1)
+		complete(&adcdone_it);
+
+}
+
+/*!
+ * This is the callback function called on ADCDone mc13783 event.
+ */
+static void callback_adcbisdone(void *unused)
+{
+	pr_debug("* adcdone bis it callback *\n");
+	if (data_ready_adc_2)
+		complete(&adcbisdone_it);
+
+}
+
+/*!
+ * This is the callback function called on mc13783 event.
+ */
+static void callback_adc_comp_high(void *unused)
+{
+	pr_debug("* adc comp it high *\n");
+	if (wcomp_mode == CHECK_HIGH || wcomp_mode == CHECK_LOW_OR_HIGH) {
+		/* launch callback */
+		if (monitoring_cb != NULL)
+			monitoring_cb();
+
+	}
+}
+
+/*!
+ * This function performs filtering and rejection of excessive noise prone
+ * samples.
+ *
+ * @param        ts_curr     Touch screen value
+ *
+ * @return       This function returns 0 on success, -1 otherwise.
+ */
+static int pmic_adc_filter(t_touch_screen *ts_curr)
+{
+	unsigned int ydiff1, ydiff2, ydiff3, xdiff1, xdiff2, xdiff3;
+	unsigned int sample_sumx, sample_sumy;
+	static unsigned int prev_x[FILTLEN], prev_y[FILTLEN];
+	int index = 0;
+	unsigned int y_curr, x_curr;
+	static int filt_count;
+	/* Added a variable filt_type to decide filtering at run-time */
+	unsigned int filt_type = 0;
+
+	if (ts_curr->contact_resistance == 0) {
+		ts_curr->x_position = 0;
+		ts_curr->y_position = 0;
+		filt_count = 0;
+		return 0;
+	}
+
+	ydiff1 = abs(ts_curr->y_position1 - ts_curr->y_position2);
+	ydiff2 = abs(ts_curr->y_position2 - ts_curr->y_position3);
+	ydiff3 = abs(ts_curr->y_position1 - ts_curr->y_position3);
+	if ((ydiff1 > DELTA_Y_MAX) ||
+	    (ydiff2 > DELTA_Y_MAX) || (ydiff3 > DELTA_Y_MAX)) {
+		pr_debug("pmic_adc_filter: Ret pos 1\n");
+		return -1;
+	}
+
+	xdiff1 = abs(ts_curr->x_position1 - ts_curr->x_position2);
+	xdiff2 = abs(ts_curr->x_position2 - ts_curr->x_position3);
+	xdiff3 = abs(ts_curr->x_position1 - ts_curr->x_position3);
+
+	if ((xdiff1 > DELTA_X_MAX) ||
+	    (xdiff2 > DELTA_X_MAX) || (xdiff3 > DELTA_X_MAX)) {
+		pr_debug("mc13783_adc_filter: Ret pos 2\n");
+		return -1;
+	}
+	/* Compute two closer values among the three available Y readouts */
+
+	if (ydiff1 < ydiff2) {
+		if (ydiff1 < ydiff3) {
+			/* Sample 0 & 1 closest together */
+			sample_sumy = ts_curr->y_position1 +
+				ts_curr->y_position2;
+		} else {
+			/* Sample 0 & 2 closest together */
+			sample_sumy = ts_curr->y_position1 +
+				ts_curr->y_position3;
+		}
+	} else {
+		if (ydiff2 < ydiff3) {
+			/* Sample 1 & 2 closest together */
+			sample_sumy = ts_curr->y_position2 +
+				ts_curr->y_position3;
+		} else {
+			/* Sample 0 & 2 closest together */
+			sample_sumy = ts_curr->y_position1 +
+				ts_curr->y_position3;
+		}
+	}
+
+	/*
+	 * Compute two closer values among the three available X
+	 * readouts
+	 */
+	if (xdiff1 < xdiff2) {
+		if (xdiff1 < xdiff3) {
+			/* Sample 0 & 1 closest together */
+			sample_sumx = ts_curr->x_position1 +
+				ts_curr->x_position2;
+		} else {
+			/* Sample 0 & 2 closest together */
+			sample_sumx = ts_curr->x_position1 +
+				ts_curr->x_position3;
+		}
+	} else {
+		if (xdiff2 < xdiff3) {
+			/* Sample 1 & 2 closest together */
+			sample_sumx = ts_curr->x_position2 +
+				ts_curr->x_position3;
+		} else {
+			/* Sample 0 & 2 closest together */
+			sample_sumx = ts_curr->x_position1 +
+				ts_curr->x_position3;
+		}
+	}
+	/*
+	 * Wait FILTER_MIN_DELAY number of samples to restart
+	 * filtering
+	 */
+	if (filt_count < FILTER_MIN_DELAY) {
+		/*
+		 * Current output is the average of the two closer
+		 * values and no filtering is used
+		 */
+		y_curr = (sample_sumy / 2);
+		x_curr = (sample_sumx / 2);
+		ts_curr->y_position = y_curr;
+		ts_curr->x_position = x_curr;
+		filt_count++;
+	} else {
+		if (abs(sample_sumx - (prev_x[0] + prev_x[1])) >
+		    (DELTA_X_MAX * 16)) {
+			pr_debug("pmic_adc_filter: : Ret pos 3\n");
+			return -1;
+		}
+		if (abs(sample_sumy - (prev_y[0] + prev_y[1])) >
+		    (DELTA_Y_MAX * 16)) {
+			return -1;
+		}
+		sample_sumy /= 2;
+		sample_sumx /= 2;
+		/* Use hard filtering if the sample difference < 10 */
+		if ((abs(sample_sumy - prev_y[0]) > 10) ||
+		    (abs(sample_sumx - prev_x[0]) > 10)) {
+			filt_type = 1;
+		}
+
+		/*
+		 * Current outputs are the average of three previous
+		 * values and the present readout
+		 */
+		y_curr = sample_sumy;
+		for (index = 0; index < FILTLEN; index++) {
+			if (filt_type == 0)
+				y_curr = y_curr + (prev_y[index]);
+			else
+				y_curr = y_curr + (prev_y[index] / 3);
+
+		}
+		if (filt_type == 0)
+			y_curr = y_curr >> 2;
+		else
+			y_curr = y_curr >> 1;
+
+		ts_curr->y_position = y_curr;
+
+		x_curr = sample_sumx;
+		for (index = 0; index < FILTLEN; index++) {
+			if (filt_type == 0)
+				x_curr = x_curr + (prev_x[index]);
+			else
+				x_curr = x_curr + (prev_x[index] / 3);
+
+		}
+		if (filt_type == 0)
+			x_curr = x_curr >> 2;
+		else
+			x_curr = x_curr >> 1;
+
+		ts_curr->x_position = x_curr;
+
+	}
+
+	/* Update previous X and Y values */
+	for (index = (FILTLEN - 1); index > 0; index--) {
+		prev_x[index] = prev_x[index - 1];
+		prev_y[index] = prev_y[index - 1];
+	}
+
+	/*
+	 * Current output will be the most recent past for the
+	 * next sample
+	 */
+	prev_y[0] = y_curr;
+	prev_x[0] = x_curr;
+
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_adc_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+	pr_debug("mc13783_adc : mc13783_adc_open()\n");
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_adc_free(struct inode *inode, struct file *file)
+{
+	pr_debug("mc13783_adc : mc13783_adc_free()\n");
+	return 0;
+}
+
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+int pmic_adc_init(void)
+{
+	unsigned int reg_value = 0, i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	for (i = 0; i < ADC_NB_AVAILABLE; i++)
+		adc_dev[i] = ADC_FREE;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_2, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_4, reg_value, PMIC_ALL_BITS));
+	reg_value = 0x001000;
+	CHECK_ERROR(pmic_write_reg(REG_ARBITRATION_PERIPHERAL_AUDIO, reg_value,
+				   0xFFFFFF));
+
+	data_ready_adc_1 = false;
+	data_ready_adc_2 = false;
+	adc_ts = false;
+	wait_ts = false;
+	monitor_en = false;
+	monitor_adc = false;
+	wcomp_mode = CHECK_LOW;
+	monitoring_cb = NULL;
+	/* sub to ADCDone IT */
+	event_adc.param = NULL;
+	event_adc.func = callback_adcdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCDONEI, event_adc));
+
+	/* sub to ADCDoneBis IT */
+	event_adc_bis.param = NULL;
+	event_adc_bis.func = callback_adcbisdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCBISDONEI, event_adc_bis));
+
+	/* sub to Touch Screen IT */
+	tsi_event.param = NULL;
+	tsi_event.func = callback_tsi;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TSI, tsi_event));
+
+	/* ADC reading above high limit */
+	adc_comp_h.param = NULL;
+	adc_comp_h.func = callback_adc_comp_high;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_WHIGHI, adc_comp_h));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void)
+{
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCDONEI, event_adc));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCBISDONEI, event_adc_bis));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TSI, tsi_event));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_WHIGHI, adc_comp_h));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initializes adc_param structure.
+ *
+ * @param        adc_param     Structure to be initialized.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_init_param(t_adc_param *adc_param)
+{
+	int i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	adc_param->delay = 0;
+	adc_param->conv_delay = false;
+	adc_param->single_channel = false;
+	adc_param->group = false;
+	adc_param->channel_0 = BATTERY_VOLTAGE;
+	adc_param->channel_1 = BATTERY_VOLTAGE;
+	adc_param->read_mode = 0;
+	adc_param->wait_tsi = 0;
+	adc_param->chrgraw_devide_5 = true;
+	adc_param->read_ts = false;
+	adc_param->ts_value.x_position = 0;
+	adc_param->ts_value.y_position = 0;
+	adc_param->ts_value.contact_resistance = 0;
+	for (i = 0; i <= MAX_CHANNEL; i++)
+		adc_param->value[i] = 0;
+
+	return 0;
+}
+
+/*!
+ * This function starts the convert.
+ *
+ * @param        adc_param      contains all adc configuration and return value.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS mc13783_adc_convert(t_adc_param *adc_param)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, reg_1 = 0, result_reg =
+	    0, i = 0;
+	unsigned int result = 0, temp = 0;
+	pmic_version_t mc13783_ver;
+	pr_debug("mc13783 ADC - mc13783_adc_convert ....\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (adc_param->wait_tsi) {
+		/* we need to set ADCEN 1 for TSI interrupt on mc13783 1.x */
+		/* configure adc to wait tsi interrupt */
+		INIT_COMPLETION(adc_tsi);
+		pr_debug("mc13783 ADC - pmic_write_reg ....\n");
+		/*for ts don't use bis */
+		adc_0_reg = 0x001c00 | (ADC_BIS * 0);
+		pmic_event_unmask(EVENT_TSI);
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+		/*for ts don't use bis */
+		adc_1_reg = 0x200001 | (ADC_BIS * 0);
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+		pr_debug("wait tsi ....\n");
+		wait_ts = true;
+		wait_for_completion_interruptible(&adc_tsi);
+		wait_ts = false;
+	}
+	if (adc_param->read_ts == false)
+		down(&convert_mutex);
+	use_bis = mc13783_adc_request(adc_param->read_ts);
+	if (use_bis < 0) {
+		pr_debug("process has received a signal and got interrupted\n");
+		return -EINTR;
+	}
+
+	/* CONFIGURE ADC REG 0 */
+	adc_0_reg = 0;
+	adc_1_reg = 0;
+	if (adc_param->read_ts == false) {
+		adc_0_reg = adc_param->read_mode & 0x00003F;
+		/* add auto inc */
+		adc_0_reg |= ADC_INC;
+		if (use_bis) {
+			/* add adc bis */
+			adc_0_reg |= ADC_BIS;
+		}
+		mc13783_ver = pmic_get_version();
+		if (mc13783_ver.revision >= 20) {
+			if (adc_param->chrgraw_devide_5)
+				adc_0_reg |= ADC_CHRGRAW_D5;
+
+		}
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+
+		if (adc_param->conv_delay)
+			adc_1_reg |= ADC_ATO;
+
+
+		if (adc_param->group)
+			adc_1_reg |= ADC_ADSEL;
+
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+
+		adc_1_reg |= (adc_param->channel_0 << ADC_CH_0_POS) &
+		    ADC_CH_0_MASK;
+		adc_1_reg |= (adc_param->channel_1 << ADC_CH_1_POS) &
+		    ADC_CH_1_MASK;
+	} else {
+		adc_0_reg = 0x003c00 | (ADC_BIS * use_bis) | ADC_INC;
+	}
+	pr_debug("Write Reg %i = %x\n", REG_ADC_0, adc_0_reg);
+	/*Change has been made here */
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg,
+				   ADC_INC | ADC_BIS | ADC_CHRGRAW_D5 |
+				   0xfff00ff));
+	/* CONFIGURE ADC REG 1 */
+	if (adc_param->read_ts == false) {
+		adc_1_reg |= ADC_NO_ADTRIG;
+		adc_1_reg |= ADC_EN;
+		adc_1_reg |= (adc_param->delay << ADC_DELAY_POS) &
+		    ADC_DELAY_MASK;
+		if (use_bis)
+			adc_1_reg |= ADC_BIS;
+
+	} else {
+		/* configure and start convert to read x and y position */
+		/* configure to read 2 value in channel selection 1 & 2 */
+		adc_1_reg = 0x100409 | (ADC_BIS * use_bis) | ADC_NO_ADTRIG;
+	}
+	reg_1 = adc_1_reg;
+	if (use_bis == 0) {
+		data_ready_adc_1 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_1 = true;
+		pr_debug("Write Reg %i = %x\n", REG_ADC_1, adc_1_reg);
+		INIT_COMPLETION(adcdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg,
+					   ADC_SGL_CH | ADC_ATO | ADC_ADSEL
+					   | ADC_CH_0_MASK | ADC_CH_1_MASK |
+					   ADC_NO_ADTRIG | ADC_EN |
+					   ADC_DELAY_MASK | ASC_ADC | ADC_BIS));
+		pr_debug("wait adc done\n");
+		wait_for_completion_interruptible(&adcdone_it);
+		data_ready_adc_1 = false;
+	} else {
+		data_ready_adc_2 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_2 = true;
+		INIT_COMPLETION(adcbisdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, 0xFFFFFF));
+		temp = 0x800000;
+		CHECK_ERROR(pmic_write_reg(REG_ADC_3, temp, 0xFFFFFF));
+		temp = 0x001000;
+		pmic_write_reg(REG_ARBITRATION_PERIPHERAL_AUDIO, temp,
+			       0xFFFFFF);
+		pr_debug("wait adc done bis\n");
+		wait_for_completion_interruptible(&adcbisdone_it);
+		data_ready_adc_2 = false;
+	}
+	/* read result and store in adc_param */
+	result = 0;
+	if (use_bis == 0)
+		result_reg = REG_ADC_2;
+	else
+		result_reg = REG_ADC_4;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, 4 << ADC_CH_1_POS,
+				   ADC_CH_0_MASK | ADC_CH_1_MASK));
+
+	for (i = 0; i <= 3; i++) {
+		CHECK_ERROR(pmic_read_reg(result_reg, &result, PMIC_ALL_BITS));
+		pr_debug("result %i = %x\n", result_reg, result);
+		adc_param->value[i] = ((result & ADD1_RESULT_MASK) >> 2);
+		adc_param->value[i + 4] = ((result & ADD2_RESULT_MASK) >> 14);
+	}
+	if (adc_param->read_ts) {
+		adc_param->ts_value.x_position = adc_param->value[2];
+		adc_param->ts_value.x_position1 = adc_param->value[0];
+		adc_param->ts_value.x_position2 = adc_param->value[1];
+		adc_param->ts_value.x_position3 = adc_param->value[2];
+		adc_param->ts_value.y_position1 = adc_param->value[3];
+		adc_param->ts_value.y_position2 = adc_param->value[4];
+		adc_param->ts_value.y_position3 = adc_param->value[5];
+		adc_param->ts_value.y_position = adc_param->value[5];
+		adc_param->ts_value.contact_resistance = adc_param->value[6];
+
+	}
+
+	/*if (adc_param->read_ts) {
+	   adc_param->ts_value.x_position = adc_param->value[2];
+	   adc_param->ts_value.y_position = adc_param->value[5];
+	   adc_param->ts_value.contact_resistance = adc_param->value[6];
+	   } */
+	mc13783_adc_release(use_bis);
+	if (adc_param->read_ts == false)
+		up(&convert_mutex);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function select the required read_mode for a specific channel.
+ *
+ * @param        channel   The channel to be sampled
+ *
+ * @return       This function returns the requires read_mode
+ */
+t_reading_mode mc13783_set_read_mode(t_channel channel)
+{
+	t_reading_mode read_mode = 0;
+
+	switch (channel) {
+	case LICELL:
+		read_mode = M_LITHIUM_CELL;
+		break;
+	case CHARGE_CURRENT:
+		read_mode = M_CHARGE_CURRENT;
+		break;
+	case BATTERY_CURRENT:
+		read_mode = M_BATTERY_CURRENT;
+		break;
+	case THERMISTOR:
+		read_mode = M_THERMISTOR;
+		break;
+	case DIE_TEMP:
+		read_mode = M_DIE_TEMPERATURE;
+		break;
+	case USB_ID:
+		read_mode = M_UID;
+		break;
+	default:
+		read_mode = 0;
+	}
+
+	return read_mode;
+}
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	PMIC_STATUS ret;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	channel = channel_num[channel];
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert\n");
+	adc_param.read_ts = false;
+	adc_param.read_mode = mc13783_set_read_mode(channel);
+
+	adc_param.single_channel = true;
+	/* Find the group */
+	if ((channel >= 0) && (channel <= 7)) {
+		adc_param.channel_0 = channel;
+		adc_param.group = false;
+	} else if ((channel >= 8) && (channel <= 15)) {
+		adc_param.channel_0 = channel & 0x07;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+	ret = mc13783_adc_convert(&adc_param);
+	*result = adc_param.value[0];
+	return ret;
+}
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	channel = channel_num[channel];
+
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_8x\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13783_set_read_mode(channel);
+	if ((channel >= 0) && (channel <= 7)) {
+		adc_param.channel_0 = channel;
+		adc_param.channel_1 = channel;
+		adc_param.group = false;
+	} else if ((channel >= 8) && (channel <= 15)) {
+		adc_param.channel_0 = channel & 0x07;
+		adc_param.channel_1 = channel & 0x07;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	ret = mc13783_adc_convert(&adc_param);
+	for (i = 0; i <= 7; i++)
+		result[i] = adc_param.value[i];
+
+	return ret;
+}
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mc13783_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_multichnnel\n");
+
+	channels = channel_num[channels];
+
+	if (channels == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	adc_param.read_ts = false;
+	adc_param.single_channel = false;
+	if ((channels >= 0) && (channels <= 7)) {
+		adc_param.channel_0 = channels;
+		adc_param.channel_1 = ((channels + 4) % 4) + 4;
+		adc_param.group = false;
+	} else if ((channels >= 8) && (channels <= 15)) {
+		channels = channels & 0x07;
+		adc_param.channel_0 = channels;
+		adc_param.channel_1 = ((channels + 4) % 4) + 4;
+		adc_param.group = true;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+	adc_param.read_mode = 0x00003f;
+	adc_param.read_ts = false;
+	ret = mc13783_adc_convert(&adc_param);
+
+	for (i = 0; i <= 7; i++)
+		result[i] = adc_param.value[i];
+
+	return ret;
+}
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode)
+{
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0,
+				   BITFVAL(MC13783_ADC0_TS_M, touch_mode),
+				   BITFMASK(MC13783_ADC0_TS_M)));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode)
+{
+	unsigned int value;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(REG_ADC_0, &value, PMIC_ALL_BITS));
+
+	*touch_mode = BITFEXT(value, MC13783_ADC0_TS_M);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrieves the current touch screen (X,Y) coordinates.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	indicates whether this call must block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *touch_sample, int wait)
+{
+	if (mc13783_adc_read_ts(touch_sample, wait) != 0)
+		return PMIC_ERROR;
+	if (0 == pmic_adc_filter(touch_sample))
+		return PMIC_SUCCESS;
+	else
+		return PMIC_ERROR;
+}
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        ts_value    return value of touch screen
+ * @param        wait_tsi    if true, this function is synchronous (wait in TSI event).
+ *
+ * @return       This function returns 0.
+ */
+PMIC_STATUS mc13783_adc_read_ts(t_touch_screen *ts_value, int wait_tsi)
+{
+	t_adc_param param;
+	pr_debug("mc13783_adc : mc13783_adc_read_ts\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (wait_ts) {
+		pr_debug("mc13783_adc : error TS busy\n");
+		return PMIC_ERROR;
+	}
+	mc13783_adc_init_param(&param);
+	param.wait_tsi = wait_tsi;
+	param.read_ts = true;
+	if (mc13783_adc_convert(&param) != 0)
+		return PMIC_ERROR;
+	/* check if x-y is ok */
+	if ((param.ts_value.x_position1 < TS_X_MAX) &&
+	    (param.ts_value.x_position1 >= TS_X_MIN) &&
+	    (param.ts_value.y_position1 < TS_Y_MAX) &&
+	    (param.ts_value.y_position1 >= TS_Y_MIN) &&
+	    (param.ts_value.x_position2 < TS_X_MAX) &&
+	    (param.ts_value.x_position2 >= TS_X_MIN) &&
+	    (param.ts_value.y_position2 < TS_Y_MAX) &&
+	    (param.ts_value.y_position2 >= TS_Y_MIN) &&
+	    (param.ts_value.x_position3 < TS_X_MAX) &&
+	    (param.ts_value.x_position3 >= TS_X_MIN) &&
+	    (param.ts_value.y_position3 < TS_Y_MAX) &&
+	    (param.ts_value.y_position3 >= TS_Y_MIN)) {
+		ts_value->x_position = param.ts_value.x_position;
+		ts_value->x_position1 = param.ts_value.x_position1;
+		ts_value->x_position2 = param.ts_value.x_position2;
+		ts_value->x_position3 = param.ts_value.x_position3;
+		ts_value->y_position = param.ts_value.y_position;
+		ts_value->y_position1 = param.ts_value.y_position1;
+		ts_value->y_position2 = param.ts_value.y_position2;
+		ts_value->y_position3 = param.ts_value.y_position3;
+		ts_value->contact_resistance =
+		    param.ts_value.contact_resistance + 1;
+
+	} else {
+		ts_value->x_position = 0;
+		ts_value->y_position = 0;
+		ts_value->contact_resistance = 0;
+
+	}
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result)
+{
+	PMIC_STATUS ret;
+	t_channel channel;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = BATTERY_CURRENT;
+	if (mode == ADC_8CHAN_1X)
+		ret = pmic_adc_convert(channel, result);
+	else
+		ret = pmic_adc_convert_8x(channel, result);
+
+	return ret;
+}
+
+/*!
+ * This function request a ADC.
+ *
+ * @return      This function returns index of ADC to be used (0 or 1) if successful.
+ *  return -1 if error.
+ */
+int mc13783_adc_request(bool read_ts)
+{
+	int adc_index = -1;
+	if (read_ts != 0) {
+		/*for ts we use bis=0 */
+		if (adc_dev[0] == ADC_USED)
+			return -1;
+		/*no wait here */
+		adc_dev[0] = ADC_USED;
+		adc_index = 0;
+	} else {
+		/*for other adc use bis = 1 */
+		if (adc_dev[1] == ADC_USED) {
+			return -1;
+			/*no wait here */
+		}
+		adc_dev[1] = ADC_USED;
+		adc_index = 1;
+	}
+	pr_debug("mc13783_adc : request ADC %d\n", adc_index);
+	return adc_index;
+}
+
+/*!
+ * This function release an ADC.
+ *
+ * @param        adc_index     index of ADC to be released.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_release(int adc_index)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+
+	pr_debug("mc13783_adc : release ADC %d\n", adc_index);
+	if ((adc_dev[adc_index] == ADC_MONITORING) ||
+	    (adc_dev[adc_index] == ADC_USED)) {
+		adc_dev[adc_index] = ADC_FREE;
+		wake_up(&queue_adc_busy);
+		return 0;
+	}
+	return -1;
+}
+
+/*!
+ * This function initializes monitoring structure.
+ *
+ * @param        monitor     Structure to be initialized.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_init_monitor_param(t_monitoring_param *monitor)
+{
+	pr_debug("mc13783_adc : init monitor\n");
+	monitor->delay = 0;
+	monitor->conv_delay = false;
+	monitor->channel = BATTERY_VOLTAGE;
+	monitor->read_mode = 0;
+	monitor->comp_low = 0;
+	monitor->comp_high = 0;
+	monitor->group = 0;
+	monitor->check_mode = CHECK_LOW_OR_HIGH;
+	monitor->callback = NULL;
+	return 0;
+}
+
+/*!
+ * This function actives the comparator.  When comparator is active and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        channel  The channel to be sampled
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, adc_3_reg = 0;
+	t_monitoring_param monitoring;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (monitor_en) {
+		pr_debug("mc13783_adc : monitoring already configured\n");
+		return PMIC_ERROR;
+	}
+	monitor_en = true;
+	mc13783_adc_init_monitor_param(&monitoring);
+	monitoring.comp_low = low;
+	monitoring.comp_high = high;
+	monitoring.channel = channel;
+	monitoring.callback = (void *)callback;
+
+	use_bis = mc13783_adc_request(false);
+	if (use_bis < 0) {
+		pr_debug("mc13783_adc : request error\n");
+		return PMIC_ERROR;
+	}
+	monitor_adc = use_bis;
+
+	adc_0_reg = 0;
+
+	/* TO DO ADOUT CONFIGURE */
+	adc_0_reg = monitoring.read_mode & ADC_MODE_MASK;
+	if (use_bis) {
+		/* add adc bis */
+		adc_0_reg |= ADC_BIS;
+	}
+	adc_0_reg |= ADC_WCOMP;
+
+	/* CONFIGURE ADC REG 1 */
+	adc_1_reg = 0;
+	adc_1_reg |= ADC_EN;
+	if (monitoring.conv_delay)
+		adc_1_reg |= ADC_ATO;
+
+	if (monitoring.group)
+		adc_1_reg |= ADC_ADSEL;
+
+	adc_1_reg |= (monitoring.channel << ADC_CH_0_POS) & ADC_CH_0_MASK;
+	adc_1_reg |= (monitoring.delay << ADC_DELAY_POS) & ADC_DELAY_MASK;
+	if (use_bis)
+		adc_1_reg |= ADC_BIS;
+
+
+	adc_3_reg |= (monitoring.comp_high << ADC_WCOMP_H_POS) &
+	    ADC_WCOMP_H_MASK;
+	adc_3_reg |= (monitoring.comp_low << ADC_WCOMP_L_POS) &
+	    ADC_WCOMP_L_MASK;
+	if (use_bis)
+		adc_3_reg |= ADC_BIS;
+
+
+	wcomp_mode = monitoring.check_mode;
+	/* call back to be called when event is detected. */
+	monitoring_cb = monitoring.callback;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, adc_0_reg, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, adc_1_reg, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, adc_3_reg, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function deactivates the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (!monitor_en) {
+		pr_debug("mc13783_adc : adc monitoring free\n");
+		return PMIC_ERROR;
+	}
+
+	if (monitor_en)
+		reg_value = ADC_BIS;
+
+
+	/* clear all reg value */
+	CHECK_ERROR(pmic_write_reg(REG_ADC_0, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_1, reg_value, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC_3, reg_value, PMIC_ALL_BITS));
+
+	reg_value = 0;
+
+	if (monitor_adc) {
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_4, reg_value, PMIC_ALL_BITS));
+	} else {
+		CHECK_ERROR(pmic_write_reg
+			    (REG_ADC_2, reg_value, PMIC_ALL_BITS));
+	}
+
+	mc13783_adc_release(monitor_adc);
+	monitor_en = false;
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function implements IOCTL controls on a MC13783 ADC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_adc_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	t_adc_convert_param *convert_param;
+	t_touch_mode touch_mode;
+	t_touch_screen touch_sample;
+	unsigned short b_current;
+	t_adc_comp_param *comp_param;
+	if ((_IOC_TYPE(cmd) != 'p') && (_IOC_TYPE(cmd) != 'D'))
+		return -ENOTTY;
+
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+
+	switch (cmd) {
+	case PMIC_ADC_INIT:
+		pr_debug("init adc\n");
+		CHECK_ERROR(pmic_adc_init());
+		break;
+
+	case PMIC_ADC_DEINIT:
+		pr_debug("deinit adc\n");
+		CHECK_ERROR(pmic_adc_deinit());
+		break;
+
+	case PMIC_ADC_CONVERT:
+		convert_param = kmalloc(sizeof(t_adc_convert_param), GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_convert(convert_param->channel,
+						   convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_CONVERT_8X:
+		convert_param = kmalloc(sizeof(t_adc_convert_param), GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_convert_8x(convert_param->channel,
+						      convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_CONVERT_MULTICHANNEL:
+		convert_param = kmalloc(sizeof(t_adc_convert_param), GFP_KERNEL);
+		if (convert_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(convert_param, (t_adc_convert_param *) arg,
+				   sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_adc_convert_multichnnel
+				  (convert_param->channel,
+				   convert_param->result),
+				  (kfree(convert_param)));
+
+		if (copy_to_user((t_adc_convert_param *) arg, convert_param,
+				 sizeof(t_adc_convert_param))) {
+			kfree(convert_param);
+			return -EFAULT;
+		}
+		kfree(convert_param);
+		break;
+
+	case PMIC_ADC_SET_TOUCH_MODE:
+		CHECK_ERROR(pmic_adc_set_touch_mode((t_touch_mode) arg));
+		break;
+
+	case PMIC_ADC_GET_TOUCH_MODE:
+		CHECK_ERROR(pmic_adc_get_touch_mode(&touch_mode));
+		if (copy_to_user((t_touch_mode *) arg, &touch_mode,
+				 sizeof(t_touch_mode))) {
+			return -EFAULT;
+		}
+		break;
+
+	case PMIC_ADC_GET_TOUCH_SAMPLE:
+		pr_debug("pmic_adc_ioctl: " "PMIC_ADC_GET_TOUCH_SAMPLE\n");
+		CHECK_ERROR(pmic_adc_get_touch_sample(&touch_sample, 1));
+		if (copy_to_user((t_touch_screen *) arg, &touch_sample,
+				 sizeof(t_touch_screen))) {
+			return -EFAULT;
+		}
+		break;
+
+	case PMIC_ADC_GET_BATTERY_CURRENT:
+		CHECK_ERROR(pmic_adc_get_battery_current(ADC_8CHAN_1X,
+							 &b_current));
+		if (copy_to_user((unsigned short *)arg, &b_current,
+				 sizeof(unsigned short))) {
+
+			return -EFAULT;
+		}
+		break;
+
+	case PMIC_ADC_ACTIVATE_COMPARATOR:
+		comp_param = kmalloc(sizeof(t_adc_comp_param), GFP_KERNEL);
+		if (comp_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(comp_param, (t_adc_comp_param *) arg,
+				   sizeof(t_adc_comp_param))) {
+			kfree(comp_param);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_adc_active_comparator(comp_param->wlow,
+							     comp_param->whigh,
+							     comp_param->
+							     channel,
+							     comp_param->
+							     callback),
+				  (kfree(comp_param)));
+		break;
+
+	case PMIC_ADC_DEACTIVE_COMPARATOR:
+		CHECK_ERROR(pmic_adc_deactive_comparator());
+		break;
+
+	default:
+		pr_debug("pmic_adc_ioctl: unsupported ioctl command 0x%x\n",
+			 cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct file_operations mc13783_adc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_adc_ioctl,
+	.open = pmic_adc_open,
+	.release = pmic_adc_free,
+};
+
+static int pmic_adc_module_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	pmic_adc_major = register_chrdev(0, "pmic_adc", &mc13783_adc_fops);
+
+	if (pmic_adc_major < 0) {
+		pr_debug(KERN_ERR "Unable to get a major for pmic_adc\n");
+		return pmic_adc_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	pmic_adc_class = class_create(THIS_MODULE, "pmic_adc");
+	if (IS_ERR(pmic_adc_class)) {
+		pr_debug(KERN_ERR "Error creating pmic_adc class.\n");
+		ret = PTR_ERR(pmic_adc_class);
+		goto err_out1;
+	}
+
+	temp_class = device_create(pmic_adc_class, NULL,
+				   MKDEV(pmic_adc_major, 0), NULL, "pmic_adc");
+	if (IS_ERR(temp_class)) {
+		pr_debug(KERN_ERR "Error creating pmic_adc class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	ret = pmic_adc_init();
+	if (ret != PMIC_SUCCESS) {
+		pr_debug(KERN_ERR "Error in pmic_adc_init.\n");
+		goto err_out4;
+	}
+
+	pmic_adc_ready = 1;
+	pr_debug(KERN_INFO "PMIC ADC successfully probed\n");
+	return ret;
+
+err_out4:
+	device_destroy(pmic_adc_class, MKDEV(pmic_adc_major, 0));
+err_out2:
+	class_destroy(pmic_adc_class);
+err_out1:
+	unregister_chrdev(pmic_adc_major, "pmic_adc");
+	return ret;
+}
+
+static int pmic_adc_module_remove(struct platform_device *pdev)
+{
+	pmic_adc_ready = 0;
+	pmic_adc_deinit();
+	device_destroy(pmic_adc_class, MKDEV(pmic_adc_major, 0));
+	class_destroy(pmic_adc_class);
+	unregister_chrdev(pmic_adc_major, "pmic_adc");
+	pr_debug(KERN_INFO "PMIC ADC successfully removed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_adc_driver_ldm = {
+	.driver = {
+		   .name = "pmic_adc",
+		   },
+	.suspend = pmic_adc_suspend,
+	.resume = pmic_adc_resume,
+	.probe = pmic_adc_module_probe,
+	.remove = pmic_adc_module_remove,
+};
+
+/*
+ * Initialization and Exit
+ */
+static int __init pmic_adc_module_init(void)
+{
+	pr_debug("PMIC ADC driver loading...\n");
+	return platform_driver_register(&pmic_adc_driver_ldm);
+}
+
+static void __exit pmic_adc_module_exit(void)
+{
+	platform_driver_unregister(&pmic_adc_driver_ldm);
+	pr_debug("PMIC ADC driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+module_init(pmic_adc_module_init);
+module_exit(pmic_adc_module_exit);
+
+MODULE_DESCRIPTION("PMIC ADC device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_adc_defs.h b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
new file mode 100644
index 0000000..3597195
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_adc_defs.h
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_adc_defs.h
+ * @brief This header contains all defines for PMIC(mc13783) ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#ifndef __MC13783_ADC__DEFS_H__
+#define __MC13783_ADC__DEFS_H__
+
+#define MC13783_ADC_DEVICE "/dev/mc13783_adc"
+
+#define         DEF_ADC_0     0x008000
+#define         DEF_ADC_3     0x000080
+
+#define ADC_NB_AVAILABLE        2
+
+#define MAX_CHANNEL             7
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch-screen
+ */
+#define DELTA_Y_MAX             50
+#define DELTA_X_MAX             50
+
+/* Upon clearing the filter, this is the delay in restarting the filter */
+#define FILTER_MIN_DELAY        4
+
+/* Length of X and Y Touch screen filters */
+#define FILTLEN                 3
+
+#define TS_X_MAX                1000
+#define TS_Y_MAX                1000
+
+#define TS_X_MIN                80
+#define TS_Y_MIN                80
+
+#define MC13783_ADC0_TS_M_LSH	14
+#define MC13783_ADC0_TS_M_WID	3
+/*
+ * ADC 0
+ */
+#define ADC_WAIT_TSI_0		0x001C00
+
+/*
+ * ADC 1
+ */
+
+#define ADC_EN                  0x000001
+#define ADC_SGL_CH              0x000002
+#define ADC_ADSEL               0x000008
+#define ADC_CH_0_POS            5
+#define ADC_CH_0_MASK           0x0000E0
+#define ADC_CH_1_POS            8
+#define ADC_CH_1_MASK           0x000700
+#define ADC_DELAY_POS           11
+#define ADC_DELAY_MASK          0x07F800
+#define ADC_ATO                 0x080000
+#define ASC_ADC                 0x100000
+#define ADC_WAIT_TSI_1		0x300001
+#define ADC_CHRGRAW_D5          0x008000
+
+/*
+ * ADC 2 - 4
+ */
+#define ADD1_RESULT_MASK        0x00000FFC
+#define ADD2_RESULT_MASK        0x00FFC000
+#define ADC_TS_MASK             0x00FFCFFC
+
+/*
+ * ADC 3
+ */
+#define ADC_INC                 0x030000
+#define ADC_BIS                 0x800000
+
+/*
+ * ADC 3
+ */
+#define ADC_NO_ADTRIG           0x200000
+#define ADC_WCOMP               0x040000
+#define ADC_WCOMP_H_POS         0
+#define ADC_WCOMP_L_POS         9
+#define ADC_WCOMP_H_MASK        0x00003F
+#define ADC_WCOMP_L_MASK        0x007E00
+
+#define ADC_MODE_MASK           0x00003F
+
+/*
+ * Interrupt Status 0
+ */
+#define ADC_INT_BISDONEI        0x02
+
+/*!
+ * Define state mode of ADC.
+ */
+typedef enum adc_state {
+	/*!
+	 * Free.
+	 */
+	ADC_FREE,
+	/*!
+	 * Used.
+	 */
+	ADC_USED,
+	/*!
+	 * Monitoring
+	 */
+	ADC_MONITORING,
+} t_adc_state;
+
+/*!
+ * This enumeration, is used to configure the mode of ADC.
+ */
+typedef enum reading_mode {
+	/*!
+	 * Enables lithium cell reading
+	 */
+	M_LITHIUM_CELL = 0x000001,
+	/*!
+	 * Enables charge current reading
+	 */
+	M_CHARGE_CURRENT = 0x000002,
+	/*!
+	 * Enables battery current reading
+	 */
+	M_BATTERY_CURRENT = 0x000004,
+	/*!
+	 * Enables thermistor reading
+	 */
+	M_THERMISTOR = 0x000008,
+	/*!
+	 * Enables die temperature reading
+	 */
+	M_DIE_TEMPERATURE = 0x000010,
+	/*!
+	 * Enables UID reading
+	 */
+	M_UID = 0x000020,
+} t_reading_mode;
+
+/*!
+ * This enumeration, is used to configure the monitoring mode.
+ */
+typedef enum check_mode {
+	/*!
+	 * Comparator low level
+	 */
+	CHECK_LOW,
+	/*!
+	 * Comparator high level
+	 */
+	CHECK_HIGH,
+	/*!
+	 * Comparator low or high level
+	 */
+	CHECK_LOW_OR_HIGH,
+} t_check_mode;
+
+/*!
+ * This structure is used to configure and report adc value.
+ */
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Sets the single channel mode
+	 */
+	bool single_channel;
+	/*!
+	 * Selects the set of inputs
+	 */
+	bool group;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel_0;
+	/*!
+	 * Channel selection 2
+	 */
+	t_channel channel_1;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	t_reading_mode read_mode;
+	/*!
+	 * Sets the Touch screen mode
+	 */
+	bool read_ts;
+	/*!
+	 * Wait TSI event before touch screen reading
+	 */
+	bool wait_tsi;
+	/*!
+	 * Sets CHRGRAW scaling to divide by 5
+	 * Only supported on 2.0 and higher
+	 */
+	bool chrgraw_devide_5;
+	/*!
+	 * Return ADC values
+	 */
+	unsigned int value[8];
+	/*!
+	 * Return touch screen values
+	 */
+	t_touch_screen ts_value;
+} t_adc_param;
+
+/*!
+ * This structure is used to configure the monitoring mode of ADC.
+ */
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel;
+	/*!
+	 * Selects the set of inputs
+	 */
+	bool group;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	unsigned int read_mode;
+	/*!
+	 * Comparator low level in WCOMP mode
+	 */
+	unsigned int comp_low;
+	/*!
+	 * Comparator high level in WCOMP mode
+	 */
+	unsigned int comp_high;
+	/*!
+	 * Sets type of monitoring (low, high or both)
+	 */
+	t_check_mode check_mode;
+	/*!
+	 * Callback to be launched when event is detected
+	 */
+	void (*callback) (void);
+} t_monitoring_param;
+
+/*!
+ * This function performs filtering and rejection of excessive noise prone
+ * samples.
+ *
+ * @param        ts_curr     Touch screen value
+ *
+ * @return       This function returns 0 on success, -1 otherwise.
+ */
+static int pmic_adc_filter(t_touch_screen *ts_curr);
+
+/*!
+ * This function request a ADC.
+ *
+ * @return      This function returns index of ADC to be used (0 or 1) if successful.
+ * return -1 if error.
+ */
+int mc13783_adc_request(bool read_ts);
+
+/*!
+ * This function is used to update buffer of touch screen value in read mode.
+ */
+void update_buffer(void);
+
+/*!
+ * This function release an ADC.
+ *
+ * @param        adc_index     index of ADC to be released.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int mc13783_adc_release(int adc_index);
+
+/*!
+ * This function select the required read_mode for a specific channel.
+ *
+ * @param        channel   The channel to be sampled
+ *
+ * @return       This function returns the requires read_mode
+ */
+t_reading_mode mc13783_set_read_mode(t_channel channel);
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        touch_sample    return value of touch screen
+ * @param        wait_tsi    if true, this function is synchronous (wait in TSI event).
+ *
+ * @return       This function returns 0.
+ */
+PMIC_STATUS mc13783_adc_read_ts(t_touch_screen *touch_sample, int wait_tsi);
+
+#endif				/* __MC13783_ADC__DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_audio.c b/drivers/mxc/pmic/mc13783/pmic_audio.c
new file mode 100644
index 0000000..735d3af
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_audio.c
@@ -0,0 +1,5876 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_audio.c
+ * @brief Implementation of the PMIC(mc13783) Audio driver APIs.
+ *
+ * The PMIC Audio driver and this API were developed to support the
+ * audio playback, recording, and mixing capabilities of the power
+ * management ICs that are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes are supported:
+ *
+ * @verbatim
+       Operating Mode               mc13783
+       ---------------------------- -------
+       Stereo DAC Playback           Yes
+       Stereo DAC Input Mixing       Yes
+       Voice CODEC Playback          Yes
+       Voice CODEC Input Mixing      Yes
+       Voice CODEC Mono Recording    Yes
+       Voice CODEC Stereo Recording  Yes
+       Microphone Bias Control       Yes
+       Output Amplifier Control      Yes
+       Output Mixing Control         Yes
+       Input Amplifier Control       Yes
+       Master/Slave Mode Select      Yes
+       Anti Pop Bias Circuit Control Yes
+   @endverbatim
+ *
+ * Note that the Voice CODEC may also be referred to as the Telephone
+ * CODEC in the PMIC DTS documentation. Also note that, while the power
+ * management ICs do provide similar audio capabilities, each PMIC may
+ * support additional configuration settings and features. Therefore, it
+ * is highly recommended that the appropriate power management IC DTS
+ * documents be used in conjunction with this API interface.
+ *
+ * @ingroup PMIC_AUDIO
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>	/* For tasklet interface.              */
+#include <linux/platform_device.h>	/* For kernel module interface.        */
+#include <linux/init.h>
+#include <linux/spinlock.h>	/* For spinlock interface.             */
+#include <linux/pmic_adc.h>	/* For PMIC ADC driver interface.      */
+#include <linux/pmic_status.h>
+#include <mach/pmic_audio.h>	/* For PMIC Audio driver interface.    */
+
+/*
+ * mc13783 PMIC Audio API
+ */
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(MIN_STDAC_SAMPLING_RATE_HZ);
+EXPORT_SYMBOL(MAX_STDAC_SAMPLING_RATE_HZ);
+EXPORT_SYMBOL(pmic_audio_open);
+EXPORT_SYMBOL(pmic_audio_close);
+EXPORT_SYMBOL(pmic_audio_set_protocol);
+EXPORT_SYMBOL(pmic_audio_get_protocol);
+EXPORT_SYMBOL(pmic_audio_enable);
+EXPORT_SYMBOL(pmic_audio_disable);
+EXPORT_SYMBOL(pmic_audio_reset);
+EXPORT_SYMBOL(pmic_audio_reset_all);
+EXPORT_SYMBOL(pmic_audio_set_callback);
+EXPORT_SYMBOL(pmic_audio_clear_callback);
+EXPORT_SYMBOL(pmic_audio_get_callback);
+EXPORT_SYMBOL(pmic_audio_antipop_enable);
+EXPORT_SYMBOL(pmic_audio_antipop_disable);
+EXPORT_SYMBOL(pmic_audio_digital_filter_reset);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_clock);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_clock);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_rxtx_timeslot);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_rxtx_timeslot);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_secondary_txslot);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_secondary_txslot);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_config);
+EXPORT_SYMBOL(pmic_audio_vcodec_clear_config);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_config);
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_bypass);
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_bypass);
+EXPORT_SYMBOL(pmic_audio_stdac_set_clock);
+EXPORT_SYMBOL(pmic_audio_stdac_get_clock);
+EXPORT_SYMBOL(pmic_audio_stdac_set_rxtx_timeslot);
+EXPORT_SYMBOL(pmic_audio_stdac_get_rxtx_timeslot);
+EXPORT_SYMBOL(pmic_audio_stdac_set_config);
+EXPORT_SYMBOL(pmic_audio_stdac_clear_config);
+EXPORT_SYMBOL(pmic_audio_stdac_get_config);
+EXPORT_SYMBOL(pmic_audio_input_set_config);
+EXPORT_SYMBOL(pmic_audio_input_clear_config);
+EXPORT_SYMBOL(pmic_audio_input_get_config);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_mic);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_mic);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_mic_on_off);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_mic_on_off);
+EXPORT_SYMBOL(pmic_audio_vcodec_set_record_gain);
+EXPORT_SYMBOL(pmic_audio_vcodec_get_record_gain);
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_micbias);
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_micbias);
+EXPORT_SYMBOL(pmic_audio_vcodec_enable_mixer);
+EXPORT_SYMBOL(pmic_audio_vcodec_disable_mixer);
+EXPORT_SYMBOL(pmic_audio_stdac_enable_mixer);
+EXPORT_SYMBOL(pmic_audio_stdac_disable_mixer);
+EXPORT_SYMBOL(pmic_audio_output_set_port);
+EXPORT_SYMBOL(pmic_audio_output_get_port);
+EXPORT_SYMBOL(pmic_audio_output_clear_port);
+EXPORT_SYMBOL(pmic_audio_output_set_stereo_in_gain);
+EXPORT_SYMBOL(pmic_audio_output_get_stereo_in_gain);
+EXPORT_SYMBOL(pmic_audio_output_set_pgaGain);
+EXPORT_SYMBOL(pmic_audio_output_get_pgaGain);
+EXPORT_SYMBOL(pmic_audio_output_enable_mixer);
+EXPORT_SYMBOL(pmic_audio_output_disable_mixer);
+EXPORT_SYMBOL(pmic_audio_output_set_balance);
+EXPORT_SYMBOL(pmic_audio_output_get_balance);
+EXPORT_SYMBOL(pmic_audio_output_enable_mono_adder);
+EXPORT_SYMBOL(pmic_audio_output_disable_mono_adder);
+EXPORT_SYMBOL(pmic_audio_output_set_mono_adder_gain);
+EXPORT_SYMBOL(pmic_audio_output_get_mono_adder_gain);
+EXPORT_SYMBOL(pmic_audio_output_set_config);
+EXPORT_SYMBOL(pmic_audio_output_clear_config);
+EXPORT_SYMBOL(pmic_audio_output_get_config);
+EXPORT_SYMBOL(pmic_audio_output_enable_phantom_ground);
+EXPORT_SYMBOL(pmic_audio_output_disable_phantom_ground);
+EXPORT_SYMBOL(pmic_audio_set_autodetect);
+#ifdef DEBUG_AUDIO
+EXPORT_SYMBOL(pmic_audio_dump_registers);
+#endif				/* DEBUG_AUDIO */
+/*!
+ * Define the minimum sampling rate (in Hz) that is supported by the
+ * Stereo DAC.
+ */
+const unsigned MIN_STDAC_SAMPLING_RATE_HZ = 8000;
+
+/*!
+ * Define the maximum sampling rate (in Hz) that is supported by the
+ * Stereo DAC.
+ */
+const unsigned MAX_STDAC_SAMPLING_RATE_HZ = 96000;
+
+/*! @def SET_BITS
+ * Set a register field to a given value.
+ */
+#define SET_BITS(reg, field, value)    (((value) << reg.field.offset) & \
+					reg.field.mask)
+/*! @def GET_BITS
+ * Get the current value of a given register field.
+ */
+#define GET_BITS(reg, field, value)    (((value) & reg.field.mask) >>	\
+					reg.field.offset)
+
+/*!
+ * @brief Define the possible states for a device handle.
+ *
+ * This enumeration is used to track the current state of each device handle.
+ */
+typedef enum {
+	HANDLE_FREE,		/*!< Handle is available for use. */
+	HANDLE_IN_USE		/*!< Handle is currently in use.  */
+} HANDLE_STATE;
+
+/*!
+ * @brief Identifies the hardware interrupt source.
+ *
+ * This enumeration identifies which of the possible hardware interrupt
+ * sources actually caused the current interrupt handler to be called.
+ */
+typedef enum {
+	CORE_EVENT_MC2BI,	/*!< Microphone Bias 2 detect. */
+	CORE_EVENT_HSDETI,	/*!< Detect Headset attach  */
+	CORE_EVENT_HSLI,	/*!< Detect Stereo Headset  */
+	CORE_EVENT_ALSPTHI,	/*!< Detect Thermal shutdown of ALSP  */
+	CORE_EVENT_AHSSHORTI	/*!< Detect Short circuit on AHS outputs  */
+} PMIC_CORE_EVENT;
+
+/*!
+ * @brief This structure is used to track the state of a microphone input.
+ */
+typedef struct {
+	PMIC_AUDIO_INPUT_PORT mic;	/*!< Microphone input port.      */
+	PMIC_AUDIO_INPUT_MIC_STATE micOnOff;	/*!< Microphone On/Off state.    */
+	PMIC_AUDIO_MIC_AMP_MODE ampMode;	/*!< Input amplifier mode.       */
+	PMIC_AUDIO_MIC_GAIN gain;	/*!< Input amplifier gain level. */
+} PMIC_MICROPHONE_STATE;
+
+/*!
+ * @brief Tracks whether a headset is currently attached or not.
+ */
+typedef enum {
+	NO_HEADSET,		/*!< No headset currently attached. */
+	HEADSET_ON		/*!< Headset has been attached.     */
+} HEADSET_STATUS;
+
+/*!
+ * @brief mc13783 only enum that indicates the path to output taken
+ * by the voice codec output
+ */
+typedef enum {
+	VCODEC_DIRECT_OUT,	/*!< Vcodec signal out direct */
+	VCODEC_MIXER_OUT	/*!< Output via the mixer     */
+} PMIC_AUDIO_VCODEC_OUTPUT_PATH;
+
+/*!
+ * @brief This structure is used to define a specific hardware register field.
+ *
+ * All hardware register fields are defined using an offset to the LSB
+ * and a mask. The offset is used to right shift a register value before
+ * applying the mask to actually obtain the value of the field.
+ */
+typedef struct {
+	const unsigned char offset;	/*!< Offset of LSB of register field.          */
+	const unsigned int mask;	/*!< Mask value used to isolate register field. */
+} REGFIELD;
+
+/*!
+ * @brief This structure lists all fields of the AUD_CODEC hardware register.
+ */
+typedef struct {
+	REGFIELD CDCSSISEL;	/*!< codec SSI bus select              */
+	REGFIELD CDCCLKSEL;	/*!< Codec clock input select          */
+	REGFIELD CDCSM;		/*!< Codec slave / master select       */
+	REGFIELD CDCBCLINV;	/*!< Codec bitclock inversion          */
+	REGFIELD CDCFSINV;	/*!< Codec framesync inversion         */
+	REGFIELD CDCFS;		/*!< Bus protocol selection - 2 bits   */
+	REGFIELD CDCCLK;	/*!< Codec clock setting - 3 bits      */
+	REGFIELD CDCFS8K16K;	/*!< Codec framesync select            */
+	REGFIELD CDCEN;		/*!< Codec enable                      */
+	REGFIELD CDCCLKEN;	/*!< Codec clocking enable             */
+	REGFIELD CDCTS;		/*!< Codec SSI tristate                */
+	REGFIELD CDCDITH;	/*!< Codec dithering                   */
+	REGFIELD CDCRESET;	/*!< Codec filter reset                */
+	REGFIELD CDCBYP;	/*!< Codec bypass                      */
+	REGFIELD CDCALM;	/*!< Codec analog loopback             */
+	REGFIELD CDCDLM;	/*!< Codec digital loopback            */
+	REGFIELD AUDIHPF;	/*!< Transmit high pass filter enable  */
+	REGFIELD AUDOHPF;	/*!< Receive high pass filter enable   */
+} REGISTER_AUD_CODEC;
+
+/*!
+ * @brief This variable is used to access the AUD_CODEC hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUD_CODEC hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUD_CODEC regAUD_CODEC = {
+	{0, 0x000001},		/* CDCSSISEL    */
+	{1, 0x000002},		/* CDCCLKSEL    */
+	{2, 0x000004},		/* CDCSM        */
+	{3, 0x000008},		/* CDCBCLINV    */
+	{4, 0x000010},		/* CDCFSINV     */
+	{5, 0x000060},		/* CDCFS        */
+	{7, 0x000380},		/* CDCCLK       */
+	{10, 0x000400},		/* CDCFS8K16K   */
+	{11, 0x000800},		/* CDCEN        */
+	{12, 0x001000},		/* CDCCLKEN     */
+	{13, 0x002000},		/* CDCTS        */
+	{14, 0x004000},		/* CDCDITH      */
+	{15, 0x008000},		/* CDCRESET     */
+	{16, 0x010000},		/* CDCBYP       */
+	{17, 0x020000},		/* CDCALM       */
+	{18, 0x040000},		/* CDCDLM       */
+	{19, 0x080000},		/* AUDIHPF      */
+	{20, 0x100000}		/* AUDOHPF      */
+	/* Unused       */
+	/* Unused       */
+	/* Unused       */
+
+};
+
+/*!
+ * @brief This structure lists all fields of the ST_DAC hardware register.
+ */
+ /* VVV */
+typedef struct {
+	REGFIELD STDCSSISEL;	/*!< Stereo DAC SSI bus select                            */
+	REGFIELD STDCCLKSEL;	/*!< Stereo DAC clock input select                        */
+	REGFIELD STDCSM;	/*!< Stereo DAC slave / master select                     */
+	REGFIELD STDCBCLINV;	/*!< Stereo DAC bitclock inversion                        */
+	REGFIELD STDCFSINV;	/*!< Stereo DAC framesync inversion                       */
+	REGFIELD STDCFS;	/*!< Bus protocol selection - 2 bits                      */
+	REGFIELD STDCCLK;	/*!< Stereo DAC clock setting - 3 bits                    */
+	REGFIELD STDCFSDLYB;	/*!< Stereo DAC framesync delay bar                       */
+	REGFIELD STDCEN;	/*!< Stereo DAC enable                                    */
+	REGFIELD STDCCLKEN;	/*!< Stereo DAC clocking enable                           */
+	REGFIELD STDCRESET;	/*!< Stereo DAC filter reset                              */
+	REGFIELD SPDIF;		/*!< Stereo DAC SSI SPDIF mode. Mode no longer available. */
+	REGFIELD SR;		/*!< Stereo DAC sample rate - 4 bits                      */
+} REGISTER_ST_DAC;
+
+/*!
+ * @brief This variable is used to access the ST_DAC hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * ST_DAC hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_ST_DAC regST_DAC = {
+	{0, 0x000001},		/* STDCSSISEL        */
+	{1, 0x000002},		/* STDCCLKSEL        */
+	{2, 0x000004},		/* STDCSM            */
+	{3, 0x000008},		/* STDCBCLINV        */
+	{4, 0x000010},		/* STDCFSINV         */
+	{5, 0x000060},		/* STDCFS            */
+	{7, 0x000380},		/* STDCCLK           */
+	{10, 0x000400},		/* STDCFSDLYB        */
+	{11, 0x000800},		/* STDCEN            */
+	{12, 0x001000},		/* STDCCLKEN         */
+	{15, 0x008000},		/* STDCRESET         */
+	{16, 0x010000},		/* SPDIF             */
+	{17, 0x1E0000}		/* SR                */
+};
+
+/*!
+ * @brief This structure lists all of the fields in the SSI_NETWORK hardware register.
+ */
+typedef struct {
+	REGFIELD CDCTXRXSLOT;	/*!< Codec timeslot assignment  - 2 bits                                  */
+	REGFIELD CDCTXSECSLOT;	/*!< Codec secondary transmit timeslot - 2 bits                           */
+	REGFIELD CDCRXSECSLOT;	/*!< Codec secondary receive timeslot - 2 bits                            */
+	REGFIELD CDCRXSECGAIN;	/*!< Codec secondary receive channel gain setting - 2 bits                */
+	REGFIELD CDCSUMGAIN;	/*!< Codec summed receive signal gain setting                             */
+	REGFIELD CDCFSDLY;	/*!< Codec framesync delay                                                */
+	REGFIELD STDCSLOTS;	/*!< Stereo DAC number of timeslots select  - 2 bits                      */
+	REGFIELD STDCRXSLOT;	/*!< Stereo DAC timeslot assignment - 2 bits                              */
+	REGFIELD STDCRXSECSLOT;	/*!< Stereo DAC secondary receive timeslot  - 2 bits                      */
+	REGFIELD STDCRXSECGAIN;	/*!< Stereo DAC secondary receive channel gain setting   - 2 bits         */
+	REGFIELD STDCSUMGAIN;	/*!< Stereo DAC summed receive signal gain setting                        */
+} REGISTER_SSI_NETWORK;
+
+/*!
+ * @brief This variable is used to access the SSI_NETWORK hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * SSI_NETWORK hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_SSI_NETWORK regSSI_NETWORK = {
+	{2, 0x00000c},		/* CDCTXRXSLOT          */
+	{4, 0x000030},		/* CDCTXSECSLOT         */
+	{6, 0x0000c0},		/* CDCRXSECSLOT         */
+	{8, 0x000300},		/* CDCRXSECGAIN         */
+	{10, 0x000400},		/* CDCSUMGAIN           */
+	{11, 0x000800},		/* CDCFSDLY             */
+	{12, 0x003000},		/* STDCSLOTS            */
+	{14, 0x00c000},		/* STDCRXSLOT           */
+	{16, 0x030000},		/* STDCRXSECSLOT        */
+	{18, 0x0c0000},		/* STDCRXSECGAIN        */
+	{20, 0x100000}		/* STDCSUMGAIN          */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_TX hardware register.
+ *
+ *
+ */
+typedef struct {
+	REGFIELD MC1BEN;	/*!< Microphone bias 1 enable                                */
+	REGFIELD MC2BEN;	/*!< Microphone bias 2 enable                                */
+	REGFIELD MC2BDETDBNC;	/*!< Microphone bias detect debounce setting                 */
+	REGFIELD MC2BDETEN;	/*!< Microphone bias 2 detect enable                         */
+	REGFIELD AMC1REN;	/*!< Amplifier Amc1R enable                                  */
+	REGFIELD AMC1RITOV;	/*!< Amplifier Amc1R current to voltage mode enable          */
+	REGFIELD AMC1LEN;	/*!< Amplifier Amc1L enable                                  */
+	REGFIELD AMC1LITOV;	/*!< Amplifier Amc1L current to voltage mode enable          */
+	REGFIELD AMC2EN;	/*!< Amplifier Amc2 enable                                   */
+	REGFIELD AMC2ITOV;	/*!< Amplifier Amc2 current to voltage mode enable           */
+	REGFIELD ATXINEN;	/*!< Amplifier Atxin enable                                  */
+	REGFIELD ATXOUTEN;	/*!< Reserved for output TXOUT enable, currently not used    */
+	REGFIELD RXINREC;	/*!< RXINR/RXINL to voice CODEC ADC routing enable           */
+	REGFIELD PGATXR;	/*!< Transmit gain setting right - 5 bits                    */
+	REGFIELD PGATXL;	/*!< Transmit gain setting left  - 5 bits                    */
+} REGISTER_AUDIO_TX;
+
+/*!
+ * @brief This variable is used to access the AUDIO_TX hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_TX hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_TX regAUDIO_TX = {
+	{0, 0x000001},		/* MC1BEN              */
+	{1, 0x000002},		/* MC2BEN              */
+	{2, 0x000004},		/* MC2BDETDBNC         */
+	{3, 0x000008},		/* MC2BDETEN           */
+	{5, 0x000020},		/* AMC1REN             */
+	{6, 0x000040},		/* AMC1RITOV           */
+	{7, 0x000080},		/* AMC1LEN             */
+	{8, 0x000100},		/* AMC1LITOV           */
+	{9, 0x000200},		/* AMC2EN              */
+	{10, 0x000400},		/* AMC2ITOV            */
+	{11, 0x000800},		/* ATXINEN             */
+	{12, 0x001000},		/* ATXOUTEN            */
+	{13, 0x002000},		/* RXINREC             */
+	{14, 0x07c000},		/* PGATXR              */
+	{19, 0xf80000}		/* PGATXL              */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_RX_0 hardware register.
+ */
+typedef struct {
+	REGFIELD VAUDIOON;	/*!<    Forces VAUDIO in active on mode               */
+	REGFIELD BIASEN;	/*!<    Audio bias enable                             */
+	REGFIELD BIASSPEED;	/*!<    Turn on ramp speed of the audio bias          */
+	REGFIELD ASPEN;		/*!<    Amplifier Asp enable                          */
+	REGFIELD ASPSEL;	/*!<    Asp input selector                            */
+	REGFIELD ALSPEN;	/*!<    Amplifier Alsp enable                         */
+	REGFIELD ALSPREF;	/*!<    Bias Alsp at common audio reference           */
+	REGFIELD ALSPSEL;	/*!<    Alsp input selector                           */
+	REGFIELD LSPLEN;	/*!<    Output LSPL enable                            */
+	REGFIELD AHSREN;	/*!<    Amplifier AhsR enable                         */
+	REGFIELD AHSLEN;	/*!<    Amplifier AhsL enable                         */
+	REGFIELD AHSSEL;	/*!<    Ahsr and Ahsl input selector                  */
+	REGFIELD HSPGDIS;	/*!<    Phantom ground disable                        */
+	REGFIELD HSDETEN;	/*!<    Headset detect enable                         */
+	REGFIELD HSDETAUTOB;	/*!<    Amplifier state determined by headset detect  */
+	REGFIELD ARXOUTREN;	/*!<    Output RXOUTR enable                          */
+	REGFIELD ARXOUTLEN;	/*!<    Output RXOUTL enable                          */
+	REGFIELD ARXOUTSEL;	/*!<    Arxout input selector                         */
+	REGFIELD CDCOUTEN;	/*!<    Output CDCOUT enable                          */
+	REGFIELD HSLDETEN;	/*!<    Headset left channel detect enable            */
+	REGFIELD ADDCDC;	/*!<    Adder channel codec selection                 */
+	REGFIELD ADDSTDC;	/*!<    Adder channel stereo DAC selection            */
+	REGFIELD ADDRXIN;	/*!<    Adder channel line in selection               */
+} REGISTER_AUDIO_RX_0;
+
+/*!
+ * @brief This variable is used to access the AUDIO_RX_0 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_RX_0 hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_RX_0 regAUDIO_RX_0 = {
+	{0, 0x000001},		/* VAUDIOON    */
+	{1, 0x000002},		/* BIASEN      */
+	{2, 0x000004},		/* BIASSPEED   */
+	{3, 0x000008},		/* ASPEN       */
+	{4, 0x000010},		/* ASPSEL      */
+	{5, 0x000020},		/* ALSPEN      */
+	{6, 0x000040},		/* ALSPREF     */
+	{7, 0x000080},		/* ALSPSEL     */
+	{8, 0x000100},		/* LSPLEN      */
+	{9, 0x000200},		/* AHSREN      */
+	{10, 0x000400},		/* AHSLEN      */
+	{11, 0x000800},		/* AHSSEL      */
+	{12, 0x001000},		/* HSPGDIS     */
+	{13, 0x002000},		/* HSDETEN     */
+	{14, 0x004000},		/* HSDETAUTOB  */
+	{15, 0x008000},		/* ARXOUTREN   */
+	{16, 0x010000},		/* ARXOUTLEN   */
+	{17, 0x020000},		/* ARXOUTSEL   */
+	{18, 0x040000},		/* CDCOUTEN    */
+	{19, 0x080000},		/* HSLDETEN    */
+	{21, 0x200000},		/* ADDCDC      */
+	{22, 0x400000},		/* ADDSTDC     */
+	{23, 0x800000}		/* ADDRXIN     */
+};
+
+/*!
+ * @brief This structure lists all fields of the AUDIO_RX_1 hardware register.
+ */
+typedef struct {
+	REGFIELD PGARXEN;	/*!<    Codec receive PGA enable                 */
+	REGFIELD PGARX;		/*!<    Codec receive gain setting - 4 bits      */
+	REGFIELD PGASTEN;	/*!<    Stereo DAC PGA enable                    */
+	REGFIELD PGAST;		/*!<    Stereo DAC gain setting  - 4 bits        */
+	REGFIELD ARXINEN;	/*!<    Amplifier Arx enable                     */
+	REGFIELD ARXIN;		/*!<    Amplifier Arx additional gain setting    */
+	REGFIELD PGARXIN;	/*!<    PGArxin gain setting  - 4 bits           */
+	REGFIELD MONO;		/*!<    Mono adder setting   - 2 bits            */
+	REGFIELD BAL;		/*!<    Balance control      - 3 bits            */
+	REGFIELD BALLR;		/*!<    Left / right balance                     */
+} REGISTER_AUDIO_RX_1;
+
+/*!
+ * @brief This variable is used to access the AUDIO_RX_1 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * AUDIO_RX_1 hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const REGISTER_AUDIO_RX_1 regAUDIO_RX_1 = {
+	{0, 0x000001},		/* PGARXEN    */
+	{1, 0x00001e},		/* PGARX      */
+	{5, 0x000020},		/* PGASTEN   */
+	{6, 0x0003c0},		/* PGAST       */
+	{10, 0x000400},		/* ARXINEN      */
+	{11, 0x000800},		/* ARXIN      */
+	{12, 0x00f000},		/* PGARXIN     */
+	{16, 0x030000},		/* MONO     */
+	{18, 0x1c0000},		/* BAL      */
+	{21, 0x200000}		/* BALLR      */
+};
+
+/*! Define a mask to access the entire hardware register. */
+static const unsigned int REG_FULLMASK = 0xffffff;
+
+/*! Reset value for the AUD_CODEC register. */
+static const unsigned int RESET_AUD_CODEC = 0x180027;
+
+/*! Reset value for the ST_DAC register.
+ *
+ *  Note that we avoid resetting any of the arbitration bits.
+ */
+static const unsigned int RESET_ST_DAC = 0x0E0004;
+
+/*! Reset value for the SSI_NETWORK register. */
+static const unsigned int RESET_SSI_NETWORK = 0x013060;
+
+/*! Reset value for the AUDIO_TX register.
+ *
+ *  Note that we avoid resetting any of the arbitration bits.
+ */
+static const unsigned int RESET_AUDIO_TX = 0x420000;
+
+/*! Reset value for the AUDIO_RX_0 register. */
+static const unsigned int RESET_AUDIO_RX_0 = 0x001000;
+
+/*! Reset value for the AUDIO_RX_1 register. */
+static const unsigned int RESET_AUDIO_RX_1 = 0x00D35A;
+
+/*! Reset mask for the SSI network Vcodec part. first 12 bits
+ * 0 - 11 */
+static const unsigned int REG_SSI_VCODEC_MASK = 0x000fff;
+
+/*! Reset mask for the SSI network STDAC part. last 12 bits
+ * 12 - 24 */
+static const unsigned int REG_SSI_STDAC_MASK = 0xfff000;
+
+/*! Constant NULL value for initializing/reseting the audio handles. */
+static const PMIC_AUDIO_HANDLE AUDIO_HANDLE_NULL = (PMIC_AUDIO_HANDLE) NULL;
+
+/*!
+ * @brief This structure maintains the current state of the Stereo DAC.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;	/*!< Handle used to access
+					   the Stereo DAC.         */
+	HANDLE_STATE handleState;	/*!< Current handle state.   */
+	PMIC_AUDIO_DATA_BUS busID;	/*!< Data bus used to access
+					   the Stereo DAC.         */
+	bool protocol_set;
+	PMIC_AUDIO_BUS_PROTOCOL protocol;	/*!< Data bus protocol.      */
+	PMIC_AUDIO_BUS_MODE masterSlave;	/*!< Master/Slave mode
+						   select.                 */
+	PMIC_AUDIO_NUMSLOTS numSlots;	/*!< Number of timeslots
+					   used.                   */
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification
+					   callback function
+					   pointer.                */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification mask. */
+	PMIC_AUDIO_CLOCK_IN_SOURCE clockIn;	/*!< Stereo DAC clock input
+						   source select.          */
+	PMIC_AUDIO_STDAC_SAMPLING_RATE samplingRate;	/*!< Stereo DAC sampling rate
+							   select.                 */
+	PMIC_AUDIO_STDAC_CLOCK_IN_FREQ clockFreq;	/*!< Stereo DAC clock input
+							   frequency.              */
+	PMIC_AUDIO_CLOCK_INVERT invert;	/*!< Stereo DAC clock signal
+					   invert select.          */
+	PMIC_AUDIO_STDAC_TIMESLOTS timeslot;	/*!< Stereo DAC data
+						   timeslots select.       */
+	PMIC_AUDIO_STDAC_CONFIG config;	/*!< Stereo DAC configuration
+					   options.                */
+} PMIC_AUDIO_STDAC_STATE;
+
+/*!
+ * @brief This variable maintains the current state of the Stereo DAC.
+ *
+ * This variable tracks the current state of the Stereo DAC audio hardware
+ * along with any information that is required by the device driver to
+ * manage the hardware (e.g., callback functions and event notification
+ * masks).
+ *
+ * The initial values represent the reset/power on state of the Stereo DAC.
+ */
+static PMIC_AUDIO_STDAC_STATE stDAC = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle       */
+	HANDLE_FREE,		/* handleState  */
+	AUDIO_DATA_BUS_1,	/* busID        */
+	false,
+	NORMAL_MSB_JUSTIFIED_MODE,	/* protocol     */
+	BUS_MASTER_MODE,	/* masterSlave  */
+	USE_2_TIMESLOTS,	/* numSlots     */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback     */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask    */
+	CLOCK_IN_CLIA,		/* clockIn      */
+	STDAC_RATE_44_1_KHZ,	/* samplingRate */
+	STDAC_CLI_13MHZ,	/* clockFreq    */
+	NO_INVERT,		/* invert       */
+	USE_TS0_TS1,		/* timeslot     */
+	(PMIC_AUDIO_STDAC_CONFIG) 0	/* config       */
+};
+
+/*!
+ * @brief This structure maintains the current state of the Voice CODEC.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;	/*!< Handle used to access
+					   the Voice CODEC.       */
+	HANDLE_STATE handleState;	/*!< Current handle state.  */
+	PMIC_AUDIO_DATA_BUS busID;	/*!< Data bus used to access
+					   the Voice CODEC.       */
+	bool protocol_set;
+	PMIC_AUDIO_BUS_PROTOCOL protocol;	/*!< Data bus protocol.     */
+	PMIC_AUDIO_BUS_MODE masterSlave;	/*!< Master/Slave mode
+						   select.                */
+	PMIC_AUDIO_NUMSLOTS numSlots;	/*!< Number of timeslots
+					   used.                  */
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification
+					   callback function
+					   pointer.               */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification
+					   mask.                  */
+	PMIC_AUDIO_CLOCK_IN_SOURCE clockIn;	/*!< Voice CODEC clock input
+						   source select.         */
+	PMIC_AUDIO_VCODEC_SAMPLING_RATE samplingRate;	/*!< Voice CODEC sampling
+							   rate select.           */
+	PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ clockFreq;	/*!< Voice CODEC clock input
+							   frequency.             */
+	PMIC_AUDIO_CLOCK_INVERT invert;	/*!< Voice CODEC clock
+					   signal invert select.  */
+	PMIC_AUDIO_VCODEC_TIMESLOT timeslot;	/*!< Voice CODEC data
+						   timeslot select.       */
+	PMIC_AUDIO_VCODEC_TIMESLOT secondaryTXtimeslot;
+
+	PMIC_AUDIO_VCODEC_CONFIG config;	/*!< Voice CODEC
+						   configuration
+						   options.            */
+	PMIC_MICROPHONE_STATE leftChannelMic;	/*!< Left channel
+						   microphone
+						   configuration.      */
+	PMIC_MICROPHONE_STATE rightChannelMic;	/*!< Right channel
+						   microphone
+						   configuration.      */
+} PMIC_AUDIO_VCODEC_STATE;
+
+/*!
+ * @brief This variable maintains the current state of the Voice CODEC.
+ *
+ * This variable tracks the current state of the Voice CODEC audio hardware
+ * along with any information that is required by the device driver to
+ * manage the hardware (e.g., callback functions and event notification
+ * masks).
+ *
+ * The initial values represent the reset/power on state of the Voice CODEC.
+ */
+static PMIC_AUDIO_VCODEC_STATE vCodec = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle          */
+	HANDLE_FREE,		/* handleState     */
+	AUDIO_DATA_BUS_2,	/* busID           */
+	false,
+	NETWORK_MODE,		/* protocol        */
+	BUS_SLAVE_MODE,		/* masterSlave     */
+	USE_4_TIMESLOTS,	/* numSlots        */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback        */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask       */
+	CLOCK_IN_CLIB,		/* clockIn         */
+	VCODEC_RATE_8_KHZ,	/* samplingRate    */
+	VCODEC_CLI_13MHZ,	/* clockFreq       */
+	NO_INVERT,		/* invert          */
+	USE_TS0,		/* timeslot pri    */
+	USE_TS2,		/* timeslot sec TX */
+	INPUT_HIGHPASS_FILTER | OUTPUT_HIGHPASS_FILTER,	/* config          */
+	/* leftChannelMic  */
+	{NO_MIC,		/*    mic          */
+	 MICROPHONE_OFF,	/*    micOnOff     */
+	 AMP_OFF,		/*    ampMode      */
+	 MIC_GAIN_0DB		/*    gain         */
+	 },
+	/* rightChannelMic */
+	{NO_MIC,		/*    mic          */
+	 MICROPHONE_OFF,	/*    micOnOff     */
+	 AMP_OFF,		/*    ampMode      */
+	 MIC_GAIN_0DB		/*    gain         */
+	 }
+};
+
+/*!
+ * @brief This maintains the current state of the External Stereo Input.
+ */
+typedef struct {
+	PMIC_AUDIO_HANDLE handle;	/*!< Handle used to access the
+					   External Stereo Inputs.     */
+	HANDLE_STATE handleState;	/*!< Current handle state.       */
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification callback
+					   function pointer.           */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification mask.    */
+	PMIC_AUDIO_STEREO_IN_GAIN inputGain;	/*!< External Stereo Input
+						   amplifier gain level.       */
+} PMIC_AUDIO_EXT_STEREO_IN_STATE;
+
+/*!
+ * @brief This maintains the current state of the External Stereo Input.
+ *
+ * This variable tracks the current state of the External Stereo Input audio
+ * hardware along with any information that is required by the device driver
+ * to manage the hardware (e.g., callback functions and event notification
+ * masks).
+ *
+ * The initial values represent the reset/power on state of the External
+ * Stereo Input.
+ */
+static PMIC_AUDIO_EXT_STEREO_IN_STATE extStereoIn = {
+	(PMIC_AUDIO_HANDLE) NULL,	/* handle      */
+	HANDLE_FREE,		/* handleState */
+	(PMIC_AUDIO_CALLBACK) NULL,	/* callback    */
+	(PMIC_AUDIO_EVENTS) NULL,	/* eventMask   */
+	STEREO_IN_GAIN_0DB	/* inputGain   */
+};
+
+/*!
+ * @brief This maintains the current state of the callback & Eventmask.
+ */
+typedef struct {
+	PMIC_AUDIO_CALLBACK callback;	/*!< Event notification callback
+					   function pointer.           */
+	PMIC_AUDIO_EVENTS eventMask;	/*!< Event notification mask.    */
+} PMIC_AUDIO_EVENT_STATE;
+
+static PMIC_AUDIO_EVENT_STATE event_state = {
+	(PMIC_AUDIO_CALLBACK) NULL,	/*Callback */
+	(PMIC_AUDIO_EVENTS) NULL,	/* EventMask */
+
+};
+
+/*!
+ * @brief This maintains the current state of the Audio Output Section.
+ */
+typedef struct {
+	PMIC_AUDIO_OUTPUT_PORT outputPort;	/*!< Current audio
+						   output port.     */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN vCodecoutputPGAGain;	/*!< Output PGA gain
+							   level codec      */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN stDacoutputPGAGain;	/*!< Output PGA gain
+							   level stDAC      */
+	PMIC_AUDIO_OUTPUT_PGA_GAIN extStereooutputPGAGain;	/*!< Output PGA gain
+								   level stereo ext */
+	PMIC_AUDIO_OUTPUT_BALANCE_GAIN balanceLeftGain;	/*!< Left channel
+							   balance gain
+							   level.           */
+	PMIC_AUDIO_OUTPUT_BALANCE_GAIN balanceRightGain;	/*!< Right channel
+								   balance gain
+								   level.           */
+	PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN monoAdderGain;	/*!< Mono adder gain
+								   level.           */
+	PMIC_AUDIO_OUTPUT_CONFIG config;	/*!< Audio output
+						   section config
+						   options.         */
+	PMIC_AUDIO_VCODEC_OUTPUT_PATH vCodecOut;
+
+} PMIC_AUDIO_AUDIO_OUTPUT_STATE;
+
+/*!
+ * @brief This variable maintains the current state of the Audio Output Section.
+ *
+ * This variable tracks the current state of the Audio Output Section.
+ *
+ * The initial values represent the reset/power on state of the Audio
+ * Output Section.
+ */
+static PMIC_AUDIO_AUDIO_OUTPUT_STATE audioOutput = {
+	(PMIC_AUDIO_OUTPUT_PORT) NULL,	/* outputPort       */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	OUTPGA_GAIN_0DB,	/* outputPGAGain    */
+	BAL_GAIN_0DB,		/* balanceLeftGain  */
+	BAL_GAIN_0DB,		/* balanceRightGain */
+	MONOADD_GAIN_0DB,	/* monoAdderGain    */
+	(PMIC_AUDIO_OUTPUT_CONFIG) 0,	/* config           */
+	VCODEC_DIRECT_OUT
+};
+
+/*! The current headset status. */
+static HEADSET_STATUS headsetState = NO_HEADSET;
+
+/* Removed PTT variable */
+/*! Define a 1 ms wait interval that is needed to ensure that certain
+ *  hardware operations are successfully completed.
+ */
+static const unsigned long delay_1ms = (HZ / 1000);
+
+/*!
+ * @brief This spinlock is used to provide mutual exclusion.
+ *
+ * Create a spinlock that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the audio data structures are consistent at all times
+ * when possibly accessed by multiple threads of execution (for example,
+ * while simultaneously handling a user request and an interrupt event).
+ *
+ * We need to use a spinlock whenever we do need to provide mutual
+ * exclusion while possibly executing in a hardware interrupt context.
+ * Spinlocks should be held for the minimum time that is necessary
+ * because hardware interrupts are disabled while a spinlock is held.
+ *
+ */
+
+static DEFINE_SPINLOCK(lock);
+/*!
+ * @brief This mutex is used to provide mutual exclusion.
+ *
+ * Create a mutex that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the audio data structures are consistent at all times
+ * when possibly accessed by multiple threads of execution.
+ *
+ * Note that we use a mutex instead of the spinlock whenever disabling
+ * interrupts while in the critical section is not required. This helps
+ * to minimize kernel interrupt handling latency.
+ */
+static DECLARE_MUTEX(mutex);
+
+/*!
+ * @brief Global variable to track currently active interrupt events.
+ *
+ * This global variable is used to keep track of all of the currently
+ * active interrupt events for the audio driver. Note that access to this
+ * variable may occur while within an interrupt context and, therefore,
+ * must be guarded by using a spinlock.
+ */
+/* static PMIC_CORE_EVENT eventID = 0; */
+
+/* Prototypes for all static audio driver functions. */
+/*
+static PMIC_STATUS pmic_audio_mic_boost_enable(void);
+static PMIC_STATUS pmic_audio_mic_boost_disable(void);*/
+static PMIC_STATUS pmic_audio_close_handle(const PMIC_AUDIO_HANDLE handle);
+static PMIC_STATUS pmic_audio_reset_device(const PMIC_AUDIO_HANDLE handle);
+
+static PMIC_STATUS pmic_audio_deregister(void *callback,
+					 PMIC_AUDIO_EVENTS * const eventMask);
+
+/*************************************************************************
+ * Audio device access APIs.
+ *************************************************************************
+ */
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Audio
+ * hardware.
+ */
+/*@{*/
+
+PMIC_STATUS pmic_audio_set_autodetect(int val)
+{
+	PMIC_STATUS status;
+	unsigned int reg_mask = 0, reg_write = 0;
+	reg_mask = SET_BITS(regAUDIO_RX_0, VAUDIOON, 1);
+	status = pmic_write_reg(REG_AUDIO_RX_0, reg_mask, reg_mask);
+	if (status != PMIC_SUCCESS)
+		return status;
+	reg_mask = 0;
+	if (val == 1) {
+		reg_write = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+		    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+	} else {
+		reg_write = 0;
+	}
+	reg_mask =
+	    SET_BITS(regAUDIO_RX_0, HSDETEN, 1) | SET_BITS(regAUDIO_RX_0,
+							   HSDETAUTOB, 1);
+	status = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+
+	return status;
+}
+
+/*!
+ * @brief Request exclusive access to the PMIC Audio hardware.
+ *
+ * Attempt to open and gain exclusive access to a key PMIC audio hardware
+ * component (e.g., the Stereo DAC or the Voice CODEC). Depending upon the
+ * type of audio operation that is desired and the nature of the audio data
+ * stream, the Stereo DAC and/or the Voice CODEC will be a required hardware
+ * component and needs to be acquired by calling this function.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls to complete
+ * the configuration of either the Stereo DAC or the Voice CODEC and along
+ * with any other associated audio hardware components that will be needed.
+ *
+ * The same handle must also be used in the close call when use of the PMIC
+ * audio hardware is no longer required.
+ *
+ * The open request will fail if the requested audio hardware component has
+ * already been acquired by a previous open call but not yet closed.
+ *
+ * @param  handle          Device handle to be used for subsequent PMIC
+ *                              audio API calls.
+ * @param  device          The required PMIC audio hardware component.
+ *
+ * @retval      PMIC_SUCCESS         If the open request was successful
+ * @retval      PMIC_PARAMETER_ERROR If the handle argument is NULL.
+ * @retval      PMIC_ERROR           If the audio hardware component is
+ *                                   unavailable.
+ */
+PMIC_STATUS pmic_audio_open(PMIC_AUDIO_HANDLE * const handle,
+			    const PMIC_AUDIO_SOURCE device)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	if (handle == (PMIC_AUDIO_HANDLE *) NULL) {
+		/* Do not dereference a NULL pointer. */
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	/* We only need to acquire a mutex here because the interrupt handler
+	 * never modifies the device handle or device handle state. Therefore,
+	 * we don't need to worry about conflicts with the interrupt handler
+	 * or the need to execute in an interrupt context.
+	 *
+	 * But we do need a critical section here to avoid problems in case
+	 * multiple calls to pmic_audio_open() are made since we can only allow
+	 * one of them to succeed.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Check the current device handle state and acquire the handle if
+	 * it is available.
+	 */
+
+	if ((device == STEREO_DAC) && (stDAC.handleState == HANDLE_FREE)) {
+		stDAC.handle = (PMIC_AUDIO_HANDLE) (&stDAC);
+		stDAC.handleState = HANDLE_IN_USE;
+		*handle = stDAC.handle;
+		rc = PMIC_SUCCESS;
+	} else if ((device == VOICE_CODEC)
+		   && (vCodec.handleState == HANDLE_FREE)) {
+		vCodec.handle = (PMIC_AUDIO_HANDLE) (&vCodec);
+		vCodec.handleState = HANDLE_IN_USE;
+		*handle = vCodec.handle;
+		rc = PMIC_SUCCESS;
+	} else if ((device == EXTERNAL_STEREO_IN) &&
+		   (extStereoIn.handleState == HANDLE_FREE)) {
+		extStereoIn.handle = (PMIC_AUDIO_HANDLE) (&extStereoIn);
+		extStereoIn.handleState = HANDLE_IN_USE;
+		*handle = extStereoIn.handle;
+		rc = PMIC_SUCCESS;
+	} else {
+		*handle = AUDIO_HANDLE_NULL;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Terminate further access to the PMIC audio hardware.
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * Note that we will shutdown/reset the Voice CODEC or Stereo DAC as well as
+ * any associated audio input/output components that are no longer required.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_close(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* We need a critical section here to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* We can now call pmic_audio_close_handle() to actually do the work. */
+	rc = pmic_audio_close_handle(handle);
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Configure the data bus protocol to be used.
+ *
+ * Provide the parameters needed to properly configure the audio data bus
+ * protocol so that data can be read/written to either the Stereo DAC or
+ * the Voice CODEC.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   busID           Select data bus to be used.
+ * @param   protocol        Select the data bus protocol.
+ * @param   masterSlave     Select the data bus timing mode.
+ * @param   numSlots        Define the number of timeslots (only if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the protocol parameters
+ *                                   are invalid.
+ */
+PMIC_STATUS pmic_audio_set_protocol(const PMIC_AUDIO_HANDLE handle,
+				    const PMIC_AUDIO_DATA_BUS busID,
+				    const PMIC_AUDIO_BUS_PROTOCOL protocol,
+				    const PMIC_AUDIO_BUS_MODE masterSlave,
+				    const PMIC_AUDIO_NUMSLOTS numSlots)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int ST_DAC_MASK = SET_BITS(regST_DAC, STDCSSISEL, 1) |
+	    SET_BITS(regST_DAC, STDCFS, 3) | SET_BITS(regST_DAC, STDCSM, 1);
+
+	unsigned int reg_mask;
+	/*unsigned int VCODEC_MASK = SET_BITS(regAUD_CODEC, CDCSSISEL, 1) |
+	   SET_BITS(regAUD_CODEC, CDCFS, 3) | SET_BITS(regAUD_CODEC, CDCSM, 1); */
+
+	unsigned int SSI_NW_MASK = SET_BITS(regSSI_NETWORK, STDCSLOTS, 1);
+	unsigned int reg_value = 0;
+	unsigned int ssi_nw_value = 0;
+
+	/* Enter a critical section so that we can ensure only one
+	 * state change request is completed at a time.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (handle == (PMIC_AUDIO_HANDLE) NULL) {
+		rc = PMIC_PARAMETER_ERROR;
+	} else {
+		if ((handle == vCodec.handle) &&
+		    (vCodec.handleState == HANDLE_IN_USE)) {
+			if ((stDAC.handleState == HANDLE_IN_USE) &&
+			    (stDAC.busID == busID) && (stDAC.protocol_set)) {
+				pr_debug("The requested bus already in USE\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if ((masterSlave == BUS_MASTER_MODE)
+				   && (numSlots != USE_4_TIMESLOTS)) {
+				pr_debug
+				    ("mc13783 supports only 4 slots in Master mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else if ((masterSlave == BUS_SLAVE_MODE)
+				   && (numSlots != USE_4_TIMESLOTS)) {
+				pr_debug
+				    ("Driver currently supports only 4 slots in Slave mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else if (!((protocol == NETWORK_MODE) ||
+				     (protocol == I2S_MODE))) {
+				pr_debug
+				    ("mc13783 Voice codec works only in Network and I2S modes\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else {
+				pr_debug
+				    ("Proceeding to configure Voice Codec\n");
+				if (busID == AUDIO_DATA_BUS_1) {
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCSSISEL,
+						     0);
+				} else {
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCSSISEL,
+						     1);
+				}
+				reg_mask = SET_BITS(regAUD_CODEC, CDCSSISEL, 1);
+				if (PMIC_SUCCESS !=
+				    pmic_write_reg(REG_AUDIO_CODEC,
+						   reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				if (masterSlave == BUS_MASTER_MODE) {
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCSM, 0);
+				} else {
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCSM, 1);
+				}
+				reg_mask = SET_BITS(regAUD_CODEC, CDCSM, 1);
+				if (PMIC_SUCCESS !=
+				    pmic_write_reg(REG_AUDIO_CODEC,
+						   reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				if (protocol == NETWORK_MODE) {
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCFS, 1);
+				} else {	/* protocol == I2S, other options have been already eliminated */
+					reg_value =
+					    SET_BITS(regAUD_CODEC, CDCFS, 2);
+				}
+				reg_mask = SET_BITS(regAUD_CODEC, CDCFS, 3);
+				if (PMIC_SUCCESS !=
+				    pmic_write_reg(REG_AUDIO_CODEC,
+						   reg_value, reg_mask))
+					return PMIC_ERROR;
+
+				ssi_nw_value =
+				    SET_BITS(regSSI_NETWORK, CDCFSDLY, 1);
+				/*if (pmic_write_reg
+				   (REG_AUDIO_CODEC, reg_value,
+				   VCODEC_MASK) != PMIC_SUCCESS) {
+				   rc = PMIC_ERROR;
+				   } else { */
+				vCodec.busID = busID;
+				vCodec.protocol = protocol;
+				vCodec.masterSlave = masterSlave;
+				vCodec.numSlots = numSlots;
+				vCodec.protocol_set = true;
+				/* pmic_write_reg(REG_AUDIO_SSI_NETWORK, ssi_nw_value, ssi_nw_value); */
+
+				pr_debug
+				    ("mc13783 Voice codec successfully configured\n");
+				rc = PMIC_SUCCESS;
+				/* } */
+
+			}
+
+		} else if ((handle == stDAC.handle) &&
+			   (stDAC.handleState == HANDLE_IN_USE)) {
+			if ((vCodec.handleState == HANDLE_IN_USE) &&
+			    (vCodec.busID == busID) && (vCodec.protocol_set)) {
+				pr_debug("The requested bus already in USE\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if (((protocol == NORMAL_MSB_JUSTIFIED_MODE) ||
+				    (protocol == I2S_MODE))
+				   && (numSlots != USE_2_TIMESLOTS)) {
+				pr_debug
+				    ("STDAC uses only 2 slots in Normal and I2S modes\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if ((protocol == NETWORK_MODE) &&
+				   !((numSlots == USE_2_TIMESLOTS) ||
+				     (numSlots == USE_4_TIMESLOTS) ||
+				     (numSlots == USE_8_TIMESLOTS))) {
+				pr_debug
+				    ("STDAC uses only 2,4 or 8 slots in Network mode\n");
+				rc = PMIC_PARAMETER_ERROR;
+			} else if (protocol == SPD_IF_MODE) {
+				pr_debug
+				    ("STDAC driver currently does not support SPD IF mode\n");
+				rc = PMIC_NOT_SUPPORTED;
+			} else {
+				pr_debug
+				    ("Proceeding to configure Stereo DAC\n");
+				if (busID == AUDIO_DATA_BUS_1) {
+					reg_value =
+					    SET_BITS(regST_DAC, STDCSSISEL, 0);
+				} else {
+					reg_value =
+					    SET_BITS(regST_DAC, STDCSSISEL, 1);
+				}
+				if (masterSlave == BUS_MASTER_MODE) {
+					reg_value |=
+					    SET_BITS(regST_DAC, STDCSM, 0);
+				} else {
+					reg_value |=
+					    SET_BITS(regST_DAC, STDCSM, 1);
+				}
+				if (protocol == NETWORK_MODE) {
+					reg_value |=
+					    SET_BITS(regST_DAC, STDCFS, 1);
+				} else if (protocol ==
+					   NORMAL_MSB_JUSTIFIED_MODE) {
+					reg_value |=
+					    SET_BITS(regST_DAC, STDCFS, 0);
+				} else {	/* I2S mode as the other option has already been eliminated */
+					reg_value |=
+					    SET_BITS(regST_DAC, STDCFS, 2);
+				}
+
+				if (pmic_write_reg
+				    (REG_AUDIO_STEREO_DAC,
+				     reg_value, ST_DAC_MASK) != PMIC_SUCCESS) {
+					rc = PMIC_ERROR;
+				} else {
+					if (numSlots == USE_2_TIMESLOTS) {
+						reg_value =
+						    SET_BITS(regSSI_NETWORK,
+							     STDCSLOTS, 3);
+					} else if (numSlots == USE_4_TIMESLOTS) {
+						reg_value =
+						    SET_BITS(regSSI_NETWORK,
+							     STDCSLOTS, 2);
+					} else {	/* Use 8 timeslots - L , R and 6 other */
+						reg_value =
+						    SET_BITS(regSSI_NETWORK,
+							     STDCSLOTS, 1);
+					}
+					if (pmic_write_reg
+					    (REG_AUDIO_SSI_NETWORK,
+					     reg_value,
+					     SSI_NW_MASK) != PMIC_SUCCESS) {
+						rc = PMIC_ERROR;
+					} else {
+						stDAC.busID = busID;
+						stDAC.protocol = protocol;
+						stDAC.protocol_set = true;
+						stDAC.masterSlave = masterSlave;
+						stDAC.numSlots = numSlots;
+						pr_debug
+						    ("mc13783 Stereo DAC successfully configured\n");
+						rc = PMIC_SUCCESS;
+					}
+				}
+
+			}
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+			/* Handle  can only be Voice Codec or Stereo DAC */
+			pr_debug("Handles only STDAC and VCODEC\n");
+		}
+
+	}
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Retrieve the current data bus protocol configuration.
+ *
+ * Retrieve the parameters that define the current audio data bus protocol.
+ *
+ * @param  handle          Device handle from pmic_audio_open() call.
+ * @param  busID           The data bus being used.
+ * @param  protocol        The data bus protocol being used.
+ * @param  masterSlave     The data bus timing mode being used.
+ * @param  numSlots        The number of timeslots being used (if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_protocol(const PMIC_AUDIO_HANDLE handle,
+				    PMIC_AUDIO_DATA_BUS * const busID,
+				    PMIC_AUDIO_BUS_PROTOCOL * const protocol,
+				    PMIC_AUDIO_BUS_MODE * const masterSlave,
+				    PMIC_AUDIO_NUMSLOTS * const numSlots)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	if ((busID != (PMIC_AUDIO_DATA_BUS *) NULL) &&
+	    (protocol != (PMIC_AUDIO_BUS_PROTOCOL *) NULL) &&
+	    (masterSlave != (PMIC_AUDIO_BUS_MODE *) NULL) &&
+	    (numSlots != (PMIC_AUDIO_NUMSLOTS *) NULL)) {
+		/* Enter a critical section so that we return a consistent state. */
+		if (down_interruptible(&mutex))
+			return PMIC_SYSTEM_ERROR_EINTR;
+
+		if ((handle == stDAC.handle) &&
+		    (stDAC.handleState == HANDLE_IN_USE)) {
+			*busID = stDAC.busID;
+			*protocol = stDAC.protocol;
+			*masterSlave = stDAC.masterSlave;
+			*numSlots = stDAC.numSlots;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == vCodec.handle) &&
+			   (vCodec.handleState == HANDLE_IN_USE)) {
+			*busID = vCodec.busID;
+			*protocol = vCodec.protocol;
+			*masterSlave = vCodec.masterSlave;
+			*numSlots = vCodec.numSlots;
+			rc = PMIC_SUCCESS;
+		}
+
+		/* Exit critical section. */
+		up(&mutex);
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Enable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly enable the Stereo DAC or the Voice CODEC to begin audio
+ * playback or recording as required. This should only be done after
+ * successfully configuring all of the associated audio components (e.g.,
+ * microphones, amplifiers, etc.).
+ *
+ * Note that the timed delays used in this function are necessary to
+ * ensure reliable operation of the Voice CODEC and Stereo DAC. The
+ * Stereo DAC seems to be particularly sensitive and it has been observed
+ * to fail to generate the required master mode clock signals if it is
+ * not allowed enough time to initialize properly.
+ *
+ * @param      handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be enabled.
+ */
+PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle)
+{
+	const unsigned int AUDIO_BIAS_ENABLE = SET_BITS(regAUDIO_RX_0,
+							VAUDIOON, 1);
+	const unsigned int STDAC_ENABLE = SET_BITS(regST_DAC, STDCEN, 1);
+	const unsigned int VCODEC_ENABLE = SET_BITS(regAUD_CODEC, CDCEN, 1);
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
+			       AUDIO_BIAS_ENABLE);
+		reg_mask =
+		    SET_BITS(regAUDIO_RX_0, HSDETEN,
+			     1) | SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write =
+		    SET_BITS(regAUDIO_RX_0, HSDETEN,
+			     1) | SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+		if (rc == PMIC_SUCCESS)
+			pr_debug("pmic_audio_enable\n");
+		/* We can enable the Stereo DAC. */
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+				    STDAC_ENABLE, STDAC_ENABLE);
+		/*pmic_read_reg(REG_AUDIO_STEREO_DAC, &reg_value); */
+		if (rc != PMIC_SUCCESS) {
+			pr_debug("Failed to enable the Stereo DAC\n");
+			rc = PMIC_ERROR;
+		}
+	} else if ((handle == vCodec.handle)
+		   && (vCodec.handleState == HANDLE_IN_USE)) {
+		/* Must first set the audio bias bit to power up the audio circuits. */
+		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
+			       AUDIO_BIAS_ENABLE);
+		reg_mask = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+		    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+		    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+
+		/* Then we can enable the Voice CODEC. */
+		rc = pmic_write_reg(REG_AUDIO_CODEC, VCODEC_ENABLE,
+				    VCODEC_ENABLE);
+
+		/* pmic_read_reg(REG_AUDIO_CODEC, &reg_value); */
+		if (rc != PMIC_SUCCESS) {
+			pr_debug("Failed to enable the Voice codec\n");
+			rc = PMIC_ERROR;
+		}
+	}
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Disable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly disable the Stereo DAC or the Voice CODEC to end audio
+ * playback or recording as required.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be disabled.
+ */
+PMIC_STATUS pmic_audio_disable(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int STDAC_DISABLE = SET_BITS(regST_DAC, STDCEN, 1);
+	const unsigned int VCODEC_DISABLE = SET_BITS(regAUD_CODEC, CDCEN, 1);
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC, 0, STDAC_DISABLE);
+	} else if ((handle == vCodec.handle)
+		   && (vCodec.handleState == HANDLE_IN_USE)) {
+		rc = pmic_write_reg(REG_AUDIO_CODEC, 0, VCODEC_DISABLE);
+	}
+	if (rc == PMIC_SUCCESS)
+		pr_debug("Disabled successfully\n");
+
+	/* Exit critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their initial power on state.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	rc = pmic_audio_reset_device(handle);
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Reset all audio hardware control registers to their power on state.
+ *
+ * This resets all of the audio hardware control registers back to their
+ * power on states. Use this function with care since it also invalidates
+ * (i.e., automatically closes) all currently opened device handles.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset_all(void)
+{
+	PMIC_STATUS rc = PMIC_SUCCESS;
+	unsigned int audio_ssi_reset = 0;
+	unsigned int audio_rx1_reset = 0;
+	/* We need a critical section here to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* First close all opened device handles, also deregisters callbacks. */
+	pmic_audio_close_handle(stDAC.handle);
+	pmic_audio_close_handle(vCodec.handle);
+	pmic_audio_close_handle(extStereoIn.handle);
+
+	if (pmic_write_reg(REG_AUDIO_RX_1, RESET_AUDIO_RX_1,
+			   PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		audio_rx1_reset = 1;
+	}
+	if (pmic_write_reg(REG_AUDIO_SSI_NETWORK, RESET_SSI_NETWORK,
+			   PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		audio_ssi_reset = 1;
+	}
+	if (pmic_write_reg
+	    (REG_AUDIO_STEREO_DAC, RESET_ST_DAC,
+	     PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		/* Also reset the driver state information to match. Note that we
+		 * keep the device handle and event callback settings unchanged
+		 * since these don't affect the actual hardware and we rely on
+		 * the user to explicitly close the handle or deregister callbacks
+		 */
+		if (audio_ssi_reset) {
+			/* better to check if SSI is also reset as some fields are represennted in SSI reg */
+			stDAC.busID = AUDIO_DATA_BUS_1;
+			stDAC.protocol = NORMAL_MSB_JUSTIFIED_MODE;
+			stDAC.masterSlave = BUS_MASTER_MODE;
+			stDAC.protocol_set = false;
+			stDAC.numSlots = USE_2_TIMESLOTS;
+			stDAC.clockIn = CLOCK_IN_CLIA;
+			stDAC.samplingRate = STDAC_RATE_44_1_KHZ;
+			stDAC.clockFreq = STDAC_CLI_13MHZ;
+			stDAC.invert = NO_INVERT;
+			stDAC.timeslot = USE_TS0_TS1;
+			stDAC.config = (PMIC_AUDIO_STDAC_CONFIG) 0;
+		}
+	}
+
+	if (pmic_write_reg(REG_AUDIO_CODEC, RESET_AUD_CODEC,
+			   PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		/* Also reset the driver state information to match. Note that we
+		 * keep the device handle and event callback settings unchanged
+		 * since these don't affect the actual hardware and we rely on
+		 * the user to explicitly close the handle or deregister callbacks
+		 */
+		if (audio_ssi_reset) {
+			vCodec.busID = AUDIO_DATA_BUS_2;
+			vCodec.protocol = NETWORK_MODE;
+			vCodec.masterSlave = BUS_SLAVE_MODE;
+			vCodec.protocol_set = false;
+			vCodec.numSlots = USE_4_TIMESLOTS;
+			vCodec.clockIn = CLOCK_IN_CLIB;
+			vCodec.samplingRate = VCODEC_RATE_8_KHZ;
+			vCodec.clockFreq = VCODEC_CLI_13MHZ;
+			vCodec.invert = NO_INVERT;
+			vCodec.timeslot = USE_TS0;
+			vCodec.config =
+			    INPUT_HIGHPASS_FILTER | OUTPUT_HIGHPASS_FILTER;
+		}
+	}
+
+	if (pmic_write_reg(REG_AUDIO_RX_0, RESET_AUDIO_RX_0,
+			   PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		/* Also reset the driver state information to match. */
+		audioOutput.outputPort = (PMIC_AUDIO_OUTPUT_PORT) NULL;
+		audioOutput.vCodecoutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.stDacoutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.extStereooutputPGAGain = OUTPGA_GAIN_0DB;
+		audioOutput.balanceLeftGain = BAL_GAIN_0DB;
+		audioOutput.balanceRightGain = BAL_GAIN_0DB;
+		audioOutput.monoAdderGain = MONOADD_GAIN_0DB;
+		audioOutput.config = (PMIC_AUDIO_OUTPUT_CONFIG) 0;
+		audioOutput.vCodecOut = VCODEC_DIRECT_OUT;
+	}
+
+	if (pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX,
+			   PMIC_ALL_BITS) != PMIC_SUCCESS) {
+		rc = PMIC_ERROR;
+	} else {
+		/* Also reset the driver state information to match. Note that we
+		 * reset the vCodec fields since all of the input/recording
+		 * devices are only connected to the Voice CODEC and are managed
+		 * as part of the Voice CODEC state.
+		 */
+		if (audio_rx1_reset) {
+			vCodec.leftChannelMic.mic = NO_MIC;
+			vCodec.leftChannelMic.micOnOff = MICROPHONE_OFF;
+			vCodec.leftChannelMic.ampMode = CURRENT_TO_VOLTAGE;
+			vCodec.leftChannelMic.gain = MIC_GAIN_0DB;
+			vCodec.rightChannelMic.mic = NO_MIC;
+			vCodec.rightChannelMic.micOnOff = MICROPHONE_OFF;
+			vCodec.rightChannelMic.ampMode = AMP_OFF;
+			vCodec.rightChannelMic.gain = MIC_GAIN_0DB;
+		}
+	}
+	/* Finally, also reset any global state variables. */
+	headsetState = NO_HEADSET;
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Set the Audio callback function.
+ *
+ * Register a callback function that will be used to signal PMIC audio
+ * events. For example, the OSS audio driver should register a callback
+ * function in order to be notified of headset connect/disconnect events.
+ *
+ * @param   func            A pointer to the callback function.
+ * @param   eventMask       A mask selecting events to be notified.
+ * @param   hs_state        To know the headset state.
+ *
+ *
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_audio_set_callback(void *func,
+				    const PMIC_AUDIO_EVENTS eventMask,
+				    PMIC_HS_STATE *hs_state)
+{
+	unsigned long flags;
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	pmic_event_callback_t eventNotify;
+
+	/* We need to start a critical section here to ensure a consistent state
+	 * in case simultaneous calls to pmic_audio_set_callback() are made. In
+	 * that case, we must serialize the calls to ensure that the "callback"
+	 * and "eventMask" state variables are always consistent.
+	 *
+	 * Note that we don't actually need to acquire the spinlock until later
+	 * when we are finally ready to update the "callback" and "eventMask"
+	 * state variables which are shared with the interrupt handler.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	rc = PMIC_ERROR;
+	/* Register for PMIC events from the core protocol driver. */
+	if (eventMask & MICROPHONE_DETECTED) {
+		/* We need to register for the A1 amplifier interrupt. */
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_MC2BI);
+		rc = pmic_event_subscribe(EVENT_MC2BI, eventNotify);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug
+			    ("%s: pmic_event_subscribe() for EVENT_HSDETI "
+			     "failed\n", __FILE__);
+			goto End;
+		}
+	}
+
+	if (eventMask & HEADSET_DETECTED) {
+		/* We need to register for the A1 amplifier interrupt. */
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_HSDETI);
+		rc = pmic_event_subscribe(EVENT_HSDETI, eventNotify);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug
+			    ("%s: pmic_event_subscribe() for EVENT_HSDETI "
+			     "failed\n", __FILE__);
+			goto Cleanup_HDT;
+		}
+
+	}
+	if (eventMask & HEADSET_STEREO) {
+		/* We need to register for the A1 amplifier interrupt. */
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_HSLI);
+		rc = pmic_event_subscribe(EVENT_HSLI, eventNotify);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug
+			    ("%s: pmic_event_subscribe() for EVENT_HSLI "
+			     "failed\n", __FILE__);
+			goto Cleanup_HST;
+		}
+	}
+	if (eventMask & HEADSET_THERMAL_SHUTDOWN) {
+		/* We need to register for the A1 amplifier interrupt. */
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_ALSPTHI);
+		rc = pmic_event_subscribe(EVENT_ALSPTHI, eventNotify);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug
+			    ("%s: pmic_event_subscribe() for EVENT_ALSPTHI "
+			     "failed\n", __FILE__);
+			goto Cleanup_TSD;
+		}
+		pr_debug("Registered for EVENT_ALSPTHI\n");
+	}
+	if (eventMask & HEADSET_SHORT_CIRCUIT) {
+		/* We need to register for the A1 amplifier interrupt. */
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_AHSSHORTI);
+		rc = pmic_event_subscribe(EVENT_AHSSHORTI, eventNotify);
+
+		if (rc != PMIC_SUCCESS) {
+			pr_debug
+			    ("%s: pmic_event_subscribe() for EVENT_AHSSHORTI "
+			     "failed\n", __FILE__);
+			goto Cleanup_HShort;
+		}
+		pr_debug("Registered for EVENT_AHSSHORTI\n");
+	}
+
+	/* We also need the spinlock here to avoid possible problems
+	 * with the interrupt handler  when we update the
+	 * "callback" and "eventMask" state variables.
+	 */
+	spin_lock_irqsave(&lock, flags);
+
+	/* Successfully registered for all events. */
+	event_state.callback = func;
+	event_state.eventMask = eventMask;
+
+	/* The spinlock is no longer needed now that we've finished
+	 * updating the "callback" and "eventMask" state variables.
+	 */
+	spin_unlock_irqrestore(&lock, flags);
+
+	goto End;
+
+	/* This section unregisters any already registered events if we should
+	 * encounter an error partway through the registration process. Note
+	 * that we don't check the return status here since it is already set
+	 * to PMIC_ERROR before we get here.
+	 */
+Cleanup_HShort:
+
+	if (eventMask & HEADSET_SHORT_CIRCUIT) {
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_AHSSHORTI);
+		pmic_event_unsubscribe(EVENT_AHSSHORTI, eventNotify);
+	}
+
+Cleanup_TSD:
+
+	if (eventMask & HEADSET_THERMAL_SHUTDOWN) {
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_ALSPTHI);
+		pmic_event_unsubscribe(EVENT_ALSPTHI, eventNotify);
+	}
+
+Cleanup_HST:
+
+	if (eventMask & HEADSET_STEREO) {
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_HSLI);
+		pmic_event_unsubscribe(EVENT_HSLI, eventNotify);
+	}
+
+Cleanup_HDT:
+
+	if (eventMask & HEADSET_DETECTED) {
+		eventNotify.func = func;
+		eventNotify.param = (void *)(CORE_EVENT_HSDETI);
+		pmic_event_unsubscribe(EVENT_HSDETI, eventNotify);
+	}
+
+End:
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Deregisters the existing audio callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_audio_set_callback().
+ *
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_clear_callback(void)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* We need a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (event_state.callback != (PMIC_AUDIO_CALLBACK) NULL) {
+		rc = pmic_audio_deregister(&(event_state.callback),
+					   &(event_state.eventMask));
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Get the current audio callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param   func            The current callback function.
+ * @param   eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_callback(PMIC_AUDIO_CALLBACK * const func,
+				    PMIC_AUDIO_EVENTS * const eventMask)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* We only need to acquire the mutex here because we will not be updating
+	 * anything that may affect the interrupt handler. We just need to ensure
+	 * that the callback fields are not changed while we are in the critical
+	 * section by calling either pmic_audio_set_callback() or
+	 * pmic_audio_clear_callback().
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((func != (PMIC_AUDIO_CALLBACK *) NULL) &&
+	    (eventMask != (PMIC_AUDIO_EVENTS *) NULL)) {
+
+		*func = event_state.callback;
+		*eventMask = event_state.eventMask;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Enable the anti-pop circuitry to avoid extra noise when inserting
+ *        or removing a external device (e.g., a headset).
+ *
+ * Enable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug. A slow ramp speed may be needed to avoid extra noise.
+ *
+ * @param       rampSpeed       The desired anti-pop circuitry ramp speed.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   enabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_antipop_enable(const PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+				      rampSpeed)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, BIASEN, 1) |
+	    SET_BITS(regAUDIO_RX_0, BIASSPEED, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	/*
+	 * Antipop is enabled by enabling the BIAS (BIASEN) and setting the
+	 * BIASSPEED .
+	 * BIASEN is just to make sure that BIAS is enabled
+	 */
+	reg_value = SET_BITS(regAUDIO_RX_0, BIASEN, 1)
+	    | SET_BITS(regAUDIO_RX_0, BIASSPEED, 0) | SET_BITS(regAUDIO_RX_0,
+							       HSLDETEN, 1);
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_value, reg_mask);
+	return rc;
+}
+
+/*!
+ * @brief Disable the anti-pop circuitry.
+ *
+ * Disable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   disabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_antipop_disable(void)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, BIASSPEED, 1) |
+	    SET_BITS(regAUDIO_RX_0, BIASEN, 1);
+	const unsigned int reg_write = SET_BITS(regAUDIO_RX_0, BIASSPEED, 1) |
+	    SET_BITS(regAUDIO_RX_0, BIASEN, 0);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	/*
+	 * Antipop is disabled by setting BIASSPEED  = 0. BIASEN bit remains set
+	 * as only antipop needs to be disabled
+	 */
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+
+	return rc;
+}
+
+/*!
+ * @brief Performs a reset of the Voice CODEC/Stereo DAC digital filter.
+ *
+ * The digital filter should be reset whenever the clock or sampling rate
+ * configuration has been changed.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the digital filter was successfully
+ *                                   reset.
+ * @retval      PMIC_ERROR           If the digital filter could not be reset.
+ */
+PMIC_STATUS pmic_audio_digital_filter_reset(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regST_DAC, STDCRESET, 1);
+		if (pmic_write_reg(REG_AUDIO_STEREO_DAC, reg_mask,
+				   reg_mask) != PMIC_SUCCESS) {
+			rc = PMIC_ERROR;
+		} else {
+			pr_debug("STDAC filter reset\n");
+		}
+
+	} else if ((handle == vCodec.handle) &&
+		   (vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUD_CODEC, CDCRESET, 1);
+		if (pmic_write_reg(REG_AUDIO_CODEC, reg_mask,
+				   reg_mask) != PMIC_SUCCESS) {
+			rc = PMIC_ERROR;
+		} else {
+			pr_debug("CODEC filter reset\n");
+		}
+	}
+	return rc;
+}
+
+/*!
+ * @brief Get the most recent PTT button voltage reading.
+ *
+ * This feature is not supported by mc13783
+ * @param       level                PTT button level.
+ *
+ * @retval      PMIC_SUCCESS         If the most recent PTT button voltage was
+ *                                   returned.
+ * @retval      PMIC_PARAMETER_ERROR If a NULL pointer argument was given.
+ */
+PMIC_STATUS pmic_audio_get_ptt_button_level(unsigned int *const level)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+#ifdef DEBUG_AUDIO
+
+/*!
+ * @brief Provide a hexadecimal dump of all PMIC audio registers (DEBUG only)
+ *
+ * This function is intended strictly for debugging purposes only and will
+ * print the current values of the following PMIC registers:
+ *
+ * - AUD_CODEC
+ * - ST_DAC
+ * - AUDIO_RX_0
+ * - AUDIO_RX_1
+ * - AUDIO_TX
+ * - AUDIO_SSI_NW
+ *
+ * The register fields will not be decoded.
+ *
+ * Note that we don't dump any of the arbitration bits because we cannot
+ * access the true arbitration bit settings when reading the registers
+ * from the secondary SPI bus.
+ *
+ * Also note that we must not call this function with interrupts disabled,
+ * for example, while holding a spinlock, because calls to pmic_read_reg()
+ * eventually end up in the SPI driver which will want to perform a
+ * schedule() operation. If schedule() is called with interrupts disabled,
+ * then you will see messages like the following:
+ *
+ * BUG: scheduling while atomic: ...
+ *
+ */
+void pmic_audio_dump_registers(void)
+{
+	unsigned int reg_value = 0;
+
+	/* Dump the AUD_CODEC (Voice CODEC) register. */
+	if (pmic_read_reg(REG_AUDIO_CODEC, &reg_value, REG_FULLMASK)
+	    == PMIC_SUCCESS) {
+		pr_debug("Audio Codec = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read audio codec\n");
+	}
+
+	/* Dump the ST DAC (Stereo DAC) register. */
+	if (pmic_read_reg
+	    (REG_AUDIO_STEREO_DAC, &reg_value, REG_FULLMASK) == PMIC_SUCCESS) {
+		pr_debug("Stereo DAC = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read Stereo DAC\n");
+	}
+
+	/* Dump the SSI NW register. */
+	if (pmic_read_reg
+	    (REG_AUDIO_SSI_NETWORK, &reg_value, REG_FULLMASK) == PMIC_SUCCESS) {
+		pr_debug("SSI Network = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read SSI network\n");
+	}
+
+	/* Dump the Audio RX 0 register. */
+	if (pmic_read_reg(REG_AUDIO_RX_0, &reg_value, REG_FULLMASK)
+	    == PMIC_SUCCESS) {
+		pr_debug("Audio RX 0 = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read audio RX 0\n");
+	}
+
+	/* Dump the Audio RX 1 register. */
+	if (pmic_read_reg(REG_AUDIO_RX_1, &reg_value, REG_FULLMASK)
+	    == PMIC_SUCCESS) {
+		pr_debug("Audio RX 1 = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read audio RX 1\n");
+	}
+	/* Dump the Audio TX register. */
+	if (pmic_read_reg(REG_AUDIO_TX, &reg_value, REG_FULLMASK) ==
+	    PMIC_SUCCESS) {
+		pr_debug("Audio Tx = 0x%x\n", reg_value);
+	} else {
+		pr_debug("Failed to read audio TX\n");
+	}
+
+}
+
+#endif				/* DEBUG_AUDIO */
+
+/*@}*/
+
+/*************************************************************************
+ * General Voice CODEC configuration.
+ *************************************************************************
+ */
+
+/*!
+ * @name General Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice
+ * CODEC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Voice CODEC clock source and operating characteristics.
+ *
+ * Define the Voice CODEC clock source and operating characteristics. This
+ * must be done before the Voice CODEC is enabled.
+ *
+ *
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       clockIn         Select the clock signal source.
+ * @param       clockFreq       Select the clock signal frequency.
+ * @param       samplingRate    Select the audio data sampling rate.
+ * @param       invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_clock(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_CLOCK_IN_SOURCE
+					clockIn,
+					const PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+					clockFreq,
+					const PMIC_AUDIO_VCODEC_SAMPLING_RATE
+					samplingRate,
+					const PMIC_AUDIO_CLOCK_INVERT invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Validate all of the calling parameters. */
+	if (handle == (PMIC_AUDIO_HANDLE) NULL) {
+		rc = PMIC_PARAMETER_ERROR;
+	} else if ((handle == vCodec.handle) &&
+		   (vCodec.handleState == HANDLE_IN_USE)) {
+		if ((clockIn != CLOCK_IN_CLIA) && (clockIn != CLOCK_IN_CLIB)) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if (!((clockFreq >= VCODEC_CLI_13MHZ)
+			     && (clockFreq <= VCODEC_CLI_33_6MHZ))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if ((samplingRate != VCODEC_RATE_8_KHZ)
+			   && (samplingRate != VCODEC_RATE_16_KHZ)) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if (!((invert >= NO_INVERT)
+			     && (invert <= INVERT_FRAMESYNC))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else {
+			/*reg_mask = SET_BITS(regAUD_CODEC, CDCCLK, 7) |
+			   SET_BITS(regAUD_CODEC, CDCCLKSEL, 1) |
+			   SET_BITS(regAUD_CODEC, CDCFS8K16K, 1) |
+			   SET_BITS(regAUD_CODEC, CDCBCLINV, 1) |
+			   SET_BITS(regAUD_CODEC, CDCFSINV, 1); */
+			if (clockIn == CLOCK_IN_CLIA) {
+				reg_value =
+				    SET_BITS(regAUD_CODEC, CDCCLKSEL, 0);
+			} else {
+				reg_value =
+				    SET_BITS(regAUD_CODEC, CDCCLKSEL, 1);
+			}
+			reg_mask = SET_BITS(regAUD_CODEC, CDCCLKSEL, 1);
+			if (PMIC_SUCCESS !=
+			    pmic_write_reg(REG_AUDIO_CODEC,
+					   reg_value, reg_mask))
+				return PMIC_ERROR;
+
+			reg_value = 0;
+			if (clockFreq == VCODEC_CLI_13MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 0);
+			else if (clockFreq == VCODEC_CLI_15_36MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 1);
+			else if (clockFreq == VCODEC_CLI_16_8MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 2);
+			else if (clockFreq == VCODEC_CLI_26MHZ)
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 4);
+			else
+				reg_value |= SET_BITS(regAUD_CODEC, CDCCLK, 7);
+
+			reg_mask = SET_BITS(regAUD_CODEC, CDCCLK, 7);
+			if (PMIC_SUCCESS !=
+			    pmic_write_reg(REG_AUDIO_CODEC,
+					   reg_value, reg_mask))
+				return PMIC_ERROR;
+
+			reg_value = 0;
+			reg_mask = 0;
+
+			if (samplingRate == VCODEC_RATE_8_KHZ) {
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCFS8K16K, 0);
+			} else {
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCFS8K16K, 1);
+			}
+			reg_mask = SET_BITS(regAUD_CODEC, CDCFS8K16K, 1);
+			if (PMIC_SUCCESS !=
+			    pmic_write_reg(REG_AUDIO_CODEC,
+					   reg_value, reg_mask))
+				return PMIC_ERROR;
+			reg_value = 0;
+			reg_mask =
+			    SET_BITS(regAUD_CODEC, CDCBCLINV,
+				     1) | SET_BITS(regAUD_CODEC, CDCFSINV, 1);
+
+			if (invert & INVERT_BITCLOCK) {
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCBCLINV, 1);
+			}
+			if (invert & INVERT_FRAMESYNC) {
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCFSINV, 1);
+			}
+			if (invert & NO_INVERT) {
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCBCLINV, 0);
+				reg_value |=
+				    SET_BITS(regAUD_CODEC, CDCFSINV, 0);
+			}
+			if (pmic_write_reg
+			    (REG_AUDIO_CODEC, reg_value,
+			     reg_mask) != PMIC_SUCCESS) {
+				rc = PMIC_ERROR;
+			} else {
+				pr_debug("CODEC clock set\n");
+				vCodec.clockIn = clockIn;
+				vCodec.clockFreq = clockFreq;
+				vCodec.samplingRate = samplingRate;
+				vCodec.invert = invert;
+			}
+
+		}
+
+	} else {
+		rc = PMIC_PARAMETER_ERROR;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the Voice CODEC clock source and operating characteristics.
+ *
+ * Get the current Voice CODEC clock source and operating characteristics.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	clockIn         The clock signal source.
+ * @param	clockFreq       The clock signal frequency.
+ * @param	samplingRate    The audio data sampling rate.
+ * @param       invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_clock(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_CLOCK_IN_SOURCE *
+					const clockIn,
+					PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *
+					const clockFreq,
+					PMIC_AUDIO_VCODEC_SAMPLING_RATE *
+					const samplingRate,
+					PMIC_AUDIO_CLOCK_INVERT * const invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure that we return a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (clockIn != (PMIC_AUDIO_CLOCK_IN_SOURCE *) NULL) &&
+	    (clockFreq != (PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *) NULL) &&
+	    (samplingRate != (PMIC_AUDIO_VCODEC_SAMPLING_RATE *) NULL) &&
+	    (invert != (PMIC_AUDIO_CLOCK_INVERT *) NULL)) {
+		*clockIn = vCodec.clockIn;
+		*clockFreq = vCodec.clockFreq;
+		*samplingRate = vCodec.samplingRate;
+		*invert = vCodec.invert;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the Voice CODEC primary audio channel timeslot.
+ *
+ * Set the Voice CODEC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+						const PMIC_AUDIO_VCODEC_TIMESLOT
+						timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regSSI_NETWORK, CDCTXRXSLOT, 3);
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    ((timeslot == USE_TS0) || (timeslot == USE_TS1) ||
+	     (timeslot == USE_TS2) || (timeslot == USE_TS3))) {
+		reg_write = SET_BITS(regSSI_NETWORK, CDCTXRXSLOT, timeslot);
+
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.timeslot = timeslot;
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param       timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+						PMIC_AUDIO_VCODEC_TIMESLOT *
+						const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (timeslot != (PMIC_AUDIO_VCODEC_TIMESLOT *) NULL)) {
+		*timeslot = vCodec.timeslot;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Set the Voice CODEC secondary audio channel timeslot. This function must be
+ * used if the default timeslot for the secondary audio channel is to be
+ * changed. The secondary audio channel timeslot is used to transmit the audio
+ * data that was recorded by the Voice CODEC from the secondary audio input
+ * channel.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   timeslot        Select the secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_secondary_txslot(const PMIC_AUDIO_HANDLE
+						   handle,
+						   const
+						   PMIC_AUDIO_VCODEC_TIMESLOT
+						   timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regSSI_NETWORK, CDCTXSECSLOT, 3);
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		/* How to handle primary slot and secondary slot being the same */
+		if ((timeslot >= USE_TS0) && (timeslot <= USE_TS3)
+		    && (timeslot != vCodec.timeslot)) {
+			reg_write =
+			    SET_BITS(regSSI_NETWORK, CDCTXSECSLOT, timeslot);
+
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				vCodec.secondaryTXtimeslot = timeslot;
+
+		}
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Get the Voice CODEC secondary audio channel timeslot.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       timeslot        The secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_secondary_txslot(const PMIC_AUDIO_HANDLE
+						   handle,
+						   PMIC_AUDIO_VCODEC_TIMESLOT *
+						   const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (timeslot != (PMIC_AUDIO_VCODEC_TIMESLOT *) NULL)) {
+		rc = PMIC_SUCCESS;
+		*timeslot = vCodec.secondaryTXtimeslot;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Set/Enable the Voice CODEC options.
+ *
+ * Set or enable various Voice CODEC options. The available options include
+ * the use of dithering, highpass digital filters, and loopback modes.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       config          The Voice CODEC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_config(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_VCODEC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (config & DITHERING) {
+			reg_write = SET_BITS(regAUD_CODEC, CDCDITH, 0);
+			reg_mask = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+		}
+
+		if (config & INPUT_HIGHPASS_FILTER) {
+			reg_write |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+		}
+
+		if (config & OUTPUT_HIGHPASS_FILTER) {
+			reg_write |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+		}
+
+		if (config & DIGITAL_LOOPBACK) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+		}
+
+		if (config & ANALOG_LOOPBACK) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+		}
+
+		if (config & VCODEC_MASTER_CLOCK_OUTPUTS) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1) |
+			    SET_BITS(regAUD_CODEC, CDCTS, 0);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1) |
+			    SET_BITS(regAUD_CODEC, CDCTS, 1);
+
+		}
+
+		if (config & TRISTATE_TS) {
+			reg_write |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+		}
+
+		if (reg_mask == 0) {
+			/* We should not reach this point without having to configure
+			 * anything so we flag it as an error.
+			 */
+			rc = PMIC_ERROR;
+		} else {
+			rc = pmic_write_reg(REG_AUDIO_CODEC,
+					    reg_write, reg_mask);
+		}
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.config |= config;
+
+	}
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Clear/Disable the Voice CODEC options.
+ *
+ * Clear or disable various Voice CODEC options.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   config          The Voice CODEC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_clear_config(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_VCODEC_CONFIG
+					   config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (config & DITHERING) {
+			reg_mask = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+			reg_write = SET_BITS(regAUD_CODEC, CDCDITH, 1);
+		}
+
+		if (config & INPUT_HIGHPASS_FILTER)
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDIHPF, 1);
+
+
+		if (config & OUTPUT_HIGHPASS_FILTER)
+			reg_mask |= SET_BITS(regAUD_CODEC, AUDOHPF, 1);
+
+
+		if (config & DIGITAL_LOOPBACK)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCDLM, 1);
+
+
+		if (config & ANALOG_LOOPBACK)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCALM, 1);
+
+
+		if (config & VCODEC_MASTER_CLOCK_OUTPUTS)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCCLKEN, 1);
+
+
+		if (config & TRISTATE_TS)
+			reg_mask |= SET_BITS(regAUD_CODEC, CDCTS, 1);
+
+
+		if (reg_mask == 0) {
+			/* We should not reach this point without having to configure
+			 * anything so we flag it as an error.
+			 */
+			rc = PMIC_ERROR;
+		} else {
+			rc = pmic_write_reg(REG_AUDIO_CODEC,
+					    reg_write, reg_mask);
+		}
+
+		if (rc == PMIC_SUCCESS)
+			vCodec.config |= config;
+
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current Voice CODEC options.
+ *
+ * Get the current Voice CODEC options.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	config          The current set of Voice CODEC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_config(const PMIC_AUDIO_HANDLE handle,
+					 PMIC_AUDIO_VCODEC_CONFIG *
+					 const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (config != (PMIC_AUDIO_VCODEC_CONFIG *) NULL)) {
+		*config = vCodec.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Enable the Voice CODEC bypass audio pathway.
+ *
+ * Enables the Voice CODEC bypass pathway for audio data. This allows direct
+ * output of the voltages on the TX data bus line to the output amplifiers
+ * (bypassing the digital-to-analog converters within the Voice CODEC).
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_bypass(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+	const unsigned int reg_mask = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_CODEC, reg_write, reg_mask);
+
+
+	return rc;
+}
+
+/*!
+ * @brief Disable the Voice CODEC bypass audio pathway.
+ *
+ * Disables the Voice CODEC bypass pathway for audio data. This means that
+ * the TX data bus line will deliver digital data to the digital-to-analog
+ * converters within the Voice CODEC.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_bypass(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regAUD_CODEC, CDCBYP, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_CODEC, reg_write, reg_mask);
+
+
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * General Stereo DAC configuration.
+ *************************************************************************
+ */
+
+/*!
+ * @name General Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo
+ * DAC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Stereo DAC clock source and operating characteristics.
+ *
+ * Define the Stereo DAC clock source and operating characteristics. This
+ * must be done before the Stereo DAC is enabled.
+ *
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   clockIn         Select the clock signal source.
+ * @param   clockFreq       Select the clock signal frequency.
+ * @param   samplingRate    Select the audio data sampling rate.
+ * @param   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_clock(const PMIC_AUDIO_HANDLE handle,
+				       const PMIC_AUDIO_CLOCK_IN_SOURCE clockIn,
+				       const PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+				       clockFreq,
+				       const PMIC_AUDIO_STDAC_SAMPLING_RATE
+				       samplingRate,
+				       const PMIC_AUDIO_CLOCK_INVERT invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	/* Validate all of the calling parameters. */
+	if (handle == (PMIC_AUDIO_HANDLE) NULL) {
+		rc = PMIC_PARAMETER_ERROR;
+	} else if ((handle == stDAC.handle) &&
+		   (stDAC.handleState == HANDLE_IN_USE)) {
+		if ((clockIn != CLOCK_IN_CLIA) && (clockIn != CLOCK_IN_CLIB)) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if ((stDAC.masterSlave == BUS_MASTER_MODE)
+			   && !((clockFreq >= STDAC_CLI_3_36864MHZ)
+				&& (clockFreq <= STDAC_CLI_33_6MHZ))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if ((stDAC.masterSlave == BUS_SLAVE_MODE)
+			   && !((clockFreq >= STDAC_MCLK_PLL_DISABLED)
+				&& (clockFreq <= STDAC_BCLK_IN_PLL))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if (!((samplingRate >= STDAC_RATE_8_KHZ)
+			     && (samplingRate <= STDAC_RATE_96_KHZ))) {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+		/*
+		   else if(!((invert >= NO_INVERT) && (invert <= INVERT_FRAMESYNC)))
+		   {
+		   rc = PMIC_PARAMETER_ERROR;
+		   } */
+		else {
+			reg_mask = SET_BITS(regST_DAC, STDCCLK, 7) |
+			    SET_BITS(regST_DAC, STDCCLKSEL, 1) |
+			    SET_BITS(regST_DAC, SR, 15) |
+			    SET_BITS(regST_DAC, STDCBCLINV, 1) |
+			    SET_BITS(regST_DAC, STDCFSINV, 1);
+			if (clockIn == CLOCK_IN_CLIA)
+				reg_value = SET_BITS(regST_DAC, STDCCLKSEL, 0);
+			else
+				reg_value = SET_BITS(regST_DAC, STDCCLKSEL, 1);
+
+			/* How to take care of sample rates in SLAVE mode */
+			if ((clockFreq == STDAC_CLI_3_36864MHZ)
+			    || ((clockFreq == STDAC_FSYNC_IN_PLL))) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 6);
+			} else if ((clockFreq == STDAC_CLI_12MHZ)
+				   || (clockFreq == STDAC_MCLK_PLL_DISABLED)) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 5);
+			} else if (clockFreq == STDAC_CLI_13MHZ) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 0);
+			} else if (clockFreq == STDAC_CLI_15_36MHZ) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 1);
+			} else if (clockFreq == STDAC_CLI_16_8MHZ) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 2);
+			} else if (clockFreq == STDAC_CLI_26MHZ) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 4);
+			} else if ((clockFreq == STDAC_CLI_33_6MHZ)
+				   || (clockFreq == STDAC_BCLK_IN_PLL)) {
+				reg_value |= SET_BITS(regST_DAC, STDCCLK, 7);
+			}
+
+			reg_value |= SET_BITS(regST_DAC, SR, samplingRate);
+
+			if (invert & INVERT_BITCLOCK)
+				reg_value |= SET_BITS(regST_DAC, STDCBCLINV, 1);
+
+			if (invert & INVERT_FRAMESYNC)
+				reg_value |= SET_BITS(regST_DAC, STDCFSINV, 1);
+
+			if (invert & NO_INVERT) {
+				reg_value |= SET_BITS(regST_DAC, STDCBCLINV, 0);
+				reg_value |= SET_BITS(regST_DAC, STDCFSINV, 0);
+			}
+			if (pmic_write_reg
+			    (REG_AUDIO_STEREO_DAC, reg_value,
+			     reg_mask) != PMIC_SUCCESS) {
+				rc = PMIC_ERROR;
+			} else {
+				pr_debug("STDAC clock set\n");
+				rc = PMIC_SUCCESS;
+				stDAC.clockIn = clockIn;
+				stDAC.clockFreq = clockFreq;
+				stDAC.samplingRate = samplingRate;
+				stDAC.invert = invert;
+			}
+
+		}
+
+	} else {
+		rc = PMIC_PARAMETER_ERROR;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the Stereo DAC clock source and operating characteristics.
+ *
+ * Get the current Stereo DAC clock source and operating characteristics.
+ *
+ * @param  handle          Device handle from pmic_audio_open() call.
+ * @param  clockIn         The clock signal source.
+ * @param  clockFreq       The clock signal frequency.
+ * @param  samplingRate    The audio data sampling rate.
+ * @param  invert          Inversion of the frame sync and/or
+ *                         bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_clock(const PMIC_AUDIO_HANDLE handle,
+				       PMIC_AUDIO_CLOCK_IN_SOURCE *
+				       const clockIn,
+				       PMIC_AUDIO_STDAC_SAMPLING_RATE *
+				       const samplingRate,
+				       PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *
+				       const clockFreq,
+				       PMIC_AUDIO_CLOCK_INVERT * const invert)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+	    (stDAC.handleState == HANDLE_IN_USE) &&
+	    (clockIn != (PMIC_AUDIO_CLOCK_IN_SOURCE *) NULL) &&
+	    (samplingRate != (PMIC_AUDIO_STDAC_SAMPLING_RATE *) NULL) &&
+	    (clockFreq != (PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *) NULL) &&
+	    (invert != (PMIC_AUDIO_CLOCK_INVERT *) NULL)) {
+		*clockIn = stDAC.clockIn;
+		*samplingRate = stDAC.samplingRate;
+		*clockFreq = stDAC.clockFreq;
+		*invert = stDAC.invert;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the Stereo DAC primary audio channel timeslot.
+ *
+ * Set the Stereo DAC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param	timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+					       const PMIC_AUDIO_STDAC_TIMESLOTS
+					       timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regSSI_NETWORK, STDCRXSLOT, 3);
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if ((timeslot == USE_TS0_TS1) || (timeslot == USE_TS2_TS3)
+		    || (timeslot == USE_TS4_TS5) || (timeslot == USE_TS6_TS7)) {
+			if (pmic_write_reg
+			    (REG_AUDIO_SSI_NETWORK, timeslot,
+			     reg_mask) != PMIC_SUCCESS) {
+				rc = PMIC_ERROR;
+			} else {
+				pr_debug("STDAC primary timeslot set\n");
+				stDAC.timeslot = timeslot;
+				rc = PMIC_SUCCESS;
+			}
+
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+					       PMIC_AUDIO_STDAC_TIMESLOTS *
+					       const timeslot)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+	    (stDAC.handleState == HANDLE_IN_USE) &&
+	    (timeslot != (PMIC_AUDIO_STDAC_TIMESLOTS *) NULL)) {
+		*timeslot = stDAC.timeslot;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set/Enable the Stereo DAC options.
+ *
+ * Set or enable various Stereo DAC options. The available options include
+ * resetting the digital filter and enabling the bus master clock outputs.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ * @param   config          The Stereo DAC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_set_config(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_STDAC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if (config & STDAC_MASTER_CLOCK_OUTPUTS) {
+			reg_write |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+			reg_mask |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+		}
+
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			stDAC.config |= config;
+			pr_debug("STDAC config set\n");
+
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Clear/Disable the Stereo DAC options.
+ *
+ * Clear or disable various Stereo DAC options.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       config          The Stereo DAC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_clear_config(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_STDAC_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+
+		if (config & STDAC_MASTER_CLOCK_OUTPUTS)
+			reg_mask |= SET_BITS(regST_DAC, STDCCLKEN, 1);
+
+
+		if (reg_mask != 0) {
+			rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				stDAC.config &= ~config;
+
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current Stereo DAC options.
+ *
+ * Get the current Stereo DAC options.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	config          The current set of Stereo DAC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_config(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_STDAC_CONFIG * const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == stDAC.handle) &&
+	    (stDAC.handleState == HANDLE_IN_USE) &&
+	    (config != (PMIC_AUDIO_STDAC_CONFIG *) NULL)) {
+		*config = stDAC.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * Audio input section configuration.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Input Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio
+ * input hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set/Enable the audio input section options.
+ *
+ * Set or enable various audio input section options. The only available
+ * option right now is to enable the automatic disabling of the microphone
+ * input amplifiers when a microphone/headset is inserted or removed.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	config          The audio input section options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_input_set_config(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_INPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+/*!
+ * @brief Clear/Disable the audio input section options.
+ *
+ * Clear or disable various audio input section options.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	config          The audio input section options to be
+ *                              cleared/disabled.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_input_clear_config(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_INPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+
+}
+
+/*!
+ * @brief Get the current audio input section options.
+ *
+ * Get the current audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of audio input section options.
+ * NOT SUPPORTED BY MC13783
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_input_get_config(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_INPUT_CONFIG * const config)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * Audio recording using the Voice CODEC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Recording Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio recording.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the microphone inputs to be used for Voice CODEC recording.
+ *
+ * Select left (mc13783-only) and right microphone inputs for Voice CODEC
+ * recording. It is possible to disable or not use a particular microphone
+ * input channel by specifying NO_MIC as a parameter.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       leftChannel     Select the left microphone input channel.
+ * @param       rightChannel    Select the right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input ports
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be successfully enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic(const PMIC_AUDIO_HANDLE handle,
+				      const PMIC_AUDIO_INPUT_PORT leftChannel,
+				      const PMIC_AUDIO_INPUT_PORT rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (!((leftChannel == NO_MIC) || (leftChannel == MIC1_LEFT))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else if (!((rightChannel == NO_MIC)
+			     || (rightChannel == MIC1_RIGHT_MIC_MONO)
+			     || (rightChannel == TXIN_EXT)
+			     || (rightChannel == MIC2_AUX))) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else {
+			if (leftChannel == NO_MIC) {
+			} else {	/* Left channel MIC enable */
+				reg_mask = SET_BITS(regAUDIO_TX, AMC1LEN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1);
+				reg_write = SET_BITS(regAUDIO_TX, AMC1LEN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0);
+			}
+			/*For right channel enable one and clear the other two as well as RXINREC */
+			if (rightChannel == NO_MIC) {
+			} else if (rightChannel == MIC1_RIGHT_MIC_MONO) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 0) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 0);
+			} else if (rightChannel == MIC2_AUX) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 0) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 0);
+			} else {	/* TX line in */
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC1REN, 1) |
+					SET_BITS(regAUDIO_TX, RXINREC, 1) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 1) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+				reg_write |= SET_BITS(regAUDIO_TX, AMC1REN, 0) |
+					SET_BITS(regAUDIO_TX, RXINREC, 0) |
+					SET_BITS(regAUDIO_TX, AMC2EN, 0) |
+					SET_BITS(regAUDIO_TX, ATXINEN, 1);
+			}
+
+			if (reg_mask == 0) {
+				rc = PMIC_PARAMETER_ERROR;
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						    reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug
+					    ("MIC inputs configured successfully\n");
+					vCodec.leftChannelMic.mic = leftChannel;
+					vCodec.rightChannelMic.mic =
+					    rightChannel;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current microphone inputs being used for Voice CODEC
+ *        recording.
+ *
+ * Get the left (mc13783-only) and right microphone inputs currently being
+ * used for Voice CODEC recording.
+ *
+ * @param	handle          Device handle from pmic_audio_open() call.
+ * @param	leftChannel    The left microphone input channel.
+ * @param	rightChannel    The right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic(const PMIC_AUDIO_HANDLE handle,
+				      PMIC_AUDIO_INPUT_PORT * const leftChannel,
+				      PMIC_AUDIO_INPUT_PORT *
+				      const rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (leftChannel != (PMIC_AUDIO_INPUT_PORT *) NULL) &&
+	    (rightChannel != (PMIC_AUDIO_INPUT_PORT *) NULL)) {
+		*leftChannel = vCodec.leftChannelMic.mic;
+		*rightChannel = vCodec.rightChannelMic.mic;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+	return rc;
+}
+
+/*!
+ * @brief Enable/disable the microphone input.
+ *
+ * This function enables/disables the current microphone input channel. The
+ * input amplifier is automatically turned off when the microphone input is
+ * disabled.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param       leftChannel     The left microphone input channel state.
+ * @param       rightChannel    the right microphone input channel state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input states
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+					     const PMIC_AUDIO_INPUT_MIC_STATE
+					     leftChannel,
+					     const PMIC_AUDIO_INPUT_MIC_STATE
+					     rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+	unsigned int curr_left = 0;
+	unsigned int curr_right = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		curr_left = vCodec.leftChannelMic.mic;
+		curr_right = vCodec.rightChannelMic.mic;
+		if ((curr_left == NO_MIC) && (curr_right == NO_MIC)) {
+			rc = PMIC_PARAMETER_ERROR;
+		} else {
+			if (curr_left == MIC1_LEFT) {
+				if ((leftChannel == MICROPHONE_ON) &&
+				    (vCodec.leftChannelMic.micOnOff ==
+				     MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1LEN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1LEN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC, 0);
+
+				} else if ((leftChannel == MICROPHONE_OFF) &&
+					   (vCodec.leftChannelMic.micOnOff ==
+					    MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1LEN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1LEN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC, 0);
+
+				} else {
+					/* Both are in same state . Nothing to be done */
+				}
+
+			}
+			if (curr_right == MIC1_RIGHT_MIC_MONO) {
+				if ((rightChannel == MICROPHONE_ON) &&
+				    (vCodec.leftChannelMic.micOnOff ==
+				     MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 0);
+				} else if ((rightChannel == MICROPHONE_OFF)
+					   && (vCodec.leftChannelMic.micOnOff ==
+					       MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 0);
+				} else {
+					/* Both are in same state . Nothing to be done */
+				}
+			} else if (curr_right == MIC2_AUX) {
+				if ((rightChannel == MICROPHONE_ON)
+				    && (vCodec.leftChannelMic.micOnOff ==
+					MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 0);
+				} else if ((rightChannel == MICROPHONE_OFF)
+					   && (vCodec.leftChannelMic.micOnOff ==
+					       MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 0);
+				} else {
+					/* Both are in same state . Nothing to be done */
+				}
+			} else if (curr_right == TXIN_EXT) {
+				if ((rightChannel == MICROPHONE_ON)
+				    && (vCodec.leftChannelMic.micOnOff ==
+					MICROPHONE_OFF)) {
+					/* Enable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+				} else if ((rightChannel == MICROPHONE_OFF)
+					   && (vCodec.leftChannelMic.micOnOff ==
+					       MICROPHONE_ON)) {
+					/* Disable the microphone */
+					reg_mask |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   1) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     1) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 1);
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1REN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   RXINREC,
+								   0) |
+					    SET_BITS(regAUDIO_TX, AMC2EN,
+						     0) | SET_BITS(regAUDIO_TX,
+								   ATXINEN, 0);
+				} else {
+					/* Both are in same state . Nothing to be done */
+				}
+			}
+			if (reg_mask == 0) {
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						    reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug
+						("MIC states configured successfully\n");
+					vCodec.leftChannelMic.micOnOff =
+						leftChannel;
+					vCodec.rightChannelMic.micOnOff =
+						rightChannel;
+				}
+			}
+		}
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Return the current state of the microphone inputs.
+ *
+ * This function returns the current state (on/off) of the microphone
+ * input channels.
+ *
+ * @param       handle          Device handle from pmic_audio_open() call.
+ * @param	leftChannel     The current left microphone input channel
+ *                              state.
+ * @param	rightChannel    the current right microphone input channel
+ *                              state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channel states
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channel states
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+					     PMIC_AUDIO_INPUT_MIC_STATE *
+					     const leftChannel,
+					     PMIC_AUDIO_INPUT_MIC_STATE *
+					     const rightChannel)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (leftChannel != (PMIC_AUDIO_INPUT_MIC_STATE *) NULL) &&
+	    (rightChannel != (PMIC_AUDIO_INPUT_MIC_STATE *) NULL)) {
+		*leftChannel = vCodec.leftChannelMic.micOnOff;
+		*rightChannel = vCodec.rightChannelMic.micOnOff;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the microphone input amplifier mode and gain level.
+ *
+ * This function sets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param       handle           Device handle from pmic_audio_open() call.
+ * @param       leftChannelMode  The left microphone input amplifier mode.
+ * @param       leftChannelGain  The left microphone input amplifier gain level.
+ * @param       rightChannelMode The right microphone input amplifier mode.
+ * @param       rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifiers were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input amplifier
+ *                                   modes or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifiers could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_record_gain(const PMIC_AUDIO_HANDLE handle,
+					      const PMIC_AUDIO_MIC_AMP_MODE
+					      leftChannelMode,
+					      const PMIC_AUDIO_MIC_GAIN
+					      leftChannelGain,
+					      const PMIC_AUDIO_MIC_AMP_MODE
+					      rightChannelMode,
+					      const PMIC_AUDIO_MIC_GAIN
+					      rightChannelGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (!(((leftChannelGain >= MIC_GAIN_MINUS_8DB)
+		       && (leftChannelGain <= MIC_GAIN_PLUS_23DB))
+		      && ((rightChannelGain >= MIC_GAIN_MINUS_8DB)
+			  && (rightChannelGain <= MIC_GAIN_PLUS_23DB)))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("VCODEC set record gain - wrong gain value\n");
+		} else if (((leftChannelMode != AMP_OFF)
+			    && (leftChannelMode != VOLTAGE_TO_VOLTAGE)
+			    && (leftChannelMode != CURRENT_TO_VOLTAGE))
+			   || ((rightChannelMode != VOLTAGE_TO_VOLTAGE)
+			       && (rightChannelMode != CURRENT_TO_VOLTAGE)
+			       && (rightChannelMode != AMP_OFF))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("VCODEC set record gain - wrong amp mode\n");
+		} else {
+			if (vCodec.leftChannelMic.mic == MIC1_LEFT) {
+				reg_mask = SET_BITS(regAUDIO_TX, AMC1LITOV, 1) |
+				    SET_BITS(regAUDIO_TX, PGATXL, 31);
+				if (leftChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write =
+					    SET_BITS(regAUDIO_TX, AMC1LITOV, 0);
+				} else {
+					reg_write =
+					    SET_BITS(regAUDIO_TX, AMC1LITOV, 1);
+				}
+				reg_write |=
+				    SET_BITS(regAUDIO_TX, PGATXL,
+					     leftChannelGain);
+			}
+			if (vCodec.rightChannelMic.mic == MIC1_RIGHT_MIC_MONO) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_TX, AMC1RITOV,
+					     1) | SET_BITS(regAUDIO_TX, PGATXR,
+							   31);
+				if (rightChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1RITOV, 0);
+				} else {
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC1RITOV, 1);
+				}
+				reg_write |=
+				    SET_BITS(regAUDIO_TX, PGATXR,
+					     rightChannelGain);
+			} else if (vCodec.rightChannelMic.mic == MIC2_AUX) {
+				reg_mask |= SET_BITS(regAUDIO_TX, AMC2ITOV, 1);
+				reg_mask |= SET_BITS(regAUDIO_TX, PGATXR, 31);
+				if (rightChannelMode == VOLTAGE_TO_VOLTAGE) {
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC2ITOV, 0);
+				} else {
+					reg_write |=
+					    SET_BITS(regAUDIO_TX, AMC2ITOV, 1);
+				}
+				reg_write |=
+				    SET_BITS(regAUDIO_TX, PGATXR,
+					     rightChannelGain);
+			} else if (vCodec.rightChannelMic.mic == TXIN_EXT) {
+				reg_mask |= SET_BITS(regAUDIO_TX, PGATXR, 31);
+				/* No current to voltage option for TX IN amplifier */
+				reg_write |=
+				    SET_BITS(regAUDIO_TX, PGATXR,
+					     rightChannelGain);
+			}
+
+			if (reg_mask == 0) {
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						    reg_write, reg_mask);
+				reg_write =
+					SET_BITS(regAUDIO_TX, PGATXL,
+						 leftChannelGain);
+				reg_mask = SET_BITS(regAUDIO_TX, PGATXL, 31);
+				rc = pmic_write_reg(REG_AUDIO_TX,
+						    reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("MIC amp mode and gain set\n");
+					vCodec.leftChannelMic.ampMode =
+						leftChannelMode;
+					vCodec.leftChannelMic.gain =
+						leftChannelGain;
+					vCodec.rightChannelMic.ampMode =
+						rightChannelMode;
+					vCodec.rightChannelMic.gain =
+						rightChannelGain;
+
+				}
+			}
+		}
+	}
+
+	/* Exit critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current microphone input amplifier mode and gain level.
+ *
+ * This function gets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param	handle           Device handle from pmic_audio_open() call.
+ * @param	leftChannelMode  The left microphone input amplifier mode.
+ * @param	leftChannelGain  The left microphone input amplifier gain level.
+ * @param	rightChannelMode The right microphone input amplifier mode.
+ * @param       rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifier modes
+ *                                   and gain levels were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifier modes
+ *                                   and gain levels could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_record_gain(const PMIC_AUDIO_HANDLE handle,
+					      PMIC_AUDIO_MIC_AMP_MODE *
+					      const leftChannelMode,
+					      PMIC_AUDIO_MIC_GAIN *
+					      const leftChannelGain,
+					      PMIC_AUDIO_MIC_AMP_MODE *
+					      const rightChannelMode,
+					      PMIC_AUDIO_MIC_GAIN *
+					      const rightChannelGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == vCodec.handle) &&
+	    (vCodec.handleState == HANDLE_IN_USE) &&
+	    (leftChannelMode != (PMIC_AUDIO_MIC_AMP_MODE *) NULL) &&
+	    (leftChannelGain != (PMIC_AUDIO_MIC_GAIN *) NULL) &&
+	    (rightChannelMode != (PMIC_AUDIO_MIC_AMP_MODE *) NULL) &&
+	    (rightChannelGain != (PMIC_AUDIO_MIC_GAIN *) NULL)) {
+		*leftChannelMode = vCodec.leftChannelMic.ampMode;
+		*leftChannelGain = vCodec.leftChannelMic.gain;
+		*rightChannelMode = vCodec.rightChannelMic.ampMode;
+		*rightChannelGain = vCodec.rightChannelMic.gain;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Enable a microphone bias circuit.
+ *
+ * This function enables one of the available microphone bias circuits.
+ *
+ * @param       handle           Device handle from pmic_audio_open() call.
+ * @param       biasCircuit      The microphone bias circuit to be enabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_micbias(const PMIC_AUDIO_HANDLE handle,
+					     const PMIC_AUDIO_MIC_BIAS
+					     biasCircuit)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (biasCircuit & MIC_BIAS1) {
+			reg_write = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+			reg_mask = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+		}
+		if (biasCircuit & MIC_BIAS2) {
+			reg_write |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+			reg_mask |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+		}
+		if (reg_mask != 0)
+			rc = pmic_write_reg(REG_AUDIO_TX, reg_write, reg_mask);
+
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Disable a microphone bias circuit.
+ *
+ * This function disables one of the available microphone bias circuits.
+ *
+ * @param      handle           Device handle from pmic_audio_open() call.
+ * @param      biasCircuit      The microphone bias circuit to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_micbias(const PMIC_AUDIO_HANDLE handle,
+					      const PMIC_AUDIO_MIC_BIAS
+					      biasCircuit)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (biasCircuit & MIC_BIAS1)
+			reg_mask = SET_BITS(regAUDIO_TX, MC1BEN, 1);
+
+
+		if (biasCircuit & MIC_BIAS2)
+			reg_mask |= SET_BITS(regAUDIO_TX, MC2BEN, 1);
+
+
+		if (reg_mask != 0)
+			rc = pmic_write_reg(REG_AUDIO_TX, reg_write, reg_mask);
+
+	}
+
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Playback Using the Voice CODEC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Playback Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Voice CODEC mixer.
+ *
+ * This function configures and enables the Voice CODEC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ * @param       rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param       gainIn              The secondary audio channel gain level.
+ * @param       gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_VCODEC_TIMESLOT
+					   rxSecondaryTimeslot,
+					   const PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+					   gainIn,
+					   const PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+					   gainOut)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		if (!((rxSecondaryTimeslot >= USE_TS0)
+		      && (rxSecondaryTimeslot <= USE_TS3))) {
+			pr_debug
+			    ("VCODEC enable mixer - wrong sec rx timeslot\n");
+		} else if (!((gainIn >= VCODEC_NO_MIX)
+			     && (gainIn <= VCODEC_MIX_IN_MINUS_12DB))) {
+			pr_debug("VCODEC enable mixer - wrong mix in gain\n");
+
+		} else if (!((gainOut >= VCODEC_MIX_OUT_0DB)
+			     && (gainOut <= VCODEC_MIX_OUT_MINUS_6DB))) {
+			pr_debug("VCODEC enable mixer - wrong mix out gain\n");
+		} else {
+
+			reg_mask = SET_BITS(regSSI_NETWORK, CDCRXSECSLOT, 3) |
+			    SET_BITS(regSSI_NETWORK, CDCRXSECGAIN, 3) |
+			    SET_BITS(regSSI_NETWORK, CDCSUMGAIN, 1);
+			reg_write =
+			    SET_BITS(regSSI_NETWORK, CDCRXSECSLOT,
+				     rxSecondaryTimeslot) |
+			    SET_BITS(regSSI_NETWORK, CDCRXSECGAIN,
+				     gainIn) | SET_BITS(regSSI_NETWORK,
+							CDCSUMGAIN, gainOut);
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					    reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Vcodec mixer enabled\n");
+
+		}
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Disable the Voice CODEC mixer.
+ *
+ * This function disables the Voice CODEC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask;
+
+	if ((handle == vCodec.handle) && (vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regSSI_NETWORK, CDCRXSECGAIN, 1);
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+				    VCODEC_NO_MIX, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			pr_debug("Vcodec mixer disabled\n");
+
+
+	}
+
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Playback Using the Stereo DAC.
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Playback Using the Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo DAC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Stereo DAC mixer.
+ *
+ * This function configures and enables the Stereo DAC mixer.
+ *
+ * @param      handle              Device handle from pmic_audio_open() call.
+ * @param      rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param      gainIn              The secondary audio channel gain level.
+ * @param      gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_STDAC_TIMESLOTS
+					  rxSecondaryTimeslot,
+					  const PMIC_AUDIO_STDAC_MIX_IN_GAIN
+					  gainIn,
+					  const PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+					  gainOut)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		if (!((rxSecondaryTimeslot >= USE_TS0_TS1)
+		      && (rxSecondaryTimeslot <= USE_TS6_TS7))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong sec timeslot\n");
+		} else if (!((gainIn >= STDAC_NO_MIX)
+			     && (gainIn <= STDAC_MIX_IN_MINUS_12DB))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong mix in gain\n");
+		} else if (!((gainOut >= STDAC_MIX_OUT_0DB)
+			     && (gainOut <= STDAC_MIX_OUT_MINUS_6DB))) {
+			rc = PMIC_PARAMETER_ERROR;
+			pr_debug("STDAC enable mixer - wrong mix out gain\n");
+		} else {
+
+			reg_mask = SET_BITS(regSSI_NETWORK, STDCRXSECSLOT, 3) |
+			    SET_BITS(regSSI_NETWORK, STDCRXSECGAIN, 3) |
+			    SET_BITS(regSSI_NETWORK, STDCSUMGAIN, 1);
+			reg_write =
+			    SET_BITS(regSSI_NETWORK, STDCRXSECSLOT,
+				     rxSecondaryTimeslot) |
+			    SET_BITS(regSSI_NETWORK, STDCRXSECGAIN,
+				     gainIn) | SET_BITS(regSSI_NETWORK,
+							STDCSUMGAIN, gainOut);
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					    reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS)
+				pr_debug("STDAC mixer enabled\n");
+
+		}
+
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Disable the Stereo DAC mixer.
+ *
+ * This function disables the Stereo DAC mixer.
+ *
+ * @param       handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask =
+	    SET_BITS(regSSI_NETWORK, STDCRXSECGAIN, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE))
+		rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK, reg_write, reg_mask);
+
+
+	return rc;
+}
+
+/*@}*/
+
+/*************************************************************************
+ * Audio Output Control
+ *************************************************************************
+ */
+
+/*!
+ * @name Audio Output Section Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio output
+ * section to support playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the audio output ports.
+ *
+ * This function selects the audio output ports to be used. This also enables
+ * the appropriate output amplifiers.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports to be used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   acquired.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   acquired.
+ */
+PMIC_STATUS pmic_audio_output_set_port(const PMIC_AUDIO_HANDLE handle,
+				       const PMIC_AUDIO_OUTPUT_PORT port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((port == MONO_ALERT) || (port == MONO_EXTOUT)) {
+		rc = PMIC_NOT_SUPPORTED;
+	} else {
+		if (((handle == stDAC.handle)
+		     && (stDAC.handleState == HANDLE_IN_USE))
+		    || ((handle == extStereoIn.handle)
+			&& (extStereoIn.handleState == HANDLE_IN_USE))
+		    || ((handle == vCodec.handle)
+			&& (vCodec.handleState == HANDLE_IN_USE)
+			&& (audioOutput.vCodecOut == VCODEC_MIXER_OUT))) {
+			/* Stereo signal and MIXER source needs to be routed to the port
+			   / Avoid Codec direct out */
+
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPREF, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ALSPEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ALSPREF,
+							   1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, AHSLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   AHSSEL, 1);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1) |
+				    SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, AHSREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   AHSSEL, 1);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+			}
+			if (port & STEREO_LEFT_LOW_POWER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+
+				reg_write |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+			}
+		} else if ((handle == vCodec.handle)
+			   && (vCodec.handleState == HANDLE_IN_USE)
+			   && (audioOutput.vCodecOut = VCODEC_DIRECT_OUT)) {
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ASPSEL, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ASPSEL, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPREF, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ALSPEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ALSPREF,
+							   1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPSEL, 0);
+			}
+
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, AHSLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   AHSSEL, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1) |
+				    SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, AHSREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   AHSSEL, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN,
+					     1) | SET_BITS(regAUDIO_RX_0,
+							   ARXOUTSEL, 0);
+			}
+			if (port & MONO_CDCOUT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+			}
+		}
+
+		if (reg_mask == 0) {
+
+		} else {
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("output ports  enabled\n");
+				audioOutput.outputPort = port;
+
+			}
+		}
+	}
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Deselect/disable the audio output ports.
+ *
+ * This function disables the audio output ports that were previously enabled
+ * by calling pmic_audio_output_set_port().
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_output_clear_port(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_OUTPUT_PORT port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((port == MONO_ALERT) || (port == MONO_EXTOUT)) {
+		rc = PMIC_NOT_SUPPORTED;
+	} else {
+		if (((handle == stDAC.handle)
+		     && (stDAC.handleState == HANDLE_IN_USE))
+		    || ((handle == extStereoIn.handle)
+			&& (extStereoIn.handleState == HANDLE_IN_USE))
+		    || ((handle == vCodec.handle)
+			&& (vCodec.handleState == HANDLE_IN_USE)
+			&& (audioOutput.vCodecOut = VCODEC_MIXER_OUT))) {
+			/* Stereo signal and MIXER source needs to be routed to the port /
+			   Avoid Codec direct out */
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ALSPEN,
+					     0) | SET_BITS(regAUDIO_RX_0,
+							   ALSPREF, 0);
+
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN, 0);
+			}
+			if (port & STEREO_LEFT_LOW_POWER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, LSPLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, LSPLEN, 0);
+			}
+		} else if ((handle == vCodec.handle)
+			   && (vCodec.handleState == HANDLE_IN_USE)
+			   && (audioOutput.vCodecOut = VCODEC_DIRECT_OUT)) {
+			if (port & MONO_SPEAKER) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ASPEN, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ASPEN, 0);
+			}
+			if (port & MONO_LOUDSPEAKER) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, ALSPEN, 1) |
+				    SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ALSPEN,
+					     0) | SET_BITS(regAUDIO_RX_0,
+							   ALSPREF, 0);
+			}
+			if (port & STEREO_HEADSET_LEFT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 0);
+			}
+			if (port & STEREO_HEADSET_RIGHT) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+				reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 0);
+			}
+			if (port & STEREO_OUT_LEFT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTLEN, 0);
+			}
+			if (port & STEREO_OUT_RIGHT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, ARXOUTREN, 0);
+			}
+			if (port & MONO_CDCOUT) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, CDCOUTEN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, CDCOUTEN, 0);
+			}
+		}
+#ifdef CONFIG_HEADSET_DETECT_ENABLE
+
+		if (port & STEREO_HEADSET_LEFT) {
+			reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+			reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 0);
+		}
+		if (port & STEREO_HEADSET_RIGHT) {
+			reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+			reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 0);
+		}
+#endif
+
+		if (reg_mask == 0) {
+
+		} else {
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					    reg_write, reg_mask);
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("output ports disabled\n");
+				audioOutput.outputPort &= ~port;
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current audio output ports.
+ *
+ * This function retrieves the audio output ports that are currently being
+ * used.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   port                The audio output ports currently being used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_port(const PMIC_AUDIO_HANDLE handle,
+				       PMIC_AUDIO_OUTPUT_PORT * const port)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+	      (stDAC.handleState == HANDLE_IN_USE)) ||
+	     ((handle == vCodec.handle) &&
+	      (vCodec.handleState == HANDLE_IN_USE)) ||
+	     ((handle == extStereoIn.handle) &&
+	      (extStereoIn.handleState == HANDLE_IN_USE))) &&
+	    (port != (PMIC_AUDIO_OUTPUT_PORT *) NULL)) {
+		*port = audioOutput.outputPort;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the gain level for the external stereo inputs.
+ *
+ * This function sets the gain levels for the external stereo inputs.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The external stereo input gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+						 const PMIC_AUDIO_STEREO_IN_GAIN
+						 gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1) |
+	    SET_BITS(regAUDIO_RX_1, ARXIN, 1);
+	unsigned int reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	/* The ARX amplifier for stereo is also enabled over here */
+
+	if ((gain == STEREO_IN_GAIN_0DB) || (gain == STEREO_IN_GAIN_PLUS_18DB)) {
+		if ((handle == extStereoIn.handle) &&
+		    (extStereoIn.handleState == HANDLE_IN_USE)) {
+
+			if (gain == STEREO_IN_GAIN_0DB)
+				reg_write |= SET_BITS(regAUDIO_RX_1, ARXIN, 1);
+			else
+				reg_write |= SET_BITS(regAUDIO_RX_1, ARXIN, 0);
+
+
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Ext stereo gain set\n");
+				extStereoIn.inputGain = gain;
+
+			}
+
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current gain level for the external stereo inputs.
+ *
+ * This function retrieves the current gain levels for the external stereo
+ * inputs.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current external stereo input gain
+ *                                  level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+						 PMIC_AUDIO_STEREO_IN_GAIN *
+						 const gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == extStereoIn.handle) &&
+	    (extStereoIn.handleState == HANDLE_IN_USE) &&
+	    (gain != (PMIC_AUDIO_STEREO_IN_GAIN *) NULL)) {
+		*gain = extStereoIn.inputGain;
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Set the output PGA gain level.
+ *
+ * This function sets the audio output PGA gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_pgaGain(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_OUTPUT_PGA_GAIN gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
+	unsigned int reg_gain;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (!((gain >= OUTPGA_GAIN_MINUS_33DB)
+	      && (gain <= OUTPGA_GAIN_PLUS_6DB))) {
+		rc = PMIC_NOT_SUPPORTED;
+		pr_debug("output set PGA gain - wrong gain value\n");
+	} else {
+		reg_gain = gain + 2;
+		if ((handle == extStereoIn.handle) &&
+		    (extStereoIn.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, ARXIN, 15) |
+			    SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+			reg_write = SET_BITS(regAUDIO_RX_1, ARXIN, reg_gain) |
+			    SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		} else if ((handle == vCodec.handle) &&
+			   (vCodec.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, PGARX, 15);
+			reg_write = SET_BITS(regAUDIO_RX_1, PGARX, reg_gain);
+		} else if ((handle == stDAC.handle) &&
+			   (stDAC.handleState == HANDLE_IN_USE)) {
+			reg_mask = SET_BITS(regAUDIO_RX_1, PGAST, 15);
+			reg_write = SET_BITS(regAUDIO_RX_1, PGAST, reg_gain);
+		}
+
+		if (reg_mask == 0) {
+
+		} else {
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Output PGA gains set\n");
+
+				if (handle == stDAC.handle) {
+					audioOutput.stDacoutputPGAGain = gain;
+				} else if (handle == vCodec.handle) {
+					audioOutput.vCodecoutputPGAGain = gain;
+				} else {
+					audioOutput.extStereooutputPGAGain =
+						gain;
+				}
+			} else {
+				pr_debug
+					("Error writing PGA gains to register\n");
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the output PGA gain level.
+ *
+ * This function retrieves the current audio output PGA gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_pgaGain(const PMIC_AUDIO_HANDLE handle,
+					  PMIC_AUDIO_OUTPUT_PGA_GAIN *
+					  const gain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (gain != (PMIC_AUDIO_OUTPUT_PGA_GAIN *) NULL) {
+		if ((handle == extStereoIn.handle) &&
+		    (extStereoIn.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.extStereooutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == vCodec.handle) &&
+			   (vCodec.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.vCodecoutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else if ((handle == stDAC.handle) &&
+			   (stDAC.handleState == HANDLE_IN_USE)) {
+			*gain = audioOutput.stDacoutputPGAGain;
+			rc = PMIC_SUCCESS;
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	} else {
+		rc = PMIC_PARAMETER_ERROR;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Enable the output mixer.
+ *
+ * This function enables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask_mix = 0;
+	unsigned int reg_write_mix = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE))) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+	} else if ((handle == vCodec.handle) &&
+		   (vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		audioOutput.vCodecOut = VCODEC_MIXER_OUT;
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+	} else if ((handle == extStereoIn.handle) &&
+		   (extStereoIn.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+	}
+
+	if (reg_mask == 0) {
+
+	} else {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					    reg_write_mix, reg_mask_mix);
+			if (rc == PMIC_SUCCESS) {
+				pr_debug("Output PGA mixers enabled\n");
+				rc = PMIC_SUCCESS;
+			}
+
+		} else {
+			pr_debug("Error writing mixer enable to register\n");
+		}
+
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Disable the output mixer.
+ *
+ * This function disables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mixer(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	unsigned int reg_mask_mix = 0;
+	unsigned int reg_write_mix = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+	if (((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE))) {
+		/*reg_mask = SET_BITS(regAUDIO_RX_1, PGASTEN, 1);
+		   reg_write = SET_BITS(regAUDIO_RX_1, PGASTEN, 0); */
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDSTDC, 0);
+	} else if ((handle == vCodec.handle) &&
+		   (vCodec.handleState == HANDLE_IN_USE)) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, PGARXEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, PGARXEN, 0);
+		audioOutput.vCodecOut = VCODEC_DIRECT_OUT;
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDCDC, 0);
+	} else if ((handle == extStereoIn.handle) &&
+		   (extStereoIn.handleState == HANDLE_IN_USE)) {
+		/*reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		   reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 0); */
+
+		reg_mask_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write_mix = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+	}
+
+	if (reg_mask == 0) {
+
+	} else {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+
+			rc = pmic_write_reg(REG_AUDIO_RX_0,
+					    reg_write_mix, reg_mask_mix);
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Output PGA mixers disabled\n");
+
+		}
+	}
+	return rc;
+}
+
+/*!
+ * @brief Configure and enable the output balance amplifiers.
+ *
+ * This function configures and enables the output balance amplifiers.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   leftGain            The desired left channel gain level.
+ * @param   rightGain           The desired right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifiers were
+ *                                   successfully configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifiers could not
+ *                                   be reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_output_set_balance(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+					  leftGain,
+					  const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+					  rightGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask_ch = 0;
+	unsigned int reg_write_ch = 0;
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (!((leftGain >= BAL_GAIN_MINUS_21DB) && (leftGain <= BAL_GAIN_0DB))) {
+		rc = PMIC_PARAMETER_ERROR;
+	} else if (!((rightGain >= BAL_GAIN_MINUS_21DB)
+		     && (rightGain <= BAL_GAIN_0DB))) {
+		rc = PMIC_PARAMETER_ERROR;
+	} else {
+		if (((handle == stDAC.handle) &&
+		     (stDAC.handleState == HANDLE_IN_USE)) ||
+		    ((handle == vCodec.handle) &&
+		     (vCodec.handleState == HANDLE_IN_USE)) ||
+		    ((handle == extStereoIn.handle) &&
+		     (extStereoIn.handleState == HANDLE_IN_USE))) {
+			/* In mc13783 only one channel can be attenuated wrt the other.
+			 * It is not possible to specify attenuation for both
+			 * This function will return an error if both channels
+			 * are required to be attenuated
+			 * The BALLR bit is set/reset depending on whether leftGain
+			 * or rightGain is specified*/
+			if ((rightGain == BAL_GAIN_0DB)
+			    && (leftGain == BAL_GAIN_0DB)) {
+				/* Nothing to be done */
+			} else if ((rightGain != BAL_GAIN_0DB)
+				   && (leftGain == BAL_GAIN_0DB)) {
+				/* Attenuate right channel */
+				reg_mask = SET_BITS(regAUDIO_RX_1, BAL, 7);
+				reg_mask_ch = SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				reg_write =
+				    SET_BITS(regAUDIO_RX_1, BAL,
+					     (BAL_GAIN_0DB - rightGain));
+				/* The enum and the register values are reversed in order .. */
+				reg_write_ch =
+				    SET_BITS(regAUDIO_RX_1, BALLR, 0);
+				/* BALLR = 0 selects right channel for atten */
+			} else if ((rightGain == BAL_GAIN_0DB)
+				   && (leftGain != BAL_GAIN_0DB)) {
+				/* Attenuate left channel */
+
+				reg_mask = SET_BITS(regAUDIO_RX_1, BAL, 7);
+				reg_mask_ch = SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				reg_write =
+				    SET_BITS(regAUDIO_RX_1, BAL,
+					     (BAL_GAIN_0DB - leftGain));
+				reg_write_ch =
+				    SET_BITS(regAUDIO_RX_1, BALLR, 1);
+				/* BALLR = 1 selects left channel for atten */
+			} else {
+				rc = PMIC_PARAMETER_ERROR;
+			}
+
+			if ((reg_mask == 0) || (reg_mask_ch == 0)) {
+
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_RX_1,
+						    reg_write_ch, reg_mask_ch);
+
+				if (rc == PMIC_SUCCESS) {
+					rc = pmic_write_reg(REG_AUDIO_RX_1,
+							    reg_write,
+							    reg_mask);
+
+					if (rc == PMIC_SUCCESS) {
+						pr_debug
+							("Output balance attenuation set\n");
+						audioOutput.balanceLeftGain =
+							leftGain;
+						audioOutput.balanceRightGain =
+							rightGain;
+					}
+				}
+			}
+		}
+	}
+	return rc;
+}
+
+/*!
+ * @brief Get the current output balance amplifier gain levels.
+ *
+ * This function retrieves the current output balance amplifier gain levels.
+ *
+ * @param	handle              Device handle from pmic_audio_open() call.
+ * @param	leftGain            The current left channel gain level.
+ * @param	rightGain           The current right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifier gain levels
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifier gain levels
+ *                                   could be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_balance(const PMIC_AUDIO_HANDLE handle,
+					  PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+					  const leftGain,
+					  PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+					  const rightGain)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+	      (stDAC.handleState == HANDLE_IN_USE)) ||
+	     ((handle == vCodec.handle) &&
+	      (vCodec.handleState == HANDLE_IN_USE)) ||
+	     ((handle == extStereoIn.handle) &&
+	      (extStereoIn.handleState == HANDLE_IN_USE))) &&
+	    ((leftGain != (PMIC_AUDIO_OUTPUT_BALANCE_GAIN *) NULL) &&
+	     (rightGain != (PMIC_AUDIO_OUTPUT_BALANCE_GAIN *) NULL))) {
+		*leftGain = audioOutput.balanceLeftGain;
+		*rightGain = audioOutput.balanceRightGain;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Configure and enable the output mono adder.
+ *
+ * This function configures and enables the output mono adder.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   mode                The desired mono adder operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mono adder mode was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be reconfigured
+ *                                   or enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mono_adder(const PMIC_AUDIO_HANDLE handle,
+						const PMIC_AUDIO_MONO_ADDER_MODE
+						mode)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, MONO, 3);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if ((mode >= MONO_ADDER_OFF) && (mode <= STEREO_OPPOSITE_PHASE)) {
+		if (((handle == stDAC.handle) &&
+		     (stDAC.handleState == HANDLE_IN_USE)) ||
+		    ((handle == vCodec.handle) &&
+		     (vCodec.handleState == HANDLE_IN_USE)) ||
+		    ((handle == extStereoIn.handle) &&
+		     (extStereoIn.handleState == HANDLE_IN_USE))) {
+			if (mode == MONO_ADDER_OFF) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 0);
+			} else if (mode == MONO_ADD_LEFT_RIGHT) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 2);
+			} else if (mode == MONO_ADD_OPPOSITE_PHASE) {
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 3);
+			} else {	/* stereo opposite */
+
+				reg_write = SET_BITS(regAUDIO_RX_1, MONO, 1);
+			}
+
+			rc = pmic_write_reg(REG_AUDIO_RX_1,
+					    reg_write, reg_mask);
+
+			if (rc == PMIC_SUCCESS)
+				pr_debug("Output mono adder mode set\n");
+
+
+
+		} else {
+			rc = PMIC_PARAMETER_ERROR;
+		}
+	} else {
+		rc = PMIC_PARAMETER_ERROR;
+	}
+	return rc;
+}
+
+/*!
+ * @brief Disable the output mono adder.
+ *
+ * This function disables the output mono adder.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mono_adder(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_write = 0;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_1, MONO, 3);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	if (((handle == stDAC.handle) &&
+	     (stDAC.handleState == HANDLE_IN_USE)) ||
+	    ((handle == vCodec.handle) &&
+	     (vCodec.handleState == HANDLE_IN_USE)) ||
+	    ((handle == extStereoIn.handle) &&
+	     (extStereoIn.handleState == HANDLE_IN_USE))) {
+		rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Configure the mono adder output gain level.
+ *
+ * This function configures the mono adder output amplifier gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The desired output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_output_set_mono_adder_gain(const PMIC_AUDIO_HANDLE
+						  handle,
+						  const
+						  PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+						  gain)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+/*!
+ * @brief Get the current mono adder output gain level.
+ *
+ * This function retrieves the current mono adder output amplifier gain level.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   gain                The current output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_mono_adder_gain(const PMIC_AUDIO_HANDLE
+						  handle,
+						  PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+						  * const gain)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+	return rc;
+}
+
+/*!
+ * @brief Set various audio output section options.
+ *
+ * This function sets one or more audio output section configuration
+ * options. The currently supported options include whether to disable
+ * the non-inverting mono speaker output, enabling the loudspeaker common
+ * bias circuit, enabling detection of headset insertion/removal, and
+ * whether to automatically disable the headset amplifiers when a headset
+ * insertion/removal has been detected.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   config              The desired audio output section
+ *                                  configuration options to be set.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_config(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_OUTPUT_CONFIG config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (((handle == stDAC.handle) &&
+	     (stDAC.handleState == HANDLE_IN_USE)) ||
+	    ((handle == vCodec.handle) &&
+	     (vCodec.handleState == HANDLE_IN_USE)) ||
+	    ((handle == extStereoIn.handle) &&
+	     (extStereoIn.handleState == HANDLE_IN_USE))) {
+		if (config & MONO_SPEAKER_INVERT_OUT_ONLY) {
+			/* If this is one of the parameters */
+			rc = PMIC_NOT_SUPPORTED;
+		} else {
+			if (config & MONO_LOUDSPEAKER_COMMON_BIAS) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+			}
+			if (config & HEADSET_DETECT_ENABLE) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+			}
+			if (config & STEREO_HEADSET_AMP_AUTO_DISABLE) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+			}
+
+			if (reg_mask == 0) {
+				rc = PMIC_PARAMETER_ERROR;
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_RX_0,
+						    reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("Output config set\n");
+					audioOutput.config |= config;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Clear various audio output section options.
+ *
+ * This function clears one or more audio output section configuration
+ * options.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param   config              The desired audio output section
+ *                                  configuration options to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be cleared.
+ */
+PMIC_STATUS pmic_audio_output_clear_config(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_OUTPUT_CONFIG
+					   config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	/*unsigned int reg_write_RX = 0;
+	   unsigned int reg_mask_RX  = 0;
+	   unsigned int reg_write_TX = 0;
+	   unsigned int reg_mask_TX  = 0; */
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (((handle == stDAC.handle) &&
+	     (stDAC.handleState == HANDLE_IN_USE)) ||
+	    ((handle == vCodec.handle) &&
+	     (vCodec.handleState == HANDLE_IN_USE)) ||
+	    ((handle == extStereoIn.handle) &&
+	     (extStereoIn.handleState == HANDLE_IN_USE))) {
+		if (config & MONO_SPEAKER_INVERT_OUT_ONLY) {
+			/* If this is one of the parameters */
+			rc = PMIC_NOT_SUPPORTED;
+		} else {
+			if (config & MONO_LOUDSPEAKER_COMMON_BIAS) {
+				reg_mask = SET_BITS(regAUDIO_RX_0, ALSPREF, 1);
+				reg_write = SET_BITS(regAUDIO_RX_0, ALSPREF, 0);
+			}
+
+			if (config & HEADSET_DETECT_ENABLE) {
+				reg_mask |= SET_BITS(regAUDIO_RX_0, HSDETEN, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, HSDETEN, 0);
+			}
+
+			if (config & STEREO_HEADSET_AMP_AUTO_DISABLE) {
+				reg_mask |=
+				    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+				reg_write |=
+				    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 0);
+			}
+
+			if (reg_mask == 0) {
+				rc = PMIC_PARAMETER_ERROR;
+			} else {
+				rc = pmic_write_reg(REG_AUDIO_RX_0,
+						    reg_write, reg_mask);
+
+				if (rc == PMIC_SUCCESS) {
+					pr_debug("Output config cleared\n");
+					audioOutput.config &= ~config;
+
+				}
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Get the current audio output section options.
+ *
+ * This function retrieves the current audio output section configuration
+ * option settings.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ * @param  config              The current audio output section
+ *                                  configuration option settings.
+ *
+ * @retval      PMIC_SUCCESS         If the current configuration options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the current configuration options
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_config(const PMIC_AUDIO_HANDLE handle,
+					 PMIC_AUDIO_OUTPUT_CONFIG *
+					 const config)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Use a critical section to ensure a consistent hardware state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == stDAC.handle) &&
+	      (stDAC.handleState == HANDLE_IN_USE)) ||
+	     ((handle == vCodec.handle) &&
+	      (vCodec.handleState == HANDLE_IN_USE)) ||
+	     ((handle == extStereoIn.handle) &&
+	      (extStereoIn.handleState == HANDLE_IN_USE))) &&
+	    (config != (PMIC_AUDIO_OUTPUT_CONFIG *) NULL)) {
+		*config = audioOutput.config;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * @brief Enable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function enables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_phantom_ground()
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	rc = pmic_write_reg(REG_AUDIO_RX_0, 0, reg_mask);
+	if (rc == PMIC_SUCCESS)
+		pr_debug("Phantom ground enabled\n");
+
+
+	return rc;
+}
+
+/*!
+ * @brief Disable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function disables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_phantom_ground()
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	const unsigned int reg_mask = SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+
+	/* No critical section required here since we are not updating any
+	 * global data.
+	 */
+
+	rc = pmic_write_reg(REG_AUDIO_RX_0, 1, reg_mask);
+	if (rc == PMIC_SUCCESS)
+		pr_debug("Phantom ground disabled\n");
+
+
+	return rc;
+}
+
+/*@}*/
+
+/**************************************************************************
+ * Static functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name Audio Driver Internal Support Functions
+ * These non-exported internal functions are used to support the functionality
+ * of the exported audio APIs.
+ */
+/*@{*/
+
+/*!
+ * @brief Enables the 5.6V boost for the microphone bias 2 circuit.
+ *
+ * This function enables the switching regulator SW3 and configures it to
+ * provide the 5.6V boost that is required for driving the microphone bias 2
+ * circuit when using a 5-pole jack configuration (which is the case for the
+ * Sphinx board).
+ *
+ * @retval      PMIC_SUCCESS         The 5.6V boost was successfully enabled.
+ * @retval      PMIC_ERROR           Failed to enable the 5.6V boost.
+ */
+/*
+static PMIC_STATUS pmic_audio_mic_boost_enable(void)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+	return rc;
+}
+*/
+/*!
+ * @brief Disables the 5.6V boost for the microphone bias 2 circuit.
+ *
+ * This function disables the switching regulator SW3 to turn off the 5.6V
+ * boost for the microphone bias 2 circuit.
+ *
+ * @retval      PMIC_SUCCESS         The 5.6V boost was successfully disabled.
+ * @retval      PMIC_ERROR           Failed to disable the 5.6V boost.
+ */
+/*
+static PMIC_STATUS pmic_audio_mic_boost_disable(void)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+	return rc;
+}
+*/
+
+/*!
+ * @brief Free a device handle previously acquired by calling pmic_audio_open().
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * Note that we will shutdown/reset the Voice CODEC or Stereo DAC as well as
+ * any associated audio input/output components that are no longer required.
+ *
+ * Also note that this function should only be called with the mutex already
+ * acquired.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+static PMIC_STATUS pmic_audio_close_handle(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+
+	/* Match up the handle to the audio device and then close it. */
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the Stereo DAC hardware. The simplest way to
+		 * do this is to simply call pmic_audio_reset_device() which will
+		 * restore the ST_DAC register to it's initial power-on state.
+		 *
+		 * This will also shutdown the audio output section if no one
+		 * else is still using it.
+		 */
+		rc = pmic_audio_reset_device(stDAC.handle);
+
+		if (rc == PMIC_SUCCESS) {
+			stDAC.handle = AUDIO_HANDLE_NULL;
+			stDAC.handleState = HANDLE_FREE;
+		}
+	} else if ((handle == vCodec.handle) &&
+		   (vCodec.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the Voice CODEC and audio input hardware. The
+		 * simplest way to do this is to simply call pmic_audio_reset_device()
+		 * which will restore the AUD_CODEC register to it's initial
+		 * power-on state.
+		 *
+		 * This will also shutdown the audio output section if no one
+		 * else is still using it.
+		 */
+		rc = pmic_audio_reset_device(vCodec.handle);
+		if (rc == PMIC_SUCCESS) {
+			vCodec.handle = AUDIO_HANDLE_NULL;
+			vCodec.handleState = HANDLE_FREE;
+		}
+	} else if ((handle == extStereoIn.handle) &&
+		   (extStereoIn.handleState == HANDLE_IN_USE)) {
+
+		/* Call pmic_audio_reset_device() here to shutdown the audio output
+		 * section if no one else is still using it.
+		 */
+		rc = pmic_audio_reset_device(extStereoIn.handle);
+
+		if (rc == PMIC_SUCCESS) {
+			extStereoIn.handle = AUDIO_HANDLE_NULL;
+			extStereoIn.handleState = HANDLE_FREE;
+		}
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their initial power on state.
+ *
+ * This function can only be called if the mutex has already been acquired.
+ *
+ * @param   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+static PMIC_STATUS pmic_audio_reset_device(const PMIC_AUDIO_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_mask = 0;
+
+	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		/* Also shutdown the audio output section if nobody else is using it.
+		   if ((vCodec.handleState == HANDLE_FREE) &&
+		   (extStereoIn.handleState == HANDLE_FREE))
+		   {
+		   pmic_write_reg(REG_RX_AUD_AMPS, RESET_RX_AUD_AMPS,
+		   REG_FULLMASK);
+		   } */
+
+		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
+				    RESET_ST_DAC, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS) {
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					    RESET_SSI_NETWORK,
+					    REG_SSI_STDAC_MASK);
+			if (rc == PMIC_SUCCESS) {
+				/* Also reset the driver state information to match. Note that we
+				 * keep the device handle and event callback settings unchanged
+				 * since these don't affect the actual hardware and we rely on
+				 * the user to explicitly close the handle or deregister callbacks
+				 */
+				stDAC.busID = AUDIO_DATA_BUS_1;
+				stDAC.protocol = NORMAL_MSB_JUSTIFIED_MODE;
+				stDAC.protocol_set = false;
+				stDAC.masterSlave = BUS_MASTER_MODE;
+				stDAC.numSlots = USE_2_TIMESLOTS;
+				stDAC.clockIn = CLOCK_IN_CLIA;
+				stDAC.samplingRate = STDAC_RATE_44_1_KHZ;
+				stDAC.clockFreq = STDAC_CLI_13MHZ;
+				stDAC.invert = NO_INVERT;
+				stDAC.timeslot = USE_TS0_TS1;
+				stDAC.config = (PMIC_AUDIO_STDAC_CONFIG) 0;
+
+			}
+		}
+	} else if ((handle == vCodec.handle)
+		   && (vCodec.handleState == HANDLE_IN_USE)) {
+		/* Disable the audio input section when disabling the Voice CODEC. */
+		pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX, REG_FULLMASK);
+
+		rc = pmic_write_reg(REG_AUDIO_CODEC,
+				    RESET_AUD_CODEC, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS) {
+			rc = pmic_write_reg(REG_AUDIO_SSI_NETWORK,
+					    RESET_SSI_NETWORK,
+					    REG_SSI_VCODEC_MASK);
+			if (rc == PMIC_SUCCESS) {
+
+				/* Also reset the driver state information to match. Note that we
+				 * keep the device handle and event callback settings unchanged
+				 * since these don't affect the actual hardware and we rely on
+				 * the user to explicitly close the handle or deregister callbacks
+				 */
+				vCodec.busID = AUDIO_DATA_BUS_2;
+				vCodec.protocol = NETWORK_MODE;
+				vCodec.protocol_set = false;
+				vCodec.masterSlave = BUS_SLAVE_MODE;
+				vCodec.numSlots = USE_4_TIMESLOTS;
+				vCodec.clockIn = CLOCK_IN_CLIB;
+				vCodec.samplingRate = VCODEC_RATE_8_KHZ;
+				vCodec.clockFreq = VCODEC_CLI_13MHZ;
+				vCodec.invert = NO_INVERT;
+				vCodec.timeslot = USE_TS0;
+				vCodec.config =
+				    INPUT_HIGHPASS_FILTER |
+				    OUTPUT_HIGHPASS_FILTER;
+
+			}
+		}
+
+	} else if ((handle == extStereoIn.handle) &&
+		   (extStereoIn.handleState == HANDLE_IN_USE)) {
+		/* Disable the Ext stereo Amplifier and disable it as analog mixer input */
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		pmic_write_reg(REG_AUDIO_RX_1, 0, reg_mask);
+
+		reg_mask = SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		pmic_write_reg(REG_AUDIO_RX_0, 0, reg_mask);
+
+		/* We don't need to reset any other registers for this case. */
+		rc = PMIC_SUCCESS;
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief Deregister the callback function and event mask currently associated
+ *        with an audio device handle.
+ *
+ * This function deregisters any existing callback function and event mask for
+ * the given audio device handle. This is done by either calling the
+ * pmic_audio_clear_callback() API or by closing the device handle.
+ *
+ * Note that this function should only be called with the mutex already
+ * acquired. We will also acquire the spinlock here to prevent possible
+ * race conditions with the interrupt handler.
+ *
+ * @param[in]   callback            The current event callback function pointer.
+ * @param[in]   eventMask           The current audio event mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback function and event mask
+ *                                   were both successfully deregistered.
+ * @retval      PMIC_ERROR           If either the callback function or the
+ *                                   event mask was not successfully
+ *                                   deregistered.
+ */
+
+static PMIC_STATUS pmic_audio_deregister(void *callback,
+					 PMIC_AUDIO_EVENTS * const eventMask)
+{
+	unsigned long flags;
+	pmic_event_callback_t eventNotify;
+	PMIC_STATUS rc = PMIC_SUCCESS;
+
+	/* Deregister each of the PMIC events that we had previously
+	 * registered for by calling pmic_event_subscribe().
+	 */
+	if (*eventMask & (HEADSET_DETECTED)) {
+		/* We need to deregister for the A1 amplifier interrupt. */
+		eventNotify.func = callback;
+		eventNotify.param = (void *)(CORE_EVENT_HSDETI);
+		if (pmic_event_unsubscribe(EVENT_HSDETI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			*eventMask &= ~(HEADSET_DETECTED);
+			pr_debug("Deregistered for EVENT_HSDETI\n");
+		} else {
+			rc = PMIC_ERROR;
+		}
+	}
+
+	if (*eventMask & (HEADSET_STEREO)) {
+		/* We need to deregister for the A1 amplifier interrupt. */
+		eventNotify.func = callback;
+		eventNotify.param = (void *)(CORE_EVENT_HSLI);
+		if (pmic_event_unsubscribe(EVENT_HSLI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			*eventMask &= ~(HEADSET_STEREO);
+			pr_debug("Deregistered for EVENT_HSLI\n");
+		} else {
+			rc = PMIC_ERROR;
+		}
+	}
+	if (*eventMask & (HEADSET_THERMAL_SHUTDOWN)) {
+		/* We need to deregister for the A1 amplifier interrupt. */
+		eventNotify.func = callback;
+		eventNotify.param = (void *)(CORE_EVENT_ALSPTHI);
+		if (pmic_event_unsubscribe(EVENT_ALSPTHI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			*eventMask &= ~(HEADSET_THERMAL_SHUTDOWN);
+			pr_debug("Deregistered for EVENT_ALSPTHI\n");
+		} else {
+			rc = PMIC_ERROR;
+		}
+	}
+	if (*eventMask & (HEADSET_SHORT_CIRCUIT)) {
+		/* We need to deregister for the A1 amplifier interrupt. */
+		eventNotify.func = callback;
+		eventNotify.param = (void *)(CORE_EVENT_AHSSHORTI);
+		if (pmic_event_unsubscribe(EVENT_AHSSHORTI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			*eventMask &= ~(HEADSET_SHORT_CIRCUIT);
+			pr_debug("Deregistered for EVENT_AHSSHORTI\n");
+		} else {
+			rc = PMIC_ERROR;
+		}
+	}
+
+	if (rc == PMIC_SUCCESS) {
+		/* We need to grab the spinlock here to create a critical section to
+		 * avoid any possible race conditions with the interrupt handler
+		 */
+		spin_lock_irqsave(&lock, flags);
+
+		/* Restore the initial reset values for the callback function
+		 * and event mask parameters. This should be NULL and zero,
+		 * respectively.
+		 */
+		callback = NULL;
+		*eventMask = 0;
+
+		/* Exit the critical section. */
+		spin_unlock_irqrestore(&lock, flags);
+	}
+
+	return rc;
+}
+
+/*!
+ * @brief enable/disable fm output.
+ *
+ * @param[in]   enable            true to enable false to disable
+ */
+PMIC_STATUS pmic_audio_fm_output_enable(bool enable)
+{
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	if (enable) {
+		pmic_audio_antipop_enable(ANTI_POP_RAMP_FAST);
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, HSPGDIS, 0);
+	} else {
+		reg_mask |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 0);
+	}
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+	if (rc != PMIC_SUCCESS)
+		return rc;
+	if (enable) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+	} else {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 0);
+	}
+	rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+	return rc;
+}
+
+/*@}*/
+
+/**************************************************************************
+ * Module initialization and termination functions.
+ *
+ * Note that if this code is compiled into the kernel, then the
+ * module_init() function will be called within the device_initcall()
+ * group.
+ **************************************************************************
+ */
+
+/*!
+ * @name Audio Driver Loading/Unloading Functions
+ * These non-exported internal functions are used to support the audio
+ * device driver initialization and de-initialization operations.
+ */
+/*@{*/
+
+/*!
+ * @brief This is the audio device driver initialization function.
+ *
+ * This function is called by the kernel when this device driver is first
+ * loaded.
+ */
+static int __init mc13783_pmic_audio_init(void)
+{
+	printk(KERN_INFO "PMIC Audio driver loading...\n");
+
+	return 0;
+}
+
+/*!
+ * @brief This is the audio device driver de-initialization function.
+ *
+ * This function is called by the kernel when this device driver is about
+ * to be unloaded.
+ */
+static void __exit mc13783_pmic_audio_exit(void)
+{
+	printk(KERN_INFO "PMIC Audio driver unloading...\n");
+
+	/* Close all device handles that are still open. This will also
+	 * deregister any callbacks that may still be active.
+	 */
+	if (stDAC.handleState == HANDLE_IN_USE)
+		pmic_audio_close(stDAC.handle);
+
+	if (vCodec.handleState == HANDLE_IN_USE)
+		pmic_audio_close(vCodec.handle);
+
+	if (extStereoIn.handleState == HANDLE_IN_USE)
+		pmic_audio_close(extStereoIn.handle);
+
+
+	/* Explicitly reset all of the audio registers so that there is no
+	 * possibility of leaving the  audio hardware in a state
+	 * where it can cause problems if there is no device driver loaded.
+	 */
+	pmic_write_reg(REG_AUDIO_STEREO_DAC, RESET_ST_DAC, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_CODEC, RESET_AUD_CODEC, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_TX, RESET_AUDIO_TX, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_SSI_NETWORK, RESET_SSI_NETWORK, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_RX_0, RESET_AUDIO_RX_0, REG_FULLMASK);
+	pmic_write_reg(REG_AUDIO_RX_1, RESET_AUDIO_RX_1, REG_FULLMASK);
+}
+
+/*@}*/
+
+/*
+ * Module entry points and description information.
+ */
+
+module_init(mc13783_pmic_audio_init);
+module_exit(mc13783_pmic_audio_exit);
+
+MODULE_DESCRIPTION("PMIC - mc13783 ADC driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_battery.c b/drivers/mxc/pmic/mc13783/pmic_battery.c
new file mode 100644
index 0000000..bd998a9
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_battery.c
@@ -0,0 +1,1222 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_battery.c
+ * @brief This is the main file of PMIC(mc13783) Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+/*
+ * Includes
+ */
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+
+#include <linux/pmic_battery.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
+
+#include "pmic_battery_defs.h"
+
+#include <mach/pmic_power.h>
+#ifdef CONFIG_MXC_HWEVENT
+#include <mach/hw_events.h>
+#endif
+
+static int pmic_battery_major;
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the battery devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used to block application calls
+ */
+static wait_queue_head_t suspendq;
+
+static struct class *pmic_battery_class;
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_batt_enable_charger);
+EXPORT_SYMBOL(pmic_batt_disable_charger);
+EXPORT_SYMBOL(pmic_batt_set_charger);
+EXPORT_SYMBOL(pmic_batt_get_charger_setting);
+EXPORT_SYMBOL(pmic_batt_get_charge_current);
+EXPORT_SYMBOL(pmic_batt_enable_eol);
+EXPORT_SYMBOL(pmic_batt_bp_enable_eol);
+EXPORT_SYMBOL(pmic_batt_disable_eol);
+EXPORT_SYMBOL(pmic_batt_set_out_control);
+EXPORT_SYMBOL(pmic_batt_set_threshold);
+EXPORT_SYMBOL(pmic_batt_led_control);
+EXPORT_SYMBOL(pmic_batt_set_reverse_supply);
+EXPORT_SYMBOL(pmic_batt_set_unregulated);
+EXPORT_SYMBOL(pmic_batt_set_5k_pull);
+EXPORT_SYMBOL(pmic_batt_event_subscribe);
+EXPORT_SYMBOL(pmic_batt_event_unsubscribe);
+
+static DECLARE_MUTEX(count_mutex);	/* open count mutex */
+static int open_count;		/* open count for device file */
+
+/*!
+ * Callback function for events, we want on MGN board
+ */
+static void callback_chg_detect(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	t_sensor_bits sensor;
+	struct mxc_hw_event event = { HWE_BAT_CHARGER_PLUG, 0 };
+
+	pr_debug("In callback_chg_detect\n");
+
+	/* get sensor values */
+	pmic_get_sensors(&sensor);
+
+	pr_debug("Callback, charger detect:%d\n", sensor.sense_chgdets);
+
+	if (sensor.sense_chgdets)
+		event.args = 1;
+	else
+		event.args = 0;
+	/* send hardware event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+static void callback_low_battery(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	struct mxc_hw_event event = { HWE_BAT_BATTERY_LOW, 0 };
+
+	pr_debug("In callback_low_battery\n");
+	/* send hardware event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+static void callback_power_fail(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	struct mxc_hw_event event = { HWE_BAT_POWER_FAILED, 0 };
+
+	pr_debug("In callback_power_fail\n");
+	/* send hardware event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+static void callback_chg_overvoltage(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	struct mxc_hw_event event = { HWE_BAT_CHARGER_OVERVOLTAGE, 0 };
+
+	pr_debug("In callback_chg_overvoltage\n");
+	/* send hardware event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+static void callback_chg_full(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	t_sensor_bits sensor;
+	struct mxc_hw_event event = { HWE_BAT_CHARGER_FULL, 0 };
+
+	pr_debug("In callback_chg_full\n");
+
+	/* disable charge function */
+	pmic_batt_disable_charger(BATT_MAIN_CHGR);
+
+	/* get charger sensor */
+	pmic_get_sensors(&sensor);
+
+	/* if did not detect the charger */
+	if (sensor.sense_chgdets)
+		return;
+	/* send hardware event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+/*!
+ * This is the suspend of power management for the pmic battery API.
+ * It suports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	unsigned int reg_value = 0;
+
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, reg_value, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the pmic battery API.
+ * It suports RESTORE state.
+ *
+ * @param        pdev           the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_resume(struct platform_device *pdev)
+{
+	suspend_flag = 0;
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, c_current) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_V_COIN, c_voltage) |
+		    BITFVAL(MC13783_BATT_DAC_COIN_CH_EN,
+			    MC13783_BATT_DAC_COIN_CH_EN_ENABLED);
+		mask = BITFMASK(MC13783_BATT_DAC_V_COIN) |
+		    BITFMASK(MC13783_BATT_DAC_COIN_CH_EN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, c_current);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, 0) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_COIN_CH_EN,
+			      MC13783_BATT_DAC_COIN_CH_EN_DISABLED);
+		mask = BITFMASK(MC13783_BATT_DAC_COIN_CH_EN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current)
+{
+	unsigned int val, mask, reg;
+
+	val = 0;
+	mask = 0;
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_DAC, c_current) |
+		    BITFVAL(MC13783_BATT_DAC_V_DAC, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_DAC) |
+		    BITFMASK(MC13783_BATT_DAC_V_DAC);
+		reg = REG_CHARGER;
+		break;
+
+	case BATT_CELL_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_V_COIN, c_voltage);
+		mask = BITFMASK(MC13783_BATT_DAC_V_COIN);
+		reg = REG_POWER_CONTROL_0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		val = BITFVAL(MC13783_BATT_DAC_TRCKLE, c_current);
+		mask = BITFMASK(MC13783_BATT_DAC_TRCKLE);
+		reg = REG_CHARGER;
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, val, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to retrive the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current)
+{
+	unsigned int val, reg;
+
+	reg = 0;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+	case BATT_TRCKLE_CHGR:
+		reg = REG_CHARGER;
+		break;
+	case BATT_CELL_CHGR:
+		reg = REG_POWER_CONTROL_0;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &val, PMIC_ALL_BITS));
+
+	switch (chgr) {
+	case BATT_MAIN_CHGR:
+		*c_voltage = BITFEXT(val, MC13783_BATT_DAC_V_DAC);;
+		*c_current = BITFEXT(val, MC13783_BATT_DAC_DAC);
+		break;
+
+	case BATT_CELL_CHGR:
+		*c_voltage = BITFEXT(val, MC13783_BATT_DAC_V_COIN);
+		*c_current = 0;
+		break;
+
+	case BATT_TRCKLE_CHGR:
+		*c_voltage = 0;
+		*c_current = BITFEXT(val, MC13783_BATT_DAC_TRCKLE);
+		break;
+
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery voltage.
+ *
+ * @param      b_voltage   Output parameter for voltage setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_voltage(unsigned short *b_voltage)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+	channel = BATTERY_VOLTAGE;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_voltage = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery current.
+ *
+ * @param      b_current   Output parameter for current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_current(unsigned short *b_current)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = BATTERY_CURRENT;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_current = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery temperature.
+ *
+ * @param      b_temper   Output parameter for temperature setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_batt_temperature(unsigned short *b_temper)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = GEN_PURPOSE_AD5;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*b_temper = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery charging voltage.
+ *
+ * @param      c_voltage   Output parameter for charging voltage setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charge_voltage(unsigned short *c_voltage)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = CHARGE_VOLTAGE;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*c_voltage = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is retrives the main battery charging current.
+ *
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	channel = CHARGE_CURRENT;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*c_current = result[0];
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables End-of-Life comparator. Not supported on
+ * mc13783. Use pmic_batt_bp_enable_eol function.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_UNSUPPORTED
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *			@verbatim
+			BPDET	UVDET	LOBATL
+			____	_____   ___________
+			0	2.6	UVDET + 0.2
+			1	2.6	UVDET + 0.3
+			2	2.6	UVDET + 0.4
+			3	2.6	UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_EOL_CMP_EN,
+		      MC13783_BATT_DAC_EOL_CMP_EN_ENABLE) |
+	    BITFVAL(MC13783_BATT_DAC_EOL_SEL, typical);
+	mask = BITFMASK(MC13783_BATT_DAC_EOL_CMP_EN) |
+	    BITFMASK(MC13783_BATT_DAC_EOL_SEL);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_EOL_CMP_EN,
+		      MC13783_BATT_DAC_EOL_CMP_EN_DISABLE);
+	mask = BITFMASK(MC13783_BATT_DAC_EOL_CMP_EN);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control)
+{
+	unsigned int val, mask;
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	switch (control) {
+	case CONTROL_HARDWARE:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 0) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	case CONTROL_BPFET_LOW:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 1) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 0);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	case CONTROL_BPFET_HIGH:
+		val = BITFVAL(MC13783_BATT_DAC_FETOVRD_EN, 1) |
+		    BITFVAL(MC13783_BATT_DAC_FETCTRL_EN, 1);
+		mask = BITFMASK(MC13783_BATT_DAC_FETOVRD_EN) |
+		    BITFMASK(MC13783_BATT_DAC_FETCTRL_EN);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold)
+{
+	unsigned int val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	if (threshold > BAT_THRESHOLD_MAX)
+		return PMIC_PARAMETER_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_OVCTRL, threshold);
+	mask = BITFMASK(MC13783_BATT_DAC_OVCTRL);
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is ture, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_LED_EN, on);
+	mask = BITFMASK(MC13783_BATT_DAC_LED_EN);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is ture, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_REVERSE_SUPPLY, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_REVERSE_SUPPLY);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets unregulatored charging mode on main battery.
+ *
+ * @param      enable     If enable is ture, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_UNREGULATED, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_UNREGULATED);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable)
+{
+	unsigned val, mask;
+
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	val = BITFVAL(MC13783_BATT_DAC_5K, enable);
+	mask = BITFMASK(MC13783_BATT_DAC_5K);
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGER, val, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to un/subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ * @param        sub            define if Un/subscribe event.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS mc13783_battery_event(t_batt_event event, void *callback, bool sub)
+{
+	pmic_event_callback_t bat_callback;
+	type_event bat_event;
+
+	bat_callback.func = callback;
+	bat_callback.param = NULL;
+	switch (event) {
+	case BAT_IT_CHG_DET:
+		bat_event = EVENT_CHGDETI;
+		break;
+	case BAT_IT_CHG_OVERVOLT:
+		bat_event = EVENT_CHGOVI;
+		break;
+	case BAT_IT_CHG_REVERSE:
+		bat_event = EVENT_CHGREVI;
+		break;
+	case BAT_IT_CHG_SHORT_CIRCUIT:
+		bat_event = EVENT_CHGSHORTI;
+		break;
+	case BAT_IT_CCCV:
+		bat_event = EVENT_CCCVI;
+		break;
+	case BAT_IT_BELOW_THRESHOLD:
+		bat_event = EVENT_CHRGCURRI;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	if (sub == true)
+		CHECK_ERROR(pmic_event_subscribe(bat_event, bat_callback));
+	else
+		CHECK_ERROR(pmic_event_unsubscribe(bat_event, bat_callback));
+
+	return 0;
+}
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback)
+{
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	return mc13783_battery_event(event, callback, true);
+}
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback)
+{
+	if (suspend_flag == 1)
+		return PMIC_ERROR;
+
+	return mc13783_battery_event(event, callback, false);
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC Battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_battery_ioctl(struct inode *inode, struct file *file,
+			      unsigned int cmd, unsigned long arg)
+{
+	t_charger_setting *chgr_setting = NULL;
+	unsigned short c_current;
+	unsigned int bc_info;
+	t_eol_setting *eol_setting;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_BATT_CHARGER_CONTROL:
+		chgr_setting = kmalloc(sizeof(t_charger_setting), GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		if (chgr_setting->on != false) {
+			CHECK_ERROR_KFREE(pmic_batt_enable_charger
+					  (chgr_setting->chgr,
+					   chgr_setting->c_voltage,
+					   chgr_setting->c_current),
+					  (kfree(chgr_setting)));
+		} else {
+			CHECK_ERROR(pmic_batt_disable_charger
+				    (chgr_setting->chgr));
+		}
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_SET_CHARGER:
+		chgr_setting = kmalloc(sizeof(t_charger_setting), GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_batt_set_charger(chgr_setting->chgr,
+							chgr_setting->c_voltage,
+							chgr_setting->
+							c_current),
+				  (kfree(chgr_setting)));
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_GET_CHARGER:
+		chgr_setting = kmalloc(sizeof(t_charger_setting), GFP_KERNEL);
+		if (chgr_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(chgr_setting, (t_charger_setting *) arg,
+				   sizeof(t_charger_setting))) {
+			kfree(chgr_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_batt_get_charger_setting
+				  (chgr_setting->chgr, &chgr_setting->c_voltage,
+				   &chgr_setting->c_current),
+				  (kfree(chgr_setting)));
+		if (copy_to_user
+		    ((t_charger_setting *) arg, chgr_setting,
+		     sizeof(t_charger_setting))) {
+			return -EFAULT;
+		}
+
+		kfree(chgr_setting);
+		break;
+
+	case PMIC_BATT_GET_CHARGER_SENSOR:
+		{
+			t_sensor_bits sensor;
+			pmic_get_sensors(&sensor);
+			if (copy_to_user
+			    ((unsigned int *)arg, &sensor.sense_chgdets,
+			     sizeof(unsigned int)))
+				return -EFAULT;
+
+			break;
+		}
+	case PMIC_BATT_GET_BATTERY_VOLTAGE:
+		CHECK_ERROR(pmic_batt_get_batt_voltage(&c_current));
+		bc_info = (unsigned int)c_current * 2300 / 1023 + 2400;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+				 sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_BATTERY_CURRENT:
+		CHECK_ERROR(pmic_batt_get_batt_current(&c_current));
+		bc_info = (unsigned int)c_current * 5750 / 1023;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+				 sizeof(unsigned int)))
+			return -EFAULT;
+		break;
+
+	case PMIC_BATT_GET_BATTERY_TEMPERATURE:
+		CHECK_ERROR(pmic_batt_get_batt_temperature(&c_current));
+		bc_info = (unsigned int)c_current;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+				 sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_CHARGER_VOLTAGE:
+		CHECK_ERROR(pmic_batt_get_charge_voltage(&c_current));
+		bc_info = (unsigned int)c_current * 23000 / 1023;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+				 sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_GET_CHARGER_CURRENT:
+		CHECK_ERROR(pmic_batt_get_charge_current(&c_current));
+		bc_info = (unsigned int)c_current * 5750 / 1023;
+		if (copy_to_user((unsigned int *)arg, &bc_info,
+				 sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case PMIC_BATT_EOL_CONTROL:
+		eol_setting = kmalloc(sizeof(t_eol_setting), GFP_KERNEL);
+		if (eol_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(eol_setting, (t_eol_setting *) arg,
+				   sizeof(t_eol_setting))) {
+			kfree(eol_setting);
+			return -EFAULT;
+		}
+
+		if (eol_setting->enable != false) {
+			CHECK_ERROR_KFREE(pmic_batt_bp_enable_eol
+					  (eol_setting->typical),
+					  (kfree(chgr_setting)));
+		} else {
+			CHECK_ERROR_KFREE(pmic_batt_disable_eol(),
+					  (kfree(chgr_setting)));
+		}
+
+		kfree(eol_setting);
+		break;
+
+	case PMIC_BATT_SET_OUT_CONTROL:
+		CHECK_ERROR(pmic_batt_set_out_control((t_control) arg));
+		break;
+
+	case PMIC_BATT_SET_THRESHOLD:
+		CHECK_ERROR(pmic_batt_set_threshold((int)arg));
+		break;
+
+	case PMIC_BATT_LED_CONTROL:
+		CHECK_ERROR(pmic_batt_led_control((bool) arg));
+		break;
+
+	case PMIC_BATT_REV_SUPP_CONTROL:
+		CHECK_ERROR(pmic_batt_set_reverse_supply((bool) arg));
+		break;
+
+	case PMIC_BATT_UNREG_CONTROL:
+		CHECK_ERROR(pmic_batt_set_unregulated((bool) arg));
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a Pmic battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_battery_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+
+	/* check open count, if open firstly, register callbacks */
+	down(&count_mutex);
+	if (open_count++ > 0) {
+		up(&count_mutex);
+		return 0;
+	}
+
+	pr_debug("Subscribe the callbacks\n");
+	/* register battery event callback */
+	if (pmic_batt_event_subscribe(BAT_IT_CHG_DET, callback_chg_detect)) {
+		pr_debug("Failed to subscribe the charger detect callback\n");
+		goto event_err1;
+	}
+	if (pmic_power_event_sub(PWR_IT_LOBATLI, callback_power_fail)) {
+		pr_debug("Failed to subscribe the power failed callback\n");
+		goto event_err2;
+	}
+	if (pmic_power_event_sub(PWR_IT_LOBATHI, callback_low_battery)) {
+		pr_debug("Failed to subscribe the low battery callback\n");
+		goto event_err3;
+	}
+	if (pmic_batt_event_subscribe
+	    (BAT_IT_CHG_OVERVOLT, callback_chg_overvoltage)) {
+		pr_debug("Failed to subscribe the low battery callback\n");
+		goto event_err4;
+	}
+	if (pmic_batt_event_subscribe
+	    (BAT_IT_BELOW_THRESHOLD, callback_chg_full)) {
+		pr_debug("Failed to subscribe the charge full callback\n");
+		goto event_err5;
+	}
+
+	up(&count_mutex);
+
+	return 0;
+
+	/* un-subscribe the event callbacks */
+event_err5:
+	pmic_batt_event_unsubscribe(BAT_IT_CHG_OVERVOLT,
+				    callback_chg_overvoltage);
+event_err4:
+	pmic_power_event_unsub(PWR_IT_LOBATHI, callback_low_battery);
+event_err3:
+	pmic_power_event_unsub(PWR_IT_LOBATLI, callback_power_fail);
+event_err2:
+	pmic_batt_event_unsubscribe(BAT_IT_CHG_DET, callback_chg_detect);
+event_err1:
+
+	open_count--;
+	up(&count_mutex);
+
+	return -EFAULT;
+
+}
+
+/*!
+ * This function implements the release method on a Pmic battery device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_battery_release(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+
+	/* check open count, if open firstly, register callbacks */
+	down(&count_mutex);
+	if (--open_count == 0) {
+		/* unregister these event callback */
+		pr_debug("Unsubscribe the callbacks\n");
+		pmic_batt_event_unsubscribe(BAT_IT_BELOW_THRESHOLD,
+					    callback_chg_full);
+		pmic_batt_event_unsubscribe(BAT_IT_CHG_OVERVOLT,
+					    callback_chg_overvoltage);
+		pmic_power_event_unsub(PWR_IT_LOBATHI, callback_low_battery);
+		pmic_power_event_unsub(PWR_IT_LOBATLI, callback_power_fail);
+		pmic_batt_event_unsubscribe(BAT_IT_CHG_DET,
+					    callback_chg_detect);
+	}
+	up(&count_mutex);
+
+	return 0;
+}
+
+static const struct file_operations pmic_battery_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_battery_ioctl,
+	.open = pmic_battery_open,
+	.release = pmic_battery_release,
+};
+
+static int pmic_battery_remove(struct platform_device *pdev)
+{
+	device_destroy(pmic_battery_class, MKDEV(pmic_battery_major, 0));
+	class_destroy(pmic_battery_class);
+	unregister_chrdev(pmic_battery_major, PMIC_BATTERY_STRING);
+	return 0;
+}
+
+static int pmic_battery_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	pmic_battery_major = register_chrdev(0, PMIC_BATTERY_STRING,
+					     &pmic_battery_fops);
+
+	if (pmic_battery_major < 0) {
+		printk(KERN_ERR "Unable to get a major for pmic_battery\n");
+		return pmic_battery_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	pmic_battery_class = class_create(THIS_MODULE, PMIC_BATTERY_STRING);
+	if (IS_ERR(pmic_battery_class)) {
+		printk(KERN_ERR "Error creating PMIC battery class.\n");
+		ret = PTR_ERR(pmic_battery_class);
+		goto err_out1;
+	}
+
+	temp_class = device_create(pmic_battery_class, NULL,
+				   MKDEV(pmic_battery_major, 0), NULL,
+				   PMIC_BATTERY_STRING);
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating PMIC battery class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	pmic_batt_led_control(true);
+	pmic_batt_set_5k_pull(true);
+
+	printk(KERN_INFO "PMIC Battery successfully probed\n");
+
+	return ret;
+
+err_out2:
+	class_destroy(pmic_battery_class);
+err_out1:
+	unregister_chrdev(pmic_battery_major, PMIC_BATTERY_STRING);
+	return ret;
+}
+
+static struct platform_driver pmic_battery_driver_ldm = {
+	.driver = {
+		   .name = "pmic_battery",
+		   .bus = &platform_bus_type,
+		   },
+	.suspend = pmic_battery_suspend,
+	.resume = pmic_battery_resume,
+	.probe = pmic_battery_probe,
+	.remove = pmic_battery_remove,
+};
+
+/*
+ * Init and Exit
+ */
+
+static int __init pmic_battery_init(void)
+{
+	pr_debug("PMIC Battery driver loading...\n");
+	return platform_driver_register(&pmic_battery_driver_ldm);
+}
+
+static void __exit pmic_battery_exit(void)
+{
+	platform_driver_unregister(&pmic_battery_driver_ldm);
+	pr_debug("PMIC Battery driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+module_init(pmic_battery_init);
+module_exit(pmic_battery_exit);
+
+MODULE_DESCRIPTION("pmic_battery driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_battery_defs.h b/drivers/mxc/pmic/mc13783/pmic_battery_defs.h
new file mode 100644
index 0000000..9f66a18
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_battery_defs.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_battery_defs.h
+ * @brief This is the internal header for PMIC(mc13783) Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#ifndef __PMIC_BATTERY_DEFS_H__
+#define __PMIC_BATTERY_DEFS_H__
+
+#define         PMIC_BATTERY_STRING    "pmic_battery"
+
+/* REG_CHARGE */
+#define MC13783_BATT_DAC_V_DAC_LSH		0
+#define MC13783_BATT_DAC_V_DAC_WID		3
+#define MC13783_BATT_DAC_DAC_LSH			3
+#define MC13783_BATT_DAC_DAC_WID			4
+#define	MC13783_BATT_DAC_TRCKLE_LSH		7
+#define	MC13783_BATT_DAC_TRCKLE_WID		3
+#define MC13783_BATT_DAC_FETOVRD_EN_LSH		10
+#define MC13783_BATT_DAC_FETOVRD_EN_WID		1
+#define MC13783_BATT_DAC_FETCTRL_EN_LSH		11
+#define MC13783_BATT_DAC_FETCTRL_EN_WID		1
+#define MC13783_BATT_DAC_REVERSE_SUPPLY_LSH	13
+#define MC13783_BATT_DAC_REVERSE_SUPPLY_WID	1
+#define MC13783_BATT_DAC_OVCTRL_LSH		15
+#define MC13783_BATT_DAC_OVCTRL_WID		2
+#define MC13783_BATT_DAC_UNREGULATED_LSH		17
+#define MC13783_BATT_DAC_UNREGULATED_WID		1
+#define MC13783_BATT_DAC_LED_EN_LSH		18
+#define MC13783_BATT_DAC_LED_EN_WID		1
+#define MC13783_BATT_DAC_5K_LSH			19
+#define MC13783_BATT_DAC_5K_WID			1
+
+#define         BITS_OUT_VOLTAGE        0
+#define         LONG_OUT_VOLTAGE        3
+#define         BITS_CURRENT_MAIN       3
+#define         LONG_CURRENT_MAIN       4
+#define         BITS_CURRENT_TRICKLE    7
+#define         LONG_CURRENT_TRICKLE    3
+#define         BIT_FETOVRD             10
+#define         BIT_FETCTRL             11
+#define         BIT_RVRSMODE            13
+#define         BITS_OVERVOLTAGE        15
+#define         LONG_OVERVOLTAGE        2
+#define         BIT_UNREGULATED         17
+#define         BIT_CHRG_LED            18
+#define         BIT_CHRGRAWPDEN         19
+
+/* REG_POWXER_CONTROL_0 */
+#define MC13783_BATT_DAC_V_COIN_LSH		20
+#define MC13783_BATT_DAC_V_COIN_WID		3
+#define MC13783_BATT_DAC_COIN_CH_EN_LSH		23
+#define MC13783_BATT_DAC_COIN_CH_EN_WID		1
+#define MC13783_BATT_DAC_COIN_CH_EN_ENABLED	1
+#define MC13783_BATT_DAC_COIN_CH_EN_DISABLED	0
+#define MC13783_BATT_DAC_EOL_CMP_EN_LSH		18
+#define MC13783_BATT_DAC_EOL_CMP_EN_WID		1
+#define MC13783_BATT_DAC_EOL_CMP_EN_ENABLE	1
+#define MC13783_BATT_DAC_EOL_CMP_EN_DISABLE	0
+#define MC13783_BATT_DAC_EOL_SEL_LSH		16
+#define MC13783_BATT_DAC_EOL_SEL_WID		2
+
+#define         DEF_VALUE               0
+
+#define         BAT_THRESHOLD_MAX       3
+
+#endif				/*  __PMIC_BATTERY_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_convity.c b/drivers/mxc/pmic/mc13783/pmic_convity.c
new file mode 100644
index 0000000..2104bbb
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_convity.c
@@ -0,0 +1,2479 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_convity.c
+ * @brief Implementation of the PMIC Connectivity driver APIs.
+ *
+ * The PMIC connectivity device driver and this API were developed to support
+ * the external connectivity capabilities of several power management ICs that
+ * are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes, in terms of external connectivity, are
+ * supported:
+ *
+ * @verbatim
+       Operating Mode     mc13783
+       ---------------    -------
+       USB (incl. OTG)     Yes
+       RS-232              Yes
+       CEA-936             Yes
+
+   @endverbatim
+ *
+ * @ingroup PMIC_CONNECTIVITY
+ */
+
+#include <linux/interrupt.h>	/* For tasklet interface.                  */
+#include <linux/platform_device.h>	/* For kernel module interface.            */
+#include <linux/spinlock.h>	/* For spinlock interface.                 */
+#include <linux/pmic_adc.h>	/* For PMIC ADC driver interface.          */
+#include <linux/pmic_status.h>
+#include <mach/pmic_convity.h>	/* For PMIC Connectivity driver interface. */
+
+/*
+ * mc13783 Connectivity API
+ */
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_convity_open);
+EXPORT_SYMBOL(pmic_convity_close);
+EXPORT_SYMBOL(pmic_convity_set_mode);
+EXPORT_SYMBOL(pmic_convity_get_mode);
+EXPORT_SYMBOL(pmic_convity_reset);
+EXPORT_SYMBOL(pmic_convity_set_callback);
+EXPORT_SYMBOL(pmic_convity_clear_callback);
+EXPORT_SYMBOL(pmic_convity_get_callback);
+EXPORT_SYMBOL(pmic_convity_usb_set_speed);
+EXPORT_SYMBOL(pmic_convity_usb_get_speed);
+EXPORT_SYMBOL(pmic_convity_usb_set_power_source);
+EXPORT_SYMBOL(pmic_convity_usb_get_power_source);
+EXPORT_SYMBOL(pmic_convity_usb_set_xcvr);
+EXPORT_SYMBOL(pmic_convity_usb_get_xcvr);
+EXPORT_SYMBOL(pmic_convity_usb_otg_set_dlp_duration);
+EXPORT_SYMBOL(pmic_convity_usb_otg_get_dlp_duration);
+EXPORT_SYMBOL(pmic_convity_usb_otg_set_config);
+EXPORT_SYMBOL(pmic_convity_usb_otg_clear_config);
+EXPORT_SYMBOL(pmic_convity_usb_otg_get_config);
+EXPORT_SYMBOL(pmic_convity_set_output);
+EXPORT_SYMBOL(pmic_convity_rs232_set_config);
+EXPORT_SYMBOL(pmic_convity_rs232_get_config);
+EXPORT_SYMBOL(pmic_convity_cea936_exit_signal);
+
+/*! @def SET_BITS
+ * Set a register field to a given value.
+ */
+
+#define SET_BITS(reg, field, value)    (((value) << reg.field.offset) & \
+					reg.field.mask)
+
+/*! @def GET_BITS
+ * Get the current value of a given register field.
+ */
+#define GET_BITS(reg, value)    (((value) & reg.mask) >> \
+				 reg.offset)
+
+/*!
+ * @brief Define the possible states for a device handle.
+ *
+ * This enumeration is used to track the current state of each device handle.
+ */
+typedef enum {
+	HANDLE_FREE,		/*!< Handle is available for use. */
+	HANDLE_IN_USE		/*!< Handle is currently in use.  */
+} HANDLE_STATE;
+
+/*
+ * This structure is used to define a specific hardware register field.
+ *
+ * All hardware register fields are defined using an offset to the LSB
+ * and a mask. The offset is used to right shift a register value before
+ * applying the mask to actually obtain the value of the field.
+ */
+typedef struct {
+	const unsigned char offset;	/* Offset of LSB of register field.           */
+	const unsigned int mask;	/* Mask value used to isolate register field. */
+} REGFIELD;
+
+/*!
+ * @brief This structure is used to identify the fields in the USBCNTRL_REG_0 hardware register.
+ *
+ * This structure lists all of the fields within the USBCNTRL_REG_0 hardware
+ * register.
+ */
+typedef struct {
+	REGFIELD FSENB;		/*!< USB Full Speed Enable                            */
+	REGFIELD USB_SUSPEND;	/*!< USB Suspend Mode Enable                          */
+	REGFIELD USB_PU;	/*!< USB Pullup Enable                                */
+	REGFIELD UDP_PD;	/*!< USB Data Plus Pulldown Enable                    */
+	REGFIELD UDM_PD;	/*!< USB 150K UDP Pullup Enable                       */
+	REGFIELD DP150K_PU;	/*!< USB Pullup/Pulldown Override Enable              */
+	REGFIELD VBUSPDENB;	/*!< USB VBUS Pulldown NMOS Switch Enable             */
+	REGFIELD CURRENT_LIMIT;	/*!< USB Regulator Current Limit Setting-3 bits       */
+	REGFIELD DLP_SRP;	/*!< USB Data Line Pulsing Timer Enable               */
+	REGFIELD SE0_CONN;	/*!< USB Pullup Connect When SE0 Detected             */
+	REGFIELD USBXCVREN;	/*!< USB Transceiver Enabled When INTERFACE_MODE[2:0]=000 and RESETB=high */
+	REGFIELD PULLOVR;	/*!< 1K5 Pullup and UDP/UDM Pulldown Disable When UTXENB=Low             */
+	REGFIELD INTERFACE_MODE;	/*!< Connectivity Interface Mode Select-3 Bits        */
+	REGFIELD DATSE0;	/*!< USB Single or Differential Mode Select           */
+	REGFIELD BIDIR;		/*!< USB Unidirectional/Bidirectional Transmission    */
+	REGFIELD USBCNTRL;	/*!< USB Mode of Operation controlled By USBEN/SPI Pin */
+	REGFIELD IDPD;		/*!< USB UID Pulldown Enable                          */
+	REGFIELD IDPULSE;	/*!< USB Pulse to Gnd on UID Line Generated           */
+	REGFIELD IDPUCNTRL;	/*!< USB UID Pin pulled high By 5ua Curr Source       */
+	REGFIELD DMPULSE;	/*!< USB Positive pulse on the UDM Line Generated     */
+} USBCNTRL_REG_0;
+
+/*!
+ * @brief This variable is used to access the USBCNTRL_REG_0 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * USBCNTRL_REG_0  hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const USBCNTRL_REG_0 regUSB0 = {
+	{0, 0x000001},		/*!< FSENB        */
+	{1, 0x000002},		/*!< USB_SUSPEND  */
+	{2, 0x000004},		/*!< USB_PU       */
+	{3, 0x000008},		/*!< UDP_PD       */
+	{4, 0x000010},		/*!< UDM_PD       */
+	{5, 0x000020},		/*!< DP150K_PU    */
+	{6, 0x000040},		/*!< VBUSPDENB    */
+	{7, 0x000380},		/*!< CURRENT_LIMIT */
+	{10, 0x000400},		/*!< DLP_SRP      */
+	{11, 0x000800},		/*!< SE0_CONN     */
+	{12, 0x001000},		/*!< USBXCVREN    */
+	{13, 0x002000},		/*!< PULLOVR      */
+	{14, 0x01c000},		/*!< INTERFACE_MODE */
+	{17, 0x020000},		/*!< DATSE0       */
+	{18, 0x040000},		/*!< BIDIR        */
+	{19, 0x080000},		/*!< USBCNTRL     */
+	{20, 0x100000},		/*!< IDPD         */
+	{21, 0x200000},		/*!< IDPULSE      */
+	{22, 0x400000},		/*!< IDPUCNTRL    */
+	{23, 0x800000}		/*!< DMPULSE      */
+
+};
+
+/*!
+ * @brief This structure is used to identify the fields in the USBCNTRL_REG_1 hardware register.
+ *
+ * This structure lists all of the fields within the USBCNTRL_REG_1 hardware
+ * register.
+ */
+typedef struct {
+	REGFIELD VUSBIN;	/*!< Controls The Input Source For VUSB             */
+	REGFIELD VUSB;		/*!< VUSB Output Voltage Select-High=3.3V Low=2.775V */
+	REGFIELD VUSBEN;	/*!< VUSB Output Enable-                            */
+	REGFIELD VBUSEN;	/*!< VBUS Output Enable-                            */
+	REGFIELD RSPOL;		/*!< Low=RS232 TX on UDM, RX on UDP
+				   High= RS232 TX on UDP, RX on UDM               */
+	REGFIELD RSTRI;		/*!< TX Forced To Tristate in RS232 Mode Only       */
+	REGFIELD ID100kPU;	/*!< 100k UID Pullup Enabled                        */
+} USBCNTRL_REG_1;
+
+/*!
+ * @brief This variable is used to access the USBCNTRL_REG_1 hardware register.
+ *
+ * This variable defines how to access all of the fields within the
+ * USBCNTRL_REG_1  hardware register. The initial values consist of the offset
+ * and mask values needed to access each of the register fields.
+ */
+static const USBCNTRL_REG_1 regUSB1 = {
+	{0, 0x000003},		/*!< VUSBIN-2 Bits  */
+	{2, 0x000004},		/*!< VUSB           */
+	{3, 0x000008},		/*!< VUSBEN         */
+	/*{4, 0x000010} *//*!< Reserved       */
+	{5, 0x000020},		/*!< VBUSEN         */
+	{6, 0x000040},		/*!< RSPOL          */
+	{7, 0x000080},		/*!< RSTRI          */
+	{8, 0x000100}		/*!< ID100kPU       */
+	/*!< 9-23 Unused    */
+};
+
+/*! Define a mask to access the entire hardware register. */
+static const unsigned int REG_FULLMASK = 0xffffff;
+
+/*! Define the mc13783 USBCNTRL_REG_0 register power on reset state. */
+static const unsigned int RESET_USBCNTRL_REG_0 = 0x080060;
+
+/*! Define the mc13783 USBCNTRL_REG_1 register power on reset state. */
+static const unsigned int RESET_USBCNTRL_REG_1 = 0x000006;
+
+static pmic_event_callback_t eventNotify;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the connectivity driver. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+	PMIC_CONVITY_USB_SPEED usbSpeed;	/*!< USB connection
+						   speed.           */
+	PMIC_CONVITY_USB_MODE usbMode;	/*!< USB connection
+					   mode.            */
+	PMIC_CONVITY_USB_POWER_IN usbPowerIn;	/*!< USB transceiver
+						   power source.    */
+	PMIC_CONVITY_USB_POWER_OUT usbPowerOut;	/*!< USB transceiver
+						   power output
+						   level.           */
+	PMIC_CONVITY_USB_TRANSCEIVER_MODE usbXcvrMode;	/*!< USB transceiver
+							   mode.            */
+	unsigned int usbDlpDuration;	/*!< USB Data Line
+					   Pulsing duration. */
+	PMIC_CONVITY_USB_OTG_CONFIG usbOtgCfg;	/*!< USB OTG
+						   configuration
+						   options.         */
+	PMIC_CONVITY_RS232_INTERNAL rs232CfgInternal;	/*!< RS-232 internal
+							   connections.     */
+	PMIC_CONVITY_RS232_EXTERNAL rs232CfgExternal;	/*!< RS-232 external
+							   connections.     */
+} pmic_convity_state_struct;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in USB mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+	PMIC_CONVITY_USB_SPEED usbSpeed;	/*!< USB connection
+						   speed.           */
+	PMIC_CONVITY_USB_MODE usbMode;	/*!< USB connection
+					   mode.            */
+	PMIC_CONVITY_USB_POWER_IN usbPowerIn;	/*!< USB transceiver
+						   power source.    */
+	PMIC_CONVITY_USB_POWER_OUT usbPowerOut;	/*!< USB transceiver
+						   power output
+						   level.           */
+	PMIC_CONVITY_USB_TRANSCEIVER_MODE usbXcvrMode;	/*!< USB transceiver
+							   mode.            */
+	unsigned int usbDlpDuration;	/*!< USB Data Line
+					   Pulsing duration. */
+	PMIC_CONVITY_USB_OTG_CONFIG usbOtgCfg;	/*!< USB OTG
+						   configuration
+						   options.         */
+} pmic_convity_usb_state;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in RS_232 mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+	PMIC_CONVITY_RS232_INTERNAL rs232CfgInternal;	/*!< RS-232 internal
+							   connections.     */
+	PMIC_CONVITY_RS232_EXTERNAL rs232CfgExternal;	/*!< RS-232 external
+							   connections.     */
+} pmic_convity_rs232_state;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in cea-936 mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+
+} pmic_convity_cea936_state;
+
+/*!
+ * @brief Identifies the hardware interrupt source.
+ *
+ * This enumeration identifies which of the possible hardware interrupt
+ * sources actually caused the current interrupt handler to be called.
+ */
+typedef enum {
+	CORE_EVENT_4V4 = 1,	/*!< Detected USB 4.4 V event.              */
+	CORE_EVENT_2V0 = 2,	/*!< Detected USB 2.0 V event.              */
+	CORE_EVENT_0V8 = 4,	/*!< Detected USB 0.8 V event.              */
+	CORE_EVENT_ABDET = 8	/*!< Detected USB mini A-B connector event. */
+} PMIC_CORE_EVENT;
+
+/*!
+ * @brief This structure defines the reset/power on state for the Connectivity driver.
+ */
+static const pmic_convity_state_struct reset = {
+	0,
+	HANDLE_FREE,
+	USB,
+	NULL,
+	0,
+	USB_FULL_SPEED,
+	USB_PERIPHERAL,
+	USB_POWER_INTERNAL,
+	USB_POWER_3V3,
+	USB_TRANSCEIVER_OFF,
+	0,
+	USB_PULL_OVERRIDE | USB_VBUS_CURRENT_LIMIT_HIGH,
+	RS232_TX_USE0VM_RX_UDATVP,
+	RS232_TX_UDM_RX_UDP
+};
+
+/*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static pmic_convity_usb_state usb = {
+	0,
+	HANDLE_FREE,
+	USB,
+	NULL,
+	0,
+	USB_FULL_SPEED,
+	USB_PERIPHERAL,
+	USB_POWER_INTERNAL,
+	USB_POWER_3V3,
+	USB_TRANSCEIVER_OFF,
+	0,
+	USB_PULL_OVERRIDE | USB_VBUS_CURRENT_LIMIT_HIGH,
+};
+
+/*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static pmic_convity_rs232_state rs_232 = {
+	0,
+	HANDLE_FREE,
+	RS232_1,
+	NULL,
+	0,
+	RS232_TX_USE0VM_RX_UDATVP,
+	RS232_TX_UDM_RX_UDP
+};
+
+/*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static pmic_convity_cea936_state cea_936 = {
+	0,
+	HANDLE_FREE,
+	CEA936_MONO,
+	NULL,
+	0,
+};
+
+/*!
+ * @brief This spinlock is used to provide mutual exclusion.
+ *
+ * Create a spinlock that can be used to provide mutually exclusive
+ * read/write access to the globally accessible "convity" data structure
+ * that was defined above. Mutually exclusive access is required to
+ * ensure that the convity data structure is consistent at all times
+ * when possibly accessed by multiple threads of execution (for example,
+ * while simultaneously handling a user request and an interrupt event).
+ *
+ * We need to use a spinlock sometimes because we need to provide mutual
+ * exclusion while handling a hardware interrupt.
+ */
+static DEFINE_SPINLOCK(lock);
+
+/*!
+ * @brief This mutex is used to provide mutual exclusion.
+ *
+ * Create a mutex that can be used to provide mutually exclusive
+ * read/write access to the globally accessible data structures
+ * that were defined above. Mutually exclusive access is required to
+ * ensure that the Connectivity data structures are consistent at all
+ * times when possibly accessed by multiple threads of execution.
+ *
+ * Note that we use a mutex instead of the spinlock whenever disabling
+ * interrupts while in the critical section is not required. This helps
+ * to minimize kernel interrupt handling latency.
+ */
+static DECLARE_MUTEX(mutex);
+
+/* Prototype for the connectivity driver tasklet function. */
+static void pmic_convity_tasklet(struct work_struct *work);
+
+/*!
+ * @brief Tasklet handler for the connectivity driver.
+ *
+ * Declare a tasklet that will do most of the processing for all of the
+ * connectivity-related interrupt events (USB4.4VI, USB2.0VI, USB0.8VI,
+ * and AB_DETI). Note that we cannot do all of the required processing
+ * within the interrupt handler itself because we may need to call the
+ * ADC driver to measure voltages as well as calling any user-registered
+ * callback functions.
+ */
+DECLARE_WORK(convityTasklet, pmic_convity_tasklet);
+
+/*!
+ * @brief Global variable to track currently active interrupt events.
+ *
+ * This global variable is used to keep track of all of the currently
+ * active interrupt events for the connectivity driver. Note that access
+ * to this variable may occur while within an interrupt context and,
+ * therefore, must be guarded by using a spinlock.
+ */
+static PMIC_CORE_EVENT eventID;
+
+/* Prototypes for all static connectivity driver functions. */
+static PMIC_STATUS pmic_convity_set_mode_internal(const PMIC_CONVITY_MODE mode);
+static PMIC_STATUS pmic_convity_deregister_all(void);
+static void pmic_convity_event_handler(void *param);
+
+/**************************************************************************
+ * General setup and configuration functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name General Setup and Configuration Connectivity APIs
+ * Functions for setting up and configuring the connectivity hardware.
+ */
+/*@{*/
+
+/*!
+ * Attempt to open and gain exclusive access to the PMIC connectivity
+ * hardware. An initial operating mode must also be specified.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls. The
+ * same handle must also be used in the pmic_convity_close() call when use
+ * of the PMIC connectivity hardware is no longer required.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            initial connectivity operating mode
+ *
+ * @return      PMIC_SUCCESS    if the open request was successful
+ */
+PMIC_STATUS pmic_convity_open(PMIC_CONVITY_HANDLE * const handle,
+			      const PMIC_CONVITY_MODE mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	if (handle == (PMIC_CONVITY_HANDLE *) NULL) {
+		/* Do not dereference a NULL pointer. */
+		return PMIC_ERROR;
+	}
+
+	/* We only need to acquire a mutex here because the interrupt handler
+	 * never modifies the device handle or device handle state. Therefore,
+	 * we don't need to worry about conflicts with the interrupt handler
+	 * or the need to execute in an interrupt context.
+	 *
+	 * But we do need a critical section here to avoid problems in case
+	 * multiple calls to pmic_convity_open() are made since we can only
+	 * allow one of them to succeed.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Check the current device handle state and acquire the handle if
+	 * it is available.
+	 */
+	if ((usb.handle_state != HANDLE_FREE)
+	    && (rs_232.handle_state != HANDLE_FREE)
+	    && (cea_936.handle_state != HANDLE_FREE)) {
+
+		/* Cannot open the PMIC connectivity hardware at this time or an invalid
+		 * mode was requested.
+		 */
+		*handle = reset.handle;
+	} else {
+
+		if (mode == USB) {
+			usb.handle = (PMIC_CONVITY_HANDLE) (&usb);
+			usb.handle_state = HANDLE_IN_USE;
+		} else if ((mode == RS232_1) || (mode == RS232_2)) {
+			rs_232.handle = (PMIC_CONVITY_HANDLE) (&rs_232);
+			rs_232.handle_state = HANDLE_IN_USE;
+		} else if ((mode == CEA936_STEREO) || (mode == CEA936_MONO)
+			   || (mode == CEA936_TEST_LEFT)
+			   || (mode == CEA936_TEST_RIGHT)) {
+			cea_936.handle = (PMIC_CONVITY_HANDLE) (&cea_936);
+			cea_936.handle_state = HANDLE_IN_USE;
+
+		}
+		/* Let's begin by acquiring the connectivity device handle. */
+		/* Then we can try to set the desired operating mode. */
+		rc = pmic_convity_set_mode_internal(mode);
+
+		if (rc == PMIC_SUCCESS) {
+			/* Successfully set the desired operating mode, now return the
+			 * handle to the caller.
+			 */
+			if (mode == USB) {
+				*handle = usb.handle;
+			} else if ((mode == RS232_1) || (mode == RS232_2)) {
+				*handle = rs_232.handle;
+			} else if ((mode == CEA936_STEREO)
+				   || (mode == CEA936_MONO)
+				   || (mode == CEA936_TEST_LEFT)
+				   || (mode == CEA936_TEST_RIGHT)) {
+				*handle = cea_936.handle;
+			}
+		} else {
+			/* Failed to set the desired mode, return the handle to an unused
+			 * state.
+			 */
+			if (mode == USB) {
+				usb.handle = reset.handle;
+				usb.handle_state = reset.handle_state;
+			} else if ((mode == RS232_1) || (mode == RS232_2)) {
+				rs_232.handle = reset.handle;
+				rs_232.handle_state = reset.handle_state;
+			} else if ((mode == CEA936_STEREO)
+				   || (mode == CEA936_MONO)
+				   || (mode == CEA936_TEST_LEFT)
+				   || (mode == CEA936_TEST_RIGHT)) {
+				cea_936.handle = reset.handle;
+				cea_936.handle_state = reset.handle_state;
+			}
+
+			*handle = reset.handle;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Terminate further access to the PMIC connectivity hardware. Also allows
+ * another process to call pmic_convity_open() to gain access.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the close request was successful
+ */
+PMIC_STATUS pmic_convity_close(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Begin a critical section here to avoid the possibility of race
+	 * conditions if multiple threads happen to call this function and
+	 * pmic_convity_open() at the same time.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	/* Confirm that the device handle matches the one assigned in the
+	 * pmic_convity_open() call and then close the connection.
+	 */
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
+		rc = PMIC_SUCCESS;
+
+		/* Deregister for all existing callbacks if necessary and make sure
+		 * that the event handling settings are consistent following the
+		 * close operation.
+		 */
+		if ((usb.callback != reset.callback)
+		    || (rs_232.callback != reset.callback)
+		    || (cea_936.callback != reset.callback)) {
+			/* Deregister the existing callback function and all registered
+			 * events before we completely close the handle.
+			 */
+			rc = pmic_convity_deregister_all();
+			if (rc == PMIC_SUCCESS) {
+
+			} else if (usb.eventMask != reset.eventMask) {
+				/* Having a non-zero eventMask without a callback function being
+				 * defined should never occur but let's just make sure here that
+				 * we keep things consistent.
+				 */
+				usb.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				usb.handle = reset.handle;
+				usb.handle_state = reset.handle_state;
+
+			} else if (rs_232.eventMask != reset.eventMask) {
+
+				rs_232.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				rs_232.handle = reset.handle;
+				rs_232.handle_state = reset.handle_state;
+
+			} else if (cea_936.eventMask != reset.eventMask) {
+				cea_936.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				cea_936.handle = reset.handle;
+				cea_936.handle_state = reset.handle_state;
+
+			}
+
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Change the current operating mode of the PMIC connectivity hardware.
+ * The available connectivity operating modes is hardware dependent and
+ * consists of one or more of the following: USB (including USB On-the-Go),
+ * RS-232, and CEA-936. Requesting an operating mode that is not supported
+ * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
+ *
+ * @param       handle          device handle from
+					open() call
+ * @param       mode            desired operating mode
+ *
+ * @return      PMIC_SUCCESS    if the requested mode was successfully set
+ */
+PMIC_STATUS pmic_convity_set_mode(const PMIC_CONVITY_HANDLE handle,
+				  const PMIC_CONVITY_MODE mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
+		rc = pmic_convity_set_mode_internal(mode);
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the current operating mode for the PMIC connectivity hardware.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            the current PMIC connectivity operating mode
+ *
+ * @return      PMIC_SUCCESS    if the requested mode was successfully set
+ */
+PMIC_STATUS pmic_convity_get_mode(const PMIC_CONVITY_HANDLE handle,
+				  PMIC_CONVITY_MODE * const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((((handle == usb.handle) &&
+	      (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						       && (rs_232.
+							   handle_state ==
+							   HANDLE_IN_USE))
+	     || ((handle == cea_936.handle)
+		 && (cea_936.handle_state == HANDLE_IN_USE)))
+	    && (mode != (PMIC_CONVITY_MODE *) NULL)) {
+
+		*mode = usb.mode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Restore all registers to the initial power-on/reset state.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the reset was successful
+ */
+PMIC_STATUS pmic_convity_reset(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
+
+		/* Reset the PMIC Connectivity register to it's power on state. */
+		rc = pmic_write_reg(REG_USB, RESET_USBCNTRL_REG_0,
+				    REG_FULLMASK);
+
+		rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+				    RESET_USBCNTRL_REG_1, REG_FULLMASK);
+
+		if (rc == PMIC_SUCCESS) {
+			/* Also reset the device driver state data structure. */
+			/* Also reset the device driver state data structure. */
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Register a callback function that will be used to signal PMIC connectivity
+ * events. For example, the USB subsystem should register a callback function
+ * in order to be notified of device connect/disconnect events. Note, however,
+ * that non-USB events may also be signalled depending upon the PMIC hardware
+ * capabilities. Therefore, the callback function must be able to properly
+ * handle all of the possible events if support for non-USB peripherals is
+ * also to be included.
+ *
+ * @param       handle          device handle from open() call
+ * @param       func            a pointer to the callback function
+ * @param       eventMask       a mask selecting events to be notified
+ *
+ * @return      PMIC_SUCCESS    if the callback was successful registered
+ */
+PMIC_STATUS pmic_convity_set_callback(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_CALLBACK func,
+				      const PMIC_CONVITY_EVENTS eventMask)
+{
+	unsigned long flags;
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* We need to start a critical section here to ensure a consistent state
+	 * in case simultaneous calls to pmic_convity_set_callback() are made. In
+	 * that case, we must serialize the calls to ensure that the "callback"
+	 * and "eventMask" state variables are always consistent.
+	 *
+	 * Note that we don't actually need to acquire the spinlock until later
+	 * when we are finally ready to update the "callback" and "eventMask"
+	 * state variables which are shared with the interrupt handler.
+	 */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+
+		/* Return an error if either the callback function or event mask
+		 * is not properly defined.
+		 *
+		 * It is also considered an error if a callback function has already
+		 * been defined. If you wish to register for a new set of events,
+		 * then you must first call pmic_convity_clear_callback() to
+		 * deregister the existing callback function and list of events
+		 * before trying to register a new callback function.
+		 */
+		if ((func == NULL) || (eventMask == 0)
+		    || (usb.callback != NULL)) {
+			rc = PMIC_ERROR;
+
+			/* Register for PMIC events from the core protocol driver. */
+		} else {
+
+			if ((eventMask & USB_DETECT_4V4_RISE) ||
+			    (eventMask & USB_DETECT_4V4_FALL)) {
+				/* We need to register for the 4.4V interrupt. */
+				/* EVENT_USBI or EVENT_USB_44VI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_4V4);
+				rc = pmic_event_subscribe(EVENT_USBI,
+							  eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					return rc;
+
+			}
+
+			if ((eventMask & USB_DETECT_2V0_RISE) ||
+			    (eventMask & USB_DETECT_2V0_FALL)) {
+				/* We need to register for the 2.0V interrupt. */
+				/* EVENT_USB_20VI or EVENT_USBI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_2V0);
+				rc = pmic_event_subscribe(EVENT_USBI,
+							  eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_4V4;
+
+			}
+
+			if ((eventMask & USB_DETECT_0V8_RISE) ||
+			    (eventMask & USB_DETECT_0V8_FALL)) {
+				/* We need to register for the 0.8V interrupt. */
+				/* EVENT_USB_08VI or EVENT_USBI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_0V8);
+				rc = pmic_event_subscribe(EVENT_USBI,
+							  eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_2V0;
+
+			}
+
+			if ((eventMask & USB_DETECT_MINI_A) ||
+			    (eventMask & USB_DETECT_MINI_B)
+			    || (eventMask & USB_DETECT_NON_USB_ACCESSORY)
+			    || (eventMask & USB_DETECT_FACTORY_MODE)) {
+				/* We need to register for the AB_DET interrupt. */
+				/* EVENT_AB_DETI or EVENT_IDI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_ABDET);
+				rc = pmic_event_subscribe(EVENT_IDI,
+							  eventNotify);
+
+				if (rc != PMIC_SUCCESS)
+					goto Cleanup_0V8;
+
+			}
+
+			/* Use a critical section to maintain a consistent state. */
+			spin_lock_irqsave(&lock, flags);
+
+			/* Successfully registered for all events. */
+			usb.callback = func;
+			usb.eventMask = eventMask;
+			spin_unlock_irqrestore(&lock, flags);
+
+			goto End;
+
+			/* This section unregisters any already registered events if we should
+			 * encounter an error partway through the registration process. Note
+			 * that we don't check the return status here since it is already set
+			 * to PMIC_ERROR before we get here.
+			 */
+Cleanup_0V8:
+
+			if ((eventMask & USB_DETECT_0V8_RISE) ||
+			    (eventMask & USB_DETECT_0V8_FALL)) {
+				/* EVENT_USB_08VI or EVENT_USBI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_0V8);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+				goto End;
+			}
+
+Cleanup_2V0:
+
+			if ((eventMask & USB_DETECT_2V0_RISE) ||
+			    (eventMask & USB_DETECT_2V0_FALL)) {
+				/* EVENT_USB_20VI or EVENT_USBI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_2V0);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+				goto End;
+			}
+
+Cleanup_4V4:
+
+			if ((eventMask & USB_DETECT_4V4_RISE) ||
+			    (eventMask & USB_DETECT_4V4_FALL)) {
+				/* EVENT_USB_44VI or EVENT_USBI */
+				eventNotify.func = pmic_convity_event_handler;
+				eventNotify.param = (void *)(CORE_EVENT_4V4);
+				pmic_event_unsubscribe(EVENT_USBI, eventNotify);
+			}
+		}
+		/* Exit the critical section. */
+
+	}
+End: up(&mutex);
+	return rc;
+
+}
+
+/*!
+ * Clears the current callback function. If this function returns successfully
+ * then all future Connectivity events will only be handled by the default
+ * handler within the Connectivity driver.
+ *
+ * @param       handle          device handle from open() call
+ *
+ * @return      PMIC_SUCCESS    if the callback was successful cleared
+ */
+PMIC_STATUS pmic_convity_clear_callback(const PMIC_CONVITY_HANDLE handle)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
+
+		rc = pmic_convity_deregister_all();
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the current callback function and event mask.
+ *
+ * @param       handle          device handle from open() call
+ * @param       func            the current callback function
+ * @param       eventMask       the current event selection mask
+ *
+ * @return      PMIC_SUCCESS    if the callback information was successful
+ *                              retrieved
+ */
+PMIC_STATUS pmic_convity_get_callback(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_CALLBACK * const func,
+				      PMIC_CONVITY_EVENTS * const eventMask)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+	if ((((handle == usb.handle) &&
+	      (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						       && (rs_232.
+							   handle_state ==
+							   HANDLE_IN_USE))
+	     || ((handle == cea_936.handle)
+		 && (cea_936.handle_state == HANDLE_IN_USE)))
+	    && (func != (PMIC_CONVITY_CALLBACK *) NULL)
+	    && (eventMask != (PMIC_CONVITY_EVENTS *) NULL)) {
+		*func = usb.callback;
+		*eventMask = usb.eventMask;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+
+	up(&mutex);
+
+	return rc;
+}
+
+/*@*/
+
+/**************************************************************************
+ * USB-specific configuration and setup functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name USB and USB-OTG Connectivity APIs
+ * Functions for controlling USB and USB-OTG connectivity.
+ */
+/*@{*/
+
+/*!
+ * Set the USB transceiver speed.
+ *
+ * @param       handle          device handle from open() call
+ * @param       speed           the desired USB transceiver speed
+ *
+ * @return      PMIC_SUCCESS    if the transceiver speed was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_set_speed(const PMIC_CONVITY_HANDLE handle,
+				       const PMIC_CONVITY_USB_SPEED speed)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = SET_BITS(regUSB0, FSENB, 1);
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if (handle == (rs_232.handle || cea_936.handle)) {
+		return PMIC_PARAMETER_ERROR;
+	} else {
+		if ((handle == usb.handle) &&
+		    (usb.handle_state == HANDLE_IN_USE)) {
+			/* Validate the function parameters and if they are valid, then
+			 * configure the pull-up and pull-down resistors as required for
+			 * the desired operating mode.
+			 */
+			if ((speed == USB_HIGH_SPEED)) {
+				/*
+				 * The USB transceiver also does not support the high speed mode
+				 * (which is also optional under the USB OTG specification).
+				 */
+				rc = PMIC_NOT_SUPPORTED;
+			} else if ((speed != USB_LOW_SPEED)
+				   && (speed != USB_FULL_SPEED)) {
+				/* Final validity check on the speed parameter. */
+				rc = PMIC_ERROR;;
+			} else {
+				/* First configure the D+ and D- pull-up/pull-down resistors as
+				 * per the USB OTG specification.
+				 */
+				if (speed == USB_FULL_SPEED) {
+					/* Activate pull-up on D+ and pull-down on D-. */
+					reg_value =
+					    SET_BITS(regUSB0, UDM_PD, 1);
+				} else if (speed == USB_LOW_SPEED) {
+					/* Activate pull-up on D+ and pull-down on D-. */
+					reg_value = SET_BITS(regUSB0, FSENB, 1);
+				}
+
+				/* Now set the desired USB transceiver speed. Note that
+				 * USB_FULL_SPEED simply requires FSENB=0 (which it
+				 * already is).
+				 */
+
+				rc = pmic_write_reg(REG_USB, reg_value,
+						    reg_mask);
+
+				if (rc == PMIC_SUCCESS)
+					usb.usbSpeed = speed;
+
+			}
+		}
+	}
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the USB transceiver speed.
+ *
+ * @param       handle          device handle from open() call
+ * @param       speed           the current USB transceiver speed
+ * @param       mode            the current USB transceiver mode
+ *
+ * @return      PMIC_SUCCESS    if the transceiver speed was successfully
+ *                              obtained
+ */
+PMIC_STATUS pmic_convity_usb_get_speed(const PMIC_CONVITY_HANDLE handle,
+				       PMIC_CONVITY_USB_SPEED * const speed,
+				       PMIC_CONVITY_USB_MODE * const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
+	    (speed != (PMIC_CONVITY_USB_SPEED *) NULL) &&
+	    (mode != (PMIC_CONVITY_USB_MODE *) NULL)) {
+		*speed = usb.usbSpeed;
+		*mode = usb.usbMode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * This function enables/disables VUSB and VBUS output.
+ * This API configures the VUSBEN and VBUSEN bits of USB register
+ *
+ * @param       handle          device handle from open() call
+ * @param        out_type true, for VBUS
+ *                        false, for VUSB
+ * @param       out	if true, output is enabled
+ *                      if false, output is disabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_convity_set_output(const PMIC_CONVITY_HANDLE handle,
+				    bool out_type, bool out)
+{
+
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+
+		if ((out_type == 0) && (out == 1)) {
+
+			reg_value = SET_BITS(regUSB1, VUSBEN, 1);
+			reg_mask = SET_BITS(regUSB1, VUSBEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					    reg_value, reg_mask);
+		} else if (out_type == 0 && out == 0) {
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					    reg_value, reg_mask);
+		} else if (out_type == 1 && out == 1) {
+
+			reg_value = SET_BITS(regUSB1, VBUSEN, 1);
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					    reg_value, reg_mask);
+		}
+
+		else if (out_type == 1 && out == 0) {
+
+			reg_mask = SET_BITS(regUSB1, VBUSEN, 1);
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					    reg_value, reg_mask);
+		}
+
+		/*else {
+
+		   rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+		   reg_value, reg_mask);
+		   } */
+	}
+
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Set the USB transceiver's power supply configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       pwrin           USB transceiver regulator input power source
+ * @param       pwrout          USB transceiver regulator output power level
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's power supply
+ *                              configuration was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_set_power_source(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_POWER_IN
+					      pwrin,
+					      const PMIC_CONVITY_USB_POWER_OUT
+					      pwrout)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+	/* SET_BITS(regUSB1, VUSBEN, 1) | SET_BITS(regUSB1, VBUSEN,
+	   1) | SET_BITS(regUSB1,
+	   VUSBIN,
+	   2) | */
+/*	    SET_BITS(regUSB1, VUSB, 1); */
+/*	    SET_BITS(regUSB1, VUSBIN, 1) | SET_BITS(regUSB1, VUSBEN,
+						    1) | SET_BITS(regUSB1,
+								  VBUSEN, 1);*/
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+
+		if (pwrin == USB_POWER_INTERNAL_BOOST) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 0);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		} else if (pwrin == USB_POWER_VBUS) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 1);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		}
+
+		else if (pwrin == USB_POWER_INTERNAL) {
+			reg_value |= SET_BITS(regUSB1, VUSBIN, 2);
+			reg_mask = SET_BITS(regUSB1, VUSBIN, 1);
+		}
+
+		if (pwrout == USB_POWER_3V3) {
+			reg_value |= SET_BITS(regUSB1, VUSB, 1);
+			reg_mask |= SET_BITS(regUSB1, VUSB, 1);
+		}
+
+		else if (pwrout == USB_POWER_2V775) {
+			reg_value |= SET_BITS(regUSB1, VUSB, 0);
+			reg_mask |= SET_BITS(regUSB1, VUSB, 1);
+		}
+		rc = pmic_write_reg(REG_CHARGE_USB_SPARE, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			usb.usbPowerIn = pwrin;
+			usb.usbPowerOut = pwrout;
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the USB transceiver's current power supply configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       pwrin           USB transceiver regulator input power source
+ * @param       pwrout          USB transceiver regulator output power level
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's power supply
+ *                              configuration was successfully retrieved
+ */
+PMIC_STATUS pmic_convity_usb_get_power_source(const PMIC_CONVITY_HANDLE handle,
+					      PMIC_CONVITY_USB_POWER_IN *
+					      const pwrin,
+					      PMIC_CONVITY_USB_POWER_OUT *
+					      const pwrout)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
+	    (pwrin != (PMIC_CONVITY_USB_POWER_IN *) NULL) &&
+	    (pwrout != (PMIC_CONVITY_USB_POWER_OUT *) NULL)) {
+		*pwrin = usb.usbPowerIn;
+		*pwrout = usb.usbPowerOut;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Set the USB transceiver's operating mode.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            desired operating mode
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's operating mode
+ *                              was successfully configured
+ */
+PMIC_STATUS pmic_convity_usb_set_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_USB_TRANSCEIVER_MODE
+				      mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+
+		if (mode == USB_TRANSCEIVER_OFF) {
+			reg_value = SET_BITS(regUSB0, USBXCVREN, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+
+			rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		}
+
+		if (mode == USB_SINGLE_ENDED_UNIDIR) {
+			reg_value |=
+			    SET_BITS(regUSB0, DATSE0, 1) | SET_BITS(regUSB0,
+								    BIDIR, 0);
+			reg_mask |=
+			    SET_BITS(regUSB0, USB_SUSPEND,
+				     1) | SET_BITS(regUSB0, DATSE0,
+						   1) | SET_BITS(regUSB0, BIDIR,
+								 1);
+		} else if (mode == USB_SINGLE_ENDED_BIDIR) {
+			reg_value |=
+			    SET_BITS(regUSB0, DATSE0, 1) | SET_BITS(regUSB0,
+								    BIDIR, 1);
+			reg_mask |=
+			    SET_BITS(regUSB0, USB_SUSPEND,
+				     1) | SET_BITS(regUSB0, DATSE0,
+						   1) | SET_BITS(regUSB0, BIDIR,
+								 1);
+		} else if (mode == USB_DIFFERENTIAL_UNIDIR) {
+			reg_value |=
+			    SET_BITS(regUSB0, DATSE0, 0) | SET_BITS(regUSB0,
+								    BIDIR, 0);
+			reg_mask |=
+			    SET_BITS(regUSB0, USB_SUSPEND,
+				     1) | SET_BITS(regUSB0, DATSE0,
+						   1) | SET_BITS(regUSB0, BIDIR,
+								 1);
+		} else if (mode == USB_DIFFERENTIAL_BIDIR) {
+			reg_value |=
+			    SET_BITS(regUSB0, DATSE0, 0) | SET_BITS(regUSB0,
+								    BIDIR, 1);
+			reg_mask |=
+			    SET_BITS(regUSB0, USB_SUSPEND,
+				     1) | SET_BITS(regUSB0, DATSE0,
+						   1) | SET_BITS(regUSB0, BIDIR,
+								 1);
+		}
+
+		if (mode == USB_SUSPEND_ON) {
+			reg_value |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		} else if (mode == USB_SUSPEND_OFF) {
+			reg_value |= SET_BITS(regUSB0, USB_SUSPEND, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		}
+
+		if (mode == USB_OTG_SRP_DLP_START) {
+			reg_value |= SET_BITS(regUSB0, USB_PU, 0);
+			reg_mask |= SET_BITS(regUSB0, USB_SUSPEND, 1);
+		} else if (mode == USB_OTG_SRP_DLP_STOP) {
+			reg_value &= SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+		}
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			usb.usbXcvrMode = mode;
+
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the USB transceiver's current operating mode.
+ *
+ * @param       handle          device handle from open() call
+ * @param       mode            current operating mode
+ *
+ * @return      PMIC_SUCCESS    if the USB transceiver's operating mode
+ *                              was successfully retrieved
+ */
+PMIC_STATUS pmic_convity_usb_get_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_USB_TRANSCEIVER_MODE *
+				      const mode)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
+	    (mode != (PMIC_CONVITY_USB_TRANSCEIVER_MODE *) NULL)) {
+		*mode = usb.usbXcvrMode;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Set the Data Line Pulse duration (in milliseconds) for the USB OTG
+ * Session Request Protocol.
+ *
+ * For mc13783, this feature is not supported.So return PMIC_NOT_SUPPORTED
+ *
+ * @param       handle          device handle from open() call
+ * @param       duration        the data line pulse duration (ms)
+ *
+ * @return      PMIC_SUCCESS    if the pulse duration was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  const unsigned int duration)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+	/* The setting of the dlp duration is not supported by the mc13783 PMIC hardware. */
+
+	/* No critical section is required. */
+
+	if ((handle != usb.handle)
+	    || (usb.handle_state != HANDLE_IN_USE)) {
+		/* Must return error indication for invalid handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+	}
+
+	return rc;
+}
+
+/*!
+ * Get the current Data Line Pulse duration (in milliseconds) for the USB
+ * OTG Session Request Protocol.
+ *
+ * @param       handle          device handle from open() call
+ * @param       duration        the data line pulse duration (ms)
+ *
+ * @return      PMIC_SUCCESS    if the pulse duration was successfully obtained
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  unsigned int *const duration)
+{
+	PMIC_STATUS rc = PMIC_NOT_SUPPORTED;
+
+	/* The setting of dlp duration is not supported by the mc13783 PMIC hardware. */
+
+	/* No critical section is required. */
+
+	if ((handle != usb.handle)
+	    || (usb.handle_state != HANDLE_IN_USE)) {
+		/* Must return error indication for invalid handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+	}
+
+	return rc;
+}
+
+/*!
+ * Set the USB On-The-Go (OTG) configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfg             desired USB OTG configuration
+ *
+ * @return      PMIC_SUCCESS    if the OTG configuration was successfully set
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_config(const PMIC_CONVITY_HANDLE handle,
+					    const PMIC_CONVITY_USB_OTG_CONFIG
+					    cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+		if (cfg & USB_OTG_SE0CONN) {
+			reg_value = SET_BITS(regUSB0, SE0_CONN, 1);
+			reg_mask = SET_BITS(regUSB0, SE0_CONN, 1);
+		}
+		if (cfg & USBXCVREN) {
+			reg_value |= SET_BITS(regUSB0, USBXCVREN, 1);
+			reg_mask |= SET_BITS(regUSB0, USBXCVREN, 1);
+		}
+
+		if (cfg & USB_OTG_DLP_SRP) {
+			reg_value |= SET_BITS(regUSB0, DLP_SRP, 1);
+			reg_mask |= SET_BITS(regUSB0, DLP_SRP, 1);
+		}
+
+		if (cfg & USB_PULL_OVERRIDE) {
+			reg_value |= SET_BITS(regUSB0, PULLOVR, 1);
+			reg_mask |= SET_BITS(regUSB0, PULLOVR, 1);
+		}
+
+		if (cfg & USB_PU) {
+			reg_value |= SET_BITS(regUSB0, USB_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+		}
+
+		if (cfg & USB_UDM_PD) {
+			reg_value |= SET_BITS(regUSB0, UDM_PD, 1);
+			reg_mask |= SET_BITS(regUSB0, UDM_PD, 1);
+		}
+
+		if (cfg & USB_UDP_PD) {
+			reg_value |= SET_BITS(regUSB0, UDP_PD, 1);
+			reg_mask |= SET_BITS(regUSB0, UDP_PD, 1);
+		}
+
+		if (cfg & USB_DP150K_PU) {
+			reg_value |= SET_BITS(regUSB0, DP150K_PU, 1);
+			reg_mask |= SET_BITS(regUSB0, DP150K_PU, 1);
+		}
+
+		if (cfg & USB_USBCNTRL) {
+			reg_value |= SET_BITS(regUSB0, USBCNTRL, 1);
+			reg_mask |= SET_BITS(regUSB0, USBCNTRL, 1);
+		}
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_HIGH)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 0);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 1);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 2);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 3);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 4);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 5);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 6);
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_LOW) {
+			reg_value |= SET_BITS(regUSB0, CURRENT_LIMIT, 7);
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 7);
+		}
+
+		if (cfg & USB_VBUS_PULLDOWN) {
+			reg_value |= SET_BITS(regUSB0, VBUSPDENB, 1);
+			reg_mask |= SET_BITS(regUSB0, VBUSPDENB, 1);
+		}
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS) {
+			if ((cfg & USB_VBUS_CURRENT_LIMIT_HIGH) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS) ||
+			    (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)) {
+				/* Make sure that the VBUS current limit state is
+				 * correctly set to either USB_VBUS_CURRENT_LIMIT_HIGH
+				 * or USB_VBUS_CURRENT_LIMIT_LOW but never both at the
+				 * same time.
+				 *
+				 * We guarantee this by first clearing both of the
+				 * status bits and then resetting the correct one.
+				 */
+				usb.usbOtgCfg &=
+				    ~(USB_VBUS_CURRENT_LIMIT_HIGH |
+				      USB_VBUS_CURRENT_LIMIT_LOW |
+				      USB_VBUS_CURRENT_LIMIT_LOW_10MS |
+				      USB_VBUS_CURRENT_LIMIT_LOW_20MS |
+				      USB_VBUS_CURRENT_LIMIT_LOW_30MS |
+				      USB_VBUS_CURRENT_LIMIT_LOW_40MS |
+				      USB_VBUS_CURRENT_LIMIT_LOW_50MS |
+				      USB_VBUS_CURRENT_LIMIT_LOW_60MS);
+			}
+
+			usb.usbOtgCfg |= cfg;
+		}
+	}
+/*	} */
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Clears the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             USB OTG configuration settings to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_clear_config(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_OTG_CONFIG
+					      cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask = 0;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
+		/* if ((cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS) ||
+		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS) ||
+		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS) ||
+		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS) ||
+		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS) ||
+		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS))
+		   {
+		   rc = PMIC_NOT_SUPPORTED;
+		   } */
+/*		else */
+
+		if (cfg & USB_OTG_SE0CONN)
+			reg_mask = SET_BITS(regUSB0, SE0_CONN, 1);
+
+
+		if (cfg & USB_OTG_DLP_SRP)
+			reg_mask |= SET_BITS(regUSB0, DLP_SRP, 1);
+
+
+		if (cfg & USB_DP150K_PU)
+			reg_mask |= SET_BITS(regUSB0, DP150K_PU, 1);
+
+
+		if (cfg & USB_PULL_OVERRIDE)
+			reg_mask |= SET_BITS(regUSB0, PULLOVR, 1);
+
+
+		if (cfg & USB_PU)
+			reg_mask |= SET_BITS(regUSB0, USB_PU, 1);
+
+
+		if (cfg & USB_UDM_PD)
+			reg_mask |= SET_BITS(regUSB0, UDM_PD, 1);
+
+
+		if (cfg & USB_UDP_PD)
+			reg_mask |= SET_BITS(regUSB0, UDP_PD, 1);
+
+
+		if (cfg & USB_USBCNTRL)
+			reg_mask |= SET_BITS(regUSB0, USBCNTRL, 1);
+
+
+		if (cfg & USB_VBUS_CURRENT_LIMIT_HIGH)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 0);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 1);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 2);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 3);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_40MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 4);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_50MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 5);
+		else if (cfg & USB_VBUS_CURRENT_LIMIT_LOW_60MS)
+			reg_mask |= SET_BITS(regUSB0, CURRENT_LIMIT, 6);
+
+
+		if (cfg & USB_VBUS_PULLDOWN) {
+			/* reg_value |= SET_BITS(regUSB0, VBUSPDENB, 1); */
+			reg_mask |= SET_BITS(regUSB0, VBUSPDENB, 1);
+		}
+
+		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+		if (rc == PMIC_SUCCESS)
+			usb.usbOtgCfg &= ~cfg;
+
+	}
+/*	} */
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the current USB On-The-Go (OTG) configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfg             the current USB OTG configuration
+ *
+ * @return      PMIC_SUCCESS    if the OTG configuration was successfully
+ *                              retrieved
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_config(const PMIC_CONVITY_HANDLE handle,
+					    PMIC_CONVITY_USB_OTG_CONFIG *
+					    const cfg)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
+	    (cfg != (PMIC_CONVITY_USB_OTG_CONFIG *) NULL)) {
+		*cfg = usb.usbOtgCfg;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*@}*/
+
+/**************************************************************************
+ * RS-232-specific configuration and setup functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name RS-232 Serial Connectivity APIs
+ * Functions for controlling RS-232 serial connectivity.
+ */
+/*@{*/
+
+/*!
+ * Set the connectivity interface to the selected RS-232 operating
+ * configuration. Note that the RS-232 operating mode will be automatically
+ * overridden if the USB_EN is asserted at any time (e.g., when a USB device
+ * is attached). However, we will also automatically return to the RS-232
+ * mode once the USB device is detached.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfgInternal     RS-232 transceiver internal connections
+ * @param       cfgExternal     RS-232 transceiver external connections
+ *
+ * @return      PMIC_SUCCESS    if the requested mode was set
+ */
+PMIC_STATUS pmic_convity_rs232_set_config(const PMIC_CONVITY_HANDLE handle,
+					  const PMIC_CONVITY_RS232_INTERNAL
+					  cfgInternal,
+					  const PMIC_CONVITY_RS232_EXTERNAL
+					  cfgExternal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value0 = 0, reg_value1 = 0;
+	unsigned int reg_mask = SET_BITS(regUSB1, RSPOL, 1);
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == rs_232.handle) && (rs_232.handle_state == HANDLE_IN_USE)) {
+		rc = PMIC_SUCCESS;
+
+		/* Validate the calling parameters. */
+		/*if ((cfgInternal !=  RS232_TX_USE0VM_RX_UDATVP) &&
+		   (cfgInternal != RS232_TX_RX_INTERNAL_DEFAULT) && (cfgInternal !=  RS232_TX_UDATVP_RX_URXVM))
+		   {
+
+		   rc = PMIC_NOT_SUPPORTED;
+		   } */
+		if (cfgInternal == RS232_TX_USE0VM_RX_UDATVP) {
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 1);
+
+		} else if (cfgInternal == RS232_TX_RX_INTERNAL_DEFAULT) {
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 1);
+			reg_mask |= SET_BITS(regUSB1, RSPOL, 1);
+
+		} else if (cfgInternal == RS232_TX_UDATVP_RX_URXVM) {
+
+			reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 2);
+			reg_value1 |= SET_BITS(regUSB1, RSPOL, 1);
+
+		} else if ((cfgExternal == RS232_TX_UDM_RX_UDP) ||
+			   (cfgExternal == RS232_TX_RX_EXTERNAL_DEFAULT)) {
+			/* Configure for TX on D+ and RX on D-. */
+			reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 1);
+			reg_value1 |= SET_BITS(regUSB1, RSPOL, 0);
+		} else if (cfgExternal != RS232_TX_UDM_RX_UDP) {
+			/* Any other RS-232 configuration is an error. */
+			rc = PMIC_ERROR;
+		}
+
+		if (rc == PMIC_SUCCESS) {
+			/* Configure for TX on D- and RX on D+. */
+			rc = pmic_write_reg(REG_USB, reg_value0, reg_mask);
+
+			rc = pmic_write_reg(REG_CHARGE_USB_SPARE,
+					    reg_value1, reg_mask);
+
+			if (rc == PMIC_SUCCESS) {
+				rs_232.rs232CfgInternal = cfgInternal;
+				rs_232.rs232CfgExternal = cfgExternal;
+			}
+		}
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*!
+ * Get the connectivity interface's current RS-232 operating configuration.
+ *
+ * @param       handle          device handle from open() call
+ * @param       cfgInternal     RS-232 transceiver internal connections
+ * @param       cfgExternal     RS-232 transceiver external connections
+ *
+ * @return      PMIC_SUCCESS    if the requested mode was retrieved
+ */
+PMIC_STATUS pmic_convity_rs232_get_config(const PMIC_CONVITY_HANDLE handle,
+					  PMIC_CONVITY_RS232_INTERNAL *
+					  const cfgInternal,
+					  PMIC_CONVITY_RS232_EXTERNAL *
+					  const cfgExternal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle == rs_232.handle) &&
+	    (rs_232.handle_state == HANDLE_IN_USE) &&
+	    (cfgInternal != (PMIC_CONVITY_RS232_INTERNAL *) NULL) &&
+	    (cfgExternal != (PMIC_CONVITY_RS232_EXTERNAL *) NULL)) {
+		*cfgInternal = rs_232.rs232CfgInternal;
+		*cfgExternal = rs_232.rs232CfgExternal;
+
+		rc = PMIC_SUCCESS;
+	}
+
+	/* Exit the critical section. */
+	up(&mutex);
+
+	return rc;
+}
+
+/*@}*/
+
+/**************************************************************************
+ * CEA-936-specific configuration and setup functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name CEA-936 Connectivity APIs
+ * Functions for controlling CEA-936 connectivity.
+ */
+/*@{*/
+
+/*!
+ * Signal the attached device to exit the current CEA-936 operating mode.
+ * Returns an error if the current operating mode is not CEA-936.
+ *
+ * @param       handle          device handle from open() call
+ * @param       signal          type of exit signal to be sent
+ *
+ * @return      PMIC_SUCCESS    if exit signal was sent
+ */
+PMIC_STATUS pmic_convity_cea936_exit_signal(const PMIC_CONVITY_HANDLE handle,
+					    const
+					    PMIC_CONVITY_CEA936_EXIT_SIGNAL
+					    signal)
+{
+	PMIC_STATUS rc = PMIC_ERROR;
+	unsigned int reg_value = 0;
+	unsigned int reg_mask =
+	    SET_BITS(regUSB0, IDPD, 1) | SET_BITS(regUSB0, IDPULSE, 1);
+
+	/* Use a critical section to maintain a consistent state. */
+	if (down_interruptible(&mutex))
+		return PMIC_SYSTEM_ERROR_EINTR;
+
+	if ((handle != cea_936.handle)
+	    || (cea_936.handle_state != HANDLE_IN_USE)) {
+		/* Must return error indication for invalid handle parameter to be
+		 * consistent with other APIs.
+		 */
+		rc = PMIC_ERROR;
+	} else if (signal == CEA936_UID_PULLDOWN_6MS) {
+		reg_value =
+		    SET_BITS(regUSB0, IDPULSE, 0) | SET_BITS(regUSB0, IDPD, 0);
+	} else if (signal == CEA936_UID_PULLDOWN_6MS) {
+		reg_value = SET_BITS(regUSB0, IDPULSE, 1);
+	} else if (signal == CEA936_UID_PULLDOWN) {
+		reg_value = SET_BITS(regUSB0, IDPD, 1);
+	} else if (signal == CEA936_UDMPULSE) {
+		reg_value = SET_BITS(regUSB0, DMPULSE, 1);
+	}
+
+	rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+
+	up(&mutex);
+
+	return rc;
+}
+
+/*@}*/
+
+/**************************************************************************
+ * Static functions.
+ **************************************************************************
+ */
+
+/*!
+ * @name Connectivity Driver Internal Support Functions
+ * These non-exported internal functions are used to support the functionality
+ * of the exported connectivity APIs.
+ */
+/*@{*/
+
+/*!
+ * This internal helper function sets the desired operating mode (either USB
+ * OTG or RS-232). It must be called with the mutex already acquired.
+ *
+ * @param       mode               the desired operating mode (USB or RS232)
+ *
+ * @return      PMIC_SUCCESS       if the desired operating mode was set
+ * @return      PMIC_NOT_SUPPORTED if the desired operating mode is invalid
+ */
+static PMIC_STATUS pmic_convity_set_mode_internal(const PMIC_CONVITY_MODE mode)
+{
+	unsigned int reg_value0 = 0, reg_value1 = 0;
+	unsigned int reg_mask0 = 0, reg_mask1 = 0;
+
+/* 	unsigned int reg_mask1 = SET_BITS(regUSB1, VBUSEN, 1); */
+
+	PMIC_STATUS rc = PMIC_SUCCESS;
+
+	switch (mode) {
+	case USB:
+		/* For the USB mode, we start by tri-stating the USB bus (by
+		 * setting VBUSEN = 0) until a device is connected (i.e.,
+		 * until we receive a 4.4V rising edge event). All pull-up
+		 * and pull-down resistors are also disabled until a USB
+		 * device is actually connected and we have determined which
+		 * device is the host and the desired USB bus speed.
+		 *
+		 * Also tri-state the RS-232 buffers (by setting RSTRI = 1).
+		 * This prevents the hardware from automatically returning to
+		 * the RS-232 mode when the USB device is detached.
+		 */
+
+		reg_value0 = SET_BITS(regUSB0, INTERFACE_MODE, 0);
+		reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+		/*reg_value1 = SET_BITS(regUSB1, RSTRI, 1); */
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+		/*      if (rc == PMIC_SUCCESS) {
+		   CHECK_ERROR(pmic_write_reg
+		   (REG_CHARGE_USB_SPARE,
+		   reg_value1, reg_mask1));
+		   } */
+
+		break;
+
+	case RS232_1:
+		/* For the RS-232 mode, we tri-state the USB bus (by setting
+		 * VBUSEN = 0) and enable the RS-232 transceiver (by setting
+		 * RS232ENB = 0).
+		 *
+		 * Note that even in the RS-232 mode, if a USB device is
+		 * plugged in, we will receive a 4.4V rising edge event which
+		 * will automatically disable the RS-232 transceiver and
+		 * tri-state the RS-232 buffers. This allows us to temporarily
+		 * switch over to USB mode while the USB device is attached.
+		 * The RS-232 transceiver and buffers will be automatically
+		 * re-enabled when the USB device is detached.
+		 */
+
+		/* Explicitly disconnect all of the USB pull-down resistors
+		 * and the VUSB power regulator here just to be safe.
+		 *
+		 * But we do connect the internal pull-up resistor on USB_D+
+		 * to avoid having an extra load on the USB_D+ line when in
+		 * RS-232 mode.
+		 */
+
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 1) |
+		    SET_BITS(regUSB0, VBUSPDENB, 1) |
+		    SET_BITS(regUSB0, USB_PU, 1);
+		reg_mask0 =
+		    SET_BITS(regUSB0, INTERFACE_MODE, 7) | SET_BITS(regUSB0,
+								    VBUSPDENB,
+								    1) |
+		    SET_BITS(regUSB0, USB_PU, 1);
+
+		reg_value1 = SET_BITS(regUSB1, RSPOL, 0);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+
+		if (rc == PMIC_SUCCESS) {
+			CHECK_ERROR(pmic_write_reg
+				    (REG_CHARGE_USB_SPARE,
+				     reg_value1, reg_mask1));
+		}
+		break;
+
+	case RS232_2:
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 2) |
+		    SET_BITS(regUSB0, VBUSPDENB, 1) |
+		    SET_BITS(regUSB0, USB_PU, 1);
+		reg_mask0 =
+		    SET_BITS(regUSB0, INTERFACE_MODE, 7) | SET_BITS(regUSB0,
+								    VBUSPDENB,
+								    1) |
+		    SET_BITS(regUSB0, USB_PU, 1);
+
+		reg_value1 = SET_BITS(regUSB1, RSPOL, 1);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+
+		if (rc == PMIC_SUCCESS) {
+			CHECK_ERROR(pmic_write_reg
+				    (REG_CHARGE_USB_SPARE,
+				     reg_value1, reg_mask1));
+		}
+		break;
+
+	case CEA936_MONO:
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 4);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+		break;
+
+	case CEA936_STEREO:
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 5);
+		reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+		break;
+
+	case CEA936_TEST_RIGHT:
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 6);
+		reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+		break;
+
+	case CEA936_TEST_LEFT:
+		reg_value0 |= SET_BITS(regUSB0, INTERFACE_MODE, 7);
+		reg_mask0 = SET_BITS(regUSB0, INTERFACE_MODE, 7);
+
+		rc = pmic_write_reg(REG_USB, reg_value0, reg_mask0);
+		break;
+
+	default:
+		rc = PMIC_NOT_SUPPORTED;
+	}
+
+	if (rc == PMIC_SUCCESS) {
+		if (mode == USB) {
+			usb.mode = mode;
+		} else if ((mode == RS232_1) || (mode == RS232_1)) {
+			rs_232.mode = mode;
+		} else if ((mode == CEA936_MONO) || (mode == CEA936_STEREO) ||
+			   (mode == CEA936_TEST_RIGHT)
+			   || (mode == CEA936_TEST_LEFT)) {
+			cea_936.mode = mode;
+		}
+	}
+
+	return rc;
+}
+
+/*!
+ * This internal helper function deregisters all of the currently registered
+ * callback events. It must be called with the mutual exclusion spinlock
+ * already acquired.
+ *
+ * We've defined the event and callback deregistration code here as a separate
+ * function because it can be called by either the pmic_convity_close() or the
+ * pmic_convity_clear_callback() APIs. We also wanted to avoid any possible
+ * issues with having the same thread calling spin_lock_irq() twice.
+ *
+ * Note that the mutex must have already been acquired. We will also acquire
+ * the spinlock here to avoid any possible race conditions with the interrupt
+ * handler.
+ *
+ * @return      PMIC_SUCCESS    if all of the callback events were cleared
+ */
+static PMIC_STATUS pmic_convity_deregister_all(void)
+{
+	unsigned long flags;
+	PMIC_STATUS rc = PMIC_SUCCESS;
+
+	/* Deregister each of the PMIC events that we had previously
+	 * registered for by using pmic_event_subscribe().
+	 */
+
+	if ((usb.eventMask & USB_DETECT_MINI_A) ||
+	    (usb.eventMask & USB_DETECT_MINI_B) ||
+	    (usb.eventMask & USB_DETECT_NON_USB_ACCESSORY) ||
+	    (usb.eventMask & USB_DETECT_FACTORY_MODE)) {
+		/* EVENT_AB_DETI or EVENT_IDI */
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_ABDET);
+
+		if (pmic_event_unsubscribe(EVENT_IDI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+
+			spin_lock_irqsave(&lock, flags);
+
+			usb.eventMask &= ~(USB_DETECT_MINI_A |
+					   USB_DETECT_MINI_B |
+					   USB_DETECT_NON_USB_ACCESSORY |
+					   USB_DETECT_FACTORY_MODE);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+			    ("%s: pmic_event_unsubscribe() for EVENT_AB_DETI failed\n",
+			     __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	else if ((usb.eventMask & USB_DETECT_0V8_RISE) ||
+		 (usb.eventMask & USB_DETECT_0V8_FALL)) {
+		/* EVENT_USB_08VI or EVENT_USBI */
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_0V8);
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			usb.eventMask &= ~(USB_DETECT_0V8_RISE |
+					   USB_DETECT_0V8_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+			    ("%s: pmic_event_unsubscribe() for EVENT_USB_08VI failed\n",
+			     __FILE__);
+			rc = PMIC_ERROR;
+		}
+
+	}
+
+	else if ((usb.eventMask & USB_DETECT_2V0_RISE) ||
+		 (usb.eventMask & USB_DETECT_2V0_FALL)) {
+		/* EVENT_USB_20VI or EVENT_USBI */
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_2V0);
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+		    PMIC_SUCCESS) {
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			usb.eventMask &= ~(USB_DETECT_2V0_RISE |
+					   USB_DETECT_2V0_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+			    ("%s: pmic_event_unsubscribe() for EVENT_USB_20VI failed\n",
+			     __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	else if ((usb.eventMask & USB_DETECT_4V4_RISE) ||
+		 (usb.eventMask & USB_DETECT_4V4_FALL)) {
+
+		/* EVENT_USB_44VI or EVENT_USBI */
+		eventNotify.func = pmic_convity_event_handler;
+		eventNotify.param = (void *)(CORE_EVENT_4V4);
+
+		if (pmic_event_unsubscribe(EVENT_USBI, eventNotify) ==
+		    PMIC_SUCCESS) {
+
+			/* Also acquire the spinlock here to avoid any possible race
+			 * conditions with the interrupt handler.
+			 */
+			spin_lock_irqsave(&lock, flags);
+
+			usb.eventMask &= ~(USB_DETECT_4V4_RISE |
+					   USB_DETECT_4V4_FALL);
+
+			spin_unlock_irqrestore(&lock, flags);
+		} else {
+			pr_debug
+			    ("%s: pmic_event_unsubscribe() for EVENT_USB_44VI failed\n",
+			     __FILE__);
+			rc = PMIC_ERROR;
+		}
+	}
+
+	if (rc == PMIC_SUCCESS) {
+		/* Also acquire the spinlock here to avoid any possible race
+		 * conditions with the interrupt handler.
+		 */
+		spin_lock_irqsave(&lock, flags);
+
+		/* Restore the initial reset values for the callback function
+		 * and event mask parameters. This should be NULL and zero,
+		 * respectively.
+		 *
+		 * Note that we wait until the end here to fully reset everything
+		 * just in case some of the pmic_event_unsubscribe() calls above
+		 * failed for some reason (which normally shouldn't happen).
+		 */
+		usb.callback = reset.callback;
+		usb.eventMask = reset.eventMask;
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+	return rc;
+}
+
+/*!
+ * This is the default event handler for all connectivity-related events
+ * and hardware interrupts.
+ *
+ * @param       param           event ID
+ */
+static void pmic_convity_event_handler(void *param)
+{
+	unsigned long flags;
+
+	/* Update the global list of active interrupt events. */
+	spin_lock_irqsave(&lock, flags);
+	eventID |= (PMIC_CORE_EVENT) (param);
+	spin_unlock_irqrestore(&lock, flags);
+
+	/* Schedule the tasklet to be run as soon as it is convenient to do so. */
+	schedule_work(&convityTasklet);
+}
+
+/*!
+ * @brief This is the connectivity driver tasklet that handles interrupt events.
+ *
+ * This function is scheduled by the connectivity driver interrupt handler
+ * pmic_convity_event_handler() to complete the processing of all of the
+ * connectivity-related interrupt events.
+ *
+ * Since this tasklet runs with interrupts enabled, we can safely call
+ * the ADC driver, if necessary, to properly detect the type of USB connection
+ * that is being made and to call any user-registered callback functions.
+ *
+ * @param   arg                The parameter that was provided above in
+ *                                  the DECLARE_TASKLET() macro (unused).
+ */
+static void pmic_convity_tasklet(struct work_struct *work)
+{
+
+	PMIC_CONVITY_EVENTS activeEvents = 0;
+	unsigned long flags = 0;
+
+	/* Check the interrupt sense bits to determine exactly what
+	 * event just occurred.
+	 */
+	if (eventID & CORE_EVENT_4V4) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_4V4;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents |= pmic_check_sensor(SENSE_USB4V4S) ?
+		    USB_DETECT_4V4_RISE : USB_DETECT_4V4_FALL;
+
+		if (activeEvents & ~usb.eventMask) {
+			/* The default handler for 4.4 V rising/falling edge detection
+			 * is to simply ignore the event.
+			 */
+			;
+		}
+	}
+	if (eventID & CORE_EVENT_2V0) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_2V0;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents |= pmic_check_sensor(SENSE_USB2V0S) ?
+		    USB_DETECT_2V0_RISE : USB_DETECT_2V0_FALL;
+		if (activeEvents & ~usb.eventMask) {
+			/* The default handler for 2.0 V rising/falling edge detection
+			 * is to simply ignore the event.
+			 */
+			;
+		}
+	}
+	if (eventID & CORE_EVENT_0V8) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_0V8;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents |= pmic_check_sensor(SENSE_USB0V8S) ?
+		    USB_DETECT_0V8_RISE : USB_DETECT_0V8_FALL;
+
+		if (activeEvents & ~usb.eventMask) {
+			/* The default handler for 0.8 V rising/falling edge detection
+			 * is to simply ignore the event.
+			 */
+			;
+		}
+	}
+	if (eventID & CORE_EVENT_ABDET) {
+		spin_lock_irqsave(&lock, flags);
+		eventID &= ~CORE_EVENT_ABDET;
+		spin_unlock_irqrestore(&lock, flags);
+
+		activeEvents |= pmic_check_sensor(SENSE_ID_GNDS) ?
+		    USB_DETECT_MINI_A : 0;
+
+		activeEvents |= pmic_check_sensor(SENSE_ID_FLOATS) ?
+		    USB_DETECT_MINI_B : 0;
+	}
+
+	/* Begin a critical section here so that we don't register/deregister
+	 * for events or open/close the connectivity driver while the existing
+	 * event handler (if it is currently defined) is in the middle of handling
+	 * the current event.
+	 */
+	spin_lock_irqsave(&lock, flags);
+
+	/* Finally, call the user-defined callback function if required. */
+	if ((usb.handle_state == HANDLE_IN_USE) &&
+	    (usb.callback != NULL) && (activeEvents & usb.eventMask)) {
+		(*usb.callback) (activeEvents);
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/*@}*/
+
+/**************************************************************************
+ * Module initialization and termination functions.
+ *
+ * Note that if this code is compiled into the kernel, then the
+ * module_init() function will be called within the device_initcall()
+ * group.
+ **************************************************************************
+ */
+
+/*!
+ * @name Connectivity Driver Loading/Unloading Functions
+ * These non-exported internal functions are used to support the connectivity
+ * device driver initialization and de-initialization operations.
+ */
+/*@{*/
+
+/*!
+ * @brief This is the connectivity device driver initialization function.
+ *
+ * This function is called by the kernel when this device driver is first
+ * loaded.
+ */
+static int __init mc13783_pmic_convity_init(void)
+{
+	printk(KERN_INFO "PMIC Connectivity driver loading..\n");
+
+	return 0;
+}
+
+/*!
+ * @brief This is the Connectivity device driver de-initialization function.
+ *
+ * This function is called by the kernel when this device driver is about
+ * to be unloaded.
+ */
+static void __exit mc13783_pmic_convity_exit(void)
+{
+	printk(KERN_INFO "PMIC Connectivity driver unloading\n");
+
+	/* Close the device handle if it is still open. This will also
+	 * deregister any callbacks that may still be active.
+	 */
+	if (usb.handle_state == HANDLE_IN_USE)
+		pmic_convity_close(usb.handle);
+	else if (usb.handle_state == HANDLE_IN_USE)
+		pmic_convity_close(rs_232.handle);
+	else if (usb.handle_state == HANDLE_IN_USE)
+		pmic_convity_close(cea_936.handle);
+
+
+	/* Reset the PMIC Connectivity register to it's power on state.
+	 * We should do this when unloading the module so that we don't
+	 * leave the hardware in a state which could cause problems when
+	 * no device driver is loaded.
+	 */
+	pmic_write_reg(REG_USB, RESET_USBCNTRL_REG_0, REG_FULLMASK);
+	pmic_write_reg(REG_CHARGE_USB_SPARE, RESET_USBCNTRL_REG_1,
+		       REG_FULLMASK);
+	/* Note that there is no need to reset the "convity" device driver
+	 * state structure to the reset state since we are in the final
+	 * stage of unloading the device driver. The device driver state
+	 * structure will be automatically and properly reinitialized if
+	 * this device driver is reloaded.
+	 */
+}
+
+/*@}*/
+
+/*
+ * Module entry points and description information.
+ */
+
+module_init(mc13783_pmic_convity_init);
+module_exit(mc13783_pmic_convity_exit);
+
+MODULE_DESCRIPTION("mc13783 Connectivity device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_light.c b/drivers/mxc/pmic/mc13783/pmic_light.c
new file mode 100644
index 0000000..3aeadab
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_light.c
@@ -0,0 +1,2769 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_light.c
+ * @brief This is the main file of PMIC(mc13783) Light and Backlight driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+/*
+ * Includes
+ */
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/pmic_light.h>
+#include <linux/pmic_status.h>
+#include "pmic_light_defs.h"
+
+#define NB_LIGHT_REG      6
+
+static int pmic_light_major;
+
+/*!
+ * Number of users waiting in suspendq
+ */
+static int swait;
+
+/*!
+ * To indicate whether any of the light devices are suspending
+ */
+static int suspend_flag;
+
+/*!
+ * The suspendq is used to block application calls
+ */
+static wait_queue_head_t suspendq;
+
+static struct class *pmic_light_class;
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_bklit_tcled_master_enable);
+EXPORT_SYMBOL(pmic_bklit_tcled_master_disable);
+EXPORT_SYMBOL(pmic_bklit_master_enable);
+EXPORT_SYMBOL(pmic_bklit_master_disable);
+EXPORT_SYMBOL(pmic_bklit_set_current);
+EXPORT_SYMBOL(pmic_bklit_get_current);
+EXPORT_SYMBOL(pmic_bklit_set_dutycycle);
+EXPORT_SYMBOL(pmic_bklit_get_dutycycle);
+EXPORT_SYMBOL(pmic_bklit_set_cycle_time);
+EXPORT_SYMBOL(pmic_bklit_get_cycle_time);
+EXPORT_SYMBOL(pmic_bklit_set_mode);
+EXPORT_SYMBOL(pmic_bklit_get_mode);
+EXPORT_SYMBOL(pmic_bklit_rampup);
+EXPORT_SYMBOL(pmic_bklit_off_rampup);
+EXPORT_SYMBOL(pmic_bklit_rampdown);
+EXPORT_SYMBOL(pmic_bklit_off_rampdown);
+EXPORT_SYMBOL(pmic_bklit_enable_edge_slow);
+EXPORT_SYMBOL(pmic_bklit_disable_edge_slow);
+EXPORT_SYMBOL(pmic_bklit_get_edge_slow);
+EXPORT_SYMBOL(pmic_bklit_set_strobemode);
+EXPORT_SYMBOL(pmic_tcled_enable);
+EXPORT_SYMBOL(pmic_tcled_disable);
+EXPORT_SYMBOL(pmic_tcled_get_mode);
+EXPORT_SYMBOL(pmic_tcled_ind_set_current);
+EXPORT_SYMBOL(pmic_tcled_ind_get_current);
+EXPORT_SYMBOL(pmic_tcled_ind_set_blink_pattern);
+EXPORT_SYMBOL(pmic_tcled_ind_get_blink_pattern);
+EXPORT_SYMBOL(pmic_tcled_fun_set_current);
+EXPORT_SYMBOL(pmic_tcled_fun_get_current);
+EXPORT_SYMBOL(pmic_tcled_fun_set_cycletime);
+EXPORT_SYMBOL(pmic_tcled_fun_get_cycletime);
+EXPORT_SYMBOL(pmic_tcled_fun_set_dutycycle);
+EXPORT_SYMBOL(pmic_tcled_fun_get_dutycycle);
+EXPORT_SYMBOL(pmic_tcled_fun_blendedramps);
+EXPORT_SYMBOL(pmic_tcled_fun_sawramps);
+EXPORT_SYMBOL(pmic_tcled_fun_blendedbowtie);
+EXPORT_SYMBOL(pmic_tcled_fun_chasinglightspattern);
+EXPORT_SYMBOL(pmic_tcled_fun_strobe);
+EXPORT_SYMBOL(pmic_tcled_fun_rampup);
+EXPORT_SYMBOL(pmic_tcled_get_fun_rampup);
+EXPORT_SYMBOL(pmic_tcled_fun_rampdown);
+EXPORT_SYMBOL(pmic_tcled_get_fun_rampdown);
+EXPORT_SYMBOL(pmic_tcled_fun_triode_on);
+EXPORT_SYMBOL(pmic_tcled_fun_triode_off);
+EXPORT_SYMBOL(pmic_tcled_enable_edge_slow);
+EXPORT_SYMBOL(pmic_tcled_disable_edge_slow);
+EXPORT_SYMBOL(pmic_tcled_enable_half_current);
+EXPORT_SYMBOL(pmic_tcled_disable_half_current);
+EXPORT_SYMBOL(pmic_tcled_enable_audio_modulation);
+EXPORT_SYMBOL(pmic_tcled_disable_audio_modulation);
+EXPORT_SYMBOL(pmic_bklit_set_boost_mode);
+EXPORT_SYMBOL(pmic_bklit_get_boost_mode);
+EXPORT_SYMBOL(pmic_bklit_config_boost_mode);
+EXPORT_SYMBOL(pmic_bklit_gets_boost_mode);
+
+/*!
+ * This is the suspend of power management for the pmic light API.
+ * It suports SAVE and POWER_DOWN state.
+ *
+ * @param        pdev           the device
+ * @param        state          the state
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_suspend(struct platform_device *dev, pm_message_t state)
+{
+	suspend_flag = 1;
+	/* switch off all leds and backlights */
+	CHECK_ERROR(pmic_light_init_reg());
+
+	return 0;
+};
+
+/*!
+ * This is the resume of power management for the pmic light API.
+ * It suports RESTORE state.
+ *
+ * @param        dev            the device
+ *
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_resume(struct platform_device *pdev)
+{
+	suspend_flag = 0;
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	reg_value = BITFVAL(BIT_LEDEN, 1);
+	mask = BITFMASK(BIT_LEDEN);
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	reg_value = BITFVAL(BIT_LEDEN, 0);
+	mask = BITFMASK(BIT_LEDEN);
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables backlight. Not supported on mc13783
+ * Use pmic_bklit_tcled_master_enable.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED
+ */
+PMIC_STATUS pmic_bklit_master_enable(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function disables backlight. Not supported on mc13783
+ * Use pmic_bklit_tcled_master_enable.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED
+ */
+PMIC_STATUS pmic_bklit_master_disable(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ *                               level     main & aux   keyboard
+ *                              ------    -----------  --------
+ *                                0         0 mA         0 mA
+ *                                1         3 mA         12 mA
+ *                                2         6 mA         24 mA
+ *                                3         9 mA         36 mA
+ *                                4         12 mA        48 mA
+ *                                5         15 mA        60 mA
+ *                                6         18 mA        72 mA
+ *                                7         21 mA        84 mA
+ *                           @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel, unsigned char level)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		value = BITFVAL(BIT_CL_MAIN, level);
+		mask = BITFMASK(BIT_CL_MAIN);
+		break;
+	case BACKLIGHT_LED2:
+		value = BITFVAL(BIT_CL_AUX, level);
+		mask = BITFMASK(BIT_CL_AUX);
+		break;
+	case BACKLIGHT_LED3:
+		value = BITFVAL(BIT_CL_KEY, level);
+		mask = BITFMASK(BIT_CL_KEY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives backlight current level.
+ * The channels are not individually adjustable, hence
+ * the channel parameter is ignored.
+ *
+ * @param        channel   Backlight channel (Ignored because the
+ *                         channels are not individually adjustable)
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_CL_MAIN);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_CL_AUX);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_CL_KEY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, mask));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		*level = BITFEXT(reg_value, BIT_CL_MAIN);
+		break;
+	case BACKLIGHT_LED2:
+		*level = BITFEXT(reg_value, BIT_CL_AUX);
+		break;
+	case BACKLIGHT_LED3:
+		*level = BITFEXT(reg_value, BIT_CL_KEY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ *                               dc        Duty Cycle (% On-time over Cycle Time)
+ *                              ------    ---------------------------------------
+ *                                 0        0%
+ *                                 1        6.7%
+ *                                 2        13.3%
+ *                                 3        20%
+ *                                 4        26.7%
+ *                                 5        33.3%
+ *                                 6        40%
+ *                                 7        46.7%
+ *                                 8        53.3%
+ *                                 9        60%
+ *                                10        66.7%
+ *                                11        73.3%
+ *                                12        80%
+ *                                13        86.7%
+ *                                14        93.3%
+ *                                15        100%
+ *                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (dc > 15)
+		return PMIC_PARAMETER_ERROR;
+
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		reg_value = reg_value & (~MASK_DUTY_CYCLE);
+		reg_value = reg_value | (dc << BIT_DUTY_CYCLE);
+		break;
+	case BACKLIGHT_LED2:
+		reg_value = reg_value & (~(MASK_DUTY_CYCLE << INDEX_AUX));
+		reg_value = reg_value | (dc << (BIT_DUTY_CYCLE + INDEX_AUX));
+		break;
+	case BACKLIGHT_LED3:
+		reg_value = reg_value & (~(MASK_DUTY_CYCLE << INDEX_KYD));
+		reg_value = reg_value | (dc << (BIT_DUTY_CYCLE + INDEX_KYD));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(LREG_2, reg_value, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+
+}
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel, unsigned char *dc)
+{
+	unsigned int reg_value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(LREG_2, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		*dc = (int)((reg_value & (MASK_DUTY_CYCLE))
+			    >> BIT_DUTY_CYCLE);
+
+		break;
+	case BACKLIGHT_LED2:
+		*dc = (int)((reg_value & (MASK_DUTY_CYCLE << INDEX_AUX))
+			    >> (BIT_DUTY_CYCLE + INDEX_AUX));
+		break;
+	case BACKLIGHT_LED3:
+		*dc = (int)((reg_value & (MASK_DUTY_CYCLE <<
+					  INDEX_KYD)) >> (BIT_DUTY_CYCLE +
+							  INDEX_KYD));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ *                               period      Cycle Time
+ *                              --------    ------------
+ *                                 0          0.01 seconds
+ *                                 1          0.1 seconds
+ *                                 2          0.5 seconds
+ *                                 3          2 seconds
+ *                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (period > 3)
+		return PMIC_PARAMETER_ERROR;
+
+	mask = BITFMASK(BIT_PERIOD);
+	value = BITFVAL(BIT_PERIOD, period);
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_PERIOD);
+	CHECK_ERROR(pmic_read_reg(LREG_2, &value, mask));
+	*period = BITFEXT(value, BIT_PERIOD);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode)
+{
+	unsigned int reg_value = 0;
+	unsigned int clear_val = 0;
+	unsigned int triode_val = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &reg_value, PMIC_ALL_BITS));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		clear_val = ~(MASK_TRIODE_MAIN_BL);
+		triode_val = MASK_TRIODE_MAIN_BL;
+		break;
+	case BACKLIGHT_LED2:
+		clear_val = ~(MASK_TRIODE_MAIN_BL << INDEX_AUXILIARY);
+		triode_val = (MASK_TRIODE_MAIN_BL << INDEX_AUXILIARY);
+		break;
+	case BACKLIGHT_LED3:
+		clear_val = ~(MASK_TRIODE_MAIN_BL << INDEX_KEYPAD);
+		triode_val = (MASK_TRIODE_MAIN_BL << INDEX_KEYPAD);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	reg_value = (reg_value & clear_val);
+
+	if (mode == BACKLIGHT_TRIODE_MODE)
+		reg_value = (reg_value | triode_val);
+
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, PMIC_ALL_BITS));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_TRIODE_MAIN_BL);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_TRIODE_AUX_BL);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_TRIODE_KEY_BL);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &reg_value, mask));
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		*mode = BITFEXT(reg_value, BIT_TRIODE_MAIN_BL);
+		break;
+	case BACKLIGHT_LED2:
+		*mode = BITFEXT(reg_value, BIT_TRIODE_AUX_BL);
+		break;
+	case BACKLIGHT_LED3:
+		*mode = BITFEXT(reg_value, BIT_TRIODE_KEY_BL);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_UP_MAIN_BL);
+		reg_value = BITFVAL(BIT_UP_MAIN_BL, 1);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_UP_AUX_BL);
+		reg_value = BITFVAL(BIT_UP_AUX_BL, 1);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_UP_KEY_BL);
+		reg_value = BITFVAL(BIT_UP_KEY_BL, 1);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_UP_MAIN_BL);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_UP_AUX_BL);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_UP_KEY_BL);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_DOWN_MAIN_BL);
+		reg_value = BITFVAL(BIT_DOWN_MAIN_BL, 1);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_DOWN_AUX_BL);
+		reg_value = BITFVAL(BIT_DOWN_AUX_BL, 1);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_DOWN_KEY_BL);
+		reg_value = BITFVAL(BIT_DOWN_KEY_BL, 1);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (channel) {
+	case BACKLIGHT_LED1:
+		mask = BITFMASK(BIT_DOWN_MAIN_BL);
+		break;
+	case BACKLIGHT_LED2:
+		mask = BITFMASK(BIT_DOWN_AUX_BL);
+		break;
+	case BACKLIGHT_LED3:
+		mask = BITFMASK(BIT_DOWN_KEY_BL);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, reg_value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	value = BITFVAL(BIT_SLEWLIMBL, 1);
+	CHECK_ERROR(pmic_write_reg(LREG_2, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an <93>Instant On<94> mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void)
+{
+	unsigned int mask;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	CHECK_ERROR(pmic_write_reg(LREG_2, 0, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	mask = BITFMASK(BIT_SLEWLIMBL);
+	CHECK_ERROR(pmic_read_reg(LREG_2, &value, mask));
+	*edge = (bool) BITFEXT(value, BIT_SLEWLIMBL);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ * @param	 bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (mode) {
+	case TCLED_FUN_MODE:
+		switch (bank) {
+		case TCLED_FUN_BANK1:
+			mask = MASK_BK1_FL;
+			value = MASK_BK1_FL;
+			break;
+		case TCLED_FUN_BANK2:
+			mask = MASK_BK2_FL;
+			value = MASK_BK2_FL;
+			break;
+		case TCLED_FUN_BANK3:
+			mask = MASK_BK3_FL;
+			value = MASK_BK3_FL;
+			break;
+		default:
+			return PMIC_PARAMETER_ERROR;
+		}
+		break;
+	case TCLED_IND_MODE:
+		mask = MASK_BK1_FL | MASK_BK2_FL | MASK_BK3_FL;
+		break;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables tri-color LED.
+ *
+ * @param        bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ *
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank)
+{
+	unsigned int mask = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = MASK_BK1_FL;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = MASK_BK2_FL;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = MASK_BK3_FL;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, 0, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ * @param        bank      Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank)
+{
+	unsigned int val;
+	unsigned int mask;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = MASK_BK1_FL;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = MASK_BK2_FL;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = MASK_BK3_FL;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_0, &val, mask));
+
+	if (val)
+		*mode = TCLED_FUN_MODE;
+	else
+		*mode = TCLED_IND_MODE;
+
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (level > TCLED_CUR_LEVEL_4)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		value = BITFVAL(BITS_CL_RED, level);
+		mask = BITFMASK(BITS_CL_RED);
+		break;
+	case TCLED_IND_GREEN:
+		value = BITFVAL(BITS_CL_GREEN, level);
+		mask = BITFMASK(BITS_CL_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		value = BITFVAL(BITS_CL_BLUE, level);
+		mask = BITFMASK(BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level *level,
+				       t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		mask = BITFMASK(BITS_CL_RED);
+		break;
+	case TCLED_IND_GREEN:
+		mask = BITFMASK(BITS_CL_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		mask = BITFMASK(BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		*level = BITFEXT(value, BITS_CL_RED);
+		break;
+	case TCLED_IND_GREEN:
+		*level = BITFEXT(value, BITS_CL_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		*level = BITFEXT(value, BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ * @param        bank         Selected tri-color bank
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (skip == true)
+		return PMIC_NOT_SUPPORTED;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		value = BITFVAL(BITS_DC_RED, pattern);
+		mask = BITFMASK(BITS_DC_RED);
+		break;
+	case TCLED_IND_GREEN:
+		value = BITFVAL(BITS_DC_GREEN, pattern);
+		mask = BITFMASK(BITS_DC_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		value = BITFVAL(BITS_DC_BLUE, pattern);
+		mask = BITFMASK(BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean varible indicating if skip
+ * @param        bank         Selected tri-color bank
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool *skip,
+					     t_funlight_bank bank)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		mask = BITFMASK(BITS_DC_RED);
+		break;
+	case TCLED_IND_GREEN:
+		mask = BITFMASK(BITS_DC_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		mask = BITFMASK(BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_IND_RED:
+		*pattern = BITFEXT(value, BITS_DC_RED);
+		break;
+	case TCLED_IND_GREEN:
+		*pattern = BITFEXT(value, BITS_DC_GREEN);
+		break;
+	case TCLED_IND_BLUE:
+		*pattern = BITFEXT(value, BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (level > TCLED_CUR_LEVEL_4)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		value = BITFVAL(BITS_CL_RED, level);
+		mask = BITFMASK(BITS_CL_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		value = BITFVAL(BITS_CL_GREEN, level);
+		mask = BITFMASK(BITS_CL_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		value = BITFVAL(BITS_CL_BLUE, level);
+		mask = BITFMASK(BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level *level)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = BITFMASK(BITS_CL_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = BITFMASK(BITS_CL_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = BITFMASK(BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		*level = BITFEXT(value, BITS_CL_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		*level = BITFEXT(value, BITS_CL_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		*level = BITFEXT(value, BITS_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets tri-color LED cycle time.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (ct > TC_CYCLE_TIME_4)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	value = BITFVAL(BIT_PERIOD, ct);
+	mask = BITFMASK(BIT_PERIOD);
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time *ct)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask;
+	unsigned int value;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (*ct > TC_CYCLE_TIME_4)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BIT_PERIOD);
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	*ct = BITFVAL(BIT_PERIOD, value);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		value = BITFVAL(BITS_DC_RED, dc);
+		mask = BITFMASK(BITS_DC_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		value = BITFVAL(BITS_DC_GREEN, dc);
+		mask = BITFMASK(BITS_DC_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		value = BITFVAL(BITS_DC_BLUE, dc);
+		mask = BITFMASK(BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg_conf, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc)
+{
+	unsigned int reg_conf = 0;
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		reg_conf = LREG_3;
+		break;
+	case TCLED_FUN_BANK2:
+		reg_conf = LREG_4;
+		break;
+	case TCLED_FUN_BANK3:
+		reg_conf = LREG_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = BITFMASK(BITS_DC_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = BITFMASK(BITS_DC_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = BITFMASK(BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg_conf, &value, mask));
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		*dc = BITFEXT(value, BITS_DC_RED);
+		break;
+	case TCLED_FUN_CHANNEL2:
+		*dc = BITFEXT(value, BITS_DC_GREEN);
+		break;
+	case TCLED_FUN_CHANNEL3:
+		*dc = BITFEXT(value, BITS_DC_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (speed) {
+	case TC_OFF:
+		value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+		break;
+	case TC_SLOW:
+		value = BITFVAL(BITS_FUN_LIGHT, BLENDED_RAMPS_SLOW);
+		break;
+	case TC_FAST:
+		value = BITFVAL(BITS_FUN_LIGHT, BLENDED_RAMPS_FAST);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (speed) {
+	case TC_OFF:
+		value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+		break;
+	case TC_SLOW:
+		value = BITFVAL(BITS_FUN_LIGHT, SAW_RAMPS_SLOW);
+		break;
+	case TC_FAST:
+		value = BITFVAL(BITS_FUN_LIGHT, SAW_RAMPS_FAST);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (speed) {
+	case TC_OFF:
+		value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+		break;
+	case TC_SLOW:
+		value = BITFVAL(BITS_FUN_LIGHT, BLENDED_INVERSE_RAMPS_SLOW);
+		break;
+	case TC_FAST:
+		value = BITFVAL(BITS_FUN_LIGHT, BLENDED_INVERSE_RAMPS_FAST);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	if (pattern > BGR)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (speed) {
+	case TC_OFF:
+		value = BITFVAL(BITS_FUN_LIGHT, FUN_LIGHTS_OFF);
+		break;
+	case TC_SLOW:
+		if (pattern == PMIC_RGB) {
+			value =
+			    BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_RGB_SLOW);
+		} else {
+			value =
+			    BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_BGR_SLOW);
+		}
+		break;
+	case TC_FAST:
+		if (pattern == PMIC_RGB) {
+			value =
+			    BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_RGB_FAST);
+		} else {
+			value =
+			    BITFVAL(BITS_FUN_LIGHT, CHASING_LIGHTS_BGR_FAST);
+		}
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	mask = BITFMASK(BITS_FUN_LIGHT);
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed)
+{
+	/* not supported on mc13783 */
+
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = LEDR1RAMPUP;
+		value = LEDR1RAMPUP;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = LEDR2RAMPUP;
+		value = LEDR2RAMPUP;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = LEDR3RAMPUP;
+		value = LEDR3RAMPUP;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = mask;
+		value = value;
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = mask * 2;
+		value = value * 2;
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = mask * 4;
+		value = value * 4;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (!rampup)
+		value = 0;
+
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel, bool *rampup)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = LEDR1RAMPUP;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = LEDR2RAMPUP;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = LEDR3RAMPUP;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = mask;
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = mask * 2;
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = mask * 4;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_1, &value, mask));
+	if (value)
+		*rampup = true;
+	else
+		*rampup = false;
+
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = LEDR1RAMPDOWN;
+		value = LEDR1RAMPDOWN;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = LEDR2RAMPDOWN;
+		value = LEDR2RAMPDOWN;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = LEDR3RAMPDOWN;
+		value = LEDR3RAMPDOWN;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = mask;
+		value = value;
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = mask * 2;
+		value = value * 2;
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = mask * 4;
+		value = value * 4;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (!rampdown)
+		value = 0;
+
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool *rampdown)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = LEDR1RAMPDOWN;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = LEDR2RAMPDOWN;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = LEDR3RAMPDOWN;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (channel) {
+	case TCLED_FUN_CHANNEL1:
+		mask = mask;
+		break;
+	case TCLED_FUN_CHANNEL2:
+		mask = mask * 2;
+		break;
+	case TCLED_FUN_CHANNEL3:
+		mask = mask * 4;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(LREG_1, &value, mask));
+	if (value)
+		*rampdown = true;
+	else
+		*rampdown = false;
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = MASK_BK1_FL;
+		value = ENABLE_BK1_FL;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = MASK_BK2_FL;
+		value = ENABLE_BK2_FL;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = MASK_BK3_FL;
+		value = ENABLE_BK2_FL;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	switch (bank) {
+	case TCLED_FUN_BANK1:
+		mask = MASK_BK1_FL;
+		break;
+	case TCLED_FUN_BANK2:
+		mask = MASK_BK2_FL;
+		break;
+	case TCLED_FUN_BANK3:
+		mask = MASK_BK3_FL;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	value = BITFVAL(BIT_SLEWLIMTC, 1);
+	mask = BITFMASK(BIT_SLEWLIMTC);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	value = BITFVAL(BIT_SLEWLIMTC, 0);
+	mask = BITFMASK(BIT_SLEWLIMTC);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	value = BITFVAL(BIT_TC1HALF, 1);
+	mask = BITFMASK(BIT_TC1HALF);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void)
+{
+	unsigned int mask = 0;
+	unsigned int value = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+
+	value = BITFVAL(BIT_TC1HALF, 0);
+	mask = BITFMASK(BIT_TC1HALF);
+
+	CHECK_ERROR(pmic_write_reg(LREG_1, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain, bool lpf_bypass)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void)
+{
+	return PMIC_NOT_SUPPORTED;
+}
+
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis)
+{
+
+	pmic_version_t mc13783_ver;
+	unsigned int mask;
+	unsigned int value;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+
+		value = BITFVAL(BIT_BOOSTEN, en_dis);
+		mask = BITFMASK(BIT_BOOSTEN);
+		CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis)
+{
+	pmic_version_t mc13783_ver;
+	unsigned int mask;
+	unsigned int value;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+		mask = BITFMASK(BIT_BOOSTEN);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*en_dis = BITFEXT(value, BIT_BOOSTEN);
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr)
+{
+	unsigned int conf_boost = 0;
+	unsigned int mask;
+	unsigned int value;
+	pmic_version_t mc13783_ver;
+
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+
+		if (abms > MAX_BOOST_ABMS)
+			return PMIC_PARAMETER_ERROR;
+
+
+		if (abr > MAX_BOOST_ABR)
+			return PMIC_PARAMETER_ERROR;
+
+
+		conf_boost = abms | (abr << 3);
+
+		value = BITFVAL(BITS_BOOST, conf_boost);
+		mask = BITFMASK(BITS_BOOST);
+		CHECK_ERROR(pmic_write_reg(LREG_0, value, mask));
+
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr)
+{
+	unsigned int mask;
+	unsigned int value;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		if (suspend_flag == 1)
+			return -EBUSY;
+
+
+		mask = BITFMASK(BITS_BOOST_ABMS);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*abms = BITFEXT(value, BITS_BOOST_ABMS);
+
+		mask = BITFMASK(BITS_BOOST_ABR);
+		CHECK_ERROR(pmic_read_reg(LREG_0, &value, mask));
+		*abr = BITFEXT(value, BITS_BOOST_ABR);
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC Light device.
+ *
+
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_light_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	t_bklit_setting_param *bklit_setting = NULL;
+	t_tcled_enable_param *tcled_setting;
+	t_fun_param *fun_param;
+	t_tcled_ind_param *tcled_ind;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	switch (cmd) {
+	case PMIC_BKLIT_TCLED_ENABLE:
+		pmic_bklit_tcled_master_enable();
+		break;
+
+	case PMIC_BKLIT_TCLED_DISABLE:
+		pmic_bklit_tcled_master_disable();
+		break;
+
+	case PMIC_BKLIT_ENABLE:
+		pmic_bklit_master_enable();
+		break;
+
+	case PMIC_BKLIT_DISABLE:
+		pmic_bklit_master_disable();
+		break;
+
+	case PMIC_SET_BKLIT:
+		bklit_setting = kmalloc(sizeof(t_bklit_setting_param), GFP_KERNEL);
+		if (bklit_setting == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(bklit_setting, (t_bklit_setting_param *) arg,
+				   sizeof(t_bklit_setting_param))) {
+			kfree(bklit_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_bklit_set_mode(bklit_setting->channel,
+						      bklit_setting->mode),
+				  (kfree(bklit_setting)));
+
+		CHECK_ERROR_KFREE(pmic_bklit_set_current(bklit_setting->channel,
+							 bklit_setting->
+							 current_level),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_set_dutycycle
+				  (bklit_setting->channel,
+				   bklit_setting->duty_cycle),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_set_cycle_time
+				  (bklit_setting->cycle_time),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_set_boost_mode
+				  (bklit_setting->en_dis),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_config_boost_mode
+				  (bklit_setting->abms, bklit_setting->abr),
+				  (kfree(bklit_setting)));
+		if (bklit_setting->edge_slow != false) {
+			CHECK_ERROR_KFREE(pmic_bklit_enable_edge_slow(),
+					  (kfree(bklit_setting)));
+		} else {
+			CHECK_ERROR_KFREE(pmic_bklit_disable_edge_slow(),
+					  (kfree(bklit_setting)));
+		}
+
+		kfree(bklit_setting);
+		break;
+
+	case PMIC_GET_BKLIT:
+		bklit_setting = kmalloc(sizeof(t_bklit_setting_param), GFP_KERNEL);
+		if (bklit_setting == NULL)
+			return -ENOMEM;
+
+
+		if (copy_from_user(bklit_setting, (t_bklit_setting_param *) arg,
+				   sizeof(t_bklit_setting_param))) {
+			kfree(bklit_setting);
+			return -EFAULT;
+		}
+
+		CHECK_ERROR_KFREE(pmic_bklit_get_current(bklit_setting->channel,
+							 &bklit_setting->
+							 current_level),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_get_cycle_time
+				  (&bklit_setting->cycle_time),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_get_dutycycle
+				  (bklit_setting->channel,
+				   &bklit_setting->duty_cycle),
+				  (kfree(bklit_setting)));
+		bklit_setting->strobe = BACKLIGHT_STROBE_NONE;
+		CHECK_ERROR_KFREE(pmic_bklit_get_mode(bklit_setting->channel,
+						      &bklit_setting->mode),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_get_edge_slow
+				  (&bklit_setting->edge_slow),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_get_boost_mode
+				  (&bklit_setting->en_dis),
+				  (kfree(bklit_setting)));
+		CHECK_ERROR_KFREE(pmic_bklit_gets_boost_mode
+				  (&bklit_setting->abms, &bklit_setting->abr),
+				  (kfree(bklit_setting)));
+
+		if (copy_to_user((t_bklit_setting_param *) arg, bklit_setting,
+				 sizeof(t_bklit_setting_param))) {
+			kfree(bklit_setting);
+			return -EFAULT;
+		}
+		kfree(bklit_setting);
+		break;
+
+	case PMIC_RAMPUP_BKLIT:
+		CHECK_ERROR(pmic_bklit_rampup((t_bklit_channel) arg));
+		break;
+
+	case PMIC_RAMPDOWN_BKLIT:
+		CHECK_ERROR(pmic_bklit_rampdown((t_bklit_channel) arg));
+		break;
+
+	case PMIC_OFF_RAMPUP_BKLIT:
+		CHECK_ERROR(pmic_bklit_off_rampup((t_bklit_channel) arg));
+		break;
+
+	case PMIC_OFF_RAMPDOWN_BKLIT:
+		CHECK_ERROR(pmic_bklit_off_rampdown((t_bklit_channel) arg));
+		break;
+
+	case PMIC_TCLED_ENABLE:
+		tcled_setting = kmalloc(sizeof(t_tcled_enable_param), GFP_KERNEL);
+		if (tcled_setting == NULL)
+			return -ENOMEM;
+
+
+		if (copy_from_user(tcled_setting, (t_tcled_enable_param *) arg,
+				   sizeof(t_tcled_enable_param))) {
+			kfree(tcled_setting);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_tcled_enable(tcled_setting->mode,
+						    tcled_setting->bank),
+				  (kfree(bklit_setting)));
+		break;
+
+	case PMIC_TCLED_DISABLE:
+		CHECK_ERROR(pmic_tcled_disable((t_funlight_bank) arg));
+		break;
+
+	case PMIC_TCLED_PATTERN:
+		fun_param = kmalloc(sizeof(t_fun_param), GFP_KERNEL);
+		if (fun_param == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(fun_param,
+				   (t_fun_param *) arg, sizeof(t_fun_param))) {
+			kfree(fun_param);
+			return -EFAULT;
+		}
+
+		switch (fun_param->pattern) {
+		case BLENDED_RAMPS_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_blendedramps
+					  (fun_param->bank, TC_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case BLENDED_RAMPS_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_blendedramps
+					  (fun_param->bank, TC_FAST),
+					  (kfree(fun_param)));
+			break;
+
+		case SAW_RAMPS_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_sawramps
+					  (fun_param->bank, TC_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case SAW_RAMPS_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_sawramps
+					  (fun_param->bank, TC_FAST),
+					  (kfree(fun_param)));
+			break;
+
+		case BLENDED_BOWTIE_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_blendedbowtie
+					  (fun_param->bank, TC_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case BLENDED_BOWTIE_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_blendedbowtie
+					  (fun_param->bank, TC_FAST),
+					  (kfree(fun_param)));
+			break;
+
+		case STROBE_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_strobe
+					  (fun_param->bank, fun_param->channel,
+					   TC_STROBE_SLOW), (kfree(fun_param)));
+			break;
+
+		case STROBE_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_strobe
+					  (fun_param->bank,
+					   fun_param->channel, TC_STROBE_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case CHASING_LIGHT_RGB_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+					  (fun_param->bank, PMIC_RGB, TC_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case CHASING_LIGHT_RGB_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+					  (fun_param->bank, PMIC_RGB, TC_FAST),
+					  (kfree(fun_param)));
+			break;
+
+		case CHASING_LIGHT_BGR_SLOW:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+					  (fun_param->bank, BGR, TC_SLOW),
+					  (kfree(fun_param)));
+			break;
+
+		case CHASING_LIGHT_BGR_FAST:
+			CHECK_ERROR_KFREE(pmic_tcled_fun_chasinglightspattern
+					  (fun_param->bank, BGR, TC_FAST),
+					  (kfree(fun_param)));
+			break;
+		}
+
+		kfree(fun_param);
+		break;
+
+	case PMIC_SET_TCLED:
+		tcled_ind = kmalloc(sizeof(t_tcled_ind_param), GFP_KERNEL);
+		if (tcled_ind == NULL)
+			return -ENOMEM;
+
+
+		if (copy_from_user(tcled_ind, (t_tcled_ind_param *) arg,
+				   sizeof(t_tcled_ind_param))) {
+			kfree(tcled_ind);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_tcled_ind_set_current(tcled_ind->channel,
+							     tcled_ind->level,
+							     tcled_ind->bank),
+				  (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_ind_set_blink_pattern
+				  (tcled_ind->channel, tcled_ind->pattern,
+				   tcled_ind->skip, tcled_ind->bank),
+				  (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_fun_rampup
+				  (tcled_ind->bank, tcled_ind->channel,
+				   tcled_ind->rampup), (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_fun_rampdown
+				  (tcled_ind->bank, tcled_ind->channel,
+				   tcled_ind->rampdown), (kfree(tcled_ind)));
+		if (tcled_ind->half_current) {
+			CHECK_ERROR_KFREE(pmic_tcled_enable_half_current(),
+					  (kfree(tcled_ind)));
+		} else {
+			CHECK_ERROR_KFREE(pmic_tcled_disable_half_current(),
+					  (kfree(tcled_ind)));
+		}
+
+		kfree(tcled_ind);
+		break;
+
+	case PMIC_GET_TCLED:
+		tcled_ind = kmalloc(sizeof(t_tcled_ind_param), GFP_KERNEL);
+		if (tcled_ind == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tcled_ind, (t_tcled_ind_param *) arg,
+				   sizeof(t_tcled_ind_param))) {
+			kfree(tcled_ind);
+			return -EFAULT;
+		}
+		CHECK_ERROR_KFREE(pmic_tcled_ind_get_current(tcled_ind->channel,
+							     &tcled_ind->level,
+							     tcled_ind->bank),
+				  (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_ind_get_blink_pattern
+				  (tcled_ind->channel, &tcled_ind->pattern,
+				   &tcled_ind->skip, tcled_ind->bank),
+				  (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_get_fun_rampup
+				  (tcled_ind->bank, tcled_ind->channel,
+				   &tcled_ind->rampup), (kfree(tcled_ind)));
+		CHECK_ERROR_KFREE(pmic_tcled_get_fun_rampdown
+				  (tcled_ind->bank, tcled_ind->channel,
+				   &tcled_ind->rampdown), (kfree(tcled_ind)));
+		if (copy_to_user
+		    ((t_tcled_ind_param *) arg, tcled_ind,
+		     sizeof(t_tcled_ind_param))) {
+			return -EFAULT;
+		}
+		kfree(tcled_ind);
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * This function initialize Light registers of mc13783 with 0.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int pmic_light_init_reg(void)
+{
+	CHECK_ERROR(pmic_write_reg(LREG_0, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_3, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_4, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(LREG_5, 0, PMIC_ALL_BITS));
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a mc13783 light device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_light_open(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a mc13783 light device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_light_release(struct inode *inode, struct file *file)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+	return 0;
+}
+
+static const struct file_operations pmic_light_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_light_ioctl,
+	.open = pmic_light_open,
+	.release = pmic_light_release,
+};
+
+static int pmic_light_remove(struct platform_device *pdev)
+{
+	device_destroy(pmic_light_class, MKDEV(pmic_light_major, 0));
+	class_destroy(pmic_light_class);
+	unregister_chrdev(pmic_light_major, "pmic_light");
+	return 0;
+}
+
+static int pmic_light_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+
+	}
+	pmic_light_major = register_chrdev(0, "pmic_light", &pmic_light_fops);
+
+	if (pmic_light_major < 0) {
+		printk(KERN_ERR "Unable to get a major for pmic_light\n");
+		return pmic_light_major;
+	}
+	init_waitqueue_head(&suspendq);
+
+	pmic_light_class = class_create(THIS_MODULE, "pmic_light");
+	if (IS_ERR(pmic_light_class)) {
+		printk(KERN_ERR "Error creating pmic_light class.\n");
+		ret = PTR_ERR(pmic_light_class);
+		goto err_out1;
+	}
+
+	temp_class = device_create(pmic_light_class, NULL,
+				   MKDEV(pmic_light_major, 0), NULL,
+				   "pmic_light");
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating pmic_light class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	ret = pmic_light_init_reg();
+	if (ret != PMIC_SUCCESS)
+		goto err_out3;
+
+
+	printk(KERN_INFO "PMIC Light successfully loaded\n");
+	return ret;
+
+err_out3:
+	device_destroy(pmic_light_class, MKDEV(pmic_light_major, 0));
+err_out2:
+	class_destroy(pmic_light_class);
+err_out1:
+	unregister_chrdev(pmic_light_major, "pmic_light");
+	return ret;
+}
+
+static struct platform_driver pmic_light_driver_ldm = {
+	.driver = {
+		   .name = "pmic_light",
+		   },
+	.suspend = pmic_light_suspend,
+	.resume = pmic_light_resume,
+	.probe = pmic_light_probe,
+	.remove = pmic_light_remove,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+static int __init pmic_light_init(void)
+{
+	pr_debug("PMIC Light driver loading...\n");
+	return platform_driver_register(&pmic_light_driver_ldm);
+}
+static void __exit pmic_light_exit(void)
+{
+	platform_driver_unregister(&pmic_light_driver_ldm);
+	pr_debug("PMIC Light driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_light_init);
+module_exit(pmic_light_exit);
+
+MODULE_DESCRIPTION("PMIC_LIGHT");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_light_defs.h b/drivers/mxc/pmic/mc13783/pmic_light_defs.h
new file mode 100644
index 0000000..47ee9a2
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_light_defs.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_light_defs.h
+ * @brief This is the internal header PMIC(mc13783) Light and Backlight driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#ifndef __MC13783_LIGHT_DEFS_H__
+#define __MC13783_LIGHT_DEFS_H__
+
+#define LREG_0   REG_LED_CONTROL_0
+#define LREG_1   REG_LED_CONTROL_1
+#define LREG_2   REG_LED_CONTROL_2
+#define LREG_3   REG_LED_CONTROL_3
+#define LREG_4   REG_LED_CONTROL_4
+#define LREG_5   REG_LED_CONTROL_5
+
+/* REG_LED_CONTROL_0 */
+
+#define         BIT_LEDEN_LSH           0
+#define         BIT_LEDEN_WID           1
+#define         MASK_TRIODE_MAIN_BL     0x080
+#define         INDEX_AUXILIARY         1
+#define         INDEX_KEYPAD            2
+#define         BITS_FUN_LIGHT_LSH      17
+#define         BITS_FUN_LIGHT_WID      4
+#define         MASK_FUN_LIGHT          0x1E0000
+#define         MASK_BK1_FL             0x200000
+#define         ENABLE_BK1_FL           0x200000
+#define         MASK_BK2_FL             0x400000
+#define         ENABLE_BK2_FL           0x400000
+#define         MASK_BK3_FL             0x800000
+#define         ENABLE_BK3_FL           0x800000
+#define         BIT_UP_MAIN_BL_LSH	1
+#define         BIT_UP_MAIN_BL_WID	1
+#define         BIT_UP_AUX_BL_LSH	2
+#define         BIT_UP_AUX_BL_WID	1
+#define         BIT_UP_KEY_BL_LSH	3
+#define         BIT_UP_KEY_BL_WID	1
+#define         BIT_DOWN_MAIN_BL_LSH	4
+#define         BIT_DOWN_MAIN_BL_WID	1
+#define         BIT_DOWN_AUX_BL_LSH	5
+#define         BIT_DOWN_AUX_BL_WID	1
+#define         BIT_DOWN_KEY_BL_LSH	6
+#define         BIT_DOWN_KEY_BL_WID	1
+#define         BIT_TRIODE_MAIN_BL_LSH	7
+#define         BIT_TRIODE_MAIN_BL_WID	1
+#define         BIT_TRIODE_AUX_BL_LSH	8
+#define         BIT_TRIODE_AUX_BL_WID	1
+#define         BIT_TRIODE_KEY_BL_LSH	9
+#define         BIT_TRIODE_KEY_BL_WID	1
+
+#define         BIT_BOOSTEN_LSH         10
+#define         BIT_BOOSTEN_WID         1
+#define         BITS_BOOST_LSH          11
+#define         BITS_BOOST_WID          5
+#define         BITS_BOOST_ABMS_LSH     11
+#define         BITS_BOOST_ABMS_WID     3
+#define         BITS_BOOST_ABR_LSH      14
+#define         BITS_BOOST_ABR_WID      2
+
+#define         MAX_BOOST_ABMS          7
+#define         MAX_BOOST_ABR           3
+
+/* REG_LED_CONTROL_1 */
+
+#define         BIT_SLEWLIMTC_LSH       23
+#define         BIT_SLEWLIMTC_WID       1
+#define         BIT_TC1HALF_LSH         18
+#define         BIT_TC1HALF_WID         1
+#define         LEDR1RAMPUP             0x000001
+#define         LEDR2RAMPUP             0x000040
+#define         LEDR3RAMPUP             0x001000
+#define         LEDR1RAMPDOWN           0x000008
+#define         LEDR2RAMPDOWN           0x000200
+#define         LEDR3RAMPDOWN           0x008000
+
+/* REG_LED_CONTROL_2 */
+
+#define         BIT_SLEWLIMBL_LSH       23
+#define         BIT_SLEWLIMBL_WID       1
+#define         BIT_DUTY_CYCLE          9
+#define         MASK_DUTY_CYCLE         0x001E00
+#define         INDEX_AUX               4
+#define         INDEX_KYD               8
+#define         BIT_CL_MAIN_LSH		0
+#define         BIT_CL_MAIN_WID		3
+#define         BIT_CL_AUX_LSH		3
+#define         BIT_CL_AUX_WID		3
+#define         BIT_CL_KEY_LSH		6
+#define         BIT_CL_KEY_WID		3
+
+/* REG_LED_CONTROL_3 4 5 */
+#define         BITS_CL_RED_LSH         0
+#define         BITS_CL_RED_WID         2
+#define         BITS_CL_GREEN_LSH       2
+#define         BITS_CL_GREEN_WID       2
+#define         BITS_CL_BLUE_LSH        4
+#define         BITS_CL_BLUE_WID        2
+#define         BITS_DC_RED_LSH         6
+#define         BITS_DC_RED_WID         5
+#define         BITS_DC_GREEN_LSH       11
+#define         BITS_DC_GREEN_WID       5
+#define         BITS_DC_BLUE_LSH        16
+#define         BITS_DC_BLUE_WID        5
+#define         BIT_PERIOD_LSH          21
+#define         BIT_PERIOD_WID          2
+
+#define         DUTY_CYCLE_MAX          31
+
+/* Fun light pattern */
+#define         BLENDED_RAMPS_SLOW		0
+#define         BLENDED_RAMPS_FAST		1
+#define         SAW_RAMPS_SLOW			2
+#define         SAW_RAMPS_FAST			3
+#define         BLENDED_INVERSE_RAMPS_SLOW	4
+#define         BLENDED_INVERSE_RAMPS_FAST	5
+#define         CHASING_LIGHTS_RGB_SLOW		6
+#define         CHASING_LIGHTS_RGB_FAST		7
+#define         CHASING_LIGHTS_BGR_SLOW		8
+#define         CHASING_LIGHTS_BGR_FAST		9
+#define         FUN_LIGHTS_OFF			15
+
+/*!
+ * This function initialize Light registers of mc13783 with 0.
+ *
+ * @return       This function returns 0 if successful.
+ */
+int pmic_light_init_reg(void);
+
+#endif				/*  __MC13783_LIGHT_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_power.c b/drivers/mxc/pmic/mc13783/pmic_power.c
new file mode 100644
index 0000000..81dd768
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_power.c
@@ -0,0 +1,3146 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_power.c
+ * @brief This is the main file of PMIC(mc13783) Power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <mach/pmic_power.h>
+
+#include "pmic_power_defs.h"
+
+#ifdef CONFIG_MXC_HWEVENT
+#include <mach/hw_events.h>
+#endif
+
+#include <asm/mach-types.h>
+
+#define MC13783_REGCTRL_GPOx_MASK 0x18000
+
+static bool VBKUP1_EN;
+static bool VBKUP2_EN;
+
+/*
+ * Power Pmic API
+ */
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_power_off);
+EXPORT_SYMBOL(pmic_power_set_pc_config);
+EXPORT_SYMBOL(pmic_power_get_pc_config);
+EXPORT_SYMBOL(pmic_power_regulator_on);
+EXPORT_SYMBOL(pmic_power_regulator_off);
+EXPORT_SYMBOL(pmic_power_regulator_set_voltage);
+EXPORT_SYMBOL(pmic_power_regulator_get_voltage);
+EXPORT_SYMBOL(pmic_power_regulator_set_config);
+EXPORT_SYMBOL(pmic_power_regulator_get_config);
+EXPORT_SYMBOL(pmic_power_vbkup2_auto_en);
+EXPORT_SYMBOL(pmic_power_get_vbkup2_auto_state);
+EXPORT_SYMBOL(pmic_power_bat_det_en);
+EXPORT_SYMBOL(pmic_power_get_bat_det_state);
+EXPORT_SYMBOL(pmic_power_vib_pin_en);
+EXPORT_SYMBOL(pmic_power_gets_vib_pin_state);
+EXPORT_SYMBOL(pmic_power_get_power_mode_sense);
+EXPORT_SYMBOL(pmic_power_set_regen_assig);
+EXPORT_SYMBOL(pmic_power_get_regen_assig);
+EXPORT_SYMBOL(pmic_power_set_regen_inv);
+EXPORT_SYMBOL(pmic_power_get_regen_inv);
+EXPORT_SYMBOL(pmic_power_esim_v_en);
+EXPORT_SYMBOL(pmic_power_gets_esim_v_state);
+EXPORT_SYMBOL(pmic_power_set_auto_reset_en);
+EXPORT_SYMBOL(pmic_power_get_auto_reset_en);
+EXPORT_SYMBOL(pmic_power_set_conf_button);
+EXPORT_SYMBOL(pmic_power_get_conf_button);
+EXPORT_SYMBOL(pmic_power_event_sub);
+EXPORT_SYMBOL(pmic_power_event_unsub);
+
+/*!
+ * This function is called to put the power in a low power state.
+ * Switching off the platform cannot be decided by
+ * the power module. It has to be handled by the
+ * client application.
+ *
+ * @param   pdev  the device structure used to give information on which power
+ *                device (0 through 3 channels) to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_power_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+};
+
+/*!
+ * This function is called to resume the power from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which power
+ *                device (0 through 3 channels) to suspend
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_power_resume(struct platform_device *pdev)
+{
+	return 0;
+};
+
+/*!
+ * This function sets user power off in power control register and thus powers
+ * off the phone.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+void pmic_power_off(void)
+{
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_PWRCTRL_USER_OFF_SPI);
+	value = BITFVAL(MC13783_PWRCTRL_USER_OFF_SPI,
+			MC13783_PWRCTRL_USER_OFF_SPI_ENABLE);
+
+	pmic_write_reg(REG_POWER_CONTROL_0, value, mask);
+}
+
+/*!
+ * This function sets the power control configuration.
+ *
+ * @param        pc_config   power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_set_pc_config(t_pc_config *pc_config)
+{
+	unsigned int pwrctrl_val_reg0 = 0;
+	unsigned int pwrctrl_val_reg1 = 0;
+	unsigned int pwrctrl_mask_reg0 = 0;
+	unsigned int pwrctrl_mask_reg1 = 0;
+
+	if (pc_config == NULL)
+		return PMIC_PARAMETER_ERROR;
+
+
+	if (pc_config->pc_enable != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PCEN,
+					    MC13783_PWRCTRL_PCEN_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PCT,
+					    pc_config->pc_timer);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PCEN,
+					    MC13783_PWRCTRL_PCEN_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_PCEN);
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_PCT);
+
+	if (pc_config->pc_count_enable != false) {
+
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT_EN,
+					    MC13783_PWRCTRL_PC_COUNT_EN_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT,
+					    pc_config->pc_count);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_PC_MAX_CNT,
+					    pc_config->pc_max_count);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_PC_COUNT_EN,
+					    MC13783_PWRCTRL_PC_COUNT_EN_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_PC_COUNT_EN);
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_PC_MAX_CNT) |
+	    BITFMASK(MC13783_PWRCTRL_PC_COUNT);
+
+	if (pc_config->warm_enable != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_WARM_EN_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_WARM_EN_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_WARM_EN);
+
+	if (pc_config->user_off_pc != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_USER_OFF_PC,
+					    MC13783_PWRCTRL_USER_OFF_PC_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_WARM_EN,
+					    MC13783_PWRCTRL_USER_OFF_PC_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_USER_OFF_PC);
+
+	if (pc_config->clk_32k_user_off != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_USER_OFF,
+					    MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_USER_OFF,
+					    MC13783_PWRCTRL_32OUT_USER_OFF_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_32OUT_USER_OFF);
+
+	if (pc_config->clk_32k_enable != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_EN,
+					    MC13783_PWRCTRL_32OUT_EN_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_32OUT_EN,
+					    MC13783_PWRCTRL_32OUT_EN_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_32OUT_EN);
+
+	if (pc_config->en_vbkup1 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+		VBKUP1_EN = true;
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+		VBKUP1_EN = false;
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1_EN);
+
+	if (pc_config->en_vbkup2 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+		VBKUP2_EN = true;
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+		VBKUP2_EN = false;
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP2_EN);
+
+	if (pc_config->auto_en_vbkup1 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1_AUTO_EN);
+
+	if (pc_config->auto_en_vbkup2 != false) {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_ENABLE);
+	} else {
+		pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2_AUTO_EN,
+					    MC13783_PWRCTRL_VBKUP_DISABLE);
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP2_AUTO_EN);
+
+	if (VBKUP1_EN != false) {
+		if (pc_config->vhold_voltage > 3
+		    || pc_config->vhold_voltage < 0) {
+			return PMIC_PARAMETER_ERROR;
+		} else {
+
+			pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP1,
+						    pc_config->vhold_voltage);
+		}
+	}
+	if (VBKUP2_EN != false) {
+		if (pc_config->vhold_voltage > 3
+		    || pc_config->vhold_voltage < 0) {
+			return PMIC_PARAMETER_ERROR;
+		} else {
+			pwrctrl_val_reg0 |= BITFVAL(MC13783_PWRCTRL_VBKUP2,
+						    pc_config->vhold_voltage2);
+		}
+	}
+	pwrctrl_mask_reg0 |= BITFMASK(MC13783_PWRCTRL_VBKUP1) |
+	    BITFMASK(MC13783_PWRCTRL_VBKUP2);
+
+	if (pc_config->mem_allon != false) {
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_ALLON,
+					    MC13783_PWRCTRL_MEM_ALLON_ENABLE);
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_TMR,
+					    pc_config->mem_timer);
+	} else {
+		pwrctrl_val_reg1 |= BITFVAL(MC13783_PWRCTRL_MEM_ALLON,
+					    MC13783_PWRCTRL_MEM_ALLON_DISABLE);
+	}
+	pwrctrl_mask_reg1 |= BITFMASK(MC13783_PWRCTRL_MEM_ALLON) |
+	    BITFMASK(MC13783_PWRCTRL_MEM_TMR);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+				   pwrctrl_val_reg0, pwrctrl_mask_reg0));
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_1,
+				   pwrctrl_val_reg1, pwrctrl_mask_reg1));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives the power control configuration.
+ *
+ * @param        pc_config   pointer to power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_pc_config(t_pc_config *pc_config)
+{
+	unsigned int pwrctrl_val_reg0 = 0;
+	unsigned int pwrctrl_val_reg1 = 0;
+
+	if (pc_config == NULL)
+		return PMIC_PARAMETER_ERROR;
+
+
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+				  &pwrctrl_val_reg0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_1,
+				  &pwrctrl_val_reg1, PMIC_ALL_BITS));
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_PCEN)
+	    == MC13783_PWRCTRL_PCEN_ENABLE) {
+		pc_config->pc_enable = true;
+		pc_config->pc_timer = BITFEXT(pwrctrl_val_reg1,
+					      MC13783_PWRCTRL_PCT);
+
+	} else {
+		pc_config->pc_enable = false;
+		pc_config->pc_timer = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_PC_COUNT_EN)
+	    == MC13783_PWRCTRL_PCEN_ENABLE) {
+		pc_config->pc_count_enable = true;
+		pc_config->pc_count = BITFEXT(pwrctrl_val_reg1,
+					      MC13783_PWRCTRL_PC_COUNT);
+		pc_config->pc_max_count = BITFEXT(pwrctrl_val_reg1,
+						  MC13783_PWRCTRL_PC_MAX_CNT);
+	} else {
+		pc_config->pc_count_enable = false;
+		pc_config->pc_count = 0;
+		pc_config->pc_max_count = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_WARM_EN)
+	    == MC13783_PWRCTRL_WARM_EN_ENABLE) {
+		pc_config->warm_enable = true;
+	} else {
+		pc_config->warm_enable = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_USER_OFF_PC)
+	    == MC13783_PWRCTRL_USER_OFF_PC_ENABLE) {
+		pc_config->user_off_pc = true;
+	} else {
+		pc_config->user_off_pc = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_32OUT_USER_OFF)
+	    == MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE) {
+		pc_config->clk_32k_user_off = true;
+	} else {
+		pc_config->clk_32k_user_off = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_32OUT_EN)
+	    == MC13783_PWRCTRL_32OUT_EN_ENABLE) {
+		pc_config->clk_32k_enable = true;
+	} else {
+		pc_config->clk_32k_enable = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP1_AUTO_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->auto_en_vbkup1 = true;
+	} else {
+		pc_config->auto_en_vbkup1 = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP2_AUTO_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->auto_en_vbkup2 = true;
+	} else {
+		pc_config->auto_en_vbkup2 = false;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP1_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->en_vbkup1 = true;
+		pc_config->vhold_voltage = BITFEXT(pwrctrl_val_reg0,
+						   MC13783_PWRCTRL_VBKUP1);
+	} else {
+		pc_config->en_vbkup1 = false;
+		pc_config->vhold_voltage = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg0, MC13783_PWRCTRL_VBKUP2_EN)
+	    == MC13783_PWRCTRL_VBKUP_ENABLE) {
+		pc_config->en_vbkup2 = true;
+		pc_config->vhold_voltage2 = BITFEXT(pwrctrl_val_reg0,
+						    MC13783_PWRCTRL_VBKUP2);
+	} else {
+		pc_config->en_vbkup2 = false;
+		pc_config->vhold_voltage2 = 0;
+	}
+
+	if (BITFEXT(pwrctrl_val_reg1, MC13783_PWRCTRL_MEM_ALLON) ==
+	    MC13783_PWRCTRL_MEM_ALLON_ENABLE) {
+		pc_config->mem_allon = true;
+		pc_config->mem_timer = BITFEXT(pwrctrl_val_reg1,
+					       MC13783_PWRCTRL_MEM_TMR);
+	} else {
+		pc_config->mem_allon = false;
+		pc_config->mem_timer = 0;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function turns on a regulator.
+ *
+ * @param        regulator    The regulator to be truned on.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_PLL:
+		reg_val = BITFVAL(MC13783_SWCTRL_PLL_EN,
+				  MC13783_SWCTRL_PLL_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_PLL_EN);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_EN,
+				  MC13783_SWCTRL_SW3_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_EN);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_EN,
+				  MC13783_REGCTRL_VAUDIO_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_EN,
+				  MC13783_REGCTRL_VIOHI_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_EN,
+				  MC13783_REGCTRL_VIOLO_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_EN,
+				  MC13783_REGCTRL_VDIG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_EN,
+				  MC13783_REGCTRL_VGEN_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_EN,
+				  MC13783_REGCTRL_VRFDIG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_EN,
+				  MC13783_REGCTRL_VRFREF_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_EN,
+				  MC13783_REGCTRL_VRFCP_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_EN,
+				  MC13783_REGCTRL_VSIM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_EN,
+				  MC13783_REGCTRL_VESIM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_EN,
+				  MC13783_REGCTRL_VCAM_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_EN,
+				  MC13783_REGCTRL_VRFBG_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VVIB:
+		reg_val = BITFVAL(MC13783_REGCTRL_VVIB_EN,
+				  MC13783_REGCTRL_VVIB_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VVIB_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_EN,
+				  MC13783_REGCTRL_VRF1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_EN,
+				  MC13783_REGCTRL_VRF2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_EN,
+				  MC13783_REGCTRL_VMMC1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_EN,
+				  MC13783_REGCTRL_VMMC2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO1_EN,
+				  MC13783_REGCTRL_GPO1_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO1_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO2_EN,
+				  MC13783_REGCTRL_GPO2_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO2_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO3_EN,
+				  MC13783_REGCTRL_GPO3_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO3_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO4_EN,
+				  MC13783_REGCTRL_GPO4_EN_ENABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO4_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function turns off a regulator.
+ *
+ * @param        regulator    The regulator to be truned off.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_PLL:
+		reg_val = BITFVAL(MC13783_SWCTRL_PLL_EN,
+				  MC13783_SWCTRL_PLL_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_PLL_EN);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_EN,
+				  MC13783_SWCTRL_SW3_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_EN);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_EN,
+				  MC13783_REGCTRL_VAUDIO_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_EN,
+				  MC13783_REGCTRL_VIOHI_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_EN,
+				  MC13783_REGCTRL_VIOLO_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_EN,
+				  MC13783_REGCTRL_VDIG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_EN,
+				  MC13783_REGCTRL_VGEN_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_EN,
+				  MC13783_REGCTRL_VRFDIG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_EN,
+				  MC13783_REGCTRL_VRFREF_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_EN,
+				  MC13783_REGCTRL_VRFCP_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_EN);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_EN,
+				  MC13783_REGCTRL_VSIM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_EN,
+				  MC13783_REGCTRL_VESIM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_EN,
+				  MC13783_REGCTRL_VCAM_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_EN,
+				  MC13783_REGCTRL_VRFBG_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VVIB:
+		reg_val = BITFVAL(MC13783_REGCTRL_VVIB_EN,
+				  MC13783_REGCTRL_VVIB_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VVIB_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_EN,
+				  MC13783_REGCTRL_VRF1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_EN,
+				  MC13783_REGCTRL_VRF2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_EN,
+				  MC13783_REGCTRL_VMMC1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_EN,
+				  MC13783_REGCTRL_VMMC2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_EN);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO1_EN,
+				  MC13783_REGCTRL_GPO1_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO1_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO2_EN,
+				  MC13783_REGCTRL_GPO2_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO2_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO3_EN,
+				  MC13783_REGCTRL_GPO3_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO3_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGCTRL_GPO4_EN,
+				  MC13783_REGCTRL_GPO4_EN_DISABLE);
+		reg_mask = BITFMASK(MC13783_REGCTRL_GPO4_EN);
+		reg = REG_POWER_MISCELLANEOUS;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        voltage      The regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage voltage)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((voltage.sw1a < SW1A_0_9V) || (voltage.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1A, voltage.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((voltage.sw1b < SW1B_0_9V) || (voltage.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1B, voltage.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((voltage.sw2a < SW2A_0_9V) || (voltage.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2A, voltage.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((voltage.sw2b < SW2B_0_9V) || (voltage.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2B, voltage.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A);
+		reg = REG_SWITCHERS_3;
+		break;
+	case SW_SW3:
+		if (voltage.sw3 != SW3_5V)
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW3, voltage.sw3);
+		reg_mask = BITFMASK(MC13783_SWSET_SW3);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VIOLO:
+		if ((voltage.violo < VIOLO_1_2V) ||
+		    (voltage.violo > VIOLO_1_8V)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGSET_VIOLO, voltage.violo);
+		reg_mask = BITFMASK(MC13783_REGSET_VIOLO);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VDIG:
+		if ((voltage.vdig < VDIG_1_2V) || (voltage.vdig > VDIG_1_8V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VDIG, voltage.vdig);
+		reg_mask = BITFMASK(MC13783_REGSET_VDIG);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VGEN:
+		if ((voltage.vgen < VGEN_1_2V) || (voltage.vgen > VGEN_2_4V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VGEN, voltage.vgen);
+		reg_mask = BITFMASK(MC13783_REGSET_VGEN);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFDIG:
+		if ((voltage.vrfdig < VRFDIG_1_2V) ||
+		    (voltage.vrfdig > VRFDIG_1_875V)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGSET_VRFDIG, voltage.vrfdig);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFDIG);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFREF:
+		if ((voltage.vrfref < VRFREF_2_475V) ||
+		    (voltage.vrfref > VRFREF_2_775V)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGSET_VRFREF, voltage.vrfref);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFREF);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VRFCP:
+		if ((voltage.vrfcp < VRFCP_2_7V) ||
+		    (voltage.vrfcp > VRFCP_2_775V)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGSET_VRFCP, voltage.vrfcp);
+		reg_mask = BITFMASK(MC13783_REGSET_VRFCP);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VSIM:
+		if ((voltage.vsim < VSIM_1_8V) || (voltage.vsim > VSIM_2_9V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VSIM, voltage.vsim);
+		reg_mask = BITFMASK(MC13783_REGSET_VSIM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VESIM:
+		if ((voltage.vesim < VESIM_1_8V) ||
+		    (voltage.vesim > VESIM_2_9V)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGSET_VESIM, voltage.vesim);
+		reg_mask = BITFMASK(MC13783_REGSET_VESIM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VCAM:
+		if ((voltage.vcam < VCAM_1_5V) || (voltage.vcam > VCAM_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VCAM, voltage.vcam);
+		reg_mask = BITFMASK(MC13783_REGSET_VCAM);
+		reg = REG_REGULATOR_SETTING_0;
+		break;
+	case REGU_VVIB:
+		if ((voltage.vvib < VVIB_1_3V) || (voltage.vvib > VVIB_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VVIB, voltage.vvib);
+		reg_mask = BITFMASK(MC13783_REGSET_VVIB);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VRF1:
+		if ((voltage.vrf1 < VRF1_1_5V) || (voltage.vrf1 > VRF1_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRF1, voltage.vrf1);
+		reg_mask = BITFMASK(MC13783_REGSET_VRF1);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VRF2:
+		if ((voltage.vrf2 < VRF2_1_5V) || (voltage.vrf2 > VRF2_2_775V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VRF2, voltage.vrf2);
+		reg_mask = BITFMASK(MC13783_REGSET_VRF2);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VMMC1:
+		if ((voltage.vmmc1 < VMMC1_1_6V) || (voltage.vmmc1 > VMMC1_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VMMC1, voltage.vmmc1);
+		reg_mask = BITFMASK(MC13783_REGSET_VMMC1);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VMMC2:
+		if ((voltage.vmmc2 < VMMC2_1_6V) || (voltage.vmmc2 > VMMC2_3V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_REGSET_VMMC2, voltage.vmmc2);
+		reg_mask = BITFMASK(MC13783_REGSET_VMMC2);
+		reg = REG_REGULATOR_SETTING_1;
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+	case REGU_GPO1:
+	case REGU_GPO2:
+	case REGU_GPO3:
+	case REGU_GPO4:
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be truned off.
+ * @param        voltage      Pointer to regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage *voltage)
+{
+	unsigned int reg_val = 0;
+
+	if (regulator == SW_SW1A) {
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_0,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if (regulator == SW_SW1B) {
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_1,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if (regulator == SW_SW2A) {
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_2,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if (regulator == SW_SW2B) {
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_3,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if (regulator == SW_SW3) {
+		CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_5,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if ((regulator == REGU_VIOLO) || (regulator == REGU_VDIG) ||
+		   (regulator == REGU_VGEN) ||
+		   (regulator == REGU_VRFDIG) ||
+		   (regulator == REGU_VRFREF) ||
+		   (regulator == REGU_VRFCP) ||
+		   (regulator == REGU_VSIM) ||
+		   (regulator == REGU_VESIM) || (regulator == REGU_VCAM)) {
+		CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+					  &reg_val, PMIC_ALL_BITS));
+	} else if ((regulator == REGU_VVIB) || (regulator == REGU_VRF1) ||
+		   (regulator == REGU_VRF2) ||
+		   (regulator == REGU_VMMC1) || (regulator == REGU_VMMC2)) {
+		CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_1,
+					  &reg_val, PMIC_ALL_BITS));
+	}
+
+	switch (regulator) {
+	case SW_SW1A:
+		voltage->sw1a = BITFEXT(reg_val, MC13783_SWSET_SW1A);
+		break;
+	case SW_SW1B:
+		voltage->sw1b = BITFEXT(reg_val, MC13783_SWSET_SW1B);
+		break;
+	case SW_SW2A:
+		voltage->sw2a = BITFEXT(reg_val, MC13783_SWSET_SW2A);
+		break;
+	case SW_SW2B:
+		voltage->sw2b = BITFEXT(reg_val, MC13783_SWSET_SW2B);
+		break;
+	case SW_SW3:
+		voltage->sw3 = BITFEXT(reg_val, MC13783_SWSET_SW3);
+		break;
+	case REGU_VIOLO:
+		voltage->violo = BITFEXT(reg_val, MC13783_REGSET_VIOLO);
+		break;
+	case REGU_VDIG:
+		voltage->vdig = BITFEXT(reg_val, MC13783_REGSET_VDIG);
+		break;
+	case REGU_VGEN:
+		voltage->vgen = BITFEXT(reg_val, MC13783_REGSET_VGEN);
+		break;
+	case REGU_VRFDIG:
+		voltage->vrfdig = BITFEXT(reg_val, MC13783_REGSET_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		voltage->vrfref = BITFEXT(reg_val, MC13783_REGSET_VRFREF);
+		break;
+	case REGU_VRFCP:
+		voltage->vrfcp = BITFEXT(reg_val, MC13783_REGSET_VRFCP);
+		break;
+	case REGU_VSIM:
+		voltage->vsim = BITFEXT(reg_val, MC13783_REGSET_VSIM);
+		break;
+	case REGU_VESIM:
+		voltage->vesim = BITFEXT(reg_val, MC13783_REGSET_VESIM);
+		break;
+	case REGU_VCAM:
+		voltage->vcam = BITFEXT(reg_val, MC13783_REGSET_VCAM);
+		break;
+	case REGU_VVIB:
+		voltage->vvib = BITFEXT(reg_val, MC13783_REGSET_VVIB);
+		break;
+	case REGU_VRF1:
+		voltage->vrf1 = BITFEXT(reg_val, MC13783_REGSET_VRF1);
+		break;
+	case REGU_VRF2:
+		voltage->vrf2 = BITFEXT(reg_val, MC13783_REGSET_VRF2);
+		break;
+	case REGU_VMMC1:
+		voltage->vmmc1 = BITFEXT(reg_val, MC13783_REGSET_VMMC1);
+		break;
+	case REGU_VMMC2:
+		voltage->vmmc2 = BITFEXT(reg_val, MC13783_REGSET_VMMC2);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the DVS voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage dvs)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((dvs.sw1a < SW1A_0_9V) || (dvs.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1A_DVS, dvs.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_DVS);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((dvs.sw1b < SW1B_0_9V) || (dvs.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1B_DVS, dvs.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_DVS);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((dvs.sw2a < SW2A_0_9V) || (dvs.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2A_DVS, dvs.sw2a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_DVS);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((dvs.sw2b < SW2B_0_9V) || (dvs.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2B_DVS, dvs.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_DVS);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the DVS voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage *dvs)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_DVS);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_DVS);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_DVS);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_DVS);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+						     MC13783_SWSET_SW1A_DVS);
+		break;
+	case SW_SW1B:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+						     MC13783_SWSET_SW1B_DVS);
+		break;
+	case SW_SW2A:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+						     MC13783_SWSET_SW2A_DVS);
+		break;
+	case SW_SW2B:
+		*dvs = (t_regulator_voltage) BITFEXT(reg_val,
+						     MC13783_SWSET_SW2B_DVS);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the standiby voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if ((stby.sw1a < SW1A_0_9V) || (stby.sw1a > SW1A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1A_STDBY, stby.sw1a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_STDBY);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		if ((stby.sw1b < SW1B_0_9V) || (stby.sw1b > SW1B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW1B_STDBY, stby.sw1b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_STDBY);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		if ((stby.sw2a < SW2A_0_9V) || (stby.sw2a > SW2A_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2A_STDBY, stby.sw2a);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_STDBY);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		if ((stby.sw2b < SW2B_0_9V) || (stby.sw2b > SW2B_2_2V))
+			return PMIC_PARAMETER_ERROR;
+
+		reg_val = BITFVAL(MC13783_SWSET_SW2B_STDBY, stby.sw2b);
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_STDBY);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the standiby voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage *stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1A_STDBY);
+		reg = REG_SWITCHERS_0;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW1B_STDBY);
+		reg = REG_SWITCHERS_1;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2A_STDBY);
+		reg = REG_SWITCHERS_2;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWSET_SW2B_STDBY);
+		reg = REG_SWITCHERS_3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+						      MC13783_SWSET_SW1A_STDBY);
+		break;
+	case SW_SW1B:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+						      MC13783_SWSET_SW1B_STDBY);
+		break;
+	case SW_SW2A:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+						      MC13783_SWSET_SW2A_STDBY);
+		break;
+	case SW_SW2B:
+		*stby = (t_regulator_voltage) BITFEXT(reg_val,
+						      MC13783_SWSET_SW2B_STDBY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switchers mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode	      The switcher mode
+ * @param        stby	      Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode mode, bool stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode;
+
+	if (mode == SYNC_RECT)
+		l_mode = MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN;
+	else if (mode == NO_PULSE_SKIP)
+		l_mode = MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN;
+	else if (mode == PULSE_SKIP)
+		l_mode = MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN;
+	else if (mode == LOW_POWER)
+		l_mode = MC13783_SWCTRL_SW_MODE_LOW_POWER_EN;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW1A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW1A_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_MODE);
+		}
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW1B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW1B_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_MODE);
+		}
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW2A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW2A_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_MODE);
+		}
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		if (stby) {
+			reg_val =
+			    BITFVAL(MC13783_SWCTRL_SW2B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_STBY_MODE);
+		} else {
+			reg_val = BITFVAL(MC13783_SWCTRL_SW2B_MODE, l_mode);
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_MODE);
+		}
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switchers mode.
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        mode         The switcher mode.
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode *mode, bool stby)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg = 0;
+	unsigned int l_mode = 0;
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_MODE);
+
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_MODE);
+
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_MODE);
+
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		if (stby)
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_STBY_MODE);
+		else
+			reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_MODE);
+
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		if (stby) {
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW1A_STBY_MODE);
+		} else {
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_MODE);
+		}
+		break;
+	case SW_SW1B:
+		if (stby) {
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW1B_STBY_MODE);
+		} else {
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_MODE);
+		}
+		break;
+	case SW_SW2A:
+		if (stby) {
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW2A_STBY_MODE);
+		} else {
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_MODE);
+		}
+		break;
+	case SW_SW2B:
+		if (stby) {
+			l_mode =
+			    BITFEXT(reg_val, MC13783_SWCTRL_SW2B_STBY_MODE);
+		} else {
+			l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_MODE);
+		}
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (l_mode == MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN)
+		*mode = SYNC_RECT;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN)
+		*mode = NO_PULSE_SKIP;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN)
+		*mode = PULSE_SKIP;
+	else if (l_mode == MC13783_SWCTRL_SW_MODE_LOW_POWER_EN)
+		*mode = LOW_POWER;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        speed	      The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed speed)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	if (speed > 3 || speed < 0)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_DVS_SPEED, speed);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed *speed)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_DVS_SPEED);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_DVS_SPEED);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_DVS_SPEED);
+		break;
+	case SW_SW1B:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_DVS_SPEED);
+		break;
+	case SW_SW2A:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_DVS_SPEED);
+		break;
+	case SW_SW2B:
+		*speed = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_DVS_SPEED);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch panic mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_panic_mode(t_pmic_regulator regulator,
+					       bool panic_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_PANIC_MODE, panic_mode);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch panic mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_panic_mode(t_pmic_regulator regulator,
+					       bool *panic_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_PANIC_MODE);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_PANIC_MODE);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_PANIC_MODE);
+		break;
+	case SW_SW1B:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW1B_PANIC_MODE);
+		break;
+	case SW_SW2A:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_PANIC_MODE);
+		break;
+	case SW_SW2B:
+		*panic_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_PANIC_MODE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_softstart(t_pmic_regulator regulator,
+					      bool softstart)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW1A_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2A_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW2B_SOFTSTART, softstart);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_softstart(t_pmic_regulator regulator,
+					      bool *softstart)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+
+	switch (regulator) {
+	case SW_SW1A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1A_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW1B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW1B_SOFTSTART);
+		reg = REG_SWITCHERS_4;
+		break;
+	case SW_SW2A:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2A_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	case SW_SW2B:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW2B_SOFTSTART);
+		reg = REG_SWITCHERS_5;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW1A:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW1A_SOFTSTART);
+		break;
+	case SW_SW1B:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_SOFTSTART);
+		break;
+	case SW_SW2A:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2A_SOFTSTART);
+		break;
+	case SW_SW2B:
+		*softstart = BITFEXT(reg_val, MC13783_SWCTRL_SW2B_SOFTSTART);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_factor(t_pmic_regulator regulator,
+					   t_switcher_factor factor)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	if (regulator != SW_PLL)
+		return PMIC_PARAMETER_ERROR;
+
+	if (factor < FACTOR_28 || factor > FACTOR_35)
+		return PMIC_PARAMETER_ERROR;
+
+	reg_val = BITFVAL(MC13783_SWCTRL_PLL_FACTOR, factor);
+	reg_mask = BITFMASK(MC13783_SWCTRL_PLL_FACTOR);
+
+	CHECK_ERROR(pmic_write_reg(REG_SWITCHERS_4, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_factor(t_pmic_regulator regulator,
+					   t_switcher_factor *factor)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	if (regulator != SW_PLL)
+		return PMIC_PARAMETER_ERROR;
+
+	reg_mask = BITFMASK(MC13783_SWCTRL_PLL_FACTOR);
+
+	CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_4, &reg_val, reg_mask));
+
+	*factor = BITFEXT(reg_val, MC13783_SWCTRL_PLL_FACTOR);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables or disables low power mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        lp_mode      Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode lp_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode, l_stby;
+
+	if (lp_mode == LOW_POWER_DISABLED) {
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_DISABLE;
+	} else if (lp_mode == LOW_POWER_CTRL_BY_PIN) {
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_ENABLE;
+	} else if (lp_mode == LOW_POWER_EN) {
+		l_mode = MC13783_REGTRL_LP_MODE_ENABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_DISABLE;
+	} else if (lp_mode == LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN) {
+		l_mode = MC13783_REGTRL_LP_MODE_ENABLE;
+		l_stby = MC13783_REGTRL_STBY_MODE_ENABLE;
+	} else {
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	switch (regulator) {
+	case SW_SW3:
+		reg_val = BITFVAL(MC13783_SWCTRL_SW3_MODE, l_mode) |
+		    BITFVAL(MC13783_SWCTRL_SW3_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_MODE) |
+		    BITFMASK(MC13783_SWCTRL_SW3_STBY);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VAUDIO_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VAUDIO_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VAUDIO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOHI_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VIOHI_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOHI_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGCTRL_VIOLO_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VIOLO_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOLO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VDIG_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VDIG_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGCTRL_VGEN_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VGEN_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VGEN_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFDIG_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VRFDIG_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFREF_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VRFREF_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFREF_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFCP_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VRFCP_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFCP_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VSIM_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VSIM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VSIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VESIM_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VESIM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VESIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGCTRL_VCAM_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VCAM_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VCAM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		if ((lp_mode == LOW_POWER) ||
+		    (lp_mode == LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN)) {
+			return PMIC_PARAMETER_ERROR;
+		}
+		reg_val = BITFVAL(MC13783_REGCTRL_VRFBG_STBY, l_mode);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF1_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VRF1_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VRF2_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VRF2_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC1_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VMMC1_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGCTRL_VMMC2_MODE, l_mode) |
+		    BITFVAL(MC13783_REGCTRL_VMMC2_STBY, l_stby);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(reg, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets low power mode.
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        lp_mode      Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode *lp_mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int reg;
+	unsigned int l_mode, l_stby;
+
+	switch (regulator) {
+	case SW_SW3:
+		reg_mask = BITFMASK(MC13783_SWCTRL_SW3_MODE) |
+		    BITFMASK(MC13783_SWCTRL_SW3_STBY);
+		reg = REG_SWITCHERS_5;
+		break;
+	case REGU_VAUDIO:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VAUDIO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VAUDIO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOHI:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOHI_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOHI_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VIOLO:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIOLO_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VIOLO_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VDIG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VGEN:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VGEN_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VGEN_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFDIG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFDIG_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFDIG_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFREF:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFREF_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFREF_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VRFCP:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFCP_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRFCP_STBY);
+		reg = REG_REGULATOR_MODE_0;
+		break;
+	case REGU_VSIM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VSIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VSIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VESIM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VESIM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VESIM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VCAM:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VCAM_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VCAM_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRFBG:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRFBG_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF1:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VRF2:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VRF2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VRF2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC1:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC1_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC1_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	case REGU_VMMC2:
+		reg_mask = BITFMASK(MC13783_REGCTRL_VMMC2_MODE) |
+		    BITFMASK(MC13783_REGCTRL_VMMC2_STBY);
+		reg = REG_REGULATOR_MODE_1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case SW_SW3:
+		l_mode = BITFEXT(reg_val, MC13783_SWCTRL_SW3_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_SWCTRL_SW3_STBY);
+		break;
+	case REGU_VAUDIO:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VAUDIO_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VAUDIO_STBY);
+		break;
+	case REGU_VIOHI:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VIOHI_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VIOHI_STBY);
+		break;
+	case REGU_VIOLO:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VIOLO_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VIOLO_STBY);
+		break;
+	case REGU_VDIG:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VDIG_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VDIG_STBY);
+		break;
+	case REGU_VGEN:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VGEN_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VGEN_STBY);
+		break;
+	case REGU_VRFDIG:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFDIG_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFDIG_STBY);
+		break;
+	case REGU_VRFREF:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFREF_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFREF_STBY);
+		break;
+	case REGU_VRFCP:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRFCP_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFCP_STBY);
+		break;
+	case REGU_VSIM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VSIM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VSIM_STBY);
+		break;
+	case REGU_VESIM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VESIM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VESIM_STBY);
+		break;
+	case REGU_VCAM:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VCAM_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VCAM_STBY);
+		break;
+	case REGU_VRFBG:
+		l_mode = MC13783_REGTRL_LP_MODE_DISABLE;
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRFBG_STBY);
+		break;
+	case REGU_VRF1:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRF1_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRF1_STBY);
+		break;
+	case REGU_VRF2:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VRF2_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VRF2_STBY);
+		break;
+	case REGU_VMMC1:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VMMC1_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VMMC1_STBY);
+		break;
+	case REGU_VMMC2:
+		l_mode = BITFEXT(reg_val, MC13783_REGCTRL_VMMC2_MODE);
+		l_stby = BITFEXT(reg_val, MC13783_REGCTRL_VMMC2_STBY);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if ((l_mode == MC13783_REGTRL_LP_MODE_DISABLE) &&
+	    (l_stby == MC13783_REGTRL_STBY_MODE_DISABLE)) {
+		*lp_mode = LOW_POWER_DISABLED;
+	} else if ((l_mode == MC13783_REGTRL_LP_MODE_DISABLE) &&
+		   (l_stby == MC13783_REGTRL_STBY_MODE_ENABLE)) {
+		*lp_mode = LOW_POWER_CTRL_BY_PIN;
+	} else if ((l_mode == MC13783_REGTRL_LP_MODE_ENABLE) &&
+		   (l_stby == MC13783_REGTRL_STBY_MODE_DISABLE)) {
+		*lp_mode = LOW_POWER_EN;
+	} else {
+		*lp_mode = LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the regulator configuration.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        config       The regulator output configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_config(t_pmic_regulator regulator,
+					    t_regulator_config *config)
+{
+	if (config == NULL)
+		return PMIC_ERROR;
+
+
+	switch (regulator) {
+	case SW_SW1A:
+	case SW_SW1B:
+	case SW_SW2A:
+	case SW_SW2B:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		CHECK_ERROR(pmic_power_switcher_set_dvs
+			    (regulator, config->voltage_lvs));
+		CHECK_ERROR(pmic_power_switcher_set_stby
+			    (regulator, config->voltage_stby));
+		CHECK_ERROR(pmic_power_switcher_set_mode
+			    (regulator, config->mode, false));
+		CHECK_ERROR(pmic_power_switcher_set_mode
+			    (regulator, config->stby_mode, true));
+		CHECK_ERROR(pmic_power_switcher_set_dvs_speed
+			    (regulator, config->dvs_speed));
+		CHECK_ERROR(pmic_power_switcher_set_panic_mode
+			    (regulator, config->panic_mode));
+		CHECK_ERROR(pmic_power_switcher_set_softstart
+			    (regulator, config->softstart));
+		break;
+	case SW_PLL:
+		CHECK_ERROR(pmic_power_switcher_set_factor
+			    (regulator, config->factor));
+		break;
+	case SW_SW3:
+	case REGU_VIOLO:
+	case REGU_VDIG:
+	case REGU_VGEN:
+	case REGU_VRFDIG:
+	case REGU_VRFREF:
+	case REGU_VRFCP:
+	case REGU_VSIM:
+	case REGU_VESIM:
+	case REGU_VCAM:
+	case REGU_VRF1:
+	case REGU_VRF2:
+	case REGU_VMMC1:
+	case REGU_VMMC2:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		CHECK_ERROR(pmic_power_regulator_set_lp_mode
+			    (regulator, config->lp_mode));
+		break;
+	case REGU_VVIB:
+		CHECK_ERROR(pmic_power_regulator_set_voltage
+			    (regulator, config->voltage));
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+		CHECK_ERROR(pmic_power_regulator_set_lp_mode
+			    (regulator, config->lp_mode));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function retrives the regulator output configuration.
+ *
+ * @param        regulator    The regulator to be truned off.
+ * @param        config       Pointer to regulator configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_config(t_pmic_regulator regulator,
+					    t_regulator_config *config)
+{
+	if (config == NULL)
+		return PMIC_ERROR;
+
+
+	switch (regulator) {
+	case SW_SW1A:
+	case SW_SW1B:
+	case SW_SW2A:
+	case SW_SW2B:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		CHECK_ERROR(pmic_power_switcher_get_dvs
+			    (regulator, &config->voltage_lvs));
+		CHECK_ERROR(pmic_power_switcher_get_stby
+			    (regulator, &config->voltage_stby));
+		CHECK_ERROR(pmic_power_switcher_get_mode
+			    (regulator, &config->mode, false));
+		CHECK_ERROR(pmic_power_switcher_get_mode
+			    (regulator, &config->stby_mode, true));
+		CHECK_ERROR(pmic_power_switcher_get_dvs_speed
+			    (regulator, &config->dvs_speed));
+		CHECK_ERROR(pmic_power_switcher_get_panic_mode
+			    (regulator, &config->panic_mode));
+		CHECK_ERROR(pmic_power_switcher_get_softstart
+			    (regulator, &config->softstart));
+		break;
+	case SW_PLL:
+		CHECK_ERROR(pmic_power_switcher_get_factor
+			    (regulator, &config->factor));
+		break;
+	case SW_SW3:
+	case REGU_VIOLO:
+	case REGU_VDIG:
+	case REGU_VGEN:
+	case REGU_VRFDIG:
+	case REGU_VRFREF:
+	case REGU_VRFCP:
+	case REGU_VSIM:
+	case REGU_VESIM:
+	case REGU_VCAM:
+	case REGU_VRF1:
+	case REGU_VRF2:
+	case REGU_VMMC1:
+	case REGU_VMMC2:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		CHECK_ERROR(pmic_power_regulator_get_lp_mode
+			    (regulator, &config->lp_mode));
+		break;
+	case REGU_VVIB:
+		CHECK_ERROR(pmic_power_regulator_get_voltage
+			    (regulator, &config->voltage));
+		break;
+	case REGU_VAUDIO:
+	case REGU_VIOHI:
+	case REGU_VRFBG:
+		CHECK_ERROR(pmic_power_regulator_get_lp_mode
+			    (regulator, &config->lp_mode));
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables automatically VBKUP2 in the memory hold modes.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable VBKUP2AUTOMH
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vbkup2_auto_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_VBKUP2AUTOMH, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VBKUP2AUTOMH);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets state of automatically VBKUP2.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, VBKUP2AUTOMH is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_vbkup2_auto_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_VBKUP2AUTOMH);
+		CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_VBKUP2AUTOMH);
+
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function enables battery detect function.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable BATTDETEN
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_bat_det_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_BATTDETEN, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_BATTDETEN);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_0,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets state of battery detect function.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, BATTDETEN is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_bat_det_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_BATTDETEN);
+
+		CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_0,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_BATTDETEN);
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function enables control of VVIB by VIBEN pin.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        en           if true, enable VIBPINCTRL
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vib_pin_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGCTRL_VIBPINCTRL, en);
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIBPINCTRL);
+
+		CHECK_ERROR(pmic_write_reg(REG_POWER_MISCELLANEOUS,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets state of control of VVIB by VIBEN pin.
+ * Only on mc13783 2.0 or higher
+ * @param        en           if true, VIBPINCTRL is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_gets_vib_pin_state(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGCTRL_VIBPINCTRL);
+		CHECK_ERROR(pmic_read_reg(REG_POWER_MISCELLANEOUS,
+					  &reg_val, reg_mask));
+		*en = BITFEXT(reg_val, MC13783_REGCTRL_VIBPINCTRL);
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function returns power up sense value
+ *
+ * @param        p_up_sense     value of power up sense
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_power_mode_sense(struct t_p_up_sense *p_up_sense)
+{
+	unsigned int reg_value = 0;
+	CHECK_ERROR(pmic_read_reg(REG_POWER_UP_MODE_SENSE,
+				  &reg_value, PMIC_ALL_BITS));
+	p_up_sense->state_ictest = (STATE_ICTEST_MASK & reg_value);
+	p_up_sense->state_clksel = ((STATE_CLKSEL_MASK & reg_value)
+				    >> STATE_CLKSEL_BIT);
+	p_up_sense->state_pums1 = ((STATE_PUMS1_MASK & reg_value)
+				   >> STATE_PUMS1_BITS);
+	p_up_sense->state_pums2 = ((STATE_PUMS2_MASK & reg_value)
+				   >> STATE_PUMS2_BITS);
+	p_up_sense->state_pums3 = ((STATE_PUMS3_MASK & reg_value)
+				   >> STATE_PUMS3_BITS);
+	p_up_sense->state_chrgmode0 = ((STATE_CHRGM1_MASK & reg_value)
+				       >> STATE_CHRGM1_BITS);
+	p_up_sense->state_chrgmode1 = ((STATE_CHRGM2_MASK & reg_value)
+				       >> STATE_CHRGM2_BITS);
+	p_up_sense->state_umod = ((STATE_UMOD_MASK & reg_value)
+				  >> STATE_UMOD_BITS);
+	p_up_sense->state_usben = ((STATE_USBEN_MASK & reg_value)
+				   >> STATE_USBEN_BIT);
+	p_up_sense->state_sw_1a1b_joined = ((STATE_SW1A_J_B_MASK & reg_value)
+					    >> STATE_SW1A_J_B_BIT);
+	p_up_sense->state_sw_2a2b_joined = ((STATE_SW2A_J_B_MASK & reg_value)
+					    >> STATE_SW2A_J_B_BIT);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function configures the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         if true, the regulator is enabled by regen.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_assig(t_pmic_regulator regulator, bool en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		reg_val = BITFVAL(MC13783_REGGEN_VAUDIO, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		reg_val = BITFVAL(MC13783_REGGEN_VIOHI, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		reg_val = BITFVAL(MC13783_REGGEN_VIOLO, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		reg_val = BITFVAL(MC13783_REGGEN_VDIG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		reg_val = BITFVAL(MC13783_REGGEN_VGEN, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFDIG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFREF, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFCP, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		reg_val = BITFVAL(MC13783_REGGEN_VCAM, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		reg_val = BITFVAL(MC13783_REGGEN_VRFBG, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		reg_val = BITFVAL(MC13783_REGGEN_VRF1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		reg_val = BITFVAL(MC13783_REGGEN_VRF2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		reg_val = BITFVAL(MC13783_REGGEN_VMMC1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		reg_val = BITFVAL(MC13783_REGGEN_VMMC2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO1, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO2, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO3, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		reg_val = BITFVAL(MC13783_REGGEN_GPO4, en_dis);
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO4);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         return value, if true :
+ *                              the regulator is enabled by regen.
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_assig(t_pmic_regulator regulator,
+				       bool *en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		reg_mask = BITFMASK(MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		reg_mask = BITFMASK(MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		reg_mask = BITFMASK(MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		reg_mask = BITFMASK(MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		reg_mask = BITFMASK(MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		reg_mask = BITFMASK(MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		reg_mask = BITFMASK(MC13783_REGGEN_GPO4);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT, &reg_val, reg_mask));
+
+	switch (regulator) {
+	case REGU_VAUDIO:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VAUDIO);
+		break;
+	case REGU_VIOHI:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VIOHI);
+		break;
+	case REGU_VIOLO:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VIOLO);
+		break;
+	case REGU_VDIG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VDIG);
+		break;
+	case REGU_VGEN:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VGEN);
+		break;
+	case REGU_VRFDIG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFDIG);
+		break;
+	case REGU_VRFREF:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFREF);
+		break;
+	case REGU_VRFCP:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFCP);
+		break;
+	case REGU_VCAM:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VCAM);
+		break;
+	case REGU_VRFBG:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRFBG);
+		break;
+	case REGU_VRF1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRF1);
+		break;
+	case REGU_VRF2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VRF2);
+		break;
+	case REGU_VMMC1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VMMC1);
+		break;
+	case REGU_VMMC2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_VMMC2);
+		break;
+	case REGU_GPO1:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO1);
+		break;
+	case REGU_GPO2:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO2);
+		break;
+	case REGU_GPO3:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO3);
+		break;
+	case REGU_GPO4:
+		*en_dis = BITFEXT(reg_val, MC13783_REGGEN_GPO4);
+		break;
+	default:
+		break;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function sets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_inv(bool en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_val = BITFVAL(MC13783_REGGEN_INV, en_dis);
+	reg_mask = BITFMASK(MC13783_REGGEN_INV);
+
+	CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT, reg_val, reg_mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_inv(bool *en_dis)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_mask = BITFMASK(MC13783_REGGEN_INV);
+	CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT, &reg_val, reg_mask));
+	*en_dis = BITFEXT(reg_val, MC13783_REGGEN_INV);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function enables esim control voltage.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_esim_v_en(bool vesim, bool vmmc1, bool vmmc2)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_val = BITFVAL(MC13783_REGGEN_VESIMESIM, vesim) |
+		    BITFVAL(MC13783_REGGEN_VMMC1ESIM, vesim) |
+		    BITFVAL(MC13783_REGGEN_VMMC2ESIM, vesim);
+		reg_mask = BITFMASK(MC13783_REGGEN_VESIMESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC1ESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC2ESIM);
+		CHECK_ERROR(pmic_write_reg(REG_REGEN_ASSIGNMENT,
+					   reg_val, reg_mask));
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function gets esim control voltage values.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_gets_esim_v_state(bool *vesim, bool *vmmc1,
+					 bool *vmmc2)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	pmic_version_t mc13783_ver;
+	mc13783_ver = pmic_get_version();
+	if (mc13783_ver.revision >= 20) {
+		reg_mask = BITFMASK(MC13783_REGGEN_VESIMESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC1ESIM) |
+		    BITFMASK(MC13783_REGGEN_VMMC2ESIM);
+		CHECK_ERROR(pmic_read_reg(REG_REGEN_ASSIGNMENT,
+					  &reg_val, reg_mask));
+		*vesim = BITFEXT(reg_val, MC13783_REGGEN_VESIMESIM);
+		*vmmc1 = BITFEXT(reg_val, MC13783_REGGEN_VMMC1ESIM);
+		*vmmc2 = BITFEXT(reg_val, MC13783_REGGEN_VMMC2ESIM);
+		return PMIC_SUCCESS;
+	} else {
+		return PMIC_NOT_SUPPORTED;
+	}
+}
+
+/*!
+ * This function enables auto reset after a system reset.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_auto_reset_en(bool en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_val = BITFVAL(MC13783_AUTO_RESTART, en);
+	reg_mask = BITFMASK(MC13783_AUTO_RESTART);
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_2, reg_val, reg_mask));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets auto reset configuration.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_auto_reset_en(bool *en)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	reg_mask = BITFMASK(MC13783_AUTO_RESTART);
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_2, &reg_val, reg_mask));
+	*en = BITFEXT(reg_val, MC13783_AUTO_RESTART);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function configures a system reset on a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, enable the system reset on this button
+ * @param       deb_time   sets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_conf_button(t_button bt, bool sys_rst, int deb_time)
+{
+	int max_val = 0;
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	max_val = (1 << MC13783_DEB_BT_ON1B_WID) - 1;
+	if (deb_time > max_val)
+		return PMIC_PARAMETER_ERROR;
+
+
+	switch (bt) {
+	case BT_ON1B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON1B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON1B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON1B) |
+		    BITFMASK(MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON2B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON2B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON2B) |
+		    BITFMASK(MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		reg_val = BITFVAL(MC13783_EN_BT_ON3B, sys_rst) |
+		    BITFVAL(MC13783_DEB_BT_ON3B, deb_time);
+		reg_mask = BITFMASK(MC13783_EN_BT_ON3B) |
+		    BITFMASK(MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_POWER_CONTROL_2, reg_val, reg_mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function gets configuration of a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, the system reset is enabled on this button
+ * @param       deb_time   gets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_conf_button(t_button bt,
+				       bool *sys_rst, int *deb_time)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+
+	switch (bt) {
+	case BT_ON1B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON1B) |
+		    BITFMASK(MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON2B) |
+		    BITFMASK(MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		reg_mask = BITFMASK(MC13783_EN_BT_ON3B) |
+		    BITFMASK(MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(REG_POWER_CONTROL_2, &reg_val, reg_mask));
+
+	switch (bt) {
+	case BT_ON1B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON1B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON1B);
+		break;
+	case BT_ON2B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON2B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON2B);
+		break;
+	case BT_ON3B:
+		*sys_rst = BITFEXT(reg_val, MC13783_EN_BT_ON3B);
+		*deb_time = BITFEXT(reg_val, MC13783_DEB_BT_ON3B);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to un/subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ * @param        sub            define if Un/subscribe event.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event(t_pwr_int event, void *callback, bool sub)
+{
+	pmic_event_callback_t power_callback;
+	type_event power_event;
+
+	power_callback.func = callback;
+	power_callback.param = NULL;
+	switch (event) {
+	case PWR_IT_BPONI:
+		power_event = EVENT_BPONI;
+		break;
+	case PWR_IT_LOBATLI:
+		power_event = EVENT_LOBATLI;
+		break;
+	case PWR_IT_LOBATHI:
+		power_event = EVENT_LOBATHI;
+		break;
+	case PWR_IT_ONOFD1I:
+		power_event = EVENT_ONOFD1I;
+		break;
+	case PWR_IT_ONOFD2I:
+		power_event = EVENT_ONOFD2I;
+		break;
+	case PWR_IT_ONOFD3I:
+		power_event = EVENT_ONOFD3I;
+		break;
+	case PWR_IT_SYSRSTI:
+		power_event = EVENT_SYSRSTI;
+		break;
+	case PWR_IT_PWRRDYI:
+		power_event = EVENT_PWRRDYI;
+		break;
+	case PWR_IT_PCI:
+		power_event = EVENT_PCI;
+		break;
+	case PWR_IT_WARMI:
+		power_event = EVENT_WARMI;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	if (sub == true) {
+		CHECK_ERROR(pmic_event_subscribe(power_event, power_callback));
+	} else {
+		CHECK_ERROR(pmic_event_unsubscribe
+			    (power_event, power_callback));
+	}
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_sub(t_pwr_int event, void *callback)
+{
+	return pmic_power_event(event, callback, true);
+}
+
+/*!
+ * This function is used to un subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_unsub(t_pwr_int event, void *callback)
+{
+	return pmic_power_event(event, callback, false);
+}
+
+void pmic_power_key_callback(void)
+{
+#ifdef CONFIG_MXC_HWEVENT
+	/*read the power key is pressed or up */
+	t_sensor_bits sense;
+	struct mxc_hw_event event = { HWE_POWER_KEY, 0 };
+
+	pmic_get_sensors(&sense);
+	if (sense.sense_onofd1s) {
+		pr_debug("PMIC Power key up\n");
+		event.args = PWRK_UNPRESS;
+	} else {
+		pr_debug("PMIC Power key pressed\n");
+		event.args = PWRK_PRESS;
+	}
+	/* send hw event */
+	hw_event_send(HWE_DEF_PRIORITY, &event);
+#endif
+}
+
+static irqreturn_t power_key_int(int irq, void *dev_id)
+{
+	pr_info(KERN_INFO "on-off key pressed\n");
+
+	return 0;
+}
+
+extern void gpio_power_key_active(void);
+
+/*
+ * Init and Exit
+ */
+
+static int pmic_power_probe(struct platform_device *pdev)
+{
+	int irq, ret;
+	struct pmic_platform_data *ppd;
+
+	/* configure on/off button */
+	gpio_power_key_active();
+
+	ppd = pdev->dev.platform_data;
+	if (ppd)
+		irq = ppd->power_key_irq;
+	else
+		goto done;
+
+	if (irq == 0) {
+		pr_info(KERN_INFO "PMIC Power has no platform data\n");
+		goto done;
+	}
+	set_irq_type(irq, IRQF_TRIGGER_RISING);
+
+	ret = request_irq(irq, power_key_int, 0, "power_key", 0);
+	if (ret)
+		pr_info(KERN_ERR "register on-off key interrupt failed\n");
+
+	set_irq_wake(irq, 1);
+
+done:
+	pr_info(KERN_INFO "PMIC Power successfully probed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_power_driver_ldm = {
+	.driver = {
+		   .name = "pmic_power",
+		   },
+	.suspend = pmic_power_suspend,
+	.resume = pmic_power_resume,
+	.probe = pmic_power_probe,
+	.remove = NULL,
+};
+
+static int __init pmic_power_init(void)
+{
+	pr_debug("PMIC Power driver loading..\n");
+	pmic_power_event_sub(PWR_IT_ONOFD1I, pmic_power_key_callback);
+	/* set power off hook to mc13783 power off */
+	pm_power_off = pmic_power_off;
+	return platform_driver_register(&pmic_power_driver_ldm);
+}
+static void __exit pmic_power_exit(void)
+{
+	pmic_power_event_unsub(PWR_IT_ONOFD1I, pmic_power_key_callback);
+	platform_driver_unregister(&pmic_power_driver_ldm);
+	pr_debug("PMIC Power driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall_sync(pmic_power_init);
+module_exit(pmic_power_exit);
+
+MODULE_DESCRIPTION("pmic_power driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_power_defs.h b/drivers/mxc/pmic/mc13783/pmic_power_defs.h
new file mode 100644
index 0000000..38e5541
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_power_defs.h
@@ -0,0 +1,509 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_power_defs.h
+ * @brief This is the internal header define of PMIC(mc13783) Power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+/*
+ * Includes
+ */
+
+#ifndef __MC13783_POWER_DEFS_H__
+#define __MC13783_POWER_DEFS_H__
+
+/*
+ * Power Up Mode Sense bits
+ */
+
+#define         STATE_ICTEST_MASK       0x000001
+
+#define         STATE_CLKSEL_BIT        1
+#define         STATE_CLKSEL_MASK       0x000002
+
+#define         STATE_PUMS1_BITS        2
+#define         STATE_PUMS1_MASK        0x00000C
+
+#define         STATE_PUMS2_BITS        4
+#define         STATE_PUMS2_MASK        0x000030
+
+#define         STATE_PUMS3_BITS        6
+#define         STATE_PUMS3_MASK        0x0000C0
+
+#define         STATE_CHRGM1_BITS       8
+#define         STATE_CHRGM1_MASK       0x000300
+
+#define         STATE_CHRGM2_BITS       10
+#define         STATE_CHRGM2_MASK       0x000C00
+
+#define         STATE_UMOD_BITS         12
+#define         STATE_UMOD_MASK         0x003000
+
+#define         STATE_USBEN_BIT         14
+#define         STATE_USBEN_MASK        0x004000
+
+#define         STATE_SW1A_J_B_BIT      15
+#define         STATE_SW1A_J_B_MASK     0x008000
+
+#define         STATE_SW2A_J_B_BIT      16
+#define         STATE_SW2A_J_B_MASK     0x010000
+
+#define         PC_COUNT_MAX            3
+#define         PC_COUNT_MIN            0
+/*
+ * Reg Regen
+ */
+#define MC13783_REGGEN_VAUDIO_LSH			0
+#define MC13783_REGGEN_VAUDIO_WID			1
+#define MC13783_REGGEN_VIOHI_LSH			1
+#define MC13783_REGGEN_VIOHI_WID			1
+#define MC13783_REGGEN_VIOLO_LSH			2
+#define MC13783_REGGEN_VIOLO_WID			1
+#define MC13783_REGGEN_VDIG_LSH			3
+#define MC13783_REGGEN_VDIG_WID			1
+#define MC13783_REGGEN_VGEN_LSH			4
+#define MC13783_REGGEN_VGEN_WID			1
+#define MC13783_REGGEN_VRFDIG_LSH			5
+#define MC13783_REGGEN_VRFDIG_WID			1
+#define MC13783_REGGEN_VRFREF_LSH			6
+#define MC13783_REGGEN_VRFREF_WID			1
+#define MC13783_REGGEN_VRFCP_LSH			7
+#define MC13783_REGGEN_VRFCP_WID			1
+#define MC13783_REGGEN_VCAM_LSH			8
+#define MC13783_REGGEN_VCAM_WID			1
+#define MC13783_REGGEN_VRFBG_LSH			9
+#define MC13783_REGGEN_VRFBG_WID			1
+#define MC13783_REGGEN_VRF1_LSH			10
+#define MC13783_REGGEN_VRF1_WID			1
+#define MC13783_REGGEN_VRF2_LSH			11
+#define MC13783_REGGEN_VRF2_WID			1
+#define MC13783_REGGEN_VMMC1_LSH			12
+#define MC13783_REGGEN_VMMC1_WID			1
+#define MC13783_REGGEN_VMMC2_LSH			13
+#define MC13783_REGGEN_VMMC2_WID			1
+#define MC13783_REGGEN_GPO1_LSH			16
+#define MC13783_REGGEN_GPO1_WID			1
+#define MC13783_REGGEN_GPO2_LSH			17
+#define MC13783_REGGEN_GPO2_WID			1
+#define MC13783_REGGEN_GPO3_LSH			18
+#define MC13783_REGGEN_GPO3_WID			1
+#define MC13783_REGGEN_GPO4_LSH			19
+#define MC13783_REGGEN_GPO4_WID			1
+#define MC13783_REGGEN_INV_LSH			20
+#define MC13783_REGGEN_INV_WID			1
+#define MC13783_REGGEN_VESIMESIM_LSH		21
+#define MC13783_REGGEN_VESIMESIM_WID		1
+#define MC13783_REGGEN_VMMC1ESIM_LSH		22
+#define MC13783_REGGEN_VMMC1ESIM_WID		1
+#define MC13783_REGGEN_VMMC2ESIM_LSH		23
+#define MC13783_REGGEN_VMMC2ESIM_WID		1
+
+/*
+ * Reg Power Control 0
+ */
+#define MC13783_PWRCTRL_PCEN_LSH			0
+#define MC13783_PWRCTRL_PCEN_WID			1
+#define MC13783_PWRCTRL_PCEN_ENABLE		1
+#define MC13783_PWRCTRL_PCEN_DISABLE		0
+#define MC13783_PWRCTRL_PC_COUNT_EN_LSH		1
+#define MC13783_PWRCTRL_PC_COUNT_EN_WID		1
+#define MC13783_PWRCTRL_PC_COUNT_EN_ENABLE	1
+#define MC13783_PWRCTRL_PC_COUNT_EN_DISABLE	0
+#define MC13783_PWRCTRL_WARM_EN_LSH		2
+#define MC13783_PWRCTRL_WARM_EN_WID		1
+#define MC13783_PWRCTRL_WARM_EN_ENABLE		1
+#define MC13783_PWRCTRL_WARM_EN_DISABLE		0
+#define MC13783_PWRCTRL_USER_OFF_SPI_LSH		3
+#define MC13783_PWRCTRL_USER_OFF_SPI_WID		1
+#define MC13783_PWRCTRL_USER_OFF_SPI_ENABLE	1
+#define MC13783_PWRCTRL_USER_OFF_PC_LSH		4
+#define MC13783_PWRCTRL_USER_OFF_PC_WID		1
+#define MC13783_PWRCTRL_USER_OFF_PC_ENABLE	1
+#define MC13783_PWRCTRL_USER_OFF_PC_DISABLE	0
+#define MC13783_PWRCTRL_32OUT_USER_OFF_LSH	5
+#define MC13783_PWRCTRL_32OUT_USER_OFF_WID	1
+#define MC13783_PWRCTRL_32OUT_USER_OFF_ENABLE	1
+#define MC13783_PWRCTRL_32OUT_USER_OFF_DISABLE	0
+#define MC13783_PWRCTRL_32OUT_EN_LSH		6
+#define MC13783_PWRCTRL_32OUT_EN_WID		1
+#define MC13783_PWRCTRL_32OUT_EN_ENABLE		1
+#define MC13783_PWRCTRL_32OUT_EN_DISABLE		0
+#define MC13783_REGCTRL_VBKUP2AUTOMH_LSH		7
+#define MC13783_REGCTRL_VBKUP2AUTOMH_WID		1
+#define MC13783_PWRCTRL_VBKUP1_EN_LSH		8
+#define MC13783_PWRCTRL_VBKUP1_EN_WID		1
+#define MC13783_PWRCTRL_VBKUP_ENABLE		1
+#define MC13783_PWRCTRL_VBKUP_DISABLE		0
+#define MC13783_PWRCTRL_VBKUP1_AUTO_EN_LSH	9
+#define MC13783_PWRCTRL_VBKUP1_AUTO_EN_WID	1
+#define MC13783_PWRCTRL_VBKUP1_LSH		10
+#define MC13783_PWRCTRL_VBKUP1_WID		2
+#define MC13783_PWRCTRL_VBKUP2_EN_LSH		12
+#define MC13783_PWRCTRL_VBKUP2_EN_WID		1
+#define MC13783_PWRCTRL_VBKUP2_AUTO_EN_LSH	13
+#define MC13783_PWRCTRL_VBKUP2_AUTO_EN_WID	1
+#define MC13783_PWRCTRL_VBKUP2_LSH		14
+#define MC13783_PWRCTRL_VBKUP2_WID		2
+#define MC13783_REGCTRL_BATTDETEN_LSH		19
+#define MC13783_REGCTRL_BATTDETEN_WID		1
+
+/*
+ * Reg Power Control 1
+ */
+#define MC13783_PWRCTRL_PCT_LSH		0
+#define MC13783_PWRCTRL_PCT_WID		8
+#define MC13783_PWRCTRL_PC_COUNT_LSH	8
+#define MC13783_PWRCTRL_PC_COUNT_WID	4
+#define MC13783_PWRCTRL_PC_MAX_CNT_LSH	12
+#define MC13783_PWRCTRL_PC_MAX_CNT_WID	4
+#define MC13783_PWRCTRL_MEM_TMR_LSH	16
+#define MC13783_PWRCTRL_MEM_TMR_WID	4
+#define MC13783_PWRCTRL_MEM_ALLON_LSH	20
+#define MC13783_PWRCTRL_MEM_ALLON_WID	1
+#define MC13783_PWRCTRL_MEM_ALLON_ENABLE	1
+#define MC13783_PWRCTRL_MEM_ALLON_DISABLE	0
+
+/*
+ * Reg Power Control 2
+ */
+#define MC13783_AUTO_RESTART_LSH	0
+#define MC13783_AUTO_RESTART_WID	1
+#define MC13783_EN_BT_ON1B_LSH		1
+#define MC13783_EN_BT_ON1B_WID		1
+#define MC13783_EN_BT_ON2B_LSH		2
+#define MC13783_EN_BT_ON2B_WID		1
+#define MC13783_EN_BT_ON3B_LSH		3
+#define MC13783_EN_BT_ON3B_WID		1
+#define MC13783_DEB_BT_ON1B_LSH		4
+#define MC13783_DEB_BT_ON1B_WID		2
+#define MC13783_DEB_BT_ON2B_LSH		6
+#define MC13783_DEB_BT_ON2B_WID		2
+#define MC13783_DEB_BT_ON3B_LSH		8
+#define MC13783_DEB_BT_ON3B_WID		2
+
+/*
+ * Reg Regulator Mode 0
+ */
+#define MC13783_REGCTRL_VAUDIO_EN_LSH	0
+#define MC13783_REGCTRL_VAUDIO_EN_WID	1
+#define MC13783_REGCTRL_VAUDIO_EN_ENABLE	1
+#define MC13783_REGCTRL_VAUDIO_EN_DISABLE	0
+#define MC13783_REGCTRL_VAUDIO_STBY_LSH	1
+#define MC13783_REGCTRL_VAUDIO_STBY_WID	1
+#define MC13783_REGCTRL_VAUDIO_MODE_LSH	2
+#define MC13783_REGCTRL_VAUDIO_MODE_WID	1
+#define MC13783_REGCTRL_VIOHI_EN_LSH	3
+#define MC13783_REGCTRL_VIOHI_EN_WID	1
+#define MC13783_REGCTRL_VIOHI_EN_ENABLE	1
+#define MC13783_REGCTRL_VIOHI_EN_DISABLE	0
+#define MC13783_REGCTRL_VIOHI_STBY_LSH	4
+#define MC13783_REGCTRL_VIOHI_STBY_WID	1
+#define MC13783_REGCTRL_VIOHI_MODE_LSH	5
+#define MC13783_REGCTRL_VIOHI_MODE_WID	1
+#define MC13783_REGCTRL_VIOLO_EN_LSH	6
+#define MC13783_REGCTRL_VIOLO_EN_WID	1
+#define MC13783_REGCTRL_VIOLO_EN_ENABLE	1
+#define MC13783_REGCTRL_VIOLO_EN_DISABLE	0
+#define MC13783_REGCTRL_VIOLO_STBY_LSH	7
+#define MC13783_REGCTRL_VIOLO_STBY_WID	1
+#define MC13783_REGCTRL_VIOLO_MODE_LSH	8
+#define MC13783_REGCTRL_VIOLO_MODE_WID	1
+#define MC13783_REGCTRL_VDIG_EN_LSH	9
+#define MC13783_REGCTRL_VDIG_EN_WID	1
+#define MC13783_REGCTRL_VDIG_EN_ENABLE	1
+#define MC13783_REGCTRL_VDIG_EN_DISABLE	0
+#define MC13783_REGCTRL_VDIG_STBY_LSH	10
+#define MC13783_REGCTRL_VDIG_STBY_WID	1
+#define MC13783_REGCTRL_VDIG_MODE_LSH	11
+#define MC13783_REGCTRL_VDIG_MODE_WID	1
+#define MC13783_REGCTRL_VGEN_EN_LSH	12
+#define MC13783_REGCTRL_VGEN_EN_WID	1
+#define MC13783_REGCTRL_VGEN_EN_ENABLE	1
+#define MC13783_REGCTRL_VGEN_EN_DISABLE	0
+#define MC13783_REGCTRL_VGEN_STBY_LSH	13
+#define MC13783_REGCTRL_VGEN_STBY_WID	1
+#define MC13783_REGCTRL_VGEN_MODE_LSH	14
+#define MC13783_REGCTRL_VGEN_MODE_WID	1
+#define MC13783_REGCTRL_VRFDIG_EN_LSH	15
+#define MC13783_REGCTRL_VRFDIG_EN_WID	1
+#define MC13783_REGCTRL_VRFDIG_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFDIG_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFDIG_STBY_LSH	16
+#define MC13783_REGCTRL_VRFDIG_STBY_WID	1
+#define MC13783_REGCTRL_VRFDIG_MODE_LSH	17
+#define MC13783_REGCTRL_VRFDIG_MODE_WID	1
+#define MC13783_REGCTRL_VRFREF_EN_LSH	18
+#define MC13783_REGCTRL_VRFREF_EN_WID	1
+#define MC13783_REGCTRL_VRFREF_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFREF_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFREF_STBY_LSH	19
+#define MC13783_REGCTRL_VRFREF_STBY_WID	1
+#define MC13783_REGCTRL_VRFREF_MODE_LSH	20
+#define MC13783_REGCTRL_VRFREF_MODE_WID	1
+#define MC13783_REGCTRL_VRFCP_EN_LSH	21
+#define MC13783_REGCTRL_VRFCP_EN_WID	1
+#define MC13783_REGCTRL_VRFCP_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFCP_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFCP_STBY_LSH	22
+#define MC13783_REGCTRL_VRFCP_STBY_WID	1
+#define MC13783_REGCTRL_VRFCP_MODE_LSH	23
+#define MC13783_REGCTRL_VRFCP_MODE_WID	1
+
+/*
+ * Reg Regulator Mode 1
+ */
+#define MC13783_REGCTRL_VSIM_EN_LSH	0
+#define MC13783_REGCTRL_VSIM_EN_WID	1
+#define MC13783_REGCTRL_VSIM_EN_ENABLE	1
+#define MC13783_REGCTRL_VSIM_EN_DISABLE	0
+#define MC13783_REGCTRL_VSIM_STBY_LSH	1
+#define MC13783_REGCTRL_VSIM_STBY_WID	1
+#define MC13783_REGCTRL_VSIM_MODE_LSH	2
+#define MC13783_REGCTRL_VSIM_MODE_WID	1
+#define MC13783_REGCTRL_VESIM_EN_LSH	3
+#define MC13783_REGCTRL_VESIM_EN_WID	1
+#define MC13783_REGCTRL_VESIM_EN_ENABLE	1
+#define MC13783_REGCTRL_VESIM_EN_DISABLE	0
+#define MC13783_REGCTRL_VESIM_STBY_LSH	4
+#define MC13783_REGCTRL_VESIM_STBY_WID	1
+#define MC13783_REGCTRL_VESIM_MODE_LSH	5
+#define MC13783_REGCTRL_VESIM_MODE_WID	1
+#define MC13783_REGCTRL_VCAM_EN_LSH	6
+#define MC13783_REGCTRL_VCAM_EN_WID	1
+#define MC13783_REGCTRL_VCAM_EN_ENABLE	1
+#define MC13783_REGCTRL_VCAM_EN_DISABLE	0
+#define MC13783_REGCTRL_VCAM_STBY_LSH	7
+#define MC13783_REGCTRL_VCAM_STBY_WID	1
+#define MC13783_REGCTRL_VCAM_MODE_LSH	8
+#define MC13783_REGCTRL_VCAM_MODE_WID	1
+#define	MC13783_REGCTRL_VRFBG_EN_LSH	9
+#define	MC13783_REGCTRL_VRFBG_EN_WID	1
+#define MC13783_REGCTRL_VRFBG_EN_ENABLE	1
+#define MC13783_REGCTRL_VRFBG_EN_DISABLE	0
+#define MC13783_REGCTRL_VRFBG_STBY_LSH	10
+#define MC13783_REGCTRL_VRFBG_STBY_WID	1
+#define MC13783_REGCTRL_VVIB_EN_LSH	11
+#define MC13783_REGCTRL_VVIB_EN_WID	1
+#define MC13783_REGCTRL_VVIB_EN_ENABLE	1
+#define MC13783_REGCTRL_VVIB_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF1_EN_LSH	12
+#define MC13783_REGCTRL_VRF1_EN_WID	1
+#define MC13783_REGCTRL_VRF1_EN_ENABLE	1
+#define MC13783_REGCTRL_VRF1_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF1_STBY_LSH	13
+#define MC13783_REGCTRL_VRF1_STBY_WID	1
+#define MC13783_REGCTRL_VRF1_MODE_LSH	14
+#define MC13783_REGCTRL_VRF1_MODE_WID	1
+#define MC13783_REGCTRL_VRF2_EN_LSH	15
+#define MC13783_REGCTRL_VRF2_EN_WID	1
+#define MC13783_REGCTRL_VRF2_EN_ENABLE	1
+#define MC13783_REGCTRL_VRF2_EN_DISABLE	0
+#define MC13783_REGCTRL_VRF2_STBY_LSH	16
+#define MC13783_REGCTRL_VRF2_STBY_WID	1
+#define MC13783_REGCTRL_VRF2_MODE_LSH	17
+#define MC13783_REGCTRL_VRF2_MODE_WID	1
+#define MC13783_REGCTRL_VMMC1_EN_LSH	18
+#define MC13783_REGCTRL_VMMC1_EN_WID	1
+#define MC13783_REGCTRL_VMMC1_EN_ENABLE	1
+#define MC13783_REGCTRL_VMMC1_EN_DISABLE	0
+#define MC13783_REGCTRL_VMMC1_STBY_LSH	19
+#define MC13783_REGCTRL_VMMC1_STBY_WID	1
+#define MC13783_REGCTRL_VMMC1_MODE_LSH	20
+#define MC13783_REGCTRL_VMMC1_MODE_WID	1
+#define MC13783_REGCTRL_VMMC2_EN_LSH	21
+#define MC13783_REGCTRL_VMMC2_EN_WID	1
+#define MC13783_REGCTRL_VMMC2_EN_ENABLE	1
+#define MC13783_REGCTRL_VMMC2_EN_DISABLE	0
+#define MC13783_REGCTRL_VMMC2_STBY_LSH	22
+#define MC13783_REGCTRL_VMMC2_STBY_WID	1
+#define MC13783_REGCTRL_VMMC2_MODE_LSH	23
+#define MC13783_REGCTRL_VMMC2_MODE_WID	1
+
+/*
+ * Reg Regulator Misc.
+ */
+#define MC13783_REGCTRL_GPO1_EN_LSH	6
+#define MC13783_REGCTRL_GPO1_EN_WID	1
+#define MC13783_REGCTRL_GPO1_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO1_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO2_EN_LSH	8
+#define MC13783_REGCTRL_GPO2_EN_WID	1
+#define MC13783_REGCTRL_GPO2_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO2_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO3_EN_LSH	10
+#define MC13783_REGCTRL_GPO3_EN_WID	1
+#define MC13783_REGCTRL_GPO3_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO3_EN_DISABLE	0
+#define MC13783_REGCTRL_GPO4_EN_LSH	12
+#define MC13783_REGCTRL_GPO4_EN_WID	1
+#define MC13783_REGCTRL_GPO4_EN_ENABLE	1
+#define MC13783_REGCTRL_GPO4_EN_DISABLE	0
+#define MC13783_REGCTRL_VIBPINCTRL_LSH	14
+#define MC13783_REGCTRL_VIBPINCTRL_WID	1
+
+/*
+ * Reg Regulator Setting 0
+ */
+#define MC13783_REGSET_VIOLO_LSH		2
+#define MC13783_REGSET_VIOLO_WID		2
+#define MC13783_REGSET_VDIG_LSH		4
+#define MC13783_REGSET_VDIG_WID		2
+#define MC13783_REGSET_VGEN_LSH		6
+#define MC13783_REGSET_VGEN_WID		3
+#define MC13783_REGSET_VRFDIG_LSH		9
+#define MC13783_REGSET_VRFDIG_WID		2
+#define MC13783_REGSET_VRFREF_LSH		11
+#define MC13783_REGSET_VRFREF_WID		2
+#define MC13783_REGSET_VRFCP_LSH		13
+#define MC13783_REGSET_VRFCP_WID		1
+#define MC13783_REGSET_VSIM_LSH		14
+#define MC13783_REGSET_VSIM_WID		1
+#define MC13783_REGSET_VESIM_LSH		15
+#define MC13783_REGSET_VESIM_WID		1
+#define MC13783_REGSET_VCAM_LSH		16
+#define MC13783_REGSET_VCAM_WID		3
+
+/*
+ * Reg Regulator Setting 1
+ */
+#define MC13783_REGSET_VVIB_LSH		0
+#define MC13783_REGSET_VVIB_WID		2
+#define MC13783_REGSET_VRF1_LSH		2
+#define MC13783_REGSET_VRF1_WID		2
+#define MC13783_REGSET_VRF2_LSH		4
+#define MC13783_REGSET_VRF2_WID		2
+#define MC13783_REGSET_VMMC1_LSH		6
+#define MC13783_REGSET_VMMC1_WID		3
+#define MC13783_REGSET_VMMC2_LSH		9
+#define MC13783_REGSET_VMMC2_WID		3
+
+/*
+ * Reg Switcher 0
+ */
+#define MC13783_SWSET_SW1A_LSH		0
+#define MC13783_SWSET_SW1A_WID		6
+#define MC13783_SWSET_SW1A_DVS_LSH	6
+#define MC13783_SWSET_SW1A_DVS_WID	6
+#define MC13783_SWSET_SW1A_STDBY_LSH	12
+#define MC13783_SWSET_SW1A_STDBY_WID	6
+
+/*
+ * Reg Switcher 1
+ */
+#define MC13783_SWSET_SW1B_LSH		0
+#define MC13783_SWSET_SW1B_WID		6
+#define MC13783_SWSET_SW1B_DVS_LSH	6
+#define MC13783_SWSET_SW1B_DVS_WID	6
+#define MC13783_SWSET_SW1B_STDBY_LSH	12
+#define MC13783_SWSET_SW1B_STDBY_WID	6
+
+/*
+ * Reg Switcher 2
+ */
+#define MC13783_SWSET_SW2A_LSH		0
+#define MC13783_SWSET_SW2A_WID		6
+#define MC13783_SWSET_SW2A_DVS_LSH	6
+#define MC13783_SWSET_SW2A_DVS_WID	6
+#define MC13783_SWSET_SW2A_STDBY_LSH	12
+#define MC13783_SWSET_SW2A_STDBY_WID	6
+
+/*
+ * Reg Switcher 3
+ */
+#define MC13783_SWSET_SW2B_LSH		0
+#define MC13783_SWSET_SW2B_WID		6
+#define MC13783_SWSET_SW2B_DVS_LSH	6
+#define MC13783_SWSET_SW2B_DVS_WID	6
+#define MC13783_SWSET_SW2B_STDBY_LSH	12
+#define MC13783_SWSET_SW2B_STDBY_WID	6
+
+/*
+ * Reg Switcher 4
+ */
+#define MC13783_SWCTRL_SW1A_MODE_LSH		0
+#define MC13783_SWCTRL_SW1A_MODE_WID		2
+#define MC13783_SWCTRL_SW1A_STBY_MODE_LSH		2
+#define MC13783_SWCTRL_SW1A_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW1A_DVS_SPEED_LSH		6
+#define MC13783_SWCTRL_SW1A_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW1A_PANIC_MODE_LSH	8
+#define MC13783_SWCTRL_SW1A_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW1A_SOFTSTART_LSH		9
+#define MC13783_SWCTRL_SW1A_SOFTSTART_WID		1
+#define MC13783_SWCTRL_SW1B_MODE_LSH		10
+#define MC13783_SWCTRL_SW1B_MODE_WID		2
+#define MC13783_SWCTRL_SW1B_STBY_MODE_LSH		12
+#define MC13783_SWCTRL_SW1B_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW1B_DVS_SPEED_LSH		14
+#define MC13783_SWCTRL_SW1B_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW1B_PANIC_MODE_LSH	16
+#define MC13783_SWCTRL_SW1B_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW1B_SOFTSTART_LSH		17
+#define MC13783_SWCTRL_SW1B_SOFTSTART_WID		1
+#define MC13783_SWCTRL_PLL_EN_LSH			18
+#define MC13783_SWCTRL_PLL_EN_WID			1
+#define MC13783_SWCTRL_PLL_EN_ENABLE		1
+#define MC13783_SWCTRL_PLL_EN_DISABLE		0
+#define MC13783_SWCTRL_PLL_FACTOR_LSH		19
+#define MC13783_SWCTRL_PLL_FACTOR_WID		3
+
+/*
+ * Reg Switcher 5
+ */
+#define MC13783_SWCTRL_SW2A_MODE_LSH		0
+#define MC13783_SWCTRL_SW2A_MODE_WID		2
+#define MC13783_SWCTRL_SW2A_STBY_MODE_LSH		2
+#define MC13783_SWCTRL_SW2A_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW2A_DVS_SPEED_LSH		6
+#define MC13783_SWCTRL_SW2A_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW2A_PANIC_MODE_LSH	8
+#define MC13783_SWCTRL_SW2A_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW2A_SOFTSTART_LSH		9
+#define MC13783_SWCTRL_SW2A_SOFTSTART_WID		1
+#define MC13783_SWCTRL_SW2B_MODE_LSH		10
+#define MC13783_SWCTRL_SW2B_MODE_WID		2
+#define MC13783_SWCTRL_SW2B_STBY_MODE_LSH		12
+#define MC13783_SWCTRL_SW2B_STBY_MODE_WID		2
+#define MC13783_SWCTRL_SW2B_DVS_SPEED_LSH		14
+#define MC13783_SWCTRL_SW2B_DVS_SPEED_WID		2
+#define MC13783_SWCTRL_SW2B_PANIC_MODE_LSH	16
+#define MC13783_SWCTRL_SW2B_PANIC_MODE_WID	1
+#define MC13783_SWCTRL_SW2B_SOFTSTART_LSH		17
+#define MC13783_SWCTRL_SW2B_SOFTSTART_WID		1
+#define MC13783_SWSET_SW3_LSH			18
+#define MC13783_SWSET_SW3_WID			2
+#define MC13783_SWCTRL_SW3_EN_LSH			20
+#define MC13783_SWCTRL_SW3_EN_WID			2
+#define MC13783_SWCTRL_SW3_EN_ENABLE		1
+#define MC13783_SWCTRL_SW3_EN_DISABLE		0
+#define MC13783_SWCTRL_SW3_STBY_LSH		21
+#define MC13783_SWCTRL_SW3_STBY_WID		1
+#define MC13783_SWCTRL_SW3_MODE_LSH		22
+#define MC13783_SWCTRL_SW3_MODE_WID		1
+
+/*
+ * Switcher configuration
+ */
+#define MC13783_SWCTRL_SW_MODE_SYNC_RECT_EN	0
+#define MC13783_SWCTRL_SW_MODE_PULSE_NO_SKIP_EN	1
+#define MC13783_SWCTRL_SW_MODE_PULSE_SKIP_EN	2
+#define MC13783_SWCTRL_SW_MODE_LOW_POWER_EN	3
+#define MC13783_REGTRL_LP_MODE_ENABLE		1
+#define MC13783_REGTRL_LP_MODE_DISABLE		0
+#define MC13783_REGTRL_STBY_MODE_ENABLE		1
+#define MC13783_REGTRL_STBY_MODE_DISABLE		0
+
+#endif				/*  __MC13783_POWER_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13783/pmic_rtc.c b/drivers/mxc/pmic/mc13783/pmic_rtc.c
new file mode 100644
index 0000000..5467c97
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_rtc.c
@@ -0,0 +1,546 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13783/pmic_rtc.c
+ * @brief This is the main file of PMIC(mc13783) RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/pmic_rtc.h>
+#include <linux/pmic_status.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+#include "pmic_rtc_defs.h"
+
+#define PMIC_LOAD_ERROR_MSG		\
+"PMIC card was not correctly detected. Stop loading PMIC RTC driver\n"
+
+/*
+ * Global variables
+ */
+static int pmic_rtc_major;
+static void callback_alarm_asynchronous(void *);
+static void callback_alarm_synchronous(void *);
+static unsigned int pmic_rtc_poll(struct file *file, poll_table * wait);
+static DECLARE_WAIT_QUEUE_HEAD(queue_alarm);
+static DECLARE_WAIT_QUEUE_HEAD(pmic_rtc_wait);
+static pmic_event_callback_t alarm_callback;
+static pmic_event_callback_t rtc_callback;
+static bool pmic_rtc_done;
+static struct class *pmic_rtc_class;
+
+static DECLARE_MUTEX(mutex);
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_rtc_set_time);
+EXPORT_SYMBOL(pmic_rtc_get_time);
+EXPORT_SYMBOL(pmic_rtc_set_time_alarm);
+EXPORT_SYMBOL(pmic_rtc_get_time_alarm);
+EXPORT_SYMBOL(pmic_rtc_wait_alarm);
+EXPORT_SYMBOL(pmic_rtc_event_sub);
+EXPORT_SYMBOL(pmic_rtc_event_unsub);
+
+/*
+ * Real Time Clock Pmic API
+ */
+
+/*!
+ * This is the callback function called on TSI Pmic event, used in asynchronous
+ * call.
+ */
+static void callback_alarm_asynchronous(void *unused)
+{
+	pmic_rtc_done = true;
+}
+
+/*!
+ * This is the callback function is used in test code for (un)sub.
+ */
+static void callback_test_sub(void)
+{
+	printk(KERN_INFO "*****************************************\n");
+	printk(KERN_INFO "***** PMIC RTC 'Alarm IT CallBack' ******\n");
+	printk(KERN_INFO "*****************************************\n");
+}
+
+/*!
+ * This is the callback function called on TSI Pmic event, used in synchronous
+ * call.
+ */
+static void callback_alarm_synchronous(void *unused)
+{
+	printk(KERN_INFO "*** Alarm IT Pmic ***\n");
+	wake_up(&queue_alarm);
+}
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void)
+{
+	DEFINE_WAIT(wait);
+	alarm_callback.func = callback_alarm_synchronous;
+	alarm_callback.param = NULL;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TODAI, alarm_callback));
+	prepare_to_wait(&queue_alarm, &wait, TASK_UNINTERRUPTIBLE);
+	schedule();
+	finish_wait(&queue_alarm, &wait);
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TODAI, alarm_callback));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time	value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	tod_reg_val = pmic_time->tv_sec % 86400;
+	day_reg_val = pmic_time->tv_sec / 86400;
+
+	mask = BITFMASK(MC13783_RTCTIME_TIME);
+	value = BITFVAL(MC13783_RTCTIME_TIME, tod_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_TIME, value, mask));
+
+	mask = BITFMASK(MC13783_RTCDAY_DAY);
+	value = BITFVAL(MC13783_RTCDAY_DAY, day_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_DAY, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time	return value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_RTCTIME_TIME);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_TIME, &value, mask));
+	tod_reg_val = BITFEXT(value, MC13783_RTCTIME_TIME);
+
+	mask = BITFMASK(MC13783_RTCDAY_DAY);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_DAY, &value, mask));
+	day_reg_val = BITFEXT(value, MC13783_RTCDAY_DAY);
+
+	pmic_time->tv_sec = (unsigned long)((unsigned long)(tod_reg_val &
+							    0x0001FFFF) +
+					    (unsigned long)(day_reg_val *
+							    86400));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time	value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+	int ret;
+	ret = down_interruptible(&mutex);
+	if (ret < 0)
+		return ret;
+
+	tod_reg_val = pmic_time->tv_sec % 86400;
+	day_reg_val = pmic_time->tv_sec / 86400;
+
+	mask = BITFMASK(MC13783_RTCALARM_TIME);
+	value = BITFVAL(MC13783_RTCALARM_TIME, tod_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_ALARM, value, mask));
+
+	mask = BITFMASK(MC13783_RTCALARM_DAY);
+	value = BITFVAL(MC13783_RTCALARM_DAY, day_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_DAY_ALARM, value, mask));
+	up(&mutex);
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time	return value of date and time
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+
+	mask = BITFMASK(MC13783_RTCALARM_TIME);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_ALARM, &value, mask));
+	tod_reg_val = BITFEXT(value, MC13783_RTCALARM_TIME);
+
+	mask = BITFMASK(MC13783_RTCALARM_DAY);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_DAY_ALARM, &value, mask));
+	day_reg_val = BITFEXT(value, MC13783_RTCALARM_DAY);
+
+	pmic_time->tv_sec = (unsigned long)((unsigned long)(tod_reg_val &
+							    0x0001FFFF) +
+					    (unsigned long)(day_reg_val *
+							    86400));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ * @param        sub		define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub)
+{
+	type_event rtc_event;
+	if (callback == NULL) {
+		return PMIC_ERROR;
+	} else {
+		rtc_callback.func = callback;
+		rtc_callback.param = NULL;
+	}
+	switch (event) {
+	case RTC_IT_ALARM:
+		rtc_event = EVENT_TODAI;
+		break;
+	case RTC_IT_1HZ:
+		rtc_event = EVENT_E1HZI;
+		break;
+	case RTC_IT_RST:
+		rtc_event = EVENT_RTCRSTI;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	if (sub == true)
+		CHECK_ERROR(pmic_event_subscribe(rtc_event, rtc_callback));
+	else
+		CHECK_ERROR(pmic_event_unsubscribe(rtc_event, rtc_callback));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback)
+{
+	CHECK_ERROR(pmic_rtc_event(event, callback, true));
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to un subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback)
+{
+	CHECK_ERROR(pmic_rtc_event(event, callback, false));
+	return PMIC_SUCCESS;
+}
+
+/* Called without the kernel lock - fine */
+static unsigned int pmic_rtc_poll(struct file *file, poll_table * wait)
+{
+	/*poll_wait(file, &pmic_rtc_wait, wait); */
+
+	if (pmic_rtc_done)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+/*!
+ * This function implements IOCTL controls on a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @param        cmd         the command
+ * @param        arg         the parameter
+ * @return       This function returns 0 if successful.
+ */
+static int pmic_rtc_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	struct timeval *pmic_time = NULL;
+
+	if (_IOC_TYPE(cmd) != 'p')
+		return -ENOTTY;
+
+	if (arg) {
+		pmic_time = kmalloc(sizeof(struct timeval), GFP_KERNEL);
+		if (pmic_time == NULL)
+			return -ENOMEM;
+
+		/*      if (copy_from_user(pmic_time, (struct timeval *)arg,
+		   sizeof(struct timeval))) {
+		   return -EFAULT;
+		   } */
+	}
+
+	switch (cmd) {
+	case PMIC_RTC_SET_TIME:
+		if (copy_from_user(pmic_time, (struct timeval *)arg,
+				   sizeof(struct timeval))) {
+			return -EFAULT;
+		}
+		pr_debug("SET RTC\n");
+		CHECK_ERROR(pmic_rtc_set_time(pmic_time));
+		break;
+	case PMIC_RTC_GET_TIME:
+		if (copy_to_user((struct timeval *)arg, pmic_time,
+				 sizeof(struct timeval))) {
+			return -EFAULT;
+		}
+		pr_debug("GET RTC\n");
+		CHECK_ERROR(pmic_rtc_get_time(pmic_time));
+		break;
+	case PMIC_RTC_SET_ALARM:
+		if (copy_from_user(pmic_time, (struct timeval *)arg,
+				   sizeof(struct timeval))) {
+			return -EFAULT;
+		}
+		pr_debug("SET RTC ALARM\n");
+		CHECK_ERROR(pmic_rtc_set_time_alarm(pmic_time));
+		break;
+	case PMIC_RTC_GET_ALARM:
+		if (copy_to_user((struct timeval *)arg, pmic_time,
+				 sizeof(struct timeval))) {
+			return -EFAULT;
+		}
+		pr_debug("GET RTC ALARM\n");
+		CHECK_ERROR(pmic_rtc_get_time_alarm(pmic_time));
+		break;
+	case PMIC_RTC_WAIT_ALARM:
+		printk(KERN_INFO "WAIT ALARM...\n");
+		CHECK_ERROR(pmic_rtc_event_sub(RTC_IT_ALARM,
+					       callback_test_sub));
+		CHECK_ERROR(pmic_rtc_wait_alarm());
+		printk(KERN_INFO "ALARM DONE\n");
+		CHECK_ERROR(pmic_rtc_event_unsub(RTC_IT_ALARM,
+						 callback_test_sub));
+		break;
+	case PMIC_RTC_ALARM_REGISTER:
+		printk(KERN_INFO "PMIC RTC ALARM REGISTER\n");
+		alarm_callback.func = callback_alarm_asynchronous;
+		alarm_callback.param = NULL;
+		CHECK_ERROR(pmic_event_subscribe(EVENT_TODAI, alarm_callback));
+		break;
+	case PMIC_RTC_ALARM_UNREGISTER:
+		printk(KERN_INFO "PMIC RTC ALARM UNREGISTER\n");
+		alarm_callback.func = callback_alarm_asynchronous;
+		alarm_callback.param = NULL;
+		CHECK_ERROR(pmic_event_unsubscribe
+			    (EVENT_TODAI, alarm_callback));
+		pmic_rtc_done = false;
+		break;
+	default:
+		pr_debug("%d unsupported ioctl command\n", (int)cmd);
+		return -EINVAL;
+	}
+
+	if (arg) {
+		if (copy_to_user((struct timeval *)arg, pmic_time,
+				 sizeof(struct timeval))) {
+			return -EFAULT;
+		}
+		kfree(pmic_time);
+	}
+
+	return 0;
+}
+
+/*!
+ * This function implements the open method on a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_rtc_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/*!
+ * This function implements the release method on a PMIC RTC device.
+ *
+ * @param        inode       pointer on the node
+ * @param        file        pointer on the file
+ * @return       This function returns 0.
+ */
+static int pmic_rtc_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/*!
+ * This function is called to put the RTC in a low power state.
+ * There is no need for power handlers for the RTC device.
+ * The RTC cannot be suspended.
+ *
+ * @param   pdev  the device structure used to give information on which RTC
+ *                device (0 through 3 channels) to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+/*!
+ * This function is called to resume the RTC from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which RTC
+ *                device (0 through 3 channels) to suspend
+ *
+ * @return  The function always returns 0.
+ */
+static int pmic_rtc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+
+static const struct file_operations pmic_rtc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = pmic_rtc_ioctl,
+	.poll = pmic_rtc_poll,
+	.open = pmic_rtc_open,
+	.release = pmic_rtc_release,
+};
+
+static int pmic_rtc_remove(struct platform_device *pdev)
+{
+	device_destroy(pmic_rtc_class, MKDEV(pmic_rtc_major, 0));
+	class_destroy(pmic_rtc_class);
+	unregister_chrdev(pmic_rtc_major, "pmic_rtc");
+	return 0;
+}
+
+static int pmic_rtc_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	pmic_rtc_major = register_chrdev(0, "pmic_rtc", &pmic_rtc_fops);
+	if (pmic_rtc_major < 0) {
+		printk(KERN_ERR "Unable to get a major for pmic_rtc\n");
+		return pmic_rtc_major;
+	}
+
+	pmic_rtc_class = class_create(THIS_MODULE, "pmic_rtc");
+	if (IS_ERR(pmic_rtc_class)) {
+		printk(KERN_ERR "Error creating pmic rtc class.\n");
+		ret = PTR_ERR(pmic_rtc_class);
+		goto err_out1;
+	}
+
+	temp_class = device_create(pmic_rtc_class, NULL,
+				   MKDEV(pmic_rtc_major, 0), NULL,
+				   "pmic_rtc");
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating pmic rtc class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	printk(KERN_INFO "PMIC RTC successfully probed\n");
+	return ret;
+
+err_out2:
+	class_destroy(pmic_rtc_class);
+err_out1:
+	unregister_chrdev(pmic_rtc_major, "pmic_rtc");
+	return ret;
+}
+
+static struct platform_driver pmic_rtc_driver_ldm = {
+	.driver = {
+		   .name = "pmic_rtc",
+		   .owner = THIS_MODULE,
+		   },
+	.suspend = pmic_rtc_suspend,
+	.resume = pmic_rtc_resume,
+	.probe = pmic_rtc_probe,
+	.remove = pmic_rtc_remove,
+};
+
+static int __init pmic_rtc_init(void)
+{
+	pr_debug("PMIC RTC driver loading...\n");
+	return platform_driver_register(&pmic_rtc_driver_ldm);
+}
+static void __exit pmic_rtc_exit(void)
+{
+	platform_driver_unregister(&pmic_rtc_driver_ldm);
+	pr_debug("PMIC RTC driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_rtc_init);
+module_exit(pmic_rtc_exit);
+
+MODULE_DESCRIPTION("Pmic_rtc driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h b/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h
new file mode 100644
index 0000000..16e968d
--- /dev/null
+++ b/drivers/mxc/pmic/mc13783/pmic_rtc_defs.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MC13783_RTC_DEFS_H__
+#define __MC13783_RTC_DEFS_H__
+
+/*!
+ * @file mc13783/pmic_rtc_defs.h
+ * @brief This is the internal header of PMIC(mc13783) RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * RTC Time
+ */
+#define MC13783_RTCTIME_TIME_LSH	0
+#define MC13783_RTCTIME_TIME_WID	17
+
+/*
+ * RTC Alarm
+ */
+#define MC13783_RTCALARM_TIME_LSH	0
+#define MC13783_RTCALARM_TIME_WID	17
+
+/*
+ * RTC Day
+ */
+#define MC13783_RTCDAY_DAY_LSH		0
+#define MC13783_RTCDAY_DAY_WID		15
+
+/*
+ * RTC Day alarm
+ */
+#define MC13783_RTCALARM_DAY_LSH	0
+#define MC13783_RTCALARM_DAY_WID	15
+
+#endif				/* __MC13783_RTC_DEFS_H__ */
diff --git a/drivers/mxc/pmic/mc13892/Kconfig b/drivers/mxc/pmic/mc13892/Kconfig
new file mode 100644
index 0000000..930e06a
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/Kconfig
@@ -0,0 +1,48 @@
+#
+# PMIC Modules configuration
+#
+
+config MXC_MC13892_ADC
+	tristate "MC13892 ADC support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 ADC module driver. This module provides kernel API
+	for the ADC system of MC13892.
+	It controls also the touch screen interface.
+	If you want MC13892 ADC support, you should say Y here
+
+config MXC_MC13892_RTC
+	tristate "MC13892 Real Time Clock (RTC) support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 RTC module driver. This module provides kernel API
+	for RTC part of MC13892.
+	If you want MC13892 RTC support, you should say Y here
+config MXC_MC13892_LIGHT
+	tristate "MC13892 Light and Backlight support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 Light module driver. This module provides kernel API
+	for led and backlight control part of MC13892.
+	If you want MC13892 Light support, you should say Y here
+config MXC_MC13892_BATTERY
+	tristate "MC13892 Battery API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 battery module driver. This module provides kernel API
+	for battery control part of MC13892.
+	If you want MC13892 battery support, you should say Y here
+config MXC_MC13892_CONNECTIVITY
+	tristate "MC13892 Connectivity API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 connectivity module driver. This module provides kernel API
+	for USB/RS232 connectivity control part of MC13892.
+	If you want MC13892 connectivity support, you should say Y here
+config MXC_MC13892_POWER
+	tristate "MC13892 Power API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 power and supplies module driver. This module provides kernel API
+	for power and regulator control part of MC13892.
+	If you want MC13892 power support, you should say Y here
diff --git a/drivers/mxc/pmic/mc13892/Makefile b/drivers/mxc/pmic/mc13892/Makefile
new file mode 100644
index 0000000..0ed2b7e
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the mc13783 pmic drivers.
+#
+
+obj-$(CONFIG_MXC_MC13892_ADC) += pmic_adc.o
+#obj-$(CONFIG_MXC_MC13892_RTC) += pmic_rtc.o
+obj-$(CONFIG_MXC_MC13892_LIGHT) += pmic_light.o
+obj-$(CONFIG_MXC_MC13892_BATTERY) += pmic_battery.o
+#obj-$(CONFIG_MXC_MC13892_CONNECTIVITY) += pmic_convity.o
+#obj-$(CONFIG_MXC_MC13892_POWER) += pmic_power.o
diff --git a/drivers/mxc/pmic/mc13892/pmic_adc.c b/drivers/mxc/pmic/mc13892/pmic_adc.c
new file mode 100644
index 0000000..d4ad368
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/pmic_adc.c
@@ -0,0 +1,984 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/device.h>
+
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
+
+#include "../core/pmic.h"
+
+#define         DEF_ADC_0     0x008000
+#define         DEF_ADC_3     0x0001c0
+
+#define ADC_NB_AVAILABLE        2
+
+#define MAX_CHANNEL             7
+
+#define MC13892_ADC0_TS_M_LSH	14
+#define MC13892_ADC0_TS_M_WID	3
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch-screen
+ */
+#define DELTA_Y_MAX             50
+#define DELTA_X_MAX             50
+
+/*
+ * ADC 0
+ */
+#define ADC_WAIT_TSI_0		0x001400
+
+#define ADC_INC                 0x030000
+#define ADC_BIS                 0x800000
+#define ADC_CHRGRAW_D5          0x008000
+
+/*
+ * ADC 1
+ */
+
+#define ADC_EN                  0x000001
+#define ADC_SGL_CH              0x000002
+#define ADC_ADSEL               0x000008
+#define ADC_CH_0_POS            5
+#define ADC_CH_0_MASK           0x0000E0
+#define ADC_CH_1_POS            8
+#define ADC_CH_1_MASK           0x000700
+#define ADC_DELAY_POS           11
+#define ADC_DELAY_MASK          0x07F800
+#define ADC_ATO                 0x080000
+#define ASC_ADC                 0x100000
+#define ADC_WAIT_TSI_1		0x200001
+#define ADC_NO_ADTRIG           0x200000
+
+/*
+ * ADC 2 - 4
+ */
+#define ADD1_RESULT_MASK        0x00000FFC
+#define ADD2_RESULT_MASK        0x00FFC000
+#define ADC_TS_MASK             0x00FFCFFC
+
+#define ADC_WCOMP               0x040000
+#define ADC_WCOMP_H_POS         0
+#define ADC_WCOMP_L_POS         9
+#define ADC_WCOMP_H_MASK        0x00003F
+#define ADC_WCOMP_L_MASK        0x007E00
+
+#define ADC_MODE_MASK           0x00003F
+
+#define ADC_INT_BISDONEI        0x02
+#define ADC_TSMODE_MASK 0x007000
+
+typedef enum adc_state {
+	ADC_FREE,
+	ADC_USED,
+	ADC_MONITORING,
+} t_adc_state;
+
+typedef enum reading_mode {
+	/*!
+	 * Enables lithium cell reading
+	 */
+	M_LITHIUM_CELL = 0x000001,
+	/*!
+	 * Enables charge current reading
+	 */
+	M_CHARGE_CURRENT = 0x000002,
+	/*!
+	 * Enables battery current reading
+	 */
+	M_BATTERY_CURRENT = 0x000004,
+} t_reading_mode;
+
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Sets the single channel mode
+	 */
+	bool single_channel;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel_0;
+	/*!
+	 * Channel selection 2
+	 */
+	t_channel channel_1;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	t_reading_mode read_mode;
+	/*!
+	 * Sets the Touch screen mode
+	 */
+	bool read_ts;
+	/*!
+	 * Wait TSI event before touch screen reading
+	 */
+	bool wait_tsi;
+	/*!
+	 * Sets CHRGRAW scaling to divide by 5
+	 * Only supported on 2.0 and higher
+	 */
+	bool chrgraw_devide_5;
+	/*!
+	 * Return ADC values
+	 */
+	unsigned int value[8];
+	/*!
+	 * Return touch screen values
+	 */
+	t_touch_screen ts_value;
+} t_adc_param;
+
+static int pmic_adc_filter(t_touch_screen *ts_curr);
+int mc13892_adc_request(bool read_ts);
+int mc13892_adc_release(int adc_index);
+t_reading_mode mc13892_set_read_mode(t_channel channel);
+PMIC_STATUS mc13892_adc_read_ts(t_touch_screen *touch_sample, int wait_tsi);
+
+/* internal function */
+static void callback_tsi(void *);
+static void callback_adcdone(void *);
+static void callback_adcbisdone(void *);
+
+static int swait;
+
+static int suspend_flag;
+
+static wait_queue_head_t suspendq;
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_adc_init);
+EXPORT_SYMBOL(pmic_adc_deinit);
+EXPORT_SYMBOL(pmic_adc_convert);
+EXPORT_SYMBOL(pmic_adc_convert_8x);
+EXPORT_SYMBOL(pmic_adc_set_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_sample);
+
+static DECLARE_COMPLETION(adcdone_it);
+static DECLARE_COMPLETION(adcbisdone_it);
+static DECLARE_COMPLETION(adc_tsi);
+static pmic_event_callback_t tsi_event;
+static pmic_event_callback_t event_adc;
+static pmic_event_callback_t event_adc_bis;
+static bool data_ready_adc_1;
+static bool data_ready_adc_2;
+static bool adc_ts;
+static bool wait_ts;
+static bool monitor_en;
+static bool monitor_adc;
+static DECLARE_MUTEX(convert_mutex);
+
+static DECLARE_WAIT_QUEUE_HEAD(queue_adc_busy);
+static t_adc_state adc_dev[2];
+
+static unsigned channel_num[] = {
+	0,
+	1,
+	3,
+	4,
+	2,
+	0,
+	1,
+	3,
+	4,
+	-1,
+	5,
+	6,
+	7,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1
+};
+
+static bool pmic_adc_ready;
+
+int is_pmic_adc_ready()
+{
+	return pmic_adc_ready;
+}
+EXPORT_SYMBOL(is_pmic_adc_ready);
+
+
+static int pmic_adc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC4, 0, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+static int pmic_adc_resume(struct platform_device *pdev)
+{
+	/* nothing for mc13892 adc */
+	unsigned int adc_0_reg, adc_1_reg, reg_mask;
+	suspend_flag = 0;
+
+	/* let interrupt of TSI again */
+	adc_0_reg = ADC_WAIT_TSI_0;
+	reg_mask = ADC_WAIT_TSI_0;
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg, reg_mask));
+	adc_1_reg = ADC_WAIT_TSI_1 | (ADC_BIS * adc_ts);
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, PMIC_ALL_BITS));
+
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+static void callback_tsi(void *unused)
+{
+	pr_debug("*** TSI IT mc13892 PMIC_ADC_GET_TOUCH_SAMPLE ***\n");
+	if (wait_ts) {
+		complete(&adc_tsi);
+		pmic_event_mask(EVENT_TSI);
+	}
+}
+
+static void callback_adcdone(void *unused)
+{
+	if (data_ready_adc_1)
+		complete(&adcdone_it);
+}
+
+static void callback_adcbisdone(void *unused)
+{
+	pr_debug("* adcdone bis it callback *\n");
+	if (data_ready_adc_2)
+		complete(&adcbisdone_it);
+}
+
+static int pmic_adc_filter(t_touch_screen *ts_curr)
+{
+	unsigned int ydiff, xdiff;
+	unsigned int sample_sumx, sample_sumy;
+
+	if (ts_curr->contact_resistance == 0) {
+		ts_curr->x_position = 0;
+		ts_curr->y_position = 0;
+		return 0;
+	}
+
+	ydiff = abs(ts_curr->y_position1 - ts_curr->y_position2);
+	if (ydiff > DELTA_Y_MAX) {
+		pr_debug("pmic_adc_filter: Ret pos y\n");
+		return -1;
+	}
+
+	xdiff = abs(ts_curr->x_position1 - ts_curr->x_position2);
+	if (xdiff > DELTA_X_MAX) {
+		pr_debug("mc13892_adc_filter: Ret pos x\n");
+		return -1;
+	}
+
+	sample_sumx = ts_curr->x_position1 + ts_curr->x_position2;
+	sample_sumy = ts_curr->y_position1 + ts_curr->y_position2;
+
+	ts_curr->y_position = sample_sumy / 2;
+	ts_curr->x_position = sample_sumx / 2;
+
+	return 0;
+}
+
+int pmic_adc_init(void)
+{
+	unsigned int reg_value = 0, i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	for (i = 0; i < ADC_NB_AVAILABLE; i++)
+		adc_dev[i] = ADC_FREE;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC4, 0, PMIC_ALL_BITS));
+	reg_value = 0x001000;
+
+	data_ready_adc_1 = false;
+	data_ready_adc_2 = false;
+	adc_ts = false;
+	wait_ts = false;
+	monitor_en = false;
+	monitor_adc = false;
+
+	/* sub to ADCDone IT */
+	event_adc.param = NULL;
+	event_adc.func = callback_adcdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCDONEI, event_adc));
+
+	/* sub to ADCDoneBis IT */
+	event_adc_bis.param = NULL;
+	event_adc_bis.func = callback_adcbisdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCBISDONEI, event_adc_bis));
+
+	/* sub to Touch Screen IT */
+	tsi_event.param = NULL;
+	tsi_event.func = callback_tsi;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TSI, tsi_event));
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_deinit(void)
+{
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCDONEI, event_adc));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCBISDONEI, event_adc_bis));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TSI, tsi_event));
+
+	return PMIC_SUCCESS;
+}
+
+int mc13892_adc_init_param(t_adc_param *adc_param)
+{
+	int i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	adc_param->delay = 0;
+	adc_param->conv_delay = false;
+	adc_param->single_channel = false;
+	adc_param->channel_0 = BATTERY_VOLTAGE;
+	adc_param->channel_1 = BATTERY_VOLTAGE;
+	adc_param->read_mode = 0;
+	adc_param->wait_tsi = 0;
+	adc_param->chrgraw_devide_5 = true;
+	adc_param->read_ts = false;
+	adc_param->ts_value.x_position = 0;
+	adc_param->ts_value.y_position = 0;
+	adc_param->ts_value.contact_resistance = 0;
+	for (i = 0; i <= MAX_CHANNEL; i++)
+		adc_param->value[i] = 0;
+
+	return 0;
+}
+
+PMIC_STATUS mc13892_adc_convert(t_adc_param *adc_param)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, reg_1 = 0, result_reg =
+	    0, i = 0;
+	unsigned int result = 0, temp = 0;
+	pmic_version_t mc13892_ver;
+	pr_debug("mc13892 ADC - mc13892_adc_convert ....\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (adc_param->wait_tsi) {
+		/* configure adc to wait tsi interrupt */
+		INIT_COMPLETION(adc_tsi);
+
+		/*for ts don't use bis */
+		/*put ts in interrupt mode */
+		/* still kep reference? */
+		adc_0_reg = 0x001400 | (ADC_BIS * 0);
+		pmic_event_unmask(EVENT_TSI);
+		CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg, PMIC_ALL_BITS));
+		/*for ts don't use bis */
+		adc_1_reg = 0x200001 | (ADC_BIS * 0);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, PMIC_ALL_BITS));
+		pr_debug("wait tsi ....\n");
+		wait_ts = true;
+		wait_for_completion_interruptible(&adc_tsi);
+		wait_ts = false;
+	}
+	down(&convert_mutex);
+	use_bis = mc13892_adc_request(adc_param->read_ts);
+	if (use_bis < 0) {
+		pr_debug("process has received a signal and got interrupted\n");
+		return -EINTR;
+	}
+
+	/* CONFIGURE ADC REG 0 */
+	adc_0_reg = 0;
+	adc_1_reg = 0;
+	if (adc_param->read_ts == false) {
+		adc_0_reg = adc_param->read_mode & 0x00003F;
+		/* add auto inc */
+		adc_0_reg |= ADC_INC;
+		if (use_bis) {
+			/* add adc bis */
+			adc_0_reg |= ADC_BIS;
+		}
+		mc13892_ver = pmic_get_version();
+		if (mc13892_ver.revision >= 20)
+			if (adc_param->chrgraw_devide_5)
+				adc_0_reg |= ADC_CHRGRAW_D5;
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		if (adc_param->conv_delay)
+			adc_1_reg |= ADC_ATO;
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		adc_1_reg |= (adc_param->channel_0 << ADC_CH_0_POS) &
+		    ADC_CH_0_MASK;
+		adc_1_reg |= (adc_param->channel_1 << ADC_CH_1_POS) &
+		    ADC_CH_1_MASK;
+	} else {
+		adc_0_reg = 0x002400 | (ADC_BIS * use_bis) | ADC_INC;
+	}
+	pr_debug("Write Reg %i = %x\n", REG_ADC0, adc_0_reg);
+	/*Change has been made here */
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg,
+				   ADC_INC | ADC_BIS | ADC_CHRGRAW_D5 |
+				   0xfff00ff));
+	/* CONFIGURE ADC REG 1 */
+	if (adc_param->read_ts == false) {
+		adc_1_reg |= ADC_NO_ADTRIG;
+		adc_1_reg |= ADC_EN;
+		adc_1_reg |= (adc_param->delay << ADC_DELAY_POS) &
+		    ADC_DELAY_MASK;
+		if (use_bis)
+			adc_1_reg |= ADC_BIS;
+	} else {
+		/* configure and start convert to read x and y position */
+		/* configure to read 2 value in channel selection 1 & 2 */
+		adc_1_reg = 0x100409 | (ADC_BIS * use_bis) | ADC_NO_ADTRIG;
+		/* set ATOx = 5, it could be better for ts ADC */
+		adc_1_reg |= 0x002800;
+	}
+	reg_1 = adc_1_reg;
+	if (use_bis == 0) {
+		data_ready_adc_1 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_1 = true;
+		pr_debug("Write Reg %i = %x\n", REG_ADC1, adc_1_reg);
+		INIT_COMPLETION(adcdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg,
+					   ADC_SGL_CH | ADC_ATO | ADC_ADSEL
+					   | ADC_CH_0_MASK | ADC_CH_1_MASK |
+					   ADC_NO_ADTRIG | ADC_EN |
+					   ADC_DELAY_MASK | ASC_ADC | ADC_BIS));
+		pr_debug("wait adc done\n");
+		wait_for_completion_interruptible(&adcdone_it);
+		data_ready_adc_1 = false;
+	} else {
+		data_ready_adc_2 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_2 = true;
+		INIT_COMPLETION(adcbisdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, 0xFFFFFF));
+		temp = 0x800000;
+		CHECK_ERROR(pmic_write_reg(REG_ADC3, temp, 0xFFFFFF));
+		pr_debug("wait adc done bis\n");
+		wait_for_completion_interruptible(&adcbisdone_it);
+		data_ready_adc_2 = false;
+	}
+	/* read result and store in adc_param */
+	result = 0;
+	if (use_bis == 0)
+		result_reg = REG_ADC2;
+	else
+		result_reg = REG_ADC4;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 4 << ADC_CH_1_POS,
+				   ADC_CH_0_MASK | ADC_CH_1_MASK));
+
+	for (i = 0; i <= 3; i++) {
+		CHECK_ERROR(pmic_read_reg(result_reg, &result, PMIC_ALL_BITS));
+		adc_param->value[i] = ((result & ADD1_RESULT_MASK) >> 2);
+		adc_param->value[i + 4] = ((result & ADD2_RESULT_MASK) >> 14);
+		pr_debug("value[%d] = %d, value[%d] = %d\n",
+			 i, adc_param->value[i],
+			 i + 4, adc_param->value[i + 4]);
+	}
+	if (adc_param->read_ts) {
+		adc_param->ts_value.x_position = adc_param->value[0];
+		adc_param->ts_value.x_position1 = adc_param->value[0];
+		adc_param->ts_value.x_position2 = adc_param->value[1];
+		adc_param->ts_value.y_position = adc_param->value[3];
+		adc_param->ts_value.y_position1 = adc_param->value[3];
+		adc_param->ts_value.y_position2 = adc_param->value[4];
+		adc_param->ts_value.contact_resistance = adc_param->value[6];
+		CHECK_ERROR(pmic_write_reg(REG_ADC0, 0x0,
+				   ADC_TSMODE_MASK));
+	}
+
+	/*if (adc_param->read_ts) {
+	   adc_param->ts_value.x_position = adc_param->value[2];
+	   adc_param->ts_value.y_position = adc_param->value[5];
+	   adc_param->ts_value.contact_resistance = adc_param->value[6];
+	   } */
+	mc13892_adc_release(use_bis);
+	up(&convert_mutex);
+
+	return PMIC_SUCCESS;
+}
+
+t_reading_mode mc13892_set_read_mode(t_channel channel)
+{
+	t_reading_mode read_mode = 0;
+
+	switch (channel) {
+	case CHARGE_CURRENT:
+		read_mode = M_CHARGE_CURRENT;
+		break;
+	case BATTERY_CURRENT:
+		read_mode = M_BATTERY_CURRENT;
+		break;
+	default:
+		read_mode = 0;
+	}
+
+	return read_mode;
+}
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	PMIC_STATUS ret;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = channel_num[channel];
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13892_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13892_set_read_mode(channel);
+
+	/* Find the group */
+	if (channel <= 7)
+		adc_param.channel_0 = channel;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+	ret = mc13892_adc_convert(&adc_param);
+	*result = adc_param.value[0];
+	return ret;
+}
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = channel_num[channel];
+
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13892_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_8x\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13892_set_read_mode(channel);
+
+	if (channel <= 7) {
+		adc_param.channel_0 = channel;
+		adc_param.channel_1 = channel;
+	} else
+		return PMIC_PARAMETER_ERROR;
+
+	ret = mc13892_adc_convert(&adc_param);
+	for (i = 0; i <= 7; i++)
+		result[i] = adc_param.value[i];
+
+	return ret;
+}
+
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode)
+{
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC0,
+				   BITFVAL(MC13892_ADC0_TS_M, touch_mode),
+				   BITFMASK(MC13892_ADC0_TS_M)));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode)
+{
+	unsigned int value;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(REG_ADC0, &value, PMIC_ALL_BITS));
+
+	*touch_mode = BITFEXT(value, MC13892_ADC0_TS_M);
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *touch_sample, int wait)
+{
+	if (mc13892_adc_read_ts(touch_sample, wait) != 0)
+		return PMIC_ERROR;
+	if (0 == pmic_adc_filter(touch_sample))
+		return PMIC_SUCCESS;
+	else
+		return PMIC_ERROR;
+}
+
+PMIC_STATUS mc13892_adc_read_ts(t_touch_screen *ts_value, int wait_tsi)
+{
+	t_adc_param param;
+	pr_debug("mc13892_adc : mc13892_adc_read_ts\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (wait_ts) {
+		pr_debug("mc13892_adc : error TS busy\n");
+		return PMIC_ERROR;
+	}
+	mc13892_adc_init_param(&param);
+	param.wait_tsi = wait_tsi;
+	param.read_ts = true;
+	if (mc13892_adc_convert(&param) != 0)
+		return PMIC_ERROR;
+	/* check if x-y is ok */
+	if (param.ts_value.contact_resistance < 1000) {
+		ts_value->x_position = param.ts_value.x_position;
+		ts_value->x_position1 = param.ts_value.x_position1;
+		ts_value->x_position2 = param.ts_value.x_position2;
+
+		ts_value->y_position = param.ts_value.y_position;
+		ts_value->y_position1 = param.ts_value.y_position1;
+		ts_value->y_position2 = param.ts_value.y_position2;
+
+		ts_value->contact_resistance =
+		    param.ts_value.contact_resistance + 1;
+
+	} else {
+		ts_value->x_position = 0;
+		ts_value->y_position = 0;
+		ts_value->contact_resistance = 0;
+
+	}
+	return PMIC_SUCCESS;
+}
+
+int mc13892_adc_request(bool read_ts)
+{
+	int adc_index = -1;
+	if (read_ts != 0) {
+		/*for ts we use bis=0 */
+		if (adc_dev[0] == ADC_USED)
+			return -1;
+		/*no wait here */
+		adc_dev[0] = ADC_USED;
+		adc_index = 0;
+	} else {
+		/*for other adc use bis = 1 */
+		if (adc_dev[1] == ADC_USED) {
+			return -1;
+			/*no wait here */
+		}
+		adc_dev[1] = ADC_USED;
+		adc_index = 1;
+	}
+	pr_debug("mc13892_adc : request ADC %d\n", adc_index);
+	return adc_index;
+}
+
+int mc13892_adc_release(int adc_index)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+
+	pr_debug("mc13892_adc : release ADC %d\n", adc_index);
+	if ((adc_dev[adc_index] == ADC_MONITORING) ||
+	    (adc_dev[adc_index] == ADC_USED)) {
+		adc_dev[adc_index] = ADC_FREE;
+		wake_up(&queue_adc_busy);
+		return 0;
+	}
+	return -1;
+}
+
+#ifdef DEBUG
+static t_adc_param adc_param_db;
+
+static ssize_t adc_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	int *value = adc_param_db.value;
+
+	pr_debug("adc_info\n");
+
+	pr_debug("ch0\t\t%d\n", adc_param_db.channel_0);
+	pr_debug("ch1\t\t%d\n", adc_param_db.channel_1);
+	pr_debug("d5\t\t%d\n", adc_param_db.chrgraw_devide_5);
+	pr_debug("conv delay\t%d\n", adc_param_db.conv_delay);
+	pr_debug("delay\t\t%d\n", adc_param_db.delay);
+	pr_debug("read mode\t%d\n", adc_param_db.read_mode);
+	pr_debug("read ts\t\t%d\n", adc_param_db.read_ts);
+	pr_debug("single ch\t%d\n", adc_param_db.single_channel);
+	pr_debug("wait ts int\t%d\n", adc_param_db.wait_tsi);
+	pr_debug("value0-3:\t%d\t%d\t%d\t%d\n", value[0], value[1],
+		 value[2], value[3]);
+	pr_debug("value4-7:\t%d\t%d\t%d\t%d\n", value[4], value[5],
+		 value[6], value[7]);
+
+	return 0;
+}
+
+enum {
+	ADC_SET_CH0 = 0,
+	ADC_SET_CH1,
+	ADC_SET_DV5,
+	ADC_SET_CON_DELAY,
+	ADC_SET_DELAY,
+	ADC_SET_RM,
+	ADC_SET_RT,
+	ADC_SET_S_CH,
+	ADC_SET_WAIT_TS,
+	ADC_INIT_P,
+	ADC_START,
+	ADC_TS,
+	ADC_TS_READ,
+	ADC_TS_CAL,
+	ADC_CMD_MAX
+};
+
+static const char *const adc_cmd[ADC_CMD_MAX] = {
+	[ADC_SET_CH0] = "ch0",
+	[ADC_SET_CH1] = "ch1",
+	[ADC_SET_DV5] = "dv5",
+	[ADC_SET_CON_DELAY] = "cd",
+	[ADC_SET_DELAY] = "dl",
+	[ADC_SET_RM] = "rm",
+	[ADC_SET_RT] = "rt",
+	[ADC_SET_S_CH] = "sch",
+	[ADC_SET_WAIT_TS] = "wt",
+	[ADC_INIT_P] = "init",
+	[ADC_START] = "start",
+	[ADC_TS] = "touch",
+	[ADC_TS_READ] = "touchr",
+	[ADC_TS_CAL] = "cal"
+};
+
+static int cmd(unsigned int index, int value)
+{
+	t_touch_screen ts;
+
+	switch (index) {
+	case ADC_SET_CH0:
+		adc_param_db.channel_0 = value;
+		break;
+	case ADC_SET_CH1:
+		adc_param_db.channel_1 = value;
+		break;
+	case ADC_SET_DV5:
+		adc_param_db.chrgraw_devide_5 = value;
+		break;
+	case ADC_SET_CON_DELAY:
+		adc_param_db.conv_delay = value;
+		break;
+	case ADC_SET_RM:
+		adc_param_db.read_mode = value;
+		break;
+	case ADC_SET_RT:
+		adc_param_db.read_ts = value;
+		break;
+	case ADC_SET_S_CH:
+		adc_param_db.single_channel = value;
+		break;
+	case ADC_SET_WAIT_TS:
+		adc_param_db.wait_tsi = value;
+		break;
+	case ADC_INIT_P:
+		mc13892_adc_init_param(&adc_param_db);
+		break;
+	case ADC_START:
+		mc13892_adc_convert(&adc_param_db);
+		break;
+	case ADC_TS:
+		pmic_adc_get_touch_sample(&ts, 1);
+		pr_debug("x = %d\n", ts.x_position);
+		pr_debug("y = %d\n", ts.y_position);
+		pr_debug("p = %d\n", ts.contact_resistance);
+		break;
+	case ADC_TS_READ:
+		pmic_adc_get_touch_sample(&ts, 0);
+		pr_debug("x = %d\n", ts.x_position);
+		pr_debug("y = %d\n", ts.y_position);
+		pr_debug("p = %d\n", ts.contact_resistance);
+		break;
+	case ADC_TS_CAL:
+		break;
+	default:
+		pr_debug("error command\n");
+		break;
+	}
+	return 0;
+}
+
+static ssize_t adc_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	int state = 0;
+	const char *const *s;
+	char *p, *q;
+	int error;
+	int len, value = 0;
+
+	pr_debug("adc_ctl\n");
+
+	q = NULL;
+	q = memchr(buf, ' ', count);
+
+	if (q != NULL) {
+		len = q - buf;
+		q += 1;
+		value = simple_strtoul(q, NULL, 10);
+	} else {
+		p = memchr(buf, '\n', count);
+		len = p ? p - buf : count;
+	}
+
+	for (s = &adc_cmd[state]; state < ADC_CMD_MAX; s++, state++) {
+		if (*s && !strncmp(buf, *s, len))
+			break;
+	}
+	if (state < ADC_CMD_MAX && *s)
+		error = cmd(state, value);
+	else
+		error = -EINVAL;
+
+	return count;
+}
+
+#else
+static ssize_t adc_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return 0;
+}
+
+static ssize_t adc_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	return count;
+}
+
+#endif
+
+static DEVICE_ATTR(adc, 0644, adc_info, adc_ctl);
+
+static int pmic_adc_module_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	pr_debug("PMIC ADC start probe\n");
+	ret = device_create_file(&(pdev->dev), &dev_attr_adc);
+	if (ret) {
+		pr_debug("Can't create device file!\n");
+		return -ENODEV;
+	}
+
+	init_waitqueue_head(&suspendq);
+
+	ret = pmic_adc_init();
+	if (ret != PMIC_SUCCESS) {
+		pr_debug("Error in pmic_adc_init.\n");
+		goto rm_dev_file;
+	}
+
+	pmic_adc_ready = 1;
+	pr_debug("PMIC ADC successfully probed\n");
+	return 0;
+
+rm_dev_file:
+	device_remove_file(&(pdev->dev), &dev_attr_adc);
+	return ret;
+}
+
+static int pmic_adc_module_remove(struct platform_device *pdev)
+{
+	pmic_adc_deinit();
+	pmic_adc_ready = 0;
+	pr_debug("PMIC ADC successfully removed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_adc_driver_ldm = {
+	.driver = {
+		   .name = "pmic_adc",
+		   },
+	.suspend = pmic_adc_suspend,
+	.resume = pmic_adc_resume,
+	.probe = pmic_adc_module_probe,
+	.remove = pmic_adc_module_remove,
+};
+
+static int __init pmic_adc_module_init(void)
+{
+	pr_debug("PMIC ADC driver loading...\n");
+	return platform_driver_register(&pmic_adc_driver_ldm);
+}
+
+static void __exit pmic_adc_module_exit(void)
+{
+	platform_driver_unregister(&pmic_adc_driver_ldm);
+	pr_debug("PMIC ADC driver successfully unloaded\n");
+}
+
+module_init(pmic_adc_module_init);
+module_exit(pmic_adc_module_exit);
+
+MODULE_DESCRIPTION("PMIC ADC device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13892/pmic_battery.c b/drivers/mxc/pmic/mc13892/pmic_battery.c
new file mode 100644
index 0000000..a9837be
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/pmic_battery.c
@@ -0,0 +1,635 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * Includes
+ */
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <asm/mach-types.h>
+#include <linux/pmic_battery.h>
+#include <linux/pmic_adc.h>
+#include <linux/pmic_status.h>
+
+#define BIT_CHG_VOL_LSH		0
+#define BIT_CHG_VOL_WID		3
+
+#define BIT_CHG_CURR_LSH		3
+#define BIT_CHG_CURR_WID		4
+
+#define BIT_CHG_PLIM_LSH		15
+#define BIT_CHG_PLIM_WID		2
+
+#define BIT_CHG_DETS_LSH 6
+#define BIT_CHG_DETS_WID 1
+#define BIT_CHG_CURRS_LSH 11
+#define BIT_CHG_CURRS_WID 1
+
+#define TRICKLE_CHG_EN_LSH	7
+#define	LOW_POWER_BOOT_ACK_LSH	8
+#define BAT_TH_CHECK_DIS_LSH	9
+#define	BATTFET_CTL_EN_LSH	10
+#define BATTFET_CTL_LSH		11
+#define	REV_MOD_EN_LSH		13
+#define PLIM_DIS_LSH		17
+#define	CHG_LED_EN_LSH		18
+#define RESTART_CHG_STAT_LSH	20
+#define	AUTO_CHG_DIS_LSH	21
+#define CYCLING_DIS_LSH		22
+#define	VI_PROGRAM_EN_LSH	23
+
+#define TRICKLE_CHG_EN_WID	1
+#define	LOW_POWER_BOOT_ACK_WID	1
+#define BAT_TH_CHECK_DIS_WID	1
+#define	BATTFET_CTL_EN_WID	1
+#define BATTFET_CTL_WID		1
+#define	REV_MOD_EN_WID		1
+#define PLIM_DIS_WID		1
+#define	CHG_LED_EN_WID		1
+#define RESTART_CHG_STAT_WID	1
+#define	AUTO_CHG_DIS_WID	1
+#define CYCLING_DIS_WID		1
+#define	VI_PROGRAM_EN_WID	1
+
+#define ACC_STARTCC_LSH		0
+#define ACC_STARTCC_WID		1
+#define ACC_RSTCC_LSH		1
+#define ACC_RSTCC_WID		1
+#define ACC_CCFAULT_LSH		7
+#define ACC_CCFAULT_WID		7
+#define ACC_CCOUT_LSH		8
+#define ACC_CCOUT_WID		16
+#define ACC1_ONEC_LSH		0
+#define ACC1_ONEC_WID		15
+
+#define ACC_CALIBRATION 0x17
+#define ACC_START_COUNTER 0x07
+#define ACC_STOP_COUNTER 0x2
+#define ACC_CONTROL_BIT_MASK 0x1f
+#define ACC_ONEC_VALUE 2621
+#define ACC_COULOMB_PER_LSB 1
+#define ACC_CALIBRATION_DURATION_MSECS 20
+
+#define BAT_VOLTAGE_UNIT_UV 4692
+#define BAT_CURRENT_UNIT_UA 5870
+#define CHG_VOLTAGE_UINT_UV 23474
+#define CHG_MIN_CURRENT_UA 3500
+
+#define COULOMB_TO_UAH(c) (10000 * c / 36)
+
+enum chg_setting {
+       TRICKLE_CHG_EN,
+       LOW_POWER_BOOT_ACK,
+       BAT_TH_CHECK_DIS,
+       BATTFET_CTL_EN,
+       BATTFET_CTL,
+       REV_MOD_EN,
+       PLIM_DIS,
+       CHG_LED_EN,
+       RESTART_CHG_STAT,
+       AUTO_CHG_DIS,
+       CYCLING_DIS,
+       VI_PROGRAM_EN
+};
+
+static int pmic_set_chg_current(unsigned short curr)
+{
+	unsigned int mask;
+	unsigned int value;
+
+	value = BITFVAL(BIT_CHG_CURR, curr);
+	mask = BITFMASK(BIT_CHG_CURR);
+	CHECK_ERROR(pmic_write_reg(REG_CHARGE, value, mask));
+
+	return 0;
+}
+
+static int pmic_set_chg_misc(enum chg_setting type, unsigned short flag)
+{
+
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+
+	switch (type) {
+	case TRICKLE_CHG_EN:
+		reg_value = BITFVAL(TRICKLE_CHG_EN, flag);
+		mask = BITFMASK(TRICKLE_CHG_EN);
+		break;
+	case LOW_POWER_BOOT_ACK:
+		reg_value = BITFVAL(LOW_POWER_BOOT_ACK, flag);
+		mask = BITFMASK(LOW_POWER_BOOT_ACK);
+		break;
+	case BAT_TH_CHECK_DIS:
+		reg_value = BITFVAL(BAT_TH_CHECK_DIS, flag);
+		mask = BITFMASK(BAT_TH_CHECK_DIS);
+		break;
+	case BATTFET_CTL_EN:
+		reg_value = BITFVAL(BATTFET_CTL_EN, flag);
+		mask = BITFMASK(BATTFET_CTL_EN);
+		break;
+	case BATTFET_CTL:
+		reg_value = BITFVAL(BATTFET_CTL, flag);
+		mask = BITFMASK(BATTFET_CTL);
+		break;
+	case REV_MOD_EN:
+		reg_value = BITFVAL(REV_MOD_EN, flag);
+		mask = BITFMASK(REV_MOD_EN);
+		break;
+	case PLIM_DIS:
+		reg_value = BITFVAL(PLIM_DIS, flag);
+		mask = BITFMASK(PLIM_DIS);
+		break;
+	case CHG_LED_EN:
+		reg_value = BITFVAL(CHG_LED_EN, flag);
+		mask = BITFMASK(CHG_LED_EN);
+		break;
+	case RESTART_CHG_STAT:
+		reg_value = BITFVAL(RESTART_CHG_STAT, flag);
+		mask = BITFMASK(RESTART_CHG_STAT);
+		break;
+	case AUTO_CHG_DIS:
+		reg_value = BITFVAL(AUTO_CHG_DIS, flag);
+		mask = BITFMASK(AUTO_CHG_DIS);
+		break;
+	case CYCLING_DIS:
+		reg_value = BITFVAL(CYCLING_DIS, flag);
+		mask = BITFMASK(CYCLING_DIS);
+		break;
+	case VI_PROGRAM_EN:
+		reg_value = BITFVAL(VI_PROGRAM_EN, flag);
+		mask = BITFMASK(VI_PROGRAM_EN);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_write_reg(REG_CHARGE, reg_value, mask));
+
+	return 0;
+}
+
+static int pmic_get_batt_voltage(unsigned short *voltage)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	channel = BATTERY_VOLTAGE;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*voltage = result[0];
+
+	return 0;
+}
+
+static int pmic_get_batt_current(unsigned short *curr)
+{
+	t_channel channel;
+	unsigned short result[8];
+
+	channel = BATTERY_CURRENT;
+	CHECK_ERROR(pmic_adc_convert(channel, result));
+	*curr = result[0];
+
+	return 0;
+}
+
+static int coulomb_counter_calibration;
+static unsigned int coulomb_counter_start_time_msecs;
+
+static int pmic_start_coulomb_counter(void)
+{
+	/* set scaler */
+	CHECK_ERROR(pmic_write_reg(REG_ACC1,
+		ACC_COULOMB_PER_LSB * ACC_ONEC_VALUE, BITFMASK(ACC1_ONEC)));
+
+	CHECK_ERROR(pmic_write_reg(
+		REG_ACC0, ACC_START_COUNTER, ACC_CONTROL_BIT_MASK));
+	coulomb_counter_start_time_msecs = jiffies_to_msecs(jiffies);
+	pr_debug("coulomb counter start time %u\n",
+		coulomb_counter_start_time_msecs);
+	return 0;
+}
+
+static int pmic_stop_coulomb_counter(void)
+{
+	CHECK_ERROR(pmic_write_reg(
+		REG_ACC0, ACC_STOP_COUNTER, ACC_CONTROL_BIT_MASK));
+	return 0;
+}
+
+static int pmic_calibrate_coulomb_counter(void)
+{
+	int ret;
+	unsigned int value;
+
+	/* set scaler */
+	CHECK_ERROR(pmic_write_reg(REG_ACC1,
+		0x1, BITFMASK(ACC1_ONEC)));
+
+	CHECK_ERROR(pmic_write_reg(
+		REG_ACC0, ACC_CALIBRATION, ACC_CONTROL_BIT_MASK));
+	msleep(ACC_CALIBRATION_DURATION_MSECS);
+
+	ret = pmic_read_reg(REG_ACC0, &value, BITFMASK(ACC_CCOUT));
+	if (ret != 0)
+		return -1;
+	value = BITFEXT(value, ACC_CCOUT);
+	pr_debug("calibrate value = %x\n", value);
+	coulomb_counter_calibration = (int)((s16)((u16) value));
+	pr_debug("coulomb_counter_calibration = %d\n",
+		coulomb_counter_calibration);
+
+	return 0;
+
+}
+
+static int pmic_get_charger_coulomb(int *coulomb)
+{
+	int ret;
+	unsigned int value;
+	int calibration;
+	unsigned int time_diff_msec;
+
+	ret = pmic_read_reg(REG_ACC0, &value, BITFMASK(ACC_CCOUT));
+	if (ret != 0)
+		return -1;
+	value = BITFEXT(value, ACC_CCOUT);
+	pr_debug("counter value = %x\n", value);
+	*coulomb = ((s16)((u16)value)) * ACC_COULOMB_PER_LSB;
+
+	if (abs(*coulomb) >= ACC_COULOMB_PER_LSB) {
+			/* calibrate */
+		time_diff_msec = jiffies_to_msecs(jiffies);
+		time_diff_msec =
+			(time_diff_msec > coulomb_counter_start_time_msecs) ?
+			(time_diff_msec - coulomb_counter_start_time_msecs) :
+			(0xffffffff - coulomb_counter_start_time_msecs
+			+ time_diff_msec);
+		calibration = coulomb_counter_calibration * (int)time_diff_msec
+			/ (ACC_ONEC_VALUE * ACC_CALIBRATION_DURATION_MSECS);
+		*coulomb -= calibration;
+	}
+
+	return 0;
+}
+
+static int pmic_restart_charging(void)
+{
+	pmic_set_chg_misc(BAT_TH_CHECK_DIS, 1);
+	pmic_set_chg_misc(AUTO_CHG_DIS, 0);
+	pmic_set_chg_misc(VI_PROGRAM_EN, 1);
+	pmic_set_chg_current(0x8);
+	pmic_set_chg_misc(RESTART_CHG_STAT, 1);
+	return 0;
+}
+
+struct mc13892_dev_info {
+	struct device *dev;
+
+	unsigned short voltage_raw;
+	int voltage_uV;
+	unsigned short current_raw;
+	int current_uA;
+	int battery_status;
+	int full_counter;
+	int charger_online;
+	int charger_voltage_uV;
+	int accum_current_uAh;
+
+	struct power_supply bat;
+	struct power_supply charger;
+
+	struct workqueue_struct *monitor_wqueue;
+	struct delayed_work monitor_work;
+};
+
+#define mc13892_SENSER	25
+#define to_mc13892_dev_info(x) container_of((x), struct mc13892_dev_info, \
+					      bat);
+
+static enum power_supply_property mc13892_battery_props[] = {
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_STATUS,
+};
+
+static enum power_supply_property mc13892_charger_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static int mc13892_charger_update_status(struct mc13892_dev_info *di)
+{
+	int ret;
+	unsigned int value;
+	int online;
+
+	ret = pmic_read_reg(REG_INT_SENSE0, &value, BITFMASK(BIT_CHG_DETS));
+
+	if (ret == 0) {
+		online = BITFEXT(value, BIT_CHG_DETS);
+		if (online != di->charger_online) {
+			di->charger_online = online;
+			dev_info(di->charger.dev, "charger status: %s\n",
+				online ? "online" : "offline");
+			power_supply_changed(&di->charger);
+
+			cancel_delayed_work(&di->monitor_work);
+			queue_delayed_work(di->monitor_wqueue,
+				&di->monitor_work, HZ / 10);
+			if (online) {
+				pmic_start_coulomb_counter();
+				pmic_restart_charging();
+			} else
+				pmic_stop_coulomb_counter();
+		}
+	}
+
+	return ret;
+}
+
+static int mc13892_charger_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	struct mc13892_dev_info *di =
+		container_of((psy), struct mc13892_dev_info, charger);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = di->charger_online;
+		return 0;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static int mc13892_battery_read_status(struct mc13892_dev_info *di)
+{
+	int retval;
+	int coulomb;
+	retval = pmic_get_batt_voltage(&(di->voltage_raw));
+	if (retval == 0)
+		di->voltage_uV = di->voltage_raw * BAT_VOLTAGE_UNIT_UV;
+
+	retval = pmic_get_batt_current(&(di->current_raw));
+	if (retval == 0) {
+		if (di->current_raw & 0x200)
+			di->current_uA =
+				(0x1FF - (di->current_raw & 0x1FF)) *
+				BAT_CURRENT_UNIT_UA * (-1);
+		else
+			di->current_uA =
+				(di->current_raw & 0x1FF) * BAT_CURRENT_UNIT_UA;
+	}
+	retval = pmic_get_charger_coulomb(&coulomb);
+	if (retval == 0)
+		di->accum_current_uAh = COULOMB_TO_UAH(coulomb);
+
+	return retval;
+}
+
+static void mc13892_battery_update_status(struct mc13892_dev_info *di)
+{
+	unsigned int value;
+	int retval;
+	int old_battery_status = di->battery_status;
+
+	if (di->battery_status == POWER_SUPPLY_STATUS_UNKNOWN)
+		di->full_counter = 0;
+
+	if (di->charger_online) {
+		retval = pmic_read_reg(REG_INT_SENSE0,
+					&value, BITFMASK(BIT_CHG_CURRS));
+
+		if (retval == 0) {
+			value = BITFEXT(value, BIT_CHG_CURRS);
+			if (value)
+				di->battery_status =
+					POWER_SUPPLY_STATUS_CHARGING;
+			else
+				di->battery_status =
+					POWER_SUPPLY_STATUS_NOT_CHARGING;
+		}
+
+		if (di->battery_status == POWER_SUPPLY_STATUS_NOT_CHARGING)
+			di->full_counter++;
+		else
+			di->full_counter = 0;
+	} else {
+		di->battery_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		di->full_counter = 0;
+	}
+
+	dev_dbg(di->bat.dev, "bat status: %d\n",
+		di->battery_status);
+
+	if (di->battery_status != old_battery_status)
+		power_supply_changed(&di->bat);
+}
+
+static void mc13892_battery_work(struct work_struct *work)
+{
+	struct mc13892_dev_info *di = container_of(work,
+						     struct mc13892_dev_info,
+						     monitor_work.work);
+	const int interval = HZ * 60;
+
+	dev_dbg(di->dev, "%s\n", __func__);
+
+	mc13892_battery_update_status(di);
+	queue_delayed_work(di->monitor_wqueue, &di->monitor_work, interval);
+}
+
+static void charger_online_event_callback(void *para)
+{
+	struct mc13892_dev_info *di = (struct mc13892_dev_info *) para;
+	pr_info("\n\n DETECTED charger plug/unplug event\n");
+	mc13892_charger_update_status(di);
+}
+
+
+static int mc13892_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	struct mc13892_dev_info *di = to_mc13892_dev_info(psy);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (di->battery_status == POWER_SUPPLY_STATUS_UNKNOWN) {
+			mc13892_charger_update_status(di);
+			mc13892_battery_update_status(di);
+		}
+		val->intval = di->battery_status;
+		return 0;
+	default:
+		break;
+	}
+
+	mc13892_battery_read_status(di);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = di->voltage_uV;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = di->current_uA;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = di->accum_current_uAh;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = 3800000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = 3300000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pmic_battery_remove(struct platform_device *pdev)
+{
+	pmic_event_callback_t bat_event_callback;
+	struct mc13892_dev_info *di = platform_get_drvdata(pdev);
+
+	bat_event_callback.func = charger_online_event_callback;
+	bat_event_callback.param = (void *) di;
+	pmic_event_unsubscribe(EVENT_CHGDETI, bat_event_callback);
+
+	cancel_rearming_delayed_workqueue(di->monitor_wqueue,
+					  &di->monitor_work);
+	destroy_workqueue(di->monitor_wqueue);
+	power_supply_unregister(&di->bat);
+	power_supply_unregister(&di->charger);
+
+	kfree(di);
+
+	return 0;
+}
+
+static int pmic_battery_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	struct mc13892_dev_info *di;
+	pmic_event_callback_t bat_event_callback;
+	pmic_version_t pmic_version;
+
+	/* Only apply battery driver for MC13892 V2.0 due to ENGR108085 */
+	pmic_version = pmic_get_version();
+	if (pmic_version.revision < 20) {
+		pr_debug("Battery driver is only applied for MC13892 V2.0\n");
+		return -1;
+	}
+	if (machine_is_mx51_babbage()) {
+		pr_debug("mc13892 charger is not used for this platform\n");
+		return -1;
+	}
+
+	di = kzalloc(sizeof(*di), GFP_KERNEL);
+	if (!di) {
+		retval = -ENOMEM;
+		goto di_alloc_failed;
+	}
+
+	platform_set_drvdata(pdev, di);
+
+	di->dev	= &pdev->dev;
+	di->bat.name	= "mc13892_bat";
+	di->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	di->bat.properties = mc13892_battery_props;
+	di->bat.num_properties = ARRAY_SIZE(mc13892_battery_props);
+	di->bat.get_property = mc13892_battery_get_property;
+	di->bat.use_for_apm = 1;
+
+	di->battery_status = POWER_SUPPLY_STATUS_UNKNOWN;
+
+	retval = power_supply_register(&pdev->dev, &di->bat);
+	if (retval) {
+		dev_err(di->dev, "failed to register battery\n");
+		goto batt_failed;
+	}
+	di->charger.name	= "mc13892_charger";
+	di->charger.type = POWER_SUPPLY_TYPE_MAINS;
+	di->charger.properties = mc13892_charger_props;
+	di->charger.num_properties = ARRAY_SIZE(mc13892_charger_props);
+	di->charger.get_property = mc13892_charger_get_property;
+	retval = power_supply_register(&pdev->dev, &di->charger);
+	if (retval) {
+		dev_err(di->dev, "failed to register charger\n");
+		goto charger_failed;
+	}
+	INIT_DELAYED_WORK(&di->monitor_work, mc13892_battery_work);
+	di->monitor_wqueue = create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!di->monitor_wqueue) {
+		retval = -ESRCH;
+		goto workqueue_failed;
+	}
+	queue_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ * 10);
+
+	bat_event_callback.func = charger_online_event_callback;
+	bat_event_callback.param = (void *) di;
+	pmic_event_subscribe(EVENT_CHGDETI, bat_event_callback);
+
+	pmic_stop_coulomb_counter();
+	pmic_calibrate_coulomb_counter();
+	goto success;
+
+workqueue_failed:
+	power_supply_unregister(&di->charger);
+charger_failed:
+	power_supply_unregister(&di->bat);
+batt_failed:
+	kfree(di);
+di_alloc_failed:
+success:
+	dev_dbg(di->dev, "%s battery probed!\n", __func__);
+	return retval;
+
+
+	return 0;
+}
+
+static struct platform_driver pmic_battery_driver_ldm = {
+	.driver = {
+		   .name = "pmic_battery",
+		   .bus = &platform_bus_type,
+		   },
+	.probe = pmic_battery_probe,
+	.remove = pmic_battery_remove,
+};
+
+static int __init pmic_battery_init(void)
+{
+	pr_debug("PMIC Battery driver loading...\n");
+	return platform_driver_register(&pmic_battery_driver_ldm);
+}
+
+static void __exit pmic_battery_exit(void)
+{
+	platform_driver_unregister(&pmic_battery_driver_ldm);
+	pr_debug("PMIC Battery driver successfully unloaded\n");
+}
+
+module_init(pmic_battery_init);
+module_exit(pmic_battery_exit);
+
+MODULE_DESCRIPTION("pmic_battery driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc13892/pmic_light.c b/drivers/mxc/pmic/mc13892/pmic_light.c
new file mode 100644
index 0000000..ae02430
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/pmic_light.c
@@ -0,0 +1,685 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mc13892/pmic_light.c
+ * @brief This is the main file of PMIC(mc13783) Light and Backlight driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+/*
+ * Includes
+ */
+#define DEBUG
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/pmic_light.h>
+#include <linux/pmic_status.h>
+
+#define BIT_CL_MAIN_LSH		9
+#define BIT_CL_AUX_LSH		21
+#define BIT_CL_KEY_LSH		9
+#define BIT_CL_RED_LSH		9
+#define BIT_CL_GREEN_LSH	21
+#define BIT_CL_BLUE_LSH		9
+
+#define BIT_CL_MAIN_WID		3
+#define BIT_CL_AUX_WID		3
+#define BIT_CL_KEY_WID		3
+#define BIT_CL_RED_WID		3
+#define BIT_CL_GREEN_WID	3
+#define BIT_CL_BLUE_WID		3
+
+#define BIT_DC_MAIN_LSH		3
+#define BIT_DC_AUX_LSH		15
+#define BIT_DC_KEY_LSH		3
+#define BIT_DC_RED_LSH		3
+#define BIT_DC_GREEN_LSH	15
+#define BIT_DC_BLUE_LSH		3
+
+#define BIT_DC_MAIN_WID		6
+#define BIT_DC_AUX_WID		6
+#define BIT_DC_KEY_WID		6
+#define BIT_DC_RED_WID		6
+#define BIT_DC_GREEN_WID	6
+#define BIT_DC_BLUE_WID		6
+
+#define BIT_RP_MAIN_LSH		2
+#define BIT_RP_AUX_LSH		14
+#define BIT_RP_KEY_LSH		2
+#define BIT_RP_RED_LSH		2
+#define BIT_RP_GREEN_LSH	14
+#define BIT_RP_BLUE_LSH		2
+
+#define BIT_RP_MAIN_WID		1
+#define BIT_RP_AUX_WID		1
+#define BIT_RP_KEY_WID		1
+#define BIT_RP_RED_WID		1
+#define BIT_RP_GREEN_WID	1
+#define BIT_RP_BLUE_WID		1
+
+#define BIT_HC_MAIN_LSH		1
+#define BIT_HC_AUX_LSH		13
+#define BIT_HC_KEY_LSH		1
+
+#define BIT_HC_MAIN_WID		1
+#define BIT_HC_AUX_WID		1
+#define BIT_HC_KEY_WID		1
+
+#define BIT_BP_RED_LSH		0
+#define BIT_BP_GREEN_LSH	12
+#define BIT_BP_BLUE_LSH		0
+
+#define BIT_BP_RED_WID		2
+#define BIT_BP_GREEN_WID	2
+#define BIT_BP_BLUE_WID		2
+
+int pmic_light_init_reg(void)
+{
+	CHECK_ERROR(pmic_write_reg(REG_LED_CTL0, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_LED_CTL1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_LED_CTL2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_LED_CTL3, 0, PMIC_ALL_BITS));
+
+	return 0;
+}
+
+static int pmic_light_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+};
+
+static int pmic_light_resume(struct platform_device *pdev)
+{
+	return 0;
+};
+
+PMIC_STATUS mc13892_bklit_set_hi_current(enum lit_channel channel, int mode)
+{
+	unsigned int mask;
+	unsigned int value;
+	int reg;
+
+	switch (channel) {
+	case LIT_MAIN:
+		value = BITFVAL(BIT_HC_MAIN, mode);
+		mask = BITFMASK(BIT_HC_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		value = BITFVAL(BIT_HC_AUX, mode);
+		mask = BITFMASK(BIT_HC_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		value = BITFVAL(BIT_HC_KEY, mode);
+		mask = BITFMASK(BIT_HC_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(reg, value, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_get_hi_current(enum lit_channel channel, int *mode)
+{
+	unsigned int mask;
+	int reg;
+
+	switch (channel) {
+	case LIT_MAIN:
+		mask = BITFMASK(BIT_HC_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		mask = BITFMASK(BIT_HC_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		mask = BITFMASK(BIT_HC_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, mode, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level)
+{
+	unsigned int mask;
+	unsigned int value;
+	int reg;
+
+	if (level > LIT_CURR_HI_42)
+		return PMIC_PARAMETER_ERROR;
+	else if (level >= LIT_CURR_HI_0) {
+		CHECK_ERROR(mc13892_bklit_set_hi_current(channel, 1));
+		level -= LIT_CURR_HI_0;
+	}
+
+	switch (channel) {
+	case LIT_MAIN:
+		value = BITFVAL(BIT_CL_MAIN, level);
+		mask = BITFMASK(BIT_CL_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		value = BITFVAL(BIT_CL_AUX, level);
+		mask = BITFMASK(BIT_CL_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		value = BITFVAL(BIT_CL_KEY, level);
+		mask = BITFMASK(BIT_CL_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		value = BITFVAL(BIT_CL_RED, level);
+		mask = BITFMASK(BIT_CL_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		value = BITFVAL(BIT_CL_GREEN, level);
+		mask = BITFMASK(BIT_CL_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		value = BITFVAL(BIT_CL_BLUE, level);
+		mask = BITFMASK(BIT_CL_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(reg, value, mask));
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level)
+{
+	unsigned int reg_value = 0;
+	unsigned int mask = 0;
+	int reg, mode;
+
+	CHECK_ERROR(mc13892_bklit_get_hi_current(channel, &mode));
+
+	switch (channel) {
+	case LIT_MAIN:
+		mask = BITFMASK(BIT_CL_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		mask = BITFMASK(BIT_CL_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		mask = BITFMASK(BIT_CL_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		mask = BITFMASK(BIT_CL_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		mask = BITFMASK(BIT_CL_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		mask = BITFMASK(BIT_CL_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_value, mask));
+
+	switch (channel) {
+	case LIT_MAIN:
+		*level = BITFEXT(reg_value, BIT_CL_MAIN);
+		break;
+	case LIT_AUX:
+		*level = BITFEXT(reg_value, BIT_CL_AUX);
+		break;
+	case LIT_KEY:
+		*level = BITFEXT(reg_value, BIT_CL_KEY);
+		break;
+	case LIT_RED:
+		*level = BITFEXT(reg_value, BIT_CL_RED);
+		break;
+	case LIT_GREEN:
+		*level = BITFEXT(reg_value, BIT_CL_GREEN);
+		break;
+	case LIT_BLUE:
+		*level = BITFEXT(reg_value, BIT_CL_BLUE);
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	if (mode == 1)
+		*level += LIT_CURR_HI_0;
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc)
+{
+	unsigned int mask;
+	unsigned int value;
+	int reg;
+
+	switch (channel) {
+	case LIT_MAIN:
+		value = BITFVAL(BIT_DC_MAIN, dc);
+		mask = BITFMASK(BIT_DC_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		value = BITFVAL(BIT_DC_AUX, dc);
+		mask = BITFMASK(BIT_DC_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		value = BITFVAL(BIT_DC_KEY, dc);
+		mask = BITFMASK(BIT_DC_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		value = BITFVAL(BIT_DC_RED, dc);
+		mask = BITFMASK(BIT_DC_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		value = BITFVAL(BIT_DC_GREEN, dc);
+		mask = BITFMASK(BIT_DC_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		value = BITFVAL(BIT_DC_BLUE, dc);
+		mask = BITFMASK(BIT_DC_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(reg, value, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc)
+{
+	unsigned int mask;
+	int reg;
+	unsigned int reg_value = 0;
+
+	switch (channel) {
+	case LIT_MAIN:
+		mask = BITFMASK(BIT_DC_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		mask = BITFMASK(BIT_DC_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		mask = BITFMASK(BIT_DC_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		mask = BITFMASK(BIT_DC_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		mask = BITFMASK(BIT_DC_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		mask = BITFMASK(BIT_DC_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &reg_value, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag)
+{
+	unsigned int mask;
+	unsigned int value;
+	int reg;
+
+	switch (channel) {
+	case LIT_MAIN:
+		value = BITFVAL(BIT_RP_MAIN, flag);
+		mask = BITFMASK(BIT_RP_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		value = BITFVAL(BIT_RP_AUX, flag);
+		mask = BITFMASK(BIT_RP_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		value = BITFVAL(BIT_RP_KEY, flag);
+		mask = BITFMASK(BIT_RP_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		value = BITFVAL(BIT_RP_RED, flag);
+		mask = BITFMASK(BIT_RP_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		value = BITFVAL(BIT_RP_GREEN, flag);
+		mask = BITFMASK(BIT_RP_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		value = BITFVAL(BIT_RP_BLUE, flag);
+		mask = BITFMASK(BIT_RP_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(reg, value, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag)
+{
+	unsigned int mask;
+	int reg;
+
+	switch (channel) {
+	case LIT_MAIN:
+		mask = BITFMASK(BIT_RP_MAIN);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_AUX:
+		mask = BITFMASK(BIT_RP_AUX);
+		reg = REG_LED_CTL0;
+		break;
+	case LIT_KEY:
+		mask = BITFMASK(BIT_RP_KEY);
+		reg = REG_LED_CTL1;
+		break;
+	case LIT_RED:
+		mask = BITFMASK(BIT_RP_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		mask = BITFMASK(BIT_RP_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		mask = BITFMASK(BIT_RP_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, flag, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period)
+{
+	unsigned int mask;
+	unsigned int value;
+	int reg;
+
+	switch (channel) {
+	case LIT_RED:
+		value = BITFVAL(BIT_BP_RED, period);
+		mask = BITFMASK(BIT_BP_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		value = BITFVAL(BIT_BP_GREEN, period);
+		mask = BITFMASK(BIT_BP_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		value = BITFVAL(BIT_BP_BLUE, period);
+		mask = BITFMASK(BIT_BP_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+	CHECK_ERROR(pmic_write_reg(reg, value, mask));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period)
+{
+	unsigned int mask;
+	int reg;
+
+	switch (channel) {
+	case LIT_RED:
+		mask = BITFMASK(BIT_BP_RED);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_GREEN:
+		mask = BITFMASK(BIT_BP_GREEN);
+		reg = REG_LED_CTL2;
+		break;
+	case LIT_BLUE:
+		mask = BITFMASK(BIT_BP_BLUE);
+		reg = REG_LED_CTL3;
+		break;
+	default:
+		return PMIC_PARAMETER_ERROR;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, period, mask));
+	return PMIC_SUCCESS;
+}
+
+EXPORT_SYMBOL(mc13892_bklit_set_current);
+EXPORT_SYMBOL(mc13892_bklit_get_current);
+EXPORT_SYMBOL(mc13892_bklit_set_dutycycle);
+EXPORT_SYMBOL(mc13892_bklit_get_dutycycle);
+EXPORT_SYMBOL(mc13892_bklit_set_ramp);
+EXPORT_SYMBOL(mc13892_bklit_get_ramp);
+EXPORT_SYMBOL(mc13892_bklit_set_blink_p);
+EXPORT_SYMBOL(mc13892_bklit_get_blink_p);
+
+static int pmic_light_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef DEBUG
+static ssize_t lit_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return 0;
+}
+
+enum {
+	SET_CURR = 0,
+	SET_DC,
+	SET_RAMP,
+	SET_BP,
+	SET_CH,
+	LIT_CMD_MAX
+};
+
+static const char *const lit_cmd[LIT_CMD_MAX] = {
+	[SET_CURR] = "cur",
+	[SET_DC] = "dc",
+	[SET_RAMP] = "ra",
+	[SET_BP] = "bp",
+	[SET_CH] = "ch"
+};
+
+static int cmd(unsigned int index, int value)
+{
+	static int ch = LIT_MAIN;
+	int ret = 0;
+
+	switch (index) {
+	case SET_CH:
+		ch = value;
+		break;
+	case SET_CURR:
+		pr_debug("set %d cur %d\n", ch, value);
+		ret = mc13892_bklit_set_current(ch, value);
+		break;
+	case SET_DC:
+		pr_debug("set %d dc %d\n", ch, value);
+		ret = mc13892_bklit_set_dutycycle(ch, value);
+		break;
+	case SET_RAMP:
+		pr_debug("set %d ramp %d\n", ch, value);
+		ret = mc13892_bklit_set_ramp(ch, value);
+		break;
+	case SET_BP:
+		pr_debug("set %d bp %d\n", ch, value);
+		ret = mc13892_bklit_set_blink_p(ch, value);
+		break;
+	default:
+		pr_debug("error command\n");
+		break;
+	}
+
+	if (ret == PMIC_SUCCESS)
+		pr_debug("command exec successfully!\n");
+
+	return 0;
+}
+
+static ssize_t lit_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	int state = 0;
+	const char *const *s;
+	char *p, *q;
+	int error;
+	int len, value = 0;
+
+	pr_debug("lit_ctl\n");
+
+	q = NULL;
+	q = memchr(buf, ' ', count);
+
+	if (q != NULL) {
+		len = q - buf;
+		q += 1;
+		value = simple_strtoul(q, NULL, 10);
+	} else {
+		p = memchr(buf, '\n', count);
+		len = p ? p - buf : count;
+	}
+
+	for (s = &lit_cmd[state]; state < LIT_CMD_MAX; s++, state++) {
+		if (*s && !strncmp(buf, *s, len))
+			break;
+	}
+	if (state < LIT_CMD_MAX && *s)
+		error = cmd(state, value);
+	else
+		error = -EINVAL;
+
+	return count;
+}
+
+#else
+static ssize_t lit_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return 0;
+}
+
+static ssize_t lit_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	return count;
+}
+
+#endif
+
+static DEVICE_ATTR(lit, 0644, lit_info, lit_ctl);
+
+static int pmic_light_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	pr_debug("PMIC ADC start probe\n");
+	ret = device_create_file(&(pdev->dev), &dev_attr_lit);
+	if (ret) {
+		pr_debug("Can't create device file!\n");
+		return -ENODEV;
+	}
+
+	pmic_light_init_reg();
+
+	pr_debug("PMIC Light successfully loaded\n");
+	return 0;
+}
+
+static struct platform_driver pmic_light_driver_ldm = {
+	.driver = {
+		   .name = "pmic_light",
+		   },
+	.suspend = pmic_light_suspend,
+	.resume = pmic_light_resume,
+	.probe = pmic_light_probe,
+	.remove = pmic_light_remove,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+static int __init pmic_light_init(void)
+{
+	pr_debug("PMIC Light driver loading...\n");
+	return platform_driver_register(&pmic_light_driver_ldm);
+}
+static void __exit pmic_light_exit(void)
+{
+	platform_driver_unregister(&pmic_light_driver_ldm);
+	pr_debug("PMIC Light driver successfully unloaded\n");
+}
+
+/*
+ * Module entry points
+ */
+
+subsys_initcall(pmic_light_init);
+module_exit(pmic_light_exit);
+
+MODULE_DESCRIPTION("PMIC_LIGHT");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/mfd/mc13783/core.h b/include/linux/mfd/mc13783/core.h
new file mode 100644
index 0000000..0b01d3e
--- /dev/null
+++ b/include/linux/mfd/mc13783/core.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13783_CORE_H_
+#define __LINUX_MFD_MC13783_CORE_H_
+
+#include <linux/kernel.h>
+
+/*!
+ * brief PMIC regulators.
+ */
+#define MC13783_SW1A 0
+#define MC13783_SW1B 1
+#define MC13783_SW2A 2
+#define MC13783_SW2B 3
+#define MC13783_SW3 4
+#define MC13783_VAUDIO 5
+#define MC13783_VIOHI 6
+#define MC13783_VIOLO 7
+#define MC13783_VDIG 8
+#define MC13783_VGEN 9
+#define MC13783_VRFDIG 10
+#define MC13783_VRFREF 11
+#define MC13783_VRFCP 12
+#define MC13783_VSIM 13
+#define MC13783_VESIM 14
+#define MC13783_VCAM 15
+#define MC13783_VRFBG 16
+#define MC13783_VVIB 17
+#define MC13783_VRF1 18
+#define MC13783_VRF2 19
+#define MC13783_VMMC1 20
+#define MC13783_VMMC2 21
+#define MC13783_GPO1 22
+#define MC13783_GPO2 23
+#define MC13783_GPO3 24
+#define MC13783_GPO4 25
+#define MC13783_REG_NUM 26
+
+struct mc13783;
+struct regulator_init_data;
+
+struct mc13783_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC13783_REG_NUM];
+};
+
+struct mc13783 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc13783_pmic pmic;
+};
+
+int mc13783_register_regulator(struct mc13783 *mc13783, int reg,
+			       struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/mfd/mc13892/core.h b/include/linux/mfd/mc13892/core.h
new file mode 100644
index 0000000..6e4ef85
--- /dev/null
+++ b/include/linux/mfd/mc13892/core.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13892_CORE_H_
+#define __LINUX_MFD_MC13892_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define MC13892_SW1 0
+#define MC13892_SW2 1
+#define MC13892_SW3 2
+#define MC13892_SW4 3
+#define MC13892_SWBST 4
+#define MC13892_VIOHI 5
+#define MC13892_VPLL 6
+#define MC13892_VDIG 7
+#define MC13892_VSD 8
+#define MC13892_VUSB2 9
+#define MC13892_VVIDEO 10
+#define MC13892_VAUDIO 11
+#define MC13892_VCAM 12
+#define MC13892_VGEN1 13
+#define MC13892_VGEN2 14
+#define MC13892_VGEN3 15
+#define MC13892_VUSB 16
+#define MC13892_GPO1 17
+#define MC13892_GPO2 18
+#define MC13892_GPO3 19
+#define MC13892_GPO4 20
+#define MC13892_PWGT1 21
+#define MC13892_PWGT2 22
+#define MC13892_REG_NUM 23
+
+struct mc13892;
+struct regulator_init_data;
+
+struct mc13892_platform_data {
+	int (*init)(struct mc13892 *);
+};
+
+struct mc13892_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC13892_REG_NUM];
+};
+
+struct mc13892 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc13892_pmic pmic;
+};
+
+int mc13892_register_regulator(struct mc13892 *mc13892, int reg,
+			      struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/pmic_adc.h b/include/linux/pmic_adc.h
new file mode 100644
index 0000000..58348cc
--- /dev/null
+++ b/include/linux/pmic_adc.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D', 4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D', 5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum {
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum {
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum {
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct {
+/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum {
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct {
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator.
+ */
+typedef struct {
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+
+int is_pmic_adc_ready(void);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/linux/pmic_battery.h b/include/linux/pmic_battery.h
new file mode 100644
index 0000000..82aa6bf
--- /dev/null
+++ b/include/linux/pmic_battery.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+
+/*!
+ * Get the charger voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_VOLTAGE		_IOR('p', 0xca, int)
+/*!
+ * Get the battery voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_VOLTAGE		_IOR('p', 0xcb, int)
+/*!
+ * Get the battery current.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_CURRENT		_IOR('p', 0xcc, int)
+/*!
+ * Get the charger sensor.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_SENSOR		_IOR('p', 0xcd, int)
+/*!
+ * Get the battery temperature.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_TEMPERATURE	_IOR('p', 0xce, int)
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum {
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum {
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum {
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum {
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct {
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct {
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * c_voltage threshold - Used on SC55112
+	 */
+	unsigned char threshold;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+
+/*START: for 3ds hw event*/
+/*!
+ * Battery event type enum
+ */
+enum {
+	BAT_EVENT_CHARGER_PLUG = 0x01,
+	BAT_EVENT_CHARGER_UNPLUG = 0x02,
+	BAT_EVENT_CHARGER_OVERVOLTAGE = 0x04,
+	BAT_EVENT_BATTERY_LOW = 0x08,
+	BAT_EVENT_POWER_FAILED = 0x10,
+	BAT_EVENT_CHARGER_FULL = 0x20,
+} t_bat_event;
+/*END: for 3ds hw event*/
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+ *                       BPDET   UVDET   LOBATL
+ *                       ____    _____   ___________
+ *                       0       2.6     UVDET + 0.2
+ *                       1       2.6     UVDET + 0.3
+ *                       2       2.6     UVDET + 0.4
+ *                       3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/linux/pmic_external.h b/include/linux/pmic_external.h
new file mode 100644
index 0000000..9182bc0
--- /dev/null
+++ b/include/linux/pmic_external.h
@@ -0,0 +1,1108 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum {
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3,
+	PMIC_MC34704 = 4
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct {
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its
+ * parameter to be used when un/registering and launching a callback
+ * for an event.
+ */
+typedef struct {
+	/*!
+	 * call back function
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct {
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for sc55112 core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#define PMIC_ARBITRATION	"NULL"
+
+#ifdef CONFIG_MXC_PMIC_MC13783
+/*!
+ * This is the enumeration of register names of MC13783
+ */
+typedef enum {
+	/*!
+	 * REG_INTERRUPT_STATUS_0
+	 */
+	REG_INTERRUPT_STATUS_0 = 0,
+	/*!
+	 * REG_INTERRUPT_MASK_0
+	 */
+	REG_INTERRUPT_MASK_0,
+	/*!
+	 * REG_INTERRUPT_SENSE_0
+	 */
+	REG_INTERRUPT_SENSE_0,
+	/*!
+	 * REG_INTERRUPT_STATUS_1
+	 */
+	REG_INTERRUPT_STATUS_1,
+	/*!
+	 * REG_INTERRUPT_MASK_1
+	 */
+	REG_INTERRUPT_MASK_1,
+	/*!
+	 * REG_INTERRUPT_SENSE_1
+	 */
+	REG_INTERRUPT_SENSE_1,
+	/*!
+	 * REG_POWER_UP_MODE_SENSE
+	 */
+	REG_POWER_UP_MODE_SENSE,
+	/*!
+	 * REG_REVISION
+	 */
+	REG_REVISION,
+	/*!
+	 * REG_SEMAPHORE
+	 */
+	REG_SEMAPHORE,
+	/*!
+	 * REG_ARBITRATION_PERIPHERAL_AUDIO
+	 */
+	REG_ARBITRATION_PERIPHERAL_AUDIO,
+	/*!
+	 * REG_ARBITRATION_SWITCHERS
+	 */
+	REG_ARBITRATION_SWITCHERS,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_0
+	 */
+	REG_ARBITRATION_REGULATORS_0,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_1
+	 */
+	REG_ARBITRATION_REGULATORS_1,
+	/*!
+	 * REG_POWER_CONTROL_0
+	 */
+	REG_POWER_CONTROL_0,
+	/*!
+	 * REG_POWER_CONTROL_1
+	 */
+	REG_POWER_CONTROL_1,
+	/*!
+	 * REG_POWER_CONTROL_2
+	 */
+	REG_POWER_CONTROL_2,
+	/*!
+	 * REG_REGEN_ASSIGNMENT
+	 */
+	REG_REGEN_ASSIGNMENT,
+	/*!
+	 * REG_CONTROL_SPARE
+	 */
+	REG_CONTROL_SPARE,
+	/*!
+	 * REG_MEMORY_A
+	 */
+	REG_MEMORY_A,
+	/*!
+	 * REG_MEMORY_B
+	 */
+	REG_MEMORY_B,
+	/*!
+	 * REG_RTC_TIME
+	 */
+	REG_RTC_TIME,
+	/*!
+	 * REG_RTC_ALARM
+	 */
+	REG_RTC_ALARM,
+	/*!
+	 * REG_RTC_DAY
+	 */
+	REG_RTC_DAY,
+	/*!
+	 * REG_RTC_DAY_ALARM
+	 */
+	REG_RTC_DAY_ALARM,
+	/*!
+	 * REG_SWITCHERS_0
+	 */
+	REG_SWITCHERS_0,
+	/*!
+	 * REG_SWITCHERS_1
+	 */
+	REG_SWITCHERS_1,
+	/*!
+	 * REG_SWITCHERS_2
+	 */
+	REG_SWITCHERS_2,
+	/*!
+	 * REG_SWITCHERS_3
+	 */
+	REG_SWITCHERS_3,
+	/*!
+	 * REG_SWITCHERS_4
+	 */
+	REG_SWITCHERS_4,
+	/*!
+	 * REG_SWITCHERS_5
+	 */
+	REG_SWITCHERS_5,
+	/*!
+	 * REG_REGULATOR_SETTING_0
+	 */
+	REG_REGULATOR_SETTING_0,
+	/*!
+	 * REG_REGULATOR_SETTING_1
+	 */
+	REG_REGULATOR_SETTING_1,
+	/*!
+	 * REG_REGULATOR_MODE_0
+	 */
+	REG_REGULATOR_MODE_0,
+	/*!
+	 * REG_REGULATOR_MODE_1
+	 */
+	REG_REGULATOR_MODE_1,
+	/*!
+	 * REG_POWER_MISCELLANEOUS
+	 */
+	REG_POWER_MISCELLANEOUS,
+	/*!
+	 * REG_POWER_SPARE
+	 */
+	REG_POWER_SPARE,
+	/*!
+	 * REG_AUDIO_RX_0
+	 */
+	REG_AUDIO_RX_0,
+	/*!
+	 * REG_AUDIO_RX_1
+	 */
+	REG_AUDIO_RX_1,
+	/*!
+	 * REG_AUDIO_TX
+	 */
+	REG_AUDIO_TX,
+	/*!
+	 * REG_AUDIO_SSI_NETWORK
+	 */
+	REG_AUDIO_SSI_NETWORK,
+	/*!
+	 * REG_AUDIO_CODEC
+	 */
+	REG_AUDIO_CODEC,
+	/*!
+	 * REG_AUDIO_STEREO_DAC
+	 */
+	REG_AUDIO_STEREO_DAC,
+	/*!
+	 * REG_AUDIO_SPARE
+	 */
+	REG_AUDIO_SPARE,
+	/*!
+	 * REG_ADC_0
+	 */
+	REG_ADC_0,
+	/*!
+	 * REG_ADC_1
+	 */
+	REG_ADC_1,
+	/*!
+	 * REG_ADC_2
+	 */
+	REG_ADC_2,
+	/*!
+	 * REG_ADC_3
+	 */
+	REG_ADC_3,
+	/*!
+	 * REG_ADC_4
+	 */
+	REG_ADC_4,
+	/*!
+	 * REG_CHARGER
+	 */
+	REG_CHARGER,
+	/*!
+	 * REG_USB
+	 */
+	REG_USB,
+	/*!
+	 * REG_CHARGE_USB_SPARE
+	 */
+	REG_CHARGE_USB_SPARE,
+	/*!
+	 * REG_LED_CONTROL_0
+	 */
+	REG_LED_CONTROL_0,
+	/*!
+	 * REG_LED_CONTROL_1
+	 */
+	REG_LED_CONTROL_1,
+	/*!
+	 * REG_LED_CONTROL_2
+	 */
+	REG_LED_CONTROL_2,
+	/*!
+	 * REG_LED_CONTROL_3
+	 */
+	REG_LED_CONTROL_3,
+	/*!
+	 * REG_LED_CONTROL_4
+	 */
+	REG_LED_CONTROL_4,
+	/*!
+	 * REG_LED_CONTROL_5
+	 */
+	REG_LED_CONTROL_5,
+	/*!
+	 * REG_SPARE
+	 */
+	REG_SPARE,
+	/*!
+	 * REG_TRIM_0
+	 */
+	REG_TRIM_0,
+	/*!
+	 * REG_TRIM_1
+	 */
+	REG_TRIM_1,
+	/*!
+	 * REG_TEST_0
+	 */
+	REG_TEST_0,
+	/*!
+	 * REG_TEST_1
+	 */
+	REG_TEST_1,
+	/*!
+	 * REG_TEST_2
+	 */
+	REG_TEST_2,
+	/*!
+	 * REG_TEST_3
+	 */
+	REG_TEST_3,
+	/*!
+	 * REG_NB
+	 */
+	REG_NB,
+} pmic_reg;
+
+/*!
+ * This is event list of mc13783 interrupt
+ */
+
+typedef enum {
+	/*!
+	 * ADC has finished requested conversions
+	 */
+	EVENT_ADCDONEI = 0,
+	/*!
+	 * ADCBIS has finished requested conversions
+	 */
+	EVENT_ADCBISDONEI = 1,
+	/*!
+	 * Touchscreen wakeup
+	 */
+	EVENT_TSI = 2,
+	/*!
+	 * ADC reading above high limit
+	 */
+	EVENT_WHIGHI = 3,
+	/*!
+	 * ADC reading below low limit
+	 */
+	EVENT_WLOWI = 4,
+	/*!
+	 * Charger attach and removal
+	 */
+	EVENT_CHGDETI = 6,
+	/*!
+	 * Charger over-voltage detection
+	 */
+	EVENT_CHGOVI = 7,
+	/*!
+	 * Charger path reverse current
+	 */
+	EVENT_CHGREVI = 8,
+	/*!
+	 * Charger path short circuit
+	 */
+	EVENT_CHGSHORTI = 9,
+	/*!
+	 * BP regulator current or voltage regulation
+	 */
+	EVENT_CCCVI = 10,
+	/*!
+	 * Charge current below threshold
+	 */
+	EVENT_CHRGCURRI = 11,
+	/*!
+	 * BP turn on threshold detection
+	 */
+	EVENT_BPONI = 12,
+	/*!
+	 * End of life / low battery detect
+	 */
+	EVENT_LOBATLI = 13,
+	/*!
+	 * Low battery warning
+	 */
+	EVENT_LOBATHI = 14,
+	/*!
+	 * USB detect
+	 */
+	EVENT_USBI = 16,
+	/*!
+	 * USB ID Line detect
+	 */
+	EVENT_IDI = 19,
+	/*!
+	 * Single ended 1 detect
+	 */
+	EVENT_SE1I = 21,
+	/*!
+	 * Car-kit detect
+	 */
+	EVENT_CKDETI = 22,
+	/*!
+	 * 1 Hz time-tick
+	 */
+	EVENT_E1HZI = 24,
+	/*!
+	 * Time of day alarm
+	 */
+	EVENT_TODAI = 25,
+	/*!
+	 * ON1B event
+	 */
+	EVENT_ONOFD1I = 27,
+	/*!
+	 * ON2B event
+	 */
+	EVENT_ONOFD2I = 28,
+	/*!
+	 * ON3B event
+	 */
+	EVENT_ONOFD3I = 29,
+	/*!
+	 * System reset
+	 */
+	EVENT_SYSRSTI = 30,
+	/*!
+	 * RTC reset occurred
+	 */
+	EVENT_RTCRSTI = 31,
+	/*!
+	 * Power cut event
+	 */
+	EVENT_PCI = 32,
+	/*!
+	 * Warm start event
+	 */
+	EVENT_WARMI = 33,
+	/*!
+	 * Memory hold event
+	 */
+	EVENT_MEMHLDI = 34,
+	/*!
+	 * Power ready
+	 */
+	EVENT_PWRRDYI = 35,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	EVENT_THWARNLI = 36,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	EVENT_THWARNHI = 37,
+	/*!
+	 * Clock source change
+	 */
+	EVENT_CLKI = 38,
+	/*!
+	 * Semaphore
+	 */
+	EVENT_SEMAFI = 39,
+	/*!
+	 * Microphone bias 2 detect
+	 */
+	EVENT_MC2BI = 41,
+	/*!
+	 * Headset attach
+	 */
+	EVENT_HSDETI = 42,
+	/*!
+	 * Stereo headset detect
+	 */
+	EVENT_HSLI = 43,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	EVENT_ALSPTHI = 44,
+	/*!
+	 * Short circuit on AHS outputs
+	 */
+	EVENT_AHSSHORTI = 45,
+	/*!
+	 * number of event
+	 */
+	EVENT_NB,
+} type_event;
+
+/*!
+ * This enumeration all senses of MC13783.
+ */
+typedef enum {
+	/*!
+	 * Charger attach sense
+	 */
+	SENSE_CHGDETS = 6,
+	/*!
+	 * Charger over-voltage sense
+	 */
+	SENSE_CHGOVS,
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	SENSE_CHGREVS,
+	/*!
+	 * Charger short circuit
+	 */
+	SENSE_CHGSHORTS,
+	/*!
+	 * Charger regulator operating mode
+	 */
+	SENSE_CCCVS,
+	/*!
+	 * Charger current below threshold
+	 */
+	SENSE_CHGCURRS,
+	/*!
+	 * BP turn on
+	 */
+	SENSE_BPONS,
+	/*!
+	 * Low bat detect
+	 */
+	SENSE_LOBATLS,
+	/*!
+	 * Low bat warning
+	 */
+	SENSE_LOBATHS,
+	/*!
+	 * UDPS
+	 */
+	SENSE_UDPS,
+	/*!
+	 * USB 4V4
+	 */
+	SENSE_USB4V4S,
+	/*!
+	 * USB 2V0
+	 */
+	SENSE_USB2V0S,
+	/*!
+	 * USB 0V8
+	 */
+	SENSE_USB0V8S,
+	/*!
+	 * ID Floats
+	 */
+	SENSE_ID_FLOATS,
+	/*!
+	 * ID Gnds
+	 */
+	SENSE_ID_GNDS,
+	/*!
+	 * Single ended
+	 */
+	SENSE_SE1S,
+	/*!
+	 * Car-kit detect
+	 */
+	SENSE_CKDETS,
+	/*!
+	 * UDMS
+	 */
+	SENSE_UDMS,
+	/*!
+	 * mic bias detect
+	 */
+	SENSE_MC2BS,
+	/*!
+	 * headset attached
+	 */
+	SENSE_HSDETS,
+	/*!
+	 * ST headset attached
+	 */
+	SENSE_HSLS,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	SENSE_ALSPTHS,
+	/*!
+	 * short circuit on AHS
+	 */
+	SENSE_AHSSHORTS,
+	/*!
+	 * ON1B pin is hight
+	 */
+	SENSE_ONOFD1S,
+	/*!
+	 * ON2B pin is hight
+	 */
+	SENSE_ONOFD2S,
+	/*!
+	 * ON3B pin is hight
+	 */
+	SENSE_ONOFD3S,
+	/*!
+	 * System reset power ready
+	 */
+	SENSE_PWRRDYS,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	SENSE_THWARNHS,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	SENSE_THWARNLS,
+	/*!
+	 * Clock source is XTAL
+	 */
+	SENSE_CLKS,
+} t_sensor;
+
+/*!
+ * This structure is used to read all sense bits of MC13783.
+ */
+typedef struct {
+	/*!
+	 * Charger attach sense
+	 */
+	bool sense_chgdets;
+	/*!
+	 * Charger over-voltage sense
+	 */
+	bool sense_chgovs;
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	bool sense_chgrevs;
+	/*!
+	 * Charger short circuit
+	 */
+	bool sense_chgshorts;
+	/*!
+	 * Charger regulator operating mode
+	 */
+	bool sense_cccvs;
+	/*!
+	 * Charger current below threshold
+	 */
+	bool sense_chgcurrs;
+	/*!
+	 * BP turn on
+	 */
+	bool sense_bpons;
+	/*!
+	 * Low bat detect
+	 */
+	bool sense_lobatls;
+	/*!
+	 * Low bat warning
+	 */
+	bool sense_lobaths;
+	/*!
+	 * USB 4V4
+	 */
+	bool sense_usb4v4s;
+	/*!
+	 * USB 2V0
+	 */
+	bool sense_usb2v0s;
+	/*!
+	 * USB 0V8
+	 */
+	bool sense_usb0v8s;
+	/*!
+	 * ID Floats
+	 */
+	bool sense_id_floats;
+	/*!
+	 * ID Gnds
+	 */
+	bool sense_id_gnds;
+	/*!
+	 * Single ended
+	 */
+	bool sense_se1s;
+	/*!
+	 * Car-kit detect
+	 */
+	bool sense_ckdets;
+	/*!
+	 * mic bias detect
+	 */
+	bool sense_mc2bs;
+	/*!
+	 * headset attached
+	 */
+	bool sense_hsdets;
+	/*!
+	 * ST headset attached
+	 */
+	bool sense_hsls;
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	bool sense_alspths;
+	/*!
+	 * short circuit on AHS
+	 */
+	bool sense_ahsshorts;
+	/*!
+	 * ON1B pin is hight
+	 */
+	bool sense_onofd1s;
+	/*!
+	 * ON2B pin is hight
+	 */
+	bool sense_onofd2s;
+	/*!
+	 * ON3B pin is hight
+	 */
+	bool sense_onofd3s;
+	/*!
+	 * System reset power ready
+	 */
+	bool sense_pwrrdys;
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	bool sense_thwarnhs;
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	bool sense_thwarnls;
+	/*!
+	 * Clock source is XTAL
+	 */
+	bool sense_clks;
+} t_sensor_bits;
+
+#endif				/*CONFIG_MXC_PMIC_MC13783 */
+
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,		/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,		/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,		/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,		/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,		/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,		/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+};
+
+typedef enum {
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
+} t_sensor;
+
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value);
+int pmic_read(int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+void mc13892_power_off(void);
+
+#endif
+
+#if defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
+
+typedef enum {
+	/* register names for mc34704 */
+	REG_MC34704_GENERAL1 = 0x01,
+	REG_MC34704_GENERAL2 = 0x02,
+	REG_MC34704_GENERAL3 = 0x03,
+	REG_MC34704_VGSET1 = 0x04,
+	REG_MC34704_VGSET2 = 0x05,
+	REG_MC34704_REG2SET1 = 0x06,
+	REG_MC34704_REG2SET2 = 0x07,
+	REG_MC34704_REG3SET1 = 0x08,
+	REG_MC34704_REG3SET2 = 0x09,
+	REG_MC34704_REG4SET1 = 0x0A,
+	REG_MC34704_REG4SET2 = 0x0B,
+	REG_MC34704_REG5SET1 = 0x0C,
+	REG_MC34704_REG5SET2 = 0x0D,
+	REG_MC34704_REG5SET3 = 0x0E,
+	REG_MC34704_REG6SET1 = 0x0F,
+	REG_MC34704_REG6SET2 = 0x10,
+	REG_MC34704_REG6SET3 = 0x11,
+	REG_MC34704_REG7SET1 = 0x12,
+	REG_MC34704_REG7SET2 = 0x13,
+	REG_MC34704_REG7SET3 = 0x14,
+	REG_MC34704_REG8SET1 = 0x15,
+	REG_MC34704_REG8SET2 = 0x16,
+	REG_MC34704_REG8SET3 = 0x17,
+	REG_MC34704_FAULTS = 0x18,
+	REG_MC34704_I2CSET1 = 0x19,
+	REG_MC34704_REG3DAC = 0x49,
+	REG_MC34704_REG7CR0 = 0x58,
+	REG_MC34704_REG7DAC = 0x59,
+	REG_NB = 0x60,
+} pmic_reg;
+
+typedef enum {
+	/* events for mc34704 */
+	EVENT_FLT1 = 0,
+	EVENT_FLT2,
+	EVENT_FLT3,
+	EVENT_FLT4,
+	EVENT_FLT5,
+	EVENT_FLT6,
+	EVENT_FLT7,
+	EVENT_FLT8,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	MCU_SENSOR_NOT_SUPPORT
+} t_sensor;
+
+typedef enum {
+	MCU_SENSOR_BIT_NOT_SUPPORT
+} t_sensor_bits;
+
+#endif				/* MXC_PMIC_MC34704 */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+#if defined(CONFIG_MXC_PMIC)
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback);
+/*!
+* This function is called by PMIC clients to un-subscribe on an event.
+*
+* @param        event_unsub   structure of event, it contains type of event and callback
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+/*!
+* This function is called to read all sensor bits of PMIC.
+*
+* @param        sensor    Sensor to be checked.
+*
+* @return       This function returns true if the sensor bit is high;
+*               or returns false if the sensor bit is low.
+*/
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+* This function checks one sensor of PMIC.
+*
+* @param        sensor_bits  structure of all sensor bits.
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits);
+
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
+#endif				/*CONFIG_MXC_PMIC*/
+#endif				/* __KERNEL__ */
+/* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
+
+struct pmic_platform_data {
+	int (*init)(void *);
+	int power_key_irq;
+};
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/linux/pmic_light.h b/include/linux/pmic_light.h
new file mode 100644
index 0000000..adb8a30
--- /dev/null
+++ b/include/linux/pmic_light.h
@@ -0,0 +1,1082 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum {
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum {
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum {
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct {
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+				 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+				 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum {
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum {
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum {
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum {
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum {
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum {
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum {
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum {
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum {
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum {
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+enum curr_level {
+	LIT_CURR_0 = 0,
+	LIT_CURR_3,
+	LIT_CURR_6,
+	LIT_CURR_9,
+	LIT_CURR_12,
+	LIT_CURR_15,
+	LIT_CURR_18,
+	LIT_CURR_21,
+	/* below setting only used for main/aux/keypad */
+	LIT_CURR_HI_0,
+	LIT_CURR_HI_6,
+	LIT_CURR_HI_12,
+	LIT_CURR_HI_18,
+	LIT_CURR_HI_24,
+	LIT_CURR_HI_30,
+	LIT_CURR_HI_36,
+	LIT_CURR_HI_42,
+};
+
+enum lit_channel {
+	LIT_MAIN = 0,
+	LIT_AUX,
+	LIT_KEY,
+	LIT_RED,
+	LIT_GREEN,
+	LIT_BLUE,
+};
+
+#endif
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ *                              level     current
+ *                              ------    -----------
+ *                                0         0 mA
+ *                                1         12 mA
+ *                                2         24 mA
+ *                                3         36 mA
+ *                                4         48 mA
+ *                                5         60 mA
+ *                                6         72 mA
+ *                                7         84 mA
+ *                           @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+				   unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ *                               dc        Duty Cycle (% On-time over Cycle Time)
+ *                              ------    ---------------------------------------
+ *                                 0        0%
+ *                                 1        6.7%
+ *                                 2        13.3%
+ *                                 3        20%
+ *                                 4        26.7%
+ *                                 5        33.3%
+ *                                 6        40%
+ *                                 7        46.7%
+ *                                 8        53.3%
+ *                                 9        60%
+ *                                10        66.7%
+ *                                11        73.3%
+ *                                12        80%
+ *                                13        86.7%
+ *                                14        93.3%
+ *                                15        100%
+ *                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+				     unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ *                               period      Cycle Time
+ *                              --------    ------------
+ *                                 0          0.01 seconds
+ *                                 1          0.1 seconds
+ *                                 2          0.5 seconds
+ *                                 3          2 seconds
+ *                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Instant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level *level,
+				       t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool *skip,
+					     t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level *level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time *ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel,
+				      bool *rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool *rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain,
+					       bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level);
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level);
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc);
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc);
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/linux/pmic_rtc.h b/include/linux/pmic_rtc.h
new file mode 100644
index 0000000..65de73d
--- /dev/null
+++ b/include/linux/pmic_rtc.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+#define         PMIC_RTC_SET_TIME                    _IOWR('p', 0xd1, int)
+#define         PMIC_RTC_GET_TIME                    _IOWR('p', 0xd2, int)
+#define         PMIC_RTC_SET_ALARM		     _IOWR('p', 0xd3, int)
+#define         PMIC_RTC_GET_ALARM		     _IOWR('p', 0xd4, int)
+#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p', 0xd5, int)
+#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p', 0xd6, int)
+#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p', 0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum {
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ * @param        sub		define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event		type of event.
+ * @param        callback	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ *		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/linux/pmic_status.h b/include/linux/pmic_status.h
new file mode 100644
index 0000000..4ec5085
--- /dev/null
+++ b/include/linux/pmic_status.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+#ifdef __KERNEL__
+#include <linux/uaccess.h>	/* copy_{from,to}_user() */
+#endif
+/*!
+ * @file arch-mxc/pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a);	\
+		if (ret != PMIC_SUCCESS)	\
+			return ret;		\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != PMIC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
-- 
1.6.5.2

