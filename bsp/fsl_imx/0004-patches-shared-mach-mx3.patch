From 1e15a0635618347498a348d63dae81bf6f34eb77 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 18 Apr 2008 15:29:20 +0800
Subject: [PATCH] patches-shared/mach-mx3

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/mach-mx3/Kconfig                  |    7 +
 arch/arm/mach-mx3/Makefile                 |    2 +-
 arch/arm/mach-mx3/clock.c                  | 1130 ++++++++++++++++
 arch/arm/mach-mx3/crm_regs.h               |  273 ++++
 arch/arm/mach-mx3/devices.c                |  619 +++++++++
 arch/arm/mach-mx3/dma.c                    |  721 ++++++++++
 arch/arm/mach-mx3/iomux.c                  |  248 ++++
 arch/arm/mach-mx3/iomux.h                  |  175 +++
 arch/arm/mach-mx3/mm.c                     |   46 +-
 arch/arm/mach-mx3/mx31_gpio.c              | 1969 ++++++++++++++++++++++++++++
 arch/arm/mach-mx3/sdma_script_code.h       |  578 ++++++++
 arch/arm/mach-mx3/sdma_script_code_pass2.h |  562 ++++++++
 arch/arm/mach-mx3/time_priv.h              |  167 +++
 13 files changed, 6495 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-mx3/clock.c
 create mode 100644 arch/arm/mach-mx3/crm_regs.h
 create mode 100644 arch/arm/mach-mx3/devices.c
 create mode 100644 arch/arm/mach-mx3/dma.c
 create mode 100644 arch/arm/mach-mx3/iomux.c
 create mode 100644 arch/arm/mach-mx3/iomux.h
 create mode 100644 arch/arm/mach-mx3/mx31_gpio.c
 create mode 100644 arch/arm/mach-mx3/sdma_script_code.h
 create mode 100644 arch/arm/mach-mx3/sdma_script_code_pass2.h
 create mode 100644 arch/arm/mach-mx3/time_priv.h

diff --git a/arch/arm/mach-mx3/Kconfig b/arch/arm/mach-mx3/Kconfig
index 5fe8606..8f19587 100644
--- a/arch/arm/mach-mx3/Kconfig
+++ b/arch/arm/mach-mx3/Kconfig
@@ -8,5 +8,12 @@ config MACH_MX31ADS
 	  Include support for MX31ADS platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
 endmenu
 
diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index cbec997..9ce7a31 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -4,5 +4,5 @@
 
 # Object file lists.
 
-obj-y			:= mm.o time.o
+obj-y			:= mm.o time.o dma.o clock.o mx31_gpio.o devices.o iomux.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
diff --git a/arch/arm/mach-mx3/clock.c b/arch/arm/mach-mx3/clock.c
new file mode 100644
index 0000000..a284da3
--- /dev/null
+++ b/arch/arm/mach-mx3/clock.c
@@ -0,0 +1,1130 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file clock.c
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <asm/mach-types.h>
+#include <asm/arch/clock.h>
+
+#include "crm_regs.h"
+#include "time_priv.h"
+
+/*
+ * Clock source bit fields for GPT
+ */
+#define CLKSRC_NO_CLK	    	0
+#define CLKSRC_IPG_CLK	    	1
+#define CLKSRC_IPG_CLK_HIGH   	2
+#define CLKSRC_EXT_PAD	    	3
+
+/*
+ * Get Clock errors
+ */
+#define ERR_CLK_NO_SUPPORT	    1
+
+/*!
+ * Spinlock to protect CRM register accesses
+ */
+static DEFINE_SPINLOCK(mxc_crm_lock);
+
+/*
+ * This function returns the clock CKIH clock input value.
+ */
+static unsigned long mxc_clock_ckih(void)
+{
+	static unsigned long g_clk_ckih = 0;
+
+	if (g_clk_ckih == 0) {
+		if (!machine_is_mx31lite() &
+			((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT) &
+			CKIH_27MHZ_BIT_SET) != 0)) {
+			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
+		} else {
+			g_clk_ckih = CKIH_CLK_FREQ;
+		}
+		pr_info("Clock input source is %ld\n", g_clk_ckih);
+	}
+
+	return g_clk_ckih;
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ * @param       pll     PLL as defined in enum plls
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll)
+{
+	unsigned long mfi, mfn, mfd, pdf, ref_clk;
+	unsigned long reg = 0, ccmr;
+	unsigned long long temp;
+	unsigned int prcs;
+
+	ccmr = __raw_readl(MXC_CCM_CCMR);
+	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
+	if (prcs == 0x1) {
+		ref_clk = CKIL_CLK_FREQ * 1024;
+	} else {
+		ref_clk = mxc_clock_ckih();
+	}
+
+	if (pll == MCUPLL) {
+		if ((ccmr & MXC_CCM_CCMR_MPE) == 0) {
+			return ref_clk;
+		}
+		if ((ccmr & MXC_CCM_CCMR_MDS) != 0) {
+			return ref_clk;
+		}
+		reg = __raw_readl(MXC_CCM_MPCTL);
+	} else if (pll == USBPLL) {
+		reg = __raw_readl(MXC_CCM_UPCTL);
+	} else if (pll == SERIALPLL) {
+		reg = __raw_readl(MXC_CCM_SRPCTL);
+	} else {
+		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
+		BUG();		/* oops */
+	}
+	pdf = (reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET;
+	mfd = (reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET;
+	mfi = (reg & MXC_CCM_PCTL_MFI_MASK) >> MXC_CCM_PCTL_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = reg & MXC_CCM_PCTL_MFN_MASK;
+
+	if (mfn < 0x200) {
+		temp = (unsigned long long)2 *ref_clk * mfn;
+		do_div(temp, mfd + 1);
+		temp = (unsigned long long)2 *ref_clk * mfi + temp;
+		do_div(temp, pdf + 1);
+	} else {
+		temp = (unsigned long long)2 *ref_clk * (0x400 - mfn);
+		do_div(temp, mfd + 1);
+		temp = (unsigned long long)2 *ref_clk * mfi - temp;
+		do_div(temp, pdf + 1);
+	}
+
+	return (unsigned long)temp;
+}
+
+/*!
+ * This function returns the mcu main clock frequency
+ *
+ * @return      mcu main clock value in Hz.
+ */
+static unsigned long mxc_mcu_main_clock(void)
+{
+	unsigned long pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	unsigned long dfsup1 = pmcr0 & MXC_CCM_PMCR0_DFSUP1;
+
+	if (dfsup1 == 0) {
+		return mxc_pll_clock(SERIALPLL);
+	}
+	return mxc_pll_clock(MCUPLL);
+}
+
+/*!
+ * This function returns the main clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk)
+{
+	unsigned long pll, ret_val = 0, hclk, gpt_ctrl;
+	unsigned long mcu_pdf, max_pdf, ipg_pdf, nfc_pdf, hsp_pdf, csi_pdf,
+	    usb_pdf;
+	unsigned long ssi1_prepdf, ssi1_pdf, per_pdf;
+	unsigned long ssi2_prepdf, ssi2_pdf, firi_prepdf, firi_pdf, usb_prepdf;
+	unsigned long msti_pdf, epit_offset = 0, pwm_ctrl, epit_ctrl;
+	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
+	unsigned long pdr0 = __raw_readl(MXC_CCM_PDR0);
+	unsigned long pdr1 = __raw_readl(MXC_CCM_PDR1);
+	unsigned long pdr2 = __raw_readl(MXC_CCM_PDR2);
+	int clksrc;
+
+	max_pdf =
+	    (pdr0 & MXC_CCM_PDR0_MAX_PODF_MASK) >> MXC_CCM_PDR0_MAX_PODF_OFFSET;
+	ipg_pdf =
+	    (pdr0 & MXC_CCM_PDR0_IPG_PODF_MASK) >> MXC_CCM_PDR0_IPG_PODF_OFFSET;
+	per_pdf =
+	    (pdr0 & MXC_CCM_PDR0_PER_PODF_MASK) >> MXC_CCM_PDR0_PER_PODF_OFFSET;
+
+	switch (clk) {
+	case CKIL_CLK:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	case CKIH_CLK:
+		ret_val = mxc_clock_ckih();
+		break;
+	case CPU_CLK:
+		pll = mxc_mcu_main_clock();
+		mcu_pdf = pdr0 & MXC_CCM_PDR0_MCU_PODF_MASK;
+		ret_val = pll / (mcu_pdf + 1);
+		break;
+	case AHB_CLK:
+		pll = mxc_mcu_main_clock();
+		ret_val = pll / (max_pdf + 1);
+		break;
+	case CSPI1_CLK:
+	case CSPI2_CLK:
+	case CSPI3_CLK:
+	case IPG_CLK:
+		pll = mxc_mcu_main_clock();
+		hclk = pll / (max_pdf + 1);
+		ret_val = hclk / (ipg_pdf + 1);
+		break;
+	case GPT_CLK:
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_high - same as ipg_clk
+		 * 3. ckil
+		 */
+		gpt_ctrl = __raw_readl(MXC_GPT_GPTCR);
+		clksrc = (gpt_ctrl & GPTCR_CLKSRC_MASK) >> (GPTCR_CLKSRC_SHIFT);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			hclk = pll / (max_pdf + 1);
+			ret_val = hclk / (ipg_pdf + 1);
+			break;
+		case CLKSRC_NO_CLK:
+		case CLKSRC_EXT_PAD:
+			printk(KERN_ERR
+			       "Warning: GPT clock source not supported !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case PWM_CLK:
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk_high - from perclk
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_32k - CKIL
+		 */
+		pwm_ctrl = __raw_readl(MXC_PWM_PWMCTRL);
+		clksrc = (pwm_ctrl & (~PWM_CTRL_MASK)) >> (PWM_CTRL_OFFSET);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+			break;
+		case CLKSRC_NO_CLK:
+			printk(KERN_ERR
+			       "Warning: PWM clock source not is off !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case EPIT2_CLK:
+		epit_offset = 0x4000;
+	case EPIT1_CLK:
+		epit_ctrl = __raw_readl(MXC_EPIT_EPITCR + epit_offset);
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_high - same as ipg_clk
+		 * 3. ipg_clk_32k - CKIL
+		 */
+		clksrc =
+		    (epit_ctrl & EPITCR_CLKSRC_MASK) >> (EPITCR_CLKSRC_SHIFT);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+			break;
+		case CLKSRC_NO_CLK:
+			printk(KERN_ERR
+			       "Warning: PWM clock source not is off !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case NFC_CLK:
+		pll = mxc_mcu_main_clock();
+		hclk = pll / (max_pdf + 1);
+		nfc_pdf = (pdr0 & MXC_CCM_PDR0_NFC_PODF_MASK) >>
+		    MXC_CCM_PDR0_NFC_PODF_OFFSET;
+		ret_val = hclk / (nfc_pdf + 1);
+		break;
+	case IPU_CLK:
+		pll = mxc_mcu_main_clock();
+		hsp_pdf = (pdr0 & MXC_CCM_PDR0_HSP_PODF_MASK) >>
+		    MXC_CCM_PDR0_HSP_PODF_OFFSET;
+		ret_val = pll / (hsp_pdf + 1);
+		break;
+	case USB_CLK:
+		pll = mxc_pll_clock(USBPLL);
+		usb_pdf = (pdr1 & MXC_CCM_PDR1_USB_PODF_MASK) >>
+		    MXC_CCM_PDR1_USB_PODF_OFFSET;
+		usb_prepdf = (pdr1 & MXC_CCM_PDR1_USB_PRDF_MASK) >>
+		    MXC_CCM_PDR1_USB_PRDF_OFFSET;
+		ret_val = pll / ((usb_prepdf + 1) * (usb_pdf + 1));
+		break;
+	case CSI_BAUD:
+		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
+			pll = mxc_pll_clock(USBPLL);
+		} else {
+			pll = mxc_pll_clock(SERIALPLL);
+		}
+		csi_pdf = (pdr0 & MXC_CCM_PDR0_CSI_PODF_MASK) >>
+		    MXC_CCM_PDR0_CSI_PODF_OFFSET;
+		ret_val = pll / (csi_pdf + 1);
+		break;
+	case UART1_BAUD:
+	case UART2_BAUD:
+	case UART3_BAUD:
+	case UART4_BAUD:
+	case UART5_BAUD:
+	case I2C_CLK:
+	case I2C2_CLK:
+	case I2C3_CLK:
+	case OWIRE_CLK:
+	case SDHC1_CLK:
+	case SDHC2_CLK:
+		if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+			pll = mxc_pll_clock(USBPLL);
+			ret_val = pll / (per_pdf + 1);
+		} else {
+			pll = mxc_mcu_main_clock();
+			hclk = pll / (max_pdf + 1);
+			ret_val = hclk / (ipg_pdf + 1);
+
+		}
+		break;
+	case SSI1_BAUD:
+		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI1S_MASK) >>
+				    MXC_CCM_CCMR_SSI1S_OFFSET);
+		ssi1_pdf = (pdr1 & MXC_CCM_PDR1_SSI1_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI1_PODF_OFFSET;
+		ssi1_prepdf = (pdr1 & MXC_CCM_PDR1_SSI1_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET;
+		ret_val = pll / ((ssi1_prepdf + 1) * (ssi1_pdf + 1));
+		break;
+	case SSI2_BAUD:
+		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI2S_MASK) >>
+				    MXC_CCM_CCMR_SSI2S_OFFSET);
+		ssi2_pdf = (pdr1 & MXC_CCM_PDR1_SSI2_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI2_PODF_OFFSET;
+		ssi2_prepdf = (pdr1 & MXC_CCM_PDR1_SSI2_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET;
+		ret_val = pll / ((ssi2_prepdf + 1) * (ssi2_pdf + 1));
+		break;
+	case FIRI_BAUD:
+		pll = mxc_get_clocks_parent(FIRI_BAUD);
+		firi_pdf = (pdr1 & MXC_CCM_PDR1_FIRI_PODF_MASK) >>
+		    MXC_CCM_PDR1_FIRI_PODF_OFFSET;
+		firi_prepdf = (pdr1 & MXC_CCM_PDR1_FIRI_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;
+		ret_val = pll / ((firi_prepdf + 1) * (firi_pdf + 1));
+		break;
+	case MBX_CLK:
+		pll = mxc_mcu_main_clock();
+		ret_val = pll / (max_pdf + 1);
+		ret_val = ret_val / 2;
+		break;
+	case MSTICK1_BAUD:
+		pll = mxc_pll_clock(USBPLL);
+		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST1_PDF_MASK) >>
+		    MXC_CCM_PDR2_MST1_PDF_OFFSET;
+		ret_val = pll / (msti_pdf + 1);
+		break;
+	case MSTICK2_BAUD:
+		pll = mxc_pll_clock(USBPLL);
+		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST2_PDF_MASK) >>
+		    MXC_CCM_PDR2_MST2_PDF_OFFSET;
+		ret_val = pll / (msti_pdf + 1);
+		break;
+	default:
+		ret_val = 66516666;
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function returns the parent clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+{
+	unsigned long ret_val = 0;
+	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
+
+	switch (clk) {
+	case CSI_BAUD:
+		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
+			ret_val = mxc_pll_clock(USBPLL);
+		} else {
+			ret_val = mxc_pll_clock(SERIALPLL);
+		}
+		break;
+	case FIRI_BAUD:
+		switch ((ccmr & MXC_CCM_CCMR_FIRS_MASK) >>
+			MXC_CCM_CCMR_FIRS_OFFSET) {
+		case 0:
+			ret_val = mxc_pll_clock(MCUPLL);
+			break;
+		case 1:
+			ret_val = mxc_pll_clock(USBPLL);
+			break;
+		case 2:
+			ret_val = mxc_pll_clock(SERIALPLL);
+			break;
+		case 3:
+		default:
+			printk(KERN_ERR
+			       "FIRI clock source select is set to RESERVED\n");
+		}
+		break;
+	default:
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function calculates the pre and post divider values for a clock
+ *
+ * @param div  divider value passed in
+ * @param div1 returns the pre-divider value
+ * @param div2 returns the post-divider value
+ * @param lim1 limit of divider 1
+ * @param lim2 limit of divider 2
+ */
+void mxc_clk_getdivs(unsigned int div, unsigned int *div1,
+		     unsigned int *div2, int lim1, int lim2)
+{
+	int i;
+
+	if (div <= lim1) {
+		*div1 = div;
+		*div2 = 1;
+		return;
+	}
+	if (div <= lim2) {
+		*div1 = 1;
+		*div2 = div;
+		return;
+	}
+	for (i = 2; i < (lim1 + 1); i++) {
+		if ((div % i) == 0) {
+			*div1 = i;
+			*div2 = div / i;
+			return;
+		}
+	}
+
+	*div1 = 1;
+	*div2 = lim2;
+	return;
+}
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+{
+	unsigned long ccmr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	ccmr = __raw_readl(MXC_CCM_CCMR);
+
+	switch (clk) {
+	case CPU_CLK:
+		if (pll_num == MCUPLL) {
+			ccmr &= ~MXC_CCM_CCMR_MDS;
+		} else {
+			ccmr |= MXC_CCM_CCMR_MDS;
+		}
+		break;
+	case CSI_BAUD:
+		if (pll_num == USBPLL) {
+			ccmr &= ~MXC_CCM_CCMR_CSCS;
+		} else {
+			ccmr |= MXC_CCM_CCMR_CSCS;
+		}
+		break;
+	case SSI1_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI1S_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_SSI1S_OFFSET);
+		break;
+	case SSI2_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI2S_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_SSI2S_OFFSET);
+		break;
+	case FIRI_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_FIRS_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_FIRS_OFFSET);
+		break;
+	default:
+		printk(KERN_ERR
+		       "This clock does not have ability to choose its clock source\n");
+		break;
+	}
+	__raw_writel(ccmr, MXC_CCM_CCMR);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function sets the divider value for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI & CSI, pass
+ *            in 2 times the expected division value to account for FP vals on certain
+ *            platforms)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+{
+	unsigned long reg;
+	unsigned long flags;
+	unsigned int d = 0, div1 = 0, div2 = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case AHB_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_MAX_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case CPU_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_MCU_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case IPG_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_IPG_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_NFC_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR0_CSI_PRDF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR0_CSI_PRDF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR0_CSI_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_HSP_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case UART1_BAUD:
+	case UART2_BAUD:
+	case UART3_BAUD:
+	case UART4_BAUD:
+	case UART5_BAUD:
+	case I2C_CLK:
+	case I2C2_CLK:
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_PER_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_PER_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_SSI1_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_SSI1_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_SSI1_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_SSI2_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_SSI2_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_SSI2_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		mxc_clk_getdivs(div, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_FIRI_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_FIRI_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		mxc_clk_getdivs(d, &div1, &div2, 4, 8);
+		reg = (reg & (~MXC_CCM_PDR1_USB_PRDF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_USB_PRDF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_USB_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_USB_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case UART1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_UART1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_UART2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART3;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART4;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART5;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case I2C_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SSI1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_SSI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_USBOTG;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_FIRI;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_CSI;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_IPU;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_KPP;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case SDHC1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SD_MMC1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDHC2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SD_MMC2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case CSPI1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_CSPI1;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_CSPI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_CSPI3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_ATA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MBX_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_GACC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_RTIC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RNG_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_RNG;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDMA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SDMA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MPEG4_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_HANTRO;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_MEMSTICK1;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_MEMSTICK2;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to disable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case UART1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_UART1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_UART2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART3;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART4;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART5;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case I2C_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SSI1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_SSI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_USBOTG;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_FIRI;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_CSI;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_IPU;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_KPP;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case SDHC1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SD_MMC1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDHC2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SD_MMC2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case CSPI1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_CSPI1;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_CSPI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_CSPI3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_ATA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MBX_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_GACC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_RTIC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RNG_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_RNG;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDMA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SDMA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MPEG4_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_HANTRO;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_MEMSTICK1;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_MEMSTICK2;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to read the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(reg_offset);
+	return reg;
+}
+
+/*!
+ * This function is called to modify the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	reg = __raw_readl(reg_offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, reg_offset);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll_num  the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn)
+{
+	unsigned long ccmr;
+	unsigned long flags;
+	unsigned long new_pll = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	if (pll_num == MCUPLL) {
+		/* Swap to reference clock and disable PLL */
+		ccmr = __raw_readl(MXC_CCM_CCMR);
+		ccmr |= MXC_CCM_CCMR_MDS;
+		ccmr &= ~MXC_CCM_CCMR_MPE;
+		__raw_writel(ccmr, MXC_CCM_CCMR);
+	}
+
+	/* Change the Pll value */
+	new_pll = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pdf << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (pll_num == MCUPLL) {
+		__raw_writel(new_pll, MXC_CCM_MPCTL);
+	} else if (pll_num == USBPLL) {
+		__raw_writel(new_pll, MXC_CCM_UPCTL);
+	} else if (pll_num == SERIALPLL) {
+		__raw_writel(new_pll, MXC_CCM_SRPCTL);
+	}
+
+	if (pll_num == MCUPLL) {
+		/* Swap to the new value */
+		ccmr = __raw_readl(MXC_CCM_CCMR);
+		ccmr |= MXC_CCM_CCMR_MPE;
+		ccmr &= ~MXC_CCM_CCMR_MDS;
+		__raw_writel(ccmr, MXC_CCM_CCMR);
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * Configure clock output on CKO pin
+ *
+ * @param       output     as defined in enum mxc_clk_out
+ * @param       clk        as defined in enum mxc_clocks
+ * @param       div        clock output divider value. The possible values
+ *                               for this are 1, 2, 4, 8 and 16
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
+{
+	unsigned long flags;
+	int div_value = 0;
+	u32 reg;
+
+	switch (div) {
+	case 1:
+		div_value = 0;
+		break;
+	case 2:
+		div_value = 1;
+		break;
+	case 4:
+		div_value = 2;
+		break;
+	case 8:
+		div_value = 3;
+		break;
+	case 16:
+		div_value = 4;
+		break;
+	default:
+		/* return error */
+		return;
+	}
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	reg = __raw_readl(MXC_CCM_COSR);
+
+	reg = (reg & ~MXC_CCM_COSR_CLKOUTDIV_MASK) |
+	    (div_value << MXC_CCM_COSR_CLKOUTDIV_OFFSET);
+
+	switch (clk) {
+	case CPU_CLK:
+		/* To select AP clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000006;
+		break;
+	case AHB_CLK:
+		/* To select AHB clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000005;
+		break;
+	case IPG_CLK:
+		/* To select IP clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000001;
+		break;
+	default:
+		goto ret;
+	}
+
+	__raw_writel(reg, MXC_CCM_COSR);
+
+      ret:
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+EXPORT_SYMBOL(mxc_pll_set);
+EXPORT_SYMBOL(mxc_pll_clock);
+EXPORT_SYMBOL(mxc_get_clocks);
+EXPORT_SYMBOL(mxc_get_clocks_parent);
+EXPORT_SYMBOL(mxc_set_clocks_pll);
+EXPORT_SYMBOL(mxc_set_clocks_div);
+EXPORT_SYMBOL(mxc_clks_disable);
+EXPORT_SYMBOL(mxc_clks_enable);
+EXPORT_SYMBOL(mxc_ccm_get_reg);
+EXPORT_SYMBOL(mxc_ccm_modify_reg);
+EXPORT_SYMBOL(mxc_set_clock_output);
diff --git a/arch/arm/mach-mx3/crm_regs.h b/arch/arm/mach-mx3/crm_regs.h
new file mode 100644
index 0000000..07fd0d4
--- /dev/null
+++ b/arch/arm/mach-mx3/crm_regs.h
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+
+#define CKIH_CLK_FREQ           26000000
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           32768
+#define CKIH_27MHZ_BIT_SET      (1 << 4)
+
+#define MXC_CCM_BASE		IO_ADDRESS(CCM_BASE_ADDR)
+
+/* Register addresses */
+#define MXC_CCM_CCMR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_PDR0		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_PDR1		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_RCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_MPCTL		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_UPCTL		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_SRPCTL		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_COSR		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CGR0		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CGR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CGR2		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_WIMR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_LDC		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_DCVR0		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_DCVR1		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_DCVR2		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_DCVR3		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_LTR0		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_LTR1		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_LTR2		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTR3		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTBR0		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_LTBR1		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_PMCR0		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_PMCR1		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
+
+/* Register bit definitions */
+#define MXC_CCM_CCMR_WBEN                       (1 << 27)
+#define MXC_CCM_CCMR_CSCS                       (1 << 25)
+#define MXC_CCM_CCMR_PERCS                      (1 << 24)
+#define MXC_CCM_CCMR_SSI1S_OFFSET               18
+#define MXC_CCM_CCMR_SSI1S_MASK                 (0x3 << 18)
+#define MXC_CCM_CCMR_SSI2S_OFFSET               21
+#define MXC_CCM_CCMR_SSI2S_MASK                 (0x3 << 21)
+#define MXC_CCM_CCMR_LPM_OFFSET                 14
+#define MXC_CCM_CCMR_LPM_MASK                   (0x3 << 14)
+#define MXC_CCM_CCMR_FIRS_OFFSET                11
+#define MXC_CCM_CCMR_FIRS_MASK                  (0x3 << 11)
+#define MXC_CCM_CCMR_MDS                        (1 << 7)
+#define MXC_CCM_CCMR_SBYCS                      (1 << 4)
+#define MXC_CCM_CCMR_MPE                        (1 << 3)
+#define MXC_CCM_CCMR_PRCS_OFFSET                1
+#define MXC_CCM_CCMR_PRCS_MASK                  (0x3 << 1)
+
+#define MXC_CCM_PDR0_CSI_PODF_OFFSET            26
+#define MXC_CCM_PDR0_CSI_PODF_MASK              (0x3F << 26)
+#define MXC_CCM_PDR0_CSI_PRDF_OFFSET            23
+#define MXC_CCM_PDR0_CSI_PRDF_MASK              (0x7 << 23)
+#define MXC_CCM_PDR0_PER_PODF_OFFSET            16
+#define MXC_CCM_PDR0_PER_PODF_MASK              (0x1F << 16)
+#define MXC_CCM_PDR0_HSP_PODF_OFFSET            11
+#define MXC_CCM_PDR0_HSP_PODF_MASK              (0x7 << 11)
+#define MXC_CCM_PDR0_NFC_PODF_OFFSET            8
+#define MXC_CCM_PDR0_NFC_PODF_MASK              (0x7 << 8)
+#define MXC_CCM_PDR0_IPG_PODF_OFFSET            6
+#define MXC_CCM_PDR0_IPG_PODF_MASK              (0x3 << 6)
+#define MXC_CCM_PDR0_MAX_PODF_OFFSET            3
+#define MXC_CCM_PDR0_MAX_PODF_MASK              (0x7 << 3)
+#define MXC_CCM_PDR0_MCU_PODF_OFFSET            0
+#define MXC_CCM_PDR0_MCU_PODF_MASK              0x7
+
+#define MXC_CCM_PDR1_USB_PRDF_OFFSET            30
+#define MXC_CCM_PDR1_USB_PRDF_MASK              (0x3 << 30)
+#define MXC_CCM_PDR1_USB_PODF_OFFSET            27
+#define MXC_CCM_PDR1_USB_PODF_MASK              (0x7 << 27)
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET       24
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_MASK         (0x7 << 24)
+#define MXC_CCM_PDR1_FIRI_PODF_OFFSET           18
+#define MXC_CCM_PDR1_FIRI_PODF_MASK             (0x3F << 18)
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET       15
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_MASK         (0x7 << 15)
+#define MXC_CCM_PDR1_SSI2_PODF_OFFSET           9
+#define MXC_CCM_PDR1_SSI2_PODF_MASK             (0x3F << 9)
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET       6
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_MASK         (0x7 << 6)
+#define MXC_CCM_PDR1_SSI1_PODF_OFFSET           0
+#define MXC_CCM_PDR1_SSI1_PODF_MASK             0x3F
+
+/* Bit definitions for RCSR */
+#define MXC_CCM_RCSR_NF16B			0x80000000
+
+/* Bit definitions for both MCU, USB and SR PLL control registers */
+#define MXC_CCM_PCTL_BRM                        0x80000000
+#define MXC_CCM_PCTL_PD_OFFSET                  26
+#define MXC_CCM_PCTL_PD_MASK                    (0xF << 26)
+#define MXC_CCM_PCTL_MFD_OFFSET                 16
+#define MXC_CCM_PCTL_MFD_MASK                   (0x3FF << 16)
+#define MXC_CCM_PCTL_MFI_OFFSET                 10
+#define MXC_CCM_PCTL_MFI_MASK                   (0xF << 10)
+#define MXC_CCM_PCTL_MFN_OFFSET                 0
+#define MXC_CCM_PCTL_MFN_MASK                   0x3FF
+
+#define MXC_CCM_CGR0_SD_MMC1                    0x3
+#define MXC_CCM_CGR0_SD_MMC2                    (0x3 << 2)
+#define MXC_CCM_CGR0_GPT                        (0x3 << 4)
+#define MXC_CCM_CGR0_EPIT1                      (0x3 << 6)
+#define MXC_CCM_CGR0_EPIT2                      (0x3 << 8)
+#define MXC_CCM_CGR0_IIM                        (0x3 << 10)
+#define MXC_CCM_CGR0_ATA                        (0x3 << 12)
+#define MXC_CCM_CGR0_SDMA                       (0x3 << 14)
+#define MXC_CCM_CGR0_CSPI3                      (0x3 << 16)
+#define MXC_CCM_CGR0_RNG                         (0x3 << 18)
+#define MXC_CCM_CGR0_UART1                      (0x3 << 20)
+#define MXC_CCM_CGR0_UART2                      (0x3 << 22)
+#define MXC_CCM_CGR0_SSI1                       (0x3 << 24)
+#define MXC_CCM_CGR0_I2C1                       (0x3 << 26)
+#define MXC_CCM_CGR0_I2C2                       (0x3 << 28)
+#define MXC_CCM_CGR0_I2C3                       (0x3 << 30)
+
+#define MXC_CCM_CGR1_HANTRO                     0x3
+#define MXC_CCM_CGR1_MEMSTICK1                  (0x3 << 2)
+#define MXC_CCM_CGR1_MEMSTICK2                  (0x3 << 4)
+#define MXC_CCM_CGR1_CSI                        (0x3 << 6)
+#define MXC_CCM_CGR1_RTC                        (0x3 << 8)
+#define MXC_CCM_CGR1_WDOG                       (0x3 << 10)
+#define MXC_CCM_CGR1_PWM                        (0x3 << 12)
+#define MXC_CCM_CGR1_SIM                        (0x3 << 14)
+#define MXC_CCM_CGR1_ECT                        (0x3 << 16)
+#define MXC_CCM_CGR1_USBOTG                     (0x3 << 18)
+#define MXC_CCM_CGR1_KPP                        (0x3 << 20)
+#define MXC_CCM_CGR1_IPU                        (0x3 << 22)
+#define MXC_CCM_CGR1_UART3                      (0x3 << 24)
+#define MXC_CCM_CGR1_UART4                      (0x3 << 26)
+#define MXC_CCM_CGR1_UART5                      (0x3 << 28)
+#define MXC_CCM_CGR1_OWIRE                      (0x3 << 30)
+
+#define MXC_CCM_CGR2_SSI2                       0x3
+#define MXC_CCM_CGR2_CSPI1                      (0x3 << 2)
+#define MXC_CCM_CGR2_CSPI2                      (0x3 << 4)
+#define MXC_CCM_CGR2_GACC                       (0x3 << 6)
+#define MXC_CCM_CGR2_EMI                        (0x3 << 8)
+#define MXC_CCM_CGR2_RTIC                       (0x3 << 10)
+#define MXC_CCM_CGR2_FIRI                       (0x3 << 12)
+#define MXC_CCM_CGR2_IPMUX1                     (0x3 << 14)
+#define MXC_CCM_CGR2_IPMUX2                     (0x3 << 16)
+
+/*
+ * LTR0 register offsets
+ */
+#define MXC_CCM_LTR0_DIV3CK_OFFSET              1
+#define MXC_CCM_LTR0_DIV3CK_MASK                (0x3 << 1)
+#define MXC_CCM_LTR0_DNTHR_OFFSET               16
+#define MXC_CCM_LTR0_DNTHR_MASK                 (0x3F << 16)
+#define MXC_CCM_LTR0_UPTHR_OFFSET               22
+#define MXC_CCM_LTR0_UPTHR_MASK                 (0x3F << 22)
+
+/*
+ * LTR1 register offsets
+ */
+#define MXC_CCM_LTR1_PNCTHR_OFFSET              0
+#define MXC_CCM_LTR1_PNCTHR_MASK                0x3F
+#define MXC_CCM_LTR1_UPCNT_OFFSET               6
+#define MXC_CCM_LTR1_UPCNT_MASK                 (0xFF << 6)
+#define MXC_CCM_LTR1_DNCNT_OFFSET               14
+#define MXC_CCM_LTR1_DNCNT_MASK                 (0xFF << 14)
+#define MXC_CCM_LTR1_LTBRSR                     0x400000
+#define MXC_CCM_LTR1_LTBRSH                     0x800000
+
+/*
+ * LTR2 bit definitions. x ranges from 0 for WSW9 to 6 for WSW15
+ */
+#define MXC_CCM_LTR2_WSW_OFFSET(x)              (11 + (x) * 3)
+#define MXC_CCM_LTR2_WSW_MASK(x)                (0x7 << MXC_CCM_LTR2_WSW_OFFSET((x)))
+#define MXC_CCM_LTR2_EMAC_OFFSET                0
+#define MXC_CCM_LTR2_EMAC_MASK                  0x1FF
+
+/*
+ * LTR3 bit definitions. x ranges from 0 for WSW0 to 8 for WSW8
+ */
+#define MXC_CCM_LTR3_WSW_OFFSET(x)              (5 + (x) * 3)
+#define MXC_CCM_LTR3_WSW_MASK(x)                (0x7 << MXC_CCM_LTR3_WSW_OFFSET((x)))
+
+#define MXC_CCM_PMCR0_DFSUP1                    0x80000000
+#define MXC_CCM_PMCR0_DFSUP0                    0x40000000
+#define MXC_CCM_PMCR0_DVSUP_0                   (0x0 << 28)
+#define MXC_CCM_PMCR0_DVSUP_1                   (0x1 << 28)
+#define MXC_CCM_PMCR0_DVSUP_2                   (0x2 << 28)
+#define MXC_CCM_PMCR0_DVSUP_3                   (0x3 << 28)
+#define MXC_CCM_PMCR0_DVSUP_OFFSET              28
+#define MXC_CCM_PMCR0_DVSUP_MASK                (0x3 << 28)
+#define MXC_CCM_PMCR0_UDSC                      0x08000000
+#define MXC_CCM_PMCR0_VSCNT_1                   (0x0 << 24)
+#define MXC_CCM_PMCR0_VSCNT_2                   (0x1 << 24)
+#define MXC_CCM_PMCR0_VSCNT_3                   (0x2 << 24)
+#define MXC_CCM_PMCR0_VSCNT_4                   (0x3 << 24)
+#define MXC_CCM_PMCR0_VSCNT_5                   (0x4 << 24)
+#define MXC_CCM_PMCR0_VSCNT_6                   (0x5 << 24)
+#define MXC_CCM_PMCR0_VSCNT_7                   (0x6 << 24)
+#define MXC_CCM_PMCR0_VSCNT_8                   (0x7 << 24)
+#define MXC_CCM_PMCR0_VSCNT_OFFSET              24
+#define MXC_CCM_PMCR0_VSCNT_MASK                (0x7 << 24)
+#define MXC_CCM_PMCR0_DVFEV                     0x00800000
+#define MXC_CCM_PMCR0_DVFIS                     0x00400000
+#define MXC_CCM_PMCR0_LBMI                      0x00200000
+#define MXC_CCM_PMCR0_LBFL                      0x00100000
+#define MXC_CCM_PMCR0_LBCF_4                    (0x0 << 18)
+#define MXC_CCM_PMCR0_LBCF_8                    (0x1 << 18)
+#define MXC_CCM_PMCR0_LBCF_12                   (0x2 << 18)
+#define MXC_CCM_PMCR0_LBCF_16                   (0x3 << 18)
+#define MXC_CCM_PMCR0_LBCF_OFFSET               18
+#define MXC_CCM_PMCR0_LBCF_MASK                 (0x3 << 18)
+#define MXC_CCM_PMCR0_PTVIS                     0x00020000
+#define MXC_CCM_PMCR0_UPDTEN                    0x00010000
+#define MXC_CCM_PMCR0_FSVAIM                    0x00008000
+#define MXC_CCM_PMCR0_FSVAI_OFFSET              13
+#define MXC_CCM_PMCR0_FSVAI_MASK                (0x3 << 13)
+#define MXC_CCM_PMCR0_DPVCR                     0x00001000
+#define MXC_CCM_PMCR0_DPVV                      0x00000800
+#define MXC_CCM_PMCR0_WFIM                      0x00000400
+#define MXC_CCM_PMCR0_DRCE3                     0x00000200
+#define MXC_CCM_PMCR0_DRCE2                     0x00000100
+#define MXC_CCM_PMCR0_DRCE1                     0x00000080
+#define MXC_CCM_PMCR0_DRCE0                     0x00000040
+#define MXC_CCM_PMCR0_DCR                       0x00000020
+#define MXC_CCM_PMCR0_DVFEN                     0x00000010
+#define MXC_CCM_PMCR0_PTVAIM                    0x00000008
+#define MXC_CCM_PMCR0_PTVAI_OFFSET              1
+#define MXC_CCM_PMCR0_PTVAI_MASK                (0x3 << 1)
+#define MXC_CCM_PMCR0_DPTEN                     0x00000001
+
+#define MXC_CCM_PMCR1_DVGP_OFFSET               0
+#define MXC_CCM_PMCR1_DVGP_MASK                 (0xF)
+
+#define MXC_CCM_DCVR_ULV_MASK                   (0x3FF << 22)
+#define MXC_CCM_DCVR_ULV_OFFSET                 22
+#define MXC_CCM_DCVR_LLV_MASK                   (0x3FF << 12)
+#define MXC_CCM_DCVR_LLV_OFFSET                 12
+#define MXC_CCM_DCVR_ELV_MASK                   (0x3FF << 2)
+#define MXC_CCM_DCVR_ELV_OFFSET                 2
+
+#define MXC_CCM_PDR2_MST2_PDF_MASK              (0x3F << 7)
+#define MXC_CCM_PDR2_MST2_PDF_OFFSET            7
+#define MXC_CCM_PDR2_MST1_PDF_MASK              0x3F
+#define MXC_CCM_PDR2_MST1_PDF_OFFSET            0
+
+#define MXC_CCM_COSR_CLKOSEL_MASK               0x0F
+#define MXC_CCM_COSR_CLKOSEL_OFFSET             0
+#define MXC_CCM_COSR_CLKOUTDIV_MASK             (0x07 << 6)
+#define MXC_CCM_COSR_CLKOUTDIV_OFFSET           6
+#define MXC_CCM_COSR_CLKOEN                     (1 << 9)
+
+/*
+ * PMCR0 register offsets
+ */
+#define MXC_CCM_PMCR0_LBFL_OFFSET   20
+#define MXC_CCM_PMCR0_DFSUP0_OFFSET 30
+#define MXC_CCM_PMCR0_DFSUP1_OFFSET 31
+
+#endif				/* __ARCH_ARM_MACH_MX3_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
new file mode 100644
index 0000000..d52f3eb
--- /dev/null
+++ b/arch/arm/mach-mx3/devices.c
@@ -0,0 +1,619 @@
+/*
+ * Author: MontaVista Software, Inc.
+ *       <source@mvista.com>
+ *
+ * Based on the OMAP devices.c
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/arch/clock.h>
+
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+#include <asm/arch/sdma.h>
+#include "sdma_script_code.h"
+#include "sdma_script_code_pass2.h"
+
+#if 0
+int board_device_enable(u32 device_id);
+int board_device_disable(u32 device_id);
+
+int mxc_device_enable(u32 device_id)
+{
+	int ret = 0;
+
+	switch (device_id) {
+	default:
+		ret = board_device_enable(device_id);
+	}
+
+	return ret;
+}
+
+int mxc_device_disable(u32 device_id)
+{
+	int ret = 0;
+
+	switch (device_id) {
+	default:
+		ret = board_device_disable(device_id);
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(mxc_device_enable);
+EXPORT_SYMBOL(mxc_device_disable);
+#endif
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
+{
+	if (system_rev == CHIP_REV_1_0) {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = -1;
+	} else {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = ap_2_bp_ADDR_2;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = bp_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_2;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR_2;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR_2;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = firi_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = per_2_firi_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR_2;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr =
+		    uartsh_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR_2;
+	}
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_RTC)
+
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG_BASE_ADDR,
+	 .end = WDOG_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_4K,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static void mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_FIR) || defined(CONFIG_MXC_FIR_MODULE)
+/*!
+ * Resource definition for the FIR
+ */
+static struct resource mxcir_resources[] = {
+	[0] = {
+	       .start = UART2_BASE_ADDR,
+	       .end = UART2_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_UART2,
+	       .end = INT_UART2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = FIRI_BASE_ADDR,
+	       .end = FIRI_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[3] = {
+	       .start = INT_FIRI,
+	       .end = INT_FIRI,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[4] = {
+	       .start = INT_UART2,
+	       .end = INT_UART2,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+
+static struct mxc_ir_platform_data ir_data;
+
+/*! Device Definition for MXC FIR */
+static struct platform_device mxcir_device = {
+	.name = "mxcir",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &ir_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcir_resources),
+	.resource = mxcir_resources,
+};
+
+static inline void mxc_init_ir(void)
+{
+	ir_data.uart_ir_mux = 1;
+	(void)platform_device_register(&mxcir_device);
+}
+#else
+static inline void mxc_init_ir(void)
+{
+}
+#endif
+
+/* MMC device data */
+
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+
+static struct mxc_mmc_platform_data mmc_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC1_BASE_ADDR,
+	       .end = MMC_SDHC1_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_MMC_SDHC1,
+	       .end = INT_MMC_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO1_CARD_IRQ,
+	       .end = MXC_SDIO1_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC2_BASE_ADDR,
+	       .end = MMC_SDHC2_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_MMC_SDHC2,
+	       .end = INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO2_CARD_IRQ,
+	       .end = MXC_SDIO2_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxcmci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxcmci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+static inline void mxc_init_mmc(void)
+{
+	int cd_irq;
+
+	cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxcsdhc1_device.resource[2].start = cd_irq;
+		mxcsdhc1_device.resource[2].end = cd_irq;
+	}
+	cd_irq = 0;
+	/* set cd_irq = 0 here to disable sdhc2 */
+	/* cd_irq = sdhc_init_card_det(1); */
+	if (cd_irq) {
+		mxcsdhc2_device.resource[2].start = cd_irq;
+		mxcsdhc2_device.resource[2].end = cd_irq;
+	}
+
+	spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
+	(void)platform_device_register(&mxcsdhc1_device);
+	if (!machine_is_mx31lite()) {
+		spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
+		(void)platform_device_register(&mxcsdhc2_device);
+	}
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI1,
+	       .end = INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI1_CLK,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI2,
+	       .end = INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI2_CLK,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI3,
+	       .end = INT_CSPI3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI3_CLK,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+static inline void mxc_init_spi(void)
+{
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk("Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk("Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk("Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
+	 .irq = MXC_INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
+	 .irq = MXC_INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
+	 .irq = MXC_INT_GPIO3,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	 },
+};
+
+#if defined(CONFIG_PCMCIA_MX31) || defined(CONFIG_PCMCIA_MX31_MODULE)
+
+static struct platform_device mx31_device = {
+	.name = "mx31-pcmcia",
+	.id = 0,
+	.dev.release = mxc_nop_release,
+};
+static inline void mxc_init_pcmcia(void)
+{
+	printk("Registering %s\n", mx31_device.name);
+	platform_device_register(&mx31_device);
+}
+#else
+static inline void mxc_init_pcmcia(void)
+{
+}
+#endif
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_ipu();
+	mxc_init_mmc();
+	mxc_init_ir();
+	mxc_init_spi();
+	mxc_init_rtc();
+	mxc_init_owire();
+	mxc_init_pcmcia();
+
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx3/dma.c b/arch/arm/mach-mx3/dma.c
new file mode 100644
index 0000000..6414f1e
--- /dev/null
+++ b/arch/arm/mach-mx3/dma.c
@@ -0,0 +1,721 @@
+/*
+ *  Copyright 2004 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <asm/dma.h>
+#include <asm/arch/hardware.h>
+
+#include <linux/device.h>
+#include "serial.h"
+
+#define MXC_MMC_BUFFER_ACCESS     0x38
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_FIRI_TXFIFO           0x14
+#define MXC_SDHC_MMC_WML          16
+#define MXC_SDHC_SD_WML           64
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_FIRI_WML              16
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR,
+			.peripheral_type = FIRI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_FIRI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR + MXC_FIRI_TXFIFO,
+			.peripheral_type = FIRI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_FIRI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_FIR_RX, &mxc_sdma_fir_rx_params},
+	{MXC_DMA_FIR_TX, &mxc_sdma_fir_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id) {
+			return p->chnl_info;
+		}
+	}
+	return NULL;
+}
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t * chnl)
+{
+	/* No channels statically allocated for MX31 */
+}
+
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx3/iomux.c b/arch/arm/mach-mx3/iomux.c
new file mode 100644
index 0000000..0f4ba8e
--- /dev/null
+++ b/arch/arm/mach-mx3/iomux.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * 4 control fields per MUX register
+ */
+#define MUX_CTL_FIELDS          4
+
+/*!
+ * 3 control fields per PAD register
+ */
+#define PAD_CTL_FIELDS          3
+
+/*!
+ * Maximum number of MUX pins
+ * Number of pins = (highest iomux reg - lowest iomux reg + 1) * (4 pins/reg)
+ */
+#define MUX_PIN_NUM_MAX \
+        (((u32 *)IOMUXSW_MUX_END - (u32 *)IOMUXSW_MUX_CTL + 1) * MUX_CTL_FIELDS)
+
+/*!
+ * Number of pad controls =
+ *               (highest pad ctl reg - lowest pad ctl reg + 1) * (3 pins/reg)
+ */
+#define PAD_CTL_NUM_MAX \
+        (((u32 *)IOMUXSW_PAD_END - (u32 *)IOMUXSW_PAD_CTL + 1) * PAD_CTL_FIELDS)
+
+#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & ((1 << (MUX_F - MUX_I)) - 1))
+#define PIN_TO_IOMUX_FIELD(pin) ((pin >> MUX_F) & ((1 << (PAD_I - MUX_F)) - 1))
+
+/*!
+ * 8 bits for each MUX control field
+ */
+#define MUX_CTL_BIT_LEN         8
+
+/*!
+ * 10 bits for each PAD control field
+ */
+#define MUX_PAD_BIT_LEN         10
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x008,	/*!< General purpose */
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x00C,	/*!< MUX control */
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x150,	/*!< last MUX control register */
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x154,	/*!< Pad control */
+	IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x308,	/*!< last Pad control register */
+	IOMUXINT_OBS1 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x000,	/*!< Observe interrupts 1 */
+	IOMUXINT_OBS2 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004,	/*!< Observe interrupts 2 */
+};
+
+/* len - mask bit length; fld - mask bit field. Example, to have the mask:
+ * 0xFF000000, use GET_FIELD_MASK(8, 3). Translate in plain language:
+ * "set the 3rd (0-based) 8-bit-long field to all 1's */
+#define GET_FIELD_MASK(len, fld)    (((1 << len) - 1) << (len * fld))
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in)
+{
+	u32 reg, l, ret = 0;
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u32 mux_mask = GET_FIELD_MASK(MUX_CTL_BIT_LEN, mux_field);
+	u8 *rp;
+
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		    (mux_field >= MUX_CTL_FIELDS));
+
+	reg = IOMUXSW_MUX_CTL + (mux_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~mux_mask)) |
+	    (((out << 4) | in) << (mux_field * MUX_CTL_BIT_LEN));
+	__raw_writel(l, reg);
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+	if (out & *rp && *rp != ((out << 4) | in)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		if (pin != MX31_PIN_CTS1 &&
+		    pin != MX31_PIN_RTS1 &&
+		    pin != MX31_PIN_DCD_DCE1 &&
+		    pin != MX31_PIN_DSR_DTE1 &&
+		    pin != MX31_PIN_DTR_DTE1 &&
+		    pin != MX31_PIN_RI_DCE1 &&
+		    pin != MX31_PIN_DSR_DCE1 &&
+		    pin != MX31_PIN_DTR_DCE1 &&
+		    pin != MX31_PIN_RXD1 && pin != MX31_PIN_TXD1) {
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+			       " config changed, index=%d field=%d, "
+			       " prev=0x%x new=0x%x\n", mux_index, mux_field,
+			       *rp, (out << 4) | in);
+		}
+		ret = -EINVAL;
+	}
+	*rp = (out << 4) | in;
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in)
+{
+	int ret = iomux_config_mux(pin, out, in);
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO) {
+		ret |= mxc_request_gpio(pin);
+	}
+	return ret;
+}
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in)
+{
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u8 *rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		    (mux_field >= MUX_CTL_FIELDS));
+
+	*rp = 0;
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO) {
+		mxc_free_gpio(pin);
+	}
+}
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 reg, l;
+	u32 pad_index = (pin >> PAD_I) & ((1 << (PAD_F - PAD_I)) - 1);
+	u32 pad_field = (pin >> PAD_F) & ((1 << (MUX_IO_I - PAD_F)) - 1);
+	u32 pad_mask = GET_FIELD_MASK(MUX_PAD_BIT_LEN, pad_field);
+
+	MXC_ERR_CHK((pad_index > (PAD_CTL_NUM_MAX / PAD_CTL_FIELDS - 1)) ||
+		    (pad_field >= PAD_CTL_FIELDS));
+
+	reg = IOMUXSW_PAD_CTL + (pad_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~pad_mask)) | (config << (pad_field * MUX_PAD_BIT_LEN));
+	__raw_writel(l, reg);
+	spin_unlock(&gpio_mux_lock);
+}
+
+/*
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_pad(iomux_pin_name_t pin, u32 config)
+{
+	mxc_iomux_set_pad(pin, config);
+}
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+	if (en) {
+		l |= gp;
+	} else {
+		l &= ~gp;
+	}
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+
+/*!
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en)
+{
+	mxc_iomux_set_gpr(gp, en);
+}
+
+EXPORT_SYMBOL(mxc_request_iomux);
+EXPORT_SYMBOL(mxc_free_iomux);
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+EXPORT_SYMBOL(iomux_config_pad);
+EXPORT_SYMBOL(iomux_config_gpr);
+EXPORT_SYMBOL(iomux_config_mux);
diff --git a/arch/arm/mach-mx3/iomux.h b/arch/arm/mach-mx3/iomux.h
new file mode 100644
index 0000000..9c0dc07
--- /dev/null
+++ b/arch/arm/mach-mx3/iomux.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_IOMUX_H__
+#define __MACH_MX31_IOMUX_H__
+
+#include <linux/types.h>
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_output_config {
+	OUTPUTCONFIG_GPIO = 0,	/*!< used as GPIO */
+	OUTPUTCONFIG_FUNC,	/*!< used as function */
+	OUTPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
+	OUTPUTCONFIG_ALT2,	/*!< used as alternate function 2 */
+	OUTPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
+	OUTPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
+	OUTPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
+	OUTPUTCONFIG_ALT6	/*!< used as alternate function 6 */
+} iomux_pin_ocfg_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUTCONFIG_NONE = 0,	/*!< not configured for input */
+	INPUTCONFIG_GPIO = 1 << 0,	/*!< used as GPIO */
+	INPUTCONFIG_FUNC = 1 << 1,	/*!< used as function */
+	INPUTCONFIG_ALT1 = 1 << 2,	/*!< used as alternate function 1 */
+	INPUTCONFIG_ALT2 = 1 << 3	/*!< used as alternate function 2 */
+} iomux_pin_icfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_NOLOOPBACK = 0x0 << 9,
+	PAD_CTL_LOOPBACK = 0x1 << 9,
+	PAD_CTL_PKE_NONE = 0x0 << 8,
+	PAD_CTL_PKE_ENABLE = 0x1 << 8,
+	PAD_CTL_PUE_KEEPER = 0x0 << 7,
+	PAD_CTL_PUE_PUD = 0x1 << 7,
+	PAD_CTL_100K_PD = 0x0 << 5,
+	PAD_CTL_100K_PU = 0x1 << 5,
+	PAD_CTL_47K_PU = 0x2 << 5,
+	PAD_CTL_22K_PU = 0x3 << 5,
+	PAD_CTL_HYS_CMOS = 0x0 << 4,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_PGP_FIRI = 0x1 << 0,
+	MUX_DDR_MODE = 0x1 << 1,
+	MUX_PGP_CSPI_BB = 0x1 << 2,
+	MUX_PGP_ATA_1 = 0x1 << 3,
+	MUX_PGP_ATA_2 = 0x1 << 4,
+	MUX_PGP_ATA_3 = 0x1 << 5,
+	MUX_PGP_ATA_4 = 0x1 << 6,
+	MUX_PGP_ATA_5 = 0x1 << 7,
+	MUX_PGP_ATA_6 = 0x1 << 8,
+	MUX_PGP_ATA_7 = 0x1 << 9,
+	MUX_PGP_ATA_8 = 0x1 << 10,
+	MUX_PGP_UH2 = 0x1 << 11,
+	MUX_SDCTL_CSD0_SEL = 0x1 << 12,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 13,
+	MUX_CSPI1_UART3 = 0x1 << 14,
+	MUX_EXTDMAREQ2_MBX_SEL = 0x1 << 15,
+	MUX_TAMPER_DETECT_EN = 0x1 << 16,
+	MUX_PGP_USB_4WIRE = 0x1 << 17,
+	MUX_PGB_USB_COMMON = 0x1 << 18,
+	MUX_SDHC_MEMSTICK1 = 0x1 << 19,
+	MUX_SDHC_MEMSTICK2 = 0x1 << 20,
+	MUX_PGP_SPLL_BYP = 0x1 << 21,
+	MUX_PGP_UPLL_BYP = 0x1 << 22,
+	MUX_PGP_MSHC1_CLK_SEL = 0x1 << 23,
+	MUX_PGP_MSHC2_CLK_SEL = 0x1 << 24,
+	MUX_CSPI3_UART5_SEL = 0x1 << 25,
+	MUX_PGP_ATA_9 = 0x1 << 26,
+	MUX_PGP_USB_SUSPEND = 0x1 << 27,
+	MUX_PGP_USB_OTG_LOOPBACK = 0x1 << 28,
+	MUX_PGP_USB_HS1_LOOPBACK = 0x1 << 29,
+	MUX_PGP_USB_HS2_LOOPBACK = 0x1 << 30,
+	MUX_CLKO_DDR_MODE = 0x1 << 31,
+} iomux_gp_func_t;
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ *
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ * @return 		0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pins
+ * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+#endif
diff --git a/arch/arm/mach-mx3/mm.c b/arch/arm/mach-mx3/mm.c
index 41dad48..bb51524 100644
--- a/arch/arm/mach-mx3/mm.c
+++ b/arch/arm/mach-mx3/mm.c
@@ -3,6 +3,7 @@
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
  *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (c) 2008 Wind River Systems, Inc.
  *    - add MX31 specific definitions
  *
  * This program is free software; you can redistribute it and/or modify
@@ -41,16 +42,59 @@
  */
 static struct map_desc mxc_io_desc[] __initdata = {
 	{
+		.virtual 	= IRAM_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(IRAM_BASE_ADDR),
+		.length 	= IRAM_SIZE,
+		.type 		= MT_NONSHARED_DEVICE
+	},
+        {
+		.virtual 	= L2CC_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(L2CC_BASE_ADDR),
+		.length 	= L2CC_SIZE,
+		.type 		= MT_DEVICE
+	},
+	{
 		.virtual	= X_MEMC_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(X_MEMC_BASE_ADDR),
 		.length		= X_MEMC_SIZE,
 		.type		= MT_DEVICE
-	}, {
+	},
+        {
+		.virtual 	= ROMP_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(ROMP_BASE_ADDR),
+		.length 	= ROMP_SIZE,
+		.type 		= MT_NONSHARED_DEVICE
+	},
+	{
 		.virtual	= AVIC_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(AVIC_BASE_ADDR),
 		.length		= AVIC_SIZE,
 		.type		= MT_NONSHARED_DEVICE
 	},
+	{
+		.virtual 	= AIPS1_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(AIPS1_BASE_ADDR),
+		.length 	= AIPS1_SIZE,
+		.type 		= MT_NONSHARED_DEVICE
+	},
+        {
+		.virtual 	= SPBA0_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(SPBA0_BASE_ADDR),
+		.length 	= SPBA0_SIZE,
+		.type 		= MT_NONSHARED_DEVICE
+	},
+        {
+		.virtual 	= AIPS2_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(AIPS2_BASE_ADDR),
+		.length 	= AIPS2_SIZE,
+		.type 		= MT_NONSHARED_DEVICE
+	},
+        {
+		.virtual 	= CS4_BASE_ADDR_VIRT,
+		.pfn 		= __phys_to_pfn(CS4_BASE_ADDR),
+		.length 	= CS4_SIZE,
+		.type 		= MT_DEVICE
+	},
 };
 
 /*!
diff --git a/arch/arm/mach-mx3/mx31_gpio.c b/arch/arm/mach-mx3/mx31_gpio.c
new file mode 100644
index 0000000..185ebbc
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31_gpio.c
@@ -0,0 +1,1969 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include <asm/mach-types.h>
+#include "iomux.h"
+
+/*!
+ * @file mx31_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+void gpio_activate_audio_ports(void);
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO initialization
+ * code inside this function. It is called by \b fixup_mx31ads() during
+ * system startup. This function is board specific.
+ */
+void mx31ads_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX31_PIN_CS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*Connect DAM ports 4 & 5 to enable audio I/O */
+	gpio_activate_audio_ports();
+}
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO initialization
+ * code inside this function. It is called by \b fixup_mx31lite() during
+ * system startup. This function is board specific.
+ */
+void mx31lite_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX31_PIN_CS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*Connect DAM ports 4 & 5 to enable audio I/O */
+	gpio_activate_audio_ports();
+
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_GPIO);
+		mxc_set_gpio_direction(MX31_PIN_SFS6, 1);
+	}
+}
+
+void gpio_nic_active(void)
+{
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_GPIO);
+		mxc_set_gpio_direction(MX31_PIN_SFS6, 1);
+	}
+}
+EXPORT_SYMBOL(gpio_nic_active);
+
+void gpio_nic_inactive(void)
+{
+	if (machine_is_mx31lite()) {
+		mxc_free_gpio(MX31_PIN_SFS6);
+		mxc_free_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+	}
+}
+EXPORT_SYMBOL(gpio_nic_inactive);
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_clr = 0, pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		/* Enable the transceiver */
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELC;
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		if (no_irda == 1) {
+			mxc_request_iomux(MX31_PIN_RTS2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CTS2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_DTR_DCE2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+			pbc_bctrl2_clr |= PBC_BCTRL2_USELC;
+		} else {
+			pbc_bctrl1_clr |= PBC_BCTRL1_IREN;
+			pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+		}
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI3_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SPI_RDY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+		pbc_bctrl2_clr |= PBC_BCTRL2_USELB;
+		break;
+		/* UART 4 IOMUX Configs */
+	case 3:
+		mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELB;
+		break;
+		/* UART 5 IOMUX Configs */
+	case 4:
+		mxc_request_iomux(MX31_PIN_PC_VS2, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_RST, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENA;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELA;
+		break;
+	default:
+		break;
+	}
+
+	__raw_writew(pbc_bctrl1_clr, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	/*
+	 * TODO: Configure the Pad registers for the UART pins
+	 */
+}
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_set = 0;
+
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX31_PIN_RXD1);
+		mxc_request_gpio(MX31_PIN_TXD1);
+		mxc_request_gpio(MX31_PIN_RTS1);
+		mxc_request_gpio(MX31_PIN_CTS1);
+		mxc_request_gpio(MX31_PIN_DTR_DCE1);
+		mxc_request_gpio(MX31_PIN_DSR_DCE1);
+		mxc_request_gpio(MX31_PIN_RI_DCE1);
+		mxc_request_gpio(MX31_PIN_DCD_DCE1);
+
+		mxc_free_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+		break;
+	case 1:
+		mxc_request_gpio(MX31_PIN_TXD2);
+		mxc_request_gpio(MX31_PIN_RXD2);
+
+		mxc_free_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		if (no_irda == 1) {
+			mxc_request_gpio(MX31_PIN_DTR_DCE2);
+			mxc_free_iomux(MX31_PIN_DTR_DCE2, OUTPUTCONFIG_GPIO,
+				       INPUTCONFIG_GPIO);
+
+			pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+		} else {
+			pbc_bctrl1_set |= PBC_BCTRL1_IREN;
+		}
+		break;
+	case 2:
+		pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+		break;
+	case 3:
+		mxc_request_gpio(MX31_PIN_ATA_CS0);
+		mxc_request_gpio(MX31_PIN_ATA_CS1);
+		mxc_request_gpio(MX31_PIN_ATA_DIOR);
+		mxc_request_gpio(MX31_PIN_ATA_DIOW);
+
+		mxc_free_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+		break;
+	case 4:
+		pbc_bctrl1_set |= PBC_BCTRL1_UENA;
+		break;
+	default:
+		break;
+	}
+	__raw_writew(pbc_bctrl1_set, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+
+	switch (port) {
+	case 1:
+		/* Configure to receive UART 2 SDMA events */
+		mxc_iomux_set_gpr(MUX_PGP_FIRI, false);
+		break;
+	case 2:
+		/* Configure to receive UART 3 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI1_UART3, true);
+		break;
+	case 4:
+		/* Configure to receive UART 5 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI3_UART5_SEL, true);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+EXPORT_SYMBOL(gpio_uart_inactive);
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Setup GPIO for Keypad  to be active
+ *
+ */
+void gpio_keypad_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for keypad signals.
+	 */
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Setup GPIO for Keypad to be inactive
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 2:
+		/* SPI3 */
+		/*
+		   mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_pad(MX31_PIN_BATT_LINE, PAD_CTL_LOOPBACK);
+}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_inactive(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_GPIO,
+			 INPUTCONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_owire_active);
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		break;
+	case 2:
+		/* SPI3 */
+		/*
+		   mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	mxc_request_iomux(MX31_PIN_GPIO1_3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_set_gpio_direction(MX31_PIN_GPIO1_3, 1);
+//      mxc_set_gpio_edge_ctrl(MX31_PIN_GPIO1_3, GPIO_INT_RISE_EDGE);
+}
+
+EXPORT_SYMBOL(gpio_pmic_active);
+
+/*!
+ * This function activates DAM ports 4 & 5 to enable
+ * audio I/O. Thsi function is called from mx31XXX_gpio_init
+ * function, which is board-specific.
+ */
+void gpio_activate_audio_ports(void)
+{
+	/* config Audio ports (4 & 5) */
+	mxc_request_iomux(MX31_PIN_SCK4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SCK5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		break;
+	case 1:
+		/* TODO:what are the pins for SDHC2? */
+		mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+int sdhc_get_card_det_status(struct device *dev)
+{
+	if (to_platform_device(dev)->id == 0) {
+		if (machine_is_mx31lite())
+			return mxc_get_gpio_datain(MX31_PIN_DCD_DCE1);
+		else
+			return mxc_get_gpio_datain(MX31_PIN_GPIO1_1);
+	} else {
+		return mxc_get_gpio_datain(MX31_PIN_GPIO1_2);
+	}
+}
+
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	if (id == 0) {
+		int pin = MX31_PIN_GPIO1_1;
+		if (machine_is_mx31lite())
+			pin = MX31_PIN_DCD_DCE1;
+		iomux_config_mux(pin, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		if (machine_is_mx31lite())
+			mxc_iomux_set_pad(MX31_PIN_DCD_DCE1,
+				  PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW);
+		return IOMUX_TO_IRQ(pin);
+	} else {
+		iomux_config_mux(MX31_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
+				 INPUTCONFIG_GPIO);
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_2);
+
+	}
+}
+
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Setup GPIO for LCD to be active
+ *
+ */
+void gpio_lcd_active(void)
+{
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// LD16
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// LD17
+	mxc_request_iomux(MX31_PIN_VSYNC3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// VSYNC
+	mxc_request_iomux(MX31_PIN_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// HSYNC
+	mxc_request_iomux(MX31_PIN_FPSHIFT, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CLK
+	mxc_request_iomux(MX31_PIN_DRDY0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// DRDY
+	mxc_request_iomux(MX31_PIN_D3_REV, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// REV
+	mxc_request_iomux(MX31_PIN_CONTRAST, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CONTR
+	mxc_request_iomux(MX31_PIN_D3_SPL, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// SPL
+	mxc_request_iomux(MX31_PIN_D3_CLS, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CLS
+
+	if (machine_is_mx31ads()) {
+		u16 temp;
+		temp = PBC_BCTRL1_LCDON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+	}
+}
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ *
+ */
+void gpio_lcd_inactive(void)
+{
+	if (machine_is_mx31ads()) {
+		u16 pbc_bctrl1_set = 0;
+
+		pbc_bctrl1_set = (u16) PBC_BCTRL1_LCDON;
+		__raw_writew(pbc_bctrl1_set, PBC_BASE_ADDRESS + PBC_BCTRL1_SET + 2);
+	}
+}
+
+/*!
+ * Setup pins for SLCD to be active
+ *
+ */
+void slcd_gpio_config(void)
+{
+	u16 temp;
+
+	if (machine_is_mx31lite())
+		return;
+
+	/* Reset smart lcd */
+	temp = PBC_BCTRL2_LDC_RST0;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	msleep(2);
+	/* Bring out of reset */
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	msleep(2);
+
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	mxc_request_iomux(MX31_PIN_READ, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* read */
+	mxc_request_iomux(MX31_PIN_WRITE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* write */
+	mxc_request_iomux(MX31_PIN_PAR_RS, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* RS */
+	mxc_request_iomux(MX31_PIN_LCS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* chip select */
+
+	/* Enable smart lcd interface */
+	temp = PBC_BCTRL2_LDCIO_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+
+/*!
+ * Switch to the specified sensor - MX31 ADS has two
+ *
+ */
+void gpio_sensor_select(int sensor)
+{
+	u16 temp;
+
+	if (machine_is_mx31lite())
+		return;
+
+	switch (sensor) {
+	case 0:
+#ifdef CONFIG_MXC_CAMERA_MC521DA
+		temp = 0x100;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+#else
+		temp = PBC_BCTRL1_SENSOR2_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+		temp = PBC_BCTRL1_SENSOR1_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+#endif
+		break;
+	case 1:
+		temp = PBC_BCTRL1_SENSOR1_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+		temp = PBC_BCTRL1_SENSOR2_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	if (machine_is_mx31lite())
+		return;
+
+	gpio_sensor_select(0);
+
+	/*
+	 * Configure the iomuxen for the CSI.
+	 */
+
+	mxc_request_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * The other 4 data bits are multiplexed on MX31.
+	 */
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+#endif
+
+	/*
+	 * Now enable the CSI buffers
+	 */
+
+	__raw_writew(PBC_BCTRL2_CSI_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * Enable the other buffer for the additional 4 data bits.
+	 */
+	__raw_writew(PBC_BCTRL4_CSI_MSB_EN,
+		     PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+#endif
+}
+
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_reset(bool flag)
+{
+	u16 temp = 0x200;
+
+	if (flag)
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+	else
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+
+EXPORT_SYMBOL(gpio_sensor_reset);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+		       INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+	/*
+	 * Configure the GPR for ATA group B signals
+	 */
+
+	/* XXX: might need revisiting for MX31LITE */
+	if (machine_is_mx31lite()) {
+		u32 config = PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE; //PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | PAD_CTL_ODE_CMOS | PAD_CTL_HYS_CMOS | PAD_CTL_100K_PD;
+
+		mxc_iomux_set_gpr(MUX_PGP_ATA_9 | MUX_PGP_ATA_5 |
+				MUX_PGP_ATA_1, true);
+
+		mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL5, config); /* ATA_DA0 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL6, config); /* ATA_DA1 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7, config); /* ATA_DA2 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL4, config); /* ATA_DMARQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, config); /* ATA_INITRQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, config); /* ATA_BUF_EN */
+
+		mxc_iomux_set_pad(MX31_PIN_PWMO, config); /* ATA_IORDY */
+	} else {
+		mxc_iomux_set_gpr(MUX_PGP_ATA_7 | MUX_PGP_ATA_6 |
+				MUX_PGP_ATA_2 | MUX_PGP_ATA_1, true);
+
+		/*
+		 * Configure the IOMUX for ATA group B signals
+		 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D0
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D1
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D2
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D3
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D4
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D5
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D6
+		mxc_request_iomux(MX31_PIN_STXD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D7
+		mxc_request_iomux(MX31_PIN_SRXD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D8
+		mxc_request_iomux(MX31_PIN_SCK3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D9
+		mxc_request_iomux(MX31_PIN_SFS3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D10
+		mxc_request_iomux(MX31_PIN_STXD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D11
+		mxc_request_iomux(MX31_PIN_SRXD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D12
+		mxc_request_iomux(MX31_PIN_SCK6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D13
+		mxc_request_iomux(MX31_PIN_CAPTURE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D14
+		mxc_request_iomux(MX31_PIN_COMPARE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D15
+
+		mxc_request_iomux(MX31_PIN_USBH2_STP, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DMARQ_B
+		mxc_request_iomux(MX31_PIN_USBH2_CLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_INTRQ_B
+		mxc_request_iomux(MX31_PIN_USBH2_NXT, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA0
+		mxc_request_iomux(MX31_PIN_USBH2_DATA0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA1
+		mxc_request_iomux(MX31_PIN_USBH2_DATA1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA2
+		mxc_request_iomux(MX31_PIN_USBH2_DIR, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_BUFFER_DIR
+
+		/* Need fast slew rate for UDMA mode */
+
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 0
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 1
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 2
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 3
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 4
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 5
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 6
+		mxc_iomux_set_pad(MX31_PIN_STXD3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 7
+		mxc_iomux_set_pad(MX31_PIN_SRXD3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 8
+		mxc_iomux_set_pad(MX31_PIN_SCK3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 9
+		mxc_iomux_set_pad(MX31_PIN_SFS3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 10
+		mxc_iomux_set_pad(MX31_PIN_STXD6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 11
+		mxc_iomux_set_pad(MX31_PIN_SRXD6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 12
+		mxc_iomux_set_pad(MX31_PIN_SCK6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 13
+		mxc_iomux_set_pad(MX31_PIN_CAPTURE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 14
+		mxc_iomux_set_pad(MX31_PIN_COMPARE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 12
+
+		/*
+		 * Turn off default pullups on high asserted control signals.
+		 * These are pulled down externally, so it will just waste
+		 * power and create voltage divider action to pull them up
+		 * on chip.
+		 */
+		mxc_iomux_set_pad(MX31_PIN_USBH2_STP, PAD_CTL_PKE_NONE); // ATA_DMARQ
+		mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, PAD_CTL_PKE_NONE); // ATA_INTRQ
+	}
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_PWMO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	if (machine_is_mx31lite()) {
+		u32 config = PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | PAD_CTL_ODE_CMOS | PAD_CTL_HYS_CMOS | PAD_CTL_100K_PD;
+		mxc_iomux_set_pad(MX31_PIN_ATA_CS0, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_CS1, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DIOR, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DIOW, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DMACK, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_RESET_B, config);
+	}
+
+//	printk(KERN_DEBUG "gpio_ata_active: Enable clocks\n");
+//	mxc_clks_enable(ATA_CLK);
+}
+
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	printk(KERN_DEBUG "gpio_ata_inactive: Disable clocks\n");
+	mxc_clks_disable(ATA_CLK);
+
+	/*
+	 * Turn off ATA group B signals
+	 */
+
+	/* XXX: revisit for MX31LITE */
+	if (!machine_is_mx31lite()) {
+		u32 config = PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE;
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D0
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D1
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D2
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D3
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D4
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D5
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D6
+		mxc_request_iomux(MX31_PIN_STXD3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D7
+		mxc_request_iomux(MX31_PIN_SRXD3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D8
+		mxc_request_iomux(MX31_PIN_SCK3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D9
+		mxc_request_iomux(MX31_PIN_SFS3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D10
+		mxc_request_iomux(MX31_PIN_STXD6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D11
+		mxc_request_iomux(MX31_PIN_SRXD6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D12
+		mxc_request_iomux(MX31_PIN_SCK6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D13
+		mxc_request_iomux(MX31_PIN_CAPTURE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D14
+		mxc_request_iomux(MX31_PIN_COMPARE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D15
+
+		mxc_request_iomux(MX31_PIN_USBH2_STP, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DMARQ_B
+		mxc_request_iomux(MX31_PIN_USBH2_CLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_INTRQ_B
+		mxc_request_iomux(MX31_PIN_USBH2_NXT, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA0
+		mxc_request_iomux(MX31_PIN_USBH2_DATA0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA1
+		mxc_request_iomux(MX31_PIN_USBH2_DATA1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA2
+		mxc_request_iomux(MX31_PIN_USBH2_DIR, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_BUFFER_DIR
+
+		/* Needed fast slew rate for UDMA mode */
+
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, config);	// data 0
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, config);	// data 1
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, config);	// data 2
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, config);	// data 3
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, config);	// data 4
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, config);	// data 5
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, config);	// data 6
+		mxc_iomux_set_pad(MX31_PIN_STXD3, config);	// data 7
+		mxc_iomux_set_pad(MX31_PIN_SRXD3, config);	// data 8
+		mxc_iomux_set_pad(MX31_PIN_SCK3, config);	// data 9
+		mxc_iomux_set_pad(MX31_PIN_SFS3, config);	// data 10
+		mxc_iomux_set_pad(MX31_PIN_STXD3, config);	// data 11
+		mxc_iomux_set_pad(MX31_PIN_SRXD6, config);	// data 12
+		mxc_iomux_set_pad(MX31_PIN_SCK6, config);	// data 13
+		mxc_iomux_set_pad(MX31_PIN_CAPTURE, config);	// data 14
+		mxc_iomux_set_pad(MX31_PIN_COMPARE, config);	// data 12
+	} else {
+		u32 config = PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE;
+		mxc_iomux_set_pad(MX31_PIN_PWMO, config); /* ATA_IORDY */
+		mxc_free_gpio(MX31_PIN_KEY_COL5);
+		mxc_free_gpio(MX31_PIN_KEY_COL6);
+		mxc_free_gpio(MX31_PIN_KEY_COL7);
+		mxc_free_gpio(MX31_PIN_KEY_COL4);
+		mxc_free_gpio(MX31_PIN_KEY_ROW6);
+		mxc_free_gpio(MX31_PIN_KEY_ROW7);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL5, config); /* ATA_DA0 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL6, config); /* ATA_DA1 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7, config); /* ATA_DA2 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL4, config); /* ATA_DMARQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, config); /* ATA_INITRQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, config); /* ATA_BUF_EN */
+	}
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+
+}
+
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+/*!
+ * Setup EDIO/IOMUX for external UART.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to allocate
+ * @param handler Function to be called when the IRQ occurs
+ * @param irq_flags Interrupt type flags
+ * @param devname An ascii name for the claiming device
+ * @param dev_id A cookie passed back to the handler function
+ * @return  Returns 0 if the interrupt was successfully requested,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_setup(unsigned int port, unsigned int irq,
+		       irqreturn_t(*handler) (int, void *),
+		       unsigned long irq_flags, const char *devname,
+		       void *dev_id)
+{
+	return 0;
+}
+
+/*!
+ * Get the EDIO interrupt, clear if set.
+ *
+ * @param port UART port
+ */
+void extuart_intr_clear(unsigned int port)
+{
+}
+
+/*!
+ * Do IOMUX configs required to put the
+ * pin back in low power mode.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to free
+ * @param dev_id Device identity to free
+ * @return  Returns 0 if the interrupt was successfully freed,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_cleanup(unsigned int port, unsigned int irq, void *dev_id)
+{
+	return 0;
+}
+
+/* *INDENT-OFF* */
+/*
+ * USB Host 1
+ * pins conflict with SPI1, ATA, UART3
+ */
+int gpio_usbh1_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_CSPI1_MOSI,	/* USBH1_RXDM */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_MISO,	/* USBH1_RXDP */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS0,	/* USBH1_TXDM */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS1,	/* USBH1_TXDP */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS2,	/* USBH1_RCV  */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SCLK,	/* USBH1_OEB (_TXOE) */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,	/* USBH1_FS   */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1)) {
+		return -EINVAL;
+	}
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY,	/* USBH1_FS   */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_gpr(MUX_PGP_USB_SUSPEND, true);
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh1_active);
+
+void gpio_usbh1_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SPI_RDY,		/* USBH1_FS   */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY	/* USBH1_FS   */,
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	int outputconfig = OUTPUTCONFIG_GPIO;
+
+	if (machine_is_mx31lite())
+		outputconfig = OUTPUTCONFIG_FUNC;
+
+	if (mxc_request_iomux(MX31_PIN_USBH2_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_PC_VS2,		/* USBH2_DATA2 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_RST,		/* USBH2_DATA5 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_IOIS16,		/* USBH2_DATA6 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFWE_B,
+			      outputconfig, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFRE_B,
+			      outputconfig, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFALE,
+			      outputconfig, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFCLE,
+			      outputconfig, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFWP_B,
+			      outputconfig, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFCE_B,
+			      outputconfig, INPUTCONFIG_NONE)) {
+		return -EINVAL;
+	}
+
+#define H2_PAD_CFG (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | PAD_CTL_HYS_CMOS | PAD_CTL_ODE_CMOS | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, H2_PAD_CFG);	/* USBH2_DATA2 */
+	mxc_iomux_set_pad(MX31_PIN_STXD6, H2_PAD_CFG);	/* USBH2_DATA3 */
+	mxc_iomux_set_pad(MX31_PIN_SFS3, H2_PAD_CFG);	/* USBH2_DATA4 */
+	mxc_iomux_set_pad(MX31_PIN_SCK3, H2_PAD_CFG);	/* USBH2_DATA5 */
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, H2_PAD_CFG);	/* USBH2_DATA6 */
+	mxc_iomux_set_pad(MX31_PIN_STXD3, H2_PAD_CFG);	/* USBH2_DATA7 */
+#undef H2_PAD_CFG
+
+	mxc_iomux_set_gpr(MUX_PGP_UH2, true);
+
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_DTR_DCE1,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_DTR_DCE1,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_DTR_DCE1, 0); // output
+		mxc_set_gpio_dataout(MX31_PIN_DTR_DCE1, 0);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	int outputconfig = OUTPUTCONFIG_GPIO;
+
+	if (machine_is_mx31lite())
+		outputconfig = OUTPUTCONFIG_FUNC;
+
+	iomux_config_gpr(MUX_PGP_UH2, false);
+
+	iomux_config_pad(MX31_PIN_USBH2_CLK,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DIR,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_NXT,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_STP,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA0,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA1,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD6,		/* USBH2_DATA2 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD6,		/* USBH2_DATA3 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SFS3,			/* USBH2_DATA4 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SCK3,			/* USBH2_DATA5 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD3,		/* USBH2_DATA6 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD3,		/* USBH2_DATA7 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+	mxc_free_iomux(MX31_PIN_USBH2_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_PC_VS2,			/* USBH2_DATA2 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST,			/* USBH2_DATA5 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_IOIS16,			/* USBH2_DATA6 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_NFWE_B,
+		       outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFRE_B,
+		       outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFALE,
+		       outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCLE,
+		       outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFWP_B,
+		       outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCE_B,
+		       outputconfig, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+		return -EINVAL;
+	}
+
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USB_PWR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+		return -EINVAL;
+	}
+	return 0;
+
+}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USB_PWR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+/* *INDENT-ON* */
+
+/*!
+ * Setup GPIO for PCMCIA interface
+ *
+ */
+void gpio_pcmcia_active(void)
+{
+	mxc_request_iomux(MX31_PIN_SDBA0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SDBA1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_LBA, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_RW, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_OE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_IOIS16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_POE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_READY, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RST, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RW_B, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+
+	if (machine_is_mx31ads()) {
+		/* PCMCIA VPP, VCC Enable, 1 = power on */
+		u16 temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+		/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+		temp = PBC_BCTRL3_CARD2_SEL;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR);
+
+		/* PCMCIA Enable, 0 = enable */
+		temp = PBC_BCTRL4_PCMCIA_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+		mdelay(1);
+	} else if (machine_is_mx31lite()) {
+		/* PCC_POWER_nEN */
+		mxc_request_iomux(MX31_PIN_LCS1,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_LCS1,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_LCS1, 0); // output
+		mxc_set_gpio_dataout(MX31_PIN_LCS1, 0);
+		/* PCC_PCMCIA_nEN */
+		mxc_request_iomux(MX31_PIN_KEY_COL7,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_KEY_COL7, 0); // output
+		mxc_set_gpio_dataout(MX31_PIN_KEY_COL7, 0);
+	}
+
+}
+
+EXPORT_SYMBOL(gpio_pcmcia_active);
+
+/*!
+ * Setup GPIO for pcmcia to be inactive
+ */
+void gpio_pcmcia_inactive(void)
+{
+	if (machine_is_mx31ads()) {
+		/* PCMCIA Enable, 0 = enable */
+		u16 temp = PBC_BCTRL4_PCMCIA_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_SET);
+
+		/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+		temp = PBC_BCTRL3_CARD2_SEL;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_SET);
+
+		/* PCMCIA VPP, VCC Enable, 1 = power on */
+		temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	} else if (machine_is_mx31lite()) {
+		mxc_free_iomux(MX31_PIN_LCS1, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+	}
+
+	mxc_free_iomux(MX31_PIN_SDBA0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_SDBA1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_LBA, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_RW, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_OE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_IOIS16, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_POE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_pcmcia_inactive);
+/*!
+ * Setup IR to be used by UART and FIRI
+ */
+void gpio_firi_init(void)
+{
+	unsigned long clk;
+	gpio_uart_active(1, 0);
+
+	clk = mxc_get_clocks_parent(FIRI_BAUD);
+	/*
+	 * FIRI module needs a clock which is a multiple of 8 Mhz..
+	 * We are giving it 48 Mhz in this case.
+	 */
+	mxc_set_clocks_div(FIRI_BAUD, (clk / 48000000));
+}
+
+EXPORT_SYMBOL(gpio_firi_init);
+
+/*!
+ * Setup IR to be used by UART
+ */
+void gpio_firi_inactive(void)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+
+	iomux_config_gpr(MUX_PGP_FIRI, false);
+	mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+
+EXPORT_SYMBOL(gpio_firi_inactive);
+
+/*!
+ * Setup IR to be used by FIRI
+ */
+void gpio_firi_active(void *fir_cong_reg_base, unsigned int tpp_mask)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+	unsigned int cr;
+
+	iomux_config_gpr(MUX_PGP_FIRI, true);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	cr = readl(fir_cong_reg_base);
+	cr |= tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+}
+
+EXPORT_SYMBOL(gpio_firi_active);
+
+/*!
+ * Find clock for FIRI
+ */
+unsigned int firi_get_clocks(void)
+{
+	return (mxc_get_clocks(UART2_BAUD));
+}
+
+EXPORT_SYMBOL(firi_get_clocks);
+
+void firi_disable_uart_clock(void)
+{
+	mxc_clks_disable(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(firi_disable_uart_clock);
+
+void firi_enable_uart_clock(void)
+{
+	mxc_clks_enable(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(firi_enable_uart_clock);
diff --git a/arch/arm/mach-mx3/sdma_script_code.h b/arch/arm/mach-mx3/sdma_script_code.h
new file mode 100644
index 0000000..361b193
--- /dev/null
+++ b/arch/arm/mach-mx3/sdma_script_code.h
@@ -0,0 +1,578 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* Following define start address of start script
+*/
+#define start_ADDR	0
+/*!
+* Following define size of start script
+*/
+#define start_SIZE	21
+
+/*!
+* Following define start address of core script
+*/
+#define core_ADDR	80
+/*!
+* Following define size of core script
+*/
+#define core_SIZE	152
+
+/*!
+* Following define start address of common script
+*/
+#define common_ADDR	232
+/*!
+* Following define size of common script
+*/
+#define common_SIZE	191
+
+/*!
+* Following define start address of burst_copy script
+*/
+#define burst_copy_ADDR	423
+/*!
+* Following define size of burst_copy script
+*/
+#define burst_copy_SIZE	87
+
+/*!
+* Following define start address of dsp_2_burst script
+*/
+#define dsp_2_burst_ADDR	510
+/*!
+* Following define size of dsp_2_burst script
+*/
+#define dsp_2_burst_SIZE	24
+
+/*!
+* Following define start address of burst_2_dsp script
+*/
+#define burst_2_dsp_ADDR	534
+/*!
+* Following define size of burst_2_dsp script
+*/
+#define burst_2_dsp_SIZE	24
+
+/*!
+* Following define start address of dsp_copy script
+*/
+#define dsp_copy_ADDR	558
+/*!
+* Following define size of dsp_copy script
+*/
+#define dsp_copy_SIZE	86
+
+/*!
+* Following define start address of mcu_2_mcu script
+*/
+#define mcu_2_mcu_ADDR	644
+/*!
+* Following define size of mcu_2_mcu script
+*/
+#define mcu_2_mcu_SIZE	79
+
+/*!
+* Following define start address of mcu_2_per script
+*/
+#define mcu_2_per_ADDR	723
+/*!
+* Following define size of mcu_2_per script
+*/
+#define mcu_2_per_SIZE	88
+
+/*!
+* Following define start address of test script
+*/
+#define test_ADDR	811
+/*!
+* Following define size of test script
+*/
+#define test_SIZE	63
+
+/*!
+* Following define start address of mcu_2_dsp script
+*/
+#define mcu_2_dsp_ADDR	874
+/*!
+* Following define size of mcu_2_dsp script
+*/
+#define mcu_2_dsp_SIZE	30
+
+/*!
+* Following define start address of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_ADDR	904
+/*!
+* Following define size of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_mcu script
+*/
+#define dsp_2_mcu_ADDR	1017
+/*!
+* Following define size of dsp_2_mcu script
+*/
+#define dsp_2_mcu_SIZE	30
+
+/*!
+* Following define start address of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_ADDR	1047
+/*!
+* Following define size of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_dsp script
+*/
+#define dsp_2_dsp_ADDR	1160
+/*!
+* Following define size of dsp_2_dsp script
+*/
+#define dsp_2_dsp_SIZE	64
+
+/*!
+* Following define start address of per_2_mcu script
+*/
+#define per_2_mcu_ADDR	1224
+/*!
+* Following define size of per_2_mcu script
+*/
+#define per_2_mcu_SIZE	121
+
+/*!
+* Following define start address of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_ADDR	1345
+/*!
+* Following define size of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_SIZE	164
+
+/*!
+* Following define start address of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_ADDR	1509
+/*!
+* Following define size of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_SIZE	168
+
+/*!
+* Following define start address of per_2_per script
+*/
+#define per_2_per_ADDR	1677
+/*!
+* Following define size of per_2_per script
+*/
+#define per_2_per_SIZE	67
+
+/*!
+* Following define start address of error_dsp script
+*/
+#define error_dsp_ADDR	1744
+/*!
+* Following define size of error_dsp script
+*/
+#define error_dsp_SIZE	34
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define ap_2_ap_ADDR	6144
+/*!
+* Following define size of ap_2_ap script
+*/
+#define ap_2_ap_SIZE	294
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define app_2_mcu_ADDR	6438
+/*!
+* Following define size of app_2_mcu script
+*/
+#define app_2_mcu_SIZE	101
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define ata_2_mcu_ADDR	6539
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define ata_2_mcu_SIZE	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define dptc_dvfs_ADDR	6649
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define dptc_dvfs_SIZE	274
+
+/*!
+* Following define start address of error script
+*/
+#define error_ADDR	6923
+/*!
+* Following define size of error script
+*/
+#define error_SIZE	73
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define firi_2_mcu_ADDR	6996
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define firi_2_mcu_SIZE	114
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mcu_2_app_ADDR	7110
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mcu_2_app_SIZE	127
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mcu_2_ata_ADDR	7237
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mcu_2_ata_SIZE	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mcu_2_firi_ADDR	7324
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mcu_2_firi_SIZE	77
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mcu_2_mshc_ADDR	7401
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mcu_2_mshc_SIZE	48
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mcu_2_shp_ADDR	7449
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mcu_2_shp_SIZE	123
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mshc_2_mcu_ADDR	7572
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mshc_2_mcu_SIZE	60
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define shp_2_mcu_ADDR	7632
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define shp_2_mcu_SIZE	101
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define uart_2_mcu_ADDR	7733
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define uart_2_mcu_SIZE	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_ADDR	7838
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_SIZE	98
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define RAM_CODE_START_ADDR	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define RAM_CODE_SIZE	1792
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM.
+* This is required to start on a 4-byte aligned boundary on some platforms
+* for SDMA to work properly.
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+__attribute__ ((__aligned__(4)))
+static const short sdma_code[] = {
+	0xc0ec, 0x7d59, 0x0970, 0x0111, 0x5111, 0x5ad1, 0x5bd9, 0xc0fe,
+	0x5ce1, 0x7d02, 0x0200, 0x9806, 0x08ff, 0x0011, 0x28ff, 0x00bc,
+	0x05df, 0x7d4b, 0x06df, 0x7d2f, 0x6dc5, 0x6ed5, 0x5ef1, 0x0288,
+	0xd81a, 0x9854, 0x0b04, 0x00d3, 0x7d20, 0x06a5, 0x3e03, 0x3d03,
+	0x03a5, 0x3b03, 0x008b, 0x058b, 0x7802, 0x63d8, 0x0000, 0x7e72,
+	0x63ff, 0x7e70, 0x02a5, 0x008a, 0x4e00, 0x7d01, 0x983d, 0x6dcf,
+	0x6edf, 0x0015, 0x0015, 0x7802, 0x63d8, 0x0000, 0x7e63, 0x63ff,
+	0x7e61, 0x3a03, 0x008a, 0x6dcd, 0x6edd, 0x7801, 0x63d8, 0x7e5a,
+	0x63ff, 0x7e58, 0x0006, 0x6dc5, 0x6e07, 0x5ef1, 0x0288, 0xd8f7,
+	0x7e02, 0x7f04, 0x9854, 0x0007, 0x68cc, 0x6b28, 0x54e1, 0x0089,
+	0xdb13, 0x0188, 0x5ce1, 0x9854, 0x52d1, 0x53d9, 0x54e1, 0xc10d,
+	0x7dad, 0x0200, 0x9800, 0x0200, 0x9800, 0x06df, 0x7d06, 0x6d23,
+	0x6ed5, 0x5ef1, 0x0288, 0xd8cd, 0x9854, 0x5ef1, 0x6e07, 0x6d03,
+	0x0b04, 0x00d3, 0x7d59, 0x06a5, 0x3e03, 0x3d03, 0x4d00, 0x7d09,
+	0x03a5, 0x00a3, 0x0588, 0x008b, 0xd8c9, 0x7ed8, 0x620c, 0x7ed6,
+	0x008d, 0x4e00, 0x7c25, 0x0a20, 0x00da, 0x7c22, 0x6503, 0x3d1f,
+	0x02a5, 0x00a2, 0x0215, 0x0215, 0x6a18, 0x6a28, 0x7fc7, 0x0a20,
+	0x0b08, 0x00da, 0x7c06, 0x6b18, 0x6b28, 0x7fc0, 0x0000, 0x2020,
+	0x9889, 0x0688, 0x0015, 0x0015, 0x6818, 0x6828, 0x7fb7, 0x98c2,
+	0x0007, 0x6a0c, 0x54e1, 0x0089, 0xdb0f, 0x0188, 0x5ce1, 0x9854,
+	0x0b04, 0x00d3, 0x7d21, 0x0389, 0x1b12, 0x048b, 0x0688, 0x0015,
+	0x0015, 0x0588, 0x038c, 0x0a08, 0x05da, 0x008d, 0x7c01, 0x008a,
+	0x05a0, 0x7803, 0x620b, 0x5a03, 0x1b01, 0x7e98, 0x008b, 0x00a4,
+	0x038c, 0x7803, 0x5203, 0x6a0b, 0x1b01, 0x6a28, 0x7f8f, 0x0000,
+	0x4d00, 0x7ce8, 0x008e, 0x3803, 0xd8c9, 0x7e88, 0x620c, 0x7e86,
+	0x9854, 0x7802, 0x6209, 0x6a29, 0x0006, 0x3e03, 0x4e00, 0x7d11,
+	0x0b04, 0x03a6, 0x02db, 0x7d01, 0x038a, 0x02a3, 0x048a, 0x008b,
+	0x7802, 0x6329, 0x6bc8, 0x7ebc, 0x63c8, 0x7ebc, 0x008c, 0x4800,
+	0x7d15, 0x0488, 0x0015, 0x0015, 0x6edf, 0x7803, 0x632b, 0x6bc8,
+	0x0000, 0x7eae, 0x63c8, 0x7eae, 0x008c, 0x3803, 0x6edd, 0x7803,
+	0x6329, 0x6bc8, 0x0000, 0x7ea4, 0x63c8, 0x7ea4, 0x0006, 0x3d03,
+	0x4d00, 0x7d0e, 0x0b04, 0x03a5, 0x02db, 0x7d01, 0x038a, 0x02a3,
+	0x048a, 0x008b, 0x7802, 0x63c8, 0x6b09, 0x7e1e, 0x7f1e, 0x008c,
+	0x0488, 0x0015, 0x0015, 0x6dcf, 0x0288, 0x008a, 0x0d08, 0x02dd,
+	0x7c01, 0x008d, 0x7802, 0x63c8, 0x6b0b, 0x7e0e, 0x6b28, 0x7f0d,
+	0x0000, 0x02dd, 0x7c02, 0x2208, 0x990d, 0x008c, 0x3803, 0x65c0,
+	0x6dc5, 0x7802, 0x63c8, 0x6b09, 0x6b28, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d5e, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x992c, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x993c, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210,
+	0x4a00, 0x7d1c, 0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311,
+	0x53eb, 0x62c8, 0x7e24, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09,
+	0x7f1e, 0x0212, 0x6a09, 0x7f1b, 0x0212, 0x6a09, 0x7f18, 0x2003,
+	0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313, 0x997d, 0x0015, 0x0015,
+	0x7802, 0x62c8, 0x6a0b, 0x997c, 0x0015, 0x7802, 0x62c8, 0x6a0a,
+	0x997c, 0x7802, 0x62c8, 0x6a09, 0x7c02, 0x0000, 0x993a, 0xdb13,
+	0x6a28, 0x7ffd, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7da5, 0x0200,
+	0x992c, 0x0200, 0x9929, 0xc19d, 0xc0ec, 0x7d69, 0x0c70, 0x0411,
+	0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02,
+	0x0200, 0x9994, 0x6d07, 0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff,
+	0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70, 0x0211, 0x552a,
+	0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9, 0x4d00, 0x7c13,
+	0x6928, 0x7f2d, 0x0400, 0x99a5, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e29, 0x6d28,
+	0x7f1e, 0x0000, 0x99a3, 0x1e20, 0x5506, 0x2620, 0x008d, 0x0560,
+	0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a, 0x7f10, 0x4c00,
+	0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000, 0x99ec, 0x0007,
+	0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28, 0x0007, 0x680c,
+	0x0007, 0x54d2, 0x0454, 0x99ef, 0x6928, 0x7ff1, 0x54d2, 0x008a,
+	0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200, 0x9994, 0x0200,
+	0x998c, 0xc0ec, 0x7d72, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1,
+	0x5bc9, 0x028e, 0xc0fe, 0x068a, 0x7c6a, 0x5dd9, 0x5ce1, 0x0bff,
+	0x0311, 0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363,
+	0x7c05, 0x036f, 0x7d27, 0x0374, 0x7c7a, 0x9a71, 0xdb04, 0x3c06,
+	0x4c00, 0x7df7, 0x028f, 0x1a04, 0x6a23, 0x620b, 0x6f23, 0x301f,
+	0x00aa, 0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9a30, 0x048a,
+	0x620b, 0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa,
+	0x048f, 0x1c04, 0x6c07, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e,
+	0x1a5c, 0x9a11, 0x058f, 0x1d0c, 0x6d23, 0x650b, 0x007d, 0x7c01,
+	0x1d08, 0x007c, 0x7c01, 0x1d04, 0x6d23, 0x650b, 0x0488, 0x3c1f,
+	0x0417, 0x0417, 0x0417, 0x0417, 0x059c, 0x6d23, 0x028e, 0x1a34,
+	0x6ad7, 0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28,
+	0x6ad7, 0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065,
+	0x7c02, 0x0101, 0x0025, 0x0400, 0x9a0d, 0x52c1, 0x53c9, 0x54e1,
+	0x0453, 0xc10d, 0x7d95, 0x0200, 0x9a00, 0x0200, 0x99f9, 0x0200,
+	0x9a00, 0x55d9, 0x6d07, 0x54d1, 0x058a, 0x2508, 0x6dc7, 0x0373,
+	0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372, 0x7c04, 0x65c8, 0x6d0b,
+	0x2408, 0x9a86, 0x6cce, 0x65c8, 0x6d0a, 0x2404, 0x6d28, 0x6507,
+	0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8, 0x0334, 0x6bc8, 0x0370,
+	0x7ca9, 0x0c60, 0x0411, 0x04bb, 0x4c00, 0x7da4, 0x0410, 0x1c30,
+	0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d, 0x7c03, 0x047c, 0x7c01,
+	0x9a3a, 0x003b, 0x003a, 0x0039, 0x0058, 0x9ab5, 0x047d, 0x7d03,
+	0x047c, 0x7d01, 0x9a3a, 0x005b, 0xdaf9, 0x1d18, 0x6d23, 0x650b,
+	0x0510, 0x003a, 0x0039, 0x0038, 0x00ad, 0xdb04, 0x0c30, 0x0410,
+	0x04bb, 0x003c, 0x003d, 0x00ac, 0xdaf9, 0x007b, 0x7c04, 0x003d,
+	0x003c, 0x1d0c, 0x9ad6, 0x048f, 0x1c14, 0x6c23, 0x640b, 0x4401,
+	0x7d04, 0x005d, 0x005c, 0x1d0c, 0x9ad6, 0x0310, 0x3b30, 0x4b30,
+	0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c, 0x00ab, 0x6ad7, 0x63c8,
+	0x6d23, 0x650b, 0x0560, 0x7d03, 0x005e, 0xdaed, 0x9a3a, 0x003e,
+	0x0c80, 0x0410, 0x0394, 0xdaed, 0x640b, 0x037f, 0x7d02, 0x1a14,
+	0x9aea, 0x1a0c, 0x6ad7, 0x6cc8, 0x9a3a, 0x0c7f, 0x0410, 0x03b4,
+	0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e, 0x1a04, 0x6ad7, 0x6cc8,
+	0x0006, 0x058f, 0x1d08, 0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d38,
+	0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b, 0x042c, 0x0454, 0x042b,
+	0x6ad7, 0x6cc8, 0x0006, 0x0007, 0x684c, 0x6144, 0x9b1c, 0x0007,
+	0x68cc, 0x61d0, 0x9b1c, 0x0007, 0x680c, 0x680c, 0x6107, 0x6907,
+	0x692b, 0x6928, 0x0007, 0x680c, 0x0d70, 0x0511, 0x5515, 0x55f5,
+	0x01a5, 0x0dff, 0x0512, 0x1dff, 0x0512, 0x04bd, 0x0499, 0x0454,
+	0x0006, 0x08ff, 0x0011, 0x28ff, 0x0006, 0x038c, 0x0eff, 0x0611,
+	0x2eff, 0x03b6, 0x0006, 0x53d6, 0x0398, 0x5bd6, 0x53ee, 0x0398,
+	0x5bee, 0x0006, 0x52de, 0x53e6, 0x54ee, 0x0498, 0x0454, 0x0006,
+	0x50f6, 0x52c6, 0x53ce, 0x54d6, 0x0498, 0x0454, 0x0006, 0x6207,
+	0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff,
+	0x0312, 0x04bb, 0x049a, 0x0006, 0x1e10, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b5b, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70,
+	0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9b6a, 0x0212,
+	0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8,
+	0xdba5, 0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xdbbd, 0x52c0,
+	0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x9b5b, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0xdba5, 0x9b68, 0x0200, 0x9b58, 0x0007, 0x68cc, 0x6a28,
+	0x7f01, 0x9ba3, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b,
+	0x6a28, 0x0007, 0x680c, 0x0454, 0x9b81, 0x05a0, 0x1e08, 0x6ec3,
+	0x0388, 0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5,
+	0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09,
+	0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5,
+	0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d78, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9bcc, 0x6d03, 0x6ed3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9bdc, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a,
+	0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25, 0x620a,
+	0x7e23, 0x9c06, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512,
+	0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70, 0x0311,
+	0x5313, 0x9c21, 0x7802, 0x6209, 0x6ac8, 0x9c20, 0x0015, 0x7802,
+	0x620a, 0x6ac8, 0x9c20, 0x0015, 0x0015, 0x7802, 0x620b, 0x6ac8,
+	0x7c03, 0x0000, 0x55db, 0x9bda, 0x0007, 0x68cc, 0x680c, 0x55d3,
+	0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9c2f, 0x0017, 0x0017, 0x55db,
+	0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8,
+	0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x008b, 0x52c0, 0x53c8, 0xc10d,
+	0x7d8b, 0x0200, 0x9bcc, 0x0200, 0x9bc9, 0xc19d, 0xc0ec, 0x7d52,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x9c4e, 0x6d03, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211, 0x4c00,
+	0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9c61, 0x4c01,
+	0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d, 0x9c5f,
+	0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f, 0x5d06,
+	0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0, 0x0454,
+	0x9c8b, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9, 0x4d00,
+	0x7c02, 0x0400, 0x9c8d, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7db6,
+	0x0200, 0x9c4e, 0x0200, 0x9c46, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9ca2, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62c8,
+	0x7e1f, 0x0400, 0x9cb3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16, 0x6ac8, 0x7f11, 0x0015,
+	0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e, 0x6ac8, 0x7f09, 0x6edf,
+	0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9cb1,
+	0x0007, 0x68cc, 0x9cdd, 0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd, 0x0200, 0x9ca2, 0x0200,
+	0x9c9f, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cf0, 0x0870, 0x0011,
+	0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228,
+	0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9cff, 0x620b, 0x7e06, 0x5a06,
+	0x7f06, 0x0000, 0x2504, 0x7d05, 0x9cff, 0x0007, 0x680c, 0x0007,
+	0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9cf0, 0x0200,
+	0x9cec, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d74, 0x5010, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d20, 0x6d03,
+	0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70, 0x0211, 0x532a, 0x5212,
+	0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9d34, 0x008f, 0x05d8, 0x7d01,
+	0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d27, 0x4d02, 0x7d20,
+	0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea, 0x0260, 0x7d05, 0x6509,
+	0x7e25, 0x630a, 0x7e23, 0x9d58, 0x630a, 0x7e20, 0x6509, 0x7e1e,
+	0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19, 0x2003, 0x4800, 0x7ced,
+	0x0a70, 0x0211, 0x5212, 0x9d73, 0x7802, 0x6309, 0x5b06, 0x9d72,
+	0x0015, 0x7802, 0x630a, 0x5b06, 0x9d72, 0x0015, 0x0015, 0x7802,
+	0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000, 0x9d32, 0x0007, 0x680c,
+	0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9d80, 0x0017, 0x0017,
+	0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d90,
+	0x0200, 0x9d20, 0x0200, 0x9d1c, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d35, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d9b, 0x0870, 0x0011, 0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d1c, 0x5228, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b,
+	0x0400, 0x9daa, 0x5206, 0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000,
+	0x2504, 0x7d0c, 0x9daa, 0x0007, 0x680c, 0x680c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3,
+	0x5010, 0x52c0, 0xc10d, 0x7dcf, 0x0200, 0x9d9b, 0x0200, 0x9d97,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d5e, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dd7, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0a70, 0x0211,
+	0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04, 0x6a28, 0x7f3a, 0x0400,
+	0x9de6, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312,
+	0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02, 0x7d20, 0x4b01, 0x7d23,
+	0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e24, 0x0260, 0x7d02, 0x0310,
+	0x0312, 0x6b09, 0x7f1e, 0x0312, 0x6b09, 0x7f1b, 0x0312, 0x6b09,
+	0x7f18, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e27,
+	0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b, 0x9e26, 0x0015, 0x7802,
+	0x5306, 0x6b0a, 0x9e26, 0x7802, 0x5306, 0x6b09, 0x7c02, 0x0000,
+	0x9de4, 0xdb13, 0x6928, 0x7ffd, 0x008a, 0x52c0, 0x53c8, 0xc10d,
+	0x7da6, 0x0200, 0x9dd7, 0x0200, 0x9dd3, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d5b, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9e3b, 0x0b70, 0x0311, 0x6ec3, 0x6d07, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3d, 0x522b, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f33, 0x0400, 0x9e4d, 0x028e, 0x1a94, 0x6ac3,
+	0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3, 0x6ed3, 0x62c8, 0x0248,
+	0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e, 0x7d31, 0x6a09, 0x7f1e,
+	0x2501, 0x4d00, 0x7d1f, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3,
+	0x0260, 0x7df1, 0x6a28, 0x7f12, 0xdb47, 0x9e8c, 0x6ee3, 0x008f,
+	0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17,
+	0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e4b, 0x0289, 0xdb13,
+	0x018a, 0x9e9b, 0x6a28, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0,
+	0x53c8, 0xc10d, 0x7da8, 0x0200, 0x9e3b, 0x0200, 0x9e38, 0x6a28,
+	0x7fed, 0xdb47, 0x9e9b, 0x0458, 0x0454, 0x9e8c, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d54, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9ea5, 0x0b70, 0x0311, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d36, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x6928, 0x7f2c, 0x0400, 0x9eb6, 0x028e, 0x1a94,
+	0x5202, 0x0269, 0x7d16, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694,
+	0x5206, 0x026e, 0x7d2e, 0x6a09, 0x7f1b, 0x2501, 0x4d00, 0x7d1c,
+	0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6a28, 0x7f11, 0xdb47,
+	0x9eee, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d17, 0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9eb4,
+	0x0289, 0xdb13, 0x018a, 0x9efd, 0x6928, 0x7ffa, 0x0b70, 0x0311,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7db0, 0x0200, 0x9ea5, 0x0200,
+	0x9ea1, 0x6a28, 0x7fed, 0xdb47, 0x9efd, 0x0458, 0x0454, 0x9eee,
+	0x9eee
+};
+#endif
diff --git a/arch/arm/mach-mx3/sdma_script_code_pass2.h b/arch/arm/mach-mx3/sdma_script_code_pass2.h
new file mode 100644
index 0000000..f7ae3c9
--- /dev/null
+++ b/arch/arm/mach-mx3/sdma_script_code_pass2.h
@@ -0,0 +1,562 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_PASS2_H__
+#define __SDMA_SCRIPT_CODE_PASS2_H__
+
+/*!
+* Following define start address of signature script
+*/
+#define signature_ADDR_2	1023
+/*!
+* Following define size of signature script
+*/
+#define signature_SIZE_2	1
+
+/*!
+* Following define start address of start script
+*/
+#define start_ADDR_2	0
+/*!
+* Following define size of start script
+*/
+#define start_SIZE_2	20
+
+/*!
+* Following define start address of core script
+*/
+#define core_ADDR_2	80
+/*!
+* Following define size of core script
+*/
+#define core_SIZE_2	152
+
+/*!
+* Following define start address of common script
+*/
+#define common_ADDR_2	232
+/*!
+* Following define size of common script
+*/
+#define common_SIZE_2	191
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define ap_2_ap_ADDR_2	423
+/*!
+* Following define size of ap_2_ap script
+*/
+#define ap_2_ap_SIZE_2	294
+
+/*!
+* Following define start address of bp_2_bp script
+*/
+#define bp_2_bp_ADDR_2	717
+/*!
+* Following define size of bp_2_bp script
+*/
+#define bp_2_bp_SIZE_2	112
+
+/*!
+* Following define start address of ap_2_bp script
+*/
+#define ap_2_bp_ADDR_2	829
+/*!
+* Following define size of ap_2_bp script
+*/
+#define ap_2_bp_SIZE_2	200
+
+/*!
+* Following define start address of bp_2_ap script
+*/
+#define bp_2_ap_ADDR_2	1029
+/*!
+* Following define size of bp_2_ap script
+*/
+#define bp_2_ap_SIZE_2	223
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define app_2_mcu_ADDR_2	1252
+/*!
+* Following define size of app_2_mcu script
+*/
+#define app_2_mcu_SIZE_2	101
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mcu_2_app_ADDR_2	1353
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mcu_2_app_SIZE_2	127
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define uart_2_mcu_ADDR_2	1480
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define uart_2_mcu_SIZE_2	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_ADDR_2	1585
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_SIZE_2	98
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mcu_2_shp_ADDR_2	1683
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mcu_2_shp_SIZE_2	123
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define shp_2_mcu_ADDR_2	1806
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define shp_2_mcu_SIZE_2	101
+
+/*!
+* Following define start address of error script
+*/
+#define error_ADDR_2	1907
+/*!
+* Following define size of error script
+*/
+#define error_SIZE_2	73
+
+/*!
+* Following define start address of test script
+*/
+#define test_ADDR_2	1980
+/*!
+* Following define size of test script
+*/
+#define test_SIZE_2	63
+
+/*!
+* Following define start address of app_2_per script
+*/
+#define app_2_per_ADDR_2	6144
+/*!
+* Following define size of app_2_per script
+*/
+#define app_2_per_SIZE_2	103
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define ata_2_mcu_ADDR_2	6247
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define ata_2_mcu_SIZE_2	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define dptc_dvfs_ADDR_2	6357
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define dptc_dvfs_SIZE_2	274
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define firi_2_mcu_ADDR_2	6631
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define firi_2_mcu_SIZE_2	114
+
+/*!
+* Following define start address of firi_2_per script
+*/
+#define firi_2_per_ADDR_2	6745
+/*!
+* Following define size of firi_2_per script
+*/
+#define firi_2_per_SIZE_2	173
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mcu_2_ata_ADDR_2	6918
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mcu_2_ata_SIZE_2	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mcu_2_firi_ADDR_2	7005
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mcu_2_firi_SIZE_2	77
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mcu_2_mshc_ADDR_2	7082
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mcu_2_mshc_SIZE_2	48
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mshc_2_mcu_ADDR_2	7130
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mshc_2_mcu_SIZE_2	60
+
+/*!
+* Following define start address of mshc_2_per script
+*/
+#define mshc_2_per_ADDR_2	7190
+/*!
+* Following define size of mshc_2_per script
+*/
+#define mshc_2_per_SIZE_2	52
+
+/*!
+* Following define start address of per_2_app script
+*/
+#define per_2_app_ADDR_2	7242
+/*!
+* Following define size of per_2_app script
+*/
+#define per_2_app_SIZE_2	129
+
+/*!
+* Following define start address of per_2_firi script
+*/
+#define per_2_firi_ADDR_2	7371
+/*!
+* Following define size of per_2_firi script
+*/
+#define per_2_firi_SIZE_2	70
+
+/*!
+* Following define start address of per_2_mshc script
+*/
+#define per_2_mshc_ADDR_2	7441
+/*!
+* Following define size of per_2_mshc script
+*/
+#define per_2_mshc_SIZE_2	48
+
+/*!
+* Following define start address of per_2_shp script
+*/
+#define per_2_shp_ADDR_2	7489
+/*!
+* Following define size of per_2_shp script
+*/
+#define per_2_shp_SIZE_2	129
+
+/*!
+* Following define start address of shp_2_per script
+*/
+#define shp_2_per_ADDR_2	7618
+/*!
+* Following define size of shp_2_per script
+*/
+#define shp_2_per_SIZE_2	104
+
+/*!
+* Following define start address of uart_2_per script
+*/
+#define uart_2_per_ADDR_2	7722
+/*!
+* Following define size of uart_2_per script
+*/
+#define uart_2_per_SIZE_2	123
+
+/*!
+* Following define start address of uartsh_2_per script
+*/
+#define uartsh_2_per_ADDR_2	7845
+/*!
+* Following define size of uartsh_2_per script
+*/
+#define uartsh_2_per_SIZE_2	109
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define RAM_CODE_START_ADDR_2	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define RAM_CODE_SIZE_2	1810
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM.
+* This is required to start on a 4-byte aligned boundary on some platforms
+* for SDMA to work properly.
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+__attribute__ ((__aligned__(4)))
+static const short sdma_code_2[] = {
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d60, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9806, 0x6ec3, 0x6dd7, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d46, 0x0b70, 0x0311,
+	0x522b, 0x5313, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3c, 0x0400,
+	0x9816, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212,
+	0x02bc, 0x0210, 0x4a00, 0x7d28, 0x4a02, 0x7d20, 0x4a01, 0x7d19,
+	0x6ddd, 0x0b70, 0x0311, 0x53eb, 0x62c8, 0x7e25, 0x0360, 0x7d02,
+	0x0210, 0x0212, 0x6ac8, 0x7f1f, 0x0212, 0x6ac8, 0x7f1c, 0x0212,
+	0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313,
+	0x9859, 0x6ddd, 0x7802, 0x62c8, 0x6ac8, 0x9858, 0x6dde, 0x0015,
+	0x7802, 0x62c8, 0x6ac8, 0x9858, 0x0015, 0x0015, 0x7801, 0x62d8,
+	0x7c02, 0x0000, 0x9814, 0xc777, 0x62ff, 0x7efd, 0x008b, 0x52c3,
+	0x53cb, 0xc10d, 0x7da3, 0x0200, 0x9806, 0x0200, 0x9803, 0xc19d,
+	0xc0ec, 0x7d69, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da,
+	0x5efa, 0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9870, 0x6d07, 0x5bca,
+	0x5cd2, 0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x4c00,
+	0x7d47, 0x0a70, 0x0211, 0x552a, 0x5212, 0x008d, 0x00bb, 0x4800,
+	0x7c07, 0x05b9, 0x4d00, 0x7c13, 0x6928, 0x7f2d, 0x0400, 0x9881,
+	0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e29, 0x6d28, 0x7f1e, 0x0000, 0x987f, 0x1e20,
+	0x5506, 0x2620, 0x008d, 0x0560, 0x7c08, 0x065f, 0x55c6, 0x063f,
+	0x7e1b, 0x6d0a, 0x7f10, 0x4c00, 0x7d1b, 0x04d8, 0x7d02, 0x008c,
+	0x0020, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e0d, 0x6d28,
+	0x7f02, 0x0000, 0x98c8, 0x0007, 0x680c, 0x6d0c, 0x6507, 0x6d07,
+	0x6d2b, 0x6d28, 0x0007, 0x680c, 0x0007, 0x54d2, 0x0454, 0x98cb,
+	0x6928, 0x7ff1, 0x54d2, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x0288,
+	0x7d9f, 0x0200, 0x9870, 0x0200, 0x9868, 0xc0ec, 0x7d72, 0x0800,
+	0x0970, 0x0111, 0x5111, 0x5ac1, 0x5bc9, 0x028e, 0xc0fe, 0x068a,
+	0x7c6a, 0x5dd9, 0x5ce1, 0x0bff, 0x0311, 0x1bff, 0x03bc, 0x5bd1,
+	0x1a5c, 0x6ac3, 0x63c8, 0x0363, 0x7c05, 0x036f, 0x7d27, 0x0374,
+	0x7c7a, 0x994d, 0xd9e0, 0x3c06, 0x4c00, 0x7df7, 0x028f, 0x1a04,
+	0x6a23, 0x620b, 0x6f23, 0x301f, 0x00aa, 0x0462, 0x7c04, 0x4a00,
+	0x7d0b, 0x2001, 0x990c, 0x048a, 0x620b, 0x2201, 0x1c01, 0x1801,
+	0x02dc, 0x7d02, 0x301f, 0x00aa, 0x048f, 0x1c04, 0x6c07, 0x0488,
+	0x3c1f, 0x6c2b, 0x0045, 0x028e, 0x1a5c, 0x98ed, 0x058f, 0x1d0c,
+	0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d08, 0x007c, 0x7c01, 0x1d04,
+	0x6d23, 0x650b, 0x0488, 0x3c1f, 0x0417, 0x0417, 0x0417, 0x0417,
+	0x059c, 0x6d23, 0x028e, 0x1a34, 0x6ad7, 0x0488, 0x0804, 0x7802,
+	0x650b, 0x6dc8, 0x008c, 0x1a28, 0x6ad7, 0x63c8, 0x034c, 0x6bc8,
+	0x54d1, 0x4c00, 0x7d06, 0x0065, 0x7c02, 0x0101, 0x0025, 0x0400,
+	0x98e9, 0x52c1, 0x53c9, 0x54e1, 0x0453, 0xc10d, 0x7d95, 0x0200,
+	0x98dc, 0x0200, 0x98d5, 0x0200, 0x98dc, 0x55d9, 0x6d07, 0x54d1,
+	0x058a, 0x2508, 0x6dc7, 0x0373, 0x7c03, 0x65c8, 0x6d0b, 0x2408,
+	0x0372, 0x7c04, 0x65c8, 0x6d0b, 0x2408, 0x9962, 0x6cce, 0x65c8,
+	0x6d0a, 0x2404, 0x6d28, 0x6507, 0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3,
+	0x63c8, 0x0334, 0x6bc8, 0x0370, 0x7ca9, 0x0c60, 0x0411, 0x04bb,
+	0x4c00, 0x7da4, 0x0410, 0x1c30, 0x0410, 0x04bb, 0x046d, 0x7d0a,
+	0x047d, 0x7c03, 0x047c, 0x7c01, 0x9916, 0x003b, 0x003a, 0x0039,
+	0x0058, 0x9991, 0x047d, 0x7d03, 0x047c, 0x7d01, 0x9916, 0x005b,
+	0xd9d5, 0x1d18, 0x6d23, 0x650b, 0x0510, 0x003a, 0x0039, 0x0038,
+	0x00ad, 0xd9e0, 0x0c30, 0x0410, 0x04bb, 0x003c, 0x003d, 0x00ac,
+	0xd9d5, 0x007b, 0x7c04, 0x003d, 0x003c, 0x1d0c, 0x99b2, 0x048f,
+	0x1c14, 0x6c23, 0x640b, 0x4401, 0x7d04, 0x005d, 0x005c, 0x1d0c,
+	0x99b2, 0x0310, 0x3b30, 0x4b30, 0x7d01, 0x1b10, 0x0310, 0x003d,
+	0x003c, 0x00ab, 0x6ad7, 0x63c8, 0x6d23, 0x650b, 0x0560, 0x7d03,
+	0x005e, 0xd9c9, 0x9916, 0x003e, 0x0c80, 0x0410, 0x0394, 0xd9c9,
+	0x640b, 0x037f, 0x7d02, 0x1a14, 0x99c6, 0x1a0c, 0x6ad7, 0x6cc8,
+	0x9916, 0x0c7f, 0x0410, 0x03b4, 0x04b8, 0x03ac, 0x640b, 0x6bc8,
+	0x028e, 0x1a04, 0x6ad7, 0x6cc8, 0x0006, 0x058f, 0x1d08, 0x6d23,
+	0x650b, 0x007d, 0x7c01, 0x1d38, 0x007c, 0x7c01, 0x1d1c, 0x0006,
+	0x048b, 0x042c, 0x0454, 0x042b, 0x6ad7, 0x6cc8, 0x0006, 0x1e10,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x99ee, 0x6d07, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28,
+	0x0264, 0x7d08, 0x0b70, 0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18,
+	0x0400, 0x99fd, 0x0212, 0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d,
+	0x0a10, 0x6ed3, 0x6ac8, 0xda38, 0x6a28, 0x7f17, 0x0b70, 0x0311,
+	0x5013, 0xda50, 0x52c0, 0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x99ee,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0xda38, 0x99fb, 0x0200, 0x99eb,
+	0x0007, 0x68cc, 0x6a28, 0x7f01, 0x9a36, 0x0007, 0x6a0c, 0x6a0c,
+	0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0454, 0x9a14,
+	0x05a0, 0x1e08, 0x6ec3, 0x0388, 0x3b03, 0x0015, 0x0015, 0x7802,
+	0x62c8, 0x6a0b, 0x7ee5, 0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b,
+	0x7802, 0x62c8, 0x6a09, 0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006,
+	0x55f0, 0x6207, 0x02a5, 0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a,
+	0x0006, 0x1e10, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7c02, 0x0200,
+	0x9a5d, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9a62, 0x6dd7, 0x0b70, 0x0311, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d65, 0x6ec3, 0x522b, 0x02b9, 0x4a00, 0x7d2c, 0x62c8,
+	0x7e6c, 0x0264, 0x7c46, 0x0212, 0x3aff, 0x008a, 0x05d8, 0x7d03,
+	0x008d, 0x0b01, 0x9a89, 0x0a10, 0x63d0, 0x6ed3, 0x6ac8, 0x6bd7,
+	0x0b00, 0xdaee, 0x4b00, 0x0b70, 0x0311, 0x7c49, 0x0478, 0x7d28,
+	0x522b, 0x02b9, 0x4a00, 0x7cdc, 0x62ff, 0x7e4f, 0x4d00, 0x7c09,
+	0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d, 0x7d01, 0x0201, 0x0400,
+	0x9a62, 0x0400, 0x9a70, 0x62c8, 0x7e40, 0x0212, 0x3aff, 0x008a,
+	0x0b00, 0x00d5, 0x7d07, 0x008d, 0x0a10, 0x63d0, 0x6ed3, 0x6ac8,
+	0x6bd7, 0x0b01, 0xdaee, 0x4b00, 0x0b70, 0x0311, 0x7d01, 0x9ad7,
+	0x62ff, 0x7e2b, 0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d, 0x0200,
+	0x9a62, 0x008f, 0x00d5, 0x7d01, 0x008d, 0xdaee, 0x522b, 0x02b9,
+	0x4a00, 0x7ca6, 0x62ff, 0x7e19, 0x4d00, 0x7c15, 0x5013, 0x52c0,
+	0x53c8, 0x04a5, 0xc10d, 0x7d01, 0x0201, 0x0400, 0x9a62, 0x62ff,
+	0x7e0c, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d,
+	0x7d81, 0x0200, 0x9a62, 0x0400, 0x9a70, 0x0007, 0x6aff, 0x0454,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x0200, 0x9a62, 0x05a0, 0x1e08,
+	0x6ec1, 0x0060, 0x7c03, 0x6edd, 0x62d8, 0x7eef, 0x0015, 0x0060,
+	0x7c04, 0x6ece, 0x6ede, 0x62d8, 0x7ee8, 0x6ecf, 0x6edf, 0x0015,
+	0x7801, 0x62d8, 0x0000, 0x7ee1, 0x2608, 0x0006, 0xc19d, 0xc0ec,
+	0x7d52, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa,
+	0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9b0f, 0x6d03, 0x5bca, 0x5cd2,
+	0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211,
+	0x4c00, 0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9b22,
+	0x4c01, 0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020,
+	0x04a0, 0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d,
+	0x9b20, 0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f,
+	0x5d06, 0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0,
+	0x0454, 0x9b4c, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9,
+	0x4d00, 0x7c02, 0x0400, 0x9b4e, 0x52c0, 0x53c8, 0xc10d, 0x0288,
+	0x7db6, 0x0200, 0x9b0f, 0x0200, 0x9b07, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b63, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9, 0x4a00, 0x7c04,
+	0x62c8, 0x7e1f, 0x0400, 0x9b74, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16, 0x6ac8, 0x7f11,
+	0x0015, 0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e, 0x6ac8, 0x7f09,
+	0x6edf, 0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01,
+	0x9b72, 0x0007, 0x68cc, 0x9b9e, 0x0007, 0x6a0c, 0x0454, 0x62c8,
+	0x7ef8, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd, 0x0200, 0x9b63,
+	0x0200, 0x9b60, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010,
+	0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9bb1, 0x0870,
+	0x0011, 0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12,
+	0x5228, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9bc0, 0x620b, 0x7e06,
+	0x5a06, 0x7f06, 0x0000, 0x2504, 0x7d05, 0x9bc0, 0x0007, 0x680c,
+	0x0007, 0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9bb1,
+	0x0200, 0x9bad, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010,
+	0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9be1, 0x0870,
+	0x0011, 0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c,
+	0x5228, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9bf0,
+	0x5206, 0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c,
+	0x9bf0, 0x0007, 0x680c, 0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28,
+	0x0007, 0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0,
+	0xc10d, 0x7dcf, 0x0200, 0x9be1, 0x0200, 0x9bdd, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d2d, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9c1d, 0x0870, 0x0011, 0x6dd7, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d14, 0x5228, 0x02b9, 0x4b00, 0x7c04,
+	0x62c8, 0x7e0a, 0x0400, 0x9c2c, 0x5206, 0x7e08, 0x6ac8, 0x7f04,
+	0x0000, 0x2504, 0x7d05, 0x9c2c, 0x0007, 0x68ff, 0x0007, 0x0454,
+	0x62c8, 0x7efa, 0x5010, 0x52c0, 0xc10d, 0x7dd7, 0x0200, 0x9c1d,
+	0x0200, 0x9c19, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d7a, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9c50, 0x6ed3,
+	0x6dc5, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d60,
+	0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00, 0x7c02, 0x0400,
+	0x9c60, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03,
+	0x0512, 0x05bc, 0x0510, 0x5dd3, 0x4d00, 0x7d2c, 0x4d02, 0x7d24,
+	0x4d01, 0x7d1e, 0x59e3, 0x0b70, 0x0311, 0x53eb, 0x61c8, 0x7e2b,
+	0x62c8, 0x7e29, 0x65c8, 0x7e27, 0x0360, 0x7d03, 0x0112, 0x0112,
+	0x9c8b, 0x0512, 0x0512, 0x0211, 0x02a9, 0x02ad, 0x6ac8, 0x7f1b,
+	0x2003, 0x4800, 0x7ceb, 0x0b70, 0x0311, 0x5313, 0x51e3, 0x9ca8,
+	0x7802, 0x62c8, 0x6ac8, 0x9ca7, 0x6dce, 0x0015, 0x7802, 0x62c8,
+	0x6ac8, 0x9ca7, 0x6dcf, 0x0015, 0x0015, 0x7801, 0x62d8, 0x7c03,
+	0x0000, 0x55db, 0x9c5e, 0x0007, 0x68ff, 0x55d3, 0x4d00, 0x7d03,
+	0x4d02, 0x7d02, 0x9cb5, 0x0017, 0x0017, 0x55db, 0x009d, 0x55fb,
+	0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454,
+	0x62c8, 0x7ee9, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7d89, 0x0200,
+	0x9c50, 0x0200, 0x9c4d, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d3f,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cd1,
+	0x0b70, 0x0311, 0x6ed3, 0x6dc7, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d24, 0x522b, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9ce2,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x6ecd, 0x0060, 0x7c04,
+	0x62c8, 0x7e11, 0x6ac8, 0x7f0f, 0x0015, 0x0060, 0x7c05, 0x6ece,
+	0x62c8, 0x7e09, 0x6ac8, 0x7f07, 0x6ecf, 0x0015, 0x7801, 0x62d8,
+	0x0000, 0x7e01, 0x9ce0, 0x0007, 0x68cc, 0x0454, 0x62ff, 0x7efb,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dc4, 0x0200, 0x9cd1, 0x0200,
+	0x9cce, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d18, 0x0870, 0x0011,
+	0x6dc7, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228,
+	0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9d27, 0x62c8, 0x7e06, 0x5a06,
+	0x7f06, 0x0000, 0x2504, 0x7d05, 0x9d27, 0x0007, 0x68ff, 0x0007,
+	0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9d18, 0x0200,
+	0x9d14, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d7a, 0x5010, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d48, 0x6dc5,
+	0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d5d, 0x0a70, 0x0211, 0x532a, 0x5212,
+	0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9d5c, 0x008f, 0x05d8, 0x7d01,
+	0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d2c, 0x4d02, 0x7d24,
+	0x4d01, 0x7d1e, 0x59e2, 0x0a70, 0x0211, 0x52ea, 0x61c8, 0x7e2c,
+	0x63c8, 0x7e2a, 0x65c8, 0x7e28, 0x0260, 0x7d03, 0x0112, 0x0112,
+	0x9d83, 0x0512, 0x0512, 0x0311, 0x03a9, 0x03ad, 0x5b06, 0x7f1c,
+	0x2003, 0x4800, 0x7ceb, 0x0a70, 0x0211, 0x5212, 0x51e2, 0x9da1,
+	0x7802, 0x63c8, 0x5b06, 0x9da0, 0x6dce, 0x0015, 0x7802, 0x63c8,
+	0x5b06, 0x9da0, 0x6dcf, 0x0015, 0x0015, 0x7802, 0x63c8, 0x5b06,
+	0x7c03, 0x55da, 0x0000, 0x9d5a, 0x0007, 0x68ff, 0x55d2, 0x4d00,
+	0x7d03, 0x4d02, 0x7d02, 0x9dae, 0x0017, 0x0017, 0x55da, 0x009d,
+	0x55fa, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad,
+	0x0454, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d8a, 0x0200, 0x9d48,
+	0x0200, 0x9d44, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d61, 0x5010,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dc9,
+	0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d47,
+	0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04, 0x63c8,
+	0x7e3d, 0x0400, 0x9dd8, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0,
+	0x0b03, 0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d28, 0x4b02, 0x7d20,
+	0x4b01, 0x7d19, 0x6ddd, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e26,
+	0x0260, 0x7d02, 0x0310, 0x0312, 0x6bc8, 0x7f20, 0x0312, 0x6bc8,
+	0x7f1d, 0x0312, 0x6bc8, 0x7f1a, 0x2003, 0x4800, 0x7cef, 0x0a70,
+	0x0211, 0x5212, 0x9e1c, 0x6ddd, 0x7802, 0x5306, 0x6bc8, 0x9e1b,
+	0x6dde, 0x0015, 0x7802, 0x5306, 0x6bc8, 0x9e1b, 0x0015, 0x0015,
+	0x7802, 0x5306, 0x6bc8, 0x7c02, 0x0000, 0x9dd6, 0xc777, 0x63c8,
+	0x7efd, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7da3, 0x0200, 0x9dc9,
+	0x0200, 0x9dc5, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d60, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9e30, 0x0b70,
+	0x0311, 0x6ec3, 0x6dd5, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d42, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e38,
+	0x0400, 0x9e42, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d20,
+	0x1e94, 0x6ee3, 0x5313, 0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3,
+	0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3, 0x0b70, 0x0311, 0x62c8,
+	0x026e, 0x7d2f, 0x6ac8, 0x7f1c, 0x2501, 0x4d00, 0x7d1d, 0x028e,
+	0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0xde93, 0x9e86,
+	0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8,
+	0x026e, 0x7d17, 0x6ac8, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e40,
+	0x0007, 0x6aff, 0xde95, 0x9ea2, 0x62ff, 0x7efa, 0x0b70, 0x0311,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7da3, 0x0200, 0x9e30, 0x0200,
+	0x9e2d, 0xde93, 0x9ea2, 0x62ff, 0x7eeb, 0x62d0, 0x0b70, 0x0311,
+	0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff, 0x0312, 0x04bb,
+	0x049a, 0x0006, 0x0458, 0x0454, 0x9e86, 0xc19d, 0x0870, 0x0011,
+	0xc0ec, 0x7d52, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9eac, 0x0a70, 0x0211, 0x6dd5, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d34, 0x532a, 0x03b9, 0x4b00,
+	0x7c04, 0x63c8, 0x7e2a, 0x0400, 0x9ebd, 0x038e, 0x1b94, 0x5303,
+	0x0369, 0x7d14, 0x1e94, 0x5306, 0x0348, 0x5b06, 0x2694, 0x5306,
+	0x036e, 0x7d2c, 0x6bc8, 0x7f19, 0x2501, 0x4d00, 0x7d1a, 0x038e,
+	0x1b98, 0x5303, 0x0360, 0x7df3, 0xdf00, 0x9ef3, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5306, 0x036e, 0x7d17, 0x6bc8,
+	0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9ebb, 0x0007, 0x6bff, 0xdf02,
+	0x9f0f, 0x63c8, 0x7efa, 0x0a70, 0x0211, 0x5012, 0x52c0, 0x53c8,
+	0xc10d, 0x7db2, 0x0200, 0x9eac, 0x0200, 0x9ea8, 0xdf00, 0x9f0f,
+	0x63c8, 0x7eeb, 0x63d0, 0x0a70, 0x0211, 0x5012, 0x55f0, 0x03a5,
+	0x0aff, 0x0212, 0x1aff, 0x0212, 0x04ba, 0x049b, 0x0006, 0x0458,
+	0x0454, 0x9ef3, 0x9ef3
+};
+#endif
diff --git a/arch/arm/mach-mx3/time_priv.h b/arch/arm/mach-mx3/time_priv.h
new file mode 100644
index 0000000..5d59c29
--- /dev/null
+++ b/arch/arm/mach-mx3/time_priv.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_TIME_PRIV_H__
+#define __MACH_MX31_TIME_PRIV_H__
+/*!
+ * @file time_priv.h
+ * @brief This file contains OS tick and wdog timer register definitions.
+ *
+ * This file contains OS tick and wdog timer register definitions.
+ *
+ * @ingroup Timers
+ */
+
+#include <asm/hardware.h>
+
+/*
+ * EPIT Control register bit definitions
+ */
+#define EPITCR_CLKSRC_SHIFT		24
+#define EPITCR_CLKSRC_MASK		0x03000000
+#define EPITCR_CLKSRC_OFF		0x00000000
+#define EPITCR_CLKSRC_HIGHFREQ		0x02000000
+#define EPITCR_CLKSRC_32K		0x03000000
+
+#define EPITCR_OM_DISCONNECTED		0x00000000
+#define EPITCR_OM_TOGGLE		0x00400000
+#define EPITCR_OM_CLEAR			0x00800000
+#define EPITCR_OM_SET			0x00C00000
+
+#define EPITCR_STOPEN_ENABLE		0x00200000
+#define EPITCR_WAITEN_ENABLE		0x00080000
+#define EPITCR_DBGEN_ENABLE		0x00040000
+#define EPITCR_IOVW_ENABLE		0x00020000
+#define EPITCR_SWR			0x00010000
+
+#define EPITCR_PRESCALER_MASK		0x0000FFF0
+#define EPITCR_PRESCALER_SHIFT		0x00000004
+
+#define EPITCR_RLD			0x00000008
+#define EPITCR_OCIEN			0x00000004
+#define EPITCR_ENMOD			0x00000002
+#define EPITCR_EN			0x00000001
+
+/*!
+ * GPT Control register bit definitions
+ */
+#define GPTCR_FO3			(1 << 31)
+#define GPTCR_FO2			(1 << 30)
+#define GPTCR_FO1			(1 << 29)
+
+#define GPTCR_OM3_SHIFT			26
+#define GPTCR_OM3_MASK			(7 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_DISCONNECTED		(0 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_TOGGLE		(1 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_CLEAR			(2 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_SET			(3 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_GENERATE_LOW		(7 << GPTCR_OM3_SHIFT)
+
+#define GPTCR_OM2_SHIFT			23
+#define GPTCR_OM2_MASK			(7 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_DISCONNECTED		(0 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_TOGGLE		(1 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_CLEAR			(2 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_SET			(3 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_GENERATE_LOW		(7 << GPTCR_OM2_SHIFT)
+
+#define GPTCR_OM1_SHIFT			20
+#define GPTCR_OM1_MASK			(7 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_DISCONNECTED		(0 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_TOGGLE		(1 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_CLEAR			(2 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_SET			(3 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_GENERATE_LOW		(7 << GPTCR_OM1_SHIFT)
+
+#define GPTCR_IM2_SHIFT			18
+#define GPTCR_IM2_MASK			(3 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_DISABLE	(0 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_RISING	(1 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_FALLING	(2 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_BOTH		(3 << GPTCR_IM2_SHIFT)
+
+#define GPTCR_IM1_SHIFT			16
+#define GPTCR_IM1_MASK			(3 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_DISABLE	(0 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_RISING	(1 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_FALLING	(2 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_BOTH		(3 << GPTCR_IM1_SHIFT)
+
+#define GPTCR_SWR			(1 << 15)
+#define GPTCR_FRR			(1 << 9)
+
+#define GPTCR_CLKSRC_SHIFT		6
+#define GPTCR_CLKSRC_MASK		(7 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_NOCLOCK		(0 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_HIGHFREQ		(2 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLKIN		(3 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLK32K		(7 << GPTCR_CLKSRC_SHIFT)
+
+#define GPTCR_STOPEN			(1 << 5)
+#define GPTCR_DOZEN			(1 << 4)
+#define GPTCR_WAITEN			(1 << 3)
+#define GPTCR_DBGEN			(1 << 2)
+
+#define GPTCR_ENMOD			(1 << 1)
+#define GPTCR_ENABLE			(1 << 0)
+
+#define	GPTSR_OF1			(1 << 0)
+#define	GPTSR_OF2			(1 << 1)
+#define	GPTSR_OF3			(1 << 2)
+#define	GPTSR_IF1			(1 << 3)
+#define	GPTSR_IF2			(1 << 4)
+#define	GPTSR_ROV			(1 << 5)
+
+#define	GPTIR_OF1IE			GPTSR_OF1
+#define	GPTIR_OF2IE			GPTSR_OF2
+#define	GPTIR_OF3IE			GPTSR_OF3
+#define	GPTIR_IF1IE			GPTSR_IF1
+#define	GPTIR_IF2IE			GPTSR_IF2
+#define	GPTIR_ROVIE			GPTSR_ROV
+
+#ifndef	__noinstrument
+#	define	__noinstrument
+#endif
+
+/*
+ * This implements the OS tick timer to generate interrupts every 10ms
+ */
+
+#if !defined(CONFIG_HZ) || (CONFIG_HZ != 100)
+#error CONFIG_HZ is not defined or not equal to 100
+#endif
+
+#if 0				/* not enabled the two wdogs by default */
+#define WDOG1_ENABLE		/* not defined by default */
+#endif
+#define WDOG1_TIMEOUT           4000	/* WDOG1 timeout in ms */
+#define WDOG_SERVICE_PERIOD     (WDOG1_TIMEOUT / 2)	/* time interval in ms to service WDOGs */
+
+#if (WDOG_SERVICE_PERIOD >= (WDOG1_TIMEOUT - 1000 / CONFIG_HZ))
+#error WDOG_SERVICE_PERIOD is too large!
+#endif
+
+/* maximum timeout is 128s based on 2Hz clock */
+#if ((WDOG1_TIMEOUT/1000) > 128)
+#error WDOG time out has to be less than 128 seconds!
+#endif
+
+#define WDOG_WT                 0x8	/* WDOG WT starting bit inside WCR */
+#define WCR_WOE_BIT             (1 << 6)
+#define WCR_WDA_BIT             (1 << 5)
+#define WCR_SRS_BIT             (1 << 4)
+#define WCR_WRE_BIT             (1 << 3)
+#define WCR_WDE_BIT             (1 << 2)
+#define WCR_WDBG_BIT            (1 << 1)
+#define WCR_WDZST_BIT           (1 << 0)
+
+#endif				/* __MACH_MX31_TIME_PRIV_H__ */
-- 
1.5.5.1

