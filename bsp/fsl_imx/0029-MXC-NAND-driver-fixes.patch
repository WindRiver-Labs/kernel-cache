From adf09723844f77899881e930b3f0406d357b6efd Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Wed, 17 Dec 2008 20:27:48 +0300
Subject: [PATCH] MXC NAND driver fixes

The following patch fixes:
 - re-initialization of host->col_addr which is used as byte index
between the successive READID flash commands.
 - compile error when CONFIG_PM is enabled
 - pass on the error code from clk_get()
 - return -ENOMEM in case of failed ioremap()
 - pass on the return value of platform_driver_probe() instead of inventing -ENODEV

Merged from ARM-list

Signed-off-by: Lothar Wassmann <LW@KARO-electronics.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/plat-mxc/include/mach/mxc_nand.h |    1 +
 drivers/mtd/nand/Kconfig                  |    2 +-
 drivers/mtd/nand/mxc_nand.c               |  328 +++++++++++++++++++++++++++--
 3 files changed, 312 insertions(+), 19 deletions(-)

diff --git a/arch/arm/plat-mxc/include/mach/mxc_nand.h b/arch/arm/plat-mxc/include/mach/mxc_nand.h
index 2b972df..c4316d0 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_nand.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_nand.h
@@ -23,5 +23,6 @@
 struct mxc_nand_platform_data {
 	int width;	/* data bus width in bytes */
 	int hw_ecc;	/* 0 if supress hardware ECC */
+	struct flash_platform_data *flash_data;
 };
 #endif /* __ASM_ARCH_NAND_H */
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 73afa1e..0ef73e1 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -427,7 +427,7 @@ config MTD_NAND_FSL_UPM
 
 config MTD_NAND_MXC
 	tristate "MXC NAND support"
-	depends on ARCH_MX2
+	depends on ARCH_MX2 || ARCH_MX3
 	help
 	  This enables the driver for the NAND flash controller on the
 	  MXC processors.
diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c
index 21fd4f1..468557d 100644
--- a/drivers/mtd/nand/mxc_nand.c
+++ b/drivers/mtd/nand/mxc_nand.c
@@ -100,6 +100,14 @@
 #define NFC_CE              (1 << 7)
 #define NFC_ONE_CYCLE       (1 << 8)
 
+#define NFMS (*((volatile u32 *)IO_ADDRESS(CCM_BASE_ADDR+0xc)))
+/*offset of ctl bit which select 8 or 16 bit
+ * for NAND flash device on the EMI*/
+#define NFMS_NF_DWIDTH      31
+/*offset of ctl bit which select 512-byte or
+ * 2k-byte page size for NAND Flash device*/
+#define NFMS_NF_PG_SZ       30
+
 struct mxc_nand_host {
 	struct mtd_info		mtd;
 	struct nand_chip	nand;
@@ -110,6 +118,7 @@ struct mxc_nand_host {
 	int			spare_only;
 	int			status_request;
 	int			pagesize_2k;
+	int			ecc_disabled;
 	uint16_t		col_addr;
 	struct clk		*clk;
 	int			clk_act;
@@ -121,7 +130,7 @@ struct mxc_nand_host {
 /* Define delays in microsec for NAND device operations */
 #define TROP_US_DELAY   2000
 /* Macros to get byte and bit positions of ECC */
-#define COLPOS(x)  ((x) >> 3)
+#define COLPOS(x) ((x) >> 4)
 #define BITPOS(x) ((x) & 0xf)
 
 /* Define single bit Error positions in Main & Spare area */
@@ -141,6 +150,25 @@ static struct nand_ecclayout nand_hw_eccoob_16 = {
 	.oobfree = {{0, 6}, {12, 4}, }
 };
 
+static struct nand_ecclayout nand_hw_eccoob_2k = {
+	.eccbytes = 20,
+	.eccpos = {6, 7, 8, 9, 10, 22, 23, 24, 25, 26,
+		38, 39, 40, 41, 42, 54, 55, 56, 57, 58},
+	.oobavail = 8,
+	.oobfree = {
+		{.offset = 0,
+			.length = 5},
+		{.offset = 11,
+			.length = 10},
+		{.offset = 27,
+			.length = 10},
+		{.offset = 43,
+			.length = 10},
+		{.offset = 59,
+			.length = 5}
+	}
+};
+
 #ifdef CONFIG_MTD_PARTITIONS
 static const char *part_probes[] = { "RedBoot", "cmdlinepart", NULL };
 #endif
@@ -251,6 +279,95 @@ static void send_prog_page(struct mxc_nand_host *host, uint8_t buf_id,
 	wait_op_done(host, TROP_US_DELAY, spare_only, true);
 }
 
+/*!
+ * This function will correct the single bit ECC error
+ *
+ * @param  buf_id   Specify Internal RAM Buffer number (0-3)
+ * @param  eccpos   Ecc byte and bit position
+ * @param  bSpareOnly   set to true if only spare area needs correction
+ */
+static void mxc_nd_correct_error(struct mxc_nand_host *host,
+		u8 buf_id, u16 eccpos, bool bSpareOnly)
+{
+	u16 col, tmp;
+	u8 pos;
+	void __iomem *buf;
+
+	/* Get col & bit position of error
+	 * these macros works for both 8 & 16 bits */
+
+	col = COLPOS(eccpos);   /* Get half-word position */
+	pos = BITPOS(eccpos);   /* Get bit position */
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+			"mxc_nd_correct_error (col=%d pos=%d)\n", col, pos);
+
+	/* Set the pointer for main / spare area */
+	if (!bSpareOnly)
+		buf = host->regs + MAIN_AREA0 +
+			col + (256 * buf_id);
+	else
+		buf = host->regs + SPARE_AREA0 + col + (8 * buf_id);
+
+	/* Fix the data */
+	tmp = readw(buf);
+	tmp ^= (1 << pos);
+	writew(tmp, buf);
+}
+
+/*!
+ * This function will maintains state of single bit Error
+ * in Main & spare  area
+ *
+ * @param buf_id    Specify Internal RAM Buffer number (0-3)
+ * @param spare     set to true if only spare area needs correction
+ */
+static void mxc_nd_correct_ecc(struct mxc_nand_host *host,
+		u8 buf_id, bool spare)
+{
+	u16 value, ecc_status, tmp;
+
+	/* Read the ECC result */
+	ecc_status = readw(host->regs + NFC_ECC_STATUS_RESULT);
+	DEBUG(MTD_DEBUG_LEVEL3,
+			"mxc_nd_correct_ecc (Ecc status=%x)\n", ecc_status);
+
+	if (((ecc_status & 0xC) == MAIN_SINGLEBIT_ERROR)
+			|| ((ecc_status & 0x3) == SPARE_SINGLEBIT_ERROR)) {
+		if (host->ecc_disabled) {
+			if ((ecc_status & 0xC) == MAIN_SINGLEBIT_ERROR) {
+				value = readw(host->regs + NFC_RSLTMAIN_AREA);
+				/* Correct single bit error in Mainarea
+				 * NFC will not correct the error in
+				 * current page */
+				mxc_nd_correct_error(host, buf_id, value, false);
+			}
+
+			if ((ecc_status & 0x3) == SPARE_SINGLEBIT_ERROR) {
+				value = readw(host->regs + NFC_RSLTSPARE_AREA);
+				/* Correct single bit error in Mainarea
+				 * NFC will not correct the error in
+				 * current page */
+				mxc_nd_correct_error(host, buf_id, value, true);
+			}
+		} else {
+			/* Disable ECC  */
+			tmp = readw(host->regs + NFC_CONFIG1);
+			tmp &= ~(NFC_ECC_EN);
+			writew(tmp, host->regs + NFC_CONFIG1);
+			host->ecc_disabled = 1;
+		}
+	} else if (ecc_status == 0) {
+		if (host->ecc_disabled) {
+			/* Enable ECC */
+			tmp = readw(host->regs + NFC_CONFIG1);
+			tmp |= NFC_ECC_EN;
+			writew(tmp, host->regs + NFC_CONFIG1);
+			host->ecc_disabled = 0;
+		}
+	}
+}
+
 /* Requests NANDFC to initated the transfer of data from the
  * NAND device into in the NANDFC ram buffer. */
 static void send_read_page(struct mxc_nand_host *host, uint8_t buf_id,
@@ -275,6 +392,13 @@ static void send_read_page(struct mxc_nand_host *host, uint8_t buf_id,
 
 	/* Wait for operation to complete */
 	wait_op_done(host, TROP_US_DELAY, spare_only, true);
+
+	/* If there are single bit errors in
+	 * two consecutive page reads then
+	 * the error is not  corrected by the
+	 * NFC for the second page.
+	 * Correct single bit error in driver */
+	mxc_nd_correct_ecc(host, buf_id, spare_only);
 }
 
 /* Request the NANDFC to perform a read of the NAND device ID. */
@@ -685,6 +809,35 @@ static void mxc_nand_select_chip(struct mtd_info *mtd, int chip)
 	}
 }
 
+/* read column 464-465 byte but only 464 for bad block marker */
+#define NFC_BB_MARKER_464       (0x600 + 464)
+/* read column 0-1 byte, but only 1 is used for swapped main area data */
+#define NFC_BB_MARKER_SP_0      (0x800 + 52)
+
+/*
+ * This function does the trick of swapping the 464th byte in the last RAM
+ * buffer in the main area with the 0th byte in the spare area. This seems
+ * to be the optimal way of addressing the NFC imcompatibility problem with
+ * the NAND flash out of factory in terms of BI field.
+ * Note: this function only operates on the NFC's internal RAM buffers and
+ * for 2K page only.
+ */
+static void mxc_nand_swap_2k_bi_main_sp(struct mtd_info *mtd)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	u16 tmp1, tmp2, new_tmp1;
+
+	tmp1 = readw(host->regs + NFC_BB_MARKER_464);
+	tmp2 = readw(host->regs + NFC_BB_MARKER_SP_0);
+
+	new_tmp1 = (tmp1 & 0xFF00) | (tmp2 >> 8);
+	tmp2 = (tmp1 << 8) | (tmp2 & 0xFF);
+	writew(new_tmp1, host->regs + NFC_BB_MARKER_464);
+	writew(tmp2, host->regs + NFC_BB_MARKER_SP_0);
+}
+
+
 /* Used by the upper layer to write command to NAND Flash for
  * different operations to be carried out on NAND Flash */
 static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
@@ -693,6 +846,7 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 	struct nand_chip *nand_chip = mtd->priv;
 	struct mxc_nand_host *host = nand_chip->priv;
 	int useirq = true;
+	uint16_t tmp;
 
 	DEBUG(MTD_DEBUG_LEVEL3,
 	      "mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",
@@ -755,6 +909,17 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 		break;
 
 	case NAND_CMD_PAGEPROG:
+		if (host->ecc_disabled) {
+			/* Enable Ecc for page writes */
+			tmp = readw(host->regs + NFC_CONFIG1);
+			tmp |= NFC_ECC_EN;
+			writew(tmp, host->regs + NFC_CONFIG1);
+		}
+
+		/* bi swap for 2k page size */
+		if (host->pagesize_2k)
+			mxc_nand_swap_2k_bi_main_sp(mtd);
+
 		send_prog_page(host, 0, host->spare_only);
 
 		if (host->pagesize_2k) {
@@ -796,7 +961,8 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 
 		if (host->pagesize_2k) {
 			send_addr(host, (page_addr >> 8) & 0xFF, false);
-			if (mtd->size >= 0x40000000)
+			/* One more address cycle for higher density devices */
+			if (mtd->size >= 0x10000000)
 				send_addr(host, (page_addr >> 16) & 0xff, true);
 		} else {
 			/* One more address cycle for higher density devices */
@@ -826,15 +992,24 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 			send_read_page(host, 1, host->spare_only);
 			send_read_page(host, 2, host->spare_only);
 			send_read_page(host, 3, host->spare_only);
+			/* bi swap for 2k page size */
+			mxc_nand_swap_2k_bi_main_sp(mtd);
 		} else
 			send_read_page(host, 0, host->spare_only);
 		break;
 
 	case NAND_CMD_READID:
+		host->col_addr = 0;
 		send_read_id(host);
 		break;
 
 	case NAND_CMD_PAGEPROG:
+		if (host->ecc_disabled) {
+			/* Enable Ecc for page writes */
+			tmp = readw(host->regs + NFC_CONFIG1);
+			tmp |= NFC_ECC_EN;
+			writew(tmp, host->regs + NFC_CONFIG1);
+		}
 		break;
 
 	case NAND_CMD_STATUS:
@@ -845,12 +1020,103 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 	}
 }
 
+/* Define some generic bad / good block scan pattern
+ * which are used while scanning a device for factory
+ * marked good / bad blocks. */
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr smallpage_memorybased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr largepage_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/* Generic flash bbt decriptors*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE |
+		NAND_BBT_WRITE | NAND_BBT_2BIT | NAND_BBT_VERSION |
+		NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE |
+		NAND_BBT_WRITE | NAND_BBT_2BIT | NAND_BBT_VERSION |
+		NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+static int mxc_nand_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	struct mxc_nand_host *host = this->priv;
+
+	/* Config before scanning */
+	/* Do not rely on NFMS_NF_PG_SZ,
+	 * set/clear NFMS bit based on mtd->writesize */
+	if (mtd->writesize == 2048) {
+		NFMS |= (1 << NFMS_NF_PG_SZ);
+		host->pagesize_2k = 1;
+	} else {
+		/* This case strangly happened on MXC91321 P1.2.2 */
+		if ((NFMS >> NFMS_NF_PG_SZ) & 0x1) {
+			printk(KERN_INFO
+					"Oops... NFMS Bit set for 512B Page,"
+					"resetting it. [RCSR: 0x%08x]\n",
+					NFMS);
+			NFMS &= ~(1 << NFMS_NF_PG_SZ);
+		}
+		host->pagesize_2k = 0;
+	}
+
+	if (host->pagesize_2k)
+		this->ecc.layout = &nand_hw_eccoob_2k;
+
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
+	/* update flash based bbt */
+	this->options |= NAND_USE_FLASH_BBT;
+
+	if (!this->badblock_pattern) {
+		if (mtd->writesize == 2048)
+			this->badblock_pattern = &smallpage_memorybased;
+		else
+			this->badblock_pattern = (mtd->writesize > 512) ?
+				&largepage_memorybased : &smallpage_memorybased;
+	}
+
+	/* Build bad block table */
+	return nand_scan_bbt(mtd, this->badblock_pattern);
+}
+
 static int __init mxcnd_probe(struct platform_device *pdev)
 {
 	struct nand_chip *this;
 	struct mtd_info *mtd;
 	struct mxc_nand_platform_data *pdata = pdev->dev.platform_data;
 	struct mxc_nand_host *host;
+	struct flash_platform_data *flash_data = pdata->flash_data;
 	struct resource *res;
 	uint16_t tmp;
 	int err = 0, nr_parts = 0;
@@ -879,10 +1145,13 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 	this->write_buf = mxc_nand_write_buf;
 	this->read_buf = mxc_nand_read_buf;
 	this->verify_buf = mxc_nand_verify_buf;
+	this->scan_bbt = mxc_nand_scan_bbt;
 
 	host->clk = clk_get(&pdev->dev, "nfc_clk");
-	if (IS_ERR(host->clk))
+	if (IS_ERR(host->clk)) {
+		err = PTR_ERR(host->clk);
 		goto eclk;
+	}
 
 	clk_enable(host->clk);
 	host->clk_act = 1;
@@ -895,7 +1164,7 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 
 	host->regs = ioremap(res->start, res->end - res->start + 1);
 	if (!host->regs) {
-		err = -EIO;
+		err = -ENOMEM;
 		goto eres;
 	}
 
@@ -952,10 +1221,19 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 		this->ecc.layout = &nand_hw_eccoob_16;
 	}
 
+	err = nand_scan_ident(mtd, 1);
+	if (!err) {
+		if (mtd->writesize == 2048) {
+			this->ecc.layout =  &nand_hw_eccoob_2k;
+			host->pagesize_2k = 1;
+		} else
 	host->pagesize_2k = 0;
+	} else
+		goto escan;
+
 
 	/* Scan to find existence of the device */
-	if (nand_scan(mtd, 1)) {
+	if (nand_scan_tail(mtd)) {
 		DEBUG(MTD_DEBUG_LEVEL0,
 		      "MXC_ND: Unable to find any NAND device.\n");
 		err = -ENXIO;
@@ -964,10 +1242,14 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 
 	/* Register the partitions */
 #ifdef CONFIG_MTD_PARTITIONS
+	mtd->name = "mxc_nand";
 	nr_parts =
 	    parse_mtd_partitions(mtd, part_probes, &host->parts, 0);
 	if (nr_parts > 0)
 		add_mtd_partitions(mtd, host->parts, nr_parts);
+	else if (flash_data->parts)
+		add_mtd_partitions(mtd, flash_data->parts,
+				flash_data->nr_parts);
 	else
 #endif
 	{
@@ -1010,30 +1292,38 @@ static int __devexit mxcnd_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int mxcnd_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct mtd_info *info = platform_get_drvdata(pdev);
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
 	int ret = 0;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND : NAND suspend\n");
-	if (info)
-		ret = info->suspend(info);
+	if (mtd)
+		ret = mtd->suspend(mtd);
 
-	/* Disable the NFC clock */
-	clk_disable(nfc_clk);	/* FIXME */
+	if (host->clk_act) {
+		/* Disable the NFC clock */
+		clk_disable(host->clk);
+	}
 
 	return ret;
 }
 
 static int mxcnd_resume(struct platform_device *pdev)
 {
-	struct mtd_info *info = platform_get_drvdata(pdev);
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
 	int ret = 0;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND : NAND resume\n");
-	/* Enable the NFC clock */
-	clk_enable(nfc_clk);	/* FIXME */
 
-	if (info)
-		info->resume(info);
+	if (host->clk_act) {
+		/* Enable the NFC clock */
+		clk_enable(host->clk);
+	}
+	if (mtd)
+		mtd->resume(mtd);
 
 	return ret;
 }
@@ -1054,13 +1344,15 @@ static struct platform_driver mxcnd_driver = {
 
 static int __init mxc_nd_init(void)
 {
+	int ret;
+
 	/* Register the device driver structure. */
 	pr_info("MXC MTD nand Driver\n");
-	if (platform_driver_probe(&mxcnd_driver, mxcnd_probe) != 0) {
+	ret = platform_driver_probe(&mxcnd_driver, mxcnd_probe);
+	if (ret != 0) {
 		printk(KERN_ERR "Driver register failed for mxcnd_driver\n");
-		return -ENODEV;
 	}
-	return 0;
+	return ret;
 }
 
 static void __exit mxc_nd_cleanup(void)
-- 
1.5.5.1

