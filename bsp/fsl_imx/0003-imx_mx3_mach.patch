From 7d598ddecf1667a2b0bf333840fde524eb973979 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Mon, 27 Oct 2008 14:15:11 +0800
Subject: [PATCH] imx_mx3_mach

MX3 arch common stuff. Add devices registeration in device.c.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/Makefile    |    2 +-
 arch/arm/mach-mx3/cpu.c       |   82 ++
 arch/arm/mach-mx3/devices.c   |  350 +++++++
 arch/arm/mach-mx3/dma.c       |  720 ++++++++++++++
 arch/arm/mach-mx3/iomux.c     |  252 +++++
 arch/arm/mach-mx3/mm.c        |   17 +-
 arch/arm/mach-mx3/mx31_gpio.c | 2166 +++++++++++++++++++++++++++++++++++++++++
 7 files changed, 3587 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-mx3/cpu.c
 create mode 100644 arch/arm/mach-mx3/dma.c
 create mode 100644 arch/arm/mach-mx3/mx31_gpio.c

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 8b21abb..07d46da 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y			:= mm.o clock.o devices.o iomux.o
+obj-y			:= mm.o clock.o devices.o iomux.o cpu.o dma.o mx31_gpio.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
 obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o
 obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
diff --git a/arch/arm/mach-mx3/cpu.c b/arch/arm/mach-mx3/cpu.c
new file mode 100644
index 0000000..336f228
--- /dev/null
+++ b/arch/arm/mach-mx3/cpu.c
@@ -0,0 +1,82 @@
+/*
+ *  Copyright (C) 2001 Deep Blue Solutions Ltd.
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*!
+ * @file cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup System
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/cacheflush.h>
+#include <mach/clock.h>
+
+const u32 system_rev_tbl[SYSTEM_REV_NUM][2] = {
+	/* SREV, own defined ver */
+	{0x00, CHIP_REV_1_0},	/* MX31 PASS 1 */
+	{0x10, CHIP_REV_1_1},	/* MX31 PASS 1.1 */
+	{0x20, CHIP_REV_2_0},	/* MX31 PASS 2 FIXME: confirm */
+};
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	/* Setup Peripheral Port Remap register for AVIC */
+	asm("ldr r0, =0xC0000015				\n\
+			mcr p15, 0, r0, c15, c2, 4");
+}
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	unsigned long aips_reg;
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
+
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index e08c6a8..9e938b7 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -1,6 +1,8 @@
 /*
  * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -21,8 +23,14 @@
 #include <linux/platform_device.h>
 #include <linux/serial.h>
 #include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+
 #include <mach/hardware.h>
 #include <mach/imx-uart.h>
+#include <mach/spba.h>
+#include <asm/plat-mxc/mxc_spi.h>
+#include <asm/plat-mxc/mxc_mci.h>
 
 static struct resource uart0[] = {
 	{
@@ -152,6 +160,7 @@ int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata)
 	return 0;
 }
 
+#ifdef ARCH_REQUIRE_GPIOLIB
 /* GPIO port description */
 static struct mxc_gpio_port imx_gpio_ports[] = {
 	[0] = {
@@ -178,3 +187,344 @@ int __init mxc_register_gpios(void)
 {
 	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
 }
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXC) || defined(CONFIG_RTC_DRV_MXC_MODULE)
+static struct resource mxc_rtc_resources[] = {
+	{
+		.start = RTC_BASE_ADDR,
+		.end = RTC_BASE_ADDR + 0x30,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_RTC,
+		.end = MXC_INT_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.num_resources  =   ARRAY_SIZE(mxc_rtc_resources),
+	.resource   =   mxc_rtc_resources,
+};
+
+int __init mxc_init_rtc(void)
+{
+	return platform_device_register(&mxc_rtc_device);
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource mxc_wdt_resources[] = {
+	{
+		.start = WDOG_BASE_ADDR,
+		.end = WDOG_BASE_ADDR + 0x30,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_wdt_resources),
+	.resource = mxc_wdt_resources,
+};
+
+int __init mxc_init_wdt(void)
+{
+	return platform_device_register(&mxc_wdt_device);
+}
+#endif
+
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+
+static struct mxc_mmc_platform_data mxc_mmc_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxc_sdhc1_resources[] = {
+	[0] = {
+		.start = MMC_SDHC1_BASE_ADDR,
+		.end = MMC_SDHC1_BASE_ADDR + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_MMC_SDHC1,
+		.end = MXC_INT_MMC_SDHC1,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start = MXC_SDIO1_CARD_IRQ,
+		.end = MXC_SDIO1_CARD_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxc_sdhc2_resources[] = {
+	[0] = {
+		.start = MMC_SDHC2_BASE_ADDR,
+		.end = MMC_SDHC2_BASE_ADDR + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_MMC_SDHC2,
+		.end = MXC_INT_MMC_SDHC2,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start = MXC_SDIO2_CARD_IRQ,
+		.end = MXC_SDIO2_CARD_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxc_sdhc1_device = {
+	.name = "mxc_mci",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_mmc_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_sdhc1_resources),
+	.resource = mxc_sdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxc_sdhc2_device = {
+	.name = "mxc_mci",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_mmc_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_sdhc2_resources),
+	.resource = mxc_sdhc2_resources,
+};
+
+int __init mxc_init_mmc(void)
+{
+	int ret;
+	int cd_irq;
+
+    cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxc_sdhc1_device.resource[2].start = cd_irq;
+		mxc_sdhc1_device.resource[2].end = cd_irq;
+	}
+	cd_irq = 0;
+
+    if (cd_irq) {
+		mxc_sdhc2_device.resource[2].start = cd_irq;
+		mxc_sdhc2_device.resource[2].end = cd_irq;
+	}
+
+    spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
+	ret = platform_device_register(&mxc_sdhc1_device);
+	if (!ret && !machine_is_mx31lite()) {
+		spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
+		ret = platform_device_register(&mxc_sdhc2_device);
+	}
+	return ret;
+}
+#endif
+
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxc_spi1_resources[] = {
+	[0] = {
+		.start = CSPI1_BASE_ADDR,
+		.end = CSPI1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_CSPI1,
+		.end = MXC_INT_CSPI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxc_spi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = "cspi_clk.0"
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxc_spi1_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_spi1_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi1_resources),
+	.resource = mxc_spi1_resources,
+};
+#endif	/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxc_spi2_resources[] = {
+	[0] = {
+		.start = CSPI2_BASE_ADDR,
+		.end = CSPI2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_CSPI2,
+		.end = MXC_INT_CSPI2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxc_spi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock  = "cspi_clk.1"
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxc_spi2_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_spi2_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi2_resources),
+	.resource = mxc_spi2_resources,
+};
+
+#endif	/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxc_spi3_resources[] = {
+	[0] = {
+		.start = CSPI3_BASE_ADDR,
+		.end = CSPI3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_CSPI3,
+		.end = MXC_INT_CSPI3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxc_spi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = "cspi_clk.2"
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxc_spi3_device = {
+	.name = "mxc_spi",
+	.id = 3,
+	.dev = {
+		.platform_data = &mxc_spi3_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi3_resources),
+	.resource = mxc_spi3_resources,
+};
+#endif	/* CONFIG_SPI_MXC_SELECT3 */
+
+int __init mxc_init_spi(void)
+{
+	int ret = 0;
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	ret = platform_device_register(&mxc_spi1_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+#endif	/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	ret = platform_device_register(&mxc_spi2_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+#endif	/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	ret = platform_device_register(&mxc_spi3_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_3\n");
+#endif	/* CONFIG_SPI_MXC_SELECT3 */
+	return ret;
+}
+#endif /*CONFIG_SPI_MXC*/
+
+#if defined(CONFIG_PCMCIA_MX3) || defined(CONFIG_PCMCIA_MX3_MODULE)
+
+static struct platform_device mxc_pcmcia_device = {
+	.name = "mxc_pcmcia",
+	.id = 0,
+};
+
+int __init mxc_init_pcmcia(void)
+{
+	return platform_device_register(&mxc_pcmcia_device);
+}
+#endif
+
+
+#if defined(CONFIG_BLK_DEV_IDE_MXC) || defined(CONFIG_BLK_DEV_IDE_MXC_MODULE)
+
+static struct resource mxc_ide_resources[] = {
+	[0] = {
+		.start = ATA_BASE_ADDR,
+		.end = ATA_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_ATA,
+		.end = MXC_INT_ATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*! Device Definition for MXC ATA */
+static struct platform_device mxc_ide_device = {
+	.name = "mxc_ide",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_ide_resources),
+	.resource = mxc_ide_resources,
+};
+
+int __init mxc_init_ide(void)
+{
+	return platform_device_register(&mxc_ide_device);
+}
+#endif /*CONFIG_BLK_DEV_IDE_MXC*/
diff --git a/arch/arm/mach-mx3/dma.c b/arch/arm/mach-mx3/dma.c
new file mode 100644
index 0000000..b1e28c3
--- /dev/null
+++ b/arch/arm/mach-mx3/dma.c
@@ -0,0 +1,720 @@
+/*
+ *  Copyright 2004 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <mach/serial.h>
+#include <mach/sdma.h>
+
+#define MXC_MMC_BUFFER_ACCESS     0x38
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_FIRI_TXFIFO           0x14
+#define MXC_SDHC_MMC_WML          16
+#define MXC_SDHC_SD_WML           64
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_FIRI_WML              16
+#define MXC_UARTUTXD            0x040
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+		.watermark_level = UART1_UFCR_RXTL,
+		.per_address = UART1_BASE_ADDR,
+		.peripheral_type = UART,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_UART1_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+		.watermark_level = UART1_UFCR_TXTL,
+		.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+		.peripheral_type = UART,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_UART1_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+		.watermark_level = UART2_UFCR_RXTL,
+		.per_address = UART2_BASE_ADDR,
+		.peripheral_type = UART,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_UART2_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+		.watermark_level = UART2_UFCR_TXTL,
+		.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+		.peripheral_type = UART,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_UART2_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+		.watermark_level = UART3_UFCR_RXTL,
+		.per_address = UART3_BASE_ADDR,
+		.peripheral_type = UART_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_UART3_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+		.watermark_level = UART3_UFCR_TXTL,
+		.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+		.peripheral_type = UART_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_UART3_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+		.watermark_level = UART4_UFCR_RXTL,
+		.per_address = UART4_BASE_ADDR,
+		.peripheral_type = UART,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_UART4_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+		.watermark_level = UART4_UFCR_TXTL,
+		.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+		.peripheral_type = UART,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_UART4_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+		.watermark_level = UART5_UFCR_RXTL,
+		.per_address = UART5_BASE_ADDR,
+		.peripheral_type = UART,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_UART5_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+		.watermark_level = UART5_UFCR_TXTL,
+		.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+		.peripheral_type = UART,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_UART5_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SDHC_MMC_WML,
+		.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+		.peripheral_type = MMC,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SDHC1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SDHC_SD_WML,
+		.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+		.peripheral_type = MMC,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SDHC1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SDHC_MMC_WML,
+		.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+		.peripheral_type = MMC,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SDHC2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SDHC_SD_WML,
+		.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+		.peripheral_type = MMC,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SDHC2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI1_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI1_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_16BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_RXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_SSI2_RX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+		.watermark_level = MXC_SSI_TXFIFO_WML,
+		.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+		.peripheral_type = SSI_SP,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_SSI2_TX2,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_rx_params = {
+	.chnl_params = {
+		.watermark_level = MXC_FIRI_WML,
+		.per_address = FIRI_BASE_ADDR,
+		.peripheral_type = FIRI,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_FIRI_RX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_FIR_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_tx_params = {
+	.chnl_params = {
+		.watermark_level = MXC_FIRI_WML,
+		.per_address = FIRI_BASE_ADDR + MXC_FIRI_TXFIFO,
+		.peripheral_type = FIRI,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_FIRI_TX,
+		.bd_number = 32,
+		.word_size = TRANSFER_8BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_FIR_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+		.peripheral_type = MEMORY,
+		.transfer_type = emi_2_emi,
+		.bd_number = 32,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+		.watermark_level = MXC_IDE_DMA_WATERMARK,
+		.per_address = ATA_DMA_BASE_ADDR,
+		.peripheral_type = ATA,
+		.transfer_type = per_2_emi,
+		.event_id = DMA_REQ_ATA_TX_END,
+		.event_id2 = DMA_REQ_ATA_RX,
+		.bd_number = MXC_IDE_DMA_BD_NR,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+		.watermark_level = MXC_IDE_DMA_WATERMARK,
+		.per_address = ATA_DMA_BASE_ADDR + 0x18,
+		.peripheral_type = ATA,
+		.transfer_type = emi_2_per,
+		.event_id = DMA_REQ_ATA_TX_END,
+		.event_id2 = DMA_REQ_ATA_TX,
+		.bd_number = MXC_IDE_DMA_BD_NR,
+		.word_size = TRANSFER_32BIT,
+	},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_FIR_RX, &mxc_sdma_fir_rx_params},
+	{MXC_DMA_FIR_TX, &mxc_sdma_fir_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+		channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+	/* No channels statically allocated for MX31 */
+}
diff --git a/arch/arm/mach-mx3/iomux.c b/arch/arm/mach-mx3/iomux.c
index 3dda1fe..540ae1c 100644
--- a/arch/arm/mach-mx3/iomux.c
+++ b/arch/arm/mach-mx3/iomux.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ * Copyright (c) 2008 Wind River Systems, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -25,6 +26,7 @@
 #include <mach/gpio.h>
 #include <mach/iomux-mx3.h>
 
+#ifndef CONFIG_MACH_MX31LITE
 /*
  * IOMUX register (base) addresses
  */
@@ -109,3 +111,253 @@ void mxc_iomux_set_gpr(enum iomux_gp_func gp, bool en)
 }
 EXPORT_SYMBOL(mxc_iomux_set_gpr);
 
+#else /*CONFIG_MACH_MX31LITE*/
+
+/*!
+ * 4 control fields per MUX register
+ */
+#define MUX_CTL_FIELDS	4
+
+/*!
+ * 3 control fields per PAD register
+ */
+#define PAD_CTL_FIELDS	3
+
+/*!
+ * Maximum number of MUX pins
+ * Number of pins = (highest iomux reg - lowest iomux reg + 1) * (4 pins/reg)
+ */
+#define MUX_PIN_NUM_MAX \
+	(((u32 *)IOMUXSW_MUX_END - (u32 *)IOMUXSW_MUX_CTL + 1) * MUX_CTL_FIELDS)
+/*!
+ * Number of pad controls =
+ *		(highest pad ctl reg - lowest
+ *		pad ctl reg + 1) * (3 pins/reg)
+ */
+#define PAD_CTL_NUM_MAX \
+	(((u32 *)IOMUXSW_PAD_END - \
+	  (u32 *)IOMUXSW_PAD_CTL + 1) * PAD_CTL_FIELDS)
+
+#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & \
+		((1 << (MUX_F - MUX_I)) - 1))
+#define PIN_TO_IOMUX_FIELD(pin) ((pin >> MUX_F) & \
+		((1 << (PAD_I - MUX_F)) - 1))
+
+/*!
+ * 8 bits for each MUX control field
+ */
+#define MUX_CTL_BIT_LEN		8
+
+/*!
+ * 10 bits for each PAD control field
+ */
+#define MUX_PAD_BIT_LEN		10
+
+/*
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+		IOMUXGPR = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x008,    /*!< General purpose */
+		IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x00C, /*!< MUX control */
+		IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x150, /*!< last MUX control register */
+		IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x154, /*!< Pad control */
+		IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x308, /*!< last Pad control register */
+		IOMUXINT_OBS1 = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x000,   /*!< Observe interrupts 1 */
+		IOMUXINT_OBS2 = IO_ADDRESS(IOMUXC_BASE_ADDR)
+		+ 0x004,   /*!< Observe interrupts 2 */
+};
+
+/* len - mask bit length; fld - mask bit field.
+ * Example, to have the mask:
+ * 0xFF000000, use GET_FIELD_MASK(8, 3).
+ * Translate in plain language:
+ * "set the 3rd (0-based) 8-bit-long
+ * field to all 1's */
+#define GET_FIELD_MASK(len, fld)    (((1 << len) - 1) << (len * fld))
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+
+/*!
+ * This function is used to configure a pin
+ * through the IOMUX module.
+ * FIXED ME: for backward compatible.
+ * Will be static function!
+ * @param  pin      a pin number as defined
+ * in #iomux_pin_name_t
+ * @param  out      an output function as defined in
+ *#iomux_pin_ocfg_t
+ * @param  in       an input function as defined in
+ * #iomux_pin_icfg_t
+ *
+ * @return      0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		iomux_pin_icfg_t in)
+{
+	u32 reg, l, ret = 0;
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u32 mux_mask = GET_FIELD_MASK(MUX_CTL_BIT_LEN, mux_field);
+	u8 *rp;
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		(mux_field >= MUX_CTL_FIELDS));
+
+	reg = IOMUXSW_MUX_CTL + (mux_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~mux_mask)) |
+		(((out << 4) | in) << (mux_field * MUX_CTL_BIT_LEN));
+	__raw_writel(l, reg);
+	/*
+     * Log a warning if a pin changes ownership
+     */
+	rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+	if (out & *rp && *rp != ((out << 4) | in)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 * */
+	if (pin != MX31_PIN_CTS1 &&
+				pin != MX31_PIN_RTS1 &&
+				pin != MX31_PIN_DCD_DCE1 &&
+				pin != MX31_PIN_DSR_DTE1 &&
+				pin != MX31_PIN_DTR_DTE1 &&
+				pin != MX31_PIN_RI_DCE1 &&
+				pin != MX31_PIN_DSR_DCE1 &&
+				pin != MX31_PIN_DTR_DCE1 &&
+				pin != MX31_PIN_RXD1 && pin !=
+				MX31_PIN_TXD1) {
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+					" config changed, index=%d field=%d,"
+					" prev=0x%x new=0x%x\n", mux_index,
+					mux_field, *rp, (out << 4) | in);
+			}
+		ret = -EINVAL;
+	}
+	*rp = (out << 4) | in;
+	spin_unlock(&gpio_mux_lock);
+	return ret;
+}
+EXPORT_SYMBOL(iomux_config_mux);
+
+/*!
+ * Request ownership for an IO pin. This
+ * function has to be the first one
+ * being called before that pin is used.
+ * The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin      a name defined by
+ * iomux_pin_name_t
+ * @param  out      an output function as defined in
+ * #iomux_pin_ocfg_t
+ * @param  in       an input function as defined in
+ * #iomux_pin_icfg_t
+ *
+ * @return      0 if successful; Non-zero otherwise
+ * */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+	iomux_pin_icfg_t in)
+{
+	int ret = iomux_config_mux(pin, out, in);
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO)
+		ret |= mxc_request_gpio(pin);
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin      a name defined by
+ * iomux_pin_name_t
+ * @param  out      an output function as defined in
+ * #iomux_pin_ocfg_t
+ * @param  in       an input function as defined in
+ * #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		iomux_pin_icfg_t in)
+{
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u8 *rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		(mux_field >= MUX_CTL_FIELDS));
+
+	*rp = 0;
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO)
+		mxc_free_gpio(pin);
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in
+ * #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in
+ * #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 reg, l;
+	u32 pad_index = (pin >> PAD_I) & ((1 << (PAD_F - PAD_I)) - 1);
+	u32 pad_field = (pin >> PAD_F) & ((1 << (MUX_IO_I - PAD_F)) - 1);
+	u32 pad_mask = GET_FIELD_MASK(MUX_PAD_BIT_LEN, pad_field);
+	MXC_ERR_CHK((pad_index > (PAD_CTL_NUM_MAX / PAD_CTL_FIELDS - 1)) ||
+	(pad_field >= PAD_CTL_FIELDS));
+
+	reg = IOMUXSW_PAD_CTL + (pad_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~pad_mask)) | (config << (pad_field * MUX_PAD_BIT_LEN));
+	__raw_writel(l, reg);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_pad(iomux_pin_name_t pin, u32 config)
+{
+	mxc_iomux_set_pad(pin, config);
+}
+EXPORT_SYMBOL(iomux_config_pad);
+
+/*
+ * This function enables/disables the general purpose
+ * function for a particular
+ * signal.
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+	 __raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
+/*!
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en)
+{
+	mxc_iomux_set_gpr(gp, en);
+}
+EXPORT_SYMBOL(iomux_config_gpr);
+
+#endif
diff --git a/arch/arm/mach-mx3/mm.c b/arch/arm/mach-mx3/mm.c
index 30d842b..6dcaced 100644
--- a/arch/arm/mach-mx3/mm.c
+++ b/arch/arm/mach-mx3/mm.c
@@ -40,12 +40,27 @@
  * These are the mappings common across all MX3 boards.
  */
 static struct map_desc mxc_io_desc[] __initdata = {
-	{
+    {
+		.virtual    = IRAM_BASE_ADDR_VIRT,
+		.pfn        = __phys_to_pfn(IRAM_BASE_ADDR),
+		.length     = IRAM_SIZE,
+		.type       = MT_NONSHARED_DEVICE
+	}, {
+		.virtual    = L2CC_BASE_ADDR_VIRT,
+		.pfn        = __phys_to_pfn(L2CC_BASE_ADDR),
+		.length     = L2CC_SIZE,
+		.type       = MT_DEVICE
+	}, {
 		.virtual	= X_MEMC_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(X_MEMC_BASE_ADDR),
 		.length		= X_MEMC_SIZE,
 		.type		= MT_DEVICE
 	}, {
+		.virtual    = ROMP_BASE_ADDR_VIRT,
+		.pfn        = __phys_to_pfn(ROMP_BASE_ADDR),
+		.length     = ROMP_SIZE,
+		.type       = MT_NONSHARED_DEVICE
+	}, {
 		.virtual	= AVIC_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(AVIC_BASE_ADDR),
 		.length		= AVIC_SIZE,
diff --git a/arch/arm/mach-mx3/mx31_gpio.c b/arch/arm/mach-mx3/mx31_gpio.c
new file mode 100644
index 0000000..e8fbbc1
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31_gpio.c
@@ -0,0 +1,2166 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/mach-types.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <mach/iomux-mx3.h>
+
+/*!
+ * @file mx31_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+/*!
+ * This system-wise GPIO function initializes the pins during system
+ * startup.  * All the statically linked device drivers should put
+ * the proper  * GPIO initialization  * code inside this function.
+ * It is called  * by \b fixup_mx31ads() during  * system startup.
+ * This function  * is board specific.
+ */
+void mx31ads_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX31_PIN_CS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*Connect DAM ports 4 & 5 to enable audio I/O */
+	gpio_activate_audio_ports();
+}
+EXPORT_SYMBOL(mx31ads_gpio_init);
+
+/*!
+ * This system-wise GPIO function initializes the pins during system
+ * startup.  * All the statically linked device drivers should put
+ * the proper GPIO initialization  * code inside this function.
+ * It is called by \b fixup_mx31lite() during  * system startup.
+ * This function is board specific.
+ */
+void mx31lite_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX31_PIN_CS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*Connect DAM ports 4 & 5 to enable audio I/O */
+	gpio_activate_audio_ports();
+
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_GPIO);
+		mxc_set_gpio_direction(MX31_PIN_SFS6, 1);
+	}
+}
+EXPORT_SYMBOL(mx31lite_gpio_init);
+
+void gpio_nic_active(void)
+{
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_GPIO);
+		mxc_set_gpio_direction(MX31_PIN_SFS6, 1);
+	}
+}
+EXPORT_SYMBOL(gpio_nic_active);
+
+void gpio_nic_inactive(void)
+{
+	if (machine_is_mx31lite()) {
+		mxc_free_gpio(MX31_PIN_SFS6);
+		mxc_free_iomux(MX31_PIN_SFS6, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+	}
+}
+EXPORT_SYMBOL(gpio_nic_inactive);
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_clr = 0, pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+			mxc_request_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+
+			/* Enable the transceiver */
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+			pbc_bctrl2_set |= PBC_BCTRL2_USELC;
+			break;
+			/* UART 2 IOMUX Configs */
+	case 1:
+			mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+
+			if (no_irda == 1) {
+				mxc_request_iomux(MX31_PIN_RTS2,
+						OUTPUTCONFIG_FUNC,
+						INPUTCONFIG_FUNC);
+				mxc_request_iomux(MX31_PIN_CTS2,
+						OUTPUTCONFIG_FUNC,
+						INPUTCONFIG_FUNC);
+				mxc_request_iomux(MX31_PIN_DTR_DCE2,
+						OUTPUTCONFIG_FUNC,
+						INPUTCONFIG_FUNC);
+				pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+				pbc_bctrl2_clr |= PBC_BCTRL2_USELC;
+			} else {
+				pbc_bctrl1_clr |= PBC_BCTRL1_IREN;
+				pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+			}
+			break;
+			/* UART 3 IOMUX Configs */
+	case 2:
+			mxc_request_iomux(MX31_PIN_CSPI3_MOSI,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI3_MISO,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI3_SCLK,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI3_SPI_RDY,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+			pbc_bctrl2_clr |= PBC_BCTRL2_USELB;
+			break;
+			/* UART 4 IOMUX Configs */
+	case 3:
+			mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+			pbc_bctrl2_set |= PBC_BCTRL2_USELB;
+			break;
+			/* UART 5 IOMUX Configs */
+	case 4:
+			mxc_request_iomux(MX31_PIN_PC_VS2, OUTPUTCONFIG_ALT2,
+					INPUTCONFIG_ALT2);
+			mxc_request_iomux(MX31_PIN_PC_RST, OUTPUTCONFIG_ALT2,
+					INPUTCONFIG_ALT2);
+			mxc_request_iomux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_ALT2,
+					INPUTCONFIG_ALT2);
+			mxc_request_iomux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_ALT2,
+					INPUTCONFIG_ALT2);
+
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENA;
+			pbc_bctrl2_set |= PBC_BCTRL2_USELA;
+			break;
+	default:
+			break;
+	}
+
+	__raw_writew(pbc_bctrl1_clr, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	/*
+	 * TODO: Configure the Pad registers for the UART pins
+	 */
+}
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_set = 0;
+
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+
+	switch (port) {
+	case 0:
+			mxc_request_gpio(MX31_PIN_RXD1);
+			mxc_request_gpio(MX31_PIN_TXD1);
+			mxc_request_gpio(MX31_PIN_RTS1);
+			mxc_request_gpio(MX31_PIN_CTS1);
+			mxc_request_gpio(MX31_PIN_DTR_DCE1);
+			mxc_request_gpio(MX31_PIN_DSR_DCE1);
+			mxc_request_gpio(MX31_PIN_RI_DCE1);
+			mxc_request_gpio(MX31_PIN_DCD_DCE1);
+
+			mxc_free_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+
+			pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+			break;
+	case 1:
+			mxc_request_gpio(MX31_PIN_TXD2);
+			mxc_request_gpio(MX31_PIN_RXD2);
+
+			mxc_free_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+
+			if (no_irda == 1) {
+				mxc_request_gpio(MX31_PIN_DTR_DCE2);
+				mxc_free_iomux(MX31_PIN_DTR_DCE2,
+						OUTPUTCONFIG_GPIO,
+						INPUTCONFIG_GPIO);
+
+				pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+			} else {
+				pbc_bctrl1_set |= PBC_BCTRL1_IREN;
+			}
+			break;
+	case 2:
+			pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+			break;
+	case 3:
+			mxc_request_gpio(MX31_PIN_ATA_CS0);
+			mxc_request_gpio(MX31_PIN_ATA_CS1);
+			mxc_request_gpio(MX31_PIN_ATA_DIOR);
+			mxc_request_gpio(MX31_PIN_ATA_DIOW);
+
+			mxc_free_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+			mxc_free_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_GPIO);
+
+			pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+			break;
+	case 4:
+			pbc_bctrl1_set |= PBC_BCTRL1_UENA;
+			break;
+	default:
+			break;
+	}
+	__raw_writew(pbc_bctrl1_set, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	if (machine_is_mx31lite())
+		return; /* not applicable to mx31lite */
+
+	switch (port) {
+	case 1:
+			/* Configure to receive UART 2 SDMA events */
+			mxc_iomux_set_gpr(MUX_PGP_FIRI, false);
+			break;
+	case 2:
+			/* Configure to receive UART 3 SDMA events */
+			mxc_iomux_set_gpr(MUX_CSPI1_UART3, true);
+			break;
+	case 4:
+			/* Configure to receive UART 5 SDMA events */
+			mxc_iomux_set_gpr(MUX_CSPI3_UART5_SEL, true);
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Setup GPIO for Keypad  to be active
+ *
+ */
+void gpio_keypad_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for keypad signals.
+	 */
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Setup GPIO for Keypad to be inactive
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+			/* SPI1 */
+			mxc_request_iomux(MX31_PIN_CSPI1_MISO,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_MOSI,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_SCLK,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS0,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS1,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS2,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			break;
+	case 1:
+			/* SPI2 */
+			mxc_request_iomux(MX31_PIN_CSPI2_MISO,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_MOSI,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_SCLK,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS0,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS1,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS2,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			break;
+	case 2:
+			/* SPI3 */
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	iomux_config_pad(MX31_PIN_BATT_LINE, PAD_CTL_LOOPBACK);
+}
+EXPORT_SYMBOL(gpio_owire_active);
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_inactive(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+			/* SPI1 */
+			mxc_request_iomux(MX31_PIN_CSPI1_MISO,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_MOSI,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_SCLK,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS0,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS1,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI1_SS2,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			break;
+	case 1:
+			/* SPI2 */
+			mxc_request_iomux(MX31_PIN_CSPI2_MISO,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_MOSI,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_SCLK,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS0,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS1,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_CSPI2_SS2,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+			break;
+	case 2:
+			/* SPI3 */
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+			mxc_request_iomux(MX31_PIN_I2C_CLK,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_I2C_DAT,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+			break;
+	case 1:
+			mxc_request_iomux(MX31_PIN_CSPI2_MOSI,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI2_MISO,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			break;
+	case 2:
+			mxc_request_iomux(MX31_PIN_CSPI2_SS2,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI2_SCLK,
+					OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1);
+			break;
+	default:
+			break;
+	}
+
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+			mxc_request_iomux(MX31_PIN_I2C_CLK,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_I2C_DAT,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_FUNC);
+			break;
+	case 1:
+			mxc_request_iomux(MX31_PIN_CSPI2_MOSI,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI2_MISO,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_ALT1);
+			break;
+	case 2:
+			mxc_request_iomux(MX31_PIN_CSPI2_SS2,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_CSPI2_SCLK,
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_ALT1);
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	mxc_request_iomux(MX31_PIN_GPIO1_3, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_GPIO);
+	mxc_set_gpio_direction(MX31_PIN_GPIO1_3, 1);
+}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+/*!
+ * This function activates DAM ports 4 & 5 to enable
+ * audio I/O. Thsi function is called from mx31XXX_gpio_init
+ * function, which is board-specific.
+ */
+void gpio_activate_audio_ports(void)
+{
+	/* config Audio ports (4 & 5) */
+	mxc_request_iomux(MX31_PIN_SCK4,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD4,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD4,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS4,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SCK5,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD5,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD5,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS5,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	switch (module) {
+	case 0:
+			mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
+					INPUTCONFIG_FUNC);
+
+			mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+					(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+			break;
+	case 1:
+			mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_ALT1,
+					INPUTCONFIG_ALT1);
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+			mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+
+			mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+					(PAD_CTL_DRV_NORMAL |
+					 PAD_CTL_SRE_SLOW));
+			break;
+	case 1:
+			/* TODO:what are the pins for SDHC2? */
+			mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_GPIO,
+					INPUTCONFIG_NONE);
+			break;
+	default:
+			break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	if (to_platform_device(dev)->id == 0) {
+		if (machine_is_mx31lite())
+			return mxc_get_gpio_datain(MX31_PIN_DCD_DCE1);
+		else
+			return mxc_get_gpio_datain(MX31_PIN_GPIO1_1);
+	} else {
+		return mxc_get_gpio_datain(MX31_PIN_GPIO1_2);
+	}
+}
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	if (id == 0) {
+		int pin = MX31_PIN_GPIO1_1;
+		if (machine_is_mx31lite())
+			pin = MX31_PIN_DCD_DCE1;
+		iomux_config_mux(pin, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		if (machine_is_mx31lite())
+			mxc_iomux_set_pad(MX31_PIN_DCD_DCE1,
+					PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW);
+		return IOMUX_TO_IRQ(pin);
+	} else {
+		iomux_config_mux(MX31_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_GPIO);
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_2);
+
+	}
+}
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Setup GPIO for LCD to be active
+ *
+ */
+void gpio_lcd_active(void)
+{
+	mxc_request_iomux(MX31_PIN_LD0,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*LD16*/
+	mxc_request_iomux(MX31_PIN_LD17,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*LD17*/
+	mxc_request_iomux(MX31_PIN_VSYNC3,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*VSYNC*/
+	mxc_request_iomux(MX31_PIN_HSYNC,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*HSYNC*/
+	mxc_request_iomux(MX31_PIN_FPSHIFT,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*CLK*/
+	mxc_request_iomux(MX31_PIN_DRDY0,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*DRDY*/
+	mxc_request_iomux(MX31_PIN_D3_REV,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*REV*/
+	mxc_request_iomux(MX31_PIN_CONTRAST,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*CONTR*/
+	mxc_request_iomux(MX31_PIN_D3_SPL,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*SPL*/
+	mxc_request_iomux(MX31_PIN_D3_CLS,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/*CLS*/
+
+	if (machine_is_mx31ads()) {
+		u16 temp;
+		temp = PBC_BCTRL1_LCDON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+	}
+}
+EXPORT_SYMBOL(gpio_lcd_active);
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ *
+ */
+void gpio_lcd_inactive(void)
+{
+	if (machine_is_mx31ads()) {
+		u16 pbc_bctrl1_set = 0;
+
+		pbc_bctrl1_set = (u16) PBC_BCTRL1_LCDON;
+		__raw_writew(pbc_bctrl1_set,
+				PBC_BASE_ADDRESS + PBC_BCTRL1_SET + 2);
+	}
+}
+EXPORT_SYMBOL(gpio_lcd_inactive);
+
+/*!
+ * Setup pins for SLCD to be active
+ *
+ */
+void slcd_gpio_config(void)
+{
+	u16 temp;
+
+	if (machine_is_mx31lite())
+		return;
+
+	/* Reset smart lcd */
+	temp = PBC_BCTRL2_LDC_RST0;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	msleep(2);
+	/* Bring out of reset */
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	msleep(2);
+
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+
+	mxc_request_iomux(MX31_PIN_READ, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);	/* read */
+	mxc_request_iomux(MX31_PIN_WRITE, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);	/* write */
+	mxc_request_iomux(MX31_PIN_PAR_RS, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);	/* RS */
+	mxc_request_iomux(MX31_PIN_LCS0, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);	/* chip select */
+
+	/* Enable smart lcd interface */
+	temp = PBC_BCTRL2_LDCIO_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+EXPORT_SYMBOL(slcd_gpio_config);
+
+/*!
+ * Switch to the specified sensor - MX31 ADS has two
+ *
+ */
+void gpio_sensor_select(int sensor)
+{
+	u16 temp;
+
+	if (machine_is_mx31lite())
+		return;
+
+	switch (sensor) {
+	case 0:
+#ifdef CONFIG_MXC_CAMERA_MC521DA
+			temp = 0x100;
+			__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+#else
+			temp = PBC_BCTRL1_SENSOR2_ON;
+			__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+			temp = PBC_BCTRL1_SENSOR1_ON;
+			__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+#endif
+			break;
+	case 1:
+			temp = PBC_BCTRL1_SENSOR1_ON;
+			__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+			temp = PBC_BCTRL1_SENSOR2_ON;
+			__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+			break;
+	default:
+			break;
+	}
+}
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	if (machine_is_mx31lite())
+		return;
+
+	gpio_sensor_select(0);
+
+	/*
+	 * Configure the iomuxen for the CSI.
+	 */
+
+	mxc_request_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * The other 4 data bits are multiplexed on MX31.
+	 */
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT2,
+			INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT2,
+			INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT2,
+			INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT2,
+			INPUTCONFIG_ALT2);
+#endif
+
+	/*
+	 * Now enable the CSI buffers
+	 */
+
+	__raw_writew(PBC_BCTRL2_CSI_EN,
+			PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * Enable the other buffer for the additional 4 data bits.
+	 */
+	__raw_writew(PBC_BCTRL4_CSI_MSB_EN,
+			PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+#endif
+}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_reset(bool flag)
+{
+	u16 temp = 0x200;
+
+	if (flag)
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+	else
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+EXPORT_SYMBOL(gpio_sensor_reset);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+	/*
+	 * Configure the GPR for ATA group B signals
+	 */
+
+	/* XXX: might need revisiting for MX31LITE */
+	if (machine_is_mx31lite()) {
+		u32 config = PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE;
+
+		mxc_iomux_set_gpr(MUX_PGP_ATA_9 | MUX_PGP_ATA_5 |
+				MUX_PGP_ATA_1, true);
+
+		mxc_request_iomux(MX31_PIN_KEY_COL5,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL6,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL7,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_COL4,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_ROW6,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_KEY_ROW7,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL5, config); /* ATA_DA0 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL6, config); /* ATA_DA1 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7, config); /* ATA_DA2 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL4, config); /* ATA_DMARQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, config); /* ATA_INITRQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, config); /* ATA_BUF_EN */
+
+		mxc_iomux_set_pad(MX31_PIN_PWMO, config); /* ATA_IORDY */
+	} else {
+		mxc_iomux_set_gpr(MUX_PGP_ATA_7 | MUX_PGP_ATA_6 |
+				MUX_PGP_ATA_2 | MUX_PGP_ATA_1, true);
+
+		/*
+		 * Configure the IOMUX for ATA group B signals
+		 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D0 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D2 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D3 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D4 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D5 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D6 */
+		mxc_request_iomux(MX31_PIN_STXD3,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D7 */
+		mxc_request_iomux(MX31_PIN_SRXD3,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D8 */
+		mxc_request_iomux(MX31_PIN_SCK3,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D9 */
+		mxc_request_iomux(MX31_PIN_SFS3,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D10 */
+		mxc_request_iomux(MX31_PIN_STXD6,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D11 */
+		mxc_request_iomux(MX31_PIN_SRXD6,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D12 */
+		mxc_request_iomux(MX31_PIN_SCK6,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D13 */
+		mxc_request_iomux(MX31_PIN_CAPTURE,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D14 */
+		mxc_request_iomux(MX31_PIN_COMPARE,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_D15 */
+
+		mxc_request_iomux(MX31_PIN_USBH2_STP,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_DMARQ_B */
+		mxc_request_iomux(MX31_PIN_USBH2_CLK,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_INTRQ_B */
+		mxc_request_iomux(MX31_PIN_USBH2_NXT,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_DA0 */
+		mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_DA1 */
+		mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_DA2 */
+		mxc_request_iomux(MX31_PIN_USBH2_DIR,
+				OUTPUTCONFIG_FUNC,
+				INPUTCONFIG_FUNC); /* ATA_BUFFER_DIR */
+
+		/* Need fast slew rate for UDMA mode */
+
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 0 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 1 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 2 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 3 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 4 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 5 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 6 */
+		mxc_iomux_set_pad(MX31_PIN_STXD3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 7 */
+		mxc_iomux_set_pad(MX31_PIN_SRXD3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 8 */
+		mxc_iomux_set_pad(MX31_PIN_SCK3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 9 */
+		mxc_iomux_set_pad(MX31_PIN_SFS3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 10 */
+		mxc_iomux_set_pad(MX31_PIN_STXD6,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 11 */
+		mxc_iomux_set_pad(MX31_PIN_SRXD6,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 12 */
+		mxc_iomux_set_pad(MX31_PIN_SCK6,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 13 */
+		mxc_iomux_set_pad(MX31_PIN_CAPTURE,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 14 */
+		mxc_iomux_set_pad(MX31_PIN_COMPARE,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_PKE_NONE); /* data 12 */
+
+		/*
+		 * Turn off default pullups on high asserted control signals.
+		 * These are pulled down externally, so it will just waste
+		 * power and create voltage divider action to pull them up
+		 * on chip.
+		 */
+		mxc_iomux_set_pad(MX31_PIN_USBH2_STP,
+				PAD_CTL_PKE_NONE); /* ATA_DMARQ */
+		mxc_iomux_set_pad(MX31_PIN_USBH2_CLK,
+				PAD_CTL_PKE_NONE); /* ATA_INTRQ */
+	}
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_PWMO, OUTPUTCONFIG_FUNC,
+			INPUTCONFIG_FUNC);
+
+	if (machine_is_mx31lite()) {
+		u32 config = PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST |
+			PAD_CTL_ODE_CMOS | PAD_CTL_HYS_CMOS | PAD_CTL_100K_PD;
+		mxc_iomux_set_pad(MX31_PIN_ATA_CS0, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_CS1, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DIOR, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DIOW, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_DMACK, config);
+		mxc_iomux_set_pad(MX31_PIN_ATA_RESET_B, config);
+	}
+
+}
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	/*
+	 * Turn off ATA group B signals
+	 */
+
+	/* XXX: revisit for MX31LITE */
+	if (!machine_is_mx31lite()) {
+		u32 config = PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE;
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D0 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D2 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D3 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D4 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D5 */
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D6 */
+		mxc_request_iomux(MX31_PIN_STXD3,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D7 */
+		mxc_request_iomux(MX31_PIN_SRXD3,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D8 */
+		mxc_request_iomux(MX31_PIN_SCK3,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D9 */
+		mxc_request_iomux(MX31_PIN_SFS3,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D10 */
+		mxc_request_iomux(MX31_PIN_STXD6,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D11 */
+		mxc_request_iomux(MX31_PIN_SRXD6,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D12 */
+		mxc_request_iomux(MX31_PIN_SCK6,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D13 */
+		mxc_request_iomux(MX31_PIN_CAPTURE,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D14 */
+		mxc_request_iomux(MX31_PIN_COMPARE,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_D15 */
+
+		mxc_request_iomux(MX31_PIN_USBH2_STP,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_DMARQ_B */
+		mxc_request_iomux(MX31_PIN_USBH2_CLK,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_INTRQ_B */
+		mxc_request_iomux(MX31_PIN_USBH2_NXT,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_DA0 */
+		mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_DA1 */
+		mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_DA2 */
+		mxc_request_iomux(MX31_PIN_USBH2_DIR,
+				OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE); /* ATA_BUFFER_DIR */
+
+		/* Needed fast slew rate for UDMA mode */
+
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, config);	/* data 0 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, config); /* data 1 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, config); /* data 2 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, config); /* data 3 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, config); /* data 4 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, config); /* data 5 */
+		mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY,
+				config); /* data 6 */
+		mxc_iomux_set_pad(MX31_PIN_STXD3, config); /* data 7 */
+		mxc_iomux_set_pad(MX31_PIN_SRXD3, config); /* data 8 */
+		mxc_iomux_set_pad(MX31_PIN_SCK3, config); /* data 9 */
+		mxc_iomux_set_pad(MX31_PIN_SFS3, config); /* data 10 */
+		mxc_iomux_set_pad(MX31_PIN_STXD3, config); /* data 11 */
+		mxc_iomux_set_pad(MX31_PIN_SRXD6, config); /* data 12 */
+		mxc_iomux_set_pad(MX31_PIN_SCK6, config); /* data 13 */
+		mxc_iomux_set_pad(MX31_PIN_CAPTURE, config); /* data 14 */
+		mxc_iomux_set_pad(MX31_PIN_COMPARE, config); /* data 12 */
+	} else {
+		u32 config = PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE;
+		mxc_iomux_set_pad(MX31_PIN_PWMO, config); /* ATA_IORDY */
+		mxc_free_gpio(MX31_PIN_KEY_COL5);
+		mxc_free_gpio(MX31_PIN_KEY_COL6);
+		mxc_free_gpio(MX31_PIN_KEY_COL7);
+		mxc_free_gpio(MX31_PIN_KEY_COL4);
+		mxc_free_gpio(MX31_PIN_KEY_ROW6);
+		mxc_free_gpio(MX31_PIN_KEY_ROW7);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL5, config); /* ATA_DA0 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL6, config); /* ATA_DA1 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7, config); /* ATA_DA2 */
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL4, config); /* ATA_DMARQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW6, config); /* ATA_INITRQ */
+		mxc_iomux_set_pad(MX31_PIN_KEY_ROW7, config); /* ATA_BUF_EN */
+	}
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_GPIO,
+			INPUTCONFIG_NONE);
+
+}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+/*!
+ * Setup EDIO/IOMUX for external UART.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to allocate
+ * @param handler Function to be called when the IRQ occurs
+ * @param irq_flags Interrupt type flags
+ * @param devname An ascii name for the claiming device
+ * @param dev_id A cookie passed back to the handler function
+ * @return  Returns 0 if the interrupt was successfully requested,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_setup(unsigned int port, unsigned int irq,
+		irqreturn_t(*handler) (int, void *),
+		unsigned long irq_flags, const char *devname,
+		void *dev_id)
+{
+	return 0;
+}
+
+/*!
+ * Get the EDIO interrupt, clear if set.
+ *
+ * @param port UART port
+ */
+void extuart_intr_clear(unsigned int port)
+{
+}
+
+/*!
+ * Do IOMUX configs required to put the
+ * pin back in low power mode.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to free
+ * @param dev_id Device identity to free
+ * @return  Returns 0 if the interrupt was successfully freed,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_cleanup(unsigned int port, unsigned int irq, void *dev_id)
+{
+	return 0;
+}
+
+/* *INDENT-OFF* */
+/*
+ * USB Host 1
+ * pins conflict with SPI1, ATA, UART3
+ */
+int gpio_usbh1_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_CSPI1_MOSI,	/* USBH1_RXDM */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_MISO,	/* USBH1_RXDP */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_SS0,	/* USBH1_TXDM */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_SS1,	/* USBH1_TXDP */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_SS2,	/* USBH1_RCV  */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_SCLK, /* USBH1_OEB */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+			mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, /* USBH1_FS */
+				OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1)) {
+		return -EINVAL;
+	}
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, /* USBH1_RXDM */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, /* USBH1_RXDP */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, /* USBH1_TXDM */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, /* USBH1_TXDP */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, /* USBH1_RCV  */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, /* USBH1_OEB(_TXOE) */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, /* USBH1_FS   */
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_gpr(MUX_PGP_USB_SUSPEND, true);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh1_active);
+
+void gpio_usbh1_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSPI1_MOSI, /* USBH1_RXDM */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_MISO, /* USBH1_RXDP */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS0, /* USBH1_TXDM */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS1, /* USBH1_TXDP */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS2, /* USBH1_RCV  */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SCLK, /* USBH1_OEB (_TXOE) */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SPI_RDY, /* USBH1_FS   */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, /* USBH1_RXDM */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, /* USBH1_RXDP */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, /* USBH1_TXDM */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, /* USBH1_TXDP */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, /* USBH1_RCV  */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, /* USBH1_OEB(_TXOE) */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY /* USBH1_FS   */,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	int outputconfig = OUTPUTCONFIG_GPIO;
+
+	if (machine_is_mx31lite())
+		outputconfig = OUTPUTCONFIG_FUNC;
+
+	if (mxc_request_iomux(MX31_PIN_USBH2_CLK,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBH2_DIR,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBH2_NXT,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBH2_STP,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_PC_VS2, /* USBH2_DATA2 */
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_PC_BVD1, /* USBH2_DATA3 */
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_PC_BVD2, /* USBH2_DATA4 */
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_PC_RST, /* USBH2_DATA5 */
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_IOIS16, /* USBH2_DATA6 */
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_PC_RW_B, /* USBH2_DATA7 */
+					OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFWE_B,
+					outputconfig, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFRE_B,
+					outputconfig, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFALE,
+					outputconfig, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFCLE,
+					outputconfig, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFWP_B,
+					outputconfig, INPUTCONFIG_NONE) ||
+			mxc_request_iomux(MX31_PIN_NFCE_B,
+					outputconfig, INPUTCONFIG_NONE)) {
+						return -EINVAL;
+					}
+
+#define H2_PAD_CFG (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | \
+		PAD_CTL_HYS_CMOS | PAD_CTL_ODE_CMOS | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, H2_PAD_CFG);	/* USBH2_DATA2 */
+	mxc_iomux_set_pad(MX31_PIN_STXD6, H2_PAD_CFG);	/* USBH2_DATA3 */
+	mxc_iomux_set_pad(MX31_PIN_SFS3, H2_PAD_CFG);	/* USBH2_DATA4 */
+	mxc_iomux_set_pad(MX31_PIN_SCK3, H2_PAD_CFG);	/* USBH2_DATA5 */
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, H2_PAD_CFG);	/* USBH2_DATA6 */
+	mxc_iomux_set_pad(MX31_PIN_STXD3, H2_PAD_CFG);	/* USBH2_DATA7 */
+#undef H2_PAD_CFG
+
+	mxc_iomux_set_gpr(MUX_PGP_UH2, true);
+
+	if (machine_is_mx31lite()) {
+		mxc_request_iomux(MX31_PIN_DTR_DCE1,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_DTR_DCE1,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_DTR_DCE1, 0); /* output */
+		mxc_set_gpio_dataout(MX31_PIN_DTR_DCE1, 0);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	int outputconfig = OUTPUTCONFIG_GPIO;
+
+	if (machine_is_mx31lite())
+		outputconfig = OUTPUTCONFIG_FUNC;
+
+	iomux_config_gpr(MUX_PGP_UH2, false);
+
+	iomux_config_pad(MX31_PIN_USBH2_CLK,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DIR,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_NXT,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_STP,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA0,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA1,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD6,		/* USBH2_DATA2 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD6,		/* USBH2_DATA3 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SFS3,			/* USBH2_DATA4 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SCK3,			/* USBH2_DATA5 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD3,		/* USBH2_DATA6 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD3,		/* USBH2_DATA7 */
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+	mxc_free_iomux(MX31_PIN_USBH2_CLK,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DIR,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_NXT,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_STP,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA0,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_PC_VS2,			/* USBH2_DATA2 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST,			/* USBH2_DATA5 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_IOIS16,			/* USBH2_DATA6 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_NFWE_B,
+			outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFRE_B,
+			outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFALE,
+			outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCLE,
+			outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFWP_B,
+			outputconfig, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCE_B,
+			outputconfig, INPUTCONFIG_NONE);
+}
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_STP,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+						return -EINVAL;
+					}
+
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			(PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			(PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+				OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USBOTG_STP,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+			mxc_request_iomux(MX31_PIN_USB_PWR,
+					OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+						return -EINVAL;
+					}
+	return 0;
+
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USB_PWR,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+/* *INDENT-ON* */
+
+/*!
+ * Setup GPIO for PCMCIA interface
+ *
+ */
+void gpio_pcmcia_active(void)
+{
+	mxc_request_iomux(MX31_PIN_SDBA0,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SDBA1,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_LBA,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_RW,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB0,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB1,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_OE,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_IOIS16,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD1,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD2,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD1_B,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD2_B,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_POE,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_PWRON,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_READY,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RST,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RW_B,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS1,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS2,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_WAIT_B,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	if (machine_is_mx31ads()) {
+		/* PCMCIA VPP, VCC Enable, 1 = power on */
+		u16 temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+		/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+		temp = PBC_BCTRL3_CARD2_SEL;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR);
+
+		/* PCMCIA Enable, 0 = enable */
+		temp = PBC_BCTRL4_PCMCIA_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+		mdelay(1);
+	} else if (machine_is_mx31lite()) {
+		/* PCC_POWER_nEN */
+		mxc_request_iomux(MX31_PIN_LCS1,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_LCS1,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_LCS1, 0); /* output */
+		mxc_set_gpio_dataout(MX31_PIN_LCS1, 0);
+		/* PCC_PCMCIA_nEN */
+		mxc_request_iomux(MX31_PIN_KEY_COL7,
+				OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+		mxc_iomux_set_pad(MX31_PIN_KEY_COL7,
+				PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_OpenDrain |
+				PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+				PAD_CTL_SRE_SLOW);
+		mxc_set_gpio_direction(MX31_PIN_KEY_COL7, 0); /* output */
+		mxc_set_gpio_dataout(MX31_PIN_KEY_COL7, 0);
+	}
+
+}
+EXPORT_SYMBOL(gpio_pcmcia_active);
+
+/*!
+ * Setup GPIO for pcmcia to be inactive
+ */
+void gpio_pcmcia_inactive(void)
+{
+	if (machine_is_mx31ads()) {
+		/* PCMCIA Enable, 0 = enable */
+		u16 temp = PBC_BCTRL4_PCMCIA_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_SET);
+
+		/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+		temp = PBC_BCTRL3_CARD2_SEL;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_SET);
+
+		/* PCMCIA VPP, VCC Enable, 1 = power on */
+		temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	} else if (machine_is_mx31lite()) {
+		mxc_free_iomux(MX31_PIN_LCS1, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+		mxc_free_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO,
+				INPUTCONFIG_NONE);
+	}
+
+	mxc_free_iomux(MX31_PIN_SDBA0,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_SDBA1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_LBA,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_RW,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB0,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_OE,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_IOIS16,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD1_B,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD2_B,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_POE,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_PWRON,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_READY,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS1,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS2,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_WAIT_B,
+			OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+EXPORT_SYMBOL(gpio_pcmcia_inactive);
+
+/*!
+ * Setup IR to be used by UART and FIRI
+ */
+void gpio_firi_init(void)
+{
+	struct clk *firi_clk = NULL;
+	gpio_uart_active(1, 0);
+
+	firi_clk = clk_get(NULL, "firi_clk");
+	/*
+	 * FIRI module needs a clock which is a multiple of 8 Mhz..
+	 * We are giving it 48 Mhz in this case.
+	 */
+	clk_set_rate(firi_clk, 48000000);
+	clk_put(firi_clk);
+}
+EXPORT_SYMBOL(gpio_firi_init);
+
+/*!
+ * Setup IR to be used by UART
+ */
+void gpio_firi_inactive(void)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+
+	iomux_config_gpr(MUX_PGP_FIRI, false);
+	mxc_request_iomux(MX31_PIN_TXD2,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_RXD2,
+			OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+EXPORT_SYMBOL(gpio_firi_inactive);
+
+/*!
+ * Setup IR to be used by FIRI
+ */
+void gpio_firi_active(void *fir_cong_reg_base, unsigned int tpp_mask)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+	unsigned int cr;
+
+	iomux_config_gpr(MUX_PGP_FIRI, true);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	cr = readl(fir_cong_reg_base);
+	cr |= tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+}
+EXPORT_SYMBOL(gpio_firi_active);
-- 
1.5.5.1

