From aadb19ab60f4024c210415c541bbbb13bb91a3ce Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Fri, 19 Dec 2008 21:09:29 +0300
Subject: [PATCH] Add SPI driver for MXC V2

Add SPI driver for MXC

Merged from pengutronix.de

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

On i.MX5 series, the spi controller is version 23. Compared to previous
versions, the new version controller not only has a new register layout,
but also has new supported features like the bigger fifo size. So
modify mxc spi driver to support version 23 controller.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Quinn Jensen <quinn.jensen@freescale.com>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 drivers/spi/Kconfig   |   49 +++
 drivers/spi/Makefile  |    1 +
 drivers/spi/mxc_spi.c |  817 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 867 insertions(+), 0 deletions(-)
 create mode 100644 drivers/spi/mxc_spi.c

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c04029a..cb99ca8 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -135,6 +135,55 @@ config SPI_MPC83xx
 	  technology. This driver uses a simple set of shift registers for data
 	  (opposed to the CPM based descriptor model).
 
+config SPI_MXC
+	tristate "MXC CSPI controller as SPI Master"
+	depends on ARCH_MXC && SPI_MASTER
+	select SPI_BITBANG
+	help
+	  This implements the SPI master mode using MXC CSPI.
+
+config SPI_MXC_TEST_LOOPBACK
+	bool "LOOPBACK Testing of CSPIs"
+	depends on SPI_MXC
+	default n
+
+config SPI_MXC_SELECT1
+	bool "CSPI1"
+	depends on SPI_MXC
+	default y
+
+config SPI_MXC_SELECT2
+	bool "CSPI2"
+	depends on SPI_MXC
+	default n
+
+config SPI_MXC_SELECT3
+	bool "CSPI3"
+	depends on SPI_MXC && (ARCH_MX3 || MACH_MX27 || ARCH_MX5)
+	default n
+
+choice
+        prompt "SPI controller hardware revision"
+        default SPI_MXC_REV0
+        depends on SPI_MXC
+        config SPI_MXC_REV0
+                bool "Revision 0"
+                help
+                  hardware revision 0, mostly on MX27
+        config SPI_MXC_REV4
+                bool "Revision 4"
+                help
+                  hardware revision 4, mostly on MX31
+        config SPI_MXC_REV5
+                bool "Revision 5"
+                help
+                  hardware revision 5
+        config SPI_MXC_REV7
+                bool "Revision 7"
+                help
+                  hardware revision 7
+endchoice
+
 config SPI_OMAP_UWIRE
 	tristate "OMAP1 MicroWire"
 	depends on ARCH_OMAP1
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 1c2e7fc..afe6319 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
+obj-$(CONFIG_SPI_MXC)			+= mxc_spi.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
diff --git a/drivers/spi/mxc_spi.c b/drivers/spi/mxc_spi.c
new file mode 100644
index 0000000..7b0904d
--- /dev/null
+++ b/drivers/spi/mxc_spi.c
@@ -0,0 +1,817 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 Juergen Beisert
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#undef DEBUG
+
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <mach/gpio.h>
+#include <mach/imx_spi.h>
+
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+struct spi_chip_info {
+	int lb_enable;
+};
+
+static struct spi_chip_info lb_chip_info = {
+	.lb_enable = 1,
+};
+
+static struct spi_board_info loopback_info[] = {
+#ifdef CONFIG_SPI_MXC_SELECT1
+	{
+	 .modalias = "spidev",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 0,
+	 .chip_select = 3,
+	 },
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT2
+	{
+	 .modalias = "spidev",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 1,
+	 .chip_select = 3,
+	 },
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT3
+	{
+	 .modalias = "spidev",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 2,
+	 .chip_select = 3,
+	 },
+#endif
+};
+#endif
+
+static struct mxc_spi_unique_def spi_ver_2_3 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_2_3,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_2_3,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_2_3,
+	.bc_mask = MXC_CSPICTRL_BCMASK_2_3,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_2_3,
+	.xfer_complete = MXC_CSPISTAT_TC_2_3,
+	.bc_overflow = MXC_CSPISTAT_BO_2_3,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_7 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_7,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_7,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_7,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_7,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_7,
+	.xfer_complete = MXC_CSPISTAT_TC_0_7,
+	.bc_overflow = MXC_CSPISTAT_BO_0_7,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_5 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_5,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_5,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_5,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_5,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_5,
+	.xfer_complete = MXC_CSPISTAT_TC_0_5,
+	.bc_overflow = MXC_CSPISTAT_BO_0_5,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_4 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_4,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_4,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_4,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_4,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_4,
+	.xfer_complete = MXC_CSPISTAT_TC_0_4,
+	.bc_overflow = MXC_CSPISTAT_BO_0_4,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_0 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_0,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_0,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_0,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_0,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_0,
+	.xfer_complete = MXC_CSPISTAT_TC_0_0,
+	.bc_overflow = MXC_CSPISTAT_BO_0_0,
+};
+
+struct mxc_spi;
+/*
+ * Structure to group together all the data buffers and functions
+ * used in data transfers.
+ */
+struct mxc_spi_xfer {
+	const void *tx_buf;	/* Transmit buffer. */
+	void *rx_buf;	/* Receive buffer. */
+	unsigned int count;	/* Data transfered count. */
+	void (*rx_get) (struct mxc_spi *, u32 val); /* Function to read the FIFO data to rx_buf. */
+	u32(*tx_get) (struct mxc_spi *);	/* Function to get the data to be written to FIFO. */
+};
+
+/*
+ * This structure is a way for the low level driver to define their own
+ * spi_master structure. This structure includes the core spi_master
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and has other elements that are specifically required by this
+ * low-level driver.
+ */
+struct mxc_spi {
+	struct spi_bitbang mxc_bitbang;	/* SPI Master and a simple I/O queue runner. */
+	struct completion xfer_done;	/* Completion flags used in data transfers. */
+	struct mxc_spi_xfer transfer;	/* Data transfer structure. */
+	struct resource *res;	/* Resource structure, which will maintain base addresses and IRQs. */
+	void *base;	/* Base address of CSPI, used in readl and writel. */
+	int irq;	/* CSPI IRQ number. */
+	struct clk *clk;	/* CSPI Clock id. */
+	/*!
+	 * CSPI input clock SCLK.
+	 */
+	unsigned long spi_ipg_clk;
+	/*!
+	 * CSPI registers' bit pattern.
+	 */
+	struct mxc_spi_unique_def *spi_ver_def;
+};
+
+#define MXC_SPI_BUF_RX(type)	\
+void mxc_spi_buf_rx_##type(struct mxc_spi *master_drv_data, u32 val)\
+{\
+	type *rx = master_drv_data->transfer.rx_buf;\
+	*rx++ = (type)val;\
+	master_drv_data->transfer.rx_buf = rx;\
+}
+
+#define MXC_SPI_BUF_TX(type)    \
+u32 mxc_spi_buf_tx_##type(struct mxc_spi *master_drv_data)\
+{\
+	u32 val;\
+	const type *tx = master_drv_data->transfer.tx_buf;\
+	val = *tx++;\
+	master_drv_data->transfer.tx_buf = tx;\
+	return val;\
+}
+MXC_SPI_BUF_RX(u8)
+    MXC_SPI_BUF_TX(u8)
+    MXC_SPI_BUF_RX(u16)
+    MXC_SPI_BUF_TX(u16)
+    MXC_SPI_BUF_RX(u32)
+    MXC_SPI_BUF_TX(u32)
+
+static int spi_enable_interrupt(struct mxc_spi *master_data, unsigned int irqs)
+{
+	if (irqs & ~((1 << master_data->spi_ver_def->intr_bit_shift) - 1)) {
+		return -1;
+	}
+	if (master_data->spi_ver_def == &spi_ver_2_3)
+		writel((irqs | readl(master_data->base + MXC_CSPIINT + 4)),
+		       master_data->base + MXC_CSPIINT + 4);
+	else
+		writel((irqs | readl(master_data->base + MXC_CSPIINT)),
+		       master_data->base + MXC_CSPIINT);
+
+	return 0;
+}
+
+static int spi_disable_interrupt(struct mxc_spi *master_data, unsigned int irqs)
+{
+	if (irqs & ~((1 << master_data->spi_ver_def->intr_bit_shift) - 1)) {
+		return -1;
+	}
+	if (master_data->spi_ver_def == &spi_ver_2_3)
+		writel((~irqs & readl(master_data->base + MXC_CSPIINT + 4)),
+		       master_data->base + MXC_CSPIINT + 4);
+	else
+		writel((~irqs & readl(master_data->base + MXC_CSPIINT)),
+		       master_data->base + MXC_CSPIINT);
+
+	return 0;
+}
+
+static unsigned int spi_find_baudrate(struct mxc_spi *master_data,
+				      unsigned int baud)
+{
+	unsigned int divisor;
+	unsigned int shift = 0;
+
+	/* Calculate required divisor (rounded) */
+	divisor = (master_data->spi_ipg_clk + baud / 2) / baud;
+	while (divisor >>= 1)
+		shift++;
+	if (master_data->spi_ver_def == &spi_ver_2_3) {
+		if (shift > MXC_CSPICTRL_MAXDATRATE_2_3)
+			shift = MXC_CSPICTRL_MAXDATRATE_2_3;
+		return (shift << MXC_CSPICTRL_DATASHIFT_2_3);
+	} else {
+		MXC_CSPICTRL_ADJUST_SHIFT(shift);
+		if (shift > MXC_CSPICTRL_MAXDATRATE)
+			shift = MXC_CSPICTRL_MAXDATRATE;
+		return (shift << MXC_CSPICTRL_DATASHIFT);
+	}
+}
+
+static unsigned int spi_get_rx_data(void *base)
+{
+	return readl(base + MXC_CSPIRXDATA);
+}
+
+static void spi_put_tx_data(void *base, unsigned int val)
+{
+	unsigned int ctrl_reg;
+
+	writel(val, base + MXC_CSPITXDATA);
+
+	ctrl_reg = readl(base + MXC_CSPICTRL);
+
+	ctrl_reg |= MXC_CSPICTRL_XCH;
+
+	writel(ctrl_reg, base + MXC_CSPICTRL);
+
+	return;
+}
+
+void mxc_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	struct mxc_spi *master_drv_data;
+	struct mxc_spi_xfer *ptransfer;
+	struct mxc_spi_unique_def *spi_ver_def;
+	unsigned int ctrl_reg;
+	unsigned int ctrl_mask;
+	unsigned int xfer_len;
+
+	if (is_active == BITBANG_CS_INACTIVE) {
+		/*Need to deselect the slave */
+		return;
+	}
+
+	/* Get the master controller driver data from spi device's master */
+
+	master_drv_data = spi_master_get_devdata(spi->master);
+	spi_ver_def = master_drv_data->spi_ver_def;
+
+	xfer_len = spi->bits_per_word;
+
+	/* Control Register Settings for transfer to this slave */
+
+	ctrl_reg = readl(master_drv_data->base + MXC_CSPICTRL);
+
+	if (spi_ver_def == &spi_ver_2_3) {
+		unsigned int config_reg = 0;
+		/* Control Register Settings for transfer to this slave */
+		ctrl_reg = MXC_CSPICTRL_ENABLE;
+		ctrl_reg |=
+		    ((spi->chip_select & MXC_CSPICTRL_CSMASK) << spi_ver_def->
+		     cs_shift);
+		ctrl_reg |=
+		    (((1 << (spi->chip_select & MXC_CSPICTRL_CSMASK)) &
+		      MXC_CSPICTRL_CHANMODEMASK_2_3) << MXC_CSPICTRL_CHANMODESHIFT_2_3);
+		ctrl_reg |=
+		    spi_find_baudrate(master_drv_data, spi->max_speed_hz);
+		ctrl_reg |=
+		    (((xfer_len -
+		       1) & spi_ver_def->bc_mask) << spi_ver_def->bc_shift);
+
+		if (spi->mode & SPI_CPHA)
+			config_reg |=
+			    (((1 << (spi->chip_select & MXC_CSPICTRL_CSMASK)) &
+			      MXC_CSPICTRL_CHANMODEMASK_2_3) <<
+			     MXC_CSPICONF_PHASHIFT_2_3);
+
+		if ((spi->mode & SPI_CPOL)) {
+			config_reg |=
+			    (((1 << (spi->chip_select & MXC_CSPICTRL_CSMASK)) &
+			      MXC_CSPICTRL_CHANMODEMASK_2_3) <<
+			     MXC_CSPICONF_POLSHIFT_2_3);
+		}
+		if (spi->mode & SPI_CS_HIGH)
+			config_reg |=
+			    (((1 << (spi->chip_select & MXC_CSPICTRL_CSMASK)) &
+			      MXC_CSPICTRL_CHANMODEMASK_2_3) <<
+			     MXC_CSPICONF_SSPOLSHIFT_2_3);
+
+		config_reg |=
+		    (((1 << (spi->chip_select & MXC_CSPICTRL_CSMASK)) &
+		      MXC_CSPICTRL_CHANMODEMASK_2_3) << MXC_CSPICONF_SSCTLSHIFT_2_3);
+
+		__raw_writel(ctrl_reg, master_drv_data->base + MXC_CSPICTRL);
+		__raw_writel(config_reg,
+			     master_drv_data->base + MXC_CSPICTRL + 4);
+
+	} else {
+		ctrl_mask =
+			(MXC_CSPICTRL_LOWPOL | MXC_CSPICTRL_PHA | MXC_CSPICTRL_HIGHSSPOL |
+			 MXC_CSPICTRL_CSMASK << spi_ver_def->cs_shift |
+			 MXC_CSPICTRL_DATAMASK << MXC_CSPICTRL_DATASHIFT |
+			 spi_ver_def->bc_mask << spi_ver_def->bc_shift);
+		ctrl_reg &= ~ctrl_mask;
+
+		ctrl_reg |=
+			((spi->chip_select & MXC_CSPICTRL_CSMASK) << spi_ver_def->cs_shift);
+		ctrl_reg |= spi_find_baudrate(master_drv_data, spi->max_speed_hz);
+		ctrl_reg |=
+			(((xfer_len - 1) & spi_ver_def->bc_mask) << spi_ver_def->bc_shift);
+		if (spi->mode & SPI_CPHA)
+			ctrl_reg |= MXC_CSPICTRL_PHA;
+		if (!(spi->mode & SPI_CPOL))
+			ctrl_reg |= MXC_CSPICTRL_LOWPOL;
+		if (spi->mode & SPI_CS_HIGH)
+			ctrl_reg |= MXC_CSPICTRL_HIGHSSPOL;
+
+		writel(ctrl_reg, master_drv_data->base + MXC_CSPICTRL);
+	}
+
+	/* Initialize the functions for transfer */
+	ptransfer = &master_drv_data->transfer;
+	if (xfer_len <= 8) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u8;
+		ptransfer->tx_get = mxc_spi_buf_tx_u8;
+	} else if (xfer_len <= 16) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u16;
+		ptransfer->tx_get = mxc_spi_buf_tx_u16;
+	} else if (xfer_len <= 32) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u32;
+		ptransfer->tx_get = mxc_spi_buf_tx_u32;
+	}
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+	{
+		struct spi_chip_info *lb_chip =
+		    (struct spi_chip_info *)spi->controller_data;
+		if (spi_ver_def == &spi_ver_2_3) {
+			if (!lb_chip)
+				writel(0, master_drv_data->base + MXC_CSPITEST + 4);
+			else if (lb_chip->lb_enable)
+				writel(MXC_CSPITEST_LBC_2_3,
+				       master_drv_data->base + MXC_CSPITEST + 4);
+
+		} else {
+			if (!lb_chip)
+				writel(0, master_drv_data->base + MXC_CSPITEST);
+			else if (lb_chip->lb_enable)
+				writel(MXC_CSPITEST_LBC,
+				       master_drv_data->base + MXC_CSPITEST);
+		}
+	}
+#endif
+	return;
+}
+
+static irqreturn_t mxc_spi_isr(int irq, void *dev_id)
+{
+	struct mxc_spi *master_drv_data = dev_id;
+	irqreturn_t ret = IRQ_NONE;
+	unsigned int status;
+
+	/* Read the interrupt status register to determine the source */
+	if (master_drv_data->spi_ver_def == &spi_ver_2_3)
+		status = readl(master_drv_data->base + MXC_CSPISTAT + 4);
+	else
+		status = readl(master_drv_data->base + MXC_CSPISTAT);
+
+	/* Rx is given higher priority - Handle it first */
+	if (status & MXC_CSPISTAT_RR) {
+		u32 rx_tmp = spi_get_rx_data(master_drv_data->base);
+
+		if (master_drv_data->transfer.rx_buf)
+			master_drv_data->transfer.rx_get(master_drv_data,
+							 rx_tmp);
+
+		ret = IRQ_HANDLED;
+	}
+
+	(master_drv_data->transfer.count)--;
+	/* Handle the Tx now */
+	if (master_drv_data->transfer.count) {
+		if (master_drv_data->transfer.tx_buf) {
+			u32 tx_tmp =
+			    master_drv_data->transfer.tx_get(master_drv_data);
+
+			spi_put_tx_data(master_drv_data->base, tx_tmp);
+		}
+	} else {
+		complete(&master_drv_data->xfer_done);
+	}
+
+	return ret;
+}
+
+int mxc_spi_setup(struct spi_device *spi)
+{
+	struct mxc_spi *master_data = spi_master_get_devdata(spi->master);
+
+	if (master_data->spi_ver_def != &spi_ver_2_3) {
+		if ((spi->max_speed_hz < 0)
+		    || (spi->max_speed_hz > (master_data->spi_ipg_clk / 4))) {
+			dev_err(&spi->dev, "Cannot set required SPI clock speed."
+				" Requested: %uHz, possible: %luHz\n",
+				spi->max_speed_hz, master_data->spi_ipg_clk / 4);
+			return -EINVAL;
+		}
+	}
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	pr_debug("%s: mode %d, %u bpw, %d hz\n", __FUNCTION__,
+		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
+
+	return 0;
+}
+
+int mxc_spi_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct mxc_spi *master_drv_data = NULL;
+
+	/* Get the master controller driver data from spi device's master */
+
+	master_drv_data = spi_master_get_devdata(spi->master);
+
+	/* Modify the Tx, Rx, Count */
+	if (t->tx_buf == NULL)
+		t->tx_buf = t->rx_buf;
+
+	master_drv_data->transfer.tx_buf = t->tx_buf;
+	master_drv_data->transfer.rx_buf = t->rx_buf;
+	master_drv_data->transfer.count = t->len;
+	INIT_COMPLETION(master_drv_data->xfer_done);
+
+	/* Enable the Rx Interrupts */
+
+	spi_enable_interrupt(master_drv_data, MXC_CSPIINT_RREN);
+
+	/* Perform single Tx transaction */
+
+	spi_put_tx_data(master_drv_data->base,
+			master_drv_data->transfer.tx_get(master_drv_data));
+
+	/* Wait for transfer completion */
+
+	wait_for_completion(&master_drv_data->xfer_done);
+
+	/* Disable the Rx Interrupts */
+
+	spi_disable_interrupt(master_drv_data, MXC_CSPIINT_RREN);
+
+	return (t->len - master_drv_data->transfer.count);
+}
+
+void mxc_spi_cleanup(struct spi_device *spi)
+{
+	return;
+}
+
+static int mxc_spi_probe(struct platform_device *pdev)
+{
+	struct mxc_spi_master *mxc_platform_info;
+	struct spi_master *master;
+	struct mxc_spi *master_drv_data = NULL;
+	unsigned int spi_ver;
+	int ret = -ENODEV;
+
+	dev_dbg(&pdev->dev, "Enter: %s\n", __FUNCTION__);
+
+	/* Get the platform specific data for this master device */
+
+	mxc_platform_info = (struct mxc_spi_master *)pdev->dev.platform_data;
+	if (!mxc_platform_info) {
+		dev_err(&pdev->dev, "can't get the platform data for CSPI\n");
+		return -EINVAL;
+	}
+
+	/* Allocate SPI master controller */
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct mxc_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "can't alloc for spi_master\n");
+		return -ENOMEM;
+	}
+
+	/* Set this device's driver data to master */
+
+	platform_set_drvdata(pdev, master);
+
+	/* Set this master's data from platform_info */
+
+	master->bus_num = pdev->id;
+	master->num_chipselect = mxc_platform_info->maxchipselect;
+
+	/* Set the master controller driver data for this master */
+
+	master_drv_data = spi_master_get_devdata(master);
+	master_drv_data->mxc_bitbang.master = spi_master_get(master);
+
+	/* Set the master bitbang data */
+
+	master_drv_data->mxc_bitbang.chipselect = mxc_spi_chipselect;
+	master_drv_data->mxc_bitbang.txrx_bufs = mxc_spi_transfer;
+	master_drv_data->mxc_bitbang.master->setup = mxc_spi_setup;
+	master_drv_data->mxc_bitbang.master->cleanup = mxc_spi_cleanup;
+
+	/* Initialize the completion object */
+
+	init_completion(&master_drv_data->xfer_done);
+
+	/* Set the master controller register addresses and irqs */
+
+	master_drv_data->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!master_drv_data->res) {
+		dev_err(&pdev->dev, "can't get platform resource for CSPI%d\n",
+			master->bus_num);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	if (!request_mem_region(master_drv_data->res->start,
+				master_drv_data->res->end -
+				master_drv_data->res->start + 1, pdev->name)) {
+		dev_err(&pdev->dev, "request_mem_region failed for CSPI%d\n",
+			master->bus_num);
+		ret = -EBUSY;
+		goto err;
+	}
+
+	master_drv_data->base = ioremap(master_drv_data->res->start,
+					master_drv_data->res->end -
+					master_drv_data->res->start + 1);
+
+	if (!master_drv_data->base) {
+		dev_err(&pdev->dev, "Cannot map iomem for CSPI%d\n",
+			master->bus_num);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	master_drv_data->irq = platform_get_irq(pdev, 0);
+	if (!master_drv_data->irq) {
+		dev_err(&pdev->dev, "can't get IRQ for CSPI%d\n",
+			master->bus_num);
+		ret = -EINVAL;
+		goto err2;
+	}
+
+	/* Register for SPI Interrupt */
+
+	ret = request_irq(master_drv_data->irq, mxc_spi_isr,
+			  0, "CSPI_IRQ", master_drv_data);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "request_irq failed for CSPI%d\n",
+			master->bus_num);
+		goto err2;
+	}
+	/* Setup any GPIO active */
+	mxc_platform_info->init(pdev);
+	/* Identify SPI version */
+
+	spi_ver = mxc_platform_info->spi_version;
+	if (spi_ver == 7) {
+		master_drv_data->spi_ver_def = &spi_ver_0_7;
+	} else if (spi_ver == 5) {
+		master_drv_data->spi_ver_def = &spi_ver_0_5;
+	} else if (spi_ver == 4) {
+		master_drv_data->spi_ver_def = &spi_ver_0_4;
+	} else if (spi_ver == 0) {
+		master_drv_data->spi_ver_def = &spi_ver_0_0;
+	} else if (spi_ver == 23) {
+		master_drv_data->spi_ver_def = &spi_ver_2_3;
+	}
+
+
+	/* Enable the CSPI Clock, CSPI Module, set as a master */
+
+	master_drv_data->clk = clk_get(&pdev->dev, "cspi_clk");
+	clk_enable(master_drv_data->clk);
+	master_drv_data->spi_ipg_clk = clk_get_rate(master_drv_data->clk);
+
+	if (spi_ver == 23) {
+		writel(MXC_CSPICTRL_ENABLE,
+		       master_drv_data->base + MXC_CSPICTRL);
+		writel(MXC_CSPIPERIOD_32KHZ,
+		       master_drv_data->base + MXC_CSPIPERIOD + 4);
+		writel(0, master_drv_data->base + MXC_CSPIINT + 4);
+
+	} else {
+		writel(0x00008000, master_drv_data->base + MXC_CSPICTRL); /* reset default */
+		writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
+		       master_drv_data->base + MXC_CSPICTRL);
+		writel(MXC_CSPIPERIOD_32KHZ,
+		       master_drv_data->base + MXC_CSPIPERIOD);
+		writel(0, master_drv_data->base + MXC_CSPIINT);
+	}
+
+	/* Start the SPI Master Controller driver */
+
+	ret = spi_bitbang_start(&master_drv_data->mxc_bitbang);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Cannot start bitbang driver\n");
+		goto err3;
+	}
+
+	printk(KERN_INFO "CSPI: %s-%d probed\n", pdev->name, pdev->id);
+
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+	{
+		int i;
+		struct spi_board_info *bi = &loopback_info[0];
+		for (i = 0; i < ARRAY_SIZE(loopback_info); i++, bi++) {
+			if (bi->bus_num != master->bus_num)
+				continue;
+
+			dev_info(&pdev->dev,
+				 "registering loopback device '%s'\n",
+				 bi->modalias);
+
+			spi_new_device(master, bi);
+		}
+	}
+#endif
+	return ret;
+
+err3:
+	clk_disable(master_drv_data->clk);
+	clk_put(master_drv_data->clk);
+	mxc_platform_info->exit(pdev);
+	free_irq(master_drv_data->irq, master_drv_data);
+err2:
+	iounmap(master_drv_data->base);
+err1:
+	release_mem_region(pdev->resource[0].start,
+			pdev->resource[0].end - pdev->resource[0].start + 1);
+err:
+	spi_master_put(master);
+	kfree(master);
+	platform_set_drvdata(pdev, NULL);
+	return ret;
+}
+
+static int mxc_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct mxc_spi_master *mxc_platform_info =
+		(struct mxc_spi_master *)pdev->dev.platform_data;
+
+	if (master) {
+		struct mxc_spi *master_drv_data =
+		    spi_master_get_devdata(master);
+
+		mxc_platform_info->exit(pdev);
+		clk_disable(master_drv_data->clk);
+		/* clk_put(master_drv_data->clk); */	/* FIXME required? */
+
+		/* Disable the CSPI module */
+
+		writel(MXC_CSPICTRL_DISABLE,
+			     master_drv_data->base + MXC_CSPICTRL);
+
+		spi_bitbang_stop(&master_drv_data->mxc_bitbang);
+
+		/* free resources */
+		spi_master_put(master);
+		free_irq(master_drv_data->irq, master_drv_data);
+		iounmap(master_drv_data->base);
+		release_mem_region(master_drv_data->res->start,
+					master_drv_data->res->end -
+					master_drv_data->res->start + 1);
+	}
+
+	printk(KERN_INFO "CSPI: %s-%d removed\n", pdev->name, pdev->id);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int spi_bitbang_suspend(struct spi_bitbang *bitbang)
+{
+	unsigned long flags;
+	unsigned limit = 500;
+
+	spin_lock_irqsave(&bitbang->lock, flags);
+	while (!list_empty(&bitbang->queue) && limit--) {
+		spin_unlock_irqrestore(&bitbang->lock, flags);
+
+		dev_dbg(&bitbang->master->dev, "wait for queue\n");
+		msleep(10);
+
+		spin_lock_irqsave(&bitbang->lock, flags);
+	}
+	if (!list_empty(&bitbang->queue)) {
+		dev_err(&bitbang->master->dev, "queue didn't empty\n");
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&bitbang->lock, flags);
+
+	return 0;
+}
+
+static void spi_bitbang_resume(struct spi_bitbang *bitbang)
+{
+	spin_lock_init(&bitbang->lock);
+	INIT_LIST_HEAD(&bitbang->queue);
+
+	bitbang->busy = 0;
+}
+
+static int mxc_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct mxc_spi *master_drv_data = spi_master_get_devdata(master);
+	struct mxc_spi_master *mxc_platform_info =
+		(struct mxc_spi_master *)pdev->dev.platform_data;
+
+	spi_bitbang_suspend(&master_drv_data->mxc_bitbang);
+	writel(MXC_CSPICTRL_DISABLE,
+		     master_drv_data->base + MXC_CSPICTRL);
+
+	clk_disable(master_drv_data->clk);
+	mxc_platform_info->exit(pdev);
+
+	return 0;
+}
+
+static int mxc_spi_resume(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct mxc_spi *master_drv_data = spi_master_get_devdata(master);
+	struct mxc_spi_master *mxc_platform_info =
+		(struct mxc_spi_master *)pdev->dev.platform_data;
+
+	mxc_platform_info->init(pdev);
+	clk_enable(master_drv_data->clk);
+
+	spi_bitbang_resume(&master_drv_data->mxc_bitbang);
+
+	if (mxc_platform_info->spi_version == 23)
+		writel(MXC_CSPICTRL_ENABLE, master_drv_data->base + MXC_CSPICTRL);
+	else
+		writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
+		       master_drv_data->base + MXC_CSPICTRL);
+
+	return 0;
+}
+#else
+# define mxc_spi_suspend  NULL
+# define mxc_spi_resume   NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver mxc_spi_driver = {
+	.driver = {
+		   .name = "mxc_spi",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_spi_probe,
+	.remove = mxc_spi_remove,
+	.suspend = mxc_spi_suspend,
+	.resume = mxc_spi_resume,
+};
+
+static int __init mxc_spi_init(void)
+{
+	pr_debug("Registering the SPI Controller Driver\n");
+	return platform_driver_register(&mxc_spi_driver);
+}
+
+static void __exit mxc_spi_exit(void)
+{
+	pr_debug("Unregistering the SPI Controller Driver\n");
+	platform_driver_unregister(&mxc_spi_driver);
+}
+
+subsys_initcall(mxc_spi_init);
+module_exit(mxc_spi_exit);
+
+MODULE_DESCRIPTION("SPI Master Controller driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

