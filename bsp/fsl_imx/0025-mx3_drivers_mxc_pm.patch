From a80a72de6f705c2e9128c1a8f145fadc8a7c13d8 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Wed, 29 Oct 2008 16:35:18 +0800
Subject: [PATCH] imx_drivers_mx3_pm

MX3 Power Managment driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/pm/Kconfig                       |   32 +
 drivers/mxc/pm/Makefile                      |   11 +
 drivers/mxc/pm/dptc.c                        |  923 +++++++++++++++++++
 drivers/mxc/pm/dvfs_dptc.c                   | 1234 ++++++++++++++++++++++++++
 drivers/mxc/pm/dvfs_dptc.h                   |   76 ++
 drivers/mxc/pm/dvfs_dptc_table_mx31.h        |  157 ++++
 drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h |  152 ++++
 7 files changed, 2585 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/pm/Kconfig
 create mode 100644 drivers/mxc/pm/Makefile
 create mode 100644 drivers/mxc/pm/dptc.c
 create mode 100644 drivers/mxc/pm/dvfs_dptc.c
 create mode 100644 drivers/mxc/pm/dvfs_dptc.h
 create mode 100644 drivers/mxc/pm/dvfs_dptc_table_mx31.h
 create mode 100644 drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h

diff --git a/drivers/mxc/pm/Kconfig b/drivers/mxc/pm/Kconfig
new file mode 100644
index 0000000..dde07bd
--- /dev/null
+++ b/drivers/mxc/pm/Kconfig
@@ -0,0 +1,32 @@
+#
+# Power Managment devices
+#
+
+menu "Advanced Power Management devices"
+
+config MXC_DPTC
+	bool "MXC DPTC driver"
+	depends on ARCH_MX3 && MXC_PMIC_MC13783
+	default y
+	help
+	   This selects the Freescale MXC Internal DPTC driver.
+	   If unsure, say N.
+
+config MXC_DVFS
+	bool "MXC DVFS driver"
+	depends on ARCH_MX3
+	default y
+	help
+	  This selects the Freescale MXC Internal DVFS driver.
+	  If unsure, say N.
+
+config MXC_DVFS_SDMA
+	bool "MXC DVFS SDMA support"
+	depends on MXC_DVFS
+	default n
+	help
+	  This selects the Freescale MXC Internal DVFS driver SDMA support.
+	  If unsure, say N.
+
+endmenu
+
diff --git a/drivers/mxc/pm/Makefile b/drivers/mxc/pm/Makefile
new file mode 100644
index 0000000..853f049
--- /dev/null
+++ b/drivers/mxc/pm/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for Power Managment devices.
+#
+
+# Module dependencies for the MXC driver
+obj-$(CONFIG_MXC_DPTC)		+= dptc.o
+
+obj-$(CONFIG_MXC_DPTC)		+= dvfs_dptc.o
+
+obj-$(CONFIG_MXC_DVFS)		+= dvfs_dptc.o
+
diff --git a/drivers/mxc/pm/dptc.c b/drivers/mxc/pm/dptc.c
new file mode 100644
index 0000000..2a91fc1
--- /dev/null
+++ b/drivers/mxc/pm/dptc.c
@@ -0,0 +1,923 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DPTC module.
+ *
+ * The DPTC driver
+ * driver is designed as a character driver which interacts with the MXC DPTC
+ * hardware. Upon initialization, the DPTC driver initializes the DPTC hardware
+ * sets up driver nodes attaches to the DPTC interrupt and initializes internal
+ * data structures. When the DPTC interrupt occurs the driver checks the cause
+ * of the interrupt (lower voltage, increase voltage or emergency) and changes
+ * the CPU voltage according to translation table that is loaded into the driver
+ * (the voltage changes are done by calling some * routines in the mc13783
+ * driver). The driver read method is used to read the currently loaded DPTC
+ * translation table and the write method is used in-order to update the
+ * translation table. Driver ioctls are used to change driver parameters and
+ * enable/disable the DPTC operation.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/sdma.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/pmic_power.h>
+
+/*
+ * Module header file
+ */
+#include <mach/dptc.h>
+
+/*
+ * CRM registers
+ */
+#ifdef CONFIG_ARCH_MX3
+#include "../../../arch/arm/mach-mx3/crm_regs.h"
+#endif
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
+ * (current working point, current frequency, translation table and DPTC
+ * log buffer).
+ */
+static dvfs_dptc_params_s *dvfs_dptc_params;
+
+static struct work_struct dptc_work;
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+static unsigned long ptvai;
+#endif
+
+/*!
+ * Enable DPTC hardware
+ */
+static void dptc_enable_dptc(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPTEN,
+			   MXC_CCM_PMCR0_DPTEN);
+}
+
+/*!
+ * Disable DPTC hardware
+ */
+static void dptc_disable_dptc(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPTEN, 0);
+}
+
+/*!
+ * Mask DPTC interrupt
+ */
+static void dptc_mask_dptc_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVAIM,
+			   MXC_CCM_PMCR0_PTVAIM);
+}
+
+/*!
+ * Unmask DPTC interrupt
+ */
+static void dptc_unmask_dptc_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVAIM, 0);
+}
+
+/*!
+ * Read the PTVAI bits from the CCM
+ *
+ * @return  PTVAI bits value
+ */
+static unsigned long dptc_get_ptvai(void)
+{
+	return (mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_PTVAI_MASK)
+	    >> MXC_CCM_PMCR0_PTVAI_OFFSET;
+}
+
+/*!
+ * Clear DCR bits of the CCM
+ */
+static void dptc_clear_dcr(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DCR, 0);
+}
+
+/*!
+ * If value equal to PTVAI bits indicates working point decrease
+ */
+#define DPTC_DECREASE		(unsigned long)0x1
+
+/*!
+ * If value equal to PTVAI bits indicates working point increase
+ */
+#define DPTC_INCREASE		(unsigned long)0x2
+
+/*!
+ * If value equal to PTVAI bits indicates working point increase to maximum
+ */
+#define DPTC_EMERG		(unsigned long)0x3
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*
+ * MCU will get DPTC interrupt
+ */
+static void dptc_set_ptvis(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_PTVIS,
+			   MXC_CCM_PMCR0_PTVIS);
+}
+#endif
+#endif
+
+/*!
+ * This function enables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to enable
+ * @return   0 on success, error code on failure
+ */
+int enable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state)
+{
+	int ret_val;
+
+	if (params->dptc_is_active == FALSE) {
+		params->rc_state = rc_state;
+
+		if (rc_state & 0x1) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE0,
+					   MXC_CCM_PMCR0_DRCE0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 0 enabled\n");
+#endif
+		}
+		if (rc_state & 0x2) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE1,
+					   MXC_CCM_PMCR0_DRCE1);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 1 enabled\n");
+#endif
+		}
+		if (rc_state & 0x4) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE2,
+					   MXC_CCM_PMCR0_DRCE2);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 2 enabled\n");
+#endif
+		}
+		if (rc_state & 0x8) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DRCE3,
+					   MXC_CCM_PMCR0_DRCE3);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 3 enabled\n");
+#endif
+		}
+
+		ret_val = 0;
+	else
+		ret_val = -EINVAL;
+
+	return ret_val;
+}
+
+/*!
+ * This function disables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to disable
+ * @return   0 on success, error code on failure
+ */
+int disable_ref_circuits(dvfs_dptc_params_s *params, unsigned char rc_state)
+{
+	int ret_val;
+
+	if (params->dptc_is_active == FALSE) {
+		params->rc_state &= ~rc_state;
+
+		if (rc_state & 0x1) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE0, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 0 disabled\n");
+#endif
+		}
+		if (rc_state & 0x2) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE1, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 1 disabled\n");
+#endif
+		}
+		if (rc_state & 0x4) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE2, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 2 disabled\n");
+#endif
+		}
+		if (rc_state & 0x8) {
+			mxc_ccm_modify_reg(MXC_CCM_PMCR0,
+					   MXC_CCM_PMCR0_DRCE3, 0);
+#ifdef EVB_DEBUG
+			printk(KERN_INFO "Ref circuit 3 disabled\n");
+#endif
+		}
+
+		ret_val = 0;
+	} else {
+		ret_val = -EINVAL;
+	}
+
+	return ret_val;
+}
+
+static void dptc_workqueue_handler(void *arg)
+{
+	dvfs_dptc_params_s *params;
+
+	params = (dvfs_dptc_params_s *) arg;
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "In %s: PTVAI = %d\n", __func__, dptc_get_ptvai());
+	printk(KERN_INFO "DCVR0 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR0));
+	printk(KERN_INFO "DCVR1 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR1));
+	printk(KERN_INFO "DCVR2 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR2));
+	printk(KERN_INFO "DCVR3 = 0x%x ", mxc_ccm_get_reg(MXC_CCM_DCVR3));
+	printk(KERN_INFO "PTVAI = 0x%x\n", ptvai);
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	switch (ptvai) {
+		/* Chip working point has decreased,
+		 * lower working point by one */
+	case DPTC_DECREASE:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp + 1);
+		break;
+
+		/* Chip working point has increased,
+		 * raise working point by one */
+	case DPTC_INCREASE:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp - 1);
+		break;
+
+		/*
+		 * Chip working point has increased dramatically,
+		 * raise working point to maximum */
+	case DPTC_EMERG:
+		set_dptc_wp(params,
+			    params->dvfs_dptc_tables_ptr->curr_wp - 1);
+		break;
+
+		/* Unknown interrupt cause */
+	default:
+		break;
+	}
+#else
+	set_dptc_wp(params, params->dvfs_dptc_tables_ptr->curr_wp);
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DPVV,
+			   MXC_CCM_PMCR0_DPVV);
+#endif
+
+	/*
+	 * If the DPTC module is still active, re-enable
+	 * the DPTC hardware
+	 */
+	if (params->dptc_is_active) {
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+	}
+}
+
+/*!
+ * This function is the DPTC Interrupt handler.
+ * This function wakes-up the dptc_workqueue_handler
+ * function that handles the
+ * DPTC interrupt.
+ */
+void dptc_irq(void)
+{
+#ifndef CONFIG_MXC_DVFS_SDMA
+	ptvai = dptc_get_ptvai();
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "Got DPTC interrupt on %d ", (int)jiffies);
+	printk(KERN_INFO "ptvai = 0x%x (0x%x)!!!!!!!\n", ptvai,
+	       mxc_ccm_get_reg(MXC_CCM_PMCR0));
+#endif
+
+	if (ptvai != 0) {
+		dptc_mask_dptc_int();
+		dptc_disable_dptc();
+
+		schedule_delayed_work(&dptc_work, 0);
+	}
+#else
+	schedule_delayed_work(&dptc_work, 0);
+#endif
+}
+
+/*!
+ * This function updates the CPU voltage,
+ * produced by mc13783, by calling mc13783
+ * driver functions.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ *				frequency.
+ *
+ */
+void set_pmic_voltage(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr, int wp)
+{
+	/* Call mc13783 functions */
+	t_regulator_voltage volt;
+
+	/* Normal mode setting */
+	volt.sw1a = dvfs_dptc_tables_ptr->wp[wp].pmic_values[0];
+	pmic_power_regulator_set_voltage(SW_SW1A, volt);
+
+#ifdef CONFIG_MXC_DVFS
+	volt.sw1a = dvfs_dptc_tables_ptr->wp[wp].pmic_values[1];
+	pmic_power_switcher_set_dvs(SW_SW1A, volt);
+
+	volt.sw1b = dvfs_dptc_tables_ptr->wp[wp].pmic_values[2];
+	pmic_power_switcher_set_dvs(SW_SW1B, volt);
+
+	volt.sw1b = dvfs_dptc_tables_ptr->wp[wp].pmic_values[3];
+	pmic_power_switcher_set_stby(SW_SW1B, volt);
+#endif
+
+#ifdef EVB_DEBUG
+	if (cpu_is_mx31()) {
+		printk(KERN_INFO "DPVV = 0x%x (0x%x)\n",
+		       mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_DPVV,
+		       mxc_ccm_get_reg(MXC_CCM_PMCR0));
+	}
+#endif				/* EVB_DEBUG */
+}
+
+/*!
+ * This function enables the DPTC module. this function updates the DPTC
+ * thresholds, updates the mc13783, unmasks the DPTC interrupt and enables
+ * the DPTC module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was enabled else returns -EINVAL.
+ */
+int start_dptc(dvfs_dptc_params_s *params)
+{
+	int freq_index = 0;
+
+	/* Check if DPTC module isn't already active */
+	if (params->dptc_is_active == FALSE) {
+
+		enable_ref_circuits(params, params->rc_state);
+		disable_ref_circuits(params, ~params->rc_state);
+
+		/*
+		 * Set the DPTC thresholds and mc13783 voltage to
+		 * correspond to the current working point and frequency.
+		 */
+		set_pmic_voltage(params->dvfs_dptc_tables_ptr,
+				 params->dvfs_dptc_tables_ptr->curr_wp);
+
+#ifdef CONFIG_MXC_DVFS
+		freq_index = dvfs_get_dvsup();
+#endif
+
+		update_dptc_thresholds(params->dvfs_dptc_tables_ptr,
+				       params->dvfs_dptc_tables_ptr->curr_wp,
+				       freq_index);
+
+		/* Mark DPCT module as active */
+		params->dptc_is_active = TRUE;
+
+		/* Enable the DPTC module and unmask the DPTC interrupt */
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+
+		return 0;
+	}
+
+	/* DPTC module already active return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function disables the DPTC module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was disabled else returns -EINVAL.
+ */
+int stop_dptc(dvfs_dptc_params_s *params)
+{
+	/* Check if DPTC module isn't already disabled */
+	if (params->dptc_is_active != FALSE) {
+
+		/* Disable the DPTC module and mask the DPTC interrupt */
+		dptc_disable_dptc();
+		dptc_mask_dptc_int();
+
+		/* Set working point 0 */
+		set_dptc_wp(params, 0);
+
+		/* Mark DPCT module as inactive */
+		params->dptc_is_active = FALSE;
+
+		return 0;
+	}
+
+	/* DPTC module already disabled, return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function updates the drivers current working point index. This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU working point measured by the DPTC hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    new_wp	New working point index value to be set.
+ *
+ */
+void set_dptc_wp(dvfs_dptc_params_s *params, int new_wp)
+{
+	int freq_index = 0;
+
+#ifdef CONFIG_MXC_DVFS
+	freq_index = dvfs_get_dvsup();
+#endif
+
+	/*
+	 * Check if new index is smaller than the maximal working point
+	 * index in the DPTC translation table and larger that 0.
+	 */
+	if ((new_wp < params->dvfs_dptc_tables_ptr->wp_num)
+	    && (new_wp >= 0))
+		/* Set current working point index to new index */
+		params->dvfs_dptc_tables_ptr->curr_wp = new_wp;
+
+	/*
+	 * Check if new index is larger than the maximal working point index in
+	 * the DPTC translation table.
+	 */
+	if (new_wp >= params->dvfs_dptc_tables_ptr->wp_num) {
+		/*
+		 * Set current working point index to maximal working point
+		 * index in the DPTC translation table.
+		 */
+		params->dvfs_dptc_tables_ptr->curr_wp =
+		    params->dvfs_dptc_tables_ptr->wp_num - 1;
+	}
+
+	/* Check if new index is smaller than 0. */
+	if (new_wp < 0)
+		/* Set current working point index to 0 (minimal value) */
+		params->dvfs_dptc_tables_ptr->curr_wp = 0;
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/* Update the DPTC hardware thresholds */
+	update_dptc_thresholds(params->dvfs_dptc_tables_ptr,
+			       params->dvfs_dptc_tables_ptr->curr_wp,
+			       freq_index);
+#else
+	params->prev_wp = params->dvfs_dptc_tables_ptr->curr_wp;
+#endif
+
+	/* Update the mc13783 voltage */
+	set_pmic_voltage(params->dvfs_dptc_tables_ptr,
+			 params->dvfs_dptc_tables_ptr->curr_wp);
+
+	/* Write DPTC changes in the DPTC log buffer */
+	add_dptc_log_entry(params, &params->dptc_log_buffer,
+			   params->dvfs_dptc_tables_ptr->curr_wp, freq_index);
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "Current wp: %d\n",
+			params->dvfs_dptc_tables_ptr->curr_wp);
+#endif
+}
+
+/*!
+ * This function updates the DPTC threshold registers.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ * @param    freq_index		translation table index of the current CPU
+ *				frequency.
+ *
+ */
+void update_dptc_thresholds(dvfs_dptc_tables_s *dvfs_dptc_tables_ptr,
+			    int wp, int freq_index)
+{
+	dcvr_state *dcvr;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+
+	dcvr_state **dcvr_arr;
+	dcvr_state *curr_freq_dcvr;
+
+	dcvr_arr = dvfs_dptc_tables_ptr->dcvr;
+	dcvr_arr = sdma_phys_to_virt((unsigned long)dcvr_arr);
+	curr_freq_dcvr = dcvr_arr[freq_index];
+	curr_freq_dcvr = sdma_phys_to_virt((unsigned long)curr_freq_dcvr);
+	dcvr = &curr_freq_dcvr[wp];
+#else
+	/* Calculate current table entry offset in the DPTC translation table */
+	dcvr = &dvfs_dptc_tables_ptr->dcvr[freq_index][wp];
+#endif
+	/* Update DPTC threshold registers */
+	mxc_ccm_modify_reg(MXC_CCM_DCVR0,
+			0xffffffff, dcvr->dcvr_reg[0].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR1,
+			0xffffffff, dcvr->dcvr_reg[1].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR2,
+			0xffffffff, dcvr->dcvr_reg[2].AsInt);
+	mxc_ccm_modify_reg(MXC_CCM_DCVR3,
+			0xffffffff, dcvr->dcvr_reg[3].AsInt);
+}
+
+/*!
+ * This function increments a log buffer index (head or tail)
+ * by the value of val.
+ *
+ * @param    index	pointer to the DPTC log buffer index that
+ *			we wish to change.
+ * @param    val	the value in which the index should be incremented.
+ *
+ */
+static void inc_log_index(int *index, int val)
+{
+	*index = (*index + val) % LOG_ENTRIES;
+}
+
+/*!
+ * This function returns the number of entries in the DPTC log buffer.
+ *
+ * @param    dptc_log	pointer to the DPTC log buffer structure.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+static int get_entry_count(dptc_log_s *dptc_log)
+{
+	return (dptc_log->head - dptc_log->tail + LOG_ENTRIES) % LOG_ENTRIES;
+}
+
+/*!
+ * This function is used by the proc file system to read the DPTC log buffer.
+ * Each time the DPTC proc file system file is read this function is called
+ * and returns the data written in the log buffer.
+ *
+ * @param    buf	pointer to the buffer the data should be written to.
+ * @param    start	pointer to the pointer where the new data is
+ *                      written to.
+ *			procedure should update the start pointer to point to
+ *			where in the buffer the data was written.
+ * @param    offset	current offset in the DPTC proc file.
+ * @param    count	number of bytes to read.
+ * @param    eof	pointer to eof flag. should be set to 1 when
+ *                      reaching eof.
+ * @param    data	driver specific data pointer.
+ *
+ * @return   number byte read from the log buffer.
+ *
+ */
+static int read_log(char *buf, char **start, off_t offset, int count,
+		    int *eof, void *data)
+{
+	int ret;
+	int entries_to_read;
+	int num_of_entries;
+	int entries_to_end_of_buffer, entries_left;
+	void *entry_ptr;
+	char *buf_ptr;
+	dvfs_dptc_params_s *params;
+
+	params = (dvfs_dptc_params_s *) data;
+
+	/* Calculate number of log entries to read */
+	entries_to_read = count / sizeof(dptc_log_entry_s);
+	/* Get the number of current log buffer entries */
+	num_of_entries = get_entry_count(&params->dptc_log_buffer);
+
+	/*
+	 * If number of entries to read is larger that the number of entries
+	 * in the log buffer set number of entries to read to number of
+	 * entries in the log buffer and set eof flag to 1
+	 */
+	if (num_of_entries < entries_to_read) {
+		entries_to_read = num_of_entries;
+		*eof = 1;
+	}
+
+	/*
+	 * Down the log buffer mutex to exclude others from reading and
+	 * writing to the log buffer.
+	 */
+	if (down_interruptible(&params->dptc_log_buffer.mutex))
+		return -EAGAIN;
+
+	if (num_of_entries == 0 && offset == 0) {
+		inc_log_index(&params->dptc_log_buffer.tail, -1);
+		num_of_entries++;
+		entries_to_read++;
+	}
+
+	/* get the pointer of the last (oldest) entry in the log buffer */
+	entry_ptr = (void *)&params->dptc_log_buffer.
+	    entries[params->dptc_log_buffer.tail];
+
+	/* Check if tail index wraps during current read */
+	if ((params->dptc_log_buffer.tail + entries_to_read) < LOG_ENTRIES) {
+		/* No tail wrap around copy data from log buffer to buf */
+		memcpy(buf, entry_ptr,
+		       (entries_to_read * sizeof(dptc_log_entry_s)));
+	} else {
+		/*
+		 * Tail wrap around.
+		 * First copy data from current position until end of buffer,
+		 * after that copy the rest from start of the log buffer.
+		 */
+		entries_to_end_of_buffer = LOG_ENTRIES -
+		    params->dptc_log_buffer.tail;
+		memcpy(buf, entry_ptr,
+		       (entries_to_end_of_buffer * sizeof(dptc_log_entry_s)));
+
+		entry_ptr = (void *)&params->dptc_log_buffer.entries[0];
+		buf_ptr = buf +
+		    (entries_to_end_of_buffer * sizeof(dptc_log_entry_s));
+		entries_left = entries_to_read - entries_to_end_of_buffer;
+		memcpy(buf_ptr, entry_ptr,
+		       (entries_left * sizeof(dptc_log_entry_s)));
+	}
+
+	/* Increment the tail index by the number of entries read */
+	inc_log_index(&params->dptc_log_buffer.tail, entries_to_read);
+
+	/* Up the log buffer mutex to allow access to the log buffer */
+	up(&params->dptc_log_buffer.mutex);
+
+	/* set start of data to point to buf */
+	*start = buf;
+
+	ret = (entries_to_read * sizeof(dptc_log_entry_s));
+	return ret;
+}
+
+/*!
+ * This function initializes the DPTC log buffer.
+ *
+ * @param    params	pointer to \b dvfs_dptc_params_s.
+ * @param    dptc_log	pointer to the DPTC log buffer structure.
+ *
+ */
+void init_dptc_log(dvfs_dptc_params_s *params, dptc_log_s *dptc_log)
+{
+	dptc_log->tail = 0;
+	dptc_log->head = 0;
+
+	/* initialize log buffer mutex used for accessing the log buffer */
+	sema_init(&dptc_log->mutex, 1);
+
+	/* add the first log buffer entry */
+	add_dptc_log_entry(params, dptc_log,
+			   params->dvfs_dptc_tables_ptr->curr_wp,
+			   params->current_freq_index);
+}
+
+/*!
+ * This function adds a new entry to the DPTC log buffer.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    dptc_log		pointer to the DPTC log buffer structure.
+ * @param    wp			value of the working point index written
+ *				to the log buffer.
+ * @param    freq_index		value of the frequency index written to
+ *				the log buffer.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+void add_dptc_log_entry(dvfs_dptc_params_s *params,
+			dptc_log_s *dptc_log, int wp, int freq_index)
+{
+	/*
+	 * Down the log buffer mutex to exclude others from reading and
+	 * writing to the log buffer.
+	 */
+	if (down_interruptible(&dptc_log->mutex))
+		return;
+
+	/* Write values to log buffer */
+	dptc_log->entries[dptc_log->head].jiffies = jiffies;
+	dptc_log->entries[dptc_log->head].wp = wp;
+
+	dptc_log->entries[dptc_log->head].voltage = wp;
+
+#ifdef CONFIG_MXC_DVFS
+	freq_index = dptc_get_ptvai();
+#endif
+
+	dptc_log->entries[dptc_log->head].freq = freq_index;
+
+	/* Increment the head index by 1 */
+	inc_log_index(&dptc_log->head, 1);
+	/* If head index reaches the tail increment the tail by 1 */
+	if (dptc_log->head == dptc_log->tail)
+		inc_log_index(&dptc_log->tail, 1);
+
+	/* Up the log buffer mutex to allow access to the log buffer */
+	up(&dptc_log->mutex);
+}
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_suspend(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params->dptc_is_active) {
+		dptc_disable_dptc();
+		set_dptc_wp(dvfs_dptc_params,
+			    dvfs_dptc_params->
+			    dvfs_dptc_tables_ptr->curr_wp - 1);
+	}
+#endif
+}
+EXPORT_SYMBOL(dptc_suspend);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_resume(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params->dptc_is_active) {
+		dptc_enable_dptc();
+		dptc_unmask_dptc_int();
+	}
+#endif
+}
+EXPORT_SYMBOL(dptc_resume);
+
+/*!
+ * This function initializes the DPTC hardware
+ *
+ * @param    params    pointer to the DPTC driver parameters structure.
+ *
+ */
+int __init init_dptc_controller(dvfs_dptc_params_s *params)
+{
+	dvfs_dptc_params = params;
+
+	INIT_WORK(&dptc_work, dptc_workqueue_handler);
+
+	if (create_proc_read_entry(PROC_NODE_NAME, 0,
+				   NULL, read_log, params) == NULL) {
+		/*
+		 * Error creating proc file system entry.
+		 * Exit and return error code
+		 */
+		printk(KERN_ERR "DPTC: Unable create proc entry");
+		return -EFAULT;
+	}
+
+	/* Initialize the DPTC log buffer */
+	init_dptc_log(params, &params->dptc_log_buffer);
+
+	set_dptc_curr_freq(params, 0);
+	set_dptc_wp(params, 0);
+
+	/* By default all reference circuits are enabled */
+	params->rc_state = DPTC_REF_CIRCUITS_STATUS;
+	dptc_clear_dcr();
+
+	/* Disable DPTC hardware and mask DPTC interrupt */
+	dptc_disable_dptc();
+	dptc_mask_dptc_int();
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DVFS_SDMA
+	dptc_set_ptvis();
+#endif
+#endif
+	printk(KERN_INFO "DPTC controller initialized\n");
+
+	return 0;
+}
+
+/*!
+ * This function updates the drivers current frequency index.This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU frequency (each CPU frequency has a separate index number
+ * according to the loaded DPTC table).
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ * @param    freq_index	  New frequency index value to be set.
+ *
+ * @return      0 if the frequency index was updated (the new index is a
+ *		valid index and the DPTC module isn't active) else returns
+ *              -EINVAL.
+ *
+ */
+int set_dptc_curr_freq(dvfs_dptc_params_s *params, unsigned int freq_index)
+{
+	/*
+	 * Check if the new index value is a valid frequency index (smaller
+	 * than the maximal index in the DPTC table) and if the DPTC module
+	 * is disabled.
+	 */
+	if ((freq_index < params->dvfs_dptc_tables_ptr->dvfs_state_num)
+	    && (params->dptc_is_active == FALSE)) {
+		/*
+		 * Index is valid and DPTC module is
+		 * disabled -> change frequency index.
+		 */
+		params->current_freq_index = freq_index;
+		add_dptc_log_entry(params, &params->dptc_log_buffer,
+				   params->dvfs_dptc_tables_ptr->curr_wp,
+				   params->current_freq_index);
+
+		return 0;
+	}
+
+	/* Invalid index or DPTC module is active -> return error */
+	return -EINVAL;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * DPTC SDMA callback.
+ * Updates the mc13783 voltage
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dptc_sdma_callback(dvfs_dptc_params_s *params)
+{
+	printk(KERN_INFO "In %s: params->dvfs_dptc_tables_ptr->curr_wp = %d\n",
+	       __func__, params->dvfs_dptc_tables_ptr->curr_wp);
+}
+#endif
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dptc_suspend();
+	return 0;
+}
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_resume(struct platform_device *pdev)
+{
+	dptc_resume();
+	return 0;
+}
diff --git a/drivers/mxc/pm/dvfs_dptc.c b/drivers/mxc/pm/dvfs_dptc.c
new file mode 100644
index 0000000..6c27335
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc.c
@@ -0,0 +1,1234 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_dptc.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DVFS & DPTC module.
+ *
+ * The DVFS & DPTC driver
+ * driver is designed as a character driver which interacts with the MXC
+ * DVFS & DPTC hardware. Upon initialization, the DVFS & DPTC driver initializes
+ * the DVFS & DPTC hardware sets up driver nodes attaches to the DVFS & DPTC
+ * interrupts and initializes internal data structures. When the DVFS or DPTC
+ * interrupt occurs the driver checks the cause of the interrupt
+ * (lower voltage/frequency, increase voltage/frequency or emergency)
+ * and changes the CPU voltage and/or frequency according to translation table
+ * that is loaded into the driver (the voltage changes are done by calling
+ * some routines of the mc13783 driver).
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/vmalloc.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*
+ * Module header files
+ */
+#include "dvfs_dptc.h"
+#include <mach/dptc.h>
+
+#ifdef CONFIG_MXC_DVFS
+#include <mach/dvfs.h>
+#endif
+
+/*
+ * Comment EVB_DEBUG to disable debug messages
+ */
+/* #define EVB_DEBUG 1 */
+
+/*
+ * Prototypes
+ */
+static int dvfs_dptc_open(struct inode *inode, struct file *filp);
+static int dvfs_dptc_release(struct inode *inode, struct file *filp);
+static int dvfs_dptc_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+#ifdef CONFIG_MXC_DVFS_SDMA
+static ssize_t dvfs_dptc_read(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos);
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+static irqreturn_t dvfs_dptc_irq(int irq, void *dev_id);
+#else
+static void dvfs_dptc_sdma_callback(dvfs_dptc_params_s *params);
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_dptc_driver = {
+	.driver = {
+		   .name = "mxc_dptc",
+		   },
+	.suspend = mxc_dptc_suspend,
+	.resume = mxc_dptc_resume,
+};
+
+/*!
+ * This is platform device structure for adding MU
+ */
+static struct platform_device mxc_dptc_device = {
+	.name = "mxc_dptc",
+	.id = 0,
+};
+#endif
+
+/*
+ * Global variables
+ */
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
+ * (current working point, current frequency, translation table and DPTC
+ * log buffer).
+ */
+static dvfs_dptc_params_s dvfs_dptc_params;
+
+/*!
+ * Holds the automatically selected DPTC driver major number.
+ */
+static int major;
+
+void mxc_dvfs_dptc_class_dev_release(struct device *dev);
+
+static struct class mxc_dvfs_dptc_class = {
+	.owner		=	THIS_MODULE,
+	.name		=	DEVICE_NAME,
+	.dev_release	= mxc_dvfs_dptc_class_dev_release,
+};
+
+/*
+ * This mutex makes the Read,Write and IOCTL command mutual exclusive.
+ */
+DECLARE_MUTEX(access_mutex);
+
+/*!
+ * This structure contains pointers for device driver entry point.
+ * The driver register function in init module will call this
+ * structure.
+ */
+static struct file_operations fops = {
+	.open = dvfs_dptc_open,
+	.release = dvfs_dptc_release,
+	.ioctl = dvfs_dptc_ioctl,
+#ifdef CONFIG_MXC_DVFS_SDMA
+	.read = dvfs_dptc_read,
+#endif
+};
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * Update pointers to physical addresses of DVFS & DPTC table
+ * for SDMA usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+static void dvfs_dptc_virt_2_phys(dvfs_dptc_tables_s *dvfs_dptc_table)
+{
+	int i;
+
+	/* Update DCVR pointers */
+	for (i = 0; i < dvfs_dptc_table->dvfs_state_num; i++) {
+		dvfs_dptc_table->dcvr[i] = (dcvr_state *)
+		    sdma_virt_to_phys(dvfs_dptc_table->dcvr[i]);
+	}
+	dvfs_dptc_table->dcvr = (dcvr_state **)
+	    sdma_virt_to_phys(dvfs_dptc_table->dcvr);
+	dvfs_dptc_table->table = (dvfs_state *)
+	    sdma_virt_to_phys(dvfs_dptc_table->table);
+}
+
+/*
+ * Update pointers to virtual addresses of DVFS & DPTC table
+ * for ARM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+static void dvfs_dptc_phys_2_virt(dvfs_dptc_tables_s *dvfs_dptc_table)
+{
+	int i;
+
+	dvfs_dptc_table->table = sdma_phys_to_virt
+	    ((unsigned long)dvfs_dptc_table->table);
+	dvfs_dptc_table->dcvr = sdma_phys_to_virt
+	    ((unsigned long)dvfs_dptc_table->dcvr);
+
+	/* Update DCVR pointers */
+	for (i = 0; i < dvfs_dptc_table->dvfs_state_num; i++) {
+		dvfs_dptc_table->dcvr[i] =
+		    sdma_phys_to_virt((unsigned long)dvfs_dptc_table->dcvr[i]);
+	}
+}
+#endif
+
+/*!
+ * This function frees power management table structures
+ */
+static void free_dvfs_dptc_table(void)
+{
+	int i;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	dvfs_dptc_phys_2_virt(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+#endif
+
+	for (i = 0;
+	     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num; i++) {
+		sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr[i]);
+	}
+
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr);
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->table);
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr->wp);
+
+	sdma_free(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+
+	dvfs_dptc_params.dvfs_dptc_tables_ptr = 0;
+}
+
+/*
+ * DVFS & DPTC table parsing function
+ * reads the next line of the table in text format
+ *
+ * @param   str    pointer to the previous line
+ *
+ * @return  pointer to the next line
+ */
+static char *pm_table_get_next_line(char *str)
+{
+	char *line_ptr;
+	int flag = 0;
+
+	if (strlen(str) == 0)
+		return str;
+
+	line_ptr = strchr(str, '\n') + 1;
+
+	while (!flag) {
+		if (strlen(line_ptr) == 0)
+			flag = 1;
+		else if (line_ptr[0] == '\n')
+			line_ptr++;
+		else if (line_ptr[0] == '#')
+			line_ptr = pm_table_get_next_line(line_ptr);
+		else
+			flag = 1;
+	}
+
+	return line_ptr;
+}
+
+/*
+ * DVFS & DPTC table parsing function
+ * sets the values of DVFS & DPTC tables from
+ * table in text format
+ *
+ * @param   pm_table  pointer to the table in binary format
+ * @param   pm_str    pointer to the table in text format
+ *
+ * @return  0 on success, error code on failure
+ */
+static int dvfs_dptc_parse_table(dvfs_dptc_tables_s *pm_table, char *pm_str)
+{
+	char *pm_str_ptr;
+	int i, j, n;
+	dptc_wp *wp;
+	dvfs_state *table;
+
+	pm_str_ptr = pm_str;
+
+	n = sscanf(pm_str_ptr, "WORKING POINT %d\n", &pm_table->wp_num);
+
+	if (n != 1) {
+		printk(KERN_WARNING "Failed read WORKING POINT number\n");
+		return -1;
+	}
+
+	pm_table->curr_wp = 0;
+
+	pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+
+	if (cpu_is_mx31()) {
+		pm_table->dvfs_state_num = 4;
+		pm_table->use_four_freq = 1;
+	} else {
+		pm_table->dvfs_state_num = 1;
+	}
+
+	pm_table->wp =
+	    (dptc_wp *) sdma_malloc(sizeof(dptc_wp) * pm_table->wp_num);
+	if (!pm_table->wp) {
+		printk(KERN_ERR "Failed allocating memory\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pm_table->wp_num; i++) {
+
+		wp = &pm_table->wp[i];
+
+		wp->wp_index = i;
+
+		if (cpu_is_mx31()) {
+			n = sscanf(pm_str_ptr, "WP 0x%x 0x%x 0x%x 0x%x\n",
+				   (unsigned int *)&wp->pmic_values[0],
+				   (unsigned int *)&wp->pmic_values[1],
+				   (unsigned int *)&wp->pmic_values[2],
+				   (unsigned int *)&wp->pmic_values[3]);
+
+			if (n != 4) {
+				printk(KERN_WARNING "Failed read WP %d\n", i);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+		} else {
+			n = sscanf(pm_str_ptr, "WP 0x%x\n",
+				   (unsigned int *)&wp->pmic_values[0]);
+
+			if (n != 1) {
+				printk(KERN_WARNING "Failed read WP %d\n", i);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+		}
+
+		pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+
+	}
+
+	pm_table->table =
+	    (dvfs_state *) sdma_malloc(sizeof(dvfs_state) *
+				       pm_table->dvfs_state_num);
+
+	if (!pm_table->table) {
+		printk(KERN_WARNING "Failed allocating memory\n");
+		sdma_free(pm_table->wp);
+		return -ENOMEM;
+	}
+
+	if (cpu_is_mx31()) {
+		for (i = 0; i < pm_table->dvfs_state_num; i++) {
+			table = &pm_table->table[i];
+
+			n = sscanf(pm_str_ptr,
+				   "FREQ %d %d 0x%x 0x%x 0x%x 0x%x %d\n",
+				   (unsigned int *)&table->pll_sw_up,
+				   (unsigned int *)&table->pll_sw_down,
+				   (unsigned int *)&table->pdr0_up,
+				   (unsigned int *)&table->pdr0_down,
+				   (unsigned int *)&table->pll_up,
+				   (unsigned int *)&table->pll_down,
+				   (unsigned int *)&table->vscnt);
+
+			if (n != 7) {
+				printk(KERN_WARNING "Failed read FREQ %d\n", i);
+				sdma_free(pm_table->table);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+
+			pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+		}
+	}
+
+	pm_table->dcvr =
+	    (dcvr_state **) sdma_malloc(sizeof(dcvr_state *) *
+					pm_table->dvfs_state_num);
+
+	if (!pm_table->dcvr) {
+		printk(KERN_WARNING "Failed allocating memory\n");
+		sdma_free(pm_table->table);
+		sdma_free(pm_table->wp);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pm_table->dvfs_state_num; i++) {
+		pm_table->dcvr[i] =
+		    (dcvr_state *) sdma_malloc(sizeof(dcvr_state) *
+					       pm_table->wp_num);
+
+		if (!pm_table->dcvr[i]) {
+			printk(KERN_WARNING "Failed allocating memory\n");
+
+			for (j = i - 1; j >= 0; j--)
+				sdma_free(pm_table->dcvr[j]);
+
+			sdma_free(pm_table->dcvr);
+			return -ENOMEM;
+		}
+
+		for (j = 0; j < pm_table->wp_num; j++) {
+
+			n = sscanf(pm_str_ptr, "DCVR 0x%x 0x%x 0x%x 0x%x\n",
+				   &pm_table->dcvr[i][j].dcvr_reg[0].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[1].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[2].AsInt,
+				   &pm_table->dcvr[i][j].dcvr_reg[3].AsInt);
+
+			if (n != 4) {
+				printk(KERN_WARNING "Failed read FREQ %d\n", i);
+
+				for (j = i; j >= 0; j--)
+					sdma_free(pm_table->dcvr[j]);
+
+				sdma_free(pm_table->dcvr);
+				sdma_free(pm_table->table);
+				sdma_free(pm_table->wp);
+				return -1;
+			}
+
+			pm_str_ptr = pm_table_get_next_line(pm_str_ptr);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Initializes the default values of DVFS & DPTC table
+ *
+ * @return  0 on success, error code on failure
+ */
+static int __init dvfs_dptc_init_default_table(void)
+{
+	int res = 0;
+	char *table_str;
+
+	dvfs_dptc_tables_s *default_table;
+
+	default_table = sdma_malloc(sizeof(dvfs_dptc_tables_s));
+
+	if (!default_table)
+		return -ENOMEM;
+#ifdef CONFIG_ARCH_MX3
+	if (mxc_get_clocks(CKIH_CLK) == 27000000) {
+		printk(KERN_INFO "DVFS & DPTC: using 27MHz CKIH table\n");
+		table_str = default_table_str_27ckih;
+	} else {
+#endif
+		table_str = default_table_str;
+#ifdef CONFIG_ARCH_MX3
+	}
+#endif
+
+	memset(default_table, 0, sizeof(dvfs_dptc_tables_s));
+	res = dvfs_dptc_parse_table(default_table, table_str);
+
+	if (res == 0)
+		dvfs_dptc_params.dvfs_dptc_tables_ptr = default_table;
+
+	return res;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is called for SDMA channel initialization.
+ *
+ * @param    params    pointer to the DPTC driver parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ */
+static int init_sdma_channel(dvfs_dptc_params_s *params)
+{
+	dma_channel_params sdma_params;
+	dma_request_t sdma_request;
+	int i;
+	int res = 0;
+
+	params->sdma_channel = 0;
+	res = mxc_request_dma(&params->sdma_channel, "DVFS_DPTC");
+	if (res < 0) {
+		printk(KERN_ERR "Failed allocate SDMA channel for DVFS_DPTC\n");
+		return res;
+	}
+
+	memset(&sdma_params, 0, sizeof(dma_channel_params));
+	sdma_params.peripheral_type = CCM;
+	sdma_params.transfer_type = per_2_emi;
+	sdma_params.event_id = DMA_REQ_CCM;
+	sdma_params.callback = (dma_callback_t) dvfs_dptc_sdma_callback;
+	sdma_params.arg = params;
+	sdma_params.per_address = CCM_BASE_ADDR;
+	sdma_params.watermark_level =
+	    sdma_virt_to_phys(params->dvfs_dptc_tables_ptr);
+	sdma_params.bd_number = 2;
+
+	res = mxc_dma_setup_channel(params->sdma_channel, &sdma_params);
+
+	if (res == 0) {
+		memset(&sdma_request, 0, sizeof(dma_request_t));
+
+		for (i = 0; i < DVFS_LB_SDMA_BD; i++) {
+			sdma_request.destAddr = (__u8 *)
+			    (params->dvfs_log_buffer_phys +
+			     i * (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) /
+			     DVFS_LB_SDMA_BD);
+			sdma_request.count = DVFS_LB_SIZE / DVFS_LB_SDMA_BD;
+			sdma_request.bd_cont = 1;
+
+			mxc_dma_set_config(params->sdma_channel, &sdma_request,
+					   i);
+		}
+
+		mxc_dma_start(params->sdma_channel);
+	}
+
+	return res;
+}
+#endif
+
+
+void mxc_dvfs_dptc_class_dev_release(struct device *dev)
+{
+	put_device(dev);
+}
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures, sets up the DPTC hardware,
+ * registers the DPTC driver, creates a proc file system read entry and
+ * attaches the driver to the DPTC interrupt.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+static int __init dvfs_dptc_init(void)
+{
+	int res = 0;
+	struct device *temp_dev;
+
+	res = dvfs_dptc_init_default_table();
+
+	if (res < 0) {
+		printk(KERN_WARNING "Failed parsing default DPTC table\n");
+		return res;
+	}
+#ifdef CONFIG_MXC_DPTC
+	/* Initialize DPTC hardware */
+	res = init_dptc_controller(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+	/* Initialize DVFS hardware */
+	res = init_dvfs_controller(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+
+	/* Enable 4 mc13783 output voltages */
+	pmic_write_reg(REG_ARBITRATION_SWITCHERS, 1, (1 << 5));
+
+	/* Enable mc13783 voltage ready signal */
+	pmic_write_reg(REG_INTERRUPT_MASK_1, 0, (1 << 11));
+
+	/* Set mc13783 DVS speed 25mV each 4us */
+	pmic_write_reg(REG_SWITCHERS_4, 1, (1 << 6));
+	pmic_write_reg(REG_SWITCHERS_4, 0, (1 << 7));
+
+	dvfs_update_freqs_table(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+#endif
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/* Update addresses to physical */
+	if (res == 0)
+		dvfs_dptc_virt_2_phys(dvfs_dptc_params.dvfs_dptc_tables_ptr);
+
+	res = init_sdma_channel(&dvfs_dptc_params);
+	if (res < 0) {
+		free_dvfs_dptc_table();
+		return res;
+	}
+#endif
+
+	/* Initialize internal driver structures */
+	dvfs_dptc_params.dptc_is_active = FALSE;
+
+#ifdef CONFIG_MXC_DVFS
+	dvfs_dptc_params.dvfs_is_active = FALSE;
+#endif
+
+	/*
+	 * Register DPTC driver as a char driver with an automatically allocated
+	 * major number.
+	 */
+	major = register_chrdev(0, DEVICE_NAME, &fops);
+
+	/*
+	 * Return error if a negative major number is returned.
+	 */
+	if (major < 0) {
+		printk(KERN_ERR
+		       "DPTC: Registering driver failed with %d\n", major);
+		free_dvfs_dptc_table();
+		return major;
+	}
+
+	res = class_register(&mxc_dvfs_dptc_class);
+	if (res) {
+		printk(KERN_ERR "DPTC: Error creating class.\n");
+		goto err_out1;
+	}
+
+	temp_dev = device_create_drvdata(&mxc_dvfs_dptc_class,
+			NULL, MKDEV(major, 0), NULL, DEVICE_NAME);
+	 if (IS_ERR(temp_dev)) {
+			printk(KERN_ERR "DPTC: Error creating class device.\n");
+			res = PTR_ERR(temp_dev);
+			goto err_out2;
+	 }
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/* request the DPTC interrupt */
+	res = request_irq(MXC_INT_CCM, dvfs_dptc_irq, 0, DEVICE_NAME, NULL);
+	/*
+	 * If res is not 0, then where was an error
+	 * during attaching to DPTC interrupt.
+	 * Exit and return error code.
+	 */
+	if (res) {
+		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt");
+		goto err_out3;
+	}
+	/* request the DVFS interrupt */
+	res = request_irq(MXC_INT_RESV31, dvfs_dptc_irq, 0, DEVICE_NAME, NULL);
+	if (res) {
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt");
+		goto err_out4;
+	}
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+	/* Register low power modes functions */
+	res = platform_driver_register(&mxc_dptc_driver);
+	if (res == 0) {
+		res = platform_device_register(&mxc_dptc_device);
+		if (res != 0)
+			goto err_out5;
+	}
+#endif
+	dvfs_dptc_params.suspended = FALSE;
+
+	return res;
+
+err_out5:
+	free_irq(MXC_INT_RESV31, NULL);
+#ifndef CONFIG_MXC_DVFS_SDMA
+err_out4:
+#endif
+	free_irq(MXC_INT_CCM, NULL);
+#ifndef CONFIG_MXC_DVFS_SDMA
+err_out3:
+#endif
+	device_unregister(temp_dev);
+err_out2:
+	class_unregister(&mxc_dvfs_dptc_class);
+err_out1:
+	unregister_chrdev(major, DEVICE_NAME);
+	free_dvfs_dptc_table();
+	printk(KERN_ERR "DVFS&DPTC driver was not initialized\n");
+	return res;
+}
+
+/*!
+ * This function is called whenever the module is removed from the kernel. It
+ * unregisters the DVFS & DPTC driver from kernel, frees the irq number
+ * and removes the proc file system entry.
+ */
+static void __exit dvfs_dptc_cleanup(void)
+{
+#ifdef CONFIG_MXC_DPTC
+	/* Unregister low power modes functions */
+	platform_driver_unregister(&mxc_dptc_driver);
+	platform_device_unregister(&mxc_dptc_device);
+#endif
+
+	free_dvfs_dptc_table();
+
+	/* release the DPTC interrupt */
+	free_irq(MXC_INT_CCM, NULL);
+	/* release the DVFS interrupt */
+	free_irq(MXC_INT_RESV31, NULL);
+
+	/* remove the DPTC proc file system entry */
+	remove_proc_entry(PROC_NODE_NAME, NULL);
+}
+
+/*!
+ * This function is called when the driver is opened. This function
+ * checks if the user that open the device has root privileges.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ */
+static int dvfs_dptc_open(struct inode *inode, struct file *filp)
+{
+	/*
+	 * check if the program that opened the driver has root
+	 * privileges, if not return error.
+	 */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (dvfs_dptc_params.suspended)
+		return -EPERM;
+
+	return 0;
+}
+
+/*!
+ * This function is called when the driver is close.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ *
+ */
+static int dvfs_dptc_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/*!
+ * This function dumps dptc translation table into string pointer
+ *
+ * @param    str    string pointer
+ */
+static void dvfs_dptc_dump_table(char *str)
+{
+	int i, j;
+	dcvr_state **dcvr_arr;
+	dcvr_state *dcvr_row;
+	dvfs_state *table;
+
+	memset(str, 0, MAX_TABLE_SIZE);
+
+	sprintf(str, "WORKING POINT %d\n",
+		dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num);
+	str += strlen(str);
+
+	for (i = 0; i < dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num; i++) {
+		if (cpu_is_mx31()) {
+			sprintf(str, "WP 0x%x 0x%x 0x%x 0x%x\n", (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[0], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[1], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[2], (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[3]);
+		} else {
+			sprintf(str, "WP 0x%x\n", (unsigned int)
+				dvfs_dptc_params.dvfs_dptc_tables_ptr->wp[i].
+				pmic_values[0]);
+		}
+
+		str += strlen(str);
+	}
+
+	if (cpu_is_mx31()) {
+		for (i = 0;
+		     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num;
+		     i++) {
+			table = dvfs_dptc_params.dvfs_dptc_tables_ptr->table;
+#ifdef CONFIG_MXC_DVFS_SDMA
+			table = sdma_phys_to_virt((unsigned long)table);
+#endif
+			sprintf(str,
+				"FREQ %d %d 0x%x 0x%x 0x%x 0x%x %d\n",
+				(unsigned int)table[i].pll_sw_up,
+				(unsigned int)table[i].pll_sw_down,
+				(unsigned int)table[i].pdr0_up,
+				(unsigned int)table[i].pdr0_down,
+				(unsigned int)table[i].pll_up,
+				(unsigned int)table[i].pll_down,
+				(unsigned int)table[i].vscnt);
+
+			str += strlen(str);
+		}
+	}
+
+	for (i = 0;
+	     i < dvfs_dptc_params.dvfs_dptc_tables_ptr->dvfs_state_num; i++) {
+		dcvr_arr = dvfs_dptc_params.dvfs_dptc_tables_ptr->dcvr;
+#ifdef CONFIG_MXC_DVFS_SDMA
+		dcvr_arr = sdma_phys_to_virt((unsigned long)dcvr_arr);
+#endif
+		dcvr_row = dcvr_arr[i];
+#ifdef CONFIG_MXC_DVFS_SDMA
+		dcvr_row = sdma_phys_to_virt((unsigned long)dcvr_row);
+#endif
+
+		for (j = 0;
+		     j < dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num; j++) {
+			sprintf(str,
+				"DCVR 0x%x 0x%x 0x%x 0x%x\n",
+				dcvr_row[j].dcvr_reg[0].AsInt,
+				dcvr_row[j].dcvr_reg[1].AsInt,
+				dcvr_row[j].dcvr_reg[2].AsInt,
+				dcvr_row[j].dcvr_reg[3].AsInt);
+
+			str += strlen(str);
+		}
+	}
+}
+
+/*!
+ * This function reads DVFS & DPTC translation table from user
+ *
+ * @param    user_table    pointer to user table
+ * @return   0 on success, error code on failure
+ */
+int dvfs_dptc_set_table(char *user_table)
+{
+	int ret_val = -ENOIOCTLCMD;
+	char *tmp_str;
+	char *tmp_str_ptr;
+	dvfs_dptc_tables_s *dptc_table;
+
+	if (cpu_is_mx31() &&
+	    (dvfs_dptc_params.dptc_is_active == TRUE ||
+	     dvfs_dptc_params.dvfs_is_active == TRUE)) {
+		ret_val = -EINVAL;
+		return ret_val;
+	} else if (dvfs_dptc_params.dptc_is_active == TRUE) {
+		ret_val = -EINVAL;
+		return ret_val;
+	}
+
+	tmp_str = vmalloc(MAX_TABLE_SIZE);
+
+	if (tmp_str < 0) {
+		ret_val = (int)tmp_str;
+	} else {
+		memset(tmp_str, 0, MAX_TABLE_SIZE);
+		tmp_str_ptr = tmp_str;
+
+		/*
+		 * read num_of_wp and dvfs_state_num
+		 * parameters from new table
+		 */
+		while (tmp_str_ptr - tmp_str < MAX_TABLE_SIZE &&
+		       (!copy_from_user(tmp_str_ptr, user_table, 1)) &&
+		       tmp_str_ptr[0] != 0) {
+			tmp_str_ptr++;
+			user_table++;
+		}
+		if (tmp_str_ptr == tmp_str) {
+			/* error reading from table */
+			printk(KERN_ERR "Failed reading table from user,"
+					"didn't copy a character\n");
+			ret_val = -EFAULT;
+		} else if (tmp_str_ptr - tmp_str == MAX_TABLE_SIZE) {
+			/* error reading from table */
+			printk(KERN_ERR "Failed reading table from user,"
+					"read more than %d\n", MAX_TABLE_SIZE);
+			ret_val = -EFAULT;
+		} else {
+			/*
+			 * copy table from user and set it as
+			 * the current DPTC table
+			 */
+			dptc_table = sdma_malloc(sizeof(dvfs_dptc_tables_s));
+
+			if (!dptc_table) {
+				ret_val = -ENOMEM;
+			} else {
+				ret_val =
+				    dvfs_dptc_parse_table(dptc_table, tmp_str);
+
+				if (ret_val == 0) {
+					free_dvfs_dptc_table();
+					dvfs_dptc_params.dvfs_dptc_tables_ptr =
+					    dptc_table;
+
+#ifdef CONFIG_MXC_DVFS
+					dvfs_update_freqs_table
+					    (dvfs_dptc_params.
+					     dvfs_dptc_tables_ptr);
+#endif
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+					/* Update addresses to physical */
+					dvfs_dptc_virt_2_phys(dvfs_dptc_params.
+							dvfs_dptc_tables_ptr);
+					mxc_free_dma(dvfs_dptc_params.
+						     sdma_channel);
+					init_sdma_channel(&dvfs_dptc_params);
+#endif
+#ifdef CONFIG_MXC_DPTC
+					set_dptc_curr_freq(&dvfs_dptc_params,
+							   0);
+					set_dptc_wp(&dvfs_dptc_params, 0);
+#endif
+				}
+			}
+
+		}
+
+		vfree(tmp_str);
+	}
+
+	return ret_val;
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+static ssize_t dvfs_dptc_read(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	size_t count0, count1;
+
+	while (dvfs_dptc_params.chars_in_buffer < count) {
+		waitqueue_active(&dvfs_dptc_params.dvfs_pred_wait);
+		wake_up(&dvfs_dptc_params.dvfs_pred_wait);
+		schedule();
+	}
+
+	if (dvfs_dptc_params.read_ptr + count <
+	    dvfs_dptc_params.dvfs_log_buffer +
+	    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) {
+		count0 = count;
+		count1 = 0;
+	} else {
+		count0 =
+		    dvfs_dptc_params.dvfs_log_buffer +
+		    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8 -
+		    dvfs_dptc_params.read_ptr;
+		count1 = count - count0;
+	}
+
+	copy_to_user(buf, dvfs_dptc_params.read_ptr, count0);
+	copy_to_user(buf + count0, dvfs_dptc_params.dvfs_log_buffer, count1);
+
+	if (count1 == 0)
+		dvfs_dptc_params.read_ptr += count;
+	else
+		dvfs_dptc_params.read_ptr =
+		    dvfs_dptc_params.dvfs_log_buffer + count1;
+
+	if (dvfs_dptc_params.read_ptr ==
+	    dvfs_dptc_params.dvfs_log_buffer +
+	    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) {
+		dvfs_dptc_params.read_ptr = dvfs_dptc_params.dvfs_log_buffer;
+	}
+
+	dvfs_dptc_params.chars_in_buffer -= count;
+
+	return count;
+}
+#endif
+
+/*!
+ * This function is called when a ioctl call is made from user space.
+ *
+ * @param    inode    Pointer to device inode
+ * @param    filp     Pointer to device file structure
+ * @param    cmd      Ioctl command
+ * @param    arg      Ioctl argument
+ *
+ *                    Following are the ioctl commands for user to use:\n
+ *                    DPTC_IOCTENABLE : Enables the DPTC module.\n
+ *                    DPTC_IOCTDISABLE : Disables the DPTC module.\n
+ *                    DPTC_IOCSENABLERC : Enables DPTC reference circuits.\n
+ *                    DPTC_IOCSDISABLERC : Disables DPTC reference circuits.\n
+ *                    DPTC_IOCGETSTATE :
+ *                    Returns 1 if the DPTC module is enabled,
+ *                    returns 0 if the DPTC module is disabled.\n
+ *                    DPTC_IOCSWP : Sets working point.\n
+ *                    PM_IOCSTABLE : Sets translation table.\n
+ *                    PM_IOCGTABLE : Gets translation table.\n
+ *                    DVFS_IOCTENABLE : Enables DVFS
+ *                    DVFS_IOCTDISABLE : Disables DVFS
+ *                    DVFS_IOCGSTATE : Returns 1 if the DVFS module is enabled,
+ *                    returns 0 if the DVFS module is disabled.\n
+ *                    DVFS_IOCSSWGP : Sets the value of DVFS SW general
+ *                    purpose bits.\n
+ *                    DVFS_IOCSWFI : Sets the status of WFI monitoring.\n
+ *                    PM_IOCGFREQ : Returns current CPU frequency in Hz
+ *                    DVFS_IOCSFREQ : Sets DVFS frequency when DVFS\n
+ *                    HW is disabled.\n
+ *
+ * @return    The function returns 0 on success and a non-zero value on
+ *            failure.
+ */
+static int dvfs_dptc_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg)
+{
+	unsigned int tmp;
+	int ret_val = -ENOIOCTLCMD;
+	char *tmp_str;
+
+	tmp = arg;
+
+	if (dvfs_dptc_params.suspended)
+		return -EPERM;
+
+	down(&access_mutex);
+
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "DVFS_DPTC ioctl (%d)\n", cmd);
+#endif
+
+	switch (cmd) {
+#ifdef CONFIG_MXC_DPTC
+		/* Enable the DPTC module */
+	case DPTC_IOCTENABLE:
+		ret_val = start_dptc(&dvfs_dptc_params);
+		break;
+
+		/* Disable the DPTC module */
+	case DPTC_IOCTDISABLE:
+		ret_val = stop_dptc(&dvfs_dptc_params);
+		break;
+
+	case DPTC_IOCSENABLERC:
+		ret_val = enable_ref_circuits(&dvfs_dptc_params, tmp);
+		break;
+
+	case DPTC_IOCSDISABLERC:
+		ret_val = disable_ref_circuits(&dvfs_dptc_params, tmp);
+		break;
+		/*
+		 * Return the DPTC module current state.
+		 * Returns 1 if the DPTC module is enabled, else returns 0
+		 */
+	case DPTC_IOCGSTATE:
+		ret_val = dvfs_dptc_params.dptc_is_active;
+		break;
+	case DPTC_IOCSWP:
+		if (dvfs_dptc_params.dptc_is_active == FALSE) {
+			if (arg >= 0 &&
+			    arg <
+			    dvfs_dptc_params.dvfs_dptc_tables_ptr->wp_num) {
+				set_dptc_wp(&dvfs_dptc_params, arg);
+				ret_val = 0;
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+		break;
+
+#endif				/* CONFIG_MXC_DPTC */
+
+		/* Update DPTC table */
+	case PM_IOCSTABLE:
+		ret_val = dvfs_dptc_set_table((char *)arg);
+		break;
+
+	case PM_IOCGTABLE:
+		tmp_str = vmalloc(MAX_TABLE_SIZE);
+		if (tmp_str < 0)
+			ret_val = (int)tmp_str;
+		else {
+			dvfs_dptc_dump_table(tmp_str);
+			if (copy_to_user((char *)tmp,
+						tmp_str, strlen(tmp_str))) {
+				printk(KERN_ERR
+				       "Failed copy %d characters to 0x%x\n",
+				       strlen(tmp_str), tmp);
+				ret_val = -EFAULT;
+			} else
+				ret_val = 0;
+			vfree(tmp_str);
+		}
+		break;
+
+#ifdef CONFIG_MXC_DVFS
+		/* Enable the DVFS module */
+	case DVFS_IOCTENABLE:
+		ret_val = start_dvfs(&dvfs_dptc_params);
+		break;
+
+		/* Disable the DVFS module */
+	case DVFS_IOCTDISABLE:
+		ret_val = stop_dvfs(&dvfs_dptc_params);
+		break;
+		/*
+		 * Return the DVFS module current state.
+		 * Returns 1 if the DPTC module is enabled, else returns 0
+		 */
+	case DVFS_IOCGSTATE:
+		ret_val = dvfs_dptc_params.dvfs_is_active;
+		break;
+	case DVFS_IOCSSWGP:
+		ret_val = set_sw_gp((unsigned char)arg);
+		break;
+	case DVFS_IOCSWFI:
+		ret_val = set_wfi((unsigned char)arg);
+		break;
+	case DVFS_IOCSFREQ:
+		if (dvfs_dptc_params.dvfs_is_active == FALSE ||
+		    dvfs_dptc_params.dvfs_mode == DVFS_PRED_MODE) {
+			if (arg >= 0 &&
+			    arg <
+			    dvfs_dptc_params.dvfs_dptc_tables_ptr->
+			    dvfs_state_num) {
+				ret_val = dvfs_set_state(arg);
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+		break;
+	case DVFS_IOCSMODE:
+#ifdef CONFIG_MXC_DVFS_SDMA
+		if (dvfs_dptc_params.dvfs_is_active == FALSE) {
+			if ((unsigned int)arg == DVFS_HW_MODE ||
+			    (unsigned int)arg == DVFS_PRED_MODE) {
+				dvfs_dptc_params.dvfs_mode = (unsigned int)arg;
+				ret_val = 0;
+			} else
+				ret_val = -EINVAL;
+		} else
+			ret_val = -EINVAL;
+#else
+		/* Predictive mode is supported only in SDMA mode */
+		ret_val = -EINVAL;
+#endif
+		break;
+#endif				/* CONFIG_MXC_DVFS */
+	case PM_IOCGFREQ:
+		ret_val = mxc_get_clocks(CPU_CLK);
+		break;
+
+		/* Unknown ioctl command -> return error */
+	default:
+		printk(KERN_ERR "Unknown ioctl command 0x%x\n", cmd);
+		ret_val = -ENOIOCTLCMD;
+	}
+
+	up(&access_mutex);
+
+	return ret_val;
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DPTC & DVFS Interrupt handler.
+ * This function wakes-up the dvfs_dptc_workqueue_handler
+ * function that handles the
+ * DPTC interrupt.
+ *
+ * @param   irq      The Interrupt number
+ * @param   dev_id   Driver private data
+ *
+ * @result    The function returns \b IRQ_RETVAL(1) if interrupt was handled,
+ *            returns \b IRQ_RETVAL(0) if the interrupt was not handled.
+ *            \b IRQ_RETVAL is defined in include/linux/interrupt.h.
+ */
+static irqreturn_t dvfs_dptc_irq(int irq, void *dev_id)
+{
+#ifdef EVB_DEBUG
+	printk(KERN_INFO "CCM interrupt (0x%x)!!!\n",
+	       (unsigned int)mxc_ccm_get_reg(MXC_CCM_PMCR0));
+#endif
+
+#ifdef CONFIG_MXC_DPTC
+	if (dvfs_dptc_params.dptc_is_active == TRUE)
+		dptc_irq();
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+	if (dvfs_dptc_params.dvfs_is_active == TRUE)
+		dvfs_irq(&dvfs_dptc_params);
+#endif
+
+	return IRQ_RETVAL(1);
+}
+#else
+/*!
+ * This function is the DPTC & DVFS SDMA callback.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ */
+static void dvfs_dptc_sdma_callback(dvfs_dptc_params_s *params)
+{
+	dma_request_t sdma_request_params;
+	int i;
+
+	for (i = 0; i < DVFS_LB_SDMA_BD; i++) {
+		mxc_dma_get_config(params->sdma_channel,
+				   &sdma_request_params, i);
+
+		if (sdma_request_params.bd_error == 1)
+			printk(KERN_WARNING
+			       "Error in DVFS-DPTC buffer descriptor\n");
+
+		if (sdma_request_params.bd_done == 0) {
+			params->chars_in_buffer +=
+			    (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8) /
+			    DVFS_LB_SDMA_BD;
+
+			if (params->chars_in_buffer >
+			    (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8)) {
+				params->chars_in_buffer =
+				    DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8;
+				params->read_ptr = params->dvfs_log_buffer;
+			}
+
+			sdma_request_params.destAddr =
+			    (__u8 *) (params->dvfs_log_buffer_phys +
+				      i * (DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE /
+					   8) / DVFS_LB_SDMA_BD);
+			sdma_request_params.count =
+			    DVFS_LB_SIZE / DVFS_LB_SDMA_BD;
+			sdma_request_params.bd_cont = 1;
+			mxc_dma_set_config(params->sdma_channel,
+					   &sdma_request_params, i);
+
+			if (params->dvfs_mode == DVFS_PRED_MODE)
+				wake_up_interruptible(&params->dvfs_pred_wait);
+		}
+	}
+
+#ifdef CONFIG_MXC_DPTC
+	if (params->prev_wp != params->dvfs_dptc_tables_ptr->curr_wp)
+		dptc_irq();
+#endif
+}
+#endif
+
+module_init(dvfs_dptc_init);
+module_exit(dvfs_dptc_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS & DPTC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pm/dvfs_dptc.h b/drivers/mxc/pm/dvfs_dptc.h
new file mode 100644
index 0000000..9c6d0b5
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_dptc.h
+ *
+ * @brief MXC dvfs & dptc header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_H__
+#define __DVFS_DPTC_H__
+
+#include <mach/pm_api.h>
+#include <mach/hardware.h>
+#include <mach/dvfs_dptc_struct.h>
+
+#ifdef CONFIG_ARCH_MX27
+#include <mach/dma.h>
+#else
+#include <mach/sdma.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX3
+#include "dvfs_dptc_table_mx31.h"
+#include "dvfs_dptc_table_mx31_27ckih.h"
+#endif
+
+#ifdef CONFIG_MXC_DVFS
+#ifndef CONFIG_MXC_DPTC
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dvfs"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dvfs"
+#endif				/* ifndef CONFIG_MXC_DPTC */
+#ifdef CONFIG_MXC_DPTC
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dvfs_dptc"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dvfs_dptc"
+#endif				/* ifdef CONFIG_MXC_DPTC */
+#else				/* ifdef CONFIG_MXC_DVFS */
+/*!
+ * DPTC Module Name
+ */
+#define DEVICE_NAME	"dptc"
+
+/*!
+ * DPTC driver node Name
+ */
+#define NODE_NAME	"dptc"
+#endif				/* ifdef CONFIG_MXC_DVFS */
+
+#define MAX_TABLE_SIZE 8192
+
+#endif				/* __DPTC_H__ */
diff --git a/drivers/mxc/pm/dvfs_dptc_table_mx31.h b/drivers/mxc/pm/dvfs_dptc_table_mx31.h
new file mode 100644
index 0000000..0d7c892
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc_table_mx31.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.h
+ *
+ * @brief MX31 dvfs & dptc table file for CKIH clock 26MHz.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_TABLE_MX31_H__
+#define __DVFS_DPTC_TABLE_MX31_H__
+
+#define NUM_OF_FREQS 4
+#define NUM_OF_WP    17
+
+/*!
+ * Default DPTC table definition.
+ * The table doesn't use PLL switch, because on DDR boards
+ * PLL switch is not possible due to HW issue.
+ * For SDR boards new table can be loaded.
+ *
+ * The table keeps the same voltage of 3.5V for frequencies lower than 399MHz.
+ * Theoretically we don't need DPTC for these frequencies,
+ * but we have to keep DPTC enabled for fluent DVFS switching
+ * back to high frequency.
+ */
+static char *default_table_str = "WORKING POINT 17\n\
+\n\
+# mc13783 switcher SW values for each working point\n\
+# The first line is for WP of highest voltage\n\
+# The first column is for highest frequency\n\
+#  SW1A      SW1A DVS   SW1B DVS   SW1B STANDBY\n\
+WP 0x1d      0x12        0x12        0x12\n\
+WP 0x1c      0x12        0x12        0x12\n\
+WP 0x1b      0x12        0x12        0x12\n\
+WP 0x1a      0x12        0x12        0x12\n\
+WP 0x19      0x12        0x12        0x12\n\
+WP 0x18      0x12        0x12        0x12\n\
+WP 0x17      0x12        0x12        0x12\n\
+WP 0x16      0x12        0x12        0x12\n\
+WP 0x15      0x12        0x12        0x12\n\
+WP 0x14      0x12        0x12        0x12\n\
+WP 0x13      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+WP 0x12      0x12        0x12        0x12\n\
+\n\
+#    pll_sw_up pll_sw_down pdr_up     pdr_down    pll_up     pll_down   vscnt\n\
+# 532MHz\n\
+FREQ 0 0 0xff871e58 0xff871e59 0x33280c 0x33280c 7\n\
+# 266MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0x33280c 0x33280c 7\n\
+# 532MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95e3e8e4 0xffc00000 0xe5b6fda0\n\
+DCVR 0xffc00000 0x95e3e8e4 0xffc00000 0xe5b6fda0\n\
+DCVR 0xffc00000 0x95e3e8e8 0xffc00000 0xe5f70da4\n\
+DCVR 0xffc00000 0x9623f8e8 0xffc00000 0xe6371da8\n\
+DCVR 0xffc00000 0x966408f0 0xffc00000 0xe6b73db0\n\
+DCVR 0xffc00000 0x96e428f4 0xffc00000 0xe7776dbc\n\
+DCVR 0xffc00000 0x976448fc 0xffc00000 0xe8379dc8\n\
+DCVR 0xffc00000 0x97e46904 0xffc00000 0xe977ddd8\n\
+DCVR 0xffc00000 0x98a48910 0xffc00000 0xeab81de8\n\
+DCVR 0xffc00000 0x9964b918 0xffc00000 0xebf86df8\n\
+DCVR 0xffc00000 0xffe4e924 0xffc00000 0xfff8ae08\n\
+DCVR 0xffc00000 0xffe5192c 0xffc00000 0xfff8fe1c\n\
+DCVR 0xffc00000 0xffe54938 0xffc00000 0xfff95e2c\n\
+DCVR 0xffc00000 0xffe57944 0xffc00000 0xfff9ae44\n\
+DCVR 0xffc00000 0xffe5b954 0xffc00000 0xfffa0e58\n\
+DCVR 0xffc00000 0xffe5e960 0xffc00000 0xfffa6e70\n\
+\n\
+# 266MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x95c00000 0xffc00000 0xe5800000\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe58dc368\n\
+DCVR 0xffc00000 0x95c8f238 0xffc00000 0xe5cdc368\n\
+DCVR 0xffc00000 0x9609023c 0xffc00000 0xe60dc36c\n\
+DCVR 0xffc00000 0x9649023c 0xffc00000 0xe68dd36c\n\
+DCVR 0xffc00000 0x96c9023c 0xffc00000 0xe74dd370\n\
+DCVR 0xffc00000 0x97491240 0xffc00000 0xe80de374\n\
+DCVR 0xffc00000 0x97c92240 0xffc00000 0xe94df374\n\
+DCVR 0xffc00000 0x98892244 0xffc00000 0xea8e0378\n\
+DCVR 0xffc00000 0x99493248 0xffc00000 0xebce137c\n\
+DCVR 0xffc00000 0xffc93248 0xffc00000 0xffce3384\n\
+DCVR 0xffc00000 0xffc9424c 0xffc00000 0xffce4388\n\
+DCVR 0xffc00000 0xffc95250 0xffc00000 0xffce538c\n\
+DCVR 0xffc00000 0xffc96250 0xffc00000 0xffce7390\n\
+DCVR 0xffc00000 0xffc97254 0xffc00000 0xffce8394\n\
+DCVR 0xffc00000 0xffc98258 0xffc00000 0xffcea39c\n\
+";
+
+#endif
diff --git a/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h b/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h
new file mode 100644
index 0000000..2254a8c
--- /dev/null
+++ b/drivers/mxc/pm/dvfs_dptc_table_mx31_27ckih.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.h
+ *
+ * @brief MX31 dvfs & dptc table file for CKIH clock 27MHz.
+ *
+ * @ingroup PM
+ */
+#ifndef __DVFS_DPTC_TABLE_MX31_27CKIH_H__
+#define __DVFS_DPTC_TABLE_MX31_27CKIH_H__
+
+#define NUM_OF_FREQS 4
+#define NUM_OF_WP    17
+
+/*!
+ * Default DPTC table definition.
+ * The table doesn't use PLL switch, because on DDR boards
+ * PLL switch is not possible due to HW issue.
+ * For SDR boards new table can be loaded.
+ *
+ * The table keeps the same voltage of 1.35V for frequencies lower than 399MHz.
+ * Theoretically we don't need DPTC for these frequencies,
+ * but we have to keep DPTC enabled for fluent DVFS switching
+ * back to high frequency.
+ */
+static char *default_table_str_27ckih = "WORKING POINT 17\n\
+WP 0x1d 0x12 0x12 0x12\n\
+WP 0x1c 0x12 0x12 0x12\n\
+WP 0x1b 0x12 0x12 0x12\n\
+WP 0x1a 0x12 0x12 0x12\n\
+WP 0x19 0x12 0x12 0x12\n\
+WP 0x18 0x12 0x12 0x12\n\
+WP 0x17 0x12 0x12 0x12\n\
+WP 0x16 0x12 0x12 0x12\n\
+WP 0x15 0x12 0x12 0x12\n\
+WP 0x14 0x12 0x12 0x12\n\
+WP 0x13 0x12 0x12 0x12\n\
+WP 0x12 0x12 0x12 0x12\n\
+WP 0x11 0x12 0x12 0x12\n\
+WP 0x10 0x12 0x12 0x12\n\
+WP 0xf 0x12 0x12 0x12\n\
+WP 0xe 0x12 0x12 0x12\n\
+WP 0xd 0x12 0x12 0x12\n\
+\n\
+#    pll_sw_up pll_sw_down pdr_up     pdr_down    pll_up     pll_down   vscnt\n\
+# 532MHz\n\
+FREQ 0 0 0xff871e58 0xff871e59 0xe240d 0xe240d 7\n\
+# 266MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 133MHz\n\
+FREQ 0 0 0xff871e58 0xff871e5b 0xe240d 0xe240d 7\n\
+# 532MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x90629890 0xffc00000 0xdd34ed20\n\
+DCVR 0xffc00000 0x90629890 0xffc00000 0xdd34ed20\n\
+DCVR 0xffc00000 0x90629894 0xffc00000 0xdd74fd24\n\
+DCVR 0xffc00000 0x90a2a894 0xffc00000 0xddb50d28\n\
+DCVR 0xffc00000 0x90e2b89c 0xffc00000 0xde352d30\n\
+DCVR 0xffc00000 0x9162d8a0 0xffc00000 0xdef55d38\n\
+DCVR 0xffc00000 0x91e2f8a8 0xffc00000 0xdfb58d44\n\
+DCVR 0xffc00000 0x926308b0 0xffc00000 0xe0b5cd54\n\
+DCVR 0xffc00000 0x92e328bc 0xffc00000 0xe1f60d64\n\
+DCVR 0xffc00000 0x93a358c0 0xffc00000 0xe3365d74\n\
+DCVR 0xffc00000 0xf66388cc 0xffc00000 0xf6768d84\n\
+DCVR 0xffc00000 0xf663b8d4 0xffc00000 0xf676dd98\n\
+DCVR 0xffc00000 0xf663e8e0 0xffc00000 0xf6773da4\n\
+DCVR 0xffc00000 0xf66418ec 0xffc00000 0xf6778dbc\n\
+DCVR 0xffc00000 0xf66458fc 0xffc00000 0xf677edd0\n\
+DCVR 0xffc00000 0xf6648908 0xffc00000 0xf6783de8\n\
+\n\
+# 266MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+\n\
+# 133MHz\n\
+DCVR 0xffc00000 0x90400000 0xffc00000 0xdd000000\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd0d4348\n\
+DCVR 0xffc00000 0x9048a224 0xffc00000 0xdd4d4348\n\
+DCVR 0xffc00000 0x9088b228 0xffc00000 0xdd8d434c\n\
+DCVR 0xffc00000 0x90c8b228 0xffc00000 0xde0d534c\n\
+DCVR 0xffc00000 0x9148b228 0xffc00000 0xdecd5350\n\
+DCVR 0xffc00000 0x91c8c22c 0xffc00000 0xdf8d6354\n\
+DCVR 0xffc00000 0x9248d22c 0xffc00000 0xe08d7354\n\
+DCVR 0xffc00000 0x92c8d230 0xffc00000 0xe1cd8358\n\
+DCVR 0xffc00000 0x9388e234 0xffc00000 0xe30d935c\n\
+DCVR 0xffc00000 0xf648e234 0xffc00000 0xf64db364\n\
+DCVR 0xffc00000 0xf648f238 0xffc00000 0xf64dc368\n\
+DCVR 0xffc00000 0xf648f23c 0xffc00000 0xf64dd36c\n\
+DCVR 0xffc00000 0xf649023c 0xffc00000 0xf64de370\n\
+DCVR 0xffc00000 0xf649123c 0xffc00000 0xf64df374\n\
+DCVR 0xffc00000 0xf6492240 0xffc00000 0xf64e1378\n\
+";
+
+#endif
-- 
1.6.0.3

