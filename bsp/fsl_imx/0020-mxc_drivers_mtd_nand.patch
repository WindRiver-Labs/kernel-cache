From f4472b6da2a964da0b0799132d7a37f04bab45b0 Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Fri, 28 Nov 2008 14:12:54 +0300
Subject: [PATCH] mxc_drivers_mtd_nand

MXC nand flash mtd driver.

commit 34f6e15786293e8d6ed05f9c19ed784ff15d2702 upstream

[MTD] [NAND] Freescale i.MX2 NAND driver

This patch adds support for the integrated NAND flash controller of the
i.MX2 and i.MX3 family. It is tested on MX27 but should work on MX3
aswell.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

On i.MX5 series, the nand flash controller is version 3. In V3
controller, the maxium page size it can support is 4Kbytes. It can
also support multi-chip and upto 8 bit ECC hardware engine. So Add
new driver for V3 nand flash controller.

Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Acked-by: Juergen Beisert <j.beisert@pengutronix.de>
Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/plat-mxc/include/mach/mxc_nand.h |   27 +
 drivers/mtd/nand/Kconfig                  |   51 +
 drivers/mtd/nand/Makefile                 |    3 +
 drivers/mtd/nand/mxc_nand.c               | 1077 +++++++++++++++++++++
 drivers/mtd/nand/mxc_nd2.c                | 1458 +++++++++++++++++++++++++++++
 drivers/mtd/nand/mxc_nd2.h                |  676 +++++++++++++
 6 files changed, 3292 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_nand.h
 create mode 100644 drivers/mtd/nand/mxc_nand.c
 create mode 100644 drivers/mtd/nand/mxc_nd2.c
 create mode 100644 drivers/mtd/nand/mxc_nd2.h

diff --git a/arch/arm/plat-mxc/include/mach/mxc_nand.h b/arch/arm/plat-mxc/include/mach/mxc_nand.h
new file mode 100644
index 0000000..2b972df
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_nand.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_NAND_H
+#define __ASM_ARCH_NAND_H
+
+struct mxc_nand_platform_data {
+	int width;	/* data bus width in bytes */
+	int hw_ecc;	/* 0 if supress hardware ECC */
+};
+#endif /* __ASM_ARCH_NAND_H */
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index ed1a331..73afa1e 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -425,4 +425,55 @@ config MTD_NAND_FSL_UPM
 	  Enables support for NAND Flash chips wired onto Freescale PowerPC
 	  processor localbus with User-Programmable Machine support.
 
+config MTD_NAND_MXC
+	tristate "MXC NAND support"
+	depends on ARCH_MX2
+	help
+	  This enables the driver for the NAND flash controller on the
+	  MXC processors.
+
+config MTD_NAND_MXC_V2
+	tristate "MXC NAND Version 2 support"
+	depends on MTD_NAND && ARCH_MXC_HAS_NFC_V2
+	help
+	  This enables the driver for the version 2 of NAND flash controller
+	  on the MXC processors.
+
+config MTD_NAND_MXC_V3
+	tristate "MXC NAND Version 3 support"
+	depends on MTD_NAND && ARCH_MXC_HAS_NFC_V3
+	help
+	  This enables the driver for the version 3 of NAND flash controller
+	  on the MXC processors.
+
+config MTD_NAND_MXC_SWECC
+	bool "Software ECC support "
+	depends on MTD_NAND_MXC || MTD_NAND_MXC_V2 || MTD_NAND_MXC_V3
+	help
+	  This enables the support for Software ECC handling. By
+	  default MXC NAND controller Hardware ECC is supported.
+
+
+config MTD_NAND_MXC_FORCE_CE
+	bool "NAND chip select operation support"
+	 depends on MTD_NAND_MXC || MTD_NAND_MXC_V2|| MTD_NAND_MXC_V3
+	help
+	  This enables the NAND chip select by using CE control line. By
+	  default CE operation is disabled.
+
+config MTD_NAND_MXC_ECC_CORRECTION_OPTION2
+	bool "ECC correction in S/W"
+	depends on MTD_NAND_MXC
+	help
+	  This enables the Option2 NFC ECC correction in software. By
+	  default Option 1 is selected. Enable if you need option2 ECC
+	  correction.
+
+config MXC_NAND_LOW_LEVEL_ERASE
+	bool "Low level NAND erase"
+	depends on MTD_NAND_MXC || MTD_NAND_MXC_V2 || MTD_NAND_MXC_V3
+	help
+	  This enables the erase of whole NAND flash. By
+	  default low level erase operation is disabled.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index ba42584..55c30b2 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -37,5 +37,8 @@ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
+obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
+obj-$(CONFIG_MTD_NAND_MXC_V2)		+= mxc_nd2.o
+obj-$(CONFIG_MTD_NAND_MXC_V3)		+= mxc_nd2.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c
new file mode 100644
index 0000000..21fd4f1
--- /dev/null
+++ b/drivers/mtd/nand/mxc_nand.c
@@ -0,0 +1,1077 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <asm/mach/flash.h>
+#include <mach/mxc_nand.h>
+
+#define DRIVER_NAME "mxc_nand"
+
+/* Addresses for NFC registers */
+#define NFC_BUF_SIZE		0xE00
+#define NFC_BUF_ADDR		0xE04
+#define NFC_FLASH_ADDR		0xE06
+#define NFC_FLASH_CMD		0xE08
+#define NFC_CONFIG		0xE0A
+#define NFC_ECC_STATUS_RESULT	0xE0C
+#define NFC_RSLTMAIN_AREA	0xE0E
+#define NFC_RSLTSPARE_AREA	0xE10
+#define NFC_WRPROT		0xE12
+#define NFC_UNLOCKSTART_BLKADDR	0xE14
+#define NFC_UNLOCKEND_BLKADDR	0xE16
+#define NFC_NF_WRPRST		0xE18
+#define NFC_CONFIG1		0xE1A
+#define NFC_CONFIG2		0xE1C
+
+/* Addresses for NFC RAM BUFFER Main area 0 */
+#define MAIN_AREA0		0x000
+#define MAIN_AREA1		0x200
+#define MAIN_AREA2		0x400
+#define MAIN_AREA3		0x600
+
+/* Addresses for NFC SPARE BUFFER Spare area 0 */
+#define SPARE_AREA0		0x800
+#define SPARE_AREA1		0x810
+#define SPARE_AREA2		0x820
+#define SPARE_AREA3		0x830
+
+/* Set INT to 0, FCMD to 1, rest to 0 in NFC_CONFIG2 Register
+ * for Command operation */
+#define NFC_CMD            0x1
+
+/* Set INT to 0, FADD to 1, rest to 0 in NFC_CONFIG2 Register
+ * for Address operation */
+#define NFC_ADDR           0x2
+
+/* Set INT to 0, FDI to 1, rest to 0 in NFC_CONFIG2 Register
+ * for Input operation */
+#define NFC_INPUT          0x4
+
+/* Set INT to 0, FDO to 001, rest to 0 in NFC_CONFIG2 Register
+ * for Data Output operation */
+#define NFC_OUTPUT         0x8
+
+/* Set INT to 0, FD0 to 010, rest to 0 in NFC_CONFIG2 Register
+ * for Read ID operation */
+#define NFC_ID             0x10
+
+/* Set INT to 0, FDO to 100, rest to 0 in NFC_CONFIG2 Register
+ * for Read Status operation */
+#define NFC_STATUS         0x20
+
+/* Set INT to 1, rest to 0 in NFC_CONFIG2 Register for Read
+ * Status operation */
+#define NFC_INT            0x8000
+
+#define NFC_SP_EN           (1 << 2)
+#define NFC_ECC_EN          (1 << 3)
+#define NFC_INT_MSK         (1 << 4)
+#define NFC_BIG             (1 << 5)
+#define NFC_RST             (1 << 6)
+#define NFC_CE              (1 << 7)
+#define NFC_ONE_CYCLE       (1 << 8)
+
+struct mxc_nand_host {
+	struct mtd_info		mtd;
+	struct nand_chip	nand;
+	struct mtd_partition	*parts;
+	struct device		*dev;
+
+	void __iomem		*regs;
+	int			spare_only;
+	int			status_request;
+	int			pagesize_2k;
+	uint16_t		col_addr;
+	struct clk		*clk;
+	int			clk_act;
+	int			irq;
+
+	wait_queue_head_t	irq_waitq;
+};
+
+/* Define delays in microsec for NAND device operations */
+#define TROP_US_DELAY   2000
+/* Macros to get byte and bit positions of ECC */
+#define COLPOS(x)  ((x) >> 3)
+#define BITPOS(x) ((x) & 0xf)
+
+/* Define single bit Error positions in Main & Spare area */
+#define MAIN_SINGLEBIT_ERROR 0x4
+#define SPARE_SINGLEBIT_ERROR 0x1
+
+/* OOB placement block for use with hardware ecc generation */
+static struct nand_ecclayout nand_hw_eccoob_8 = {
+	.eccbytes = 5,
+	.eccpos = {6, 7, 8, 9, 10},
+	.oobfree = {{0, 5}, {11, 5}, }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_16 = {
+	.eccbytes = 5,
+	.eccpos = {6, 7, 8, 9, 10},
+	.oobfree = {{0, 6}, {12, 4}, }
+};
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "RedBoot", "cmdlinepart", NULL };
+#endif
+
+static irqreturn_t mxc_nfc_irq(int irq, void *dev_id)
+{
+	struct mxc_nand_host *host = dev_id;
+
+	uint16_t tmp;
+
+	tmp = readw(host->regs + NFC_CONFIG1);
+	tmp |= NFC_INT_MSK; /* Disable interrupt */
+	writew(tmp, host->regs + NFC_CONFIG1);
+
+	wake_up(&host->irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+/* This function polls the NANDFC to wait for the basic operation to
+ * complete by checking the INT bit of config2 register.
+ */
+static void wait_op_done(struct mxc_nand_host *host, int max_retries,
+				uint16_t param, int useirq)
+{
+	uint32_t tmp;
+
+	if (useirq) {
+		if ((readw(host->regs + NFC_CONFIG2) & NFC_INT) == 0) {
+
+			tmp = readw(host->regs + NFC_CONFIG1);
+			tmp  &= ~NFC_INT_MSK;	/* Enable interrupt */
+			writew(tmp, host->regs + NFC_CONFIG1);
+
+			wait_event(host->irq_waitq,
+				readw(host->regs + NFC_CONFIG2) & NFC_INT);
+
+			tmp = readw(host->regs + NFC_CONFIG2);
+			tmp  &= ~NFC_INT;
+			writew(tmp, host->regs + NFC_CONFIG2);
+		}
+	} else {
+		while (max_retries-- > 0) {
+			if (readw(host->regs + NFC_CONFIG2) & NFC_INT) {
+				tmp = readw(host->regs + NFC_CONFIG2);
+				tmp  &= ~NFC_INT;
+				writew(tmp, host->regs + NFC_CONFIG2);
+				break;
+			}
+			udelay(1);
+		}
+		if (max_retries <= 0)
+			DEBUG(MTD_DEBUG_LEVEL0, "%s(%d): INT not set\n",
+			      __func__, param);
+	}
+}
+
+/* This function issues the specified command to the NAND device and
+ * waits for completion. */
+static void send_cmd(struct mxc_nand_host *host, uint16_t cmd, int useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_cmd(host, 0x%x, %d)\n", cmd, useirq);
+
+	writew(cmd, host->regs + NFC_FLASH_CMD);
+	writew(NFC_CMD, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, cmd, useirq);
+}
+
+/* This function sends an address (or partial address) to the
+ * NAND device. The address is used to select the source/destination for
+ * a NAND command. */
+static void send_addr(struct mxc_nand_host *host, uint16_t addr, int islast)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_addr(host, 0x%x %d)\n", addr, islast);
+
+	writew(addr, host->regs + NFC_FLASH_ADDR);
+	writew(NFC_ADDR, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, addr, islast);
+}
+
+/* This function requests the NANDFC to initate the transfer
+ * of data currently in the NANDFC RAM buffer to the NAND device. */
+static void send_prog_page(struct mxc_nand_host *host, uint8_t buf_id,
+			int spare_only)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_prog_page (%d)\n", spare_only);
+
+	/* NANDFC buffer 0 is used for page read/write */
+	writew(buf_id, host->regs + NFC_BUF_ADDR);
+
+	/* Configure spare or page+spare access */
+	if (!host->pagesize_2k) {
+		uint16_t config1 = readw(host->regs + NFC_CONFIG1);
+		if (spare_only)
+			config1 |= NFC_SP_EN;
+		else
+			config1 &= ~(NFC_SP_EN);
+		writew(config1, host->regs + NFC_CONFIG1);
+	}
+
+	writew(NFC_INPUT, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, spare_only, true);
+}
+
+/* Requests NANDFC to initated the transfer of data from the
+ * NAND device into in the NANDFC ram buffer. */
+static void send_read_page(struct mxc_nand_host *host, uint8_t buf_id,
+		int spare_only)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_read_page (%d)\n", spare_only);
+
+	/* NANDFC buffer 0 is used for page read/write */
+	writew(buf_id, host->regs + NFC_BUF_ADDR);
+
+	/* Configure spare or page+spare access */
+	if (!host->pagesize_2k) {
+		uint32_t config1 = readw(host->regs + NFC_CONFIG1);
+		if (spare_only)
+			config1 |= NFC_SP_EN;
+		else
+			config1 &= ~NFC_SP_EN;
+		writew(config1, host->regs + NFC_CONFIG1);
+	}
+
+	writew(NFC_OUTPUT, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, spare_only, true);
+}
+
+/* Request the NANDFC to perform a read of the NAND device ID. */
+static void send_read_id(struct mxc_nand_host *host)
+{
+	struct nand_chip *this = &host->nand;
+	uint16_t tmp;
+
+	/* NANDFC buffer 0 is used for device ID output */
+	writew(0x0, host->regs + NFC_BUF_ADDR);
+
+	/* Read ID into main buffer */
+	tmp = readw(host->regs + NFC_CONFIG1);
+	tmp &= ~NFC_SP_EN;
+	writew(tmp, host->regs + NFC_CONFIG1);
+
+	writew(NFC_ID, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, 0, true);
+
+	if (this->options & NAND_BUSWIDTH_16) {
+		void __iomem *main_buf = host->regs + MAIN_AREA0;
+		/* compress the ID info */
+		writeb(readb(main_buf + 2), main_buf + 1);
+		writeb(readb(main_buf + 4), main_buf + 2);
+		writeb(readb(main_buf + 6), main_buf + 3);
+		writeb(readb(main_buf + 8), main_buf + 4);
+		writeb(readb(main_buf + 10), main_buf + 5);
+	}
+}
+
+/* This function requests the NANDFC to perform a read of the
+ * NAND device status and returns the current status. */
+static uint16_t get_dev_status(struct mxc_nand_host *host)
+{
+	void __iomem *main_buf = host->regs + MAIN_AREA1;
+	uint32_t store;
+	uint16_t ret, tmp;
+	/* Issue status request to NAND device */
+
+	/* store the main area1 first word, later do recovery */
+	store = readl(main_buf);
+	/* NANDFC buffer 1 is used for device status to prevent
+	 * corruption of read/write buffer on status requests. */
+	writew(1, host->regs + NFC_BUF_ADDR);
+
+	/* Read status into main buffer */
+	tmp = readw(host->regs + NFC_CONFIG1);
+	tmp &= ~NFC_SP_EN;
+	writew(tmp, host->regs + NFC_CONFIG1);
+
+	writew(NFC_STATUS, host->regs + NFC_CONFIG2);
+
+	/* Wait for operation to complete */
+	wait_op_done(host, TROP_US_DELAY, 0, true);
+
+	/* Status is placed in first word of main buffer */
+	/* get status, then recovery area 1 data */
+	ret = readw(main_buf);
+	writel(store, main_buf);
+
+	return ret;
+}
+
+/* This functions is used by upper layer to checks if device is ready */
+static int mxc_nand_dev_ready(struct mtd_info *mtd)
+{
+	/*
+	 * NFC handles R/B internally. Therefore, this function
+	 * always returns status as ready.
+	 */
+	return 1;
+}
+
+static void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	/*
+	 * If HW ECC is enabled, we turn it on during init. There is
+	 * no need to enable again here.
+	 */
+}
+
+static int mxc_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+
+	/*
+	 * 1-Bit errors are automatically corrected in HW.  No need for
+	 * additional correction.  2-Bit errors cannot be corrected by
+	 * HW ECC, so we need to return failure
+	 */
+	uint16_t ecc_status = readw(host->regs + NFC_ECC_STATUS_RESULT);
+
+	if (((ecc_status & 0x3) == 2) || ((ecc_status >> 2) == 2)) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "MXC_NAND: HWECC uncorrectable 2-bit ECC error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				  u_char *ecc_code)
+{
+	return 0;
+}
+
+static u_char mxc_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	uint8_t ret = 0;
+	uint16_t col, rd_word;
+	uint16_t __iomem *main_buf = host->regs + MAIN_AREA0;
+	uint16_t __iomem *spare_buf = host->regs + SPARE_AREA0;
+
+	/* Check for status request */
+	if (host->status_request)
+		return get_dev_status(host) & 0xFF;
+
+	/* Get column for 16-bit access */
+	col = host->col_addr >> 1;
+
+	/* If we are accessing the spare region */
+	if (host->spare_only)
+		rd_word = readw(&spare_buf[col]);
+	else
+		rd_word = readw(&main_buf[col]);
+
+	/* Pick upper/lower byte of word from RAM buffer */
+	if (host->col_addr & 0x1)
+		ret = (rd_word >> 8) & 0xFF;
+	else
+		ret = rd_word & 0xFF;
+
+	/* Update saved column address */
+	host->col_addr++;
+
+	return ret;
+}
+
+static uint16_t mxc_nand_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	uint16_t col, rd_word, ret;
+	uint16_t __iomem *p;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_read_word(col = %d)\n", host->col_addr);
+
+	col = host->col_addr;
+	/* Adjust saved column address */
+	if (col < mtd->writesize && host->spare_only)
+		col += mtd->writesize;
+
+	if (col < mtd->writesize)
+		p = (host->regs + MAIN_AREA0) + (col >> 1);
+	else
+		p = (host->regs + SPARE_AREA0) + ((col - mtd->writesize) >> 1);
+
+	if (col & 1) {
+		rd_word = readw(p);
+		ret = (rd_word >> 8) & 0xff;
+		rd_word = readw(&p[1]);
+		ret |= (rd_word << 8) & 0xff00;
+
+	} else
+		ret = readw(p);
+
+	/* Update saved column address */
+	host->col_addr = col + 2;
+
+	return ret;
+}
+
+/* Write data of length len to buffer buf. The data to be
+ * written on NAND Flash is first copied to RAMbuffer. After the Data Input
+ * Operation by the NFC, the data is written to NAND Flash */
+static void mxc_nand_write_buf(struct mtd_info *mtd,
+				const u_char *buf, int len)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	int n, col, i = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_write_buf(col = %d, len = %d)\n", host->col_addr,
+	      len);
+
+	col = host->col_addr;
+
+	/* Adjust saved column address */
+	if (col < mtd->writesize && host->spare_only)
+		col += mtd->writesize;
+
+	n = mtd->writesize + mtd->oobsize - col;
+	n = min(len, n);
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "%s:%d: col = %d, n = %d\n", __func__, __LINE__, col, n);
+
+	while (n) {
+		void __iomem *p;
+
+		if (col < mtd->writesize)
+			p = host->regs + MAIN_AREA0 + (col & ~3);
+		else
+			p = host->regs + SPARE_AREA0 -
+						mtd->writesize + (col & ~3);
+
+		DEBUG(MTD_DEBUG_LEVEL3, "%s:%d: p = %p\n", __func__,
+		      __LINE__, p);
+
+		if (((col | (int)&buf[i]) & 3) || n < 16) {
+			uint32_t data = 0;
+
+			if (col & 3 || n < 4)
+				data = readl(p);
+
+			switch (col & 3) {
+			case 0:
+				if (n) {
+					data = (data & 0xffffff00) |
+					    (buf[i++] << 0);
+					n--;
+					col++;
+				}
+			case 1:
+				if (n) {
+					data = (data & 0xffff00ff) |
+					    (buf[i++] << 8);
+					n--;
+					col++;
+				}
+			case 2:
+				if (n) {
+					data = (data & 0xff00ffff) |
+					    (buf[i++] << 16);
+					n--;
+					col++;
+				}
+			case 3:
+				if (n) {
+					data = (data & 0x00ffffff) |
+					    (buf[i++] << 24);
+					n--;
+					col++;
+				}
+			}
+
+			writel(data, p);
+		} else {
+			int m = mtd->writesize - col;
+
+			if (col >= mtd->writesize)
+				m += mtd->oobsize;
+
+			m = min(n, m) & ~3;
+
+			DEBUG(MTD_DEBUG_LEVEL3,
+			      "%s:%d: n = %d, m = %d, i = %d, col = %d\n",
+			      __func__,  __LINE__, n, m, i, col);
+
+			memcpy(p, &buf[i], m);
+			col += m;
+			i += m;
+			n -= m;
+		}
+	}
+	/* Update saved column address */
+	host->col_addr = col;
+}
+
+/* Read the data buffer from the NAND Flash. To read the data from NAND
+ * Flash first the data output cycle is initiated by the NFC, which copies
+ * the data to RAMbuffer. This data of length len is then copied to buffer buf.
+ */
+static void mxc_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	int n, col, i = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_read_buf(col = %d, len = %d)\n", host->col_addr, len);
+
+	col = host->col_addr;
+
+	/* Adjust saved column address */
+	if (col < mtd->writesize && host->spare_only)
+		col += mtd->writesize;
+
+	n = mtd->writesize + mtd->oobsize - col;
+	n = min(len, n);
+
+	while (n) {
+		void __iomem *p;
+
+		if (col < mtd->writesize)
+			p = host->regs + MAIN_AREA0 + (col & ~3);
+		else
+			p = host->regs + SPARE_AREA0 -
+					mtd->writesize + (col & ~3);
+
+		if (((col | (int)&buf[i]) & 3) || n < 16) {
+			uint32_t data;
+
+			data = readl(p);
+			switch (col & 3) {
+			case 0:
+				if (n) {
+					buf[i++] = (uint8_t) (data);
+					n--;
+					col++;
+				}
+			case 1:
+				if (n) {
+					buf[i++] = (uint8_t) (data >> 8);
+					n--;
+					col++;
+				}
+			case 2:
+				if (n) {
+					buf[i++] = (uint8_t) (data >> 16);
+					n--;
+					col++;
+				}
+			case 3:
+				if (n) {
+					buf[i++] = (uint8_t) (data >> 24);
+					n--;
+					col++;
+				}
+			}
+		} else {
+			int m = mtd->writesize - col;
+
+			if (col >= mtd->writesize)
+				m += mtd->oobsize;
+
+			m = min(n, m) & ~3;
+			memcpy(&buf[i], p, m);
+			col += m;
+			i += m;
+			n -= m;
+		}
+	}
+	/* Update saved column address */
+	host->col_addr = col;
+
+}
+
+/* Used by the upper layer to verify the data in NAND Flash
+ * with the data in the buf. */
+static int mxc_nand_verify_buf(struct mtd_info *mtd,
+				const u_char *buf, int len)
+{
+	return -EFAULT;
+}
+
+/* This function is used by upper layer for select and
+ * deselect of the NAND chip */
+static void mxc_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+
+#ifdef CONFIG_MTD_NAND_MXC_FORCE_CE
+	if (chip > 0) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "ERROR:  Illegal chip select (chip = %d)\n", chip);
+		return;
+	}
+
+	if (chip == -1) {
+		writew(readw(host->regs + NFC_CONFIG1) & ~NFC_CE,
+				host->regs + NFC_CONFIG1);
+		return;
+	}
+
+	writew(readw(host->regs + NFC_CONFIG1) | NFC_CE,
+			host->regs + NFC_CONFIG1);
+#endif
+
+	switch (chip) {
+	case -1:
+		/* Disable the NFC clock */
+		if (host->clk_act) {
+			clk_disable(host->clk);
+			host->clk_act = 0;
+		}
+		break;
+	case 0:
+		/* Enable the NFC clock */
+		if (!host->clk_act) {
+			clk_enable(host->clk);
+			host->clk_act = 1;
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* Used by the upper layer to write command to NAND Flash for
+ * different operations to be carried out on NAND Flash */
+static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+	struct nand_chip *nand_chip = mtd->priv;
+	struct mxc_nand_host *host = nand_chip->priv;
+	int useirq = true;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",
+	      command, column, page_addr);
+
+	/* Reset command state information */
+	host->status_request = false;
+
+	/* Command pre-processing step */
+	switch (command) {
+
+	case NAND_CMD_STATUS:
+		host->col_addr = 0;
+		host->status_request = true;
+		break;
+
+	case NAND_CMD_READ0:
+		host->col_addr = column;
+		host->spare_only = false;
+		useirq = false;
+		break;
+
+	case NAND_CMD_READOOB:
+		host->col_addr = column;
+		host->spare_only = true;
+		useirq = false;
+		if (host->pagesize_2k)
+			command = NAND_CMD_READ0; /* only READ0 is valid */
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (column >= mtd->writesize) {
+			/*
+			 * FIXME: before send SEQIN command for write OOB,
+			 * We must read one page out.
+			 * For K9F1GXX has no READ1 command to set current HW
+			 * pointer to spare area, we must write the whole page
+			 * including OOB together.
+			 */
+			if (host->pagesize_2k)
+				/* call ourself to read a page */
+				mxc_nand_command(mtd, NAND_CMD_READ0, 0,
+						page_addr);
+
+			host->col_addr = column - mtd->writesize;
+			host->spare_only = true;
+
+			/* Set program pointer to spare region */
+			if (!host->pagesize_2k)
+				send_cmd(host, NAND_CMD_READOOB, false);
+		} else {
+			host->spare_only = false;
+			host->col_addr = column;
+
+			/* Set program pointer to page start */
+			if (!host->pagesize_2k)
+				send_cmd(host, NAND_CMD_READ0, false);
+		}
+		useirq = false;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		send_prog_page(host, 0, host->spare_only);
+
+		if (host->pagesize_2k) {
+			/* data in 4 areas datas */
+			send_prog_page(host, 1, host->spare_only);
+			send_prog_page(host, 2, host->spare_only);
+			send_prog_page(host, 3, host->spare_only);
+		}
+
+		break;
+
+	case NAND_CMD_ERASE1:
+		useirq = false;
+		break;
+	}
+
+	/* Write out the command to the device. */
+	send_cmd(host, command, useirq);
+
+	/* Write out column address, if necessary */
+	if (column != -1) {
+		/*
+		 * MXC NANDFC can only perform full page+spare or
+		 * spare-only read/write.  When the upper layers
+		 * layers perform a read/write buf operation,
+		 * we will used the saved column adress to index into
+		 * the full page.
+		 */
+		send_addr(host, 0, page_addr == -1);
+		if (host->pagesize_2k)
+			/* another col addr cycle for 2k page */
+			send_addr(host, 0, false);
+	}
+
+	/* Write out page address, if necessary */
+	if (page_addr != -1) {
+		/* paddr_0 - p_addr_7 */
+		send_addr(host, (page_addr & 0xff), false);
+
+		if (host->pagesize_2k) {
+			send_addr(host, (page_addr >> 8) & 0xFF, false);
+			if (mtd->size >= 0x40000000)
+				send_addr(host, (page_addr >> 16) & 0xff, true);
+		} else {
+			/* One more address cycle for higher density devices */
+			if (mtd->size >= 0x4000000) {
+				/* paddr_8 - paddr_15 */
+				send_addr(host, (page_addr >> 8) & 0xff, false);
+				send_addr(host, (page_addr >> 16) & 0xff, true);
+			} else
+				/* paddr_8 - paddr_15 */
+				send_addr(host, (page_addr >> 8) & 0xff, true);
+		}
+	}
+
+	/* Command post-processing step */
+	switch (command) {
+
+	case NAND_CMD_RESET:
+		break;
+
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		if (host->pagesize_2k) {
+			/* send read confirm command */
+			send_cmd(host, NAND_CMD_READSTART, true);
+			/* read for each AREA */
+			send_read_page(host, 0, host->spare_only);
+			send_read_page(host, 1, host->spare_only);
+			send_read_page(host, 2, host->spare_only);
+			send_read_page(host, 3, host->spare_only);
+		} else
+			send_read_page(host, 0, host->spare_only);
+		break;
+
+	case NAND_CMD_READID:
+		send_read_id(host);
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		break;
+
+	case NAND_CMD_STATUS:
+		break;
+
+	case NAND_CMD_ERASE2:
+		break;
+	}
+}
+
+static int __init mxcnd_probe(struct platform_device *pdev)
+{
+	struct nand_chip *this;
+	struct mtd_info *mtd;
+	struct mxc_nand_platform_data *pdata = pdev->dev.platform_data;
+	struct mxc_nand_host *host;
+	struct resource *res;
+	uint16_t tmp;
+	int err = 0, nr_parts = 0;
+
+	/* Allocate memory for MTD device structure and private data */
+	host = kzalloc(sizeof(struct mxc_nand_host), GFP_KERNEL);
+	if (!host)
+		return -ENOMEM;
+
+	host->dev = &pdev->dev;
+	/* structures must be linked */
+	this = &host->nand;
+	mtd = &host->mtd;
+	mtd->priv = this;
+	mtd->owner = THIS_MODULE;
+
+	/* 50 us command delay time */
+	this->chip_delay = 5;
+
+	this->priv = host;
+	this->dev_ready = mxc_nand_dev_ready;
+	this->cmdfunc = mxc_nand_command;
+	this->select_chip = mxc_nand_select_chip;
+	this->read_byte = mxc_nand_read_byte;
+	this->read_word = mxc_nand_read_word;
+	this->write_buf = mxc_nand_write_buf;
+	this->read_buf = mxc_nand_read_buf;
+	this->verify_buf = mxc_nand_verify_buf;
+
+	host->clk = clk_get(&pdev->dev, "nfc_clk");
+	if (IS_ERR(host->clk))
+		goto eclk;
+
+	clk_enable(host->clk);
+	host->clk_act = 1;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		err = -ENODEV;
+		goto eres;
+	}
+
+	host->regs = ioremap(res->start, res->end - res->start + 1);
+	if (!host->regs) {
+		err = -EIO;
+		goto eres;
+	}
+
+	tmp = readw(host->regs + NFC_CONFIG1);
+	tmp |= NFC_INT_MSK;
+	writew(tmp, host->regs + NFC_CONFIG1);
+
+	init_waitqueue_head(&host->irq_waitq);
+
+	host->irq = platform_get_irq(pdev, 0);
+
+	err = request_irq(host->irq, mxc_nfc_irq, 0, "mxc_nd", host);
+	if (err)
+		goto eirq;
+
+	if (pdata->hw_ecc) {
+		this->ecc.calculate = mxc_nand_calculate_ecc;
+		this->ecc.hwctl = mxc_nand_enable_hwecc;
+		this->ecc.correct = mxc_nand_correct_data;
+		this->ecc.mode = NAND_ECC_HW;
+		this->ecc.size = 512;
+		this->ecc.bytes = 3;
+		this->ecc.layout = &nand_hw_eccoob_8;
+		tmp = readw(host->regs + NFC_CONFIG1);
+		tmp |= NFC_ECC_EN;
+		writew(tmp, host->regs + NFC_CONFIG1);
+	} else {
+		this->ecc.size = 512;
+		this->ecc.bytes = 3;
+		this->ecc.layout = &nand_hw_eccoob_8;
+		this->ecc.mode = NAND_ECC_SOFT;
+		tmp = readw(host->regs + NFC_CONFIG1);
+		tmp &= ~NFC_ECC_EN;
+		writew(tmp, host->regs + NFC_CONFIG1);
+	}
+
+	/* Reset NAND */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* preset operation */
+	/* Unlock the internal RAM Buffer */
+	writew(0x2, host->regs + NFC_CONFIG);
+
+	/* Blocks to be unlocked */
+	writew(0x0, host->regs + NFC_UNLOCKSTART_BLKADDR);
+	writew(0x4000, host->regs + NFC_UNLOCKEND_BLKADDR);
+
+	/* Unlock Block Command for given address range */
+	writew(0x4, host->regs + NFC_WRPROT);
+
+	/* NAND bus width determines access funtions used by upper layer */
+	if (pdata->width == 2) {
+		this->options |= NAND_BUSWIDTH_16;
+		this->ecc.layout = &nand_hw_eccoob_16;
+	}
+
+	host->pagesize_2k = 0;
+
+	/* Scan to find existence of the device */
+	if (nand_scan(mtd, 1)) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "MXC_ND: Unable to find any NAND device.\n");
+		err = -ENXIO;
+		goto escan;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts =
+	    parse_mtd_partitions(mtd, part_probes, &host->parts, 0);
+	if (nr_parts > 0)
+		add_mtd_partitions(mtd, host->parts, nr_parts);
+	else
+#endif
+	{
+		pr_info("Registering %s as whole device\n", mtd->name);
+		add_mtd_device(mtd);
+	}
+
+	platform_set_drvdata(pdev, host);
+
+	return 0;
+
+escan:
+	free_irq(host->irq, NULL);
+eirq:
+	iounmap(host->regs);
+eres:
+	clk_put(host->clk);
+eclk:
+	kfree(host);
+
+	return err;
+}
+
+static int __devexit mxcnd_remove(struct platform_device *pdev)
+{
+	struct mxc_nand_host *host = platform_get_drvdata(pdev);
+
+	clk_put(host->clk);
+
+	platform_set_drvdata(pdev, NULL);
+
+	nand_release(&host->mtd);
+	free_irq(host->irq, NULL);
+	iounmap(host->regs);
+	kfree(host);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mxcnd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mtd_info *info = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND : NAND suspend\n");
+	if (info)
+		ret = info->suspend(info);
+
+	/* Disable the NFC clock */
+	clk_disable(nfc_clk);	/* FIXME */
+
+	return ret;
+}
+
+static int mxcnd_resume(struct platform_device *pdev)
+{
+	struct mtd_info *info = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND : NAND resume\n");
+	/* Enable the NFC clock */
+	clk_enable(nfc_clk);	/* FIXME */
+
+	if (info)
+		info->resume(info);
+
+	return ret;
+}
+
+#else
+# define mxcnd_suspend   NULL
+# define mxcnd_resume    NULL
+#endif				/* CONFIG_PM */
+
+static struct platform_driver mxcnd_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   },
+	.remove = __exit_p(mxcnd_remove),
+	.suspend = mxcnd_suspend,
+	.resume = mxcnd_resume,
+};
+
+static int __init mxc_nd_init(void)
+{
+	/* Register the device driver structure. */
+	pr_info("MXC MTD nand Driver\n");
+	if (platform_driver_probe(&mxcnd_driver, mxcnd_probe) != 0) {
+		printk(KERN_ERR "Driver register failed for mxcnd_driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit mxc_nd_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxcnd_driver);
+}
+
+module_init(mxc_nd_init);
+module_exit(mxc_nd_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC NAND MTD driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/mxc_nd2.c b/drivers/mtd/nand/mxc_nd2.c
new file mode 100644
index 0000000..bbc153e
--- /dev/null
+++ b/drivers/mtd/nand/mxc_nd2.c
@@ -0,0 +1,1458 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mtd/partitions.h>
+#include <asm/mach/flash.h>
+#include <asm/io.h>
+#include <mach/common.h>
+#include "mxc_nd2.h"
+
+#define DVR_VER "2.5"
+
+/* Global address Variables */
+static u32 nfc_axi_base, nfc_ip_base;
+
+struct mxc_mtd_s {
+	struct mtd_info mtd;
+	struct nand_chip nand;
+	struct mtd_partition *parts;
+	struct device *dev;
+};
+
+static struct mxc_mtd_s *mxc_nand_data;
+
+/*
+ * Define delays in microsec for NAND device operations
+ */
+#define TROP_US_DELAY   2000
+
+struct nand_info {
+	bool bStatusRequest;
+	u16 colAddr;
+};
+
+static struct nand_info g_nandfc_info;
+
+#ifdef CONFIG_MTD_NAND_MXC_SWECC
+static int hardware_ecc = 0;
+#else
+static int hardware_ecc = 1;
+#endif
+
+static u8 num_of_interleave = 1;
+
+static u8 *data_buf;
+static u8 *oob_buf;
+
+static int g_page_mask;
+
+static struct clk *nfc_clk;
+
+/*
+ * OOB placement block for use with hardware ecc generation
+ */
+static struct nand_ecclayout nand_hw_eccoob_512 = {
+	.eccbytes = 9,
+	.eccpos = {7, 8, 9, 10, 11, 12, 13, 14, 15},
+	.oobavail = 4,
+	.oobfree = {{0, 4} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_2k = {
+	.eccbytes = 9,
+	.eccpos = {7, 8, 9, 10, 11, 12, 13, 14, 15},
+	.oobavail = 4,
+	.oobfree = {{2, 4} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_4k = {
+	.eccbytes = 32,
+	.eccpos = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+		   38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 },
+	.oobavail = 30,
+	.oobfree = {{2, 10}, {28, 10}, {54, 10} }
+};
+
+/*!
+ * @defgroup NAND_MTD NAND Flash MTD Driver for MXC processors
+ */
+
+/*!
+ * @file mxc_nd2.c
+ *
+ * @brief This file contains the hardware specific layer for NAND Flash on
+ * MXC processor
+ *
+ * @ingroup NAND_MTD
+ */
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "RedBoot", "cmdlinepart", NULL };
+#endif
+
+static wait_queue_head_t irq_waitq;
+
+static irqreturn_t mxc_nfc_irq(int irq, void *dev_id)
+{
+	/* Disable Interuupt */
+	raw_write(raw_read(REG_NFC_INTRRUPT) | NFC_INT_MSK, REG_NFC_INTRRUPT);
+	wake_up(&irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Functions to transfer data to/from spare erea.
+ */
+static void
+copy_spare(struct mtd_info *mtd, void *pbuf, void *pspare, int len, bool bfrom)
+{
+	u16 i, j;
+	u16 m = mtd->oobsize;
+	u16 n = mtd->writesize >> 9;
+	u8 *d = (u8 *) pbuf;
+	u8 *s = (u8 *) pspare;
+	u16 t = SPARE_LEN;
+
+	m /= num_of_interleave;
+	n /= num_of_interleave;
+
+	j = (m / n >> 1) << 1;
+
+	if (bfrom) {
+		for (i = 0; i < n - 1; i++)
+			memcpy(&d[i * j], &s[i * t], j);
+
+		/* the last section */
+		memcpy(&d[i * j], &s[i * t], len - i * j);
+	} else {
+		for (i = 0; i < n - 1; i++)
+			memcpy(&s[i * t], &d[i * j], j);
+
+		/* the last section */
+		memcpy(&s[i * t], &d[i * j], len - i * j);
+	}
+}
+
+/*!
+ * This function polls the NFC to wait for the basic operation to complete by
+ * checking the INT bit of config2 register.
+ *
+ * @param       maxRetries     number of retry attempts (separated by 1 us)
+ * @param       useirq         True if IRQ should be used rather than polling
+ */
+static void wait_op_done(int maxRetries, bool useirq)
+{
+	if (useirq) {
+		if ((raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT) == 0) {
+			/* Enable Interuupt */
+			raw_write(raw_read(REG_NFC_INTRRUPT) & ~NFC_INT_MSK,
+				  REG_NFC_INTRRUPT);
+			wait_event(irq_waitq,
+				   (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT));
+		}
+		WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+				  ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
+	} else {
+		while (1) {
+			maxRetries--;
+			if (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT) {
+				WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+						  ~NFC_OPS_STAT),
+						 REG_NFC_OPS_STAT);
+				break;
+			}
+			udelay(1);
+			if (maxRetries <= 0) {
+				DEBUG(MTD_DEBUG_LEVEL0, "%s(%d): INT not set\n",
+				      __func__, __LINE__);
+			}
+		}
+	}
+}
+
+static inline void send_atomic_cmd(u16 cmd, bool useirq)
+{
+	/* fill command */
+	raw_write(cmd, REG_NFC_FLASH_CMD);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* send out command */
+	raw_write(NFC_CMD, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr);
+static int mxc_check_ecc_status(struct mtd_info *mtd);
+
+#ifdef NFC_AUTO_MODE_ENABLE
+/*!
+ * This function handle the interleave related work
+ * @param	mtd	mtd info
+ * @param	cmd	command
+ */
+static void auto_cmd_interleave(struct mtd_info *mtd, u16 cmd)
+{
+	u32 i;
+	u32 j = num_of_interleave;
+	struct nand_chip *this = mtd->priv;
+	u32 addr_low = raw_read(NFC_FLASH_ADDR0);
+	u32 addr_high = raw_read(NFC_FLASH_ADDR8);
+	u32 page_addr = addr_low >> 16 | addr_high << 16;
+	u8 *dbuf = data_buf;
+	u8 *obuf = oob_buf;
+	u32 dlen = mtd->writesize / j;
+	u32 olen = mtd->oobsize / j;
+
+	/* adjust the addr value
+	 * since ADD_OP mode is 01
+	 */
+	if (j > 1)
+		page_addr *= j;
+	else
+		page_addr *= this->numchips;
+
+	switch (cmd) {
+	case NAND_CMD_PAGEPROG:
+		for (i = 0; i < j; i++) {
+			/* reset addr cycle */
+			if (j > 1)
+				mxc_do_addr_cycle(mtd, 0, page_addr++);
+
+			/* data transfer */
+			memcpy(MAIN_AREA0, dbuf, dlen);
+			copy_spare(mtd, obuf, SPARE_AREA0, olen, false);
+
+			/* update the value */
+			dbuf += dlen;
+			obuf += olen;
+
+			NFC_SET_RBA(0);
+			ACK_OPS;
+			raw_write(NFC_AUTO_PROG, REG_NFC_OPS);
+
+			/* wait auto_prog_done bit set */
+			while (!(raw_read(REG_NFC_OPS_STAT) & NFC_OP_DONE))
+				;
+		}
+
+		wait_op_done(TROP_US_DELAY, false);
+		while (!(raw_read(REG_NFC_OPS_STAT) & NFC_RB))
+			;
+
+		break;
+	case NAND_CMD_READSTART:
+		for (i = 0; i < j; i++) {
+			/* reset addr cycle */
+			if (j > 1)
+				mxc_do_addr_cycle(mtd, 0, page_addr++);
+
+			NFC_SET_RBA(0);
+			ACK_OPS;
+			raw_write(NFC_AUTO_READ, REG_NFC_OPS);
+			wait_op_done(TROP_US_DELAY, false);
+
+			/* check ecc error */
+			mxc_check_ecc_status(mtd);
+
+			/* data transfer */
+			memcpy(dbuf, MAIN_AREA0, dlen);
+			copy_spare(mtd, obuf, SPARE_AREA0, olen, true);
+
+			/* update the value */
+			dbuf += dlen;
+			obuf += olen;
+		}
+		break;
+	case NAND_CMD_ERASE2:
+		for (i = 0; i < j; i++) {
+			if (!i) {
+				page_addr = addr_low;
+				page_addr *= (j > 1 ? j : this->numchips);
+			}
+			mxc_do_addr_cycle(mtd, -1, page_addr++);
+			ACK_OPS;
+			raw_write(NFC_AUTO_ERASE, REG_NFC_OPS);
+			wait_op_done(TROP_US_DELAY, true);
+		}
+		break;
+	case NAND_CMD_RESET:
+		for (i = 0; i < j; i++) {
+			if (j > 1)
+				NFC_SET_NFC_ACTIVE_CS(i);
+			send_atomic_cmd(cmd, false);
+		}
+		break;
+	default:
+		break;
+	}
+}
+#endif
+
+static void send_addr(u16 addr, bool useirq);
+
+/*!
+ * This function issues the specified command to the NAND device and
+ * waits for completion.
+ *
+ * @param       cmd     command for NAND Flash
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_cmd(struct mtd_info *mtd, u16 cmd, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_cmd(0x%x, %d)\n", cmd, useirq);
+
+#ifdef NFC_AUTO_MODE_ENABLE
+	switch (cmd) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READOOB:
+		raw_write(NAND_CMD_READ0, REG_NFC_FLASH_CMD);
+		break;
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_ERASE1:
+		raw_write(cmd, REG_NFC_FLASH_CMD);
+		break;
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_READSTART:
+		raw_write(raw_read(REG_NFC_FLASH_CMD) | cmd << NFC_CMD_1_SHIFT,
+			  REG_NFC_FLASH_CMD);
+		auto_cmd_interleave(mtd, cmd);
+		break;
+	case NAND_CMD_READID:
+		send_atomic_cmd(cmd, useirq);
+		send_addr(0, false);
+		break;
+	case NAND_CMD_RESET:
+		auto_cmd_interleave(mtd, cmd);
+	case NAND_CMD_STATUS:
+		break;
+	default:
+		break;
+	}
+#else
+	send_atomic_cmd(cmd, useirq);
+#endif
+}
+
+/*!
+ * This function sends an address (or partial address) to the
+ * NAND device.  The address is used to select the source/destination for
+ * a NAND command.
+ *
+ * @param       addr    address to be written to NFC.
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_addr(u16 addr, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_addr(0x%x %d)\n", addr, useirq);
+
+	/* fill address */
+	raw_write((addr << NFC_FLASH_ADDR_SHIFT), REG_NFC_FLASH_ADDR);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* send out address */
+	raw_write(NFC_ADDR, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+/*!
+ * This function requests the NFC to initate the transfer
+ * of data currently in the NFC RAM buffer to the NAND device.
+ *
+ * @param	buf_id	      Specify Internal RAM Buffer number
+ */
+static void send_prog_page(u8 buf_id)
+{
+#ifndef NFC_AUTO_MODE_ENABLE
+	DEBUG(MTD_DEBUG_LEVEL3, "%s\n", __FUNCTION__);
+
+	/* set ram buffer id */
+	NFC_SET_RBA(buf_id);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* transfer data from NFC ram to nand */
+	raw_write(NFC_INPUT, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, false);
+#endif
+}
+
+/*!
+ * This function requests the NFC to initated the transfer
+ * of data from the NAND device into in the NFC ram buffer.
+ *
+ * @param  	buf_id		Specify Internal RAM Buffer number
+ */
+static void send_read_page(u8 buf_id)
+{
+#ifndef NFC_AUTO_MODE_ENABLE
+	DEBUG(MTD_DEBUG_LEVEL3, "%s(%d)\n", __FUNCTION__, buf_id);
+
+	/* set ram buffer id */
+	NFC_SET_RBA(buf_id);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* transfer data from nand to NFC ram */
+	raw_write(NFC_OUTPUT, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, false);
+#endif
+}
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device ID.
+ */
+static void send_read_id(void)
+{
+	/* Set RBA bits for BUFFER0 */
+	NFC_SET_RBA(0);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* Read ID into main buffer */
+	raw_write(NFC_ID, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, false);
+
+}
+
+#ifdef NFC_AUTO_MODE_ENABLE
+static inline void read_dev_status(u16 *status)
+{
+	u32 mask = 0xFF << 16;
+
+	/* clear status */
+	ACK_OPS;
+
+	do {
+		/* send auto read status command */
+		raw_write(NFC_AUTO_STATE, REG_NFC_OPS);
+		if (cpu_is_mx51_rev(CHIP_REV_2_0) == 1)
+			wait_op_done(TROP_US_DELAY, false);
+		*status = (raw_read(NFC_CONFIG1) & mask) >> 16;
+	} while ((*status & NAND_STATUS_READY) == 0);
+}
+#endif
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device status and returns the current status.
+ *
+ * @return  device status
+ */
+static u16 get_dev_status(void)
+{
+#ifdef NFC_AUTO_MODE_ENABLE
+	int i;
+	u16 status = 0;
+	for (i = 0; i < num_of_interleave; i++) {
+
+		/* set ative cs */
+		NFC_SET_NFC_ACTIVE_CS(i);
+
+		/* FIXME, NFC Auto erase may have
+		 * problem, have to pollingit until
+		 * the nand get idle, otherwise
+		 * it may get error
+		 */
+		read_dev_status(&status);
+		if (status & NAND_STATUS_FAIL)
+			break;
+	}
+
+	return status;
+#else
+	volatile u16 *mainBuf = MAIN_AREA1;
+	u8 val = 1;
+	u16 ret;
+
+	/* Set ram buffer id */
+	NFC_SET_RBA(val);
+
+	/* clear status */
+	ACK_OPS;
+
+	/* Read status into main buffer */
+	raw_write(NFC_STATUS, REG_NFC_OPS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, false);
+
+	/* Status is placed in first word of main buffer */
+	/* get status, then recovery area 1 data */
+	ret = *mainBuf;
+
+	return ret;
+#endif
+}
+
+static void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN);
+	return;
+}
+
+/*
+ * Function to record the ECC corrected/uncorrected errors resulted
+ * after a page read. This NFC detects and corrects upto to 4 symbols
+ * of 9-bits each.
+ */
+static int mxc_check_ecc_status(struct mtd_info *mtd)
+{
+	u32 ecc_stat, err;
+	int no_subpages = 1;
+	int ret = 0;
+	u8 ecc_bit_mask, err_limit;
+
+	ecc_bit_mask = (IS_4BIT_ECC ? 0x7 : 0xf);
+	err_limit = (IS_4BIT_ECC ? 0x4 : 0x8);
+
+	no_subpages = mtd->writesize >> 9;
+
+	no_subpages /= num_of_interleave;
+
+	ecc_stat = GET_NFC_ECC_STATUS();
+	do {
+		err = ecc_stat & ecc_bit_mask;
+		if (err > err_limit) {
+			mtd->ecc_stats.failed++;
+			printk(KERN_WARNING "UnCorrectable RS-ECC Error\n");
+			return -1;
+		} else {
+			ret += err;
+		}
+		ecc_stat >>= 4;
+	} while (--no_subpages);
+
+	mtd->ecc_stats.corrected += ret;
+	pr_debug("%d Symbol Correctable RS-ECC Error\n", ret);
+
+	return ret;
+}
+
+/*
+ * Function to correct the detected errors. This NFC corrects all the errors
+ * detected. So this function just return 0.
+ */
+static int mxc_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)
+{
+	return 0;
+}
+
+/*
+ * Function to calculate the ECC for the data to be stored in the Nand device.
+ * This NFC has a hardware RS(511,503) ECC engine together with the RS ECC
+ * CONTROL blocks are responsible for detection  and correction of up to
+ * 8 symbols of 9 bits each in 528 byte page.
+ * So this function is just return 0.
+ */
+
+static int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				  u_char *ecc_code)
+{
+	return 0;
+}
+
+/*!
+ * This function id is used to read the data buffer from the NAND Flash. To
+ * read the data from NAND Flash first the data output cycle is initiated by
+ * the NFC, which copies the data to RAMbuffer. This data of length \b len is
+ * then copied to buffer \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be read from NAND Flash
+ * @param       len     number of bytes to be read
+ */
+static void mxc_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	u16 col = g_nandfc_info.colAddr;
+
+	if (mtd->writesize) {
+
+		int j = mtd->writesize - col;
+		int n = mtd->oobsize + j;
+
+		n = min(n, len);
+
+		if (j > 0) {
+			if (n > j) {
+				memcpy(buf, &data_buf[col], j);
+				memcpy(buf + j, &oob_buf[0], n - j);
+			} else {
+				memcpy(buf, &data_buf[col], n);
+			}
+		} else {
+			col -= mtd->writesize;
+			memcpy(buf, &oob_buf[col], len);
+		}
+
+		/* update */
+		g_nandfc_info.colAddr += n;
+
+	} else {
+		/* At flash identify phase,
+		 * mtd->writesize has not been
+		 * set correctly, it should
+		 * be zero.And len will less 2
+		 */
+		memcpy(buf, &data_buf[col], len);
+
+		/* update */
+		g_nandfc_info.colAddr += len;
+	}
+
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static uint8_t mxc_nand_read_byte(struct mtd_info *mtd)
+{
+	uint8_t ret;
+
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest) {
+		return (get_dev_status() & 0xFF);
+	}
+
+	mxc_nand_read_buf(mtd, &ret, 1);
+
+	return ret;
+}
+
+/*!
+  * This function reads word from the NAND Flash
+  *
+  * @param     mtd     MTD structure for the NAND Flash
+  *
+  * @return    data read from the NAND Flash
+  */
+static u16 mxc_nand_read_word(struct mtd_info *mtd)
+{
+	u16 ret;
+
+	mxc_nand_read_buf(mtd, (uint8_t *) &ret, sizeof(u16));
+
+	return ret;
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param     mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static u_char mxc_nand_read_byte16(struct mtd_info *mtd)
+{
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest) {
+		return (get_dev_status() & 0xFF);
+	}
+
+	return mxc_nand_read_word(mtd) & 0xFF;
+}
+
+/*!
+ * This function writes data of length \b len from buffer \b buf to the NAND
+ * internal RAM buffer's MAIN area 0.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be written to NAND Flash
+ * @param       len     number of bytes to be written
+ */
+static void mxc_nand_write_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	u16 col = g_nandfc_info.colAddr;
+	int j = mtd->writesize - col;
+	int n = mtd->oobsize + j;
+
+	n = min(n, len);
+
+	if (j > 0) {
+		if (n > j) {
+			memcpy(&data_buf[col], buf, j);
+			memcpy(&oob_buf[0], buf + j, n - j);
+		} else {
+			memcpy(&data_buf[col], buf, n);
+		}
+	} else {
+		col -= mtd->writesize;
+		memcpy(&oob_buf[col], buf, len);
+	}
+
+	/* update */
+	g_nandfc_info.colAddr += n;
+}
+
+/*!
+ * This function is used by the upper layer to verify the data in NAND Flash
+ * with the data in the \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be verified
+ * @param       len     length of the data to be verified
+ *
+ * @return      -EFAULT if error else 0
+ *
+ */
+static int mxc_nand_verify_buf(struct mtd_info *mtd, const u_char *buf,
+			       int len)
+{
+	u_char *s = data_buf;
+
+	const u_char *p = buf;
+
+	for (; len > 0; len--) {
+		if (*p++ != *s++)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*!
+ * This function is used by upper layer for select and deselect of the NAND
+ * chip
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       chip    val indicating select or deselect
+ */
+static void mxc_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+
+	switch (chip) {
+	case -1:
+		/* Disable the NFC clock */
+		clk_disable(nfc_clk);
+		break;
+	case 0 ... 7:
+		/* Enable the NFC clock */
+		clk_enable(nfc_clk);
+
+		NFC_SET_NFC_ACTIVE_CS(chip);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*
+ * Function to perform the address cycles.
+ */
+static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)
+{
+#ifdef NFC_AUTO_MODE_ENABLE
+
+	if (page_addr != -1 && column != -1) {
+		u32 mask = 0xFFFF;
+		/* the column address */
+		raw_write(column & mask, NFC_FLASH_ADDR0);
+		raw_write((raw_read(NFC_FLASH_ADDR0) |
+			   ((page_addr & mask) << 16)), NFC_FLASH_ADDR0);
+		/* the row address */
+		raw_write(((raw_read(NFC_FLASH_ADDR8) & (mask << 16)) |
+			   ((page_addr & (mask << 16)) >> 16)),
+			  NFC_FLASH_ADDR8);
+	} else if (page_addr != -1) {
+		raw_write(page_addr, NFC_FLASH_ADDR0);
+	}
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "AutoMode:the ADDR REGS value is (0x%x, 0x%x)\n",
+	      raw_read(NFC_FLASH_ADDR0), raw_read(NFC_FLASH_ADDR8));
+#else
+
+	u32 page_mask = g_page_mask;
+
+	if (column != -1) {
+		send_addr(column & 0xFF, false);
+		if (IS_2K_PAGE_NAND) {
+			/* another col addr cycle for 2k page */
+			send_addr((column >> 8) & 0xF, false);
+		} else if (IS_4K_PAGE_NAND) {
+			/* another col addr cycle for 4k page */
+			send_addr((column >> 8) & 0x1F, false);
+		}
+	}
+	if (page_addr != -1) {
+		do {
+			send_addr((page_addr & 0xff), false);
+			page_mask >>= 8;
+			page_addr >>= 8;
+		} while (page_mask != 0);
+	}
+#endif
+}
+
+/*!
+ * This function is used by the upper layer to write command to NAND Flash for
+ * different operations to be carried out on NAND Flash
+ *
+ * @param       mtd             MTD structure for the NAND Flash
+ * @param       command         command for NAND Flash
+ * @param       column          column offset for the page read
+ * @param       page_addr       page to be read from NAND Flash
+ */
+static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
+			     int column, int page_addr)
+{
+	bool useirq = false;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",
+	      command, column, page_addr);
+	/*
+	 * Reset command state information
+	 */
+	g_nandfc_info.bStatusRequest = false;
+
+	/*
+	 * Command pre-processing step
+	 */
+	switch (command) {
+	case NAND_CMD_STATUS:
+		g_nandfc_info.colAddr = 0;
+		g_nandfc_info.bStatusRequest = true;
+		break;
+
+	case NAND_CMD_READ0:
+		g_nandfc_info.colAddr = column;
+		break;
+
+	case NAND_CMD_READOOB:
+		g_nandfc_info.colAddr = column;
+		command = NAND_CMD_READ0;
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (column != 0) {
+
+			/* FIXME: before send SEQIN command for
+			 * partial write,We need read one page out.
+			 * FSL NFC does not support partial write
+			 * It alway send out 512+ecc+512+ecc ...
+			 * for large page nand flash. But for small
+			 * page nand flash, it did support SPARE
+			 * ONLY operation. But to make driver
+			 * simple. We take the same as large page,read
+			 * whole page out and update. As for MLC nand
+			 * NOP(num of operation) = 1. Partial written
+			 * on one programed page is not allowed! We
+			 * can't limit it on the driver, it need the
+			 * upper layer applicaiton take care it
+			 */
+
+			mxc_nand_command(mtd, NAND_CMD_READ0, 0, page_addr);
+		}
+
+		g_nandfc_info.colAddr = column;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+#ifndef NFC_AUTO_MODE_ENABLE
+		/* FIXME:the NFC interal buffer
+		 * access has some limitation, it
+		 * does not allow byte access. To
+		 * make the code simple and ease use
+		 * not every time check the address
+		 * alignment.Use the temp buffer
+		 * to accomadate the data.since We
+		 * know data_buf will be at leat 4
+		 * byte alignment, so we can use
+		 * memcpy safely
+		 */
+		memcpy(MAIN_AREA0, data_buf, mtd->writesize);
+		copy_spare(mtd, oob_buf, SPARE_AREA0, mtd->oobsize, false);
+#endif
+
+		if (IS_LARGE_PAGE_NAND)
+			PROG_PAGE();
+		else
+			send_prog_page(0);
+
+		useirq = true;
+
+		break;
+
+	case NAND_CMD_ERASE1:
+		break;
+	case NAND_CMD_ERASE2:
+		useirq = true;
+
+		break;
+	}
+
+	/*
+	 * Write out the command to the device.
+	 */
+	send_cmd(mtd, command, useirq);
+
+	mxc_do_addr_cycle(mtd, column, page_addr);
+
+	/*
+	 * Command post-processing step
+	 */
+	switch (command) {
+
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		if (IS_LARGE_PAGE_NAND) {
+			/* send read confirm command */
+			send_cmd(mtd, NAND_CMD_READSTART, false);
+			/* read for each AREA */
+			READ_PAGE();
+		} else {
+			send_read_page(0);
+		}
+
+#ifndef NFC_AUTO_MODE_ENABLE
+		/* FIXME, the NFC interal buffer
+		 * access has some limitation, it
+		 * does not allow byte access. To
+		 * make the code simple and ease use
+		 * not every time check the address
+		 * alignment.Use the temp buffer
+		 * to accomadate the data.since We
+		 * know data_buf will be at leat 4
+		 * byte alignment, so we can use
+		 * memcpy safely
+		 */
+		memcpy(data_buf, MAIN_AREA0, mtd->writesize);
+		copy_spare(mtd, oob_buf, SPARE_AREA0, mtd->oobsize, true);
+#endif
+
+		break;
+
+	case NAND_CMD_READID:
+		send_read_id();
+		g_nandfc_info.colAddr = column;
+		memcpy(data_buf, MAIN_AREA0, 2048);
+
+		break;
+	}
+}
+
+static int mxc_nand_read_oob(struct mtd_info *mtd,
+			     struct nand_chip *chip, int page, int sndcmd)
+{
+	if (sndcmd) {
+
+		chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
+		sndcmd = 0;
+	}
+
+	memcpy(chip->oob_poi, oob_buf, mtd->oobsize);
+
+	return sndcmd;
+}
+
+static int mxc_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+			      uint8_t *buf)
+{
+
+#ifndef NFC_AUTO_MODE_ENABLE
+	mxc_check_ecc_status(mtd);
+#endif
+
+	memcpy(buf, data_buf, mtd->writesize);
+	memcpy(chip->oob_poi, oob_buf, mtd->oobsize);
+
+	return 0;
+}
+
+static void mxc_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+				const uint8_t *buf)
+{
+	memcpy(data_buf, buf, mtd->writesize);
+	memcpy(oob_buf, chip->oob_poi, mtd->oobsize);
+
+}
+
+/* Define some generic bad / good block scan pattern which are used
+ * while scanning a device for factory marked good / bad blocks. */
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr smallpage_memorybased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr largepage_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+static int mxc_nand_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	int maf_id, dev_id;
+
+	/* Select the device */
+	this->select_chip(mtd, 0);
+
+	/* Send the command for reading device ID */
+	this->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	maf_id = this->read_byte(mtd);
+	dev_id = this->read_byte(mtd);
+
+	if (maf_id == NAND_MFR_MICRON && dev_id == 0xd5)
+		mtd->oobsize = 218;
+
+	g_page_mask = this->pagemask;
+
+	if (IS_2K_PAGE_NAND) {
+		NFC_SET_NFMS(1 << NFMS_NF_PG_SZ);
+		this->ecc.layout = &nand_hw_eccoob_2k;
+	} else if (IS_4K_PAGE_NAND) {
+		NFC_SET_NFMS(1 << NFMS_NF_PG_SZ);
+		this->ecc.layout = &nand_hw_eccoob_4k;
+	} else {
+		this->ecc.layout = &nand_hw_eccoob_512;
+	}
+
+	/* reconfig for interleave mode */
+#ifdef NFC_AUTO_MODE_ENABLE
+	if (this->numchips > 1) {
+		num_of_interleave = this->numchips;
+		this->numchips = 1;
+
+		/* FIXEME:need remove it
+		 * when kernel support
+		 * 4G larger space
+		 */
+		mtd->size = this->chipsize;
+		mtd->erasesize *= num_of_interleave;
+		mtd->writesize *= num_of_interleave;
+		mtd->oobsize *= num_of_interleave;
+		this->page_shift = ffs(mtd->writesize) - 1;
+		this->bbt_erase_shift =
+		    this->phys_erase_shift = ffs(mtd->erasesize) - 1;
+		this->chip_shift = ffs(this->chipsize) - 1;
+		this->oob_poi = this->buffers->databuf + mtd->writesize;
+	}
+#endif
+
+	mtd->flags &= ~MTD_OOB_WRITEABLE;
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = this->ecc.layout;
+
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
+	/* update flash based bbt */
+	this->options |= NAND_USE_FLASH_BBT;
+
+	if (!this->badblock_pattern) {
+		this->badblock_pattern = (mtd->writesize > 512) ?
+		    &largepage_memorybased : &smallpage_memorybased;
+	}
+
+	/* Build bad block table */
+	return nand_scan_bbt(mtd, this->badblock_pattern);
+}
+
+static void mxc_nfc_init(void)
+{
+	/* Disable interrupt */
+	raw_write((raw_read(REG_NFC_INTRRUPT) | NFC_INT_MSK), REG_NFC_INTRRUPT);
+
+	/* disable spare enable */
+	raw_write(raw_read(REG_NFC_SP_EN) & ~NFC_SP_EN, REG_NFC_SP_EN);
+
+	/* Unlock the internal RAM Buffer */
+	raw_write(NFC_SET_BLS(NFC_BLS_UNLCOKED), REG_NFC_BLS);
+
+	/* Blocks to be unlocked */
+	UNLOCK_ADDR(0x0, 0xFFFF);
+
+	/* Unlock Block Command for given address range */
+	raw_write(NFC_SET_WPC(NFC_WPC_UNLOCK), REG_NFC_WPC);
+
+	/* Enable symetric mode by default except mx37TO1.0 */
+	if (!(cpu_is_mx37_rev(CHIP_REV_1_0) == 1))
+		raw_write(raw_read(REG_NFC_ONE_CYCLE) |
+			  NFC_ONE_CYCLE, REG_NFC_ONE_CYCLE);
+
+}
+
+static int mxc_alloc_buf(void)
+{
+	int err = 0;
+
+	data_buf = kzalloc(NAND_MAX_PAGESIZE * NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!data_buf) {
+		printk(KERN_ERR "%s: failed to allocate data_buf\n", __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+	oob_buf = kzalloc(NAND_MAX_OOBSIZE * NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!oob_buf) {
+		printk(KERN_ERR "%s: failed to allocate oob_buf\n", __func__);
+		err = -ENOMEM;
+		goto out;
+	}
+
+      out:
+	return err;
+}
+
+static void mxc_free_buf(void)
+{
+	kfree(data_buf);
+	kfree(oob_buf);
+}
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and
+ *                remove functions
+ *
+ * @return  The function always returns 0.
+ */
+static int __init mxcnd_probe(struct platform_device *pdev)
+{
+	struct nand_chip *this;
+	struct mtd_info *mtd;
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	int nr_parts = 0, err = 0;
+
+	nfc_axi_base = IO_ADDRESS(NFC_AXI_BASE_ADDR);
+	nfc_ip_base = IO_ADDRESS(NFC_BASE_ADDR);
+
+	/* init the nfc */
+	mxc_nfc_init();
+
+	/* init data buf */
+	if (mxc_alloc_buf())
+		goto out;
+
+	/* Allocate memory for MTD device structure and private data */
+	mxc_nand_data = kzalloc(sizeof(struct mxc_mtd_s), GFP_KERNEL);
+	if (!mxc_nand_data) {
+		printk(KERN_ERR "%s: failed to allocate mtd_info\n",
+		       __FUNCTION__);
+		err = -ENOMEM;
+		goto out;
+	}
+
+	memset((char *)&g_nandfc_info, 0, sizeof(g_nandfc_info));
+
+	mxc_nand_data->dev = &pdev->dev;
+	/* structures must be linked */
+	this = &mxc_nand_data->nand;
+	mtd = &mxc_nand_data->mtd;
+	mtd->priv = this;
+	mtd->owner = THIS_MODULE;
+
+	this->priv = mxc_nand_data;
+	this->cmdfunc = mxc_nand_command;
+	this->select_chip = mxc_nand_select_chip;
+	this->read_byte = mxc_nand_read_byte;
+	this->read_word = mxc_nand_read_word;
+	this->write_buf = mxc_nand_write_buf;
+	this->read_buf = mxc_nand_read_buf;
+	this->verify_buf = mxc_nand_verify_buf;
+	this->scan_bbt = mxc_nand_scan_bbt;
+
+	this->options |= NAND_OWN_BUFFERS;
+	this->buffers = kzalloc((NAND_MAX_OOBSIZE * 3 + NAND_MAX_PAGESIZE) * NAND_MAX_CHIPS, GFP_KERNEL);
+	if (!this->buffers)
+		goto out_1;
+
+	/* NAND bus width determines access funtions used by upper layer */
+	if (flash->width == 2) {
+		this->read_byte = mxc_nand_read_byte16;
+		this->options |= NAND_BUSWIDTH_16;
+		NFC_SET_NFMS(1 << NFMS_NF_DWIDTH);
+	} else {
+		NFC_SET_NFMS(0);
+	}
+
+	nfc_clk = clk_get(&pdev->dev, "nfc_clk");
+	clk_enable(nfc_clk);
+
+	init_waitqueue_head(&irq_waitq);
+	err = request_irq(MXC_INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
+	if (err) {
+		goto out_2;
+	}
+
+	if (hardware_ecc) {
+		this->ecc.read_page = mxc_nand_read_page;
+		this->ecc.write_page = mxc_nand_write_page;
+		this->ecc.read_oob = mxc_nand_read_oob;
+		this->ecc.layout = &nand_hw_eccoob_512;
+		this->ecc.calculate = mxc_nand_calculate_ecc;
+		this->ecc.hwctl = mxc_nand_enable_hwecc;
+		this->ecc.correct = mxc_nand_correct_data;
+		this->ecc.mode = NAND_ECC_HW;
+		this->ecc.size = 512;
+		this->ecc.bytes = 9;
+		raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN),
+			  REG_NFC_ECC_EN);
+	} else {
+		this->ecc.mode = NAND_ECC_SOFT;
+		raw_write((raw_read(REG_NFC_ECC_EN) & ~NFC_ECC_EN),
+			  REG_NFC_ECC_EN);
+	}
+
+	/* config the gpio */
+	if (flash->init)
+		flash->init();
+
+	/* Reset NAND */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Scan to find existence of the device */
+	if (nand_scan(mtd, NFC_GET_MAXCHIP_SP())) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "MXC_ND2: Unable to find any NAND device.\n");
+		err = -ENXIO;
+		goto out_2;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts =
+	    parse_mtd_partitions(mtd, part_probes, &mxc_nand_data->parts, 0);
+	if (nr_parts > 0)
+		add_mtd_partitions(mtd, mxc_nand_data->parts, nr_parts);
+	else if (flash->parts)
+		add_mtd_partitions(mtd, flash->parts, flash->nr_parts);
+	else
+#endif
+	{
+		pr_info("Registering %s as whole device\n", mtd->name);
+		add_mtd_device(mtd);
+	}
+
+	platform_set_drvdata(pdev, mtd);
+
+	return 0;
+out_2:
+	kfree(this->buffers);
+out_1:
+	kfree(mxc_nand_data);
+out:
+	return err;
+
+}
+
+ /*!
+  * Dissociates the driver from the device.
+  *
+  * @param   pdev  the device structure used to give information on which
+  *
+  * @return  The function always returns 0.
+  */
+
+static int __exit mxcnd_remove(struct platform_device *pdev)
+{
+	struct mtd_info *mtd = platform_get_drvdata(pdev);
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	struct nand_chip *this;
+
+	if (flash->exit)
+		flash->exit();
+
+	mxc_free_buf();
+
+	clk_disable(nfc_clk);
+	clk_put(nfc_clk);
+	platform_set_drvdata(pdev, NULL);
+
+	if (mxc_nand_data) {
+		this = &mxc_nand_data->nand;
+		kfree(this->buffers);
+		nand_release(mtd);
+		free_irq(MXC_INT_NANDFC, NULL);
+		kfree(mxc_nand_data);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * This function is called to put the NAND in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+
+static int mxcnd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mtd_info *info = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND suspend\n");
+	if (info)
+		ret = info->suspend(info);
+
+	/* Disable the NFC clock */
+	clk_disable(nfc_clk);
+
+	/* Disable the NFC clock */
+	clk_disable(nfc_clk);
+
+	return ret;
+}
+
+/*!
+ * This function is called to bring the NAND back from a low power state. Refer
+ * to the document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxcnd_resume(struct platform_device *pdev)
+{
+	struct mtd_info *info = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND resume\n");
+	/* Enable the NFC clock */
+	clk_enable(nfc_clk);
+
+	if (info) {
+		info->resume(info);
+	}
+
+	return ret;
+}
+
+#else
+#define mxcnd_suspend   NULL
+#define mxcnd_resume    NULL
+#endif				/* CONFIG_PM */
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcnd_driver = {
+	.driver = {
+		   .name = "mxc_nandv2_flash",
+		   },
+	.probe = mxcnd_probe,
+	.remove = __exit_p(mxcnd_remove),
+	.suspend = mxcnd_suspend,
+	.resume = mxcnd_resume,
+};
+
+/*!
+ * Main initialization routine
+ * @return  0 if successful; non-zero otherwise
+ */
+static int __init mxc_nd_init(void)
+{
+	/* Register the device driver structure. */
+	pr_info("MXC MTD nand Driver %s\n", DVR_VER);
+	if (platform_driver_register(&mxcnd_driver) != 0) {
+		printk(KERN_ERR "Driver register failed for mxcnd_driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/*!
+ * Clean up routine
+ */
+static void __exit mxc_nd_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxcnd_driver);
+}
+
+module_init(mxc_nd_init);
+module_exit(mxc_nd_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC NAND MTD driver Version 2-5");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/mxc_nd2.h b/drivers/mtd/nand/mxc_nd2.h
new file mode 100644
index 0000000..ee560bf
--- /dev/null
+++ b/drivers/mtd/nand/mxc_nd2.h
@@ -0,0 +1,676 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_nd2.h
+ *
+ * @brief This file contains the NAND Flash Controller register information.
+ *
+ *
+ * @ingroup NAND_MTD
+ */
+
+#ifndef __MXC_ND2_H__
+#define __MXC_ND2_H__
+
+#include <mach/hardware.h>
+
+#define IS_2K_PAGE_NAND         ((mtd->writesize / num_of_interleave) \
+						== NAND_PAGESIZE_2KB)
+#define IS_4K_PAGE_NAND         ((mtd->writesize / num_of_interleave) \
+						== NAND_PAGESIZE_4KB)
+#define IS_LARGE_PAGE_NAND      ((mtd->writesize / num_of_interleave) > 512)
+
+#define GET_NAND_OOB_SIZE	(mtd->oobsize / num_of_interleave)
+
+#define NAND_PAGESIZE_2KB	2048
+#define NAND_PAGESIZE_4KB	4096
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3
+/*
+ * For V3 NFC registers Definition
+ */
+/* AXI Bus Mapped */
+#define NFC_AXI_BASE_ADDR		NFC_BASE_ADDR_AXI
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1)	/* mx37 */
+#define MXC_INT_NANDFC			MXC_INT_EMI
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0x1E00)
+#define NFC_CONFIG1			(nfc_axi_base + 0x1E04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0x1E08)
+#define LAUNCH_NFC			(nfc_axi_base + 0x1E0c)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
+#define NFC_IPC				(nfc_ip_base + 0x18)
+#elif defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define MXC_INT_NANDFC			MXC_INT_NFC
+#define NFC_AUTO_MODE_ENABLE
+#define NFC_FLASH_CMD			(nfc_axi_base + 0x1E00)
+#define NFC_FLASH_ADDR0      		(nfc_axi_base + 0x1E04)
+#define NFC_FLASH_ADDR8			(nfc_axi_base + 0x1E24)
+#define NFC_CONFIG1         		(nfc_axi_base + 0x1E34)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0x1E38)
+#define NFC_ECC_STATUS_SUM		(nfc_axi_base + 0x1E3C)
+#define LAUNCH_NFC			(nfc_axi_base + 0x1E40)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x24)
+#define NFC_CONFIG3			(nfc_ip_base + 0x28)
+#define NFC_IPC				(nfc_ip_base + 0x2C)
+#else				/* skye */
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0xE00)
+#define NFC_CONFIG1			(nfc_axi_base + 0xE04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0xE08)
+#define LAUNCH_NFC			(nfc_axi_base + 0xE0C)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
+#define NFC_IPC				(nfc_ip_base + 0x18)
+#endif
+/*!
+ * Addresses for NFC RAM BUFFER Main area 0
+ */
+#define MAIN_AREA0        		((u16 *)(nfc_axi_base + 0x000))
+#define MAIN_AREA1        		((u16 *)(nfc_axi_base + 0x200))
+
+/*!
+ * Addresses for NFC SPARE BUFFER Spare area 0
+ */
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define SPARE_AREA0       		((u16 *)(nfc_axi_base + 0x1000))
+#define SPARE_LEN			64
+#define SPARE_COUNT			8
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#else
+#define SPARE_AREA0       		((u16 *)(nfc_axi_base + 0x800))
+#define SPARE_LEN			16
+#define SPARE_COUNT			4
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#endif
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_SPAS_WIDTH 8
+#define NFC_SPAS_SHIFT 16
+
+#define IS_4BIT_ECC \
+( \
+	cpu_is_mx51_rev(CHIP_REV_2_0) == 1 ? \
+		!((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6) : \
+		((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6) \
+)
+
+#define NFC_SET_SPAS(v)			\
+	raw_write((((raw_read(NFC_CONFIG2) & \
+	NFC_FIELD_RESET(NFC_SPAS_WIDTH, NFC_SPAS_SHIFT)) | ((v) << 16))), \
+	NFC_CONFIG2)
+
+#define NFC_SET_ECC_MODE(v)		\
+do { \
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) == 1) { \
+		if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112) \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) | \
+					NFC_ECC_MODE_4), NFC_CONFIG2); \
+		else \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) & \
+					NFC_ECC_MODE_8), NFC_CONFIG2); \
+	} else { \
+		if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112) \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) & \
+					NFC_ECC_MODE_8), NFC_CONFIG2); \
+		else \
+			raw_write(((raw_read(NFC_CONFIG2) & \
+					NFC_ECC_MODE_MASK) | \
+					NFC_ECC_MODE_4), NFC_CONFIG2); \
+	} \
+} while (0)
+
+#define WRITE_NFC_IP_REG(val,reg) 			\
+	do {	 					\
+		raw_write(NFC_IPC_CREQ, NFC_IPC);	\
+		while (!((raw_read(NFC_IPC) & NFC_IPC_ACK)>>1)) \
+			;				\
+		raw_write(val, reg);			\
+		raw_write(0, NFC_IPC);			\
+	} while (0)
+
+#else
+#define IS_4BIT_ECC			1
+#define NFC_SET_SPAS(v)
+#define NFC_SET_ECC_MODE(v)
+#define NFC_SET_NFMS(v)	(NFMS |= (v))
+
+#define WRITE_NFC_IP_REG(val,reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  \
+	REG_NFC_OPS_STAT)
+#endif
+
+#define GET_NFC_ECC_STATUS() raw_read(REG_NFC_ECC_STATUS_RESULT);
+
+/*!
+ * Set 1 to specific operation bit, rest to 0 in LAUNCH_NFC Register for
+ * Specific operation
+ */
+#define NFC_CMD            		0x1
+#define NFC_ADDR           		0x2
+#define NFC_INPUT          		0x4
+#define NFC_OUTPUT         		0x8
+#define NFC_ID             		0x10
+#define NFC_STATUS         		0x20
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_AUTO_PROG 			0x40
+#define NFC_AUTO_READ           	0x80
+#define NFC_AUTO_ERASE          	0x200
+#define NFC_COPY_BACK_0			0x400
+#define NFC_COPY_BACK_1         	0x800
+#define NFC_AUTO_STATE          	0x1000
+#endif
+
+/* Bit Definitions for NFC_IPC*/
+#define NFC_OPS_STAT			(1 << 31)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_OP_DONE			(1 << 30)
+#define NFC_RB				(1 << 28)
+#define NFC_PS_WIDTH 			2
+#define NFC_PS_SHIFT 			0
+#define NFC_PS_512	 		0
+#define NFC_PS_2K	 		1
+#define NFC_PS_4K    			2
+#else
+#define NFC_RB				(1 << 29)
+#endif
+
+#define NFC_ONE_CYCLE			(1 << 2)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2	/* mx51 */
+#define NFC_INT_MSK			(1 << 15)
+#define NFC_AUTO_PROG_DONE_MSK 		(1 << 14)
+#define NFC_NUM_ADDR_PHASE1_WIDTH   	2
+#define NFC_NUM_ADDR_PHASE1_SHIFT  	12
+
+#define NFC_NUM_ADDR_PHASE0_WIDTH 	1
+#define NFC_NUM_ADDR_PHASE0_SHIFT  	5
+
+#define NFC_ONE_LESS_PHASE1 		0
+#define NFC_TWO_LESS_PHASE1 		1
+
+#define NFC_FLASH_ADDR_SHIFT		0
+#else
+#define NFC_INT_MSK			(1 << 4)
+#define NFC_BIG				(1 << 5)
+#define NFC_FLASH_ADDR_SHIFT		16
+#endif
+
+#define NFC_UNLOCK_END_ADDR_SHIFT	16
+
+/* Bit definition for NFC_CONFIGRATION_1 */
+#define NFC_SP_EN			(1 << 0)
+#define NFC_CE				(1 << 1)
+#define NFC_RST				(1 << 2)
+#define NFC_ECC_EN			(1 << 3)
+
+#define NFC_FIELD_RESET(width, shift) (~(((1 << (width)) - 1) << (shift)))
+
+#define NFC_RBA_SHIFT       		4
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) ||	\
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define NFC_RBA_WIDTH			3
+#else
+#define NFC_RBA_WIDTH			2
+#endif
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)	/* mx51 */
+#define NFC_ITERATION_SHIFT 8
+#define NFC_ITERATION_WIDTH 4
+#define NFC_ACTIVE_CS_SHIFT 12
+#define NFC_ACTIVE_CS_WIDTH 3
+/* bit definition for CONFIGRATION3 */
+#define NFC_NO_SDMA			(1 << 20)
+#define NFC_FMP_SHIFT 			16
+#define NFC_FMP_WIDTH			4
+#define NFC_RBB_MODE			(1 << 15)
+#define NFC_NUM_OF_DEVICES_SHIFT 	12
+#define NFC_NUM_OF_DEVICES_WIDTH 	4
+#define NFC_DMA_MODE_SHIFT 		11
+#define NFC_DMA_MODE_WIDTH  		1
+#define NFC_SBB_SHIFT 			8
+#define NFC_SBB_WIDTH 			3
+#define NFC_BIG				(1 << 7)
+#define NFC_SB2R_SHIFT 			4
+#define NFC_SB2R_WIDTH			3
+#define NFC_FW_SHIFT    		3
+#define NFC_FW_WIDTH 			1
+#define NFC_TOO				(1 << 2)
+#define NFC_ADD_OP_SHIFT 		0
+#define NFC_ADD_OP_WIDTH		2
+#define NFC_FW_8 			1
+#define NFC_FW_16			0
+#define NFC_ST_CMD_SHITF		24
+#define NFC_ST_CMD_WIDTH		8
+#endif
+
+#define NFC_PPB_32			(0 << 7)
+#define NFC_PPB_64			(1 << 7)
+#define NFC_PPB_128			(2 << 7)
+#define NFC_PPB_256			(3 << 7)
+#define NFC_PPB_RESET			(~(3 << 7))
+
+#define NFC_BLS_LOCKED			(0 << 16)
+#define NFC_BLS_LOCKED_DEFAULT		(1 << 16)
+#define NFC_BLS_UNLCOKED		(2 << 16)
+#define NFC_BLS_RESET			(~(3 << 16))
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
+#define NFC_WPC_RESET			(~(7))
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_1) || \
+    defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_ECC_MODE_4    		(1 << 6)
+#define NFC_ECC_MODE_8			(~(1 << 6))
+#define NFC_ECC_MODE_MASK 		(~(1 << 6))
+#define NFC_SPAS_16			8
+#define NFC_SPAS_64		 	32
+#define NFC_SPAS_128			64
+#define NFC_SPAS_112			56
+#define NFC_SPAS_218		 	109
+#define NFC_IPC_CREQ			(1 << 0)
+#define NFC_IPC_ACK			(1 << 1)
+#endif
+
+#define REG_NFC_OPS_STAT		NFC_IPC
+#define REG_NFC_INTRRUPT		NFC_CONFIG2
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR0
+#define REG_NFC_FLASH_CMD		NFC_FLASH_CMD
+#else
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR_CMD
+#define REG_NFC_FLASH_CMD		NFC_FLASH_ADDR_CMD
+#endif
+#define REG_NFC_OPS			LAUNCH_NFC
+#define REG_NFC_SET_RBA			NFC_CONFIG1
+#define REG_NFC_RB			NFC_IPC
+#define REG_NFC_ECC_EN			NFC_CONFIG2
+#define REG_NFC_ECC_STATUS_RESULT	NFC_ECC_STATUS_RESULT
+#define REG_NFC_CE			NFC_CONFIG1
+#define REG_NFC_RST			NFC_CONFIG1
+#define REG_NFC_PPB			NFC_CONFIG2
+#define REG_NFC_SP_EN			NFC_CONFIG1
+#define REG_NFC_BLS			NFC_WRPROT
+#define REG_UNLOCK_BLK_ADD0		NFC_WRPROT_UNLOCK_BLK_ADD0
+#define REG_UNLOCK_BLK_ADD1		NFC_WRPROT_UNLOCK_BLK_ADD1
+#define REG_UNLOCK_BLK_ADD2		NFC_WRPROT_UNLOCK_BLK_ADD2
+#define REG_UNLOCK_BLK_ADD3		NFC_WRPROT_UNLOCK_BLK_ADD3
+#define REG_NFC_WPC			NFC_WRPROT
+#define REG_NFC_ONE_CYCLE		NFC_CONFIG2
+
+/* NFC V3 Specific MACRO functions definitions */
+#define raw_write(v, a)		__raw_writel(v, a)
+#define raw_read(a)		__raw_readl(a)
+
+/* Explcit ack ops status (if any), before issue of any command  */
+#define ACK_OPS	\
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT), \
+	REG_NFC_OPS_STAT);
+
+/* Set RBA buffer id*/
+#define NFC_SET_RBA(val)       \
+	raw_write((raw_read(REG_NFC_SET_RBA) & \
+	(NFC_FIELD_RESET(NFC_RBA_WIDTH, NFC_RBA_SHIFT))) | \
+	((val) << NFC_RBA_SHIFT), REG_NFC_SET_RBA);
+
+#define NFC_SET_PS(val)       \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_PS_WIDTH, NFC_PS_SHIFT))) | \
+	((val) << NFC_PS_SHIFT), NFC_CONFIG2);
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_2
+#define UNLOCK_ADDR(start_addr,end_addr)     \
+{ \
+	int i = 0; \
+	for (; i < NAND_MAX_CHIPS; i++)  \
+	raw_write(start_addr | \
+	(end_addr << NFC_UNLOCK_END_ADDR_SHIFT), \
+	REG_UNLOCK_BLK_ADD0 + (i << 2)); \
+}
+#define NFC_SET_NFC_ACTIVE_CS(val) \
+	raw_write((raw_read(NFC_CONFIG1) & \
+	(NFC_FIELD_RESET(NFC_ACTIVE_CS_WIDTH, NFC_ACTIVE_CS_SHIFT))) | \
+	((val) << NFC_ACTIVE_CS_SHIFT), NFC_CONFIG1);
+
+#define NFC_GET_MAXCHIP_SP() 		8
+
+#else
+#define UNLOCK_ADDR(start_addr,end_addr)     \
+	raw_write(start_addr | \
+	(end_addr << NFC_UNLOCK_END_ADDR_SHIFT), REG_UNLOCK_BLK_ADD0);
+
+#define NFC_SET_NFC_ACTIVE_CS(val)
+#define NFC_GET_MAXCHIP_SP() 		1
+#endif
+
+#define NFC_SET_BLS(val) ((raw_read(REG_NFC_BLS) & NFC_BLS_RESET) | val)
+#define NFC_SET_WPC(val) ((raw_read(REG_NFC_WPC) & NFC_WPC_RESET) | val)
+#define CHECK_NFC_RB    (raw_read(REG_NFC_RB) & NFC_RB)
+
+#if defined(CONFIG_ARCH_MXC_HAS_NFC_V3_2)
+#define NFC_SET_NFC_NUM_ADDR_PHASE1(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_NUM_ADDR_PHASE1_WIDTH, \
+	NFC_NUM_ADDR_PHASE1_SHIFT))) | \
+	((val) << NFC_NUM_ADDR_PHASE1_SHIFT), NFC_CONFIG2);
+
+#define NFC_SET_NFC_NUM_ADDR_PHASE0(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_NUM_ADDR_PHASE0_WIDTH, \
+	NFC_NUM_ADDR_PHASE0_SHIFT))) | \
+	((val) << NFC_NUM_ADDR_PHASE0_SHIFT), NFC_CONFIG2);
+
+#define NFC_SET_NFC_ITERATION(val) \
+	raw_write((raw_read(NFC_CONFIG1) & \
+	(NFC_FIELD_RESET(NFC_ITERATION_WIDTH, NFC_ITERATION_SHIFT))) | \
+	((val) << NFC_ITERATION_SHIFT), NFC_CONFIG1);
+
+#define NFC_SET_FW(val) \
+	raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_FW_WIDTH, NFC_FW_SHIFT))) | \
+	((val) << NFC_FW_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_NUM_OF_DEVICE(val) \
+	raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_NUM_OF_DEVICES_WIDTH, \
+	NFC_NUM_OF_DEVICES_SHIFT))) | \
+	((val) << NFC_NUM_OF_DEVICES_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_ADD_OP_MODE(val) \
+	 raw_write((raw_read(NFC_CONFIG3) & \
+	(NFC_FIELD_RESET(NFC_ADD_OP_WIDTH, NFC_ADD_OP_SHIFT))) | \
+	((val) << NFC_ADD_OP_SHIFT), NFC_CONFIG3);
+
+#define NFC_SET_ADD_CS_MODE(val) \
+{ \
+	NFC_SET_ADD_OP_MODE(val); \
+	NFC_SET_NUM_OF_DEVICE(this->numchips - 1); \
+}
+
+#define NFC_SET_ST_CMD(val) \
+	raw_write((raw_read(NFC_CONFIG2) & \
+	(NFC_FIELD_RESET(NFC_ST_CMD_WIDTH, \
+	NFC_ST_CMD_SHITF))) | \
+	((val) << NFC_ST_CMD_SHITF), NFC_CONFIG2);
+
+#define NFMS_NF_DWIDTH 0
+#define NFMS_NF_PG_SZ  1
+#define NFC_CMD_1_SHIFT 8
+
+#define NUM_OF_ADDR_CYCLE (fls(g_page_mask) >> 3)
+
+/*should set the fw,ps,spas,ppb*/
+#define NFC_SET_NFMS(v)	\
+do {	\
+	NFC_SET_FW(NFC_FW_8);	\
+	if (((v) & (1 << NFMS_NF_DWIDTH)))	\
+		NFC_SET_FW(NFC_FW_16);	\
+	if (((v) & (1 << NFMS_NF_PG_SZ))) {	\
+		if (IS_2K_PAGE_NAND) {	\
+			NFC_SET_PS(NFC_PS_2K);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_TWO_LESS_PHASE1); \
+		} else if (IS_4K_PAGE_NAND) {       \
+			NFC_SET_PS(NFC_PS_4K);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_TWO_LESS_PHASE1); \
+		} else {	\
+			NFC_SET_PS(NFC_PS_512);	\
+			NFC_SET_NFC_NUM_ADDR_PHASE1(NUM_OF_ADDR_CYCLE - 1); \
+			NFC_SET_NFC_NUM_ADDR_PHASE0(NFC_ONE_LESS_PHASE1); \
+		}	\
+		NFC_SET_ADD_CS_MODE(1); \
+		NFC_SET_SPAS(GET_NAND_OOB_SIZE >> 1);	\
+		NFC_SET_ECC_MODE(GET_NAND_OOB_SIZE >> 1); \
+		NFC_SET_ST_CMD(0x70); \
+		raw_write(raw_read(NFC_CONFIG3) | 1 << 20, NFC_CONFIG3); \
+	} \
+} while (0)
+#endif
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define NFC_SET_NFMS(v)
+#endif
+
+#define READ_PAGE()	send_read_page(0)
+#define PROG_PAGE() 	send_prog_page(0)
+
+#elif CONFIG_ARCH_MXC_HAS_NFC_V2
+
+/*
+ * For V1/V2 NFC registers Definition
+ */
+
+#define NFC_AXI_BASE_ADDR      		0x00
+/*
+ * Addresses for NFC registers
+ */
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_REG_BASE			(nfc_ip_base + 0x1000)
+#else
+#define NFC_REG_BASE			nfc_ip_base
+#endif
+#define NFC_BUF_SIZE            	(NFC_REG_BASE + 0xE00)
+#define NFC_BUF_ADDR            	(NFC_REG_BASE + 0xE04)
+#define NFC_FLASH_ADDR          	(NFC_REG_BASE + 0xE06)
+#define NFC_FLASH_CMD           	(NFC_REG_BASE + 0xE08)
+#define NFC_CONFIG              	(NFC_REG_BASE + 0xE0A)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_ECC_STATUS_RESULT		(NFC_REG_BASE + 0xE0C)
+#define NFC_ECC_STATUS_RESULT_1		(NFC_REG_BASE + 0xE0C)
+#define NFC_ECC_STATUS_RESULT_2		(NFC_REG_BASE + 0xE0E)
+#define NFC_SPAS			(NFC_REG_BASE + 0xE10)
+#else
+#define NFC_ECC_STATUS_RESULT   	(NFC_REG_BASE + 0xE0C)
+#define NFC_RSLTMAIN_AREA       	(NFC_REG_BASE + 0xE0E)
+#define NFC_RSLTSPARE_AREA      	(NFC_REG_BASE + 0xE10)
+#endif
+#define NFC_WRPROT              	(NFC_REG_BASE + 0xE12)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_UNLOCKSTART_BLKADDR  	(NFC_REG_BASE + 0xE20)
+#define NFC_UNLOCKEND_BLKADDR    	(NFC_REG_BASE + 0xE22)
+#define NFC_UNLOCKSTART_BLKADDR1 	(NFC_REG_BASE + 0xE24)
+#define NFC_UNLOCKEND_BLKADDR1   	(NFC_REG_BASE + 0xE26)
+#define NFC_UNLOCKSTART_BLKADDR2 	(NFC_REG_BASE + 0xE28)
+#define NFC_UNLOCKEND_BLKADDR2   	(NFC_REG_BASE + 0xE2A)
+#define NFC_UNLOCKSTART_BLKADDR3 	(NFC_REG_BASE + 0xE2C)
+#define NFC_UNLOCKEND_BLKADDR3   	(NFC_REG_BASE + 0xE2E)
+#else
+#define NFC_UNLOCKSTART_BLKADDR  	(NFC_REG_BASE + 0xE14)
+#define NFC_UNLOCKEND_BLKADDR    	(NFC_REG_BASE + 0xE16)
+#endif
+#define NFC_NF_WRPRST            	(NFC_REG_BASE + 0xE18)
+#define NFC_CONFIG1              	(NFC_REG_BASE + 0xE1A)
+#define NFC_CONFIG2              	(NFC_REG_BASE + 0xE1C)
+
+/*!
+ * Addresses for NFC RAM BUFFER Main area 0
+ */
+#define MAIN_AREA0      		(u16 *)(nfc_ip_base + 0x000)
+#define MAIN_AREA1      		(u16 *)(nfc_ip_base + 0x200)
+
+/*!
+ * Addresses for NFC SPARE BUFFER Spare area 0
+ */
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define SPARE_AREA0     		(u16 *)(nfc_ip_base + 0x1000)
+#define SPARE_LEN			64
+#define SPARE_COUNT			8
+#else
+#define SPARE_AREA0     		(u16 *)(nfc_ip_base + 0x800)
+#define SPARE_LEN       		16
+#define SPARE_COUNT     		4
+#endif
+#define SPARE_SIZE      		(SPARE_LEN * SPARE_COUNT)
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define REG_NFC_ECC_MODE NFC_CONFIG1
+#define SPAS_SHIFT		(0)
+#define REG_NFC_SPAS NFC_SPAS
+#define SPAS_MASK	(0xFF00)
+#define IS_4BIT_ECC			\
+	((raw_read(REG_NFC_ECC_MODE) & NFC_ECC_MODE_4) >> 0)
+
+#define NFC_SET_SPAS(v)			\
+	raw_write(((raw_read(REG_NFC_SPAS) & SPAS_MASK) | ((v<<SPAS_SHIFT))), \
+								REG_NFC_SPAS)
+
+#define NFC_SET_ECC_MODE(v) 		 \
+do {	\
+	if ((v) == NFC_SPAS_218 || (v) == NFC_SPAS_112)  {	\
+		raw_write((raw_read(REG_NFC_ECC_MODE) & NFC_ECC_MODE_8), \
+							REG_NFC_ECC_MODE); \
+	} else {	\
+		raw_write((raw_read(REG_NFC_ECC_MODE) | NFC_ECC_MODE_4), \
+							REG_NFC_ECC_MODE); \
+	}	\
+} while (0)
+
+#define GET_ECC_STATUS()  __raw_readl(REG_NFC_ECC_STATUS_RESULT);
+#define NFC_SET_NFMS(v)	\
+do {	\
+	(NFMS |= (v));	\
+	if (((v) & (1 << NFMS_NF_PG_SZ))) {	\
+		NFC_SET_SPAS(GET_NAND_OOB_SIZE >> 1);	\
+		NFC_SET_ECC_MODE(GET_NAND_OOB_SIZE >> 1); \
+	} \
+} while (0)
+#else
+#define IS_4BIT_ECC			(1)
+#define NFC_SET_SPAS(v)
+#define NFC_SET_ECC_MODE(v)
+#define GET_ECC_STATUS()  raw_read(REG_NFC_ECC_STATUS_RESULT);
+#define NFC_SET_NFMS(v)     (NFMS |= (v))
+#endif
+
+#define WRITE_NFC_IP_REG(val,reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  \
+	REG_NFC_OPS_STAT)
+
+#define GET_NFC_ECC_STATUS() raw_read(REG_NFC_ECC_STATUS_RESULT);
+
+/*!
+ * Set INT to 0, Set 1 to specific operation bit, rest to 0 in LAUNCH_NFC Register for
+ * Specific operation
+ */
+#define NFC_CMD            		0x1
+#define NFC_ADDR           		0x2
+#define NFC_INPUT          		0x4
+#define NFC_OUTPUT         		0x8
+#define NFC_ID             		0x10
+#define NFC_STATUS         		0x20
+
+/* Bit Definitions */
+#define NFC_OPS_STAT			(1 << 15)
+#define NFC_SP_EN           		(1 << 2)
+#define NFC_ECC_EN          		(1 << 3)
+#define NFC_INT_MSK         		(1 << 4)
+#define NFC_BIG             		(1 << 5)
+#define NFC_RST             		(1 << 6)
+#define NFC_CE              		(1 << 7)
+#define NFC_ONE_CYCLE       		(1 << 8)
+#define NFC_BLS_LOCKED			0
+#define NFC_BLS_LOCKED_DEFAULT		1
+#define NFC_BLS_UNLCOKED		2
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
+#define NFC_FLASH_ADDR_SHIFT 		0
+#define NFC_UNLOCK_END_ADDR_SHIFT	0
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define NFC_ECC_MODE_4    		 (1<<0)
+#define NFC_ECC_MODE_8			 (~(1<<0))
+#define NFC_SPAS_16			 8
+#define NFC_SPAS_64			 32
+#define NFC_SPAS_112			 56
+#define NFC_SPAS_128			 64
+#define NFC_SPAS_218			 109
+#endif
+/* NFC Register Mapping */
+#define REG_NFC_OPS_STAT		NFC_CONFIG2
+#define REG_NFC_INTRRUPT		NFC_CONFIG1
+#define REG_NFC_FLASH_ADDR		NFC_FLASH_ADDR
+#define REG_NFC_FLASH_CMD		NFC_FLASH_CMD
+#define REG_NFC_OPS			NFC_CONFIG2
+#define REG_NFC_SET_RBA			NFC_BUF_ADDR
+#define REG_NFC_ECC_EN			NFC_CONFIG1
+#define REG_NFC_ECC_STATUS_RESULT  	NFC_ECC_STATUS_RESULT
+#define REG_NFC_CE			NFC_CONFIG1
+#define REG_NFC_SP_EN			NFC_CONFIG1
+#define REG_NFC_BLS			NFC_CONFIG
+#define REG_NFC_WPC			NFC_WRPROT
+#define REG_START_BLKADDR      		NFC_UNLOCKSTART_BLKADDR
+#define REG_END_BLKADDR        		NFC_UNLOCKEND_BLKADDR
+#define REG_NFC_RST			NFC_CONFIG1
+#define REG_NFC_ONE_CYCLE		NFC_CONFIG1
+
+/* NFC V1/V2 Specific MACRO functions definitions */
+
+#define raw_write(v, a)                  __raw_writew(v, a)
+#define raw_read(a)                     __raw_readw(a)
+
+#define NFC_SET_BLS(val)  		val
+
+#define UNLOCK_ADDR(start_addr, end_addr)		\
+{							\
+	raw_write(start_addr, REG_START_BLKADDR);	\
+	raw_write(end_addr, REG_END_BLKADDR);		\
+}
+
+#define NFC_SET_NFC_ACTIVE_CS(val)
+#define NFC_GET_MAXCHIP_SP() 		1
+#define NFC_SET_WPC(val)                val
+
+/* NULL Definitions */
+#define ACK_OPS
+#define NFC_SET_RBA(val) raw_write(val, REG_NFC_SET_RBA);
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V2_1
+#define READ_PAGE()	send_read_page(0)
+#define PROG_PAGE() 	send_prog_page(0)
+#else
+#define READ_PAGE()   \
+do {                     \
+	send_read_page(0);  \
+	send_read_page(1);  \
+	send_read_page(2);  \
+	send_read_page(3);  \
+} while (0)
+
+#define PROG_PAGE()   \
+do {                     \
+	send_prog_page(0);  \
+	send_prog_page(1);  \
+	send_prog_page(2);  \
+	send_prog_page(3);  \
+} while (0)
+#endif
+#define CHECK_NFC_RB            1
+
+#endif
+
+#endif				/* __MXC_ND2_H__ */
-- 
1.5.5.1

