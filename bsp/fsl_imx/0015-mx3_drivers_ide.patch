From c0c5a621cbaa2e8cfc560d0663a1d41a59411d6a Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Mon, 27 Oct 2008 17:23:02 +0800
Subject: [PATCH] mx3_drivers_ide

MX3 ide controller driver.
rewrite IDE DMA functions for adapting to new IDE
DMA interface.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/ide/Kconfig       |    7 +
 drivers/ide/arm/Makefile  |    1 +
 drivers/ide/arm/mxc_ide.c | 1324 +++++++++++++++++++++++++++++++++++++++++++++
 include/linux/ide.h       |    2 +-
 4 files changed, 1333 insertions(+), 1 deletions(-)
 create mode 100644 drivers/ide/arm/mxc_ide.c

diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 052879a..173684c 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -828,6 +828,13 @@ config BLK_DEV_IDE_RAPIDE
 	  Say Y here if you want to support the Yellowstone RapIDE controller
 	  manufactured for use with Acorn computers.
 
+config BLK_DEV_IDE_MXC
+    tristate "Freescale MXC IDE support"
+    depends on ARM && ARCH_MX3
+    help
+        Say Y here if you want to support the IDE controller on the
+        Freescale iMX3 processor.
+
 config IDE_H8300
 	tristate "H8300 IDE support"
 	depends on H8300
diff --git a/drivers/ide/arm/Makefile b/drivers/ide/arm/Makefile
index 5bc2605..61d42ae 100644
--- a/drivers/ide/arm/Makefile
+++ b/drivers/ide/arm/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_BLK_DEV_IDE_ICSIDE)	+= icside.o
 obj-$(CONFIG_BLK_DEV_IDE_RAPIDE)	+= rapide.o
 obj-$(CONFIG_BLK_DEV_PALMCHIP_BK3710)	+= palm_bk3710.o
+obj-$(CONFIG_BLK_DEV_IDE_MXC)           += mxc_ide.o
 
 ifeq ($(CONFIG_IDE_ARM), m)
 	obj-m += ide_arm.o
diff --git a/drivers/ide/arm/mxc_ide.c b/drivers/ide/arm/mxc_ide.c
new file mode 100644
index 0000000..2f04351
--- /dev/null
+++ b/drivers/ide/arm/mxc_ide.c
@@ -0,0 +1,1324 @@
+/*
+ * linux/drivers/ide/arm/mxc_ide.c
+ *
+ * Based on Simtec BAST IDE driver
+ * Copyright (c) 2003-2004 Simtec Electronics
+ *  Ben Dooks <ben@simtec.co.uk>
+ *
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*!
+ * @file mxc_ide.c
+ *
+ * @brief ATA driver
+ *
+ * @ingroup ATA
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/ide.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/regulator/regulator.h>
+
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <asm/plat-mxc/mxc_ide.h>
+
+static int mxc_ide_config_drive(ide_drive_t *drive, u8 xfer_mode);
+static void mxc_ide_dma_callback(void *arg, int error, unsigned int count);
+
+#define DRV_NAME	"mxc_ide"
+
+#ifdef DEBUG
+#define dbg(fmt, args...)	printk(KERN_DEBUG "%s: " fmt "\n", \
+						__func__, ## args)
+#else
+#define dbg(fmt, args...)	do {} while (0)
+#endif
+
+/*
+ * This structure contains the timing parameters for
+ * ATA bus timing in the 5 PIO modes.  The timings
+ * are in nanoseconds, and are converted to clock
+ * cycles before being stored in the ATA controller
+ * timing registers.
+ */
+static struct {
+	short t0, t1, t2_8, t2_16, t2i, t4, t9, tA;
+} pio_specs[] = {
+	[0] = {
+		.t0 = 600, .t1 = 70, .t2_8 = 290, .t2_16 = 165, .t2i = 0, .t4 =
+		30, .t9 = 20, .tA = 50},
+	[1] = {
+		.t0 = 383, .t1 = 50, .t2_8 = 290, .t2_16 = 125, .t2i = 0, .t4 =
+		20, .t9 = 15, .tA = 50},
+	[2] = {
+		.t0 = 240, .t1 = 30, .t2_8 = 290, .t2_16 = 100, .t2i = 0, .t4 =
+		15, .t9 = 10, .tA = 50},
+	[3] = {
+		.t0 = 180, .t1 = 30, .t2_8 = 80, .t2_16 = 80, .t2i = 0, .t4 =
+		10, .t9 = 10, .tA = 50},
+	[4] = {
+		.t0 = 120, .t1 = 25, .t2_8 = 70, .t2_16 = 70, .t2i = 0, .t4 =
+		10, .t9 = 10, .tA = 50}
+};
+
+#define NR_PIO_SPECS (sizeof pio_specs / sizeof pio_specs[0])
+
+/*
+ * This structure contains the timing parameters for
+ * ATA bus timing in the 3 MDMA modes.  The timings
+ * are in nanoseconds, and are converted to clock
+ * cycles before being stored in the ATA controller
+ * timing registers.
+ */
+static struct {
+	short t0M, tD, tH, tJ, tKW, tM, tN, tJNH;
+} mdma_specs[] = {
+	[0] = {
+		.t0M = 480, .tD = 215, .tH = 20, .tJ = 20,
+		.tKW = 215, .tM = 50, .tN =	15, .tJNH = 20},
+	[1] = {
+		.t0M = 150, .tD = 80, .tH = 15, .tJ = 5,
+		.tKW = 50, .tM = 30, .tN = 10, .tJNH = 15},
+	[2] = {
+		.t0M = 120, .tD = 70, .tH = 10, .tJ = 5,
+		.tKW = 25, .tM = 25, .tN = 10, .tJNH = 10}
+};
+
+#define NR_MDMA_SPECS (sizeof mdma_specs / sizeof mdma_specs[0])
+
+/*
+ * This structure contains the timing parameters for
+ * ATA bus timing in the 6 UDMA modes.  The timings
+ * are in nanoseconds, and are converted to clock
+ * cycles before being stored in the ATA controller
+ * timing registers.
+ */
+static struct {
+	short t2CYC, tCYC, tDS, tDH, tDVS, tDVH, tCVS, tCVH, tFS_min, tLI_max,
+		  tMLI, tAZ, tZAH, tENV_min, tSR, tRFS, tRP, tACK, tSS, tDZFS;
+} udma_specs[] = {
+	[0] = {
+	.t2CYC = 235, .tCYC = 114, .tDS = 15, .tDH = 5, .tDVS = 70, .tDVH =
+	6, .tCVS = 70, .tCVH = 6, .tFS_min = 0, .tLI_max =
+	100, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 50, .tRFS = 75, .tRP = 160, .tACK = 20, .tSS =
+	50, .tDZFS = 80},
+	[1] = {
+	.t2CYC = 156, .tCYC = 75, .tDS = 10, .tDH = 5, .tDVS = 48, .tDVH =
+	6, .tCVS = 48, .tCVH = 6, .tFS_min = 0, .tLI_max =
+	100, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 30, .tRFS = 70, .tRP = 125, .tACK = 20, .tSS =
+	50, .tDZFS = 63},
+	[2] = {
+	.t2CYC = 117, .tCYC = 55, .tDS = 7, .tDH = 5, .tDVS = 34, .tDVH =
+	6, .tCVS = 34, .tCVH = 6, .tFS_min = 0, .tLI_max =
+	100, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 20, .tRFS = 60, .tRP = 100, .tACK = 20, .tSS =
+	50, .tDZFS = 47},
+	[3] = {
+	.t2CYC = 86, .tCYC = 39, .tDS = 7, .tDH = 5, .tDVS = 20, .tDVH =
+	6, .tCVS = 20, .tCVH = 6, .tFS_min = 0, .tLI_max =
+	100, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 20, .tRFS = 60, .tRP = 100, .tACK = 20, .tSS =
+	50, .tDZFS = 35},
+	[4] = {
+	.t2CYC = 57, .tCYC = 25, .tDS = 5, .tDH = 5, .tDVS = 7, .tDVH =
+	6, .tCVS = 7, .tCVH = 6, .tFS_min = 0, .tLI_max =
+	100, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 50, .tRFS = 60, .tRP = 100, .tACK = 20, .tSS =
+	50, .tDZFS = 25},
+	[5] = {
+	.t2CYC = 38, .tCYC = 17, .tDS = 4, .tDH = 5, .tDVS = 5, .tDVH =
+	6, .tCVS = 10, .tCVH = 10, .tFS_min = 0, .tLI_max =
+	75, .tMLI = 20, .tAZ = 10, .tZAH = 20, .tENV_min =
+	20, .tSR = 20, .tRFS = 50, .tRP = 85, .tACK = 20, .tSS =
+	50, .tDZFS = 40}
+};
+
+#define NR_UDMA_SPECS (sizeof udma_specs / sizeof udma_specs[0])
+
+
+/*!
+ * Calculate values for the ATA bus timing registers and store
+ * them into the hardware.
+ * @param		base		Specifies the ATA controler access base address
+ *
+ * @param       mode        Selects PIO, MDMA or UDMA modes
+ *
+ * @param       speed       Specifies the sub-mode number
+ *
+ * @return      EINVAL      speed out of range, or illegal mode
+ */
+static int set_ata_bus_timing(mxc_ide_private_t *priv,
+		int speed, enum ata_mode mode)
+{
+	unsigned int base = (unsigned int)priv->base;
+	/* get the bus clock cycle time, in ns */
+	int T;
+	mxc_ide_time_cfg_t cfg0, cfg1, cfg2, cfg3, cfg4, cfg5;
+	/* every mode gets the same t_off and t_on */
+
+	T = 1 * 1000 * 1000 * 1000 / (clk_get_rate(priv->clk));
+
+	GET_TIME_CFG(&cfg0, base + MXC_IDE_TIME_OFF);
+	cfg0.bytes.field1 = 3;
+	cfg0.bytes.field2 = 3;
+	SET_TIME_CFG(&cfg0, 3, base + MXC_IDE_TIME_OFF);
+
+	switch (mode) {
+	case PIO:
+			if (speed < 0 || speed >= NR_PIO_SPECS)
+				return -EINVAL;
+
+			cfg0.bytes.field3 = (pio_specs[speed].t1 + T) / T;
+			cfg0.bytes.field4 = (pio_specs[speed].t2_8 + T) / T;
+
+			cfg1.bytes.field1 = (pio_specs[speed].t2_8 + T) / T;
+			cfg1.bytes.field2 = (pio_specs[speed].tA + T) / T + 2;
+			cfg1.bytes.field3 = 1;
+			cfg1.bytes.field4 = (pio_specs[speed].t4 + T) / T;
+
+			GET_TIME_CFG(&cfg2, base + MXC_IDE_TIME_9);
+			cfg2.bytes.field1 = (pio_specs[speed].t9 + T) / T;
+
+			SET_TIME_CFG(&cfg0, 0x0C, base + MXC_IDE_TIME_OFF);
+			SET_TIME_CFG(&cfg1, 0x0F, base + MXC_IDE_TIME_2r);
+			SET_TIME_CFG(&cfg2, 0x01, base + MXC_IDE_TIME_9);
+			break;
+	case MDMA:
+			if (speed < 0 || speed >= NR_MDMA_SPECS)
+				return -EINVAL;
+
+			GET_TIME_CFG(&cfg2, base + MXC_IDE_TIME_9);
+			GET_TIME_CFG(&cfg3, base + MXC_IDE_TIME_K);
+
+			cfg2.bytes.field2 = (mdma_specs[speed].tM + T) / T;
+			cfg2.bytes.field3 = (mdma_specs[speed].tJNH + T) / T;
+			cfg2.bytes.field4 = (mdma_specs[speed].tD + T) / T;
+
+			cfg3.bytes.field1 = (mdma_specs[speed].tKW + T) / T;
+
+			SET_TIME_CFG(&cfg2, 0x0E, base + MXC_IDE_TIME_9);
+			SET_TIME_CFG(&cfg3, 0x01, base + MXC_IDE_TIME_K);
+			break;
+	case UDMA:
+			if (speed < 0 || speed >= NR_UDMA_SPECS)
+				return -EINVAL;
+
+			GET_TIME_CFG(&cfg3, base + MXC_IDE_TIME_K);
+
+			cfg3.bytes.field2 = (udma_specs[speed].tACK + T) / T;
+			cfg3.bytes.field3 =
+				(udma_specs[speed].tENV_min + T) / T;
+			cfg3.bytes.field4 =
+				(udma_specs[speed].tRP + T) / T + 2;
+
+			cfg4.bytes.field1 = (udma_specs[speed].tZAH + T) / T;
+			cfg4.bytes.field2 = (udma_specs[speed].tMLI + T) / T;
+			cfg4.bytes.field3 =
+				(udma_specs[speed].tDVH + T) / T + 1;
+			cfg4.bytes.field4 = (udma_specs[speed].tDZFS + T) / T;
+
+			cfg5.bytes.field1 = (udma_specs[speed].tDVS + T) / T;
+			cfg5.bytes.field2 = (udma_specs[speed].tCVH + T) / T;
+			cfg5.bytes.field3 = (udma_specs[speed].tSS + T) / T;
+			cfg5.bytes.field4 = (udma_specs[speed].tCYC + T) / T;
+
+			SET_TIME_CFG(&cfg3, 0x0E, base + MXC_IDE_TIME_K);
+			SET_TIME_CFG(&cfg4, 0x0F, base + MXC_IDE_TIME_ZAH);
+			SET_TIME_CFG(&cfg5, 0x0F, base + MXC_IDE_TIME_DVS);
+			break;
+	default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void mxc_ide_set_pio_mode(ide_drive_t *drive, const u8 pio)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)
+		HWIF(drive)->host->host_priv;
+	switch (pio) {
+	case XFER_PIO_4:
+	case XFER_PIO_3:
+	case XFER_PIO_2:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+			set_ata_bus_timing(priv, pio - XFER_PIO_0, PIO);
+			break;
+	}
+}
+
+static void mxc_ide_set_dma_mode(ide_drive_t *drive, const u8 speed)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)
+		HWIF(drive)->host->host_priv;
+
+	switch (speed) {
+	case XFER_UDMA_7:
+	case XFER_UDMA_6:
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+			priv->ultra = 1;
+			set_ata_bus_timing(priv, speed - XFER_UDMA_0, UDMA);
+			break;
+	case XFER_MW_DMA_2:
+	case XFER_MW_DMA_1:
+	case XFER_MW_DMA_0:
+			priv->ultra = 0;
+			set_ata_bus_timing(priv, speed - XFER_MW_DMA_0, MDMA);
+			break;
+	}
+}
+
+/*!
+ * Placeholder for code to make any hardware tweaks
+ * necessary to select a drive.  Currently we are
+ * not aware of any.
+ */
+static void mxc_ide_selectproc(ide_drive_t *drive)
+{
+	return;
+}
+
+/*!
+ * Called by the IDE layer when something goes wrong
+ *
+ * @param       drive       Specifies the drive
+ *
+ */
+static void mxc_ide_resetproc(ide_drive_t *drive)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)
+		HWIF(drive)->host->host_priv;
+	printk(KERN_INFO "%s: resetting ATA controller\n", __func__);
+
+	ATA_RAW_WRITE(0x00, priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B, priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+	dbg("done");
+}
+
+
+/*!
+ * Masks drive interrupts temporarily at the hardware level
+ *
+ * @param       drive       Specifies the drive
+ *
+ * @param       mask        1 = disable interrupts, 0 = re-enable
+ *
+ */
+static void mxc_ide_maskproc(ide_drive_t *drive, int mask)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)
+		HWIF(drive)->host->host_priv;
+	BUG_ON(!priv);
+
+	if (mask)
+		ATA_RAW_WRITE(0, priv->base + MXC_IDE_INTR_ENABLE);
+	else {
+		dbg("enable irq %d\n", priv->enable);
+		ATA_RAW_WRITE(priv->enable, priv->base + MXC_IDE_INTR_ENABLE);
+	}
+	dbg("done");
+}
+
+static const struct ide_port_ops mxc_ide_port_ops = {
+	.set_pio_mode	=		mxc_ide_set_pio_mode,
+	.set_dma_mode	=		mxc_ide_set_dma_mode,
+	.selectproc		=		mxc_ide_selectproc,
+	.resetproc		=		mxc_ide_resetproc,
+	.maskproc		=		mxc_ide_maskproc,
+};
+
+
+/*!
+ * Helper routine to configure drive speed
+ *
+ * @param       drive       Specifies the drive
+ *
+ * @param       xfer_mode   Specifies the desired transfer mode
+ *
+ * @return      0 = success, non-zero otherwise
+ */
+static int mxc_ide_config_drive(ide_drive_t *drive, u8 xfer_mode)
+{
+	int err;
+	ide_hwif_t *hwif = HWIF(drive);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)hwif->host->host_priv;
+	u8 prev = priv->enable;
+	unsigned int base = (unsigned int)priv->base;
+
+	hwif->port_ops->set_dma_mode(drive, xfer_mode);
+
+	/*
+	 * Work around an ADS hardware bug:
+	 *
+	 * OK, ide_config_drive_speed() is the right thing to call but it's
+	 * going to leave an interrupt pending.  We have to jump through hoops
+	 * because the ADS board doesn't correctly terminate INTRQ.  Instead
+	 * of pulling it low, it pulls it high (asserted), so when the drive
+	 * tri-states it, the MX31 sees it as an interrupt.  So we'll disable
+	 * the hardware interrupt here, and restore it a bit later, after we've
+	 * selected the drive again and let it drive INTRQ low for a bit.
+	 *
+	 * On later ADS boards, when presumably the correct INTRQ termination
+	 * is in place, these extra hoops won't be necessary, but they
+	 * shouldn't hurt, either.
+	 */
+	priv->enable = 0;
+	ATA_RAW_WRITE(0, base + MXC_IDE_INTR_ENABLE);
+
+	err = ide_config_drive_speed(drive, xfer_mode);
+
+	if (ATA_RAW_READ(base + MXC_IDE_INTR_PENDING) &
+			(MXC_IDE_INTR_ATA_INTRQ2 | MXC_IDE_INTR_ATA_INTRQ1)) {
+		/*
+		 * OK, the 'bad thing' is happening, so we'll clear nIEN to
+		 * get the drive to drive INTRQ, then we'll read status to
+		 * clear any pending interrupt.  This sequence gets us by
+		 * the spurious and stuck interrupt we see otherwise.
+		 */
+		SELECT_DRIVE(drive);
+		udelay(2);
+		ATA_RAW_WRITE(0, hwif->io_ports.ctl_addr);
+		udelay(2);
+		ATA_RAW_READ(hwif->io_ports.status_addr);
+		udelay(2);
+	}
+
+	priv->enable = prev;
+	ATA_RAW_WRITE(prev, base + MXC_IDE_INTR_ENABLE);
+	dbg("done");
+	return err;
+}
+
+static void mxc_ide_dma_host_set(ide_drive_t *drive, int on)
+{
+	if (on) {
+		/*
+		 * Go to UDMA3 mode.  Beyond that you'll no doubt
+		 * need an Ultra-100 cable (the 80 pin type with
+		 * ground leads between all the signals)
+		 */
+		printk(KERN_INFO "%s: enabling UDMA3 mode\n", drive->name);
+		mxc_ide_config_drive(drive, XFER_UDMA_3);
+		drive->using_dma = 1;
+	} else
+		drive->using_dma = 0;
+
+	dbg("done");
+}
+
+
+static ide_startstop_t mxc_ide_dma_intr(ide_drive_t *drive)
+{
+	u8 stat, dma_stat;
+	struct request *rq = HWGROUP(drive)->rq;
+	ide_hwif_t *hwif = HWIF(drive);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) hwif->host->host_priv;
+	u8 fifo_fill;
+
+	if (!rq)
+		return ide_stopped;
+
+	fifo_fill = ATA_RAW_READ(priv->base + MXC_IDE_FIFO_FILL);
+	BUG_ON(fifo_fill);
+
+	dma_stat = hwif->dma_ops->dma_end(drive);
+	stat = hwif->tp_ops->read_status(hwif);   /* get drive status */
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (dma_stat == MXC_DMA_DONE) {
+			ide_end_request(drive, 1, rq->nr_sectors);
+			dbg("done");
+			return ide_stopped;
+		}
+		printk(KERN_ERR "%s: mxc_ide_dma_intr: bad DMA status (0x%x)\n",
+				drive->name, dma_stat);
+	}
+
+	return ide_error(drive, "mxc_ide_dma_intr", stat);
+}
+
+
+/*!
+ * Directs the IDE INTRQ signal to DMA or to the CPU
+ *
+ * @param       hwif       Specifies the IDE controller
+ *
+ * @param       which       \b INTRQ_DMA or \b INTRQ_MCU
+ *
+ */
+static void mxc_ide_set_intrq(ide_hwif_t *hwif, intrq_which_t which)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) hwif->host->host_priv;
+	unsigned char enable = ATA_RAW_READ(priv->base + MXC_IDE_INTR_ENABLE);
+
+	switch (which) {
+	case INTRQ_DMA:
+			enable &= ~MXC_IDE_INTR_ATA_INTRQ2;
+			enable |= MXC_IDE_INTR_ATA_INTRQ1;
+			break;
+	case INTRQ_MCU:
+			enable &= ~MXC_IDE_INTR_ATA_INTRQ1;
+			enable |= MXC_IDE_INTR_ATA_INTRQ2;
+			break;
+	}
+	priv->enable = enable;
+
+	ATA_RAW_WRITE(enable, priv->base + MXC_IDE_INTR_ENABLE);
+	dbg("done");
+}
+
+
+/*!
+ * DMA completion callback routine.  This gets called after the DMA request
+ * has completed or aborted.All we need to do here is return ownership of
+ * the drive's INTRQ signal back to the CPU, which will immediately raise
+ * the interrupt to the IDE layer.
+ *
+ * @param       arg         The drive we're servicing
+ * @param   error       The error number of DMA transfer.
+ * @param   count       The transfered length.
+ */
+static void mxc_ide_dma_callback(void *arg, int error, unsigned int count)
+{
+	ide_hwif_t *hwif = HWIF((ide_drive_t *) arg);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) hwif->host->host_priv;
+	unsigned long fifo_fill;
+
+	/*
+	 * clean the fifo if the fill register is non-zero.
+	 * If the fill register is non-zero, it is incorrect state.
+	 */
+	fifo_fill = ATA_RAW_READ(priv->base + MXC_IDE_FIFO_FILL);
+	while (fifo_fill) {
+		ATA_RAW_READ(priv->base + MXC_IDE_FIFO_DATA_32);
+		fifo_fill = ATA_RAW_READ(priv->base + MXC_IDE_FIFO_FILL);
+	}
+
+	priv->dma_stat = error;
+	/*
+	 * Redirect ata_intrq back to us instead of the DMA.
+	 */
+	mxc_ide_set_intrq(hwif, INTRQ_MCU);
+	dbg("done");
+}
+
+
+/*!
+ * DMA set up.  This is called once per DMA request to the drive. It delivers
+ * the scatter-gather list into the DMA channel and prepares both the ATA
+ * controller and the DMA engine for the DMA
+ * transfer.
+ *
+ * @param       drive     The drive we're servicing
+ *
+ * @return      0 on success, non-zero otherwise
+ */
+static int mxc_ide_dma_setup(ide_drive_t *drive)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) hwif->host->host_priv;
+	int dma_ultra = priv->ultra ? MXC_IDE_CTRL_DMA_ULTRA : 0;
+	int dma_mode = 0;
+	int chan;
+	u8 ata_control;
+	u8 fifo_fill;
+
+	BUG_ON(!rq);
+	BUG_ON(!priv);
+	BUG_ON(drive->waiting_for_dma);
+
+	/*Initialize the dma state */
+	priv->dma_stat = MXC_DMA_TRANSFER_ERROR;
+
+	/*
+	 * Prepare the ATA controller for the DMA
+	 */
+	if (rq_data_dir(rq)) {
+		chan = priv->dma_write_chan;
+		ata_control = MXC_IDE_CTRL_FIFO_RST_B |
+			MXC_IDE_CTRL_ATA_RST_B |
+			MXC_IDE_CTRL_FIFO_TX_EN |
+			MXC_IDE_CTRL_DMA_PENDING |
+			dma_ultra | MXC_IDE_CTRL_DMA_WRITE;
+
+		dma_mode = DMA_MODE_WRITE;
+	} else {
+		chan = priv->dma_read_chan;
+		ata_control = MXC_IDE_CTRL_FIFO_RST_B |
+			MXC_IDE_CTRL_ATA_RST_B |
+			MXC_IDE_CTRL_FIFO_RCV_EN |
+			MXC_IDE_CTRL_DMA_PENDING | dma_ultra;
+
+		dma_mode = DMA_MODE_READ;
+	}
+
+	/*
+	 * Set up the DMA interrupt callback
+	 */
+	mxc_dma_callback_set(chan, mxc_ide_dma_callback, (void *)drive);
+
+	/*
+	 * If the ATA FIFO isn't empty, we shouldn't even be here
+	 */
+	fifo_fill = ATA_RAW_READ(priv->base + MXC_IDE_FIFO_FILL);
+	BUG_ON(fifo_fill);
+
+	ide_map_sg(drive, rq);
+
+	hwif->sg_dma_direction = rq_data_dir(rq) ? DMA_TO_DEVICE :
+		DMA_FROM_DEVICE;
+
+	hwif->sg_nents = dma_map_sg(priv->dev, sg, hwif->sg_nents,
+			hwif->sg_dma_direction);
+	BUG_ON(!hwif->sg_nents);
+	BUG_ON(hwif->sg_nents > MXC_IDE_DMA_BD_NR);
+
+	mxc_dma_sg_config(chan, sg, hwif->sg_nents, 0, dma_mode);
+
+	ATA_RAW_WRITE(ata_control, priv->base + MXC_IDE_ATA_CONTROL);
+	ATA_RAW_WRITE(MXC_IDE_DMA_WATERMARK / 2,
+			priv->base + MXC_IDE_FIFO_ALARM);
+
+	/*
+	 * Route ata_intrq to the DMA engine, and not to us.
+	 */
+	mxc_ide_set_intrq(hwif, INTRQ_DMA);
+
+	/*
+	 * The DMA and ATA controller are ready to go.
+	 * mxc_ide_dma_start() will start the DMA transfer,
+	 * and mxc_ide_dma_exec_cmd() will tickle the drive, which
+	 * actually initiates the DMA transfer on the ATA bus.
+	 * The ATA controller is DMA slave for both read and write.
+	 */
+	BUG_ON(drive->waiting_for_dma);
+	drive->waiting_for_dma = 1;
+	dbg("done");
+	return 0;
+}
+
+/*!
+ * DMA timeout notification.  This gets called when the IDE layer above
+ * us times out waiting for a request.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @return      0 to attempt recovery, otherwise, an additional tick count
+ *              to keep waiting
+ */
+static int mxc_ide_dma_timer_expiry(ide_drive_t *drive)
+{
+	HWIF(drive)->port_ops->resetproc(drive);
+
+	if (drive->waiting_for_dma)
+		HWIF(drive)->dma_ops->dma_host_set(drive, 0);
+
+	dbg("done");
+	return 0;
+}
+
+
+/*!
+ * Called by the IDE layer to start a DMA request on the specified drive.
+ * The request has already been prepared by \b mxc_ide_dma_setup().  All
+ * we need to do is pass the command through while specifying our timeout
+ * handler.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @param       cmd         The IDE command for the drive
+ *
+ */
+static void mxc_ide_dma_exec_cmd(ide_drive_t *drive, u8 cmd)
+{
+	ide_execute_command(drive, cmd, mxc_ide_dma_intr, 2 * WAIT_CMD,
+			mxc_ide_dma_timer_expiry);
+	dbg("done");
+}
+
+
+/*!
+ * Called by the IDE layer to start the DMA controller.  The request has
+ * already been prepared by \b mxc_ide_dma_setup().  All we do here
+ * is tickle the DMA channel.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ */
+static void mxc_ide_dma_start(ide_drive_t *drive)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	ide_hwif_t *hwif = HWIF(drive);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) hwif->host->host_priv;
+	int chan = rq_data_dir(rq) ? priv->dma_write_chan : priv->dma_read_chan;
+
+	BUG_ON(chan < 0);
+
+	/*
+	 * Tickle the DMA channel.  This starts the channel, but it is likely
+	 * that DMA will yield and go idle before the DMA request arrives from
+	 * the drive.  Nonetheless, at least the context will be hot.
+	 */
+	mxc_dma_enable(chan);
+	dbg("done");
+}
+
+
+/*!
+ * The DMA is done, and the drive is done.  We'll check the BD array for
+ * errors, and unmap the scatter-gather list.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @return      0 means all is well, others means DMA signalled an error ,
+ */
+static int mxc_ide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)hwif->host->host_priv;
+	int dma_stat = priv->dma_stat;
+
+	BUG_ON(drive->waiting_for_dma == 0);
+	drive->waiting_for_dma = 0;
+
+	/*
+	 * We'll unmap the sg table regardless of status.
+	 */
+	dma_unmap_sg(priv->dev, hwif->sg_table, hwif->sg_nents,
+			hwif->sg_dma_direction);
+	dbg("done");
+	return dma_stat;
+}
+
+
+/*!
+ * There is a race between the DMA interrupt and the timeout interrupt.  This
+ * gets called during the IDE layer's timeout interrupt to see if the DMA
+ * interrupt has also occured or is pending.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @return      1 means there is a DMA interrupt pending, 0 otherwise
+ */
+static int mxc_ide_dma_test_irq(ide_drive_t *drive)
+{
+	mxc_ide_private_t *priv = (mxc_ide_private_t *)
+		HWIF(drive)->host->host_priv;
+	unsigned char status = ATA_RAW_READ(priv->base + MXC_IDE_INTR_PENDING);
+
+	/*
+	 * We need to test the interrupt status without dismissing any.
+	 */
+	return status & (MXC_IDE_INTR_ATA_INTRQ1
+			| MXC_IDE_INTR_ATA_INTRQ2) ? 1 : 0;
+}
+
+/*!
+ * Called for special handling on timeouts.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @return      0 if successful, non-zero otherwise
+ */
+static void mxc_ide_dma_timeout(ide_drive_t *drive)
+{
+	HWIF(drive)->port_ops->resetproc(drive);
+}
+
+/*!
+ * Called for special handling on lost irq's.
+ *
+ * @param       drive       The drive we're servicing
+ *
+ * @return      0 if successful, non-zero otherwise
+ */
+static void mxc_ide_dma_lost_irq(ide_drive_t *drive)
+{
+}
+
+
+/*
+ *  mxc ide dma operation
+ */
+static const struct ide_dma_ops mxc_ide_dma_ops = {
+	.dma_host_set   =   mxc_ide_dma_host_set,
+	.dma_setup      =   mxc_ide_dma_setup,
+	.dma_exec_cmd   =   mxc_ide_dma_exec_cmd,
+	.dma_start      =   mxc_ide_dma_start,
+	.dma_end       =    mxc_ide_dma_end,
+	.dma_test_irq   =   mxc_ide_dma_test_irq,
+	.dma_lost_irq   =   mxc_ide_dma_lost_irq,
+	.dma_timeout    =   mxc_ide_dma_timeout,
+};
+
+/*!
+ * Called once per controller to set up DMA
+ *
+ * @param       hwif       Specifies the IDE controller
+ *
+ */
+static int mxc_ide_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)
+{
+	int ret = 0;
+	struct ide_host *host = hwif->host;
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) host->host_priv;
+
+	hwif->dmatable_cpu = NULL;
+	hwif->dmatable_dma = 0;
+
+	/*
+	 * Allocate and setup the DMA channels
+	 */
+	priv->dma_read_chan = mxc_dma_request(MXC_DMA_ATA_RX, "MXC ATA RX");
+	if (priv->dma_read_chan < 0) {
+		printk(KERN_ERR "%s: couldn't get RX DMA channel\n",
+				hwif->name);
+		ret = -EBUSY;
+		goto err_out;
+	}
+
+	priv->dma_write_chan = mxc_dma_request(MXC_DMA_ATA_TX, "MXC ATA TX");
+	if (priv->dma_write_chan < 0) {
+		printk(KERN_ERR "%s: couldn't get TX DMA channel\n",
+				hwif->name);
+		ret = -EBUSY;
+		goto err_out;
+	}
+
+	printk(KERN_INFO "%s: read chan=%d , write chan=%d \n",
+			hwif->name, priv->dma_read_chan, priv->dma_write_chan);
+
+	set_ata_bus_timing(priv, 0, UDMA);
+	return 0;
+
+err_out:
+	if (priv->dma_read_chan >= 0)
+		mxc_dma_free(priv->dma_read_chan);
+	return ret;
+}
+
+static const struct ide_port_info mxc_ide_port_info = {
+	.init_dma		=		mxc_ide_dma_init,
+	.tp_ops			=		&default_tp_ops,
+	.port_ops		=		&mxc_ide_port_ops,
+	.dma_ops		=		&mxc_ide_dma_ops,
+	.host_flags		=		IDE_HFLAG_MMIO,
+	.pio_mask		=		ATA_PIO4,
+	.swdma_mask 	= 		0x07,
+	.mwdma_mask		=		0x07,
+	.udma_mask		=		0x7f,
+};
+
+/*!
+ * Hardware-specific interrupt service routine for the ATA driver,
+ * called mainly just to dismiss the interrupt at the hardware, and
+ * to indicate whether there actually was an interrupt pending.
+ *
+ * The generic IDE related interrupt handling is done by the IDE layer.
+ */
+static int mxc_ide_ack_intr(struct hwif_s *hwif)
+{
+	struct ide_host *host = hwif->host;
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) host->host_priv;
+	unsigned int base = (unsigned int)priv->base;
+	unsigned char status = ATA_RAW_READ(base + MXC_IDE_INTR_PENDING);
+	unsigned char enable = ATA_RAW_READ(base + MXC_IDE_INTR_ENABLE);
+
+	/*
+	 * The only interrupts we can actually dismiss are the FIFO conditions.
+	 * INTRQ comes from the bus, and must be dismissed according to IDE
+	 * protocol, which will be done by the IDE layer, even when DMA
+	 * is invovled (DMA can see it, but can't dismiss it).
+	 */
+	ATA_RAW_WRITE(status, base + MXC_IDE_INTR_CLEAR);
+
+	if (status & enable & ~MXC_IDE_INTR_ATA_INTRQ2) {
+		printk(KERN_ERR "mxc_ide_ack_intr: unexpected interrupt, "
+				"status=0x%02X\n", status);
+	}
+	return status ? 1 : 0;
+}
+
+
+static void mxc_ide_setup_ports(hw_regs_t *hw, mxc_ide_private_t   *priv)
+{
+	int i = 0;
+	unsigned long *ata_regs = hw->io_ports_array;
+	unsigned int base	= (unsigned int)priv->base + IDE_ARM_IO;
+	unsigned int aux	= (unsigned int)priv->base + IDE_ARM_CTL;
+	const int regsize = 4;
+
+	for (i = 0; i <= 7; i++) {
+		*ata_regs++ = base;
+		base += regsize;
+	}
+
+	/* set the Alternative Status register */
+	*ata_regs = aux;
+
+	hw->irq = priv->irq;
+	hw->ack_intr = mxc_ide_ack_intr;
+	hw->chipset = ide_mxc;
+}
+
+/*!
+ * This function is called during the driver binding process. Based on the ATA
+ * module that is being probed this function adds the appropriate ATA module
+ * structure in the core driver.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions.
+ *
+ * @return  The function returns 0 on successful registration and initialization
+ *          of SDHC module. Otherwise returns specific error code.
+ */
+static int mxc_ide_probe(struct platform_device *pdev)
+{
+	mxc_ide_private_t	*priv;
+	struct mxc_ide_platform_data *ide_plat = pdev->dev.platform_data;
+	struct ide_host *host;
+	ide_hwif_t *hwif;
+	hw_regs_t hw, *hws[] = { &hw, NULL, NULL, NULL };
+	struct regulator *regulator_drive = NULL, *regulator_io = NULL;
+	int i, j, ret = 0;
+
+	/*
+	 * Allocate a private structure
+	 */
+	priv = kmalloc(sizeof(mxc_ide_private_t),
+			GFP_KERNEL);
+	if (priv == NULL)
+		return ENOMEM;
+
+	memset(priv, 0, sizeof *priv);
+	priv->dev = &pdev->dev;
+	priv->dma_read_chan = -1;
+	priv->dma_write_chan = -1;
+
+	priv->irq = platform_get_irq(pdev, 0);
+
+	if (priv->irq < 0) {
+		pr_debug("%s %d: no IRQ\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	priv->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (priv->res == NULL) {
+		pr_debug("%s %d: no base address\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (!request_mem_region(priv->res->start,
+				priv->res->end - priv->res->start + 1,
+				pdev->name)) {
+		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
+		ret =  -EBUSY;
+		goto err;
+	}
+
+	priv->base = (void *)IO_ADDRESS(priv->res->start);
+	if (priv->base == 0) {
+		pr_debug("%s: remap mem address failed\n", DRV_NAME);
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	priv->clk = clk_get(&pdev->dev, "ata_clk");
+	if (IS_ERR(priv->clk)) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "no ata_clk?\n");
+		goto err2;
+	}
+	clk_enable(priv->clk);
+
+#ifndef CONFIG_MACH_MX31_3DS
+	/* Select group B pins, and enable the interface */
+	if (!machine_is_mx31lite())
+		PBC_ATA_SIGNAL_ACTIVE();
+#endif
+
+	/* Configure the pads */
+	gpio_ata_active();
+
+	/* Deassert the reset bit to enable the interface */
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B, priv->base + MXC_IDE_ATA_CONTROL);
+
+	/*
+     * Enable the power to HDD
+     */
+	if (ide_plat) {
+		if (ide_plat->power_drive != NULL) {
+			regulator_drive = regulator_get(&pdev->dev,
+				ide_plat->power_drive);
+			if (IS_ERR(regulator_drive)) {
+				printk(KERN_ERR "MXC: IDE driver, can't get power\n");
+				ret = -ENODEV;
+				goto err2a;
+			} else {
+				if (regulator_enable(regulator_drive)) {
+					printk(KERN_ERR "enable regulator error.\n");
+					ret = -ENODEV;
+					goto err2a;
+				}
+				msleep(100);
+			}
+		} else
+			regulator_drive = NULL;
+
+		if (ide_plat->power_io != NULL) {
+			regulator_io = regulator_get(&pdev->dev,
+					ide_plat->power_io);
+			if (IS_ERR(regulator_io)) {
+				printk(KERN_ERR "MXC: IDE driver, can't get power\n");
+				ret = -ENODEV;
+				goto err2a;
+			} else {
+				if (regulator_enable(regulator_io)) {
+					printk(KERN_ERR "enable regulator error.\n");
+					ret = -ENODEV;
+					goto err2a;
+				}
+			msleep(100);
+			}
+		} else
+			regulator_io = NULL;
+	}
+	/* Set initial timing and mode */
+	set_ata_bus_timing(priv, 4, PIO);
+
+	/* Reset the interface */
+	ATA_RAW_WRITE(0x00, priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B, priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+
+	/*
+	 * Enable hardware interrupts.
+	 * INTRQ2 goes to us, so we enable it here, but we'll need to ignore
+	 * it when DMA is doing the transfer.
+	 */
+	ATA_RAW_WRITE(MXC_IDE_INTR_ATA_INTRQ2,
+			priv->base + MXC_IDE_INTR_ENABLE);
+	priv->enable = MXC_IDE_INTR_ATA_INTRQ2;
+
+	memset(&hw, 0, sizeof(hw));
+
+	mxc_ide_setup_ports(&hw, priv);
+	hw.dev = &pdev->dev;
+
+	host = ide_host_alloc(&mxc_ide_port_info, hws);
+	if (host == NULL) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "alloc host failed\n");
+		goto err3;
+	}
+
+	host->host_priv = (void *)priv;
+	ret = ide_host_register(host, &mxc_ide_port_info, hws);
+	if (ret) {
+		dev_dbg(&pdev->dev, "register host failed\n");
+		goto err4;
+	}
+
+	for (i = 0; i < ret; i++) {
+		hwif = host->ports[i];
+		for (j = 0; j < MAX_DRIVES; j++) {
+			ide_drive_t *drive = &hwif->drives[j];
+			if (!drive->present)
+				continue;
+
+			blk_queue_max_hw_segments(drive->queue,
+					MXC_IDE_DMA_BD_NR);
+			blk_queue_max_segment_size(drive->queue,
+					MXC_IDE_DMA_BD_SIZE_MAX);
+		}
+
+	}
+#ifdef ATA_USE_IORDY
+	/* turn on IORDY protocol */
+
+	udelay(25);
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B | MXC_IDE_CTRL_IORDY_EN,
+			priv->base + MXC_IDE_ATA_CONTROL);
+#endif
+
+	priv->regulator_drive = regulator_drive;
+	priv->regulator_io = regulator_io;
+
+	platform_set_drvdata(pdev, host);
+
+	printk(KERN_INFO "MXC IDE(builtin) configured sucessfully\n");
+
+	return 0;
+err4:
+	ide_host_free(host);
+err3:
+	ATA_RAW_WRITE(0, priv->base + MXC_IDE_INTR_ENABLE);
+#ifndef CONFIG_MACH_MX31_3DS
+	/* Disable the interface */
+	if (!machine_is_mx31lite())
+		PBC_ATA_SIGNAL_INACTIVE();
+#endif
+	if (regulator_io) {
+		regulator_disable(regulator_io);
+		regulator_put(regulator_io, &pdev->dev);
+	}
+err2a:
+	if (regulator_drive) {
+		regulator_disable(regulator_drive);
+		regulator_put(regulator_drive, &pdev->dev);
+	}
+	gpio_ata_inactive();
+	clk_disable(priv->clk);
+err2:
+	clk_put(priv->clk);
+err1:
+	release_mem_region(priv->res->start,
+			priv->res->end - priv->res->start + 1);
+err:
+	kfree(priv);
+	return ret;
+}
+
+/*!
+ * Driver exit routine.  Clean up.
+ */
+static int mxc_ide_remove(struct platform_device *pdev)
+{
+	struct ide_host *host = platform_get_drvdata(pdev);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) host->host_priv;
+
+	ide_host_remove(host);
+
+	/*
+	 * Disable hardware interrupts.
+	 */
+	ATA_RAW_WRITE(0, priv->base + MXC_IDE_INTR_ENABLE);
+
+	/*
+	 * Deallocate DMA channels.  Free's BDs and everything.
+	 */
+	if (priv->dma_read_chan >= 0)
+		mxc_dma_free(priv->dma_read_chan);
+	if (priv->dma_write_chan >= 0)
+		mxc_dma_free(priv->dma_write_chan);
+
+#ifndef CONFIG_MACH_MX31_3DS
+	/* Disable the interface */
+	if (!machine_is_mx31lite())
+		PBC_ATA_SIGNAL_INACTIVE();
+#endif
+
+	/*
+	 * Free the pins
+	 */
+	gpio_ata_inactive();
+
+
+	release_mem_region(priv->res->start,
+			priv->res->end - priv->res->start + 1);
+
+	/* Disable power supply */
+	if (priv->regulator_drive) {
+		regulator_disable(priv->regulator_drive);
+		regulator_put((priv->regulator_drive), &pdev->dev);
+	}
+	if (priv->regulator_io) {
+		regulator_disable(priv->regulator_io);
+		regulator_put((priv->regulator_io), &pdev->dev);
+	}
+
+	/*Disable clock*/
+	clk_disable(priv->clk);
+	clk_put(priv->clk);
+
+	/*
+	 * Free the private structure.
+	 */
+	kfree(priv);
+
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+/*!
+ * This function is called to put the ATA  in a low power state.
+ * Refer to the document driver-model/driver.txt in the kernel
+ * source tree for more information.
+ *
+ * @param   pdev  the device structure used to give information
+ *			on which IDE to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_ide_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct ide_host *host = platform_get_drvdata(pdev);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) host->host_priv;
+	/*
+	 * Disable hardware interrupts.
+	 * Be carefully, the system would halt if there is no pwr supply
+	 */
+	ATA_RAW_WRITE(0, MXC_IDE_INTR_ENABLE);
+
+	if (priv->dma_read_chan >= 0) {
+		mxc_dma_disable(priv->dma_read_chan);
+		mxc_dma_free(priv->dma_read_chan);
+	}
+	if (priv->dma_write_chan >= 0) {
+		mxc_dma_disable(priv->dma_write_chan);
+		mxc_dma_free(priv->dma_write_chan);
+	}
+
+	/*
+	 * Turn off the power
+	 */
+	if (priv->regulator_drive)
+		regulator_disable(priv->regulator_drive);
+	if (priv->regulator_io)
+		regulator_disable(priv->regulator_io);
+
+	gpio_ata_inactive();
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the ATA back from a low
+ * power state. Refer to the document driver-model/driver.txt
+ * in the kernel source tree for more information.
+ *
+ * @param   pdev  the device structure used to give information
+ *			on which IDE to resume
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_ide_resume(struct platform_device *pdev)
+{
+	struct ide_host *host = platform_get_drvdata(pdev);
+	mxc_ide_private_t *priv = (mxc_ide_private_t *) host->host_priv;
+
+	gpio_ata_active();
+	/* power up the ATA pwr supply */
+	if (priv->regulator_drive) {
+		if (regulator_enable(priv->regulator_drive))
+			printk(KERN_ERR "enable power_drive error.\n");
+	}
+	udelay(600);
+
+	if (priv->regulator_io) {
+			if (regulator_enable(priv->regulator_io))
+				printk(KERN_ERR "enable power_io error.\n");
+	}
+	udelay(600);
+
+	/* Deassert the reset bit to enable the interface */
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B, MXC_IDE_ATA_CONTROL);
+
+	/* Set initial timing and mode */
+	set_ata_bus_timing(priv, 4, PIO);
+
+	/* Reset the interface */
+	ATA_RAW_WRITE(0x00, priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B,
+			priv->base + MXC_IDE_ATA_CONTROL);
+	udelay(100);
+
+	priv->dma_read_chan =
+		mxc_dma_request(MXC_DMA_ATA_RX, "MXC ATA RX");
+	if (priv->dma_read_chan < 0) {
+		dev_dbg(&pdev->dev, "couldn't get RX DMA channel\n");
+		return -EAGAIN;
+	}
+
+	priv->dma_write_chan =
+		mxc_dma_request(MXC_DMA_ATA_TX, "MXC ATA TX");
+	if (priv->dma_write_chan < 0) {
+		if (priv->dma_read_chan > 0)
+			mxc_dma_free(priv->dma_read_chan);
+			dev_dbg(&pdev->dev, "couldn't get TX DMA channel\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver mxc_ide_driver = {
+	.driver = {
+		.name = DRV_NAME,
+	},
+	.probe	=	mxc_ide_probe,
+	.remove	=	mxc_ide_remove,
+	.suspend	=	mxc_ide_suspend,
+	.resume		=	mxc_ide_resume,
+};
+
+
+static int __init mxc_ide_init(void)
+{
+	printk(KERN_INFO "ATA IDE Driver for FreeScale mxc\n");
+	return platform_driver_register(&mxc_ide_driver);
+}
+
+
+static void __exit mxc_ide_exit(void)
+{
+	platform_driver_unregister(&mxc_ide_driver);
+}
+
+
+
+module_init(mxc_ide_init);
+module_exit(mxc_ide_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MXC ATA IDE Driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+
diff --git a/include/linux/ide.h b/include/linux/ide.h
index 6514db8..71ac6d2 100644
--- a/include/linux/ide.h
+++ b/include/linux/ide.h
@@ -160,7 +160,7 @@ enum {		ide_unknown,	ide_generic,	ide_pci,
 		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_acorn,
-		ide_au1xxx,	ide_palm3710
+		ide_au1xxx,	ide_palm3710, ide_mxc
 };
 
 typedef u8 hwif_chipset_t;
-- 
1.5.5.1

