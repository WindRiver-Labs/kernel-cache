From 11d4d8438fba5ee143a9dc8fae1eca11b3123b7c Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 11:57:08 +0800
Subject: [PATCH] mx3_drivers_i2c

MX3 i2c controller driver.
Add kernel clk interface manipulation.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/i2c/busses/Kconfig   |    9 +
 drivers/i2c/busses/Makefile  |    1 +
 drivers/i2c/busses/i2c-mxc.c |  777 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 787 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-mxc.c

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..adb3945 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -504,6 +504,15 @@ config I2C_VERSATILE
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_MXC
+    tristate "MXC I2C support"
+    depends on I2C && ARCH_MXC
+    help
+      If you say yes to this option, support will be included for Freescale
+      MXC I2C modules.
+
+      This driver can also be built as a module.
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..bedbfb4 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -46,6 +46,7 @@ obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
 obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
+obj-$(CONFIG_I2C_MXC)       += i2c-mxc.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
diff --git a/drivers/i2c/busses/i2c-mxc.c b/drivers/i2c/busses/i2c-mxc.c
new file mode 100644
index 0000000..ff51286
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mxc.c
@@ -0,0 +1,777 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_i2c.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC I2C buses.
+ *
+ * Based on i2c driver algorithm for PCF8584 adapters
+ *
+ * @ingroup MXCI2C
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <asm/plat-mxc/mxc_i2c.h>
+/*!
+ * Boolean to indicate if data was transferred
+ */
+static bool transfer_done;
+
+/*!
+ * Boolean to indicate if we received an ACK for the data transmitted
+ */
+static bool tx_success;
+
+/*!
+ * This is an array where each element holds information about a I2C module,
+ * like base address, interrupt number etc. This elements of this structure
+ * are stored in the appropriate i2c_adapter structure during the module
+ * initialization.
+ */
+static mxc_i2c_device mxc_i2c_devs[I2C_NR] = {
+	[0] = {
+		.membase = (void *)IO_ADDRESS(I2C_BASE_ADDR),
+		.irq = MXC_INT_I2C,
+		.clkdiv = I2C1_FRQ_DIV,
+	},
+#if I2C_NR > 1
+	[1] = {
+		.membase = (void *)IO_ADDRESS(I2C2_BASE_ADDR),
+		.irq = MXC_INT_I2C2,
+		.clkdiv = I2C2_FRQ_DIV,
+	},
+#if I2C_NR > 2
+	[2] = {
+		.membase = (void *)IO_ADDRESS(I2C3_BASE_ADDR),
+		.irq = MXC_INT_I2C3,
+		.clkdiv = I2C3_FRQ_DIV,
+	}
+#endif
+#endif
+};
+
+/*!
+ * Transmit a \b STOP signal to the slave device.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ */
+static void mxc_i2c_stop(mxc_i2c_device *dev)
+{
+	unsigned int cr;
+	int retry = 16;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	cr &= ~(MXC_I2CR_MSTA | MXC_I2CR_MTX);
+	writew(cr, dev->membase + MXC_I2CR);
+
+	/*
+	 * Make sure STOP meets setup requirement.
+	 */
+	for (;;) {
+		unsigned int sr = readw(dev->membase + MXC_I2SR);
+		if ((sr & MXC_I2SR_IBB) == 0)
+			break;
+		if (retry-- <= 0) {
+			printk(KERN_DEBUG "Bus busy\n");
+			break;
+		}
+		udelay(3);
+	}
+}
+
+/*!
+ * Wait for the transmission of the data byte to complete. This function waits
+ * till we get a signal from the interrupt service routine indicating completion
+ * of the address cycle or we time out.
+ *
+ * @param   dev         the mxc i2c structure used to get to the right i2c device
+ * @param   trans_flag  transfer flag
+ *
+ *
+ * @return  The function returns 0 on success or -1 if an ack was not received
+ */
+
+static int mxc_i2c_wait_for_tc(mxc_i2c_device *dev, int trans_flag)
+{
+	int retry = 16;
+	unsigned int sr, cr;
+
+	if (trans_flag & MXC_I2C_FLAG_POLLING) {
+		/* I2C_POLLING_MODE */
+		unsigned long x = jiffies + dev->adap.timeout * HZ;
+		while (!(readw(dev->membase + MXC_I2SR) & MXC_I2SR_IIF)) {
+			if (unlikely(time_after(jiffies, x))) {
+				/* Poll timeout */
+				retry = -ETIMEDOUT;
+				break;
+			}
+			if (unlikely(signal_pending(current))) {
+				/* Poll interrupted */
+				retry = -ERESTARTSYS;
+				break;
+			}
+			if (!irqs_disabled())
+				schedule();
+		}
+		sr = readw(dev->membase + MXC_I2SR);
+		cr = readw(dev->membase + MXC_I2CR);
+		writew(0, dev->membase + MXC_I2SR);
+
+		tx_success = false;
+		/* Check if RXAK is received in Transmit mode */
+		if ((cr & MXC_I2CR_MTX) && (!(sr & MXC_I2SR_RXAK)))
+			tx_success = true;
+	} else {
+		/* Interrupt mode */
+		while (retry-- && !transfer_done) {
+			wait_event_interruptible_timeout(dev->wq,
+					transfer_done,
+					dev->adap.timeout);
+		}
+		transfer_done = false;
+	}
+	if (retry <= 0) {
+		/* Unable to send data */
+		printk(KERN_DEBUG "Data not transmitted\n");
+		return -1;
+	} else if (!(trans_flag & I2C_M_RD)) {
+		if (!tx_success) {
+			/* An ACK was not received for transmitted byte */
+			printk(KERN_DEBUG "ACK not received \n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * Transmit a \b START signal to the slave device.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address
+ */
+static void mxc_i2c_start(mxc_i2c_device *dev, struct i2c_msg *msg)
+{
+	unsigned int cr, sr;
+	unsigned int addr_trans;
+	int retry = 16;
+
+	/*
+	 * Set the slave address and the requested transfer mode
+	 * in the data register
+	 */
+	addr_trans = msg->addr << 1;
+	if (msg->flags & I2C_M_RD)
+		addr_trans |= 0x01;
+
+	/* Set the Master bit */
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_MSTA;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	/* Wait till the Bus Busy bit is set */
+	sr = readw(dev->membase + MXC_I2SR);
+	while (retry-- && (!(sr & MXC_I2SR_IBB))) {
+		udelay(3);
+		sr = readw(dev->membase + MXC_I2SR);
+	}
+	if (retry <= 0)
+		printk(KERN_DEBUG "Could not grab Bus ownership\n");
+
+	/* Set the Transmit bit */
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_MTX;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	writew(addr_trans, dev->membase + MXC_I2DR);
+}
+
+/*!
+ * Transmit a \b REPEAT START to the slave device
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address
+ */
+static void mxc_i2c_repstart(mxc_i2c_device *dev, struct i2c_msg *msg)
+{
+	unsigned int cr;
+	unsigned int addr_trans;
+
+	/*
+	 * Set the slave address and the requested transfer mode
+	 * in the data register
+	 */
+	addr_trans = msg->addr << 1;
+	if (msg->flags & I2C_M_RD)
+		addr_trans |= 0x01;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_RSTA;
+	writew(cr, dev->membase + MXC_I2CR);
+	udelay(3);
+	writew(addr_trans, dev->membase + MXC_I2DR);
+}
+
+/*!
+ * Read the received data. The function waits till data is available or times
+ * out. Generates a stop signal if this is the last message to be received.
+ * Sends an ack for all the bytes received except the last byte.
+ *
+ * @param  dev       the mxc i2c structure used to get to the right i2c device
+ * @param  *msg      pointer to a message structure that contains the slave
+ *                   address and a pointer to the receive buffer
+ * @param  last      indicates that this is the last message to be received
+ * @param  addr_comp flag indicates that we just finished the address cycle
+ *
+ * @return  The function returns the number of bytes read or -1 on time out.
+ */
+static int mxc_i2c_readbytes(mxc_i2c_device *dev, struct i2c_msg *msg,
+		int last, int addr_comp)
+{
+	int i;
+	char *buf = msg->buf;
+	int len = msg->len;
+	unsigned int cr;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	/*
+	 * Clear MTX to switch to receive mode.
+	 */
+	cr &= ~MXC_I2CR_MTX;
+	/*
+	 * Clear the TXAK bit to gen an ack when receiving only one byte.
+	 */
+	if (len == 1)
+		cr |= MXC_I2CR_TXAK;
+	else
+		cr &= ~MXC_I2CR_TXAK;
+
+	writew(cr, dev->membase + MXC_I2CR);
+	/*
+	 * Dummy read only at the end of an address cycle
+	 */
+	if (addr_comp > 0)
+		readw(dev->membase + MXC_I2DR);
+
+	for (i = 0; i < len; i++) {
+		/*
+		 * Wait for data transmission to complete
+		 */
+		if (mxc_i2c_wait_for_tc(dev, msg->flags)) {
+			mxc_i2c_stop(dev);
+			return -1;
+		}
+		/*
+		 * Do not generate an ACK for the last byte
+		 */
+		if (i == (len - 2)) {
+			cr = readw(dev->membase + MXC_I2CR);
+			cr |= MXC_I2CR_TXAK;
+			writew(cr, dev->membase + MXC_I2CR);
+		} else if (i == (len - 1)) {
+			if (last)
+				mxc_i2c_stop(dev);
+		}
+		/* Read the data */
+		*buf++ = readw(dev->membase + MXC_I2DR);
+	}
+
+	return i;
+}
+
+/*!
+ * Write the data to the data register. Generates a stop signal if this is
+ * the last message to be sent or if no ack was received for the data sent.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address and data to be sent
+ * @param   last  indicates that this is the last message to be received
+ *
+ * @return  The function returns the number of bytes written or -1 on time out
+ *          or if no ack was received for the data that was sent.
+ */
+static int mxc_i2c_writebytes(mxc_i2c_device *dev, struct i2c_msg *msg,
+		int last)
+{
+	int i;
+	char *buf = msg->buf;
+	int len = msg->len;
+	unsigned int cr;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	/* Set MTX to switch to transmit mode */
+	cr |= MXC_I2CR_MTX;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	for (i = 0; i < len; i++) {
+		/*
+		 * Write the data
+		 */
+		writew(*buf++, dev->membase + MXC_I2DR);
+		if (mxc_i2c_wait_for_tc(dev, msg->flags)) {
+			mxc_i2c_stop(dev);
+			return -1;
+		}
+	}
+
+	if (last > 0)
+		mxc_i2c_stop(dev);
+
+	return i;
+}
+
+/*!
+ * Function enables the I2C module and initializes the registers.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   trans_flag  transfer flag
+ */
+static void mxc_i2c_module_en(mxc_i2c_device *dev, int trans_flag)
+{
+	clk_enable(dev->clk);
+
+	/* Set the frequency divider */
+	writew(dev->clkdiv, dev->membase + MXC_IFDR);
+	/* Clear the status register */
+	writew(0x0, dev->membase + MXC_I2SR);
+	/* Enable I2C and its interrupts */
+	if (trans_flag & MXC_I2C_FLAG_POLLING)
+		writew(MXC_I2CR_IEN, dev->membase + MXC_I2CR);
+	else {
+		writew(MXC_I2CR_IEN, dev->membase + MXC_I2CR);
+		writew(MXC_I2CR_IEN | MXC_I2CR_IIEN, dev->membase + MXC_I2CR);
+	}
+}
+
+/*!
+ * Disables the I2C module.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ */
+static void mxc_i2c_module_dis(mxc_i2c_device *dev)
+{
+	writew(0x0, dev->membase + MXC_I2CR);
+	clk_disable(dev->clk);
+}
+
+/*!
+ * The function is registered in the adapter structure. It is called when an MXC
+ * driver wishes to transfer data to a device connected to the I2C device.
+ *
+ * @param   adap   adapter structure for the MXC i2c device
+ * @param   msgs[] array of messages to be transferred to the device
+ * @param   num    number of messages to be transferred to the device
+ *
+ * @return  The function returns the number of messages transferred,
+ *          \b -EREMOTEIO on I2C failure and a 0 if the num argument is
+ *          less than 0.
+ */
+static int mxc_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+		int num)
+{
+	mxc_i2c_device *dev = (mxc_i2c_device *) (i2c_get_adapdata(adap));
+	int i, ret = 0, addr_comp = 0;
+	unsigned int sr;
+
+	if (dev->low_power) {
+		printk(KERN_ERR "I2C Device in low power mode\n");
+		return -EREMOTEIO;
+	}
+
+	if (num < 1)
+		return 0;
+
+	mxc_i2c_module_en(dev, msgs[0].flags);
+	sr = readw(dev->membase + MXC_I2SR);
+	/*
+	 * Check bus state
+	 */
+	if (sr & MXC_I2SR_IBB) {
+		mxc_i2c_module_dis(dev);
+		printk(KERN_DEBUG "Bus busy\n");
+		return -EREMOTEIO;
+	}
+
+	transfer_done = false;
+	tx_success = false;
+
+	for (i = 0; i < num && ret >= 0; i++) {
+		addr_comp = 0;
+		/*
+		 * Send the slave address and transfer direction in the
+		 * address cycle
+		 */
+		if (i == 0) {
+			/*
+			 * Send a start or repeat start signal
+			 */
+			mxc_i2c_start(dev, &msgs[0]);
+			/* Wait for the address cycle to complete */
+			if (mxc_i2c_wait_for_tc(dev, msgs[0].flags)) {
+				mxc_i2c_stop(dev);
+				mxc_i2c_module_dis(dev);
+				return -EREMOTEIO;
+			}
+			addr_comp = 1;
+		} else {
+			/*
+			 * Generate repeat start only if
+			 * required i.e the address
+			 * changed or the transfer direction changed
+			 */
+			if ((msgs[i].addr != msgs[i - 1].addr) ||
+					((msgs[i].flags & I2C_M_RD) !=
+					 (msgs[i - 1].flags & I2C_M_RD))) {
+				mxc_i2c_repstart(dev, &msgs[i]);
+				/* Wait for the address cycle to complete */
+				if (mxc_i2c_wait_for_tc(dev, msgs[i].flags)) {
+					mxc_i2c_stop(dev);
+					mxc_i2c_module_dis(dev);
+					return -EREMOTEIO;
+				}
+				addr_comp = 1;
+			}
+		}
+
+		/* Transfer the data */
+		if (msgs[i].flags & I2C_M_RD) {
+			/* Read the data */
+			ret = mxc_i2c_readbytes(dev, &msgs[i], (i + 1 == num),
+					addr_comp);
+			if (ret < 0) {
+				printk(KERN_ERR "mxc_i2c_readbytes: fail.\n");
+				break;
+			}
+		} else {
+			/* Write the data */
+			ret = mxc_i2c_writebytes(dev, &msgs[i], (i + 1 == num));
+			if (ret < 0) {
+				printk(KERN_ERR "mxc_i2c_writebytes: fail.\n");
+				break;
+			}
+		}
+	}
+
+	mxc_i2c_module_dis(dev);
+	/*
+	 * Decrease by 1 as we do not want Start message to be included in
+	 * the count
+	 */
+	return i - 1;
+}
+
+/*!
+ * Returns the i2c functionality supported by this driver.
+ *
+ * @param   adap adapter structure for this i2c device
+ *
+ * @return Returns the functionality that is supported.
+ */
+static u32 mxc_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/*!
+ * Stores the pointers for the i2c algorithm functions. The algorithm functions
+ * is used by the i2c bus driver to talk to the i2c bus
+ */
+static struct i2c_algorithm mxc_i2c_algorithm = {
+	.master_xfer = mxc_i2c_xfer,
+	.functionality = mxc_i2c_func
+};
+
+/*!
+ * Interrupt Service Routine. It signals to the process about the data transfer
+ * completion. Also sets a flag if bus arbitration is lost.
+ * @param   irq    the interrupt number
+ * @param   dev_id driver private data
+ *
+ * @return  The function returns \b IRQ_HANDLED.
+ */
+static irqreturn_t mxc_i2c_handler(int irq, void *dev_id)
+{
+	mxc_i2c_device *dev = dev_id;
+	unsigned int sr, cr;
+
+	sr = readw(dev->membase + MXC_I2SR);
+	cr = readw(dev->membase + MXC_I2CR);
+
+	/*
+	 * Clear the interrupt bit
+	 */
+	writew(0x0, dev->membase + MXC_I2SR);
+
+	if (sr & MXC_I2SR_IAL)
+		printk(KERN_DEBUG "Bus Arbitration lost\n");
+	else {
+		/* Interrupt due byte transfer completion */
+		tx_success = false;
+		/* Check if RXAK is received in Transmit mode */
+		if ((cr & MXC_I2CR_MTX) && (!(sr & MXC_I2SR_RXAK)))
+			tx_success = true;
+
+		transfer_done = true;
+		wake_up_interruptible(&dev->wq);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is called to put the I2C adapter in
+ * a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel
+ * source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure.
+ */
+static int mxci2c_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mxc_i2c_device *mxcdev = platform_get_drvdata(pdev);
+	unsigned int sr = 0;
+
+	if (mxcdev == NULL)
+		return -1;
+
+	/* Prevent further calls to be processed */
+	mxcdev->low_power = true;
+	/* Wait till we finish the current transfer */
+	sr = readw(mxcdev->membase + MXC_I2SR);
+	while (sr & MXC_I2SR_IBB) {
+		msleep(10);
+		sr = readw(mxcdev->membase + MXC_I2SR);
+	}
+	gpio_i2c_inactive(mxcdev->adap.id);
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the I2C adapter
+ * back from a low power state. Refer
+ * to the document driver-model/driver.txt in the
+ * kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to resume
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxci2c_resume(struct platform_device *pdev)
+{
+	mxc_i2c_device *mxcdev = platform_get_drvdata(pdev);
+
+	if (mxcdev == NULL)
+		return -1;
+
+	mxcdev->low_power = false;
+	gpio_i2c_active(mxcdev->adap.id);
+
+	return 0;
+}
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions
+ *
+ * @return  The function always returns 0.
+ */
+static int mxci2c_probe(struct platform_device *pdev)
+{
+	int id = pdev->id;
+	int i;
+
+	for (i = 0; i < I2C_NR; i++) {
+		/*
+		 * Get the appropriate device structure for this I2C adapter
+		 */
+		if (mxc_i2c_devs[i].adap.id != id)
+			continue;
+
+		mxc_i2c_devs[i].clk = clk_get(&pdev->dev,
+				mxc_i2c_devs[i].clock_id);;
+		platform_set_drvdata(pdev, &mxc_i2c_devs[i]);
+	}
+	return 0;
+}
+
+/*!
+ * Dissociates the driver from the I2C device.
+ *
+ * @param   pdev   the device structure used to give information on which I2C
+ *                to remove
+ *
+ * @return  The function always returns 0.
+ */
+static int mxci2c_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxci2c_driver = {
+	.driver = {
+		.name = "mxci2c",
+		.owner = THIS_MODULE,
+	},
+	.probe = mxci2c_probe,
+	.remove = mxci2c_remove,
+	.suspend = mxci2c_suspend,
+	.resume = mxci2c_resume,
+};
+
+/*! Device Definition for MXC I2C devices */
+static struct platform_device mxci2c_devices[I2C_NR] = {
+	[0] = {
+		.name = "mxci2c",
+		.id = 0,
+	},
+#if I2C_NR > 1
+	[1] = {
+		.name = "mxci2c",
+		.id = 1,
+	},
+#if I2C_NR > 2
+	[2] = {
+		.name = "mxci2c",
+		.id = 2,
+	}
+#endif
+#endif
+};
+
+/*!
+ * Function requests the interrupts and registers the i2c adapter structures.
+ *
+ * @return The function returns 0 on success and a non-zero value on failure.
+ */
+static int __init mxc_i2c_init(void)
+{
+	int i, ret = 0, err = 0;
+
+	printk(KERN_INFO "MXC I2C driver\n");
+
+	/* Register the device driver structure. */
+	ret = platform_driver_register(&mxci2c_driver);
+	if (ret != 0)
+		return ret;
+
+	for (i = 0; i < I2C_NR; i++) {
+		/*
+		 * Request the I2C interrupt
+		 */
+		ret = request_irq(mxc_i2c_devs[i].irq, mxc_i2c_handler,
+				0, "MXC I2C", &mxc_i2c_devs[i]);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to request i2c "
+					"interrupt\n", i);
+			err = ret;
+			continue;
+		}
+
+		init_waitqueue_head(&mxc_i2c_devs[i].wq);
+
+		mxc_i2c_devs[i].low_power = false;
+		/*
+		 * Set the adapter information
+		 */
+		strcpy(mxc_i2c_devs[i].adap.name, MXC_ADAPTER_NAME);
+		mxc_i2c_devs[i].adap.id = i;	/* Used by MXC I2C client */
+		mxc_i2c_devs[i].adap.algo = &mxc_i2c_algorithm;
+		mxc_i2c_devs[i].adap.timeout = 1;
+		snprintf(mxc_i2c_devs[i].clock_id,
+				MAX_DRV_CLK_NAME, "%s.%d", "i2c_clk", i);
+		i2c_set_adapdata(&mxc_i2c_devs[i].adap, &mxc_i2c_devs[i]);
+
+		ret = i2c_add_adapter(&mxc_i2c_devs[i].adap);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to register i2c "
+					"adapter\n", i);
+			free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+			err = ret;
+			continue;
+		}
+		/* Register the I2C device */
+		ret = platform_device_register(&mxci2c_devices[i]);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to register i2c "
+					"platform device\n", i);
+			free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+			err = ret;
+		}
+		/*
+		 * Enable the I2C pins
+		 */
+		gpio_i2c_active(i);
+	}
+
+	return err;
+}
+
+/*!
+ * This function is used to cleanup all resources before the driver exits.
+ */
+static void __exit mxc_i2c_exit(void)
+{
+	int i;
+
+	for (i = 0; i < I2C_NR; i++) {
+		gpio_i2c_inactive(i);
+		free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+		i2c_del_adapter(&mxc_i2c_devs[i].adap);
+		platform_driver_unregister(&mxci2c_driver);
+		platform_device_unregister(&mxci2c_devices[i]);
+	}
+}
+
+subsys_initcall(mxc_i2c_init);
+module_exit(mxc_i2c_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC I2C driver");
+MODULE_LICENSE("GPL");
-- 
1.6.0.3

