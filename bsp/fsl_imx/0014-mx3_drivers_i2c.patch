From 3a5c5aa0f2a0ad0ff3ee9cd5d1f337546a118425 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 11:57:08 +0800
Subject: [PATCH] mx3_drivers_i2c

MX3 i2c controller driver.
Add kernel clk interface manipulation.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Add mxc high Speed i2c bus controller driver for i.MX5 MCU. The HS
i2c bus can work at up to 3.4Mbps clock rate.
Modify mxc normal speed i2c bus driver for static power management.
Becase some drivers(like regulator) will use the i2c driver api, so
we should prevent the i2c bus driver from suspending before those
drivers do when in pm operation.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/i2c/busses/Kconfig          |   16 +
 drivers/i2c/busses/Makefile         |    2 +
 drivers/i2c/busses/i2c-mxc.c        |  779 +++++++++++++++++++++++++++++++++++
 drivers/i2c/busses/mxc_i2c_hs.c     |  549 ++++++++++++++++++++++++
 drivers/i2c/busses/mxc_i2c_hs_reg.h |   97 +++++
 5 files changed, 1443 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-mxc.c
 create mode 100644 drivers/i2c/busses/mxc_i2c_hs.c
 create mode 100644 drivers/i2c/busses/mxc_i2c_hs_reg.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..a2582a4 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -504,6 +504,22 @@ config I2C_VERSATILE
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_MXC
+    tristate "MXC I2C support"
+    depends on I2C && ARCH_MXC
+    help
+      If you say yes to this option, support will be included for Freescale
+      MXC I2C modules.
+
+      This driver can also be built as a module.
+
+config I2C_MXC_HS
+	tristate "MXC HIGH SPEED I2C support"
+	depends on I2C && ARCH_MXC
+	help
+	  If you say yes to this option, support will be included for Freescale
+	  MXC HIGH SPEED I2C modules.
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..7906c98 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -46,6 +46,8 @@ obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
 obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
+obj-$(CONFIG_I2C_MXC)		+= i2c-mxc.o
+obj-$(CONFIG_I2C_MXC_HS)	+= mxc_i2c_hs.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
diff --git a/drivers/i2c/busses/i2c-mxc.c b/drivers/i2c/busses/i2c-mxc.c
new file mode 100644
index 0000000..a3fb22d
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mxc.c
@@ -0,0 +1,779 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_i2c.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC I2C buses.
+ *
+ * Based on i2c driver algorithm for PCF8584 adapters
+ *
+ * @ingroup MXCI2C
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+#include <asm/plat-mxc/mxc_i2c.h>
+/*!
+ * Boolean to indicate if data was transferred
+ */
+static bool transfer_done;
+
+/*!
+ * Boolean to indicate if we received an ACK for the data transmitted
+ */
+static bool tx_success;
+
+/*!
+ * This is an array where each element holds information about a I2C module,
+ * like base address, interrupt number etc. This elements of this structure
+ * are stored in the appropriate i2c_adapter structure during the module
+ * initialization.
+ */
+static mxc_i2c_device mxc_i2c_devs[I2C_NR] = {
+	[0] = {
+		.membase = (void *)IO_ADDRESS(I2C_BASE_ADDR),
+		.irq = MXC_INT_I2C,
+		.clkdiv = I2C1_FRQ_DIV,
+	},
+#if I2C_NR > 1
+	[1] = {
+		.membase = (void *)IO_ADDRESS(I2C2_BASE_ADDR),
+		.irq = MXC_INT_I2C2,
+		.clkdiv = I2C2_FRQ_DIV,
+	},
+#if I2C_NR > 2
+	[2] = {
+		.membase = (void *)IO_ADDRESS(I2C3_BASE_ADDR),
+		.irq = MXC_INT_I2C3,
+		.clkdiv = I2C3_FRQ_DIV,
+	}
+#endif
+#endif
+};
+
+/*!
+ * Transmit a \b STOP signal to the slave device.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ */
+static void mxc_i2c_stop(mxc_i2c_device *dev)
+{
+	unsigned int cr;
+	int retry = 16;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	cr &= ~(MXC_I2CR_MSTA | MXC_I2CR_MTX);
+	writew(cr, dev->membase + MXC_I2CR);
+
+	/*
+	 * Make sure STOP meets setup requirement.
+	 */
+	for (;;) {
+		unsigned int sr = readw(dev->membase + MXC_I2SR);
+		if ((sr & MXC_I2SR_IBB) == 0)
+			break;
+		if (retry-- <= 0) {
+			printk(KERN_DEBUG "Bus busy\n");
+			break;
+		}
+		udelay(3);
+	}
+}
+
+/*!
+ * Wait for the transmission of the data byte to complete. This function waits
+ * till we get a signal from the interrupt service routine indicating completion
+ * of the address cycle or we time out.
+ *
+ * @param   dev         the mxc i2c structure used to get to the right i2c device
+ * @param   trans_flag  transfer flag
+ *
+ *
+ * @return  The function returns 0 on success or -1 if an ack was not received
+ */
+
+static int mxc_i2c_wait_for_tc(mxc_i2c_device *dev, int trans_flag)
+{
+	int retry = 16;
+	unsigned int sr, cr;
+
+	if (trans_flag & MXC_I2C_FLAG_POLLING) {
+		/* I2C_POLLING_MODE */
+		unsigned long x = jiffies + dev->adap.timeout * HZ;
+		while (!(readw(dev->membase + MXC_I2SR) & MXC_I2SR_IIF)) {
+			if (unlikely(time_after(jiffies, x))) {
+				/* Poll timeout */
+				retry = -ETIMEDOUT;
+				break;
+			}
+			if (unlikely(signal_pending(current))) {
+				/* Poll interrupted */
+				retry = -ERESTARTSYS;
+				break;
+			}
+			if (!irqs_disabled())
+				schedule();
+		}
+		sr = readw(dev->membase + MXC_I2SR);
+		cr = readw(dev->membase + MXC_I2CR);
+		writew(0, dev->membase + MXC_I2SR);
+
+		tx_success = false;
+		/* Check if RXAK is received in Transmit mode */
+		if ((cr & MXC_I2CR_MTX) && (!(sr & MXC_I2SR_RXAK)))
+			tx_success = true;
+	} else {
+		/* Interrupt mode */
+		while (retry-- && !transfer_done) {
+			wait_event_interruptible_timeout(dev->wq,
+					transfer_done,
+					dev->adap.timeout);
+		}
+		transfer_done = false;
+	}
+	if (retry <= 0) {
+		/* Unable to send data */
+		printk(KERN_DEBUG "Data not transmitted\n");
+		return -1;
+	} else if (!(trans_flag & I2C_M_RD)) {
+		if (!tx_success) {
+			/* An ACK was not received for transmitted byte */
+			printk(KERN_DEBUG "ACK not received \n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * Transmit a \b START signal to the slave device.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address
+ */
+static void mxc_i2c_start(mxc_i2c_device *dev, struct i2c_msg *msg)
+{
+	unsigned int cr, sr;
+	unsigned int addr_trans;
+	int retry = 16;
+
+	/*
+	 * Set the slave address and the requested transfer mode
+	 * in the data register
+	 */
+	addr_trans = msg->addr << 1;
+	if (msg->flags & I2C_M_RD)
+		addr_trans |= 0x01;
+
+	/* Set the Master bit */
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_MSTA;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	/* Wait till the Bus Busy bit is set */
+	sr = readw(dev->membase + MXC_I2SR);
+	while (retry-- && (!(sr & MXC_I2SR_IBB))) {
+		udelay(3);
+		sr = readw(dev->membase + MXC_I2SR);
+	}
+	if (retry <= 0)
+		printk(KERN_DEBUG "Could not grab Bus ownership\n");
+
+	/* Set the Transmit bit */
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_MTX;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	writew(addr_trans, dev->membase + MXC_I2DR);
+}
+
+/*!
+ * Transmit a \b REPEAT START to the slave device
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address
+ */
+static void mxc_i2c_repstart(mxc_i2c_device *dev, struct i2c_msg *msg)
+{
+	unsigned int cr;
+	unsigned int addr_trans;
+
+	/*
+	 * Set the slave address and the requested transfer mode
+	 * in the data register
+	 */
+	addr_trans = msg->addr << 1;
+	if (msg->flags & I2C_M_RD)
+		addr_trans |= 0x01;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	cr |= MXC_I2CR_RSTA;
+	writew(cr, dev->membase + MXC_I2CR);
+	udelay(3);
+	writew(addr_trans, dev->membase + MXC_I2DR);
+}
+
+/*!
+ * Read the received data. The function waits till data is available or times
+ * out. Generates a stop signal if this is the last message to be received.
+ * Sends an ack for all the bytes received except the last byte.
+ *
+ * @param  dev       the mxc i2c structure used to get to the right i2c device
+ * @param  *msg      pointer to a message structure that contains the slave
+ *                   address and a pointer to the receive buffer
+ * @param  last      indicates that this is the last message to be received
+ * @param  addr_comp flag indicates that we just finished the address cycle
+ *
+ * @return  The function returns the number of bytes read or -1 on time out.
+ */
+static int mxc_i2c_readbytes(mxc_i2c_device *dev, struct i2c_msg *msg,
+		int last, int addr_comp)
+{
+	int i;
+	char *buf = msg->buf;
+	int len = msg->len;
+	unsigned int cr;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	/*
+	 * Clear MTX to switch to receive mode.
+	 */
+	cr &= ~MXC_I2CR_MTX;
+	/*
+	 * Clear the TXAK bit to gen an ack when receiving only one byte.
+	 */
+	if (len == 1)
+		cr |= MXC_I2CR_TXAK;
+	else
+		cr &= ~MXC_I2CR_TXAK;
+
+	writew(cr, dev->membase + MXC_I2CR);
+	/*
+	 * Dummy read only at the end of an address cycle
+	 */
+	if (addr_comp > 0)
+		readw(dev->membase + MXC_I2DR);
+
+	for (i = 0; i < len; i++) {
+		/*
+		 * Wait for data transmission to complete
+		 */
+		if (mxc_i2c_wait_for_tc(dev, msg->flags)) {
+			mxc_i2c_stop(dev);
+			return -1;
+		}
+		/*
+		 * Do not generate an ACK for the last byte
+		 */
+		if (i == (len - 2)) {
+			cr = readw(dev->membase + MXC_I2CR);
+			cr |= MXC_I2CR_TXAK;
+			writew(cr, dev->membase + MXC_I2CR);
+		} else if (i == (len - 1)) {
+			if (last)
+				mxc_i2c_stop(dev);
+		}
+		/* Read the data */
+		*buf++ = readw(dev->membase + MXC_I2DR);
+	}
+
+	return i;
+}
+
+/*!
+ * Write the data to the data register. Generates a stop signal if this is
+ * the last message to be sent or if no ack was received for the data sent.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   *msg  pointer to a message structure that contains the slave
+ *                address and data to be sent
+ * @param   last  indicates that this is the last message to be received
+ *
+ * @return  The function returns the number of bytes written or -1 on time out
+ *          or if no ack was received for the data that was sent.
+ */
+static int mxc_i2c_writebytes(mxc_i2c_device *dev, struct i2c_msg *msg,
+		int last)
+{
+	int i;
+	char *buf = msg->buf;
+	int len = msg->len;
+	unsigned int cr;
+
+	cr = readw(dev->membase + MXC_I2CR);
+	/* Set MTX to switch to transmit mode */
+	cr |= MXC_I2CR_MTX;
+	writew(cr, dev->membase + MXC_I2CR);
+
+	for (i = 0; i < len; i++) {
+		/*
+		 * Write the data
+		 */
+		writew(*buf++, dev->membase + MXC_I2DR);
+		if (mxc_i2c_wait_for_tc(dev, msg->flags)) {
+			mxc_i2c_stop(dev);
+			return -1;
+		}
+	}
+
+	if (last > 0)
+		mxc_i2c_stop(dev);
+
+	return i;
+}
+
+/*!
+ * Function enables the I2C module and initializes the registers.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ * @param   trans_flag  transfer flag
+ */
+static void mxc_i2c_module_en(mxc_i2c_device *dev, int trans_flag)
+{
+	clk_enable(dev->clk);
+
+	/* Set the frequency divider */
+	writew(dev->clkdiv, dev->membase + MXC_IFDR);
+	/* Clear the status register */
+	writew(0x0, dev->membase + MXC_I2SR);
+	/* Enable I2C and its interrupts */
+	if (trans_flag & MXC_I2C_FLAG_POLLING)
+		writew(MXC_I2CR_IEN, dev->membase + MXC_I2CR);
+	else {
+		writew(MXC_I2CR_IEN, dev->membase + MXC_I2CR);
+		writew(MXC_I2CR_IEN | MXC_I2CR_IIEN, dev->membase + MXC_I2CR);
+	}
+}
+
+/*!
+ * Disables the I2C module.
+ *
+ * @param   dev   the mxc i2c structure used to get to the right i2c device
+ */
+static void mxc_i2c_module_dis(mxc_i2c_device *dev)
+{
+	writew(0x0, dev->membase + MXC_I2CR);
+	clk_disable(dev->clk);
+}
+
+/*!
+ * The function is registered in the adapter structure. It is called when an MXC
+ * driver wishes to transfer data to a device connected to the I2C device.
+ *
+ * @param   adap   adapter structure for the MXC i2c device
+ * @param   msgs[] array of messages to be transferred to the device
+ * @param   num    number of messages to be transferred to the device
+ *
+ * @return  The function returns the number of messages transferred,
+ *          \b -EREMOTEIO on I2C failure and a 0 if the num argument is
+ *          less than 0.
+ */
+static int mxc_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+		int num)
+{
+	mxc_i2c_device *dev = (mxc_i2c_device *) (i2c_get_adapdata(adap));
+	int i, ret = 0, addr_comp = 0;
+	unsigned int sr;
+
+	if (dev->low_power) {
+		printk(KERN_ERR "I2C Device in low power mode\n");
+		return -EREMOTEIO;
+	}
+
+	if (num < 1)
+		return 0;
+
+	mxc_i2c_module_en(dev, msgs[0].flags);
+	sr = readw(dev->membase + MXC_I2SR);
+	/*
+	 * Check bus state
+	 */
+	if (sr & MXC_I2SR_IBB) {
+		mxc_i2c_module_dis(dev);
+		printk(KERN_DEBUG "Bus busy\n");
+		return -EREMOTEIO;
+	}
+
+	transfer_done = false;
+	tx_success = false;
+
+	for (i = 0; i < num && ret >= 0; i++) {
+		addr_comp = 0;
+		/*
+		 * Send the slave address and transfer direction in the
+		 * address cycle
+		 */
+		if (i == 0) {
+			/*
+			 * Send a start or repeat start signal
+			 */
+			mxc_i2c_start(dev, &msgs[0]);
+			/* Wait for the address cycle to complete */
+			if (mxc_i2c_wait_for_tc(dev, msgs[0].flags)) {
+				mxc_i2c_stop(dev);
+				mxc_i2c_module_dis(dev);
+				return -EREMOTEIO;
+			}
+			addr_comp = 1;
+		} else {
+			/*
+			 * Generate repeat start only if
+			 * required i.e the address
+			 * changed or the transfer direction changed
+			 */
+			if ((msgs[i].addr != msgs[i - 1].addr) ||
+					((msgs[i].flags & I2C_M_RD) !=
+					 (msgs[i - 1].flags & I2C_M_RD))) {
+				mxc_i2c_repstart(dev, &msgs[i]);
+				/* Wait for the address cycle to complete */
+				if (mxc_i2c_wait_for_tc(dev, msgs[i].flags)) {
+					mxc_i2c_stop(dev);
+					mxc_i2c_module_dis(dev);
+					return -EREMOTEIO;
+				}
+				addr_comp = 1;
+			}
+		}
+
+		/* Transfer the data */
+		if (msgs[i].flags & I2C_M_RD) {
+			/* Read the data */
+			ret = mxc_i2c_readbytes(dev, &msgs[i], (i + 1 == num),
+					addr_comp);
+			if (ret < 0) {
+				printk(KERN_ERR "mxc_i2c_readbytes: fail.\n");
+				break;
+			}
+		} else {
+			/* Write the data */
+			ret = mxc_i2c_writebytes(dev, &msgs[i], (i + 1 == num));
+			if (ret < 0) {
+				printk(KERN_ERR "mxc_i2c_writebytes: fail.\n");
+				break;
+			}
+		}
+	}
+
+	mxc_i2c_module_dis(dev);
+	/*
+	 * Decrease by 1 as we do not want Start message to be included in
+	 * the count
+	 */
+	return i - 1;
+}
+
+/*!
+ * Returns the i2c functionality supported by this driver.
+ *
+ * @param   adap adapter structure for this i2c device
+ *
+ * @return Returns the functionality that is supported.
+ */
+static u32 mxc_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/*!
+ * Stores the pointers for the i2c algorithm functions. The algorithm functions
+ * is used by the i2c bus driver to talk to the i2c bus
+ */
+static struct i2c_algorithm mxc_i2c_algorithm = {
+	.master_xfer = mxc_i2c_xfer,
+	.functionality = mxc_i2c_func
+};
+
+/*!
+ * Interrupt Service Routine. It signals to the process about the data transfer
+ * completion. Also sets a flag if bus arbitration is lost.
+ * @param   irq    the interrupt number
+ * @param   dev_id driver private data
+ *
+ * @return  The function returns \b IRQ_HANDLED.
+ */
+static irqreturn_t mxc_i2c_handler(int irq, void *dev_id)
+{
+	mxc_i2c_device *dev = dev_id;
+	unsigned int sr, cr;
+
+	sr = readw(dev->membase + MXC_I2SR);
+	cr = readw(dev->membase + MXC_I2CR);
+
+	/*
+	 * Clear the interrupt bit
+	 */
+	writew(0x0, dev->membase + MXC_I2SR);
+
+	if (sr & MXC_I2SR_IAL)
+		printk(KERN_DEBUG "Bus Arbitration lost\n");
+	else {
+		/* Interrupt due byte transfer completion */
+		tx_success = false;
+		/* Check if RXAK is received in Transmit mode */
+		if ((cr & MXC_I2CR_MTX) && (!(sr & MXC_I2SR_RXAK)))
+			tx_success = true;
+
+		transfer_done = true;
+		wake_up_interruptible(&dev->wq);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is called to put the I2C adapter in
+ * a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel
+ * source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure.
+ */
+static int mxci2c_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mxc_i2c_device *mxcdev = platform_get_drvdata(pdev);
+	unsigned int sr = 0;
+
+	if (mxcdev == NULL)
+		return -1;
+
+	/* Prevent further calls to be processed */
+	mxcdev->low_power = true;
+	/* Wait till we finish the current transfer */
+	sr = readw(mxcdev->membase + MXC_I2SR);
+	while (sr & MXC_I2SR_IBB) {
+		msleep(10);
+		sr = readw(mxcdev->membase + MXC_I2SR);
+	}
+	gpio_i2c_inactive(mxcdev->adap.id);
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the I2C adapter
+ * back from a low power state. Refer
+ * to the document driver-model/driver.txt in the
+ * kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to resume
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxci2c_resume(struct platform_device *pdev)
+{
+	mxc_i2c_device *mxcdev = platform_get_drvdata(pdev);
+
+	if (mxcdev == NULL)
+		return -1;
+
+	mxcdev->low_power = false;
+	gpio_i2c_active(mxcdev->adap.id);
+
+	return 0;
+}
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions
+ *
+ * @return  The function always returns 0.
+ */
+static int mxci2c_probe(struct platform_device *pdev)
+{
+	int id = pdev->id;
+	int i;
+
+	for (i = 0; i < I2C_NR; i++) {
+		/*
+		 * Get the appropriate device structure for this I2C adapter
+		 */
+		if (mxc_i2c_devs[i].adap.id != id || \
+					mxc_i2c_devs[i].adap.algo == NULL)
+			continue;
+
+		mxc_i2c_devs[i].clk = clk_get(&pdev->dev,
+				mxc_i2c_devs[i].clock_id);;
+		platform_set_drvdata(pdev, &mxc_i2c_devs[i]);
+	}
+	return 0;
+}
+
+/*!
+ * Dissociates the driver from the I2C device.
+ *
+ * @param   pdev   the device structure used to give information on which I2C
+ *                to remove
+ *
+ * @return  The function always returns 0.
+ */
+static int mxci2c_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxci2c_driver = {
+	.driver = {
+		.name = "mxci2c",
+		.owner = THIS_MODULE,
+	},
+	.probe = mxci2c_probe,
+	.remove = mxci2c_remove,
+	.suspend_late = mxci2c_suspend,
+	.resume_early = mxci2c_resume,
+};
+
+/*! Device Definition for MXC I2C devices */
+static struct platform_device mxci2c_devices[I2C_NR] = {
+	[0] = {
+		.name = "mxci2c",
+		.id = 0,
+	},
+#if I2C_NR > 1
+	[1] = {
+		.name = "mxci2c",
+		.id = 1,
+	},
+#if I2C_NR > 2
+	[2] = {
+		.name = "mxci2c",
+		.id = 2,
+	}
+#endif
+#endif
+};
+
+/*!
+ * Function requests the interrupts and registers the i2c adapter structures.
+ *
+ * @return The function returns 0 on success and a non-zero value on failure.
+ */
+static int __init mxc_i2c_init(void)
+{
+	int i, ret = 0, err = 0;
+
+	printk(KERN_INFO "MXC I2C driver\n");
+
+	/* Register the device driver structure. */
+	ret = platform_driver_register(&mxci2c_driver);
+	if (ret != 0)
+		return ret;
+
+	for (i = 0; i < I2C_NR; i++) {
+		/*
+		 * Request the I2C interrupt
+		 */
+		ret = request_irq(mxc_i2c_devs[i].irq, mxc_i2c_handler,
+				0, "MXC I2C", &mxc_i2c_devs[i]);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to request i2c "
+					"interrupt\n", i);
+			err = ret;
+			continue;
+		}
+
+		init_waitqueue_head(&mxc_i2c_devs[i].wq);
+
+		mxc_i2c_devs[i].low_power = false;
+		/*
+		 * Set the adapter information
+		 */
+		strcpy(mxc_i2c_devs[i].adap.name, MXC_ADAPTER_NAME);
+		mxc_i2c_devs[i].adap.id = i;	/* Used by MXC I2C client */
+		mxc_i2c_devs[i].adap.nr = i; /* assign bus num for this adapter*/
+		mxc_i2c_devs[i].adap.algo = &mxc_i2c_algorithm;
+		mxc_i2c_devs[i].adap.timeout = 1;
+		snprintf(mxc_i2c_devs[i].clock_id,
+				MAX_DRV_CLK_NAME, "%s.%d", "i2c_clk", i);
+		i2c_set_adapdata(&mxc_i2c_devs[i].adap, &mxc_i2c_devs[i]);
+
+		ret = i2c_add_numbered_adapter(&mxc_i2c_devs[i].adap);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to register i2c "
+					"adapter\n", i);
+			free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+			err = ret;
+			continue;
+		}
+		/* Register the I2C device */
+		ret = platform_device_register(&mxci2c_devices[i]);
+		if (ret != 0) {
+			printk(KERN_CRIT "mxc-i2c%d: failed to register i2c "
+					"platform device\n", i);
+			free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+			err = ret;
+		}
+		/*
+		 * Enable the I2C pins
+		 */
+		gpio_i2c_active(i);
+	}
+
+	return err;
+}
+
+/*!
+ * This function is used to cleanup all resources before the driver exits.
+ */
+static void __exit mxc_i2c_exit(void)
+{
+	int i;
+
+	for (i = 0; i < I2C_NR; i++) {
+		gpio_i2c_inactive(i);
+		free_irq(mxc_i2c_devs[i].irq, &mxc_i2c_devs[i]);
+		i2c_del_adapter(&mxc_i2c_devs[i].adap);
+		platform_driver_unregister(&mxci2c_driver);
+		platform_device_unregister(&mxci2c_devices[i]);
+	}
+}
+
+subsys_initcall(mxc_i2c_init);
+module_exit(mxc_i2c_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC I2C driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/mxc_i2c_hs.c b/drivers/i2c/busses/mxc_i2c_hs.c
new file mode 100644
index 0000000..b913235
--- /dev/null
+++ b/drivers/i2c/busses/mxc_i2c_hs.c
@@ -0,0 +1,549 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include "mxc_i2c_hs_reg.h"
+
+typedef struct {
+	struct device *dev;
+
+	unsigned long reg_base_virt;
+	unsigned long reg_base_phy;
+	int irq;
+	unsigned int speed;
+	struct clk *ipg_clk;
+	struct clk *serial_clk;
+	bool low_power;
+
+	struct i2c_msg *msg;
+	int index;
+} mxc_i2c_hs;
+
+struct clk_div_table {
+	int reg_value;
+	int div;
+};
+
+static const struct clk_div_table i2c_clk_table[] = {
+	{0x0, 16}, {0x1, 18}, {0x2, 20}, {0x3, 22},
+	{0x20, 24}, {0x21, 26}, {0x22, 28}, {0x23, 30},
+	{0x4, 32}, {0x5, 36}, {0x6, 40}, {0x7, 44},
+	{0x24, 48}, {0x25, 52}, {0x26, 56}, {0x27, 60},
+	{0x8, 64}, {0x9, 72}, {0xa, 80}, {0xb, 88},
+	{0x28, 96}, {0x29, 104}, {0x2a, 112}, {0x2b, 120},
+	{0xc, 128}, {0xd, 144}, {0xe, 160}, {0xf, 176},
+	{0x2c, 192}, {0x2d, 208}, {0x2e, 224}, {0x2f, 240},
+	{0x10, 256}, {0x11, 288}, {0x12, 320}, {0x13, 352},
+	{0x30, 384}, {0x31, 416}, {0x32, 448}, {0x33, 480},
+	{0x14, 512}, {0x15, 576}, {0x16, 640}, {0x17, 704},
+	{0x34, 768}, {0x35, 832}, {0x36, 896}, {0x37, 960},
+	{0x18, 1024}, {0x19, 1152}, {0x1a, 1280}, {0x1b, 1408},
+	{0x38, 1536}, {0x39, 1664}, {0x3a, 1792}, {0x3b, 1920},
+	{0x1c, 2048}, {0x1d, 2304}, {0x1e, 2560}, {0x1f, 2816},
+	{0x3c, 3072}, {0x3d, 3328}, {0x3E, 3584}, {0x3F, 3840},
+	{-1, -1}
+};
+
+static struct i2c_adapter *adap;
+
+extern void gpio_i2c_hs_inactive(void);
+extern void gpio_i2c_hs_active(void);
+
+static u16 reg_read(mxc_i2c_hs *i2c_hs, u32 reg_offset)
+{
+	return __raw_readw(i2c_hs->reg_base_virt + reg_offset);
+}
+
+static void reg_write(mxc_i2c_hs *i2c_hs, u32 reg_offset, u16 data)
+{
+	__raw_writew(data, i2c_hs->reg_base_virt + reg_offset);
+}
+
+static void reg_set_mask(mxc_i2c_hs *i2c_hs, u32 reg_offset, u16 mask)
+{
+	u16 value;
+
+	value = reg_read(i2c_hs, reg_offset);
+	value |= mask;
+	reg_write(i2c_hs, reg_offset, value);
+}
+static void reg_clear_mask(mxc_i2c_hs *i2c_hs, u32 reg_offset, u16 mask)
+{
+	u16 value;
+
+	value = reg_read(i2c_hs, reg_offset);
+	value &= ~mask;
+	reg_write(i2c_hs, reg_offset, value);
+}
+
+static void mxci2c_hs_set_div(mxc_i2c_hs *i2c_hs)
+{
+	unsigned long clk_freq;
+	int i;
+	int div = -1;;
+
+	clk_freq = clk_get_rate(i2c_hs->serial_clk);
+	if (i2c_hs->speed) {
+		div = (clk_freq + i2c_hs->speed - 1) / i2c_hs->speed;
+		for (i = 0; i2c_clk_table[i].div >= 0; i++) {
+			if (i2c_clk_table[i].div >= div) {
+				div = i2c_clk_table[i].reg_value;
+				reg_write(i2c_hs, HIFSFDR, div);
+				break;
+			}
+		}
+	}
+}
+
+static int mxci2c_hs_enable(mxc_i2c_hs *i2c_hs)
+{
+	gpio_i2c_hs_active();
+	clk_enable(i2c_hs->ipg_clk);
+	clk_enable(i2c_hs->serial_clk);
+	mxci2c_hs_set_div(i2c_hs);
+	reg_write(i2c_hs, HICR, reg_read(i2c_hs, HICR) | HICR_HIEN);
+
+	return 0;
+}
+
+static int mxci2c_hs_disable(mxc_i2c_hs *i2c_hs)
+{
+	reg_write(i2c_hs, HICR, reg_read(i2c_hs, HICR) & (~HICR_HIEN));
+	clk_disable(i2c_hs->ipg_clk);
+	clk_disable(i2c_hs->serial_clk);
+
+	return 0;
+}
+
+static int mxci2c_hs_bus_busy(mxc_i2c_hs *i2c_hs)
+{
+	u16 value;
+	int retry = 1000;
+
+	while (retry--) {
+		value = reg_read(i2c_hs, HISR);
+		if (value & HISR_HIBB) {
+			udelay(1);
+		} else {
+			break;
+		}
+	}
+
+	if (retry <= 0) {
+		dev_dbg(NULL, "%s: Bus Busy!\n", __func__);
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static int mxci2c_hs_start(mxc_i2c_hs *i2c_hs, int repeat_start, u16 address)
+{
+	u16 mask;
+	int ret = 0;
+
+	mxci2c_hs_bus_busy(i2c_hs);
+
+	/*7 bit address */
+	reg_clear_mask(i2c_hs, HICR, HICR_ADDR_MODE);
+
+	/*send start */
+	if (repeat_start)
+		mask = HICR_RSTA;
+	else
+		mask = HICR_MSTA;
+	reg_set_mask(i2c_hs, HICR, mask);
+
+	return ret;
+}
+
+static int mxci2c_hs_stop(mxc_i2c_hs *i2c_hs)
+{
+	reg_clear_mask(i2c_hs, HICR, HICR_MSTA);
+	reg_clear_mask(i2c_hs, HICR, HICR_HIIEN);
+
+	return 0;
+}
+
+static int mxci2c_wait_writefifo(mxc_i2c_hs *i2c_hs)
+{
+	int i, num, left;
+	int retry, ret = 0;
+
+	retry = 10000;
+	while (retry--) {
+		udelay(10);
+		if (reg_read(i2c_hs, HISR) & (HISR_TDE | HISR_TDC_ZERO)) {
+			if (i2c_hs->index < i2c_hs->msg->len) {
+				left = i2c_hs->msg->len - i2c_hs->index;
+				num =
+				    (left >
+				     HITFR_MAX_COUNT) ? HITFR_MAX_COUNT : left;
+				for (i = 0; i < num; i++) {
+					reg_write(i2c_hs, HITDR,
+						  i2c_hs->msg->buf[i2c_hs->
+								   index + i]);
+				}
+				i2c_hs->index += num;
+			} else {
+				if (reg_read(i2c_hs, HISR) & HISR_TDC_ZERO) {
+					msleep(1);
+					break;
+				}
+			}
+		}
+	}
+
+	if (retry <= 0) {
+		printk(KERN_ERR "%s:wait error\n", __func__);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int mxci2c_wait_readfifo(mxc_i2c_hs *i2c_hs)
+{
+	int i, num, left;
+	int retry, ret = 0;
+	u16 value;
+
+	retry = 10000;
+	while (retry--) {
+		udelay(10);
+		value = reg_read(i2c_hs, HISR);
+		if (value & (HISR_RDF | HISR_RDC_ZERO)) {
+			if (i2c_hs->index < i2c_hs->msg->len) {
+				left = i2c_hs->msg->len - i2c_hs->index;
+				num =
+				    (left >
+				     HITFR_MAX_COUNT) ? HITFR_MAX_COUNT : left;
+				for (i = 0; i < num; i++) {
+					i2c_hs->msg->buf[i2c_hs->index + i] =
+					    reg_read(i2c_hs, HIRDR);
+				}
+				i2c_hs->index += num;
+			} else {
+				if (value & HISR_RDC_ZERO) {
+					break;
+				}
+			}
+		}
+	}
+
+	if (retry <= 0) {
+		printk(KERN_ERR "%s:wait error\n", __func__);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int mxci2c_hs_read(mxc_i2c_hs *i2c_hs, int repeat_start,
+			  struct i2c_msg *msg)
+{
+	int ret;
+
+	if (msg->len > HIRDCR_MAX_COUNT) {
+		printk(KERN_ERR "%s: error: msg too long, max longth 256\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = 0;
+	i2c_hs->msg = msg;
+	i2c_hs->index = 0;
+
+	/*set address */
+	reg_write(i2c_hs, HIMADR, HIMADR_LSB_ADR(msg->addr));
+
+	/*receive mode */
+	reg_clear_mask(i2c_hs, HICR, HICR_MTX);
+
+	reg_clear_mask(i2c_hs, HICR, HICR_HIIEN);
+
+	 /*FIFO*/ reg_set_mask(i2c_hs, HIRFR, HIRFR_RFEN | HIRFR_RFWM(7));
+	reg_set_mask(i2c_hs, HIRFR, HIRFR_RFLSH);
+
+	 /*TDCR*/
+	    reg_write(i2c_hs, HIRDCR, HIRDCR_RDC_EN | HIRDCR_RDC(msg->len));
+
+	mxci2c_hs_start(i2c_hs, repeat_start, msg->addr);
+
+	ret = mxci2c_wait_readfifo(i2c_hs);
+
+	if (ret < 0)
+		return ret;
+	else
+		return msg->len;
+}
+
+static int mxci2c_hs_write(mxc_i2c_hs *i2c_hs, int repeat_start,
+			   struct i2c_msg *msg)
+{
+	int ret, i;
+
+	if (msg->len > HITDCR_MAX_COUNT) {
+		printk(KERN_ERR "%s: error: msg too long, max longth 256\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = 0;
+	i2c_hs->msg = msg;
+	i2c_hs->index = 0;
+
+	/*set address */
+	reg_write(i2c_hs, HIMADR, HIMADR_LSB_ADR(msg->addr));
+
+	/*transmit mode */
+	reg_set_mask(i2c_hs, HICR, HICR_MTX);
+
+	reg_clear_mask(i2c_hs, HICR, HICR_HIIEN);
+
+	/* TDCR */
+	reg_write(i2c_hs, HITDCR, HITDCR_TDC_EN | HITDCR_TDC(msg->len));
+
+	/* FIFO */
+	reg_set_mask(i2c_hs, HITFR, HITFR_TFEN);
+	reg_set_mask(i2c_hs, HITFR, HITFR_TFLSH);
+
+	if (msg->len > HITFR_MAX_COUNT)
+		i2c_hs->index = HITFR_MAX_COUNT;
+	else {
+		i2c_hs->index = msg->len;
+	}
+
+	for (i = 0; i < i2c_hs->index; i++) {
+		reg_write(i2c_hs, HITDR, msg->buf[i]);
+	}
+
+	mxci2c_hs_start(i2c_hs, repeat_start, msg->addr);
+
+	ret = mxci2c_wait_writefifo(i2c_hs);
+
+	if (ret < 0)
+		return ret;
+	else
+		return msg->len;
+}
+
+static int mxci2c_hs_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+			  int num)
+{
+	int i;
+	int ret = -EIO;
+
+	mxc_i2c_hs *i2c_hs = (mxc_i2c_hs *) (i2c_get_adapdata(adap));
+
+	if (i2c_hs->low_power) {
+		dev_err(&adap->dev, "I2C Device in low power mode\n");
+		return -EREMOTEIO;
+	}
+
+	if (num < 1) {
+		return 0;
+	}
+
+	mxci2c_hs_enable(i2c_hs);
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].flags & I2C_M_RD) {
+			ret = mxci2c_hs_read(i2c_hs, 0, &msgs[i]);
+			if (ret < 0)
+				break;
+		} else {
+			ret = mxci2c_hs_write(i2c_hs, 0, &msgs[i]);
+			if (ret < 0)
+				break;
+		}
+		mxci2c_hs_stop(i2c_hs);
+	}
+	mxci2c_hs_stop(i2c_hs);
+
+	mxci2c_hs_disable(i2c_hs);
+
+	if (ret < 0)
+		return ret;
+
+	return i;
+}
+
+static u32 mxci2c_hs_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/*!
+ * Stores the pointers for the i2c algorithm functions. The algorithm functions
+ * is used by the i2c bus driver to talk to the i2c bus
+ */
+static struct i2c_algorithm mxci2c_hs_algorithm = {
+	.master_xfer = mxci2c_hs_xfer,
+	.functionality = mxci2c_hs_func
+};
+
+static int mxci2c_hs_probe(struct platform_device *pdev)
+{
+	mxc_i2c_hs *i2c_hs;
+	struct mxc_i2c_platform_data *i2c_plat_data = pdev->dev.platform_data;
+	struct resource *res;
+	int id = pdev->id;
+	int ret = 0;
+
+	i2c_hs = kzalloc(sizeof(mxc_i2c_hs), GFP_KERNEL);
+	if (!i2c_hs) {
+		return -ENOMEM;
+	}
+
+	i2c_hs->dev = &pdev->dev;
+
+	i2c_hs->speed = i2c_plat_data->i2c_clk;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err1;
+	}
+	i2c_hs->reg_base_virt = IO_ADDRESS(res->start);
+	i2c_hs->reg_base_phy = res->start;
+
+	i2c_hs->ipg_clk = clk_get(&pdev->dev, "hsi2c_clk");
+	i2c_hs->serial_clk = clk_get(&pdev->dev, "hsi2c_serial_clk");
+
+	/*
+	 * Request the I2C interrupt
+	 */
+	i2c_hs->irq = platform_get_irq(pdev, 0);
+	if (i2c_hs->irq < 0) {
+		ret = i2c_hs->irq;
+		goto err1;
+	}
+
+	i2c_hs->low_power = false;
+
+	/*
+	 * Set the adapter information
+	 */
+	adap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
+	if (!adap) {
+		ret = -ENODEV;
+		goto err1;
+	}
+	strlcpy(adap->name, pdev->name, 48);
+	adap->id = adap->nr = id;
+	adap->algo = &mxci2c_hs_algorithm;
+	adap->timeout = 1;
+	platform_set_drvdata(pdev, i2c_hs);
+	i2c_set_adapdata(adap, i2c_hs);
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	printk(KERN_INFO "MXC HS I2C driver\n");
+	return 0;
+
+      err2:
+	kfree(adap);
+      err1:
+	dev_err(&pdev->dev, "failed to probe high speed i2c adapter\n");
+	kfree(i2c_hs);
+	return ret;
+}
+
+static int mxci2c_hs_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mxc_i2c_hs *i2c_hs = platform_get_drvdata(pdev);
+
+	if (i2c_hs == NULL) {
+		return -1;
+	}
+
+	/* Prevent further calls to be processed */
+	i2c_hs->low_power = true;
+
+	gpio_i2c_hs_inactive();
+
+	return 0;
+}
+
+static int mxci2c_hs_resume(struct platform_device *pdev)
+{
+	mxc_i2c_hs *i2c_hs = platform_get_drvdata(pdev);
+
+	if (i2c_hs == NULL)
+		return -1;
+
+	i2c_hs->low_power = false;
+	gpio_i2c_hs_active();
+
+	return 0;
+}
+
+static int mxci2c_hs_remove(struct platform_device *pdev)
+{
+	mxc_i2c_hs *i2c_hs = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(adap);
+	gpio_i2c_hs_inactive();
+	platform_set_drvdata(pdev, NULL);
+	kfree(i2c_hs);
+	return 0;
+}
+
+static struct platform_driver mxci2c_hs_driver = {
+	.driver = {
+		   .name = "mxc_i2c_hs",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxci2c_hs_probe,
+	.remove = mxci2c_hs_remove,
+	.suspend = mxci2c_hs_suspend,
+	.resume = mxci2c_hs_resume,
+};
+
+/*!
+ * Function requests the interrupts and registers the i2c adapter structures.
+ *
+ * @return The function returns 0 on success and a non-zero value on failure.
+ */
+static int __init mxci2c_hs_init(void)
+{
+	/* Register the device driver structure. */
+	return platform_driver_register(&mxci2c_hs_driver);
+}
+
+/*!
+ * This function is used to cleanup all resources before the driver exits.
+ */
+static void __exit mxci2c_hs_exit(void)
+{
+	platform_driver_unregister(&mxci2c_hs_driver);
+}
+
+subsys_initcall(mxci2c_hs_init);
+module_exit(mxci2c_hs_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC HIGH SPEED I2C driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/mxc_i2c_hs_reg.h b/drivers/i2c/busses/mxc_i2c_hs_reg.h
new file mode 100644
index 0000000..fe6bb9a
--- /dev/null
+++ b/drivers/i2c/busses/mxc_i2c_hs_reg.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MXC_I2C_HS_REG_H__
+#define __MXC_I2C_HS_REG_H__
+
+#define	HISADR        0x00
+
+#define	HIMADR        0x04
+#define	HIMADR_LSB_ADR(x) ((x) << 1)
+#define	HIMADR_MSB_ADR(x) (((x) & 0x7) << 8)
+
+#define	HICR          0x08
+#define	HICR_HIEN	0x1
+#define	HICR_DMA_EN_RX 0x2
+#define	HICR_DMA_EN_TR 0x4
+#define	HICR_RSTA 0x8
+#define	HICR_TXAK 0x10
+#define	HICR_MTX 0x20
+#define	HICR_MSTA 0x40
+#define	HICR_HIIEN 0x80
+#define	HICR_ADDR_MODE 0x100
+#define	HICR_MST_CODE(x) (((x)&0x7) << 9)
+#define	HICR_HSM_EN 0x1000
+#define	HICR_SAMC(x) (((x)&0x3) << 13)
+#define 	SAMC_7_10 	0
+#define	SMAC_7		1
+#define	SMAC_10		2
+
+#define  HISR          0x0c
+#define 	HISR_RDF		0x1
+#define 	HISR_TDE		0x2
+#define 	HISR_HIAAS	0x4
+#define 	HISR_HIAL	0x8
+#define 	HISR_BTD		0x10
+#define 	HISR_RDC_ZERO	0x20
+#define 	HISR_TDC_ZERO	0x40
+#define 	HISR_RXAK		0x80
+#define 	HISR_HIBB		0x100
+#define 	HISR_SRW		0x200
+#define 	HISR_SADDR_MODE	0x400
+#define 	HISR_SHS_MODE	0x800
+
+#define  HIIMR         0x10
+#define  	HIIMR_RDF	0x1
+#define  	HIIMR_TDE	0x2
+#define  	HIIMR_AAS	0x4
+#define  	HIIMR_AL	0x8
+#define  	HIIMR_BTD	0x10
+#define  	HIIMR_RDC	0x20
+#define  	HIIMR_TDC	0x40
+#define  	HIIMR_RXAK	0x80
+
+#define  HITDR         0x14
+
+#define  HIRDR         0x18
+
+#define  HIFSFDR       0x1c
+
+#define  HIHSFDR       0x20
+
+#define  HITFR         0x24
+#define	HITFR_TFEN		0x1
+#define	HITFR_TFLSH	0x2
+#define	HITFR_TFWM(x) (((x) & 0x7) << 2)
+#define	HITFR_TFC(x)	(((x) >> 8) & 0xF)
+#define	HITFR_MAX_COUNT 8
+
+#define  HIRFR         0x28
+#define  	HIRFR_RFEN			0x1
+#define  	HIRFR_RFLSH		0x2
+#define  	HIRFR_RFWM(x)	 	(((x) & 0x7) << 2)
+#define  	HIRFR_RFC(x) 		(((x) >> 8) & 0xF)
+#define	HIRFR_MAX_COUNT 8
+
+#define  HITDCR        0x2c
+#define	HITDCR_TDC(x)		((x) & 0xFF)
+#define	HITDCR_TDC_EN	0x100
+#define	HITDCR_TDC_RSTA	0x200
+#define	HITDCR_MAX_COUNT 0xFF
+
+#define  HIRDCR        0x30
+#define	HIRDCR_RDC(x)		((x) & 0xFF)
+#define	HIRDCR_RDC_EN	0x100
+#define	HIRDCR_RDC_RSTA	0x200
+#define	HIRDCR_MAX_COUNT 0xFF
+
+#endif
-- 
1.5.5.1

