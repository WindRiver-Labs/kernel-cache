>From d37692ec8eeb6e574f2e149c038f372c3f37f016 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 5 Aug 2013 13:37:38 +0800
Subject: [PATCH] mxc/ts: Correctly exit the kernel thread while exiting the module

The touchscreen driver creates a kernel daemon to monitor
the operation of touchscreen, however, the driver don't
exit the kernel thread correctly while exiting the module,
so when this driver is built into kernel module, this kernel
thread keeps increasing when insmod/rmmod continuously and
all these kernel threads become zombie process.

Fix this problem by sending a SIGKILL signal to the kernel
daemon while the module is exiting.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/input/touchscreen/imx_adc_ts.c |    7 +++++--
 drivers/input/touchscreen/mxc_ts.c     |    5 ++++-
 drivers/mxc/adc/imx_adc.c              |   12 ++++++++++--
 3 files changed, 19 insertions(+), 5 deletions(-)

diff --git a/drivers/input/touchscreen/imx_adc_ts.c b/drivers/input/touchscreen/imx_adc_ts.c
index ec43a16..19a6aee 100644
--- a/drivers/input/touchscreen/imx_adc_ts.c
+++ b/drivers/input/touchscreen/imx_adc_ts.c
@@ -40,19 +40,21 @@
 
 static struct input_dev *imx_inputdev;
 static u32 input_ts_installed;
+static struct task_struct *imx_thread;
 
 static int ts_thread(void *arg)
 {
 	struct t_touch_screen ts_sample;
 	int wait = 0;
+
 	daemonize("imx_adc_ts");
+	allow_signal(SIGKILL);
 	while (input_ts_installed) {
 		try_to_freeze();
 
 		memset(&ts_sample, 0, sizeof(ts_sample));
 		if (0 != imx_adc_get_touch_sample(&ts_sample, !wait))
 			continue;
-
 		input_report_abs(imx_inputdev, ABS_X, ts_sample.x_position);
 		input_report_abs(imx_inputdev, ABS_Y, ts_sample.y_position);
 		input_report_abs(imx_inputdev, ABS_PRESSURE,
@@ -90,13 +92,14 @@ static int __init imx_adc_ts_init(void)
 	}
 
 	input_ts_installed = 1;
-	kthread_run(ts_thread, NULL, "ts_thread");
+	imx_thread = kthread_run(ts_thread, NULL, "ts_thread");
 	pr_info("i.MX ADC input touchscreen loaded.\n");
 	return 0;
 }
 
 static void __exit imx_adc_ts_exit(void)
 {
+	send_sig(SIGKILL, imx_thread, 1);
 	input_ts_installed = 0;
 	input_unregister_device(imx_inputdev);
 
diff --git a/drivers/input/touchscreen/mxc_ts.c b/drivers/input/touchscreen/mxc_ts.c
index b60735a..568f9c4 100644
--- a/drivers/input/touchscreen/mxc_ts.c
+++ b/drivers/input/touchscreen/mxc_ts.c
@@ -40,6 +40,7 @@
 
 static struct input_dev *mxc_inputdev;
 static u32 input_ts_installed;
+static pid_t mxc_thread;
 
 static int ts_thread(void *arg)
 {
@@ -47,6 +48,7 @@ static int ts_thread(void *arg)
 	s32 wait = 0;
 
 	daemonize("mxc_ts");
+	allow_signal(SIGKILL);
 	while (input_ts_installed) {
 		try_to_freeze();
 		memset(&ts_sample, 0, sizeof(t_touch_screen));
@@ -94,13 +96,14 @@ static int __init mxc_ts_init(void)
 	}
 
 	input_ts_installed = 1;
-	kernel_thread(ts_thread, NULL, CLONE_VM | CLONE_FS);
+	mxc_thread = kernel_thread(ts_thread, NULL, CLONE_VM | CLONE_FS);
 	printk("mxc input touchscreen loaded\n");
 	return 0;
 }
 
 static void __exit mxc_ts_exit(void)
 {
+	send_sig(SIGKILL, find_task_by_vpid(mxc_thread), 1);
 	input_ts_installed = 0;
 	input_unregister_device(mxc_inputdev);
 
diff --git a/drivers/mxc/adc/imx_adc.c b/drivers/mxc/adc/imx_adc.c
index 94b90ef..b9ba706 100644
--- a/drivers/mxc/adc/imx_adc.c
+++ b/drivers/mxc/adc/imx_adc.c
@@ -288,9 +288,13 @@ enum IMX_ADC_STATUS imx_adc_read_ts(struct t_touch_screen *touch_sample,
 		__raw_writel(reg, tsc_base + TCQMR);
 
 		wait_event_interruptible(tsq, ts_data_ready);
-		while (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ))
+		while (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ) && !signal_pending(current))
 			continue;
 
+		/* This indicates a SIGKILL signal is received */
+		if (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ))
+			return IMX_ADC_ERROR;
+
 		/* stop the conversion */
 		reg = __raw_readl(tsc_base + TCQCR);
 		reg &= ~CQCR_QSM_MASK;
@@ -319,9 +323,13 @@ enum IMX_ADC_STATUS imx_adc_read_ts(struct t_touch_screen *touch_sample,
 		reg = __raw_readl(tsc_base + TCQCR);
 		reg |= CQCR_FQS;
 		__raw_writel(reg, tsc_base + TCQCR);
-		while (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ))
+		while (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ) && !signal_pending(current))
 			continue;
 
+		/* This indicates a SIGKILL signal is received */
+		if (!(__raw_readl(tsc_base + TCQSR) & CQSR_EOQ))
+			return IMX_ADC_ERROR;
+
 		/* stop FQS */
 		reg = __raw_readl(tsc_base + TCQCR);
 		reg &= ~CQCR_QSM_MASK;
-- 
1.7.0.5

