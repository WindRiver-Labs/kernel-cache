From c188b9edbe5e2049ca4f4ffbeb25b6448af01b70 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Wed, 29 Oct 2008 16:31:50 +0800
Subject: [PATCH] imx_drivers_mx3_hmp4e

MX3 MPEG4 Encoder driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/hmp4e/Kconfig     |   14 +
 drivers/mxc/hmp4e/Makefile    |    5 +
 drivers/mxc/hmp4e/mxc_hmp4e.c |  689 +++++++++++++++++++++++++++++++++++++++++
 drivers/mxc/hmp4e/mxc_hmp4e.h |   69 ++++
 4 files changed, 777 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/hmp4e/Kconfig
 create mode 100644 drivers/mxc/hmp4e/Makefile
 create mode 100644 drivers/mxc/hmp4e/mxc_hmp4e.c
 create mode 100644 drivers/mxc/hmp4e/mxc_hmp4e.h

diff --git a/drivers/mxc/hmp4e/Kconfig b/drivers/mxc/hmp4e/Kconfig
new file mode 100644
index 0000000..3ba929b
--- /dev/null
+++ b/drivers/mxc/hmp4e/Kconfig
@@ -0,0 +1,14 @@
+#
+# MPEG4 Encoder kernel module  configuration
+#
+
+menu "MXC MPEG4 Encoder Kernel module support"
+
+config MXC_HMP4E
+	tristate "MPEG4 Encoder support"
+	depends on ARCH_MX3
+	---help---
+	  Say Y to get the MPEG4 Encoder kernel module available on MXC platform.
+
+endmenu
+
diff --git a/drivers/mxc/hmp4e/Makefile b/drivers/mxc/hmp4e/Makefile
new file mode 100644
index 0000000..4948175
--- /dev/null
+++ b/drivers/mxc/hmp4e/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the MPEG4 Encoder kernel module.
+
+obj-$(CONFIG_MXC_HMP4E) 		+= mxc_hmp4e.o
+
diff --git a/drivers/mxc/hmp4e/mxc_hmp4e.c b/drivers/mxc/hmp4e/mxc_hmp4e.c
new file mode 100644
index 0000000..7c44b8f
--- /dev/null
+++ b/drivers/mxc/hmp4e/mxc_hmp4e.c
@@ -0,0 +1,689 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+/*
+ * Encoder device driver (kernel module)
+ *
+ * Copyright (C) 2005  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/pm.h>
+
+#include <mach/hardware.h>
+#include "mxc_hmp4e.h"
+
+/* when base address not page aligned */
+#define NON_PAGE_ALIGNED        1
+/* use consistent_alloc */
+#define CONS_ALLOC              1
+#if CONS_ALLOC
+static u32 hmp4e_phys;
+#endif
+
+#define APM_HMP4E 0
+/* use apm for hmp4e driver
+   note, after hmp4e is inserted,
+   apm level will be set to LOW, i.e.
+   HCLK >= 88MHz, in order to acheive 30fps */
+
+/* module description */
+MODULE_AUTHOR("Hantro Products Oy");
+MODULE_DESCRIPTION("Device driver for Hantro's MPEG4 encoder HW");
+MODULE_SUPPORTED_DEVICE("4400 MPEG4 Encoder");
+MODULE_LICENSE("GPL");
+
+/* these could be module params in the future */
+
+#define ENC_IO_SIZE                 (16*4)	/* bytes */
+#define HMP4E_BUF_SIZE              512000	/* bytes */
+
+#define ENC_HW_ID                   0x00001882
+
+unsigned long base_port = MPEG4_ENC_BASE_ADDR;
+unsigned int irq = INT_MPEG4_ENC;
+
+module_param(base_port, long, 000);
+module_param(irq, int, 000);
+
+/* and this is our MAJOR; use 0 for
+ * dynamic allocation (recommended)*/
+static int hmp4e_major;
+
+static struct class *hmp4e_class;
+
+/* For module reference count */
+static int count;
+
+/* here's all the must remember stuff */
+typedef struct {
+	char *buffer;
+	unsigned int buffsize;
+	unsigned long iobaseaddr;
+	unsigned int iosize;
+	volatile u32 *hwregs;
+	unsigned int irq;
+	struct fasync_struct *async_queue;
+} hmp4e_t;
+
+static hmp4e_t hmp4e_data;	/* dynamic allocation? */
+
+/*
+ * avoid "enable_irq(x) unbalanced from ..."
+ * error messages from the kernel, since {ena,dis}able_irq()
+ * calls are stacked in kernel.
+ */
+static bool irq_enable;
+
+static int AllocMemory(void);
+static void FreeMemory(void);
+
+static int ReserveIO(void);
+static void ReleaseIO(void);
+
+static int MapBuffers(struct file *filp, struct vm_area_struct *vma);
+static int MapHwRegs(struct file *filp, struct vm_area_struct *vma);
+static void ResetAsic(hmp4e_t *dev);
+
+/* local */
+static void hmp4ehw_clock_enable(void);
+static void hmp4ehw_clock_disable(void);
+/*readable by other modules through ipc */
+/*static int g_hmp4e_busy = 0;*/
+
+static irqreturn_t hmp4e_isr(int irq, void *dev_id);
+
+/* VM operations */
+static struct page *hmp4e_vm_nopage(struct vm_area_struct *vma,
+		unsigned long address, int *write_access)
+{
+	printk(KERN_INFO "hmp4e_vm_nopage: problem with mem access\n");
+	return NOPAGE_SIGBUS;	/* send a SIGBUS */
+}
+
+static void hmp4e_vm_open(struct vm_area_struct *vma)
+{
+	count++;
+	printk(KERN_INFO "hmp4e_vm_open:\n");
+}
+
+static void hmp4e_vm_close(struct vm_area_struct *vma)
+{
+	count--;
+	printk(KERN_INFO "hmp4e_vm_close:\n");
+}
+
+static struct vm_operations_struct hmp4e_vm_ops = {
+		.open = hmp4e_vm_open,
+		.close = hmp4e_vm_close,
+		.nopage = hmp4e_vm_nopage,
+};
+
+/* the device's mmap method. The VFS has kindly prepared the process's
+ * vm_area_struct for us, so we examine this to see what was requested.
+ */
+static int hmp4e_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int result;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+#if NON_PAGE_ALIGNED
+	int ofs;
+
+	ofs = hmp4e_data.iobaseaddr & (PAGE_SIZE - 1);
+#endif
+
+	printk(KERN_INFO "hmp4e_mmap: size = %lu off = 0x%08lx\n",
+			vma->vm_end - vma->vm_start, offset);
+
+	if (offset == 0)
+		result = MapBuffers(filp, vma);
+#if NON_PAGE_ALIGNED
+	else if (offset == hmp4e_data.iobaseaddr - ofs)
+#else
+	else if (offset == hmp4e_data.iobaseaddr)
+#endif
+		result = MapHwRegs(filp, vma);
+	else
+		result = -EINVAL;
+
+	if (result == 0) {
+		vma->vm_ops = &hmp4e_vm_ops;
+		/* open is not implicitly called when mmap is called */
+		hmp4e_vm_open(vma);
+	}
+
+	return result;
+}
+
+static int hmp4e_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+
+	printk(KERN_INFO "ioctl cmd 0x%08ux\n", cmd);
+	/*
+	 * extract the type and number bitfields, and don't decode
+	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+	 */
+	if (_IOC_TYPE(cmd) != HMP4E_IOC_MAGIC)
+		return -ENOTTY;
+	if (_IOC_NR(cmd) > HMP4E_IOC_MAXNR)
+		return -ENOTTY;
+
+	/*
+	 * the direction is a bitmask, and VERIFY_WRITE catches R/W
+	 * transfers. `Type' is user-oriented, while
+	 * access_ok is kernel-oriented, so the concept of "read" and
+	 * "write" is reversed
+	 */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	switch (cmd) {
+	case HMP4E_IOCHARDRESET:
+			/*
+			 * reset the counter to 1, to allow unloading in case
+			 * of problems. Use 1, not 0, because the invoking
+			 * process has the device open.
+			 */
+			while (count > 0)
+				count--;
+			count++;
+			break;
+
+	case HMP4E_IOCGBUFBUSADDRESS:
+#if !CONS_ALLOC
+			__put_user(virt_to_bus(hmp4e_data.buffer),
+					(unsigned long *)arg);
+#else
+			__put_user(hmp4e_phys, (unsigned long *)arg);
+#endif
+			break;
+
+	case HMP4E_IOCGBUFSIZE:
+			__put_user(hmp4e_data.buffsize, (unsigned int *)arg);
+			break;
+
+	case HMP4E_IOCGHWOFFSET:
+			__put_user(hmp4e_data.iobaseaddr, (unsigned long *)arg);
+			break;
+
+	case HMP4E_IOCGHWIOSIZE:
+			__put_user(hmp4e_data.iosize, (unsigned int *)arg);
+			break;
+
+	case HMP4E_IOC_CLI:
+			if (irq_enable == true) {
+				disable_irq(hmp4e_data.irq);
+				irq_enable = false;
+			}
+			break;
+
+	case HMP4E_IOC_STI:
+			if (irq_enable == false) {
+				enable_irq(hmp4e_data.irq);
+				irq_enable = true;
+			}
+			break;
+	}
+	return 0;
+}
+
+static int hmp4e_open(struct inode *inode, struct file *filp)
+{
+	int result;
+	hmp4e_t *dev = &hmp4e_data;
+
+	filp->private_data = (void *)dev;
+
+	if (count > 0)
+		return -EBUSY;
+
+	result = request_irq(dev->irq, hmp4e_isr, 0, "hmp4e", (void *)dev);
+	if (result == -EINVAL) {
+		printk(KERN_ERR "hmp4e: Bad irq number or handler\n");
+		return result;
+	} else if (result == -EBUSY) {
+		printk(KERN_ERR "hmp4e: IRQ %d busy, change your config\n",
+				dev->irq);
+		return result;
+	}
+
+	if (irq_enable == false)
+		irq_enable = true;
+
+	/* enable_irq(dev->irq); */
+
+	count++;
+	printk(KERN_INFO "dev opened\n");
+	return 0;
+}
+
+static int hmp4e_fasync(int fd, struct file *filp, int mode)
+{
+	hmp4e_t *dev = (hmp4e_t *) filp->private_data;
+
+	printk(KERN_INFO "fasync called\n");
+
+	return fasync_helper(fd, filp, mode, &dev->async_queue);
+}
+
+#ifdef HMP4E_DEBUG
+static void dump_regs(unsigned long data);
+#endif
+
+static int hmp4e_release(struct inode *inode, struct file *filp)
+{
+	hmp4e_t *dev = (hmp4e_t *) filp->private_data;
+
+	/* this is necessary if user process exited asynchronously */
+	if (irq_enable == true) {
+		disable_irq(dev->irq);
+		irq_enable = false;
+	}
+#ifdef HMP4E_DEBUG
+	dump_regs((unsigned long)dev);	/* dump the regs */
+#endif
+	ResetAsic(dev);		/* reset hardware */
+
+	/* free the encoder IRQ */
+	free_irq(dev->irq, (void *)dev);
+
+	/* remove this filp from the asynchronusly notified filp's */
+	hmp4e_fasync(-1, filp, 0);
+
+	/* g_hmp4e_busy = 0; */
+
+	count--;
+	printk(KERN_INFO "dev closed\n");
+	return 0;
+}
+
+/* VFS methods */
+static struct file_operations hmp4e_fops = {
+		.mmap = hmp4e_mmap,
+		.open =  hmp4e_open,
+		.release = hmp4e_release,
+		.ioctl = hmp4e_ioctl,
+		.fasync = hmp4e_fasync,
+};
+
+int __init hmp4e_init(void)
+{
+	int result = 0;
+	struct class_device *temp_class;
+
+	/* if you want to test the module, you obviously need to "mknod". */
+	printk(KERN_INFO "module init\n");
+
+	printk(KERN_INFO "hmp4e: base_port=0x%08lx irq=%i\n", base_port, irq);
+
+	if (__raw_readl(HANTRO_FUSE) & MXC_IIMHWV1_HANTRO_DISABLE)
+		__raw_writel(__raw_readl(HANTRO_FUSE) &
+				~MXC_IIMHWV1_HANTRO_DISABLE, HANTRO_FUSE);
+	if (__raw_readl(HANTRO_FUSE) & MXC_IIMHWV1_HANTRO_DISABLE) {
+		printk(KERN_ERR "The hantro hardware is disabled.\n");
+		return -1;
+	}
+
+	/* make sure clock is enabled */
+	hmp4ehw_clock_enable();
+
+	hmp4e_data.iobaseaddr = base_port;
+	hmp4e_data.iosize = ENC_IO_SIZE;
+	hmp4e_data.irq = irq;
+
+	hmp4e_major = register_chrdev(0, "hmp4e", &hmp4e_fops);
+	if (hmp4e_major < 0) {
+		printk(KERN_INFO "hmp4e: unable to get major for hmp4e\n");
+		return hmp4e_major;
+	}
+
+	hmp4e_class = class_create(THIS_MODULE, "hmp4e");
+	if (IS_ERR(hmp4e_class)) {
+		printk(KERN_ERR "Error creating hmp4e class.\n");
+		result = PTR_ERR(hmp4e_class);
+		goto err1;
+	}
+
+	temp_class = class_device_create(hmp4e_class, NULL,
+			MKDEV(hmp4e_major, 0), NULL, "hmp4e");
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating hmp4e class device.\n");
+		result = PTR_ERR(temp_class);
+		goto err2;
+	}
+
+	/* register for ipc */
+	/* in case other emma device want to get the status of each other
+	   g_hmp4e_busy = 0;
+	   inter_module_register("string_hmp4e_busy",
+	   THIS_MODULE,&g_hmp4e_busy); */
+	result = ReserveIO();
+	if (result < 0)
+		goto err3;
+
+	ResetAsic(&hmp4e_data);	/* reset hardware */
+
+	result = AllocMemory();
+	if (result < 0)
+		goto err4;
+
+	printk(KERN_INFO "hmp4e: module inserted. Major = %d\n", hmp4e_major);
+
+	return result;
+
+err4:
+	ReleaseIO();
+err3:
+	class_device_destroy(hmp4e_class, MKDEV(hmp4e_major, 0));
+err2:
+	class_destroy(hmp4e_class);
+err1:
+	unregister_chrdev(hmp4e_major, "hmp4e");
+	printk(KERN_INFO "hmp4e: module not inserted\n");
+	return result;
+}
+
+/* changed to devfs */
+void __exit hmp4e_cleanup(void)
+{
+	/* unregister ipc
+	   inter_module_unregister("string_hmp4e_busy"); */
+
+	class_device_destroy(hmp4e_class, MKDEV(hmp4e_major, 0));
+	class_destroy(hmp4e_class);
+
+	unregister_chrdev(hmp4e_major, "hmp4e");
+
+	hmp4ehw_clock_disable();
+
+	FreeMemory();
+
+	ReleaseIO();
+
+	printk(KERN_INFO "Encoder driver is unloaded sucessfully\n");
+}
+
+module_init(hmp4e_init);
+module_exit(hmp4e_cleanup);
+
+static int AllocMemory(void)
+{
+#if !CONS_ALLOC
+	struct page *pg;
+	char *start_addr, *end_addr;
+	u32 order, size;
+
+	printk(KERN_INFO "hmp4e: AllocMemory: Begin\n");
+
+	hmp4e_data.buffer = NULL;
+	hmp4e_data.buffsize = HMP4E_BUF_SIZE;
+	printk(KERN_INFO "hmp4e: AllocMemory: Buffer size %d\n",
+			hmp4e_data.buffsize);
+
+	for (order = 0, size = PAGE_SIZE; size < hmp4e_data.buffsize;
+			order++)
+			size <<= 1;
+	hmp4e_data.buffsize = size;
+
+	/* alloc memory */
+	start_addr = (char *)__get_free_pages(GFP_KERNEL, order);
+
+	if (!start_addr) {
+		printk(KERN_INFO "hmp4e: failed to allocate memory\n");
+		printk(KERN_INFO "hmp4e: AllocMemory: End (-ENOMEM)\n");
+		return -ENOMEM;
+	} else {
+		/* clear the mem */
+		memset(start_addr, 0, hmp4e_data.buffsize);
+
+		hmp4e_data.buffer = start_addr;
+	}
+	end_addr = start_addr + hmp4e_data.buffsize - 1;
+
+	printk(KERN_INFO "Alloc buffer 0x%08lx -- 0x%08lx\n", (long)start_addr,
+			(long)end_addr);
+
+	/* now we've got the kernel memory, but it can still be
+	 * swapped out. We need to stop the VM system from removing our
+	 * pages from main memory. To do this we just
+	 * need to set the PG_reserved
+	 * bit on each page, via mem_map_reserve() macro.
+	 */
+
+	/* If we don't set the reserved bit, the user-space
+	 * application sees all-zeroes pages. This is because
+	 * remap_pfn_range() won't allow you to
+	 * map non-reserved pages (check remap_pte_range()).
+	 * The pte's will be cleared, resulting in a page faulting
+	 * in a new zeroed page instead of the pages we are trying to mmap().
+	 */
+	for (pg = virt_to_page(start_addr);
+			pg <= virt_to_page(end_addr); pg++)
+		mem_map_reserve(pg);
+#else
+	hmp4e_data.buffsize = (HMP4E_BUF_SIZE + PAGE_SIZE - 1) &
+		~(PAGE_SIZE - 1);
+	hmp4e_data.buffer = dma_alloc_coherent(NULL, hmp4e_data.buffsize,
+			(dma_addr_t *) &hmp4e_phys,
+			GFP_DMA | GFP_KERNEL);
+	if (!hmp4e_data.buffer)
+		return -ENOMEM;
+
+	memset(hmp4e_data.buffer, 0, hmp4e_data.buffsize);
+#endif
+	printk(KERN_INFO "hmp4e: AllocMemory: End (0)\n");
+	return 0;
+}
+
+static void FreeMemory(void)
+{
+#if !CONS_ALLOC
+	struct page *pg;
+	u32 size, order;
+
+	/* first unreserve */
+	for (pg = virt_to_page(hmp4e_data.buffer);
+			pg < virt_to_page(hmp4e_data.buffer +
+				hmp4e_data.buffsize); pg++) {
+		mem_map_unreserve(pg);
+	}
+	for (order = 0, size = PAGE_SIZE;
+			size < hmp4e_data.buffsize; order++)
+			size <<= 1;
+	/* and now free */
+	free_pages((long)hmp4e_data.buffer, order);
+	printk(KERN_INFO "Free buffer 0x%08lx -- 0x%08lx\n",
+			(long)hmp4e_data.buffer,
+			(long)(hmp4e_data.buffer + hmp4e_data.buffsize - 1));
+#else
+	dma_free_coherent(NULL, hmp4e_data.buffsize, (void *)hmp4e_data.buffer,
+			hmp4e_phys);
+#endif
+}
+
+static int ReserveIO(void)
+{
+	long int hwid;
+
+	hmp4e_data.hwregs = (volatile u32 *)
+		IO_ADDRESS(hmp4e_data.iobaseaddr);
+	if (hmp4e_data.hwregs == NULL) {
+		printk(KERN_INFO "hmp4e: failed to ioremap HW regs\n");
+		ReleaseIO();
+		return -EBUSY;
+	}
+
+	hwid = __raw_readl(hmp4e_data.hwregs + 7);
+
+	if ((hwid & 0x0000ffff) != ENC_HW_ID) {
+		printk(KERN_INFO "hmp4e: HW not found at 0x%08lx\n",
+				hmp4e_data.iobaseaddr);
+		ReleaseIO();
+		return -EBUSY;
+	} else
+		printk(KERN_INFO "hmp4e: Compatble HW"
+				"found with ID: 0x%08lx\n",
+				hwid);
+
+	return 0;
+}
+
+static void ReleaseIO(void)
+{
+}
+
+static int MapBuffers(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long phys;
+	unsigned long start = (unsigned long)vma->vm_start;
+	unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
+
+	/* if userspace tries to mmap beyond end of our buffer, fail */
+	if (size > hmp4e_data.buffsize) {
+		printk(KERN_INFO "hmp4e: MapBuffers (-EINVAL)\n");
+		return -EINVAL;
+	}
+
+	vma->vm_flags |= VM_RESERVED | VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+#if !CONS_ALLOC
+	/* Remember this won't work for vmalloc()d memory ! */
+	phys = virt_to_phys(hmp4e_data.buffer);
+#else
+	phys = hmp4e_phys;
+#endif
+
+	if (remap_pfn_range
+			(vma, start, phys >> PAGE_SHIFT,
+			 size, vma->vm_page_prot)) {
+		printk(KERN_INFO "hmp4e: MapBuffers (-EAGAIN)\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "hmp4e: MapBuffers (0)\n");
+	return 0;
+}
+
+static int MapHwRegs(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long phys;
+	unsigned long start = (unsigned long)vma->vm_start;
+	unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
+#if NON_PAGE_ALIGNED
+	int ofs;
+
+	ofs = hmp4e_data.iobaseaddr & (PAGE_SIZE - 1);
+#endif
+
+	/* if userspace tries to mmap beyond end of our buffer, fail */
+	if (size > PAGE_SIZE)
+		return -EINVAL;
+
+	vma->vm_flags |= VM_RESERVED | VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	/* Remember this won't work for vmalloc()d memory ! */
+	phys = hmp4e_data.iobaseaddr;
+
+#if NON_PAGE_ALIGNED
+	if (remap_pfn_range(vma, start, (phys - ofs) >> PAGE_SHIFT,
+				hmp4e_data.iosize + ofs, vma->vm_page_prot))
+#else
+		if (remap_pfn_range(vma, start, phys >> PAGE_SHIFT,
+					hmp4e_data.iosize, vma->vm_page_prot))
+#endif
+			return -EAGAIN;
+
+	return 0;
+}
+
+static irqreturn_t hmp4e_isr(int irq, void *dev_id)
+{
+	hmp4e_t *dev = (hmp4e_t *) dev_id;
+	u32 irq_status = __raw_readl(dev->hwregs + 5);
+
+	/* clear enc IRQ */
+	__raw_writel(irq_status & (~0x01), dev->hwregs + 5);
+	printk(KERN_INFO "IRQ received!\n");
+	if (dev->async_queue)
+		kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+
+	return IRQ_HANDLED;
+}
+
+void ResetAsic(hmp4e_t *dev)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(dev->hwregs);
+	tmp = tmp | 0x02;
+	__raw_writel(tmp, dev->hwregs);	/* enable enc CLK */
+	__raw_writel(tmp & (~0x01), dev->hwregs);	/* disable enc */
+	__raw_writel(0x02, dev->hwregs);	/* clear reg 1 */
+	__raw_writel(0, dev->hwregs + 5);	/* clear enc IRQ */
+	__raw_writel(0, dev->hwregs);	/* disable enc CLK */
+}
+
+#ifdef HMP4E_DEBUG
+void dump_regs(unsigned long data)
+{
+	hmp4e_t *dev = (hmp4e_t *) data;
+	int i;
+
+	printk(KERN_INFO "Reg Dump Start\n");
+	for (i = 0; i < 16; i++) {
+		printk(KERN_INFO "\toffset %02X = %08X\n", i * 4,
+				__raw_readl(dev->hwregs + i));
+	}
+	printk(KERN_INFO "Reg Dump End\n");
+}
+#endif
+
+static void hmp4ehw_clock_enable(void)
+{
+	if ((__raw_readl(CCM_MCGR1_REG) & MCGR1_MPEG4_CLK_EN) !=
+			MCGR1_MPEG4_CLK_EN)
+		__raw_writel(__raw_readl(CCM_MCGR1_REG) | MCGR1_MPEG4_CLK_EN,
+				CCM_MCGR1_REG);
+}
+
+static void hmp4ehw_clock_disable(void)
+{
+	__raw_writel(__raw_readl(CCM_MCGR1_REG) & ~MCGR1_MPEG4_CLK_EN,
+			CCM_MCGR1_REG);
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/hmp4e/mxc_hmp4e.h b/drivers/mxc/hmp4e/mxc_hmp4e.h
new file mode 100644
index 0000000..59497d7
--- /dev/null
+++ b/drivers/mxc/hmp4e/mxc_hmp4e.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+/*
+ * Encoder device driver (kernel module headers)
+ *
+ * Copyright (C) 2005  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef __MXC_HMP4E_H__
+#define __MXC_HMP4E_H__
+#include <linux/ioctl.h>
+#include <mach/iim.h>
+
+/*
+ * Macros to help debugging
+ */
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'k' as magic number */
+#define HMP4E_IOC_MAGIC  'k'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define HMP4E_IOCGBUFBUSADDRESS _IOR(HMP4E_IOC_MAGIC,  1, unsigned long *)
+#define HMP4E_IOCGBUFSIZE       _IOR(HMP4E_IOC_MAGIC,  2, unsigned int *)
+#define HMP4E_IOCGHWOFFSET      _IOR(HMP4E_IOC_MAGIC,  3, unsigned long *)
+#define HMP4E_IOCGHWIOSIZE      _IOR(HMP4E_IOC_MAGIC,  4, unsigned int *)
+#define HMP4E_IOC_CLI           _IO(HMP4E_IOC_MAGIC,  5)
+#define HMP4E_IOC_STI           _IO(HMP4E_IOC_MAGIC,  6)
+
+/* ... more to come */
+#define HMP4E_IOCHARDRESET _IO(HMP4E_IOC_MAGIC, 15)	/* debugging tool */
+#define HMP4E_IOC_MAXNR 15
+
+#define mem_map_reserve SetPageReserved
+#define mem_map_unreserve ClearPageReserved
+
+#define CCM_MCGR1_REG  IO_ADDRESS(CRM_MCU_BASE_ADDR+0x20)
+#define MCGR1_MPEG4_CLK_EN 0x0000000C
+
+#define HANTRO_FUSE IO_ADDRESS(IIM_BASE_ADDR + MXC_IIMHWV1)
+
+#endif				/* __MXC_HMP4E_H__ */
-- 
1.6.0.3

