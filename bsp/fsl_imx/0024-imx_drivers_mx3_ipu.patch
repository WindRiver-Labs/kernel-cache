From fda4a4591d572af8bc766f6edbc522d801dc1de3 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Wed, 29 Oct 2008 16:34:07 +0800
Subject: [PATCH] imx_drivers_mx3_ipu

MX3 Image Processing Unit driver.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

IPUv3 is an enhanced version of the IPU. It supports more hardware
like two cameras, two displays. It supports more bandwidth up to 4KX4K
transfer. Compared with IPUv1 the register layout and registers
number have changed. So add this new driver to support IPUv3.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/plat-mxc/include/mach/ipu.h    | 1217 +++++++++++++++++++
 arch/arm/plat-mxc/include/mach/mxc_pf.h |  139 +++
 drivers/mxc/ipu/Kconfig                 |   16 +
 drivers/mxc/ipu/Makefile                |    5 +
 drivers/mxc/ipu/ipu_adc.c               |  675 +++++++++++
 drivers/mxc/ipu/ipu_common.c            | 1849 ++++++++++++++++++++++++++++
 drivers/mxc/ipu/ipu_csi.c               |  222 ++++
 drivers/mxc/ipu/ipu_device.c            |  669 +++++++++++
 drivers/mxc/ipu/ipu_ic.c                |  576 +++++++++
 drivers/mxc/ipu/ipu_param_mem.h         |  186 +++
 drivers/mxc/ipu/ipu_prv.h               |   60 +
 drivers/mxc/ipu/ipu_regs.h              |  396 ++++++
 drivers/mxc/ipu/ipu_sdc.c               |  358 ++++++
 drivers/mxc/ipu/pf/Kconfig              |    7 +
 drivers/mxc/ipu/pf/Makefile             |    2 +
 drivers/mxc/ipu/pf/mxc_pf.c             |  980 +++++++++++++++
 drivers/mxc/ipu/snoop.c                 |  135 +++
 drivers/mxc/ipu/snoop.h                 |   20 +
 drivers/mxc/ipu3/Kconfig                |   20 +
 drivers/mxc/ipu3/Makefile               |    4 +
 drivers/mxc/ipu3/ipu_capture.c          |  711 +++++++++++
 drivers/mxc/ipu3/ipu_common.c           | 2001 +++++++++++++++++++++++++++++++
 drivers/mxc/ipu3/ipu_device.c           |  496 ++++++++
 drivers/mxc/ipu3/ipu_disp.c             | 1367 +++++++++++++++++++++
 drivers/mxc/ipu3/ipu_ic.c               |  711 +++++++++++
 drivers/mxc/ipu3/ipu_param_mem.h        |  332 +++++
 drivers/mxc/ipu3/ipu_prv.h              |   88 ++
 drivers/mxc/ipu3/ipu_regs.h             |  625 ++++++++++
 28 files changed, 13867 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/ipu.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_pf.h
 create mode 100644 drivers/mxc/ipu/Kconfig
 create mode 100644 drivers/mxc/ipu/Makefile
 create mode 100644 drivers/mxc/ipu/ipu_adc.c
 create mode 100644 drivers/mxc/ipu/ipu_common.c
 create mode 100644 drivers/mxc/ipu/ipu_csi.c
 create mode 100644 drivers/mxc/ipu/ipu_device.c
 create mode 100644 drivers/mxc/ipu/ipu_ic.c
 create mode 100644 drivers/mxc/ipu/ipu_param_mem.h
 create mode 100644 drivers/mxc/ipu/ipu_prv.h
 create mode 100644 drivers/mxc/ipu/ipu_regs.h
 create mode 100644 drivers/mxc/ipu/ipu_sdc.c
 create mode 100644 drivers/mxc/ipu/pf/Kconfig
 create mode 100644 drivers/mxc/ipu/pf/Makefile
 create mode 100644 drivers/mxc/ipu/pf/mxc_pf.c
 create mode 100644 drivers/mxc/ipu/snoop.c
 create mode 100644 drivers/mxc/ipu/snoop.h
 create mode 100644 drivers/mxc/ipu3/Kconfig
 create mode 100644 drivers/mxc/ipu3/Makefile
 create mode 100644 drivers/mxc/ipu3/ipu_capture.c
 create mode 100644 drivers/mxc/ipu3/ipu_common.c
 create mode 100644 drivers/mxc/ipu3/ipu_device.c
 create mode 100644 drivers/mxc/ipu3/ipu_disp.c
 create mode 100644 drivers/mxc/ipu3/ipu_ic.c
 create mode 100644 drivers/mxc/ipu3/ipu_param_mem.h
 create mode 100644 drivers/mxc/ipu3/ipu_prv.h
 create mode 100644 drivers/mxc/ipu3/ipu_regs.h

diff --git a/arch/arm/plat-mxc/include/mach/ipu.h b/arch/arm/plat-mxc/include/mach/ipu.h
new file mode 100644
index 0000000..43e725e
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/ipu.h
@@ -0,0 +1,1217 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file arch-mxc/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+#else
+#define bool char
+#define irqreturn_t int
+#define dma_addr_t int
+#define u32 unsigned int
+#define __u32 u32
+#endif
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of Post Filter modes
+ */
+typedef enum {
+	PF_DISABLE_ALL = 0,
+	PF_MPEG4_DEBLOCK = 1,
+	PF_MPEG4_DERING = 2,
+	PF_MPEG4_DEBLOCK_DERING = 3,
+	PF_H264_DEBLOCK = 4,
+} pf_operation_t;
+
+/*!
+ * Enumeration of Synchronous (Memory-less) panel types
+ */
+typedef enum {
+	IPU_PANEL_SHARP_TFT,
+	IPU_PANEL_TFT,
+} ipu_panel_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')
+/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')
+
+#define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#ifdef CONFIG_MXC_IPU_V1
+#define _MAKE_CHAN(num, in, out, sec) \
+	((num << 24) | (sec << 16) | (out << 8) | in)
+#define IPU_CHAN_ID(ch)         (ch >> 24)
+#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
+#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
+#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
+
+#else
+#define IPU_MAX_CH	32
+#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
+	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
+#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
+#define IPU_CHAN_ID(ch)			(ch >> 24)
+#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
+#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
+#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
+#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
+#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
+#define NO_DMA 0x3F
+#define ALT	1
+#endif
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CHAN_NONE = -1,
+#ifdef CONFIG_MXC_IPU_V1
+	/*!< CSI raw sensor data to memory */
+	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),
+
+	/*!< CSI to IC Encoder PreProcessing to Memory */
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),
+	/*!< Memory to IC Encoder PreProcessing to Memory */
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),
+	/*!< Memory to IC Encoder Rotation to Memory */
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),
+
+	/*!< CSI to IC Viewfinder PreProcessing to Memory */
+	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),
+	/*!< CSI to IC Viewfinder PreProcessing to ADC */
+	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),
+	/*!< Memory to IC Viewfinder PreProcessing to Memory */
+	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),
+	/*!< Memory to IC Viewfinder PreProcessing to ADC */
+	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),
+	/*!< Memory to IC Viewfinder Rotation to Memory */
+	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),
+
+	/*!< Memory to IC PostProcessing to Memory */
+	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),
+	/*!< Memory to IC PostProcessing Rotation to Memory */
+	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),
+	/*!< Memory to IC PostProcessing to ADC */
+	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),
+
+	/*!< Memory to SDC Background plane */
+	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),
+	/*!< Memory to SDC Foreground plane */
+	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),
+	/*!< Memory to SDC Mask */
+	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),
+
+	MEM_BG_SYNC = MEM_SDC_BG,
+	MEM_FG_SYNC = MEM_SDC_FG,
+
+	/*!< Memory to ADC System Channel 1 */
+	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),
+	/*!< Memory to ADC System Channel 2 */
+	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),
+
+	/*!< Y and PF Memory to Post-filter to Y Memory */
+	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),
+	/*!< U and PF Memory to Post-filter to U Memory */
+	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),
+	/*!< V Memory to Post-filter to V Memory */
+	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),
+
+	MEM_DC_SYNC = CHAN_NONE,
+	DIRECT_ASYNC0 = CHAN_NONE,
+	DIRECT_ASYNC1 = CHAN_NONE,
+#else
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
+	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
+	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
+
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
+	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
+	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
+
+	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
+	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
+	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
+	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
+
+	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
+	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
+	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
+	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
+
+	DIRECT_ASYNC0 = _MAKE_CHAN(13, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+	DIRECT_ASYNC1 = _MAKE_CHAN(14, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+
+	CSI_MEM0 = _MAKE_CHAN(15, NO_DMA, NO_DMA, NO_DMA, 0),
+	CSI_MEM1 = _MAKE_CHAN(16, NO_DMA, NO_DMA, NO_DMA, 1),
+	CSI_MEM2 = _MAKE_CHAN(17, NO_DMA, NO_DMA, NO_DMA, 2),
+	CSI_MEM3 = _MAKE_CHAN(18, NO_DMA, NO_DMA, NO_DMA, 3),
+
+	CSI_MEM = CSI_MEM0,
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(19, NO_DMA, NO_DMA, NO_DMA, 20),
+	CSI_PRP_VF_MEM = _MAKE_CHAN(20, NO_DMA, NO_DMA, NO_DMA, 21),
+
+	MEM_PP_ADC = CHAN_NONE,
+	ADC_SYS2 = CHAN_NONE,
+#endif
+
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
+	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
+	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
+	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
+	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
+	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
+} ipu_buffer_t;
+
+#define IPU_PANEL_SERIAL		1
+#define IPU_PANEL_PARALLEL		2
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t csi;
+		bool mipi_en;
+		uint32_t mipi_id;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t csi;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t csi;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+#ifdef CONFIG_ARCH_MX51
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+#endif
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+#ifdef CONFIG_ARCH_MX51
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+#endif
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+	struct {
+		pf_operation_t operation;
+	} mem_pf_mem;
+	struct {
+		uint32_t di;
+		bool interlaced;
+	} mem_dc_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dp_bg_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dp_fg_sync;
+	struct {
+		uint32_t di;
+	} direct_async;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+#ifdef CONFIG_MXC_IPU_V1
+	IPU_IRQ_DC_FC_1 = -1,
+
+	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
+	IPU_IRQ_PRP_VF_OUT_EOF = 1,
+	IPU_IRQ_PP_OUT_EOF = 2,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
+	IPU_IRQ_PP_IN_EOF = 5,
+	IPU_IRQ_PRP_IN_EOF = 6,
+	IPU_IRQ_SENSOR_OUT_EOF = 7,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
+	IPU_IRQ_PP_ROT_OUT_EOF = 12,
+	IPU_IRQ_PP_ROT_IN_EOF = 13,
+	IPU_IRQ_BG_SYNC_EOF = 14,
+	IPU_IRQ_SDC_BG_EOF = IPU_IRQ_BG_SYNC_EOF,
+	IPU_IRQ_FG_SYNC_EOF = 15,
+	IPU_IRQ_SDC_FG_EOF = IPU_IRQ_FG_SYNC_EOF,
+	IPU_IRQ_SDC_MASK_EOF = 16,
+	IPU_IRQ_SDC_BG_PART_EOF = 17,
+	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
+	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
+	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
+	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
+	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
+	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
+	IPU_IRQ_PF_QP_IN_EOF = 24,
+	IPU_IRQ_PF_BSP_IN_EOF = 25,
+	IPU_IRQ_PF_Y_IN_EOF = 26,
+	IPU_IRQ_PF_U_IN_EOF = 27,
+	IPU_IRQ_PF_V_IN_EOF = 28,
+	IPU_IRQ_PF_Y_OUT_EOF = 29,
+	IPU_IRQ_PF_U_OUT_EOF = 30,
+	IPU_IRQ_PF_V_OUT_EOF = 31,
+
+	IPU_IRQ_PRP_ENC_OUT_NF = 32,
+	IPU_IRQ_PRP_VF_OUT_NF = 33,
+	IPU_IRQ_PP_OUT_NF = 34,
+	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
+	IPU_IRQ_PP_GRAPH_IN_NF = 36,
+	IPU_IRQ_PP_IN_NF = 37,
+	IPU_IRQ_PRP_IN_NF = 38,
+	IPU_IRQ_SENSOR_OUT_NF = 39,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
+	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
+	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
+	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
+	IPU_IRQ_PP_ROT_OUT_NF = 44,
+	IPU_IRQ_PP_ROT_IN_NF = 45,
+	IPU_IRQ_SDC_FG_NF = 46,
+	IPU_IRQ_SDC_BG_NF = 47,
+	IPU_IRQ_SDC_MASK_NF = 48,
+	IPU_IRQ_SDC_BG_PART_NF = 49,
+	IPU_IRQ_ADC_SYS1_WR_NF = 50,
+	IPU_IRQ_ADC_SYS2_WR_NF = 51,
+	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
+	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
+	IPU_IRQ_ADC_SYS1_RD_NF = 54,
+	IPU_IRQ_ADC_SYS2_RD_NF = 55,
+	IPU_IRQ_PF_QP_IN_NF = 56,
+	IPU_IRQ_PF_BSP_IN_NF = 57,
+	IPU_IRQ_PF_Y_IN_NF = 58,
+	IPU_IRQ_PF_U_IN_NF = 59,
+	IPU_IRQ_PF_V_IN_NF = 60,
+	IPU_IRQ_PF_Y_OUT_NF = 61,
+	IPU_IRQ_PF_U_OUT_NF = 62,
+	IPU_IRQ_PF_V_OUT_NF = 63,
+
+	IPU_IRQ_BREAKRQ = 64,
+	IPU_IRQ_SDC_BG_OUT_EOF = 65,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_SDC_BG_OUT_EOF,
+	IPU_IRQ_SDC_FG_OUT_EOF = 66,
+	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
+	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
+	IPU_IRQ_SENSOR_NF = 69,
+	IPU_IRQ_SENSOR_EOF = 70,
+	IPU_IRQ_SDC_DISP3_VSYNC = 80,
+	IPU_IRQ_ADC_DISP0_VSYNC = 81,
+	IPU_IRQ_ADC_DISP12_VSYNC = 82,
+	IPU_IRQ_ADC_PRP_EOF = 83,
+	IPU_IRQ_ADC_PP_EOF = 84,
+	IPU_IRQ_ADC_SYS1_EOF = 85,
+	IPU_IRQ_ADC_SYS2_EOF = 86,
+
+	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
+	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
+	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
+	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
+	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
+	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
+	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
+	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
+	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
+	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
+	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
+	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
+	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
+	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
+	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
+	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
+	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
+	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
+	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
+	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
+	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
+	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
+	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
+	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
+	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
+	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
+	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
+	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
+	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
+	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
+	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
+
+	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
+	IPU_IRQ_ENC_BUFOVF_ERR = 129,
+	IPU_IRQ_VF_BUFOVF_ERR = 130,
+	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
+	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
+	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
+	IPU_IRQ_SDC_BGD_ERR = 134,
+	IPU_IRQ_SDC_FGD_ERR = 135,
+	IPU_IRQ_SDC_MASKD_ERR = 136,
+	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
+	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
+	IPU_IRQ_VF_FRM_LOST_ERR = 139,
+	IPU_IRQ_ADC_LOCK_ERR = 140,
+	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
+	IPU_IRQ_AHB_M1_ERR = 142,
+	IPU_IRQ_AHB_M12_ERR = 143,
+#else
+	IPU_IRQ_CSI0_OUT_EOF = 0,
+	IPU_IRQ_CSI1_OUT_EOF = 1,
+	IPU_IRQ_CSI2_OUT_EOF = 2,
+	IPU_IRQ_CSI3_OUT_EOF = 3,
+	IPU_IRQ_PP_IN_EOF = 11,
+	IPU_IRQ_PRP_IN_EOF = 12,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
+	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
+	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
+	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
+	IPU_IRQ_PRP_VF_OUT_EOF = 21,
+	IPU_IRQ_PP_OUT_EOF = 22,
+	IPU_IRQ_BG_SYNC_EOF = 23,
+	IPU_IRQ_BG_ASYNC_EOF = 24,
+	IPU_IRQ_FG_SYNC_EOF = 27,
+	IPU_IRQ_DC_SYNC_EOF = 28,
+	IPU_IRQ_FG_ASYNC_EOF = 29,
+	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
+
+	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
+	IPU_IRQ_DC_READ_EOF = 40,
+	IPU_IRQ_DC_ASYNC_EOF = 41,
+	IPU_IRQ_DC_CMD1_EOF = 42,
+	IPU_IRQ_DC_CMD2_EOF = 43,
+	IPU_IRQ_DC_MASK_EOF = 44,
+#ifdef CONFIG_ARCH_MX51
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 46,
+	IPU_IRQ_PP_ROT_IN_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 49,
+	IPU_IRQ_PP_ROT_OUT_EOF = 50,
+#else
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 46,
+	IPU_IRQ_PP_ROT_OUT_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 49,
+	IPU_IRQ_PP_ROT_IN_EOF = 50,
+#endif
+	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
+	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
+
+	IPU_IRQ_DP_SF_START = 448 + 2,
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_DP_SF_END,
+	IPU_IRQ_DC_FC_0 = 448 + 8,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+	IPU_IRQ_DC_FC_2 = 448 + 10,
+	IPU_IRQ_DC_FC_3 = 448 + 11,
+	IPU_IRQ_DC_FC_4 = 448 + 12,
+	IPU_IRQ_DC_FC_6 = 448 + 13,
+	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
+	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
+#endif
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned ext_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+
+typedef struct {
+	unsigned data_width:4;
+	unsigned clk_mode:3;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+	unsigned pack_tight:1;
+	unsigned force_eof:1;
+	unsigned data_en_pol:1;
+	unsigned data_fmt;
+	unsigned csi;
+	unsigned mclk;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4,
+	IPU_CSI_DATA_WIDTH_8,
+	IPU_CSI_DATA_WIDTH_10,
+	IPU_CSI_DATA_WIDTH_16,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
+};
+
+enum {
+	IPU_CSI_MIPI_DI0,
+	IPU_CSI_MIPI_DI1,
+	IPU_CSI_MIPI_DI2,
+	IPU_CSI_MIPI_DI3,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned rs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) (((rs) << 29) | ((fc) << 27) | \
+	((oc) << 24) | (dat))
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+/* Common IPU API */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params);
+void ipu_uninit_channel(ipu_channel_t channel);
+
+static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
+{
+#ifdef CONFIG_MXC_IPU_V1
+	return rot < IPU_ROTATE_90_RIGHT;
+#else
+	return rot < IPU_ROTATE_HORIZ_FLIP;
+#endif
+}
+
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t pixel_fmt,
+		uint16_t width, uint16_t height,
+		uint32_t stride,
+		ipu_rotate_mode_t rot_mode,
+		dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+		uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_select_buffer(ipu_channel_t channel,
+		ipu_buffer_t type, uint32_t bufNum);
+
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_is_channel_busy(ipu_channel_t channel);
+int32_t ipu_enable_channel(ipu_channel_t channel);
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
+
+int ipu_lowpwr_display_enable(void);
+int ipu_lowpwr_display_disable(void);
+
+void ipu_enable_irq(uint32_t irq);
+void ipu_disable_irq(uint32_t irq);
+void ipu_clear_irq(uint32_t irq);
+int ipu_request_irq(uint32_t irq,
+		irqreturn_t(*handler) (int, void *),
+		uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(uint32_t irq);
+void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
+
+/* SDC API */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+		uint32_t pixel_clk,
+		uint16_t width, uint16_t height,
+		uint32_t pixel_fmt,
+		uint16_t hStartWidth, uint16_t hSyncWidth,
+		uint16_t hEndWidth, uint16_t vStartWidth,
+		uint16_t vSyncWidth, uint16_t vEndWidth,
+		ipu_di_signal_cfg_t sig);
+
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+		uint32_t colorKey);
+int32_t ipu_sdc_set_brightness(uint8_t value);
+
+int32_t ipu_init_sync_panel(int disp,
+		uint32_t pixel_clk,
+		uint16_t width, uint16_t height,
+		uint32_t pixel_fmt,
+		uint16_t h_start_width, uint16_t h_sync_width,
+		uint16_t h_end_width, uint16_t v_start_width,
+		uint16_t v_sync_width, uint16_t v_end_width,
+		uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
+
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+		int16_t y_pos);
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+		uint8_t alpha);
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+		uint32_t colorKey);
+
+int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
+		uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig);
+void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset);
+void ipu_reset_disp_panel(void);
+
+/* ADC API */
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t *pCmd,
+		bool write);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+		ipu_adc_update_mode_t mode,
+		uint32_t refresh_rate, unsigned long addr,
+		uint32_t *size);
+
+int32_t ipu_adc_get_snooping_status(uint32_t *statl, uint32_t *stath);
+
+int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+		uint32_t cmd, const uint32_t *params,
+		uint16_t numParams);
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+		uint16_t width, uint16_t height,
+		uint32_t pixel_fmt,
+		uint32_t stride,
+		ipu_adc_sig_cfg_t sig,
+		display_addressing_t addr,
+		uint32_t vsync_width, vsync_t mode);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+		uint32_t cycle_time,
+		uint32_t up_time,
+		uint32_t down_time,
+		uint32_t read_latch_time, uint32_t pixel_clk);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
+		uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
+
+static inline int32_t ipu_csi_enable_mclk_if(int src, uint32_t csi,
+		bool flag, bool wait)
+{
+#ifdef CONFIG_MXC_IPU_V1
+	return ipu_csi_enable_mclk(src, flag, wait);
+#else
+	return ipu_csi_enable_mclk(csi, flag, wait);
+#endif
+}
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi);
+
+void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi);
+
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi);
+
+/* Post Filter functions */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+/* New added for IPU-lib functionality*/
+int ipu_open(void);
+int ipu_register_generic_isr(int irq, void *dev);
+void ipu_close(void);
+
+typedef struct _ipu_channel_parm {
+	ipu_channel_t channel;
+	ipu_channel_params_t params;
+	bool flag;
+} ipu_channel_parm;
+
+typedef struct _ipu_channel_buf_parm {
+	ipu_channel_t channel;
+	ipu_buffer_t type;
+	uint32_t pixel_fmt;
+	uint16_t width;
+	uint16_t height;
+	uint16_t stride;
+	ipu_rotate_mode_t rot_mode;
+	dma_addr_t phyaddr_0;
+	dma_addr_t phyaddr_1;
+	uint32_t u_offset;
+	uint32_t v_offset;
+	uint32_t bufNum;
+} ipu_channel_buf_parm;
+
+typedef struct _ipu_channel_link {
+	ipu_channel_t src_ch;
+	ipu_channel_t dest_ch;
+} ipu_channel_link;
+
+typedef struct _ipu_channel_info {
+	ipu_channel_t channel;
+	bool stop;
+} ipu_channel_info;
+
+typedef struct ipu_irq_info {
+	uint32_t irq;
+	irqreturn_t(*handler) (int, void *);
+	uint32_t irq_flags;
+	char *devname;
+	void *dev_id;
+} ipu_irq_info;
+
+typedef struct _ipu_sdc_panel_info {
+	ipu_panel_t panel;
+	uint32_t pixel_clk;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint16_t hStartWidth;
+	uint16_t hSyncWidth;
+	uint16_t hEndWidth;
+	uint16_t vStartWidth;
+	uint16_t vSyncWidth;
+	uint16_t vEndWidth;
+	ipu_di_signal_cfg_t signal;
+} ipu_sdc_panel_info;
+
+typedef struct _ipu_sdc_window_pos {
+	ipu_channel_t channel;
+	int16_t x_pos;
+	int16_t y_pos;
+} ipu_sdc_window_pos;
+
+typedef struct _ipu_sdc_global_alpha {
+	bool enable;
+	uint8_t alpha;
+} ipu_sdc_global_alpha;
+
+typedef struct _ipu_sdc_color_key {
+	ipu_channel_t channel;
+	bool enable;
+	uint32_t colorKey;
+} ipu_sdc_color_key;
+
+typedef struct _ipu_adc_template {
+	display_port_t disp;
+	uint32_t *pCmd;
+	bool write;
+} ipu_adc_template;
+
+typedef struct _ipu_adc_update {
+	ipu_channel_t channel;
+	ipu_adc_update_mode_t mode;
+	uint32_t refresh_rate;
+	unsigned long addr;
+	uint32_t *size;
+} ipu_adc_update;
+
+typedef struct _ipu_adc_snoop {
+	uint32_t *statl;
+	uint32_t *stath;
+} ipu_adc_snoop;
+
+typedef struct _ipu_adc_cmd {
+	display_port_t disp;
+	cmddata_t type;
+	uint32_t cmd;
+	uint32_t *params;
+	uint16_t numParams;
+} ipu_adc_cmd;
+
+typedef struct _ipu_adc_panel {
+	display_port_t disp;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint32_t stride;
+	ipu_adc_sig_cfg_t signal;
+	display_addressing_t addr;
+	uint32_t vsync_width;
+	vsync_t mode;
+} ipu_adc_panel;
+
+typedef struct _ipu_adc_ifc_timing {
+	display_port_t disp;
+	bool read;
+	uint32_t cycle_time;
+	uint32_t up_time;
+	uint32_t down_time;
+	uint32_t read_latch_time;
+	uint32_t pixel_clk;
+} ipu_adc_ifc_timing;
+
+typedef struct _ipu_csi_interface {
+	uint16_t width;
+	uint16_t height;
+	uint16_t pixel_fmt;
+	ipu_csi_signal_cfg_t signal;
+} ipu_csi_interface;
+
+typedef struct _ipu_csi_mclk {
+	int src;
+	bool flag;
+	bool wait;
+} ipu_csi_mclk;
+
+typedef struct _ipu_csi_window {
+	uint32_t left;
+	uint32_t top;
+} ipu_csi_window;
+
+typedef struct _ipu_csi_window_size {
+	uint32_t width;
+	uint32_t height;
+} ipu_csi_window_size;
+
+typedef struct _ipu_event_info {
+	int irq;
+	void *dev;
+} ipu_event_info;
+
+typedef struct _ipu_mem_info {
+	dma_addr_t paddr;
+	void *vaddr;
+	int size;
+} ipu_mem_info;
+
+/* IOCTL commands */
+
+#define IPU_INIT_CHANNEL              _IOW('I', 0x1, ipu_channel_parm)
+#define IPU_UNINIT_CHANNEL            _IOW('I', 0x2, ipu_channel_t)
+#define IPU_INIT_CHANNEL_BUFFER       _IOW('I', 0x3, ipu_channel_buf_parm)
+#define IPU_UPDATE_CHANNEL_BUFFER     _IOW('I', 0x4, ipu_channel_buf_parm)
+#define IPU_SELECT_CHANNEL_BUFFER     _IOW('I', 0x5, ipu_channel_buf_parm)
+#define IPU_LINK_CHANNELS             _IOW('I', 0x6, ipu_channel_link)
+#define IPU_UNLINK_CHANNELS           _IOW('I', 0x7, ipu_channel_link)
+#define IPU_ENABLE_CHANNEL            _IOW('I', 0x8, ipu_channel_t)
+#define IPU_DISABLE_CHANNEL           _IOW('I', 0x9, ipu_channel_info)
+#define IPU_ENABLE_IRQ                _IOW('I', 0xA, int)
+#define IPU_DISABLE_IRQ               _IOW('I', 0xB, int)
+#define IPU_CLEAR_IRQ                 _IOW('I', 0xC, int)
+#define IPU_FREE_IRQ                  _IOW('I', 0xD, ipu_irq_info)
+#define IPU_REQUEST_IRQ_STATUS        _IOW('I', 0xE, int)
+#define IPU_SDC_INIT_PANEL            _IOW('I', 0xF, ipu_sdc_panel_info)
+#define IPU_SDC_SET_WIN_POS           _IOW('I', 0x10, ipu_sdc_window_pos)
+#define IPU_SDC_SET_GLOBAL_ALPHA      _IOW('I', 0x11, ipu_sdc_global_alpha)
+#define IPU_SDC_SET_COLOR_KEY         _IOW('I', 0x12, ipu_sdc_color_key)
+#define IPU_SDC_SET_BRIGHTNESS        _IOW('I', 0x13, int)
+#define IPU_ADC_WRITE_TEMPLATE        _IOW('I', 0x14, ipu_adc_template)
+#define IPU_ADC_UPDATE                _IOW('I', 0x15, ipu_adc_update)
+#define IPU_ADC_SNOOP                 _IOW('I', 0x16, ipu_adc_snoop)
+#define IPU_ADC_CMD                   _IOW('I', 0x17, ipu_adc_cmd)
+#define IPU_ADC_INIT_PANEL            _IOW('I', 0x18, ipu_adc_panel)
+#define IPU_ADC_IFC_TIMING            _IOW('I', 0x19, ipu_adc_ifc_timing)
+#define IPU_CSI_INIT_INTERFACE        _IOW('I', 0x1A, ipu_csi_interface)
+#define IPU_CSI_ENABLE_MCLK           _IOW('I', 0x1B, ipu_csi_mclk)
+#define IPU_CSI_READ_MCLK_FLAG        _IOR('I', 0x1C, ipu_csi_mclk)
+#define IPU_CSI_FLASH_STROBE          _IOW('I', 0x1D, ipu_csi_mclk)
+#define IPU_CSI_GET_WIN_SIZE          _IOR('I', 0x1E, ipu_csi_window_size)
+#define IPU_CSI_SET_WIN_SIZE          _IOW('I', 0x1F, ipu_csi_window_size)
+#define IPU_CSI_SET_WINDOW            _IOW('I', 0x20, ipu_csi_window)
+#define IPU_PF_SET_PAUSE_ROW          _IOW('I', 0x21, uint32_t)
+#define IPU_REGISTER_GENERIC_ISR      _IOW('I', 0x22, ipu_event_info)
+#ifdef CONFIG_ARCH_MX51
+#define IPU_GET_EVENT                 _IOWR('I', 0x23, ipu_event_info)
+#else
+#define IPU_GET_EVENT                 _IOR('I', 0x23, ipu_event_info)
+#endif
+#define IPU_ALOC_MEM		      _IOWR('I', 0x24, ipu_mem_info)
+#define IPU_FREE_MEM		      _IOW('I', 0x25, ipu_mem_info)
+#define IPU_IS_CHAN_BUSY	      _IOW('I', 0x26, ipu_channel_t)
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_pf.h b/arch/arm/plat-mxc/include/mach/mxc_pf.h
new file mode 100644
index 0000000..9daa462
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_pf.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
+ */
+/*!
+ * @file arch-mxc/mxc_pf.h
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+#ifndef __INCLUDED_MXC_PF_H__
+#define __INCLUDED_MXC_PF_H__
+
+#define PF_MAX_BUFFER_CNT       17
+
+#define PF_WAIT_Y	0x0001
+#define PF_WAIT_U	0x0002
+#define PF_WAIT_V	0x0004
+#define PF_WAIT_ALL	(PF_WAIT_Y|PF_WAIT_U|PF_WAIT_V)
+
+/*!
+ * Structure for Post Filter initialization parameters.
+ */
+typedef struct {
+	/*!< Post filter operation mode */
+	uint16_t pf_mode;
+	/*!< Width of frame in pixels */
+	uint16_t width;
+	/*!< Height of frame in pixels */
+	uint16_t height;
+	/*!< Stride of Y plane in pixels.
+	 * Stride for U and V planes is half Y stride */
+	uint16_t stride;
+	uint32_t qp_size;
+	unsigned long qp_paddr;
+} pf_init_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int count;		/*!< Number of buffers requested */
+	__u32 req_size;
+} pf_reqbufs_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int index;
+	/*!< Size of buffer allocated */
+	int size;
+	/*!< Buffer offset in driver memory. Set by QUERYBUF */
+	__u32 offset;
+	/*!< Optional starting relative offset of Y data
+	 * from beginning of buffer. Set to 0 to use default
+	 * calculated based on height and stride */
+	__u32 y_offset;
+	/*!< Optional starting relative offset of U data
+	 * from beginning of buffer. Set to 0 to use default
+	 * calculated based on height and stride */
+	__u32 u_offset;
+	/*!< Optional starting relative offset of V data
+	 * from beginning of buffer. Set to 0 to use default
+	 * calculated based on height and stride */
+	__u32 v_offset;
+} pf_buf;
+
+/*!
+ * Structure for Post Filter start parameters.
+ */
+typedef struct {
+	/*!< Input buffer address and offsets */
+	pf_buf in;
+	/*!< Output buffer address and offsets */
+	pf_buf out;
+	int qp_buf;
+	int wait;
+	/*!< Row to pause at for H.264 mode. 0 to disable pause */
+	uint32_t h264_pause_row;
+} pf_start_params;
+
+/*! @name User Client Ioctl Interface */
+/*! @{ */
+
+/*!
+ * IOCTL to Initialize the Post Filter.
+ */
+#define PF_IOCTL_INIT           _IOW('F', 0x0, pf_init_params)
+
+/*!
+ * IOCTL to Uninitialize the Post Filter.
+ */
+#define PF_IOCTL_UNINIT         _IO('F', 0x1)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_REQBUFS        _IOWR('F', 0x2, pf_reqbufs_params)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_QUERYBUF       _IOR('F', 0x2, pf_buf)
+
+/*!
+ * IOCTL to start post filtering on a frame of data.
+ * This ioctl may block until processing is done or return immediately.
+ */
+#define PF_IOCTL_START          _IOWR('F', 0x3, pf_start_params)
+
+/*!
+ * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
+ */
+#define PF_IOCTL_RESUME         _IOW('F', 0x4, int)
+
+/*!
+ * IOCTL to wait for post-filtering to complete.
+ */
+#define PF_IOCTL_WAIT           _IOW('F', 0x5, int)
+/*! @} */
+
+#endif				/* __INCLUDED_MXC_PF_H__ */
diff --git a/drivers/mxc/ipu/Kconfig b/drivers/mxc/ipu/Kconfig
new file mode 100644
index 0000000..5ff6ba9
--- /dev/null
+++ b/drivers/mxc/ipu/Kconfig
@@ -0,0 +1,16 @@
+menu "MXC IPU"
+
+config MXC_IPU
+	bool "MXC Image Processing Unit"
+	depends on ARCH_MX3
+	select MXC_IPU_V1
+	help
+	  If you plan to use the Image Processing unit in the MXC, say
+	  Y here. If unsure, select Y.
+
+config MXC_IPU_V1
+	bool
+
+source "drivers/mxc/ipu/pf/Kconfig"
+
+endmenu
diff --git a/drivers/mxc/ipu/Makefile b/drivers/mxc/ipu/Makefile
new file mode 100644
index 0000000..396ab6a
--- /dev/null
+++ b/drivers/mxc/ipu/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_MXC_IPU) += mxc_ipu.o
+
+mxc_ipu-objs := ipu_common.o ipu_sdc.o ipu_adc.o ipu_ic.o ipu_csi.o ipu_device.o snoop.o
+
+obj-$(CONFIG_MXC_IPU_PF)        +=   pf/
diff --git a/drivers/mxc/ipu/ipu_adc.c b/drivers/mxc/ipu/ipu_adc.c
new file mode 100644
index 0000000..860d043
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_adc.c
@@ -0,0 +1,675 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_adc.c
+ *
+ * @brief IPU ADC functions
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+#include "snoop.h"
+
+/*#define ADC_CHAN1_SA_MASK 0xFF800000 */
+
+static void _ipu_set_cmd_data_mappings(display_port_t disp,
+				       uint32_t pixel_fmt, int ifc_width);
+
+int32_t _ipu_adc_init_channel(ipu_channel_t chan, display_port_t disp,
+			      mcu_mode_t cmd, int16_t x_pos, int16_t y_pos)
+{
+	uint32_t reg;
+	uint32_t start_addr, stride;
+	unsigned long lock_flags;
+	uint32_t size;
+
+	size = 0;
+
+	switch (disp) {
+	case DISP0:
+		reg = __raw_readl(ADC_DISP0_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	case DISP1:
+		reg = __raw_readl(ADC_DISP1_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	case DISP2:
+		reg = __raw_readl(ADC_DISP2_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (stride == 0)
+		return -EINVAL;
+
+	stride++;
+	start_addr = (y_pos * stride) + x_pos;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	reg = __raw_readl(ADC_CONF);
+
+	switch (chan) {
+	case ADC_SYS1:
+		reg &= ~0x00FF4000;
+		reg |=
+		    ((uint32_t) size << 21 | (uint32_t) disp << 19 | (uint32_t)
+		     cmd << 16);
+
+		__raw_writel(start_addr, ADC_SYSCHA1_SA);
+		break;
+
+	case ADC_SYS2:
+		reg &= ~0xFF008000;
+		reg |=
+		    ((uint32_t) size << 29 | (uint32_t) disp << 27 | (uint32_t)
+		     cmd << 24);
+
+		__raw_writel(start_addr, ADC_SYSCHA2_SA);
+		break;
+
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+		reg &= ~0x000000F9;
+		reg |=
+		    ((uint32_t) size << 5 | (uint32_t) disp << 3 |
+		     ADC_CONF_PRP_EN);
+
+		__raw_writel(start_addr, ADC_PRPCHAN_SA);
+		break;
+
+	case MEM_PP_ADC:
+		reg &= ~0x00003F02;
+		reg |=
+		    ((uint32_t) size << 10 | (uint32_t) disp << 8 |
+		     ADC_CONF_PP_EN);
+
+		__raw_writel(start_addr, ADC_PPCHAN_SA);
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -1;
+		break;
+	}
+	__raw_writel(reg, ADC_CONF);
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+
+int32_t _ipu_adc_uninit_channel(ipu_channel_t chan)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	reg = __raw_readl(ADC_CONF);
+
+	switch (chan) {
+	case ADC_SYS1:
+		reg &= ~0x00FF4000;
+		break;
+	case ADC_SYS2:
+		reg &= ~0xFF008000;
+		break;
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+		reg &= ~0x000000F9;
+		break;
+	case MEM_PP_ADC:
+		reg &= ~0x00003F02;
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -1;
+		break;
+	}
+	__raw_writel(reg, ADC_CONF);
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t *pCmd, bool write)
+{
+	uint32_t ima_addr = 0;
+	uint32_t row_nu;
+	int i;
+
+	/* Set IPU_IMA_ADDR (IPU Internal Memory Access Address) */
+	if (write)
+		row_nu = (uint32_t) disp * 2 * ATM_ADDR_RANGE;
+	else
+		row_nu = ((uint32_t) disp * 2 + 1) * ATM_ADDR_RANGE;
+
+	/* form template addr for IPU_IMA_ADDR */
+	ima_addr = (0x3 << 16 /*Template memory */  | row_nu << 3);
+
+	__raw_writel(ima_addr, IPU_IMA_ADDR);
+
+	/* write template data for IPU_IMA_DATA */
+	for (i = 0; i < TEMPLATE_BUF_SIZE; i++)
+		/* only DATA field are needed */
+		__raw_writel(pCmd[i], IPU_IMA_DATA);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_write_template);
+
+int32_t
+ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+		  uint32_t cmd, const uint32_t *params, uint16_t numParams)
+{
+	uint16_t i;
+	int disable_di = 0;
+	u32 reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	reg = __raw_readl(IPU_CONF);
+	if ((reg & IPU_CONF_DI_EN) == 0) {
+		disable_di = 1;
+		reg |= IPU_CONF_DI_EN;
+		__raw_writel(reg, IPU_CONF);
+	}
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+
+	__raw_writel((uint32_t) ((type ? 0x0 : 0x1) | disp << 1 | 0x10),
+		     DI_DISP_LLA_CONF);
+	__raw_writel(cmd, DI_DISP_LLA_DATA);
+	udelay(3);
+
+	__raw_writel((uint32_t) (0x10 | disp << 1 | 0x11), DI_DISP_LLA_CONF);
+	for (i = 0; i < numParams; i++) {
+		__raw_writel(params[i], DI_DISP_LLA_DATA);
+		udelay(3);
+	}
+
+	if (disable_di) {
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		reg = __raw_readl(IPU_CONF);
+		reg &= ~IPU_CONF_DI_EN;
+		__raw_writel(reg, IPU_CONF);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_write_cmd);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t *size)
+{
+	int32_t err = 0;
+	uint32_t ref_per, reg, src = 0;
+	unsigned long lock_flags;
+	uint32_t ipu_freq;
+
+	ipu_freq = clk_get_rate(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPU_FS_DISP_FLOW);
+	reg &= ~FS_AUTO_REF_PER_MASK;
+	switch (mode) {
+	case IPU_ADC_REFRESH_NONE:
+		src = 0;
+		break;
+	case IPU_ADC_AUTO_REFRESH:
+		if (refresh_rate == 0) {
+			err = -EINVAL;
+			goto err0;
+		}
+		ref_per = ipu_freq / ((1UL << 17) * refresh_rate);
+		ref_per--;
+		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
+
+		src = FS_SRC_AUTOREF;
+		break;
+	case IPU_ADC_AUTO_REFRESH_SNOOP:
+		if (refresh_rate == 0) {
+			err = -EINVAL;
+			goto err0;
+		}
+		ref_per = ipu_freq / ((1UL << 17) * refresh_rate);
+		ref_per--;
+		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
+
+		src = FS_SRC_AUTOREF_SNOOP;
+		break;
+	case IPU_ADC_SNOOPING:
+		src = FS_SRC_SNOOP;
+		break;
+	}
+
+	switch (channel) {
+	case ADC_SYS1:
+		reg &= ~FS_ADC1_SRC_SEL_MASK;
+		reg |= src << FS_ADC1_SRC_SEL_OFFSET;
+		break;
+	case ADC_SYS2:
+		reg &= ~FS_ADC2_SRC_SEL_MASK;
+		reg |= src << FS_ADC2_SRC_SEL_OFFSET;
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+	__raw_writel(reg, IPU_FS_DISP_FLOW);
+
+	/* Setup M3IF for snooping */
+	if ((mode == IPU_ADC_AUTO_REFRESH_SNOOP) ||
+			(mode == IPU_ADC_SNOOPING)) {
+		err = mxc_snoop_set_config(0, addr, *size);
+		if (err > 0) {
+			*size = err;
+			err = 0;
+		}
+	} else
+		mxc_snoop_set_config(0, 0, 0);
+
+err0:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return err;
+}
+EXPORT_SYMBOL(ipu_adc_set_update_mode);
+
+int32_t ipu_adc_get_snooping_status(uint32_t *statl, uint32_t *stath)
+{
+	return mxc_snoop_get_status(0, statl, stath);
+}
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+	uint32_t ser_conf;
+	uint32_t disp_conf;
+	uint32_t adc_disp_conf;
+	uint32_t adc_disp_vsync;
+	uint32_t old_pol;
+
+	if ((disp != DISP1) && (disp != DISP2) &&
+	    (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL)) {
+		return -EINVAL;
+	}
+	adc_disp_conf = (uint32_t) addr << 12 | (stride - 1);
+
+	_ipu_set_cmd_data_mappings(disp, pixel_fmt, sig.ifc_width);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	disp_conf = __raw_readl(DI_DISP_IF_CONF);
+	old_pol = __raw_readl(DI_DISP_SIG_POL);
+	adc_disp_vsync = __raw_readl(ADC_DISP_VSYNC);
+
+	switch (disp) {
+	case DISP0:
+		__raw_writel(adc_disp_conf, ADC_DISP0_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP0_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D0_MODE_MASK |
+				    ADC_DISP_VSYNC_D0_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x2000003FL;
+		old_pol |= sig.data_pol | sig.cs_pol << 1 |
+		    sig.addr_pol << 2 | sig.read_pol << 3 |
+		    sig.write_pol << 4 | sig.Vsync_pol << 5 |
+		    sig.burst_pol << 29;
+		__raw_writel(old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x0000001FL;
+		disp_conf |= (sig.burst_mode << 3) | (sig.ifc_mode << 1) |
+		    DI_CONF_DISP0_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	case DISP1:
+		__raw_writel(adc_disp_conf, ADC_DISP1_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP12_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D12_MODE_MASK |
+				    ADC_DISP_VSYNC_D12_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x4000FF00L;
+		old_pol |= (sig.Vsync_pol << 6 | sig.data_pol << 8 |
+			    sig.cs_pol << 9 | sig.addr_pol << 10 |
+			    sig.read_pol << 11 | sig.write_pol << 12 |
+			    sig.clk_pol << 14 | sig.burst_pol << 30);
+		__raw_writel(old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x00003F00L;
+		if (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL) {
+			ser_conf = (sig.ifc_width - 1) <<
+			    DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET;
+			if (sig.ser_preamble_len) {
+				ser_conf |= DI_SER_DISPx_CONF_PREAMBLE_EN;
+				ser_conf |= sig.ser_preamble <<
+				    DI_SER_DISPx_CONF_PREAMBLE_OFFSET;
+				ser_conf |= (sig.ser_preamble_len - 1) <<
+				    DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET;
+			}
+
+			ser_conf |=
+			    sig.ser_rw_mode << DI_SER_DISPx_CONF_RW_CFG_OFFSET;
+
+			if (sig.burst_mode == IPU_ADC_BURST_SERIAL)
+				ser_conf |= DI_SER_DISPx_CONF_BURST_MODE_EN;
+			__raw_writel(ser_conf, DI_SER_DISP1_CONF);
+		} else {	/* parallel interface */
+			disp_conf |= (uint32_t) (sig.burst_mode << 12);
+		}
+		disp_conf |= (sig.ifc_mode << 9) | DI_CONF_DISP1_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	case DISP2:
+		__raw_writel(adc_disp_conf, ADC_DISP2_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP12_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D12_MODE_MASK |
+				    ADC_DISP_VSYNC_D12_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x80FF0000L;
+		temp = (uint32_t) (sig.data_pol << 16 | sig.cs_pol << 17 |
+				   sig.addr_pol << 18 | sig.read_pol << 19 |
+				   sig.write_pol << 20 | sig.Vsync_pol << 6 |
+				   sig.burst_pol << 31 | sig.clk_pol << 22);
+		__raw_writel(temp | old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x003F0000L;
+		if (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL) {
+			ser_conf = (sig.ifc_width - 1) <<
+			    DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET;
+			if (sig.ser_preamble_len) {
+				ser_conf |= DI_SER_DISPx_CONF_PREAMBLE_EN;
+				ser_conf |= sig.ser_preamble <<
+				    DI_SER_DISPx_CONF_PREAMBLE_OFFSET;
+				ser_conf |= (sig.ser_preamble_len - 1) <<
+				    DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET;
+
+			}
+
+			ser_conf |=
+			    sig.ser_rw_mode << DI_SER_DISPx_CONF_RW_CFG_OFFSET;
+
+			if (sig.burst_mode == IPU_ADC_BURST_SERIAL)
+				ser_conf |= DI_SER_DISPx_CONF_BURST_MODE_EN;
+			__raw_writel(ser_conf, DI_SER_DISP2_CONF);
+		} else {	/* parallel interface */
+			disp_conf |= (uint32_t) (sig.burst_mode << 20);
+		}
+		disp_conf |= (sig.ifc_mode << 17) | DI_CONF_DISP2_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	default:
+		break;
+	}
+
+	__raw_writel(adc_disp_vsync, ADC_DISP_VSYNC);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_init_panel);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk)
+{
+	uint32_t reg;
+	uint32_t time_conf3 = 0;
+	uint32_t clk_per;
+	uint32_t up_per;
+	uint32_t down_per;
+	uint32_t read_per;
+	uint32_t pixclk_per = 0;
+	uint32_t ipu_freq;
+
+	ipu_freq = clk_get_rate(g_ipu_clk);
+
+	clk_per = (cycle_time * (ipu_freq / 1000L) * 16L) / 1000000L;
+	up_per = (up_time * (ipu_freq / 1000L) * 4L) / 1000000L;
+	down_per = (down_time * (ipu_freq / 1000L) * 4L) / 1000000L;
+
+	reg = (clk_per << DISPx_IF_CLK_PER_OFFSET) |
+	    (up_per << DISPx_IF_CLK_UP_OFFSET) |
+	    (down_per << DISPx_IF_CLK_DOWN_OFFSET);
+
+	if (read) {
+		read_per =
+		    (read_latch_time * (ipu_freq / 1000L) * 4L) / 1000000L;
+		if (pixel_clk)
+			pixclk_per = (ipu_freq * 16L) / pixel_clk;
+		time_conf3 = (read_per << DISPx_IF_CLK_READ_EN_OFFSET) |
+		    (pixclk_per << DISPx_PIX_CLK_PER_OFFSET);
+	}
+
+	dev_dbg(g_ipu_dev, "DI_DISPx_TIME_CONF_1/2 = 0x%08X\n", reg);
+	dev_dbg(g_ipu_dev, "DI_DISPx_TIME_CONF_3 = 0x%08X\n", time_conf3);
+
+	switch (disp) {
+	case DISP0:
+		if (read) {
+			__raw_writel(reg, DI_DISP0_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP0_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP0_TIME_CONF_1);
+		}
+		break;
+	case DISP1:
+		if (read) {
+			__raw_writel(reg, DI_DISP1_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP1_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP1_TIME_CONF_1);
+		}
+		break;
+	case DISP2:
+		if (read) {
+			__raw_writel(reg, DI_DISP2_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP2_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP2_TIME_CONF_1);
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_init_ifc_timing);
+
+struct ipu_adc_di_map {
+	uint32_t map_byte1;
+	uint32_t map_byte2;
+	uint32_t map_byte3;
+	uint32_t cycle_cnt;
+};
+
+static const struct ipu_adc_di_map di_mappings[] = {
+	[0] = {
+	       /* RGB888, 8-bit bus */
+	       .map_byte1 = 0x1600AAAA,
+	       .map_byte2 = 0x00E05555,
+	       .map_byte2 = 0x00070000,
+	       .cycle_cnt = 3,
+	       },
+	[1] = {
+	       /* RGB666, 8-bit bus */
+	       .map_byte1 = 0x1C00AAAF,
+	       .map_byte2 = 0x00E0555F,
+	       .map_byte3 = 0x0007000F,
+	       .cycle_cnt = 3,
+	       },
+	[2] = {
+	       /* RGB565, 8-bit bus */
+	       .map_byte1 = 0x008055BF,
+	       .map_byte2 = 0x0142015F,
+	       .map_byte3 = 0x0007003F,
+	       .cycle_cnt = 2,
+	       },
+	[3] = {
+	       /* RGB888, 24-bit bus */
+	       .map_byte1 = 0x0007000F,
+	       .map_byte2 = 0x000F000F,
+	       .map_byte3 = 0x0017000F,
+	       .cycle_cnt = 1,
+	       },
+	[4] = {
+	       /* RGB666, 18-bit bus */
+	       .map_byte1 = 0x0005000F,
+	       .map_byte2 = 0x000B000F,
+	       .map_byte3 = 0x0011000F,
+	       .cycle_cnt = 1,
+	       },
+	[5] = {
+	       /* RGB565, 16-bit bus */
+	       .map_byte1 = 0x0004003F,
+	       .map_byte2 = 0x000A000F,
+	       .map_byte3 = 0x000F003F,
+	       .cycle_cnt = 1,
+	       },
+};
+
+/* Private methods */
+static void _ipu_set_cmd_data_mappings(display_port_t disp,
+				       uint32_t pixel_fmt, int ifc_width)
+{
+	uint32_t reg;
+	u32 map = 0;
+
+	if (ifc_width == 8) {
+		switch (pixel_fmt) {
+		case IPU_PIX_FMT_BGR24:
+			map = 0;
+			break;
+		case IPU_PIX_FMT_RGB666:
+			map = 1;
+			break;
+		case IPU_PIX_FMT_RGB565:
+			map = 2;
+			break;
+		default:
+			break;
+		}
+	} else if (ifc_width >= 16) {
+		switch (pixel_fmt) {
+		case IPU_PIX_FMT_BGR24:
+			map = 3;
+			break;
+		case IPU_PIX_FMT_RGB666:
+			map = 4;
+			break;
+		case IPU_PIX_FMT_RGB565:
+			map = 5;
+			break;
+		default:
+			break;
+		}
+	}
+
+	switch (disp) {
+	case DISP0:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP0_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP0_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP0_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP0_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP0_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP0_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP0_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP0_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	case DISP1:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP1_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP1_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP1_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP1_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP1_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP1_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP1_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP1_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	case DISP2:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP2_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP2_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP2_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP2_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP2_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP2_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP2_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP2_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/drivers/mxc/ipu/ipu_common.c b/drivers/mxc/ipu/ipu_common.c
new file mode 100644
index 0000000..467b3a9
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_common.c
@@ -0,0 +1,1849 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_common.c
+ *
+ * @brief This file contains the IPU driver common API functions.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/*
+ * This type definition is used to define a node
+ * in the GPIO interrupt queue for
+ * registered interrupts for GPIO pins.
+ * Each node contains the GPIO signal number
+ * associated with the ISR and the actual ISR function pointer.
+ */
+struct ipu_irq_node {
+	irqreturn_t(*handler) (int, void *);	/*!< the ISR */
+	const char *name;	/*!< device associated with the interrupt */
+	void *dev_id;		/*!< some unique information for the ISR */
+	__u32 flags;		/*!< not used */
+};
+
+/* Globals */
+struct clk *g_ipu_clk;
+struct clk *g_ipu_csi_clk;
+static struct clk *dfm_clk;
+int g_ipu_irq[2];
+int g_ipu_hw_rev;
+bool g_sec_chan_en[21];
+uint32_t g_channel_init_mask;
+DEFINE_SPINLOCK(ipu_lock);
+struct device *g_ipu_dev;
+
+static struct ipu_irq_node ipu_irq_list[IPU_IRQ_COUNT];
+static const char driver_name[] = "mxc_ipu";
+
+static uint32_t g_ipu_config;
+static uint32_t g_channel_init_mask_backup;
+static bool g_csi_used;
+
+/* Static functions */
+static irqreturn_t ipu_irq_handler(int irq, void *desc);
+static void _ipu_pf_init(ipu_channel_params_t *params);
+static void _ipu_pf_uninit(void);
+
+static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
+{
+	return (type == IPU_INPUT_BUFFER) ? ((uint32_t) ch & 0xFF) :
+		((type == IPU_OUTPUT_BUFFER) ? (((uint32_t) ch >> 8) & 0xFF)
+		 : (((uint32_t) ch >> 16) & 0xFF));
+};
+
+static inline uint32_t DMAParamAddr(uint32_t dma_ch)
+{
+	return 0x10000 | (dma_ch << 4);
+};
+
+/*!
+ * This function is called by the driver framework to initialize the IPU
+ * hardware.
+ *
+ * @param       dev       The device structure for the IPU passed in by the framework.
+ *
+ * @return      This function returns 0 on success or negative error code on error
+ */
+static
+int ipu_probe(struct platform_device *pdev)
+{
+	struct mxc_ipu_config *ipu_conf = pdev->dev.platform_data;
+
+	spin_lock_init(&ipu_lock);
+
+	g_ipu_dev = &pdev->dev;
+	g_ipu_hw_rev = ipu_conf->rev;
+
+	/* Register IPU interrupts */
+	g_ipu_irq[0] = platform_get_irq(pdev, 0);
+	if (g_ipu_irq[0] < 0)
+		return -EINVAL;
+
+	if (request_irq(g_ipu_irq[0], ipu_irq_handler,
+				0, driver_name, 0) != 0) {
+		dev_err(g_ipu_dev, "request SYNC interrupt failed\n");
+		return -EBUSY;
+	}
+	/* Some platforms have 2 IPU interrupts */
+	g_ipu_irq[1] = platform_get_irq(pdev, 1);
+	if (g_ipu_irq[1] >= 0) {
+		if (request_irq
+		    (g_ipu_irq[1], ipu_irq_handler, 0, driver_name, 0) != 0) {
+			dev_err(g_ipu_dev, "request ERR interrupt failed\n");
+			return -EBUSY;
+		}
+	}
+
+	/* Enable IPU and CSI clocks */
+	/* Get IPU clock freq */
+	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
+	dev_dbg(g_ipu_dev, "ipu_clk = %lu\n", clk_get_rate(g_ipu_clk));
+
+	g_ipu_csi_clk = clk_get(&pdev->dev, "csi_clk");
+
+	dfm_clk = clk_get(NULL, "dfm_clk");
+
+	clk_enable(g_ipu_clk);
+
+	/* resetting the CONF register of the IPU */
+	__raw_writel(0x00000000, IPU_CONF);
+
+	__raw_writel(0x00100010L, DI_HSP_CLK_PER);
+
+	/* Set SDC refresh channels as high priority */
+	__raw_writel(0x0000C000L, IDMAC_CHA_PRI);
+
+	/* Set to max back to back burst requests */
+	__raw_writel(0x00000000L, IDMAC_CONF);
+
+	register_ipu_device();
+
+	return 0;
+}
+
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to initalize.
+ *
+ * @param       params  Input parameter containing union of channel initialization
+ *                      parameters.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	uint32_t ipu_conf;
+	uint32_t reg;
+	unsigned long  lock_flags;
+
+	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	if ((channel != MEM_SDC_BG) && (channel != MEM_SDC_FG) &&
+	    (channel != MEM_ROT_ENC_MEM) && (channel != MEM_ROT_VF_MEM) &&
+	    (channel != MEM_ROT_PP_MEM) && (channel != CSI_MEM)
+	    && (params == NULL))
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	ipu_conf = __raw_readl(IPU_CONF);
+	if (ipu_conf == 0)
+		clk_enable(g_ipu_clk);
+
+	if (g_channel_init_mask & (1L << IPU_CHAN_ID(channel)))
+		dev_err(g_ipu_dev, "Warning: channel already initialized\n");
+
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case CSI_PRP_VF_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | (FS_DEST_ADC << FS_PRPVF_DEST_SEL_OFFSET),
+			     IPU_FS_PROC_FLOW);
+
+		_ipu_adc_init_channel(CSI_PRP_VF_ADC,
+				      params->csi_prp_vf_adc.disp,
+				      WriteTemplateNonSeq,
+				      params->csi_prp_vf_adc.out_left,
+				      params->csi_prp_vf_adc.out_top);
+
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case MEM_PRP_VF_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | FS_VF_IN_VALID, IPU_FS_PROC_FLOW);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, false);
+		break;
+	case MEM_ROT_VF_MEM:
+		_ipu_ic_init_rotate_vf(params);
+		break;
+	case CSI_PRP_ENC_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW);
+		_ipu_ic_init_prpenc(params, true);
+		break;
+	case MEM_PRP_ENC_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | FS_ENC_IN_VALID, IPU_FS_PROC_FLOW);
+		_ipu_ic_init_prpenc(params, false);
+		break;
+	case MEM_ROT_ENC_MEM:
+		_ipu_ic_init_rotate_enc(params);
+		break;
+	case MEM_PP_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | (FS_DEST_ADC << FS_PP_DEST_SEL_OFFSET),
+			     IPU_FS_PROC_FLOW);
+
+		_ipu_adc_init_channel(MEM_PP_ADC, params->mem_pp_adc.disp,
+				      WriteTemplateNonSeq,
+				      params->mem_pp_adc.out_left,
+				      params->mem_pp_adc.out_top);
+
+		if (params->mem_pp_adc.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_pp(params);
+		break;
+	case MEM_PP_MEM:
+		if (params->mem_pp_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_pp(params);
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_init_rotate_pp(params);
+		break;
+	case CSI_MEM:
+		_ipu_ic_init_csi(params);
+		break;
+
+	case MEM_PF_Y_MEM:
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		/* Enable PF block */
+		_ipu_pf_init(params);
+		break;
+
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		_ipu_adc_init_channel(ADC_SYS1, params->adc_sys1.disp,
+				      params->adc_sys1.ch_mode,
+				      params->adc_sys1.out_left,
+				      params->adc_sys1.out_top);
+		break;
+	case ADC_SYS2:
+		_ipu_adc_init_channel(ADC_SYS2, params->adc_sys2.disp,
+				      params->adc_sys2.ch_mode,
+				      params->adc_sys2.out_left,
+				      params->adc_sys2.out_top);
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	/* Enable IPU sub module */
+    g_channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+
+    if (g_channel_init_mask & 0x00000066L) {    /*CSI */
+		ipu_conf |= IPU_CONF_CSI_EN;
+		if (cpu_is_mx31())
+			g_csi_used = true;
+    }
+	if (g_channel_init_mask & 0x00001FFFL)		/*IC */
+		ipu_conf |= IPU_CONF_IC_EN;
+	if (g_channel_init_mask & 0x00000A10L)		/*ROT */
+		ipu_conf |= IPU_CONF_ROT_EN;
+	if (g_channel_init_mask & 0x0001C000L)		/*SDC */
+		ipu_conf |= IPU_CONF_SDC_EN | IPU_CONF_DI_EN;
+	if (g_channel_init_mask & 0x00061140L)		/*ADC */
+		ipu_conf |= IPU_CONF_ADC_EN | IPU_CONF_DI_EN;
+	if (g_channel_init_mask & 0x00380000L)		/*PF */
+		ipu_conf |= IPU_CONF_PF_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel);
+
+/*!
+ * This function is called to uninitialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to uninitalize.
+ */
+void ipu_uninit_channel(ipu_channel_t channel)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t dma, mask = 0;
+	uint32_t ipu_conf;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if ((g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already uninitialized\n");
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return;
+	}
+
+	/* Make sure channel is disabled */
+	/* Get input and output dma channels */
+	dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	if (dma != IDMA_CHAN_INVALID)
+		mask |= 1UL << dma;
+	dma = channel_2_dma(channel, IPU_INPUT_BUFFER);
+	if (dma != IDMA_CHAN_INVALID)
+		mask |= 1UL << dma;
+	/* Get secondary input dma channel */
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)]) {
+		dma = channel_2_dma(channel, IPU_SEC_INPUT_BUFFER);
+		if (dma != IDMA_CHAN_INVALID)
+			mask |= 1UL << dma;
+	}
+
+	if (mask & __raw_readl(IDMAC_CHA_EN)) {
+		dev_err(g_ipu_dev,
+			"Channel %d is not disabled, disable first\n",
+			IPU_CHAN_ID(channel));
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return;
+	}
+
+	/* Reset the double buffer */
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL);
+	__raw_writel(reg & ~mask, IPU_CHA_DB_MODE_SEL);
+
+	g_channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	g_sec_chan_en[IPU_CHAN_ID(channel)] = false;
+
+	/* Make sure channel is disabled */
+	/* ipu_disable_channel(channel, false); */
+
+	switch (channel) {
+	case CSI_MEM:
+		_ipu_ic_uninit_csi();
+		break;
+	case CSI_PRP_VF_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_PRPVF_DEST_SEL_MASK, IPU_FS_PROC_FLOW);
+
+		_ipu_adc_uninit_channel(CSI_PRP_VF_ADC);
+
+		/* Fall thru */
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		_ipu_ic_uninit_prpvf();
+		break;
+	case MEM_PRP_VF_ADC:
+		break;
+	case MEM_ROT_VF_MEM:
+		_ipu_ic_uninit_rotate_vf();
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		_ipu_ic_uninit_prpenc();
+		break;
+	case MEM_ROT_ENC_MEM:
+		_ipu_ic_uninit_rotate_enc();
+		break;
+	case MEM_PP_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_PP_DEST_SEL_MASK, IPU_FS_PROC_FLOW);
+
+		_ipu_adc_uninit_channel(MEM_PP_ADC);
+
+		/* Fall thru */
+	case MEM_PP_MEM:
+		_ipu_ic_uninit_pp();
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_uninit_rotate_pp();
+		break;
+
+	case MEM_PF_Y_MEM:
+		_ipu_pf_uninit();
+		break;
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		break;
+
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		_ipu_adc_uninit_channel(ADC_SYS1);
+		break;
+	case ADC_SYS2:
+		_ipu_adc_uninit_channel(ADC_SYS2);
+		break;
+	case MEM_SDC_MASK:
+	case CHAN_NONE:
+		break;
+	}
+
+	ipu_conf = __raw_readl(IPU_CONF);
+	if ((g_channel_init_mask & 0x00000066L) == 0) /*CSI */
+		ipu_conf &= ~IPU_CONF_CSI_EN;
+	if ((g_channel_init_mask & 0x00001FFFL) == 0) /*IC */
+		ipu_conf &= ~IPU_CONF_IC_EN;
+	if ((g_channel_init_mask & 0x00000A10L) == 0) /*ROT */
+		ipu_conf &= ~IPU_CONF_ROT_EN;
+	if ((g_channel_init_mask & 0x0001C000L) == 0) /*SDC */
+		ipu_conf &= ~IPU_CONF_SDC_EN;
+	if ((g_channel_init_mask & 0x00061140L) == 0) /*ADC */
+		ipu_conf &= ~IPU_CONF_ADC_EN;
+	if ((g_channel_init_mask & 0x0007D140L) == 0) /*DI */
+		ipu_conf &= ~IPU_CONF_DI_EN;
+	if ((g_channel_init_mask & 0x00380000L) == 0) /*PF */
+		ipu_conf &= ~IPU_CONF_PF_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	if (ipu_conf == 0)
+		clk_disable(g_ipu_clk);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_uninit_channel);
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer. Pixel
+ *                              format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input
+ *                              buffers of rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		       	private u offset for additional cropping,
+ *		zero if not used.
+ *
+ * @param       v		       	private v offset for additional cropping,
+ *		zero if not used.
+ *
+ * @return      This function returns 0 on success or
+ * negative error code on fail
+ */
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u, uint32_t v)
+{
+	uint32_t params[10];
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t dma_chan;
+
+	dma_chan = channel_2_dma(channel, type);
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (stride % 4) {
+		dev_err(g_ipu_dev,
+			"Stride length must be 32-bit aligned,"
+			"stride = %d\n",
+			stride);
+		return -EINVAL;
+	}
+	/* IC channels' width must be multiple of 8 pixels     */
+	if ((dma_chan <= 13) && (width % 8)) {
+		dev_err(g_ipu_dev, "width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_set_size(params, pixel_fmt, width, height, stride,
+			       u, v);
+	_ipu_ch_param_set_buffer(params, phyaddr_0, phyaddr_1);
+	_ipu_ch_param_set_rotation(params, rot_mode);
+	/* Some channels (rotation) have restriction on burst length */
+	if ((dma_chan == 10) || (dma_chan == 11) || (dma_chan == 13)) {
+		_ipu_ch_param_set_burst_size(params, 8);
+	} else if (dma_chan == 24) {	/* PF QP channel */
+		_ipu_ch_param_set_burst_size(params, 4);
+	} else if (dma_chan == 25) {	/* PF H264 BS channel */
+		_ipu_ch_param_set_burst_size(params, 16);
+	} else if (((dma_chan == 14) || (dma_chan == 15)) &&
+		   pixel_fmt == IPU_PIX_FMT_RGB565) {
+		_ipu_ch_param_set_burst_size(params, 16);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	_ipu_write_param_mem(DMAParamAddr(dma_chan), params, 10);
+
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL);
+	if (phyaddr_1)
+		reg |= 1UL << dma_chan;
+	else
+		reg &= ~(1UL << dma_chan);
+	__raw_writel(reg, IPU_CHA_DB_MODE_SEL);
+
+	/* Reset to buffer 0 */
+	__raw_writel(1UL << dma_chan, IPU_CHA_CUR_BUF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer);
+
+/*!
+ * This function is called to update the physical address of a buffer for
+ * a logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number to update.
+ *                              0 or 1 are the only valid values.
+ *
+ * @param       phyaddr         Input parameter buffer physical address.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail. This function will fail if the buffer is set to ready.
+ */
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bufNum == 0) {
+		reg = __raw_readl(IPU_CHA_BUF0_RDY);
+		if (reg & (1UL << dma_chan)) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+			return -EACCES;
+		}
+		__raw_writel(DMAParamAddr(dma_chan) + 0x0008UL, IPU_IMA_ADDR);
+		__raw_writel(phyaddr, IPU_IMA_DATA);
+	} else {
+		reg = __raw_readl(IPU_CHA_BUF1_RDY);
+		if (reg & (1UL << dma_chan)) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+			return -EACCES;
+		}
+		__raw_writel(DMAParamAddr(dma_chan) + 0x0009UL, IPU_IMA_ADDR);
+		__raw_writel(phyaddr, IPU_IMA_DATA);
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	dev_dbg(g_ipu_dev, "IPU: update IDMA ch %d buf %d = 0x%08X\n",
+		dma_chan, bufNum, phyaddr);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_update_channel_buffer);
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_buffer(ipu_channel_t channel, ipu_buffer_t type,
+			  uint32_t bufNum)
+{
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		__raw_writel(1UL << dma_chan, IPU_CHA_BUF0_RDY);
+	} else {
+		/*Mark buffer 1 as ready. */
+		__raw_writel(1UL << dma_chan, IPU_CHA_BUF1_RDY);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_buffer);
+
+/*!
+ * This function links 2 channels together for automatic frame
+ * synchronization. The output of the source channel is linked to the input of
+ * the destination channel.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	unsigned long lock_flags;
+	uint32_t out_dma;
+	uint32_t in_dma;
+	bool isProc;
+	uint32_t value;
+	uint32_t mask;
+	uint32_t offset;
+	uint32_t fs_proc_flow;
+	uint32_t fs_disp_flow;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow = __raw_readl(IPU_FS_PROC_FLOW);
+	fs_disp_flow = __raw_readl(IPU_FS_DISP_FLOW);
+
+	out_dma = (1UL << channel_2_dma(src_ch, IPU_OUTPUT_BUFFER));
+	in_dma = (1UL << channel_2_dma(dest_ch, IPU_INPUT_BUFFER));
+
+	/* PROCESS THE OUTPUT DMA CH */
+	switch (out_dma) {
+		/*VF-> */
+	case IDMA_IC_1:
+		pr_debug("Link VF->");
+		isProc = true;
+		mask = FS_PRPVF_DEST_SEL_MASK;
+		offset = FS_PRPVF_DEST_SEL_OFFSET;
+		 /*->VF_ROT */
+		value = (in_dma == IDMA_IC_11) ? FS_DEST_ROT :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_FG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->ADC1 */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADCDirect */
+		    0;
+		break;
+
+		/*VF_ROT-> */
+	case IDMA_IC_9:
+		pr_debug("Link VF_ROT->");
+		isProc = true;
+		mask = FS_PRPVF_ROT_DEST_SEL_MASK;
+		offset = FS_PRPVF_ROT_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/*->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    0;
+		break;
+
+		/*ENC-> */
+	case IDMA_IC_0:
+		pr_debug("Link ENC->");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (in_dma == IDMA_IC_10) ? FS_PRPENC_DEST_SEL :
+			/*->ENC_ROT	*/
+		    0;
+		break;
+
+		/*PP-> */
+	case IDMA_IC_2:
+		pr_debug("Link PP->");
+		isProc = true;
+		mask = FS_PP_DEST_SEL_MASK;
+		offset = FS_PP_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_13) ? FS_DEST_ROT :
+			/*->PP_ROT */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    /* ->ADCDirect */
+		    0;
+		break;
+
+		/*PP_ROT-> */
+	case IDMA_IC_12:
+		pr_debug("Link PP_ROT->");
+		isProc = true;
+		mask = FS_PP_ROT_DEST_SEL_MASK;
+		offset = FS_PP_ROT_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_5) ? FS_DEST_ROT :
+			/*->PP */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    0;
+		break;
+
+		/*PF-> */
+	case IDMA_PF_Y_OUT:
+	case IDMA_PF_U_OUT:
+	case IDMA_PF_V_OUT:
+		pr_debug("Link PF->");
+		isProc = true;
+		mask = FS_PF_DEST_SEL_MASK;
+		offset = FS_PF_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_5) ? FS_PF_DEST_PP :
+		    (in_dma == IDMA_IC_13) ? FS_PF_DEST_ROT : 0;
+		break;
+
+		/* Invalid Chainings: ENC_ROT-> */
+	default:
+		pr_debug("Link Invalid->");
+		value = 0;
+		break;
+
+	}
+
+	if (value) {
+		if (isProc) {
+			fs_proc_flow &= ~mask;
+			fs_proc_flow |= (value << offset);
+		} else {
+			fs_disp_flow &= ~mask;
+			fs_disp_flow |= (value << offset);
+		}
+	} else {
+		dev_err(g_ipu_dev, "Invalid channel chaining %d -> %d\n",
+			out_dma, in_dma);
+		return -EINVAL;
+	}
+
+	/* PROCESS THE INPUT DMA CH */
+	switch (in_dma) {
+		/* ->VF_ROT */
+	case IDMA_IC_11:
+		pr_debug("VF_ROT\n");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (out_dma == IDMA_IC_1) ? FS_PRPVF_ROT_SRC_SEL :
+			/*VF-> */
+		    0;
+		break;
+
+		/* ->ENC_ROT */
+	case IDMA_IC_10:
+		pr_debug("ENC_ROT\n");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (out_dma == IDMA_IC_0) ? FS_PRPENC_ROT_SRC_SEL :
+			/*ENC-> */
+		    0;
+		break;
+
+		/* ->PP */
+	case IDMA_IC_5:
+		pr_debug("PP\n");
+		isProc = true;
+		mask = FS_PP_SRC_SEL_MASK;
+		offset = FS_PP_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_PF_Y_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_U_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_V_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_IC_12) ? FS_PP_SRC_ROT :
+			/*PP_ROT-> */
+		    0;
+		break;
+
+		/* ->PP_ROT */
+	case IDMA_IC_13:
+		pr_debug("PP_ROT\n");
+		isProc = true;
+		mask = FS_PP_ROT_SRC_SEL_MASK;
+		offset = FS_PP_ROT_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_PF_Y_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_U_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_V_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_IC_2) ? FS_ROT_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->SDC_BG */
+	case IDMA_SDC_BG:
+		pr_debug("SDC_BG\n");
+		isProc = false;
+		mask = FS_SDC_BG_SRC_SEL_MASK;
+		offset = FS_SDC_BG_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->SDC_FG */
+	case IDMA_SDC_FG:
+		pr_debug("SDC_FG\n");
+		isProc = false;
+		mask = FS_SDC_FG_SRC_SEL_MASK;
+		offset = FS_SDC_FG_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->ADC1 */
+	case IDMA_ADC_SYS1_WR:
+		pr_debug("ADC_SYS1\n");
+		isProc = false;
+		mask = FS_ADC1_SRC_SEL_MASK;
+		offset = FS_ADC1_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->ADC2 */
+	case IDMA_ADC_SYS2_WR:
+		pr_debug("ADC_SYS2\n");
+		isProc = false;
+		mask = FS_ADC2_SRC_SEL_MASK;
+		offset = FS_ADC2_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/*Invalid chains: */
+		/* ->ENC, ->VF, ->PF, ->VF_COMBINE, ->PP_COMBINE */
+	default:
+		pr_debug("Invalid\n");
+		value = 0;
+		break;
+
+	}
+
+	if (value) {
+		if (isProc) {
+			fs_proc_flow &= ~mask;
+			fs_proc_flow |= (value << offset);
+		} else {
+			fs_disp_flow &= ~mask;
+			fs_disp_flow |= (value << offset);
+		}
+	} else {
+		dev_err(g_ipu_dev, "Invalid channel chaining %d -> %d\n",
+			out_dma, in_dma);
+		return -EINVAL;
+	}
+
+	__raw_writel(fs_proc_flow, IPU_FS_PROC_FLOW);
+	__raw_writel(fs_disp_flow, IPU_FS_DISP_FLOW);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_link_channels);
+
+/*!
+ * This function unlinks 2 channels and disables automatic frame
+ * synchronization.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	unsigned long lock_flags;
+	uint32_t out_dma;
+	uint32_t in_dma;
+	uint32_t fs_proc_flow;
+	uint32_t fs_disp_flow;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow = __raw_readl(IPU_FS_PROC_FLOW);
+	fs_disp_flow = __raw_readl(IPU_FS_DISP_FLOW);
+
+	out_dma = (1UL << channel_2_dma(src_ch, IPU_OUTPUT_BUFFER));
+	in_dma = (1UL << channel_2_dma(dest_ch, IPU_INPUT_BUFFER));
+
+	/*clear the src_ch's output destination */
+	switch (out_dma) {
+		/*VF-> */
+	case IDMA_IC_1:
+		pr_debug("Unlink VF->");
+		fs_proc_flow &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+
+		/*VF_ROT-> */
+	case IDMA_IC_9:
+		pr_debug("Unlink VF_Rot->");
+		fs_proc_flow &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		break;
+
+		/*ENC-> */
+	case IDMA_IC_0:
+		pr_debug("Unlink ENC->");
+		fs_proc_flow &= ~FS_PRPENC_DEST_SEL;
+		break;
+
+		/*PP-> */
+	case IDMA_IC_2:
+		pr_debug("Unlink PP->");
+		fs_proc_flow &= ~FS_PP_DEST_SEL_MASK;
+		break;
+
+		/*PP_ROT-> */
+	case IDMA_IC_12:
+		pr_debug("Unlink PP_ROT->");
+		fs_proc_flow &= ~FS_PP_ROT_DEST_SEL_MASK;
+		break;
+
+		/*PF-> */
+	case IDMA_PF_Y_OUT:
+	case IDMA_PF_U_OUT:
+	case IDMA_PF_V_OUT:
+		pr_debug("Unlink PF->");
+		fs_proc_flow &= ~FS_PF_DEST_SEL_MASK;
+		break;
+
+	default:		/*ENC_ROT->     */
+		pr_debug("Unlink Invalid->");
+		break;
+	}
+
+	/*clear the dest_ch's input source */
+	switch (in_dma) {
+	/*->VF_ROT*/
+	case IDMA_IC_11:
+		pr_debug("VF_ROT\n");
+		fs_proc_flow &= ~FS_PRPVF_ROT_SRC_SEL;
+		break;
+
+	/*->Enc_ROT*/
+	case IDMA_IC_10:
+		pr_debug("ENC_ROT\n");
+		fs_proc_flow &= ~FS_PRPENC_ROT_SRC_SEL;
+		break;
+
+	/*->PP*/
+	case IDMA_IC_5:
+		pr_debug("PP\n");
+		fs_proc_flow &= ~FS_PP_SRC_SEL_MASK;
+		break;
+
+	/*->PP_ROT*/
+	case IDMA_IC_13:
+		pr_debug("PP_ROT\n");
+		fs_proc_flow &= ~FS_PP_ROT_SRC_SEL_MASK;
+		break;
+
+	/*->SDC_FG*/
+	case IDMA_SDC_FG:
+		pr_debug("SDC_FG\n");
+		fs_disp_flow &= ~FS_SDC_FG_SRC_SEL_MASK;
+		break;
+
+	/*->SDC_BG*/
+	case IDMA_SDC_BG:
+		pr_debug("SDC_BG\n");
+		fs_disp_flow &= ~FS_SDC_BG_SRC_SEL_MASK;
+		break;
+
+	/*->ADC1*/
+	case IDMA_ADC_SYS1_WR:
+		pr_debug("ADC_SYS1\n");
+		fs_disp_flow &= ~FS_ADC1_SRC_SEL_MASK;
+		break;
+
+	/*->ADC2*/
+	case IDMA_ADC_SYS2_WR:
+		pr_debug("ADC_SYS2\n");
+		fs_disp_flow &= ~FS_ADC2_SRC_SEL_MASK;
+		break;
+
+		/*->VF, ->ENC, ->VF_COMBINE, ->PP_COMBINE, ->PF*/
+	default:
+		pr_debug("Invalid\n");
+		break;
+	}
+
+	__raw_writel(fs_proc_flow, IPU_FS_PROC_FLOW);
+	__raw_writel(fs_disp_flow, IPU_FS_DISP_FLOW);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_unlink_channels);
+
+/*!
+ * This function enables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_enable_channel(ipu_channel_t channel)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t sec_dma;
+	uint32_t out_dma;
+	uint32_t chan_mask = 0;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IDMAC_CHA_EN);
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	if (out_dma != IDMA_CHAN_INVALID)
+		reg |= 1UL << out_dma;
+	in_dma = channel_2_dma(channel, IPU_INPUT_BUFFER);
+	if (in_dma != IDMA_CHAN_INVALID)
+		reg |= 1UL << in_dma;
+
+	/* Get secondary input dma channel */
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)]) {
+		sec_dma = channel_2_dma(channel, IPU_SEC_INPUT_BUFFER);
+		if (sec_dma != IDMA_CHAN_INVALID)
+			reg |= 1UL << sec_dma;
+	}
+
+	__raw_writel(reg | chan_mask, IDMAC_CHA_EN);
+
+	if (IPU_CHAN_ID(channel) <= IPU_CHAN_ID(MEM_PP_ADC))
+		_ipu_ic_enable_task(channel);
+	else if (channel == MEM_SDC_BG) {
+		dev_dbg(g_ipu_dev, "Initializing SDC BG\n");
+		_ipu_sdc_bg_init(NULL);
+	} else if (channel == MEM_SDC_FG) {
+		dev_dbg(g_ipu_dev, "Initializing SDC FG\n");
+		_ipu_sdc_fg_init(NULL);
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_enable_channel);
+
+/*!
+ * This function disables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       wait_for_stop   Flag to set whether to wait for channel end
+ *                              of frame or return immediately.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t sec_dma;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t chan_mask = 0;
+	uint32_t timeout;
+	uint32_t eof_intr;
+	uint32_t enabled;
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	if (out_dma != IDMA_CHAN_INVALID)
+		chan_mask = 1UL << out_dma;
+	in_dma = channel_2_dma(channel, IPU_INPUT_BUFFER);
+	if (in_dma != IDMA_CHAN_INVALID)
+		chan_mask |= 1UL << in_dma;
+	sec_dma = channel_2_dma(channel, IPU_SEC_INPUT_BUFFER);
+	if (sec_dma != IDMA_CHAN_INVALID)
+		chan_mask |= 1UL << sec_dma;
+
+	if (wait_for_stop && channel != MEM_SDC_FG && channel != MEM_SDC_BG) {
+		timeout = 40;
+		while ((__raw_readl(IDMAC_CHA_BUSY) & chan_mask) ||
+		       (_ipu_channel_status(channel) == TASK_STAT_ACTIVE)) {
+			timeout--;
+			msleep(10);
+			if (timeout == 0) {
+				printk
+				    (KERN_INFO
+				     "MXC IPU: Warning - timeout waiting"
+					 "for channel to stop,\n"
+				     "\tbuf0_rdy = 0x%08X, buf1_rdy = 0x%08X\n"
+				     "\tbusy = 0x%08X, tstat = 0x%08X\n\t"
+					 "mask = 0x%08X\n",
+				     __raw_readl(IPU_CHA_BUF0_RDY),
+				     __raw_readl(IPU_CHA_BUF1_RDY),
+				     __raw_readl(IDMAC_CHA_BUSY),
+				     __raw_readl(IPU_TASKS_STAT), chan_mask);
+				break;
+			}
+		}
+		dev_dbg(g_ipu_dev, "timeout = %d * 10ms\n", 40 - timeout);
+	}
+	/* SDC BG and FG must be disabled before DMA is disabled */
+	if ((channel == MEM_SDC_BG) || (channel == MEM_SDC_FG)) {
+
+		if (channel == MEM_SDC_BG)
+			eof_intr = IPU_IRQ_SDC_BG_EOF;
+		else
+			eof_intr = IPU_IRQ_SDC_FG_EOF;
+
+		/* Wait for any buffer flips to finsh */
+		timeout = 4;
+		while (timeout &&
+			((__raw_readl(IPU_CHA_BUF0_RDY) & chan_mask) ||
+				(__raw_readl(IPU_CHA_BUF1_RDY) & chan_mask))) {
+			msleep(10);
+			timeout--;
+		}
+
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		ipu_clear_irq(eof_intr);
+
+		if (channel == MEM_SDC_BG)
+			enabled = _ipu_sdc_bg_uninit();
+		else
+			enabled = _ipu_sdc_fg_uninit();
+
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+		if (enabled && wait_for_stop)
+			timeout = 5;
+		else
+			timeout = 0;
+
+		while (timeout && !ipu_get_irq_status(eof_intr)) {
+			msleep(5);
+			timeout--;
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (IPU_CHAN_ID(channel) <= IPU_CHAN_ID(MEM_PP_ADC))
+		_ipu_ic_disable_task(channel);
+
+	/* Disable DMA channel(s) */
+	reg = __raw_readl(IDMAC_CHA_EN);
+	__raw_writel(reg & ~chan_mask, IDMAC_CHA_EN);
+
+	/* Clear DMA related interrupts */
+	__raw_writel(chan_mask, IPU_INT_STAT_1);
+	__raw_writel(chan_mask, IPU_INT_STAT_2);
+	__raw_writel(chan_mask, IPU_INT_STAT_4);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disable_channel);
+
+static
+irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	uint32_t line_base = 0;
+	uint32_t line;
+	irqreturn_t result = IRQ_NONE;
+	uint32_t int_stat;
+
+	if (g_ipu_irq[1]) {
+		disable_irq(g_ipu_irq[0]);
+		disable_irq(g_ipu_irq[1]);
+	}
+
+	int_stat = __raw_readl(IPU_INT_STAT_1);
+	int_stat &= __raw_readl(IPU_INT_CTRL_1);
+	__raw_writel(int_stat, IPU_INT_STAT_1);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 32;
+	int_stat = __raw_readl(IPU_INT_STAT_2);
+	int_stat &= __raw_readl(IPU_INT_CTRL_2);
+	__raw_writel(int_stat, IPU_INT_STAT_2);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 64;
+	int_stat = __raw_readl(IPU_INT_STAT_3);
+	int_stat &= __raw_readl(IPU_INT_CTRL_3);
+	__raw_writel(int_stat, IPU_INT_STAT_3);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 96;
+	int_stat = __raw_readl(IPU_INT_STAT_4);
+	int_stat &= __raw_readl(IPU_INT_CTRL_4);
+	__raw_writel(int_stat, IPU_INT_STAT_4);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 128;
+	int_stat = __raw_readl(IPU_INT_STAT_5);
+	int_stat &= __raw_readl(IPU_INT_CTRL_5);
+	__raw_writel(int_stat, IPU_INT_STAT_5);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	if (g_ipu_irq[1]) {
+		enable_irq(g_ipu_irq[0]);
+		enable_irq(g_ipu_irq[1]);
+	}
+	return result;
+}
+
+/*!
+ * This function enables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to enable interrupt for.
+ *
+ */
+void ipu_enable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_enable_irq);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_disable_irq);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq(uint32_t irq)
+{
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+}
+EXPORT_SYMBOL(ipu_clear_irq);
+
+/*!
+ * This function returns the current interrupt
+ * status for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @return      Returns true if the interrupt is pending/asserted or false if
+ *              the interrupt is not pending.
+ */
+bool ipu_get_irq_status(uint32_t irq)
+{
+	uint32_t reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+
+	if (reg & IPUIRQ_2_MASK(irq))
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(ipu_get_irq_status);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	unsigned long lock_flags;
+
+	MXC_ERR_CHK(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (ipu_irq_list[irq].handler != NULL) {
+		dev_err(g_ipu_dev,
+			"ipu_request_irq - handler already"
+			"installed on irq %d\n",
+			irq);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	ipu_irq_list[irq].handler = handler;
+	ipu_irq_list[irq].flags = irq_flags;
+	ipu_irq_list[irq].dev_id = dev_id;
+	ipu_irq_list[irq].name = devname;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	ipu_enable_irq(irq);	/* enable the interrupt */
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_request_irq);
+
+/*!
+ * This function unregisters an interrupt handler for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler. This must match value passed to
+ *                              ipu_request_irq().
+ *
+ */
+void ipu_free_irq(uint32_t irq, void *dev_id)
+{
+	ipu_disable_irq(irq);	/* disable the interrupt */
+
+	if (ipu_irq_list[irq].dev_id == dev_id)
+		ipu_irq_list[irq].handler = NULL;
+}
+EXPORT_SYMBOL(ipu_free_irq);
+
+/*!
+ * This function sets the post-filter pause row for h.264 mode.
+ *
+ * @param       pause_row       The last row to process before pausing.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ *
+ */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row)
+{
+	int32_t retval = 0;
+	uint32_t timeout = 5;
+	unsigned long lock_flags;
+	uint32_t reg;
+
+	reg = __raw_readl(IPU_TASKS_STAT);
+	while ((reg & TSTAT_PF_MASK) && ((reg & TSTAT_PF_H264_PAUSE) == 0)) {
+		timeout--;
+		msleep(5);
+		if (timeout == 0) {
+			dev_err(g_ipu_dev, "PF Timeout - tstat = 0x%08X\n",
+				__raw_readl(IPU_TASKS_STAT));
+			retval = -ETIMEDOUT;
+			goto err0;
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(PF_CONF);
+
+	/* Set the pause row */
+	if (pause_row) {
+		reg &= ~PF_CONF_PAUSE_ROW_MASK;
+		reg |= PF_CONF_PAUSE_EN | pause_row << PF_CONF_PAUSE_ROW_SHIFT;
+	} else
+		reg &= ~(PF_CONF_PAUSE_EN | PF_CONF_PAUSE_ROW_MASK);
+	__raw_writel(reg, PF_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err0:
+	return retval;
+}
+EXPORT_SYMBOL(ipu_pf_set_pause_row);
+
+/* Private functions */
+void _ipu_write_param_mem(uint32_t addr, uint32_t *data, uint32_t numWords)
+{
+	for (; numWords > 0; numWords--) {
+		dev_dbg(g_ipu_dev,
+			"write param mem - addr = 0x%08X, data = 0x%08X\n",
+			addr, *data);
+		__raw_writel(addr, IPU_IMA_ADDR);
+		__raw_writel(*data++, IPU_IMA_DATA);
+		addr++;
+		if ((addr & 0x7) == 5) {
+			addr &= ~0x7;	/* set to word 0 */
+			addr += 8;	/* increment to next row */
+		}
+	}
+}
+
+static void _ipu_pf_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+
+	/*Setup the type of filtering required */
+	switch (params->mem_pf_mem.operation) {
+	case PF_MPEG4_DEBLOCK:
+	case PF_MPEG4_DERING:
+	case PF_MPEG4_DEBLOCK_DERING:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = true;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+		break;
+	case PF_H264_DEBLOCK:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = true;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = true;
+		break;
+	default:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = false;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+		return;
+		break;
+	}
+	reg = params->mem_pf_mem.operation;
+	__raw_writel(reg, PF_CONF);
+}
+
+static void _ipu_pf_uninit(void)
+{
+	__raw_writel(0x0L, PF_CONF);
+	g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = false;
+	g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+}
+
+uint32_t _ipu_channel_status(ipu_channel_t channel)
+{
+	uint32_t stat = 0;
+	uint32_t task_stat_reg = __raw_readl(IPU_TASKS_STAT);
+
+	switch (channel) {
+	case CSI_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_CSI2MEM_MASK) >>
+		    TSTAT_CSI2MEM_OFFSET;
+		break;
+	case CSI_PRP_VF_ADC:
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_ADC:
+	case MEM_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_VF_ROT_MASK) >> TSTAT_VF_ROT_OFFSET;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		stat = (task_stat_reg & TSTAT_ENC_MASK) >> TSTAT_ENC_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_ENC_ROT_MASK) >>
+		    TSTAT_ENC_ROT_OFFSET;
+		break;
+	case MEM_PP_ADC:
+	case MEM_PP_MEM:
+		stat = (task_stat_reg & TSTAT_PP_MASK) >> TSTAT_PP_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_PP_ROT_MASK) >> TSTAT_PP_ROT_OFFSET;
+		break;
+
+	case MEM_PF_Y_MEM:
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		stat = (task_stat_reg & TSTAT_PF_MASK) >> TSTAT_PF_OFFSET;
+		break;
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		stat =
+		    (task_stat_reg & TSTAT_ADCSYS1_MASK) >>
+		    TSTAT_ADCSYS1_OFFSET;
+		break;
+	case ADC_SYS2:
+		stat =
+		    (task_stat_reg & TSTAT_ADCSYS2_MASK) >>
+		    TSTAT_ADCSYS2_OFFSET;
+		break;
+	case MEM_SDC_MASK:
+	default:
+		stat = TASK_STAT_IDLE;
+		break;
+	}
+	return stat;
+}
+
+uint32_t bytes_per_pixel(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/*generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+		break;
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+		break;
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+		break;
+	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bytes_per_pixel);
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+		return RGB;
+		break;
+
+	default:
+		return YCbCr;
+		break;
+	}
+	return RGB;
+
+}
+
+static u32 saved_disp3_time_conf;
+static bool in_lpdr_mode;
+static struct clk *default_ipu_parent_clk;
+
+int ipu_lowpwr_display_enable(void)
+{
+	unsigned long rate, div;
+	struct clk *parent_clk = g_ipu_clk;
+
+	if (in_lpdr_mode || IS_ERR(dfm_clk))
+		return -EINVAL;
+
+	if (g_channel_init_mask != (1L << IPU_CHAN_ID(MEM_SDC_BG))) {
+		dev_err(g_ipu_dev, "LPDR mode requires only SDC BG active.\n");
+		return -EINVAL;
+	}
+
+	default_ipu_parent_clk = clk_get_parent(g_ipu_clk);
+	in_lpdr_mode = true;
+
+	/* Calculate current pixel clock rate */
+	rate = clk_get_rate(g_ipu_clk) * 16;
+	saved_disp3_time_conf = __raw_readl(DI_DISP3_TIME_CONF);
+	div = saved_disp3_time_conf & 0xFFF;
+	rate /= div;
+	rate *= 4;      /* min hsp clk is 4x pixel clk */
+
+	/* Initialize DFM clock */
+	rate = clk_round_rate(dfm_clk, rate);
+	clk_set_rate(dfm_clk, rate);
+	clk_enable(dfm_clk);
+
+	/* Wait for next VSYNC */
+	 __raw_writel(IPUIRQ_2_MASK(IPU_IRQ_SDC_DISP3_VSYNC),
+		IPUIRQ_2_STATREG(IPU_IRQ_SDC_DISP3_VSYNC));
+
+	while ((__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_SDC_DISP3_VSYNC)) &
+			IPUIRQ_2_MASK(IPU_IRQ_SDC_DISP3_VSYNC)) == 0)
+		msleep_interruptible(1);
+
+	/* Set display clock divider to divide by 4 */
+	__raw_writel(((0x8) << 22) | 0x40, DI_DISP3_TIME_CONF);
+
+	clk_set_parent(parent_clk, dfm_clk);
+
+	return 0;
+}
+
+
+int ipu_lowpwr_display_disable(void)
+{
+
+	struct clk *parent_clk = g_ipu_clk;
+
+	if (!in_lpdr_mode || IS_ERR(dfm_clk))
+		return -EINVAL;
+
+
+	if (g_channel_init_mask != (1L << IPU_CHAN_ID(MEM_SDC_BG))) {
+		dev_err(g_ipu_dev, "LPDR mode requires only SDC BG active.\n");
+		return -EINVAL;
+	}
+
+	in_lpdr_mode = false;
+
+	/* Wait for next VSYNC */
+	__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_SDC_DISP3_VSYNC),
+			IPUIRQ_2_STATREG(IPU_IRQ_SDC_DISP3_VSYNC));
+	while ((__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_SDC_DISP3_VSYNC)) &
+			IPUIRQ_2_MASK(IPU_IRQ_SDC_DISP3_VSYNC)) == 0)
+		msleep_interruptible(1);
+
+	__raw_writel(saved_disp3_time_conf, DI_DISP3_TIME_CONF);
+	clk_set_parent(parent_clk, default_ipu_parent_clk);
+	clk_disable(dfm_clk);
+
+	return 0;
+}
+
+static int ipu_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (cpu_is_mx31()) {
+		/* work-around for i.Mx31 SR mode after camera related test */
+		if (g_csi_used) {
+			g_ipu_config = __raw_readl(IPU_CONF);
+			clk_enable(g_ipu_csi_clk);
+			__raw_writel(0x51, IPU_CONF);
+			g_channel_init_mask_backup = g_channel_init_mask;
+			g_channel_init_mask |= 2;
+		}
+	}
+
+	return 0;
+}
+
+static int ipu_resume(struct platform_device *pdev)
+{
+	if (cpu_is_mx31()) {
+		/* work-around for i.Mx31 SR mode after camera related test */
+		if (g_csi_used) {
+			__raw_writel(g_ipu_config, IPU_CONF);
+			clk_disable(g_ipu_csi_clk);
+			g_channel_init_mask = g_channel_init_mask_backup;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		   .name = "mxc_ipu",
+		   },
+	.probe = ipu_probe,
+	.suspend = ipu_suspend,
+	.resume = ipu_resume,
+};
+
+int32_t __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	if (g_ipu_irq[0])
+		free_irq(g_ipu_irq[0], 0);
+	if (g_ipu_irq[1])
+		free_irq(g_ipu_irq[1], 0);
+
+	platform_driver_unregister(&mxcipu_driver);
+}
+module_exit(ipu_gen_uninit);
diff --git a/drivers/mxc/ipu/ipu_csi.c b/drivers/mxc/ipu/ipu_csi.c
new file mode 100644
index 0000000..61ffc8f
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_csi.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_csi.c
+ *
+ * @brief IPU CMOS Sensor interface functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+
+static bool gipu_csi_get_mclk_flag;
+static int csi_mclk_flag;
+
+/*!
+ * ipu_csi_init_interface
+ *    Sets initial values for the CSI registers.
+ *    The width and height of the sensor and the actual frame size will be
+ *    set to the same values.
+ * @param       width        Sensor width
+ * @param       height       Sensor height
+ * @param       pixel_fmt    pixel format
+ * @param       sig          ipu_csi_signal_cfg_t structure
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t
+ipu_csi_init_interface(uint16_t width, uint16_t height, uint32_t pixel_fmt,
+		       ipu_csi_signal_cfg_t sig)
+{
+	uint32_t data = 0;
+
+	/* Set SENS_DATA_FORMAT bits (8 and 9)
+	   RGB or YUV444 is 0 which is current value
+	   in data so not set explicitly
+	   This is also the default value if attempts
+	   are made to set it to
+	   something invalid. */
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_UYVY:
+		data = CSI_SENS_CONF_DATA_FMT_YUV422;
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR24:
+		data = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
+		break;
+	case IPU_PIX_FMT_GENERIC:
+		data = CSI_SENS_CONF_DATA_FMT_BAYER;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	data |= sig.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
+	    sig.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
+	    sig.Vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
+	    sig.Hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
+	    sig.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
+	    sig.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
+	    sig.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
+	    sig.sens_clksrc << CSI_SENS_CONF_SENS_CLKSRC_SHIFT;
+
+	__raw_writel(data, CSI_SENS_CONF);
+
+	/* Setup frame size     */
+	__raw_writel(width | height << 16, CSI_SENS_FRM_SIZE);
+
+	__raw_writel(width << 16, CSI_FLASH_STROBE_1);
+	__raw_writel(height << 16 | 0x22, CSI_FLASH_STROBE_2);
+
+	/* Set CCIR registers */
+	if ((sig.clk_mode == IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE) ||
+	    (sig.clk_mode == IPU_CSI_CLK_MODE_CCIR656_INTERLACED)) {
+		__raw_writel(0x40030, CSI_CCIR_CODE_1);
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3);
+	}
+
+	dev_dbg(g_ipu_dev, "CSI_SENS_CONF = 0x%08X\n",
+		__raw_readl(CSI_SENS_CONF));
+	dev_dbg(g_ipu_dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
+		__raw_readl(CSI_ACT_FRM_SIZE));
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_init_interface);
+
+/*!
+ * ipu_csi_flash_strobe
+ *
+ * @param       flag         true to turn on flash strobe
+ *
+ * @return      0 for success
+ */
+void ipu_csi_flash_strobe(bool flag)
+{
+	if (flag == true) {
+		__raw_writel(__raw_readl(CSI_FLASH_STROBE_2) | 0x1,
+			     CSI_FLASH_STROBE_2);
+	}
+}
+EXPORT_SYMBOL(ipu_csi_flash_strobe);
+
+/*!
+ * ipu_csi_enable_mclk
+ *
+ * @param       src         enum define which source to control the clk
+ *                          CSI_MCLK_VF CSI_MCLK_ENC CSI_MCLK_RAW CSI_MCLK_I2C
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      0 for success
+ */
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait)
+{
+	if (flag == true)
+		csi_mclk_flag |= src;
+	else
+		csi_mclk_flag &= ~src;
+
+	if (gipu_csi_get_mclk_flag == flag)
+		return 0;
+
+	if (flag == true) {
+		clk_enable(g_ipu_csi_clk);
+		if (wait == true)
+			msleep(10);
+		gipu_csi_get_mclk_flag = true;
+	} else if (csi_mclk_flag == 0) {
+		clk_disable(g_ipu_csi_clk);
+		gipu_csi_get_mclk_flag = flag;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_enable_mclk);
+
+/*!
+ * ipu_csi_read_mclk_flag
+ *
+ * @return  csi_mclk_flag
+ */
+int ipu_csi_read_mclk_flag(void)
+{
+	return csi_mclk_flag;
+}
+EXPORT_SYMBOL(ipu_csi_read_mclk_flag);
+
+/*!
+ * ipu_csi_get_window_size
+ *
+ * @param       width        pointer to window width
+ * @param       height       pointer to window height
+ * @param		dummy		dummy for IPUv1 to keep the same interface with IPUv3
+ *
+ */
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height,
+		uint32_t dummy)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(CSI_ACT_FRM_SIZE);
+	*width = (reg & 0xFFFF) + 1;
+	*height = (reg >> 16 & 0xFFFF) + 1;
+}
+EXPORT_SYMBOL(ipu_csi_get_window_size);
+
+/*!
+ * ipu_csi_set_window_size
+ *
+ * @param       width        window width
+ * @param       height       window height
+ * @param		dummy		dummy for IPUv1 to keep the same interface with IPUv3
+ *
+ */
+void ipu_csi_set_window_size(uint32_t width, uint32_t height,
+		uint32_t dummy)
+{
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_ACT_FRM_SIZE);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_size);
+
+/*!
+ * ipu_csi_set_window_pos
+ *
+ * @param       left        uint32 window x start
+ * @param       top         uint32 window y start
+ * @param		dummy		dummy for IPUv1 to keep the same interface with IPUv3
+ *
+ */
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top,
+		uint32_t dummy)
+{
+	uint32_t temp = __raw_readl(CSI_OUT_FRM_CTRL);
+	temp &= 0xffff0000;
+	temp = top | (left << 8) | temp;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_pos);
diff --git a/drivers/mxc/ipu/ipu_device.c b/drivers/mxc/ipu/ipu_device.c
new file mode 100644
index 0000000..7800a5b
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_device.c
@@ -0,0 +1,669 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_device.c
+ *
+ * @brief This file contains the IPU driver device interface and fops functions.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/* Strucutures and variables for exporting MXC IPU as device*/
+
+#define MAX_Q_SIZE 10
+
+static int mxc_ipu_major;
+static struct class *mxc_ipu_class;
+
+DEFINE_SPINLOCK(queue_lock);
+static DECLARE_MUTEX(user_mutex);
+
+static wait_queue_head_t waitq;
+static int pending_events;
+int read_ptr;
+int write_ptr;
+
+typedef struct _event_type {
+	int irq;
+	void *dev;
+} event_type;
+
+event_type events[MAX_Q_SIZE];
+
+int register_ipu_device(void);
+
+/* Static functions */
+
+int get_events(event_type *p)
+{
+	unsigned long flags;
+	int ret = 0;
+	spin_lock_irqsave(&queue_lock, flags);
+	if (pending_events != 0) {
+		*p = events[read_ptr];
+		read_ptr++;
+		pending_events--;
+		if (read_ptr >= MAX_Q_SIZE)
+			read_ptr = 0;
+	} else
+		ret = -1;
+
+	spin_unlock_irqrestore(&queue_lock, flags);
+	return ret;
+}
+
+static irqreturn_t mxc_ipu_generic_handler(int irq, void *dev_id)
+{
+	event_type e;
+	e.irq = irq;
+	e.dev = dev_id;
+	events[write_ptr] = e;
+	write_ptr++;
+	if (write_ptr >= MAX_Q_SIZE)
+		write_ptr = 0;
+	pending_events++;
+	/* Wakeup any blocking user context */
+	wake_up_interruptible(&waitq);
+	return IRQ_HANDLED;
+}
+
+static int mxc_ipu_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int mxc_ipu_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+
+	case IPU_INIT_CHANNEL:
+		{
+				ipu_channel_parm parm;
+				if (copy_from_user
+				(&parm, (ipu_channel_parm *) arg,
+				sizeof(ipu_channel_parm)))
+					return -EFAULT;
+				if (!parm.flag)
+					ret =
+						ipu_init_channel(parm.channel,
+								&parm.params);
+				else
+					ret = ipu_init_channel(
+						parm.channel, NULL);
+			break;
+		}
+	case IPU_UNINIT_CHANNEL:
+		{
+				ipu_channel_t ch;
+				int __user *argp = (void __user *)arg;
+				if (get_user(ch, argp))
+					return -EFAULT;
+				ipu_uninit_channel(ch);
+			break;
+		}
+	case IPU_INIT_CHANNEL_BUFFER:
+		{
+				ipu_channel_buf_parm parm;
+				if (copy_from_user
+					(&parm, (ipu_channel_buf_parm *) arg,
+					sizeof(ipu_channel_buf_parm)))
+					return -EFAULT;
+				ret =
+					ipu_init_channel_buffer(parm.channel,
+							parm.type,
+							parm.pixel_fmt,
+							parm.width, parm.height,
+							parm.stride,
+							parm.rot_mode,
+							parm.phyaddr_0,
+							parm.phyaddr_1,
+							parm.u_offset,
+							parm.v_offset);
+
+			break;
+		}
+	case IPU_UPDATE_CHANNEL_BUFFER:
+		{
+				ipu_channel_buf_parm parm;
+				if (copy_from_user
+					(&parm, (ipu_channel_buf_parm *) arg,
+					sizeof(ipu_channel_buf_parm)))
+					return -EFAULT;
+				if ((parm.phyaddr_0 != (dma_addr_t) NULL)
+					&& (parm.phyaddr_1 ==
+					(dma_addr_t) NULL))
+					ret =
+						ipu_update_channel_buffer(
+								parm.channel,
+								parm.type,
+								parm.bufNum,
+								parm.phyaddr_0);
+				else if ((parm.phyaddr_0 == (dma_addr_t) NULL)
+						&& (parm.phyaddr_1
+							!= (dma_addr_t) NULL))
+					ret =
+						ipu_update_channel_buffer(
+								parm.channel,
+								parm.type,
+								parm.bufNum,
+								parm.phyaddr_1);
+				else
+					ret = -1;
+
+			break;
+		}
+	case IPU_SELECT_CHANNEL_BUFFER:
+		{
+				ipu_channel_buf_parm parm;
+				if (copy_from_user
+					(&parm, (ipu_channel_buf_parm *) arg,
+					sizeof(ipu_channel_buf_parm)))
+					return -EFAULT;
+				ret =
+					ipu_select_buffer(parm.channel,
+							parm.type,
+							parm.bufNum);
+
+			break;
+		}
+	case IPU_LINK_CHANNELS:
+		{
+				ipu_channel_link link;
+				if (copy_from_user
+					(&link, (ipu_channel_link *) arg,
+					sizeof(ipu_channel_link)))
+					return -EFAULT;
+				ret =
+					ipu_link_channels(link.src_ch, link.dest_ch);
+
+			break;
+		}
+	case IPU_UNLINK_CHANNELS:
+		{
+				ipu_channel_link link;
+				if (copy_from_user
+					(&link, (ipu_channel_link *) arg,
+					sizeof(ipu_channel_link)))
+					return -EFAULT;
+				ret =
+					ipu_unlink_channels(link.src_ch, link.dest_ch);
+
+			break;
+		}
+	case IPU_ENABLE_CHANNEL:
+		{
+				ipu_channel_t ch;
+				int __user *argp = (void __user *)arg;
+				if (get_user(ch, argp))
+					return -EFAULT;
+				ipu_enable_channel(ch);
+			break;
+		}
+	case IPU_DISABLE_CHANNEL:
+		{
+				ipu_channel_info info;
+				if (copy_from_user
+					(&info, (ipu_channel_info *) arg,
+					sizeof(ipu_channel_info)))
+					return -EFAULT;
+				ret = ipu_disable_channel(info.channel, info.stop);
+			break;
+		}
+	case IPU_ENABLE_IRQ:
+		{
+				uint32_t irq;
+				int __user *argp = (void __user *)arg;
+				if (get_user(irq, argp))
+					return -EFAULT;
+				ipu_enable_irq(irq);
+			break;
+		}
+	case IPU_DISABLE_IRQ:
+		{
+				uint32_t irq;
+				int __user *argp = (void __user *)arg;
+				if (get_user(irq, argp))
+					return -EFAULT;
+				ipu_disable_irq(irq);
+			break;
+		}
+	case IPU_CLEAR_IRQ:
+		{
+				uint32_t irq;
+				int __user *argp = (void __user *)arg;
+				if (get_user(irq, argp))
+					return -EFAULT;
+				ipu_clear_irq(irq);
+			break;
+		}
+	case IPU_FREE_IRQ:
+		{
+				ipu_irq_info info;
+				if (copy_from_user
+					(&info, (ipu_irq_info *) arg,
+					sizeof(ipu_irq_info)))
+					return -EFAULT;
+				ipu_free_irq(info.irq, info.dev_id);
+			break;
+		}
+	case IPU_REQUEST_IRQ_STATUS:
+		{
+				uint32_t irq;
+				int __user *argp = (void __user *)arg;
+				if (get_user(irq, argp))
+					return -EFAULT;
+				ret = ipu_get_irq_status(irq);
+			break;
+		}
+	case IPU_SDC_INIT_PANEL:
+		{
+				ipu_sdc_panel_info sinfo;
+				if (copy_from_user
+					(&sinfo, (ipu_sdc_panel_info *) arg,
+					sizeof(ipu_sdc_panel_info)))
+					return -EFAULT;
+				ret =
+					ipu_sdc_init_panel(sinfo.panel,
+							sinfo.pixel_clk,
+							sinfo.width,
+							sinfo.height,
+							sinfo.pixel_fmt,
+							sinfo.hStartWidth,
+							sinfo.hSyncWidth,
+							sinfo.hEndWidth,
+							sinfo.vStartWidth,
+							sinfo.vSyncWidth,
+							sinfo.vEndWidth,
+							sinfo.signal);
+			break;
+		}
+	case IPU_SDC_SET_WIN_POS:
+		{
+				ipu_sdc_window_pos pos;
+				if (copy_from_user
+					(&pos, (ipu_sdc_window_pos *) arg,
+					sizeof(ipu_sdc_window_pos)))
+					return -EFAULT;
+				ret =
+					ipu_disp_set_window_pos(pos.channel,
+							pos.x_pos,
+							pos.y_pos);
+
+			break;
+		}
+	case IPU_SDC_SET_GLOBAL_ALPHA:
+		{
+				ipu_sdc_global_alpha g;
+				if (copy_from_user
+					(&g, (ipu_sdc_global_alpha *) arg,
+					sizeof(ipu_sdc_global_alpha)))
+					return -EFAULT;
+				ret = ipu_sdc_set_global_alpha(g.enable,
+						g.alpha);
+			break;
+		}
+	case IPU_SDC_SET_COLOR_KEY:
+		{
+				ipu_sdc_color_key c;
+				if (copy_from_user
+					(&c, (ipu_sdc_color_key *) arg,
+					sizeof(ipu_sdc_color_key)))
+					return -EFAULT;
+				ret =
+					ipu_sdc_set_color_key(c.channel,
+							c.enable,
+							c.colorKey);
+			break;
+		}
+	case IPU_SDC_SET_BRIGHTNESS:
+		{
+				uint8_t b;
+				int __user *argp = (void __user *)arg;
+				if (get_user(b, argp))
+					return -EFAULT;
+				ret = ipu_sdc_set_brightness(b);
+
+			break;
+		}
+	case IPU_REGISTER_GENERIC_ISR:
+		{
+				ipu_event_info info;
+				if (copy_from_user
+					(&info, (ipu_event_info *) arg,
+					sizeof(ipu_event_info)))
+					return -EFAULT;
+				ret =
+					ipu_request_irq(info.irq,
+						mxc_ipu_generic_handler,
+						0, "video_sink", info.dev);
+			break;
+		}
+	case IPU_GET_EVENT:
+		{
+			/* User will have to allocate event_type structure
+			 * and pass the pointer in arg */
+				event_type ev;
+				int r = -1;
+				r = get_events(&ev);
+				if (r == -1) {
+					wait_event_interruptible(waitq,
+							(pending_events != 0));
+					r = get_events(&ev);
+				}
+				ret = -1;
+				if (r == 0) {
+					if (!copy_to_user((event_type *) arg,
+							&ev,
+							sizeof(event_type)))
+						ret = 0;
+				}
+			break;
+		}
+	case IPU_ADC_WRITE_TEMPLATE:
+		{
+				ipu_adc_template temp;
+				if (copy_from_user
+					(&temp, (ipu_adc_template *) arg,
+					sizeof(temp)))
+					return -EFAULT;
+				ret =
+					ipu_adc_write_template(temp.disp,
+							temp.pCmd,
+							temp.write);
+			break;
+		}
+	case IPU_ADC_UPDATE:
+		{
+				ipu_adc_update update;
+				if (copy_from_user
+					(&update, (ipu_adc_update *) arg,
+					sizeof(update)))
+					return -EFAULT;
+				ret =
+					ipu_adc_set_update_mode(
+						update.channel,
+						update.mode,
+						update.refresh_rate,
+						update.addr,
+						update.size);
+			break;
+		}
+	case IPU_ADC_SNOOP:
+		{
+				ipu_adc_snoop snoop;
+				if (copy_from_user
+					(&snoop, (ipu_adc_snoop *) arg,
+					sizeof(snoop)))
+					return -EFAULT;
+				ret =
+					ipu_adc_get_snooping_status(snoop.statl,
+							snoop.stath);
+			break;
+		}
+	case IPU_ADC_CMD:
+		{
+				ipu_adc_cmd cmd;
+				if (copy_from_user
+					(&cmd, (ipu_adc_cmd *) arg,
+					sizeof(cmd)))
+					return -EFAULT;
+				ret =
+					ipu_adc_write_cmd(cmd.disp, cmd.type,
+							cmd.cmd, cmd.params, cmd.numParams);
+			break;
+		}
+	case IPU_ADC_INIT_PANEL:
+		{
+				ipu_adc_panel panel;
+				if (copy_from_user
+					(&panel, (ipu_adc_panel *) arg,
+					sizeof(panel)))
+					return -EFAULT;
+				ret =
+					ipu_adc_init_panel(panel.disp,
+						panel.width,
+						panel.height,
+						panel.pixel_fmt,
+						panel.stride,
+						panel.signal,
+						panel.addr,
+						panel.vsync_width,
+						panel.mode);
+			break;
+		}
+	case IPU_ADC_IFC_TIMING:
+		{
+				ipu_adc_ifc_timing t;
+				if (copy_from_user
+					(&t, (ipu_adc_ifc_timing *) arg,
+					sizeof(t)))
+					return -EFAULT;
+				ret =
+					ipu_adc_init_ifc_timing(t.disp,
+							t.read,
+							t.cycle_time, t.up_time,
+							t.down_time,
+							t.read_latch_time,
+							t.pixel_clk);
+			break;
+		}
+	case IPU_CSI_INIT_INTERFACE:
+		{
+				ipu_csi_interface c;
+				if (copy_from_user
+					(&c, (ipu_csi_interface *) arg,
+					sizeof(c)))
+					return -EFAULT;
+				ret =
+					ipu_csi_init_interface(c.width,
+							c.height,
+							c.pixel_fmt, c.signal);
+			break;
+		}
+	case IPU_CSI_ENABLE_MCLK:
+		{
+				ipu_csi_mclk m;
+				if (copy_from_user
+					(&m, (ipu_csi_mclk *) arg,
+					sizeof(m)))
+					return -EFAULT;
+				ret =
+					ipu_csi_enable_mclk(m.src, m.flag, m.wait);
+			break;
+		}
+	case IPU_CSI_READ_MCLK_FLAG:
+				ret = ipu_csi_read_mclk_flag();
+			break;
+	case IPU_CSI_FLASH_STROBE:
+			{
+				bool strobe;
+				int __user *argp = (void __user *)arg;
+				if (get_user(strobe, argp))
+					return -EFAULT;
+				ipu_csi_flash_strobe(strobe);
+			break;
+			}
+	case IPU_CSI_GET_WIN_SIZE:
+			{
+				ipu_csi_window_size w;
+				int dummy = 0;
+				ipu_csi_get_window_size
+					(&w.width, &w.height, dummy);
+				if (copy_to_user
+					((ipu_csi_window_size *) arg,
+					&w, sizeof(w)))
+					return -EFAULT;
+			break;
+			}
+	case IPU_CSI_SET_WIN_SIZE:
+			{
+				ipu_csi_window_size w;
+				int dummy = 0;
+				if (copy_from_user
+					(&w, (ipu_csi_window_size *) arg, sizeof(w)))
+					return -EFAULT;
+				ipu_csi_set_window_size(w.width,
+					w.height, dummy);
+			break;
+			}
+	case IPU_CSI_SET_WINDOW:
+			{
+				ipu_csi_window p;
+				int dummy = 0;
+				if (copy_from_user
+					(&p, (ipu_csi_window *) arg, sizeof(p)))
+					return -EFAULT;
+				ipu_csi_set_window_pos(p.left, p.top, dummy);
+			break;
+			}
+	case IPU_PF_SET_PAUSE_ROW:
+			{
+				uint32_t p;
+				int __user *argp = (void __user *)arg;
+				if (get_user(p, argp))
+					return -EFAULT;
+				ret = ipu_pf_set_pause_row(p);
+			break;
+			}
+	case IPU_ALOC_MEM:
+			{
+				ipu_mem_info info;
+				if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					sizeof(ipu_mem_info)))
+					return -EFAULT;
+
+				info.vaddr = dma_alloc_coherent(0,
+						PAGE_ALIGN(info.size),
+						&info.paddr,
+						GFP_DMA | GFP_KERNEL);
+				if (info.vaddr == 0) {
+					printk(KERN_ERR "dma alloc failed!\n");
+					return -ENOBUFS;
+				}
+				if (copy_to_user((ipu_mem_info *) arg, &info,
+					sizeof(ipu_mem_info)) > 0)
+					return -EFAULT;
+			break;
+			}
+	case IPU_FREE_MEM:
+			{
+				ipu_mem_info info;
+				if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					sizeof(ipu_mem_info)))
+					return -EFAULT;
+
+				if (info.vaddr != 0)
+					dma_free_coherent(0,
+							PAGE_ALIGN(info.size),
+							info.vaddr, info.paddr);
+				else
+					return -EFAULT;
+			break;
+			}
+	default:
+			break;
+
+	}
+	return ret;
+}
+
+static int mxc_ipu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		printk(KERN_ERR
+				"mmap failed!\n");
+		return -ENOBUFS;
+	}
+	return 0;
+}
+
+static int mxc_ipu_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static struct file_operations mxc_ipu_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_ipu_open,
+	.mmap = mxc_ipu_mmap,
+	.release = mxc_ipu_release,
+	.ioctl = mxc_ipu_ioctl
+};
+
+int register_ipu_device()
+{
+	int ret = 0;
+	struct device *temp;
+	mxc_ipu_major = register_chrdev(0, "mxc_ipu", &mxc_ipu_fops);
+	if (mxc_ipu_major < 0) {
+		printk(KERN_ERR
+			"Unable to register Mxc Ipu as a char device\n");
+		return mxc_ipu_major;
+	}
+
+	mxc_ipu_class = class_create(THIS_MODULE, "mxc_ipu");
+	if (IS_ERR(mxc_ipu_class)) {
+		printk(KERN_ERR "Unable to create class for Mxc Ipu\n");
+		ret = PTR_ERR(mxc_ipu_class);
+		goto err1;
+	}
+
+	temp = device_create(mxc_ipu_class, NULL, MKDEV(mxc_ipu_major, 0),
+			NULL, "mxc_ipu");
+
+	if (IS_ERR(temp)) {
+		printk(KERN_ERR "Unable to create class device for Mxc Ipu\n");
+		ret = PTR_ERR(temp);
+		goto err2;
+	}
+	spin_lock_init(&queue_lock);
+	init_waitqueue_head(&waitq);
+	return ret;
+
+err2:
+	class_destroy(mxc_ipu_class);
+err1:
+	unregister_chrdev(mxc_ipu_major, "mxc_ipu");
+	return ret;
+
+}
diff --git a/drivers/mxc/ipu/ipu_ic.c b/drivers/mxc/ipu/ipu_ic.c
new file mode 100644
index 0000000..f5c4d31
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_ic.c
@@ -0,0 +1,576 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_ic.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum {
+	IC_TASK_VIEWFINDER,
+	IC_TASK_ENCODER,
+	IC_TASK_POST_PROCESSOR
+};
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format);
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff);
+
+void _ipu_ic_enable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_ADC:
+	case MEM_PP_MEM:
+		ic_conf |= IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf |= IC_CONF_PP_ROT_EN;
+		break;
+	case CSI_MEM:
+		ic_conf |= IC_CONF_RWS_EN | IC_CONF_PRPENC_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_disable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_ADC:
+	case MEM_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_ROT_EN;
+		break;
+	case CSI_MEM:
+		ic_conf &= ~(IC_CONF_RWS_EN | IC_CONF_PRPENC_EN);
+		break;
+	default:
+		break;
+	}
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_height,
+			    params->mem_prp_vf_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
+			    params->mem_prp_vf_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_VF_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+			/* Enable RGB->YCBCR CSC */
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+			/* Enable YCBCR->RGB CSC */
+		}
+	}
+
+	if (params->mem_prp_vf_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PRPVF_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PRPVF_CSC1;
+		/* Enable RGB->RGB CSC */
+
+		if (params->mem_prp_vf_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_prp_vf_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else
+		ic_conf &= ~IC_CONF_PP_CMB;
+
+#ifndef CONFIG_VIRTIO_SUPPORT
+	/* Setting RWS_EN doesn't work in Virtio */
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+#endif
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpvf(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPVF_EN | IC_CONF_PRPVF_CMB |
+		 IC_CONF_PRPVF_CSC2 | IC_CONF_PRPVF_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_vf(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PRPVF_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_csi(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_CSI_MEM_WR_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_uninit_csi(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_RWS_EN | IC_CONF_PRPENC_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_height,
+			    params->mem_prp_enc_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
+			    params->mem_prp_enc_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_ENC_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_enc_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_enc_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV))
+			pr_debug("error\n");
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_ENCODER, YCbCr, RGB);
+			/* Enable YCBCR->RGB CSC */
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		} else
+			/* TODO: Support YUV<->YCbCr conversion? */
+			pr_debug("unsupportd yuv<->ycrcb\n");
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpenc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_enc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_ROT_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_pp(ipu_channel_params_t *params)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_height,
+			    params->mem_pp_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_width,
+			    params->mem_pp_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PP_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_pp_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt);
+			ic_conf |= IC_CONF_PP_CSC2;
+			/* Enable RGB->YCBCR CSC */
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB);
+			ic_conf |= IC_CONF_PP_CSC1;
+			/* Enable YCBCR->RGB CSC */
+		} else
+			/* TODO: Support YUV<->YCbCr conversion? */
+			pr_debug("Support YUV<->YCbCr conversion?");
+	}
+
+	if (params->mem_pp_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PP_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PP_CSC1;	/* Enable RGB->RGB CSC */
+
+		if (params->mem_pp_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_pp_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else
+		ic_conf &= ~IC_CONF_PP_CMB;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_pp(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PP_EN | IC_CONF_PP_CSC1 | IC_CONF_PP_CSC2 |
+		 IC_CONF_PP_CMB);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_pp(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PP_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format)
+{
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+	static const uint32_t rgb2ycbcr_coeff[4][3] = {
+		{0x004D, 0x0096, 0x001D},
+		{0x01D5, 0x01AB, 0x0080},
+		{0x0080, 0x0195, 0x01EB},
+		{0x0000, 0x0200, 0x0200},	/* A0, A1, A2 */
+	};
+
+	/* transparent RGB->RGB matrix for combining
+	 */
+	static const uint32_t rgb2rgb_coeff[4][3] = {
+		{0x0080, 0x0000, 0x0000},
+		{0x0000, 0x0080, 0x0000},
+		{0x0000, 0x0000, 0x0080},
+		{0x0000, 0x0000, 0x0000},	/* A0, A1, A2 */
+	};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+	static const uint32_t ycbcr2rgb_coeff[4][3] = {
+		{149, 0, 204},
+		{149, 462, 408},
+		{149, 255, 0},
+		{8192 - 446, 266, 8192 - 554},	/* A0, A1, A2 */
+	};
+
+	uint32_t param[2];
+	uint32_t address = 0;
+
+	if (ic_task == IC_TASK_VIEWFINDER) {
+		address = 0x5A5 << 3;
+	} else if (ic_task == IC_TASK_ENCODER) {
+		address = 0x2D1 << 3;
+	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+		address = 0x87C << 3;
+	} else {
+		MXC_ERR_CHK(1);
+		return;
+	}
+
+	if ((in_format == YCbCr) && (out_format == RGB)) {
+		/* Init CSC1 (YCbCr->RGB) */
+		param[0] =
+		    (ycbcr2rgb_coeff[3][0] << 27) | (ycbcr2rgb_coeff[0][0] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][1] << 9) | ycbcr2rgb_coeff[2][2];
+		/* scale = 2, sat = 0 */
+		param[1] = (ycbcr2rgb_coeff[3][0] >> 5) | (2L << (40 - 32));
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (ycbcr2rgb_coeff[3][1] << 27) | (ycbcr2rgb_coeff[0][1] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][0] << 9) | ycbcr2rgb_coeff[2][0];
+		param[1] = (ycbcr2rgb_coeff[3][1] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (ycbcr2rgb_coeff[3][2] << 27) | (ycbcr2rgb_coeff[0][2] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][2] << 9) | ycbcr2rgb_coeff[2][1];
+		param[1] = (ycbcr2rgb_coeff[3][2] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else if ((in_format == RGB) && (out_format == YCbCr)) {
+		/* Init CSC1 (RGB->YCbCr) */
+		param[0] =
+		    (rgb2ycbcr_coeff[3][0] << 27) | (rgb2ycbcr_coeff[0][0] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][1] << 9) | rgb2ycbcr_coeff[2][2];
+		/* scale = 1, sat = 0 */
+		param[1] = (rgb2ycbcr_coeff[3][0] >> 5) | (1UL << 8);
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2ycbcr_coeff[3][1] << 27) | (rgb2ycbcr_coeff[0][1] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][0] << 9) | rgb2ycbcr_coeff[2][0];
+		param[1] = (rgb2ycbcr_coeff[3][1] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2ycbcr_coeff[3][2] << 27) | (rgb2ycbcr_coeff[0][2] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][2] << 9) | rgb2ycbcr_coeff[2][1];
+		param[1] = (rgb2ycbcr_coeff[3][2] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else if ((in_format == RGB) && (out_format == RGB)) {
+		/* Init CSC1 */
+		param[0] =
+		    (rgb2rgb_coeff[3][0] << 27) | (rgb2rgb_coeff[0][0] << 18) |
+		    (rgb2rgb_coeff[1][1] << 9) | rgb2rgb_coeff[2][2];
+		/* scale = 2, sat = 0 */
+		param[1] = (rgb2rgb_coeff[3][0] >> 5) | (2UL << 8);
+
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2rgb_coeff[3][1] << 27) | (rgb2rgb_coeff[0][1] << 18) |
+		    (rgb2rgb_coeff[1][0] << 9) | rgb2rgb_coeff[2][0];
+		param[1] = (rgb2rgb_coeff[3][1] >> 5);
+
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2rgb_coeff[3][2] << 27) | (rgb2rgb_coeff[0][2] << 18) |
+		    (rgb2rgb_coeff[1][2] << 9) | rgb2rgb_coeff[2][1];
+		param[1] = (rgb2rgb_coeff[3][2] >> 5);
+
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else {
+		dev_err(g_ipu_dev, "Unsupported color space conversion\n");
+	}
+}
+
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff)
+{
+	uint32_t tempSize;
+	uint32_t tempDownsize;
+
+	/* Cannot downsize more than 8:1 */
+	if ((outSize << 3) < inSize)
+		return false;
+	/* compute downsizing coefficient */
+	tempDownsize = 0;
+	tempSize = inSize;
+	while ((tempSize >= outSize * 2) && (tempDownsize < 2)) {
+		tempSize >>= 1;
+		tempDownsize++;
+	}
+	*downsizeCoeff = tempDownsize;
+
+	/* compute resizing coefficient using the following equation:
+	   resizeCoeff = M*(SI -1)/(SO - 1)
+	   where M = 2^13, SI - input size, SO - output size    */
+	*resizeCoeff = (8192L * (tempSize - 1)) / (outSize - 1);
+	if (*resizeCoeff >= 16384L) {
+		dev_err(g_ipu_dev, "Warning! Overflow on resize coeff.\n");
+		*resizeCoeff = 0x3FFF;
+	}
+
+	dev_dbg(g_ipu_dev, "resizing from %u -> %u pixels, "
+		"downsize=%u, resize=%u.%lu (reg=%u)\n", inSize, outSize,
+		*downsizeCoeff, (*resizeCoeff >= 8192L) ? 1 : 0,
+		((*resizeCoeff & 0x1FFF) * 10000L) / 8192L, *resizeCoeff);
+
+	return true;
+}
diff --git a/drivers/mxc/ipu/ipu_param_mem.h b/drivers/mxc/ipu/ipu_param_mem.h
new file mode 100644
index 0000000..e4272c0
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_param_mem.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PARAM_MEM_H__
+#define __INCLUDE_IPU_PARAM_MEM_H__
+
+#include <linux/types.h>
+
+static inline void _ipu_ch_param_set_size(uint32_t *params,
+					    uint32_t pixel_fmt, uint16_t width,
+					    uint16_t height, uint16_t stride,
+					    uint32_t u, uint32_t v)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	memset(params, 0, 40);
+
+	params[3] =
+	    (uint32_t) ((width - 1) << 12) | ((uint32_t) (height - 1) << 24);
+	params[4] = (uint32_t) (height - 1) >> 8;
+	params[7] = (uint32_t) (stride - 1) << 3;
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/*Represents 8-bit Generic data */
+		params[7] |= 3 | (7UL << (81 - 64)) | (31L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2;	/* SAT = use 32-bit access */
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/*Represents 32-bit Generic data */
+		params[7] |= (7UL << (81 - 64)) | (7L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2;	/* SAT = use 32-bit access */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		params[7] |= 2L | (4UL << (81 - 64)) | (7L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (0UL << (99 - 96)) |	/* Red bit offset */
+		    (5UL << (104 - 96)) |	/* Green bit offset     */
+		    (11UL << (109 - 96)) |	/* Blue bit offset */
+		    (16UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (4UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (5UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (4UL << (125 - 96));
+		/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_BGR24:	/* 24 BPP & RGB PFS */
+		params[7] |= 1 | (4UL << (81 - 64)) | (7L << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (8UL << (104 - 96)) |	/* Green bit offset     */
+		    (16UL << (109 - 96)) |	/* Blue bit offset */
+		    (24UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));
+		/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_RGB24:	/* 24 BPP & RGB PFS     */
+		params[7] |= 1 | (4UL << (81 - 64)) | (7L << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (16UL << (99 - 96)) |	/* Red bit offset */
+		    (8UL << (104 - 96)) |	/* Green bit offset */
+		    (0UL << (109 - 96)) |	/* Blue bit offset */
+		    (24UL << (114 - 96)) |	/* Alpha bit offset */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (8UL << (99 - 96)) |	/* Red bit offset */
+		    (16UL << (104 - 96)) |	/* Green bit offset     */
+		    (24UL << (109 - 96)) |	/* Blue bit offset */
+		    (0UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		params[9] = 7;	/* Alpha bit width - 1 */
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (24UL << (99 - 96)) |	/* Red bit offset */
+		    (16UL << (104 - 96)) |	/* Green bit offset     */
+		    (8UL << (109 - 96)) |	/* Blue bit offset */
+		    (0UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		params[9] = 7;	/* Alpha bit width - 1 */
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (0UL << (99 - 96)) |	/* Alpha bit offset     */
+		    (8UL << (104 - 96)) |	/* Blue bit offset */
+		    (16UL << (109 - 96)) |	/* Green bit offset     */
+		    (24UL << (114 - 96)) |	/* Red bit offset */
+		    (7UL << (119 - 96)) |	/* Alpha bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Blue bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));
+		/* Green bit width - 1 */
+		params[9] = 7;	/* Red bit width - 1 */
+		break;
+	case IPU_PIX_FMT_UYVY:
+		/* BPP & pixel format */
+		params[7] |= 2 | (6UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (3UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 4 : v;
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (2UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (2UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+
+	params[1] = (1UL << (46 - 32)) | (u_offset << (53 - 32));
+	params[2] = u_offset >> (64 - 53);
+	params[2] |= v_offset << (79 - 64);
+	params[3] |= v_offset >> (96 - 79);
+}
+
+static inline void _ipu_ch_param_set_burst_size(uint32_t *params,
+						  uint16_t burst_pixels)
+{
+	params[7] &= ~(0x3FL << (89 - 64));
+	params[7] |= (uint32_t) (burst_pixels - 1) << (89 - 64);
+};
+
+static inline void _ipu_ch_param_set_buffer(uint32_t *params,
+					      dma_addr_t buf0, dma_addr_t buf1)
+{
+	params[5] = buf0;
+	params[6] = buf1;
+};
+
+static inline void _ipu_ch_param_set_rotation(uint32_t *params,
+						ipu_rotate_mode_t rot)
+{
+	params[7] |= (uint32_t) rot << (84 - 64);
+};
+
+void _ipu_write_param_mem(uint32_t addr, uint32_t *data, uint32_t numWords);
+
+#endif
diff --git a/drivers/mxc/ipu/ipu_prv.h b/drivers/mxc/ipu/ipu_prv.h
new file mode 100644
index 0000000..cf03f1c
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_prv.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PRV_H__
+#define __INCLUDE_IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+
+/* Globals */
+extern struct device *g_ipu_dev;
+extern spinlock_t ipu_lock;
+extern struct clk *g_ipu_clk;
+extern struct clk *g_ipu_csi_clk;
+
+int register_ipu_device(void);
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel);
+
+void _ipu_sdc_fg_init(ipu_channel_params_t *params);
+uint32_t _ipu_sdc_fg_uninit(void);
+void _ipu_sdc_bg_init(ipu_channel_params_t *params);
+uint32_t _ipu_sdc_bg_uninit(void);
+
+void _ipu_ic_enable_task(ipu_channel_t channel);
+void _ipu_ic_disable_task(ipu_channel_t channel);
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpvf(void);
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_vf(void);
+void _ipu_ic_init_csi(ipu_channel_params_t *params);
+void _ipu_ic_uninit_csi(void);
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpenc(void);
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_enc(void);
+void _ipu_ic_init_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_pp(void);
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_pp(void);
+
+int32_t _ipu_adc_init_channel(ipu_channel_t chan, display_port_t disp,
+			      mcu_mode_t cmd, int16_t x_pos, int16_t y_pos);
+int32_t _ipu_adc_uninit_channel(ipu_channel_t chan);
+
+#endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu/ipu_regs.h b/drivers/mxc/ipu/ipu_regs.h
new file mode 100644
index 0000000..73f0e9c
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_regs.h
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_regs.h
+ *
+ * @brief IPU Register definitions
+ *
+ * @ingroup IPU
+ */
+#ifndef __IPU_REGS_INCLUDED__
+#define __IPU_REGS_INCLUDED__
+
+#define IPU_REG_BASE    IO_ADDRESS(IPU_CTRL_BASE_ADDR)
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CONF                (IPU_REG_BASE + 0x0000)
+#define IPU_CHA_BUF0_RDY        (IPU_REG_BASE + 0x0004)
+#define IPU_CHA_BUF1_RDY        (IPU_REG_BASE + 0x0008)
+#define IPU_CHA_DB_MODE_SEL     (IPU_REG_BASE + 0x000C)
+#define IPU_CHA_CUR_BUF         (IPU_REG_BASE + 0x0010)
+#define IPU_FS_PROC_FLOW        (IPU_REG_BASE + 0x0014)
+#define IPU_FS_DISP_FLOW        (IPU_REG_BASE + 0x0018)
+#define IPU_TASKS_STAT          (IPU_REG_BASE + 0x001C)
+#define IPU_IMA_ADDR            (IPU_REG_BASE + 0x0020)
+#define IPU_IMA_DATA            (IPU_REG_BASE + 0x0024)
+#define IPU_INT_CTRL_1          (IPU_REG_BASE + 0x0028)
+#define IPU_INT_CTRL_2          (IPU_REG_BASE + 0x002C)
+#define IPU_INT_CTRL_3          (IPU_REG_BASE + 0x0030)
+#define IPU_INT_CTRL_4          (IPU_REG_BASE + 0x0034)
+#define IPU_INT_CTRL_5          (IPU_REG_BASE + 0x0038)
+#define IPU_INT_STAT_1          (IPU_REG_BASE + 0x003C)
+#define IPU_INT_STAT_2          (IPU_REG_BASE + 0x0040)
+#define IPU_INT_STAT_3          (IPU_REG_BASE + 0x0044)
+#define IPU_INT_STAT_4          (IPU_REG_BASE + 0x0048)
+#define IPU_INT_STAT_5          (IPU_REG_BASE + 0x004C)
+#define IPU_BRK_CTRL_1          (IPU_REG_BASE + 0x0050)
+#define IPU_BRK_CTRL_2          (IPU_REG_BASE + 0x0054)
+#define IPU_BRK_STAT            (IPU_REG_BASE + 0x0058)
+#define IPU_DIAGB_CTRL          (IPU_REG_BASE + 0x005C)
+/* CMOS Sensor Interface Registers */
+#define CSI_SENS_CONF           (IPU_REG_BASE + 0x0060)
+#define CSI_SENS_FRM_SIZE       (IPU_REG_BASE + 0x0064)
+#define CSI_ACT_FRM_SIZE        (IPU_REG_BASE + 0x0068)
+#define CSI_OUT_FRM_CTRL        (IPU_REG_BASE + 0x006C)
+#define CSI_TST_CTRL            (IPU_REG_BASE + 0x0070)
+#define CSI_CCIR_CODE_1         (IPU_REG_BASE + 0x0074)
+#define CSI_CCIR_CODE_2         (IPU_REG_BASE + 0x0078)
+#define CSI_CCIR_CODE_3         (IPU_REG_BASE + 0x007C)
+#define CSI_FLASH_STROBE_1      (IPU_REG_BASE + 0x0080)
+#define CSI_FLASH_STROBE_2      (IPU_REG_BASE + 0x0084)
+/* Image Converter Registers */
+#define IC_CONF                 (IPU_REG_BASE + 0x0088)
+#define IC_PRP_ENC_RSC          (IPU_REG_BASE + 0x008C)
+#define IC_PRP_VF_RSC           (IPU_REG_BASE + 0x0090)
+#define IC_PP_RSC               (IPU_REG_BASE + 0x0094)
+#define IC_CMBP_1               (IPU_REG_BASE + 0x0098)
+#define IC_CMBP_2               (IPU_REG_BASE + 0x009C)
+#define PF_CONF                 (IPU_REG_BASE + 0x00A0)
+#define IDMAC_CONF              (IPU_REG_BASE + 0x00A4)
+#define IDMAC_CHA_EN            (IPU_REG_BASE + 0x00A8)
+#define IDMAC_CHA_PRI           (IPU_REG_BASE + 0x00AC)
+#define IDMAC_CHA_BUSY          (IPU_REG_BASE + 0x00B0)
+/* SDC Registers */
+#define SDC_COM_CONF            (IPU_REG_BASE + 0x00B4)
+#define SDC_GW_CTRL             (IPU_REG_BASE + 0x00B8)
+#define SDC_FG_POS              (IPU_REG_BASE + 0x00BC)
+#define SDC_BG_POS              (IPU_REG_BASE + 0x00C0)
+#define SDC_CUR_POS             (IPU_REG_BASE + 0x00C4)
+#define SDC_PWM_CTRL            (IPU_REG_BASE + 0x00C8)
+#define SDC_CUR_MAP             (IPU_REG_BASE + 0x00CC)
+#define SDC_HOR_CONF            (IPU_REG_BASE + 0x00D0)
+#define SDC_VER_CONF            (IPU_REG_BASE + 0x00D4)
+#define SDC_SHARP_CONF_1        (IPU_REG_BASE + 0x00D8)
+#define SDC_SHARP_CONF_2        (IPU_REG_BASE + 0x00DC)
+/* ADC Registers */
+#define ADC_CONF                (IPU_REG_BASE + 0x00E0)
+#define ADC_SYSCHA1_SA          (IPU_REG_BASE + 0x00E4)
+#define ADC_SYSCHA2_SA          (IPU_REG_BASE + 0x00E8)
+#define ADC_PRPCHAN_SA          (IPU_REG_BASE + 0x00EC)
+#define ADC_PPCHAN_SA           (IPU_REG_BASE + 0x00F0)
+#define ADC_DISP0_CONF          (IPU_REG_BASE + 0x00F4)
+#define ADC_DISP0_RD_AP         (IPU_REG_BASE + 0x00F8)
+#define ADC_DISP0_RDM           (IPU_REG_BASE + 0x00FC)
+#define ADC_DISP0_SS            (IPU_REG_BASE + 0x0100)
+#define ADC_DISP1_CONF          (IPU_REG_BASE + 0x0104)
+#define ADC_DISP1_RD_AP         (IPU_REG_BASE + 0x0108)
+#define ADC_DISP1_RDM           (IPU_REG_BASE + 0x010C)
+#define ADC_DISP12_SS           (IPU_REG_BASE + 0x0110)
+#define ADC_DISP2_CONF          (IPU_REG_BASE + 0x0114)
+#define ADC_DISP2_RD_AP         (IPU_REG_BASE + 0x0118)
+#define ADC_DISP2_RDM           (IPU_REG_BASE + 0x011C)
+#define ADC_DISP_VSYNC          (IPU_REG_BASE + 0x0120)
+/* Display Interface re(sters */
+#define DI_DISP_IF_CONF         (IPU_REG_BASE + 0x0124)
+#define DI_DISP_SIG_POL         (IPU_REG_BASE + 0x0128)
+#define DI_SER_DISP1_CONF       (IPU_REG_BASE + 0x012C)
+#define DI_SER_DISP2_CONF       (IPU_REG_BASE + 0x0130)
+#define DI_HSP_CLK_PER          (IPU_REG_BASE + 0x0134)
+#define DI_DISP0_TIME_CONF_1    (IPU_REG_BASE + 0x0138)
+#define DI_DISP0_TIME_CONF_2    (IPU_REG_BASE + 0x013C)
+#define DI_DISP0_TIME_CONF_3    (IPU_REG_BASE + 0x0140)
+#define DI_DISP1_TIME_CONF_1    (IPU_REG_BASE + 0x0144)
+#define DI_DISP1_TIME_CONF_2    (IPU_REG_BASE + 0x0148)
+#define DI_DISP1_TIME_CONF_3    (IPU_REG_BASE + 0x014C)
+#define DI_DISP2_TIME_CONF_1    (IPU_REG_BASE + 0x0150)
+#define DI_DISP2_TIME_CONF_2    (IPU_REG_BASE + 0x0154)
+#define DI_DISP2_TIME_CONF_3    (IPU_REG_BASE + 0x0158)
+#define DI_DISP3_TIME_CONF      (IPU_REG_BASE + 0x015C)
+#define DI_DISP0_DB0_MAP        (IPU_REG_BASE + 0x0160)
+#define DI_DISP0_DB1_MAP        (IPU_REG_BASE + 0x0164)
+#define DI_DISP0_DB2_MAP        (IPU_REG_BASE + 0x0168)
+#define DI_DISP0_CB0_MAP        (IPU_REG_BASE + 0x016C)
+#define DI_DISP0_CB1_MAP        (IPU_REG_BASE + 0x0170)
+#define DI_DISP0_CB2_MAP        (IPU_REG_BASE + 0x0174)
+#define DI_DISP1_DB0_MAP        (IPU_REG_BASE + 0x0178)
+#define DI_DISP1_DB1_MAP        (IPU_REG_BASE + 0x017C)
+#define DI_DISP1_DB2_MAP        (IPU_REG_BASE + 0x0180)
+#define DI_DISP1_CB0_MAP        (IPU_REG_BASE + 0x0184)
+#define DI_DISP1_CB1_MAP        (IPU_REG_BASE + 0x0188)
+#define DI_DISP1_CB2_MAP        (IPU_REG_BASE + 0x018C)
+#define DI_DISP2_DB0_MAP        (IPU_REG_BASE + 0x0190)
+#define DI_DISP2_DB1_MAP        (IPU_REG_BASE + 0x0194)
+#define DI_DISP2_DB2_MAP        (IPU_REG_BASE + 0x0198)
+#define DI_DISP2_CB0_MAP        (IPU_REG_BASE + 0x019C)
+#define DI_DISP2_CB1_MAP        (IPU_REG_BASE + 0x01A0)
+#define DI_DISP2_CB2_MAP        (IPU_REG_BASE + 0x01A4)
+#define DI_DISP3_B0_MAP         (IPU_REG_BASE + 0x01A8)
+#define DI_DISP3_B1_MAP         (IPU_REG_BASE + 0x01AC)
+#define DI_DISP3_B2_MAP         (IPU_REG_BASE + 0x01B0)
+#define DI_DISP_ACC_CC          (IPU_REG_BASE + 0x01B4)
+#define DI_DISP_LLA_CONF        (IPU_REG_BASE + 0x01B8)
+#define DI_DISP_LLA_DATA        (IPU_REG_BASE + 0x01BC)
+
+#define IPUIRQ_2_STATREG(int)   (IPU_INT_STAT_1 + 4*(int>>5))
+#define IPUIRQ_2_CTRLREG(int)   (IPU_INT_CTRL_1 + 4*(int>>5))
+#define IPUIRQ_2_MASK(int)      (1UL << (int & 0x1F))
+
+enum {
+	IPU_CONF_CSI_EN = 0x00000001,
+	IPU_CONF_IC_EN = 0x00000002,
+	IPU_CONF_ROT_EN = 0x00000004,
+	IPU_CONF_PF_EN = 0x00000008,
+	IPU_CONF_SDC_EN = 0x00000010,
+	IPU_CONF_ADC_EN = 0x00000020,
+	IPU_CONF_DI_EN = 0x00000040,
+	IPU_CONF_DU_EN = 0x00000080,
+	IPU_CONF_PXL_ENDIAN = 0x00000100,
+
+	FS_PRPVF_ROT_SRC_SEL = 0x00000040,
+	FS_PRPENC_ROT_SRC_SEL = 0x00000020,
+	FS_PRPENC_DEST_SEL = 0x00000010,
+	FS_PP_SRC_SEL_MASK = 0x00000300,
+	FS_PP_SRC_SEL_OFFSET = 8,
+	FS_PP_ROT_SRC_SEL_MASK = 0x00000C00,
+	FS_PP_ROT_SRC_SEL_OFFSET = 10,
+	FS_PF_DEST_SEL_MASK = 0x00003000,
+	FS_PF_DEST_SEL_OFFSET = 12,
+	FS_PRPVF_DEST_SEL_MASK = 0x00070000,
+	FS_PRPVF_DEST_SEL_OFFSET = 16,
+	FS_PRPVF_ROT_DEST_SEL_MASK = 0x00700000,
+	FS_PRPVF_ROT_DEST_SEL_OFFSET = 20,
+	FS_PP_DEST_SEL_MASK = 0x07000000,
+	FS_PP_DEST_SEL_OFFSET = 24,
+	FS_PP_ROT_DEST_SEL_MASK = 0x70000000,
+	FS_PP_ROT_DEST_SEL_OFFSET = 28,
+	FS_VF_IN_VALID = 0x00000002,
+	FS_ENC_IN_VALID = 0x00000001,
+
+	FS_SDC_BG_SRC_SEL_MASK = 0x00000007,
+	FS_SDC_BG_SRC_SEL_OFFSET = 0,
+	FS_SDC_FG_SRC_SEL_MASK = 0x00000070,
+	FS_SDC_FG_SRC_SEL_OFFSET = 4,
+	FS_ADC1_SRC_SEL_MASK = 0x00000700,
+	FS_ADC1_SRC_SEL_OFFSET = 8,
+	FS_ADC2_SRC_SEL_MASK = 0x00007000,
+	FS_ADC2_SRC_SEL_OFFSET = 12,
+	FS_AUTO_REF_PER_MASK = 0x03FF0000,
+	FS_AUTO_REF_PER_OFFSET = 16,
+
+	FS_DEST_ARM = 0,
+	FS_DEST_ROT = 1,
+	FS_DEST_PP = 1,
+	FS_DEST_ADC1 = 2,
+	FS_DEST_ADC2 = 3,
+	FS_DEST_SDC_BG = 4,
+	FS_DEST_SDC_FG = 5,
+	FS_DEST_ADC = 6,
+
+	FS_SRC_ARM = 0,
+	FS_PP_SRC_PF = 1,
+	FS_PP_SRC_ROT = 2,
+
+	FS_ROT_SRC_PP = 1,
+	FS_ROT_SRC_PF = 2,
+
+	FS_PF_DEST_PP = 1,
+	FS_PF_DEST_ROT = 2,
+
+	FS_SRC_ROT_VF = 1,
+	FS_SRC_ROT_PP = 2,
+	FS_SRC_VF = 3,
+	FS_SRC_PP = 4,
+	FS_SRC_SNOOP = 5,
+	FS_SRC_AUTOREF = 6,
+	FS_SRC_AUTOREF_SNOOP = 7,
+
+	TSTAT_PF_H264_PAUSE = 0x00000001,
+	TSTAT_CSI2MEM_MASK = 0x0000000C,
+	TSTAT_CSI2MEM_OFFSET = 2,
+	TSTAT_VF_MASK = 0x00000600,
+	TSTAT_VF_OFFSET = 9,
+	TSTAT_VF_ROT_MASK = 0x000C0000,
+	TSTAT_VF_ROT_OFFSET = 18,
+	TSTAT_ENC_MASK = 0x00000180,
+	TSTAT_ENC_OFFSET = 7,
+	TSTAT_ENC_ROT_MASK = 0x00030000,
+	TSTAT_ENC_ROT_OFFSET = 16,
+	TSTAT_PP_MASK = 0x00001800,
+	TSTAT_PP_OFFSET = 11,
+	TSTAT_PP_ROT_MASK = 0x00300000,
+	TSTAT_PP_ROT_OFFSET = 20,
+	TSTAT_PF_MASK = 0x00C00000,
+	TSTAT_PF_OFFSET = 22,
+	TSTAT_ADCSYS1_MASK = 0x03000000,
+	TSTAT_ADCSYS1_OFFSET = 24,
+	TSTAT_ADCSYS2_MASK = 0x0C000000,
+	TSTAT_ADCSYS2_OFFSET = 26,
+
+	TASK_STAT_IDLE = 0,
+	TASK_STAT_ACTIVE = 1,
+	TASK_STAT_WAIT4READY = 2,
+
+	/* Register bits */
+	SDC_COM_TFT_COLOR = 0x00000001UL,
+	SDC_COM_FG_EN = 0x00000010UL,
+	SDC_COM_GWSEL = 0x00000020UL,
+	SDC_COM_GLB_A = 0x00000040UL,
+	SDC_COM_KEY_COLOR_G = 0x00000080UL,
+	SDC_COM_BG_EN = 0x00000200UL,
+	SDC_COM_SHARP = 0x00001000UL,
+
+	SDC_V_SYNC_WIDTH_L = 0x00000001UL,
+
+	ADC_CONF_PRP_EN = 0x00000001L,
+	ADC_CONF_PP_EN = 0x00000002L,
+	ADC_CONF_MCU_EN = 0x00000004L,
+
+	ADC_DISP_CONF_SL_MASK = 0x00000FFFL,
+	ADC_DISP_CONF_TYPE_MASK = 0x00003000L,
+	ADC_DISP_CONF_TYPE_XY = 0x00002000L,
+
+	ADC_DISP_VSYNC_D0_MODE_MASK = 0x00000003L,
+	ADC_DISP_VSYNC_D0_WIDTH_MASK = 0x003F0000L,
+	ADC_DISP_VSYNC_D12_MODE_MASK = 0x0000000CL,
+	ADC_DISP_VSYNC_D12_WIDTH_MASK = 0x3F000000L,
+
+	/* Image Converter Register bits */
+	IC_CONF_PRPENC_EN = 0x00000001,
+	IC_CONF_PRPENC_CSC1 = 0x00000002,
+	IC_CONF_PRPENC_ROT_EN = 0x00000004,
+	IC_CONF_PRPVF_EN = 0x00000100,
+	IC_CONF_PRPVF_CSC1 = 0x00000200,
+	IC_CONF_PRPVF_CSC2 = 0x00000400,
+	IC_CONF_PRPVF_CMB = 0x00000800,
+	IC_CONF_PRPVF_ROT_EN = 0x00001000,
+	IC_CONF_PP_EN = 0x00010000,
+	IC_CONF_PP_CSC1 = 0x00020000,
+	IC_CONF_PP_CSC2 = 0x00040000,
+	IC_CONF_PP_CMB = 0x00080000,
+	IC_CONF_PP_ROT_EN = 0x00100000,
+	IC_CONF_IC_GLB_LOC_A = 0x10000000,
+	IC_CONF_KEY_COLOR_EN = 0x20000000,
+	IC_CONF_RWS_EN = 0x40000000,
+	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
+
+	IDMA_CHAN_INVALID = 0x000000FF,
+	IDMA_IC_0 = 0x00000001,
+	IDMA_IC_1 = 0x00000002,
+	IDMA_IC_2 = 0x00000004,
+	IDMA_IC_3 = 0x00000008,
+	IDMA_IC_4 = 0x00000010,
+	IDMA_IC_5 = 0x00000020,
+	IDMA_IC_6 = 0x00000040,
+	IDMA_IC_7 = 0x00000080,
+	IDMA_IC_8 = 0x00000100,
+	IDMA_IC_9 = 0x00000200,
+	IDMA_IC_10 = 0x00000400,
+	IDMA_IC_11 = 0x00000800,
+	IDMA_IC_12 = 0x00001000,
+	IDMA_IC_13 = 0x00002000,
+	IDMA_SDC_BG = 0x00004000,
+	IDMA_SDC_FG = 0x00008000,
+	IDMA_SDC_MASK = 0x00010000,
+	IDMA_SDC_PARTIAL = 0x00020000,
+	IDMA_ADC_SYS1_WR = 0x00040000,
+	IDMA_ADC_SYS2_WR = 0x00080000,
+	IDMA_ADC_SYS1_CMD = 0x00100000,
+	IDMA_ADC_SYS2_CMD = 0x00200000,
+	IDMA_ADC_SYS1_RD = 0x00400000,
+	IDMA_ADC_SYS2_RD = 0x00800000,
+	IDMA_PF_QP = 0x01000000,
+	IDMA_PF_BSP = 0x02000000,
+	IDMA_PF_Y_IN = 0x04000000,
+	IDMA_PF_U_IN = 0x08000000,
+	IDMA_PF_V_IN = 0x10000000,
+	IDMA_PF_Y_OUT = 0x20000000,
+	IDMA_PF_U_OUT = 0x40000000,
+	IDMA_PF_V_OUT = 0x80000000,
+
+	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
+	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0x00000000L,
+	CSI_SENS_CONF_DATA_FMT_YUV422 = 0x00000200L,
+	CSI_SENS_CONF_DATA_FMT_BAYER = 0x00000300L,
+
+	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
+	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
+	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
+	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
+	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
+	CSI_SENS_CONF_SENS_CLKSRC_SHIFT = 7,
+	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 10,
+	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
+	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
+
+	PF_CONF_TYPE_MASK = 0x00000007,
+	PF_CONF_TYPE_SHIFT = 0,
+	PF_CONF_PAUSE_EN = 0x00000010,
+	PF_CONF_RESET = 0x00008000,
+	PF_CONF_PAUSE_ROW_MASK = 0x00FF0000,
+	PF_CONF_PAUSE_ROW_SHIFT = 16,
+
+	/* DI_DISP_SIG_POL bits */
+	DI_D3_VSYNC_POL_SHIFT = 28,
+	DI_D3_HSYNC_POL_SHIFT = 27,
+	DI_D3_DRDY_SHARP_POL_SHIFT = 26,
+	DI_D3_CLK_POL_SHIFT = 25,
+	DI_D3_DATA_POL_SHIFT = 24,
+
+	/* DI_DISP_IF_CONF bits */
+	DI_D3_CLK_IDLE_SHIFT = 26,
+	DI_D3_CLK_SEL_SHIFT = 25,
+	DI_D3_DATAMSK_SHIFT = 24,
+
+	DISPx_IF_CLK_DOWN_OFFSET = 22,
+	DISPx_IF_CLK_UP_OFFSET = 12,
+	DISPx_IF_CLK_PER_OFFSET = 0,
+	DISPx_IF_CLK_READ_EN_OFFSET = 16,
+	DISPx_PIX_CLK_PER_OFFSET = 0,
+
+	DI_CONF_DISP0_EN = 0x00000001L,
+	DI_CONF_DISP0_IF_MODE_OFFSET = 1,
+	DI_CONF_DISP0_BURST_MODE_OFFSET = 3,
+	DI_CONF_DISP1_EN = 0x00000100L,
+	DI_CONF_DISP1_IF_MODE_OFFSET = 9,
+	DI_CONF_DISP1_BURST_MODE_OFFSET = 12,
+	DI_CONF_DISP2_EN = 0x00010000L,
+	DI_CONF_DISP2_IF_MODE_OFFSET = 17,
+	DI_CONF_DISP2_BURST_MODE_OFFSET = 20,
+
+	DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET = 16,
+	DI_SER_DISPx_CONF_PREAMBLE_OFFSET = 8,
+	DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET = 4,
+	DI_SER_DISPx_CONF_RW_CFG_OFFSET = 1,
+	DI_SER_DISPx_CONF_BURST_MODE_EN = 0x01000000L,
+	DI_SER_DISPx_CONF_PREAMBLE_EN = 0x00000001L,
+
+	/* DI_DISP_ACC_CC */
+	DISP0_IF_CLK_CNT_D_MASK = 0x00000003L,
+	DISP0_IF_CLK_CNT_D_OFFSET = 0,
+	DISP0_IF_CLK_CNT_C_MASK = 0x0000000CL,
+	DISP0_IF_CLK_CNT_C_OFFSET = 2,
+	DISP1_IF_CLK_CNT_D_MASK = 0x00000030L,
+	DISP1_IF_CLK_CNT_D_OFFSET = 4,
+	DISP1_IF_CLK_CNT_C_MASK = 0x000000C0L,
+	DISP1_IF_CLK_CNT_C_OFFSET = 6,
+	DISP2_IF_CLK_CNT_D_MASK = 0x00000300L,
+	DISP2_IF_CLK_CNT_D_OFFSET = 8,
+	DISP2_IF_CLK_CNT_C_MASK = 0x00000C00L,
+	DISP2_IF_CLK_CNT_C_OFFSET = 10,
+	DISP3_IF_CLK_CNT_MASK = 0x00003000L,
+	DISP3_IF_CLK_CNT_OFFSET = 12,
+};
+
+#endif
diff --git a/drivers/mxc/ipu/ipu_sdc.c b/drivers/mxc/ipu/ipu_sdc.c
new file mode 100644
index 0000000..76ae992
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_sdc.c
@@ -0,0 +1,358 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_sdc.c
+ *
+ * @brief IPU SDC submodule API functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+static uint32_t g_h_start_width;
+static uint32_t g_v_start_width;
+
+static const uint32_t di_mappings[] = {
+	0x1600AAAA, 0x00E05555, 0x00070000, 3,	/* RGB888 */
+	0x0005000F, 0x000B000F, 0x0011000F, 1,	/* RGB666 */
+	0x0011000F, 0x000B000F, 0x0005000F, 1,	/* BGR666 */
+	0x0004003F, 0x000A000F, 0x000F003F, 1	/* RGB565 */
+};
+
+/*!
+ * This function is called to initialize a synchronous LCD panel.
+ *
+ * @param       panel           The type of panel.
+ *
+ * @param       pixel_clk       Desired pixel clock frequency in Hz.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer. Pixel
+ *                              format is a FOURCC ASCII code.
+ *
+ * @param       width           The width of panel in pixels.
+ *
+ * @param       height          The height of panel in pixels.
+ *
+ * @param       hStartWidth     The number of pixel clocks between the HSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       hSyncWidth      The width of the HSYNC signal in units of pixel
+ *                              clocks.
+ *
+ * @param       hEndWidth       The number of pixel clocks between the end of
+ *                              valid data and the HSYNC signal for next line.
+ *
+ * @param       vStartWidth     The number of lines between the VSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       vSyncWidth      The width of the VSYNC signal in units of lines
+ *
+ * @param       vEndWidth       The number of lines between the end of valid
+ *                              data and the VSYNC signal for next frame.
+ *
+ * @param       sig             Bitfield of signal polarities for LCD interface.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t h_start_width, uint16_t h_sync_width,
+			   uint16_t h_end_width, uint16_t v_start_width,
+			   uint16_t v_sync_width, uint16_t v_end_width,
+			   ipu_di_signal_cfg_t sig)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t old_conf;
+	uint32_t div;
+
+	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
+
+	if ((v_sync_width == 0) || (h_sync_width == 0))
+		return EINVAL;
+
+	/* Init panel size and blanking periods */
+	reg =
+	    ((uint32_t) (h_sync_width - 1) << 26) |
+	    ((uint32_t) (width + h_sync_width +
+			h_start_width + h_end_width - 1) << 16);
+	__raw_writel(reg, SDC_HOR_CONF);
+
+	reg = ((uint32_t) (v_sync_width - 1) << 26) | SDC_V_SYNC_WIDTH_L |
+	    ((uint32_t) (height + v_sync_width +
+			v_start_width + v_end_width - 1) << 16);
+	__raw_writel(reg, SDC_VER_CONF);
+
+	g_h_start_width = h_start_width + h_sync_width;
+	g_v_start_width = v_start_width + v_sync_width;
+
+	switch (panel) {
+	case IPU_PANEL_SHARP_TFT:
+		__raw_writel(0x00FD0102L, SDC_SHARP_CONF_1);
+		__raw_writel(0x00F500F4L, SDC_SHARP_CONF_2);
+		__raw_writel(SDC_COM_SHARP | SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		break;
+	case IPU_PANEL_TFT:
+		__raw_writel(SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		break;
+	default:
+		return EINVAL;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Init clocking */
+
+	/* Calculate divider */
+	/* fractional part is 4 bits so simply
+	 * multiple by 2^4 to get fractional part */
+	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
+	div = (clk_get_rate(g_ipu_clk) * 16) / pixel_clk;
+	if (div < 0x40) {	/* Divider less than 4 */
+		dev_dbg(g_ipu_dev,
+			"InitPanel() - Pixel clock divider less than 1\n");
+		div = 0x40;
+	}
+	/* DISP3_IF_CLK_DOWN_WR is half the divider
+	 * value and 2 less fraction bits */
+	/* Subtract 1 extra from DISP3_IF_CLK_DOWN_WR
+	 * based on timing debug     */
+	/* DISP3_IF_CLK_UP_WR is 0 */
+	__raw_writel((((div / 8) - 1) << 22) | div, DI_DISP3_TIME_CONF);
+
+	/* DI settings */
+	old_conf = __raw_readl(DI_DISP_IF_CONF) & 0x78FFFFFF;
+	old_conf |= sig.datamask_en << DI_D3_DATAMSK_SHIFT |
+	    sig.clksel_en << DI_D3_CLK_SEL_SHIFT |
+	    sig.clkidle_en << DI_D3_CLK_IDLE_SHIFT;
+	__raw_writel(old_conf, DI_DISP_IF_CONF);
+
+	old_conf = __raw_readl(DI_DISP_SIG_POL) & 0xE0FFFFFF;
+	old_conf |= sig.data_pol << DI_D3_DATA_POL_SHIFT |
+	    sig.clk_pol << DI_D3_CLK_POL_SHIFT |
+	    sig.enable_pol << DI_D3_DRDY_SHARP_POL_SHIFT |
+	    sig.Hsync_pol << DI_D3_HSYNC_POL_SHIFT |
+	    sig.Vsync_pol << DI_D3_VSYNC_POL_SHIFT;
+	__raw_writel(old_conf, DI_DISP_SIG_POL);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_RGB24:
+		__raw_writel(di_mappings[0], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[1], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[2], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[3] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	case IPU_PIX_FMT_RGB666:
+		__raw_writel(di_mappings[4], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[5], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[6], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[7] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	case IPU_PIX_FMT_BGR666:
+		__raw_writel(di_mappings[8], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[9], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[10], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[11] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	default:
+		__raw_writel(di_mappings[12], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[13], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[14], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[15] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	dev_dbg(g_ipu_dev, "DI_DISP_IF_CONF = 0x%08X\n",
+		__raw_readl(DI_DISP_IF_CONF));
+	dev_dbg(g_ipu_dev, "DI_DISP_SIG_POL = 0x%08X\n",
+		__raw_readl(DI_DISP_SIG_POL));
+	dev_dbg(g_ipu_dev, "DI_DISP3_TIME_CONF = 0x%08X\n",
+		__raw_readl(DI_DISP3_TIME_CONF));
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_init_panel);
+
+/*!
+ * This function sets the foreground and background
+ * plane global alpha blending
+ * modes.
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *		blending. If disabled, per pixel blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(SDC_GW_CTRL) & 0x00FFFFFFL;
+		__raw_writel(reg | ((uint32_t) alpha << 24), SDC_GW_CTRL);
+
+		reg = __raw_readl(SDC_COM_CONF);
+		__raw_writel(reg | SDC_COM_GLB_A, SDC_COM_CONF);
+	} else {
+		reg = __raw_readl(SDC_COM_CONF);
+		__raw_writel(reg & ~SDC_COM_GLB_A, SDC_COM_CONF);
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_global_alpha);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color to use as transparent color key.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t color_key)
+{
+	uint32_t reg, sdc_conf;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	sdc_conf = __raw_readl(SDC_COM_CONF);
+	if (channel == MEM_SDC_BG)
+		sdc_conf &= ~SDC_COM_GWSEL;
+	else
+		sdc_conf |= SDC_COM_GWSEL;
+
+	if (enable) {
+		reg = __raw_readl(SDC_GW_CTRL) & 0xFF000000L;
+		__raw_writel(reg | (color_key & 0x00FFFFFFL), SDC_GW_CTRL);
+
+		sdc_conf |= SDC_COM_KEY_COLOR_G;
+	} else
+		sdc_conf &= ~SDC_COM_KEY_COLOR_G;
+	__raw_writel(sdc_conf, SDC_COM_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_color_key);
+
+int32_t ipu_sdc_set_brightness(uint8_t value)
+{
+	__raw_writel(0x03000000UL | value << 16, SDC_PWM_CTRL);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_brightness);
+
+/*!
+ * This function sets the window position of the foreground or background plane.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       x_pos           The X coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @param       y_pos           The Y coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+			       int16_t y_pos)
+{
+	x_pos += g_h_start_width;
+	y_pos += g_v_start_width;
+
+	if (channel == MEM_SDC_BG)
+		__raw_writel((x_pos << 16) | y_pos, SDC_BG_POS);
+	else if (channel == MEM_SDC_FG)
+		__raw_writel((x_pos << 16) | y_pos, SDC_FG_POS);
+	else
+		return EINVAL;
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_window_pos);
+
+void _ipu_sdc_fg_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	(void)params;
+
+	/* Enable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg | SDC_COM_FG_EN | SDC_COM_BG_EN, SDC_COM_CONF);
+}
+
+uint32_t _ipu_sdc_fg_uninit(void)
+{
+	uint32_t reg;
+
+	/* Disable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg & ~SDC_COM_FG_EN, SDC_COM_CONF);
+
+	return reg & SDC_COM_FG_EN;
+}
+
+void _ipu_sdc_bg_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	(void)params;
+
+	/* Enable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg | SDC_COM_BG_EN, SDC_COM_CONF);
+}
+
+uint32_t _ipu_sdc_bg_uninit(void)
+{
+	uint32_t reg;
+
+	/* Disable BG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg & ~SDC_COM_BG_EN, SDC_COM_CONF);
+
+	return reg & SDC_COM_BG_EN;
+}
diff --git a/drivers/mxc/ipu/pf/Kconfig b/drivers/mxc/ipu/pf/Kconfig
new file mode 100644
index 0000000..9d045eb
--- /dev/null
+++ b/drivers/mxc/ipu/pf/Kconfig
@@ -0,0 +1,7 @@
+config MXC_IPU_PF
+	tristate "MXC MPEG4/H.264 Post Filter Driver"
+	depends on (MXC_IPU && MXC_IPU_V1)
+    default y
+	help
+        Driver for MPEG4 dering and deblock and H.264 deblock
+        using MXC IPU h/w
diff --git a/drivers/mxc/ipu/pf/Makefile b/drivers/mxc/ipu/pf/Makefile
new file mode 100644
index 0000000..3fdccc4
--- /dev/null
+++ b/drivers/mxc/ipu/pf/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MXC_IPU_PF) += mxc_pf.o
+
diff --git a/drivers/mxc/ipu/pf/mxc_pf.c b/drivers/mxc/ipu/pf/mxc_pf.c
new file mode 100644
index 0000000..a7a334a
--- /dev/null
+++ b/drivers/mxc/ipu/pf/mxc_pf.c
@@ -0,0 +1,980 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_pf.c
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+
+#include <linux/pagemap.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/ipu.h>
+#include <mach/mxc_pf.h>
+
+
+struct mxc_pf_data {
+	pf_operation_t mode;
+	u32 pf_enabled;
+	u32 width;
+	u32 height;
+	u32 stride;
+	uint32_t qp_size;
+	dma_addr_t qp_paddr;
+	void *qp_vaddr;
+	pf_buf buf[PF_MAX_BUFFER_CNT];
+	void *buf_vaddr[PF_MAX_BUFFER_CNT];
+	wait_queue_head_t pf_wait;
+	volatile int done_mask;
+	volatile int wait_mask;
+	volatile int busy_flag;
+	struct semaphore busy_lock;
+};
+
+static struct mxc_pf_data pf_data;
+static u8 open_count;
+static struct class *mxc_pf_class;
+
+/*
+ * Function definitions
+ */
+
+static irqreturn_t mxc_pf_irq_handler(int irq, void *dev_id)
+{
+	struct mxc_pf_data *pf = dev_id;
+
+	if (irq == IPU_IRQ_PF_Y_OUT_EOF)
+		pf->done_mask |= PF_WAIT_Y;
+	else if (irq == IPU_IRQ_PF_U_OUT_EOF)
+		pf->done_mask |= PF_WAIT_U;
+	else if (irq == IPU_IRQ_PF_V_OUT_EOF)
+		pf->done_mask |= PF_WAIT_V;
+	else
+		return IRQ_NONE;
+
+	if (pf->wait_mask && ((pf->done_mask & pf->wait_mask) == pf->wait_mask))
+		wake_up_interruptible(&pf->pf_wait);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function handles PF_IOCTL_INIT calls. It initializes the PF channels,
+ * interrupt handlers, and channel buffers.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_init(pf_init_params *pf_init)
+{
+	int err;
+	ipu_channel_params_t params;
+	u32 w;
+	u32 stride;
+	u32 h;
+	u32 qp_size = 0;
+	u32 qp_stride;
+
+	if ((pf_init->pf_mode > 4) || (pf_init->width > 1024) ||
+		(pf_init->height > 1024) || (pf_init->stride < pf_init->width))
+		return -EINVAL;
+
+	pf_data.mode = pf_init->pf_mode;
+	w = pf_data.width = pf_init->width;
+	h = pf_data.height = pf_init->height;
+	stride = pf_data.stride = pf_init->stride;
+	pf_data.qp_size = pf_init->qp_size;
+
+	memset(&params, 0, sizeof(params));
+	params.mem_pf_mem.operation = pf_data.mode;
+	err = ipu_init_channel(MEM_PF_Y_MEM, &params);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing channel\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_Y_MEM, IPU_INPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing Y input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_Y_MEM, IPU_OUTPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing Y output buffer\n");
+		goto err0;
+	}
+
+	w = w / 2;
+	h = h / 2;
+	stride = stride / 2;
+
+	if (pf_data.mode != PF_MPEG4_DERING) {
+		err = ipu_init_channel_buffer(MEM_PF_U_MEM, IPU_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h, stride,
+					      IPU_ROTATE_NONE, 0, 0, 0, 0);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error initializing U input buffer\n");
+			goto err0;
+		}
+
+		err = ipu_init_channel_buffer(MEM_PF_U_MEM, IPU_OUTPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h, stride,
+					      IPU_ROTATE_NONE, 0, 0, 0, 0);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error initializing U output buffer\n");
+			goto err0;
+		}
+
+		err = ipu_init_channel_buffer(MEM_PF_V_MEM, IPU_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h, stride,
+					      IPU_ROTATE_NONE, 0, 0, 0, 0);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error initializing V input buffer\n");
+			goto err0;
+		}
+
+		err = ipu_init_channel_buffer(MEM_PF_V_MEM, IPU_OUTPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h, stride,
+					      IPU_ROTATE_NONE, 0, 0, 0, 0);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error initializing V output buffer\n");
+			goto err0;
+		}
+	}
+	/*Setup Channel QF and BSC Params */
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+		w = ((pf_data.width + 15) / 16);
+		h = (pf_data.height + 15) / 16;
+		qp_stride = w;
+		qp_size = 4 * qp_stride * h;
+		pr_debug("H264 QP width = %d, height = %d\n", w, h);
+		err = ipu_init_channel_buffer(MEM_PF_Y_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC_32, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing H264 QP buffer\n");
+			goto err0;
+		}
+		w *= 4;
+		h *= 4;
+		qp_stride = w;
+		err = ipu_init_channel_buffer(MEM_PF_U_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing H264 BSB buffer\n");
+			goto err0;
+		}
+		qp_size += qp_stride * h;
+	} else {		/* MPEG4 mode */
+
+		w = (pf_data.width + 15) / 16;
+		h = (pf_data.height + 15) / 16;
+		qp_stride = (w + 3) & ~0x3UL;
+		pr_debug("MPEG4 QP width = %d, height = %d, stride = %d\n",
+			 w, h, qp_stride);
+		err = ipu_init_channel_buffer(MEM_PF_Y_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing MPEG4 QP buffer\n");
+			goto err0;
+		}
+		qp_size = qp_stride * h;
+	}
+
+	qp_size *= 2;
+
+	if (pf_data.qp_size > qp_size)
+		qp_size = pf_data.qp_size;
+	else
+		pf_data.qp_size = qp_size;
+
+	pf_data.qp_vaddr = dma_alloc_coherent(NULL, pf_data.qp_size,
+					      &pf_data.qp_paddr,
+					      GFP_KERNEL | GFP_DMA);
+	if (!pf_data.qp_vaddr)
+		return -ENOMEM;
+
+	pf_init->qp_paddr = pf_data.qp_paddr;
+	pf_init->qp_size = pf_data.qp_size;
+
+	return 0;
+
+err0:
+	return err;
+}
+
+/*!
+ * This function handles PF_IOCTL_UNINIT calls. It uninitializes the PF
+ * channels and interrupt handlers.
+ *
+ * @return      This function returns 0 on success or negative error code
+ *              on error.
+ */
+static int mxc_pf_uninit(void)
+{
+	pf_data.pf_enabled = 0;
+	ipu_disable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+	ipu_disable_irq(IPU_IRQ_PF_U_OUT_EOF);
+	ipu_disable_irq(IPU_IRQ_PF_V_OUT_EOF);
+
+	ipu_disable_channel(MEM_PF_Y_MEM, true);
+	ipu_disable_channel(MEM_PF_U_MEM, true);
+	ipu_disable_channel(MEM_PF_V_MEM, true);
+	ipu_uninit_channel(MEM_PF_Y_MEM);
+	ipu_uninit_channel(MEM_PF_U_MEM);
+	ipu_uninit_channel(MEM_PF_V_MEM);
+
+	if (pf_data.qp_vaddr) {
+		dma_free_coherent(NULL, pf_data.qp_size, pf_data.qp_vaddr,
+				  pf_data.qp_paddr);
+		pf_data.qp_vaddr = NULL;
+	}
+
+	return 0;
+}
+
+/*!
+ * This function handles PF_IOCTL_REQBUFS calls. It initializes the PF channels
+ * and channel buffers.
+ *
+ * @param       reqbufs         Input/Output Structure containing buffer mode,
+ *                              type, offset, and size. The offset and size of
+ *                              the buffer are returned for PF_MEMORY_MMAP mode.
+ *
+ * @return      This function returns 0 on success or negative error code
+ *              on error.
+ */
+static int mxc_pf_reqbufs(pf_reqbufs_params *reqbufs)
+{
+	int err;
+	uint32_t buf_size;
+	int i;
+	int alloc_cnt = 0;
+	pf_buf *buf = pf_data.buf;
+	if (reqbufs->count > PF_MAX_BUFFER_CNT)
+		reqbufs->count = PF_MAX_BUFFER_CNT;
+
+	/* Deallocate mmapped buffers */
+	if (reqbufs->count == 0) {
+		for (i = 0; i < PF_MAX_BUFFER_CNT; i++) {
+			if (buf[i].index != -1) {
+				dma_free_coherent(NULL, buf[i].size,
+						  pf_data.buf_vaddr[i],
+						  buf[i].offset);
+				pf_data.buf_vaddr[i] = NULL;
+				buf[i].index = -1;
+				buf[i].size = 0;
+			}
+		}
+		return 0;
+	}
+
+	buf_size = (pf_data.stride * pf_data.height * 3) / 2;
+	if (reqbufs->req_size > buf_size) {
+		buf_size = reqbufs->req_size;
+		pr_debug("using requested buffer size of %d\n", buf_size);
+	} else {
+		reqbufs->req_size = buf_size;
+		pr_debug("using default buffer size of %d\n", buf_size);
+	}
+
+	for (i = 0; alloc_cnt < reqbufs->count; i++) {
+		buf[i].index = i;
+		buf[i].size = buf_size;
+		pf_data.buf_vaddr[i] = dma_alloc_coherent(NULL, buf[i].size,
+							  &buf[i].offset,
+							  GFP_KERNEL | GFP_DMA);
+		if (!pf_data.buf_vaddr[i] || !buf[i].offset) {
+			printk(KERN_ERR
+			       "mxc_pf: unable to allocate IPU buffers.\n");
+			err = -ENOMEM;
+			goto err0;
+		}
+		pr_debug("Allocated buffer %d at paddr 0x%08X, vaddr %p\n",
+			 i, buf[i].offset, pf_data.buf_vaddr[i]);
+
+		alloc_cnt++;
+	}
+
+	return 0;
+err0:
+	for (i = 0; i < alloc_cnt; i++) {
+		dma_free_coherent(NULL, buf[i].size, pf_data.buf_vaddr[i],
+				  buf[i].offset);
+		pf_data.buf_vaddr[i] = NULL;
+		buf[i].index = -1;
+		buf[i].size = 0;
+	}
+	return err;
+}
+
+/*!
+ * This function handles PF_IOCTL_START calls. It sets the PF channel buffers
+ * addresses and starts the channels
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_start(pf_buf *in, pf_buf *out, int qp_buf)
+{
+	int err;
+	dma_addr_t y_in_paddr;
+	dma_addr_t u_in_paddr;
+	dma_addr_t v_in_paddr;
+	dma_addr_t p1_in_paddr;
+	dma_addr_t p2_in_paddr;
+	dma_addr_t y_out_paddr;
+	dma_addr_t u_out_paddr;
+	dma_addr_t v_out_paddr;
+
+	/* H.264 requires output buffer equal to input */
+	if (pf_data.mode == PF_H264_DEBLOCK)
+		out = in;
+
+	y_in_paddr = in->offset + in->y_offset;
+	if (in->u_offset)
+		u_in_paddr = in->offset + in->u_offset;
+	else
+		u_in_paddr = y_in_paddr + (pf_data.stride * pf_data.height);
+	if (in->v_offset)
+		v_in_paddr = in->offset + in->v_offset;
+	else
+		v_in_paddr = u_in_paddr + (pf_data.stride * pf_data.height) / 4;
+	p1_in_paddr = pf_data.qp_paddr;
+
+	if (qp_buf)
+		p1_in_paddr += pf_data.qp_size / 2;
+
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+		p2_in_paddr = p1_in_paddr +
+		    ((pf_data.width + 15) / 16) *
+		    ((pf_data.height + 15) / 16) * 4;
+	} else
+		p2_in_paddr = 0;
+
+	pr_debug("y_in_paddr = 0x%08X\nu_in_paddr = 0x%08X\n"
+		 "v_in_paddr = 0x%08X\n"
+		 "qp_paddr = 0x%08X\nbsb_paddr = 0x%08X\n",
+		 y_in_paddr, u_in_paddr, v_in_paddr, p1_in_paddr, p2_in_paddr);
+
+	y_out_paddr = out->offset + out->y_offset;
+	if (out->u_offset)
+		u_out_paddr = out->offset + out->u_offset;
+	else
+		u_out_paddr = y_out_paddr + (pf_data.stride * pf_data.height);
+	if (out->v_offset)
+		v_out_paddr = out->offset + out->v_offset;
+	else
+		v_out_paddr =
+		    u_out_paddr + (pf_data.stride * pf_data.height) / 4;
+
+	pr_debug("y_out_paddr = 0x%08X\nu_out_paddr = 0x%08X\n"
+		 "v_out_paddr = 0x%08X\n",
+		 y_out_paddr, u_out_paddr, v_out_paddr);
+
+	pf_data.done_mask = 0;
+
+	ipu_enable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+	if (pf_data.mode != PF_MPEG4_DERING) {
+		ipu_enable_irq(IPU_IRQ_PF_U_OUT_EOF);
+		ipu_enable_irq(IPU_IRQ_PF_V_OUT_EOF);
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM,
+			IPU_INPUT_BUFFER, 0,
+			y_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting Y input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM,
+			IPU_OUTPUT_BUFFER, 0,
+			y_out_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting Y output buffer\n");
+		goto err0;
+	}
+
+	if (pf_data.mode != PF_MPEG4_DERING) {
+		err = ipu_update_channel_buffer(MEM_PF_U_MEM,
+				IPU_INPUT_BUFFER, 0,
+				u_in_paddr);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error setting U input buffer\n");
+			goto err0;
+		}
+
+		err = ipu_update_channel_buffer(MEM_PF_U_MEM,
+				IPU_OUTPUT_BUFFER, 0,
+				u_out_paddr);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error setting U output buffer\n");
+			goto err0;
+		}
+
+		err = ipu_update_channel_buffer(MEM_PF_V_MEM,
+				IPU_INPUT_BUFFER, 0,
+				v_in_paddr);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error setting V input buffer\n");
+			goto err0;
+		}
+
+		err = ipu_update_channel_buffer(MEM_PF_V_MEM,
+				IPU_OUTPUT_BUFFER, 0,
+				v_out_paddr);
+		if (err < 0) {
+			printk(KERN_ERR "mxc_pf: error setting V output buffer\n");
+			goto err0;
+		}
+	}
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM,
+			IPU_SEC_INPUT_BUFFER, 0,
+			p1_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting QP buffer\n");
+		goto err0;
+	}
+
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+
+		err = ipu_update_channel_buffer(MEM_PF_U_MEM,
+						IPU_SEC_INPUT_BUFFER, 0,
+						p2_in_paddr);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error setting H264 BSB buffer\n");
+			goto err0;
+		}
+		ipu_select_buffer(MEM_PF_U_MEM, IPU_SEC_INPUT_BUFFER, 0);
+	}
+
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_OUTPUT_BUFFER, 0);
+	if (pf_data.mode != PF_MPEG4_DERING) {
+		ipu_select_buffer(MEM_PF_U_MEM, IPU_OUTPUT_BUFFER, 0);
+		ipu_select_buffer(MEM_PF_V_MEM, IPU_OUTPUT_BUFFER, 0);
+		ipu_select_buffer(MEM_PF_U_MEM, IPU_INPUT_BUFFER, 0);
+		ipu_select_buffer(MEM_PF_V_MEM, IPU_INPUT_BUFFER, 0);
+	}
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_SEC_INPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_INPUT_BUFFER, 0);
+
+	if (!pf_data.pf_enabled) {
+		pf_data.pf_enabled = 1;
+		if (pf_data.mode != PF_MPEG4_DERING) {
+			ipu_enable_channel(MEM_PF_V_MEM);
+			ipu_enable_channel(MEM_PF_U_MEM);
+		}
+		ipu_enable_channel(MEM_PF_Y_MEM);
+	}
+
+	return 0;
+err0:
+	return err;
+}
+
+/*!
+ * Post Filter driver open function. This function implements the Linux
+ * file_operations.open() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_open(struct inode *inode, struct file *filp)
+{
+	int i;
+
+	if (open_count++ == 0) {
+		memset(&pf_data, 0, sizeof(pf_data));
+		for (i = 0; i < PF_MAX_BUFFER_CNT; i++)
+			pf_data.buf[i].index = -1;
+
+		init_waitqueue_head(&pf_data.pf_wait);
+		init_MUTEX(&pf_data.busy_lock);
+
+		pf_data.busy_flag = 1;
+
+		ipu_request_irq(IPU_IRQ_PF_Y_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_request_irq(IPU_IRQ_PF_U_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_request_irq(IPU_IRQ_PF_V_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_disable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+		ipu_disable_irq(IPU_IRQ_PF_U_OUT_EOF);
+		ipu_disable_irq(IPU_IRQ_PF_V_OUT_EOF);
+	}
+	return 0;
+}
+
+/*!
+ * Post Filter driver release function. This function implements the Linux
+ * file_operations.release() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_release(struct inode *inode, struct file *filp)
+{
+	pf_reqbufs_params req_buf;
+
+	if (--open_count == 0) {
+		mxc_pf_uninit();
+
+		/* Free any allocated buffers */
+		req_buf.count = 0;
+		mxc_pf_reqbufs(&req_buf);
+
+		ipu_free_irq(IPU_IRQ_PF_V_OUT_EOF, &pf_data);
+		ipu_free_irq(IPU_IRQ_PF_U_OUT_EOF, &pf_data);
+		ipu_free_irq(IPU_IRQ_PF_Y_OUT_EOF, &pf_data);
+
+	}
+	return 0;
+}
+
+/*!
+ * Post Filter driver ioctl function. This function implements the Linux
+ * file_operations.ioctl() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @param       cmd             IOCTL command to handle
+ *
+ * @param       arg             Pointer to arguments for IOCTL
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	switch (cmd) {
+	case PF_IOCTL_INIT:
+		{
+			pf_init_params pf_init;
+
+			pr_debug("PF_IOCTL_INIT\n");
+			if (copy_from_user(&pf_init, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			retval = mxc_pf_init(&pf_init);
+			if (retval < 0)
+				break;
+			pf_init.qp_paddr = pf_data.qp_paddr;
+			pf_init.qp_size = pf_data.qp_size;
+
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &pf_init,
+						_IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			pf_data.busy_flag = 0;
+			break;
+		}
+	case PF_IOCTL_UNINIT:
+		pr_debug("PF_IOCTL_UNINIT\n");
+		retval = mxc_pf_uninit();
+		break;
+	case PF_IOCTL_REQBUFS:
+		{
+			pf_reqbufs_params reqbufs;
+			pr_debug("PF_IOCTL_REQBUFS\n");
+
+			if (copy_from_user
+			    (&reqbufs, (void *)arg, _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			retval = mxc_pf_reqbufs(&reqbufs);
+
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &reqbufs,
+						_IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			break;
+		}
+	case PF_IOCTL_QUERYBUF:
+		{
+			pf_buf buf;
+			pr_debug("PF_IOCTL_QUERYBUF\n");
+
+			if (copy_from_user(&buf, (void *)arg, _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if ((buf.index < 0) ||
+			    (buf.index >= PF_MAX_BUFFER_CNT) ||
+			    (pf_data.buf[buf.index].index != buf.index)) {
+				retval = -EINVAL;
+				break;
+			}
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &pf_data.buf[buf.index],
+					 _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			break;
+		}
+	case PF_IOCTL_START:
+		{
+			int index;
+			pf_start_params start_params;
+			pr_debug("PF_IOCTL_START\n");
+
+			if (pf_data.busy_flag) {
+				retval = -EBUSY;
+				break;
+			}
+
+			if (copy_from_user(&start_params, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (start_params.h264_pause_row >=
+			    ((pf_data.height + 15) / 16)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			pf_data.busy_flag = 1;
+
+			index = start_params.in.index;
+			if ((index >= 0) && (index < PF_MAX_BUFFER_CNT)) {
+				if (pf_data.buf[index].offset !=
+				    start_params.in.offset) {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			index = start_params.out.index;
+			if ((index >= 0) && (index < PF_MAX_BUFFER_CNT)) {
+				if (pf_data.buf[index].offset !=
+				    start_params.out.offset) {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			ipu_pf_set_pause_row(start_params.h264_pause_row);
+
+			/*Update y, u, v buffers in DMA Channels */
+			retval = mxc_pf_start(&start_params.in,
+					&start_params.out, start_params.qp_buf);
+			if (retval < 0)
+				break;
+
+			pr_debug("PF_IOCTL_START - processing started\n");
+
+			if (!start_params.wait)
+				break;
+
+			pr_debug("PF_IOCTL_START - waiting for completion\n");
+
+			pf_data.wait_mask = PF_WAIT_ALL;
+
+			/* Fall thru to wait */
+		}
+	case PF_IOCTL_WAIT:
+		{
+
+			if (!pf_data.wait_mask)
+				pf_data.wait_mask = (u32) arg;
+
+			if (pf_data.mode == PF_MPEG4_DERING)
+				pf_data.wait_mask &= PF_WAIT_Y;
+
+			if (!pf_data.wait_mask) {
+				retval = -EINVAL;
+				break;
+			}
+
+			if (!wait_event_interruptible_timeout(pf_data.pf_wait,
+						      ((pf_data.done_mask &
+							pf_data.wait_mask)
+							== pf_data.wait_mask),
+								1 * HZ)) {
+				pr_debug
+				    ("PF_IOCTL_WAIT: timeout, done_mask = %d\n",
+				     pf_data.done_mask);
+				retval = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				pr_debug("PF_IOCTL_WAIT: interrupt received\n");
+				retval = -ERESTARTSYS;
+				break;
+			}
+			pf_data.busy_flag = 0;
+			pf_data.wait_mask = 0;
+
+			pr_debug("PF_IOCTL_WAIT - finished\n");
+			break;
+		}
+	case PF_IOCTL_RESUME:
+		{
+			int pause_row;
+			pr_debug("PF_IOCTL_RESUME\n");
+
+			if (pf_data.busy_flag == 0) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if (copy_from_user(&pause_row, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if (pause_row >= ((pf_data.height + 15) / 16)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			ipu_pf_set_pause_row(pause_row);
+			break;
+		}
+
+	default:
+		printk(KERN_ERR "ipu_pf_ioctl not supported ioctl\n");
+		retval = -1;
+	}
+
+	if (retval < 0)
+		pr_debug("return = %d\n", retval);
+	return retval;
+}
+
+/*!
+ * Post Filter driver mmap function. This function implements the Linux
+ * file_operations.mmap() API function for mapping driver buffers to user space.
+ *
+ * @param       file            struct file *
+ *
+ * @param       vma             structure vm_area_struct *
+ *
+ * @return      0 Success, EINTR busy lock error,
+ *                      ENOBUFS remap_page error.
+ */
+static int mxc_pf_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long size = vma->vm_end - vma->vm_start;
+	int res = 0;
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",
+		 vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&pf_data.busy_lock))
+		return -EINTR;
+
+	/* make buffers write-thru cacheable */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) &
+				     ~L_PTE_BUFFERABLE);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    vma->vm_pgoff, size, vma->vm_page_prot)) {
+		printk(KERN_ERR "mxc_pf: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto mmap_exit;
+	}
+
+	vma->vm_flags &= ~VM_IO;	/* using shared anonymous pages */
+
+mmap_exit:
+	up(&pf_data.busy_lock);
+	return res;
+}
+
+extern void v6_flush_kern_cache_all_l2(void);
+
+/*!
+ * Post Filter driver fsync function. This function implements the Linux
+ * file_operations.fsync() API function.
+ *
+ * The user must call fsync() before reading an output buffer. This
+ * call flushes the L1 and L2 caches
+ *
+ * @param filp          structure file *
+ *
+ * @param dentry        struct dentry *
+ *
+ * @param datasync      unused
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+int mxc_pf_fsync(struct file *filp, struct dentry *dentry, int datasync)
+{
+	flush_cache_all();
+	return 0;
+}
+
+/*!
+ * Post Filter driver poll function. This function implements the Linux
+ * file_operations.poll() API function.
+ *
+ * @param file       structure file *
+ *
+ * @param wait       structure poll_table *
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+static unsigned int mxc_pf_poll(struct file *file, poll_table *wait)
+{
+	wait_queue_head_t *queue = NULL;
+	int res = POLLIN | POLLRDNORM;
+
+	if (down_interruptible(&pf_data.busy_lock))
+		return -EINTR;
+
+	queue = &pf_data.pf_wait;
+	poll_wait(file, queue, wait);
+
+	up(&pf_data.busy_lock);
+
+	return res;
+}
+
+/*!
+ * File operation structure functions pointers.
+ */
+static struct file_operations mxc_pf_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_pf_open,
+	.release = mxc_pf_release,
+	.ioctl = mxc_pf_ioctl,
+	.poll = mxc_pf_poll,
+	.mmap = mxc_pf_mmap,
+	.fsync = mxc_pf_fsync,
+};
+
+static int mxc_pf_major;
+
+/*!
+ * Post Filter driver module initialization function.
+ */
+int mxc_pf_dev_init(void)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	mxc_pf_major = register_chrdev(0, "mxc_ipu_pf", &mxc_pf_fops);
+
+	if (mxc_pf_major < 0) {
+		printk(KERN_INFO "Unable to get a major for mxc_ipu_pf");
+		return mxc_pf_major;
+	}
+
+	mxc_pf_class = class_create(THIS_MODULE, "mxc_ipu_pf");
+	if (IS_ERR(mxc_pf_class)) {
+		printk(KERN_ERR "Error creating mxc_ipu_pf class.\n");
+		ret = PTR_ERR(mxc_pf_class);
+		goto err_out1;
+	}
+
+	temp_class = device_create(mxc_pf_class, NULL,
+					 MKDEV(mxc_pf_major, 0), NULL,
+					 "mxc_ipu_pf");
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating mxc_ipu_pf class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	printk(KERN_INFO "IPU Post-filter loading\n");
+
+	return 0;
+
+err_out2:
+	class_destroy(mxc_pf_class);
+err_out1:
+	unregister_chrdev(mxc_pf_major, "mxc_ipu_pf");
+	return ret;
+}
+
+/*!
+ * Post Filter driver module exit function.
+ */
+static void mxc_pf_exit(void)
+{
+	if (mxc_pf_major > 0) {
+		device_destroy(mxc_pf_class, MKDEV(mxc_pf_major, 0));
+		class_destroy(mxc_pf_class);
+		unregister_chrdev(mxc_pf_major, "mxc_ipu_pf");
+	}
+}
+
+module_init(mxc_pf_dev_init);
+module_exit(mxc_pf_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC MPEG4/H.264 Postfilter Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/ipu/snoop.c b/drivers/mxc/ipu/snoop.c
new file mode 100644
index 0000000..068b142
--- /dev/null
+++ b/drivers/mxc/ipu/snoop.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+
+#include "snoop.h"
+
+#ifdef M4IF_BASE_ADDR
+#define SNOOP_V2
+#define MAX_SNOOP	2
+#define g_snoop_base	(IO_ADDRESS(M4IF_BASE_ADDR) + 0x4C)
+#elif defined(M3IF_BASE_ADDR)
+#define MAX_SNOOP	1
+#define g_snoop_base	(IO_ADDRESS(M3IF_BASE_ADDR) + 0x28)
+#else
+#define MAX_SNOOP	0
+#define g_snoop_base	0
+#endif
+
+/* M3IF Snooping Configuration Register 0 (M3IFSCFG0) READ/WRITE*/
+#define SBAR(x)		(x * 0x14)
+/* M3IF Snooping Configuration Register 1 (M3IFSCFG1) READ/WRITE*/
+#define SERL(x)		((x * 0x14) + 0x4)
+/* M3IF Snooping Configuration Register 2 (M3IFSCFG2) READ/WRITE*/
+#define SERH(x)		((x * 0x14) + 0x8)
+/* M3IF Snooping Status Register 0 (M3IFSSR0) READ/WRITE */
+#define SSRL(x)		((x * 0x14) + 0xC)
+/* M3IF Snooping Status Register 1 (M3IFSSR1) */
+#define SSRH(x)		((x * 0x14) + 0x10)
+
+#if MAX_SNOOP
+
+int mxc_snoop_set_config(u32 num, unsigned long base, int size)
+{
+	u32 reg;
+	uint32_t msb;
+	uint32_t seg_size;
+	uint32_t window_size = 0;
+	int i;
+
+	if (num >= MAX_SNOOP)
+		return -EINVAL;
+
+	/* Setup M3IF for snooping */
+	if (size) {
+
+		if (base == 0)
+			return -EINVAL;
+
+		msb = fls(size);
+		if (!(size & ((1UL << msb) - 1)))
+			msb--;	/* Already aligned to power 2 */
+		if (msb < 11)
+			msb = 11;
+
+		window_size = (1UL << msb);
+		seg_size = window_size / 64;
+
+		msb -= 11;
+
+		reg = base & ~((1UL << msb) - 1);
+		reg |= msb << 1;
+		reg |= 1;	/* enable snooping */
+		reg |= 0x80;	/* Set pulse width to default (M4IF only) */
+		__raw_writel(reg, g_snoop_base + SBAR(num));
+
+		reg = 0;
+		for (i = 0; i < 32; i++) {
+			if (i * seg_size >= size)
+				break;
+			reg |= 1UL << i;
+		}
+		__raw_writel(reg, g_snoop_base + SERL(num));
+
+		reg = 0;
+		for (i = 32; i < 64; i++) {
+			if (i * seg_size >= size)
+				break;
+			reg |= 1UL << (i - 32);
+		}
+		__raw_writel(reg, g_snoop_base + SERH(num));
+
+		pr_debug
+			("Snooping unit # %d enabled:"
+			 "window size = 0x%X,"
+			 "M3IFSCFG0=0x%08X, M3IFSCFG1=0x%08X,"
+			 "M3IFSCFG2=0x%08X\n",
+			 num, window_size, __raw_readl(g_snoop_base + SBAR(num)),
+			 __raw_readl(g_snoop_base + SERL(num)),
+			 __raw_readl(g_snoop_base + SERH(num)));
+	} else {
+		__raw_writel(0, g_snoop_base + SBAR(num));
+	}
+
+	return window_size;
+}
+EXPORT_SYMBOL(mxc_snoop_set_config);
+
+int mxc_snoop_get_status(u32 num, u32 *statl, u32 *stath)
+{
+	if (num >= MAX_SNOOP)
+		return -EINVAL;
+
+	*statl = __raw_readl(g_snoop_base + SSRL(num));
+	*stath = __raw_readl(g_snoop_base + SSRH(num));
+	/* DPRINTK("status = 0x%08X%08X\n", stat[1], stat[0]); */
+
+#ifdef SNOOP_V2
+	__raw_writel(*statl, g_snoop_base + SSRL(num));
+	__raw_writel(*stath, g_snoop_base + SSRH(num));
+#else
+	__raw_writel(0x0, g_snoop_base + SSRL(num));
+	__raw_writel(0x0, g_snoop_base + SSRH(num));
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(mxc_snoop_get_status);
+
+#endif				/* MAX_SNOOP */
diff --git a/drivers/mxc/ipu/snoop.h b/drivers/mxc/ipu/snoop.h
new file mode 100644
index 0000000..327ac81
--- /dev/null
+++ b/drivers/mxc/ipu/snoop.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2008-2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __INCLUDE_IPU_SNOOP_H__
+#define __INCLUDE_IPU_SNOOP_H__
+
+int mxc_snoop_set_config(u32 num, unsigned long base, int size);
+int mxc_snoop_get_status(u32 num, u32 *statl, u32 *stath);
+
+#endif
diff --git a/drivers/mxc/ipu3/Kconfig b/drivers/mxc/ipu3/Kconfig
new file mode 100644
index 0000000..8dc92c0
--- /dev/null
+++ b/drivers/mxc/ipu3/Kconfig
@@ -0,0 +1,20 @@
+menu "MXC IPU V3"
+
+config MXC_IPU_V3
+	bool
+
+config MXC_IPU_V3D
+	bool
+
+config MXC_IPU
+	bool "Image Processing Unit Driver V3"
+	depends on !ARCH_MX21
+	depends on !ARCH_MX27
+	depends on !ARCH_MX25
+	select MXC_IPU_V3 if ARCH_MX37 || ARCH_MX51
+	select MXC_IPU_V3D if ARCH_MX37
+	help
+	  If you plan to use the Image Processing unit, say
+	  Y here. IPU is needed by Framebuffer and V4L2 drivers.
+
+endmenu
diff --git a/drivers/mxc/ipu3/Makefile b/drivers/mxc/ipu3/Makefile
new file mode 100644
index 0000000..559486d
--- /dev/null
+++ b/drivers/mxc/ipu3/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MXC_IPU_V3) = mxc_ipu.o
+
+mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o ipu_capture.o ipu_device.o
+
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
new file mode 100644
index 0000000..5a864de
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -0,0 +1,711 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_capture.c
+ *
+ * @brief IPU capture dase functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <mach/ipu.h>
+#include <linux/clk.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+
+/*!
+ * ipu_csi_init_interface
+ *	Sets initial values for the CSI registers.
+ *	The width and height of the sensor and the actual frame size will be
+ *	set to the same values.
+ * @param	width		Sensor width
+ * @param       height		Sensor height
+ * @param       pixel_fmt	pixel format
+ * @param       cfg_param	ipu_csi_signal_cfg_t structure
+ * @param       csi             csi 0 or csi 1
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t
+ipu_csi_init_interface(uint16_t width, uint16_t height, uint32_t pixel_fmt,
+	ipu_csi_signal_cfg_t cfg_param)
+{
+	uint32_t data = 0;
+	uint32_t csi = cfg_param.csi;
+	unsigned long lock_flags;
+
+	/* Set SENS_DATA_FORMAT bits (8, 9 and 10)
+	   RGB or YUV444 is 0 which is current value in data so not set
+	   explicitly
+	   This is also the default value if attempts are made to set it to
+	   something invalid. */
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_YUYV:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;
+		break;
+	case IPU_PIX_FMT_UYVY:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR24:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
+		break;
+	case IPU_PIX_FMT_GENERIC:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		break;
+	case IPU_PIX_FMT_RGB565:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;
+		break;
+	case IPU_PIX_FMT_RGB555:
+		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	data |= cfg_param.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
+		cfg_param.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |
+		cfg_param.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
+		cfg_param.Vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
+		cfg_param.Hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
+		cfg_param.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
+		cfg_param.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
+		cfg_param.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
+		cfg_param.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |
+		cfg_param.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |
+		cfg_param.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel(data, CSI_SENS_CONF(csi));
+
+	/* Setup sensor frame size */
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE(csi));
+
+	/* Set CCIR registers */
+	if ((cfg_param.clk_mode == IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE) ||
+	    (cfg_param.clk_mode == IPU_CSI_CLK_MODE_CCIR656_INTERLACED)) {
+		_ipu_csi_ccir_err_detection_enable(csi);
+		__raw_writel(0x40030, CSI_CCIR_CODE_1(csi));
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3(csi));
+	} else if ((cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR) ||
+		(cfg_param.clk_mode ==
+			IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR)) {
+		_ipu_csi_ccir_err_detection_enable(csi);
+		__raw_writel(0x40030, CSI_CCIR_CODE_1(csi));
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3(csi));
+	} else if ((cfg_param.clk_mode == IPU_CSI_CLK_MODE_GATED_CLK) ||
+		   (cfg_param.clk_mode == IPU_CSI_CLK_MODE_NONGATED_CLK)) {
+		_ipu_csi_ccir_err_detection_disable(csi);
+	}
+
+	dev_dbg(g_ipu_dev, "CSI_SENS_CONF = 0x%08X\n",
+		__raw_readl(CSI_SENS_CONF(csi)));
+	dev_dbg(g_ipu_dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
+		__raw_readl(CSI_ACT_FRM_SIZE(csi)));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_init_interface);
+
+/*! _ipu_csi_mclk_set
+ *
+ * @param	pixel_clk   desired pixel clock frequency in Hz
+ * @param	csi         csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_mclk_set(uint32_t pixel_clk, uint32_t csi)
+{
+	uint32_t temp;
+	uint32_t div_ratio;
+
+	div_ratio = (clk_get_rate(g_ipu_clk) / pixel_clk) - 1;
+
+	if (div_ratio > 0xFF || div_ratio < 0) {
+		dev_dbg(g_ipu_dev, "The value of pixel_clk extends normal range\n");
+		return -EINVAL;
+	}
+
+	temp = __raw_readl(CSI_SENS_CONF(csi));
+	temp &= ~CSI_SENS_CONF_DIVRATIO_MASK;
+	__raw_writel(temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),
+			CSI_SENS_CONF(csi));
+
+	return 0;
+}
+
+/*!
+ * ipu_csi_enable_mclk
+ *
+ * @param	csi         csi 0 or csi 1
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      Returns 0 on success
+ */
+int ipu_csi_enable_mclk(int csi, bool flag, bool wait)
+{
+	if (flag) {
+		clk_enable(g_csi_clk[csi]);
+		if (wait == true)
+			msleep(10);
+	} else
+		clk_disable(g_csi_clk[csi]);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_enable_mclk);
+
+/*!
+ * ipu_csi_get_window_size
+ *
+ * @param	width	pointer to window width
+ * @param	height	pointer to window height
+ * @param	csi	csi 0 or csi 1
+ */
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(CSI_ACT_FRM_SIZE(csi));
+	*width = (reg & 0xFFFF) + 1;
+	*height = (reg >> 16 & 0xFFFF) + 1;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_get_window_size);
+
+/*!
+ * ipu_csi_set_window_size
+ *
+ * @param	width	window width
+ * @param       height	window height
+ * @param       csi	csi 0 or csi 1
+ */
+void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi)
+{
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_ACT_FRM_SIZE(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_size);
+
+/*!
+ * ipu_csi_set_window_pos
+ *
+ * @param       left	uint32 window x start
+ * @param       top	uint32 window y start
+ * @param       csi	csi 0 or csi 1
+ */
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~(CSI_HSC_MASK | CSI_VSC_MASK);
+	temp |= ((top << CSI_VSC_SHIFT) | (left << CSI_HSC_SHIFT));
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_pos);
+
+/*!
+ * _ipu_csi_horizontal_downsize_enable
+ *	Enable horizontal downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_horizontal_downsize_enable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp |= CSI_HORI_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_horizontal_downsize_disable
+ *	Disable horizontal downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_horizontal_downsize_disable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~CSI_HORI_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_vertical_downsize_enable
+ *	Enable vertical downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_vertical_downsize_enable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp |= CSI_VERT_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_vertical_downsize_disable
+ *	Disable vertical downsizing(decimation) by 2.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_vertical_downsize_disable(uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_OUT_FRM_CTRL(csi));
+	temp &= ~CSI_VERT_DOWNSIZE_EN;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * ipu_csi_set_test_generator
+ *
+ * @param	active       1 for active and 0 for inactive
+ * @param       r_value	     red value for the generated pattern of even pixel
+ * @param       g_value      green value for the generated pattern of even
+ *			     pixel
+ * @param       b_value      blue value for the generated pattern of even pixel
+ * @param	pixel_clk   desired pixel clock frequency in Hz
+ * @param       csi          csi 0 or csi 1
+ */
+void ipu_csi_set_test_generator(bool active, uint32_t r_value,
+	uint32_t g_value, uint32_t b_value, uint32_t pix_clk, uint32_t csi)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_TST_CTRL(csi));
+
+	if (active == false) {
+		temp &= ~CSI_TEST_GEN_MODE_EN;
+		__raw_writel(temp, CSI_TST_CTRL(csi));
+	} else {
+		/* Set sensb_mclk div_ratio*/
+		_ipu_csi_mclk_set(pix_clk, csi);
+
+		temp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |
+			CSI_TEST_GEN_B_MASK);
+		temp |= CSI_TEST_GEN_MODE_EN;
+		temp |= (r_value << CSI_TEST_GEN_R_SHIFT) |
+			(g_value << CSI_TEST_GEN_G_SHIFT) |
+			(b_value << CSI_TEST_GEN_B_SHIFT);
+		__raw_writel(temp, CSI_TST_CTRL(csi));
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_csi_set_test_generator);
+
+/*!
+ * _ipu_csi_ccir_err_detection_en
+ *	Enable error detection and correction for
+ *	CCIR interlaced mode with protection bit.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_ccir_err_detection_enable(uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(CSI_CCIR_CODE_1(csi));
+	temp |= CSI_CCIR_ERR_DET_EN;
+	__raw_writel(temp, CSI_CCIR_CODE_1(csi));
+}
+
+/*!
+ * _ipu_csi_ccir_err_detection_disable
+ *	Disable error detection and correction for
+ *	CCIR interlaced mode with protection bit.
+ *
+ * @param	csi	csi 0 or csi 1
+ */
+void _ipu_csi_ccir_err_detection_disable(uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(CSI_CCIR_CODE_1(csi));
+	temp &= ~CSI_CCIR_ERR_DET_EN;
+	__raw_writel(temp, CSI_CCIR_CODE_1(csi));
+}
+
+/*!
+ * _ipu_csi_set_mipi_di
+ *
+ * @param	num	MIPI data identifier 0-3 handled by CSI
+ * @param	di_val	data identifier value
+ * @param	csi	csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_mipi_di(uint32_t num, uint32_t di_val, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (di_val > 0xFFL) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_MIPI_DI(csi));
+
+	switch (num) {
+	case IPU_CSI_MIPI_DI0:
+		temp &= ~CSI_MIPI_DI0_MASK;
+		temp |= (di_val << CSI_MIPI_DI0_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI1:
+		temp &= ~CSI_MIPI_DI1_MASK;
+		temp |= (di_val << CSI_MIPI_DI1_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI2:
+		temp &= ~CSI_MIPI_DI2_MASK;
+		temp |= (di_val << CSI_MIPI_DI2_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	case IPU_CSI_MIPI_DI3:
+		temp &= ~CSI_MIPI_DI3_MASK;
+		temp |= (di_val << CSI_MIPI_DI3_SHIFT);
+		__raw_writel(temp, CSI_MIPI_DI(csi));
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_csi_set_skip_isp
+ *
+ * @param	skip		select frames to be skipped and set the
+ *				correspond bits to 1
+ * @param	max_ratio	number of frames in a skipping set and the
+ * 				maximum value of max_ratio is 5
+ * @param	csi		csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_skip_isp(uint32_t skip, uint32_t max_ratio, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (max_ratio > 5) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_SKIP(csi));
+	temp &= ~(CSI_MAX_RATIO_SKIP_ISP_MASK | CSI_SKIP_ISP_MASK);
+	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_ISP_SHIFT) |
+		(skip << CSI_SKIP_ISP_SHIFT);
+	__raw_writel(temp, CSI_SKIP(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_csi_set_skip_smfc
+ *
+ * @param	skip		select frames to be skipped and set the
+ *				correspond bits to 1
+ * @param	max_ratio	number of frames in a skipping set and the
+ *				maximum value of max_ratio is 5
+ * @param	id		csi to smfc skipping id
+ * @param	csi		csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_set_skip_smfc(uint32_t skip, uint32_t max_ratio,
+	uint32_t id, uint32_t csi)
+{
+	uint32_t temp;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (max_ratio > 5 || id > 3) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(CSI_SKIP(csi));
+	temp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |
+			CSI_SKIP_SMFC_MASK);
+	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |
+			(id << CSI_ID_2_SKIP_SHIFT) |
+			(skip << CSI_SKIP_SMFC_SHIFT);
+	__raw_writel(temp, CSI_SKIP(csi));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err:
+	return retval;
+}
+
+/*!
+ * _ipu_smfc_init
+ *	Map CSI frames to IDMAC channels.
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	mipi_id		mipi id number 0-3
+ * @param	csi		csi0 or csi1
+ */
+void _ipu_smfc_init(ipu_channel_t channel, uint32_t mipi_id, uint32_t csi)
+{
+	uint32_t temp;
+
+	temp = __raw_readl(SMFC_MAP);
+
+	switch (channel) {
+	case CSI_MEM0:
+		temp &= ~SMFC_MAP_CH0_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH0_SHIFT;
+		break;
+	case CSI_MEM1:
+		temp &= ~SMFC_MAP_CH1_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH1_SHIFT;
+		break;
+	case CSI_MEM2:
+		temp &= ~SMFC_MAP_CH2_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH2_SHIFT;
+		break;
+	case CSI_MEM3:
+		temp &= ~SMFC_MAP_CH3_MASK;
+		temp |= ((csi << 2) | mipi_id) << SMFC_MAP_CH3_SHIFT;
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_MAP);
+}
+
+/*!
+ * _ipu_smfc_set_wmc
+ *	Caution: The number of required channels,  the enabled channels
+ *	and the FIFO size per channel are configured restrictedly.
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	set		set 1 or clear 0
+ * @param	level		water mark level when FIFO is on the
+ *				relative size
+ */
+void _ipu_smfc_set_wmc(ipu_channel_t channel, bool set, uint32_t level)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(SMFC_WMC);
+
+	switch (channel) {
+	case CSI_MEM0:
+		if (set == true) {
+			temp &= ~SMFC_WM0_SET_MASK;
+			temp |= level << SMFC_WM0_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM0_CLR_MASK;
+			temp |= level << SMFC_WM0_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM1:
+		if (set == true) {
+			temp &= ~SMFC_WM1_SET_MASK;
+			temp |= level << SMFC_WM1_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM1_CLR_MASK;
+			temp |= level << SMFC_WM1_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM2:
+		if (set == true) {
+			temp &= ~SMFC_WM2_SET_MASK;
+			temp |= level << SMFC_WM2_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM2_CLR_MASK;
+			temp |= level << SMFC_WM2_CLR_SHIFT;
+		}
+		break;
+	case CSI_MEM3:
+		if (set == true) {
+			temp &= ~SMFC_WM3_SET_MASK;
+			temp |= level << SMFC_WM3_SET_SHIFT;
+		} else {
+			temp &= ~SMFC_WM3_CLR_MASK;
+			temp |= level << SMFC_WM3_CLR_SHIFT;
+		}
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_WMC);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_smfc_set_burst_size
+ *
+ * @param	channel		IDMAC channel 0-3
+ * @param	bs		burst size of IDMAC channel,
+ *				the value programmed here shoud be BURST_SIZE-1
+ */
+void _ipu_smfc_set_burst_size(ipu_channel_t channel, uint32_t bs)
+{
+	uint32_t temp;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	temp = __raw_readl(SMFC_BS);
+
+	switch (channel) {
+	case CSI_MEM0:
+		temp &= ~SMFC_BS0_MASK;
+		temp |= bs << SMFC_BS0_SHIFT;
+		break;
+	case CSI_MEM1:
+		temp &= ~SMFC_BS1_MASK;
+		temp |= bs << SMFC_BS1_SHIFT;
+		break;
+	case CSI_MEM2:
+		temp &= ~SMFC_BS2_MASK;
+		temp |= bs << SMFC_BS2_SHIFT;
+		break;
+	case CSI_MEM3:
+		temp &= ~SMFC_BS3_MASK;
+		temp |= bs << SMFC_BS3_SHIFT;
+		break;
+	default:
+		return;
+	}
+
+	__raw_writel(temp, SMFC_BS);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+/*!
+ * _ipu_csi_init
+ *
+ * @param	channel      IDMAC channel
+ * @param	csi	     csi 0 or csi 1
+ *
+ * @return	Returns 0 on success or negative error code on fail
+ */
+int _ipu_csi_init(ipu_channel_t channel, uint32_t csi)
+{
+	uint32_t csi_sens_conf, csi_dest;
+	int retval = 0;
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		csi_dest = CSI_DATA_DEST_IDMAC;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case CSI_PRP_VF_MEM:
+		csi_dest = CSI_DATA_DEST_IC;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	csi_sens_conf = __raw_readl(CSI_SENS_CONF(csi));
+	csi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;
+	__raw_writel(csi_sens_conf | (csi_dest <<
+		CSI_SENS_CONF_DATA_DEST_SHIFT), CSI_SENS_CONF(csi));
+err:
+	return retval;
+}
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
new file mode 100644
index 0000000..e34d0b2
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -0,0 +1,2001 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_common.c
+ *
+ * @brief This file contains the IPU driver common API functions.
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+#include <linux/clk.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+struct ipu_irq_node {
+	irqreturn_t(*handler) (int, void *);	/*!< the ISR */
+	const char *name;	/*!< device associated with the interrupt */
+	void *dev_id;		/*!< some unique information for the ISR */
+	__u32 flags;		/*!< not used */
+};
+
+/* Globals */
+struct clk *g_ipu_clk;
+bool g_ipu_clk_enabled;
+struct clk *g_di_clk[2];
+struct clk *g_csi_clk[2];
+unsigned char g_dc_di_assignment[10];
+ipu_channel_t g_ipu_csi_channel[2];
+int g_ipu_irq[2];
+int g_ipu_hw_rev;
+bool g_sec_chan_en[21];
+bool g_thrd_chan_en[21];
+uint32_t g_channel_init_mask;
+uint32_t g_channel_enable_mask;
+DEFINE_SPINLOCK(ipu_lock);
+struct device *g_ipu_dev;
+
+static struct ipu_irq_node ipu_irq_list[IPU_IRQ_COUNT];
+static const char driver_name[] = "mxc_ipu";
+
+static int ipu_dc_use_count;
+static int ipu_dp_use_count;
+static int ipu_dmfc_use_count;
+static int ipu_smfc_use_count;
+static int ipu_ic_use_count;
+static int ipu_rot_use_count;
+static int ipu_di_use_count[2];
+static int ipu_csi_use_count[2];
+
+/* for power gating */
+static uint32_t ipu_conf_reg;
+static uint32_t ic_conf_reg;
+static uint32_t ipu_cha_db_mode_reg[4];
+static uint32_t ipu_cha_cur_buf_reg[4];
+static uint32_t idma_enable_reg[2];
+static uint32_t buf_ready_reg[8];
+
+u32 *ipu_cm_reg;
+u32 *ipu_idmac_reg;
+u32 *ipu_dp_reg;
+u32 *ipu_ic_reg;
+u32 *ipu_dc_reg;
+u32 *ipu_dc_tmpl_reg;
+u32 *ipu_dmfc_reg;
+u32 *ipu_di_reg[2];
+u32 *ipu_smfc_reg;
+u32 *ipu_csi_reg[2];
+u32 *ipu_cpmem_base;
+u32 *ipu_tpmem_base;
+u32 *ipu_disp_base[2];
+
+/* Static functions */
+static irqreturn_t ipu_irq_handler(int irq, void *desc);
+
+static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
+{
+	return ((uint32_t) ch >> (6 * type)) & 0x3F;
+};
+
+static inline int _ipu_is_ic_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 11) && (dma_chan <= 22));
+}
+
+static inline int _ipu_is_irt_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 45) && (dma_chan <= 50));
+}
+
+static inline int _ipu_is_dmfc_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 23) && (dma_chan <= 29));
+}
+
+static inline int _ipu_is_smfc_chan(uint32_t dma_chan)
+{
+	return ((dma_chan >= 0) && (dma_chan <= 3));
+}
+
+#define idma_is_valid(ch)	(ch != NO_DMA)
+#define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
+#define idma_is_set(reg, dma)	(__raw_readl(reg(dma)) & idma_mask(dma))
+
+/*!
+ * This function is called by the driver framework to initialize the IPU
+ * hardware.
+ *
+ * @param	dev	The device structure for the IPU passed in by the
+ *			driver framework.
+ *
+ * @return      Returns 0 on success or negative error code on error
+ */
+static int ipu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct mxc_ipu_config *plat_data = pdev->dev.platform_data;
+	unsigned long ipu_base;
+
+	spin_lock_init(&ipu_lock);
+
+	g_ipu_hw_rev = plat_data->rev;
+
+	g_ipu_dev = &pdev->dev;
+
+	/* Register IPU interrupts */
+	g_ipu_irq[0] = platform_get_irq(pdev, 0);
+	if (g_ipu_irq[0] < 0)
+		return -EINVAL;
+
+	if (request_irq(g_ipu_irq[0], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+		dev_err(g_ipu_dev, "request SYNC interrupt failed\n");
+		return -EBUSY;
+	}
+	/* Some platforms have 2 IPU interrupts */
+	g_ipu_irq[1] = platform_get_irq(pdev, 1);
+	if (g_ipu_irq[1] >= 0) {
+		if (request_irq
+		    (g_ipu_irq[1], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+			dev_err(g_ipu_dev, "request ERR interrupt failed\n");
+			return -EBUSY;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res))
+		return -ENODEV;
+
+	ipu_base = res->start;
+	ipu_cm_reg = ioremap(ipu_base + IPU_CM_REG_BASE, PAGE_SIZE);
+	ipu_ic_reg = ioremap(ipu_base + IPU_IC_REG_BASE, PAGE_SIZE);
+	ipu_idmac_reg = ioremap(ipu_base + IPU_IDMAC_REG_BASE, PAGE_SIZE);
+	/* DP Registers are accessed thru the SRM */
+	ipu_dp_reg = ioremap(ipu_base + IPU_SRM_REG_BASE, PAGE_SIZE);
+	ipu_dc_reg = ioremap(ipu_base + IPU_DC_REG_BASE, PAGE_SIZE);
+	ipu_dmfc_reg = ioremap(ipu_base + IPU_DMFC_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[0] = ioremap(ipu_base + IPU_DI0_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[1] = ioremap(ipu_base + IPU_DI1_REG_BASE, PAGE_SIZE);
+	ipu_smfc_reg = ioremap(ipu_base + IPU_SMFC_REG_BASE, PAGE_SIZE);
+	ipu_csi_reg[0] = ioremap(ipu_base + IPU_CSI0_REG_BASE, PAGE_SIZE);
+	ipu_csi_reg[1] = ioremap(ipu_base + IPU_CSI1_REG_BASE, PAGE_SIZE);
+	ipu_cpmem_base = ioremap(ipu_base + IPU_CPMEM_REG_BASE, PAGE_SIZE);
+	ipu_tpmem_base = ioremap(ipu_base + IPU_TPM_REG_BASE, SZ_64K);
+	ipu_dc_tmpl_reg = ioremap(ipu_base + IPU_DC_TMPL_REG_BASE, SZ_128K);
+	ipu_disp_base[1] = ioremap(ipu_base + IPU_DISP1_BASE, SZ_4K);
+
+	dev_dbg(g_ipu_dev, "IPU CM Regs = %p\n", ipu_cm_reg);
+	dev_dbg(g_ipu_dev, "IPU IC Regs = %p\n", ipu_ic_reg);
+	dev_dbg(g_ipu_dev, "IPU IDMAC Regs = %p\n", ipu_idmac_reg);
+	dev_dbg(g_ipu_dev, "IPU DP Regs = %p\n", ipu_dp_reg);
+	dev_dbg(g_ipu_dev, "IPU DC Regs = %p\n", ipu_dc_reg);
+	dev_dbg(g_ipu_dev, "IPU DMFC Regs = %p\n", ipu_dmfc_reg);
+	dev_dbg(g_ipu_dev, "IPU DI0 Regs = %p\n", ipu_di_reg[0]);
+	dev_dbg(g_ipu_dev, "IPU DI1 Regs = %p\n", ipu_di_reg[1]);
+	dev_dbg(g_ipu_dev, "IPU SMFC Regs = %p\n", ipu_smfc_reg);
+	dev_dbg(g_ipu_dev, "IPU CSI0 Regs = %p\n", ipu_csi_reg[0]);
+	dev_dbg(g_ipu_dev, "IPU CSI1 Regs = %p\n", ipu_csi_reg[1]);
+	dev_dbg(g_ipu_dev, "IPU CPMem = %p\n", ipu_cpmem_base);
+	dev_dbg(g_ipu_dev, "IPU TPMem = %p\n", ipu_tpmem_base);
+	dev_dbg(g_ipu_dev, "IPU DC Template Mem = %p\n", ipu_dc_tmpl_reg);
+	dev_dbg(g_ipu_dev, "IPU Display Region 1 Mem = %p\n", ipu_disp_base[1]);
+
+	/* Enable IPU and CSI clocks */
+	/* Get IPU clock freq */
+	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
+	dev_dbg(g_ipu_dev, "ipu_clk = %lu\n", clk_get_rate(g_ipu_clk));
+
+	clk_enable(g_ipu_clk);
+
+	g_di_clk[0] = plat_data->di_clk[0];
+	g_di_clk[1] = plat_data->di_clk[1];
+
+	g_csi_clk[0] = clk_get(&pdev->dev, "csi_mclk1");
+	g_csi_clk[1] = clk_get(&pdev->dev, "csi_mclk2");
+
+	__raw_writel(0x807FFFFF, IPU_MEM_RST);
+	while (__raw_readl(IPU_MEM_RST) & 0x80000000)
+		;
+
+	_ipu_init_dc_mappings();
+
+	/* Enable error interrupts by default */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	/* DMFC Init */
+	_ipu_dmfc_init();
+
+	/* Set sync refresh channels as high priority */
+	__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
+
+	/* Set MCU_T to divide MCU access window into 2 */
+	__raw_writel(0x00400000L | (IPU_MCU_T_DEFAULT << 18), IPU_DISP_GEN);
+
+	clk_disable(g_ipu_clk);
+
+	register_ipu_device();
+
+	return 0;
+}
+
+int ipu_remove(struct platform_device *pdev)
+{
+	if (g_ipu_irq[0])
+		free_irq(g_ipu_irq[0], 0);
+	if (g_ipu_irq[1])
+		free_irq(g_ipu_irq[1], 0);
+
+	clk_put(g_ipu_clk);
+
+	iounmap(ipu_cm_reg);
+	iounmap(ipu_ic_reg);
+	iounmap(ipu_idmac_reg);
+	iounmap(ipu_dc_reg);
+	iounmap(ipu_dp_reg);
+	iounmap(ipu_dmfc_reg);
+	iounmap(ipu_di_reg[0]);
+	iounmap(ipu_di_reg[1]);
+	iounmap(ipu_smfc_reg);
+	iounmap(ipu_csi_reg[0]);
+	iounmap(ipu_csi_reg[1]);
+	iounmap(ipu_cpmem_base);
+	iounmap(ipu_tpmem_base);
+	iounmap(ipu_dc_tmpl_reg);
+	iounmap(ipu_disp_base[1]);
+
+	return 0;
+}
+
+void ipu_dump_registers(void)
+{
+	printk(KERN_DEBUG "IPU_CONF = \t0x%08X\n", __raw_readl(IPU_CONF));
+	printk(KERN_DEBUG "IDMAC_CONF = \t0x%08X\n", __raw_readl(IDMAC_CONF));
+	printk(KERN_DEBUG "IDMAC_CHA_EN1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_EN(0)));
+	printk(KERN_DEBUG "IDMAC_CHA_EN2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_EN(32)));
+	printk(KERN_DEBUG "IDMAC_CHA_PRI1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_PRI(0)));
+	printk(KERN_DEBUG "IDMAC_CHA_PRI2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_CHA_PRI(32)));
+	printk(KERN_DEBUG "IDMAC_BAND_EN1 = \t0x%08X\n",
+	       __raw_readl(IDMAC_BAND_EN(0)));
+	printk(KERN_DEBUG "IDMAC_BAND_EN2 = \t0x%08X\n",
+	       __raw_readl(IDMAC_BAND_EN(32)));
+	printk(KERN_DEBUG "IPU_CHA_DB_MODE_SEL0 = \t0x%08X\n",
+	       __raw_readl(IPU_CHA_DB_MODE_SEL(0)));
+	printk(KERN_DEBUG "IPU_CHA_DB_MODE_SEL1 = \t0x%08X\n",
+	       __raw_readl(IPU_CHA_DB_MODE_SEL(32)));
+	printk(KERN_DEBUG "DMFC_WR_CHAN = \t0x%08X\n",
+	       __raw_readl(DMFC_WR_CHAN));
+	printk(KERN_DEBUG "DMFC_WR_CHAN_DEF = \t0x%08X\n",
+	       __raw_readl(DMFC_WR_CHAN_DEF));
+	printk(KERN_DEBUG "DMFC_DP_CHAN = \t0x%08X\n",
+	       __raw_readl(DMFC_DP_CHAN));
+	printk(KERN_DEBUG "DMFC_DP_CHAN_DEF = \t0x%08X\n",
+	       __raw_readl(DMFC_DP_CHAN_DEF));
+	printk(KERN_DEBUG "DMFC_IC_CTRL = \t0x%08X\n",
+	       __raw_readl(DMFC_IC_CTRL));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW1 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW1));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW2 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW2));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW3 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW3));
+	printk(KERN_DEBUG "IPU_FS_DISP_FLOW1 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_DISP_FLOW1));
+}
+
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	int ret = 0;
+	uint32_t ipu_conf;
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	/* re-enable error interrupts every time a channel is initialized */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	if (g_ipu_clk_enabled == false) {
+		g_ipu_clk_enabled = true;
+		clk_enable(g_ipu_clk);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_err(g_ipu_dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		if (params->csi_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu_smfc_use_count++;
+		ipu_csi_use_count[params->csi_mem.csi]++;
+		g_ipu_csi_channel[params->csi_mem.csi] = channel;
+
+		/*SMFC setting*/
+		if (params->csi_mem.mipi_en) {
+			ipu_conf |= (1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+				params->csi_mem.csi));
+			_ipu_smfc_init(channel, params->csi_mem.mipi_id,
+				params->csi_mem.csi);
+		} else {
+			ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+				params->csi_mem.csi));
+			_ipu_smfc_init(channel, 0, params->csi_mem.csi);
+		}
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_mem.csi);
+		break;
+	case CSI_PRP_ENC_MEM:
+		if (params->csi_prp_enc_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu_ic_use_count++;
+		ipu_csi_use_count[params->csi_prp_enc_mem.csi]++;
+		g_ipu_csi_channel[params->csi_prp_enc_mem.csi] = channel;
+
+		/*Without SMFC, CSI only support parallel data source*/
+		ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+			params->csi_prp_enc_mem.csi));
+
+		/*CSI0/1 feed into IC*/
+		ipu_conf &= ~IPU_CONF_IC_INPUT;
+		if (params->csi_prp_enc_mem.csi)
+			ipu_conf |= IPU_CONF_CSI_SEL;
+		else
+			ipu_conf &= ~IPU_CONF_CSI_SEL;
+
+		/*PRP skip buffer in memory, only valid when RWS_EN is true*/
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_prp_enc_mem.csi);
+		_ipu_ic_init_prpenc(params, true);
+		break;
+	case CSI_PRP_VF_MEM:
+		if (params->csi_prp_vf_mem.csi > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu_ic_use_count++;
+		ipu_csi_use_count[params->csi_prp_vf_mem.csi]++;
+		g_ipu_csi_channel[params->csi_prp_vf_mem.csi] = channel;
+
+		/*Without SMFC, CSI only support parallel data source*/
+		ipu_conf &= ~(1 << (IPU_CONF_CSI0_DATA_SOURCE_OFFSET +
+			params->csi_prp_vf_mem.csi));
+
+		/*CSI0/1 feed into IC*/
+		ipu_conf &= ~IPU_CONF_IC_INPUT;
+		if (params->csi_prp_vf_mem.csi)
+			ipu_conf |= IPU_CONF_CSI_SEL;
+		else
+			ipu_conf &= ~IPU_CONF_CSI_SEL;
+
+		/*PRP skip buffer in memory, only valid when RWS_EN is true*/
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		/*CSI data (include compander) dest*/
+		_ipu_csi_init(channel, params->csi_prp_vf_mem.csi);
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		if (params->mem_prp_vf_mem.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, false);
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_vf(params);
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+		_ipu_ic_init_prpenc(params, false);
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_enc(params);
+		break;
+	case MEM_PP_MEM:
+		if (params->mem_pp_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		if (params->mem_pp_mem.alpha_chan_en)
+			g_thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+		_ipu_ic_init_pp(params);
+		ipu_ic_use_count++;
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_init_rotate_pp(params);
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		break;
+	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[1] = params->mem_dc_sync.di;
+		_ipu_dc_init(1, params->mem_dc_sync.di,
+			     params->mem_dc_sync.interlaced);
+		ipu_di_use_count[params->mem_dc_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		if (params->mem_dp_bg_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[5] = params->mem_dp_bg_sync.di;
+		_ipu_dp_init(channel, params->mem_dp_bg_sync.in_pixel_fmt,
+			     params->mem_dp_bg_sync.out_pixel_fmt);
+		_ipu_dc_init(5, params->mem_dp_bg_sync.di,
+			     params->mem_dp_bg_sync.interlaced);
+		ipu_di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case DIRECT_ASYNC0:
+		if (params->direct_async.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[8] = params->direct_async.di;
+		_ipu_dc_init(8, params->direct_async.di, false);
+		ipu_di_use_count[params->direct_async.di]++;
+		ipu_dc_use_count++;
+		break;
+	case DIRECT_ASYNC1:
+		if (params->direct_async.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		g_dc_di_assignment[9] = params->direct_async.di;
+		_ipu_dc_init(9, params->direct_async.di, false);
+		ipu_di_use_count[params->direct_async.di]++;
+		ipu_dc_use_count++;
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	/* Enable IPU sub module */
+	g_channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+	ipu_conf = __raw_readl(IPU_CONF);
+	if (ipu_ic_use_count == 1)
+		ipu_conf |= IPU_CONF_IC_EN;
+	if (ipu_rot_use_count == 1)
+		ipu_conf |= IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 1)
+		ipu_conf |= IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 1)
+		ipu_conf |= IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 1)
+		ipu_conf |= IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 1) {
+		ipu_conf |= IPU_CONF_DI0_EN;
+		clk_enable(g_di_clk[0]);
+	}
+	if (ipu_di_use_count[1] == 1) {
+		ipu_conf |= IPU_CONF_DI1_EN;
+		clk_enable(g_di_clk[1]);
+	}
+	if (ipu_smfc_use_count == 1)
+		ipu_conf |= IPU_CONF_SMFC_EN;
+	if (ipu_csi_use_count[0] == 1)
+		ipu_conf |= IPU_CONF_CSI0_EN;
+	if (ipu_csi_use_count[1] == 1)
+		ipu_conf |= IPU_CONF_CSI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_init_channel);
+
+/*!
+ * This function is called to uninitialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to uninit.
+ */
+void ipu_uninit_channel(ipu_channel_t channel)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t in_dma, out_dma = 0;
+	uint32_t ipu_conf;
+
+	if ((g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already uninitialized %d\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	/* Make sure channel is disabled */
+	/* Get input and output dma channels */
+	in_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	out_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if (idma_is_set(IDMAC_CHA_EN, in_dma) ||
+	    idma_is_set(IDMAC_CHA_EN, out_dma)) {
+		dev_err(g_ipu_dev,
+			"Channel %d is not disabled, disable first\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Reset the double buffer */
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(in_dma));
+	__raw_writel(reg & ~idma_mask(in_dma), IPU_CHA_DB_MODE_SEL(in_dma));
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(out_dma));
+	__raw_writel(reg & ~idma_mask(out_dma), IPU_CHA_DB_MODE_SEL(out_dma));
+
+	g_sec_chan_en[IPU_CHAN_ID(channel)] = false;
+	g_thrd_chan_en[IPU_CHAN_ID(channel)] = false;
+
+	switch (channel) {
+	case CSI_MEM0:
+	case CSI_MEM1:
+	case CSI_MEM2:
+	case CSI_MEM3:
+		ipu_smfc_use_count--;
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case CSI_PRP_ENC_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpenc();
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case CSI_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpvf();
+		if (g_ipu_csi_channel[0] == channel) {
+			g_ipu_csi_channel[0] = CHAN_NONE;
+			ipu_csi_use_count[0]--;
+		} else if (g_ipu_csi_channel[1] == channel) {
+			g_ipu_csi_channel[1] = CHAN_NONE;
+			ipu_csi_use_count[1]--;
+		}
+		break;
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpvf();
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_vf();
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpenc();
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_enc();
+		break;
+	case MEM_PP_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_pp();
+		break;
+	case MEM_ROT_PP_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_pp();
+		break;
+	case MEM_DC_SYNC:
+		_ipu_dc_uninit(1);
+		ipu_di_use_count[g_dc_di_assignment[1]]--;
+		ipu_dc_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_BG_SYNC:
+		_ipu_dp_uninit(channel);
+		_ipu_dc_uninit(5);
+		ipu_di_use_count[g_dc_di_assignment[5]]--;
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_uninit(channel);
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case DIRECT_ASYNC0:
+		_ipu_dc_uninit(8);
+		ipu_di_use_count[g_dc_di_assignment[8]]--;
+		ipu_dc_use_count--;
+		break;
+	case DIRECT_ASYNC1:
+		_ipu_dc_uninit(9);
+		ipu_di_use_count[g_dc_di_assignment[9]]--;
+		ipu_dc_use_count--;
+		break;
+	default:
+		break;
+	}
+
+	g_channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	ipu_conf = __raw_readl(IPU_CONF);
+
+	if (ipu_ic_use_count == 0)
+		ipu_conf &= ~IPU_CONF_IC_EN;
+	if (ipu_rot_use_count == 0)
+		ipu_conf &= ~IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 0) {
+		ipu_conf &= ~IPU_CONF_DI0_EN;
+		clk_disable(g_di_clk[0]);
+	}
+	if (ipu_di_use_count[1] == 0) {
+		ipu_conf &= ~IPU_CONF_DI1_EN;
+		clk_disable(g_di_clk[1]);
+	}
+	if (ipu_smfc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_SMFC_EN;
+	if (ipu_csi_use_count[0] == 0)
+		ipu_conf &= ~IPU_CONF_CSI0_EN;
+	if (ipu_csi_use_count[1] == 0)
+		ipu_conf &= ~IPU_CONF_CSI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	if (ipu_conf == 0) {
+		clk_disable(g_ipu_clk);
+		g_ipu_clk_enabled = false;
+	}
+
+	WARN_ON(ipu_ic_use_count < 0);
+	WARN_ON(ipu_rot_use_count < 0);
+	WARN_ON(ipu_dc_use_count < 0);
+	WARN_ON(ipu_dp_use_count < 0);
+	WARN_ON(ipu_dmfc_use_count < 0);
+	WARN_ON(ipu_smfc_use_count < 0);
+}
+EXPORT_SYMBOL(ipu_uninit_channel);
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u, uint32_t v)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(g_ipu_dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC & IRT channels' width must be multiple of 8 pixels */
+	if ((_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan))
+		&& (width % 8)) {
+		dev_err(g_ipu_dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1);
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if (_ipu_is_ic_chan(dma_chan)) {
+		if ((width % 16) == 0)
+			_ipu_ch_param_set_burst_size(dma_chan, 16);
+		else
+			_ipu_ch_param_set_burst_size(dma_chan, 8);
+	} else if (_ipu_is_irt_chan(dma_chan)) {
+		_ipu_ch_param_set_burst_size(dma_chan, 8);
+		_ipu_ch_param_set_block_mode(dma_chan);
+	} else if (_ipu_is_dmfc_chan(dma_chan))
+		_ipu_dmfc_set_wait4eot(dma_chan, width);
+
+	if (_ipu_chan_is_interlaced(channel))
+		_ipu_ch_param_set_interlaced_scan(dma_chan);
+
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(dma_chan);
+		_ipu_ic_idma_init(dma_chan, width, height, burst_size,
+			rot_mode);
+	} else if (_ipu_is_smfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(dma_chan);
+		if ((pixel_fmt == IPU_PIX_FMT_GENERIC) &&
+			((_ipu_ch_param_get_bpp(dma_chan) == 5) ||
+			(_ipu_ch_param_get_bpp(dma_chan) == 3)))
+			burst_size = burst_size >> 4;
+		else
+			burst_size = burst_size >> 2;
+		_ipu_smfc_set_burst_size(channel, burst_size-1);
+	}
+
+	if (idma_is_set(IDMAC_CHA_PRI, dma_chan))
+		_ipu_ch_param_set_high_priority(dma_chan);
+
+	_ipu_ch_param_dump(dma_chan);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(dma_chan));
+	if (phyaddr_1)
+		reg |= idma_mask(dma_chan);
+	else
+		reg &= ~idma_mask(dma_chan);
+	__raw_writel(reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+	/* Reset to buffer 0 */
+	__raw_writel(idma_mask(dma_chan), IPU_CHA_CUR_BUF(dma_chan));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer);
+
+/*!
+ * This function is called to update the physical address of a buffer for
+ * a logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for buffer number to update.
+ *                              0 or 1 are the only valid values.
+ *
+ * @param       phyaddr         Input parameter buffer physical address.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail. This function will fail if the buffer is set to ready.
+ */
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr)
+{
+	uint32_t reg;
+	int ret = 0;
+	unsigned long lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bufNum == 0)
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+	else
+		reg = __raw_readl(IPU_CHA_BUF1_RDY(dma_chan));
+
+	if ((reg & idma_mask(dma_chan)) == 0)
+		_ipu_ch_param_set_buffer(dma_chan, bufNum, phyaddr);
+	else
+		ret = -EACCES;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_update_channel_buffer);
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_buffer(ipu_channel_t channel, ipu_buffer_t type,
+			  uint32_t bufNum)
+{
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		__raw_writel(idma_mask(dma_chan), IPU_CHA_BUF0_RDY(dma_chan));
+	} else {
+		/*Mark buffer 1 as ready. */
+		__raw_writel(idma_mask(dma_chan), IPU_CHA_BUF1_RDY(dma_chan));
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_buffer);
+
+#define NA	-1
+static int proc_dest_sel[] =
+    { 0, 1, 1, 3, 5, 5, 4, 7, 8, 9, 10, 11, 12, 14, 15 };
+static int proc_src_sel[] = { 0, 6, 7, 6, 7, 8, 5, NA, NA, NA,
+NA, NA, NA, NA, NA, 1, 2, 3, 4, 7, 8 };
+static int disp_src_sel[] = { 0, 6, 7, 8, 3, 4, 5, NA, NA, NA,
+NA, NA, NA, NA, NA, 1, NA, 2, NA, 3, 4 };
+
+/*!
+ * This function links 2 channels together for automatic frame
+ * synchronization. The output of the source channel is linked to the input of
+ * the destination channel.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_proc_flow3;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_proc_flow3 = __raw_readl(IPU_FS_PROC_FLOW3);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case CSI_MEM0:
+		fs_proc_flow3 &= ~FS_SMFC0_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC0_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM1:
+		fs_proc_flow3 &= ~FS_SMFC1_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC1_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM2:
+		fs_proc_flow3 &= ~FS_SMFC2_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC2_DEST_SEL_OFFSET;
+		break;
+	case CSI_MEM3:
+		fs_proc_flow3 &= ~FS_SMFC3_DEST_SEL_MASK;
+		fs_proc_flow3 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_SMFC3_DEST_SEL_OFFSET;
+		break;
+	case CSI_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_PRPENC_DEST_SEL_OFFSET;
+		break;
+	case CSI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+			proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+			FS_PRPVF_DEST_SEL_OFFSET;
+		break;
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_ROT_DEST_SEL_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPENC_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPENC_ROT_DEST_SEL_OFFSET;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPVF_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PRPVF_ROT_DEST_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PP_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PRP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRPENC_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PRPENC_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PRP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRPVF_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PRPVF_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] << FS_DC1_SRC_SEL_OFFSET;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC0_SRC_SEL_OFFSET;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC1_SRC_SEL_OFFSET;
+		break;
+	case MEM_DC_ASYNC:
+		fs_disp_flow1 &= ~FS_DC2_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] << FS_DC2_SRC_SEL_OFFSET;
+		break;
+	case MEM_BG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC0_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_ASYNC0_SRC_SEL_OFFSET;
+		break;
+	case MEM_FG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_ASYNC1_SRC_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_proc_flow3, IPU_FS_PROC_FLOW3);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_link_channels);
+
+/*!
+ * This function unlinks 2 channels and disables automatic frame
+ * synchronization.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_proc_flow3;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_proc_flow3 = __raw_readl(IPU_FS_PROC_FLOW3);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case CSI_MEM0:
+		fs_proc_flow3 &= ~FS_SMFC0_DEST_SEL_MASK;
+		break;
+	case CSI_MEM1:
+		fs_proc_flow3 &= ~FS_SMFC1_DEST_SEL_MASK;
+		break;
+	case CSI_MEM2:
+		fs_proc_flow3 &= ~FS_SMFC2_DEST_SEL_MASK;
+		break;
+	case CSI_MEM3:
+		fs_proc_flow3 &= ~FS_SMFC3_DEST_SEL_MASK;
+		break;
+	case CSI_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		break;
+	case CSI_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow2 &= ~FS_PRPENC_ROT_DEST_SEL_MASK;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow2 &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_PRP_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_ENC_MEM:
+		fs_proc_flow1 &= ~FS_PRPENC_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_PRP_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_VF_MEM:
+		fs_proc_flow1 &= ~FS_PRPVF_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		break;
+	case MEM_DC_ASYNC:
+		fs_disp_flow1 &= ~FS_DC2_SRC_SEL_MASK;
+		break;
+	case MEM_BG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC0_SRC_SEL_MASK;
+		break;
+	case MEM_FG_ASYNC0:
+		fs_disp_flow1 &= ~FS_DP_ASYNC1_SRC_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_proc_flow3, IPU_FS_PROC_FLOW3);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_unlink_channels);
+
+/*!
+ * This function check whether a logical channel was enabled.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 1 while request channel is enabled or
+ *              0 for not enabled.
+ */
+int32_t ipu_is_channel_busy(ipu_channel_t channel)
+{
+	uint32_t reg;
+	uint32_t in_dma;
+	uint32_t out_dma;
+
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+	if (reg & idma_mask(in_dma))
+		return 1;
+	reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+	if (reg & idma_mask(out_dma))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(ipu_is_channel_busy);
+
+/*!
+ * This function enables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_enable_channel(ipu_channel_t channel)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t sec_dma;
+	uint32_t thrd_dma;
+
+	if (g_channel_enable_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_err(g_ipu_dev, "Warning: channel already enabled %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg | idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg | idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+	}
+
+	if ((g_sec_chan_en[IPU_CHAN_ID(channel)]) &&
+		((channel == MEM_PP_MEM) || (channel == MEM_PRP_VF_MEM))) {
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+		reg = __raw_readl(IDMAC_CHA_EN(sec_dma));
+		__raw_writel(reg | idma_mask(sec_dma), IDMAC_CHA_EN(sec_dma));
+	}
+	if ((g_thrd_chan_en[IPU_CHAN_ID(channel)]) &&
+		((channel == MEM_PP_MEM) || (channel == MEM_PRP_VF_MEM))) {
+		thrd_dma = channel_2_dma(channel, IPU_ALPHA_IN_BUFFER);
+		reg = __raw_readl(IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(reg | idma_mask(thrd_dma), IDMAC_CHA_EN(thrd_dma));
+	}
+
+	if ((channel == MEM_DC_SYNC) || (channel == MEM_BG_SYNC) ||
+	    (channel == MEM_FG_SYNC))
+		_ipu_dp_dc_enable(channel);
+
+	if (_ipu_is_ic_chan(in_dma) || _ipu_is_ic_chan(out_dma) ||
+		_ipu_is_irt_chan(in_dma) || _ipu_is_irt_chan(out_dma))
+		_ipu_ic_enable_task(channel);
+
+	g_channel_enable_mask |= 1L << IPU_CHAN_ID(channel);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_enable_channel);
+
+/*!
+ * This function disables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       wait_for_stop   Flag to set whether to wait for channel end
+ *                              of frame or return immediately.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t sec_dma = NO_DMA;
+	uint32_t thrd_dma = NO_DMA;
+	uint32_t timeout;
+
+	if ((g_channel_enable_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already disabled %d\n",
+			IPU_CHAN_ID(channel));
+		return 0;
+	}
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if ((idma_is_valid(in_dma) &&
+		!idma_is_set(IDMAC_CHA_EN, in_dma))
+		&& (idma_is_valid(out_dma) &&
+		!idma_is_set(IDMAC_CHA_EN, out_dma)))
+		return -EINVAL;
+
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)])
+		sec_dma = channel_2_dma(channel, IPU_GRAPH_IN_BUFFER);
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)])
+		thrd_dma = channel_2_dma(channel, IPU_ALPHA_IN_BUFFER);
+
+	if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC) ||
+	    (channel == MEM_DC_SYNC)) {
+		_ipu_dp_dc_disable(channel);
+	} else if (wait_for_stop) {
+		timeout = 40;
+		while (idma_is_set(IDMAC_CHA_BUSY, in_dma) ||
+		       idma_is_set(IDMAC_CHA_BUSY, out_dma) ||
+			(g_sec_chan_en[IPU_CHAN_ID(channel)] &&
+			idma_is_set(IDMAC_CHA_BUSY, sec_dma)) ||
+			(g_thrd_chan_en[IPU_CHAN_ID(channel)] &&
+			idma_is_set(IDMAC_CHA_BUSY, thrd_dma)) ||
+		       (_ipu_channel_status(channel) == TASK_STAT_ACTIVE)) {
+			timeout--;
+			msleep(10);
+			if (timeout == 0) {
+				ipu_dump_registers();
+				break;
+			}
+		}
+		dev_dbg(g_ipu_dev, "timeout = %d * 10ms\n", 40 - timeout);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Disable IC task */
+	if (_ipu_is_ic_chan(in_dma) || _ipu_is_ic_chan(out_dma) ||
+		_ipu_is_irt_chan(in_dma) || _ipu_is_irt_chan(out_dma))
+		_ipu_ic_disable_task(channel);
+
+	/* Disable DMA channel(s) */
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg & ~idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+		__raw_writel(idma_mask(in_dma), IPU_CHA_CUR_BUF(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg & ~idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+		__raw_writel(idma_mask(out_dma), IPU_CHA_CUR_BUF(out_dma));
+	}
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(sec_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(sec_dma));
+		__raw_writel(reg & ~idma_mask(sec_dma), IDMAC_CHA_EN(sec_dma));
+		__raw_writel(idma_mask(sec_dma), IPU_CHA_CUR_BUF(sec_dma));
+	}
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(thrd_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(reg & ~idma_mask(thrd_dma), IDMAC_CHA_EN(thrd_dma));
+		__raw_writel(idma_mask(thrd_dma), IPU_CHA_CUR_BUF(thrd_dma));
+	}
+
+	/* Set channel buffers NOT to be ready */
+	__raw_writel(0xF0000000, IPU_GPR); /* write one to clear */
+	if (idma_is_valid(in_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, in_dma)) {
+			__raw_writel(idma_mask(in_dma),
+				     IPU_CHA_BUF0_RDY(in_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, in_dma)) {
+			__raw_writel(idma_mask(in_dma),
+				     IPU_CHA_BUF1_RDY(in_dma));
+		}
+	}
+	if (idma_is_valid(out_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, out_dma)) {
+			__raw_writel(idma_mask(out_dma),
+				     IPU_CHA_BUF0_RDY(out_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, out_dma)) {
+			__raw_writel(idma_mask(out_dma),
+				     IPU_CHA_BUF1_RDY(out_dma));
+		}
+	}
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(sec_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, sec_dma)) {
+			__raw_writel(idma_mask(sec_dma),
+				     IPU_CHA_BUF0_RDY(sec_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, sec_dma)) {
+			__raw_writel(idma_mask(sec_dma),
+				     IPU_CHA_BUF1_RDY(sec_dma));
+		}
+	}
+	if (g_thrd_chan_en[IPU_CHAN_ID(channel)] && idma_is_valid(thrd_dma)) {
+		if (idma_is_set(IPU_CHA_BUF0_RDY, thrd_dma)) {
+			__raw_writel(idma_mask(thrd_dma),
+				     IPU_CHA_BUF0_RDY(thrd_dma));
+		}
+		if (idma_is_set(IPU_CHA_BUF1_RDY, thrd_dma)) {
+			__raw_writel(idma_mask(thrd_dma),
+				     IPU_CHA_BUF1_RDY(thrd_dma));
+		}
+	}
+	__raw_writel(0x0, IPU_GPR); /* write one to set */
+
+	g_channel_enable_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disable_channel);
+
+static irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	int i;
+	uint32_t line;
+	irqreturn_t result = IRQ_NONE;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
+
+	if (g_ipu_irq[1]) {
+		disable_irq(g_ipu_irq[0]);
+		disable_irq(g_ipu_irq[1]);
+	}
+
+	for (i = 0;; i++) {
+		if (err_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(err_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			__raw_writel(int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_err(g_ipu_dev,
+				"IPU Error - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+
+			/* Disable interrupts so we only get error once */
+			int_stat =
+			    __raw_readl(IPU_INT_CTRL(err_reg[i])) & ~int_stat;
+			__raw_writel(int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	for (i = 0;; i++) {
+		if (int_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(int_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(int_reg[i]));
+		__raw_writel(int_stat, IPU_INT_STAT(int_reg[i]));
+		while ((line = ffs(int_stat)) != 0) {
+			line--;
+			int_stat &= ~(1UL << line);
+			line += (int_reg[i] - 1) * 32;
+			result |=
+			    ipu_irq_list[line].handler(line,
+						       ipu_irq_list[line].
+						       dev_id);
+		}
+	}
+
+	if (g_ipu_irq[1]) {
+		enable_irq(g_ipu_irq[0]);
+		enable_irq(g_ipu_irq[1]);
+	}
+	return result;
+}
+
+/*!
+ * This function enables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to enable interrupt for.
+ *
+ */
+void ipu_enable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_enable_irq);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_disable_irq);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq(uint32_t irq)
+{
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_clear_irq);
+
+/*!
+ * This function returns the current interrupt status for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @return      Returns true if the interrupt is pending/asserted or false if
+ *              the interrupt is not pending.
+ */
+bool ipu_get_irq_status(uint32_t irq)
+{
+	uint32_t reg;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	if (reg & IPUIRQ_2_MASK(irq))
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(ipu_get_irq_status);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	unsigned long lock_flags;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (ipu_irq_list[irq].handler != NULL) {
+		dev_err(g_ipu_dev,
+			"handler already installed on irq %d\n", irq);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	ipu_irq_list[irq].handler = handler;
+	ipu_irq_list[irq].flags = irq_flags;
+	ipu_irq_list[irq].dev_id = dev_id;
+	ipu_irq_list[irq].name = devname;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	ipu_enable_irq(irq);	/* enable the interrupt */
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_request_irq);
+
+/*!
+ * This function unregisters an interrupt handler for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler. This must match value passed to
+ *                              ipu_request_irq().
+ *
+ */
+void ipu_free_irq(uint32_t irq, void *dev_id)
+{
+	ipu_disable_irq(irq);	/* disable the interrupt */
+
+	if (ipu_irq_list[irq].dev_id == dev_id)
+		ipu_irq_list[irq].handler = NULL;
+}
+EXPORT_SYMBOL(ipu_free_irq);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel)
+{
+	uint32_t stat = 0;
+	uint32_t task_stat_reg = __raw_readl(IPU_PROC_TASK_STAT);
+
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_VF_ROT_MASK) >> TSTAT_VF_ROT_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		stat = (task_stat_reg & TSTAT_ENC_MASK) >> TSTAT_ENC_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_ENC_ROT_MASK) >>
+		    TSTAT_ENC_ROT_OFFSET;
+		break;
+	case MEM_PP_MEM:
+		stat = (task_stat_reg & TSTAT_PP_MASK) >> TSTAT_PP_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_PP_ROT_MASK) >> TSTAT_PP_ROT_OFFSET;
+		break;
+
+	default:
+		stat = TASK_STAT_IDLE;
+		break;
+	}
+	return stat;
+}
+
+uint32_t bytes_per_pixel(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/*generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+		break;
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+		break;
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+		break;
+	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bytes_per_pixel);
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB666:
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+	case IPU_PIX_FMT_LVDS666:
+	case IPU_PIX_FMT_LVDS888:
+		return RGB;
+		break;
+
+	default:
+		return YCbCr;
+		break;
+	}
+	return RGB;
+}
+
+void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3])
+{
+	_ipu_dp_set_csc_coefficients(channel, param);
+}
+EXPORT_SYMBOL(ipu_set_csc_coefficients);
+
+static int ipu_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (g_ipu_clk_enabled) {
+		/* save and disable enabled channels*/
+		idma_enable_reg[0] = __raw_readl(IDMAC_CHA_EN(0));
+		idma_enable_reg[1] = __raw_readl(IDMAC_CHA_EN(32));
+		while ((__raw_readl(IDMAC_CHA_BUSY(0)) & idma_enable_reg[0])
+			|| (__raw_readl(IDMAC_CHA_BUSY(32)) &
+				idma_enable_reg[1])) {
+			/* disable channel not busy already */
+			uint32_t chan_should_disable, timeout = 1000, time = 0;
+
+			chan_should_disable =
+				__raw_readl(IDMAC_CHA_BUSY(0))
+					^ idma_enable_reg[0];
+			__raw_writel((~chan_should_disable) &
+					idma_enable_reg[0], IDMAC_CHA_EN(0));
+			chan_should_disable =
+				__raw_readl(IDMAC_CHA_BUSY(1))
+					^ idma_enable_reg[1];
+			__raw_writel((~chan_should_disable) &
+					idma_enable_reg[1], IDMAC_CHA_EN(32));
+			msleep(2);
+			time += 2;
+			if (time >= timeout)
+				return -1;
+		}
+		__raw_writel(0, IDMAC_CHA_EN(0));
+		__raw_writel(0, IDMAC_CHA_EN(32));
+
+		/* save double buffer select regs */
+		ipu_cha_db_mode_reg[0] = __raw_readl(IPU_CHA_DB_MODE_SEL(0));
+		ipu_cha_db_mode_reg[1] = __raw_readl(IPU_CHA_DB_MODE_SEL(32));
+		ipu_cha_db_mode_reg[2] =
+			__raw_readl(IPU_ALT_CHA_DB_MODE_SEL(0));
+		ipu_cha_db_mode_reg[3] =
+			__raw_readl(IPU_ALT_CHA_DB_MODE_SEL(32));
+
+		/* save current buffer regs */
+		ipu_cha_cur_buf_reg[0] = __raw_readl(IPU_CHA_CUR_BUF(0));
+		ipu_cha_cur_buf_reg[1] = __raw_readl(IPU_CHA_CUR_BUF(32));
+		ipu_cha_cur_buf_reg[2] = __raw_readl(IPU_ALT_CUR_BUF0);
+		ipu_cha_cur_buf_reg[3] = __raw_readl(IPU_ALT_CUR_BUF1);
+
+		/* save sub-modules status and disable all */
+		ic_conf_reg = __raw_readl(IC_CONF);
+		__raw_writel(0, IC_CONF);
+		ipu_conf_reg = __raw_readl(IPU_CONF);
+		__raw_writel(0, IPU_CONF);
+
+		/* save buf ready regs */
+		buf_ready_reg[0] = __raw_readl(IPU_CHA_BUF0_RDY(0));
+		buf_ready_reg[1] = __raw_readl(IPU_CHA_BUF0_RDY(32));
+		buf_ready_reg[2] = __raw_readl(IPU_CHA_BUF1_RDY(0));
+		buf_ready_reg[3] = __raw_readl(IPU_CHA_BUF1_RDY(32));
+		buf_ready_reg[4] = __raw_readl(IPU_ALT_CHA_BUF0_RDY(0));
+		buf_ready_reg[5] = __raw_readl(IPU_ALT_CHA_BUF0_RDY(32));
+		buf_ready_reg[6] = __raw_readl(IPU_ALT_CHA_BUF1_RDY(0));
+		buf_ready_reg[7] = __raw_readl(IPU_ALT_CHA_BUF1_RDY(32));
+	}
+
+	mxc_pg_enable(pdev);
+
+	return 0;
+}
+
+static int ipu_resume(struct platform_device *pdev)
+{
+	mxc_pg_disable(pdev);
+
+	if (g_ipu_clk_enabled) {
+
+		/* restore buf ready regs */
+		__raw_writel(buf_ready_reg[0], IPU_CHA_BUF0_RDY(0));
+		__raw_writel(buf_ready_reg[1], IPU_CHA_BUF0_RDY(32));
+		__raw_writel(buf_ready_reg[2], IPU_CHA_BUF1_RDY(0));
+		__raw_writel(buf_ready_reg[3], IPU_CHA_BUF1_RDY(32));
+		__raw_writel(buf_ready_reg[4], IPU_ALT_CHA_BUF0_RDY(0));
+		__raw_writel(buf_ready_reg[5], IPU_ALT_CHA_BUF0_RDY(32));
+		__raw_writel(buf_ready_reg[6], IPU_ALT_CHA_BUF1_RDY(0));
+		__raw_writel(buf_ready_reg[7], IPU_ALT_CHA_BUF1_RDY(32));
+
+		/* re-enable sub-modules*/
+		__raw_writel(ipu_conf_reg, IPU_CONF);
+		__raw_writel(ic_conf_reg, IC_CONF);
+
+		/* restore double buffer select regs */
+		__raw_writel(ipu_cha_db_mode_reg[0], IPU_CHA_DB_MODE_SEL(0));
+		__raw_writel(ipu_cha_db_mode_reg[1], IPU_CHA_DB_MODE_SEL(32));
+		__raw_writel(ipu_cha_db_mode_reg[2],
+				IPU_ALT_CHA_DB_MODE_SEL(0));
+		__raw_writel(ipu_cha_db_mode_reg[3],
+				IPU_ALT_CHA_DB_MODE_SEL(32));
+
+		/* restore current buffer select regs */
+		__raw_writel(~(ipu_cha_cur_buf_reg[0]), IPU_CHA_CUR_BUF(0));
+		__raw_writel(~(ipu_cha_cur_buf_reg[1]), IPU_CHA_CUR_BUF(32));
+		__raw_writel(~(ipu_cha_cur_buf_reg[2]), IPU_ALT_CUR_BUF0);
+		__raw_writel(~(ipu_cha_cur_buf_reg[3]), IPU_ALT_CUR_BUF1);
+
+		/* restart idma channel*/
+		__raw_writel(idma_enable_reg[0], IDMAC_CHA_EN(0));
+		__raw_writel(idma_enable_reg[1], IDMAC_CHA_EN(32));
+	} else {
+		clk_enable(g_ipu_clk);
+		_ipu_dmfc_init();
+		_ipu_init_dc_mappings();
+
+		/* Set sync refresh channels as high priority */
+		__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
+		clk_disable(g_ipu_clk);
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		   .name = "mxc_ipu",
+		   },
+	.probe = ipu_probe,
+	.remove = ipu_remove,
+	.suspend_late = ipu_suspend,
+	.resume_early = ipu_resume,
+};
+
+int32_t __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	platform_driver_unregister(&mxcipu_driver);
+}
+
+module_exit(ipu_gen_uninit);
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
new file mode 100644
index 0000000..58b330c
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -0,0 +1,496 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_device.c
+ *
+ * @brief This file contains the IPUv3 driver device interface and fops functions.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+#include <asm/cacheflush.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/* Strucutures and variables for exporting MXC IPU as device*/
+
+#define MAX_Q_SIZE 10
+
+static int mxc_ipu_major;
+static struct class *mxc_ipu_class;
+
+DEFINE_SPINLOCK(queue_lock);
+static DECLARE_MUTEX(user_mutex);
+
+static wait_queue_head_t waitq;
+static int pending_events;
+int read_ptr;
+int write_ptr;
+
+ipu_event_info events[MAX_Q_SIZE];
+
+int register_ipu_device(void);
+
+/* Static functions */
+
+int get_events(ipu_event_info *p)
+{
+	unsigned long flags;
+	int ret = 0, i, cnt, found = 0;
+
+	spin_lock_irqsave(&queue_lock, flags);
+	if (pending_events != 0) {
+		if (write_ptr > read_ptr)
+			cnt = write_ptr - read_ptr;
+		else
+			cnt = MAX_Q_SIZE - read_ptr + write_ptr;
+		for (i = 0; i < cnt; i++) {
+			if (p->irq == events[read_ptr].irq) {
+				*p = events[read_ptr];
+				events[read_ptr].irq = 0;
+				read_ptr++;
+				if (read_ptr >= MAX_Q_SIZE)
+					read_ptr = 0;
+				found = 1;
+				break;
+			}
+
+			if (events[read_ptr].irq) {
+				events[write_ptr] = events[read_ptr];
+				events[read_ptr].irq = 0;
+				write_ptr++;
+				if (write_ptr >= MAX_Q_SIZE)
+					write_ptr = 0;
+			} else
+				pending_events--;
+
+			read_ptr++;
+			if (read_ptr >= MAX_Q_SIZE)
+				read_ptr = 0;
+		}
+		if (found)
+			pending_events--;
+		else
+			ret = -1;
+	} else {
+		ret = -1;
+	}
+
+	spin_unlock_irqrestore(&queue_lock, flags);
+
+	return ret;
+}
+
+static irqreturn_t mxc_ipu_generic_handler(int irq, void *dev_id)
+{
+	ipu_event_info e;
+
+	e.irq = irq;
+	e.dev = dev_id;
+	events[write_ptr] = e;
+	write_ptr++;
+	if (write_ptr >= MAX_Q_SIZE)
+		write_ptr = 0;
+	pending_events++;
+
+	/* Wakeup any blocking user context */
+	wake_up_interruptible(&waitq);
+	return IRQ_HANDLED;
+}
+
+static int mxc_ipu_open(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	return ret;
+}
+static int mxc_ipu_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case IPU_INIT_CHANNEL:
+		{
+			ipu_channel_parm parm;
+
+			if (copy_from_user
+					(&parm, (ipu_channel_parm *) arg,
+					 sizeof(ipu_channel_parm)))
+				return -EFAULT;
+
+			if (!parm.flag) {
+				ret =
+					ipu_init_channel(parm.channel,
+							&parm.params);
+			} else {
+				ret = ipu_init_channel(parm.channel, NULL);
+			}
+		}
+		break;
+	case IPU_UNINIT_CHANNEL:
+		{
+		ipu_channel_t ch;
+		int __user *argp = (void __user *)arg;
+		if (get_user(ch, argp))
+				return -EFAULT;
+			ipu_uninit_channel(ch);
+		}
+		break;
+	case IPU_INIT_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			ret =
+				ipu_init_channel_buffer(
+						parm.channel, parm.type,
+						parm.pixel_fmt,
+						parm.width, parm.height,
+						parm.stride,
+						parm.rot_mode,
+						parm.phyaddr_0,
+						parm.phyaddr_1,
+						parm.u_offset,
+						parm.v_offset);
+
+		}
+		break;
+	case IPU_UPDATE_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			if ((parm.phyaddr_0 != (dma_addr_t) NULL)
+				&& (parm.phyaddr_1 == (dma_addr_t) NULL)) {
+				ret =
+					ipu_update_channel_buffer(
+							parm.channel,
+							parm.type,
+							parm.bufNum,
+							parm.phyaddr_0);
+			} else if ((parm.phyaddr_0 == (dma_addr_t) NULL)
+				&& (parm.phyaddr_1 != (dma_addr_t) NULL)) {
+				ret =
+					ipu_update_channel_buffer(
+							parm.channel,
+							parm.type,
+							parm.bufNum,
+							parm.phyaddr_1);
+			} else {
+				ret = -1;
+			}
+
+		}
+		break;
+	case IPU_SELECT_CHANNEL_BUFFER:
+		{
+			ipu_channel_buf_parm parm;
+			if (copy_from_user
+				(&parm, (ipu_channel_buf_parm *) arg,
+				sizeof(ipu_channel_buf_parm)))
+				return -EFAULT;
+
+			ret =
+				ipu_select_buffer(parm.channel,
+					parm.type, parm.bufNum);
+
+		}
+		break;
+	case IPU_LINK_CHANNELS:
+		{
+			ipu_channel_link link;
+			if (copy_from_user
+				(&link, (ipu_channel_link *) arg,
+				sizeof(ipu_channel_link)))
+				return -EFAULT;
+
+			ret = ipu_link_channels(link.src_ch,
+				link.dest_ch);
+
+		}
+		break;
+	case IPU_UNLINK_CHANNELS:
+		{
+			ipu_channel_link link;
+			if (copy_from_user
+				(&link, (ipu_channel_link *) arg,
+				sizeof(ipu_channel_link)))
+				return -EFAULT;
+
+			ret = ipu_unlink_channels(link.src_ch,
+				link.dest_ch);
+
+		}
+		break;
+	case IPU_ENABLE_CHANNEL:
+		{
+			ipu_channel_t ch;
+			int __user *argp = (void __user *)arg;
+			if (get_user(ch, argp))
+				return -EFAULT;
+			ipu_enable_channel(ch);
+		}
+		break;
+	case IPU_DISABLE_CHANNEL:
+		{
+			ipu_channel_info info;
+			if (copy_from_user
+				(&info, (ipu_channel_info *) arg,
+				 sizeof(ipu_channel_info)))
+				return -EFAULT;
+
+			ret = ipu_disable_channel(info.channel,
+				info.stop);
+		}
+		break;
+	case IPU_ENABLE_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_enable_irq(irq);
+		}
+		break;
+	case IPU_DISABLE_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_disable_irq(irq);
+		}
+		break;
+	case IPU_CLEAR_IRQ:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ipu_clear_irq(irq);
+		}
+		break;
+	case IPU_FREE_IRQ:
+		{
+			ipu_irq_info info;
+			int i;
+
+			if (copy_from_user
+					(&info, (ipu_irq_info *) arg,
+					 sizeof(ipu_irq_info)))
+				return -EFAULT;
+
+			ipu_free_irq(info.irq, info.dev_id);
+			for (i = 0; i < MAX_Q_SIZE; i++) {
+				if (events[i].irq == info.irq)
+					events[i].irq = 0;
+			}
+		}
+		break;
+	case IPU_REQUEST_IRQ_STATUS:
+		{
+			uint32_t irq;
+			int __user *argp = (void __user *)arg;
+			if (get_user(irq, argp))
+				return -EFAULT;
+			ret = ipu_get_irq_status(irq);
+		}
+		break;
+	case IPU_REGISTER_GENERIC_ISR:
+		{
+			ipu_event_info info;
+			if (copy_from_user
+					(&info, (ipu_event_info *) arg,
+					 sizeof(ipu_event_info)))
+				return -EFAULT;
+
+			ret =
+				ipu_request_irq(info.irq,
+					mxc_ipu_generic_handler,
+					0, "video_sink", info.dev);
+		}
+		break;
+	case IPU_GET_EVENT:
+		/* User will have to allocate event_type
+		structure and pass the pointer in arg */
+		{
+			ipu_event_info info;
+			int r = -1;
+
+			if (copy_from_user
+					(&info, (ipu_event_info *) arg,
+					 sizeof(ipu_event_info)))
+				return -EFAULT;
+
+			r = get_events(&info);
+			if (r == -1) {
+				wait_event_interruptible_timeout(waitq,
+						(pending_events != 0), 2 * HZ);
+				r = get_events(&info);
+			}
+			ret = -1;
+			if (r == 0) {
+				if (!copy_to_user((ipu_event_info *) arg,
+					&info, sizeof(ipu_event_info)))
+					ret = 0;
+			}
+		}
+		break;
+	case IPU_ALOC_MEM:
+		{
+			ipu_mem_info info;
+			if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					 sizeof(ipu_mem_info)))
+				return -EFAULT;
+
+			info.vaddr = dma_alloc_coherent(0,
+					PAGE_ALIGN(info.size),
+					&info.paddr,
+					GFP_DMA | GFP_KERNEL);
+			if (info.vaddr == 0) {
+				printk(KERN_ERR "dma alloc failed!\n");
+				return -ENOBUFS;
+			}
+			if (copy_to_user((ipu_mem_info *) arg, &info,
+					sizeof(ipu_mem_info)) > 0)
+				return -EFAULT;
+		}
+		break;
+	case IPU_FREE_MEM:
+		{
+			ipu_mem_info info;
+			if (copy_from_user
+					(&info, (ipu_mem_info *) arg,
+					 sizeof(ipu_mem_info)))
+				return -EFAULT;
+
+			if (info.vaddr)
+				dma_free_coherent(0, PAGE_ALIGN(info.size),
+					info.vaddr, info.paddr);
+			else
+				return -EFAULT;
+		}
+		break;
+	case IPU_IS_CHAN_BUSY:
+		{
+			ipu_channel_t chan;
+			if (copy_from_user
+					(&chan, (ipu_channel_t *)arg,
+					 sizeof(ipu_channel_t)))
+				return -EFAULT;
+
+			if (ipu_is_channel_busy(chan))
+				ret = 1;
+			else
+				ret = 0;
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static int mxc_ipu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	/* vma->vm_page_prot = pgprot_writethru(vma->vm_page_prot); */
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		printk(KERN_ERR
+				"mmap failed!\n");
+		return -ENOBUFS;
+	}
+	return 0;
+}
+
+static int mxc_ipu_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static struct file_operations mxc_ipu_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_ipu_open,
+	.mmap = mxc_ipu_mmap,
+	.release = mxc_ipu_release,
+	.ioctl = mxc_ipu_ioctl
+};
+
+int register_ipu_device()
+{
+	int ret = 0;
+	struct device *temp;
+	mxc_ipu_major = register_chrdev(0, "mxc_ipu", &mxc_ipu_fops);
+	if (mxc_ipu_major < 0) {
+		printk(KERN_ERR
+			"Unable to register Mxc Ipu as a char device\n");
+		return mxc_ipu_major;
+	}
+
+	mxc_ipu_class = class_create(THIS_MODULE, "mxc_ipu");
+	if (IS_ERR(mxc_ipu_class)) {
+		printk(KERN_ERR "Unable to create class for Mxc Ipu\n");
+		ret = PTR_ERR(mxc_ipu_class);
+		goto err1;
+	}
+
+	temp = device_create(mxc_ipu_class, NULL, MKDEV(mxc_ipu_major, 0),
+			NULL, "mxc_ipu");
+
+	if (IS_ERR(temp)) {
+		printk(KERN_ERR "Unable to create class device for Mxc Ipu\n");
+		ret = PTR_ERR(temp);
+		goto err2;
+	}
+	spin_lock_init(&queue_lock);
+	init_waitqueue_head(&waitq);
+
+	pending_events = 0;
+	read_ptr = 0;
+	write_ptr = 0;
+
+	return ret;
+
+err2:
+	class_destroy(mxc_ipu_class);
+err1:
+	unregister_chrdev(mxc_ipu_major, "mxc_ipu");
+	return ret;
+
+}
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
new file mode 100644
index 0000000..3e4e57d
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -0,0 +1,1367 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_disp.c
+ *
+ * @brief IPU display submodule API functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+#include <asm/atomic.h>
+#include <mach/common.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum csc_type_t {
+	RGB2YUV = 0,
+	YUV2RGB,
+	RGB2RGB,
+	YUV2YUV,
+	CSC_NONE,
+	CSC_NUM
+};
+
+struct dp_csc_param_t {
+	int mode;
+	void *coeff;
+};
+
+#define SYNC_WAVE 0
+#define ASYNC_SER_WAVE 6
+
+/* DC display ID assignments */
+#define DC_DISP_ID_SYNC(di)	(di)
+#define DC_DISP_ID_SERIAL	2
+#define DC_DISP_ID_ASYNC	3
+
+
+/* all value below is determined by fix reg setting in _ipu_dmfc_init*/
+#define DMFC_FIFO_SIZE_28	(128*4)
+#define DMFC_FIFO_SIZE_29	(64*4)
+#define DMFC_FIFO_SIZE_24	(64*4)
+#define DMFC_FIFO_SIZE_27	(128*4)
+#define DMFC_FIFO_SIZE_23	(128*4)
+
+void _ipu_dmfc_init(void)
+{
+	/* disable DMFC-IC channel*/
+	__raw_writel(0x2, DMFC_IC_CTRL);
+	/* 1 - segment 0 and 1; 2, 1C and 2C unused */
+	__raw_writel(0x00000090, DMFC_WR_CHAN);
+	__raw_writel(0x20202000, DMFC_WR_CHAN_DEF);
+	/* 5B - segment 2 and 3; 5F - segment 4 and 5; */
+	/* 6B - segment 6; 6F - segment 7 */
+	__raw_writel(0x1F1E9492, DMFC_DP_CHAN);
+}
+
+void _ipu_dmfc_set_wait4eot(int dma_chan, int width)
+{
+	u32 dmfc_gen1 = __raw_readl(DMFC_GENERAL1);
+
+	if (dma_chan == 23) { /*5B*/
+		if (DMFC_FIFO_SIZE_23/width > 3)
+			dmfc_gen1 |= 1UL << 20;
+		else
+			dmfc_gen1 &= ~(1UL << 20);
+	} else if (dma_chan == 24) { /*6B*/
+		if (DMFC_FIFO_SIZE_24/width > 1)
+			dmfc_gen1 |= 1UL << 22;
+		else
+			dmfc_gen1 &= ~(1UL << 22);
+	} else if (dma_chan == 27) { /*5F*/
+		if (DMFC_FIFO_SIZE_27/width > 2)
+			dmfc_gen1 |= 1UL << 21;
+		else
+			dmfc_gen1 &= ~(1UL << 21);
+	} else if (dma_chan == 28) { /*1*/
+		if (DMFC_FIFO_SIZE_28/width > 2)
+			dmfc_gen1 |= 1UL << 16;
+		else
+			dmfc_gen1 &= ~(1UL << 16);
+	} else if (dma_chan == 29) { /*6F*/
+		if (DMFC_FIFO_SIZE_29/width > 1)
+			dmfc_gen1 |= 1UL << 23;
+		else
+			dmfc_gen1 &= ~(1UL << 23);
+	}
+
+	__raw_writel(dmfc_gen1, DMFC_GENERAL1);
+}
+
+static void _ipu_di_data_wave_config(int di,
+				     int wave_gen,
+				     int access_size, int component_size)
+{
+	u32 reg;
+	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
+	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+}
+
+static void _ipu_di_data_pin_config(int di, int wave_gen, int di_pin, int set,
+				    int up, int down)
+{
+	u32 reg;
+
+	reg = __raw_readl(DI_DW_GEN(di, wave_gen));
+	reg &= ~(0x3 << (di_pin * 2));
+	reg |= set << (di_pin * 2);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+
+	__raw_writel((down << 16) | up, DI_DW_SET(di, wave_gen, set));
+}
+
+static void _ipu_di_sync_config(int di, int wave_gen,
+				int run_count, int run_src,
+				int offset_count, int offset_src,
+				int repeat_count, int cnt_clr_src,
+				int cnt_polarity_gen_en,
+				int cnt_polarity_clr_src,
+				int cnt_polarity_trigger_src,
+				int cnt_up, int cnt_down)
+{
+	u32 reg;
+
+	if ((run_count >= 0x1000) || (offset_count >= 0x1000) || (repeat_count >= 0x1000) ||
+		(cnt_up >= 0x400) || (cnt_down >= 0x400)) {
+		dev_err(g_ipu_dev, "DI%d counters out of range.\n", di);
+		return;
+	}
+
+	reg = (run_count << 19) | (++run_src << 16) |
+	    (offset_count << 3) | ++offset_src;
+	__raw_writel(reg, DI_SW_GEN0(di, wave_gen));
+	reg = (cnt_polarity_gen_en << 29) | (++cnt_clr_src << 25) |
+	    (++cnt_polarity_trigger_src << 12) | (++cnt_polarity_clr_src << 9);
+	reg |= (cnt_down << 16) | cnt_up;
+	if (repeat_count == 0) {
+		/* Enable auto reload */
+		reg |= 0x10000000;
+	}
+	__raw_writel(reg, DI_SW_GEN1(di, wave_gen));
+	reg = __raw_readl(DI_STP_REP(di, wave_gen));
+	reg &= ~(0xFFFF << (16 * ((wave_gen - 1) & 0x1)));
+	reg |= repeat_count << (16 * ((wave_gen - 1) & 0x1));
+	__raw_writel(reg, DI_STP_REP(di, wave_gen));
+}
+
+static void _ipu_dc_map_config(int map, int byte_num, int offset, int mask)
+{
+	int ptr = map * 3 + byte_num;
+	u32 reg;
+
+	reg = __raw_readl(DC_MAP_CONF_VAL(ptr));
+	reg &= ~(0xFFFF << (16 * (ptr & 0x1)));
+	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
+	__raw_writel(reg, DC_MAP_CONF_VAL(ptr));
+
+	reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	reg &= ~(0x1F << ((16 * (map & 0x1)) + (5 * byte_num)));
+	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
+	__raw_writel(reg, DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_map_clear(int map)
+{
+	u32 reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	__raw_writel(reg & ~(0xFFFF << (16 * (map & 0x1))),
+		     DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_write_tmpl(int word, u32 opcode, u32 operand, int map,
+			       int wave, int glue, int sync)
+{
+	u32 reg;
+	int stop = 1;
+
+	reg = sync;
+	reg |= (glue << 4);
+	reg |= (++wave << 11);
+	reg |= (++map << 15);
+	reg |= (operand << 20) & 0xFFF00000;
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2);
+
+	reg = (operand >> 12);
+	reg |= opcode << 4;
+	reg |= (stop << 9);
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2 + 1);
+}
+
+static void _ipu_dc_link_event(int chan, int event, int addr, int priority)
+{
+	u32 reg;
+
+	reg = __raw_readl(DC_RL_CH(chan, event));
+	reg &= ~(0xFFFF << (16 * (event & 0x1)));
+	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+	__raw_writel(reg, DC_RL_CH(chan, event));
+}
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+static const int rgb2ycbcr_coeff[5][3] = {
+	{153, 301, 58},
+	{-87, -170, 0x0100},
+	{0x100, -215, -42},
+	{0x0000, 0x0200, 0x0200},	/* B0, B1, B2 */
+	{0x2, 0x2, 0x2},	/* S0, S1, S2 */
+};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+static const int ycbcr2rgb_coeff[5][3] = {
+	{0x095, 0x000, 0x0CC},
+	{0x095, 0x3CE, 0x398},
+	{0x095, 0x0FF, 0x000},
+	{0x3E42, 0x010A, 0x3DD6},	/*B0,B1,B2 */
+	{0x1, 0x1, 0x1},	/*S0,S1,S2 */
+};
+
+#define mask_a(a) ((u32)(a) & 0x3FF)
+#define mask_b(b) ((u32)(b) & 0x3FFF)
+
+static int _rgb_to_yuv(int n, int red, int green, int blue)
+{
+	int c;
+	c = red * rgb2ycbcr_coeff[n][0];
+	c += green * rgb2ycbcr_coeff[n][1];
+	c += blue * rgb2ycbcr_coeff[n][2];
+	c /= 16;
+	c += rgb2ycbcr_coeff[3][n] * 4;
+	c += 8;
+	c /= 16;
+	if (c < 0)
+		c = 0;
+	if (c > 255)
+		c = 255;
+	return c;
+}
+
+/*
+ * Row is for BG: 	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ * Column is for FG:	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ */
+static struct dp_csc_param_t dp_csc_array[CSC_NUM][CSC_NUM] = {
+{{DP_COM_CONF_CSC_DEF_BOTH, &rgb2ycbcr_coeff}, {0, 0}, {0, 0}, {DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff}, {DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff} },
+{{0, 0}, {DP_COM_CONF_CSC_DEF_BOTH, &ycbcr2rgb_coeff}, {DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff}, {0, 0}, {DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff} },
+{{0, 0}, {DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff}, {0, 0}, {0, 0}, {0, 0} },
+{{DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff}, {0, 0}, {0, 0}, {0, 0}, {0, 0} },
+{{DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff}, {DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff}, {0, 0}, {0, 0}, {0, 0} }
+};
+
+static enum csc_type_t fg_csc_type = CSC_NONE, bg_csc_type = CSC_NONE;
+
+void __ipu_dp_csc_setup(int dp, struct dp_csc_param_t dp_csc_param,
+			bool srm_mode_update)
+{
+	u32 reg;
+	const int (*coeff)[5][3];
+
+	if (dp_csc_param.mode >= 0) {
+		reg = __raw_readl(DP_COM_CONF(dp));
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+		reg |= dp_csc_param.mode;
+		__raw_writel(reg, DP_COM_CONF(dp));
+	}
+
+	coeff = dp_csc_param.coeff;
+
+	if (coeff) {
+		__raw_writel(mask_a((*coeff)[0][0]) |
+				(mask_a((*coeff)[0][1]) << 16), DP_CSC_A_0(dp));
+		__raw_writel(mask_a((*coeff)[0][2]) |
+				(mask_a((*coeff)[1][0]) << 16), DP_CSC_A_1(dp));
+		__raw_writel(mask_a((*coeff)[1][1]) |
+				(mask_a((*coeff)[1][2]) << 16), DP_CSC_A_2(dp));
+		__raw_writel(mask_a((*coeff)[2][0]) |
+				(mask_a((*coeff)[2][1]) << 16), DP_CSC_A_3(dp));
+		__raw_writel(mask_a((*coeff)[2][2]) |
+				(mask_b((*coeff)[3][0]) << 16) |
+				((*coeff)[4][0] << 30), DP_CSC_0(dp));
+		__raw_writel(mask_b((*coeff)[3][1]) | ((*coeff)[4][1] << 14) |
+				(mask_b((*coeff)[3][2]) << 16) |
+				((*coeff)[4][2] << 30), DP_CSC_1(dp));
+	}
+
+	if (srm_mode_update) {
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+	}
+}
+
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt)
+{
+	int in_fmt, out_fmt;
+	int dp;
+	int partial = false;
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return -EINVAL;
+	}
+
+	in_fmt = format_to_colorspace(in_pixel_fmt);
+	out_fmt = format_to_colorspace(out_pixel_fmt);
+
+	if (partial) {
+		if (in_fmt == RGB) {
+			if (out_fmt == RGB)
+				fg_csc_type = RGB2RGB;
+			else
+				fg_csc_type = RGB2YUV;
+		} else {
+			if (out_fmt == RGB)
+				fg_csc_type = YUV2RGB;
+			else
+				fg_csc_type = YUV2YUV;
+		}
+	} else {
+		if (in_fmt == RGB) {
+			if (out_fmt == RGB)
+				bg_csc_type = RGB2RGB;
+			else
+				bg_csc_type = RGB2YUV;
+		} else {
+			if (out_fmt == RGB)
+				bg_csc_type = YUV2RGB;
+			else
+				bg_csc_type = YUV2YUV;
+		}
+	}
+
+	__ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], true);
+
+	return 0;
+}
+
+void _ipu_dp_uninit(ipu_channel_t channel)
+{
+	int dp;
+	int partial = false;
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return;
+	}
+
+	if (partial)
+		fg_csc_type = CSC_NONE;
+	else
+		bg_csc_type = CSC_NONE;
+
+	__ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], false);
+}
+
+void _ipu_dc_init(int dc_chan, int di, bool interlaced)
+{
+	u32 reg = 0;
+
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		if (interlaced) {
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 3);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 2);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 1);
+		} else {
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 4, 1);
+		}
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+
+		/* Make sure other DC sync channel is not assigned same DI */
+		reg = __raw_readl(DC_WR_CH_CONF(6 - dc_chan));
+		if ((di << 2) == (reg & DC_WR_CH_CONF_PROG_DI_ID)) {
+			reg &= ~DC_WR_CH_CONF_PROG_DI_ID;
+			reg |= di ? 0 : DC_WR_CH_CONF_PROG_DI_ID;
+			__raw_writel(reg, DC_WR_CH_CONF(6 - dc_chan));
+		}
+
+		reg = 0x2;
+		reg |= DC_DISP_ID_SYNC(di) << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+		reg |= di << 2;
+		if (interlaced)
+			reg |= DC_WR_CH_CONF_FIELD_MODE;
+	} else if ((dc_chan == 8) || (dc_chan == 9)) {
+		/* async channels */
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0x64, 1);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0x64, 1);
+
+		reg = 0x3;
+		reg |= DC_DISP_ID_SERIAL << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+	}
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	__raw_writel(0x00000000, DC_WR_CH_ADDR(dc_chan));
+
+	__raw_writel(0x00000084, DC_GEN);
+}
+
+void _ipu_dc_uninit(int dc_chan)
+{
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+	} else if ((dc_chan == 8) || (dc_chan == 9)) {
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR_R_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN_R_1, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_R_0, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_R_1, 0, 0);
+	}
+}
+
+int _ipu_chan_is_interlaced(ipu_channel_t channel)
+{
+	if (channel == MEM_DC_SYNC)
+		return !!(__raw_readl(DC_WR_CH_CONF_1) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	else if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC))
+		return !!(__raw_readl(DC_WR_CH_CONF_5) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	return 0;
+}
+
+void _ipu_dp_dc_enable(ipu_channel_t channel)
+{
+	uint32_t reg;
+	uint32_t dc_chan;
+	int irq = 0;
+
+	if (channel == MEM_FG_SYNC)
+		irq = IPU_IRQ_DP_SF_END;
+	else if (channel == MEM_DC_SYNC)
+		dc_chan = 1;
+	else if (channel == MEM_BG_SYNC)
+		dc_chan = 5;
+	else
+		return;
+
+	if (channel == MEM_FG_SYNC) {
+		/* Enable FG channel */
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		__raw_writel(reg | DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+		return;
+	}
+
+	reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_dc_di_assignment[dc_chan])
+		reg |= DI1_COUNTER_RELEASE;
+	else
+		reg |= DI0_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+}
+
+static irqreturn_t dc_irq_handler(int irq, void *dev_id)
+{
+	u32 reg;
+	uint32_t dc_chan;
+	ipu_channel_t channel;
+	struct completion *comp = dev_id;
+
+	if (irq == IPU_IRQ_DP_SF_END) {
+		channel = MEM_BG_SYNC;
+		dc_chan = 5;
+	} else if (irq == IPU_IRQ_DC_FC_1) {
+		channel = MEM_DC_SYNC;
+		dc_chan = 1;
+	} else {
+		return IRQ_HANDLED;
+	}
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_dc_di_assignment[dc_chan])
+		reg &= ~DI1_COUNTER_RELEASE;
+	else
+		reg &= ~DI0_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+
+	reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	if (__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_VSYNC_PRE_0 + g_dc_di_assignment[dc_chan])) &
+		IPUIRQ_2_MASK(IPU_IRQ_VSYNC_PRE_0 + g_dc_di_assignment[dc_chan]))
+		dev_err(g_ipu_dev, "VSyncPre occurred before DI%d disable\n", g_dc_di_assignment[dc_chan]);
+
+	complete(comp);
+	return IRQ_HANDLED;
+}
+
+void _ipu_dp_dc_disable(ipu_channel_t channel)
+{
+	int ret;
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t csc;
+	uint32_t dc_chan;
+	int irq = 0;
+	int timeout = 50;
+	DECLARE_COMPLETION_ONSTACK(dc_comp);
+
+	if (channel == MEM_DC_SYNC) {
+		dc_chan = 1;
+		irq = IPU_IRQ_DC_FC_1;
+	} else if (channel == MEM_BG_SYNC) {
+		dc_chan = 5;
+		irq = IPU_IRQ_DP_SF_END;
+	} else if (channel == MEM_FG_SYNC) {
+		/* Disable FG channel */
+
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		csc = reg & DP_COM_CONF_CSC_DEF_MASK;
+		if (csc == DP_COM_CONF_CSC_DEF_FG)
+			reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+
+		reg &= ~DP_COM_CONF_FG_EN;
+		__raw_writel(reg, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+		__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END),
+			     IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END));
+		while ((__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END)) &
+			IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END)) == 0) {
+			msleep(2);
+			timeout -= 2;
+			if (timeout <= 0)
+				break;
+		}
+		return;
+	} else {
+		return;
+	}
+
+	__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_VSYNC_PRE_0 + g_dc_di_assignment[dc_chan]),
+		     IPUIRQ_2_STATREG(IPU_IRQ_VSYNC_PRE_0 + g_dc_di_assignment[dc_chan]));
+	ipu_clear_irq(irq);
+	ret = ipu_request_irq(irq, dc_irq_handler, 0, NULL, &dc_comp);
+	if (ret < 0) {
+		dev_err(g_ipu_dev, "DC irq %d in use\n", irq);
+		return;
+	}
+	ret = wait_for_completion_timeout(&dc_comp, msecs_to_jiffies(50));
+
+	dev_dbg(g_ipu_dev, "DC stop timeout - %d * 10ms\n", 5 - ret);
+	ipu_free_irq(irq, &dc_comp);
+}
+
+void _ipu_init_dc_mappings(void)
+{
+	/* IPU_PIX_FMT_RGB24 */
+	_ipu_dc_map_clear(0);
+	_ipu_dc_map_config(0, 0, 7, 0xFF);
+	_ipu_dc_map_config(0, 1, 15, 0xFF);
+	_ipu_dc_map_config(0, 2, 23, 0xFF);
+
+	/* IPU_PIX_FMT_RGB666 */
+	_ipu_dc_map_clear(1);
+	_ipu_dc_map_config(1, 0, 5, 0xFC);
+	_ipu_dc_map_config(1, 1, 11, 0xFC);
+	_ipu_dc_map_config(1, 2, 17, 0xFC);
+
+	/* IPU_PIX_FMT_YUV444 */
+	_ipu_dc_map_clear(2);
+	_ipu_dc_map_config(2, 0, 15, 0xFF);
+	_ipu_dc_map_config(2, 1, 23, 0xFF);
+	_ipu_dc_map_config(2, 2, 7, 0xFF);
+
+	/* IPU_PIX_FMT_RGB565 */
+	_ipu_dc_map_clear(3);
+	_ipu_dc_map_config(3, 0, 4, 0xF8);
+	_ipu_dc_map_config(3, 1, 10, 0xFC);
+	_ipu_dc_map_config(3, 2, 15, 0xF8);
+
+	/* IPU_PIX_FMT_LVDS666 */
+	_ipu_dc_map_clear(4);
+	_ipu_dc_map_config(4, 0, 5, 0xFC);
+	_ipu_dc_map_config(4, 1, 13, 0xFC);
+	_ipu_dc_map_config(4, 2, 21, 0xFC);
+}
+
+int _ipu_pixfmt_to_map(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_RGB24:
+		return 0;
+	case IPU_PIX_FMT_RGB666:
+		return 1;
+	case IPU_PIX_FMT_YUV444:
+		return 2;
+	case IPU_PIX_FMT_RGB565:
+		return 3;
+	case IPU_PIX_FMT_LVDS666:
+		return 4;
+	}
+
+	return -1;
+}
+
+/*!
+ * This function sets the colorspace for of dp.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       param         	If it's not NULL, update the csc table
+ *                              with this parameter.
+ *
+ * @return      N/A
+ */
+void _ipu_dp_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3])
+{
+	int dp;
+	struct dp_csc_param_t dp_csc_param;
+
+	if (channel == MEM_FG_SYNC)
+		dp = DP_SYNC;
+	else if (channel == MEM_BG_SYNC)
+		dp = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		dp = DP_ASYNC0;
+	else
+		return;
+
+	dp_csc_param.mode = -1;
+	dp_csc_param.coeff = param;
+	__ipu_dp_csc_setup(dp, dp_csc_param, true);
+}
+
+/*!
+ * This function is called to initialize a synchronous LCD panel.
+ *
+ * @param       disp            The DI the panel is attached to.
+ *
+ * @param       pixel_clk       Desired pixel clock frequency in Hz.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           The width of panel in pixels.
+ *
+ * @param       height          The height of panel in pixels.
+ *
+ * @param       hStartWidth     The number of pixel clocks between the HSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       hSyncWidth      The width of the HSYNC signal in units of pixel
+ *                              clocks.
+ *
+ * @param       hEndWidth       The number of pixel clocks between the end of
+ *                              valid data and the HSYNC signal for next line.
+ *
+ * @param       vStartWidth     The number of lines between the VSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       vSyncWidth      The width of the VSYNC signal in units of lines
+ *
+ * @param       vEndWidth       The number of lines between the end of valid
+ *                              data and the VSYNC signal for next frame.
+ *
+ * @param       sig             Bitfield of signal polarities for LCD interface.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig)
+{
+	unsigned long lock_flags;
+	uint32_t field0_offset = 0;
+	uint32_t field1_offset;
+	uint32_t reg;
+	uint32_t disp_gen, di_gen, vsync_cnt;
+	uint32_t div;
+	uint32_t h_total, v_total;
+	int map;
+	struct clk *di_clk;
+	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
+
+	if ((v_sync_width == 0) || (h_sync_width == 0))
+		return EINVAL;
+
+	h_total = width + h_sync_width + h_start_width + h_end_width;
+	v_total = height + v_sync_width + v_start_width + v_end_width;
+
+	/* Init clocking */
+	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
+	if (sig.ext_clk)
+		di_clk = g_di_clk[disp];
+	else
+		di_clk = g_ipu_clk;
+
+	/*
+	 * Calculate divider
+	 * Fractional part is 4 bits,
+	 * so simply multiply by 2^4 to get fractional part.
+	 */
+	div = (clk_get_rate(di_clk) * 16) / pixel_clk;
+	if (div < 0x10)	/* Min DI disp clock divider is 1 */
+		div = 0x10;
+	/*
+	 * DI disp clock offset is zero,
+	 * and fractional part is rounded off to 0.5.
+	 */
+	div &= 0xFF8;
+
+	reg = __raw_readl(DI_GENERAL(disp));
+	if (sig.ext_clk)
+		__raw_writel(reg | DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
+	else
+		__raw_writel(reg & ~DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen &= disp ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	__raw_writel(div, DI_BS_CLKGEN0(disp));
+
+	/* Setup pixel clock timing */
+	/* FIXME: needs to be more flexible */
+	/* Down time is half of period */
+	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(disp));
+
+	_ipu_di_data_wave_config(disp, SYNC_WAVE, div / 16 - 1, div / 16 - 1);
+	_ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div / 16 * 2);
+
+	div = div / 16;		/* Now divider is integer portion */
+
+	map = _ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0) {
+		dev_dbg(g_ipu_dev, "IPU_DISP: No MAP\n");
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	di_gen = 0;
+	if (sig.ext_clk)
+		di_gen |= DI_GEN_DI_CLK_EXT;
+
+	if (sig.interlaced) {
+		if (cpu_is_mx51_rev(CHIP_REV_2_0)) {
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					1, 				/* counter */
+					h_total/2 - 1, 	/* run count */
+					DI_SYNC_CLK,		 /* run_resolution */
+					0, 				/* offset */
+					DI_SYNC_NONE, 	/* offset resolution */
+					0, 				/* repeat count */
+					DI_SYNC_NONE, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Field 1 VSYNC waveform */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					2, 				/* counter */
+					h_total - 1, 		/* run count */
+					DI_SYNC_CLK,		/* run_resolution */
+					0, 				/* offset */
+					DI_SYNC_NONE, 	/* offset resolution */
+					0, 				/* repeat count */
+					DI_SYNC_NONE, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					3, 				/* counter */
+					v_total*2 - 1, 	/* run count */
+					DI_SYNC_INT_HSYNC,	/* run_resolution */
+					1, 				/* offset */
+					DI_SYNC_INT_HSYNC, 	/* offset resolution */
+					0, 				/* repeat count */
+					DI_SYNC_NONE, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* Active Field ? */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					4, 				/* counter */
+					v_total/2 - 1, 	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					v_start_width, 	/*  offset */
+					DI_SYNC_HSYNC, 	/* offset resolution */
+					2, 				/* repeat count */
+					DI_SYNC_VSYNC, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Active Line */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					5, 				/* counter */
+					0, 				/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					0, 				/*  offset */
+					DI_SYNC_NONE, 	/* offset resolution */
+					height/2, 		/* repeat count */
+					4, 				/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* Field 0 VSYNC waveform */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					6, 				/* counter */
+					v_total - 1, 	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution */
+					0, 				/* offset */
+					DI_SYNC_NONE, 	/* offset resolution */
+					0, 				/* repeat count */
+					DI_SYNC_NONE, 	/* CNT_CLR_SEL  */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* DC VSYNC waveform */
+			vsync_cnt = 7;
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					7, 				/* counter */
+					v_total/2 - 1, 	/* run count */
+					DI_SYNC_HSYNC,	/* run_resolution  */
+					9, 				/* offset  */
+					DI_SYNC_HSYNC, 	/* offset resolution */
+					2, 				/* repeat count */
+					DI_SYNC_VSYNC, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					0				/* COUNT DOWN */
+					);
+
+			/* active pixel waveform */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					8, 				/* counter */
+					0, 	/* run count  */
+					DI_SYNC_CLK,	/* run_resolution */
+					h_start_width, 				/* offset  */
+					DI_SYNC_CLK, 	/* offset resolution */
+					width, 				/* repeat count  */
+					5, 	/* CNT_CLR_SEL  */
+					0, 				/* CNT_POLARITY_GEN_EN  */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL  */
+					0, 				/* COUNT UP  */
+					0				/* COUNT DOWN */
+					);
+
+			/* ??? */
+			_ipu_di_sync_config(
+					disp, 			/* display */
+					9, 				/* counter */
+					v_total - 1, 	/* run count */
+					DI_SYNC_INT_HSYNC,	/* run_resolution */
+					v_total/2, 			/* offset  */
+					DI_SYNC_INT_HSYNC, 	/* offset resolution  */
+					0, 				/* repeat count */
+					DI_SYNC_HSYNC, 	/* CNT_CLR_SEL */
+					0, 				/* CNT_POLARITY_GEN_EN  */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_CLR_SEL  */
+					DI_SYNC_NONE, 	/* CNT_POLARITY_TRIGGER_SEL */
+					0, 				/* COUNT UP */
+					4				/* COUNT DOWN */
+					);
+
+			/* set gentime select and tag sel */
+			reg = __raw_readl(DI_SW_GEN1(disp, 9));
+			reg &= 0x1FFFFFFF;
+			reg |= (3-1)<<29 | 0x00008000;
+			__raw_writel(reg, DI_SW_GEN1(disp, 9));
+
+			__raw_writel(v_total / 2 - 1, DI_SCR_CONF(disp));
+
+			/* set y_sel = 1 */
+			di_gen |= 0x10000000;
+			di_gen |= DI_GEN_POLARITY_5;
+			di_gen |= DI_GEN_POLARITY_8;
+		} else {
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			field1_offset = v_sync_width + v_start_width + height / 2 +
+				v_end_width;
+			if (sig.odd_field_first) {
+				field0_offset = field1_offset - 1;
+				field1_offset = 0;
+			}
+			v_total += v_start_width + v_end_width;
+
+			/* Field 1 VSYNC waveform */
+			_ipu_di_sync_config(disp, 2, v_total - 1, 1,
+					field0_offset,
+					field0_offset ? 1 : DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 0,
+					DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+			/* Setup internal HSYNC waveform */
+			_ipu_di_sync_config(disp, 3, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0,
+					DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+			/* Active Field ? */
+			_ipu_di_sync_config(disp, 4,
+					field0_offset ?
+					field0_offset : field1_offset - 2,
+					1, v_start_width + v_sync_width, 1, 2, 2,
+					0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+			/* Active Line */
+			_ipu_di_sync_config(disp, 5, 0, 1,
+					0, DI_SYNC_NONE,
+					height / 2, 4, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			/* Field 0 VSYNC waveform */
+			_ipu_di_sync_config(disp, 6, v_total - 1, 1,
+					0, DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			/* DC VSYNC waveform */
+			vsync_cnt = 7;
+			_ipu_di_sync_config(disp, 7, 0, 1,
+					field1_offset,
+					field1_offset ? 1 : DI_SYNC_NONE,
+					1, 2, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+			/* active pixel waveform */
+			_ipu_di_sync_config(disp, 8, 0, DI_SYNC_CLK,
+					h_sync_width + h_start_width, DI_SYNC_CLK,
+					width, 5, 0, DI_SYNC_NONE, DI_SYNC_NONE,
+					0, 0);
+
+			/* ??? */
+			_ipu_di_sync_config(disp, 9, v_total - 1, 2,
+					0, DI_SYNC_NONE,
+					0, DI_SYNC_NONE, 6, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+			reg = __raw_readl(DI_SW_GEN1(disp, 9));
+			reg |= 0x8000;
+			__raw_writel(reg, DI_SW_GEN1(disp, 9));
+
+			__raw_writel(v_sync_width + v_start_width +
+					v_end_width + height / 2 - 1, DI_SCR_CONF(disp));
+		}
+
+		/* Init template microcode */
+		_ipu_dc_write_tmpl(0, WROD(0), 0, map, SYNC_WAVE, 0, 8);
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+	} else {
+		/* Setup internal HSYNC waveform */
+		_ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
+					0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+					DI_SYNC_NONE, 0, 0);
+
+		/* Setup external (delayed) HSYNC waveform */
+		_ipu_di_sync_config(disp, DI_SYNC_HSYNC, h_total - 1,
+				    DI_SYNC_CLK, div * v_to_h_sync, DI_SYNC_CLK,
+				    0, DI_SYNC_NONE, 1, DI_SYNC_NONE,
+				    DI_SYNC_CLK, 0, h_sync_width * 2);
+		/* Setup VSYNC waveform */
+		vsync_cnt = DI_SYNC_VSYNC;
+		_ipu_di_sync_config(disp, DI_SYNC_VSYNC, v_total - 1,
+				    DI_SYNC_INT_HSYNC, 0, DI_SYNC_NONE, 0,
+				    DI_SYNC_NONE, 1, DI_SYNC_NONE,
+				    DI_SYNC_INT_HSYNC, 0, v_sync_width * 2);
+		__raw_writel(v_total - 1, DI_SCR_CONF(disp));
+
+		/* Setup active data waveform to sync with DC */
+		_ipu_di_sync_config(disp, 4, 0, DI_SYNC_HSYNC,
+				    v_start_width, DI_SYNC_HSYNC, height,
+				    DI_SYNC_VSYNC, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+		_ipu_di_sync_config(disp, 5, 0, DI_SYNC_CLK,
+				    h_sync_width + h_start_width, DI_SYNC_CLK,
+				    width, 4, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0,
+				    0);
+
+		/* Init template microcode */
+		_ipu_dc_write_tmpl(2, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+		_ipu_dc_write_tmpl(3, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+		_ipu_dc_write_tmpl(4, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+	}
+
+	__raw_writel(di_gen, DI_GENERAL(disp));
+	__raw_writel((--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,
+		     DI_SYNC_AS_GEN(disp));
+
+	reg = __raw_readl(DI_POL(disp));
+	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
+	if (sig.enable_pol)
+		reg |= DI_POL_DRDY_POLARITY_15;
+	if (sig.data_pol)
+		reg |= DI_POL_DRDY_DATA_POLARITY;
+	__raw_writel(reg, DI_POL(disp));
+
+	__raw_writel(width, DC_DISP_CONF2(DC_DISP_ID_SYNC(disp)));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_sync_panel);
+
+
+int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
+			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig)
+{
+	unsigned long lock_flags;
+	int map;
+	u32 ser_conf = 0;
+	u32 div;
+	u32 di_clk = clk_get_rate(g_ipu_clk);
+
+	/* round up cycle_time, then calcalate the divider using scaled math */
+	cycle_time += (1000000000UL / di_clk) - 1;
+	div = (cycle_time * (di_clk / 256UL)) / (1000000000UL / 256UL);
+
+	map = _ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (type == IPU_PANEL_SERIAL) {
+		__raw_writel((div << 24) | ((sig.ifc_width - 1) << 4),
+			     DI_DW_GEN(disp, ASYNC_SER_WAVE));
+
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_CS,
+					0, 0, (div * 2) + 1);
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_SER_CLK,
+					1, div, div * 2);
+		_ipu_di_data_pin_config(disp, ASYNC_SER_WAVE, DI_PIN_SER_RS,
+					2, 0, 0);
+
+		_ipu_dc_write_tmpl(0x64, WROD(0), 0, map, ASYNC_SER_WAVE, 0, 0);
+
+		/* Configure DC for serial panel */
+		__raw_writel(0x14, DC_DISP_CONF1(DC_DISP_ID_SERIAL));
+
+		if (sig.clk_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_CLK_POL;
+		if (sig.data_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_DATA_POL;
+		if (sig.rs_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_RS_POL;
+		if (sig.cs_pol)
+			ser_conf |= DI_SER_CONF_SERIAL_CS_POL;
+		__raw_writel(ser_conf, DI_SER_CONF(disp));
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_async_panel);
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes.
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		__raw_writel(reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	reg = __raw_readl(DP_COM_CONF(flow));
+	if ((reg & DP_COM_CONF_CSC_DEF_MASK) == DP_COM_CONF_CSC_DEF_BG) {
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(0, red, green, blue);
+		v = _rgb_to_yuv(0, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key);
+
+/*!
+ * This function sets the window position of the foreground or background plane.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       x_pos           The X coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @param       y_pos           The Y coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos)
+{
+	u32 reg;
+	unsigned long lock_flags;
+	uint32_t flow = 0;
+
+	if (channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel((x_pos << 16) | y_pos, DP_FG_POS(flow));
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_window_pos);
+
+void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset)
+{
+	if (channel == DIRECT_ASYNC0)
+		__raw_writel(value, ipu_disp_base[0] + offset);
+	else if (channel == DIRECT_ASYNC1)
+		__raw_writel(value, ipu_disp_base[1] + offset);
+}
+EXPORT_SYMBOL(ipu_disp_direct_write);
+
+void ipu_reset_disp_panel(void)
+{
+	uint32_t tmp;
+
+	tmp = __raw_readl(DI_GENERAL(1));
+	__raw_writel(tmp | 0x08, DI_GENERAL(1));
+	msleep(10); /* tRES >= 100us */
+	tmp = __raw_readl(DI_GENERAL(1));
+	__raw_writel(tmp & ~0x08, DI_GENERAL(1));
+	msleep(60);
+
+	return;
+}
+EXPORT_SYMBOL(ipu_reset_disp_panel);
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
new file mode 100644
index 0000000..5454dc0
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -0,0 +1,711 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_ic.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum {
+	IC_TASK_VIEWFINDER,
+	IC_TASK_ENCODER,
+	IC_TASK_POST_PROCESSOR
+};
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format, int csc_index);
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff);
+
+void ic_dump_register(void)
+{
+	printk(KERN_DEBUG "IC_CONF = \t0x%08X\n", __raw_readl(IC_CONF));
+	printk(KERN_DEBUG "IC_PRP_ENC_RSC = \t0x%08X\n",
+	       __raw_readl(IC_PRP_ENC_RSC));
+	printk(KERN_DEBUG "IC_PRP_VF_RSC = \t0x%08X\n",
+	       __raw_readl(IC_PRP_VF_RSC));
+	printk(KERN_DEBUG "IC_PP_RSC = \t0x%08X\n", __raw_readl(IC_PP_RSC));
+	printk(KERN_DEBUG "IC_IDMAC_1 = \t0x%08X\n", __raw_readl(IC_IDMAC_1));
+	printk(KERN_DEBUG "IC_IDMAC_2 = \t0x%08X\n", __raw_readl(IC_IDMAC_2));
+	printk(KERN_DEBUG "IC_IDMAC_3 = \t0x%08X\n", __raw_readl(IC_IDMAC_3));
+}
+
+void _ipu_ic_enable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf |= IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf |= IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_disable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_ROT_EN;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_height,
+			    params->mem_prp_vf_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
+			    params->mem_prp_vf_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_VF_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_prp_vf_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PRPVF_CMB;
+
+		if (!(ic_conf & IC_CONF_PRPVF_CSC1)) {
+			/* need transparent CSC1 conversion */
+			_init_csc(IC_TASK_VIEWFINDER, RGB, RGB, 1);
+			ic_conf |= IC_CONF_PRPVF_CSC1;  /* Enable RGB->RGB CSC */
+		}
+		in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_g_pixel_fmt);
+		out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+		if (in_fmt == RGB) {
+			if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+				/* Enable RGB->YCBCR CSC2 */
+				_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt, 2);
+				ic_conf |= IC_CONF_PRPVF_CSC2;
+			}
+		}
+		if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+			if (out_fmt == RGB) {
+				/* Enable YCBCR->RGB CSC2 */
+				_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB, 2);
+				ic_conf |= IC_CONF_PRPVF_CSC2;
+			} else {
+				/* TODO: Support YUV<->YCbCr conversion? */
+			}
+		}
+
+		if (params->mem_prp_vf_mem.global_alpha_en) {
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+			reg = __raw_readl(IC_CMBP_1);
+			reg &= ~(0xff);
+			reg |= params->mem_prp_vf_mem.alpha;
+			__raw_writel(reg, IC_CMBP_1);
+		} else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_prp_vf_mem.key_color_en) {
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+			__raw_writel(params->mem_prp_vf_mem.key_color,
+					IC_CMBP_2);
+		} else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PRPVF_CMB;
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpvf(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPVF_EN | IC_CONF_PRPVF_CMB |
+		 IC_CONF_PRPVF_CSC2 | IC_CONF_PRPVF_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_vf(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PRPVF_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_height,
+			    params->mem_prp_enc_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
+			    params->mem_prp_enc_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_ENC_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_enc_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_enc_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_ENCODER, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_ENCODER, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpenc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_enc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_ROT_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_pp(ipu_channel_params_t *params)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_height,
+			    params->mem_pp_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_width,
+			    params->mem_pp_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PP_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_pp_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC1 */
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt, 1);
+			ic_conf |= IC_CONF_PP_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC1 */
+			_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB, 1);
+			ic_conf |= IC_CONF_PP_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_pp_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PP_CMB;
+
+		if (!(ic_conf & IC_CONF_PP_CSC1)) {
+			/* need transparent CSC1 conversion */
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB, 1);
+			ic_conf |= IC_CONF_PP_CSC1;  /* Enable RGB->RGB CSC */
+		}
+
+		in_fmt = format_to_colorspace(params->mem_pp_mem.in_g_pixel_fmt);
+		out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+		if (in_fmt == RGB) {
+			if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+				/* Enable RGB->YCBCR CSC2 */
+				_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt, 2);
+				ic_conf |= IC_CONF_PP_CSC2;
+			}
+		}
+		if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+			if (out_fmt == RGB) {
+				/* Enable YCBCR->RGB CSC2 */
+				_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB, 2);
+				ic_conf |= IC_CONF_PP_CSC2;
+			} else {
+				/* TODO: Support YUV<->YCbCr conversion? */
+			}
+		}
+
+		if (params->mem_pp_mem.global_alpha_en) {
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+			reg = __raw_readl(IC_CMBP_1);
+			reg &= ~(0xff00);
+			reg |= (params->mem_pp_mem.alpha << 8);
+			__raw_writel(reg, IC_CMBP_1);
+		} else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_pp_mem.key_color_en) {
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+			__raw_writel(params->mem_pp_mem.key_color,
+					IC_CMBP_2);
+		} else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PP_CMB;
+	}
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_pp(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PP_EN | IC_CONF_PP_CSC1 | IC_CONF_PP_CSC2 |
+		 IC_CONF_PP_CMB);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_pp(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PP_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot)
+{
+	u32 ic_idmac_1, ic_idmac_2, ic_idmac_3;
+	u32 temp_rot = bitrev8(rot) >> 5;
+	bool need_hor_flip = false;
+
+	if ((burst_size != 8) && (burst_size != 16)) {
+		dev_dbg(g_ipu_dev, "Illegal burst length for IC\n");
+		return -EINVAL;
+	}
+
+	width--;
+	height--;
+
+	if (temp_rot & 0x2)	/* Need horizontal flip */
+		need_hor_flip = true;
+
+	ic_idmac_1 = __raw_readl(IC_IDMAC_1);
+	ic_idmac_2 = __raw_readl(IC_IDMAC_2);
+	ic_idmac_3 = __raw_readl(IC_IDMAC_3);
+	if (dma_chan == 22) {	/* PP output - CB2 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;
+
+	} else if (dma_chan == 11) {	/* PP Input - CB5 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;
+	} else if (dma_chan == 47) {	/* PP Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;
+	}
+
+	if (dma_chan == 12) {	/* PRP Input - CB6 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;
+	}
+
+	if (dma_chan == 20) {	/* PRP ENC output - CB0 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;
+
+	} else if (dma_chan == 45) {	/* PRP ENC Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;
+	}
+
+	if (dma_chan == 21) {	/* PRP VF output - CB1 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;
+
+	} else if (dma_chan == 46) {	/* PRP VF Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;
+	}
+
+	if (dma_chan == 14) {	/* PRP VF graphics combining input - CB3 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;
+	} else if (dma_chan == 15) {	/* PP graphics combining input - CB4 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;
+	}
+
+	__raw_writel(ic_idmac_1, IC_IDMAC_1);
+	__raw_writel(ic_idmac_2, IC_IDMAC_2);
+	__raw_writel(ic_idmac_3, IC_IDMAC_3);
+
+	return 0;
+}
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format, int csc_index)
+{
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+	static const uint32_t rgb2ycbcr_coeff[4][3] = {
+		{0x004D, 0x0096, 0x001D},
+		{0x01D5, 0x01AB, 0x0080},
+		{0x0080, 0x0195, 0x01EB},
+		{0x0000, 0x0200, 0x0200},	/* A0, A1, A2 */
+	};
+
+	/* transparent RGB->RGB matrix for combining
+	 */
+	static const uint32_t rgb2rgb_coeff[4][3] = {
+		{0x0080, 0x0000, 0x0000},
+		{0x0000, 0x0080, 0x0000},
+		{0x0000, 0x0000, 0x0080},
+		{0x0000, 0x0000, 0x0000},	/* A0, A1, A2 */
+	};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+	static const uint32_t ycbcr2rgb_coeff[4][3] = {
+		{149, 0, 204},
+		{149, 462, 408},
+		{149, 255, 0},
+		{8192 - 446, 266, 8192 - 554},	/* A0, A1, A2 */
+	};
+
+	uint32_t param;
+	uint32_t *base = NULL;
+
+	if (ic_task == IC_TASK_ENCODER) {
+		base = ipu_tpmem_base + 0x2008 / 4;
+	} else if (ic_task == IC_TASK_VIEWFINDER) {
+		if (csc_index == 1)
+			base = ipu_tpmem_base + 0x4028 / 4;
+		else
+			base = ipu_tpmem_base + 0x4040 / 4;
+	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+		if (csc_index == 1)
+			base = ipu_tpmem_base + 0x6060 / 4;
+		else
+			base = ipu_tpmem_base + 0x6078 / 4;
+	} else {
+		BUG();
+	}
+
+	if ((in_format == YCbCr) && (out_format == RGB)) {
+		/* Init CSC (YCbCr->RGB) */
+		param = (ycbcr2rgb_coeff[3][0] << 27) |
+			(ycbcr2rgb_coeff[0][0] << 18) |
+			(ycbcr2rgb_coeff[1][1] << 9) | ycbcr2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (ycbcr2rgb_coeff[3][0] >> 5) | (2L << (40 - 32));
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][1] << 27) |
+			(ycbcr2rgb_coeff[0][1] << 18) |
+			(ycbcr2rgb_coeff[1][0] << 9) | ycbcr2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][2] << 27) |
+			(ycbcr2rgb_coeff[0][2] << 18) |
+			(ycbcr2rgb_coeff[1][2] << 9) | ycbcr2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == YCbCr)) {
+		/* Init CSC (RGB->YCbCr) */
+		param = (rgb2ycbcr_coeff[3][0] << 27) |
+			(rgb2ycbcr_coeff[0][0] << 18) |
+			(rgb2ycbcr_coeff[1][1] << 9) | rgb2ycbcr_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 1, sat = 0 */
+		param = (rgb2ycbcr_coeff[3][0] >> 5) | (1UL << 8);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][1] << 27) |
+			(rgb2ycbcr_coeff[0][1] << 18) |
+			(rgb2ycbcr_coeff[1][0] << 9) | rgb2ycbcr_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][2] << 27) |
+			(rgb2ycbcr_coeff[0][2] << 18) |
+			(rgb2ycbcr_coeff[1][2] << 9) | rgb2ycbcr_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == RGB)) {
+		/* Init CSC */
+		param =
+		    (rgb2rgb_coeff[3][0] << 27) | (rgb2rgb_coeff[0][0] << 18) |
+		    (rgb2rgb_coeff[1][1] << 9) | rgb2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (rgb2rgb_coeff[3][0] >> 5) | (2UL << 8);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][1] << 27) | (rgb2rgb_coeff[0][1] << 18) |
+		    (rgb2rgb_coeff[1][0] << 9) | rgb2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][2] << 27) | (rgb2rgb_coeff[0][2] << 18) |
+		    (rgb2rgb_coeff[1][2] << 9) | rgb2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else {
+		dev_err(g_ipu_dev, "Unsupported color space conversion\n");
+	}
+}
+
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff)
+{
+	uint32_t tempSize;
+	uint32_t tempDownsize;
+
+	/* Input size cannot be more than 4096 */
+	/* Output size cannot be more than 1024 */
+	if ((inSize > 4096) || (outSize > 1024))
+		return false;
+
+	/* Cannot downsize more than 8:1 */
+	if ((outSize << 3) < inSize)
+		return false;
+
+	/* Compute downsizing coefficient */
+	/* Output of downsizing unit cannot be more than 1024 */
+	tempDownsize = 0;
+	tempSize = inSize;
+	while (((tempSize > 1024) || (tempSize >= outSize * 2)) &&
+	       (tempDownsize < 2)) {
+		tempSize >>= 1;
+		tempDownsize++;
+	}
+	*downsizeCoeff = tempDownsize;
+
+	/* compute resizing coefficient using the following equation:
+	   resizeCoeff = M*(SI -1)/(SO - 1)
+	   where M = 2^13, SI - input size, SO - output size    */
+	*resizeCoeff = (8192L * (tempSize - 1)) / (outSize - 1);
+	if (*resizeCoeff >= 16384L) {
+		dev_err(g_ipu_dev, "Warning! Overflow on resize coeff.\n");
+		*resizeCoeff = 0x3FFF;
+	}
+
+	dev_dbg(g_ipu_dev, "resizing from %u -> %u pixels, "
+		"downsize=%u, resize=%u.%lu (reg=%u)\n", inSize, outSize,
+		*downsizeCoeff, (*resizeCoeff >= 8192L) ? 1 : 0,
+		((*resizeCoeff & 0x1FFF) * 10000L) / 8192L, *resizeCoeff);
+
+	return true;
+}
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
new file mode 100644
index 0000000..535f66a
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -0,0 +1,332 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PARAM_MEM_H__
+#define __INCLUDE_IPU_PARAM_MEM_H__
+
+#include <linux/types.h>
+#include <linux/bitrev.h>
+
+extern u32 *ipu_cpmem_base;
+
+struct ipu_ch_param_word {
+	uint32_t data[5];
+	uint32_t res[3];
+};
+
+struct ipu_ch_param {
+	struct ipu_ch_param_word word[2];
+};
+
+#define ipu_ch_param_addr(ch) (((struct ipu_ch_param *)ipu_cpmem_base) + (ch))
+
+#define _param_word(base, w) \
+	(((struct ipu_ch_param *)(base))->word[(w)].data)
+
+#define ipu_ch_param_set_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	_param_word(base, w)[i] |= (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		_param_word(base, w)[i + 1] |= (v) >> (off ? (32 - off) : 0); \
+	} \
+}
+
+#define ipu_ch_param_mod_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp = _param_word(base, w)[i]; \
+	temp &= ~(mask << off); \
+	_param_word(base, w)[i] = temp | (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp = _param_word(base, w)[i + 1]; \
+		temp &= ~(mask >> (32 - off)); \
+		_param_word(base, w)[i + 1] = \
+			temp | ((v) >> (off ? (32 - off) : 0)); \
+	} \
+}
+
+#define ipu_ch_param_read_field(base, w, bit, size) ({ \
+	u32 temp2; \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp1 = _param_word(base, w)[i]; \
+	temp1 = mask & (temp1 >> off); \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp2 = _param_word(base, w)[i + 1]; \
+		temp2 &= mask >> (off ? (32 - off) : 0); \
+		temp1 |= temp2 << (off ? (32 - off) : 0); \
+	} \
+	temp1; \
+})
+
+static inline void _ipu_ch_params_set_packing(struct ipu_ch_param *p,
+					      int red_width, int red_offset,
+					      int green_width, int green_offset,
+					      int blue_width, int blue_offset,
+					      int alpha_width, int alpha_offset)
+{
+	/* Setup red width and offset */
+	ipu_ch_param_set_field(p, 1, 116, 3, red_width - 1);
+	ipu_ch_param_set_field(p, 1, 128, 5, red_offset);
+	/* Setup green width and offset */
+	ipu_ch_param_set_field(p, 1, 119, 3, green_width - 1);
+	ipu_ch_param_set_field(p, 1, 133, 5, green_offset);
+	/* Setup blue width and offset */
+	ipu_ch_param_set_field(p, 1, 122, 3, blue_width - 1);
+	ipu_ch_param_set_field(p, 1, 138, 5, blue_offset);
+	/* Setup alpha width and offset */
+	ipu_ch_param_set_field(p, 1, 125, 3, alpha_width - 1);
+	ipu_ch_param_set_field(p, 1, 143, 5, alpha_offset);
+}
+
+static inline void _ipu_ch_param_dump(int ch)
+{
+	struct ipu_ch_param *p = ipu_ch_param_addr(ch);
+	pr_debug("ch %d word 0 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[0].data[0], p->word[0].data[1], p->word[0].data[2],
+		 p->word[0].data[3], p->word[0].data[4]);
+	pr_debug("ch %d word 1 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[1].data[0], p->word[1].data[1], p->word[1].data[2],
+		 p->word[1].data[3], p->word[1].data[4]);
+	pr_debug("PFS 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 85, 4));
+	pr_debug("BPP 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 107, 3));
+	pr_debug("NPB 0x%x\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7));
+
+	pr_debug("FW %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 125, 13));
+	pr_debug("FH %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 138, 12));
+	pr_debug("Stride %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14));
+
+	pr_debug("Width0 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 116, 3));
+	pr_debug("Width1 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 119, 3));
+	pr_debug("Width2 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 122, 3));
+	pr_debug("Width3 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 125, 3));
+	pr_debug("Offset0 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 128, 5));
+	pr_debug("Offset1 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 133, 5));
+	pr_debug("Offset2 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 138, 5));
+	pr_debug("Offset3 %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 143, 5));
+}
+
+static inline void _ipu_ch_param_init(int ch,
+				      uint32_t pixel_fmt, uint32_t width,
+				      uint32_t height, uint32_t stride,
+				      uint32_t u, uint32_t v,
+				      uint32_t uv_stride, dma_addr_t addr0,
+				      dma_addr_t addr1)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	struct ipu_ch_param params;
+
+	memset(&params, 0, sizeof(params));
+
+	ipu_ch_param_set_field(&params, 0, 125, 13, width - 1);
+	ipu_ch_param_set_field(&params, 0, 138, 12, height - 1);
+	ipu_ch_param_set_field(&params, 1, 102, 14, stride - 1);
+
+	ipu_ch_param_set_field(&params, 1, 0, 29, addr0 >> 3);
+	ipu_ch_param_set_field(&params, 1, 29, 29, addr1 >> 3);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/*Represents 8-bit Generic data */
+		ipu_ch_param_set_field(&params, 0, 107, 3, 5);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 63);	/* burst size */
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/*Represents 32-bit Generic data */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 5, 0, 6, 5, 5, 11, 1, 16);
+		break;
+	case IPU_PIX_FMT_BGR24:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 1, 24);
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 16, 8, 8, 8, 0, 1, 24);
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 8, 8, 16, 8, 24, 8, 0);
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 24, 8, 16, 8, 8, 8, 0);
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 8, 24);
+		break;
+	case IPU_PIX_FMT_UYVY:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0xA);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUYV:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0x8);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		ipu_ch_param_set_field(&params, 1, 85, 4, 2);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + (uv_stride * height / 2) : v;
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	case IPU_PIX_FMT_NV12:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 4);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		uv_stride = stride;
+		u_offset = (u == 0) ? stride * height : u;
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+
+	if (uv_stride)
+		ipu_ch_param_set_field(&params, 1, 128, 14, uv_stride - 1);
+
+	if (u > u_offset)
+		u_offset = u;
+
+	if (v > v_offset)
+		v_offset = v;
+
+	ipu_ch_param_set_field(&params, 0, 46, 22, u_offset / 8);
+	ipu_ch_param_set_field(&params, 0, 68, 22, v_offset / 8);
+
+	pr_debug("initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ch));
+	memcpy(ipu_ch_param_addr(ch), &params, sizeof(params));
+};
+
+static inline void _ipu_ch_param_set_burst_size(uint32_t ch,
+						uint16_t burst_pixels)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 78, 7,
+			       burst_pixels - 1);
+};
+
+static inline int _ipu_ch_param_get_burst_size(uint32_t ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7) + 1;
+};
+
+static inline int _ipu_ch_param_get_bpp(uint32_t ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 107, 3);
+};
+
+static inline void _ipu_ch_param_set_buffer(uint32_t ch, int bufNum,
+					    dma_addr_t phyaddr)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 29 * bufNum, 29,
+			       phyaddr / 8);
+};
+
+static inline void _ipu_ch_param_set_rotation(uint32_t ch,
+					      ipu_rotate_mode_t rot)
+{
+	u32 temp_rot = bitrev8(rot) >> 5;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 119, 3, temp_rot);
+};
+
+static inline void _ipu_ch_param_set_block_mode(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 117, 2, 1);
+};
+
+static inline void _ipu_ch_param_set_interlaced_scan(uint32_t ch)
+{
+	u32 stride;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), 0, 113, 1, 1);
+	stride = ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14) + 1;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 58, 20, stride / 8);
+	stride *= 2;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 102, 14, stride - 1);
+};
+
+static inline void _ipu_ch_param_set_high_priority(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 93, 2, 1);
+};
+
+#endif
diff --git a/drivers/mxc/ipu3/ipu_prv.h b/drivers/mxc/ipu3/ipu_prv.h
new file mode 100644
index 0000000..c54315f
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_prv.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PRV_H__
+#define __INCLUDE_IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+
+/* Globals */
+extern struct device *g_ipu_dev;
+extern spinlock_t ipu_lock;
+extern bool g_ipu_clk_enabled;
+extern struct clk *g_ipu_clk;
+extern struct clk *g_di_clk[2];
+extern struct clk *g_csi_clk[2];
+extern unsigned char g_dc_di_assignment[];
+extern int g_ipu_hw_rev;
+
+#define IDMA_CHAN_INVALID	0xFF
+
+struct ipu_channel {
+	u8 video_in_dma;
+	u8 alpha_in_dma;
+	u8 graph_in_dma;
+	u8 out_dma;
+};
+
+int register_ipu_device(void);
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+
+void ipu_dump_registers(void);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel);
+
+void _ipu_init_dc_mappings(void);
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt);
+void _ipu_dp_uninit(ipu_channel_t channel);
+void _ipu_dc_init(int dc_chan, int di, bool interlaced);
+void _ipu_dc_uninit(int dc_chan);
+void _ipu_dp_dc_enable(ipu_channel_t channel);
+void _ipu_dp_dc_disable(ipu_channel_t channel);
+void _ipu_dmfc_init(void);
+void _ipu_dmfc_set_wait4eot(int dma_chan, int width);
+int _ipu_chan_is_interlaced(ipu_channel_t channel);
+
+void _ipu_ic_enable_task(ipu_channel_t channel);
+void _ipu_ic_disable_task(ipu_channel_t channel);
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpvf(void);
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_vf(void);
+void _ipu_ic_init_csi(ipu_channel_params_t *params);
+void _ipu_ic_uninit_csi(void);
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpenc(void);
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_enc(void);
+void _ipu_ic_init_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_pp(void);
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_pp(void);
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot);
+int _ipu_csi_init(ipu_channel_t channel, uint32_t csi);
+void ipu_csi_set_test_generator(bool active, uint32_t r_value,
+		uint32_t g_value, uint32_t b_value,
+		uint32_t pix_clk, uint32_t csi);
+void _ipu_csi_ccir_err_detection_enable(uint32_t csi);
+void _ipu_csi_ccir_err_detection_disable(uint32_t csi);
+void _ipu_smfc_init(ipu_channel_t channel, uint32_t mipi_id, uint32_t csi);
+void _ipu_smfc_set_burst_size(ipu_channel_t channel, uint32_t bs);
+void _ipu_dp_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
+
+#endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu3/ipu_regs.h b/drivers/mxc/ipu3/ipu_regs.h
new file mode 100644
index 0000000..4723c22
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_regs.h
@@ -0,0 +1,625 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_regs.h
+ *
+ * @brief IPU Register definitions
+ *
+ * @ingroup IPU
+ */
+#ifndef __IPU_REGS_INCLUDED__
+#define __IPU_REGS_INCLUDED__
+
+#define IPU_DISP0_BASE		0x00000000
+#define IPU_MCU_T_DEFAULT	8
+#define IPU_DISP1_BASE		(IPU_MCU_T_DEFAULT << 25)
+#define IPU_CM_REG_BASE		0x1E000000
+#define IPU_IDMAC_REG_BASE	0x1E008000
+#define IPU_ISP_REG_BASE	0x1E010000
+#define IPU_DP_REG_BASE		0x1E018000
+#define IPU_IC_REG_BASE		0x1E020000
+#define IPU_IRT_REG_BASE	0x1E028000
+#define IPU_CSI0_REG_BASE	0x1E030000
+#define IPU_CSI1_REG_BASE	0x1E038000
+#define IPU_DI0_REG_BASE	0x1E040000
+#define IPU_DI1_REG_BASE	0x1E048000
+#define IPU_SMFC_REG_BASE	0x1E050000
+#define IPU_DC_REG_BASE		0x1E058000
+#define IPU_DMFC_REG_BASE	0x1E060000
+#define IPU_CPMEM_REG_BASE	0x1F000000
+#define IPU_LUT_REG_BASE	0x1F020000
+#define IPU_SRM_REG_BASE	0x1F040000
+#define IPU_TPM_REG_BASE	0x1F060000
+#define IPU_DC_TMPL_REG_BASE	0x1F080000
+#define IPU_ISP_TBPR_REG_BASE	0x1F0C0000
+
+extern u32 *ipu_cm_reg;
+extern u32 *ipu_idmac_reg;
+extern u32 *ipu_dp_reg;
+extern u32 *ipu_ic_reg;
+extern u32 *ipu_dc_reg;
+extern u32 *ipu_dc_tmpl_reg;
+extern u32 *ipu_dmfc_reg;
+extern u32 *ipu_di_reg[];
+extern u32 *ipu_smfc_reg;
+extern u32 *ipu_csi_reg[];
+extern u32 *ipu_tpmem_base;
+extern u32 *ipu_disp_base[];
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CONF		(ipu_cm_reg)
+
+#define IPU_SRM_PRI1		(ipu_cm_reg + 0x00A0/4)
+#define IPU_SRM_PRI2		(ipu_cm_reg + 0x00A4/4)
+#define IPU_FS_PROC_FLOW1	(ipu_cm_reg + 0x00A8/4)
+#define IPU_FS_PROC_FLOW2	(ipu_cm_reg + 0x00AC/4)
+#define IPU_FS_PROC_FLOW3	(ipu_cm_reg + 0x00B0/4)
+#define IPU_FS_DISP_FLOW1	(ipu_cm_reg + 0x00B4/4)
+#define IPU_FS_DISP_FLOW2	(ipu_cm_reg + 0x00B8/4)
+#define IPU_SKIP		(ipu_cm_reg + 0x00BC/4)
+#define IPU_DISP_ALT_CONF	(ipu_cm_reg + 0x00C0/4)
+#define IPU_DISP_GEN		(ipu_cm_reg + 0x00C4/4)
+#define IPU_DISP_ALT1		(ipu_cm_reg + 0x00C8/4)
+#define IPU_DISP_ALT2		(ipu_cm_reg + 0x00CC/4)
+#define IPU_DISP_ALT3		(ipu_cm_reg + 0x00D0/4)
+#define IPU_DISP_ALT4		(ipu_cm_reg + 0x00D4/4)
+#define IPU_SNOOP		(ipu_cm_reg + 0x00D8/4)
+#define IPU_MEM_RST		(ipu_cm_reg + 0x00DC/4)
+#define IPU_PM			(ipu_cm_reg + 0x00E0/4)
+#define IPU_GPR			(ipu_cm_reg + 0x00E4/4)
+#define IPU_CHA_DB_MODE_SEL(ch)	(ipu_cm_reg + 0x0150/4 + (ch / 32))
+#define IPU_ALT_CHA_DB_MODE_SEL(ch) (ipu_cm_reg + 0x0168/4 + (ch / 32))
+#define IPU_CHA_CUR_BUF(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x023C/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0124/4 + (ch / 32)); })
+#define IPU_ALT_CUR_BUF0	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0244/4) : \
+				  (ipu_cm_reg + 0x012C/4); })
+#define IPU_ALT_CUR_BUF1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0248/4) : \
+				  (ipu_cm_reg + 0x0130/4); })
+#define IPU_SRM_STAT		({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x024C/4) : \
+				  (ipu_cm_reg + 0x0134/4); })
+#define IPU_PROC_TASK_STAT	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0250/4) : \
+				  (ipu_cm_reg + 0x0138/4); })
+#define IPU_DISP_TASK_STAT	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0254/4) : \
+				  (ipu_cm_reg + 0x013C/4); })
+#define IPU_CHA_BUF0_RDY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0268/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0140/4 + (ch / 32)); })
+#define IPU_CHA_BUF1_RDY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0270/4 + (ch / 32)) : \
+				  (ipu_cm_reg + 0x0148/4 + (ch / 32)); })
+#define IPU_ALT_CHA_BUF0_RDY(ch) ({g_ipu_hw_rev == 2 ? \
+				   (ipu_cm_reg + 0x0278/4 + (ch / 32)) : \
+				   (ipu_cm_reg + 0x0158/4 + (ch / 32)); })
+#define IPU_ALT_CHA_BUF1_RDY(ch) ({g_ipu_hw_rev == 2 ? \
+				   (ipu_cm_reg + 0x0280/4 + (ch / 32)) : \
+				   (ipu_cm_reg + 0x0160/4 + (ch / 32)); })
+
+#define IPU_INT_CTRL(n)		(ipu_cm_reg + 0x003C/4 + ((n) - 1))
+#define IPU_INT_CTRL_IRQ(irq)	IPU_INT_CTRL(((irq) / 32))
+#define IPU_INT_STAT_IRQ(irq)	IPU_INT_STAT(((irq) / 32))
+#define IPU_INT_STAT(n)		({g_ipu_hw_rev == 2 ? \
+				  (ipu_cm_reg + 0x0200/4 + ((n) - 1)) : \
+				  (ipu_cm_reg + 0x00E8/4 + ((n) - 1)); })
+
+#define IPUIRQ_2_STATREG(irq)	(IPU_INT_STAT(1) + ((irq) / 32))
+#define IPUIRQ_2_CTRLREG(irq)	(IPU_INT_CTRL(1) + ((irq) / 32))
+#define IPUIRQ_2_MASK(irq)	(1UL << ((irq) & 0x1F))
+
+/* CMOS Sensor Interface Registers */
+#define CSI_SENS_CONF(csi)	(ipu_csi_reg[csi])
+#define CSI_SENS_FRM_SIZE(csi)	(ipu_csi_reg[csi] + 0x0004/4)
+#define CSI_ACT_FRM_SIZE(csi)	(ipu_csi_reg[csi] + 0x0008/4)
+#define CSI_OUT_FRM_CTRL(csi)	(ipu_csi_reg[csi] + 0x000C/4)
+#define CSI_TST_CTRL(csi)	(ipu_csi_reg[csi] + 0x0010/4)
+#define CSI_CCIR_CODE_1(csi)	(ipu_csi_reg[csi] + 0x0014/4)
+#define CSI_CCIR_CODE_2(csi)	(ipu_csi_reg[csi] + 0x0018/4)
+#define CSI_CCIR_CODE_3(csi)	(ipu_csi_reg[csi] + 0x001C/4)
+#define CSI_MIPI_DI(csi)	(ipu_csi_reg[csi] + 0x0020/4)
+#define CSI_SKIP(csi)		(ipu_csi_reg[csi] + 0x0024/4)
+#define CSI_CPD_CTRL(csi)	(ipu_csi_reg[csi] + 0x0028/4)
+#define CSI_CPD_RC(csi, n)	(ipu_csi_reg[csi] + 0x002C/4 + n)
+#define CSI_CPD_RS(csi, n)	(ipu_csi_reg[csi] + 0x004C/4 + n)
+#define CSI_CPD_GRC(csi, n)	(ipu_csi_reg[csi] + 0x005C/4 + n)
+#define CSI_CPD_GRS(csi, n)	(ipu_csi_reg[csi] + 0x007C/4 + n)
+#define CSI_CPD_GBC(csi, n)	(ipu_csi_reg[csi] + 0x008C/4 + n)
+#define CSI_CPD_GBS(csi, n)	(ipu_csi_reg[csi] + 0x00AC/4 + n)
+#define CSI_CPD_BC(csi, n)	(ipu_csi_reg[csi] + 0x00BC/4 + n)
+#define CSI_CPD_BS(csi, n)	(ipu_csi_reg[csi] + 0x00DC/4 + n)
+#define CSI_CPD_OFFSET1(csi)	(ipu_csi_reg[csi] + 0x00EC/4)
+#define CSI_CPD_OFFSET2(csi)	(ipu_csi_reg[csi] + 0x00F0/4)
+
+/*SMFC Registers */
+#define SMFC_MAP	(ipu_smfc_reg)
+#define SMFC_WMC	(ipu_smfc_reg + 0x0004/4)
+#define SMFC_BS		(ipu_smfc_reg + 0x0008/4)
+
+/* Image Converter Registers */
+#define IC_CONF			(ipu_ic_reg)
+#define IC_PRP_ENC_RSC		(ipu_ic_reg + 0x0004/4)
+#define IC_PRP_VF_RSC		(ipu_ic_reg + 0x0008/4)
+#define IC_PP_RSC		(ipu_ic_reg + 0x000C/4)
+#define IC_CMBP_1		(ipu_ic_reg + 0x0010/4)
+#define IC_CMBP_2		(ipu_ic_reg + 0x0014/4)
+#define IC_IDMAC_1		(ipu_ic_reg + 0x0018/4)
+#define IC_IDMAC_2		(ipu_ic_reg + 0x001C/4)
+#define IC_IDMAC_3		(ipu_ic_reg + 0x0020/4)
+#define IC_IDMAC_4		(ipu_ic_reg + 0x0024/4)
+
+#define IDMAC_CONF		(ipu_idmac_reg + 0x0000)
+#define IDMAC_CHA_EN(ch)	(ipu_idmac_reg + 0x0004/4 + (ch/32))
+#define IDMAC_SEP_ALPHA		(ipu_idmac_reg + 0x000C/4)
+#define IDMAC_ALT_SEP_ALPHA	(ipu_idmac_reg + 0x0010/4)
+#define IDMAC_CHA_PRI(ch)	(ipu_idmac_reg + 0x0014/4 + (ch/32))
+#define IDMAC_WM_EN(ch)		(ipu_idmac_reg + 0x001C/4 + (ch/32))
+#define IDMAC_CH_LOCK_EN_1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0024/4) : 0; })
+#define IDMAC_CH_LOCK_EN_2	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0028/4) : \
+				  (ipu_idmac_reg + 0x0024/4); })
+#define IDMAC_SUB_ADDR_0	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x002C/4) : \
+				  (ipu_idmac_reg + 0x0028/4); })
+#define IDMAC_SUB_ADDR_1	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0030/4) : \
+				  (ipu_idmac_reg + 0x002C/4); })
+#define IDMAC_SUB_ADDR_2	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0034/4) : \
+				  (ipu_idmac_reg + 0x0030/4); })
+#define IDMAC_BAND_EN(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0040/4 + (ch/32)) : \
+				  (ipu_idmac_reg + 0x0034/4 + (ch/32)); })
+#define IDMAC_CHA_BUSY(ch)	({g_ipu_hw_rev == 2 ? \
+				  (ipu_idmac_reg + 0x0100/4 + (ch/32)) : \
+				  (ipu_idmac_reg + 0x0040/4 + (ch/32)); })
+
+#define DI_GENERAL(di)		(ipu_di_reg[di])
+#define DI_BS_CLKGEN0(di)	(ipu_di_reg[di] + 0x0004/4)
+#define DI_BS_CLKGEN1(di)	(ipu_di_reg[di] + 0x0008/4)
+
+#define DI_SW_GEN0(di, gen)	(ipu_di_reg[di] + 0x000C/4 + (gen - 1))
+#define DI_SW_GEN1(di, gen)	(ipu_di_reg[di] + 0x0030/4 + (gen - 1))
+#define DI_STP_REP(di, gen)	(ipu_di_reg[di] + 0x0148/4 + (gen - 1)/2)
+#define DI_SYNC_AS_GEN(di)	(ipu_di_reg[di] + 0x0054/4)
+#define DI_DW_GEN(di, gen)	(ipu_di_reg[di] + 0x0058/4 + gen)
+#define DI_DW_SET(di, gen, set)	(ipu_di_reg[di] + 0x0088/4 + gen + 0xC*set)
+#define DI_SER_CONF(di)		(ipu_di_reg[di] + 0x015C/4)
+#define DI_SSC(di)		(ipu_di_reg[di] + 0x0160/4)
+#define DI_POL(di)		(ipu_di_reg[di] + 0x0164/4)
+#define DI_AW0(di)		(ipu_di_reg[di] + 0x0168/4)
+#define DI_AW1(di)		(ipu_di_reg[di] + 0x016C/4)
+#define DI_SCR_CONF(di)		(ipu_di_reg[di] + 0x0170/4)
+#define DI_STAT(di)		(ipu_di_reg[di] + 0x0174/4)
+
+#define DMFC_RD_CHAN		(ipu_dmfc_reg)
+#define DMFC_WR_CHAN		(ipu_dmfc_reg + 0x0004/4)
+#define DMFC_WR_CHAN_DEF	(ipu_dmfc_reg + 0x0008/4)
+#define DMFC_DP_CHAN		(ipu_dmfc_reg + 0x000C/4)
+#define DMFC_DP_CHAN_DEF	(ipu_dmfc_reg + 0x0010/4)
+#define DMFC_GENERAL1		(ipu_dmfc_reg + 0x0014/4)
+#define DMFC_GENERAL2		(ipu_dmfc_reg + 0x0018/4)
+#define DMFC_IC_CTRL		(ipu_dmfc_reg + 0x001C/4)
+
+#define DC_MAP_CONF_PTR(n)	(ipu_dc_reg + 0x0108/4 + n/2)
+#define DC_MAP_CONF_VAL(n)	(ipu_dc_reg + 0x0144/4 + n/2)
+
+#define _RL_CH_2_OFFSET(ch)	((ch == 0) ? 8 : ( \
+				 (ch == 1) ? 0x24 : ( \
+				 (ch == 2) ? 0x40 : ( \
+				 (ch == 5) ? 0x64 : ( \
+				 (ch == 6) ? 0x80 : ( \
+				 (ch == 8) ? 0x9C : ( \
+				 (ch == 9) ? 0xBC : (-1))))))))
+#define DC_RL_CH(ch, evt)	(ipu_dc_reg + _RL_CH_2_OFFSET(ch)/4 + evt/2)
+
+#define DC_EVT_NF		0
+#define DC_EVT_NL		1
+#define DC_EVT_EOF		2
+#define DC_EVT_NFIELD		3
+#define DC_EVT_EOL		4
+#define DC_EVT_EOFIELD		5
+#define DC_EVT_NEW_ADDR		6
+#define DC_EVT_NEW_CHAN		7
+#define DC_EVT_NEW_DATA		8
+
+#define DC_EVT_NEW_ADDR_W_0	0
+#define DC_EVT_NEW_ADDR_W_1	1
+#define DC_EVT_NEW_CHAN_W_0	2
+#define DC_EVT_NEW_CHAN_W_1	3
+#define DC_EVT_NEW_DATA_W_0	4
+#define DC_EVT_NEW_DATA_W_1	5
+#define DC_EVT_NEW_ADDR_R_0	6
+#define DC_EVT_NEW_ADDR_R_1	7
+#define DC_EVT_NEW_CHAN_R_0	8
+#define DC_EVT_NEW_CHAN_R_1	9
+#define DC_EVT_NEW_DATA_R_0	10
+#define DC_EVT_NEW_DATA_R_1	11
+
+#define dc_ch_offset(ch) \
+({ \
+	const u8 _offset[] = { \
+		0, 0x1C, 0x38, 0x54, 0x58, 0x5C, 0x78, 0, 0x94, 0xB4}; \
+	_offset[ch]; \
+})
+#define DC_WR_CH_CONF(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4)
+#define DC_WR_CH_ADDR(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4 + 4/4)
+
+#define DC_WR_CH_CONF_1		(ipu_dc_reg + 0x001C/4)
+#define DC_WR_CH_ADDR_1		(ipu_dc_reg + 0x0020/4)
+#define DC_WR_CH_CONF_5		(ipu_dc_reg + 0x005C/4)
+#define DC_WR_CH_ADDR_5		(ipu_dc_reg + 0x0060/4)
+#define DC_GEN			(ipu_dc_reg + 0x00D4/4)
+#define DC_DISP_CONF1(disp)	(ipu_dc_reg + 0x00D8/4 + disp)
+#define DC_DISP_CONF2(disp)	(ipu_dc_reg + 0x00E8/4 + disp)
+#define DC_STAT			(ipu_dc_reg + 0x01C8/4)
+#define DC_UGDE_0(evt)		(ipu_dc_reg + 0x0174/4 + evt*4)
+#define DC_UGDE_1(evt)		(ipu_dc_reg + 0x0178/4 + evt*4)
+#define DC_UGDE_2(evt)		(ipu_dc_reg + 0x017C/4 + evt*4)
+#define DC_UGDE_3(evt)		(ipu_dc_reg + 0x0180/4 + evt*4)
+
+#define DP_SYNC 0
+#define DP_ASYNC0 0x60
+#define DP_ASYNC1 0xBC
+#define DP_COM_CONF(flow)	(ipu_dp_reg + flow/4)
+#define DP_GRAPH_WIND_CTRL(flow) (ipu_dp_reg + 0x0004/4 + flow/4)
+#define DP_FG_POS(flow)		(ipu_dp_reg + 0x0008/4 + flow/4)
+#define DP_CSC_A_0(flow)	(ipu_dp_reg + 0x0044/4 + flow/4)
+#define DP_CSC_A_1(flow)	(ipu_dp_reg + 0x0048/4 + flow/4)
+#define DP_CSC_A_2(flow)	(ipu_dp_reg + 0x004C/4 + flow/4)
+#define DP_CSC_A_3(flow)	(ipu_dp_reg + 0x0050/4 + flow/4)
+#define DP_CSC_0(flow)		(ipu_dp_reg + 0x0054/4 + flow/4)
+#define DP_CSC_1(flow)		(ipu_dp_reg + 0x0058/4 + flow/4)
+
+enum {
+	IPU_CONF_CSI0_EN = 0x00000001,
+	IPU_CONF_CSI1_EN = 0x00000002,
+	IPU_CONF_IC_EN = 0x00000004,
+	IPU_CONF_ROT_EN = 0x00000008,
+	IPU_CONF_ISP_EN = 0x00000010,
+	IPU_CONF_DP_EN = 0x00000020,
+	IPU_CONF_DI0_EN = 0x00000040,
+	IPU_CONF_DI1_EN = 0x00000080,
+	IPU_CONF_DMFC_EN = 0x00000400,
+	IPU_CONF_SMFC_EN = 0x00000100,
+	IPU_CONF_DC_EN = 0x00000200,
+	IPU_CONF_IDMAC_DIS = 0x00400000,
+	IPU_CONF_IC_DMFC_SEL = 0x02000000,
+	IPU_CONF_IC_DMFC_SYNC = 0x04000000,
+	IPU_CONF_VDI_DMFC_SYNC = 0x08000000,
+	IPU_CONF_CSI0_DATA_SOURCE = 0x10000000,
+	IPU_CONF_CSI0_DATA_SOURCE_OFFSET = 28,
+	IPU_CONF_CSI1_DATA_SOURCE = 0x20000000,
+	IPU_CONF_IC_INPUT = 0x40000000,
+	IPU_CONF_CSI_SEL = 0x80000000,
+
+	DI0_COUNTER_RELEASE = 0x01000000,
+	DI1_COUNTER_RELEASE = 0x02000000,
+
+	FS_PRPVF_ROT_SRC_SEL_MASK = 0x00000F00,
+	FS_PRPVF_ROT_SRC_SEL_OFFSET = 8,
+	FS_PRPENC_ROT_SRC_SEL_MASK = 0x0000000F,
+	FS_PRPENC_ROT_SRC_SEL_OFFSET = 0,
+	FS_PP_ROT_SRC_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_SRC_SEL_OFFSET = 16,
+	FS_PP_SRC_SEL_MASK = 0x0000F000,
+	FS_PP_SRC_SEL_OFFSET = 12,
+	FS_PRP_SRC_SEL_MASK = 0x0F000000,
+	FS_PRP_SRC_SEL_OFFSET = 24,
+	FS_VF_IN_VALID = 0x80000000,
+	FS_ENC_IN_VALID = 0x40000000,
+
+	FS_PRPENC_DEST_SEL_MASK = 0x0000000F,
+	FS_PRPENC_DEST_SEL_OFFSET = 0,
+	FS_PRPVF_DEST_SEL_MASK = 0x000000F0,
+	FS_PRPVF_DEST_SEL_OFFSET = 4,
+	FS_PRPVF_ROT_DEST_SEL_MASK = 0x00000F00,
+	FS_PRPVF_ROT_DEST_SEL_OFFSET = 8,
+	FS_PP_DEST_SEL_MASK = 0x0000F000,
+	FS_PP_DEST_SEL_OFFSET = 12,
+	FS_PP_ROT_DEST_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_DEST_SEL_OFFSET = 16,
+	FS_PRPENC_ROT_DEST_SEL_MASK = 0x00F00000,
+	FS_PRPENC_ROT_DEST_SEL_OFFSET = 20,
+
+	FS_SMFC0_DEST_SEL_MASK = 0x0000000F,
+	FS_SMFC0_DEST_SEL_OFFSET = 0,
+	FS_SMFC1_DEST_SEL_MASK = 0x00000070,
+	FS_SMFC1_DEST_SEL_OFFSET = 4,
+	FS_SMFC2_DEST_SEL_MASK = 0x00000780,
+	FS_SMFC2_DEST_SEL_OFFSET = 7,
+	FS_SMFC3_DEST_SEL_MASK = 0x00003800,
+	FS_SMFC3_DEST_SEL_OFFSET = 11,
+
+	FS_DC1_SRC_SEL_MASK = 0x00F00000,
+	FS_DC1_SRC_SEL_OFFSET = 20,
+	FS_DC2_SRC_SEL_MASK = 0x000F0000,
+	FS_DC2_SRC_SEL_OFFSET = 16,
+	FS_DP_SYNC0_SRC_SEL_MASK = 0x0000000F,
+	FS_DP_SYNC0_SRC_SEL_OFFSET = 0,
+	FS_DP_SYNC1_SRC_SEL_MASK = 0x000000F0,
+	FS_DP_SYNC1_SRC_SEL_OFFSET = 4,
+	FS_DP_ASYNC0_SRC_SEL_MASK = 0x00000F00,
+	FS_DP_ASYNC0_SRC_SEL_OFFSET = 8,
+	FS_DP_ASYNC1_SRC_SEL_MASK = 0x0000F000,
+	FS_DP_ASYNC1_SRC_SEL_OFFSET = 12,
+
+	FS_AUTO_REF_PER_MASK = 0,
+	FS_AUTO_REF_PER_OFFSET = 16,
+
+	TSTAT_VF_MASK = 0x0000000C,
+	TSTAT_VF_OFFSET = 2,
+	TSTAT_VF_ROT_MASK = 0x00000300,
+	TSTAT_VF_ROT_OFFSET = 8,
+	TSTAT_ENC_MASK = 0x00000003,
+	TSTAT_ENC_OFFSET = 0,
+	TSTAT_ENC_ROT_MASK = 0x000000C0,
+	TSTAT_ENC_ROT_OFFSET = 6,
+	TSTAT_PP_MASK = 0x00000030,
+	TSTAT_PP_OFFSET = 4,
+	TSTAT_PP_ROT_MASK = 0x00000C00,
+	TSTAT_PP_ROT_OFFSET = 10,
+
+	TASK_STAT_IDLE = 0,
+	TASK_STAT_ACTIVE = 1,
+	TASK_STAT_WAIT4READY = 2,
+
+	/* Image Converter Register bits */
+	IC_CONF_PRPENC_EN = 0x00000001,
+	IC_CONF_PRPENC_CSC1 = 0x00000002,
+	IC_CONF_PRPENC_ROT_EN = 0x00000004,
+	IC_CONF_PRPVF_EN = 0x00000100,
+	IC_CONF_PRPVF_CSC1 = 0x00000200,
+	IC_CONF_PRPVF_CSC2 = 0x00000400,
+	IC_CONF_PRPVF_CMB = 0x00000800,
+	IC_CONF_PRPVF_ROT_EN = 0x00001000,
+	IC_CONF_PP_EN = 0x00010000,
+	IC_CONF_PP_CSC1 = 0x00020000,
+	IC_CONF_PP_CSC2 = 0x00040000,
+	IC_CONF_PP_CMB = 0x00080000,
+	IC_CONF_PP_ROT_EN = 0x00100000,
+	IC_CONF_IC_GLB_LOC_A = 0x10000000,
+	IC_CONF_KEY_COLOR_EN = 0x20000000,
+	IC_CONF_RWS_EN = 0x40000000,
+	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
+
+	IC_IDMAC_1_CB0_BURST_16 = 0x00000001,
+	IC_IDMAC_1_CB1_BURST_16 = 0x00000002,
+	IC_IDMAC_1_CB2_BURST_16 = 0x00000004,
+	IC_IDMAC_1_CB3_BURST_16 = 0x00000008,
+	IC_IDMAC_1_CB4_BURST_16 = 0x00000010,
+	IC_IDMAC_1_CB5_BURST_16 = 0x00000020,
+	IC_IDMAC_1_CB6_BURST_16 = 0x00000040,
+	IC_IDMAC_1_CB7_BURST_16 = 0x00000080,
+	IC_IDMAC_1_PRPENC_ROT_MASK = 0x00003800,
+	IC_IDMAC_1_PRPENC_ROT_OFFSET = 11,
+	IC_IDMAC_1_PRPVF_ROT_MASK = 0x0001C000,
+	IC_IDMAC_1_PRPVF_ROT_OFFSET = 14,
+	IC_IDMAC_1_PP_ROT_MASK = 0x000E0000,
+	IC_IDMAC_1_PP_ROT_OFFSET = 17,
+	IC_IDMAC_1_PP_FLIP_RS = 0x00400000,
+	IC_IDMAC_1_PRPVF_FLIP_RS = 0x00200000,
+	IC_IDMAC_1_PRPENC_FLIP_RS = 0x00100000,
+
+	IC_IDMAC_2_PRPENC_HEIGHT_MASK = 0x000003FF,
+	IC_IDMAC_2_PRPENC_HEIGHT_OFFSET = 0,
+	IC_IDMAC_2_PRPVF_HEIGHT_MASK = 0x000FFC00,
+	IC_IDMAC_2_PRPVF_HEIGHT_OFFSET = 10,
+	IC_IDMAC_2_PP_HEIGHT_MASK = 0x3FF00000,
+	IC_IDMAC_2_PP_HEIGHT_OFFSET = 20,
+
+	IC_IDMAC_3_PRPENC_WIDTH_MASK = 0x000003FF,
+	IC_IDMAC_3_PRPENC_WIDTH_OFFSET = 0,
+	IC_IDMAC_3_PRPVF_WIDTH_MASK = 0x000FFC00,
+	IC_IDMAC_3_PRPVF_WIDTH_OFFSET = 10,
+	IC_IDMAC_3_PP_WIDTH_MASK = 0x3FF00000,
+	IC_IDMAC_3_PP_WIDTH_OFFSET = 20,
+
+	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
+	CSI_SENS_CONF_DATA_FMT_MASK = 0x00000700,
+	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0L,
+	CSI_SENS_CONF_DATA_FMT_YUV422_YUYV = 1L,
+	CSI_SENS_CONF_DATA_FMT_YUV422_UYVY = 2L,
+	CSI_SENS_CONF_DATA_FMT_BAYER = 3L,
+	CSI_SENS_CONF_DATA_FMT_RGB565 = 4L,
+	CSI_SENS_CONF_DATA_FMT_RGB555 = 5L,
+	CSI_SENS_CONF_DATA_FMT_RGB444 = 6L,
+	CSI_SENS_CONF_DATA_FMT_JPEG = 7L,
+
+	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
+	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
+	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
+	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
+	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
+	CSI_SENS_CONF_PACK_TIGHT_SHIFT = 7,
+	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 11,
+	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
+	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
+
+	CSI_SENS_CONF_DIVRATIO_MASK = 0x00FF0000L,
+	CSI_SENS_CONF_DATA_DEST_SHIFT = 24,
+	CSI_SENS_CONF_DATA_DEST_MASK = 0x07000000L,
+	CSI_SENS_CONF_JPEG8_EN_SHIFT = 27,
+	CSI_SENS_CONF_JPEG_EN_SHIFT = 28,
+	CSI_SENS_CONF_FORCE_EOF_SHIFT = 29,
+	CSI_SENS_CONF_DATA_EN_POL_SHIFT = 31,
+
+	CSI_DATA_DEST_ISP = 1L,
+	CSI_DATA_DEST_IC = 2L,
+	CSI_DATA_DEST_IDMAC = 4L,
+
+	CSI_CCIR_ERR_DET_EN = 0x01000000L,
+	CSI_HORI_DOWNSIZE_EN = 0x80000000L,
+	CSI_VERT_DOWNSIZE_EN = 0x40000000L,
+	CSI_TEST_GEN_MODE_EN = 0x01000000L,
+
+	CSI_HSC_MASK = 0x1FFF0000,
+	CSI_HSC_SHIFT = 16,
+	CSI_VSC_MASK = 0x00000FFF,
+	CSI_VSC_SHIFT = 0,
+
+	CSI_TEST_GEN_R_MASK = 0x000000FFL,
+	CSI_TEST_GEN_R_SHIFT = 0,
+	CSI_TEST_GEN_G_MASK = 0x0000FF00L,
+	CSI_TEST_GEN_G_SHIFT = 8,
+	CSI_TEST_GEN_B_MASK = 0x00FF0000L,
+	CSI_TEST_GEN_B_SHIFT = 16,
+
+	CSI_MIPI_DI0_MASK = 0x000000FFL,
+	CSI_MIPI_DI0_SHIFT = 0,
+	CSI_MIPI_DI1_MASK = 0x0000FF00L,
+	CSI_MIPI_DI1_SHIFT = 8,
+	CSI_MIPI_DI2_MASK = 0x00FF0000L,
+	CSI_MIPI_DI2_SHIFT = 16,
+	CSI_MIPI_DI3_MASK = 0xFF000000L,
+	CSI_MIPI_DI3_SHIFT = 24,
+
+	CSI_MAX_RATIO_SKIP_ISP_MASK = 0x00070000L,
+	CSI_MAX_RATIO_SKIP_ISP_SHIFT = 16,
+	CSI_SKIP_ISP_MASK = 0x00F80000L,
+	CSI_SKIP_ISP_SHIFT = 19,
+	CSI_MAX_RATIO_SKIP_SMFC_MASK = 0x00000007L,
+	CSI_MAX_RATIO_SKIP_SMFC_SHIFT = 0,
+	CSI_SKIP_SMFC_MASK = 0x000000F8L,
+	CSI_SKIP_SMFC_SHIFT = 3,
+	CSI_ID_2_SKIP_MASK = 0x00000300L,
+	CSI_ID_2_SKIP_SHIFT = 8,
+
+	CSI_COLOR_FIRST_ROW_MASK = 0x00000002L,
+	CSI_COLOR_FIRST_COMP_MASK = 0x00000001L,
+
+	SMFC_MAP_CH0_MASK = 0x00000007L,
+	SMFC_MAP_CH0_SHIFT = 0,
+	SMFC_MAP_CH1_MASK = 0x00000038L,
+	SMFC_MAP_CH1_SHIFT = 3,
+	SMFC_MAP_CH2_MASK = 0x000001C0L,
+	SMFC_MAP_CH2_SHIFT = 6,
+	SMFC_MAP_CH3_MASK = 0x00000E00L,
+	SMFC_MAP_CH3_SHIFT = 9,
+
+	SMFC_WM0_SET_MASK = 0x00000007L,
+	SMFC_WM0_SET_SHIFT = 0,
+	SMFC_WM1_SET_MASK = 0x000001C0L,
+	SMFC_WM1_SET_SHIFT = 6,
+	SMFC_WM2_SET_MASK = 0x00070000L,
+	SMFC_WM2_SET_SHIFT = 16,
+	SMFC_WM3_SET_MASK = 0x01C00000L,
+	SMFC_WM3_SET_SHIFT = 22,
+
+	SMFC_WM0_CLR_MASK = 0x00000038L,
+	SMFC_WM0_CLR_SHIFT = 3,
+	SMFC_WM1_CLR_MASK = 0x00000E00L,
+	SMFC_WM1_CLR_SHIFT = 9,
+	SMFC_WM2_CLR_MASK = 0x00380000L,
+	SMFC_WM2_CLR_SHIFT = 19,
+	SMFC_WM3_CLR_MASK = 0x0E000000L,
+	SMFC_WM3_CLR_SHIFT = 25,
+
+	SMFC_BS0_MASK = 0x0000000FL,
+	SMFC_BS0_SHIFT = 0,
+	SMFC_BS1_MASK = 0x000000F0L,
+	SMFC_BS1_SHIFT = 4,
+	SMFC_BS2_MASK = 0x00000F00L,
+	SMFC_BS2_SHIFT = 8,
+	SMFC_BS3_MASK = 0x0000F000L,
+	SMFC_BS3_SHIFT = 12,
+
+	PF_CONF_TYPE_MASK = 0x00000007,
+	PF_CONF_TYPE_SHIFT = 0,
+	PF_CONF_PAUSE_EN = 0x00000010,
+	PF_CONF_RESET = 0x00008000,
+	PF_CONF_PAUSE_ROW_MASK = 0x00FF0000,
+	PF_CONF_PAUSE_ROW_SHIFT = 16,
+
+	DI_DW_GEN_ACCESS_SIZE_OFFSET = 24,
+	DI_DW_GEN_COMPONENT_SIZE_OFFSET = 16,
+
+	DI_GEN_DI_CLK_EXT = 0x100000,
+	DI_GEN_POLARITY_1 = 0x00000001,
+	DI_GEN_POLARITY_2 = 0x00000002,
+	DI_GEN_POLARITY_3 = 0x00000004,
+	DI_GEN_POLARITY_4 = 0x00000008,
+	DI_GEN_POLARITY_5 = 0x00000010,
+	DI_GEN_POLARITY_6 = 0x00000020,
+	DI_GEN_POLARITY_7 = 0x00000040,
+	DI_GEN_POLARITY_8 = 0x00000080,
+
+	DI_POL_DRDY_DATA_POLARITY = 0x00000080,
+	DI_POL_DRDY_POLARITY_15 = 0x00000010,
+
+	DI_VSYNC_SEL_OFFSET = 13,
+
+	DC_WR_CH_CONF_FIELD_MODE = 0x00000200,
+	DC_WR_CH_CONF_PROG_TYPE_OFFSET = 5,
+	DC_WR_CH_CONF_PROG_TYPE_MASK = 0x000000E0,
+	DC_WR_CH_CONF_PROG_DI_ID = 0x00000004,
+	DC_WR_CH_CONF_PROG_DISP_ID_OFFSET = 3,
+	DC_WR_CH_CONF_PROG_DISP_ID_MASK = 0x00000018,
+
+	DC_UGDE_0_ODD_EN = 0x02000000,
+	DC_UGDE_0_ID_CODED_MASK = 0x00000007,
+	DC_UGDE_0_ID_CODED_OFFSET = 0,
+	DC_UGDE_0_EV_PRIORITY_MASK = 0x00000078,
+	DC_UGDE_0_EV_PRIORITY_OFFSET = 3,
+
+	DP_COM_CONF_FG_EN = 0x00000001,
+	DP_COM_CONF_GWSEL = 0x00000002,
+	DP_COM_CONF_GWAM = 0x00000004,
+	DP_COM_CONF_GWCKE = 0x00000008,
+	DP_COM_CONF_CSC_DEF_MASK = 0x00000300,
+	DP_COM_CONF_CSC_DEF_OFFSET = 8,
+	DP_COM_CONF_CSC_DEF_FG = 0x00000300,
+	DP_COM_CONF_CSC_DEF_BG = 0x00000200,
+	DP_COM_CONF_CSC_DEF_BOTH = 0x00000100,
+
+	DI_SER_CONF_LLA_SER_ACCESS = 0x00000020,
+	DI_SER_CONF_SERIAL_CLK_POL = 0x00000010,
+	DI_SER_CONF_SERIAL_DATA_POL = 0x00000008,
+	DI_SER_CONF_SERIAL_RS_POL = 0x00000004,
+	DI_SER_CONF_SERIAL_CS_POL = 0x00000002,
+	DI_SER_CONF_WAIT4SERIAL = 0x00000001,
+};
+
+enum di_pins {
+	DI_PIN11 = 0,
+	DI_PIN12 = 1,
+	DI_PIN13 = 2,
+	DI_PIN14 = 3,
+	DI_PIN15 = 4,
+	DI_PIN16 = 5,
+	DI_PIN17 = 6,
+	DI_PIN_CS = 7,
+
+	DI_PIN_SER_CLK = 0,
+	DI_PIN_SER_RS = 1,
+};
+
+enum di_sync_wave {
+	DI_SYNC_NONE = -1,
+	DI_SYNC_CLK = 0,
+	DI_SYNC_INT_HSYNC = 1,
+	DI_SYNC_HSYNC = 2,
+	DI_SYNC_VSYNC = 3,
+	DI_SYNC_DE = 5,
+};
+
+/* DC template opcodes */
+#define WROD(lf)		(0x18 | (lf << 1))
+
+#endif
-- 
1.5.5.1

