From 5a845ae7db1f0f41c716e0760d2f900e89464c11 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Fri, 19 Jun 2009 19:55:32 +0800
Subject: [PATCH] fsl_imx: add framebuffer and epson lcd support

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Add mxc ipu based framebuffer and epson LCD support.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

On i.MX51PDK platform, the epson vga lcd is driven by ipu instead of
spi, and moreover, the i.MX5 series can support in-chip tv encoder
function and can support wvga resolution lcd. So add drivers to
support this hardware.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/plat-mxc/include/mach/mxcfb.h  |   75 ++
 drivers/video/Kconfig                   |    4 +
 drivers/video/Makefile                  |    1 +
 drivers/video/mxc/Kconfig               |   48 ++
 drivers/video/mxc/Makefile              |   11 +
 drivers/video/mxc/mxc_ipuv3_fb.c        | 1069 ++++++++++++++++++++++++
 drivers/video/mxc/mxcfb.c               | 1363 +++++++++++++++++++++++++++++++
 drivers/video/mxc/mxcfb_claa_wvga.c     |  236 ++++++
 drivers/video/mxc/mxcfb_epson_vga.c     |  270 ++++++
 drivers/video/mxc/mxcfb_epson_vga_ipu.c |  288 +++++++
 drivers/video/mxc/mxcfb_modedb.c        |   65 ++
 drivers/video/mxc/tve.c                 |  705 ++++++++++++++++
 12 files changed, 4135 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/mxcfb.h
 create mode 100644 drivers/video/mxc/Kconfig
 create mode 100644 drivers/video/mxc/Makefile
 create mode 100644 drivers/video/mxc/mxc_ipuv3_fb.c
 create mode 100644 drivers/video/mxc/mxcfb.c
 create mode 100644 drivers/video/mxc/mxcfb_claa_wvga.c
 create mode 100644 drivers/video/mxc/mxcfb_epson_vga.c
 create mode 100644 drivers/video/mxc/mxcfb_epson_vga_ipu.c
 create mode 100644 drivers/video/mxc/mxcfb_modedb.c
 create mode 100644 drivers/video/mxc/tve.c

diff --git a/arch/arm/plat-mxc/include/mach/mxcfb.h b/arch/arm/plat-mxc/include/mach/mxcfb.h
new file mode 100644
index 0000000..7daf8fa
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxcfb.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file arch-mxc/   mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_ACT_HIGH	0x80000000
+#define FB_SYNC_CLK_INVERT	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOW('F', 0x24, struct mxcfb_pos)
+
+#ifdef __KERNEL__
+
+extern struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+struct mxcfb_rect {
+	u32 top;
+	u32 left;
+	u32 width;
+	u32 height;
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+		struct mxcfb_rect *update_region);
+
+#endif	/* __KERNEL__ */
+#endif
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index b1e6689..07a0f73 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -370,6 +370,10 @@ config FB_CLPS711X
 	  Say Y to enable the Framebuffer driver for the CLPS7111 and
 	  EP7212 processors.
 
+if ARCH_MXC
+source "drivers/video/mxc/Kconfig"
+endif
+
 config FB_SA1100
 	bool "SA-1100 LCD support"
 	depends on (FB = y) && ARM && ARCH_SA1100
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index a6b5529..f8fb3d0 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
 obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
 obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
 obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx4008/
+obj-$(CONFIG_FB_MXC)          += mxc/
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
new file mode 100644
index 0000000..b1136de
--- /dev/null
+++ b/drivers/video/mxc/Kconfig
@@ -0,0 +1,48 @@
+config FB_MXC
+	tristate "MXC Framebuffer support"
+	depends on FB && MXC_IPU
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	default y
+	help
+	  This is a framebuffer device for the MXC LCD Controller.
+	  See <http://www.linux-fbdev.org/> for information on framebuffer
+	  devices.
+
+	  If you plan to use the LCD display with your MXC system, say
+	  Y here.
+
+config FB_MXC_SYNC_PANEL
+	depends on FB_MXC
+	tristate "Synchronous Panel Framebuffer"
+	default y
+
+config FB_MXC_EPSON_VGA_SYNC_PANEL
+	depends on FB_MXC_SYNC_PANEL
+	tristate "Epson VGA Panel"
+	default n
+
+config FB_MXC_LOW_PWR_DISPLAY
+	bool "Low Power Display Refresh Mode"
+	depends on FB_MXC_SYNC_PANEL && MXC_FB_IRAM
+	default y
+
+config FB_MXC_INTERNAL_MEM
+	bool "Framebuffer in Internal RAM"
+	depends on FB_MXC_SYNC_PANEL && MXC_FB_IRAM
+	default y
+
+config FB_MXC_EPSON_VGA_SYNC_PANEL_IPU
+	depends on FB_MXC_SYNC_PANEL
+	tristate "Epson VGA Panel via IPU"
+	default n
+
+config FB_MXC_TVOUT_TVE
+	tristate "MXC TVE TV Out Encoder"
+	depends on FB_MXC_SYNC_PANEL
+	depends on MXC_IPU_V3
+
+config FB_MXC_CLAA_WVGA_SYNC_PANEL
+	depends on FB_MXC_SYNC_PANEL
+	tristate "CLAA WVGA Panel"
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
new file mode 100644
index 0000000..4a1e76e
--- /dev/null
+++ b/drivers/video/mxc/Makefile
@@ -0,0 +1,11 @@
+ifeq ($(CONFIG_MXC_IPU_V3),y)
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mxc_ipuv3_fb.o
+endif
+obj-$(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL_IPU)	+= mxcfb_epson_vga_ipu.o
+obj-$(CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL)	+= mxcfb_claa_wvga.o
+obj-$(CONFIG_FB_MXC_TVOUT_TVE)			+= tve.o
+
+ifeq ($(CONFIG_MXC_IPU_V1),y)
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mxcfb.o mxcfb_modedb.o
+endif
+obj-$(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL)	+= mxcfb_epson_vga.o
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
new file mode 100644
index 0000000..6a9f68d
--- /dev/null
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -0,0 +1,1069 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+#include <linux/io.h>
+#include <mach/ipu.h>
+#include <mach/mxcfb.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxc_sdc_fb"
+/*!
+ * Structure containing the MXC specific framebuffer information.
+ */
+struct mxcfb_info {
+	int blank;
+	ipu_channel_t ipu_ch;
+	int ipu_di;
+	u32 ipu_di_pix_fmt;
+	bool overlay;
+	uint32_t ipu_ch_irq;
+	uint32_t cur_ipu_buf;
+
+	u32 pseudo_palette[16];
+
+	struct semaphore flip_sem;
+	struct completion vsync_complete;
+};
+
+struct mxcfb_alloc_list {
+	struct list_head list;
+	dma_addr_t phy_addr;
+	void *cpu_addr;
+	u32 size;
+};
+
+static char *fb_mode;
+static unsigned long default_bpp = 16;
+static bool g_dp_in_use;
+LIST_HEAD(fb_alloc_list);
+
+static uint32_t bpp_to_pixfmt(struct fb_info *fbi)
+{
+	uint32_t pixfmt = 0;
+
+	if (fbi->var.nonstd)
+		return fbi->var.nonstd;
+
+	switch (fbi->var.bits_per_pixel) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id);
+static int mxcfb_blank(int blank, struct fb_info *info);
+static int mxcfb_map_video_memory(struct fb_info *fbi);
+static int mxcfb_unmap_video_memory(struct fb_info *fbi);
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval;
+	u32 mem_len;
+	ipu_di_signal_cfg_t sig_cfg;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dev_dbg(fbi->device, "Reconfiguring framebuffer\n");
+
+	ipu_disable_irq(mxc_fbi->ipu_ch_irq);
+	ipu_disable_channel(mxc_fbi->ipu_ch, true);
+	ipu_uninit_channel(mxc_fbi->ipu_ch);
+	ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+	mxcfb_set_fix(fbi);
+
+	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
+	if (!fbi->fix.smem_start || (mem_len > fbi->fix.smem_len)) {
+		if (fbi->fix.smem_start)
+			mxcfb_unmap_video_memory(fbi);
+
+		if (mxcfb_map_video_memory(fbi) < 0)
+			return -ENOMEM;
+	}
+#ifdef CONFIG_MXC_IPU_V1
+	ipu_init_channel(mxc_fbi->ipu_ch, NULL);
+#else
+	memset(&params, 0, sizeof(params));
+	params.mem_dp_bg_sync.di = mxc_fbi->ipu_di;
+
+	/* Assuming interlaced means YUV output */
+	if (fbi->var.vmode & FB_VMODE_INTERLACED) {
+		params.mem_dp_bg_sync.interlaced = true;
+		params.mem_dp_bg_sync.out_pixel_fmt = IPU_PIX_FMT_YUV444;
+	} else {
+		if (mxc_fbi->ipu_di_pix_fmt)
+			params.mem_dp_bg_sync.out_pixel_fmt = mxc_fbi->ipu_di_pix_fmt;
+		else
+			params.mem_dp_bg_sync.out_pixel_fmt = IPU_PIX_FMT_RGB666;
+	}
+	params.mem_dp_bg_sync.in_pixel_fmt = bpp_to_pixfmt(fbi);
+	ipu_init_channel(mxc_fbi->ipu_ch, &params);
+#endif
+
+	if (!mxc_fbi->overlay) {
+		memset(&sig_cfg, 0, sizeof(sig_cfg));
+		if (fbi->var.vmode & FB_VMODE_INTERLACED)
+			sig_cfg.interlaced = true;
+		if (fbi->var.vmode & FB_VMODE_ODD_FLD_FIRST) /* PAL */
+			sig_cfg.odd_field_first = true;
+		if (fbi->var.sync & FB_SYNC_EXT)
+			sig_cfg.ext_clk = true;
+		if (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)
+			sig_cfg.Hsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)
+			sig_cfg.Vsync_pol = true;
+		if (!(fbi->var.sync & FB_SYNC_CLK_INVERT))
+			sig_cfg.clk_pol = true;
+		if (fbi->var.sync & FB_SYNC_DATA_INVERT)
+			sig_cfg.data_pol = true;
+		if (!(fbi->var.sync & FB_SYNC_OE_ACT_HIGH))
+			sig_cfg.enable_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)
+			sig_cfg.clkidle_en = true;
+
+		dev_dbg(fbi->device, "pixclock = %ul Hz\n",
+			(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));
+
+#ifdef CONFIG_MXC_IPU_V1
+		if (ipu_sdc_init_panel(mode,
+				       (PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+				       fbi->var.xres, fbi->var.yres,
+				       (fbi->var.sync & FB_SYNC_SWAP_RGB) ?
+				       IPU_PIX_FMT_BGR666 : IPU_PIX_FMT_RGB666,
+				       fbi->var.left_margin,
+				       fbi->var.hsync_len,
+				       fbi->var.right_margin,
+				       fbi->var.upper_margin,
+				       fbi->var.vsync_len,
+				       fbi->var.lower_margin, sig_cfg) != 0) {
+#else
+		if (ipu_init_sync_panel(mxc_fbi->ipu_di,
+					(PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+					fbi->var.xres, fbi->var.yres,
+					params.mem_dp_bg_sync.out_pixel_fmt,
+					fbi->var.left_margin,
+					fbi->var.hsync_len,
+					fbi->var.right_margin,
+					fbi->var.upper_margin,
+					fbi->var.vsync_len,
+					fbi->var.lower_margin,
+					480, sig_cfg) != 0) {
+#endif
+			dev_err(fbi->device,
+				"mxcfb: Error initializing panel.\n");
+			return -EINVAL;
+		}
+
+		fbi->mode =
+		    (struct fb_videomode *)fb_match_mode(&fbi->var,
+							 &fbi->modelist);
+		ipu_disp_set_window_pos(mxc_fbi->ipu_ch, 0, 0);
+	}
+
+	mxc_fbi->cur_ipu_buf = 1;
+	sema_init(&mxc_fbi->flip_sem, 1);
+	fbi->var.xoffset = fbi->var.yoffset = 0;
+
+	retval = ipu_init_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+					 bpp_to_pixfmt(fbi),
+					 fbi->var.xres, fbi->var.yres,
+					 fbi->fix.line_length,
+					 IPU_ROTATE_NONE,
+					 fbi->fix.smem_start +
+					 (fbi->fix.line_length * fbi->var.yres),
+					 fbi->fix.smem_start,
+					 0, 0);
+	if (retval) {
+		dev_err(fbi->device,
+			"ipu_init_channel_buffer error %d\n", retval);
+		return retval;
+	}
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+		ipu_enable_channel(mxc_fbi->ipu_ch);
+	}
+
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	u32 vtotal;
+	u32 htotal;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16))
+		var->bits_per_pixel = default_bpp;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			   u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int __user *argp = (void __user *)arg;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	switch (cmd) {
+	case MXCFB_SET_GBL_ALPHA:
+		{
+			struct mxcfb_gbl_alpha ga;
+			if (copy_from_user(&ga, (void *)arg, sizeof(ga))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval =
+			    ipu_disp_set_global_alpha(MEM_BG_SYNC,
+						      (bool) ga.enable,
+						      ga.alpha);
+			dev_dbg(fbi->device, "Set global alpha to %d\n",
+				ga.alpha);
+			break;
+		}
+	case MXCFB_SET_CLR_KEY:
+		{
+			struct mxcfb_color_key key;
+			if (copy_from_user(&key, (void *)arg, sizeof(key))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = ipu_disp_set_color_key(MEM_BG_SYNC, key.enable,
+							key.color_key);
+			dev_dbg(fbi->device, "Set color key to 0x%08X\n",
+				key.color_key);
+			break;
+		}
+	case MXCFB_WAIT_FOR_VSYNC:
+		{
+			if (mxc_fbi->blank != FB_BLANK_UNBLANK)
+				break;
+
+			down(&mxc_fbi->flip_sem);
+			init_completion(&mxc_fbi->vsync_complete);
+
+			ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+			ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+			retval = wait_for_completion_interruptible_timeout(
+				&mxc_fbi->vsync_complete, 1 * HZ);
+			if (retval == 0) {
+				dev_err(fbi->device,
+					"MXCFB_WAIT_FOR_VSYNC: timeout %d\n",
+					retval);
+				retval = -ETIME;
+			} else if (retval > 0) {
+				retval = 0;
+			}
+			break;
+		}
+	case FBIO_ALLOC:
+		{
+			int size;
+			struct mxcfb_alloc_list *mem;
+
+			mem = kzalloc(sizeof(*mem), GFP_KERNEL);
+			if (mem == NULL)
+				return -ENOMEM;
+
+			if (get_user(size, argp))
+				return -EFAULT;
+
+			mem->size = PAGE_ALIGN(size);
+
+			mem->cpu_addr = dma_alloc_coherent(fbi->device, size,
+							   &mem->phy_addr,
+							   GFP_DMA);
+			if (mem->cpu_addr == NULL) {
+				kfree(mem);
+				return -ENOMEM;
+			}
+
+			list_add(&mem->list, &fb_alloc_list);
+
+			dev_dbg(fbi->device, "allocated %d bytes @ 0x%08X\n",
+				mem->size, mem->phy_addr);
+
+			if (put_user(mem->phy_addr, argp))
+				return -EFAULT;
+
+			break;
+		}
+	case FBIO_FREE:
+		{
+			unsigned long offset;
+			struct mxcfb_alloc_list *mem;
+
+			if (get_user(offset, argp))
+				return -EFAULT;
+
+			retval = -EINVAL;
+			list_for_each_entry(mem, &fb_alloc_list, list) {
+				if (mem->phy_addr == offset) {
+					list_del(&mem->list);
+					dma_free_coherent(fbi->device,
+							  mem->size,
+							  mem->cpu_addr,
+							  mem->phy_addr);
+					kfree(mem);
+					retval = 0;
+					break;
+				}
+			}
+
+			break;
+		}
+	case MXCFB_SET_OVERLAY_POS:
+		{
+			struct mxcfb_pos pos;
+			if (copy_from_user(&pos, (void *)arg, sizeof(pos))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = ipu_disp_set_window_pos(mxc_fbi->ipu_ch,
+							 pos.x, pos.y);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "blank = %d\n", blank);
+
+	if (mxc_fbi->blank == blank)
+		return 0;
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		ipu_disable_channel(mxc_fbi->ipu_ch, true);
+		ipu_uninit_channel(mxc_fbi->ipu_ch);
+		break;
+	case FB_BLANK_UNBLANK:
+		mxcfb_set_par(info);
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ *
+ * @param               var     Variable screen buffer information
+ * @param               info    Framebuffer information pointer
+ */
+static int
+mxcfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+	u_int y_bottom;
+	unsigned long base;
+
+	if (var->xoffset > 0) {
+		dev_dbg(info->device, "x panning not supported\n");
+		return -EINVAL;
+	}
+
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset))
+		return 0;	/* No change, do nothing */
+
+	y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP))
+		y_bottom += var->yres;
+
+	if (y_bottom > info->var.yres_virtual)
+		return -EINVAL;
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	dev_dbg(info->device, "Updating SDC BG buf %d address=0x%08lX\n",
+		mxc_fbi->cur_ipu_buf, base);
+
+	down(&mxc_fbi->flip_sem);
+	init_completion(&mxc_fbi->vsync_complete);
+
+	mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+	if (ipu_update_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				      mxc_fbi->cur_ipu_buf, base) == 0) {
+		ipu_select_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				  mxc_fbi->cur_ipu_buf);
+		ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+		ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+	} else {
+		dev_err(info->device,
+			"Error updating SDC buf %d to address=0x%08lX\n",
+			mxc_fbi->cur_ipu_buf, base);
+	}
+
+	dev_dbg(info->device, "Update complete\n");
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+	return 0;
+}
+
+/*
+ * Function to handle custom mmap for MXC framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       vma     Pointer to vm_area_struct
+ */
+static int mxcfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
+{
+	bool found = false;
+	u32 len;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	struct mxcfb_alloc_list *mem;
+
+	if (offset < fbi->fix.smem_len) {
+		/* mapping framebuffer memory */
+		len = fbi->fix.smem_len - offset;
+		vma->vm_pgoff = (fbi->fix.smem_start + offset) >> PAGE_SHIFT;
+	} else {
+		list_for_each_entry(mem, &fb_alloc_list, list) {
+			if (offset == mem->phy_addr) {
+				found = true;
+				len = mem->size;
+				break;
+			}
+		}
+		if (!found)
+			return -EINVAL;
+	}
+
+	len = PAGE_ALIGN(len);
+	if (vma->vm_end - vma->vm_start > len)
+		return -EINVAL;
+
+	/* make buffers bufferable */
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+		dev_dbg(fbi->device, "mmap remap_pfn_range failed\n");
+		return -ENOBUFS;
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_ioctl = mxcfb_ioctl,
+	.fb_mmap = mxcfb_mmap,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+};
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id)
+{
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	complete(&mxc_fbi->vsync_complete);
+	up(&mxc_fbi->flip_sem);
+	ipu_disable_irq(irq);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Suspends the framebuffer and blanks the screen. Power management support
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	int saved_blank;
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+	void *fbmem;
+#endif
+
+	acquire_console_sem();
+	fb_set_suspend(fbi, 1);
+	saved_blank = mxc_fbi->blank;
+	mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+	mxc_fbi->blank = saved_blank;
+	release_console_sem();
+
+	return 0;
+}
+
+/*
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	int saved_blank;
+
+	acquire_console_sem();
+	saved_blank = mxc_fbi->blank;
+	mxc_fbi->blank = FB_BLANK_POWERDOWN;
+	mxcfb_blank(saved_blank, fbi);
+	fb_set_suspend(fbi, 0);
+	release_console_sem();
+
+	return 0;
+}
+
+/*
+ * Main framebuffer functions
+ */
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi)
+{
+	if (fbi->fix.smem_len < fbi->var.yres_virtual * fbi->fix.line_length)
+		fbi->fix.smem_len = fbi->var.yres_virtual *
+				    fbi->fix.line_length;
+
+	fbi->screen_base = dma_alloc_writecombine(fbi->device,
+				fbi->fix.smem_len,
+				(dma_addr_t *)&fbi->fix.smem_start,
+				GFP_DMA);
+	if (fbi->screen_base == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		fbi->fix.smem_len = 0;
+		fbi->fix.smem_start = 0;
+		return -EBUSY;
+	}
+
+	dev_dbg(fbi->device, "allocated fb @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_size = fbi->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0xff, fbi->fix.smem_len);
+
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	dma_free_writecombine(fbi->device, fbi->fix.smem_len,
+			      fbi->screen_base, fbi->fix.smem_start);
+	fbi->screen_base = 0;
+	fbi->fix.smem_start = 0;
+	fbi->fix.smem_len = 0;
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	fbi->var.activate = FB_ACTIVATE_NOW;
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+	struct mxc_fb_platform_data *plat_data = pdev->dev.platform_data;
+	struct resource *res;
+	int ret = 0;
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	if (pdev->id == 0) {
+		mxcfbi->ipu_ch_irq = IPU_IRQ_BG_SYNC_EOF;
+		mxcfbi->ipu_ch = MEM_BG_SYNC;
+		mxcfbi->ipu_di = pdev->id;
+		ipu_disp_set_global_alpha(MEM_BG_SYNC, true, 0x80);
+		ipu_disp_set_color_key(MEM_BG_SYNC, false, 0);
+		mxcfbi->blank = FB_BLANK_UNBLANK;
+
+		strcpy(fbi->fix.id, "DISP3 BG");
+		g_dp_in_use = true;
+	} else if (pdev->id == 1) {
+		if (!g_dp_in_use) {
+			mxcfbi->ipu_ch_irq = IPU_IRQ_BG_SYNC_EOF;
+			mxcfbi->ipu_ch = MEM_BG_SYNC;
+			mxcfbi->blank = FB_BLANK_UNBLANK;
+		} else {
+			mxcfbi->ipu_ch_irq = IPU_IRQ_DC_SYNC_EOF;
+			mxcfbi->ipu_ch = MEM_DC_SYNC;
+			fbi->var.nonstd = IPU_PIX_FMT_UYVY;
+			mxcfbi->blank = FB_BLANK_POWERDOWN;
+		}
+		mxcfbi->ipu_di = pdev->id;
+
+		strcpy(fbi->fix.id, "DISP3 BG - DI1");
+	} else if (pdev->id == 2) {	/* Overlay */
+		mxcfbi->ipu_ch_irq = IPU_IRQ_FG_SYNC_EOF;
+		mxcfbi->ipu_ch = MEM_FG_SYNC;
+		mxcfbi->ipu_di = -1;
+		mxcfbi->overlay = true;
+		mxcfbi->blank = FB_BLANK_POWERDOWN;
+
+		strcpy(fbi->fix.id, "DISP3 FG");
+	}
+
+	if (ipu_request_irq(mxcfbi->ipu_ch_irq, mxcfb_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(&pdev->dev, "Error registering BG irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	ipu_disable_irq(mxcfbi->ipu_ch_irq);
+
+	/* Default Y virtual size is 2x panel size */
+	fbi->var.yres_virtual = fbi->var.yres * 2;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res) {
+		fbi->fix.smem_len = res->end - res->start + 1;
+		fbi->fix.smem_start = res->start;
+		fbi->screen_base = ioremap(fbi->fix.smem_start, fbi->fix.smem_len);
+	}
+
+	/* Need dummy values until real panel is configured */
+	fbi->var.xres = 240;
+	fbi->var.yres = 320;
+
+	if (!fb_mode && plat_data && plat_data->mode_str)
+		fb_mode = plat_data->mode_str;
+
+	if (fb_mode)
+		fb_find_mode(&fbi->var, fbi, fb_mode, NULL, 0, NULL,
+			     default_bpp);
+
+	if (plat_data) {
+		mxcfbi->ipu_di_pix_fmt = plat_data->interface_pix_fmt;
+		if (plat_data->mode)
+			fb_videomode_to_var(&fbi->var, plat_data->mode);
+	}
+
+	mxcfb_check_var(&fbi->var, fbi);
+	mxcfb_set_fix(fbi);
+
+	ret = register_framebuffer(fbi);
+	if (ret < 0)
+		goto err2;
+
+	platform_set_drvdata(pdev, fbi);
+
+	dev_err(&pdev->dev, "fb registered, using mode %s\n", fb_mode);
+	return 0;
+
+err2:
+	ipu_free_irq(mxcfbi->ipu_ch_irq, fbi);
+err1:
+	fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+err0:
+	return ret;
+}
+
+static int mxcfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if (!fbi)
+		return 0;
+
+	mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+	ipu_free_irq(mxc_fbi->ipu_ch_irq, fbi);
+	mxcfb_unmap_video_memory(fbi);
+
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+
+	unregister_framebuffer(fbi);
+	framebuffer_release(fbi);
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.remove = mxcfb_remove,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*
+ * Parse user specified options (`video=trident:')
+ * example:
+ * 	video=trident:800x600,bpp=16,noaccel
+ */
+int mxcfb_setup(char *options)
+{
+	char *opt;
+	if (!options || !*options)
+		return 0;
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+	return 0;
+}
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+int __init mxcfb_init(void)
+{
+	int ret = 0;
+#ifndef MODULE
+	char *option = NULL;
+#endif
+
+#ifndef MODULE
+	if (fb_get_options("mxcfb", &option))
+		return -ENODEV;
+	mxcfb_setup(option);
+#endif
+
+	ret = platform_driver_register(&mxcfb_driver);
+	return ret;
+}
+
+void mxcfb_exit(void)
+{
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC framebuffer driver");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("fb");
diff --git a/drivers/video/mxc/mxcfb.c b/drivers/video/mxc/mxcfb.c
new file mode 100644
index 0000000..732e86b
--- /dev/null
+++ b/drivers/video/mxc/mxcfb.c
@@ -0,0 +1,1363 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+#include <linux/uaccess.h>
+
+#include <asm/mach-types.h>
+#include <mach/gpio.h>
+
+#include <mach/hardware.h>
+#include <mach/ipu.h>
+#include <mach/mxcfb.h>
+
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxc_sdc_fb"
+/*!
+ * Structure containing the MXC specific framebuffer information.
+ */
+struct mxcfb_info {
+	int blank;
+	ipu_channel_t ipu_ch;
+	uint32_t ipu_ch_irq;
+	uint32_t cur_ipu_buf;
+
+	u32 pseudo_palette[16];
+
+	struct semaphore flip_sem;
+	spinlock_t fb_lock;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	struct fb_info *fbi_ovl;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+struct mxcfb_alloc_list {
+	struct list_head list;
+	dma_addr_t phy_addr;
+	void *cpu_addr;
+	u32 size;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+
+static char *fb_mode;
+static unsigned long default_bpp = 16;
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+static struct clk *iram_clk;
+#endif
+LIST_HEAD(fb_alloc_list);
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+			pixfmt = IPU_PIX_FMT_BGR24;
+			break;
+	case 32:
+			pixfmt = IPU_PIX_FMT_BGR32;
+			break;
+	case 16:
+			pixfmt = IPU_PIX_FMT_RGB565;
+			break;
+	}
+
+	return pixfmt;
+}
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id);
+static int mxcfb_blank(int blank, struct fb_info *info);
+static int mxcfb_map_video_memory(struct fb_info *fbi,
+		bool use_internal_ram);
+static int mxcfb_unmap_video_memory(struct fb_info *fbi);
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	if (mxc_fbi->ipu_ch == MEM_SDC_FG)
+		strncpy(fix->id, "DISP3 FG", 8);
+	else
+		strncpy(fix->id, "DISP3 BG", 8);
+
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval;
+	bool use_iram = false;
+	u32 mem_len;
+	ipu_di_signal_cfg_t sig_cfg;
+	ipu_panel_t mode = IPU_PANEL_TFT;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	ipu_disable_irq(mxc_fbi->ipu_ch_irq);
+	ipu_disable_channel(mxc_fbi->ipu_ch, true);
+	ipu_uninit_channel(mxc_fbi->ipu_ch);
+	ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+	mxcfb_set_fix(fbi);
+
+	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
+	if (mem_len > fbi->fix.smem_len) {
+		if (fbi->fix.smem_start)
+			mxcfb_unmap_video_memory(fbi);
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+		if (mxc_fbi->ipu_ch == MEM_SDC_BG)
+			use_iram = true;
+#endif
+		if (mxcfb_map_video_memory(fbi, use_iram) < 0)
+			return -ENOMEM;
+	}
+
+	ipu_init_channel(mxc_fbi->ipu_ch, NULL);
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+
+	if (mxc_fbi->ipu_ch == MEM_SDC_BG) {
+		memset(&sig_cfg, 0, sizeof(sig_cfg));
+		if (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)
+			sig_cfg.Hsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)
+			sig_cfg.Vsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_INVERT)
+			sig_cfg.clk_pol = true;
+		if (fbi->var.sync & FB_SYNC_DATA_INVERT)
+			sig_cfg.data_pol = true;
+		if (fbi->var.sync & FB_SYNC_OE_ACT_HIGH)
+			sig_cfg.enable_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)
+			sig_cfg.clkidle_en = true;
+		if (fbi->var.sync & FB_SYNC_SHARP_MODE)
+			mode = IPU_PANEL_SHARP_TFT;
+
+		dev_dbg(fbi->device, "pixclock = %ul Hz\n",
+				(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));
+
+		if (ipu_sdc_init_panel(mode,
+					(PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+					fbi->var.xres, fbi->var.yres,
+					(fbi->var.sync & FB_SYNC_SWAP_RGB) ?
+					IPU_PIX_FMT_BGR666 : IPU_PIX_FMT_RGB666,
+					fbi->var.left_margin,
+					fbi->var.hsync_len,
+					fbi->var.right_margin,
+					fbi->var.upper_margin,
+					fbi->var.vsync_len,
+					fbi->var.lower_margin, sig_cfg) != 0) {
+			dev_err(fbi->device,
+					"mxcfb: Error initializing panel.\n");
+			return -EINVAL;
+		}
+
+		fbi->mode =
+			(struct fb_videomode *)fb_match_mode(&fbi->var,
+					&fbi->modelist);
+	}
+
+	ipu_disp_set_window_pos(mxc_fbi->ipu_ch, 0, 0);
+
+	mxc_fbi->cur_ipu_buf = 1;
+	sema_init(&mxc_fbi->flip_sem, 1);
+	fbi->var.xoffset = fbi->var.yoffset = 0;
+
+	retval = ipu_init_channel_buffer(mxc_fbi->ipu_ch,
+			IPU_INPUT_BUFFER,
+			bpp_to_pixfmt(fbi->var.bits_per_pixel),
+			fbi->var.xres, fbi->var.yres,
+			fbi->var.xres_virtual,
+			IPU_ROTATE_NONE,
+			fbi->fix.smem_start +
+			(fbi->fix.line_length * fbi->var.yres),
+			fbi->fix.smem_start,
+			0, 0);
+
+	if (retval) {
+		dev_err(fbi->device,
+				"ipu_init_channel_buffer error %d\n", retval);
+		return retval;
+	}
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		ipu_enable_channel(mxc_fbi->ipu_ch);
+
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust
+ * to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	u32 vtotal;
+	u32 htotal;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if ((info->fix.smem_start == FB_RAM_BASE_ADDR) &&
+			((var->yres_virtual * var->xres_virtual *
+			  var->bits_per_pixel / 8) > FB_RAM_SIZE))
+		return -EINVAL;
+#endif
+
+	if ((var->bits_per_pixel != 32) &&
+			(var->bits_per_pixel != 24) &&
+			(var->bits_per_pixel != 16))
+		var->bits_per_pixel = default_bpp;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+			var->red.length = 5;
+			var->red.offset = 11;
+			var->red.msb_right = 0;
+
+			var->green.length = 6;
+			var->green.offset = 5;
+			var->green.msb_right = 0;
+
+			var->blue.length = 5;
+			var->blue.offset = 0;
+			var->blue.msb_right = 0;
+
+			var->transp.length = 0;
+			var->transp.offset = 0;
+			var->transp.msb_right = 0;
+			break;
+	case 24:
+			var->red.length = 8;
+			var->red.offset = 16;
+			var->red.msb_right = 0;
+
+			var->green.length = 8;
+			var->green.offset = 8;
+			var->green.msb_right = 0;
+
+			var->blue.length = 8;
+			var->blue.offset = 0;
+			var->blue.msb_right = 0;
+
+			var->transp.length = 0;
+			var->transp.offset = 0;
+			var->transp.msb_right = 0;
+			break;
+	case 32:
+			var->red.length = 8;
+			var->red.offset = 16;
+			var->red.msb_right = 0;
+
+			var->green.length = 8;
+			var->green.offset = 8;
+			var->green.msb_right = 0;
+
+			var->blue.length = 8;
+			var->blue.offset = 0;
+			var->blue.msb_right = 0;
+
+			var->transp.length = 8;
+			var->transp.offset = 24;
+			var->transp.msb_right = 0;
+			break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+			var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+			var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+				"pixclock set for 60Hz refresh = %u ps\n",
+				var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	/* nonstd used for YUV formats, but only RGB supported */
+	var->nonstd = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+static int mxcfb_setcolreg(u_int regno, u_int red, u_int green,
+		u_int blue, u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+			/*
+			 * 16-bit True Colour.  We encode the RGB value
+			 * according to the RGB bitfield information.
+			 */
+			if (regno < 16) {
+				u32 *pal = fbi->pseudo_palette;
+
+				val = _chan_to_field(red, &fbi->var.red);
+				val |= _chan_to_field(green, &fbi->var.green);
+				val |= _chan_to_field(blue, &fbi->var.blue);
+
+				pal[regno] = val;
+				ret = 0;
+			}
+			break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+			break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd,
+		unsigned long arg)
+{
+	int retval = 0;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	switch (cmd) {
+	case MXCFB_SET_GBL_ALPHA:
+			{
+				struct mxcfb_gbl_alpha ga;
+				if (copy_from_user(&ga,
+						(void *)arg, sizeof(ga))) {
+					retval = -EFAULT;
+					break;
+				}
+
+				retval =
+					ipu_sdc_set_global_alpha(
+							(bool) ga.enable,
+							ga.alpha);
+				dev_dbg(fbi->device, "Set global alpha to %d\n",
+						ga.alpha);
+				break;
+			}
+	case MXCFB_SET_CLR_KEY:
+			{
+				struct mxcfb_color_key key;
+				if (copy_from_user(&key,
+						(void *)arg, sizeof(key))) {
+					retval = -EFAULT;
+					break;
+				}
+
+				retval = ipu_sdc_set_color_key(
+						MEM_SDC_BG, key.enable,
+						key.color_key);
+				dev_dbg(fbi->device, "Set color key"
+						"to 0x%08X\n",
+						key.color_key);
+				break;
+			}
+
+	default:
+			retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl_ovl(struct fb_info *fbi, unsigned int cmd,
+		unsigned long arg)
+{
+	int retval = 0;
+	int __user *argp = (void __user *)arg;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	switch (cmd) {
+	case FBIO_ALLOC:
+			{
+				int size;
+				struct mxcfb_alloc_list *mem;
+
+				mem = kzalloc(sizeof(*mem), GFP_KERNEL);
+				if (mem == NULL)
+					return -ENOMEM;
+
+				if (get_user(size, argp))
+					return -EFAULT;
+
+				mem->size = PAGE_ALIGN(size);
+
+				mem->cpu_addr =
+					dma_alloc_coherent(fbi->device,
+							size,
+							&mem->phy_addr,
+							GFP_DMA);
+
+				if (mem->cpu_addr == NULL) {
+					kfree(mem);
+					return -ENOMEM;
+				}
+
+				list_add(&mem->list, &fb_alloc_list);
+
+				dev_dbg(fbi->device, "allocated %d"
+						"bytes @ 0x%08X\n",
+						mem->size, mem->phy_addr);
+
+				if (put_user(mem->phy_addr, argp))
+					return -EFAULT;
+
+				break;
+			}
+	case FBIO_FREE:
+			{
+				unsigned long offset;
+				struct mxcfb_alloc_list *mem;
+
+				if (get_user(offset, argp))
+					return -EFAULT;
+
+				retval = -EINVAL;
+				list_for_each_entry(mem,
+						&fb_alloc_list, list) {
+					if (mem->phy_addr == offset) {
+						list_del(&mem->list);
+						dma_free_coherent(fbi->device,
+								mem->size,
+								mem->cpu_addr,
+								mem->phy_addr);
+						kfree(mem);
+						retval = 0;
+						break;
+					}
+				}
+
+				break;
+			}
+	case MXCFB_SET_OVERLAY_POS:
+			{
+				struct mxcfb_pos pos;
+				if (copy_from_user(&pos,
+						(void *)arg, sizeof(pos))) {
+					retval = -EFAULT;
+					break;
+				}
+
+				retval = ipu_disp_set_window_pos(
+						mxc_fbi->ipu_ch,
+						pos.x, pos.y);
+				break;
+			}
+	default:
+			retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *info)
+{
+	int retval;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "blank = %d\n", blank);
+
+	if (mxc_fbi->blank == blank)
+		return 0;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+			ipu_disable_channel(MEM_SDC_BG, true);
+			gpio_lcd_inactive();
+			break;
+
+	case FB_BLANK_UNBLANK:
+			gpio_lcd_active();
+			ipu_enable_channel(MEM_SDC_BG);
+			break;
+	}
+	return 0;
+}
+
+/*
+ * mxcfb_blank_ovl():
+ *      Blank the display.
+ */
+static int mxcfb_blank_ovl(int blank, struct fb_info *info)
+{
+	int retval;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "ovl blank = %d\n", blank);
+
+	if (mxc_fbi->blank == blank)
+		return 0;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+			ipu_disable_channel(MEM_SDC_FG, true);
+			break;
+	case FB_BLANK_UNBLANK:
+			ipu_enable_channel(MEM_SDC_FG);
+			break;
+	}
+	return 0;
+}
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the
+ * FB_VMODE_YWRAP flag
+ *
+ * @param	var     Variable screen buffer information
+ * @param	info    Framebuffer information pointer
+ */
+	static int
+mxcfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+	unsigned long lock_flags = 0;
+	int retval;
+	u_int y_bottom;
+	unsigned long base;
+
+	retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+			(mxcfb_drv_data.suspended == false));
+	if (retval < 0)
+		return retval;
+
+	if (var->xoffset > 0) {
+		dev_dbg(info->device, "x panning not supported\n");
+		return -EINVAL;
+	}
+
+	if ((info->var.xoffset == var->xoffset) &&
+			(info->var.yoffset == var->yoffset))
+		return 0;	/* No change, do nothing*/
+
+	y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP))
+		y_bottom += var->yres;
+
+	if (y_bottom > info->var.yres_virtual)
+		return -EINVAL;
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	down(&mxc_fbi->flip_sem);
+
+	spin_lock_irqsave(&mxc_fbi->fb_lock, lock_flags);
+
+	dev_dbg(info->device, "Updating SDC BG buf %d address=0x%08lX\n",
+			mxc_fbi->cur_ipu_buf, base);
+
+	mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+	if (ipu_update_channel_buffer(
+				mxc_fbi->ipu_ch,
+				IPU_INPUT_BUFFER,
+				mxc_fbi->cur_ipu_buf, base) == 0) {
+		ipu_select_buffer(mxc_fbi->ipu_ch,
+				IPU_INPUT_BUFFER,
+				mxc_fbi->cur_ipu_buf);
+		ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+		ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+	} else
+		dev_err(info->device,
+				"Error updating SDC buf %d"
+				"to address=0x%08lX\n",
+				mxc_fbi->cur_ipu_buf, base);
+
+	spin_unlock_irqrestore(&mxc_fbi->fb_lock, lock_flags);
+
+	dev_dbg(info->device, "Update complete\n");
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+	return 0;
+}
+
+/*
+ * Function to handle custom mmap for MXC framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       vma     Pointer to vm_area_struct
+ */
+static int mxcfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
+{
+	bool found = false;
+	u32 len;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	struct mxcfb_alloc_list *mem;
+
+	if (offset < fbi->fix.smem_len) {
+		/* mapping framebuffer memory */
+		len = fbi->fix.smem_len - offset;
+		vma->vm_pgoff = (fbi->fix.smem_start + offset) >> PAGE_SHIFT;
+	} else {
+		list_for_each_entry(mem, &fb_alloc_list, list) {
+			if (offset == mem->phy_addr) {
+				found = true;
+				len = mem->size;
+				break;
+			}
+		}
+		if (!found)
+			return -EINVAL;
+	}
+
+	len = PAGE_ALIGN(len);
+	if (vma->vm_end - vma->vm_start > len)
+		return -EINVAL;
+
+	/* make buffers write-thru cacheable */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) &
+			~L_PTE_BUFFERABLE);
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		dev_dbg(fbi->device, "mmap remap_pfn_range failed\n");
+		return -ENOBUFS;
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control
+ * functions that are invoked by the core framebuffer
+ * driver to perform operations like blitting, rectangle
+ * filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_ioctl = mxcfb_ioctl,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+};
+
+static struct fb_ops mxcfb_ovl_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_ioctl = mxcfb_ioctl_ovl,
+	.fb_mmap = mxcfb_mmap,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank_ovl,
+};
+
+static irqreturn_t mxcfb_vsync_irq_handler(int irq, void *dev_id)
+{
+	struct mxcfb_data *fb_data = dev_id;
+
+	ipu_disable_irq(irq);
+
+	fb_data->vsync_flag = 1;
+	wake_up_interruptible(&fb_data->vsync_wq);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id)
+{
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	up(&mxc_fbi->flip_sem);
+	ipu_disable_irq(irq);
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called
+ * from IRQ context,unlike the blank functions above,
+ * so we may sleep.
+ */
+
+/*
+ * Suspends the framebuffer and blanks the screen.
+ * Power management support
+ */
+static int mxcfb_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)drv_data->fbi->par;
+	struct mxcfb_info *mxc_fbi_ovl =
+		(struct mxcfb_info *)drv_data->fbi_ovl->par;
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+	void *fbmem;
+#endif
+
+	drv_data->suspended = true;
+
+	acquire_console_sem();
+	fb_set_suspend(drv_data->fbi, 1);
+	fb_set_suspend(drv_data->fbi_ovl, 1);
+	release_console_sem();
+
+	if (mxc_fbi_ovl->blank == FB_BLANK_UNBLANK)
+		ipu_disable_channel(MEM_SDC_FG, true);
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+		if (drv_data->fbi->fix.smem_start != FB_RAM_BASE_ADDR) {
+			fbmem = ioremap(FB_RAM_BASE_ADDR, FB_RAM_SIZE);
+			memcpy(fbmem, drv_data->fbi->screen_base, FB_RAM_SIZE);
+			iounmap(fbmem);
+			mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+			ipu_update_channel_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					mxc_fbi->cur_ipu_buf,
+					FB_RAM_BASE_ADDR);
+			ipu_select_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					mxc_fbi->cur_ipu_buf);
+		}
+		ipu_lowpwr_display_enable();
+#else
+		ipu_disable_channel(MEM_SDC_BG, true);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Resumes the framebuffer and unblanks the screen.
+ * Power management support
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)drv_data->fbi->par;
+	struct mxcfb_info *mxc_fbi_ovl =
+		(struct mxcfb_info *)drv_data->fbi_ovl->par;
+
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+		ipu_lowpwr_display_disable();
+		if (drv_data->fbi->fix.smem_start != FB_RAM_BASE_ADDR) {
+			mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+			ipu_update_channel_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					mxc_fbi->cur_ipu_buf,
+					drv_data->fbi->fix.
+					smem_start);
+			ipu_select_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					mxc_fbi->cur_ipu_buf);
+		}
+#else
+		ipu_enable_channel(MEM_SDC_BG);
+#endif
+	}
+
+	if (mxc_fbi_ovl->blank == FB_BLANK_UNBLANK)
+		ipu_enable_channel(MEM_SDC_FG);
+
+	acquire_console_sem();
+	fb_set_suspend(drv_data->fbi, 0);
+	fb_set_suspend(drv_data->fbi_ovl, 0);
+	release_console_sem();
+
+	wake_up_interruptible(&drv_data->suspend_wq);
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*
+ * Main framebuffer functions
+ */
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.
+ * This buffer is remapped into a non-cached, non-buffered,
+ * memory region to allow palette and pixel writes to occur
+ * without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur
+ * at the new region.
+ *
+ * @param	fbi     framebuffer information pointer
+ *
+ * @param	use_internal_ram flag on whether to use
+ *			internal RAM for memory
+ *
+ * @return	Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi,
+		bool use_internal_ram)
+{
+	int retval = 0;
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if (use_internal_ram) {
+		fbi->fix.smem_len = FB_RAM_SIZE;
+		fbi->fix.smem_start = FB_RAM_BASE_ADDR;
+		if (fbi->fix.smem_len <
+				(fbi->var.yres_virtual *
+				 fbi->fix.line_length)) {
+			dev_err(fbi->device,
+					"Not enough internal RAM for"
+					"framebuffer configuration\n");
+			retval = -EINVAL;
+			goto err0;
+		}
+
+		if (request_mem_region(fbi->fix.smem_start,
+					fbi->fix.smem_len,
+					fbi->device->driver->name) == NULL) {
+			dev_err(fbi->device,
+					"Unable to request internal RAM\n");
+			retval = -ENOMEM;
+			goto err0;
+		}
+
+		fbi->screen_base = ioremap(fbi->fix.smem_start,
+				fbi->fix.smem_len);
+		if (!fbi->screen_base) {
+			dev_err(fbi->device,
+					"Unable to map fb memory"
+					"to virtual address\n");
+			release_mem_region(fbi->fix.smem_start,
+					fbi->fix.smem_len);
+			retval = -EIO;
+			goto err0;
+		}
+
+		iram_clk = clk_get(NULL, "iram_clk");
+		clk_enable(iram_clk);
+	} else
+#endif
+	{
+		fbi->fix.smem_len = fbi->var.yres_virtual *
+			fbi->fix.line_length;
+		fbi->screen_base =
+			dma_alloc_writecombine(fbi->device,
+					fbi->fix.smem_len,
+					(dma_addr_t *) &fbi->fix.smem_start,
+					GFP_DMA);
+
+		if (fbi->screen_base == 0) {
+			dev_err(fbi->device,
+					"Unable to allocate framebuffer"
+					"memory\n");
+			retval = -EBUSY;
+			goto err0;
+		}
+	}
+
+	dev_dbg(fbi->device, "allocated fb @ paddr=0x%08X, size=%d.\n",
+			(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_size = fbi->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+
+	return 0;
+
+err0:
+	fbi->fix.smem_len = 0;
+	fbi->fix.smem_start = 0;
+	fbi->screen_base = NULL;
+	return retval;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if (fbi->fix.smem_start == FB_RAM_BASE_ADDR) {
+		iounmap(fbi->screen_base);
+		release_mem_region(fbi->fix.smem_start,
+				fbi->fix.smem_len);
+		fbi->fix.smem_start = 0;
+		fbi->fix.smem_len = 0;
+		clk_disable(iram_clk);
+	} else
+#endif
+	{
+		dma_free_writecombine(fbi->device, fbi->fix.smem_len,
+				fbi->screen_base, fbi->fix.smem_start);
+	}
+	fbi->screen_base = 0;
+	fbi->fix.smem_start = 0;
+	fbi->fix.smem_len = 0;
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev,
+		struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	fbi->var.activate = FB_ACTIVATE_NOW;
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	spin_lock_init(&mxcfbi->fb_lock);
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are
+ * performed in this routine: Framebuffer initialization, Memory
+ * allocation and mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	char *mode = pdev->dev.platform_data;
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+	struct fb_info *fbi_ovl;
+	int ret = 0;
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	mxcfbi->ipu_ch_irq = IPU_IRQ_SDC_BG_EOF;
+	mxcfbi->cur_ipu_buf = 0;
+	mxcfbi->ipu_ch = MEM_SDC_BG;
+
+	ipu_sdc_set_global_alpha(true, 0xFF);
+	ipu_sdc_set_color_key(MEM_SDC_BG, false, 0);
+
+	if (ipu_request_irq(IPU_IRQ_SDC_BG_EOF,
+				mxcfb_irq_handler, 0,
+				MXCFB_NAME, fbi) != 0) {
+		dev_err(&pdev->dev, "Error registering BG irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	ipu_disable_irq(IPU_IRQ_SDC_BG_EOF);
+
+	if (fb_mode == NULL)
+		fb_mode = mode;
+
+	if (!fb_find_mode(&fbi->var, fbi, fb_mode, mxcfb_modedb,
+				mxcfb_modedb_sz, NULL, default_bpp)) {
+		ret = -EBUSY;
+		goto err2;
+	}
+
+	fb_videomode_to_modelist(mxcfb_modedb, mxcfb_modedb_sz, &fbi->modelist);
+
+	/* Default Y virtual size is 2x panel size */
+#ifndef CONFIG_FB_MXC_INTERNAL_MEM
+	fbi->var.yres_virtual = fbi->var.yres * 2;
+#endif
+
+	mxcfb_drv_data.fbi = fbi;
+	mxcfb_drv_data.backlight_level = 255;
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	mxcfbi->blank = FB_BLANK_NORMAL;
+	ret = mxcfb_set_par(fbi);
+	if (ret < 0)
+		goto err2;
+
+	mxcfb_blank(FB_BLANK_UNBLANK, fbi);
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0)
+		goto err2;
+
+	/*
+	 * Initialize Overlay FB structures
+	 */
+	fbi_ovl = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ovl_ops);
+	if (!fbi_ovl) {
+		ret = -ENOMEM;
+		goto err3;
+	}
+
+	mxcfb_drv_data.fbi_ovl = fbi_ovl;
+	mxcfbi = (struct mxcfb_info *)fbi_ovl->par;
+
+	mxcfbi->ipu_ch_irq = IPU_IRQ_SDC_FG_EOF;
+	mxcfbi->cur_ipu_buf = 0;
+	mxcfbi->ipu_ch = MEM_SDC_FG;
+
+	if (ipu_request_irq(IPU_IRQ_SDC_FG_EOF, mxcfb_irq_handler, 0,
+				MXCFB_NAME, fbi_ovl) != 0) {
+		dev_err(fbi->device, "Error registering FG irq handler.\n");
+		ret = -EBUSY;
+		goto err4;
+	}
+
+	ipu_disable_irq(mxcfbi->ipu_ch_irq);
+
+	/* Default Y virtual size is 2x panel size */
+	fbi_ovl->var = fbi->var;
+	fbi_ovl->var.yres_virtual = fbi->var.yres * 2;
+
+	/* Overlay is blanked by default */
+	mxcfbi->blank = FB_BLANK_NORMAL;
+
+	ret = mxcfb_set_par(fbi_ovl);
+	if (ret < 0)
+		goto err5;
+
+	/*
+	 * Register overlay framebuffer
+	 */
+	ret = register_framebuffer(fbi_ovl);
+	if (ret < 0)
+		goto err5;
+
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	init_waitqueue_head(&mxcfb_drv_data.vsync_wq);
+	if (!cpu_is_mx31()) {
+		if (ipu_request_irq(IPU_IRQ_SDC_DISP3_VSYNC,
+						mxcfb_vsync_irq_handler,
+						0, MXCFB_NAME,
+						&mxcfb_drv_data) != 0)
+			goto err6;
+
+		ipu_disable_irq(IPU_IRQ_SDC_DISP3_VSYNC);
+	}
+
+	pr_info("mxcfb: fb registered, using mode %s\n", fb_mode);
+	return 0;
+
+err6:
+	unregister_framebuffer(fbi_ovl);
+err5:
+	ipu_free_irq(IPU_IRQ_SDC_FG_EOF, fbi_ovl);
+err4:
+	fb_dealloc_cmap(&fbi_ovl->cmap);
+	framebuffer_release(fbi_ovl);
+err3:
+	unregister_framebuffer(fbi);
+err2:
+	ipu_free_irq(IPU_IRQ_SDC_BG_EOF, fbi);
+err1:
+	fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+err0:
+	printk(KERN_ERR "mxcfb: failed to register fb\n");
+	return ret;
+}
+
+/*!
+ * This structure contains pointers to the power
+ * management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		.name = MXCFB_NAME,
+	},
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*
+ * Parse user specified options (`video=trident:')
+ * example:
+ * 	video=trident:800x600,bpp=16,noaccel
+ */
+int mxcfb_setup(char *options)
+{
+	char *opt;
+	if (!options || !*options)
+		return 0;
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+	return 0;
+}
+
+/*!
+ * Main entry function for the framebuffer. The function
+ * registers the power management callback functions with
+ * the kernel and also registers the MXCFB callback functions
+ * with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+int __init mxcfb_init(void)
+{
+	int ret = 0;
+#ifndef MODULE
+	char *option = NULL;
+#endif
+
+#ifndef MODULE
+	if (fb_get_options("mxcfb", &option))
+		return -ENODEV;
+	mxcfb_setup(option);
+#endif
+
+	ret = platform_driver_register(&mxcfb_driver);
+	return ret;
+}
+
+void mxcfb_exit(void)
+{
+	struct fb_info *fbi = mxcfb_drv_data.fbi;
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	fbi = mxcfb_drv_data.fbi_ovl;
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC framebuffer driver");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("fb");
diff --git a/drivers/video/mxc/mxcfb_claa_wvga.c b/drivers/video/mxc/mxcfb_claa_wvga.c
new file mode 100644
index 0000000..9eea5d0
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_claa_wvga.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_claa_wvga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <mach/mxcfb.h>
+#include <linux/regulator/consumer.h>
+
+static void lcd_poweron(void);
+static void lcd_poweroff(void);
+
+static struct platform_device *plcd_dev;
+static struct regulator *io_reg;
+static struct regulator *core_reg;
+static int lcd_on;
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 800x480 @ 55 Hz , pixel clk @ 25MHz */
+	 "CLAA-WVGA", 55, 800, 480, 40000, 80, 0, 10, 0, 20, 10,
+	 FB_SYNC_CLK_INVERT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static void lcd_init_fb(struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+
+	memset(&var, 0, sizeof(var));
+
+	fb_videomode_to_var(&var, &video_modes[0]);
+
+	var.activate = FB_ACTIVATE_ALL;
+	var.yres_virtual = var.yres * 2;
+
+	acquire_console_sem();
+	info->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(info, &var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static int lcd_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+
+	if (strcmp(event->info->fix.id, "DISP3 BG")) {
+		return 0;
+	}
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		lcd_init_fb(event->info);
+		lcd_poweron();
+		break;
+	case FB_EVENT_BLANK:
+		if ((event->info->var.xres != 800) ||
+		    (event->info->var.yres != 480)) {
+			break;
+		}
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			lcd_poweron();
+		} else {
+			lcd_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = lcd_fb_event,
+};
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit lcd_probe(struct platform_device *pdev)
+{
+	int i;
+	struct mxc_lcd_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat) {
+		if (plat->reset)
+			plat->reset();
+
+		io_reg = regulator_get(&pdev->dev, plat->io_reg);
+		if (IS_ERR(io_reg))
+			io_reg = NULL;
+		core_reg = regulator_get(&pdev->dev, plat->core_reg);
+		if (!IS_ERR(core_reg)) {
+			regulator_set_voltage(io_reg, 1800000, 1800000);
+		} else {
+			core_reg = NULL;
+		}
+	}
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+			fb_show_logo(registered_fb[i], 0);
+			lcd_poweron();
+		} else if (strcmp(registered_fb[i]->fix.id, "DISP3 FG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+		}
+	}
+
+	fb_register_client(&nb);
+
+	plcd_dev = pdev;
+
+	return 0;
+}
+
+static int __devexit lcd_remove(struct platform_device *pdev)
+{
+	fb_unregister_client(&nb);
+	lcd_poweroff();
+	if (io_reg)
+		regulator_put(io_reg);
+	if (core_reg)
+		regulator_put(core_reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lcd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int lcd_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lcd_suspend NULL
+#define lcd_resume NULL
+#endif
+
+/*!
+ * platform driver structure for CLAA WVGA
+ */
+static struct platform_driver lcd_driver = {
+	.driver = {
+		   .name = "lcd_claa"},
+	.probe = lcd_probe,
+	.remove = __devexit_p(lcd_remove),
+	.suspend = lcd_suspend,
+	.resume = lcd_resume,
+};
+
+/*
+ * Send Power On commands to L4F00242T03
+ *
+ */
+static void lcd_poweron(void)
+{
+	if (lcd_on)
+		return;
+
+	dev_dbg(&plcd_dev->dev, "turning on LCD\n");
+	if (core_reg)
+		regulator_enable(core_reg);
+	if (io_reg)
+		regulator_enable(io_reg);
+	lcd_on = 1;
+}
+
+/*
+ * Send Power Off commands to L4F00242T03
+ *
+ */
+static void lcd_poweroff(void)
+{
+	lcd_on = 0;
+	dev_dbg(&plcd_dev->dev, "turning off LCD\n");
+	if (io_reg)
+		regulator_disable(io_reg);
+	if (core_reg)
+		regulator_disable(core_reg);
+}
+
+static int __init claa_lcd_init(void)
+{
+	return platform_driver_register(&lcd_driver);
+}
+
+static void __exit claa_lcd_exit(void)
+{
+	platform_driver_unregister(&lcd_driver);
+}
+
+module_init(claa_lcd_init);
+module_exit(claa_lcd_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("CLAA WVGA LCD init driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/mxc/mxcfb_epson_vga.c b/drivers/video/mxc/mxcfb_epson_vga.c
new file mode 100644
index 0000000..8d534f9
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_epson_vga.c
@@ -0,0 +1,270 @@
+/*
+ * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_epson_vga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/regulator/regulator.h>
+#include <linux/spi/spi.h>
+
+#include <mach/mxcfb.h>
+#include <asm/mach-types.h>
+
+static struct spi_device *lcd_spi;
+
+static void lcd_init(void);
+static void lcd_poweron(void);
+static void lcd_poweroff(void);
+
+static void (*lcd_reset) (void);
+static struct regulator *io_reg;
+static struct regulator *core_reg;
+
+static struct fb_videomode video_modes[] = {
+	{
+		/* 480x640 @ 60 Hz */
+		"Epson-VGA", 60, 480, 640, 41701, 60, 41, 10, 5, 20, 10,
+		FB_SYNC_CLK_INVERT | FB_SYNC_OE_ACT_HIGH,
+		FB_VMODE_NONINTERLACED,
+		0,},
+};
+
+static void lcd_init_fb(struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+
+	memset(&var, 0, sizeof(var));
+
+	fb_videomode_to_var(&var, &video_modes[0]);
+
+	if (machine_is_mx31_3ds()) {
+		var.upper_margin = 0;
+		var.left_margin = 0;
+	}
+
+	var.activate = FB_ACTIVATE_ALL;
+	var.yres_virtual = var.yres * 2;
+
+	acquire_console_sem();
+	info->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(info, &var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static int lcd_fb_event(struct notifier_block *nb,
+				unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+
+	if (strcmp(event->info->fix.id, "DISP3 BG"))
+		return 0;
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		lcd_init_fb(event->info);
+		lcd_poweron();
+			break;
+	case FB_EVENT_BLANK:
+		if ((event->info->var.xres != 480) ||
+				(event->info->var.yres != 640))
+			break;
+
+		if (*((int *)event->data) == FB_BLANK_UNBLANK)
+			lcd_poweron();
+		else
+			lcd_poweroff();
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = lcd_fb_event,
+};
+
+/*!
+ * This function is called whenever the SPI slave device
+ * is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit lcd_spi_probe(struct spi_device *spi)
+{
+	int i;
+	struct mxc_lcd_platform_data *plat = spi->dev.platform_data;
+
+	lcd_spi = spi;
+
+	if (plat) {
+		io_reg = regulator_get(&spi->dev, plat->io_reg);
+		if (!IS_ERR(io_reg)) {
+			regulator_set_voltage(io_reg, 1800000);
+			regulator_enable(io_reg);
+		}
+
+		core_reg = regulator_get(&spi->dev, plat->core_reg);
+		if (!IS_ERR(core_reg)) {
+			regulator_set_voltage(core_reg, 2800000);
+			regulator_enable(core_reg);
+		}
+
+		lcd_reset = plat->reset;
+		if (lcd_reset)
+			lcd_reset();
+
+	}
+
+	spi->bits_per_word = 9;
+	spi_setup(spi);
+
+	lcd_init();
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+			fb_show_logo(registered_fb[i], 0);
+			lcd_poweron();
+		}
+	}
+
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int __devexit lcd_spi_remove(struct spi_device *spi)
+{
+	fb_unregister_client(&nb);
+	lcd_poweroff();
+	regulator_put(io_reg, &spi->dev);
+	regulator_put(core_reg, &spi->dev);
+
+	return 0;
+}
+
+static int lcd_suspend(struct spi_device *spi, pm_message_t message)
+{
+	return 0;
+}
+
+static int lcd_resume(struct spi_device *spi)
+{
+	return 0;
+}
+
+/*!
+ * spi driver structure for LTV350QV
+ */
+static struct spi_driver lcd_spi_dev_driver = {
+
+	.driver = {
+		.name = "lcd_spi",
+		.owner = THIS_MODULE,
+	},
+	.probe = lcd_spi_probe,
+	.remove = __devexit_p(lcd_spi_remove),
+	.suspend = lcd_suspend,
+	.resume = lcd_resume,
+};
+
+#define param(x) ((x) | 0x100)
+
+/*
+ * Send init commands to L4F00242T03
+ *
+ */
+static void lcd_init(void)
+{
+	const u16 cmd[] = { 0x36, param(0), 0x3A, param(0x60) };
+
+	dev_dbg(&lcd_spi->dev, "initializing LCD\n");
+	spi_write(lcd_spi, (const u8 *)cmd, ARRAY_SIZE(cmd));
+}
+
+static int lcd_on;
+/*
+ * Send Power On commands to L4F00242T03
+ *
+ */
+static void lcd_poweron(void)
+{
+	const u16 slpout = 0x11;
+	const u16 dison = 0x29;
+
+	if (lcd_on)
+		return;
+
+	dev_dbg(&lcd_spi->dev, "turning on LCD\n");
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&slpout, 1);
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&dison, 1);
+	lcd_on = 1;
+}
+
+/*
+ * Send Power Off commands to L4F00242T03
+ *
+ */
+static void lcd_poweroff(void)
+{
+	const u16 slpin = 0x10;
+	const u16 disoff = 0x28;
+
+	if (!lcd_on)
+		return;
+
+	dev_dbg(&lcd_spi->dev, "turning off LCD\n");
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&disoff, 1);
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&slpin, 1);
+	lcd_on = 0;
+}
+
+static int __init epson_lcd_init(void)
+{
+	return spi_register_driver(&lcd_spi_dev_driver);
+}
+
+static void __exit epson_lcd_exit(void)
+{
+	spi_unregister_driver(&lcd_spi_dev_driver);
+}
+
+module_init(epson_lcd_init);
+module_exit(epson_lcd_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Epson VGA LCD init driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/mxc/mxcfb_epson_vga_ipu.c b/drivers/video/mxc/mxcfb_epson_vga_ipu.c
new file mode 100644
index 0000000..046cac1
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_epson_vga_ipu.c
@@ -0,0 +1,288 @@
+/*
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_epson_vga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/mxcfb.h>
+#include <mach/ipu.h>
+#include <asm/mach-types.h>
+
+static struct device *lcd_dev;
+
+static void lcd_init(void);
+static void lcd_poweron(void);
+static void lcd_poweroff(void);
+
+static void (*lcd_reset) (void);
+static struct regulator *io_reg;
+static struct regulator *core_reg;
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 480x640 @ 60 Hz */
+	 "Epson-VGA", 60, 480, 640, 41701, 60, 41, 10, 5, 20, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static void lcd_init_fb(struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+
+	memset(&var, 0, sizeof(var));
+
+	fb_videomode_to_var(&var, &video_modes[0]);
+
+	if (machine_is_mx31_3ds()) {
+		var.upper_margin = 0;
+		var.left_margin = 0;
+	}
+
+	var.activate = FB_ACTIVATE_ALL;
+	var.yres_virtual = var.yres * 2;
+
+	acquire_console_sem();
+	info->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(info, &var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static int lcd_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+
+	if (strcmp(event->info->fix.id, "DISP3 BG")) {
+		return 0;
+	}
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		lcd_init_fb(event->info);
+		lcd_poweron();
+		break;
+	case FB_EVENT_BLANK:
+		if ((event->info->var.xres != 480) ||
+		    (event->info->var.yres != 640)) {
+			break;
+		}
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			lcd_poweron();
+		} else {
+			lcd_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = lcd_fb_event,
+};
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit lcd_probe(struct device *dev)
+{
+	int i;
+	struct mxc_lcd_platform_data *plat = dev->platform_data;
+
+	lcd_dev = dev;
+
+	if (plat) {
+		io_reg = regulator_get(dev, plat->io_reg);
+		if (!IS_ERR(io_reg)) {
+			regulator_set_voltage(io_reg, 1800000, 1800000);
+			regulator_enable(io_reg);
+		}
+		core_reg = regulator_get(dev, plat->core_reg);
+		if (!IS_ERR(core_reg)) {
+			regulator_set_voltage(core_reg, 2800000, 2800000);
+			regulator_enable(core_reg);
+		}
+
+		lcd_reset = plat->reset;
+		if (lcd_reset)
+			lcd_reset();
+	}
+
+	lcd_init();
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+			fb_show_logo(registered_fb[i], 0);
+			lcd_poweron();
+		}
+	}
+
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int __devinit lcd_plat_probe(struct platform_device *pdev)
+{
+	ipu_adc_sig_cfg_t sig;
+	ipu_channel_params_t param;
+
+	memset(&sig, 0, sizeof(sig));
+	sig.ifc_width = 9;
+	sig.clk_pol = 1;
+	ipu_init_async_panel(0, IPU_PANEL_SERIAL, 90, IPU_PIX_FMT_GENERIC, sig);
+
+	memset(&param, 0, sizeof(param));
+	ipu_init_channel(DIRECT_ASYNC1, &param);
+
+	return lcd_probe(&pdev->dev);
+}
+
+static int __devexit lcd_remove(struct device *dev)
+{
+	fb_unregister_client(&nb);
+	lcd_poweroff();
+	regulator_put(io_reg);
+	regulator_put(core_reg);
+
+	return 0;
+}
+
+static int __devexit lcd_plat_remove(struct platform_device *pdev)
+{
+	return lcd_remove(&pdev->dev);
+}
+
+static struct platform_driver lcd_plat_driver = {
+	.driver = {
+		   .name = "lcd_spi",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = lcd_plat_probe,
+	.remove = __devexit_p(lcd_plat_remove),
+};
+
+#define param(x) ((x) | 0x100)
+
+/*
+ * Send init commands to L4F00242T03
+ *
+ */
+static void lcd_init(void)
+{
+
+	dev_dbg(lcd_dev, "initializing LCD\n");
+
+	ipu_disp_direct_write(DIRECT_ASYNC1, 0x36, 0);
+	ipu_disp_direct_write(DIRECT_ASYNC1, 0x100, 0);
+	ipu_disp_direct_write(DIRECT_ASYNC1, 0x3A, 0);
+	ipu_disp_direct_write(DIRECT_ASYNC1, 0x160, 0);
+	msleep(1);
+	ipu_uninit_channel(DIRECT_ASYNC1);
+}
+
+static int lcd_on;
+/*
+ * Send Power On commands to L4F00242T03
+ *
+ */
+static void lcd_poweron(void)
+{
+	const u16 slpout = 0x11;
+	const u16 dison = 0x29;
+	ipu_channel_params_t param;
+
+	if (lcd_on)
+		return;
+
+	dev_dbg(lcd_dev, "turning on LCD\n");
+
+	memset(&param, 0, sizeof(param));
+	ipu_init_channel(DIRECT_ASYNC1, &param);
+	ipu_disp_direct_write(DIRECT_ASYNC1, slpout, 0);
+	msleep(60);
+	ipu_disp_direct_write(DIRECT_ASYNC1, dison, 0);
+	msleep(1);
+	ipu_uninit_channel(DIRECT_ASYNC1);
+
+	lcd_on = 1;
+}
+
+/*
+ * Send Power Off commands to L4F00242T03
+ *
+ */
+static void lcd_poweroff(void)
+{
+	const u16 slpin = 0x10;
+	const u16 disoff = 0x28;
+	ipu_channel_params_t param;
+
+	if (!lcd_on)
+		return;
+
+	dev_dbg(lcd_dev, "turning off LCD\n");
+
+	memset(&param, 0, sizeof(param));
+	ipu_init_channel(DIRECT_ASYNC1, &param);
+	ipu_disp_direct_write(DIRECT_ASYNC1, disoff, 0);
+	msleep(60);
+	ipu_disp_direct_write(DIRECT_ASYNC1, slpin, 0);
+	msleep(1);
+	ipu_uninit_channel(DIRECT_ASYNC1);
+
+	lcd_on = 0;
+}
+
+static int __init epson_lcd_init(void)
+{
+	return platform_driver_register(&lcd_plat_driver);
+}
+
+static void __exit epson_lcd_exit(void)
+{
+}
+
+module_init(epson_lcd_init);
+module_exit(epson_lcd_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Epson VGA LCD init driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/mxc/mxcfb_modedb.c b/drivers/video/mxc/mxcfb_modedb.c
new file mode 100644
index 0000000..abd4886
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_modedb.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <mach/mxcfb.h>
+
+struct fb_videomode mxcfb_modedb[] = {
+	{
+		/* 240x320 @ 60 Hz */
+		"Sharp-QVGA", 60, 240, 320, 185925, 9, 16, 7, 9, 1, 1,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE |
+			FB_SYNC_CLK_INVERT | FB_SYNC_DATA_INVERT |
+			FB_SYNC_CLK_IDLE_EN,
+		FB_VMODE_NONINTERLACED,
+		0,},
+	{
+		/* 240x33 @ 60 Hz */
+		"Sharp-CLI", 60, 240, 33, 185925, 9, 16, 7, 9 + 287, 1, 1,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE |
+			FB_SYNC_CLK_INVERT | FB_SYNC_DATA_INVERT |
+			FB_SYNC_CLK_IDLE_EN,
+		FB_VMODE_NONINTERLACED,
+		0,},
+	{
+		/* 640x480 @ 60 Hz */
+		"NEC-VGA", 60, 640, 480, 38255, 144, 0, 34, 40, 1, 1,
+		FB_SYNC_VERT_HIGH_ACT | FB_SYNC_OE_ACT_HIGH,
+		FB_VMODE_NONINTERLACED,
+		0,},
+	{
+		/* NTSC TV output */
+		"TV-NTSC", 60, 640, 480, 37538,
+		38, 858 - 640 - 38 - 3,
+		36, 518 - 480 - 36 - 1,
+		3, 1,
+		0,
+		FB_VMODE_NONINTERLACED,
+		0,},
+	{
+		/* PAL TV output */
+		"TV-PAL", 50, 640, 480, 37538,
+		38, 960 - 640 - 38 - 32,
+		32, 555 - 480 - 32 - 3,
+		32, 3,
+		0,
+		FB_VMODE_NONINTERLACED,
+		0,},
+	{
+		/* TV output VGA mode, 640x480 @ 65 Hz */
+		"TV-VGA", 60, 640, 480, 40574, 35, 45, 9, 1, 46, 5,
+		0, FB_VMODE_NONINTERLACED, 0,
+	},
+};
+
+int mxcfb_modedb_sz = ARRAY_SIZE(mxcfb_modedb);
diff --git a/drivers/video/mxc/tve.c b/drivers/video/mxc/tve.c
new file mode 100644
index 0000000..1d751f0
--- /dev/null
+++ b/drivers/video/mxc/tve.c
@@ -0,0 +1,705 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file tve.c
+ * @brief Driver for i.MX TV encoder
+ *
+ * @ingroup Framebuffer
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/clk.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/irq.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <mach/mxcfb.h>
+#include <linux/regulator/consumer.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+#define TVE_ENABLE			(1UL)
+#define TVE_DAC_FULL_RATE		(0UL<<1)
+#define TVE_DAC_DIV2_RATE		(1UL<<1)
+#define TVE_DAC_DIV4_RATE		(2UL<<1)
+#define TVE_IPU_CLK_ENABLE		(1UL<<3)
+
+#define CD_LM_INT		0x00000001
+#define CD_SM_INT		0x00000002
+#define CD_MON_END_INT		0x00000004
+#define CD_CH_0_LM_ST		0x00000001
+#define CD_CH_0_SM_ST		0x00000010
+#define CD_CH_1_LM_ST		0x00000002
+#define CD_CH_1_SM_ST		0x00000020
+#define CD_CH_2_LM_ST		0x00000004
+#define CD_CH_2_SM_ST		0x00000040
+#define CD_MAN_TRIG		0x00000100
+
+#define TVE_STAND_MASK			(0x0F<<8)
+#define TVE_NTSC_STAND			(0UL<<8)
+#define TVE_PAL_STAND			(3UL<<8)
+
+#define TVOUT_FMT_OFF			0
+#define TVOUT_FMT_NTSC			1
+#define TVOUT_FMT_PAL			2
+
+static int enabled;		/* enable power on or not */
+
+static struct fb_info *tve_fbi;
+
+struct tve_data {
+	struct platform_device *pdev;
+	int cur_mode;
+	int output_mode;
+	int detect;
+	void *base;
+	int irq;
+	struct clk *clk;
+	struct regulator *dac_reg;
+	struct regulator *dig_reg;
+	struct delayed_work cd_work;
+} tve;
+
+struct tve_reg_mapping {
+	u32 tve_com_conf_reg;
+	u32 tve_cd_cont_reg;
+	u32 tve_int_cont_reg;
+	u32 tve_stat_reg;
+	u32 tve_mv_cont_reg;
+};
+
+struct tve_reg_fields_mapping {
+	u32 cd_en;
+	u32 cd_trig_mode;
+	u32 cd_lm_int;
+	u32 cd_sm_int;
+	u32 cd_mon_end_int;
+	u32 cd_man_trig;
+	u32 sync_ch_mask;
+	u32 tvout_mode_mask;
+	u32 sync_ch_offset;
+	u32 tvout_mode_offset;
+	u32 cd_ch_stat_offset;
+};
+
+static struct tve_reg_mapping tve_regs_v1 = {
+	0, 0x14, 0x28, 0x2C, 0x48
+};
+
+static struct tve_reg_fields_mapping tve_reg_fields_v1 = {
+	1, 2, 1, 2, 4, 0x00010000, 0x7000, 0x70, 12, 4, 8
+};
+
+static struct tve_reg_mapping tve_regs_v2 = {
+	0, 0x34, 0x64, 0x68, 0xDC
+};
+
+static struct tve_reg_fields_mapping tve_reg_fields_v2 = {
+	1, 2, 1, 2, 4, 0x01000000, 0x700000, 0x7000, 20, 12, 16
+};
+
+
+struct tve_reg_mapping *tve_regs;
+struct tve_reg_fields_mapping *tve_reg_fields;
+
+/* For MX37 need modify some fields in tve_probe */
+static struct fb_videomode video_modes[] = {
+	{
+	 /* NTSC TV output */
+	 "TV-NTSC", 60, 720, 480, 74074,
+	 122, 15,
+	 18, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED,
+	 0,},
+	{
+	 /* PAL TV output */
+	 "TV-PAL", 50, 720, 576, 74074,
+	 132, 11,
+	 22, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED | FB_VMODE_ODD_FLD_FIRST,
+	 0,},
+};
+
+enum tvout_mode {
+	TV_OFF,
+	CVBS0,
+	CVBS2,
+	CVBS02,
+	SVIDEO,
+	SVIDEO_CVBS,
+	YPBPR,
+	RGB
+};
+
+static unsigned short tvout_mode_to_channel_map[8] = {
+	0,	/* TV_OFF */
+	1,	/* CVBS0 */
+	4,	/* CVBS2 */
+	5,	/* CVBS02 */
+	1,	/* SVIDEO */
+	5,	/* SVIDEO_CVBS */
+	1,	/* YPBPR */
+	7	/* RGB */
+};
+
+
+static void tve_set_tvout_mode(int mode)
+{
+	u32 conf_reg;
+	conf_reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
+	conf_reg &= ~(tve_reg_fields->sync_ch_mask |
+				tve_reg_fields->tvout_mode_mask);
+	/* clear sync_ch and tvout_mode fields */
+	conf_reg |=
+		mode << tve_reg_fields->
+		tvout_mode_offset | tvout_mode_to_channel_map[mode] <<
+		tve_reg_fields->sync_ch_offset;
+	__raw_writel(conf_reg, tve.base + tve_regs->tve_com_conf_reg);
+}
+
+/**
+ * tve_setup
+ * initial the CH7024 chipset by setting register
+ * @param:
+ * 	vos: output video format
+ * @return:
+ * 	0 successful
+ * 	otherwise failed
+ */
+static int tve_setup(int mode)
+{
+	u32 reg;
+	if (tve.cur_mode == mode)
+		return 0;
+
+	tve.cur_mode = mode;
+
+	if (!enabled)
+		clk_enable(tve.clk);
+
+	/* select output video format */
+	if (mode == TVOUT_FMT_PAL) {
+		reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
+		reg = (reg & ~TVE_STAND_MASK) | TVE_PAL_STAND;
+		__raw_writel(reg, tve.base + tve_regs->tve_com_conf_reg);
+		pr_debug("TVE: change to PAL video\n");
+	} else if (mode == TVOUT_FMT_NTSC) {
+		reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
+		reg = (reg & ~TVE_STAND_MASK) | TVE_NTSC_STAND;
+		__raw_writel(reg, tve.base + tve_regs->tve_com_conf_reg);
+		pr_debug("TVE: change to NTSC video\n");
+	} else if (mode == TVOUT_FMT_OFF) {
+		__raw_writel(0x0, tve.base + tve_regs->tve_com_conf_reg);
+		pr_debug("TVE: change to OFF video\n");
+	} else {
+		pr_debug("TVE: no such video format.\n");
+		if (!enabled)
+			clk_disable(tve.clk);
+		return -EINVAL;
+	}
+
+	if (!enabled)
+		clk_disable(tve.clk);
+
+	return 0;
+}
+
+/**
+ * tve_enable
+ * Enable the tve Power to begin TV encoder
+ */
+static void tve_enable(void)
+{
+	u32 reg;
+
+	if (!enabled) {
+		enabled = 1;
+		clk_enable(tve.clk);
+		reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
+		__raw_writel(reg | TVE_IPU_CLK_ENABLE | TVE_ENABLE,
+					tve.base + tve_regs->tve_com_conf_reg);
+		pr_debug("TVE power on.\n");
+	}
+
+	/* enable interrupt */
+	__raw_writel(CD_SM_INT | CD_LM_INT | CD_MON_END_INT,
+				tve.base + tve_regs->tve_stat_reg);
+	__raw_writel(CD_SM_INT | CD_LM_INT | CD_MON_END_INT,
+				tve.base + tve_regs->tve_int_cont_reg);
+}
+
+/**
+ * tve_disable
+ * Disable the tve Power to stop TV encoder
+ */
+static void tve_disable(void)
+{
+	u32 reg;
+
+	if (enabled) {
+		enabled = 0;
+		reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
+		__raw_writel(reg & ~TVE_ENABLE & ~TVE_IPU_CLK_ENABLE,
+				tve.base + tve_regs->tve_com_conf_reg);
+		tve_set_tvout_mode(TV_OFF);
+		clk_disable(tve.clk);
+		pr_debug("TVE power off.\n");
+	}
+}
+
+static int tve_update_detect_status(void)
+{
+	int old_detect = tve.detect;
+	u32 stat_lm, stat_sm, stat;
+	u32 int_ctl = __raw_readl(tve.base + tve_regs->tve_int_cont_reg);
+	u32 cd_cont_reg =
+		__raw_readl(tve.base + tve_regs->tve_cd_cont_reg);
+	u32 timeout = 40;
+
+	if ((cd_cont_reg & 0x1) == 0) {
+		pr_warning("Warning: pls enable TVE CD first!\n");
+		return tve.detect;
+	}
+
+	stat = __raw_readl(tve.base + tve_regs->tve_stat_reg);
+	while (((stat & CD_MON_END_INT) == 0) && (timeout > 0)) {
+		msleep(2);
+		timeout -= 2;
+		stat = __raw_readl(tve.base + tve_regs->tve_stat_reg);
+	}
+	if (((stat & CD_MON_END_INT) == 0) && (timeout <= 0)) {
+		pr_warning("Warning: get detect resultwithout CD_MON_END_INT!\n");
+		return tve.detect;
+	}
+
+	stat = stat >> tve_reg_fields->cd_ch_stat_offset;
+	stat_lm = stat & (CD_CH_0_LM_ST | CD_CH_1_LM_ST | CD_CH_2_LM_ST);
+	if ((stat_lm == (CD_CH_0_LM_ST | CD_CH_1_LM_ST | CD_CH_2_LM_ST)) &&
+		((stat & (CD_CH_0_SM_ST | CD_CH_1_SM_ST | CD_CH_2_SM_ST)) == 0)
+		) {
+			tve.detect = 3;
+			tve.output_mode = YPBPR;
+	} else if ((stat_lm == (CD_CH_0_LM_ST | CD_CH_1_LM_ST)) &&
+		((stat & (CD_CH_0_SM_ST | CD_CH_1_SM_ST)) == 0)) {
+			tve.detect = 4;
+			tve.output_mode = SVIDEO;
+	} else if (stat_lm == CD_CH_0_LM_ST) {
+		stat_sm = stat & CD_CH_0_SM_ST;
+		if (stat_sm != 0) {
+			/* headset */
+			tve.detect = 2;
+			tve.output_mode = TV_OFF;
+		} else {
+			tve.detect = 1;
+			tve.output_mode = CVBS0;
+		}
+	} else if (stat_lm == CD_CH_2_LM_ST) {
+		stat_sm = stat & CD_CH_2_SM_ST;
+		if (stat_sm != 0) {
+			/* headset */
+			tve.detect = 2;
+			tve.output_mode = TV_OFF;
+		} else {
+			tve.detect = 1;
+			tve.output_mode = CVBS2;
+		}
+	} else {
+		/* none */
+		tve.detect = 0;
+		tve.output_mode = TV_OFF;
+	}
+
+	tve_set_tvout_mode(tve.output_mode);
+
+	/* clear interrupt */
+	__raw_writel(CD_MON_END_INT | CD_LM_INT | CD_SM_INT,
+			tve.base + tve_regs->tve_stat_reg);
+
+	__raw_writel(int_ctl | CD_SM_INT | CD_LM_INT,
+			tve.base + tve_regs->tve_int_cont_reg);
+
+	if (old_detect != tve.detect)
+		sysfs_notify(&tve.pdev->dev.kobj, NULL, "headphone");
+
+	dev_dbg(&tve.pdev->dev, "detect = %d mode = %d\n",
+			tve.detect, tve.output_mode);
+
+	return tve.detect;
+}
+
+static void cd_work_func(struct work_struct *work)
+{
+	tve_update_detect_status();
+}
+
+static int tve_man_detect(void)
+{
+	u32 cd_cont;
+	u32 int_cont;
+
+	if (!enabled)
+		return -1;
+
+	int_cont = __raw_readl(tve.base + tve_regs->tve_int_cont_reg);
+	__raw_writel(int_cont &
+				~(tve_reg_fields->cd_sm_int | tve_reg_fields->cd_lm_int),
+				tve.base + tve_regs->tve_int_cont_reg);
+
+	cd_cont = __raw_readl(tve.base + tve_regs->tve_cd_cont_reg);
+	__raw_writel(cd_cont | tve_reg_fields->cd_trig_mode,
+				tve.base + tve_regs->tve_cd_cont_reg);
+
+	__raw_writel(tve_reg_fields->cd_sm_int | tve_reg_fields->
+			cd_lm_int | tve_reg_fields->
+			cd_mon_end_int | tve_reg_fields->cd_man_trig,
+			tve.base + tve_regs->tve_stat_reg);
+
+	while ((__raw_readl(tve.base + tve_regs->tve_stat_reg)
+		& tve_reg_fields->cd_mon_end_int) == 0)
+		msleep(5);
+
+	tve_update_detect_status();
+
+	__raw_writel(cd_cont, tve.base + tve_regs->tve_cd_cont_reg);
+	__raw_writel(int_cont, tve.base + tve_regs->tve_int_cont_reg);
+
+	return tve.detect;
+}
+
+static irqreturn_t tve_detect_handler(int irq, void *data)
+{
+	u32 int_ctl = __raw_readl(tve.base + tve_regs->tve_int_cont_reg);
+	/* disable INT first */
+	int_ctl &= ~(CD_SM_INT | CD_LM_INT | CD_MON_END_INT);
+	__raw_writel(int_ctl, tve.base + tve_regs->tve_int_cont_reg);
+
+	__raw_writel(CD_MON_END_INT | CD_LM_INT | CD_SM_INT,
+			tve.base + tve_regs->tve_stat_reg);
+
+	schedule_delayed_work(&tve.cd_work, msecs_to_jiffies(1000));
+
+	return IRQ_HANDLED;
+}
+
+int tve_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+	struct fb_info *fbi = event->info;
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		pr_debug("fb registered event\n");
+		if ((tve_fbi != NULL) || strcmp(fbi->fix.id, "DISP3 BG - DI1"))
+			break;
+
+		tve_fbi = fbi;
+		fb_add_videomode(&video_modes[0], &tve_fbi->modelist);
+		fb_add_videomode(&video_modes[1], &tve_fbi->modelist);
+		break;
+	case FB_EVENT_MODE_CHANGE:
+		if (tve_fbi != fbi)
+			break;
+
+		if (!fbi->mode) {
+			tve_disable();
+			tve.cur_mode = TVOUT_FMT_OFF;
+			return 0;
+		}
+
+		pr_debug("fb mode change event: xres=%d, yres=%d\n",
+			 fbi->mode->xres, fbi->mode->yres);
+
+		tve_disable();
+
+		if (fb_mode_is_equal(fbi->mode, &video_modes[0])) {
+			tve_setup(TVOUT_FMT_NTSC);
+			tve_enable();
+		} else if (fb_mode_is_equal(fbi->mode, &video_modes[1])) {
+			tve_setup(TVOUT_FMT_PAL);
+			tve_enable();
+		} else {
+			tve_setup(TVOUT_FMT_OFF);
+		}
+		break;
+	case FB_EVENT_BLANK:
+		if ((tve_fbi != fbi) || (fbi->mode == NULL))
+			return 0;
+
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			if (fb_mode_is_equal(fbi->mode, &video_modes[0])) {
+				if (tve.cur_mode != TVOUT_FMT_NTSC) {
+					tve_disable();
+					tve_setup(TVOUT_FMT_NTSC);
+				}
+				tve_enable();
+			} else if (fb_mode_is_equal(fbi->mode,
+					&video_modes[1])) {
+				if (tve.cur_mode != TVOUT_FMT_PAL) {
+					tve_disable();
+					tve_setup(TVOUT_FMT_PAL);
+				}
+				tve_enable();
+			} else {
+				tve_setup(TVOUT_FMT_OFF);
+			}
+		} else
+			tve_disable();
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = tve_fb_event,
+};
+
+static ssize_t show_headphone(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int detect;
+
+	if (!enabled) {
+		strcpy(buf, "tve power off\n");
+		return strlen(buf);
+	}
+
+	detect = tve_update_detect_status();
+
+	if (detect == 0)
+		strcpy(buf, "none\n");
+	else if (detect == 1)
+		strcpy(buf, "cvbs\n");
+	else if (detect == 2)
+		strcpy(buf, "headset\n");
+	else if (detect == 3)
+		strcpy(buf, "component\n");
+	else
+		strcpy(buf, "svideo\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+static int _tve_get_revision(void)
+{
+	u32 conf_reg;
+	u32 rev = 0;
+
+	/* find out TVE rev based on the base addr default value
+	 * can be used at the init/probe ONLY */
+	conf_reg = __raw_readl(tve.base);
+	switch (conf_reg) {
+	case 0x00842000:
+		rev = 1;
+		break;
+	case 0x00100000:
+		rev = 2;
+		break;
+	}
+	return rev;
+}
+
+static int tve_probe(struct platform_device *pdev)
+{
+	int ret, i;
+	struct resource *res;
+	struct tve_platform_data *plat_data = pdev->dev.platform_data;
+	u32 conf_reg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -ENOMEM;
+
+	tve.pdev = pdev;
+	tve.base = ioremap(res->start, res->end - res->start);
+
+	tve.irq = platform_get_irq(pdev, 0);
+	if (tve.irq < 0) {
+		ret = tve.irq;
+		goto err0;
+	}
+
+	INIT_DELAYED_WORK(&tve.cd_work, cd_work_func);
+	ret = request_irq(tve.irq, tve_detect_handler, 0, pdev->name, pdev);
+	if (ret < 0)
+		goto err0;
+
+	ret = device_create_file(&pdev->dev, &dev_attr_headphone);
+	if (ret < 0)
+		goto err1;
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG - DI1") == 0) {
+			tve_fbi = registered_fb[i];
+			break;
+		}
+	}
+
+	/* adjust video mode for mx37 */
+	if (cpu_is_mx37()) {
+		video_modes[0].left_margin = 121;
+		video_modes[0].right_margin = 16;
+		video_modes[0].upper_margin = 17;
+		video_modes[0].lower_margin = 5;
+		video_modes[1].left_margin = 131;
+		video_modes[1].right_margin = 12;
+		video_modes[1].upper_margin = 21;
+		video_modes[1].lower_margin = 3;
+	}
+
+	if (tve_fbi != NULL) {
+		fb_add_videomode(&video_modes[0], &tve_fbi->modelist);
+		fb_add_videomode(&video_modes[1], &tve_fbi->modelist);
+	}
+
+	tve.dac_reg = regulator_get(&pdev->dev, plat_data->dac_reg);
+	if (!IS_ERR(tve.dac_reg)) {
+		regulator_set_voltage(tve.dac_reg, 2500000, 2500000);
+		regulator_enable(tve.dac_reg);
+	}
+
+	tve.dig_reg = regulator_get(&pdev->dev, plat_data->dig_reg);
+	if (!IS_ERR(tve.dig_reg)) {
+		regulator_set_voltage(tve.dig_reg, 1250000, 1250000);
+		regulator_enable(tve.dig_reg);
+	}
+
+	tve.clk = clk_get(&pdev->dev, "tve_clk");
+	clk_set_rate(tve.clk, 216000000);
+	clk_enable(tve.clk);
+
+	if (_tve_get_revision() == 1) {
+		tve_regs = &tve_regs_v1;
+		tve_reg_fields = &tve_reg_fields_v1;
+	} else {
+		tve_regs = &tve_regs_v2;
+		tve_reg_fields = &tve_reg_fields_v2;
+	}
+
+	/* Setup cable detect, for YPrPb mode, default use channel#0 for Y */
+	__raw_writel(0x01067701, tve.base + tve_regs->tve_cd_cont_reg);
+	/* tve_man_detect(); not working */
+
+	conf_reg = 0;
+	__raw_writel(conf_reg, tve.base + tve_regs->tve_com_conf_reg);
+
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg - 4 * 5);
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg - 4 * 4);
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg - 4 * 3);
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg - 4 * 2);
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg - 4);
+	__raw_writel(0x00000000, tve.base + tve_regs->tve_mv_cont_reg);
+
+	clk_disable(tve.clk);
+
+	ret = fb_register_client(&nb);
+	if (ret < 0)
+		goto err2;
+
+	return 0;
+err2:
+	device_remove_file(&pdev->dev, &dev_attr_headphone);
+err1:
+	free_irq(tve.irq, pdev);
+err0:
+	iounmap(tve.base);
+	return ret;
+}
+
+static int tve_remove(struct platform_device *pdev)
+{
+	if (enabled) {
+		clk_disable(tve.clk);
+		enabled = 0;
+	}
+	free_irq(tve.irq, pdev);
+	device_remove_file(&pdev->dev, &dev_attr_headphone);
+	fb_unregister_client(&nb);
+	return 0;
+}
+
+/*!
+ * PM suspend/resume routing
+ */
+static int tve_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (enabled) {
+		__raw_writel(0, tve.base + tve_regs->tve_int_cont_reg);
+		__raw_writel(0, tve.base + tve_regs->tve_cd_cont_reg);
+		__raw_writel(0, tve.base + tve_regs->tve_com_conf_reg);
+		clk_disable(tve.clk);
+	}
+	return 0;
+}
+
+static int tve_resume(struct platform_device *pdev)
+{
+	if (enabled) {
+		clk_enable(tve.clk);
+
+		/* Setup cable detect */
+		__raw_writel(0x01067701, tve.base + tve_regs->tve_cd_cont_reg);
+
+		if (tve.cur_mode == TVOUT_FMT_NTSC) {
+			tve_disable();
+			tve.cur_mode = TVOUT_FMT_OFF;
+			tve_setup(TVOUT_FMT_NTSC);
+		} else if (tve.cur_mode == TVOUT_FMT_PAL) {
+			tve_disable();
+			tve.cur_mode = TVOUT_FMT_OFF;
+			tve_setup(TVOUT_FMT_PAL);
+		}
+		tve_enable();
+	}
+
+	return 0;
+}
+
+static struct platform_driver tve_driver = {
+	.driver = {
+		   .name = "tve",
+		   },
+	.probe = tve_probe,
+	.remove = tve_remove,
+	.suspend = tve_suspend,
+	.resume = tve_resume,
+};
+
+static int __init tve_init(void)
+{
+	return platform_driver_register(&tve_driver);
+}
+
+static void __exit tve_exit(void)
+{
+	platform_driver_unregister(&tve_driver);
+}
+
+module_init(tve_init);
+module_exit(tve_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX TV encoder driver");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

