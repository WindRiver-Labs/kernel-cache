From b1f63c6fe3895c9d87f1e256141278b1d80754e3 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 18 Apr 2008 15:29:20 +0800
Subject: [PATCH] patches-shared/arch-mxc_include

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 include/asm-arm/arch-mxc/board-mx31.h  |  366 ++++++++++++++++++++++++++
 include/asm-arm/arch-mxc/board.h       |   43 +++
 include/asm-arm/arch-mxc/clock.h       |  308 ++++++++++++++++++++++
 include/asm-arm/arch-mxc/debug-macro.S |   37 +++
 include/asm-arm/arch-mxc/dma.h         |  227 ++++++++++++++++
 include/asm-arm/arch-mxc/gpio.h        |  169 ++++++++++++
 include/asm-arm/arch-mxc/hardware.h    |   39 +++-
 include/asm-arm/arch-mxc/memory.h      |   13 +
 include/asm-arm/arch-mxc/mx31.h        |   94 +++++++
 include/asm-arm/arch-mxc/mx31_pins.h   |  438 +++++++++++++++++++++++++++++++
 include/asm-arm/arch-mxc/mxc.h         |   29 ++
 include/asm-arm/arch-mxc/sdma.h        |  448 ++++++++++++++++++++++++++++++++
 include/asm-arm/arch-mxc/vmalloc.h     |    4 +
 13 files changed, 2214 insertions(+), 1 deletions(-)
 create mode 100644 include/asm-arm/arch-mxc/board-mx31.h
 create mode 100644 include/asm-arm/arch-mxc/board.h
 create mode 100644 include/asm-arm/arch-mxc/clock.h
 create mode 100644 include/asm-arm/arch-mxc/debug-macro.S
 create mode 100644 include/asm-arm/arch-mxc/gpio.h
 create mode 100644 include/asm-arm/arch-mxc/mx31_pins.h
 create mode 100644 include/asm-arm/arch-mxc/sdma.h

diff --git a/include/asm-arm/arch-mxc/board-mx31.h b/include/asm-arm/arch-mxc/board-mx31.h
new file mode 100644
index 0000000..25c3c1e
--- /dev/null
+++ b/include/asm-arm/arch-mxc/board-mx31.h
@@ -0,0 +1,366 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARM_ARCH_BOARD_MX31_H_
+#define __ASM_ARM_ARCH_BOARD_MX31_H_
+
+/*
+ * Include Files
+ */
+#include <asm/arch/board.h>
+
+/* Size of contiguous memory for DMA and other h/w blocks */
+#define CONSISTENT_DMA_SIZE	SZ_8M
+
+/* I2C configuration */
+/*!
+ * This defines the number of I2C modules in the MXC platform
+ * Defined as 1, as MC13783 on ADS uses the other pins
+ */
+#define I2C_NR                  1
+/*!
+ * This define specifies the frequency divider value to be written into
+ * the I2C \b IFDR register.
+ */
+#define I2C1_FRQ_DIV            0x17
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specify the max baudrate for the MXC UARTs for your board, do not specify a max
+ * baudrate greater than 1500000. This is used while specifying the UART Power
+ * management constraints.
+ */
+#define MAX_UART_BAUDRATE       1500000
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                IRDA
+#ifdef CONFIG_MXC_FIR_MODULE
+#define UART2_ENABLED           0
+#else
+#define UART2_ENABLED           1
+#endif
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0	/* Disable UART 4 as its pins are shared with ATA */
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           1
+
+#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x10000)
+#define MXC_LL_EXTUART_VADDR	CS4_IO_ADDRESS(MXC_LL_EXTUART_PADDR)
+#undef  MXC_LL_EXTUART_16BIT_BUS
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name Memory Size parameters
+ */
+/*! @{ */
+/*!
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE          SZ_128M
+/*!
+ * Size of MBX buffer memory
+ */
+#define MXC_MBX_MEM_SIZE        SZ_16M
+/*!
+ * Size of memory available to kernel
+ */
+#define MEM_SIZE                (SDRAM_MEM_SIZE - MXC_MBX_MEM_SIZE)
+/*! @} */
+
+/*!
+ * @name Keypad Configurations FIXME
+ */
+/*! @{ */
+/*!
+ * Maximum number of rows (0 to 7)
+ */
+#define MAXROW                  8
+/*!
+ * Maximum number of columns (0 to 7)
+ */
+#define MAXCOL                  8
+/*! @} */
+
+/*!
+ * @name PBC Controller parameters
+ */
+/*! @{ */
+/*!
+ * Base address of PBC controller
+ */
+#define PBC_BASE_ADDRESS        IO_ADDRESS(CS4_BASE_ADDR)
+/* Offsets for the PBC Controller register */
+/*!
+ * PBC Board status register offset
+ */
+#define PBC_BSTAT               0x000002
+/*!
+ * PBC Board control register 1 set address.
+ */
+#define PBC_BCTRL1_SET          0x000004
+/*!
+ * PBC Board control register 1 clear address.
+ */
+#define PBC_BCTRL1_CLEAR        0x000006
+/*!
+ * PBC Board control register 2 set address.
+ */
+#define PBC_BCTRL2_SET          0x000008
+/*!
+ * PBC Board control register 2 clear address.
+ */
+#define PBC_BCTRL2_CLEAR        0x00000A
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL3_SET          0x00000C
+/*!
+ * PBC Board control register 3 clear address.
+ */
+#define PBC_BCTRL3_CLEAR        0x00000E
+/*!
+ * PBC Board control register 4 set address.
+ */
+#define PBC_BCTRL4_SET          0x000010
+/*!
+ * PBC Board control register 4 clear address.
+ */
+#define PBC_BCTRL4_CLEAR        0x000012
+/*!
+ * PBC Board status register 1.
+ */
+#define PBC_BSTAT1              0x000014
+/*!
+ * PBC Board interrupt status register.
+ */
+#define PBC_INTSTATUS           0x000016
+/*!
+ * PBC Board interrupt current status register.
+ */
+#define PBC_INTCURR_STATUS      0x000018
+/*!
+ * PBC Interrupt mask register set address.
+ */
+#define PBC_INTMASK_SET         0x00001A
+/*!
+ * PBC Interrupt mask register clear address.
+ */
+#define PBC_INTMASK_CLEAR       0x00001C
+
+/*!
+ * External UART A.
+ */
+#define PBC_SC16C652_UARTA      0x010000
+/*!
+ * External UART B.
+ */
+#define PBC_SC16C652_UARTB      0x010010
+/*!
+ * Ethernet Controller IO base address.
+ */
+#define PBC_CS8900A_IOBASE      0x020000
+/*!
+ * Ethernet Controller Memory base address.
+ */
+#define PBC_CS8900A_MEMBASE     0x021000
+/*!
+ * Ethernet Controller DMA base address.
+ */
+#define PBC_CS8900A_DMABASE     0x022000
+/*!
+ * External chip select 0.
+ */
+#define PBC_XCS0                0x040000
+/*!
+ * LCD Display enable.
+ */
+#define PBC_LCD_EN_B            0x060000
+/*!
+ * Code test debug enable.
+ */
+#define PBC_CODE_B              0x070000
+/*!
+ * PSRAM memory select.
+ */
+#define PBC_PSRAM_B             0x5000000
+
+/* PBC Board Status Register 1 bit definitions */
+#define PBC_BSTAT1_NF_DET       0x0001	/* NAND flash card. 0 = connected */
+#define PBC_BSTAT1_KP_ON        0x0002	/* KPP board. 0 = connected */
+#define PBC_BSTAT1_LS           0x0004	/* KPP:LightSense signal */
+#define PBC_BSTAT1_ATA_IOCS16   0x0008	/* ATA_IOCS16 signal */
+#define PBC_BSTAT1_ATA_CBLID    0x0010	/* ATA_CBLID signal */
+#define PBC_BSTAT1_ATA_DASP     0x0020	/* ATA_DASP signal */
+#define PBC_BSTAT1_PWR_RDY      0x0040	/* MC13783 power. 1 = ready */
+#define PBC_BSTAT1_SD1_WP       0x0080	/* 0 = SD1 card is write protected */
+#define PBC_BSTAT1_SD2_WP       0x0100	/* 0 = SD2 card is write protected */
+#define PBC_BSTAT1_FS1          0x0200	/* KPP:FlipSense1 signal */
+#define PBC_BSTAT1_FS2          0x0400	/* KPP:FlipSense2 signal */
+#define PBC_BSTAT1_PTT          0x0800	/* KPP:PTT signal */
+#define PBC_BSTAT1_MC13783_IN   0x1000	/* MC13783 board. 0 = connected. */
+
+/* PBC Board Control Register 1 bit definitions */
+#define PBC_BCTRL1_ERST         0x0001	/* Ethernet Reset */
+#define PBC_BCTRL1_URST         0x0002	/* Reset External UART controller */
+#define PBC_BCTRL1_UENA         0x0004	/* Enable UART A transceiver */
+#define PBC_BCTRL1_UENB         0x0008	/* Enable UART B transceiver */
+#define PBC_BCTRL1_UENCE        0x0010	/* Enable UART CE transceiver */
+#define PBC_BCTRL1_IREN         0x0020	/* Enable the IRDA transmitter */
+#define PBC_BCTRL1_LED0         0x0040	/* Used to control LED 0 (green) */
+#define PBC_BCTRL1_LED1         0x0080	/* Used to control LED 1 (yellow) */
+#define PBC_BCTRL1_SENSOR1_ON	0x0600	/* Enable Sensor 1 */
+#define PBC_BCTRL1_SENSOR2_ON	0x3000	/* Enable Sensor 2 */
+#define PBC_BCTRL1_BEND         0x4000	/* Big Endian Select */
+#define PBC_BCTRL1_LCDON        0x8000	/* Enable the LCD */
+
+/* PBC Board Control Register 2 bit definitions */
+#define PBC_BCTRL2_USELA	0x0001	/* UART A Select, 0 = UART1, 1 = UART5 */
+#define PBC_BCTRL2_USELB	0x0002	/* UART B Select, 0 = UART3, 1 = UART5 */
+#define PBC_BCTRL2_USELC	0x0004	/* UART C Select, 0 = UART2, 1 = UART1 */
+#define PBC_BCTRL2_UMODENA	0x0008	/* UART A Modem Signals Enable, 0 = enabled */
+#define PBC_BCTRL2_UMODENC	0x0008	/* UART C Modem Signals Enable, 0 = enabled */
+#define PBC_BCTRL2_CSI_EN	0x0020	/* Enable the CSI interface, 0 = enabled */
+#define PBC_BCTRL2_ATA_EN	0x0040	/* Enable the ATA interface, 0 = enabled */
+#define PBC_BCTRL2_ATA_SEL	0x0080	/* ATA Select, 0 = group A, 1 = group B */
+#define PBC_BCTRL2_IRDA_MOD	0x0100	/* IRDA Mode (see CPLD spec) */
+#define PBC_BCTRL2_LDC_RST0	0x0200	/* LCD 0 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDC_RST1	0x0400	/* LCD 1 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDC_RST2	0x0800	/* LCD 2 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDCIO_EN	0x1000	/* LCD GPIO Enable, 0 = enabled */
+#define PBC_BCTRL2_CT_CS	0x2000	/* Code Test Chip Select, = Code Test selected */
+#define PBC_BCTRL2_VPP_EN	0x4000	/* PCMCIA VPP Enable, 1 = power on */
+#define PBC_BCTRL2_VCC_EN	0x8000	/* PCMCIA VCC Enable, 1 = power on */
+
+/* PBC Board Control Register 3 bit definitions */
+#define PBC_BCTRL3_OTG_FS_SEL	0x0001	/* USB OTG Full Speed Select, 0 = PMIC, 1 = CPU */
+#define PBC_BCTRL3_OTG_FS_EN	0x0002	/* USB OTG Full Speed Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_SEL	0x0004	/* USB Full Speed Host Select, 0 = Group A, 1 = Group B */
+#define PBC_BCTRL3_FSH_EN	0x0008	/* USB Full Speed Host Enable, 0 = enabled */
+#define PBC_BCTRL3_HSH_SEL	0x0010	/* USB High Speed Host Select, 0 = Group A, 1 = Group B */
+#define PBC_BCTRL3_HSH_EN	0x0020	/* USB High Speed Host Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_MOD	0x0040	/* USB Full Speed Host Mode, 0 = Differential, 1 = Single ended */
+#define PBC_BCTRL3_OTG_HS_EN	0x0080	/* USB OTG High Speed Enable, 0 = enabled */
+#define PBC_BCTRL3_OTG_VBUS_EN	0x0100	/* USB OTG VBUS Regulator Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_VBUS_EN	0x0200	/* USB Full Speed Host VBUS Regulator Enable, 0 = enabled */
+#define PBC_BCTRL3_CARD1_SEL	0x0400	/* Card1 Select, 0 = SD1, 1 = MS1 */
+#define PBC_BCTRL3_CARD2_SEL	0x0800	/* Card2 Select, 0 = PCMCIA & SD2, 1 = MS2 */
+#define PBC_BCTRL3_SYNTH_RST	0x1000	/* Audio Synthesizer Reset, 0 = reset asserted */
+#define PBC_BCTRL3_VSIM_EN	0x2000	/* VSIM Regulator Enable, 1 = enabled */
+#define PBC_BCTRL3_VESIM_EN	0x4000	/* VESIM Regulator Enable, 1 = enabled */
+#define PBC_BCTRL3_SPI3_RESET	0x8000	/* CSPI3 Connector Reset, 0 = reset asserted */
+
+/* PBC Board Control Register 4 bit definitions */
+#define PBC_BCTRL4_CSI_MSB_EN	0x0001	/* CSI MSB Enable, 0 = CSI_Data[3:0] enabled */
+#define PBC_BCTRL4_REGEN_SEL	0x0002	/* Regulator Enable Select, 0 = enabled */
+#define PBC_BCTRL4_USER_OFF	0x0004	/* User Off Indication, 1 = user off confirmation */
+#define PBC_BCTRL4_VIB_EN	0x0008	/* Vibrator Enable, 1 = enabled */
+#define PBC_BCTRL4_PCMCIA_EN	0x0010	/* PCMCIA Enable, 0 = buffer enabled */
+
+#define PBC_INT_CS8900A         4
+/*! @} */
+
+#define PBC_INTSTATUS_REG	(PBC_INTSTATUS + PBC_BASE_ADDRESS)
+#define PBC_INTCURR_STATUS_REG	(PBC_INTCURR_STATUS + PBC_BASE_ADDRESS)
+#define PBC_INTMASK_SET_REG	(PBC_INTMASK_SET + PBC_BASE_ADDRESS)
+#define PBC_INTMASK_CLEAR_REG	(PBC_INTMASK_CLEAR + PBC_BASE_ADDRESS)
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX31_PIN_GPIO1_4)
+
+#define EXPIO_INT_LOW_BAT	(MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_PB_IRQ	(MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_OTG_FS_OVR	(MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_FSH_OVR	(MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_RES4		(MXC_EXP_IO_BASE + 4)
+#define EXPIO_INT_RES5		(MXC_EXP_IO_BASE + 5)
+#define EXPIO_INT_RES6		(MXC_EXP_IO_BASE + 6)
+#define EXPIO_INT_RES7		(MXC_EXP_IO_BASE + 7)
+#define EXPIO_INT_ENET_INT	(MXC_EXP_IO_BASE + 8)
+#define EXPIO_INT_OTG_FS_INT	(MXC_EXP_IO_BASE + 9)
+#define EXPIO_INT_XUART_INTA	(MXC_EXP_IO_BASE + 10)
+#define EXPIO_INT_XUART_INTB	(MXC_EXP_IO_BASE + 11)
+#define EXPIO_INT_SYNTH_IRQ	(MXC_EXP_IO_BASE + 12)
+#define EXPIO_INT_CE_INT1	(MXC_EXP_IO_BASE + 13)
+#define EXPIO_INT_CE_INT2	(MXC_EXP_IO_BASE + 14)
+#define EXPIO_INT_RES15		(MXC_EXP_IO_BASE + 15)
+
+#define MXC_MAX_EXP_IO_LINES	16
+
+/*!
+ * @name  Defines Base address and IRQ used for CS8900A Ethernet Controller on MXC Boards
+ */
+/*! @{*/
+/*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
+#define CS8900AIRQ              EXPIO_INT_ENET_INT
+/*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
+#define CS8900A_BASE_ADDRESS    (PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300)
+/*! @} */
+
+#define MXC_PMIC_INT_LINE	IOMUX_TO_IRQ(MX31_PIN_GPIO1_3)
+
+#define MX31LITE_LAN_INT	IOMUX_TO_IRQ(MX31_PIN_SFS6)
+
+#define AHB_FREQ                133000000
+#define IPG_FREQ                66500000
+
+/*! This is used to active or inactive ata signal in CPLD .
+ *  It is dependent with hardware
+ */
+#define PBC_ATA_SIGNAL_ACTIVE() \
+        __raw_writew(PBC_BCTRL2_ATA_SEL, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);\
+        __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+#define PBC_ATA_SIGNAL_INACTIVE() \
+         __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX31ADS_H__ */
diff --git a/include/asm-arm/arch-mxc/board.h b/include/asm-arm/arch-mxc/board.h
new file mode 100644
index 0000000..827295d
--- /dev/null
+++ b/include/asm-arm/arch-mxc/board.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_H__
+#define __ASM_ARCH_MXC_BOARD_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#ifndef __ASSEMBLY__
+
+struct mxc_ipu_config {
+	int rev;
+};
+
+struct mxc_ir_platform_data {
+	int uart_ir_mux;
+};
+#endif
+
+/*
+ * The modes of the UART ports
+ */
+#define MODE_DTE                0
+#define MODE_DCE                1
+/*
+ * Is the UART configured to be a IR port
+ */
+#define IRDA                    0
+#define NO_IRDA                 1
+
+#endif				/* __ASM_ARCH_MXC_BOARD_H__ */
diff --git a/include/asm-arm/arch-mxc/clock.h b/include/asm-arm/arch-mxc/clock.h
new file mode 100644
index 0000000..e347c8b
--- /dev/null
+++ b/include/asm-arm/arch-mxc/clock.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_CLOCK_H__
+#define __ASM_ARCH_MXC_CLOCK_H__
+
+/*!
+ * @defgroup CLOCKS Clocking Setup and Retrieving
+ * @ingroup MSL
+ */
+
+/*!
+ * @file clock.h
+ *
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#ifndef __ASSEMBLY__
+/*!
+ * Enumerations of plls and available clock sources
+ */
+enum plls {
+	MCUPLL = 0,		/*!< MCU PLL */
+	USBPLL = 2,		/*!< USB PLL */
+	DSPPLL = 1,		/*!< DSP PLL */
+	CDPLL = 3,		/*!< Corrected Clock PLL */
+	CKIH = 4,		/*!< Main Network clock */
+	CKIH_X2 = 5,		/*!< Doubled version of CKIH */
+	DIGRF = 6,		/*!< DIGRF ref clock */
+	DIGRF_X2 = 7,		/*!< Doubled version of DIGRF */
+	USBCLK = 8,		/*!< USB Clock */
+	MRCG_2_CLK = 9,		/*!< MRCG CLock */
+	TURBOPLL,		/*!< Turbo PLL */
+	SERIALPLL,		/*!<  PLL */
+};
+
+enum mxc_clk_out {
+	CKOH,
+	CKO,
+	CKO2,
+	CKO1,
+};
+
+/*!
+ * Enumerations for MXC clocks
+ */
+enum mxc_clocks {
+	CLK_NONE,
+	CKIL_CLK,
+	CKIH_CLK,
+	CPU_CLK,
+	AHB_CLK,
+	IPG_CLK,
+	NFC_CLK,
+	USB_CLK,
+	UART1_BAUD,
+	UART2_BAUD,
+	UART3_BAUD,
+	UART4_BAUD,
+	UART5_BAUD,
+	UART6_BAUD,
+	SSI1_BAUD,
+	SSI2_BAUD,
+	CSI_BAUD,
+	FIRI_BAUD,
+	I2C_CLK,
+	I2C1_CLK = I2C_CLK,
+	I2C2_CLK,
+	I2C3_CLK,
+	CSPI1_CLK,
+	CSPI2_CLK,
+	CSPI3_CLK,
+	GPT_CLK,
+	GPT1_CLK = GPT_CLK,
+	GPT2_CLK,
+	GPT3_CLK,
+	GPT4_CLK,
+	GPT5_CLK,
+	GPT6_CLK,
+	RTC_CLK,
+	EPIT1_CLK,
+	EPIT2_CLK,
+	EDIO_CLK,
+	WDOG_CLK,
+	WDOG2_CLK,
+	PWM_CLK,
+	IPU_CLK,
+	SIM1_CLK,
+	SIM2_CLK,
+	HAC_CLK,
+	GEM_CLK,
+	SDHC1_CLK,
+	SDHC2_CLK,
+	SDMA_CLK,
+	RNG_CLK,
+	KPP_CLK,
+	MU_CLK,
+	RTIC_CLK,
+	SCC_CLK,
+	SPBA_CLK,
+	DSM_CLK,
+	SAHARA2_CLK,
+	MQSPI_IPG_CLK,
+	MQSPI_CKIH_CLK,
+	EL1T_IPG_CLK,
+	EL1T_NET_CLK,
+	LPMC_CLK,
+	MPEG4_CLK,
+	OWIRE_CLK,
+	MBX_CLK,
+	MSTICK1_BAUD,
+	MSTICK2_BAUD,
+	ATA_CLK,
+	PERCLK1,
+	PERCLK2,
+	PERCLK3,
+	PERCLK4,
+	DMA_CLK,
+	EMMA_PRP_CLK,
+	EMMA_PP_CLK,
+	FEC_CLK,
+	GPIO_CLK,
+	IIM_CLK,
+	LCDC_CLK,
+	SDHC3_CLK,
+	SLCDC_CLK,
+	BROM_CLK,
+	EMI_CLK,
+	VPU_BAUD,
+	BMI_AHB_CLK,
+};
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll      the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn);
+
+/*!
+ * This function is used to get PLL registers values used generate the clock
+ * frequency.
+ *
+ * @param  pll      the PLL that you wish to access
+ * @param  mfi      pointer that holds multiplication factor integer part
+ * @param  pdf      pointer that holds pre-division factor
+ * @param  mfd      pointer that holds multiplication factor denominator
+ * @param  mfn      pointer that holds multiplication factor numerator
+ */
+void mxc_pll_get(enum plls pll, unsigned int *mfi, unsigned int *pdf,
+		 unsigned int *mfd, unsigned int *mfn);
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ *
+ * @param       pll     PLL as defined in enum plls
+ *
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll);
+
+/*!
+ * This function returns the clock value in Hz for various MXC modules.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk);
+
+/*!
+ * This function returns the parent clock value in Hz for various MXC modules.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk);
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num);
+
+/*!
+ * This function sets the division factor for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI, pass in
+ *            2 times the expected division value to account for FP vals)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div);
+
+/*!
+ * This function returns the peripheral clock dividers.
+ * Note that for SSI divider, in order to maintain the accuracy, the returned
+ * divider is doubled.
+ *
+ * @param       clk     peripheral clock as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_peri_clock_divider(enum mxc_clocks clk);
+
+/*!
+ * This function returns the main clock dividers.
+ *
+ * @param       clk     peripheral clock as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_main_clock_divider(enum mxc_clocks clk);
+
+/*!
+ * This function sets the digital frequency multiplier clock.
+ *
+ * @param       freq    Desired DFM output frequency in Hz
+ *
+ * @return      Actual DFM frequency in Hz
+ */
+unsigned long mxc_set_dfm_clock(unsigned int freq);
+
+/*!
+ * This function returns the DFS block divider - LFDF value
+ *
+ * @return      Low Voltage frequency Divider Factor value
+ */
+unsigned int mxc_get_lfdf_value(void);
+
+/*!
+ * This function is called to gate off the individual module clocks
+ *
+ * @param clks     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clks);
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param clks     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clks);
+
+/*!
+ * This function is called to read the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
+
+/*!
+ * This function is called to modify the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data);
+
+/*!
+ * Configure clock output on CKO1/CKO2 pins
+ *
+ * @param   output  The desired clock needed to measure. Possible
+ *                  values are, CKOH_AP_SEL, CKOH_AHB_SEL or CKOH_IP_SEL
+ * @param   clk     as defined in enum mxc_clocks
+ * @param   div     divider value
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk,
+			  int div);
+
+/*!
+ * This function returns the divider value for a clock.
+ *
+ * @param       clk as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_get_clocks_div(enum mxc_clocks clk);
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_CLOCK_H__ */
diff --git a/include/asm-arm/arch-mxc/debug-macro.S b/include/asm-arm/arch-mxc/debug-macro.S
new file mode 100644
index 0000000..63ee776
--- /dev/null
+++ b/include/asm-arm/arch-mxc/debug-macro.S
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-mxc/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <asm/arch/hardware.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		ldreq	\rx, =MXC_LL_UART_PADDR @ Physical
+		ldrne	\rx, =MXC_LL_UART_VADDR	@ Virtual
+#ifdef	CONFIG_ARCH_MX3
+		orr	\rx, \rx, #0x00090000	@ UART1 offset
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x40]	@ TXDATA
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x94]	@ SR2
+		tst	\rd, #0x2000		@ TXDC
+		beq	1002b			@ wait until transmit done
+		.endm
diff --git a/include/asm-arm/arch-mxc/dma.h b/include/asm-arm/arch-mxc/dma.h
index c822d56..e154d7e 100644
--- a/include/asm-arm/arch-mxc/dma.h
+++ b/include/asm-arm/arch-mxc/dma.h
@@ -11,4 +11,231 @@
 #ifndef __ASM_ARCH_MXC_DMA_H__
 #define __ASM_ARCH_MXC_DMA_H__
 
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+				    unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct mxc_dma_channel {
+	unsigned int active:1;	/*!< When there has a active tranfer, it is set to 1 */
+	unsigned int lock;	/*!< Defines the channel is allocated or not */
+	int curr_buf;		/*!< Current buffer */
+	mxc_dma_mode_t mode;	/*!< Read or Write */
+	unsigned int channel;	/*!< Channel info */
+	unsigned int dynamic:1;	/*!< Channel not statically allocated when 1 */
+	char *dev_name;		/*!< Device name */
+	void *private;		/*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;	/*!< The callback function */
+	void *cb_args;		/*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct mxc_dma_requestbuf {
+	dma_addr_t src_addr;	/*!< source address */
+	dma_addr_t dst_addr;	/*!< destination address */
+	int num_of_bytes;	/*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+#include <asm/arch/sdma.h>
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return returns a negative number on error if request for a DMA channel did not
+ *         succeed, returns the channel number to be used on success.
+ */
+extern int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t * dma_buf,
+			  int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+			     int num_buf, int num_of_bytes,
+			     mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+				void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
+
 #endif
diff --git a/include/asm-arm/arch-mxc/gpio.h b/include/asm-arm/arch-mxc/gpio.h
new file mode 100644
index 0000000..9a47adb
--- /dev/null
+++ b/include/asm-arm/arch-mxc/gpio.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_GPIO_H__
+#define __ASM_ARCH_MXC_GPIO_H__
+
+/*!
+ * @defgroup GPIO General Purpose Input Output (GPIO)
+ * @ingroup MSL
+ */
+
+/*!
+ * @file gpio.h
+ * @brief This file contains the GPIO and IOMUX configuration details.
+ *
+ * @ingroup GPIO
+ */
+
+#include <asm/sizes.h>
+#include <linux/interrupt.h>
+#include <asm/hardware.h>
+
+/*!
+ * gpio port structure
+ */
+struct mxc_gpio_port {
+        u32 num;                /*!< gpio port number */
+        u32 base;               /*!< gpio port base VA */
+        u16 irq;                /*!< irq number to the core */
+        u16 virtual_irq_start;  /*!< virtual irq start number */
+};
+/* gpio related defines */
+
+/*!
+ * There are two queues for registered GPIO ISRs. One is for high priority and
+ * the other is for low priority. The ISRs in the high priority queue will be
+ * called first before the low priority queue if more than one GPIO interrupt
+ * occurs at the same time.
+ */
+enum gpio_prio {
+	GPIO_HIGH_PRIO = 0,	/*!< high priority queue */
+	GPIO_LOW_PRIO		/*!< low priority queue */
+};
+
+/*!
+ * This enumeration data type defines various different ways for interrupting
+ * the ARM core from GPIO signals. The way to interrupt the core is dictated
+ * by the external hardware.
+ */
+typedef enum gpio_int_cfg {
+	GPIO_INT_LOW_LEV = 0x0,	/*!< low level sensitive */
+	GPIO_INT_HIGH_LEV = 0x1,	/*!< high level sensitive */
+	GPIO_INT_RISE_EDGE = 0x2,	/*!< rising edge sensitive */
+	GPIO_INT_FALL_EDGE = 0x3,	/*!< falling edge sensitive */
+	GPIO_INT_NONE = 0x4	/*!< No interrupt */
+} gpio_edge_t;
+
+typedef irqreturn_t(*gpio_irq_handler) (int, void *);
+
+/*!
+ * This function configures the GPIO signal to be either input or output. For
+ * input signals used for generating interrupts for the ARM core, how the
+ * interrupts being triggered is also passed in via \a icr. For output signals,
+ * the \a icr value doesn't matter.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  out          #true for output, #false for input
+ * @param  icr          value defined in \b #gpio_int_cfg
+ */
+void gpio_config(__u32 port, __u32 sig_no, bool out, enum gpio_int_cfg icr);
+
+/*!
+ * This function sets a GPIO signal value.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  data         value to be set (only 0 or 1 is valid)
+ */
+void gpio_set_data(__u32 port, __u32 sig_no, __u32 data);
+
+/*!
+ * This function returns the value of the GPIO signal.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ *
+ * @return Value of the GPIO signal
+ */
+__u32 gpio_get_data(__u32 port, __u32 sig_no);
+
+/*!
+ * This function is responsible for registering a GPIO signal's ISR.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ * @param  handler      GPIO ISR function pointer for the GPIO signal
+ * @param  irq_flags    irq flags (not used)
+ * @param  devname      device name associated with the interrupt
+ * @param  dev_id       some unique information for the ISR
+ *
+ * @return 0 if successful; non-zero otherwise.
+ */
+int gpio_request_irq(__u32 port, __u32 sig_no, enum gpio_prio prio,
+		     gpio_irq_handler handler, __u32 irq_flags,
+		     const char *devname, void *dev_id);
+
+/*!
+ * This function un-registers an ISR with the GPIO interrupt module.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ */
+void gpio_free_irq(__u32 port, __u32 sig_no, enum gpio_prio prio);
+
+/*!
+ * Request ownership for a GPIO pin. The caller has to check the return value
+ * of this function to make sure it returns 0 before make use of that pin.
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_gpio(iomux_pin_name_t pin);
+
+/*!
+ * Exported function to set a GPIO pin's direction
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @param is_input	1 (or non-zero) for input; 0 for output
+ */
+void mxc_set_gpio_direction(iomux_pin_name_t pin, int is_input);
+
+/*!
+ * Exported function to set a GPIO pin's data output
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @param data		value to be set (only 0 or 1 is valid)
+ */
+void mxc_set_gpio_dataout(iomux_pin_name_t pin, u32 data);
+
+/*!
+ * Return the data value of a GPIO signal.
+ * @param pin	a name defined by \b iomux_pin_name_t
+ *
+ * @return 	value (0 or 1) of the GPIO signal; -1 if pass in invalid pin
+ */
+int mxc_get_gpio_datain(iomux_pin_name_t pin);
+
+/*!
+ * Release ownership for a GPIO pin
+ * @param pin		a name defined by \b iomux_pin_name_t
+ */
+void mxc_free_gpio(iomux_pin_name_t pin);
+
+/*!
+ * GPIO driver initialization
+ * @return    always 0
+ */
+int mxc_gpio_init(void);
+#endif				/* __ASM_ARCH_MXC_GPIO_H__ */
+
diff --git a/include/asm-arm/arch-mxc/hardware.h b/include/asm-arm/arch-mxc/hardware.h
index e87ff06..2461d35 100644
--- a/include/asm-arm/arch-mxc/hardware.h
+++ b/include/asm-arm/arch-mxc/hardware.h
@@ -14,7 +14,8 @@
 #include <asm/sizes.h>
 
 #ifdef CONFIG_ARCH_MX3
-# include <asm/arch/mx31.h>
+#include <asm/arch/mx31.h>
+#include <asm/arch/board-mx31.h>
 #endif
 
 #include <asm/arch/mxc.h>
@@ -28,4 +29,40 @@
 # include <asm/arch/board-mx31ads.h>
 #endif
 
+/* This is used to turn on/off debugging */
+#define MXC_TRACE
+#ifdef MXC_TRACE
+/*!
+ * This is used for error checking in debugging mode.
+ */
+#define MXC_ERR_CHK(a) \
+        do { \
+                if ((a)) { \
+                        printk("Error at line %d in function %s in file %s", \
+                                __LINE__, __FUNCTION__, __FILE__); \
+                        BUG(); \
+                } \
+        } \
+        while (0)
+#else
+#define MXC_ERR_CHK(a)
+#endif
+
+/*
+ * ---------------------------------------------------------------------------
+ * Processor specific defines
+ * ---------------------------------------------------------------------------
+ */
+#define CHIP_REV_1_0            0x10
+#define CHIP_REV_1_1            0x11
+#define CHIP_REV_1_2            0x12
+#define CHIP_REV_1_3            0x13
+#define CHIP_REV_2_0            0x20
+#define CHIP_REV_2_1            0x21
+#define CHIP_REV_2_2            0x22
+#define CHIP_REV_2_3            0x23
+#define CHIP_REV_3_0            0x30
+#define CHIP_REV_3_1            0x31
+#define CHIP_REV_3_2            0x32
+
 #endif /* __ASM_ARCH_MXC_HARDWARE_H__ */
diff --git a/include/asm-arm/arch-mxc/memory.h b/include/asm-arm/arch-mxc/memory.h
index 059f830..5650543 100644
--- a/include/asm-arm/arch-mxc/memory.h
+++ b/include/asm-arm/arch-mxc/memory.h
@@ -14,6 +14,19 @@
 #include <asm/hardware.h>
 
 /*
+ * Physical start address of the first bank of RAM
+ */
+#if defined(PHYS_OFFSET)
+
+/*! This is needed for L2 Cache support */
+#define PHYS_OFFSET_ASM         PHYS_OFFSET
+#define PAGE_OFFSET_ASM         0xC0000000
+
+#else
+#error "Define PHYS_OFFSET to the base of the physical memory's PA"
+#endif
+
+/*
  * Virtual view <-> DMA view memory address translations
  * This macro is used to translate the virtual address to an address
  * suitable to be passed to set_dma_addr()
diff --git a/include/asm-arm/arch-mxc/mx31.h b/include/asm-arm/arch-mxc/mx31.h
index 36a1af4..31aa073 100644
--- a/include/asm-arm/arch-mxc/mx31.h
+++ b/include/asm-arm/arch-mxc/mx31.h
@@ -11,6 +11,8 @@
 #ifndef __ASM_ARCH_MXC_MX31_H__
 #define __ASM_ARCH_MXC_MX31_H__
 
+#include <asm/arch/mx31_pins.h>
+
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
 #error "Do not include directly."
 #endif
@@ -58,6 +60,22 @@
 #define PCMCIA_MEM_BASE_ADDR	0xBC000000
 
 /*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 5
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+/*
  * IRAM
  */
 #define IRAM_BASE_ADDR		0x1FFC0000	/* internal ram */
@@ -120,6 +138,34 @@
 #define MSHC2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
 #define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
 
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
 /*
  * AIPS 2
  */
@@ -247,6 +293,46 @@
 #define PHYS_OFFSET             CSD0_BASE_ADDR
 
 /*
+ * DMA request assignments
+ */
+#define DMA_REQ_GPIO1_0    31
+#define DMA_REQ_NFC        30
+#define DMA_REQ_SSI1_TX1   29
+#define DMA_REQ_SSI1_RX1   28
+#define DMA_REQ_SSI1_TX2   27
+#define DMA_REQ_SSI1_RX2   26
+#define DMA_REQ_SSI2_TX1   25
+#define DMA_REQ_SSI2_RX1   24
+#define DMA_REQ_SSI2_TX2   23
+#define DMA_REQ_SSI2_RX2   22
+#define DMA_REQ_SDHC2      21
+#define DMA_REQ_SDHC1      20
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_FIRI_TX    17
+#define DMA_REQ_FIRI_RX    16
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_GPIO1_1    15
+#define DMA_REQ_GPIO1_2    14
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_UART5_TX   11
+#define DMA_REQ_UART5_RX   10
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_UART3_TX   9
+#define DMA_REQ_UART3_RX   8
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_SIM        5
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_CCM        1
+#define DMA_REQ_reserved   0
+
+/*
  * Interrupt numbers
  */
 #define MXC_INT_PEN_ADS7843	0
@@ -347,6 +433,14 @@
 #define SYSTEM_REV_MIN		CHIP_REV_1_0
 #define SYSTEM_REV_NUM		3
 
+/*
+ * PWM control register used in clock API for
+ * finding clock source for the module
+ */
+#define MXC_PWM_PWMCTRL         IO_ADDRESS(PWM_BASE_ADDR)
+#define PWM_CTRL_MASK           0xFFFCFFFF
+#define PWM_CTRL_OFFSET         16
+
 #if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
 
 /* this is a i.MX31 CPU */
diff --git a/include/asm-arm/arch-mxc/mx31_pins.h b/include/asm-arm/arch-mxc/mx31_pins.h
new file mode 100644
index 0000000..7135007
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx31_pins.h
@@ -0,0 +1,438 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX31_PINS_H__
+#define __ASM_ARCH_MXC_MX31_PINS_H__
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20  | 19 - 18 | 17 - 10| 9 - 8 | 7 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   |     RSVD    |  PAD_F  |  PAD_I | MUX_F | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base + 0xC) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Bit 8 to 9 is MUX_F which
+ * contains the offset value defined WITHIN the same register (each IOMUX
+ * control register contains four 8-bit fields for four different pins). The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX31_PIN_A0 is defined in the enumeration:
+ *    ( 73 << MUX_I) | (0 << MUX_F)|( 98 << PAD_I) | (0 << PAD_F)
+ * It means the mux control register is at register offset 73. So the absolute
+ * address is: 0xC+73*4=0x130   0 << MUX_F means the control bits are at the
+ * least significant bits within the register. The pad control register offset
+ * is: 0x154+98*4=0x2DC and also occupy the least significant bits within the
+ * register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	29
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	24
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register index (0-based)
+ */
+#define MUX_I		0
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within IOMUX control register for control bits
+ * (legal values are 0, 1, 2, 3)
+ */
+#define MUX_F		8
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register index (0-based)
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within PAD control register for control bits
+ * (legal values are 0, 1, 2)
+ */
+#define PAD_F		18
+
+#define _MXC_BUILD_PIN(gp,gi,mi,mf,pi,pf) \
+	((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | ((mi) << MUX_I) | \
+	((mf) << MUX_F) | ((pi) << PAD_I) | ((pf) << PAD_F)
+
+#define _MXC_BUILD_GPIO_PIN(gp,gi,mi,mf,pi,pf) \
+		_MXC_BUILD_PIN(gp,gi,mi,mf,pi,pf)
+#define _MXC_BUILD_NON_GPIO_PIN(mi,mf,pi,pf) \
+		_MXC_BUILD_PIN(7,0,mi,mf,pi,pf)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX31 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+typedef enum iomux_pins {
+	MX31_PIN_CSPI3_MISO = _MXC_BUILD_NON_GPIO_PIN(0, 3, 1, 2),
+	MX31_PIN_CSPI3_SCLK = _MXC_BUILD_NON_GPIO_PIN(0, 2, 1, 1),
+	MX31_PIN_CSPI3_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(0, 1, 1, 0),
+	MX31_PIN_TTM_PAD = _MXC_BUILD_NON_GPIO_PIN(0, 0, 0, 2),
+	MX31_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(2, 31, 1, 3, 3, 0),
+	MX31_PIN_CE_CONTROL = _MXC_BUILD_NON_GPIO_PIN(1, 2, 2, 2),
+	MX31_PIN_CLKSS = _MXC_BUILD_NON_GPIO_PIN(1, 1, 2, 1),
+	MX31_PIN_CSPI3_MOSI = _MXC_BUILD_NON_GPIO_PIN(1, 0, 2, 0),
+	MX31_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(2, 27, 2, 3, 4, 1),
+	MX31_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(2, 28, 2, 2, 4, 0),
+	MX31_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(2, 29, 2, 1, 3, 2),
+	MX31_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(2, 30, 2, 0, 3, 1),
+	MX31_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 29, 3, 3, 5, 2),
+	MX31_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 30, 3, 2, 5, 1),
+	MX31_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 31, 3, 1, 5, 0),
+	MX31_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0, 4, 2),
+	MX31_PIN_D3_SPL = _MXC_BUILD_NON_GPIO_PIN(4, 3, 7, 0),
+	MX31_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 26, 4, 2, 6, 2),
+	MX31_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 27, 4, 1, 6, 1),
+	MX31_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 28, 4, 0, 6, 0),
+	MX31_PIN_VSYNC3 = _MXC_BUILD_NON_GPIO_PIN(5, 3, 8, 1),
+	MX31_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(5, 2, 8, 0),
+	MX31_PIN_D3_REV = _MXC_BUILD_NON_GPIO_PIN(5, 1, 7, 2),
+	MX31_PIN_D3_CLS = _MXC_BUILD_NON_GPIO_PIN(5, 0, 7, 1),
+	MX31_PIN_SER_RS = _MXC_BUILD_GPIO_PIN(2, 25, 6, 3, 9, 2),
+	MX31_PIN_PAR_RS = _MXC_BUILD_NON_GPIO_PIN(6, 2, 9, 1),
+	MX31_PIN_WRITE = _MXC_BUILD_NON_GPIO_PIN(6, 1, 9, 0),
+	MX31_PIN_READ = _MXC_BUILD_NON_GPIO_PIN(6, 0, 8, 2),
+	MX31_PIN_SD_D_IO = _MXC_BUILD_GPIO_PIN(2, 21, 7, 3, 11, 0),
+	MX31_PIN_SD_D_CLK = _MXC_BUILD_GPIO_PIN(2, 22, 7, 2, 10, 2),
+	MX31_PIN_LCS0 = _MXC_BUILD_GPIO_PIN(2, 23, 7, 1, 10, 1),
+	MX31_PIN_LCS1 = _MXC_BUILD_GPIO_PIN(2, 24, 7, 0, 10, 0),
+	MX31_PIN_HSYNC = _MXC_BUILD_NON_GPIO_PIN(8, 3, 12, 1),
+	MX31_PIN_FPSHIFT = _MXC_BUILD_NON_GPIO_PIN(8, 2, 12, 0),
+	MX31_PIN_DRDY0 = _MXC_BUILD_NON_GPIO_PIN(8, 1, 11, 2),
+	MX31_PIN_SD_D_I = _MXC_BUILD_GPIO_PIN(2, 20, 8, 0, 11, 1),
+	MX31_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(9, 3, 13, 2),
+	MX31_PIN_LD16 = _MXC_BUILD_NON_GPIO_PIN(9, 2, 13, 1),
+	MX31_PIN_LD17 = _MXC_BUILD_NON_GPIO_PIN(9, 1, 13, 0),
+	MX31_PIN_VSYNC0 = _MXC_BUILD_NON_GPIO_PIN(9, 0, 12, 2),
+	MX31_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(10, 3, 15, 0),
+	MX31_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(10, 2, 14, 2),
+	MX31_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(10, 1, 14, 1),
+	MX31_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(10, 0, 14, 0),
+	MX31_PIN_LD7 = _MXC_BUILD_NON_GPIO_PIN(11, 3, 16, 1),
+	MX31_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(11, 2, 16, 0),
+	MX31_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(11, 1, 15, 2),
+	MX31_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(11, 0, 15, 1),
+	MX31_PIN_LD3 = _MXC_BUILD_NON_GPIO_PIN(12, 3, 17, 2),
+	MX31_PIN_LD4 = _MXC_BUILD_NON_GPIO_PIN(12, 2, 17, 1),
+	MX31_PIN_LD5 = _MXC_BUILD_NON_GPIO_PIN(12, 1, 17, 0),
+	MX31_PIN_LD6 = _MXC_BUILD_NON_GPIO_PIN(12, 0, 16, 2),
+	MX31_PIN_USBH2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(13, 3, 19, 0),
+	MX31_PIN_LD0 = _MXC_BUILD_NON_GPIO_PIN(13, 2, 18, 2),
+	MX31_PIN_LD1 = _MXC_BUILD_NON_GPIO_PIN(13, 1, 18, 1),
+	MX31_PIN_LD2 = _MXC_BUILD_NON_GPIO_PIN(13, 0, 18, 0),
+	MX31_PIN_USBH2_DIR = _MXC_BUILD_NON_GPIO_PIN(14, 3, 20, 1),
+	MX31_PIN_USBH2_STP = _MXC_BUILD_NON_GPIO_PIN(14, 2, 20, 0),
+	MX31_PIN_USBH2_NXT = _MXC_BUILD_NON_GPIO_PIN(14, 1, 19, 2),
+	MX31_PIN_USBH2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(14, 0, 19, 1),
+	MX31_PIN_USBOTG_DATA5 = _MXC_BUILD_NON_GPIO_PIN(15, 3, 21, 2),
+	MX31_PIN_USBOTG_DATA6 = _MXC_BUILD_NON_GPIO_PIN(15, 2, 21, 1),
+	MX31_PIN_USBOTG_DATA7 = _MXC_BUILD_NON_GPIO_PIN(15, 1, 21, 0),
+	MX31_PIN_USBH2_CLK = _MXC_BUILD_NON_GPIO_PIN(15, 0, 20, 2),
+	MX31_PIN_USBOTG_DATA1 = _MXC_BUILD_NON_GPIO_PIN(16, 3, 23, 0),
+	MX31_PIN_USBOTG_DATA2 = _MXC_BUILD_NON_GPIO_PIN(16, 2, 22, 2),
+	MX31_PIN_USBOTG_DATA3 = _MXC_BUILD_NON_GPIO_PIN(16, 1, 22, 1),
+	MX31_PIN_USBOTG_DATA4 = _MXC_BUILD_NON_GPIO_PIN(16, 0, 22, 0),
+	MX31_PIN_USBOTG_DIR = _MXC_BUILD_NON_GPIO_PIN(17, 3, 24, 1),
+	MX31_PIN_USBOTG_STP = _MXC_BUILD_NON_GPIO_PIN(17, 2, 24, 0),
+	MX31_PIN_USBOTG_NXT = _MXC_BUILD_NON_GPIO_PIN(17, 1, 23, 2),
+	MX31_PIN_USBOTG_DATA0 = _MXC_BUILD_NON_GPIO_PIN(17, 0, 23, 1),
+	MX31_PIN_USB_PWR = _MXC_BUILD_GPIO_PIN(0, 29, 18, 3, 25, 2),
+	MX31_PIN_USB_OC = _MXC_BUILD_GPIO_PIN(0, 30, 18, 2, 25, 1),
+	MX31_PIN_USB_BYP = _MXC_BUILD_GPIO_PIN(0, 31, 18, 1, 25, 0),
+	MX31_PIN_USBOTG_CLK = _MXC_BUILD_NON_GPIO_PIN(18, 0, 24, 2),
+	MX31_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(19, 3, 27, 0),
+	MX31_PIN_TRSTB = _MXC_BUILD_NON_GPIO_PIN(19, 2, 26, 2),
+	MX31_PIN_DE_B = _MXC_BUILD_NON_GPIO_PIN(19, 1, 26, 1),
+	MX31_PIN_SJC_MOD = _MXC_BUILD_NON_GPIO_PIN(19, 0, 26, 0),
+	MX31_PIN_RTCK = _MXC_BUILD_NON_GPIO_PIN(20, 3, 28, 1),
+	MX31_PIN_TCK = _MXC_BUILD_NON_GPIO_PIN(20, 2, 28, 0),
+	MX31_PIN_TMS = _MXC_BUILD_NON_GPIO_PIN(20, 1, 27, 2),
+	MX31_PIN_TDI = _MXC_BUILD_NON_GPIO_PIN(20, 0, 27, 1),
+	MX31_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN(1, 22, 21, 3, 29, 2),
+	MX31_PIN_KEY_COL5 = _MXC_BUILD_GPIO_PIN(1, 23, 21, 2, 29, 1),
+	MX31_PIN_KEY_COL6 = _MXC_BUILD_GPIO_PIN(1, 24, 21, 1, 29, 0),
+	MX31_PIN_KEY_COL7 = _MXC_BUILD_GPIO_PIN(1, 25, 21, 0, 28, 2),
+	MX31_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(22, 3, 31, 0),
+	MX31_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(22, 2, 30, 2),
+	MX31_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(22, 1, 30, 1),
+	MX31_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(22, 0, 30, 0),
+	MX31_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN(1, 18, 23, 3, 32, 1),
+	MX31_PIN_KEY_ROW5 = _MXC_BUILD_GPIO_PIN(1, 19, 23, 2, 32, 0),
+	MX31_PIN_KEY_ROW6 = _MXC_BUILD_GPIO_PIN(1, 20, 23, 1, 31, 2),
+	MX31_PIN_KEY_ROW7 = _MXC_BUILD_GPIO_PIN(1, 21, 23, 0, 31, 1),
+	MX31_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(24, 3, 33, 2),
+	MX31_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(24, 2, 33, 1),
+	MX31_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(24, 1, 33, 0),
+	MX31_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(24, 0, 32, 2),
+	MX31_PIN_TXD2 = _MXC_BUILD_GPIO_PIN(0, 28, 25, 3, 35, 0),
+	MX31_PIN_RTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 2, 34, 2),
+	MX31_PIN_CTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 1, 34, 1),
+	MX31_PIN_BATT_LINE = _MXC_BUILD_GPIO_PIN(1, 17, 25, 0, 34, 0),
+	MX31_PIN_RI_DTE1 = _MXC_BUILD_GPIO_PIN(1, 14, 26, 3, 36, 1),
+	MX31_PIN_DCD_DTE1 = _MXC_BUILD_GPIO_PIN(1, 15, 26, 2, 36, 0),
+	MX31_PIN_DTR_DCE2 = _MXC_BUILD_GPIO_PIN(1, 16, 26, 1, 35, 2),
+	MX31_PIN_RXD2 = _MXC_BUILD_GPIO_PIN(0, 27, 26, 0, 35, 1),
+	MX31_PIN_RI_DCE1 = _MXC_BUILD_GPIO_PIN(1, 10, 27, 3, 37, 2),
+	MX31_PIN_DCD_DCE1 = _MXC_BUILD_GPIO_PIN(1, 11, 27, 2, 37, 1),
+	MX31_PIN_DTR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 12, 27, 1, 37, 0),
+	MX31_PIN_DSR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 13, 27, 0, 36, 2),
+	MX31_PIN_RTS1 = _MXC_BUILD_GPIO_PIN(1, 6, 28, 3, 39, 0),
+	MX31_PIN_CTS1 = _MXC_BUILD_GPIO_PIN(1, 7, 28, 2, 38, 2),
+	MX31_PIN_DTR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 8, 28, 1, 38, 1),
+	MX31_PIN_DSR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 9, 28, 0, 38, 0),
+	MX31_PIN_CSPI2_SCLK = _MXC_BUILD_NON_GPIO_PIN(29, 3, 40, 1),
+	MX31_PIN_CSPI2_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(29, 2, 40, 0),
+	MX31_PIN_RXD1 = _MXC_BUILD_GPIO_PIN(1, 4, 29, 1, 39, 2),
+	MX31_PIN_TXD1 = _MXC_BUILD_GPIO_PIN(1, 5, 29, 0, 39, 1),
+	MX31_PIN_CSPI2_MISO = _MXC_BUILD_NON_GPIO_PIN(30, 3, 41, 2),
+	MX31_PIN_CSPI2_SS0 = _MXC_BUILD_NON_GPIO_PIN(30, 2, 41, 1),
+	MX31_PIN_CSPI2_SS1 = _MXC_BUILD_NON_GPIO_PIN(30, 1, 41, 0),
+	MX31_PIN_CSPI2_SS2 = _MXC_BUILD_NON_GPIO_PIN(30, 0, 40, 2),
+	MX31_PIN_CSPI1_SS2 = _MXC_BUILD_NON_GPIO_PIN(31, 3, 43, 0),
+	MX31_PIN_CSPI1_SCLK = _MXC_BUILD_NON_GPIO_PIN(31, 2, 42, 2),
+	MX31_PIN_CSPI1_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(31, 1, 42, 1),
+	MX31_PIN_CSPI2_MOSI = _MXC_BUILD_NON_GPIO_PIN(31, 0, 42, 0),
+	MX31_PIN_CSPI1_MOSI = _MXC_BUILD_NON_GPIO_PIN(32, 3, 44, 1),
+	MX31_PIN_CSPI1_MISO = _MXC_BUILD_NON_GPIO_PIN(32, 2, 44, 0),
+	MX31_PIN_CSPI1_SS0 = _MXC_BUILD_NON_GPIO_PIN(32, 1, 43, 2),
+	MX31_PIN_CSPI1_SS1 = _MXC_BUILD_NON_GPIO_PIN(32, 0, 43, 1),
+	MX31_PIN_STXD6 = _MXC_BUILD_GPIO_PIN(0, 23, 33, 3, 45, 2),
+	MX31_PIN_SRXD6 = _MXC_BUILD_GPIO_PIN(0, 24, 33, 2, 45, 1),
+	MX31_PIN_SCK6 = _MXC_BUILD_GPIO_PIN(0, 25, 33, 1, 45, 0),
+	MX31_PIN_SFS6 = _MXC_BUILD_GPIO_PIN(0, 26, 33, 0, 44, 2),
+	MX31_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 21, 34, 3, 47, 0),
+	MX31_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 22, 34, 2, 46, 2),
+	MX31_PIN_SCK5 = _MXC_BUILD_NON_GPIO_PIN(34, 1, 46, 1),
+	MX31_PIN_SFS5 = _MXC_BUILD_NON_GPIO_PIN(34, 0, 46, 0),
+	MX31_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(0, 19, 35, 3, 48, 1),
+	MX31_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(0, 20, 35, 2, 48, 0),
+	MX31_PIN_SCK4 = _MXC_BUILD_NON_GPIO_PIN(35, 1, 47, 2),
+	MX31_PIN_SFS4 = _MXC_BUILD_NON_GPIO_PIN(35, 0, 47, 1),
+	MX31_PIN_STXD3 = _MXC_BUILD_GPIO_PIN(0, 17, 36, 3, 49, 2),
+	MX31_PIN_SRXD3 = _MXC_BUILD_GPIO_PIN(0, 18, 36, 2, 49, 1),
+	MX31_PIN_SCK3 = _MXC_BUILD_NON_GPIO_PIN(36, 1, 49, 0),
+	MX31_PIN_SFS3 = _MXC_BUILD_NON_GPIO_PIN(36, 0, 48, 2),
+	MX31_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(2, 18, 37, 3, 51, 0),
+	MX31_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(2, 19, 37, 2, 50, 2),
+	MX31_PIN_I2C_CLK = _MXC_BUILD_NON_GPIO_PIN(37, 1, 50, 1),
+	MX31_PIN_I2C_DAT = _MXC_BUILD_NON_GPIO_PIN(37, 0, 50, 0),
+	MX31_PIN_CSI_D14 = _MXC_BUILD_GPIO_PIN(2, 14, 38, 3, 52, 1),
+	MX31_PIN_CSI_D15 = _MXC_BUILD_GPIO_PIN(2, 15, 38, 2, 52, 0),
+	MX31_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(2, 16, 38, 1, 51, 2),
+	MX31_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(2, 17, 38, 0, 51, 1),
+	MX31_PIN_CSI_D10 = _MXC_BUILD_GPIO_PIN(2, 10, 39, 3, 53, 2),
+	MX31_PIN_CSI_D11 = _MXC_BUILD_GPIO_PIN(2, 11, 39, 2, 53, 1),
+	MX31_PIN_CSI_D12 = _MXC_BUILD_GPIO_PIN(2, 12, 39, 1, 53, 0),
+	MX31_PIN_CSI_D13 = _MXC_BUILD_GPIO_PIN(2, 13, 39, 0, 52, 2),
+	MX31_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(2, 6, 40, 3, 55, 0),
+	MX31_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(2, 7, 40, 2, 54, 2),
+	MX31_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(2, 8, 40, 1, 54, 1),
+	MX31_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(2, 9, 40, 0, 54, 0),
+	MX31_PIN_M_REQUEST = _MXC_BUILD_NON_GPIO_PIN(41, 3, 56, 1),
+	MX31_PIN_M_GRANT = _MXC_BUILD_NON_GPIO_PIN(41, 2, 56, 0),
+	MX31_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(2, 4, 41, 1, 55, 2),
+	MX31_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(2, 5, 41, 0, 55, 1),
+	MX31_PIN_PC_RST = _MXC_BUILD_NON_GPIO_PIN(42, 3, 57, 2),
+	MX31_PIN_IOIS16 = _MXC_BUILD_NON_GPIO_PIN(42, 2, 57, 1),
+	MX31_PIN_PC_RW_B = _MXC_BUILD_NON_GPIO_PIN(42, 1, 57, 0),
+	MX31_PIN_PC_POE = _MXC_BUILD_NON_GPIO_PIN(42, 0, 56, 2),
+	MX31_PIN_PC_VS1 = _MXC_BUILD_NON_GPIO_PIN(43, 3, 59, 0),
+	MX31_PIN_PC_VS2 = _MXC_BUILD_NON_GPIO_PIN(43, 2, 58, 2),
+	MX31_PIN_PC_BVD1 = _MXC_BUILD_NON_GPIO_PIN(43, 1, 58, 1),
+	MX31_PIN_PC_BVD2 = _MXC_BUILD_NON_GPIO_PIN(43, 0, 58, 0),
+	MX31_PIN_PC_CD2_B = _MXC_BUILD_NON_GPIO_PIN(44, 3, 60, 1),
+	MX31_PIN_PC_WAIT_B = _MXC_BUILD_NON_GPIO_PIN(44, 2, 60, 0),
+	MX31_PIN_PC_READY = _MXC_BUILD_NON_GPIO_PIN(44, 1, 59, 2),
+	MX31_PIN_PC_PWRON = _MXC_BUILD_NON_GPIO_PIN(44, 0, 59, 1),
+	MX31_PIN_D2 = _MXC_BUILD_NON_GPIO_PIN(45, 3, 61, 2),
+	MX31_PIN_D1 = _MXC_BUILD_NON_GPIO_PIN(45, 2, 61, 1),
+	MX31_PIN_D0 = _MXC_BUILD_NON_GPIO_PIN(45, 1, 61, 0),
+	MX31_PIN_PC_CD1_B = _MXC_BUILD_NON_GPIO_PIN(45, 0, 60, 2),
+	MX31_PIN_D6 = _MXC_BUILD_NON_GPIO_PIN(46, 3, 63, 0),
+	MX31_PIN_D5 = _MXC_BUILD_NON_GPIO_PIN(46, 2, 62, 2),
+	MX31_PIN_D4 = _MXC_BUILD_NON_GPIO_PIN(46, 1, 62, 1),
+	MX31_PIN_D3 = _MXC_BUILD_NON_GPIO_PIN(46, 0, 62, 0),
+	MX31_PIN_D10 = _MXC_BUILD_NON_GPIO_PIN(47, 3, 64, 1),
+	MX31_PIN_D9 = _MXC_BUILD_NON_GPIO_PIN(47, 2, 64, 0),
+	MX31_PIN_D8 = _MXC_BUILD_NON_GPIO_PIN(47, 1, 63, 2),
+	MX31_PIN_D7 = _MXC_BUILD_NON_GPIO_PIN(47, 0, 63, 1),
+	MX31_PIN_D14 = _MXC_BUILD_NON_GPIO_PIN(48, 3, 65, 2),
+	MX31_PIN_D13 = _MXC_BUILD_NON_GPIO_PIN(48, 2, 65, 1),
+	MX31_PIN_D12 = _MXC_BUILD_NON_GPIO_PIN(48, 1, 65, 0),
+	MX31_PIN_D11 = _MXC_BUILD_NON_GPIO_PIN(48, 0, 64, 2),
+	MX31_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(0, 14, 49, 3, 67, 0),
+	MX31_PIN_NFCE_B = _MXC_BUILD_GPIO_PIN(0, 15, 49, 2, 66, 2),
+	MX31_PIN_NFRB = _MXC_BUILD_GPIO_PIN(0, 16, 49, 1, 66, 1),
+	MX31_PIN_D15 = _MXC_BUILD_NON_GPIO_PIN(49, 0, 66, 0),
+	MX31_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(0, 10, 50, 3, 68, 1),
+	MX31_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(0, 11, 50, 2, 68, 0),
+	MX31_PIN_NFALE = _MXC_BUILD_GPIO_PIN(0, 12, 50, 1, 67, 2),
+	MX31_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(0, 13, 50, 0, 67, 1),
+	MX31_PIN_SDQS0 = _MXC_BUILD_NON_GPIO_PIN(51, 3, 69, 2),
+	MX31_PIN_SDQS1 = _MXC_BUILD_NON_GPIO_PIN(51, 2, 69, 1),
+	MX31_PIN_SDQS2 = _MXC_BUILD_NON_GPIO_PIN(51, 1, 69, 0),
+	MX31_PIN_SDQS3 = _MXC_BUILD_NON_GPIO_PIN(51, 0, 68, 2),
+	MX31_PIN_SDCKE0 = _MXC_BUILD_NON_GPIO_PIN(52, 3, 71, 0),
+	MX31_PIN_SDCKE1 = _MXC_BUILD_NON_GPIO_PIN(52, 2, 70, 2),
+	MX31_PIN_SDCLK = _MXC_BUILD_NON_GPIO_PIN(52, 1, 70, 1),
+	MX31_PIN_SDCLK_B = _MXC_BUILD_NON_GPIO_PIN(52, 0, 70, 0),
+	MX31_PIN_RW = _MXC_BUILD_NON_GPIO_PIN(53, 3, 72, 1),
+	MX31_PIN_RAS = _MXC_BUILD_NON_GPIO_PIN(53, 2, 72, 0),
+	MX31_PIN_CAS = _MXC_BUILD_NON_GPIO_PIN(53, 1, 71, 2),
+	MX31_PIN_SDWE = _MXC_BUILD_NON_GPIO_PIN(53, 0, 71, 1),
+	MX31_PIN_CS5 = _MXC_BUILD_NON_GPIO_PIN(54, 3, 73, 2),
+	MX31_PIN_ECB = _MXC_BUILD_NON_GPIO_PIN(54, 2, 73, 1),
+	MX31_PIN_LBA = _MXC_BUILD_NON_GPIO_PIN(54, 1, 73, 0),
+	MX31_PIN_BCLK = _MXC_BUILD_NON_GPIO_PIN(54, 0, 72, 2),
+	MX31_PIN_CS1 = _MXC_BUILD_NON_GPIO_PIN(55, 3, 75, 0),
+	MX31_PIN_CS2 = _MXC_BUILD_NON_GPIO_PIN(55, 2, 74, 2),
+	MX31_PIN_CS3 = _MXC_BUILD_NON_GPIO_PIN(55, 1, 74, 1),
+	MX31_PIN_CS4 = _MXC_BUILD_NON_GPIO_PIN(55, 0, 74, 0),
+	MX31_PIN_EB0 = _MXC_BUILD_NON_GPIO_PIN(56, 3, 76, 1),
+	MX31_PIN_EB1 = _MXC_BUILD_NON_GPIO_PIN(56, 2, 76, 0),
+	MX31_PIN_OE = _MXC_BUILD_NON_GPIO_PIN(56, 1, 75, 2),
+	MX31_PIN_CS0 = _MXC_BUILD_NON_GPIO_PIN(56, 0, 75, 1),
+	MX31_PIN_DQM0 = _MXC_BUILD_NON_GPIO_PIN(57, 3, 77, 2),
+	MX31_PIN_DQM1 = _MXC_BUILD_NON_GPIO_PIN(57, 2, 77, 1),
+	MX31_PIN_DQM2 = _MXC_BUILD_NON_GPIO_PIN(57, 1, 77, 0),
+	MX31_PIN_DQM3 = _MXC_BUILD_NON_GPIO_PIN(57, 0, 76, 2),
+	MX31_PIN_SD28 = _MXC_BUILD_NON_GPIO_PIN(58, 3, 79, 0),
+	MX31_PIN_SD29 = _MXC_BUILD_NON_GPIO_PIN(58, 2, 78, 2),
+	MX31_PIN_SD30 = _MXC_BUILD_NON_GPIO_PIN(58, 1, 78, 1),
+	MX31_PIN_SD31 = _MXC_BUILD_NON_GPIO_PIN(58, 0, 78, 0),
+	MX31_PIN_SD24 = _MXC_BUILD_NON_GPIO_PIN(59, 3, 80, 1),
+	MX31_PIN_SD25 = _MXC_BUILD_NON_GPIO_PIN(59, 2, 80, 0),
+	MX31_PIN_SD26 = _MXC_BUILD_NON_GPIO_PIN(59, 1, 79, 2),
+	MX31_PIN_SD27 = _MXC_BUILD_NON_GPIO_PIN(59, 0, 79, 1),
+	MX31_PIN_SD20 = _MXC_BUILD_NON_GPIO_PIN(60, 3, 81, 2),
+	MX31_PIN_SD21 = _MXC_BUILD_NON_GPIO_PIN(60, 2, 81, 1),
+	MX31_PIN_SD22 = _MXC_BUILD_NON_GPIO_PIN(60, 1, 81, 0),
+	MX31_PIN_SD23 = _MXC_BUILD_NON_GPIO_PIN(60, 0, 80, 2),
+	MX31_PIN_SD16 = _MXC_BUILD_NON_GPIO_PIN(61, 3, 83, 0),
+	MX31_PIN_SD17 = _MXC_BUILD_NON_GPIO_PIN(61, 2, 82, 2),
+	MX31_PIN_SD18 = _MXC_BUILD_NON_GPIO_PIN(61, 1, 82, 1),
+	MX31_PIN_SD19 = _MXC_BUILD_NON_GPIO_PIN(61, 0, 82, 0),
+	MX31_PIN_SD12 = _MXC_BUILD_NON_GPIO_PIN(62, 3, 84, 1),
+	MX31_PIN_SD13 = _MXC_BUILD_NON_GPIO_PIN(62, 2, 84, 0),
+	MX31_PIN_SD14 = _MXC_BUILD_NON_GPIO_PIN(62, 1, 83, 2),
+	MX31_PIN_SD15 = _MXC_BUILD_NON_GPIO_PIN(62, 0, 83, 1),
+	MX31_PIN_SD8 = _MXC_BUILD_NON_GPIO_PIN(63, 3, 85, 2),
+	MX31_PIN_SD9 = _MXC_BUILD_NON_GPIO_PIN(63, 2, 85, 1),
+	MX31_PIN_SD10 = _MXC_BUILD_NON_GPIO_PIN(63, 1, 85, 0),
+	MX31_PIN_SD11 = _MXC_BUILD_NON_GPIO_PIN(63, 0, 84, 2),
+	MX31_PIN_SD4 = _MXC_BUILD_NON_GPIO_PIN(64, 3, 87, 0),
+	MX31_PIN_SD5 = _MXC_BUILD_NON_GPIO_PIN(64, 2, 86, 2),
+	MX31_PIN_SD6 = _MXC_BUILD_NON_GPIO_PIN(64, 1, 86, 1),
+	MX31_PIN_SD7 = _MXC_BUILD_NON_GPIO_PIN(64, 0, 86, 0),
+	MX31_PIN_SD0 = _MXC_BUILD_NON_GPIO_PIN(65, 3, 88, 1),
+	MX31_PIN_SD1 = _MXC_BUILD_NON_GPIO_PIN(65, 2, 88, 0),
+	MX31_PIN_SD2 = _MXC_BUILD_NON_GPIO_PIN(65, 1, 87, 2),
+	MX31_PIN_SD3 = _MXC_BUILD_NON_GPIO_PIN(65, 0, 87, 1),
+	MX31_PIN_A24 = _MXC_BUILD_NON_GPIO_PIN(66, 3, 89, 2),
+	MX31_PIN_A25 = _MXC_BUILD_NON_GPIO_PIN(66, 2, 89, 1),
+	MX31_PIN_SDBA1 = _MXC_BUILD_NON_GPIO_PIN(66, 1, 89, 0),
+	MX31_PIN_SDBA0 = _MXC_BUILD_NON_GPIO_PIN(66, 0, 88, 2),
+	MX31_PIN_A20 = _MXC_BUILD_NON_GPIO_PIN(67, 3, 91, 0),
+	MX31_PIN_A21 = _MXC_BUILD_NON_GPIO_PIN(67, 2, 90, 2),
+	MX31_PIN_A22 = _MXC_BUILD_NON_GPIO_PIN(67, 1, 90, 1),
+	MX31_PIN_A23 = _MXC_BUILD_NON_GPIO_PIN(67, 0, 90, 0),
+	MX31_PIN_A16 = _MXC_BUILD_NON_GPIO_PIN(68, 3, 92, 1),
+	MX31_PIN_A17 = _MXC_BUILD_NON_GPIO_PIN(68, 2, 92, 0),
+	MX31_PIN_A18 = _MXC_BUILD_NON_GPIO_PIN(68, 1, 91, 2),
+	MX31_PIN_A19 = _MXC_BUILD_NON_GPIO_PIN(68, 0, 91, 1),
+	MX31_PIN_A12 = _MXC_BUILD_NON_GPIO_PIN(69, 3, 93, 2),
+	MX31_PIN_A13 = _MXC_BUILD_NON_GPIO_PIN(69, 2, 93, 1),
+	MX31_PIN_A14 = _MXC_BUILD_NON_GPIO_PIN(69, 1, 93, 0),
+	MX31_PIN_A15 = _MXC_BUILD_NON_GPIO_PIN(69, 0, 92, 2),
+	MX31_PIN_A9 = _MXC_BUILD_NON_GPIO_PIN(70, 3, 95, 0),
+	MX31_PIN_A10 = _MXC_BUILD_NON_GPIO_PIN(70, 2, 94, 2),
+	MX31_PIN_MA10 = _MXC_BUILD_NON_GPIO_PIN(70, 1, 94, 1),
+	MX31_PIN_A11 = _MXC_BUILD_NON_GPIO_PIN(70, 0, 94, 0),
+	MX31_PIN_A5 = _MXC_BUILD_NON_GPIO_PIN(71, 3, 96, 1),
+	MX31_PIN_A6 = _MXC_BUILD_NON_GPIO_PIN(71, 2, 96, 0),
+	MX31_PIN_A7 = _MXC_BUILD_NON_GPIO_PIN(71, 1, 95, 2),
+	MX31_PIN_A8 = _MXC_BUILD_NON_GPIO_PIN(71, 0, 95, 1),
+	MX31_PIN_A1 = _MXC_BUILD_NON_GPIO_PIN(72, 3, 97, 2),
+	MX31_PIN_A2 = _MXC_BUILD_NON_GPIO_PIN(72, 2, 97, 1),
+	MX31_PIN_A3 = _MXC_BUILD_NON_GPIO_PIN(72, 1, 97, 0),
+	MX31_PIN_A4 = _MXC_BUILD_NON_GPIO_PIN(72, 0, 96, 2),
+	MX31_PIN_DVFS1 = _MXC_BUILD_NON_GPIO_PIN(73, 3, 99, 0),
+	MX31_PIN_VPG0 = _MXC_BUILD_NON_GPIO_PIN(73, 2, 98, 2),
+	MX31_PIN_VPG1 = _MXC_BUILD_NON_GPIO_PIN(73, 1, 98, 1),
+	MX31_PIN_A0 = _MXC_BUILD_NON_GPIO_PIN(73, 0, 98, 0),
+	MX31_PIN_CKIL = _MXC_BUILD_NON_GPIO_PIN(74, 3, 100, 1),
+	MX31_PIN_POWER_FAIL = _MXC_BUILD_NON_GPIO_PIN(74, 2, 100, 0),
+	MX31_PIN_VSTBY = _MXC_BUILD_NON_GPIO_PIN(74, 1, 99, 2),
+	MX31_PIN_DVFS0 = _MXC_BUILD_NON_GPIO_PIN(74, 0, 99, 1),
+	MX31_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN(75, 3, 101, 2),
+	MX31_PIN_BOOT_MODE2 = _MXC_BUILD_NON_GPIO_PIN(75, 2, 101, 1),
+	MX31_PIN_BOOT_MODE3 = _MXC_BUILD_NON_GPIO_PIN(75, 1, 101, 0),
+	MX31_PIN_BOOT_MODE4 = _MXC_BUILD_NON_GPIO_PIN(75, 0, 100, 2),
+	MX31_PIN_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN(76, 3, 103, 0),
+	MX31_PIN_POR_B = _MXC_BUILD_NON_GPIO_PIN(76, 2, 102, 2),
+	MX31_PIN_CLKO = _MXC_BUILD_NON_GPIO_PIN(76, 1, 102, 1),
+	MX31_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN(76, 0, 102, 0),
+	MX31_PIN_STX0 = _MXC_BUILD_GPIO_PIN(1, 1, 77, 3, 104, 1),
+	MX31_PIN_SRX0 = _MXC_BUILD_GPIO_PIN(1, 2, 77, 2, 104, 0),
+	MX31_PIN_SIMPD0 = _MXC_BUILD_GPIO_PIN(1, 3, 77, 1, 103, 2),
+	MX31_PIN_CKIH = _MXC_BUILD_NON_GPIO_PIN(77, 0, 103, 1),
+	MX31_PIN_GPIO3_1 = _MXC_BUILD_GPIO_PIN(2, 1, 78, 3, 105, 2),
+	MX31_PIN_SCLK0 = _MXC_BUILD_GPIO_PIN(2, 2, 78, 2, 105, 1),
+	MX31_PIN_SRST0 = _MXC_BUILD_GPIO_PIN(2, 3, 78, 1, 105, 0),
+	MX31_PIN_SVEN0 = _MXC_BUILD_GPIO_PIN(1, 0, 78, 0, 104, 2),
+	MX31_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 79, 3, 107, 0),
+	MX31_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 79, 2, 106, 2),
+	MX31_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 79, 1, 106, 1),
+	MX31_PIN_GPIO3_0 = _MXC_BUILD_GPIO_PIN(2, 0, 79, 0, 106, 0),
+	MX31_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 80, 3, 108, 1),
+	MX31_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 80, 2, 108, 0),
+	MX31_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 80, 1, 107, 2),
+	MX31_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 80, 0, 107, 1),
+	MX31_PIN_CAPTURE = _MXC_BUILD_GPIO_PIN(0, 7, 81, 3, 109, 2),
+	MX31_PIN_COMPARE = _MXC_BUILD_GPIO_PIN(0, 8, 81, 2, 109, 1),
+	MX31_PIN_WATCHDOG_RST = _MXC_BUILD_NON_GPIO_PIN(81, 1, 109, 0),
+	MX31_PIN_PWMO = _MXC_BUILD_GPIO_PIN(0, 9, 81, 0, 108, 2),
+} iomux_pin_name_t;
+
+#endif
+#endif
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 146d3f6..1f44eb3 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -20,6 +20,26 @@
 # define cpu_is_mx31() (0)
 #endif
 
+#define IOMUX_TO_GPIO(pin)      ((((unsigned int)pin >> MUX_IO_P) * GPIO_NUM_PIN) + ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) -1)))
+#define IOMUX_TO_IRQ(pin)       (MXC_GPIO_INT_BASE + IOMUX_TO_GPIO(pin))
+#define GPIO_TO_PORT(n)         (n / GPIO_NUM_PIN)
+#define GPIO_TO_INDEX(n)        (n % GPIO_NUM_PIN)
+
+/*
+ *****************************************
+ * EPIT  Register definitions            *
+ *****************************************
+ */
+#ifndef EPIT1_AP_BASE_ADDR
+#define EPIT1_AP_BASE_ADDR      EPIT1_BASE_ADDR
+#endif
+
+#define MXC_EPIT_EPITCR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x00))
+#define MXC_EPIT_EPITSR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x04))
+#define MXC_EPIT_EPITLR         (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x08))
+#define MXC_EPIT_EPITCMPR       (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x0C))
+#define MXC_EPIT_EPITCNR        (IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x10))
+
 /*
  *****************************************
  * GPT  Register definitions             *
@@ -149,4 +169,13 @@
 #define IIM_PROD_REV_SH		3
 #define IIM_PROD_REV_LEN	5
 
+/* DMA driver defines */
+#define MXC_IDE_DMA_WATERMARK   32      /* DMA watermark level in bytes */
+#define MXC_IDE_DMA_BD_NR       (512/3/4)       /* Number of BDs per channel */
+
+/*!
+ * Interrupt Number for ARM11 PMU
+ */
+#define ARM11_PMU_IRQ           INT_EVTMON
+
 #endif /*  __ASM_ARCH_MXC_H__ */
diff --git a/include/asm-arm/arch-mxc/sdma.h b/include/asm-arm/arch-mxc/sdma.h
new file mode 100644
index 0000000..863aa02
--- /dev/null
+++ b/include/asm-arm/arch-mxc/sdma.h
@@ -0,0 +1,448 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SDMA_H__
+#define __ASM_ARCH_MXC_SDMA_H__
+
+/*!
+ * @defgroup SDMA Smart Direct Memory Access (SDMA) Driver
+ */
+
+/*!
+ * @file sdma.h
+ *
+ * @brief This file contains the SDMA API declarations.
+ *
+ * SDMA is responsible on moving data between peripherals and memories (MCU, EMI and DSP).
+ *
+ * @ingroup SDMA
+ */
+
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#include <asm/hardware.h>
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+/*!
+ * This defines maximum number of DMA channels
+ */
+#ifdef CONFIG_MXC_SDMA_API
+#define MAX_DMA_CHANNELS 32
+#define MAX_BD_NUMBER    16
+#define MXC_SDMA_DEFAULT_PRIORITY 1
+#define MXC_SDMA_MIN_PRIORITY 1
+#define MXC_SDMA_MAX_PRIORITY 7
+#else
+#define MAX_DMA_CHANNELS 0
+#endif
+
+/*!
+ * This enumerates  transfer types
+ */
+typedef enum {
+	emi_2_per = 0,		/*!< EMI memory to peripheral */
+	emi_2_int,		/*!< EMI memory to internal RAM */
+	emi_2_emi,		/*!< EMI memory to EMI memory */
+	emi_2_dsp,		/*!< EMI memory to DSP memory */
+	per_2_int,		/*!< Peripheral to internal RAM */
+	per_2_emi,		/*!< Peripheral to internal EMI memory */
+	per_2_dsp,		/*!< Peripheral to DSP memory */
+	int_2_per,		/*!< Internal RAM to peripheral */
+	int_2_int,		/*!< Internal RAM to Internal RAM */
+	int_2_emi,		/*!< Internal RAM to EMI memory */
+	int_2_dsp,		/*!< Internal RAM to DSP memory */
+	dsp_2_per,		/*!< DSP memory to peripheral */
+	dsp_2_int,		/*!< DSP memory to internal RAM */
+	dsp_2_emi,		/*!< DSP memory to EMI memory */
+	dsp_2_dsp,		/*!< DSP memory to DSP memory */
+	emi_2_dsp_loop,		/*!< EMI memory to DSP memory loopback */
+	dsp_2_emi_loop,		/*!< DSP memory to EMI memory loopback */
+	dvfs_pll,		/*!< DVFS script with PLL change       */
+	dvfs_pdr		/*!< DVFS script without PLL change    */
+} sdma_transferT;
+
+/*!
+ * This enumerates peripheral types
+ */
+typedef enum {
+	SSI,			/*!< MCU domain SSI */
+	SSI_SP,			/*!< Shared SSI */
+	MMC,			/*!< MMC */
+	SDHC,			/*!< SDHC */
+	UART,			/*!< MCU domain UART */
+	UART_SP,		/*!< Shared UART */
+	FIRI,			/*!< FIRI */
+	CSPI,			/*!< MCU domain CSPI */
+	CSPI_SP,		/*!< Shared CSPI */
+	SIM,			/*!< SIM */
+	ATA,			/*!< ATA */
+	CCM,			/*!< CCM */
+	EXT,			/*!< External peripheral */
+	MSHC,			/*!< Memory Stick Host Controller */
+	DSP,			/*!< DSP */
+	MEMORY			/*!< Memory */
+} sdma_periphT;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines SDMA access data size
+ */
+#define TRANSFER_32BIT      0x00
+#define TRANSFER_8BIT       0x01
+#define TRANSFER_16BIT      0x02
+#define TRANSFER_24BIT      0x03
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+
+/*!
+ * This defines SDMA interrupt callback function prototype.
+ */
+typedef void (*dma_callback_t) (void *arg);
+
+/*!
+ * Structure containing sdma channel parameters.
+ */
+typedef struct {
+	__u32 watermark_level;	/*!< Lower/upper threshold that
+				 *   triggers SDMA event
+				 */
+	__u32 per_address;	/*!< Peripheral source/destination
+				 *   physical address
+				 */
+	sdma_periphT peripheral_type;	/*!< Peripheral type */
+	sdma_transferT transfer_type;	/*!< Transfer type   */
+	int event_id;		/*!< Event number,
+				 *   needed by all channels
+				 *   that started by peripherals dma
+				 *   request (per_2_*,*_2_per)
+				 *   Not used for memory and DSP
+				 *   transfers.
+				 */
+	int event_id2;		/*!< Second event number,
+				 *   used in ATA scripts only.
+				 */
+	int bd_number;		/*!< Buffer descriptors number.
+				 *   If not set, single buffer
+				 *   descriptor will be used.
+				 */
+	dma_callback_t callback;	/*!   callback function            */
+	void *arg;		/*!   callback argument            */
+	unsigned long word_size:8;	/*!< SDMA data access word size    */
+} dma_channel_params;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*!   physical source memory address        */
+	__u8 *sourceAddr;
+	/*!   physical destination memory address   */
+	__u8 *destAddr;
+	/*!   amount of data to transfer,
+	 * updated during mxc_dma_get_config
+	 */
+	__u16 count;
+	/*!< DONE bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config
+	 * 0 - means the BD is done and closed by SDMA
+	 * 1 - means the BD is still being processed by SDMA
+	 */
+	int bd_done;
+	/*!< CONT bit of the buffer descriptor,
+	 * set it if full multi-buffer descriptor mechanism
+	 * required.
+	 */
+	int bd_cont;
+	/*!< ERROR bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config.
+	 * If it is set - there was an error during BD processing.
+	 */
+	int bd_error;
+} dma_request_t;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*! address of ap_2_ap script */
+	int mxc_sdma_ap_2_ap_addr;
+	/*! address of ap_2_bp script */
+	int mxc_sdma_ap_2_bp_addr;
+	/*! address of bp_2_ap script */
+	int mxc_sdma_bp_2_ap_addr;
+	/*! address of loopback_on_dsp_side script */
+	int mxc_sdma_loopback_on_dsp_side_addr;
+	/*! address of mcu_interrupt_only script */
+	int mxc_sdma_mcu_interrupt_only_addr;
+
+	/*! address of firi_2_per script */
+	int mxc_sdma_firi_2_per_addr;
+	/*! address of firi_2_mcu script */
+	int mxc_sdma_firi_2_mcu_addr;
+	/*! address of per_2_firi script */
+	int mxc_sdma_per_2_firi_addr;
+	/*! address of mcu_2_firi script */
+	int mxc_sdma_mcu_2_firi_addr;
+
+	/*! address of uart_2_per script */
+	int mxc_sdma_uart_2_per_addr;
+	/*! address of uart_2_mcu script */
+	int mxc_sdma_uart_2_mcu_addr;
+	/*! address of per_2_app script */
+	int mxc_sdma_per_2_app_addr;
+	/*! address of mcu_2_app script */
+	int mxc_sdma_mcu_2_app_addr;
+
+	/*! address of uartsh_2_per script */
+	int mxc_sdma_uartsh_2_per_addr;
+	/*! address of uartsh_2_mcu script */
+	int mxc_sdma_uartsh_2_mcu_addr;
+	/*! address of per_2_shp script */
+	int mxc_sdma_per_2_shp_addr;
+	/*! address of mcu_2_shp script */
+	int mxc_sdma_mcu_2_shp_addr;
+
+	/*! address of ata_2_mcu script */
+	int mxc_sdma_ata_2_mcu_addr;
+	/*! address of mcu_2_ata script */
+	int mxc_sdma_mcu_2_ata_addr;
+
+	/*! address of app_2_per script */
+	int mxc_sdma_app_2_per_addr;
+	/*! address of app_2_mcu script */
+	int mxc_sdma_app_2_mcu_addr;
+	/*! address of shp_2_per script */
+	int mxc_sdma_shp_2_per_addr;
+	/*! address of shp_2_mcu script */
+	int mxc_sdma_shp_2_mcu_addr;
+
+	/*! address of mshc_2_mcu script */
+	int mxc_sdma_mshc_2_mcu_addr;
+	/*! address of mcu_2_mshc script */
+	int mxc_sdma_mcu_2_mshc_addr;
+
+	/*! address of dptc_dvfs script */
+	int mxc_sdma_dptc_dvfs_addr;
+
+	/*! address where ram code starts */
+	int mxc_sdma_ram_code_start_addr;
+	/*! size of the ram code */
+	int mxc_sdma_ram_code_size;
+	/*! RAM image address */
+	unsigned short *mxc_sdma_start_addr;
+} sdma_script_start_addrs;
+
+/*! Structure to store the initialized dma_channel parameters */
+typedef struct mxc_sdma_channel_params {
+	/*! Channel params */
+	dma_channel_params chnl_params;
+	/*! Channel type (static channel number or dynamic channel) */
+	unsigned int channel_num;
+	/*! Channel priority [0x1(lowest) - 0x7(highest)] */
+	unsigned int chnl_priority;
+} mxc_sdma_channel_params_t;
+
+/*! Private SDMA data structure */
+typedef struct mxc_dma_channel_private {
+	/*! ID of the buffer that was processed */
+	unsigned int buf_tail;
+	/*! Tasklet for the channel */
+	struct tasklet_struct chnl_tasklet;
+	/*! Flag indicates if interrupt is required after every BD transfer */
+	int intr_after_every_bd;
+} mxc_dma_channel_private_t;
+
+/*!
+ * Setup channel according to parameters.
+ * Must be called once after mxc_request_dma()
+ *
+ * @param   channel           channel number
+ * @param   p                 channel parameters pointer
+ * @return  0 on success, error code on fail
+ */
+int mxc_dma_setup_channel(int channel, dma_channel_params * p);
+
+/*!
+ * Setup the channel priority. This can be used to change the default priority
+ * for the channel.
+ *
+ * @param   channel           channel number
+ * @param   priority          priority to be set for the channel
+ *
+ * @return  0 on success, error code on failure
+ */
+int mxc_dma_set_channel_priority(unsigned int channel, unsigned int priority);
+
+/*!
+ * Allocates dma channel.
+ * If channel's value is 0, then the function allocates a free channel
+ * dynamically and sets its value to channel.
+ * Else allocates requested channel if it is free.
+ * If the channel is busy or no free channels (in dynamic allocation) -EBUSY returned.
+ *
+ * @param   channel           pointer to channel number
+ * @param   devicename        device name
+ * @return  0 on success, error code on fail
+ */
+int mxc_request_dma(int *channel, const char *devicename);
+
+/*!
+ * Configures request parameters. Can be called multiple times after
+ * mxc_request_dma() and mxc_dma_setup_channel().
+ *
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to set
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_set_config(int channel, dma_request_t * p, int bd_index);
+
+/*!
+ * Returns request parameters.
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to get
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_get_config(int channel, dma_request_t * p, int bd_index);
+
+/*!
+ * Starts dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_start(int channel);
+
+/*!
+ * Stops dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_stop(int channel);
+
+/*!
+ * Frees dma channel.
+ *
+ * @param   channel           channel number
+ */
+void mxc_free_dma(int channel);
+
+/*!
+ * Sets callback function. Used with standard dma api
+ *  for supporting interrupts
+ *
+ * @param   channel           channel number
+ * @param   callback          callback function pointer
+ * @param   arg               argument for callback function
+ */
+void mxc_dma_set_callback(int channel, dma_callback_t callback, void *arg);
+
+/*!
+ * Allocates uncachable buffer. Uses hash table.
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_malloc(size_t size);
+
+/*!
+ * Frees uncachable buffer. Uses hash table.
+ */
+void sdma_free(void *buf);
+
+/*!
+ * Converts virtual to physical address. Uses hash table.
+ *
+ * @param   buf  virtual address pointer
+ * @return  physical address value
+ */
+unsigned long sdma_virt_to_phys(void *buf);
+
+/*!
+ * Converts physical to virtual address. Uses hash table.
+ *
+ * @param   buf  physical address value
+ * @return  virtual address pointer
+ */
+void *sdma_phys_to_virt(unsigned long buf);
+
+/*!
+ * Configures the BD_INTR bit on a buffer descriptor parameters.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ * @param   bd_intr           flag to set or clear the BD_INTR bit
+ */
+void mxc_dma_set_bd_intr(int channel, int bd_index, int bd_intr);
+
+/*!
+ * Gets the BD_INTR bit on a buffer descriptor.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ *
+ * @return returns the BD_INTR bit status
+ */
+int mxc_dma_get_bd_intr(int channel, int bd_index);
+
+/*!
+ * Stop the current transfer
+ *
+ * @param   channel           channel number
+ * @param   buffer_number     number of buffers (beginning with 0),
+ *                            whose done bits should be reset to 0
+ */
+int mxc_dma_reset(int channel, int buffer_number);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t * chnl);
+
+/*!
+ * Initializes SDMA driver
+ */
+int __init sdma_init(void);
+
+#define DEFAULT_ERR     1
+#define MXC_SDMA_DSPDMA 1
+
+#endif
diff --git a/include/asm-arm/arch-mxc/vmalloc.h b/include/asm-arm/arch-mxc/vmalloc.h
index 62d9762..773a4b7 100644
--- a/include/asm-arm/arch-mxc/vmalloc.h
+++ b/include/asm-arm/arch-mxc/vmalloc.h
@@ -21,6 +21,10 @@
 #define __ASM_ARCH_MXC_VMALLOC_H__
 
 /* vmalloc ending address */
+#ifdef CONFIG_ARCH_MX3
 #define VMALLOC_END       0xF4000000
+#else
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
+#endif
 
 #endif /* __ASM_ARCH_MXC_VMALLOC_H__ */
-- 
1.5.5.1

