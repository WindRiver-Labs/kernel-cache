From 0345afb0244a8b45782b9bd38135ea89e9be16d8 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 27 May 2010 18:38:44 +0800
Subject: [PATCH 1/7] mx3: add mx3 platforms common files

Add freescale mx3 platforms common files, include device, dma, clock,
cpu, crm, dptc/dvfs, pm, and usb etc.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-mx3/Kconfig                  |   50 ++
 arch/arm/mach-mx3/Makefile                 |   11 +-
 arch/arm/mach-mx3/clock-imx31.c            |   64 ++-
 arch/arm/mach-mx3/cpu.c                    |   46 ++
 arch/arm/mach-mx3/crm_regs.h               |   39 ++
 arch/arm/mach-mx3/devices.c                |  873 ++++++++++++++++++++--------
 arch/arm/mach-mx3/dma.c                    |  745 ++++++++++++++++++++++++
 arch/arm/mach-mx3/dptc.c                   |  103 ++++
 arch/arm/mach-mx3/dvfs_v2.c                |  535 +++++++++++++++++
 arch/arm/mach-mx3/iomux-imx31.c            |  125 ++++-
 arch/arm/mach-mx3/iomux.h                  |  195 +++++++
 arch/arm/mach-mx3/mx31_pins.h              |  429 ++++++++++++++
 arch/arm/mach-mx3/mxc_pm.c                 |  421 ++++++++++++++
 arch/arm/mach-mx3/pm.c                     |  102 ++++
 arch/arm/mach-mx3/sdma_script_code.h       |  581 ++++++++++++++++++
 arch/arm/mach-mx3/sdma_script_code_pass2.h |  434 ++++++++++++++
 arch/arm/mach-mx3/serial.h                 |  175 ++++++
 arch/arm/mach-mx3/system.c                 |   91 +++
 arch/arm/mach-mx3/usb.h                    |  116 ++++
 arch/arm/mach-mx3/usb_dr.c                 |  155 +++++
 arch/arm/mach-mx3/usb_h1.c                 |   52 ++
 arch/arm/mach-mx3/usb_h2.c                 |   69 +++
 22 files changed, 5140 insertions(+), 271 deletions(-)
 create mode 100644 arch/arm/mach-mx3/dma.c
 create mode 100644 arch/arm/mach-mx3/dptc.c
 create mode 100644 arch/arm/mach-mx3/dvfs_v2.c
 create mode 100644 arch/arm/mach-mx3/iomux.h
 create mode 100644 arch/arm/mach-mx3/mx31_pins.h
 create mode 100644 arch/arm/mach-mx3/mxc_pm.c
 create mode 100644 arch/arm/mach-mx3/pm.c
 create mode 100644 arch/arm/mach-mx3/sdma_script_code.h
 create mode 100644 arch/arm/mach-mx3/sdma_script_code_pass2.h
 create mode 100644 arch/arm/mach-mx3/serial.h
 create mode 100644 arch/arm/mach-mx3/system.c
 create mode 100644 arch/arm/mach-mx3/usb.h
 create mode 100644 arch/arm/mach-mx3/usb_dr.c
 create mode 100644 arch/arm/mach-mx3/usb_h1.c
 create mode 100644 arch/arm/mach-mx3/usb_h2.c

diff --git a/arch/arm/mach-mx3/Kconfig b/arch/arm/mach-mx3/Kconfig
index 170f68e..1fe072f 100644
--- a/arch/arm/mach-mx3/Kconfig
+++ b/arch/arm/mach-mx3/Kconfig
@@ -124,4 +124,54 @@ config MACH_KZM_ARM11_01
 	  Include support for KZM-ARM11-01. This includes specific
 	  configurations for the board and its peripherals.
 
+config MXC_SDMA_API
+	bool "Use SDMA API"
+	default y
+	help
+	  This selects the Freescale MXC SDMA API.
+	  If unsure, say N.
+
+menu "SDMA options"
+	depends on MXC_SDMA_API
+
+	config SDMA_IRAM
+		bool "Use Internal RAM for SDMA transfer"
+		default n
+		help
+		  Support Internal RAM as SDMA buffer or control structures
+
+	config SDMA_IRAM_SIZE
+		hex "Reserved bytes of IRAM for SDMA (0x800-0x2000)"
+		range 0x800 0x2000
+		depends on SDMA_IRAM
+		default "0x1000"
+		help
+		 Set the size of IRAM for SDMA. It must be multiple of 512bytes.
+endmenu
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	Enable MX31 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	Enable MX31 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	Enable MX31 I2C3 module.
+
+endmenu
+
 endif
diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 5d650fd..dc09187 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y				:= mm.o devices.o cpu.o
+obj-y				:= system.o cpu.o mm.o dptc.o devices.o dma.o mxc_pm.o dvfs_v2.o
 CFLAGS_mm.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
 CFLAGS_devices.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
 CFLAGS_cpu.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
@@ -24,3 +24,12 @@ obj-$(CONFIG_MACH_PCM043)	+= mach-pcm043.o
 obj-$(CONFIG_MACH_ARMADILLO5X0) += mach-armadillo5x0.o
 obj-$(CONFIG_MACH_MX35_3DS)	+= mach-mx35pdk.o
 obj-$(CONFIG_MACH_KZM_ARM11_01)	+= mach-kzm_arm11_01.o
+
+# power management
+obj-$(CONFIG_PM)                += pm.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H1)   += usb_h1.o
+obj-$(CONFIG_USB_EHCI_ARC_H2)   += usb_h2.o
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y   += usb_dr.o
+endif
diff --git a/arch/arm/mach-mx3/clock-imx31.c b/arch/arm/mach-mx3/clock-imx31.c
index 9a9eb6d..191aef8 100644
--- a/arch/arm/mach-mx3/clock-imx31.c
+++ b/arch/arm/mach-mx3/clock-imx31.c
@@ -104,6 +104,16 @@ static void cgr_disable(struct clk *clk)
 	__raw_writel(reg, clk->enable_reg);
 }
 
+static unsigned long _clk_cpu_get_rate(struct clk *clk)
+{
+	unsigned long mcu_pdf;
+
+	mcu_pdf = __raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_MCU_PODF_MASK >>
+				MXC_CCM_PDR0_MCU_PODF_OFFSET;
+
+	return clk->parent->get_rate(clk->parent) / (mcu_pdf + 1);
+}
+
 static unsigned long pll_ref_get_rate(void)
 {
 	unsigned long ccmr;
@@ -436,11 +446,28 @@ static struct clk usb_pll_clk = {
 	.disable = usb_pll_disable,
 };
 
+static struct clk cpu_clk = {
+	.parent = &mcu_main_clk,
+	.get_rate = _clk_cpu_get_rate,
+};
+
 static struct clk ahb_clk = {
 	.parent = &mcu_main_clk,
 	.get_rate = ahb_get_rate,
 };
 
+static struct clk sdma_ahb_clk = {
+	 .parent = &ahb_clk,
+	 .enable = cgr_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SDMA_OFFSET,
+	 .disable = cgr_disable,
+};
+
+static struct clk sdma_ipg_clk = {
+	 .parent = &ipg_clk,
+};
+
 #define DEFINE_CLOCK(name, i, er, es, gr, s, p)		\
 	static struct clk name = {			\
 		.id		= i,			\
@@ -524,6 +551,12 @@ DEFINE_CLOCK(ipg_clk,     0, NULL,          0, ipg_get_rate, NULL, &ahb_clk);
 	},
 
 static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "mcu_pll_clk", mcu_pll_clk)
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk)
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk)
+	_REGISTER_CLOCK(NULL, "ipg_clk", ipg_clk)
+	_REGISTER_CLOCK(NULL, "ckil", ckil_clk)
+	_REGISTER_CLOCK(NULL, "usb_pll", usb_pll_clk)
 	_REGISTER_CLOCK(NULL, "emi", emi_clk)
 	_REGISTER_CLOCK("spi_imx.0", NULL, cspi1_clk)
 	_REGISTER_CLOCK("spi_imx.1", NULL, cspi2_clk)
@@ -534,19 +567,13 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "rtc", rtc_clk)
 	_REGISTER_CLOCK(NULL, "epit", epit1_clk)
 	_REGISTER_CLOCK(NULL, "epit", epit2_clk)
-	_REGISTER_CLOCK("mxc_nand.0", NULL, nfc_clk)
-	_REGISTER_CLOCK("ipu-core", NULL, ipu_clk)
+	_REGISTER_CLOCK(NULL, "nfc_clk", nfc_clk)
+	_REGISTER_CLOCK(NULL, "ipu_clk", ipu_clk)
 	_REGISTER_CLOCK("mx3_sdc_fb", NULL, ipu_clk)
 	_REGISTER_CLOCK(NULL, "kpp", kpp_clk)
-	_REGISTER_CLOCK("mxc-ehci.0", "usb", usb_clk1)
-	_REGISTER_CLOCK("mxc-ehci.0", "usb_ahb", usb_clk2)
-	_REGISTER_CLOCK("mxc-ehci.1", "usb", usb_clk1)
-	_REGISTER_CLOCK("mxc-ehci.1", "usb_ahb", usb_clk2)
-	_REGISTER_CLOCK("mxc-ehci.2", "usb", usb_clk1)
-	_REGISTER_CLOCK("mxc-ehci.2", "usb_ahb", usb_clk2)
-	_REGISTER_CLOCK("fsl-usb2-udc", "usb", usb_clk1)
-	_REGISTER_CLOCK("fsl-usb2-udc", "usb_ahb", usb_clk2)
-	_REGISTER_CLOCK("mx3-camera.0", NULL, csi_clk)
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk1)
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_clk2)
+	_REGISTER_CLOCK(NULL, "csi_clk", csi_clk)
 	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk)
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk)
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk)
@@ -558,17 +585,17 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk)
 	_REGISTER_CLOCK("mxc-mmc.0", NULL, sdhc1_clk)
 	_REGISTER_CLOCK("mxc-mmc.1", NULL, sdhc2_clk)
-	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk)
-	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk)
+	_REGISTER_CLOCK(NULL, "ssi1_clk", ssi1_clk)
+	_REGISTER_CLOCK(NULL, "ssi2_clk", ssi2_clk)
 	_REGISTER_CLOCK(NULL, "firi", firi_clk)
-	_REGISTER_CLOCK(NULL, "ata", ata_clk)
+	_REGISTER_CLOCK(NULL, "ata_clk", ata_clk)
 	_REGISTER_CLOCK(NULL, "rtic", rtic_clk)
-	_REGISTER_CLOCK(NULL, "rng", rng_clk)
-	_REGISTER_CLOCK(NULL, "sdma_ahb", sdma_clk1)
-	_REGISTER_CLOCK(NULL, "sdma_ipg", sdma_clk2)
+	_REGISTER_CLOCK(NULL, "rng_clk", rng_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ahb_clk", sdma_ahb_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ipg_clk", sdma_ipg_clk)
 	_REGISTER_CLOCK(NULL, "mstick", mstick1_clk)
 	_REGISTER_CLOCK(NULL, "mstick", mstick2_clk)
-	_REGISTER_CLOCK(NULL, "scc", scc_clk)
+	_REGISTER_CLOCK(NULL, "scc_clk", scc_clk)
 	_REGISTER_CLOCK(NULL, "iim", iim_clk)
 	_REGISTER_CLOCK(NULL, "mpeg4", mpeg4_clk)
 	_REGISTER_CLOCK(NULL, "mbx", mbx_clk)
@@ -610,6 +637,7 @@ int __init mx31_clocks_init(unsigned long fref)
 	clk_enable(&gpt_clk);
 	clk_enable(&emi_clk);
 	clk_enable(&iim_clk);
+	clk_enable(&wdog_clk);
 
 	clk_enable(&serial_pll_clk);
 
diff --git a/arch/arm/mach-mx3/cpu.c b/arch/arm/mach-mx3/cpu.c
index 861afe0..f8089ab 100644
--- a/arch/arm/mach-mx3/cpu.c
+++ b/arch/arm/mach-mx3/cpu.c
@@ -55,3 +55,49 @@ void __init mx31_read_cpu_rev(void)
 
 	printk(KERN_WARNING "Unknown CPU identifier. srev = %02x\n", srev);
 }
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	/* Setup Peripheral Port Remap register for AVIC */
+	asm("ldr r0, =0xC0000015\n\
+	 mcr p15, 0, r0, c15, c2, 4");
+	if (!system_rev)
+		mxc_set_system_rev(0x31, CHIP_REV_2_0);
+}
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	volatile unsigned long aips_reg;
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx3/crm_regs.h b/arch/arm/mach-mx3/crm_regs.h
index 37a8a07..7f4a9a5 100644
--- a/arch/arm/mach-mx3/crm_regs.h
+++ b/arch/arm/mach-mx3/crm_regs.h
@@ -55,6 +55,7 @@
 #define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
 
 /* Register bit definitions */
+#define MXC_CCM_CCMR_VSTBY                      (1 << 28)
 #define MXC_CCM_CCMR_WBEN                       (1 << 27)
 #define MXC_CCM_CCMR_CSCS                       (1 << 25)
 #define MXC_CCM_CCMR_PERCS                      (1 << 24)
@@ -91,6 +92,42 @@
 #define MXC_CCM_PDR0_MCU_PODF_OFFSET            0
 #define MXC_CCM_PDR0_MCU_PODF_MASK              0x7
 
+#define MXC_CCM_PDR0_HSP_DIV_1                  (0x0 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_2                  (0x1 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_3                  (0x2 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_4                  (0x3 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_5                  (0x4 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_6                  (0x5 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_7                  (0x6 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_8                  (0x7 << 11)
+
+#define MXC_CCM_PDR0_IPG_DIV_1                  (0x0 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_2                  (0x1 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_3                  (0x2 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_4                  (0x3 << 6)
+
+#define MXC_CCM_PDR0_MAX_DIV_1                  (0x0 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_2                  (0x1 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_3                  (0x2 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_4                  (0x3 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_5                  (0x4 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_6                  (0x5 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_7                  (0x6 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_8                  (0x7 << 3)
+
+#define MXC_CCM_PDR0_NFC_DIV_1                  (0x0 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_2                  (0x1 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_3                  (0x2 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_4                  (0x3 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_5                  (0x4 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_6                  (0x5 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_7                  (0x6 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_8                  (0x7 << 8)
+
+#define MXC_CCM_PDR0_MCU_DIV_4                  0x3
+#define MXC_CCM_PDR0_MCU_DIV_2                  0x1
+#define MXC_CCM_PDR0_MCU_DIV_1                  0x0
+
 #define MXC_CCM_PDR1_USB_PRDF_OFFSET            30
 #define MXC_CCM_PDR1_USB_PRDF_MASK              (0x3 << 30)
 #define MXC_CCM_PDR1_USB_PODF_OFFSET            27
@@ -111,6 +148,8 @@
 /* Bit definitions for RCSR */
 #define MXC_CCM_RCSR_NF16B			0x80000000
 
+#define MXC_CCM_CGR0_SDMA_OFFSET                14
+
 /*
  * LTR0 register offsets
  */
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index f891115..44161d7 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -19,16 +19,105 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
+#include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/serial.h>
 #include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ata.h>
 #include <mach/hardware.h>
 #include <mach/irqs.h>
 #include <mach/common.h>
 #include <mach/imx-uart.h>
 #include <mach/mx3_camera.h>
+#include <mach/sdma.h>
+#include <mach/spba.h>
+#include <mach/mmc.h>
+#include <mach/spi.h>
+#include <mach/mxc_dptc.h>
+#include <mach/i2c.h>
+#include <asm/mach-types.h>
 
 #include "devices.h"
+#include "crm_regs.h"
+#include "sdma_script_code.h"
+#include "sdma_script_code_pass2.h"
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	if (cpu_is_mx31_rev(CHIP_REV_1_0) == 1) {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = -1;
+	} else {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr =
+		    ap_2_ap_fixed_addr_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = ap_2_bp_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr =
+		    ap_2_ap_fixed_addr_ADDR_2;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = bp_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_2;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR_2;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR_2;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR_2;
+	}
+}
 
 static struct resource uart0[] = {
 	{
@@ -167,26 +256,42 @@ struct platform_device mxc_w1_master_device = {
 	.resource = mxc_w1_master_resources,
 };
 
-static struct resource mxc_nand_resources[] = {
+#if defined(CONFIG_RTC_MXC) || defined(CONFIG_RTC_MXC_MODULE)
+static struct resource mxc_rtc_resources[] = {
 	{
-		.start	= 0, /* runtime dependent */
-		.end	= 0,
-		.flags	= IORESOURCE_MEM,
+		.start = RTC_BASE_ADDR,
+		.end = RTC_BASE_ADDR + 0x30,
+		.flags = IORESOURCE_MEM,
 	}, {
-		.start	= MXC_INT_NANDFC,
-		.end	= MXC_INT_NANDFC,
-		.flags	= IORESOURCE_IRQ,
+		.start = MXC_INT_RTC,
+		.end = MXC_INT_RTC,
+		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_nand_device = {
-	.name = "mxc_nand",
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_nand_resources),
-	.resource = mxc_nand_resources,
+	.num_resources  =   ARRAY_SIZE(mxc_rtc_resources),
+	.resource   =   mxc_rtc_resources,
 };
 
-static struct resource mxc_i2c0_resources[] = {
+int __init mxc_init_rtc(void)
+{
+	return platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/* Resource definition for the I2C1 */
+static struct resource mxc_i2c1_resources[] = {
 	{
 		.start = I2C_BASE_ADDR,
 		.end = I2C_BASE_ADDR + SZ_4K - 1,
@@ -198,14 +303,15 @@ static struct resource mxc_i2c0_resources[] = {
 	},
 };
 
-struct platform_device mxc_i2c_device0 = {
-	.name = "imx-i2c",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_i2c0_resources),
-	.resource = mxc_i2c0_resources,
+/*! Platform Data for MXC I2C1 */
+static struct mxc_i2c_platform_data mxci2c1_data = {
+	.i2c_clk = 100000,
 };
+#endif
 
-static struct resource mxc_i2c1_resources[] = {
+#ifdef CONFIG_I2C_MXC_SELECT2
+/* Resource definition for the I2C2 */
+static struct resource mxc_i2c2_resources[] = {
 	{
 		.start = I2C2_BASE_ADDR,
 		.end = I2C2_BASE_ADDR + SZ_4K - 1,
@@ -217,14 +323,15 @@ static struct resource mxc_i2c1_resources[] = {
 	},
 };
 
-struct platform_device mxc_i2c_device1 = {
-	.name = "imx-i2c",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(mxc_i2c1_resources),
-	.resource = mxc_i2c1_resources,
+/*! Platform Data for MXC I2C2 */
+static struct mxc_i2c_platform_data mxci2c2_data = {
+	.i2c_clk = 100000,
 };
+#endif
 
-static struct resource mxc_i2c2_resources[] = {
+#ifdef CONFIG_I2C_MXC_SELECT3
+/* Resource definition for the I2C3 */
+static struct resource mxc_i2c3_resources[] = {
 	{
 		.start = I2C3_BASE_ADDR,
 		.end = I2C3_BASE_ADDR + SZ_4K - 1,
@@ -236,52 +343,189 @@ static struct resource mxc_i2c2_resources[] = {
 	},
 };
 
-struct platform_device mxc_i2c_device2 = {
+/*! Platform Data for MXC I2C3 */
+static struct mxc_i2c_platform_data mxci2c3_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+/*! Device Definition for MXC I2C */
+struct platform_device mxci2c_devices[] = {
+#ifdef CONFIG_I2C_MXC_SELECT1
+	{
 	.name = "imx-i2c",
-	.id = 2,
+	.id = 0,
+	.dev = {
+		.platform_data = &mxci2c1_data,
+		},
+	.num_resources = 2,
+	.resource = mxc_i2c1_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	{
+	.name = "imx-i2c",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxci2c2_data,
+		},
 	.num_resources = ARRAY_SIZE(mxc_i2c2_resources),
-	.resource = mxc_i2c2_resources,
+	.resource = mxc_i2c2_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	{
+	.name = "imx-i2c",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxci2c3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxc_i2c3_resources),
+	.resource = mxc_i2c3_resources,},
+#endif
 };
 
+static inline void mxc_init_i2c(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
+		if (platform_device_register(&mxci2c_devices[i]) < 0)
+			dev_err(&mxci2c_devices[i].dev,
+				"Unable to register I2C device\n");
+	}
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
+
+
 #ifdef CONFIG_ARCH_MX31
-static struct resource mxcsdhc0_resources[] = {
-	{
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+extern int sdhc_write_protect(struct device *dev);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+static struct mxc_mmc_platform_data mxc_mmc1_data = {
+	.ocr_mask = MMC_VDD_32_33,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.power_mmc = "GPO1",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxc_sdhc1_resources[] = {
+	[0] = {
 		.start = MMC_SDHC1_BASE_ADDR,
-		.end = MMC_SDHC1_BASE_ADDR + SZ_16K - 1,
+		.end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 		.start = MXC_INT_MMC_SDHC1,
 		.end = MXC_INT_MMC_SDHC1,
 		.flags = IORESOURCE_IRQ,
 	},
+	[2] = {
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct resource mxcsdhc1_resources[] = {
-	{
+static struct mxc_mmc_platform_data mxc_mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_fixed = 1,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.power_mmc = "VMMC2",
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxc_sdhc2_resources[] = {
+	[0] = {
 		.start = MMC_SDHC2_BASE_ADDR,
-		.end = MMC_SDHC2_BASE_ADDR + SZ_16K - 1,
+		.end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 		.start = MXC_INT_MMC_SDHC2,
 		.end = MXC_INT_MMC_SDHC2,
 		.flags = IORESOURCE_IRQ,
 	},
+	[2] = {
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-struct platform_device mxcsdhc_device0 = {
+/*! Device Definition for MXC SDHC1 */
+struct platform_device mxc_sdhc1_device = {
 	.name = "mxc-mmc",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(mxcsdhc0_resources),
-	.resource = mxcsdhc0_resources,
+	.dev = {
+		.platform_data = &mxc_mmc1_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_sdhc1_resources),
+	.resource = mxc_sdhc1_resources,
 };
 
-struct platform_device mxcsdhc_device1 = {
+/*! Device Definition for MXC SDHC2 */
+struct platform_device mxc_sdhc2_device = {
 	.name = "mxc-mmc",
 	.id = 1,
-	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
-	.resource = mxcsdhc1_resources,
+	.dev = {
+		.platform_data = &mxc_mmc2_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_sdhc2_resources),
+	.resource = mxc_sdhc2_resources,
 };
 
+int __init mxc_init_mmc(void)
+{
+	int ret;
+	int cd_irq;
+
+	cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxc_sdhc1_device.resource[2].start = cd_irq;
+		mxc_sdhc1_device.resource[2].end = cd_irq;
+	}
+
+	cd_irq = sdhc_init_card_det(1);
+
+	if (cd_irq) {
+		mxc_sdhc2_device.resource[2].start = cd_irq;
+		mxc_sdhc2_device.resource[2].end = cd_irq;
+	}
+
+	spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
+	ret = platform_device_register(&mxc_sdhc1_device);
+	if (!ret) {
+		spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
+		ret = platform_device_register(&mxc_sdhc2_device);
+	}
+
+	return ret;
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_HW_RANDOM_FSL_RNGA) || \
+	defined(CONFIG_HW_RANDOM_FSL_RNGA_MODULE)
 static struct resource rnga_resources[] = {
 	{
 		.start = RNGA_BASE_ADDR,
@@ -296,225 +540,277 @@ struct platform_device mxc_rnga_device = {
 	.num_resources = 1,
 	.resource = rnga_resources,
 };
+
+static inline void mxc_init_rnga(void)
+{
+	platform_device_register(&mxc_rnga_device);
+}
+#else
+static inline void mxc_init_rnga(void)
+{
+}
+#endif
 #endif /* CONFIG_ARCH_MX31 */
 
 /* i.MX31 Image Processing Unit */
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
 
 /* The resource order is important! */
-static struct resource mx3_ipu_rsrc[] = {
-	{
+static struct resource ipu_resources[] = {
+	[0] = {
 		.start = IPU_CTRL_BASE_ADDR,
-		.end = IPU_CTRL_BASE_ADDR + 0x5F,
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = IPU_CTRL_BASE_ADDR + 0x88,
-		.end = IPU_CTRL_BASE_ADDR + 0xB3,
+		.end = IPU_CTRL_BASE_ADDR + SZ_4K,
 		.flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 		.start = MXC_INT_IPU_SYN,
-		.end = MXC_INT_IPU_SYN,
 		.flags = IORESOURCE_IRQ,
-	}, {
+	},
+	[2] = {
 		.start = MXC_INT_IPU_ERR,
-		.end = MXC_INT_IPU_ERR,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mx3_ipu = {
-	.name = "ipu-core",
+struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
 	.id = -1,
-	.num_resources = ARRAY_SIZE(mx3_ipu_rsrc),
-	.resource = mx3_ipu_rsrc,
-};
-
-static struct resource fb_resources[] = {
-	{
-		.start	= IPU_CTRL_BASE_ADDR + 0xB4,
-		.end	= IPU_CTRL_BASE_ADDR + 0x1BF,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-struct platform_device mx3_fb = {
-	.name		= "mx3_sdc_fb",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(fb_resources),
-	.resource	= fb_resources,
-	.dev		= {
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-       },
-};
-
-static struct resource camera_resources[] = {
-	{
-		.start	= IPU_CTRL_BASE_ADDR + 0x60,
-		.end	= IPU_CTRL_BASE_ADDR + 0x87,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-struct platform_device mx3_camera = {
-	.name		= "mx3-camera",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(camera_resources),
-	.resource	= camera_resources,
-	.dev		= {
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-};
-
-static struct resource otg_resources[] = {
-	{
-		.start	= MX31_OTG_BASE_ADDR,
-		.end	= MX31_OTG_BASE_ADDR + 0x1ff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= MXC_INT_USB3,
-		.end	= MXC_INT_USB3,
-		.flags	= IORESOURCE_IRQ,
-	},
+	.dev = {
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
 };
 
-static u64 otg_dmamask = DMA_BIT_MASK(32);
-
-/* OTG gadget device */
-struct platform_device mxc_otg_udc_device = {
-	.name		= "fsl-usb2-udc",
-	.id		= -1,
-	.dev		= {
-		.dma_mask		= &otg_dmamask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.resource	= otg_resources,
-	.num_resources	= ARRAY_SIZE(otg_resources),
-};
+void __init mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif /* CONFIG_MXC_IPU */
 
-/* OTG host */
-struct platform_device mxc_otg_host = {
-	.name = "mxc-ehci",
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
 	.id = 0,
-	.dev = {
-		.coherent_dma_mask = 0xffffffff,
-		.dma_mask = &otg_dmamask,
-	},
-	.resource = otg_resources,
-	.num_resources = ARRAY_SIZE(otg_resources),
 };
 
-/* USB host 1 */
-
-static u64 usbh1_dmamask = ~(u32)0;
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
 
-static struct resource mxc_usbh1_resources[] = {
-	{
-		.start = MX31_OTG_BASE_ADDR + 0x200,
-		.end = MX31_OTG_BASE_ADDR + 0x3ff,
+/* Resource definition for the DPTC LP */
+static struct resource dptc_resources[] = {
+	[0] = {
+		.start = CCM_BASE_ADDR,
+		.end = CCM_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
-	}, {
-		.start = MXC_INT_USB1,
-		.end = MXC_INT_USB1,
-		.flags = IORESOURCE_IRQ,
 	},
-};
-
-struct platform_device mxc_usbh1 = {
-	.name = "mxc-ehci",
-	.id = 1,
-	.dev = {
-		.coherent_dma_mask = 0xffffffff,
-		.dma_mask = &usbh1_dmamask,
-	},
-	.resource = mxc_usbh1_resources,
-	.num_resources = ARRAY_SIZE(mxc_usbh1_resources),
-};
-
-/* USB host 2 */
-static u64 usbh2_dmamask = ~(u32)0;
-
-static struct resource mxc_usbh2_resources[] = {
-	{
-		.start = MX31_OTG_BASE_ADDR + 0x400,
-		.end = MX31_OTG_BASE_ADDR + 0x5ff,
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = MXC_INT_USB2,
-		.end = MXC_INT_USB2,
+	[1] = {
+		.start = MXC_INT_CCM,
+		.end = MXC_INT_CCM,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_usbh2 = {
-	.name = "mxc-ehci",
-	.id = 2,
+static struct clk *ckih_clk;
+
+extern struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED];
+extern struct dptc_wp dptc_wp_allfreq_26ckih_TO_2_0[DPTC_WP_SUPPORTED];
+extern struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED];
+
+/* Platform Data for DPTC */
+static struct mxc_dptc_data dptc_data = {
+	.reg_id = "SW1A",
+	.clk_id = "cpu_clk",
+	.dptccr_reg_addr = (unsigned int)MXC_CCM_PMCR0,
+	.dcvr0_reg_addr = (int)MXC_CCM_DCVR0,
+	.gpc_cntr_reg_addr = (int)MXC_CCM_PMCR0,
+	.dptccr = 0xFFFFFFFF,
+	.dptc_wp_supported = DPTC_WP_SUPPORTED,
+	.dptc_wp_allfreq = dptc_wp_allfreq_26ckih,
+	.clk_max_val = 532000000,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_CCM_PMCR0_PTVAI_MASK,
+	.vai_offset = MXC_CCM_PMCR0_PTVAI_OFFSET,
+	.dptc_enable_bit = MXC_CCM_PMCR0_DPTEN,
+	.irq_mask = MXC_CCM_PMCR0_PTVAIM,
+	.dptc_nvcr_bit = 0x0,
+	.gpc_irq_bit = 0x00000000,
+	.init_config =
+		MXC_CCM_PMCR0_PTVIS | MXC_CCM_PMCR0_DRCE3 | MXC_CCM_PMCR0_DRCE1,
+	.enable_config =
+		MXC_CCM_PMCR0_DPTEN | MXC_CCM_PMCR0_DPVCR | MXC_CCM_PMCR0_DPVV,
+	.dcr_mask = MXC_CCM_PMCR0_DCR,
+};
+
+/* Device Definition for MXC DPTC */
+static struct platform_device mxc_dptc_device = {
+	.name = "mxc_dptc",
+	.id = 0,
 	.dev = {
-		.coherent_dma_mask = 0xffffffff,
-		.dma_mask = &usbh2_dmamask,
+		.platform_data = &dptc_data,
 	},
-	.resource = mxc_usbh2_resources,
-	.num_resources = ARRAY_SIZE(mxc_usbh2_resources),
+	.num_resources = ARRAY_SIZE(dptc_resources),
+	.resource = dptc_resources,
 };
 
+static inline void mxc_init_dptc(void)
+{
+	ckih_clk = clk_get(NULL, "ckih");
+	if (clk_get_rate(ckih_clk) == 27000000) {
+		if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+			dptc_data.dptc_wp_allfreq = NULL;
+		else
+			dptc_data.dptc_wp_allfreq =
+				dptc_wp_allfreq_27ckih_TO_2_0;
+	} else if (clk_get_rate(ckih_clk) == 26000000
+			&& mxc_cpu_is_rev(CHIP_REV_2_0) == 1)
+		dptc_data.dptc_wp_allfreq = dptc_wp_allfreq_26ckih_TO_2_0;
+
+	platform_device_register(&mxc_dptc_device);
+}
+
 /*
  * SPI master controller
  * 3 channels
  */
-static struct resource mxc_spi_0_resources[] = {
-	{
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/* Resource definition for the CSPI1 */
+static struct resource mxc_spi1_resources[] = {
+	[0] = {
 	       .start = CSPI1_BASE_ADDR,
 	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
 	       .flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 	       .start = MXC_INT_CSPI1,
 	       .end = MXC_INT_CSPI1,
 	       .flags = IORESOURCE_IRQ,
 	},
 };
 
-static struct resource mxc_spi_1_resources[] = {
-	{
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxc_spi1_data = {
+	.spi_version = 4,
+	.maxchipselect = 4,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxc_spi1_device = {
+	.name = "spi_imx",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_spi1_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi1_resources),
+	.resource = mxc_spi1_resources,
+};
+#endif /* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/* Resource definition for the CSPI2 */
+static struct resource mxc_spi2_resources[] = {
+	[0] = {
 		.start = CSPI2_BASE_ADDR,
 		.end = CSPI2_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 		.start = MXC_INT_CSPI2,
 		.end = MXC_INT_CSPI2,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-static struct resource mxc_spi_2_resources[] = {
-	{
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxc_spi2_data = {
+	.spi_version = 4,
+	.maxchipselect = 4,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxc_spi2_device = {
+	.name = "spi_imx",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_spi2_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi2_resources),
+	.resource = mxc_spi2_resources,
+};
+#endif /* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/* Resource definition for the CSPI3 */
+static struct resource mxc_spi3_resources[] = {
+	[0] = {
 		.start = CSPI3_BASE_ADDR,
 		.end = CSPI3_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
-	}, {
+	},
+	[1] = {
 		.start = MXC_INT_CSPI3,
 		.end = MXC_INT_CSPI3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_spi_device0 = {
-	.name = "spi_imx",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_spi_0_resources),
-	.resource = mxc_spi_0_resources,
-};
-
-struct platform_device mxc_spi_device1 = {
-	.name = "spi_imx",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(mxc_spi_1_resources),
-	.resource = mxc_spi_1_resources,
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxc_spi3_data = {
+	.spi_version = 4,
+	.maxchipselect = 4,
 };
 
-struct platform_device mxc_spi_device2 = {
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxc_spi3_device = {
 	.name = "spi_imx",
 	.id = 2,
-	.num_resources = ARRAY_SIZE(mxc_spi_2_resources),
-	.resource = mxc_spi_2_resources,
+	.dev = {
+		.platform_data = &mxc_spi3_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_spi3_resources),
+	.resource = mxc_spi3_resources,
 };
+#endif  /* CONFIG_SPI_MXC_SELECT3 */
+
+int __init mxc_init_spi(void)
+{
+	int ret = 0;
+
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	ret = platform_device_register(&mxc_spi1_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+#endif  /* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	ret = platform_device_register(&mxc_spi2_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+#endif  /* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	ret = platform_device_register(&mxc_spi3_device);
+	if (ret < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_3\n");
+#endif  /* CONFIG_SPI_MXC_SELECT3 */
+
+	return ret;
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
 
 #ifdef CONFIG_ARCH_MX35
 static struct resource mxc_fec_resources[] = {
@@ -537,86 +833,161 @@ struct platform_device mxc_fec_device = {
 };
 #endif
 
-static struct resource imx_ssi_resources0[] = {
-	{
-		.start	= SSI1_BASE_ADDR,
-		.end	= SSI1_BASE_ADDR + 0xfff,
+static struct mxc_audio_platform_data mxc_audio_data;
+#if defined(CONFIG_MXC_SSI) || defined(CONFIG_MXC_SSI_MODULE)
+/* Resource definition for the SSI */
+static struct resource mxcssi2_resources[] = {
+	[0] = {
+		.start	= SSI2_BASE_ADDR,
+		.end	= SSI2_BASE_ADDR + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= MX31_INT_SSI1,
-		.end	= MX31_INT_SSI1,
-		.flags	= IORESOURCE_IRQ,
-	},
+	      },
 };
 
-static struct resource imx_ssi_resources1[] = {
-	{
-		.start	= SSI2_BASE_ADDR,
-		.end	= SSI2_BASE_ADDR + 0xfff,
+static struct resource mxcssi1_resources[] = {
+	[0] = {
+		.start	= SSI1_BASE_ADDR,
+		.end	= SSI1_BASE_ADDR + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM
-	}, {
-		.start	= MX31_INT_SSI2,
-		.end	= MX31_INT_SSI2,
-		.flags	= IORESOURCE_IRQ,
-	},
+	      },
 };
 
-struct platform_device imx_ssi_device0 = {
-	.name = "imx-ssi",
+/*! Device Definition for MXC SSI */
+static struct platform_device mxc_ssi1_device = {
+	.name = "mxc-ssi",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(imx_ssi_resources0),
-	.resource = imx_ssi_resources0,
+	.dev = {
+		.platform_data = &mxc_audio_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcssi1_resources),
+	.resource = mxcssi1_resources,
 };
 
-struct platform_device imx_ssi_device1 = {
-	.name = "imx-ssi",
+struct platform_device mxc_ssi2_device = {
+	.name = "mxc-ssi",
 	.id = 1,
-	.num_resources = ARRAY_SIZE(imx_ssi_resources1),
-	.resource = imx_ssi_resources1,
+	.dev = {
+		.platform_data = &mxc_audio_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcssi2_resources),
+	.resource = mxcssi2_resources,
+};
+
+void __init mxc_init_ssi(void)
+{
+	platform_device_register(&mxc_ssi1_device);
+	platform_device_register(&mxc_ssi2_device);
+}
+#else
+static inline void mxc_init_ssi(void)
+{
+}
+#endif /*CONFIG_MXC_SSI*/
+
+/* platform device structure for adding SCC */
+#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
+static struct platform_device mxc_scc_device = {
+	.name = "mxc_scc",
+	.id = 0,
 };
 
-static struct resource imx_wdt_resources[] = {
+static void mxc_init_scc(void)
+{
+	platform_device_register(&mxc_scc_device);
+}
+#else
+static inline void mxc_init_scc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_MXC_PMIC) || defined(CONFIG_SND_MXC_PMIC_MODULE)
+static struct platform_device mxc_alsa_device = {
+	.name = "mxc_alsa",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_audio_data,
+	       },
+};
+
+void __init mxc_init_audio(void)
+{
+	struct clk *pll_clk;
+
+	pll_clk = clk_get(NULL, "usb_pll");
+	printk(KERN_INFO "audio pll clock:%lu\n", clk_get_rate(pll_clk));
+	mxc_audio_data.ssi_clk[0] = clk_get(NULL, "ssi1_clk");
+	printk(KERN_INFO "audio ssi 0 clock:%lu\n",
+		clk_get_rate(mxc_audio_data.ssi_clk[0]));
+	clk_set_parent(mxc_audio_data.ssi_clk[0], pll_clk);
+	clk_put(mxc_audio_data.ssi_clk[0]);
+	if (machine_is_mx31ads() || machine_is_mx31_3ds()) {
+		mxc_audio_data.ssi_num = 1;
+	} else {
+		mxc_audio_data.ssi_num = 2;
+		mxc_audio_data.ssi_clk[1] = clk_get(NULL, "ssi_clk.1");
+		printk(KERN_INFO "audio ssi 1 clock:%lu\n",
+			clk_get_rate(mxc_audio_data.ssi_clk[1]));
+		clk_set_parent(mxc_audio_data.ssi_clk[1], pll_clk);
+		clk_put(mxc_audio_data.ssi_clk[1]);
+
+		/* SPBA configuration for SSI2 - SDMA and MCU are set */
+		spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
+	}
+
+	clk_put(pll_clk);
+	mxc_audio_data.src_port = 0;
+	platform_device_register(&mxc_alsa_device);
+}
+#else
+static inline void mxc_init_audio(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource mxc_wdt_resources[] = {
 	{
+		.start = WDOG_BASE_ADDR,
+		.end = WDOG_BASE_ADDR + 0x30,
 		.flags = IORESOURCE_MEM,
 	},
 };
 
-struct platform_device imx_wdt_device0 = {
-	.name           = "imx-wdt",
+struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
 	.id             = 0,
-	.num_resources  = ARRAY_SIZE(imx_wdt_resources),
-	.resource       = imx_wdt_resources,
+	.num_resources  = ARRAY_SIZE(mxc_wdt_resources),
+	.resource       = mxc_wdt_resources,
 };
 
-static int __init mx3_devices_init(void)
+int __init mxc_init_wdt(void)
 {
-	if (cpu_is_mx31()) {
-		mxc_nand_resources[0].start = MX31_NFC_BASE_ADDR;
-		mxc_nand_resources[0].end = MX31_NFC_BASE_ADDR + 0xfff;
-		imx_wdt_resources[0].start = MX31_WDOG_BASE_ADDR;
-		imx_wdt_resources[0].end = MX31_WDOG_BASE_ADDR + 0x3fff;
-		mxc_register_device(&mxc_rnga_device, NULL);
-	}
-	if (cpu_is_mx35()) {
-		mxc_nand_resources[0].start = MX35_NFC_BASE_ADDR;
-		mxc_nand_resources[0].end = MX35_NFC_BASE_ADDR + 0x1fff;
-		otg_resources[0].start = MX35_OTG_BASE_ADDR;
-		otg_resources[0].end = MX35_OTG_BASE_ADDR + 0x1ff;
-		otg_resources[1].start = MXC_INT_USBOTG;
-		otg_resources[1].end = MXC_INT_USBOTG;
-		mxc_usbh1_resources[0].start = MX35_OTG_BASE_ADDR + 0x400;
-		mxc_usbh1_resources[0].end = MX35_OTG_BASE_ADDR + 0x5ff;
-		mxc_usbh1_resources[1].start = MXC_INT_USBHS;
-		mxc_usbh1_resources[1].end = MXC_INT_USBHS;
-		imx_ssi_resources0[1].start = MX35_INT_SSI1;
-		imx_ssi_resources0[1].end = MX35_INT_SSI1;
-		imx_ssi_resources1[1].start = MX35_INT_SSI2;
-		imx_ssi_resources1[1].end = MX35_INT_SSI2;
-		imx_wdt_resources[0].start = MX35_WDOG_BASE_ADDR;
-		imx_wdt_resources[0].end = MX35_WDOG_BASE_ADDR + 0x3fff;
-	}
+	return platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+int __init mx3_devices_init(void)
+{
+	mxc_init_wdt();
+	mxc_init_ipu();
+	mxc_init_spi();
+	mxc_init_i2c();
+	mxc_init_rtc();
+	mxc_init_scc();
+	mxc_init_ssi();
+	mxc_init_dma();
+	mxc_init_audio();
+	mxc_init_dptc();
+	mxc_init_rnga();
+	mxc_init_mmc();
+
+	/* SPBA configuration for SSI2 - SDMA and MCU are set */
+	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
 
 	return 0;
 }
-
-subsys_initcall(mx3_devices_init);
diff --git a/arch/arm/mach-mx3/dma.c b/arch/arm/mach-mx3/dma.c
new file mode 100644
index 0000000..49c332d
--- /dev/null
+++ b/arch/arm/mach-mx3/dma.c
@@ -0,0 +1,745 @@
+/*
+ *  Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+#include "serial.h"
+
+#define MXC_MMC_BUFFER_ACCESS     0x38
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_FIRI_TXFIFO           0x14
+#define MXC_SDHC_MMC_WML          16
+#define MXC_SDHC_SD_WML           64
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_FIRI_WML              16
+
+#ifdef CONFIG_SDMA_IRAM
+#define trans_type  int_2_per
+#else
+#define trans_type emi_2_per
+#endif
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR,
+			.peripheral_type = FIRI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_FIRI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR + MXC_FIRI_TXFIFO,
+			.peripheral_type = FIRI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_FIRI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fifo_memory_params = {
+	.chnl_params = {
+			.peripheral_type = FIFO_MEMORY,
+			.per_address = MXC_FIFO_MEM_DEST_FIXED,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			.event_id = 0,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIFO_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_FIR_RX, &mxc_sdma_fir_rx_params},
+	{MXC_DMA_FIR_TX, &mxc_sdma_fir_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_FIFO_MEMORY, &mxc_sdma_fifo_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif				/*CONFIG_SDMA_IRAM */
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
+
diff --git a/arch/arm/mach-mx3/dptc.c b/arch/arm/mach-mx3/dptc.c
new file mode 100644
index 0000000..e4fb0bb
--- /dev/null
+++ b/arch/arm/mach-mx3/dptc.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.c
+ *
+ * @brief DPTC table for the Freescale Semiconductor MXC DPTC module.
+ *
+ * @ingroup PM
+ */
+
+#include <mach/hardware.h>
+#include <mach/mxc_dptc.h>
+
+struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED] = {
+	/* 532MHz */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x95c00000, 0xffc00000, 0xe5800000, 1625},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1600},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1575},
+	{0xffc00000, 0x95e3e8e8, 0xffc00000, 0xe5f70da4, 1550},
+	{0xffc00000, 0x9623f8e8, 0xffc00000, 0xe6371da8, 1525},
+	/* wp5 */
+	{0xffc00000, 0x966408f0, 0xffc00000, 0xe6b73db0, 1500},
+	{0xffc00000, 0x96e428f4, 0xffc00000, 0xe7776dbc, 1475},
+	{0xffc00000, 0x976448fc, 0xffc00000, 0xe8379dc8, 1450},
+	{0xffc00000, 0x97e46904, 0xffc00000, 0xe977ddd8, 1425},
+	{0xffc00000, 0x98a48910, 0xffc00000, 0xeab81de8, 1400},
+	/* wp10 */
+	{0xffc00000, 0x9964b918, 0xffc00000, 0xebf86df8, 1375},
+	{0xffc00000, 0xffe4e924, 0xffc00000, 0xfff8ae08, 1350},
+	{0xffc00000, 0xffe5192c, 0xffc00000, 0xfff8fe1c, 1350},
+	{0xffc00000, 0xffe54938, 0xffc00000, 0xfff95e2c, 1350},
+	{0xffc00000, 0xffe57944, 0xffc00000, 0xfff9ae44, 1350},
+	/* wp15 */
+	{0xffc00000, 0xffe5b954, 0xffc00000, 0xfffa0e58, 1350},
+	{0xffc00000, 0xffe5e960, 0xffc00000, 0xfffa6e70, 1350},
+};
+
+struct dptc_wp dptc_wp_allfreq_26ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
+	/* Mx31 TO 2.0  Offset table */
+	/* 532MHz  */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x9E265978, 0xffc00000, 0xE4371D9C, 1625},
+	{0xffc00000, 0x9E665978, 0xffc00000, 0xE4772D9C, 1600},
+	{0xffc00000, 0x9EA65978, 0xffc00000, 0xE4772DA0, 1575},
+	{0xffc00000, 0x9EE66978, 0xffc00000, 0xE4B73DA0, 1550},
+	{0xffc00000, 0x9F26697C, 0xffc00000, 0xE4F73DA0, 1525},
+	/* wp5 */
+	{0xffc00000, 0x9F66797C, 0xffc00000, 0xE5774DA4, 1500},
+	{0xffc00000, 0x9FE6797C, 0xffc00000, 0xE5F75DA4, 1475},
+	{0xffc00000, 0xA026897C, 0xffc00000, 0xE6776DA4, 1450},
+	{0xffc00000, 0xA0A6897C, 0xffc00000, 0xE6F77DA8, 1425},
+	{0xffc00000, 0xA0E69980, 0xffc00000, 0xE7B78DAC, 1400},
+	/* wp10 */
+	{0xffc00000, 0xA1669980, 0xffc00000, 0xE8379DAC, 1375},
+	{0xffc00000, 0xA1A6A980, 0xffc00000, 0xE8F7ADB0, 1350},
+	{0xffc00000, 0xA226B984, 0xffc00000, 0xE9F7CDB0, 1325},
+	{0xffc00000, 0xA2A6C984, 0xffc00000, 0xEAB7DDB4, 1300},
+	{0xffc00000, 0xA326C988, 0xffc00000, 0xEBB7FDB8, 1275},
+	/* wp15 */
+	{0xffc00000, 0xA3A6D988, 0xffc00000, 0xECB80DBC, 1250},
+	{0xffc00000, 0xA426E988, 0xffc00000, 0xEDB82DC0, 1225},
+};
+
+struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
+	/* Mx31 TO 2.0  Offset table */
+	/* 532MHz  */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x9864E920, 0xffc00000, 0xDBB50D1C, 1625},
+	{0xffc00000, 0x98A4E920, 0xffc00000, 0xDBF51D1C, 1600},
+	{0xffc00000, 0x98E4E920, 0xffc00000, 0xDBF51D20, 1575},
+	{0xffc00000, 0x9924F920, 0xffc00000, 0xDC352D20, 1550},
+	{0xffc00000, 0x9924F924, 0xffc00000, 0xDC752D20, 1525},
+	/* wp5 */
+	{0xffc00000, 0x99650924, 0xffc00000, 0xDCF53D24, 1500},
+	{0xffc00000, 0x99E50924, 0xffc00000, 0xDD754D24, 1475},
+	{0xffc00000, 0x9A251924, 0xffc00000, 0xDDF55D24, 1450},
+	{0xffc00000, 0x9AA51924, 0xffc00000, 0xDE756D28, 1425},
+	{0xffc00000, 0x9AE52928, 0xffc00000, 0xDF357D2C, 1400},
+	/* wp10 */
+	{0xffc00000, 0x9B652928, 0xffc00000, 0xDFB58D2C, 1375},
+	{0xffc00000, 0x9BA53928, 0xffc00000, 0xE0759D30, 1350},
+	{0xffc00000, 0x9C254928, 0xffc00000, 0xE135BD30, 1325},
+	{0xffc00000, 0x9CA55928, 0xffc00000, 0xE1F5CD34, 1300},
+	{0xffc00000, 0x9D25592C, 0xffc00000, 0xE2F5ED38, 1275},
+	/* wp15 */
+	{0xffc00000, 0x9DA5692C, 0xffc00000, 0xE3F5FD38, 1250},
+	{0xffc00000, 0x9E25792C, 0xffc00000, 0xE4F61D3C, 1225},
+};
diff --git a/arch/arm/mach-mx3/dvfs_v2.c b/arch/arm/mach-mx3/dvfs_v2.c
new file mode 100644
index 0000000..36b5fe2
--- /dev/null
+++ b/arch/arm/mach-mx3/dvfs_v2.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_v2.c
+ *
+ * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and
+ * changes the CPU voltage according to translation table that is loaded into
+ * the driver.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/pmic_external.h>
+#include <mach/pmic_power.h>
+#include <mach/hardware.h>
+
+#include "crm_regs.h"
+#include "iomux.h"
+
+extern int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+			     iomux_pin_icfg_t in);
+
+static int dvfs_is_active;
+
+/* Used for tracking the number of interrupts */
+static u32 dvfs_nr_up[4];
+static u32 dvfs_nr_dn[4];
+
+/*
+ * Clock structures
+ */
+static struct clk *cpu_clk;
+static struct clk *ahb_clk;
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+/*
+ * Frequency increase threshold. Increase frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ */
+#define DVFS_UPTHR		(30 << MXC_CCM_LTR0_UPTHR_OFFSET)
+
+/*
+ * Frequency decrease threshold. Decrease frequency change request
+ * will be sent if DVFS counter value will be less than this value.
+ */
+#define DVFS_DNTHR		(18 << MXC_CCM_LTR0_DNTHR_OFFSET)
+
+/*
+ * With the ARM clocked at 532, this setting yields a DIV_3_CLK of 2.03 kHz.
+ */
+#define DVFS_DIV3CK		(3 << MXC_CCM_LTR0_DIV3CK_OFFSET)
+
+/*
+ * DNCNT defines the amount of times the down threshold should be exceeded
+ * before DVFS will trigger frequency decrease request.
+ */
+#define DVFS_DNCNT		(0x33 << MXC_CCM_LTR1_DNCNT_OFFSET)
+
+/*
+ * UPCNT defines the amount of times the up threshold should be exceeded
+ * before DVFS will trigger frequency increase request.
+ */
+#define DVFS_UPCNT		(0x33 << MXC_CCM_LTR1_UPCNT_OFFSET)
+
+/*
+ * Panic threshold. Panic frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ */
+#define DVFS_PNCTHR		(63 << MXC_CCM_LTR1_PNCTHR_OFFSET)
+
+/*
+ * Load tracking buffer source: 1 for ld_add; 0 for pre_ld_add
+ */
+#define DVFS_LTBRSR		(1 << MXC_CCM_LTR1_LTBRSR_OFFSET)
+
+/* EMAC defines how many samples are included in EMA calculation */
+#define DVFS_EMAC		(0x20 << MXC_CCM_LTR2_EMAC_OFFSET)
+
+const static u8 ltr_gp_weight[] = {
+	0,			/* 0 */
+	0,
+	0,
+	0,
+	0,
+	0,			/* 5 */
+	0,
+	0,
+	0,
+	0,
+	0,			/* 10 */
+	0,
+	7,
+	7,
+	7,
+	7,			/* 15 */
+};
+
+DEFINE_SPINLOCK(mxc_dvfs_lock);
+
+/*!
+ * This function sets the weight of general purpose signals
+ * @param   gp_id   number of general purpose bit
+ * @param   weight  the weight of the general purpose bit
+ */
+static void set_gp_weight(int gp_id, u8 weight)
+{
+	u32 reg;
+
+	if (gp_id < 9) {
+		reg = __raw_readl(MXC_CCM_LTR3);
+		reg = (reg & ~(MXC_CCM_LTR3_WSW_MASK(gp_id))) |
+		    (weight << MXC_CCM_LTR3_WSW_OFFSET(gp_id));
+		__raw_writel(reg, MXC_CCM_LTR3);
+	} else if (gp_id < 16) {
+		reg = __raw_readl(MXC_CCM_LTR2);
+		reg = (reg & ~(MXC_CCM_LTR2_WSW_MASK(gp_id))) |
+		    (weight << MXC_CCM_LTR2_WSW_OFFSET(gp_id));
+		__raw_writel(reg, MXC_CCM_LTR2);
+	}
+}
+
+static int start_dvfs(void)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (dvfs_is_active)
+		return 0;
+
+	spin_lock_irqsave(&mxc_dvfs_lock, flags);
+
+	reg = __raw_readl(MXC_CCM_PMCR0);
+
+	/* enable dvfs and interrupt */
+	reg = (reg & ~MXC_CCM_PMCR0_FSVAIM) | MXC_CCM_PMCR0_DVFEN;
+
+	__raw_writel(reg, MXC_CCM_PMCR0);
+
+	dvfs_is_active = 1;
+
+	spin_unlock_irqrestore(&mxc_dvfs_lock, flags);
+
+	pr_info("DVFS is started\n");
+
+	return 0;
+}
+
+#define MXC_CCM_LTR0_CONFIG_MASK	(MXC_CCM_LTR0_UPTHR_MASK | \
+					 MXC_CCM_LTR0_DNTHR_MASK | \
+					 MXC_CCM_LTR0_DIV3CK_MASK)
+#define MXC_CCM_LTR0_CONFIG_VAL		(DVFS_UPTHR | DVFS_DNTHR | DVFS_DIV3CK)
+
+#define MXC_CCM_LTR1_CONFIG_MASK	(MXC_CCM_LTR1_UPCNT_MASK | \
+					 MXC_CCM_LTR1_DNCNT_MASK | \
+					 MXC_CCM_LTR1_PNCTHR_MASK | \
+					 MXC_CCM_LTR1_LTBRSR_MASK)
+#define MXC_CCM_LTR1_CONFIG_VAL		(DVFS_UPCNT | DVFS_DNCNT | \
+					 DVFS_PNCTHR | DVFS_LTBRSR)
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_controller(void)
+{
+	u32 i, reg;
+
+	/* Configure 2 MC13783 DVFS pins */
+	mxc_request_iomux(MX31_PIN_DVFS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_DVFS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_NONE);
+
+	/* Configure MC13783 voltage ready input pin */
+	mxc_request_iomux(MX31_PIN_GPIO1_5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_FUNC);
+
+	/* setup LTR0 */
+	reg = __raw_readl(MXC_CCM_LTR0);
+	reg = (reg & ~(MXC_CCM_LTR0_CONFIG_MASK)) | MXC_CCM_LTR0_CONFIG_VAL;
+	__raw_writel(reg, MXC_CCM_LTR0);
+
+	/* set up LTR1 */
+	reg = __raw_readl(MXC_CCM_LTR1);
+	reg = (reg & ~(MXC_CCM_LTR1_CONFIG_MASK)) | MXC_CCM_LTR1_CONFIG_VAL;
+	__raw_writel(reg, MXC_CCM_LTR1);
+
+	/* setup LTR2 */
+	reg = __raw_readl(MXC_CCM_LTR2);
+	reg = (reg & ~(MXC_CCM_LTR2_EMAC_MASK)) | DVFS_EMAC;
+	__raw_writel(reg, MXC_CCM_LTR2);
+
+	/* Set general purpose weights to 0 */
+	for (i = 0; i < 16; i++)
+		set_gp_weight(i, ltr_gp_weight[i]);
+
+	/* ARM interrupt, mask load buf full interrupt */
+	reg = __raw_readl(MXC_CCM_PMCR0);
+	reg |= MXC_CCM_PMCR0_DVFIS | MXC_CCM_PMCR0_LBMI;
+	__raw_writel(reg, MXC_CCM_PMCR0);
+
+	/* configuring EMI Handshake and PLL relock disable */
+	reg = __raw_readl(MXC_CCM_PMCR1);
+	reg |= MXC_CCM_PMCR1_PLLRDIS;
+	reg |= MXC_CCM_PMCR1_EMIRQ_EN;
+	__raw_writel(reg, MXC_CCM_PMCR1);
+
+	return 0;
+}
+
+static irqreturn_t dvfs_irq(int irq, void *dev_id)
+{
+	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	u32 fsvai = (pmcr0 & MXC_CCM_PMCR0_FSVAI_MASK) >>
+	    MXC_CCM_PMCR0_FSVAI_OFFSET;
+	u32 dvsup = (pmcr0 & MXC_CCM_PMCR0_DVSUP_MASK) >>
+	    MXC_CCM_PMCR0_DVSUP_OFFSET;
+	u32 curr_ahb, curr_cpu, rate;
+
+	/* Should not be here if FSVAIM is set */
+	BUG_ON(pmcr0 & MXC_CCM_PMCR0_FSVAIM);
+
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		printk(KERN_WARNING "fsvai should not be 0\n");
+		return IRQ_HANDLED;
+	}
+
+	if (!(pmcr0 & MXC_CCM_PMCR0_UPDTEN)) {
+		/* Do nothing. DVFS didn't finish previous flow update */
+		return IRQ_HANDLED;
+	}
+
+	if (((dvsup == DVSUP_LOW) && (fsvai == FSVAI_FREQ_DECREASE)) ||
+	    ((dvsup == DVSUP_TURBO) && ((fsvai == FSVAI_FREQ_INCREASE) ||
+					(fsvai == FSVAI_FREQ_EMERG)))) {
+		/* Interrupt should be disabled in these cases according to
+		 * the spec since DVFS is already at lowest (highest) state */
+		printk(KERN_WARNING "Something is wrong?\n");
+		return IRQ_HANDLED;
+	}
+
+	curr_ahb = clk_get_rate(ahb_clk);
+	if (fsvai == FSVAI_FREQ_DECREASE) {
+		curr_cpu = clk_get_rate(cpu_clk);
+		rate = ((curr_cpu / curr_ahb) - 1) * curr_ahb;
+		if ((cpu_is_mx31_rev(CHIP_REV_2_0) < 0) &&
+		    ((curr_cpu / curr_ahb) == 4)) {
+			rate = ((curr_cpu / curr_ahb) - 2) * curr_ahb;
+		}
+		dvfs_nr_dn[dvsup]++;
+	} else {
+		rate = 4 * curr_ahb;
+		dvfs_nr_up[dvsup]++;
+	}
+
+	clk_set_rate(cpu_clk, rate);
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function disables the DVFS module.
+ */
+static void stop_dvfs(void)
+{
+	u32 pmcr0, dvsup;
+	unsigned long flags;
+	u32 curr_ahb = clk_get_rate(ahb_clk);
+
+	if (dvfs_is_active) {
+		spin_lock_irqsave(&mxc_dvfs_lock, flags);
+
+		pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+		dvsup = (pmcr0 & MXC_CCM_PMCR0_DVSUP_MASK) >>
+		    MXC_CCM_PMCR0_DVSUP_OFFSET;
+		if (dvsup != DVSUP_TURBO) {
+			/* Use sw delay to insure volt/freq change */
+			clk_set_rate(cpu_clk, (4 * curr_ahb));
+			udelay(200);
+		}
+
+		pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+		/* disable dvfs and its interrupt */
+		pmcr0 = (pmcr0 & ~MXC_CCM_PMCR0_DVFEN) | MXC_CCM_PMCR0_FSVAIM;
+		__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+		dvfs_is_active = 0;
+
+		spin_unlock_irqrestore(&mxc_dvfs_lock, flags);
+	}
+
+	pr_info("DVFS is stopped\n");
+}
+
+void pmic_voltage_init(void)
+{
+	t_regulator_voltage volt;
+
+	/* Enable 4 mc13783 output voltages */
+	pmic_write_reg(REG_ARBITRATION_SWITCHERS, (1 << 5), (1 << 5));
+
+	/* Set mc13783 DVS speed 25mV each 4us */
+	pmic_write_reg(REG_SWITCHERS_4, (0 << 6), (3 << 6));
+
+	if (cpu_is_mx31())
+		volt.sw1a = SW1A_1_625V;
+	else
+		volt.sw1a = SW1A_1_425V;
+
+	pmic_power_regulator_set_voltage(SW_SW1A, volt);
+
+	volt.sw1a = SW1A_1_25V;
+	pmic_power_switcher_set_dvs(SW_SW1A, volt);
+
+	volt.sw1b = SW1A_1_25V;
+	pmic_power_switcher_set_dvs(SW_SW1B, volt);
+
+	volt.sw1b = SW1A_1_25V;
+	pmic_power_switcher_set_stby(SW_SW1B, volt);
+}
+
+static ssize_t dvfs_enable_store(struct sys_device *dev,
+				 struct sysdev_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		if (start_dvfs() != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL)
+		stop_dvfs();
+
+	return size;
+}
+
+static ssize_t dvfs_status_show(struct sys_device *dev,
+				struct sysdev_attribute *attr, char *buf)
+{
+	int size = 0;
+
+	if (dvfs_is_active)
+		size = sprintf(buf, "DVFS is enabled\n");
+	else
+		size = sprintf(buf, "DVFS is disabled\n");
+	size +=
+	    sprintf((buf + size), "UP:\t%d\t%d\t%d\t%d\n", dvfs_nr_up[0],
+		    dvfs_nr_up[1], dvfs_nr_up[2], dvfs_nr_up[3]);
+	size +=
+	    sprintf((buf + size), "DOWN:\t%d\t%d\t%d\t%d\n\n", dvfs_nr_dn[0],
+		    dvfs_nr_dn[1], dvfs_nr_dn[2], dvfs_nr_dn[3]);
+
+	return size;
+}
+
+static ssize_t dvfs_status_store(struct sys_device *dev,
+				 struct sysdev_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "reset") != NULL) {
+		int i;
+		for (i = 0; i < 4; i++) {
+			dvfs_nr_up[i] = 0;
+			dvfs_nr_dn[i] = 0;
+		}
+	}
+
+	return size;
+}
+
+static ssize_t dvfs_debug_show(struct sys_device *dev,
+				struct sysdev_attribute *attr, char *buf)
+{
+	int size = 0;
+	u32 curr_ahb, curr_cpu;
+
+	curr_ahb = clk_get_rate(ahb_clk);
+	curr_cpu = clk_get_rate(cpu_clk);
+
+	pr_debug("ahb %d, cpu %d\n", curr_ahb, curr_cpu);
+
+	return size;
+}
+
+static ssize_t dvfs_debug_store(struct sys_device *dev,
+				struct sysdev_attribute *attr,
+				const char *buf, size_t size)
+{
+	u32 curr_ahb, curr_cpu, rate = 0;
+
+	curr_ahb = clk_get_rate(ahb_clk);
+	curr_cpu = clk_get_rate(cpu_clk);
+
+	if (strstr(buf, "inc") != NULL) {
+		rate = 4 * curr_ahb;
+		pr_debug("inc to %d\n", rate);
+	}
+
+	if (strstr(buf, "dec") != NULL) {
+		rate = ((curr_cpu / curr_ahb) - 1) * curr_ahb;
+		if ((cpu_is_mx31_rev(CHIP_REV_2_0) < 0) &&
+		    ((curr_cpu / curr_ahb) == 4))
+			rate = ((curr_cpu / curr_ahb) - 2) * curr_ahb;
+
+		pr_debug("dec to %d\n", rate);
+	}
+
+	clk_set_rate(cpu_clk, rate);
+
+	return size;
+}
+
+static SYSDEV_ATTR(enable, 0200, NULL, dvfs_enable_store);
+static SYSDEV_ATTR(status, 0644, dvfs_status_show, dvfs_status_store);
+static SYSDEV_ATTR(debug, 0644, dvfs_debug_show, dvfs_debug_store);
+
+static struct sysdev_class dvfs_sysclass = {
+	.name = "dvfs",
+};
+
+static struct sys_device dvfs_device = {
+	.id = 0,
+	.cls = &dvfs_sysclass,
+};
+
+static int dvfs_sysdev_ctrl_init(void)
+{
+	int err;
+
+	err = sysdev_class_register(&dvfs_sysclass);
+	if (!err)
+		err = sysdev_register(&dvfs_device);
+	if (!err) {
+		err = sysdev_create_file(&dvfs_device, &attr_enable);
+		err = sysdev_create_file(&dvfs_device, &attr_status);
+		err = sysdev_create_file(&dvfs_device, &attr_debug);
+	}
+
+	return err;
+}
+
+static void dvfs_sysdev_ctrl_exit(void)
+{
+	sysdev_remove_file(&dvfs_device, &attr_enable);
+	sysdev_remove_file(&dvfs_device, &attr_status);
+	sysdev_unregister(&dvfs_device);
+	sysdev_class_unregister(&dvfs_sysclass);
+}
+
+static int __init dvfs_init(void)
+{
+	int err = 0;
+	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	pmic_voltage_init();
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	err = init_dvfs_controller();
+	if (err) {
+		printk(KERN_ERR "DVFS: Unable to initialize DVFS");
+		return err;
+	}
+
+	/* request the DVFS interrupt */
+	err = request_irq(MXC_INT_CCM_DVFS, dvfs_irq,
+				IRQF_DISABLED, "dvfs", NULL);
+	if (err)
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt");
+
+	err = dvfs_sysdev_ctrl_init();
+	if (err) {
+		free_irq(MXC_INT_CCM_DVFS, NULL);
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for dvfs");
+		return err;
+	}
+
+	return err;
+}
+
+static void __exit dvfs_cleanup(void)
+{
+	stop_dvfs();
+
+	/* release the DVFS interrupt */
+	free_irq(MXC_INT_CCM_DVFS, NULL);
+
+	dvfs_sysdev_ctrl_exit();
+
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+}
+
+module_init(dvfs_init);
+module_exit(dvfs_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx3/iomux-imx31.c b/arch/arm/mach-mx3/iomux-imx31.c
index a1d7fa5..02b676d 100644
--- a/arch/arm/mach-mx3/iomux-imx31.c
+++ b/arch/arm/mach-mx3/iomux-imx31.c
@@ -24,7 +24,14 @@
 #include <linux/kernel.h>
 #include <mach/hardware.h>
 #include <mach/gpio.h>
-#include <mach/iomux-mx3.h>
+#include "iomux.h"
+
+#define MUX_CTL_FIELDS          4
+
+#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & ((1 << (MUX_F - MUX_I)) - 1))
+#define PIN_TO_IOMUX_FIELD(pin) ((pin >> MUX_F) & ((1 << (PAD_I - MUX_F)) - 1))
+
+#define MUX_CTL_BIT_LEN         8
 
 /*
  * IOMUX register (base) addresses
@@ -34,13 +41,129 @@
 #define IOMUXINT_OBS2	(IOMUX_BASE + 0x004)
 #define IOMUXGPR	(IOMUX_BASE + 0x008)
 #define IOMUXSW_MUX_CTL	(IOMUX_BASE + 0x00C)
+/*!< last MUX control register */
+#define IOMUXSW_MUX_END (IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x150)
 #define IOMUXSW_PAD_CTL	(IOMUX_BASE + 0x154)
+#define GET_FIELD_MASK(len, fld)    (((1 << len) - 1) << (len * fld))
+
+/*!
+* Maximum number of MUX pins
+* Number of pins = (highest iomux reg - lowest iomux reg + 1) * (4 pins/reg)
+*/
+#define MUX_PIN_NUM_MAX \
+	(((u32 *)IOMUXSW_MUX_END - (u32 *)IOMUXSW_MUX_CTL + 1) * MUX_CTL_FIELDS)
 
 static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
 
 #define IOMUX_REG_MASK (IOMUX_PADNUM_MASK & ~0x3)
 
 unsigned long mxc_pin_alloc_map[NB_PORTS * 32 / BITS_PER_LONG];
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return 0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in)
+{
+	void __iomem *reg;
+	u32 l, ret = 0;
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u32 mux_mask = GET_FIELD_MASK(MUX_CTL_BIT_LEN, mux_field);
+	u8 *rp;
+
+	BUG_ON((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+	       (mux_field >= MUX_CTL_FIELDS));
+
+	reg = IOMUXSW_MUX_CTL + (mux_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~mux_mask)) |
+	    (((out << 4) | in) << (mux_field * MUX_CTL_BIT_LEN));
+	__raw_writel(l, reg);
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+	if (out & *rp && *rp != ((out << 4) | in)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		if (pin != MX31_PIN_CTS1 &&
+		    pin != MX31_PIN_RTS1 &&
+		    pin != MX31_PIN_DCD_DCE1 &&
+		    pin != MX31_PIN_DSR_DTE1 &&
+		    pin != MX31_PIN_DTR_DTE1 &&
+		    pin != MX31_PIN_RI_DCE1 &&
+		    pin != MX31_PIN_DSR_DCE1 &&
+		    pin != MX31_PIN_DTR_DCE1 &&
+		    pin != MX31_PIN_RXD1 && pin != MX31_PIN_TXD1) {
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+			       " config changed, index=%d field=%d, "
+			       " prev=0x%x new=0x%x\n", mux_index, mux_field,
+			       *rp, (out << 4) | in);
+		}
+		ret = -EINVAL;
+	}
+	*rp = (out << 4) | in;
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(iomux_config_mux);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in)
+{
+	int ret = iomux_config_mux(pin, out, in);
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO)
+		ret |= gpio_request(IOMUX_TO_GPIO(pin), NULL);
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in)
+{
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u8 *rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+
+	BUG_ON((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+	       (mux_field >= MUX_CTL_FIELDS));
+
+	*rp = 0;
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO)
+		gpio_free(IOMUX_TO_GPIO(pin));
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
 /*
  * set the mode for a IOMUX pin.
  */
diff --git a/arch/arm/mach-mx3/iomux.h b/arch/arm/mach-mx3/iomux.h
new file mode 100644
index 0000000..4c78829
--- /dev/null
+++ b/arch/arm/mach-mx3/iomux.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_IOMUX_H__
+#define __MACH_MX31_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+#include "mx31_pins.h"
+
+typedef unsigned int iomux_pin_name_t;
+/*!
+ * @file mach-mx3/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX31
+ */
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_output_config {
+	OUTPUTCONFIG_GPIO = 0,	/*!< used as GPIO */
+	OUTPUTCONFIG_FUNC,	/*!< used as function */
+	OUTPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
+	OUTPUTCONFIG_ALT2,	/*!< used as alternate function 2 */
+	OUTPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
+	OUTPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
+	OUTPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
+	OUTPUTCONFIG_ALT6	/*!< used as alternate function 6 */
+} iomux_pin_ocfg_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUTCONFIG_NONE = 0,	/*!< not configured for input */
+	INPUTCONFIG_GPIO = 1 << 0,	/*!< used as GPIO */
+	INPUTCONFIG_FUNC = 1 << 1,	/*!< used as function */
+	INPUTCONFIG_ALT1 = 1 << 2,	/*!< used as alternate function 1 */
+	INPUTCONFIG_ALT2 = 1 << 3	/*!< used as alternate function 2 */
+} iomux_pin_icfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_NOLOOPBACK = 0x0 << 9,
+	PAD_CTL_LOOPBACK = 0x1 << 9,
+	PAD_CTL_PKE_NONE = 0x0 << 8,
+	PAD_CTL_PKE_ENABLE = 0x1 << 8,
+	PAD_CTL_PUE_KEEPER = 0x0 << 7,
+	PAD_CTL_PUE_PUD = 0x1 << 7,
+	PAD_CTL_100K_PD = 0x0 << 5,
+	PAD_CTL_100K_PU = 0x1 << 5,
+	PAD_CTL_47K_PU = 0x2 << 5,
+	PAD_CTL_22K_PU = 0x3 << 5,
+	PAD_CTL_HYS_CMOS = 0x0 << 4,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_PGP_FIRI = 0x1 << 0,
+	MUX_DDR_MODE = 0x1 << 1,
+	MUX_PGP_CSPI_BB = 0x1 << 2,
+	MUX_PGP_ATA_1 = 0x1 << 3,
+	MUX_PGP_ATA_2 = 0x1 << 4,
+	MUX_PGP_ATA_3 = 0x1 << 5,
+	MUX_PGP_ATA_4 = 0x1 << 6,
+	MUX_PGP_ATA_5 = 0x1 << 7,
+	MUX_PGP_ATA_6 = 0x1 << 8,
+	MUX_PGP_ATA_7 = 0x1 << 9,
+	MUX_PGP_ATA_8 = 0x1 << 10,
+	MUX_PGP_UH2 = 0x1 << 11,
+	MUX_SDCTL_CSD0_SEL = 0x1 << 12,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 13,
+	MUX_CSPI1_UART3 = 0x1 << 14,
+	MUX_EXTDMAREQ2_MBX_SEL = 0x1 << 15,
+	MUX_TAMPER_DETECT_EN = 0x1 << 16,
+	MUX_PGP_USB_4WIRE = 0x1 << 17,
+	MUX_PGB_USB_COMMON = 0x1 << 18,
+	MUX_SDHC_MEMSTICK1 = 0x1 << 19,
+	MUX_SDHC_MEMSTICK2 = 0x1 << 20,
+	MUX_PGP_SPLL_BYP = 0x1 << 21,
+	MUX_PGP_UPLL_BYP = 0x1 << 22,
+	MUX_PGP_MSHC1_CLK_SEL = 0x1 << 23,
+	MUX_PGP_MSHC2_CLK_SEL = 0x1 << 24,
+	MUX_CSPI3_UART5_SEL = 0x1 << 25,
+	MUX_PGP_ATA_9 = 0x1 << 26,
+	MUX_PGP_USB_SUSPEND = 0x1 << 27,
+	MUX_PGP_USB_OTG_LOOPBACK = 0x1 << 28,
+	MUX_PGP_USB_HS1_LOOPBACK = 0x1 << 29,
+	MUX_PGP_USB_HS2_LOOPBACK = 0x1 << 30,
+	MUX_CLKO_DDR_MODE = 0x1 << 31,
+} iomux_gp_func_t;
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ *
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ * @return 0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pins
+ * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(enum iomux_pins pin, u32 config);
+
+void mxc_iomux_release_multiple_pins(unsigned int *pin_list, int count);
+
+#define PIN_MAX 327
+#define NB_PORTS 12 /* NB_PINS/32, we chose 32 pins per "PORT" */
+#define IOMUX_PADNUM_MASK       0x1ff
+#define IOMUX_MODE_SHIFT        17
+#define IOMUX_MODE_MASK (0xff << IOMUX_MODE_SHIFT)
+
+
+#endif
diff --git a/arch/arm/mach-mx3/mx31_pins.h b/arch/arm/mach-mx3/mx31_pins.h
new file mode 100644
index 0000000..aad34d4
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31_pins.h
@@ -0,0 +1,429 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX31_PINS_H__
+#define __ASM_ARCH_MXC_MX31_PINS_H__
+
+/*!
+ * @file arch-mxc/mx31_pins.h
+ *
+ * @brief MX31 I/O Pin List
+ *
+ * @ingroup GPIO_MX31
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20  | 19 - 18 | 17 - 10| 9 - 8 | 7 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   |     RSVD    |  PAD_F  |  PAD_I | MUX_F | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base + 0xC) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Bit 8 to 9 is MUX_F which
+ * contains the offset value defined WITHIN the same register (each IOMUX
+ * control register contains four 8-bit fields for four different pins). The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX31_PIN_A0 is defined in the enumeration:
+ *    ( 73 << MUX_I) | (0 << MUX_F)|( 98 << PAD_I) | (0 << PAD_F)
+ * It means the mux control register is at register offset 73. So the absolute
+ * address is: 0xC+73*4=0x130   0 << MUX_F means the control bits are at the
+ * least significant bits within the register. The pad control register offset
+ * is: 0x154+98*4=0x2DC and also occupy the least significant bits within the
+ * register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register index (0-based)
+ */
+#define MUX_I		0
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within IOMUX control register for control bits
+ * (legal values are 0, 1, 2, 3)
+ */
+#define MUX_F		8
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register index (0-based)
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within PAD control register for control bits
+ * (legal values are 0, 1, 2)
+ */
+#define PAD_F		18
+
+#define _MXC_BUILD_PIN(gp, gi, mi, mf, pi, pf) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | ((mi) << MUX_I) | \
+	((mf) << MUX_F) | ((pi) << PAD_I) | ((pf) << PAD_F))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, mf, pi, pf) \
+		_MXC_BUILD_PIN(gp, gi, mi, mf, pi, pf)
+#define _MXC_BUILD_NON_GPIO_PIN(mi, mf, pi, pf) \
+		_MXC_BUILD_PIN(7, 0, mi, mf, pi, pf)
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX31 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins {
+	MX31_PIN_CSPI3_MISO = _MXC_BUILD_NON_GPIO_PIN(0, 3, 1, 2),
+	MX31_PIN_CSPI3_SCLK = _MXC_BUILD_NON_GPIO_PIN(0, 2, 1, 1),
+	MX31_PIN_CSPI3_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(0, 1, 1, 0),
+	MX31_PIN_TTM_PAD = _MXC_BUILD_NON_GPIO_PIN(0, 0, 0, 2),
+	MX31_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(2, 31, 1, 3, 3, 0),
+	MX31_PIN_CE_CONTROL = _MXC_BUILD_NON_GPIO_PIN(1, 2, 2, 2),
+	MX31_PIN_CLKSS = _MXC_BUILD_NON_GPIO_PIN(1, 1, 2, 1),
+	MX31_PIN_CSPI3_MOSI = _MXC_BUILD_NON_GPIO_PIN(1, 0, 2, 0),
+	MX31_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(2, 27, 2, 3, 4, 1),
+	MX31_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(2, 28, 2, 2, 4, 0),
+	MX31_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(2, 29, 2, 1, 3, 2),
+	MX31_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(2, 30, 2, 0, 3, 1),
+	MX31_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 29, 3, 3, 5, 2),
+	MX31_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 30, 3, 2, 5, 1),
+	MX31_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 31, 3, 1, 5, 0),
+	MX31_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0, 4, 2),
+	MX31_PIN_D3_SPL = _MXC_BUILD_NON_GPIO_PIN(4, 3, 7, 0),
+	MX31_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 26, 4, 2, 6, 2),
+	MX31_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 27, 4, 1, 6, 1),
+	MX31_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 28, 4, 0, 6, 0),
+	MX31_PIN_VSYNC3 = _MXC_BUILD_NON_GPIO_PIN(5, 3, 8, 1),
+	MX31_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(5, 2, 8, 0),
+	MX31_PIN_D3_REV = _MXC_BUILD_NON_GPIO_PIN(5, 1, 7, 2),
+	MX31_PIN_D3_CLS = _MXC_BUILD_NON_GPIO_PIN(5, 0, 7, 1),
+	MX31_PIN_SER_RS = _MXC_BUILD_GPIO_PIN(2, 25, 6, 3, 9, 2),
+	MX31_PIN_PAR_RS = _MXC_BUILD_NON_GPIO_PIN(6, 2, 9, 1),
+	MX31_PIN_WRITE = _MXC_BUILD_NON_GPIO_PIN(6, 1, 9, 0),
+	MX31_PIN_READ = _MXC_BUILD_NON_GPIO_PIN(6, 0, 8, 2),
+	MX31_PIN_SD_D_IO = _MXC_BUILD_GPIO_PIN(2, 21, 7, 3, 11, 0),
+	MX31_PIN_SD_D_CLK = _MXC_BUILD_GPIO_PIN(2, 22, 7, 2, 10, 2),
+	MX31_PIN_LCS0 = _MXC_BUILD_GPIO_PIN(2, 23, 7, 1, 10, 1),
+	MX31_PIN_LCS1 = _MXC_BUILD_GPIO_PIN(2, 24, 7, 0, 10, 0),
+	MX31_PIN_HSYNC = _MXC_BUILD_NON_GPIO_PIN(8, 3, 12, 1),
+	MX31_PIN_FPSHIFT = _MXC_BUILD_NON_GPIO_PIN(8, 2, 12, 0),
+	MX31_PIN_DRDY0 = _MXC_BUILD_NON_GPIO_PIN(8, 1, 11, 2),
+	MX31_PIN_SD_D_I = _MXC_BUILD_GPIO_PIN(2, 20, 8, 0, 11, 1),
+	MX31_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(9, 3, 13, 2),
+	MX31_PIN_LD16 = _MXC_BUILD_NON_GPIO_PIN(9, 2, 13, 1),
+	MX31_PIN_LD17 = _MXC_BUILD_NON_GPIO_PIN(9, 1, 13, 0),
+	MX31_PIN_VSYNC0 = _MXC_BUILD_NON_GPIO_PIN(9, 0, 12, 2),
+	MX31_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(10, 3, 15, 0),
+	MX31_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(10, 2, 14, 2),
+	MX31_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(10, 1, 14, 1),
+	MX31_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(10, 0, 14, 0),
+	MX31_PIN_LD7 = _MXC_BUILD_NON_GPIO_PIN(11, 3, 16, 1),
+	MX31_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(11, 2, 16, 0),
+	MX31_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(11, 1, 15, 2),
+	MX31_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(11, 0, 15, 1),
+	MX31_PIN_LD3 = _MXC_BUILD_NON_GPIO_PIN(12, 3, 17, 2),
+	MX31_PIN_LD4 = _MXC_BUILD_NON_GPIO_PIN(12, 2, 17, 1),
+	MX31_PIN_LD5 = _MXC_BUILD_NON_GPIO_PIN(12, 1, 17, 0),
+	MX31_PIN_LD6 = _MXC_BUILD_NON_GPIO_PIN(12, 0, 16, 2),
+	MX31_PIN_USBH2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(13, 3, 19, 0),
+	MX31_PIN_LD0 = _MXC_BUILD_NON_GPIO_PIN(13, 2, 18, 2),
+	MX31_PIN_LD1 = _MXC_BUILD_NON_GPIO_PIN(13, 1, 18, 1),
+	MX31_PIN_LD2 = _MXC_BUILD_NON_GPIO_PIN(13, 0, 18, 0),
+	MX31_PIN_USBH2_DIR = _MXC_BUILD_NON_GPIO_PIN(14, 3, 20, 1),
+	MX31_PIN_USBH2_STP = _MXC_BUILD_NON_GPIO_PIN(14, 2, 20, 0),
+	MX31_PIN_USBH2_NXT = _MXC_BUILD_NON_GPIO_PIN(14, 1, 19, 2),
+	MX31_PIN_USBH2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(14, 0, 19, 1),
+	MX31_PIN_USBOTG_DATA5 = _MXC_BUILD_NON_GPIO_PIN(15, 3, 21, 2),
+	MX31_PIN_USBOTG_DATA6 = _MXC_BUILD_NON_GPIO_PIN(15, 2, 21, 1),
+	MX31_PIN_USBOTG_DATA7 = _MXC_BUILD_NON_GPIO_PIN(15, 1, 21, 0),
+	MX31_PIN_USBH2_CLK = _MXC_BUILD_NON_GPIO_PIN(15, 0, 20, 2),
+	MX31_PIN_USBOTG_DATA1 = _MXC_BUILD_NON_GPIO_PIN(16, 3, 23, 0),
+	MX31_PIN_USBOTG_DATA2 = _MXC_BUILD_NON_GPIO_PIN(16, 2, 22, 2),
+	MX31_PIN_USBOTG_DATA3 = _MXC_BUILD_NON_GPIO_PIN(16, 1, 22, 1),
+	MX31_PIN_USBOTG_DATA4 = _MXC_BUILD_NON_GPIO_PIN(16, 0, 22, 0),
+	MX31_PIN_USBOTG_DIR = _MXC_BUILD_NON_GPIO_PIN(17, 3, 24, 1),
+	MX31_PIN_USBOTG_STP = _MXC_BUILD_NON_GPIO_PIN(17, 2, 24, 0),
+	MX31_PIN_USBOTG_NXT = _MXC_BUILD_NON_GPIO_PIN(17, 1, 23, 2),
+	MX31_PIN_USBOTG_DATA0 = _MXC_BUILD_NON_GPIO_PIN(17, 0, 23, 1),
+	MX31_PIN_USB_PWR = _MXC_BUILD_GPIO_PIN(0, 29, 18, 3, 25, 2),
+	MX31_PIN_USB_OC = _MXC_BUILD_GPIO_PIN(0, 30, 18, 2, 25, 1),
+	MX31_PIN_USB_BYP = _MXC_BUILD_GPIO_PIN(0, 31, 18, 1, 25, 0),
+	MX31_PIN_USBOTG_CLK = _MXC_BUILD_NON_GPIO_PIN(18, 0, 24, 2),
+	MX31_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(19, 3, 27, 0),
+	MX31_PIN_TRSTB = _MXC_BUILD_NON_GPIO_PIN(19, 2, 26, 2),
+	MX31_PIN_DE_B = _MXC_BUILD_NON_GPIO_PIN(19, 1, 26, 1),
+	MX31_PIN_SJC_MOD = _MXC_BUILD_NON_GPIO_PIN(19, 0, 26, 0),
+	MX31_PIN_RTCK = _MXC_BUILD_NON_GPIO_PIN(20, 3, 28, 1),
+	MX31_PIN_TCK = _MXC_BUILD_NON_GPIO_PIN(20, 2, 28, 0),
+	MX31_PIN_TMS = _MXC_BUILD_NON_GPIO_PIN(20, 1, 27, 2),
+	MX31_PIN_TDI = _MXC_BUILD_NON_GPIO_PIN(20, 0, 27, 1),
+	MX31_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN(1, 22, 21, 3, 29, 2),
+	MX31_PIN_KEY_COL5 = _MXC_BUILD_GPIO_PIN(1, 23, 21, 2, 29, 1),
+	MX31_PIN_KEY_COL6 = _MXC_BUILD_GPIO_PIN(1, 24, 21, 1, 29, 0),
+	MX31_PIN_KEY_COL7 = _MXC_BUILD_GPIO_PIN(1, 25, 21, 0, 28, 2),
+	MX31_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(22, 3, 31, 0),
+	MX31_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(22, 2, 30, 2),
+	MX31_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(22, 1, 30, 1),
+	MX31_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(22, 0, 30, 0),
+	MX31_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN(1, 18, 23, 3, 32, 1),
+	MX31_PIN_KEY_ROW5 = _MXC_BUILD_GPIO_PIN(1, 19, 23, 2, 32, 0),
+	MX31_PIN_KEY_ROW6 = _MXC_BUILD_GPIO_PIN(1, 20, 23, 1, 31, 2),
+	MX31_PIN_KEY_ROW7 = _MXC_BUILD_GPIO_PIN(1, 21, 23, 0, 31, 1),
+	MX31_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(24, 3, 33, 2),
+	MX31_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(24, 2, 33, 1),
+	MX31_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(24, 1, 33, 0),
+	MX31_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(24, 0, 32, 2),
+	MX31_PIN_TXD2 = _MXC_BUILD_GPIO_PIN(0, 28, 25, 3, 35, 0),
+	MX31_PIN_RTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 2, 34, 2),
+	MX31_PIN_CTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 1, 34, 1),
+	MX31_PIN_BATT_LINE = _MXC_BUILD_GPIO_PIN(1, 17, 25, 0, 34, 0),
+	MX31_PIN_RI_DTE1 = _MXC_BUILD_GPIO_PIN(1, 14, 26, 3, 36, 1),
+	MX31_PIN_DCD_DTE1 = _MXC_BUILD_GPIO_PIN(1, 15, 26, 2, 36, 0),
+	MX31_PIN_DTR_DCE2 = _MXC_BUILD_GPIO_PIN(1, 16, 26, 1, 35, 2),
+	MX31_PIN_RXD2 = _MXC_BUILD_GPIO_PIN(0, 27, 26, 0, 35, 1),
+	MX31_PIN_RI_DCE1 = _MXC_BUILD_GPIO_PIN(1, 10, 27, 3, 37, 2),
+	MX31_PIN_DCD_DCE1 = _MXC_BUILD_GPIO_PIN(1, 11, 27, 2, 37, 1),
+	MX31_PIN_DTR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 12, 27, 1, 37, 0),
+	MX31_PIN_DSR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 13, 27, 0, 36, 2),
+	MX31_PIN_RTS1 = _MXC_BUILD_GPIO_PIN(1, 6, 28, 3, 39, 0),
+	MX31_PIN_CTS1 = _MXC_BUILD_GPIO_PIN(1, 7, 28, 2, 38, 2),
+	MX31_PIN_DTR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 8, 28, 1, 38, 1),
+	MX31_PIN_DSR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 9, 28, 0, 38, 0),
+	MX31_PIN_CSPI2_SCLK = _MXC_BUILD_NON_GPIO_PIN(29, 3, 40, 1),
+	MX31_PIN_CSPI2_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(29, 2, 40, 0),
+	MX31_PIN_RXD1 = _MXC_BUILD_GPIO_PIN(1, 4, 29, 1, 39, 2),
+	MX31_PIN_TXD1 = _MXC_BUILD_GPIO_PIN(1, 5, 29, 0, 39, 1),
+	MX31_PIN_CSPI2_MISO = _MXC_BUILD_NON_GPIO_PIN(30, 3, 41, 2),
+	MX31_PIN_CSPI2_SS0 = _MXC_BUILD_NON_GPIO_PIN(30, 2, 41, 1),
+	MX31_PIN_CSPI2_SS1 = _MXC_BUILD_NON_GPIO_PIN(30, 1, 41, 0),
+	MX31_PIN_CSPI2_SS2 = _MXC_BUILD_NON_GPIO_PIN(30, 0, 40, 2),
+	MX31_PIN_CSPI1_SS2 = _MXC_BUILD_NON_GPIO_PIN(31, 3, 43, 0),
+	MX31_PIN_CSPI1_SCLK = _MXC_BUILD_NON_GPIO_PIN(31, 2, 42, 2),
+	MX31_PIN_CSPI1_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(31, 1, 42, 1),
+	MX31_PIN_CSPI2_MOSI = _MXC_BUILD_NON_GPIO_PIN(31, 0, 42, 0),
+	MX31_PIN_CSPI1_MOSI = _MXC_BUILD_NON_GPIO_PIN(32, 3, 44, 1),
+	MX31_PIN_CSPI1_MISO = _MXC_BUILD_NON_GPIO_PIN(32, 2, 44, 0),
+	MX31_PIN_CSPI1_SS0 = _MXC_BUILD_NON_GPIO_PIN(32, 1, 43, 2),
+	MX31_PIN_CSPI1_SS1 = _MXC_BUILD_NON_GPIO_PIN(32, 0, 43, 1),
+	MX31_PIN_STXD6 = _MXC_BUILD_GPIO_PIN(0, 23, 33, 3, 45, 2),
+	MX31_PIN_SRXD6 = _MXC_BUILD_GPIO_PIN(0, 24, 33, 2, 45, 1),
+	MX31_PIN_SCK6 = _MXC_BUILD_GPIO_PIN(0, 25, 33, 1, 45, 0),
+	MX31_PIN_SFS6 = _MXC_BUILD_GPIO_PIN(0, 26, 33, 0, 44, 2),
+	MX31_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 21, 34, 3, 47, 0),
+	MX31_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 22, 34, 2, 46, 2),
+	MX31_PIN_SCK5 = _MXC_BUILD_NON_GPIO_PIN(34, 1, 46, 1),
+	MX31_PIN_SFS5 = _MXC_BUILD_NON_GPIO_PIN(34, 0, 46, 0),
+	MX31_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(0, 19, 35, 3, 48, 1),
+	MX31_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(0, 20, 35, 2, 48, 0),
+	MX31_PIN_SCK4 = _MXC_BUILD_NON_GPIO_PIN(35, 1, 47, 2),
+	MX31_PIN_SFS4 = _MXC_BUILD_NON_GPIO_PIN(35, 0, 47, 1),
+	MX31_PIN_STXD3 = _MXC_BUILD_GPIO_PIN(0, 17, 36, 3, 49, 2),
+	MX31_PIN_SRXD3 = _MXC_BUILD_GPIO_PIN(0, 18, 36, 2, 49, 1),
+	MX31_PIN_SCK3 = _MXC_BUILD_NON_GPIO_PIN(36, 1, 49, 0),
+	MX31_PIN_SFS3 = _MXC_BUILD_NON_GPIO_PIN(36, 0, 48, 2),
+	MX31_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(2, 18, 37, 3, 51, 0),
+	MX31_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(2, 19, 37, 2, 50, 2),
+	MX31_PIN_I2C_CLK = _MXC_BUILD_NON_GPIO_PIN(37, 1, 50, 1),
+	MX31_PIN_I2C_DAT = _MXC_BUILD_NON_GPIO_PIN(37, 0, 50, 0),
+	MX31_PIN_CSI_D14 = _MXC_BUILD_GPIO_PIN(2, 14, 38, 3, 52, 1),
+	MX31_PIN_CSI_D15 = _MXC_BUILD_GPIO_PIN(2, 15, 38, 2, 52, 0),
+	MX31_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(2, 16, 38, 1, 51, 2),
+	MX31_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(2, 17, 38, 0, 51, 1),
+	MX31_PIN_CSI_D10 = _MXC_BUILD_GPIO_PIN(2, 10, 39, 3, 53, 2),
+	MX31_PIN_CSI_D11 = _MXC_BUILD_GPIO_PIN(2, 11, 39, 2, 53, 1),
+	MX31_PIN_CSI_D12 = _MXC_BUILD_GPIO_PIN(2, 12, 39, 1, 53, 0),
+	MX31_PIN_CSI_D13 = _MXC_BUILD_GPIO_PIN(2, 13, 39, 0, 52, 2),
+	MX31_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(2, 6, 40, 3, 55, 0),
+	MX31_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(2, 7, 40, 2, 54, 2),
+	MX31_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(2, 8, 40, 1, 54, 1),
+	MX31_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(2, 9, 40, 0, 54, 0),
+	MX31_PIN_M_REQUEST = _MXC_BUILD_NON_GPIO_PIN(41, 3, 56, 1),
+	MX31_PIN_M_GRANT = _MXC_BUILD_NON_GPIO_PIN(41, 2, 56, 0),
+	MX31_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(2, 4, 41, 1, 55, 2),
+	MX31_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(2, 5, 41, 0, 55, 1),
+	MX31_PIN_PC_RST = _MXC_BUILD_NON_GPIO_PIN(42, 3, 57, 2),
+	MX31_PIN_IOIS16 = _MXC_BUILD_NON_GPIO_PIN(42, 2, 57, 1),
+	MX31_PIN_PC_RW_B = _MXC_BUILD_NON_GPIO_PIN(42, 1, 57, 0),
+	MX31_PIN_PC_POE = _MXC_BUILD_NON_GPIO_PIN(42, 0, 56, 2),
+	MX31_PIN_PC_VS1 = _MXC_BUILD_NON_GPIO_PIN(43, 3, 59, 0),
+	MX31_PIN_PC_VS2 = _MXC_BUILD_NON_GPIO_PIN(43, 2, 58, 2),
+	MX31_PIN_PC_BVD1 = _MXC_BUILD_NON_GPIO_PIN(43, 1, 58, 1),
+	MX31_PIN_PC_BVD2 = _MXC_BUILD_NON_GPIO_PIN(43, 0, 58, 0),
+	MX31_PIN_PC_CD2_B = _MXC_BUILD_NON_GPIO_PIN(44, 3, 60, 1),
+	MX31_PIN_PC_WAIT_B = _MXC_BUILD_NON_GPIO_PIN(44, 2, 60, 0),
+	MX31_PIN_PC_READY = _MXC_BUILD_NON_GPIO_PIN(44, 1, 59, 2),
+	MX31_PIN_PC_PWRON = _MXC_BUILD_NON_GPIO_PIN(44, 0, 59, 1),
+	MX31_PIN_D2 = _MXC_BUILD_NON_GPIO_PIN(45, 3, 61, 2),
+	MX31_PIN_D1 = _MXC_BUILD_NON_GPIO_PIN(45, 2, 61, 1),
+	MX31_PIN_D0 = _MXC_BUILD_NON_GPIO_PIN(45, 1, 61, 0),
+	MX31_PIN_PC_CD1_B = _MXC_BUILD_NON_GPIO_PIN(45, 0, 60, 2),
+	MX31_PIN_D6 = _MXC_BUILD_NON_GPIO_PIN(46, 3, 63, 0),
+	MX31_PIN_D5 = _MXC_BUILD_NON_GPIO_PIN(46, 2, 62, 2),
+	MX31_PIN_D4 = _MXC_BUILD_NON_GPIO_PIN(46, 1, 62, 1),
+	MX31_PIN_D3 = _MXC_BUILD_NON_GPIO_PIN(46, 0, 62, 0),
+	MX31_PIN_D10 = _MXC_BUILD_NON_GPIO_PIN(47, 3, 64, 1),
+	MX31_PIN_D9 = _MXC_BUILD_NON_GPIO_PIN(47, 2, 64, 0),
+	MX31_PIN_D8 = _MXC_BUILD_NON_GPIO_PIN(47, 1, 63, 2),
+	MX31_PIN_D7 = _MXC_BUILD_NON_GPIO_PIN(47, 0, 63, 1),
+	MX31_PIN_D14 = _MXC_BUILD_NON_GPIO_PIN(48, 3, 65, 2),
+	MX31_PIN_D13 = _MXC_BUILD_NON_GPIO_PIN(48, 2, 65, 1),
+	MX31_PIN_D12 = _MXC_BUILD_NON_GPIO_PIN(48, 1, 65, 0),
+	MX31_PIN_D11 = _MXC_BUILD_NON_GPIO_PIN(48, 0, 64, 2),
+	MX31_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(0, 14, 49, 3, 67, 0),
+	MX31_PIN_NFCE_B = _MXC_BUILD_GPIO_PIN(0, 15, 49, 2, 66, 2),
+	MX31_PIN_NFRB = _MXC_BUILD_GPIO_PIN(0, 16, 49, 1, 66, 1),
+	MX31_PIN_D15 = _MXC_BUILD_NON_GPIO_PIN(49, 0, 66, 0),
+	MX31_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(0, 10, 50, 3, 68, 1),
+	MX31_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(0, 11, 50, 2, 68, 0),
+	MX31_PIN_NFALE = _MXC_BUILD_GPIO_PIN(0, 12, 50, 1, 67, 2),
+	MX31_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(0, 13, 50, 0, 67, 1),
+	MX31_PIN_SDQS0 = _MXC_BUILD_NON_GPIO_PIN(51, 3, 69, 2),
+	MX31_PIN_SDQS1 = _MXC_BUILD_NON_GPIO_PIN(51, 2, 69, 1),
+	MX31_PIN_SDQS2 = _MXC_BUILD_NON_GPIO_PIN(51, 1, 69, 0),
+	MX31_PIN_SDQS3 = _MXC_BUILD_NON_GPIO_PIN(51, 0, 68, 2),
+	MX31_PIN_SDCKE0 = _MXC_BUILD_NON_GPIO_PIN(52, 3, 71, 0),
+	MX31_PIN_SDCKE1 = _MXC_BUILD_NON_GPIO_PIN(52, 2, 70, 2),
+	MX31_PIN_SDCLK = _MXC_BUILD_NON_GPIO_PIN(52, 1, 70, 1),
+	MX31_PIN_SDCLK_B = _MXC_BUILD_NON_GPIO_PIN(52, 0, 70, 0),
+	MX31_PIN_RW = _MXC_BUILD_NON_GPIO_PIN(53, 3, 72, 1),
+	MX31_PIN_RAS = _MXC_BUILD_NON_GPIO_PIN(53, 2, 72, 0),
+	MX31_PIN_CAS = _MXC_BUILD_NON_GPIO_PIN(53, 1, 71, 2),
+	MX31_PIN_SDWE = _MXC_BUILD_NON_GPIO_PIN(53, 0, 71, 1),
+	MX31_PIN_CS5 = _MXC_BUILD_NON_GPIO_PIN(54, 3, 73, 2),
+	MX31_PIN_ECB = _MXC_BUILD_NON_GPIO_PIN(54, 2, 73, 1),
+	MX31_PIN_LBA = _MXC_BUILD_NON_GPIO_PIN(54, 1, 73, 0),
+	MX31_PIN_BCLK = _MXC_BUILD_NON_GPIO_PIN(54, 0, 72, 2),
+	MX31_PIN_CS1 = _MXC_BUILD_NON_GPIO_PIN(55, 3, 75, 0),
+	MX31_PIN_CS2 = _MXC_BUILD_NON_GPIO_PIN(55, 2, 74, 2),
+	MX31_PIN_CS3 = _MXC_BUILD_NON_GPIO_PIN(55, 1, 74, 1),
+	MX31_PIN_CS4 = _MXC_BUILD_NON_GPIO_PIN(55, 0, 74, 0),
+	MX31_PIN_EB0 = _MXC_BUILD_NON_GPIO_PIN(56, 3, 76, 1),
+	MX31_PIN_EB1 = _MXC_BUILD_NON_GPIO_PIN(56, 2, 76, 0),
+	MX31_PIN_OE = _MXC_BUILD_NON_GPIO_PIN(56, 1, 75, 2),
+	MX31_PIN_CS0 = _MXC_BUILD_NON_GPIO_PIN(56, 0, 75, 1),
+	MX31_PIN_DQM0 = _MXC_BUILD_NON_GPIO_PIN(57, 3, 77, 2),
+	MX31_PIN_DQM1 = _MXC_BUILD_NON_GPIO_PIN(57, 2, 77, 1),
+	MX31_PIN_DQM2 = _MXC_BUILD_NON_GPIO_PIN(57, 1, 77, 0),
+	MX31_PIN_DQM3 = _MXC_BUILD_NON_GPIO_PIN(57, 0, 76, 2),
+	MX31_PIN_SD28 = _MXC_BUILD_NON_GPIO_PIN(58, 3, 79, 0),
+	MX31_PIN_SD29 = _MXC_BUILD_NON_GPIO_PIN(58, 2, 78, 2),
+	MX31_PIN_SD30 = _MXC_BUILD_NON_GPIO_PIN(58, 1, 78, 1),
+	MX31_PIN_SD31 = _MXC_BUILD_NON_GPIO_PIN(58, 0, 78, 0),
+	MX31_PIN_SD24 = _MXC_BUILD_NON_GPIO_PIN(59, 3, 80, 1),
+	MX31_PIN_SD25 = _MXC_BUILD_NON_GPIO_PIN(59, 2, 80, 0),
+	MX31_PIN_SD26 = _MXC_BUILD_NON_GPIO_PIN(59, 1, 79, 2),
+	MX31_PIN_SD27 = _MXC_BUILD_NON_GPIO_PIN(59, 0, 79, 1),
+	MX31_PIN_SD20 = _MXC_BUILD_NON_GPIO_PIN(60, 3, 81, 2),
+	MX31_PIN_SD21 = _MXC_BUILD_NON_GPIO_PIN(60, 2, 81, 1),
+	MX31_PIN_SD22 = _MXC_BUILD_NON_GPIO_PIN(60, 1, 81, 0),
+	MX31_PIN_SD23 = _MXC_BUILD_NON_GPIO_PIN(60, 0, 80, 2),
+	MX31_PIN_SD16 = _MXC_BUILD_NON_GPIO_PIN(61, 3, 83, 0),
+	MX31_PIN_SD17 = _MXC_BUILD_NON_GPIO_PIN(61, 2, 82, 2),
+	MX31_PIN_SD18 = _MXC_BUILD_NON_GPIO_PIN(61, 1, 82, 1),
+	MX31_PIN_SD19 = _MXC_BUILD_NON_GPIO_PIN(61, 0, 82, 0),
+	MX31_PIN_SD12 = _MXC_BUILD_NON_GPIO_PIN(62, 3, 84, 1),
+	MX31_PIN_SD13 = _MXC_BUILD_NON_GPIO_PIN(62, 2, 84, 0),
+	MX31_PIN_SD14 = _MXC_BUILD_NON_GPIO_PIN(62, 1, 83, 2),
+	MX31_PIN_SD15 = _MXC_BUILD_NON_GPIO_PIN(62, 0, 83, 1),
+	MX31_PIN_SD8 = _MXC_BUILD_NON_GPIO_PIN(63, 3, 85, 2),
+	MX31_PIN_SD9 = _MXC_BUILD_NON_GPIO_PIN(63, 2, 85, 1),
+	MX31_PIN_SD10 = _MXC_BUILD_NON_GPIO_PIN(63, 1, 85, 0),
+	MX31_PIN_SD11 = _MXC_BUILD_NON_GPIO_PIN(63, 0, 84, 2),
+	MX31_PIN_SD4 = _MXC_BUILD_NON_GPIO_PIN(64, 3, 87, 0),
+	MX31_PIN_SD5 = _MXC_BUILD_NON_GPIO_PIN(64, 2, 86, 2),
+	MX31_PIN_SD6 = _MXC_BUILD_NON_GPIO_PIN(64, 1, 86, 1),
+	MX31_PIN_SD7 = _MXC_BUILD_NON_GPIO_PIN(64, 0, 86, 0),
+	MX31_PIN_SD0 = _MXC_BUILD_NON_GPIO_PIN(65, 3, 88, 1),
+	MX31_PIN_SD1 = _MXC_BUILD_NON_GPIO_PIN(65, 2, 88, 0),
+	MX31_PIN_SD2 = _MXC_BUILD_NON_GPIO_PIN(65, 1, 87, 2),
+	MX31_PIN_SD3 = _MXC_BUILD_NON_GPIO_PIN(65, 0, 87, 1),
+	MX31_PIN_A24 = _MXC_BUILD_NON_GPIO_PIN(66, 3, 89, 2),
+	MX31_PIN_A25 = _MXC_BUILD_NON_GPIO_PIN(66, 2, 89, 1),
+	MX31_PIN_SDBA1 = _MXC_BUILD_NON_GPIO_PIN(66, 1, 89, 0),
+	MX31_PIN_SDBA0 = _MXC_BUILD_NON_GPIO_PIN(66, 0, 88, 2),
+	MX31_PIN_A20 = _MXC_BUILD_NON_GPIO_PIN(67, 3, 91, 0),
+	MX31_PIN_A21 = _MXC_BUILD_NON_GPIO_PIN(67, 2, 90, 2),
+	MX31_PIN_A22 = _MXC_BUILD_NON_GPIO_PIN(67, 1, 90, 1),
+	MX31_PIN_A23 = _MXC_BUILD_NON_GPIO_PIN(67, 0, 90, 0),
+	MX31_PIN_A16 = _MXC_BUILD_NON_GPIO_PIN(68, 3, 92, 1),
+	MX31_PIN_A17 = _MXC_BUILD_NON_GPIO_PIN(68, 2, 92, 0),
+	MX31_PIN_A18 = _MXC_BUILD_NON_GPIO_PIN(68, 1, 91, 2),
+	MX31_PIN_A19 = _MXC_BUILD_NON_GPIO_PIN(68, 0, 91, 1),
+	MX31_PIN_A12 = _MXC_BUILD_NON_GPIO_PIN(69, 3, 93, 2),
+	MX31_PIN_A13 = _MXC_BUILD_NON_GPIO_PIN(69, 2, 93, 1),
+	MX31_PIN_A14 = _MXC_BUILD_NON_GPIO_PIN(69, 1, 93, 0),
+	MX31_PIN_A15 = _MXC_BUILD_NON_GPIO_PIN(69, 0, 92, 2),
+	MX31_PIN_A9 = _MXC_BUILD_NON_GPIO_PIN(70, 3, 95, 0),
+	MX31_PIN_A10 = _MXC_BUILD_NON_GPIO_PIN(70, 2, 94, 2),
+	MX31_PIN_MA10 = _MXC_BUILD_NON_GPIO_PIN(70, 1, 94, 1),
+	MX31_PIN_A11 = _MXC_BUILD_NON_GPIO_PIN(70, 0, 94, 0),
+	MX31_PIN_A5 = _MXC_BUILD_NON_GPIO_PIN(71, 3, 96, 1),
+	MX31_PIN_A6 = _MXC_BUILD_NON_GPIO_PIN(71, 2, 96, 0),
+	MX31_PIN_A7 = _MXC_BUILD_NON_GPIO_PIN(71, 1, 95, 2),
+	MX31_PIN_A8 = _MXC_BUILD_NON_GPIO_PIN(71, 0, 95, 1),
+	MX31_PIN_A1 = _MXC_BUILD_NON_GPIO_PIN(72, 3, 97, 2),
+	MX31_PIN_A2 = _MXC_BUILD_NON_GPIO_PIN(72, 2, 97, 1),
+	MX31_PIN_A3 = _MXC_BUILD_NON_GPIO_PIN(72, 1, 97, 0),
+	MX31_PIN_A4 = _MXC_BUILD_NON_GPIO_PIN(72, 0, 96, 2),
+	MX31_PIN_DVFS1 = _MXC_BUILD_NON_GPIO_PIN(73, 3, 99, 0),
+	MX31_PIN_VPG0 = _MXC_BUILD_NON_GPIO_PIN(73, 2, 98, 2),
+	MX31_PIN_VPG1 = _MXC_BUILD_NON_GPIO_PIN(73, 1, 98, 1),
+	MX31_PIN_A0 = _MXC_BUILD_NON_GPIO_PIN(73, 0, 98, 0),
+	MX31_PIN_CKIL = _MXC_BUILD_NON_GPIO_PIN(74, 3, 100, 1),
+	MX31_PIN_POWER_FAIL = _MXC_BUILD_NON_GPIO_PIN(74, 2, 100, 0),
+	MX31_PIN_VSTBY = _MXC_BUILD_NON_GPIO_PIN(74, 1, 99, 2),
+	MX31_PIN_DVFS0 = _MXC_BUILD_NON_GPIO_PIN(74, 0, 99, 1),
+	MX31_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN(75, 3, 101, 2),
+	MX31_PIN_BOOT_MODE2 = _MXC_BUILD_NON_GPIO_PIN(75, 2, 101, 1),
+	MX31_PIN_BOOT_MODE3 = _MXC_BUILD_NON_GPIO_PIN(75, 1, 101, 0),
+	MX31_PIN_BOOT_MODE4 = _MXC_BUILD_NON_GPIO_PIN(75, 0, 100, 2),
+	MX31_PIN_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN(76, 3, 103, 0),
+	MX31_PIN_POR_B = _MXC_BUILD_NON_GPIO_PIN(76, 2, 102, 2),
+	MX31_PIN_CLKO = _MXC_BUILD_NON_GPIO_PIN(76, 1, 102, 1),
+	MX31_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN(76, 0, 102, 0),
+	MX31_PIN_STX0 = _MXC_BUILD_GPIO_PIN(1, 1, 77, 3, 104, 1),
+	MX31_PIN_SRX0 = _MXC_BUILD_GPIO_PIN(1, 2, 77, 2, 104, 0),
+	MX31_PIN_SIMPD0 = _MXC_BUILD_GPIO_PIN(1, 3, 77, 1, 103, 2),
+	MX31_PIN_CKIH = _MXC_BUILD_NON_GPIO_PIN(77, 0, 103, 1),
+	MX31_PIN_GPIO3_1 = _MXC_BUILD_GPIO_PIN(2, 1, 78, 3, 105, 2),
+	MX31_PIN_SCLK0 = _MXC_BUILD_GPIO_PIN(2, 2, 78, 2, 105, 1),
+	MX31_PIN_SRST0 = _MXC_BUILD_GPIO_PIN(2, 3, 78, 1, 105, 0),
+	MX31_PIN_SVEN0 = _MXC_BUILD_GPIO_PIN(1, 0, 78, 0, 104, 2),
+	MX31_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 79, 3, 107, 0),
+	MX31_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 79, 2, 106, 2),
+	MX31_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 79, 1, 106, 1),
+	MX31_PIN_GPIO3_0 = _MXC_BUILD_GPIO_PIN(2, 0, 79, 0, 106, 0),
+	MX31_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 80, 3, 108, 1),
+	MX31_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 80, 2, 108, 0),
+	MX31_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 80, 1, 107, 2),
+	MX31_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 80, 0, 107, 1),
+	MX31_PIN_CAPTURE = _MXC_BUILD_GPIO_PIN(0, 7, 81, 3, 109, 2),
+	MX31_PIN_COMPARE = _MXC_BUILD_GPIO_PIN(0, 8, 81, 2, 109, 1),
+	MX31_PIN_WATCHDOG_RST = _MXC_BUILD_NON_GPIO_PIN(81, 1, 109, 0),
+	MX31_PIN_PWMO = _MXC_BUILD_GPIO_PIN(0, 9, 81, 0, 108, 2),
+};
+
+#endif
+#endif
diff --git a/arch/arm/mach-mx3/mxc_pm.c b/arch/arm/mach-mx3/mxc_pm.c
new file mode 100644
index 0000000..e833986
--- /dev/null
+++ b/arch/arm/mach-mx3/mxc_pm.c
@@ -0,0 +1,421 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DPM_MX31 Power Management
+ * @ingroup MSL_MX31
+ */
+/*!
+ * @file mach-mx3/mxc_pm.c
+ *
+ * @brief This file provides all the kernel level and user level API
+ * definitions for the CRM_MCU and DPLL in mx3.
+ *
+ * @ingroup DPM_MX31
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <mach/mxc_pm.h>
+#include <asm/cacheflush.h>
+#include <asm/irq.h>
+#include <mach/common.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include "crm_regs.h"
+
+/* Local defines */
+#define FREQ_COMP_TOLERANCE      200	/* tolerance percentage times 100 */
+#define MCU_PLL_MAX_FREQ   600000000	/* Maximum frequency MCU PLL clock */
+#define MCU_PLL_MIN_FREQ   160000000	/* Minimum frequency MCU PLL clock */
+#define NFC_MAX_FREQ        20000000	/* Maximum frequency NFC clock */
+#define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
+
+static struct clk *mcu_pll_clk;
+static struct clk *cpu_clk;
+static struct clk *ahb_clk;
+static struct clk *ipg_clk;
+
+/*!
+ * Spinlock to protect CRM register accesses
+ */
+static DEFINE_SPINLOCK(mxc_crm_lock);
+
+/*!
+ * This function is called to modify the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(void *reg_offset, unsigned int mask,
+			unsigned int data)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	reg = __raw_readl(reg_offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, reg_offset);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * Compare two frequences using allowable tolerance
+ *
+ * The MX3 PLL can generate many frequencies. This function
+ * compares the generated frequency to the requested frequency
+ * and determines it they are within and acceptable tolerance.
+ *
+ * @param   freq1  desired frequency
+ * @param   freq2  generated frequency
+ *
+ * @return       Returns 0 is frequencies are within talerance
+ *               and non-zero is they are not.
+ */
+static int freq_equal(unsigned long freq1, unsigned long freq2)
+{
+	if (freq1 > freq2)
+		return (freq1 - freq2) <= (freq1 / FREQ_COMP_TOLERANCE);
+	return (freq2 - freq1) <= (freq1 / FREQ_COMP_TOLERANCE);
+}
+
+/*!
+ * Calculate new MCU clock dividers for the PDR0 regiser.
+ *
+ * @param   mcu_main_clk PLL output frequency (Hz)
+ * @param   arm_freq     desired ARM frequency (Hz)
+ * @param   max_freq     desired MAX frequency (Hz)
+ * @param   ip_freq      desired IP frequency (Hz)
+ * @param   mask         were to return PDR0 mask
+ * @param   value        were to return PDR0 value
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+static int
+cal_pdr0_value(unsigned long mcu_main_clk,
+	       long arm_freq,
+	       long max_freq,
+	       long ip_freq, unsigned long *mask, unsigned long *value)
+{
+	unsigned long arm_div;	/* ARM core clock divider */
+	unsigned long max_div;	/* MAX clock divider */
+	unsigned long ipg_div;	/* IPG clock divider */
+	unsigned long nfc_div;	/* NFC (Nand Flash Controller) clock divider */
+	unsigned long hsp_div;	/* HSP clock divider */
+
+	if (arm_freq > mcu_main_clk)
+		return -PLL_LESS_ARM_ERR;
+
+	arm_div = mcu_main_clk / arm_freq;
+	if ((arm_div == 0) || !freq_equal(arm_freq, mcu_main_clk / arm_div))
+		return FREQ_OUT_OF_RANGE;
+	max_div = mcu_main_clk / max_freq;
+	if ((max_div == 0) || !freq_equal(max_freq, mcu_main_clk / max_div))
+		return FREQ_OUT_OF_RANGE;
+	hsp_div = max_div;
+
+	ipg_div = max_freq / ip_freq;
+	if ((ipg_div == 0) || !freq_equal(ip_freq, max_freq / ipg_div))
+		return FREQ_OUT_OF_RANGE;
+
+	nfc_div = ((max_freq - 1000000) / NFC_MAX_FREQ) + 1;
+
+	/* All of the divider values have been calculated.
+	 * Now change the hardware register. */
+
+	*mask = MXC_CCM_PDR0_HSP_PODF_MASK |
+	    MXC_CCM_PDR0_NFC_PODF_MASK |
+	    MXC_CCM_PDR0_IPG_PODF_MASK |
+	    MXC_CCM_PDR0_MAX_PODF_MASK | MXC_CCM_PDR0_MCU_PODF_MASK;
+
+	*value = ((hsp_div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET) |
+	    ((nfc_div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET) |
+	    ((ipg_div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET) |
+	    ((max_div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET) |
+	    ((arm_div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
+
+	return 0;
+}
+
+/*!
+ * Integer clock scaling
+ *
+ * Change main arm clock frequencies without changing the PLL.
+ * The integer dividers are changed to produce the desired
+ * frequencies. The number of valid frequency are limited and
+ * are determined by the current MCU PLL frequency
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+int mxc_pm_intscale(long arm_freq, long max_freq, long ip_freq)
+{
+	unsigned long mcu_main_clk;	/* mcu clock domain main clock */
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+	       arm_freq, max_freq, ip_freq);
+
+	mcu_main_clk = clk_get_rate(mcu_pll_clk);
+	ret_value = cal_pdr0_value(mcu_main_clk, arm_freq, max_freq, ip_freq,
+				   &mask, &value);
+	if ((arm_freq != clk_round_rate(cpu_clk, arm_freq)) ||
+	    (max_freq != clk_round_rate(ahb_clk, max_freq)) ||
+	    (ip_freq != clk_round_rate(ipg_clk, ip_freq))) {
+		return -EINVAL;
+	}
+
+	if ((max_freq != clk_get_rate(ahb_clk)) ||
+	    (ip_freq != clk_get_rate(ipg_clk))) {
+		return -EINVAL;
+	}
+
+	if (arm_freq != clk_get_rate(cpu_clk))
+		ret_value = clk_set_rate(cpu_clk, arm_freq);
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_intscale);
+
+/*!
+ * PLL clock scaling
+ *
+ * Change MCU PLL frequency and adjust derived clocks. Integer
+ * dividers are used generate the derived clocks so changed to produce
+ * the desired the valid frequencies are limited by the desired ARM
+ * frequency.
+ *
+ * The clock source for the MCU is set to the MCU PLL.
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+int mxc_pm_pllscale(long arm_freq, long max_freq, long ip_freq)
+{
+	signed long pll_freq = 0;	/* target pll frequency */
+	unsigned long old_pll;
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+	       arm_freq, max_freq, ip_freq);
+
+	do {
+		pll_freq += arm_freq;
+		if ((pll_freq > MCU_PLL_MAX_FREQ) || (pll_freq / 8 > arm_freq))
+			return FREQ_OUT_OF_RANGE;
+		if (pll_freq < MCU_PLL_MIN_FREQ) {
+			ret_value = 111;
+		} else {
+			ret_value =
+			    cal_pdr0_value(pll_freq, arm_freq, max_freq,
+					   ip_freq, &mask, &value);
+		}
+	} while (ret_value != 0);
+
+	old_pll = clk_get_rate(mcu_pll_clk);
+	if (pll_freq > old_pll) {
+		/* if pll freq is increasing then change dividers first */
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
+	} else {
+		/* if pll freq is decreasing then change pll first */
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+	}
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_pllscale);
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, DOZE_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode)
+{
+	unsigned int lpm;
+	int enable_flag;
+	unsigned long reg;
+
+	enable_flag = 0;
+
+	switch (mode) {
+	case STOP_MODE:
+		/* State Retention mode */
+		lpm = 2;
+		/* Disable timer interrupt */
+		disable_irq(MXC_INT_GPT);
+		enable_flag = 1;
+
+		/* Enable Well Bias and set VSTBY
+		 * VSTBY pin will be asserted during SR mode. This asks the
+		 * PM IC to set the core voltage to the standby voltage
+		 * Must clear the MXC_CCM_CCMR_SBYCS bit as well  */
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				   MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY |
+				   MXC_CCM_CCMR_SBYCS,
+				   MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY |
+				   MXC_CCM_CCMR_SBYCS);
+
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				   MXC_CCM_CCMR_LPM_MASK,
+				   lpm << MXC_CCM_CCMR_LPM_OFFSET);
+		cpu_do_idle();
+		break;
+
+	case DSM_MODE:
+		/* Deep Sleep Mode */
+		lpm = 3;
+		/* Disable timer interrupt */
+		disable_irq(MXC_INT_GPT);
+		enable_flag = 1;
+		/* Enabled Well Bias
+		 * SBYCS = 0, MCU clock source is disabled*/
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				   MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY |
+				   MXC_CCM_CCMR_SBYCS | MXC_CCM_CCMR_LPM_MASK,
+				   MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY |
+				   MXC_CCM_CCMR_SBYCS |
+				   (lpm << MXC_CCM_CCMR_LPM_OFFSET));
+
+		/* wake up by keypad */
+		reg = __raw_readl(MXC_CCM_WIMR);
+		reg &= ~(1 << 18);
+		__raw_writel(reg, MXC_CCM_WIMR);
+
+		flush_cache_all();
+
+		mxc_pm_arch_entry(IO_ADDRESS(MX31_NFC_BASE_ADDR), 2048);
+		printk(KERN_INFO "Resume from DSM\n");
+
+		mxc_init_irq(IO_ADDRESS(AVIC_BASE_ADDR));
+
+		break;
+	default:
+	case WAIT_MODE:
+		/* Wait is the default mode used when idle. */
+		reg = __raw_readl(MXC_CCM_CCMR);
+		reg &= ~MXC_CCM_CCMR_LPM_MASK;
+		__raw_writel(reg, MXC_CCM_CCMR);
+		break;
+	}
+
+	if (enable_flag) {
+		/* Enable timer interrupt */
+		enable_irq(MXC_INT_GPT);
+	}
+}
+EXPORT_SYMBOL(mxc_pm_lowpower);
+
+#ifdef CONFIG_MXC_DVFS
+/*!
+ * Changes MCU frequencies using dvfs.
+ *
+ * @param       armfreq       desired ARM frequency in Hz
+ * @param       ahbfreq       desired AHB frequency in Hz
+ * @param       ipfreq        desired IP frequency in Hz
+ *
+ * @return             Returns 0 on success, non-zero on error
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq)
+{
+	int ret_value;
+	int i;
+
+	if (ahbfreq != 133000000)
+		return FREQ_OUT_OF_RANGE;
+	if (ipfreq != 66500000)
+		return FREQ_OUT_OF_RANGE;
+	ret_value = FREQ_OUT_OF_RANGE;
+	for (i = 0; i < dvfs_states_tbl->num_of_states; i++) {
+		if (dvfs_states_tbl->freqs[i] == armfreq) {
+			ret_value = dvfs_set_state(i);
+			break;
+		}
+	}
+
+	return ret_value;
+}
+EXPORT_SYMBOL(mxc_pm_dvfs);
+#endif				/* CONFIG_MXC_DVFS */
+
+/*!
+ * This function is used to load the module.
+ *
+ * @return   Returns an Integer on success
+ */
+static int __init mxc_pm_init_module(void)
+{
+	printk(KERN_INFO "Low-Level PM Driver module loaded\n");
+
+	mcu_pll_clk = clk_get(NULL, "mcu_pll");
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	ipg_clk = clk_get(NULL, "ipg_clk");
+	return 0;
+}
+
+/*!
+ * This function is used to unload the module
+ */
+static void __exit mxc_pm_cleanup_module(void)
+{
+	clk_put(mcu_pll_clk);
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+	clk_put(ipg_clk);
+	printk(KERN_INFO "Low-Level PM Driver module Unloaded\n");
+}
+
+module_init(mxc_pm_init_module);
+module_exit(mxc_pm_cleanup_module);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX3 Low-level Power Management Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx3/pm.c b/arch/arm/mach-mx3/pm.c
new file mode 100644
index 0000000..4c734db
--- /dev/null
+++ b/arch/arm/mach-mx3/pm.c
@@ -0,0 +1,102 @@
+/*
+ * linux/arch/arm/mach-mx3/pm.c
+ *
+ * MX3 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX31
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/suspend.h>
+#include <linux/regulator/machine.h>
+#include <mach/mxc_pm.h>
+
+/*
+ * TODO: whatta save?
+ */
+
+static int mx31_suspend_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_pm_lowpower(DSM_MODE);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_pm_lowpower(STOP_MODE);
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx31_suspend_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx31_suspend_finish(void)
+{
+	return;
+}
+
+static int mx31_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx31_suspend_ops = {
+	.valid = mx31_pm_valid,
+	.prepare = mx31_suspend_prepare,
+	.enter = mx31_suspend_enter,
+	.finish = mx31_suspend_finish,
+};
+
+static int __init mx31_pm_init(void)
+{
+	printk(KERN_INFO "Power Management for Freescale MX31\n");
+	suspend_set_ops(&mx31_suspend_ops);
+
+	return 0;
+}
+
+late_initcall(mx31_pm_init);
diff --git a/arch/arm/mach-mx3/sdma_script_code.h b/arch/arm/mach-mx3/sdma_script_code.h
new file mode 100644
index 0000000..627b896
--- /dev/null
+++ b/arch/arm/mach-mx3/sdma_script_code.h
@@ -0,0 +1,581 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* Following define start address of start script
+*/
+#define start_ADDR	0
+/*!
+* Following define size of start script
+*/
+#define start_SIZE	21
+
+/*!
+* Following define start address of core script
+*/
+#define core_ADDR	80
+/*!
+* Following define size of core script
+*/
+#define core_SIZE	152
+
+/*!
+* Following define start address of common script
+*/
+#define common_ADDR	232
+/*!
+* Following define size of common script
+*/
+#define common_SIZE	191
+
+/*!
+* Following define start address of burst_copy script
+*/
+#define burst_copy_ADDR	423
+/*!
+* Following define size of burst_copy script
+*/
+#define burst_copy_SIZE	87
+
+/*!
+* Following define start address of dsp_2_burst script
+*/
+#define dsp_2_burst_ADDR	510
+/*!
+* Following define size of dsp_2_burst script
+*/
+#define dsp_2_burst_SIZE	24
+
+/*!
+* Following define start address of burst_2_dsp script
+*/
+#define burst_2_dsp_ADDR	534
+/*!
+* Following define size of burst_2_dsp script
+*/
+#define burst_2_dsp_SIZE	24
+
+/*!
+* Following define start address of dsp_copy script
+*/
+#define dsp_copy_ADDR	558
+/*!
+* Following define size of dsp_copy script
+*/
+#define dsp_copy_SIZE	86
+
+/*!
+* Following define start address of mcu_2_mcu script
+*/
+#define mcu_2_mcu_ADDR	644
+/*!
+* Following define size of mcu_2_mcu script
+*/
+#define mcu_2_mcu_SIZE	79
+
+/*!
+* Following define start address of mcu_2_per script
+*/
+#define mcu_2_per_ADDR	723
+/*!
+* Following define size of mcu_2_per script
+*/
+#define mcu_2_per_SIZE	88
+
+/*!
+* Following define start address of test script
+*/
+#define test_ADDR	811
+/*!
+* Following define size of test script
+*/
+#define test_SIZE	63
+
+/*!
+* Following define start address of mcu_2_dsp script
+*/
+#define mcu_2_dsp_ADDR	874
+/*!
+* Following define size of mcu_2_dsp script
+*/
+#define mcu_2_dsp_SIZE	30
+
+/*!
+* Following define start address of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_ADDR	904
+/*!
+* Following define size of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_mcu script
+*/
+#define dsp_2_mcu_ADDR	1017
+/*!
+* Following define size of dsp_2_mcu script
+*/
+#define dsp_2_mcu_SIZE	30
+
+/*!
+* Following define start address of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_ADDR	1047
+/*!
+* Following define size of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_dsp script
+*/
+#define dsp_2_dsp_ADDR	1160
+/*!
+* Following define size of dsp_2_dsp script
+*/
+#define dsp_2_dsp_SIZE	64
+
+/*!
+* Following define start address of per_2_mcu script
+*/
+#define per_2_mcu_ADDR	1224
+/*!
+* Following define size of per_2_mcu script
+*/
+#define per_2_mcu_SIZE	121
+
+/*!
+* Following define start address of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_ADDR	1345
+/*!
+* Following define size of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_SIZE	164
+
+/*!
+* Following define start address of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_ADDR	1509
+/*!
+* Following define size of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_SIZE	168
+
+/*!
+* Following define start address of per_2_per script
+*/
+#define per_2_per_ADDR	1677
+/*!
+* Following define size of per_2_per script
+*/
+#define per_2_per_SIZE	67
+
+/*!
+* Following define start address of error_dsp script
+*/
+#define error_dsp_ADDR	1744
+/*!
+* Following define size of error_dsp script
+*/
+#define error_dsp_SIZE	34
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define ap_2_ap_ADDR	6144
+/*!
+* Following define size of ap_2_ap script
+*/
+#define ap_2_ap_SIZE	294
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define app_2_mcu_ADDR	6438
+/*!
+* Following define size of app_2_mcu script
+*/
+#define app_2_mcu_SIZE	101
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define ata_2_mcu_ADDR	6539
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define ata_2_mcu_SIZE	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define dptc_dvfs_ADDR	6649
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define dptc_dvfs_SIZE	274
+
+/*!
+* Following define start address of error script
+*/
+#define error_ADDR	6923
+/*!
+* Following define size of error script
+*/
+#define error_SIZE	73
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define firi_2_mcu_ADDR	6996
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define firi_2_mcu_SIZE	114
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mcu_2_app_ADDR	7110
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mcu_2_app_SIZE	127
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mcu_2_ata_ADDR	7237
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mcu_2_ata_SIZE	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mcu_2_firi_ADDR	7324
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mcu_2_firi_SIZE	77
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mcu_2_mshc_ADDR	7401
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mcu_2_mshc_SIZE	48
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mcu_2_shp_ADDR	7449
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mcu_2_shp_SIZE	123
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mshc_2_mcu_ADDR	7572
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mshc_2_mcu_SIZE	60
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define shp_2_mcu_ADDR	7632
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define shp_2_mcu_SIZE	101
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define uart_2_mcu_ADDR	7733
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define uart_2_mcu_SIZE	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_ADDR	7838
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_SIZE	98
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define RAM_CODE_START_ADDR	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define RAM_CODE_SIZE	1792
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM.
+* This is required to start on a 4-byte aligned boundary on some platforms
+* for SDMA to work properly.
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static short sdma_code[] = {
+	0xc0ec, 0x7d59, 0x0970, 0x0111, 0x5111, 0x5ad1, 0x5bd9, 0xc0fe,
+	0x5ce1, 0x7d02, 0x0200, 0x9806, 0x08ff, 0x0011, 0x28ff, 0x00bc,
+	0x05df, 0x7d4b, 0x06df, 0x7d2f, 0x6dc5, 0x6ed5, 0x5ef1, 0x0288,
+	0xd81a, 0x9854, 0x0b04, 0x00d3, 0x7d20, 0x06a5, 0x3e03, 0x3d03,
+	0x03a5, 0x3b03, 0x008b, 0x058b, 0x7802, 0x63d8, 0x0000, 0x7e72,
+	0x63ff, 0x7e70, 0x02a5, 0x008a, 0x4e00, 0x7d01, 0x983d, 0x6dcf,
+	0x6edf, 0x0015, 0x0015, 0x7802, 0x63d8, 0x0000, 0x7e63, 0x63ff,
+	0x7e61, 0x3a03, 0x008a, 0x6dcd, 0x6edd, 0x7801, 0x63d8, 0x7e5a,
+	0x63ff, 0x7e58, 0x0006, 0x6dc5, 0x6e07, 0x5ef1, 0x0288, 0xd8f7,
+	0x7e02, 0x7f04, 0x9854, 0x0007, 0x68cc, 0x6b28, 0x54e1, 0x0089,
+	0xdb13, 0x0188, 0x5ce1, 0x9854, 0x52d1, 0x53d9, 0x54e1, 0xc10d,
+	0x7dad, 0x0200, 0x9800, 0x0200, 0x9800, 0x06df, 0x7d06, 0x6d23,
+	0x6ed5, 0x5ef1, 0x0288, 0xd8cd, 0x9854, 0x5ef1, 0x6e07, 0x6d03,
+	0x0b04, 0x00d3, 0x7d59, 0x06a5, 0x3e03, 0x3d03, 0x4d00, 0x7d09,
+	0x03a5, 0x00a3, 0x0588, 0x008b, 0xd8c9, 0x7ed8, 0x620c, 0x7ed6,
+	0x008d, 0x4e00, 0x7c25, 0x0a20, 0x00da, 0x7c22, 0x6503, 0x3d1f,
+	0x02a5, 0x00a2, 0x0215, 0x0215, 0x6a18, 0x6a28, 0x7fc7, 0x0a20,
+	0x0b08, 0x00da, 0x7c06, 0x6b18, 0x6b28, 0x7fc0, 0x0000, 0x2020,
+	0x9889, 0x0688, 0x0015, 0x0015, 0x6818, 0x6828, 0x7fb7, 0x98c2,
+	0x0007, 0x6a0c, 0x54e1, 0x0089, 0xdb0f, 0x0188, 0x5ce1, 0x9854,
+	0x0b04, 0x00d3, 0x7d21, 0x0389, 0x1b12, 0x048b, 0x0688, 0x0015,
+	0x0015, 0x0588, 0x038c, 0x0a08, 0x05da, 0x008d, 0x7c01, 0x008a,
+	0x05a0, 0x7803, 0x620b, 0x5a03, 0x1b01, 0x7e98, 0x008b, 0x00a4,
+	0x038c, 0x7803, 0x5203, 0x6a0b, 0x1b01, 0x6a28, 0x7f8f, 0x0000,
+	0x4d00, 0x7ce8, 0x008e, 0x3803, 0xd8c9, 0x7e88, 0x620c, 0x7e86,
+	0x9854, 0x7802, 0x6209, 0x6a29, 0x0006, 0x3e03, 0x4e00, 0x7d11,
+	0x0b04, 0x03a6, 0x02db, 0x7d01, 0x038a, 0x02a3, 0x048a, 0x008b,
+	0x7802, 0x6329, 0x6bc8, 0x7ebc, 0x63c8, 0x7ebc, 0x008c, 0x4800,
+	0x7d15, 0x0488, 0x0015, 0x0015, 0x6edf, 0x7803, 0x632b, 0x6bc8,
+	0x0000, 0x7eae, 0x63c8, 0x7eae, 0x008c, 0x3803, 0x6edd, 0x7803,
+	0x6329, 0x6bc8, 0x0000, 0x7ea4, 0x63c8, 0x7ea4, 0x0006, 0x3d03,
+	0x4d00, 0x7d0e, 0x0b04, 0x03a5, 0x02db, 0x7d01, 0x038a, 0x02a3,
+	0x048a, 0x008b, 0x7802, 0x63c8, 0x6b09, 0x7e1e, 0x7f1e, 0x008c,
+	0x0488, 0x0015, 0x0015, 0x6dcf, 0x0288, 0x008a, 0x0d08, 0x02dd,
+	0x7c01, 0x008d, 0x7802, 0x63c8, 0x6b0b, 0x7e0e, 0x6b28, 0x7f0d,
+	0x0000, 0x02dd, 0x7c02, 0x2208, 0x990d, 0x008c, 0x3803, 0x65c0,
+	0x6dc5, 0x7802, 0x63c8, 0x6b09, 0x6b28, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d5e, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x992c, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x993c, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210,
+	0x4a00, 0x7d1c, 0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311,
+	0x53eb, 0x62c8, 0x7e24, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09,
+	0x7f1e, 0x0212, 0x6a09, 0x7f1b, 0x0212, 0x6a09, 0x7f18, 0x2003,
+	0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313, 0x997d, 0x0015, 0x0015,
+	0x7802, 0x62c8, 0x6a0b, 0x997c, 0x0015, 0x7802, 0x62c8, 0x6a0a,
+	0x997c, 0x7802, 0x62c8, 0x6a09, 0x7c02, 0x0000, 0x993a, 0xdb13,
+	0x6a28, 0x7ffd, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7da5, 0x0200,
+	0x992c, 0x0200, 0x9929, 0xc19d, 0xc0ec, 0x7d69, 0x0c70, 0x0411,
+	0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02,
+	0x0200, 0x9994, 0x6d07, 0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff,
+	0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70, 0x0211, 0x552a,
+	0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9, 0x4d00, 0x7c13,
+	0x6928, 0x7f2d, 0x0400, 0x99a5, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e29, 0x6d28,
+	0x7f1e, 0x0000, 0x99a3, 0x1e20, 0x5506, 0x2620, 0x008d, 0x0560,
+	0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a, 0x7f10, 0x4c00,
+	0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000, 0x99ec, 0x0007,
+	0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28, 0x0007, 0x680c,
+	0x0007, 0x54d2, 0x0454, 0x99ef, 0x6928, 0x7ff1, 0x54d2, 0x008a,
+	0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200, 0x9994, 0x0200,
+	0x998c, 0xc0ec, 0x7d72, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1,
+	0x5bc9, 0x028e, 0xc0fe, 0x068a, 0x7c6a, 0x5dd9, 0x5ce1, 0x0bff,
+	0x0311, 0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363,
+	0x7c05, 0x036f, 0x7d27, 0x0374, 0x7c7a, 0x9a71, 0xdb04, 0x3c06,
+	0x4c00, 0x7df7, 0x028f, 0x1a04, 0x6a23, 0x620b, 0x6f23, 0x301f,
+	0x00aa, 0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9a30, 0x048a,
+	0x620b, 0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa,
+	0x048f, 0x1c04, 0x6c07, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e,
+	0x1a5c, 0x9a11, 0x058f, 0x1d0c, 0x6d23, 0x650b, 0x007d, 0x7c01,
+	0x1d08, 0x007c, 0x7c01, 0x1d04, 0x6d23, 0x650b, 0x0488, 0x3c1f,
+	0x0417, 0x0417, 0x0417, 0x0417, 0x059c, 0x6d23, 0x028e, 0x1a34,
+	0x6ad7, 0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28,
+	0x6ad7, 0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065,
+	0x7c02, 0x0101, 0x0025, 0x0400, 0x9a0d, 0x52c1, 0x53c9, 0x54e1,
+	0x0453, 0xc10d, 0x7d95, 0x0200, 0x9a00, 0x0200, 0x99f9, 0x0200,
+	0x9a00, 0x55d9, 0x6d07, 0x54d1, 0x058a, 0x2508, 0x6dc7, 0x0373,
+	0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372, 0x7c04, 0x65c8, 0x6d0b,
+	0x2408, 0x9a86, 0x6cce, 0x65c8, 0x6d0a, 0x2404, 0x6d28, 0x6507,
+	0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8, 0x0334, 0x6bc8, 0x0370,
+	0x7ca9, 0x0c60, 0x0411, 0x04bb, 0x4c00, 0x7da4, 0x0410, 0x1c30,
+	0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d, 0x7c03, 0x047c, 0x7c01,
+	0x9a3a, 0x003b, 0x003a, 0x0039, 0x0058, 0x9ab5, 0x047d, 0x7d03,
+	0x047c, 0x7d01, 0x9a3a, 0x005b, 0xdaf9, 0x1d18, 0x6d23, 0x650b,
+	0x0510, 0x003a, 0x0039, 0x0038, 0x00ad, 0xdb04, 0x0c30, 0x0410,
+	0x04bb, 0x003c, 0x003d, 0x00ac, 0xdaf9, 0x007b, 0x7c04, 0x003d,
+	0x003c, 0x1d0c, 0x9ad6, 0x048f, 0x1c14, 0x6c23, 0x640b, 0x4401,
+	0x7d04, 0x005d, 0x005c, 0x1d0c, 0x9ad6, 0x0310, 0x3b30, 0x4b30,
+	0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c, 0x00ab, 0x6ad7, 0x63c8,
+	0x6d23, 0x650b, 0x0560, 0x7d03, 0x005e, 0xdaed, 0x9a3a, 0x003e,
+	0x0c80, 0x0410, 0x0394, 0xdaed, 0x640b, 0x037f, 0x7d02, 0x1a14,
+	0x9aea, 0x1a0c, 0x6ad7, 0x6cc8, 0x9a3a, 0x0c7f, 0x0410, 0x03b4,
+	0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e, 0x1a04, 0x6ad7, 0x6cc8,
+	0x0006, 0x058f, 0x1d08, 0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d38,
+	0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b, 0x042c, 0x0454, 0x042b,
+	0x6ad7, 0x6cc8, 0x0006, 0x0007, 0x684c, 0x6144, 0x9b1c, 0x0007,
+	0x68cc, 0x61d0, 0x9b1c, 0x0007, 0x680c, 0x680c, 0x6107, 0x6907,
+	0x692b, 0x6928, 0x0007, 0x680c, 0x0d70, 0x0511, 0x5515, 0x55f5,
+	0x01a5, 0x0dff, 0x0512, 0x1dff, 0x0512, 0x04bd, 0x0499, 0x0454,
+	0x0006, 0x08ff, 0x0011, 0x28ff, 0x0006, 0x038c, 0x0eff, 0x0611,
+	0x2eff, 0x03b6, 0x0006, 0x53d6, 0x0398, 0x5bd6, 0x53ee, 0x0398,
+	0x5bee, 0x0006, 0x52de, 0x53e6, 0x54ee, 0x0498, 0x0454, 0x0006,
+	0x50f6, 0x52c6, 0x53ce, 0x54d6, 0x0498, 0x0454, 0x0006, 0x6207,
+	0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff,
+	0x0312, 0x04bb, 0x049a, 0x0006, 0x1e10, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b5b, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70,
+	0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9b6a, 0x0212,
+	0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8,
+	0xdba5, 0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xdbbd, 0x52c0,
+	0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x9b5b, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0xdba5, 0x9b68, 0x0200, 0x9b58, 0x0007, 0x68cc, 0x6a28,
+	0x7f01, 0x9ba3, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b,
+	0x6a28, 0x0007, 0x680c, 0x0454, 0x9b81, 0x05a0, 0x1e08, 0x6ec3,
+	0x0388, 0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5,
+	0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09,
+	0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5,
+	0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d78, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9bcc, 0x6d03, 0x6ed3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9bdc, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a,
+	0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25, 0x620a,
+	0x7e23, 0x9c06, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512,
+	0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70, 0x0311,
+	0x5313, 0x9c21, 0x7802, 0x6209, 0x6ac8, 0x9c20, 0x0015, 0x7802,
+	0x620a, 0x6ac8, 0x9c20, 0x0015, 0x0015, 0x7802, 0x620b, 0x6ac8,
+	0x7c03, 0x0000, 0x55db, 0x9bda, 0x0007, 0x68cc, 0x680c, 0x55d3,
+	0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9c2f, 0x0017, 0x0017, 0x55db,
+	0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8,
+	0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x008b, 0x52c0, 0x53c8, 0xc10d,
+	0x7d8b, 0x0200, 0x9bcc, 0x0200, 0x9bc9, 0xc19d, 0xc0ec, 0x7d52,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x9c4e, 0x6d03, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211, 0x4c00,
+	0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9c61, 0x4c01,
+	0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d, 0x9c5f,
+	0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f, 0x5d06,
+	0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0, 0x0454,
+	0x9c8b, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9, 0x4d00,
+	0x7c02, 0x0400, 0x9c8d, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7db6,
+	0x0200, 0x9c4e, 0x0200, 0x9c46, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9ca2, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62c8,
+	0x7e1f, 0x0400, 0x9cb3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16, 0x6ac8, 0x7f11, 0x0015,
+	0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e, 0x6ac8, 0x7f09, 0x6edf,
+	0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9cb1,
+	0x0007, 0x68cc, 0x9cdd, 0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd, 0x0200, 0x9ca2, 0x0200,
+	0x9c9f, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cf0, 0x0870, 0x0011,
+	0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228,
+	0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9cff, 0x620b, 0x7e06, 0x5a06,
+	0x7f06, 0x0000, 0x2504, 0x7d05, 0x9cff, 0x0007, 0x680c, 0x0007,
+	0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9cf0, 0x0200,
+	0x9cec, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d74, 0x5010, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d20, 0x6d03,
+	0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70, 0x0211, 0x532a, 0x5212,
+	0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9d34, 0x008f, 0x05d8, 0x7d01,
+	0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d27, 0x4d02, 0x7d20,
+	0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea, 0x0260, 0x7d05, 0x6509,
+	0x7e25, 0x630a, 0x7e23, 0x9d58, 0x630a, 0x7e20, 0x6509, 0x7e1e,
+	0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19, 0x2003, 0x4800, 0x7ced,
+	0x0a70, 0x0211, 0x5212, 0x9d73, 0x7802, 0x6309, 0x5b06, 0x9d72,
+	0x0015, 0x7802, 0x630a, 0x5b06, 0x9d72, 0x0015, 0x0015, 0x7802,
+	0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000, 0x9d32, 0x0007, 0x680c,
+	0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9d80, 0x0017, 0x0017,
+	0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d90,
+	0x0200, 0x9d20, 0x0200, 0x9d1c, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d35, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d9b, 0x0870, 0x0011, 0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d1c, 0x5228, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b,
+	0x0400, 0x9daa, 0x5206, 0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000,
+	0x2504, 0x7d0c, 0x9daa, 0x0007, 0x680c, 0x680c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3,
+	0x5010, 0x52c0, 0xc10d, 0x7dcf, 0x0200, 0x9d9b, 0x0200, 0x9d97,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d5e, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dd7, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0a70, 0x0211,
+	0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04, 0x6a28, 0x7f3a, 0x0400,
+	0x9de6, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312,
+	0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02, 0x7d20, 0x4b01, 0x7d23,
+	0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e24, 0x0260, 0x7d02, 0x0310,
+	0x0312, 0x6b09, 0x7f1e, 0x0312, 0x6b09, 0x7f1b, 0x0312, 0x6b09,
+	0x7f18, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e27,
+	0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b, 0x9e26, 0x0015, 0x7802,
+	0x5306, 0x6b0a, 0x9e26, 0x7802, 0x5306, 0x6b09, 0x7c02, 0x0000,
+	0x9de4, 0xdb13, 0x6928, 0x7ffd, 0x008a, 0x52c0, 0x53c8, 0xc10d,
+	0x7da6, 0x0200, 0x9dd7, 0x0200, 0x9dd3, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d5b, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9e3b, 0x0b70, 0x0311, 0x6ec3, 0x6d07, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3d, 0x522b, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f33, 0x0400, 0x9e4d, 0x028e, 0x1a94, 0x6ac3,
+	0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3, 0x6ed3, 0x62c8, 0x0248,
+	0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e, 0x7d31, 0x6a09, 0x7f1e,
+	0x2501, 0x4d00, 0x7d1f, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3,
+	0x0260, 0x7df1, 0x6a28, 0x7f12, 0xdb47, 0x9e8c, 0x6ee3, 0x008f,
+	0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17,
+	0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e4b, 0x0289, 0xdb13,
+	0x018a, 0x9e9b, 0x6a28, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0,
+	0x53c8, 0xc10d, 0x7da8, 0x0200, 0x9e3b, 0x0200, 0x9e38, 0x6a28,
+	0x7fed, 0xdb47, 0x9e9b, 0x0458, 0x0454, 0x9e8c, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d54, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9ea5, 0x0b70, 0x0311, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d36, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x6928, 0x7f2c, 0x0400, 0x9eb6, 0x028e, 0x1a94,
+	0x5202, 0x0269, 0x7d16, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694,
+	0x5206, 0x026e, 0x7d2e, 0x6a09, 0x7f1b, 0x2501, 0x4d00, 0x7d1c,
+	0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6a28, 0x7f11, 0xdb47,
+	0x9eee, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d17, 0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9eb4,
+	0x0289, 0xdb13, 0x018a, 0x9efd, 0x6928, 0x7ffa, 0x0b70, 0x0311,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7db0, 0x0200, 0x9ea5, 0x0200,
+	0x9ea1, 0x6a28, 0x7fed, 0xdb47, 0x9efd, 0x0458, 0x0454, 0x9eee,
+	0x9eee
+};
+#endif
diff --git a/arch/arm/mach-mx3/sdma_script_code_pass2.h b/arch/arm/mach-mx3/sdma_script_code_pass2.h
new file mode 100644
index 0000000..dde3f4a
--- /dev/null
+++ b/arch/arm/mach-mx3/sdma_script_code_pass2.h
@@ -0,0 +1,434 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+SDMA RELEASE LABEL: "SS15_MX31"
+
+*******************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_PASS2_H__
+#define __SDMA_SCRIPT_CODE_PASS2_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_2	0
+#define start_SIZE_2	20
+
+#define core_ADDR_2	80
+#define core_SIZE_2	152
+
+#define common_ADDR_2	232
+#define common_SIZE_2	191
+
+#define ap_2_ap_ADDR_2	423
+#define ap_2_ap_SIZE_2	294
+
+#define bp_2_bp_ADDR_2	717
+#define bp_2_bp_SIZE_2	112
+
+#define ap_2_bp_ADDR_2	829
+#define ap_2_bp_SIZE_2	200
+
+#define bp_2_ap_ADDR_2	1029
+#define bp_2_ap_SIZE_2	223
+
+#define app_2_mcu_ADDR_2	1252
+#define app_2_mcu_SIZE_2	101
+
+#define mcu_2_app_ADDR_2	1353
+#define mcu_2_app_SIZE_2	127
+
+#define uart_2_mcu_ADDR_2	1480
+#define uart_2_mcu_SIZE_2	105
+
+#define uartsh_2_mcu_ADDR_2	1585
+#define uartsh_2_mcu_SIZE_2	98
+
+#define mcu_2_shp_ADDR_2	1683
+#define mcu_2_shp_SIZE_2	123
+
+#define shp_2_mcu_ADDR_2	1806
+#define shp_2_mcu_SIZE_2	101
+
+#define error_ADDR_2	1907
+#define error_SIZE_2	73
+
+#define test_ADDR_2	1980
+#define test_SIZE_2	63
+
+#define signature_ADDR_2	1023
+#define signature_SIZE_2	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define ap_2_ap_fixed_addr_ADDR_2	6144
+#define ap_2_ap_fixed_addr_SIZE_2	68
+
+#define app_2_mcu_patched_ADDR_2	6212
+#define app_2_mcu_patched_SIZE_2	104
+
+#undef  app_2_mcu_ADDR_2
+#undef  app_2_mcu_SIZE_2
+
+/*mapping the app_2_mcu start address to the patched(RAM)script start address*/
+#define app_2_mcu_ADDR_2		app_2_mcu_patched_ADDR_2
+#define app_2_mcu_SIZE_2		app_2_mcu_patched_SIZE_2
+
+#define app_2_per_ADDR_2	6316
+#define app_2_per_SIZE_2	105
+
+#define ata_2_mcu_ADDR_2	6421
+#define ata_2_mcu_SIZE_2	110
+
+#define firi_2_mcu_ADDR_2	6531
+#define firi_2_mcu_SIZE_2	114
+
+#define loop_DMAs_fixed_addr_ADDR_2	6645
+#define loop_DMAs_fixed_addr_SIZE_2	90
+
+#define mcu_2_app_patched_ADDR_2	6735
+#define mcu_2_app_patched_SIZE_2	129
+
+#undef  mcu_2_app_ADDR_2
+#undef  mcu_2_app_SIZE_2
+
+/*mapping the mcu_2_app start address to the patched(RAM)script start address*/
+#define mcu_2_app_ADDR_2		mcu_2_app_patched_ADDR_2
+#define mcu_2_app_SIZE_2		mcu_2_app_patched_SIZE_2
+
+#define mcu_2_ata_ADDR_2	6864
+#define mcu_2_ata_SIZE_2	87
+
+#define mcu_2_firi_ADDR_2	6951
+#define mcu_2_firi_SIZE_2	77
+
+#define mcu_2_mshc_ADDR_2	7028
+#define mcu_2_mshc_SIZE_2	48
+
+#define mcu_2_shp_patched_ADDR_2	7076
+#define mcu_2_shp_patched_SIZE_2	125
+
+#undef  mcu_2_shp_ADDR_2
+#undef  mcu_2_shp_SIZE_2
+
+/*mapping the mcu_2_shp start address to the patched(RAM)script start address*/
+#define mcu_2_shp_ADDR_2		mcu_2_shp_patched_ADDR_2
+#define mcu_2_shp_SIZE_2		mcu_2_shp_patched_SIZE_2
+
+#define mshc_2_mcu_ADDR_2	7201
+#define mshc_2_mcu_SIZE_2	60
+
+#define per_2_app_ADDR_2	7261
+#define per_2_app_SIZE_2	131
+
+#define per_2_shp_ADDR_2	7392
+#define per_2_shp_SIZE_2	131
+
+#define shp_2_mcu_patched_ADDR_2	7523
+#define shp_2_mcu_patched_SIZE_2	104
+
+#undef  shp_2_mcu_ADDR_2
+#undef  shp_2_mcu_SIZE_2
+
+/*mapping the shp_2_mcu start address to the patched(RAM)script start address*/
+#define shp_2_mcu_ADDR_2		shp_2_mcu_patched_ADDR_2
+#define shp_2_mcu_SIZE_2		shp_2_mcu_patched_SIZE_2
+
+#define shp_2_per_ADDR_2	7627
+#define shp_2_per_SIZE_2	109
+
+#define uart_2_mcu_patched_ADDR_2	7736
+#define uart_2_mcu_patched_SIZE_2	106
+
+#undef  uart_2_mcu_ADDR_2
+#undef  uart_2_mcu_SIZE_2
+
+/*mapping the uart_2_mcu start address to the patched(RAM)script start address*/
+#define uart_2_mcu_ADDR_2		uart_2_mcu_patched_ADDR_2
+#define uart_2_mcu_SIZE_2		uart_2_mcu_patched_SIZE_2
+
+#define uartsh_2_mcu_patched_ADDR_2	7842
+#define uartsh_2_mcu_patched_SIZE_2	99
+
+#undef  uartsh_2_mcu_ADDR_2
+#undef  uartsh_2_mcu_SIZE_2
+
+/*
+ * mapping the uartsh_2_mcu start address to the patched(RAM)script
+ * start address
+ */
+#define uartsh_2_mcu_ADDR_2		uartsh_2_mcu_patched_ADDR_2
+#define uartsh_2_mcu_SIZE_2		uartsh_2_mcu_patched_SIZE_2
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_2		6144
+#define RAM_CODE_SIZE_2			1797
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code_2[] = {
+	0x0970, 0x0111, 0x5111, 0x5ef9, 0xc0ec, 0x7d23, 0x5ad1, 0x5bd9,
+	0xc0fe, 0x7c1f, 0x5ce1, 0x5de9, 0x5ef1, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x048e, 0x56f9, 0x0660, 0x7d05, 0x0661, 0x7c2b, 0x6c07,
+	0x6d13, 0x9821, 0x0661, 0x7d26, 0x6c17, 0x6d03, 0x028d, 0x058c,
+	0x048a, 0xd9f5, 0x7e08, 0x7f07, 0x54e1, 0x52d1, 0x53d9, 0xc10d,
+	0x7dde, 0x0200, 0x9804, 0x0660, 0x7d03, 0x6007, 0x52f1, 0x9832,
+	0x6003, 0x52e9, 0x00a2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x6a0c, 0x54e1, 0xc795, 0x048b, 0x0498,
+	0x0454, 0x9825, 0x0800, 0x983c, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d61, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x984a, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d45, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f3b, 0x0400, 0x985a, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d1c,
+	0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311, 0x53eb, 0x62c8,
+	0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09, 0x7f1f, 0x0212,
+	0x6a09, 0x7f1c, 0x0212, 0x6a09, 0x7f19, 0x2003, 0x4800, 0x7cef,
+	0x0b70, 0x0311, 0x5313, 0x989b, 0x0015, 0x0015, 0x7802, 0x62c8,
+	0x6a0b, 0x989a, 0x0015, 0x7802, 0x62c8, 0x6a0a, 0x989a, 0x7802,
+	0x62c8, 0x6a09, 0x7c03, 0x6a28, 0x0000, 0x9858, 0xc77b, 0x6a28,
+	0x7ffd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da2,
+	0x0200, 0x984a, 0x0200, 0x9847, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d62, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x98b2, 0x6ec3, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d46, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x62ff, 0x7e3c, 0x0400, 0x98c2, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d28,
+	0x4a02, 0x7d20, 0x4a01, 0x7d19, 0x6ddd, 0x0b70, 0x0311, 0x53eb,
+	0x62c8, 0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6ac8, 0x7f1f,
+	0x0212, 0x6ac8, 0x7f1c, 0x0212, 0x6ac8, 0x7f19, 0x2003, 0x4800,
+	0x7cef, 0x0b70, 0x0311, 0x5313, 0x9905, 0x6ddd, 0x7802, 0x62c8,
+	0x6ac8, 0x9904, 0x6dde, 0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9904,
+	0x0015, 0x0015, 0x7801, 0x62d8, 0x7c02, 0x0000, 0x98c0, 0xc777,
+	0x62ff, 0x7efd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d,
+	0x7da1, 0x0200, 0x98b2, 0x0200, 0x98af, 0xc19d, 0xc0ec, 0x7d69,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x991e, 0x6d07, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70,
+	0x0211, 0x552a, 0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9,
+	0x4d00, 0x7c13, 0x6928, 0x7f2d, 0x0400, 0x992f, 0x008f, 0x0015,
+	0x04d8, 0x7d01, 0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b,
+	0x7e29, 0x6d28, 0x7f1e, 0x0000, 0x992d, 0x1e20, 0x5506, 0x2620,
+	0x008d, 0x0560, 0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a,
+	0x7f10, 0x4c00, 0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000,
+	0x9976, 0x0007, 0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28,
+	0x0007, 0x680c, 0x0007, 0x54d2, 0x0454, 0x9979, 0x6928, 0x7ff1,
+	0x54d2, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200,
+	0x991e, 0x0200, 0x9916, 0x1e10, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x998a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70, 0x0311,
+	0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9999, 0x0212, 0x3aff,
+	0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8, 0xd9d4,
+	0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xd9ec, 0x52c0, 0x53c8,
+	0xc10d, 0x7dd0, 0x0200, 0x998a, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0xd9d4, 0x9997, 0x0200, 0x9987, 0x0007, 0x68cc, 0x6a28, 0x7f01,
+	0x99d2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b, 0x6a28,
+	0x0007, 0x680c, 0x0454, 0x99b0, 0x05a0, 0x1e08, 0x6ec3, 0x0388,
+	0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5, 0x6a28,
+	0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09, 0x7edc,
+	0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5, 0x0dff,
+	0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0388, 0x028d, 0x3a03,
+	0x4a00, 0x7c33, 0x028c, 0x3a03, 0x4a00, 0x7d0c, 0x0804, 0x00a2,
+	0x00db, 0x7d24, 0x03a0, 0x0498, 0x7802, 0x6209, 0x6a29, 0x7e24,
+	0x620c, 0x7e22, 0x0804, 0x03d0, 0x7d19, 0x0820, 0x028c, 0x3a1f,
+	0x00a2, 0x03d0, 0x7c02, 0x008b, 0x3003, 0x03a0, 0x0015, 0x0015,
+	0x6818, 0x7e12, 0x6828, 0x7f10, 0x0000, 0x0820, 0x03d8, 0x7df5,
+	0x0804, 0x03d0, 0x7d03, 0x008b, 0x3003, 0x9a15, 0x008b, 0x7802,
+	0x6209, 0x6a29, 0x7e01, 0x620c, 0x0006, 0x0804, 0x03d0, 0x7df6,
+	0x048b, 0x3403, 0x03a4, 0x0415, 0x0415, 0x0d0f, 0x0511, 0x1df0,
+	0x0808, 0x04d0, 0x7c01, 0x008c, 0x58c1, 0x04a0, 0x7803, 0x620b,
+	0x5a05, 0x1d01, 0x7ee9, 0x50c1, 0x05a0, 0x7803, 0x5205, 0x6a0b,
+	0x1d01, 0x6a28, 0x7fe1, 0x0000, 0x4c00, 0x7ce7, 0x9a26, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d7a, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9a55, 0x6d03, 0x6ed3, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b,
+	0x5313, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9a65,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512,
+	0x05bc, 0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01,
+	0x7d1a, 0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25,
+	0x620a, 0x7e23, 0x9a8f, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512,
+	0x0512, 0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70,
+	0x0311, 0x5313, 0x9aaa, 0x7802, 0x6209, 0x6ac8, 0x9aa9, 0x0015,
+	0x7802, 0x620a, 0x6ac8, 0x9aa9, 0x0015, 0x0015, 0x7802, 0x620b,
+	0x6ac8, 0x7c03, 0x0000, 0x55db, 0x9a63, 0x0007, 0x68cc, 0x680c,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9ab8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d89, 0x0200, 0x9a55, 0x0200, 0x9a52,
+	0xc19d, 0xc0ec, 0x7d52, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c,
+	0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9ad9, 0x6d03,
+	0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da,
+	0x0a70, 0x0211, 0x4c00, 0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02,
+	0x0400, 0x9aec, 0x4c01, 0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x0020, 0x04a0, 0x0015, 0x7802, 0x650b, 0x5d06, 0x0000,
+	0x7e0c, 0x7f0d, 0x9aea, 0x650a, 0x7e08, 0x008d, 0x0011, 0x0010,
+	0x05a8, 0x065f, 0x5d06, 0x063f, 0x7f02, 0x0007, 0x680c, 0x0007,
+	0x5012, 0x54d0, 0x0454, 0x9b16, 0x5012, 0x54d0, 0x0473, 0x7c06,
+	0x552a, 0x05b9, 0x4d00, 0x7c02, 0x0400, 0x9b18, 0x52c0, 0x53c8,
+	0xc10d, 0x0288, 0x7db6, 0x0200, 0x9ad9, 0x0200, 0x9ad1, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9b2d, 0x0b70, 0x0311, 0x6ed3, 0x6d03,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x62c8, 0x7e1f, 0x0400, 0x9b3e, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16,
+	0x6ac8, 0x7f11, 0x0015, 0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e,
+	0x6ac8, 0x7f09, 0x6edf, 0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000,
+	0x7e05, 0x7f01, 0x9b3c, 0x0007, 0x68cc, 0x9b68, 0x0007, 0x6a0c,
+	0x0454, 0x62c8, 0x7ef8, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd,
+	0x0200, 0x9b2d, 0x0200, 0x9b2a, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9b7b, 0x0870, 0x0011, 0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9b8a,
+	0x620b, 0x7e06, 0x5a06, 0x7f06, 0x0000, 0x2504, 0x7d05, 0x9b8a,
+	0x0007, 0x680c, 0x0007, 0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb,
+	0x0200, 0x9b7b, 0x0200, 0x9b77, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d76, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9bab, 0x6d03, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70,
+	0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9bbf,
+	0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00,
+	0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea,
+	0x0260, 0x7d05, 0x6509, 0x7e25, 0x630a, 0x7e23, 0x9be3, 0x630a,
+	0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19,
+	0x2003, 0x4800, 0x7ced, 0x0a70, 0x0211, 0x5212, 0x9bfe, 0x7802,
+	0x6309, 0x5b06, 0x9bfd, 0x0015, 0x7802, 0x630a, 0x5b06, 0x9bfd,
+	0x0015, 0x0015, 0x7802, 0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000,
+	0x9bbd, 0x0007, 0x680c, 0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02,
+	0x9c0b, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff,
+	0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454, 0x0870, 0x0011,
+	0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d8e, 0x0200, 0x9bab, 0x0200,
+	0x9ba7, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9c28, 0x0870, 0x0011,
+	0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c, 0x5228,
+	0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9c37, 0x5206,
+	0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9c37,
+	0x0007, 0x680c, 0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007,
+	0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0, 0xc10d,
+	0x7dcf, 0x0200, 0x9c28, 0x0200, 0x9c24, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d7c, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9c63, 0x6ed3, 0x6dc5, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d60, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9,
+	0x4a00, 0x7c02, 0x0400, 0x9c73, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd3, 0x4d00,
+	0x7d2c, 0x4d02, 0x7d24, 0x4d01, 0x7d1e, 0x59e3, 0x0b70, 0x0311,
+	0x53eb, 0x61c8, 0x7e2b, 0x62c8, 0x7e29, 0x65c8, 0x7e27, 0x0360,
+	0x7d03, 0x0112, 0x0112, 0x9c9e, 0x0512, 0x0512, 0x0211, 0x02a9,
+	0x02ad, 0x6ac8, 0x7f1b, 0x2003, 0x4800, 0x7ceb, 0x0b70, 0x0311,
+	0x5313, 0x51e3, 0x9cbb, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dce,
+	0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dcf, 0x0015, 0x0015,
+	0x7801, 0x62d8, 0x7c03, 0x0000, 0x55db, 0x9c71, 0x0007, 0x68ff,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9cc8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62c8, 0x7ee9, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d87, 0x0200, 0x9c63, 0x0200, 0x9c60,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d7c, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ce7, 0x6dc5, 0x0d03,
+	0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d5d, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9,
+	0x4b00, 0x7c02, 0x0400, 0x9cfb, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d2c, 0x4d02, 0x7d24, 0x4d01,
+	0x7d1e, 0x59e2, 0x0a70, 0x0211, 0x52ea, 0x61c8, 0x7e2c, 0x63c8,
+	0x7e2a, 0x65c8, 0x7e28, 0x0260, 0x7d03, 0x0112, 0x0112, 0x9d22,
+	0x0512, 0x0512, 0x0311, 0x03a9, 0x03ad, 0x5b06, 0x7f1c, 0x2003,
+	0x4800, 0x7ceb, 0x0a70, 0x0211, 0x5212, 0x51e2, 0x9d40, 0x7802,
+	0x63c8, 0x5b06, 0x9d3f, 0x6dce, 0x0015, 0x7802, 0x63c8, 0x5b06,
+	0x9d3f, 0x6dcf, 0x0015, 0x0015, 0x7802, 0x63c8, 0x5b06, 0x7c03,
+	0x55da, 0x0000, 0x9cf9, 0x0007, 0x68ff, 0x55d2, 0x4d00, 0x7d03,
+	0x4d02, 0x7d02, 0x9d4d, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa,
+	0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d88, 0x0200,
+	0x9ce7, 0x0200, 0x9ce3, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d61,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d6a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d45, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04,
+	0x6a28, 0x7f3b, 0x0400, 0x9d79, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x0b03, 0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02,
+	0x7d20, 0x4b01, 0x7d23, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e25,
+	0x0260, 0x7d02, 0x0310, 0x0312, 0x6b09, 0x7f1f, 0x0312, 0x6b09,
+	0x7f1c, 0x0312, 0x6b09, 0x7f19, 0x2003, 0x4800, 0x7cef, 0x0a70,
+	0x0211, 0x5212, 0x9dba, 0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b,
+	0x9db9, 0x0015, 0x7802, 0x5306, 0x6b0a, 0x9db9, 0x7802, 0x5306,
+	0x6b09, 0x7c03, 0x6b28, 0x0000, 0x9d77, 0xc77b, 0x6928, 0x7ffd,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da3, 0x0200,
+	0x9d6a, 0x0200, 0x9d66, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d60,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9dd2, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d46, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02,
+	0x0400, 0x9de1, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03,
+	0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d28, 0x4b02, 0x7d20, 0x4b01,
+	0x7d19, 0x6ddd, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e27, 0x0260,
+	0x7d02, 0x0310, 0x0312, 0x6bc8, 0x7f21, 0x0312, 0x6bc8, 0x7f1e,
+	0x0312, 0x6bc8, 0x7f1b, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211,
+	0x5212, 0x9e23, 0x6ddd, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x6dde,
+	0x0015, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x0015, 0x0015, 0x7802,
+	0x5306, 0x6bc8, 0x7c03, 0x0000, 0xde32, 0x9ddf, 0xc777, 0x0870,
+	0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da4, 0x0200, 0x9dd2,
+	0x0200, 0x9dce, 0x63ff, 0x0368, 0x7d02, 0x0369, 0x7def, 0x0006,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d5c, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9e3e, 0x0b70, 0x0311, 0x6ec3,
+	0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3e,
+	0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f34, 0x0400, 0x9e50,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3,
+	0x6ed3, 0x62c8, 0x0248, 0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e,
+	0x7d32, 0x6a09, 0x7f1f, 0x2501, 0x4d00, 0x7d20, 0x028e, 0x1a98,
+	0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x6a28, 0x7f13, 0xc7af,
+	0x9e90, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x62c8, 0x026e, 0x7d18, 0x6a09, 0x7f05, 0x2001, 0x7cf9, 0x6a28,
+	0x0000, 0x9e4e, 0x0289, 0xc77b, 0x018a, 0x9e9f, 0x6a28, 0x7ffa,
+	0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7da7, 0x0200,
+	0x9e3e, 0x0200, 0x9e3b, 0x6a28, 0x7fed, 0xc7af, 0x9e9f, 0x0458,
+	0x0454, 0x9e90, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d55, 0x5010,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ea9,
+	0x0b70, 0x0311, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d37, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f2d,
+	0x0400, 0x9eba, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d16, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d2f, 0x6a09,
+	0x7f1c, 0x2501, 0x4d00, 0x7d1d, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6a28, 0x7f12, 0xc7af, 0x9ef3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d18, 0x6a09, 0x7f05,
+	0x2001, 0x7cf9, 0x6a28, 0x0000, 0x9eb8, 0x0289, 0xc77b, 0x018a,
+	0x9f02, 0x6928, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7daf, 0x0200, 0x9ea9, 0x0200, 0x9ea5, 0x6a28, 0x7fed,
+	0xc7af, 0x9f02, 0x0458, 0x0454, 0x9ef3
+};
+#endif
diff --git a/arch/arm/mach-mx3/serial.h b/arch/arm/mach-mx3/serial.h
new file mode 100644
index 0000000..b2b0a05
--- /dev/null
+++ b/arch/arm/mach-mx3/serial.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX3_SERIAL_H__
+#define __ARCH_ARM_MACH_MX3_SERIAL_H__
+
+/*!
+ * @file mach-mx3/serial.h
+ *
+ * @ingroup MSL_MX31
+ */
+#include <mach/mxc_uart.h>
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 5
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+/* UART used as wakeup source */
+#define UART1_HW_FLOW           0
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        0
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        0
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              MXC_INT_UART4
+#define UART4_INT2              -1
+#define UART4_INT3              -1
+#define UART4_SHARED_PERI       -1
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              MXC_INT_UART5
+#define UART5_INT2              -1
+#define UART5_INT3              -1
+#define UART5_SHARED_PERI       -1
+
+#endif				/* __ARCH_ARM_MACH_MX3_SERIAL_H__ */
diff --git a/arch/arm/mach-mx3/system.c b/arch/arm/mach-mx3/system.c
new file mode 100644
index 0000000..c699750
--- /dev/null
+++ b/arch/arm/mach-mx3/system.c
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX31 i.MX31 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx3/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX31
+ */
+
+static int clks_initialized;
+static struct clk *sdma_clk, *mbx_clk, *ipu_clk, *mpeg_clk, *vpu_clk, *usb_clk,
+    *rtic_clk, *nfc_clk, *emi_clk;
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void mx31_arch_idle(void)
+{
+	int emi_gated_off = 0;
+
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled) {
+		if (clks_initialized == 0) {
+			clks_initialized = 1;
+			sdma_clk = clk_get(NULL, "sdma_ahb_clk");
+			ipu_clk = clk_get(NULL, "ipu_clk");
+			if (cpu_is_mx31()) {
+				mpeg_clk = clk_get(NULL, "mpeg4_clk");
+				mbx_clk = clk_get(NULL, "mbx_clk");
+			} else {
+				vpu_clk = clk_get(NULL, "vpu_clk");
+			}
+			usb_clk = clk_get(NULL, "usb_ahb_clk");
+			rtic_clk = clk_get(NULL, "rtic_clk");
+			nfc_clk = clk_get(NULL, "nfc_clk");
+			emi_clk = clk_get(NULL, "emi_clk");
+		}
+
+		if ((clk_get_usecount(sdma_clk) == 0)
+		    && (clk_get_usecount(ipu_clk) <= 1)
+		    && (clk_get_usecount(usb_clk) == 0)
+		    && (clk_get_usecount(rtic_clk) == 0)
+		    && (clk_get_usecount(mpeg_clk) == 0)
+		    && (clk_get_usecount(mbx_clk) == 0)
+		    && (clk_get_usecount(nfc_clk) == 0)
+		    && (clk_get_usecount(vpu_clk) == 0)) {
+			emi_gated_off = 1;
+			clk_disable(emi_clk);
+		}
+
+		cpu_do_idle();
+		if (emi_gated_off == 1)
+			clk_enable(emi_clk);
+	}
+}
diff --git a/arch/arm/mach-mx3/usb.h b/arch/arm/mach-mx3/usb.h
new file mode 100644
index 0000000..5a71703
--- /dev/null
+++ b/arch/arm/mach-mx3/usb.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_fs_active(void);
+extern void gpio_usbotg_fs_inactive(void);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh1_active(void);
+extern void gpio_usbh1_inactive(void);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+#if defined(CONFIG_ISP1504_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1504_config;
+#define PDATA (&dr_1504_config)
+#elif defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config;
+#define PDATA (&dr_1301_config)
+#elif defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config;
+#define PDATA (&dr_13783_config)
+#endif
+
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx3/usb_dr.c b/arch/arm/mach-mx3/usb_dr.c
new file mode 100644
index 0000000..a204150
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_dr.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable);
+
+/*
+ * platform data structs
+ * - Which one to use is determined by CONFIG options in usb.h
+ * - operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "mc13783",
+};
+
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "isp1301",
+};
+
+static struct fsl_usb2_platform_data __maybe_unused dr_1504_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.wake_up_enable = _wake_up_enable,
+	.transceiver       = "isp1504",
+};
+
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * dev.platform_data field plugged at run time
+ */
+static struct platform_device __maybe_unused dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (get_usb_mode(pdata) == FSL_USB_DR_DEVICE) {
+		if (enable) {
+			USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+			USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+				   UCTRL_OWIE |	/* OTG wakeup intr enable */
+				   UCTRL_OPM;	/* power mask */
+		} else {
+			USBCTRL &= ~UCTRL_OWIE;
+		}
+	} else {
+		if (enable) {
+			USBCTRL &= ~UCTRL_OSIC_MASK;
+			USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+			USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+				   UCTRL_OWIE |	/* OTG wakeup intr enable */
+				   UCTRL_OPM;	/* power mask */
+		} else {
+			USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+			USBCTRL &= ~UCTRL_OWIE;
+		}
+	}
+}
+
+static int __init usb_dr_init(void)
+{
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+#ifdef CONFIG_USB_GADGET_WAKE_UP
+	/* set udc may and should wakeup */
+	device_init_wakeup(&(dr_udc_device.dev), 1);
+#endif
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx3/usb_h1.c b/arch/arm/mach-mx3/usb_h1.c
new file mode 100644
index 0000000..ac48af2
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_h1.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name              = "Host 1",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbh1_active,
+	.gpio_usb_inactive = gpio_usbh1_inactive,
+	.transceiver       = "serial",
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+		.start = (u32) (USB_H1REGS_BASE),
+		.end   = (u32) (USB_H1REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int __init usbh1_init(void)
+{
+	host_pdev_register(usbh1_resources, ARRAY_SIZE(usbh1_resources),
+			   &usbh1_config);
+	return 0;
+}
+module_init(usbh1_init);
diff --git a/arch/arm/mach-mx3/usb_h2.c b/arch/arm/mach-mx3/usb_h2.c
new file mode 100644
index 0000000..e06c3ae
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_h2.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <asm/mach-types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "isp1504",
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int __init usbh2_init(void)
+{
+	if (machine_is_mx31_3ds()) {
+		struct regulator *usbh2_regux;
+		usbh2_config.xcvr_pwr =
+			kmalloc(sizeof(struct fsl_xcvr_power), GFP_KERNEL);
+		if (!(usbh2_config.xcvr_pwr))
+			return -ENOMEM;
+
+		usbh2_regux = regulator_get(NULL, "GPO1");
+		usbh2_config.xcvr_pwr->regu1 = usbh2_regux;
+		usbh2_regux = regulator_get(NULL, "GPO3");
+		usbh2_config.xcvr_pwr->regu2 = usbh2_regux;
+	}
+
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+module_init(usbh2_init);
-- 
1.6.5.2

