From 130bc467a21c8b1febdae50c9a6ebef5a8a41fae Mon Sep 17 00:00:00 2001
From: Alexander Smirnov <asmirnov@embeddedalley.com>
Date: Wed, 17 Dec 2008 20:27:48 +0300
Subject: [PATCH] Add a MX2/MX3 specific SDHC driver

This patch adds a MX2/MX3 specific SDHC driver. The hardware is basically
the same as in the MX1, but unlike the MX1 controller the MX2
controller just works as expected. Since the MX1 driver has more
workarounds for bugs than anything else I had no success with supporting
MX1 and MX2 in a sane way in one driver.

Merged from ARM-list.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

i.MX5 series supports enhanced SD host controller Version 2. This
driver can fully support eSDHC controller functions to support MMC/
SD/SDIO/CE-ATA card.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Alexander Smirnov <asmirnov@embeddedalley.com>
---
 arch/arm/plat-mxc/include/mach/mmc.h |   33 +
 drivers/mmc/host/Kconfig             |   38 +
 drivers/mmc/host/Makefile            |    2 +
 drivers/mmc/host/mx_sdhci.c          | 2094 ++++++++++++++++++++++++++++++++++
 drivers/mmc/host/mx_sdhci.h          |  273 +++++
 drivers/mmc/host/mxcmmc.c            |  881 ++++++++++++++
 6 files changed, 3321 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/mmc.h
 create mode 100644 drivers/mmc/host/mx_sdhci.c
 create mode 100644 drivers/mmc/host/mx_sdhci.h
 create mode 100644 drivers/mmc/host/mxcmmc.c

diff --git a/arch/arm/plat-mxc/include/mach/mmc.h b/arch/arm/plat-mxc/include/mach/mmc.h
new file mode 100644
index 0000000..9007ad8
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mmc.h
@@ -0,0 +1,33 @@
+#ifndef ASMARM_ARCH_MMC_H
+#define ASMARM_ARCH_MMC_H
+
+#include <linux/mmc/host.h>
+
+struct device;
+
+struct imxmmc_platform_data {
+	int (*get_ro)(struct device *);
+	int (*init)(struct device *, irq_handler_t, void *);
+	void (*exit)(struct device *, void *);
+	void (*setpower)(struct device *, unsigned int vdd);
+};
+
+extern void imx_set_mmc_info(struct imxmmc_platform_data *info);
+
+struct mxc_mmc_platform_data {
+	unsigned int ocr_mask;	/* available voltages */
+	unsigned int vendor_ver;
+	unsigned int caps;
+	unsigned int min_clk;
+	unsigned int max_clk;
+	unsigned int clk_flg;	/* 1 clock enable, 0 not */
+	unsigned int reserved:16;
+	unsigned int card_fixed:1;
+	unsigned int card_inserted_state:1;
+	unsigned int (*status) (struct device *);
+	int (*wp_status) (struct device *);
+	char *power_mmc;
+	char *clock_mmc;
+};
+
+#endif
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 6130230..7476837 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -144,6 +144,44 @@ config MMC_IMX
 
 	  If unsure, say N.
 
+config MMC_MXC
+	tristate "Freescale i.MX2/3 Multimedia Card Interface support"
+	depends on ARCH_MXC
+	help
+	  This selects the Freescale i.MX2/3 Multimedia card Interface.
+	  If you have a i.MX platform with a Multimedia Card slot,
+	  say Y or M here.
+
+	  If unsure, say N.
+config MMC_IMX_ESDHCI
+	tristate "Freescale i.MX Secure Digital Host Controller support"
+	depends on ARCH_MXC && MMC
+	help
+	  This selects the Freescale i.MX Multimedia card Interface.
+	  If you have a i.MX platform with a Multimedia Card slot,
+	  say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_IMX_ESDHCI_SELECT2
+	bool "Enable second ESDHCI port"
+	depends on MMC_IMX_ESDHCI && ARCH_MX25
+	default n
+	help
+	  Enable the second ESDHC port
+
+config MMC_IMX_ESDHCI_PIO_MODE
+	bool "Freescale i.MX Secure Digital Host Controller Interface PIO mode"
+	depends on MMC_IMX_ESDHC != n
+	default n
+	help
+	  This sets the Freescale i.MX Multimedia card Interface to PIO mode.
+	  If you have a i.MX platform with a Multimedia Card slot,
+	  and want test it with PIO mode.
+	  say Y here.
+
+	  If unsure, say N.
+
 config MMC_TIFM_SD
 	tristate "TI Flash Media MMC/SD Interface support  (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && PCI
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 0c34ca6..abb2d4a 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -9,6 +9,7 @@ endif
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
+obj-$(CONFIG_MMC_MXC)		+= mxcmmc.o
 obj-$(CONFIG_MMC_SDHCI)		+= sdhci.o
 obj-$(CONFIG_MMC_SDHCI_PCI)	+= sdhci-pci.o
 obj-$(CONFIG_MMC_RICOH_MMC)	+= ricoh_mmc.o
@@ -24,4 +25,5 @@ obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
 obj-$(CONFIG_MMC_DAVINCI)       += davinci_mmc.o
+obj-$(CONFIG_MMC_IMX_ESDHCI)	+= mx_sdhci.o
 
diff --git a/drivers/mmc/host/mx_sdhci.c b/drivers/mmc/host/mx_sdhci.c
new file mode 100644
index 0000000..4836ff5
--- /dev/null
+++ b/drivers/mmc/host/mx_sdhci.c
@@ -0,0 +1,2094 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx_sdhci.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC eSDHC modules.
+ *
+ * This driver code is based on sdhci.c, by Pierre Ossman <drzeus@drzeus.cx>");
+ * This driver supports Enhanced Secure Digital Host Controller
+ * modules eSDHC of MXC. eSDHC is also referred as enhanced MMC/SD
+ * controller.
+ *
+ * @ingroup MMC_SD
+ */
+
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include <linux/leds.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+#include <mach/mmc.h>
+#include <mach/common.h>
+
+#include "mx_sdhci.h"
+
+#define DRIVER_NAME "mxsdhci"
+
+#define DBG(f, x...) \
+	pr_debug(DRIVER_NAME " [%s()]: " f, __func__, ## x)
+
+#define MMC_BUS_WIDTH_8	3
+
+static unsigned int debug_quirks;
+static int last_op_dir;
+
+/*
+ * Different quirks to handle when the hardware deviates from a strict
+ * interpretation of the SDHCI specification.
+ */
+
+/* Controller doesn't honor resets unless we touch the clock register */
+#define SDHCI_QUIRK_CLOCK_BEFORE_RESET			(1<<0)
+/* Controller has bad caps bits, but really supports DMA */
+#define SDHCI_QUIRK_FORCE_DMA				(1<<1)
+/* Controller doesn't like to be reset when there is no card inserted. */
+#define SDHCI_QUIRK_NO_CARD_NO_RESET			(1<<2)
+/* Controller doesn't like clearing the power reg before a change */
+#define SDHCI_QUIRK_SINGLE_POWER_WRITE			(1<<3)
+/* Controller has flaky internal state so reset it on each ios change */
+#define SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS		(1<<4)
+/* Controller has an unusable DMA engine */
+#define SDHCI_QUIRK_BROKEN_DMA				(1<<5)
+/* Controller can only DMA from 32-bit aligned addresses */
+#define SDHCI_QUIRK_32BIT_DMA_ADDR			(1<<6)
+/* Controller can only DMA chunk sizes that are a multiple of 32 bits */
+#define SDHCI_QUIRK_32BIT_DMA_SIZE			(1<<7)
+/* Controller needs to be reset after each request to stay stable */
+#define SDHCI_QUIRK_RESET_AFTER_REQUEST			(1<<8)
+/* Controller needs voltage and power writes to happen separately */
+#define SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER		(1<<9)
+/* Controller has an off-by-one issue with timeout value */
+#define SDHCI_QUIRK_INCR_TIMEOUT_CONTROL		(1<<10)
+/* Controller only support the PIO */
+#define SDHCI_QUIRK_ONLY_PIO 				(1<<16)
+/* Controller support the External DMA */
+#define SDHCI_QUIRK_EXTERNAL_DMA_MODE			(1<<17)
+/* Controller support the Internal Simple DMA */
+#define SDHCI_QUIRK_INTERNAL_SIMPLE_DMA			(1<<18)
+/* Controller support the Internal Advanced DMA */
+#define SDHCI_QUIRK_INTERNAL_ADVANCED_DMA 		(1<<19)
+
+/*
+ * defines the mxc flags refer to the special hw pre-conditons and behavior
+ */
+static unsigned int mxc_quirks;
+#ifdef CONFIG_MMC_IMX_ESDHCI_PIO_MODE
+static unsigned int debug_quirks = SDHCI_QUIRK_ONLY_PIO;
+#else
+static unsigned int debug_quirks;
+#endif
+static unsigned int mxc_wml_value = 512;
+static unsigned int *adma_des_table;
+
+#ifndef MXC_SDHCI_NUM
+#define MXC_SDHCI_NUM	4
+#endif
+
+static struct sdhci_chip *mxc_fix_chips[MXC_SDHCI_NUM];
+
+static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
+static void sdhci_finish_data(struct sdhci_host *);
+
+static void sdhci_send_command(struct sdhci_host *, struct mmc_command *);
+static void sdhci_finish_command(struct sdhci_host *);
+
+/* Used to active the SD bus */
+extern void gpio_sdhc_active(int module);
+extern void gpio_sdhc_inactive(int module);
+static void sdhci_dma_irq(void *devid, int error, unsigned int cnt);
+
+void mxc_mmc_force_detect(int id)
+{
+	struct sdhci_host *host;
+	if ((id < 0) || (id >= MXC_SDHCI_NUM))
+		return;
+	if (!mxc_fix_chips[id])
+		return;
+	host = mxc_fix_chips[id]->hosts[0];
+	if (host->detect_irq)
+		return;
+
+	schedule_work(&host->cd_wq);
+	return;
+}
+
+EXPORT_SYMBOL(mxc_mmc_force_detect);
+
+static void sdhci_dumpregs(struct sdhci_host *host)
+{
+	printk(KERN_DEBUG DRIVER_NAME
+	       ": ============== REGISTER DUMP ==============\n");
+
+	printk(KERN_DEBUG DRIVER_NAME ": Sys addr: 0x%08x | Version:  0x%08x\n",
+	       readl(host->ioaddr + SDHCI_DMA_ADDRESS),
+	       readl(host->ioaddr + SDHCI_HOST_VERSION));
+	printk(KERN_DEBUG DRIVER_NAME ": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
+	       (readl(host->ioaddr + SDHCI_BLOCK_SIZE) & 0xFFFF),
+	       (readl(host->ioaddr + SDHCI_BLOCK_COUNT) >> 16));
+	printk(KERN_DEBUG DRIVER_NAME ": Argument: 0x%08x | Trn mode: 0x%08x\n",
+	       readl(host->ioaddr + SDHCI_ARGUMENT),
+	       readl(host->ioaddr + SDHCI_TRANSFER_MODE));
+	printk(KERN_DEBUG DRIVER_NAME ": Present:  0x%08x | Host ctl: 0x%08x\n",
+	       readl(host->ioaddr + SDHCI_PRESENT_STATE),
+	       readl(host->ioaddr + SDHCI_HOST_CONTROL));
+	printk(KERN_DEBUG DRIVER_NAME ": Clock:    0x%08x\n",
+	       readl(host->ioaddr + SDHCI_CLOCK_CONTROL));
+	printk(KERN_DEBUG DRIVER_NAME ": Int stat: 0x%08x\n",
+	       readl(host->ioaddr + SDHCI_INT_STATUS));
+	printk(KERN_DEBUG DRIVER_NAME ": Int enab: 0x%08x | Sig enab: 0x%08x\n",
+	       readl(host->ioaddr + SDHCI_INT_ENABLE),
+	       readl(host->ioaddr + SDHCI_SIGNAL_ENABLE));
+	printk(KERN_DEBUG DRIVER_NAME ": Caps:     0x%08x\n",
+	       readl(host->ioaddr + SDHCI_CAPABILITIES));
+
+	printk(KERN_DEBUG DRIVER_NAME
+	       ": ===========================================\n");
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * Low level functions                                                       *
+ *                                                                           *
+\*****************************************************************************/
+
+static void sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	unsigned long tmp;
+	unsigned long mask_u32;
+	unsigned long reg_save = 0;
+
+	if (host->chip->quirks & SDHCI_QUIRK_NO_CARD_NO_RESET) {
+		if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) &
+		      SDHCI_CARD_PRESENT))
+			return;
+	}
+
+	if (mask & SDHCI_RESET_ALL)
+		host->clock = 0;
+	else if (host->flags & SDHCI_CD_PRESENT)
+		reg_save = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+
+	tmp = readl(host->ioaddr + SDHCI_CLOCK_CONTROL) | (mask << 24);
+	mask_u32 = readl(host->ioaddr + SDHCI_SIGNAL_ENABLE);
+	writel(tmp, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 100 ms */
+	tmp = 5000;
+
+	/* hw clears the bit when it's done */
+	while ((readl(host->ioaddr + SDHCI_CLOCK_CONTROL) >> 24) & mask) {
+		if (tmp == 0) {
+			printk(KERN_ERR "%s: Reset 0x%x never completed.\n",
+			       mmc_hostname(host->mmc), (int)mask);
+			sdhci_dumpregs(host);
+			return;
+		}
+		tmp--;
+		udelay(20);
+	}
+	/*
+	 * The INT_EN SIG_EN regs have been modified after reset.
+	 * re-configure them ag.
+	 */
+	if (!(mask & SDHCI_RESET_ALL) && (host->flags & SDHCI_CD_PRESENT))
+		writel(reg_save, host->ioaddr + SDHCI_HOST_CONTROL);
+	if (host->flags & SDHCI_USE_DMA)
+		mask_u32 &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
+	if (mxc_wml_value == 512)
+		writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	else
+		writel(SDHCI_WML_16_WORDS, host->ioaddr + SDHCI_WML);
+	writel(mask_u32 | SDHCI_INT_CARD_INT, host->ioaddr + SDHCI_INT_ENABLE);
+	writel(mask_u32, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+	last_op_dir = 0;
+}
+
+static void sdhci_init(struct sdhci_host *host)
+{
+	u32 intmask;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	intmask = SDHCI_INT_ADMA_ERROR |
+	    SDHCI_INT_DATA_END_BIT | SDHCI_INT_DATA_CRC |
+	    SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
+	    SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
+	    SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL |
+	    SDHCI_INT_DMA_END | SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE;
+
+	if (host->flags & SDHCI_USE_DMA)
+		intmask &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
+	/* Configure the WML rege */
+	if (mxc_wml_value == 512)
+		writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	else
+		writel(SDHCI_WML_16_WORDS, host->ioaddr + SDHCI_WML);
+	writel(intmask | SDHCI_INT_CARD_INT, host->ioaddr + SDHCI_INT_ENABLE);
+	writel(intmask, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+}
+
+static void sdhci_activate_led(struct sdhci_host *host)
+{
+	u32 ctrl;
+
+	ctrl = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+	ctrl |= SDHCI_CTRL_LED;
+	writel(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
+}
+
+static void sdhci_deactivate_led(struct sdhci_host *host)
+{
+	u32 ctrl;
+
+	ctrl = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_LED;
+	writel(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * Core functions                                                            *
+ *                                                                           *
+\*****************************************************************************/
+
+static inline char *sdhci_sg_to_buffer(struct sdhci_host *host)
+{
+	return sg_virt(host->cur_sg);
+}
+
+static inline int sdhci_next_sg(struct sdhci_host *host)
+{
+	/*
+	 * Skip to next SG entry.
+	 */
+	host->cur_sg++;
+	host->num_sg--;
+
+	/*
+	 * Any entries left?
+	 */
+	if (host->num_sg > 0) {
+		host->offset = 0;
+		host->remain = host->cur_sg->length;
+	}
+
+	return host->num_sg;
+}
+
+static void sdhci_read_block_pio(struct sdhci_host *host)
+{
+	int blksize, chunk_remain;
+	u32 data;
+	char *buffer;
+	int size;
+
+	DBG("PIO reading\n");
+
+	blksize = host->data->blksz;
+	chunk_remain = 0;
+	data = 0;
+
+	buffer = sdhci_sg_to_buffer(host) + host->offset;
+
+	while (blksize) {
+		if (chunk_remain == 0) {
+			data = readl(host->ioaddr + SDHCI_BUFFER);
+			chunk_remain = min(blksize, 4);
+		}
+
+		size = min(host->remain, chunk_remain);
+
+		chunk_remain -= size;
+		blksize -= size;
+		host->offset += size;
+		host->remain -= size;
+
+		while (size) {
+			*buffer = data & 0xFF;
+			buffer++;
+			data >>= 8;
+			size--;
+		}
+
+		if (host->remain == 0) {
+			if (sdhci_next_sg(host) == 0) {
+				BUG_ON(blksize != 0);
+				return;
+			}
+			buffer = sdhci_sg_to_buffer(host);
+		}
+	}
+}
+
+static void sdhci_write_block_pio(struct sdhci_host *host)
+{
+	int blksize, chunk_remain;
+	u32 data;
+	char *buffer;
+	int bytes, size;
+
+	DBG("PIO writing\n");
+
+	blksize = host->data->blksz;
+	chunk_remain = 4;
+	data = 0;
+
+	bytes = 0;
+	buffer = sdhci_sg_to_buffer(host) + host->offset;
+
+	while (blksize) {
+		size = min(host->remain, chunk_remain);
+
+		chunk_remain -= size;
+		blksize -= size;
+		host->offset += size;
+		host->remain -= size;
+
+		while (size) {
+			data >>= 8;
+			data |= (u32) *buffer << 24;
+			buffer++;
+			size--;
+		}
+
+		if (chunk_remain == 0) {
+			writel(data, host->ioaddr + SDHCI_BUFFER);
+			chunk_remain = min(blksize, 4);
+		}
+
+		if (host->remain == 0) {
+			if (sdhci_next_sg(host) == 0) {
+				BUG_ON(blksize != 0);
+				return;
+			}
+			buffer = sdhci_sg_to_buffer(host);
+		}
+	}
+}
+
+static void sdhci_transfer_pio(struct sdhci_host *host)
+{
+	u32 mask;
+
+	BUG_ON(!host->data);
+
+	if (host->num_sg == 0)
+		return;
+
+	if (host->data->flags & MMC_DATA_READ)
+		mask = SDHCI_DATA_AVAILABLE;
+	else
+		mask = SDHCI_SPACE_AVAILABLE;
+
+	while (readl(host->ioaddr + SDHCI_PRESENT_STATE) & mask) {
+		if (host->data->flags & MMC_DATA_READ)
+			sdhci_read_block_pio(host);
+		else
+			sdhci_write_block_pio(host);
+
+		if (host->num_sg == 0)
+			break;
+	}
+
+	DBG("PIO transfer complete.\n");
+}
+
+static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
+{
+	u32 count;
+	unsigned target_timeout, current_timeout;
+
+	WARN_ON(host->data);
+
+	if (data == NULL)
+		return;
+
+	/* Sanity checks */
+	BUG_ON(data->blksz * data->blocks > 524288);
+	BUG_ON(data->blksz > host->mmc->max_blk_size);
+	BUG_ON(data->blocks > 65535);
+
+	host->data = data;
+	host->data_early = 0;
+	if (host->data->flags & MMC_DATA_READ)
+		writel(readl(host->ioaddr + SDHCI_CLOCK_CONTROL) |
+		       SDHCI_CLOCK_HLK_EN, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* timeout in us */
+	target_timeout = data->timeout_ns / 1000 +
+	    data->timeout_clks / host->clock;
+
+	/*
+	 * Figure out needed cycles.
+	 * We do this in steps in order to fit inside a 32 bit int.
+	 * The first step is the minimum timeout, which will have a
+	 * minimum resolution of 6 bits:
+	 * (1) 2^13*1000 > 2^22,
+	 * (2) host->timeout_clk < 2^16
+	 *     =>
+	 *     (1) / (2) > 2^6
+	 */
+	count = 0;
+	current_timeout = (1 << 13) * 1000 / host->timeout_clk;
+	while (current_timeout < target_timeout) {
+		count++;
+		current_timeout <<= 1;
+		if (count >= 0xF)
+			break;
+	}
+
+	/*
+	 * Compensate for an off-by-one error in the CaFe hardware; otherwise,
+	 * a too-small count gives us interrupt timeouts.
+	 */
+	if ((host->chip->quirks & SDHCI_QUIRK_INCR_TIMEOUT_CONTROL))
+		count++;
+
+	if (count >= 0xF) {
+		DBG(KERN_WARNING "%s: Too large timeout requested!\n",
+		    mmc_hostname(host->mmc));
+		count = 0xE;
+	}
+
+	/* Set the max time-out value to level up the compatibility */
+	count = 0xE;
+
+	count =
+	    (count << 16) | (readl(host->ioaddr + SDHCI_CLOCK_CONTROL) &
+			     0xFFF0FFFF);
+	writel(count, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	if (host->flags & SDHCI_USE_DMA)
+		host->flags |= SDHCI_REQ_USE_DMA;
+
+	if (unlikely((host->flags & SDHCI_REQ_USE_DMA) &&
+		     (host->chip->quirks & SDHCI_QUIRK_32BIT_DMA_SIZE) &&
+		     ((data->blksz * data->blocks) & 0x3))) {
+		DBG("Reverting to PIO because of transfer size (%d)\n",
+		    data->blksz * data->blocks);
+		host->flags &= ~SDHCI_REQ_USE_DMA;
+	}
+
+	/*
+	 * The assumption here being that alignment is the same after
+	 * translation to device address space.
+	 */
+	if (unlikely((host->flags & SDHCI_REQ_USE_DMA) &&
+		     (host->chip->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+		     (data->sg->offset & 0x3))) {
+		DBG("Reverting to PIO because of bad alignment\n");
+		host->flags &= ~SDHCI_REQ_USE_DMA;
+	}
+
+	if (host->flags & SDHCI_REQ_USE_DMA) {
+		int i;
+		struct scatterlist *tsg;
+
+		DBG("Configure the sg DMA, %s, len is 0x%x\n",
+		    (data->flags & MMC_DATA_READ)
+		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE", data->sg_len);
+		count =
+		    dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+			       (data->
+				flags & MMC_DATA_READ) ? DMA_FROM_DEVICE :
+			       DMA_TO_DEVICE);
+		BUG_ON(count != data->sg_len);
+
+		/* Make sure the ADMA mode is selected. */
+		i = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+		i |= SDHCI_CTRL_ADMA;
+		writel(i, host->ioaddr + SDHCI_HOST_CONTROL);
+
+		tsg = data->sg;
+		/* ADMA mode is used, create the descriptor table */
+		for (i = 0; i < count; i++) {
+			if (tsg->dma_address & 0xFFF) {
+				DBG(KERN_ERR "ADMA addr isn't 4K aligned.\n");
+				DBG(KERN_ERR "0x%x\n", tsg->dma_address);
+				DBG(KERN_ERR "Changed to Single DMA mode.\n");
+				goto Single_DMA;
+			}
+			adma_des_table[2 * i] = tsg->length << 12;
+			adma_des_table[2 * i] |= FSL_ADMA_DES_ATTR_SET;
+			adma_des_table[2 * i] |= FSL_ADMA_DES_ATTR_VALID;
+			adma_des_table[2 * i + 1] = tsg->dma_address;
+			adma_des_table[2 * i + 1] |= FSL_ADMA_DES_ATTR_TRAN;
+			adma_des_table[2 * i + 1] |= FSL_ADMA_DES_ATTR_VALID;
+			if (count == (i + 1))
+				adma_des_table[2 * i + 1] |=
+				    FSL_ADMA_DES_ATTR_END;
+			tsg++;
+		}
+
+		/* Write the physical address to ADMA address reg */
+		writel(virt_to_phys(adma_des_table),
+		       host->ioaddr + SDHCI_ADMA_ADDRESS);
+	      Single_DMA:
+		/* Rollback to the Single DMA mode */
+		i = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+		i &= ~SDHCI_CTRL_ADMA;
+		writel(i, host->ioaddr + SDHCI_HOST_CONTROL);
+		/* Single DMA mode is used */
+		writel(sg_dma_address(data->sg),
+		       host->ioaddr + SDHCI_DMA_ADDRESS);
+	} else if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+		   (data->blocks * data->blksz >= mxc_wml_value)) {
+		host->dma_size = data->blocks * data->blksz;
+		DBG("Configure the External DMA, %s, len is 0x%x\n",
+		    (data->flags & MMC_DATA_READ)
+		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE", host->dma_size);
+
+		if (data->blksz & 0x3) {
+			printk(KERN_ERR
+			       "mxc_mci: block size not multiple of 4 bytes\n");
+		}
+
+		if (data->flags & MMC_DATA_READ)
+			host->dma_dir = DMA_FROM_DEVICE;
+		else
+			host->dma_dir = DMA_TO_DEVICE;
+
+		host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+					   data->sg_len, host->dma_dir);
+
+		if (data->flags & MMC_DATA_READ) {
+			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
+					  host->dma_size, MXC_DMA_MODE_READ);
+		} else {
+			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
+					  host->dma_size, MXC_DMA_MODE_WRITE);
+		}
+	} else {
+		host->cur_sg = data->sg;
+		host->num_sg = data->sg_len;
+
+		host->offset = 0;
+		host->remain = host->cur_sg->length;
+	}
+
+	/* We do not handle DMA boundaries, so set it to max (512 KiB) */
+	writel((data->blocks << 16) | SDHCI_MAKE_BLKSZ(7, data->blksz),
+	       host->ioaddr + SDHCI_BLOCK_SIZE);
+}
+
+static void sdhci_finish_data(struct sdhci_host *host)
+{
+	struct mmc_data *data;
+	u16 blocks;
+
+	BUG_ON(!host->data);
+
+	data = host->data;
+	host->data = NULL;
+
+	if (host->flags & SDHCI_REQ_USE_DMA) {
+		dma_unmap_sg(&(host->chip->pdev)->dev, data->sg, data->sg_len,
+			     (data->flags & MMC_DATA_READ) ? DMA_FROM_DEVICE :
+			     DMA_TO_DEVICE);
+	}
+	if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+	    (host->dma_size >= mxc_wml_value)) {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+			     host->dma_len, host->dma_dir);
+		host->dma_size = 0;
+	}
+
+	/*
+	 * Controller doesn't count down when in single block mode.
+	 */
+	if (data->blocks == 1)
+		blocks = (data->error == 0) ? 0 : 1;
+	else
+		blocks = readl(host->ioaddr + SDHCI_BLOCK_COUNT) >> 16;
+	data->bytes_xfered = data->blksz * data->blocks;
+
+	if (data->stop) {
+		/*
+		 * The controller needs a reset of internal state machines
+		 * upon error conditions.
+		 */
+		if (data->error) {
+			sdhci_reset(host, SDHCI_RESET_CMD);
+			sdhci_reset(host, SDHCI_RESET_DATA);
+		}
+
+		sdhci_send_command(host, data->stop);
+	} else
+		tasklet_schedule(&host->finish_tasklet);
+}
+
+static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
+{
+	int flags;
+	u32 mask;
+	u32 mode = 0;
+	unsigned long timeout;
+
+	DBG("sdhci_send_command 0x%x is starting...\n", cmd->opcode);
+	WARN_ON(host->cmd);
+
+	/* Wait max 10 ms */
+	timeout = 5000;
+
+	mask = SDHCI_CMD_INHIBIT;
+	if ((cmd->data != NULL) || (cmd->flags & MMC_RSP_BUSY))
+		mask |= SDHCI_DATA_INHIBIT;
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (host->mrq->data && (cmd == host->mrq->data->stop))
+		mask &= ~SDHCI_DATA_INHIBIT;
+
+	while (readl(host->ioaddr + SDHCI_PRESENT_STATE) & mask) {
+		if (timeout == 0) {
+			printk(KERN_ERR "%s: Controller never released "
+			       "inhibit bit(s).\n", mmc_hostname(host->mmc));
+			sdhci_dumpregs(host);
+			cmd->error = -EIO;
+			tasklet_schedule(&host->finish_tasklet);
+			return;
+		}
+		timeout--;
+		udelay(20);
+	}
+
+	mod_timer(&host->timer, jiffies + 10 * HZ);
+
+	host->cmd = cmd;
+
+	sdhci_prepare_data(host, cmd->data);
+
+	writel(cmd->arg, host->ioaddr + SDHCI_ARGUMENT);
+
+	/* Set up the transfer mode */
+	if (cmd->data != NULL) {
+		mode = SDHCI_TRNS_BLK_CNT_EN | SDHCI_TRNS_DPSEL;
+		if (cmd->data->blocks > 1)
+			mode |= SDHCI_TRNS_MULTI;
+		if (cmd->data->flags & MMC_DATA_READ)
+			mode |= SDHCI_TRNS_READ;
+		else
+			mode &= ~SDHCI_TRNS_READ;
+		if (host->flags & SDHCI_USE_DMA)
+			mode |= SDHCI_TRNS_DMA;
+		if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+			DBG("Prepare data completely in %s transfer mode.\n",
+			    "EXTTERNAL DMA");
+	}
+
+	if ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {
+		printk(KERN_ERR "%s: Unsupported response type!\n",
+		       mmc_hostname(host->mmc));
+		cmd->error = -EINVAL;
+		tasklet_schedule(&host->finish_tasklet);
+		return;
+	}
+
+	if (!(cmd->flags & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->flags & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->flags & MMC_RSP_BUSY)
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+	else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->flags & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->flags & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	if (cmd->data)
+		flags |= SDHCI_CMD_DATA;
+
+	mode |= SDHCI_MAKE_CMD(cmd->opcode, flags);
+	DBG("Complete sending cmd, transfer mode would be 0x%x.\n", mode);
+	writel(mode, host->ioaddr + SDHCI_TRANSFER_MODE);
+}
+
+static void sdhci_finish_command(struct sdhci_host *host)
+{
+	int i;
+
+	BUG_ON(host->cmd == NULL);
+
+	if (host->cmd->flags & MMC_RSP_PRESENT) {
+		if (host->cmd->flags & MMC_RSP_136) {
+			/* CRC is stripped so we need to do some shifting. */
+			for (i = 0; i < 4; i++) {
+				host->cmd->resp[i] = readl(host->ioaddr +
+							   SDHCI_RESPONSE + (3 -
+									     i)
+							   * 4) << 8;
+				if (i != 3)
+					host->cmd->resp[i] |=
+					    readb(host->ioaddr +
+						  SDHCI_RESPONSE + (3 - i) * 4 -
+						  1);
+			}
+		} else {
+			host->cmd->resp[0] =
+			    readl(host->ioaddr + SDHCI_RESPONSE);
+		}
+	}
+
+	host->cmd->error = 0;
+
+	if (host->data && host->data_early)
+		sdhci_finish_data(host);
+
+	if (!host->cmd->data)
+		tasklet_schedule(&host->finish_tasklet);
+
+	host->cmd = NULL;
+}
+
+static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	/*This variable holds the value of clock divider, prescaler */
+	int div = 0, prescaler = 0;
+	int clk_rate;
+	u32 clk;
+	unsigned long timeout;
+
+	if (clock == 0) {
+		goto out;
+	} else {
+		if (!host->plat_data->clk_flg) {
+			clk_enable(host->clk);
+			host->plat_data->clk_flg = 1;
+		}
+	}
+	if (clock == host->clock)
+		return;
+
+	clk_rate = clk_get_rate(host->clk);
+	clk = readl(host->ioaddr + SDHCI_CLOCK_CONTROL) & ~SDHCI_CLOCK_MASK;
+	writel(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	if (clock == host->min_clk)
+		prescaler = 16;
+	else
+		prescaler = 0;
+	while (prescaler <= 0x80) {
+		for (div = 0; div <= 0xF; div++) {
+			int x;
+			if (prescaler != 0)
+				x = (clk_rate / (div + 1)) / (prescaler * 2);
+			else
+				x = clk_rate / (div + 1);
+
+			DBG("x=%d, clock=%d %d\n", x, clock, div);
+			if (x <= clock)
+				break;
+		}
+		if (div < 0x10)
+			break;
+		if (prescaler == 0)
+			prescaler = 1;
+		else
+			prescaler <<= 1;
+	}
+	DBG("prescaler = 0x%x, divider = 0x%x\n", prescaler, div);
+	clk |= (prescaler << 8) | (div << 4);
+
+	/* Configure the clock control register */
+	clk |=
+	    (readl(host->ioaddr + SDHCI_CLOCK_CONTROL) & (~SDHCI_CLOCK_MASK));
+	if (host->plat_data->vendor_ver < ESDHC_VENDOR_V22)
+		writel(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
+	else
+		writel(clk | SDHCI_CLOCK_SD_EN,
+		       host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 10 ms */
+	timeout = 5000;
+	while (timeout > 0) {
+		timeout--;
+		udelay(20);
+	}
+
+      out:
+	host->clock = clock;
+}
+
+static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
+{
+	int voltage = 0;
+
+	/* There is no PWR CTL REG */
+	if (host->power == power)
+		return;
+
+	if (host->regulator_mmc) {
+		if (power == (unsigned short)-1) {
+			regulator_disable(host->regulator_mmc);
+			DBG("mmc power off\n");
+		} else {
+			if (power == 7)
+				voltage = 1800000;
+			else if (power >= 8)
+				voltage = 2000000 + (power - 8) * 100000;
+			regulator_set_voltage(host->regulator_mmc,
+					      voltage, voltage);
+
+			if (regulator_enable(host->regulator_mmc) == 0) {
+				DBG("mmc power on\n");
+				msleep(1);
+			}
+		}
+	}
+
+	host->power = power;
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * MMC callbacks                                                             *
+ *                                                                           *
+\*****************************************************************************/
+
+static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+
+	host = mmc_priv(mmc);
+
+	/* Enable the clock */
+	if (!host->plat_data->clk_flg) {
+		clk_enable(host->clk);
+		host->plat_data->clk_flg = 1;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	WARN_ON(host->mrq != NULL);
+
+	sdhci_activate_led(host);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 0) {
+		if (mrq->cmd && mrq->data) {
+			if (mrq->data->flags & MMC_DATA_READ)
+				last_op_dir = 1;
+			else {
+				if (last_op_dir)
+					sdhci_reset(host,
+						    SDHCI_RESET_CMD |
+						    SDHCI_RESET_DATA);
+			}
+		}
+	}
+	host->mrq = mrq;
+	if (!(host->flags & SDHCI_CD_PRESENT)) {
+		host->mrq->cmd->error = -ENOMEDIUM;
+		tasklet_schedule(&host->finish_tasklet);
+	} else
+		sdhci_send_command(host, mrq->cmd);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmiowb();
+}
+
+static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+	u32 tmp;
+	mxc_dma_device_t dev_id = 0;
+
+	DBG("%s: clock %u, bus %lu, power %u, vdd %u\n", DRIVER_NAME,
+	    ios->clock, 1UL << ios->bus_width, ios->power_mode, ios->vdd);
+
+	host = mmc_priv(mmc);
+
+	/* Configure the External DMA mode */
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA) {
+		host->dma_dir = DMA_NONE;
+		if (mmc->ios.bus_width != host->mode) {
+			mxc_dma_free(host->dma);
+			if (mmc->ios.bus_width == MMC_BUS_WIDTH_4) {
+				if (host->id == 0)
+					dev_id = MXC_DMA_MMC1_WIDTH_4;
+				else
+					dev_id = MXC_DMA_MMC2_WIDTH_4;
+			} else {
+				if (host->id == 0)
+					dev_id = MXC_DMA_MMC1_WIDTH_1;
+				else
+					dev_id = MXC_DMA_MMC2_WIDTH_1;
+			}
+			host->dma = mxc_dma_request(dev_id, "MXC MMC");
+			if (host->dma < 0)
+				DBG("Cannot allocate MMC DMA channel\n");
+			mxc_dma_callback_set(host->dma, sdhci_dma_irq,
+					     (void *)host);
+			/* Configure the WML rege */
+			if (mxc_wml_value == 512)
+				writel(SDHCI_WML_128_WORDS,
+				       host->ioaddr + SDHCI_WML);
+			else
+				writel(SDHCI_WML_16_WORDS,
+				       host->ioaddr + SDHCI_WML);
+		}
+	}
+
+	host->mode = mmc->ios.bus_width;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	/*
+	 * Reset the chip on each power off.
+	 * Should clear out any weird states.
+	 */
+	if (ios->power_mode == MMC_POWER_OFF) {
+		writel(0, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+		sdhci_init(host);
+	}
+
+	sdhci_set_clock(host, ios->clock);
+
+	if (ios->power_mode == MMC_POWER_OFF)
+		sdhci_set_power(host, -1);
+	else {
+		sdhci_set_power(host, ios->vdd);
+		if (!readl(host->ioaddr + SDHCI_SIGNAL_ENABLE)) {
+			tmp = readl(host->ioaddr + SDHCI_INT_ENABLE);
+			if (host->sdio_enable)
+				writel(tmp, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+			else
+				writel(tmp & ~SDHCI_INT_CARD_INT,
+				       host->ioaddr + SDHCI_SIGNAL_ENABLE);
+		}
+	}
+
+	tmp = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+
+	if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		tmp &= ~SDHCI_CTRL_8BITBUS;
+		tmp |= SDHCI_CTRL_4BITBUS;
+	} else if (ios->bus_width == MMC_BUS_WIDTH_8) {
+		tmp &= ~SDHCI_CTRL_4BITBUS;
+		tmp |= SDHCI_CTRL_8BITBUS;
+	} else if (ios->bus_width == MMC_BUS_WIDTH_1) {
+		tmp &= ~SDHCI_CTRL_4BITBUS;
+		tmp &= ~SDHCI_CTRL_8BITBUS;
+	}
+
+	if (host->flags & SDHCI_USE_DMA)
+		tmp |= SDHCI_CTRL_ADMA;
+
+	writel(tmp, host->ioaddr + SDHCI_HOST_CONTROL);
+
+	/*
+	 * Some (ENE) controllers go apeshit on some ios operation,
+	 * signalling timeout and CRC errors even on CMD0. Resetting
+	 * it on each ios seems to solve the problem.
+	 */
+	if (host->chip->quirks & SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS)
+		sdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int sdhci_get_ro(struct mmc_host *mmc)
+{
+	struct sdhci_host *host;
+
+	host = mmc_priv(mmc);
+
+	if (host->plat_data->wp_status)
+		return host->plat_data->wp_status(mmc->parent);
+	else
+		return 0;
+}
+
+static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+	u32 ier, prot, clk, present;
+
+	host = mmc_priv(mmc);
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (enable) {
+		if (host->sdio_enable++)
+			goto exit_unlock;
+	} else {
+		if (--(host->sdio_enable))
+			goto exit_unlock;
+	}
+	/* Enable the clock */
+	if (!host->plat_data->clk_flg) {
+		clk_enable(host->clk);
+		host->plat_data->clk_flg = 1;
+	}
+	ier = readl(host->ioaddr + SDHCI_SIGNAL_ENABLE);
+	prot = readl(host->ioaddr + SDHCI_HOST_CONTROL);
+	clk = readl(host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	if (enable) {
+		ier |= SDHCI_INT_CARD_INT;
+		prot |= SDHCI_CTRL_D3CD;
+		clk |= SDHCI_CLOCK_PER_EN | SDHCI_CLOCK_IPG_EN;
+		present = readl(host->ioaddr + SDHCI_PRESENT_STATE);
+		if ((present & SDHCI_CARD_INT_MASK) != SDHCI_CARD_INT_ID)
+			writel(SDHCI_INT_CARD_INT,
+			       host->ioaddr + SDHCI_INT_STATUS);
+	} else {
+		ier &= ~SDHCI_INT_CARD_INT;
+		prot &= ~SDHCI_CTRL_D3CD;
+		clk &= ~(SDHCI_CLOCK_PER_EN | SDHCI_CLOCK_IPG_EN);
+	}
+
+	writel(prot, host->ioaddr + SDHCI_HOST_CONTROL);
+	writel(ier, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+	writel(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	mmiowb();
+      exit_unlock:
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static const struct mmc_host_ops sdhci_ops = {
+	.request = sdhci_request,
+	.set_ios = sdhci_set_ios,
+	.get_ro = sdhci_get_ro,
+	.enable_sdio_irq = sdhci_enable_sdio_irq,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Tasklets                                                                  *
+ *                                                                           *
+\*****************************************************************************/
+
+static void sdhci_tasklet_card(unsigned long param)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+	unsigned int cd_status = 0;
+
+	host = (struct sdhci_host *)param;
+
+	if (host->flags & SDHCI_CD_PRESENT)
+		host->flags &= ~SDHCI_CD_PRESENT;
+	else
+		host->flags |= SDHCI_CD_PRESENT;
+	/* Detect there is a card in slot or not */
+	DBG("cd_status=%d %s\n", cd_status,
+	    (host->flags & SDHCI_CD_PRESENT) ? "inserted" : "removed");
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (!(host->flags & SDHCI_CD_PRESENT)) {
+		if (host->mrq) {
+			printk(KERN_ERR "%s: Card removed during transfer!\n",
+			       mmc_hostname(host->mmc));
+			printk(KERN_ERR "%s: Resetting controller.\n",
+			       mmc_hostname(host->mmc));
+
+			sdhci_reset(host, SDHCI_RESET_CMD);
+			sdhci_reset(host, SDHCI_RESET_DATA);
+
+			host->mrq->cmd->error = -ENOMEDIUM;
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
+}
+
+static void sdhci_tasklet_finish(unsigned long param)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+	struct mmc_request *mrq;
+
+	host = (struct sdhci_host *)param;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	del_timer(&host->timer);
+
+	mrq = host->mrq;
+
+	/*
+	 * The controller needs a reset of internal state machines
+	 * upon error conditions.
+	 */
+	if (mrq->cmd->error ||
+	    (mrq->data && (mrq->data->error ||
+			   (mrq->data->stop && mrq->data->stop->error))) ||
+	    (host->chip->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST)) {
+
+		/* Some controllers need this kick or reset won't work here */
+		if (host->chip->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET) {
+			unsigned int clock;
+
+			/* This is to force an update */
+			clock = host->clock;
+			host->clock = 0;
+			sdhci_set_clock(host, clock);
+		}
+
+		/* Spec says we should do both at the same time, but Ricoh
+		   controllers do not like that. */
+		sdhci_reset(host, SDHCI_RESET_CMD);
+		sdhci_reset(host, SDHCI_RESET_DATA);
+	}
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	sdhci_deactivate_led(host);
+
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/* Stop the clock when the req is done */
+	flags = SDHCI_DATA_ACTIVE | SDHCI_DOING_WRITE | SDHCI_DOING_READ;
+	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & flags)) {
+		if (host->plat_data->clk_flg) {
+			clk_disable(host->clk);
+			host->plat_data->clk_flg = 0;
+		}
+	}
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void sdhci_timeout_timer(unsigned long data)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+
+	host = (struct sdhci_host *)data;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (host->mrq) {
+		printk(KERN_ERR "%s: Timeout waiting for hardware "
+		       "interrupt.\n", mmc_hostname(host->mmc));
+		sdhci_dumpregs(host);
+
+		if (host->data) {
+			host->data->error = -ETIMEDOUT;
+			sdhci_finish_data(host);
+		} else {
+			if (host->cmd)
+				host->cmd->error = -ETIMEDOUT;
+			else
+				host->mrq->cmd->error = -ETIMEDOUT;
+
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}
+
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * Interrupt handling                                                        *
+ *                                                                           *
+\*****************************************************************************/
+
+static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask)
+{
+	BUG_ON(intmask == 0);
+
+	if (!host->cmd) {
+		printk(KERN_ERR "%s: Got command interrupt 0x%08x even "
+		       "though no command operation was in progress.\n",
+		       mmc_hostname(host->mmc), (unsigned)intmask);
+		sdhci_dumpregs(host);
+		return;
+	}
+
+	if (intmask & SDHCI_INT_TIMEOUT)
+		host->cmd->error = -ETIMEDOUT;
+	else if (intmask & (SDHCI_INT_CRC | SDHCI_INT_END_BIT |
+			    SDHCI_INT_INDEX))
+		host->cmd->error = -EILSEQ;
+
+	if (host->cmd->error)
+		tasklet_schedule(&host->finish_tasklet);
+	else if (intmask & SDHCI_INT_RESPONSE)
+		sdhci_finish_command(host);
+}
+
+static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
+{
+	u32 intsave = 0;
+
+	BUG_ON(intmask == 0);
+
+	if (!host->data) {
+		/*
+		 * A data end interrupt is sent together with the response
+		 * for the stop command.
+		 */
+		if (intmask & SDHCI_INT_DATA_END)
+			return;
+
+		printk(KERN_ERR "%s: Got data interrupt 0x%08x even "
+		       "though no data operation was in progress.\n",
+		       mmc_hostname(host->mmc), (unsigned)intmask);
+		sdhci_dumpregs(host);
+		return;
+	}
+
+	/* Mask the INT */
+	intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
+	writel(intsave & (~(intmask & SDHCI_INT_DATA_RE_MASK)),
+	       host->ioaddr + SDHCI_INT_ENABLE);
+
+	if (intmask & SDHCI_INT_DATA_TIMEOUT)
+		host->data->error = -ETIMEDOUT;
+	else if (intmask & (SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_END_BIT))
+		host->data->error = -EILSEQ;
+
+	if (host->data->error)
+		sdhci_finish_data(host);
+	else {
+		if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+		    (host->dma_size >= mxc_wml_value)) {
+			/* Use DMA if transfer size is greater than fifo size */
+			if (intmask & (SDHCI_INT_DATA_AVAIL |
+				       SDHCI_INT_SPACE_AVAIL)) {
+				intsave &= ~SDHCI_INT_DATA_RE_MASK;
+				if (mxc_dma_enable(host->dma) < 0) {
+					printk(KERN_ERR "ENABLE SDMA ERR.\n");
+					intsave |= SDHCI_INT_DATA_RE_MASK;
+				}
+			}
+		} else {
+			if (intmask & (SDHCI_INT_DATA_AVAIL |
+				       SDHCI_INT_SPACE_AVAIL))
+				sdhci_transfer_pio(host);
+		}
+
+		/*
+		 * We currently don't do anything fancy with DMA
+		 * boundaries, but as we can't disable the feature
+		 * we need to at least restart the transfer.
+		 */
+		if ((intmask & SDHCI_INT_DMA_END) &&
+		    (!(intmask & SDHCI_INT_DATA_END)))
+			writel(readl(host->ioaddr + SDHCI_DMA_ADDRESS),
+			       host->ioaddr + SDHCI_DMA_ADDRESS);
+
+		if (intmask & SDHCI_INT_DATA_END) {
+			if (host->data->flags & MMC_DATA_READ)
+				writel(readl(host->ioaddr + SDHCI_CLOCK_CONTROL)
+				       & ~SDHCI_CLOCK_HLK_EN,
+				       host->ioaddr + SDHCI_CLOCK_CONTROL);
+			if (host->cmd) {
+				/*
+				 * Data managed to finish before the
+				 * command completed. Make sure we do
+				 * things in the proper order.
+				 */
+				host->data_early = 1;
+			} else {
+
+				if (host->plat_data->vendor_ver
+				    < ESDHC_VENDOR_V22) {
+					/*
+					 * There are the DATA END INT when
+					 * writing is not complete. Double
+					 * check on it. TO2 has been fixed it.
+					 */
+					intmask = readl(host->ioaddr +
+							SDHCI_PRESENT_STATE);
+					if (intmask & SDHCI_DATA_ACTIVE)
+						goto data_irq_out;
+				}
+				sdhci_finish_data(host);
+			}
+		}
+	}
+      data_irq_out:
+	/* Enable the INT */
+	writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
+}
+
+/*!
+* This function is called by DMA Interrupt Service Routine to indicate
+* requested DMA transfer is completed.
+*
+* @param   devid  pointer to device specific structure
+* @param   error any DMA error
+* @param   cnt   amount of data that was transferred
+*/
+static void sdhci_dma_irq(void *devid, int error, unsigned int cnt)
+{
+	u32 intsave = 0;
+	int ret;
+	struct sdhci_host *host = devid;
+
+	DBG("%s: error: %d Transferred bytes:%d\n", DRIVER_NAME, error, cnt);
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA) {
+		/*
+		 * Stop the DMA transfer here, the data_irq would be called
+		 * to process the others
+		 */
+		ret = mxc_dma_disable(host->dma);
+		if (ret < 0)
+			printk(KERN_ERR "Disable dma channel err %d\n", ret);
+
+		if (error) {
+			DBG("Error in DMA transfer\n");
+			return;
+		}
+		intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
+		intsave |= SDHCI_INT_DATA_RE_MASK;
+		writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
+	}
+}
+
+/* woke queue handler func */
+static void esdhc_cd_callback(struct work_struct *work)
+{
+	unsigned long flags;
+	unsigned int cd_status = 0;
+	struct sdhci_host *host = container_of(work, struct sdhci_host, cd_wq);
+
+	cd_status = host->plat_data->status(host->mmc->parent);
+	if (cd_status)
+		host->flags &= ~SDHCI_CD_PRESENT;
+	else
+		host->flags |= SDHCI_CD_PRESENT;
+	/* Detect there is a card in slot or not */
+	DBG("cd_status=%d %s\n", cd_status,
+	    (host->flags & SDHCI_CD_PRESENT) ? "inserted" : "removed");
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (!(host->flags & SDHCI_CD_PRESENT)) {
+		printk(KERN_INFO
+		       "%s: Card removed and resetting controller.\n",
+		       mmc_hostname(host->mmc));
+		sdhci_init(host);
+		if (host->mrq) {
+			printk(KERN_ERR
+			       "%s: Card removed during transfer!\n",
+			       mmc_hostname(host->mmc));
+			printk(KERN_ERR
+			       "%s: Resetting controller.\n",
+			       mmc_hostname(host->mmc));
+
+			sdhci_reset(host, SDHCI_RESET_CMD);
+			sdhci_reset(host, SDHCI_RESET_DATA);
+
+			host->mrq->cmd->error = -ENOMEDIUM;
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
+
+	if (!host->detect_irq)
+		return;
+	do {
+		cd_status = host->plat_data->status(host->mmc->parent);
+		if (cd_status)
+			set_irq_type(host->detect_irq, IRQF_TRIGGER_FALLING);
+		else
+			set_irq_type(host->detect_irq, IRQF_TRIGGER_RISING);
+	} while (cd_status != host->plat_data->status(host->mmc->parent));
+}
+
+/*!
+* Card detection interrupt service routine registered to handle
+* the SDHC interrupts. This interrupt routine handles card
+* insertion and card removal interrupts.
+*
+* @param   irq    the interrupt number
+* @param   devid  driver private data
+*
+* @return  The function returns \b IRQ_RETVAL(1)
+*/
+static irqreturn_t sdhci_cd_irq(int irq, void *dev_id)
+{
+	struct sdhci_host *host = dev_id;
+
+	schedule_work(&host->cd_wq);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sdhci_irq(int irq, void *dev_id)
+{
+	irqreturn_t result;
+	struct sdhci_host *host = dev_id;
+	u32 intmask;
+	int cardint = 0;
+
+	spin_lock(&host->lock);
+
+	intmask = readl(host->ioaddr + SDHCI_INT_STATUS);
+
+	if (!intmask || intmask == 0xffffffff) {
+		result = IRQ_NONE;
+		goto out;
+	}
+
+	DBG("*** %s got interrupt: 0x%08x\n", mmc_hostname(host->mmc), intmask);
+
+	if (intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE)) {
+		writel(intmask &
+		       (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE),
+		       host->ioaddr + SDHCI_INT_STATUS);
+		tasklet_schedule(&host->card_tasklet);
+	}
+
+	intmask &= ~(SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE);
+
+	if (intmask & SDHCI_INT_CMD_MASK) {
+		writel(intmask & SDHCI_INT_CMD_MASK,
+		       host->ioaddr + SDHCI_INT_STATUS);
+		sdhci_cmd_irq(host, intmask & SDHCI_INT_CMD_MASK);
+	}
+
+	if (intmask & SDHCI_INT_DATA_MASK) {
+		writel(intmask & SDHCI_INT_DATA_MASK,
+		       host->ioaddr + SDHCI_INT_STATUS);
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 0) {
+			if (!
+			    (readl(host->ioaddr + SDHCI_TRANSFER_MODE) &
+			     SDHCI_TRNS_READ))
+				intmask &= ~SDHCI_INT_DATA_END_BIT;
+		}
+		if (intmask & SDHCI_INT_DATA_MASK)
+			sdhci_data_irq(host, intmask & SDHCI_INT_DATA_MASK);
+	}
+
+	intmask &= ~(SDHCI_INT_CMD_MASK | SDHCI_INT_DATA_MASK);
+
+	intmask &= ~SDHCI_INT_ERROR;
+
+	if (intmask & SDHCI_INT_BUS_POWER) {
+		printk(KERN_ERR "%s: Card is consuming too much power!\n",
+		       mmc_hostname(host->mmc));
+		writel(SDHCI_INT_BUS_POWER, host->ioaddr + SDHCI_INT_STATUS);
+	}
+
+	intmask &= ~SDHCI_INT_BUS_POWER;
+
+	if (intmask & SDHCI_INT_CARD_INT)
+		cardint = readl(host->ioaddr + SDHCI_SIGNAL_ENABLE) &
+		    SDHCI_INT_CARD_INT;
+
+	intmask &= ~SDHCI_INT_CARD_INT;
+
+	if (intmask) {
+		printk(KERN_ERR "%s: Unexpected interrupt 0x%08x.\n",
+		       mmc_hostname(host->mmc), intmask);
+		sdhci_dumpregs(host);
+
+		writel(intmask, host->ioaddr + SDHCI_INT_STATUS);
+	}
+
+	result = IRQ_HANDLED;
+
+	mmiowb();
+      out:
+	spin_unlock(&host->lock);
+
+	/*
+	 * We have to delay this as it calls back into the driver.
+	 */
+	if (cardint)
+		mmc_signal_sdio_irq(host->mmc);
+
+	return result;
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * Suspend/resume                                                            *
+ *                                                                           *
+\*****************************************************************************/
+
+#ifdef CONFIG_PM
+
+static int sdhci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct sdhci_chip *chip;
+	int i, ret;
+
+	chip = dev_get_drvdata(&pdev->dev);
+	if (!chip)
+		return 0;
+
+	DBG("Suspending...\n");
+
+	for (i = 0; i < chip->num_slots; i++) {
+		if (!chip->hosts[i])
+			continue;
+		ret = mmc_suspend_host(chip->hosts[i]->mmc, state);
+		if (ret) {
+			for (i--; i >= 0; i--)
+				mmc_resume_host(chip->hosts[i]->mmc);
+			return ret;
+		}
+	}
+
+	for (i = 0; i < chip->num_slots; i++) {
+		if (!chip->hosts[i])
+			continue;
+		free_irq(chip->hosts[i]->irq, chip->hosts[i]);
+	}
+
+	gpio_sdhc_inactive(pdev->id);
+
+	return 0;
+}
+
+static int sdhci_resume(struct platform_device *pdev)
+{
+	struct sdhci_chip *chip;
+	int i, ret;
+
+	chip = dev_get_drvdata(&pdev->dev);
+	if (!chip)
+		return 0;
+
+	DBG("Resuming...\n");
+
+	gpio_sdhc_active(pdev->id);
+
+	for (i = 0; i < chip->num_slots; i++) {
+		if (!chip->hosts[i])
+			continue;
+		ret = request_irq(chip->hosts[i]->irq, sdhci_irq,
+				  IRQF_SHARED,
+				  mmc_hostname(chip->hosts[i]->mmc),
+				  chip->hosts[i]);
+		if (ret)
+			return ret;
+		sdhci_init(chip->hosts[i]);
+		mmiowb();
+		ret = mmc_resume_host(chip->hosts[i]->mmc);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+#else				/* CONFIG_PM */
+
+#define sdhci_suspend NULL
+#define sdhci_resume NULL
+
+#endif				/* CONFIG_PM */
+
+/*****************************************************************************\
+ *                                                                           *
+ * Device probing/removal                                                    *
+ *                                                                           *
+\*****************************************************************************/
+
+static int __devinit sdhci_probe_slot(struct platform_device
+				      *pdev, int slot)
+{
+	struct mxc_mmc_platform_data *mmc_plat = pdev->dev.platform_data;
+	int ret = 0;
+	unsigned int version, caps;
+	struct sdhci_chip *chip;
+	struct mmc_host *mmc;
+	struct sdhci_host *host;
+	mxc_dma_device_t dev_id = 0;
+
+	if (!mmc_plat)
+		return -EINVAL;
+
+	chip = dev_get_drvdata(&pdev->dev);
+	BUG_ON(!chip);
+
+	mmc = mmc_alloc_host(sizeof(struct sdhci_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->id = pdev->id;
+	host->dma = -1;
+	host->plat_data = mmc_plat;
+	if (!host->plat_data) {
+		ret = -EINVAL;
+		goto out0;
+	}
+
+	host->chip = chip;
+	chip->hosts[slot] = host;
+
+	/* Get pwr supply for eSDHC */
+	if (NULL != mmc_plat->power_mmc) {
+		host->regulator_mmc =
+		    regulator_get(&pdev->dev, mmc_plat->power_mmc);
+		if (IS_ERR(host->regulator_mmc)) {
+			ret = PTR_ERR(host->regulator_mmc);
+			goto out1;
+		}
+		if (regulator_enable(host->regulator_mmc) == 0) {
+			DBG("mmc power on\n");
+			msleep(1);
+		}
+	}
+
+	/* Active the eSDHC bus */
+	gpio_sdhc_active(pdev->id);
+
+	/* Get the SDHC clock from clock system APIs */
+	host->clk = clk_get(&pdev->dev, mmc_plat->clock_mmc);
+	if (NULL == host->clk)
+		printk(KERN_ERR "MXC MMC can't get clock.\n");
+	DBG("SDHC:%d clock:%lu\n", pdev->id, clk_get_rate(host->clk));
+
+	host->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!host->res) {
+		ret = -ENOMEM;
+		goto out2;
+	}
+	host->irq = platform_get_irq(pdev, 0);
+	if (!host->irq) {
+		ret = -ENOMEM;
+		goto out2;
+	}
+	host->detect_irq = platform_get_irq(pdev, 1);
+	if (!host->detect_irq) {
+		host->flags &= ~SDHCI_CD_PRESENT;
+		if ((pdev->id >= 0) && (pdev->id < MXC_SDHCI_NUM))
+			mxc_fix_chips[pdev->id] = chip;
+		goto no_detect_irq;
+	}
+
+	do {
+		ret = host->plat_data->status(host->mmc->parent);
+		if (ret)
+			set_irq_type(host->detect_irq, IRQF_TRIGGER_FALLING);
+		else
+			set_irq_type(host->detect_irq, IRQF_TRIGGER_RISING);
+	} while (ret != host->plat_data->status(host->mmc->parent));
+
+	ret = host->plat_data->status(host->mmc->parent);
+	if (ret)
+		host->flags &= ~SDHCI_CD_PRESENT;
+	else
+		host->flags |= SDHCI_CD_PRESENT;
+
+      no_detect_irq:
+	DBG("slot %d at 0x%x, irq %d \n", slot, host->res->start, host->irq);
+	if (!request_mem_region(host->res->start,
+				host->res->end -
+				host->res->start + 1, pdev->name)) {
+		printk(KERN_ERR "request_mem_region failed\n");
+		ret = -ENOMEM;
+		goto out2;
+	}
+	host->ioaddr = (void *)ioremap(host->res->start, host->res->end -
+				       host->res->start + 1);
+	if (!host->ioaddr) {
+		ret = -ENOMEM;
+		goto out3;
+	}
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	version = readl(host->ioaddr + SDHCI_HOST_VERSION);
+	host->plat_data->vendor_ver = (version & SDHCI_VENDOR_VER_MASK) >>
+	    SDHCI_VENDOR_VER_SHIFT;
+	version = (version & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT;
+	if (version != 1) {
+		printk(KERN_ERR "%s: Unknown controller version (%d). "
+		       "You may experience problems.\n", mmc_hostname(mmc),
+		       version);
+	}
+
+	caps = readl(host->ioaddr + SDHCI_CAPABILITIES);
+
+	if (chip->quirks & SDHCI_QUIRK_FORCE_DMA)
+		host->flags |= SDHCI_USE_DMA;
+	else if (!(caps & SDHCI_CAN_DO_DMA))
+		DBG("Controller doesn't have DMA capability\n");
+	else if (chip->
+		 quirks & (SDHCI_QUIRK_INTERNAL_ADVANCED_DMA |
+			   SDHCI_QUIRK_INTERNAL_SIMPLE_DMA))
+		host->flags |= SDHCI_USE_DMA;
+	else if (chip->quirks & (SDHCI_QUIRK_EXTERNAL_DMA_MODE))
+		host->flags |= SDHCI_USE_EXTERNAL_DMA;
+	else
+		host->flags &= ~SDHCI_USE_DMA;
+
+	/*
+	 * These definitions of eSDHC are not compatible with the SD Host
+	 * Controller Spec v2.0
+	 */
+	host->min_clk = mmc_plat->min_clk;
+	host->max_clk = mmc_plat->max_clk;
+	host->timeout_clk = 1024 * 1000;	/* Just set the value temply. */
+
+	/*
+	 * Set host parameters.
+	 */
+	mmc->ops = &sdhci_ops;
+	mmc->f_min = host->min_clk;
+	mmc->f_max = host->max_clk;
+	mmc->caps = MMC_CAP_SDIO_IRQ;
+	mmc->caps |= mmc_plat->caps;
+
+	if (caps & SDHCI_CAN_DO_HISPD)
+		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
+
+	mmc->ocr_avail = mmc_plat->ocr_mask;
+	if (caps & SDHCI_CAN_VDD_330)
+		mmc->ocr_avail |= MMC_VDD_32_33 | MMC_VDD_33_34;
+	if (caps & SDHCI_CAN_VDD_300)
+		mmc->ocr_avail |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & SDHCI_CAN_VDD_180)
+		mmc->ocr_avail |= MMC_VDD_165_195;
+
+	if (mmc->ocr_avail == 0) {
+		printk(KERN_ERR "%s: Hardware doesn't report any "
+		       "support voltages.\n", mmc_hostname(mmc));
+		ret = -ENODEV;
+		goto out3;
+	}
+
+	spin_lock_init(&host->lock);
+
+	/*
+	 * Maximum number of segments. Hardware cannot do scatter lists.
+	 */
+	if (host->flags & SDHCI_USE_DMA)
+		mmc->max_hw_segs = 1;
+	else
+		mmc->max_hw_segs = 16;
+	mmc->max_phys_segs = 16;
+
+	/*
+	 * Maximum number of sectors in one transfer. Limited by DMA boundary
+	 * size (512KiB).
+	 */
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+		mmc->max_req_size = 32 * 1024;
+	else
+		mmc->max_req_size = 524288;
+
+	/*
+	 * Maximum segment size. Could be one segment with the maximum number
+	 * of bytes.
+	 */
+	mmc->max_seg_size = mmc->max_req_size;
+
+	/*
+	 * Maximum block size. This varies from controller to controller and
+	 * is specified in the capabilities register.
+	 */
+	mmc->max_blk_size =
+	    (caps & SDHCI_MAX_BLOCK_MASK) >> SDHCI_MAX_BLOCK_SHIFT;
+	if (mmc->max_blk_size > 3) {
+		printk(KERN_WARNING "%s: Invalid maximum block size, "
+		       "assuming 512 bytes\n", mmc_hostname(mmc));
+		mmc->max_blk_size = 512;
+	} else
+		mmc->max_blk_size = 512 << mmc->max_blk_size;
+
+	/*
+	 * Maximum block count.
+	 */
+	mmc->max_blk_count = 65535;
+
+	/*
+	 * Apply a continous physical memory used for storing the ADMA
+	 * descriptor table.
+	 */
+	if (host->flags & SDHCI_USE_DMA) {
+		adma_des_table = kcalloc((2 * (mmc->max_phys_segs) + 1),
+					 sizeof(unsigned int), GFP_DMA);
+		if (adma_des_table == NULL) {
+			printk(KERN_ERR "Cannot allocate ADMA memory\n");
+			ret = -ENOMEM;
+			goto out3;
+		}
+	}
+
+	/*
+	 * Init tasklets.
+	 */
+	tasklet_init(&host->card_tasklet,
+		     sdhci_tasklet_card, (unsigned long)host);
+	tasklet_init(&host->finish_tasklet,
+		     sdhci_tasklet_finish, (unsigned long)host);
+
+	/* initialize the work queue */
+	INIT_WORK(&host->cd_wq, esdhc_cd_callback);
+
+	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
+
+	if (host->detect_irq) {
+		ret = request_irq(host->detect_irq, sdhci_cd_irq, 0,
+				  pdev->name, host);
+		if (ret)
+			goto out4;
+	}
+
+	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED, pdev->name, host);
+	if (ret)
+		goto out5;
+
+	sdhci_init(host);
+
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA) {
+		/* Apply the 1-bit SDMA channel. */
+		if (host->id == 0)
+			dev_id = MXC_DMA_MMC1_WIDTH_1;
+		else
+			dev_id = MXC_DMA_MMC2_WIDTH_1;
+		host->dma = mxc_dma_request(dev_id, "MXC MMC");
+		if (host->dma < 0) {
+			DBG("Cannot allocate MMC DMA channel\n");
+			goto out6;
+		}
+		mxc_dma_callback_set(host->dma, sdhci_dma_irq, (void *)host);
+	}
+#ifdef CONFIG_MMC_DEBUG
+	sdhci_dumpregs(host);
+#endif
+
+	mmiowb();
+
+	if (mmc_add_host(mmc) < 0)
+		goto out6;
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+		printk(KERN_INFO "%s: SDHCI detect irq %d irq %d %s\n",
+		       mmc_hostname(mmc), host->detect_irq, host->irq,
+		       "EXTERNAL DMA");
+	else
+		printk(KERN_INFO "%s: SDHCI detect irq %d irq %d %s\n",
+		       mmc_hostname(mmc), host->detect_irq, host->irq,
+		       (host->flags & SDHCI_USE_DMA) ? "INTERNAL DMA" : "PIO");
+
+	return 0;
+
+      out6:
+	free_irq(host->irq, host);
+      out5:
+	if (host->detect_irq)
+		free_irq(host->detect_irq, host);
+	else {
+		if ((pdev->id >= 0) && (pdev->id < MXC_SDHCI_NUM))
+			mxc_fix_chips[pdev->id] = chip;
+	}
+      out4:
+	del_timer_sync(&host->timer);
+	tasklet_kill(&host->card_tasklet);
+	tasklet_kill(&host->finish_tasklet);
+      out3:
+	if (host->flags & SDHCI_USE_DMA)
+		kfree(adma_des_table);
+	release_mem_region(host->res->start,
+			   host->res->end - host->res->start + 1);
+      out2:
+	clk_disable(host->clk);
+	host->plat_data->clk_flg = 0;
+	clk_put(host->clk);
+      out1:
+	gpio_sdhc_inactive(pdev->id);
+      out0:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static void sdhci_remove_slot(struct platform_device *pdev, int slot)
+{
+	struct sdhci_chip *chip;
+	struct mmc_host *mmc;
+	struct sdhci_host *host;
+
+	chip = dev_get_drvdata(&pdev->dev);
+	host = chip->hosts[slot];
+	mmc = host->mmc;
+
+	chip->hosts[slot] = NULL;
+
+	mmc_remove_host(mmc);
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	if (host->detect_irq)
+		free_irq(host->detect_irq, host);
+	else {
+		if ((pdev->id >= 0) && (pdev->id < MXC_SDHCI_NUM))
+			mxc_fix_chips[pdev->id] = NULL;
+	}
+	free_irq(host->irq, host);
+	if (chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
+		host->flags &= ~SDHCI_USE_EXTERNAL_DMA;
+		mxc_dma_free(host->dma);
+	}
+
+	del_timer_sync(&host->timer);
+
+	tasklet_kill(&host->card_tasklet);
+	tasklet_kill(&host->finish_tasklet);
+
+	if (host->flags & SDHCI_USE_DMA)
+		kfree(adma_des_table);
+	release_mem_region(host->res->start,
+			   host->res->end - host->res->start + 1);
+	clk_disable(host->clk);
+	host->plat_data->clk_flg = 0;
+	clk_put(host->clk);
+	mmc_free_host(mmc);
+	gpio_sdhc_inactive(pdev->id);
+}
+
+static int sdhci_probe(struct platform_device *pdev)
+{
+	int ret = 0, i;
+	u8 slots = 1;
+	struct sdhci_chip *chip;
+
+	printk(KERN_INFO DRIVER_NAME ": MXC SDHCI Controller Driver. \n");
+	BUG_ON(pdev == NULL);
+
+	chip = kzalloc(sizeof(struct sdhci_chip) +
+		       sizeof(struct sdhci_host *) * slots, GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* Distinguish different platform */
+	if (machine_is_mx37_3ds()) {
+		mxc_quirks = SDHCI_QUIRK_EXTERNAL_DMA_MODE;
+	} else {
+		mxc_quirks = SDHCI_QUIRK_INTERNAL_ADVANCED_DMA |
+		    SDHCI_QUIRK_INTERNAL_SIMPLE_DMA;
+	}
+	chip->pdev = pdev;
+	chip->quirks = mxc_quirks;
+
+	if (debug_quirks)
+		chip->quirks = debug_quirks;
+
+	chip->num_slots = slots;
+	dev_set_drvdata(&pdev->dev, chip);
+
+	for (i = 0; i < slots; i++) {
+		ret = sdhci_probe_slot(pdev, i);
+		if (ret) {
+			for (i--; i >= 0; i--)
+				sdhci_remove_slot(pdev, i);
+			goto free;
+		}
+	}
+
+	return 0;
+
+      free:
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(chip);
+
+      err:
+	return ret;
+}
+
+static int sdhci_remove(struct platform_device *pdev)
+{
+	int i;
+	struct sdhci_chip *chip;
+
+	chip = dev_get_drvdata(&pdev->dev);
+
+	if (chip) {
+		for (i = 0; i < chip->num_slots; i++)
+			sdhci_remove_slot(pdev, i);
+
+		dev_set_drvdata(&pdev->dev, NULL);
+
+		kfree(chip);
+	}
+
+	return 0;
+}
+
+static struct platform_driver sdhci_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   },
+	.probe = sdhci_probe,
+	.remove = sdhci_remove,
+	.suspend = sdhci_suspend,
+	.resume = sdhci_resume,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Driver init/exit                                                          *
+ *                                                                           *
+\*****************************************************************************/
+
+static int __init sdhci_drv_init(void)
+{
+	printk(KERN_INFO DRIVER_NAME
+	       ": MXC Secure Digital Host Controller Interface driver\n");
+	return platform_driver_register(&sdhci_driver);
+}
+
+static void __exit sdhci_drv_exit(void)
+{
+	DBG("Exiting\n");
+
+	platform_driver_unregister(&sdhci_driver);
+}
+
+module_init(sdhci_drv_init);
+module_exit(sdhci_drv_exit);
+
+module_param(debug_quirks, uint, 0444);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM_DESC(debug_quirks, "Force certain quirks.");
diff --git a/drivers/mmc/host/mx_sdhci.h b/drivers/mmc/host/mx_sdhci.h
new file mode 100644
index 0000000..4a68cd5
--- /dev/null
+++ b/drivers/mmc/host/mx_sdhci.h
@@ -0,0 +1,273 @@
+/*
+ *  linux/drivers/mmc/host/mx_sdhci.h - Secure Digital Host
+ *  Controller Interface driver
+ *
+ *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
+ *  Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+/*
+ * Controller registers
+ */
+
+#define SDHCI_DMA_ADDRESS	0x00
+
+#define SDHCI_BLOCK_SIZE	0x04
+#define  SDHCI_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 13) | (blksz & 0x1FFF))
+
+#define SDHCI_BLOCK_COUNT	0x04
+
+#define SDHCI_ARGUMENT		0x08
+
+#define SDHCI_TRANSFER_MODE	0x0C
+#define  SDHCI_TRNS_DMA		0x00000001
+#define  SDHCI_TRNS_BLK_CNT_EN	0x00000002
+#define  SDHCI_TRNS_ACMD12	0x00000004
+#define  SDHCI_TRNS_READ	0x00000010
+#define  SDHCI_TRNS_MULTI	0x00000020
+#define  SDHCI_TRNS_DPSEL	0x00200000
+#define  SDHCI_TRNS_MASK	0xFFFF0000
+
+#define SDHCI_COMMAND		0x0E
+#define  SDHCI_CMD_RESP_MASK	0x03
+#define  SDHCI_CMD_CRC		0x08
+#define  SDHCI_CMD_INDEX	0x10
+#define  SDHCI_CMD_DATA		0x20
+
+#define  SDHCI_CMD_RESP_NONE	0x00
+#define  SDHCI_CMD_RESP_LONG	0x01
+#define  SDHCI_CMD_RESP_SHORT	0x02
+#define  SDHCI_CMD_RESP_SHORT_BUSY 0x03
+
+#define SDHCI_MAKE_CMD(c, f) ((((c & 0xff) << 8) | (f & 0xff)) << 16)
+
+#define SDHCI_RESPONSE		0x10
+
+#define SDHCI_BUFFER		0x20
+
+#define SDHCI_PRESENT_STATE	0x24
+#define  SDHCI_CMD_INHIBIT	0x00000001
+#define  SDHCI_DATA_INHIBIT	0x00000002
+#define  SDHCI_DATA_ACTIVE 	0x00000004
+#define  SDHCI_DOING_WRITE	0x00000100
+#define  SDHCI_DOING_READ	0x00000200
+#define  SDHCI_SPACE_AVAILABLE	0x00000400
+#define  SDHCI_DATA_AVAILABLE	0x00000800
+#define  SDHCI_CARD_PRESENT	0x00010000
+#define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DAT0_IDLE	0x01000000
+#define  SDHCI_CARD_INT_MASK	0x0E000000
+#define  SDHCI_CARD_INT_ID	0x0C000000
+
+#define SDHCI_HOST_CONTROL 	0x28
+#define  SDHCI_CTRL_LED		0x00000001
+#define  SDHCI_CTRL_4BITBUS	0x00000002
+#define  SDHCI_CTRL_8BITBUS	0x00000004
+#define  SDHCI_CTRL_HISPD	0x00000004
+#define  SDHCI_CTRL_DMA_MASK	0x18
+#define   SDHCI_CTRL_SDMA	0x00
+#define   SDHCI_CTRL_ADMA1	0x08
+#define   SDHCI_CTRL_ADMA32	0x10
+#define   SDHCI_CTRL_ADMA64	0x18
+#define  SDHCI_CTRL_D3CD 	0x00000008
+#define  SDHCI_CTRL_ADMA 	0x00000100
+/* wake up control */
+#define  SDHCI_CTRL_WECINS 	0x04000000
+
+#define SDHCI_POWER_CONTROL	0x29
+#define  SDHCI_POWER_ON		0x01
+#define  SDHCI_POWER_180	0x0A
+#define  SDHCI_POWER_300	0x0C
+#define  SDHCI_POWER_330	0x0E
+
+#define SDHCI_BLOCK_GAP_CONTROL	0x2A
+
+#define SDHCI_WAKE_UP_CONTROL	0x2B
+
+#define SDHCI_CLOCK_CONTROL	0x2C
+#define  SDHCI_DIVIDER_SHIFT	8
+#define  SDHCI_CLOCK_SD_EN	0x00000008
+#define  SDHCI_CLOCK_PER_EN	0x00000004
+#define  SDHCI_CLOCK_HLK_EN	0x00000002
+#define  SDHCI_CLOCK_IPG_EN	0x00000001
+#define  SDHCI_CLOCK_MASK 	0x0000FFFF
+
+#define SDHCI_TIMEOUT_CONTROL	0x2E
+
+#define SDHCI_SOFTWARE_RESET	0x2F
+#define  SDHCI_RESET_ALL	0x01
+#define  SDHCI_RESET_CMD	0x02
+#define  SDHCI_RESET_DATA	0x04
+
+#define SDHCI_INT_STATUS	0x30
+#define SDHCI_INT_ENABLE	0x34
+#define SDHCI_SIGNAL_ENABLE	0x38
+#define  SDHCI_INT_RESPONSE	0x00000001
+#define  SDHCI_INT_DATA_END	0x00000002
+#define  SDHCI_INT_DMA_END	0x00000008
+#define  SDHCI_INT_SPACE_AVAIL	0x00000010
+#define  SDHCI_INT_DATA_AVAIL	0x00000020
+#define  SDHCI_INT_CARD_INSERT	0x00000040
+#define  SDHCI_INT_CARD_REMOVE	0x00000080
+#define  SDHCI_INT_CARD_INT	0x00000100
+#define  SDHCI_INT_ERROR	0x00008000
+#define  SDHCI_INT_TIMEOUT	0x00010000
+#define  SDHCI_INT_CRC		0x00020000
+#define  SDHCI_INT_END_BIT	0x00040000
+#define  SDHCI_INT_INDEX	0x00080000
+#define  SDHCI_INT_DATA_TIMEOUT	0x00100000
+#define  SDHCI_INT_DATA_CRC	0x00200000
+#define  SDHCI_INT_DATA_END_BIT	0x00400000
+#define  SDHCI_INT_BUS_POWER	0x00800000
+#define  SDHCI_INT_ACMD12ERR	0x01000000
+#define  SDHCI_INT_ADMA_ERROR	0x10000000
+
+#define  SDHCI_INT_NORMAL_MASK	0x00007FFF
+#define  SDHCI_INT_ERROR_MASK	0xFFFF8000
+
+#define  SDHCI_INT_CMD_MASK	(SDHCI_INT_RESPONSE | SDHCI_INT_TIMEOUT | \
+		SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX)
+#define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
+		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
+		SDHCI_INT_DATA_END_BIT | SDHCI_INT_ADMA_ERROR)
+#define  SDHCI_INT_DATA_RE_MASK	(SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL)
+
+#define SDHCI_ACMD12_ERR	0x3C
+
+/* 3E-3F reserved */
+
+#define SDHCI_CAPABILITIES	0x40
+#define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
+#define  SDHCI_TIMEOUT_CLK_SHIFT 0
+#define  SDHCI_TIMEOUT_CLK_UNIT	0x00000080
+#define  SDHCI_CLOCK_BASE_MASK	0x00003F00
+#define  SDHCI_CLOCK_BASE_SHIFT	8
+#define  SDHCI_MAX_BLOCK_MASK	0x00030000
+#define  SDHCI_MAX_BLOCK_SHIFT  16
+#define  SDHCI_CAN_DO_ADMA2	0x00080000
+#define  SDHCI_CAN_DO_ADMA1	0x00100000
+#define  SDHCI_CAN_DO_HISPD	0x00200000
+#define  SDHCI_CAN_DO_DMA	0x00400000
+#define  SDHCI_CAN_VDD_330	0x01000000
+#define  SDHCI_CAN_VDD_300	0x02000000
+#define  SDHCI_CAN_VDD_180	0x04000000
+#define  SDHCI_CAN_64BIT	0x10000000
+
+/* 44-47 reserved for more caps */
+#define SDHCI_WML 		0x44
+#define  SDHCI_WML_4_WORDS 	0x00040004
+#define  SDHCI_WML_16_WORDS 	0x00100010
+#define  SDHCI_WML_64_WORDS 	0x00400040
+#define  SDHCI_WML_128_WORDS 	0x00800080
+
+#define SDHCI_MAX_CURRENT	0x48
+
+/* 4C-4F reserved for more max current */
+
+#define SDHCI_SET_ACMD12_ERROR	0x50
+#define SDHCI_SET_INT_ERROR	0x52
+
+#define SDHCI_ADMA_ERROR	0x54
+
+/* 55-57 reserved */
+
+#define SDHCI_ADMA_ADDRESS	0x58
+
+/* 60-FB reserved */
+
+/* ADMA Addr Descriptor Attribute Filed */
+enum {
+	FSL_ADMA_DES_ATTR_VALID = 0x01,
+	FSL_ADMA_DES_ATTR_END = 0x02,
+	FSL_ADMA_DES_ATTR_INT = 0x04,
+	FSL_ADMA_DES_ATTR_SET = 0x10,
+	FSL_ADMA_DES_ATTR_TRAN = 0x20,
+	FSL_ADMA_DES_ATTR_LINK = 0x30,
+};
+
+#define SDHCI_HOST_VERSION	0xFC
+#define  SDHCI_VENDOR_VER_MASK	0xFF00
+#define  SDHCI_VENDOR_VER_SHIFT	8
+#define  SDHCI_SPEC_VER_MASK	0x00FF
+#define  SDHCI_SPEC_VER_SHIFT	0
+#define   SDHCI_SPEC_100	0
+#define   SDHCI_SPEC_200	1
+#define   ESDHC_VENDOR_V22 	0x12
+
+struct sdhci_chip;
+
+struct sdhci_host {
+	struct sdhci_chip *chip;
+	struct mmc_host *mmc;	/* MMC structure */
+
+#ifdef CONFIG_LEDS_CLASS
+	struct led_classdev led;	/* LED control */
+#endif
+
+	spinlock_t lock;	/* Mutex */
+
+	int flags;		/* Host attributes */
+#define SDHCI_USE_DMA		(1<<0)	/* Host is DMA capable */
+#define SDHCI_REQ_USE_DMA	(1<<1)	/* Use DMA for this req. */
+#define SDHCI_USE_EXTERNAL_DMA	(1<<2)	/* Use the External DMA */
+#define SDHCI_CD_PRESENT 	(1<<8)	/* CD present */
+#define SDHCI_WP_ENABLED	(1<<9)	/* Write protect */
+
+	unsigned int max_clk;	/* Max possible freq (MHz) */
+	unsigned int min_clk;	/* Min possible freq (MHz) */
+	unsigned int timeout_clk;	/* Timeout freq (KHz) */
+
+	unsigned int clock;	/* Current clock (MHz) */
+	unsigned short power;	/* Current voltage */
+	struct regulator *regulator_mmc;	/*! Regulator */
+
+	struct mmc_request *mrq;	/* Current request */
+	struct mmc_command *cmd;	/* Current command */
+	struct mmc_data *data;	/* Current data request */
+	unsigned int data_early:1;	/* Data finished before cmd */
+
+	unsigned int id;	/* Id for SD/MMC block */
+	int mode;		/* SD/MMC mode */
+	int dma;		/* DMA channel number. */
+	unsigned int dma_size;	/* Number of Bytes in DMA */
+	unsigned int dma_len;	/* Length of the s-g list */
+	unsigned int dma_dir;	/* DMA transfer direction */
+
+	struct scatterlist *cur_sg;	/* We're working on this */
+	int num_sg;		/* Entries left */
+	int offset;		/* Offset into current sg */
+	int remain;		/* Bytes left in current */
+
+	struct resource *res;	/* IO map memory */
+	int irq;		/* Device IRQ */
+	int detect_irq;		/* Card Detect IRQ number. */
+	int sdio_enable;	/* sdio interrupt enable number. */
+	struct clk *clk;	/* Clock id */
+	int bar;		/* PCI BAR index */
+	unsigned long addr;	/* Bus address */
+	void __iomem *ioaddr;	/* Mapped address */
+
+	struct tasklet_struct card_tasklet;	/* Tasklet structures */
+	struct tasklet_struct finish_tasklet;
+	struct work_struct cd_wq;	/* card detection work queue */
+	/* Platform specific data */
+	struct mxc_mmc_platform_data *plat_data;
+
+	struct timer_list timer;	/* Timer for timeouts */
+};
+
+struct sdhci_chip {
+	struct platform_device *pdev;
+
+	unsigned long quirks;
+
+	int num_slots;		/* Slots on controller */
+	struct sdhci_host *hosts[0];	/* Pointers to hosts */
+};
diff --git a/drivers/mmc/host/mxcmmc.c b/drivers/mmc/host/mxcmmc.c
new file mode 100644
index 0000000..67f44b3
--- /dev/null
+++ b/drivers/mmc/host/mxcmmc.c
@@ -0,0 +1,881 @@
+/*
+ *  linux/drivers/mmc/host/mxcmmc.c - Freescale i.MX MMCI driver
+ *
+ *  This is a driver for the SDHC controller found in Freescale MX2/MX3
+ *  SoCs. It is basically the same hardware as found on MX1 (imxmmc.c).
+ *  Unlike the hardware found on MX1, this hardware just works and does
+ *  not need all the quirks found in imxmmc.c, hence the seperate driver.
+ *
+ *  Copyright (C) 2008 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ *  Copyright (C) 2006 Pavel Pisa, PiKRON <ppisa@pikron.com>
+ *
+ *  derived from pxamci.c by Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+#include <mach/mmc.h>
+
+#ifdef CONFIG_ARCH_MX2
+#include <mach/dma-mx1-mx2.h>
+#define HAS_DMA
+#endif
+
+#define DRIVER_NAME "imx-mmc"
+
+#define MMC_REG_STR_STP_CLK		0x00
+#define MMC_REG_STATUS			0x04
+#define MMC_REG_CLK_RATE		0x08
+#define MMC_REG_CMD_DAT_CONT		0x0C
+#define MMC_REG_RES_TO			0x10
+#define MMC_REG_READ_TO			0x14
+#define MMC_REG_BLK_LEN			0x18
+#define MMC_REG_NOB			0x1C
+#define MMC_REG_REV_NO			0x20
+#define MMC_REG_INT_CNTR		0x24
+#define MMC_REG_CMD			0x28
+#define MMC_REG_ARG			0x2C
+#define MMC_REG_RES_FIFO		0x34
+#define MMC_REG_BUFFER_ACCESS		0x38
+
+#define STR_STP_CLK_RESET               (1 << 3)
+#define STR_STP_CLK_START_CLK           (1 << 1)
+#define STR_STP_CLK_STOP_CLK            (1 << 0)
+
+#define STATUS_CARD_INSERTION		(1 << 31)
+#define STATUS_CARD_REMOVAL		(1 << 30)
+#define STATUS_YBUF_EMPTY		(1 << 29)
+#define STATUS_XBUF_EMPTY		(1 << 28)
+#define STATUS_YBUF_FULL		(1 << 27)
+#define STATUS_XBUF_FULL		(1 << 26)
+#define STATUS_BUF_UND_RUN		(1 << 25)
+#define STATUS_BUF_OVFL			(1 << 24)
+#define STATUS_SDIO_INT_ACTIVE		(1 << 14)
+#define STATUS_END_CMD_RESP		(1 << 13)
+#define STATUS_WRITE_OP_DONE		(1 << 12)
+#define STATUS_DATA_TRANS_DONE		(1 << 11)
+#define STATUS_READ_OP_DONE		(1 << 11)
+#define STATUS_WR_CRC_ERROR_CODE_MASK	(3 << 10)
+#define STATUS_CARD_BUS_CLK_RUN		(1 << 8)
+#define STATUS_BUF_READ_RDY		(1 << 7)
+#define STATUS_BUF_WRITE_RDY		(1 << 6)
+#define STATUS_RESP_CRC_ERR		(1 << 5)
+#define STATUS_CRC_READ_ERR		(1 << 3)
+#define STATUS_CRC_WRITE_ERR		(1 << 2)
+#define STATUS_TIME_OUT_RESP		(1 << 1)
+#define STATUS_TIME_OUT_READ		(1 << 0)
+#define STATUS_ERR_MASK			0x2f
+
+#define CMD_DAT_CONT_CMD_RESP_LONG_OFF	(1 << 12)
+#define CMD_DAT_CONT_STOP_READWAIT	(1 << 11)
+#define CMD_DAT_CONT_START_READWAIT	(1 << 10)
+#define CMD_DAT_CONT_BUS_WIDTH_4	(2 << 8)
+#define CMD_DAT_CONT_INIT		(1 << 7)
+#define CMD_DAT_CONT_WRITE		(1 << 4)
+#define CMD_DAT_CONT_DATA_ENABLE	(1 << 3)
+#define CMD_DAT_CONT_RESPONSE_48BIT_CRC	(1 << 0)
+#define CMD_DAT_CONT_RESPONSE_136BIT	(2 << 0)
+#define CMD_DAT_CONT_RESPONSE_48BIT	(3 << 0)
+
+#define INT_SDIO_INT_WKP_EN		(1 << 18)
+#define INT_CARD_INSERTION_WKP_EN	(1 << 17)
+#define INT_CARD_REMOVAL_WKP_EN		(1 << 16)
+#define INT_CARD_INSERTION_EN		(1 << 15)
+#define INT_CARD_REMOVAL_EN		(1 << 14)
+#define INT_SDIO_IRQ_EN			(1 << 13)
+#define INT_DAT0_EN			(1 << 12)
+#define INT_BUF_READ_EN			(1 << 4)
+#define INT_BUF_WRITE_EN		(1 << 3)
+#define INT_END_CMD_RES_EN		(1 << 2)
+#define INT_WRITE_OP_DONE_EN		(1 << 1)
+#define INT_READ_OP_EN			(1 << 0)
+
+struct mxcmci_host {
+	struct mmc_host		*mmc;
+	struct resource		*res;
+	void __iomem		*base;
+	int			irq;
+	int			detect_irq;
+	int			dma;
+	int			do_dma;
+	unsigned int		power_mode;
+	struct imxmmc_platform_data *pdata;
+
+	struct mmc_request	*req;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+
+	unsigned int		dma_nents;
+	unsigned int		datasize;
+	unsigned int		dma_dir;
+
+	u16			rev_no;
+	unsigned int		cmdat;
+
+	struct clk		*clk;
+
+	int			clock;
+
+	struct work_struct	datawork;
+};
+
+static inline int mxcmci_use_dma(struct mxcmci_host *host)
+{
+	return host->do_dma;
+}
+
+static void mxcmci_softreset(struct mxcmci_host *host)
+{
+	int i;
+
+	/* reset sequence */
+	writew(STR_STP_CLK_RESET, host->base + MMC_REG_STR_STP_CLK);
+	writew(STR_STP_CLK_RESET | STR_STP_CLK_START_CLK,
+			host->base + MMC_REG_STR_STP_CLK);
+
+	for (i = 0; i < 8; i++)
+		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
+
+	writew(0xff, host->base + MMC_REG_RES_TO);
+}
+
+static void mxcmci_setup_data(struct mxcmci_host *host, struct mmc_data *data)
+{
+	unsigned int nob = data->blocks;
+	unsigned int blksz = data->blksz;
+	unsigned int datasize = nob * blksz;
+#ifdef HAS_DMA
+	struct scatterlist *sg;
+	int i;
+#endif
+	if (data->flags & MMC_DATA_STREAM)
+		nob = 0xffff;
+
+	host->data = data;
+	data->bytes_xfered = 0;
+
+	writew(nob, host->base + MMC_REG_NOB);
+	writew(blksz, host->base + MMC_REG_BLK_LEN);
+	host->datasize = datasize;
+
+#ifdef HAS_DMA
+	for_each_sg(data->sg, sg, data->sg_len, i) {
+		if (sg->offset & 3 || sg->length & 3) {
+			host->do_dma = 0;
+			return;
+		}
+	}
+
+	if (data->flags & MMC_DATA_READ) {
+		host->dma_dir = DMA_FROM_DEVICE;
+		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
+					     data->sg_len,  host->dma_dir);
+
+		imx_dma_setup_sg(host->dma, data->sg, host->dma_nents, datasize,
+				 host->res->start + MMC_REG_BUFFER_ACCESS,
+				 DMA_MODE_READ);
+	} else {
+		host->dma_dir = DMA_TO_DEVICE;
+		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
+					     data->sg_len,  host->dma_dir);
+
+		imx_dma_setup_sg(host->dma, data->sg, host->dma_nents, datasize,
+				 host->res->start + MMC_REG_BUFFER_ACCESS,
+				 DMA_MODE_WRITE);
+	}
+
+	wmb();
+
+	imx_dma_enable(host->dma);
+#endif /* HAS_DMA */
+}
+
+static int mxcmci_start_cmd(struct mxcmci_host *host, struct mmc_command *cmd,
+		unsigned int cmdat)
+{
+	WARN_ON(host->cmd != NULL);
+	host->cmd = cmd;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1: /* short CRC, OPCODE */
+	case MMC_RSP_R1B:/* short CRC, OPCODE, BUSY */
+		cmdat |= CMD_DAT_CONT_RESPONSE_48BIT_CRC;
+		break;
+	case MMC_RSP_R2: /* long 136 bit + CRC */
+		cmdat |= CMD_DAT_CONT_RESPONSE_136BIT;
+		break;
+	case MMC_RSP_R3: /* short */
+		cmdat |= CMD_DAT_CONT_RESPONSE_48BIT;
+		break;
+	case MMC_RSP_NONE:
+		break;
+	default:
+		dev_err(mmc_dev(host->mmc), "unhandled response type 0x%x\n",
+				mmc_resp_type(cmd));
+		cmd->error = -EINVAL;
+		return -EINVAL;
+	}
+
+	if (mxcmci_use_dma(host))
+		writel(INT_READ_OP_EN | INT_WRITE_OP_DONE_EN |
+				INT_END_CMD_RES_EN,
+				host->base + MMC_REG_INT_CNTR);
+	else
+		writel(INT_END_CMD_RES_EN, host->base + MMC_REG_INT_CNTR);
+
+	writew(cmd->opcode, host->base + MMC_REG_CMD);
+	writel(cmd->arg, host->base + MMC_REG_ARG);
+	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
+
+	return 0;
+}
+
+static void mxcmci_finish_request(struct mxcmci_host *host,
+		struct mmc_request *req)
+{
+	writel(0, host->base + MMC_REG_INT_CNTR);
+
+	host->req = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	mmc_request_done(host->mmc, req);
+}
+
+static int mxcmci_finish_data(struct mxcmci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+	int data_error;
+
+#ifdef HAS_DMA
+	if (mxcmci_use_dma(host)) {
+		imx_dma_disable(host->dma);
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,
+				host->dma_dir);
+	}
+#endif
+
+	if (stat & STATUS_ERR_MASK) {
+		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",
+				stat);
+		if (stat & STATUS_CRC_READ_ERR) {
+			data->error = -EILSEQ;
+		} else if (stat & STATUS_CRC_WRITE_ERR) {
+			u32 err_code = (stat >> 9) & 0x3;
+			if (err_code == 2) /* No CRC response */
+				data->error = -ETIMEDOUT;
+			else
+				data->error = -EILSEQ;
+		} else if (stat & STATUS_TIME_OUT_READ) {
+			data->error = -ETIMEDOUT;
+		} else {
+			data->error = -EIO;
+		}
+	} else {
+		data->bytes_xfered = host->datasize;
+	}
+
+	data_error = data->error;
+
+	host->data = NULL;
+
+	return data_error;
+}
+
+static void mxcmci_read_response(struct mxcmci_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->cmd;
+	int i;
+	u32 a, b, c;
+
+	if (!cmd)
+		return;
+
+	if (stat & STATUS_TIME_OUT_RESP) {
+		dev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");
+		cmd->error = -ETIMEDOUT;
+	} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {
+		dev_dbg(mmc_dev(host->mmc), "cmd crc error\n");
+		cmd->error = -EILSEQ;
+	}
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			for (i = 0; i < 4; i++) {
+				a = readw(host->base + MMC_REG_RES_FIFO);
+				b = readw(host->base + MMC_REG_RES_FIFO);
+				cmd->resp[i] = a << 16 | b;
+			}
+		} else {
+			a = readw(host->base + MMC_REG_RES_FIFO);
+			b = readw(host->base + MMC_REG_RES_FIFO);
+			c = readw(host->base + MMC_REG_RES_FIFO);
+			cmd->resp[0] = a << 24 | b << 8 | c >> 8;
+		}
+	}
+}
+
+static int mxcmci_poll_status(struct mxcmci_host *host, u32 mask)
+{
+	u32 stat;
+	unsigned long timeout = jiffies + HZ;
+
+	do {
+		stat = readl(host->base + MMC_REG_STATUS);
+		if (stat & STATUS_ERR_MASK)
+			return stat;
+		if (time_after(jiffies, timeout))
+			return STATUS_TIME_OUT_READ;
+		if (stat & mask)
+			return 0;
+		cpu_relax();
+	} while (1);
+}
+
+static int mxcmci_pull(struct mxcmci_host *host, void *_buf, int bytes)
+{
+	unsigned int stat;
+	u32 *buf = _buf;
+
+	while (bytes > 3) {
+		stat = mxcmci_poll_status(host,
+				STATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);
+		if (stat)
+			return stat;
+		*buf++ = readl(host->base + MMC_REG_BUFFER_ACCESS);
+		bytes -= 4;
+	}
+
+	if (bytes) {
+		u8 *b = (u8 *)buf;
+		u32 tmp;
+
+		stat = mxcmci_poll_status(host,
+				STATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);
+		if (stat)
+			return stat;
+		tmp = readl(host->base + MMC_REG_BUFFER_ACCESS);
+		memcpy(b, &tmp, bytes);
+	}
+
+	return 0;
+}
+
+static int mxcmci_push(struct mxcmci_host *host, void *_buf, int bytes)
+{
+	unsigned int stat;
+	u32 *buf = _buf;
+
+	while (bytes > 3) {
+		stat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);
+		if (stat)
+			return stat;
+		writel(*buf++, host->base + MMC_REG_BUFFER_ACCESS);
+		bytes -= 4;
+	}
+
+	if (bytes) {
+		u8 *b = (u8 *)buf;
+		u32 tmp;
+
+		stat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);
+		if (stat)
+			return stat;
+
+		memcpy(&tmp, b, bytes);
+		writel(tmp, host->base + MMC_REG_BUFFER_ACCESS);
+	}
+
+	stat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);
+	if (stat)
+		return stat;
+
+	return 0;
+}
+
+static int mxcmci_transfer_data(struct mxcmci_host *host)
+{
+	struct mmc_data *data = host->req->data;
+	struct scatterlist *sg;
+	int stat, i;
+
+	host->datasize = 0;
+
+	host->data = data;
+	host->datasize = 0;
+
+	if (data->flags & MMC_DATA_READ) {
+		for_each_sg(data->sg, sg, data->sg_len, i) {
+			stat = mxcmci_pull(host, sg_virt(sg), sg->length);
+			if (stat)
+				return stat;
+			host->datasize += sg->length;
+		}
+	} else {
+		for_each_sg(data->sg, sg, data->sg_len, i) {
+			stat = mxcmci_push(host, sg_virt(sg), sg->length);
+			if (stat)
+				return stat;
+			host->datasize += sg->length;
+		}
+		stat = mxcmci_poll_status(host, STATUS_WRITE_OP_DONE);
+		if (stat)
+			return stat;
+	}
+	return 0;
+}
+
+static void mxcmci_datawork(struct work_struct *work)
+{
+	struct mxcmci_host *host = container_of(work, struct mxcmci_host,
+						  datawork);
+	int datastat = mxcmci_transfer_data(host);
+	mxcmci_finish_data(host, datastat);
+
+	if (host->req->stop) {
+		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
+			mxcmci_finish_request(host, host->req);
+			return;
+		}
+	} else {
+		mxcmci_finish_request(host, host->req);
+	}
+}
+
+#ifdef HAS_DMA
+static void mxcmci_data_done(struct mxcmci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+	int data_error;
+
+	if (!data)
+		return;
+
+	data_error = mxcmci_finish_data(host, stat);
+
+	mxcmci_read_response(host, stat);
+	host->cmd = NULL;
+
+	if (host->req->stop) {
+		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
+			mxcmci_finish_request(host, host->req);
+			return;
+		}
+	} else {
+		mxcmci_finish_request(host, host->req);
+	}
+}
+#endif /* HAS_DMA */
+
+static void mxcmci_cmd_done(struct mxcmci_host *host, unsigned int stat)
+{
+	mxcmci_read_response(host, stat);
+	host->cmd = NULL;
+
+	if (!host->data && host->req) {
+		mxcmci_finish_request(host, host->req);
+		return;
+	}
+
+	/* For the DMA case the DMA engine handles the data transfer
+	 * automatically. For non DMA we have to to it ourselves.
+	 * Don't do it in interrupt context though.
+	 */
+	if (!mxcmci_use_dma(host) && host->data)
+		schedule_work(&host->datawork);
+
+}
+
+static irqreturn_t mxcmci_irq(int irq, void *devid)
+{
+	struct mxcmci_host *host = devid;
+	u32 stat;
+
+	stat = readl(host->base + MMC_REG_STATUS);
+	writel(stat, host->base + MMC_REG_STATUS);
+
+	dev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);
+
+	if (stat & STATUS_END_CMD_RESP)
+		mxcmci_cmd_done(host, stat);
+#ifdef HAS_DMA
+	if (mxcmci_use_dma(host) &&
+		  (stat & (STATUS_DATA_TRANS_DONE | STATUS_WRITE_OP_DONE)))
+		mxcmci_data_done(host, stat);
+#endif
+	return IRQ_HANDLED;
+}
+
+static void mxcmci_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mxcmci_host *host = mmc_priv(mmc);
+	unsigned int cmdat = host->cmdat;
+
+	WARN_ON(host->req != NULL);
+
+	host->req = req;
+	host->cmdat &= ~CMD_DAT_CONT_INIT;
+#ifdef HAS_DMA
+	host->do_dma = 1;
+#endif
+	if (req->data) {
+		mxcmci_setup_data(host, req->data);
+
+		cmdat |= CMD_DAT_CONT_DATA_ENABLE;
+
+		if (req->data->flags & MMC_DATA_WRITE)
+			cmdat |= CMD_DAT_CONT_WRITE;
+	}
+
+	if (mxcmci_start_cmd(host, req->cmd, cmdat))
+		mxcmci_finish_request(host, req);
+}
+
+static void mxcmci_set_clk_rate(struct mxcmci_host *host, unsigned int clk_ios)
+{
+	unsigned int divider;
+	int prescaler = 0;
+	unsigned int clk_in = clk_get_rate(host->clk);
+
+	while (prescaler <= 0x800) {
+		for (divider = 1; divider <= 0xF; divider++) {
+			int x;
+
+			x = (clk_in / (divider + 1));
+
+			if (prescaler)
+				x /= (prescaler * 2);
+
+			if (x <= clk_ios)
+				break;
+		}
+		if (divider < 0x10)
+			break;
+
+		if (prescaler == 0)
+			prescaler = 1;
+		else
+			prescaler <<= 1;
+	}
+
+	writew((prescaler << 4) | divider, host->base + MMC_REG_CLK_RATE);
+
+	dev_dbg(mmc_dev(host->mmc), "scaler: %d divider: %d in: %d out: %d\n",
+			prescaler, divider, clk_in, clk_ios);
+}
+
+static void mxcmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mxcmci_host *host = mmc_priv(mmc);
+#ifdef HAS_DMA
+	unsigned int blen;
+	/*
+	 * use burstlen of 64 in 4 bit mode (--> reg value  0)
+	 * use burstlen of 16 in 1 bit mode (--> reg value 16)
+	 */
+	if (ios->bus_width == MMC_BUS_WIDTH_4)
+		blen = 0;
+	else
+		blen = 16;
+
+	imx_dma_config_burstlen(host->dma, blen);
+#endif
+	if (ios->bus_width == MMC_BUS_WIDTH_4)
+		host->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;
+	else
+		host->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;
+
+	if (host->power_mode != ios->power_mode) {
+		if (host->pdata->setpower)
+			host->pdata->setpower(mmc_dev(mmc), ios->vdd);
+		host->power_mode = ios->power_mode;
+		if (ios->power_mode == MMC_POWER_ON)
+			host->cmdat |= CMD_DAT_CONT_INIT;
+	}
+
+	if (ios->clock) {
+		mxcmci_set_clk_rate(host, ios->clock);
+		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
+	} else {
+		writew(STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
+	}
+
+	host->clock = ios->clock;
+}
+
+static irqreturn_t mxcmci_detect_irq(int irq, void *data)
+{
+	struct mmc_host *mmc = data;
+
+	dev_dbg(mmc_dev(mmc), "%s\n", __func__);
+
+	mmc_detect_change(mmc, msecs_to_jiffies(250));
+	return IRQ_HANDLED;
+}
+
+static int mxcmci_get_ro(struct mmc_host *mmc)
+{
+	struct mxcmci_host *host = mmc_priv(mmc);
+
+	if (host->pdata->get_ro)
+		return !!host->pdata->get_ro(mmc_dev(mmc));
+	/*
+	 * Board doesn't support read only detection; let the mmc core
+	 * decide what to do.
+	 */
+	return -ENOSYS;
+}
+
+
+static const struct mmc_host_ops mxcmci_ops = {
+	.request	= mxcmci_request,
+	.set_ios	= mxcmci_set_ios,
+	.get_ro		= mxcmci_get_ro,
+};
+
+static int mxcmci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct mxcmci_host *host = NULL;
+	struct resource *r;
+	int ret = 0, irq;
+
+	printk(KERN_INFO "i.MX SDHC driver\n");
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!r || irq < 0)
+		return -ENXIO;
+
+	r = request_mem_region(r->start, resource_size(r), pdev->name);
+	if (!r)
+		return -EBUSY;
+
+	mmc = mmc_alloc_host(sizeof(struct mxcmci_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto out_release_mem;
+	}
+
+	mmc->ops = &mxcmci_ops;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+
+	/* MMC core transfer sizes tunable parameters */
+	mmc->max_hw_segs = 64;
+	mmc->max_phys_segs = 64;
+	mmc->max_blk_size = 2048;
+	mmc->max_blk_count = 65535;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_seg_size;
+
+	host = mmc_priv(mmc);
+	host->base = ioremap(r->start, resource_size(r));
+	if (!host->base) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	host->mmc = mmc;
+	host->pdata = pdev->dev.platform_data;
+	if (!host->pdata) {
+		ret = -ENODEV;
+		dev_err(&pdev->dev, "No platform data provided!\n");
+		goto out_iounmap;
+	}
+
+	host->res = r;
+	host->irq = irq;
+
+	host->clk = clk_get(&pdev->dev, "sdhc_clk");
+	if (IS_ERR(host->clk)) {
+		ret = PTR_ERR(host->clk);
+		goto out_iounmap;
+	}
+	clk_enable(host->clk);
+
+	mxcmci_softreset(host);
+
+	host->rev_no = readw(host->base + MMC_REG_REV_NO);
+	if (host->rev_no != 0x400) {
+		ret = -ENODEV;
+		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
+			host->rev_no);
+		goto out_clk_put;
+	}
+
+	mmc->f_min = clk_get_rate(host->clk) >> 7;
+	mmc->f_max = clk_get_rate(host->clk) >> 1;
+
+	/* recommended in data sheet */
+	writew(0x2db4, host->base + MMC_REG_READ_TO);
+
+	writel(0, host->base + MMC_REG_INT_CNTR);
+
+#ifdef HAS_DMA
+	host->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);
+	if (host->dma < 0) {
+		dev_err(mmc_dev(host->mmc), "imx_dma_request_by_prio failed\n");
+		ret = -EBUSY;
+		goto out_clk_put;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!r) {
+		ret = -ENXIO;
+		goto out_free_dma;
+	}
+
+	ret = imx_dma_config_channel(host->dma,
+				     IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_FIFO,
+				     IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+				     r->start, 0);
+	if (ret) {
+		dev_err(mmc_dev(host->mmc), "failed to config DMA channel\n");
+		goto out_free_dma;
+	}
+#endif
+	INIT_WORK(&host->datawork, mxcmci_datawork);
+
+	ret = request_irq(host->irq, mxcmci_irq, 0, DRIVER_NAME, host);
+	if (ret)
+		goto out_free_dma;
+
+	platform_set_drvdata(pdev, mmc);
+
+	if (host->pdata->init) {
+		ret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,
+				host->mmc);
+		if (ret)
+			goto out_free_irq;
+	}
+
+	mmc_add_host(mmc);
+
+	return 0;
+
+out_free_irq:
+	free_irq(host->irq, host);
+out_free_dma:
+#ifdef HAS_DMA
+	imx_dma_free(host->dma);
+#endif
+out_clk_put:
+	clk_disable(host->clk);
+	clk_put(host->clk);
+out_iounmap:
+	iounmap(host->base);
+out_free:
+	mmc_free_host(mmc);
+out_release_mem:
+	release_mem_region(host->res->start, resource_size(host->res));
+	return ret;
+}
+
+static int mxcmci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct mxcmci_host *host = mmc_priv(mmc);
+
+	platform_set_drvdata(pdev, NULL);
+
+	mmc_remove_host(mmc);
+
+	if (host->pdata->exit)
+		host->pdata->exit(&pdev->dev, mmc);
+
+	free_irq(host->irq, host);
+	iounmap(host->base);
+#ifdef HAS_DMA
+	imx_dma_free(host->dma);
+#endif
+	clk_disable(host->clk);
+	clk_put(host->clk);
+
+	release_mem_region(host->res->start, resource_size(host->res));
+	release_resource(host->res);
+
+	mmc_free_host(mmc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mxcmci_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (mmc)
+		ret = mmc_suspend_host(mmc, state);
+
+	return ret;
+}
+
+static int mxcmci_resume(struct platform_device *dev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct mxcmci_host *host;
+	int ret = 0;
+
+	if (mmc) {
+		host = mmc_priv(mmc);
+		ret = mmc_resume_host(mmc);
+	}
+
+	return ret;
+}
+#else
+#define mxcmci_suspend  NULL
+#define mxcmci_resume   NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver mxcmci_driver = {
+	.probe		= mxcmci_probe,
+	.remove		= mxcmci_remove,
+	.suspend	= mxcmci_suspend,
+	.resume		= mxcmci_resume,
+	.driver		= {
+		.name		= DRIVER_NAME,
+		.owner		= THIS_MODULE,
+	}
+};
+
+static int __init mxcmci_init(void)
+{
+	return platform_driver_register(&mxcmci_driver);
+}
+
+static void __exit mxcmci_exit(void)
+{
+	platform_driver_unregister(&mxcmci_driver);
+}
+
+module_init(mxcmci_init);
+module_exit(mxcmci_exit);
+
+MODULE_DESCRIPTION("i.MX Multimedia Card Interface Driver");
+MODULE_AUTHOR("Sascha Hauer, Pengutronix");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:imx-mmc");
-- 
1.6.5.2

