From 55d66ce7e713814b895444f4b4a30c1e5f1aed75 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 2 Sep 2009 15:22:13 +0800
Subject: [PATCH] mx5/mach: add common stuff of mach level for i.MX5 series

Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Add Makefile, Kconfig and MSL(machine specific layer) drivers for
i.MX5 series MCU and SOC device registraion. The MSL drivers include
gpio, bus clock, dma and power management.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-mx5/Kconfig            |  110 ++
 arch/arm/mach-mx5/Makefile           |   19 +
 arch/arm/mach-mx5/Makefile.boot      |    3 +
 arch/arm/mach-mx5/bus_freq.c         |  122 ++
 arch/arm/mach-mx5/clock.c            | 3279 ++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx5/cpu.c              |   60 +
 arch/arm/mach-mx5/crm_regs.h         |  680 +++++++
 arch/arm/mach-mx5/devices.c          |  828 +++++++++
 arch/arm/mach-mx5/dma.c              |  574 ++++++
 arch/arm/mach-mx5/dummy_gpio.c       |  108 ++
 arch/arm/mach-mx5/iomux.c            |  236 +++
 arch/arm/mach-mx5/iomux.h            |  244 +++
 arch/arm/mach-mx5/lpmodes.c          |  205 +++
 arch/arm/mach-mx5/mm.c               |   85 +
 arch/arm/mach-mx5/mx51_pins.h        |  361 ++++
 arch/arm/mach-mx5/pm.c               |  149 ++
 arch/arm/mach-mx5/sdma_script_code.h |  170 ++
 arch/arm/mach-mx5/serial.c           |  146 ++
 arch/arm/mach-mx5/suspend.S          |  145 ++
 arch/arm/mach-mx5/system.c           |  205 +++
 arch/arm/mach-mx5/usb.h              |  102 ++
 arch/arm/mach-mx5/usb_dr.c           |  216 +++
 arch/arm/mach-mx5/usb_h1.c           |  134 ++
 arch/arm/mach-mx5/usb_h2.c           |  120 ++
 arch/arm/mach-mx5/wfi.S              |  427 +++++
 25 files changed, 8728 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx5/Kconfig
 create mode 100644 arch/arm/mach-mx5/Makefile
 create mode 100644 arch/arm/mach-mx5/Makefile.boot
 create mode 100644 arch/arm/mach-mx5/bus_freq.c
 create mode 100644 arch/arm/mach-mx5/clock.c
 create mode 100644 arch/arm/mach-mx5/cpu.c
 create mode 100644 arch/arm/mach-mx5/crm_regs.h
 create mode 100644 arch/arm/mach-mx5/devices.c
 create mode 100644 arch/arm/mach-mx5/dma.c
 create mode 100644 arch/arm/mach-mx5/dummy_gpio.c
 create mode 100644 arch/arm/mach-mx5/iomux.c
 create mode 100644 arch/arm/mach-mx5/iomux.h
 create mode 100644 arch/arm/mach-mx5/lpmodes.c
 create mode 100644 arch/arm/mach-mx5/mm.c
 create mode 100644 arch/arm/mach-mx5/mx51_pins.h
 create mode 100644 arch/arm/mach-mx5/pm.c
 create mode 100644 arch/arm/mach-mx5/sdma_script_code.h
 create mode 100644 arch/arm/mach-mx5/serial.c
 create mode 100644 arch/arm/mach-mx5/suspend.S
 create mode 100644 arch/arm/mach-mx5/system.c
 create mode 100644 arch/arm/mach-mx5/usb.h
 create mode 100644 arch/arm/mach-mx5/usb_dr.c
 create mode 100644 arch/arm/mach-mx5/usb_h1.c
 create mode 100644 arch/arm/mach-mx5/usb_h2.c
 create mode 100644 arch/arm/mach-mx5/wfi.S

diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
new file mode 100644
index 0000000..0654c50
--- /dev/null
+++ b/arch/arm/mach-mx5/Kconfig
@@ -0,0 +1,110 @@
+if ARCH_MX5
+
+config ARCH_MX51
+	bool
+
+config ARCH_MX515
+	bool
+
+comment "MX5 Platforms:"
+
+config MACH_MX51_3DS
+	bool "support MX51PDK(3DS)"
+	select ARCH_MX51
+	select ARCH_MX515
+	select ARCH_REQUIRE_GPIOLIB
+	select USB_ARCH_HAS_EHCI
+	default y
+	help
+	  Include support for MX51PDK (3DS) platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MXC_SDMA_API
+	bool "Use SDMA API"
+	default y
+	help
+	  This selects the Freescale MXC SDMA API.
+	  If unsure, say N.
+
+menu "SDMA options"
+	depends on MXC_SDMA_API
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA transfer"
+	default n
+	help
+	  Support Internal RAM as SDMA buffer or control structures.
+
+config SDMA_IRAM_SIZE
+	hex "Reserved bytes of IRAM for SDMA (0x800-0x1000)"
+	range 0x800 0x1000
+	depends on SDMA_IRAM
+	default "0x1000"
+	help
+	  Set the size of IRAM for SDMA. It must be a multiple of 512bytes.
+endmenu
+
+menu "Device options"
+
+config ARCH_MXC_HAS_NFC_V3
+	bool "MXC NFC Hardware Version 3"
+	depends on ARCH_MX51
+	default y
+	help
+	  This selects the Freescale MXC Nand Flash Controller Hardware Version 3
+	  If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3_2
+	bool "MXC NFC Hardware Version 3.2"
+	depends on ARCH_MXC_HAS_NFC_V3
+	default y
+	help
+	  This selects the Freescale MXC Nand Flash Controller Hardware Version 3.1
+	  If unsure, say N.
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX51 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX51 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX51 I2C3 module.
+endmenu
+
+config MXC_DVFS_CORE
+	bool "MXC dynamic voltage and frequency scale support"
+	default y
+	depends on PM
+
+config MXC_USB_COMMON
+	bool "MXC usb xcvr common interface"
+	default y
+	depends on USB
+
+menu "USB xcvr selections"
+	depends on MXC_USB_COMMON
+
+config USB_COMMON_ISP1504
+	bool "ISP1504 usb xcvr driver"
+	default y if USB_EHCI_ARC
+
+config USB_COMMON_UTMI
+	bool "In chip UTMI usb xcvr driver"
+	default y if UTMI_MXC
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
new file mode 100644
index 0000000..d9eead0
--- /dev/null
+++ b/arch/arm/mach-mx5/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+
+obj-y				:= system.o iomux.o cpu.o mm.o clock.o \
+				   devices.o serial.o dummy_gpio.o
+
+obj-$(CONFIG_PM)		+= pm.o bus_freq.o wfi.o suspend.o lpmodes.o
+obj-$(CONFIG_MACH_MX51_3DS)	+= mx51_3stack.o mx51_3stack_gpio.o
+
+
+obj-$(CONFIG_MXC_SDMA_API)	+= dma.o
+obj-$(CONFIG_REGULATOR_MC13892)	+= mx51_3stack_pmic_mc13892.o
+obj-$(CONFIG_USB_EHCI_ARC_H1)	+= usb_h1.o
+obj-$(CONFIG_USB_EHCI_ARC_H2)	+= usb_h2.o
+obj-$(CONFIG_UTMI_MXC)		+= usb_dr.o
diff --git a/arch/arm/mach-mx5/Makefile.boot b/arch/arm/mach-mx5/Makefile.boot
new file mode 100644
index 0000000..89afeef
--- /dev/null
+++ b/arch/arm/mach-mx5/Makefile.boot
@@ -0,0 +1,3 @@
+zreladdr-y	:= 0x90008000
+params_phys-y	:= 0x90000100
+initrd_phys-y	:= 0x90800000
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
new file mode 100644
index 0000000..c454ffa
--- /dev/null
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <linux/regulator/consumer.h>
+
+struct clk *main_bus_clk;
+struct clk *pll2;
+struct clk *axi_a_clk;
+struct clk *axi_b_clk;
+struct clk *axi_c_clk;
+struct clk *emi_core_clk;
+struct clk *nfc_clk;
+struct clk *ahb_clk;
+struct clk *vpu_clk;
+struct clk *vpu_core_clk;
+struct clk *arm_axi_clk;
+struct clk *ddr_clk;
+struct clk *ipu_clk;
+struct clk *periph_apm_clk;
+struct clk *lp_apm;
+struct clk *osc;
+struct regulator *lp_regulator;
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+char *gp_reg_id = "SW1";
+char *lp_reg_id = "SW2";
+
+int set_low_bus_freq(void)
+{
+	return 0;
+}
+
+int set_high_bus_freq(void)
+{
+	return 0;
+}
+
+int low_freq_bus_used(void)
+{
+	return 0;
+}
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		   },
+	.probe = busfreq_probe,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
new file mode 100644
index 0000000..b4b9061
--- /dev/null
+++ b/arch/arm/mach-mx5/clock.c
@@ -0,0 +1,3279 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/clock.h>
+#include <mach/spba.h>
+
+#include "crm_regs.h"
+
+static unsigned long pll_base[] = {
+	(unsigned long)MXC_DPLL1_BASE,
+	(unsigned long)MXC_DPLL2_BASE,
+	(unsigned long)MXC_DPLL3_BASE,
+};
+
+static struct clk pll1_main_clk;
+static struct clk pll1_sw_clk;
+static struct clk pll2_sw_clk;
+static struct clk pll3_sw_clk;
+static struct clk lp_apm_clk;
+static struct clk tve_clk;
+static struct clk emi_fast_clk;
+static struct clk emi_slow_clk;
+static struct clk emi_intr_clk;
+static struct clk ddr_clk;
+static struct clk ipu_clk[];
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk ddr_hf_clk;
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+
+int cpu_wp_nr;
+
+extern int mxc_jtag_enabled;
+extern int cpufreq_trig_needed;
+
+static int cpu_clk_set_wp(int wp);
+extern void propagate_rate(struct clk *tclk);
+struct cpu_wp *(*get_cpu_wp)(int *wp);
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGR_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else
+		BUG();
+
+	return 0;
+}
+
+/*
+ * For the ddr muxed input clock
+ */
+static inline u32 _get_mux_ddr(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3, struct clk *m4)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else
+		BUG();
+
+	return 0;
+}
+
+static inline unsigned long _get_pll_base(struct clk *pll)
+{
+	if (pll == &pll1_main_clk)
+		return pll_base[0];
+	else if (pll == &pll2_sw_clk)
+		return pll_base[1];
+	else if (pll == &pll3_sw_clk)
+		return pll_base[2];
+	else
+		BUG();
+
+	return 0;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ckih2_clk = {
+	.name = "ckih2",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk osc_clk = {
+	.name = "osc",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.flags = RATE_PROPAGATES,
+};
+
+static void _fpm_recalc(struct clk *clk)
+{
+	clk->rate = ckil_clk.rate * 512;
+	if ((__raw_readl(MXC_CCM_CCR) & MXC_CCM_CCR_FPM_MULT_MASK) != 0)
+		clk->rate *= 2;
+
+}
+
+static int _fpm_enable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg |= MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+	return 0;
+}
+
+static void _fpm_disable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg &= ~MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+}
+
+static struct clk fpm_clk = {
+	.name = "fpm_clk",
+	.parent = &ckil_clk,
+	.recalc = _fpm_recalc,
+	.enable = _fpm_enable,
+	.disable = _fpm_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _fpm_div2_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate / 2;
+}
+
+static struct clk fpm_div2_clk = {
+	.name = "fpm_div2_clk",
+	.parent = &fpm_clk,
+	.recalc = _fpm_div2_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	unsigned long pllbase;
+	s64 temp;
+
+	pllbase = _get_pll_base(clk);
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = 2 * clk->parent->rate;
+	if (dbl != 0)
+		ref_clk *= 2;
+
+	ref_clk /= (pdf + 1);
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	clk->rate = temp;
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 pllbase;
+
+	long mfi, pdf, mfn, mfd = 999999;
+	s64 temp64;
+	unsigned long quad_parent_rate;
+	unsigned long pll_hfsm, dp_ctl;
+
+	pllbase = _get_pll_base(clk);
+
+	quad_parent_rate = 4*clk->parent->rate;
+	pdf = mfi = -1;
+	while (++pdf < 16 && mfi < 5)
+		mfi = rate * (pdf+1) / quad_parent_rate;
+	if (mfi > 15)
+		return -1;
+	pdf--;
+
+	temp64 = rate*(pdf+1) - quad_parent_rate*mfi;
+	do_div(temp64, quad_parent_rate/1000000);
+	mfn = (long)temp64;
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	/* use dpdck0_2 */
+	__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	if (pll_hfsm == 0) {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);
+	} else {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+
+	return 0;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	u32 pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_LRF))
+		;
+
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	u32 pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static struct clk pll1_main_clk = {
+	.name = "pll1_main_clk",
+	.parent = &osc_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll1_main_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+	} else {
+		if (parent == &lp_apm_clk) {
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+			reg = __raw_readl(MXC_CCM_CCSR);
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+		} else {
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+			__raw_writel(reg, MXC_CCM_CCSR);
+			reg = __raw_readl(MXC_CCM_CCSR);
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+
+		}
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+	return 0;
+}
+
+static void _clk_pll1_sw_recalc(struct clk *clk)
+{
+	u32 reg, div;
+	div = 1;
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (clk->parent == &pll2_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;
+	} else if (clk->parent == &pll3_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;
+	}
+	clk->rate = clk->parent->rate / div;
+}
+
+/* pll1 switch clock */
+static struct clk pll1_sw_clk = {
+	.name = "pll1_sw_clk",
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.recalc = _clk_pll1_sw_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll2_main_clk. These two clocks should always be the same */
+static struct clk pll2_sw_clk = {
+	.name = "pll2",
+	.parent = &osc_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll3_main_clk. These two clocks should always be the same */
+static struct clk pll3_sw_clk = {
+	.name = "pll3",
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &osc_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	else if (parent == &fpm_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static struct clk lp_apm_clk = {
+	.name = "lp_apm",
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_arm_recalc(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i > cpu_wp_nr)
+		return -EINVAL;
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_wp_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &pll1_sw_clk,
+	.recalc = _clk_arm_recalc,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
+static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll3_sw_clk, &lp_apm_clk, NULL);
+
+	reg = __raw_readl(MXC_CCM_CBCMR) & ~MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk periph_apm_clk = {
+	.name = "periph_apm_clk",
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_periph_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+/* TODO: Need to sync with GPC to determine if DVFS is in place so that
+ * the DVFS_PODF divider can be applied in CDCR register.
+ */
+static void _clk_main_bus_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate;
+}
+
+static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+	if (emi_intr_clk.usecount == 0)
+		emi_intr_clk.enable(&emi_intr_clk);
+
+	if (parent == &pll2_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) &
+		    ~MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else if (parent == &periph_apm_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) | MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else {
+		return -EINVAL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+	if (emi_intr_clk.usecount == 0)
+		emi_intr_clk.disable(&emi_intr_clk);
+
+	return 0;
+}
+
+static struct clk main_bus_clk = {
+	.name = "main_bus_clk",
+	.parent = &pll2_sw_clk,
+	.set_parent = _clk_main_bus_set_parent,
+	.recalc = _clk_main_bus_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_axi_a_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk axi_a_clk = {
+	.name = "axi_a_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_axi_a_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_ddr_hf_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_DDR_PODF_MASK) >>
+	       MXC_CCM_CBCDR_DDR_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk ddr_hf_clk = {
+	.name = "ddr_hf_clk",
+	.parent = &pll1_sw_clk,
+	.recalc = _clk_ddr_hf_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_axi_b_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk axi_b_clk = {
+	.name = "axi_b_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_axi_b_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_ahb_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_ahb_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_max_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with MAX when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+
+static void _clk_max_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable_inwait(clk);
+
+	/* No Handshake with MAX when LPM is entered as its disabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk ahb_max_clk = {
+	.name = "max_clk",
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
+static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk) {
+		reg |= MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else if (parent == &main_bus_clk) {
+		reg &= ~MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else {
+		BUG();
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	return 0;
+}
+
+static void _clk_emi_slow_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_intr_clk.usecount == 0)
+		emi_intr_clk.enable(&emi_intr_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	clk->rate = rate;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_intr_clk.usecount == 0)
+		emi_intr_clk.disable(&emi_intr_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+
+static struct clk emi_slow_clk = {
+	.name = "emi_slow_clk",
+	.parent = &main_bus_clk,
+	.set_parent = _clk_emi_slow_set_parent,
+	.recalc = _clk_emi_slow_recalc,
+	.set_rate = _clk_emi_slow_set_rate,
+	.round_rate = _clk_emi_slow_round_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahbmux1_clk = {
+	.name = "ahbmux1_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk ahbmux2_clk = {
+	.name = "ahbmux2_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG9_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+
+static struct clk emi_fast_clk = {
+	.name = "emi_fast_clk",
+	.parent = &ddr_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG7_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk emi_intr_clk = {
+	.name = "emi_intr_clk",
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG9_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
+	       MXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_ipg_per_recalc(struct clk *clk)
+{
+	u32 reg, prediv1, prediv2, podf;
+
+	if (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {
+		/* the main_bus_clk is the one before the DVFS engine */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		prediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;
+		prediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
+			MXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv1 * prediv2 * podf);
+	} else if (clk->parent == &ipg_clk) {
+		clk->rate = ipg_clk.rate;
+	} else {
+		BUG();
+	}
+}
+
+static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &main_bus_clk, &lp_apm_clk, &ipg_clk, NULL);
+	if (mux == 2) {
+		reg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+		if (mux == 0)
+			reg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+		else
+			reg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk ipg_perclk = {
+	.name = "ipg_perclk",
+	.parent = &lp_apm_clk,
+	.recalc = _clk_ipg_per_recalc,
+	.set_parent = _clk_ipg_per_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk aips_tz1_clk = {
+	.name = "aips_tz1_clk",
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.name = "aips_tz2_clk",
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk gpc_dvfs_clk = {
+	.name = "gpc_dvfs_clk",
+	.parent = &aips_tz1_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ahb_clk",
+	 .parent = &ahb_clk,
+	 .secondary = &emi_fast_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG15_OFFSET,
+	 .enable = _clk_sdma_enable,
+	 .disable = _clk_sdma_disable,
+	 },
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ipg_clk,
+#ifdef CONFIG_SDMA_IRAM
+	 .secondary = &emi_intr_clk,
+#endif
+	 },
+};
+
+static int _clk_ipu_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_IPU_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* Handshake with IPU when LPM is entered as its enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+
+	return 0;
+}
+
+static void _clk_ipu_disable(struct clk *clk)
+{
+	u32 reg;
+	_clk_disable(clk);
+
+	/* No handshake with IPU whe dividers are changed
+	 * as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* No handshake with IPU when LPM is entered as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+}
+
+
+static struct clk ipu_clk[] = {
+	{
+	.name = "ipu_clk",
+	.parent = &ahb_clk,
+	.secondary = &ipu_clk[1],
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG5_OFFSET,
+	.enable = _clk_ipu_enable,
+	.disable = _clk_ipu_disable,
+	},
+	{
+	 .name = "ipu_sec_clk",
+	 .parent = &emi_fast_clk,
+	 .secondary = &ahbmux1_clk,
+	}
+};
+
+static int _clk_ipu_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg &= ~MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id);
+	if (parent == &pll3_sw_clk)
+		;
+	else if (parent == &osc_clk)
+		reg |= 1 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &ckih_clk)
+		reg |= 2 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &tve_clk)
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else		/* Assume any other clock is external clock pin */
+		reg |= 4 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_ipu_di_recalc(struct clk *clk)
+{
+	u32 reg, div, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = (reg & MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id)) >>
+		MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	if (mux == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_DI_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET) + 1;
+		clk->rate = clk->parent->rate / div;
+	} else if (mux == 3) {
+		clk->rate = clk->parent->rate / 8;
+	} else {
+		clk->rate = clk->parent->rate;
+	}
+}
+
+static struct clk ipu_di_clk[] = {
+	{
+	.name = "ipu_di0_clk",
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG5_OFFSET,
+	.recalc = _clk_ipu_di_recalc,
+	.set_parent = _clk_ipu_di_set_parent,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.name = "ipu_di1_clk",
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG6_OFFSET,
+	.recalc = _clk_ipu_di_recalc,
+	.set_parent = _clk_ipu_di_set_parent,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+};
+
+static int _clk_csi0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_csi0_recalc(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / (pred * podf);
+}
+
+static unsigned long _clk_csi0_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static int _clk_csi0_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static struct clk csi0_clk = {
+	.name = "csi_mclk1",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi0_set_parent,
+	.recalc = _clk_csi0_recalc,
+	.round_rate = _clk_csi0_round_rate,
+	.set_rate = _clk_csi0_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_csi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_csi1_recalc(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / (pred * podf);
+}
+
+static unsigned long _clk_csi1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static int _clk_csi1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static struct clk csi1_clk = {
+	.name = "csi_mclk2",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi1_set_parent,
+	.recalc = _clk_csi1_recalc,
+	.round_rate = _clk_csi1_round_rate,
+	.set_rate = _clk_csi1_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static int _clk_hsc_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_hsc_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with HSC as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static struct clk mipi_esc_clk = {
+	.name = "mipi_esc_clk",
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG5_OFFSET,
+};
+
+static struct clk mipi_hsc2_clk = {
+	.name = "mipi_hsc2_clk",
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG4_OFFSET,
+	.secondary = &mipi_esc_clk,
+};
+
+static struct clk mipi_hsc1_clk = {
+	.name = "mipi_hsc1_clk",
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG3_OFFSET,
+	.secondary = &mipi_hsc2_clk,
+};
+
+static struct clk mipi_hsp_clk = {
+	.name = "mipi_hsp_clk",
+	.parent = &ipu_clk[0],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG6_OFFSET,
+	.enable = _clk_hsc_enable,
+	.disable = _clk_hsc_disable,
+	.secondary = &mipi_hsc1_clk,
+};
+
+static int _clk_tve_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+
+	if (parent == &pll3_sw_clk) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_CLK_SEL);
+	} else if (parent == &osc_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg &= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else if (parent == &ckih_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg |= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static void _clk_tve_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_TVE_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET) + 1;
+		clk->rate = clk->parent->rate / div;
+	} else {
+		clk->rate = clk->parent->rate;
+	}
+}
+
+static unsigned long _clk_tve_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+		return -EINVAL;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+static int _clk_tve_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+		return -EINVAL;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	div--;
+	reg = __raw_readl(MXC_CCM_CDCDR) & ~MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+	reg |= div << MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+	clk->rate = rate;
+	return 0;
+}
+
+static struct clk tve_clk = {
+	.name = "tve_clk",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_tve_set_parent,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG15_OFFSET,
+	.recalc = _clk_tve_recalc,
+	.round_rate = _clk_tve_round_rate,
+	.set_rate = _clk_tve_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk spba_clk = {
+	.name = "spba_clk",
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static void _clk_uart_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk uart_main_clk = {
+	.name = "uart_main_clk",
+	.parent = &pll2_sw_clk,
+	.recalc = _clk_uart_recalc,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz1_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG3_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz1_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk gpt_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &gpt_clk[1],
+	 },
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "gpt_32k_clk",
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm1_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm1_clk[1],
+	 },
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "pwm_32k_clk",
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm2_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .parent = &ipg_perclk,
+	 .id = 1,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm2_clk[1],
+	 },
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "pwm_32k_clk",
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static void _clk_hsi2c_serial_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR3);
+	prediv = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static struct clk hsi2c_serial_clk = {
+	.name = "hsi2c_serial_clk",
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.secondary = &spba_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGR1_CG11_OFFSET,
+	.recalc = _clk_hsi2c_serial_recalc,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk hsi2c_clk = {
+	.name = "hsi2c_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGR1_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static void _clk_cspi_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.name = "cspi_main_clk",
+	.parent = &pll3_sw_clk,
+	.recalc = _clk_cspi_recalc,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi3_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &cspi_main_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG13_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &cspi3_clk[1],
+	 },
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 },
+};
+
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.name = "ssi_lp_apm_clk",
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .secondary = &ssi1_clk[1],
+	 .recalc = _clk_ssi1_recalc,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi1_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_dep_clk",
+	 .id = 0,
+	 .parent = &aips_tz2_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk,
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .secondary = &ssi2_clk[1],
+	 .recalc = _clk_ssi2_recalc,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi2_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_dep_clk",
+	 .id = 1,
+	 .parent = &spba_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk,
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static void _clk_ssi_ext1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	clk->rate = clk->parent->rate;
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv * podf);
+	}
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext1_clk = {
+	.name = "ssi_ext1_clk",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.recalc = _clk_ssi_ext1_recalc,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGR3_CG14_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static void _clk_ssi_ext2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	clk->rate = clk->parent->rate;
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv * podf);
+	}
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.name = "ssi_ext2_clk",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.recalc = _clk_ssi_ext2_recalc,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGR3_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.secondary = &aips_tz2_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax1_clk = {
+	 .name = "tmax1_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 };
+
+static struct clk tmax2_clk = {
+	 .name = "tmax2_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG1_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk tmax3_clk = {
+	 .name = "tmax3_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG2_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static void _clk_usboh3_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_usboh3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk usboh3_clk[] = {
+	{
+	 .name = "usboh3_clk",
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_usboh3_set_parent,
+	 .recalc = _clk_usboh3_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG14_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &usboh3_clk[1],
+	 },
+	{
+	 .name = "usb_ahb_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG13_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &usboh3_clk[2],
+	 },
+	{
+	 .name = "usb_sec_clk",
+	 .parent = &tmax2_clk,
+	 .secondary = &emi_fast_clk,
+	 },
+};
+
+static void _clk_usb_phy_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		prediv = ((reg & MXC_CCM_CDCDR_USB_PHY_PRED_MASK) >>
+			  MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_USB_PHY_PODF_MASK) >>
+			MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET) + 1;
+
+		clk->rate = clk->parent->rate / (prediv * podf);
+	} else
+		clk->rate = clk->parent->rate;
+}
+
+static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &osc_clk)
+		reg &= ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else if (parent == &pll3_sw_clk)
+		reg |= MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk usb_phy_clk = {
+	.name = "usb_phy_clk",
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.recalc = _clk_usb_phy_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG0_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk esdhc_dep_clks = {
+	 .name = "sd_dep_clk",
+	 .parent = &spba_clk,
+	 .secondary = &emi_fast_clk,
+};
+
+
+static void _clk_esdhc1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc1_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esdhc1_set_parent,
+	 .recalc = _clk_esdhc1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc1_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+
+};
+
+static void _clk_esdhc2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc2_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esdhc2_set_parent,
+	 .recalc = _clk_esdhc2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc2_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;
+	else if (parent == &esdhc2_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc3_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 2,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc3_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG5_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &ahb_max_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+
+static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else if (parent == &esdhc2_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc4_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 3,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc4_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG7_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG6_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_sim_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR2) & ~MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_sim_recalc(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	pred = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / (pred * podf);
+}
+
+static unsigned long _clk_sim_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static int _clk_sim_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set SIM clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR2) &
+	    ~(MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK |
+	      MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR2);
+
+	clk->rate = rate;
+	return 0;
+
+}
+
+static struct clk sim_clk[] = {
+	{
+	 .name = "sim_clk",
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_sim_set_parent,
+	 .secondary = &sim_clk[1],
+	 .recalc = _clk_sim_recalc,
+	 .round_rate = _clk_sim_round_rate,
+	 .set_rate = _clk_sim_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "sim_ipg_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static void _clk_nfc_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_NFC_PODF_MASK) >>
+	       MXC_CCM_CBCDR_NFC_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk emi_enfc_clk = {
+	.name = "nfc_clk",
+	.parent = &emi_slow_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG10_OFFSET,
+	.disable = _clk_disable_inwait,
+	.recalc = _clk_nfc_recalc,
+};
+
+static int _clk_spdif_xtal_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &osc_clk, &ckih_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk spdif_xtal_clk = {
+	.name = "spdif_xtal_clk",
+	.parent = &osc_clk,
+	.set_parent = _clk_spdif_xtal_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_spdif0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF0_COM;
+	if (parent != &ssi1_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF0_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_spdif0_recalc(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	if (clk->parent == &ssi1_clk[0]) {
+		clk->rate = clk->parent->rate;
+	} else {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (pred * podf);
+	}
+}
+
+static struct clk spdif0_clk[] = {
+	{
+	.name = "spdif_clk",
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif0_set_parent,
+	.recalc = _clk_spdif0_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG13_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	 .name = "spdif_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGR5_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_spdif1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF1_COM;
+	if (parent != &ssi2_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF1_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static void _clk_spdif1_recalc(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	if (clk->parent == &ssi2_clk[0]) {
+		clk->rate = clk->parent->rate;
+	} else {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (pred * podf);
+	}
+}
+
+static struct clk spdif1_clk[] = {
+	{
+	.name = "spdif_clk",
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif1_set_parent,
+	.recalc = _clk_spdif1_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG14_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	 .name = "spdif_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGR5_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, reg2, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	reg2 = __raw_readl(MXC_CCM_CBCDR);
+	mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, &ddr_hf_clk);
+	if (mux < 4) {
+		reg = (reg & ~MXC_CCM_CBCMR_DDR_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCMR);
+	} else {
+		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL) |
+			(MXC_CCM_CBCDR_DDR_HF_SEL);
+		__raw_writel(reg2, MXC_CCM_CBCDR);
+	}
+
+	return 0;
+}
+
+static struct clk ddr_clk = {
+	.name = "ddr_clk",
+	.parent = &ddr_hf_clk,
+	.set_parent = _clk_ddr_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_arm_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk arm_axi_clk = {
+	.name = "arm_axi_clk",
+	.parent = &axi_a_clk,
+	.set_parent = _clk_arm_axi_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_vpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk vpu_clk[] = {
+	{
+	 .name = "vpu_clk",
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGR5_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &vpu_clk[1],
+	 },
+	{
+	 .name = "vpu_core_clk",
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGR5_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &vpu_clk[2],
+	 },
+	{
+	 .name = "vpu_emi_clk",
+	 .parent = &emi_fast_clk,
+#ifdef CONFIG_MXC_VPU_IRAM
+	 .secondary = &emi_intr_clk,
+#endif
+	 }
+};
+
+static int _clk_lpsr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	mux = _get_mux(parent, &ckil_clk, &fpm_clk, &fpm_div2_clk, NULL);
+	reg = (reg & ~MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static struct clk lpsr_clk = {
+	.name = "lpsr_clk",
+	.parent = &ckil_clk,
+	.set_parent = _clk_lpsr_set_parent,
+};
+
+static void _clk_pgc_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	div = (reg & MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK) >>
+	    MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET;
+	div = 1 >> div;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk pgc_clk = {
+	.name = "pgc_clk",
+	.parent = &ipg_clk,
+	.recalc = _clk_pgc_recalc,
+};
+
+/*usb OTG clock */
+
+static struct clk usb_clk = {
+	.name = "usb_clk",
+	.rate = 60000000,
+};
+
+static struct clk usb_utmi_clk = {
+	.name = "usb_utmi_clk",
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CSCMR1,
+	.enable_shift = MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ipg_clk,
+	.secondary = &spba_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG0_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &ipg_perclk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG11_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static struct clk fec_clk[] = {
+	{
+	.name = "fec_clk",
+	.parent = &ipg_clk,
+	.secondary = &fec_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG12_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	 .name = "fec_sec1_clk",
+	 .parent = &tmax2_clk,
+	 .secondary = &fec_clk[2],
+	},
+	{
+	 .name = "fec_sec2_clk",
+	 .parent = &aips_tz2_clk,
+	 .secondary = &emi_fast_clk,
+	},
+};
+
+static struct clk sahara_clk[] = {
+	{
+	.name = "sahara_clk",
+	.parent = &ahb_clk,
+	.secondary = &sahara_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG7_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.name = "sahara_sec_clk",
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
+};
+
+static int _clk_gpu3d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu3d_clk = {
+	.name = "gpu3d_clk",
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu3d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk garb_clk = {
+	.name = "garb_clk",
+	.parent = &axi_a_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk emi_garb_clk = {
+	.name = "emi_garb_clk",
+	.parent = &axi_a_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG4_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.name = "gpu2d_clk",
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG7_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk epit_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &epit_clk[1],
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG1_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "epit_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG2_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "epit_32k_clk",
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.id = 0,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.id = 0,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.id = 0,
+};
+
+
+static struct clk *mxc_clks[] = {
+	&osc_clk,
+	&ckih_clk,
+	&ckih2_clk,
+	&ckil_clk,
+	&fpm_clk,
+	&fpm_div2_clk,
+	&pll1_main_clk,
+	&pll1_sw_clk,
+	&pll2_sw_clk,
+	&pll3_sw_clk,
+	&gpc_dvfs_clk,
+	&lp_apm_clk,
+	&cpu_clk,
+	&periph_apm_clk,
+	&main_bus_clk,
+	&axi_a_clk,
+	&axi_b_clk,
+	&ahb_clk,
+	&ahb_max_clk,
+	&ipg_clk,
+	&ipg_perclk,
+	&ahbmux1_clk,
+	&ahbmux2_clk,
+	&aips_tz1_clk,
+	&aips_tz2_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&ipu_clk[0],
+	&ipu_clk[1],
+	&ipu_di_clk[0],
+	&ipu_di_clk[1],
+	&tve_clk,
+	&csi0_clk,
+	&csi1_clk,
+	&uart_main_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&spba_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&hsi2c_clk,
+	&hsi2c_serial_clk,
+	&gpt_clk[0],
+	&gpt_clk[1],
+	&gpt_clk[2],
+	&pwm1_clk[0],
+	&pwm1_clk[1],
+	&pwm1_clk[2],
+	&pwm2_clk[0],
+	&pwm2_clk[1],
+	&pwm2_clk[2],
+	&cspi_main_clk,
+	&cspi1_clk[0],
+	&cspi1_clk[1],
+	&cspi2_clk[0],
+	&cspi2_clk[1],
+	&cspi3_clk[0],
+	&cspi3_clk[1],
+	&ssi_lp_apm_clk,
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi1_clk[2],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&ssi2_clk[2],
+	&ssi_ext1_clk,
+	&ssi_ext2_clk,
+	&iim_clk,
+	&tmax1_clk,
+	&tmax2_clk,
+	&tmax3_clk,
+	&usboh3_clk[0],
+	&usboh3_clk[1],
+	&usboh3_clk[2],
+	&usb_phy_clk,
+	&usb_utmi_clk,
+	&usb_clk,
+	&esdhc1_clk[0],
+	&esdhc1_clk[1],
+	&esdhc2_clk[0],
+	&esdhc2_clk[1],
+	&esdhc3_clk[0],
+	&esdhc3_clk[1],
+	&esdhc4_clk[0],
+	&esdhc4_clk[1],
+	&esdhc_dep_clks,
+	&sim_clk[0],
+	&sim_clk[1],
+	&emi_slow_clk,
+	&ddr_clk,
+	&emi_enfc_clk,
+	&emi_fast_clk,
+	&emi_intr_clk,
+	&spdif_xtal_clk,
+	&spdif0_clk[0],
+	&spdif0_clk[1],
+	&spdif1_clk[0],
+	&spdif1_clk[1],
+	&arm_axi_clk,
+	&vpu_clk[0],
+	&vpu_clk[1],
+	&vpu_clk[2],
+	&lpsr_clk,
+	&pgc_clk,
+	&rtc_clk,
+	&ata_clk,
+	&owire_clk,
+	&fec_clk[0],
+	&fec_clk[1],
+	&fec_clk[2],
+	&mipi_hsc1_clk,
+	&mipi_hsc2_clk,
+	&mipi_esc_clk,
+	&mipi_hsp_clk,
+	&sahara_clk[0],
+	&sahara_clk[1],
+	&gpu3d_clk,
+	&garb_clk,
+	&emi_garb_clk,
+	&ddr_hf_clk,
+	&gpu2d_clk,
+	&epit_clk[0],
+	&epit_clk[1],
+	&epit_clk[2],
+	&wdog_clk,
+	&kpp_clk,
+	&scc_clk,
+};
+
+static void clk_tree_init(void)
+{
+	u32 reg, reg2, dp_ctl;
+
+	ipg_perclk.set_parent(&ipg_perclk, &ipg_clk);
+	/*
+	 *Initialise the IPG PER CLK dividers to 3. IPG_PER_CLK should be at
+	 * 8MHz, its derived from lp_apm.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
+	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[0] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll1_main_clk.parent = &fpm_clk;
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[1] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll2_sw_clk.parent = &fpm_clk;
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[2] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll3_sw_clk.parent = &fpm_clk;
+
+	/* set emi_slow_clk parent */
+	emi_slow_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MXC_CCM_CBCDR_EMI_CLK_SEL) != 0)
+		emi_slow_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CBCMR) & MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+	reg2 = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+	reg2 >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+	if (reg2) {
+		ddr_clk.parent = &ddr_hf_clk;
+	} else {
+		if (reg == 0) {
+			ddr_clk.parent = &axi_a_clk;
+		} else if (reg == 1) {
+			ddr_clk.parent = &axi_b_clk;
+		} else if (reg == 2) {
+			ddr_clk.parent = &emi_slow_clk;
+		} else {
+			ddr_clk.parent = &ahb_clk;
+		}
+	}
+}
+
+int __init mxc_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	struct clk **clkp;
+	int i, reg;
+
+	ckil_clk.rate = ckil;
+	osc_clk.rate = osc;
+	ckih_clk.rate = ckih1;
+	ckih2_clk.rate = ckih2;
+
+	clk_tree_init();
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG1_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG2_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG4_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG9_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG1_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG2_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG9_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+#ifdef CONFIG_DEBUG_LL
+	__raw_writel(0x140, MXC_CCM_CCGR1);
+#else
+	__raw_writel(0, MXC_CCM_CCGR1);
+#endif
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(3 << MXC_CCM_CCGR4_CG8_OFFSET, MXC_CCM_CCGR4);
+	__raw_writel(1 << MXC_CCM_CCGR5_CG2_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG7_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG8_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG9_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG10_OFFSET |
+		     3 << MXC_CCM_CCGR5_CG11_OFFSET, MXC_CCM_CCGR5);
+	__raw_writel(1 << MXC_CCM_CCGR6_CG4_OFFSET, MXC_CCM_CCGR6);
+
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&osc_clk);
+	propagate_rate(&ckih_clk);
+	propagate_rate(&ckih2_clk);
+	propagate_rate(&ckil_clk);
+	propagate_rate(&pll1_sw_clk);
+	propagate_rate(&pll2_sw_clk);
+
+	clk_enable(&cpu_clk);
+	clk_enable(&main_bus_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+	reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+	if (reg)
+		clk_set_parent(&ddr_clk, &ddr_hf_clk);
+	else
+		clk_set_parent(&ddr_clk, &axi_a_clk);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		clk_set_parent(&vpu_clk[0], &ahb_clk);
+		clk_set_parent(&vpu_clk[1], &ahb_clk);
+	} else {
+		clk_set_parent(&vpu_clk[0], &axi_a_clk);
+		clk_set_parent(&vpu_clk[1], &axi_a_clk);
+	}
+
+	clk_set_parent(&gpu3d_clk, &ahb_clk);
+	clk_set_parent(&gpu2d_clk, &ahb_clk);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	return 0;
+}
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 reg;
+	u32 stat;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * If DDR clock is sourced from PLL1, we cannot drop PLL1 freq.
+	 * Use the ARM_PODF to change the freq of the core, leave the PLL1
+	 * freq unchanged.
+	 */
+	if (ddr_clk.parent == &ddr_hf_clk) {
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+		reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CACRR);
+		cpu_curr_wp = wp;
+		cpu_clk.rate = cpu_wp_tbl[wp].cpu_rate;
+	} else {
+		/* Change the ARM clock to requested frequency */
+		/* First move the ARM clock to step clock which is running
+		 * at 24MHz.
+		 */
+
+		/* Change the source of pll1_sw_clk to be the step_clk */
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		/* Stop the PLL */
+		reg = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+
+		/* PDF and MFI */
+		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
+		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_OP);
+
+		/* MFD */
+		__raw_writel(p->mfd, MXC_DPLL1_BASE + MXC_PLL_DP_MFD);
+
+		/* MFI */
+		__raw_writel(p->mfn, MXC_DPLL1_BASE + MXC_PLL_DP_MFN);
+
+		reg = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg |= MXC_PLL_DP_CTL_UPEN;
+		/* Set the UPEN bits */
+		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		/* Forcefully restart the PLL */
+		reg |= MXC_PLL_DP_CTL_RST;
+		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+
+		/* Wait for the PLL to lock */
+		do {
+			stat = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL) &
+			    MXC_PLL_DP_CTL_LRF;
+		} while (!stat);
+
+		reg = __raw_readl(MXC_CCM_CCSR);
+		/* Move the PLL1 back to the pll1_main_clk */
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		cpu_curr_wp = wp;
+
+		pll1_sw_clk.rate = cpu_wp_tbl[wp].cpu_rate;
+		pll1_main_clk.rate = pll1_sw_clk.rate;
+		cpu_clk.rate = pll1_sw_clk.rate;
+	}
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
new file mode 100644
index 0000000..81d0a4f
--- /dev/null
+++ b/arch/arm/mach-mx5/cpu.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mach-mx51/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX51
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev)
+		mxc_set_system_rev(0x51, CHIP_REV_1_0);
+}
+
+static int __init post_cpu_init(void)
+{
+	unsigned int base, reg;
+
+	base = IO_ADDRESS(AIPS1_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	base = IO_ADDRESS(AIPS2_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx5/crm_regs.h b/arch/arm/mach-mx5/crm_regs.h
new file mode 100644
index 0000000..0427991
--- /dev/null
+++ b/arch/arm/mach-mx5/crm_regs.h
@@ -0,0 +1,680 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ARCH_ARM_MACH_MX51_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX51_CRM_REGS_H__
+
+#define MXC_CCM_BASE	((char *)IO_ADDRESS(CCM_BASE_ADDR))
+#define MXC_DPLL1_BASE	IO_ADDRESS(PLL1_BASE_ADDR)
+#define MXC_DPLL2_BASE	IO_ADDRESS(PLL2_BASE_ADDR)
+#define MXC_DPLL3_BASE	IO_ADDRESS(PLL3_BASE_ADDR)
+
+/* PLL Register Offsets */
+#define MXC_PLL_DP_CTL			0x00
+#define MXC_PLL_DP_CONFIG		0x04
+#define MXC_PLL_DP_OP			0x08
+#define MXC_PLL_DP_MFD			0x0C
+#define MXC_PLL_DP_MFN			0x10
+#define MXC_PLL_DP_MFNMINUS		0x14
+#define MXC_PLL_DP_MFNPLUS		0x18
+#define MXC_PLL_DP_HFS_OP		0x1C
+#define MXC_PLL_DP_HFS_MFD		0x20
+#define MXC_PLL_DP_HFS_MFN		0x24
+#define MXC_PLL_DP_MFN_TOGC		0x28
+#define MXC_PLL_DP_DESTAT		0x2c
+
+/* PLL Register Bit definitions */
+#define MXC_PLL_DP_CTL_MUL_CTRL		0x2000
+#define MXC_PLL_DP_CTL_DPDCK0_2_EN	0x1000
+#define MXC_PLL_DP_CTL_DPDCK0_2_OFFSET	12
+#define MXC_PLL_DP_CTL_ADE		0x800
+#define MXC_PLL_DP_CTL_REF_CLK_DIV	0x400
+#define MXC_PLL_DP_CTL_REF_CLK_SEL_MASK	(3 << 8)
+#define MXC_PLL_DP_CTL_REF_CLK_SEL_OFFSET	8
+#define MXC_PLL_DP_CTL_HFSM		0x80
+#define MXC_PLL_DP_CTL_PRE		0x40
+#define MXC_PLL_DP_CTL_UPEN		0x20
+#define MXC_PLL_DP_CTL_RST		0x10
+#define MXC_PLL_DP_CTL_RCP		0x8
+#define MXC_PLL_DP_CTL_PLM		0x4
+#define MXC_PLL_DP_CTL_BRM0		0x2
+#define MXC_PLL_DP_CTL_LRF		0x1
+
+#define MXC_PLL_DP_CONFIG_BIST		0x8
+#define MXC_PLL_DP_CONFIG_SJC_CE	0x4
+#define MXC_PLL_DP_CONFIG_AREN		0x2
+#define MXC_PLL_DP_CONFIG_LDREQ		0x1
+
+#define MXC_PLL_DP_OP_MFI_OFFSET	4
+#define MXC_PLL_DP_OP_MFI_MASK		(0xF << 4)
+#define MXC_PLL_DP_OP_PDF_OFFSET	0
+#define MXC_PLL_DP_OP_PDF_MASK		0xF
+
+#define MXC_PLL_DP_MFD_OFFSET		0
+#define MXC_PLL_DP_MFD_MASK		0x07FFFFFF
+
+#define MXC_PLL_DP_MFN_OFFSET		0x0
+#define MXC_PLL_DP_MFN_MASK		0x07FFFFFF
+
+#define MXC_PLL_DP_MFN_TOGC_TOG_DIS	(1 << 17)
+#define MXC_PLL_DP_MFN_TOGC_TOG_EN	(1 << 16)
+#define MXC_PLL_DP_MFN_TOGC_CNT_OFFSET	0x0
+#define MXC_PLL_DP_MFN_TOGC_CNT_MASK	0xFFFF
+
+#define MXC_PLL_DP_DESTAT_TOG_SEL	(1 << 31)
+#define MXC_PLL_DP_DESTAT_MFN		0x07FFFFFF
+
+/* Register addresses of CCM*/
+#define MXC_CCM_CCR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_CCDR		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CSR		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CACRR		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CBCDR		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_CBCMR		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_CSCMR1		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CSCMR2		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CSCDR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CS1CDR		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CS2CDR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_CDCDR		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_CHSCDR		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_CSCDR2		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_CSCDR3		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_CSCDR4		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_CWDR		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_CDHIPR		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_CDCR		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_CTOR		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_CLPCR		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_CISR		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_CIMR		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_CCOSR		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_CGPR		(MXC_CCM_BASE + 0x64)
+#define MXC_CCM_CCGR0		(MXC_CCM_BASE + 0x68)
+#define MXC_CCM_CCGR1		(MXC_CCM_BASE + 0x6C)
+#define MXC_CCM_CCGR2		(MXC_CCM_BASE + 0x70)
+#define MXC_CCM_CCGR3		(MXC_CCM_BASE + 0x74)
+#define MXC_CCM_CCGR4		(MXC_CCM_BASE + 0x78)
+#define MXC_CCM_CCGR5		(MXC_CCM_BASE + 0x7C)
+#define MXC_CCM_CCGR6		(MXC_CCM_BASE + 0x80)
+#define MXC_CCM_CMEOR		(MXC_CCM_BASE + 0x84)
+
+/* Define the bits in register CCR */
+#define MXC_CCM_CCR_COSC_EN		(1 << 12)
+#define MXC_CCM_CCR_FPM_MULT_MASK	(1 << 11)
+#define MXC_CCM_CCR_CAMP2_EN		(1 << 10)
+#define MXC_CCM_CCR_CAMP1_EN		(1 << 9)
+#define MXC_CCM_CCR_FPM_EN		(1 << 8)
+#define MXC_CCM_CCR_OSCNT_OFFSET	(0)
+#define MXC_CCM_CCR_OSCNT_MASK	(0xFF)
+
+/* Define the bits in register CCDR */
+#define MXC_CCM_CCDR_HSC_HS_MASK	(0x1 << 18)
+#define MXC_CCM_CCDR_IPU_HS_MASK	(0x1 << 17)
+#define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
+
+/* Define the bits in register CSR */
+#define MXC_CCM_CSR_COSR_READY	(1 << 5)
+#define MXC_CCM_CSR_LVS_VALUE		(1 << 4)
+#define MXC_CCM_CSR_CAMP2_READY	(1 << 3)
+#define MXC_CCM_CSR_CAMP1_READY	(1 << 2)
+#define MXC_CCM_CSR_FPM_READY	(1 << 1)
+#define MXC_CCM_CSR_REF_EN_B		(1 << 0)
+
+/* Define the bits in register CCSR */
+#define MXC_CCM_CCSR_LP_APM_SEL		(0x1 << 9)
+#define MXC_CCM_CCSR_STEP_SEL_OFFSET		(7)
+#define MXC_CCM_CCSR_STEP_SEL_MASK		(0x3 << 7)
+#define MXC_CCM_CCSR_PLL2_PODF_OFFSET	(5)
+#define MXC_CCM_CCSR_PLL2_PODF_MASK		(0x3 << 5)
+#define MXC_CCM_CCSR_PLL3_PODF_OFFSET	(3)
+#define MXC_CCM_CCSR_PLL3_PODF_MASK		(0x3 << 3)
+#define MXC_CCM_CCSR_PLL1_SW_CLK_SEL		(1 << 2)
+#define MXC_CCM_CCSR_PLL2_SW_CLK_SEL		(1 << 1)
+#define MXC_CCM_CCSR_PLL3_SW_CLK_SEL		(1 << 0)
+
+/* Define the bits in register CACRR */
+#define MXC_CCM_CACRR_ARM_PODF_OFFSET	(0)
+#define MXC_CCM_CACRR_ARM_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCDR */
+#define MXC_CCM_CBCDR_EMI_CLK_SEL			(0x1 << 26)
+#define MXC_CCM_CBCDR_PERIPH_CLK_SEL			(0x1 << 25)
+#define MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET		(30)
+#define MXC_CCM_CBCDR_DDR_HF_SEL			(0x1 << 30)
+#define MXC_CCM_CBCDR_DDR_PODF_OFFSET		(27)
+#define MXC_CCM_CBCDR_DDR_PODF_MASK			(0x7 << 27)
+#define MXC_CCM_CBCDR_EMI_PODF_OFFSET		(22)
+#define MXC_CCM_CBCDR_EMI_PODF_MASK			(0x7 << 22)
+#define MXC_CCM_CBCDR_AXI_B_PODF_OFFSET		(19)
+#define MXC_CCM_CBCDR_AXI_B_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CBCDR_AXI_A_PODF_OFFSET		(16)
+#define MXC_CCM_CBCDR_AXI_A_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CBCDR_NFC_PODF_OFFSET		(13)
+#define MXC_CCM_CBCDR_NFC_PODF_MASK			(0x7 << 13)
+#define MXC_CCM_CBCDR_AHB_PODF_OFFSET		(10)
+#define MXC_CCM_CBCDR_AHB_PODF_MASK			(0x7 << 10)
+#define MXC_CCM_CBCDR_IPG_PODF_OFFSET		(8)
+#define MXC_CCM_CBCDR_IPG_PODF_MASK			(0x3 << 8)
+#define MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET		(6)
+#define MXC_CCM_CBCDR_PERCLK_PRED1_MASK		(0x3 << 6)
+#define MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET		(3)
+#define MXC_CCM_CBCDR_PERCLK_PRED2_MASK		(0x7 << 3)
+#define MXC_CCM_CBCDR_PERCLK_PODF_OFFSET		(0)
+#define MXC_CCM_CBCDR_PERCLK_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCMR */
+#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET	(14)
+#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET		(12)
+#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET		(10)
+#define MXC_CCM_CBCMR_DDR_CLK_SEL_MASK		(0x3 << 10)
+#define MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET	(8)
+#define MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_OFFSET	(6)
+#define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK		(0x3 << 6)
+#define MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET		(4)
+#define MXC_CCM_CBCMR_GPU_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET        (14)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK      (0x3 << 14)
+#define MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL		(0x1 << 1)
+#define MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL		(0x1 << 0)
+
+/* Define the bits in register CSCMR1 */
+#define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET		(30)
+#define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK		(0x3 << 30)
+#define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET		(28)
+#define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK		(0x3 << 28)
+#define MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET		(26)
+#define MXC_CCM_CSCMR1_USB_PHY_CLK_SEL			(0x1 << 26)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET			(24)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK			(0x3 << 24)
+#define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET		(22)
+#define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK			(0x3 << 22)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET	(20)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL			(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 18)
+#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK		(0x3 << 16)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET			(14)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK			(0x3 << 14)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET			(12)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK			(0x3 << 12)
+#define MXC_CCM_CSCMR1_SSI3_CLK_SEL				(0x1 << 11)
+#define MXC_CCM_CSCMR1_VPU_RCLK_SEL				(0x1 << 10)
+#define MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET		(8)
+#define MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CSCMR1_TVE_CLK_SEL				(0x1 << 7)
+#define MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL			(0x1 << 6)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET			(4)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK			(0x3 << 4)
+#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET			(2)
+#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK			(0x3 << 2)
+#define MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL			(0x1 << 1)
+#define MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL			(0x1)
+
+/* Define the bits in register CSCMR2 */
+#define MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(n)		(26+n*3)
+#define MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(n)		(0x7 << (26+n*3))
+#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET	(24)
+#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK	(0x3 << 24)
+#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET	(22)
+#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK	(0x3 << 22)
+#define MXC_CCM_CSCMR2_ESC_CLK_SEL_OFFSET		(20)
+#define MXC_CCM_CSCMR2_ESC_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CSCMR2_HSC2_CLK_SEL_OFFSET		(18)
+#define MXC_CCM_CSCMR2_HSC2_CLK_SEL_MASK		(0x3 << 18)
+#define MXC_CCM_CSCMR2_HSC1_CLK_SEL_OFFSET		(16)
+#define MXC_CCM_CSCMR2_HSC1_CLK_SEL_MASK		(0x3 << 16)
+#define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_OFFSET		(14)
+#define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCMR2_FIRI_CLK_SEL_OFFSET		(12)
+#define MXC_CCM_CSCMR2_FIRI_CLK_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET		(10)
+#define MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK		(0x3 << 10)
+#define MXC_CCM_CSCMR2_SLIMBUS_COM			(0x1 << 9)
+#define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_OFFSET	(6)
+#define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_MASK		(0x7 << 6)
+#define MXC_CCM_CSCMR2_SPDIF1_COM			(1 << 5)
+#define MXC_CCM_CSCMR2_SPDIF0_COM			(1 << 4)
+#define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET	(2)
+#define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK		(0x3 << 2)
+#define MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET	(0)
+#define MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK		(0x3)
+
+/* Define the bits in register CSCDR1 */
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET			(14)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK			(0x3 << 14)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET	(11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK		(0x7 << 11)
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		(8)
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		(6)
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK		(0x3 << 6)
+#define MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET		(3)
+#define MXC_CCM_CSCDR1_UART_CLK_PRED_MASK			(0x7 << 3)
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK			(0x7)
+
+/* Define the bits in register CS1CDR and CS2CDR */
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET	(16)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK	(0x3F << 16)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		(0x3F)
+
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET	(16)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK	(0x3F << 16)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK		(0x3F)
+
+/* Define the bits in register CDCDR */
+#define MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET		(28)
+#define MXC_CCM_CDCDR_TVE_CLK_PRED_MASK		(0x7 << 28)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET	(25)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x3F << 19)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CDCDR_DI_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET		(3)
+#define MXC_CCM_CDCDR_USB_PHY_PRED_MASK		(0x7 << 3)
+#define MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET		(0)
+#define MXC_CCM_CDCDR_USB_PHY_PODF_MASK		(0x7)
+
+/* Define the bits in register CHSCCDR */
+#define MXC_CCM_CHSCCDR_ESC_CLK_PRED_OFFSET		(12)
+#define MXC_CCM_CHSCCDR_ESC_CLK_PRED_MASK		(0x7 << 12)
+#define MXC_CCM_CHSCCDR_ESC_CLK_PODF_OFFSET	(6)
+#define MXC_CCM_CHSCCDR_ESC_CLK_PODF_MASK		(0x3F << 6)
+#define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_OFFSET	(3)
+#define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_MASK		(0x7 << 3)
+#define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_MASK		(0x7)
+
+/* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET		(25)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK		(0x7 << 25)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET		(19)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK		(0x3F << 19)
+#define MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET		(16)
+#define MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET		(9)
+#define MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR2_SLIMBUS_CLK_PRED_OFFSET	(6)
+#define MXC_CCM_CSCDR2_SLIMBUS_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR2_SLIMBUS_PODF_OFFSET		(0)
+#define MXC_CCM_CSCDR2_SLIMBUS_PODF_MASK		(0x3F)
+
+/* Define the bits in register CSCDR3 */
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR3_FIRI_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CSCDR3_FIRI_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR3_FIRI_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CSCDR3_FIRI_CLK_PODF_MASK		(0x3F)
+
+/* Define the bits in register CSCDR4 */
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK	(0x7 << 16)
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK	(0x3F << 9)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET	(6)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK	(0x7 << 6)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK	(0x3F)
+
+/* Define the bits in register CDHIPR */
+#define MXC_CCM_CDHIPR_ARM_PODF_BUSY			(1 << 16)
+#define MXC_CCM_CDHIPR_EMI_CLK_SEL_BUSY			(1 << 6)
+#define MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY			(1 << 5)
+#define MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY		(1 << 4)
+#define MXC_CCM_CDHIPR_AHB_PODF_BUSY			(1 << 3)
+#define MXC_CCM_CDHIPR_EMI_PODF_BUSY				(1 << 2)
+#define MXC_CCM_CDHIPR_AXI_B_PODF_BUSY			(1 << 1)
+#define MXC_CCM_CDHIPR_AXI_A_PODF_BUSY			(1 << 0)
+
+/* Define the bits in register CDCR */
+#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER			(0x1 << 2)
+#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET		(0)
+#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK		(0x3)
+
+/* Define the bits in register CLPCR */
+#define MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS		(0x1 << 23)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS		(0x1 << 20)
+#define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS		(0x1 << 19)
+#define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS		(0x1 << 18)
+#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS		(0x1 << 17)
+#define MXC_CCM_CLPCR_BYPASS_RNGC_LPM_HS		(0x1 << 16)
+#define MXC_CCM_CLPCR_COSC_PWRDOWN			(0x1 << 11)
+#define MXC_CCM_CLPCR_STBY_COUNT_OFFSET		(9)
+#define MXC_CCM_CLPCR_STBY_COUNT_MASK		(0x3 << 9)
+#define MXC_CCM_CLPCR_VSTBY				(0x1 << 8)
+#define MXC_CCM_CLPCR_DIS_REF_OSC			(0x1 << 7)
+#define MXC_CCM_CLPCR_SBYOS				(0x1 << 6)
+#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM		(0x1 << 5)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET		(3)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK		(0x3 << 3)
+#define MXC_CCM_CLPCR_LPM_OFFSET			(0)
+#define MXC_CCM_CLPCR_LPM_MASK			(0x3)
+
+/* Define the bits in register CISR */
+#define MXC_CCM_CISR_ARM_PODF_LOADED			(0x1 << 25)
+#define MXC_CCM_CISR_NFC_IPG_INT_MEM_PODF_LOADED		(0x1 << 21)
+#define MXC_CCM_CISR_AHB_PODF_LOADED			(0x1 << 20)
+#define MXC_CCM_CISR_EMI_PODF_LOADED				(0x1 << 19)
+#define MXC_CCM_CISR_AXI_B_PODF_LOADED			(0x1 << 18)
+#define MXC_CCM_CISR_AXI_A_PODF_LOADED			(0x1 << 17)
+#define MXC_CCM_CISR_DIVIDER_LOADED				(0x1 << 16)
+#define MXC_CCM_CISR_COSC_READY				(0x1 << 6)
+#define MXC_CCM_CISR_CKIH2_READY				(0x1 << 5)
+#define MXC_CCM_CISR_CKIH_READY				(0x1 << 4)
+#define MXC_CCM_CISR_FPM_READY				(0x1 << 3)
+#define MXC_CCM_CISR_LRF_PLL3					(0x1 << 2)
+#define MXC_CCM_CISR_LRF_PLL2					(0x1 << 1)
+#define MXC_CCM_CISR_LRF_PLL1					(0x1)
+
+/* Define the bits in register CIMR */
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
+#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED		(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_AXI_B_PODF_LOADED		(0x1 << 18)
+#define MXC_CCM_CIMR_MASK_AXI_A_PODF_LOADED		(0x1 << 17)
+#define MXC_CCM_CIMR_MASK_DIVIDER_LOADED		(0x1 << 16)
+#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 5)
+#define MXC_CCM_CIMR_MASK_CKIH_READY			(0x1 << 4)
+#define MXC_CCM_CIMR_MASK_FPM_READY			(0x1 << 3)
+#define MXC_CCM_CIMR_MASK_LRF_PLL3			(0x1 << 2)
+#define MXC_CCM_CIMR_MASK_LRF_PLL2			(0x1 << 1)
+#define MXC_CCM_CIMR_MASK_LRF_PLL1			(0x1)
+
+/* Define the bits in register CCOSR */
+#define MXC_CCM_CCOSR_CKO2_EN_OFFSET			(0x1 << 24)
+#define MXC_CCM_CCOSR_CKO2_DIV_OFFSET			(21)
+#define MXC_CCM_CCOSR_CKO2_DIV_MASK			(0x7 << 21)
+#define MXC_CCM_CCOSR_CKO2_SEL_OFFSET			(16)
+#define MXC_CCM_CCOSR_CKO2_SEL_MASK			(0x1F << 16)
+#define MXC_CCM_CCOSR_CKOL_EN				(0x1 << 7)
+#define MXC_CCM_CCOSR_CKOL_DIV_OFFSET			(4)
+#define MXC_CCM_CCOSR_CKOL_DIV_MASK			(0x7 << 4)
+#define MXC_CCM_CCOSR_CKOL_SEL_OFFSET			(0)
+#define MXC_CCM_CCOSR_CKOL_SEL_MASK			(0xF)
+
+/* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(0x1 << 4)
+#define MXC_CCM_CGPR_FPM_SEL				(0x1 << 3)
+#define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET		(0)
+#define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_MASK		(0x7)
+
+/* Define the bits in registers CCGRx */
+#define MXC_CCM_CCGR_CG_MASK				0x3
+
+#define MXC_CCM_CCGR0_CG15_OFFSET			30
+#define MXC_CCM_CCGR0_CG15_MASK			(0x3 << 30)
+#define MXC_CCM_CCGR0_CG14_OFFSET			28
+#define MXC_CCM_CCGR0_CG14_MASK			(0x3 << 28)
+#define MXC_CCM_CCGR0_CG13_OFFSET			26
+#define MXC_CCM_CCGR0_CG13_MASK			(0x3 << 26)
+#define MXC_CCM_CCGR0_CG12_OFFSET			24
+#define MXC_CCM_CCGR0_CG12_MASK			(0x3 << 24)
+#define MXC_CCM_CCGR0_CG11_OFFSET			22
+#define MXC_CCM_CCGR0_CG11_MASK			(0x3 << 22)
+#define MXC_CCM_CCGR0_CG10_OFFSET			20
+#define MXC_CCM_CCGR0_CG10_MASK			(0x3 << 20)
+#define MXC_CCM_CCGR0_CG9_OFFSET			18
+#define MXC_CCM_CCGR0_CG9_MASK			(0x3 << 18)
+#define MXC_CCM_CCGR0_CG8_OFFSET			16
+#define MXC_CCM_CCGR0_CG8_MASK			(0x3 << 16)
+#define MXC_CCM_CCGR0_CG7_OFFSET			14
+#define MXC_CCM_CCGR0_CG6_OFFSET			12
+#define MXC_CCM_CCGR0_CG5_OFFSET			10
+#define MXC_CCM_CCGR0_CG5_MASK			(0x3 << 10)
+#define MXC_CCM_CCGR0_CG4_OFFSET			8
+#define MXC_CCM_CCGR0_CG4_MASK			(0x3 << 8)
+#define MXC_CCM_CCGR0_CG3_OFFSET			6
+#define MXC_CCM_CCGR0_CG3_MASK			(0x3 << 6)
+#define MXC_CCM_CCGR0_CG2_OFFSET			4
+#define MXC_CCM_CCGR0_CG2_MASK			(0x3 << 4)
+#define MXC_CCM_CCGR0_CG1_OFFSET			2
+#define MXC_CCM_CCGR0_CG1_MASK			(0x3 << 2)
+#define MXC_CCM_CCGR0_CG0_OFFSET			0
+#define MXC_CCM_CCGR0_CG0_MASK			0x3
+
+#define MXC_CCM_CCGR1_CG15_OFFSET			30
+#define MXC_CCM_CCGR1_CG14_OFFSET			28
+#define MXC_CCM_CCGR1_CG13_OFFSET			26
+#define MXC_CCM_CCGR1_CG12_OFFSET			24
+#define MXC_CCM_CCGR1_CG11_OFFSET			22
+#define MXC_CCM_CCGR1_CG10_OFFSET			20
+#define MXC_CCM_CCGR1_CG9_OFFSET			18
+#define MXC_CCM_CCGR1_CG8_OFFSET			16
+#define MXC_CCM_CCGR1_CG7_OFFSET			14
+#define MXC_CCM_CCGR1_CG6_OFFSET			12
+#define MXC_CCM_CCGR1_CG5_OFFSET			10
+#define MXC_CCM_CCGR1_CG4_OFFSET			8
+#define MXC_CCM_CCGR1_CG3_OFFSET			6
+#define MXC_CCM_CCGR1_CG2_OFFSET			4
+#define MXC_CCM_CCGR1_CG1_OFFSET			2
+#define MXC_CCM_CCGR1_CG0_OFFSET			0
+
+#define MXC_CCM_CCGR2_CG15_OFFSET			30
+#define MXC_CCM_CCGR2_CG14_OFFSET			28
+#define MXC_CCM_CCGR2_CG13_OFFSET			26
+#define MXC_CCM_CCGR2_CG12_OFFSET			24
+#define MXC_CCM_CCGR2_CG11_OFFSET			22
+#define MXC_CCM_CCGR2_CG10_OFFSET			20
+#define MXC_CCM_CCGR2_CG9_OFFSET			18
+#define MXC_CCM_CCGR2_CG8_OFFSET			16
+#define MXC_CCM_CCGR2_CG7_OFFSET			14
+#define MXC_CCM_CCGR2_CG6_OFFSET			12
+#define MXC_CCM_CCGR2_CG5_OFFSET			10
+#define MXC_CCM_CCGR2_CG4_OFFSET			8
+#define MXC_CCM_CCGR2_CG3_OFFSET			6
+#define MXC_CCM_CCGR2_CG2_OFFSET			4
+#define MXC_CCM_CCGR2_CG1_OFFSET			2
+#define MXC_CCM_CCGR2_CG0_OFFSET			0
+
+#define MXC_CCM_CCGR3_CG15_OFFSET			30
+#define MXC_CCM_CCGR3_CG14_OFFSET			28
+#define MXC_CCM_CCGR3_CG13_OFFSET			26
+#define MXC_CCM_CCGR3_CG12_OFFSET			24
+#define MXC_CCM_CCGR3_CG11_OFFSET			22
+#define MXC_CCM_CCGR3_CG10_OFFSET			20
+#define MXC_CCM_CCGR3_CG9_OFFSET			18
+#define MXC_CCM_CCGR3_CG8_OFFSET			16
+#define MXC_CCM_CCGR3_CG7_OFFSET			14
+#define MXC_CCM_CCGR3_CG6_OFFSET			12
+#define MXC_CCM_CCGR3_CG5_OFFSET			10
+#define MXC_CCM_CCGR3_CG4_OFFSET			8
+#define MXC_CCM_CCGR3_CG3_OFFSET			6
+#define MXC_CCM_CCGR3_CG2_OFFSET			4
+#define MXC_CCM_CCGR3_CG1_OFFSET			2
+#define MXC_CCM_CCGR3_CG0_OFFSET			0
+
+#define MXC_CCM_CCGR4_CG15_OFFSET			30
+#define MXC_CCM_CCGR4_CG14_OFFSET			28
+#define MXC_CCM_CCGR4_CG13_OFFSET			26
+#define MXC_CCM_CCGR4_CG12_OFFSET			24
+#define MXC_CCM_CCGR4_CG11_OFFSET			22
+#define MXC_CCM_CCGR4_CG10_OFFSET			20
+#define MXC_CCM_CCGR4_CG9_OFFSET			18
+#define MXC_CCM_CCGR4_CG8_OFFSET			16
+#define MXC_CCM_CCGR4_CG7_OFFSET			14
+#define MXC_CCM_CCGR4_CG6_OFFSET			12
+#define MXC_CCM_CCGR4_CG5_OFFSET			10
+#define MXC_CCM_CCGR4_CG4_OFFSET			8
+#define MXC_CCM_CCGR4_CG3_OFFSET			6
+#define MXC_CCM_CCGR4_CG2_OFFSET			4
+#define MXC_CCM_CCGR4_CG1_OFFSET			2
+#define MXC_CCM_CCGR4_CG0_OFFSET			0
+
+#define MXC_CCM_CCGR5_CG15_OFFSET			30
+#define MXC_CCM_CCGR5_CG14_OFFSET			28
+#define MXC_CCM_CCGR5_CG14_MASK			(0x3 << 28)
+#define MXC_CCM_CCGR5_CG13_OFFSET			26
+#define MXC_CCM_CCGR5_CG13_MASK			(0x3 << 26)
+#define MXC_CCM_CCGR5_CG12_OFFSET			24
+#define MXC_CCM_CCGR5_CG12_MASK			(0x3 << 24)
+#define MXC_CCM_CCGR5_CG11_OFFSET			22
+#define MXC_CCM_CCGR5_CG11_MASK			(0x3 << 22)
+#define MXC_CCM_CCGR5_CG10_OFFSET			20
+#define MXC_CCM_CCGR5_CG10_MASK			(0x3 << 20)
+#define MXC_CCM_CCGR5_CG9_OFFSET			18
+#define MXC_CCM_CCGR5_CG9_MASK			(0x3 << 18)
+#define MXC_CCM_CCGR5_CG8_OFFSET			16
+#define MXC_CCM_CCGR5_CG8_MASK			(0x3 << 16)
+#define MXC_CCM_CCGR5_CG7_OFFSET			14
+#define MXC_CCM_CCGR5_CG7_MASK			(0x3 << 14)
+#define MXC_CCM_CCGR5_CG6_OFFSET			12
+#define MXC_CCM_CCGR5_CG5_OFFSET			10
+#define MXC_CCM_CCGR5_CG4_OFFSET			8
+#define MXC_CCM_CCGR5_CG3_OFFSET			6
+#define MXC_CCM_CCGR5_CG2_OFFSET			4
+#define MXC_CCM_CCGR5_CG2_MASK			(0x3 << 4)
+#define MXC_CCM_CCGR5_CG1_OFFSET			2
+#define MXC_CCM_CCGR5_CG0_OFFSET			0
+#define MXC_CCM_CCGR6_CG7_OFFSET            14
+#define MXC_CCM_CCGR6_CG7_MASK          (0x3 << 14)
+#define MXC_CCM_CCGR6_CG6_OFFSET			12
+#define MXC_CCM_CCGR6_CG6_MASK			(0x3 << 12)
+#define MXC_CCM_CCGR6_CG5_OFFSET			10
+#define MXC_CCM_CCGR6_CG5_MASK			(0x3 << 10)
+#define MXC_CCM_CCGR6_CG4_OFFSET			8
+#define MXC_CCM_CCGR6_CG4_MASK			(0x3 << 8)
+#define MXC_CCM_CCGR6_CG3_OFFSET			6
+#define MXC_CCM_CCGR6_CG2_OFFSET			4
+#define MXC_CCM_CCGR6_CG1_OFFSET			2
+#define MXC_CCM_CCGR6_CG0_OFFSET			0
+
+#define MXC_CORTEXA8_BASE	IO_ADDRESS(ARM_BASE_ADDR)
+#define MXC_GPC_BASE		IO_ADDRESS(GPC_BASE_ADDR)
+#define MXC_DPTC_LP_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x80)
+#define MXC_DPTC_GP_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x100)
+#define MXC_DVFS_CORE_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x180)
+#define MXC_DPTC_PER_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x1C0)
+#define MXC_PGC_IPU_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x220)
+#define MXC_PGC_VPU_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x240)
+#define MXC_PGC_GPU_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x260)
+#define MXC_SRPG_NEON_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x280)
+#define MXC_SRPG_ARM_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x2A0)
+#define MXC_SRPG_EMPGC0_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x2C0)
+#define MXC_SRPG_EMPGC1_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x2D0)
+#define MXC_SRPG_MEGAMIX_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x2E0)
+#define MXC_SRPG_EMI_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x300)
+
+/* CORTEXA8 platform */
+#define MXC_CORTEXA8_PLAT_PVID		(MXC_CORTEXA8_BASE + 0x0)
+#define MXC_CORTEXA8_PLAT_GPC		(MXC_CORTEXA8_BASE + 0x4)
+#define MXC_CORTEXA8_PLAT_PIC		(MXC_CORTEXA8_BASE + 0x8)
+#define MXC_CORTEXA8_PLAT_LPC		(MXC_CORTEXA8_BASE + 0xC)
+#define MXC_CORTEXA8_PLAT_NEON_LPC	(MXC_CORTEXA8_BASE + 0x10)
+#define MXC_CORTEXA8_PLAT_ICGC		(MXC_CORTEXA8_BASE + 0x14)
+#define MXC_CORTEXA8_PLAT_AMC		(MXC_CORTEXA8_BASE + 0x18)
+#define MXC_CORTEXA8_PLAT_NMC		(MXC_CORTEXA8_BASE + 0x20)
+#define MXC_CORTEXA8_PLAT_NMS		(MXC_CORTEXA8_BASE + 0x24)
+
+/* DVFS CORE */
+#define MXC_DVFSTHRS		(MXC_DVFS_CORE_BASE + 0x00)
+#define MXC_DVFSCOUN		(MXC_DVFS_CORE_BASE + 0x04)
+#define MXC_DVFSSIG1		(MXC_DVFS_CORE_BASE + 0x08)
+#define MXC_DVFSSIG0		(MXC_DVFS_CORE_BASE + 0x0C)
+#define MXC_DVFSGPC0		(MXC_DVFS_CORE_BASE + 0x10)
+#define MXC_DVFSGPC1		(MXC_DVFS_CORE_BASE + 0x14)
+#define MXC_DVFSGPBT		(MXC_DVFS_CORE_BASE + 0x18)
+#define MXC_DVFSEMAC		(MXC_DVFS_CORE_BASE + 0x1C)
+#define MXC_DVFSCNTR		(MXC_DVFS_CORE_BASE + 0x20)
+#define MXC_DVFSLTR0_0		(MXC_DVFS_CORE_BASE + 0x24)
+#define MXC_DVFSLTR0_1		(MXC_DVFS_CORE_BASE + 0x28)
+#define MXC_DVFSLTR1_0		(MXC_DVFS_CORE_BASE + 0x2C)
+#define MXC_DVFSLTR1_1		(MXC_DVFS_CORE_BASE + 0x30)
+#define MXC_DVFSPT0 		(MXC_DVFS_CORE_BASE + 0x34)
+#define MXC_DVFSPT1 		(MXC_DVFS_CORE_BASE + 0x38)
+#define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
+#define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
+
+/* GPC */
+#define MXC_GPC_CNTR		(MXC_GPC_BASE + 0x0)
+#define MXC_GPC_PGR		(MXC_GPC_BASE + 0x4)
+#define MXC_GPC_VCR		(MXC_GPC_BASE + 0x8)
+#define MXC_GPC_ALL_PU		(MXC_GPC_BASE + 0xC)
+#define MXC_GPC_NEON		(MXC_GPC_BASE + 0x10)
+#define MXC_GPC_PGR_ARMPG_OFFSET	8
+#define MXC_GPC_PGR_ARMPG_MASK		(3 << 8)
+
+/* PGC */
+#define MXC_PGC_IPU_PGCR	(MXC_PGC_IPU_BASE + 0x0)
+#define MXC_PGC_IPU_PGSR	(MXC_PGC_IPU_BASE + 0xC)
+#define MXC_PGC_VPU_PGCR	(MXC_PGC_VPU_BASE + 0x0)
+#define MXC_PGC_VPU_PGSR	(MXC_PGC_VPU_BASE + 0xC)
+#define MXC_PGC_GPU_PGCR	(MXC_PGC_GPU_BASE + 0x0)
+#define MXC_PGC_GPU_PGSR	(MXC_PGC_GPU_BASE + 0xC)
+
+#define MXC_PGCR_PCR		1
+#define MXC_SRPGCR_PCR		1
+#define MXC_EMPGCR_PCR		1
+#define MXC_PGSR_PSR		1
+
+
+#define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
+#define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
+
+/* SRPG */
+#define MXC_SRPG_NEON_SRPGCR	(MXC_SRPG_NEON_BASE + 0x0)
+#define MXC_SRPG_NEON_PUPSCR	(MXC_SRPG_NEON_BASE + 0x4)
+#define MXC_SRPG_NEON_PDNSCR	(MXC_SRPG_NEON_BASE + 0x8)
+
+#define MXC_SRPG_ARM_SRPGCR	(MXC_SRPG_ARM_BASE + 0x0)
+#define MXC_SRPG_ARM_PUPSCR	(MXC_SRPG_ARM_BASE + 0x4)
+#define MXC_SRPG_ARM_PDNSCR	(MXC_SRPG_ARM_BASE + 0x8)
+
+#define MXC_SRPG_EMPGC0_SRPGCR	(MXC_SRPG_EMPGC0_BASE + 0x0)
+#define MXC_SRPG_EMPGC0_PUPSCR	(MXC_SRPG_EMPGC0_BASE + 0x4)
+#define MXC_SRPG_EMPGC0_PDNSCR	(MXC_SRPG_EMPGC0_BASE + 0x8)
+
+#define MXC_SRPG_EMPGC1_SRPGCR	(MXC_SRPG_EMPGC1_BASE + 0x0)
+#define MXC_SRPG_EMPGC1_PUPSCR	(MXC_SRPG_EMPGC1_BASE + 0x4)
+#define MXC_SRPG_EMPGC1_PDNSCR	(MXC_SRPG_EMPGC1_BASE + 0x8)
+
+#define MXC_SRPG_MEGAMIX_SRPGCR		(MXC_SRPG_MEGAMIX_BASE + 0x0)
+#define MXC_SRPG_MEGAMIX_PUPSCR		(MXC_SRPG_MEGAMIX_BASE + 0x4)
+#define MXC_SRPG_MEGAMIX_PDNSCR		(MXC_SRPG_MEGAMIX_BASE + 0x8)
+
+#define MXC_SRPGC_EMI_SRPGCR	(MXC_SRPGC_EMI_BASE + 0x0)
+#define MXC_SRPGC_EMI_PUPSCR	(MXC_SRPGC_EMI_BASE + 0x4)
+#define MXC_SRPGC_EMI_PDNSCR	(MXC_SRPGC_EMI_BASE + 0x8)
+
+#endif				/* __ARCH_ARM_MACH_MX51_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
new file mode 100644
index 0000000..fedc44a
--- /dev/null
+++ b/arch/arm/mach-mx5/devices.c
@@ -0,0 +1,828 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/spba.h>
+#include <asm-arm/plat-mxc/mxc_scc2_driver.h>
+#include "iomux.h"
+#include "crm_regs.h"
+#include <mach/sdma.h>
+#include <mach/imx_spi.h>
+#include <mach/gpio.h>
+#include "sdma_script_code.h"
+
+/* Flag used to indicate when IRAM has been initialized */
+int iram_ready;
+
+void mx51_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	/* ATA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct resource w1_resources[] = {
+	{
+	 .start = MXC_INT_OWIRE,
+	 .flags = IORESOURCE_IRQ,
+	 }
+};
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_w1_data,
+		},
+	.num_resources = ARRAY_SIZE(w1_resources),
+	.resource = w1_resources,
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct resource rtc_resources[] = {
+	{
+	 .start = SRTC_BASE_ADDR,
+	 .end = SRTC_BASE_ADDR + 0x40,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_SRTC_NTZ,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &srtc_data,
+		},
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG1_BASE_ADDR,
+	 .end = WDOG1_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mx51_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mx51_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU_V3) || defined(CONFIG_MXC_IPU_V3_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_512M,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = MXC_INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+void mxc_init_ipu(void)
+{
+	u32 reg_hsc_mcd = IO_ADDRESS(MIPI_HSC_BASE_ADDR);
+	u32 reg_hsc_mxt_conf = IO_ADDRESS(MIPI_HSC_BASE_ADDR + 0x800);
+	struct clk *clk;
+	uint32_t temp;
+
+	/* Select IPUv3 h/w version */
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		mxc_ipu_data.rev = 2;
+
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+	clk = clk_get(NULL, "tve_clk");
+	clk_set_parent(mxc_ipu_data.di_clk[1], clk);
+	clk_put(clk);
+
+	/* Temporarily setup MIPI module to legacy mode */
+	clk = clk_get(NULL, "mipi_hsp_clk");
+	if (!IS_ERR(clk)) {
+		clk_enable(clk);
+
+		/* Temporarily setup MIPI module to legacy mode */
+		__raw_writel(0xF00, reg_hsc_mcd);
+
+		/* CSI mode reserved*/
+		temp = __raw_readl(reg_hsc_mxt_conf);
+		__raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
+
+		if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) {
+			temp = __raw_readl(reg_hsc_mxt_conf);
+			__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
+		}
+
+		clk_disable(clk);
+		clk_put(clk);
+	}
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
+static struct resource vpu_resources[] = {
+	[0] = {
+	       .start = VPU_IRAM_BASE_ADDR,
+	       .end = VPU_IRAM_BASE_ADDR + VPU_IRAM_SIZE,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IO_ADDRESS(SRC_BASE_ADDR),
+	       .end = IO_ADDRESS(SRC_BASE_ADDR),
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+/*! Platform Data for MXC VPU */
+static struct platform_device mxcvpu_device = {
+	.name = "mxc_vpu",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(vpu_resources),
+	.resource = vpu_resources,
+};
+
+static inline void mxc_init_vpu(void)
+{
+	if (platform_device_register(&mxcvpu_device) < 0)
+		printk(KERN_ERR "Error: Registering the VPU.\n");
+}
+#else
+static inline void mxc_init_vpu(void)
+{
+}
+#endif
+
+/*!
+ * This is platform device structure for adding SCC
+ */
+#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
+static struct platform_device mxc_scc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+};
+
+static void mxc_init_scc(void)
+{
+	platform_device_register(&mxc_scc_device);
+}
+#else
+static inline void mxc_init_scc(void)
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint8_t *UMID_base;
+	uint32_t *MAP_base;
+	uint8_t i;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint8_t iram_partitions = 16;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		iram_partitions = 12;
+
+	scc_base = ioremap((uint32_t) SCC_BASE_ADDR, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM REGS\n");
+		return;
+	}
+	scm_ram_base = ioremap((uint32_t) IRAM_BASE_ADDR, IRAM_SIZE);
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM\n");
+		return;
+	}
+
+	for (partition_no = 0; partition_no < iram_partitions; partition_no++) {
+		/*De-allocate a Partition*/
+		reg_value = ((partition_no << SCM_ZCMD_PART_SHIFT) &
+			     SCM_ZCMD_PART_MASK) | ((0x03 <<
+						     SCM_ZCMD_CCMD_SHIFT)
+						    & SCM_ZCMD_CCMD_MASK);
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		msleep(1);
+		while ((__raw_readl(scc_base + SCM_STATUS_REG) &
+			SCM_STATUS_SRS_READY) != SCM_STATUS_SRS_READY)
+			;
+
+		/*In Supervisor mode claims a partition for it's own use
+		    by writing zero to SMID register.*/
+		__raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
+
+		reg_mask |= (3 << (2 * (partition_no)));
+	}
+
+	msleep(1);
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+
+	if ((reg_value & reg_mask) != reg_mask) {
+		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	for (partition_no = 0; partition_no < iram_partitions; partition_no++) {
+		MAP_base = scm_ram_base + (partition_no * 0x2000);
+		UMID_base = (uint8_t *) MAP_base + 0x10;
+
+		for (i = 0; i < 16; i++)
+			UMID_base[i] = 0;
+
+		MAP_base[0] = SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
+		    SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
+		    SCM_PERM_TH_READ | SCM_PERM_TH_WRITE;
+
+	}
+
+	/* Freeing 2 partitions for SCC2 */
+	scc_partno = iram_partitions - (SCC_IRAM_SIZE / SZ_8K);
+	for (partition_no = scc_partno; partition_no < iram_partitions;
+	     partition_no++) {
+		reg_value = ((partition_no << SCM_ZCMD_PART_SHIFT) &
+			     SCM_ZCMD_PART_MASK) | ((0x03 <<
+						     SCM_ZCMD_CCMD_SHIFT)
+						    & SCM_ZCMD_CCMD_MASK);
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		msleep(1);
+		while ((__raw_readl(scc_base + SCM_STATUS_REG) &
+			SCM_STATUS_SRS_READY) != SCM_STATUS_SRS_READY)
+			;
+	}
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+	iram_ready = 1;
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.init = gpio_spi_active,
+	.exit = gpio_spi_inactive,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.init = gpio_spi_active,
+	.exit = gpio_spi_inactive,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI,
+	       .end = MXC_INT_CSPI,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 7,
+	.init = gpio_spi_active,
+	.exit = gpio_spi_inactive,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+int mxc_init_spi(void)
+{
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI1, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+	return 0;
+}
+#else
+int mxc_init_spi(void)
+{
+	return 0;
+}
+#endif
+
+
+#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+static struct resource mxci2c_hs_resources[] = {
+	[0] = {
+	       .start = HSI2C_DMA_BASE_ADDR,
+	       .end = HSI2C_DMA_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_HS_I2C,
+	       .end = MXC_INT_HS_I2C,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct platform_device mxci2c_hs_device = {
+	.name = "mxc_i2c_hs",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxci2c_hs_data,
+		},
+	.num_resources = ARRAY_SIZE(mxci2c_hs_resources),
+	.resource = mxci2c_hs_resources
+};
+
+static inline void mxc_init_i2c_hs(void)
+{
+	if (platform_device_register(&mxci2c_hs_device) < 0)
+		dev_err(&mxci2c_hs_device.dev,
+			"Unable to register High Speed I2C device\n");
+}
+#else
+static inline void mxc_init_i2c_hs(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_TVOUT_TVE) || defined(CONFIG_FB_MXC_TVOUT_TVE_MODULE)
+static struct resource tve_resources[] = {
+	{
+	 .start = TVE_BASE_ADDR,
+	 .end = TVE_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_TVE,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+	.dig_reg = "VDIG",
+};
+
+static struct platform_device mxc_tve_device = {
+	.name = "tve",
+	.dev = {
+		.platform_data = &tve_data,
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(tve_resources),
+	.resource = tve_resources,
+};
+
+void __init mxc_init_tve(void)
+{
+	platform_device_register(&mxc_tve_device);
+}
+#else
+static inline void mxc_init_tve(void)
+{
+}
+#endif
+
+/*!
+ * Resource definition for the DVFS CORE
+ */
+static struct resource dvfs_core_resources[] = {
+	[0] = {
+	       .start = MXC_DVFS_CORE_BASE,
+	       .end = MXC_DVFS_CORE_BASE + 4 * SZ_16 - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_GPC1,
+	       .end = MXC_INT_GPC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for DVFS CORE */
+struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
+	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
+	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
+	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x10,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 3,
+	.dncnt_val = 3,
+	.delay_time = 30,
+	.num_wp = 2,
+};
+
+/*! Device Definition for MXC DVFS core */
+static struct platform_device mxc_dvfs_core_device = {
+	.name = "mxc_dvfs_core",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &dvfs_core_data,
+		},
+	.num_resources = ARRAY_SIZE(dvfs_core_resources),
+	.resource = dvfs_core_resources,
+};
+
+static inline void mxc_init_dvfs(void)
+{
+	if (platform_device_register(&mxc_dvfs_core_device) < 0)
+		dev_err(&mxc_dvfs_core_device.dev,
+			"Unable to register DVFS core device\n");
+}
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
+static struct resource spdif_resources[] = {
+	{
+	 .start = SPDIF_BASE_ADDR,
+	 .end = SPDIF_BASE_ADDR + 0x50,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+};
+
+static struct platform_device mxc_alsa_spdif_device = {
+	.name = "mxc_alsa_spdif",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_spdif_data,
+		},
+	.num_resources = ARRAY_SIZE(spdif_resources),
+	.resource = spdif_resources,
+};
+
+static inline void mxc_init_spdif(void)
+{
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+	platform_device_register(&mxc_alsa_spdif_device);
+}
+
+static struct platform_device mx51_lpmode_device = {
+	.name = "mx51_lpmode",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mx51_init_lpmode(void)
+{
+	(void)platform_device_register(&mx51_lpmode_device);
+}
+
+static struct platform_device busfreq_device = {
+	.name = "busfreq",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_busfreq(void)
+{
+	(void)platform_device_register(&busfreq_device);
+}
+
+#if defined(CONFIG_MXC_IIM) || defined(CONFIG_MXC_IIM_MODULE)
+static struct resource mxc_iim_resources[] = {
+	{
+	 .start = IIM_BASE_ADDR,
+	 .end = IIM_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_iim_device = {
+	.name = "mxc_iim",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(mxc_iim_resources),
+	.resource = mxc_iim_resources
+};
+
+static inline void mxc_init_iim(void)
+{
+	if (platform_device_register(&mxc_iim_device) < 0)
+		dev_err(&mxc_iim_device.dev,
+			"Unable to register mxc iim device\n");
+}
+#else
+static inline void mxc_init_iim(void)
+{
+}
+#endif
+
+int __init mxc_init_devices(void)
+{
+	mx51_init_wdt();
+	mxc_init_spi();
+	mxc_init_i2c_hs();
+	mxc_init_rtc();
+	mxc_init_scc();
+	mxc_init_dma();
+	mxc_init_owire();
+	mxc_init_ipu();
+	mxc_init_vpu();
+	mxc_init_spdif();
+	mxc_init_tve();
+	mx51_init_lpmode();
+	mxc_init_busfreq();
+	mxc_init_dvfs();
+	mxc_init_iim();
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/dma.c b/arch/arm/mach-mx5/dma.c
new file mode 100644
index 0000000..1b9e72b
--- /dev/null
+++ b/arch/arm/mach-mx5/dma.c
@@ -0,0 +1,574 @@
+/*
+ *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+
+#define MXC_MMC_BUFFER_ACCESS     0x20
+#define MXC_SDHC_MMC_WML          64
+#define MXC_SDHC_SD_WML           256
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_SPDIF_TXFIFO_WML      0x8
+#define MXC_SPDIF_TX_REG          0x2C
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+
+	}
+	return NULL;
+}
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif
+}
+
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx5/dummy_gpio.c b/arch/arm/mach-mx5/dummy_gpio.c
new file mode 100644
index 0000000..e91bbb5
--- /dev/null
+++ b/arch/arm/mach-mx5/dummy_gpio.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+
+void gpio_uart_active(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_active);
+
+void gpio_uart_inactive(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+void config_uartdma_event(int port) {}
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_spi_active(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_active);
+
+void gpio_spi_inactive(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+void gpio_owire_active(void) {}
+EXPORT_SYMBOL(gpio_owire_active);
+
+void gpio_owire_inactive(void) {}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+void gpio_i2c_active(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+void gpio_i2c_inactive(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+void gpio_i2c_hs_active(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_active);
+
+void gpio_i2c_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_inactive);
+
+void gpio_pmic_active(void) {}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+void gpio_activate_audio_ports(void) {}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+void gpio_sdhc_active(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+void gpio_sdhc_inactive(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+void gpio_sensor_select(int sensor) {}
+
+void gpio_sensor_active(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_inactive(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+void gpio_ata_active(void) {}
+EXPORT_SYMBOL(gpio_ata_active);
+
+void gpio_ata_inactive(void) {}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+void gpio_nand_active(void) {}
+EXPORT_SYMBOL(gpio_nand_active);
+
+void gpio_nand_inactive(void) {}
+EXPORT_SYMBOL(gpio_nand_inactive);
+
+void gpio_keypad_active(void) {}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+void gpio_keypad_inactive(void) {}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+int gpio_usbotg_hs_active(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+void gpio_fec_active(void) {}
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void) {}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+void gpio_spdif_active(void) {}
+EXPORT_SYMBOL(gpio_spdif_active);
+
+void gpio_spdif_inactive(void) {}
+EXPORT_SYMBOL(gpio_spdif_inactive);
+
diff --git a/arch/arm/mach-mx5/iomux.c b/arch/arm/mach-mx5/iomux.c
new file mode 100644
index 0000000..821f646
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX51 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX51
+ */
+/*!
+ * @file mach-mx51/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX51
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/gpio.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR0 = IO_ADDRESS(IOMUXC_BASE_ADDR),
+	IOMUXGPR1 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004,
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR),
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + MUX_I_END,
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START,
+	IOMUXSW_INPUT_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR),
+};
+
+#define MUX_PIN_NUM_MAX        ((MUX_I_END >> 2) + 1)
+
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+static DEFINE_SPINLOCK(gpio_mux_lock);
+
+static inline u32 _get_mux_reg(iomux_pin_name_t pin)
+{
+	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (mux_reg >= 0x2FC)
+			mux_reg += 8;
+		else if (mux_reg >= 0x130)
+			mux_reg += 0xC;
+	}
+	mux_reg += IOMUXSW_MUX_CTL;
+	return mux_reg;
+}
+
+static inline u32 _get_pad_reg(iomux_pin_name_t pin)
+{
+	u32 pad_reg = PIN_TO_IOMUX_PAD(pin);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (pad_reg == 0x4D0 - PAD_I_START)
+			pad_reg += 0x4C;
+		else if (pad_reg == 0x860 - PAD_I_START)
+			pad_reg += 0x9C;
+		else if (pad_reg >= 0x804 - PAD_I_START)
+			pad_reg += 0xB0;
+		else if (pad_reg >= 0x7FC - PAD_I_START)
+			pad_reg += 0xB4;
+		else if (pad_reg >= 0x4E4 - PAD_I_START)
+			pad_reg += 0xCC;
+		else
+			pad_reg += 8;
+	}
+	pad_reg += IOMUXSW_PAD_CTL;
+	return pad_reg;
+}
+
+static inline u32 _get_mux_end(void)
+{
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + (0x3F8 - 4);
+	else
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + (0x3F0 - 4);
+}
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_reg = _get_mux_reg(pin);
+	u32 mux_data = 0;
+	u8 *rp;
+
+	BUG_ON((mux_reg > _get_mux_end()) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+
+	if (config == IOMUX_CONFIG_GPIO)
+		mux_data = PIN_TO_ALT_GPIO(pin);
+	else
+		mux_data = config;
+
+	__raw_writel(mux_data, mux_reg);
+
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if ((mux_data & *rp) && (*rp != mux_data)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, pin=%d, "
+		       " prev=0x%x new=0x%x\n", mux_reg, *rp, mux_data);
+		ret = -EINVAL;
+	}
+	*rp = mux_data;
+	spin_unlock(&gpio_mux_lock);
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	int ret = iomux_config_mux(pin, config);
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+
+	*rp = 0;
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 pad_reg = _get_pad_reg(pin);
+
+	BUG_ON(pad_reg < IOMUXSW_PAD_CTL);
+	__raw_writel(config, pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin)
+{
+	u32 pad_reg = _get_pad_reg(pin);
+
+	return __raw_readl(pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_get_pad);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ *      */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	u32 reg;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if (input == MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 4;
+		else if (input == MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT)
+			input -= 5;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT)
+			input -= 1;
+
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_TO1;
+	} else {
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START;
+	}
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+	__raw_writel(config, reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx5/iomux.h b/arch/arm/mach-mx5/iomux.h
new file mode 100644
index 0000000..5c3187e
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX51_IOMUX_H__
+#define __MACH_MX51_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+#include "mx51_pins.h"
+
+/*!
+ * @file mach-mx51/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX51
+ */
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,	/*!< used as alternate function 0 */
+	IOMUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	IOMUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	IOMUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	IOMUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	IOMUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	IOMUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	IOMUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	IOMUX_CONFIG_GPIO,	/*!< added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0,
+	PAD_CTL_DRV_LOW = 0x0 << 1,
+	PAD_CTL_DRV_MEDIUM = 0x1 << 1,
+	PAD_CTL_DRV_HIGH = 0x2 << 1,
+	PAD_CTL_DRV_MAX = 0x3 << 1,
+	PAD_CTL_ODE_OPENDRAIN_NONE = 0x0 << 3,
+	PAD_CTL_ODE_OPENDRAIN_ENABLE = 0x1 << 3,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_HYS_NONE = 0x0 << 8,
+	PAD_CTL_HYS_ENABLE = 0x1 << 8,
+	PAD_CTL_DDR_INPUT_CMOS = 0x0 << 9,
+	PAD_CTL_DDR_INPUT_DDR = 0x1 << 9,
+	PAD_CTL_DRV_VOT_LOW = 0x0 << 13,
+	PAD_CTL_DRV_VOT_HIGH = 0x1 << 13,
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX input select register index
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT,
+	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CCM_IPP_DI_CLK_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_DPLLIP1_L1T_TOG_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_EMI_IPP_IND_RDY_INT_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT0_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT1_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT2_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT3_IN_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
+	MUX_IN_FEC_FEC_CRS_SELECT_INPUT,
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_2_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_3_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_1_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_2_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_3_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_4_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_6_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_7_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_8_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_VSYNC_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_DI_WAIT_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_CLK_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_0_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_1_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_2_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_3_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_4_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_5_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_6_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_7_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DIR_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_NXT_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_STP_SELECT_INPUT,
+	MUX_INPUT_NUM_MUX,
+} iomux_input_select_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_config_t;
+
+struct mxc_iomux_pin_cfg {
+	iomux_pin_name_t pin;
+	u8 mux_mode;
+	u16 pad_cfg;
+	u8 in_select;
+	u8 in_mode;
+};
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config      the ORed value of elements defined in
+ *                             \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function gets the current pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @return		current pad value
+ */
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in
+ *                              \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+
+#endif				/*  __MACH_MX51_IOMUX_H__ */
diff --git a/arch/arm/mach-mx5/lpmodes.c b/arch/arm/mach-mx5/lpmodes.c
new file mode 100644
index 0000000..240e531
--- /dev/null
+++ b/arch/arm/mach-mx5/lpmodes.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx51_lpmodes.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC low power modes setup.
+ *
+ * MX51 is designed to play and video with minimal power consumption.
+ * This driver enables the platform to enter and exit audio and video low
+ * power modes.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <linux/regulator/machine.h>
+#include "crm_regs.h"
+
+#define ARM_LP_CLK  200000000
+#define GP_LPM_VOLTAGE 775000
+#define GP_NORMAL_VOLTAGE 1050000
+
+static int org_cpu_rate;
+int lp_video_mode;
+int lp_audio_mode;
+static struct device *lpmode_dev;
+struct regulator *gp_core;
+
+void enter_lp_video_mode(void)
+{
+}
+
+void exit_lp_video_mode(void)
+{
+}
+
+void enter_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	int ret;
+
+	tclk = clk_get(NULL, "cpu_clk");
+	org_cpu_rate = clk_get_rate(tclk);
+
+	ret = clk_set_rate(tclk, ARM_LP_CLK);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+
+	/* Set the voltage to 0.775v for the GP domain. */
+	ret = regulator_set_voltage(gp_core, GP_LPM_VOLTAGE, GP_LPM_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	lp_audio_mode = 1;
+}
+
+void exit_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	int ret;
+
+	/* Set the voltage to 1.05v for the GP domain. */
+	ret = regulator_set_voltage(gp_core,
+				    GP_NORMAL_VOLTAGE, GP_NORMAL_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	tclk = clk_get(NULL, "cpu_clk");
+	ret = clk_set_rate(tclk, org_cpu_rate);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+
+	lp_audio_mode = 0;
+
+}
+
+static ssize_t lp_curr_mode(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	if (lp_video_mode)
+		return sprintf(buf, "in lp_video_mode\n");
+	else if (lp_audio_mode)
+		return sprintf(buf, "in lp_audio_mode\n");
+	else
+		return sprintf(buf, "in normal mode\n");
+}
+
+static ssize_t set_lp_mode(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	printk(KERN_DEBUG "In set_lp_mode() \n");
+
+	if (strstr(buf, "enable_lp_video") != NULL) {
+		if (!lp_video_mode)
+			enter_lp_video_mode();
+	} else if (strstr(buf, "disable_lp_video") != NULL) {
+		if (lp_video_mode)
+			exit_lp_video_mode();
+	} else if (strstr(buf, "enable_lp_audio") != NULL) {
+		if (!lp_audio_mode)
+			enter_lp_audio_mode();
+	} else if (strstr(buf, "disable_lp_audio") != NULL) {
+		if (lp_audio_mode)
+			exit_lp_audio_mode();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(lp_modes, 0644, lp_curr_mode, set_lp_mode);
+
+/*!
+ * This is the probe routine for the lp_mode driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mx51_lpmode_probe(struct platform_device *pdev)
+{
+	u32 res = 0;
+	lpmode_dev = &pdev->dev;
+
+	res = sysfs_create_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+	if (res) {
+		printk(KERN_ERR
+		"lpmode_dev: Unable to register sysdev entry for lpmode_dev");
+		return res;
+	}
+
+	if (res != 0) {
+		printk(KERN_ERR "lpmode_dev: Unable to start");
+		return res;
+	}
+	gp_core = regulator_get(NULL, "SW1");
+	lp_video_mode = 0;
+	lp_audio_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver mx51_lpmode_driver = {
+	.driver = {
+		   .name = "mx51_lpmode",
+		   },
+	.probe = mx51_lpmode_probe,
+};
+
+/*!
+ * Initialise the mx51_lpmode_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init lpmode_init(void)
+{
+	if (platform_driver_register(&mx51_lpmode_driver) != 0) {
+		printk(KERN_ERR "mx37_lpmode_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "LPMode driver module loaded\n");
+	return 0;
+}
+
+static void __exit lpmode_cleanup(void)
+{
+	sysfs_remove_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx51_lpmode_driver);
+}
+
+module_init(lpmode_init);
+module_exit(lpmode_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("LPMode driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/mm.c b/arch/arm/mach-mx5/mm.c
new file mode 100644
index 0000000..d426616
--- /dev/null
+++ b/arch/arm/mach-mx5/mm.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License.  You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/*!
+ * @file mach-mx51/mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory_MX51
+ */
+
+/*!
+ * This structure defines the MX51 memory map.
+ */
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = IRAM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
+	 .length = IRAM_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = DEBUG_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(DEBUG_BASE_ADDR),
+	 .length = DEBUG_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = TZIC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(TZIC_BASE_ADDR),
+	 .length = TZIC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = SPBA0_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+	 .length = SPBA0_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = NFC_BASE_ADDR_AXI_VIRT,
+	 .pfn = __phys_to_pfn(NFC_BASE_ADDR_AXI),
+	 .length = NFC_AXI_SIZE,
+	 .type = MT_DEVICE},
+};
+
+/*!
+ * This function initializes the memory map. It is called during the
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	u32 tzic_addr;
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		tzic_addr = 0x8FFFC000;
+	else
+		tzic_addr = 0xE0003000;
+
+	mxc_io_desc[2].pfn =  __phys_to_pfn(tzic_addr);
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff --git a/arch/arm/mach-mx5/mx51_pins.h b/arch/arm/mach-mx5/mx51_pins.h
new file mode 100644
index 0000000..5b08a5f
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_pins.h
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX51_PINS_H__
+#define __ASM_ARCH_MXC_MX51_PINS_H__
+
+/*!
+ * @file arch-mxc/mx51_pins.h
+ *
+ * @brief MX51 I/O Pin List
+ *
+ * @ingroup GPIO_MX51
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |  23 - 21 | 20  - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I  | GPIO_I | PAD_I  | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 9 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX51_PIN_ETM_D0 is defined in the enumeration:
+ *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
+ * It means the mux control register is at register offset 0x28. The pad control
+ * register offset is: 0x250 and also occupy the least significant bits
+ * within the register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I			0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I			10
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent which
+ * mux mode is for GPIO (0-based)
+ */
+#define GPIO_I			21
+
+#define NON_GPIO_PORT		0x7
+#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
+#define PIN_TO_ALT_GPIO_MASK		((1 << (MUX_IO_I - GPIO_I)) - 1)
+
+#define NON_MUX_I		PIN_TO_MUX_MASK
+#define MUX_I_START		0x001C
+#define PAD_I_START		0x3F0
+#define INPUT_CTL_START		0x8C4
+#define INPUT_CTL_START_TO1	0x928
+#define MUX_I_END		(PAD_I_START - 4)
+
+#define _MXC_BUILD_PIN(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi) << MUX_I) | \
+	((pi - PAD_I_START) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+    _MXC_BUILD_PIN(NON_GPIO_PORT, 0, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
+#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
+#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX51 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins {
+	MX51_PIN_EIM_DA0 = _MXC_BUILD_NON_GPIO_PIN(0x1C, 0x7A8),
+	MX51_PIN_EIM_DA1 = _MXC_BUILD_NON_GPIO_PIN(0x20, 0x7A8),
+	MX51_PIN_EIM_DA2 = _MXC_BUILD_NON_GPIO_PIN(0x24, 0x7A8),
+	MX51_PIN_EIM_DA3 = _MXC_BUILD_NON_GPIO_PIN(0x28, 0x7A8),
+	MX51_PIN_EIM_DA4 = _MXC_BUILD_NON_GPIO_PIN(0x2C, 0x7AC),
+	MX51_PIN_EIM_DA5 = _MXC_BUILD_NON_GPIO_PIN(0x30, 0x7AC),
+	MX51_PIN_EIM_DA6 = _MXC_BUILD_NON_GPIO_PIN(0x34, 0x7AC),
+	MX51_PIN_EIM_DA7 = _MXC_BUILD_NON_GPIO_PIN(0x38, 0x7AC),
+	MX51_PIN_EIM_DA8 = _MXC_BUILD_NON_GPIO_PIN(0x3C, 0x7B0),
+	MX51_PIN_EIM_DA9 = _MXC_BUILD_NON_GPIO_PIN(0x40, 0x7B0),
+	MX51_PIN_EIM_DA10 = _MXC_BUILD_NON_GPIO_PIN(0x44, 0x7B0),
+	MX51_PIN_EIM_DA11 = _MXC_BUILD_NON_GPIO_PIN(0x48, 0x7B0),
+	MX51_PIN_EIM_DA12 = _MXC_BUILD_NON_GPIO_PIN(0x4C, 0x7BC),
+	MX51_PIN_EIM_DA13 = _MXC_BUILD_NON_GPIO_PIN(0x50, 0x7BC),
+	MX51_PIN_EIM_DA14 = _MXC_BUILD_NON_GPIO_PIN(0x54, 0x7BC),
+	MX51_PIN_EIM_DA15 = _MXC_BUILD_NON_GPIO_PIN(0x58, 0x7BC),
+	MX51_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN(1, 0, 1, 0x5C, 0x3F0),
+	MX51_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN(1, 1, 1, 0x60, 0x3F4),
+	MX51_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN(1, 2, 1, 0x64, 0x3F8),
+	MX51_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN(1, 3, 1, 0x68, 0x3FC),
+	MX51_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN(1, 4, 1, 0x6C, 0x400),
+	MX51_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN(1, 5, 1, 0x70, 0x404),
+	MX51_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN(1, 6, 1, 0x74, 0x408),
+	MX51_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN(1, 7, 1, 0x78, 0x40C),
+	MX51_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN(1, 8, 1, 0x7C, 0x410),
+	MX51_PIN_EIM_D25 = _MXC_BUILD_NON_GPIO_PIN(0x80, 0x414),
+	MX51_PIN_EIM_D26 = _MXC_BUILD_NON_GPIO_PIN(0x84, 0x418),
+	MX51_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN(1, 9, 1, 0x88, 0x41C),
+	MX51_PIN_EIM_D28 = _MXC_BUILD_NON_GPIO_PIN(0x8C, 0x420),
+	MX51_PIN_EIM_D29 = _MXC_BUILD_NON_GPIO_PIN(0x90, 0x424),
+	MX51_PIN_EIM_D30 = _MXC_BUILD_NON_GPIO_PIN(0x94, 0x428),
+	MX51_PIN_EIM_D31 = _MXC_BUILD_NON_GPIO_PIN(0x98, 0x42C),
+	MX51_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN(1, 10, 1, 0x9C, 0x430),
+	MX51_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN(1, 11, 1, 0xA0, 0x434),
+	MX51_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN(1, 12, 1, 0xA4, 0x438),
+	MX51_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN(1, 13, 1, 0xA8, 0x43C),
+	MX51_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN(1, 14, 1, 0xAC, 0x440),
+	MX51_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN(1, 15, 1, 0xB0, 0x444),
+	MX51_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN(1, 16, 1, 0xB4, 0x448),
+	MX51_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN(1, 17, 1, 0xB8, 0x44C),
+	MX51_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN(1, 18, 1, 0xBC, 0x450),
+	MX51_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN(1, 19, 1, 0xC0, 0x454),
+	MX51_PIN_EIM_A26 = _MXC_BUILD_GPIO_PIN(1, 20, 1, 0xC4, 0x458),
+	MX51_PIN_EIM_A27 = _MXC_BUILD_GPIO_PIN(1, 21, 1, 0xC8, 0x45C),
+	MX51_PIN_EIM_EB0 = _MXC_BUILD_NON_GPIO_PIN(0xCC, 0x460),
+	MX51_PIN_EIM_EB1 = _MXC_BUILD_NON_GPIO_PIN(0xD0, 0x464),
+	MX51_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN(1, 22, 1, 0xD4, 0x468),
+	MX51_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN(1, 23, 1, 0xD8, 0x46C),
+	MX51_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN(1, 24, 1, 0xDC, 0x470),
+	MX51_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN(1, 25, 1, 0xE0, 0x474),
+	MX51_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN(1, 26, 1, 0xE4, 0x478),
+	MX51_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN(1, 27, 1, 0xE8, 0x47C),
+	MX51_PIN_EIM_CS3 = _MXC_BUILD_GPIO_PIN(1, 28, 1, 0xEC, 0x480),
+	MX51_PIN_EIM_CS4 = _MXC_BUILD_GPIO_PIN(1, 29, 1, 0xF0, 0x484),
+	MX51_PIN_EIM_CS5 = _MXC_BUILD_GPIO_PIN(1, 30, 1, 0xF4, 0x488),
+	MX51_PIN_EIM_DTACK = _MXC_BUILD_GPIO_PIN(1, 31, 1, 0xF8, 0x48C),
+	MX51_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN(2, 1, 1, 0xFC, 0x494),
+	MX51_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN(2, 2, 1, 0x100, 0x4A0),
+	MX51_PIN_DRAM_CS1 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x4D0),
+	MX51_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN(2, 3, 3, 0x108, 0x4E4),
+	MX51_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN(2, 4, 3, 0x10C, 0x4E8),
+	MX51_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN(2, 5, 3, 0x110, 0x4EC),
+	MX51_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN(2, 6, 3, 0x114, 0x4F0),
+	MX51_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN(2, 7, 3, 0x118, 0x4F4),
+	MX51_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN(2, 8, 3, 0x11C, 0x4F8),
+	MX51_PIN_NANDF_RB1 = _MXC_BUILD_GPIO_PIN(2, 9, 3, 0x120, 0x4FC),
+	MX51_PIN_NANDF_RB2 = _MXC_BUILD_GPIO_PIN(2, 10, 3, 0x124, 0x500),
+	MX51_PIN_NANDF_RB3 = _MXC_BUILD_GPIO_PIN(2, 11, 3, 0x128, 0x504),
+	MX51_PIN_GPIO_NAND = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x12C, 0x514),
+	MX51_PIN_NANDF_RB4 = MX51_PIN_GPIO_NAND,
+	MX51_PIN_NANDF_RB5 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x130, 0x5D8),
+	MX51_PIN_NANDF_RB6 = _MXC_BUILD_GPIO_PIN(2, 14, 3, 0x134, 0x5DC),
+	MX51_PIN_NANDF_RB7 = _MXC_BUILD_GPIO_PIN(2, 15, 3, 0x138, 0x5E0),
+	MX51_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN(2, 16, 3, 0x130, 0x518),
+	MX51_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN(2, 17, 3, 0x134, 0x51C),
+	MX51_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN(2, 18, 3, 0x138, 0x520),
+	MX51_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN(2, 19, 3, 0x13C, 0x524),
+	MX51_PIN_NANDF_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 3, 0x140, 0x528),
+	MX51_PIN_NANDF_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 3, 0x144, 0x52C),
+	MX51_PIN_NANDF_CS6 = _MXC_BUILD_GPIO_PIN(2, 22, 3, 0x148, 0x530),
+	MX51_PIN_NANDF_CS7 = _MXC_BUILD_GPIO_PIN(2, 23, 3, 0x14C, 0x534),
+	MX51_PIN_NANDF_RDY_INT = _MXC_BUILD_GPIO_PIN(2, 24, 3, 0x150, 0x538),
+	MX51_PIN_NANDF_D15 = _MXC_BUILD_GPIO_PIN(2, 25, 3, 0x154, 0x53C),
+	MX51_PIN_NANDF_D14 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0x158, 0x540),
+	MX51_PIN_NANDF_D13 = _MXC_BUILD_GPIO_PIN(2, 27, 3, 0x15C, 0x544),
+	MX51_PIN_NANDF_D12 = _MXC_BUILD_GPIO_PIN(2, 28, 3, 0x160, 0x548),
+	MX51_PIN_NANDF_D11 = _MXC_BUILD_GPIO_PIN(2, 29, 3, 0x164, 0x54C),
+	MX51_PIN_NANDF_D10 = _MXC_BUILD_GPIO_PIN(2, 30, 3, 0x168, 0x550),
+	MX51_PIN_NANDF_D9 = _MXC_BUILD_GPIO_PIN(2, 31, 3, 0x16C, 0x554),
+	MX51_PIN_NANDF_D8 = _MXC_BUILD_GPIO_PIN(3, 0, 3, 0x170, 0x558),
+	MX51_PIN_NANDF_D7 = _MXC_BUILD_GPIO_PIN(3, 1, 3, 0x174, 0x55C),
+	MX51_PIN_NANDF_D6 = _MXC_BUILD_GPIO_PIN(3, 2, 3, 0x178, 0x560),
+	MX51_PIN_NANDF_D5 = _MXC_BUILD_GPIO_PIN(3, 3, 3, 0x17C, 0x564),
+	MX51_PIN_NANDF_D4 = _MXC_BUILD_GPIO_PIN(3, 4, 3, 0x180, 0x568),
+	MX51_PIN_NANDF_D3 = _MXC_BUILD_GPIO_PIN(3, 5, 3, 0x184, 0x56C),
+	MX51_PIN_NANDF_D2 = _MXC_BUILD_GPIO_PIN(3, 6, 3, 0x188, 0x570),
+	MX51_PIN_NANDF_D1 = _MXC_BUILD_GPIO_PIN(3, 7, 3, 0x18C, 0x574),
+	MX51_PIN_NANDF_D0 = _MXC_BUILD_GPIO_PIN(3, 8, 3, 0x190, 0x578),
+	MX51_PIN_CSI1_D8 = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x194, 0x57C),
+	MX51_PIN_CSI1_D9 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x198, 0x580),
+	MX51_PIN_CSI1_D10 = _MXC_BUILD_NON_GPIO_PIN(0x19C, 0x584),
+	MX51_PIN_CSI1_D11 = _MXC_BUILD_NON_GPIO_PIN(0x1A0, 0x588),
+	MX51_PIN_CSI1_D12 = _MXC_BUILD_NON_GPIO_PIN(0x1A4, 0x58C),
+	MX51_PIN_CSI1_D13 = _MXC_BUILD_NON_GPIO_PIN(0x1A8, 0x590),
+	MX51_PIN_CSI1_D14 = _MXC_BUILD_NON_GPIO_PIN(0x1AC, 0x594),
+	MX51_PIN_CSI1_D15 = _MXC_BUILD_NON_GPIO_PIN(0x1B0, 0x598),
+	MX51_PIN_CSI1_D16 = _MXC_BUILD_NON_GPIO_PIN(0x1B4, 0x59C),
+	MX51_PIN_CSI1_D17 = _MXC_BUILD_NON_GPIO_PIN(0x1B8, 0x5A0),
+	MX51_PIN_CSI1_D18 = _MXC_BUILD_NON_GPIO_PIN(0x1BC, 0x5A4),
+	MX51_PIN_CSI1_D19 = _MXC_BUILD_NON_GPIO_PIN(0x1C0, 0x5A8),
+	MX51_PIN_CSI1_VSYNC = _MXC_BUILD_NON_GPIO_PIN(0x1C4, 0x5AC),
+	MX51_PIN_CSI1_HSYNC = _MXC_BUILD_NON_GPIO_PIN(0x1C8, 0x5B0),
+	MX51_PIN_CSI1_PIXCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B4),
+	MX51_PIN_CSI1_MCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B8),
+	MX51_PIN_CSI1_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x860),
+	MX51_PIN_CSI2_D12 = _MXC_BUILD_GPIO_PIN(3, 9, 3, 0x1CC, 0x5BC),
+	MX51_PIN_CSI2_D13 = _MXC_BUILD_GPIO_PIN(3, 10, 3, 0x1D0, 0x5C0),
+	MX51_PIN_CSI2_D14 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1D4, 0x5C4),
+	MX51_PIN_CSI2_D15 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1D8, 0x5C8),
+	MX51_PIN_CSI2_D16 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1DC, 0x5CC),
+	MX51_PIN_CSI2_D17 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E0, 0x5D0),
+	MX51_PIN_CSI2_D18 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1E4, 0x5D4),
+	MX51_PIN_CSI2_D19 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E8, 0x5D8),
+	MX51_PIN_CSI2_VSYNC = _MXC_BUILD_GPIO_PIN(3, 13, 3, 0x1EC, 0x5DC),
+	MX51_PIN_CSI2_HSYNC = _MXC_BUILD_GPIO_PIN(3, 14, 3, 0x1F0, 0x5E0),
+	MX51_PIN_CSI2_PIXCLK = _MXC_BUILD_GPIO_PIN(3, 15, 3, 0x1F4, 0x5E4),
+	MX51_PIN_CSI2_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x81C),
+	MX51_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(3, 16, 3, 0x1F8, 0x5E8),
+	MX51_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(3, 17, 3, 0x1FC, 0x5EC),
+	MX51_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN(3, 18, 3, 0x200, 0x5F0),
+	MX51_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN(3, 19, 3, 0x204, 0x5F4),
+	MX51_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN(3, 20, 3, 0x208, 0x5F8),
+	MX51_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN(3, 21, 3, 0x20C, 0x5FC),
+	MX51_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(3, 22, 3, 0x210, 0x600),
+	MX51_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(3, 23, 3, 0x214, 0x604),
+	MX51_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(3, 24, 3, 0x218, 0x608),
+	MX51_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(3, 25, 3, 0x21C, 0x60C),
+	MX51_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(3, 26, 3, 0x220, 0x610),
+	MX51_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(3, 27, 3, 0x224, 0x614),
+	MX51_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 28, 3, 0x228, 0x618),
+	MX51_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 29, 3, 0x22C, 0x61C),
+	MX51_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 30, 3, 0x230, 0x620),
+	MX51_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 31, 3, 0x234, 0x624),
+	MX51_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(0, 20, 3, 0x238, 0x628),
+	MX51_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(0, 21, 3, 0x23C, 0x62C),
+	MX51_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN(0, 22, 3, 0x240, 0x630),
+	MX51_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN(0, 23, 3, 0x244, 0x634),
+	MX51_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN(0, 24, 3, 0x248, 0x638),
+	MX51_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(0x24C, 0x63C),
+	MX51_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(0x250, 0x640),
+	MX51_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(0x254, 0x644),
+	MX51_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(0x258, 0x648),
+	MX51_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(0x25C, 0x64C),
+	MX51_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(0x260, 0x650),
+	MX51_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(0x264, 0x654),
+	MX51_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(0x268, 0x658),
+	MX51_PIN_KEY_COL4 = _MXC_BUILD_NON_GPIO_PIN(0x26C, 0x65C),
+	MX51_PIN_KEY_COL5 = _MXC_BUILD_NON_GPIO_PIN(0x270, 0x660),
+	MX51_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN(0, 25, 2, 0x278, 0x678),
+	MX51_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN(0, 26, 2, 0x27C, 0x67C),
+	MX51_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN(0, 27, 2, 0x280, 0x680),
+	MX51_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN(0, 28, 2, 0x284, 0x684),
+	MX51_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN(0, 11, 2, 0x288, 0x688),
+	MX51_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN(0, 12, 2, 0x28C, 0x68C),
+	MX51_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN(0, 13, 2, 0x290, 0x690),
+	MX51_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN(0, 14, 2, 0x294, 0x694),
+	MX51_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN(0, 15, 2, 0x298, 0x698),
+	MX51_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN(0, 16, 2, 0x29C, 0x69C),
+	MX51_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN(0, 17, 2, 0x2A0, 0x6A0),
+	MX51_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN(0, 18, 2, 0x2A4, 0x6A4),
+	MX51_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN(2, 0, 4, 0x2A8, 0x6A8),
+	MX51_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN(2, 1, 4, 0x2AC, 0x6AC),
+	MX51_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN(2, 2, 4, 0x2B0, 0x6B0),
+	MX51_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN(2, 3, 4, 0x2B4, 0x6B4),
+	MX51_PIN_DI1_D1_CS = _MXC_BUILD_GPIO_PIN(2, 4, 4, 0x2B8, 0x6B8),
+	MX51_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN(2, 5, 4, 0x2BC, 0x6BC),
+	MX51_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN(2, 6, 4, 0x2C0, 0x6C0),
+	MX51_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN(2, 7, 4, 0x2C4, 0x6C4),
+	MX51_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN(2, 8, 4, 0x2C8, 0x6C8),
+	MX51_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x2CC, 0x6CC),
+	MX51_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x2D0, 0x6D0),
+	MX51_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x2D4, 0x6D4),
+	MX51_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x2D8, 0x6D8),
+	MX51_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x2DC, 0x6DC),
+	MX51_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x2E0, 0x6E0),
+	MX51_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN(0x2E4, 0x6E4),
+	MX51_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN(0x2E8, 0x6E8),
+	MX51_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN(0x2EC, 0x6EC),
+	MX51_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN(0x2F0, 0x6F0),
+	MX51_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x2F4, 0x6F4),
+	MX51_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x2F8, 0x6F8),
+	MX51_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x2FC, 0x6FC),
+	MX51_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x300, 0x700),
+	MX51_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x304, 0x704),
+	MX51_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x308, 0x708),
+	MX51_PIN_DISP1_DAT16 = _MXC_BUILD_NON_GPIO_PIN(0x30C, 0x70C),
+	MX51_PIN_DISP1_DAT17 = _MXC_BUILD_NON_GPIO_PIN(0x310, 0x710),
+	MX51_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN(0x314, 0x714),
+	MX51_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN(0x318, 0x718),
+	MX51_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN(0x31C, 0x71C),
+	MX51_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN(0x320, 0x720),
+	MX51_PIN_DISP1_DAT22 = _MXC_BUILD_NON_GPIO_PIN(0x324, 0x724),
+	MX51_PIN_DISP1_DAT23 = _MXC_BUILD_NON_GPIO_PIN(0x328, 0x728),
+	MX51_PIN_DI1_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x32C, 0x72C),
+	MX51_PIN_DI1_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x330, 0x734),
+	MX51_PIN_DI_GP1 = _MXC_BUILD_NON_GPIO_PIN(0x334, 0x73C),
+	MX51_PIN_DI_GP2 = _MXC_BUILD_NON_GPIO_PIN(0x338, 0x740),
+	MX51_PIN_DI_GP3 = _MXC_BUILD_NON_GPIO_PIN(0x33C, 0x744),
+	MX51_PIN_DI2_PIN4 = _MXC_BUILD_NON_GPIO_PIN(0x340, 0x748),
+	MX51_PIN_DI2_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x344, 0x74C),
+	MX51_PIN_DI2_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x348, 0x750),
+	MX51_PIN_DI2_DISP_CLK = _MXC_BUILD_NON_GPIO_PIN(0x34C, 0x754),
+	MX51_PIN_DI_GP4 = _MXC_BUILD_NON_GPIO_PIN(0x350, 0x758),
+	MX51_PIN_DISP2_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x354, 0x75C),
+	MX51_PIN_DISP2_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x358, 0x760),
+	MX51_PIN_DISP2_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x35C, 0x764),
+	MX51_PIN_DISP2_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x360, 0x768),
+	MX51_PIN_DISP2_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x364, 0x76C),
+	MX51_PIN_DISP2_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x368, 0x770),
+	MX51_PIN_DISP2_DAT6 = _MXC_BUILD_GPIO_PIN(0, 19, 5, 0x36C, 0x774),
+	MX51_PIN_DISP2_DAT7 = _MXC_BUILD_GPIO_PIN(0, 29, 5, 0x370, 0x778),
+	MX51_PIN_DISP2_DAT8 = _MXC_BUILD_GPIO_PIN(0, 30, 5, 0x374, 0x77C),
+	MX51_PIN_DISP2_DAT9 = _MXC_BUILD_GPIO_PIN(0, 31, 5, 0x378, 0x780),
+	MX51_PIN_DISP2_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x37C, 0x784),
+	MX51_PIN_DISP2_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x380, 0x788),
+	MX51_PIN_DISP2_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x384, 0x78C),
+	MX51_PIN_DISP2_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x388, 0x790),
+	MX51_PIN_DISP2_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x38C, 0x794),
+	MX51_PIN_DISP2_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x390, 0x798),
+	MX51_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN(0x394, 0x79C),
+	MX51_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN(0x398, 0x7A0),
+	MX51_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x39C, 0x7A4),
+	MX51_PIN_SD1_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3A0, 0x7A8),
+	MX51_PIN_SD1_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3A4, 0x7AC),
+	MX51_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3A8, 0x7B0),
+	MX51_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 1, 0x3AC, 0x7B4),
+	MX51_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 1, 0x3B0, 0x7B8),
+	MX51_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN(0x3B4, 0x7BC),
+	MX51_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN(0x3B8, 0x7C0),
+	MX51_PIN_SD2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x3BC, 0x7C4),
+	MX51_PIN_SD2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3C0, 0x7C8),
+	MX51_PIN_SD2_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3C4, 0x7CC),
+	MX51_PIN_SD2_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3C8, 0x7D0),
+	MX51_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 0, 0x3CC, 0x7D4),
+	MX51_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 0, 0x3D0, 0x7D8),
+	MX51_PIN_PMIC_INT_REQ = _MXC_BUILD_NON_GPIO_PIN(0x3D4, 0x7FC),
+	MX51_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 0, 0x3D8, 0x804),
+	MX51_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 0, 0x3DC, 0x808),
+	MX51_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 0, 0x3E0, 0x80C),
+	MX51_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN(0, 7, 0, 0x3E4, 0x810),
+	MX51_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN(0, 8, 0, 0x3E8, 0x814),
+	MX51_PIN_GPIO1_9 = _MXC_BUILD_GPIO_PIN(0, 9, 0, 0x3EC, 0x818),
+};
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX51_PINS_H__ */
diff --git a/arch/arm/mach-mx5/pm.c b/arch/arm/mach-mx5/pm.c
new file mode 100644
index 0000000..60bd88c
--- /dev/null
+++ b/arch/arm/mach-mx5/pm.c
@@ -0,0 +1,149 @@
+/*
+ *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include "crm_regs.h"
+
+static struct device *pm_dev;
+struct clk *gpc_dvfs_clk;
+extern void cpu_do_suspend_workaround(void);
+extern void cpu_cortexa8_do_idle(u32);
+
+extern int iram_ready;
+
+static int mx51_suspend_enter(suspend_state_t state)
+{
+	if (tzic_enable_wake(0) != 0)
+		return -EAGAIN;
+
+	if (gpc_dvfs_clk == NULL)
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	/* gpc clock is needed for SRPG */
+	clk_enable(gpc_dvfs_clk);
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (state == PM_SUSPEND_MEM) {
+		cpu_do_suspend_workaround();
+		/*clear the EMPGC0/1 bits */
+		__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+	} else {
+		if ((mxc_cpu_is_rev(CHIP_REV_2_0)) < 0) {
+			/* do cpu_idle_workaround */
+			u32 l2_iram_addr = IDLE_IRAM_BASE_ADDR;
+			if (!iram_ready)
+				return 0;
+			if (l2_iram_addr > 0x1FFE8000)
+				cpu_cortexa8_do_idle(IO_ADDRESS(l2_iram_addr));
+		} else {
+			cpu_do_idle();
+		}
+	}
+
+	clk_disable(gpc_dvfs_clk);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx51_suspend_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Called before devices are re-setup.
+ */
+static void mx51_suspend_finish(void)
+{
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx51_suspend_end(void)
+{
+}
+
+static int mx51_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx51_suspend_ops = {
+	.valid = mx51_pm_valid,
+	.prepare = mx51_suspend_prepare,
+	.enter = mx51_suspend_enter,
+	.finish = mx51_suspend_finish,
+	.end = mx51_suspend_end,
+};
+
+
+static int __devinit mx51_pm_probe(struct platform_device *pdev)
+{
+	pm_dev = &pdev->dev;
+	return 0;
+}
+
+static struct platform_driver mx51_pm_driver = {
+	.driver = {
+		   .name = "mx51_pm",
+		   },
+	.probe = mx51_pm_probe,
+};
+
+static int __init pm_init(void)
+{
+	pr_info("Static Power Management for Freescale i.MX51\n");
+	if (platform_driver_register(&mx51_pm_driver) != 0) {
+		printk(KERN_ERR "mx51_pm_driver register failed\n");
+		return -ENODEV;
+	}
+	suspend_set_ops(&mx51_suspend_ops);
+	printk(KERN_INFO "PM driver module loaded\n");
+
+	return 0;
+}
+
+
+static void __exit pm_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx51_pm_driver);
+}
+
+module_init(pm_init);
+module_exit(pm_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("PM driver");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-mx5/sdma_script_code.h b/arch/arm/mach-mx5/sdma_script_code.h
new file mode 100644
index 0000000..9b8de26
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS15_ELVIS"
+
+*******************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR	0
+#define start_SIZE	24
+
+#define core_ADDR	80
+#define core_SIZE	232
+
+#define common_ADDR	312
+#define common_SIZE	330
+
+#define ap_2_ap_ADDR	642
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	683
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	747
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	817
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	892
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	961
+#define mcu_2_shp_SIZE	72
+
+#define app_2_per_ADDR	1033
+#define app_2_per_SIZE	66
+
+#define per_2_app_ADDR	1099
+#define per_2_app_SIZE	74
+
+#define per_2_shp_ADDR	1173
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1251
+#define shp_2_per_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1323
+#define uartsh_2_mcu_SIZE	69
+
+#define mcu_2_ata_ADDR	1392
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1473
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1569
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1796
+#define test_SIZE	63
+
+#define signature_ADDR	1023
+#define signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define ext_mem__ipu_ram_ADDR	6144
+#define ext_mem__ipu_ram_SIZE	123
+
+#define mcu_2_spdif_ADDR	6267
+#define mcu_2_spdif_SIZE	59
+
+#define uart_2_per_ADDR	6326
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6399
+#define uartsh_2_per_SIZE	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			322
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0x0e70, 0x0611, 0x5616, 0xc13c, 0x7d2a, 0x5ade, 0x008e, 0xc14e,
+	0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5,
+	0xd84f, 0x982b, 0x6b05, 0xc681, 0x7e27, 0x7f29, 0x982b, 0x6d01,
+	0x03df, 0x7d05, 0x6bd5, 0xc6ab, 0x7e18, 0x7f1a, 0x982b, 0x6b05,
+	0xc621, 0x7e07, 0x7f06, 0x52de, 0x53e6, 0xc159, 0x7dd7, 0x0200,
+	0x9803, 0x0007, 0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc256,
+	0x048b, 0x0498, 0x0454, 0x068a, 0x982b, 0x0207, 0x680c, 0x6ddf,
+	0x0107, 0x68ff, 0x60d0, 0x9834, 0x0207, 0x68ff, 0x6d28, 0x0107,
+	0x6004, 0x680c, 0x9834, 0x0007, 0x68ff, 0x60d0, 0x9834, 0x0288,
+	0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da,
+	0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804,
+	0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf,
+	0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb,
+	0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3,
+	0x65ff, 0x7ed1, 0x0006, 0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a01,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x56fb, 0x0478,
+	0x7d28, 0x0479, 0x7c16, 0x0015, 0x0015, 0x0388, 0x620a, 0x0808,
+	0x7801, 0x0217, 0x5a06, 0x7f1d, 0x620a, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f17, 0x2301, 0x4b00, 0x7cf1, 0x0b70, 0x0311, 0x5313,
+	0x98aa, 0x0015, 0x0015, 0x0015, 0x7804, 0x620b, 0x5a06, 0x620b,
+	0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa, 0x57db,
+	0x9880, 0x0007, 0x680c, 0xc213, 0xc20a, 0x987d, 0xc1e3, 0x57db,
+	0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269,
+	0x7d1e, 0x1e94, 0x6ee3, 0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3,
+	0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27,
+	0x6ac8, 0x7f23, 0x2501, 0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3,
+	0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x62d0, 0xc27a, 0x98fb, 0x6ee3,
+	0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e,
+	0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000,
+	0x4d00, 0x7d09, 0xc1fa, 0x57db, 0x98ba, 0x0007, 0x6aff, 0x62d0,
+	0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff8, 0xc20a, 0x98b7, 0xc1d9,
+	0xc1e3, 0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202,
+	0x0269, 0x7d17, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694, 0x5206,
+	0x026e, 0x7d26, 0x6ac8, 0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e,
+	0x1a98, 0x5202, 0x0260, 0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc27a,
+	0x993e, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06,
+	0x0000, 0x4d00, 0x7d0b, 0xc1fa, 0x57db, 0x9904, 0x0007, 0x6aff,
+	0x6add, 0x7ffc, 0x62d0, 0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff6,
+	0xc20a, 0x9901
+};
+#endif
diff --git a/arch/arm/mach-mx5/serial.c b/arch/arm/mach-mx5/serial.c
new file mode 100644
index 0000000..1775db4
--- /dev/null
+++ b/arch/arm/mach-mx5/serial.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx51/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX51
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <mach/hardware.h>
+#include <mach/imx-uart.h>
+#include <mach/board-mx51_3stack.h>
+
+
+#if defined(CONFIG_SERIAL_IMX) || defined(CONFIG_SERIAL_IMX_MODULE)
+static struct resource uart0[] = {
+	{
+		.start = UART1_BASE_ADDR,
+		.end = UART1_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART1,
+		.end = MXC_INT_UART1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device0 = {
+	.name = "imx-uart",
+	.id = 0,
+	.resource = uart0,
+	.num_resources = ARRAY_SIZE(uart0),
+};
+
+static struct resource uart1[] = {
+	{
+		.start = UART2_BASE_ADDR,
+		.end = UART2_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART2,
+		.end = MXC_INT_UART2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "imx-uart",
+	.id = 1,
+	.resource = uart1,
+	.num_resources = ARRAY_SIZE(uart1),
+};
+
+static struct resource uart2[] = {
+	{
+		.start = UART3_BASE_ADDR,
+		.end = UART3_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART3,
+		.end = MXC_INT_UART3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "imx-uart",
+	.id = 2,
+	.resource = uart2,
+	.num_resources = ARRAY_SIZE(uart2),
+};
+
+static int uart_mxc_port0_init(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int uart_mxc_port0_exit(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int uart_mxc_port1_init(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int uart_mxc_port1_exit(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int uart_mxc_port2_init(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int uart_mxc_port2_exit(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct imxuart_platform_data uart_pdata[] = {
+	{
+		.init = uart_mxc_port0_init,
+		.exit = uart_mxc_port0_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port1_init,
+		.exit = uart_mxc_port1_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port2_init,
+		.exit = uart_mxc_port2_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	},
+};
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	mxc_uart_device0.dev.platform_data = &uart_pdata[0];
+	mxc_uart_device1.dev.platform_data = &uart_pdata[1];
+	mxc_uart_device2.dev.platform_data = &uart_pdata[2];
+	platform_device_register(&mxc_uart_device0);
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+	return 0;
+}
+
+arch_initcall(mxc_init_uart);
+#endif
diff --git a/arch/arm/mach-mx5/suspend.S b/arch/arm/mach-mx5/suspend.S
new file mode 100644
index 0000000..9533b46
--- /dev/null
+++ b/arch/arm/mach-mx5/suspend.S
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_CTRL_ICACHE  1 << 12
+#define ARM_AUXCR_L2EN   1 << 1
+
+
+/*
+ *	cpu_do_suspend_workaround()
+ *
+ *	Suspend the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_do_suspend_workaround)
+    stmfd   sp!, {r4,r5,r7,r9,r10,r11}     @ Save registers
+
+    /* Disable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    bic     r0, r0, #ARM_CTRL_ICACHE @ Disable ICache
+    bic     r0, r0, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000       @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedClean
+    mov     r10, #0
+Loop1Clean:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipClean                @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7             @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Clean:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Clean:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c14, 2 @ Clean and invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Clean
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Clean
+SkipClean:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Clean
+
+FinishedClean:
+
+    /* Disable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    bic     r0, r0, #ARM_AUXCR_L2EN @ Disable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    .long     0xe320f003              @ Opcode for WFI
+
+    mov     r0, #0
+    mcr     p15, 0, r0, c7, c5, 0   @ Invalidate inst cache
+
+    /* Invalidate data caches */
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000      @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedInvalidate
+    mov     r10, #0
+Loop1Invalidate:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipInvalidate          @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7              @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Invalidate:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Invalidate:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c6, 2  @ Invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Invalidate
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Invalidate
+SkipInvalidate:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Invalidate
+
+FinishedInvalidate:
+
+    /* Enable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    orr     r0, r0, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    /* Enable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    orr     r0, r0, #ARM_CTRL_ICACHE @ Enable ICache
+    orr     r0, r0, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    /* Restore registers */
+    ldmfd sp!, {r4,r5,r7,r9,r10,r11}
+    mov		pc, lr
+
+	.type	cpu_do_suspend, #object
+ENTRY(cpu_do_suspend)
+	.word	cpu_do_suspend_workaround
+	.size	cpu_do_suspend_workaround, . - cpu_do_suspend_workaround
+
+
diff --git a/arch/arm/mach-mx5/system.c b/arch/arm/mach-mx5/system.c
new file mode 100644
index 0000000..f749426
--- /dev/null
+++ b/arch/arm/mach-mx5/system.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm-arm/plat-mxc/mxc_wdt.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX51 i.MX51 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx51/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX51
+ */
+
+extern int mxc_jtag_enabled;
+extern int iram_ready;
+static struct clk *gpc_dvfs_clk;
+
+extern void cpu_cortexa8_do_idle(u32 addr);
+
+
+/* set cpu low power mode before WFI instruction */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	u32 plat_lpc, gpc_pgr, arm_srpgcr, ccm_clpcr;
+	u32 empgc0, empgc1;
+	int stop_mode = 0;
+
+	/* always allow platform to issue a deep sleep mode request */
+	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
+	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+
+	gpc_pgr = __raw_readl(MXC_GPC_PGR) & ~(MXC_GPC_PGR_ARMPG_MASK);
+
+	switch (mode) {
+	case WAIT_CLOCKED:
+		break;
+	case WAIT_UNCLOCKED:
+		ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	case WAIT_UNCLOCKED_POWER_OFF:
+	case STOP_POWER_OFF:
+		plat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM
+			    | MXC_CORTEXA8_PLAT_LPC_DBG_DSM;
+		if (mode == WAIT_UNCLOCKED_POWER_OFF) {
+			ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;
+			stop_mode = 0;
+		} else {
+			ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr |= (0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET);
+			ccm_clpcr |= MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr |= MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 1;
+		}
+
+		arm_srpgcr |= MXC_SRPGCR_PCR;
+		gpc_pgr |= (0x1 << MXC_GPC_PGR_ARMPG_OFFSET);
+		if (stop_mode) {
+			empgc0 |= MXC_SRPGCR_PCR;
+			empgc1 |= MXC_SRPGCR_PCR;
+		}
+
+		if (tzic_enable_wake(1) != 0)
+			return;
+		break;
+	case STOP_POWER_ON:
+		ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	default:
+		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		return;
+	}
+
+	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	__raw_writel(gpc_pgr, MXC_GPC_PGR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+
+	if (stop_mode) {
+		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+	}
+}
+
+void mxc_pg_enable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_IPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_VPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+
+EXPORT_SYMBOL(mxc_pg_enable);
+
+void mxc_pg_disable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(0x0, MXC_PGC_IPU_PGCR);
+		if (__raw_readl(MXC_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(0x0, MXC_PGC_VPU_PGCR);
+		if (__raw_readl(MXC_PGC_VPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+
+EXPORT_SYMBOL(mxc_pg_disable);
+
+/* To change the idle power mode, need to set arch_idle_mode to a different
+ * power mode as in enum mxc_cpu_pwr_mode.
+ * May allow dynamically changing the idle mode.
+ */
+static int arch_idle_mode = WAIT_UNCLOCKED_POWER_OFF;
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void mx51_arch_idle(void)
+{
+#ifdef CONFIG_PM
+	if (likely(!mxc_jtag_enabled)) {
+		if (gpc_dvfs_clk == NULL)
+			gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+		/* gpc clock is needed for SRPG */
+		clk_enable(gpc_dvfs_clk);
+		mxc_cpu_lp_set(arch_idle_mode);
+		if ((mxc_cpu_is_rev(CHIP_REV_2_0)) < 0) {
+			u32 l2_iram_addr = IDLE_IRAM_BASE_ADDR;
+
+			if (!iram_ready)
+				return;
+
+			if (l2_iram_addr > 0x1FFE8000)
+				cpu_cortexa8_do_idle(IO_ADDRESS(l2_iram_addr));
+		} else {
+			cpu_do_idle();
+		}
+		clk_disable(gpc_dvfs_clk);
+	}
+#else
+	cpu_do_idle();
+#endif
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void mx51_arch_reset(char mode)
+{
+	u16 reg;
+	struct clk *clk;
+
+	/* Workaround to reset NFC_CONFIG3 register
+	 * due to the chip warm reset does not reset it
+	 */
+	__raw_writel(0x20600, IO_ADDRESS(NFC_BASE_ADDR) + 0x28);
+
+
+	clk = clk_get(NULL, "wdog_clk");
+	clk_enable(clk);
+
+	reg = __raw_readw(MXC_WDT_WCR) & ~WCR_SRS_BIT;
+	reg |= WCR_WDE_BIT;
+	__raw_writew(reg, MXC_WDT_WCR);
+}
diff --git a/arch/arm/mach-mx5/usb.h b/arch/arm/mach-mx5/usb.h
new file mode 100644
index 0000000..d22bf59
--- /dev/null
+++ b/arch/arm/mach-mx5/usb.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+			  int n_res, struct fsl_usb2_platform_data *config,
+			  struct arc_usb_config *arc_config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata,
+					int on);
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+#if defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config;
+#define PDATA (&dr_1301_config)
+#elif defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config;
+#define PDATA (&dr_13783_config)
+#elif defined(CONFIG_UTMI_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+#endif
+
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx5/usb_dr.c b/arch/arm/mach-mx5/usb_dr.c
new file mode 100644
index 0000000..f099ea1
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_dr.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+void fsl_usb2_data_set(struct fsl_usb2_platform_data *usb2_data);
+static int usbotg_init_ext(struct platform_device *pdev);
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata);
+static struct platform_device *usbdr_pdev;
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit_ext,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.transceiver       = "utmi",
+	.regs = &(UOG_ID),
+};
+
+static int usbdr_cb_init(void)
+{
+	if (dr_utmi_config.platform_init != NULL)
+		return dr_utmi_config.platform_init(usbdr_pdev);
+
+	return 0;
+}
+
+static void usbdr_cb_uninit(void)
+{
+	if (dr_utmi_config.platform_uninit != NULL)
+		dr_utmi_config.platform_uninit(&dr_utmi_config);
+}
+
+static void usbdr_set_vbus_power(int on)
+{
+	fsl_platform_set_vbus_power(&dr_utmi_config, on);
+}
+
+static struct arc_usb_config dr_arc_config = {
+	.name            = "DR",
+	.platform_init   = usbdr_cb_init,
+	.platform_uninit = usbdr_cb_uninit,
+	.set_vbus_power  = usbdr_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource udc_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource host_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = udc_resources,
+	.num_resources = ARRAY_SIZE(udc_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "isp1504_arc",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+/* Notes: configure USB clock*/
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+	void *p_save;
+	int ret;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(NULL, "usb_phy_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	/*derive clock from oscillator */
+	usb_clk = clk_get(NULL, "usb_utmi_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	p_save = pdev->dev.platform_data;
+	pdev->dev.platform_data = &dr_arc_config;
+	ret = usbotg_init(pdev);
+	pdev->dev.platform_data = p_save;
+	return ret;
+}
+
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(NULL, "usb_phy_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usbotg_uninit(pdata);
+}
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	usbdr_pdev = host_pdev_register(r, rs, PDATA, &dr_arc_config);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	fsl_usb2_data_set(&dr_utmi_config);
+	dr_register_otg();
+	dr_register_host(host_resources, ARRAY_SIZE(host_resources));
+	dr_register_udc();
+
+	return 0;
+}
+subsys_initcall(usb_dr_init);
+
diff --git a/arch/arm/mach-mx5/usb_h1.c b/arch/arm/mach-mx5/usb_h1.c
new file mode 100644
index 0000000..d11cba2
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h1.c
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "usb.h"
+#include "iomux.h"
+
+
+static struct platform_device *usbh1_pdev;
+/*
+ * USB Host1 HS port
+ */
+static int gpio_usbh1_init(void)
+{
+	/* Set USBH1_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO |
+			  IOMUX_CONFIG_SION);
+	mxc_set_gpio_direction(MX51_PIN_USBH1_STP, 0);
+	mxc_set_gpio_dataout(MX51_PIN_USBH1_STP, 1);
+
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		mxc_request_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_ALT1);
+		mxc_iomux_set_pad(MX51_PIN_EIM_D17, PAD_CTL_DRV_HIGH |
+			  PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+			  PAD_CTL_100K_PU | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+		mxc_set_gpio_direction(MX51_PIN_EIM_D17, 0);
+		mxc_set_gpio_dataout(MX51_PIN_EIM_D17, 1);
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+void gpio_usbh1_setback_stp(void)
+{
+	/* setback USBH1_STP to be function */
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_STP, PAD_CTL_SRE_FAST |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS |
+			  PAD_CTL_DRV_VOT_LOW);
+}
+EXPORT_SYMBOL(gpio_usbh1_setback_stp);
+
+static void gpio_usbh1_deinit(void)
+{
+	mxc_free_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.platform_init = fsl_usb_host_init,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.gpio_usb_active = gpio_usbh1_init,
+	.gpio_usb_inactive = gpio_usbh1_deinit,
+	.transceiver = "isp1504",
+	.regs = &(UH1_ID),
+};
+
+static int usbh1_cb_init(void)
+{
+	if (usbh1_config.platform_init != NULL)
+		return usbh1_config.platform_init(usbh1_pdev);
+
+	return 0;
+}
+
+static void usbh1_cb_uninit(void)
+{
+	if (usbh1_config.platform_uninit != NULL)
+		usbh1_config.platform_uninit(&usbh1_config);
+}
+
+static void usbh1_set_vbus_power(int on)
+{
+	fsl_platform_set_vbus_power(&usbh1_config, on);
+}
+
+static struct arc_usb_config usbh1_arc_config = {
+	.name            = "Host 1",
+	.platform_init   = usbh1_cb_init,
+	.platform_uninit = usbh1_cb_uninit,
+	.set_vbus_power  = usbh1_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH1_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H1REGS_BASE),
+	       .end = (u32) (USB_H1REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_USB_H1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int __init usbh1_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	usbh1_pdev = host_pdev_register(usbh1_resources, ARRAY_SIZE(usbh1_resources),
+					&usbh1_config, &usbh1_arc_config);
+	return 0;
+}
+
+subsys_initcall(usbh1_init);
diff --git a/arch/arm/mach-mx5/usb_h2.c b/arch/arm/mach-mx5/usb_h2.c
new file mode 100644
index 0000000..fac4760
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h2.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <asm/mach-types.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+#include "iomux.h"
+
+static struct platform_device *usbh2_pdev;
+/*
+ * USB Host2 HS port
+ */
+static int gpio_usbh2_init(void)
+{
+	/* Set USBH2_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+	mxc_set_gpio_direction(MX51_PIN_EIM_A26, 0);
+	mxc_set_gpio_dataout(MX51_PIN_EIM_A26, 1);
+
+	msleep(100);
+
+	return 0;
+}
+
+void gpio_usbh2_setback_stp(void)
+{
+	/* setback USBH2_STP to be function */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT2);
+}
+EXPORT_SYMBOL(gpio_usbh2_setback_stp);
+
+static void gpio_usbh2_deinit(void)
+{
+	mxc_free_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+}
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name = "Host 2",
+	.platform_init = fsl_usb_host_init,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.gpio_usb_active = gpio_usbh2_init,
+	.gpio_usb_inactive = gpio_usbh2_deinit,
+	.transceiver = "isp1504",
+	.regs = &(UH2_ID),
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H2REGS_BASE),
+	       .end = (u32) (USB_H2REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_USB_H2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int usbh2_cb_init(void)
+{
+	if (usbh2_config.platform_init != NULL)
+		return usbh2_config.platform_init(usbh2_pdev);
+
+	return 0;
+}
+
+static void usbh2_cb_uninit(void)
+{
+	if (usbh2_config.platform_uninit != NULL)
+		usbh2_config.platform_uninit(&usbh2_config);
+}
+
+static void usbh2_set_vbus_power(int on)
+{
+	fsl_platform_set_vbus_power(&usbh2_config, on);
+}
+
+static struct arc_usb_config usbh2_arc_config = {
+	.name            = "Host 2",
+	.platform_init   = usbh2_cb_init,
+	.platform_uninit = usbh2_cb_uninit,
+	.set_vbus_power  = usbh2_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH2_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	if (machine_is_mx51_3ds())
+		return 0;
+
+	usbh2_pdev = host_pdev_register(usbh2_resources,
+					ARRAY_SIZE(usbh2_resources),
+					&usbh2_config, &usbh2_arc_config);
+	return 0;
+}
+
+subsys_initcall(usbh2_init);
+
diff --git a/arch/arm/mach-mx5/wfi.S b/arch/arm/mach-mx5/wfi.S
new file mode 100644
index 0000000..5596696
--- /dev/null
+++ b/arch/arm/mach-mx5/wfi.S
@@ -0,0 +1,427 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_AUXCR_L2EN   1 << 1
+/*
+ *	cpu_cortexa8_do_idle()
+ *
+ *	Idle the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_cortexa8_do_idle)
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    ands    r2, r1, #ARM_AUXCR_L2EN @ Check if L2 is disabled
+    beq     SkipL2Access
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    bic     r2, r2, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    bic     r1, r1, #ARM_AUXCR_L2EN  @ Disable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1    @ Update aux control reg
+
+    ldr     r1, =(0x0 << 6)          @ A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2   @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0   @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x00]          @ Save tag info
+
+    ldr     r1, =(0x1 << 6)          @ A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x04]         @ Save tag info
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x08]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x0C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x10]         @ Store data info
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x14]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x18]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x1C]         @ Store data info
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x20]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x24]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x28]         @ Store data info
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x2C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x30]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x34]         @ Store data info
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x38]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x3C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x40]         @ Store data info
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x44]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x48]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x4C]         @ Store data info
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x50]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x54]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x58]         @ Store data info
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x5C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x60]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x64]         @ Store data info
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x68]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x6C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x70]         @ Store data info
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x74]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x78]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x7C]         @ Store data info
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x80]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x84]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x88]         @ Store data info
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x8C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x90]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x94]         @ Store data info
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x98]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x9C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xA0]         @ Store data info
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xA4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xA8]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xAC]         @ Store data info
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xB0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xB4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xB8]         @ Store data info
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xBC]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xC0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xC4]         @ Store data info
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xC8]         @ Save tag info
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xCC]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD0]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD4]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD8]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xDC]         @ Save tag info
+
+    .long     0xe320f003              @ Opcode for WFI
+
+    ldr     r1, =(0x0 << 6)         @ A[6] = 0
+    ldr     r2, [r0, #0x00]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x1 << 6)         @ A[6] = 1
+    ldr     r2, [r0, #0x04]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    ldr     r2, [r0, #0x08]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x0C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x10]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    ldr     r2, [r0, #0x14]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x18]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x1C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    ldr     r2, [r0, #0x20]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x24]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x28]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    ldr     r2, [r0, #0x2C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x30]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x34]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    ldr     r2, [r0, #0x38]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x3C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x40]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    ldr     r2, [r0, #0x44]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x48]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x4C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    ldr     r2, [r0, #0x50]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x54]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x58]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    ldr     r2, [r0, #0x5C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x60]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x64]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    ldr     r2, [r0, #0x68]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x6C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x70]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    ldr     r2, [r0, #0x74]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x78]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x7C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    ldr     r2, [r0, #0x80]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x84]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x88]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    ldr     r2, [r0, #0x8C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x90]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x94]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    ldr     r2, [r0, #0x98]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x9C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xA0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    ldr     r2, [r0, #0xA4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xA8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xAC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    ldr     r2, [r0, #0xB0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xB4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xB8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    ldr     r2, [r0, #0xBC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xC0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xC4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    ldr     r2, [r0, #0xC8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    ldr     r2, [r0, #0xCC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    ldr     r2, [r0, #0xD0]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    ldr     r2, [r0, #0xD4]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    ldr     r2, [r0, #0xD8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    ldr     r2, [r0, #0xDC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    orr     r1, r1, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1   @ Update aux control reg
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    orr     r2, r2, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    b       Done
+
+SkipL2Access:
+    .long     0xe320f003              @ Opcode for WFI
+
+Done:
+    mov		pc, lr
+
+	.type	cortexa8_idle_workaround, #object
+ENTRY(cortexa8_idle_workaround)
+	.word	cpu_cortexa8_do_idle
+	.size	cortexa8_idle_workaround, . - cortexa8_idle_workaround
+
-- 
1.5.5.1

