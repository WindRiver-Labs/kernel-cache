From a6b72785c7f86d71fa58bf167c5a35f6fec555dc Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Fri, 24 Oct 2008 16:37:41 +0800
Subject: [PATCH] imx_mx3_plat

MX3 arch platform common files.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-mx3/clock.c               |   67 ++++
 arch/arm/mach-mx3/devices.c             |  194 +++++++++++-
 arch/arm/plat-mxc/Makefile              |    1 +
 arch/arm/plat-mxc/clock.c               |   51 +++
 arch/arm/plat-mxc/cpu_common.c          |  166 ++++++++++
 arch/arm/plat-mxc/gpio.c                |  515 +++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/system.h |    2 +
 arch/arm/plat-mxc/irq.c                 |    3 +-
 arch/arm/plat-mxc/spba.c                |  111 +++++++
 9 files changed, 1102 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/plat-mxc/cpu_common.c
 create mode 100644 arch/arm/plat-mxc/spba.c

diff --git a/arch/arm/mach-mx3/clock.c b/arch/arm/mach-mx3/clock.c
index 9f14a87..20b343a 100644
--- a/arch/arm/mach-mx3/clock.c
+++ b/arch/arm/mach-mx3/clock.c
@@ -382,6 +382,39 @@ static unsigned long _clk_ssi1_get_rate(struct clk *clk)
 	return clk_get_rate(clk->parent) / (ssi1_prepdf + 1) / (ssi1_pdf + 1);
 }
 
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+    unsigned long ccmr;
+
+    if(clk->parent == parent)
+        return 0;
+
+    ccmr = __raw_readl(MXC_CCM_CCMR);
+
+    ccmr = (ccmr & (~MXC_CCM_CCMR_SSI1S_MASK));
+
+    /*
+    * SSI1 post divider clock source select
+    * 0x00 -- mcu clk
+    * 0x01 -- usb clk
+    * 0x02 -- serial clk
+    */
+
+    if (parent == &mcu_pll_clk)
+        ccmr |= (0x00 << MXC_CCM_CCMR_SSI1S_OFFSET);
+    else if (parent == &usb_pll_clk)
+        ccmr |= (0x01 << MXC_CCM_CCMR_SSI1S_OFFSET);
+    else if (parent == &serial_pll_clk)
+        ccmr |= (0x02 << MXC_CCM_CCMR_SSI1S_OFFSET);
+    else {
+        printk(KERN_ERR "%s: not valid clk parent\n", __func__);
+        return -1;
+    }
+
+    __raw_writel(ccmr, MXC_CCM_CCMR);
+    return 0;
+}
+
 static unsigned long _clk_ssi2_get_rate(struct clk *clk)
 {
 	unsigned long ssi2_pdf, ssi2_prepdf;
@@ -393,6 +426,38 @@ static unsigned long _clk_ssi2_get_rate(struct clk *clk)
 	return clk_get_rate(clk->parent) / (ssi2_prepdf + 1) / (ssi2_pdf + 1);
 }
 
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+    unsigned long ccmr;
+
+    if(clk->parent == parent)
+        return 0;
+
+    ccmr = __raw_readl(MXC_CCM_CCMR);
+
+    ccmr = (ccmr & (~MXC_CCM_CCMR_SSI2S_MASK));
+
+    /*
+    * SSI2 post divider clock source select
+    * 0x00 -- mcu clk
+    * 0x01 -- usb clk
+    * 0x02 -- serial clk
+    */
+
+    if (parent == &mcu_pll_clk)
+        ccmr |= (0x00 << MXC_CCM_CCMR_SSI2S_OFFSET);
+    else if (parent == &usb_pll_clk)
+        ccmr |= (0x01 << MXC_CCM_CCMR_SSI2S_OFFSET);
+    else if (parent == &serial_pll_clk)
+        ccmr |= (0x02 << MXC_CCM_CCMR_SSI2S_OFFSET);
+    else {
+        printk(KERN_ERR "%s: not valid clk parent\n", __func__);
+        return -1;
+    }
+    __raw_writel(ccmr, MXC_CCM_CCMR);
+    return 0;
+}
+
 static unsigned long _clk_firi_get_rate(struct clk *clk)
 {
 	unsigned long firi_pdf, firi_prepdf;
@@ -788,6 +853,7 @@ static struct clk ssi_clk[] = {
 	 .name = "ssi_clk",
 	 .parent = &serial_pll_clk,
 	 .get_rate = _clk_ssi1_get_rate,
+	 .set_parent = _clk_ssi1_set_parent,
 	 .enable = _clk_enable,
 	 .enable_reg = MXC_CCM_CGR0,
 	 .enable_shift = MXC_CCM_CGR0_SSI1_OFFSET,
@@ -797,6 +863,7 @@ static struct clk ssi_clk[] = {
 	 .id = 1,
 	 .parent = &serial_pll_clk,
 	 .get_rate = _clk_ssi2_get_rate,
+	 .set_parent = _clk_ssi2_set_parent,
 	 .enable = _clk_enable,
 	 .enable_reg = MXC_CCM_CGR2,
 	 .enable_shift = MXC_CCM_CGR2_SSI2_OFFSET,
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index c93f6ca..a523702 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -20,9 +20,11 @@
  */
 
 #include <linux/module.h>
+#include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/serial.h>
 #include <linux/gpio.h>
+#include <linux/clk.h>
 #include <linux/spi/spi.h>
 #include <linux/mmc/host.h>
 
@@ -165,19 +167,19 @@ int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata)
 static struct mxc_gpio_port imx_gpio_ports[] = {
 	[0] = {
 		.chip.label = "gpio-0",
-		.base = IO_ADDRESS(GPIO1_BASE_ADDR),
+		.base = (void __iomem *)IO_ADDRESS(GPIO1_BASE_ADDR),
 		.irq = MXC_INT_GPIO1,
 		.virtual_irq_start = MXC_GPIO_INT_BASE
 	},
 	[1] = {
 		.chip.label = "gpio-1",
-		.base = IO_ADDRESS(GPIO2_BASE_ADDR),
+		.base = (void __iomem *)IO_ADDRESS(GPIO2_BASE_ADDR),
 		.irq = MXC_INT_GPIO2,
 		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN
 	},
 	[2] = {
 		.chip.label = "gpio-2",
-		.base = IO_ADDRESS(GPIO3_BASE_ADDR),
+		.base = (void __iomem *)IO_ADDRESS(GPIO3_BASE_ADDR),
 		.irq = MXC_INT_GPIO3,
 		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2
 	}
@@ -239,12 +241,17 @@ int __init mxc_init_wdt(void)
 
 #if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
 
-static struct mxc_mmc_platform_data mxc_mmc_data = {
-	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+static struct mxc_mmc_platform_data mxc_mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_32_33,
 	.min_clk = 150000,
 	.max_clk = 25000000,
 	.card_inserted_state = 1,
 	.status = sdhc_get_card_det_status,
+#ifdef CONFIG_MACH_MX31_3DS
+	.wp_status = sdhc_write_protect,
+	.power_mmc = "GPO1",
+#endif
 };
 
 /*!
@@ -273,6 +280,20 @@ static struct resource mxc_sdhc1_resources[] = {
 	},
 };
 
+static struct mxc_mmc_platform_data mxc_mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_fixed = 1,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+#ifdef CONFIG_MACH_MX31_3DS
+	.wp_status = sdhc_write_protect,
+	.power_mmc = "VMMC2",
+#endif
+};
+
 /*!
  * Resource definition for the SDHC2
  */
@@ -304,7 +325,7 @@ static struct platform_device mxc_sdhc1_device = {
 	.name = "mxc_mci",
 	.id = 0,
 	.dev = {
-		.platform_data = &mxc_mmc_data,
+		.platform_data = &mxc_mmc1_data,
 	},
 	.num_resources = ARRAY_SIZE(mxc_sdhc1_resources),
 	.resource = mxc_sdhc1_resources,
@@ -315,7 +336,7 @@ static struct platform_device mxc_sdhc2_device = {
 	.name = "mxc_mci",
 	.id = 1,
 	.dev = {
-		.platform_data = &mxc_mmc_data,
+		.platform_data = &mxc_mmc2_data,
 	},
 	.num_resources = ARRAY_SIZE(mxc_sdhc2_resources),
 	.resource = mxc_sdhc2_resources,
@@ -331,7 +352,12 @@ int __init mxc_init_mmc(void)
 		mxc_sdhc1_device.resource[2].start = cd_irq;
 		mxc_sdhc1_device.resource[2].end = cd_irq;
 	}
+
+#ifdef CONFIG_MACH_MX31LITE
 	cd_irq = 0;
+#else
+	cd_irq = sdhc_init_card_det(1);
+#endif
 
     if (cd_irq) {
 		mxc_sdhc2_device.resource[2].start = cd_irq;
@@ -515,6 +541,14 @@ int __init mxc_init_pcmcia(void)
 
 #if defined(CONFIG_BLK_DEV_IDE_MXC) || defined(CONFIG_BLK_DEV_IDE_MXC_MODULE)
 
+#ifdef CONFIG_MACH_MX31_3DS
+/*! Platform Data for MXC IDE */
+static struct mxc_ide_platform_data mxc_ide_data = {
+	.power_drive = "GPO2",
+	.power_io = "GPO3",
+};
+#endif
+
 static struct resource mxc_ide_resources[] = {
 	[0] = {
 		.start = ATA_BASE_ADDR,
@@ -532,6 +566,13 @@ static struct resource mxc_ide_resources[] = {
 static struct platform_device mxc_ide_device = {
 	.name = "mxc_ide",
 	.id = 0,
+	.dev = {
+#ifdef CONFIG_MACH_MX31_3DS
+		.platform_data = &mxc_ide_data,
+#else
+		.platform_data = NULL,
+#endif
+	},
 	.num_resources = ARRAY_SIZE(mxc_ide_resources),
 	.resource = mxc_ide_resources,
 };
@@ -541,3 +582,142 @@ int __init mxc_init_ide(void)
 	return platform_device_register(&mxc_ide_device);
 }
 #endif /*CONFIG_BLK_DEV_IDE_MXC*/
+
+#if defined(CONFIG_MXC_SSI) || defined(CONFIG_MXC_SSI_MODULE)
+static struct mxc_audio_platform_data mxc_audio_data;
+/*!
+ * Resource definition for the SSI
+ */
+static struct resource mxcssi2_resources[] = {
+    [0] = {
+           .start = SSI2_BASE_ADDR,
+           .end = SSI2_BASE_ADDR + SZ_4K - 1,
+           .flags = IORESOURCE_MEM,
+           },
+};
+
+static struct resource mxcssi1_resources[] = {
+    [0] = {
+           .start = SSI1_BASE_ADDR,
+           .end = SSI1_BASE_ADDR + SZ_4K - 1,
+           .flags = IORESOURCE_MEM,
+           },
+};
+
+/*! Device Definition for MXC SSI */
+static struct platform_device mxc_ssi1_device = {
+    .name = "mxc_ssi",
+    .id = 0,
+    .dev = {
+        .platform_data = &mxc_audio_data,
+        },
+    .num_resources = ARRAY_SIZE(mxcssi1_resources),
+    .resource = mxcssi1_resources,
+};
+
+static struct platform_device mxc_ssi2_device = {
+    .name = "mxc_ssi",
+    .id = 1,
+    .dev = {
+        .platform_data = &mxc_audio_data,
+        },
+    .num_resources = ARRAY_SIZE(mxcssi2_resources),
+    .resource = mxcssi2_resources,
+};
+
+void __init mxc_init_ssi(void)
+{
+    platform_device_register(&mxc_ssi1_device);
+    platform_device_register(&mxc_ssi2_device);
+}
+#endif /*CONFIG_MXC_SSI*/
+
+#if defined(CONFIG_SND_MXC_PMIC) || defined(CONFIG_SND_MXC_PMIC_MODULE)
+static struct platform_device mxc_alsa_device = {
+    .name = "mxc_alsa",
+    .id = 0,
+    .dev = {
+        .platform_data = &mxc_audio_data,
+    },
+};
+
+void __init mxc_init_audio(void)
+{
+    struct clk *pll_clk;
+    pll_clk = clk_get(NULL, "usb_pll");
+    mxc_audio_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
+    clk_set_parent(mxc_audio_data.ssi_clk[0], pll_clk);
+    clk_put(mxc_audio_data.ssi_clk[0]);
+    if (machine_is_mx31ads() || machine_is_mx31_3ds()) {
+        mxc_audio_data.ssi_num = 1;
+    } else {
+        mxc_audio_data.ssi_num = 2;
+        mxc_audio_data.ssi_clk[1] = clk_get(NULL, "ssi_clk.1");
+        clk_set_parent(mxc_audio_data.ssi_clk[1], pll_clk);
+        clk_put(mxc_audio_data.ssi_clk[1]);
+        /* SPBA configuration for SSI2 - SDMA and MCU are set */
+        spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
+    }
+    clk_put(pll_clk);
+    mxc_audio_data.src_port = 0;
+    platform_device_register(&mxc_alsa_device);
+}
+#endif /*CONFIG_SND_MXC_PMIC*/
+
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	[0] = {
+		.start = IPU_CTRL_BASE_ADDR,
+		.end = IPU_CTRL_BASE_ADDR + SZ_4K,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_IPU_SYN,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = MXC_INT_IPU_ERR,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.platform_data = &mxc_ipu_data,
+	},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+void __init mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#endif /* CONFIG_MXC_IPU */
+
+#if defined(CONFIG_MXC_HMP4E) || defined(CONFIG_MXC_HMP4E_MODULE)
+struct platform_device mxc_hmp4e_device = {
+	.name = "mxc_hmp4e",
+	.id = 0,
+};
+
+void __init mxc_init_hmp4e(void)
+{
+	/* override fuse for Hantro HW clock */
+	if (readl(IO_ADDRESS(IIM_BASE_ADDR + 0x808)) == 0x4) {
+		if (!(readl(IO_ADDRESS(IIM_BASE_ADDR + 0x800))
+				& (1 << 5))) {
+			writel(readl(IO_ADDRESS(IIM_BASE_ADDR + 0x808)) &
+			0xfffffffb, IO_ADDRESS(IIM_BASE_ADDR + 0x808));
+		}
+	}
+
+	platform_device_register(&mxc_hmp4e_device);
+}
+#endif /* CONFIG_MXC_HMP4E */
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index db66e9a..ec20a5c 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -6,3 +6,4 @@
 obj-y := irq.o clock.o gpio.o time.o
 
 obj-$(CONFIG_ARCH_MX2) += iomux-mx1-mx2.o
+obj-$(CONFIG_ARCH_MX3) += cpu_common.o spba.o
diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
index 0a38f0b..977e929 100644
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -6,6 +6,7 @@
  * Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
  * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ * Copyright (c) 2008 Wind River Systems, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -43,6 +44,44 @@
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
+/*!
+ * This function is called to modify the
+ * contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ * @param mask       the mask to be used to clear the
+ * bits that are to be modified
+ * @param data       the data that should be written to the register
+ * */
+void mxc_ccm_modify_reg(unsigned int reg_offset,
+		unsigned int mask, unsigned int data)
+{
+	unsigned long reg;
+
+	mutex_lock(&clocks_mutex);
+	reg = __raw_readl(reg_offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, reg_offset);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(mxc_ccm_modify_reg);
+
+/*!
+ * This function is called to read the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(reg_offset);
+	return reg;
+}
+EXPORT_SYMBOL(mxc_ccm_get_reg);
+
 /*-------------------------------------------------------------------------
  * Standard clock functions defined in include/linux/clk.h
  *-------------------------------------------------------------------------*/
@@ -187,6 +226,18 @@ unsigned long clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_get_rate);
 
+/*
+ * This function returns the reference count for the clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+EXPORT_SYMBOL(clk_get_usecount);
+
 /* Decrement the clock's module reference count */
 void clk_put(struct clk *clk)
 {
diff --git a/arch/arm/plat-mxc/cpu_common.c b/arch/arm/plat-mxc/cpu_common.c
new file mode 100644
index 0000000..b61dc69
--- /dev/null
+++ b/arch/arm/plat-mxc/cpu_common.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <asm/setup.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+
+#define SYSTEM_PREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x20)
+#define SYSTEM_SREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x24)
+#define IIM_PROD_REV_SH		3
+#define IIM_PROD_REV_LEN    5
+
+extern const u32 system_rev_tbl[SYSTEM_REV_NUM][2];
+
+/*!
+ * @file cpu_common.c
+ *
+ * @brief This file contains the common CPU initialization code.
+ *
+ * @ingroup System
+ */
+
+static int system_rev_updated ;
+
+static void __init system_rev_setup(char **p)
+{
+	system_rev = simple_strtoul(*p, NULL, 16);
+	system_rev_updated = 1;
+}
+
+/* system_rev=0x10 for pass 1; 0x20 for pass 2.0; 0x21 for pass 2.1; etc */
+__early_param("system_rev=", system_rev_setup);
+
+/*
+ * This functions reads the IIM module and returns the system revision number.
+ * It does the translation from the IIM silicon revision reg value to our own
+ * convention so that it is more readable.
+ */
+static u32 read_system_rev(void)
+{
+	u32 val;
+	u32 i;
+
+	val = __raw_readl(SYSTEM_PREV_REG);
+
+	/* If the IIM doesn't contain valid product signature, return
+	 * the lowest revision number */
+	if (MXC_GET_FIELD(val, IIM_PROD_REV_LEN, IIM_PROD_REV_SH) !=
+			PROD_SIGNATURE) {
+		printk(KERN_ALERT
+				"Can't find valid PROD_REV. Default Rev=0x%x\n",
+				SYSTEM_REV_MIN);
+		return SYSTEM_REV_MIN;
+	}
+
+	/* Now trying to retrieve the silicon rev from IIM's SREV register */
+	val = __raw_readl(SYSTEM_SREV_REG);
+
+	/* ckeck SILICON_REV[7:0] first with ROM ver at [3:2] masked off */
+	for (i = 0; i < SYSTEM_REV_NUM; i++) {
+		if ((val & 0xF3) == system_rev_tbl[i][0])
+			return system_rev_tbl[i][1];
+	}
+	/* check again with SILICON_REV[3:0] masked off */
+	for (i = 0; i < SYSTEM_REV_NUM; i++) {
+		if ((val & 0xF0) == system_rev_tbl[i][0])
+			return system_rev_tbl[i][1];
+	}
+	/* Reach here only the SREV value unknown. */
+	/* Maybe due to new tapeout? */
+	if (i == SYSTEM_REV_NUM) {
+		val = system_rev_tbl[SYSTEM_REV_NUM - 1][1];
+		printk(KERN_ALERT "WARNING: Can't find valid system rev\n");
+		printk(KERN_ALERT "Assuming last known system_rev=0x%x\n", val);
+		return val;
+	}
+	return 0;
+}
+
+/*
+ * Update the system_rev value.
+ * If no system_rev is passed in through the command line, it gets the value
+ * from the IIM module. Otherwise, it uses the pass-in value.
+ */
+static void system_rev_update(void)
+{
+	int i;
+
+	if (!system_rev_updated) {
+		/* means NO value passed-in through command line */
+		system_rev = read_system_rev();
+		pr_info("system_rev is: 0x%x\n", system_rev);
+	} else {
+		pr_info("Command line passed system_rev: 0x%x\n", system_rev);
+		for (i = 0; i < SYSTEM_REV_NUM; i++) {
+			if (system_rev == system_rev_tbl[i][1])
+				break;
+		}
+		/* Reach here only the SREV value unknown. */
+		/* Maybe due to new tapeout? */
+		if (i == SYSTEM_REV_NUM)
+			panic("Command system_rev is unknown\n");
+	}
+}
+
+int mxc_jtag_enabled;
+
+/*
+ * Here are the JTAG options from the command line. By default JTAG
+ * is OFF which means JTAG is not connected and WFI is enabled
+ *
+ *       "on" --  JTAG is connected, so WFI is disabled
+ *       "off" -- JTAG is disconnected, so WFI is enabled
+ */
+
+static void __init jtag_wfi_setup(char **p)
+{
+	if (memcmp(*p, "on", 2) == 0) {
+		mxc_jtag_enabled = 1;
+		*p += 2;
+	} else if (memcmp(*p, "off", 3) == 0) {
+		mxc_jtag_enabled = 0;
+		*p += 3;
+	}
+}
+
+__early_param("jtag=", jtag_wfi_setup);
+
+/*!
+ * Enable or Disable WFI based on JTAG on boot command line
+ */
+static void __init jtag_wfi_init(void)
+{
+	if (mxc_jtag_enabled) {
+		/* Disable WFI as JTAG is connected */
+		__raw_writel(__raw_readl(AVIC_VECTOR) & ~(MXC_WFI_ENABLE),
+				AVIC_VECTOR);
+		pr_debug("jtag: on\n");
+	} else {
+		/* Enable WFI as JTAG is not connected */
+		__raw_writel(__raw_readl(AVIC_VECTOR) | (MXC_WFI_ENABLE),
+				AVIC_VECTOR);
+		pr_debug("jtag: off\n");
+	}
+}
+
+void mxc_cpu_common_init(void)
+{
+	system_rev_update();
+	jtag_wfi_init();
+}
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
index 733e0ac..551ef7d 100644
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -26,6 +26,7 @@
 #include <mach/hardware.h>
 #include <asm-generic/bug.h>
 
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 static struct mxc_gpio_port *mxc_gpio_ports;
 static int gpio_table_size;
 
@@ -251,3 +252,517 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 #endif
 	return 0;
 }
+
+#else /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
+
+#define IRQT_RISING  IRQ_TYPE_EDGE_RISING
+#define IRQT_FALLING IRQ_TYPE_EDGE_FALLING
+#define IRQT_LOW    IRQ_TYPE_LEVEL_LOW
+#define IRQT_HIGH   IRQ_TYPE_LEVEL_HIGH
+#define IRQT_BOTHEDGE (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)
+/*!
+ * @file gpio.c
+ *
+ * @brief This file contains the GPIO and IOMUX implementation details.
+ *
+ * @ingroup GPIO
+ */
+
+/* GPIO related defines */
+enum gpio_reg {
+	GPIO_DR = 0x00,
+	GPIO_GDIR = 0x04,
+	GPIO_PSR = 0x08,
+	GPIO_ICR1 = 0x0C,
+	GPIO_ICR2 = 0x10,
+	GPIO_IMR = 0x14,
+	GPIO_ISR = 0x18,
+};
+
+struct gpio_port {
+	u32 num;        /*!< gpio port number */
+	u32 base;       /*!< gpio port base VA */
+	u16 irq;        /*!< irq number to the core */
+	u16 virtual_irq_start;  /*!< virtual irq start number */
+	u32 reserved_map;   /*!< keep track of which pins are in use */
+	u32 irq_is_level_map;   /*!< if a pin's irq */
+	/* is level sensitive. default is edge */
+	spinlock_t lock;    /*!< lock when operating on the port */
+};
+static struct gpio_port gpio_port[GPIO_PORT_NUM];
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+		.num = 0,
+		.base = IO_ADDRESS(GPIO1_BASE_ADDR),
+		.irq = MXC_INT_GPIO1,
+		.virtual_irq_start = MXC_GPIO_INT_BASE,
+	},
+	{
+		.num = 1,
+		.base = IO_ADDRESS(GPIO2_BASE_ADDR),
+		.irq = MXC_INT_GPIO2,
+		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
+	},
+	{
+		.num = 2,
+		.base = IO_ADDRESS(GPIO3_BASE_ADDR),
+		.irq = MXC_INT_GPIO3,
+		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	},
+};
+
+/*
+ * Find the pointer to the gpio_port for a given pin.
+ * @param gpio      a gpio pin number
+ * @return      pointer to \b struc \b gpio_port
+ */
+static inline struct gpio_port *get_gpio_port(u32 gpio)
+{
+	return &gpio_port[GPIO_TO_PORT(gpio)];
+}
+
+/*
+ * Check if a gpio pin is within [0, MXC_MAX_GPIO_LINES -1].
+ * @param gpio      a gpio pin number
+ * @return      0 if the pin number is valid; -1 otherwise
+ */
+static int check_gpio(u32 gpio)
+{
+	if (gpio >= MXC_MAX_GPIO_LINES) {
+		printk(KERN_ERR "mxc-gpio: invalid GPIO %d\n", gpio);
+		dump_stack();
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ * Set a GPIO pin's direction
+ * @param port      pointer to a gpio_port
+ * @param index     gpio pin index value (0~31)
+ * @param is_input  0 for output; non-zero for input
+ */
+static void _set_gpio_direction(struct gpio_port *port, u32 index, int is_input)
+{
+	u32 reg = port->base + GPIO_GDIR;
+	u32 l;
+
+	l = __raw_readl(reg);
+	if (is_input)
+		l &= ~(1 << index);
+	else
+		l |= 1 << index;
+	__raw_writel(l, reg);
+}
+
+/*!
+ * Exported function to set a GPIO pin's direction
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @param is_input  1 (or non-zero) for input; 0 for output
+ */
+
+void mxc_set_gpio_direction(iomux_pin_name_t pin, int is_input)
+{
+	struct gpio_port *port;
+	u32 gpio = IOMUX_TO_GPIO(pin);
+
+	if (check_gpio(gpio) < 0)
+		return;
+	port = get_gpio_port(gpio);
+	spin_lock(&port->lock);
+	_set_gpio_direction(port, GPIO_TO_INDEX(gpio), is_input);
+	spin_unlock(&port->lock);
+}
+
+/*
+ * Set a GPIO pin's data output
+ * @param port      pointer to a gpio_port
+ * @param index     gpio pin index value (0~31)
+ * @param data      value to be set (only 0 or 1 is valid)
+ */
+static void _set_gpio_dataout(struct gpio_port *port, u32 index, u32 data)
+{
+	u32 reg = port->base + GPIO_DR;
+	u32 l = 0;
+
+	l = (__raw_readl(reg) & (~(1 << index))) | (data << index);
+	__raw_writel(l, reg);
+}
+
+/*!
+ * Exported function to set a GPIO pin's data output
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @param data      value to be set (only 0 or 1 is valid)
+ */
+void mxc_set_gpio_dataout(iomux_pin_name_t pin, u32 data)
+{
+	struct gpio_port *port;
+	u32 gpio = IOMUX_TO_GPIO(pin);
+
+	if (check_gpio(gpio) < 0)
+		return;
+
+	port = get_gpio_port(gpio);
+	spin_lock(&port->lock);
+	_set_gpio_dataout(port, GPIO_TO_INDEX(gpio), (data == 0) ? 0 : 1);
+	spin_unlock(&port->lock);
+}
+
+/*!
+ * Return the data value of a GPIO signal.
+ * @param pin   a name defined by \b iomux_pin_name_t
+ *
+ * @return  value (0 or 1) of the GPIO signal; -1 if pass in invalid pin
+ */
+int mxc_get_gpio_datain(iomux_pin_name_t pin)
+{
+	struct gpio_port *port;
+	u32 gpio = IOMUX_TO_GPIO(pin);
+
+	if (check_gpio(gpio) < 0)
+		return -1;
+
+	port = get_gpio_port(gpio);
+
+	return (__raw_readl(port->base + GPIO_DR) >> GPIO_TO_INDEX(gpio)) & 1;
+}
+
+/*
+ * Clear a GPIO signal's interrupt status
+ *
+ * @param port      pointer to a gpio_port
+ * @param index     gpio pin index value (0~31)
+ */
+static inline void _clear_gpio_irqstatus(struct gpio_port *port, u32 index)
+{
+	__raw_writel(1 << index, port->base + GPIO_ISR);
+}
+
+/*
+ * Set a GPIO pin's interrupt edge
+ * @param port      pointer to a gpio_port
+ * @param index     gpio pin index value (0~31)
+ * @param icr       one of the values defined in \b gpio_edge_t
+ *                      to indicate how to generate an interrupt
+ */
+static void _set_gpio_edge_ctrl(struct gpio_port *port, u32 index,
+		gpio_edge_t edge)
+{
+	u32 reg = port->base;
+	u32 l, sig;
+
+	reg += (index <= 15) ? GPIO_ICR1 : GPIO_ICR2;
+	sig = (index <= 15) ? index : (index - 16);
+	l = __raw_readl(reg);
+	l = (l & (~(0x3 << (sig * 2)))) | (edge << (sig * 2));
+	__raw_writel(l, reg);
+	_clear_gpio_irqstatus(port, index);
+}
+
+/*
+ * Enable/disable a GPIO signal's interrupt.
+ *
+ * @param port      pointer to a gpio_port
+ * @param index     gpio pin index value (0~31)
+ * @param enable    \b #true for enabling the interrupt; \b #false otherwise
+ */
+static inline void _set_gpio_irqenable(struct gpio_port *port, u32 index,
+		bool enable)
+{
+	u32 reg = port->base + GPIO_IMR;
+	u32 mask = (!enable) ? 0 : 1;
+	u32 l;
+
+	l = __raw_readl(reg);
+	l = (l & (~(1 << index))) | (mask << index);
+	__raw_writel(l, reg);
+}
+
+static inline int _request_gpio(struct gpio_port *port, u32 index)
+{
+	spin_lock(&port->lock);
+	if (port->reserved_map & (1 << index)) {
+		printk(KERN_ERR
+				"GPIO port %d (0-based),"
+				"pin %d is already reserved!\n",
+				port->num, index);
+		dump_stack();
+		spin_unlock(&port->lock);
+		return -1;
+	}
+	port->reserved_map |= (1 << index);
+	spin_unlock(&port->lock);
+	return 0;
+}
+
+/*!
+ * Request ownership for a GPIO pin. The caller has to check the return value
+ * of this function to make sure it returns 0 before make use of that pin.
+ * @param pin       a name defined by \b iomux_pin_name_t
+ * @return      0 if successful; Non-zero otherwise
+ */
+int mxc_request_gpio(iomux_pin_name_t pin)
+{
+	struct gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	if (check_gpio(gpio) < 0)
+		return -EINVAL;
+
+	port = get_gpio_port(gpio);
+	index = GPIO_TO_INDEX(gpio);
+
+	return _request_gpio(port, index);
+}
+
+/*!
+ * Release ownership for a GPIO pin
+ * @param pin       a name defined by \b iomux_pin_name_t
+ */
+void mxc_free_gpio(iomux_pin_name_t pin)
+{
+	struct gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	if (check_gpio(gpio) < 0)
+		return;
+
+	port = get_gpio_port(gpio);
+	index = GPIO_TO_INDEX(gpio);
+
+	spin_lock(&port->lock);
+	if ((!(port->reserved_map & (1 << index)))) {
+		printk(KERN_ERR "GPIO port %d, pin %d wasn't reserved!\n",
+				port->num, index);
+		dump_stack();
+		spin_unlock(&port->lock);
+		return;
+	}
+	port->reserved_map &= ~(1 << index);
+	port->irq_is_level_map &= ~(1 << index);
+	_set_gpio_direction(port, index, 1);
+	_set_gpio_irqenable(port, index, 0);
+	_clear_gpio_irqstatus(port, index);
+	spin_unlock(&port->lock);
+}
+
+/*
+ * We need to unmask the GPIO port interrupt as soon as possible to
+ * avoid missing GPIO interrupts for other lines in the port.
+ * Then we need to mask-read-clear-unmask the triggered GPIO lines
+ * in the port to avoid missing nested interrupts for a GPIO line.
+ * If we wait to unmask individual GPIO lines in the port after the
+ * line's interrupt handler has been run, we may miss some nested
+ * interrupts.
+ */
+static void mxc_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 isr_reg = 0, imr_reg = 0, imr_val;
+	u32 int_valid;
+	u32 gpio_irq;
+	struct gpio_port *port;
+
+	port = (struct gpio_port *)get_irq_data(irq);
+	isr_reg = port->base + GPIO_ISR;
+	imr_reg = port->base + GPIO_IMR;
+
+	imr_val = __raw_readl(imr_reg);
+	int_valid = __raw_readl(isr_reg) & imr_val;
+
+	if (unlikely(!int_valid)) {
+		printk(KERN_ERR "\nGPIO port: %d Spurious interrupt:0x%0x\n\n",
+				port->num, int_valid);
+		BUG();      /* oops */
+	}
+
+	gpio_irq = port->virtual_irq_start;
+	for (; int_valid != 0; int_valid >>= 1, gpio_irq++) {
+		struct irq_desc *d;
+
+		if (!(int_valid & 1))
+			continue;
+		d = irq_desc + gpio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nGPIO port: %d irq: %d unhandeled\n",
+					port->num, gpio_irq);
+			BUG();  /* oops */
+		}
+		d->handle_irq(gpio_irq, d);
+	}
+}
+
+#ifdef MXC_MUX_GPIO_INTERRUPTS
+static void mxc_gpio_mux_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	int i;
+	u32 isr_reg = 0, imr_reg = 0, imr_val;
+	u32 int_valid;
+	struct gpio_port *port;
+
+	for (i = 0; i < GPIO_PORT_NUM; i++) {
+		port = &gpio_port[i];
+		isr_reg = port->base + GPIO_ISR;
+		imr_reg = port->base + GPIO_IMR;
+
+		imr_val = __raw_readl(imr_reg);
+		int_valid = __raw_readl(isr_reg) & imr_val;
+
+		if (int_valid != 0) {
+			set_irq_data(irq, (void *)port);
+			mxc_gpio_irq_handler(irq, desc);
+		}
+	}
+}
+#endif
+
+/*
+ * Disable a gpio pin's interrupt by setting the bit in the imr.
+ * @param irq       a gpio virtual irq number
+ */
+static void gpio_mask_irq(u32 irq)
+{
+	u32 gpio = MXC_IRQ_TO_GPIO(irq);
+	struct gpio_port *port = get_gpio_port(gpio);
+
+	_set_gpio_irqenable(port, GPIO_TO_INDEX(gpio), 0);
+}
+
+/*
+ * Acknowledge a gpio pin's interrupt by clearing the bit in the isr.
+ * If the GPIO interrupt is level triggered, it also disables the interrupt.
+ * @param irq       a gpio virtual irq number
+ */
+static void gpio_ack_irq(u32 irq)
+{
+	u32 gpio = MXC_IRQ_TO_GPIO(irq);
+	u32 index = GPIO_TO_INDEX(gpio);
+	struct gpio_port *port = get_gpio_port(gpio);
+
+	_clear_gpio_irqstatus(port, GPIO_TO_INDEX(gpio));
+	if (port->irq_is_level_map & (1 << index))
+		gpio_mask_irq(irq);
+}
+
+/*
+ * Enable a gpio pin's interrupt by clearing the bit in the imr.
+ * @param irq       a gpio virtual irq number
+ */
+static void gpio_unmask_irq(u32 irq)
+{
+	u32 gpio = MXC_IRQ_TO_GPIO(irq);
+	struct gpio_port *port = get_gpio_port(gpio);
+
+	_set_gpio_irqenable(port, GPIO_TO_INDEX(gpio), 1);
+}
+
+/*
+ * Enable a gpio pin's interrupt by clearing the bit in the imr.
+ * @param irq       a gpio virtual irq number
+ */
+static int gpio_set_irq_type(u32 irq, u32 type)
+{
+	u32 gpio = MXC_IRQ_TO_GPIO(irq);
+	struct gpio_port *port = get_gpio_port(gpio);
+
+	switch (type) {
+	case IRQT_RISING:
+			_set_gpio_edge_ctrl(port, GPIO_TO_INDEX(gpio),
+					GPIO_INT_RISE_EDGE);
+			set_irq_handler(irq, handle_edge_irq);
+			port->irq_is_level_map &= ~(1 << GPIO_TO_INDEX(gpio));
+			break;
+	case IRQT_FALLING:
+			_set_gpio_edge_ctrl(port, GPIO_TO_INDEX(gpio),
+					GPIO_INT_FALL_EDGE);
+			set_irq_handler(irq, handle_edge_irq);
+			port->irq_is_level_map &= ~(1 << GPIO_TO_INDEX(gpio));
+			break;
+	case IRQT_LOW:
+			_set_gpio_edge_ctrl(port, GPIO_TO_INDEX(gpio),
+					GPIO_INT_LOW_LEV);
+			set_irq_handler(irq, handle_level_irq);
+			port->irq_is_level_map |= 1 << GPIO_TO_INDEX(gpio);
+			break;
+	case IRQT_HIGH:
+			_set_gpio_edge_ctrl(port, GPIO_TO_INDEX(gpio),
+					GPIO_INT_HIGH_LEV);
+			set_irq_handler(irq, handle_level_irq);
+			port->irq_is_level_map |= 1 << GPIO_TO_INDEX(gpio);
+			break;
+	case IRQT_BOTHEDGE:
+	default:
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+static struct irq_chip gpio_irq_chip = {
+	.ack = gpio_ack_irq,
+	.mask = gpio_mask_irq,
+	.unmask = gpio_unmask_irq,
+	.set_type = gpio_set_irq_type,
+};
+
+static int initialized;
+
+static int __init _mxc_gpio_init(void)
+{
+	int i;
+	struct gpio_port *port;
+
+	initialized = 1;
+
+	printk(KERN_INFO "MXC GPIO hardware\n");
+
+	for (i = 0; i < GPIO_PORT_NUM; i++) {
+		int j, gpio_count = GPIO_NUM_PIN;
+
+		port = &gpio_port[i];
+		port->base = mxc_gpio_ports[i].base;
+		port->num = mxc_gpio_ports[i].num;
+		port->irq = mxc_gpio_ports[i].irq;
+		port->virtual_irq_start = mxc_gpio_ports[i].virtual_irq_start;
+
+		port->reserved_map = 0;
+		spin_lock_init(&port->lock);
+
+		/* disable the interrupt and clear the status */
+		__raw_writel(0, port->base + GPIO_IMR);
+		__raw_writel(0xFFFFFFFF, port->base + GPIO_ISR);
+		for (j = port->virtual_irq_start;
+				j < port->virtual_irq_start + gpio_count; j++) {
+			set_irq_chip(j, &gpio_irq_chip);
+			set_irq_handler(j, handle_edge_irq);
+			set_irq_flags(j, IRQF_VALID);
+		}
+#ifndef MXC_MUX_GPIO_INTERRUPTS
+		set_irq_chained_handler(port->irq, mxc_gpio_irq_handler);
+		set_irq_data(port->irq, port);
+#endif
+	}
+
+#ifdef MXC_MUX_GPIO_INTERRUPTS
+	set_irq_chained_handler(port->irq, mxc_gpio_mux_irq_handler);
+	set_irq_data(mxc_gpio_ports[0].irq, gpio_port);
+#endif
+
+	return 0;
+}
+
+/*
+ * This may get called early from board specific init
+ */
+int mxc_gpio_init(void)
+{
+	if (!initialized)
+		return _mxc_gpio_init();
+	else
+		return 0;
+}
+
+postcore_initcall(mxc_gpio_init);
+
+#endif /*CONFIG_ARCH_REQUIRE_GPIOLIB*/
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
index 40798ae..2ecb55f 100644
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -24,8 +24,10 @@
 #include <mach/hardware.h>
 #include <asm/system.h>
 
+extern int mxc_jtag_enabled;
 static inline void arch_idle(void)
 {
+	if(!mxc_jtag_enabled)
 	cpu_do_idle();
 }
 
diff --git a/arch/arm/plat-mxc/irq.c b/arch/arm/plat-mxc/irq.c
index 1053b66..a872c69 100644
--- a/arch/arm/plat-mxc/irq.c
+++ b/arch/arm/plat-mxc/irq.c
@@ -105,9 +105,10 @@ void __init mxc_init_irq(void)
 	reg = __raw_readl(AVIC_NIPRIORITY6);
 	reg |= (0xF << 28);
 	__raw_writel(reg, AVIC_NIPRIORITY6);
-
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
 	/* init architectures chained interrupt handler */
 	mxc_register_gpios();
+#endif
 
 	printk(KERN_INFO "MXC IRQ initialized\n");
 }
diff --git a/arch/arm/plat-mxc/spba.c b/arch/arm/plat-mxc/spba.c
new file mode 100644
index 0000000..66a074c
--- /dev/null
+++ b/arch/arm/plat-mxc/spba.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/spba.h>
+
+/*!
+ * @file spba.c
+ *
+ * @brief This file contains the SPBA API implementation details.
+ *
+ * @ingroup SPBA
+ */
+
+static DEFINE_SPINLOCK(spba_lock);
+
+#define SPBA_MASTER_MIN                 1
+#define SPBA_MASTER_MAX                 7
+
+/*!
+ * the base addresses for the SPBA modules
+ */
+static unsigned long spba_base = (unsigned long)IO_ADDRESS(SPBA_CTRL_BASE_ADDR);
+
+/*!
+ * This function allows the three masters (A, B, C) to take ownership of a
+ * shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_take_ownership(int mod, int master)
+{
+	unsigned long spba_flags;
+	__u32 rtn_val = -1;
+
+	if (master < SPBA_MASTER_MIN || master > SPBA_MASTER_MAX) {
+		printk(KERN_ERR "spba_take_ownership()"
+				"invalide master= %d\n", master);
+		BUG();		/* oops */
+	}
+
+	spin_lock_irqsave(&spba_lock, spba_flags);
+	__raw_writel(master, spba_base + mod);
+
+	if ((__raw_readl(spba_base + mod) & MXC_SPBA_RAR_MASK) == master)
+		rtn_val = 0;
+
+	spin_unlock_irqrestore(&spba_lock, spba_flags);
+
+	return rtn_val;
+}
+EXPORT_SYMBOL(spba_take_ownership);
+
+/*!
+ * This function releases the ownership for a shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_rel_ownership(int mod, int master)
+{
+	unsigned long spba_flags;
+	volatile unsigned long rar;
+
+	if (master < SPBA_MASTER_MIN || master > SPBA_MASTER_MAX) {
+		printk(KERN_ERR "spba_take_ownership() "
+				"invalide master= %d\n", master);
+		BUG();		/* oops */
+	}
+
+	if ((__raw_readl(spba_base + mod) & master) == 0)
+		return 0;	/* does not own it */
+
+	spin_lock_irqsave(&spba_lock, spba_flags);
+
+	/* Since only the last 3 bits are writeable, doesn't need to mask off
+	   bits 31-3 */
+	rar = __raw_readl(spba_base + mod) & (~master);
+	__raw_writel(rar, spba_base + mod);
+
+	if ((__raw_readl(spba_base + mod) & master) != 0) {
+		spin_unlock_irqrestore(&spba_lock, spba_flags);
+		return -1;
+	}
+
+	spin_unlock_irqrestore(&spba_lock, spba_flags);
+	return 0;
+}
+EXPORT_SYMBOL(spba_rel_ownership);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SPBA");
+MODULE_LICENSE("GPL");
-- 
1.6.3.3

