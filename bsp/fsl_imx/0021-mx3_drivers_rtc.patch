From e1cd82594bb587e98cb9010e3fac560d3ec04028 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 19:15:59 +0800
Subject: [PATCH] mx3_drivers_rtc

MX3 RTC driver.
Add kernel clk interface manipulation.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/rtc/Kconfig   |    7 +
 drivers/rtc/Makefile  |    1 +
 drivers/rtc/rtc-mxc.c |  866 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 874 insertions(+), 0 deletions(-)
 create mode 100644 drivers/rtc/rtc-mxc.c

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bcc0d96..caa0085 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -433,6 +433,13 @@ config RTC_DRV_V3020
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-v3020.
 
+config RTC_DRV_MXC
+    bool "Freescale MXC Real Time Clock"
+    depends on ARCH_MXC
+    default y
+    ---help---
+      Support for Freescale MXC RTC
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_OMAP
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 3ef1dfc..e4486fd 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -60,3 +60,4 @@ obj-$(CONFIG_RTC_DRV_TWL4030)	+= rtc-twl4030.o
 obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_MXC)       += rtc-mxc.o
diff --git a/drivers/rtc/rtc-mxc.c b/drivers/rtc/rtc-mxc.c
new file mode 100644
index 0000000..88c161c
--- /dev/null
+++ b/drivers/rtc/rtc-mxc.c
@@ -0,0 +1,866 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/mxc_rtc.h>
+
+/*!
+ * @file mxc_rtc.c
+ * @brief Real Time Clock interface
+ *
+ * This file contains Real Time Clock interface for Linux.
+ *
+ * @ingroup Timers
+ */
+
+#ifdef CONFIG_MXC_MC13783_RTC
+#include <asm/plat-mxc/pmic_rtc.h>
+#else
+#define pmic_rtc_get_time(args) MXC_EXTERNAL_RTC_NONE
+#define pmic_rtc_set_time(args) MXC_EXTERNAL_RTC_NONE
+#define pmic_rtc_loaded()       0
+#endif
+
+#define RTC_VERSION     "1.0"
+#define MXC_EXTERNAL_RTC_OK 0
+#define MXC_EXTERNAL_RTC_ERR    -1
+#define MXC_EXTERNAL_RTC_NONE   -2
+
+#define DRV_NAME    "mxc_rtc"
+static struct mxc_rtc_priv *rtc_priv;
+
+/*
+ * Calculate the next alarm time given the requested alarm time mask
+ * and the current time.
+ */
+void rtc_next_alarm_time(struct rtc_time *next,
+		struct rtc_time *now, struct rtc_time *alrm)
+{
+	unsigned long next_time;
+	unsigned long now_time;
+
+	next->tm_year = now->tm_year;
+	next->tm_mon = now->tm_mon;
+	next->tm_mday = now->tm_mday;
+	next->tm_hour = alrm->tm_hour;
+	next->tm_min = alrm->tm_min;
+	next->tm_sec = alrm->tm_sec;
+
+	rtc_tm_to_time(now, &now_time);
+	rtc_tm_to_time(next, &next_time);
+
+	if (next_time < now_time) {
+		/* Advance one day */
+		next_time += 60 * 60 * 24;
+		rtc_time_to_tm(next_time, next);
+	}
+}
+
+static inline int rtc_periodic_alarm(struct rtc_time *tm)
+{
+	return  (tm->tm_year == -1) ||
+		((unsigned)tm->tm_mon >= 12) ||
+		((unsigned)(tm->tm_mday - 1) >= 31) ||
+		((unsigned)tm->tm_hour > 23) ||
+		((unsigned)tm->tm_min > 59) ||
+		((unsigned)tm->tm_sec > 59);
+}
+
+
+/*!
+ * This function reads the RTC value from some external source.
+ *
+ * @param  second       pointer to the returned value in second
+ *
+ * @return 0 if successful; non-zero otherwise
+ */
+int get_ext_rtc_time(u32 *second)
+{
+	int ret = 0;
+	struct timeval tmp;
+
+	if (!pmic_rtc_loaded())
+		return MXC_EXTERNAL_RTC_NONE;
+
+	ret = pmic_rtc_get_time(&tmp);
+
+	if (0 == ret)
+		*second = tmp.tv_sec;
+	else
+		ret = MXC_EXTERNAL_RTC_ERR;
+	return ret;
+}
+
+/*!
+ * This function sets external RTC
+ *
+ * @param  second       value in second to be set to external RTC
+ *
+ * @return 0 if successful; non-zero otherwise
+ */
+int set_ext_rtc_time(u32 second)
+{
+	int ret = 0;
+	struct timeval tmp;
+
+	if (!pmic_rtc_loaded())
+		return MXC_EXTERNAL_RTC_NONE;
+
+	tmp.tv_sec = second;
+
+	ret = pmic_rtc_set_time(&tmp);
+
+	if (0 != ret)
+		ret = MXC_EXTERNAL_RTC_ERR;
+	return ret;
+}
+
+
+static u32 rtc_freq = 4;    /* minimun value for PIE */
+static unsigned long rtc_status;
+
+static struct rtc_time g_rtc_alarm = {
+	.tm_year = 0,
+	.tm_mon = 0,
+	.tm_mday = 0,
+	.tm_hour = 0,
+	.tm_mon = 0,
+	.tm_sec = 0,
+};
+
+static DEFINE_SPINLOCK(rtc_lock);
+
+static int mxc_rtc_ioctl(struct device *dev,
+		unsigned int cmd, unsigned long arg);
+
+/*!
+ * This function is used to obtain the RTC time or the alarm value in
+ * second.
+ *
+ * @param  time_alarm   use MXC_RTC_TIME for RTC time value; MXC_RTC_ALARM for alarm value
+ *
+ * @return The RTC time or alarm time in second.
+ */
+static u32 get_alarm_or_time(int time_alarm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	u32 day, hr, min, sec, hr_min;
+
+	if (time_alarm == MXC_RTC_TIME) {
+		day = RTC_RAW_READ(base + RTC_DAYR);
+		hr_min = RTC_RAW_READ(base + RTC_HOURMIN);
+		sec = RTC_RAW_READ(base + RTC_SECOND);
+	} else if (time_alarm == MXC_RTC_ALARM) {
+		day = RTC_RAW_READ(base + RTC_DAYALARM);
+		hr_min = (0x0000FFFF) & RTC_RAW_READ(base + RTC_ALRM_HM);
+		sec = RTC_RAW_READ(base + RTC_ALRM_SEC);
+	} else
+		panic("wrong value for time_alarm=%d\n", time_alarm);
+
+	hr = hr_min >> 8;
+	min = hr_min & 0x00FF;
+
+	return (((day * 24 + hr) * 60) + min) * 60 + sec;
+}
+
+
+/*!
+ * This function sets the RTC alarm value or the time value.
+ *
+ * @param  time_alarm   the new alarm value to be updated in the RTC
+ * @param  time         use MXC_RTC_TIME for RTC time value; MXC_RTC_ALARM for alarm value
+ */
+static void set_alarm_or_time(int time_alarm, u32 time)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	u32 day, hr, min, sec, temp;
+
+	day = time / 86400;
+	time -= day * 86400;
+	/* time is within a day now */
+	hr = time / 3600;
+	time -= hr * 3600;
+	/* time is within an hour now */
+	min = time / 60;
+	sec = time - min * 60;
+
+	temp = (hr << 8) + min;
+
+	if (time_alarm == MXC_RTC_TIME) {
+		RTC_RAW_WRITE(day, base + RTC_DAYR);
+		RTC_RAW_WRITE(sec, base + RTC_SECOND);
+		RTC_RAW_WRITE(temp, base + RTC_HOURMIN);
+	} else if (time_alarm == MXC_RTC_ALARM) {
+		RTC_RAW_WRITE(day, base + RTC_DAYALARM);
+		RTC_RAW_WRITE(sec, base + RTC_ALRM_SEC);
+		RTC_RAW_WRITE(temp, base + RTC_ALRM_HM);
+	} else {
+		panic("wrong value for time_alarm=%d\n", time_alarm);
+	}
+}
+/*!
+ * This function updates the RTC alarm registers and then clears all the
+ * interrupt status bits.
+ *
+ * @param  alrm         the new alarm value to be updated in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int rtc_update_alarm(struct rtc_time *alrm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_time alarm_tm, now_tm;
+	unsigned long now, time;
+	int ret;
+
+	now = get_alarm_or_time(MXC_RTC_TIME);
+	rtc_time_to_tm(now, &now_tm);
+	rtc_next_alarm_time(&alarm_tm, &now_tm, alrm);
+	ret = rtc_tm_to_time(&alarm_tm, &time);
+
+	/* clear all the interrupt status bits */
+	RTC_RAW_WRITE(RTC_RAW_READ(base + RTC_RTCISR), base + RTC_RTCISR);
+
+	set_alarm_or_time(MXC_RTC_ALARM, time);
+
+	return ret;
+}
+
+/*!
+ * This function is the RTC interrupt service routine.
+ *
+ * @param  irq          RTC IRQ number
+ * @param  dev_id       device ID which is not used
+ *
+ * @return IRQ_HANDLED as defined in the include/linux/interrupt.h file.
+ */
+static irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)
+{
+	u32 status;
+	u32 events = 0;
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_device *rtc = (struct rtc_device *)dev_id;
+
+	spin_lock(&rtc_lock);
+
+	status = RTC_RAW_READ(base + RTC_RTCISR);
+	status &= RTC_RAW_READ(base + RTC_RTCIENR);
+	/* clear interrupt sources */
+	RTC_RAW_WRITE(status, base + RTC_RTCISR);
+
+
+	/* clear alarm interrupt if it has occurred */
+	if (status & RTC_ALM_BIT)
+		status &= ~RTC_ALM_BIT;
+
+	/* update irq data & counter */
+	if (status & RTC_ALM_BIT)
+		events |= (RTC_AF | RTC_IRQF);
+
+	if (status & RTC_1HZ_BIT)
+		events |= (RTC_UF | RTC_IRQF);
+
+	if (status & PIT_ALL_ON)
+		events |= (RTC_PF | RTC_IRQF);
+
+	if ((status & RTC_ALM_BIT) &&
+			rtc_periodic_alarm(&g_rtc_alarm))
+		rtc_update_alarm(&g_rtc_alarm);
+
+	spin_unlock(&rtc_lock);
+
+	rtc_update_irq(rtc, 1, events);
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to open the RTC driver by registering the RTC
+ * interrupt service routine.
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_open(struct device *dev)
+{
+	if (test_and_set_bit(1, &rtc_status))
+		return -EBUSY;
+	return 0;
+}
+
+
+/*!
+ * clear all interrupts and release the IRQ
+ */
+static void mxc_rtc_release(struct device *dev)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	spin_lock_irq(&rtc_lock);
+	RTC_RAW_WRITE(0, base + RTC_RTCIENR); /* Disable all rtc interrupts */
+	/* Clear all interrupt status */
+	RTC_RAW_WRITE(0xFFFFFFFF, base + RTC_RTCISR);
+	spin_unlock_irq(&rtc_lock);
+	rtc_status = 0;
+}
+
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm);
+static int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm);
+
+/*!
+ * This function is used to support some ioctl calls directly.
+ * Other ioctl calls are supported indirectly through the
+ * arm/common/rtctime.c file.
+ *
+ * @param  cmd          ioctl command as defined in include/linux/rtc.h
+ * @param  arg          value for the ioctl command
+ *
+ * @return  0 if successful or negative value otherwise.
+ */
+static int mxc_rtc_ioctl(struct device *dev,
+		unsigned int cmd, unsigned long arg)
+{
+	int i;
+	unsigned int temp;
+	unsigned int base = (unsigned int)rtc_priv->base;
+
+	switch (cmd) {
+	case RTC_PIE_OFF:
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~PIT_ALL_ON;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			return 0;
+	case RTC_IRQP_SET:
+			if (arg < 2 || arg > MAX_PIE_FREQ ||
+					(arg % 2) != 0)
+				/* Also make sure a power of 2Hz */
+				return -EINVAL;
+			if ((arg > 64) &&
+					(!capable(CAP_SYS_RESOURCE)))
+				return -EACCES;
+			rtc_freq = arg;
+			return 0;
+	case RTC_IRQP_READ:
+			return put_user(rtc_freq, (u32 *) arg);
+	case RTC_PIE_ON:
+			for (i = 0; i < MAX_PIE_NUM; i++) {
+				if (PIE_BIT_DEF[i][0] == rtc_freq)
+					break;
+			}
+			if (i == MAX_PIE_NUM)
+				return -EACCES;
+
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= PIE_BIT_DEF[i][1];
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+	case RTC_AIE_OFF:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~RTC_ALM_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_AIE_ON:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= RTC_ALM_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_UIE_OFF:
+			/* UIE is for the 1Hz interrupt */
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~RTC_1HZ_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_UIE_ON:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= RTC_1HZ_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_RD_TIME:
+			spin_lock_irq(&rtc_lock);
+			mxc_rtc_read_time(dev, (struct rtc_time *)arg);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_SET_TIME:
+			mxc_rtc_set_time(dev, (struct rtc_time *)arg);
+			return 0;
+	}
+	return -EINVAL;
+}
+
+/*!
+ * This function reads the current RTC time into tm in Gregorian date.
+ *
+ * @param  tm           contains the RTC time value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	u32 val;
+
+	/* Avoid roll-over from reading the different registers */
+	do {
+		val = get_alarm_or_time(MXC_RTC_TIME);
+	} while (val != get_alarm_or_time(MXC_RTC_TIME));
+
+	rtc_time_to_tm(val, tm);
+	return 0;
+}
+
+/*!
+ * This function sets the internal RTC
+ * time based on tm in Gregorian date.
+ *
+ * @param  tm           the time value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_time(struct device *dev,
+		struct rtc_time *tm)
+{
+	unsigned long time;
+	int ret;
+
+	ret = rtc_tm_to_time(tm, &time);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to set local RTC\n");
+		return ret;
+	}
+
+	/* Avoid roll-over from reading */
+	/* the different registers */
+	do {
+		set_alarm_or_time(MXC_RTC_TIME, time);
+	} while (time != get_alarm_or_time(MXC_RTC_TIME));
+
+	ret = set_ext_rtc_time(time);
+
+	if (ret != MXC_EXTERNAL_RTC_OK) {
+		if (ret == MXC_EXTERNAL_RTC_NONE) {
+			pr_info("No external RTC\n");
+			ret = 0;
+		} else
+			pr_info("Failed to set external RTC\n");
+	}
+	return ret;
+
+}
+
+/*!
+ * This function is the actual implementation of set_rtc() which is used
+ * by programs like NTPD to sync the internal RTC with some external clock
+ * source.
+ *
+ * @return 0 if successful; non-zero if there is pending alarm.
+ */
+static int mxc_set_rtc(void)
+{
+	unsigned long current_time = xtime.tv_sec;
+
+	if ((RTC_RAW_READ((unsigned int)rtc_priv->base +
+					RTC_RTCIENR) & RTC_ALM_BIT) != 0) {
+		/* make sure not to forward the clock over an alarm */
+		unsigned long alarm = get_alarm_or_time(MXC_RTC_ALARM);
+		if (current_time >= alarm &&
+				alarm >= get_alarm_or_time(MXC_RTC_TIME))
+			return -ERESTARTSYS;
+	}
+
+	set_alarm_or_time(MXC_RTC_TIME, current_time);
+	return 0;
+}
+
+
+/*!
+ * This function reads the current alarm value into the passed in \b alrm
+ * argument. It updates the \b alrm's pending field value based on the whether
+ * an alarm interrupt occurs or not.
+ *
+ * @param  alrm         contains the RTC alarm value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	rtc_time_to_tm(get_alarm_or_time(MXC_RTC_ALARM), &alrm->time);
+	alrm->pending = ((RTC_RAW_READ((unsigned int)rtc_priv->base +
+					RTC_RTCISR) &
+				RTC_ALM_BIT) != 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*!
+ * This function sets the RTC alarm based on passed in alrm.
+ *
+ * @param  alrm         the alarm value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_time atm, ctm;
+	int ret;
+
+	spin_lock_irq(&rtc_lock);
+	if (rtc_periodic_alarm(&alrm->time)) {
+		if (alrm->time.tm_sec > 59 ||
+				alrm->time.tm_hour > 23 ||
+				alrm->time.tm_min > 59) {
+			ret = -EINVAL;
+			goto out;
+		}
+		mxc_rtc_read_time(rtc_priv->dev, &ctm);
+		rtc_next_alarm_time(&atm, &ctm, &alrm->time);
+		ret = rtc_update_alarm(&atm);
+	} else {
+		ret = rtc_valid_tm(&alrm->time);
+		if (ret)
+			goto out;
+		ret = rtc_update_alarm(&alrm->time);
+	}
+
+	if (ret == 0) {
+		memcpy(&g_rtc_alarm, &alrm->time, sizeof(struct rtc_time));
+
+		if (alrm->enabled)
+			RTC_RAW_WRITE((RTC_RAW_READ(base +
+							RTC_RTCIENR) |
+						RTC_ALM_BIT),
+					base + RTC_RTCIENR);
+		else
+
+			RTC_RAW_WRITE((RTC_RAW_READ(base +
+							RTC_RTCIENR) &
+						(~RTC_ALM_BIT)),
+					base + RTC_RTCIENR);
+	}
+
+out:
+	spin_unlock_irq(&rtc_lock);
+
+	return ret;
+}
+
+/*!
+ * This function is used to provide the content for the /proc/driver/rtc
+ * file.
+ *
+ * @param  buf          the buffer to hold the information that the driver wants to write
+ *
+ * @return  The number of bytes written into the rtc file.
+ */
+static int mxc_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	seq_printf(seq, "alarm_IRQ\t: %s\n",
+			((RTC_RAW_READ((unsigned int)base +
+						   RTC_RTCIENR) &
+						RTC_ALM_BIT) != 0)
+						? "yes" : "no");
+	seq_printf(seq, "update_IRQ\t: %s\n",
+			((RTC_RAW_READ(base + RTC_RTCIENR) &
+			  RTC_1HZ_BIT) != 0) ? "yes" : "no");
+	seq_printf(seq, "periodic_IRQ\t: %s\n",
+			((RTC_RAW_READ(base + RTC_RTCIENR) &
+			  PIT_ALL_ON) != 0) ? "yes" : "no");
+	seq_printf(seq, "periodic_freq\t: %d\n", rtc_freq);
+
+	return 0;
+}
+
+static const struct rtc_class_ops mxc_rtc_ops = {
+	.open = mxc_rtc_open,
+	.release = mxc_rtc_release,
+	.ioctl = mxc_rtc_ioctl,
+	.read_time = mxc_rtc_read_time,
+	.set_time = mxc_rtc_set_time,
+	.read_alarm = mxc_rtc_read_alarm,
+	.set_alarm = mxc_rtc_set_alarm,
+	.proc = mxc_rtc_proc,
+};
+
+/*! MXC RTC Power management control */
+
+static struct timespec mxc_rtc_delta;
+
+static int __init mxc_rtc_probe(struct platform_device *pdev)
+{
+	struct timespec tv;
+	struct rtc_time temp_time;
+	struct rtc_device *rtc;
+	u32 sec;
+	int ret;
+
+	rtc_priv = kmalloc(sizeof(struct mxc_rtc_priv), GFP_KERNEL);
+	if (rtc_priv == NULL) {
+		pr_debug("%s: error out of memory\n", DRV_NAME);
+		return -ENOMEM;
+	}
+
+	rtc_priv->irq = platform_get_irq(pdev, 0);
+	if (rtc_priv->irq < 0) {
+		pr_debug("%s %d: no IRQ\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	rtc_priv->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (rtc_priv->res == NULL) {
+		pr_debug("%s %d: no base address\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (!request_mem_region(rtc_priv->res->start,
+				rtc_priv->res->end - rtc_priv->res->start + 1,
+				pdev->name)) {
+		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
+		ret =  -EBUSY;
+		goto err;
+	}
+
+	rtc_priv->base = (void *)IO_ADDRESS(rtc_priv->res->start);
+	if (rtc_priv->base == 0) {
+		pr_debug("%s: remap mem address failed\n", DRV_NAME);
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	rtc_priv->clk = clk_get(&pdev->dev, "rtc_clk");
+	if (IS_ERR(rtc_priv->clk)) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "no rtc_clk?\n");
+		goto err1;
+	}
+	clk_enable(rtc_priv->clk);
+
+
+	/* cpu init code should really have flagged this device as
+	 * being wake-capable; if it didn't, do that here.
+	 */
+	if (!device_can_wakeup(&pdev->dev))
+		device_init_wakeup(&pdev->dev, 1);
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+			&mxc_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		goto err2;
+	}
+
+	ret = request_irq(rtc_priv->irq, mxc_rtc_interrupt,
+			IRQF_TIMER, DRV_NAME, rtc);
+	if (ret != 0) {
+		pr_debug("rtc: IRQ%d already in use. \n", rtc_priv->irq);
+		goto err3;
+	}
+
+	rtc_priv->dev = &rtc->dev;
+
+	ret = get_ext_rtc_time(&sec);
+
+	if (ret == MXC_EXTERNAL_RTC_OK) {
+		rtc_time_to_tm(sec, &temp_time);
+		mxc_rtc_set_time(rtc_priv->dev, &temp_time);
+	} else if (ret == MXC_EXTERNAL_RTC_NONE)
+		pr_info("No external RTC clock\n");
+	else
+		pr_info("Reading external RTC failed\n");
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	do_settimeofday(&tv);
+
+	set_rtc = mxc_set_rtc;
+
+	RTC_RAW_WRITE(RTC_INPUT_CLK | RTC_ENABLE_BIT,
+			rtc_priv->base + RTC_RTCCTL);
+	if ((RTC_RAW_READ(rtc_priv->base + RTC_RTCCTL) &
+				RTC_ENABLE_BIT) == 0) {
+		pr_debug("rtc : hardware module can't be enabled!\n");
+		ret = -EINVAL;
+		goto err4;
+	}
+	printk(KERN_INFO "Real TIme clock"
+			"Driver v%s \n", RTC_VERSION);
+
+	platform_set_drvdata(pdev, rtc);
+
+	return 0;
+err4:
+	free_irq(rtc_priv->irq, rtc);
+err3:
+	rtc_device_unregister(rtc);
+err2:
+	clk_disable(rtc_priv->clk);
+	clk_put(rtc_priv->clk);
+err1:
+	release_mem_region(rtc_priv->res->start,
+			rtc_priv->res->end - rtc_priv->res->start + 1);
+err:
+	kfree(rtc_priv);
+
+	return ret;
+}
+
+
+static int __exit mxc_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	if (!rtc_priv) {
+		pr_debug("%s: No such device\n", DRV_NAME);
+		return -ENODEV;
+	}
+
+	mxc_rtc_release(rtc_priv->dev);
+
+
+	free_irq(rtc_priv->irq, rtc);
+	release_mem_region(rtc_priv->res->start,
+			rtc_priv->res->end - rtc_priv->res->start + 1);
+
+	clk_disable(rtc_priv->clk);
+	clk_put(rtc_priv->clk);
+
+	kfree(rtc_priv);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+/*!
+ * This function is called to save the system time delta relative to
+ * the MXC RTC when enterring a low power state. This time delta is
+ * then used on resume to adjust the system time to account for time
+ * loss while suspended.
+ *
+ * @param   pdev  not used
+ * @param   state Power state to enter.
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct timespec tv;
+
+	/* calculate time delta for suspend */
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	save_time_delta(&mxc_rtc_delta, &tv);
+
+	return 0;
+}
+
+/*!
+ * This function is called to correct the system time based on the
+ * current MXC RTC time relative to the time delta saved during
+ * suspend.
+ *
+ * @param   pdev  not used
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_resume(struct platform_device *pdev)
+{
+	struct timespec tv;
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	restore_time_delta(&mxc_rtc_delta, &tv);
+
+	return 0;
+}
+
+
+/*!
+ * Contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_rtc_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.bus = &platform_bus_type,
+	},
+	.probe = mxc_rtc_probe,
+	.remove = __exit_p(mxc_rtc_remove),
+	.suspend = mxc_rtc_suspend,
+	.resume = mxc_rtc_resume,
+};
+
+
+/*!
+ * This function creates the /proc/driver/rtc file and registers the device RTC
+ * in the /dev/misc directory. It also reads the RTC value from external source
+ * and setup the internal RTC properly.
+ *
+ * @return  -1 if RTC is failed to initialize; 0 is successful.
+ */
+
+
+static int __init mxc_rtc_init(void)
+{
+	return platform_driver_register(&mxc_rtc_driver);
+}
+
+/*!
+ * This function removes the /proc/driver/rtc file and un-registers the
+ * device RTC from the /dev/misc directory.
+ */
+
+
+static void __exit mxc_rtc_exit(void)
+{
+	platform_driver_unregister(&mxc_rtc_driver);
+}
+
+
+module_init(mxc_rtc_init);
+module_exit(mxc_rtc_exit);
+
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Realtime Clock Driver (RTC)");
+MODULE_LICENSE("GPL");
-- 
1.6.0.3

