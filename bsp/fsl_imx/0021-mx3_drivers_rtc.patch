From 6db15c01f72ec8234be9d233b79472f8a5a3c1a9 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Thu, 23 Oct 2008 19:15:59 +0800
Subject: [PATCH] mx3_drivers_rtc

MX3 RTC driver.
Add kernel clk interface manipulation.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

There are two hardware rtc engines on imx51pdk, one is in the security
engine, another is in the PMIC mc13892 chip. Based on these two
hardware rtc engines, develop the rtc drivers and HWclock API drivers.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/rtc/Kconfig       |   21 +
 drivers/rtc/Makefile      |    3 +
 drivers/rtc/rtc-mc13892.c |  324 +++++++++++++++++
 drivers/rtc/rtc-mxc.c     |  866 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/rtc/rtc-mxc_v2.c  |  883 +++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 2097 insertions(+), 0 deletions(-)
 create mode 100644 drivers/rtc/rtc-mc13892.c
 create mode 100644 drivers/rtc/rtc-mxc.c
 create mode 100644 drivers/rtc/rtc-mxc_v2.c

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bcc0d96..0192c74 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -433,6 +433,27 @@ config RTC_DRV_V3020
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-v3020.
 
+config RTC_DRV_MXC
+	bool "Freescale MXC Real Time Clock"
+	depends on ARCH_MXC
+	default y
+	---help---
+	  Support for Freescale MXC RTC
+
+config RTC_DRV_MXC_V2
+	tristate "Freescale MXC Secure Real Time Clock"
+	depends on ARCH_MXC
+	depends on RTC_CLASS
+	help
+	  Support for Freescale SRTC MXC
+
+config RTC_MC13892
+	tristate "Freescale MC13892 Real Time Clock"
+	depends on ARCH_MXC && MXC_PMIC_MC13892
+	depends on RTC_CLASS
+	help
+	  Support for Freescale MC13892 RTC
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_OMAP
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 3ef1dfc..6b09f69 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -60,3 +60,6 @@ obj-$(CONFIG_RTC_DRV_TWL4030)	+= rtc-twl4030.o
 obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_MXC)       += rtc-mxc.o
+obj-$(CONFIG_RTC_DRV_MXC_V2)	+= rtc-mxc_v2.o
+obj-$(CONFIG_RTC_MC13892)	+= rtc-mc13892.o
diff --git a/drivers/rtc/rtc-mc13892.c b/drivers/rtc/rtc-mc13892.c
new file mode 100644
index 0000000..3bd5c80
--- /dev/null
+++ b/drivers/rtc/rtc-mc13892.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/rtc.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm-arm/plat-mxc/pmic_status.h>
+#include <asm-arm/plat-mxc/pmic_external.h>
+
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
+struct rtc_drv_data {
+	struct rtc_device *rtc;
+	pmic_event_callback_t event;
+};
+
+#define RTC_TIME_LSH		0
+#define RTC_DAY_LSH		0
+#define RTCALARM_TIME_LSH	0
+#define RTCALARM_DAY_LSH	0
+
+#define RTC_TIME_WID		17
+#define RTC_DAY_WID		15
+#define RTCALARM_TIME_WID	17
+#define RTCALARM_DAY_WID	15
+
+static unsigned long rtc_status;
+
+#ifdef CONFIG_HWTIMER_HOOKS
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+static struct rtc_drv_data pie_data;
+static DEFINE_SPINLOCK(pmic_rtc_lock);
+extern int pmic_event_unmask(type_event event);
+extern int pmic_event_mask(type_event event);
+
+#define E1HZ			1
+
+static int rtc_get_freq(void)
+{
+	return E1HZ;
+}
+
+static void mxc_rtc_pie_int(void *data)
+{
+	if (rtc_hwtimer.hook != NULL)
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+
+}
+static int rtc_start(void)
+{
+	pmic_event_unmask(EVENT_1HZI);
+	return 0;
+}
+
+static int rtc_stop(void)
+{
+	pmic_event_mask(EVENT_1HZI);
+	return 0;
+}
+
+#endif  /* CONFIG_HWTIMER_HOOKS */
+
+
+static int mxc_rtc_open(struct device *dev)
+{
+	if (test_and_set_bit(1, &rtc_status))
+		return -EBUSY;
+	return 0;
+}
+
+static void mxc_rtc_release(struct device *dev)
+{
+	clear_bit(1, &rtc_status);
+}
+
+static int mxc_rtc_ioctl(struct device *dev, unsigned int cmd,
+			 unsigned long arg)
+{
+	switch (cmd) {
+	case RTC_AIE_OFF:
+		pr_debug("alarm off\n");
+		CHECK_ERROR(pmic_write_reg(REG_RTC_ALARM, 0x100000, 0x100000));
+		return 0;
+	case RTC_AIE_ON:
+		pr_debug("alarm on\n");
+		CHECK_ERROR(pmic_write_reg(REG_RTC_ALARM, 0, 0x100000));
+		return 0;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0, day_reg_val2;
+	unsigned int mask, value;
+	unsigned long time;
+
+	do {
+		mask = BITFMASK(RTC_DAY);
+		CHECK_ERROR(pmic_read_reg(REG_RTC_DAY, &value, mask));
+		day_reg_val = BITFEXT(value, RTC_DAY);
+
+		mask = BITFMASK(RTC_TIME);
+		CHECK_ERROR(pmic_read_reg(REG_RTC_TIME, &value, mask));
+		tod_reg_val = BITFEXT(value, RTC_TIME);
+
+		mask = BITFMASK(RTC_DAY);
+		CHECK_ERROR(pmic_read_reg(REG_RTC_DAY, &value, mask));
+		day_reg_val2 = BITFEXT(value, RTC_DAY);
+	} while (day_reg_val != day_reg_val2);
+
+	time = (unsigned long)((unsigned long)(tod_reg_val &
+					       0x0001FFFF) +
+			       (unsigned long)(day_reg_val * 86400));
+
+	rtc_time_to_tm(time, tm);
+
+	return 0;
+}
+
+static int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val, day_reg_val2 = 0;
+	unsigned int mask, value;
+	unsigned long time;
+
+	if (rtc_valid_tm(tm))
+		return -1;
+
+	rtc_tm_to_time(tm, &time);
+
+	tod_reg_val = time % 86400;
+	day_reg_val = time / 86400;
+
+	do {
+		mask = BITFMASK(RTC_DAY);
+		value = BITFVAL(RTC_DAY, day_reg_val);
+		CHECK_ERROR(pmic_write_reg(REG_RTC_DAY, value, mask));
+
+		mask = BITFMASK(RTC_TIME);
+		value = BITFVAL(RTC_TIME, tod_reg_val);
+		CHECK_ERROR(pmic_write_reg(REG_RTC_TIME, value, mask));
+
+		mask = BITFMASK(RTC_DAY);
+		CHECK_ERROR(pmic_read_reg(REG_RTC_DAY, &value, mask));
+		day_reg_val2 = BITFEXT(value, RTC_DAY);
+	} while (day_reg_val != day_reg_val2);
+
+	return 0;
+}
+
+static int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+	unsigned long time;
+
+	mask = BITFMASK(RTCALARM_TIME);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_ALARM, &value, mask));
+	tod_reg_val = BITFEXT(value, RTCALARM_TIME);
+
+	mask = BITFMASK(RTCALARM_DAY);
+	CHECK_ERROR(pmic_read_reg(REG_RTC_DAY_ALARM, &value, mask));
+	day_reg_val = BITFEXT(value, RTCALARM_DAY);
+
+	time = (unsigned long)((unsigned long)(tod_reg_val &
+					       0x0001FFFF) +
+			       (unsigned long)(day_reg_val * 86400));
+	rtc_time_to_tm(time, &(alrm->time));
+
+	return 0;
+}
+
+static int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned int tod_reg_val = 0;
+	unsigned int day_reg_val = 0;
+	unsigned int mask, value;
+	unsigned long time;
+
+	if (rtc_valid_tm(&alrm->time))
+		return -1;
+
+	rtc_tm_to_time(&alrm->time, &time);
+
+	tod_reg_val = time % 86400;
+	day_reg_val = time / 86400;
+
+	mask = BITFMASK(RTCALARM_TIME);
+	value = BITFVAL(RTCALARM_TIME, tod_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_ALARM, value, mask));
+
+	mask = BITFMASK(RTCALARM_DAY);
+	value = BITFVAL(RTCALARM_DAY, day_reg_val);
+	CHECK_ERROR(pmic_write_reg(REG_RTC_DAY_ALARM, value, mask));
+
+	return 0;
+}
+
+static struct rtc_class_ops mxc_rtc_ops = {
+	.open = mxc_rtc_open,
+	.release = mxc_rtc_release,
+	.ioctl = mxc_rtc_ioctl,
+	.read_time = mxc_rtc_read_time,
+	.set_time = mxc_rtc_set_time,
+	.read_alarm = mxc_rtc_read_alarm,
+	.set_alarm = mxc_rtc_set_alarm,
+};
+
+static void mxc_rtc_alarm_int(void *data)
+{
+	struct rtc_drv_data *pdata = data;
+
+	rtc_update_irq(pdata->rtc, 1, RTC_AF | RTC_IRQF);
+}
+
+static int mxc_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_drv_data *pdata = NULL;
+
+	printk(KERN_INFO "mc13892 rtc probe start\n");
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->event.func = mxc_rtc_alarm_int;
+	pdata->event.param = pdata;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TODAI, pdata->event));
+
+	device_init_wakeup(&pdev->dev, 1);
+	pdata->rtc = rtc_device_register(pdev->name, &pdev->dev,
+					 &mxc_rtc_ops, THIS_MODULE);
+
+	platform_set_drvdata(pdev, pdata);
+	if (IS_ERR(pdata->rtc))
+		return -1;
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	pie_data.event.func = mxc_rtc_pie_int;
+	pie_data.event.param = &pie_data;
+
+	rtc_hwtimer_data.name = "pmic_rtc";
+	rtc_hwtimer_data.desc = "Freescale PMIC Real Time Clock";
+	rtc_hwtimer_data.def_freq = 1;
+	rtc_hwtimer_data.min_freq = 1;
+	rtc_hwtimer_data.max_freq = 1;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = NULL;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &pmic_rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+
+	CHECK_ERROR(pmic_event_subscribe(EVENT_1HZI, pie_data.event));
+	pmic_event_mask(EVENT_1HZI);
+#endif
+
+	printk(KERN_INFO "mc13892 rtc probe succeed\n");
+	return 0;
+}
+
+static int __exit mxc_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_drv_data *pdata = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(pdata->rtc);
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TODAI, pdata->event));
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	unregister_hwtimer(&rtc_hwtimer);
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_1HZI, pie_data.event));
+#endif
+	return 0;
+}
+
+static struct platform_driver mxc_rtc_driver = {
+	.driver = {
+		   .name = "pmic_rtc",
+		   },
+	.probe = mxc_rtc_probe,
+	.remove = __exit_p(mxc_rtc_remove),
+};
+
+static int __init mxc_rtc_init(void)
+{
+	return platform_driver_register(&mxc_rtc_driver);
+}
+
+static void __exit mxc_rtc_exit(void)
+{
+	platform_driver_unregister(&mxc_rtc_driver);
+
+}
+
+module_init(mxc_rtc_init);
+module_exit(mxc_rtc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MC13892 Realtime Clock Driver (RTC)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/rtc-mxc.c b/drivers/rtc/rtc-mxc.c
new file mode 100644
index 0000000..88c161c
--- /dev/null
+++ b/drivers/rtc/rtc-mxc.c
@@ -0,0 +1,866 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/mxc_rtc.h>
+
+/*!
+ * @file mxc_rtc.c
+ * @brief Real Time Clock interface
+ *
+ * This file contains Real Time Clock interface for Linux.
+ *
+ * @ingroup Timers
+ */
+
+#ifdef CONFIG_MXC_MC13783_RTC
+#include <asm/plat-mxc/pmic_rtc.h>
+#else
+#define pmic_rtc_get_time(args) MXC_EXTERNAL_RTC_NONE
+#define pmic_rtc_set_time(args) MXC_EXTERNAL_RTC_NONE
+#define pmic_rtc_loaded()       0
+#endif
+
+#define RTC_VERSION     "1.0"
+#define MXC_EXTERNAL_RTC_OK 0
+#define MXC_EXTERNAL_RTC_ERR    -1
+#define MXC_EXTERNAL_RTC_NONE   -2
+
+#define DRV_NAME    "mxc_rtc"
+static struct mxc_rtc_priv *rtc_priv;
+
+/*
+ * Calculate the next alarm time given the requested alarm time mask
+ * and the current time.
+ */
+void rtc_next_alarm_time(struct rtc_time *next,
+		struct rtc_time *now, struct rtc_time *alrm)
+{
+	unsigned long next_time;
+	unsigned long now_time;
+
+	next->tm_year = now->tm_year;
+	next->tm_mon = now->tm_mon;
+	next->tm_mday = now->tm_mday;
+	next->tm_hour = alrm->tm_hour;
+	next->tm_min = alrm->tm_min;
+	next->tm_sec = alrm->tm_sec;
+
+	rtc_tm_to_time(now, &now_time);
+	rtc_tm_to_time(next, &next_time);
+
+	if (next_time < now_time) {
+		/* Advance one day */
+		next_time += 60 * 60 * 24;
+		rtc_time_to_tm(next_time, next);
+	}
+}
+
+static inline int rtc_periodic_alarm(struct rtc_time *tm)
+{
+	return  (tm->tm_year == -1) ||
+		((unsigned)tm->tm_mon >= 12) ||
+		((unsigned)(tm->tm_mday - 1) >= 31) ||
+		((unsigned)tm->tm_hour > 23) ||
+		((unsigned)tm->tm_min > 59) ||
+		((unsigned)tm->tm_sec > 59);
+}
+
+
+/*!
+ * This function reads the RTC value from some external source.
+ *
+ * @param  second       pointer to the returned value in second
+ *
+ * @return 0 if successful; non-zero otherwise
+ */
+int get_ext_rtc_time(u32 *second)
+{
+	int ret = 0;
+	struct timeval tmp;
+
+	if (!pmic_rtc_loaded())
+		return MXC_EXTERNAL_RTC_NONE;
+
+	ret = pmic_rtc_get_time(&tmp);
+
+	if (0 == ret)
+		*second = tmp.tv_sec;
+	else
+		ret = MXC_EXTERNAL_RTC_ERR;
+	return ret;
+}
+
+/*!
+ * This function sets external RTC
+ *
+ * @param  second       value in second to be set to external RTC
+ *
+ * @return 0 if successful; non-zero otherwise
+ */
+int set_ext_rtc_time(u32 second)
+{
+	int ret = 0;
+	struct timeval tmp;
+
+	if (!pmic_rtc_loaded())
+		return MXC_EXTERNAL_RTC_NONE;
+
+	tmp.tv_sec = second;
+
+	ret = pmic_rtc_set_time(&tmp);
+
+	if (0 != ret)
+		ret = MXC_EXTERNAL_RTC_ERR;
+	return ret;
+}
+
+
+static u32 rtc_freq = 4;    /* minimun value for PIE */
+static unsigned long rtc_status;
+
+static struct rtc_time g_rtc_alarm = {
+	.tm_year = 0,
+	.tm_mon = 0,
+	.tm_mday = 0,
+	.tm_hour = 0,
+	.tm_mon = 0,
+	.tm_sec = 0,
+};
+
+static DEFINE_SPINLOCK(rtc_lock);
+
+static int mxc_rtc_ioctl(struct device *dev,
+		unsigned int cmd, unsigned long arg);
+
+/*!
+ * This function is used to obtain the RTC time or the alarm value in
+ * second.
+ *
+ * @param  time_alarm   use MXC_RTC_TIME for RTC time value; MXC_RTC_ALARM for alarm value
+ *
+ * @return The RTC time or alarm time in second.
+ */
+static u32 get_alarm_or_time(int time_alarm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	u32 day, hr, min, sec, hr_min;
+
+	if (time_alarm == MXC_RTC_TIME) {
+		day = RTC_RAW_READ(base + RTC_DAYR);
+		hr_min = RTC_RAW_READ(base + RTC_HOURMIN);
+		sec = RTC_RAW_READ(base + RTC_SECOND);
+	} else if (time_alarm == MXC_RTC_ALARM) {
+		day = RTC_RAW_READ(base + RTC_DAYALARM);
+		hr_min = (0x0000FFFF) & RTC_RAW_READ(base + RTC_ALRM_HM);
+		sec = RTC_RAW_READ(base + RTC_ALRM_SEC);
+	} else
+		panic("wrong value for time_alarm=%d\n", time_alarm);
+
+	hr = hr_min >> 8;
+	min = hr_min & 0x00FF;
+
+	return (((day * 24 + hr) * 60) + min) * 60 + sec;
+}
+
+
+/*!
+ * This function sets the RTC alarm value or the time value.
+ *
+ * @param  time_alarm   the new alarm value to be updated in the RTC
+ * @param  time         use MXC_RTC_TIME for RTC time value; MXC_RTC_ALARM for alarm value
+ */
+static void set_alarm_or_time(int time_alarm, u32 time)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	u32 day, hr, min, sec, temp;
+
+	day = time / 86400;
+	time -= day * 86400;
+	/* time is within a day now */
+	hr = time / 3600;
+	time -= hr * 3600;
+	/* time is within an hour now */
+	min = time / 60;
+	sec = time - min * 60;
+
+	temp = (hr << 8) + min;
+
+	if (time_alarm == MXC_RTC_TIME) {
+		RTC_RAW_WRITE(day, base + RTC_DAYR);
+		RTC_RAW_WRITE(sec, base + RTC_SECOND);
+		RTC_RAW_WRITE(temp, base + RTC_HOURMIN);
+	} else if (time_alarm == MXC_RTC_ALARM) {
+		RTC_RAW_WRITE(day, base + RTC_DAYALARM);
+		RTC_RAW_WRITE(sec, base + RTC_ALRM_SEC);
+		RTC_RAW_WRITE(temp, base + RTC_ALRM_HM);
+	} else {
+		panic("wrong value for time_alarm=%d\n", time_alarm);
+	}
+}
+/*!
+ * This function updates the RTC alarm registers and then clears all the
+ * interrupt status bits.
+ *
+ * @param  alrm         the new alarm value to be updated in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int rtc_update_alarm(struct rtc_time *alrm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_time alarm_tm, now_tm;
+	unsigned long now, time;
+	int ret;
+
+	now = get_alarm_or_time(MXC_RTC_TIME);
+	rtc_time_to_tm(now, &now_tm);
+	rtc_next_alarm_time(&alarm_tm, &now_tm, alrm);
+	ret = rtc_tm_to_time(&alarm_tm, &time);
+
+	/* clear all the interrupt status bits */
+	RTC_RAW_WRITE(RTC_RAW_READ(base + RTC_RTCISR), base + RTC_RTCISR);
+
+	set_alarm_or_time(MXC_RTC_ALARM, time);
+
+	return ret;
+}
+
+/*!
+ * This function is the RTC interrupt service routine.
+ *
+ * @param  irq          RTC IRQ number
+ * @param  dev_id       device ID which is not used
+ *
+ * @return IRQ_HANDLED as defined in the include/linux/interrupt.h file.
+ */
+static irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)
+{
+	u32 status;
+	u32 events = 0;
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_device *rtc = (struct rtc_device *)dev_id;
+
+	spin_lock(&rtc_lock);
+
+	status = RTC_RAW_READ(base + RTC_RTCISR);
+	status &= RTC_RAW_READ(base + RTC_RTCIENR);
+	/* clear interrupt sources */
+	RTC_RAW_WRITE(status, base + RTC_RTCISR);
+
+
+	/* clear alarm interrupt if it has occurred */
+	if (status & RTC_ALM_BIT)
+		status &= ~RTC_ALM_BIT;
+
+	/* update irq data & counter */
+	if (status & RTC_ALM_BIT)
+		events |= (RTC_AF | RTC_IRQF);
+
+	if (status & RTC_1HZ_BIT)
+		events |= (RTC_UF | RTC_IRQF);
+
+	if (status & PIT_ALL_ON)
+		events |= (RTC_PF | RTC_IRQF);
+
+	if ((status & RTC_ALM_BIT) &&
+			rtc_periodic_alarm(&g_rtc_alarm))
+		rtc_update_alarm(&g_rtc_alarm);
+
+	spin_unlock(&rtc_lock);
+
+	rtc_update_irq(rtc, 1, events);
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to open the RTC driver by registering the RTC
+ * interrupt service routine.
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_open(struct device *dev)
+{
+	if (test_and_set_bit(1, &rtc_status))
+		return -EBUSY;
+	return 0;
+}
+
+
+/*!
+ * clear all interrupts and release the IRQ
+ */
+static void mxc_rtc_release(struct device *dev)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	spin_lock_irq(&rtc_lock);
+	RTC_RAW_WRITE(0, base + RTC_RTCIENR); /* Disable all rtc interrupts */
+	/* Clear all interrupt status */
+	RTC_RAW_WRITE(0xFFFFFFFF, base + RTC_RTCISR);
+	spin_unlock_irq(&rtc_lock);
+	rtc_status = 0;
+}
+
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm);
+static int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm);
+
+/*!
+ * This function is used to support some ioctl calls directly.
+ * Other ioctl calls are supported indirectly through the
+ * arm/common/rtctime.c file.
+ *
+ * @param  cmd          ioctl command as defined in include/linux/rtc.h
+ * @param  arg          value for the ioctl command
+ *
+ * @return  0 if successful or negative value otherwise.
+ */
+static int mxc_rtc_ioctl(struct device *dev,
+		unsigned int cmd, unsigned long arg)
+{
+	int i;
+	unsigned int temp;
+	unsigned int base = (unsigned int)rtc_priv->base;
+
+	switch (cmd) {
+	case RTC_PIE_OFF:
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~PIT_ALL_ON;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			return 0;
+	case RTC_IRQP_SET:
+			if (arg < 2 || arg > MAX_PIE_FREQ ||
+					(arg % 2) != 0)
+				/* Also make sure a power of 2Hz */
+				return -EINVAL;
+			if ((arg > 64) &&
+					(!capable(CAP_SYS_RESOURCE)))
+				return -EACCES;
+			rtc_freq = arg;
+			return 0;
+	case RTC_IRQP_READ:
+			return put_user(rtc_freq, (u32 *) arg);
+	case RTC_PIE_ON:
+			for (i = 0; i < MAX_PIE_NUM; i++) {
+				if (PIE_BIT_DEF[i][0] == rtc_freq)
+					break;
+			}
+			if (i == MAX_PIE_NUM)
+				return -EACCES;
+
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= PIE_BIT_DEF[i][1];
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+	case RTC_AIE_OFF:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~RTC_ALM_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_AIE_ON:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= RTC_ALM_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_UIE_OFF:
+			/* UIE is for the 1Hz interrupt */
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp &= ~RTC_1HZ_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_UIE_ON:
+			spin_lock_irq(&rtc_lock);
+			temp = RTC_RAW_READ(base + RTC_RTCIENR);
+			temp |= RTC_1HZ_BIT;
+			RTC_RAW_WRITE(temp, base + RTC_RTCIENR);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_RD_TIME:
+			spin_lock_irq(&rtc_lock);
+			mxc_rtc_read_time(dev, (struct rtc_time *)arg);
+			spin_unlock_irq(&rtc_lock);
+			return 0;
+
+	case RTC_SET_TIME:
+			mxc_rtc_set_time(dev, (struct rtc_time *)arg);
+			return 0;
+	}
+	return -EINVAL;
+}
+
+/*!
+ * This function reads the current RTC time into tm in Gregorian date.
+ *
+ * @param  tm           contains the RTC time value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	u32 val;
+
+	/* Avoid roll-over from reading the different registers */
+	do {
+		val = get_alarm_or_time(MXC_RTC_TIME);
+	} while (val != get_alarm_or_time(MXC_RTC_TIME));
+
+	rtc_time_to_tm(val, tm);
+	return 0;
+}
+
+/*!
+ * This function sets the internal RTC
+ * time based on tm in Gregorian date.
+ *
+ * @param  tm           the time value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_time(struct device *dev,
+		struct rtc_time *tm)
+{
+	unsigned long time;
+	int ret;
+
+	ret = rtc_tm_to_time(tm, &time);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to set local RTC\n");
+		return ret;
+	}
+
+	/* Avoid roll-over from reading */
+	/* the different registers */
+	do {
+		set_alarm_or_time(MXC_RTC_TIME, time);
+	} while (time != get_alarm_or_time(MXC_RTC_TIME));
+
+	ret = set_ext_rtc_time(time);
+
+	if (ret != MXC_EXTERNAL_RTC_OK) {
+		if (ret == MXC_EXTERNAL_RTC_NONE) {
+			pr_info("No external RTC\n");
+			ret = 0;
+		} else
+			pr_info("Failed to set external RTC\n");
+	}
+	return ret;
+
+}
+
+/*!
+ * This function is the actual implementation of set_rtc() which is used
+ * by programs like NTPD to sync the internal RTC with some external clock
+ * source.
+ *
+ * @return 0 if successful; non-zero if there is pending alarm.
+ */
+static int mxc_set_rtc(void)
+{
+	unsigned long current_time = xtime.tv_sec;
+
+	if ((RTC_RAW_READ((unsigned int)rtc_priv->base +
+					RTC_RTCIENR) & RTC_ALM_BIT) != 0) {
+		/* make sure not to forward the clock over an alarm */
+		unsigned long alarm = get_alarm_or_time(MXC_RTC_ALARM);
+		if (current_time >= alarm &&
+				alarm >= get_alarm_or_time(MXC_RTC_TIME))
+			return -ERESTARTSYS;
+	}
+
+	set_alarm_or_time(MXC_RTC_TIME, current_time);
+	return 0;
+}
+
+
+/*!
+ * This function reads the current alarm value into the passed in \b alrm
+ * argument. It updates the \b alrm's pending field value based on the whether
+ * an alarm interrupt occurs or not.
+ *
+ * @param  alrm         contains the RTC alarm value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	rtc_time_to_tm(get_alarm_or_time(MXC_RTC_ALARM), &alrm->time);
+	alrm->pending = ((RTC_RAW_READ((unsigned int)rtc_priv->base +
+					RTC_RTCISR) &
+				RTC_ALM_BIT) != 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*!
+ * This function sets the RTC alarm based on passed in alrm.
+ *
+ * @param  alrm         the alarm value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	struct rtc_time atm, ctm;
+	int ret;
+
+	spin_lock_irq(&rtc_lock);
+	if (rtc_periodic_alarm(&alrm->time)) {
+		if (alrm->time.tm_sec > 59 ||
+				alrm->time.tm_hour > 23 ||
+				alrm->time.tm_min > 59) {
+			ret = -EINVAL;
+			goto out;
+		}
+		mxc_rtc_read_time(rtc_priv->dev, &ctm);
+		rtc_next_alarm_time(&atm, &ctm, &alrm->time);
+		ret = rtc_update_alarm(&atm);
+	} else {
+		ret = rtc_valid_tm(&alrm->time);
+		if (ret)
+			goto out;
+		ret = rtc_update_alarm(&alrm->time);
+	}
+
+	if (ret == 0) {
+		memcpy(&g_rtc_alarm, &alrm->time, sizeof(struct rtc_time));
+
+		if (alrm->enabled)
+			RTC_RAW_WRITE((RTC_RAW_READ(base +
+							RTC_RTCIENR) |
+						RTC_ALM_BIT),
+					base + RTC_RTCIENR);
+		else
+
+			RTC_RAW_WRITE((RTC_RAW_READ(base +
+							RTC_RTCIENR) &
+						(~RTC_ALM_BIT)),
+					base + RTC_RTCIENR);
+	}
+
+out:
+	spin_unlock_irq(&rtc_lock);
+
+	return ret;
+}
+
+/*!
+ * This function is used to provide the content for the /proc/driver/rtc
+ * file.
+ *
+ * @param  buf          the buffer to hold the information that the driver wants to write
+ *
+ * @return  The number of bytes written into the rtc file.
+ */
+static int mxc_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	unsigned int base = (unsigned int)rtc_priv->base;
+	seq_printf(seq, "alarm_IRQ\t: %s\n",
+			((RTC_RAW_READ((unsigned int)base +
+						   RTC_RTCIENR) &
+						RTC_ALM_BIT) != 0)
+						? "yes" : "no");
+	seq_printf(seq, "update_IRQ\t: %s\n",
+			((RTC_RAW_READ(base + RTC_RTCIENR) &
+			  RTC_1HZ_BIT) != 0) ? "yes" : "no");
+	seq_printf(seq, "periodic_IRQ\t: %s\n",
+			((RTC_RAW_READ(base + RTC_RTCIENR) &
+			  PIT_ALL_ON) != 0) ? "yes" : "no");
+	seq_printf(seq, "periodic_freq\t: %d\n", rtc_freq);
+
+	return 0;
+}
+
+static const struct rtc_class_ops mxc_rtc_ops = {
+	.open = mxc_rtc_open,
+	.release = mxc_rtc_release,
+	.ioctl = mxc_rtc_ioctl,
+	.read_time = mxc_rtc_read_time,
+	.set_time = mxc_rtc_set_time,
+	.read_alarm = mxc_rtc_read_alarm,
+	.set_alarm = mxc_rtc_set_alarm,
+	.proc = mxc_rtc_proc,
+};
+
+/*! MXC RTC Power management control */
+
+static struct timespec mxc_rtc_delta;
+
+static int __init mxc_rtc_probe(struct platform_device *pdev)
+{
+	struct timespec tv;
+	struct rtc_time temp_time;
+	struct rtc_device *rtc;
+	u32 sec;
+	int ret;
+
+	rtc_priv = kmalloc(sizeof(struct mxc_rtc_priv), GFP_KERNEL);
+	if (rtc_priv == NULL) {
+		pr_debug("%s: error out of memory\n", DRV_NAME);
+		return -ENOMEM;
+	}
+
+	rtc_priv->irq = platform_get_irq(pdev, 0);
+	if (rtc_priv->irq < 0) {
+		pr_debug("%s %d: no IRQ\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	rtc_priv->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (rtc_priv->res == NULL) {
+		pr_debug("%s %d: no base address\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (!request_mem_region(rtc_priv->res->start,
+				rtc_priv->res->end - rtc_priv->res->start + 1,
+				pdev->name)) {
+		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
+		ret =  -EBUSY;
+		goto err;
+	}
+
+	rtc_priv->base = (void *)IO_ADDRESS(rtc_priv->res->start);
+	if (rtc_priv->base == 0) {
+		pr_debug("%s: remap mem address failed\n", DRV_NAME);
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	rtc_priv->clk = clk_get(&pdev->dev, "rtc_clk");
+	if (IS_ERR(rtc_priv->clk)) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "no rtc_clk?\n");
+		goto err1;
+	}
+	clk_enable(rtc_priv->clk);
+
+
+	/* cpu init code should really have flagged this device as
+	 * being wake-capable; if it didn't, do that here.
+	 */
+	if (!device_can_wakeup(&pdev->dev))
+		device_init_wakeup(&pdev->dev, 1);
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+			&mxc_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		goto err2;
+	}
+
+	ret = request_irq(rtc_priv->irq, mxc_rtc_interrupt,
+			IRQF_TIMER, DRV_NAME, rtc);
+	if (ret != 0) {
+		pr_debug("rtc: IRQ%d already in use. \n", rtc_priv->irq);
+		goto err3;
+	}
+
+	rtc_priv->dev = &rtc->dev;
+
+	ret = get_ext_rtc_time(&sec);
+
+	if (ret == MXC_EXTERNAL_RTC_OK) {
+		rtc_time_to_tm(sec, &temp_time);
+		mxc_rtc_set_time(rtc_priv->dev, &temp_time);
+	} else if (ret == MXC_EXTERNAL_RTC_NONE)
+		pr_info("No external RTC clock\n");
+	else
+		pr_info("Reading external RTC failed\n");
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	do_settimeofday(&tv);
+
+	set_rtc = mxc_set_rtc;
+
+	RTC_RAW_WRITE(RTC_INPUT_CLK | RTC_ENABLE_BIT,
+			rtc_priv->base + RTC_RTCCTL);
+	if ((RTC_RAW_READ(rtc_priv->base + RTC_RTCCTL) &
+				RTC_ENABLE_BIT) == 0) {
+		pr_debug("rtc : hardware module can't be enabled!\n");
+		ret = -EINVAL;
+		goto err4;
+	}
+	printk(KERN_INFO "Real TIme clock"
+			"Driver v%s \n", RTC_VERSION);
+
+	platform_set_drvdata(pdev, rtc);
+
+	return 0;
+err4:
+	free_irq(rtc_priv->irq, rtc);
+err3:
+	rtc_device_unregister(rtc);
+err2:
+	clk_disable(rtc_priv->clk);
+	clk_put(rtc_priv->clk);
+err1:
+	release_mem_region(rtc_priv->res->start,
+			rtc_priv->res->end - rtc_priv->res->start + 1);
+err:
+	kfree(rtc_priv);
+
+	return ret;
+}
+
+
+static int __exit mxc_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	if (!rtc_priv) {
+		pr_debug("%s: No such device\n", DRV_NAME);
+		return -ENODEV;
+	}
+
+	mxc_rtc_release(rtc_priv->dev);
+
+
+	free_irq(rtc_priv->irq, rtc);
+	release_mem_region(rtc_priv->res->start,
+			rtc_priv->res->end - rtc_priv->res->start + 1);
+
+	clk_disable(rtc_priv->clk);
+	clk_put(rtc_priv->clk);
+
+	kfree(rtc_priv);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+/*!
+ * This function is called to save the system time delta relative to
+ * the MXC RTC when enterring a low power state. This time delta is
+ * then used on resume to adjust the system time to account for time
+ * loss while suspended.
+ *
+ * @param   pdev  not used
+ * @param   state Power state to enter.
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct timespec tv;
+
+	/* calculate time delta for suspend */
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	save_time_delta(&mxc_rtc_delta, &tv);
+
+	return 0;
+}
+
+/*!
+ * This function is called to correct the system time based on the
+ * current MXC RTC time relative to the time delta saved during
+ * suspend.
+ *
+ * @param   pdev  not used
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_resume(struct platform_device *pdev)
+{
+	struct timespec tv;
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = get_alarm_or_time(MXC_RTC_TIME);
+	restore_time_delta(&mxc_rtc_delta, &tv);
+
+	return 0;
+}
+
+
+/*!
+ * Contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_rtc_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.bus = &platform_bus_type,
+	},
+	.probe = mxc_rtc_probe,
+	.remove = __exit_p(mxc_rtc_remove),
+	.suspend = mxc_rtc_suspend,
+	.resume = mxc_rtc_resume,
+};
+
+
+/*!
+ * This function creates the /proc/driver/rtc file and registers the device RTC
+ * in the /dev/misc directory. It also reads the RTC value from external source
+ * and setup the internal RTC properly.
+ *
+ * @return  -1 if RTC is failed to initialize; 0 is successful.
+ */
+
+
+static int __init mxc_rtc_init(void)
+{
+	return platform_driver_register(&mxc_rtc_driver);
+}
+
+/*!
+ * This function removes the /proc/driver/rtc file and un-registers the
+ * device RTC from the /dev/misc directory.
+ */
+
+
+static void __exit mxc_rtc_exit(void)
+{
+	platform_driver_unregister(&mxc_rtc_driver);
+}
+
+
+module_init(mxc_rtc_init);
+module_exit(mxc_rtc_exit);
+
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Realtime Clock Driver (RTC)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/rtc-mxc_v2.c b/drivers/rtc/rtc-mxc_v2.c
new file mode 100644
index 0000000..8419516
--- /dev/null
+++ b/drivers/rtc/rtc-mxc_v2.c
@@ -0,0 +1,883 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*
+ * Implementation based on rtc-ds1553.c
+ */
+
+/*!
+ * @defgroup RTC Real Time Clock (RTC) Driver
+ */
+/*!
+ * @file rtc-mxc_v2.c
+ * @brief Real Time Clock interface
+ *
+ * This file contains Real Time Clock interface for Linux.
+ *
+ * @ingroup RTC
+ */
+
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
+#define SRTC_LPPDR_INIT       0x41736166	/* init for glitch detect */
+
+#define SRTC_LPCR_SWR_LP      (1 << 0)	/* lp software reset */
+#define SRTC_LPCR_EN_LP       (1 << 3)	/* lp enable */
+#define SRTC_LPCR_WAE         (1 << 4)	/* lp wakeup alarm enable */
+#define SRTC_LPCR_SAE         (1 << 5)	/* lp security alarm enable */
+#define SRTC_LPCR_SI          (1 << 6)	/* lp security interrupt enable */
+#define SRTC_LPCR_ALP         (1 << 7)	/* lp alarm flag */
+#define SRTC_LPCR_LTC         (1 << 8)	/* lp lock time counter */
+#define SRTC_LPCR_LMC         (1 << 9)	/* lp lock monotonic counter */
+#define SRTC_LPCR_SV          (1 << 10)	/* lp security violation */
+#define SRTC_LPCR_NSA         (1 << 11)	/* lp non secure access */
+#define SRTC_LPCR_NVEIE       (1 << 12)	/* lp non valid state exit int en */
+#define SRTC_LPCR_IEIE        (1 << 13)	/* lp init state exit int enable */
+#define SRTC_LPCR_NVE         (1 << 14)	/* lp non valid state exit bit */
+#define SRTC_LPCR_IE          (1 << 15)	/* lp init state exit bit */
+
+#define SRTC_LPCR_ALL_INT_EN (SRTC_LPCR_WAE | SRTC_LPCR_SAE | \
+			      SRTC_LPCR_SI | SRTC_LPCR_ALP | \
+			      SRTC_LPCR_NVEIE | SRTC_LPCR_IEIE)
+
+#define SRTC_LPSR_TRI         (1 << 0)	/* lp time read invalidate */
+#define SRTC_LPSR_PGD         (1 << 1)	/* lp power supply glitc detected */
+#define SRTC_LPSR_CTD         (1 << 2)	/* lp clock tampering detected */
+#define SRTC_LPSR_ALP         (1 << 3)	/* lp alarm flag */
+#define SRTC_LPSR_MR          (1 << 4)	/* lp monotonic counter rollover */
+#define SRTC_LPSR_TR          (1 << 5)	/* lp time rollover */
+#define SRTC_LPSR_EAD         (1 << 6)	/* lp external alarm detected */
+#define SRTC_LPSR_IT0         (1 << 7)	/* lp IIM throttle */
+#define SRTC_LPSR_IT1         (1 << 8)
+#define SRTC_LPSR_IT2         (1 << 9)
+#define SRTC_LPSR_SM0         (1 << 10)	/* lp security mode */
+#define SRTC_LPSR_SM1         (1 << 11)
+#define SRTC_LPSR_STATE_LP0   (1 << 12)	/* lp state */
+#define SRTC_LPSR_STATE_LP1   (1 << 13)
+#define SRTC_LPSR_NVES        (1 << 14)	/* lp non-valid state exit status */
+#define SRTC_LPSR_IES         (1 << 15)	/* lp init state exit status */
+
+#define MAX_PIE_NUM     15
+#define MAX_PIE_FREQ    32768
+#define MIN_PIE_FREQ	1
+
+#define SRTC_PI0         (1 << 0)
+#define SRTC_PI1         (1 << 1)
+#define SRTC_PI2         (1 << 2)
+#define SRTC_PI3         (1 << 3)
+#define SRTC_PI4         (1 << 4)
+#define SRTC_PI5         (1 << 5)
+#define SRTC_PI6         (1 << 6)
+#define SRTC_PI7         (1 << 7)
+#define SRTC_PI8         (1 << 8)
+#define SRTC_PI9         (1 << 9)
+#define SRTC_PI10        (1 << 10)
+#define SRTC_PI11        (1 << 11)
+#define SRTC_PI12        (1 << 12)
+#define SRTC_PI13        (1 << 13)
+#define SRTC_PI14        (1 << 14)
+#define SRTC_PI15        (1 << 15)
+
+#define PIT_ALL_ON      (SRTC_PI1 | SRTC_PI2 | SRTC_PI3 | \
+			SRTC_PI4 | SRTC_PI5 | SRTC_PI6 | SRTC_PI7 | \
+			SRTC_PI8 | SRTC_PI9 | SRTC_PI10 | SRTC_PI11 | \
+			SRTC_PI12 | SRTC_PI13 | SRTC_PI14 | SRTC_PI15)
+
+#define SRTC_SWR_HP      (1 << 0)	/* hp software reset */
+#define SRTC_EN_HP       (1 << 3)	/* hp enable */
+#define SRTC_TS          (1 << 4)	/* time syncronize hp with lp */
+
+#define SRTC_IE_AHP      (1 << 16)	/* Alarm HP Interrupt Enable bit */
+#define SRTC_IE_WDHP     (1 << 18)	/* Write Done HP Interrupt Enable bit */
+#define SRTC_IE_WDLP     (1 << 19)	/* Write Done LP Interrupt Enable bit */
+
+#define SRTC_ISR_AHP     (1 << 16)	/* interrupt status: alarm hp */
+#define SRTC_ISR_WDHP    (1 << 18)	/* interrupt status: write done hp */
+#define SRTC_ISR_WDLP    (1 << 19)	/* interrupt status: write done lp */
+#define SRTC_ISR_WPHP    (1 << 20)	/* interrupt status: write pending hp */
+#define SRTC_ISR_WPLP    (1 << 21)	/* interrupt status: write pending lp */
+
+#define SRTC_LPSCMR	0x00	/* LP Secure Counter MSB Reg */
+#define SRTC_LPSCLR	0x04	/* LP Secure Counter LSB Reg */
+#define SRTC_LPSAR	0x08	/* LP Secure Alarm Reg */
+#define SRTC_LPSMCR	0x0C	/* LP Secure Monotonic Counter Reg */
+#define SRTC_LPCR	0x10	/* LP Control Reg */
+#define SRTC_LPSR	0x14	/* LP Status Reg */
+#define SRTC_LPPDR	0x18	/* LP Power Supply Glitch Detector Reg */
+#define SRTC_LPGR	0x1C	/* LP General Purpose Reg */
+#define SRTC_HPCMR	0x20	/* HP Counter MSB Reg */
+#define SRTC_HPCLR	0x24	/* HP Counter LSB Reg */
+#define SRTC_HPAMR	0x28	/* HP Alarm MSB Reg */
+#define SRTC_HPALR	0x2C	/* HP Alarm LSB Reg */
+#define SRTC_HPCR	0x30	/* HP Control Reg */
+#define SRTC_HPISR	0x34	/* HP Interrupt Status Reg */
+#define SRTC_HPIENR	0x38	/* HP Interrupt Enable Reg */
+
+#define SRTC_SECMODE_MASK	0x3	/* the mask of SRTC security mode */
+#define SRTC_SECMODE_LOW	0x0	/* Low Security */
+#define SRTC_SECMODE_MED	0x1	/* Medium Security */
+#define SRTC_SECMODE_HIGH	0x2	/* High Security */
+#define SRTC_SECMODE_RESERVED	0x3	/* Reserved */
+
+struct rtc_drv_data {
+	struct rtc_device *rtc;
+	void __iomem *ioaddr;
+	unsigned long baseaddr;
+	int irq;
+	struct clk *clk;
+	bool irq_enable;
+};
+
+/*!
+ * @defgroup RTC Real Time Clock (RTC) Driver
+ */
+/*!
+ * @file rtc-mxc.c
+ * @brief Real Time Clock interface
+ *
+ * This file contains Real Time Clock interface for Linux.
+ *
+ * @ingroup RTC
+ */
+
+static unsigned long rtc_status;
+
+static DEFINE_SPINLOCK(rtc_lock);
+
+#ifdef CONFIG_HWTIMER_HOOKS
+#define EPIT1_CR	IO_ADDRESS((EPIT1_BASE_ADDR + 0x0))
+#define EPIT1_SR	IO_ADDRESS((EPIT1_BASE_ADDR + 0x4))
+#define EPIT1_LR	IO_ADDRESS((EPIT1_BASE_ADDR + 0x8))
+#define EPIT1_CMPR	IO_ADDRESS((EPIT1_BASE_ADDR + 0xC))
+#define EPIT1_CNR	IO_ADDRESS((EPIT1_BASE_ADDR + 0x10))
+
+#define EPIT1_CR_EN		(1<<0)
+#define EPIT1_CR_ENMOD		(1<<1)
+#define EPIT1_CR_OCIEN		(1<<2)
+#define EPIT1_CR_RLD		(1<<3)
+#define EPIT1_CR_IOVW		(1<<17)
+#define EPIT1_CR_CLKSRC_LF	(3<<24)
+#define EPIT1_CR_CLKSRC_PF	(1<<24)
+
+#define EPIT1_SR_CCIF	(1<<0)
+
+static u32 input_freq;
+
+static struct hwtimer rtc_hwtimer;
+static struct hwtimer_data rtc_hwtimer_data;
+
+static int rtc_get_freq(void)
+{
+	u32 lv;
+	lv = __raw_readl(EPIT1_LR);
+
+	return input_freq/lv;
+}
+
+static int rtc_set_freq(int freq)
+{
+	u32 newfreq;
+
+	newfreq = input_freq/freq;
+	__raw_writel(newfreq, EPIT1_LR);
+
+	return 0;
+}
+
+static int rtc_start(void)
+{
+	__raw_writel(__raw_readl(EPIT1_CR) | EPIT1_CR_EN, EPIT1_CR);
+	return 0;
+}
+
+static int rtc_stop(void)
+{
+	__raw_writel((__raw_readl(EPIT1_CR) & ~EPIT1_CR_EN), EPIT1_CR);
+	return 0;
+}
+#endif	/* CONFIG_HWTIMER_HOOKS */
+
+/*!
+ * This function does write synchronization for writes to the lp srtc block.
+ * To take care of the asynchronous CKIL clock, all writes from the IP domain
+ * will be synchronized to the CKIL domain.
+ */
+static inline void rtc_write_sync_lp(void __iomem *ioaddr)
+{
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WPLP) != 0)
+		msleep(1);
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WDLP) == 0)
+		msleep(1);
+	__raw_writel(SRTC_ISR_WDLP, ioaddr + SRTC_HPISR);
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WPHP) != 0)
+		msleep(1);
+}
+
+static inline void rtc_write_sync_lp_no_wait(void __iomem *ioaddr)
+{
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WPLP) != 0)
+		;
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WDLP) == 0)
+		;
+	__raw_writel(SRTC_ISR_WDLP, ioaddr + SRTC_HPISR);
+	while ((__raw_readl(ioaddr + SRTC_HPISR) & SRTC_ISR_WPHP) != 0)
+		;
+}
+
+/*!
+ * This function updates the RTC alarm registers and then clears all the
+ * interrupt status bits.
+ *
+ * @param  alrm         the new alarm value to be updated in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int rtc_update_alarm(struct device *dev, struct rtc_time *alrm)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	struct rtc_time alarm_tm, now_tm;
+	unsigned long now, time;
+	int ret;
+
+	now = __raw_readl(ioaddr + SRTC_LPSCMR);
+	rtc_time_to_tm(now, &now_tm);
+
+	alarm_tm.tm_year = now_tm.tm_year;
+	alarm_tm.tm_mon = now_tm.tm_mon;
+	alarm_tm.tm_mday = now_tm.tm_mday;
+
+	alarm_tm.tm_hour = alrm->tm_hour;
+	alarm_tm.tm_min = alrm->tm_min;
+	alarm_tm.tm_sec = alrm->tm_sec;
+
+	rtc_tm_to_time(&now_tm, &now);
+	rtc_tm_to_time(&alarm_tm, &time);
+
+	if (time < now) {
+		time += 60 * 60 * 24;
+		rtc_time_to_tm(time, &alarm_tm);
+	}
+	ret = rtc_tm_to_time(&alarm_tm, &time);
+
+	__raw_writel(time, ioaddr + SRTC_LPSAR);
+
+	/* clear alarm interrupt status bit */
+	__raw_writel(SRTC_LPSR_ALP, ioaddr + SRTC_LPSR);
+
+	return ret;
+}
+
+
+#ifdef CONFIG_HWTIMER_HOOKS
+static irqreturn_t mxc_epit_interrupt(int irq, void *dev_id)
+{
+	__raw_writel(EPIT1_SR_CCIF, EPIT1_SR);
+
+	if (rtc_hwtimer.hook != NULL)
+		rtc_hwtimer.hook(rtc_hwtimer.hook_data);
+
+	return IRQ_HANDLED;
+}
+#endif
+/*!
+ * This function is the RTC interrupt service routine.
+ *
+ * @param  irq          RTC IRQ number
+ * @param  dev_id       device ID which is not used
+ *
+ * @return IRQ_HANDLED as defined in the include/linux/interrupt.h file.
+ */
+static irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct rtc_drv_data *pdata = platform_get_drvdata(pdev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	u32 lp_status, lp_cr;
+	u32 events = 0;
+
+	lp_status = __raw_readl(ioaddr + SRTC_LPSR);
+	lp_cr = __raw_readl(ioaddr + SRTC_LPCR);
+
+	/* update irq data & counter */
+	if (lp_status & SRTC_LPSR_ALP) {
+		if (lp_cr & SRTC_LPCR_ALP)
+			events |= (RTC_AF | RTC_IRQF);
+
+		/* disable further lp alarm interrupts */
+		lp_cr &= ~(SRTC_LPCR_ALP | SRTC_LPCR_WAE);
+	}
+
+	/* Update interrupt enables */
+	__raw_writel(lp_cr, ioaddr + SRTC_LPCR);
+
+	/* If no interrupts are enabled, turn off interrupts in kernel */
+	if (((lp_cr & SRTC_LPCR_ALL_INT_EN) == 0) && (pdata->irq_enable)) {
+		disable_irq(pdata->irq);
+		pdata->irq_enable = false;
+	}
+
+	/* clear interrupt status */
+	__raw_writel(lp_status, ioaddr + SRTC_LPSR);
+
+	rtc_update_irq(pdata->rtc, 1, events);
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to open the RTC driver.
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_open(struct device *dev)
+{
+	if (test_and_set_bit(1, &rtc_status))
+		return -EBUSY;
+	return 0;
+}
+
+/*!
+ * clear all interrupts and release the IRQ
+ */
+static void mxc_rtc_release(struct device *dev)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	unsigned long lock_flags = 0;
+
+	spin_lock_irqsave(&rtc_lock, lock_flags);
+
+	/* Disable all rtc interrupts */
+	__raw_writel(__raw_readl(ioaddr + SRTC_LPCR) & ~(SRTC_LPCR_ALL_INT_EN),
+		     ioaddr + SRTC_LPCR);
+
+	/* Clear all interrupt status */
+	__raw_writel(0xFFFFFFFF, ioaddr + SRTC_LPSR);
+
+	spin_unlock_irqrestore(&rtc_lock, lock_flags);
+	rtc_status = 0;
+}
+
+/*!
+ * This function is used to support some ioctl calls directly.
+ * Other ioctl calls are supported indirectly through the
+ * arm/common/rtctime.c file.
+ *
+ * @param  cmd          ioctl command as defined in include/linux/rtc.h
+ * @param  arg          value for the ioctl command
+ *
+ * @return  0 if successful or negative value otherwise.
+ */
+static int mxc_rtc_ioctl(struct device *dev, unsigned int cmd,
+			 unsigned long arg)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	unsigned long lock_flags = 0;
+	u32 lp_cr;
+
+	switch (cmd) {
+	case RTC_AIE_OFF:
+		spin_lock_irqsave(&rtc_lock, lock_flags);
+		lp_cr = __raw_readl(ioaddr + SRTC_LPCR);
+		lp_cr &= ~(SRTC_LPCR_ALP | SRTC_LPCR_WAE);
+		if (((lp_cr & SRTC_LPCR_ALL_INT_EN) == 0)
+		    && (pdata->irq_enable)) {
+			disable_irq(pdata->irq);
+			pdata->irq_enable = false;
+		}
+		__raw_writel(lp_cr, ioaddr + SRTC_LPCR);
+		spin_unlock_irqrestore(&rtc_lock, lock_flags);
+		return 0;
+
+	case RTC_AIE_ON:
+		spin_lock_irqsave(&rtc_lock, lock_flags);
+		if (!pdata->irq_enable) {
+			enable_irq(pdata->irq);
+			pdata->irq_enable = true;
+		}
+		lp_cr = __raw_readl(ioaddr + SRTC_LPCR);
+		lp_cr |= SRTC_LPCR_ALP | SRTC_LPCR_WAE;
+		__raw_writel(lp_cr, ioaddr + SRTC_LPCR);
+		spin_unlock_irqrestore(&rtc_lock, lock_flags);
+		return 0;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+/*!
+ * This function reads the current RTC time into tm in Gregorian date.
+ *
+ * @param  tm           contains the RTC time value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+
+	rtc_time_to_tm(__raw_readl(ioaddr + SRTC_LPSCMR), tm);
+	return 0;
+}
+
+/*!
+ * This function sets the internal RTC time based on tm in Gregorian date.
+ *
+ * @param  tm           the time value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	unsigned long time;
+	int ret;
+	ret = rtc_tm_to_time(tm, &time);
+	if (ret != 0)
+		return ret;
+
+	__raw_writel(time, ioaddr + SRTC_LPSCMR);
+	rtc_write_sync_lp(ioaddr);
+
+	return 0;
+}
+
+/*!
+ * This function reads the current alarm value into the passed in \b alrm
+ * argument. It updates the \b alrm's pending field value based on the whether
+ * an alarm interrupt occurs or not.
+ *
+ * @param  alrm         contains the RTC alarm value upon return
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+
+	rtc_time_to_tm(__raw_readl(ioaddr + SRTC_LPSAR), &alrm->time);
+	alrm->pending =
+	    ((__raw_readl(ioaddr + SRTC_LPSR) & SRTC_LPSR_ALP) != 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*!
+ * This function sets the RTC alarm based on passed in alrm.
+ *
+ * @param  alrm         the alarm value to be set in the RTC
+ *
+ * @return  0 if successful; non-zero otherwise.
+ */
+static int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	unsigned long lock_flags = 0;
+	u32 lp_cr;
+	int ret;
+
+	if (rtc_valid_tm(&alrm->time)) {
+		if (alrm->time.tm_sec > 59 ||
+		    alrm->time.tm_hour > 23 || alrm->time.tm_min > 59) {
+			return -EINVAL;
+		}
+	}
+
+	spin_lock_irqsave(&rtc_lock, lock_flags);
+	lp_cr = __raw_readl(ioaddr + SRTC_LPCR);
+
+	ret = rtc_update_alarm(dev, &alrm->time);
+	if (ret)
+		goto out;
+
+	if (alrm->enabled)
+		lp_cr |= (SRTC_LPCR_ALP | SRTC_LPCR_WAE);
+	else
+		lp_cr &= ~(SRTC_LPCR_ALP | SRTC_LPCR_WAE);
+
+	if (lp_cr & SRTC_LPCR_ALL_INT_EN) {
+		if (!pdata->irq_enable) {
+			enable_irq(pdata->irq);
+			pdata->irq_enable = true;
+		}
+	} else {
+		if (pdata->irq_enable) {
+			disable_irq(pdata->irq);
+			pdata->irq_enable = false;
+		}
+	}
+
+	__raw_writel(lp_cr, ioaddr + SRTC_LPCR);
+
+out:
+	spin_unlock_irqrestore(&rtc_lock, lock_flags);
+	rtc_write_sync_lp(ioaddr);
+	return ret;
+}
+
+/*!
+ * This function is used to provide the content for the /proc/driver/rtc
+ * file.
+ *
+ * @param  seq  buffer to hold the information that the driver wants to write
+ *
+ * @return  The number of bytes written into the rtc file.
+ */
+static int mxc_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	struct rtc_drv_data *pdata = dev_get_drvdata(dev);
+	void __iomem *ioaddr = pdata->ioaddr;
+
+	seq_printf(seq, "alarm_IRQ\t: %s\n",
+		   (((__raw_readl(ioaddr + SRTC_LPCR)) & SRTC_LPCR_ALP) !=
+		    0) ? "yes" : "no");
+
+	return 0;
+}
+
+/*!
+ * The RTC driver structure
+ */
+static struct rtc_class_ops mxc_rtc_ops = {
+	.open = mxc_rtc_open,
+	.release = mxc_rtc_release,
+	.ioctl = mxc_rtc_ioctl,
+	.read_time = mxc_rtc_read_time,
+	.set_time = mxc_rtc_set_time,
+	.read_alarm = mxc_rtc_read_alarm,
+	.set_alarm = mxc_rtc_set_alarm,
+	.proc = mxc_rtc_proc,
+};
+
+/*! MXC RTC Power management control */
+
+static struct timespec mxc_rtc_delta;
+
+static int mxc_rtc_probe(struct platform_device *pdev)
+{
+	struct clk *clk;
+	struct timespec tv;
+	struct resource *res;
+	struct rtc_device *rtc;
+	struct rtc_drv_data *pdata = NULL;
+	struct mxc_srtc_platform_data *plat_data = NULL;
+	void __iomem *ioaddr;
+	void __iomem *srtc_secmode_addr;
+	int ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->clk = clk_get(&pdev->dev, "rtc_clk");
+	clk_enable(pdata->clk);
+	pdata->baseaddr = res->start;
+	pdata->ioaddr = ioremap(pdata->baseaddr, 0x40);
+	ioaddr = pdata->ioaddr;
+
+	/* Configure and enable the RTC */
+	pdata->irq = platform_get_irq(pdev, 0);
+	if (pdata->irq >= 0) {
+		if (request_irq(pdata->irq, mxc_rtc_interrupt, IRQF_SHARED,
+				pdev->name, pdev) < 0) {
+			dev_warn(&pdev->dev, "interrupt not available.\n");
+			pdata->irq = -1;
+		} else {
+			disable_irq(pdata->irq);
+			pdata->irq_enable = false;
+		}
+	}
+
+	clk = clk_get(NULL, "rtc_clk");
+	if (clk_get_rate(clk) != 32768) {
+		printk(KERN_ALERT "rtc clock is not valid");
+		ret = -EINVAL;
+		clk_put(clk);
+		goto err_out;
+	}
+	clk_put(clk);
+
+	/* initialize glitch detect */
+	__raw_writel(SRTC_LPPDR_INIT, ioaddr + SRTC_LPPDR);
+	rtc_write_sync_lp_no_wait(ioaddr);
+
+	/* clear lp interrupt status */
+	__raw_writel(0xFFFFFFFF, ioaddr + SRTC_LPSR);
+	rtc_write_sync_lp_no_wait(ioaddr);
+
+	plat_data = (struct mxc_srtc_platform_data *)pdev->dev.platform_data;
+	clk = clk_get(NULL, "iim_clk");
+	clk_enable(clk);
+	srtc_secmode_addr = ioremap(plat_data->srtc_sec_mode_addr, 1);
+
+	/* Check SRTC security mode */
+	if (((__raw_readl(srtc_secmode_addr) & SRTC_SECMODE_MASK) ==
+	    SRTC_SECMODE_LOW) && (cpu_is_mx51_rev(CHIP_REV_1_0) == 1)) {
+		/* Workaround for MX51 TO1 due to inaccurate CKIL clock */
+		__raw_writel(SRTC_LPCR_EN_LP, ioaddr + SRTC_LPCR);
+		rtc_write_sync_lp_no_wait(ioaddr);
+	} else {
+		/* move out of init state */
+		__raw_writel((SRTC_LPCR_IE | SRTC_LPCR_NSA),
+			     ioaddr + SRTC_LPCR);
+
+		rtc_write_sync_lp_no_wait(ioaddr);
+
+		while ((__raw_readl(ioaddr + SRTC_LPSR) & SRTC_LPSR_IES) == 0)
+			;
+
+		/* move out of non-valid state */
+		__raw_writel((SRTC_LPCR_IE | SRTC_LPCR_NVE | SRTC_LPCR_NSA |
+			      SRTC_LPCR_EN_LP), ioaddr + SRTC_LPCR);
+
+		rtc_write_sync_lp_no_wait(ioaddr);
+
+		while ((__raw_readl(ioaddr + SRTC_LPSR) & SRTC_LPSR_NVES) == 0)
+			;
+
+		__raw_writel(0xFFFFFFFF, ioaddr + SRTC_LPSR);
+		rtc_write_sync_lp_no_wait(ioaddr);
+	}
+	clk_disable(clk);
+	clk_put(clk);
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+				  &mxc_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		goto err_out;
+	}
+
+	pdata->rtc = rtc;
+	platform_set_drvdata(pdev, pdata);
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = __raw_readl(ioaddr + SRTC_LPSCMR);
+
+	/* By default, devices should wakeup if they can */
+	/* So srtc is set as "should wakeup" as it can */
+	device_init_wakeup(&pdev->dev, 1);
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	clk = clk_get(NULL, "epit_clk");
+	if (clk == NULL) {
+		printk(KERN_WARNING "request epit input clk failed\n");
+		goto skip_hwtimer;
+	}
+	input_freq = clk_get_rate(clk);
+
+	__raw_writel(EPIT1_CR_CLKSRC_PF | EPIT1_CR_IOVW | EPIT1_CR_RLD |
+		     EPIT1_CR_OCIEN | EPIT1_CR_ENMOD | (0xFFF << 4) | 1 << 21 |
+		     1 << 19, EPIT1_CR);
+	input_freq /= 4096;
+	__raw_writel(input_freq >> 4, EPIT1_LR);
+	__raw_writel(0, EPIT1_CMPR);
+
+	clk_enable(clk);
+
+	if (request_irq(MXC_INT_EPIT1, mxc_epit_interrupt, 0,
+				"EPIT1", NULL) < 0) {
+		printk(KERN_WARNING "request rtc periodic irq failed\n");
+		clk_disable(clk);
+		clk_put(clk);
+		goto skip_hwtimer;
+	}
+
+	clk_put(clk);
+	rtc_hwtimer_data.name = "mxc_rtc_v2";
+	rtc_hwtimer_data.desc = "Freescale MXC Secure Real Time Clock";
+	rtc_hwtimer_data.def_freq = 16;
+	rtc_hwtimer_data.min_freq = 1;
+	rtc_hwtimer_data.max_freq = input_freq;
+
+	rtc_hwtimer.data = &rtc_hwtimer_data;
+	rtc_hwtimer.set_freq = rtc_set_freq;
+	rtc_hwtimer.get_freq = rtc_get_freq;
+	rtc_hwtimer.start = rtc_start;
+	rtc_hwtimer.stop = rtc_stop;
+	rtc_hwtimer.lock = &rtc_lock;
+	rtc_hwtimer.hook = NULL;
+
+	register_hwtimer(&rtc_hwtimer);
+
+skip_hwtimer:
+#endif	/* CONFIG_HWTIMER_HOOKS */
+
+	return ret;
+
+err_out:
+	clk_disable(pdata->clk);
+	iounmap(ioaddr);
+	if (pdata->irq >= 0)
+		free_irq(pdata->irq, pdev);
+	kfree(pdata);
+	return ret;
+}
+
+static int __exit mxc_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_drv_data *pdata = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(pdata->rtc);
+	if (pdata->irq >= 0)
+		free_irq(pdata->irq, pdev);
+
+	clk_disable(pdata->clk);
+	clk_put(pdata->clk);
+	kfree(pdata);
+	mxc_rtc_release(NULL);
+	return 0;
+}
+
+/*!
+ * This function is called to save the system time delta relative to
+ * the MXC RTC when enterring a low power state. This time delta is
+ * then used on resume to adjust the system time to account for time
+ * loss while suspended.
+ *
+ * @param   pdev  not used
+ * @param   state Power state to enter.
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct rtc_drv_data *pdata = platform_get_drvdata(pdev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	struct timespec tv;
+
+	if (device_may_wakeup(&pdev->dev)) {
+		enable_irq_wake(pdata->irq);
+	} else {
+		/* calculate time delta for suspend.  RTC precision is
+		   1 second; adjust delta for avg 1/2 sec err */
+		tv.tv_nsec = NSEC_PER_SEC >> 1;
+		tv.tv_sec = __raw_readl(ioaddr + SRTC_LPSCMR);
+		set_normalized_timespec(&mxc_rtc_delta,
+					xtime.tv_sec - tv.tv_sec,
+					xtime.tv_nsec - tv.tv_nsec);
+
+		if (pdata->irq_enable)
+			disable_irq(pdata->irq);
+	}
+
+	clk_disable(pdata->clk);
+
+	return 0;
+}
+
+/*!
+ * This function is called to correct the system time based on the
+ * current MXC RTC time relative to the time delta saved during
+ * suspend.
+ *
+ * @param   pdev  not used
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_rtc_resume(struct platform_device *pdev)
+{
+	struct rtc_drv_data *pdata = platform_get_drvdata(pdev);
+	void __iomem *ioaddr = pdata->ioaddr;
+	struct timespec tv;
+	struct timespec ts;
+
+	clk_enable(pdata->clk);
+
+	if (device_may_wakeup(&pdev->dev)) {
+		disable_irq_wake(pdata->irq);
+	} else {
+		if (pdata->irq_enable)
+			enable_irq(pdata->irq);
+
+		tv.tv_nsec = 0;
+		tv.tv_sec = __raw_readl(ioaddr + SRTC_LPSCMR);
+
+		/*
+		 * restore wall clock using delta against this RTC;
+		 * adjust again for avg 1/2 second RTC sampling error
+		 */
+		set_normalized_timespec(&ts,
+					tv.tv_sec + mxc_rtc_delta.tv_sec,
+					(NSEC_PER_SEC >> 1) +
+					mxc_rtc_delta.tv_nsec);
+		do_settimeofday(&ts);
+	}
+
+	return 0;
+}
+
+/*!
+ * Contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_rtc_driver = {
+	.driver = {
+		   .name = "mxc_rtc",
+		   },
+	.probe = mxc_rtc_probe,
+	.remove = __exit_p(mxc_rtc_remove),
+	.suspend = mxc_rtc_suspend,
+	.resume = mxc_rtc_resume,
+};
+
+/*!
+ * This function creates the /proc/driver/rtc file and registers the device RTC
+ * in the /dev/misc directory. It also reads the RTC value from external source
+ * and setup the internal RTC properly.
+ *
+ * @return  -1 if RTC is failed to initialize; 0 is successful.
+ */
+static int __init mxc_rtc_init(void)
+{
+	return platform_driver_register(&mxc_rtc_driver);
+}
+
+/*!
+ * This function removes the /proc/driver/rtc file and un-registers the
+ * device RTC from the /dev/misc directory.
+ */
+static void __exit mxc_rtc_exit(void)
+{
+	platform_driver_unregister(&mxc_rtc_driver);
+
+}
+
+module_init(mxc_rtc_init);
+module_exit(mxc_rtc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Realtime Clock Driver (RTC)");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

