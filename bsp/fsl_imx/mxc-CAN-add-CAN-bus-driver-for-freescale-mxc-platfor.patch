From 0cda0cb26bf9f6ef91fa56c0da06b634d50deb8e Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Tue, 17 May 2011 15:04:52 +0800
Subject: [PATCH 11/11] mxc/CAN: add CAN bus driver for freescale mxc platform

Add CAN bus driver for freescale mxc platform.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=
IMX25PDK&fpsp=1&tab=Design_Tools_Tab]

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/can/Kconfig           |    8 +
 drivers/net/can/Makefile          |    1 +
 drivers/net/can/flexcan/Makefile  |    3 +
 drivers/net/can/flexcan/dev.c     |  743 +++++++++++++++++++++++++++++++++++++
 drivers/net/can/flexcan/drv.c     |  628 +++++++++++++++++++++++++++++++
 drivers/net/can/flexcan/flexcan.h |  222 +++++++++++
 drivers/net/can/flexcan/mbm.c     |  361 ++++++++++++++++++
 7 files changed, 1966 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/can/flexcan/Makefile
 create mode 100644 drivers/net/can/flexcan/dev.c
 create mode 100644 drivers/net/can/flexcan/drv.c
 create mode 100644 drivers/net/can/flexcan/flexcan.h
 create mode 100644 drivers/net/can/flexcan/mbm.c

diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index 05b7517..196fcac 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -79,4 +79,12 @@ config CAN_DEBUG_DEVICES
 	  a problem with CAN support and want to see more of what is going
 	  on.
 
+config CAN_FLEXCAN
+        tristate "Freescale FlexCAN"
+        depends on CAN && (ARCH_MX25 || ARCH_MX35 || ARCH_MX28 || ARCH_MX53)
+        default y
+        ---help---
+          This select the support of Freescale CAN(FlexCAN).
+          This driver can also be built as a module.
+          If unsure, say N.
 endmenu
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 7a702f2..400c126 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -3,6 +3,7 @@
 #
 
 obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_FLEXCAN)       += flexcan/
 
 obj-$(CONFIG_CAN_DEV)		+= can-dev.o
 can-dev-y			:= dev.o
diff --git a/drivers/net/can/flexcan/Makefile b/drivers/net/can/flexcan/Makefile
new file mode 100644
index 0000000..b2dbb4f
--- /dev/null
+++ b/drivers/net/can/flexcan/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_CAN_FLEXCAN)	+= flexcan.o
+
+flexcan-y := dev.o drv.o mbm.o
diff --git a/drivers/net/can/flexcan/dev.c b/drivers/net/can/flexcan/dev.c
new file mode 100644
index 0000000..0b594dd
--- /dev/null
+++ b/drivers/net/can/flexcan/dev.c
@@ -0,0 +1,743 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dev.c
+ *
+ * @brief Driver for Freescale CAN Controller FlexCAN.
+ *
+ * @ingroup can
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/fsl_devices.h>
+
+#include <linux/module.h>
+#ifdef CONFIG_ARCH_MX28
+#include <mach/device.h>
+#endif
+#include "flexcan.h"
+
+#define DEFAULT_BITRATE	    500000
+#define TIME_SEGMENT_MIN    8
+#define TIME_SEGMENT_MAX    25
+#define TIME_SEGMENT_MID    ((TIME_SEGMENT_MIN + TIME_SEGMENT_MAX)/2)
+
+struct time_segment {
+	char propseg;
+	char pseg1;
+	char pseg2;
+};
+
+struct time_segment time_segments[] = {
+    { /* total 8 timequanta */
+	1, 2, 1
+    },
+    { /* total 9 timequanta */
+	1, 2, 2
+    },
+    { /* total 10 timequanta */
+	2, 2, 2
+    },
+    { /* total 11 timequanta */
+	2, 2, 3
+    },
+    { /* total 12 timequanta */
+	2, 3, 3
+    },
+    { /* total 13 timequanta */
+	3, 3, 3
+    },
+    { /* total 14 timequanta */
+	3, 3, 4
+    },
+    { /* total 15 timequanta */
+	3, 4, 4
+    },
+    { /* total 16 timequanta */
+	4, 4, 4
+    },
+    { /* total 17 timequanta */
+	4, 4, 5
+    },
+    { /* total 18 timequanta */
+	4, 5, 5
+    },
+    { /* total 19 timequanta */
+	5, 5, 5
+    },
+    { /* total 20 timequanta */
+	5, 5, 6
+    },
+    { /* total 21 timequanta */
+	5, 6, 6
+    },
+    { /* total 22 timequanta */
+	6, 6, 6
+    },
+    { /* total 23 timequanta */
+	6, 6, 7
+    },
+    { /* total 24 timequanta */
+	6, 7, 7
+    },
+    { /* total 25 timequanta */
+	7, 7, 7
+    },
+};
+
+enum {
+	FLEXCAN_ATTR_STATE = 0,
+	FLEXCAN_ATTR_BITRATE,
+	FLEXCAN_ATTR_BR_PRESDIV,
+	FLEXCAN_ATTR_BR_RJW,
+	FLEXCAN_ATTR_BR_PROPSEG,
+	FLEXCAN_ATTR_BR_PSEG1,
+	FLEXCAN_ATTR_BR_PSEG2,
+	FLEXCAN_ATTR_BR_CLKSRC,
+	FLEXCAN_ATTR_MAXMB,
+	FLEXCAN_ATTR_XMIT_MAXMB,
+	FLEXCAN_ATTR_FIFO,
+	FLEXCAN_ATTR_WAKEUP,
+	FLEXCAN_ATTR_SRX_DIS,
+	FLEXCAN_ATTR_WAK_SRC,
+	FLEXCAN_ATTR_BCC,
+	FLEXCAN_ATTR_LOCAL_PRIORITY,
+	FLEXCAN_ATTR_ABORT,
+	FLEXCAN_ATTR_LOOPBACK,
+	FLEXCAN_ATTR_SMP,
+	FLEXCAN_ATTR_BOFF_REC,
+	FLEXCAN_ATTR_TSYN,
+	FLEXCAN_ATTR_LISTEN,
+	FLEXCAN_ATTR_EXTEND_MSG,
+	FLEXCAN_ATTR_STANDARD_MSG,
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	FLEXCAN_ATTR_DUMP_REG,
+	FLEXCAN_ATTR_DUMP_XMIT_MB,
+	FLEXCAN_ATTR_DUMP_RX_MB,
+#endif
+	FLEXCAN_ATTR_MAX
+};
+
+static ssize_t flexcan_show_attr(struct device *dev,
+				 struct device_attribute *attr, char *buf);
+static ssize_t flexcan_set_attr(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count);
+
+static struct device_attribute flexcan_dev_attr[FLEXCAN_ATTR_MAX] = {
+	[FLEXCAN_ATTR_STATE] = __ATTR(state, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_BITRATE] =
+	    __ATTR(bitrate, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PRESDIV] =
+	    __ATTR(br_presdiv, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_RJW] =
+	    __ATTR(br_rjw, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PROPSEG] =
+	    __ATTR(br_propseg, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PSEG1] =
+	    __ATTR(br_pseg1, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_PSEG2] =
+	    __ATTR(br_pseg2, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BR_CLKSRC] =
+	    __ATTR(br_clksrc, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_MAXMB] =
+	    __ATTR(maxmb, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_XMIT_MAXMB] =
+	    __ATTR(xmit_maxmb, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_FIFO] =
+	    __ATTR(fifo, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_WAKEUP] =
+	    __ATTR(wakeup, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_SRX_DIS] =
+	    __ATTR(srx_dis, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_WAK_SRC] =
+	    __ATTR(wak_src, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BCC] =
+	    __ATTR(bcc, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LOCAL_PRIORITY] =
+	    __ATTR(local_priority, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_ABORT] =
+	    __ATTR(abort, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LOOPBACK] =
+	    __ATTR(loopback, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_SMP] =
+	    __ATTR(smp, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_BOFF_REC] =
+	    __ATTR(boff_rec, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_TSYN] =
+	    __ATTR(tsyn, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_LISTEN] =
+	    __ATTR(listen, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_EXTEND_MSG] =
+	    __ATTR(ext_msg, 0644, flexcan_show_attr, flexcan_set_attr),
+	[FLEXCAN_ATTR_STANDARD_MSG] =
+	    __ATTR(std_msg, 0644, flexcan_show_attr, flexcan_set_attr),
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	[FLEXCAN_ATTR_DUMP_REG] =
+	    __ATTR(dump_reg, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_DUMP_XMIT_MB] =
+	    __ATTR(dump_xmit_mb, 0444, flexcan_show_attr, NULL),
+	[FLEXCAN_ATTR_DUMP_RX_MB] =
+	    __ATTR(dump_rx_mb, 0444, flexcan_show_attr, NULL),
+#endif
+};
+
+static void flexcan_set_bitrate(struct flexcan_device *flexcan, int bitrate)
+{
+	/* TODO:: implement in future
+	 * based on the bitrate to get the timing of
+	 * presdiv, pseg1, pseg2, propseg
+	 */
+	int i, rate, div;
+	bool found = false;
+	struct time_segment *segment;
+	rate = clk_get_rate(flexcan->clk);
+
+	if (!bitrate)
+		bitrate = DEFAULT_BITRATE;
+
+	if (rate % bitrate == 0) {
+		div = rate / bitrate;
+		for (i = TIME_SEGMENT_MID; i <= TIME_SEGMENT_MAX; i++) {
+			if (div % i == 0) {
+				found = true;
+				break;
+			}
+		}
+		if (!found) {
+			for (i = TIME_SEGMENT_MID - 1;
+					    i >= TIME_SEGMENT_MIN; i--) {
+				if (div % i == 0) {
+					found = true;
+					break;
+				}
+			}
+
+		}
+	}
+
+	if (found) {
+		segment = &time_segments[i - TIME_SEGMENT_MIN];
+		flexcan->br_presdiv = div/i - 1;
+		flexcan->br_propseg = segment->propseg;
+		flexcan->br_pseg1 = segment->pseg1;
+		flexcan->br_pseg2 = segment->pseg2;
+		flexcan->bitrate = bitrate;
+	} else {
+		pr_info("The bitrate %d can't supported with clock \
+				    rate of %d \n", bitrate, rate);
+	}
+}
+
+static void flexcan_update_bitrate(struct flexcan_device *flexcan)
+{
+	int rate, div;
+	struct flexcan_platform_data *plat_data;
+	plat_data = flexcan->dev->dev.platform_data;
+
+	if (plat_data->root_clk_id)
+		rate = clk_get_rate(flexcan->clk);
+	else {
+		if (flexcan->br_clksrc)
+			rate = clk_get_rate(flexcan->clk);
+		else {
+			struct clk *clk;
+			clk = clk_get(NULL, "ckih");
+			if (!clk)
+				return;
+			rate = clk_get_rate(clk);
+			clk_put(clk);
+		}
+	}
+	if (!rate)
+		return;
+
+	div = (flexcan->br_presdiv + 1);
+	div *=
+	    (flexcan->br_propseg + flexcan->br_pseg1 + flexcan->br_pseg2 + 4);
+	flexcan->bitrate = (rate + div - 1) / div;
+}
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static int flexcan_dump_reg(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0;
+	unsigned int reg;
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	ret += sprintf(buf + ret, "MCR::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_CTRL);
+	ret += sprintf(buf + ret, "CTRL::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_RXGMASK);
+	ret += sprintf(buf + ret, "RXGMASK::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_RX14MASK);
+	ret += sprintf(buf + ret, "RX14MASK::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_RX15MASK);
+	ret += sprintf(buf + ret, "RX15MASK::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_ECR);
+	ret += sprintf(buf + ret, "ECR::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_ESR);
+	ret += sprintf(buf + ret, "ESR::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_IMASK2);
+	ret += sprintf(buf + ret, "IMASK2::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_IMASK1);
+	ret += sprintf(buf + ret, "IMASK1::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_IFLAG2);
+	ret += sprintf(buf + ret, "IFLAG2::0x%x\n", reg);
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_IFLAG1);
+	ret += sprintf(buf + ret, "IFLAG1::0x%x\n", reg);
+	return ret;
+}
+
+static int flexcan_dump_xmit_mb(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0, i;
+	i = flexcan->xmit_maxmb + 1;
+	for (; i <= flexcan->maxmb; i++)
+		ret +=
+		    sprintf(buf + ret,
+			    "mb[%d]::CS:0x%x ID:0x%x DATA[1~2]:0x%02x,0x%02x\n",
+			    i, flexcan->hwmb[i].mb_cs,
+			    flexcan->hwmb[i].mb_id, flexcan->hwmb[i].mb_data[1],
+			    flexcan->hwmb[i].mb_data[2]);
+	return ret;
+}
+
+static int flexcan_dump_rx_mb(struct flexcan_device *flexcan, char *buf)
+{
+	int ret = 0, i;
+	for (i = 0; i <= flexcan->xmit_maxmb; i++)
+		ret +=
+		    sprintf(buf + ret,
+			    "mb[%d]::CS:0x%x ID:0x%x DATA[1~2]:0x%02x,0x%02x\n",
+			    i, flexcan->hwmb[i].mb_cs,
+			    flexcan->hwmb[i].mb_id, flexcan->hwmb[i].mb_data[1],
+			    flexcan->hwmb[i].mb_data[2]);
+	return ret;
+}
+#endif
+
+static ssize_t flexcan_show_state(struct net_device *net, char *buf)
+{
+	int ret, esr;
+	struct flexcan_device *flexcan = netdev_priv(net);
+	ret = sprintf(buf, "%s::", netif_running(net) ? "Start" : "Stop");
+	if (netif_carrier_ok(net)) {
+		esr = __raw_readl(flexcan->io_base + CAN_HW_REG_ESR);
+		switch ((esr & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) {
+		case 0:
+			ret += sprintf(buf + ret, "normal\n");
+			break;
+		case 1:
+			ret += sprintf(buf + ret, "error passive\n");
+			break;
+		default:
+			ret += sprintf(buf + ret, "bus off\n");
+		}
+	} else
+		ret += sprintf(buf + ret, "bus off\n");
+	return ret;
+}
+
+static ssize_t flexcan_show_attr(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int attr_id;
+	struct net_device *net;
+	struct flexcan_device *flexcan;
+
+	net = dev_get_drvdata(dev);
+	BUG_ON(!net);
+	flexcan = netdev_priv(net);
+	BUG_ON(!flexcan);
+
+	attr_id = attr - flexcan_dev_attr;
+	switch (attr_id) {
+	case FLEXCAN_ATTR_STATE:
+		return flexcan_show_state(net, buf);
+	case FLEXCAN_ATTR_BITRATE:
+		return sprintf(buf, "%d\n", flexcan->bitrate);
+	case FLEXCAN_ATTR_BR_PRESDIV:
+		return sprintf(buf, "%d\n", flexcan->br_presdiv + 1);
+	case FLEXCAN_ATTR_BR_RJW:
+		return sprintf(buf, "%d\n", flexcan->br_rjw);
+	case FLEXCAN_ATTR_BR_PROPSEG:
+		return sprintf(buf, "%d\n", flexcan->br_propseg + 1);
+	case FLEXCAN_ATTR_BR_PSEG1:
+		return sprintf(buf, "%d\n", flexcan->br_pseg1 + 1);
+	case FLEXCAN_ATTR_BR_PSEG2:
+		return sprintf(buf, "%d\n", flexcan->br_pseg2 + 1);
+	case FLEXCAN_ATTR_BR_CLKSRC:
+		return sprintf(buf, "%s\n", flexcan->br_clksrc ? "bus" : "osc");
+	case FLEXCAN_ATTR_MAXMB:
+		return sprintf(buf, "%d\n", flexcan->maxmb + 1);
+	case FLEXCAN_ATTR_XMIT_MAXMB:
+		return sprintf(buf, "%d\n", flexcan->xmit_maxmb + 1);
+	case FLEXCAN_ATTR_FIFO:
+		return sprintf(buf, "%d\n", flexcan->fifo);
+	case FLEXCAN_ATTR_WAKEUP:
+		return sprintf(buf, "%d\n", flexcan->wakeup);
+	case FLEXCAN_ATTR_SRX_DIS:
+		return sprintf(buf, "%d\n", flexcan->srx_dis);
+	case FLEXCAN_ATTR_WAK_SRC:
+		return sprintf(buf, "%d\n", flexcan->wak_src);
+	case FLEXCAN_ATTR_BCC:
+		return sprintf(buf, "%d\n", flexcan->bcc);
+	case FLEXCAN_ATTR_LOCAL_PRIORITY:
+		return sprintf(buf, "%d\n", flexcan->lprio);
+	case FLEXCAN_ATTR_ABORT:
+		return sprintf(buf, "%d\n", flexcan->abort);
+	case FLEXCAN_ATTR_LOOPBACK:
+		return sprintf(buf, "%d\n", flexcan->loopback);
+	case FLEXCAN_ATTR_SMP:
+		return sprintf(buf, "%d\n", flexcan->smp);
+	case FLEXCAN_ATTR_BOFF_REC:
+		return sprintf(buf, "%d\n", flexcan->boff_rec);
+	case FLEXCAN_ATTR_TSYN:
+		return sprintf(buf, "%d\n", flexcan->tsyn);
+	case FLEXCAN_ATTR_LISTEN:
+		return sprintf(buf, "%d\n", flexcan->listen);
+	case FLEXCAN_ATTR_EXTEND_MSG:
+		return sprintf(buf, "%d\n", flexcan->ext_msg);
+	case FLEXCAN_ATTR_STANDARD_MSG:
+		return sprintf(buf, "%d\n", flexcan->std_msg);
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+	case FLEXCAN_ATTR_DUMP_REG:
+		return flexcan_dump_reg(flexcan, buf);
+	case FLEXCAN_ATTR_DUMP_XMIT_MB:
+		return flexcan_dump_xmit_mb(flexcan, buf);
+	case FLEXCAN_ATTR_DUMP_RX_MB:
+		return flexcan_dump_rx_mb(flexcan, buf);
+#endif
+	default:
+		return sprintf(buf, "%s:%p->%p\n", __func__, flexcan_dev_attr,
+			       attr);
+	}
+}
+
+static ssize_t flexcan_set_attr(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_id, tmp;
+	struct net_device *net;
+	struct flexcan_device *flexcan;
+
+	net = dev_get_drvdata(dev);
+	BUG_ON(!net);
+	flexcan = netdev_priv(net);
+	BUG_ON(!flexcan);
+
+	attr_id = attr - flexcan_dev_attr;
+
+	if (mutex_lock_interruptible(&flexcan->mutex))
+		return count;
+
+	if (netif_running(net))
+		goto set_finish;
+
+	if (attr_id == FLEXCAN_ATTR_BR_CLKSRC) {
+		if (!strncasecmp(buf, "bus", 3))
+			flexcan->br_clksrc = 1;
+		else if (!strncasecmp(buf, "osc", 3))
+			flexcan->br_clksrc = 0;
+		goto set_finish;
+	}
+
+	tmp = simple_strtoul(buf, NULL, 0);
+	switch (attr_id) {
+	case FLEXCAN_ATTR_BITRATE:
+		flexcan_set_bitrate(flexcan, tmp);
+		break;
+	case FLEXCAN_ATTR_BR_PRESDIV:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PRESDIV)) {
+			flexcan->br_presdiv = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_RJW:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_RJW))
+			flexcan->br_rjw = tmp - 1;
+		break;
+	case FLEXCAN_ATTR_BR_PROPSEG:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PROPSEG)) {
+			flexcan->br_propseg = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_PSEG1:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PSEG1)) {
+			flexcan->br_pseg1 = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_BR_PSEG2:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_PSEG2)) {
+			flexcan->br_pseg2 = tmp - 1;
+			flexcan_update_bitrate(flexcan);
+		}
+		break;
+	case FLEXCAN_ATTR_MAXMB:
+		if ((tmp > 0) && (tmp <= FLEXCAN_MAX_MB)) {
+			if (flexcan->maxmb != (tmp - 1)) {
+				flexcan->maxmb = tmp - 1;
+				if (flexcan->xmit_maxmb < flexcan->maxmb)
+					flexcan->xmit_maxmb = flexcan->maxmb;
+			}
+		}
+		break;
+	case FLEXCAN_ATTR_XMIT_MAXMB:
+		if ((tmp > 0) && (tmp <= (flexcan->maxmb + 1))) {
+			if (flexcan->xmit_maxmb != (tmp - 1))
+				flexcan->xmit_maxmb = tmp - 1;
+		}
+		break;
+	case FLEXCAN_ATTR_FIFO:
+		flexcan->fifo = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_WAKEUP:
+		flexcan->wakeup = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_SRX_DIS:
+		flexcan->srx_dis = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_WAK_SRC:
+		flexcan->wak_src = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_BCC:
+		flexcan->bcc = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_LOCAL_PRIORITY:
+		flexcan->lprio = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_ABORT:
+		flexcan->abort = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_LOOPBACK:
+		flexcan->loopback = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_SMP:
+		flexcan->smp = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_BOFF_REC:
+		flexcan->boff_rec = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_TSYN:
+		flexcan->tsyn = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_LISTEN:
+		flexcan->listen = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_EXTEND_MSG:
+		flexcan->ext_msg = tmp ? 1 : 0;
+		break;
+	case FLEXCAN_ATTR_STANDARD_MSG:
+		flexcan->std_msg = tmp ? 1 : 0;
+		break;
+	}
+set_finish:
+	mutex_unlock(&flexcan->mutex);
+	return count;
+}
+
+static void flexcan_device_default(struct flexcan_device *dev)
+{
+	struct platform_device *pdev = dev->dev;
+	struct flexcan_platform_data *plat_data = (pdev->dev).platform_data;
+	dev->br_clksrc = plat_data->br_clksrc;
+	dev->br_rjw = plat_data->br_rjw;
+	dev->br_presdiv = plat_data->br_presdiv;
+	dev->br_propseg = plat_data->br_propseg;
+	dev->br_pseg1 = plat_data->br_pseg1;
+	dev->br_pseg2 = plat_data->br_pseg2;
+
+	dev->bcc = plat_data->bcc;
+	dev->srx_dis = plat_data->srx_dis;
+	dev->smp = plat_data->smp;
+	dev->boff_rec = plat_data->boff_rec;
+
+	dev->maxmb = FLEXCAN_MAX_MB - 1;
+	dev->xmit_maxmb = (FLEXCAN_MAX_MB >> 1) - 1;
+	dev->xmit_mb = dev->maxmb - dev->xmit_maxmb;
+
+	dev->ext_msg = plat_data->ext_msg;
+	dev->std_msg = plat_data->std_msg;
+}
+
+static int flexcan_device_attach(struct flexcan_device *flexcan)
+{
+	int ret;
+	struct resource *res;
+	struct platform_device *pdev = flexcan->dev;
+	struct flexcan_platform_data *plat_data = (pdev->dev).platform_data;
+	struct clk *can_root_clk;
+
+	res = platform_get_resource(flexcan->dev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	flexcan->io_base = ioremap(res->start, res->end - res->start + 1);
+	if (!flexcan->io_base)
+		return -ENOMEM;
+
+	flexcan->irq = platform_get_irq(flexcan->dev, 0);
+	if (!flexcan->irq) {
+		ret = -ENODEV;
+		goto no_irq_err;
+	}
+
+	ret = -EINVAL;
+	if (plat_data) {
+		if (plat_data->core_reg) {
+			flexcan->core_reg = regulator_get(&pdev->dev,
+							  plat_data->core_reg);
+			if (!flexcan->core_reg)
+				goto plat_err;
+		}
+
+		if (plat_data->io_reg) {
+			flexcan->io_reg = regulator_get(&pdev->dev,
+							plat_data->io_reg);
+			if (!flexcan->io_reg)
+				goto plat_err;
+		}
+	}
+	flexcan->clk = clk_get(&(flexcan->dev)->dev, "can_clk");
+	if (plat_data->root_clk_id) {
+		can_root_clk = clk_get(NULL, plat_data->root_clk_id);
+		clk_set_parent(flexcan->clk, can_root_clk);
+	}
+	flexcan->hwmb = (struct can_hw_mb *)(flexcan->io_base + CAN_MB_BASE);
+	flexcan->rx_mask = (unsigned int *)(flexcan->io_base + CAN_RXMASK_BASE);
+
+	return 0;
+plat_err:
+	if (flexcan->core_reg) {
+		regulator_put(flexcan->core_reg);
+		flexcan->core_reg = NULL;
+	}
+no_irq_err:
+	if (flexcan->io_base)
+		iounmap(flexcan->io_base);
+	return ret;
+}
+
+static void flexcan_device_detach(struct flexcan_device *flexcan)
+{
+	if (flexcan->clk) {
+		clk_put(flexcan->clk);
+		flexcan->clk = NULL;
+	}
+
+	if (flexcan->io_reg) {
+		regulator_put(flexcan->io_reg);
+		flexcan->io_reg = NULL;
+	}
+
+	if (flexcan->core_reg) {
+		regulator_put(flexcan->core_reg);
+		flexcan->core_reg = NULL;
+	}
+
+	if (flexcan->io_base)
+		iounmap(flexcan->io_base);
+}
+
+/*!
+ * @brief The function allocates can device.
+ *
+ * @param pdev	the pointer of platform device.
+ * @param setup	the initial function pointer of network device.
+ *
+ * @return none
+ */
+struct net_device *flexcan_device_alloc(struct platform_device *pdev,
+					void (*setup) (struct net_device *dev))
+{
+	struct flexcan_device *flexcan;
+	struct net_device *net;
+	int i, num;
+
+	net = alloc_netdev(sizeof(*flexcan), "can%d", setup);
+	if (net == NULL) {
+		printk(KERN_ERR "Allocate netdevice for FlexCAN fail!\n");
+		return NULL;
+	}
+	flexcan = netdev_priv(net);
+	memset(flexcan, 0, sizeof(*flexcan));
+
+	mutex_init(&flexcan->mutex);
+	init_timer(&flexcan->timer);
+
+	flexcan->dev = pdev;
+	if (flexcan_device_attach(flexcan)) {
+		printk(KERN_ERR "Attach FlexCAN fail!\n");
+		free_netdev(net);
+		return NULL;
+	}
+	flexcan_device_default(flexcan);
+	flexcan_set_bitrate(flexcan, flexcan->bitrate);
+	flexcan_update_bitrate(flexcan);
+
+	num = ARRAY_SIZE(flexcan_dev_attr);
+
+	for (i = 0; i < num; i++) {
+		if (device_create_file(&pdev->dev, flexcan_dev_attr + i)) {
+			printk(KERN_ERR "Create attribute file fail!\n");
+			break;
+		}
+	}
+
+	if (i != num) {
+		for (; i >= 0; i--)
+			device_remove_file(&pdev->dev, flexcan_dev_attr + i);
+		free_netdev(net);
+		return NULL;
+	}
+	dev_set_drvdata(&pdev->dev, net);
+	return net;
+}
+
+/*!
+ * @brief The function frees can device.
+ *
+ * @param pdev	the pointer of platform device.
+ *
+ * @return none
+ */
+void flexcan_device_free(struct platform_device *pdev)
+{
+	struct net_device *net;
+	struct flexcan_device *flexcan;
+	int i, num;
+	net = (struct net_device *)dev_get_drvdata(&pdev->dev);
+
+	unregister_netdev(net);
+	flexcan = netdev_priv(net);
+	del_timer(&flexcan->timer);
+
+	num = ARRAY_SIZE(flexcan_dev_attr);
+
+	for (i = 0; i < num; i++)
+		device_remove_file(&pdev->dev, flexcan_dev_attr + i);
+
+	flexcan_device_detach(netdev_priv(net));
+	free_netdev(net);
+}
diff --git a/drivers/net/can/flexcan/drv.c b/drivers/net/can/flexcan/drv.c
new file mode 100644
index 0000000..97e9fda
--- /dev/null
+++ b/drivers/net/can/flexcan/drv.c
@@ -0,0 +1,628 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file drv.c
+ *
+ * @brief Driver for Freescale CAN Controller FlexCAN.
+ *
+ * @ingroup can
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/fsl_devices.h>
+#include <linux/random.h>
+#include "flexcan.h"
+
+static void flexcan_hw_start(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+	if ((flexcan->maxmb + 1) > 32) {
+		__raw_writel(0xFFFFFFFF, flexcan->io_base + CAN_HW_REG_IMASK1);
+		reg = (1 << (flexcan->maxmb - 31)) - 1;
+		__raw_writel(reg, flexcan->io_base + CAN_HW_REG_IMASK2);
+	} else {
+		reg = (1 << (flexcan->maxmb + 1)) - 1;
+		__raw_writel(reg, flexcan->io_base + CAN_HW_REG_IMASK1);
+		__raw_writel(0, flexcan->io_base + CAN_HW_REG_IMASK2);
+	}
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR) & (~__MCR_HALT);
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_MCR);
+}
+
+static void flexcan_hw_stop(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	__raw_writel(reg | __MCR_HALT, flexcan->io_base + CAN_HW_REG_MCR);
+}
+
+static int flexcan_hw_reset(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+	int timeout = 100000;
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	__raw_writel(reg | __MCR_MDIS, flexcan->io_base + CAN_HW_REG_MCR);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_CTRL);
+	if (flexcan->br_clksrc)
+		reg |= __CTRL_CLK_SRC;
+	else
+		reg &= ~__CTRL_CLK_SRC;
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_CTRL);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR) & (~__MCR_MDIS);
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_MCR);
+	reg |= __MCR_SOFT_RST;
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_MCR);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	while (reg & __MCR_SOFT_RST) {
+		if (--timeout <= 0) {
+			printk(KERN_ERR "Flexcan software Reset Timeouted\n");
+			return -1;
+		}
+		udelay(10);
+		reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	}
+	return 0;
+}
+
+static inline void flexcan_mcr_setup(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	reg &= ~(__MCR_MAX_MB_MASK | __MCR_WAK_MSK | __MCR_MAX_IDAM_MASK);
+
+	if (flexcan->fifo)
+		reg |= __MCR_FEN;
+	else
+		reg &= ~__MCR_FEN;
+
+	if (flexcan->wakeup)
+		reg |= __MCR_SLF_WAK | __MCR_WAK_MSK;
+	else
+		reg &= ~(__MCR_SLF_WAK | __MCR_WAK_MSK);
+
+	if (flexcan->wak_src)
+		reg |= __MCR_WAK_SRC;
+	else
+		reg &= ~__MCR_WAK_SRC;
+
+	if (flexcan->srx_dis)
+		reg |= __MCR_SRX_DIS;
+	else
+		reg &= ~__MCR_SRX_DIS;
+
+	if (flexcan->bcc)
+		reg |= __MCR_BCC;
+	else
+		reg &= ~__MCR_BCC;
+
+	if (flexcan->lprio)
+		reg |= __MCR_LPRIO_EN;
+	else
+		reg &= ~__MCR_LPRIO_EN;
+
+	if (flexcan->abort)
+		reg |= __MCR_AEN;
+	else
+		reg &= ~__MCR_AEN;
+
+	reg |= (flexcan->maxmb << __MCR_MAX_MB_OFFSET);
+	reg |= __MCR_DOZE | __MCR_MAX_IDAM_C;
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_MCR);
+}
+
+static inline void flexcan_ctrl_setup(struct flexcan_device *flexcan)
+{
+	unsigned int reg;
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_CTRL);
+	reg &= ~(__CTRL_PRESDIV_MASK | __CTRL_RJW_MASK | __CTRL_PSEG1_MASK |
+		 __CTRL_PSEG2_MASK | __CTRL_PROPSEG_MASK);
+
+	if (flexcan->loopback)
+		reg |= __CTRL_LPB;
+	else
+		reg &= ~__CTRL_LPB;
+
+	if (flexcan->smp)
+		reg |= __CTRL_SMP;
+	else
+		reg &= ~__CTRL_SMP;
+
+	if (flexcan->boff_rec)
+		reg |= __CTRL_BOFF_REC;
+	else
+		reg &= ~__CTRL_BOFF_REC;
+
+	if (flexcan->tsyn)
+		reg |= __CTRL_TSYN;
+	else
+		reg &= ~__CTRL_TSYN;
+
+	if (flexcan->listen)
+		reg |= __CTRL_LOM;
+	else
+		reg &= ~__CTRL_LOM;
+
+	reg |= (flexcan->br_presdiv << __CTRL_PRESDIV_OFFSET) |
+	    (flexcan->br_rjw << __CTRL_RJW_OFFSET) |
+	    (flexcan->br_pseg1 << __CTRL_PSEG1_OFFSET) |
+	    (flexcan->br_pseg2 << __CTRL_PSEG2_OFFSET) |
+	    (flexcan->br_propseg << __CTRL_PROPSEG_OFFSET);
+
+	reg &= ~__CTRL_LBUF;
+
+	reg |= __CTRL_TWRN_MSK | __CTRL_RWRN_MSK | __CTRL_BOFF_MSK |
+	    __CTRL_ERR_MSK;
+
+	__raw_writel(reg, flexcan->io_base + CAN_HW_REG_CTRL);
+}
+
+static int flexcan_hw_restart(struct net_device *dev)
+{
+	unsigned int reg;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	if (reg & __MCR_SOFT_RST)
+		return 1;
+
+	flexcan_mcr_setup(flexcan);
+
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_IMASK2);
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_IMASK1);
+
+	__raw_writel(0xFFFFFFFF, flexcan->io_base + CAN_HW_REG_IFLAG2);
+	__raw_writel(0xFFFFFFFF, flexcan->io_base + CAN_HW_REG_IFLAG1);
+
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_ECR);
+
+	flexcan_mbm_init(flexcan);
+	netif_carrier_on(dev);
+	flexcan_hw_start(flexcan);
+
+	if (netif_queue_stopped(dev))
+		netif_start_queue(dev);
+
+	return 0;
+}
+
+static void flexcan_hw_watch(unsigned long data)
+{
+	unsigned int reg, ecr;
+	struct net_device *dev = (struct net_device *)data;
+	struct flexcan_device *flexcan = dev ? netdev_priv(dev) : NULL;
+
+	BUG_ON(!flexcan);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	if (reg & __MCR_MDIS) {
+		if (flexcan_hw_restart(dev))
+			mod_timer(&flexcan->timer, HZ / 20);
+		return;
+	}
+	ecr = __raw_readl(flexcan->io_base + CAN_HW_REG_ECR);
+	if (flexcan->boff_rec) {
+		if (((reg & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) > 1) {
+			reg |= __MCR_SOFT_RST;
+			__raw_writel(reg, flexcan->io_base + CAN_HW_REG_MCR);
+			mod_timer(&flexcan->timer, HZ / 20);
+			return;
+		}
+		netif_carrier_on(dev);
+	}
+}
+
+static void flexcan_hw_busoff(struct net_device *dev)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	unsigned int reg;
+
+	netif_carrier_off(dev);
+
+	flexcan->timer.function = flexcan_hw_watch;
+	flexcan->timer.data = (unsigned long)dev;
+
+	if (flexcan->boff_rec) {
+		mod_timer(&flexcan->timer, HZ / 10);
+		return;
+	}
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_MCR);
+	__raw_writel(reg | __MCR_SOFT_RST, flexcan->io_base + CAN_HW_REG_MCR);
+	mod_timer(&flexcan->timer, HZ / 20);
+}
+
+static int flexcan_hw_open(struct flexcan_device *flexcan)
+{
+	if (flexcan_hw_reset(flexcan))
+		return -EFAULT;
+
+	flexcan_mcr_setup(flexcan);
+	flexcan_ctrl_setup(flexcan);
+
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_IMASK2);
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_IMASK1);
+
+	__raw_writel(0xFFFFFFFF, flexcan->io_base + CAN_HW_REG_IFLAG2);
+	__raw_writel(0xFFFFFFFF, flexcan->io_base + CAN_HW_REG_IFLAG1);
+
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_ECR);
+	return 0;
+}
+
+static void flexcan_err_handler(struct net_device *dev)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	unsigned int esr, ecr;
+
+	esr = __raw_readl(flexcan->io_base + CAN_HW_REG_ESR);
+	__raw_writel(esr & __ESR_INTERRUPTS, flexcan->io_base + CAN_HW_REG_ESR);
+
+	if (esr & __ESR_WAK_INT)
+		return;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		printk(KERN_ERR "%s: allocates skb fail in\n", __func__);
+		return;
+	}
+	frame = (struct can_frame *)skb_put(skb, sizeof(*frame));
+	memset(frame, 0, sizeof(*frame));
+	frame->can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+	frame->can_dlc = CAN_ERR_DLC;
+
+	if (esr & __ESR_TWRN_INT)
+		frame->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+
+	if (esr & __ESR_RWRN_INT)
+		frame->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+
+	if (esr & __ESR_BOFF_INT)
+		frame->can_id |= CAN_ERR_BUSOFF;
+
+	if (esr & __ESR_ERR_INT) {
+		if (esr & __ESR_BIT1_ERR)
+			frame->data[2] |= CAN_ERR_PROT_BIT1;
+
+		if (esr & __ESR_BIT0_ERR)
+			frame->data[2] |= CAN_ERR_PROT_BIT0;
+
+		if (esr & __ESR_ACK_ERR)
+			frame->can_id |= CAN_ERR_ACK;
+
+		/*TODO:// if (esr & __ESR_CRC_ERR) */
+
+		if (esr & __ESR_FRM_ERR)
+			frame->data[2] |= CAN_ERR_PROT_FORM;
+
+		if (esr & __ESR_STF_ERR)
+			frame->data[2] |= CAN_ERR_PROT_STUFF;
+
+		ecr = __raw_readl(flexcan->io_base + CAN_HW_REG_ECR);
+		switch ((esr & __ESR_FLT_CONF_MASK) >> __ESR_FLT_CONF_OFF) {
+		case 0:
+			if (__ECR_TX_ERR_COUNTER(ecr) >= __ECR_ACTIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+			if (__ECR_RX_ERR_COUNTER(ecr) >= __ECR_ACTIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+			break;
+		case 1:
+			if (__ECR_TX_ERR_COUNTER(ecr) >=
+			    __ECR_PASSIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+
+			if (__ECR_RX_ERR_COUNTER(ecr) >=
+			    __ECR_PASSIVE_THRESHOLD)
+				frame->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+			break;
+		default:
+			frame->can_id |= CAN_ERR_BUSOFF;
+		}
+	}
+
+	if (frame->can_id & CAN_ERR_BUSOFF)
+		flexcan_hw_busoff(dev);
+
+	skb->dev = dev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	netif_receive_skb(skb);
+}
+
+static irqreturn_t flexcan_irq_handler(int irq, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct flexcan_device *flexcan = dev ? netdev_priv(dev) : NULL;
+	unsigned int reg;
+
+	BUG_ON(!flexcan);
+
+	reg = __raw_readl(flexcan->io_base + CAN_HW_REG_ESR);
+	if (reg & __ESR_INTERRUPTS) {
+		flexcan_err_handler(dev);
+		return IRQ_HANDLED;
+	}
+
+	flexcan_mbm_isr(dev);
+	return IRQ_HANDLED;
+}
+
+static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct net_device_stats *stats = &dev->stats;
+
+	BUG_ON(!flexcan);
+
+	if (frame->can_dlc > 8)
+		return -EINVAL;
+
+	if (!flexcan_mbm_xmit(flexcan, frame)) {
+		dev_kfree_skb(skb);
+		stats->tx_bytes += frame->can_dlc;
+		stats->tx_packets++;
+		dev->trans_start = jiffies;
+		return NETDEV_TX_OK;
+	}
+	netif_stop_queue(dev);
+	return NETDEV_TX_BUSY;
+}
+
+static int flexcan_open(struct net_device *dev)
+{
+	struct flexcan_device *flexcan;
+	struct platform_device *pdev;
+	struct flexcan_platform_data *plat_data;
+
+	flexcan = netdev_priv(dev);
+	BUG_ON(!flexcan);
+
+	pdev = flexcan->dev;
+	plat_data = (pdev->dev).platform_data;
+	if (plat_data && plat_data->active)
+		plat_data->active(pdev->id);
+
+	if (flexcan->clk)
+		if (clk_enable(flexcan->clk))
+			goto clk_err;
+
+	if (flexcan->core_reg)
+		if (regulator_enable(flexcan->core_reg))
+			goto core_reg_err;
+
+	if (flexcan->io_reg)
+		if (regulator_enable(flexcan->io_reg))
+			goto io_reg_err;
+
+	if (plat_data && plat_data->xcvr_enable)
+		plat_data->xcvr_enable(pdev->id, 1);
+
+	if (request_irq(flexcan->irq, flexcan_irq_handler, IRQF_SHARED,
+			dev->name, dev))
+		goto irq_err;
+	add_interrupt_randomness(flexcan->irq);
+
+	if (flexcan_hw_open(flexcan))
+		goto open_err;
+
+	flexcan_mbm_init(flexcan);
+	netif_carrier_on(dev);
+	flexcan_hw_start(flexcan);
+	return 0;
+open_err:
+	free_irq(flexcan->irq, dev);
+irq_err:
+	if (plat_data && plat_data->xcvr_enable)
+		plat_data->xcvr_enable(pdev->id, 0);
+
+	if (flexcan->io_reg)
+		regulator_disable(flexcan->io_reg);
+io_reg_err:
+	if (flexcan->core_reg)
+		regulator_disable(flexcan->core_reg);
+core_reg_err:
+	if (flexcan->clk)
+		clk_disable(flexcan->clk);
+clk_err:
+	if (plat_data && plat_data->inactive)
+		plat_data->inactive(pdev->id);
+	return -ENODEV;
+}
+
+static int flexcan_stop(struct net_device *dev)
+{
+	struct flexcan_device *flexcan;
+	struct platform_device *pdev;
+	struct flexcan_platform_data *plat_data;
+
+	flexcan = netdev_priv(dev);
+
+	BUG_ON(!flexcan);
+
+	pdev = flexcan->dev;
+	plat_data = (pdev->dev).platform_data;
+
+	flexcan_hw_stop(flexcan);
+
+	free_irq(flexcan->irq, dev);
+
+	if (plat_data && plat_data->xcvr_enable)
+		plat_data->xcvr_enable(pdev->id, 0);
+
+	if (flexcan->io_reg)
+		regulator_disable(flexcan->io_reg);
+	if (flexcan->core_reg)
+		regulator_disable(flexcan->core_reg);
+	if (flexcan->clk)
+		clk_disable(flexcan->clk);
+	if (plat_data && plat_data->inactive)
+		plat_data->inactive(pdev->id);
+	return 0;
+}
+
+static struct net_device_ops flexcan_netdev_ops = {
+	.ndo_open = flexcan_open,
+	.ndo_stop = flexcan_stop,
+	.ndo_start_xmit = flexcan_start_xmit,
+};
+
+static void flexcan_setup(struct net_device *dev)
+{
+	dev->type = ARPHRD_CAN;
+	dev->mtu = sizeof(struct can_frame);
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+	dev->tx_queue_len = FLEXCAN_MAX_MB;
+	dev->flags = IFF_NOARP;
+	dev->features = NETIF_F_NO_CSUM;
+
+	dev->netdev_ops = &flexcan_netdev_ops;
+}
+
+static int flexcan_probe(struct platform_device *pdev)
+{
+	struct net_device *net;
+	net = flexcan_device_alloc(pdev, flexcan_setup);
+	if (!net)
+		return -ENOMEM;
+
+	if (register_netdev(net)) {
+		flexcan_device_free(pdev);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int flexcan_remove(struct platform_device *pdev)
+{
+	flexcan_device_free(pdev);
+	return 0;
+}
+
+static int flexcan_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *net;
+	struct flexcan_device *flexcan;
+	struct flexcan_platform_data *plat_data;
+	net = (struct net_device *)dev_get_drvdata(&pdev->dev);
+	flexcan = netdev_priv(net);
+
+	BUG_ON(!flexcan);
+
+	if (!(net->flags & IFF_UP))
+		return 0;
+	if (flexcan->wakeup)
+		set_irq_wake(flexcan->irq, 1);
+	else {
+		plat_data = (pdev->dev).platform_data;
+
+		if (plat_data && plat_data->xcvr_enable)
+			plat_data->xcvr_enable(pdev->id, 0);
+
+		if (flexcan->io_reg)
+			regulator_disable(flexcan->io_reg);
+		if (flexcan->core_reg)
+			regulator_disable(flexcan->core_reg);
+		if (flexcan->clk)
+			clk_disable(flexcan->clk);
+		if (plat_data && plat_data->inactive)
+			plat_data->inactive(pdev->id);
+	}
+	return 0;
+}
+
+static int flexcan_resume(struct platform_device *pdev)
+{
+	struct net_device *net;
+	struct flexcan_device *flexcan;
+	struct flexcan_platform_data *plat_data;
+	net = (struct net_device *)dev_get_drvdata(&pdev->dev);
+	flexcan = netdev_priv(net);
+
+	BUG_ON(!flexcan);
+
+	if (!(net->flags & IFF_UP))
+		return 0;
+
+	if (flexcan->wakeup)
+		set_irq_wake(flexcan->irq, 0);
+	else {
+		plat_data = (pdev->dev).platform_data;
+		if (plat_data && plat_data->active)
+			plat_data->active(pdev->id);
+
+		if (flexcan->clk) {
+			if (clk_enable(flexcan->clk))
+				printk(KERN_ERR "%s:enable clock fail\n",
+				       __func__);
+		}
+
+		if (flexcan->core_reg) {
+			if (regulator_enable(flexcan->core_reg))
+				printk(KERN_ERR "%s:enable core voltage\n",
+				       __func__);
+		}
+		if (flexcan->io_reg) {
+			if (regulator_enable(flexcan->io_reg))
+				printk(KERN_ERR "%s:enable io voltage\n",
+				       __func__);
+		}
+
+		if (plat_data && plat_data->xcvr_enable)
+			plat_data->xcvr_enable(pdev->id, 1);
+	}
+	return 0;
+}
+
+static struct platform_driver flexcan_driver = {
+	.driver = {
+		   .name = FLEXCAN_DEVICE_NAME,
+		   },
+	.probe = flexcan_probe,
+	.remove = flexcan_remove,
+	.suspend = flexcan_suspend,
+	.resume = flexcan_resume,
+};
+
+static __init int flexcan_init(void)
+{
+	pr_info("Freescale FlexCAN Driver \n");
+	return platform_driver_register(&flexcan_driver);
+}
+
+static __exit void flexcan_exit(void)
+{
+	return platform_driver_unregister(&flexcan_driver);
+}
+
+module_init(flexcan_init);
+module_exit(flexcan_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/can/flexcan/flexcan.h b/drivers/net/can/flexcan/flexcan.h
new file mode 100644
index 0000000..51a800b
--- /dev/null
+++ b/drivers/net/can/flexcan/flexcan.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file flexcan.h
+ *
+ * @brief FlexCan definitions.
+ *
+ * @ingroup can
+ */
+
+#ifndef __CAN_FLEXCAN_H__
+#define __CAN_FLEXCAN_H__
+
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include <linux/can/error.h>
+
+#define FLEXCAN_DEVICE_NAME	"FlexCAN"
+
+#define CAN_MB_RX_INACTIVE	0x0
+#define CAN_MB_RX_EMPTY		0x4
+#define CAN_MB_RX_FULL		0x2
+#define CAN_MB_RX_OVERRUN	0x6
+#define CAN_MB_RX_BUSY		0x1
+
+#define CAN_MB_TX_INACTIVE	0x8
+#define CAN_MB_TX_ABORT		0x9
+#define CAN_MB_TX_ONCE		0xC
+#define CAN_MB_TX_REMOTE	0xA
+
+struct can_hw_mb {
+	unsigned int mb_cs;
+	unsigned int mb_id;
+	unsigned char mb_data[8];
+};
+
+#define MB_CS_CODE_OFFSET	24
+#define MB_CS_CODE_MASK		(0xF << MB_CS_CODE_OFFSET)
+#define MB_CS_SRR_OFFSET	22
+#define MB_CS_SRR_MASK		(0x1 << MB_CS_SRR_OFFSET)
+#define MB_CS_IDE_OFFSET	21
+#define MB_CS_IDE_MASK		(0x1 << MB_CS_IDE_OFFSET)
+#define MB_CS_RTR_OFFSET	20
+#define MB_CS_RTR_MASK		(0x1 << MB_CS_RTR_OFFSET)
+#define MB_CS_LENGTH_OFFSET	16
+#define MB_CS_LENGTH_MASK	(0xF << MB_CS_LENGTH_OFFSET)
+#define MB_CS_TIMESTAMP_OFFSET	0
+#define MB_CS_TIMESTAMP_MASK	(0xFF << MB_CS_TIMESTAMP_OFFSET)
+
+#define CAN_HW_REG_MCR		0x00
+#define CAN_HW_REG_CTRL		0x04
+#define CAN_HW_REG_TIMER	0x08
+#define CAN_HW_REG_RXGMASK	0x10
+#define CAN_HW_REG_RX14MASK	0x14
+#define CAN_HW_REG_RX15MASK	0x18
+#define CAN_HW_REG_ECR		0x1C
+#define CAN_HW_REG_ESR		0x20
+#define CAN_HW_REG_IMASK2	0x24
+#define CAN_HW_REG_IMASK1	0x28
+#define CAN_HW_REG_IFLAG2	0x2C
+#define CAN_HW_REG_IFLAG1	0x30
+
+#define CAN_MB_BASE	0x0080
+#define CAN_RXMASK_BASE	0x0880
+#define CAN_FIFO_BASE	0xE0
+
+#define __MCR_MDIS		(1 << 31)
+#define __MCR_FRZ		(1 << 30)
+#define __MCR_FEN		(1 << 29)
+#define __MCR_HALT		(1 << 28)
+#define __MCR_NOTRDY		(1 << 27)
+#define __MCR_WAK_MSK		(1 << 26)
+#define __MCR_SOFT_RST		(1 << 25)
+#define __MCR_FRZ_ACK		(1 << 24)
+#define __MCR_SLF_WAK		(1 << 22)
+#define __MCR_WRN_EN		(1 << 21)
+#define __MCR_LPM_ACK		(1 << 20)
+#define __MCR_WAK_SRC		(1 << 19)
+#define __MCR_DOZE		(1 << 18)
+#define __MCR_SRX_DIS		(1 << 17)
+#define __MCR_BCC		(1 << 16)
+#define __MCR_LPRIO_EN		(1 << 13)
+#define __MCR_AEN		(1 << 12)
+#define __MCR_MAX_IDAM_OFFSET 	8
+#define __MCR_MAX_IDAM_MASK 	(0x3 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_A	(0x0 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_B	(0x1 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_C	(0x2 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_IDAM_D	(0x3 << __MCR_MAX_IDAM_OFFSET)
+#define __MCR_MAX_MB_OFFSET 	0
+#define __MCR_MAX_MB_MASK 	(0x3F)
+
+#define __CTRL_PRESDIV_OFFSET	24
+#define __CTRL_PRESDIV_MASK	(0xFF << __CTRL_PRESDIV_OFFSET)
+#define __CTRL_RJW_OFFSET	22
+#define __CTRL_RJW_MASK		(0x3 << __CTRL_RJW_OFFSET)
+#define __CTRL_PSEG1_OFFSET	19
+#define __CTRL_PSEG1_MASK	(0x7 << __CTRL_PSEG1_OFFSET)
+#define __CTRL_PSEG2_OFFSET	16
+#define __CTRL_PSEG2_MASK	(0x7 << __CTRL_PSEG2_OFFSET)
+#define __CTRL_BOFF_MSK		(0x1 << 15)
+#define __CTRL_ERR_MSK		(0x1 << 14)
+#define __CTRL_CLK_SRC		(0x1 << 13)
+#define __CTRL_LPB		(0x1 << 12)
+#define __CTRL_TWRN_MSK		(0x1 << 11)
+#define __CTRL_RWRN_MSK		(0x1 << 10)
+#define __CTRL_SMP		(0x1 << 7)
+#define __CTRL_BOFF_REC		(0x1 << 6)
+#define __CTRL_TSYN		(0x1 << 5)
+#define __CTRL_LBUF		(0x1 << 4)
+#define __CTRL_LOM		(0x1 << 3)
+#define __CTRL_PROPSEG_OFFSET	0
+#define __CTRL_PROPSEG_MASK	(0x7)
+
+#define __ECR_TX_ERR_COUNTER(x) ((x) & 0xFF)
+#define __ECR_RX_ERR_COUNTER(x) (((x) >> 8) & 0xFF)
+#define __ECR_PASSIVE_THRESHOLD	128
+#define __ECR_ACTIVE_THRESHOLD	96
+
+#define __ESR_TWRN_INT		(0x1 << 17)
+#define __ESR_RWRN_INT		(0x1 << 16)
+#define __ESR_BIT1_ERR		(0x1 << 15)
+#define __ESR_BIT0_ERR		(0x1 << 14)
+#define __ESR_ACK_ERR		(0x1 << 13)
+#define __ESR_CRC_ERR		(0x1 << 12)
+#define __ESR_FRM_ERR		(0x1 << 11)
+#define __ESR_STF_ERR		(0x1 << 10)
+#define __ESR_TX_WRN		(0x1 << 9)
+#define __ESR_RX_WRN		(0x1 << 8)
+#define __ESR_IDLE		(0x1 << 7)
+#define __ESR_TXRX		(0x1 << 6)
+#define __ESR_FLT_CONF_OFF	4
+#define __ESR_FLT_CONF_MASK	(0x3 << __ESR_FLT_CONF_OFF)
+#define __ESR_BOFF_INT		(0x1 << 2)
+#define __ESR_ERR_INT		(0x1 << 1)
+#define __ESR_WAK_INT		(0x1)
+
+#define __ESR_INTERRUPTS	(__ESR_WAK_INT | __ESR_ERR_INT | \
+				__ESR_BOFF_INT | __ESR_TWRN_INT | \
+				__ESR_RWRN_INT)
+
+#define __FIFO_OV_INT		0x0080
+#define __FIFO_WARN_INT		0x0040
+#define __FIFO_RDY_INT		0x0020
+
+struct flexcan_device {
+	struct mutex mutex;
+	void *io_base;
+	struct can_hw_mb *hwmb;
+	unsigned int *rx_mask;
+	unsigned int xmit_mb;
+	unsigned int bitrate;
+	/* word 1 */
+	unsigned int br_presdiv:8;
+	unsigned int br_rjw:2;
+	unsigned int br_propseg:3;
+	unsigned int br_pseg1:3;
+	unsigned int br_pseg2:3;
+	unsigned int maxmb:6;
+	unsigned int xmit_maxmb:6;
+	unsigned int wd1_resv:1;
+
+	/* word 2 */
+	unsigned int fifo:1;
+	unsigned int wakeup:1;
+	unsigned int srx_dis:1;
+	unsigned int wak_src:1;
+	unsigned int bcc:1;
+	unsigned int lprio:1;
+	unsigned int abort:1;
+	unsigned int br_clksrc:1;
+	unsigned int loopback:1;
+	unsigned int smp:1;
+	unsigned int boff_rec:1;
+	unsigned int tsyn:1;
+	unsigned int listen:1;
+
+	unsigned int ext_msg:1;
+	unsigned int std_msg:1;
+
+	struct timer_list timer;
+	struct platform_device *dev;
+	struct regulator *core_reg;
+	struct regulator *io_reg;
+	struct clk *clk;
+	int irq;
+};
+
+#define FLEXCAN_MAX_FIFO_MB	8
+#define FLEXCAN_MAX_MB		64
+#define FLEXCAN_MAX_PRESDIV	256
+#define FLEXCAN_MAX_RJW		4
+#define FLEXCAN_MAX_PSEG1	8
+#define FLEXCAN_MAX_PSEG2	8
+#define FLEXCAN_MAX_PROPSEG	8
+#define FLEXCAN_MAX_BITRATE	1000000
+
+extern struct net_device *flexcan_device_alloc(struct platform_device *pdev,
+					       void (*setup) (struct net_device
+							      *dev));
+extern void flexcan_device_free(struct platform_device *pdev);
+
+extern void flexcan_mbm_init(struct flexcan_device *flexcan);
+extern void flexcan_mbm_isr(struct net_device *dev);
+extern int flexcan_mbm_xmit(struct flexcan_device *flexcan,
+			    struct can_frame *frame);
+#endif				/* __CAN_FLEXCAN_H__ */
diff --git a/drivers/net/can/flexcan/mbm.c b/drivers/net/can/flexcan/mbm.c
new file mode 100644
index 0000000..c846d97
--- /dev/null
+++ b/drivers/net/can/flexcan/mbm.c
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mbm.c
+ *
+ * @brief Driver for Freescale CAN Controller FlexCAN.
+ *
+ * @ingroup can
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include "flexcan.h"
+
+#define flexcan_swab32(x)	\
+	(((x) << 24) | ((x) >> 24) |\
+		(((x) & (__u32)0x0000ff00UL) << 8) |\
+		(((x) & (__u32)0x00ff0000UL) >> 8))
+
+static inline void flexcan_memcpy(void *dst, void *src, int len)
+{
+	int i;
+	unsigned int *d = (unsigned int *)dst, *s = (unsigned int *)src;
+	len = (len + 3) >> 2;
+	for (i = 0; i < len; i++, s++, d++)
+		*d = flexcan_swab32(*s);
+}
+
+static void flexcan_mb_bottom(struct net_device *dev, int index)
+{
+	struct flexcan_device *flexcan = netdev_priv(dev);
+	struct net_device_stats *stats = &dev->stats;
+	struct can_hw_mb *hwmb;
+	struct can_frame *frame;
+	struct sk_buff *skb;
+	unsigned int tmp;
+
+	hwmb = flexcan->hwmb + index;
+	if (flexcan->fifo || (index >= (flexcan->maxmb - flexcan->xmit_maxmb))) {
+		if ((hwmb->mb_cs & MB_CS_CODE_MASK) >> MB_CS_CODE_OFFSET ==
+							CAN_MB_TX_ABORT) {
+			hwmb->mb_cs &= ~MB_CS_CODE_MASK;
+			hwmb->mb_cs |= CAN_MB_TX_INACTIVE << MB_CS_CODE_OFFSET;
+		}
+
+		if (hwmb->mb_cs & (CAN_MB_TX_INACTIVE << MB_CS_CODE_OFFSET)) {
+			if (netif_queue_stopped(dev))
+				netif_start_queue(dev);
+			return;
+		}
+	}
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb) {
+		frame = (struct can_frame *)skb_put(skb, sizeof(*frame));
+		memset(frame, 0, sizeof(*frame));
+		if (hwmb->mb_cs & MB_CS_IDE_MASK)
+			frame->can_id =
+			    (hwmb->mb_id & CAN_EFF_MASK) | CAN_EFF_FLAG;
+		else
+			frame->can_id = (hwmb->mb_id >> 18) & CAN_SFF_MASK;
+
+		if (hwmb->mb_cs & MB_CS_RTR_MASK)
+			frame->can_id |= CAN_RTR_FLAG;
+
+		frame->can_dlc =
+		(hwmb->mb_cs & MB_CS_LENGTH_MASK) >> MB_CS_LENGTH_OFFSET;
+
+		if (frame->can_dlc && frame->can_dlc)
+			flexcan_memcpy(frame->data, hwmb->mb_data,
+				       frame->can_dlc);
+
+		if (flexcan->fifo
+		    || (index >= (flexcan->maxmb - flexcan->xmit_maxmb))) {
+			hwmb->mb_cs &= ~MB_CS_CODE_MASK;
+			hwmb->mb_cs |= CAN_MB_TX_INACTIVE << MB_CS_CODE_OFFSET;
+			if (netif_queue_stopped(dev))
+				netif_start_queue(dev);
+		}
+
+		tmp = __raw_readl(flexcan->io_base + CAN_HW_REG_TIMER);
+
+		dev->last_rx = jiffies;
+		stats->rx_packets++;
+		stats->rx_bytes += frame->can_dlc;
+
+		skb->dev = dev;
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_rx(skb);
+	} else {
+		tmp = hwmb->mb_cs;
+		tmp = hwmb->mb_id;
+		tmp = hwmb->mb_data[0];
+		if (flexcan->fifo
+		    || (index >= (flexcan->maxmb - flexcan->xmit_maxmb))) {
+			hwmb->mb_cs &= ~MB_CS_CODE_MASK;
+			hwmb->mb_cs |= CAN_MB_TX_INACTIVE << MB_CS_CODE_OFFSET;
+			if (netif_queue_stopped(dev))
+				netif_start_queue(dev);
+		}
+		tmp = __raw_readl(flexcan->io_base + CAN_HW_REG_TIMER);
+		stats->rx_dropped++;
+	}
+}
+
+static void flexcan_fifo_isr(struct net_device *dev, unsigned int iflag1)
+{
+	struct flexcan_device *flexcan = dev ? netdev_priv(dev) : NULL;
+	struct net_device_stats *stats = &dev->stats;
+	struct sk_buff *skb;
+	struct can_hw_mb *hwmb = flexcan->hwmb;
+	struct can_frame *frame;
+	unsigned int tmp;
+
+	if (iflag1 & __FIFO_RDY_INT) {
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (skb) {
+			frame =
+			    (struct can_frame *)skb_put(skb, sizeof(*frame));
+			memset(frame, 0, sizeof(*frame));
+			if (hwmb->mb_cs & MB_CS_IDE_MASK)
+				frame->can_id =
+				    (hwmb->mb_id & CAN_EFF_MASK) | CAN_EFF_FLAG;
+			else
+				frame->can_id =
+				    (hwmb->mb_id >> 18) & CAN_SFF_MASK;
+
+			if (hwmb->mb_cs & MB_CS_RTR_MASK)
+				frame->can_id |= CAN_RTR_FLAG;
+
+			frame->can_dlc =
+				(hwmb->mb_cs & MB_CS_LENGTH_MASK) >>
+						MB_CS_LENGTH_OFFSET;
+
+			if (frame->can_dlc && (frame->can_dlc <= 8))
+				flexcan_memcpy(frame->data, hwmb->mb_data,
+					       frame->can_dlc);
+			tmp = __raw_readl(flexcan->io_base + CAN_HW_REG_TIMER);
+
+			dev->last_rx = jiffies;
+
+			stats->rx_packets++;
+			stats->rx_bytes += frame->can_dlc;
+
+			skb->dev = dev;
+			skb->protocol = __constant_htons(ETH_P_CAN);
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+			netif_rx(skb);
+		} else {
+			tmp = hwmb->mb_cs;
+			tmp = hwmb->mb_id;
+			tmp = hwmb->mb_data[0];
+			tmp = __raw_readl(flexcan->io_base + CAN_HW_REG_TIMER);
+		}
+	}
+
+	if (iflag1 & (__FIFO_OV_INT | __FIFO_WARN_INT)) {
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (skb) {
+			frame =
+			    (struct can_frame *)skb_put(skb, sizeof(*frame));
+			memset(frame, 0, sizeof(*frame));
+			frame->can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+			frame->can_dlc = CAN_ERR_DLC;
+			if (iflag1 & __FIFO_WARN_INT)
+				frame->data[1] |=
+				    CAN_ERR_CRTL_TX_WARNING |
+				    CAN_ERR_CRTL_RX_WARNING;
+			if (iflag1 & __FIFO_OV_INT)
+				frame->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
+
+			skb->dev = dev;
+			skb->protocol = __constant_htons(ETH_P_CAN);
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+			netif_rx(skb);
+		}
+	}
+}
+
+/*!
+ * @brief The function call by CAN ISR to handle mb events.
+ *
+ * @param dev		the pointer of network device.
+ *
+ * @return none
+ */
+void flexcan_mbm_isr(struct net_device *dev)
+{
+	int i, iflag1, iflag2, maxmb;
+	struct flexcan_device *flexcan = dev ? netdev_priv(dev) : NULL;
+
+	if (flexcan->maxmb > 31) {
+		maxmb = flexcan->maxmb + 1 - 32;
+		iflag1 = __raw_readl(flexcan->io_base + CAN_HW_REG_IFLAG1) &
+		    __raw_readl(flexcan->io_base + CAN_HW_REG_IMASK1);
+		iflag2 = __raw_readl(flexcan->io_base + CAN_HW_REG_IFLAG2) &
+		    __raw_readl(flexcan->io_base + CAN_HW_REG_IMASK2);
+		iflag2 &= (1 << maxmb) - 1;
+		maxmb = 32;
+	} else {
+		maxmb = flexcan->maxmb + 1;
+		iflag1 = __raw_readl(flexcan->io_base + CAN_HW_REG_IFLAG1) &
+		    __raw_readl(flexcan->io_base + CAN_HW_REG_IMASK1);
+		iflag1 &= (1 << maxmb) - 1;
+		iflag2 = 0;
+	}
+
+	__raw_writel(iflag1, flexcan->io_base + CAN_HW_REG_IFLAG1);
+	__raw_writel(iflag2, flexcan->io_base + CAN_HW_REG_IFLAG2);
+
+	if (flexcan->fifo) {
+		flexcan_fifo_isr(dev, iflag1);
+		iflag1 &= 0xFFFFFF00;
+	}
+	for (i = 0; iflag1 && (i < maxmb); i++) {
+		if (iflag1 & (1 << i)) {
+			iflag1 &= ~(1 << i);
+			flexcan_mb_bottom(dev, i);
+		}
+	}
+
+	for (i = maxmb; iflag2 && (i <= flexcan->maxmb); i++) {
+		if (iflag2 & (1 << (i - 32))) {
+			iflag2 &= ~(1 << (i - 32));
+			flexcan_mb_bottom(dev, i);
+		}
+	}
+}
+
+/*!
+ * @brief function to xmit message buffer
+ *
+ * @param flexcan	the pointer of can hardware device.
+ * @param frame		the pointer of can message frame.
+ *
+ * @return	Returns 0 if xmit is success. otherwise returns non-zero.
+ */
+int flexcan_mbm_xmit(struct flexcan_device *flexcan, struct can_frame *frame)
+{
+	int i = flexcan->xmit_mb;
+	struct can_hw_mb *hwmb = flexcan->hwmb;
+
+	do {
+		if ((hwmb[i].mb_cs & MB_CS_CODE_MASK) >> MB_CS_CODE_OFFSET ==
+							    CAN_MB_TX_INACTIVE)
+			break;
+		if ((++i) > flexcan->maxmb) {
+			if (flexcan->fifo)
+				i = FLEXCAN_MAX_FIFO_MB;
+			else
+				i = flexcan->xmit_maxmb + 1;
+		}
+		if (i == flexcan->xmit_mb)
+			return -1;
+	} while (1);
+
+	flexcan->xmit_mb = i + 1;
+	if (flexcan->xmit_mb > flexcan->maxmb) {
+		if (flexcan->fifo)
+			flexcan->xmit_mb = FLEXCAN_MAX_FIFO_MB;
+		else
+			flexcan->xmit_mb = flexcan->xmit_maxmb + 1;
+	}
+
+	if (frame->can_id & CAN_RTR_FLAG)
+		hwmb[i].mb_cs |= 1 << MB_CS_RTR_OFFSET;
+	else
+		hwmb[i].mb_cs &= ~MB_CS_RTR_MASK;
+
+	if (frame->can_id & CAN_EFF_FLAG) {
+		hwmb[i].mb_cs |= 1 << MB_CS_IDE_OFFSET;
+		hwmb[i].mb_cs |= 1 << MB_CS_SRR_OFFSET;
+		hwmb[i].mb_id = frame->can_id & CAN_EFF_MASK;
+	} else {
+		hwmb[i].mb_cs &= ~MB_CS_IDE_MASK;
+		hwmb[i].mb_id = (frame->can_id & CAN_SFF_MASK) << 18;
+	}
+
+	hwmb[i].mb_cs &= ~MB_CS_LENGTH_MASK;
+	hwmb[i].mb_cs |= frame->can_dlc << MB_CS_LENGTH_OFFSET;
+	flexcan_memcpy(hwmb[i].mb_data, frame->data, frame->can_dlc);
+	hwmb[i].mb_cs &= ~MB_CS_CODE_MASK;
+	hwmb[i].mb_cs |= CAN_MB_TX_ONCE << MB_CS_CODE_OFFSET;
+	return 0;
+}
+
+/*!
+ * @brief function to initial message buffer
+ *
+ * @param flexcan	the pointer of can hardware device.
+ *
+ * @return	none
+ */
+void flexcan_mbm_init(struct flexcan_device *flexcan)
+{
+	struct can_hw_mb *hwmb;
+	int rx_mb, i;
+
+	/* Set global mask to receive all messages */
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_RXGMASK);
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_RX14MASK);
+	__raw_writel(0, flexcan->io_base + CAN_HW_REG_RX15MASK);
+
+	memset(flexcan->hwmb, 0, sizeof(*hwmb) * FLEXCAN_MAX_MB);
+	/* Set individual mask to receive all messages */
+	memset(flexcan->rx_mask, 0, sizeof(unsigned int) * FLEXCAN_MAX_MB);
+
+	if (flexcan->fifo)
+		rx_mb = FLEXCAN_MAX_FIFO_MB;
+	else
+		rx_mb = flexcan->maxmb - flexcan->xmit_maxmb;
+
+	hwmb = flexcan->hwmb;
+	if (flexcan->fifo) {
+		unsigned long *id_table = flexcan->io_base + CAN_FIFO_BASE;
+		for (i = 0; i < rx_mb; i++)
+			id_table[i] = 0;
+	} else {
+		for (i = 0; i < rx_mb; i++) {
+			hwmb[i].mb_cs &= ~MB_CS_CODE_MASK;
+			hwmb[i].mb_cs |= CAN_MB_RX_EMPTY << MB_CS_CODE_OFFSET;
+			/*
+			 * IDE bit can not control by mask registers
+			 * So set message buffer to receive extend
+			 * or standard message.
+			 */
+			if (flexcan->ext_msg && flexcan->std_msg) {
+				hwmb[i].mb_cs &= ~MB_CS_IDE_MASK;
+				hwmb[i].mb_cs |= (i & 1) << MB_CS_IDE_OFFSET;
+			} else {
+				if (flexcan->ext_msg)
+					hwmb[i].mb_cs |= 1 << MB_CS_IDE_OFFSET;
+			}
+		}
+	}
+
+	for (; i <= flexcan->maxmb; i++) {
+		hwmb[i].mb_cs &= ~MB_CS_CODE_MASK;
+		hwmb[i].mb_cs |= CAN_MB_TX_INACTIVE << MB_CS_CODE_OFFSET;
+	}
+
+	flexcan->xmit_mb = rx_mb;
+}
-- 
1.7.0.4

