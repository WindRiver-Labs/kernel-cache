From 15f2c65685292ad61cca0b46581aaa1513750f87 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Jun 2009 21:25:39 +0800
Subject: [PATCH] MXC: Introduce USB OTG driver

Original code source taken from Freescale BSP Global Package Pool.
http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

OTG Controller + USB transceiver isp1504 exist on severial MXC
platforms, here backport the OTG driver from Freescale vendor drop,
adjust related USB UDC&HOST drivers and reconstruct Kconfig&Makefile
so as to fully funciton OTG.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Add new usb transceiver support in Makefile and Kconfig. The new added
transceiver is an on-chip one which is used by imx51pdk OTG port.
Fix a usb device controller driver defect. The defect is if there
is no usb gadget driver loaded before the udc enter suspend or resume,
the udc driver will crash.
Move the otg_start_host from irq context to kthread context for mx51.
Because on imx51, the otg_start_host will call transceiver operation
which has possibility to be blocked(calling wait_event).

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/arm/plat-mxc/Kconfig                |   25 +
 arch/arm/plat-mxc/include/mach/arc_otg.h |   11 +
 drivers/usb/Makefile                     |    2 +
 drivers/usb/core/Kconfig                 |    6 +-
 drivers/usb/gadget/Kconfig               |   92 ++-
 drivers/usb/gadget/arcotg_udc.c          |   42 +-
 drivers/usb/host/Kconfig                 |   40 +-
 drivers/usb/host/ehci-arc.c              |  103 ++-
 drivers/usb/host/ehci-fsl.h              |    4 +
 drivers/usb/otg/Kconfig                  |    5 +
 drivers/usb/otg/Makefile                 |   12 +
 drivers/usb/otg/fsl_otg.c                | 1215 ++++++++++++++++++++++++++++++
 drivers/usb/otg/fsl_otg.h                |  410 ++++++++++
 drivers/usb/otg/otg_fsm.c                |  371 +++++++++
 drivers/usb/otg/otg_fsm.h                |  151 ++++
 include/linux/fsl_devices.h              |   60 ++-
 include/linux/usb/fsl_xcvr.h             |   44 ++
 17 files changed, 2499 insertions(+), 94 deletions(-)
 create mode 100644 drivers/usb/otg/Kconfig
 create mode 100644 drivers/usb/otg/Makefile
 create mode 100644 drivers/usb/otg/fsl_otg.c
 create mode 100644 drivers/usb/otg/fsl_otg.h
 create mode 100644 drivers/usb/otg/otg_fsm.c
 create mode 100644 drivers/usb/otg/otg_fsm.h
 create mode 100644 include/linux/usb/fsl_xcvr.h

diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index acb916e..2733a4b 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -23,6 +23,31 @@ source "arch/arm/mach-mx3/Kconfig"
 
 endmenu
 
+config UTMI_MXC
+	bool
+	select UTMI_MXC_OTG if (USB_GADGET || USB_EHCI_HCD) && USB_OTG
+	default y if USB_EHCI_FSL_UTMI || USB_GADGET_FSL_UTMI
+	depends on ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51
+
+config UTMI_MXC_OTG
+	tristate
+	help
+	  Support for USB OTG pin detect using the UTMI transceiver on MXC
+	  platforms.
+
+config ISP1504_MXC
+	bool "ISP1504 transceiver support"
+	select ISP1504_MXC_OTG if (USB_GADGET || USB_EHCI_HCD) && USB_OTG
+	help
+	  Support for the ISP1504 USB transceiver on MXC platforms.
+
+config ISP1504_MXC_OTG
+	tristate "USB OTG support by ISP1504 transceiver"
+	depends on ISP1504_MXC && USB_OTG
+	default n
+	help
+	  Support for USB OTG using the ISP1504 transceiver on MXC platforms.
+
 config MXC_ISP1301
 	bool "ISP1301 USB transeiver"
 	depends on I2C
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index a08cd03..8b9ad4d 100644
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -23,6 +23,17 @@ struct arc_usb_config {
 	u32 usbmode;		/* address of usbmode register */
 	u32 does_otg;		/* set IFF it's an OTG port */
 	unsigned power_budget;	/* for hcd->power_budget */
+
+	/* register save area for suspend/resume */
+	u32 pm_command;
+	u32 pm_status;
+	u32 pm_intr_enable;
+	u32 pm_frame_index;
+	u32 pm_segment;
+	u32 pm_frame_list;
+	u32 pm_async_next;
+	u32 pm_configured_flag;
+	u32 pm_portsc;
 };
 
 struct arc_xcvr_config {
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index a419c42..265ca57 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -8,6 +8,8 @@ obj-$(CONFIG_USB)		+= core/
 
 obj-$(CONFIG_USB_MON)		+= mon/
 
+obj-$(CONFIG_USB_OTG)		+= otg/
+
 obj-$(CONFIG_PCI)		+= host/
 obj-$(CONFIG_USB_EHCI_HCD)	+= host/
 obj-$(CONFIG_USB_ISP116X_HCD)	+= host/
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index cc9f397..d402c36 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -103,8 +103,10 @@ config USB_SUSPEND
 	  If you are unsure about this, say N here.
 
 config USB_OTG
-	bool
-	depends on USB && EXPERIMENTAL
+	bool "Enable On-The-Go(OTG) support"
+	depends on USB && EXPERIMENTAL && \
+		   (USB_GADGET_ARC_OTGHS || USB_EHCI_ARC_OTGHS || \
+		    USB_GADGET_ARC_OTG || USB_EHCI_ARC_OTG)
 	select USB_SUSPEND
 	default n
 
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index e89fe5e..1fc4d09 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -315,16 +315,33 @@ config USB_OMAP
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
-config USB_OTG
-	boolean "OTG Support"
-	depends on USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD
+config USB_GADGET_ARC
+	boolean "ARC USB Device Controller"
+	depends on ARCH_MXC
+	select USB_GADGET_DUALSPEED
+	select USB_GADGET_ARC_OTGHS if USB_EHCI_ARC_OTGHS
+	select USB_GADGET_ARC_OTGFS if USB_EHCI_ARC_OTGFS
+	select USB_GADGET_FSL_UTMI if USB_EHCI_FSL_UTMI
 	help
-	   The most notable feature of USB OTG is support for a
-	   "Dual-Role" device, which can act as either a device
-	   or a host.  The initial role choice can be changed
-	   later, when two dual-role devices talk to each other.
+	  Some Freescale processors have an ARC High Speed
+	  USBOTG controller, which supports device mode.
+	  This driver supports the controller in the i.MX27,i.MX31 and
+	  i.MX51 and should work with controllers
+	  in other Freescale processors too, given minor tweaks.
+
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "arc_udc" and force all
+	  gadget drivers to also be dynamically linked.
+
+config USB_ARC
+	tristate
+	depends on USB_GADGET_ARC
+	select ISP1504_MXC if USB_GADGET_ARC_OTGHS
+	select MXC_ISP1301 if USB_GADGET_ARC_OTGFS
+	select UTMI_MXC if USB_GADGET_FSL_UTMI
+	default USB_GADGET
+	select USB_GADGET_SELECTED
 
-	   Select this only if your OMAP board has a Mini-AB connector.
 
 config USB_GADGET_S3C2410
 	boolean "S3C2410 USB Device Controller"
@@ -365,24 +382,6 @@ config USB_AT91
 	depends on USB_GADGET_AT91
 	default USB_GADGET
 
-config USB_GADGET_ARC
-	boolean "Freescale USB Device Controller"
-	depends on ARCH_MXC
-	select USB_GADGET_DUALSPEED if USB_GADGET_FSL_1504 || USB_GADGET_FSL_UTMI
-	help
-	   Some Freescale processors have a USBOTG controller,
-	   which supports device mode.
-
-	   Say "y" to link the driver statically, or "m" to build a
-	   dynamically linked module called "arc_udc" and force all
-	   gadget drivers to also be dynamically linked.
-
-config USB_ARC
-	tristate
-	depends on USB_GADGET_ARC
-	default USB_GADGET
-	select USB_GADGET_SELECTED
-
 config USB_GADGET_DUMMY_HCD
 	boolean "Dummy HCD (DEVELOPMENT)"
 	depends on USB=y || (USB=m && USB_GADGET=m)
@@ -425,6 +424,47 @@ config USB_GADGET_DUALSPEED
 	  Means that gadget drivers should include extra descriptors
 	  and code to handle dual-speed controllers.
 
+config USB_GADGET_ARC_OTG
+    bool "Support for OTG prepheral port on ARC controller"
+    depends on USB_GADGET_ARC
+    default y
+    ---help---
+      Enable support for the USB OTG port in HS/FS prepheral mode.
+
+choice
+    prompt "Select transceiver"
+    depends on USB_GADGET_ARC_OTG
+
+config USB_GADGET_ARC_OTGFS
+    bool "Full Speed"
+    depends on !USB_EHCI_ARC_OTGHS
+    help
+      The ARC OTG controller can be connected to either a FS or
+      a HS transceiver.
+
+      Enable this configuration option if you want to use the FS
+      transceiver.
+
+config USB_GADGET_ARC_OTGHS
+    bool "High Speed"
+    depends on !USB_EHCI_ARC_OTGFS
+    help
+      The ARC OTG controller can be connected to either a FS or
+      a HS transceiver.
+
+      Enable this configuration option if you want to use the HS
+      transceiver.
+
+config USB_GADGET_FSL_UTMI
+	bool "On-chip UTMI"
+
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx35 board.
+
+endchoice
+
 #
 # USB Gadget Drivers
 #
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 3ebf4da..1d432bb 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -773,13 +773,7 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 
 	req->req.actual += *length;
 
-	/* zlp is needed if req->req.zero is set */
-	if (req->req.zero) {
-		if (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)
-			*is_last = 1;
-		else
-			*is_last = 0;
-	} else if (req->req.length == req->req.actual)
+	if (req->req.length == req->req.actual)
 		*is_last = 1;
 	else
 		*is_last = 0;
@@ -1717,8 +1711,10 @@ static void suspend_irq(struct fsl_udc *udc)
 	udc->usb_state = USB_STATE_SUSPENDED;
 
 	/* report suspend to the driver, serial.c does not support this */
-	if (udc->driver->suspend)
-		udc->driver->suspend(&udc->gadget);
+	if (udc->driver) {
+		if (udc->driver->suspend)
+			udc->driver->suspend(&udc->gadget);
+	}
 }
 
 static void bus_resume(struct fsl_udc *udc)
@@ -1727,8 +1723,10 @@ static void bus_resume(struct fsl_udc *udc)
 	udc->resume_state = 0;
 
 	/* report resume to the driver, serial.c does not support this */
-	if (udc->driver->resume)
-		udc->driver->resume(&udc->gadget);
+	if (udc->driver) {
+		if (udc->driver->resume)
+			udc->driver->resume(&udc->gadget);
+	}
 }
 
 /* Clear up all ep queues */
@@ -1929,11 +1927,9 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		udc_suspend(udc_controller);
 		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
 
-#if 0
 		/* export udc suspend/resume call to OTG */
 		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
 		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
-#endif
 
 		/* connect to bus through transceiver */
 		if (udc_controller->transceiver) {
@@ -2389,7 +2385,7 @@ static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
 static int __init fsl_udc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
-	struct mxc_gadget_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct clk *usbclk, *ahbclk;
 	int ret = -ENODEV;
 	unsigned int i;
@@ -2415,10 +2411,10 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		goto err1a;
 	}
 
-	res = otg_get_resources();
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
-		DBG("resource not registered!\n");
-		return -ENODEV;
+		ret = -ENODEV;
+		goto err1a;
 	}
 #else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2448,7 +2444,7 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	/*
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
-	if (pdata->init && pdata->init(pdev)) {
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
 		ret = -ENODEV;
 		goto err2a;
 	}
@@ -2553,8 +2549,8 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
-	if (pdata->exit)
-		pdata->exit(pdev);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
 err2a:
 	iounmap(dr_regs);
 err1:
@@ -2572,7 +2568,7 @@ err1a:
 static int __exit fsl_udc_remove(struct platform_device *pdev)
 {
 	struct resource *res;
-	struct mxc_gadget_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	DECLARE_COMPLETION(done);
 
@@ -2605,8 +2601,8 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	 * do platform specific un-initialization:
 	 * release iomux pins, etc.
 	 */
-	if (pdata->exit)
-		pdata->exit(pdev);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
 
 	return 0;
 }
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 94f9bc9..6bf5504 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -20,6 +20,10 @@ config USB_C67X00_HCD
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on USB && USB_ARCH_HAS_EHCI
+	select ISP1504_MXC if ( MACH_MX31ADS || MACH_MX27ADS || MACH_MX31LITE) && \
+			      (USB_EHCI_ARC_OTGHS || USB_EHCI_ARC_H2)
+	select MXC_ISP1301 if ( MACH_MX31ADS || MACH_MX27ADS ) && \
+			      USB_EHCI_ARC_OTGFS
 	---help---
 	  The Enhanced Host Controller Interface (EHCI) is standard for USB 2.0
 	  "high speed" (480 Mbit/sec, 60 Mbyte/sec) host controller hardware.
@@ -64,6 +68,7 @@ endchoice
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
 	depends on USB_EHCI_HCD
+	default y if USB_EHCI_ARC
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
@@ -109,9 +114,8 @@ config USB_EHCI_FSL
 
 config USB_EHCI_ARC
     bool "Support for ARC controller"
-    depends on USB_EHCI_HCD && ARCH_MX3
+    depends on USB_EHCI_HCD && ARCH_MXC
     select USB_EHCI_ROOT_HUB_TT
-	select ISP1504_MXC if MACH_MX31LITE
     ---help---
        Some Freescale processors have an ARC High Speed
        USBOTG controller, which supports EHCI host mode.
@@ -135,6 +139,38 @@ config USB_EHCI_ARC_H2
     ---help---
       Enable support for the USB Host2 port.
 
+config USB_EHCI_ARC_OTG
+    bool "Support for OTG host port on ARC controller"
+    depends on USB_EHCI_ARC
+    default y
+    ---help---
+      Enable support for the USB OTG port in HS/FS Host mode.
+
+choice
+    prompt "Select transceiver"
+    depends on USB_EHCI_ARC_OTG
+    default USB_EHCI_ARC_OTGHS if !ARCH_MX51
+    default USB_EHCI_FSL_UTMI if ARCH_MX51
+
+config USB_EHCI_ARC_OTGHS
+    bool "High Speed"
+    ---help---
+      Enable support for the USB OTG port in HS Host mode.
+
+config USB_EHCI_ARC_OTGFS
+    bool "Full Speed"
+    ---help---
+      Enable support for the USB OTG port in FS Host mode.
+
+config USB_EHCI_FSL_UTMI
+	bool "Internal UTMI"
+	depends on (ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51)
+	---help---
+	  Enable support for the on-chip High Speed UTMI transceiver.
+
+	  This is the factory default for the mx35ads board.
+endchoice
+
 config USB_EHCI_HCD_PPC_OF
 	bool "EHCI support for PPC USB controller on OF platform bus"
 	depends on USB_EHCI_HCD && PPC_OF
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
index 0c843c4..26ab8bb 100644
--- a/drivers/usb/host/ehci-arc.c
+++ b/drivers/usb/host/ehci-arc.c
@@ -22,6 +22,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/usb/otg.h>
+#include <linux/fsl_devices.h>
 #include <mach/arc_otg.h>
 #include <mach/isp1504.h>
 
@@ -29,6 +30,16 @@
 #include <mach/mx31_usb.h>
 #endif
 
+#ifdef CONFIG_MACH_MX27
+#include <mach/mx27_usb.h>
+#endif
+
+#include "ehci-fsl.h"
+
+#ifdef CONFIG_ARCH_MX51
+#include <mach/mx51_usb.h>
+#endif
+
 static struct otg_transceiver *transceiver;
 
 /* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
@@ -108,14 +119,16 @@ static int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	vdbg("start=0x%x   end=0x%x    rsrc_start=0x%llx  rsrc_len=0x%llx\n",
 			res->start, res->end, hcd->rsrc_start, hcd->rsrc_len);
 
+#ifndef CONFIG_USB_OTG
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
 				driver->description)) {
 		dev_dbg(&pdev->dev, "request_mem_region failed\n");
 		retval = -EBUSY;
 		goto err2;
 	}
+#endif
 
-	hcd->regs = (void __iomem *)IO_ADDRESS(hcd->rsrc_start);
+	hcd->regs = (void __iomem *)(u32)IO_ADDRESS(hcd->rsrc_start);
 
 	if (hcd->regs == NULL) {
 		dev_dbg(&pdev->dev, "error mapping memory\n");
@@ -142,8 +155,8 @@ static int usb_hcd_fsl_probe(const struct hc_driver *driver,
 
 		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
 
-		transceiver = otg_get_transceiver()
-			dbg("ehci->transceiver=0x%p\n", transceiver);
+		transceiver = otg_get_transceiver();
+		dbg("ehci->transceiver=0x%p\n", transceiver);
 
 		if (transceiver) {
 			retval = otg_set_host(transceiver,
@@ -170,7 +183,9 @@ static int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	return retval;
 
 err3:
+#ifndef CONFIG_USB_OTG
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+#endif
 err2:
 	usb_put_hcd(hcd);
 err1:
@@ -189,7 +204,9 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 	dbg("%s  hcd=0x%p\n", __func__, hcd);
 
 	usb_remove_hcd(hcd);
+#ifndef CONFIG_USB_OTG
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+#endif
 	usb_put_hcd(hcd);
 
 	if (transceiver) {
@@ -234,16 +251,20 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
-	hcd->has_tt = 1;
-	ehci->sbrn = 0x20;
-
-	ehci_reset(ehci);
+	retval = ehci_halt(ehci);
 
 	/* data structure init */
 	retval = ehci_init(hcd);
 	if (retval)
 		return retval;
 
+	hcd->has_tt = 1;
+
+	/* usb controller is compliant with with usb spec 2.0 */
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
 	retval = ehci_fsl_reinit(ehci);
 	return retval;
 }
@@ -258,7 +279,7 @@ static const struct hc_driver ehci_arc_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq		= ehci_irq,
-	.flags		= HCD_USB2 ,
+	.flags		= FSL_PLATFORM_HC_FLAGS,
 
 	/*
 	 * basic lifecycle operations
@@ -294,7 +315,6 @@ static const struct hc_driver ehci_arc_hc_driver = {
 
 /* *INDENT-ON* */
 
-static struct ehci_regs usb_ehci_regs;
 
 /* suspend/resume, section 4.3 */
 
@@ -320,17 +340,39 @@ static int ehci_arc_suspend(struct platform_device *pdev, pm_message_t state)
 	dbg("%s config->usbmode=0x%x  config->set_vbus_power=0x%p\n",
 			__func__, config->usbmode, config->set_vbus_power);
 
-#ifdef CONFIG_USB_OTG
-	hcd->state = HC_STATE_HALT;	/* ignore non-host interrupts */
-#endif
+	printk(KERN_INFO "USB Host suspended\n");
 
-	cmd = readl(&ehci->regs->command);
-	cmd &= ~CMD_RUN;
-	writel(cmd, &ehci->regs->command);
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
 
-	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
-	usb_ehci_regs.port_status[0] &=
-		cpu_to_le32(~(PORT_PEC | PORT_OCC | PORT_CSC));
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* stop the controller */
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	cmd &= ~CMD_RUN;
+	ehci_writel(ehci, cmd, &ehci->regs->command);
+
+	/* save EHCI registers */
+	config->pm_command = ehci_readl(ehci, &ehci->regs->command);
+	config->pm_command &= ~CMD_RUN;
+	config->pm_status  = ehci_readl(ehci, &ehci->regs->status);
+	config->pm_intr_enable  = ehci_readl(ehci, &ehci->regs->intr_enable);
+	config->pm_frame_index  = ehci_readl(ehci, &ehci->regs->frame_index);
+	config->pm_segment  = ehci_readl(ehci, &ehci->regs->segment);
+	config->pm_frame_list  = ehci_readl(ehci, &ehci->regs->frame_list);
+	config->pm_async_next  = ehci_readl(ehci, &ehci->regs->async_next);
+	config->pm_configured_flag  =
+		ehci_readl(ehci, &ehci->regs->configured_flag);
+	config->pm_portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+
+	/* clear the W1C bits */
+	config->pm_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);
+
+	/* clear PP to cut power to the port */
+	cmd = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	cmd &= ~PORT_POWER;
+	ehci_writel(ehci, cmd, &ehci->regs->port_status[0]);
 
 	if (config->set_vbus_power)
 		config->set_vbus_power(0);
@@ -355,16 +397,27 @@ static int ehci_arc_resume(struct platform_device *pdev)
 		config->set_vbus_power(1);
 
 	writel(USBMODE_CM_HOST, config->usbmode);
-	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
-
-	cmd = readl(&ehci->regs->command);
-	cmd |= CMD_RUN;
-	writel(cmd, &ehci->regs->command);
 
-#ifdef CONFIG_USB_OTG
+	/* restore EHCI registers */
+	ehci_writel(ehci, config->pm_command, &ehci->regs->command);
+	ehci_writel(ehci, config->pm_intr_enable, &ehci->regs->intr_enable);
+	ehci_writel(ehci, config->pm_frame_index, &ehci->regs->frame_index);
+	ehci_writel(ehci, config->pm_segment, &ehci->regs->segment);
+	ehci_writel(ehci, config->pm_frame_list, &ehci->regs->frame_list);
+	ehci_writel(ehci, config->pm_async_next, &ehci->regs->async_next);
+	ehci_writel(ehci, config->pm_configured_flag,
+		    &ehci->regs->configured_flag);
+	ehci_writel(ehci, config->pm_portsc, &ehci->regs->port_status[0]);
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	hcd->state = HC_STATE_RUNNING;
-#endif
+	pdev->dev.power.power_state = PMSG_ON;
+
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	cmd |= CMD_RUN;
+	ehci_writel(ehci, cmd, &ehci->regs->command);
 
+	usb_hcd_resume_root_hub(hcd);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index b5e59db..671c325 100644
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -19,6 +19,10 @@
 #define _EHCI_FSL_H
 
 /* offsets for the non-ehci registers in the FSL SOC USB controller */
+#define FSL_SOC_USB_SBUSCFG     0x90
+#define FSL_SOC_USB_BURSTSIZE	0x160
+#define FSL_SOC_USB_TXFILLTUNING	0x164
+
 #define FSL_SOC_USB_ULPIVP	0x170
 #define FSL_SOC_USB_PORTSC1	0x184
 #define PORT_PTS_MSK		(3<<30)
diff --git a/drivers/usb/otg/Kconfig b/drivers/usb/otg/Kconfig
new file mode 100644
index 0000000..20ccb82
--- /dev/null
+++ b/drivers/usb/otg/Kconfig
@@ -0,0 +1,5 @@
+config TRANSCEIVER_MXC_OTG
+	tristate "usb otg pin detect support"
+	depends on (MC13783_MXC || ISP1504_MXC) && USB_GADGET && USB_EHCI_HCD && USB_OTG
+	help
+	  Support for USB OTG PIN detect on MXC platforms.
diff --git a/drivers/usb/otg/Makefile b/drivers/usb/otg/Makefile
new file mode 100644
index 0000000..240018e
--- /dev/null
+++ b/drivers/usb/otg/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for USB OTG controller  driver
+#
+# USB transceiver
+
+ifeq ($(CONFIG_USB_DEBUG),y)
+        EXTRA_CFLAGS            += -DDEBUG
+endif
+
+isp1504_arc-objs		:= fsl_otg.o otg_fsm.o
+obj-$(CONFIG_ISP1504_MXC_OTG)	+= isp1504_arc.o
+obj-$(CONFIG_UTMI_MXC_OTG)	+= isp1504_arc.o
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
new file mode 100644
index 0000000..4e048be
--- /dev/null
+++ b/drivers/usb/otg/fsl_otg.c
@@ -0,0 +1,1215 @@
+/*
+ * Copyright (C) 2005-2008 Freescale semiconductor, Inc.
+ *
+ * Author: Li Yang <LeoLi@freescale.com>
+ *         Jerry Huang <Chang-Ming.Huang@freescale.com>
+ *
+ * Initialization based on code from Shlomi Gridish.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/workqueue.h>
+#include <linux/time.h>
+#include <linux/fsl_devices.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+
+#include "fsl_otg.h"
+
+#define CONFIG_USB_OTG_DEBUG_FILES
+#define DRIVER_VERSION "$Revision: 1.55 $"
+#define DRIVER_AUTHOR "Jerry Huang/Li Yang"
+#define DRIVER_DESC "Freescale USB OTG Driver"
+#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
+
+MODULE_DESCRIPTION("Freescale USB OTG Transceiver Driver");
+
+static const char driver_name[] = "isp1504_arc";
+
+const pm_message_t otg_suspend_state = {
+	.event = 1,
+};
+
+#define HA_DATA_PULSE 1
+
+volatile static struct usb_dr_mmap *usb_dr_regs;
+static struct fsl_otg *fsl_otg_dev;
+static int srp_wait_done;
+
+/* FSM timers */
+struct fsl_otg_timer *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+	*b_ase0_brst_tmr, *b_se0_srp_tmr;
+
+/* Driver specific timers */
+struct fsl_otg_timer *b_data_pulse_tmr, *b_vbus_pulse_tmr, *b_srp_fail_tmr,
+	*b_srp_wait_tmr, *a_wait_enum_tmr;
+
+static struct list_head active_timers;
+
+static struct fsl_otg_config fsl_otg_initdata = {
+	.otg_port = 1,
+};
+
+int write_ulpi(u8 addr, u8 data)
+{
+	u32 temp;
+	temp = 0x60000000 | (addr << 16) | data;
+	temp = cpu_to_le32(temp);
+	usb_dr_regs->ulpiview = temp;
+	return 0;
+}
+
+/* prototype declaration */
+void fsl_otg_add_timer(void *timer);
+void fsl_otg_del_timer(void *timer);
+
+/* -------------------------------------------------------------*/
+/* Operations that will be called from OTG Finite State Machine */
+
+/* Charge vbus for vbus pulsing in SRP */
+void fsl_otg_chrg_vbus(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK &
+				 ~OTGSC_CTRL_VBUS_DISCHARGE) |
+				OTGSC_CTRL_VBUS_CHARGE);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK & ~OTGSC_CTRL_VBUS_CHARGE));
+}
+
+/* Discharge vbus through a resistor to ground */
+void fsl_otg_dischrg_vbus(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK)
+				| OTGSC_CTRL_VBUS_DISCHARGE);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK &
+				 ~OTGSC_CTRL_VBUS_DISCHARGE));
+}
+
+/* A-device driver vbus, controlled through PP bit in PORTSC */
+void fsl_otg_drv_vbus(int on)
+{
+/*	if (on)
+		usb_dr_regs->portsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->portsc) &
+				 ~PORTSC_W1C_BITS) | PORTSC_PORT_POWER);
+	else
+		usb_dr_regs->portsc =
+		    cpu_to_le32(le32_to_cpu(usb_dr_regs->portsc) &
+				~PORTSC_W1C_BITS & ~PORTSC_PORT_POWER);
+*/
+}
+
+/*
+ * Pull-up D+, signalling connect by periperal. Also used in
+ * data-line pulsing in SRP
+ */
+void fsl_otg_loc_conn(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK) | OTGSC_CTRL_DATA_PULSING);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32(le32_to_cpu(usb_dr_regs->otgsc) &
+				~OTGSC_INTSTS_MASK & ~OTGSC_CTRL_DATA_PULSING);
+}
+
+/* Generate SOF by host.  This is controlled through suspend/resume the
+ * port.  In host mode, controller will automatically send SOF.
+ * Suspend will block the data on the port.
+ */
+void fsl_otg_loc_sof(int on)
+{
+	u32 tmpval;
+
+	tmpval = readl(&fsl_otg_dev->dr_mem_map->portsc) & ~PORTSC_W1C_BITS;
+	if (on)
+		tmpval |= PORTSC_PORT_FORCE_RESUME;
+	else
+		tmpval |= PORTSC_PORT_SUSPEND;
+	writel(tmpval, &fsl_otg_dev->dr_mem_map->portsc);
+
+}
+
+/* Start SRP pulsing by data-line pulsing, followed with v-bus pulsing. */
+void fsl_otg_start_pulse(void)
+{
+	srp_wait_done = 0;
+#ifdef HA_DATA_PULSE
+	usb_dr_regs->otgsc =
+	    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK)
+			| OTGSC_HA_DATA_PULSE);
+#else
+	fsl_otg_loc_conn(1);
+#endif
+
+	fsl_otg_add_timer(b_data_pulse_tmr);
+}
+
+void fsl_otg_pulse_vbus(void);
+
+void b_data_pulse_end(unsigned long foo)
+{
+#ifdef HA_DATA_PULSE
+#else
+	fsl_otg_loc_conn(0);
+#endif
+
+	/* Do VBUS pulse after data pulse */
+	fsl_otg_pulse_vbus();
+}
+
+void fsl_otg_pulse_vbus(void)
+{
+	srp_wait_done = 0;
+	fsl_otg_chrg_vbus(1);
+	/* start the timer to end vbus charge */
+	fsl_otg_add_timer(b_vbus_pulse_tmr);
+}
+
+void b_vbus_pulse_end(unsigned long foo)
+{
+	fsl_otg_chrg_vbus(0);
+
+	/* As USB3300 using the same a_sess_vld and b_sess_vld voltage
+	 * we need to discharge the bus for a while to distinguish
+	 * residual voltage of vbus pulsing and A device pull up */
+	fsl_otg_dischrg_vbus(1);
+	fsl_otg_add_timer(b_srp_wait_tmr);
+}
+
+void b_srp_end(unsigned long foo)
+{
+	fsl_otg_dischrg_vbus(0);
+	srp_wait_done = 1;
+
+	if ((fsl_otg_dev->otg.state == OTG_STATE_B_SRP_INIT) &&
+	    fsl_otg_dev->fsm.b_sess_vld)
+		fsl_otg_dev->fsm.b_srp_done = 1;
+}
+
+/* Workaround for a_host suspending too fast.  When a_bus_req=0,
+ * a_host will start by SRP.  It needs to set b_hnp_enable before
+ * actually suspending to start HNP
+ */
+void a_wait_enum(unsigned long foo)
+{
+	VDBG("a_wait_enum timeout\n");
+	if (!fsl_otg_dev->otg.host->b_hnp_enable)
+		fsl_otg_add_timer(a_wait_enum_tmr);
+	else
+		otg_statemachine(&fsl_otg_dev->fsm);
+}
+
+/* ------------------------------------------------------*/
+
+/* The timeout callback function to set time out bit */
+void set_tmout(unsigned long indicator)
+{
+	*(int *)indicator = 1;
+}
+
+/* Initialize timers */
+int fsl_otg_init_timers(struct otg_fsm *fsm)
+{
+	/* FSM used timers */
+	a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
+				(unsigned long)&fsm->a_wait_vrise_tmout);
+	if (a_wait_vrise_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,
+				(unsigned long)&fsm->a_wait_bcon_tmout);
+	if (a_wait_bcon_tmr == NULL)
+		return -ENOMEM;
+
+	a_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
+				(unsigned long)&fsm->a_aidl_bdis_tmout);
+	if (a_aidl_bdis_tmr == NULL)
+		return -ENOMEM;
+
+	b_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,
+				(unsigned long)&fsm->b_ase0_brst_tmout);
+	if (b_ase0_brst_tmr == NULL)
+		return -ENOMEM;
+
+	b_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,
+				(unsigned long)&fsm->b_se0_srp);
+	if (b_se0_srp_tmr == NULL)
+		return -ENOMEM;
+
+	b_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,
+				(unsigned long)&fsm->b_srp_done);
+	if (b_srp_fail_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,
+				(unsigned long)&fsm);
+	if (a_wait_enum_tmr == NULL)
+		return -ENOMEM;
+
+	/* device driver used timers */
+	b_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);
+	if (b_srp_wait_tmr == NULL)
+		return -ENOMEM;
+
+	b_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,
+				TB_DATA_PLS, 0);
+	if (b_data_pulse_tmr == NULL)
+		return -ENOMEM;
+
+	b_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,
+				TB_VBUS_PLS, 0);
+	if (b_vbus_pulse_tmr == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* Uninitialize timers */
+void fsl_otg_uninit_timers(void)
+{
+	/* FSM used timers */
+	if (a_wait_vrise_tmr != NULL)
+		kfree(a_wait_vrise_tmr);
+	if (a_wait_bcon_tmr != NULL)
+		kfree(a_wait_bcon_tmr);
+	if (a_aidl_bdis_tmr != NULL)
+		kfree(a_aidl_bdis_tmr);
+	if (b_ase0_brst_tmr != NULL)
+		kfree(b_ase0_brst_tmr);
+	if (b_se0_srp_tmr != NULL)
+		kfree(b_se0_srp_tmr);
+	if (b_srp_fail_tmr != NULL)
+		kfree(b_srp_fail_tmr);
+	if (a_wait_enum_tmr != NULL)
+		kfree(a_wait_enum_tmr);
+
+	/* device driver used timers */
+	if (b_srp_wait_tmr != NULL)
+		kfree(b_srp_wait_tmr);
+	if (b_data_pulse_tmr != NULL)
+		kfree(b_data_pulse_tmr);
+	if (b_vbus_pulse_tmr != NULL)
+		kfree(b_vbus_pulse_tmr);
+}
+
+/* Add timer to timer list */
+void fsl_otg_add_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer;
+
+	/* Check if the timer is already in the active list,
+	 * if so update timer count
+	 */
+	list_for_each_entry(tmp_timer, &active_timers, list)
+	    if (tmp_timer == timer) {
+		timer->count = timer->expires;
+		return;
+	}
+	timer->count = timer->expires;
+	list_add_tail(&timer->list, &active_timers);
+}
+
+/* Remove timer from the timer list; clear timeout status */
+void fsl_otg_del_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)
+		if (tmp_timer == timer)
+			list_del(&timer->list);
+}
+
+/* Reduce timer count by 1, and find timeout conditions.
+ * Called by fsl_otg 1ms timer interrupt
+ */
+int fsl_otg_tick_timer(void)
+{
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+	int expired = 0;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {
+		tmp_timer->count--;
+		/* check if timer expires */
+		if (!tmp_timer->count) {
+			list_del(&tmp_timer->list);
+			tmp_timer->function(tmp_timer->data);
+			expired = 1;
+		}
+	}
+
+	return expired;
+}
+
+/* Reset controller, not reset the bus */
+void otg_reset_controller(void)
+{
+	u32 command;
+
+	command = readl(&usb_dr_regs->usbcmd);
+	command |= (1 << 1);
+	writel(command, &usb_dr_regs->usbcmd);
+	while (readl(&usb_dr_regs->usbcmd) & (1 << 1)) ;
+}
+
+/* Call suspend/resume routines in host driver */
+int fsl_otg_start_host(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *dev;
+	struct fsl_otg *otg_dev = container_of(xceiv, struct fsl_otg, otg);
+	u32 retval = 0;
+
+	if (!xceiv->host)
+		return -ENODEV;
+	dev = xceiv->host->controller;
+
+	/* Update a_vbus_vld state as a_vbus_vld int is disabled
+	 * in device mode
+	 */
+	fsm->a_vbus_vld =
+	    (le32_to_cpu(usb_dr_regs->otgsc) & OTGSC_STS_A_VBUS_VALID) ? 1 : 0;
+	if (on) {
+		/* start fsl usb host controller */
+		if (otg_dev->host_working)
+			goto end;
+		else {
+			otg_reset_controller();
+			VDBG("host on......\n");
+			if (dev->driver->resume) {
+				retval = dev->driver->resume(dev);
+				if (fsm->id) {
+					/* default-b */
+					fsl_otg_drv_vbus(1);
+					/* Workaround: b_host can't driver
+					 * vbus, but PP in PORTSC needs to
+					 * be 1 for host to work.
+					 * So we set drv_vbus bit in
+					 * transceiver to 0 thru ULPI. */
+#if defined(CONFIG_ISP1504_MXC)
+					write_ulpi(0x0c, 0x20);
+#endif
+				}
+			}
+
+			otg_dev->host_working = 1;
+		}
+	} else {
+		/* stop fsl usb host controller */
+		if (!otg_dev->host_working)
+			goto end;
+		else {
+			VDBG("host off......\n");
+			if (dev && dev->driver) {
+				retval = dev->driver->suspend(dev,
+							otg_suspend_state);
+				if (fsm->id)
+					/* default-b */
+					fsl_otg_drv_vbus(0);
+			}
+			otg_dev->host_working = 0;
+		}
+	}
+end:
+	return retval;
+}
+
+/* Call suspend and resume function in udc driver
+ * to stop and start udc driver.
+ */
+int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *dev;
+
+	if (!xceiv->gadget || !xceiv->gadget->dev.parent)
+		return -ENODEV;
+
+	VDBG("gadget %s \n", on ? "on" : "off");
+	dev = xceiv->gadget->dev.parent;
+
+	if (on)
+		dev->driver->resume(dev);
+	else
+		dev->driver->suspend(dev, otg_suspend_state);
+
+	return 0;
+}
+
+/* Called by initialization code of host driver.  Register host controller
+ * to the OTG.  Suspend host for OTG role detection.
+ */
+static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	otg_p->host = host;
+
+	otg_dev->fsm.a_bus_drop = 0;
+	otg_dev->fsm.a_bus_req = 1;
+
+	if (host) {
+		VDBG("host off......\n");
+
+		otg_p->host->otg_port = fsl_otg_initdata.otg_port;
+		otg_p->host->is_b_host = otg_dev->fsm.id;
+		/* must leave time for khubd to finish its thing
+		 * before yanking the host driver out from under it,
+		 * so suspend the host after a short delay.
+		 */
+		otg_dev->host_working = 1;
+		schedule_delayed_work(&otg_dev->otg_event, 100);
+		return 0;
+	} else {		/* host driver going away */
+
+		if (!(le32_to_cpu(otg_dev->dr_mem_map->otgsc) &
+		      OTGSC_STS_USB_ID)) {
+			/* Mini-A cable connected */
+			struct otg_fsm *fsm = &otg_dev->fsm;
+
+			otg_p->state = OTG_STATE_UNDEFINED;
+			fsm->protocol = PROTO_UNDEF;
+		}
+	}
+
+	otg_dev->host_working = 0;
+
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/* Called by initialization code of udc.  Register udc to OTG.*/
+static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
+				  struct usb_gadget *gadget)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	VDBG("otg_dev 0x%x\n", (int)otg_dev);
+	VDBG("fsl_otg_dev 0x%x\n", (int)fsl_otg_dev);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	if (!gadget) {
+		if (!otg_dev->otg.default_a)
+			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
+		usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+		otg_dev->otg.gadget = 0;
+		otg_dev->fsm.b_bus_req = 0;
+		otg_statemachine(&otg_dev->fsm);
+		return 0;
+	}
+#ifdef DEBUG
+	/*
+	 * debug the initial state of the ID pin when only
+	 * the gadget driver is loaded and no cable is connected.
+	 * sometimes, we get an ID irq right
+	 * after the udc driver's otg_get_transceiver() call
+	 * that indicates that IDpin=0, which means a Mini-A
+	 * connector is attached.  not good.
+	 */
+	DBG("before: fsm.id ID pin=%d", otg_dev->fsm.id);
+	otg_dev->fsm.id = (otg_dev->dr_mem_map->otgsc & OTGSC_STS_USB_ID) ?
+	    1 : 0;
+	DBG("after:  fsm.id ID pin=%d", otg_dev->fsm.id);
+	/*if (!otg_dev->fsm.id) {
+	   printk("OTG Control = 0x%x\n",
+	   isp1504_read(ISP1504_OTGCTL,
+	   &otg_dev->dr_mem_map->ulpiview));
+	   } */
+#endif
+
+	otg_p->gadget = gadget;
+	otg_p->gadget->is_a_peripheral = !otg_dev->fsm.id;
+
+	otg_dev->fsm.b_bus_req = 1;
+
+	/* start the gadget right away if the ID pin says Mini-B */
+	DBG("ID pin=%d\n", otg_dev->fsm.id);
+	if (otg_dev->fsm.id == 1) {
+		fsl_otg_start_host(&otg_dev->fsm, 0);
+		otg_drv_vbus(&otg_dev->fsm, 0);
+		fsl_otg_start_gadget(&otg_dev->fsm, 1);
+	}
+
+	return 0;
+}
+
+/* Set OTG port power, only for B-device */
+static int fsl_otg_set_power(struct otg_transceiver *otg_p, unsigned mA)
+{
+	if (!fsl_otg_dev)
+		return -ENODEV;
+	if (otg_p->state == OTG_STATE_B_PERIPHERAL)
+		printk(KERN_INFO "FSL OTG:Draw %d mA\n", mA);
+
+	return 0;
+}
+
+/* Delayed pin detect interrupt processing.
+ *
+ * When the Mini-A cable is disconnected from the board,
+ * the pin-detect interrupt happens before the disconnnect
+ * interrupts for the connected device(s).  In order to
+ * process the disconnect interrupt(s) prior to switching
+ * roles, the pin-detect interrupts are delayed, and handled
+ * by this routine.
+ */
+static void fsl_otg_event(struct work_struct *work)
+{
+	struct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);
+	struct otg_fsm *fsm = &og->fsm;
+
+	if (fsm->id) {		/* switch to gadget */
+		fsl_otg_start_host(fsm, 0);
+		otg_drv_vbus(fsm, 0);
+		fsl_otg_start_gadget(fsm, 1);
+	}
+#ifdef CONFIG_ARCH_MX51
+	else {			/* switch to host */
+		fsl_otg_start_gadget(fsm, 0);
+		otg_drv_vbus(fsm, 1);
+		fsl_otg_start_host(fsm, 1);
+	}
+#endif
+}
+
+/* B-device start SRP */
+static int fsl_otg_start_srp(struct otg_transceiver *otg_p)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev
+	    || otg_p->state != OTG_STATE_B_IDLE)
+		return -ENODEV;
+
+	otg_dev->fsm.b_bus_req = 1;
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/* A_host suspend will call this function to start hnp */
+static int fsl_otg_start_hnp(struct otg_transceiver *otg_p)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	/* printk("start_hnp.............\n"); */
+	/* clear a_bus_req to enter a_suspend state */
+	otg_dev->fsm.a_bus_req = 0;
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/* Interrupt handler.  OTG/host/peripheral share the same int line.
+ * OTG driver clears OTGSC interrupts and leaves USB interrupts
+ * intact.  It needs to have knowledge of some USB interrupts
+ * such as port change.
+ */
+irqreturn_t fsl_otg_isr(int irq, void *dev_id)
+{
+	struct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;
+	struct otg_transceiver *otg = &((struct fsl_otg *)dev_id)->otg;
+	u32 otg_int_src, otg_sc;
+
+	otg_sc = le32_to_cpu(usb_dr_regs->otgsc);
+	otg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);
+
+	/* Only clear otg interrupts */
+	usb_dr_regs->otgsc |= cpu_to_le32(otg_sc & OTGSC_INTSTS_MASK);
+
+	/*FIXME: ID change not generate when init to 0 */
+	fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+	otg->default_a = (fsm->id == 0);
+
+	/* process OTG interrupts */
+	if (otg_int_src) {
+		if (otg_int_src & OTGSC_INTSTS_USB_ID) {
+			fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+			otg->default_a = (fsm->id == 0);
+			/* clear conn information */
+			if (fsm->id)
+				fsm->b_conn = 0;
+			else
+				fsm->a_conn = 0;
+
+			if (otg->host)
+				otg->host->is_b_host = fsm->id;
+			if (otg->gadget)
+				otg->gadget->is_a_peripheral = !fsm->id;
+			VDBG("ID int (ID is %d)\n", fsm->id);
+
+			if (fsm->id) {	/* switch to gadget */
+				schedule_delayed_work(&((struct fsl_otg *)
+							dev_id)->otg_event,
+							100);
+			} else {	/* switch to host */
+#ifndef CONFIG_ARCH_MX51
+				cancel_delayed_work(&
+						    ((struct fsl_otg *)dev_id)->
+						    otg_event);
+				fsl_otg_start_gadget(fsm, 0);
+				otg_drv_vbus(fsm, 1);
+				fsl_otg_start_host(fsm, 1);
+#else
+				schedule_delayed_work(&((struct fsl_otg *)
+							dev_id)->otg_event,
+							100);
+#endif
+			}
+
+			return IRQ_HANDLED;
+		}
+	}
+
+	return IRQ_NONE;
+}
+
+static struct otg_fsm_ops fsl_otg_ops = {
+	.chrg_vbus = fsl_otg_chrg_vbus,
+	.drv_vbus = fsl_otg_drv_vbus,
+	.loc_conn = fsl_otg_loc_conn,
+	.loc_sof = fsl_otg_loc_sof,
+	.start_pulse = fsl_otg_start_pulse,
+
+	.add_timer = fsl_otg_add_timer,
+	.del_timer = fsl_otg_del_timer,
+
+	.start_host = fsl_otg_start_host,
+	.start_gadget = fsl_otg_start_gadget,
+};
+
+/* Initialize the global variable fsl_otg_dev and request IRQ for OTG */
+static int fsl_otg_conf(struct platform_device *pdev)
+{
+	int status;
+	struct fsl_otg *fsl_otg_tc;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+
+	DBG();
+
+	if (fsl_otg_dev)
+		return 0;
+
+	/* allocate space to fsl otg device */
+	fsl_otg_tc = kzalloc(sizeof(struct fsl_otg), GFP_KERNEL);
+	if (!fsl_otg_tc)
+		return -ENODEV;
+
+	INIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);
+
+	INIT_LIST_HEAD(&active_timers);
+	status = fsl_otg_init_timers(&fsl_otg_tc->fsm);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG timers\n");
+		fsl_otg_uninit_timers();
+		kfree(fsl_otg_tc);
+		return status;
+	}
+	spin_lock_init(&fsl_otg_tc->fsm.lock);
+
+	/* Set OTG state machine operations */
+	fsl_otg_tc->fsm.ops = &fsl_otg_ops;
+
+	/* initialize the otg structure */
+	fsl_otg_tc->otg.label = DRIVER_DESC;
+	fsl_otg_tc->otg.set_host = fsl_otg_set_host;
+	fsl_otg_tc->otg.set_peripheral = fsl_otg_set_peripheral;
+	fsl_otg_tc->otg.set_power = fsl_otg_set_power;
+	fsl_otg_tc->otg.start_hnp = fsl_otg_start_hnp;
+	fsl_otg_tc->otg.start_srp = fsl_otg_start_srp;
+
+	fsl_otg_dev = fsl_otg_tc;
+
+	/* Store the otg transceiver */
+	status = otg_set_transceiver(&fsl_otg_tc->otg);
+	if (status) {
+		printk(KERN_WARNING ": unable to register OTG transceiver.\n");
+		return status;
+	}
+
+	return 0;
+}
+
+/* OTG Initialization*/
+int usb_otg_start(struct platform_device *pdev)
+{
+	struct fsl_otg *p_otg;
+	struct otg_transceiver *otg_trans = otg_get_transceiver();
+	struct otg_fsm *fsm;
+	volatile unsigned long *p;
+	int status;
+	struct resource *res;
+	u32 temp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	p_otg = container_of(otg_trans, struct fsl_otg, otg);
+	fsm = &p_otg->fsm;
+
+	/* Initialize the state machine structure with default values */
+	SET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);
+	fsm->transceiver = &p_otg->otg;
+
+	/* We don't require predefined MEM/IRQ resource index */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	/* We don't request_mem_region here to enable resource sharing
+	 * with host/device */
+
+	usb_dr_regs = ioremap(res->start, sizeof(struct usb_dr_mmap));
+	p_otg->dr_mem_map = (struct usb_dr_mmap *)usb_dr_regs;
+	pdata->regs = (void *)usb_dr_regs;
+
+	/* request irq */
+	p_otg->irq = platform_get_irq(pdev, 0);
+	status = request_irq(p_otg->irq, fsl_otg_isr,
+				IRQF_SHARED, driver_name, p_otg);
+	if (status) {
+		dev_dbg(p_otg->otg.dev, "can't get IRQ %d, error %d\n",
+			p_otg->irq, status);
+		iounmap(p_otg->dr_mem_map);
+		kfree(p_otg);
+		return status;
+	}
+
+	if (pdata->platform_init && pdata->platform_init(pdev) != 0) {
+		free_irq(p_otg->irq, p_otg);
+		return -EINVAL;
+	}
+
+	/* stop the controller */
+	temp = readl(&p_otg->dr_mem_map->usbcmd);
+	temp &= ~USB_CMD_RUN_STOP;
+	writel(temp, &p_otg->dr_mem_map->usbcmd);
+
+	/* reset the controller */
+	temp = readl(&p_otg->dr_mem_map->usbcmd);
+	temp |= USB_CMD_CTRL_RESET;
+	writel(temp, &p_otg->dr_mem_map->usbcmd);
+
+	/* wait reset completed */
+	while (readl(&p_otg->dr_mem_map->usbcmd) & USB_CMD_CTRL_RESET) ;
+
+	/* configure the VBUSHS as IDLE(both host and device) */
+	temp = USB_MODE_STREAM_DISABLE | (pdata->es ? USB_MODE_ES : 0);
+	writel(temp, &p_otg->dr_mem_map->usbmode);
+
+	/* configure PHY interface */
+	temp = readl(&p_otg->dr_mem_map->portsc);
+	temp &= ~(PORTSC_PHY_TYPE_SEL | PORTSC_PTW);
+	switch (pdata->phy_mode) {
+	case FSL_USB2_PHY_ULPI:
+		temp |= PORTSC_PTS_ULPI;
+		break;
+	case FSL_USB2_PHY_UTMI_WIDE:
+		temp |= PORTSC_PTW_16BIT;
+		/* fall through */
+	case FSL_USB2_PHY_UTMI:
+		temp |= PORTSC_PTS_UTMI;
+		/* fall through */
+	default:
+		break;
+	}
+	writel(temp, &p_otg->dr_mem_map->portsc);
+
+	if (pdata->have_sysif_regs) {
+		/* configure control enable IO output, big endian register */
+		p = (volatile unsigned long *)(&p_otg->dr_mem_map->control);
+		temp = *p;
+		temp |= USB_CTRL_IOENB;
+		*p = temp;
+	}
+
+	/* disable all interrupt and clear all OTGSC status */
+	temp = readl(&p_otg->dr_mem_map->otgsc);
+	temp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+	temp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;
+	writel(temp, &p_otg->dr_mem_map->otgsc);
+
+
+	/*
+	 * The identification (id) input is FALSE when a Mini-A plug is inserted
+	 * in the devices Mini-AB receptacle. Otherwise, this input is TRUE.
+	 * Also: record initial state of ID pin
+	 */
+	if (le32_to_cpu(p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID) {
+		p_otg->otg.state = OTG_STATE_UNDEFINED;
+		p_otg->fsm.id = 1;
+	} else {
+		p_otg->otg.state = OTG_STATE_A_IDLE;
+		p_otg->fsm.id = 0;
+	}
+
+	DBG("initial ID pin=%d\n", p_otg->fsm.id);
+
+	/* enable OTG ID pin interrupt */
+	temp = readl(&p_otg->dr_mem_map->otgsc);
+	temp |= OTGSC_INTR_USB_ID_EN;
+	temp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_INTR_1MS_TIMER_EN);
+	writel(temp, &p_otg->dr_mem_map->otgsc);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_OTG_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/isp1504_otg";
+
+static int otg_proc_read(char *page, char **start, off_t off, int count,
+			 int *eof, void *_dev)
+{
+	struct otg_fsm *fsm = &fsl_otg_dev->fsm;
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+	u32 tmp_reg;
+
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	/* ------basic driver infomation ---- */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n" "fsl_usb2_otg version: %s\n\n",
+		      DRIVER_VERSION);
+	size -= t;
+	next += t;
+
+	/* ------ Registers ----- */
+	tmp_reg = le32_to_cpu(usb_dr_regs->otgsc);
+	t = scnprintf(next, size, "OTGSC reg: %08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->portsc);
+	t = scnprintf(next, size, "PORTSC reg: %08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbmode);
+	t = scnprintf(next, size, "USBMODE reg: %08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbcmd);
+	t = scnprintf(next, size, "USBCMD reg: %08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbsts);
+	t = scnprintf(next, size, "USBSTS reg: %08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* ------ State ----- */
+	t = scnprintf(next, size,
+		      "OTG state: %s\n\n",
+		      state_string(fsl_otg_dev->otg.state));
+	size -= t;
+	next += t;
+
+#if 1 || defined DEBUG
+	/* ------ State Machine Variables ----- */
+	t = scnprintf(next, size, "a_bus_req: %d\n", fsm->a_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_req: %d\n", fsm->b_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_resume: %d\n", fsm->a_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_suspend: %d\n", fsm->a_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_conn: %d\n", fsm->a_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_sess_vld: %d\n", fsm->a_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_srp_det: %d\n", fsm->a_srp_det);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_vbus_vld: %d\n", fsm->a_vbus_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_resume: %d\n", fsm->b_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_suspend: %d\n", fsm->b_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_conn: %d\n", fsm->b_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_se0_srp: %d\n", fsm->b_se0_srp);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_end: %d\n", fsm->b_sess_end);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_vld: %d\n", fsm->b_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "id: %d\n", fsm->id);
+	size -= t;
+	next += t;
+#endif
+
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, otg_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_OTG_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/*CONFIG_USB_OTG_DEBUG_FILES */
+
+/*----------------------------------------------------------*/
+/* Char driver interface to control some OTG input */
+
+/* This function handle some ioctl command,such as get otg
+ * status and set host suspend
+ */
+static int fsl_otg_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	u32 retval = 0;
+
+	switch (cmd) {
+	case GET_OTG_STATUS:
+		retval = fsl_otg_dev->host_working;
+		break;
+
+	case SET_A_SUSPEND_REQ:
+		fsl_otg_dev->fsm.a_suspend_req = arg;
+		break;
+
+	case SET_A_BUS_DROP:
+		fsl_otg_dev->fsm.a_bus_drop = arg;
+		break;
+
+	case SET_A_BUS_REQ:
+		fsl_otg_dev->fsm.a_bus_req = arg;
+		break;
+
+	case SET_B_BUS_REQ:
+		fsl_otg_dev->fsm.b_bus_req = arg;
+		break;
+
+	default:
+		break;
+	}
+
+	otg_statemachine(&fsl_otg_dev->fsm);
+
+	return retval;
+}
+
+static int fsl_otg_open(struct inode *inode, struct file *file)
+{
+
+	return 0;
+}
+
+static int fsl_otg_release(struct inode *inode, struct file *file)
+{
+
+	return 0;
+}
+
+static struct file_operations otg_fops = {
+	.owner = THIS_MODULE,
+	.llseek = NULL,
+	.read = NULL,
+	.write = NULL,
+	.ioctl = fsl_otg_ioctl,
+	.open = fsl_otg_open,
+	.release = fsl_otg_release,
+};
+
+static int __init fsl_otg_probe(struct platform_device *pdev)
+{
+	int status;
+	struct fsl_usb2_platform_data *pdata;
+
+	DBG("pdev=0x%p\n", pdev);
+
+	if (!pdev)
+		return -ENODEV;
+
+	if (!pdev->dev.platform_data)
+		return -ENOMEM;
+
+	pdata = pdev->dev.platform_data;
+
+	/* configure the OTG */
+	status = fsl_otg_conf(pdev);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG module\n");
+		return -status;
+	}
+
+	/* start OTG */
+	status = usb_otg_start(pdev);
+
+	if (register_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME, &otg_fops)) {
+		printk(KERN_WARNING FSL_OTG_NAME
+		       ": unable to register FSL OTG device\n");
+		return -EIO;
+	}
+
+	create_proc_file();
+	return status;
+}
+
+static int fsl_otg_remove(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	otg_set_transceiver(NULL);
+	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
+
+	iounmap((void *)usb_dr_regs);
+
+	kfree(fsl_otg_dev);
+
+	remove_proc_file();
+
+	unregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);
+
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+
+	return 0;
+}
+
+struct platform_driver fsl_otg_driver = {
+	.probe = fsl_otg_probe,
+	.remove = fsl_otg_remove,
+	.driver = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+	},
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init fsl_usb_otg_init(void)
+{
+	printk(KERN_INFO DRIVER_DESC " loaded, %s\n", DRIVER_VERSION);
+	return platform_driver_register(&fsl_otg_driver);
+}
+
+static void __exit fsl_usb_otg_exit(void)
+{
+	platform_driver_unregister(&fsl_otg_driver);
+	printk(KERN_INFO DRIVER_DESC " unloaded\n");
+}
+
+#ifdef CONFIG_ARCH_MX51
+subsys_initcall(fsl_usb_otg_init);
+#else
+module_init(fsl_usb_otg_init);
+#endif
+module_exit(fsl_usb_otg_exit);
+
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/otg/fsl_otg.h b/drivers/usb/otg/fsl_otg.h
new file mode 100644
index 0000000..c358045
--- /dev/null
+++ b/drivers/usb/otg/fsl_otg.h
@@ -0,0 +1,410 @@
+/* Copyright (C) 2005-2008 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "otg_fsm.h"
+#include <linux/usb/otg.h>
+#include <linux/ioctl.h>
+
+ /* USB Command  Register Bit Masks */
+#define USB_CMD_RUN_STOP		(0x1<<0  )
+#define USB_CMD_CTRL_RESET		(0x1<<1  )
+#define USB_CMD_PERIODIC_SCHEDULE_EN	(0x1<<4  )
+#define USB_CMD_ASYNC_SCHEDULE_EN	(0x1<<5  )
+#define USB_CMD_INT_AA_DOORBELL		(0x1<<6  )
+#define USB_CMD_ASP			(0x3<<8  )
+#define USB_CMD_ASYNC_SCH_PARK_EN	(0x1<<11 )
+#define USB_CMD_SUTW			(0x1<<13 )
+#define USB_CMD_ATDTW			(0x1<<14 )
+#define USB_CMD_ITC			(0xFF<<16)
+
+/* bit 15,3,2 are frame list size */
+#define USB_CMD_FRAME_SIZE_1024		(0x0<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_512		(0x0<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_256		(0x0<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_128		(0x0<<15 | 0x3<<2)
+#define USB_CMD_FRAME_SIZE_64		(0x1<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_32		(0x1<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_16		(0x1<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_8		(0x1<<15 | 0x3<<2)
+
+/* bit 9-8 are async schedule park mode count */
+#define USB_CMD_ASP_00			(0x0<<8)
+#define USB_CMD_ASP_01			(0x1<<8)
+#define USB_CMD_ASP_10			(0x2<<8)
+#define USB_CMD_ASP_11			(0x3<<8)
+#define USB_CMD_ASP_BIT_POS		(8)
+
+/* bit 23-16 are interrupt threshold control */
+#define USB_CMD_ITC_NO_THRESHOLD	(0x00<<16)
+#define USB_CMD_ITC_1_MICRO_FRM		(0x01<<16)
+#define USB_CMD_ITC_2_MICRO_FRM		(0x02<<16)
+#define USB_CMD_ITC_4_MICRO_FRM		(0x04<<16)
+#define USB_CMD_ITC_8_MICRO_FRM		(0x08<<16)
+#define USB_CMD_ITC_16_MICRO_FRM	(0x10<<16)
+#define USB_CMD_ITC_32_MICRO_FRM	(0x20<<16)
+#define USB_CMD_ITC_64_MICRO_FRM	(0x40<<16)
+#define USB_CMD_ITC_BIT_POS		(16)
+
+/* USB Status Register Bit Masks */
+#define USB_STS_INT			(0x1<<0 )
+#define USB_STS_ERR			(0x1<<1 )
+#define USB_STS_PORT_CHANGE		(0x1<<2 )
+#define USB_STS_FRM_LST_ROLL		(0x1<<3 )
+#define USB_STS_SYS_ERR			(0x1<<4 )
+#define USB_STS_IAA			(0x1<<5 )
+#define USB_STS_RESET_RECEIVED		(0x1<<6 )
+#define USB_STS_SOF			(0x1<<7 )
+#define USB_STS_DCSUSPEND		(0x1<<8 )
+#define USB_STS_HC_HALTED		(0x1<<12)
+#define USB_STS_RCL			(0x1<<13)
+#define USB_STS_PERIODIC_SCHEDULE	(0x1<<14)
+#define USB_STS_ASYNC_SCHEDULE		(0x1<<15)
+
+/* USB Interrupt Enable Register Bit Masks */
+#define USB_INTR_INT_EN			(0x1<<0 )
+#define USB_INTR_ERR_INT_EN		(0x1<<1 )
+#define USB_INTR_PC_DETECT_EN		(0x1<<2 )
+#define USB_INTR_FRM_LST_ROLL_EN	(0x1<<3 )
+#define USB_INTR_SYS_ERR_EN		(0x1<<4 )
+#define USB_INTR_ASYN_ADV_EN		(0x1<<5 )
+#define USB_INTR_RESET_EN		(0x1<<6 )
+#define USB_INTR_SOF_EN			(0x1<<7 )
+#define USB_INTR_DEVICE_SUSPEND		(0x1<<8 )
+
+/* Device Address bit masks */
+#define USB_DEVICE_ADDRESS_MASK		(0x7F<<25)
+#define USB_DEVICE_ADDRESS_BIT_POS	(25)
+/* PORTSC  Register Bit Masks,Only one PORT in OTG mode*/
+#define PORTSC_CURRENT_CONNECT_STATUS	(0x1<<0)
+#define PORTSC_CONNECT_STATUS_CHANGE	(0x1<<1)
+#define PORTSC_PORT_ENABLE		(0x1<<2)
+#define PORTSC_PORT_EN_DIS_CHANGE	(0x1<<3)
+#define PORTSC_OVER_CURRENT_ACT		(0x1<<4)
+#define PORTSC_OVER_CUURENT_CHG		(0x1<<5)
+#define PORTSC_PORT_FORCE_RESUME	(0x1<<6)
+#define PORTSC_PORT_SUSPEND		(0x1<<7)
+#define PORTSC_PORT_RESET		(0x1<<8)
+#define PORTSC_LINE_STATUS_BITS		(0x3<<10)
+#define PORTSC_PORT_POWER		(0x1<<12)
+#define PORTSC_PORT_INDICTOR_CTRL	(0x3<<14)
+#define PORTSC_PORT_TEST_CTRL		(0xF<<16)
+#define PORTSC_WAKE_ON_CONNECT_EN	(0x1<<20)
+#define PORTSC_WAKE_ON_CONNECT_DIS	(0x1<<21)
+#define PORTSC_WAKE_ON_OVER_CURRENT	(0x1<<22)
+#define PORTSC_PHY_LOW_POWER_SPD	(0x1<<23)
+#define PORTSC_PORT_FORCE_FULL_SPEED	(0x1<<24)
+#define PORTSC_PORT_SPEED_MASK		(0x3<<26)
+#define PORTSC_TRANSCEIVER_WIDTH	(0x1<<28)
+#define PORTSC_PHY_TYPE_SEL		(0x3<<30)
+/* bit 11-10 are line status */
+#define PORTSC_LINE_STATUS_SE0		(0x0<<10)
+#define PORTSC_LINE_STATUS_JSTATE	(0x1<<10)
+#define PORTSC_LINE_STATUS_KSTATE	(0x2<<10)
+#define PORTSC_LINE_STATUS_UNDEF	(0x3<<10)
+#define PORTSC_LINE_STATUS_BIT_POS	(10)
+
+/* bit 15-14 are port indicator control */
+#define PORTSC_PIC_OFF			(0x0<<14)
+#define PORTSC_PIC_AMBER		(0x1<<14)
+#define PORTSC_PIC_GREEN		(0x2<<14)
+#define PORTSC_PIC_UNDEF		(0x3<<14)
+#define PORTSC_PIC_BIT_POS		(14)
+
+/* bit 19-16 are port test control */
+#define PORTSC_PTC_DISABLE		(0x0<<16)
+#define PORTSC_PTC_JSTATE		(0x1<<16)
+#define PORTSC_PTC_KSTATE		(0x2<<16)
+#define PORTSC_PTC_SEQNAK		(0x3<<16)
+#define PORTSC_PTC_PACKET		(0x4<<16)
+#define PORTSC_PTC_FORCE_EN		(0x5<<16)
+#define PORTSC_PTC_BIT_POS		(16)
+
+/* bit 27-26 are port speed */
+#define PORTSC_PORT_SPEED_FULL		(0x0<<26)
+#define PORTSC_PORT_SPEED_LOW		(0x1<<26)
+#define PORTSC_PORT_SPEED_HIGH		(0x2<<26)
+#define PORTSC_PORT_SPEED_UNDEF		(0x3<<26)
+#define PORTSC_SPEED_BIT_POS		(26)
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define PORTSC_PTW			(0x1<<28)
+#define PORTSC_PTW_8BIT			(0x0<<28)
+#define PORTSC_PTW_16BIT		(0x1<<28)
+
+/* bit 31-30 are port transceiver select */
+#define PORTSC_PTS_UTMI			(0x0<<30)
+#define PORTSC_PTS_ULPI			(0x2<<30)
+#define PORTSC_PTS_FSLS_SERIAL		(0x3<<30)
+#define PORTSC_PTS_BIT_POS		(30)
+
+#define PORTSC_W1C_BITS                    \
+       (PORTSC_CONNECT_STATUS_CHANGE |     \
+	PORTSC_PORT_EN_DIS_CHANGE    |     \
+	PORTSC_OVER_CUURENT_CHG)
+
+/* OTG Status Control Register Bit Masks */
+#define OTGSC_CTRL_VBUS_DISCHARGE	(0x1<<0)
+#define OTGSC_CTRL_VBUS_CHARGE		(0x1<<1)
+#define OTGSC_CTRL_OTG_TERMINATION	(0x1<<3)
+#define OTGSC_CTRL_DATA_PULSING		(0x1<<4)
+#define OTGSC_CTRL_ID_PULL_EN		(0x1<<5)
+#define OTGSC_HA_DATA_PULSE		(0x1<<6)
+#define OTGSC_HA_BA			(0x1<<7)
+#define OTGSC_STS_USB_ID		(0x1<<8)
+#define OTGSC_STS_A_VBUS_VALID		(0x1<<9)
+#define OTGSC_STS_A_SESSION_VALID	(0x1<<10)
+#define OTGSC_STS_B_SESSION_VALID	(0x1<<11)
+#define OTGSC_STS_B_SESSION_END		(0x1<<12)
+#define OTGSC_STS_1MS_TOGGLE		(0x1<<13)
+#define OTGSC_STS_DATA_PULSING		(0x1<<14)
+#define OTGSC_INTSTS_USB_ID		(0x1<<16)
+#define OTGSC_INTSTS_A_VBUS_VALID	(0x1<<17)
+#define OTGSC_INTSTS_A_SESSION_VALID	(0x1<<18)
+#define OTGSC_INTSTS_B_SESSION_VALID	(0x1<<19)
+#define OTGSC_INTSTS_B_SESSION_END	(0x1<<20)
+#define OTGSC_INTSTS_1MS		(0x1<<21)
+#define OTGSC_INTSTS_DATA_PULSING	(0x1<<22)
+#define OTGSC_INTR_USB_ID_EN		(0x1<<24)
+#define OTGSC_INTR_A_VBUS_VALID_EN	(0x1<<25)
+#define OTGSC_INTR_A_SESSION_VALID_EN	(0x1<<26)
+#define OTGSC_INTR_B_SESSION_VALID_EN	(0x1<<27)
+#define OTGSC_INTR_B_SESSION_END_EN	(0x1<<28)
+#define OTGSC_INTR_1MS_TIMER_EN		(0x1<<29)
+#define OTGSC_INTR_DATA_PULSING_EN	(0x1<<30)
+#define OTGSC_INTSTS_MASK		(0x00ff0000)
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE	(0x0<<0)
+#define  USB_MODE_CTRL_MODE_DEVICE	(0x2<<0)
+#define  USB_MODE_CTRL_MODE_HOST	(0x3<<0)
+#define  USB_MODE_CTRL_MODE_RSV		(0x1<<0)
+#define  USB_MODE_SETUP_LOCK_OFF	(0x1<<3)
+#define  USB_MODE_STREAM_DISABLE	(0x1<<4)
+#define  USB_MODE_ES			(0x1<<2) /* (big) Endian Select */
+
+#define MPC8349_OTG_IRQ			(38)
+#define CFG_IMMR_BASE	        	(0xfe000000)
+#define MPC83xx_USB_DR_BASE     	(CFG_IMMR_BASE + 0x23000)
+
+/* control Register Bit Masks */
+#define  USB_CTRL_IOENB			(0x1<<2)
+#define  USB_CTRL_ULPI_INT0EN		(0x1<<0)
+
+/* BCSR5 */
+#define BCSR5_INT_USB			(0x02)
+
+/* USB module clk cfg */
+#define SCCR_OFFS			(0xA08)
+#define SCCR_USB_CLK_DISABLE		(0x00000000)	/* USB clk disable */
+#define SCCR_USB_MPHCM_11		(0x00c00000)
+#define SCCR_USB_MPHCM_01		(0x00400000)
+#define SCCR_USB_MPHCM_10		(0x00800000)
+#define SCCR_USB_DRCM_11		(0x00300000)
+#define SCCR_USB_DRCM_01		(0x00100000)
+#define SCCR_USB_DRCM_10		(0x00200000)
+
+#define SICRL_OFFS			(0x114)
+#define SICRL_USB0			(0x40000000)
+#define SICRL_USB1			(0x20000000)
+
+#define SICRH_OFFS			(0x118)
+#define SICRH_USB_UTMI			(0x00020000)
+
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK  \
+	(OTGSC_INTR_USB_ID_EN            | \
+	OTGSC_INTR_1MS_TIMER_EN          | \
+	OTGSC_INTR_A_VBUS_VALID_EN       | \
+	OTGSC_INTR_A_SESSION_VALID_EN    | \
+	OTGSC_INTR_B_SESSION_VALID_EN    | \
+	OTGSC_INTR_B_SESSION_END_EN      | \
+	OTGSC_INTR_DATA_PULSING_EN)
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK  \
+	(OTGSC_INTSTS_USB_ID          |    \
+	OTGSC_INTR_1MS_TIMER_EN       |    \
+	OTGSC_INTSTS_A_VBUS_VALID     |    \
+	OTGSC_INTSTS_A_SESSION_VALID  |    \
+	OTGSC_INTSTS_B_SESSION_VALID  |    \
+	OTGSC_INTSTS_B_SESSION_END    |    \
+	OTGSC_INTSTS_DATA_PULSING)
+
+/*
+ *  A-DEVICE timing  constants
+ */
+
+/* Wait for VBUS Rise  */
+#define TA_WAIT_VRISE	(100)	/* a_wait_vrise 100 ms, section: 6.6.5.1 */
+
+/* Wait for B-Connect */
+#define TA_WAIT_BCON	(10000)  /* a_wait_bcon > 1 sec, section: 6.6.5.2
+				  * This is only used to get out of
+				  * OTG_STATE_A_WAIT_BCON state if there was
+				  * no connection for these many milliseconds
+				  */
+
+/* A-Idle to B-Disconnect */
+/* It is necessary for this timer to be more than 750 ms because of a bug in OPT
+ * test 5.4 in which B OPT disconnects after 750 ms instead of 75ms as stated
+ * in the test description
+ */
+#define TA_AIDL_BDIS	(5000)	/* a_suspend minimum 200 ms, section: 6.6.5.3 */
+
+/* B-Idle to A-Disconnect */
+#define TA_BIDL_ADIS	(12)	/* 3 to 200 ms */
+
+/* B-device timing constants */
+
+
+/* Data-Line Pulse Time*/
+#define TB_DATA_PLS	(10)	/* b_srp_init,continue 5~10ms, section:5.3.3 */
+#define TB_DATA_PLS_MIN	(5)	/* minimum 5 ms */
+#define TB_DATA_PLS_MAX	(10)	/* maximum 10 ms */
+
+/* SRP Initiate Time  */
+#define TB_SRP_INIT	(100)	/* b_srp_init,maximum 100 ms, section:5.3.8 */
+
+/* SRP Fail Time  */
+#define TB_SRP_FAIL	(7000)	/* b_srp_init,Fail time 5~30s, section:6.8.2.2*/
+
+/* SRP result wait time */
+#define TB_SRP_WAIT	(60)
+
+/* VBus time */
+#define TB_VBUS_PLS	(30)	/* time to keep vbus pulsing asserted */
+
+/* Discharge time */
+/* This time should be less than 10ms. It varies from system to system. */
+#define TB_VBUS_DSCHRG	(8)
+
+/* A-SE0 to B-Reset  */
+#define TB_ASE0_BRST	(20)	/* b_wait_acon, mini 3.125 ms,section:6.8.2.4 */
+
+/* A bus suspend timer before we can switch to b_wait_aconn */
+#define TB_A_SUSPEND	(7)
+#define TB_BUS_RESUME	(12)
+
+/* SE0 Time Before SRP */
+#define TB_SE0_SRP	(2)	/* b_idle,minimum 2 ms, section:5.3.2 */
+
+
+#define SET_OTG_STATE(otg_ptr, newstate)	((otg_ptr)->state=newstate)
+
+struct usb_dr_mmap {
+	/* Capability register */
+	u8 res1[256];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u8 res2[20];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u8 res3[24];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u8 res4[4];
+	u32 deviceaddr;		/* Device Address */
+	u32 endpointlistaddr;	/* Endpoint List Address Register */
+	u8 res5[4];
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u8 res6[8];
+	u32 ulpiview;		/* ULPI register access */
+	u8 res7[12];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc;		/* Port 1 Status and Control Register */
+	u8 res8[28];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+	u32 endptctrl[6];	/* Endpoint Control Registers */
+	u8 res9[552];
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u8 res10[236];
+	u32 control;		/* General Purpose Control Register */
+};
+
+
+struct fsl_otg_timer {
+	unsigned long expires;	/* Number of count increase to timeout */
+	unsigned long count;	/* Tick counter */
+	void (*function)(unsigned long);	/* Timeout function */
+	unsigned long data;	/* Data passed to function */
+	struct list_head list;
+};
+
+struct fsl_otg_timer inline *otg_timer_initializer
+(void (*function)(unsigned long), unsigned long expires, unsigned long data)
+{
+	struct fsl_otg_timer *timer;
+	timer = kmalloc(sizeof(struct fsl_otg_timer), GFP_KERNEL);
+	if (timer == NULL)
+		return NULL;
+	timer->function = function;
+	timer->expires = expires;
+	timer->data = data;
+	return timer;
+}
+
+struct fsl_otg {
+	struct otg_transceiver otg;
+	struct otg_fsm fsm;
+	struct usb_dr_mmap *dr_mem_map;
+	struct delayed_work otg_event;
+
+	/*used for usb host */
+	struct work_struct work_wq;
+	u8	host_working;
+
+	int irq;
+};
+
+struct fsl_otg_config {
+	u8 otg_port;
+};
+
+/*For SRP and HNP handle*/
+#define FSL_OTG_MAJOR	66
+#define FSL_OTG_NAME	"fsl-usb2-otg"
+/*Command to OTG driver(ioctl)*/
+#define OTG_IOCTL_MAGIC		FSL_OTG_MAJOR
+/*if otg work as host,it should return 1,otherwise it return 0*/
+#define GET_OTG_STATUS		_IOR(OTG_IOCTL_MAGIC, 1, int)
+#define SET_A_SUSPEND_REQ	_IOW(OTG_IOCTL_MAGIC, 2, int)
+#define SET_A_BUS_DROP		_IOW(OTG_IOCTL_MAGIC, 3, int)
+#define SET_A_BUS_REQ		_IOW(OTG_IOCTL_MAGIC, 4, int)
+#define SET_B_BUS_REQ		_IOW(OTG_IOCTL_MAGIC, 5, int)
+#define GET_A_SUSPEND_REQ	_IOR(OTG_IOCTL_MAGIC, 6, int)
+#define GET_A_BUS_DROP		_IOR(OTG_IOCTL_MAGIC, 7, int)
+#define GET_A_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 8, int)
+#define GET_B_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 9, int)
+
+extern const char *state_string(enum usb_otg_state state);
+extern int otg_set_resources(struct resource *resources);
diff --git a/drivers/usb/otg/otg_fsm.c b/drivers/usb/otg/otg_fsm.c
new file mode 100644
index 0000000..955b21c
--- /dev/null
+++ b/drivers/usb/otg/otg_fsm.c
@@ -0,0 +1,371 @@
+/* OTG Finite State Machine from OTG spec
+ *
+ * Copyright (C) 2006-2008 Freescale Semiconductor, Inc.
+ *
+ * Author: 	Li Yang <LeoLi@freescale.com>
+ * 		Jerry Huang <Chang-Ming.Huang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/usb/otg.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/types.h>
+#include "otg_fsm.h"
+
+
+/* Defined by device specific driver, for different timer implementation */
+extern void *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+	*b_ase0_brst_tmr, *b_se0_srp_tmr, *b_srp_fail_tmr, *a_wait_enum_tmr;
+
+const char *state_string(enum usb_otg_state state)
+{
+	switch (state) {
+	case OTG_STATE_A_IDLE:		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:	return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:	return "a_wait_bcon";
+	case OTG_STATE_A_HOST:		return "a_host";
+	case OTG_STATE_A_SUSPEND:	return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:	return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:	return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:	return "a_vbus_err";
+	case OTG_STATE_B_IDLE:		return "b_idle";
+	case OTG_STATE_B_SRP_INIT:	return "b_srp_init";
+	case OTG_STATE_B_PERIPHERAL:	return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:	return "b_wait_acon";
+	case OTG_STATE_B_HOST:		return "b_host";
+	default:			return "UNDEFINED";
+	}
+}
+
+/* Change USB protocol when there is a protocol change */
+static int otg_set_protocol(struct otg_fsm *fsm, int protocol)
+{
+	int ret = 0;
+
+	if (fsm->protocol != protocol) {
+		VDBG("Changing role fsm->protocol= %d; new protocol= %d\n",
+				fsm->protocol, protocol);
+		/* stop old protocol */
+		if (fsm->protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 0);
+		else if (fsm->protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 0);
+		if (ret)
+			return ret;
+
+		/* start new protocol */
+		if (protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 1);
+		else if (protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 1);
+		if (ret)
+			return ret;
+
+		fsm->protocol = protocol;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int state_changed;
+
+/* Called when leaving a state.  Do state clean up jobs here */
+void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
+{
+	switch (old_state) {
+	case OTG_STATE_B_IDLE:
+		otg_del_timer(fsm, b_se0_srp_tmr);
+		fsm->b_se0_srp = 0;
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		fsm->b_srp_done = 0;
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_del_timer(fsm, b_ase0_brst_tmr);
+		fsm->b_ase0_brst_tmout = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		break;
+	case OTG_STATE_A_IDLE:
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_del_timer(fsm, a_wait_vrise_tmr);
+		fsm->a_wait_vrise_tmout = 0;
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_del_timer(fsm, a_wait_bcon_tmr);
+		fsm->a_wait_bcon_tmout = 0;
+		break;
+	case OTG_STATE_A_HOST:
+		otg_del_timer(fsm, a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_del_timer(fsm, a_aidl_bdis_tmr);
+		fsm->a_aidl_bdis_tmout = 0;
+		fsm->a_suspend_req = 0;
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_del_timer(fsm, a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		break;
+	default:
+		break;
+	}
+}
+
+/* Called when entering a state */
+int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
+{
+	state_changed = 1;
+	if (fsm->transceiver->state == new_state)
+		return 0;
+	VDBG("Set state: %s \n", state_string(new_state));
+	otg_leave_state(fsm, fsm->transceiver->state);
+	switch (new_state) {
+	case OTG_STATE_B_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, b_se0_srp_tmr);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		otg_start_pulse(fsm);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, b_srp_fail_tmr);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, b_ase0_brst_tmr);
+		fsm->a_bus_suspend = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		usb_bus_start_enum(fsm->transceiver->host,
+				fsm->transceiver->host->otg_port);
+		break;
+	case OTG_STATE_A_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_wait_bcon_tmr);
+		break;
+	case OTG_STATE_A_HOST:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		/* When HNP is triggered while a_bus_req = 0, a_host will
+		 * suspend too fast to complete a_set_b_hnp_en */
+		if (!fsm->a_bus_req || fsm->a_suspend_req)
+			otg_add_timer(fsm, a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_aidl_bdis_tmr);
+
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		otg_drv_vbus(fsm, 1);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		break;
+	default:
+		break;
+	}
+
+	fsm->transceiver->state = new_state;
+	return 0;
+}
+
+/* State change judgement */
+int otg_statemachine(struct otg_fsm *fsm)
+{
+	enum usb_otg_state state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	state = fsm->transceiver->state;
+	state_changed = 0;
+	/* State machine state change judgement */
+
+	switch (state) {
+	case OTG_STATE_UNDEFINED:
+		VDBG("fsm->id = %d \n", fsm->id);
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_B_IDLE:
+		if (!fsm->id)
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		else if (fsm->b_sess_vld && fsm->transceiver->gadget)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		else if (fsm->b_bus_req && fsm->b_sess_end && fsm->b_se0_srp)
+			otg_set_state(fsm, OTG_STATE_B_SRP_INIT);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		if (!fsm->id || fsm->b_srp_done)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->b_bus_req && fsm->transceiver->
+				gadget->b_hnp_enable && fsm->a_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_B_WAIT_ACON);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		if (fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_HOST);
+		else if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {
+			fsm->b_ase0_brst_tmout = 0;
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		}
+		break;
+	case OTG_STATE_B_HOST:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->b_bus_req || !fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		break;
+	case OTG_STATE_A_IDLE:
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->a_bus_drop && (fsm->a_bus_req || fsm->a_srp_det))
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_vbus_vld ||
+				fsm->a_wait_vrise_tmout) {
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		else if (fsm->b_conn)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		break;
+	case OTG_STATE_A_HOST:
+		if ((!fsm->a_bus_req || fsm->a_suspend_req) &&
+				fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_SUSPEND);
+		else if (fsm->id || !fsm->b_conn || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		if (!fsm->b_conn && fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_PERIPHERAL);
+		else if (!fsm->b_conn && !fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (fsm->a_bus_req || fsm->b_bus_resume)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		if (fsm->id || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (fsm->b_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (fsm->id || fsm->a_bus_req || (!fsm->a_sess_vld &&
+					!fsm->b_conn))
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	/*	VDBG("quit statemachine, changed = %d \n", state_changed); */
+	return state_changed;
+}
diff --git a/drivers/usb/otg/otg_fsm.h b/drivers/usb/otg/otg_fsm.h
new file mode 100644
index 0000000..cd6894c
--- /dev/null
+++ b/drivers/usb/otg/otg_fsm.h
@@ -0,0 +1,151 @@
+/* Copyright (C) 2006-2008 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if 0
+#define DEBUG 	1
+#define VERBOSE	1
+#endif
+
+#ifdef DEBUG
+#define DBG(fmt, args...) printk(KERN_DEBUG "j=%lu [%s] " fmt "\n", jiffies, \
+				 __func__, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define VDBG		DBG
+#else
+#define VDBG(stuff...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define MPC_LOC printk("Current Location [%s]:[%d]\n", __FILE__, __LINE__)
+#else
+#define MPC_LOC do {} while (0)
+#endif
+
+#define PROTO_UNDEF	(0)
+#define PROTO_HOST	(1)
+#define PROTO_GADGET	(2)
+
+/* OTG state machine according to the OTG spec */
+struct otg_fsm {
+	/* Input */
+	int a_bus_resume;
+	int a_bus_suspend;
+	int a_conn;
+	int a_sess_vld;
+	int a_srp_det;
+	int a_vbus_vld;
+	int b_bus_resume;
+	int b_bus_suspend;
+	int b_conn;
+	int b_se0_srp;
+	int b_sess_end;
+	int b_sess_vld;
+	int id;
+
+	/* Internal variables */
+	int a_set_b_hnp_en;
+	int b_srp_done;
+	int b_hnp_enable;
+
+	/* Timeout indicator for timers */
+	int a_wait_vrise_tmout;
+	int a_wait_bcon_tmout;
+	int a_aidl_bdis_tmout;
+	int b_ase0_brst_tmout;
+
+	/* Informative variables */
+	int a_bus_drop;
+	int a_bus_req;
+	int a_clr_err;
+	int a_suspend_req;
+	int b_bus_req;
+
+	/* Output */
+	int drv_vbus;
+	int loc_conn;
+	int loc_sof;
+
+	struct otg_fsm_ops *ops;
+	struct otg_transceiver *transceiver;
+
+	/* Current usb protocol used: 0:undefine; 1:host; 2:client */
+	int protocol;
+	spinlock_t lock;
+};
+
+struct otg_fsm_ops {
+	void	(*chrg_vbus)(int on);
+	void	(*drv_vbus)(int on);
+	void	(*loc_conn)(int on);
+	void	(*loc_sof)(int on);
+	void	(*start_pulse)(void);
+	void	(*add_timer)(void *timer);
+	void	(*del_timer)(void *timer);
+	int	(*start_host)(struct otg_fsm *fsm, int on);
+	int	(*start_gadget)(struct otg_fsm *fsm, int on);
+};
+
+
+static inline void otg_chrg_vbus(struct otg_fsm *fsm, int on)
+{
+	fsm->ops->chrg_vbus(on);
+}
+
+static inline void otg_drv_vbus(struct otg_fsm *fsm, int on)
+{
+	if (fsm->drv_vbus != on) {
+		fsm->drv_vbus = on;
+		fsm->ops->drv_vbus(on);
+	}
+}
+
+static inline void otg_loc_conn(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_conn != on) {
+		fsm->loc_conn = on;
+		fsm->ops->loc_conn(on);
+	}
+}
+
+static inline void otg_loc_sof(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_sof != on) {
+		fsm->loc_sof = on;
+		fsm->ops->loc_sof(on);
+	}
+}
+
+static inline void otg_start_pulse(struct otg_fsm *fsm)
+{
+	fsm->ops->start_pulse();
+}
+
+static inline void otg_add_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->add_timer(timer);
+}
+
+static inline void otg_del_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->del_timer(timer);
+}
+
+int otg_statemachine(struct otg_fsm *fsm);
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 4e625e0..db37df8 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -6,7 +6,7 @@
  *
  * Maintainer: Kumar Gala <galak@kernel.crashing.org>
  *
- * Copyright 2004 Freescale Semiconductor, Inc
+ * Copyright 2004-2008 Freescale Semiconductor, Inc
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -69,11 +69,10 @@ struct gianfar_mdio_data {
 #define FSL_GIANFAR_DEV_HAS_VLAN		0x00000020
 #define FSL_GIANFAR_DEV_HAS_EXTENDED_HASH	0x00000040
 #define FSL_GIANFAR_DEV_HAS_PADDING		0x00000080
-#define FSL_GIANFAR_DEV_HAS_MAGIC_PACKET	0x00000100
 
 /* Flags in gianfar_platform_data */
-#define FSL_GIANFAR_BRD_HAS_PHY_INTR	0x00000001 /* set or use a timer */
-#define FSL_GIANFAR_BRD_IS_REDUCED	0x00000002 /* Set if RGMII, RMII */
+#define FSL_GIANFAR_BRD_HAS_PHY_INTR	0x00000001	/* set or use a timer */
+#define FSL_GIANFAR_BRD_IS_REDUCED	0x00000002	/* Set if RGMII, RMII */
 
 struct fsl_i2c_platform_data {
 	/* device specific information */
@@ -99,11 +98,32 @@ enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_SERIAL,
 };
 
+struct platform_device;
 struct fsl_usb2_platform_data {
 	/* board specific information */
 	enum fsl_usb2_operating_modes	operating_mode;
 	enum fsl_usb2_phy_modes		phy_mode;
 	unsigned int			port_enables;
+
+	char *name;		/* pretty print */
+	int (*platform_init) (struct platform_device *);
+	void (*platform_uninit) (struct fsl_usb2_platform_data *);
+	void __iomem *regs;	/* ioremap'd register base */
+	u32 xcvr_type;		/* PORTSC_PTS_* */
+	char *transceiver;	/* transceiver name */
+	unsigned power_budget;	/* for hcd->power_budget */
+	struct platform_device *pdev;
+	struct fsl_xcvr_ops *xcvr_ops;
+	struct fsl_xcvr_power *xcvr_pwr;
+	int (*gpio_usb_active) (void);
+	void (*gpio_usb_inactive) (void);
+	unsigned			big_endian_mmio:1;
+	unsigned			big_endian_desc:1;
+	unsigned			es:1;	/* need USBMODE:ES */
+	unsigned			have_sysif_regs:1;
+	unsigned			le_setup_buf:1;
+	unsigned change_ahb_burst:1;
+	unsigned ahb_burst_mode:3;
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
@@ -111,25 +131,33 @@ struct fsl_usb2_platform_data {
 #define FSL_USB2_PORT1_ENABLED	0x00000002
 
 struct fsl_spi_platform_data {
-	u32 	initial_spmode;	/* initial SPMODE value */
-	u16	bus_num;
+	u32 initial_spmode;	/* initial SPMODE value */
+	u16 bus_num;
 	bool	qe_mode;
 	/* board specific information */
-	u16	max_chipselect;
-	void	(*activate_cs)(u8 cs, u8 polarity);
-	void	(*deactivate_cs)(u8 cs, u8 polarity);
-	u32	sysclk;
+	u16 max_chipselect;
+	void (*activate_cs) (u8 cs, u8 polarity);
+	void (*deactivate_cs) (u8 cs, u8 polarity);
+	u32 sysclk;
+};
+
+struct fsl_ata_platform_data {
+       int     adma_flag;      /* AMDA mode is used or not, 1:used.*/
+       int     udma_mask;      /* UDMA modes h/w can handle */
+       int     mwdma_mask;      /* MDMA modes h/w can handle */
+       int     pio_mask;      /* PIO modes h/w can handle */
+       int     fifo_alarm;     /* value for fifo_alarm reg */
+       int     max_sg;         /* longest sglist h/w can handle */
+       int     (*init)(struct platform_device *pdev);
+       void    (*exit)(void);
+	   char    *io_reg;
+	   char    *core_reg;
 };
 
+
 struct mpc8xx_pcmcia_ops {
 	void(*hw_ctrl)(int slot, int enable);
 	int(*voltage_set)(int slot, int vcc, int vpp);
 };
 
-/* Returns non-zero if the current suspend operation would
- * lead to a deep sleep (i.e. power removed from the core,
- * instead of just the clock).
- */
-int fsl_deep_sleep(void);
-
 #endif /* _FSL_DEVICE_H_ */
diff --git a/include/linux/usb/fsl_xcvr.h b/include/linux/usb/fsl_xcvr.h
new file mode 100644
index 0000000..9a48bb6
--- /dev/null
+++ b/include/linux/usb/fsl_xcvr.h
@@ -0,0 +1,44 @@
+#ifndef __LINUX_USB_FSL_XCVR_H
+#define __LINUX_USB_FSL_XCVR_H
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+struct fsl_usb2_platform_data;
+
+enum usb_test_mode{
+	USB_TEST_J = 1,
+	USB_TEST_K = 2,
+};
+
+/**
+ * @name: transceiver name
+ * @xcvr_type: one of PORTSC_PTS_{UTMI,SERIAL,ULPI}
+ * @init: transceiver- and board-specific initialization function
+ * @uninit: transceiver- and board-specific uninitialization function
+ * @set_host:
+ * @set_device:
+ * @pullup: enable or disable D+ pullup
+ *
+ */
+struct fsl_xcvr_ops {
+	char *name;
+	u32 xcvr_type;
+
+	void (*init)(struct fsl_xcvr_ops *ops);
+	void (*uninit)(struct fsl_xcvr_ops *ops);
+	void (*suspend)(struct fsl_xcvr_ops *ops);
+	void (*set_host)(void);
+	void (*set_device)(void);
+	void (*set_vbus_power)(struct fsl_xcvr_ops *ops,
+			       struct fsl_usb2_platform_data *pdata, int on);
+	void (*set_remote_wakeup)(u32 *view);
+	void (*pullup)(int on);
+	void(*set_test_mode)(u32 *view, enum usb_test_mode mode);
+};
+
+struct fsl_xcvr_power {
+	struct platform_device *usb_pdev;
+	struct regulator *regu1;
+	struct regulator *regu2;
+};
+#endif
-- 
1.5.5.1

