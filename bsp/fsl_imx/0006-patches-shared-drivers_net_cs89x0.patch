From 7e4b80960b59331d2c13aafde49bad24433b7c58 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 18 Apr 2008 15:29:21 +0800
Subject: [PATCH] patches-shared/drivers_net_cs89x0

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 drivers/net/cs89x0.c |   28 ++++++++++++++++++++++++++--
 1 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/drivers/net/cs89x0.c b/drivers/net/cs89x0.c
index 348371f..8bbd2a1 100644
--- a/drivers/net/cs89x0.c
+++ b/drivers/net/cs89x0.c
@@ -194,11 +194,23 @@ static unsigned int cs8900_irq_map[] = {IRQ_IXDP2X01_CS8900, 0, 0, 0};
 #define CIRRUS_DEFAULT_IRQ	VH_INTC_INT_NUM_CASCADED_INTERRUPT_1 /* Event inputs bank 1 - ID 35/bit 3 */
 static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
 static unsigned int cs8900_irq_map[] = {CIRRUS_DEFAULT_IRQ, 0, 0, 0};
+#elif defined(CONFIG_ARCH_MXC)
+/*! Null terminated portlist used to probe for the CS8900A device on ISA Bus
+ * Add 3 to reset the page window before probing (fixes eth probe when deployed
+ * using nand_boot)
+ */
+static unsigned int netcard_portlist[] = {CS8900A_BASE_ADDRESS+3, 0};
+/*!
+ * The CS8900A has 4 IRQ pins, which is software selectable, CS8900A interrupt
+ * pin 0 is used for interrupt generation.
+ */
+static unsigned int cs8900_irq_map[] = {CS8900AIRQ, 0, 0, 0};
 #else
 static unsigned int netcard_portlist[] __used __initdata =
    { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
 static unsigned int cs8900_irq_map[] = {10,11,12,5};
 #endif
+static unsigned char cs89xx_mac_addr_def[]={0x00,0x01,0x02,0x03,0x04,0x05};
 
 #if DEBUGGING
 static unsigned int net_debug = DEBUGGING;
@@ -762,6 +774,13 @@ cs89x0_probe1(struct net_device *dev, int ioaddr, int modular)
 				dev->name, lp->adapter_cnf);
         }
 
+       if(is_zero_ether_addr(dev->dev_addr)){
+	       /* cannot find MAC from EEPROM,set default MAC address */
+	       printk(" cs89x0,fail to find MAC from EEPROM,using default MAC \n" );
+	       memcpy(dev->dev_addr,cs89xx_mac_addr_def, 6);
+       }
+
+
         /* allow them to force multiple transceivers.  If they force multiple, autosense */
         {
 		int count = 0;
@@ -802,7 +821,8 @@ cs89x0_probe1(struct net_device *dev, int ioaddr, int modular)
 	} else {
 		i = lp->isa_config & INT_NO_MASK;
 		if (lp->chip_type == CS8900) {
-#if defined(CONFIG_MACH_IXDP2351) || defined(CONFIG_ARCH_IXDP2X01) || defined(CONFIG_ARCH_PNX010X)
+#if defined(CONFIG_MACH_IXDP2351) || defined(CONFIG_ARCH_IXDP2X01) || \
+	defined(CONFIG_ARCH_PNX010X) || defined(CONFIG_ARCH_MXC)
 		        i = cs8900_irq_map[0];
 #else
 			/* Translate the IRQ using the IRQ mapping table. */
@@ -1029,6 +1049,7 @@ skip_this_frame:
 
 void  __init reset_chip(struct net_device *dev)
 {
+#if !defined(CONFIG_ARCH_MXC)
 #if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01)
 	struct net_local *lp = netdev_priv(dev);
 	int ioaddr = dev->base_addr;
@@ -1057,6 +1078,7 @@ void  __init reset_chip(struct net_device *dev)
 	reset_start_time = jiffies;
 	while( (readreg(dev, PP_SelfST) & INIT_DONE) == 0 && jiffies - reset_start_time < 2)
 		;
+#endif
 }
 
 
@@ -1304,7 +1326,9 @@ net_open(struct net_device *dev)
 	else
 #endif
 	{
-#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01) && !defined(CONFIG_ARCH_PNX010X)
+#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01) &&\
+	!defined(CONFIG_ARCH_PNX010X) && !defined(CONFIG_ARCH_MXC)
+
 		if (((1 << dev->irq) & lp->irq_map) == 0) {
 			printk(KERN_ERR "%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",
                                dev->name, dev->irq, lp->irq_map);
-- 
1.5.5.1

