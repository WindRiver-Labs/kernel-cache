From 6889a753126bb9a529037c3759fb8bacb24f55f5 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 20 May 2010 14:22:06 +0800
Subject: [PATCH] mxc/header: Add mxc common platform headers

Add mxc common platoform headers.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/plat-mxc/include/mach/arc_otg.h           |  365 +++
 arch/arm/plat-mxc/include/mach/board-mx31_3ds.h    |    8 +
 arch/arm/plat-mxc/include/mach/board-mx51_3stack.h |  128 ++
 arch/arm/plat-mxc/include/mach/clock.h             |   10 +
 arch/arm/plat-mxc/include/mach/common.h            |    5 +
 arch/arm/plat-mxc/include/mach/dma.h               |  293 +++
 arch/arm/plat-mxc/include/mach/fsl_usb.h           |   91 +
 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h    |   40 +
 arch/arm/plat-mxc/include/mach/gpio.h              |    3 +
 arch/arm/plat-mxc/include/mach/hardware.h          |   28 +
 arch/arm/plat-mxc/include/mach/hw_events.h         |   65 +
 arch/arm/plat-mxc/include/mach/io.h                |   11 +
 arch/arm/plat-mxc/include/mach/irqs.h              |   15 +
 arch/arm/plat-mxc/include/mach/memory.h            |    8 +
 arch/arm/plat-mxc/include/mach/mmc.h               |   16 +
 arch/arm/plat-mxc/include/mach/mx31.h              |  104 +
 arch/arm/plat-mxc/include/mach/mx3x.h              |    2 +
 arch/arm/plat-mxc/include/mach/mx51.h              |  142 ++-
 arch/arm/plat-mxc/include/mach/mxc.h               |  527 +++++
 arch/arm/plat-mxc/include/mach/mxc_dptc.h          |  111 +
 arch/arm/plat-mxc/include/mach/mxc_dvfs.h          |  261 +++
 arch/arm/plat-mxc/include/mach/mxc_gadget.h        |   22 +
 arch/arm/plat-mxc/include/mach/mxc_nand.h          |    4 +-
 arch/arm/plat-mxc/include/mach/mxc_pm.h            |  252 +++
 arch/arm/plat-mxc/include/mach/mxc_scc.h           |   45 +
 arch/arm/plat-mxc/include/mach/mxc_uart.h          |  275 +++
 arch/arm/plat-mxc/include/mach/mxc_vpu.h           |   94 +
 arch/arm/plat-mxc/include/mach/pmic_audio.h        | 2329 ++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/pmic_convity.h      |  871 ++++++++
 arch/arm/plat-mxc/include/mach/pmic_power.h        | 1358 ++++++++++++
 arch/arm/plat-mxc/include/mach/sdma.h              |  563 +++++
 arch/arm/plat-mxc/include/mach/sdram_autogating.h  |   56 +
 arch/arm/plat-mxc/include/mach/spba.h              |   66 +
 arch/arm/plat-mxc/include/mach/system.h            |    7 +-
 34 files changed, 8171 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/arc_otg.h
 create mode 100644 arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
 create mode 100644 arch/arm/plat-mxc/include/mach/dma.h
 create mode 100644 arch/arm/plat-mxc/include/mach/fsl_usb.h
 create mode 100644 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
 create mode 100644 arch/arm/plat-mxc/include/mach/hw_events.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_dptc.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_dvfs.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_gadget.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_pm.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_scc.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_uart.h
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_vpu.h
 create mode 100644 arch/arm/plat-mxc/include/mach/pmic_audio.h
 create mode 100644 arch/arm/plat-mxc/include/mach/pmic_convity.h
 create mode 100644 arch/arm/plat-mxc/include/mach/pmic_power.h
 create mode 100644 arch/arm/plat-mxc/include/mach/sdma.h
 create mode 100644 arch/arm/plat-mxc/include/mach/sdram_autogating.h
 create mode 100644 arch/arm/plat-mxc/include/mach/spba.h

diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
new file mode 100644
index 0000000..6f5f171
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#ifdef CONFIG_ARCH_MX51
+#define USB_H3REGS_BASE		(OTG_BASE_ADDR + 0x600)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x800)
+#else
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+#endif
+
+
+#define USBOTG_REG32(offset) \
+	(*((volatile u32 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
+#define USBOTG_REG16(offset) \
+	(*((volatile u16 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
+
+#define USBH1_REG32(offset) \
+	(*((volatile u32 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
+#define USBH1_REG16(offset) \
+	(*((volatile u16 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
+
+#define USBH2_REG32(offset) \
+	(*((volatile u32 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
+#define USBH2_REG16(offset) \
+	(*((volatile u16 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
+
+#define USBOTHER_REG(offset) \
+	(*((volatile u32 *)(IO_ADDRESS(USB_OTHERREGS_BASE + (offset)))))
+
+/*
+ * OTG registers
+ */
+#define UOG_ID			USBOTG_REG32(0x00) /* Host ID */
+#define UOG_HWGENERAL		USBOTG_REG32(0x04) /* Host General */
+#define UOG_HWHOST		USBOTG_REG32(0x08) /* Host h/w params */
+#define UOG_HWTXBUF		USBOTG_REG32(0x10) /* TX buffer h/w params */
+#define UOG_HWRXBUF		USBOTG_REG32(0x14) /* RX buffer h/w params */
+#define UOG_CAPLENGTH		USBOTG_REG16(0x100) /* Capability reg length */
+#define UOG_HCIVERSION		USBOTG_REG16(0x102) /* Host Interface version */
+#define UOG_HCSPARAMS		USBOTG_REG32(0x104) /* ctrl structural params */
+#define UOG_HCCPARAMS		USBOTG_REG32(0x108) /* ctrl capability params */
+#define UOG_DCIVERSION		USBOTG_REG32(0x120) /* dev interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		USBOTG_REG32(0x140) /* USB command register */
+#define UOG_USBSTS		USBOTG_REG32(0x144) /* USB status register */
+#define UOG_USBINTR		USBOTG_REG32(0x148) /* int enable register */
+#define UOG_FRINDEX		USBOTG_REG32(0x14c) /* USB frame index */
+/*      segment                        (0x150) addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	USBOTG_REG32(0x154) /* frame list base addr */
+#define UOG_DEVICEADDR		USBOTG_REG32(0x154) /* device crtlr device address */
+#define UOG_ASYNCLISTADDR	USBOTG_REG32(0x158) /* host ctrlr next async addr */
+#define UOG_EPLISTADDR		USBOTG_REG32(0x158) /* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		USBOTG_REG32(0x160) /* host ctrlr embedded TT async buf status */
+#define UOG_TXFILLTUNING	USBOTG_REG32(0x164) /* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		USBOTG_REG32(0x170) /* ULPI viewport */
+#define UOG_CFGFLAG		USBOTG_REG32(0x180) /* configflag (supports HS) */
+#define UOG_PORTSC1		USBOTG_REG32(0x184) /* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		USBOTG_REG32(0x1a4) /* OTG status and control */
+#define UOG_USBMODE		USBOTG_REG32(0x1a8) /* USB device mode */
+#define UOG_ENDPTSETUPSTAT	USBOTG_REG32(0x1ac) /* endpoint setup status */
+#define UOG_ENDPTPRIME		USBOTG_REG32(0x1b0) /* endpoint initialization */
+#define UOG_ENDPTFLUSH		USBOTG_REG32(0x1b4) /* endpoint de-initialize */
+#define UOG_ENDPTSTAT		USBOTG_REG32(0x1b8) /* endpoint status */
+#define UOG_ENDPTCOMPLETE	USBOTG_REG32(0x1bc) /* endpoint complete */
+#define UOG_EPCTRL0		USBOTG_REG32(0x1c0) /* endpoint control0 */
+#define UOG_EPCTRL1		USBOTG_REG32(0x1c4) /* endpoint control1 */
+#define UOG_EPCTRL2		USBOTG_REG32(0x1c8) /* endpoint control2 */
+#define UOG_EPCTRL3		USBOTG_REG32(0x1cc) /* endpoint control3 */
+#define UOG_EPCTRL4		USBOTG_REG32(0x1d0) /* endpoint control4 */
+#define UOG_EPCTRL5		USBOTG_REG32(0x1d4) /* endpoint control5 */
+#define UOG_EPCTRL6		USBOTG_REG32(0x1d8) /* endpoint control6 */
+#define UOG_EPCTRL7		USBOTG_REG32(0x1dc) /* endpoint control7 */
+
+/*
+ * Host 1 registers
+ */
+#define UH1_ID			USBH1_REG32(0x00)	/* Host ID */
+#define UH1_HWGENERAL		USBH1_REG32(0x04)	/* Host General */
+#define UH1_HWHOST		USBH1_REG32(0x08)	/* Host h/w params */
+#define UH1_HWTXBUF		USBH1_REG32(0x10)	/* TX buffer h/w params */
+#define UH1_HWRXBUF		USBH1_REG32(0x14)	/* RX buffer h/w params */
+#define UH1_CAPLENGTH		USBH1_REG16(0x100)	/* Capability register length */
+#define UH1_HCIVERSION		USBH1_REG16(0x102)	/* Host Interface version */
+#define UH1_HCSPARAMS		USBH1_REG32(0x104)	/* Host control structural params */
+#define UH1_HCCPARAMS		USBH1_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH1_USBCMD		USBH1_REG32(0x140)	/* USB command register */
+#define UH1_USBSTS		USBH1_REG32(0x144)	/* USB status register */
+#define UH1_USBINTR		USBH1_REG32(0x148)	/* interrupt enable register */
+#define UH1_FRINDEX		USBH1_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH1_PERIODICLISTBASE	USBH1_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH1_ASYNCLISTADDR	USBH1_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH1_BURSTSIZE		USBH1_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH1_TXFILLTUNING	USBH1_REG32(0x164)	/* TX FIFO fill tuning */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * Host 2 registers
+ */
+#define UH2_ID			USBH2_REG32(0x00)	/* Host ID */
+#define UH2_HWGENERAL		USBH2_REG32(0x04)	/* Host General */
+#define UH2_HWHOST		USBH2_REG32(0x08)	/* Host h/w params */
+#define UH2_HWTXBUF		USBH2_REG32(0x10)	/* TX buffer h/w params */
+#define UH2_HWRXBUF		USBH2_REG32(0x14)	/* RX buffer h/w params */
+#define UH2_CAPLENGTH		USBH2_REG16(0x100)	/* Capability register length */
+#define UH2_HCIVERSION		USBH2_REG16(0x102)	/* Host Interface version */
+#define UH2_HCSPARAMS		USBH2_REG32(0x104)	/* Host control structural params */
+#define UH2_HCCPARAMS		USBH2_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH2_USBCMD		USBH2_REG32(0x140)	/* USB command register */
+#define UH2_USBSTS		USBH2_REG32(0x144)	/* USB status register */
+#define UH2_USBINTR		USBH2_REG32(0x148)	/* interrupt enable register */
+#define UH2_FRINDEX		USBH2_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH2_USBMODE		USBH2_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * other regs (not part of ARC core)
+ */
+#define USBCTRL			USBOTHER_REG(0x00)	/* USB Control register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)	/* USB OTG mirror register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG(0x08)      /* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG(0x0c)      /* OTG UTMI PHY Function Control register */
+#define USB_CTRL_1		USBOTHER_REG(0x10)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST2		USBOTHER_REG(0x14)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
+
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30)	/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI			(0 << 30)	/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30)	/* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30)	/* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30)	/* serial */
+#define PORTSC_STS			(1 << 29)	/* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28)       /* UTMI width */
+#define PORTSC_PHCD                     (1 << 23)       /* Low Power Suspend */
+#define PORTSC_PORT_POWER		(1 << 12)	/* port power */
+#define PORTSC_LS_MASK			(3 << 10)	/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)	/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)	/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)	/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)	/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)	/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)	/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)	/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)	/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)	/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)	/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)	/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)	/* current connect status */
+
+#define PORTSC_W1C_BITS                     \
+	(PORTSC_CONNECT_STATUS_CHANGE |     \
+	 PORTSC_PORT_EN_DIS_CHANGE    |     \
+	 PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)	/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)	/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)	/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1				/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+/* USBCTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OWIE		(1 << 27)	/* OTG wakeup intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+
+#ifdef CONFIG_ARCH_MX51
+#define UCTRL_H2UIE		(1 << 8)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)	/* HOST2 power mask */
+#else
+#define UCTRL_H2UIE		(1 << 20)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 19)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		(1 << 18)	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 16)	/* HOST2 power mask */
+#endif
+#define UCTRL_H2OVBWK_EN	(1 << 6) /* OTG VBUS Wakeup Enable */
+#define UCTRL_H2OIDWK_EN	(1 << 5) /* OTG ID Wakeup Enable */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)	/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)	/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)	/* Host1 ULPI interrupt enable */
+
+#if defined(CONFIG_ARCH_MX37)
+/* VBUS wakeup enable, UTMI only */
+#define UCTRL_VBUS_WKUP_EN	(1 << 12)
+#elif defined(CONFIG_ARCH_MX25) || defined(CONFIG_ARCH_MX35)
+#define UCTRL_VBUS_WKUP_EN      (1 << 15)
+#endif
+
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2             (1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+#define UCTRL_IP_PULIDP         (1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP         (1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN       (1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_USBTE             (1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL             (1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE               (1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS             (1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)	/* OTG TLL Disable */
+#define UCTRL_OOCS              (1 <<  0)       /* OTG OverCurrent State */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	(~(0xff << 16)) /* Int Threshold Control */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+						/* 1=high: Operate as B-device */
+						/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+/* PHY control0 Register Bit Masks */
+#define USB_UTMI_PHYCTRL_CONF2	(1 << 26)
+
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE (1 << 24)
+#define USB_UTMI_PHYCTRL_CHGRDETEN (1 << 24)    /* Enable Charger Detector */
+#define USB_UTMI_PHYCTRL_CHGRDETON (1 << 23)    /* Charger Detector Power On Control */
+#define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
+#define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_MASK		0x3
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT	19
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN			(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN			(1 << 26)
+
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+
+extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/board-mx31_3ds.h b/arch/arm/plat-mxc/include/mach/board-mx31_3ds.h
index da92933..2232213 100644
--- a/arch/arm/plat-mxc/include/mach/board-mx31_3ds.h
+++ b/arch/arm/plat-mxc/include/mach/board-mx31_3ds.h
@@ -48,12 +48,20 @@
 #define MXC_EXP_IO_BASE		(MXC_BOARD_IRQ_START)
 #define MXC_IRQ_TO_EXPIO(irq)	((irq) - MXC_EXP_IO_BASE)
 
+#define MXC_VIRTUAL_INTS_BASE   (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES)
+#define MXC_SDIO1_CARD_IRQ      MXC_VIRTUAL_INTS_BASE
+#define MXC_SDIO2_CARD_IRQ      (MXC_VIRTUAL_INTS_BASE + 1)
+#define MXC_SDIO3_CARD_IRQ      (MXC_VIRTUAL_INTS_BASE + 2)
+
 #define EXPIO_INT_ENET		(MXC_EXP_IO_BASE + 0)
 #define EXPIO_INT_XUART_A	(MXC_EXP_IO_BASE + 1)
 #define EXPIO_INT_XUART_B	(MXC_EXP_IO_BASE + 2)
 #define EXPIO_INT_BUTTON_A	(MXC_EXP_IO_BASE + 3)
 #define EXPIO_INT_BUTTON_B	(MXC_EXP_IO_BASE + 4)
 
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ     EXPIO_INT_ENET
+
 #define MXC_MAX_EXP_IO_LINES	16
 
 #endif /* __ASM_ARCH_MXC_BOARD_MX31_3DS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h b/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
new file mode 100644
index 0000000..bcd30dd
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/board-mx51_3stack.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__
+
+/*!
+ * @defgroup BRDCFG_MX51 Board Configuration Options
+ * @ingroup MSL_MX51
+ */
+
+/*!
+ * @file mach-mx51/board-mx51_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX51 3Stack Platform.
+ *
+ * @ingroup BRDCFG_MX51
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+
+/*!
+ * @name MXC UART board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV	0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV	0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE		MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR		NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED		1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE		MODE_DCE
+#define UART2_IR		NO_IRDA
+#define UART2_ENABLED		1
+/* UART 3 configuration */
+#define UART3_MODE		MODE_DCE
+#define UART3_IR		NO_IRDA
+#define UART3_ENABLED		1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define DEBUG_BOARD_BASE_ADDRESS(n)	(n)
+/* LAN9217 ethernet base address */
+#define LAN9217_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n))
+/* External UART */
+#define UARTA_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x8000)
+#define UARTB_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x10000)
+
+#define BOARD_IO_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x20000)
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG	0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+/* interrupts like external uart , external ethernet etc*/
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX51_PIN_GPIO1_6)
+
+#define EXPIO_INT_ENET		(MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUART_A	(MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUART_B	(MXC_BOARD_IRQ_START + 2)
+#define EXPIO_INT_BUTTON_A	(MXC_BOARD_IRQ_START + 3)
+#define EXPIO_INT_BUTTON_B	(MXC_BOARD_IRQ_START + 4)
+
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ	EXPIO_INT_ENET
+
+extern int __init mx51_3stack_init_mc13892(void);
+extern void __init mx51_3stack_io_init(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/clock.h b/arch/arm/plat-mxc/include/mach/clock.h
index 753a598..e695291 100644
--- a/arch/arm/plat-mxc/include/mach/clock.h
+++ b/arch/arm/plat-mxc/include/mach/clock.h
@@ -59,6 +59,16 @@ struct clk {
 
 int clk_register(struct clk *clk);
 void clk_unregister(struct clk *clk);
+int clk_get_usecount(struct clk *clk);
+int clk_set_pll_dither(struct clk *clk, unsigned int pll_ppm);
+
+/* Clock flags */
+#define RATE_PROPAGATES		(1 << 0)	/* Program children too */
+#define ALWAYS_ENABLED		(1 << 1)	/* Clock cannot be disabled */
+#define RATE_FIXED		(1 << 2)	/* Fixed clock rate */
+#define CPU_FREQ_TRIG_UPDATE	(1 << 3)	/* CPUFREQ trig update */
+#define AHB_HIGH_SET_POINT	(1 << 4)	/* Requires max AHB clock */
+#define AHB_MED_SET_POINT	(1 << 5)	/* Requires med AHB clock */
 
 unsigned long mxc_decode_pll(unsigned int pll, u32 f_ref);
 
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 2941472..3a4671a 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -50,4 +50,9 @@ extern void mxc91231_power_off(void);
 extern void mxc91231_arch_reset(int, const char *);
 extern void mxc91231_prepare_idle(void);
 
+extern int mxc_init_devices(void);
+extern void mxc_cpu_init(void);
+extern void mxc_cpu_common_init(void);
+extern void early_console_setup(char *);
+
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/dma.h b/arch/arm/plat-mxc/include/mach/dma.h
new file mode 100644
index 0000000..077119b
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dma.h
@@ -0,0 +1,293 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_DMA_H__
+#define __ASM_ARCH_MXC_DMA_H__
+
+#include <linux/scatterlist.h>
+
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+	MXC_DMA_CSPI3_RX,
+	MXC_DMA_CSPI3_TX,
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_FIFO_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+	MXC_DMA_CSI_RX,
+	MXC_DMA_SPDIF_16BIT_TX,
+	MXC_DMA_SPDIF_16BIT_RX,
+	MXC_DMA_SPDIF_32BIT_TX,
+	MXC_DMA_SPDIF_32BIT_RX,
+	MXC_DMA_ASRC_A_RX,
+	MXC_DMA_ASRC_A_TX,
+	MXC_DMA_ASRC_B_RX,
+	MXC_DMA_ASRC_B_TX,
+	MXC_DMA_ASRC_C_RX,
+	MXC_DMA_ASRC_C_TX,
+	MXC_DMA_ASRCA_ESAI,
+	MXC_DMA_ASRCB_ESAI,
+	MXC_DMA_ASRCC_ESAI,
+	MXC_DMA_ASRCA_SSI1_TX0,
+	MXC_DMA_ASRCA_SSI1_TX1,
+	MXC_DMA_ASRCA_SSI2_TX0,
+	MXC_DMA_ASRCA_SSI2_TX1,
+	MXC_DMA_ASRCB_SSI1_TX0,
+	MXC_DMA_ASRCB_SSI1_TX1,
+	MXC_DMA_ASRCB_SSI2_TX0,
+	MXC_DMA_ASRCB_SSI2_TX1,
+	MXC_DMA_ESAI_16BIT_RX,
+	MXC_DMA_ESAI_16BIT_TX,
+	MXC_DMA_ESAI_24BIT_RX,
+	MXC_DMA_ESAI_24BIT_TX,
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+				    unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct mxc_dma_channel {
+	unsigned int active:1;	/*!< When a active tranfer, it is set to 1 */
+	unsigned int lock;	/*!< Defines the channel is allocated or not */
+	int curr_buf;		/*!< Current buffer */
+	mxc_dma_mode_t mode;	/*!< Read or Write */
+	unsigned int channel;	/*!< Channel info */
+	unsigned int dynamic:1;	/*!< Channel not statically allocated when 1 */
+	char *dev_name;		/*!< Device name */
+	void *private;		/*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;	/*!< The callback function */
+	void *cb_args;		/*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct mxc_dma_requestbuf {
+	dma_addr_t src_addr;	/*!< source address */
+	dma_addr_t dst_addr;	/*!< destination address */
+	int num_of_bytes;	/*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+/*! This struct contains the information for asrc special*/
+struct dma_channel_asrc_info {
+	u32 channs;		/*!< data channels in asrc */
+};
+
+/*! This struct contains  the information for device special*/
+struct dma_channel_info {
+	struct dma_channel_asrc_info asrc;	/*!< asrc special information */
+};
+
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX21)
+#include <mach/mx2_dma.h>
+#else
+#include <mach/sdma.h>
+#endif
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @param data         the customized parameter for special channel.
+ * @return returns a negative number on error if request for a DMA channel did not
+ *         succeed, returns the channel number to be used on success.
+ */
+extern int mxc_dma_request_ext(mxc_dma_device_t channel_id, char *dev_name,
+			       struct dma_channel_info *info);
+
+static inline int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name)
+{
+	return mxc_dma_request_ext(channel_id, dev_name, NULL);
+}
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t *dma_buf,
+			  int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+			     int num_buf, int num_of_bytes,
+			     mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+				void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb.h b/arch/arm/plat-mxc/include/mach/fsl_usb.h
new file mode 100644
index 0000000..d1235fc
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
+
+/* Needed for enable PP and i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 temp;
+
+	/* HCSPARAMS */
+	temp = readl(pdata->regs + 0x104);
+	/* Port Power Control */
+	if (temp & HCSPARAMS_PPC) {
+		temp = readl(pdata->regs + FSL_SOC_USB_PORTSC1);
+		if (on)
+			temp |= PORT_POWER;
+		else
+			temp &= ~PORT_POWER;
+
+		writel(temp, pdata->regs + FSL_SOC_USB_PORTSC1);
+	}
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, on);
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+	struct fsl_usb2_platform_data *pdata;
+	unsigned int temp;
+
+	pdata = hcd->self.controller->platform_data;
+	if (pdata->change_ahb_burst) {
+		temp = readl(hcd->regs + FSL_SOC_USB_SBUSCFG);
+		writel((temp & (~(0x7))) | pdata->ahb_burst_mode,
+			hcd->regs + FSL_SOC_USB_SBUSCFG);
+	}
+
+	/* Increase TX fifo threshold for USB+ATA for i.mx35 2.0 */
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x20 */
+		writel((temp & (~(0x3f << 16))) | (0x20 << 16),
+			hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+}
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
new file mode 100644
index 0000000..d3c581e
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/arch/arm/plat-mxc/include/mach/gpio.h b/arch/arm/plat-mxc/include/mach/gpio.h
index 894d2f8..9f382e6 100644
--- a/arch/arm/plat-mxc/include/mach/gpio.h
+++ b/arch/arm/plat-mxc/include/mach/gpio.h
@@ -33,9 +33,12 @@
 struct mxc_gpio_port {
 	void __iomem *base;
 	int irq;
+	int irq_high;
 	int virtual_irq_start;
 	struct gpio_chip chip;
 	u32 both_edges;
+	u32 suspend_wakeup;
+	u32 saved_wakeup;
 };
 
 int mxc_gpio_init(struct mxc_gpio_port*, int);
diff --git a/arch/arm/plat-mxc/include/mach/hardware.h b/arch/arm/plat-mxc/include/mach/hardware.h
index ebadf4a..a8bc139 100644
--- a/arch/arm/plat-mxc/include/mach/hardware.h
+++ b/arch/arm/plat-mxc/include/mach/hardware.h
@@ -27,6 +27,7 @@
 	 (((unsigned long)((addr) - (module ## _BASE_ADDR)) < module ## _SIZE) ?\
 	 (addr) - (module ## _BASE_ADDR) + (module ## _BASE_ADDR_VIRT) : 0))
 
+
 #ifdef CONFIG_ARCH_MX5
 #include <mach/mx51.h>
 #endif
@@ -59,6 +60,33 @@
 # include <mach/mxc91231.h>
 #endif
 
+#ifndef __ASSEMBLY__
+extern unsigned int system_rev;
+#define board_is_rev(rev)	(((system_rev & 0x0F00) == rev) ? 1 : 0)
+#endif
+
 #include <mach/mxc.h>
 
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+#ifndef MXC_INT_FORCE
+#define MXC_INT_FORCE	-1
+#endif
+
 #endif /* __ASM_ARCH_MXC_HARDWARE_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/hw_events.h b/arch/arm/plat-mxc/include/mach/hw_events.h
new file mode 100644
index 0000000..f0aa3ad
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/hw_events.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * hw_events.h
+ * include the headset/cvbs interrupt detect
+ */
+
+#ifndef HW_EVENT_H
+#define HW_EVENT_H
+
+#define HW_EVENT_GROUP		2
+#define HWE_DEF_PRIORITY	1
+#define HWE_HIGH_PRIORITY	0
+
+typedef enum {
+
+	HWE_PHONEJACK_PLUG = 0,
+	HWE_BAT_CHARGER_PLUG,
+	HWE_BAT_CHARGER_OVERVOLTAGE,
+	HWE_BAT_BATTERY_LOW,
+	HWE_BAT_POWER_FAILED,
+	HWE_BAT_CHARGER_FULL,
+	HWE_POWER_KEY,
+} HW_EVENT_T;
+
+typedef enum {
+
+	PJT_NONE = 0,
+	PJT_CVBS,
+	PJT_HEADSET,
+} PHONEJACK_TYPE;
+
+typedef enum {
+
+	PWRK_UNPRESS = 0,
+	PWRK_PRESS,
+} POWERKEY_TYPE;
+
+typedef enum {
+
+	UNPLUG = 0,
+	PLUGGED,
+} PLUG_TYPE;
+
+struct mxc_hw_event {
+	unsigned int event;
+	int args;
+};
+
+#ifdef __KERNEL__
+extern int hw_event_send(int priority, struct mxc_hw_event *new_event);
+#endif
+
+#endif				/* HW_EVENT_H */
diff --git a/arch/arm/plat-mxc/include/mach/io.h b/arch/arm/plat-mxc/include/mach/io.h
index b4f2de7..ab4ac68 100644
--- a/arch/arm/plat-mxc/include/mach/io.h
+++ b/arch/arm/plat-mxc/include/mach/io.h
@@ -34,6 +34,17 @@ __mx3_ioremap(unsigned long phys_addr, size_t size, unsigned int mtype)
 }
 #endif
 
+#ifdef CONFIG_ARCH_MX5
+#define __arch_ioremap __mx5_ioremap
+#define __arch_iounmap __iounmap
+
+static inline void __iomem *
+__mx5_ioremap(unsigned long phys_addr, size_t size, unsigned int mtype)
+{
+	return __arm_ioremap(phys_addr, size, mtype);
+}
+#endif
+
 /* io address mapping macro */
 #define __io(a)		__typesafe_io(a)
 
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index 86781f7..cd07001 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -7,6 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include "hardware.h"
 
 #ifndef __ASM_ARCH_MXC_IRQS_H__
 #define __ASM_ARCH_MXC_IRQS_H__
@@ -20,6 +21,12 @@
 #define MXC_INTERNAL_IRQS	64
 #endif
 
+#ifdef CONFIG_ARCH_MX3
+#define IRQ_PMU_MXC	MX3x_INT_EVTMON
+#elif defined(CONFIG_ARCH_MX5)
+#define IRQ_PMU_MXC	MX51_MXC_INT_PMU
+#endif
+
 #define MXC_GPIO_IRQ_START	MXC_INTERNAL_IRQS
 
 /* these are ordered by size to support multi-SoC kernels */
@@ -69,4 +76,12 @@ extern int imx_irq_set_priority(unsigned char irq, unsigned char prio);
 /* switch betwean IRQ and FIQ */
 extern int mxc_set_irq_fiq(unsigned int irq, unsigned int type);
 
+#define MXC_IRQ_TO_EXPIO(irq)   ((irq) - MXC_BOARD_IRQ_START)
+
+/*
+ * This function is used to get the AVIC Lo and Hi interrupts
+ * that are enabled as wake up sources to wake up the core from suspend
+ */
+void mxc_get_wake_irq(u32 *wake_src[]);
+
 #endif /* __ASM_ARCH_MXC_IRQS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index c4b40c3..bfb79eb 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -52,4 +52,12 @@
 #define CONSISTENT_DMA_SIZE SZ_4M
 #endif /* CONFIG_MX1_VIDEO */
 
+#ifdef CONFIG_ARCH_MX51
+#define CONSISTENT_DMA_SIZE (32 * SZ_1M)
+#endif
+
+#ifdef CONFIG_ARCH_MX31
+#define CONSISTENT_DMA_SIZE (32 * SZ_1M)
+#endif
+
 #endif /* __ASM_ARCH_MXC_MEMORY_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mmc.h b/arch/arm/plat-mxc/include/mach/mmc.h
index de2128d..e64df27 100644
--- a/arch/arm/plat-mxc/include/mach/mmc.h
+++ b/arch/arm/plat-mxc/include/mach/mmc.h
@@ -33,4 +33,20 @@ struct imxmmc_platform_data {
 	void (*setpower)(struct device *, unsigned int vdd);
 };
 
+struct mxc_mmc_platform_data {
+	unsigned int ocr_mask;	/* available voltages */
+	unsigned int vendor_ver;
+	unsigned int caps;
+	unsigned int min_clk;
+	unsigned int max_clk;
+	unsigned int clk_flg;	/* 1 clock enable, 0 not */
+	unsigned int reserved:16;
+	unsigned int card_fixed:1;
+	unsigned int card_inserted_state:1;
+	unsigned int (*status) (struct device *);
+	int (*wp_status) (struct device *);
+	char *power_mmc;
+	char *clock_mmc;
+};
+
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/mx31.h b/arch/arm/plat-mxc/include/mach/mx31.h
index fb90e11..dc1bafc 100644
--- a/arch/arm/plat-mxc/include/mach/mx31.h
+++ b/arch/arm/plat-mxc/include/mach/mx31.h
@@ -26,6 +26,7 @@
 #define MX31_I2C_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x80000)
 #define MX31_I2C3_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x84000)
 #define MX31_OTG_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x88000)
+#define OTG_BASE_ADDR				MX31_OTG_BASE_ADDR
 #define MX31_ATA_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x8c000)
 #define MX31_UART1_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x90000)
 #define MX31_UART2_BASE_ADDR			(MX31_AIPS1_BASE_ADDR + 0x94000)
@@ -54,6 +55,14 @@
 #define MX31_MSHC1_BASE_ADDR			(MX31_SPBA0_BASE_ADDR + 0x24000)
 #define MX31_SPBA_CTRL_BASE_ADDR		(MX31_SPBA0_BASE_ADDR + 0x3c000)
 
+#define SPBA_SDHC1		0x04
+#define SPBA_SDHC2		0x08
+#define SPBA_UART3		0x0C
+#define SPBA_CSPI2              0x10
+#define SPBA_SSI2               0x14
+#define SPBA_SIM		0x18
+#define SPBA_IIM		0x1C
+#define SPBA_ATA                0x20
 #define MX31_AIPS2_BASE_ADDR		0x53f00000
 #define MX31_AIPS2_BASE_ADDR_VIRT	0xfc200000
 #define MX31_AIPS2_SIZE			SZ_1M
@@ -76,6 +85,7 @@
 #define MX31_SDMA_BASE_ADDR			(MX31_AIPS2_BASE_ADDR + 0xd4000)
 #define MX31_RTC_BASE_ADDR			(MX31_AIPS2_BASE_ADDR + 0xd8000)
 #define MX31_WDOG_BASE_ADDR			(MX31_AIPS2_BASE_ADDR + 0xdc000)
+#define WDOG1_BASE_ADDR				MX31_WDOG_BASE_ADDR
 #define MX31_PWM_BASE_ADDR			(MX31_AIPS2_BASE_ADDR + 0xe0000)
 #define MX31_RTIC_BASE_ADDR			(MX31_AIPS2_BASE_ADDR + 0xec000)
 
@@ -138,6 +148,91 @@ static inline void mx31_setup_weimcs(size_t cs,
 }
 #endif
 
+/*
+* DMA request assignments
+*/
+#define DMA_REQ_ECT        31
+#define DMA_REQ_NFC        30
+#define DMA_REQ_SSI1_TX1   29
+#define DMA_REQ_SSI1_RX1   28
+#define DMA_REQ_SSI1_TX2   27
+#define DMA_REQ_SSI1_RX2   26
+#define DMA_REQ_SSI2_TX1   25
+#define DMA_REQ_SSI2_RX1   24
+#define DMA_REQ_SSI2_TX2   23
+#define DMA_REQ_SSI2_RX2   22
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_EXTREQ1    15
+#define DMA_REQ_EXTREQ2    14
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_CCM        1
+#define DMA_REQ_EXTREQ0    0
+
+/*!
+* Defines for modules using static and dynamic DMA channels
+*/
+
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_IRAM         30
+#endif                          /*CONFIG_SDMA_IRAM */
+
+#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
+#else                           /*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#endif                          /*CONFIG_SDMA_IRAM */
+
+#define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIFO_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+* DMA request assignments
+*/
+#define DMA_REQ_SDHC2      21
+#define DMA_REQ_SDHC1      20
+#define DMA_REQ_FIRI_TX    17
+#define DMA_REQ_FIRI_RX    16
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_CSPI3_TX   11
+#define DMA_REQ_CSPI3_RX   10
+#define DMA_REQ_UART5_TX   11
+#define DMA_REQ_UART5_RX   10
+#define DMA_REQ_UART3_TX   9
+#define DMA_REQ_UART3_RX   8
+#define DMA_REQ_SIM        5
+
 #define MX31_INT_I2C3		3
 #define MX31_INT_I2C2		4
 #define MX31_INT_MPEG4_ENCODER	5
@@ -248,4 +343,13 @@ static inline void mx31_setup_weimcs(size_t cs,
 #define MXC_INT_PCMCIA MX31_INT_PCMCIA
 #endif
 
+#define MXC_IDE_DMA_WATERMARK	32	/* DMA watermark level in bytes */
+#define MXC_IDE_DMA_BD_NR	(512/3/4)	/* Number of BDs per channel */
+
+#define DPTC_GP_ID 0
+#define DPTC_LP_ID 1
 #endif /* ifndef __MACH_MX31_H__ */
+
+#if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
+extern void mx31_arch_idle(void);
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mx3x.h b/arch/arm/plat-mxc/include/mach/mx3x.h
index 7a356de..84235b1 100644
--- a/arch/arm/plat-mxc/include/mach/mx3x.h
+++ b/arch/arm/plat-mxc/include/mach/mx3x.h
@@ -269,6 +269,8 @@ static inline int mx31_revision(void)
 }
 #endif
 
+#define IMX_NEEDS_DEPRECATED_SYMBOLS
+
 #ifdef IMX_NEEDS_DEPRECATED_SYMBOLS
 /* these should go away */
 #define L2CC_BASE_ADDR MX3x_L2CC_BASE_ADDR
diff --git a/arch/arm/plat-mxc/include/mach/mx51.h b/arch/arm/plat-mxc/include/mach/mx51.h
index 5aad344..66f67ff 100644
--- a/arch/arm/plat-mxc/include/mach/mx51.h
+++ b/arch/arm/plat-mxc/include/mach/mx51.h
@@ -1,6 +1,41 @@
 #ifndef __ASM_ARCH_MXC_MX51_H__
 #define __ASM_ARCH_MXC_MX51_H__
 
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
+#define MXC_SDMA_V2
+
+/*!
+ * The maximum frequency that the pixel clock can be at so as to
+ * activate DVFS-PER.
+ */
+#define DVFS_MAX_PIX_CLK	54000000
+
 /*
  * MX51 memory map:
  *
@@ -40,12 +75,52 @@
 #define MX51_IRAM_BASE_ADDR_VIRT	0xFA3E0000
 #define MX51_IRAM_PARTITIONS		16
 #define MX51_IRAM_PARTITIONS_TO1	12
-#define MX51_IRAM_SIZE		(MX51_IRAM_PARTITIONS * SZ_8K)	/* 128KB */
+#define MX51_IRAM_SIZE		(MX51_IRAM_PARTITIONS * 0x2000)	/* 128KB */
+
+
+#if defined(CONFIG_MXC_SECURITY_SCC2) \
+    || defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
+#define SCC_IRAM_SIZE  0x4000
+#else
+#define SCC_IRAM_SIZE  0
+#endif
+
+#ifdef CONFIG_SDMA_IRAM
+#define SDMA_IRAM_SIZE  CONFIG_SDMA_IRAM_SIZE
+#else
+#define SDMA_IRAM_SIZE  0
+#endif
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x6000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#ifdef CONFIG_MXC_VPU_IRAM
+#define VPU_IRAM_SIZE  0x7000
+#else
+#define VPU_IRAM_SIZE 0
+#endif
+
+#if (MX51_IRAM_SIZE < (SDMA_IRAM_SIZE + SND_RAM_SIZE + VPU_IRAM_SIZE + \
+		SCC_IRAM_SIZE))
+#error "IRAM size exceeded"
+#endif
+
+#define SCC_IRAM_BASE_ADDR \
+	(MX51_IRAM_BASE_ADDR + MX51_IRAM_SIZE - SCC_IRAM_SIZE)
+#define VPU_IRAM_BASE_ADDR	(SCC_IRAM_BASE_ADDR - VPU_IRAM_SIZE)
+#define SND_RAM_BASE_ADDR	(VPU_IRAM_BASE_ADDR - SND_RAM_SIZE)
+#define SDMA_IRAM_BASE_ADDR	(SND_RAM_BASE_ADDR - SDMA_IRAM_SIZE)
+#define IDLE_IRAM_BASE_ADDR	(SDMA_IRAM_BASE_ADDR - 0x1000)
+#define SUSPEND_IRAM_BASE_ADDR	(IDLE_IRAM_BASE_ADDR - 0x1000)
 
 /*
  * NFC
  */
 #define MX51_NFC_AXI_BASE_ADDR		0xCFFF0000	/* NAND flash AXI */
+#define MX51_NFC_AXI_BASE_ADDR_VIRT	0xF9000000
 #define MX51_NFC_AXI_SIZE		SZ_64K
 
 /*
@@ -133,6 +208,7 @@
 #define MX51_CCM_BASE_ADDR	(MX51_AIPS1_BASE_ADDR + 0x000D4000)
 #define MX51_GPC_BASE_ADDR	(MX51_AIPS1_BASE_ADDR + 0x000D8000)
 
+#define DVFSPER_BASE_ADDR	(MX51_GPC_BASE_ADDR + 0x1C4)
 /*
  * Defines for modules using static and dynamic DMA channels
  */
@@ -240,6 +316,7 @@
 	MX51_IS_MODULE(x, SPBA0) ? MX51_SPBA0_IO_ADDRESS(x) :	\
 	MX51_IS_MODULE(x, AIPS1) ? MX51_AIPS1_IO_ADDRESS(x) :	\
 	MX51_IS_MODULE(x, AIPS2) ? MX51_AIPS2_IO_ADDRESS(x) : \
+	MX51_IS_MODULE(x, NFC_AXI) ? MX51_NFC_AXI_IO_ADDRESS(x) : \
 	0xDEADBEEF)
 
 /*
@@ -260,6 +337,9 @@
 #define MX51_AIPS2_IO_ADDRESS(x)  \
 	(((x) - MX51_AIPS2_BASE_ADDR) + MX51_AIPS2_BASE_ADDR_VIRT)
 
+#define MX51_NFC_AXI_IO_ADDRESS(x)  \
+	(((x) - MX51_NFC_AXI_BASE_ADDR) + MX51_NFC_AXI_BASE_ADDR_VIRT)
+
 #define MX51_IS_MEM_DEVICE_NONSHARED(x)		0
 
 /*
@@ -435,11 +515,71 @@
 #define MX51_CHIP_REV_3_1	0x31
 #define MX51_CHIP_REV_3_2	0x32
 
+#define IMX_NEEDS_DEPRECATED_SYMBOLS
+
+#ifdef IMX_NEEDS_DEPRECATED_SYMBOLS
+#define IO_ADDRESS(x)		MX51_IO_ADDRESS(x)
+#define KPP_BASE_ADDR		MX51_KPP_BASE_ADDR
+#define MXC_INT_KPP		MX51_MXC_INT_KPP
+#define SPBA_CTRL_BASE_ADDR	MX51_SPBA_CTRL_BASE_ADDR
+#define CSD0_BASE_ADDR		MX51_CSD0_BASE_ADDR
+#define MXC_INT_SDMA		MX51_MXC_INT_SDMA
+#define SDMA_BASE_ADDR		MX51_SDMA_BASE_ADDR
+#define OTG_BASE_ADDR		MX51_OTG_BASE_ADDR
+#define MXC_INT_GPC1		MX51_MXC_INT_GPC1
+#define GPC_BASE_ADDR		MX51_GPC_BASE_ADDR
+#define M4IF_BASE_ADDR		MX51_M4IF_BASE_ADDR
+#define SPDIF_BASE_ADDR		MX51_SPDIF_BASE_ADDR
+#define MXC_INT_SPDIF		MX51_MXC_INT_SPDIF
+#define AUDMUX_BASE_ADDR	MX51_AUDMUX_BASE_ADDR
+#define SSI1_BASE_ADDR		MX51_SSI1_BASE_ADDR
+#define SSI2_BASE_ADDR		MX51_SSI2_BASE_ADDR
+#define MXC_INT_SSI1		MX51_MXC_INT_SSI1
+#define MXC_INT_SSI2		MX51_MXC_INT_SSI2
+#define VPU_BASE_ADDR		MX51_VPU_BASE_ADDR
+#define MXC_INT_VPU		MX51_MXC_INT_VPU
+#define SRC_BASE_ADDR		MX51_SRC_BASE_ADDR
+#define NFC_BASE_ADDR_AXI	MX51_NFC_AXI_BASE_ADDR
+#define MXC_INT_NFC		MX51_MXC_INT_NFC
+#define NFC_BASE_ADDR		MX51_NFC_BASE_ADDR
+#define IRAM_BASE_ADDR		MX51_IRAM_BASE_ADDR
+#define IIM_BASE_ADDR		MX51_IIM_BASE_ADDR
+#define SCC_BASE_ADDR		MX51_SCC_BASE_ADDR
+#define MXC_INT_SCC_SCM		MX51_MXC_INT_SCC_SCM
+#define MXC_INT_SCC_SMN		MX51_MXC_INT_SCC_SMN
+#define SAHARA_BASE_ADDR	MX51_SAHARA_BASE_ADDR
+#define MXC_INT_SAHARA_H0	MX51_MXC_INT_SAHARA_H0
+#define MXC_DMA_CHANNEL_IRAM	MX51_MXC_DMA_CHANNEL_IRAM
+#define IRAM_BASE_ADDR_VIRT	MX51_IRAM_BASE_ADDR_VIRT
+
+#define CHIP_REV_1_0		MX51_CHIP_REV_1_0
+#define CHIP_REV_1_1		MX51_CHIP_REV_1_1
+#define CHIP_REV_1_2		MX51_CHIP_REV_1_2
+#define CHIP_REV_1_3		MX51_CHIP_REV_1_3
+#define CHIP_REV_2_0		MX51_CHIP_REV_2_0
+#define CHIP_REV_2_1		MX51_CHIP_REV_2_1
+#define CHIP_REV_2_2		MX51_CHIP_REV_2_2
+#define CHIP_REV_2_3		MX51_CHIP_REV_2_3
+#define CHIP_REV_3_0		MX51_CHIP_REV_3_0
+#define CHIP_REV_3_1		MX51_CHIP_REV_3_1
+#define CHIP_REV_3_2		MX51_CHIP_REV_3_2
+
+#define BOARD_REV_1		0x000
+#define BOARD_REV_2		0x100
+#endif
+
 /* Mandatory defines used globally */
 
 #if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
 
 extern int mx51_revision(void);
+extern void mx51_arch_idle(void);
+extern void mx51_reset_fixup(void);
+extern int g_di1_tvout;
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
 #endif
 
+#define dmac_inv_range dmac_flush_range
+#define dmac_clean_range dmac_flush_range
+
 #endif	/*  __ASM_ARCH_MXC_MX51_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index a790bf2..af840dc 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -30,6 +30,7 @@
 #define MXC_CPU_MX27		27
 #define MXC_CPU_MX31		31
 #define MXC_CPU_MX35		35
+#define MXC_CPU_MX37		37
 #define MXC_CPU_MX51		51
 #define MXC_CPU_MXC91231	91231
 
@@ -109,6 +110,18 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mx35()		(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX37
+# ifdef mxc_cpu_type
+#  undef mxc_cpu_type
+#  define mxc_cpu_type __mxc_cpu_type
+# else
+#  define mxc_cpu_type MXC_CPU_MX37
+# endif
+# define cpu_is_mx37()		(mxc_cpu_type == MXC_CPU_MX37)
+#else
+# define cpu_is_mx37()		(0)
+#endif
+
 #ifdef CONFIG_ARCH_MX5
 # ifdef mxc_cpu_type
 #  undef mxc_cpu_type
@@ -133,6 +146,520 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mxc91231()	(0)
 #endif
 
+#define cpu_is_mx32()		(0)
+
+/*
+ * Create inline functions to test for cpu revision
+ * Function name is cpu_is_<cpu name>_rev(rev)
+ *
+ * Returns:
+ *	 0 - not the cpu queried
+ *	 1 - cpu and revision match
+ *	 2 - cpu matches, but cpu revision is greater than queried rev
+ *	-1 - cpu matches, but cpu revision is less than queried rev
+ */
+#ifndef __ASSEMBLY__
+extern unsigned int system_rev;
+#define mxc_set_system_rev(part, rev) ({	\
+	system_rev = (part << 12) | rev;	\
+})
+#define mxc_cpu()		(system_rev >> 12)
+#define mxc_cpu_rev()		(system_rev & 0xFF)
+#define mxc_cpu_rev_major()	((system_rev >> 4) & 0xF)
+#define mxc_cpu_rev_minor()	(system_rev & 0xF)
+#define mxc_cpu_is_rev(rev)	\
+	((mxc_cpu_rev() == rev) ? 1 : ((mxc_cpu_rev() < rev) ? -1 : 2))
+#define cpu_rev(type)				\
+static inline int type## _rev(int rev)		\
+{						\
+	return type() ? mxc_cpu_is_rev(rev) : 0;	\
+}
+cpu_rev(cpu_is_mx21);
+cpu_rev(cpu_is_mx25);
+cpu_rev(cpu_is_mx27);
+cpu_rev(cpu_is_mx31);
+cpu_rev(cpu_is_mx35);
+cpu_rev(cpu_is_mx37);
+cpu_rev(cpu_is_mx51);
+
+
+#include <linux/types.h>
+
+/*!
+ * This structure is used to define the One wire platform data.
+ * It includes search rom accelerator.
+ */
+struct mxc_w1_config {
+	int search_rom_accelerator;
+};
+/*!
+ * This structure is used to define the SPI master controller's platform
+ * data. It includes the SPI  bus number and the maximum number of
+ * slaves/chips it supports.
+ */
+struct mxc_spi_master {
+	/*!
+	 * SPI Master's bus number.
+	 */
+	unsigned int bus_num;
+	/*!
+	 * SPI Master's maximum number of chip selects.
+	 */
+	unsigned int maxchipselect;
+	/*!
+	 * CSPI Hardware Version.
+	 */
+	unsigned int spi_version;
+	/*!
+	 * CSPI chipselect pin table.
+	 * Workaround for ecspi chipselect pin may not keep correct level when
+	 * idle.
+	 */
+	void (*chipselect_active) (int cspi_mode, int status, int chipselect);
+	void (*chipselect_inactive) (int cspi_mode, int status, int chipselect);
+};
+
+struct mxc_ipu_config {
+	int rev;
+	struct clk *di_clk[2];
+};
+
+struct mxc_ir_platform_data {
+	int uart_ir_mux;
+	int ir_rx_invert;
+	int ir_tx_invert;
+	struct clk *uart_clk;
+};
+
+struct mxc_i2c_platform_data {
+	u32 i2c_clk;
+};
+
+/*
+ * This struct is to define the number of SSIs on a platform,
+ * DAM source port config, DAM external port config,
+ * regulator names, and other stuff audio needs.
+ */
+struct mxc_audio_platform_data {
+	int ssi_num;
+	int src_port;
+	int ext_port;
+
+	int intr_id_hp;
+	int ext_ram;
+	struct clk *ssi_clk[2];
+
+	int hp_irq;
+	int (*hp_status) (void);
+
+	int sysclk;
+
+	int (*init) (void);	/* board specific init */
+	int (*amp_enable) (int enable);
+	int (*finit) (void);	/* board specific finit */
+	void *priv;		/* used by board specific functions */
+};
+
+struct mxc_keypad_platform_data {
+	u16 rowmax;
+	u16 colmax;
+	u32 irq;
+	u16 delay;
+	u16 learning;
+	u16 *matrix;
+};
+
+struct mxc_spdif_platform_data {
+	int spdif_tx;
+	int spdif_rx;
+	int spdif_clk_44100;
+	int spdif_clk_48000;
+	int spdif_clkid;
+	struct clk *spdif_clk;
+	struct clk *spdif_core_clk;
+	struct clk *spdif_audio_clk;
+};
+
+struct mxc_asrc_platform_data {
+	struct clk *asrc_core_clk;
+	struct clk *asrc_audio_clk;
+	unsigned int channel_bits;
+};
+
+struct mxc_bt_platform_data {
+	char *bt_vdd;
+	char *bt_vdd_parent;
+	char *bt_vusb;
+	char *bt_vusb_parent;
+	void (*bt_reset) (void);
+};
+
+struct mxc_lightsensor_platform_data {
+	char *vdd_reg;
+	int rext;
+};
+
+struct mxc_fb_platform_data {
+	struct fb_videomode *mode;
+	char *mode_str;
+	u32 interface_pix_fmt;
+};
+
+struct mxc_lcd_platform_data {
+	char *io_reg;
+	char *core_reg;
+	char *analog_reg;
+	void (*reset) (void);
+};
+
+
+struct mxc_tsc_platform_data {
+	char *vdd_reg;
+	int penup_threshold;
+	void (*active) (void);
+	void (*inactive) (void);
+};
+
+struct mxc_tvout_platform_data {
+	char *io_reg;
+	char *core_reg;
+	char *analog_reg;
+	u32 detect_line;
+};
+
+struct mxc_tvin_platform_data {
+	char *dvddio_reg;
+	char *dvdd_reg;
+	char *avdd_reg;
+	char *pvdd_reg;
+	void (*pwdn) (int pwdn);
+	void (*reset) (void);
+};
+
+/*! Platform data for the IDE drive structure. */
+struct mxc_ide_platform_data {
+	char *power_drive;	/*!< The power pointer */
+	char *power_io;		/*!< The power pointer */
+};
+
+struct mxc_camera_platform_data {
+	char *core_regulator;
+	char *io_regulator;
+	char *analog_regulator;
+	char *gpo_regulator;
+	u32 mclk;
+	u32 csi;
+};
+
+/*gpo1-3 is in fixed state by hardware design,
+ * only deal with reset pin and clock_enable pin
+ * only poll mode can be used to control the chip,
+ * interrupt mode is not supported by 3ds*/
+struct mxc_fm_platform_data {
+	char *reg_vio;
+	char *reg_vdd;
+	void (*gpio_get) (void);
+	void (*gpio_put) (void);
+	void (*reset) (void);
+	void (*clock_ctl) (int flag);
+	u8	sksnr; /*0,disable;1,most stop;0xf,fewest stop*/
+	u8	skcnt; /*0,disable;1,most stop;0xf,fewest stop*/
+	/*
+	00 = 87.5-108 MHz (USA,Europe) (Default).
+	01 = 76-108 MHz (Japan wide band).
+	10 = 76-90 MHz (Japan).
+	11 = Reserved.
+	*/
+	u8	band;
+	/*
+	00 = 200 kHz (USA, Australia) (default).
+	01 = 100 kHz (Europe, Japan).
+	10 = 50 kHz.
+	*/
+	u8	space;
+	u8	seekth;
+};
+
+struct mxc_mma7450_platform_data {
+	char *reg_dvdd_io;
+	char *reg_avdd;
+	void (*gpio_pin_get) (void);
+	void (*gpio_pin_put) (void);
+	int int1;
+	int int2;
+};
+
+struct mxc_keyp_platform_data {
+	u16 *matrix;
+	void (*active) (void);
+	void (*inactive) (void);
+	char *vdd_reg;
+};
+
+struct mxc_unifi_platform_data {
+	void (*hardreset) (int pin_level);
+	void (*enable) (int en);
+	/* power parameters */
+	char *reg_gpo1;
+	char *reg_gpo2;
+	char *reg_1v5_ana_bb;
+	char *reg_vdd_vpa;
+	char *reg_1v5_dd;
+
+	int host_id;
+
+	void *priv;
+};
+
+struct mxc_gps_platform_data {
+	char *core_reg;
+	char *analog_reg;
+	struct regulator *gps_regu_core;
+	struct regulator *gps_regu_analog;
+};
+
+struct mxc_mlb_platform_data {
+	u32 buf_address;
+	u32 phy_address;
+	char *reg_nvcc;
+	char *mlb_clk;
+};
+
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	void (*xcvr_enable) (int id, int en);
+	void (*active) (int id);
+	void (*inactive) (int id);
+};
+
+struct mxc_srtc_platform_data {
+	u32 srtc_sec_mode_addr;
+};
+
+struct tve_platform_data {
+	char *dac_reg;
+	char *dig_reg;
+};
+
+struct fec_platform_data {
+	int (*init) (void);
+	int (*uninit) (void);
+	struct regulator *vddio_reg;
+};
+
+/* The name that links the i.MX NAND Flash Controller driver to its devices. */
+
+#define IMX_NFC_DRIVER_NAME  ("imx_nfc")
+
+/* Resource names for the i.MX NAND Flash Controller driver. */
+
+#define IMX_NFC_BUFFERS_ADDR_RES_NAME         \
+			("i.MX NAND Flash Controller Buffer")
+#define IMX_NFC_PRIMARY_REGS_ADDR_RES_NAME    \
+			("i.MX NAND Flash Controller Primary Registers")
+#define IMX_NFC_SECONDARY_REGS_ADDR_RES_NAME  \
+			("i.MX NAND Flash Controller Secondary Registers")
+#define IMX_NFC_INTERRUPT_RES_NAME            \
+			("i.MX NAND Flash Controller Interrupt")
+
+/**
+ * struct imx_nfc_platform_data - i.MX NFC driver platform data.
+ *
+ * This structure communicates information to the i.MX NFC driver that can't be
+ * expressed as resources.
+ *
+ * @nfc_major_version:  The "major version" of the NFC hardware.
+ * @nfc_minor_version:  The "minor version" of the NFC hardware.
+ * @force_ce:           If true, this flag causes the driver to assert the
+ *                      hardware chip enable signal for the currently selected
+ *                      chip as long as the MTD NAND Flash HAL has the chip
+ *                      selected (not just when an I/O transaction is in
+ *                      progress).
+ * @target_cycle_in_ns: The target read and write cycle period, in nanoseconds.
+ *                      NAND Flash part data sheets give minimum times for read
+ *                      and write cycles in nanoseconds (usually tRC and tWC,
+ *                      respectively). Set this value to the maximum of these
+ *                      two parameters. The driver will set the NFC clock as
+ *                      close as possible without violating this value.
+ * @clock_name:         The name of the clock used by the NAND Flash controller.
+ * @init:               A pointer to a function the driver must call so the
+ *                      platform can prepare for this device to operate. This
+ *                      pointer may be NULL.
+ * @exit:               A pointer to a function the driver must call so the
+ *                      platform clean up after this device stops operating.
+ *                      This pointer may be NULL.
+ * @set_page_size:      A pointer to a function the driver can call to set the
+ *                      page size. This pointer may be NULL.
+ *
+ *                      For some i.MX SoC's, the NFC gets information about the
+ *                      page size from signals driven by a system register
+ *                      outside the NFC. The address and format of this external
+ *                      register varies across SoC's. In other SoC's, the NFC
+ *                      still receives this signal, but it is overridden by a
+ *                      page size register in the NFC itself.
+ *
+ *                      For SoC's where the page size *must* be set in an
+ *                      external register, the driver must rely on a platform-
+ *                      specific function, and this member must point to it.
+ *
+ *                      For SoC's where the NFC has its own page size register,
+ *                      the driver will set that register itself and ignore the
+ *                      external signals. In this case, there's no need for the
+ *                      platform-specific function and this member must be NULL.
+ *
+ *                      This function accepts the page size in bytes (MTD calls
+ *                      this the "writesize") discovered by the NAND Flash MTD
+ *                      base driver (e.g., 512, 2048, 4096). This size refers
+ *                      specifically to the the data bytes in the page, *not*
+ *                      including out-of-band bytes. The return value is zero if
+ *                      the operation succeeded. The driver does *not* view a
+ *                      non-zero value as an error code - only an indication of
+ *                      failure. The driver will decide for itself what error
+ *                      code to return to its caller.
+ * @interleave:         Indicates that the driver should "interleave" the NAND
+ *                      Flash chips it finds. If true, the driver will aggregate
+ *                      the chips "horizontally" such that MTD will see a single
+ *                      chip with a potentially very large page size. This can
+ *                      improve write performance for some applications.
+ * @partitions:         An optional pointer to an array of partitions. If this
+ *                      is NULL, the driver will create a single MTD that
+ *                      represents the entire medium.
+ * @partition_count:    The number of elements in the partition array.
+ */
+
+struct imx_nfc_platform_data {
+	unsigned int          nfc_major_version;
+	unsigned int          nfc_minor_version;
+	int                   force_ce;
+	unsigned int          target_cycle_in_ns;
+	char                  *clock_name;
+	int                   (*init)(void);
+	void                  (*exit)(void);
+	int                   (*set_page_size)(unsigned int data_size_in_bytes);
+	int                   interleave;
+	struct mtd_partition  *partitions;
+	unsigned int	      partition_count;
+};
+
+extern void mxc_wd_reset(void);
+unsigned long board_get_ckih_rate(void);
+
+int mxc_snoop_set_config(u32 num, unsigned long base, int size);
+int mxc_snoop_get_status(u32 num, u32 *statl, u32 *stath);
+
+struct platform_device;
+void mxc_pg_enable(struct platform_device *pdev);
+void mxc_pg_disable(struct platform_device *pdev);
+
+struct mxc_unifi_platform_data *get_unifi_plat_data(void);
+
+struct mxc_sim_platform_data {
+	unsigned int clk_rate;
+	char *clock_sim;
+	char *power_sim;
+	int (*init)(struct platform_device *pdev);
+	void (*exit)(void);
+	unsigned int detect; /* 1 have detect pin, 0 not */
+};
+
+#endif				/* __ASSEMBLY__ */
+
+#define MUX_IO_P		29
+#define MUX_IO_I		24
+#define IOMUX_TO_GPIO(pin) \
+((((unsigned int)pin >> MUX_IO_P) * 32) + ((pin >> MUX_IO_I) & \
+((1 << (MUX_IO_P - MUX_IO_I)) - 1)))
+
+#define IOMUX_TO_IRQ(pin)	(MXC_GPIO_IRQ_START + IOMUX_TO_GPIO(pin))
+
+/* DMA driver defines */
+#define MXC_IDE_DMA_WATERMARK	32	/* DMA watermark level in bytes */
+#define MXC_IDE_DMA_BD_NR	(512/3/4)	/* Number of BDs per channel */
+
+#ifndef IS_MEM_DEVICE_NONSHARED
+/* all peripherals on MXC so far are below 0x80000000 but leave L2CC alone */
+#define IS_MEM_DEVICE_NONSHARED(x)  ((x) < 0x80000000 && (x) != L2CC_BASE_ADDR)
+#endif
+/*!
+ * DPTC GP and LP ID
+ */
+#define DPTC_GP_ID 0
+#define DPTC_LP_ID 1
+
+#ifndef __ASSEMBLY__
+
+struct cpu_wp {
+	u32 pll_reg;
+	u32 pll_rate;
+	u32 cpu_rate;
+	u32 pdr0_reg;
+	u32 pdf;
+	u32 mfi;
+	u32 mfd;
+	u32 mfn;
+	u32 cpu_voltage;
+	u32 cpu_podf;
+};
+
+#ifndef CONFIG_ARCH_MX51
+struct cpu_wp *get_cpu_wp(int *wp);
+#endif
+
+enum mxc_cpu_pwr_mode {
+	WAIT_CLOCKED,		/* wfi only */
+	WAIT_UNCLOCKED,		/* WAIT */
+	WAIT_UNCLOCKED_POWER_OFF,	/* WAIT + SRPG */
+	STOP_POWER_ON,		/* just STOP */
+	STOP_POWER_OFF,		/* STOP + SRPG */
+};
+
+struct fsl_xcvr_ops;
+
+int mxc_early_serial_console_init(char *);
+int set_low_bus_freq(void);
+int set_high_bus_freq(int high_bus_speed);
+int low_freq_bus_used(void);
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
+int tzic_enable_wake(int is_idle);
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops);
+
+void gpio_activate_audio_ports(void);
+void gpio_inactivate_audio_ports(void);
+void gpio_activate_bt_audio_port(void);
+void gpio_inactivate_bt_audio_port(void);
+void gpio_activate_esai_ports(void);
+void gpio_deactivate_esai_ports(void);
+void gpio_sensor_active(unsigned int csi_index);
+void gpio_sensor_inactive(unsigned int csi);
+void gpio_nand_active(void);
+void gpio_nand_inactive(void);
+void gpio_ata_active(void);
+void gpio_ata_inactive(void);
+int gpio_usbotg_hs_active(void);
+void gpio_usbotg_hs_inactive(void);
+void gpio_usbh1_setback_stp(void);
+void gpio_usbh2_setback_stp(void);
+void gpio_i2c_hs_inactive(void);
+void gpio_i2c_hs_active(void);
+void gpio_sdhc_active(int module);
+void gpio_sdhc_inactive(int module);
+void gpio_spdif_inactive(void);
+void gpio_spdif_active(void);
+
+extern int low_bus_freq_mode;
+extern int high_bus_freq_mode;
+extern int lp_high_freq;
+extern int lp_med_freq;
+extern int cpu_wp_nr;
+extern char *gp_reg_id;
+extern int cpufreq_trig_needed;
+extern int bus_freq_scaling_is_active;
+extern int mxc_jtag_enabled;
+#endif
+
 #if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX2)
 /* These are deprecated, use mx[23][157]_setup_weimcs instead. */
 #define CSCR_U(n) (IO_ADDRESS(WEIM_BASE_ADDR + n * 0x10))
diff --git a/arch/arm/plat-mxc/include/mach/mxc_dptc.h b/arch/arm/plat-mxc/include/mach/mxc_dptc.h
new file mode 100644
index 0000000..b42fc36
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_dptc.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DPTC Dynamic Process and Temperatur Compensation (DPTC) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_dptc.h
+ *
+ * @brief This file contains the DPTC configuration structure definition.
+ *
+ *
+ * @ingroup DPTC
+ */
+
+#ifndef __ASM_ARCH_MXC_DPTC_H__
+#define __ASM_ARCH_MXC_DPTC_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+#define DPTC_WP_SUPPORTED	17
+#define DPTC_GP_WP_SUPPORTED	7
+#define DPTC_LP_WP_SUPPORTED	9
+
+struct dptc_wp {
+	u32 dcvr0;
+	u32 dcvr1;
+	u32 dcvr2;
+	u32 dcvr3;
+	u32 voltage;
+};
+
+/*!
+ * This structure is used to define the dptc controller's platform
+ * data. It includes the regulator name string and DPTC clock name string.
+ */
+struct mxc_dptc_data {
+	/** Regulator name string */
+	char *reg_id;
+	/* DPTC clock name string */
+	char *clk_id;
+	/* Control reg address */
+	unsigned int dptccr_reg_addr;
+	/* Comparator value reg 0 address */
+	unsigned int dcvr0_reg_addr;
+	/* GPC control reg address */
+	unsigned int gpc_cntr_reg_addr;
+	/* DPTC interrupt status bit */
+	unsigned int dptccr;
+	/* The number of DPTC working points */
+	unsigned int dptc_wp_supported;
+	/* Maximum value of DPTC clock rate */
+	unsigned long clk_max_val;
+	/* DPTC working points */
+	struct dptc_wp *dptc_wp_allfreq;
+	/* DPTC enable bit */
+	u32 dptc_enable_bit;
+	/* DPTC ADU bit */
+	int gpc_adu;
+	/* VAI mask */
+	u32 vai_mask;
+	/* VAI offset */
+	int vai_offset;
+	/* Mask DPTC interrupt */
+	u32 irq_mask;
+	/* DPTC no voltage change request bit */
+	u32 dptc_nvcr_bit;
+	/* ARM interrrupt bit */
+	u32 gpc_irq_bit;
+	/* dptc init config */
+	u32 init_config;
+	/* dptc enable config */
+	u32 enable_config;
+	/* dptc counting range mask */
+	u32 dcr_mask;
+};
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ * @param   id   The DPTC device id. DPTC_GP_ID is for DPTC GP;
+ *               DPTC_LP_ID is for DPTC LP
+ */
+void dptc_suspend(int id);
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ * @param   id   The DPTC device id. DPTC_GP_ID is for DPTC GP;
+ *               DPTC_LP_ID is for DPTC LP
+ */
+void dptc_resume(int id);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_DPTC_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
new file mode 100644
index 0000000..b5e5be5
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DVFS Dynamic Voltage and Frequency Scaling (DVFS) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_dvfs.h
+ *
+ * @brief This file contains the DVFS configuration structure definition.
+ *
+ *
+ * @ingroup DVFS
+ */
+
+#ifndef __ASM_ARCH_MXC_DVFS_H__
+#define __ASM_ARCH_MXC_DVFS_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+#define MXC_GPCCNTR_GPCIRQ2M		(1 << 25)
+#define MXC_GPCCNTR_GPCIRQ2		(1 << 24)
+#define MXC_GPCCNTR_GPCIRQM		(1 << 21)
+#define MXC_GPCCNTR_GPCIRQ_ARM	(1 << 20)
+#define MXC_GPCCNTR_GPCIRQ_SDMA	(0 << 20)
+#define MXC_GPCCNTR_DVFS0CR		(1 << 16)
+#define MXC_GPCCNTR_DVFS1CR		(1 << 17)
+#define MXC_GPCCNTR_ADU_MASK		0x8000
+#define MXC_GPCCNTR_ADU			(1 << 15)
+#define MXC_GPCCNTR_STRT			(1 << 14)
+#define MXC_GPCCNTR_FUPD_MASK	0x2000
+#define MXC_GPCCNTR_FUPD			(1 << 13)
+#define MXC_GPCCNTR_HTRI_MASK		0x0000000F
+#define MXC_GPCCNTR_HTRI_OFFSET	0
+
+#define MXC_GPCVCR_VINC_MASK		0x00020000
+#define MXC_GPCVCR_VINC_OFFSET	17
+#define MXC_GPCVCR_VCNTU_MASK	0x00010000
+#define MXC_GPCVCR_VCNTU_OFFSET	16
+#define MXC_GPCVCR_VCNT_MASK		0x00007FFF
+#define MXC_GPCVCR_VCNT_OFFSET	0
+
+/* DVFS-PER */
+#define MXC_DVFSPER_PMCR0_UDCS			(1 << 27)
+#define MXC_DVFSPER_PMCR0_UDCS_MASK		0x8000000
+#define MXC_DVFSPER_PMCR0_ENABLE_MASK	0x10
+#define MXC_DVFSPER_PMCR0_ENABLE			(1 << 4)
+
+#define MXC_DVFS_PER_BASE	IO_ADDRESS(GPC_BASE_ADDR + 0x1C4)
+
+/* DVFS PER */
+#define MXC_DVFS_PER_LTR0	(MXC_DVFS_PER_BASE)
+#define MXC_DVFS_PER_LTR1	(MXC_DVFS_PER_BASE + 0x04)
+#define MXC_DVFS_PER_LTR2	(MXC_DVFS_PER_BASE + 0x08)
+#define MXC_DVFS_PER_LTR3	(MXC_DVFS_PER_BASE + 0x0C)
+#define MXC_DVFS_PER_LTBR0	(MXC_DVFS_PER_BASE + 0x10)
+#define MXC_DVFS_PER_LTBR1	(MXC_DVFS_PER_BASE + 0x14)
+#define MXC_DVFS_PER_PMCR0	(MXC_DVFS_PER_BASE + 0x18)
+#define MXC_DVFS_PER_PMCR1	(MXC_DVFS_PER_BASE + 0x1C)
+
+#define MXC_DVFSLTR0_UPTHR_MASK		0x0FC00000
+#define MXC_DVFSLTR0_UPTHR_OFFSET	22
+#define MXC_DVFSLTR0_DNTHR_MASK		0x003F0000
+#define MXC_DVFSLTR0_DNTHR_OFFSET	16
+
+#define MXC_DVFSLTR1_PNCTHR_MASK	0x0000003F
+#define MXC_DVFSLTR1_PNCTHR_OFFSET	0
+#define MXC_DVFSLTR1_DNCNT_MASK		0x003FC000
+#define MXC_DVFSLTR1_DNCNT_OFFSET	14
+#define MXC_DVFSLTR1_UPCNT_MASK		0x00003FC0
+#define MXC_DVFSLTR1_UPCNT_OFFSET	6
+#define MXC_DVFSLTR1_LTBRSR		0x800000
+#define MXC_DVFSLTR1_LTBRSH		0x400000
+
+#define MXC_DVFSLTR2_EMAC_MASK		0x000001FF
+#define MXC_DVFSLTR2_EMAC_OFFSET	0
+
+#define MXC_DVFSPMCR0_UDCS		0x8000000
+#define MXC_DVFSPMCR0_DVFEV		0x800000
+#define MXC_DVFSPMCR0_DVFIS		0x400000
+#define MXC_DVFSPMCR0_LBMI		0x200000
+#define MXC_DVFSPMCR0_LBFL		0x100000
+#define MXC_DVFSPMCR0_LBFC_MASK		0xC0000
+#define MXC_DVFSPMCR0_LBFC_OFFSET	18
+#define MXC_DVFSPMCR0_FSVAIM		0x00008000
+#define MXC_DVFSPMCR0_FSVAI_MASK	0x00006000
+#define MXC_DVFSPMCR0_FSVAI_OFFSET	13
+#define MXC_DVFSPMCR0_WFIM		0x00000400
+#define MXC_DVFSPMCR0_WFIM_OFFSET	10
+#define MXC_DVFSPMCR0_DVFEN		0x00000010
+
+#define MXC_DVFSPMCR1_P1INM		0x00100000
+#define MXC_DVFSPMCR1_P1ISM		0x00080000
+#define MXC_DVFSPMCR1_P1IFM		0x00040000
+#define MXC_DVFSPMCR1_P4PM		0x00020000
+#define MXC_DVFSPMCR1_P2PM		0x00010000
+
+/*
+ * DVFS structure
+ */
+struct dvfs_wp {
+	int upthr;
+	int downthr;
+	int panicthr;
+	int upcnt;
+	int downcnt;
+	int emac;
+};
+
+struct mxc_dvfs_platform_data {
+	/** Supply voltage regulator name string */
+	char *reg_id;
+	/* CPU clock name string */
+	char *clk1_id;
+	/* DVFS clock name string */
+	char *clk2_id;
+	/* GPC control reg address */
+	void __iomem *gpc_cntr_reg_addr;
+	/* GPC voltage counter reg address */
+	void __iomem *gpc_vcr_reg_addr;
+	/* CCM DVFS control reg address */
+	void __iomem *ccm_cdcr_reg_addr;
+	/* CCM ARM clock root reg address */
+	void __iomem *ccm_cacrr_reg_addr;
+	/* CCM divider handshake in-progree reg address */
+	void __iomem *ccm_cdhipr_reg_addr;
+	/* DVFS threshold reg address */
+	void __iomem *dvfs_thrs_reg_addr;
+	/* DVFS counters reg address */
+	void __iomem *dvfs_coun_reg_addr;
+	/* DVFS EMAC reg address */
+	void __iomem *dvfs_emac_reg_addr;
+	/* DVFS control reg address */
+	void __iomem *dvfs_cntr_reg_addr;
+	/* PREDIV mask */
+	u32 prediv_mask;
+	/* PREDIV offset */
+	int prediv_offset;
+	/* PREDIV value */
+	int prediv_val;
+	/* DIV3CK mask */
+	u32 div3ck_mask;
+	/* DIV3CK offset */
+	int div3ck_offset;
+	/* DIV3CK value */
+	int div3ck_val;
+	/* EMAC value */
+	int emac_val;
+	/* Frequency increase threshold. Increase frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int upthr_val;
+	/* Frequency decrease threshold. Decrease frequency change request
+	   will be sent if DVFS counter value will be less than this value */
+	int dnthr_val;
+	/* Panic threshold. Panic frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int pncthr_val;
+	/* The amount of times the up threshold should be exceeded
+	   before DVFS will trigger frequency increase request */
+	int upcnt_val;
+	/* The amount of times the down threshold should be exceeded
+	   before DVFS will trigger frequency decrease request */
+	int dncnt_val;
+	/* Delay time in us */
+	int delay_time;
+	/* Number of woking points supported */
+	int num_wp;
+};
+
+/*!
+ * This structure is used to define the dvfs controller's platform
+ * data. It includes the regulator name string and DVFS clock name string.
+ */
+struct mxc_dvfsper_data {
+	/** Regulator name string */
+	char *reg_id;
+	/* DVFS clock name string */
+	char *clk_id;
+	/* GPC control reg address */
+	void __iomem *gpc_cntr_reg_addr;
+	/* GPC VCR reg address */
+	void __iomem *gpc_vcr_reg_addr;
+	/* DVFS enable bit */
+	u32 dvfs_enable_bit;
+	/* DVFS ADU bit */
+	int gpc_adu;
+	/* VAI mask */
+	u32 vai_mask;
+	/* VAI offset */
+	int vai_offset;
+	/* Mask DVFS interrupt */
+	u32 irq_mask;
+	/* Div3 clock offset. */
+	u32 div3_offset;
+	/*div3 clock mask. */
+	u32 div3_mask;
+	/*div3 clock divider */
+	u32 div3_div;
+	/* LP voltage - high setpoint*/
+	u32 lp_high;
+	/* LP voltage - low setpoint*/
+	u32 lp_low;
+};
+
+
+extern struct dvfs_wp dvfs_core_setpoint[];
+extern int dvfs_core_is_active;
+void setup_pll(void);
+
+#if defined(CONFIG_MXC_DVFS_PER)
+extern int start_dvfs_per(void);
+extern void stop_dvfs_per(void);
+extern int dvfs_per_active(void);
+extern int dvfs_per_divider_active(void);
+extern int dvfs_per_pixel_clk_limit(void);
+#else
+static inline int start_dvfs_per(void)
+{
+	return 0;
+}
+
+static inline void stop_dvfs_per(void)
+{
+}
+
+static inline int dvfs_per_active(void)
+{
+	return 0;
+}
+
+static inline int dvfs_per_divider_active(void)
+{
+	return 0;
+}
+
+static inline int dvfs_per_pixel_clk_limit(void)
+{
+	return 0;
+}
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_DVFS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_gadget.h b/arch/arm/plat-mxc/include/mach/mxc_gadget.h
new file mode 100644
index 0000000..6edef1a
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_gadget.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __INCLUDE_ASM_ARCH_MXC_GADGET_H
+#define __INCLUDE_ASM_ARCH_MXC_GADGET_H
+
+struct mxc_gadget_platform_data {
+	int (*init)(struct platform_device *pdev);
+	int (*exit)(struct platform_device *pdev);
+};
+#endif /* __INCLUDE_ASM_ARCH_MXC_GADGET_H */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_nand.h b/arch/arm/plat-mxc/include/mach/mxc_nand.h
index 5d2d21d..c4316d0 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_nand.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_nand.h
@@ -22,7 +22,7 @@
 
 struct mxc_nand_platform_data {
 	int width;	/* data bus width in bytes */
-	int hw_ecc:1;	/* 0 if supress hardware ECC */
-	int flash_bbt:1; /* set to 1 to use a flash based bbt */
+	int hw_ecc;	/* 0 if supress hardware ECC */
+	struct flash_platform_data *flash_data;
 };
 #endif /* __ASM_ARCH_NAND_H */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_pm.h b/arch/arm/plat-mxc/include/mach/mxc_pm.h
new file mode 100644
index 0000000..b4d389a
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_pm.h
@@ -0,0 +1,252 @@
+
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup LPMD Low-Level Power Management Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_pm.h
+ *
+ * @brief This file contains the  chip level configuration details and
+ * public API declarations for CRM_AP module
+ *
+ * @ingroup LPMD
+ */
+
+#ifndef __ASM_ARCH_MXC_PM_H__
+#define __ASM_ARCH_MXC_PM_H__
+
+#define WAIT_MODE               111
+#define DOZE_MODE               112
+#define STOP_MODE               113
+#define DSM_MODE                114
+/*
+ * MXC91231 Break-Point Frequency below which is low frequency and
+ * above which is high frequency
+ */
+#define BREAKPT_FREQ            ((long)(400000000))
+
+#define GATE_STOP_WAIT          9
+#define GATE_STOP               10
+
+/*
+ * Used for MHz conversion
+ */
+#define MEGA_HERTZ              1000000
+
+/*
+ * If invalid frequency value other than the following
+ * CORE_133 - ARM desired to run @133MHz, LoV (1.2V)
+ * CORE_266 - ARM desired to run @266MHz, LoV (1.2V)
+ * CORE_399 - ARM desired to run @399MHz, LoV (1.2V)
+ * CORE_532 - ARM desired to run @133MHz, HiV (1.6V)
+ * are passed then this error is returned,
+ */
+#define ERR_FREQ_INVALID          1
+
+/*
+ * For MXC91231 Pass1, Integer DVFS greater than 133MHz is not allowed
+ * due to the hardware issue
+ */
+#define INTEGER_DVFS_NOT_ALLOW  1
+
+/*
+ * If PLL freq is less than desired ARM frequency during Integer
+ * DVFS, then return this error
+ */
+#define PLL_LESS_ARM_ERR        2
+
+/*
+ * Frequency change within the same-lo voltage is not approved.
+ * Inorder to do Integer DFS, move to the high voltage range and
+ * then set LFDF and move to the low voltage range
+ */
+#define INT_DFS_LOW_NOT_ALLOW   3
+
+/*
+ * If the desired AHB or IPG exceeds 133MHz or 66.5MHz respectively,
+ * then return this error
+ */
+#define AHB_IPG_EXCEED_LIMIT    4
+
+/*
+ * If the desired ARM frequency is too low to get by PLL scaling
+ * and the mxc_pm_pllscale API is called, return this error:
+ */
+#define PLL_DVFS_FREQ_TOO_LOW   5
+
+/*
+ * Invalid frequencies requested
+ */
+#define MXC_PM_INVALID_PARAM    6
+
+/*
+ * If AHB and/or IPG frequencies are greater than maximum allowed
+ */
+#define FREQ_OUT_OF_RANGE       2
+
+/*
+ * If AHB and/or IPG frequencies are other than 100 or 50Mhz
+ */
+#define BUS_FREQ_INVALID        2
+
+/*
+ * If MAX_PDF is greater than max value (8) then return this error
+ */
+#define AHB_MAX_DIV_ERR         3
+
+/*
+ * If IPG_PDF is greater than max value (2) then return this error
+ */
+#define IPG_MAX_DIV_ERR         4
+
+/*
+ * If ARM freq is out of range i.e., less than 133 or greater than
+ * 399 then return this error
+ */
+#define INVALID_ARM_FREQ        5
+
+/*
+ * This file includes all platform APIs. Some of the APIs are not
+ * appicable to some platforms. So, this error is used to indicate
+ * that a particular API is not available
+ */
+#define MXC_PM_API_NOT_SUPPORTED	6
+
+/*
+ * Error when frequency scaling is attempted while switch between MPLL and
+ * TPLL is in progress on MXC91321
+ */
+#define ERR_DFSP_SWITCH            2
+
+/*!
+ * Additional define for stop mode
+ */
+#define PM_SUSPEND_STOP         ((__force suspend_state_t) 2)
+
+/*!
+ * CKOH pins configuration
+ */
+#define CKOH_AP_SEL             1
+#define CKOH_AHB_SEL            2
+#define CKOH_IP_SEL             3
+
+/*!
+ * Defines for Stop and DSM mode acknowledgements
+ */
+#define MXC_PM_LOWPWR_ACK_SDMA  0x01
+#define MXC_PM_LOWPWR_ACK_IPU   0x02
+#define MXC_PM_LOWPWR_ACK_MAX   0x04
+#define MXC_PM_LOWPWR_ACK_MQSPI 0x08
+#define MXC_PM_LOWPWR_ACK_USB   0x10
+#define MXC_PM_LOWPWR_ACK_RTIC  0x20
+
+/*
+ * PMIC configuration
+ */
+#define MXC_PMIC_1_2_VOLT                      0xC
+#define MXC_PMIC_1_6_VOLT                      0x1C
+#define MXC_PMIC_1_0_VOLT                      0x4
+#if defined(CONFIG_ARCH_MXC91321) || defined(CONFIG_ARCH_MXC91231)
+#define MXC_PMIC_DVS_SPEED                     0x1
+#else
+#define MXC_PMIC_DVS_SPEED                     0x3
+#endif
+
+/*!
+ * Implementing Level 1 CRM Gate Control. Level 2 gate control
+ * is provided at module level using LPMD registers
+ *
+ * @param   group   The desired clock gate control register bits.
+ *                  Possible values are 0 through 6
+ * @param   opt     The desired option requesting clock to run during stop
+ *                  and wait modes or just during the stop mode. Possible
+ *                  values are GATE_STOP_WAIT and GATE_STOP.
+ *
+ */
+void mxc_pm_clockgate(int group, int opt);
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode);
+
+/*!
+ * Enables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to enable.
+ *
+ */
+void mxc_pm_lp_ack_enable(int ack);
+
+/*!
+ * Disables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to disable.
+ *
+ */
+void mxc_pm_lp_ack_disable(int ack);
+
+/*!
+ * Implementing steps required to set Integer Scaling
+ *
+ * @param   armfreq    The desired ARM frequency. AHB and IP
+ *                     frequency are changed depending on ARM
+ *                     frequency and the divider values.
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -PLL_LESS_ARM_ERR if pllfreq is less than
+ *                     desired core freq
+ */
+int mxc_pm_intscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To calculate MFI, MFN, MFD values. Using this the output frequency
+ * whose value is calculated using,
+ * 2 * REF_FREQ * (MF / PDF), where
+ * REF_FREQ is 26 Mhz
+ * MF = MFI + (MFN + MFD)
+ * PDF is assumed to be 1
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -1 on error
+ */
+int mxc_pm_pllscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To change AP core frequency and/or voltage suitably
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns -ERR_FREQ_INVALID on failure
+ *                     Returns 0 on success
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq);
+
+extern void mxc_pm_arch_entry(void *entry, u32 size);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_scc.h b/arch/arm/plat-mxc/include/mach/mxc_scc.h
new file mode 100644
index 0000000..d23f6c3
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_scc.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/mxc_scc.h
+ *
+ * @brief This is intended to be the file which contains all of code or changes
+ * needed to port the driver.
+ *
+ * @ingroup MXCSCC
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_H__
+#define __ASM_ARCH_MXC_SCC_H__
+
+#include <mach/hardware.h>
+
+/*!
+ * Expected to come from platform header files.
+ * This symbol must be the address of the SCC
+ */
+#define SCC_BASE        SCC_BASE_ADDR
+
+/*!
+ *  This must be the interrupt line number of the SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
+ *  the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_uart.h b/arch/arm/plat-mxc/include/mach/mxc_uart.h
new file mode 100644
index 0000000..d1db802
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_uart.h
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup UART Universal Asynchronous Receiver Transmitter (UART) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_uart.h
+ *
+ * @brief This file contains the UART configuration structure definition.
+ *
+ *
+ * @ingroup UART
+ */
+
+#ifndef __ASM_ARCH_MXC_UART_H__
+#define __ASM_ARCH_MXC_UART_H__
+
+#ifdef __KERNEL__
+
+#include <linux/serial_core.h>
+#include <mach/dma.h>
+
+/*
+ * The modes of the UART ports
+ */
+#define MODE_DTE                0
+#define MODE_DCE                1
+/*
+ * Is the UART configured to be a IR port
+ */
+#define IRDA                    0
+#define NO_IRDA                 1
+
+/*!
+ * This structure is used to store the the physical and virtual
+ * addresses of the UART DMA receive buffer.
+ */
+typedef struct {
+	/*!
+	 * DMA Receive buffer virtual address
+	 */
+	char *rx_buf;
+	/*!
+	 * DMA Receive buffer physical address
+	 */
+	dma_addr_t rx_handle;
+} mxc_uart_rxdmamap;
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b uart_port structure. This structure includes the core \b uart_port
+ * structure that is provided by Linux as an element and has other
+ * elements that are specifically required by this low-level driver.
+ */
+typedef struct {
+	/*!
+	 * The port structure holds all the information about the UART
+	 * port like base address, and so on.
+	 */
+	struct uart_port port;
+	/*!
+	 * Flag to determine if the interrupts are muxed.
+	 */
+	int ints_muxed;
+	/*!
+	 * Array that holds the receive and master interrupt numbers
+	 * when the interrupts are not muxed.
+	 */
+	int irqs[2];
+	/*!
+	 * Flag to determine the DTE/DCE mode.
+	 */
+	int mode;
+	/*!
+	 * Flag to hold the IR mode of the port.
+	 */
+	int ir_mode;
+	/*!
+	 * Flag to enable/disable the UART port.
+	 */
+	int enabled;
+	/*!
+	 * Flag to indicate if we wish to use hardware-driven hardware
+	 * flow control.
+	 */
+	int hardware_flow;
+	/*!
+	 * Holds the threshold value at which the CTS line is deasserted in
+	 * case we use hardware-driven hardware flow control.
+	 */
+	unsigned int cts_threshold;
+	/*!
+	 * Flag to enable/disable DMA data transfer.
+	 */
+	int dma_enabled;
+	/*!
+	 * Holds the DMA receive buffer size.
+	 */
+	int dma_rxbuf_size;
+	/*!
+	 * DMA Receive buffers information
+	 */
+	mxc_uart_rxdmamap *rx_dmamap;
+	/*!
+	 * DMA RX buffer id
+	 */
+	int dma_rxbuf_id;
+	/*!
+	 * DMA Transmit buffer virtual address
+	 */
+	char *tx_buf;
+	/*!
+	 * DMA Transmit buffer physical address
+	 */
+	dma_addr_t tx_handle;
+	/*!
+	 * Holds the RxFIFO threshold value.
+	 */
+	unsigned int rx_threshold;
+	/*!
+	 * Holds the TxFIFO threshold value.
+	 */
+	unsigned int tx_threshold;
+	/*!
+	 * Information whether this is a shared UART
+	 */
+	unsigned int shared;
+	/*!
+	 * Clock id for UART clock
+	 */
+	struct clk *clk;
+	/*!
+	 * Information whether RXDMUXSEL must be set or not for IR port
+	 */
+	int rxd_mux;
+	int ir_tx_inv;
+	int ir_rx_inv;
+	/*!
+	 * DMA ID for transmit
+	 */
+	mxc_dma_device_t dma_tx_id;
+	/*!
+	 * DMA ID for receive
+	 */
+	mxc_dma_device_t dma_rx_id;
+} uart_mxc_port;
+
+/* Address offsets of the UART registers */
+#define MXC_UARTURXD            0x000	/* Receive reg */
+#define MXC_UARTUTXD            0x040	/* Transmitter reg */
+#define	MXC_UARTUCR1            0x080	/* Control reg 1 */
+#define MXC_UARTUCR2            0x084	/* Control reg 2 */
+#define MXC_UARTUCR3            0x088	/* Control reg 3 */
+#define MXC_UARTUCR4            0x08C	/* Control reg 4 */
+#define MXC_UARTUFCR            0x090	/* FIFO control reg */
+#define MXC_UARTUSR1            0x094	/* Status reg 1 */
+#define MXC_UARTUSR2            0x098	/* Status reg 2 */
+#define MXC_UARTUESC            0x09C	/* Escape character reg */
+#define MXC_UARTUTIM            0x0A0	/* Escape timer reg */
+#define MXC_UARTUBIR            0x0A4	/* BRM incremental reg */
+#define MXC_UARTUBMR            0x0A8	/* BRM modulator reg */
+#define MXC_UARTUBRC            0x0AC	/* Baud rate count reg */
+#define MXC_UARTONEMS           0x0B0	/* One millisecond reg */
+#define MXC_UARTUTS             0x0B4	/* Test reg */
+
+/* Bit definations of UCR1 */
+#define MXC_UARTUCR1_ADEN       0x8000
+#define MXC_UARTUCR1_ADBR       0x4000
+#define MXC_UARTUCR1_TRDYEN     0x2000
+#define MXC_UARTUCR1_IDEN       0x1000
+#define MXC_UARTUCR1_RRDYEN     0x0200
+#define MXC_UARTUCR1_RXDMAEN    0x0100
+#define MXC_UARTUCR1_IREN       0x0080
+#define MXC_UARTUCR1_TXMPTYEN   0x0040
+#define MXC_UARTUCR1_RTSDEN     0x0020
+#define MXC_UARTUCR1_SNDBRK     0x0010
+#define MXC_UARTUCR1_TXDMAEN    0x0008
+#define MXC_UARTUCR1_ATDMAEN    0x0004
+#define MXC_UARTUCR1_DOZE       0x0002
+#define MXC_UARTUCR1_UARTEN     0x0001
+
+/* Bit definations of UCR2 */
+#define MXC_UARTUCR2_ESCI       0x8000
+#define MXC_UARTUCR2_IRTS       0x4000
+#define MXC_UARTUCR2_CTSC       0x2000
+#define MXC_UARTUCR2_CTS        0x1000
+#define MXC_UARTUCR2_PREN       0x0100
+#define MXC_UARTUCR2_PROE       0x0080
+#define MXC_UARTUCR2_STPB       0x0040
+#define MXC_UARTUCR2_WS         0x0020
+#define MXC_UARTUCR2_RTSEN      0x0010
+#define MXC_UARTUCR2_ATEN       0x0008
+#define MXC_UARTUCR2_TXEN       0x0004
+#define MXC_UARTUCR2_RXEN       0x0002
+#define MXC_UARTUCR2_SRST       0x0001
+
+/* Bit definations of UCR3 */
+#define MXC_UARTUCR3_DTREN      0x2000
+#define MXC_UARTUCR3_PARERREN   0x1000
+#define MXC_UARTUCR3_FRAERREN   0x0800
+#define MXC_UARTUCR3_DSR        0x0400
+#define MXC_UARTUCR3_DCD        0x0200
+#define MXC_UARTUCR3_RI         0x0100
+#define MXC_UARTUCR3_RXDSEN     0x0040
+#define MXC_UARTUCR3_AWAKEN     0x0010
+#define MXC_UARTUCR3_DTRDEN     0x0008
+#define MXC_UARTUCR3_RXDMUXSEL  0x0004
+#define MXC_UARTUCR3_INVT       0x0002
+
+/* Bit definations of UCR4 */
+#define MXC_UARTUCR4_CTSTL_OFFSET       10
+#define MXC_UARTUCR4_CTSTL_MASK         (0x3F << 10)
+#define MXC_UARTUCR4_INVR               0x0200
+#define MXC_UARTUCR4_ENIRI              0x0100
+#define MXC_UARTUCR4_REF16              0x0040
+#define MXC_UARTUCR4_IRSC               0x0020
+#define MXC_UARTUCR4_TCEN               0x0008
+#define MXC_UARTUCR4_OREN               0x0002
+#define MXC_UARTUCR4_DREN               0x0001
+
+/* Bit definations of UFCR */
+#define MXC_UARTUFCR_RFDIV              0x0200	/* Ref freq div is set to 2 */
+#define MXC_UARTUFCR_RFDIV_OFFSET       7
+#define MXC_UARTUFCR_RFDIV_MASK         (0x7 << 7)
+#define MXC_UARTUFCR_TXTL_OFFSET        10
+#define MXC_UARTUFCR_DCEDTE             0x0040
+
+/* Bit definations of URXD */
+#define MXC_UARTURXD_ERR        0x4000
+#define MXC_UARTURXD_OVRRUN     0x2000
+#define MXC_UARTURXD_FRMERR     0x1000
+#define MXC_UARTURXD_BRK        0x0800
+#define MXC_UARTURXD_PRERR      0x0400
+
+/* Bit definations of USR1 */
+#define MXC_UARTUSR1_PARITYERR  0x8000
+#define MXC_UARTUSR1_RTSS       0x4000
+#define MXC_UARTUSR1_TRDY       0x2000
+#define MXC_UARTUSR1_RTSD       0x1000
+#define MXC_UARTUSR1_FRAMERR    0x0400
+#define MXC_UARTUSR1_RRDY       0x0200
+#define MXC_UARTUSR1_AGTIM      0x0100
+#define MXC_UARTUSR1_DTRD       0x0080
+#define MXC_UARTUSR1_AWAKE      0x0010
+
+/* Bit definations of USR2 */
+#define MXC_UARTUSR2_TXFE       0x4000
+#define MXC_UARTUSR2_IDLE       0x1000
+#define MXC_UARTUSR2_RIDELT     0x0400
+#define MXC_UARTUSR2_RIIN       0x0200
+#define MXC_UARTUSR2_DCDDELT    0x0040
+#define MXC_UARTUSR2_DCDIN      0x0020
+#define MXC_UARTUSR2_TXDC       0x0008
+#define MXC_UARTUSR2_ORE        0x0002
+#define MXC_UARTUSR2_RDR        0x0001
+#define MXC_UARTUSR2_BRCD       0x0004
+
+/* Bit definations of UTS */
+#define MXC_UARTUTS_LOOP        0x1000
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_UART_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_vpu.h b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
new file mode 100644
index 0000000..8a42c7d
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup VPU Video Processor Unit Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_vpu.h
+ *
+ * @brief VPU system initialization and file operation definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __ASM_ARCH_MXC_VPU_H__
+#define __ASM_ARCH_MXC_VPU_H__
+
+#include <linux/fs.h>
+
+struct vpu_mem_desc {
+	u32 size;
+	dma_addr_t phy_addr;
+	u32 cpu_addr;		/* cpu address to free the dma mem */
+	u32 virt_uaddr;		/* virtual user space address */
+};
+
+#define VPU_IOC_MAGIC  'V'
+
+#define VPU_IOC_PHYMEM_ALLOC	_IO(VPU_IOC_MAGIC, 0)
+#define VPU_IOC_PHYMEM_FREE	_IO(VPU_IOC_MAGIC, 1)
+#define VPU_IOC_WAIT4INT	_IO(VPU_IOC_MAGIC, 2)
+#define VPU_IOC_PHYMEM_DUMP	_IO(VPU_IOC_MAGIC, 3)
+#define VPU_IOC_REG_DUMP	_IO(VPU_IOC_MAGIC, 4)
+#define VPU_IOC_VL2CC_FLUSH	_IO(VPU_IOC_MAGIC, 5)
+#define VPU_IOC_IRAM_SETTING	_IO(VPU_IOC_MAGIC, 6)
+#define VPU_IOC_CLKGATE_SETTING	_IO(VPU_IOC_MAGIC, 7)
+#define VPU_IOC_GET_WORK_ADDR   _IO(VPU_IOC_MAGIC, 8)
+#define VPU_IOC_GET_PIC_PARA_ADDR   _IO(VPU_IOC_MAGIC, 9)
+#define VPU_IOC_GET_USER_DATA_ADDR   _IO(VPU_IOC_MAGIC, 10)
+#define VPU_IOC_SYS_SW_RESET	_IO(VPU_IOC_MAGIC, 11)
+#define VPU_IOC_GET_SHARE_MEM   _IO(VPU_IOC_MAGIC, 12)
+
+#define BIT_CODE_RUN			0x000
+#define BIT_CODE_DOWN			0x004
+#define	BIT_INT_CLEAR			0x00C
+#define	BIT_INT_STATUS			0x010
+
+#define BIT_WORK_CTRL_BUF_BASE		0x100
+#define BIT_WORK_CTRL_BUF_REG(i)	(BIT_WORK_CTRL_BUF_BASE + i * 4)
+#define BIT_CODE_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(0)
+#define BIT_WORK_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(1)
+#define BIT_PARA_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(2)
+#define BIT_BIT_STREAM_CTRL		BIT_WORK_CTRL_BUF_REG(3)
+#define BIT_FRAME_MEM_CTRL		BIT_WORK_CTRL_BUF_REG(4)
+#define BIT_BIT_STREAM_PARAM		BIT_WORK_CTRL_BUF_REG(5)
+
+#define BIT_RESET_CTRL			0x11C
+
+/* i could be 0, 1, 2, 3 */
+#define	BIT_RD_PTR_BASE			0x120
+#define BIT_RD_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8)
+#define BIT_WR_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8 + 4)
+
+/* i could be 0, 1, 2, 3 */
+#define BIT_FRM_DIS_FLG_BASE		(cpu_is_mx51() ? 0x150 : 0x140)
+#define	BIT_FRM_DIS_FLG_REG(i)		(BIT_FRM_DIS_FLG_BASE + i * 4)
+
+#define BIT_BUSY_FLAG			0x160
+#define BIT_RUN_COMMAND			0x164
+#define BIT_INT_ENABLE			0x170
+
+#define	BITVAL_PIC_RUN			8
+
+#define	VPU_SLEEP_REG_VALUE		10
+#define	VPU_WAKE_REG_VALUE		11
+
+int vl2cc_init(u32 vl2cc_hw_base);
+void vl2cc_enable(void);
+void vl2cc_flush(void);
+void vl2cc_disable(void);
+void vl2cc_cleanup(void);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/pmic_audio.h b/arch/arm/plat-mxc/include/mach/pmic_audio.h
new file mode 100644
index 0000000..5092876
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/pmic_audio.h
@@ -0,0 +1,2329 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_AUDIO_H__
+#define __ASM_ARCH_MXC_PMIC_AUDIO_H__
+
+/*!
+ * @defgroup PMIC_AUDIO  PMIC Audio Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_audio.h
+ * @brief External definitions for the PMIC Audio Client driver.
+ *
+ * The PMIC Audio driver and this API were developed to support the
+ * audio playback, recording, and mixing capabilities of the power
+ * management ICs that are available from Freescale Semiconductor, Inc.
+ *
+ * The following table shows which audio-related capabilities are supported
+ * by each power management IC:
+ *
+ * @ingroup PMIC_AUDIO
+ */
+
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Audio Device Access Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to the
+ * PMIC Audio hardware.
+ */
+/*@{*/
+
+/*!
+ * @typedef PMIC_AUDIO_HANDLE
+ * @brief Define typedef for a handle to the PMIC Audio hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Audio hardware
+ * is opened. This handle grants exclusive access to the PMIC Audio
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Audio hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long *PMIC_AUDIO_HANDLE;
+
+/*!
+ * @enum PMIC_AUDIO_EVENTS
+ * @brief Identify the audio events that have been detected and should be
+ * handled.
+ *
+ * This enumeration defines all of the possible PMIC Audio events. Multiple
+ * events may be selected when defining a mask and multiple events may be
+ * signalled together.
+ *
+ * Note that the MICROPHONE_DETECT and MICROPHONE_REMOVED events may also be
+ * used to signal the operation of a serial or parallel microphone switch
+ * when used with a combined headset+microphone device. In that case the
+ * HEADSET_DETECT state must also be checked to determine if it's only the
+ * microphone switch being operated or whether the microphone has truly been
+ * inserted/removed (along with the headset).
+ */
+typedef enum _PMIC_AUDIO_EVENTS{
+	HEADSET_DETECTED = 1,	/*!< Detected headset insertion.      */
+	HEADSET_STEREO = 2,	/*!< Detected stereo headset device.  */
+	HEADSET_MONO = 4,	/*!< Detected mono headset device.    */
+	HEADSET_THERMAL_SHUTDOWN = 8,	/*!< Detected output amplifier */
+	/* shutdown due to thermal */
+	/*  limits . */
+	HEADSET_SHORT_CIRCUIT = 16,	/*!< Detected output amplifier */
+	/* short circuit condition */
+	HEADSET_REMOVED = 32,	/*!< Detected headset removal.        */
+	MICROPHONE_DETECTED = 64,	/*!< Detected microphone insertion.   */
+	MICROPHONE_REMOVED = 128,	/*!< Detected microphone removal.     */
+	PTT_BUTTON_PRESS = 256,	/*!< Detected PTT button down */
+	PTT_BUTTON_RANGE = 512,	/*!< Detected PTT button within */
+	/*  voltage range. */
+	PTT_SHORT_OR_INVALID = 1024	/*!< Detected PTT button outside */
+		/*  of voltage range or invalid*/
+		/*  device  . */
+} PMIC_AUDIO_EVENTS;
+
+/*!
+ * @typedef PMIC_AUDIO_CALLBACK
+ * @brief Typedef for PMIC Audio event notification callback function.
+ *
+ * Define a typedef for the PMIC Audio event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef PMIC_AUDIO_EVENTS(*PMIC_AUDIO_CALLBACK) (const PMIC_AUDIO_EVENTS event);
+
+typedef struct {
+	int hs_state;
+	int event_type;
+} PMIC_HS_STATE;
+
+/*!
+ * @enum PMIC_AUDIO_SOURCE
+ * @brief Select an audio signal processing component.
+ *
+ * This enumeration defines all of the possible PMIC audio signal handling
+ * components which can be acquired by calling pmic_audio_open().
+ *
+ * Note that the EXTERNAL_STEREO_IN selection is used to simply gain access
+ * to the stereo input pins. The stereo input signal can then be routed
+ * directly to the output amplifiers. In this case, no signal processing is
+ * done by either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum _PMIC_AUDIO_SOURCE{
+	STEREO_DAC,		/*!< Open connection to Stereo DAC. */
+	VOICE_CODEC,		/*!< Open connection to Voice CODEC. */
+	EXTERNAL_STEREO_IN	/*!< Open connection to external */
+		/* stereo inputs. */
+} PMIC_AUDIO_SOURCE;
+
+/*@}*/
+
+/*!
+ * @name Data Bus Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the data bus protocol in order to communicate with the Stereo DAC
+ * or the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_DATA_BUS
+ * @brief Select the data bus used to transfer data between the host and
+ *        Voice CODEC and/or the Stereo DAC.
+ *
+ * This enumeration defines all of the possible PMIC audio data buses that
+ * can be used to transfer data between the host and the Voice CODEC and/or
+ * the Stereo DAC on the PMIC.
+ *
+ * Note that the same data bus may be used to transfer audio data to/from
+ * the Voice CODEC and the Stereo DAC. However, in this case, the data bus
+ * must be configured for network mode with different timeslots assigned to
+ * the Voice CODEC and the Stereo DAC. Also, the sampling rates must be
+ * identical for both the Voice CODEC and the Stereo DAC in order to avoid
+ * a data bus timing conflict and audio signal distortion.
+ */
+typedef enum _PMIC_AUDIO_DATA_BUS{
+	AUDIO_DATA_BUS_1,	/*!< Use data bus 1 for audio data. */
+	AUDIO_DATA_BUS_2	/*!< Use data bus 2 for audio data. */
+} PMIC_AUDIO_DATA_BUS;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_PROTOCOL
+ * @brief Select the data bus protocol to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus protocols
+ * that may be selected.
+ */
+typedef enum _PMIC_AUDIO_BUS_PROTOCOL{
+	NORMAL_MSB_JUSTIFIED_MODE,	/*!< Transmit and receive audio data */
+	/*  in normal MSB-justified mode. */
+	NETWORK_MODE,		/*!< Transmit and receive audio data */
+	/*  in network mode. */
+	I2S_MODE,		/*!< Transmit and receive audio data */
+	/*  in I2S mode. */
+	SPD_IF_MODE		/*!< Transmit and receive audio data */
+		/* in SPD/IF mode. */
+} PMIC_AUDIO_BUS_PROTOCOL;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_MODE
+ * @brief Select the data bus mode to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus modes
+ * that may be selected. When configured in BUS_MASTER_MODE, the PMIC is
+ * responsible for supplying the data bus clock signals. Alternatively,
+ * when configured in BUS_SLAVE_MODE, the PMIC will use the data bus clock
+ * signals that are supplied by the bus master.
+ */
+typedef enum _PMIC_AUDIO_BUS_MODE{
+	BUS_MASTER_MODE = 0,	/*!< Operate as bus master.       */
+	BUS_SLAVE_MODE = 1	/*!< Operate as bus slave.        */
+} PMIC_AUDIO_BUS_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_IN_SOURCE
+ * @brief Select the clock signal source when in bus master mode.
+ *
+ * This enumeration defines all of the possible PMIC audio clock signal
+ * sources that may be selected. One of these clock signal sources must
+ * be selected in order to use either the Voice CODEC or the Stereo DAC.
+ *
+ * When configured in BUS_MASTER_MODE, the PMIC's onboard PLL circuits
+ * will also be driven by the selected clock input signal.
+ */
+typedef enum _PMIC_AUDIO_CLOCK_IN_SOURCE{
+	CLOCK_IN_DEFAULT,	/*!< Just use default */
+	/* (power-up) clock input.*/
+	CLOCK_IN_CLIA,		/*!< Use the CLIA clock */
+	/*  source (Stereo DAC default). */
+	CLOCK_IN_CLIB,		/*!< Use the CLIB clock source */
+	/*  (Voice CODEC default). */
+	CLOCK_IN_CLKIN,		/*!< Use the CLKIN clock source */
+	CLOCK_IN_MCLK,		/*!< Disable the internal PLL */
+	/* and use the MCLK clock */
+	/* source (Stereo DAC only) */
+	CLOCK_IN_FSYNC,		/*!< Internal PLL input from */
+	/* external framesync( Stereo DAC only). */
+	CLOCK_IN_BITCLK		/*!< Internal PLL input */
+		/* from external bitclock */
+		/* (Stereo DAC only) */
+} PMIC_AUDIO_CLOCK_IN_SOURCE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_INVERT
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration enables or disables the inversion of the incoming
+ * frame sync or bit clock signals.
+ */
+typedef enum _PMIC_AUDIO_CLOCK_INVERT{
+	NO_INVERT = 0,		/*!< Do not invert the clock signals.    */
+	INVERT_BITCLOCK = 1,	/*!< Invert the BCLK input signal.       */
+	INVERT_FRAMESYNC = 2	/*!< Invert the FSYNC input signal.      */
+} PMIC_AUDIO_CLOCK_INVERT;
+
+/*!
+ * @enum PMIC_AUDIO_NUMSLOTS
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration defines all of the possible number of timeslots that may
+ * be selected when the PMIC is configured as the data bus master. One of these
+ * options must be selected if the Stereo DAC is to provide the data bus
+ * clock signals.
+ *
+ * Note that the Voice CODEC currently only allows USE_4_TIMESLOTS when
+ * operating in data bus master mode.
+ */
+typedef enum _PMIC_AUDIO_NUMSLOTS{
+	USE_2_TIMESLOTS,	/*!< Configure for 2 timeslots. */
+	USE_4_TIMESLOTS,	/*!< Configure for 4 timeslots. */
+	USE_8_STAR_TIMESLOTS,	/*!< Configure for 8 */
+	/* (Left, Right, 6 other) timeslots. */
+	USE_8_TIMESLOTS		/*!< Configure for 8 timeslots. */
+} PMIC_AUDIO_NUMSLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Stereo DAC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Stereo DAC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum _PMIC_AUDIO_STDAC_SAMPLING_RATE{
+	STDAC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	STDAC_RATE_11_025_KHZ,	/*!< Use 11.025 kHz sampling rate. */
+	STDAC_RATE_12_KHZ,	/*!< Use 12 kHz sampling rate.     */
+	STDAC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+	STDAC_RATE_22_050_KHZ,	/*!< Use 22.050 kHz sampling rate. */
+	STDAC_RATE_24_KHZ,	/*!< Use 24 kHz sampling rate.     */
+	STDAC_RATE_32_KHZ,	/*!< Use 32 kHz sampling rate.     */
+	STDAC_RATE_44_1_KHZ,	/*!< Use 44.1 kHz sampling rate.   */
+	STDAC_RATE_48_KHZ,	/*!< Use 48 kHz sampling rate.     */
+	STDAC_RATE_64_KHZ,	/*!< Use 64 kHz sampling rate
+						  .          */
+	STDAC_RATE_96_KHZ	/*!< Use 96 kHz sampling rate.
+						  .          */
+} PMIC_AUDIO_STDAC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Voice CODEC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Voice CODEC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_SAMPLING_RATE{
+	VCODEC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	VCODEC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+} PMIC_AUDIO_VCODEC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+ * @brief Select the anti-pop circuitry's ramp up speed.
+ *
+ * This enumeration defines all of the possible ramp up speeds for the
+ * anti-pop circuitry. A slow ramp up speed may be required in order to
+ * avoid the popping noise that is typically generated during the insertion
+ * or removal of a headset or microphone.
+ */
+typedef enum _PMIC_AUDIO_ANTI_POP_RAMP_SPEED{
+	ANTI_POP_RAMP_FAST,	/*!< Select fast ramp up.          */
+	ANTI_POP_RAMP_SLOW	/*!< Select slow ramp up.          */
+} PMIC_AUDIO_ANTI_POP_RAMP_SPEED;
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+ * @brief Select the Voice CODEC input clock frequency.
+ *
+ * This enumeration defines all of the supported Voice CODEC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Voice CODEC to operate at the required sampling
+ * rate.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ{
+	VCODEC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.    */
+	VCODEC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz. */
+	VCODEC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+						  .         */
+	VCODEC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.    */
+	VCODEC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.  */
+} PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CONFIG
+ * @brief Select the Voice CODEC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Voice CODEC options.
+ * This includes the use of highpass digital filters and audio signal
+ * loopback modes.
+ *
+ * Note that resetting the digital filters is now handled by the
+ * pmic_audio_digital_filter_reset() API.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_CONFIG{
+	DITHERING = 1,		/*!< Enable/disable dithering.      */
+	INPUT_HIGHPASS_FILTER = 2,	/*!< Enable/disable the input high */
+	/* pass digital filter.*/
+	OUTPUT_HIGHPASS_FILTER = 4,	/*!< Enable/disable the output high */
+	/*  pass digital filter. */
+	ANALOG_LOOPBACK = 8,	/*!< Enable/disable the analog */
+	/* loopback path */
+	DIGITAL_LOOPBACK = 16,	/*!< Enable/disable the digital
+							  loopback path. */
+	VCODEC_MASTER_CLOCK_OUTPUTS = 32,	/*!< Enable/disable the */
+	/* bus master clock outputs. */
+	TRISTATE_TS = 64	/*!< Enable/disable FSYNC, BITCLK,*/
+		/* and TX tristate. */
+} PMIC_AUDIO_VCODEC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+ * @brief Select the Stereo DAC input clock frequency.
+ *
+ * This enumeration defines all of the supported Stereo DAC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Stereo DAC to operate at the required sampling
+ * rate.
+ */
+typedef enum _PMIC_AUDIO_STDAC_CLOCK_IN_FREQ{
+	STDAC_CLI_3_36864MHZ,	/*!< Clock frequency is 3.36864MHz
+							  .                */
+	STDAC_CLI_12MHZ,	/*!< Clock frequency is 12MHz.
+						  .                */
+	STDAC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.           */
+	STDAC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz.        */
+	STDAC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+						  .                */
+	STDAC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.           */
+	STDAC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.         */
+	STDAC_MCLK_PLL_DISABLED,	/*!< Use MCLK and */
+	/* disable internal PLL.  */
+	STDAC_FSYNC_IN_PLL,	/*!< Use FSYNC as internal PLL input.    */
+	STDAC_BCLK_IN_PLL	/*!< Use BCLK as internal PLL input.     */
+} PMIC_AUDIO_STDAC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CONFIG
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Stereo DAC options.
+ */
+typedef enum _PMIC_AUDIO_STDAC_CONFIG{
+	STDAC_MASTER_CLOCK_OUTPUTS = 1	/*!< Enable/dis the bus master clock */
+		/*  outputs.*/
+} PMIC_AUDIO_STDAC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name Voice CODEC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_TIMESLOT
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to select the timeslot for both the primary and
+ * secondary (for mc13783-only) audio channels to the Voice CODEC.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_TIMESLOT{
+	USE_TS0,		/*!< Use timeslot 0 for audio signal source
+					  .                    */
+	USE_TS1,		/*!< Use timeslot 1 for audio signal source
+					  .                    */
+	USE_TS2,		/*!< Use timeslot 2 for audio signal source
+					  .                    */
+	USE_TS3			/*!< Use timeslot 3 for audio signal source
+					  .                    */
+} PMIC_AUDIO_VCODEC_TIMESLOT;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the secondary channel input gain for the Voice
+ * CODEC mixer.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_MIX_IN_GAIN{
+	VCODEC_NO_MIX,		/*!< No audio mixing .  */
+	VCODEC_MIX_IN_0DB,	/*!< Mix with 0dB */
+	/* secondary channel gain
+	   .                  */
+	VCODEC_MIX_IN_MINUS_6DB,	/*!< Mix with -6dB */
+	/* secondary channel gain */
+	VCODEC_MIX_IN_MINUS_12DB,	/*!< Mix with -12dB */
+	/* secondary channel gain */
+} PMIC_AUDIO_VCODEC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the output gain for the Voice CODEC mixer.
+ */
+typedef enum _PMIC_AUDIO_VCODEC_MIX_OUT_GAIN{
+	VCODEC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain
+						  .                  */
+	VCODEC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain */
+} PMIC_AUDIO_VCODEC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Stereo DAC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_TIMESLOTS
+ * @brief Select the timeslots used to transmit the left and right audio
+ *        channels to the Stereo DAC.
+ *
+ * This enumeration is used to select the timeslots used to transmit the
+ * data corresponding to the left and right audio channels to the Stereo
+ * DAC.
+ */
+typedef enum _PMIC_AUDIO_STDAC_TIMESLOTS{
+	USE_TS0_TS1,		/*!< Use timeslots 0 and 1 for left and */
+	/* right channels, respectively.      */
+	USE_TS2_TS3,		/*!< Use timeslots 2 and 3 for left and */
+	/*right channels, respectively */
+	USE_TS4_TS5,		/*!< Use timeslots 4 and 5 for left and */
+	/*  right channels, respectively */
+	USE_TS6_TS7		/*!< Use timeslots 6 and 7 for left and */
+		/*  right channels, respectively */
+} PMIC_AUDIO_STDAC_TIMESLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the secondary channel input gain for
+ * the Stereo DAC mixer.
+ */
+typedef enum _PMIC_AUDIO_STDAC_MIX_IN_GAIN{
+	STDAC_NO_MIX,		/*!< No mixing, keep separate left
+						  and right audio channels.*/
+	STDAC_MIX_IN_0DB,	/*!< Mix left and right audio channels
+						  together with 0dB secondary
+						  channel gain.*/
+	STDAC_MIX_IN_MINUS_6DB,	/*!< Mix left and right audio channels
+						  together with -6dB secondary
+							  channel gain. */
+	STDAC_MIX_IN_MINUS_12DB	/*!< Mix left and right audio channels
+						  together with -12dB secondary
+							  channel gain . */
+} PMIC_AUDIO_STDAC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the output gain for the Stereo DAC
+ * mixer.
+ */
+typedef enum _PMIC_AUDIO_STDAC_MIX_OUT_GAIN{
+	STDAC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain.     */
+	STDAC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain. */
+} PMIC_AUDIO_STDAC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Microphone Input Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or microphone inputs for recording.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_MIC_BIAS
+ * @brief Select the microphone bias circuit to be enabled/disabled.
+ *
+ * This enumeration lists all of the available microphone bias circuits that
+ * may be enabled or disabled.
+ */
+typedef enum _PMIC_AUDIO_MIC_BIAS{
+	NO_BIAS = 0,		/*!< No microphone
+						  bias circuit selected. */
+	MIC_BIAS1 = 1,		/*!< Enable/disable
+						  microphone bias 1 circuit. */
+	MIC_BIAS2 = 2,		/*!< Enable/disable
+						  microphone bias 2 circuit. */
+} PMIC_AUDIO_MIC_BIAS;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_PORT
+ * @brief Select an audio input port for recording.
+ *
+ * This enumeration lists all of the available audio input ports that may
+ * be selected for a recording operation.
+ */
+typedef enum _PMIC_AUDIO_INPUT_PORT{
+	NO_MIC,			/*!< No microphone
+					  input selected. */
+	MIC1_LEFT,		/*!< Enable left/mono
+					  channel microphone input. */
+	MIC1_RIGHT_MIC_MONO,	/*!< Enable right
+					  channel microphone input. */
+	MIC2_AUX,		/*!< Enable auxiliary
+					  microphone input. */
+	TXIN_EXT		/*!< Enable external
+					  mono input. */
+} PMIC_AUDIO_INPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_MIC_STATE
+ * @brief Control whether the input microphone is on/off.
+ *
+ * This enumeration allows the currently selected input microphone amplifier
+ * to be turned on/off.
+ */
+typedef enum _PMIC_AUDIO_INPUT_MIC_STATE{
+	MICROPHONE_ON,		/*!< Turn microphone input on for recording. */
+	MICROPHONE_OFF		/*!< Turn microphone input off (mute).       */
+} PMIC_AUDIO_INPUT_MIC_STATE;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_CONFIG
+ * @brief Enable/disable the audio input options.
+ *
+ * This enumeration allows for enabling/disabling any of the audio input
+ * section options.
+ */
+typedef enum _PMIC_AUDIO_INPUT_CONFIG{
+	MIC_AMP_AUTO_DISABLE = 1	/* !< Enable/disable
+					   automatic disabling of
+					   microphone input
+					   amplifiers following
+					   headset insertion/removal */
+} PMIC_AUDIO_INPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_AMP_MODE
+ * @brief Select the operating mode for the microphone amplifiers.
+ *
+ * This enumeration is used to select the operating mode for the microphone
+ * amplifier.
+ */
+typedef enum _PMIC_AUDIO_MIC_AMP_MODE{
+	AMP_OFF,		/*!< Disable input amplifier.   */
+	VOLTAGE_TO_VOLTAGE,	/*!< Operate input amplifier in
+						  voltage-to-voltage mode
+						  .       */
+	CURRENT_TO_VOLTAGE	/*!< Operate input amplifier in
+						  current-to-voltage mode    */
+} PMIC_AUDIO_MIC_AMP_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_GAIN
+ * @brief Select the microphone amplifier gain level.
+ *
+ * This enumeration lists all of the available microphone amplifier gain
+ * levels.
+ */
+typedef enum _PMIC_AUDIO_MIC_GAIN{
+	MIC_GAIN_MINUS_8DB,	/*!< Select -8dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_7DB,	/*!< Select -7dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_6DB,	/*!< Select -6dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_5DB,	/*!< Select -5dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_4DB,	/*!< Select -4dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_3DB,	/*!< Select -3dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_2DB,	/*!< Select -2dB
+						  microphone amplifier gain */
+	MIC_GAIN_MINUS_1DB,	/*!< Select -1dB
+						  microphone amplifier gain */
+	MIC_GAIN_0DB,		/*!< Select 0dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_1DB,	/*!< Select 1dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_2DB,	/*!< Select 2dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_3DB,	/*!< Select 3dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_4DB,	/*!< Select 4dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_5DB,	/*!< Select 5dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_6DB,	/*!< Select 6dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_7DB,	/*!< Select 7dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_8DB,	/*!< Select 8dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_9DB,	/*!< Select 9dB microphone
+						  amplifier gain.  */
+	MIC_GAIN_PLUS_10DB,	/*!< Select 10dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_11DB,	/*!< Select 11dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_12DB,	/*!< Select 12dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_13DB,	/*!< Select 13dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_14DB,	/*!< Select 14dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_15DB,	/*!< Select 15dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_16DB,	/*!< Select 16dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_17DB,	/*!< Select 17dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_18DB,	/*!< Select 18dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_19DB,	/*!< Select 19dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_20DB,	/*!< Select 20dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_21DB,	/*!< Select 21dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_22DB,	/*!< Select 22dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_23DB,	/*!< Select 23dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_24DB,	/*!< Select 24dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_25DB,	/*!< Select 25dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_26DB,	/*!< Select 26dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_27DB,	/*!< Select 27dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_28DB,	/*!< Select 28dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_29DB,	/*!< Select 29dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_30DB,	/*!< Select 30dB microphone
+						  amplifier gain. */
+	MIC_GAIN_PLUS_31DB	/*!< Select 31dB microphone
+						  amplifier gain. */
+} PMIC_AUDIO_MIC_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or audio output ports for playback.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PORT
+ * @brief Select the audio output port.
+ *
+ * This enumeration lists all of the available audio output ports. One or
+ * more may be selected as desired to handle the output audio stream from
+ * either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_PORT{
+	MONO_SPEAKER = 1,	/*!< Select mono output speaker.            */
+	MONO_LOUDSPEAKER = 2,	/*!< Select mono loudspeaker
+							  .                   */
+	MONO_ALERT = 4,		/*!< Select mono alert output               */
+	MONO_EXTOUT = 8,	/*!< Select mono external output            */
+	MONO_CDCOUT = 16,	/*!< Select dedicated Voice CODEC output
+						  .                   */
+	STEREO_LEFT_LOW_POWER = 32,	/*!< Select stereo left chan low power
+						  output .            */
+	STEREO_HEADSET_LEFT = 64,	/*!< Select stereo headset left chan.*/
+	STEREO_HEADSET_RIGHT = 128,	/*!< Select str headset right chan.*/
+	STEREO_OUT_LEFT = 256,	/*!< Select stereo external left channel
+					  output .            */
+	STEREO_OUT_RIGHT = 512	/*!< Select stereo external right channel
+						  output .            */
+} PMIC_AUDIO_OUTPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_CONFIG
+ * @brief Enable/disable the audio output section options.
+ *
+ * This enumeration is used to enable/disable any of the audio output section
+ * options.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_CONFIG{
+	MONO_SPEAKER_INVERT_OUT_ONLY = 1, /*!< Enable/disable the non-inverted
+					  mono speaker output          */
+	MONO_LOUDSPEAKER_COMMON_BIAS = 2, /*!< Enable/disable the loudspeaker
+					  output amplifier common bias
+							  .            */
+	HEADSET_DETECT_ENABLE = 4, /*!< Enable/disable headset
+					  insertion/removal detection
+						  .            */
+	STEREO_HEADSET_AMP_AUTO_DISABLE = 8 /*!< Enable/disable automatic
+					  disabling of the stereo headset
+					  output amplifiers following
+				  headset insertion/removal.      */
+} PMIC_AUDIO_OUTPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_STEREO_IN_GAIN
+ * @brief Select the amplifier gain for the external stereo inputs.
+ *
+ * This enumeration is used to select the amplifier gain level to be used for
+ * the external stereo inputs.
+ */
+typedef enum _PMIC_AUDIO_STEREO_IN_GAIN{
+	STEREO_IN_GAIN_0DB,	/*!< Select 0dB external stereo signal
+				  input gain.                        */
+	STEREO_IN_GAIN_PLUS_18DB	/*!< Select 18dB external stereo signal
+						  input gain .    */
+} PMIC_AUDIO_STEREO_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PGA_GAIN
+ * @brief Select the output PGA amplifier gain level.
+ *
+ * This enumeration is used to select the output PGA amplifier gain level.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_PGA_GAIN{
+	OUTPGA_GAIN_MINUS_33DB,	/*!< Select -33dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_30DB,	/*!< Select -30dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_27DB,	/*!< Select -27dB output PGA gain
+							  .          */
+	OUTPGA_GAIN_MINUS_24DB,	/*!< Select -24dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_21DB,	/*!< Select -21dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_18DB,	/*!< Select -18dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_15DB,	/*!< Select -15dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_12DB,	/*!< Select -12dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_9DB,	/*!< Select -9dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_6DB,	/*!< Select -6dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_3DB,	/*!< Select -3dB output PGA gain.  */
+	OUTPGA_GAIN_0DB,	/*!< Select 0dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_3DB,	/*!< Select 3dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_6DB,	/*!< Select 6dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_9DB,	/*!< Select 9dB output PGA gain.
+							  .     */
+	OUTPGA_GAIN_PLUS_12DB,	/*!< Select 12dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_15DB,	/*!< Select 15dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_18DB,	/*!< Select 18dB output PGA gain
+							  .     */
+	OUTPGA_GAIN_PLUS_21DB	/*!< Select 21dB output PGA gain
+							  .     */
+} PMIC_AUDIO_OUTPUT_PGA_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+ * @brief Select the left/right channel balance gain level.
+ *
+ * This enumeration is used to select the balance gain level that is to be
+ * separately applied to the left and right audio channels.
+ */
+typedef enum _PMIC_AUDIO_OUTPUT_BALANCE_GAIN{
+	BAL_GAIN_MINUS_21DB,	/*!< Select -21dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_18DB,	/*!< Select -18dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_15DB,	/*!< Select -15dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_12DB,	/*!< Select -12dB channel balance
+							  gain .        */
+	BAL_GAIN_MINUS_9DB,	/*!< Select -9dB channel balance
+						  gain .        */
+	BAL_GAIN_MINUS_6DB,	/*!< Select -6dB channel balance
+						  gain .        */
+	BAL_GAIN_MINUS_3DB,	/*!< Select -3dB channel balance
+						  gain .        */
+	BAL_GAIN_0DB		/*!< Select 0dB channel balance gain. */
+} PMIC_AUDIO_OUTPUT_BALANCE_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_MODE
+ * @brief Select the output mono adder operating mode.
+ *
+ * This enumeration is used to select the operating mode for the mono adder
+ * in the audio output section.
+ */
+typedef enum _PMIC_AUDIO_MONO_ADDER_MODE{
+	MONO_ADDER_OFF,		/*!< Disable mono adder (keep separate
+						  left and right channels).*/
+	MONO_ADD_LEFT_RIGHT,	/*!< Add left and right channels.      */
+	MONO_ADD_OPPOSITE_PHASE,	/*!< Add left and right channels but
+				  with outputs in opposite phase.*/
+	STEREO_OPPOSITE_PHASE	/*!< Keep separate left and right
+				  channels but invert phase of left channel.*/
+} PMIC_AUDIO_MONO_ADDER_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+ * @brief Select the mono adder output amplifier gain level.
+ *
+ * This enumeration is used to select the output amplifier gain level for
+ * the mono adder.
+ */
+typedef enum _PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN{
+	MONOADD_GAIN_MINUS_6DB,	/*!< Select -6dB mono adder output gain
+							  .          */
+	MONOADD_GAIN_MINUS_3DB,	/*!< Select -3dB mono adder output gain
+							  .          */
+	MONOADD_GAIN_0DB	/*!< Select 0dB mono adder output gain. */
+} PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN;
+
+/*@}*/
+
+/***************************************************************************
+ *                       PMIC-SPECIFIC DEFINITIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name Definition of PMIC-specific Capabilities
+ * Constants that are used to define PMIC-specific capabilities.
+ */
+/*@{*/
+
+/*!
+ * Define the minimum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MIN_STDAC_SAMPLING_RATE_HZ;
+/*!
+ * Define the maximum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MAX_STDAC_SAMPLING_RATE_HZ;
+
+/*@}*/
+
+#define DEBUG_AUDIO
+
+#ifdef __KERNEL__
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Audio
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * This function enables the Headset detection mechanism in hardware
+ */
+PMIC_STATUS pmic_audio_set_autodetect(int val);
+
+/*!
+ * @brief Request exclusive access to the PMIC Audio hardware.
+ *
+ * Attempt to open and gain exclusive access to a key PMIC audio hardware
+ * component (e.g., the Stereo DAC or the Voice CODEC). Depending upon the
+ * type of audio operation that is desired and the nature of the audio data
+ * stream, the Stereo DAC and/or the Voice CODEC will be a required hardware
+ * component and needs to be acquired by calling this function.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls to complete
+ * the configuration of either the Stereo DAC or the Voice CODEC and along
+ * with any other associated audio hardware components that will be needed.
+ *
+ * The same handle must also be used in the close call when use of the PMIC
+ * audio hardware is no longer required.
+ *
+ * The open request will fail if the requested audio hardware component has
+ * already been acquired by a previous open call but not yet closed.
+ *
+ * @param[out]  handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param[in]   device          The required PMIC audio hardware component.
+ *
+ * @retval      PMIC_SUCCESS         If the open request was successful
+ * @retval      PMIC_PARAMETER_ERROR If the handle argument is NULL.
+ * @retval      PMIC_ERROR           If the audio hardware component is
+ *                                   unavailable.
+ */
+PMIC_STATUS pmic_audio_open(PMIC_AUDIO_HANDLE * const handle,
+		const PMIC_AUDIO_SOURCE device);
+
+/*!
+ * @brief Terminate further access to the PMIC audio hardware.
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_close(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure the data bus protocol to be used.
+ *
+ * Provide the parameters needed to properly configure the audio data bus
+ * protocol so that data can be read/written to either the Stereo DAC or
+ * the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   busID           Select data bus to be used.
+ * @param[in]   protocol        Select the data bus protocol.
+ * @param[in]   masterSlave     Select the data bus timing mode.
+ * @param[in]   numSlots        Define the number of timeslots (only if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the protocol parameters
+ *                                   are invalid.
+ */
+PMIC_STATUS pmic_audio_set_protocol(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_DATA_BUS busID,
+		const PMIC_AUDIO_BUS_PROTOCOL protocol,
+		const PMIC_AUDIO_BUS_MODE masterSlave,
+		const PMIC_AUDIO_NUMSLOTS numSlots);
+
+/*!
+ * @brief Retrieve the current data bus protocol configuration.
+ *
+ * Retrieve the parameters that define the current audio data bus protocol.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  busID           The data bus being used.
+ * @param[out]  protocol        The data bus protocol being used.
+ * @param[out]  masterSlave     The data bus timing mode being used.
+ * @param[out]  numSlots        The number of timeslots being used (if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_protocol(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_DATA_BUS * const busID,
+		PMIC_AUDIO_BUS_PROTOCOL * const protocol,
+		PMIC_AUDIO_BUS_MODE * const masterSlave,
+		PMIC_AUDIO_NUMSLOTS * const numSlots);
+
+/*!
+ * @brief Enable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly enable the Stereo DAC or the Voice CODEC to begin audio
+ * playback or recording as required. This should only be done after
+ * successfully configuring all of the associated audio components (e.g.,
+ * microphones, amplifiers, etc.).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be enabled.
+ */
+PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly disable the Stereo DAC or the Voice CODEC to end audio
+ * playback or recording as required.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be disabled.
+ */
+PMIC_STATUS pmic_audio_disable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their power on state.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset all audio hardware control registers to their power on state.
+ *
+ * This resets all of the audio hardware control registers back to their
+ * power on states. Use this function with care since it also invalidates
+ * (i.e., automatically closes) all currently opened device handles.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset_all(void);
+
+/*!
+ * @brief Set the Audio callback function.
+ *
+ * Register a callback function that will be used to signal PMIC audio
+ * events. For example, the OSS audio driver should register a callback
+ * function in order to be notified of headset connect/disconnect events.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   func            A pointer to the callback function.
+ * @param[in]   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_audio_set_callback(void *func,
+		const PMIC_AUDIO_EVENTS eventMask,
+		PMIC_HS_STATE *hs_state);
+
+/*!
+ * @brief Deregisters the existing audio callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_audio_set_callback().
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_clear_callback(void);
+
+/*!
+ * @brief Get the current audio callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  func            The current callback function.
+ * @param[out]  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_callback(PMIC_AUDIO_CALLBACK * const func,
+				    PMIC_AUDIO_EVENTS * const eventMask);
+
+/*!
+ * @brief Enable the anti-pop circuitry to avoid extra noise when inserting
+ *        or removing a external device (e.g., a headset).
+ *
+ * Enable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug. A slow ramp speed may be needed to avoid extra noise.
+ *
+ * @param[in]   rampSpeed       The desired anti-pop circuitry ramp speed.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   enabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_antipop_enable(const PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+		rampSpeed);
+
+/*!
+ * @brief Disable the anti-pop circuitry.
+ *
+ * Disable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   disabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_antipop_disable(void);
+
+/*!
+ * @brief Performs a reset of the Voice CODEC/Stereo DAC digital filter.
+ *
+ * This function performs a reset of the digital filter using the back-to-back
+ * SPI write procedure.
+ *
+ * @retval      PMIC_SUCCESS         If the digital filter was successfully
+ *                                   reset.
+ * @retval      PMIC_ERROR           If the digital filter could not be reset.
+ */
+PMIC_STATUS pmic_audio_digital_filter_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Get the most recent PTT button voltage reading.
+ *
+ * This function returns the most recent reading for the PTT button voltage.
+ * The value may be used during the processing of the PTT_BUTTON_RANGE event
+ * as part of the headset ID detection process.
+ *
+ * @retval      PMIC_SUCCESS         If the most recent PTT button voltage was
+ *                                   returned.
+ * @retval      PMIC_PARAMETER_ERROR If a NULL pointer argument was given.
+ */
+PMIC_STATUS pmic_audio_get_ptt_button_level(unsigned int *const level);
+
+#ifdef DEBUG_AUDIO
+
+/*!
+ * @brief Provide a hexadecimal dump of all PMIC audio registers (DEBUG only).
+ *
+ * This function is intended strictly for debugging purposes only (i.e.,
+ * the DEBUG macro must be defined) and will print the current values of the
+ * following PMIC registers:
+ *
+ * - AUD_CODEC (Voice CODEC state)
+ * - ST_DAC (Stereo DAC state)
+ * - RX_AUD_AMPS (audio input section state)
+ * - TX_AUD_AMPS (audio output section state)
+ *
+ * The register fields will also be decoded.
+ */
+void pmic_audio_dump_registers(void);
+
+#endif				/* DEBUG */
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice
+ * CODEC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Voice CODEC clock source and operating characteristics.
+ *
+ * Define the Voice CODEC clock source and operating characteristics. This
+ * must be done before the Voice CODEC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE
+		clockIn,
+		const PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_VCODEC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Voice CODEC clock source and operating characteristics.
+ *
+ * Get the current Voice CODEC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_VCODEC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Voice CODEC primary audio channel timeslot.
+ *
+ * Set the Voice CODEC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot);
+
+/*!
+ * @brief Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot);
+
+/*!
+ * @brief Set the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Set the Voice CODEC secondary audio channel timeslot. This function must be
+ * used if the default timeslot for the secondary audio channel is to be
+ * changed. The secondary audio channel timeslot is used to transmit the audio
+ * data that was recorded by the Voice CODEC from the secondary audio input
+ * channel.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		const
+		PMIC_AUDIO_VCODEC_TIMESLOT
+		timeslot);
+
+/*!
+ * @brief Get the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Get the Voice CODEC secondary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_secondary_txslot(const PMIC_AUDIO_HANDLE
+		handle,
+		PMIC_AUDIO_VCODEC_TIMESLOT *
+		const timeslot);
+
+/*!
+ * @brief Set/Enable the Voice CODEC options.
+ *
+ * Set or enable various Voice CODEC options. The available options include
+ * the use of dithering, highpass digital filters, and loopback modes.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Voice CODEC options.
+ *
+ * Clear or disable various Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_CONFIG
+		config);
+
+/*!
+ * @brief Get the current Voice CODEC options.
+ *
+ * Get the current Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Voice CODEC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_VCODEC_CONFIG *
+		const config);
+
+/*!
+ * @brief Enable the Voice CODEC bypass audio pathway.
+ *
+ * Enables the Voice CODEC bypass pathway for audio data. This allows direct
+ * output of the voltages on the TX data bus line to the output amplifiers
+ * (bypassing the digital-to-analog converters within the Voice CODEC).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Voice CODEC bypass audio pathway.
+ *
+ * Disables the Voice CODEC bypass pathway for audio data. This means that
+ * the TX data bus line will deliver digital data to the digital-to-analog
+ * converters within the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo
+ * DAC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Stereo DAC clock source and operating characteristics.
+ *
+ * Define the Stereo DAC clock source and operating characteristics. This
+ * must be done before the Stereo DAC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_clock(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_CLOCK_IN_SOURCE clockIn,
+		const PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+		clockFreq,
+		const PMIC_AUDIO_STDAC_SAMPLING_RATE
+		samplingRate,
+		const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Stereo DAC clock source and operating characteristics.
+ *
+ * Get the current Stereo DAC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_clock(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_CLOCK_IN_SOURCE *
+		const clockIn,
+		PMIC_AUDIO_STDAC_SAMPLING_RATE *
+		const samplingRate,
+		PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *
+		const clockFreq,
+		PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Stereo DAC primary audio channel timeslot.
+ *
+ * Set the Stereo DAC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		timeslot);
+
+/*!
+ * @brief Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_TIMESLOTS *
+		const timeslot);
+
+/*!
+ * @brief Set/Enable the Stereo DAC options.
+ *
+ * Set or enable various Stereo DAC options. The available options include
+ * enabling/disabling the bus master clock outputs.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Stereo DAC options.
+ *
+ * Clear or disable various Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Get the current Stereo DAC options.
+ *
+ * Get the current Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Stereo DAC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STDAC_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Input Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio
+ * input hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set/Enable the audio input section options.
+ *
+ * Set or enable various audio input section options. The only available
+ * option right now is to enable the automatic disabling of the microphone
+ * input amplifiers when a microphone/headset is inserted or removed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_input_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the audio input section options.
+ *
+ * Clear or disable various audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to be
+ *                              cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_input_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Get the current audio input section options.
+ *
+ * Get the current audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of audio input section options.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_input_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Recording Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio recording.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the microphone inputs to be used for Voice CODEC recording.
+ *
+ * Select left  and right microphone inputs for Voice CODEC
+ * recording. It is possible to disable or not use a particular microphone
+ * input channel by specifying NO_MIC as a parameter.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     Select the left microphone input channel.
+ * @param[in]   rightChannel    Select the right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input ports
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be successfully enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_PORT leftChannel,
+		const PMIC_AUDIO_INPUT_PORT rightChannel);
+
+/*!
+ * @brief Get the current microphone inputs being used for Voice CODEC
+ *        recording.
+ *
+ * Get the left  and right microphone inputs currently being
+ * used for Voice CODEC recording.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The left microphone input channel.
+ * @param[out]  rightChannel    The right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_PORT * const leftChannel,
+		PMIC_AUDIO_INPUT_PORT *
+		const rightChannel);
+
+/*!
+ * @brief Enable/disable the microphone input.
+ *
+ * This function enables/disables the current microphone input channel. The
+ * input amplifier is automatically turned off when the microphone input is
+ * disabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     The left microphone input channel state.
+ * @param[in]   rightChannel    the right microphone input channel state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input states
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		leftChannel,
+		const PMIC_AUDIO_INPUT_MIC_STATE
+		rightChannel);
+
+/*!
+ * @brief Return the current state of the microphone inputs.
+ *
+ * This function returns the current state (on/off) of the microphone
+ * input channels.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The current left microphone input channel
+ *                              state.
+ * @param[out]  rightChannel    the current right microphone input channel
+ *                              state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channel states
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channel states
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const leftChannel,
+		PMIC_AUDIO_INPUT_MIC_STATE *
+		const rightChannel);
+
+/*!
+ * @brief Set the microphone input amplifier mode and gain level.
+ *
+ * This function sets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannelMode  The left microphone input amplifier mode.
+ * @param[in]   leftChannelGain  The left microphone input amplifier gain level.
+ * @param[in]   rightChannelMode The right microphone input amplifier mode.
+ * @param[in]   rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifiers were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input amplifier
+ *                                   modes or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifiers could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_record_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		leftChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		leftChannelGain,
+		const PMIC_AUDIO_MIC_AMP_MODE
+		rightChannelMode,
+		const PMIC_AUDIO_MIC_GAIN
+		rightChannelGain);
+
+/*!
+ * @brief Get the current microphone input amplifier mode and gain level.
+ *
+ * This function gets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannelMode  The left microphone input amplifier mode.
+ * @param[out]  leftChannelGain  The left microphone input amplifier gain level.
+ * @param[out]  rightChannelMode The right microphone input amplifier mode.
+ * @param[out]  rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifier modes
+ *                                   and gain levels were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifier modes
+ *                                   and gain levels could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_record_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const leftChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const leftChannelGain,
+		PMIC_AUDIO_MIC_AMP_MODE *
+		const rightChannelMode,
+		PMIC_AUDIO_MIC_GAIN *
+		const rightChannelGain);
+
+/*!
+ * @brief Enable a microphone bias circuit.
+ *
+ * This function enables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be enabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit);
+
+/*!
+ * @brief Disable a microphone bias circuit.
+ *
+ * This function disables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_micbias(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MIC_BIAS
+		biasCircuit);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Voice CODEC mixer.
+ *
+ * This function configures and enables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_VCODEC_TIMESLOT
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+		gainOut);
+
+/*!
+ * @brief Disable the Voice CODEC mixer.
+ *
+ * This function disables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo DAC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Stereo DAC mixer.
+ *
+ * This function configures and enables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STDAC_TIMESLOTS
+		rxSecondaryTimeslot,
+		const PMIC_AUDIO_STDAC_MIX_IN_GAIN
+		gainIn,
+		const PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+		gainOut);
+
+/*!
+ * @brief Disable the Stereo DAC mixer.
+ *
+ * This function disables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio output
+ * section to support playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the audio output ports.
+ *
+ * This function selects the audio output ports to be used. This also enables
+ * the appropriate output amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   acquired.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   acquired.
+ */
+PMIC_STATUS pmic_audio_output_set_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Deselect/disable the audio output ports.
+ *
+ * This function disables the audio output ports that were previously enabled
+ * by calling pmic_audio_output_set_port().
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_output_clear_port(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Get the current audio output ports.
+ *
+ * This function retrieves the audio output ports that are currently being
+ * used.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  port                The audio output ports currently being used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_port(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PORT * const port);
+
+/*!
+ * @brief Set the gain level for the external stereo inputs.
+ *
+ * This function sets the gain levels for the external stereo inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The external stereo input gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_STEREO_IN_GAIN
+		gain);
+
+/*!
+ * @brief Get the current gain level for the external stereo inputs.
+ *
+ * This function retrieves the current gain levels for the external stereo
+ * inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current external stereo input gain
+ *                                  level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_STEREO_IN_GAIN *
+		const gain);
+
+/*!
+ * @brief Set the output PGA gain level.
+ *
+ * This function sets the audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_PGA_GAIN
+		gain);
+
+/*!
+ * @brief Get the output PGA gain level.
+ *
+ * This function retrieves the current audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_pgaGain(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_PGA_GAIN *
+		const gain);
+
+/*!
+ * @brief Enable the output mixer.
+ *
+ * This function enables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the output mixer.
+ *
+ * This function disables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure and enable the output balance amplifiers.
+ *
+ * This function configures and enables the output balance amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   leftGain            The desired left channel gain level.
+ * @param[in]   rightGain           The desired right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifiers were
+ *                                   successfully configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifiers could not
+ *                                   be reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_output_set_balance(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		leftGain,
+		const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+		rightGain);
+
+/*!
+ * @brief Get the current output balance amplifier gain levels.
+ *
+ * This function retrieves the current output balance amplifier gain levels.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  leftGain            The current left channel gain level.
+ * @param[out]  rightGain           The current right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifier gain levels
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifier gain levels
+ *                                   could be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_balance(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const leftGain,
+		PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+		const rightGain);
+
+/*!
+ * @brief Configure and enable the output mono adder.
+ *
+ * This function configures and enables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   mode                The desired mono adder operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mono adder mode was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be reconfigured
+ *                                   or enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mono_adder(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_MODE
+		mode);
+
+/*!
+ * @brief Disable the output mono adder.
+ *
+ * This function disables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mono_adder(const PMIC_AUDIO_HANDLE
+		handle);
+
+/*!
+ * @brief Configure the mono adder output gain level.
+ *
+ * This function configures the mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The desired output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_output_set_mono_adder_gain(
+		const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN gain);
+
+/*!
+ * @brief Get the current mono adder output gain level.
+ *
+ * This function retrieves the current mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_mono_adder_gain(const PMIC_AUDIO_HANDLE
+						  handle,
+					PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+						  * const gain);
+
+/*!
+ * @brief Set various audio output section options.
+ *
+ * This function sets one or more audio output section configuration
+ * options. The currently supported options include whether to disable
+ * the non-inverting mono speaker output, enabling the loudspeaker common
+ * bias circuit, enabling detection of headset insertion/removal, and
+ * whether to automatically disable the headset amplifiers when a headset
+ * insertion/removal has been detected.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be set.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG config);
+
+/*!
+ * @brief Clear various audio output section options.
+ *
+ * This function clears one or more audio output section configuration
+ * options.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be cleared.
+ */
+PMIC_STATUS pmic_audio_output_clear_config(const PMIC_AUDIO_HANDLE handle,
+		const PMIC_AUDIO_OUTPUT_CONFIG
+		config);
+
+/*!
+ * @brief Get the current audio output section options.
+ *
+ * This function retrieves the current audio output section configuration
+ * option settings.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  config              The current audio output section
+ *                                  configuration option settings.
+ *
+ * @retval      PMIC_SUCCESS         If the current configuration options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the current configuration options
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_config(const PMIC_AUDIO_HANDLE handle,
+		PMIC_AUDIO_OUTPUT_CONFIG *
+		const config);
+
+/*!
+ * @brief Enable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function enables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_phantom_ground(void);
+
+/*!
+ * @brief Disable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function disables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_phantom_ground(void);
+
+/*@}*/
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_AUDIO_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/pmic_convity.h b/arch/arm/plat-mxc/include/mach/pmic_convity.h
new file mode 100644
index 0000000..c2b997f
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/pmic_convity.h
@@ -0,0 +1,871 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_CONVITY_H__
+#define __ASM_ARCH_MXC_PMIC_CONVITY_H__
+
+/*!
+ * @defgroup PMIC_CONNECTIVITY PMIC Connectivity Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_convity.h
+ * @brief External definitions for the PMIC Connectivity Client driver.
+ *
+ * The PMIC Connectivity driver and this API were developed to support the
+ * external connectivity capabilities of several power management ICs that
+ * are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes, in terms of external connectivity, are
+ * supported:
+ *
+ *
+ *
+ * @ingroup PMIC_CONNECTIVITY
+ */
+
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to and
+ * configuration of the PMIC Connectivity hardware.
+ */
+/*@{*/
+
+#define DEBUG_CONVITY
+
+/*!
+ * @typedef PMIC_CONVITY_HANDLE
+ * @brief Define typedef for a handle to the PMIC Connectivity hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Connectivity hardware
+ * is opened. This handle grants exclusive access to the PMIC Connectivity
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Connectivity hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long PMIC_CONVITY_HANDLE;
+
+/*!
+ * @enum PMIC_CONVITY_MODE
+ * @brief Select the main Connectivity operating mode.
+ *
+ * Defines all possible PMIC Connectivity main operating modes. Only one of
+ * these modes can be active at a time.
+ */
+typedef enum {
+	USB,			/*!< Select USB mode */
+	RS232,			/*!< Select RS-232 mode. for SC55112 */
+	RS232_1,		/*!< Select RS-232_1 mode.*/
+	RS232_2,		/*!< Select RS-232_2 mode. */
+	CEA936_MONO,		/*!< Select CE-936 Mono mode .    */
+	CEA936_STEREO,		/*!< Select CE-936 Stereo mode .  */
+	CEA936_TEST_RIGHT,	/*!< Select CE-936 Right Channel Test mode
+				   .                            */
+	CEA936_TEST_LEFT	/*!< Select CE-936 Left Channel Test mode
+				   .                            */
+} PMIC_CONVITY_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_EVENTS
+ * @brief Identify the connectivity events that have been detected and should
+ * be handled.
+ *
+ * Defines all possible PMIC Connectivity events. Multiple events may be
+ * selected when defining a mask.
+ */
+typedef enum {
+	USB_DETECT_4V4_RISE = 1,	/*!< Detected 4.4V rising edge.      */
+	USB_DETECT_4V4_FALL = 2,	/*!< Detected 4.4V falling edge.     */
+	USB_DETECT_2V0_RISE = 4,	/*!< Detected 2.0V rising edge.      */
+	USB_DETECT_2V0_FALL = 8,	/*!< Detected 2.0V falling edge.     */
+	USB_DETECT_0V8_RISE = 16,	/*!< Detected 0.8V rising edge.      */
+	USB_DETECT_0V8_FALL = 32,	/*!< Detected 0.8V falling edge.     */
+	USB_DETECT_MINI_A = 64,	/*!< Detected USB mini A plug.       */
+	USB_DETECT_MINI_B = 128,	/*!< Detected USB mini B plug.       */
+	USB_DETECT_NON_USB_ACCESSORY = 256, /*!< Detected a non-USB con.*/
+	USB_DETECT_FACTORY_MODE = 512,	/*!< Detected a factory-mode
+					   connection . */
+	USB_DP_HI = 1024,
+
+	USB_DM_HI = 2048
+} PMIC_CONVITY_EVENTS;
+
+/*!
+ * @typedef PMIC_CONVITY_CALLBACK
+ * @brief Typedef for PMIC Connectivity event notification callback function.
+ *
+ * Define a typedef for the PMIC Connectivity event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef void (*PMIC_CONVITY_CALLBACK) (const PMIC_CONVITY_EVENTS event);
+
+/*@}*/
+
+/*!
+ * @name USB and USB On-The-Go Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the USB and USB On-The-Go modes of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_USB_DEVICE_TYPE
+ * @brief Select the USB device type (either A or B).
+ *
+ * Defines all possible USB device types. This must match the physical
+ * connector being used.
+ */
+typedef enum {
+	USB_A_DEVICE,
+	USB_B_DEVICE
+} PMIC_CONVITY_USB_DEVICE_TYPE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_SPEED
+ * @brief Select the USB transceiver operating speed.
+ *
+ * Defines all possible USB transceiver operating speeds. Only one
+ * speed setting may be used at a time.
+ */
+typedef enum {
+	USB_LOW_SPEED,		/*!< Select 1.5 Mbps.              */
+	USB_FULL_SPEED,		/*!< Select 12 Mbps.               */
+	USB_HIGH_SPEED		/*!< Select 480 Mbps <b>(currently
+				   not supported)</b>.           */
+} PMIC_CONVITY_USB_SPEED;
+
+/*!
+ * @enum PMIC_CONVITY_USB_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all possible USB transceiver operating modes. Only one
+ * mode may be used at a time. The selected mode, in combination with
+ * the USB bus speed, determines the selection of pull-up and pull-down
+ * resistors.
+ */
+typedef enum {
+	USB_HOST,
+	USB_PERIPHERAL
+} PMIC_CONVITY_USB_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_IN
+ * @brief Select the USB transceiver's power regulator input source.
+ *
+ * Defines all possible input power sources for the USB transceiver power
+ * regulator. Only one power supply source may be selected at a time.
+ */
+typedef enum {
+
+	USB_POWER_INTERNAL_BOOST,	/*!< Select internal power source
+					   with boost.                  */
+
+	USB_POWER_VBUS,		/*!< Select VBUS power source.    */
+
+	USB_POWER_INTERNAL	/*!< Select internal power source
+				   .         */
+} PMIC_CONVITY_USB_POWER_IN;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_OUT
+ * @brief Select the USB transceiver power regulator output voltage.
+ *
+ * Defines all possible output voltages for the USB transceiver power
+ * regulator. Only one power output voltage level may be selected at
+ * a time.
+ */
+typedef enum {
+	USB_POWER_2V775,	/*!< Select 2.775V output voltage
+				   .         */
+	USB_POWER_3V3		/*!< Select 3.3V output voltage.  */
+} PMIC_CONVITY_USB_POWER_OUT;
+
+/*!
+ * @enum PMIC_CONVITY_USB_TRANSCEIVER_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all valid USB transceiver operating modes. Only one of the
+ * following USB transceiver modes may be selected at a time.
+ */
+typedef enum {
+	USB_TRANSCEIVER_OFF,	/*!< USB transceiver currently off
+				   .            */
+	USB_SINGLE_ENDED_UNIDIR,	/*!< Select Single-ended
+					   unidirectional transmit mode.   */
+	USB_SINGLE_ENDED_UNIDIR_TX,	/*!< Select Single-ended
+					   unidirectional transmit mode.   */
+	USB_SINGLE_ENDED_UNIDIR_RX,	/*!< Select Single-ended
+					   unidirectional receive mode.    */
+	USB_SINGLE_ENDED_BIDIR,	/*!< Select Single-ended
+				   bidirectional transmit mode.    */
+	USB_SINGLE_ENDED_LOW,	/*!< Select USB SE0 mode.            */
+	USB_DIFFERENTIAL_UNIDIR_TX,	/*!< Select Differential
+					   unidirectional transmit mode
+					   .            */
+	USB_DIFFERENTIAL_UNIDIR,	/*!< Select Differential
+					   unidirectional transmit mode
+					   .            */
+
+	USB_DIFFERENTIAL_UNIDIR_RX,	/*!< Select Differential
+					   unidirectional receive mode.    */
+	USB_DIFFERENTIAL_BIDIR,	/*!< Select Differential
+				   bidirectional transmit mode
+				 */
+	USB_SUSPEND_ON,		/*!< Select Suspend mode.            */
+	USB_SUSPEND_OFF,	/*!< Terminate Suspend mode.         */
+	USB_OTG_SRP_DLP_START,	/*!< Start USB On-The-Go Session
+				   Request Protocol using Data
+				   Line Pulsing.                   */
+	USB_OTG_SRP_DLP_STOP	/*!< Terminate USB On-The-Go Session
+				   Request Protocol using Data
+				   Line Pulsing.                   */
+} PMIC_CONVITY_USB_TRANSCEIVER_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_OTG_CONFIG
+ * @brief Select the USB On-The-Go configuration options.
+ *
+ * Defines all possible USB On-The-Go configuration options. Multiple
+ * configuration options may be selected at the same time. However, only one
+ * VBUS current limit may be selected at a time. Selecting more than one
+ * VBUS current limit will result in undefined and implementation-dependent
+ * behavior.
+ */
+typedef enum {
+	USB_OTG_SE0CONN = 0x00001,	/*!< Enable automatic
+					   connection of a pull-up
+					   resistor to VUSB when the
+					   SE0 condition is detected. */
+	USB_OTG_DLP_SRP = 0x00002,	/*!< Enable use of the hardware
+					   timer to control the
+					   duration of the data line
+					   pulse during the session
+					   request protocol.          */
+	USB_PULL_OVERRIDE = 0x00004,	/*!< Enable automatic disconnect
+					   of pull-up and pull-down
+					   resistors when transmitter
+					   is enabled.                */
+
+	USB_DP150K_PU = 0x00008,
+
+	USB_VBUS_CURRENT_LIMIT_HIGH = 0x00010,/*!< Select current limit to 200mA
+						for VBUS regulator.        */
+	USB_VBUS_CURRENT_LIMIT_LOW = 0x00020,	/*!< Select low current limit
+						   for VBUS regulator.        */
+	USB_VBUS_CURRENT_LIMIT_LOW_10MS = 0x00040, /*!< Select low current limit
+						   for VBUS regulator for
+							   10 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_20MS = 0x00080, /*!< Select low current limit
+						   for VBUS regulator for
+							   20 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_30MS = 0x00100, /*!< Select low current limit
+						   for VBUS regulator for
+							   30 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_40MS = 0x00200,/*!< Select low current limit
+						   for VBUS regulator for
+							   40 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_50MS = 0x00400, /*!< Select low current limit
+						   for VBUS regulator for
+							   50 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_60MS = 0x00800, /*!< Select low current limit
+						   for VBUS regulator for
+							   60 ms . */
+
+	USB_VBUS_PULLDOWN = 0x01000,	/*!< Enable VBUS pull-down.     */
+
+	USB_USBCNTRL = 0x02000,
+
+	USB_UDP_PD = 0x04000,
+
+	USB_UDM_PD = 0x08000,
+
+	USB_PU = 0x10000,
+
+	USBXCVREN = 0x20000
+} PMIC_CONVITY_USB_OTG_CONFIG;
+/*@}*/
+
+/*!
+ * @name RS-232 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the RS-232 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_RS232_EXTERNAL
+ * @brief Select the RS-232 transceiver external connections.
+ *
+ * Defines all valid RS-232 transceiver external RX/TX connection options.
+ * Only one connection mode may be selected at a time.
+ */
+typedef enum {
+	RS232_TX_UDM_RX_UDP,	/*!< Select RS-232 TX on UDM   */
+	RS232_TX_UDP_RX_UDM,	/*!< Select RS-232 TX on UDP
+				   . */
+	RS232_TX_RX_EXTERNAL_DEFAULT	/*!< Use power on default.        */
+} PMIC_CONVITY_RS232_EXTERNAL;
+
+/*!
+ * @enum PMIC_CONVITY_RS232_INTERNAL
+ * @brief Select the RS-232 transceiver internal connections.
+ *
+ * Defines all valid RS-232 transceiver internal RX/TX connection options.
+ * Only one connection mode can be selected at a time.
+ */
+typedef enum {
+	RS232_TX_USE0VM_RX_UDATVP,	/*!< Select RS-232 TX from USE0VM
+					   .         */
+	RS232_TX_UDATVP_RX_URXVM,	/*!< Select RS-232 TX from UDATVP
+					   .         */
+	RS232_TX_UTXDI_RX_URXDO,	/*!< Select RS-232 TX from UTXDI
+					   .    */
+	RS232_TX_RX_INTERNAL_DEFAULT	/*!< Use power on default.     */
+} PMIC_CONVITY_RS232_INTERNAL;
+
+/*@}*/
+
+/*!
+ * @name CEA-936 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the CEA-936 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_CEA936_EXIT_SIGNAL
+ * @brief Select the CEA-936 mode exit signal.
+ *
+ * Defines all valid CEA-936 connection termination signals. Only one
+ * termination signal can be selected at a time.
+ */
+typedef enum {
+	CEA936_UID_NO_PULLDOWN,	/*!< No UID pull-down . */
+	CEA936_UID_PULLDOWN_6MS,	/*!< UID pull-down for 6 ms (+/-2 ms)
+					   .                  */
+	CEA936_UID_PULLDOWN,	/*!< UID pulled down .  */
+	CEA936_UDMPULSE		/*!< UDM pulsed .       */
+} PMIC_CONVITY_CEA936_EXIT_SIGNAL;
+
+/*@}*/
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Connectivity
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Request exclusive access to the PMIC Connectivity hardware.
+ *
+ * Attempt to open and gain exclusive access to the PMIC Connectivity
+ * hardware. An initial operating mode (e.g., USB or RS-232) must also
+ * be specified.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls. The
+ * same handle must also be used in the close call when use of the PMIC
+ * connectivity hardware is no longer required.
+ *
+ * The open request will fail if another thread has already obtained the
+ * device handle and has not yet called pmic_convity_close() with it.
+ *
+ * @param   handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param   mode            Initial connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the open request was successful
+ * @retval      PMIC_ERROR      If the connectivity hardware cannot be opened.
+ */
+PMIC_STATUS pmic_convity_open(PMIC_CONVITY_HANDLE * const handle,
+			      const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Terminate further access to the PMIC Connectivity hardware.
+ *
+ * Terminate further access to the PMIC Connectivity hardware. This also
+ * allows another thread to successfully call pmic_convity_open() to gain
+ * access.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_close(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the PMIC Connectivity main operating mode.
+ *
+ * Change the current operating mode of the PMIC Connectivity hardware.
+ * The available connectivity operating modes are hardware-dependent and
+ * consists of one or more of the following: USB (including USB On-the-Go),
+ * RS-232, and CEA-936. Requesting an operating mode that is not supported
+ * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired operating mode.
+ */
+PMIC_STATUS pmic_convity_set_mode(const PMIC_CONVITY_HANDLE handle,
+				  const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Get the current PMIC Connectivity main operating mode.
+ *
+ * Get the current operating mode for the PMIC Connectivity hardware.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            The current PMIC Connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_mode(const PMIC_CONVITY_HANDLE handle,
+				  PMIC_CONVITY_MODE * const mode);
+
+/*!
+ * @brief Reset the Connectivity hardware to it's power on state.
+ *
+ * Restore all registers to the initial power-on/reset state.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_reset(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the Connectivity callback function.
+ *
+ * Register a callback function that will be used to signal PMIC Connectivity
+ * events. For example, the USB subsystem should register a callback function
+ * in order to be notified of device connect/disconnect events. Note, however,
+ * that non-USB events may also be signalled depending upon the PMIC hardware
+ * capabilities. Therefore, the callback function must be able to properly
+ * handle all of the possible events if support for non-USB peripherals is
+ * also to be included.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   func            A pointer to the callback function.
+ * @param   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_convity_set_callback(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_CALLBACK func,
+				      const PMIC_CONVITY_EVENTS eventMask);
+
+/*!
+ * @brief Deregisters the existing Connectivity callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_convity_set_callback().
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_clear_callback(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Get the current Connectivity callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param  handle          Device handle from open() call.
+ * @param  func            The current callback function.
+ * @param  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_callback(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_CALLBACK * const func,
+				      PMIC_CONVITY_EVENTS * const eventMask);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name USB and USB On-The-Go APIs
+ * USB Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the USB transceiver's operating speed.
+ *
+ * Set the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   speed           The desired USB transceiver speed.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the high speed (480 Mbps) mode is
+ *                                   requested.
+ */
+PMIC_STATUS pmic_convity_usb_set_speed(const PMIC_CONVITY_HANDLE handle,
+				       const PMIC_CONVITY_USB_SPEED speed);
+
+/*!
+ * This function enables/disables VUSB and VBUS output.
+ * This API configures the VUSBEN and VBUSEN bits of USB register
+ *
+ * @param   handle          Device handle from open() call.
+ * @param        out_type true, for VUSB
+ *                        false, for VBUS
+ * @param        out	if true, output is enabled
+ *                      if false, output is disabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_convity_set_output(const PMIC_CONVITY_HANDLE handle,
+				    bool out_type, bool out);
+
+/*!
+ * @brief Get the USB transceiver's operating speed.
+ *
+ * Get the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  speed           The current USB transceiver speed.
+ * @param  mode            The current USB transceiver mode.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ *                                   obtained
+ */
+PMIC_STATUS pmic_convity_usb_get_speed(const PMIC_CONVITY_HANDLE handle,
+				       PMIC_CONVITY_USB_SPEED * const speed,
+				       PMIC_CONVITY_USB_MODE * const mode);
+
+/*!
+ * @brief Set the USB transceiver's power supply configuration.
+ *
+ * Set the USB transceiver's power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   pwrin           USB transceiver regulator input power source.
+ * @param   pwrout          USB transceiver regulator output power level.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired configuration.
+ */
+PMIC_STATUS pmic_convity_usb_set_power_source(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_POWER_IN
+					      pwrin,
+					      const PMIC_CONVITY_USB_POWER_OUT
+					      pwrout);
+
+/*!
+ * @brief Get the USB transceiver's power supply configuration.
+ *
+ * Get the USB transceiver's current power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  pwrin           USB transceiver regulator input power source
+ * @param  pwrout          USB transceiver regulator output power level
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_power_source(const PMIC_CONVITY_HANDLE handle,
+					      PMIC_CONVITY_USB_POWER_IN *
+					      const pwrin,
+					      PMIC_CONVITY_USB_POWER_OUT *
+					      const pwrout);
+
+/*!
+ * @brief Set the current USB transceiver operating mode.
+ *
+ * Set the USB transceiver's operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the USB transceiver's operating mode
+ *                              was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB transceiver mode is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_set_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_USB_TRANSCEIVER_MODE
+				      mode);
+
+/*!
+ * @brief Get the current USB transceiver operating mode.
+ *
+ * Get the USB transceiver's current operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  mode            Current operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's operating mode
+ *                                   was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_USB_TRANSCEIVER_MODE *
+				      const mode);
+
+/*!
+ * @brief Set the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Set the Data Line Pulse duration (in milliseconds) for the USB OTG
+ * Session Request Protocol.
+ *
+ * Note that for mc13783 the duration is fixed at 7.5 ms and calling this
+ * function will simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the data line pulse
+ *                                   duration is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired data line pulse duration
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  const unsigned int duration);
+
+/*!
+ * @brief Get the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Get the current Data Line Pulse duration (in milliseconds) for the USB
+ * OTG Session Request Protocol.
+ *
+ * Note that the Data Line Pulse duration is fixed at 7.5 ms for the mc13783
+ * PMIC. Therefore, calling this function while using the mc13783 PMIC will
+ * simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully
+ *                                   obtained.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If called using the mc13783 PMIC.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  unsigned int *const duration);
+
+/*!
+ * @brief Start the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the start of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully started
+ */
+PMIC_STATUS pmic_convity_usb_otg_begin_hnp(const PMIC_CONVITY_HANDLE handle,
+					   const PMIC_CONVITY_USB_DEVICE_TYPE
+					   deviceType);
+
+/*!
+ * @brief Complete the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the end of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully ended
+ */
+PMIC_STATUS pmic_convity_usb_otg_end_hnp(const PMIC_CONVITY_HANDLE handle,
+					 const PMIC_CONVITY_USB_DEVICE_TYPE
+					 deviceType);
+
+/*!
+ * @brief Set the current USB On-The-Go configuration.
+ *
+ * Set the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             Desired USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_config(const PMIC_CONVITY_HANDLE handle,
+					    const PMIC_CONVITY_USB_OTG_CONFIG
+					    cfg);
+
+/*!
+ * @brief Clear the current USB On-The-Go configuration.
+ *
+ * Clears the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             USB OTG configuration settings to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_clear_config(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_OTG_CONFIG
+					      cfg);
+
+/*!
+ * @brief Get the current USB On-The-Go configuration.
+ *
+ * Get the current USB On-The-Go (OTG) configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             The current USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_config(const PMIC_CONVITY_HANDLE handle,
+					    PMIC_CONVITY_USB_OTG_CONFIG *
+					    const cfg);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name RS-232 APIs
+ * RS-232 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the current RS-232 operating configuration.
+ *
+ * Set the connectivity interface to the selected RS-232 operating mode.
+ * Note that the RS-232 operating mode will be automatically overridden
+ * if the USB_EN is asserted at any time (e.g., when a USB device is
+ * attached).
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfgInternal     RS-232 transceiver internal connections.
+ * @param   cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired RS-232 configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_rs232_set_config(const PMIC_CONVITY_HANDLE handle,
+					  const PMIC_CONVITY_RS232_INTERNAL
+					  cfgInternal,
+					  const PMIC_CONVITY_RS232_EXTERNAL
+					  cfgExternal);
+
+/*!
+ * @brief Get the current RS-232 operating configuration.
+ *
+ * Get the connectivity interface's current RS-232 operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  cfgInternal     RS-232 transceiver internal connections.
+ * @param  cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_rs232_get_config(const PMIC_CONVITY_HANDLE handle,
+					  PMIC_CONVITY_RS232_INTERNAL *
+					  const cfgInternal,
+					  PMIC_CONVITY_RS232_EXTERNAL *
+					  const cfgExternal);
+
+/***************************************************************************/
+
+/*@}*/
+
+/*!
+ * @name CE-936 APIs
+ * CE-936 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Send a signal to exit CEA-936 mode.
+ *
+ * Signal the attached device to exit the current CEA-936 operating mode.
+ * Returns an error if the current operating mode is not CEA-936.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   signal          Type of exit signal to be sent.
+ *
+ * @retval      PMIC_SUCCESS         If the CEA-936 exit mode signal was sent.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired CEA-936 exit mode signal
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_cea936_exit_signal(const PMIC_CONVITY_HANDLE handle,
+					    const
+					    PMIC_CONVITY_CEA936_EXIT_SIGNAL
+					    signal);
+
+/*@}*/
+
+#endif				/* __ASM_ARCH_MXC_PMIC_CONVITY_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/pmic_power.h b/arch/arm/plat-mxc/include/mach/pmic_power.h
new file mode 100644
index 0000000..c4016ac
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/pmic_power.h
@@ -0,0 +1,1358 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_POWER_H__
+#define __ASM_ARCH_MXC_PMIC_POWER_H__
+
+/*!
+ * @defgroup PMIC_POWER  PMIC Power Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_power.h
+ * @brief This is the header of PMIC power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+/*! @{ */
+
+/*!
+ * Turn on a regulator.
+ */
+#define PMIC_REGULATOR_ON			_IOWR('p', 0xf0, int)
+
+/*!
+ * Turn off a regulator.
+ */
+#define PMIC_REGULATOR_OFF			_IOWR('p', 0xf1, int)
+
+/*!
+ * Set regulator configuration.
+ */
+#define PMIC_REGULATOR_SET_CONFIG		_IOWR('p', 0xf2, int)
+
+/*!
+ * Get regulator configuration.
+ */
+#define PMIC_REGULATOR_GET_CONFIG		_IOWR('p', 0xf3, int)
+
+/*!
+ * Miscellaneous Power Test.
+ */
+#define PMIC_POWER_CHECK_MISC			_IOWR('p', 0xf4, int)
+
+/*! @} */
+
+/*!
+ * This enumeration define all power interrupts
+ */
+typedef enum {
+	/*!
+	 * BP turn on threshold detection
+	 */
+	PWR_IT_BPONI = 0,
+	/*!
+	 * End of life / low battery detect
+	 */
+	PWR_IT_LOBATLI,
+	/*!
+	 * Low battery warning
+	 */
+	PWR_IT_LOBATHI,
+	/*!
+	 * ON1B event
+	 */
+	PWR_IT_ONOFD1I,
+	/*!
+	 * ON2B event
+	 */
+	PWR_IT_ONOFD2I,
+	/*!
+	 * ON3B event
+	 */
+	PWR_IT_ONOFD3I,
+	/*!
+	 * System reset
+	 */
+	PWR_IT_SYSRSTI,
+	/*!
+	 * Power ready
+	 */
+	PWR_IT_PWRRDYI,
+	/*!
+	 * Power cut event
+	 */
+	PWR_IT_PCI,
+	/*!
+	 * Warm start event
+	 */
+	PWR_IT_WARMI,
+	/*!
+	 * Memory hold event
+	 */
+} t_pwr_int;
+
+/*!
+ * VHOLD regulator output voltage setting.
+ */
+typedef enum {
+	VH_1_875V,		/*!< 1.875V */
+	VH_2_5V,		/*!< 2.5V */
+	VH_1_55V,		/*!< 1.55V */
+	VH_PASSTHROUGH,		/*!< Pass-through mode */
+} t_vhold_voltage;
+
+/*!
+ * PMIC power control configuration.
+ */
+
+typedef struct {
+	bool pc_enable;		/*!< Power cut enable */
+	unsigned char pc_timer;	/*!< Power cut timer value */
+	bool pc_count_enable;	/*!< Power cut counter enable,
+				   If TURE, Power cuts are disabled
+				   when pc_count > pc_max_count;
+				   If FALSE, Power cuts are not
+				   disabled when
+				   pc_count > pc_max_count */
+	unsigned char pc_count;	/*!< Power cut count */
+	unsigned char pc_max_count;	/*!< Power cut maximum count */
+	bool warm_enable;	/*!< User Off state enable */
+	bool user_off_pc;	/*!< Automatic transition to user off
+				   during power cut */
+	bool clk_32k_enable;	/*!< 32 kHz output buffer enable
+				   during memory hold */
+	bool clk_32k_user_off;	/*!< Keeps the CLK32KMCU active during
+				   user off power cut modes */
+	bool en_vbkup1;		/*!< enable VBKUP1 regulator */
+	bool auto_en_vbkup1;	/*!< automatically enable VBKUP1
+				   regulator in the memory hold
+				   and user of modes */
+	t_vhold_voltage vhold_voltage;	/*!< output voltage for VBKUP1 */
+	bool en_vbkup2;		/*!< enable VBKUP2 regulator */
+	bool auto_en_vbkup2;	/*!< automatically enable VBKUP2
+				   regulator in the memory hold
+				   and user of modes */
+	t_vhold_voltage vhold_voltage2;	/*!< output voltage for VBKUP2 */
+	unsigned char mem_timer;	/*!< duration of the memory hold
+					   timer */
+	bool mem_allon;		/*!< memory hold timer infinity mode,
+				   If TRUE, the memory hold timer
+				   will be set to infinity and
+				   the mem_timer filed will be
+				   ignored */
+} t_pc_config;
+
+/*!
+ * brief PMIC regulators.
+ */
+
+typedef enum {
+	SW_SW1A = 0,		/*!< SW1A or SW1 */
+	SW_SW1B,		/*!< SW1B */
+	SW_SW2A,		/*!< SW2A or SW2 */
+	SW_SW2B,		/*!< SW2B */
+	SW_SW3,			/*!< SW3 */
+	SW_PLL,			/*!< PLL */
+	REGU_VAUDIO,		/*!< VAUDIO */
+	REGU_VIOHI,		/*!< VIOHI */
+	REGU_VIOLO,		/*!< VIOLO */
+	REGU_VDIG,		/*!< VDIG */
+	REGU_VGEN,		/*!< VGEN */
+	REGU_VRFDIG,		/*!< VRFDIG */
+	REGU_VRFREF,		/*!< VRFREF */
+	REGU_VRFCP,		/*!< VRFCP */
+	REGU_VSIM,		/*!< VSIM */
+	REGU_VESIM,		/*!< VESIM */
+	REGU_VCAM,		/*!< VCAM */
+	REGU_VRFBG,		/*!< VRFBG */
+	REGU_VVIB,		/*!< VVIB */
+	REGU_VRF1,		/*!< VRF1 */
+	REGU_VRF2,		/*!< VRF2 */
+	REGU_VMMC1,		/*!< VMMC1 or VMMC */
+	REGU_VMMC2,		/*!< VMMC2 */
+	REGU_GPO1,		/*!< GPIO1 */
+	REGU_GPO2,		/*!< GPO2 */
+	REGU_GPO3,		/*!< GPO3 */
+	REGU_GPO4,		/*!< GPO4 */
+	REGU_V1,		/*!< V1 */
+	REGU_V2,		/*!< V2 */
+	REGU_V3,		/*!< V3 */
+	REGU_V4,		/*!< V4 */
+} t_pmic_regulator;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1
+ * @brief PMIC Switch mode regulator SW1 output voltages.
+ */
+
+typedef enum {
+	SW1_1V = 0,		/*!< 1.0 V */
+	SW1_1_1V,		/*!< 1.1 V */
+	SW1_1_2V,		/*!< 1.2 V */
+	SW1_1_3V,		/*!< 1.3 V */
+	SW1_1_4V,		/*!< 1.4 V */
+	SW1_1_55V,		/*!< 1.55 V */
+	SW1_1_625V,		/*!< 1.625 V */
+	SW1_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1a
+ * @brief PMIC regulator SW1A output voltage.
+ */
+typedef enum {
+	SW1A_0_9V = 0,		/*!< 0.900 V */
+	SW1A_0_925V,		/*!< 0.925 V */
+	SW1A_0_95V,		/*!< 0.950 V */
+	SW1A_0_975V,		/*!< 0.975 V */
+	SW1A_1V,		/*!< 1.000 V */
+	SW1A_1_025V,		/*!< 1.025 V */
+	SW1A_1_05V,		/*!< 1.050 V */
+	SW1A_1_075V,		/*!< 1.075 V */
+	SW1A_1_1V,		/*!< 1.100 V */
+	SW1A_1_125V,		/*!< 1.125 V */
+	SW1A_1_15V,		/*!< 1.150 V */
+	SW1A_1_175V,		/*!< 1.175 V */
+	SW1A_1_2V,		/*!< 1.200 V */
+	SW1A_1_225V,		/*!< 1.225 V */
+	SW1A_1_25V,		/*!< 1.250 V */
+	SW1A_1_275V,		/*!< 1.275 V */
+	SW1A_1_3V,		/*!< 1.300 V */
+	SW1A_1_325V,		/*!< 1.325 V */
+	SW1A_1_35V,		/*!< 1.350 V */
+	SW1A_1_375V,		/*!< 1.375 V */
+	SW1A_1_4V,		/*!< 1.400 V */
+	SW1A_1_425V,		/*!< 1.425 V */
+	SW1A_1_45V,		/*!< 1.450 V */
+	SW1A_1_475V,		/*!< 1.475 V */
+	SW1A_1_5V,		/*!< 1.500 V */
+	SW1A_1_525V,		/*!< 1.525 V */
+	SW1A_1_55V,		/*!< 1.550 V */
+	SW1A_1_575V,		/*!< 1.575 V */
+	SW1A_1_6V,		/*!< 1.600 V */
+	SW1A_1_625V,		/*!< 1.625 V */
+	SW1A_1_65V,		/*!< 1.650 V */
+	SW1A_1_675V,		/*!< 1.675 V */
+	SW1A_1_7V,		/*!< 1.700 V */
+	SW1A_1_8V = 36,		/*!< 1.800 V */
+	SW1A_1_85V = 40,	/*!< 1.850 V */
+	SW1A_2V = 44,		/*!< 2_000 V */
+	SW1A_2_1V = 48,		/*!< 2_100 V */
+	SW1A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1b
+ * @brief PMIC regulator SW1B output voltage.
+ */
+typedef enum {
+	SW1B_0_9V = 0,		/*!< 0.900 V */
+	SW1B_0_925V,		/*!< 0.925 V */
+	SW1B_0_95V,		/*!< 0.950 V */
+	SW1B_0_975V,		/*!< 0.975 V */
+	SW1B_1V,		/*!< 1.000 V */
+	SW1B_1_025V,		/*!< 1.025 V */
+	SW1B_1_05V,		/*!< 1.050 V */
+	SW1B_1_075V,		/*!< 1.075 V */
+	SW1B_1_1V,		/*!< 1.100 V */
+	SW1B_1_125V,		/*!< 1.125 V */
+	SW1B_1_15V,		/*!< 1.150 V */
+	SW1B_1_175V,		/*!< 1.175 V */
+	SW1B_1_2V,		/*!< 1.200 V */
+	SW1B_1_225V,		/*!< 1.225 V */
+	SW1B_1_25V,		/*!< 1.250 V */
+	SW1B_1_275V,		/*!< 1.275 V */
+	SW1B_1_3V,		/*!< 1.300 V */
+	SW1B_1_325V,		/*!< 1.325 V */
+	SW1B_1_35V,		/*!< 1.350 V */
+	SW1B_1_375V,		/*!< 1.375 V */
+	SW1B_1_4V,		/*!< 1.400 V */
+	SW1B_1_425V,		/*!< 1.425 V */
+	SW1B_1_45V,		/*!< 1.450 V */
+	SW1B_1_475V,		/*!< 1.475 V */
+	SW1B_1_5V,		/*!< 1.500 V */
+	SW1B_1_525V,		/*!< 1.525 V */
+	SW1B_1_55V,		/*!< 1.550 V */
+	SW1B_1_575V,		/*!< 1.575 V */
+	SW1B_1_6V,		/*!< 1.600 V */
+	SW1B_1_625V,		/*!< 1.625 V */
+	SW1B_1_65V,		/*!< 1.650 V */
+	SW1B_1_675V,		/*!< 1.675 V */
+	SW1B_1_7V,		/*!< 1.700 V */
+	SW1B_1_8V = 36,		/*!< 1.800 V */
+	SW1B_1_85V = 40,	/*!< 1.850 V */
+	SW1B_2V = 44,		/*!< 2_000 V */
+	SW1B_2_1V = 48,		/*!< 2_100 V */
+	SW1B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2
+ * @brief PMIC Switch mode regulator SW2 output voltages.
+  */
+typedef enum {
+	SW2_1V = 0,		/*!< 1.0 V */
+	SW2_1_1V,		/*!< 1.1 V */
+	SW2_1_2V,		/*!< 1.2 V */
+	SW2_1_3V,		/*!< 1.3 V */
+	SW2_1_4V,		/*!< 1.4 V */
+	SW2_1_55V,		/*!< 1.55 V */
+	SW2_1_625V,		/*!< 1.625 V */
+	SW2_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2a
+ * @brief PMIC regulator SW2A output voltage.
+ */
+typedef enum {
+	SW2A_0_9V = 0,		/*!< 0.900 V */
+	SW2A_0_925V,		/*!< 0.925 V */
+	SW2A_0_95V,		/*!< 0.950 V */
+	SW2A_0_975V,		/*!< 0.975 V */
+	SW2A_1V,		/*!< 1.000 V */
+	SW2A_1_025V,		/*!< 1.025 V */
+	SW2A_1_05V,		/*!< 1.050 V */
+	SW2A_1_075V,		/*!< 1.075 V */
+	SW2A_1_1V,		/*!< 1.100 V */
+	SW2A_1_125V,		/*!< 1.125 V */
+	SW2A_1_15V,		/*!< 1.150 V */
+	SW2A_1_175V,		/*!< 1.175 V */
+	SW2A_1_2V,		/*!< 1.200 V */
+	SW2A_1_225V,		/*!< 1.225 V */
+	SW2A_1_25V,		/*!< 1.250 V */
+	SW2A_1_275V,		/*!< 1.275 V */
+	SW2A_1_3V,		/*!< 1.300 V */
+	SW2A_1_325V,		/*!< 1.325 V */
+	SW2A_1_35V,		/*!< 1.350 V */
+	SW2A_1_375V,		/*!< 1.375 V */
+	SW2A_1_4V,		/*!< 1.400 V */
+	SW2A_1_425V,		/*!< 1.425 V */
+	SW2A_1_45V,		/*!< 1.450 V */
+	SW2A_1_475V,		/*!< 1.475 V */
+	SW2A_1_5V,		/*!< 1.500 V */
+	SW2A_1_525V,		/*!< 1.525 V */
+	SW2A_1_55V,		/*!< 1.550 V */
+	SW2A_1_575V,		/*!< 1.575 V */
+	SW2A_1_6V,		/*!< 1.600 V */
+	SW2A_1_625V,		/*!< 1.625 V */
+	SW2A_1_65V,		/*!< 1.650 V */
+	SW2A_1_675V,		/*!< 1.675 V */
+	SW2A_1_7V,		/*!< 1.700 V */
+	SW2A_1_8V = 36,		/*!< 1.800 V */
+	SW2A_1_9V = 40,		/*!< 1.900 V */
+	SW2A_2V = 44,		/*!< 2_000 V */
+	SW2A_2_1V = 48,		/*!< 2_100 V */
+	SW2A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2b
+ * @brief PMIC regulator SW2B output voltage.
+ */
+typedef enum {
+	SW2B_0_9V = 0,		/*!< 0.900 V */
+	SW2B_0_925V,		/*!< 0.925 V */
+	SW2B_0_95V,		/*!< 0.950 V */
+	SW2B_0_975V,		/*!< 0.975 V */
+	SW2B_1V,		/*!< 1.000 V */
+	SW2B_1_025V,		/*!< 1.025 V */
+	SW2B_1_05V,		/*!< 1.050 V */
+	SW2B_1_075V,		/*!< 1.075 V */
+	SW2B_1_1V,		/*!< 1.100 V */
+	SW2B_1_125V,		/*!< 1.125 V */
+	SW2B_1_15V,		/*!< 1.150 V */
+	SW2B_1_175V,		/*!< 1.175 V */
+	SW2B_1_2V,		/*!< 1.200 V */
+	SW2B_1_225V,		/*!< 1.225 V */
+	SW2B_1_25V,		/*!< 1.250 V */
+	SW2B_1_275V,		/*!< 1.275 V */
+	SW2B_1_3V,		/*!< 1.300 V */
+	SW2B_1_325V,		/*!< 1.325 V */
+	SW2B_1_35V,		/*!< 1.350 V */
+	SW2B_1_375V,		/*!< 1.375 V */
+	SW2B_1_4V,		/*!< 1.400 V */
+	SW2B_1_425V,		/*!< 1.425 V */
+	SW2B_1_45V,		/*!< 1.450 V */
+	SW2B_1_475V,		/*!< 1.475 V */
+	SW2B_1_5V,		/*!< 1.500 V */
+	SW2B_1_525V,		/*!< 1.525 V */
+	SW2B_1_55V,		/*!< 1.550 V */
+	SW2B_1_575V,		/*!< 1.575 V */
+	SW2B_1_6V,		/*!< 1.600 V */
+	SW2B_1_625V,		/*!< 1.625 V */
+	SW2B_1_65V,		/*!< 1.650 V */
+	SW2B_1_675V,		/*!< 1.675 V */
+	SW2B_1_7V,		/*!< 1.700 V */
+	SW2B_1_8V = 36,		/*!< 1.800 V */
+	SW2B_1_9V = 40,		/*!< 1.900 V */
+	SW2B_2V = 44,		/*!< 2_000 V */
+	SW2B_2_1V = 48,		/*!< 2_100 V */
+	SW2B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw3
+ * @brief PMIC Switch mode regulator SW3 output voltages.
+ */
+typedef enum {
+	SW3_5V = 0,		/*!< 5.0 V */
+	SW3_5_1V = 0,		/*!< 5.1 V */
+	SW3_5_6V,		/*!< 5.6 V */
+} t_pmic_regulator_voltage_sw3;
+
+/*!
+ * @enum t_switcher_factor
+ * @brief PLL multiplication factor
+ */
+typedef enum {
+	FACTOR_28 = 0,		/*!< 917 504 kHz */
+	FACTOR_29,		/*!< 950 272 kHz */
+	FACTOR_30,		/*!< 983 040 kHz */
+	FACTOR_31,		/*!< 1 015 808 kHz */
+	FACTOR_32,		/*!< 1 048 576 kHz */
+	FACTOR_33,		/*!< 1 081 344 kHz */
+	FACTOR_34,		/*!< 1 114 112 kHz */
+	FACTOR_35,		/*!< 1 146 880 kHz */
+} t_switcher_factor;
+
+/*!
+ * @enum t_pmic_regulator_voltage_violo
+ * @brief PMIC regulator VIOLO output voltage.
+ */
+typedef enum {
+	VIOLO_1_2V = 0,		/*!< 1.2 V */
+	VIOLO_1_3V,		/*!< 1.3 V */
+	VIOLO_1_5V,		/*!< 1.5 V */
+	VIOLO_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_violo;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vdig
+ * @brief PMIC regulator VDIG output voltage.
+ */
+typedef enum {
+	VDIG_1_2V = 0,		/*!< 1.2 V */
+	VDIG_1_3V,		/*!< 1.3 V */
+	VDIG_1_5V,		/*!< 1.5 V */
+	VDIG_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_vdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vgen
+ * @brief PMIC regulator VGEN output voltage.
+ */
+typedef enum {
+	VGEN_1_2V = 0,		/*!< 1.2 V */
+	VENG_1_3V,		/*!< 1.3 V */
+	VGEN_1_5V,		/*!< 1.5 V */
+	VGEN_1_8V,		/*!< 1.8 V */
+	VGEN_1_1V,		/*!< 1.1 V */
+	VGEN_2V,		/*!< 2 V */
+	VGEN_2_775V,		/*!< 2.775 V */
+	VGEN_2_4V,		/*!< 2.4 V */
+} t_pmic_regulator_voltage_vgen;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfdig
+ * @brief PMIC regulator VRFDIG output voltage.
+ */
+typedef enum {
+	VRFDIG_1_2V = 0,	/*!< 1.2 V */
+	VRFDIG_1_5V,		/*!< 1.5 V */
+	VRFDIG_1_8V,		/*!< 1.8 V */
+	VRFDIG_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_vrfdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfref
+ * @brief PMIC regulator VRFREF output voltage.
+ */
+typedef enum {
+	VRFREF_2_475V = 0,	/*!< 2.475 V */
+	VRFREF_2_6V,		/*!< 2.600 V */
+	VRFREF_2_7V,		/*!< 2.700 V */
+	VRFREF_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfref;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfcp
+ * @brief PMIC regulator VRFCP output voltage.
+ */
+typedef enum {
+	VRFCP_2_7V = 0,		/*!< 2.700 V */
+	VRFCP_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfcp;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vsim
+ * @brief PMIC linear regulator VSIM output voltage.
+ */
+typedef enum {
+	VSIM_1_8V = 0,		/*!< 1.8 V */
+	VSIM_2_9V,		/*!< 2.90 V */
+	VSIM_3V = 1,		/*!< 3 V */
+} t_pmic_regulator_voltage_vsim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vesim
+ * @brief PMIC regulator VESIM output voltage.
+ */
+typedef enum {
+	VESIM_1_8V = 0,		/*!< 1.80 V */
+	VESIM_2_9V,		/*!< 2.90 V */
+} t_pmic_regulator_voltage_vesim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vcam
+ * @brief PMIC regulator VCAM output voltage.
+ */
+typedef enum {
+	VCAM_1_5V = 0,		/*!< 1.50 V */
+	VCAM_1_8V,		/*!< 1.80 V */
+	VCAM_2_5V,		/*!< 2.50 V */
+	VCAM_2_55V,		/*!< 2.55 V */
+	VCAM_2_6V,		/*!< 2.60 V */
+	VCAM_2_75V,		/*!< 2.75 V */
+	VCAM_2_8V,		/*!< 2.80 V */
+	VCAM_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vcam;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vvib
+ * @brief PMIC linear regulator V_VIB output voltage.
+ */
+typedef enum {
+	VVIB_1_3V = 0,		/*!< 1.30 V */
+	VVIB_1_8V,		/*!< 1.80 V */
+	VVIB_2V,		/*!< 2 V */
+	VVIB_3V,		/*!< 3 V */
+} t_pmic_regulator_voltage_vvib;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf1
+ * @brief PMIC regulator VRF1 output voltage.
+ */
+typedef enum {
+	VRF1_1_5V = 0,		/*!< 1.500 V */
+	VRF1_1_875V,		/*!< 1.875 V */
+	VRF1_2_7V,		/*!< 2.700 V */
+	VRF1_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf2
+ * @brief PMIC regulator VRF2 output voltage.
+ */
+typedef enum {
+	VRF2_1_5V = 0,		/*!< 1.500 V */
+	VRF2_1_875V,		/*!< 1.875 V */
+	VRF2_2_7V,		/*!< 2.700 V */
+	VRF2_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc
+ * @brief PMIC linear regulator VMMC output voltage.
+ */
+typedef enum {
+	VMMC_OFF = 0,		/*!< Output off */
+	VMMC_1_6V,		/*!< 1.6 V */
+	VMMC_1_8V,		/*!< 1.8 V */
+	VMMC_2V,		/*!< 2 V */
+	VMMC_2_2V,		/*!< 2.2 V */
+	VMMC_2_4V,		/*!< 2.4 V */
+	VMMC_2_6V,		/*!< 2.6 V */
+	VMMC_2_8V,		/*!< 2.8 V */
+	VMMC_3V,		/*!< 3 V */
+	VMMC_3_2V,		/*!< 3.2 V */
+	VMMC_3_3V,		/*!< 3.3 V */
+	VMMC_3_4V,		/*!< 3.4 V */
+} t_pmic_regulator_voltage_vmmc;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc1
+ * @brief PMIC regulator VMMC1 output voltage.
+ */
+typedef enum {
+	VMMC1_1_6V = 0,		/*!< 1.60 V */
+	VMMC1_1_8V,		/*!< 1.80 V */
+	VMMC1_2V,		/*!< 2.00 V */
+	VMMC1_2_6V,		/*!< 2.60 V */
+	VMMC1_2_7V,		/*!< 2.70 V */
+	VMMC1_2_8V,		/*!< 2.80 V */
+	VMMC1_2_9V,		/*!< 2.90 V */
+	VMMC1_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc2
+ * @brief PMIC regulator VMMC2 output voltage.
+ */
+typedef enum {
+	VMMC2_1_6V = 0,		/*!< 1.60 V */
+	VMMC2_1_8V,		/*!< 1.80 V */
+	VMMC2_2V,		/*!< 2.00 V */
+	VMMC2_2_6V,		/*!< 2.60 V */
+	VMMC2_2_7V,		/*!< 2.70 V */
+	VMMC2_2_8V,		/*!< 2.80 V */
+	VMMC2_2_9V,		/*!< 2.90 V */
+	VMMC2_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v1
+ * @brief PMIC linear regulator V1 output voltages.
+ */
+typedef enum {
+	V1_2_775V = 0,		/*!< 2.775 V */
+	V1_1_2V,		/*!< 1.2 V */
+	V1_1_3V,		/*!< 1.3 V */
+	V1_1_4V,		/*!< 1.4 V */
+	V1_1_55V,		/*!< 1.55 V */
+	V1_1_75V,		/*!< 1.75 V */
+	V1_1_875V,		/*!< 1.875 V */
+	V1_2_475V,		/*!< 2.475 V */
+} t_pmic_regulator_voltage_v1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v2
+ * @brief PMIC linear regulator V2 output voltage, V2 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum {
+	V2_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v3
+ * @brief PMIC linear regulator V3 output voltage.
+ */
+typedef enum {
+	V3_1_875V = 0,		/*!< 1.875 V */
+	V3_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v3;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v4
+ * @brief PMIC linear regulator V4 output voltage, V4 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum {
+	V4_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v4;
+
+/*!
+ * @union t_regulator_voltage
+ * @brief PMIC regulator output voltages.
+ */
+typedef union {
+	t_pmic_regulator_voltage_sw1 sw1;	/*!< SW1 voltage */
+	t_pmic_regulator_voltage_sw1a sw1a;	/*!< SW1A voltage */
+	t_pmic_regulator_voltage_sw1b sw1b;	/*!< SW1B voltage */
+	t_pmic_regulator_voltage_sw2 sw2;	/*!< SW2 voltage */
+	t_pmic_regulator_voltage_sw2a sw2a;	/*!< SW2A voltage */
+	t_pmic_regulator_voltage_sw2b sw2b;	/*!< SW2B voltage */
+	t_pmic_regulator_voltage_sw3 sw3;	/*!< SW3 voltage */
+	t_pmic_regulator_voltage_violo violo;	/*!< VIOLO voltage */
+	t_pmic_regulator_voltage_vdig vdig;	/*!< VDIG voltage */
+	t_pmic_regulator_voltage_vgen vgen;	/*!< VGEN voltage */
+	t_pmic_regulator_voltage_vrfdig vrfdig;	/*!< VRFDIG voltage */
+	t_pmic_regulator_voltage_vrfref vrfref;	/*!< VRFREF voltage */
+	t_pmic_regulator_voltage_vrfcp vrfcp;	/*!< VRFCP voltage */
+	t_pmic_regulator_voltage_vsim vsim;	/*!< VSIM voltage */
+	t_pmic_regulator_voltage_vesim vesim;	/*!< VESIM voltage */
+	t_pmic_regulator_voltage_vcam vcam;	/*!< VCAM voltage */
+	t_pmic_regulator_voltage_vvib vvib;	/*!< VVIB voltage */
+	t_pmic_regulator_voltage_vrf1 vrf1;	/*!< VRF1 voltage */
+	t_pmic_regulator_voltage_vrf2 vrf2;	/*!< VRF2 voltage */
+	t_pmic_regulator_voltage_vmmc vmmc;	/*!< VMMC voltage */
+	t_pmic_regulator_voltage_vmmc1 vmmc1;	/*!< VMMC1 voltage */
+	t_pmic_regulator_voltage_vmmc2 vmmc2;	/*!< VMMC2 voltage */
+	t_pmic_regulator_voltage_v1 v1;	/*!< V1 voltage */
+	t_pmic_regulator_voltage_v2 v2;	/*!< V2 voltage */
+	t_pmic_regulator_voltage_v3 v3;	/*!< V3 voltage */
+	t_pmic_regulator_voltage_v4 v4;	/*!< V4 voltage */
+} t_regulator_voltage;
+
+/*!
+ * @enum t_pmic_regulator_sw_mode
+ * @brief define switch mode regulator mode.
+ *
+ * The synchronous rectifier can be disabled (and pulse-skipping enabled)
+ * to improve low current efficiency. Software should disable synchronous
+ * rectifier / enable the pulse skipping for average loads less than
+ * approximately 30 mA, depending on the quiescent current penalty due to
+ * synchronous mode.
+ */
+typedef enum {
+	SYNC_RECT = 0,
+	NO_PULSE_SKIP,
+	PULSE_SKIP,
+	LOW_POWER,
+} t_pmic_regulator_sw_mode;
+
+/*!
+ * Generic PMIC switch mode regulator mode.
+ */
+typedef t_pmic_regulator_sw_mode t_regulator_sw_mode;
+typedef t_pmic_regulator_sw_mode t_regulator_stby_mode;
+
+/*!
+ * @enum t_regulator_lp_mode
+ * @brief Low power mode control modes.
+ */
+
+typedef enum {
+	/*!
+	 * Low Power Mode is disabled
+	 */
+	LOW_POWER_DISABLED = 0,
+	/*!
+	 * Low Power Mode is controlled by STANDBY pin and/or LVS pin
+	 */
+	LOW_POWER_CTRL_BY_PIN,
+	/*!
+	 * Set Low Power mode no matter of hardware pins
+	 */
+	LOW_POWER_EN,
+	/*!
+	 * Set Low Power mode and control by STANDBY
+	 */
+	LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN,
+} t_regulator_lp_mode;
+
+/*!
+ * @enum t_switcher_dvs_speed
+ * @brief DVS speed setting
+ */
+typedef enum {
+	/*!
+	 * Transition speed is dictated by the current
+	 * limit and input -output conditions
+	 */
+	DICTATED = 0,
+	/*!
+	 * 25mV step each 4us
+	 */
+	DVS_4US,
+	/*!
+	 * 25mV step each 8us
+	 */
+	DVS_8US,
+	/*!
+	 * 25mV step each 16us
+	 */
+	DVS_16US,
+} t_switcher_dvs_speed;
+
+/*!
+ * @struct t_regulator_config
+ * @brief regulator configuration.
+ *
+ */
+
+typedef struct {
+	/*!
+	 * Switch mode regulator operation mode. This field only applies to
+	 * switch mode regulators.
+	 */
+	t_regulator_sw_mode mode;
+	/*!
+	 * Switch mode stby regulator operation mode. This field only applies
+	 * to switch mode regulators.
+	 */
+	t_regulator_stby_mode stby_mode;
+	/*!
+	 * Regulator output voltage.
+	 */
+	t_regulator_voltage voltage;
+	/*!
+	 * Regulator output voltage in LVS mode.
+	 */
+	t_regulator_voltage voltage_lvs;
+	/*!
+	 * Regulator output voltage in standby mode.
+	 */
+	t_regulator_voltage voltage_stby;
+	/*!
+	 * Regulator low power mode.
+	 */
+	t_regulator_lp_mode lp_mode;
+	/*!
+	 * Switcher dvs speed
+	 */
+	t_switcher_dvs_speed dvs_speed;
+	/*!
+	 * Switcher panic mode
+	 */
+	bool panic_mode;
+	/*!
+	 * Switcher softstart
+	 */
+	bool softstart;
+	/*!
+	 * PLL Multiplication factor
+	 */
+	t_switcher_factor factor;
+} t_regulator_config;
+
+/*!
+ * @struct t_regulator_cfg_param
+ * @brief regulator configuration structure for IOCTL.
+ *
+ */
+typedef struct {
+	/*!
+	 * Regulator.
+	 */
+	t_pmic_regulator regulator;
+	/*!
+	 * Regulator configuration.
+	 */
+	t_regulator_config cfg;
+} t_regulator_cfg_param;
+
+/*!
+ * This struct list all state reads in Power Up Sense
+ */
+struct t_p_up_sense {
+	/*!
+	 * power up sense ictest
+	 */
+	bool state_ictest;
+	/*!
+	 * power up sense clksel
+	 */
+	bool state_clksel;
+	/*!
+	 * power up mode supply 1
+	 */
+	bool state_pums1;
+	/*!
+	 * power up mode supply 2
+	 */
+	bool state_pums2;
+	/*!
+	 * power up mode supply 3
+	 */
+	bool state_pums3;
+	/*!
+	 * power up sense charge mode 0
+	 */
+	bool state_chrgmode0;
+	/*!
+	 * power up sense charge mode 1
+	 */
+	bool state_chrgmode1;
+	/*!
+	 * power up sense USB mode
+	 */
+	bool state_umod;
+	/*!
+	 * power up sense boot mode enable for USB/RS232
+	 */
+	bool state_usben;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_1a1b_joined;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_2a2b_joined;
+};
+
+/*!
+ * This enumeration define all On_OFF button
+ */
+typedef enum {
+	/*!
+	 * ON1B
+	 */
+	BT_ON1B = 0,
+	/*!
+	 * ON2B
+	 */
+	BT_ON2B,
+	/*!
+	 * ON3B
+	 */
+	BT_ON3B,
+} t_button;
+
+#ifdef __KERNEL__
+/* EXPORTED FUNCTIONS */
+
+/*!
+ * This function sets user power off in power control register and thus powers
+ * off the phone.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+void pmic_power_off(void);
+
+/*!
+ * This function sets the power control configuration.
+ *
+ * @param        pc_config   power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_set_pc_config(t_pc_config *pc_config);
+
+/*!
+ * This function retrives the power control configuration.
+ *
+ * @param        pc_config   pointer to power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_pc_config(t_pc_config *pc_config);
+
+/*!
+ * This function turns on a regulator.
+ *
+ * @param        regulator    The regulator to be turned on.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator);
+
+/*!
+ * This function turns off a regulator.
+ *
+ * @param        regulator    The regulator to be turned off.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator);
+
+/*!
+ * This function sets the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      The regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage voltage);
+
+/*!
+ * This function retrieves the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      Pointer to regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage *voltage);
+
+/*!
+ * This function sets the DVS voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage dvs);
+
+/*!
+ * This function gets the DVS voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage *dvs);
+
+/*!
+ * This function sets the standby voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage stby);
+
+/*!
+ * This function gets the standby voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage *stby);
+
+/*!
+ * This function sets the switchers mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         The switcher mode
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode mode, bool stby);
+
+/*!
+ * This function gets the switchers mode.
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        mode         The switcher mode.
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode *mode, bool stby);
+
+/*!
+ * This function sets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed speed);
+
+/*!
+ * This function gets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed *speed);
+
+/*!
+ * This function sets the switch panic mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_panic_mode(t_pmic_regulator regulator,
+					       bool panic_mode);
+
+/*!
+ * This function gets the switch panic mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_panic_mode(t_pmic_regulator regulator,
+					       bool *panic_mode);
+
+/*!
+ * This function sets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_softstart(t_pmic_regulator regulator,
+					      bool softstart);
+
+/*!
+ * This function gets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_softstart(t_pmic_regulator regulator,
+					      bool *softstart);
+
+/*!
+ * This function sets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        factor              The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_factor(t_pmic_regulator regulator,
+					   t_switcher_factor factor);
+
+/*!
+ * This function gets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_factor(t_pmic_regulator regulator,
+					   t_switcher_factor *factor);
+
+/*!
+ * This function enables or disables low power mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode lp_mode);
+
+/*!
+ * This function gets low power mode.
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode *lp_mode);
+
+/*!
+ * This function sets the regulator configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       The regulator output configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_config(t_pmic_regulator regulator,
+					    t_regulator_config *config);
+
+/*!
+ * This function retrieves the regulator output configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       Pointer to regulator configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_config(t_pmic_regulator regulator,
+					    t_regulator_config *config);
+
+/*!
+ * This function enables automatically VBKUP2 in the memory hold modes.
+ *
+ * @param        en           if true, enable VBKUP2AUTOMH
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vbkup2_auto_en(bool en);
+
+/*!
+ * This function gets state of automatically VBKUP2.
+ *
+ * @param        en           if true, VBKUP2AUTOMH is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_vbkup2_auto_state(bool *en);
+
+/*!
+ * This function enables battery detect function.
+ *
+ * @param        en           if true, enable BATTDETEN
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_bat_det_en(bool en);
+
+/*!
+ * This function gets state of battery detect function.
+ *
+ * @param        en           if true, BATTDETEN is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_bat_det_state(bool *en);
+
+/*!
+ * This function enables control of VVIB by VIBEN pin.
+ *
+ * @param        en           if true, enable VIBPINCTRL
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vib_pin_en(bool en);
+
+/*!
+ * This function gets state of control of VVIB by VIBEN pin.
+ * @param        en           if true, VIBPINCTRL is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_gets_vib_pin_state(bool *en);
+
+/*!
+ * This function returns power up sense value
+ *
+ * @param        p_up_sense     value of power up sense
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_power_mode_sense(struct t_p_up_sense *p_up_sense);
+
+/*!
+ * This function configures the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         if true, the regulator is enabled by regen.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_assig(t_pmic_regulator regulator, bool en_dis);
+
+/*!
+ * This function gets the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         return value, if true :
+ *	the regulator is enabled by regen.
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_assig(t_pmic_regulator regu, bool *en_dis);
+
+/*!
+ * This function sets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_inv(bool en_dis);
+
+/*!
+ * This function gets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+
+PMIC_STATUS pmic_power_get_regen_inv(bool *en_dis);
+
+/*!
+ * This function enables esim control voltage.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_esim_v_en(bool vesim, bool vmmc1, bool vmmc2);
+
+/*!
+ * This function gets esim control voltage values.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_gets_esim_v_state(bool *vesim,
+					 bool *vmmc1, bool *vmmc2);
+
+/*!
+ * This function enables auto reset after a system reset.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_auto_reset_en(bool en);
+
+/*!
+ * This function gets auto reset configuration.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_auto_reset_en(bool *en);
+
+/*!
+ * This function configures a system reset on a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, enable the system reset on this button
+ * @param       deb_time   sets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_conf_button(t_button bt, bool sys_rst, int deb_time);
+
+/*!
+ * This function gets configuration of a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, the system reset is enabled on this button
+ * @param       deb_time   gets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_conf_button(t_button bt,
+				       bool *sys_rst, int *deb_time);
+
+/*!
+ * This function is used to subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_sub(t_pwr_int event, void *callback);
+
+/*!
+ * This function is used to un subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_unsub(t_pwr_int event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_POWER_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/sdma.h b/arch/arm/plat-mxc/include/mach/sdma.h
new file mode 100644
index 0000000..54131d7
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdma.h
@@ -0,0 +1,563 @@
+
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SDMA_H__
+#define __ASM_ARCH_MXC_SDMA_H__
+
+/*!
+ * @defgroup SDMA Smart Direct Memory Access (SDMA) Driver
+ */
+
+/*!
+ * @file arch-mxc/sdma.h
+ *
+ * @brief This file contains the SDMA API declarations.
+ *
+ * SDMA is responsible on moving data between peripherals and memories
+ * (MCU, EMI and DSP).
+ *
+ * @ingroup SDMA
+ */
+
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+/*!
+ * This defines maximum number of DMA channels
+ */
+#ifdef CONFIG_MXC_SDMA_API
+#define MAX_DMA_CHANNELS 32
+#define MAX_BD_NUMBER    16
+#define MXC_SDMA_DEFAULT_PRIORITY 1
+#define MXC_SDMA_MIN_PRIORITY 1
+#define MXC_SDMA_MAX_PRIORITY 7
+#else
+#define MAX_DMA_CHANNELS 0
+#endif
+
+#define MXC_FIFO_MEM_DEST_FIXED   0x1
+#define MXC_FIFO_MEM_SRC_FIXED    0x2
+
+#define SDMA_ASRC_INFO_WML_OFF	0
+#define SDMA_ASRC_INFO_WML_MASK ((1 << 10) - 1)
+#define SDMA_ASRC_INFO_PS	(1 << 10)
+#define SDMA_ASRC_INFO_PA	(1 << 11)
+#define SDMA_ASRC_INFO_TXFR_DIR	(1 << 14)
+#define SDMA_ASRC_INFO_N_OFF	(24)
+#define SDMA_ASRC_INFO_N_MASK	((1 << 4) - 1)
+
+#define SDMA_ASRC_P2P_INFO_LWML_OFF 0
+#define SDMA_ASRC_P2P_INFO_LWML_MASK ((1 << 8) - 1)
+#define SDMA_ASRC_P2P_INFO_PS	(1 << 8)
+#define SDMA_ASRC_P2P_INFO_PA	(1 << 9)
+#define SDMA_ASRC_P2P_INFO_SPDIF (1 << 10)
+#define SDMA_ASRC_P2P_INFO_SP (1 << 11)
+#define SDMA_ASRC_P2P_INFO_DP (1 << 12)
+#define SDMA_ASRC_P2P_INFO_HWML_OFF 14
+#define SDMA_ASRC_P2P_INFO_HWML_MASK ((1 << 10) - 1)
+#define SDMA_ASRC_P2P_INFO_LWE (1 << 28)
+#define SDMA_ASRC_P2P_INFO_HWE (1 << 29)
+#define SDMA_ASRC_P2P_INFO_CONT (1 << 31)
+
+/*!
+ * This enumerates  transfer types
+ */
+typedef enum {
+	emi_2_per = 0,		/*!< EMI memory to peripheral */
+	emi_2_int,		/*!< EMI memory to internal RAM */
+	emi_2_emi,		/*!< EMI memory to EMI memory */
+	emi_2_dsp,		/*!< EMI memory to DSP memory */
+	per_2_int,		/*!< Peripheral to internal RAM */
+	per_2_emi,		/*!< Peripheral to internal EMI memory */
+	per_2_dsp,		/*!< Peripheral to DSP memory */
+	per_2_per,		/*!< Peripheral to Peripheral */
+	int_2_per,		/*!< Internal RAM to peripheral */
+	int_2_int,		/*!< Internal RAM to Internal RAM */
+	int_2_emi,		/*!< Internal RAM to EMI memory */
+	int_2_dsp,		/*!< Internal RAM to DSP memory */
+	dsp_2_per,		/*!< DSP memory to peripheral */
+	dsp_2_int,		/*!< DSP memory to internal RAM */
+	dsp_2_emi,		/*!< DSP memory to EMI memory */
+	dsp_2_dsp,		/*!< DSP memory to DSP memory */
+	emi_2_dsp_loop,		/*!< EMI memory to DSP memory loopback */
+	dsp_2_emi_loop,		/*!< DSP memory to EMI memory loopback */
+	dvfs_pll,		/*!< DVFS script with PLL change       */
+	dvfs_pdr		/*!< DVFS script without PLL change    */
+} sdma_transferT;
+
+/*!
+ * This enumerates peripheral types
+ */
+typedef enum {
+	SSI,			/*!< MCU domain SSI */
+	SSI_SP,			/*!< Shared SSI */
+	MMC,			/*!< MMC */
+	SDHC,			/*!< SDHC */
+	UART,			/*!< MCU domain UART */
+	UART_SP,		/*!< Shared UART */
+	FIRI,			/*!< FIRI */
+	CSPI,			/*!< MCU domain CSPI */
+	CSPI_SP,		/*!< Shared CSPI */
+	SIM,			/*!< SIM */
+	ATA,			/*!< ATA */
+	CCM,			/*!< CCM */
+	EXT,			/*!< External peripheral */
+	MSHC,			/*!< Memory Stick Host Controller */
+	MSHC_SP,		/*!< Shared Memory Stick Host Controller */
+	DSP,			/*!< DSP */
+	MEMORY,			/*!< Memory */
+	FIFO_MEMORY,		/*!< FIFO type Memory */
+	SPDIF,			/*!< SPDIF */
+	IPU_MEMORY,		/*!< IPU Memory */
+	ASRC,			/*!< ASRC */
+	ESAI,			/*!< ESAI */
+} sdma_periphT;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines SDMA access data size
+ */
+#define TRANSFER_32BIT      0x00
+#define TRANSFER_8BIT       0x01
+#define TRANSFER_16BIT      0x02
+#define TRANSFER_24BIT      0x03
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+
+/*!
+ * This defines SDMA interrupt callback function prototype.
+ */
+typedef void (*dma_callback_t) (void *arg);
+
+/*!
+ * Structure containing sdma channel parameters.
+ */
+typedef struct {
+	__u32 watermark_level;	/*!< Lower/upper threshold that
+				 *   triggers SDMA event
+				 *   for p2p, this is event1 watermark level
+				 */
+	__u32 per_address;	/*!< Peripheral source/destination
+				 *   physical address
+				 *   for p2p, this is destination address
+				 */
+	sdma_periphT peripheral_type;	/*!< Peripheral type */
+	sdma_transferT transfer_type;	/*!< Transfer type   */
+	int event_id;		/*!< Event number,
+				 *   needed by all channels
+				 *   that started by peripherals dma
+				 *   request (per_2_*,*_2_per)
+				 *   Not used for memory and DSP
+				 *   transfers.
+				 */
+	int event_id2;		/*!< Second event number,
+				 *   used in ATA scripts only.
+				 */
+	int bd_number;		/*!< Buffer descriptors number.
+				 *   If not set, single buffer
+				 *   descriptor will be used.
+				 */
+	dma_callback_t callback;	/*!   callback function            */
+	void *arg;		/*!   callback argument            */
+	unsigned long word_size:8;	/*!< SDMA data access word size    */
+	unsigned long ext:1;	/*!< 1: extend parameter structure */
+} dma_channel_params;
+
+typedef struct {
+	dma_channel_params common;
+	unsigned long p2p_dir:1;	/*!< 0: per2 to per.
+					 * the device of peripheral_type is per.
+					 * 1: per to per2
+					 * the device of peripheral_type is per2
+					 */
+	unsigned long info_bits;	/*!< info field in context */
+	unsigned long info_mask;	/*!< info field mask in context */
+	__u32 watermark_level2;	/*!< event2 threshold that
+				 *   triggers SDMA event
+				 *   just valid for p2p.
+				 */
+	__u32 per_address2;	/*!< Peripheral source
+				 *   physical address.
+				 *   just valid for p2p.
+				 */
+	struct dma_channel_info info;	/*!< the channel special parameter */
+} dma_channel_ext_params;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*!   physical source memory address        */
+	__u8 *sourceAddr;
+	/*!   physical destination memory address   */
+	__u8 *destAddr;
+	/*!   amount of data to transfer,
+	 * updated during mxc_dma_get_config
+	 */
+	__u16 count;
+	/*!< DONE bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config
+	 * 0 - means the BD is done and closed by SDMA
+	 * 1 - means the BD is still being processed by SDMA
+	 */
+	int bd_done;
+	/*!< CONT bit of the buffer descriptor,
+	 * set it if full multi-buffer descriptor mechanism
+	 * required.
+	 */
+	int bd_cont;
+	/*!< ERROR bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config.
+	 * If it is set - there was an error during BD processing.
+	 */
+	int bd_error;
+} dma_request_t;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*! address of ap_2_ap script */
+	int mxc_sdma_ap_2_ap_addr;
+	/*! address of ap_2_bp script */
+	int mxc_sdma_ap_2_bp_addr;
+	/*! address of ap_2_ap_fixed script */
+	int mxc_sdma_ap_2_ap_fixed_addr;
+	/*! address of bp_2_ap script */
+	int mxc_sdma_bp_2_ap_addr;
+	/*! address of loopback_on_dsp_side script */
+	int mxc_sdma_loopback_on_dsp_side_addr;
+	/*! address of mcu_interrupt_only script */
+	int mxc_sdma_mcu_interrupt_only_addr;
+
+	/*! address of firi_2_per script */
+	int mxc_sdma_firi_2_per_addr;
+	/*! address of firi_2_mcu script */
+	int mxc_sdma_firi_2_mcu_addr;
+	/*! address of per_2_firi script */
+	int mxc_sdma_per_2_firi_addr;
+	/*! address of mcu_2_firi script */
+	int mxc_sdma_mcu_2_firi_addr;
+
+	/*! address of uart_2_per script */
+	int mxc_sdma_uart_2_per_addr;
+	/*! address of uart_2_mcu script */
+	int mxc_sdma_uart_2_mcu_addr;
+	/*! address of per_2_app script */
+	int mxc_sdma_per_2_app_addr;
+	/*! address of mcu_2_app script */
+	int mxc_sdma_mcu_2_app_addr;
+	/*! address of per_2_per script */
+	int mxc_sdma_per_2_per_addr;
+
+	/*! address of uartsh_2_per script */
+	int mxc_sdma_uartsh_2_per_addr;
+	/*! address of uartsh_2_mcu script */
+	int mxc_sdma_uartsh_2_mcu_addr;
+	/*! address of per_2_shp script */
+	int mxc_sdma_per_2_shp_addr;
+	/*! address of mcu_2_shp script */
+	int mxc_sdma_mcu_2_shp_addr;
+
+	/*! address of ata_2_mcu script */
+	int mxc_sdma_ata_2_mcu_addr;
+	/*! address of mcu_2_ata script */
+	int mxc_sdma_mcu_2_ata_addr;
+
+	/*! address of app_2_per script */
+	int mxc_sdma_app_2_per_addr;
+	/*! address of app_2_mcu script */
+	int mxc_sdma_app_2_mcu_addr;
+	/*! address of shp_2_per script */
+	int mxc_sdma_shp_2_per_addr;
+	/*! address of shp_2_mcu script */
+	int mxc_sdma_shp_2_mcu_addr;
+
+	/*! address of mshc_2_mcu script */
+	int mxc_sdma_mshc_2_mcu_addr;
+	/*! address of mcu_2_mshc script */
+	int mxc_sdma_mcu_2_mshc_addr;
+
+	/*! address of spdif_2_mcu script */
+	int mxc_sdma_spdif_2_mcu_addr;
+	/*! address of mcu_2_spdif script */
+	int mxc_sdma_mcu_2_spdif_addr;
+
+	/*! address of asrc_2_mcu script */
+	int mxc_sdma_asrc_2_mcu_addr;
+
+	/*! address of ext_mem_2_ipu script */
+	int mxc_sdma_ext_mem_2_ipu_addr;
+
+	/*! address of descrambler script */
+	int mxc_sdma_descrambler_addr;
+
+	/*! address of dptc_dvfs script */
+	int mxc_sdma_dptc_dvfs_addr;
+
+	int mxc_sdma_utra_addr;
+
+	/*! address where ram code starts */
+	int mxc_sdma_ram_code_start_addr;
+	/*! size of the ram code */
+	int mxc_sdma_ram_code_size;
+	/*! RAM image address */
+	unsigned short *mxc_sdma_start_addr;
+} sdma_script_start_addrs;
+
+/*! Structure to store the initialized dma_channel parameters */
+typedef struct mxc_sdma_channel_params {
+	/*! Channel type (static channel number or dynamic channel) */
+	unsigned int channel_num;
+	/*! Channel priority [0x1(lowest) - 0x7(highest)] */
+	unsigned int chnl_priority;
+	/*! Channel params */
+	dma_channel_params chnl_params;
+} mxc_sdma_channel_params_t;
+
+/*! Structure to store the initialized dma_channel extend parameters */
+typedef struct mxc_sdma_channel_ext_params {
+	/*! Channel type (static channel number or dynamic channel) */
+	unsigned int channel_num;
+	/*! Channel priority [0x1(lowest) - 0x7(highest)] */
+	unsigned int chnl_priority;
+	/*! Channel extend params */
+	dma_channel_ext_params chnl_ext_params;
+} mxc_sdma_channel_ext_params_t;
+
+/*! Private SDMA data structure */
+typedef struct mxc_dma_channel_private {
+	/*! ID of the buffer that was processed */
+	unsigned int buf_tail;
+	/*! Tasklet for the channel */
+	struct tasklet_struct chnl_tasklet;
+	/*! Flag indicates if interrupt is required after every BD transfer */
+	int intr_after_every_bd;
+} mxc_dma_channel_private_t;
+
+/*!
+ * Setup channel according to parameters.
+ * Must be called once after mxc_request_dma()
+ *
+ * @param   channel           channel number
+ * @param   p                 channel parameters pointer
+ * @return  0 on success, error code on fail
+ */
+int mxc_dma_setup_channel(int channel, dma_channel_params *p);
+
+/*!
+ * Setup the channel priority. This can be used to change the default priority
+ * for the channel.
+ *
+ * @param   channel           channel number
+ * @param   priority          priority to be set for the channel
+ *
+ * @return  0 on success, error code on failure
+ */
+int mxc_dma_set_channel_priority(unsigned int channel, unsigned int priority);
+
+/*!
+ * Allocates dma channel.
+ * If channel's value is 0, then the function allocates a free channel
+ * dynamically and sets its value to channel.
+ * Else allocates requested channel if it is free.
+ * If the channel is busy or no free channels (in dynamic allocation)
+ * -EBUSY returned.
+ *
+ * @param   channel           pointer to channel number
+ * @param   devicename        device name
+ * @return  0 on success, error code on fail
+ */
+int mxc_request_dma(int *channel, const char *devicename);
+
+/*!
+ * Configures request parameters. Can be called multiple times after
+ * mxc_request_dma() and mxc_dma_setup_channel().
+ *
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to set
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index);
+
+/*!
+ * Returns request parameters.
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to get
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index);
+
+/*!
+ * This function is used by MXC IPC's write_ex2. It passes the a pointer to the
+ * data control structure to iapi_write_ipcv2()
+ *
+ * @param channel  SDMA channel number
+ * @param ctrl_ptr Data Control structure pointer
+ */
+int mxc_sdma_write_ipcv2(int channel, void *ctrl_ptr);
+
+/*!
+ * This function is used by MXC IPC's read_ex2. It passes the a pointer to the
+ * data control structure to iapi_read_ipcv2()
+ *
+ * @param channel   SDMA channel number
+ * @param ctrl_ptr  Data Control structure pointer
+ */
+int mxc_sdma_read_ipcv2(int channel, void *ctrl_ptr);
+
+/*!
+ * Starts dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_start(int channel);
+
+/*!
+ * Stops dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_stop(int channel);
+
+/*!
+ * Frees dma channel.
+ *
+ * @param   channel           channel number
+ */
+void mxc_free_dma(int channel);
+
+/*!
+ * Sets callback function. Used with standard dma api
+ *  for supporting interrupts
+ *
+ * @param   channel           channel number
+ * @param   callback          callback function pointer
+ * @param   arg               argument for callback function
+ */
+void mxc_dma_set_callback(int channel, dma_callback_t callback, void *arg);
+
+/*!
+ * Allocates uncachable buffer. Uses hash table.
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_malloc(size_t size);
+
+#ifdef CONFIG_SDMA_IRAM
+/*!
+ * Allocates uncachable buffer from IRAM..
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_iram_malloc(size_t size);
+#endif				/*CONFIG_SDMA_IRAM */
+
+/*!
+ * Frees uncachable buffer. Uses hash table.
+ */
+void sdma_free(void *buf);
+
+/*!
+ * Converts virtual to physical address. Uses hash table.
+ *
+ * @param   buf  virtual address pointer
+ * @return  physical address value
+ */
+unsigned long sdma_virt_to_phys(void *buf);
+
+/*!
+ * Converts physical to virtual address. Uses hash table.
+ *
+ * @param   buf  physical address value
+ * @return  virtual address pointer
+ */
+void *sdma_phys_to_virt(unsigned long buf);
+
+/*!
+ * Configures the BD_INTR bit on a buffer descriptor parameters.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ * @param   bd_intr           flag to set or clear the BD_INTR bit
+ */
+void mxc_dma_set_bd_intr(int channel, int bd_index, int bd_intr);
+
+/*!
+ * Gets the BD_INTR bit on a buffer descriptor.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ *
+ * @return returns the BD_INTR bit status
+ */
+int mxc_dma_get_bd_intr(int channel, int bd_index);
+
+/*!
+ * Stop the current transfer
+ *
+ * @param   channel           channel number
+ * @param   buffer_number     number of buffers (beginning with 0),
+ *                            whose done bits should be reset to 0
+ */
+int mxc_dma_reset(int channel, int buffer_number);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl);
+
+/*!
+ * Initializes SDMA driver
+ */
+int __init sdma_init(void);
+
+#define DEFAULT_ERR     1
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/sdram_autogating.h b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
new file mode 100644
index 0000000..471a25e
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DVFS Dynamic Voltage and Frequency Scaling (DVFS) Driver
+ */
+
+/*!
+ * @file arch-mxc/sdram_autogating.h
+ *
+ * @brief This file contains the SDRAM autogating function prototypes
+ *
+ *
+ * @ingroup PM
+ */
+
+#ifndef __ASM_ARCH_SDRAM_AUTOGATING_H__
+#define __ASM_ARCH_SDRAM_AUTOGATING_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+
+#ifdef CONFIG_ARCH_MX51
+extern void start_sdram_autogating(void);
+extern void stop_sdram_autogating(void);
+extern int sdram_autogating_active(void);
+#else
+static inline void start_sdram_autogating(void)
+{}
+
+static inline void stop_sdram_autogating(void)
+{}
+
+static inline int sdram_autogating_active(void)
+{
+	return 0;
+}
+#endif
+
+#endif				/*__KERNEL__ */
+#endif				/* __ASM_ARCH_MXC_DVFS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/spba.h b/arch/arm/plat-mxc/include/mach/spba.h
new file mode 100644
index 0000000..8d018be
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/spba.h
@@ -0,0 +1,66 @@
+
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup SPBA Shared Peripheral Bus Arbiter (SPBA)
+ * @ingroup MSL_MX31 MSL_MX35 MSL_MX37 MSL_MX51 MSL_MXC91321
+ */
+
+/*!
+ * @file arch-mxc/spba.h
+ * @brief This file contains the Shared Peripheral Bus Arbiter (spba) API.
+ *
+ * @ingroup SPBA
+ */
+
+#ifndef __ASM_ARCH_MXC_SPBA_H__
+#define __ASM_ARCH_MXC_SPBA_H__
+
+#ifdef __KERNEL__
+
+#define MXC_SPBA_RAR_MASK       0x7
+
+/*!
+ * Defines three SPBA masters: A - ARM, C - SDMA (no master B for MX31)
+ */
+enum spba_masters {
+	SPBA_MASTER_A = 1,
+	SPBA_MASTER_B = 2,
+	SPBA_MASTER_C = 4,
+};
+
+/*!
+ * This function allows the three masters (A, B, C) to take ownership of a
+ * shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_take_ownership(int mod, int master);
+
+/*!
+ * This function releases the ownership for a shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_rel_ownership(int mod, int master);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_SPBA_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
index ef00199..bb9ccf8 100644
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -32,8 +32,13 @@ static inline void arch_idle(void)
 		mxc91231_prepare_idle();
 	}
 #endif
-
+#ifdef CONFIG_ARCH_MX51
+	mx51_arch_idle();
+#elif CONFIG_ARCH_MX31
+	mx31_arch_idle();
+#else
 	cpu_do_idle();
+#endif
 }
 
 void arch_reset(char mode, const char *cmd);
-- 
1.6.5.2

