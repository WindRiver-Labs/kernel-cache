From 994385f35b4021a830c0e9d3e6ccf0f4cc57d8d9 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Fri, 19 Jun 2009 19:55:34 +0800
Subject: [PATCH] fsl_imx: add pmic mc13783 regulator control

Original reference code source taken from Freescale
    BSP Global Package Pool.
    http://www.bitshrine.org/gpp/linux-2.6.24-imx_2.3.2.bz2

Add generic Voltage and Current Regulator support.
This is redundant version of regulators API to be able
to use PMIC regulators driver and a couple of drivers that
require old (2.6.24 based) regulators API. And Add pmic
mc13783 regulator support, this is an enhancement for pm
which is good for power sensitive device.

Also includes:
Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

PMIC mc13892 chip has ability to control the voltage or the current
for some devices. Based on this function, develop this regulator
driver.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
Signed-off-by: Vladimir Barinov <vbarinov@embeddedalley.com>
Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/regulator/Kconfig                    |   23 +
 drivers/regulator/Makefile                   |    8 +-
 drivers/regulator/mc13783/Makefile           |    5 +
 drivers/regulator/mc13783/reg-mc13783.c      | 3300 ++++++++++++++++++++++++++
 drivers/regulator/reg-core.c                 |  893 +++++++
 drivers/regulator/reg-mc13892.c              | 1854 +++++++++++++++
 include/linux/regulator/regulator-drv.h      |  107 +
 include/linux/regulator/regulator-platform.h |  102 +
 include/linux/regulator/regulator.h          |  341 +++
 9 files changed, 6632 insertions(+), 1 deletions(-)
 create mode 100644 drivers/regulator/mc13783/Makefile
 create mode 100644 drivers/regulator/mc13783/reg-mc13783.c
 create mode 100644 drivers/regulator/reg-core.c
 create mode 100644 drivers/regulator/reg-mc13892.c
 create mode 100644 include/linux/regulator/regulator-drv.h
 create mode 100644 include/linux/regulator/regulator-platform.h
 create mode 100644 include/linux/regulator/regulator.h

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index a656128..272129c 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -56,4 +56,27 @@ config REGULATOR_BQ24022
 	  charging select between 100 mA and 500 mA charging current
 	  limit.
 
+config REGULATOR_API
+	bool
+
+config REGULATOR_DEPRECATED
+	bool
+
+config REGULATOR_MC13783
+	tristate "MC13783 Regulator Support"
+	depends on MXC_PMIC_MC13783
+	select REGULATOR_API
+	select REGULATOR_DEPRECATED
+	default n
+	help
+	  This driver supports Freescale mc13783 PMIC. The provided
+	  regulator can enable/disable peripheral power supply, and
+	  control voltage or current under predefined constraint.
+
+config REGULATOR_MC13892
+	tristate "MC13892 Regulator Support"
+	depends on REGULATOR
+	depends on MXC_PMIC_MC13892
+	default y
+
 endmenu
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index ac2c64e..e6d2051 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -2,11 +2,17 @@
 # Makefile for regulator drivers.
 #
 
-
+ifeq ($(CONFIG_REGULATOR_DEPRECATED),y)
+obj-$(CONFIG_REGULATOR) += reg-core.o
+else
 obj-$(CONFIG_REGULATOR) += core.o
+endif
+
 obj-$(CONFIG_REGULATOR_FIXED_VOLTAGE) += fixed.o
 obj-$(CONFIG_REGULATOR_VIRTUAL_CONSUMER) += virtual.o
 
 obj-$(CONFIG_REGULATOR_BQ24022) += bq24022.o
+obj-$(CONFIG_REGULATOR_MC13892) += reg-mc13892.o
+obj-$(CONFIG_REGULATOR_MC13783) += mc13783/
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/mc13783/Makefile b/drivers/regulator/mc13783/Makefile
new file mode 100644
index 0000000..77399db
--- /dev/null
+++ b/drivers/regulator/mc13783/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for regulator driver for MC13783.
+#
+
+obj-$(CONFIG_REGULATOR_MC13783) += reg-mc13783.o
diff --git a/drivers/regulator/mc13783/reg-mc13783.c b/drivers/regulator/mc13783/reg-mc13783.c
new file mode 100644
index 0000000..ae9ea26
--- /dev/null
+++ b/drivers/regulator/mc13783/reg-mc13783.c
@@ -0,0 +1,3300 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/regulator-platform.h>
+#include <linux/regulator/regulator-drv.h>
+
+#include <asm/plat-mxc/pmic_status.h>
+#include <asm/plat-mxc/pmic_external.h>
+
+/*!
+ * brief PMIC regulators.
+ */
+
+enum {
+	MC13783_SW1A = 0,	/*!< SW1A or SW1 */
+	MC13783_SW1B,		/*!< SW1B */
+	MC13783_SW2A,		/*!< SW2A or SW2 */
+	MC13783_SW2B,		/*!< SW2B */
+	MC13783_SW3,		/*!< SW3 */
+	MC13783_VAUDIO,		/*!< VAUDIO */
+	MC13783_VIOHI,		/*!< VIOHI */
+	MC13783_VIOLO,		/*!< VIOLO */
+	MC13783_VDIG,		/*!< VDIG */
+	MC13783_VGEN,		/*!< VGEN */
+	MC13783_VRFDIG,		/*!< VRFDIG */
+	MC13783_VRFREF,		/*!< VRFREF */
+	MC13783_VRFCP,		/*!< VRFCP */
+	MC13783_VSIM,		/*!< VSIM */
+	MC13783_VESIM,		/*!< VESIM */
+	MC13783_VCAM,		/*!< VCAM */
+	MC13783_VRFBG,		/*!< VRFBG */
+	MC13783_VVIB,		/*!< VVIB */
+	MC13783_VRF1,		/*!< VRF1 */
+	MC13783_VRF2,		/*!< VRF2 */
+	MC13783_VMMC1,		/*!< VMMC1 or VMMC */
+	MC13783_VMMC2,		/*!< VMMC2 */
+	MC13783_GPO1,		/*!< GPIO1 */
+	MC13783_GPO2,		/*!< GPO2 */
+	MC13783_GPO3,		/*!< GPO3 */
+	MC13783_GPO4,		/*!< GPO4 */
+} MC13783_regulator;
+
+/*!
+ * @enum regulator_voltage_sw
+ * @brief PMIC regulator SW output voltage.
+ */
+enum {
+	SW_0_9V = 0,		/*!< 0.900 V */
+	SW_0_925V,		/*!< 0.925 V */
+	SW_0_95V,		/*!< 0.950 V */
+	SW_0_975V,		/*!< 0.975 V */
+	SW_1V,			/*!< 1.000 V */
+	SW_1_025V,		/*!< 1.025 V */
+	SW_1_05V,		/*!< 1.050 V */
+	SW_1_075V,		/*!< 1.075 V */
+	SW_1_1V,		/*!< 1.100 V */
+	SW_1_125V,		/*!< 1.125 V */
+	SW_1_15V,		/*!< 1.150 V */
+	SW_1_175V,		/*!< 1.175 V */
+	SW_1_2V,		/*!< 1.200 V */
+	SW_1_225V,		/*!< 1.225 V */
+	SW_1_25V,		/*!< 1.250 V */
+	SW_1_275V,		/*!< 1.275 V */
+	SW_1_3V,		/*!< 1.300 V */
+	SW_1_325V,		/*!< 1.325 V */
+	SW_1_35V,		/*!< 1.350 V */
+	SW_1_375V,		/*!< 1.375 V */
+	SW_1_4V,		/*!< 1.400 V */
+	SW_1_425V,		/*!< 1.425 V */
+	SW_1_45V,		/*!< 1.450 V */
+	SW_1_475V,		/*!< 1.475 V */
+	SW_1_5V,		/*!< 1.500 V */
+	SW_1_525V,		/*!< 1.525 V */
+	SW_1_55V,		/*!< 1.550 V */
+	SW_1_575V,		/*!< 1.575 V */
+	SW_1_6V,		/*!< 1.600 V */
+	SW_1_625V,		/*!< 1.625 V */
+	SW_1_65V,		/*!< 1.650 V */
+	SW_1_675V,		/*!< 1.675 V */
+	SW_1_7V,		/*!< 1.700 V */
+	SW_1_8V = 36,		/*!< 1.800 V */
+	SW_1_85V = 40,		/*!< 1.850 V */
+	SW_2V = 44,		/*!< 2_000 V */
+	SW_2_1V = 48,		/*!< 2_100 V */
+	SW_2_2V = 52,		/*!< 2_200 V */
+} regulator_voltage_sw;
+
+/*!
+ * @enum regulator_voltage_violo
+ * @brief PMIC regulator VIOLO output voltage.
+ */
+enum {
+	VIOLO_1_2V = 0,		/*!< 1.2 V */
+	VIOLO_1_3V,		/*!< 1.3 V */
+	VIOLO_1_5V,		/*!< 1.5 V */
+	VIOLO_1_8V,		/*!< 1.8 V */
+} regulator_voltage_violo;
+
+/*!
+ * @enum regulator_voltage_vdig
+ * @brief PMIC regulator VDIG output voltage.
+ */
+enum {
+	VDIG_1_2V = 0,		/*!< 1.2 V */
+	VDIG_1_3V,		/*!< 1.3 V */
+	VDIG_1_5V,		/*!< 1.5 V */
+	VDIG_1_8V,		/*!< 1.8 V */
+} regulator_voltage_vdig;
+
+/*!
+ * @enum regulator_voltage_vgen
+ * @brief PMIC regulator VGEN output voltage.
+ */
+enum {
+	VGEN_1_2V = 0,		/*!< 1.2 V */
+	VGEN_1_3V,		/*!< 1.3 V */
+	VGEN_1_5V,		/*!< 1.5 V */
+	VGEN_1_8V,		/*!< 1.8 V */
+	VGEN_1_1V,		/*!< 1.1 V */
+	VGEN_2V,		/*!< 2 V */
+	VGEN_2_775V,		/*!< 2.775 V */
+	VGEN_2_4V,		/*!< 2.4 V */
+} regulator_voltage_vgen;
+
+/*!
+ * @enum regulator_voltage_vrfdig
+ * @brief PMIC regulator VRFDIG output voltage.
+ */
+enum {
+	VRFDIG_1_2V = 0,	/*!< 1.2 V */
+	VRFDIG_1_5V,		/*!< 1.5 V */
+	VRFDIG_1_8V,		/*!< 1.8 V */
+	VRFDIG_1_875V,		/*!< 1.875 V */
+} regulator_voltage_vrfdig;
+
+/*!
+ * @enum regulator_voltage_vrfref
+ * @brief PMIC regulator VRFREF output voltage.
+ */
+enum {
+	VRFREF_2_475V = 0,	/*!< 2.475 V */
+	VRFREF_2_6V,		/*!< 2.600 V */
+	VRFREF_2_7V,		/*!< 2.700 V */
+	VRFREF_2_775V,		/*!< 2.775 V */
+} regulator_voltage_vrfref;
+
+/*!
+ * @enum regulator_voltage_vrfcp
+ * @brief PMIC regulator VRFCP output voltage.
+ */
+enum {
+	VRFCP_2_7V = 0,		/*!< 2.700 V */
+	VRFCP_2_775V,		/*!< 2.775 V */
+} regulator_voltage_vrfcp;
+
+/*!
+ * @enum regulator_voltage_vsim
+ * @brief PMIC linear regulator VSIM output voltage.
+ */
+enum {
+	VSIM_1_8V = 0,		/*!< 1.8 V */
+	VSIM_2_9V,		/*!< 2.90 V */
+	VSIM_3V = 1,		/*!< 3 V */
+} regulator_voltage_vsim;
+
+/*!
+ * @enum regulator_voltage_vesim
+ * @brief PMIC regulator VESIM output voltage.
+ */
+enum {
+	VESIM_1_8V = 0,		/*!< 1.80 V */
+	VESIM_2_9V,		/*!< 2.90 V */
+} regulator_voltage_vesim;
+
+/*!
+ * @enum regulator_voltage_vcam
+ * @brief PMIC regulator VCAM output voltage.
+ */
+enum {
+	VCAM_1_5V = 0,		/*!< 1.50 V */
+	VCAM_1_8V,		/*!< 1.80 V */
+	VCAM_2_5V,		/*!< 2.50 V */
+	VCAM_2_55V,		/*!< 2.55 V */
+	VCAM_2_6V,		/*!< 2.60 V */
+	VCAM_2_75V,		/*!< 2.75 V */
+	VCAM_2_8V,		/*!< 2.80 V */
+	VCAM_3V,		/*!< 3.00 V */
+} regulator_voltage_vcam;
+
+/*!
+ * @enum regulator_voltage_vvib
+ * @brief PMIC linear regulator V_VIB output voltage.
+ */
+enum {
+	VVIB_1_3V = 0,		/*!< 1.30 V */
+	VVIB_1_8V,		/*!< 1.80 V */
+	VVIB_2V,		/*!< 2 V */
+	VVIB_3V,		/*!< 3 V */
+} regulator_voltage_vvib;
+
+/*!
+ * @enum regulator_voltage_vmmc
+ * @brief MC13783 PMIC regulator VMMC output voltage.
+ */
+enum {
+	VMMC_1_6V = 0,		/*!< 1.60 V */
+	VMMC_1_8V,		/*!< 1.80 V */
+	VMMC_2V,		/*!< 2.00 V */
+	VMMC_2_6V,		/*!< 2.60 V */
+	VMMC_2_7V,		/*!< 2.70 V */
+	VMMC_2_8V,		/*!< 2.80 V */
+	VMMC_2_9V,		/*!< 2.90 V */
+	VMMC_3V,		/*!< 3.00 V */
+} regulator_voltage_vmmc;
+
+/*!
+ * @enum regulator_voltage_vrf
+ * @brief PMIC regulator VRF output voltage.
+ */
+enum {
+	VRF_1_5V = 0,		/*!< 1.500 V */
+	VRF_1_875V,		/*!< 1.875 V */
+	VRF_2_7V,		/*!< 2.700 V */
+	VRF_2_775V,		/*!< 2.775 V */
+} regulator_voltage_vrf;
+
+/*!
+ * @enum regulator_voltage_sw3
+ * @brief PMIC Switch mode regulator SW3 output voltages.
+ */
+enum {
+	SW3_5V = 0,		/*!< 5.0 V */
+	SW3_5_5V = 3,		/*!< 5.5 V */
+} regulator_voltage_sw3;
+
+/*!
+ * The \b TPmicDVSTransitionSpeed enum defines
+ * the rate with which the
+ * voltage transition occurs.
+ */
+enum {
+	ESysDependent,
+	E25mVEach4us,
+	E25mVEach8us,
+	E25mvEach16us
+} DVS_transition_speed;
+
+/*
+ * Reg Regulator Mode 0
+ */
+#define VAUDIO_EN_LSH	0
+#define VAUDIO_EN_WID	1
+#define VAUDIO_EN_ENABLE	1
+#define VAUDIO_EN_DISABLE	0
+#define VIOHI_EN_LSH	3
+#define VIOHI_EN_WID	1
+#define VIOHI_EN_ENABLE	1
+#define VIOHI_EN_DISABLE	0
+#define VIOLO_EN_LSH	6
+#define VIOLO_EN_WID	1
+#define VIOLO_EN_ENABLE	1
+#define VIOLO_EN_DISABLE	0
+#define VDIG_EN_LSH	9
+#define VDIG_EN_WID	1
+#define VDIG_EN_ENABLE	1
+#define VDIG_EN_DISABLE	0
+#define VGEN_EN_LSH	12
+#define VGEN_EN_WID	1
+#define VGEN_EN_ENABLE	1
+#define VGEN_EN_DISABLE	0
+#define VRFDIG_EN_LSH	15
+#define VRFDIG_EN_WID	1
+#define VRFDIG_EN_ENABLE	1
+#define VRFDIG_EN_DISABLE	0
+#define VRFREF_EN_LSH	18
+#define VRFREF_EN_WID	1
+#define VRFREF_EN_ENABLE	1
+#define VRFREF_EN_DISABLE	0
+#define VRFCP_EN_LSH	21
+#define VRFCP_EN_WID	1
+#define VRFCP_EN_ENABLE	1
+#define VRFCP_EN_DISABLE	0
+
+/*
+ * Reg Regulator Mode 1
+ */
+#define VSIM_EN_LSH	0
+#define VSIM_EN_WID	1
+#define VSIM_EN_ENABLE	1
+#define VSIM_EN_DISABLE	0
+#define VESIM_EN_LSH	3
+#define VESIM_EN_WID	1
+#define VESIM_EN_ENABLE	1
+#define VESIM_EN_DISABLE	0
+#define VCAM_EN_LSH	6
+#define VCAM_EN_WID	1
+#define VCAM_EN_ENABLE	1
+#define VCAM_EN_DISABLE	0
+#define VRFBG_EN_LSH	9
+#define VRFBG_EN_WID	1
+#define VRFBG_EN_ENABLE	1
+#define VRFBG_EN_DISABLE	0
+#define VVIB_EN_LSH	11
+#define VVIB_EN_WID	1
+#define VVIB_EN_ENABLE	1
+#define VVIB_EN_DISABLE	0
+#define VRF1_EN_LSH	12
+#define VRF1_EN_WID	1
+#define VRF1_EN_ENABLE	1
+#define VRF1_EN_DISABLE	0
+#define VRF2_EN_LSH	15
+#define VRF2_EN_WID	1
+#define VRF2_EN_ENABLE	1
+#define VRF2_EN_DISABLE	0
+#define VMMC1_EN_LSH	18
+#define VMMC1_EN_WID	1
+#define VMMC1_EN_ENABLE	1
+#define VMMC1_EN_DISABLE	0
+#define VMMC2_EN_LSH	21
+#define VMMC2_EN_WID	1
+#define VMMC2_EN_ENABLE	1
+#define VMMC2_EN_DISABLE	0
+
+/*
+ * Reg Regulator Setting 0
+ */
+#define VIOLO_LSH		2
+#define VIOLO_WID		2
+#define VDIG_LSH		4
+#define VDIG_WID		2
+#define VGEN_LSH		6
+#define VGEN_WID		3
+#define VRFDIG_LSH		9
+#define VRFDIG_WID		2
+#define VRFREF_LSH		11
+#define VRFREF_WID		2
+#define VRFCP_LSH		13
+#define VRFCP_WID		1
+#define VSIM_LSH		14
+#define VSIM_WID		1
+#define VESIM_LSH		15
+#define VESIM_WID		1
+#define VCAM_LSH		16
+#define VCAM_WID		3
+
+/*
+ * Reg Regulator Setting 1
+ */
+#define VVIB_LSH		0
+#define VVIB_WID		2
+#define VRF1_LSH		2
+#define VRF1_WID		2
+#define VRF2_LSH		4
+#define VRF2_WID		2
+#define VMMC1_LSH		6
+#define VMMC1_WID		3
+#define VMMC2_LSH		9
+#define VMMC2_WID		3
+
+/*
+ * Reg Switcher 0
+ */
+#define SW1A_LSH		0
+#define SW1A_WID		6
+#define SW1A_DVS_LSH	6
+#define SW1A_DVS_WID	6
+#define SW1A_STDBY_LSH	12
+#define SW1A_STDBY_WID	6
+
+/*
+ * Reg Switcher 1
+ */
+#define SW1B_LSH		0
+#define SW1B_WID		6
+#define SW1B_DVS_LSH	6
+#define SW1B_DVS_WID	6
+#define SW1B_STDBY_LSH	12
+#define SW1B_STDBY_WID	6
+
+/*
+ * Reg Switcher 2
+ */
+#define SW2A_LSH		0
+#define SW2A_WID		6
+#define SW2A_DVS_LSH	6
+#define SW2A_DVS_WID	6
+#define SW2A_STDBY_LSH	12
+#define SW2A_STDBY_WID	6
+
+/*
+ * Reg Switcher 3
+ */
+#define SW2B_LSH		0
+#define SW2B_WID		6
+#define SW2B_DVS_LSH	6
+#define SW2B_DVS_WID	6
+#define SW2B_STDBY_LSH	12
+#define SW2B_STDBY_WID	6
+
+/*
+ * Reg Switcher 4
+ */
+#define SW1A_MODE_LSH		0
+#define SW1A_MODE_WID		2
+#define SW1A_STBY_MODE_LSH		2
+#define SW1A_STBY_MODE_WID		2
+#define SW1A_DVS_SPEED_LSH		6
+#define SW1A_DVS_SPEED_WID		2
+#define SW1B_MODE_LSH		10
+#define SW1B_MODE_WID		2
+#define SW1B_STBY_MODE_LSH		12
+#define SW1B_STBY_MODE_WID		2
+#define SW1B_DVS_SPEED_LSH		14
+#define SW1B_DVS_SPEED_WID		2
+
+/*
+ * Reg Switcher 5
+ */
+#define SW2A_MODE_LSH		0
+#define SW2A_MODE_WID		2
+#define SW2A_STBY_MODE_LSH		2
+#define SW2A_STBY_MODE_WID		2
+#define SW2A_DVS_SPEED_LSH		6
+#define SW2A_DVS_SPEED_WID		2
+#define SW2B_MODE_LSH		10
+#define SW2B_MODE_WID		2
+#define SW2B_STBY_MODE_LSH		12
+#define SW2B_STBY_MODE_WID		2
+#define SW2B_DVS_SPEED_LSH		14
+#define SW2B_DVS_SPEED_WID		2
+#define SW3_LSH			18
+#define SW3_WID			2
+#define SW3_EN_LSH			20
+#define SW3_EN_WID			2
+#define SW3_EN_ENABLE		1
+#define SW3_EN_DISABLE		0
+
+/*
+ * Reg Regulator Misc.
+ */
+#define GPO1_EN_LSH	6
+#define GPO1_EN_WID	1
+#define GPO1_EN_ENABLE	1
+#define GPO1_EN_DISABLE	0
+#define GPO2_EN_LSH	8
+#define GPO2_EN_WID	1
+#define GPO2_EN_ENABLE	1
+#define GPO2_EN_DISABLE	0
+#define GPO3_EN_LSH	10
+#define GPO3_EN_WID	1
+#define GPO3_EN_ENABLE	1
+#define GPO3_EN_DISABLE	0
+#define GPO4_EN_LSH	12
+#define GPO4_EN_WID	1
+#define GPO4_EN_ENABLE	1
+#define GPO4_EN_DISABLE	0
+
+/*
+ * Switcher mode configuration
+ */
+#define SW_MODE_SYNC_RECT_EN	0
+#define SW_MODE_PULSE_NO_SKIP_EN	1
+#define SW_MODE_PULSE_SKIP_EN	2
+#define SW_MODE_LOW_POWER_EN	3
+
+#define NUM_MC13783_REGULATORS 33
+#define dvs_speed E25mvEach16us
+
+static int mc13783_vaudio_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_ENABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vaudio_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_DISABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_viohi_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_ENABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_viohi_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_DISABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_violo_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0, register1 = 0;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1300))
+		voltage = VIOLO_1_2V;
+	else if ((mV >= 1300) && (mV < 1500))
+		voltage = VIOLO_1_3V;
+	else if ((mV >= 1500) && (mV < 1800))
+		voltage = VIOLO_1_5V;
+	else
+		voltage = VIOLO_1_8V;
+
+	register_val = BITFVAL(VIOLO, voltage);
+	register_mask = BITFMASK(VIOLO);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_violo_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VIOLO);
+
+	switch (voltage) {
+	case VIOLO_1_2V:
+			mV = 1200;
+			break;
+	case VIOLO_1_3V:
+			mV = 1300;
+			break;
+	case VIOLO_1_5V:
+			mV = 1500;
+			break;
+	case VIOLO_1_8V:
+			mV = 1800;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_violo_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOLO_EN, VIOLO_EN_ENABLE);
+	register_mask = BITFMASK(VIOLO_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_violo_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOLO_EN, VIOLO_EN_DISABLE);
+	register_mask = BITFMASK(VIOLO_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vdig_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1300))
+		voltage = VDIG_1_2V;
+	else if ((mV >= 1300) && (mV < 1500))
+		voltage = VDIG_1_3V;
+	else if ((mV >= 1500) && (mV < 1800))
+		voltage = VDIG_1_5V;
+	else
+		voltage = VDIG_1_8V;
+
+	register_val = BITFVAL(VDIG, voltage);
+	register_mask = BITFMASK(VDIG);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vdig_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VDIG);
+
+	switch (voltage) {
+	case VDIG_1_2V:
+			mV = 1200;
+			break;
+	case VDIG_1_3V:
+			mV = 1300;
+			break;
+	case VDIG_1_5V:
+			mV = 1500;
+			break;
+	case VDIG_1_8V:
+			mV = 1800;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vdig_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_ENABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vdig_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_DISABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vgen_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+	int vgenid = reg->id;
+
+	printk(KERN_INFO "VGEN ID is %d\n", vgenid);
+
+	if ((mV >= 1100) && (mV < 1200))
+		voltage = VGEN_1_1V;
+	else if ((mV >= 1200) && (mV < 1300))
+		voltage = VGEN_1_2V;
+	else if ((mV >= 1300) && (mV < 1500))
+		voltage = VGEN_1_3V;
+	else if ((mV >= 1500) && (mV < 1800))
+		voltage = VGEN_1_5V;
+	else if ((mV >= 1800) && (mV < 2000))
+		voltage = VGEN_1_8V;
+	else if ((mV >= 2000) && (mV < 2400))
+		voltage = VGEN_2V;
+	else if ((mV >= 2400) && (mV < 2775))
+		voltage = VGEN_2_4V;
+	else
+		voltage = VGEN_2_775V;
+
+	register_val = BITFVAL(VGEN, voltage);
+	register_mask = BITFMASK(VGEN);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vgen_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN);
+
+	switch (voltage) {
+	case VGEN_1_2V:
+			mV = 1200;
+			break;
+	case VGEN_1_3V:
+			mV = 1300;
+			break;
+	case VGEN_1_5V:
+			mV = 1500;
+			break;
+	case VGEN_1_8V:
+			mV = 1800;
+			break;
+	case VGEN_1_1V:
+			mV = 1100;
+			break;
+	case VGEN_2V:
+			mV = 2000;
+			break;
+	case VGEN_2_775V:
+			mV = 2775;
+			break;
+	case VGEN_2_4V:
+			mV = 2400;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vgen_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN_EN, VGEN_EN_ENABLE);
+	register_mask = BITFMASK(VGEN_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vgen_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN_EN, VGEN_EN_DISABLE);
+	register_mask = BITFMASK(VGEN_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vrfdig_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1500))
+		voltage = VRFDIG_1_2V;
+	else if ((mV >= 1500) && (mV < 1300))
+		voltage = VRFDIG_1_5V;
+	else if ((mV >= 1800) && (mV < 1875))
+		voltage = VRFDIG_1_8V;
+	else
+		voltage = VRFDIG_1_875V;
+
+	register_val = BITFVAL(VRFDIG, voltage);
+	register_mask = BITFMASK(VRFDIG);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vrfdig_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VRFDIG);
+
+	switch (voltage) {
+	case VRFDIG_1_2V:
+			mV = 1200;
+			break;
+	case VRFDIG_1_5V:
+			mV = 1500;
+			break;
+	case VRFDIG_1_8V:
+			mV = 1800;
+			break;
+	case VRFDIG_1_875V:
+			mV = 1875;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vrfdig_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFDIG_EN, VRFDIG_EN_ENABLE);
+	register_mask = BITFMASK(VRFDIG_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfdig_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFDIG_EN, VRFDIG_EN_DISABLE);
+	register_mask = BITFMASK(VRFDIG_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfref_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2475) && (mV < 2600))
+		voltage = VRFREF_2_475V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VRFREF_2_6V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VRFREF_2_7V;
+	else
+		voltage = VRFREF_2_775V;
+
+	register_val = BITFVAL(VRFREF, voltage);
+	register_mask = BITFMASK(VRFREF);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfref_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VRFREF);
+
+	switch (voltage) {
+	case VRFREF_2_475V:
+			mV = 2475;
+			break;
+	case VRFREF_2_6V:
+			mV = 2600;
+			break;
+	case VRFREF_2_7V:
+			mV = 2700;
+			break;
+	case VRFREF_2_775V:
+			mV = 2775;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vrfref_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFREF_EN, VRFREF_EN_ENABLE);
+	register_mask = BITFMASK(VRFREF_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfref_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFREF_EN, VRFREF_EN_DISABLE);
+	register_mask = BITFMASK(VRFREF_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfcp_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2700) && (mV < 2775))
+		voltage = VRFCP_2_7V;
+	else
+		voltage = VRFCP_2_775V;
+
+	register_val = BITFVAL(VRFCP, voltage);
+	register_mask = BITFMASK(VRFCP);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfcp_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VRFCP);
+
+	switch (voltage) {
+	case VRFCP_2_7V:
+			mV = 2700;
+			break;
+	case VRFCP_2_775V:
+			mV = 2775;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vrfcp_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFCP_EN, VRFCP_EN_ENABLE);
+	register_mask = BITFMASK(VRFCP_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrfcp_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VRFCP_EN, VRFCP_EN_DISABLE);
+	register_mask = BITFMASK(VRFCP_EN);
+	register1 = REG_REGULATOR_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vsim_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2900))
+		voltage = VSIM_1_8V;
+	else
+		voltage = VSIM_2_9V;
+
+	register_val = BITFVAL(VSIM, voltage);
+	register_mask = BITFMASK(VSIM);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vsim_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VSIM);
+
+	switch (voltage) {
+	case VSIM_1_8V:
+			mV = 1800;
+			break;
+	case VSIM_2_9V:
+			mV = 1900;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vsim_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSIM_EN, VSIM_EN_ENABLE);
+	register_mask = BITFMASK(VSIM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vsim_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSIM_EN, VSIM_EN_DISABLE);
+	register_mask = BITFMASK(VSIM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vesim_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2900))
+		voltage = VESIM_1_8V;
+	else
+		voltage = VESIM_2_9V;
+
+	register_val = BITFVAL(VESIM, voltage);
+	register_mask = BITFMASK(VESIM);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vesim_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VESIM);
+
+	switch (voltage) {
+	case VESIM_1_8V:
+			mV = 1800;
+			break;
+	case VESIM_2_9V:
+			mV = 1900;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vesim_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VESIM_EN, VESIM_EN_ENABLE);
+	register_mask = BITFMASK(VESIM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vesim_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VESIM_EN, VESIM_EN_DISABLE);
+	register_mask = BITFMASK(VESIM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vcam_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1500) && (mV < 1800))
+		voltage = VCAM_1_5V;
+	else if ((mV >= 1800) && (mV < 2500))
+		voltage = VCAM_1_8V;
+	else if ((mV >= 2500) && (mV < 2550))
+		voltage = VCAM_2_5V;
+	else if ((mV >= 2550) && (mV < 2600))
+		voltage = VCAM_2_55V;
+	if ((mV >= 2600) && (mV < 2750))
+		voltage = VCAM_2_6V;
+	else if ((mV >= 2750) && (mV < 2800))
+		voltage = VCAM_2_75V;
+	else if ((mV >= 2800) && (mV < 3000))
+		voltage = VCAM_2_8V;
+	else
+		voltage = VCAM_3V;
+
+	register_val = BITFVAL(VCAM, voltage);
+	register_mask = BITFMASK(VCAM);
+	register1 = REG_REGULATOR_SETTING_0;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vcam_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_0,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VCAM);
+
+	switch (voltage) {
+	case VCAM_1_5V:
+			mV = 1500;
+			break;
+	case VCAM_1_8V:
+			mV = 1800;
+			break;
+	case VCAM_2_5V:
+			mV = 2500;
+			break;
+	case VCAM_2_55V:
+			mV = 2550;
+			break;
+	case VCAM_2_6V:
+			mV = 2600;
+			break;
+	case VCAM_2_75V:
+			mV = 2750;
+			break;
+	case VCAM_2_8V:
+			mV = 2800;
+			break;
+	case VCAM_3V:
+			mV = 3000;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vcam_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_ENABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vcam_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_DISABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vvib_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1300) && (mV < 1800))
+		voltage = VVIB_1_3V;
+	else if ((mV >= 1800) && (mV < 2000))
+		voltage = VVIB_1_8V;
+	else if ((mV >= 2000) && (mV < 3000))
+		voltage = VVIB_2V;
+	else
+		voltage = VVIB_3V;
+
+	register_val = BITFVAL(VVIB, voltage);
+	register_mask = BITFMASK(VVIB);
+	register1 = REG_REGULATOR_SETTING_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vvib_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_1,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VVIB);
+
+	switch (voltage) {
+	case VVIB_1_3V:
+			mV = 1300;
+			break;
+	case VVIB_1_8V:
+			mV = 1800;
+			break;
+	case VVIB_2V:
+			mV = 2000;
+			break;
+	case VVIB_3V:
+			mV = 3000;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vvib_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIB_EN, VVIB_EN_ENABLE);
+	register_mask = BITFMASK(VVIB_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vvib_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIB_EN, VVIB_EN_DISABLE);
+	register_mask = BITFMASK(VVIB_EN);
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrf_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, rf = reg->id, mV = uV / 1000;
+
+	if ((mV >= 1500) && (mV < 1875))
+		voltage = VRF_1_5V;
+	else if ((mV >= 1875) && (mV < 2700))
+		voltage = VRF_1_875V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VRF_2_7V;
+	else
+		voltage = VRF_2_775V;
+
+	switch (rf) {
+	case MC13783_VRF1:
+			register_val = BITFVAL(VRF1, voltage);
+			register_mask = BITFMASK(VRF1);
+			break;
+	case MC13783_VRF2:
+			register_val = BITFVAL(VRF2, voltage);
+			register_mask = BITFMASK(VRF2);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	register1 = REG_REGULATOR_SETTING_1;
+
+	return pmic_write_reg(register1,
+				register_val, register_mask);
+}
+
+static int mc13783_vrf_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, rf = reg->id, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_1,
+				&register_val, PMIC_ALL_BITS));
+
+	switch (rf) {
+	case MC13783_VRF1:
+			voltage = BITFEXT(register_val, VRF1);
+			break;
+	case MC13783_VRF2:
+			voltage = BITFEXT(register_val, VRF2);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	switch (voltage) {
+	case VRF_1_5V:
+			mV = 1500;
+			break;
+	case VRF_1_875V:
+			mV = 1875;
+			break;
+	case VRF_2_7V:
+			mV = 2700;
+			break;
+	case VRF_2_775V:
+			mV = 2775;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vrf_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int vrf = reg->id;
+
+	switch (vrf) {
+	case MC13783_VRF1:
+			register_val = BITFVAL(VRF1_EN, VRF1_EN_ENABLE);
+			register_mask = BITFMASK(VRF1_EN);
+			break;
+	case MC13783_VRF2:
+			register_val = BITFVAL(VRF2_EN, VRF2_EN_ENABLE);
+			register_mask = BITFMASK(VRF2_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vrf_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int vrf = reg->id;
+
+	switch (vrf) {
+	case MC13783_VRF1:
+			register_val = BITFVAL(VRF1_EN, VRF1_EN_DISABLE);
+			register_mask = BITFMASK(VRF1_EN);
+			break;
+	case MC13783_VRF2:
+			register_val = BITFVAL(VRF2_EN, VRF2_EN_DISABLE);
+			register_mask = BITFMASK(VRF2_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vmmc_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mmc = reg->id, mV = uV / 1000;
+
+	printk(KERN_INFO "VMMC ID is %d\n", mmc);
+
+	if ((mV >= 1600) && (mV < 1800))
+		voltage = VMMC_1_6V;
+	else if ((mV >= 1800) && (mV < 2000))
+		voltage = VMMC_1_8V;
+	else if ((mV >= 2000) && (mV < 2600))
+		voltage = VMMC_2V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VMMC_2_6V;
+	else if ((mV >= 2700) && (mV < 2800))
+		voltage = VMMC_2_7V;
+	else if ((mV >= 2800) && (mV < 2900))
+		voltage = VMMC_2_8V;
+	else if ((mV >= 2900) && (mV < 3000))
+		voltage = VMMC_2_9V;
+	else
+		voltage = VMMC_3V;
+
+	switch (mmc) {
+	case MC13783_VMMC1:
+			register_val = BITFVAL(VMMC1, voltage);
+			register_mask = BITFMASK(VMMC1);
+			break;
+	case MC13783_VMMC2:
+			register_val = BITFVAL(VMMC2, voltage);
+			register_mask = BITFMASK(VMMC2);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	register1 = REG_REGULATOR_SETTING_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vmmc_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mmc = reg->id, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_REGULATOR_SETTING_1,
+				&register_val, PMIC_ALL_BITS));
+
+	switch (mmc) {
+	case MC13783_VMMC1:
+			voltage = BITFEXT(register_val, VMMC1);
+			break;
+	case MC13783_VMMC2:
+			voltage = BITFEXT(register_val, VMMC2);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (voltage) {
+	case VMMC_1_6V:
+			mV = 1600;
+			break;
+	case VMMC_1_8V:
+			mV = 1800;
+			break;
+	case VMMC_2V:
+			mV = 2000;
+			break;
+	case VMMC_2_6V:
+			mV = 2600;
+			break;
+	case VMMC_2_7V:
+			mV = 2700;
+			break;
+	case VMMC_2_8V:
+			mV = 2800;
+			break;
+	case VMMC_2_9V:
+			mV = 2900;
+			break;
+	case VMMC_3V:
+			mV = 3000;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_vmmc_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int vmmc = reg->id;
+
+	switch (vmmc) {
+	case MC13783_VMMC1:
+			register_val = BITFVAL(VMMC1_EN, VMMC1_EN_ENABLE);
+			register_mask = BITFMASK(VMMC1_EN);
+			break;
+	case MC13783_VMMC2:
+			register_val = BITFVAL(VMMC2_EN, VMMC2_EN_ENABLE);
+			register_mask = BITFMASK(VMMC2_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_vmmc_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int vmmc = reg->id;
+
+	switch (vmmc) {
+	case MC13783_VMMC1:
+			register_val = BITFVAL(VMMC1_EN, VMMC1_EN_DISABLE);
+			register_mask = BITFMASK(VMMC1_EN);
+			break;
+	case MC13783_VMMC2:
+			register_val = BITFVAL(VMMC2_EN, VMMC2_EN_DISABLE);
+			register_mask = BITFMASK(VMMC2_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_REGULATOR_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_gpo_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = reg->id;
+
+	switch (gpo) {
+	case MC13783_GPO1:
+			register_val = BITFVAL(GPO1_EN, GPO1_EN_ENABLE);
+			register_mask = BITFMASK(GPO1_EN);
+			break;
+	case MC13783_GPO2:
+			register_val = BITFVAL(GPO2_EN, GPO2_EN_ENABLE);
+			register_mask = BITFMASK(GPO2_EN);
+			break;
+	case MC13783_GPO3:
+			register_val = BITFVAL(GPO3_EN, GPO3_EN_ENABLE);
+			register_mask = BITFMASK(GPO3_EN);
+			break;
+	case MC13783_GPO4:
+			register_val = BITFVAL(GPO4_EN, GPO4_EN_ENABLE);
+			register_mask = BITFMASK(GPO4_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISCELLANEOUS;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_gpo_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = reg->id;
+
+	switch (gpo) {
+	case MC13783_GPO1:
+			register_val = BITFVAL(GPO1_EN, GPO1_EN_DISABLE);
+			register_mask = BITFMASK(GPO1_EN);
+			break;
+	case MC13783_GPO2:
+			register_val = BITFVAL(GPO2_EN, GPO2_EN_DISABLE);
+			register_mask = BITFMASK(GPO2_EN);
+			break;
+	case MC13783_GPO3:
+			register_val = BITFVAL(GPO3_EN, GPO3_EN_DISABLE);
+			register_mask = BITFMASK(GPO3_EN);
+			break;
+	case MC13783_GPO4:
+			register_val = BITFVAL(GPO4_EN, GPO4_EN_DISABLE);
+			register_mask = BITFMASK(GPO4_EN);
+			break;
+	default:
+			return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISCELLANEOUS;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_sw3_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0, register1 = 0;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 5000) && (mV < 5500))
+		voltage = SW3_5V;
+	else
+		voltage = SW3_5_5V;
+
+	register_val = BITFVAL(SW3, voltage);
+	register_mask = BITFMASK(SW3);
+	register1 = REG_SWITCHERS_5;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_sw3_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_5,
+				&register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, SW3);
+
+	if (voltage == SW3_5_5V)
+		mV = 5500;
+	else
+		mV = 5000;
+
+	return mV * 1000;
+}
+
+static int mc13783_sw3_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SW3_EN, SW3_EN_ENABLE);
+	register_mask = BITFMASK(SW3_EN);
+	register1 = REG_SWITCHERS_5;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_sw3_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SW3_EN, SW3_EN_DISABLE);
+	register_mask = BITFMASK(SW3_EN);
+	register1 = REG_SWITCHERS_5;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int
+	mc13783_sw_set_normal_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000;
+
+	if ((mV >= 900) && (mV < 925))
+		voltage = SW_0_9V;
+	else if ((mV >= 925) && (mV < 950))
+		voltage = SW_0_925V;
+	else if ((mV >= 950) && (mV < 975))
+		voltage = SW_0_95V;
+	else if ((mV >= 975) && (mV < 1000))
+		voltage = SW_0_975V;
+	else if ((mV >= 1000) && (mV < 1025))
+		voltage = SW_1V;
+	else if ((mV >= 1025) && (mV < 1050))
+		voltage = SW_1_025V;
+	else if ((mV >= 1050) && (mV < 1075))
+		voltage = SW_1_05V;
+	else if ((mV >= 1075) && (mV < 1100))
+		voltage = SW_1_075V;
+	else if ((mV >= 1100) && (mV < 1125))
+		voltage = SW_1_1V;
+	else if ((mV >= 1125) && (mV < 1150))
+		voltage = SW_1_125V;
+	else if ((mV >= 1150) && (mV < 1175))
+		voltage = SW_1_15V;
+	else if ((mV >= 1175) && (mV < 1200))
+		voltage = SW_1_175V;
+	else if ((mV >= 1200) && (mV < 1225))
+		voltage = SW_1_2V;
+	else if ((mV >= 1225) && (mV < 1250))
+		voltage = SW_1_225V;
+	else if ((mV >= 1250) && (mV < 1275))
+		voltage = SW_1_25V;
+	else if ((mV >= 1275) && (mV < 1300))
+		voltage = SW_1_275V;
+	else if ((mV >= 1300) && (mV < 1325))
+		voltage = SW_1_3V;
+	else if ((mV >= 1325) && (mV < 1350))
+		voltage = SW_1_325V;
+	else if ((mV >= 1350) && (mV < 1375))
+		voltage = SW_1_35V;
+	else if ((mV >= 1375) && (mV < 1400))
+		voltage = SW_1_375V;
+	else if ((mV >= 1400) && (mV < 1425))
+		voltage = SW_1_4V;
+	else if ((mV >= 1425) && (mV < 1450))
+		voltage = SW_1_425V;
+	else if ((mV >= 1450) && (mV < 1475))
+		voltage = SW_1_45V;
+	else if ((mV >= 1475) && (mV < 1500))
+		voltage = SW_1_475V;
+	else if ((mV >= 1500) && (mV < 1525))
+		voltage = SW_1_5V;
+	else if ((mV >= 1525) && (mV < 1550))
+		voltage = SW_1_525V;
+	else if ((mV >= 1550) && (mV < 1575))
+		voltage = SW_1_55V;
+	else if ((mV >= 1575) && (mV < 1600))
+		voltage = SW_1_575V;
+	else if ((mV >= 1600) && (mV < 1625))
+		voltage = SW_1_6V;
+	else if ((mV >= 1625) && (mV < 1650))
+		voltage = SW_1_625V;
+	else if ((mV >= 1650) && (mV < 1675))
+		voltage = SW_1_65V;
+	else if ((mV >= 1675) && (mV < 1700))
+		voltage = SW_1_675V;
+	else if ((mV >= 1700) && (mV < 1800))
+		voltage = SW_1_7V;
+	else if ((mV >= 1800) && (mV < 1850))
+		voltage = SW_1_8V;
+	else if ((mV >= 1850) && (mV < 2000))
+		voltage = SW_1_85V;
+	else if ((mV >= 2000) && (mV < 2100))
+		voltage = SW_2V;
+	else if ((mV >= 2100) && (mV < 2200))
+		voltage = SW_2_1V;
+	else
+		voltage = SW_2_2V;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			register1 = REG_SWITCHERS_0;
+			register_val = BITFVAL(SW1A, voltage);
+			register_mask = BITFMASK(SW1A);
+			break;
+	case MC13783_SW1B:
+			register1 = REG_SWITCHERS_1;
+			register_val = BITFVAL(SW1B, voltage);
+			register_mask = BITFMASK(SW1B);
+			break;
+	case MC13783_SW2A:
+			register1 = REG_SWITCHERS_2;
+			register_val = BITFVAL(SW2A, voltage);
+			register_mask = BITFMASK(SW2A);
+			break;
+	case MC13783_SW2B:
+			register1 = REG_SWITCHERS_3;
+			register_val = BITFVAL(SW2B, voltage);
+			register_mask = BITFMASK(SW2B);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_sw_get_normal_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_0,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1A);
+			break;
+	case MC13783_SW1B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_1,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1B);
+			break;
+	case MC13783_SW2A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_2,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2A);
+			break;
+	case MC13783_SW2B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_3,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2B);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (voltage) {
+	case SW_0_9V:
+			mV = 900;
+			break;
+	case SW_0_925V:
+			mV = 925;
+			break;
+	case SW_0_95V:
+			mV = 950;
+			break;
+	case SW_0_975V:
+			mV = 975;
+			break;
+	case SW_1V:
+			mV = 1000;
+			break;
+	case SW_1_025V:
+			mV = 1025;
+			break;
+	case SW_1_05V:
+			mV = 1050;
+			break;
+	case SW_1_075V:
+			mV = 1075;
+			break;
+	case SW_1_1V:
+			mV = 1100;
+			break;
+	case SW_1_125V:
+			mV = 1125;
+			break;
+	case SW_1_15V:
+			mV = 1150;
+			break;
+	case SW_1_175V:
+			mV = 1175;
+			break;
+	case SW_1_2V:
+			mV = 1200;
+			break;
+	case SW_1_225V:
+			mV = 1225;
+			break;
+	case SW_1_25V:
+			mV = 1250;
+			break;
+	case SW_1_275V:
+			mV = 1275;
+			break;
+	case SW_1_3V:
+			mV = 1300;
+			break;
+	case SW_1_325V:
+			mV = 1325;
+			break;
+	case SW_1_35V:
+			mV = 1350;
+			break;
+	case SW_1_375V:
+			mV = 1375;
+			break;
+	case SW_1_4V:
+			mV = 1400;
+			break;
+	case SW_1_425V:
+			mV = 1425;
+			break;
+	case SW_1_45V:
+			mV = 1450;
+			break;
+	case SW_1_475V:
+			mV = 1475;
+			break;
+	case SW_1_5V:
+			mV = 1500;
+			break;
+	case SW_1_525V:
+			mV = 1525;
+			break;
+	case SW_1_55V:
+			mV = 1550;
+			break;
+	case SW_1_575V:
+			mV = 1575;
+			break;
+	case SW_1_6V:
+			mV = 1600;
+			break;
+	case SW_1_625V:
+			mV = 1625;
+			break;
+	case SW_1_65V:
+			mV = 1650;
+			break;
+	case SW_1_675V:
+			mV = 1675;
+			break;
+	case SW_1_7V:
+			mV = 1700;
+			break;
+	case SW_1_8V:
+			mV = 1800;
+			break;
+	case SW_1_85V:
+			mV = 1850;
+			break;
+	case SW_2V:
+			mV = 2000;
+			break;
+	case SW_2_1V:
+			mV = 2100;
+			break;
+	case SW_2_2V:
+			mV = 2200;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_sw_set_dvs_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0, register2_val =
+		0, register2_mask = 0;
+	unsigned int register1 = 0, register2 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000;
+
+	if ((mV >= 900) && (mV < 925))
+		voltage = SW_0_9V;
+	else if ((mV >= 925) && (mV < 950))
+		voltage = SW_0_925V;
+	else if ((mV >= 950) && (mV < 975))
+		voltage = SW_0_95V;
+	else if ((mV >= 975) && (mV < 1000))
+		voltage = SW_0_975V;
+	else if ((mV >= 1000) && (mV < 1025))
+		voltage = SW_1V;
+	else if ((mV >= 1025) && (mV < 1050))
+		voltage = SW_1_025V;
+	else if ((mV >= 1050) && (mV < 1075))
+		voltage = SW_1_05V;
+	else if ((mV >= 1075) && (mV < 1100))
+		voltage = SW_1_075V;
+	else if ((mV >= 1100) && (mV < 1125))
+		voltage = SW_1_1V;
+	else if ((mV >= 1125) && (mV < 1150))
+		voltage = SW_1_125V;
+	else if ((mV >= 1150) && (mV < 1175))
+		voltage = SW_1_15V;
+	else if ((mV >= 1175) && (mV < 1200))
+		voltage = SW_1_175V;
+	else if ((mV >= 1200) && (mV < 1225))
+		voltage = SW_1_2V;
+	else if ((mV >= 1225) && (mV < 1250))
+		voltage = SW_1_225V;
+	else if ((mV >= 1250) && (mV < 1275))
+		voltage = SW_1_25V;
+	else if ((mV >= 1275) && (mV < 1300))
+		voltage = SW_1_275V;
+	else if ((mV >= 1300) && (mV < 1325))
+		voltage = SW_1_3V;
+	else if ((mV >= 1325) && (mV < 1350))
+		voltage = SW_1_325V;
+	else if ((mV >= 1350) && (mV < 1375))
+		voltage = SW_1_35V;
+	else if ((mV >= 1375) && (mV < 1400))
+		voltage = SW_1_375V;
+	else if ((mV >= 1400) && (mV < 1425))
+		voltage = SW_1_4V;
+	else if ((mV >= 1425) && (mV < 1450))
+		voltage = SW_1_425V;
+	else if ((mV >= 1450) && (mV < 1475))
+		voltage = SW_1_45V;
+	else if ((mV >= 1475) && (mV < 1500))
+		voltage = SW_1_475V;
+	else if ((mV >= 1500) && (mV < 1525))
+		voltage = SW_1_5V;
+	else if ((mV >= 1525) && (mV < 1550))
+		voltage = SW_1_525V;
+	else if ((mV >= 1550) && (mV < 1575))
+		voltage = SW_1_55V;
+	else if ((mV >= 1575) && (mV < 1600))
+		voltage = SW_1_575V;
+	else if ((mV >= 1600) && (mV < 1625))
+		voltage = SW_1_6V;
+	else if ((mV >= 1625) && (mV < 1650))
+		voltage = SW_1_625V;
+	else if ((mV >= 1650) && (mV < 1675))
+		voltage = SW_1_65V;
+	else if ((mV >= 1675) && (mV < 1700))
+		voltage = SW_1_675V;
+	else if ((mV >= 1700) && (mV < 1800))
+		voltage = SW_1_7V;
+	else if ((mV >= 1800) && (mV < 1850))
+		voltage = SW_1_8V;
+	else if ((mV >= 1850) && (mV < 2000))
+		voltage = SW_1_85V;
+	else if ((mV >= 2000) && (mV < 2100))
+		voltage = SW_2V;
+	else if ((mV >= 2100) && (mV < 2200))
+		voltage = SW_2_1V;
+	else
+		voltage = SW_2_2V;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			register1 = REG_SWITCHERS_0;
+			register_val = BITFVAL(SW1A_DVS, voltage);
+			register_mask = BITFMASK(SW1A_DVS);
+			register2 = REG_SWITCHERS_4;
+			register2_val = BITFVAL(SW1A_DVS_SPEED, dvs_speed);
+			register2_mask = BITFMASK(SW1A_DVS_SPEED);
+			break;
+	case MC13783_SW1B:
+			register1 = REG_SWITCHERS_1;
+			register_val = BITFVAL(SW1B_DVS, voltage);
+			register_mask = BITFMASK(SW1B_DVS);
+			register2 = REG_SWITCHERS_4;
+			register2_val = BITFVAL(SW1B_DVS_SPEED, dvs_speed);
+			register2_mask = BITFMASK(SW1B_DVS_SPEED);
+			break;
+	case MC13783_SW2A:
+			register1 = REG_SWITCHERS_2;
+			register_val = BITFVAL(SW2A_DVS, voltage);
+			register_mask = BITFMASK(SW2A_DVS);
+			register2 = REG_SWITCHERS_5;
+			register2_val = BITFVAL(SW2A_DVS_SPEED, dvs_speed);
+			register2_mask = BITFMASK(SW2A_DVS_SPEED);
+			break;
+	case MC13783_SW2B:
+			register1 = REG_SWITCHERS_3;
+			register_val = BITFVAL(SW2B_DVS, voltage);
+			register_mask = BITFMASK(SW2B_DVS);
+			register2 = REG_SWITCHERS_5;
+			register2_val = BITFVAL(SW2B_DVS_SPEED, dvs_speed);
+			register2_mask = BITFMASK(SW2B_DVS_SPEED);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	CHECK_ERROR(pmic_write_reg(register1, register_val, register_mask));
+	CHECK_ERROR(pmic_write_reg(register2, register2_val, register2_mask));
+
+	return 0;
+}
+
+static int mc13783_sw_get_dvs_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_0,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1A_DVS);
+			break;
+	case MC13783_SW1B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_1,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1B_DVS);
+			break;
+	case MC13783_SW2A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_2,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2A_DVS);
+			break;
+	case MC13783_SW2B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_3,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2B_DVS);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (voltage) {
+	case SW_0_9V:
+			mV = 900;
+			break;
+	case SW_0_925V:
+			mV = 925;
+			break;
+	case SW_0_95V:
+			mV = 950;
+			break;
+	case SW_0_975V:
+			mV = 975;
+			break;
+	case SW_1V:
+			mV = 1000;
+			break;
+	case SW_1_025V:
+			mV = 1025;
+			break;
+	case SW_1_05V:
+			mV = 1050;
+			break;
+	case SW_1_075V:
+			mV = 1075;
+			break;
+	case SW_1_1V:
+			mV = 1100;
+			break;
+	case SW_1_125V:
+			mV = 1125;
+			break;
+	case SW_1_15V:
+			mV = 1150;
+			break;
+	case SW_1_175V:
+			mV = 1175;
+			break;
+	case SW_1_2V:
+			mV = 1200;
+			break;
+	case SW_1_225V:
+			mV = 1225;
+			break;
+	case SW_1_25V:
+			mV = 1250;
+			break;
+	case SW_1_275V:
+			mV = 1275;
+			break;
+	case SW_1_3V:
+			mV = 1300;
+			break;
+	case SW_1_325V:
+			mV = 1325;
+			break;
+	case SW_1_35V:
+			mV = 1350;
+			break;
+	case SW_1_375V:
+			mV = 1375;
+			break;
+	case SW_1_4V:
+			mV = 1400;
+			break;
+	case SW_1_425V:
+			mV = 1425;
+			break;
+	case SW_1_45V:
+			mV = 1450;
+			break;
+	case SW_1_475V:
+			mV = 1475;
+			break;
+	case SW_1_5V:
+			mV = 1500;
+			break;
+	case SW_1_525V:
+			mV = 1525;
+			break;
+	case SW_1_55V:
+			mV = 1550;
+			break;
+	case SW_1_575V:
+			mV = 1575;
+			break;
+	case SW_1_6V:
+			mV = 1600;
+			break;
+	case SW_1_625V:
+			mV = 1625;
+			break;
+	case SW_1_65V:
+			mV = 1650;
+			break;
+	case SW_1_675V:
+			mV = 1675;
+			break;
+	case SW_1_7V:
+			mV = 1700;
+			break;
+	case SW_1_8V:
+			mV = 1800;
+			break;
+	case SW_1_85V:
+			mV = 1850;
+			break;
+	case SW_2V:
+			mV = 2000;
+			break;
+	case SW_2_1V:
+			mV = 2100;
+			break;
+	case SW_2_2V:
+			mV = 2200;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_sw_set_stby_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000;
+
+	if ((mV >= 900) && (mV < 925))
+		voltage = SW_0_9V;
+	else if ((mV >= 925) && (mV < 950))
+		voltage = SW_0_925V;
+	else if ((mV >= 950) && (mV < 975))
+		voltage = SW_0_95V;
+	else if ((mV >= 975) && (mV < 1000))
+		voltage = SW_0_975V;
+	else if ((mV >= 1000) && (mV < 1025))
+		voltage = SW_1V;
+	else if ((mV >= 1025) && (mV < 1050))
+		voltage = SW_1_025V;
+	else if ((mV >= 1050) && (mV < 1075))
+		voltage = SW_1_05V;
+	else if ((mV >= 1075) && (mV < 1100))
+		voltage = SW_1_075V;
+	else if ((mV >= 1100) && (mV < 1125))
+		voltage = SW_1_1V;
+	else if ((mV >= 1125) && (mV < 1150))
+		voltage = SW_1_125V;
+	else if ((mV >= 1150) && (mV < 1175))
+		voltage = SW_1_15V;
+	else if ((mV >= 1175) && (mV < 1200))
+		voltage = SW_1_175V;
+	else if ((mV >= 1200) && (mV < 1225))
+		voltage = SW_1_2V;
+	else if ((mV >= 1225) && (mV < 1250))
+		voltage = SW_1_225V;
+	else if ((mV >= 1250) && (mV < 1275))
+		voltage = SW_1_25V;
+	else if ((mV >= 1275) && (mV < 1300))
+		voltage = SW_1_275V;
+	else if ((mV >= 1300) && (mV < 1325))
+		voltage = SW_1_3V;
+	else if ((mV >= 1325) && (mV < 1350))
+		voltage = SW_1_325V;
+	else if ((mV >= 1350) && (mV < 1375))
+		voltage = SW_1_35V;
+	else if ((mV >= 1375) && (mV < 1400))
+		voltage = SW_1_375V;
+	else if ((mV >= 1400) && (mV < 1425))
+		voltage = SW_1_4V;
+	else if ((mV >= 1425) && (mV < 1450))
+		voltage = SW_1_425V;
+	else if ((mV >= 1450) && (mV < 1475))
+		voltage = SW_1_45V;
+	else if ((mV >= 1475) && (mV < 1500))
+		voltage = SW_1_475V;
+	else if ((mV >= 1500) && (mV < 1525))
+		voltage = SW_1_5V;
+	else if ((mV >= 1525) && (mV < 1550))
+		voltage = SW_1_525V;
+	else if ((mV >= 1550) && (mV < 1575))
+		voltage = SW_1_55V;
+	else if ((mV >= 1575) && (mV < 1600))
+		voltage = SW_1_575V;
+	else if ((mV >= 1600) && (mV < 1625))
+		voltage = SW_1_6V;
+	else if ((mV >= 1625) && (mV < 1650))
+		voltage = SW_1_625V;
+	else if ((mV >= 1650) && (mV < 1675))
+		voltage = SW_1_65V;
+	else if ((mV >= 1675) && (mV < 1700))
+		voltage = SW_1_675V;
+	else if ((mV >= 1700) && (mV < 1800))
+		voltage = SW_1_7V;
+	else if ((mV >= 1800) && (mV < 1850))
+		voltage = SW_1_8V;
+	else if ((mV >= 1850) && (mV < 2000))
+		voltage = SW_1_85V;
+	else if ((mV >= 2000) && (mV < 2100))
+		voltage = SW_2V;
+	else if ((mV >= 2100) && (mV < 2200))
+		voltage = SW_2_1V;
+	else
+		voltage = SW_2_2V;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			register1 = REG_SWITCHERS_0;
+			register_val = BITFVAL(SW1A_STDBY, voltage);
+			register_mask = BITFMASK(SW1A_STDBY);
+			break;
+	case MC13783_SW1B:
+			register1 = REG_SWITCHERS_1;
+			register_val = BITFVAL(SW1B_STDBY, voltage);
+			register_mask = BITFMASK(SW1B_STDBY);
+			break;
+	case MC13783_SW2A:
+			register1 = REG_SWITCHERS_2;
+			register_val = BITFVAL(SW2A_STDBY, voltage);
+			register_mask = BITFMASK(SW2A_STDBY);
+			break;
+	case MC13783_SW2B:
+			register1 = REG_SWITCHERS_3;
+			register_val = BITFVAL(SW2B_STDBY, voltage);
+			register_mask = BITFMASK(SW2B_STDBY);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13783_sw_get_stby_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_0,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1A_STDBY);
+			break;
+	case MC13783_SW1B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_1,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW1B_STDBY);
+			break;
+	case MC13783_SW2A:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_2,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2A_STDBY);
+			break;
+	case MC13783_SW2B:
+			CHECK_ERROR(pmic_read_reg(REG_SWITCHERS_3,
+						&register_val, PMIC_ALL_BITS));
+			voltage = BITFEXT(register_val, SW2B_STDBY);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (voltage) {
+	case SW_0_9V:
+			mV = 900;
+			break;
+	case SW_0_925V:
+			mV = 925;
+			break;
+	case SW_0_95V:
+			mV = 950;
+			break;
+	case SW_0_975V:
+			mV = 975;
+			break;
+	case SW_1V:
+			mV = 1000;
+			break;
+	case SW_1_025V:
+			mV = 1025;
+			break;
+	case SW_1_05V:
+			mV = 1050;
+			break;
+	case SW_1_075V:
+			mV = 1075;
+			break;
+	case SW_1_1V:
+			mV = 1100;
+			break;
+	case SW_1_125V:
+			mV = 1125;
+			break;
+	case SW_1_15V:
+			mV = 1150;
+			break;
+	case SW_1_175V:
+			mV = 1175;
+			break;
+	case SW_1_2V:
+			mV = 1200;
+			break;
+	case SW_1_225V:
+			mV = 1225;
+			break;
+	case SW_1_25V:
+			mV = 1250;
+			break;
+	case SW_1_275V:
+			mV = 1275;
+			break;
+	case SW_1_3V:
+			mV = 1300;
+			break;
+	case SW_1_325V:
+			mV = 1325;
+			break;
+	case SW_1_35V:
+			mV = 1350;
+			break;
+	case SW_1_375V:
+			mV = 1375;
+			break;
+	case SW_1_4V:
+			mV = 1400;
+			break;
+	case SW_1_425V:
+			mV = 1425;
+			break;
+	case SW_1_45V:
+			mV = 1450;
+			break;
+	case SW_1_475V:
+			mV = 1475;
+			break;
+	case SW_1_5V:
+			mV = 1500;
+			break;
+	case SW_1_525V:
+			mV = 1525;
+			break;
+	case SW_1_55V:
+			mV = 1550;
+			break;
+	case SW_1_575V:
+			mV = 1575;
+			break;
+	case SW_1_6V:
+			mV = 1600;
+			break;
+	case SW_1_625V:
+			mV = 1625;
+			break;
+	case SW_1_65V:
+			mV = 1650;
+			break;
+	case SW_1_675V:
+			mV = 1675;
+			break;
+	case SW_1_7V:
+			mV = 1700;
+			break;
+	case SW_1_8V:
+			mV = 1800;
+			break;
+	case SW_1_85V:
+			mV = 1850;
+			break;
+	case SW_2V:
+			mV = 2000;
+			break;
+	case SW_2_1V:
+			mV = 2100;
+			break;
+	case SW_2_2V:
+			mV = 2200;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13783_sw_set_normal_mode(struct regulator *reg, unsigned int mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int register1 = 0;
+	unsigned int l_mode;
+	int sw = reg->id;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+			/* SYNC RECT mode */
+			l_mode = SW_MODE_SYNC_RECT_EN;
+			break;
+	case REGULATOR_MODE_NORMAL:
+			/* PULSE SKIP mode */
+			l_mode = SW_MODE_PULSE_SKIP_EN;
+			break;
+	case REGULATOR_MODE_IDLE:
+			/* LOW POWER mode */
+			l_mode = SW_MODE_LOW_POWER_EN;
+			break;
+	case REGULATOR_MODE_STANDBY:
+			/* NO PULSE SKIP mode */
+			l_mode = SW_MODE_PULSE_NO_SKIP_EN;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (sw) {
+	case MC13783_SW1A:
+			reg_val = BITFVAL(SW1A_MODE, l_mode);
+			reg_mask = BITFMASK(SW1A_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW1B:
+			reg_val = BITFVAL(SW1B_MODE, l_mode);
+			reg_mask = BITFMASK(SW1B_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW2A:
+			reg_val = BITFVAL(SW2A_MODE, l_mode);
+			reg_mask = BITFMASK(SW2A_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	case MC13783_SW2B:
+			reg_val = BITFVAL(SW2B_MODE, l_mode);
+			reg_mask = BITFMASK(SW2B_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return pmic_write_reg(register1, reg_val, reg_mask);
+}
+
+static unsigned int mc13783_sw_get_normal_mode(struct regulator *reg)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int register1 = 0;
+	unsigned int l_mode = 0;
+	int sw = reg->id;
+	int ret = 0;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			reg_mask = BITFMASK(SW1A_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW1B:
+			reg_mask = BITFMASK(SW1B_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW2A:
+			reg_mask = BITFMASK(SW2A_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	case MC13783_SW2B:
+			reg_mask = BITFMASK(SW2B_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = (pmic_read_reg(register1, &reg_val, reg_mask));
+	if (ret != 0)
+		return ret;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			l_mode = BITFEXT(reg_val, SW1A_MODE);
+			break;
+	case MC13783_SW1B:
+			l_mode = BITFEXT(reg_val, SW1B_MODE);
+			break;
+	case MC13783_SW2A:
+			l_mode = BITFEXT(reg_val, SW2A_MODE);
+			break;
+	case MC13783_SW2B:
+			l_mode = BITFEXT(reg_val, SW2B_MODE);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	if (l_mode == SW_MODE_SYNC_RECT_EN)
+		return REGULATOR_MODE_FAST;
+	else if (l_mode == SW_MODE_PULSE_NO_SKIP_EN)
+		return REGULATOR_MODE_STANDBY;
+	else if (l_mode == SW_MODE_PULSE_SKIP_EN)
+		return REGULATOR_MODE_NORMAL;
+	else if (l_mode == SW_MODE_LOW_POWER_EN)
+		return REGULATOR_MODE_IDLE;
+	else
+		return -EINVAL;
+}
+
+static int mc13783_sw_set_stby_mode(struct regulator *reg, unsigned int mode)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int register1 = 0;
+	unsigned int l_mode;
+	int sw = reg->id;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+			/* SYNC RECT mode */
+			l_mode = SW_MODE_SYNC_RECT_EN;
+			break;
+	case REGULATOR_MODE_NORMAL:
+			/* PULSE SKIP mode */
+			l_mode = SW_MODE_PULSE_SKIP_EN;
+			break;
+	case REGULATOR_MODE_IDLE:
+			/* LOW POWER mode */
+			l_mode = SW_MODE_LOW_POWER_EN;
+			break;
+	case REGULATOR_MODE_STANDBY:
+			/* NO PULSE SKIP mode */
+			l_mode = SW_MODE_PULSE_NO_SKIP_EN;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	switch (sw) {
+	case MC13783_SW1A:
+			reg_val = BITFVAL(SW1A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(SW1A_STBY_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW1B:
+			reg_val = BITFVAL(SW1B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(SW1B_STBY_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW2A:
+			reg_val = BITFVAL(SW2A_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(SW2A_STBY_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	case MC13783_SW2B:
+			reg_val = BITFVAL(SW2B_STBY_MODE, l_mode);
+			reg_mask = BITFMASK(SW2B_STBY_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	return pmic_write_reg(register1, reg_val, reg_mask);
+}
+
+static unsigned int mc13783_sw_get_stby_mode(struct regulator *reg)
+{
+	unsigned int reg_val = 0, reg_mask = 0;
+	unsigned int register1 = 0;
+	unsigned int l_mode = 0;
+	int sw = reg->id;
+	int ret = 0;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			reg_mask = BITFMASK(SW1A_STBY_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW1B:
+			reg_mask = BITFMASK(SW1B_STBY_MODE);
+			register1 = REG_SWITCHERS_4;
+			break;
+	case MC13783_SW2A:
+			reg_mask = BITFMASK(SW2A_STBY_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	case MC13783_SW2B:
+			reg_mask = BITFMASK(SW2B_STBY_MODE);
+			register1 = REG_SWITCHERS_5;
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = (pmic_read_reg(register1, &reg_val, reg_mask));
+	if (ret != 0)
+		return ret;
+
+	switch (sw) {
+	case MC13783_SW1A:
+			l_mode = BITFEXT(reg_val, SW1A_STBY_MODE);
+			break;
+	case MC13783_SW1B:
+			l_mode = BITFEXT(reg_val, SW1B_STBY_MODE);
+			break;
+	case MC13783_SW2A:
+			l_mode = BITFEXT(reg_val, SW2A_STBY_MODE);
+			break;
+	case MC13783_SW2B:
+			l_mode = BITFEXT(reg_val, SW2B_STBY_MODE);
+			break;
+	default:
+			return -EINVAL;
+	}
+
+	if (l_mode == SW_MODE_SYNC_RECT_EN)
+		return REGULATOR_MODE_FAST;
+	else if (l_mode == SW_MODE_PULSE_NO_SKIP_EN)
+		return REGULATOR_MODE_STANDBY;
+	else if (l_mode == SW_MODE_PULSE_SKIP_EN)
+		return REGULATOR_MODE_NORMAL;
+	else if (l_mode == SW_MODE_LOW_POWER_EN)
+		return REGULATOR_MODE_IDLE;
+	else
+		return -EINVAL;
+
+}
+
+static struct regulator_ops mc13783_vaudio_ops = {
+	.enable = mc13783_vaudio_enable,
+	.disable = mc13783_vaudio_disable,
+};
+
+static struct regulator_ops mc13783_viohi_ops = {
+	.enable = mc13783_viohi_enable,
+	.disable = mc13783_viohi_disable,
+};
+
+static struct regulator_ops mc13783_violo_ops = {
+	.set_voltage = mc13783_violo_set_voltage,
+	.get_voltage = mc13783_violo_get_voltage,
+	.enable = mc13783_violo_enable,
+	.disable = mc13783_violo_disable,
+};
+
+static struct regulator_ops mc13783_vdig_ops = {
+	.set_voltage = mc13783_vdig_set_voltage,
+	.get_voltage = mc13783_vdig_get_voltage,
+	.enable = mc13783_vdig_enable,
+	.disable = mc13783_vdig_disable,
+};
+
+static struct regulator_ops mc13783_vgen_ops = {
+	.set_voltage = mc13783_vgen_set_voltage,
+	.get_voltage = mc13783_vgen_get_voltage,
+	.enable = mc13783_vgen_enable,
+	.disable = mc13783_vgen_disable,
+};
+
+static struct regulator_ops mc13783_vrfdig_ops = {
+	.set_voltage = mc13783_vrfdig_set_voltage,
+	.get_voltage = mc13783_vrfdig_get_voltage,
+	.enable = mc13783_vrfdig_enable,
+	.disable = mc13783_vrfdig_disable,
+};
+
+static struct regulator_ops mc13783_vrfref_ops = {
+	.set_voltage = mc13783_vrfref_set_voltage,
+	.get_voltage = mc13783_vrfref_get_voltage,
+	.enable = mc13783_vrfref_enable,
+	.disable = mc13783_vrfref_disable,
+};
+
+static struct regulator_ops mc13783_vrfcp_ops = {
+	.set_voltage = mc13783_vrfcp_set_voltage,
+	.get_voltage = mc13783_vrfcp_get_voltage,
+	.enable = mc13783_vrfcp_enable,
+	.disable = mc13783_vrfcp_disable,
+};
+
+static struct regulator_ops mc13783_vsim_ops = {
+	.set_voltage = mc13783_vsim_set_voltage,
+	.get_voltage = mc13783_vsim_get_voltage,
+	.enable = mc13783_vsim_enable,
+	.disable = mc13783_vsim_disable,
+};
+
+static struct regulator_ops mc13783_vesim_ops = {
+	.set_voltage = mc13783_vesim_set_voltage,
+	.get_voltage = mc13783_vesim_get_voltage,
+	.enable = mc13783_vesim_enable,
+	.disable = mc13783_vesim_disable,
+};
+
+static struct regulator_ops mc13783_vcam_ops = {
+	.set_voltage = mc13783_vcam_set_voltage,
+	.get_voltage = mc13783_vcam_get_voltage,
+	.enable = mc13783_vcam_enable,
+	.disable = mc13783_vcam_disable,
+};
+
+static struct regulator_ops mc13783_vvib_ops = {
+	.set_voltage = mc13783_vvib_set_voltage,
+	.get_voltage = mc13783_vvib_get_voltage,
+	.enable = mc13783_vvib_enable,
+	.disable = mc13783_vvib_disable,
+};
+
+static struct regulator_ops mc13783_vrf_ops = {
+	.set_voltage = mc13783_vrf_set_voltage,
+	.get_voltage = mc13783_vrf_get_voltage,
+	.enable = mc13783_vrf_enable,
+	.disable = mc13783_vrf_disable,
+};
+
+static struct regulator_ops mc13783_vmmc_ops = {
+	.set_voltage = mc13783_vmmc_set_voltage,
+	.get_voltage = mc13783_vmmc_get_voltage,
+	.enable = mc13783_vmmc_enable,
+	.disable = mc13783_vmmc_disable,
+};
+
+static struct regulator_ops mc13783_gpo_ops = {
+	.enable = mc13783_gpo_enable,
+	.disable = mc13783_gpo_disable,
+};
+
+static struct regulator_ops mc13783_sw3_ops = {
+	.set_voltage = mc13783_sw3_set_voltage,
+	.get_voltage = mc13783_sw3_get_voltage,
+	.enable = mc13783_sw3_enable,
+	.disable = mc13783_sw3_disable,
+};
+
+static struct regulator_ops mc13783_sw_normal_ops = {
+	.set_voltage = mc13783_sw_set_normal_voltage,
+	.get_voltage = mc13783_sw_get_normal_voltage,
+	.get_mode = mc13783_sw_get_normal_mode,
+	.set_mode = mc13783_sw_set_normal_mode,
+};
+
+static struct regulator_ops mc13783_sw_dvs_ops = {
+	.set_voltage = mc13783_sw_set_dvs_voltage,
+	.get_voltage = mc13783_sw_get_dvs_voltage,
+};
+
+static struct regulator_ops mc13783_sw_stby_ops = {
+	.set_voltage = mc13783_sw_set_stby_voltage,
+	.get_voltage = mc13783_sw_get_stby_voltage,
+	.get_mode = mc13783_sw_get_stby_mode,
+	.set_mode = mc13783_sw_set_stby_mode,
+};
+
+struct regulation_constraints violo_regulation_constraints = {
+	.min_uV = mV_to_uV(1200),
+	.max_uV = mV_to_uV(1800),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vdig_regulation_constraints = {
+	.min_uV = mV_to_uV(1200),
+	.max_uV = mV_to_uV(1800),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vgen_regulation_constraints = {
+	.min_uV = mV_to_uV(1100),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vrfdig_regulation_constraints = {
+	.min_uV = mV_to_uV(1200),
+	.max_uV = mV_to_uV(1875),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vrfref_regulation_constraints = {
+	.min_uV = mV_to_uV(2475),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vrfcp_regulation_constraints = {
+	.min_uV = mV_to_uV(2700),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vsim_regulation_constraints = {
+	.min_uV = mV_to_uV(1800),
+	.max_uV = mV_to_uV(2900),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vesim_regulation_constraints = {
+	.min_uV = mV_to_uV(1800),
+	.max_uV = mV_to_uV(2900),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vcam_regulation_constraints = {
+	.min_uV = mV_to_uV(1500),
+	.max_uV = mV_to_uV(3000),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vvib_regulation_constraints = {
+	.min_uV = mV_to_uV(1300),
+	.max_uV = mV_to_uV(3000),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vrf_regulation_constraints = {
+	.min_uV = mV_to_uV(1500),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints vmmc_regulation_constraints = {
+	.min_uV = mV_to_uV(1600),
+	.max_uV = mV_to_uV(3000),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints sw3_regulation_constraints = {
+	.min_uV = mV_to_uV(5000),
+	.max_uV = mV_to_uV(5500),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+struct regulation_constraints sw_regulation_constraints = {
+	.min_uV = mV_to_uV(900),
+	.max_uV = mV_to_uV(2200),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_MODE,
+	.valid_modes_mask = REGULATOR_MODE_FAST |
+		REGULATOR_MODE_NORMAL | REGULATOR_MODE_IDLE |
+		REGULATOR_MODE_STANDBY,
+};
+
+struct mc13783_regulator {
+	struct regulator regulator;
+};
+
+static struct
+mc13783_regulator reg_mc13783[NUM_MC13783_REGULATORS] = {
+	{
+		.regulator = {
+			.name = "VAUDIO",
+			.id = MC13783_VAUDIO,
+			.ops = &mc13783_vaudio_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VIOHI",
+			.id = MC13783_VIOHI,
+			.ops = &mc13783_viohi_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VIOLO",
+			.id = MC13783_VIOLO,
+			.ops = &mc13783_violo_ops,
+			.constraints =
+				&violo_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VDIG",
+			.id = MC13783_VDIG,
+			.ops = &mc13783_vdig_ops,
+			.constraints =
+				&vdig_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VGEN",
+			.id = MC13783_VGEN,
+			.ops = &mc13783_vgen_ops,
+			.constraints =
+				&vgen_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VRFDIG",
+			.id = MC13783_VRFDIG,
+			.ops = &mc13783_vrfdig_ops,
+			.constraints =
+				&vrfdig_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VRFREF",
+			.id = MC13783_VRFREF,
+			.ops = &mc13783_vrfref_ops,
+			.constraints =
+				&vrfref_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VRFCP",
+			.id = MC13783_VRFCP,
+			.ops = &mc13783_vrfcp_ops,
+			.constraints =
+				&vrfcp_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VSIM",
+			.id = MC13783_VSIM,
+			.ops = &mc13783_vsim_ops,
+			.constraints =
+				&vsim_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VESIM",
+			.id = MC13783_VESIM,
+			.ops = &mc13783_vesim_ops,
+			.constraints =
+				&vesim_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VCAM",
+			.id = MC13783_VCAM,
+			.ops = &mc13783_vcam_ops,
+			.constraints =
+				&vcam_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VVIB",
+			.id = MC13783_VVIB,
+			.ops = &mc13783_vvib_ops,
+			.constraints =
+				&vvib_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VRF1",
+			.id = MC13783_VRF1,
+			.ops = &mc13783_vrf_ops,
+			.constraints =
+				&vrf_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VRF2",
+			.id = MC13783_VRF2,
+			.ops = &mc13783_vrf_ops,
+			.constraints =
+				&vrf_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VMMC1",
+			.id = MC13783_VMMC1,
+			.ops = &mc13783_vmmc_ops,
+			.constraints =
+				&vmmc_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "VMMC2",
+			.id = MC13783_VMMC2,
+			.ops = &mc13783_vmmc_ops,
+			.constraints =
+				&vmmc_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "GPO1",
+			.id = MC13783_GPO1,
+			.ops = &mc13783_gpo_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "GPO2",
+			.id = MC13783_GPO2,
+			.ops = &mc13783_gpo_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "GPO3",
+			.id = MC13783_GPO3,
+			.ops = &mc13783_gpo_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "GPO4",
+			.id = MC13783_GPO4,
+			.ops = &mc13783_gpo_ops,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW3",
+			.id = MC13783_SW3,
+			.ops = &mc13783_sw3_ops,
+			.constraints =
+				&sw3_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1A_NORMAL",
+			.id = MC13783_SW1A,
+			.ops = &mc13783_sw_normal_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1B_NORMAL",
+			.id = MC13783_SW1B,
+			.ops = &mc13783_sw_normal_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2A_NORMAL",
+			.id = MC13783_SW2A,
+			.ops = &mc13783_sw_normal_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2B_NORMAL",
+			.id = MC13783_SW2B,
+			.ops = &mc13783_sw_normal_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1A_DVS",
+			.id = MC13783_SW1A,
+			.ops = &mc13783_sw_dvs_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1B_DVS",
+			.id = MC13783_SW1B,
+			.ops = &mc13783_sw_dvs_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2A_DVS",
+			.id = MC13783_SW2A,
+			.ops = &mc13783_sw_dvs_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2B_DVS",
+			.id = MC13783_SW2B,
+			.ops = &mc13783_sw_dvs_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1A_STBY",
+			.id = MC13783_SW1A,
+			.ops = &mc13783_sw_stby_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW1B_STBY",
+			.id = MC13783_SW1B,
+			.ops = &mc13783_sw_stby_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2A_STBY",
+			.id = MC13783_SW2A,
+			.ops = &mc13783_sw_stby_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+	{
+		.regulator = {
+			.name = "SW2B_STBY",
+			.id = MC13783_SW2B,
+			.ops = &mc13783_sw_stby_ops,
+			.constraints =
+				&sw_regulation_constraints,
+		},
+	},
+};
+
+/*
+ * Init and Exit
+ */
+
+int reg_mc13783_probe(void)
+{
+	int ret11 = 0;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(reg_mc13783); i++) {
+		ret11 = regulator_register(
+				&reg_mc13783[i].regulator);
+		regulator_set_platform_constraints(
+				reg_mc13783[i].regulator.
+				name,
+				reg_mc13783[i].regulator.
+				constraints);
+		if (ret11 < 0) {
+			printk(KERN_ERR "%s: failed to register"
+					"%s err %d\n",
+					__func__,
+					reg_mc13783[i].regulator.name, ret11);
+			i--;
+			for (; i >= 0; i--)
+				regulator_unregister(&reg_mc13783[i].regulator);
+
+			return ret11;
+		}
+	}
+
+	printk(KERN_INFO "MC13783 regulator successfully probed\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(reg_mc13783_probe);
+
+/* Module information */
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MC13783 Regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/reg-core.c b/drivers/regulator/reg-core.c
new file mode 100644
index 0000000..9fc2c6f
--- /dev/null
+++ b/drivers/regulator/reg-core.c
@@ -0,0 +1,893 @@
+/*
+ * regulator.c  --  Voltage/Current Regulator framework.
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/regulator/regulator.h>
+#include <linux/regulator/regulator-drv.h>
+#include <linux/regulator/regulator-platform.h>
+
+static DEFINE_MUTEX(list_mutex);
+static LIST_HEAD(regulators);
+
+struct regulator_load {
+	struct device *dev;
+	struct list_head list;
+	int uA_load;
+	struct device_attribute dev_attr;
+};
+
+#define to_regulator(cd) \
+	container_of(cd, struct regulator, cdev)
+
+static struct regulator_load *get_regulator_load(struct device *dev)
+{
+	struct regulator_load *load = NULL;
+	struct regulator *regulator;
+
+	list_for_each_entry(regulator, &regulators, list) {
+		list_for_each_entry(load, &regulator->user_list, list) {
+			if (load->dev == dev)
+				return load;
+		}
+	}
+	return NULL;
+}
+
+static int
+	constraint_check_voltage(struct regulator *regulator, int uV)
+{
+	if (!regulator->constraints)
+		return -ENODEV;
+	if (!regulator->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)
+		return -EPERM;
+	if (uV > regulator->constraints->max_uV ||
+			uV < regulator->constraints->min_uV)
+		return -EINVAL;
+	return 0;
+}
+
+static int
+	constraint_check_current(struct regulator *regulator, int uA)
+{
+	if (!regulator->constraints)
+		return -ENODEV;
+	if (!regulator->constraints->valid_ops_mask &
+			REGULATOR_CHANGE_CURRENT)
+		return -EPERM;
+	if (uA > regulator->constraints->max_uA ||
+			uA < regulator->constraints->min_uA)
+		return -EINVAL;
+	return 0;
+}
+
+static int
+	constraint_check_mode(struct regulator *regulator, int mode)
+{
+	if (!regulator->constraints)
+		return -ENODEV;
+	if (!regulator->constraints->valid_ops_mask &
+			REGULATOR_CHANGE_MODE)
+		return -EPERM;
+	if (!regulator->constraints->valid_modes_mask & mode)
+		return -EINVAL;
+	return 0;
+}
+
+static int constraint_check_drms(struct regulator *regulator)
+{
+	if (!regulator->constraints)
+		return -ENODEV;
+	if (!regulator->constraints->valid_ops_mask &
+			REGULATOR_CHANGE_DRMS)
+		return -EPERM;
+	return 0;
+}
+
+static ssize_t dev_load_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_load *load;
+
+	load = get_regulator_load(dev);
+	if (load == NULL)
+		return 0;
+
+	return sprintf(buf, "%d\n", load->uA_load);
+}
+
+static ssize_t regulator_uV_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+
+	return sprintf(buf, "%d\n", regulator_get_voltage(regulator));
+}
+
+static ssize_t regulator_uV_store(struct device *cdev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	int mV, ret;
+
+	mV = simple_strtoul(buf, NULL, 10);
+
+	ret = regulator_set_voltage(regulator, mV * 1000);
+	if (ret == 0)
+		printk(KERN_INFO "set voltage %d mV\n", mV);
+	else
+		printk(KERN_INFO "set voltage failed\n");
+
+	return count;
+}
+
+static ssize_t regulator_uA_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+
+	return sprintf(buf, "%d\n", regulator_get_current(regulator));
+}
+
+static ssize_t regulator_mode_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	int mode = regulator_get_mode(regulator);
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t regulator_state_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	int state = regulator_is_enabled(regulator);
+
+	if (state > 0)
+		return sprintf(buf, "enabled\n");
+	else if (state == 0)
+		return sprintf(buf, "disabled\n");
+	else
+		return sprintf(buf, "unknown\n");
+}
+
+static ssize_t
+regulator_constraint_uA_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+
+	if (!regulator->constraints)
+		return sprintf(buf, "no constraints\n");
+
+	return sprintf(buf, "%d %d\n",
+			regulator->constraints->min_uA,
+			regulator->constraints->max_uA);
+}
+
+static ssize_t
+regulator_constraint_uV_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+
+	if (!regulator->constraints)
+		return sprintf(buf, "no constraints\n");
+
+	return sprintf(buf, "%d %d\n",
+			regulator->constraints->min_uV,
+			regulator->constraints->max_uV);
+}
+
+static ssize_t
+regulator_constraint_modes_show(struct device *cdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	int count = 0;
+
+	if (!regulator->constraints)
+		return sprintf(buf, "no constraints\n");
+
+	if (regulator->constraints->valid_modes_mask &
+				REGULATOR_MODE_FAST)
+		count = sprintf(buf, "fast ");
+	if (regulator->constraints->valid_modes_mask &
+				REGULATOR_MODE_NORMAL)
+		count += sprintf(buf + count, "normal ");
+	if (regulator->constraints->valid_modes_mask &
+				REGULATOR_MODE_IDLE)
+		count += sprintf(buf + count, "idle ");
+	if (regulator->constraints->valid_modes_mask &
+				REGULATOR_MODE_STANDBY)
+		count += sprintf(buf + count, "standby");
+
+	count += sprintf(buf + count, "\n");
+
+	return count;
+}
+
+static ssize_t regulator_total_dev_load(struct device *cdev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	struct regulator_load *load;
+	int uA = 0;
+
+	list_for_each_entry(load, &regulator->user_list, list) {
+		uA += load->uA_load;
+	}
+
+	return sprintf(buf, "%d\n", uA);
+}
+
+static ssize_t regulator_enabled_use_count(struct device *cdev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	struct regulator *regulator = to_regulator(cdev);
+
+	return sprintf(buf, "%d\n", regulator->use_count);
+}
+
+static ssize_t regulator_ctl(struct device *cdev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	if (buf[0] == '0') {
+		printk(KERN_WARNING "disable regulator.\n");
+		if (regulator_disable(regulator))
+			printk(KERN_ERR "disable regulator failed.\n");
+	} else {
+		printk(KERN_WARNING "enable regulator.\n");
+		if (regulator_enable(regulator))
+			printk(KERN_ERR "enable regulator failed.\n");
+	}
+	return count;
+}
+
+static struct device_attribute regulator_dev_attrs[] = {
+	__ATTR(uV, 0666, regulator_uV_show, regulator_uV_store),
+	__ATTR(uA, 0444, regulator_uA_show, NULL),
+	__ATTR(mode, 0444, regulator_mode_show, NULL),
+	__ATTR(state, 0444, regulator_state_show, NULL),
+	__ATTR(uA_limits, 0444, regulator_constraint_uA_show, NULL),
+	__ATTR(uV_limits, 0444, regulator_constraint_uV_show, NULL),
+	__ATTR(valid_modes, 0444, regulator_constraint_modes_show, NULL),
+	__ATTR(total_uA_load, 0444, regulator_total_dev_load, NULL),
+	__ATTR(enabled_count, 0444, regulator_enabled_use_count, NULL),
+	__ATTR(ctl, 0666, NULL, regulator_ctl),
+	__ATTR_NULL,
+};
+
+static void regulator_dev_release(struct device *dev)
+{
+}
+
+struct class regulator_class = {
+	.name = "regulator",
+	.dev_release = regulator_dev_release,
+	.dev_attrs = regulator_dev_attrs,
+};
+
+static struct regulator_load *create_load_dev(struct regulator *regulator,
+		struct device *dev)
+{
+	struct regulator_load *load;
+	char buf[32];
+	int err;
+
+	load = kzalloc(sizeof(*load), GFP_KERNEL);
+	if (load == NULL)
+		return NULL;
+
+	sprintf(buf, "uA_load-%s", regulator->name);
+	list_add(&load->list, &regulator->user_list);
+	load->dev = dev;
+	load->dev_attr.attr.name = kstrdup(buf, GFP_KERNEL);
+	load->dev_attr.attr.owner = THIS_MODULE;
+	load->dev_attr.attr.mode = 0444;
+	load->dev_attr.show = dev_load_show;
+
+	err = device_create_file(dev, &load->dev_attr);
+	if (err < 0) {
+		printk(KERN_WARNING "%s: could not add"
+				"regulator load"
+				" sysfs\n", __func__);
+		goto err_out;
+	}
+
+	err = sysfs_create_link(&regulator->cdev.kobj, &dev->kobj,
+			kobject_name(&dev->kobj));
+	if (err) {
+		printk
+			(KERN_WARNING "%s : could not add device"
+			 "link %s err %d\n",
+			 __func__, kobject_name(&dev->kobj), err);
+		goto err_out;
+	}
+
+	return load;
+
+err_out:
+	kfree(load->dev_attr.attr.name);
+	kfree(load);
+	return NULL;
+}
+
+struct regulator *regulator_get(struct device *dev,
+		const char *id)
+{
+	struct regulator *r, *regulator = ERR_PTR(-ENOENT);
+	struct regulator_load *load = NULL;
+
+	if (id == NULL)
+		return regulator;
+
+	mutex_lock(&list_mutex);
+
+	list_for_each_entry(r, &regulators, list) {
+		if (strcmp(id, r->name) == 0 &&
+				try_module_get(r->owner)) {
+			regulator = r;
+			goto found;
+		}
+	}
+
+	printk
+		(KERN_WARNING "regulator: Unable to get"
+		 "requested regulator: %s\n",
+		 id);
+
+	mutex_unlock(&list_mutex);
+	return regulator;
+
+found:
+	if (dev) {
+		load = create_load_dev(regulator, dev);
+		if (load == NULL) {
+			regulator = ERR_PTR(-ENOMEM);
+			module_put(regulator->owner);
+		}
+	}
+
+	mutex_unlock(&list_mutex);
+	return regulator;
+}
+EXPORT_SYMBOL_GPL(regulator_get);
+
+void regulator_put(struct regulator *regulator, struct device *dev)
+{
+	struct regulator_load *load, *l;
+
+	if (regulator == NULL || IS_ERR(regulator))
+		return;
+
+	if (!dev)
+		goto put;
+
+	sysfs_remove_link(&regulator->cdev.kobj,
+			kobject_name(&dev->kobj));
+	list_for_each_entry_safe(load, l,
+			&regulator->user_list, list) {
+		device_remove_file(dev, &load->dev_attr);
+		list_del(&load->list);
+		kfree(load->dev_attr.attr.name);
+		kfree(load);
+		goto put;
+	}
+
+put:
+	module_put(regulator->owner);
+	mutex_unlock(&list_mutex);
+}
+EXPORT_SYMBOL_GPL(regulator_put);
+
+static int __regulator_disable(struct regulator *regulator);
+
+static int __regulator_enable(struct regulator *regulator)
+{
+	int ret = 0;
+
+	if (regulator->use_count == 0) {
+
+		if (regulator->parent) {
+			ret = __regulator_enable(regulator->parent);
+
+			if (ret < 0) {
+				__regulator_disable(regulator->parent);
+				goto out;
+			}
+		}
+
+		if (regulator->ops->enable) {
+			ret = regulator->ops->enable(regulator);
+			if (ret < 0) {
+				__regulator_disable(regulator);
+				goto out;
+			}
+		}
+	}
+
+	regulator->use_count++;
+
+out:
+	return ret;
+}
+
+int regulator_enable(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+	ret = __regulator_enable(regulator);
+	mutex_unlock(&regulator->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_enable);
+
+static int __regulator_disable(struct regulator *regulator)
+{
+	int ret = 0;
+
+	if (regulator->use_count > 0 &&
+			!(--regulator->use_count)) {
+		if (regulator->ops->disable) {
+			ret = regulator->ops->disable(regulator);
+			if (ret < 0)
+				goto out;
+		}
+		if (regulator->parent)
+			__regulator_disable(regulator->parent);
+	}
+out:
+	return ret;
+}
+
+int regulator_disable(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+	ret = __regulator_disable(regulator);
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_disable);
+
+int regulator_is_enabled(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->is_enabled) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = regulator->ops->is_enabled(regulator);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_is_enabled);
+
+int regulator_set_voltage(struct regulator *regulator, int uV)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->set_voltage) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = constraint_check_voltage(regulator, uV);
+	if (ret < 0)
+		goto out;
+
+	ret = regulator->ops->set_voltage(regulator, uV);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_voltage);
+
+int regulator_get_voltage(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->get_voltage) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = regulator->ops->get_voltage(regulator);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_get_voltage);
+
+int regulator_set_current(struct regulator *regulator, int uA)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->set_current) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = constraint_check_current(regulator, uA);
+	if (ret < 0)
+		goto out;
+
+	ret = regulator->ops->set_current(regulator, uA);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_current);
+
+int regulator_get_current(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->get_current) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = regulator->ops->get_current(regulator);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_get_current);
+
+int regulator_set_mode(struct regulator *regulator,
+		unsigned int mode)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->set_mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = constraint_check_mode(regulator, mode);
+	if (ret < 0)
+		goto out;
+
+	ret = regulator->ops->set_mode(regulator, mode);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_mode);
+
+unsigned int regulator_get_mode(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->get_mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = regulator->ops->get_mode(regulator);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_get_mode);
+
+unsigned int
+	regulator_get_optimum_mode(struct regulator *regulator,
+		int input_uV, int output_uV,
+		int load_uA)
+{
+	int ret;
+
+	mutex_lock(&regulator->mutex);
+
+	/* sanity check */
+	if (!regulator->ops->get_optimum_mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = regulator->ops->get_optimum_mode(regulator,
+			input_uV, output_uV, load_uA);
+
+out:
+	mutex_unlock(&regulator->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_get_optimum_mode);
+
+int regulator_register_client(struct regulator *regulator,
+		struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(
+			&regulator->notifier, nb);
+}
+EXPORT_SYMBOL_GPL(regulator_register_client);
+
+int regulator_unregister_client(struct regulator *regulator,
+		struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(
+			&regulator->notifier, nb);
+}
+EXPORT_SYMBOL_GPL(regulator_unregister_client);
+
+int regulator_notifier_call_chain(struct regulator *regulator,
+		unsigned long event, void *data)
+{
+	return blocking_notifier_call_chain(
+			&regulator->notifier, event, data);
+}
+EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
+
+int regulator_register(struct regulator *regulator)
+{
+	static atomic_t regulator_no = ATOMIC_INIT(0);
+	int ret;
+
+	if (regulator == NULL || IS_ERR(regulator))
+		return -EINVAL;
+
+	if (regulator->name == NULL ||
+			regulator->ops == NULL)
+		return -EINVAL;
+
+	mutex_lock(&list_mutex);
+
+	mutex_init(&regulator->mutex);
+	regulator->parent = NULL;
+	INIT_LIST_HEAD(&regulator->user_list);
+	BLOCKING_INIT_NOTIFIER_HEAD(&regulator->notifier);
+
+	regulator->cdev.class = &regulator_class;
+	device_initialize(&regulator->cdev);
+	snprintf(regulator->cdev.bus_id,
+			sizeof(regulator->cdev.bus_id),
+			"regulator-%ld-%s",
+			(unsigned long)atomic_inc_return(&regulator_no) - 1,
+			regulator->name);
+
+	ret = device_add(&regulator->cdev);
+	if (ret == 0)
+		list_add(&regulator->list, &regulators);
+
+	mutex_unlock(&list_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_register);
+
+void regulator_unregister(struct regulator *regulator)
+{
+	if (regulator == NULL || IS_ERR(regulator))
+		return;
+
+	mutex_lock(&list_mutex);
+
+	list_del(&regulator->list);
+	if (regulator->parent)
+		sysfs_remove_link(&regulator->cdev.kobj, "source");
+
+	device_unregister(&regulator->cdev);
+
+	mutex_unlock(&list_mutex);
+}
+EXPORT_SYMBOL_GPL(regulator_unregister);
+
+int regulator_set_platform_source(struct regulator *regulator,
+		struct regulator *parent)
+{
+	int err;
+
+	if (regulator == NULL || IS_ERR(regulator))
+		return -EINVAL;
+
+	if (parent == NULL || IS_ERR(parent))
+		return -EINVAL;
+
+	mutex_lock(&list_mutex);
+
+	regulator->parent = parent;
+	err = sysfs_create_link(&regulator->cdev.kobj,
+			&parent->cdev.kobj,
+			"source");
+	if (err)
+		printk(KERN_WARNING
+				"%s : could not add device link"
+				"%s err %d\n", __func__,
+				kobject_name(&parent->cdev.kobj),
+				err);
+
+	mutex_unlock(&list_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_set_platform_source);
+
+struct regulator *regulator_get_platform_source(
+		struct regulator *regulator)
+{
+	if (regulator == NULL || IS_ERR(regulator))
+		return ERR_PTR(-EINVAL);
+	return regulator->parent;
+}
+EXPORT_SYMBOL_GPL(regulator_get_platform_source);
+
+int regulator_set_platform_constraints(const char *regulator_name,
+		struct regulation_constraints
+		*constraints)
+{
+	struct regulator *regulator;
+
+	if (regulator_name == NULL)
+		return -EINVAL;
+
+	mutex_lock(&list_mutex);
+	list_for_each_entry(regulator, &regulators, list) {
+		if (!strcmp(regulator_name, regulator->name)) {
+			mutex_lock(&regulator->mutex);
+			regulator->constraints = constraints;
+			mutex_unlock(&regulator->mutex);
+			mutex_unlock(&list_mutex);
+			return 0;
+		}
+	}
+
+	mutex_unlock(&list_mutex);
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(regulator_set_platform_constraints);
+
+static void load_change(struct regulator *regulator,
+		struct regulator_load *load, int uA)
+{
+	struct regulator_load *l;
+	int current_uA = 0, output_uV, input_uV, err;
+	unsigned int mode;
+
+	load->uA_load = uA;
+	err = constraint_check_drms(regulator);
+	if (err < 0 || !regulator->ops->get_optimum_mode ||
+			!regulator->ops->get_voltage ||
+			!regulator->ops->set_mode)
+		return;
+
+	/* get output voltage */
+	output_uV = regulator->ops->get_voltage(regulator);
+
+	/* get input voltage */
+	if (regulator->parent &&
+			regulator->parent->ops->get_voltage)
+		input_uV =
+			regulator->parent->ops->get_voltage(
+					regulator->parent);
+	else
+		input_uV = regulator->constraints->input_uV;
+
+	/* calc total requested load */
+	list_for_each_entry(l, &regulator->user_list, list)
+		current_uA += l->uA_load;
+
+	mode = regulator->ops->get_optimum_mode(regulator,
+			input_uV, output_uV, current_uA);
+
+	err = constraint_check_mode(regulator, mode);
+	if (err < 0)
+		return;
+
+	regulator->ops->set_mode(regulator, mode);
+}
+
+void regulator_drms_notify_load(struct regulator *regulator,
+		struct device *dev, int uA)
+{
+	struct regulator_load *load;
+
+	mutex_lock(&regulator->mutex);
+	list_for_each_entry(load, &regulator->user_list, list) {
+		if (load->dev == dev) {
+			load_change(regulator, load, uA);
+			break;
+		}
+	}
+	mutex_unlock(&regulator->mutex);
+}
+EXPORT_SYMBOL_GPL(regulator_drms_notify_load);
+
+void *regulator_get_drvdata(struct regulator *regulator)
+{
+	return regulator->reg_data;
+}
+EXPORT_SYMBOL_GPL(regulator_get_drvdata);
+
+void regulator_set_drvdata(struct regulator *regulator,
+		void *data)
+{
+	regulator->reg_data = data;
+}
+EXPORT_SYMBOL_GPL(regulator_set_drvdata);
+
+static int __init regulator_init(void)
+{
+	return class_register(&regulator_class);
+}
+
+static void __exit regulator_exit(void)
+{
+	class_unregister(&regulator_class);
+}
+
+subsys_initcall(regulator_init);
+module_exit(regulator_exit);
+
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, \
+		www.wolfsonmicro.com ");
+MODULE_DESCRIPTION("Regulator Interface");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/reg-mc13892.c b/drivers/regulator/reg-mc13892.c
new file mode 100644
index 0000000..9f106ea
--- /dev/null
+++ b/drivers/regulator/reg-mc13892.c
@@ -0,0 +1,1854 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <mach/mx5_regulator.h>
+#include <asm-arm/plat-mxc/mc13892/core.h>
+#include <linux/platform_device.h>
+#include <asm-arm/plat-mxc/pmic_status.h>
+#include <asm-arm/plat-mxc/pmic_external.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+enum {
+	VDIG_1_05V = 0,
+	VDIG_1_25V,
+	VDIG_1_65V,
+	VDIG_1_80V,
+} regulator_voltage_vdig;
+
+enum {
+	VPLL_1_05V = 0,
+	VPLL_1_25V,
+	VPLL_1_65V,
+	VPLL_1_80V,
+} regulator_voltage_vpll;
+
+enum {
+	VGEN1_1_2V = 0,
+	VGEN1_1_5V,
+	VGEN1_2_775V,
+	VGEN1_3_15V,
+} regulator_voltage_vgen1;
+
+enum {
+	VGEN2_1_2V = 0,
+	VGEN2_1_5V,
+	VGEN2_1_6V,
+	VGEN2_1_8V,
+	VGEN2_2_7V,
+	VGEN2_2_8V,
+	VGEN2_3_0V,
+	VGEN2_3_15V,
+} regulator_voltage_vgen2;
+
+enum {
+	VGEN3_1_8V = 0,
+	VGEN3_2_9V,
+} regulator_voltage_vgen3;
+
+enum {
+	VSD_1_8V = 0,
+	VSD_2_0V,
+	VSD_2_6V,
+	VSD_2_7V,
+	VSD_2_8V,
+	VSD_2_9V,
+	VSD_3_0V,
+	VSD_3_15V,
+} regulator_voltage_vsd;
+
+enum {
+	VCAM_2_5V,
+	VCAM_2_6V,
+	VCAM_2_75V,
+	VCAM_3_0V,
+} regulator_voltage_vcam;
+
+enum {
+	VAUDIO_2_3V,
+	VAUDIO_2_5V,
+	VAUDIO_2_775V,
+	VAUDIO_3V,
+} regulator_voltage_vaudio;
+
+enum {
+	VUSB2_2_4V,
+	VUSB2_2_6V,
+	VUSB2_2_7V,
+	VUSB2_2_775V,
+} regulator_voltage_vusb2;
+
+enum {
+	VVIDEO_2_7V,
+	VVIDEO_2_775V,
+	VVIDEO_2_5V,
+	VVIDEO_2_6V,
+} regulator_voltage_vvideo;
+
+#define VAUDIO_LSH	4
+#define VAUDIO_WID	2
+#define VAUDIO_EN_LSH	15
+#define VAUDIO_EN_WID	1
+#define VAUDIO_EN_ENABLE	1
+#define VAUDIO_EN_DISABLE	0
+
+#define VUSB2_LSH	11
+#define VUSB2_WID	2
+#define VUSB2_EN_LSH	18
+#define VUSB2_EN_WID	1
+#define VUSB2_EN_ENABLE	1
+#define VUSB2_EN_DISABLE	0
+
+#define VVIDEO_LSH	2
+#define VVIDEO_WID	2
+#define VVIDEO_EN_LSH	12
+#define VVIDEO_EN_WID	1
+#define VVIDEO_EN_ENABLE	1
+#define VVIDEO_EN_DISABLE	0
+
+#define SWBST_EN_LSH	20
+#define SWBST_EN_WID	1
+#define SWBST_EN_ENABLE	1
+#define SWBST_EN_DISABLE	0
+
+#define VIOHI_EN_LSH	3
+#define VIOHI_EN_WID	1
+#define VIOHI_EN_ENABLE	1
+#define VIOHI_EN_DISABLE	0
+
+#define VDIG_LSH	4
+#define VDIG_WID	2
+#define VDIG_EN_LSH	9
+#define VDIG_EN_WID	1
+#define VDIG_EN_ENABLE	1
+#define VDIG_EN_DISABLE	0
+
+#define VPLL_LSH	9
+#define VPLL_WID	2
+#define VPLL_EN_LSH	15
+#define VPLL_EN_WID	1
+#define VPLL_EN_ENABLE	1
+#define VPLL_EN_DISABLE	0
+
+#define VGEN1_LSH	0
+#define VGEN1_WID	2
+#define VGEN1_EN_LSH	0
+#define VGEN1_EN_WID	1
+#define VGEN1_EN_ENABLE	1
+#define VGEN1_EN_DISABLE	0
+
+#define VGEN2_LSH	6
+#define VGEN2_WID	3
+#define VGEN2_EN_LSH	12
+#define VGEN2_EN_WID	1
+#define VGEN2_EN_ENABLE	1
+#define VGEN2_EN_DISABLE	0
+
+#define VGEN3_LSH	14
+#define VGEN3_WID	1
+#define VGEN3_EN_LSH	0
+#define VGEN3_EN_WID	1
+#define VGEN3_EN_ENABLE	1
+#define VGEN3_EN_DISABLE	0
+
+#define VSD_LSH	6
+#define VSD_WID	3
+#define VSD_EN_LSH	18
+#define VSD_EN_WID	1
+#define VSD_EN_ENABLE	1
+#define VSD_EN_DISABLE	0
+
+#define VCAM_LSH	16
+#define VCAM_WID	2
+#define VCAM_EN_LSH	6
+#define VCAM_EN_WID	1
+#define VCAM_EN_ENABLE	1
+#define VCAM_EN_DISABLE	0
+#define VCAM_CONFIG_LSH	9
+#define VCAM_CONFIG_WID	1
+#define VCAM_CONFIG_EXT	1
+#define VCAM_CONFIG_INT	0
+
+#define SW1_LSH		0
+#define SW1_WID		5
+#define SW1_DVS_LSH	5
+#define SW1_DVS_WID	5
+#define SW1_STDBY_LSH	10
+#define SW1_STDBY_WID	5
+
+#define SW2_LSH		0
+#define SW2_WID		5
+#define SW2_DVS_LSH	5
+#define SW2_DVS_WID	5
+#define SW2_STDBY_LSH	10
+#define SW2_STDBY_WID	5
+
+#define SW3_LSH		0
+#define SW3_WID		5
+#define SW3_STDBY_LSH	10
+#define SW3_STDBY_WID	5
+
+#define SW4_LSH		0
+#define SW4_WID		5
+#define SW4_STDBY_LSH	10
+#define SW4_STDBY_WID	5
+
+#define VUSB_EN_LSH	3
+#define VUSB_EN_WID	1
+#define VUSB_EN_ENABLE	1
+#define VUSB_EN_DISABLE	0
+
+#define GPO1_EN_LSH	6
+#define GPO1_EN_WID	1
+#define GPO1_EN_ENABLE	1
+#define GPO1_EN_DISABLE	0
+
+#define GPO2_EN_LSH	8
+#define GPO2_EN_WID	1
+#define GPO2_EN_ENABLE	1
+#define GPO2_EN_DISABLE	0
+
+#define GPO3_EN_LSH	10
+#define GPO3_EN_WID	1
+#define GPO3_EN_ENABLE	1
+#define GPO3_EN_DISABLE	0
+
+#define GPO4_EN_LSH	12
+#define GPO4_EN_WID	1
+#define GPO4_EN_ENABLE	1
+#define GPO4_EN_DISABLE	0
+
+#define GPO4_ADIN_LSH	21
+#define GPO4_ADIN_WID	1
+#define GPO4_ADIN_ENABLE	1
+#define GPO4_ADIN_DISABLE	0
+
+#define PWGT1SPI_EN_LSH	15
+#define PWGT1SPI_EN_WID	1
+#define PWGT1SPI_EN_ENABLE	0
+#define PWGT1SPI_EN_DISABLE	1
+
+#define PWGT2SPI_EN_LSH	16
+#define PWGT2SPI_EN_WID	1
+#define PWGT2SPI_EN_ENABLE	0
+#define PWGT2SPI_EN_DISABLE	1
+
+#define SWXHI_LSH	23
+#define SWXHI_WID	1
+#define SWXHI_ON	1
+#define SWXHI_OFF	0
+
+static int mc13892_get_sw_hi_bit(int sw)
+{
+	unsigned int register_val = 0;
+	unsigned int reg = 0;
+
+	switch (sw) {
+	case MC13892_SW1:
+		reg = REG_SW_0;
+		break;
+	case MC13892_SW2:
+		reg = REG_SW_1;
+		break;
+	case MC13892_SW3:
+		reg = REG_SW_2;
+		break;
+	case MC13892_SW4:
+		reg = REG_SW_3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &register_val, PMIC_ALL_BITS));
+	return (register_val & 0x800000) >> SWXHI_LSH;
+}
+
+static int mc13892_get_voltage_value(int *hi, int mV)
+{
+	int voltage;
+
+	if (mV < 600)
+		mV = 600;
+	if (mV > 1850)
+		mV = 1850;
+
+	if (mV > 1375)
+		*hi = 1;
+	if (mV < 1100)
+		*hi = 0;
+
+	if (*hi == 0)
+		voltage = (mV - 600) / 25;
+	else
+		voltage = (mV - 1100) / 25;
+
+	return voltage;
+}
+
+static int mc13892_get_voltage_mV(int hi, int voltage)
+{
+	int mV;
+
+	if (hi == 0)
+		mV = voltage * 25 + 600;
+	else
+		mV = voltage * 25 + 1100;
+
+	return mV;
+}
+
+static int mc13892_sw_set_voltage(struct regulator_dev *reg, int MiniV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage;
+	int sw = rdev_get_id(reg);
+	int mV = uV / 1000;
+	int hi;
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	voltage = mc13892_get_voltage_value(&hi, mV);
+
+	switch (sw) {
+	case MC13892_SW1:
+		register1 = REG_SW_0;
+		register_val = BITFVAL(SW1, voltage);
+		register_mask = BITFMASK(SW1);
+		break;
+	case MC13892_SW2:
+		register1 = REG_SW_1;
+		register_val = BITFVAL(SW2, voltage);
+		register_mask = BITFMASK(SW2);
+		break;
+	case MC13892_SW3:
+		register1 = REG_SW_2;
+		register_val = BITFVAL(SW3, voltage);
+		register_mask = BITFMASK(SW3);
+		break;
+	case MC13892_SW4:
+		register1 = REG_SW_3;
+		register_val = BITFVAL(SW4, voltage);
+		register_mask = BITFMASK(SW4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	register_val |= (hi << SWXHI_LSH);
+	register_mask |= (1 << SWXHI_LSH);
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_sw_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0;
+	int mV = 0;
+	int sw = rdev_get_id(reg);
+	int hi;
+
+	switch (sw) {
+	case MC13892_SW1:
+		CHECK_ERROR(pmic_read_reg(REG_SW_0,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW1);
+		break;
+	case MC13892_SW2:
+		CHECK_ERROR(pmic_read_reg(REG_SW_1,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW2);
+		break;
+	case MC13892_SW3:
+		CHECK_ERROR(pmic_read_reg(REG_SW_2,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW3);
+		break;
+	case MC13892_SW4:
+		CHECK_ERROR(pmic_read_reg(REG_SW_3,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	mV = mc13892_get_voltage_mV(hi, voltage);
+
+	return mV * 1000;
+}
+
+static int mc13892_sw_stby_enable(struct regulator_dev *reg)
+{
+	return 0;
+}
+
+static int mc13892_sw_stby_disable(struct regulator_dev *reg)
+{
+	return 0;
+}
+
+static int mc13892_sw_stby_set_mode(struct regulator_dev *reg, unsigned int mode)
+{
+	return 0;
+}
+
+static int mc13892_sw_stby_set_voltage(struct regulator_dev *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, mV = uV / 1000, hi;
+	int sw = rdev_get_id(reg);
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	voltage = mc13892_get_voltage_value(&hi, mV);
+
+	switch (sw) {
+	case MC13892_SW1:
+		register1 = REG_SW_0;
+		register_val = BITFVAL(SW1_STDBY, voltage);
+		register_mask = BITFMASK(SW1_STDBY);
+		break;
+	case MC13892_SW2:
+		register1 = REG_SW_1;
+		register_val = BITFVAL(SW2_STDBY, voltage);
+		register_mask = BITFMASK(SW2_STDBY);
+		break;
+	case MC13892_SW3:
+		register1 = REG_SW_2;
+		register_val = BITFVAL(SW3_STDBY, voltage);
+		register_mask = BITFMASK(SW3_STDBY);
+		break;
+	case MC13892_SW4:
+		register1 = REG_SW_3;
+		register_val = BITFVAL(SW4_STDBY, voltage);
+		register_mask = BITFMASK(SW4_STDBY);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	register_val |= (hi << SWXHI_LSH);
+	register_mask |= (1 << SWXHI_LSH);
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_swbst_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SWBST_EN, SWBST_EN_ENABLE);
+	register_mask = BITFMASK(SWBST_EN);
+	register1 = REG_SW_5;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_swbst_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SWBST_EN, SWBST_EN_DISABLE);
+	register_mask = BITFMASK(SWBST_EN);
+	register1 = REG_SW_5;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_viohi_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_ENABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_viohi_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_DISABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vusb_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB_EN, VUSB_EN_ENABLE);
+	register_mask = BITFMASK(VUSB_EN);
+	register1 = REG_USB1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vusb_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB_EN, VUSB_EN_DISABLE);
+	register_mask = BITFMASK(VUSB_EN);
+	register1 = REG_USB1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vdig_set_voltage(struct regulator_dev *reg,
+				    int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1050) && (mV < 1250))
+		voltage = VDIG_1_05V;
+	else if ((mV >= 1250) && (mV < 1650))
+		voltage = VDIG_1_25V;
+	else if ((mV >= 1650) && (mV < 1800))
+		voltage = VDIG_1_65V;
+	else
+		voltage = VDIG_1_80V;
+
+	register_val = BITFVAL(VDIG, voltage);
+	register_mask = BITFMASK(VDIG);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vdig_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VDIG);
+
+	switch (voltage) {
+	case VDIG_1_05V:
+		mV = 1050;
+		break;
+	case VDIG_1_25V:
+		mV = 1250;
+		break;
+	case VDIG_1_65V:
+		mV = 1650;
+		break;
+	case VDIG_1_80V:
+		mV = 1800;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vdig_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_ENABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vdig_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_DISABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vpll_set_voltage(struct regulator_dev *reg,
+				    int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1050) && (mV < 1250))
+		voltage = VPLL_1_05V;
+	else if ((mV >= 1250) && (mV < 1650))
+		voltage = VPLL_1_25V;
+	else if ((mV >= 1650) && (mV < 1800))
+		voltage = VPLL_1_65V;
+	else
+		voltage = VPLL_1_80V;
+
+	register_val = BITFVAL(VPLL, voltage);
+	register_mask = BITFMASK(VPLL);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vpll_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VPLL);
+
+	switch (voltage) {
+	case VPLL_1_05V:
+		mV = 1050;
+		break;
+	case VPLL_1_25V:
+		mV = 1250;
+		break;
+	case VPLL_1_65V:
+		mV = 1650;
+		break;
+	case VPLL_1_80V:
+		mV = 1800;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vpll_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VPLL_EN, VPLL_EN_ENABLE);
+	register_mask = BITFMASK(VPLL_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vpll_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VPLL_EN, VPLL_EN_DISABLE);
+	register_mask = BITFMASK(VPLL_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vaudio_set_voltage(struct regulator_dev *reg,
+				      int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2300) && (mV < 2500))
+		voltage = VAUDIO_2_3V;
+	else if ((mV >= 2500) && (mV < 2775))
+		voltage = VAUDIO_2_5V;
+	else if ((mV >= 2775) && (mV < 3000))
+		voltage = VAUDIO_2_775V;
+	else
+		voltage = VAUDIO_3V;
+
+	register_val = BITFVAL(VAUDIO, voltage);
+	register_mask = BITFMASK(VAUDIO);
+	register1 = REG_SETTING_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vaudio_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VAUDIO);
+
+	switch (voltage) {
+	case VAUDIO_2_3V:
+		mV = 2300;
+		break;
+	case VAUDIO_2_5V:
+		mV = 2500;
+		break;
+	case VAUDIO_2_775V:
+		mV = 2775;
+		break;
+	case VAUDIO_3V:
+		mV = 3000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vaudio_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_ENABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vaudio_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_DISABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vusb2_set_voltage(struct regulator_dev *reg,
+				     int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2400) && (mV < 2600))
+		voltage = VUSB2_2_4V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VUSB2_2_6V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VUSB2_2_7V;
+	else
+		voltage = VUSB2_2_775V;
+
+	register_val = BITFVAL(VUSB2, voltage);
+	register_mask = BITFMASK(VUSB2);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vusb2_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VUSB2);
+
+	switch (voltage) {
+	case VUSB2_2_4V:
+		mV = 2400;
+		break;
+	case VUSB2_2_6V:
+		mV = 2600;
+		break;
+	case VUSB2_2_7V:
+		mV = 2700;
+		break;
+	case VUSB2_2_775V:
+		mV = 2775;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vusb2_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB2_EN, VUSB2_EN_ENABLE);
+	register_mask = BITFMASK(VUSB2_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vusb2_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB2_EN, VUSB2_EN_DISABLE);
+	register_mask = BITFMASK(VUSB2_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vvideo_set_voltage(struct regulator_dev *reg,
+				      int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2500) && (mV < 2600))
+		voltage = VVIDEO_2_5V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VVIDEO_2_6V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VVIDEO_2_7V;
+	else
+		voltage = VVIDEO_2_775V;
+
+	register_val = BITFVAL(VVIDEO, voltage);
+	register_mask = BITFMASK(VVIDEO);
+	register1 = REG_SETTING_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vvideo_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VVIDEO);
+
+	switch (voltage) {
+	case VVIDEO_2_5V:
+		mV = 2500;
+		break;
+	case VVIDEO_2_6V:
+		mV = 2600;
+		break;
+	case VVIDEO_2_7V:
+		mV = 2700;
+		break;
+	case VVIDEO_2_775V:
+		mV = 2775;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vvideo_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIDEO_EN, VVIDEO_EN_ENABLE);
+	register_mask = BITFMASK(VVIDEO_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vvideo_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIDEO_EN, VVIDEO_EN_DISABLE);
+	register_mask = BITFMASK(VVIDEO_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vsd_set_voltage(struct regulator_dev *reg,
+				   int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2000))
+		voltage = VSD_1_8V;
+	else if ((mV >= 2000) && (mV < 2600))
+		voltage = VSD_2_0V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VSD_2_6V;
+	else if ((mV >= 2700) && (mV < 2800))
+		voltage = VSD_2_7V;
+	else if ((mV >= 2800) && (mV < 2900))
+		voltage = VSD_2_8V;
+	else if ((mV >= 2900) && (mV < 3000))
+		voltage = VSD_2_9V;
+	else if ((mV >= 3000) && (mV < 3150))
+		voltage = VSD_3_0V;
+	else
+		voltage = VSD_3_15V;
+
+	register_val = BITFVAL(VSD, voltage);
+	register_mask = BITFMASK(VSD);
+	register1 = REG_SETTING_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vsd_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VSD);
+
+	switch (voltage) {
+	case VSD_1_8V:
+		mV = 1800;
+		break;
+	case VSD_2_0V:
+		mV = 2000;
+		break;
+	case VSD_2_6V:
+		mV = 2600;
+		break;
+	case VSD_2_7V:
+		mV = 2700;
+		break;
+	case VSD_2_8V:
+		mV = 2800;
+		break;
+	case VSD_2_9V:
+		mV = 2900;
+		break;
+	case VSD_3_0V:
+		mV = 3000;
+		break;
+	case VSD_3_15V:
+		mV = 3150;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vsd_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSD_EN, VSD_EN_ENABLE);
+	register_mask = BITFMASK(VSD_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vsd_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSD_EN, VSD_EN_DISABLE);
+	register_mask = BITFMASK(VSD_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vcam_set_voltage(struct regulator_dev *reg,
+				    int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2500) && (mV < 2600))
+		voltage = VCAM_2_5V;
+	else if ((mV >= 2600) && (mV < 2750))
+		voltage = VCAM_2_6V;
+	else if ((mV >= 2750) && (mV < 3000))
+		voltage = VCAM_2_75V;
+	else
+		voltage = VCAM_3_0V;
+
+	register_val = BITFVAL(VCAM, voltage);
+	register_mask = BITFMASK(VCAM);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vcam_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VCAM);
+
+	switch (voltage) {
+	case VCAM_2_5V:
+		mV = 2500;
+		break;
+	case VCAM_2_6V:
+		mV = 2600;
+		break;
+	case VCAM_2_75V:
+		mV = 2750;
+		break;
+	case VCAM_3_0V:
+		mV = 3000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vcam_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_ENABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vcam_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_DISABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vcam_set_mode(struct regulator_dev *reg, unsigned int mode)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		register_val = BITFVAL(VCAM_CONFIG, VCAM_CONFIG_EXT);
+		break;
+	case REGULATOR_MODE_NORMAL:
+		register_val = BITFVAL(VCAM_CONFIG, VCAM_CONFIG_INT);
+		break;
+	default:
+		return -EINVAL;
+	}
+	register_mask = BITFMASK(VCAM_CONFIG);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+unsigned int mc13892_vcam_get_mode(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int config = 0, mode = VCAM_CONFIG_INT;
+
+	CHECK_ERROR(pmic_read_reg(REG_MODE_1, &register_val, PMIC_ALL_BITS));
+	config = BITFEXT(register_val, VCAM_CONFIG);
+
+	switch (config) {
+	case VCAM_CONFIG_EXT:
+		mode = REGULATOR_MODE_FAST;
+		break;
+	case VCAM_CONFIG_INT:
+		mode = REGULATOR_MODE_NORMAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return mode;
+}
+
+static int mc13892_vgen1_set_voltage(struct regulator_dev *reg,
+				     int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1500))
+		voltage = VGEN1_1_2V;
+	else if ((mV >= 1500) && (mV < 2775))
+		voltage = VGEN1_1_5V;
+	else if ((mV >= 2775) && (mV < 3150))
+		voltage = VGEN1_2_775V;
+	else
+		voltage = VGEN1_3_15V;
+
+	register_val = BITFVAL(VGEN1, voltage);
+	register_mask = BITFMASK(VGEN1);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen1_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN1);
+
+	switch (voltage) {
+	case VGEN1_1_2V:
+		mV = 1200;
+		break;
+	case VGEN1_1_5V:
+		mV = 1500;
+		break;
+	case VGEN1_2_775V:
+		mV = 2775;
+		break;
+	case VGEN1_3_15V:
+		mV = 3150;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen1_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN1_EN, VGEN1_EN_ENABLE);
+	register_mask = BITFMASK(VGEN1_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen1_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN1_EN, VGEN1_EN_DISABLE);
+	register_mask = BITFMASK(VGEN1_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen2_set_voltage(struct regulator_dev *reg,
+				     int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1500))
+		voltage = VGEN2_1_2V;
+	else if ((mV >= 1500) && (mV < 1600))
+		voltage = VGEN2_1_5V;
+	else if ((mV >= 1600) && (mV < 1800))
+		voltage = VGEN2_1_6V;
+	else if ((mV >= 1800) && (mV < 2700))
+		voltage = VGEN2_1_8V;
+	else if ((mV >= 2700) && (mV < 2800))
+		voltage = VGEN2_2_7V;
+	else if ((mV >= 2800) && (mV < 3000))
+		voltage = VGEN2_2_8V;
+	else if ((mV >= 3000) && (mV < 3150))
+		voltage = VGEN2_3_0V;
+	else
+		voltage = VGEN2_3_15V;
+
+	register_val = BITFVAL(VGEN2, voltage);
+	register_mask = BITFMASK(VGEN2);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen2_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN2);
+
+	switch (voltage) {
+	case VGEN2_1_2V:
+		mV = 1200;
+		break;
+	case VGEN2_1_5V:
+		mV = 1500;
+		break;
+	case VGEN2_1_6V:
+		mV = 1600;
+		break;
+	case VGEN2_1_8V:
+		mV = 1800;
+		break;
+	case VGEN2_2_7V:
+		mV = 2700;
+		break;
+	case VGEN2_2_8V:
+		mV = 2800;
+		break;
+	case VGEN2_3_0V:
+		mV = 3000;
+		break;
+	case VGEN2_3_15V:
+		mV = 3150;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen2_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN2_EN, VGEN2_EN_ENABLE);
+	register_mask = BITFMASK(VGEN2_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen2_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN2_EN, VGEN2_EN_DISABLE);
+	register_mask = BITFMASK(VGEN2_EN);
+	register1 = REG_MODE_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen3_set_voltage(struct regulator_dev *reg,
+				     int minuV, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2900))
+		voltage = VGEN3_1_8V;
+	else
+		voltage = VGEN3_2_9V;
+
+	register_val = BITFVAL(VGEN3, voltage);
+	register_mask = BITFMASK(VGEN3);
+	register1 = REG_SETTING_0;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen3_get_voltage(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN3);
+
+	switch (voltage) {
+	case VGEN3_1_8V:
+		mV = 1800;
+		break;
+	case VGEN3_2_9V:
+		mV = 2900;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen3_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN3_EN, VGEN3_EN_ENABLE);
+	register_mask = BITFMASK(VGEN3_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_vgen3_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN3_EN, VGEN3_EN_DISABLE);
+	register_mask = BITFMASK(VGEN3_EN);
+	register1 = REG_MODE_1;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_gpo_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = rdev_get_id(reg);
+
+	switch (gpo) {
+	case MC13892_GPO1:
+		register_val = BITFVAL(GPO1_EN, GPO1_EN_ENABLE);
+		register_mask = BITFMASK(GPO1_EN);
+		break;
+	case MC13892_GPO2:
+		register_val = BITFVAL(GPO2_EN, GPO2_EN_ENABLE);
+		register_mask = BITFMASK(GPO2_EN);
+		break;
+	case MC13892_GPO3:
+		register_val = BITFVAL(GPO3_EN, GPO3_EN_ENABLE);
+		register_mask = BITFMASK(GPO3_EN);
+		break;
+	case MC13892_GPO4:
+		register_val = BITFVAL(GPO4_EN, GPO4_EN_ENABLE) +
+		    BITFVAL(GPO4_ADIN, GPO4_ADIN_DISABLE);
+		register_mask = BITFMASK(GPO4_EN) + BITFMASK(GPO4_ADIN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_gpo_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = rdev_get_id(reg);
+
+	switch (gpo) {
+	case MC13892_GPO1:
+		register_val = BITFVAL(GPO1_EN, GPO1_EN_DISABLE);
+		register_mask = BITFMASK(GPO1_EN);
+		break;
+	case MC13892_GPO2:
+		register_val = BITFVAL(GPO2_EN, GPO2_EN_DISABLE);
+		register_mask = BITFMASK(GPO2_EN);
+		break;
+	case MC13892_GPO3:
+		register_val = BITFVAL(GPO3_EN, GPO3_EN_DISABLE);
+		register_mask = BITFMASK(GPO3_EN);
+		break;
+	case MC13892_GPO4:
+		register_val = BITFVAL(GPO4_EN, GPO4_EN_DISABLE);
+		register_mask = BITFMASK(GPO4_EN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_power_gating_enable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = rdev_get_id(reg);
+
+	switch (gpo) {
+	case MC13892_PWGT1:
+		register_val = BITFVAL(PWGT1SPI_EN, PWGT1SPI_EN_ENABLE);
+		register_mask = BITFMASK(PWGT1SPI_EN);
+		break;
+	case MC13892_PWGT2:
+		register_val = BITFVAL(PWGT2SPI_EN, PWGT2SPI_EN_ENABLE);
+		register_mask = BITFMASK(PWGT2SPI_EN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static int mc13892_power_gating_disable(struct regulator_dev *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = rdev_get_id(reg);
+
+	switch (gpo) {
+	case MC13892_PWGT1:
+		register_val = BITFVAL(PWGT1SPI_EN, PWGT1SPI_EN_DISABLE);
+		register_mask = BITFMASK(PWGT1SPI_EN);
+		break;
+	case MC13892_PWGT2:
+		register_val = BITFVAL(PWGT2SPI_EN, PWGT2SPI_EN_DISABLE);
+		register_mask = BITFMASK(PWGT2SPI_EN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return pmic_write_reg(register1, register_val, register_mask);
+}
+
+static struct regulator_ops mc13892_sw_ops = {
+	.enable = mc13892_sw_stby_enable,
+	.disable = mc13892_sw_stby_disable,
+	.set_voltage = mc13892_sw_set_voltage,
+	.get_voltage = mc13892_sw_get_voltage,
+	.set_suspend_voltage = mc13892_sw_stby_set_voltage,
+	.set_suspend_enable = mc13892_sw_stby_enable,
+	.set_suspend_disable = mc13892_sw_stby_disable,
+	.set_suspend_mode = mc13892_sw_stby_set_mode,
+};
+
+static struct regulator_ops mc13892_swbst_ops = {
+	.enable = mc13892_swbst_enable,
+	.disable = mc13892_swbst_disable,
+};
+
+static struct regulator_ops mc13892_viohi_ops = {
+	.enable = mc13892_viohi_enable,
+	.disable = mc13892_viohi_disable,
+};
+
+static struct regulator_ops mc13892_vusb_ops = {
+	.enable = mc13892_vusb_enable,
+	.disable = mc13892_vusb_disable,
+};
+
+static struct regulator_ops mc13892_vdig_ops = {
+	.set_voltage = mc13892_vdig_set_voltage,
+	.get_voltage = mc13892_vdig_get_voltage,
+	.enable = mc13892_vdig_enable,
+	.disable = mc13892_vdig_disable,
+};
+
+static struct regulator_ops mc13892_vpll_ops = {
+	.set_voltage = mc13892_vpll_set_voltage,
+	.get_voltage = mc13892_vpll_get_voltage,
+	.enable = mc13892_vpll_enable,
+	.disable = mc13892_vpll_disable,
+};
+
+static struct regulator_ops mc13892_vusb2_ops = {
+	.set_voltage = mc13892_vusb2_set_voltage,
+	.get_voltage = mc13892_vusb2_get_voltage,
+	.enable = mc13892_vusb2_enable,
+	.disable = mc13892_vusb2_disable,
+};
+
+static struct regulator_ops mc13892_vvideo_ops = {
+	.set_voltage = mc13892_vvideo_set_voltage,
+	.get_voltage = mc13892_vvideo_get_voltage,
+	.enable = mc13892_vvideo_enable,
+	.disable = mc13892_vvideo_disable,
+};
+
+static struct regulator_ops mc13892_vaudio_ops = {
+	.set_voltage = mc13892_vaudio_set_voltage,
+	.get_voltage = mc13892_vaudio_get_voltage,
+	.enable = mc13892_vaudio_enable,
+	.disable = mc13892_vaudio_disable,
+};
+
+static struct regulator_ops mc13892_vsd_ops = {
+	.set_voltage = mc13892_vsd_set_voltage,
+	.get_voltage = mc13892_vsd_get_voltage,
+	.enable = mc13892_vsd_enable,
+	.disable = mc13892_vsd_disable,
+};
+
+static struct regulator_ops mc13892_vcam_ops = {
+	.set_voltage = mc13892_vcam_set_voltage,
+	.get_voltage = mc13892_vcam_get_voltage,
+	.enable = mc13892_vcam_enable,
+	.disable = mc13892_vcam_disable,
+	.set_mode = mc13892_vcam_set_mode,
+	.get_mode = mc13892_vcam_get_mode,
+};
+
+static struct regulator_ops mc13892_vgen1_ops = {
+	.set_voltage = mc13892_vgen1_set_voltage,
+	.get_voltage = mc13892_vgen1_get_voltage,
+	.enable = mc13892_vgen1_enable,
+	.disable = mc13892_vgen1_disable,
+};
+
+static struct regulator_ops mc13892_vgen2_ops = {
+	.set_voltage = mc13892_vgen2_set_voltage,
+	.get_voltage = mc13892_vgen2_get_voltage,
+	.enable = mc13892_vgen2_enable,
+	.disable = mc13892_vgen2_disable,
+};
+
+static struct regulator_ops mc13892_vgen3_ops = {
+	.set_voltage = mc13892_vgen3_set_voltage,
+	.get_voltage = mc13892_vgen3_get_voltage,
+	.enable = mc13892_vgen3_enable,
+	.disable = mc13892_vgen3_disable,
+};
+
+static struct regulator_ops mc13892_gpo_ops = {
+	.enable = mc13892_gpo_enable,
+	.disable = mc13892_gpo_disable,
+};
+
+static struct regulator_ops mc13892_power_gating_ops = {
+	.enable = mc13892_power_gating_enable,
+	.disable = mc13892_power_gating_disable,
+
+};
+
+static struct regulator_desc mc13892_reg[] = {
+	{
+		.name = "SW1",
+		.id = MC13892_SW1,
+		.ops = &mc13892_sw_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "SW2",
+		.id = MC13892_SW2,
+		.ops = &mc13892_sw_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "SW3",
+		.id = MC13892_SW3,
+		.ops = &mc13892_sw_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "SW4",
+		.id = MC13892_SW4,
+		.ops = &mc13892_sw_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "SWBST",
+		.id = MC13892_SWBST,
+		.ops = &mc13892_swbst_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VIOHI",
+		.id = MC13892_VIOHI,
+		.ops = &mc13892_viohi_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VPLL",
+		.id = MC13892_VPLL,
+		.ops = &mc13892_vpll_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VDIG",
+		.id = MC13892_VDIG,
+		.ops = &mc13892_vdig_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VSD",
+		.id = MC13892_VSD,
+		.ops = &mc13892_vsd_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VUSB2",
+		.id = MC13892_VUSB2,
+		.ops = &mc13892_vusb2_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VVIDEO",
+		.id = MC13892_VVIDEO,
+		.ops = &mc13892_vvideo_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VAUDIO",
+		.id = MC13892_VAUDIO,
+		.ops = &mc13892_vaudio_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VCAM",
+		.id = MC13892_VCAM,
+		.ops = &mc13892_vcam_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VGEN1",
+		.id = MC13892_VGEN1,
+		.ops = &mc13892_vgen1_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VGEN2",
+		.id = MC13892_VGEN2,
+		.ops = &mc13892_vgen2_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VGEN3",
+		.id = MC13892_VGEN3,
+		.ops = &mc13892_vgen3_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "VUSB",
+		.id = MC13892_VUSB,
+		.ops = &mc13892_vusb_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "GPO1",
+		.id = MC13892_GPO1,
+		.ops = &mc13892_gpo_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "GPO2",
+		.id = MC13892_GPO2,
+		.ops = &mc13892_gpo_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "GPO3",
+		.id = MC13892_GPO3,
+		.ops = &mc13892_gpo_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "GPO4",
+		.id = MC13892_GPO4,
+		.ops = &mc13892_gpo_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "PWGT1",
+		.id = MC13892_PWGT1,
+		.ops = &mc13892_power_gating_ops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+};
+
+static int mc13892_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev;
+	struct regulator_init_data *init_data = pdev->dev.platform_data;
+	int ret;
+
+	/* register regulator */
+	rdev = regulator_register(&mc13892_reg[pdev->id], pdev);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s\n",
+			mc13892_reg[pdev->id].name);
+		return PTR_ERR(rdev);
+	}
+
+	/* set regulator constraints */
+	ret = regulator_set_machine_constraints(init_data->constraints.name,
+						&init_data->constraints);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to set constraints %s\n",
+			mc13892_reg[pdev->id].name);
+		regulator_unregister(rdev);
+		return ret;
+	}
+
+
+	return 0;
+}
+
+
+static int mc13892_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+
+	return 0;
+}
+
+int mc13892_register_regulator(struct mc13892 *mc13892, int reg,
+			      struct regulator_init_data *initdata)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	if (mc13892->pmic.pdev[reg])
+		return -EBUSY;
+
+	pdev = platform_device_alloc("mc13892-regulatr", reg);
+	if (!pdev)
+		return -ENOMEM;
+
+	mc13892->pmic.pdev[reg] = pdev;
+
+	initdata->driver_data = mc13892;
+
+	pdev->dev.platform_data = initdata;
+	pdev->dev.parent = mc13892->dev;
+	platform_set_drvdata(pdev, mc13892);
+	ret = platform_device_add(pdev);
+
+	if (ret != 0) {
+		dev_err(mc13892->dev, "Failed to register regulator %d: %d\n",
+			reg, ret);
+		platform_device_del(pdev);
+		mc13892->pmic.pdev[reg] = NULL;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(mc13892_register_regulator);
+
+static struct platform_driver mc13892_regulator_driver = {
+	.probe = mc13892_regulator_probe,
+	.remove = mc13892_regulator_remove,
+	.driver		= {
+		.name	= "mc13892-regulatr",
+	},
+};
+
+static int __init mc13892_regulator_init(void)
+{
+	return platform_driver_register(&mc13892_regulator_driver);
+}
+subsys_initcall(mc13892_regulator_init);
+
+static void __exit mc13892_regulator_exit(void)
+{
+	platform_driver_unregister(&mc13892_regulator_driver);
+}
+module_exit(mc13892_regulator_exit);
+
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MC13892 Regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/regulator/regulator-drv.h b/include/linux/regulator/regulator-drv.h
new file mode 100644
index 0000000..2ba6ab1
--- /dev/null
+++ b/include/linux/regulator/regulator-drv.h
@@ -0,0 +1,107 @@
+/*
+ * regulator-drv.h -- SoC Regulator support.
+ *
+ * Copyright (C) 2007 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Regulator Driver Interface.
+ */
+
+
+#ifndef __LINUX_REGULATOR_DRV_H_
+#define __LINUX_REGULATOR_DRV_H_
+
+#include <linux/device.h>
+#include <linux/regulator/regulator.h>
+
+struct regulator_constraints;
+
+/**
+ * struct regulator_ops - regulator operations.
+ *
+ * This struct describes regulator operations.
+ */
+struct regulator_ops {
+
+	/* get/set regulator voltage */
+	int (*set_voltage)(struct regulator *, int uV);
+	int (*get_voltage)(struct regulator *);
+
+	/* get/set regulator current  */
+	int (*set_current)(struct regulator *, int uA);
+	int (*get_current)(struct regulator *);
+
+	/* enable/disable regulator */
+	int (*enable)(struct regulator *);
+	int (*disable)(struct regulator *);
+	int (*is_enabled)(struct regulator *);
+
+	/* get/set regulator mode (defined in regulator.h) */
+	int (*set_mode)(struct regulator *, unsigned int mode);
+	unsigned int (*get_mode)(struct regulator *);
+
+	/* get most efficient regulator mode for load */
+	unsigned int (*get_optimum_mode)(struct regulator *, int input_uV,
+			int output_uV, int load_uA);
+};
+
+/**
+ * struct regulator
+ *
+ * Voltage / Current regulator.
+ */
+struct regulator {
+	const char *name;
+	int id;
+	struct regulator_ops *ops;
+	struct regulation_constraints *constraints;
+	int use_count;
+
+	struct list_head list;
+	struct list_head user_list;
+	struct blocking_notifier_head notifier;
+	struct mutex mutex;
+	struct module *owner;
+	struct device cdev;
+
+	struct regulator *parent; /* for tree */
+
+	void *reg_data; /* regulator data */
+	void *vendor; /* regulator vendor extensions */
+};
+
+/**
+ * regulator_register - register regulator
+ * @regulator: regulator source
+ *
+ * Called by regulator drivers to register a regulator.
+ * Returns 0 on success.
+ */
+int regulator_register(struct regulator *regulator);
+
+/**
+ * regulator_unregister - unregister regulator
+ * @regulator: regulator source
+ *
+ * Called by regulator drivers to unregister a regulator.
+ */
+void regulator_unregister(struct regulator *regulator);
+
+/**
+ * regulator_notifier_call_chain - call regulator event notifier
+ * @regulator: regulator source
+ * @event: notifier block
+ * @data:
+ *
+ * Called by regulator drivers to notify clients a regulator event has
+ * occurred.
+ */
+int regulator_notifier_call_chain(struct regulator *regulator,
+		unsigned long event, void *data);
+
+#endif
diff --git a/include/linux/regulator/regulator-platform.h b/include/linux/regulator/regulator-platform.h
new file mode 100644
index 0000000..36cc2ac
--- /dev/null
+++ b/include/linux/regulator/regulator-platform.h
@@ -0,0 +1,102 @@
+/*
+ * regulator-platform.h -- SoC Regulator support.
+ *
+ * Copyright (C) 2007 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Regulator Platform Interface.
+ */
+
+
+#ifndef __LINUX_REGULATOR_PLATFORM_H_
+#define __LINUX_REGULATOR_PLATFORM_H_
+
+#include <linux/regulator/regulator.h>
+
+struct regulator;
+
+/*
+ * Regulator operations.
+ *
+ * @VOLTAGE:  Regulator output voltage can be changed by software on this
+ *            board/machine.
+ * @CURRENT:  Regulator output current can be changed by software on this
+ *            board machine.
+ * @MODE:     Regulator operating mode can be changed by software on this
+ *            board machine.
+ * @STATUS:   Regulator can be enabled and disabled.
+ * @DRMS:     Dynamic Regulator Mode Switching is enabled for this regulator.
+ */
+
+#define REGULATOR_CHANGE_VOLTAGE	0x1
+#define REGULATOR_CHANGE_CURRENT	0x2
+#define REGULATOR_CHANGE_MODE		0x4
+#define REGULATOR_CHANGE_STATUS		0x8
+#define REGULATOR_CHANGE_DRMS		0x10
+
+/**
+ * struct regulation_constraints - regulator operating constraints.
+ *
+ * This struct describes regulator and board/machine specific constraints.
+ */
+struct regulation_constraints {
+
+	char *name;
+
+	/* voltage output range - for voltage control */
+	int min_uV;
+	int max_uV;
+
+	/* current output range - for current control */
+	int min_uA;
+	int max_uA;
+
+	/* valid regulator operating modes for this machine */
+	unsigned int valid_modes_mask;
+
+	/* valid operations for regulator on this machine */
+	unsigned int valid_ops_mask;
+
+	/* input voltage */
+	int input_uV;
+};
+
+/**
+ * regulator_set_platform_source - set regulator source regulator
+ * @regulator: regulator source
+ * @parent: source or parent regulator
+ *
+ * Called by platform initialisation code to set the source supply or "parent"
+ * regulator for this regulator.
+ */
+int regulator_set_platform_source(struct regulator *reg,
+		struct regulator *parent);
+
+/**
+ * regulator_get_platform_source - get regulator source regulator
+ * @regulator: regulator source
+ *
+ * Returns the regulator supply regulator or NULL if no supply regulator
+ * exists (i.e the regulator is supplied directly from USB, Line, Battery, etc)
+ */
+struct regulator *regulator_get_platform_source(struct regulator *regulator);
+
+
+/**
+ * regulator_set_platform_constraints - sets regulator constraints
+ * @regulator: regulator source
+ *
+ * Allows platform initialisation code to define and constrain regulator
+ * circuits e.g. valid voltage/current ranges, etc.
+ * NOTE: Constraints must be set by platform code in order for some
+ * regulator operations to proceed i.e. set_voltage, set_current, set_mode.
+ */
+int regulator_set_platform_constraints(const char *regulator_name,
+		struct regulation_constraints *constraints);
+
+#endif
diff --git a/include/linux/regulator/regulator.h b/include/linux/regulator/regulator.h
new file mode 100644
index 0000000..230dae9
--- /dev/null
+++ b/include/linux/regulator/regulator.h
@@ -0,0 +1,341 @@
+/*
+ * regulator.h -- SoC Regulator support.
+ *
+ * Copyright (C) 2007 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Regulator Client Interface.
+ *
+ * A Power Management Regulator framework for SoC based devices.
+ * Features:-
+ *   o Voltage and current level control.
+ *   o Operating mode control.
+ *   o Regulator status.
+ *   o sysfs entries for showing client devices and status
+ *
+ * EXPERIMENTAL FEATURES:
+ *   Dynamic Regulator operating Mode Switching (DRMS) - allows regulators
+ *   to use most efficient operating mode depending upon voltage and load and
+ *   is transparent to client drivers.
+ */
+
+
+#ifndef __LINUX_REGULATOR_H_
+#define __LINUX_REGULATOR_H_
+
+/*
+ * Regulator operating modes.
+ *
+ * Regulators can run in a variety of different operating modes depending
+ * output load. This allows further power saving though regulator efficiency.
+ *
+ * Most drivers will only care about NORMAL. The modes below are generic and
+ * will probably not match the naming convention of your regulator data sheet
+ * but should match the use cases in the datasheet.
+ *
+ * In order of power efficiency (least efficient at top).
+ *
+ *  Mode       Description
+ *  FAST       Regulator can handle fast changes in it's load.
+ *             e.g. usefull in CPU voltage & frequency scaling where
+ *             load can quickly increase with freqency increases.
+ *
+ *  NORMAL     Normal regulator power supply mode. Most drivers will
+ *             use this mode.
+ *
+ *  IDLE       Regulator runs in a more efficient mode for light
+ *             loads. Can be used for devices that have a low power
+ *             requirement during periods of inactivity. This mode
+ *             may be more noisy than NORMAL and may not be able
+ *             to handle fast load switching.
+ *
+ *  STANDBY    Regulator runs in most efficient mode for very
+ *             light loads. Can be used by devices when they are
+ *             in a sleep/standby state. This mode may be more noisy
+ *             than NORMAL and may not be able to handle fast load
+ *             switching.
+ *
+ * NOTE: Most regulators will only support a subset of these modes. Some
+ * will only just support NORMAL.
+ */
+
+#define REGULATOR_MODE_FAST		0x1
+#define REGULATOR_MODE_NORMAL		0x2
+#define REGULATOR_MODE_IDLE		0x4
+#define REGULATOR_MODE_STANDBY		0x8
+
+/*
+ * Regulator notifier events.
+ *
+ * @UNDER_VOLTAGE:  Regulator output is undervoltage.
+ * @OVER_CURRENT:   Regulator output current is too high.
+ * @POWER_ON:       Regulator power ON event.
+ * @POWER_OFF:      Regulator power OFF event.
+ * @REGULATION_OUT: Regulator output is out of regulation.
+ * @FAIL:           Regulator output has failed.
+ * @OVER_TEMP:      Regulator over temp.
+ */
+
+#define REGULATOR_EVENT_UNDER_VOLTAGE		0x1
+#define REGULATOR_EVENT_OVER_CURRENT		0x2
+#define REGULATOR_EVENT_POWER_ON		0x4
+#define REGULATOR_EVENT_POWER_OFF		0x8
+#define REGULATOR_EVENT_REGULATION_OUT		0x10
+#define REGULATOR_EVENT_FAIL			0x20
+#define REGULATOR_EVENT_OVER_TEMP		0x40
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+struct regulator;
+
+#if defined(CONFIG_REGULATOR_API)
+
+/**
+ * regulator_get - lookup and obtain a reference to a regulator.
+ * @dev: device for regulator "consumer"
+ * @id: regulator ID
+ *
+ * Returns a struct regulator corresponding to the regulator producer, or
+ * valid IS_ERR() condition containing errno.
+ *
+ * Drivers must assume that the clock source is not enabled.
+ */
+struct regulator *regulator_get(struct device *dev, const char *id);
+
+/**
+ * regulator_put - "free" the regulator source
+ * @regulator: regulator source
+ * @dev: device
+ *
+ * Note: drivers must ensure that all regulator_enable calls made on this
+ * regulator source are balanced by regulator_disable calls prior to calling
+ * this function.
+ */
+void regulator_put(struct regulator *regulator, struct device *dev);
+
+/**
+ * regulator_enable - enable regulator output
+ * @regulator: regulator source
+ *
+ * Enable the regulator output at the predefined voltage or current value.
+ * Note: the output value can be set by other drivers, bootloader or may be
+ * hardwired in the regulator.
+ */
+int regulator_enable(struct regulator *regulator);
+
+/**
+ * regulator_disable - disable regulator output
+ * @regulator: regulator source
+ *
+ * Disable the regulator output voltage or current.
+ */
+int regulator_disable(struct regulator *regulator);
+
+/**
+ * regulator_is_enabled - is the regulator output enabled
+ * @regulator: regulator source
+ *
+ * Returns zero for disabled otherwise return number of enable requests.
+ */
+int regulator_is_enabled(struct regulator *regulator);
+
+/**
+ * regulator_set_voltage - set regulator output voltage
+ * @regulator: regulator source
+ * @uV: voltage in uV
+ *
+ * Sets a voltage regulator to the desired output voltage. This can be set
+ * during any regulator state. IOW, regulator can be disabled or enabled.
+ *
+ * If the regulator is enabled then the voltage will change to the new value
+ * immediately otherwise if the regulator is disabled the regulator will
+ * output at the new voltage when enabled.
+ */
+int regulator_set_voltage(struct regulator *regulator, int uV);
+
+/**
+ * regulator_get_voltage - get regulator output voltage
+ * @regulator: regulator source
+ *
+ * This returns the regulator voltage in uV.
+ *
+ * Note: If the regulator is disabled it will return the voltage value. This
+ * function should not be used to determine regulator state.
+ */
+int regulator_get_voltage(struct regulator *regulator);
+
+/**
+ * regulator_set_current - set regulator output current
+ * @regulator: regulator source
+ * @uV: voltage in uA
+ *
+ * Sets current regulator to the desired output current. This can be set during
+ * any regulator state. IOW, regulator can be disabled or enabled.
+ *
+ * If the regulator is enabled then the current will change to the new value
+ * immediately otherwise if the regulator is disabled the regulator will
+ * output at the new current when enabled.
+ */
+int regulator_set_current(struct regulator *regulator, int uA);
+
+/**
+ * regulator_get_current - get regulator output current
+ * @regulator: regulator source
+ *
+ * This returns the regulator current in uA.
+ *
+ * Note: If the regulator is disabled it will return the current value. This
+ * function should not be used to determine regulator state.
+ */
+int regulator_get_current(struct regulator *regulator);
+
+/**
+ * regulator_set_mode - set regulator operating mode
+ * @regulator: regulator source
+ * @mode: operating mode
+ *
+ * Set regulator operating mode to increase regulator efficiency or improve
+ * regulation performance.
+ */
+int regulator_set_mode(struct regulator *regulator, unsigned int mode);
+
+/**
+ * regulator_get_mode - set regulator operating mode
+ * @regulator: regulator source
+ *
+ * Get the current regulator operating mode.
+ */
+unsigned int regulator_get_mode(struct regulator *regulator);
+
+/**
+ * regulator_get_optimum_mode - get regulator optimum operating mode
+ * @regulator: regulator source
+ * @input_uV: input voltage
+ * @output_uV: output voltage
+ * @load_uV: load current
+ *
+ * Get the most efficient regulator operating mode for the given input
+ * and output voltages at a specific load..
+ */
+unsigned int regulator_get_optimum_mode(struct regulator *regulator,
+		int input_uV, int output_uV, int load_uA);
+
+/**
+ * regulator_register_client - register regulator event notifier
+ * @regulator: regulator source
+ * @notifier_block: notifier block
+ *
+ * Register notifier block to receive regulator events.
+ */
+int regulator_register_client(struct regulator *regulator,
+		struct notifier_block *nb);
+
+/**
+ * regulator_unregister_client - unregister regulator event notifier
+ * @regulator: regulator source
+ * @notifier_block: notifier block
+ *
+ * Unregister regulator event notifier block.
+ */
+int regulator_unregister_client(struct regulator *regulator,
+		struct notifier_block *nb);
+
+/**
+ * regulator_notify_load - notify regulator of device max load
+ * @regulator: regulator
+ * @dev: device
+ * @uA: load
+ *
+ * Notifies the regulator of new max device load. Can be used by DRMS to select
+ * the most efficient regulator operating mode.
+ *
+ * Client devices notify their supply regulator of the maximum power
+ * they will require when they change operational status and hence power
+ * state. Examples of operational state changes that can affect power
+ * consumption are :-
+ *
+ *    o Device is opened / closed.
+ *    o Device IO is about to begin or has just finished.
+ *    o Device is idling in between work.
+ *
+ * The power tables in device datasheets would be used by the driver for
+ * the power consumption in each operational state. This information is
+ * also exported via sysfs to userspace.
+ *
+ * DRMS would then sum the total requested load on the regulator and change
+ * to the most efficient operating mode if platform constraints allow.
+ */
+void regulator_drms_notify_load(struct regulator *regulator,
+		struct device *dev, int uA);
+
+/**
+ * regulator_get_drvdata - get regulator driver data
+ * @regulator: regulator
+ */
+void *regulator_get_drvdata(struct regulator *regulator);
+
+/**
+ * regulator_set_drvdata - set regulator driver data
+ * @regulator: regulator
+ * @void: data
+ */
+void regulator_set_drvdata(struct regulator *regulator, void *data);
+
+#else
+
+/*
+ * Make sure client drivers will still build on systems with no software
+ * controllable voltage or current regulators.
+ */
+#define regulator_get(dev, id)	({ (void)(dev); \
+		(void)(id); NULL; })
+#define regulator_put(regulator, dev) \
+	do { (void)(regulator); (void)(dev); } while (0)
+#define regulator_enable(regulator) \
+	({ (void)(regulator); 0; })
+#define regulator_disable(regulator) \
+	({ (void)(regulator); 0; })
+#define regulator_is_enabled(regulator) \
+	({ (void)(regulator); 1; })
+#define regulator_set_voltage(regulator, uV) \
+	({ (void)(regulator); (void)(uV); 0; })
+#define regulator_get_voltage(regulator) \
+	({ (void)(regulator); 0; })
+#define regulator_set_current(regulator, uA) \
+	({ (void)(regulator); (void)(uA); 0; })
+#define regulator_get_current(regulator) \
+	({ (void)(regulator); 0; })
+#define regulator_set_mode(regulator, mode) \
+	({ (void)(regulator); (void)(mode); 0; })
+#define regulator_get_mode(regulator) \
+	({ (void)(regulator); 0; })
+#define regulator_get_optimum_mode(regulator, \
+		input_uV, output_uV, load_uA) \
+	({ (void)(regulator); (void)(input_uV); \
+	 (void)(output_uV); (void)(load_uA); 0; })
+#define regulator_register_client(regulator, nb) \
+	({ (void)(regulator); (void)(nb); 0; })
+#define regulator_unregister_client(regulator, nb) \
+	do { (void)(regulator); (void)(nb); } while (0)
+#define regulator_notify_load(regulator, dev, uA) \
+	do { (void)(regulator); (void)(dev); (void)(uA); } while (0)
+#define regulator_get_drvdata(regulator) \
+	({ (void)(regulator); NULL; })
+#define regulator_set_drvdata(regulator, data) \
+	do { (void)(regulator); (void)(data); } while (0)
+
+#endif
+
+#endif
-- 
1.5.5.1

