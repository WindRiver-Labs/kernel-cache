From 79cfb3341c2cdd5d1c0ebebc0b8b719890355d24 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 19 May 2010 18:43:22 +0800
Subject: [PATCH 05/30] mx5: add mx5 platform common files

Add mx5 series platform common files, include usb device registration,
power manament suspend and idle implementation, io multiplex manament,
peripheral clocks and dma manament.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-mx5/Kconfig            |   66 +
 arch/arm/mach-mx5/Makefile           |   12 +-
 arch/arm/mach-mx5/bus_freq.c         |  575 ++++++++
 arch/arm/mach-mx5/clock-mx51.c       | 2583 ++++++++++++++++++++++++++++++++--
 arch/arm/mach-mx5/cpu.c              |    9 +
 arch/arm/mach-mx5/crm_regs.h         |   12 +
 arch/arm/mach-mx5/devices.c          | 1201 ++++++++++++++++-
 arch/arm/mach-mx5/dma.c              |  727 ++++++++++
 arch/arm/mach-mx5/dummy_gpio.c       |  113 ++
 arch/arm/mach-mx5/iomux.c            |  244 ++++
 arch/arm/mach-mx5/iomux.h            |  246 ++++
 arch/arm/mach-mx5/lpmodes.c          |  309 ++++
 arch/arm/mach-mx5/mm.c               |    5 +
 arch/arm/mach-mx5/mx51_pins.h        |  361 +++++
 arch/arm/mach-mx5/pm.c               |  220 +++
 arch/arm/mach-mx5/sdma_script_code.h |  170 +++
 arch/arm/mach-mx5/sdram_autogating.c |  184 +++
 arch/arm/mach-mx5/serial.h           |  127 ++
 arch/arm/mach-mx5/suspend.S          |  153 ++
 arch/arm/mach-mx5/system.c           |  190 +++
 arch/arm/mach-mx5/usb.h              |  112 ++
 arch/arm/mach-mx5/usb_dr.c           |  222 +++
 arch/arm/mach-mx5/usb_h1.c           |  142 ++
 arch/arm/mach-mx5/usb_h2.c           |   90 ++
 arch/arm/mach-mx5/wfi.S              |  426 ++++++
 25 files changed, 8395 insertions(+), 104 deletions(-)
 create mode 100644 arch/arm/mach-mx5/bus_freq.c
 create mode 100644 arch/arm/mach-mx5/dma.c
 create mode 100644 arch/arm/mach-mx5/dummy_gpio.c
 create mode 100644 arch/arm/mach-mx5/iomux.c
 create mode 100644 arch/arm/mach-mx5/iomux.h
 create mode 100644 arch/arm/mach-mx5/lpmodes.c
 create mode 100644 arch/arm/mach-mx5/mx51_pins.h
 create mode 100644 arch/arm/mach-mx5/pm.c
 create mode 100644 arch/arm/mach-mx5/sdma_script_code.h
 create mode 100644 arch/arm/mach-mx5/sdram_autogating.c
 create mode 100644 arch/arm/mach-mx5/serial.h
 create mode 100644 arch/arm/mach-mx5/suspend.S
 create mode 100644 arch/arm/mach-mx5/system.c
 create mode 100644 arch/arm/mach-mx5/usb.h
 create mode 100644 arch/arm/mach-mx5/usb_dr.c
 create mode 100644 arch/arm/mach-mx5/usb_h1.c
 create mode 100644 arch/arm/mach-mx5/usb_h2.c
 create mode 100644 arch/arm/mach-mx5/wfi.S

diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
index 1576d51..ef18f8d 100644
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -15,4 +15,70 @@ config MACH_MX51_BABBAGE
 	  u-boot. This includes specific configurations for the board and its
 	  peripherals.
 
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_IMX
+	help
+	  Enable MX51 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_IMX
+	help
+	  Enable MX51 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_IMX
+	help
+	  Enable MX51 I2C3 module.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3
+        bool "MXC NFC Hardware Version 3"
+        depends on ARCH_MX51
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3_2
+        bool "MXC NFC Hardware Version 3.2"
+        depends on ARCH_MXC_HAS_NFC_V3
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3.1
+           If unsure, say N.
+
+menu "SDMA options"
+        depends on MXC_SDMA_API
+
+config SDMA_IRAM
+        bool "Use Internal RAM for SDMA transfer"
+        default n
+	help
+           Support Internal RAM as SDMA buffer or control structures
+
+config SDMA_IRAM_SIZE
+        hex "Reserved bytes of IRAM for SDMA (0x800-0x1000)"
+        range 0x800 0x1000
+        depends on SDMA_IRAM
+        default "0x1000"
+        help
+           Set the size of IRAM for SDMA. It must be a multiple of 512bytes.
+endmenu
+
+endmenu
+
 endif
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
index bf23f86..26570cd 100644
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -3,7 +3,17 @@
 #
 
 # Object file lists.
-obj-y   := cpu.o mm.o clock-mx51.o devices.o
+obj-y   := cpu.o mm.o clock-mx51.o devices.o iomux.o dma.o sdram_autogating.o bus_freq.o lpmodes.o pm.o system.o
+
+obj-y += dummy_gpio.o
 
 obj-$(CONFIG_MACH_MX51_BABBAGE) += board-mx51_babbage.o
 
+obj-$(CONFIG_CPU_V7)        += wfi.o suspend.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H1)   += usb_h1.o
+obj-$(CONFIG_USB_EHCI_ARC_H2)   += usb_h2.o
+
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+    obj-y   += usb_dr.o
+endif
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
new file mode 100644
index 0000000..d195da7
--- /dev/null
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -0,0 +1,575 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+#include "crm_regs.h"
+
+#define LP_NORMAL_CLK			133000000
+#define LP_MED_CLK			83125000
+#define LP_APM_CLK			24000000
+#define NAND_LP_APM_CLK			12000000
+#define DDR_LOW_FREQ_CLK		133000000
+#define DDR_NORMAL_CLK			200000000
+#define AXI_A_NORMAL_CLK		166250000
+#define AXI_A_CLK_NORMAL_DIV		4
+#define AXI_B_CLK_NORMAL_DIV		5
+#define AHB_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define EMI_SLOW_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define NFC_CLK_NORMAL_DIV		4
+
+static struct clk *ddr_clk;
+static struct clk *pll2;
+static struct clk *main_bus_clk;
+static struct clk *axi_a_clk;
+static struct clk *axi_b_clk;
+static struct clk *cpu_clk;
+static struct clk *ddr_hf_clk;
+static struct clk *nfc_clk;
+static struct clk *ahb_clk;
+static struct clk *vpu_clk;
+static struct clk *vpu_core_clk;
+static struct clk *emi_slow_clk;
+static struct clk *ddr_clk;
+static struct clk *ipu_clk;
+static struct clk *periph_apm_clk;
+static struct clk *lp_apm;
+static struct clk *osc;
+static struct clk *gpc_dvfs_clk;
+static struct clk *mipi_hsp_clk;
+struct regulator *lp_regulator;
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+int bus_freq_scaling_initialized;
+char *gp_reg_id = "SW1";
+char *lp_reg_id = "SW2";
+
+static struct cpu_wp *cpu_wp_tbl;
+static struct device *busfreq_dev;
+static int busfreq_suspended;
+/* True if bus_frequency is scaled not using DVFS-PER */
+int bus_freq_scaling_is_active;
+
+
+struct dvfs_wp dvfs_core_setpoint[] = {
+						{33, 8, 33, 10, 10, 0x08},
+						{26, 0, 33, 20, 10, 0x08},
+						{28, 8, 33, 20, 30, 0x08},
+						{29, 0, 33, 20, 10, 0x08},};
+
+#define DISABLE_PLL1
+
+int set_low_bus_freq(void)
+{
+	struct clk *tclk;
+	u32 reg;
+
+	if (busfreq_suspended)
+		return 0;
+
+	if (bus_freq_scaling_initialized) {
+		if (clk_get_rate(cpu_clk) != cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+			return 0;
+
+		stop_dvfs_per();
+
+		stop_sdram_autogating();
+#ifdef DISABLE_PLL1
+		tclk = clk_get(NULL, "ddr_clk");
+		clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+		/* Set CPU clock to be derived from PLL2 instead of PLL1 */
+		tclk = clk_get(NULL, "pll1_sw_clk");
+		clk_set_parent(tclk, clk_get(NULL, "pll2"));
+		clk_enable(tclk);
+
+		tclk = clk_get(NULL, "ddr_clk");
+		clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+
+		/*Change the DDR freq to 133Mhz. */
+		clk_set_rate(ddr_hf_clk,
+			     clk_round_rate(ddr_hf_clk, DDR_LOW_FREQ_CLK));
+
+		clk_enable(gpc_dvfs_clk);
+
+		/* Setup the GPC. */
+		reg = __raw_readl(MXC_GPC_VCR);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+			 MXC_GPCVCR_VCNT_MASK);
+
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+			(0 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, MXC_GPC_VCR);
+
+		reg = __raw_readl(MXC_GPC_CNTR);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, MXC_GPC_CNTR);
+
+		/* Enable DVFS-PER */
+		reg = __raw_readl(MXC_DVFSPER_PMCR0);
+		reg &= ~(MXC_DVFSPER_PMCR0_UDCS_MASK |
+				MXC_DVFSPER_PMCR0_ENABLE_MASK);
+		reg |= MXC_DVFSPER_PMCR0_ENABLE;
+		__raw_writel(reg, MXC_DVFSPER_PMCR0);
+
+		/* Set the dvfs-podf to divide by 4. */
+		reg = __raw_readl(MXC_CCM_CDCR);
+		reg &= ~MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK;
+		reg |= 3 << MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCR);
+
+		/* Setup the GPC */
+		reg = __raw_readl(MXC_GPC_VCR) & ~MXC_GPCVCR_VINC_MASK;
+		/* Set VINC to 0. */
+		reg |= 0 << MXC_GPCVCR_VINC_OFFSET;
+		__raw_writel(reg, MXC_GPC_VCR);
+
+		reg = __raw_readl(MXC_GPC_CNTR);
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, MXC_GPC_CNTR);
+		while (__raw_readl(MXC_GPC_CNTR) & MXC_GPCCNTR_STRT)
+			udelay(10);
+
+		/* Disable DVFS-PER */
+		reg = __raw_readl(MXC_DVFSPER_PMCR0);
+		reg &= ~MXC_DVFSPER_PMCR0_ENABLE;
+		__raw_writel(reg, MXC_DVFSPER_PMCR0);
+
+		/* Set the dividers to be  close to 24Mhz from 166.25MHz*/
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+				| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+				| MXC_CCM_CBCDR_AHB_PODF_MASK
+				| MXC_CCM_CBCDR_EMI_PODF_MASK
+				| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+		reg |= (6 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+				| 6 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+				| 6 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+				| 6 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+				| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCDR);
+
+		while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+			udelay(10);
+
+		low_bus_freq_mode = 1;
+		high_bus_freq_mode = 0;
+		clk_set_parent(main_bus_clk, pll2);
+	}
+	return 0;
+}
+
+int set_high_bus_freq(int high_bus_freq)
+{
+	u32 reg;
+	struct clk *tclk;
+
+	if (bus_freq_scaling_initialized) {
+		stop_sdram_autogating();
+
+		if (low_bus_freq_mode) {
+			reg = __raw_readl(MXC_CCM_CBCDR);
+			reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+					| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+					| MXC_CCM_CBCDR_AHB_PODF_MASK
+					| MXC_CCM_CBCDR_EMI_PODF_MASK
+					| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+			reg |= (3 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+					| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+			__raw_writel(reg, MXC_CCM_CBCDR);
+			while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+				udelay(10);
+
+			/* Setup the GPC. */
+			reg = __raw_readl(MXC_GPC_VCR);
+			reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+				 MXC_GPCVCR_VCNT_MASK);
+
+			reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+				(0 << MXC_GPCVCR_VCNT_OFFSET);
+			__raw_writel(reg, MXC_GPC_VCR);
+
+			reg = __raw_readl(MXC_GPC_CNTR);
+			reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+			reg |= MXC_GPCCNTR_FUPD;
+			__raw_writel(reg, MXC_GPC_CNTR);
+
+			/* Enable DVFS-PER */
+			reg = __raw_readl(MXC_DVFSPER_PMCR0);
+			reg |= MXC_DVFSPER_PMCR0_UDCS;
+			reg |= MXC_DVFSPER_PMCR0_ENABLE;
+			__raw_writel(reg, MXC_DVFSPER_PMCR0);
+
+			/* Set the dvfs-podf to divide by 1. */
+			reg = __raw_readl(MXC_CCM_CDCR);
+			reg &= ~MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK;
+			reg |= 1 << MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET;
+			__raw_writel(reg, MXC_CCM_CDCR);
+
+			/* Setup the GPC */
+			reg = __raw_readl(MXC_GPC_VCR) & ~MXC_GPCVCR_VINC_MASK;
+			/* Set VINC to 1. */
+			reg |= 1 << MXC_GPCVCR_VINC_OFFSET;
+			__raw_writel(reg, MXC_GPC_VCR);
+
+			reg = __raw_readl(MXC_GPC_CNTR);
+			reg |= MXC_GPCCNTR_STRT;
+			__raw_writel(reg, MXC_GPC_CNTR);
+			while (__raw_readl(MXC_GPC_CNTR) & MXC_GPCCNTR_STRT)
+				udelay(10);
+
+			/* Disable DVFS-PER */
+			reg = __raw_readl(MXC_DVFSPER_PMCR0);
+			reg &= ~MXC_DVFSPER_PMCR0_ENABLE;
+			__raw_writel(reg, MXC_DVFSPER_PMCR0);
+
+			low_bus_freq_mode = 0;
+			clk_set_parent(main_bus_clk, pll2);
+			clk_disable(gpc_dvfs_clk);
+#ifdef DISABLE_PLL1
+			tclk = clk_get(NULL, "ddr_clk");
+			clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+		/* Set CPU clock to be derived from PLL1 instead of PLL2 */
+			tclk = clk_get(NULL, "pll1_sw_clk");
+			clk_set_parent(tclk, clk_get(NULL, "pll1_main_clk"));
+			clk_disable(tclk);
+
+			tclk = clk_get(NULL, "ddr_clk");
+			clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+			/*Change the DDR freq to 200MHz*/
+			clk_set_rate(ddr_hf_clk,
+				    clk_round_rate(ddr_hf_clk, DDR_NORMAL_CLK));
+
+			start_dvfs_per();
+		}
+	if (bus_freq_scaling_is_active) {
+		/*
+		 * If the CPU freq is 800MHz, set the bus to the high setpoint
+		 * (133MHz) and DDR to 200MHz.
+		 */
+		if (clk_get_rate(cpu_clk) != cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+			high_bus_freq = 1;
+
+		if (((clk_get_rate(ahb_clk) == LP_MED_CLK) && lp_high_freq) ||
+							high_bus_freq) {
+			/* Set to the high setpoint. */
+			high_bus_freq_mode = 1;
+			clk_set_rate(ahb_clk,
+				clk_round_rate(ahb_clk, LP_NORMAL_CLK));
+			clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, DDR_NORMAL_CLK));
+		}
+		if (!lp_high_freq && !high_bus_freq) {
+			/* Set to the medium setpoint. */
+			high_bus_freq_mode = 0;
+			low_bus_freq_mode = 0;
+			clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, DDR_LOW_FREQ_CLK));
+			clk_set_rate(ahb_clk,
+				     clk_round_rate(ahb_clk, LP_MED_CLK));
+		}
+	}
+	start_sdram_autogating();
+	}
+	return 0;
+}
+
+int low_freq_bus_used(void)
+{
+	if ((clk_get_usecount(ipu_clk) == 0)
+	    && (clk_get_usecount(vpu_clk) == 0)
+	    && (lp_high_freq == 0)
+	    && (lp_med_freq == 0))
+		return 1;
+	else
+		return 0;
+}
+
+void setup_pll(void)
+{
+}
+
+static ssize_t bus_freq_scaling_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (bus_freq_scaling_is_active)
+		return sprintf(buf, "Bus frequency scaling is enabled\n");
+	else
+		return sprintf(buf, "Bus frequency scaling is disabled\n");
+}
+
+static ssize_t bus_freq_scaling_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	u32 reg;
+
+
+	if (strstr(buf, "1") != NULL) {
+		if (dvfs_per_active()) {
+			printk(KERN_INFO "bus frequency scaling cannot be\
+				 enabled when DVFS-PER is active\n");
+			return size;
+		}
+
+		/* Initialize DVFS-PODF to 0. */
+		reg = __raw_readl(MXC_CCM_CDCR);
+		reg &= ~MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK;
+		__raw_writel(reg, MXC_CCM_CDCR);
+		clk_set_parent(main_bus_clk, pll2);
+
+		bus_freq_scaling_is_active = 1;
+	} else if (strstr(buf, "0") != NULL) {
+		if (bus_freq_scaling_is_active)
+			set_high_bus_freq(1);
+		bus_freq_scaling_is_active = 0;
+	}
+	return size;
+}
+
+static int busfreq_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	if (low_bus_freq_mode)
+		set_high_bus_freq(1);
+	busfreq_suspended = 1;
+	return 0;
+}
+
+static int busfreq_resume(struct platform_device *pdev)
+{
+	busfreq_suspended = 0;
+	return  0;
+}
+
+static DEVICE_ATTR(enable, 0644, bus_freq_scaling_enable_show,
+			bus_freq_scaling_enable_store);
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	int err = 0;
+
+	busfreq_dev = &pdev->dev;
+
+	main_bus_clk = clk_get(NULL, "main_bus_clk");
+	if (IS_ERR(main_bus_clk)) {
+		printk(KERN_DEBUG "%s: failed to get main_bus_clk\n",
+		       __func__);
+		return PTR_ERR(main_bus_clk);
+	}
+
+	pll2 = clk_get(NULL, "pll2");
+	if (IS_ERR(pll2)) {
+		printk(KERN_DEBUG "%s: failed to get pll2\n", __func__);
+		return PTR_ERR(pll2);
+	}
+
+	axi_a_clk = clk_get(NULL, "axi_a_clk");
+	if (IS_ERR(axi_a_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_a_clk\n",
+		       __func__);
+		return PTR_ERR(axi_a_clk);
+	}
+
+	axi_b_clk = clk_get(NULL, "axi_b_clk");
+	if (IS_ERR(axi_b_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_b_clk\n",
+		       __func__);
+		return PTR_ERR(axi_b_clk);
+	}
+
+	ddr_hf_clk = clk_get(NULL, "ddr_hf_clk");
+	if (IS_ERR(ddr_hf_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_hf_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_hf_clk);
+	}
+
+	emi_slow_clk = clk_get(NULL, "emi_slow_clk");
+	if (IS_ERR(emi_slow_clk)) {
+		printk(KERN_DEBUG "%s: failed to get emi_slow_clk\n",
+		       __func__);
+		return PTR_ERR(emi_slow_clk);
+	}
+
+	nfc_clk = clk_get(NULL, "nfc_clk");
+	if (IS_ERR(nfc_clk)) {
+		printk(KERN_DEBUG "%s: failed to get nfc_clk\n",
+		       __func__);
+		return PTR_ERR(nfc_clk);
+	}
+
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	if (IS_ERR(ahb_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ahb_clk\n",
+		       __func__);
+		return PTR_ERR(ahb_clk);
+	}
+
+	vpu_core_clk = clk_get(NULL, "vpu_core_clk");
+	if (IS_ERR(vpu_core_clk)) {
+		printk(KERN_DEBUG "%s: failed to get vpu_core_clk\n",
+		       __func__);
+		return PTR_ERR(vpu_core_clk);
+	}
+
+	ddr_clk = clk_get(NULL, "ddr_clk");
+	if (IS_ERR(ddr_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_clk);
+	}
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n",
+		       __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	ipu_clk = clk_get(NULL, "ipu_clk");
+	if (IS_ERR(ipu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ipu_clk\n",
+		       __func__);
+		return PTR_ERR(ipu_clk);
+	}
+
+	mipi_hsp_clk = clk_get(NULL, "mipi_hsp_clk");
+	if (IS_ERR(mipi_hsp_clk)) {
+		printk(KERN_DEBUG "%s: failed to get mipi_hsp_clk\n",
+		       __func__);
+		return PTR_ERR(mipi_hsp_clk);
+	}
+
+	vpu_clk = clk_get(NULL, "vpu_clk");
+	if (IS_ERR(vpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get vpu_clk\n",
+		       __func__);
+		return PTR_ERR(vpu_clk);
+	}
+
+	periph_apm_clk = clk_get(NULL, "periph_apm_clk");
+	if (IS_ERR(periph_apm_clk)) {
+		printk(KERN_DEBUG "%s: failed to get periph_apm_clk\n",
+		       __func__);
+		return PTR_ERR(periph_apm_clk);
+	}
+
+	lp_apm = clk_get(NULL, "lp_apm");
+	if (IS_ERR(lp_apm)) {
+		printk(KERN_DEBUG "%s: failed to get lp_apm\n",
+		       __func__);
+		return PTR_ERR(lp_apm);
+	}
+
+	osc = clk_get(NULL, "osc");
+	if (IS_ERR(osc)) {
+		printk(KERN_DEBUG "%s: failed to get osc\n", __func__);
+		return PTR_ERR(osc);
+	}
+
+	gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	if (IS_ERR(gpc_dvfs_clk)) {
+		printk(KERN_DEBUG "%s: failed to get gpc_dvfs_clk\n", __func__);
+		return PTR_ERR(gpc_dvfs_clk);
+	}
+
+	err = sysfs_create_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for BUSFREQ");
+		return err;
+	}
+
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 1;
+	bus_freq_scaling_is_active = 0;
+	bus_freq_scaling_initialized = 1;
+
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		},
+	.probe = busfreq_probe,
+	.suspend = busfreq_suspend,
+	.resume = busfreq_resume,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	sysfs_remove_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+	bus_freq_scaling_initialized = 0;
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/clock-mx51.c b/arch/arm/mach-mx5/clock-mx51.c
index 1ee6ce4..ff01dd8 100644
--- a/arch/arm/mach-mx5/clock-mx51.c
+++ b/arch/arm/mach-mx5/clock-mx51.c
@@ -10,6 +10,7 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+#include <linux/err.h>
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
@@ -21,13 +22,22 @@
 #include <mach/hardware.h>
 #include <mach/common.h>
 #include <mach/clock.h>
+#include <mach/sdram_autogating.h>
+#include <mach/mxc_dvfs.h>
 
 #include "crm_regs.h"
 
+static unsigned long pll_base[] = {
+	(unsigned long)MX51_DPLL1_BASE,
+	(unsigned long)MX51_DPLL2_BASE,
+	(unsigned long)MX51_DPLL3_BASE,
+};
+
 /* External clock values passed-in by the board code */
 static unsigned long external_high_reference, external_low_reference;
 static unsigned long oscillator_reference, ckih2_reference;
 
+static struct clk ckil_clk;
 static struct clk osc_clk;
 static struct clk pll1_main_clk;
 static struct clk pll1_sw_clk;
@@ -37,9 +47,59 @@ static struct clk lp_apm_clk;
 static struct clk periph_apm_clk;
 static struct clk ahb_clk;
 static struct clk ipg_clk;
+static struct clk emi_fast_clk;
+static struct clk emi_slow_clk;
+static struct clk ddr_clk;
+static struct clk tve_clk;
+static struct clk vpu_clk[];
+static struct clk spba_clk;
+static struct clk ssi1_clk;
+static struct clk ssi2_clk;
+
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+
+int cpu_wp_nr;
+int lp_high_freq;
+int lp_med_freq;
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+
+static int cpu_clk_set_wp(int wp);
+struct cpu_wp *(*get_cpu_wp)(int *wp);
+void (*set_num_cpu_wp)(int num);
 
 #define MAX_DPLL_WAIT_TRIES	1000 /* 1000 * udelay(1) = 1ms */
 
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
 static int _clk_ccgr_enable(struct clk *clk)
 {
 	u32 reg;
@@ -48,6 +108,22 @@ static int _clk_ccgr_enable(struct clk *clk)
 	reg |= MXC_CCM_CCGRx_MOD_ON << clk->enable_shift;
 	__raw_writel(reg, clk->enable_reg);
 
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static int _clk_ccgr_enable_inrun(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
 	return 0;
 }
 
@@ -55,9 +131,13 @@ static void _clk_ccgr_disable(struct clk *clk)
 {
 	u32 reg;
 	reg = __raw_readl(clk->enable_reg);
-	reg &= ~(MXC_CCM_CCGRx_MOD_OFF << clk->enable_shift);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
 	__raw_writel(reg, clk->enable_reg);
 
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
 }
 
 static void _clk_ccgr_disable_inwait(struct clk *clk)
@@ -90,6 +170,67 @@ static inline u32 _get_mux(struct clk *parent, struct clk *m0,
 	return -EINVAL;
 }
 
+/*
+ * For the ddr muxed input clock
+ */
+static inline u32 _get_mux_ddr(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3,
+			       struct clk *m4)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else
+		BUG();
+
+	return 0;
+}
+
+static unsigned long get_high_reference_clock_rate(struct clk *clk)
+{
+	return external_high_reference;
+}
+
+static unsigned long get_low_reference_clock_rate(struct clk *clk)
+{
+	return external_low_reference;
+}
+
+static unsigned long get_oscillator_reference_clock_rate(struct clk *clk)
+{
+	return oscillator_reference;
+}
+
+static unsigned long get_ckih2_reference_clock_rate(struct clk *clk)
+{
+	return ckih2_reference;
+}
+
+/* External high frequency clock */
+static struct clk ckih_clk = {
+	.get_rate = get_high_reference_clock_rate,
+};
+
+static struct clk ckih2_clk = {
+	.get_rate = get_ckih2_reference_clock_rate,
+};
+
+static struct clk osc_clk = {
+	.get_rate = get_oscillator_reference_clock_rate,
+};
+
+/* External low frequency (32kHz) clock */
+static struct clk ckil_clk = {
+	.get_rate = get_low_reference_clock_rate,
+};
+
 static inline void __iomem *_get_pll_base(struct clk *pll)
 {
 	if (pll == &pll1_main_clk)
@@ -315,6 +456,82 @@ static int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+static struct clk pll1_main_clk = {
+	.parent = &osc_clk,
+	.get_rate = clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+/* Clock tree block diagram (WIP):
+ *	CCM: Clock Controller Module
+ *
+ * PLL output -> |
+ *               | CCM Switcher -> CCM_CLK_ROOT_GEN ->
+ * PLL bypass -> |
+ *
+ */
+
+/* PLL1 SW supplies to ARM core */
+static struct clk pll1_sw_clk = {
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.get_rate = clk_pll1_sw_get_rate,
+};
+
+/* PLL2 SW supplies to AXI/AHB/IP buses */
+static struct clk pll2_sw_clk = {
+	.parent = &osc_clk,
+	.get_rate = clk_pll_get_rate,
+	.set_rate = _clk_pll_set_rate,
+	.set_parent = _clk_pll2_sw_set_parent,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+/* PLL3 SW supplies to serial clocks like USB, SSI, etc. */
+static struct clk pll3_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+static unsigned long _fpm_getrate(struct clk *clk)
+{
+	unsigned long ret;
+
+	ret = clk_get_rate(&ckil_clk) * 512;
+	if ((__raw_readl(MXC_CCM_CCR) & MXC_CCM_CCR_FPM_MULT_MASK) != 0)
+		ret *= 2;
+
+	return ret;
+}
+
+static int _fpm_enable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg |= MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+	return 0;
+}
+
+static void _fpm_disable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg &= ~MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+}
+
+static struct clk fpm_clk = {
+	.parent = &ckil_clk,
+	.get_rate = _fpm_getrate,
+	.enable = _fpm_enable,
+	.disable = _fpm_disable,
+	.flags = RATE_PROPAGATES,
+};
+
 static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg;
@@ -329,6 +546,12 @@ static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+/* Low-power Audio Playback Mode clock */
+static struct clk lp_apm_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+};
+
 static unsigned long clk_arm_get_rate(struct clk *clk)
 {
 	u32 cacrr, div;
@@ -341,6 +564,46 @@ static unsigned long clk_arm_get_rate(struct clk *clk)
 	return parent_rate / div;
 }
 
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_wp_nr)
+		return -EINVAL;
+
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_wp_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+static struct clk cpu_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = clk_arm_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
 static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg, mux;
@@ -369,6 +632,23 @@ static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+static struct clk periph_apm_clk = {
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_periph_apm_set_parent,
+};
+
+static unsigned long _clk_main_bus_getrate(struct clk *clk)
+{
+	u32 div = 0;
+	unsigned long ret;
+
+	if (dvfs_per_divider_active() || low_bus_freq_mode)
+		div  = (__raw_readl(MXC_CCM_CDCR) & 0x3);
+	ret = clk_get_rate(clk->parent) / (div + 1);
+
+	return ret;
+}
+
 static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg;
@@ -389,6 +669,7 @@ static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
 
 static struct clk main_bus_clk = {
 	.parent = &pll2_sw_clk,
+	.get_rate = _clk_main_bus_getrate,
 	.set_parent = _clk_main_bus_set_parent,
 };
 
@@ -405,7 +686,6 @@ static unsigned long clk_ahb_get_rate(struct clk *clk)
 	return parent_rate / div;
 }
 
-
 static int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)
 {
 	u32 reg, div;
@@ -456,6 +736,30 @@ static unsigned long _clk_ahb_round_rate(struct clk *clk,
 	return parent_rate / div;
 }
 
+static struct clk ahb_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = clk_ahb_get_rate,
+	.set_rate = _clk_ahb_set_rate,
+	.round_rate = _clk_ahb_round_rate,
+};
+
+static struct clk ahbmux2_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.disable = _clk_ccgr_disable_inwait,
+};
+
+static struct clk emi_intr_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable_inwait,
+};
 
 static int _clk_max_enable(struct clk *clk)
 {
@@ -483,6 +787,14 @@ static void _clk_max_disable(struct clk *clk)
 	__raw_writel(reg, MXC_CCM_CLPCR);
 }
 
+static struct clk ahb_max_clk = {
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
 static unsigned long clk_ipg_get_rate(struct clk *clk)
 {
 	u32 reg, div;
@@ -497,6 +809,12 @@ static unsigned long clk_ipg_get_rate(struct clk *clk)
 	return parent_rate / div;
 }
 
+/* Main IP interface clock for access to registers */
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = clk_ipg_get_rate,
+};
+
 static unsigned long clk_ipg_per_get_rate(struct clk *clk)
 {
 	u32 reg, prediv1, prediv2, podf;
@@ -541,6 +859,12 @@ static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+static struct clk ipg_perclk = {
+	.parent = &lp_apm_clk,
+	.get_rate = clk_ipg_per_get_rate,
+	.set_parent = _clk_ipg_per_set_parent,
+};
+
 static unsigned long clk_uart_get_rate(struct clk *clk)
 {
 	u32 reg, prediv, podf;
@@ -570,156 +894,1808 @@ static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static unsigned long get_high_reference_clock_rate(struct clk *clk)
+static struct clk uart_root_clk = {
+	.parent = &pll2_sw_clk,
+	.get_rate = clk_uart_get_rate,
+	.set_parent = _clk_uart_set_parent,
+};
+
+static struct clk aips_tz1_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable_inwait,
+};
+
+static struct clk gpt_32k_clk = {
+	.id = 0,
+	.parent = &ckil_clk,
+};
+
+static struct clk kpp_clk = {
+	.id = 0,
+};
+
+static unsigned long _clk_axi_a_getrate(struct clk *clk)
 {
-	return external_high_reference;
+	u32 reg, div;
+	unsigned long ret;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / div;
+	return ret;
 }
 
-static unsigned long get_low_reference_clock_rate(struct clk *clk)
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
 {
-	return external_low_reference;
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_axi_a_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
 }
 
-static unsigned long get_oscillator_reference_clock_rate(struct clk *clk)
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
 {
-	return oscillator_reference;
+	u32 div;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
 }
 
-static unsigned long get_ckih2_reference_clock_rate(struct clk *clk)
+
+static struct clk axi_a_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_a_getrate,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+
+static unsigned long _clk_axi_b_getrate(struct clk *clk)
 {
-	return ckih2_reference;
+	u32 reg, div;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / div;
+
+	return ret;
 }
 
-/* External high frequency clock */
-static struct clk ckih_clk = {
-	.get_rate = get_high_reference_clock_rate,
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_axi_b_set_rate failed\n");
+	}
+
+	emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
+}
+
+
+static struct clk axi_b_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_b_getrate,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+	.flags = RATE_PROPAGATES,
 };
 
-static struct clk ckih2_clk = {
-	.get_rate = get_ckih2_reference_clock_rate,
+
+static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk)
+		reg |= MXC_CCM_CBCDR_EMI_CLK_SEL;
+	else if (parent == &main_bus_clk)
+		reg &= ~MXC_CCM_CBCDR_EMI_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_getrate(struct clk *clk)
+{
+	u32 reg, div;
+	unsigned long ret;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / div;
+
+	return ret;
+}
+
+static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_EMI_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_emi_slow_set_rate failed\n");
+	}
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
+}
+
+
+static struct clk emi_slow_clk = {
+	.parent = &main_bus_clk,
+	.set_parent = _clk_emi_slow_set_parent,
+	.get_rate = _clk_emi_slow_getrate,
+	.set_rate = _clk_emi_slow_set_rate,
+	.round_rate = _clk_emi_slow_round_rate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_ccgr_disable_inwait,
+	.flags = RATE_PROPAGATES,
 };
 
-static struct clk osc_clk = {
-	.get_rate = get_oscillator_reference_clock_rate,
+static struct clk emi_fast_clk = {
+	.parent = &ddr_clk,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_ccgr_disable_inwait,
 };
 
-/* External low frequency (32kHz) clock */
-static struct clk ckil_clk = {
-	.get_rate = get_low_reference_clock_rate,
+static struct clk ahbmux1_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_ccgr_disable_inwait,
 };
 
-static struct clk pll1_main_clk = {
-	.parent = &osc_clk,
-	.get_rate = clk_pll_get_rate,
-	.enable = _clk_pll_enable,
-	.disable = _clk_pll_disable,
+
+static unsigned long _clk_hsi2c_serial_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR3);
+	prediv = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+/* SDMA */
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_ccgr_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_ccgr_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static struct clk sdma_ahb_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_sdma_enable,
+	.disable = _clk_sdma_disable,
+};
+static struct clk sdma_ipg_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+#ifdef CONFIG_SDMA_IRAM
+	 .secondary = &emi_intr_clk,
+#endif
 };
 
-/* Clock tree block diagram (WIP):
- * 	CCM: Clock Controller Module
- *
- * PLL output -> |
- *               | CCM Switcher -> CCM_CLK_ROOT_GEN ->
- * PLL bypass -> |
- *
- */
+/* DDR */
+static unsigned long _clk_ddr_hf_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
 
-/* PLL1 SW supplies to ARM core */
-static struct clk pll1_sw_clk = {
-	.parent = &pll1_main_clk,
-	.set_parent = _clk_pll1_sw_set_parent,
-	.get_rate = clk_pll1_sw_get_rate,
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ddr_hf_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_DDR_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_DDR_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_DDR_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("clk_ddr_hf_set_rate failed\n");
+	}
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_ddr_hf_getrate(struct clk *clk)
+{
+	u32 reg, div;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_DDR_PODF_MASK) >>
+	       MXC_CCM_CBCDR_DDR_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / div;
+	return ret;
+}
+
+static struct clk ddr_hf_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_ddr_hf_getrate,
+	.round_rate = _clk_ddr_hf_round_rate,
+	.set_rate = _clk_ddr_hf_set_rate,
 };
 
-/* PLL2 SW supplies to AXI/AHB/IP buses */
-static struct clk pll2_sw_clk = {
-	.parent = &osc_clk,
-	.get_rate = clk_pll_get_rate,
-	.set_rate = _clk_pll_set_rate,
-	.set_parent = _clk_pll2_sw_set_parent,
-	.enable = _clk_pll_enable,
-	.disable = _clk_pll_disable,
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, reg2, mux;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	reg2 = __raw_readl(MXC_CCM_CBCDR);
+	mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk,
+			   &ahb_clk, &ddr_hf_clk);
+	if (mux < 4) {
+		reg = (reg & ~MXC_CCM_CBCMR_DDR_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCMR);
+		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL);
+	} else {
+		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL) |
+			(MXC_CCM_CBCDR_DDR_HF_SEL);
+	}
+	__raw_writel(reg2, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+		MXC_CCM_CDHIPR_DDR_HF_CLK_SEL_BUSY){
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_ddr_set_parent failed\n");
+	}
+	return 0;
+}
+
+static struct clk ddr_clk = {
+	.parent = &ddr_hf_clk,
+	.set_parent = _clk_ddr_set_parent,
 };
 
-/* PLL3 SW supplies to serial clocks like USB, SSI, etc. */
-static struct clk pll3_sw_clk = {
-	.parent = &osc_clk,
-	.set_rate = _clk_pll_set_rate,
-	.get_rate = clk_pll_get_rate,
-	.enable = _clk_pll_enable,
-	.disable = _clk_pll_disable,
+/* usb */
+static unsigned long clk_usb_get_rate(struct clk *clk)
+{
+	return 60000000;
+}
+
+
+static struct clk usb_clk = {
+	.get_rate = clk_usb_get_rate,
 };
 
-/* Low-power Audio Playback Mode clock */
-static struct clk lp_apm_clk = {
-	.parent = &osc_clk,
-	.set_parent = _clk_lp_apm_set_parent,
+
+static unsigned long _clk_ssi1_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_ssi2_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_usboh3_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_usb_phy_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		prediv = ((reg & MXC_CCM_CDCDR_USB_PHY_PRED_MASK) >>
+			  MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_USB_PHY_PODF_MASK) >>
+			MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET) + 1;
+
+		ret = clk_get_rate(clk->parent) / (prediv * podf);
+	} else
+		ret = clk_get_rate(clk->parent);
+	return ret;
+}
+
+static unsigned long _clk_esdhc1_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_esdhc2_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static struct clk tmax2_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_ccgr_disable,
 };
 
-static struct clk periph_apm_clk = {
-	.parent = &pll1_sw_clk,
-	.set_parent = _clk_periph_apm_set_parent,
+static struct clk tmax3_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_ccgr_disable,
 };
 
-static struct clk cpu_clk = {
-	.parent = &pll1_sw_clk,
-	.get_rate = clk_arm_get_rate,
+static int _clk_usboh3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk usboh3_clk[] = {
+	{
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_usboh3_set_parent,
+	 .get_rate = _clk_usboh3_getrate,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	 .disable = _clk_ccgr_disable,
+	 .secondary = &usboh3_clk[1],
+	 .flags = AHB_MED_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .parent = &tmax2_clk,
+	 .secondary = &emi_fast_clk,
+	 },
+};
+static struct clk usb_ahb_clk = {
+	 .parent = &ipg_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .disable = _clk_ccgr_disable,
 };
 
-static struct clk ahb_clk = {
-	.parent = &main_bus_clk,
-	.get_rate = clk_ahb_get_rate,
-	.set_rate = _clk_ahb_set_rate,
-	.round_rate = _clk_ahb_round_rate,
+static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &osc_clk)
+		reg &= ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else if (parent == &pll3_sw_clk)
+		reg |= MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk usb_phy_clk = {
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_getrate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_ccgr_disable,
 };
 
-/* Main IP interface clock for access to registers */
-static struct clk ipg_clk = {
+/* CSI */
+static int _clk_csi0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi0_getrate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / (pred * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_csi0_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk_get_rate(clk->parent) / rate;
+	if (clk_get_rate(clk->parent) % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk_get_rate(clk->parent) / (pre * post);
+}
+
+static int _clk_csi0_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk_get_rate(clk->parent) / rate;
+
+	if ((clk_get_rate(clk->parent) / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi0_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi0_set_parent,
+	.get_rate = _clk_csi0_getrate,
+	.round_rate = _clk_csi0_round_rate,
+	.set_rate = _clk_csi0_set_rate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_ccgr_disable,
+};
+
+static int _clk_csi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi1_getrate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / (pred * podf);
+
+	return ret;
+}
+
+static unsigned long _clk_csi1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk_get_rate(clk->parent) / rate;
+	if (clk_get_rate(clk->parent) % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk_get_rate(clk->parent) / (pre * post);
+}
+
+static int _clk_csi1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk_get_rate(clk->parent) / rate;
+
+	if ((clk_get_rate(clk->parent) / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi1_set_parent,
+	.get_rate = _clk_csi1_getrate,
+	.round_rate = _clk_csi1_round_rate,
+	.set_rate = _clk_csi1_set_rate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_ccgr_disable,
+};
+
+/* IPU */
+static int _clk_ipu_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_ccgr_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_IPU_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* Handshake with IPU when LPM is entered as its enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	start_sdram_autogating();
+
+	return 0;
+}
+
+static void _clk_ipu_disable(struct clk *clk)
+{
+	u32 reg;
+
+	if (sdram_autogating_active())
+		stop_sdram_autogating();
+
+	_clk_ccgr_disable(clk);
+
+	/* No handshake with IPU whe dividers are changed
+	 * as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* No handshake with IPU when LPM is entered as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static int _clk_ipu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &ahb_clk,
+		       &emi_slow_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+
+static struct clk ipu_clk[] = {
+	{
+	.id = 0,
 	.parent = &ahb_clk,
-	.get_rate = clk_ipg_get_rate,
+	.secondary = &ipu_clk[1],
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.enable = _clk_ipu_enable,
+	.disable = _clk_ipu_disable,
+	.set_parent = _clk_ipu_set_parent,
+	 .flags = CPU_FREQ_TRIG_UPDATE | AHB_MED_SET_POINT | RATE_PROPAGATES,
+	},
+	{
+	 .parent = &emi_fast_clk,
+	 .secondary = &ahbmux1_clk,
+	}
 };
 
-static struct clk ipg_perclk = {
-	.parent = &lp_apm_clk,
-	.get_rate = clk_ipg_per_get_rate,
-	.set_parent = _clk_ipg_per_set_parent,
+static int _clk_ipu_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg &= ~MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id);
+	if (parent == &pll3_sw_clk)
+		;
+	else if (parent == &osc_clk)
+		reg |= 1 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &ckih_clk)
+		reg |= 2 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &tve_clk)
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else		/* Assume any other clock is external clock pin */
+		reg |= 4 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_ipu_di_getrate(struct clk *clk)
+{
+	u32 reg, div, mux;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = (reg & MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id)) >>
+		MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	if (mux == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_DI_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / div;
+	} else if (mux == 3) {
+		ret = clk_get_rate(clk->parent) / 8;
+	} else {
+		ret = clk_get_rate(clk->parent);
+	}
+
+	return ret;
+}
+
+static int _clk_ipu_di_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_DI_CLK_PRED_MASK;
+	reg |= (div - 1) << MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	return 0;
+}
+
+static unsigned long _clk_ipu_di_round_rate(struct clk *clk,
+					    unsigned long rate)
+{
+	u32 div;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk ipu_di_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.get_rate = _clk_ipu_di_getrate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable,
+	.flags = RATE_PROPAGATES,
+	},
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.get_rate = _clk_ipu_di_getrate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable,
+	.flags = RATE_PROPAGATES,
+	},
 };
 
-static struct clk uart_root_clk = {
+
+/* MIPI */
+static int _clk_hsc_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_ccgr_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_hsc_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_ccgr_disable(clk);
+	/* No handshake with HSC as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static struct clk mipi_esc_clk = {
 	.parent = &pll2_sw_clk,
-	.get_rate = clk_uart_get_rate,
-	.set_parent = _clk_uart_set_parent,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
 };
 
-static struct clk ahb_max_clk = {
-	.parent = &ahb_clk,
-	.enable_reg = MXC_CCM_CCGR0,
+static struct clk mipi_hsc2_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.secondary = &mipi_esc_clk,
+};
+
+static struct clk mipi_hsc1_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.secondary = &mipi_hsc2_clk,
+};
+
+static struct clk mipi_hsp_clk = {
+	.parent = &ipu_clk[0],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.enable = _clk_hsc_enable,
+	.disable = _clk_hsc_disable,
+	.secondary = &mipi_hsc1_clk,
+};
+/* NFC */
+static unsigned long _clk_nfc_getrate(struct clk *clk)
+{
+	u32 reg, div;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_NFC_PODF_MASK) >>
+	       MXC_CCM_CBCDR_NFC_PODF_OFFSET) + 1;
+	ret = clk_get_rate(clk->parent) / div;
+
+	return ret;
+}
+
+static unsigned long _clk_nfc_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	/*
+	 * Compute the divider we'd have to use to reach the target rate.
+	 */
+
+	div = clk_get_rate(clk->parent) / rate;
+
+	/*
+	 * If there's a remainder after the division, then we have to increment
+	 * the divider. There are two reasons for this:
+	 *
+	 * 1) The frequency we round to must be LESS THAN OR EQUAL to the
+	 *    target. We aren't allowed to round to a frequency that is higher
+	 *    than the target.
+	 *
+	 * 2) This also catches the case where target rate is less than the
+	 *    parent rate, which implies a divider of zero. We can't allow a
+	 *    divider of zero.
+	 */
+
+	if (clk_get_rate(clk->parent) % rate)
+		div++;
+
+	/*
+	 * The divider for this clock is 3 bits wide, so we can't possibly
+	 * divide the parent by more than eight.
+	 */
+
+	if (div > 8)
+		return -EINVAL;
+
+	return clk_get_rate(clk->parent) / div;
+
+}
+
+static int _clk_nfc_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_NFC_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_NFC_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY){
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_nfc_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk emi_enfc_clk = {
+	.parent = &emi_slow_clk,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.disable = _clk_ccgr_disable_inwait,
+	.get_rate = _clk_nfc_getrate,
+	.round_rate = _clk_nfc_round_rate,
+	.set_rate = _clk_nfc_set_rate,
+};
+
+/* TVE */
+
+static int _clk_tve_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+
+	if (parent == &pll3_sw_clk) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_CLK_SEL);
+	} else if (parent == &osc_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg &= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else if (parent == &ckih_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg |= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static unsigned long _clk_tve_getrate(struct clk *clk)
+{
+	u32 reg, div;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_TVE_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / div;
+	} else {
+		ret = clk_get_rate(clk->parent);
+	}
+	return ret;
+}
+
+static unsigned long _clk_tve_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+		return -EINVAL;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_tve_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+		return -EINVAL;
+
+	div = clk_get_rate(clk->parent) / rate;
+	if (div == 0)
+		div++;
+	if (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	div--;
+	reg = __raw_readl(MXC_CCM_CDCDR) & ~MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+	reg |= div << MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	return 0;
+}
+
+static int _clk_tve_enable(struct clk *clk)
+{
+	_clk_ccgr_enable(clk);
+	if (ipu_di_clk[1].usecount++ == 0 && ipu_di_clk[1].enable)
+		ipu_di_clk[1].enable(&ipu_di_clk[1]);
+
+	return 0;
+}
+
+static void _clk_tve_disable(struct clk *clk)
+{
+	_clk_ccgr_disable(clk);
+	if (--ipu_di_clk[1].usecount == 0 && ipu_di_clk[1].disable)
+		ipu_di_clk[1].disable(&ipu_di_clk[1]);
+
+}
+
+static struct clk tve_clk = {
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_tve_set_parent,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.get_rate = _clk_tve_getrate,
+	.round_rate = _clk_tve_round_rate,
+	.set_rate = _clk_tve_set_rate,
+	.enable = _clk_tve_enable,
+	.disable = _clk_tve_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+/* VPU */
+static int _clk_vpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	/* Set VPU's parent to be axi_a or ahb when its enabled. */
+	return _clk_ccgr_enable(clk);
+
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	_clk_ccgr_disable(clk);
+}
+
+static struct clk vpu_clk[] = {
+	{
+	 .id = 0,
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_ccgr_disable,
+	 .secondary = &vpu_clk[1],
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_vpu_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_vpu_disable,
+	 .secondary = &vpu_clk[2],
+	 },
+	{
+	 .parent = &emi_fast_clk,
+#ifdef CONFIG_MXC_VPU_IRAM
+	 .secondary = &emi_intr_clk,
+#endif
+	 }
+};
+
+/* CSPI */
+static unsigned long _clk_cspi_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+	return ret;
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.parent = &pll3_sw_clk,
+	.get_rate = _clk_cspi_getrate,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_ccgr_enable,
+	 .disable = _clk_ccgr_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_ccgr_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_ccgr_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	 .enable = _clk_ccgr_enable,
+	 .disable = _clk_ccgr_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_ccgr_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_ccgr_disable,
+	 },
+};
+
+static struct clk cspi3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &cspi_main_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .enable = _clk_ccgr_enable,
+	 .disable = _clk_ccgr_disable,
+	 .secondary = &cspi3_clk[1],
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 },
+};
+
+/* SPDIF */
+static int _clk_spdif_xtal_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &osc_clk, &ckih_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk spdif_xtal_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_spdif_xtal_set_parent,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.disable = _clk_ccgr_disable,
+};
+
+static int _clk_spdif0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF0_COM;
+	if (parent != &ssi1_clk) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF0_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif0_getrate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	unsigned long ret;
+	if (clk->parent == &ssi1_clk) {
+		ret = clk_get_rate(clk->parent);
+	} else {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / (pred * podf);
+	}
+	return ret;
+}
+
+static struct clk spdif0_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif0_set_parent,
+	.get_rate = _clk_spdif0_getrate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.disable = _clk_ccgr_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_ccgr_disable,
+	 },
+};
+
+static int _clk_spdif1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF1_COM;
+	if (parent != &ssi2_clk) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF1_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif1_getrate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	u32 ret;
+
+	if (clk->parent == &ssi2_clk) {
+		ret = clk_get_rate(clk->parent);
+	} else {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / (pred * podf);
+	}
+	return ret;
+}
+
+static struct clk spdif1_clk[] = {
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif1_set_parent,
+	.get_rate = _clk_spdif1_getrate,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
 	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
-	.enable = _clk_max_enable,
-	.disable = _clk_max_disable,
+	.disable = _clk_ccgr_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_ccgr_disable,
+	 },
 };
 
-static struct clk aips_tz1_clk = {
-	.parent = &ahb_clk,
-	.secondary = &ahb_max_clk,
-	.enable_reg = MXC_CCM_CCGR0,
+/* DVFS */
+static struct clk gpc_dvfs_clk = {
+	.parent = &aips_tz1_clk,
+	.enable_reg = MXC_CCM_CCGR5,
 	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
 	.enable = _clk_ccgr_enable,
-	.disable = _clk_ccgr_disable_inwait,
+	.disable = _clk_ccgr_disable,
 };
 
-static struct clk aips_tz2_clk = {
-	.parent = &ahb_clk,
-	.secondary = &ahb_max_clk,
+/* GPU */
+static int _clk_gpu3d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu3d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu3d_set_parent,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_ccgr_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_ccgr_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_ccgr_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+/* SSI */
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static unsigned long _clk_ssi_ext1_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 ret;
+
+	ret = clk_get_rate(clk->parent);
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / (prediv * podf);
+	}
+	return ret;
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.get_rate = _clk_ssi_ext1_getrate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable,
+};
+
+static unsigned long _clk_ssi_ext2_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 ret;
+
+	ret = clk_get_rate(clk->parent);
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		ret = clk_get_rate(clk->parent) / (prediv * podf);
+	}
+	return ret;
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.get_rate = _clk_ssi_ext2_getrate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable,
+};
+
+/* arm axi */
+static int _clk_arm_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+/* uart main */
+static unsigned long _clk_uart_getrate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	unsigned long ret;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	ret = clk_get_rate(clk->parent) / (prediv * podf);
+
+	return ret;
+}
+
+static struct clk uart_main_clk = {
+	.parent = &pll2_sw_clk,
+	.get_rate = _clk_uart_getrate,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk arm_axi_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_arm_axi_set_parent,
+	.enable = _clk_ccgr_enable,
 	.enable_reg = MXC_CCM_CCGR0,
-	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_ccgr_disable,
+};
+
+/* SECURITY */
+static struct clk tmax1_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_ccgr_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_ccgr_disable,
+	 };
+
+
+static struct clk sahara_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &sahara_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
 	.enable = _clk_ccgr_enable,
-	.disable = _clk_ccgr_disable_inwait,
+	.disable = _clk_ccgr_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
 };
 
-static struct clk gpt_32k_clk = {
-	.id = 0,
-	.parent = &ckil_clk,
+static struct clk scc_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &scc_clk[1],
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_ccgr_enable,
+	.disable = _clk_ccgr_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
 };
 
 #define DEFINE_CLOCK(name, i, er, es, gr, sr, p, s)	\
@@ -755,16 +2731,52 @@ DEFINE_CLOCK(uart2_ipg_clk, 1, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG5_OFFSET,
 	NULL,  NULL, &ipg_clk, &aips_tz1_clk);
 DEFINE_CLOCK(uart3_ipg_clk, 2, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG7_OFFSET,
 	NULL,  NULL, &ipg_clk, &spba_clk);
-
-/* GPT */
-DEFINE_CLOCK(gpt_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG9_OFFSET,
+DEFINE_CLOCK(i2c1_clk, 0, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG9_OFFSET,
+	NULL,  NULL, &ipg_perclk, NULL);
+DEFINE_CLOCK(i2c2_clk, 1, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG10_OFFSET,
+	NULL,  NULL, &ipg_perclk, NULL);
+DEFINE_CLOCK(hsi2c_clk, 0, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG12_OFFSET,
 	NULL,  NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(hsi2c_serial_clk, 0, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG11_OFFSET,
+	_clk_hsi2c_serial_getrate,  NULL, &pll3_sw_clk, &spba_clk);
+/* GPT */
 DEFINE_CLOCK(gpt_ipg_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG10_OFFSET,
 	NULL,  NULL, &ipg_clk, NULL);
-
+DEFINE_CLOCK(gpt_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG9_OFFSET,
+	NULL,  NULL, &ipg_clk, &gpt_ipg_clk);
+DEFINE_CLOCK(clk_rtc_clk, 0, MXC_CCM_CCGR4, MXC_CCM_CCGRx_CG14_OFFSET,
+	NULL,  NULL, &ckil_clk, &ipg_clk);
+DEFINE_CLOCK(iim_clk, 0, MXC_CCM_CCGR0, MXC_CCM_CCGRx_CG15_OFFSET,
+	NULL,  NULL, &ipg_clk, &aips_tz2_clk);
+/* One Wire */
+DEFINE_CLOCK(owire_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG11_OFFSET,
+	NULL,  NULL, &ipg_perclk, NULL);
 /* FEC */
 DEFINE_CLOCK(fec_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG12_OFFSET,
 	NULL,  NULL, &ipg_clk, NULL);
+/* USB UTMI */
+DEFINE_CLOCK(usb_utmi_clk, 0, MXC_CCM_CSCMR1,
+	     MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET, NULL,  NULL,
+	     &pll3_sw_clk, NULL);
+/* esdhci */
+DEFINE_CLOCK(esdhc1_ipg_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG0_OFFSET,
+	NULL,  NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(esdhc1_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG1_OFFSET,
+	_clk_esdhc1_getrate,  NULL, &pll3_sw_clk, &esdhc1_ipg_clk);
+DEFINE_CLOCK(esdhc2_ipg_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG2_OFFSET,
+	NULL,  NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(esdhc2_clk, 1, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG3_OFFSET,
+	_clk_esdhc2_getrate,  NULL, &pll3_sw_clk, &esdhc2_ipg_clk);
+/* SSI */
+DEFINE_CLOCK(ssi1_ipg_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG8_OFFSET,
+	NULL,  NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(ssi1_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG9_OFFSET,
+	_clk_ssi1_getrate,  NULL, &pll3_sw_clk, &ssi1_ipg_clk);
+DEFINE_CLOCK(ssi2_ipg_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG10_OFFSET,
+	NULL,  NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(ssi2_clk, 0, MXC_CCM_CCGR3, MXC_CCM_CCGRx_CG11_OFFSET,
+	_clk_ssi2_getrate,  NULL, &pll3_sw_clk, &ssi2_ipg_clk);
+
 
 #define _REGISTER_CLOCK(d, n, c) \
        { \
@@ -777,13 +2789,67 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk)
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk)
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk)
+	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c1_clk)
+	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c2_clk)
+	_REGISTER_CLOCK(NULL, "hsi2c_clk", hsi2c_clk)
+	_REGISTER_CLOCK(NULL, "hsi2c_serial_clk", hsi2c_serial_clk)
 	_REGISTER_CLOCK(NULL, "gpt", gpt_clk)
+	_REGISTER_CLOCK(NULL, "rtc_clk", clk_rtc_clk)
+	_REGISTER_CLOCK(NULL, "iim_clk", iim_clk)
+	_REGISTER_CLOCK(NULL, "kpp", kpp_clk)
+	_REGISTER_CLOCK(NULL, "owire", owire_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ahb_clk", sdma_ahb_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ipg_clk", sdma_ipg_clk)
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk)
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk)
+	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0])
+	_REGISTER_CLOCK(NULL, "usb_phy_clk", usb_phy_clk)
+	_REGISTER_CLOCK(NULL, "usb_utmi_clk", usb_utmi_clk)
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk)
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk)
+	_REGISTER_CLOCK(NULL, "ssi_clk.0", ssi1_clk)
+	_REGISTER_CLOCK(NULL, "ssi_clk.1", ssi2_clk)
+	_REGISTER_CLOCK(NULL, "csi_mclk1", csi0_clk)
+	_REGISTER_CLOCK(NULL, "csi_mclk2", csi1_clk)
+	_REGISTER_CLOCK(NULL, "pll3", pll3_sw_clk)
+	_REGISTER_CLOCK(NULL, "ipu_di0_clk", ipu_di_clk[0])
+	_REGISTER_CLOCK(NULL, "ipu_di1_clk", ipu_di_clk[1])
+	_REGISTER_CLOCK(NULL, "tve_clk", tve_clk)
+	_REGISTER_CLOCK(NULL, "vpu_clk", vpu_clk[0])
+	_REGISTER_CLOCK(NULL, "ipu_clk", ipu_clk[0])
+	_REGISTER_CLOCK(NULL, "mipi_hsp_clk", mipi_hsp_clk)
+	_REGISTER_CLOCK(NULL, "nfc_clk", emi_enfc_clk)
+	_REGISTER_CLOCK("spi_imx.0", NULL, cspi1_clk[0])
+	_REGISTER_CLOCK("spi_imx.1", NULL, cspi2_clk[0])
+	_REGISTER_CLOCK("spi_imx.2", NULL, cspi3_clk[0])
+	_REGISTER_CLOCK(NULL, "spdif_xtal_clk", spdif_xtal_clk)
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk)
+	_REGISTER_CLOCK(NULL, "gpc_dvfs_clk", gpc_dvfs_clk)
+	_REGISTER_CLOCK(NULL, "main_bus_clk", main_bus_clk)
+	_REGISTER_CLOCK(NULL, "pll2", pll2_sw_clk)
+	_REGISTER_CLOCK(NULL, "axi_a_clk", axi_a_clk)
+	_REGISTER_CLOCK(NULL, "axi_b_clk", axi_b_clk)
+	_REGISTER_CLOCK(NULL, "ddr_hf_clk", ddr_hf_clk)
+	_REGISTER_CLOCK(NULL, "ddr_clk", ddr_clk)
+	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk)
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk)
+	_REGISTER_CLOCK(NULL, "vpu_core_clk", vpu_clk[1])
+	_REGISTER_CLOCK(NULL, "periph_apm_clk", periph_apm_clk)
+	_REGISTER_CLOCK(NULL, "lp_apm", lp_apm_clk)
+	_REGISTER_CLOCK(NULL, "osc", osc_clk)
+	_REGISTER_CLOCK(NULL, "pll1_sw_clk", pll1_sw_clk)
+	_REGISTER_CLOCK(NULL, "sahara_clk", sahara_clk[0])
+	_REGISTER_CLOCK(NULL, "scc_clk", scc_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt_32k_clk", gpt_32k_clk)
+	_REGISTER_CLOCK(NULL, "uart1_ipg_clk", uart1_ipg_clk)
+	_REGISTER_CLOCK(NULL, "uart2_ipg_clk", uart2_ipg_clk)
+	_REGISTER_CLOCK(NULL, "uart3_ipg_clk", uart3_ipg_clk)
 	_REGISTER_CLOCK("fec.0", NULL, fec_clk)
 };
 
 static void clk_tree_init(void)
 {
-	u32 reg;
+	u32 reg, reg2, dp_ctl;;
 
 	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
 
@@ -799,12 +2865,66 @@ static void clk_tree_init(void)
 	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
 	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
 	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[0] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll1_main_clk.parent = &fpm_clk;
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[1] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll2_sw_clk.parent = &fpm_clk;
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+	dp_ctl = __raw_readl(pll_base[2] + MXC_PLL_DP_CTL);
+	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+		pll3_sw_clk.parent = &fpm_clk;
+
+	/* set emi_slow_clk parent */
+	emi_slow_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MXC_CCM_CBCDR_EMI_CLK_SEL) != 0)
+		emi_slow_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CBCMR) & MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+	reg2 = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+	reg2 >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+	if (reg2) {
+		ddr_clk.parent = &ddr_hf_clk;
+	} else {
+		if (reg == 0) {
+			ddr_clk.parent = &axi_a_clk;
+		} else if (reg == 1) {
+			ddr_clk.parent = &axi_b_clk;
+		} else if (reg == 2) {
+			ddr_clk.parent = &emi_slow_clk;
+		} else {
+			ddr_clk.parent = &ahb_clk;
+		}
+	}
+
 }
 
 int __init mx51_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2)
 {
-	int i;
+	int i, j = 0, reg;
+	int wp_cnt = 0;
 
 	external_low_reference = ckil;
 	external_high_reference = ckih1;
@@ -816,11 +2936,270 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc,
 
 	clk_tree_init();
 
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	/* Disable the handshake with HSC block as its not
+	  * initialised right now.
+	  */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
 	clk_enable(&cpu_clk);
 	clk_enable(&main_bus_clk);
 
+	reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+	reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+	if (reg)
+		clk_set_parent(&ddr_clk, &ddr_hf_clk);
+	else
+		clk_set_parent(&ddr_clk, &axi_a_clk);
+
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	clk_set_parent(&gpu3d_clk, &axi_a_clk);
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* move the spdif1 to 24MHz */
+	clk_set_parent(&spdif1_clk[0], &spdif_xtal_clk);
+	/* set the spdif1 dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk, &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from SSI1_CLK_ROOT */
+	clk_set_parent(&ssi_ext1_clk, &ssi1_clk);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk, &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	if (clk_get_rate(&pll1_main_clk) <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (clk_get_rate(&pll1_main_clk) <= cpu_wp_tbl[1].cpu_rate &&
+			clk_get_rate(&pll1_main_clk) > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = clk_get_rate(&pll1_main_clk);
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+
+	for (j = 0; j < cpu_wp_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_wp_tbl[j].cpu_podf =
+			(clk_get_rate(&pll1_main_clk) / cpu_wp_tbl[j].cpu_rate)
+				- 1;
+			if (clk_get_rate(&pll1_main_clk) / (cpu_wp_tbl[j].cpu_podf + 1) >
+					cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_podf++;
+				cpu_wp_tbl[j].cpu_rate =
+					 clk_get_rate(&pll1_main_clk)/
+					 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+				cpu_wp_tbl[j].cpu_rate *= 1000;
+			}
+			if (clk_get_rate(&pll1_main_clk) / (cpu_wp_tbl[j].cpu_podf + 1) <
+						cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_rate = clk_get_rate(&pll1_main_clk);
+			}
+		}
+	cpu_wp_tbl[j].pll_rate = clk_get_rate(&pll1_main_clk);
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	/*Allow for automatic gating of the EMI internal clock.
+	 * If this is done, emi_intr CCGR bits should be set to 11.
+	 */
+	reg = __raw_readl((IO_ADDRESS(M4IF_BASE_ADDR) + 0x8c));
+	reg &= ~0x1;
+	__raw_writel(reg, (IO_ADDRESS(M4IF_BASE_ADDR) + 0x8c));
+
+	clk_set_parent(&arm_axi_clk, &axi_a_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+	clk_set_parent(&uart_main_clk, &pll2_sw_clk);
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 130000000));
+
+	/* Change the NFC clock rate to be 1:4 ratio with emi clock. */
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			(clk_get_rate(&emi_slow_clk))/4));
+
 	/* System timer */
 	mxc_timer_init(&gpt_clk, MX51_IO_ADDRESS(MX51_GPT1_BASE_ADDR),
 		MX51_MXC_INT_GPT);
 	return 0;
 }
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 reg;
+	u32 stat;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * If DDR clock is sourced from PLL1, we cannot drop PLL1 freq.
+	 * Use the ARM_PODF to change the freq of the core, leave the PLL1
+	 * freq unchanged.
+	 */
+	if (ddr_clk.parent == &ddr_hf_clk) {
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+		reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CACRR);
+		cpu_curr_wp = wp;
+	} else {
+		struct timespec nstimeofday;
+		struct timespec curtime;
+
+		/* Change the ARM clock to requested frequency */
+		/* First move the ARM clock to step clock which is running
+		 * at 24MHz.
+		 */
+
+		/* Change the source of pll1_sw_clk to be the step_clk */
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		/* Stop the PLL */
+		reg = __raw_readl(MX51_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, MX51_DPLL1_BASE + MXC_PLL_DP_CTL);
+
+		/* PDF and MFI */
+		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
+		__raw_writel(reg, MX51_DPLL1_BASE + MXC_PLL_DP_OP);
+
+		/* MFD */
+		__raw_writel(p->mfd, MX51_DPLL1_BASE + MXC_PLL_DP_MFD);
+
+		/* MFI */
+		__raw_writel(p->mfn, MX51_DPLL1_BASE + MXC_PLL_DP_MFN);
+
+		reg = __raw_readl(MX51_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg |= MXC_PLL_DP_CTL_UPEN;
+		/* Set the UPEN bits */
+		__raw_writel(reg, MX51_DPLL1_BASE + MXC_PLL_DP_CTL);
+		/* Forcefully restart the PLL */
+		reg |= MXC_PLL_DP_CTL_RST;
+		__raw_writel(reg, MX51_DPLL1_BASE + MXC_PLL_DP_CTL);
+
+		/* Wait for the PLL to lock */
+		getnstimeofday(&nstimeofday);
+		do {
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("pll1 relock failed\n");
+			stat = __raw_readl(MX51_DPLL1_BASE + MXC_PLL_DP_CTL) &
+			    MXC_PLL_DP_CTL_LRF;
+		} while (!stat);
+
+		reg = __raw_readl(MXC_CCM_CCSR);
+		/* Move the PLL1 back to the pll1_main_clk */
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		cpu_curr_wp = wp;
+
+	}
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
index 2d37785..3902991 100644
--- a/arch/arm/mach-mx5/cpu.c
+++ b/arch/arm/mach-mx5/cpu.c
@@ -70,6 +70,15 @@ int mx51_revision(void)
 }
 EXPORT_SYMBOL(mx51_revision);
 
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev)
+		mxc_set_system_rev(0x51, CHIP_REV_1_0);
+}
+
 static int __init post_cpu_init(void)
 {
 	unsigned int reg;
diff --git a/arch/arm/mach-mx5/crm_regs.h b/arch/arm/mach-mx5/crm_regs.h
index c776b9a..5ba7fc9 100644
--- a/arch/arm/mach-mx5/crm_regs.h
+++ b/arch/arm/mach-mx5/crm_regs.h
@@ -478,6 +478,8 @@
 #define MXC_CCM_CCGRx_CG8_OFFSET			16
 #define MXC_CCM_CCGRx_CG7_OFFSET			14
 #define MXC_CCM_CCGRx_CG6_OFFSET			12
+#define MXC_CCM_CCGRx_CG6_1_OFFSET			12
+#define MXC_CCM_CCGRx_CG6_2_OFFSET			13
 #define MXC_CCM_CCGRx_CG5_OFFSET			10
 #define MXC_CCM_CCGRx_CG4_OFFSET			8
 #define MXC_CCM_CCGRx_CG3_OFFSET			6
@@ -529,6 +531,16 @@
 #define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
 #define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
 
+/* DVFS PER */
+#define MXC_DVFSPER_LTR0	(MXC_DVFS_PER_BASE)
+#define MXC_DVFSPER_LTR1	(MXC_DVFS_PER_BASE + 0x04)
+#define MXC_DVFSPER_LTR2	(MXC_DVFS_PER_BASE + 0x08)
+#define MXC_DVFSPER_LTR3	(MXC_DVFS_PER_BASE + 0x0C)
+#define MXC_DVFSPER_LTBR0	(MXC_DVFS_PER_BASE + 0x10)
+#define MXC_DVFSPER_LTBR1	(MXC_DVFS_PER_BASE + 0x14)
+#define MXC_DVFSPER_PMCR0	(MXC_DVFS_PER_BASE + 0x18)
+#define MXC_DVFSPER_PMCR1	(MXC_DVFS_PER_BASE + 0x1C)
+
 /* GPC */
 #define MXC_GPC_CNTR		(MX51_GPC_BASE + 0x0)
 #define MXC_GPC_PGR		(MX51_GPC_BASE + 0x4)
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
index d6fd396..1bae511 100644
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -10,8 +10,25 @@
  */
 
 #include <linux/platform_device.h>
+#include <linux/mxc_scc2_driver.h>
 #include <mach/hardware.h>
 #include <mach/imx-uart.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+
+#include <mach/sdma.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/spba.h>
+#include <mach/spi.h>
+
+#include "iomux.h"
+#include "crm_regs.h"
+
+/* Flag used to indicate when IRAM has been initialized */
+int iram_ready;
+/* Flag used to indicate if dvfs_core is active. */
+int dvfs_core_is_active;
 
 static struct resource uart0[] = {
 	{
@@ -89,8 +106,1190 @@ struct platform_device mxc_fec_device = {
 	.resource = mxc_fec_resources,
 };
 
-/* Dummy definition to allow compiling in AVIC and TZIC simultaneously */
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct resource w1_resources[] = {
+	{
+		.start = MX51_OWIRE_BASE_ADDR,
+		.end   = MX51_OWIRE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+
+	{
+		.start = MX51_MXC_INT_OWIRE,
+		.flags = IORESOURCE_IRQ,
+	 }
+};
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_w1_data,
+		},
+	.num_resources = ARRAY_SIZE(w1_resources),
+	.resource = w1_resources,
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct resource rtc_resources[] = {
+	{
+		.start = MX51_SRTC_BASE_ADDR,
+		.end = MX51_SRTC_BASE_ADDR + 0x40,
+		.flags = IORESOURCE_MEM,
+	 },
+	{
+		.start = MX51_MXC_INT_SRTC_NTZ,
+		.flags = IORESOURCE_IRQ,
+	 },
+};
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &srtc_data,
+		},
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource wdt_resources[] = {
+	{
+		.start = MX51_WDOG_BASE_ADDR,
+		.end = MX51_WDOG_BASE_ADDR + 0x30,
+		.flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_PWM)
+static struct resource pwm_resources[] = {
+	{
+	 .start = PWM1_BASE_ADDR,
+	 .end = PWM1_BASE_ADDR + 0x14,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_pwm_device = {
+	.name = "mxc_pwm",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(pwm_resources),
+	.resource = pwm_resources,
+};
+
+static void mxc_init_pwm(void)
+{
+	printk(KERN_INFO "mxc_pwm_device registered\n");
+	if (platform_device_register(&mxc_pwm_device) < 0)
+		printk(KERN_ERR "registration of mxc_pwm device failed\n");
+}
+#else
+static void mxc_init_pwm(void)
+{
+
+}
+#endif
+
+#if defined(CONFIG_BACKLIGHT_PWM)
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+static struct platform_device mxc_pwm_backlight_device = {
+	.name = "pwm-backlight",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_pwm_backlight_data,
+		},
+};
+
+static void mxc_init_pwm_backlight(void)
+{
+	printk(KERN_INFO "pwm-backlight device registered\n");
+	if (platform_device_register(&mxc_pwm_backlight_device) < 0)
+		printk(KERN_ERR
+		       "registration of pwm-backlight device failed\n");
+}
+#else
+static void mxc_init_pwm_backlight(void)
+{
+
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU_V3) || defined(CONFIG_MXC_IPU_V3_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	{
+		.start = MX51_IPU_CTRL_BASE_ADDR,
+		.end = MX51_IPU_CTRL_BASE_ADDR + SZ_512M,
+		.flags = IORESOURCE_MEM,
+	 },
+	{
+		.start = MX51_MXC_INT_IPU_SYN,
+		.flags = IORESOURCE_IRQ,
+	 },
+	{
+		.start = MX51_MXC_INT_IPU_ERR,
+		.flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static void mxc_init_ipu(void)
+{
+	void __iomem *reg_hsc_mcd = IO_ADDRESS(MX51_MIPI_HSC_BASE_ADDR);
+	void __iomem *reg_hsc_mxt_conf = IO_ADDRESS(MX51_MIPI_HSC_BASE_ADDR + \
+						    0x800);
+	struct clk *clk;
+	uint32_t temp;
+
+	/* Select IPUv3 h/w version */
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		mxc_ipu_data.rev = 2;
+
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+
+	/* Temporarily setup MIPI module to legacy mode */
+	clk = clk_get(NULL, "mipi_hsp_clk");
+	if (!IS_ERR(clk)) {
+		clk_enable(clk);
+
+		/* Temporarily setup MIPI module to legacy mode */
+		__raw_writel(0xF00, reg_hsc_mcd);
+
+		/* CSI mode reserved*/
+		temp = __raw_readl(reg_hsc_mxt_conf);
+		__raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
+
+		if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) {
+			temp = __raw_readl(reg_hsc_mxt_conf);
+			__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
+		}
+
+		clk_disable(clk);
+		clk_put(clk);
+	}
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
+static struct resource vpu_resources[] = {
+	[0] = {
+		.start = VPU_IRAM_BASE_ADDR,
+		.end = VPU_IRAM_BASE_ADDR + VPU_IRAM_SIZE,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = (u32) IO_ADDRESS(MX51_SRC_BASE_ADDR),
+		.end = (u32) IO_ADDRESS(MX51_SRC_BASE_ADDR),
+		.flags = IORESOURCE_MEM,
+	       },
+};
+
+/*! Platform Data for MXC VPU */
+static struct platform_device mxcvpu_device = {
+	.name = "mxc_vpu",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(vpu_resources),
+	.resource = vpu_resources,
+};
+
+static inline void mxc_init_vpu(void)
+{
+	if (platform_device_register(&mxcvpu_device) < 0)
+		printk(KERN_ERR "Error: Registering the VPU.\n");
+}
+#else
+static inline void mxc_init_vpu(void)
+{
+}
+#endif
+
+/*!
+ * This is platform device structure for adding SCC
+ */
+#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
+static struct platform_device mxc_scc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+};
+static void mxc_init_scc(void)
+{
+	platform_device_register(&mxc_scc_device);
+}
+#else
+#define SCM_RD_DELAY	1000000 /* in nanoseconds */
+#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
+static inline void mxc_init_scc(void)
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint8_t *UMID_base;
+	uint32_t *MAP_base;
+	uint8_t i;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint8_t iram_partitions = 16;
+	struct timespec stime;
+	struct timespec curtime;
+	long scm_rd_timeout = 0;
+	long cur_ns = 0;
+	long start_ns = 0;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		iram_partitions = 12;
+
+	scc_base = ioremap((uint32_t) MX51_SCC_BASE_ADDR, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM REGS\n");
+		return;
+	}
+	scm_ram_base = ioremap((uint32_t) MX51_IRAM_BASE_ADDR, MX51_IRAM_SIZE);
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM\n");
+		return;
+	}
+
+	/* Wait for any running SCC operations to finish or fail */
+	getnstimeofday(&stime);
+	do {
+		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec > stime.tv_nsec)
+			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
+		else{
+			/*Converted second to nanosecond and add to
+			nsec when current nanosec is less than
+			start time nanosec.*/
+			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+			curtime.tv_nsec;
+			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+				stime.tv_nsec;
+			scm_rd_timeout = cur_ns - start_ns;
+		}
+	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
+
+	/* Check for failures */
+	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
+		/* Special message for bad secret key fuses */
+		if (reg_value & SCM_STATUS_KST_BAD_KEY)
+			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
+		else
+		    printk(KERN_ERR "SECURE RAM FAILURE\n");
+
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	scm_rd_timeout = 0;
+	/* Release final two partitions for SCC2 driver */
+	scc_partno = iram_partitions - (SCC_IRAM_SIZE / SZ_8K);
+
+	for (partition_no = scc_partno; partition_no < iram_partitions;
+	     partition_no++) {
+		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
+			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
+			SCM_ZCMD_CCMD_MASK));
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		udelay(1);
+		/* Wait for zeroization to complete */
+		getnstimeofday(&stime);
+	    do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		    getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else {
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+		    }
+	    } while (((reg_value & SCM_STATUS_SRS_MASK) !=
+	    SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+	    SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+	}
+
+	/*Check all expected partitions released */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != 0) {
+		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+	reg_mask = 0;
+	scm_rd_timeout = 0;
+	/* Allocate remaining partitions for general use */
+	for (partition_no = 0; partition_no < scc_partno; partition_no++) {
+		/* Supervisor mode claims a partition for it's own use
+		by writing zero to SMID register.*/
+	    __raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
+
+		/* Wait for any zeroization to complete */
+		getnstimeofday(&stime);
+	    do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		    getnstimeofday(&curtime);
+		    if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else{
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+	    } while (((reg_value & SCM_STATUS_SRS_MASK) !=
+	    SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+	    SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+		/* Set UMID=0 and permissions for universal data
+		read/write access */
+		MAP_base = scm_ram_base + (partition_no * 0x2000);
+		UMID_base = (uint8_t *) MAP_base + 0x10;
+		for (i = 0; i < 16; i++)
+			UMID_base[i] = 0;
+
+		MAP_base[0] = (SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
+			SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
+			SCM_PERM_HD_EXECUTE | SCM_PERM_TH_READ |
+			SCM_PERM_TH_WRITE);
+		reg_mask |= (3 << (2 * (partition_no)));
+	}
+
+	/* Check all expected partitions allocated */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != reg_mask) {
+		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+	iram_ready = 1;
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_IMX) || defined(CONFIG_SPI_IMX_MODULE)
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+		.start = MX51_CSPI1_BASE_ADDR,
+		.end = MX51_CSPI1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_CSPI1,
+		.end = MX51_MXC_INT_CSPI1,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int mx51_spi1_cs[] = {
+	MXC_SPI_CS(0),
+	MXC_SPI_CS(1),
+};
+
+static struct spi_imx_master mx51_spi1_data = {
+	.chipselect	= mx51_spi1_cs,
+	.num_chipselect	= ARRAY_SIZE(mx51_spi1_cs),
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "spi_imx",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mx51_spi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+		.start = MX51_CSPI2_BASE_ADDR,
+		.end = MX51_CSPI2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_CSPI2,
+		.end = MX51_MXC_INT_CSPI2,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int mx51_spi2_cs[] = {
+	MXC_SPI_CS(0),
+	IOMUX_TO_GPIO(MX51_PIN_NANDF_D12),
+};
+
+static struct spi_imx_master mx51_spi2_data = {
+	.chipselect	= mx51_spi2_cs,
+	.num_chipselect	= ARRAY_SIZE(mx51_spi2_cs),
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "spi_imx",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mx51_spi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+
+void __init mxc_init_spi(void)
+{
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(MX51_SPBA_CSPI1, SPBA_MASTER_A);
+
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+
+
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+
+}
+#else
+void __init mxc_init_spi(void)
+{
+}
+#endif
+
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_IMX) || defined(CONFIG_I2C_IMX_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/*!
+ * Resource definition for the I2C1
+ */
+static struct resource mxci2c1_resources[] = {
+	[0] = {
+		.start = MX51_I2C1_BASE_ADDR,
+		.end = MX51_I2C1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_I2C1,
+		.end = MX51_MXC_INT_I2C1,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT2
+/*!
+ * Resource definition for the I2C2
+ */
+static struct resource mxci2c2_resources[] = {
+	[0] = {
+		.start = MX51_I2C2_BASE_ADDR,
+		.end = MX51_I2C2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_I2C2,
+		.end = MX51_MXC_INT_I2C2,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT3
+/*!
+ * Resource definition for the I2C3
+ */
+static struct resource mxci2c3_resources[] = {
+	[0] = {
+		.start = MX51_I2C3_BASE_ADDR,
+		.end = MX51_I2C3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_I2C3,
+		.end = MX51_MXC_INT_I2C3,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+#endif
+
+/*! Device Definition for MXC I2C1 */
+static struct platform_device mxci2c_devices[] = {
+#ifdef CONFIG_I2C_MXC_SELECT1
+	{
+	 .name = "imx-i2c",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = NULL,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
+	 .resource = mxci2c1_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	{
+	 .name = "imx-i2c",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = NULL,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
+	 .resource = mxci2c2_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	{
+	 .name = "imx-i2c",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = NULL,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c3_resources),
+	 .resource = mxci2c3_resources,},
+#endif
+};
+
+static inline void mxc_init_i2c(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
+		if (platform_device_register(&mxci2c_devices[i]) < 0)
+			dev_err(&mxci2c_devices[i].dev,
+				"Unable to register I2C device\n");
+	}
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
+
+#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+static struct resource mxci2c_hs_resources[] = {
+	[0] = {
+		.start = MX51_HSI2C_DMA_BASE_ADDR,
+		.end = MX51_HSI2C_DMA_BASE_ADDR + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_HS_I2C,
+		.end = MX51_MXC_INT_HS_I2C,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct platform_device mxci2c_hs_device = {
+	.name = "mxc_i2c_hs",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxci2c_hs_data,
+		},
+	.num_resources = ARRAY_SIZE(mxci2c_hs_resources),
+	.resource = mxci2c_hs_resources
+};
+
+static inline void mxc_init_i2c_hs(void)
+{
+	if (platform_device_register(&mxci2c_hs_device) < 0)
+		dev_err(&mxci2c_hs_device.dev,
+			"Unable to register High Speed I2C device\n");
+}
+#else
+static inline void mxc_init_i2c_hs(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_TVOUT_TVE) || defined(CONFIG_FB_MXC_TVOUT_TVE_MODULE)
+static struct resource tve_resources[] = {
+	{
+		.start = MX51_TVE_BASE_ADDR,
+		.end = MX51_TVE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	 },
+	{
+		.start = MX51_MXC_INT_TVE,
+		.flags = IORESOURCE_IRQ,
+	 },
+};
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+	.dig_reg = "VDIG",
+};
+
+static struct platform_device mxc_tve_device = {
+	.name = "tve",
+	.dev = {
+		.platform_data = &tve_data,
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(tve_resources),
+	.resource = tve_resources,
+};
+
+void __init mxc_init_tve(void)
+{
+	platform_device_register(&mxc_tve_device);
+}
+#else
+static inline void mxc_init_tve(void)
+{
+}
+#endif
+
+/*!
+ * Resource definition for the DVFS CORE
+ */
+static struct resource dvfs_core_resources[] = {
+	[0] = {
+		.start = (u32) MXC_DVFS_CORE_BASE,
+		.end = (u32) (MXC_DVFS_CORE_BASE + 4 * SZ_16 - 1),
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_GPC1,
+		.end = MX51_MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for DVFS CORE */
+struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
+	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
+	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
+	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+/*! Device Definition for MXC DVFS core */
+static struct platform_device mxc_dvfs_core_device = {
+	.name = "mxc_dvfs_core",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &dvfs_core_data,
+		},
+	.num_resources = ARRAY_SIZE(dvfs_core_resources),
+	.resource = dvfs_core_resources,
+};
+
+static inline void mxc_init_dvfs_core(void)
+{
+	if (platform_device_register(&mxc_dvfs_core_device) < 0)
+		dev_err(&mxc_dvfs_core_device.dev,
+			"Unable to register DVFS core device\n");
+}
+
+/*!
+ * Resource definition for the DVFS PER
+ */
+static struct resource dvfs_per_resources[] = {
+	[0] = {
+		.start = DVFSPER_BASE_ADDR,
+		.end = DVFSPER_BASE_ADDR + 2 * SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MX51_MXC_INT_GPC1,
+		.end = MX51_MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC DVFS PER*/
+struct mxc_dvfsper_data dvfs_per_data = {
+	.reg_id = "SW2",
+	.clk_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
+	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
+	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
+	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
+	.div3_offset = 0,
+	.div3_mask = 0x7,
+	.div3_div = 2,
+	.lp_high = 1200000,
+	.lp_low = 1200000,
+};
+
+/*! Device Definition for MXC DVFS Peripheral*/
+static struct platform_device mxc_dvfs_per_device = {
+	 .name = "mxc_dvfsper",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &dvfs_per_data,
+		 },
+	 .num_resources = ARRAY_SIZE(dvfs_per_resources),
+	 .resource = dvfs_per_resources,
+};
+
+static inline void mxc_init_dvfs_per(void)
+{
+	if (platform_device_register(&mxc_dvfs_per_device) < 0) {
+		dev_err(&mxc_dvfs_per_device.dev,
+				"Unable to register DVFS device\n");
+	} else {
+		printk(KERN_INFO "mxc_init_dvfs_per initialised\n");
+	}
+	return;
+}
+
+struct mxc_gpio_port mxc_gpio_ports[] = {
+	[0] = {
+	 .chip.label = "gpio-0",
+	 .base = MX51_IO_ADDRESS(MX51_GPIO1_BASE_ADDR),
+	 .irq = MX51_MXC_INT_GPIO1_LOW,
+	 .irq_high = MX51_MXC_INT_GPIO1_HIGH,
+	 .virtual_irq_start = MXC_GPIO_IRQ_START
+	 },
+	[1] = {
+	 .chip.label = "gpio-1",
+	 .base = MX51_IO_ADDRESS(MX51_GPIO2_BASE_ADDR),
+	 .irq = MX51_MXC_INT_GPIO2_LOW,
+	 .irq_high = MX51_MXC_INT_GPIO2_HIGH,
+	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 1
+	 },
+	[2] = {
+	 .chip.label = "gpio-2",
+	 .base = MX51_IO_ADDRESS(MX51_GPIO3_BASE_ADDR),
+	 .irq = MX51_MXC_INT_GPIO3_LOW,
+	 .irq_high = MX51_MXC_INT_GPIO3_HIGH,
+	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
+	 },
+	[3] = {
+	 .chip.label = "gpio-3",
+	 .base = MX51_IO_ADDRESS(MX51_GPIO4_BASE_ADDR),
+	 .irq = MX51_MXC_INT_GPIO4_LOW,
+	 .irq_high = MX51_MXC_INT_GPIO4_HIGH,
+	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
+	 }
+};
+
 int __init mxc_register_gpios(void)
 {
+	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
+}
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
+static struct resource spdif_resources[] = {
+	{
+		.start = MX51_SPDIF_BASE_ADDR,
+		.end = MX51_SPDIF_BASE_ADDR + 0x50,
+		.flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+};
+
+static struct platform_device mxc_alsa_spdif_device = {
+	.name = "mxc_alsa_spdif",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_spdif_data,
+		},
+	.num_resources = ARRAY_SIZE(spdif_resources),
+	.resource = spdif_resources,
+};
+
+static inline void mxc_init_spdif(void)
+{
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+	platform_device_register(&mxc_alsa_spdif_device);
+}
+
+static struct platform_device mx51_lpmode_device = {
+	.name = "mx51_lpmode",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mx51_init_lpmode(void)
+{
+	(void)platform_device_register(&mx51_lpmode_device);
+}
+
+static struct platform_device busfreq_device = {
+	.name = "busfreq",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_busfreq(void)
+{
+	(void)platform_device_register(&busfreq_device);
+}
+
+static struct platform_device sdram_autogating_device = {
+	.name = "sdram_autogating",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_sdram_autogating(void)
+{
+	(void)platform_device_register(&sdram_autogating_device);
+}
+
+#if defined(CONFIG_MXC_IIM) || defined(CONFIG_MXC_IIM_MODULE)
+static struct resource mxc_iim_resources[] = {
+	{
+		.start = IIM_BASE_ADDR,
+		.end = IIM_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_iim_device = {
+	.name = "mxc_iim",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(mxc_iim_resources),
+	.resource = mxc_iim_resources
+};
+
+static inline void mxc_init_iim(void)
+{
+	if (platform_device_register(&mxc_iim_device) < 0)
+		dev_err(&mxc_iim_device.dev,
+			"Unable to register mxc iim device\n");
+}
+#else
+static inline void mxc_init_iim(void)
+{
+}
+#endif
+
+static struct resource mxc_gpu_resources[] = {
+	[0] = {
+		.start = MX51_MXC_INT_GPU2_IRQ,
+		.end = MX51_MXC_INT_GPU2_IRQ,
+		.name = "gpu_2d_irq",
+		.flags = IORESOURCE_IRQ,},
+	[1] = {
+		.start = MX51_MXC_INT_GPU,
+		.end = MX51_MXC_INT_GPU,
+		.name = "gpu_3d_irq",
+		.flags = IORESOURCE_IRQ,},
+};
+
+static struct platform_device gpu_device = {
+	.name = "mxc_gpu",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(mxc_gpu_resources),
+	.resource = mxc_gpu_resources,
+};
+
+static void __init mxc_init_gpu(void)
+{
+	platform_device_register(&gpu_device);
+}
+
+#if defined(CONFIG_UIO_PDRV_GENIRQ) || defined(CONFIG_UIO_PDRV_GENIRQ_MODULE)
+static struct clk *gpu_clk;
+
+static struct resource mxc_gpu2d_resources[] = {
+	{
+		.start = MX51_GPU2D_BASE_ADDR,
+		.end = MX51_GPU2D_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	 },
+	{
+		.flags = IORESOURCE_MEM,
+	 },
+	{
+		.flags = IORESOURCE_MEM,
+	 },
+};
+
+int gpu2d_open(struct uio_info *info, struct inode *inode)
+{
+	gpu_clk = clk_get(NULL, "gpu2d_clk");
+	if (IS_ERR(gpu_clk))
+		return PTR_ERR(gpu_clk);
+
+	return clk_enable(gpu_clk);
+}
+
+int gpu2d_release(struct uio_info *info, struct inode *inode)
+{
+	if (IS_ERR(gpu_clk))
+		return PTR_ERR(gpu_clk);
+
+	clk_disable(gpu_clk);
+	clk_put(gpu_clk);
+	return 0;
+}
+
+static int gpu2d_mmap(struct uio_info *info, struct vm_area_struct *vma)
+{
+	int mi = vma->vm_pgoff;
+	if (mi < 0)
+		return -EINVAL;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	return remap_pfn_range(vma,
+			       vma->vm_start,
+			       info->mem[mi].addr >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+}
+
+static struct uio_info gpu2d_info = {
+	.name = "imx_gpu2d",
+	.version = "1",
+	.irq = MXC_INT_GPU2_IRQ,
+	.open = gpu2d_open,
+	.release = gpu2d_release,
+	.mmap = gpu2d_mmap,
+};
+
+static struct platform_device mxc_gpu2d_device = {
+	.name = "uio_pdrv_genirq",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &gpu2d_info,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+	.num_resources = ARRAY_SIZE(mxc_gpu2d_resources),
+	.resource = mxc_gpu2d_resources,
+};
+
+static inline void mxc_init_gpu2d(void)
+{
+	dma_alloc_coherent(&mxc_gpu2d_device.dev, SZ_8K,
+			   &mxc_gpu2d_resources[1].start, GFP_DMA);
+	mxc_gpu2d_resources[1].end = mxc_gpu2d_resources[1].start + SZ_8K - 1;
+
+	dma_alloc_coherent(&mxc_gpu2d_device.dev, 88 * SZ_1K,
+			   &mxc_gpu2d_resources[2].start, GFP_DMA);
+	mxc_gpu2d_resources[2].end = mxc_gpu2d_resources[2].start + \
+			(88 * SZ_1K) - 1;
+
+	platform_device_register(&mxc_gpu2d_device);
+}
+#else
+static inline void mxc_init_gpu2d(void)
+{
+}
+#endif
+
+int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_spi();
+	mxc_init_i2c();
+	mxc_init_i2c_hs();
+	mxc_init_rtc();
+	mxc_init_scc();
+	mxc_init_dma();
+	mxc_init_owire();
+	mxc_init_ipu();
+	mxc_init_vpu();
+	mxc_init_spdif();
+	mxc_init_tve();
+	mx51_init_lpmode();
+	mxc_init_busfreq();
+	mxc_init_sdram_autogating();
+	mxc_init_dvfs_core();
+	mxc_init_dvfs_per();
+	mxc_init_iim();
+	mxc_init_gpu();
+	mxc_init_gpu2d();
+	mxc_init_pwm();
+	mxc_init_pwm_backlight();
 	return 0;
 }
diff --git a/arch/arm/mach-mx5/dma.c b/arch/arm/mach-mx5/dma.c
new file mode 100644
index 0000000..c8e3819
--- /dev/null
+++ b/arch/arm/mach-mx5/dma.c
@@ -0,0 +1,727 @@
+/*
+ *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+
+#include "serial.h"
+#include "sdma_script_code.h"
+
+#define MXC_MMC_BUFFER_ACCESS     0x20
+#define MXC_SDHC_MMC_WML          64
+#define MXC_SDHC_SD_WML           256
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_SPDIF_TXFIFO_WML      0x8
+#define MXC_SPDIF_TX_REG          0x2C
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = MX51_UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = MX51_UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = MX51_UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = MX51_UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = MX51_UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = MX51_UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MX51_MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MX51_MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MX51_MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MX51_MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX51_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = MX51_ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = MX51_DMA_REQ_ATA_TX_END,
+			.event_id2 = MX51_DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = MX51_ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_ATA_TX_END,
+			.event_id2 = MX51_DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = MX51_SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SPDIF,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = MX51_SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = MX51_DMA_REQ_SPDIF,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MX51_MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	/* ATA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+}
diff --git a/arch/arm/mach-mx5/dummy_gpio.c b/arch/arm/mach-mx5/dummy_gpio.c
new file mode 100644
index 0000000..8d9537d
--- /dev/null
+++ b/arch/arm/mach-mx5/dummy_gpio.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+
+void gpio_uart_active(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_active);
+
+void gpio_uart_inactive(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+void gpio_gps_active(void) {}
+EXPORT_SYMBOL(gpio_gps_active);
+
+void gpio_gps_inactive(void) {}
+EXPORT_SYMBOL(gpio_gps_inactive);
+
+void config_uartdma_event(int port) {}
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_spi_active(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_active);
+
+void gpio_spi_inactive(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+void gpio_owire_active(void) {}
+EXPORT_SYMBOL(gpio_owire_active);
+
+void gpio_owire_inactive(void) {}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+void gpio_i2c_active(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+void gpio_i2c_inactive(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+void gpio_i2c_hs_active(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_active);
+
+void gpio_i2c_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_inactive);
+
+void gpio_pmic_active(void) {}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+void gpio_activate_audio_ports(void) {}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+void gpio_sdhc_active(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+void gpio_sdhc_inactive(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+void gpio_sensor_select(int sensor) {}
+
+void gpio_sensor_active(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_inactive(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+void gpio_ata_active(void) {}
+EXPORT_SYMBOL(gpio_ata_active);
+
+void gpio_ata_inactive(void) {}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+void gpio_nand_active(void) {}
+EXPORT_SYMBOL(gpio_nand_active);
+
+void gpio_nand_inactive(void) {}
+EXPORT_SYMBOL(gpio_nand_inactive);
+
+void gpio_keypad_active(void) {}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+void gpio_keypad_inactive(void) {}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+int gpio_usbotg_hs_active(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+void gpio_fec_active(void) {}
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void) {}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+void gpio_spdif_active(void) {}
+EXPORT_SYMBOL(gpio_spdif_active);
+
+void gpio_spdif_inactive(void) {}
+EXPORT_SYMBOL(gpio_spdif_inactive);
diff --git a/arch/arm/mach-mx5/iomux.c b/arch/arm/mach-mx5/iomux.c
new file mode 100644
index 0000000..407cebc
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX51 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX51
+ */
+/*!
+ * @file mach-mx51/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX51
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+#define IOMUXGPR0		(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR))
+#define IOMUXGPR1		(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR) + 0x004)
+#define IOMUXSW_MUX_CTL		(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR))
+#define IOMUXSW_MUX_END		(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR) + MUX_I_END)
+#define IOMUXSW_PAD_CTL		(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR) + PAD_I_START)
+#define IOMUXSW_INPUT_CTL	(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR))
+
+#define MUX_PIN_NUM_MAX        ((MUX_I_END >> 2) + 1)
+
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+static DEFINE_SPINLOCK(gpio_mux_lock);
+
+static inline void *_get_mux_reg(iomux_pin_name_t pin)
+{
+	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (mux_reg >= 0x2FC)
+			mux_reg += 8;
+		else if (mux_reg >= 0x130)
+			mux_reg += 0xC;
+	}
+	return IOMUXSW_MUX_CTL + mux_reg;
+}
+
+static inline void *_get_pad_reg(iomux_pin_name_t pin)
+{
+	u32 pad_reg = PIN_TO_IOMUX_PAD(pin);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (pad_reg == 0x4D0 - PAD_I_START)
+			pad_reg += 0x4C;
+		else if (pad_reg == 0x860 - PAD_I_START)
+			pad_reg += 0x9C;
+		else if (pad_reg >= 0x804 - PAD_I_START)
+			pad_reg += 0xB0;
+		else if (pad_reg >= 0x7FC - PAD_I_START)
+			pad_reg += 0xB4;
+		else if (pad_reg >= 0x4E4 - PAD_I_START)
+			pad_reg += 0xCC;
+		else
+			pad_reg += 8;
+	}
+	return IOMUXSW_PAD_CTL + pad_reg;
+}
+
+static inline void *_get_mux_end(void)
+{
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		return MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR) + (0x3F8 - 4);
+	else
+		return MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR) + (0x3F0 - 4);
+}
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	void __iomem *mux_reg = _get_mux_reg(pin);
+	u32 mux_data = 0;
+	u8 *rp;
+
+	BUG_ON((mux_reg > _get_mux_end()) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+
+	if (config == IOMUX_CONFIG_GPIO)
+		mux_data = PIN_TO_ALT_GPIO(pin);
+	else
+		mux_data = config;
+
+	__raw_writel(mux_data, mux_reg);
+
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if ((mux_data & *rp) && (*rp != mux_data)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, reg=%p, "
+		       " prev=0x%x new=0x%x\n", mux_reg, *rp, mux_data);
+		ret = -EINVAL;
+	}
+	*rp = mux_data;
+	spin_unlock(&gpio_mux_lock);
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	int ret = iomux_config_mux(pin, config);
+	int gpio = IOMUX_TO_GPIO(pin);
+
+	if (!ret && (gpio < MXC_GPIO_IRQS) && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin))))
+		ret |= gpio_request(gpio, NULL);
+
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+	int gpio = IOMUX_TO_GPIO(pin);
+
+	*rp = 0;
+	if ((gpio < MXC_GPIO_IRQS)
+	    && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin))))
+		gpio_free(gpio);
+
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	void __iomem *pad_reg = _get_pad_reg(pin);
+
+	BUG_ON(pad_reg < IOMUXSW_PAD_CTL);
+	__raw_writel(config, pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin)
+{
+	void __iomem *pad_reg = _get_pad_reg(pin);
+
+	return __raw_readl(pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_get_pad);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ *      */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	void __iomem *reg;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if (input == MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 4;
+		else if (input == MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT)
+			input -= 5;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT)
+			input -= 1;
+
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_TO1;
+	} else {
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START;
+	}
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+	__raw_writel(config, reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx5/iomux.h b/arch/arm/mach-mx5/iomux.h
new file mode 100644
index 0000000..e314ab2
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.h
@@ -0,0 +1,246 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX51_IOMUX_H__
+#define __MACH_MX51_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+#include "mx51_pins.h"
+
+/*!
+ * @file mach-mx51/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX51
+ */
+
+typedef unsigned int iomux_pin_name_t;
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,	/*!< used as alternate function 0 */
+	IOMUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	IOMUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	IOMUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	IOMUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	IOMUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	IOMUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	IOMUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	IOMUX_CONFIG_GPIO,	/*!< added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0,
+	PAD_CTL_DRV_LOW = 0x0 << 1,
+	PAD_CTL_DRV_MEDIUM = 0x1 << 1,
+	PAD_CTL_DRV_HIGH = 0x2 << 1,
+	PAD_CTL_DRV_MAX = 0x3 << 1,
+	PAD_CTL_ODE_OPENDRAIN_NONE = 0x0 << 3,
+	PAD_CTL_ODE_OPENDRAIN_ENABLE = 0x1 << 3,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_HYS_NONE = 0x0 << 8,
+	PAD_CTL_HYS_ENABLE = 0x1 << 8,
+	PAD_CTL_DDR_INPUT_CMOS = 0x0 << 9,
+	PAD_CTL_DDR_INPUT_DDR = 0x1 << 9,
+	PAD_CTL_DRV_VOT_LOW = 0x0 << 13,
+	PAD_CTL_DRV_VOT_HIGH = 0x1 << 13,
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX input select register index
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT,
+	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CCM_IPP_DI_CLK_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_DPLLIP1_L1T_TOG_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_EMI_IPP_IND_RDY_INT_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT0_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT1_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT2_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT3_IN_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
+	MUX_IN_FEC_FEC_CRS_SELECT_INPUT,
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_2_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_3_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_1_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_2_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_3_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_4_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_6_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_7_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_8_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_VSYNC_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_DI_WAIT_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_CLK_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_0_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_1_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_2_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_3_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_4_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_5_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_6_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_7_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DIR_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_NXT_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_STP_SELECT_INPUT,
+	MUX_INPUT_NUM_MUX,
+} iomux_input_select_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_config_t;
+
+struct mxc_iomux_pin_cfg {
+	iomux_pin_name_t pin;
+	u8 mux_mode;
+	u16 pad_cfg;
+	u8 in_select;
+	u8 in_mode;
+};
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config      the ORed value of elements defined in
+ *                             \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function gets the current pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @return		current pad value
+ */
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in
+ *                              \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+
+#endif				/*  __MACH_MX51_IOMUX_H__ */
diff --git a/arch/arm/mach-mx5/lpmodes.c b/arch/arm/mach-mx5/lpmodes.c
new file mode 100644
index 0000000..5f31603
--- /dev/null
+++ b/arch/arm/mach-mx5/lpmodes.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx51_lpmodes.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC low power modes setup.
+ *
+ * MX51 is designed to play and video with minimal power consumption.
+ * This driver enables the platform to enter and exit audio and video low
+ * power modes.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <linux/regulator/machine.h>
+#include "crm_regs.h"
+
+#define ARM_LP_CLK  166250000
+#define GP_LPM_VOLTAGE 775000
+#define GP_NORMAL_VOLTAGE 1050000
+
+static int org_cpu_rate;
+int lp_video_mode;
+int lp_audio_mode;
+static struct device *lpmode_dev;
+struct regulator *gp_core;
+
+void enter_lp_video_mode(void)
+{
+}
+
+void exit_lp_video_mode(void)
+{
+}
+
+void enter_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	int ret;
+
+	struct clk *p_clk;
+	struct clk *amode_parent_clk;
+
+
+	tclk = clk_get(NULL, "ipu_clk");
+	if (clk_get_usecount(tclk) != 0) {
+		printk(KERN_INFO
+		"Cannot enter AUDIO LPM mode - display is still active\n");
+		return;
+	}
+
+	tclk = clk_get(NULL, "cpu_clk");
+	org_cpu_rate = clk_get_rate(tclk);
+
+#ifdef CHANGE_DDR2_TO_PLL2
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+	/* Set CPU clock to be derived from PLL2 instead of PLL1 */
+	tclk = clk_get(NULL, "pll1_sw_clk");
+	clk_set_parent(tclk, clk_get(NULL, "pll2"));
+	clk_enable(tclk);
+
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+
+	/*Change the DDR freq to 133Mhz. */
+	tclk = clk_get(NULL, "ddr_hf_clk");
+	clk_set_rate(tclk, clk_round_rate(tclk, 133000000));
+
+	tclk = clk_get(NULL, "cpu_clk");
+	ret = clk_set_rate(tclk, ARM_LP_CLK);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+	/* Set the voltage to 0.775v for the GP domain. */
+	ret = regulator_set_voltage(gp_core, GP_LPM_VOLTAGE, GP_LPM_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	tclk = clk_get(NULL, "periph_apm_clk");
+	amode_parent_clk = clk_get(NULL, "lp_apm");
+	p_clk = clk_get_parent(tclk);
+	/* Make sure osc_clk is the parent of lp_apm. */
+	clk_set_parent(amode_parent_clk, clk_get(NULL, "osc"));
+	/* Set the parent of periph_apm_clk to be lp_apm */
+	clk_set_parent(tclk, amode_parent_clk);
+
+	amode_parent_clk = tclk;
+
+	tclk = clk_get(NULL, "main_bus_clk");
+	p_clk = clk_get_parent(tclk);
+	/* Set the parent of main_bus_clk to be periph_apm_clk */
+	clk_set_parent(tclk, amode_parent_clk);
+
+	clk_set_rate(clk_get(NULL, "axi_a_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "axi_b_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "ahb_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "emi_slow_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "nfc_clk"), 12000000);
+
+	/* disable PLL3 */
+	tclk = clk_get(NULL, "pll3");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	/* disable PLL2 */
+	tclk = clk_get(NULL, "pll2");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	/* disable PLL1 */
+	tclk = clk_get(NULL, "pll1_main_clk");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	lp_audio_mode = 1;
+}
+
+void exit_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	struct clk *p_clk;
+	struct clk *rmode_parent_clk;
+	int ret;
+
+	/* Set the voltage to 1.05v for the GP domain. */
+	ret = regulator_set_voltage(gp_core,
+				    GP_NORMAL_VOLTAGE, GP_NORMAL_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	rmode_parent_clk = clk_get(NULL, "pll2");
+	clk_enable(rmode_parent_clk);
+
+	tclk = clk_get(NULL, "main_bus_clk");
+	p_clk = clk_get_parent(tclk);
+
+	/* Set the dividers before setting the parent clock. */
+	clk_set_rate(clk_get(NULL, "axi_a_clk"), 6000000);
+	clk_set_rate(clk_get(NULL, "axi_b_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "ahb_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "emi_slow_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "nfc_clk"), 1200000);
+	/* Set the parent of main_bus_clk to be pll2 */
+	clk_set_parent(tclk, rmode_parent_clk);
+
+#ifdef CHANGE_DDR2_TO_PLL2
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+	/* Set CPU clock to be derived from PLL1 instead of PLL2 */
+	tclk = clk_get(NULL, "pll1_sw_clk");
+	clk_set_parent(tclk, clk_get(NULL, "pll1_main_clk"));
+	clk_disable(tclk);
+
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+
+	tclk = clk_get(NULL, "cpu_clk");
+	ret = clk_set_rate(tclk, org_cpu_rate);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+
+	tclk = clk_get(NULL, "cpu_clk");
+
+	ret = clk_set_rate(tclk, org_cpu_rate);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+
+
+	/*Change the DDR freq to 200MHz*/
+	tclk = clk_get(NULL, "ddr_hf_clk");
+	clk_set_rate(tclk, clk_round_rate(tclk, 200000000));
+	lp_audio_mode = 0;
+
+}
+
+static ssize_t lp_curr_mode(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	if (lp_video_mode)
+		return sprintf(buf, "in lp_video_mode\n");
+	else if (lp_audio_mode)
+		return sprintf(buf, "in lp_audio_mode\n");
+	else
+		return sprintf(buf, "in normal mode\n");
+}
+
+static ssize_t set_lp_mode(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	printk(KERN_DEBUG "In set_lp_mode()\n");
+
+	if (strstr(buf, "enable_lp_video") != NULL) {
+		if (!lp_video_mode)
+			enter_lp_video_mode();
+	} else if (strstr(buf, "disable_lp_video") != NULL) {
+		if (lp_video_mode)
+			exit_lp_video_mode();
+	} else if (strstr(buf, "enable_lp_audio") != NULL) {
+		if (!lp_audio_mode)
+			enter_lp_audio_mode();
+	} else if (strstr(buf, "disable_lp_audio") != NULL) {
+		if (lp_audio_mode)
+			exit_lp_audio_mode();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(lp_modes, 0644, lp_curr_mode, set_lp_mode);
+
+/*!
+ * This is the probe routine for the lp_mode driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mx51_lpmode_probe(struct platform_device *pdev)
+{
+	u32 res = 0;
+	lpmode_dev = &pdev->dev;
+
+	res = sysfs_create_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+	if (res) {
+		printk(KERN_ERR
+		"lpmode_dev: Unable to register sysdev entry for lpmode_dev");
+		return res;
+	}
+
+	if (res != 0) {
+		printk(KERN_ERR "lpmode_dev: Unable to start");
+		return res;
+	}
+	gp_core = regulator_get(NULL, "SW1");
+	lp_video_mode = 0;
+	lp_audio_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver mx51_lpmode_driver = {
+	.driver = {
+		   .name = "mx51_lpmode",
+		   },
+	.probe = mx51_lpmode_probe,
+};
+
+/*!
+ * Initialise the mx51_lpmode_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init lpmode_init(void)
+{
+	if (platform_driver_register(&mx51_lpmode_driver) != 0) {
+		printk(KERN_ERR "mx37_lpmode_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "LPMode driver module loaded\n");
+	return 0;
+}
+
+static void __exit lpmode_cleanup(void)
+{
+	sysfs_remove_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx51_lpmode_driver);
+}
+
+module_init(lpmode_init);
+module_exit(lpmode_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("LPMode driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/mm.c b/arch/arm/mach-mx5/mm.c
index b7677ef..9fe7beb 100644
--- a/arch/arm/mach-mx5/mm.c
+++ b/arch/arm/mach-mx5/mm.c
@@ -49,6 +49,11 @@ static struct map_desc mxc_io_desc[] __initdata = {
 		.pfn = __phys_to_pfn(MX51_AIPS2_BASE_ADDR),
 		.length = MX51_AIPS2_SIZE,
 		.type = MT_DEVICE
+	}, {
+		.virtual = MX51_NFC_AXI_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(MX51_NFC_AXI_BASE_ADDR),
+		.length = MX51_NFC_AXI_SIZE,
+		.type = MT_DEVICE
 	},
 };
 
diff --git a/arch/arm/mach-mx5/mx51_pins.h b/arch/arm/mach-mx5/mx51_pins.h
new file mode 100644
index 0000000..c0905a0
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_pins.h
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX51_PINS_H__
+#define __ASM_ARCH_MXC_MX51_PINS_H__
+
+/*!
+ * @file arch-mxc/mx51_pins.h
+ *
+ * @brief MX51 I/O Pin List
+ *
+ * @ingroup GPIO_MX51
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |  23 - 21 | 20  - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I  | GPIO_I | PAD_I  | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 9 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX51_PIN_ETM_D0 is defined in the enumeration:
+ *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
+ * It means the mux control register is at register offset 0x28. The pad control
+ * register offset is: 0x250 and also occupy the least significant bits
+ * within the register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I			0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I			10
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent which
+ * mux mode is for GPIO (0-based)
+ */
+#define GPIO_I			21
+
+#define NON_GPIO_PORT		0x7
+#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
+#define PIN_TO_ALT_GPIO_MASK		((1 << (MUX_IO_I - GPIO_I)) - 1)
+
+#define NON_MUX_I		PIN_TO_MUX_MASK
+#define MUX_I_START		0x001C
+#define PAD_I_START		0x3F0
+#define INPUT_CTL_START		0x8C4
+#define INPUT_CTL_START_TO1	0x928
+#define MUX_I_END		(PAD_I_START - 4)
+
+#define _MXC_BUILD_PIN(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi) << MUX_I) | \
+	((pi - PAD_I_START) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+    _MXC_BUILD_PIN(NON_GPIO_PORT, 0, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
+#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
+#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX51 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins {
+	MX51_PIN_EIM_DA0 = _MXC_BUILD_NON_GPIO_PIN(0x1C, 0x7A8),
+	MX51_PIN_EIM_DA1 = _MXC_BUILD_NON_GPIO_PIN(0x20, 0x7A8),
+	MX51_PIN_EIM_DA2 = _MXC_BUILD_NON_GPIO_PIN(0x24, 0x7A8),
+	MX51_PIN_EIM_DA3 = _MXC_BUILD_NON_GPIO_PIN(0x28, 0x7A8),
+	MX51_PIN_EIM_DA4 = _MXC_BUILD_NON_GPIO_PIN(0x2C, 0x7AC),
+	MX51_PIN_EIM_DA5 = _MXC_BUILD_NON_GPIO_PIN(0x30, 0x7AC),
+	MX51_PIN_EIM_DA6 = _MXC_BUILD_NON_GPIO_PIN(0x34, 0x7AC),
+	MX51_PIN_EIM_DA7 = _MXC_BUILD_NON_GPIO_PIN(0x38, 0x7AC),
+	MX51_PIN_EIM_DA8 = _MXC_BUILD_NON_GPIO_PIN(0x3C, 0x7B0),
+	MX51_PIN_EIM_DA9 = _MXC_BUILD_NON_GPIO_PIN(0x40, 0x7B0),
+	MX51_PIN_EIM_DA10 = _MXC_BUILD_NON_GPIO_PIN(0x44, 0x7B0),
+	MX51_PIN_EIM_DA11 = _MXC_BUILD_NON_GPIO_PIN(0x48, 0x7B0),
+	MX51_PIN_EIM_DA12 = _MXC_BUILD_NON_GPIO_PIN(0x4C, 0x7BC),
+	MX51_PIN_EIM_DA13 = _MXC_BUILD_NON_GPIO_PIN(0x50, 0x7BC),
+	MX51_PIN_EIM_DA14 = _MXC_BUILD_NON_GPIO_PIN(0x54, 0x7BC),
+	MX51_PIN_EIM_DA15 = _MXC_BUILD_NON_GPIO_PIN(0x58, 0x7BC),
+	MX51_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN(1, 0, 1, 0x5C, 0x3F0),
+	MX51_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN(1, 1, 1, 0x60, 0x3F4),
+	MX51_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN(1, 2, 1, 0x64, 0x3F8),
+	MX51_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN(1, 3, 1, 0x68, 0x3FC),
+	MX51_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN(1, 4, 1, 0x6C, 0x400),
+	MX51_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN(1, 5, 1, 0x70, 0x404),
+	MX51_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN(1, 6, 1, 0x74, 0x408),
+	MX51_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN(1, 7, 1, 0x78, 0x40C),
+	MX51_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN(1, 8, 1, 0x7C, 0x410),
+	MX51_PIN_EIM_D25 = _MXC_BUILD_NON_GPIO_PIN(0x80, 0x414),
+	MX51_PIN_EIM_D26 = _MXC_BUILD_NON_GPIO_PIN(0x84, 0x418),
+	MX51_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN(1, 9, 1, 0x88, 0x41C),
+	MX51_PIN_EIM_D28 = _MXC_BUILD_NON_GPIO_PIN(0x8C, 0x420),
+	MX51_PIN_EIM_D29 = _MXC_BUILD_NON_GPIO_PIN(0x90, 0x424),
+	MX51_PIN_EIM_D30 = _MXC_BUILD_NON_GPIO_PIN(0x94, 0x428),
+	MX51_PIN_EIM_D31 = _MXC_BUILD_NON_GPIO_PIN(0x98, 0x42C),
+	MX51_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN(1, 10, 1, 0x9C, 0x430),
+	MX51_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN(1, 11, 1, 0xA0, 0x434),
+	MX51_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN(1, 12, 1, 0xA4, 0x438),
+	MX51_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN(1, 13, 1, 0xA8, 0x43C),
+	MX51_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN(1, 14, 1, 0xAC, 0x440),
+	MX51_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN(1, 15, 1, 0xB0, 0x444),
+	MX51_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN(1, 16, 1, 0xB4, 0x448),
+	MX51_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN(1, 17, 1, 0xB8, 0x44C),
+	MX51_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN(1, 18, 1, 0xBC, 0x450),
+	MX51_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN(1, 19, 1, 0xC0, 0x454),
+	MX51_PIN_EIM_A26 = _MXC_BUILD_GPIO_PIN(1, 20, 1, 0xC4, 0x458),
+	MX51_PIN_EIM_A27 = _MXC_BUILD_GPIO_PIN(1, 21, 1, 0xC8, 0x45C),
+	MX51_PIN_EIM_EB0 = _MXC_BUILD_NON_GPIO_PIN(0xCC, 0x460),
+	MX51_PIN_EIM_EB1 = _MXC_BUILD_NON_GPIO_PIN(0xD0, 0x464),
+	MX51_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN(1, 22, 1, 0xD4, 0x468),
+	MX51_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN(1, 23, 1, 0xD8, 0x46C),
+	MX51_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN(1, 24, 1, 0xDC, 0x470),
+	MX51_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN(1, 25, 1, 0xE0, 0x474),
+	MX51_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN(1, 26, 1, 0xE4, 0x478),
+	MX51_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN(1, 27, 1, 0xE8, 0x47C),
+	MX51_PIN_EIM_CS3 = _MXC_BUILD_GPIO_PIN(1, 28, 1, 0xEC, 0x480),
+	MX51_PIN_EIM_CS4 = _MXC_BUILD_GPIO_PIN(1, 29, 1, 0xF0, 0x484),
+	MX51_PIN_EIM_CS5 = _MXC_BUILD_GPIO_PIN(1, 30, 1, 0xF4, 0x488),
+	MX51_PIN_EIM_DTACK = _MXC_BUILD_GPIO_PIN(1, 31, 1, 0xF8, 0x48C),
+	MX51_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN(2, 1, 1, 0xFC, 0x494),
+	MX51_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN(2, 2, 1, 0x100, 0x4A0),
+	MX51_PIN_DRAM_CS1 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x4D0),
+	MX51_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN(2, 3, 3, 0x108, 0x4E4),
+	MX51_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN(2, 4, 3, 0x10C, 0x4E8),
+	MX51_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN(2, 5, 3, 0x110, 0x4EC),
+	MX51_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN(2, 6, 3, 0x114, 0x4F0),
+	MX51_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN(2, 7, 3, 0x118, 0x4F4),
+	MX51_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN(2, 8, 3, 0x11C, 0x4F8),
+	MX51_PIN_NANDF_RB1 = _MXC_BUILD_GPIO_PIN(2, 9, 3, 0x120, 0x4FC),
+	MX51_PIN_NANDF_RB2 = _MXC_BUILD_GPIO_PIN(2, 10, 3, 0x124, 0x500),
+	MX51_PIN_NANDF_RB3 = _MXC_BUILD_GPIO_PIN(2, 11, 3, 0x128, 0x504),
+	MX51_PIN_GPIO_NAND = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x12C, 0x514),
+	MX51_PIN_NANDF_RB4 = MX51_PIN_GPIO_NAND,
+	MX51_PIN_NANDF_RB5 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x130, 0x5D8),
+	MX51_PIN_NANDF_RB6 = _MXC_BUILD_GPIO_PIN(2, 14, 3, 0x134, 0x5DC),
+	MX51_PIN_NANDF_RB7 = _MXC_BUILD_GPIO_PIN(2, 15, 3, 0x138, 0x5E0),
+	MX51_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN(2, 16, 3, 0x130, 0x518),
+	MX51_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN(2, 17, 3, 0x134, 0x51C),
+	MX51_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN(2, 18, 3, 0x138, 0x520),
+	MX51_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN(2, 19, 3, 0x13C, 0x524),
+	MX51_PIN_NANDF_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 3, 0x140, 0x528),
+	MX51_PIN_NANDF_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 3, 0x144, 0x52C),
+	MX51_PIN_NANDF_CS6 = _MXC_BUILD_GPIO_PIN(2, 22, 3, 0x148, 0x530),
+	MX51_PIN_NANDF_CS7 = _MXC_BUILD_GPIO_PIN(2, 23, 3, 0x14C, 0x534),
+	MX51_PIN_NANDF_RDY_INT = _MXC_BUILD_GPIO_PIN(2, 24, 3, 0x150, 0x538),
+	MX51_PIN_NANDF_D15 = _MXC_BUILD_GPIO_PIN(2, 25, 3, 0x154, 0x53C),
+	MX51_PIN_NANDF_D14 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0x158, 0x540),
+	MX51_PIN_NANDF_D13 = _MXC_BUILD_GPIO_PIN(2, 27, 3, 0x15C, 0x544),
+	MX51_PIN_NANDF_D12 = _MXC_BUILD_GPIO_PIN(2, 28, 3, 0x160, 0x548),
+	MX51_PIN_NANDF_D11 = _MXC_BUILD_GPIO_PIN(2, 29, 3, 0x164, 0x54C),
+	MX51_PIN_NANDF_D10 = _MXC_BUILD_GPIO_PIN(2, 30, 3, 0x168, 0x550),
+	MX51_PIN_NANDF_D9 = _MXC_BUILD_GPIO_PIN(2, 31, 3, 0x16C, 0x554),
+	MX51_PIN_NANDF_D8 = _MXC_BUILD_GPIO_PIN(3, 0, 3, 0x170, 0x558),
+	MX51_PIN_NANDF_D7 = _MXC_BUILD_GPIO_PIN(3, 1, 3, 0x174, 0x55C),
+	MX51_PIN_NANDF_D6 = _MXC_BUILD_GPIO_PIN(3, 2, 3, 0x178, 0x560),
+	MX51_PIN_NANDF_D5 = _MXC_BUILD_GPIO_PIN(3, 3, 3, 0x17C, 0x564),
+	MX51_PIN_NANDF_D4 = _MXC_BUILD_GPIO_PIN(3, 4, 3, 0x180, 0x568),
+	MX51_PIN_NANDF_D3 = _MXC_BUILD_GPIO_PIN(3, 5, 3, 0x184, 0x56C),
+	MX51_PIN_NANDF_D2 = _MXC_BUILD_GPIO_PIN(3, 6, 3, 0x188, 0x570),
+	MX51_PIN_NANDF_D1 = _MXC_BUILD_GPIO_PIN(3, 7, 3, 0x18C, 0x574),
+	MX51_PIN_NANDF_D0 = _MXC_BUILD_GPIO_PIN(3, 8, 3, 0x190, 0x578),
+	MX51_PIN_CSI1_D8 = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x194, 0x57C),
+	MX51_PIN_CSI1_D9 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x198, 0x580),
+	MX51_PIN_CSI1_D10 = _MXC_BUILD_NON_GPIO_PIN(0x19C, 0x584),
+	MX51_PIN_CSI1_D11 = _MXC_BUILD_NON_GPIO_PIN(0x1A0, 0x588),
+	MX51_PIN_CSI1_D12 = _MXC_BUILD_NON_GPIO_PIN(0x1A4, 0x58C),
+	MX51_PIN_CSI1_D13 = _MXC_BUILD_NON_GPIO_PIN(0x1A8, 0x590),
+	MX51_PIN_CSI1_D14 = _MXC_BUILD_NON_GPIO_PIN(0x1AC, 0x594),
+	MX51_PIN_CSI1_D15 = _MXC_BUILD_NON_GPIO_PIN(0x1B0, 0x598),
+	MX51_PIN_CSI1_D16 = _MXC_BUILD_NON_GPIO_PIN(0x1B4, 0x59C),
+	MX51_PIN_CSI1_D17 = _MXC_BUILD_NON_GPIO_PIN(0x1B8, 0x5A0),
+	MX51_PIN_CSI1_D18 = _MXC_BUILD_NON_GPIO_PIN(0x1BC, 0x5A4),
+	MX51_PIN_CSI1_D19 = _MXC_BUILD_NON_GPIO_PIN(0x1C0, 0x5A8),
+	MX51_PIN_CSI1_VSYNC = _MXC_BUILD_GPIO_PIN(2, 14, 3, 0x1C4, 0x5AC),
+	MX51_PIN_CSI1_HSYNC = _MXC_BUILD_GPIO_PIN(2, 15, 3, 0x1C8, 0x5B0),
+	MX51_PIN_CSI1_PIXCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B4),
+	MX51_PIN_CSI1_MCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B8),
+	MX51_PIN_CSI1_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x860),
+	MX51_PIN_CSI2_D12 = _MXC_BUILD_GPIO_PIN(3, 9, 3, 0x1CC, 0x5BC),
+	MX51_PIN_CSI2_D13 = _MXC_BUILD_GPIO_PIN(3, 10, 3, 0x1D0, 0x5C0),
+	MX51_PIN_CSI2_D14 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1D4, 0x5C4),
+	MX51_PIN_CSI2_D15 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1D8, 0x5C8),
+	MX51_PIN_CSI2_D16 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1DC, 0x5CC),
+	MX51_PIN_CSI2_D17 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E0, 0x5D0),
+	MX51_PIN_CSI2_D18 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1E4, 0x5D4),
+	MX51_PIN_CSI2_D19 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E8, 0x5D8),
+	MX51_PIN_CSI2_VSYNC = _MXC_BUILD_GPIO_PIN(3, 13, 3, 0x1EC, 0x5DC),
+	MX51_PIN_CSI2_HSYNC = _MXC_BUILD_GPIO_PIN(3, 14, 3, 0x1F0, 0x5E0),
+	MX51_PIN_CSI2_PIXCLK = _MXC_BUILD_GPIO_PIN(3, 15, 3, 0x1F4, 0x5E4),
+	MX51_PIN_CSI2_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x81C),
+	MX51_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(3, 16, 3, 0x1F8, 0x5E8),
+	MX51_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(3, 17, 3, 0x1FC, 0x5EC),
+	MX51_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN(3, 18, 3, 0x200, 0x5F0),
+	MX51_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN(3, 19, 3, 0x204, 0x5F4),
+	MX51_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN(3, 20, 3, 0x208, 0x5F8),
+	MX51_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN(3, 21, 3, 0x20C, 0x5FC),
+	MX51_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(3, 22, 3, 0x210, 0x600),
+	MX51_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(3, 23, 3, 0x214, 0x604),
+	MX51_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(3, 24, 3, 0x218, 0x608),
+	MX51_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(3, 25, 3, 0x21C, 0x60C),
+	MX51_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(3, 26, 3, 0x220, 0x610),
+	MX51_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(3, 27, 3, 0x224, 0x614),
+	MX51_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 28, 3, 0x228, 0x618),
+	MX51_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 29, 3, 0x22C, 0x61C),
+	MX51_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 30, 3, 0x230, 0x620),
+	MX51_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 31, 3, 0x234, 0x624),
+	MX51_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(0, 20, 3, 0x238, 0x628),
+	MX51_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(0, 21, 3, 0x23C, 0x62C),
+	MX51_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN(0, 22, 3, 0x240, 0x630),
+	MX51_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN(0, 23, 3, 0x244, 0x634),
+	MX51_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN(0, 24, 3, 0x248, 0x638),
+	MX51_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(0x24C, 0x63C),
+	MX51_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(0x250, 0x640),
+	MX51_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(0x254, 0x644),
+	MX51_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(0x258, 0x648),
+	MX51_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(0x25C, 0x64C),
+	MX51_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(0x260, 0x650),
+	MX51_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(0x264, 0x654),
+	MX51_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(0x268, 0x658),
+	MX51_PIN_KEY_COL4 = _MXC_BUILD_NON_GPIO_PIN(0x26C, 0x65C),
+	MX51_PIN_KEY_COL5 = _MXC_BUILD_NON_GPIO_PIN(0x270, 0x660),
+	MX51_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN(0, 25, 2, 0x278, 0x678),
+	MX51_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN(0, 26, 2, 0x27C, 0x67C),
+	MX51_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN(0, 27, 2, 0x280, 0x680),
+	MX51_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN(0, 28, 2, 0x284, 0x684),
+	MX51_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN(0, 11, 2, 0x288, 0x688),
+	MX51_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN(0, 12, 2, 0x28C, 0x68C),
+	MX51_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN(0, 13, 2, 0x290, 0x690),
+	MX51_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN(0, 14, 2, 0x294, 0x694),
+	MX51_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN(0, 15, 2, 0x298, 0x698),
+	MX51_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN(0, 16, 2, 0x29C, 0x69C),
+	MX51_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN(0, 17, 2, 0x2A0, 0x6A0),
+	MX51_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN(0, 18, 2, 0x2A4, 0x6A4),
+	MX51_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN(2, 0, 4, 0x2A8, 0x6A8),
+	MX51_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN(2, 1, 4, 0x2AC, 0x6AC),
+	MX51_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN(2, 2, 4, 0x2B0, 0x6B0),
+	MX51_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN(2, 3, 4, 0x2B4, 0x6B4),
+	MX51_PIN_DI1_D1_CS = _MXC_BUILD_GPIO_PIN(2, 4, 4, 0x2B8, 0x6B8),
+	MX51_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN(2, 5, 4, 0x2BC, 0x6BC),
+	MX51_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN(2, 6, 4, 0x2C0, 0x6C0),
+	MX51_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN(2, 7, 4, 0x2C4, 0x6C4),
+	MX51_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN(2, 8, 4, 0x2C8, 0x6C8),
+	MX51_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x2CC, 0x6CC),
+	MX51_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x2D0, 0x6D0),
+	MX51_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x2D4, 0x6D4),
+	MX51_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x2D8, 0x6D8),
+	MX51_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x2DC, 0x6DC),
+	MX51_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x2E0, 0x6E0),
+	MX51_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN(0x2E4, 0x6E4),
+	MX51_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN(0x2E8, 0x6E8),
+	MX51_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN(0x2EC, 0x6EC),
+	MX51_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN(0x2F0, 0x6F0),
+	MX51_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x2F4, 0x6F4),
+	MX51_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x2F8, 0x6F8),
+	MX51_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x2FC, 0x6FC),
+	MX51_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x300, 0x700),
+	MX51_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x304, 0x704),
+	MX51_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x308, 0x708),
+	MX51_PIN_DISP1_DAT16 = _MXC_BUILD_NON_GPIO_PIN(0x30C, 0x70C),
+	MX51_PIN_DISP1_DAT17 = _MXC_BUILD_NON_GPIO_PIN(0x310, 0x710),
+	MX51_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN(0x314, 0x714),
+	MX51_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN(0x318, 0x718),
+	MX51_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN(0x31C, 0x71C),
+	MX51_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN(0x320, 0x720),
+	MX51_PIN_DISP1_DAT22 = _MXC_BUILD_NON_GPIO_PIN(0x324, 0x724),
+	MX51_PIN_DISP1_DAT23 = _MXC_BUILD_NON_GPIO_PIN(0x328, 0x728),
+	MX51_PIN_DI1_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x32C, 0x72C),
+	MX51_PIN_DI1_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x330, 0x734),
+	MX51_PIN_DI_GP1 = _MXC_BUILD_NON_GPIO_PIN(0x334, 0x73C),
+	MX51_PIN_DI_GP2 = _MXC_BUILD_NON_GPIO_PIN(0x338, 0x740),
+	MX51_PIN_DI_GP3 = _MXC_BUILD_NON_GPIO_PIN(0x33C, 0x744),
+	MX51_PIN_DI2_PIN4 = _MXC_BUILD_NON_GPIO_PIN(0x340, 0x748),
+	MX51_PIN_DI2_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x344, 0x74C),
+	MX51_PIN_DI2_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x348, 0x750),
+	MX51_PIN_DI2_DISP_CLK = _MXC_BUILD_NON_GPIO_PIN(0x34C, 0x754),
+	MX51_PIN_DI_GP4 = _MXC_BUILD_NON_GPIO_PIN(0x350, 0x758),
+	MX51_PIN_DISP2_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x354, 0x75C),
+	MX51_PIN_DISP2_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x358, 0x760),
+	MX51_PIN_DISP2_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x35C, 0x764),
+	MX51_PIN_DISP2_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x360, 0x768),
+	MX51_PIN_DISP2_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x364, 0x76C),
+	MX51_PIN_DISP2_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x368, 0x770),
+	MX51_PIN_DISP2_DAT6 = _MXC_BUILD_GPIO_PIN(0, 19, 5, 0x36C, 0x774),
+	MX51_PIN_DISP2_DAT7 = _MXC_BUILD_GPIO_PIN(0, 29, 5, 0x370, 0x778),
+	MX51_PIN_DISP2_DAT8 = _MXC_BUILD_GPIO_PIN(0, 30, 5, 0x374, 0x77C),
+	MX51_PIN_DISP2_DAT9 = _MXC_BUILD_GPIO_PIN(0, 31, 5, 0x378, 0x780),
+	MX51_PIN_DISP2_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x37C, 0x784),
+	MX51_PIN_DISP2_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x380, 0x788),
+	MX51_PIN_DISP2_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x384, 0x78C),
+	MX51_PIN_DISP2_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x388, 0x790),
+	MX51_PIN_DISP2_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x38C, 0x794),
+	MX51_PIN_DISP2_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x390, 0x798),
+	MX51_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN(0x394, 0x79C),
+	MX51_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN(0x398, 0x7A0),
+	MX51_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x39C, 0x7A4),
+	MX51_PIN_SD1_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3A0, 0x7A8),
+	MX51_PIN_SD1_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3A4, 0x7AC),
+	MX51_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3A8, 0x7B0),
+	MX51_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 1, 0x3AC, 0x7B4),
+	MX51_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 1, 0x3B0, 0x7B8),
+	MX51_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN(0x3B4, 0x7BC),
+	MX51_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN(0x3B8, 0x7C0),
+	MX51_PIN_SD2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x3BC, 0x7C4),
+	MX51_PIN_SD2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3C0, 0x7C8),
+	MX51_PIN_SD2_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3C4, 0x7CC),
+	MX51_PIN_SD2_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3C8, 0x7D0),
+	MX51_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 0, 0x3CC, 0x7D4),
+	MX51_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 0, 0x3D0, 0x7D8),
+	MX51_PIN_PMIC_INT_REQ = _MXC_BUILD_NON_GPIO_PIN(0x3D4, 0x7FC),
+	MX51_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 0, 0x3D8, 0x804),
+	MX51_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 0, 0x3DC, 0x808),
+	MX51_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 0, 0x3E0, 0x80C),
+	MX51_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN(0, 7, 0, 0x3E4, 0x810),
+	MX51_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN(0, 8, 0, 0x3E8, 0x814),
+	MX51_PIN_GPIO1_9 = _MXC_BUILD_GPIO_PIN(0, 9, 0, 0x3EC, 0x818),
+};
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX51_PINS_H__ */
diff --git a/arch/arm/mach-mx5/pm.c b/arch/arm/mach-mx5/pm.c
new file mode 100644
index 0000000..7050675
--- /dev/null
+++ b/arch/arm/mach-mx5/pm.c
@@ -0,0 +1,220 @@
+/*
+ *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include <linux/proc_fs.h>
+#include <linux/cpufreq.h>
+#include <asm/cacheflush.h>
+#include <asm/tlb.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
+#include "crm_regs.h"
+
+static struct cpu_wp *cpu_wp_tbl;
+static struct clk *cpu_clk;
+
+#if defined(CONFIG_CPU_FREQ)
+static int org_freq;
+extern int cpufreq_suspended;
+extern int set_cpu_freq(int wp);
+#endif
+
+
+static struct device *pm_dev;
+struct clk *gpc_dvfs_clk;
+extern void cpu_do_suspend_workaround(u32 sdclk_iomux_addr);
+extern void cpu_cortexa8_do_idle(void *);
+
+extern int iram_ready;
+void *suspend_iram_base;
+void (*suspend_in_iram)(void *sdclk_iomux_addr) = NULL;
+
+static int mx51_suspend_enter(suspend_state_t state)
+{
+	void __iomem *sdclk_iomux_addr = IO_ADDRESS(MX51_IOMUXC_BASE_ADDR + 0x4b8);
+
+	if (gpc_dvfs_clk == NULL)
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	/* gpc clock is needed for SRPG */
+	clk_enable(gpc_dvfs_clk);
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (tzic_enable_wake(0) != 0)
+		return -EAGAIN;
+
+	if (state == PM_SUSPEND_MEM) {
+		local_flush_tlb_all();
+		flush_cache_all();
+
+		/* Run the suspend code from iRAM. */
+		suspend_in_iram(sdclk_iomux_addr);
+
+		/*clear the EMPGC0/1 bits */
+		__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+	} else {
+		if ((mxc_cpu_is_rev(CHIP_REV_2_0)) < 0) {
+			/* do cpu_idle_workaround */
+			u32 l2_iram_addr = IDLE_IRAM_BASE_ADDR;
+			if (!iram_ready)
+				return 0;
+			if (l2_iram_addr > 0x1FFE8000)
+				cpu_cortexa8_do_idle(IO_ADDRESS(l2_iram_addr));
+		} else {
+			cpu_do_idle();
+		}
+	}
+	clk_disable(gpc_dvfs_clk);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx51_suspend_prepare(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+	struct cpufreq_freqs freqs;
+	org_freq = clk_get_rate(cpu_clk);
+	freqs.old = org_freq / 1000;
+	freqs.new = cpu_wp_tbl[0].cpu_rate / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+	cpufreq_suspended = 1;
+	if (clk_get_rate(cpu_clk) != cpu_wp_tbl[0].cpu_rate) {
+		set_cpu_freq(cpu_wp_tbl[0].cpu_rate);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Called before devices are re-setup.
+ */
+static void mx51_suspend_finish(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+	struct cpufreq_freqs freqs;
+
+	freqs.old = clk_get_rate(cpu_clk) / 1000;
+	freqs.new = org_freq / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+	cpufreq_suspended = 0;
+
+	if (org_freq != clk_get_rate(cpu_clk)) {
+		set_cpu_freq(org_freq);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx51_suspend_end(void)
+{
+}
+
+static int mx51_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+const struct platform_suspend_ops mx51_suspend_ops = {
+	.valid = mx51_pm_valid,
+	.prepare = mx51_suspend_prepare,
+	.enter = mx51_suspend_enter,
+	.finish = mx51_suspend_finish,
+	.end = mx51_suspend_end,
+};
+
+
+static int __devinit mx51_pm_probe(struct platform_device *pdev)
+{
+	pm_dev = &pdev->dev;
+	return 0;
+}
+
+static struct platform_driver mx51_pm_driver = {
+	.driver = {
+		   .name = "mx51_pm",
+		   },
+	.probe = mx51_pm_probe,
+};
+
+static int __init pm_init(void)
+{
+	int cpu_wp_nr;
+
+	pr_info("Static Power Management for Freescale i.MX51\n");
+	if (platform_driver_register(&mx51_pm_driver) != 0) {
+		printk(KERN_ERR "mx51_pm_driver register failed\n");
+		return -ENODEV;
+	}
+	suspend_set_ops(&mx51_suspend_ops);
+	/* Move suspend routine into iRAM */
+	suspend_iram_base = IO_ADDRESS(SUSPEND_IRAM_BASE_ADDR);
+	memcpy(suspend_iram_base, cpu_do_suspend_workaround, SZ_4K);
+	/* Need to remap the area here since we want the memory region
+		 to be executable. */
+	suspend_iram_base = __arm_ioremap(SUSPEND_IRAM_BASE_ADDR, SZ_4K,
+							MT_HIGH_VECTORS);
+	suspend_in_iram = (void *)suspend_iram_base;
+
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+	printk(KERN_INFO "PM driver module loaded\n");
+
+	return 0;
+}
+
+
+static void __exit pm_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx51_pm_driver);
+}
+
+module_init(pm_init);
+module_exit(pm_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("PM driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/sdma_script_code.h b/arch/arm/mach-mx5/sdma_script_code.h
new file mode 100644
index 0000000..0ec376b
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+	SDMA RELEASE LABEL:	"SS15_ELVIS"
+
+*******************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR	0
+#define start_SIZE	24
+
+#define core_ADDR	80
+#define core_SIZE	232
+
+#define common_ADDR	312
+#define common_SIZE	330
+
+#define ap_2_ap_ADDR	642
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	683
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	747
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	817
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	892
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	961
+#define mcu_2_shp_SIZE	72
+
+#define app_2_per_ADDR	1033
+#define app_2_per_SIZE	66
+
+#define per_2_app_ADDR	1099
+#define per_2_app_SIZE	74
+
+#define per_2_shp_ADDR	1173
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1251
+#define shp_2_per_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1323
+#define uartsh_2_mcu_SIZE	69
+
+#define mcu_2_ata_ADDR	1392
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1473
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1569
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1796
+#define test_SIZE	63
+
+#define signature_ADDR	1023
+#define signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define ext_mem__ipu_ram_ADDR	6144
+#define ext_mem__ipu_ram_SIZE	123
+
+#define mcu_2_spdif_ADDR	6267
+#define mcu_2_spdif_SIZE	59
+
+#define uart_2_per_ADDR	6326
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6399
+#define uartsh_2_per_SIZE	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			322
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0x0e70, 0x0611, 0x5616, 0xc13c, 0x7d2a, 0x5ade, 0x008e, 0xc14e,
+	0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5,
+	0xd84f, 0x982b, 0x6b05, 0xc681, 0x7e27, 0x7f29, 0x982b, 0x6d01,
+	0x03df, 0x7d05, 0x6bd5, 0xc6ab, 0x7e18, 0x7f1a, 0x982b, 0x6b05,
+	0xc621, 0x7e07, 0x7f06, 0x52de, 0x53e6, 0xc159, 0x7dd7, 0x0200,
+	0x9803, 0x0007, 0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc256,
+	0x048b, 0x0498, 0x0454, 0x068a, 0x982b, 0x0207, 0x680c, 0x6ddf,
+	0x0107, 0x68ff, 0x60d0, 0x9834, 0x0207, 0x68ff, 0x6d28, 0x0107,
+	0x6004, 0x680c, 0x9834, 0x0007, 0x68ff, 0x60d0, 0x9834, 0x0288,
+	0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da,
+	0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804,
+	0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf,
+	0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb,
+	0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3,
+	0x65ff, 0x7ed1, 0x0006, 0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a01,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x56fb, 0x0478,
+	0x7d28, 0x0479, 0x7c16, 0x0015, 0x0015, 0x0388, 0x620a, 0x0808,
+	0x7801, 0x0217, 0x5a06, 0x7f1d, 0x620a, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f17, 0x2301, 0x4b00, 0x7cf1, 0x0b70, 0x0311, 0x5313,
+	0x98aa, 0x0015, 0x0015, 0x0015, 0x7804, 0x620b, 0x5a06, 0x620b,
+	0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa, 0x57db,
+	0x9880, 0x0007, 0x680c, 0xc213, 0xc20a, 0x987d, 0xc1e3, 0x57db,
+	0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269,
+	0x7d1e, 0x1e94, 0x6ee3, 0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3,
+	0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27,
+	0x6ac8, 0x7f23, 0x2501, 0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3,
+	0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x62d0, 0xc27a, 0x98fb, 0x6ee3,
+	0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e,
+	0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000,
+	0x4d00, 0x7d09, 0xc1fa, 0x57db, 0x98ba, 0x0007, 0x6aff, 0x62d0,
+	0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff8, 0xc20a, 0x98b7, 0xc1d9,
+	0xc1e3, 0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202,
+	0x0269, 0x7d17, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694, 0x5206,
+	0x026e, 0x7d26, 0x6ac8, 0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e,
+	0x1a98, 0x5202, 0x0260, 0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc27a,
+	0x993e, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06,
+	0x0000, 0x4d00, 0x7d0b, 0xc1fa, 0x57db, 0x9904, 0x0007, 0x6aff,
+	0x6add, 0x7ffc, 0x62d0, 0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff6,
+	0xc20a, 0x9901
+};
+#endif
diff --git a/arch/arm/mach-mx5/sdram_autogating.c b/arch/arm/mach-mx5/sdram_autogating.c
new file mode 100644
index 0000000..68a2b12
--- /dev/null
+++ b/arch/arm/mach-mx5/sdram_autogating.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sdram_autogating.c
+ *
+ * @brief Enable auto clock gating of the EMI_FAST clock using M4IF.
+ *
+ * The APIs are for enabling and disabling automatic clock gating of EMI_FAST.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/sdram_autogating.h>
+#include "crm_regs.h"
+
+static struct device *sdram_autogating_dev;
+#define M4IF_CNTL_REG0		0x8c
+#define M4IF_CNTL_REG1		0x90
+
+/* Flag used to indicate if SDRAM M4IF autoclock gating feature is active. */
+static int sdram_autogating_is_active;
+static int sdram_autogating_paused;
+
+static void enable(void)
+{
+	u32 reg;
+
+	/* Set the Fast arbitration Power saving timer */
+	reg = __raw_readl((IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG1));
+	reg &= ~0xFF;
+	reg |= 0x09;
+	__raw_writel(reg, (IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG1));
+	/*Allow for automatic gating of the EMI internal clock.
+	 * If this is done, emi_intr CCGR bits should be set to 11.
+	 */
+	reg = __raw_readl((IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG0));
+	reg &= ~0x5;
+	__raw_writel(reg, (IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG0));
+
+	sdram_autogating_is_active = 1;
+}
+
+static void disable(void)
+{
+	u32 reg;
+
+	reg = __raw_readl((IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG0));
+	reg |= 0x4;
+	__raw_writel(reg, (IO_ADDRESS(M4IF_BASE_ADDR) + M4IF_CNTL_REG0));
+	sdram_autogating_is_active = 0;
+}
+
+int sdram_autogating_active()
+{
+	return sdram_autogating_is_active;
+}
+
+void start_sdram_autogating()
+{
+	if (sdram_autogating_paused) {
+		enable();
+		sdram_autogating_paused = 0;
+	}
+}
+
+void  stop_sdram_autogating()
+{
+	if (sdram_autogating_is_active) {
+		sdram_autogating_paused = 1;
+		disable();
+	}
+}
+
+static ssize_t sdram_autogating_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (sdram_autogating_is_active)
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST enabled\n");
+	else
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST disabled\n");
+}
+
+static ssize_t sdram_autogating_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL)
+		enable();
+	else if (strstr(buf, "0") != NULL) {
+		if (sdram_autogating_is_active)
+			disable();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, sdram_autogating_enable_show,
+			sdram_autogating_enable_store);
+
+/*!
+ * This is the probe routine for the auto clockgating of sdram driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit sdram_autogating_probe(struct platform_device *pdev)
+{
+	int err = 0;
+
+	sdram_autogating_dev = &pdev->dev;
+
+	err = sysfs_create_file(&sdram_autogating_dev->kobj,
+							&dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for sdram_autogating");
+		return err;
+	}
+
+	sdram_autogating_is_active = 0;
+
+	return 0;
+}
+
+static struct platform_driver sdram_autogating_driver = {
+	.driver = {
+		   .name = "sdram_autogating",
+		},
+	.probe = sdram_autogating_probe,
+};
+
+/*!
+ * Initialise the sdram_autogating_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init sdram_autogating_init(void)
+{
+	if (platform_driver_register(&sdram_autogating_driver) != 0) {
+		printk(KERN_ERR "sdram_autogating_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "sdram autogating driver module loaded\n");
+	return 0;
+}
+
+static void __exit sdram_autogating_cleanup(void)
+{
+	sysfs_remove_file(&sdram_autogating_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&sdram_autogating_driver);
+}
+
+module_init(sdram_autogating_init);
+module_exit(sdram_autogating_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("sdram_autogating driver");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-mx5/serial.h b/arch/arm/mach-mx5/serial.h
new file mode 100644
index 0000000..ff4928c
--- /dev/null
+++ b/arch/arm/mach-mx5/serial.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX51_SERIAL_H__
+#define __ARCH_ARM_MACH_MX51_SERIAL_H__
+
+#include <mach/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+/* UART used as wakeup source */
+#define UART1_HW_FLOW           0
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+
+#endif				/* __ARCH_ARM_MACH_MX51_SERIAL_H__ */
diff --git a/arch/arm/mach-mx5/suspend.S b/arch/arm/mach-mx5/suspend.S
new file mode 100644
index 0000000..5cfd9be
--- /dev/null
+++ b/arch/arm/mach-mx5/suspend.S
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_CTRL_ICACHE  1 << 12
+#define ARM_AUXCR_L2EN   1 << 1
+
+
+/*
+ *	cpu_do_suspend_workaround()
+ *
+ *	Suspend the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_do_suspend_workaround)
+    stmfd   sp!, {r4,r5,r6,r7,r9,r10,r11}     @ Save registers
+
+   mov    r6, r0                       @save iomux address
+    /* Disable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    bic     r0, r0, #ARM_CTRL_ICACHE @ Disable ICache
+    bic     r0, r0, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000       @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedClean
+    mov     r10, #0
+Loop1Clean:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipClean                @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7             @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Clean:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Clean:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c14, 2 @ Clean and invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Clean
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Clean
+SkipClean:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Clean
+
+FinishedClean:
+
+    /* Disable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    bic     r0, r0, #ARM_AUXCR_L2EN @ Disable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+	/*Set the DDR drive strength to low */
+	ldr        r10, [r6]
+	and       r10, r10, #0xF1        @ clear bits 2-1
+	str        r10, [r6]
+
+    .long     0xe320f003              @ Opcode for WFI
+
+	/*Set the DDR drive strength to max */
+	orr       r10, r10, #0x06        @ set bits 2-1
+	str        r10, [r6]
+
+    mov     r0, #0
+    mcr     p15, 0, r0, c7, c5, 0   @ Invalidate inst cache
+
+    /* Invalidate data caches */
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000      @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedInvalidate
+    mov     r10, #0
+Loop1Invalidate:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipInvalidate          @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7              @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Invalidate:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Invalidate:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c6, 2  @ Invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Invalidate
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Invalidate
+SkipInvalidate:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Invalidate
+
+FinishedInvalidate:
+
+    /* Enable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    orr     r0, r0, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    /* Enable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    orr     r0, r0, #ARM_CTRL_ICACHE @ Enable ICache
+    orr     r0, r0, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    /* Restore registers */
+    ldmfd sp!, {r4,r5,r6,r7,r9,r10,r11}
+    mov		pc, lr
+
+	.type	cpu_do_suspend, #object
+ENTRY(cpu_do_suspend)
+	.word	cpu_do_suspend_workaround
+	.size	cpu_do_suspend_workaround, . - cpu_do_suspend_workaround
diff --git a/arch/arm/mach-mx5/system.c b/arch/arm/mach-mx5/system.c
new file mode 100644
index 0000000..958620d
--- /dev/null
+++ b/arch/arm/mach-mx5/system.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include "crm_regs.h"
+#include "iomux.h"
+/*!
+ * @defgroup MSL_MX51 i.MX51 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx51/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX51
+ */
+
+extern int iram_ready;
+static struct clk *gpc_dvfs_clk;
+
+extern void cpu_cortexa8_do_idle(void *addr);
+
+
+/* set cpu low power mode before WFI instruction */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	u32 plat_lpc, arm_srpgcr, ccm_clpcr, gpc_pgr;
+	u32 empgc0, empgc1;
+	int stop_mode = 0;
+
+	/* always allow platform to issue a deep sleep mode request */
+	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
+	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	gpc_pgr = __raw_readl(MXC_GPC_PGR) & ~(MXC_GPC_PGR_ARMPG_MASK);
+	switch (mode) {
+	case WAIT_CLOCKED:
+		break;
+	case WAIT_UNCLOCKED:
+		ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	case WAIT_UNCLOCKED_POWER_OFF:
+	case STOP_POWER_OFF:
+		plat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM
+			    | MXC_CORTEXA8_PLAT_LPC_DBG_DSM;
+		if (mode == WAIT_UNCLOCKED_POWER_OFF) {
+			ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;
+			stop_mode = 0;
+		} else {
+			ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr |= (0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET);
+			ccm_clpcr |= MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr |= MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 1;
+		}
+
+		arm_srpgcr |= MXC_SRPGCR_PCR;
+gpc_pgr |= (0x1 << MXC_GPC_PGR_ARMPG_OFFSET);
+		if (stop_mode) {
+			empgc0 |= MXC_SRPGCR_PCR;
+			empgc1 |= MXC_SRPGCR_PCR;
+		}
+
+		if (tzic_enable_wake(1) != 0)
+			return;
+		break;
+	case STOP_POWER_ON:
+		ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	default:
+		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		return;
+	}
+
+	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	__raw_writel(gpc_pgr, MXC_GPC_PGR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+	if (stop_mode) {
+		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+	}
+}
+
+void mxc_pg_enable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_IPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_VPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+EXPORT_SYMBOL(mxc_pg_enable);
+
+void mxc_pg_disable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(0x0, MXC_PGC_IPU_PGCR);
+		if (__raw_readl(MXC_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(0x0, MXC_PGC_VPU_PGCR);
+		if (__raw_readl(MXC_PGC_VPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+EXPORT_SYMBOL(mxc_pg_disable);
+
+/* To change the idle power mode, need to set arch_idle_mode to a different
+ * power mode as in enum mxc_cpu_pwr_mode.
+ * May allow dynamically changing the idle mode.
+ */
+static int arch_idle_mode = WAIT_UNCLOCKED_POWER_OFF;
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void mx51_arch_idle(void)
+{
+	if (likely(!mxc_jtag_enabled)) {
+		if (gpc_dvfs_clk == NULL)
+			gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+		/* gpc clock is needed for SRPG */
+		clk_enable(gpc_dvfs_clk);
+		mxc_cpu_lp_set(arch_idle_mode);
+		if ((mxc_cpu_is_rev(CHIP_REV_2_0)) < 0) {
+			u32 l2_iram_addr = IDLE_IRAM_BASE_ADDR;
+			if (!iram_ready)
+				return;
+
+			if (l2_iram_addr > 0x1FFE8000)
+				cpu_cortexa8_do_idle(IO_ADDRESS(l2_iram_addr));
+		} else {
+			cpu_do_idle();
+		}
+		clk_disable(gpc_dvfs_clk);
+	}
+}
+/*
+ * This function resets the system. It is called by arch_reset().
+ *
+ */
+void mx51_reset_fixup(void)
+{
+	/* Workaround to reset NFC_CONFIG3 register
+	 * due to the chip warm reset does not reset it
+	 */
+	__raw_writel(0x20600, IO_ADDRESS(MX51_NFC_BASE_ADDR) + 0x28);
+
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB3,
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_HIGH);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB2,
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_HIGH);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D15,
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_HIGH);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D12,
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_HIGH);
+}
+
diff --git a/arch/arm/mach-mx5/usb.h b/arch/arm/mach-mx5/usb.h
new file mode 100644
index 0000000..7cc14d9
--- /dev/null
+++ b/arch/arm/mach-mx5/usb.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+#if defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config;
+#define PDATA (&dr_1301_config)
+#elif defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config;
+#define PDATA (&dr_13783_config)
+#elif defined(CONFIG_UTMI_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+#endif
+
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx5/usb_dr.c b/arch/arm/mach-mx5/usb_dr.c
new file mode 100644
index 0000000..3eba7be
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_dr.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include "usb.h"
+
+static int usbotg_init_ext(struct platform_device *pdev);
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata);
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable);
+static void usbotg_clock_gate(bool on);
+
+/*
+ * platform data structs
+ *	- Which one to use is determined by CONFIG options in usb.h
+ *	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit_ext,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.wake_up_enable = _wake_up_enable,
+	.transceiver       = "utmi",
+};
+
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MX51_MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource udc_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MX51_MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ *	dev.platform_data field plugged at run time
+ */
+static struct platform_device dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = udc_resources,
+	.num_resources = ARRAY_SIZE(udc_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+/* Notes: configure USB clock*/
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(NULL, "usb_phy_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	/*derive clock from oscillator */
+	usb_clk = clk_get(NULL, "usb_utmi_clk");
+	if (clk_get_usecount(usb_clk) > 0)
+		clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	return usbotg_init(pdev);
+}
+
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(NULL, "usb_phy_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usbotg_uninit(pdata);
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (get_usb_mode(pdata) == FSL_USB_DR_DEVICE) {
+		if (enable) {
+			USBCTRL |= UCTRL_OWIE;
+			USBCTRL_HOST2 |= UCTRL_H2OVBWK_EN;
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_CONF2;
+		} else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL_HOST2 &= ~UCTRL_H2OVBWK_EN;
+			USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CONF2;
+		}
+	} else {
+		if (enable) {
+			USBCTRL |= UCTRL_OWIE;
+			USBCTRL_HOST2 |= (1 << 5);
+		} else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL_HOST2 &= ~(1 << 5);
+		}
+	}
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	struct clk *usb_clk;
+
+	if (on) {
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_phy_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		/*derive clock from oscillator */
+		usb_clk = clk_get(NULL, "usb_utmi_clk");
+		if (clk_get_usecount(usb_clk) > 0)
+			clk_disable(usb_clk);
+		clk_put(usb_clk);
+	} else {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_phy_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+}
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s:\n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx5/usb_h1.c b/arch/arm/mach-mx5/usb_h1.c
new file mode 100644
index 0000000..6b47971
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h1.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "usb.h"
+#include "iomux.h"
+
+
+/*
+ * USB Host1 HS port
+ */
+static int gpio_usbh1_active(void)
+{
+	/* Set USBH1_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO |
+			  IOMUX_CONFIG_SION);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), "usbh1_stp");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), 1);
+
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		mxc_request_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_ALT1);
+		mxc_iomux_set_pad(MX51_PIN_EIM_D17, PAD_CTL_DRV_HIGH |
+			  PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+			  PAD_CTL_100K_PU | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+		gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), "eim_d17");
+		gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), 0);
+		gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), 1);
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+void gpio_usbh1_setback_stp(void)
+{
+	/* setback USBH1_STP to be function */
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_STP, PAD_CTL_SRE_FAST |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS |
+			  PAD_CTL_DRV_VOT_LOW);
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP));
+}
+EXPORT_SYMBOL(gpio_usbh1_setback_stp);
+
+static void gpio_usbh1_inactive(void)
+{
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		gpio_free(IOMUX_TO_GPIO(MX51_PIN_EIM_D17));
+		mxc_free_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_GPIO);
+	}
+
+	mxc_free_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO);
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP));
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (enable)
+		USBCTRL |= UCTRL_H1WIE;
+	else
+		USBCTRL &= ~UCTRL_H1WIE;
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	struct clk *usboh3_clk = clk_get(NULL, "usboh3_clk");
+	struct clk *usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+
+	if (on) {
+		clk_enable(usb_ahb_clk);
+		clk_enable(usboh3_clk);
+	} else {
+		clk_disable(usboh3_clk);
+		clk_disable(usb_ahb_clk);
+	}
+
+	clk_put(usboh3_clk);
+	clk_put(usb_ahb_clk);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.platform_init = fsl_usb_host_init,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.gpio_usb_active = gpio_usbh1_active,
+	.gpio_usb_inactive = gpio_usbh1_inactive,
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.transceiver = "isp1504",
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H1REGS_BASE),
+	       .end = (u32) (USB_H1REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX51_MXC_INT_USB_H1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int __init usbh1_init(void)
+{
+	pr_debug("%s:\n", __func__);
+
+	host_pdev_register(usbh1_resources,
+			ARRAY_SIZE(usbh1_resources), &usbh1_config);
+
+	return 0;
+}
+
+module_init(usbh1_init);
diff --git a/arch/arm/mach-mx5/usb_h2.c b/arch/arm/mach-mx5/usb_h2.c
new file mode 100644
index 0000000..8230753
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h2.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <asm/mach-types.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+#include "iomux.h"
+
+/*
+ * USB Host2 HS port
+ */
+static int gpio_usbh2_active(void)
+{
+	/* Set USBH2_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), "eim_a26");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), 1);
+
+	msleep(100);
+
+	return 0;
+}
+
+void gpio_usbh2_setback_stp(void)
+{
+	/* setback USBH2_STP to be function */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT2);
+}
+EXPORT_SYMBOL(gpio_usbh2_setback_stp);
+
+static void gpio_usbh2_inactive(void)
+{
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_EIM_A26));
+	mxc_free_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+}
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name = "Host 2",
+	.platform_init = fsl_usb_host_init,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.gpio_usb_active = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver = "isp1504",
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H2REGS_BASE),
+	       .end = (u32) (USB_H2REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX51_MXC_INT_USB_H2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s:\n", __func__);
+
+	if (machine_is_mx51_3ds() ||
+	    (machine_is_mx51_babbage() && (cpu_is_mx51_rev(CHIP_REV_2_0) >= 1)))
+		return 0;
+
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+
+module_init(usbh2_init);
diff --git a/arch/arm/mach-mx5/wfi.S b/arch/arm/mach-mx5/wfi.S
new file mode 100644
index 0000000..adb9a4f
--- /dev/null
+++ b/arch/arm/mach-mx5/wfi.S
@@ -0,0 +1,426 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_AUXCR_L2EN   1 << 1
+/*
+ *	cpu_cortexa8_do_idle()
+ *
+ *	Idle the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_cortexa8_do_idle)
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    ands    r2, r1, #ARM_AUXCR_L2EN @ Check if L2 is disabled
+    beq     SkipL2Access
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    bic     r2, r2, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    bic     r1, r1, #ARM_AUXCR_L2EN  @ Disable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1    @ Update aux control reg
+
+    ldr     r1, =(0x0 << 6)          @ A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2   @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0   @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x00]          @ Save tag info
+
+    ldr     r1, =(0x1 << 6)          @ A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x04]         @ Save tag info
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x08]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x0C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x10]         @ Store data info
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x14]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x18]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x1C]         @ Store data info
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x20]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x24]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x28]         @ Store data info
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x2C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x30]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x34]         @ Store data info
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x38]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x3C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x40]         @ Store data info
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x44]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x48]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x4C]         @ Store data info
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x50]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x54]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x58]         @ Store data info
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x5C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x60]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x64]         @ Store data info
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x68]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x6C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x70]         @ Store data info
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x74]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x78]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x7C]         @ Store data info
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x80]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x84]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x88]         @ Store data info
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x8C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x90]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x94]         @ Store data info
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x98]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x9C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xA0]         @ Store data info
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xA4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xA8]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xAC]         @ Store data info
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xB0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xB4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xB8]         @ Store data info
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xBC]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xC0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xC4]         @ Store data info
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xC8]         @ Save tag info
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xCC]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD0]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD4]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD8]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xDC]         @ Save tag info
+
+    .long     0xe320f003              @ Opcode for WFI
+
+    ldr     r1, =(0x0 << 6)         @ A[6] = 0
+    ldr     r2, [r0, #0x00]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x1 << 6)         @ A[6] = 1
+    ldr     r2, [r0, #0x04]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    ldr     r2, [r0, #0x08]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x0C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x10]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    ldr     r2, [r0, #0x14]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x18]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x1C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    ldr     r2, [r0, #0x20]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x24]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x28]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    ldr     r2, [r0, #0x2C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x30]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x34]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    ldr     r2, [r0, #0x38]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x3C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x40]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    ldr     r2, [r0, #0x44]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x48]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x4C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    ldr     r2, [r0, #0x50]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x54]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x58]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    ldr     r2, [r0, #0x5C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x60]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x64]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    ldr     r2, [r0, #0x68]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x6C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x70]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    ldr     r2, [r0, #0x74]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x78]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x7C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    ldr     r2, [r0, #0x80]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x84]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x88]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    ldr     r2, [r0, #0x8C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x90]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x94]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    ldr     r2, [r0, #0x98]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x9C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xA0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    ldr     r2, [r0, #0xA4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xA8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xAC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    ldr     r2, [r0, #0xB0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xB4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xB8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    ldr     r2, [r0, #0xBC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xC0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xC4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    ldr     r2, [r0, #0xC8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    ldr     r2, [r0, #0xCC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    ldr     r2, [r0, #0xD0]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    ldr     r2, [r0, #0xD4]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    ldr     r2, [r0, #0xD8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    ldr     r2, [r0, #0xDC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    orr     r1, r1, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1   @ Update aux control reg
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    orr     r2, r2, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    b       Done
+
+SkipL2Access:
+    .long     0xe320f003              @ Opcode for WFI
+
+Done:
+    mov		pc, lr
+
+	.type	cortexa8_idle_workaround, #object
+ENTRY(cortexa8_idle_workaround)
+	.word	cpu_cortexa8_do_idle
+	.size	cortexa8_idle_workaround, . - cortexa8_idle_workaround
-- 
1.6.5.2

