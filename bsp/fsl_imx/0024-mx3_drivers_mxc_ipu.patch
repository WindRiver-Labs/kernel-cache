From 201342db44d0b863722c71bf794e33c594640897 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Wed, 29 Oct 2008 16:34:07 +0800
Subject: [PATCH] imx_drivers_mx3_ipu

MX3 Image Processing Unit driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mxc/ipu/Kconfig         |   17 +
 drivers/mxc/ipu/Makefile        |    5 +
 drivers/mxc/ipu/ipu_adc.c       |  707 ++++++++++++++++
 drivers/mxc/ipu/ipu_common.c    | 1731 +++++++++++++++++++++++++++++++++++++++
 drivers/mxc/ipu/ipu_csi.c       |  216 +++++
 drivers/mxc/ipu/ipu_ic.c        |  498 +++++++++++
 drivers/mxc/ipu/ipu_lpmc.c      |  179 ++++
 drivers/mxc/ipu/ipu_param_mem.h |  186 +++++
 drivers/mxc/ipu/ipu_prv.h       |   55 ++
 drivers/mxc/ipu/ipu_regs.h      |  396 +++++++++
 drivers/mxc/ipu/ipu_sdc.c       |  356 ++++++++
 drivers/mxc/ipu/pf/Kconfig      |    7 +
 drivers/mxc/ipu/pf/Makefile     |    2 +
 drivers/mxc/ipu/pf/mxc_pf.c     |  937 +++++++++++++++++++++
 14 files changed, 5292 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/ipu/Kconfig
 create mode 100644 drivers/mxc/ipu/Makefile
 create mode 100644 drivers/mxc/ipu/ipu_adc.c
 create mode 100644 drivers/mxc/ipu/ipu_common.c
 create mode 100644 drivers/mxc/ipu/ipu_csi.c
 create mode 100644 drivers/mxc/ipu/ipu_ic.c
 create mode 100644 drivers/mxc/ipu/ipu_lpmc.c
 create mode 100644 drivers/mxc/ipu/ipu_param_mem.h
 create mode 100644 drivers/mxc/ipu/ipu_prv.h
 create mode 100644 drivers/mxc/ipu/ipu_regs.h
 create mode 100644 drivers/mxc/ipu/ipu_sdc.c
 create mode 100644 drivers/mxc/ipu/pf/Kconfig
 create mode 100644 drivers/mxc/ipu/pf/Makefile
 create mode 100644 drivers/mxc/ipu/pf/mxc_pf.c

diff --git a/drivers/mxc/ipu/Kconfig b/drivers/mxc/ipu/Kconfig
new file mode 100644
index 0000000..0d59a3d
--- /dev/null
+++ b/drivers/mxc/ipu/Kconfig
@@ -0,0 +1,17 @@
+menu "MXC IPU"
+
+config MXC_IPU
+	bool "MXC Image Processing Unit"
+	depends on ARCH_MX3
+	help
+	  If you plan to use the Image Processing unit in the MXC, say
+	  Y here. If unsure, select Y.
+
+config MXC_IPU_LPMC
+	bool
+	depends on MXC_IPU
+	default n
+
+source "drivers/mxc/ipu/pf/Kconfig"
+
+endmenu
diff --git a/drivers/mxc/ipu/Makefile b/drivers/mxc/ipu/Makefile
new file mode 100644
index 0000000..205cb2e
--- /dev/null
+++ b/drivers/mxc/ipu/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_MXC_IPU) += mxc_ipu.o
+
+mxc_ipu-objs := ipu_common.o ipu_sdc.o ipu_adc.o ipu_ic.o ipu_csi.o ipu_lpmc.o
+
+obj-$(CONFIG_MXC_IPU_PF)        +=   pf/
diff --git a/drivers/mxc/ipu/ipu_adc.c b/drivers/mxc/ipu/ipu_adc.c
new file mode 100644
index 0000000..1a42eb6
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_adc.c
@@ -0,0 +1,707 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_adc.c
+ *
+ * @brief IPU ADC functions
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/* M3IF Snooping Configuration Register 0 (M3IFSCFG0) READ/WRITE*/
+#define M3IFSCFG0 IO_ADDRESS(M3IF_BASE_ADDR + 0x28)
+/* M3IF Snooping Configuration Register 1 (M3IFSCFG1) READ/WRITE*/
+#define M3IFSCFG1 IO_ADDRESS(M3IF_BASE_ADDR + 0x2C)
+/* M3IF Snooping Configuration Register 2 (M3IFSCFG2) READ/WRITE*/
+#define M3IFSCFG2 IO_ADDRESS(M3IF_BASE_ADDR + 0x30)
+/* M3IF Snooping Status Register 0 (M3IFSSR0) READ/WRITE */
+#define M3IFSSR0 IO_ADDRESS(M3IF_BASE_ADDR + 0x34)
+/* M3IF Snooping Status Register 1 (M3IFSSR1) */
+#define M3IFSSR1 IO_ADDRESS(M3IF_BASE_ADDR + 0x38)
+
+/*#define ADC_CHAN1_SA_MASK 0xFF800000 */
+
+static void _ipu_set_cmd_data_mappings(display_port_t disp,
+				       uint32_t pixel_fmt, int ifc_width);
+
+int32_t _ipu_adc_init_channel(ipu_channel_t chan, display_port_t disp,
+			      mcu_mode_t cmd, int16_t x_pos, int16_t y_pos)
+{
+	uint32_t reg;
+	uint32_t start_addr, stride;
+	uint32_t lock_flags;
+	uint32_t size;
+
+	size = 0;
+
+	switch (disp) {
+	case DISP0:
+		reg = __raw_readl(ADC_DISP0_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	case DISP1:
+		reg = __raw_readl(ADC_DISP1_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	case DISP2:
+		reg = __raw_readl(ADC_DISP2_CONF);
+		stride = reg & ADC_DISP_CONF_SL_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (stride == 0)
+		return -EINVAL;
+
+	stride++;
+	start_addr = (y_pos * stride) + x_pos;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	reg = __raw_readl(ADC_CONF);
+
+	switch (chan) {
+	case ADC_SYS1:
+		reg &= ~0x00FF4000;
+		reg |=
+		    ((uint32_t) size << 21 | (uint32_t) disp << 19 | (uint32_t)
+		     cmd << 16);
+
+		__raw_writel(start_addr, ADC_SYSCHA1_SA);
+		break;
+
+	case ADC_SYS2:
+		reg &= ~0xFF008000;
+		reg |=
+		    ((uint32_t) size << 29 | (uint32_t) disp << 27 | (uint32_t)
+		     cmd << 24);
+
+		__raw_writel(start_addr, ADC_SYSCHA2_SA);
+		break;
+
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+		reg &= ~0x000000F9;
+		reg |=
+		    ((uint32_t) size << 5 | (uint32_t) disp << 3 |
+		     ADC_CONF_PRP_EN);
+
+		__raw_writel(start_addr, ADC_PRPCHAN_SA);
+		break;
+
+	case MEM_PP_ADC:
+		reg &= ~0x00003F02;
+		reg |=
+		    ((uint32_t) size << 10 | (uint32_t) disp << 8 |
+		     ADC_CONF_PP_EN);
+
+		__raw_writel(start_addr, ADC_PPCHAN_SA);
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -1;
+		break;
+	}
+	__raw_writel(reg, ADC_CONF);
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+
+int32_t _ipu_adc_uninit_channel(ipu_channel_t chan)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	reg = __raw_readl(ADC_CONF);
+
+	switch (chan) {
+	case ADC_SYS1:
+		reg &= ~0x00FF4000;
+		break;
+	case ADC_SYS2:
+		reg &= ~0xFF008000;
+		break;
+	case CSI_PRP_VF_ADC:
+	case MEM_PRP_VF_ADC:
+		reg &= ~0x000000F9;
+		break;
+	case MEM_PP_ADC:
+		reg &= ~0x00003F02;
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -1;
+		break;
+	}
+	__raw_writel(reg, ADC_CONF);
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t *pCmd, bool write)
+{
+	uint32_t ima_addr = 0;
+	uint32_t row_nu;
+	int i;
+
+	/* Set IPU_IMA_ADDR (IPU Internal Memory Access Address) */
+	if (write)
+		row_nu = (uint32_t) disp * 2 * ATM_ADDR_RANGE;
+	else
+		row_nu = ((uint32_t) disp * 2 + 1) * ATM_ADDR_RANGE;
+
+	/* form template addr for IPU_IMA_ADDR */
+	ima_addr = (0x3 << 16 /*Template memory */  | row_nu << 3);
+
+	__raw_writel(ima_addr, IPU_IMA_ADDR);
+
+	/* write template data for IPU_IMA_DATA */
+	for (i = 0; i < TEMPLATE_BUF_SIZE; i++)
+		/* only DATA field are needed */
+		__raw_writel(pCmd[i], IPU_IMA_DATA);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_write_template);
+
+int32_t
+ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+		  uint32_t cmd, const uint32_t *params, uint16_t numParams)
+{
+	uint16_t i;
+
+	__raw_writel((uint32_t) ((type ? 0x0 : 0x1) | disp << 1 | 0x10),
+		     DI_DISP_LLA_CONF);
+	__raw_writel(cmd, DI_DISP_LLA_DATA);
+	udelay(3);
+
+	__raw_writel((uint32_t) (0x10 | disp << 1 | 0x11), DI_DISP_LLA_CONF);
+	for (i = 0; i < numParams; i++) {
+		__raw_writel(params[i], DI_DISP_LLA_DATA);
+		udelay(3);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_write_cmd);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t *size)
+{
+	int32_t err = 0;
+	uint32_t ref_per, reg, src = 0;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPU_FS_DISP_FLOW);
+	reg &= ~FS_AUTO_REF_PER_MASK;
+	switch (mode) {
+	case IPU_ADC_REFRESH_NONE:
+		src = 0;
+		break;
+	case IPU_ADC_AUTO_REFRESH:
+		if (refresh_rate == 0) {
+			err = -EINVAL;
+			goto err0;
+		}
+		ref_per = (refresh_rate * g_ipu_clk) / 217;
+		ref_per--;
+		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
+
+		src = FS_SRC_AUTOREF;
+		break;
+	case IPU_ADC_AUTO_REFRESH_SNOOP:
+		if (refresh_rate == 0) {
+			err = -EINVAL;
+			goto err0;
+		}
+		ref_per = (refresh_rate * g_ipu_clk) / 217;
+		ref_per--;
+		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
+
+		src = FS_SRC_AUTOREF_SNOOP;
+		break;
+	case IPU_ADC_SNOOPING:
+		src = FS_SRC_SNOOP;
+		break;
+	}
+
+	switch (channel) {
+	case ADC_SYS1:
+		reg &= ~FS_ADC1_SRC_SEL_MASK;
+		reg |= src << FS_ADC1_SRC_SEL_OFFSET;
+		break;
+	case ADC_SYS2:
+		reg &= ~FS_ADC2_SRC_SEL_MASK;
+		reg |= src << FS_ADC2_SRC_SEL_OFFSET;
+		break;
+	default:
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+	__raw_writel(reg, IPU_FS_DISP_FLOW);
+
+	/* Setup M3IF for snooping */
+	if ((mode == IPU_ADC_AUTO_REFRESH_SNOOP) ||
+			(mode == IPU_ADC_SNOOPING)) {
+		uint32_t msb;
+		uint32_t seg_size;
+		uint32_t window_size;
+		int i;
+
+		if ((addr == 0) || (size == NULL) || (*size == 0)) {
+			err = -EINVAL;
+			goto err0;
+		}
+
+		msb = fls(*size);
+		if (!(*size & ((1UL << msb) - 1)))
+			msb--;	/* Already aligned to power 2 */
+		if (msb < 11)
+			msb = 11;
+
+		window_size = (1UL << msb);
+		seg_size = window_size / 64;
+
+		msb -= 11;
+
+		reg = addr & ~((1UL << msb) - 1);
+		reg |= msb << 1;
+		reg |= 1;	/* enable snooping */
+		__raw_writel(reg, M3IFSCFG0);
+
+		reg = 0;
+		for (i = 0; i < 32; i++) {
+			if (i * seg_size >= *size)
+				break;
+			reg |= 1UL << i;
+		}
+		__raw_writel(reg, M3IFSCFG1);
+
+		reg = 0;
+		for (i = 32; i < 64; i++) {
+			if (i * seg_size >= *size)
+				break;
+			reg |= 1UL << (i - 32);
+		}
+		__raw_writel(reg, M3IFSCFG2);
+
+		*size = window_size;
+
+		dev_dbg(g_ipu_dev,
+			"Snooping enabled: window size = 0x%X,"
+			"M3IFSCFG0=0x%08X, M3IFSCFG1=0x%08X,"
+			"M3IFSCFG2=0x%08X\n",
+			window_size, __raw_readl(M3IFSCFG0),
+			__raw_readl(M3IFSCFG1), __raw_readl(M3IFSCFG2));
+	}
+
+err0:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return err;
+}
+EXPORT_SYMBOL(ipu_adc_set_update_mode);
+
+int32_t ipu_adc_get_snooping_status(uint32_t *statl, uint32_t *stath)
+{
+	*statl = __raw_readl(M3IFSSR0);
+	*stath = __raw_readl(M3IFSSR1);
+	/* DPRINTK("status = 0x%08X%08X\n", stat[1], stat[0]); */
+
+	__raw_writel(0x0, M3IFSSR0);
+	__raw_writel(0x0, M3IFSSR1);
+	return 0;
+}
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode)
+{
+	uint32_t temp;
+	uint32_t lock_flags;
+	uint32_t ser_conf;
+	uint32_t disp_conf;
+	uint32_t adc_disp_conf;
+	uint32_t adc_disp_vsync;
+	uint32_t old_pol;
+
+	if ((disp != DISP1) && (disp != DISP2) &&
+	    (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL)) {
+		return -EINVAL;
+	}
+	adc_disp_conf = (uint32_t) addr << 12 | (stride - 1);
+
+	_ipu_set_cmd_data_mappings(disp, pixel_fmt, sig.ifc_width);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+	disp_conf = __raw_readl(DI_DISP_IF_CONF);
+	old_pol = __raw_readl(DI_DISP_SIG_POL);
+	adc_disp_vsync = __raw_readl(ADC_DISP_VSYNC);
+
+	switch (disp) {
+	case DISP0:
+		__raw_writel(adc_disp_conf, ADC_DISP0_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP0_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D0_MODE_MASK |
+				    ADC_DISP_VSYNC_D0_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x2000003FL;
+		old_pol |= sig.data_pol | sig.cs_pol << 1 |
+		    sig.addr_pol << 2 | sig.read_pol << 3 |
+		    sig.write_pol << 4 | sig.Vsync_pol << 5 |
+		    sig.burst_pol << 29;
+		__raw_writel(old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x0000001FL;
+		disp_conf |= (sig.burst_mode << 3) | (sig.ifc_mode << 1) |
+		    DI_CONF_DISP0_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	case DISP1:
+		__raw_writel(adc_disp_conf, ADC_DISP1_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP12_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D12_MODE_MASK |
+				    ADC_DISP_VSYNC_D12_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x4000FF00L;
+		old_pol |= (sig.Vsync_pol << 6 | sig.data_pol << 8 |
+			    sig.cs_pol << 9 | sig.addr_pol << 10 |
+			    sig.read_pol << 11 | sig.write_pol << 12 |
+			    sig.clk_pol << 14 | sig.burst_pol << 30);
+		__raw_writel(old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x00003F00L;
+		if (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL) {
+			ser_conf = (sig.ifc_width - 1) <<
+			    DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET;
+			if (sig.ser_preamble_len) {
+				ser_conf |= DI_SER_DISPx_CONF_PREAMBLE_EN;
+				ser_conf |= sig.ser_preamble <<
+				    DI_SER_DISPx_CONF_PREAMBLE_OFFSET;
+				ser_conf |= (sig.ser_preamble_len - 1) <<
+				    DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET;
+			}
+
+			ser_conf |=
+			    sig.ser_rw_mode << DI_SER_DISPx_CONF_RW_CFG_OFFSET;
+
+			if (sig.burst_mode == IPU_ADC_BURST_SERIAL)
+				ser_conf |= DI_SER_DISPx_CONF_BURST_MODE_EN;
+			__raw_writel(ser_conf, DI_SER_DISP1_CONF);
+		} else {	/* parallel interface */
+			disp_conf |= (uint32_t) (sig.burst_mode << 12);
+		}
+		disp_conf |= (sig.ifc_mode << 9) | DI_CONF_DISP1_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	case DISP2:
+		__raw_writel(adc_disp_conf, ADC_DISP2_CONF);
+		__raw_writel((((height - 1) << 16) | (width - 1)),
+			     ADC_DISP12_SS);
+
+		adc_disp_vsync &= ~(ADC_DISP_VSYNC_D12_MODE_MASK |
+				    ADC_DISP_VSYNC_D12_WIDTH_MASK);
+		adc_disp_vsync |= (vsync_width << 16) | (uint32_t) mode;
+
+		old_pol &= ~0x80FF0000L;
+		temp = (uint32_t) (sig.data_pol << 16 | sig.cs_pol << 17 |
+				   sig.addr_pol << 18 | sig.read_pol << 19 |
+				   sig.write_pol << 20 | sig.Vsync_pol << 6 |
+				   sig.burst_pol << 31 | sig.clk_pol << 22);
+		__raw_writel(temp | old_pol, DI_DISP_SIG_POL);
+
+		disp_conf &= ~0x003F0000L;
+		if (sig.ifc_mode >= IPU_ADC_IFC_MODE_3WIRE_SERIAL) {
+			ser_conf = (sig.ifc_width - 1) <<
+			    DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET;
+			if (sig.ser_preamble_len) {
+				ser_conf |= DI_SER_DISPx_CONF_PREAMBLE_EN;
+				ser_conf |= sig.ser_preamble <<
+				    DI_SER_DISPx_CONF_PREAMBLE_OFFSET;
+				ser_conf |= (sig.ser_preamble_len - 1) <<
+				    DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET;
+
+			}
+
+			ser_conf |=
+			    sig.ser_rw_mode << DI_SER_DISPx_CONF_RW_CFG_OFFSET;
+
+			if (sig.burst_mode == IPU_ADC_BURST_SERIAL)
+				ser_conf |= DI_SER_DISPx_CONF_BURST_MODE_EN;
+			__raw_writel(ser_conf, DI_SER_DISP2_CONF);
+		} else {	/* parallel interface */
+			disp_conf |= (uint32_t) (sig.burst_mode << 20);
+		}
+		disp_conf |= (sig.ifc_mode << 17) | DI_CONF_DISP2_EN;
+		__raw_writel(disp_conf, DI_DISP_IF_CONF);
+		break;
+	default:
+		break;
+	}
+
+	__raw_writel(adc_disp_vsync, ADC_DISP_VSYNC);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_init_panel);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk)
+{
+	uint32_t reg;
+	uint32_t time_conf3 = 0;
+	uint32_t clk_per;
+	uint32_t up_per;
+	uint32_t down_per;
+	uint32_t read_per;
+	uint32_t pixclk_per = 0;
+
+	clk_per = (cycle_time * (g_ipu_clk / 1000L) * 16L) / 1000000L;
+	up_per = (up_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
+	down_per = (down_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
+
+	reg = (clk_per << DISPx_IF_CLK_PER_OFFSET) |
+	    (up_per << DISPx_IF_CLK_UP_OFFSET) |
+	    (down_per << DISPx_IF_CLK_DOWN_OFFSET);
+
+	if (read) {
+		read_per =
+		    (read_latch_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
+		if (pixel_clk)
+			pixclk_per = (g_ipu_clk * 16L) / pixel_clk;
+		time_conf3 = (read_per << DISPx_IF_CLK_READ_EN_OFFSET) |
+		    (pixclk_per << DISPx_PIX_CLK_PER_OFFSET);
+	}
+
+	dev_dbg(g_ipu_dev, "DI_DISPx_TIME_CONF_1/2 = 0x%08X\n", reg);
+	dev_dbg(g_ipu_dev, "DI_DISPx_TIME_CONF_3 = 0x%08X\n", time_conf3);
+
+	switch (disp) {
+	case DISP0:
+		if (read) {
+			__raw_writel(reg, DI_DISP0_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP0_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP0_TIME_CONF_1);
+		}
+		break;
+	case DISP1:
+		if (read) {
+			__raw_writel(reg, DI_DISP1_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP1_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP1_TIME_CONF_1);
+		}
+		break;
+	case DISP2:
+		if (read) {
+			__raw_writel(reg, DI_DISP2_TIME_CONF_2);
+			__raw_writel(time_conf3, DI_DISP2_TIME_CONF_3);
+		} else {
+			__raw_writel(reg, DI_DISP2_TIME_CONF_1);
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_adc_init_ifc_timing);
+
+struct ipu_adc_di_map {
+	uint32_t map_byte1;
+	uint32_t map_byte2;
+	uint32_t map_byte3;
+	uint32_t cycle_cnt;
+};
+
+static const struct ipu_adc_di_map di_mappings[] = {
+	[0] = {
+	       /* RGB888, 8-bit bus */
+	       .map_byte1 = 0x1600AAAA,
+	       .map_byte2 = 0x00E05555,
+	       .map_byte2 = 0x00070000,
+	       .cycle_cnt = 3,
+	       },
+	[1] = {
+	       /* RGB666, 8-bit bus */
+	       .map_byte1 = 0x1C00AAAF,
+	       .map_byte2 = 0x00E0555F,
+	       .map_byte3 = 0x0007000F,
+	       .cycle_cnt = 3,
+	       },
+	[2] = {
+	       /* RGB565, 8-bit bus */
+	       .map_byte1 = 0x008055BF,
+	       .map_byte2 = 0x0142015F,
+	       .map_byte3 = 0x0007003F,
+	       .cycle_cnt = 2,
+	       },
+	[3] = {
+	       /* RGB888, 24-bit bus */
+	       .map_byte1 = 0x0007000F,
+	       .map_byte2 = 0x000F000F,
+	       .map_byte3 = 0x0017000F,
+	       .cycle_cnt = 1,
+	       },
+	[4] = {
+	       /* RGB666, 18-bit bus */
+	       .map_byte1 = 0x0005000F,
+	       .map_byte2 = 0x000B000F,
+	       .map_byte3 = 0x0011000F,
+	       .cycle_cnt = 1,
+	       },
+	[5] = {
+	       /* RGB565, 16-bit bus */
+	       .map_byte1 = 0x0004003F,
+	       .map_byte2 = 0x000A000F,
+	       .map_byte3 = 0x000F003F,
+	       .cycle_cnt = 1,
+	       },
+};
+
+/* Private methods */
+static void _ipu_set_cmd_data_mappings(display_port_t disp,
+				       uint32_t pixel_fmt, int ifc_width)
+{
+	uint32_t reg;
+	u32 map = 0;
+
+	if (ifc_width == 8) {
+		switch (pixel_fmt) {
+		case IPU_PIX_FMT_BGR24:
+			map = 0;
+			break;
+		case IPU_PIX_FMT_RGB666:
+			map = 1;
+			break;
+		case IPU_PIX_FMT_RGB565:
+			map = 2;
+			break;
+		default:
+			break;
+		}
+	} else if (ifc_width >= 16) {
+		switch (pixel_fmt) {
+		case IPU_PIX_FMT_BGR24:
+			map = 3;
+			break;
+		case IPU_PIX_FMT_RGB666:
+			map = 4;
+			break;
+		case IPU_PIX_FMT_RGB565:
+			map = 5;
+			break;
+		default:
+			break;
+		}
+	}
+
+	switch (disp) {
+	case DISP0:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP0_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP0_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP0_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP0_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP0_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP0_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP0_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP0_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP0_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	case DISP1:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP1_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP1_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP1_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP1_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP1_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP1_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP1_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP1_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP1_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	case DISP2:
+		if (ifc_width == 8) {
+			__raw_writel(0x00070000, DI_DISP2_CB0_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB2_MAP);
+		} else {
+			__raw_writel(0x00070000, DI_DISP2_CB0_MAP);
+			__raw_writel(0x000F0000, DI_DISP2_CB1_MAP);
+			__raw_writel(0x0000FFFF, DI_DISP2_CB2_MAP);
+		}
+		__raw_writel(di_mappings[map].map_byte1, DI_DISP2_DB0_MAP);
+		__raw_writel(di_mappings[map].map_byte2, DI_DISP2_DB1_MAP);
+		__raw_writel(di_mappings[map].map_byte3, DI_DISP2_DB2_MAP);
+		reg = __raw_readl(DI_DISP_ACC_CC);
+		reg &= ~DISP2_IF_CLK_CNT_D_MASK;
+		reg |= (di_mappings[map].cycle_cnt - 1) <<
+		    DISP2_IF_CLK_CNT_D_OFFSET;
+		__raw_writel(reg, DI_DISP_ACC_CC);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/drivers/mxc/ipu/ipu_common.c b/drivers/mxc/ipu/ipu_common.c
new file mode 100644
index 0000000..c48f209
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_common.c
@@ -0,0 +1,1731 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_common.c
+ *
+ * @brief This file contains the IPU driver common API functions.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/clock.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+/*
+ * This type definition is used to define a node
+ * in the GPIO interrupt queue for
+ * registered interrupts for GPIO pins.
+ * Each node contains the GPIO signal number
+ * associated with the ISR and the actual ISR function pointer.
+ */
+struct ipu_irq_node {
+	irqreturn_t(*handler) (int, void *);	/*!< the ISR */
+	const char *name;	/*!< device associated with the interrupt */
+	void *dev_id;		/*!< some unique information for the ISR */
+	__u32 flags;		/*!< not used */
+};
+
+/* Globals */
+uint32_t g_ipu_clk;
+uint32_t g_ipu_csi_clk;
+int g_ipu_irq[2];
+int g_ipu_hw_rev;
+bool g_sec_chan_en[21];
+uint32_t g_channel_init_mask;
+DEFINE_SPINLOCK(ipu_lock);
+struct device *g_ipu_dev;
+
+static struct ipu_irq_node ipu_irq_list[IPU_IRQ_COUNT];
+static const char driver_name[] = "mxc_ipu";
+
+/* Static functions */
+static irqreturn_t ipu_irq_handler(int irq, void *desc);
+static void _ipu_pf_init(ipu_channel_params_t *params);
+static void _ipu_pf_uninit(void);
+
+static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
+{
+	return (type == IPU_INPUT_BUFFER) ? ((uint32_t) ch & 0xFF) :
+		((type == IPU_OUTPUT_BUFFER) ? (((uint32_t) ch >> 8) & 0xFF)
+		 : (((uint32_t) ch >> 16) & 0xFF));
+};
+
+static inline uint32_t DMAParamAddr(uint32_t dma_ch)
+{
+	return 0x10000 | (dma_ch << 4);
+};
+
+/*!
+ * This function is called by the driver framework to initialize the IPU
+ * hardware.
+ *
+ * @param       dev       The device structure for the IPU passed in by the framework.
+ *
+ * @return      This function returns 0 on success or negative error code on error
+ */
+static
+int ipu_probe(struct platform_device *pdev)
+{
+	struct mxc_ipu_config *ipu_conf = pdev->dev.platform_data;
+
+	spin_lock_init(&ipu_lock);
+
+	g_ipu_dev = &pdev->dev;
+	g_ipu_hw_rev = ipu_conf->rev;
+
+	/* Register IPU interrupts */
+	g_ipu_irq[0] = platform_get_irq(pdev, 0);
+	if (g_ipu_irq[0] < 0)
+		return -EINVAL;
+
+	if (request_irq(g_ipu_irq[0], ipu_irq_handler,
+				0, driver_name, 0) != 0) {
+		dev_err(g_ipu_dev, "request SYNC interrupt failed\n");
+		return -EBUSY;
+	}
+	/* Some platforms have 2 IPU interrupts */
+	g_ipu_irq[1] = platform_get_irq(pdev, 1);
+	if (g_ipu_irq[1] >= 0) {
+		if (request_irq
+		    (g_ipu_irq[1], ipu_irq_handler, 0, driver_name, 0) != 0) {
+			dev_err(g_ipu_dev, "request ERR interrupt failed\n");
+			return -EBUSY;
+		}
+	}
+
+	/* Enable IPU and CSI clocks */
+	/* Get IPU clock freq */
+	mxc_clks_enable(IPU_CLK);
+	g_ipu_clk = mxc_get_clocks(IPU_CLK);
+	dev_dbg(g_ipu_dev, "g_ipu_clk = %d\n", g_ipu_clk);
+
+	__raw_writel(0x00100010L, DI_HSP_CLK_PER);
+
+	/* Set SDC refresh channels as high priority */
+	__raw_writel(0x0000C000L, IDMAC_CHA_PRI);
+
+	/* Set to max back to back burst requests */
+	__raw_writel(0x00000070L, IDMAC_CONF);
+
+	return 0;
+}
+
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to initalize.
+ *
+ * @param       params  Input parameter containing union of channel initialization
+ *                      parameters.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	uint32_t ipu_conf;
+	uint32_t reg;
+	uint32_t lock_flags;
+
+	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	if ((channel != MEM_SDC_BG) && (channel != MEM_SDC_FG) &&
+	    (channel != MEM_ROT_ENC_MEM) && (channel != MEM_ROT_VF_MEM) &&
+	    (channel != MEM_ROT_PP_MEM) && (channel != CSI_MEM)
+	    && (params == NULL))
+		return -EINVAL;
+
+	if (g_channel_init_mask & (1L << IPU_CHAN_ID(channel)))
+		dev_err(g_ipu_dev, "Warning: channel already initialized\n");
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	g_channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+
+	/* Enable IPU sub module */
+	ipu_conf = __raw_readl(IPU_CONF);
+	if (g_channel_init_mask & 0x00000066L)
+		/*CSI */
+		ipu_conf |= IPU_CONF_CSI_EN;
+	if (g_channel_init_mask & 0x00001FFFL)
+		/*IC */
+		ipu_conf |= IPU_CONF_IC_EN;
+	if (g_channel_init_mask & 0x00000A10L)
+		/*ROT */
+		ipu_conf |= IPU_CONF_ROT_EN;
+	if (g_channel_init_mask & 0x0001C000L)
+		/*SDC */
+		ipu_conf |= IPU_CONF_SDC_EN | IPU_CONF_DI_EN;
+	if (g_channel_init_mask & 0x00061140L)
+		/*ADC */
+		ipu_conf |= IPU_CONF_ADC_EN | IPU_CONF_DI_EN;
+	if (g_channel_init_mask & 0x00380000L)
+		/*PF */
+		ipu_conf |= IPU_CONF_PF_EN;
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	switch (channel) {
+	case CSI_PRP_VF_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_VF_IN_VALID, IPU_FS_PROC_FLOW);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case CSI_PRP_VF_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | (FS_DEST_ADC << FS_PRPVF_DEST_SEL_OFFSET),
+			     IPU_FS_PROC_FLOW);
+
+		_ipu_adc_init_channel(CSI_PRP_VF_ADC,
+				      params->csi_prp_vf_adc.disp,
+				      WriteTemplateNonSeq,
+				      params->csi_prp_vf_adc.out_left,
+				      params->csi_prp_vf_adc.out_top);
+
+		_ipu_ic_init_prpvf(params, true);
+		break;
+	case MEM_PRP_VF_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | FS_VF_IN_VALID, IPU_FS_PROC_FLOW);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, false);
+		break;
+	case MEM_ROT_VF_MEM:
+		_ipu_ic_init_rotate_vf(params);
+		break;
+	case CSI_PRP_ENC_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW);
+		_ipu_ic_init_prpenc(params, true);
+		break;
+	case MEM_PRP_ENC_MEM:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | FS_ENC_IN_VALID, IPU_FS_PROC_FLOW);
+		_ipu_ic_init_prpenc(params, false);
+		break;
+	case MEM_ROT_ENC_MEM:
+		_ipu_ic_init_rotate_enc(params);
+		break;
+	case MEM_PP_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg | (FS_DEST_ADC << FS_PP_DEST_SEL_OFFSET),
+			     IPU_FS_PROC_FLOW);
+
+		_ipu_adc_init_channel(MEM_PP_ADC, params->mem_pp_adc.disp,
+				      WriteTemplateNonSeq,
+				      params->mem_pp_adc.out_left,
+				      params->mem_pp_adc.out_top);
+
+		if (params->mem_pp_adc.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_pp(params);
+		break;
+	case MEM_PP_MEM:
+		if (params->mem_pp_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_pp(params);
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_init_rotate_pp(params);
+		break;
+	case CSI_MEM:
+		_ipu_ic_init_csi(params);
+		break;
+
+	case MEM_PF_Y_MEM:
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		/* Enable PF block */
+		_ipu_pf_init(params);
+		break;
+
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		_ipu_adc_init_channel(ADC_SYS1, params->adc_sys1.disp,
+				      params->adc_sys1.ch_mode,
+				      params->adc_sys1.out_left,
+				      params->adc_sys1.out_top);
+		break;
+	case ADC_SYS2:
+		_ipu_adc_init_channel(ADC_SYS2, params->adc_sys2.disp,
+				      params->adc_sys2.ch_mode,
+				      params->adc_sys2.out_left,
+				      params->adc_sys2.out_top);
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel);
+
+/*!
+ * This function is called to uninitialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to uninitalize.
+ */
+void ipu_uninit_channel(ipu_channel_t channel)
+{
+	uint32_t lock_flags;
+	uint32_t reg;
+
+	if ((g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already uninitialized\n");
+		return;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	g_channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	g_sec_chan_en[IPU_CHAN_ID(channel)] = false;
+
+	/* Make sure channel is disabled */
+	/* ipu_disable_channel(channel, false); */
+
+	switch (channel) {
+	case CSI_MEM:
+		_ipu_ic_uninit_csi();
+		break;
+	case CSI_PRP_VF_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_PRPVF_DEST_SEL_MASK, IPU_FS_PROC_FLOW);
+
+		_ipu_adc_uninit_channel(CSI_PRP_VF_ADC);
+
+		/* Fall thru */
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_MEM:
+		_ipu_ic_uninit_prpvf();
+		break;
+	case MEM_PRP_VF_ADC:
+		break;
+	case MEM_ROT_VF_MEM:
+		_ipu_ic_uninit_rotate_vf();
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		_ipu_ic_uninit_prpenc();
+		break;
+	case MEM_ROT_ENC_MEM:
+		_ipu_ic_uninit_rotate_enc();
+		break;
+	case MEM_PP_ADC:
+		reg = __raw_readl(IPU_FS_PROC_FLOW);
+		__raw_writel(reg & ~FS_PP_DEST_SEL_MASK, IPU_FS_PROC_FLOW);
+
+		_ipu_adc_uninit_channel(MEM_PP_ADC);
+
+		/* Fall thru */
+	case MEM_PP_MEM:
+		_ipu_ic_uninit_pp();
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_uninit_rotate_pp();
+		break;
+
+	case MEM_PF_Y_MEM:
+		_ipu_pf_uninit();
+		break;
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		break;
+
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		_ipu_adc_uninit_channel(ADC_SYS1);
+		break;
+	case ADC_SYS2:
+		_ipu_adc_uninit_channel(ADC_SYS2);
+		break;
+	case MEM_SDC_MASK:
+	case CHAN_NONE:
+		break;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_uninit_channel);
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer. Pixel
+ *                              format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input
+ *                              buffers of rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		       	private u offset for additional cropping,
+ *		zero if not used.
+ *
+ * @param       v		       	private v offset for additional cropping,
+ *		zero if not used.
+ *
+ * @return      This function returns 0 on success or
+ * negative error code on fail
+ */
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u, uint32_t v)
+{
+	uint32_t params[10];
+	uint32_t lock_flags;
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t stride_bytes;
+
+	dma_chan = channel_2_dma(channel, type);
+	stride_bytes = stride * bytes_per_pixel(pixel_fmt);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (stride_bytes % 4) {
+		dev_err(g_ipu_dev,
+			"Stride length must be 32-bit aligned,"
+			"stride = %d, bytes = %d\n",
+			stride, stride_bytes);
+		return -EINVAL;
+	}
+	/* IC channels' stride must be multiple of 8 pixels     */
+	if ((dma_chan <= 13) && (stride % 8)) {
+		dev_err(g_ipu_dev, "Stride must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_set_size(params, pixel_fmt, width, height, stride_bytes,
+			       u, v);
+	_ipu_ch_param_set_buffer(params, phyaddr_0, phyaddr_1);
+	_ipu_ch_param_set_rotation(params, rot_mode);
+	/* Some channels (rotation) have restriction on burst length */
+	if ((dma_chan == 10) || (dma_chan == 11) || (dma_chan == 13)) {
+		_ipu_ch_param_set_burst_size(params, 8);
+	} else if (dma_chan == 24) {	/* PF QP channel */
+		_ipu_ch_param_set_burst_size(params, 4);
+	} else if (dma_chan == 25) {	/* PF H264 BS channel */
+		_ipu_ch_param_set_burst_size(params, 16);
+	} else if (((dma_chan == 14) || (dma_chan == 15)) &&
+		   pixel_fmt == IPU_PIX_FMT_RGB565) {
+		_ipu_ch_param_set_burst_size(params, 16);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	_ipu_write_param_mem(DMAParamAddr(dma_chan), params, 10);
+
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL);
+	if (phyaddr_1)
+		reg |= 1UL << dma_chan;
+	else
+		reg &= ~(1UL << dma_chan);
+	__raw_writel(reg, IPU_CHA_DB_MODE_SEL);
+
+	/* Reset to buffer 0 */
+	__raw_writel(1UL << dma_chan, IPU_CHA_CUR_BUF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer);
+
+/*!
+ * This function is called to update the physical address of a buffer for
+ * a logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number to update.
+ *                              0 or 1 are the only valid values.
+ *
+ * @param       phyaddr         Input parameter buffer physical address.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail. This function will fail if the buffer is set to ready.
+ */
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bufNum == 0) {
+		reg = __raw_readl(IPU_CHA_BUF0_RDY);
+		if (reg & (1UL << dma_chan)) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+			return -EACCES;
+		}
+		__raw_writel(DMAParamAddr(dma_chan) + 0x0008UL, IPU_IMA_ADDR);
+		__raw_writel(phyaddr, IPU_IMA_DATA);
+	} else {
+		reg = __raw_readl(IPU_CHA_BUF1_RDY);
+		if (reg & (1UL << dma_chan)) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+			return -EACCES;
+		}
+		__raw_writel(DMAParamAddr(dma_chan) + 0x0009UL, IPU_IMA_ADDR);
+		__raw_writel(phyaddr, IPU_IMA_DATA);
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	dev_dbg(g_ipu_dev, "IPU: update IDMA ch %d buf %d = 0x%08X\n",
+		dma_chan, bufNum, phyaddr);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_update_channel_buffer);
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_buffer(ipu_channel_t channel, ipu_buffer_t type,
+			  uint32_t bufNum)
+{
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		__raw_writel(1UL << dma_chan, IPU_CHA_BUF0_RDY);
+	} else {
+		/*Mark buffer 1 as ready. */
+		__raw_writel(1UL << dma_chan, IPU_CHA_BUF1_RDY);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_buffer);
+
+/*!
+ * This function links 2 channels together for automatic frame
+ * synchronization. The output of the source channel is linked to the input of
+ * the destination channel.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	uint32_t lock_flags;
+	uint32_t out_dma;
+	uint32_t in_dma;
+	bool isProc;
+	uint32_t value;
+	uint32_t mask;
+	uint32_t offset;
+	uint32_t fs_proc_flow;
+	uint32_t fs_disp_flow;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow = __raw_readl(IPU_FS_PROC_FLOW);
+	fs_disp_flow = __raw_readl(IPU_FS_DISP_FLOW);
+
+	out_dma = (1UL << channel_2_dma(src_ch, IPU_OUTPUT_BUFFER));
+	in_dma = (1UL << channel_2_dma(dest_ch, IPU_INPUT_BUFFER));
+
+	/* PROCESS THE OUTPUT DMA CH */
+	switch (out_dma) {
+		/*VF-> */
+	case IDMA_IC_1:
+		pr_debug("Link VF->");
+		isProc = true;
+		mask = FS_PRPVF_DEST_SEL_MASK;
+		offset = FS_PRPVF_DEST_SEL_OFFSET;
+		 /*->VF_ROT */
+		value = (in_dma == IDMA_IC_11) ? FS_DEST_ROT :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_FG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->ADC1 */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADCDirect */
+		    0;
+		break;
+
+		/*VF_ROT-> */
+	case IDMA_IC_9:
+		pr_debug("Link VF_ROT->");
+		isProc = true;
+		mask = FS_PRPVF_ROT_DEST_SEL_MASK;
+		offset = FS_PRPVF_ROT_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/*->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    0;
+		break;
+
+		/*ENC-> */
+	case IDMA_IC_0:
+		pr_debug("Link ENC->");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (in_dma == IDMA_IC_10) ? FS_PRPENC_DEST_SEL :
+			/*->ENC_ROT	*/
+		    0;
+		break;
+
+		/*PP-> */
+	case IDMA_IC_2:
+		pr_debug("Link PP->");
+		isProc = true;
+		mask = FS_PP_DEST_SEL_MASK;
+		offset = FS_PP_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_13) ? FS_DEST_ROT :
+			/*->PP_ROT */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    /* ->ADCDirect */
+		    0;
+		break;
+
+		/*PP_ROT-> */
+	case IDMA_IC_12:
+		pr_debug("Link PP_ROT->");
+		isProc = true;
+		mask = FS_PP_ROT_DEST_SEL_MASK;
+		offset = FS_PP_ROT_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_5) ? FS_DEST_ROT :
+			/*->PP */
+		    (in_dma == IDMA_ADC_SYS1_WR) ? FS_DEST_ADC1 :
+			/* ->ADC1 */
+		    (in_dma == IDMA_ADC_SYS2_WR) ? FS_DEST_ADC2 :
+			/* ->ADC2 */
+		    (in_dma == IDMA_SDC_BG) ? FS_DEST_SDC_BG :
+			/*->SDC_BG */
+		    (in_dma == IDMA_SDC_FG) ? FS_DEST_SDC_FG :
+			/*->SDC_FG */
+		    0;
+		break;
+
+		/*PF-> */
+	case IDMA_PF_Y_OUT:
+	case IDMA_PF_U_OUT:
+	case IDMA_PF_V_OUT:
+		pr_debug("Link PF->");
+		isProc = true;
+		mask = FS_PF_DEST_SEL_MASK;
+		offset = FS_PF_DEST_SEL_OFFSET;
+		value = (in_dma == IDMA_IC_5) ? FS_PF_DEST_PP :
+		    (in_dma == IDMA_IC_13) ? FS_PF_DEST_ROT : 0;
+		break;
+
+		/* Invalid Chainings: ENC_ROT-> */
+	default:
+		pr_debug("Link Invalid->");
+		value = 0;
+		break;
+
+	}
+
+	if (value) {
+		if (isProc) {
+			fs_proc_flow &= ~mask;
+			fs_proc_flow |= (value << offset);
+		} else {
+			fs_disp_flow &= ~mask;
+			fs_disp_flow |= (value << offset);
+		}
+	} else {
+		dev_err(g_ipu_dev, "Invalid channel chaining %d -> %d\n",
+			out_dma, in_dma);
+		return -EINVAL;
+	}
+
+	/* PROCESS THE INPUT DMA CH */
+	switch (in_dma) {
+		/* ->VF_ROT */
+	case IDMA_IC_11:
+		pr_debug("VF_ROT\n");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (out_dma == IDMA_IC_1) ? FS_PRPVF_ROT_SRC_SEL :
+			/*VF-> */
+		    0;
+		break;
+
+		/* ->ENC_ROT */
+	case IDMA_IC_10:
+		pr_debug("ENC_ROT\n");
+		isProc = true;
+		mask = 0;
+		offset = 0;
+		value = (out_dma == IDMA_IC_0) ? FS_PRPENC_ROT_SRC_SEL :
+			/*ENC-> */
+		    0;
+		break;
+
+		/* ->PP */
+	case IDMA_IC_5:
+		pr_debug("PP\n");
+		isProc = true;
+		mask = FS_PP_SRC_SEL_MASK;
+		offset = FS_PP_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_PF_Y_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_U_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_V_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_IC_12) ? FS_PP_SRC_ROT :
+			/*PP_ROT-> */
+		    0;
+		break;
+
+		/* ->PP_ROT */
+	case IDMA_IC_13:
+		pr_debug("PP_ROT\n");
+		isProc = true;
+		mask = FS_PP_ROT_SRC_SEL_MASK;
+		offset = FS_PP_ROT_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_PF_Y_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_U_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_PF_V_OUT) ? FS_PP_SRC_PF :
+			/*PF-> */
+		    (out_dma == IDMA_IC_2) ? FS_ROT_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->SDC_BG */
+	case IDMA_SDC_BG:
+		pr_debug("SDC_BG\n");
+		isProc = false;
+		mask = FS_SDC_BG_SRC_SEL_MASK;
+		offset = FS_SDC_BG_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->SDC_FG */
+	case IDMA_SDC_FG:
+		pr_debug("SDC_FG\n");
+		isProc = false;
+		mask = FS_SDC_FG_SRC_SEL_MASK;
+		offset = FS_SDC_FG_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->ADC1 */
+	case IDMA_ADC_SYS1_WR:
+		pr_debug("ADC_SYS1\n");
+		isProc = false;
+		mask = FS_ADC1_SRC_SEL_MASK;
+		offset = FS_ADC1_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/* ->ADC2 */
+	case IDMA_ADC_SYS2_WR:
+		pr_debug("ADC_SYS2\n");
+		isProc = false;
+		mask = FS_ADC2_SRC_SEL_MASK;
+		offset = FS_ADC2_SRC_SEL_OFFSET;
+		value = (out_dma == IDMA_IC_9) ? FS_SRC_ROT_VF :
+			/*VF_ROT-> */
+		    (out_dma == IDMA_IC_12) ? FS_SRC_ROT_PP :
+			/*PP_ROT-> */
+		    (out_dma == IDMA_IC_1) ? FS_SRC_VF :
+			/*VF-> */
+		    (out_dma == IDMA_IC_2) ? FS_SRC_PP :
+			/*PP-> */
+		    0;
+		break;
+
+		/*Invalid chains: */
+		/* ->ENC, ->VF, ->PF, ->VF_COMBINE, ->PP_COMBINE */
+	default:
+		pr_debug("Invalid\n");
+		value = 0;
+		break;
+
+	}
+
+	if (value) {
+		if (isProc) {
+			fs_proc_flow &= ~mask;
+			fs_proc_flow |= (value << offset);
+		} else {
+			fs_disp_flow &= ~mask;
+			fs_disp_flow |= (value << offset);
+		}
+	} else {
+		dev_err(g_ipu_dev, "Invalid channel chaining %d -> %d\n",
+			out_dma, in_dma);
+		return -EINVAL;
+	}
+
+	__raw_writel(fs_proc_flow, IPU_FS_PROC_FLOW);
+	__raw_writel(fs_disp_flow, IPU_FS_DISP_FLOW);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_link_channels);
+
+/*!
+ * This function unlinks 2 channels and disables automatic frame
+ * synchronization.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	uint32_t lock_flags;
+	uint32_t out_dma;
+	uint32_t in_dma;
+	uint32_t fs_proc_flow;
+	uint32_t fs_disp_flow;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow = __raw_readl(IPU_FS_PROC_FLOW);
+	fs_disp_flow = __raw_readl(IPU_FS_DISP_FLOW);
+
+	out_dma = (1UL << channel_2_dma(src_ch, IPU_OUTPUT_BUFFER));
+	in_dma = (1UL << channel_2_dma(dest_ch, IPU_INPUT_BUFFER));
+
+	/*clear the src_ch's output destination */
+	switch (out_dma) {
+		/*VF-> */
+	case IDMA_IC_1:
+		pr_debug("Unlink VF->");
+		fs_proc_flow &= ~FS_PRPVF_DEST_SEL_MASK;
+		break;
+
+		/*VF_ROT-> */
+	case IDMA_IC_9:
+		pr_debug("Unlink VF_Rot->");
+		fs_proc_flow &= ~FS_PRPVF_ROT_DEST_SEL_MASK;
+		break;
+
+		/*ENC-> */
+	case IDMA_IC_0:
+		pr_debug("Unlink ENC->");
+		fs_proc_flow &= ~FS_PRPENC_DEST_SEL;
+		break;
+
+		/*PP-> */
+	case IDMA_IC_2:
+		pr_debug("Unlink PP->");
+		fs_proc_flow &= ~FS_PP_DEST_SEL_MASK;
+		break;
+
+		/*PP_ROT-> */
+	case IDMA_IC_12:
+		pr_debug("Unlink PP_ROT->");
+		fs_proc_flow &= ~FS_PP_ROT_DEST_SEL_MASK;
+		break;
+
+		/*PF-> */
+	case IDMA_PF_Y_OUT:
+	case IDMA_PF_U_OUT:
+	case IDMA_PF_V_OUT:
+		pr_debug("Unlink PF->");
+		fs_proc_flow &= ~FS_PF_DEST_SEL_MASK;
+		break;
+
+	default:		/*ENC_ROT->     */
+		pr_debug("Unlink Invalid->");
+		break;
+	}
+
+	/*clear the dest_ch's input source */
+	switch (in_dma) {
+	/*->VF_ROT*/
+	case IDMA_IC_11:
+		pr_debug("VF_ROT\n");
+		fs_proc_flow &= ~FS_PRPVF_ROT_SRC_SEL;
+		break;
+
+	/*->Enc_ROT*/
+	case IDMA_IC_10:
+		pr_debug("ENC_ROT\n");
+		fs_proc_flow &= ~FS_PRPENC_ROT_SRC_SEL;
+		break;
+
+	/*->PP*/
+	case IDMA_IC_5:
+		pr_debug("PP\n");
+		fs_proc_flow &= ~FS_PP_SRC_SEL_MASK;
+		break;
+
+	/*->PP_ROT*/
+	case IDMA_IC_13:
+		pr_debug("PP_ROT\n");
+		fs_proc_flow &= ~FS_PP_ROT_SRC_SEL_MASK;
+		break;
+
+	/*->SDC_FG*/
+	case IDMA_SDC_FG:
+		pr_debug("SDC_FG\n");
+		fs_disp_flow &= ~FS_SDC_FG_SRC_SEL_MASK;
+		break;
+
+	/*->SDC_BG*/
+	case IDMA_SDC_BG:
+		pr_debug("SDC_BG\n");
+		fs_disp_flow &= ~FS_SDC_BG_SRC_SEL_MASK;
+		break;
+
+	/*->ADC1*/
+	case IDMA_ADC_SYS1_WR:
+		pr_debug("ADC_SYS1\n");
+		fs_disp_flow &= ~FS_ADC1_SRC_SEL_MASK;
+		break;
+
+	/*->ADC2*/
+	case IDMA_ADC_SYS2_WR:
+		pr_debug("ADC_SYS2\n");
+		fs_disp_flow &= ~FS_ADC2_SRC_SEL_MASK;
+		break;
+
+		/*->VF, ->ENC, ->VF_COMBINE, ->PP_COMBINE, ->PF*/
+	default:
+		pr_debug("Invalid\n");
+		break;
+	}
+
+	__raw_writel(fs_proc_flow, IPU_FS_PROC_FLOW);
+	__raw_writel(fs_disp_flow, IPU_FS_DISP_FLOW);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_unlink_channels);
+
+/*!
+ * This function enables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_enable_channel(ipu_channel_t channel)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+	uint32_t in_dma;
+	uint32_t sec_dma;
+	uint32_t out_dma;
+	uint32_t chan_mask = 0;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IDMAC_CHA_EN);
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	if (out_dma != IDMA_CHAN_INVALID)
+		reg |= 1UL << out_dma;
+	in_dma = channel_2_dma(channel, IPU_INPUT_BUFFER);
+	if (in_dma != IDMA_CHAN_INVALID)
+		reg |= 1UL << in_dma;
+
+	/* Get secondary input dma channel */
+	if (g_sec_chan_en[IPU_CHAN_ID(channel)]) {
+		sec_dma = channel_2_dma(channel, IPU_SEC_INPUT_BUFFER);
+		if (sec_dma != IDMA_CHAN_INVALID)
+			reg |= 1UL << sec_dma;
+	}
+
+	__raw_writel(reg | chan_mask, IDMAC_CHA_EN);
+
+	switch (channel) {
+	case CSI_PRP_VF_ADC:
+	case CSI_PRP_VF_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPVF_EN, IC_CONF);
+		break;
+	case MEM_PRP_VF_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPVF_EN, IC_CONF);
+		break;
+	case MEM_ROT_VF_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPVF_ROT_EN,
+			     IC_CONF);
+		break;
+	case CSI_PRP_ENC_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPENC_EN, IC_CONF);
+		break;
+	case MEM_PRP_ENC_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPENC_EN, IC_CONF);
+		break;
+	case MEM_ROT_ENC_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PRPENC_ROT_EN,
+			     IC_CONF);
+		break;
+	case MEM_PP_ADC:
+	case MEM_PP_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PP_EN, IC_CONF);
+		break;
+	case MEM_ROT_PP_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_PP_ROT_EN, IC_CONF);
+		break;
+	case CSI_MEM:
+		__raw_writel(__raw_readl(IC_CONF) | IC_CONF_RWS_EN |
+			     IC_CONF_PRPENC_EN, IC_CONF);
+		break;
+
+	case MEM_PF_Y_MEM:
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		break;
+
+	case MEM_SDC_BG:
+		dev_dbg(g_ipu_dev, "Initializing SDC BG\n");
+		_ipu_sdc_bg_init(NULL);
+		break;
+	case MEM_SDC_FG:
+		dev_dbg(g_ipu_dev, "Initializing SDC FG\n");
+		_ipu_sdc_fg_init(NULL);
+		break;
+	case ADC_SYS1:
+/*            __raw_writel(__raw_readl(ADC_CONF) | 0x00030000, ADC_CONF); */
+		break;
+	case ADC_SYS2:
+/*            __raw_writel(__raw_readl(ADC_CONF) | 0x03000000, ADC_CONF); */
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_enable_channel);
+
+/*!
+ * This function disables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       wait_for_stop   Flag to set whether to wait for channel end
+ *                              of frame or return immediately.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+	uint32_t sec_dma;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t chan_mask = 0;
+	uint32_t ipu_conf;
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	if (out_dma != IDMA_CHAN_INVALID)
+		chan_mask = 1UL << out_dma;
+	in_dma = channel_2_dma(channel, IPU_INPUT_BUFFER);
+	if (in_dma != IDMA_CHAN_INVALID)
+		chan_mask |= 1UL << in_dma;
+	sec_dma = channel_2_dma(channel, IPU_SEC_INPUT_BUFFER);
+	if (sec_dma != IDMA_CHAN_INVALID)
+		chan_mask |= 1UL << sec_dma;
+
+	if (wait_for_stop && channel != MEM_SDC_FG && channel != MEM_SDC_BG) {
+		uint32_t timeout = 40;
+		while ((__raw_readl(IDMAC_CHA_BUSY) & chan_mask) ||
+		       (_ipu_channel_status(channel) == TASK_STAT_ACTIVE)) {
+			timeout--;
+			msleep(10);
+			if (timeout == 0) {
+				printk
+				    (KERN_INFO
+				     "MXC IPU: Warning - timeout waiting"
+					 "for channel to stop,\n"
+				     "\tbuf0_rdy = 0x%08X, buf1_rdy = 0x%08X\n"
+				     "\tbusy = 0x%08X, tstat = 0x%08X\n\t"
+					 "mask = 0x%08X\n",
+				     __raw_readl(IPU_CHA_BUF0_RDY),
+				     __raw_readl(IPU_CHA_BUF1_RDY),
+				     __raw_readl(IDMAC_CHA_BUSY),
+				     __raw_readl(IPU_TASKS_STAT), chan_mask);
+				break;
+			}
+		}
+		dev_dbg(g_ipu_dev, "timeout = %d * 10ms\n", 40 - timeout);
+	}
+	/* SDC BG and FG must be disabled before DMA is disabled */
+	if (channel == MEM_SDC_BG) {
+		uint32_t timeout = 5;
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		ipu_clear_irq(IPU_IRQ_SDC_BG_EOF);
+		if (_ipu_sdc_bg_uninit() && wait_for_stop) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+			while (!ipu_get_irq_status(IPU_IRQ_SDC_BG_EOF)) {
+				msleep(5);
+				timeout--;
+				if (timeout == 0)
+					break;
+			}
+		} else {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		}
+	} else if (channel == MEM_SDC_FG) {
+		uint32_t timeout = 5;
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+		ipu_clear_irq(IPU_IRQ_SDC_FG_EOF);
+		if (_ipu_sdc_fg_uninit() && wait_for_stop) {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+			while (!ipu_get_irq_status(IPU_IRQ_SDC_FG_EOF)) {
+				msleep(5);
+				timeout--;
+				if (timeout == 0)
+					break;
+			}
+		} else {
+			spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Disable DMA channel(s) */
+	reg = __raw_readl(IDMAC_CHA_EN);
+	__raw_writel(reg & ~chan_mask, IDMAC_CHA_EN);
+
+	/* Clear DMA related interrupts */
+	__raw_writel(chan_mask, IPU_INT_STAT_1);
+	__raw_writel(chan_mask, IPU_INT_STAT_2);
+	__raw_writel(chan_mask, IPU_INT_STAT_4);
+
+	ipu_conf = __raw_readl(IPU_CONF);
+	if ((g_channel_init_mask & 0x00000066L) == 0) {	/*CSI */
+		ipu_conf &= ~IPU_CONF_CSI_EN;
+	}
+	if ((g_channel_init_mask & 0x00001FFFL) == 0) {	/*IC */
+		ipu_conf &= ~IPU_CONF_IC_EN;
+	}
+	if ((g_channel_init_mask & 0x00000A10L) == 0) {	/*ROT */
+		ipu_conf &= ~IPU_CONF_ROT_EN;
+	}
+	if ((g_channel_init_mask & 0x0001C000L) == 0) {	/*SDC */
+		ipu_conf &= ~IPU_CONF_SDC_EN;
+	}
+	if ((g_channel_init_mask & 0x00061140L) == 0) {	/*ADC */
+		ipu_conf &= ~IPU_CONF_ADC_EN;
+	}
+	if ((g_channel_init_mask & 0x0007D140L) == 0) {	/*DI */
+		ipu_conf &= ~IPU_CONF_DI_EN;
+	}
+	if ((g_channel_init_mask & 0x00380000L) == 0) {	/*PF */
+		ipu_conf &= ~IPU_CONF_PF_EN;
+	}
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disable_channel);
+
+static
+irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	uint32_t line_base = 0;
+	uint32_t line;
+	irqreturn_t result = IRQ_NONE;
+	uint32_t int_stat;
+
+	if (g_ipu_irq[1]) {
+		disable_irq(g_ipu_irq[0]);
+		disable_irq(g_ipu_irq[1]);
+	}
+
+	int_stat = __raw_readl(IPU_INT_STAT_1);
+	int_stat &= __raw_readl(IPU_INT_CTRL_1);
+	__raw_writel(int_stat, IPU_INT_STAT_1);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 32;
+	int_stat = __raw_readl(IPU_INT_STAT_2);
+	int_stat &= __raw_readl(IPU_INT_CTRL_2);
+	__raw_writel(int_stat, IPU_INT_STAT_2);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 64;
+	int_stat = __raw_readl(IPU_INT_STAT_3);
+	int_stat &= __raw_readl(IPU_INT_CTRL_3);
+	__raw_writel(int_stat, IPU_INT_STAT_3);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 96;
+	int_stat = __raw_readl(IPU_INT_STAT_4);
+	int_stat &= __raw_readl(IPU_INT_CTRL_4);
+	__raw_writel(int_stat, IPU_INT_STAT_4);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	line_base = 128;
+	int_stat = __raw_readl(IPU_INT_STAT_5);
+	int_stat &= __raw_readl(IPU_INT_CTRL_5);
+	__raw_writel(int_stat, IPU_INT_STAT_5);
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		line += line_base - 1;
+		result |=
+		    ipu_irq_list[line].handler(line, ipu_irq_list[line].dev_id);
+	}
+
+	if (g_ipu_irq[1]) {
+		enable_irq(g_ipu_irq[0]);
+		enable_irq(g_ipu_irq[1]);
+	}
+	return result;
+}
+
+/*!
+ * This function enables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to enable interrupt for.
+ *
+ */
+void ipu_enable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_enable_irq);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_disable_irq);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq(uint32_t irq)
+{
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+}
+EXPORT_SYMBOL(ipu_clear_irq);
+
+/*!
+ * This function returns the current interrupt
+ * status for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @return      Returns true if the interrupt is pending/asserted or false if
+ *              the interrupt is not pending.
+ */
+bool ipu_get_irq_status(uint32_t irq)
+{
+	uint32_t reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+
+	if (reg & IPUIRQ_2_MASK(irq))
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(ipu_get_irq_status);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	uint32_t lock_flags;
+
+	MXC_ERR_CHK(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (ipu_irq_list[irq].handler != NULL) {
+		dev_err(g_ipu_dev,
+			"ipu_request_irq - handler already"
+			"installed on irq %d\n",
+			irq);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	ipu_irq_list[irq].handler = handler;
+	ipu_irq_list[irq].flags = irq_flags;
+	ipu_irq_list[irq].dev_id = dev_id;
+	ipu_irq_list[irq].name = devname;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	ipu_enable_irq(irq);	/* enable the interrupt */
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_request_irq);
+
+/*!
+ * This function unregisters an interrupt handler for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler. This must match value passed to
+ *                              ipu_request_irq().
+ *
+ */
+void ipu_free_irq(uint32_t irq, void *dev_id)
+{
+	ipu_disable_irq(irq);	/* disable the interrupt */
+
+	if (ipu_irq_list[irq].dev_id == dev_id)
+		ipu_irq_list[irq].handler = NULL;
+}
+EXPORT_SYMBOL(ipu_free_irq);
+
+/*!
+ * This function sets the post-filter pause row for h.264 mode.
+ *
+ * @param       pause_row       The last row to process before pausing.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ *
+ */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row)
+{
+	int32_t retval = 0;
+	uint32_t timeout = 5;
+	uint32_t lock_flags;
+	uint32_t reg;
+
+	reg = __raw_readl(IPU_TASKS_STAT);
+	while ((reg & TSTAT_PF_MASK) && ((reg & TSTAT_PF_H264_PAUSE) == 0)) {
+		timeout--;
+		msleep(5);
+		if (timeout == 0) {
+			dev_err(g_ipu_dev, "PF Timeout - tstat = 0x%08X\n",
+				__raw_readl(IPU_TASKS_STAT));
+			retval = -ETIMEDOUT;
+			goto err0;
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(PF_CONF);
+
+	/* Set the pause row */
+	if (pause_row) {
+		reg &= ~PF_CONF_PAUSE_ROW_MASK;
+		reg |= PF_CONF_PAUSE_EN | pause_row << PF_CONF_PAUSE_ROW_SHIFT;
+	} else
+		reg &= ~(PF_CONF_PAUSE_EN | PF_CONF_PAUSE_ROW_MASK);
+	__raw_writel(reg, PF_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+err0:
+	return retval;
+}
+EXPORT_SYMBOL(ipu_pf_set_pause_row);
+
+/* Private functions */
+void _ipu_write_param_mem(uint32_t addr, uint32_t *data, uint32_t numWords)
+{
+	for (; numWords > 0; numWords--) {
+		dev_dbg(g_ipu_dev,
+			"write param mem - addr = 0x%08X, data = 0x%08X\n",
+			addr, *data);
+		__raw_writel(addr, IPU_IMA_ADDR);
+		__raw_writel(*data++, IPU_IMA_DATA);
+		addr++;
+		if ((addr & 0x7) == 5) {
+			addr &= ~0x7;	/* set to word 0 */
+			addr += 8;	/* increment to next row */
+		}
+	}
+}
+
+static void _ipu_pf_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+
+	/*Setup the type of filtering required */
+	switch (params->mem_pf_mem.operation) {
+	case PF_MPEG4_DEBLOCK:
+	case PF_MPEG4_DERING:
+	case PF_MPEG4_DEBLOCK_DERING:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = true;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+		break;
+	case PF_H264_DEBLOCK:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = true;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = true;
+		break;
+	default:
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = false;
+		g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+		return;
+		break;
+	}
+	reg = params->mem_pf_mem.operation;
+	__raw_writel(reg, PF_CONF);
+}
+
+static void _ipu_pf_uninit(void)
+{
+	__raw_writel(0x0L, PF_CONF);
+	g_sec_chan_en[IPU_CHAN_ID(MEM_PF_Y_MEM)] = false;
+	g_sec_chan_en[IPU_CHAN_ID(MEM_PF_U_MEM)] = false;
+}
+
+uint32_t _ipu_channel_status(ipu_channel_t channel)
+{
+	uint32_t stat = 0;
+	uint32_t task_stat_reg = __raw_readl(IPU_TASKS_STAT);
+
+	switch (channel) {
+	case CSI_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_CSI2MEM_MASK) >>
+		    TSTAT_CSI2MEM_OFFSET;
+		break;
+	case CSI_PRP_VF_ADC:
+	case CSI_PRP_VF_MEM:
+	case MEM_PRP_VF_ADC:
+	case MEM_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_VF_ROT_MASK) >> TSTAT_VF_ROT_OFFSET;
+		break;
+	case CSI_PRP_ENC_MEM:
+	case MEM_PRP_ENC_MEM:
+		stat = (task_stat_reg & TSTAT_ENC_MASK) >> TSTAT_ENC_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_ENC_ROT_MASK) >>
+		    TSTAT_ENC_ROT_OFFSET;
+		break;
+	case MEM_PP_ADC:
+	case MEM_PP_MEM:
+		stat = (task_stat_reg & TSTAT_PP_MASK) >> TSTAT_PP_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_PP_ROT_MASK) >> TSTAT_PP_ROT_OFFSET;
+		break;
+
+	case MEM_PF_Y_MEM:
+	case MEM_PF_U_MEM:
+	case MEM_PF_V_MEM:
+		stat = (task_stat_reg & TSTAT_PF_MASK) >> TSTAT_PF_OFFSET;
+		break;
+	case MEM_SDC_BG:
+		break;
+	case MEM_SDC_FG:
+		break;
+	case ADC_SYS1:
+		stat =
+		    (task_stat_reg & TSTAT_ADCSYS1_MASK) >>
+		    TSTAT_ADCSYS1_OFFSET;
+		break;
+	case ADC_SYS2:
+		stat =
+		    (task_stat_reg & TSTAT_ADCSYS2_MASK) >>
+		    TSTAT_ADCSYS2_OFFSET;
+		break;
+	case MEM_SDC_MASK:
+	default:
+		stat = TASK_STAT_IDLE;
+		break;
+	}
+	return stat;
+}
+
+uint32_t bytes_per_pixel(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/*generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+		break;
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+		break;
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+		break;
+	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bytes_per_pixel);
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+		return RGB;
+		break;
+
+	default:
+		return YCbCr;
+		break;
+	}
+	return RGB;
+
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		   .name = "mxc_ipu",
+		   },
+	.probe = ipu_probe,
+};
+
+int32_t __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	if (g_ipu_irq[0])
+		free_irq(g_ipu_irq[0], 0);
+	if (g_ipu_irq[1])
+		free_irq(g_ipu_irq[1], 0);
+
+	platform_driver_unregister(&mxcipu_driver);
+}
+module_exit(ipu_gen_uninit);
diff --git a/drivers/mxc/ipu/ipu_csi.c b/drivers/mxc/ipu/ipu_csi.c
new file mode 100644
index 0000000..9fcd764
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_csi.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_csi.c
+ *
+ * @brief IPU CMOS Sensor interface functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <mach/clock.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+
+static bool gipu_csi_get_mclk_flag;
+static int csi_mclk_flag;
+
+extern void gpio_sensor_suspend(bool flag);
+
+/*!
+ * ipu_csi_init_interface
+ *    Sets initial values for the CSI registers.
+ *    The width and height of the sensor and the actual frame size will be
+ *    set to the same values.
+ * @param       width        Sensor width
+ * @param       height       Sensor height
+ * @param       pixel_fmt    pixel format
+ * @param       sig          ipu_csi_signal_cfg_t structure
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t
+ipu_csi_init_interface(uint16_t width, uint16_t height, uint32_t pixel_fmt,
+		       ipu_csi_signal_cfg_t sig)
+{
+	uint32_t data = 0;
+
+	/* Set SENS_DATA_FORMAT bits (8 and 9)
+	   RGB or YUV444 is 0 which is current value
+	   in data so not set explicitly
+	   This is also the default value if attempts
+	   are made to set it to
+	   something invalid. */
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_UYVY:
+		data = CSI_SENS_CONF_DATA_FMT_YUV422;
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR24:
+		data = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
+		break;
+	case IPU_PIX_FMT_GENERIC:
+		data = CSI_SENS_CONF_DATA_FMT_BAYER;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	data |= sig.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
+	    sig.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
+	    sig.Vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
+	    sig.Hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
+	    sig.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
+	    sig.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
+	    sig.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
+	    sig.sens_clksrc << CSI_SENS_CONF_SENS_CLKSRC_SHIFT;
+
+	__raw_writel(data, CSI_SENS_CONF);
+
+	/* Setup frame size     */
+	__raw_writel(width | height << 16, CSI_SENS_FRM_SIZE);
+
+	__raw_writel(width << 16, CSI_FLASH_STROBE_1);
+	__raw_writel(height << 16 | 0x22, CSI_FLASH_STROBE_2);
+
+	/* Set CCIR registers */
+	if ((sig.clk_mode == IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE) ||
+	    (sig.clk_mode == IPU_CSI_CLK_MODE_CCIR656_INTERLACED)) {
+		__raw_writel(0x40030, CSI_CCIR_CODE_1);
+		__raw_writel(0xFF0000, CSI_CCIR_CODE_3);
+	}
+
+	dev_dbg(g_ipu_dev, "CSI_SENS_CONF = 0x%08X\n",
+		__raw_readl(CSI_SENS_CONF));
+	dev_dbg(g_ipu_dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
+		__raw_readl(CSI_ACT_FRM_SIZE));
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_init_interface);
+
+/*!
+ * ipu_csi_flash_strobe
+ *
+ * @param       flag         true to turn on flash strobe
+ *
+ * @return      0 for success
+ */
+void ipu_csi_flash_strobe(bool flag)
+{
+	if (flag == true) {
+		__raw_writel(__raw_readl(CSI_FLASH_STROBE_2) | 0x1,
+			     CSI_FLASH_STROBE_2);
+	}
+}
+EXPORT_SYMBOL(ipu_csi_flash_strobe);
+
+/*!
+ * ipu_csi_enable_mclk
+ *
+ * @param       src         enum define which source to control the clk
+ *                          CSI_MCLK_VF CSI_MCLK_ENC CSI_MCLK_RAW CSI_MCLK_I2C
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      0 for success
+ */
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait)
+{
+	if (flag == true)
+		csi_mclk_flag |= src;
+	else
+		csi_mclk_flag &= ~src;
+
+	if (gipu_csi_get_mclk_flag == flag)
+		return 0;
+
+	if (flag == true) {
+		mxc_clks_enable(CSI_BAUD);
+		if (wait == true)
+			msleep(10);
+		gipu_csi_get_mclk_flag = true;
+	} else if (csi_mclk_flag == 0) {
+		mxc_clks_disable(CSI_BAUD);
+		gipu_csi_get_mclk_flag = flag;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_csi_enable_mclk);
+
+/*!
+ * ipu_csi_read_mclk_flag
+ *
+ * @return  csi_mclk_flag
+ */
+int ipu_csi_read_mclk_flag(void)
+{
+	return csi_mclk_flag;
+}
+EXPORT_SYMBOL(ipu_csi_read_mclk_flag);
+
+/*!
+ * ipu_csi_get_window_size
+ *
+ * @param       width        pointer to window width
+ * @param       height       pointer to window height
+ *
+ */
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(CSI_ACT_FRM_SIZE);
+	*width = (reg & 0xFFFF) + 1;
+	*height = (reg >> 16 & 0xFFFF) + 1;
+}
+EXPORT_SYMBOL(ipu_csi_get_window_size);
+
+/*!
+ * ipu_csi_set_window_size
+ *
+ * @param       width        window width
+ * @param       height       window height
+ *
+ */
+void ipu_csi_set_window_size(uint32_t width, uint32_t height)
+{
+	__raw_writel((width - 1) | (height - 1) << 16, CSI_ACT_FRM_SIZE);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_size);
+
+/*!
+ * ipu_csi_set_window_pos
+ *
+ * @param       left        uint32 window x start
+ * @param       top         uint32 window y start
+ *
+ */
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top)
+{
+	uint32_t temp = __raw_readl(CSI_OUT_FRM_CTRL);
+	temp &= 0xffff0000;
+	temp = top | (left << 8) | temp;
+	__raw_writel(temp, CSI_OUT_FRM_CTRL);
+}
+EXPORT_SYMBOL(ipu_csi_set_window_pos);
diff --git a/drivers/mxc/ipu/ipu_ic.c b/drivers/mxc/ipu/ipu_ic.c
new file mode 100644
index 0000000..74c926e
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_ic.c
@@ -0,0 +1,498 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_ic.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum {
+	IC_TASK_VIEWFINDER,
+	IC_TASK_ENCODER,
+	IC_TASK_POST_PROCESSOR
+};
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format);
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff);
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_height,
+			    params->mem_prp_vf_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
+			    params->mem_prp_vf_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_VF_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+			/* Enable RGB->YCBCR CSC */
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+			/* Enable YCBCR->RGB CSC */
+		}
+	}
+
+	if (params->mem_prp_vf_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PRPVF_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PRPVF_CSC1;
+		/* Enable RGB->RGB CSC */
+
+		if (params->mem_prp_vf_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_prp_vf_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else
+		ic_conf &= ~IC_CONF_PP_CMB;
+
+#ifndef CONFIG_VIRTIO_SUPPORT
+	/* Setting RWS_EN doesn't work in Virtio */
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+#endif
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpvf(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPVF_EN | IC_CONF_PRPVF_CMB |
+		 IC_CONF_PRPVF_CSC2 | IC_CONF_PRPVF_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_vf(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PRPVF_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_csi(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_CSI_MEM_WR_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_uninit_csi(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_RWS_EN | IC_CONF_PRPENC_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_height,
+			    params->mem_prp_enc_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
+			    params->mem_prp_enc_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_ENC_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_enc_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_enc_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV))
+			pr_debug("error\n");
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_ENCODER, YCbCr, RGB);
+			/* Enable YCBCR->RGB CSC */
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		} else
+			/* TODO: Support YUV<->YCbCr conversion? */
+			pr_debug("unsupportd yuv<->ycrcb\n");
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpenc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_enc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_ROT_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_pp(ipu_channel_params_t *params)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_height,
+			    params->mem_pp_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_width,
+			    params->mem_pp_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PP_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_pp_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt);
+			ic_conf |= IC_CONF_PP_CSC2;
+			/* Enable RGB->YCBCR CSC */
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB);
+			ic_conf |= IC_CONF_PP_CSC1;
+			/* Enable YCBCR->RGB CSC */
+		} else
+			/* TODO: Support YUV<->YCbCr conversion? */
+			pr_debug("Support YUV<->YCbCr conversion?");
+	}
+
+	if (params->mem_pp_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PP_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PP_CSC1;	/* Enable RGB->RGB CSC */
+
+		if (params->mem_pp_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_pp_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else
+		ic_conf &= ~IC_CONF_PP_CMB;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_pp(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PP_EN | IC_CONF_PP_CSC1 | IC_CONF_PP_CSC2 |
+		 IC_CONF_PP_CMB);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_pp(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PP_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format)
+{
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+	static const uint32_t rgb2ycbcr_coeff[4][3] = {
+		{0x004D, 0x0096, 0x001D},
+		{0x01D5, 0x01AB, 0x0080},
+		{0x0080, 0x0195, 0x01EB},
+		{0x0000, 0x0200, 0x0200},	/* A0, A1, A2 */
+	};
+
+	/* transparent RGB->RGB matrix for combining
+	 */
+	static const uint32_t rgb2rgb_coeff[4][3] = {
+		{0x0080, 0x0000, 0x0000},
+		{0x0000, 0x0080, 0x0000},
+		{0x0000, 0x0000, 0x0080},
+		{0x0000, 0x0000, 0x0000},	/* A0, A1, A2 */
+	};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+	static const uint32_t ycbcr2rgb_coeff[4][3] = {
+		{149, 0, 204},
+		{149, 462, 408},
+		{149, 255, 0},
+		{8192 - 446, 266, 8192 - 554},	/* A0, A1, A2 */
+	};
+
+	uint32_t param[2];
+	uint32_t address = 0;
+
+	if (ic_task == IC_TASK_VIEWFINDER) {
+		address = 0x5A5 << 3;
+	} else if (ic_task == IC_TASK_ENCODER) {
+		address = 0x2D1 << 3;
+	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+		address = 0x87C << 3;
+	} else {
+		MXC_ERR_CHK(1);
+		return;
+	}
+
+	if ((in_format == YCbCr) && (out_format == RGB)) {
+		/* Init CSC1 (YCbCr->RGB) */
+		param[0] =
+		    (ycbcr2rgb_coeff[3][0] << 27) | (ycbcr2rgb_coeff[0][0] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][1] << 9) | ycbcr2rgb_coeff[2][2];
+		/* scale = 2, sat = 0 */
+		param[1] = (ycbcr2rgb_coeff[3][0] >> 5) | (2L << (40 - 32));
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (ycbcr2rgb_coeff[3][1] << 27) | (ycbcr2rgb_coeff[0][1] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][0] << 9) | ycbcr2rgb_coeff[2][0];
+		param[1] = (ycbcr2rgb_coeff[3][1] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (ycbcr2rgb_coeff[3][2] << 27) | (ycbcr2rgb_coeff[0][2] <<
+						     18) |
+		    (ycbcr2rgb_coeff[1][2] << 9) | ycbcr2rgb_coeff[2][1];
+		param[1] = (ycbcr2rgb_coeff[3][2] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else if ((in_format == RGB) && (out_format == YCbCr)) {
+		/* Init CSC1 (RGB->YCbCr) */
+		param[0] =
+		    (rgb2ycbcr_coeff[3][0] << 27) | (rgb2ycbcr_coeff[0][0] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][1] << 9) | rgb2ycbcr_coeff[2][2];
+		/* scale = 1, sat = 0 */
+		param[1] = (rgb2ycbcr_coeff[3][0] >> 5) | (1UL << 8);
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2ycbcr_coeff[3][1] << 27) | (rgb2ycbcr_coeff[0][1] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][0] << 9) | rgb2ycbcr_coeff[2][0];
+		param[1] = (rgb2ycbcr_coeff[3][1] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2ycbcr_coeff[3][2] << 27) | (rgb2ycbcr_coeff[0][2] <<
+						     18) |
+		    (rgb2ycbcr_coeff[1][2] << 9) | rgb2ycbcr_coeff[2][1];
+		param[1] = (rgb2ycbcr_coeff[3][2] >> 5);
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else if ((in_format == RGB) && (out_format == RGB)) {
+		/* Init CSC1 */
+		param[0] =
+		    (rgb2rgb_coeff[3][0] << 27) | (rgb2rgb_coeff[0][0] << 18) |
+		    (rgb2rgb_coeff[1][1] << 9) | rgb2rgb_coeff[2][2];
+		/* scale = 2, sat = 0 */
+		param[1] = (rgb2rgb_coeff[3][0] >> 5) | (2UL << 8);
+
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2rgb_coeff[3][1] << 27) | (rgb2rgb_coeff[0][1] << 18) |
+		    (rgb2rgb_coeff[1][0] << 9) | rgb2rgb_coeff[2][0];
+		param[1] = (rgb2rgb_coeff[3][1] >> 5);
+
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+
+		param[0] =
+		    (rgb2rgb_coeff[3][2] << 27) | (rgb2rgb_coeff[0][2] << 18) |
+		    (rgb2rgb_coeff[1][2] << 9) | rgb2rgb_coeff[2][1];
+		param[1] = (rgb2rgb_coeff[3][2] >> 5);
+
+		address += 1L << 3;
+		_ipu_write_param_mem(address, param, 2);
+
+		dev_dbg(g_ipu_dev,
+			"addr 0x%04X: word0 = 0x%08X, word1 = 0x%08X\n",
+			address, param[0], param[1]);
+	} else {
+		dev_err(g_ipu_dev, "Unsupported color space conversion\n");
+	}
+}
+
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff)
+{
+	uint32_t tempSize;
+	uint32_t tempDownsize;
+
+	/* Cannot downsize more than 8:1 */
+	if ((outSize << 3) < inSize)
+		return false;
+	/* compute downsizing coefficient */
+	tempDownsize = 0;
+	tempSize = inSize;
+	while ((tempSize >= outSize * 2) && (tempDownsize < 2)) {
+		tempSize >>= 1;
+		tempDownsize++;
+	}
+	*downsizeCoeff = tempDownsize;
+
+	/* compute resizing coefficient using the following equation:
+	   resizeCoeff = M*(SI -1)/(SO - 1)
+	   where M = 2^13, SI - input size, SO - output size    */
+	*resizeCoeff = (8192L * (tempSize - 1)) / (outSize - 1);
+	if (*resizeCoeff >= 16384L) {
+		dev_err(g_ipu_dev, "Warning! Overflow on resize coeff.\n");
+		*resizeCoeff = 0x3FFF;
+	}
+
+	dev_dbg(g_ipu_dev, "resizing from %d -> %d pixels, "
+		"downsize=%d, resize=%d.%d (reg=%d)\n", inSize, outSize,
+		*downsizeCoeff, (*resizeCoeff >= 8192L) ? 1 : 0,
+		((*resizeCoeff & 0x1FFF) * 10000L) / 8192L, *resizeCoeff);
+
+	return true;
+}
diff --git a/drivers/mxc/ipu/ipu_lpmc.c b/drivers/mxc/ipu/ipu_lpmc.c
new file mode 100644
index 0000000..960af91
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_lpmc.c
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_lpmc.c
+ *
+ * @brief This file contains the IPU API functions for the LPMC module.
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_MXC_IPU_LPMC
+
+#include <linux/io.h>
+#include <mach/clock.h>
+#include <asm/plat-mxc/mxc_pm.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+
+
+#define LPMC_CNTL	IO_ADDRESS(LPMC_BASE_ADDR + 0)
+#define LPMC_DATA	IO_ADDRESS(LPMC_BASE_ADDR + 4)
+#define LPMC_STAT	IO_ADDRESS(LPMC_BASE_ADDR + 8)
+
+#define LPMC_CNTL_LOW_PWR_CLK           0x00000002
+#define LPMC_CNTL_LPMC_EN               0x00000001
+#define LPMC_CNTL_RMP_END_PTR_OFFSET    16
+#define LPMC_CNTL_LPMP_END_PTR_OFFSET   24
+
+/*!
+ * This function initializes low-power self-refresh mode.
+ *
+ * @param       dfm_freq        Frequency for DFM. This should be 4x the
+ *                              pixel clock.
+ *
+ * @param       save_list       List of IPU register accesses for saving normal
+ *                              mode.
+ *
+ * @param       save_count      Number of IPU register accesses for normal mode.
+ *
+ * @param       lpm_list        List of IPU register accesses for setting up
+ *                              low power, self-refresh mode.
+ *
+ * @param       lpm_count       Number of IPU register accesses for
+ *                              low power, self-refresh mode.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int ipu_lpmc_init(u32 dfm_freq,
+		  ipu_lpmc_reg_t *save_list,
+		  u32 save_count, ipu_lpmc_reg_t *lpm_list, u32 lpm_count)
+{
+	u32 reg, lpmc_cntl;
+	u32 lpmc_state, previous_lpmc_state;
+
+	mxc_set_dfm_clock(dfm_freq);
+	mxc_clks_enable(LPMC_CLK);
+
+#ifdef CONFIG_DPM
+	mxc_pm_lp_ack_enable(MXC_PM_LOWPWR_ACK_IPU);
+#endif
+	lpmc_cntl = (save_count) << LPMC_CNTL_RMP_END_PTR_OFFSET;
+	lpmc_cntl |= (lpm_count + save_count) << LPMC_CNTL_LPMP_END_PTR_OFFSET;
+	__raw_writel(lpmc_cntl, LPMC_CNTL);
+
+	/* Dummy read of IPU_CONF is needed for some reason     */
+	__raw_writel(0, LPMC_DATA);
+	__raw_writel(0, LPMC_DATA);
+
+	/* Setup LPMC normal mode register save template */
+	for (; save_count > 0; save_count--) {
+		reg = (~IPU_LPMC_REG_READ & save_list->reg) >> 1;
+		if ((save_list->reg & IPU_LPMC_REG_READ) == 0)
+			reg |= 0x1;	/* Write register */
+		__raw_writel(reg, LPMC_DATA);
+		__raw_writel(save_list->value, LPMC_DATA);
+		dev_dbg(g_ipu_dev, "Save reg - reg 0x%08X = 0x%08X\n", reg,
+			save_list->value);
+		save_list++;
+	}
+
+	/* Setup LPMC low power mode register settings */
+	for (; lpm_count > 0; lpm_count--) {
+		reg = (~IPU_LPMC_REG_READ & lpm_list->reg) >> 1;
+		if ((lpm_list->reg & IPU_LPMC_REG_READ) == 0)
+			reg |= 0x1;	/* Write register */
+		__raw_writel(reg, LPMC_DATA);
+		__raw_writel(lpm_list->value, LPMC_DATA);
+		dev_dbg(g_ipu_dev, "lpm reg - reg 0x%08X = 0x%08X\n", reg,
+			lpm_list->value);
+		lpm_list++;
+	}
+
+	lpmc_state = previous_lpmc_state = __raw_readl(LPMC_STAT) >> 16;
+	dev_dbg(g_ipu_dev, "LPMC off - LPMC_STAT = 0x%X\n", lpmc_state);
+
+	lpmc_cntl |= LPMC_CNTL_LOW_PWR_CLK | LPMC_CNTL_LPMC_EN;
+	__raw_writel(lpmc_cntl, LPMC_CNTL);	/* EXIT LPMC Mode */
+	dev_dbg(g_ipu_dev, "LPMC_CNTL = 0x%08X\n", lpmc_cntl);
+
+	while (lpmc_state != 0xC) {
+		lpmc_state = __raw_readl(LPMC_STAT) >> 16;
+		if (previous_lpmc_state != lpmc_state) {
+			dev_dbg(g_ipu_dev, "LPMC_STAT = 0x%08X\n", lpmc_state);
+			previous_lpmc_state = lpmc_state;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_lpmc_init);
+
+/*!
+ * This function uninitializes low-power self-refresh mode and returns
+ * to normal operation.
+ *
+ */
+void ipu_lpmc_uninit(void)
+{
+	u32 reg;
+	u32 lpmc_state, previous_lpmc_state;
+	u32 lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+#ifdef CONFIG_DPM
+	mxc_pm_lp_ack_disable(MXC_PM_LOWPWR_ACK_IPU);
+#endif
+	reg = __raw_readl(LPMC_CNTL);
+	reg &= ~LPMC_CNTL_LOW_PWR_CLK;
+	__raw_writel(reg, LPMC_CNTL);	/* EXIT LPMC Mode */
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	lpmc_state = previous_lpmc_state = __raw_readl(LPMC_STAT) >> 16;
+	while (lpmc_state != 0) {
+		lpmc_state = __raw_readl(LPMC_STAT) >> 16;
+		if (previous_lpmc_state != lpmc_state) {
+			dev_dbg(g_ipu_dev, "LPMC_STAT = 0x%08X\n", lpmc_state);
+			previous_lpmc_state = lpmc_state;
+		}
+	}
+
+	__raw_writel(0, LPMC_CNTL);	/* Disable LPMC */
+	mxc_clks_disable(LPMC_CLK);
+	mxc_set_dfm_clock(0);
+}
+EXPORT_SYMBOL(ipu_lpmc_uninit);
+
+#else
+int ipu_lpmc_init(u32 dfm_freq,
+		  ipu_lpmc_reg_t *save_list,
+		  u32 save_count, ipu_lpmc_reg_t *lpm_list, u32 lpm_count)
+{
+	return 0;
+}
+EXPORT_SYMBOL(ipu_lpmc_init);
+
+void ipu_lpmc_uninit(void)
+{
+}
+EXPORT_SYMBOL(ipu_lpmc_uninit);
+
+#endif
+
diff --git a/drivers/mxc/ipu/ipu_param_mem.h b/drivers/mxc/ipu/ipu_param_mem.h
new file mode 100644
index 0000000..e4272c0
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_param_mem.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PARAM_MEM_H__
+#define __INCLUDE_IPU_PARAM_MEM_H__
+
+#include <linux/types.h>
+
+static inline void _ipu_ch_param_set_size(uint32_t *params,
+					    uint32_t pixel_fmt, uint16_t width,
+					    uint16_t height, uint16_t stride,
+					    uint32_t u, uint32_t v)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	memset(params, 0, 40);
+
+	params[3] =
+	    (uint32_t) ((width - 1) << 12) | ((uint32_t) (height - 1) << 24);
+	params[4] = (uint32_t) (height - 1) >> 8;
+	params[7] = (uint32_t) (stride - 1) << 3;
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/*Represents 8-bit Generic data */
+		params[7] |= 3 | (7UL << (81 - 64)) | (31L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2;	/* SAT = use 32-bit access */
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/*Represents 32-bit Generic data */
+		params[7] |= (7UL << (81 - 64)) | (7L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2;	/* SAT = use 32-bit access */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		params[7] |= 2L | (4UL << (81 - 64)) | (7L << (89 - 64));
+		/* BPP & PFS */
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (0UL << (99 - 96)) |	/* Red bit offset */
+		    (5UL << (104 - 96)) |	/* Green bit offset     */
+		    (11UL << (109 - 96)) |	/* Blue bit offset */
+		    (16UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (4UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (5UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (4UL << (125 - 96));
+		/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_BGR24:	/* 24 BPP & RGB PFS */
+		params[7] |= 1 | (4UL << (81 - 64)) | (7L << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (8UL << (104 - 96)) |	/* Green bit offset     */
+		    (16UL << (109 - 96)) |	/* Blue bit offset */
+		    (24UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));
+		/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_RGB24:	/* 24 BPP & RGB PFS     */
+		params[7] |= 1 | (4UL << (81 - 64)) | (7L << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (16UL << (99 - 96)) |	/* Red bit offset */
+		    (8UL << (104 - 96)) |	/* Green bit offset */
+		    (0UL << (109 - 96)) |	/* Blue bit offset */
+		    (24UL << (114 - 96)) |	/* Alpha bit offset */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (8UL << (99 - 96)) |	/* Red bit offset */
+		    (16UL << (104 - 96)) |	/* Green bit offset     */
+		    (24UL << (109 - 96)) |	/* Blue bit offset */
+		    (0UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		params[9] = 7;	/* Alpha bit width - 1 */
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (24UL << (99 - 96)) |	/* Red bit offset */
+		    (16UL << (104 - 96)) |	/* Green bit offset     */
+		    (8UL << (109 - 96)) |	/* Blue bit offset */
+		    (0UL << (114 - 96)) |	/* Alpha bit offset     */
+		    (7UL << (119 - 96)) |	/* Red bit width - 1 */
+		    (7UL << (122 - 96)) |
+			/* Green bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));	/* Blue bit width - 1 */
+		params[9] = 7;	/* Alpha bit width - 1 */
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		/* BPP & pixel fmt */
+		params[7] |= 0 | (4UL << (81 - 64)) | (7 << (89 - 64));
+		params[8] = 2 |	/* SAT = 32-bit access */
+		    (0UL << (99 - 96)) |	/* Alpha bit offset     */
+		    (8UL << (104 - 96)) |	/* Blue bit offset */
+		    (16UL << (109 - 96)) |	/* Green bit offset     */
+		    (24UL << (114 - 96)) |	/* Red bit offset */
+		    (7UL << (119 - 96)) |	/* Alpha bit width - 1 */
+		    (7UL << (122 - 96)) |	/* Blue bit width - 1 */
+		    (uint32_t) (7UL << (125 - 96));
+		/* Green bit width - 1 */
+		params[9] = 7;	/* Red bit width - 1 */
+		break;
+	case IPU_PIX_FMT_UYVY:
+		/* BPP & pixel format */
+		params[7] |= 2 | (6UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (3UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 4 : v;
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (2UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		params[7] |= 3 | (2UL << 17) | (7 << (89 - 64));
+		params[8] = 2;	/* SAT = 32-bit access */
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+
+	params[1] = (1UL << (46 - 32)) | (u_offset << (53 - 32));
+	params[2] = u_offset >> (64 - 53);
+	params[2] |= v_offset << (79 - 64);
+	params[3] |= v_offset >> (96 - 79);
+}
+
+static inline void _ipu_ch_param_set_burst_size(uint32_t *params,
+						  uint16_t burst_pixels)
+{
+	params[7] &= ~(0x3FL << (89 - 64));
+	params[7] |= (uint32_t) (burst_pixels - 1) << (89 - 64);
+};
+
+static inline void _ipu_ch_param_set_buffer(uint32_t *params,
+					      dma_addr_t buf0, dma_addr_t buf1)
+{
+	params[5] = buf0;
+	params[6] = buf1;
+};
+
+static inline void _ipu_ch_param_set_rotation(uint32_t *params,
+						ipu_rotate_mode_t rot)
+{
+	params[7] |= (uint32_t) rot << (84 - 64);
+};
+
+void _ipu_write_param_mem(uint32_t addr, uint32_t *data, uint32_t numWords);
+
+#endif
diff --git a/drivers/mxc/ipu/ipu_prv.h b/drivers/mxc/ipu/ipu_prv.h
new file mode 100644
index 0000000..a897fc4
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_prv.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PRV_H__
+#define __INCLUDE_IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+
+/* Globals */
+extern struct device *g_ipu_dev;
+extern spinlock_t ipu_lock;
+extern uint32_t g_ipu_clk;
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel);
+
+void _ipu_sdc_fg_init(ipu_channel_params_t *params);
+uint32_t _ipu_sdc_fg_uninit(void);
+void _ipu_sdc_bg_init(ipu_channel_params_t *params);
+uint32_t _ipu_sdc_bg_uninit(void);
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpvf(void);
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_vf(void);
+void _ipu_ic_init_csi(ipu_channel_params_t *params);
+void _ipu_ic_uninit_csi(void);
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpenc(void);
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_enc(void);
+void _ipu_ic_init_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_pp(void);
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_pp(void);
+
+int32_t _ipu_adc_init_channel(ipu_channel_t chan, display_port_t disp,
+			      mcu_mode_t cmd, int16_t x_pos, int16_t y_pos);
+int32_t _ipu_adc_uninit_channel(ipu_channel_t chan);
+
+#endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu/ipu_regs.h b/drivers/mxc/ipu/ipu_regs.h
new file mode 100644
index 0000000..73f0e9c
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_regs.h
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_regs.h
+ *
+ * @brief IPU Register definitions
+ *
+ * @ingroup IPU
+ */
+#ifndef __IPU_REGS_INCLUDED__
+#define __IPU_REGS_INCLUDED__
+
+#define IPU_REG_BASE    IO_ADDRESS(IPU_CTRL_BASE_ADDR)
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CONF                (IPU_REG_BASE + 0x0000)
+#define IPU_CHA_BUF0_RDY        (IPU_REG_BASE + 0x0004)
+#define IPU_CHA_BUF1_RDY        (IPU_REG_BASE + 0x0008)
+#define IPU_CHA_DB_MODE_SEL     (IPU_REG_BASE + 0x000C)
+#define IPU_CHA_CUR_BUF         (IPU_REG_BASE + 0x0010)
+#define IPU_FS_PROC_FLOW        (IPU_REG_BASE + 0x0014)
+#define IPU_FS_DISP_FLOW        (IPU_REG_BASE + 0x0018)
+#define IPU_TASKS_STAT          (IPU_REG_BASE + 0x001C)
+#define IPU_IMA_ADDR            (IPU_REG_BASE + 0x0020)
+#define IPU_IMA_DATA            (IPU_REG_BASE + 0x0024)
+#define IPU_INT_CTRL_1          (IPU_REG_BASE + 0x0028)
+#define IPU_INT_CTRL_2          (IPU_REG_BASE + 0x002C)
+#define IPU_INT_CTRL_3          (IPU_REG_BASE + 0x0030)
+#define IPU_INT_CTRL_4          (IPU_REG_BASE + 0x0034)
+#define IPU_INT_CTRL_5          (IPU_REG_BASE + 0x0038)
+#define IPU_INT_STAT_1          (IPU_REG_BASE + 0x003C)
+#define IPU_INT_STAT_2          (IPU_REG_BASE + 0x0040)
+#define IPU_INT_STAT_3          (IPU_REG_BASE + 0x0044)
+#define IPU_INT_STAT_4          (IPU_REG_BASE + 0x0048)
+#define IPU_INT_STAT_5          (IPU_REG_BASE + 0x004C)
+#define IPU_BRK_CTRL_1          (IPU_REG_BASE + 0x0050)
+#define IPU_BRK_CTRL_2          (IPU_REG_BASE + 0x0054)
+#define IPU_BRK_STAT            (IPU_REG_BASE + 0x0058)
+#define IPU_DIAGB_CTRL          (IPU_REG_BASE + 0x005C)
+/* CMOS Sensor Interface Registers */
+#define CSI_SENS_CONF           (IPU_REG_BASE + 0x0060)
+#define CSI_SENS_FRM_SIZE       (IPU_REG_BASE + 0x0064)
+#define CSI_ACT_FRM_SIZE        (IPU_REG_BASE + 0x0068)
+#define CSI_OUT_FRM_CTRL        (IPU_REG_BASE + 0x006C)
+#define CSI_TST_CTRL            (IPU_REG_BASE + 0x0070)
+#define CSI_CCIR_CODE_1         (IPU_REG_BASE + 0x0074)
+#define CSI_CCIR_CODE_2         (IPU_REG_BASE + 0x0078)
+#define CSI_CCIR_CODE_3         (IPU_REG_BASE + 0x007C)
+#define CSI_FLASH_STROBE_1      (IPU_REG_BASE + 0x0080)
+#define CSI_FLASH_STROBE_2      (IPU_REG_BASE + 0x0084)
+/* Image Converter Registers */
+#define IC_CONF                 (IPU_REG_BASE + 0x0088)
+#define IC_PRP_ENC_RSC          (IPU_REG_BASE + 0x008C)
+#define IC_PRP_VF_RSC           (IPU_REG_BASE + 0x0090)
+#define IC_PP_RSC               (IPU_REG_BASE + 0x0094)
+#define IC_CMBP_1               (IPU_REG_BASE + 0x0098)
+#define IC_CMBP_2               (IPU_REG_BASE + 0x009C)
+#define PF_CONF                 (IPU_REG_BASE + 0x00A0)
+#define IDMAC_CONF              (IPU_REG_BASE + 0x00A4)
+#define IDMAC_CHA_EN            (IPU_REG_BASE + 0x00A8)
+#define IDMAC_CHA_PRI           (IPU_REG_BASE + 0x00AC)
+#define IDMAC_CHA_BUSY          (IPU_REG_BASE + 0x00B0)
+/* SDC Registers */
+#define SDC_COM_CONF            (IPU_REG_BASE + 0x00B4)
+#define SDC_GW_CTRL             (IPU_REG_BASE + 0x00B8)
+#define SDC_FG_POS              (IPU_REG_BASE + 0x00BC)
+#define SDC_BG_POS              (IPU_REG_BASE + 0x00C0)
+#define SDC_CUR_POS             (IPU_REG_BASE + 0x00C4)
+#define SDC_PWM_CTRL            (IPU_REG_BASE + 0x00C8)
+#define SDC_CUR_MAP             (IPU_REG_BASE + 0x00CC)
+#define SDC_HOR_CONF            (IPU_REG_BASE + 0x00D0)
+#define SDC_VER_CONF            (IPU_REG_BASE + 0x00D4)
+#define SDC_SHARP_CONF_1        (IPU_REG_BASE + 0x00D8)
+#define SDC_SHARP_CONF_2        (IPU_REG_BASE + 0x00DC)
+/* ADC Registers */
+#define ADC_CONF                (IPU_REG_BASE + 0x00E0)
+#define ADC_SYSCHA1_SA          (IPU_REG_BASE + 0x00E4)
+#define ADC_SYSCHA2_SA          (IPU_REG_BASE + 0x00E8)
+#define ADC_PRPCHAN_SA          (IPU_REG_BASE + 0x00EC)
+#define ADC_PPCHAN_SA           (IPU_REG_BASE + 0x00F0)
+#define ADC_DISP0_CONF          (IPU_REG_BASE + 0x00F4)
+#define ADC_DISP0_RD_AP         (IPU_REG_BASE + 0x00F8)
+#define ADC_DISP0_RDM           (IPU_REG_BASE + 0x00FC)
+#define ADC_DISP0_SS            (IPU_REG_BASE + 0x0100)
+#define ADC_DISP1_CONF          (IPU_REG_BASE + 0x0104)
+#define ADC_DISP1_RD_AP         (IPU_REG_BASE + 0x0108)
+#define ADC_DISP1_RDM           (IPU_REG_BASE + 0x010C)
+#define ADC_DISP12_SS           (IPU_REG_BASE + 0x0110)
+#define ADC_DISP2_CONF          (IPU_REG_BASE + 0x0114)
+#define ADC_DISP2_RD_AP         (IPU_REG_BASE + 0x0118)
+#define ADC_DISP2_RDM           (IPU_REG_BASE + 0x011C)
+#define ADC_DISP_VSYNC          (IPU_REG_BASE + 0x0120)
+/* Display Interface re(sters */
+#define DI_DISP_IF_CONF         (IPU_REG_BASE + 0x0124)
+#define DI_DISP_SIG_POL         (IPU_REG_BASE + 0x0128)
+#define DI_SER_DISP1_CONF       (IPU_REG_BASE + 0x012C)
+#define DI_SER_DISP2_CONF       (IPU_REG_BASE + 0x0130)
+#define DI_HSP_CLK_PER          (IPU_REG_BASE + 0x0134)
+#define DI_DISP0_TIME_CONF_1    (IPU_REG_BASE + 0x0138)
+#define DI_DISP0_TIME_CONF_2    (IPU_REG_BASE + 0x013C)
+#define DI_DISP0_TIME_CONF_3    (IPU_REG_BASE + 0x0140)
+#define DI_DISP1_TIME_CONF_1    (IPU_REG_BASE + 0x0144)
+#define DI_DISP1_TIME_CONF_2    (IPU_REG_BASE + 0x0148)
+#define DI_DISP1_TIME_CONF_3    (IPU_REG_BASE + 0x014C)
+#define DI_DISP2_TIME_CONF_1    (IPU_REG_BASE + 0x0150)
+#define DI_DISP2_TIME_CONF_2    (IPU_REG_BASE + 0x0154)
+#define DI_DISP2_TIME_CONF_3    (IPU_REG_BASE + 0x0158)
+#define DI_DISP3_TIME_CONF      (IPU_REG_BASE + 0x015C)
+#define DI_DISP0_DB0_MAP        (IPU_REG_BASE + 0x0160)
+#define DI_DISP0_DB1_MAP        (IPU_REG_BASE + 0x0164)
+#define DI_DISP0_DB2_MAP        (IPU_REG_BASE + 0x0168)
+#define DI_DISP0_CB0_MAP        (IPU_REG_BASE + 0x016C)
+#define DI_DISP0_CB1_MAP        (IPU_REG_BASE + 0x0170)
+#define DI_DISP0_CB2_MAP        (IPU_REG_BASE + 0x0174)
+#define DI_DISP1_DB0_MAP        (IPU_REG_BASE + 0x0178)
+#define DI_DISP1_DB1_MAP        (IPU_REG_BASE + 0x017C)
+#define DI_DISP1_DB2_MAP        (IPU_REG_BASE + 0x0180)
+#define DI_DISP1_CB0_MAP        (IPU_REG_BASE + 0x0184)
+#define DI_DISP1_CB1_MAP        (IPU_REG_BASE + 0x0188)
+#define DI_DISP1_CB2_MAP        (IPU_REG_BASE + 0x018C)
+#define DI_DISP2_DB0_MAP        (IPU_REG_BASE + 0x0190)
+#define DI_DISP2_DB1_MAP        (IPU_REG_BASE + 0x0194)
+#define DI_DISP2_DB2_MAP        (IPU_REG_BASE + 0x0198)
+#define DI_DISP2_CB0_MAP        (IPU_REG_BASE + 0x019C)
+#define DI_DISP2_CB1_MAP        (IPU_REG_BASE + 0x01A0)
+#define DI_DISP2_CB2_MAP        (IPU_REG_BASE + 0x01A4)
+#define DI_DISP3_B0_MAP         (IPU_REG_BASE + 0x01A8)
+#define DI_DISP3_B1_MAP         (IPU_REG_BASE + 0x01AC)
+#define DI_DISP3_B2_MAP         (IPU_REG_BASE + 0x01B0)
+#define DI_DISP_ACC_CC          (IPU_REG_BASE + 0x01B4)
+#define DI_DISP_LLA_CONF        (IPU_REG_BASE + 0x01B8)
+#define DI_DISP_LLA_DATA        (IPU_REG_BASE + 0x01BC)
+
+#define IPUIRQ_2_STATREG(int)   (IPU_INT_STAT_1 + 4*(int>>5))
+#define IPUIRQ_2_CTRLREG(int)   (IPU_INT_CTRL_1 + 4*(int>>5))
+#define IPUIRQ_2_MASK(int)      (1UL << (int & 0x1F))
+
+enum {
+	IPU_CONF_CSI_EN = 0x00000001,
+	IPU_CONF_IC_EN = 0x00000002,
+	IPU_CONF_ROT_EN = 0x00000004,
+	IPU_CONF_PF_EN = 0x00000008,
+	IPU_CONF_SDC_EN = 0x00000010,
+	IPU_CONF_ADC_EN = 0x00000020,
+	IPU_CONF_DI_EN = 0x00000040,
+	IPU_CONF_DU_EN = 0x00000080,
+	IPU_CONF_PXL_ENDIAN = 0x00000100,
+
+	FS_PRPVF_ROT_SRC_SEL = 0x00000040,
+	FS_PRPENC_ROT_SRC_SEL = 0x00000020,
+	FS_PRPENC_DEST_SEL = 0x00000010,
+	FS_PP_SRC_SEL_MASK = 0x00000300,
+	FS_PP_SRC_SEL_OFFSET = 8,
+	FS_PP_ROT_SRC_SEL_MASK = 0x00000C00,
+	FS_PP_ROT_SRC_SEL_OFFSET = 10,
+	FS_PF_DEST_SEL_MASK = 0x00003000,
+	FS_PF_DEST_SEL_OFFSET = 12,
+	FS_PRPVF_DEST_SEL_MASK = 0x00070000,
+	FS_PRPVF_DEST_SEL_OFFSET = 16,
+	FS_PRPVF_ROT_DEST_SEL_MASK = 0x00700000,
+	FS_PRPVF_ROT_DEST_SEL_OFFSET = 20,
+	FS_PP_DEST_SEL_MASK = 0x07000000,
+	FS_PP_DEST_SEL_OFFSET = 24,
+	FS_PP_ROT_DEST_SEL_MASK = 0x70000000,
+	FS_PP_ROT_DEST_SEL_OFFSET = 28,
+	FS_VF_IN_VALID = 0x00000002,
+	FS_ENC_IN_VALID = 0x00000001,
+
+	FS_SDC_BG_SRC_SEL_MASK = 0x00000007,
+	FS_SDC_BG_SRC_SEL_OFFSET = 0,
+	FS_SDC_FG_SRC_SEL_MASK = 0x00000070,
+	FS_SDC_FG_SRC_SEL_OFFSET = 4,
+	FS_ADC1_SRC_SEL_MASK = 0x00000700,
+	FS_ADC1_SRC_SEL_OFFSET = 8,
+	FS_ADC2_SRC_SEL_MASK = 0x00007000,
+	FS_ADC2_SRC_SEL_OFFSET = 12,
+	FS_AUTO_REF_PER_MASK = 0x03FF0000,
+	FS_AUTO_REF_PER_OFFSET = 16,
+
+	FS_DEST_ARM = 0,
+	FS_DEST_ROT = 1,
+	FS_DEST_PP = 1,
+	FS_DEST_ADC1 = 2,
+	FS_DEST_ADC2 = 3,
+	FS_DEST_SDC_BG = 4,
+	FS_DEST_SDC_FG = 5,
+	FS_DEST_ADC = 6,
+
+	FS_SRC_ARM = 0,
+	FS_PP_SRC_PF = 1,
+	FS_PP_SRC_ROT = 2,
+
+	FS_ROT_SRC_PP = 1,
+	FS_ROT_SRC_PF = 2,
+
+	FS_PF_DEST_PP = 1,
+	FS_PF_DEST_ROT = 2,
+
+	FS_SRC_ROT_VF = 1,
+	FS_SRC_ROT_PP = 2,
+	FS_SRC_VF = 3,
+	FS_SRC_PP = 4,
+	FS_SRC_SNOOP = 5,
+	FS_SRC_AUTOREF = 6,
+	FS_SRC_AUTOREF_SNOOP = 7,
+
+	TSTAT_PF_H264_PAUSE = 0x00000001,
+	TSTAT_CSI2MEM_MASK = 0x0000000C,
+	TSTAT_CSI2MEM_OFFSET = 2,
+	TSTAT_VF_MASK = 0x00000600,
+	TSTAT_VF_OFFSET = 9,
+	TSTAT_VF_ROT_MASK = 0x000C0000,
+	TSTAT_VF_ROT_OFFSET = 18,
+	TSTAT_ENC_MASK = 0x00000180,
+	TSTAT_ENC_OFFSET = 7,
+	TSTAT_ENC_ROT_MASK = 0x00030000,
+	TSTAT_ENC_ROT_OFFSET = 16,
+	TSTAT_PP_MASK = 0x00001800,
+	TSTAT_PP_OFFSET = 11,
+	TSTAT_PP_ROT_MASK = 0x00300000,
+	TSTAT_PP_ROT_OFFSET = 20,
+	TSTAT_PF_MASK = 0x00C00000,
+	TSTAT_PF_OFFSET = 22,
+	TSTAT_ADCSYS1_MASK = 0x03000000,
+	TSTAT_ADCSYS1_OFFSET = 24,
+	TSTAT_ADCSYS2_MASK = 0x0C000000,
+	TSTAT_ADCSYS2_OFFSET = 26,
+
+	TASK_STAT_IDLE = 0,
+	TASK_STAT_ACTIVE = 1,
+	TASK_STAT_WAIT4READY = 2,
+
+	/* Register bits */
+	SDC_COM_TFT_COLOR = 0x00000001UL,
+	SDC_COM_FG_EN = 0x00000010UL,
+	SDC_COM_GWSEL = 0x00000020UL,
+	SDC_COM_GLB_A = 0x00000040UL,
+	SDC_COM_KEY_COLOR_G = 0x00000080UL,
+	SDC_COM_BG_EN = 0x00000200UL,
+	SDC_COM_SHARP = 0x00001000UL,
+
+	SDC_V_SYNC_WIDTH_L = 0x00000001UL,
+
+	ADC_CONF_PRP_EN = 0x00000001L,
+	ADC_CONF_PP_EN = 0x00000002L,
+	ADC_CONF_MCU_EN = 0x00000004L,
+
+	ADC_DISP_CONF_SL_MASK = 0x00000FFFL,
+	ADC_DISP_CONF_TYPE_MASK = 0x00003000L,
+	ADC_DISP_CONF_TYPE_XY = 0x00002000L,
+
+	ADC_DISP_VSYNC_D0_MODE_MASK = 0x00000003L,
+	ADC_DISP_VSYNC_D0_WIDTH_MASK = 0x003F0000L,
+	ADC_DISP_VSYNC_D12_MODE_MASK = 0x0000000CL,
+	ADC_DISP_VSYNC_D12_WIDTH_MASK = 0x3F000000L,
+
+	/* Image Converter Register bits */
+	IC_CONF_PRPENC_EN = 0x00000001,
+	IC_CONF_PRPENC_CSC1 = 0x00000002,
+	IC_CONF_PRPENC_ROT_EN = 0x00000004,
+	IC_CONF_PRPVF_EN = 0x00000100,
+	IC_CONF_PRPVF_CSC1 = 0x00000200,
+	IC_CONF_PRPVF_CSC2 = 0x00000400,
+	IC_CONF_PRPVF_CMB = 0x00000800,
+	IC_CONF_PRPVF_ROT_EN = 0x00001000,
+	IC_CONF_PP_EN = 0x00010000,
+	IC_CONF_PP_CSC1 = 0x00020000,
+	IC_CONF_PP_CSC2 = 0x00040000,
+	IC_CONF_PP_CMB = 0x00080000,
+	IC_CONF_PP_ROT_EN = 0x00100000,
+	IC_CONF_IC_GLB_LOC_A = 0x10000000,
+	IC_CONF_KEY_COLOR_EN = 0x20000000,
+	IC_CONF_RWS_EN = 0x40000000,
+	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
+
+	IDMA_CHAN_INVALID = 0x000000FF,
+	IDMA_IC_0 = 0x00000001,
+	IDMA_IC_1 = 0x00000002,
+	IDMA_IC_2 = 0x00000004,
+	IDMA_IC_3 = 0x00000008,
+	IDMA_IC_4 = 0x00000010,
+	IDMA_IC_5 = 0x00000020,
+	IDMA_IC_6 = 0x00000040,
+	IDMA_IC_7 = 0x00000080,
+	IDMA_IC_8 = 0x00000100,
+	IDMA_IC_9 = 0x00000200,
+	IDMA_IC_10 = 0x00000400,
+	IDMA_IC_11 = 0x00000800,
+	IDMA_IC_12 = 0x00001000,
+	IDMA_IC_13 = 0x00002000,
+	IDMA_SDC_BG = 0x00004000,
+	IDMA_SDC_FG = 0x00008000,
+	IDMA_SDC_MASK = 0x00010000,
+	IDMA_SDC_PARTIAL = 0x00020000,
+	IDMA_ADC_SYS1_WR = 0x00040000,
+	IDMA_ADC_SYS2_WR = 0x00080000,
+	IDMA_ADC_SYS1_CMD = 0x00100000,
+	IDMA_ADC_SYS2_CMD = 0x00200000,
+	IDMA_ADC_SYS1_RD = 0x00400000,
+	IDMA_ADC_SYS2_RD = 0x00800000,
+	IDMA_PF_QP = 0x01000000,
+	IDMA_PF_BSP = 0x02000000,
+	IDMA_PF_Y_IN = 0x04000000,
+	IDMA_PF_U_IN = 0x08000000,
+	IDMA_PF_V_IN = 0x10000000,
+	IDMA_PF_Y_OUT = 0x20000000,
+	IDMA_PF_U_OUT = 0x40000000,
+	IDMA_PF_V_OUT = 0x80000000,
+
+	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
+	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0x00000000L,
+	CSI_SENS_CONF_DATA_FMT_YUV422 = 0x00000200L,
+	CSI_SENS_CONF_DATA_FMT_BAYER = 0x00000300L,
+
+	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
+	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
+	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
+	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
+	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
+	CSI_SENS_CONF_SENS_CLKSRC_SHIFT = 7,
+	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 10,
+	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
+	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
+
+	PF_CONF_TYPE_MASK = 0x00000007,
+	PF_CONF_TYPE_SHIFT = 0,
+	PF_CONF_PAUSE_EN = 0x00000010,
+	PF_CONF_RESET = 0x00008000,
+	PF_CONF_PAUSE_ROW_MASK = 0x00FF0000,
+	PF_CONF_PAUSE_ROW_SHIFT = 16,
+
+	/* DI_DISP_SIG_POL bits */
+	DI_D3_VSYNC_POL_SHIFT = 28,
+	DI_D3_HSYNC_POL_SHIFT = 27,
+	DI_D3_DRDY_SHARP_POL_SHIFT = 26,
+	DI_D3_CLK_POL_SHIFT = 25,
+	DI_D3_DATA_POL_SHIFT = 24,
+
+	/* DI_DISP_IF_CONF bits */
+	DI_D3_CLK_IDLE_SHIFT = 26,
+	DI_D3_CLK_SEL_SHIFT = 25,
+	DI_D3_DATAMSK_SHIFT = 24,
+
+	DISPx_IF_CLK_DOWN_OFFSET = 22,
+	DISPx_IF_CLK_UP_OFFSET = 12,
+	DISPx_IF_CLK_PER_OFFSET = 0,
+	DISPx_IF_CLK_READ_EN_OFFSET = 16,
+	DISPx_PIX_CLK_PER_OFFSET = 0,
+
+	DI_CONF_DISP0_EN = 0x00000001L,
+	DI_CONF_DISP0_IF_MODE_OFFSET = 1,
+	DI_CONF_DISP0_BURST_MODE_OFFSET = 3,
+	DI_CONF_DISP1_EN = 0x00000100L,
+	DI_CONF_DISP1_IF_MODE_OFFSET = 9,
+	DI_CONF_DISP1_BURST_MODE_OFFSET = 12,
+	DI_CONF_DISP2_EN = 0x00010000L,
+	DI_CONF_DISP2_IF_MODE_OFFSET = 17,
+	DI_CONF_DISP2_BURST_MODE_OFFSET = 20,
+
+	DI_SER_DISPx_CONF_SER_BIT_NUM_OFFSET = 16,
+	DI_SER_DISPx_CONF_PREAMBLE_OFFSET = 8,
+	DI_SER_DISPx_CONF_PREAMBLE_LEN_OFFSET = 4,
+	DI_SER_DISPx_CONF_RW_CFG_OFFSET = 1,
+	DI_SER_DISPx_CONF_BURST_MODE_EN = 0x01000000L,
+	DI_SER_DISPx_CONF_PREAMBLE_EN = 0x00000001L,
+
+	/* DI_DISP_ACC_CC */
+	DISP0_IF_CLK_CNT_D_MASK = 0x00000003L,
+	DISP0_IF_CLK_CNT_D_OFFSET = 0,
+	DISP0_IF_CLK_CNT_C_MASK = 0x0000000CL,
+	DISP0_IF_CLK_CNT_C_OFFSET = 2,
+	DISP1_IF_CLK_CNT_D_MASK = 0x00000030L,
+	DISP1_IF_CLK_CNT_D_OFFSET = 4,
+	DISP1_IF_CLK_CNT_C_MASK = 0x000000C0L,
+	DISP1_IF_CLK_CNT_C_OFFSET = 6,
+	DISP2_IF_CLK_CNT_D_MASK = 0x00000300L,
+	DISP2_IF_CLK_CNT_D_OFFSET = 8,
+	DISP2_IF_CLK_CNT_C_MASK = 0x00000C00L,
+	DISP2_IF_CLK_CNT_C_OFFSET = 10,
+	DISP3_IF_CLK_CNT_MASK = 0x00003000L,
+	DISP3_IF_CLK_CNT_OFFSET = 12,
+};
+
+#endif
diff --git a/drivers/mxc/ipu/ipu_sdc.c b/drivers/mxc/ipu/ipu_sdc.c
new file mode 100644
index 0000000..3c3ab7d
--- /dev/null
+++ b/drivers/mxc/ipu/ipu_sdc.c
@@ -0,0 +1,356 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_sdc.c
+ *
+ * @brief IPU SDC submodule API functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include "ipu.h"
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+static uint32_t g_h_start_width;
+static uint32_t g_v_start_width;
+
+static const uint32_t di_mappings[] = {
+	0x1600AAAA, 0x00E05555, 0x00070000, 3,	/* RGB888 */
+	0x0005000F, 0x000B000F, 0x0011000F, 1,	/* RGB666 */
+	0x0011000F, 0x000B000F, 0x0005000F, 1,	/* BGR666 */
+	0x0004003F, 0x000A000F, 0x000F003F, 1	/* RGB565 */
+};
+
+/*!
+ * This function is called to initialize a synchronous LCD panel.
+ *
+ * @param       panel           The type of panel.
+ *
+ * @param       pixel_clk       Desired pixel clock frequency in Hz.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer. Pixel
+ *                              format is a FOURCC ASCII code.
+ *
+ * @param       width           The width of panel in pixels.
+ *
+ * @param       height          The height of panel in pixels.
+ *
+ * @param       hStartWidth     The number of pixel clocks between the HSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       hSyncWidth      The width of the HSYNC signal in units of pixel
+ *                              clocks.
+ *
+ * @param       hEndWidth       The number of pixel clocks between the end of
+ *                              valid data and the HSYNC signal for next line.
+ *
+ * @param       vStartWidth     The number of lines between the VSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       vSyncWidth      The width of the VSYNC signal in units of lines
+ *
+ * @param       vEndWidth       The number of lines between the end of valid
+ *                              data and the VSYNC signal for next frame.
+ *
+ * @param       sig             Bitfield of signal polarities for LCD interface.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t h_start_width, uint16_t h_sync_width,
+			   uint16_t h_end_width, uint16_t v_start_width,
+			   uint16_t vSyncWidth, uint16_t v_end_width,
+			   ipu_di_signal_cfg_t sig)
+{
+	uint32_t lock_flags;
+	uint32_t reg;
+	uint32_t old_conf;
+	uint32_t div;
+
+	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
+
+	if ((vSyncWidth == 0) || (h_sync_width == 0))
+		return EINVAL;
+
+	/* Init panel size and blanking periods */
+	reg =
+	    ((uint32_t) (h_sync_width - 1) << 26) |
+	    ((uint32_t) (width + h_start_width + h_end_width - 1) << 16);
+	__raw_writel(reg, SDC_HOR_CONF);
+
+	reg = ((uint32_t) (vSyncWidth - 1) << 26) | SDC_V_SYNC_WIDTH_L |
+	    ((uint32_t) (height + v_start_width + v_end_width - 1) << 16);
+	__raw_writel(reg, SDC_VER_CONF);
+
+	g_h_start_width = h_start_width;
+	g_v_start_width = v_start_width;
+
+	switch (panel) {
+	case IPU_PANEL_SHARP_TFT:
+		__raw_writel(0x00FD0102L, SDC_SHARP_CONF_1);
+		__raw_writel(0x00F500F4L, SDC_SHARP_CONF_2);
+		__raw_writel(SDC_COM_SHARP | SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		break;
+	case IPU_PANEL_TFT:
+		__raw_writel(SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		break;
+	default:
+		return EINVAL;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Init clocking */
+
+	/* Calculate divider */
+	/* fractional part is 4 bits so simply
+	 * multiple by 2^4 to get fractional part */
+	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
+	div = (g_ipu_clk * 16) / pixel_clk;
+	if (div < 0x40) {	/* Divider less than 4 */
+		dev_dbg(g_ipu_dev,
+			"InitPanel() - Pixel clock divider less than 1\n");
+		div = 0x40;
+	}
+	/* DISP3_IF_CLK_DOWN_WR is half the divider
+	 * value and 2 less fraction bits */
+	/* Subtract 1 extra from DISP3_IF_CLK_DOWN_WR
+	 * based on timing debug     */
+	/* DISP3_IF_CLK_UP_WR is 0 */
+	__raw_writel((((div / 8) - 1) << 22) | div, DI_DISP3_TIME_CONF);
+
+	/* DI settings */
+	old_conf = __raw_readl(DI_DISP_IF_CONF) & 0x78FFFFFF;
+	old_conf |= sig.datamask_en << DI_D3_DATAMSK_SHIFT |
+	    sig.clksel_en << DI_D3_CLK_SEL_SHIFT |
+	    sig.clkidle_en << DI_D3_CLK_IDLE_SHIFT;
+	__raw_writel(old_conf, DI_DISP_IF_CONF);
+
+	old_conf = __raw_readl(DI_DISP_SIG_POL) & 0xE0FFFFFF;
+	old_conf |= sig.data_pol << DI_D3_DATA_POL_SHIFT |
+	    sig.clk_pol << DI_D3_CLK_POL_SHIFT |
+	    sig.enable_pol << DI_D3_DRDY_SHARP_POL_SHIFT |
+	    sig.Hsync_pol << DI_D3_HSYNC_POL_SHIFT |
+	    sig.Vsync_pol << DI_D3_VSYNC_POL_SHIFT;
+	__raw_writel(old_conf, DI_DISP_SIG_POL);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_RGB24:
+		__raw_writel(di_mappings[0], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[1], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[2], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[3] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	case IPU_PIX_FMT_RGB666:
+		__raw_writel(di_mappings[4], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[5], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[6], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[7] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	case IPU_PIX_FMT_BGR666:
+		__raw_writel(di_mappings[8], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[9], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[10], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[11] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	default:
+		__raw_writel(di_mappings[12], DI_DISP3_B0_MAP);
+		__raw_writel(di_mappings[13], DI_DISP3_B1_MAP);
+		__raw_writel(di_mappings[14], DI_DISP3_B2_MAP);
+		__raw_writel(__raw_readl(DI_DISP_ACC_CC) |
+			     ((di_mappings[15] - 1) << 12), DI_DISP_ACC_CC);
+		break;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	dev_dbg(g_ipu_dev, "DI_DISP_IF_CONF = 0x%08X\n",
+		__raw_readl(DI_DISP_IF_CONF));
+	dev_dbg(g_ipu_dev, "DI_DISP_SIG_POL = 0x%08X\n",
+		__raw_readl(DI_DISP_SIG_POL));
+	dev_dbg(g_ipu_dev, "DI_DISP3_TIME_CONF = 0x%08X\n",
+		__raw_readl(DI_DISP3_TIME_CONF));
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_init_panel);
+
+/*!
+ * This function sets the foreground and background
+ * plane global alpha blending
+ * modes.
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *		blending. If disabled, per pixel blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(SDC_GW_CTRL) & 0x00FFFFFFL;
+		__raw_writel(reg | ((uint32_t) alpha << 24), SDC_GW_CTRL);
+
+		reg = __raw_readl(SDC_COM_CONF);
+		__raw_writel(reg | SDC_COM_GLB_A, SDC_COM_CONF);
+	} else {
+		reg = __raw_readl(SDC_COM_CONF);
+		__raw_writel(reg & ~SDC_COM_GLB_A, SDC_COM_CONF);
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_global_alpha);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color to use as transparent color key.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t color_key)
+{
+	uint32_t reg, sdc_conf;
+	uint32_t lock_flags;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	sdc_conf = __raw_readl(SDC_COM_CONF);
+	if (channel == MEM_SDC_BG)
+		sdc_conf &= ~SDC_COM_GWSEL;
+	else
+		sdc_conf |= SDC_COM_GWSEL;
+
+	if (enable) {
+		reg = __raw_readl(SDC_GW_CTRL) & 0xFF000000L;
+		__raw_writel(reg | (color_key & 0x00FFFFFFL), SDC_GW_CTRL);
+
+		sdc_conf |= SDC_COM_KEY_COLOR_G;
+	} else
+		sdc_conf &= ~SDC_COM_KEY_COLOR_G;
+	__raw_writel(sdc_conf, SDC_COM_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_color_key);
+
+int32_t ipu_sdc_set_brightness(uint8_t value)
+{
+	__raw_writel(0x03000000UL | value << 16, SDC_PWM_CTRL);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_brightness);
+
+/*!
+ * This function sets the window position of the foreground or background plane.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       x_pos           The X coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @param       y_pos           The Y coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @return      This function returns 0 on success or negative error code on fail
+ */
+int32_t ipu_sdc_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+			       int16_t y_pos)
+{
+	x_pos += g_h_start_width;
+	y_pos += g_v_start_width;
+
+	if (channel == MEM_SDC_BG)
+		__raw_writel((x_pos << 16) | y_pos, SDC_BG_POS);
+	else if (channel == MEM_SDC_FG)
+		__raw_writel((x_pos << 16) | y_pos, SDC_FG_POS);
+	else
+		return EINVAL;
+	return 0;
+}
+EXPORT_SYMBOL(ipu_sdc_set_window_pos);
+
+void _ipu_sdc_fg_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	(void)params;
+
+	/* Enable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg | SDC_COM_FG_EN | SDC_COM_BG_EN, SDC_COM_CONF);
+}
+
+uint32_t _ipu_sdc_fg_uninit(void)
+{
+	uint32_t reg;
+
+	/* Disable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg & ~SDC_COM_FG_EN, SDC_COM_CONF);
+
+	return reg & SDC_COM_FG_EN;
+}
+
+void _ipu_sdc_bg_init(ipu_channel_params_t *params)
+{
+	uint32_t reg;
+	(void)params;
+
+	/* Enable FG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg | SDC_COM_BG_EN, SDC_COM_CONF);
+}
+
+uint32_t _ipu_sdc_bg_uninit(void)
+{
+	uint32_t reg;
+
+	/* Disable BG channel */
+	reg = __raw_readl(SDC_COM_CONF);
+	__raw_writel(reg & ~SDC_COM_BG_EN, SDC_COM_CONF);
+
+	return reg & SDC_COM_BG_EN;
+}
diff --git a/drivers/mxc/ipu/pf/Kconfig b/drivers/mxc/ipu/pf/Kconfig
new file mode 100644
index 0000000..02cda91
--- /dev/null
+++ b/drivers/mxc/ipu/pf/Kconfig
@@ -0,0 +1,7 @@
+config MXC_IPU_PF
+	tristate "MXC MPEG4/H.264 Post Filter Driver"
+	depends on MXC_IPU
+    default y
+	help
+        Driver for MPEG4 dering and deblock and H.264 deblock
+        using MXC IPU h/w
diff --git a/drivers/mxc/ipu/pf/Makefile b/drivers/mxc/ipu/pf/Makefile
new file mode 100644
index 0000000..3fdccc4
--- /dev/null
+++ b/drivers/mxc/ipu/pf/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MXC_IPU_PF) += mxc_pf.o
+
diff --git a/drivers/mxc/ipu/pf/mxc_pf.c b/drivers/mxc/ipu/pf/mxc_pf.c
new file mode 100644
index 0000000..c0cc13e
--- /dev/null
+++ b/drivers/mxc/ipu/pf/mxc_pf.c
@@ -0,0 +1,937 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 WindRiver System, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_pf.c
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+
+#include <linux/pagemap.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/plat-mxc/mxc_pf.h>
+
+#include "ipu.h"
+
+struct mxc_pf_data {
+	pf_operation_t mode;
+	u32 pf_enabled;
+	u32 width;
+	u32 height;
+	u32 stride;
+	uint32_t qp_size;
+	dma_addr_t qp_paddr;
+	void *qp_vaddr;
+	pf_buf buf[PF_MAX_BUFFER_CNT];
+	void *buf_vaddr[PF_MAX_BUFFER_CNT];
+	wait_queue_head_t pf_wait;
+	volatile int done_flag;
+	volatile int busy_flag;
+	bool buffer_dirty;
+	struct semaphore busy_lock;
+};
+
+static struct mxc_pf_data pf_data;
+static u8 open_count;
+static struct class *mxc_pf_class;
+
+/*
+ * Function definitions
+ */
+
+static irqreturn_t mxc_pf_irq_handler(int irq, void *dev_id)
+{
+	struct mxc_pf_data *pf = dev_id;
+	pf->done_flag++;
+
+	if ((pf->done_flag == 3) || (pf->mode == PF_MPEG4_DERING)) {
+		pf->done_flag = 4;
+		wake_up_interruptible(&pf->pf_wait);
+	}
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function handles PF_IOCTL_INIT calls. It initializes the PF channels,
+ * interrupt handlers, and channel buffers.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_init(pf_init_params *pf_init)
+{
+	int err;
+	ipu_channel_params_t params;
+	u32 w;
+	u32 stride;
+	u32 h;
+	u32 qp_size = 0;
+	u32 qp_stride;
+
+	pf_data.mode = pf_init->pf_mode;
+	w = pf_data.width = pf_init->width;
+	h = pf_data.height = pf_init->height;
+	stride = pf_data.stride = pf_init->stride;
+	pf_data.qp_size = pf_init->qp_size;
+
+	memset(&params, 0, sizeof(params));
+	params.mem_pf_mem.operation = pf_data.mode;
+	err = ipu_init_channel(MEM_PF_Y_MEM, &params);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing channel\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_Y_MEM, IPU_INPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing Y input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_Y_MEM, IPU_OUTPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing Y output buffer\n");
+		goto err0;
+	}
+
+	w = w / 2;
+	h = h / 2;
+	stride = stride / 2;
+
+	err = ipu_init_channel_buffer(MEM_PF_U_MEM, IPU_INPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing U input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_U_MEM, IPU_OUTPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing U output buffer\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_V_MEM, IPU_INPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing V input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_init_channel_buffer(MEM_PF_V_MEM, IPU_OUTPUT_BUFFER,
+				      IPU_PIX_FMT_GENERIC, w, h, stride,
+				      IPU_ROTATE_NONE, 0, 0, 0, 0);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error initializing V output buffer\n");
+		goto err0;
+	}
+	/*Setup Channel QF and BSC Params */
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+		w = ((pf_data.width + 15) / 16);
+		h = (pf_data.height + 15) / 16;
+		qp_stride = w;
+		qp_size = 4 * qp_stride * h;
+		pr_debug("H264 QP width = %d, height = %d\n", w, h);
+		err = ipu_init_channel_buffer(MEM_PF_Y_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC_32, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing H264 QP buffer\n");
+			goto err0;
+		}
+		w *= 4;
+		h *= 4;
+		qp_stride = w;
+		err = ipu_init_channel_buffer(MEM_PF_U_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing H264 BSB buffer\n");
+			goto err0;
+		}
+		qp_size += qp_stride * h;
+	} else {		/* MPEG4 mode */
+
+		w = (pf_data.width + 15) / 16;
+		h = (pf_data.height + 15) / 16;
+		qp_stride = (w + 3) & ~0x3UL;
+		pr_debug("MPEG4 QP width = %d, height = %d, stride = %d\n",
+			 w, h, qp_stride);
+		err = ipu_init_channel_buffer(MEM_PF_Y_MEM,
+					      IPU_SEC_INPUT_BUFFER,
+					      IPU_PIX_FMT_GENERIC, w, h,
+					      qp_stride, IPU_ROTATE_NONE, 0, 0,
+					      0, 0);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error initializing MPEG4 QP buffer\n");
+			goto err0;
+		}
+		qp_size = qp_stride * h;
+	}
+
+	if (pf_data.qp_size > qp_size)
+		qp_size = pf_data.qp_size;
+	else
+		pf_data.qp_size = qp_size;
+
+	pf_data.qp_vaddr = dma_alloc_coherent(NULL, pf_data.qp_size,
+					      &pf_data.qp_paddr,
+					      GFP_KERNEL | GFP_DMA);
+	if (!pf_data.qp_vaddr)
+		return -ENOMEM;
+
+	pf_init->qp_paddr = pf_data.qp_paddr;
+	pf_init->qp_size = pf_data.qp_size;
+
+	return 0;
+
+err0:
+	return err;
+}
+
+/*!
+ * This function handles PF_IOCTL_UNINIT calls. It uninitializes the PF
+ * channels and interrupt handlers.
+ *
+ * @return      This function returns 0 on success or negative error code
+ *              on error.
+ */
+static int mxc_pf_uninit(void)
+{
+	pf_data.pf_enabled = 0;
+	ipu_disable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+	ipu_disable_irq(IPU_IRQ_PF_U_OUT_EOF);
+	ipu_disable_irq(IPU_IRQ_PF_V_OUT_EOF);
+
+	ipu_disable_channel(MEM_PF_Y_MEM, true);
+	ipu_disable_channel(MEM_PF_U_MEM, true);
+	ipu_disable_channel(MEM_PF_V_MEM, true);
+	ipu_uninit_channel(MEM_PF_Y_MEM);
+	ipu_uninit_channel(MEM_PF_U_MEM);
+	ipu_uninit_channel(MEM_PF_V_MEM);
+
+	if (pf_data.qp_vaddr) {
+		dma_free_coherent(NULL, pf_data.qp_size, pf_data.qp_vaddr,
+				  pf_data.qp_paddr);
+		pf_data.qp_vaddr = NULL;
+	}
+
+	return 0;
+}
+
+/*!
+ * This function handles PF_IOCTL_REQBUFS calls. It initializes the PF channels
+ * and channel buffers.
+ *
+ * @param       reqbufs         Input/Output Structure containing buffer mode,
+ *                              type, offset, and size. The offset and size of
+ *                              the buffer are returned for PF_MEMORY_MMAP mode.
+ *
+ * @return      This function returns 0 on success or negative error code
+ *              on error.
+ */
+static int mxc_pf_reqbufs(pf_reqbufs_params *reqbufs)
+{
+	int err;
+	uint32_t buf_size;
+	int i;
+	int alloc_cnt = 0;
+	pf_buf *buf = pf_data.buf;
+	if (reqbufs->count > PF_MAX_BUFFER_CNT)
+		reqbufs->count = PF_MAX_BUFFER_CNT;
+
+	/* Deallocate mmapped buffers */
+	if (reqbufs->count == 0) {
+		for (i = 0; i < PF_MAX_BUFFER_CNT; i++) {
+			if (buf[i].index != -1) {
+				dma_free_coherent(NULL, buf[i].size,
+						  pf_data.buf_vaddr[i],
+						  buf[i].offset);
+				pf_data.buf_vaddr[i] = NULL;
+				buf[i].index = -1;
+				buf[i].size = 0;
+			}
+		}
+		return 0;
+	}
+
+	buf_size = (pf_data.stride * pf_data.height * 3) / 2;
+	if (reqbufs->req_size > buf_size) {
+		buf_size = reqbufs->req_size;
+		pr_debug("using requested buffer size of %d\n", buf_size);
+	} else {
+		reqbufs->req_size = buf_size;
+		pr_debug("using default buffer size of %d\n", buf_size);
+	}
+
+	for (i = 0; alloc_cnt < reqbufs->count; i++) {
+		buf[i].index = i;
+		buf[i].size = buf_size;
+		pf_data.buf_vaddr[i] = dma_alloc_coherent(NULL, buf[i].size,
+							  &buf[i].offset,
+							  GFP_KERNEL | GFP_DMA);
+		if (!pf_data.buf_vaddr[i] || !buf[i].offset) {
+			printk(KERN_ERR
+			       "mxc_pf: unable to allocate IPU buffers.\n");
+			err = -ENOMEM;
+			goto err0;
+		}
+		pr_debug("Allocated buffer %d at paddr 0x%08X, vaddr %p\n",
+			 i, buf[i].offset, pf_data.buf_vaddr[i]);
+
+		alloc_cnt++;
+	}
+
+	return 0;
+err0:
+	for (i = 0; i < alloc_cnt; i++) {
+		dma_free_coherent(NULL, buf[i].size, pf_data.buf_vaddr[i],
+				  buf[i].offset);
+		pf_data.buf_vaddr[i] = NULL;
+		buf[i].index = -1;
+		buf[i].size = 0;
+	}
+	return err;
+}
+
+/*!
+ * This function handles PF_IOCTL_START calls. It sets the PF channel buffers
+ * addresses and starts the channels
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_start(pf_buf *in, pf_buf *out)
+{
+	int err;
+	dma_addr_t y_in_paddr;
+	dma_addr_t u_in_paddr;
+	dma_addr_t v_in_paddr;
+	dma_addr_t p1_in_paddr;
+	dma_addr_t p2_in_paddr;
+	dma_addr_t y_out_paddr;
+	dma_addr_t u_out_paddr;
+	dma_addr_t v_out_paddr;
+
+	/* H.264 requires output buffer equal to input */
+	if (pf_data.mode == PF_H264_DEBLOCK)
+		out = in;
+
+	y_in_paddr = in->offset + in->y_offset;
+	if (in->u_offset)
+		u_in_paddr = in->offset + in->u_offset;
+	else
+		u_in_paddr = y_in_paddr + (pf_data.stride * pf_data.height);
+	if (in->v_offset)
+		v_in_paddr = in->offset + in->v_offset;
+	else
+		v_in_paddr = u_in_paddr + (pf_data.stride * pf_data.height) / 4;
+	p1_in_paddr = pf_data.qp_paddr;
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+		p2_in_paddr = pf_data.qp_paddr +
+		    ((pf_data.width + 15) / 16) *
+		    ((pf_data.height + 15) / 16) * 4;
+	} else
+		p2_in_paddr = 0;
+
+	pr_debug("y_in_paddr = 0x%08X\nu_in_paddr = 0x%08X\n"
+		 "v_in_paddr = 0x%08X\n"
+		 "qp_paddr = 0x%08X\nbsb_paddr = 0x%08X\n",
+		 y_in_paddr, u_in_paddr, v_in_paddr, p1_in_paddr, p2_in_paddr);
+
+	y_out_paddr = out->offset + out->y_offset;
+	if (out->u_offset)
+		u_out_paddr = out->offset + out->u_offset;
+	else
+		u_out_paddr = y_out_paddr + (pf_data.stride * pf_data.height);
+	if (out->v_offset)
+		v_out_paddr = out->offset + out->v_offset;
+	else
+		v_out_paddr =
+		    u_out_paddr + (pf_data.stride * pf_data.height) / 4;
+
+	pr_debug("y_out_paddr = 0x%08X\nu_out_paddr = 0x%08X\n"
+		 "v_out_paddr = 0x%08X\n",
+		 y_out_paddr, u_out_paddr, v_out_paddr);
+
+	pf_data.done_flag = 0;
+
+	ipu_enable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+	ipu_enable_irq(IPU_IRQ_PF_U_OUT_EOF);
+	ipu_enable_irq(IPU_IRQ_PF_V_OUT_EOF);
+
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM, IPU_INPUT_BUFFER, 0,
+					y_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting Y input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM, IPU_OUTPUT_BUFFER, 0,
+					y_out_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting Y output buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_U_MEM, IPU_INPUT_BUFFER, 0,
+					u_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting U input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_U_MEM, IPU_OUTPUT_BUFFER, 0,
+					u_out_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting U output buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_V_MEM, IPU_INPUT_BUFFER, 0,
+					v_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting V input buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_V_MEM, IPU_OUTPUT_BUFFER, 0,
+					v_out_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting V output buffer\n");
+		goto err0;
+	}
+
+	err = ipu_update_channel_buffer(MEM_PF_Y_MEM, IPU_SEC_INPUT_BUFFER, 0,
+					p1_in_paddr);
+	if (err < 0) {
+		printk(KERN_ERR "mxc_pf: error setting QP buffer\n");
+		goto err0;
+	}
+
+	if (pf_data.mode == PF_H264_DEBLOCK) {
+
+		err = ipu_update_channel_buffer(MEM_PF_U_MEM,
+						IPU_SEC_INPUT_BUFFER, 0,
+						p2_in_paddr);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "mxc_pf: error setting H264 BSB buffer\n");
+			goto err0;
+		}
+		ipu_select_buffer(MEM_PF_U_MEM, IPU_SEC_INPUT_BUFFER, 0);
+	}
+
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_OUTPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_U_MEM, IPU_OUTPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_V_MEM, IPU_OUTPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_U_MEM, IPU_INPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_V_MEM, IPU_INPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_SEC_INPUT_BUFFER, 0);
+	ipu_select_buffer(MEM_PF_Y_MEM, IPU_INPUT_BUFFER, 0);
+
+	if (!pf_data.pf_enabled) {
+		pf_data.pf_enabled = 1;
+		ipu_enable_channel(MEM_PF_V_MEM);
+		ipu_enable_channel(MEM_PF_U_MEM);
+		ipu_enable_channel(MEM_PF_Y_MEM);
+	}
+
+	return 0;
+err0:
+	return err;
+}
+
+/*!
+ * Post Filter driver open function. This function implements the Linux
+ * file_operations.open() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_open(struct inode *inode, struct file *filp)
+{
+	int i;
+
+	if (open_count++ == 0) {
+		memset(&pf_data, 0, sizeof(pf_data));
+		for (i = 0; i < PF_MAX_BUFFER_CNT; i++)
+			pf_data.buf[i].index = -1;
+
+		init_waitqueue_head(&pf_data.pf_wait);
+		init_MUTEX(&pf_data.busy_lock);
+
+		pf_data.busy_flag = 1;
+
+		ipu_request_irq(IPU_IRQ_PF_Y_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_request_irq(IPU_IRQ_PF_U_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_request_irq(IPU_IRQ_PF_V_OUT_EOF, mxc_pf_irq_handler,
+				0, "mxc_ipu_pf", &pf_data);
+
+		ipu_disable_irq(IPU_IRQ_PF_Y_OUT_EOF);
+		ipu_disable_irq(IPU_IRQ_PF_U_OUT_EOF);
+		ipu_disable_irq(IPU_IRQ_PF_V_OUT_EOF);
+	}
+	return 0;
+}
+
+/*!
+ * Post Filter driver release function. This function implements the Linux
+ * file_operations.release() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_release(struct inode *inode, struct file *filp)
+{
+	pf_reqbufs_params req_buf;
+
+	if (--open_count == 0) {
+		mxc_pf_uninit();
+
+		/* Free any allocated buffers */
+		req_buf.count = 0;
+		mxc_pf_reqbufs(&req_buf);
+
+		ipu_free_irq(IPU_IRQ_PF_V_OUT_EOF, &pf_data);
+		ipu_free_irq(IPU_IRQ_PF_U_OUT_EOF, &pf_data);
+		ipu_free_irq(IPU_IRQ_PF_Y_OUT_EOF, &pf_data);
+
+	}
+	return 0;
+}
+
+/*!
+ * Post Filter driver ioctl function. This function implements the Linux
+ * file_operations.ioctl() API function.
+ *
+ * @param       inode           struct inode *
+ *
+ * @param       filp            struct file *
+ *
+ * @param       cmd             IOCTL command to handle
+ *
+ * @param       arg             Pointer to arguments for IOCTL
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              error.
+ */
+static int mxc_pf_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	switch (cmd) {
+	case PF_IOCTL_INIT:
+		{
+			pf_init_params pf_init;
+
+			pr_debug("PF_IOCTL_INIT\n");
+			if (copy_from_user(&pf_init, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			retval = mxc_pf_init(&pf_init);
+			if (retval < 0)
+				break;
+			pf_init.qp_paddr = pf_data.qp_paddr;
+			pf_init.qp_size = pf_data.qp_size;
+
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &pf_init,
+						_IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			pf_data.busy_flag = 0;
+			break;
+		}
+	case PF_IOCTL_UNINIT:
+		pr_debug("PF_IOCTL_UNINIT\n");
+		retval = mxc_pf_uninit();
+		break;
+	case PF_IOCTL_REQBUFS:
+		{
+			pf_reqbufs_params reqbufs;
+			pr_debug("PF_IOCTL_REQBUFS\n");
+
+			if (copy_from_user
+			    (&reqbufs, (void *)arg, _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			retval = mxc_pf_reqbufs(&reqbufs);
+
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &reqbufs,
+						_IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			break;
+		}
+	case PF_IOCTL_QUERYBUF:
+		{
+			pf_buf buf;
+			pr_debug("PF_IOCTL_QUERYBUF\n");
+
+			if (copy_from_user(&buf, (void *)arg, _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if ((buf.index < 0) ||
+			    (buf.index >= PF_MAX_BUFFER_CNT) ||
+			    (pf_data.buf[buf.index].index != buf.index)) {
+				retval = -EINVAL;
+				break;
+			}
+			/* Return size of memory allocated */
+			if (copy_to_user((void *)arg, &pf_data.buf[buf.index],
+					 _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			break;
+		}
+	case PF_IOCTL_START:
+		{
+			int index;
+			pf_start_params start_params;
+			pr_debug("PF_IOCTL_START\n");
+
+			if (pf_data.busy_flag) {
+				retval = -EBUSY;
+				break;
+			}
+
+			if (copy_from_user(&start_params, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (start_params.h264_pause_row >=
+			    ((pf_data.height + 15) / 16)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			pf_data.busy_flag = 1;
+
+			index = start_params.in.index;
+			if ((index >= 0) && (index < PF_MAX_BUFFER_CNT)) {
+				if (pf_data.buf[index].offset !=
+				    start_params.in.offset) {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			index = start_params.out.index;
+			if ((index >= 0) && (index < PF_MAX_BUFFER_CNT)) {
+				if (pf_data.buf[index].offset !=
+				    start_params.out.offset) {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			ipu_pf_set_pause_row(start_params.h264_pause_row);
+
+			/*Update y, u, v buffers in DMA Channels */
+			retval = mxc_pf_start(&start_params.in,
+					&start_params.out);
+			if (retval < 0)
+				break;
+
+			pr_debug("PF_IOCTL_START - processing started\n");
+
+			if (!start_params.wait)
+				break;
+
+			pr_debug("PF_IOCTL_START - waiting for completion\n");
+
+			/* Fall thru to wait */
+		}
+	case PF_IOCTL_WAIT:
+		{
+			if (!wait_event_interruptible_timeout(pf_data.pf_wait,
+							      pf_data.
+							      done_flag == 4,
+							      1 * HZ)) {
+				pr_debug
+				    ("PF_IOCTL_WAIT: timeout, done_flag = %d\n",
+				     pf_data.done_flag);
+				retval = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				pr_debug("PF_IOCTL_WAIT: interrupt received\n");
+				retval = -ERESTARTSYS;
+				break;
+			}
+			pf_data.busy_flag = 0;
+			pf_data.buffer_dirty = true;
+
+			pr_debug("PF_IOCTL_WAIT - finished\n");
+			break;
+		}
+	case PF_IOCTL_RESUME:
+		{
+			int pause_row;
+			pr_debug("PF_IOCTL_RESUME\n");
+
+			if (pf_data.busy_flag == 0) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if (copy_from_user(&pause_row, (void *)arg,
+					   _IOC_SIZE(cmd))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			if (pause_row >= ((pf_data.height + 15) / 16)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			ipu_pf_set_pause_row(pause_row);
+			break;
+		}
+
+	default:
+		printk(KERN_ERR "ipu_pf_ioctl not supported ioctl\n");
+		retval = -1;
+	}
+
+	if (retval < 0)
+		pr_debug("return = %d\n", retval);
+	return retval;
+}
+
+/*!
+ * Post Filter driver mmap function. This function implements the Linux
+ * file_operations.mmap() API function for mapping driver buffers to user space.
+ *
+ * @param       file            struct file *
+ *
+ * @param       vma             structure vm_area_struct *
+ *
+ * @return      0 Success, EINTR busy lock error,
+ *                      ENOBUFS remap_page error.
+ */
+static int mxc_pf_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long size = vma->vm_end - vma->vm_start;
+	int res = 0;
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",
+		 vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&pf_data.busy_lock))
+		return -EINTR;
+
+	/* make buffers write-thru cacheable */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) &
+				     ~L_PTE_BUFFERABLE);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    vma->vm_pgoff, size, vma->vm_page_prot)) {
+		printk(KERN_ERR "mxc_pf: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto mmap_exit;
+	}
+
+	vma->vm_flags &= ~VM_IO;	/* using shared anonymous pages */
+
+mmap_exit:
+	up(&pf_data.busy_lock);
+	return res;
+}
+
+extern void v6_flush_kern_cache_all_l2(void);
+
+/*!
+ * Post Filter driver fsync function. This function implements the Linux
+ * file_operations.fsync() API function.
+ *
+ * The user must call fsync() before reading an output buffer. This
+ * call flushes the L1 and L2 caches
+ *
+ * @param filp          structure file *
+ *
+ * @param dentry        struct dentry *
+ *
+ * @param datasync      unused
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+int mxc_pf_fsync(struct file *filp, struct dentry *dentry, int datasync)
+{
+#if 0
+	if (pf_data.buffer_dirty)
+		v6_flush_kern_cache_all_l2();
+#endif
+	pf_data.buffer_dirty = false;
+
+	return 0;
+}
+
+/*!
+ * Post Filter driver poll function. This function implements the Linux
+ * file_operations.poll() API function.
+ *
+ * @param file       structure file *
+ *
+ * @param wait       structure poll_table *
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+static unsigned int mxc_pf_poll(struct file *file, poll_table *wait)
+{
+	wait_queue_head_t *queue = NULL;
+	int res = POLLIN | POLLRDNORM;
+
+	if (down_interruptible(&pf_data.busy_lock))
+		return -EINTR;
+
+	queue = &pf_data.pf_wait;
+	poll_wait(file, queue, wait);
+
+	up(&pf_data.busy_lock);
+
+	return res;
+}
+
+/*!
+ * File operation structure functions pointers.
+ */
+static struct file_operations mxc_pf_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_pf_open,
+	.release = mxc_pf_release,
+	.ioctl = mxc_pf_ioctl,
+	.poll = mxc_pf_poll,
+	.mmap = mxc_pf_mmap,
+	.fsync = mxc_pf_fsync,
+};
+
+static int mxc_pf_major;
+
+/*!
+ * Post Filter driver module initialization function.
+ */
+int mxc_pf_dev_init(void)
+{
+	int ret = 0;
+	struct class_device *temp_class;
+
+	mxc_pf_major = register_chrdev(0, "mxc_ipu_pf", &mxc_pf_fops);
+
+	if (mxc_pf_major < 0) {
+		printk(KERN_INFO "Unable to get a major for mxc_ipu_pf");
+		return mxc_pf_major;
+	}
+
+	mxc_pf_class = class_create(THIS_MODULE, "mxc_ipu_pf");
+	if (IS_ERR(mxc_pf_class)) {
+		printk(KERN_ERR "Error creating mxc_ipu_pf class.\n");
+		ret = PTR_ERR(mxc_pf_class);
+		goto err_out1;
+	}
+
+	temp_class = class_device_create(mxc_pf_class, NULL,
+					 MKDEV(mxc_pf_major, 0), NULL,
+					 "mxc_ipu_pf");
+	if (IS_ERR(temp_class)) {
+		printk(KERN_ERR "Error creating mxc_ipu_pf class device.\n");
+		ret = PTR_ERR(temp_class);
+		goto err_out2;
+	}
+
+	printk(KERN_INFO "IPU Post-filter loading\n");
+
+	return 0;
+
+err_out2:
+	class_destroy(mxc_pf_class);
+err_out1:
+	unregister_chrdev(mxc_pf_major, "mxc_ipu_pf");
+	return ret;
+}
+
+/*!
+ * Post Filter driver module exit function.
+ */
+static void mxc_pf_exit(void)
+{
+	if (mxc_pf_major > 0) {
+		class_device_destroy(mxc_pf_class, MKDEV(mxc_pf_major, 0));
+		class_destroy(mxc_pf_class);
+		unregister_chrdev(mxc_pf_major, "mxc_ipu_pf");
+	}
+}
+
+module_init(mxc_pf_dev_init);
+module_exit(mxc_pf_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC MPEG4/H.264 Postfilter Driver");
+MODULE_LICENSE("GPL");
-- 
1.5.5.1

